00:00:10 <Feuerbach> an alternative is to pass the required options manually or set GHC_PACKAGE_PATH
00:00:20 <makalu> ok thanks for your help jle` and Feuerbach
00:01:47 <bergmark> does sandbox repl work when you are loading/working on multiple packages at once?
00:02:06 <Feuerbach> in the same sandbox?
00:02:16 <bergmark> yeah
00:02:56 <Feuerbach> it should; it's like an ordinary ghci, just instructed to use a different package db
00:04:00 <bergmark> i realized the other day how nice it is to load everything into a single ghci session :-)
00:10:31 <dmwit> akegalj: http://www.haskell.org/pipermail/glasgow-haskell-users/2014-January/024579.html
00:19:02 <codygman> Are there any simple tutorials for using heist with snap? Perhaps I'm tired (or just slow), but after reading "Heist Template Tutorial" I'm not sure how to apply it in a handler. Or wait.. maybe I was just overthinking... instead of 'B.write "page content"' I bet I can generate the template and output that in the handler.
00:24:02 <akegalj> dmwit: thank you
00:30:50 <romm> Hi. I just noticed something that I probably should've noticed way back. Why is it "instance Monad (State s) where..." and not "instance Monad (State s a) where..." ?
00:33:53 <lieven_> because it's also Monad Maybe and not Monad (Maybe a). Monad takes a type constructor, not a type
00:34:02 <sipa> romm: for the same reason it is instance Monad Maybe
00:34:35 <pavonia> :k Monad
00:34:36 <lambdabot> (* -> *) -> Constraint
00:34:43 <pavonia> :k State s
00:34:43 <lambdabot> Not in scope: type variable `s'
00:34:45 <romm> Let me rephrase :) Why a type constructor?
00:34:45 <sipa> monad actions (values of type Maybe a for example) are not monads
00:35:11 <sipa> as they have an additional type parameter (the return type)
00:37:27 <therp> sipa: oh hi pieter, didn't know you where hanging out here.
00:47:36 <Twey> romm: Because the type parameter changes inside the class definition
00:47:47 <Twey> :t (>>=)
00:47:48 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:48:31 <Twey> romm: You're not interested in the properties of m a, you're interested in the properties of m (when applied to *any* type)
00:49:53 <jle`> is there a way to get to the index of a haddocfrom the Contents?
00:50:40 <Twey> And the point of (>>=) is to talk about how to combine two different (arbitrary) applications of the type constructor, so it doesn't make sense for either one of them to be the type whose instance is being defined
00:50:43 <romm> Twey: Okay, seems to make sense. So when calling a "then" or a "bind" operator, the compiler matches the type "m a" with the type constructor "m" to know which implementation to use?
00:50:51 <Twey> Right
00:50:53 <jle`> romm: you might be able to think of it as type currying/partial application
00:50:57 <jle`> monad is m a
00:51:00 <jle`> so m = Maybe
00:51:03 <jle`> m = State s
00:51:08 <jle`> it doesn't make sense for m = State
00:51:17 <romm> Yeah, I think I got it, thanks guys.
00:51:24 <jle`> m ~ State s, you get m a ~ State s a
00:51:36 <jle`> m ~ Maybe, you get m a ~ Maybe a
00:51:56 <jle`> Reader and Writer are like this too
00:53:19 <romm> Is there an extension of the idea to type pairs? Like "m a b"? Obviously it's not a monad, but is it interesting/useful?
00:54:05 <romm> I understand that you can do something like "m (a,b)". That's not what I mean.
00:54:23 <jle`> well
00:54:43 <jle`> monad transformers commonly are mt m a
00:54:50 <Twey> romm: There are some classes on things of kind ★ → ★, yes, like Category
00:54:53 <jle`> but perhaps more interesting are Category and Arrow typeclasses
00:55:01 <Twey> Er, ★ → ★ → ★
00:55:32 <jle`> where Category c => c a b is some sort of generalized notion of a thing that takes an a and returns a b
00:55:47 <jle`> for example, (->) is an instance of Category
00:55:55 <Twey> Except without the notion of ‘returns’ :þ
00:56:01 <jle`> heh. yeah ><
00:56:02 <Twey> ‘Goes to’, maybe
00:56:11 <jle`> transforms an a into a b?
00:56:21 <jle`> morphs?
00:56:21 <Twey> Graphs are categories, for example, where arrows are the edges
00:56:30 <jle`> links?
00:56:40 <jle`> hm
00:56:41 <Twey> ‘Links a to b’ works, I guess
00:57:28 <jle`> :k (->)
00:57:29 <lambdabot> * -> * -> *
00:57:32 <romm> It's okay guys, you don't have to ELI5 me :)
00:57:53 <jle`> so all instances of Category have to take two types
00:57:58 <jle`> the 'from' type and the 'to' type
00:58:11 <jle`> (->) a b, for example
00:58:29 * hackagebot fay 0.19.0.2 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.19.0.2 (AdamBergmark)
00:58:34 <jle`> ooh a fay update.
00:59:38 <remdezx> Hello! I'm working with ghc api, but I'm getting linker errors. I have 3 projects - 1st dependent to 2nd, and 2nd dependent to 3rd. This 3rd use ghc api (has "-package ghc" ghc flags section in cabal) and I keep getting linker errors in the 1st project. Any ideas how to solve it? http://lpaste.net/99244
00:59:44 <romm> So I'm guessing there's no notion of "class" in haskell? Or, maybe more correctly, the class is "haskell types"?
00:59:55 <adnap> Does anyone have colored GHCI output?
01:00:11 <bergmark> jle`: :-)))
01:00:14 <romm> By "class" I mean in the sense of Categories
01:01:11 <Twey> adnap: You mean like this?  http://www.haskell.org/haskellwiki/GHCi_in_colour
01:02:06 <Twey> romm: You mean, the objects of the category?
01:02:33 <jle`> romm: well typically in OOP...we use 'class' to mean a blueprint/predefined structure for object instantiation
01:02:35 <romm> Twey: Yes.
01:02:37 <Twey> We usually call it ‘Hask’, and yes, it's the set of valid Haskell types
01:02:44 <jle`> oh nvm
01:02:46 <jle`> didnt read.
01:03:07 <romm> Got it, thanks.
01:10:39 <mm_freak> jle`: 'now' does not break semantics…  and indeed, the solution will probably not require events
01:10:48 <adnap> Twey: Yes
01:11:27 <mm_freak> jle`: and yes, i have seen ocharles' asteroids implementation…  it makes sense, but i'm not sure whether it's semantically valid…  ocharles has written a few custom wires for the game
01:11:40 <mm_freak> jle`: in general ocharles has the right intuition though
01:11:54 <adnap> Twey: There is an example using sed and a suggestion: "An existing tool, HsColour, could be modified..." It doesn't seem like there's anything good yet.
01:13:31 * hackagebot email-validate 2.0.0 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-2.0.0 (GeorgePollard)
01:16:06 <adnap> Twey: The example shell script doesn't work correctly in my terminal. It starts coloring everything with a dark grey background after I ask for the type of a function
01:19:34 <jle`> mm_freak: he seems to manually step through wires...within wires
01:20:01 <jle`> i think?
01:20:03 <jle`> i'm not totally sure
01:20:07 <mm_freak> jle`: wire combinators do that
01:20:20 <osa1_> I have a function named "fun" in my module, and I want to import a function with same name from another module, without importing the whole module with qualified name .. is this possible?
01:20:23 <jle`> they do that for me so i don't have to do it manually you mean?
01:20:43 <mm_freak> osa1_: how would that work?
01:20:54 <mm_freak> osa1_: when you write "fun", which one should the compiler pick?
01:20:55 <osa1_> mm_freak: renaming imported functions or something like that
01:21:08 <mm_freak> osa1_: renaming is not supported in haskell
01:21:16 <mm_freak> but you can import modules multiple times
01:21:22 <mm_freak> import X hiding (fun)
01:21:33 <mm_freak> import qualified X as X
01:22:02 <mm_freak> jle`: in general wire combinators step their argument wires
01:22:13 <osa1_> mm_freak: aha! that worked. thanks.
01:22:14 <mm_freak> this is about implementation
01:22:22 <jle`> mm_freak: ah.
01:22:27 <jle`> but should i have to do it explicitly, like he?
01:22:34 <mm_freak> jle`: in general no
01:23:02 <jle`> hm. should i be passing wires through my wires often? or is that only for special cases mostly
01:23:14 <jle`> i notice that in some of the Control.Wire functions...they take events that contain Wires
01:23:24 <jle`> this is kind of a whole other dimension I didn't even know existed heh.
01:23:44 <jle`> well, I remember seeing a talk about FRP to control user interfaces, and they did things like this.
01:23:45 <mm_freak> wires as arguments are generally only needed for switching and routing
01:23:56 <jle`> hm ok.
01:24:05 <jle`> thanks
01:24:11 <jle`> hope i am not too much of a bother with these questions :)
01:24:56 <jle`> i rewrite my entire program a couple times a day at least hoping to finally hit upon the one true frp way to do things :)
01:25:04 <Twey> adnap: I would go the HsColour route
01:26:12 <adnap> Twey: Someone did, but it doesn't work for me: http://www.reddit.com/r/haskell/comments/144biy/pretty_output_in_ghci_howto_in_comments/
01:27:00 <adnap> I see no color and [1..10] doesn't work for some reason I think has to do with the imports. Also, the author claims that the config is unloaded when one loads a module in ghci
01:28:12 <sipa> therp: hmm?
01:31:40 <zett_zelett> > let str = "putStrLn (\"let str = \" ++ show str ++ \" in \" ++ str)" in putStrLn ("let str = " ++ show str ++ " in " ++ str)
01:31:41 <lambdabot>  <IO ()>
01:31:48 <zett_zelett> Oh, right.
01:32:00 <merijn> Oooh!
01:32:08 <merijn> 7.8 has overloaded lists?!
01:33:07 <zett_zelett> What are overloaded lists?
01:33:22 <randomclown> unholy abuses of list syntax probably
01:34:34 <quchen> zett_zelett: [1,2,3] :: Vector Int
01:34:55 <quchen> It wraps all literal "[...]" lists with "fromList".
01:35:40 <quchen> It's similar to OverloadedStrings, or how "1" actually stands for "fromIntegral (1 :: Integer)".
01:36:08 <quchen> randomclown: List syntax is unholy abuse of list syntax.
01:36:19 <zett_zelett> I don’t understand, but that’s okay.
01:36:26 <zett_zelett> I’m so happy, I wrote my first quine.
01:36:27 <quchen> 1:2:3:[] is ugly to write, that's why there is [1,2,3] syntax.
01:36:47 <makalu> has anyone used attoparsec for parsing a programming language?
01:37:47 <merijn> zett_zelett: Well, basically if you wanna write a Set in your code, you're stuck writing "fromList [1,2,3,4,5]" overloaded lists extension would let you write "[1,2,3,4,5]" and the type inferrer will infer the "fromlist"
01:38:10 <merijn> makalu: attoparsec is more parsed at binary, you probably want parsec or trifecta for parsing programming languages
01:38:24 <randomclown> quchen: heh
01:38:29 <merijn> s/more parsed/more aimed
01:38:38 <AshyIsMe> has anyone tried out vindinium.org yet?
01:38:46 <AshyIsMe> im trying to make a bot for it but failing at monads: https://github.com/AshyIsMe/vindinium-starter-haskell/blob/master/src/Bot.hs#L21
01:38:56 <quchen> Comic Sans. Eject
01:39:06 <randomclown> merijn: I'm waiting for the OverloadedFunctions extension
01:39:22 <makalu> merijn: that's what I thought too but maybe there's someone who has tried it.
01:39:23 <zett_zelett> That’s nice.
01:39:31 <AshyIsMe> the compile error i get is:     Couldn't match expected type `Vindinium Dir' with actual type `Dir'
01:39:35 <AshyIsMe> on line 21
01:40:48 <merijn> AshyIsMe: Bot is a type synonym for "type Bot = State -> Vindinium Dir"
01:41:00 <merijn> AshyIsMe: You use getDirection, which returns a a Dir
01:41:14 <merijn> AshyIsMe: You probably want a "return" in there somewhere
01:41:29 <merijn> AshyIsMe: Also, you should use where instead of let/in
01:42:19 <av> hello
01:42:30 <merijn> AshyIsMe: Since you have the question "How do I put the Dir from getDirection into the Vindinium monad?" in the source, "return" is the correct to put something in *any* Monad
01:42:46 <av> I'm aware of the "cons" operator, which is very useful -- is there anything like it for tuples?
01:42:57 <tdammers> av: how would that work?
01:43:13 <tdammers> av: a tuple has a fixed number of element encoded in its type
01:43:21 <AshyIsMe> merijn: ah cool, thanks
01:43:33 <AshyIsMe> so how does return know which monad to put it into?
01:43:36 <av> reason: I'd like to construct, say, a pair, in point-free notation, is there anything I can use without defining my own?
01:43:36 <dv-> > (,9) 2
01:43:37 <lambdabot>  (2,9)
01:43:43 <AshyIsMe> or is that type inference magic?
01:43:45 <av> ah, perfect
01:43:51 <av> dv-: thanks
01:43:53 <tdammers> tuple sections, that is
01:44:10 <AshyIsMe> i probably need to read the monad chapter of lyah actually
01:44:14 <merijn> AshyIsMe: Try something like: http://lpaste.net/99245
01:44:31 <tdammers> AshyIsMe: it's type inference, but not really magic
01:44:38 <merijn> AshyIsMe: Yes, the type inference the same way "show" is
01:44:40 <merijn> :t show
01:44:41 <lambdabot> Show a => a -> String
01:44:44 <merijn> :t return
01:44:45 <lambdabot> Monad m => a -> m a
01:44:59 <tdammers> AshyIsMe: the compiler knows the type of the do expression and can derive the type of the return part from that
01:45:08 <merijn> AshyIsMe: The only difference is that instead of inferring the argument (like show), return infers the result
01:45:21 <tdammers> it's more like the inference for Read
01:45:23 <merijn> > return 4 :: Maybe Int
01:45:24 <lambdabot>  Just 4
01:45:32 <merijn> > return 4 :: [Int]
01:45:33 <lambdabot>  [4]
01:46:05 <merijn> dv-: You forgot the coolest example of TupleSections
01:46:09 <merijn> > (2,,9) 3
01:46:11 <lambdabot>  (2,3,9)
01:46:27 <FireFly> > map (+1) (return 4)
01:46:28 <lambdabot>  [5]
01:46:30 <merijn> > (2,,9,,10) 3 4
01:46:31 <lambdabot>  (2,3,9,4,10)
01:46:41 <merijn> <3 TupleSections
01:47:04 <FireFly> (the type of `return 4` there is inferred from it being used where `map` expects a list of something)
01:49:16 <AshyIsMe> merijn: cheers, ive got new errors but let me experiment a bit before asking again
01:51:43 <randomclown> when cabal builds a program, does it use -O2?
01:53:01 <randomclown> is there a built in way to profile wiht cabal configs?
01:54:37 <merijn> randomclown: You can specify GHC flags in your cabal file
01:55:00 <merijn> randomclown: See: https://github.com/merijn/posix-pty/blob/master/posix-pty.cabal#L27-L28
01:55:15 <supki> randomclown: it's -O by default
01:55:25 <supki> I think cabal check even warns if you use -O2 explicitly
01:55:58 <supki> because it's longer to compile and stuff
01:56:56 <randomclown> merijn: how do I get the profiling libraries for my dependencies?
01:58:41 <merijn> randomclown: Unfortunately you will have to reinstall all of them using profiling :\
01:58:54 <merijn> randomclown: You probably want to add this in your ~/.cabal/config "library-profiling: True"
01:59:06 <randomclown> merijn: I'm using the sandbox
01:59:40 <randomclown> can I just delete the .cabal-sandbox and cabal install --enable-library-profiling -- etc etc
01:59:44 <merijn> randomclown: You'll still want to set that flag, but that means you should probably just nuke the sandbox and reinitialise it after setting that flag, which will rebuild everything with profiling
02:00:46 <randomclown> right, I see
02:03:36 <merijn> @remember avdi It's easy to get a reaction out of FP zealots... but at least it's the SAME reaction every time!
02:03:36 <lambdabot> Done.
02:06:58 <mjrosenb> @hoogle Maybe (a -> b) -> a -> Maybe b
02:06:58 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
02:06:59 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
02:06:59 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
02:07:13 <AshyIsMe> merijn: so is using where a preferred stylistic thing or does it have other reasons for being preferred?
02:07:37 <mjrosenb> is a <*> b == b <**> a?
02:07:56 <mjrosenb> also, lambdabot: none of those things match what I asked for :-/
02:08:32 <merijn> AshyIsMe: Stylistic thing, let and where are *mostly* interchangeable
02:09:32 <merijn> AshyIsMe: The only real difference is that a where clause can cover multiple guards and let can be used if your binding uses a previously bound monadic result (i.e. "do { x <- foo; let bar = something x }", you can't do that using 'where', because 'x' is not in scope)
02:10:06 <randomclown> merijn: so to switch between profile/non-profile mode I'll need to cabal configure right?
02:10:08 <merijn> AshyIsMe: In general 'where' is almost always better, stylistically, so unless you have to use let due to monadic results, you should probably use where
02:10:22 <merijn> randomclown: I'm not sure, can't hurt, though
02:10:29 <merijn> randomclown: Better safe than sorry ;)
02:11:16 <AshyIsMe> merijn: i may have to use it for monadic results in this case, i'll paste again in a sec
02:14:30 <merijn> AshyIsMe: The result being monadic is irrelevant, you only need the 'let' if you use a monadic result in your binding
02:19:57 <mjrosenb> merijn: well, let is a special monadic syntax, right?
02:25:35 <tdammers> mjrosenb: not really, no. let is available outside of do blocks, but the syntax rules are subtly different
02:26:16 <Twey> What triggers Gloss to redraw, exactly?  I'm using playIO, and my ‘world’ contains an MVar, so I want to update every so often even if the world value hasn't changed per se, but ‘const return’ for the tick handler doesn't seem to be enough to trigger a redraw
02:26:16 <mjrosenb> tdammers: that's what I mean
02:26:33 <mjrosenb> outside, it is let BINDINGS in expr, inside, it is just let BINDINGS
02:26:57 <tdammers> semantically it's the same though, once you desugar
02:27:04 <Twey> You can use the normal one in a do-block too.  There's just sugar to save you a level of indentation.
02:27:34 <Twey> (since otherwise you might need many nested lets, which would shift your code across the page quite quickly)
02:28:00 <mjrosenb> Twey: but they aren't quite the same thing, are they?
02:29:08 <mjrosenb> Twey: with |let BINDINGS|, you introduce BINDINGS for the rest of the do block, but with |let BINDINGS in EXPR|, you introduce bindings for the single expression which needs to be a monadic value, which won't get bound to anything.
02:29:29 <mjrosenb> unless you say |PAT <- let BINDINGS in EXPR|
02:30:04 <tdammers> mjrosenb: but once you desugar |let BINDINGS; expr|...
02:31:11 * mjrosenb tries to remember how do blocks desugar
02:31:34 <tdammers> do { let x = 23; return x }
02:31:38 <tdammers> let x in return 23
02:31:50 <ion> do { let { x = 23 }; return x }
02:32:15 <ion> let x = 23 in do { return x }
02:32:20 <mjrosenb> do { x <- foo; y <- bar; z } desugars into foo >>= (\x -> bar >>= (\y -> z)) ?
02:32:33 <ion> yes
02:33:34 <ion> do { x <- foo; y <- bar; z }
02:33:41 * hackagebot imagemagick 0.0.3.3 - bindings to imagemagick library  http://hackage.haskell.org/package/imagemagick-0.0.3.3 (AlexanderVershilov)
02:33:43 <ion> foo >>= \x -> do { y <- bar; z }
02:33:53 <ion> foo >>= \x -> bar >>= \y -> do { z }
02:33:57 <ion> foo >>= \x -> bar >>= \y -> z
02:36:29 <mjrosenb> anyhow, my point was that let inside of a do block can be different from let outside of a do block, even if they are only different by a simple syntatic transform.
02:38:31 <bernalex> how does <|> work? I have a function nulldot s = if null s then "." else s -- and I wanted to replace (foo . nulldot) bar, with foo (bar <|> "."), but that doesn't work (it uses bar not "." when it should use "."). ideas?
02:39:09 <ion> Which (<|>)?
02:39:19 <ion> That is the type of bar?
02:39:30 <bernalex> "" <|> "testest" in ghci "works" (gives me testest)
02:39:33 <ion> s/That/What/
02:39:35 <bernalex> ion: Control.Applicative
02:39:41 <tdammers> mjrosenb: ok, yes, that is correct. It's just that the difference appears much larger than it actually is.
02:39:42 <bernalex> ion: FilePath
02:39:42 <ion> bernalex: Which instance?
02:39:53 <bernalex> ion: instance of what?
02:40:04 <bernalex> nulldot ::  String -> String
02:40:06 <bernalex> nulldot s = if null s then "." else s
02:40:16 <bernalex> is the function I am trying to replace using <|> from Control.Applicative.
02:40:18 <ion> > "bar" <|> "."  -- This is how the list instance works.
02:40:19 <lambdabot>  "bar."
02:40:27 <k00mi> bernalex: is that a parser?
02:40:35 <bernalex> k00mi: is what a parser?
02:40:41 <bernalex> > "" <|> "."
02:40:42 <lambdabot>  "."
02:40:45 <k00mi> bernalex: what you're trying to write
02:40:54 <k00mi> nevermind
02:40:57 <bernalex> k00mi: not really.
02:41:17 <bernalex> ion: I have (canonicalizePath . nulldot) dir
02:41:30 <bernalex> ion: so shouldn't this be roughly equivalent to canonicalizePath (dir <|> ".")?
02:41:48 <mm_freak> bernalex: are you perhaps confusing (<|>) with (</>)?
02:42:00 <mm_freak> (<|>) does something hugely different
02:42:12 <bernalex> IDR what the latter does. doing "" <|> "blah" in ghci does what I want my program to do though
02:42:25 <ion> bernalex: (<|>) for strings is (++)
02:42:36 <bernalex> ion: ohhhh
02:42:43 <mm_freak> "abc" </> "def" = "abc/def" on unix-like systems
02:43:05 <bernalex> well, what I want to do is replace my nulldot s = if null s then "." else s function
02:43:58 <bernalex> right. just ran "test" <|> "test" in ghci. obviously not what I want.
02:44:01 <FireFly> @ty (</>)
02:44:02 <lambdabot>     Not in scope: `</>'
02:44:02 <lambdabot>     Perhaps you meant one of these:
02:44:02 <lambdabot>       `<>' (imported from Data.Monoid),
02:44:03 <bernalex> tohugh, TBF "" ++ "." works too.
02:44:27 <mm_freak> bernalex: the empty string is the identity for string concatenation…  you probably want another identity here
02:44:29 <FireFly> oh, never mind
02:44:33 <bernalex> but "test" </> "testest" doesn't exactly look more right
02:45:09 <mm_freak> bernalex: nullDot = maybe "." id
02:45:18 <bernalex> mm_freak: I'm fine just using my nulldot s = if null s then "." else s function though. I just thought/assumed there was a short/easy way of doing exactly that
02:45:58 <ion> maybe "." id = fromMaybe "."
02:46:01 <Twey> mjrosenb: do let x = y; z  desugars exactly to  let x = y in z
02:46:12 <ion> do let { x = y }; z
02:46:37 <mm_freak> bernalex: well, special-empty-strings have been such a bad idea in PHP…  you don't get predefined functions to reintroduce stringly typing into haskell =)
02:46:38 <bernalex> using maybe isn't exactly more readable than just doing if null s then "." else s
02:46:49 <Twey> ion: I don't know why that's necessary in λb
02:46:53 <mm_freak> bernalex: it is to a haskell programmer
02:47:03 <bernalex> mm_freak: special empty strings? it's just an empty list of Chars, no?
02:47:16 <ion> twey: s/λb/Haskell/
02:47:18 <mm_freak> bernalex: empty strings with special semantic meaning
02:47:34 <ion> twey: Because otherwise it parses as do let { x = y; z }
02:47:50 <bernalex> it's not more special than checking for any empty list
02:47:58 <Twey> Oh, right, I'm thinking of something else apparently
02:48:26 <mm_freak> bernalex: to give the empty list a special meaning
02:48:39 <mm_freak> in this case:  "if empty string, then use the current directory"
02:48:40 <Twey> bernalex: The problem is that you've introduced a magic value that has different behaviour to other values of that type, without distinguishing it in the type system
02:49:03 <mm_freak> bernalex: this is a bad coding style, and haskell doesn't support it very well
02:49:24 <Twey> bernalex: So you effectively introduce an ad-hoc type: you now have ‘string’ and ‘string where the empty string should be interpreted as "."’, but you're not tracking it in the actual type-system
02:50:22 <Twey> The purpose of the Maybe type is precisely to add a ‘special’ value to an existing type for operations like this
02:50:42 <bernalex> I see your point.
02:51:44 <mm_freak> bernalex: such a semantics is unnatural…  in fact in a deep mathematical sense
02:53:20 <mm_freak> you can still provide a command line interface with "no arguments is special", but you should translate it into Maybe FilePath or Maybe [FilePath] or whatever is appropriate
02:54:44 <mm_freak> although even in command line interfaces i follow some basic algebraic rules…  this proved really useful
02:55:54 <ski> hm, `currentDir' should be left unit to `(</>)', for relative paths, no ?
02:56:31 <ski> (i agree with wanting to avoid defaulty representations internally, though)
02:57:03 <mm_freak> ski: abc </> (currentDir </> def)
02:57:31 <mm_freak> through a canonical-path lens the identity of (</>) is "."
02:58:40 <bernalex> mm_freak: I don't see how maybe "." id is supposed to work with my strings though
02:59:18 <bernalex> you mean that dir should be a Maybe FilePath, and be Nothing instead of "" when it's empty/
02:59:24 <mm_freak> bernalex: well, i'm assuming that you get this empty string from some kind of user interface (config file, command line args, etc.)
02:59:31 <bernalex> no
03:00:01 <bernalex> well, kind of
03:00:18 <mm_freak> well, yes, that's what i mean
03:00:29 <bernalex> I get e.g. "../../foo". then takeDirectory is ran on this.
03:00:52 <bernalex> oh wait
03:01:11 <bernalex> takeDirectory doesn't work like the function I had previously. it actually figures out the . itself.
03:01:33 <bernalex> oh. right. problem solved, lol.
03:02:01 <ski> (in Prolog, interpreting some values in some specific ways, and then "everything else" in some "default" way, is known as a "defaulty representation", and is to be avoided, when possible)
03:04:23 <ski> (btw, i'm not sure what the point of `abc </> (currentDir </> def)' was. and yes, i meant with equality up to the intended interpretation of paths)
03:04:36 <Twey> How does that make sense in Prolog?
03:04:45 <ski> which ?
03:05:15 <Twey> Not having ‘defaulty’ representations.  If you have a symbol in a place, you have to take every possible symbol there.
03:06:15 <ski> well, one example is representing arithmetical expressions with variables
03:06:39 <ski> so `E0 + E1' represents addition, `E0 * E1' represents multiplication, and so on
03:06:56 <ski> and then `V' represents a variable, for any atom `V', e.g. `x' and `y' represents variables
03:07:05 <ski> the latter is an example of a defaulty representation
03:07:13 <Twey> The point of the example was that currentDir isn't an identity: currentDir </> def is distinguishable from def, because if you prepend something to it you get quite a different path ("abc" </> "def" = "abc/def", "abc" </> (currentDir </> "def") = "abc/path/to/current/directory/def")
03:07:16 <ski> it leads to lots of grief
03:07:49 <Twey> ski: So what's the alternative to that, given the lack of a type-system?
03:07:49 <ski> it's much better to represent variables as `var(Name)', where `Name' is some kind of identifier (atom or integer, e.g.)
03:07:55 <Twey> Ah, right
03:08:13 <Twey> But what do you do with e.g. notvar(Name)?
03:08:36 <ski> this means that you don't have to use if-then-else (or worse, cuts), meaning you avoid lots of opportunities for bugs *and* get more efficient code (due to indexing)
03:08:52 <Twey> Don't you have to have a ‘defaulty’ behaviour for all the other symbols that aren't ruled out by the type system?
03:09:22 <ski> well, the one thing that is worse than a defaulty representation is a nonground representation (not quite what you asked above, but slightly related)
03:09:56 <ski> in a nonground representation, one would represent variables not by concrete datums like `x' or `var(x)', but by an uninstantiated logic variable like `X1'
03:10:34 <ski> to detect this, one needs to use lots of nonvar/1 and var/1 (this was the connection), and generally lots of conditionals or cuts as well -- and it's every hairier to debug
03:11:41 <ski> anyway, re `notvar(Name)', you'd typically just assume that `Name' is already instantiated (or, in case where the code wouldn't fault out when it isn't, add an explicit assertion)
03:11:58 <ski> better would be to have static checking of this. Mercury does that
03:13:14 <ski> (note i didn't say "error out", because a run-time instantiation problem typically is not because the program is logically wrong, but because the implementation isn't good enough to compute the logically correct solution(s). hence fault rather than error)
03:14:54 <mjrosenb> ski: since you seem to know about it, prolog is more than just a large, efficent unification engine, right?
03:15:01 <ski> (sometimes there's good practical reasons for an implementation to refuse to compute the solutions, unless you explicitly ask for it, though. one possible example could be when there's very many, or infinitely many, solutions (to a query with small inputs, say))
03:15:34 <ski> Prolog systems also support non-determinism, in a nice declarative fashion, yes
03:15:44 <ski> typically in the form of backtracking
03:16:01 <ski> (well, *angelic* non-determinism, i.e.)
03:16:51 <ski> you can reason about Haskell programs using an equational logic
03:17:02 <ski> you can reason about Prolog programs using predicate logic
03:18:49 <ski> so, apart from unification (an implementation of equality) and non-determinism (implementing disjunction, more or less), Prolog can also be said to implement (a fragment) of the rest of predicate logic, so conjunction, implication, universals, and predicates/relations. also function symbols and terms constructed with them
03:18:59 <ski> mjrosenb : does that help ?
03:19:39 <mjrosenb> ski: kind of.
03:20:17 <mjrosenb> i've written a bunch of prolog, but none of the tutorals i've seen actually go into how to do useful things like i/o :-\
03:21:23 <ski> (specifically, the fragment that Prolog allows divides formulae into two categories : "clauses" and "goals". "clauses" may use conjunction, universals, and implication. "goals" may use conjunction,disjunction,existentials,equality)
03:21:55 <ski> (an implication clause contains a clause and a goal. a goal may not contain a clause)
03:22:13 <ski> well, I/O in Prolog is ugly, side-effecting
03:22:22 <ski> I/O in Mercury is much nicer
03:22:24 <Fuuzetsu> Prolog is ugly ;(
03:22:42 <Kaidelong> Aww, I love prolog
03:22:46 <ski> (it's similar to I/O in Clean. both using uniqueness on a "real world" token that is threaded around)
03:22:51 <Fuuzetsu> stop liking what I don't like
03:23:06 <ski> Prolog is cool, but it is old, and it shows
03:23:22 <Kaidelong> kind of like SNOBOL
03:23:37 <ski> it doesn't have any proper module system. what exists in implementations is kind of an ugly fit due to this
03:23:39 <Axman6> Ada is old, and it shows, but it's still cool
03:23:47 <Axman6> also also quite modern
03:23:57 <Axman6> s/also/it's
03:24:17 <ski> also, it doesn't cleanly support higher-order programming (you can do it, but there's an amount of pain involved that shouldn't be necessary in a clean design)
03:24:25 <Kaidelong> ^
03:24:53 <Kaidelong> I think higher order logic (constructing things over predicates) is a little harder to do than higher order functions though
03:25:09 <ski> (and the excuse for higher-order programming doesn't cleanly interact with the excuse for modules)
03:25:50 <Kaidelong> actually I've found it easier to translate higher order logic to Haskell than to Prolog in the past
03:26:58 <ski> Mercury has a proper (though not advanced like in the MLs) module system, and supports higher-order programming (though it's somewhat awkward and inflexible, it doesn't involve strange illogical hickups like in Prolog)
03:27:00 <Kaidelong> [a] is a set of solutions of a type a, you can parameterize [a] with some t -> [r]
03:27:24 <Kaidelong> essentially through >>=
03:27:40 <ski> Kaidelong : the problem with that is that each distinct mode of a predicate becomes a separate function
03:27:42 <xplat> agh, it's colder than beelzebub's butthole
03:28:08 <ski> with Prolog and Mercury, i can write the code for that predicate *once*, instead of having to (essentially) repeat it once for every mode of use
03:28:13 <xplat> wrong window :/
03:29:24 <xplat> ski: the main problem with that is that often running an algorithm backwards doesn't give a good algorithm for a backwards problem
03:29:41 <ski> (it's nice that Mercury also supports functions, including multi-moded functions. you can e.g. say `f([0,1] ++ Xs) = ..Xs', running the ordinary function (++)/2 backwards there in the "pattern")
03:30:03 <xplat> but it's really nice for quick-and-dirty mockups
03:30:47 <ski> xplat : Mercury allows you to specify an alternate algorithm for a mode (though you must write a promise pragma to the compiler that it is semantically equivalent to the other code for the predicate)
03:31:14 <xplat> ski: ah, that's nicer than prolog then
03:31:46 <ski> anyway, Prolog has side-effects. Mercury has no side-effects, it's "pure declarative"
03:33:24 <Kaidelong> ski: Mercury does have side effects though, they're not even encapsulated the same way haskell ones are, are they? Uses linear logic in the type system, like Clean
03:33:39 <Kaidelong> single-use references
03:33:47 * hackagebot safe 0.3.4 - Library for safe (pattern match free) functions  http://hackage.haskell.org/package/safe-0.3.4 (NeilMitchell)
03:34:22 <Kaidelong> amounts to "pure" in the same way haskell amounts to it though because impure stuff shows up in the type
03:36:07 <ski> (a) linearity is not the same as uniqueness; (b) plain Mercury (including I/O and update-in-place arrays) doesn't have side-effect; but yes, (c) mainly for purposes of wrapping FFI there is a notion of "impure" (and "semipure") predicates and functions (which is transitively contagious, unless promised away)
03:37:23 <ski> (uniqueness is about whether a value (or reference to it) have been duplicated *yet*. linearity is about whether it may still be duplicated in the future)
03:37:32 <Kaidelong> ski: So they have some implementation of the proposal to unify IO and ST?
03:38:52 <ski> a predicate that does I/O is just a predicate that takes two extra arguments representing the "before" and "after" state of the real world
03:39:06 <ski> similarly for update-in-place on arrays
03:39:23 <Kaidelong> oh that's the same as I understood it then
03:39:39 <Kaidelong> and "real world" arguments/results have special considerations in the type system
03:40:30 <ski> for `ST s a', one can think of it as being decomposed into `Store s -> (Store s,a)' (the `Store s' part being uniquely passed around). so an "ST"-predicate is a predicate that threads around a `store(S)' uniquely
03:41:01 <ski> instead of `runST :: (forall s. ST s a) -> a', then basically have something like `newStore :: exists s. Store s'
03:41:15 <ski> (they have both universals and existentials, yes)
03:41:37 <ski> Kaidelong : no special consideration in the type system
03:41:57 <ski> not really any special consideration in the inst/mode & determinism system either
03:42:15 <Kaidelong> ski: really? I thought the mercury type system had features Haskell's didn't
03:42:47 <ski> in the code generation phase, a `RealWorld' (known as `io.state') and a `Store s' (really `store.store(S)') is treated specially, by passing nothing
03:43:07 <ski> Kaidelong : well, existentials, i suppose
03:44:09 <ski> (also, for abstract data types with user-defined equality, the abstract type and the representation type are cleanly distinguished from each other, unlike in Haskell)
03:45:10 <ski> (this has to be done because equality, (=)/2, has special status, must represent actual equality, unlike `(==)' in Haskell)
03:46:02 <ski> Mercury does have type classes, but it doesn't have higher-order types (every type variable has kind `*')
03:46:16 <Kaidelong> mm, when does == not represent actual equality?
03:46:30 <Twey> ski: … no lists?
03:47:01 <Kaidelong> that means no higher kinded polymorphism
03:47:13 <ski> and related to existentials, computations can also compute constraints, not only consume them. so you can express stuff like `frob :: forall a. C a => Foo a -> exists b. D a b *> Bar a b', where the `D a b' constraint is computed by this operation
03:47:16 <Kaidelong> which I guess explains in part why IO is not encapsulated
03:47:27 <Kaidelong> since haskell relies on higher kinded polymorphism for Monad
03:47:51 <ski> Twey : `type list(T) ---> [] ; [T|list(T)].', `T' has kind `*', list/1 has kind `(*) -> *'
03:48:05 <ski> every type *variable* has kind `*'
03:48:08 <Twey> Oh
03:48:17 <ski> (same as in SML and OCaml)
03:48:23 * Twey nods.
03:48:51 <ski> Kaidelong : *nod*
03:50:22 <ski> Kaidelong : "when does == not represent actual equality?". when you do `data Strange = NAN; instance Eq Strange where NAN == NAN = False'
03:50:48 <Twey> > (0/0) == (0/0)
03:50:49 <lambdabot>  False
03:51:07 <ski> doing this may perhaps break the implicit preconditions on some library functions, but it won't break the language semantics in itself
03:51:14 <ski> the same doesn't hold for Mercury
03:51:31 <Kaidelong> ski: so you mean when (==) does not compare actual representations but is defined to match the abstract meaning
03:51:54 <Kaidelong> I am annoyed by that too
03:51:58 <ski> (=)/2 isn't just interpreted as "any binary relation", but as "equality", inherently in the declarative semantics of the language
03:52:06 <Twey> More, when it does neither
03:52:36 <Twey> Non-representational (==) is pretty reasonable e.g. on Set
03:53:18 <ski> Kaidelong : well, let's say you implement finite subsets as lists of elements (possibly with duplicates, say)
03:54:09 <ski> so, you do something that looks a bit like `newtype Set a = MkSet [a]' .. *except* that the constructor `MkSet' here isn't guaranteed to be injective !
03:54:55 <ski> this means that matching on `MkSet as' is (conceptually) non-deterministic, you don't know which of the potentially many different representations of the abstract value that you're going to get
03:55:49 <greg> concurrent haskell is deterministic?! wow
03:55:55 <ski> so, in the end you will (usually) then have to *promise* that regardless of what representation of the inputs you get, the representation of the output will still represent the same value
03:56:15 <Axman6> greg: parallel haskell is, not concurrent
03:56:33 <Kaidelong> greg: this wasn't about concurrency to begin with anyway
03:56:46 <greg> ok
03:58:05 <Kaidelong> ski: essentially the problem is that because MkSet doesn't preserve (x :: [a] /= y :: [b]), for certain x and y, (==) isn't really equality at the machine level?
03:58:16 <Kaidelong> That's kind of what I already understood, just checking if you did mean that
03:58:28 <ski> (hm, some variants of concurrency can be (essentially) deterministic, when there's a monotone accumulation of information. e.g. when using dataflow variables (more or less logic variables used in a concurrent system) as in Oz, as mentioned in CTM)
03:58:50 * hackagebot crypto-pubkey-openssh 0.2.4 - OpenSSH keys decoder/encoder  http://hackage.haskell.org/package/crypto-pubkey-openssh-0.2.4 (FedorGogolev)
03:59:26 <ski> Kaidelong : yes, the representation equality is too fine-grained. hence we want to use a more coarse-grained equality
04:00:28 <ski> Kaidelong : so, we provide a relation that we promise is an equivalence relation, and that effectively ("magically") determines to which extent our "data constructor" isn't injective
04:02:01 <ski> <http://www.mercurylang.org/information/doc-latest/mercury_ref/User_002ddefined-equality-and-comparison.html> explains user-defined equality
04:03:21 <ski> (e.g. see the note "If `equalitypred' is not an equivalence relation, then the program is inconsistent: its declarative semantics contains a contradiction, because the additional axioms for the user-defined equality contradict the standard equality axioms. That implies that the implementation may compute any answer at all (see Semantics), i.e. the behaviour of the program is undefined.")
04:12:20 <Kaidelong> given how logical languages work I guess that shouldn't surprise anyone
04:19:44 <AshyIsMe> oh wow, cabal repl is sweet
04:26:43 <Kaidelong> what does cabal need a repl for?
04:27:20 <ivanm> Kaidelong: "cabal repl" works with the sandbox feature to bring in the packages you specified in the .cabal file into ghci
04:27:32 <Kaidelong> oh okay
04:27:35 <dcoutts_> it's orthogonal to the sandbox feature
04:27:54 <ivanm> dcoutts_: oh, my mistake then
04:28:32 <dcoutts_> it takes the ghc environment you would get for cabal build, and starts ghci with that environment
04:29:03 <dcoutts_> so if you're using a sandbox then it will of course make use of that, just as build does
04:29:26 <dcoutts_> (cabal build & cabal repl share 90% of the same code path)
04:29:57 <ivanm> dcoutts_: the main difference being which executable is called (+ cabal build being able to work with other compilers)?
04:30:18 <ivanm> hmmmm... does cabal repl theoretically work with hugs, or is it hard-coded for ghci?
04:31:06 <dcoutts_> the compiler-independent bits would allow for it, however there's no support in the compiler-specific bits other than for ghc currently
04:31:06 <makalu> I have an IO action that has a polymorphic type in one internal action. It's doesn't take or return a value of that type. How do I pass that type inside?
04:31:19 <dcoutts_> ivanm: so adding hugs support is possible
04:31:26 <ivanm> makalu: with asTypeOf ?
04:31:35 <ivanm> makalu: an example might help us understand
04:31:38 <ivanm> dcoutts_: *nod*
04:31:45 <dcoutts_> ivanm: as it happens, it does not call ghci, it calls ghc --interactive
04:31:53 <ivanm> is there a difference?
04:32:00 <dcoutts_> usually no
04:32:23 <dcoutts_> just means we don't have to find ghci, since we already found ghc
04:34:06 <ivanm> *nod*
04:36:04 <makalu> ivanm: it worked but it's quite ugly
04:36:06 <makalu> thank you
04:36:24 <ivanm> makalu: paste it up somewhere?  Maybe it's a matter of refactoring it a bit
04:36:49 <ivanm> (though I've sometimes used phantom parameters to functions for tests, etc. just to set a type)
04:37:14 <ivanm> > show . (`asTypeOf`(3::Float)) . read "5"
04:37:15 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
04:37:16 <lambdabot>    arising from a use of `M142499048487286059126984.show_M1424990484872860591...
04:37:16 <lambdabot>  The type variable `a0' is ambiguous
04:37:16 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
04:37:16 <lambdabot>  Note: there are several potential instances:
04:37:23 <ivanm> > show . (`asTypeOf`(3::Float)) . read $ "5"
04:37:24 <lambdabot>  "5.0"
04:37:33 <ivanm> > show . read $ "5"
04:37:34 <lambdabot>  "*Exception: Prelude.read: no parse
04:38:07 <ion> > (show . (:: Integer) . read) "5"  -- I wish this sugar existed.
04:38:08 <lambdabot>  <hint>:1:10: parse error on input `::'
04:38:16 <makalu> sorry, I can't paste proprietary code
04:38:29 <ivanm> makalu: can you make a similar example?
04:38:34 <makalu> I'll try
04:38:44 <ivanm> ion: hmmm, that might be nice
04:43:55 * hackagebot instrument-chord 0.1.0.5 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.5 (AlanHawkins)
04:45:10 <ivanm> that package looks interesting
04:45:40 <makalu> ivanm: super minimal example http://lpaste.net/99249
04:47:05 <ivanm> makalu: the other possibility is instead to have named variants of get, and pass those in
04:47:24 <ivanm> getInt32 :: IO Int32; getInt32 = get
04:48:12 <ivanm> bar withGet = void (withGet >>= doSomethingWith)
04:48:34 <ivanm> case x of A -> bar getInt32
04:49:13 <makalu> that's a good idea but unfortunately I have multiple 'get'-like functions
04:49:52 <ivanm> well, that's the only alternative I can think of
04:50:28 <ivanm> or rather than aliases, put the type sig in the call: case x of A -> bar (get :: IO Int32)
04:50:39 <ivanm> that way you're not using undefined and asTypeOf
04:52:53 <ivanm> or if it's just the usage of undefined that you don't like, pass in an alias to id:
04:53:27 <ivanm> bar withID = do void (withID <$> get >>= doSomething)
04:53:38 <ivanm> case x of A -> bar (id :: Int32 -> Int32)
04:53:54 <ivanm> makalu: ^^
04:54:33 <makalu> :)
04:54:46 <makalu> I think asTypeOf will have to suffice
04:54:48 <makalu> thank you
04:54:54 <ivanm> np
04:55:33 <ivanm> makalu: wait, one other option: depending on how you've defined your code, you'd still use the dummy type, but rather than asTypeOf use ScopedTypeVariables and give an explicit type to the value
04:56:22 <makalu> that's actually the first thing I tried but it didn't work for some reason. GHC didn't understand that the "a" in my signature is the same "a" I used in the function body
05:00:00 <ivanm> makalu: you need a "forall." in your type sig as well as ScopedTypeVariables
05:01:29 <randomclown> can a cabal target depend on another cabal target?
05:02:40 <makalu> damnit I forgot that >:(
05:05:33 <lllllllllllll> is let x = case y of Just z -> f z ... not correct in a monad? i get a parse error
05:06:11 <makalu> yeah scopedtypevariables is way nicer
05:10:19 <AlainODea> lllllllllllll: what parse error do you get.  Throw it up on http://lpaste.net/new/haskell
05:11:58 <ivanm> randomclown: as in an executable depend on the library?
05:12:39 <ivanm> yes, you need cabal-1.14 I believe, and just list the package name as a dependency
05:12:59 <ivanm> (but make sure the hs-source-dirs are different)
05:13:57 <randomclown> ivanm: I did that, but cabal apparently wants me to manually specify every dependecny under executable
05:14:17 <lllllllllllll> AlainODea, http://lpaste.net/99250
05:14:30 <ivanm> randomclown: yup, still need to re-list any extra dependencies the executable uses
05:14:39 <randomclown> ivanm: say the library uses bytestring
05:14:43 <ivanm> randomclown: but you don't need to list versions if it's the same as a package the library used
05:15:00 <randomclown> man that sucks
05:15:11 <randomclown> I have a lot of dependencies for the library
05:15:14 <ivanm> randomclown: well, consider it a completely separate package
05:15:15 <lllllllllllll> AlainODea, i used  where to fix this...just wondering
05:15:27 <ivanm> randomclown: if the library uses it but the executable doesn't, you don't need to specify it as a dep for the executable
05:15:36 <ivanm> only packages the executable uses directly
05:15:45 <ivanm> @hackage graphviz
05:15:46 <lambdabot> http://hackage.haskell.org/package/graphviz
05:16:14 <AlainODea> lllllllllllll: good stuff. I'm not sure. I'll have to poke around the Haskell Report to see.
05:16:17 <ivanm> ^^ randomclown have a look at how I do the benchmark target (I don't use it for testing as I use the internals for the test-suite, and thus can't use the library)
05:17:10 * ivanm -> land of nod
05:17:42 <randomclown> hm ok
05:21:18 <k00mi> lllllllllllll: try indenting the cases further than the x
05:21:59 <lllllllllllll> k00mi, oh yeah that works
05:22:07 <lllllllllllll> AlainODea, ^
05:22:14 <lllllllllllll> k00mi, thanks
05:22:14 <randomclown> ivanm: is there a way to make ghc ignore other files in the same directory?
05:23:38 <AlainODea> lllllllllllll: good 'ol layout. I should generally think of that first. Good catch k00mi :)
05:24:28 <k00mi> =)
05:37:01 <zipper{-_-}> Is ski around?
05:37:04 <zipper{-_-}> ski: kikoo
05:41:02 <CaptainK> a command to show class instances?
05:41:08 <johnw> :i in ghci
05:41:27 <CaptainK> hey, just slow down on the answers  :P
05:45:55 <CaptainK> :i Num and show....was hoping for output more like: Num => Eq, Int, Integer, Float, Double
05:46:48 <CaptainK> :i shows the infix and prefix functions?
05:48:04 <quchen> :i shows you what a type is an instance of, the fixitx of operators (if set, otherwise it's infixl 9), and where they are defined.
05:48:13 <quchen> And maybe more.
05:49:27 <quchen> The grammar in that sentence was awful, but I hope it's understandable anyway. I didn't sleep much because of a mouse terrorizing my room.
05:50:54 * CaptainK scratches head, infixl 9...getting ahead of the LYAH again
05:53:17 <CaptainK> curious that Num has no (/)
05:53:42 <mr-> CaptainK: Num Integer ?
05:54:09 <CaptainK> ah ya, that is why
05:54:24 <johnw> :t (/)
05:54:24 <lambdabot> Fractional a => a -> a -> a
05:54:29 <johnw> :t div
05:54:30 <lambdabot> Integral a => a -> a -> a
05:54:42 <CaptainK> yep
05:57:23 <quchen> CaptainK: infixl 9 = left-associative with precedence level 9 (highest)
06:01:20 <CaptainK> ok, so that somes later in lyah, explination of more control of infix functions, cool
06:03:38 <quchen> I'm not sure LYAH covers this.
06:03:54 <quchen> Anyway, it's just a small detail, not really something you need to *understand*.
06:07:38 <johnw> if you're a library author creating new operators, then it might be useful, but I've never needed it yet
06:14:07 * hackagebot roundtrip-xml 0.3.0.5 - Bidirectional (de-)serialization for XML.  http://hackage.haskell.org/package/roundtrip-xml-0.3.0.5 (StefanWehr)
06:19:08 * hackagebot roundtrip 0.2.0.3 - Bidirectional (de-)serialization  http://hackage.haskell.org/package/roundtrip-0.2.0.3 (StefanWehr)
06:19:10 * hackagebot roundtrip-string 0.1.0.1 - Bidirectional (de-)serialization  http://hackage.haskell.org/package/roundtrip-string-0.1.0.1 (StefanWehr)
06:22:10 <dennda> From the 7.8 change notes: iOS support & cross compilation - After many years of work GHC now has full support for iOS cross-compilation. As of GHC 7.8, you'll really be able to write iOS apps in your favorite programming language!
06:22:30 <dennda> How is that supposed to be used? Compile a static library and expose an interface to that?
06:22:30 <identity> holy shit.
06:22:33 <zomg> That's p great
06:22:42 <zomg> Obj-C is hate :(
06:22:43 * dennda is an iOS developer
06:23:35 <bartavelle> is there a reason why I get all kind of linker errors when trying to upgrade the version bounds of the libraries I depend on ?
06:23:45 <bartavelle> for example : Loading package blaze-builder-0.3.3.2 ... linking ... ghc: /home/smarechal/.cabal/lib/x86_64-linux-ghc-7.6.3/blaze-builder-0.3.3.2/HSblaze-builder-0.3.3.2.o: unknown symbol `textzm0zi11zi3zi1_DataziTextziFusionziInternal_ZCztZC_con_info'
06:24:30 <Peaker> bartavelle: what OS are you on?
06:24:57 <Peaker> bartavelle: did you try to build -- get a GHC error, try to change .cabal file, reconfigure and build?
06:24:57 <bartavelle> linux
06:25:12 <bartavelle> I am upgrading the version bounds, I rm -rf'ed ~/.ghc
06:25:25 <merijn_> dennda: Probably? I'm not familiar with iOS development in general, so perhaps you could just compile a binary like you would with Objective-C? I don't see why that wouldn't work...
06:25:29 <bartavelle> perhaps I should cabal clean too
06:25:30 * bartavelle trues
06:25:46 <bartavelle> nope
06:25:47 <Peaker> bartavelle: hmm.. if you nuked ~/.ghc, and kept ~/.cabal, maybe that's a problem? (I'm not sure)  but your complaint is about ~/.cabal/lib/...
06:25:56 <bartavelle> ah nice catch
06:26:03 <bartavelle> I'll just nuke everything
06:26:07 <Terr> hi 1st day on haskell, tryin to install this https://github.com/elliottt/rogue with "cabal install" in the dir, got curses missing headers and "Missing (or bad) header file: HsUnix.h" " Missing C library: dl"
06:26:10 <identity> bartavelle: perhaps you want to start using sandboxes after this? :P
06:26:11 <Peaker> bartavelle: keep your ~/.cabal/config
06:26:12 <dennda> merijn_: Yes, I'm just guessing though and should probably read up on it to make sure. I ported Python to iOS once (more as an experiment than anything) and that worked /somewhat/ similar
06:26:22 <Peaker> bartavelle: tip: if you want to profile sometimes, make sure library-profiling: True in ~/.cabal/config
06:26:50 <bartavelle> Peaker, yes, my config file is out of ~/.cabal, I merely ln -s
06:26:55 <merijn> dennda: Presumably once 7.8 is released there will be better docs on cross-compiling to iOS
06:27:07 <CaptainK> fixty in LYAH p134, great to make your own list types
06:27:19 <dennda> I guess. Although I remain a bit sceptical. I'll check it out.
06:27:51 <bartavelle> hmm I should have kept my ~/.cabal/bin :)
06:29:09 * hackagebot aws-cloudfront-signer 1.1.0.2 - For signing AWS CloudFront HTTP URL requests  http://hackage.haskell.org/package/aws-cloudfront-signer-1.1.0.2 (ChrisDornan)
06:29:22 <Terr> sorry, paste of errors here http://lpaste.net/99254
06:29:35 <merijn> dennda: iPwn Studios was working on an iOS game in Haskell, they ran out of funding, but afaik they were able to run stuff on iOS just fine
06:30:12 <quchen> Does Cabal take any Haddock flags into account in its config? I'm just browsing the source right now because I'm annoyed again that you can't add --haddock-hyperlink-source to the config.
06:30:30 <dennda> merijn: Yeah, I'm not so much concerned about being able to run haskell on iOS (which is 'only' a matter of cross-compilation) so much as I'm concerned about the integration with the iOS ecosystem
06:30:33 <Peaker> bartavelle: ooh, that's a neat trick, I ought to copy that :)
06:30:43 <colDrMcBeardman> merijn, dennda, a long time ago someone ported ghc to jailbroken iOS
06:30:48 <Peaker> bartavelle: make ~/.cabal/bin a symlink too, then :)
06:30:58 <bartavelle> Peaker, will certainly do that yes
06:31:04 <colDrMcBeardman> ghci on a teeny tiny screen was tons of joy.
06:31:21 <identity> bartavelle: homesick is a nice little utility that can manage dotfiles and such for you very simply
06:31:31 <identity> like .cabal and possibly even .cabal/bin
06:31:35 <bartavelle> identity, I already have my vital stuff under version control
06:31:50 <bartavelle> obviously not the binary files ...
06:31:53 <merijn> dennda: I don't see how that would be problematic? The ecosystem is just Objective-C, no?
06:32:01 <identity> bartavelle: it just uses git, but it symlinks/unsymlinks the stuff automatically for you.
06:32:04 <identity> it's pretty neat
06:32:11 <merijn> dennda: You'll need to go through C to interact with that, but that should be pretty trivial from both sides
06:32:30 <bartavelle> identity, does sound neat yes ! will take a look
06:32:33 <colDrMcBeardman> are there cocoa bindings for hs?
06:33:02 <dennda> merijn: My experience (which I hope is not universally applicable) is that that sort of thing causes you to run into more trouble than you'd otherwise have. I guess there's only one way to find out though, and I'm curious enough to try.
06:33:09 <merijn> colDrMcBeardman: Not afaik, but there's cocoa bindings for C, so from there it should be pretty trivial
06:33:44 <merijn> dennda: In my experience, as long as you don't need mutable structs (i.e. C structs that you want to mutate from Haskell) the FFI is pretty trivial
06:33:50 <colDrMcBeardman> FFI FTW.
06:34:15 <merijn> You can do mutable structs to, but getting the Storable instance implemented is a bit of a hassle the first couple of times
06:35:47 <Peaker> The Storable stuff should all be auto-generated
06:36:19 <merijn> Peaker: Yeah, but that never quite works without messing around a while when you first try
06:36:20 <Peaker> either from a clang parse of the C code -- or from debug information. I can do the latter (I have good debug info parsing), but some people suggested the former might be a better approach
06:36:30 <Peaker> merijn: I mean in a generic tool
06:36:31 <merijn> c2hsc is good
06:36:53 <johnw> c2hsc will generate the Bindings-DSL macros that will generate the Storable instances
06:36:53 <merijn> Peaker: Yeah, I use c2hsc for that now :)
06:40:40 <Peaker> c2hsc is not what I mean -- it still requires manually mentioning every struct name, field name, etc
06:41:02 <johnw> c2hsc should be auto-generating them from the header file
06:41:19 <johnw> now, c2hs (no c), requires manually mentioning them
06:41:32 <Peaker> I mean something you use like:   foo somesrc.h   or    foo someobj.o     to get  fooffi.hs    with all the exported functions and types available
06:41:43 <johnw> yep, that's c2hsc
06:41:44 <merijn> Peaker: I have a header file and auto generate from there
06:41:56 <merijn> Peaker: You are confused with c2hs which is one of the standard haskell build tools
06:42:17 <merijn> Peaker: c2hsc generates hsc from C, which is then processed by the standard hsc tools
06:42:47 <Peaker> iirc, it didn't generate all the Storable instances? I'll test now
06:43:03 <johnw> c2hsc generates Bindings-DSL macros, and these generate Storable instances
06:44:04 <merijn> Peaker: If it doesn't, blame johnw :p
06:44:11 * hackagebot filecache 0.2.3 - A Linux-only cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.2.3 (SimonMarechal)
06:44:13 * hackagebot hruby 0.2.0 - Embed Ruby in your Haskell program.  http://hackage.haskell.org/package/hruby-0.2.0 (SimonMarechal)
06:44:32 <Peaker> johnw: how does it preprocess header files? Do you specify what macros are available?
06:45:24 <johnw> it uses the language-c library to parse them
06:45:28 <johnw> and cpp to preprocess them
06:45:38 <johnw> yes, you can specify cpp options
06:51:57 <klrr_> how do i render a String from a UTCTime? it seem to derive Show but when i run show on a UTCTime value it throws a type error
06:52:46 <merijn> klrr_: lpaste minimal code sample + error?
06:53:19 <klrr_> okey, sec
06:53:55 <klrr_> http://lpaste.net/99256
06:53:57 <klrr_> merijn: ^
06:54:41 <quchen> I think UTCTime might have an orphan instance somewhere for a reason I don't remember.
06:54:51 <klrr_> orphan instance?
06:54:54 <quchen> There is some orphan in the Time package, that's all I remember.
06:54:57 <ion> Uh, i guess that’s a way to format the list, too. http://hackage.haskell.org/package/instrument-chord-0.1.0.5/docs/src/Music-Instrument-Chord.html
06:54:57 <colDrMcBeardman> Data.Time.LocalTime.LocalTime
06:55:07 <quchen> An instance that's not defined in the same module as the type is called an orphan.
06:55:17 <quchen> (Emits a warning during compilation even.)
06:55:19 <colDrMcBeardman> ^^ klrr_, quchen that's supposedly where.
06:55:32 <colDrMcBeardman> klrr_, try importing that module
06:55:34 <klrr_> aa okey, so i need to import another module to get the instace?
06:55:41 <quchen> So try  import Data.Time.LocalTime.LocalTime ()
06:55:42 <klrr_> okey
06:55:49 <colDrMcBeardman> no guarantees.
06:55:51 <quchen> Importing with () imports only instances
06:56:19 <quchen> colDrMcBeardman: How did you find that module?
06:56:24 <colDrMcBeardman> also, it's apparently recommended to just import the top level Data.Time
06:56:28 <quchen> Last time I was looking for the instance I cloned+grepped
06:56:42 <colDrMcBeardman> quchen, lmgtfy.com :P
06:56:55 <klrr_> it says it's a hidden module -.- is there any way to import non-base packages or do i need to make a whole cabal project to make this work?
06:57:17 <colDrMcBeardman> klrr_, are you importing Data.Time itself or other modules?
06:57:39 <klrr_> Data.Time.LocalTime.LocalTime
06:58:27 <colDrMcBeardman> i meant before. you might have a problem if you were doing, say, import Data.Time.Something instead of just Data.Time
06:58:47 <colDrMcBeardman> i didn't know Data.Time.LocalTime.LocalTime is hidden now.
06:59:10 <klrr_> well wont be able to import it without making a cabal project which i dont wanna put effort into, seriously packages in haskell are a hell
07:00:05 <klrr_> is there any way to specify with the args?
07:00:08 <klrr_> to ghci
07:00:12 <colDrMcBeardman> klrr_, if it's hidden, could you do ghc-pkg expose?
07:00:13 <klrr_> which version you want to use
07:00:29 <quchen> Time never fails to annoy the crap out of people.
07:01:24 <klrr_> i only got one freaking time-* package and still ghci cant figure out which to load?
07:01:26 <colDrMcBeardman> quchen, i don't know if it was made up but i read a supposedly roman quote that went something like "curse the inventor of the clock, who so ruthlessly hacked my days into unusably small pieces"
07:01:49 <colDrMcBeardman> wish i could find that quote or if it's fake.
07:02:01 <implementation> Is there any way to implement catchError for something like instance MonadError e m => MonadError e (MyMonadT m) without using runMyMonadT?
07:02:11 <klrr_> haha i know how to do time, i will call a shell command and chatch its output
07:02:17 <colDrMcBeardman> klrr_, does it say "foo is a member of hidden package bar"?
07:02:22 <remdezx> Hello! I asked my question before, but noone answered it. I'm working with ghc api, but I'm getting linker errors. I have 3 projects - 1st dependent to 2nd, and 2nd dependent to 3rd. This 3rd use ghc api (has "-package ghc" ghc flags section in cabal) and I keep getting linker errors in the 1st project. Any ideas how to solve it? http://lpaste.net/99244
07:02:33 <klrr_> colDrMcBeardman: yes
07:02:39 <quchen> implementation: Why don't you want to run*? run* functions are usually newtypes, so they're operationally free
07:02:41 <colDrMcBeardman> do ghc-pkg expose bar
07:03:09 <quchen> In other words, there is no good reason to avoid using run*, except to reduce code size
07:03:27 <klrr_> colDrMcBeardman: gives same error
07:03:34 <klrr_> after doing that
07:03:50 <implementation> quchen: because actually I'm writing a template that creates the MonadError instances for me, and the need to use runMyMonadT would make it harder to call :)
07:03:54 <CaptainK> is there another way to list instances for classes
07:03:54 <bitonic> so it seems like TH sees hidden data constructors.  is there a way to explicitly refer to an hidden constructor in TH?
07:04:15 <quchen> CaptainK: Other than :i? Not that I know of.
07:04:24 <quchen> You can look at the docs of course.
07:04:36 <quchen> But that'll show whatever instances Haddock knew of.
07:05:28 <CaptainK> ok, I'll just search the web, someone made a list :P
07:05:32 <CaptainK> thx
07:05:59 <colDrMcBeardman> klrr_, maybe it's supposed to be Data.Time.LocalTime
07:06:04 <colDrMcBeardman> not .LocalTime.LocalTime
07:06:41 <klrr_> colDrMcBeardman: lol, thanks now it works
07:06:50 <colDrMcBeardman> heh
07:08:12 <Terr> hi first time in haskell/cabal, tryin to install this https://github.com/elliottt/rogue with "cabal install" in the dir, got those errors http://lpaste.net/99254
07:08:40 <colDrMcBeardman> Terr: you need the curses development libraries (in C)
07:08:55 <colDrMcBeardman> so if you're on ubongo, you need to do something like apt-get install libcurses-dev
07:09:18 <Terr> colDrMcBeardman: cygwin here, got the headers in /usr/include/ncurses
07:09:22 <quchen> klrr_: Works without anything here. http://lpaste.net/99257
07:09:35 <colDrMcBeardman> Terr: something about dl too, idk what library that is.
07:10:26 <colDrMcBeardman> Terr: you have headers, but are the libraries there for linking?
07:10:42 <Terr> colDrMcBeardman: I did set C_INCLUDE_PATH with that but no difference.
07:10:54 <Terr> colDrMcBeardman: wait I'll check...
07:11:02 <colDrMcBeardman> Terr: did you look for the appropriate .so file in wherever cygwin's lib is?
07:11:21 <colDrMcBeardman> quchen, i read that importing just Data.Time should work, because it reexports what you need.
07:11:39 <Terr> colDrMcBeardman: yes got them in /usr/lib/ncurses. how do I "notify" cabal of this?
07:11:56 <colDrMcBeardman> Terr: you also need something called dl, idk what that is.
07:12:47 <exicer> I've been looking at scotty as a server for a small project I'm thinking of doing. Would anyone discourage me from using it, over snap say, for any reason ?
07:13:05 <colDrMcBeardman> Terr: it says config.log has more info, could you lpaste that?
07:16:04 <klrr_> if i got a [(a, b)] is there any function that produces a list of one of them sorted by the other?
07:16:40 <colDrMcBeardman> klrr_, do you want it to still be pairs, or like [b] sorted by a's ordering?
07:16:51 <Terr`> colDrMcBeardman: http://lpaste.net/99268 here
07:17:03 <Terr`> t/nick Terr
07:17:19 <int-e> @type map snd . sort (comparing fst)
07:17:20 <lambdabot>     Couldn't match expected type `a0 -> [(a1, b0)]'
07:17:20 <lambdabot>                 with actual type `[a2]'
07:17:20 <lambdabot>     In the return type of a call of `sort'
07:17:27 <int-e> @type map snd . sortBy (comparing fst)
07:17:28 <klrr_> something like this Ord b => [(a, b)] -> [a]
07:17:28 <lambdabot> Ord a => [(a, b)] -> [b]
07:17:37 <klrr_> or the oppsotie
07:17:44 <klrr_> thanks!
07:18:08 <colDrMcBeardman> int-e that is friggin cool.
07:18:13 <BoR0> @src liftIO
07:18:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:18:50 <colDrMcBeardman> Terr: i get redirected to lpaste's home page
07:19:15 * hackagebot regex-tdfa-rc 1.1.8.1 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-rc-1.1.8.1 (RomanCheplyaka)
07:19:34 <Terr`> colDrMcBeardman: new paste here http://lpaset.net/99258 , hope it works now
07:20:59 <Terr``> colDrMcBeardman: uh, "-V" for gcc ?
07:22:28 <colDrMcBeardman> Terr, ok, so oddly it's failing because of something that autoconf needs to fail apparently.
07:22:46 <ski> zipper{-_-} ?
07:22:55 <colDrMcBeardman> autoconf tries to include ac_nonexistent expecting a failure just to `make sure' that including a nonexistent header will fail.
07:23:10 <colDrMcBeardman> but it looks like cabal is taking that as a signal that compilation failed.
07:23:20 <Terr> colDrMcBeardman: I'm tryin to check the terminfo haskell package , not easy thing as a first try...
07:23:41 <augur> jfischoff:
07:23:45 <augur>           (:) :: a -> [a] -> [a]     [] :: [a]
07:23:45 <augur> list  :: (      a -> [a] -> b  ) ->        b    -> [a] -> b
07:23:46 <augur> foldr :: (      a ->   b -> b  ) ->        b    -> [a] -> b
07:24:11 * jfischoff is copying and pasting
07:24:17 <augur> jfischoff: its too long :(
07:24:27 <augur> i tried to @HaskellTips but its just too big
07:24:33 <augur> also there's no standard function list
07:24:38 <colDrMcBeardman> Terr, i don't know if i can be much help past this point, but it seems like a bug with terminfo's configure stuff. try checking their tracker and filing a bug. sorry i could be more help
07:24:47 <jfischoff> too bad :(
07:25:10 <Terr> colDrMcBeardman: ty very much :)
07:25:13 <colDrMcBeardman> np
07:26:13 <augur> jfischoff: indeed
07:26:23 <ocharles> Does anyone have any idea why: 'cabal run -- -- --src=dbsmall --dest=fynder' causes: "SqlError {seState = "[\"08S01\",\"08001\"]", seNativeError = -1, seErrorMsg = "connectODBC/sqlDriverConnect: [\"20009: [unixODBC][FreeTDS][SQL Server]Unable to connect: Adaptive Server is unavailable or does not exist\",\"0: [unixODBC][FreeTDS][SQL Server]Unable to connect to data source\"]"}"
07:26:36 <ocharles> Where as it works fine if I cabal repl and then ':main --src=dbsmall --dest=fynder' ?
07:26:38 <augur> and its lovely why this exists
07:26:53 <ocharles> What would different between running main from the command line and running it from the repl?
07:26:56 <jfischoff> ocharles: threaded?
07:27:08 <ocharles> jfischoff: is ghci threaded by default?
07:27:14 <jfischoff> yeah I think so
07:27:21 <ocharles> alright, I'll give that a whirl
07:27:42 <ocharles> same result if I compile with ghc-options: -threaded
07:27:44 <ocharles> :/
07:30:28 <geekosaur> does the repl break with --no-ghci-sandbox?
07:30:52 <dennda> lukexi: Are these instructions terribly outdated on the 7.8 branch? https://ghc.haskell.org/trac/ghc/wiki/Building/CrossCompiling/iOS
07:31:00 <ocharles> cabal: unrecognized option `--no-ghci-sandbox' for 'cabal repl --no-ghci-sandbox'
07:31:18 <geekosaur> huh
07:31:32 <dcoutts> ocharles: did you mean to pass that through to ghci, via --ghc-options=
07:31:43 <ocharles> dcoutts: pass what?
07:31:49 <dcoutts> --no-ghci-sandbox
07:31:50 <geekosaur> the no-ghc-sandbox thing
07:31:54 <ocharles> I meant to do what geekosaur suggested :)
07:32:18 * geekosaur has not done much with sandboxes yet and doesn't know what extra steps are involved in passing random options
07:32:18 <dcoutts> geekosaur: ghci's notion of "sandbox" is nothing whatsoever to do with cabal's notion of sandbox
07:32:51 <geekosaur> the sandbox I am talking about is the one inside ghci that isolates threads, not the cabal sandboxing
07:33:01 <dcoutts> geekosaur: ok fine
07:33:13 <ocharles> dcoutts: what I'm trying to do is work out why my program crashes with 'cabal run' but works with 'cabal repl' and then typing ":main" as above should explain
07:33:20 <geekosaur> ...the ghci sandbox can lead to unintuitive thread behavior especially if a library relies on thread-local data
07:34:12 <geekosaur> dcoutts: I don't expect xmonad to behave at all sanely in a sandbox so it's not so useful for my most common use case :p
07:34:34 <dcoutts> geekosaur: ok, ignore me, you clearly understand what you're doing :-)
07:35:09 <ocharles> geekosaur: aha!
07:35:15 <ocharles> -fno-ghci-sandbox reproduces the error on the command line
07:37:03 <geekosaur> ok, so we know it is related to threading somehow. but it's kinda backwards because apparently it only works if it's not on the main thread. at this point my understanding of ghc's threading goes south :(
07:37:27 <ocharles> I think I'll read more of the HDBC documentation
07:37:39 <ocharles> I'm not familiar with the code I'm working on, so maybe there's some initialisation step that's missing
07:38:31 <sdfxc> Why is mplus for Maybe defined such that Just 1 `mplus` Just 2 => Just 1, not Just 2?
07:39:39 <ocharles> :t mplus
07:39:40 <lambdabot> MonadPlus m => m a -> m a -> m a
07:39:49 <ocharles> sdfxc: mplus is defined so generally it can't make decisions like that
07:39:59 <ocharles> Doing that would have to know about integer addition - and there's no mention of integers in that type
07:40:23 <ocharles> It could assume a Monoid, but then you'd still be assuming that there was a monoid for integers (there isn't - because there are multiple choices)
07:41:16 <Mon_Ouie> ocharles: notice the second argument was Just 2, i.e. why is Just a `mplus` Just b = Just a rather than Just b
07:42:03 <identity> @src mplus
07:42:03 <lambdabot> Source not found. Take a stress pill and think things over.
07:42:47 <merijn> sdfxc: mplus returns the first non-failing argument
07:43:04 <merijn> sdfxc: If you want "Just 1 >> Just 2" -> Just 2, that is just >>
07:43:56 <merijn> sdfxc: MonadPlus is similar to Alternative where you have 2 (potentially failing) branches and you wanna pick the first that succeeds
07:44:03 <merijn> :t (<|>)
07:44:03 <lambdabot> Alternative f => f a -> f a -> f a
07:44:57 <merijn> sdfxc: For example, in STM mplus and <|> are both "orElse" so "x `mplus` y" becomes "x `orElse` y", i.e. returns the result of the first succeeding transaction
07:51:58 <danilo2> Hello all! :) I've got a small and simple question to you :) Is there any tool in haskell which check s for unused imports and all the things we get warnings about when we are compiling stuff? but without the need of recompiling it ?
07:52:26 <bergmark> you can run ghc with -fno-code
07:53:16 <geekosaur> there's some tools for managing imports on hackage but I don't know if they will do that for you. but haskell being what it is, I think you need something approaching the power of the full compiler to do it right...
07:57:25 <danilo2> geekosaur: Ouch, so we are nto able to tell ghc "hey, dont compile the file, just imitate you are doing this, but in reality print just the wornings?
07:57:43 <geekosaur> that is -fno-code as bergmark said
07:57:49 <geekosaur> I meant there are no simpler tools
07:57:56 <geekosaur> (compare e.g. hlint)
08:03:24 <HelloWorld> Is there a class in JAVA that contains a method which can count a specific pattern in a String? Like: How often does the pattern "ee" appear in the String "see see see"?
08:03:49 <bennofs> HelloWorld: why are you asking about JAVA in a haskell channel?
08:04:18 <HelloWorld> I didn't find a Java-channel on freenode^^
08:04:22 <bennofs> HelloWorld: ##java
08:04:36 <HelloWorld> Thanks a lot :)
08:05:17 <tdammers> that's a bit like ordering a cheeseburger in a vegan restaurant because you didn't find the McD
08:05:20 <tdammers> :x
08:06:05 <Hafydd> GoodbyeWorld
08:07:25 <dv-> a cheeseburger without cheese
08:07:36 <quchen> "Hello, I'd like to buy some bananas"
08:07:41 <quchen> "Sir, this is a bicycle store"
08:07:46 <quchen> "But I didn't find a banana store"
08:07:47 <colDrMcBeardman> actually, some veggie burgers are awesome
08:08:00 <tdammers> what have I done
08:08:16 <danilo2> geekosaur: ah i didnt noticed the bergmark response! Thank you both! :)
08:08:17 <colDrMcBeardman> tdammers, it's so simple, see? a monad is like a veggie burger....
08:08:30 <quchen> tdammers: Oh. I should have read the scrollback. I couldn't hesitate saying it
08:08:56 <tdammers> yeah... but I think I took #h deeply into -blah country
08:09:15 <levi> danilo2: Tools like ghc-mod and hdevtools might interest you as well.
08:09:24 <bergmark> danilo2: you may want -fforce-recomp also
08:09:27 <danilo2> levi: Ok, checking them right now :)
08:09:38 <danilo2> bergmark: I do not want to recompile things
08:10:06 <levi> They use the ghi API to examine your source and give you information about it, such as errors, type information, etc.
08:10:20 <bergmark> danilo2: it won't recompile with -fno-code -fforce-recomp, just give you all the warnings again
08:10:21 <levi> And they're designed with editor integration in mind.
08:10:30 <geekosaur> danilo2: the name is slightly a misnomer, it means don't rely on an existing .hi file
08:10:58 <geekosaur> which usually won't have enough information to reconstruct all the imports
08:11:14 <geekosaur> so you need to force it to look at the source code
08:12:31 <bergmark> just realized you can use -fforce-recomp in ghci too :-)
08:21:08 <danilo2> geekosaur, bergmark: thank you. Btw I found, that hlint is very cool!
08:22:38 <colDrMcBeardman> danilo2, there's also scan
08:22:47 <colDrMcBeardman> it's more of a style checker
08:23:15 <danilo2> colDrMcBeardman: Thank you, I will check it also :)
08:23:23 <flebron> Is there a name for m Bool -> m a -> m a -> m a?
08:23:56 <colDrMcBeardman> flebron, ifM?
08:24:18 <flebron> Where is that?
08:24:28 <colDrMcBeardman> scyther-proof
08:24:37 <colDrMcBeardman> no idea how that made its way onto my machine
08:25:01 <quchen> Obscure 4-th level transdependency
08:25:18 <colDrMcBeardman> quchen, no doubt.
08:26:23 <flebron> Hehe, I'll just write it myself then :) Thanks!
08:26:26 <colDrMcBeardman> maybe djinn needed it.
08:28:32 <Tehnix> hmm, if I have a problem with a library while compiling my own application, and want to test changes to that library in the sandbox of my app, what would be the approach there? could I just dl the source directly into the app folder and compile it, or?
08:29:50 <danilo2> Hi! Does somebody know why such error happens? I've got bunch of libraries. One of them is linked agains ghc library (using GHC-Options: -package ghc). Almost all of the libraries compile, but one results in: http://lpaste.net/99260 :(
08:30:22 <bergmark> Tehnix: add-source it to the sandbox
08:33:13 <levi> ^^- yes, cabal sandbox add-source is your friend!
08:33:57 <Tehnix> neat, thanks! :)
08:34:13 <c_wraith> Tehnix: with more detail..   use cabal unpack to download and unpack it outside your sandbox, then cabal sandbox add-source it
08:35:49 <jle`> luite: will ghcjs work with the new 7.8 branch out of the box?
08:37:09 <flebron> Say I have a very IO-bound operation, running on 256 independent inputs. Exactly one of these inputs will return a Just, every other one will return a Nothing. What would be a good way to parallelize this to get the first Just, and not care about anything else?
08:37:30 <flebron> (The operation is an HTTP request.)
08:38:07 <jle`> you're making me sad because i left my Parallel & Concurrent Haskell book on the roof of my car one day and drove off in a hurry and now I don't have it anymore and it was my favorite book :'(
08:38:26 <syllogismos> lol
08:39:07 <jle`> but this is one of the first exercises they go through
08:39:11 <jle`> in the concurrency section
08:39:53 <flebron> Oh! I'll check it out :)
08:40:59 <jle`> not sure how good of an idea it would be to use in real code though because as it's a tutorial it forgoes some of the more refined abstraction libraries
08:41:26 <jle`> http://chimera.labs.oreilly.com/books/1230000000929/ch09.html
08:41:32 <flebron> This is for a one-shot utility, so maintenance doesn't matter thaaaat much to me :)
08:42:00 <jle`> for what you want mostly, i think...but it builds on ch 7 and 8
08:42:17 <jle`> someone who actualyl does stuff like this in real life would probably give you a better answer than me
08:43:05 <carlosgaldino> hi, I'm very newbie to haskell and its ecosystem. I checked a project and while I was trying to install its dependencies I got the following error: https://gist.github.com/carlosgaldino/62248e44bfd83f71ff4c
08:44:26 <jle`> carlosgaldino: what OS are you running?
08:44:44 <carlosgaldino> jle` osx mavericks
08:45:33 <supki> carlosgaldino: you need to install cpphs with  cabal install cpphs
08:46:32 <supki> well, and ensure cpphs ends up in PATH
08:47:09 <jle`> i don't use osx, but i hear there was a big stir around it when mavericks was released and breaking some compatibility with haskell
08:47:11 <supki> that's an unfortunate consequence of the cabal inability to install build tools
08:48:27 <carlosgaldino> how can I know where cabal is installing stuff?
08:48:33 <carlosgaldino> so I can put that in my PATH
08:48:34 <Fuuzetsu> are there any plans to get lens into a state where it's possible to install it with GHC HEAD?
08:48:55 <supki> Fuuzetsu: did you try 4.0?
08:49:39 <Fuuzetsu> no, I just saw the Travis failing with 3.10.1, wasn't aware 4 was out
08:49:45 <Fuuzetsu> I'll see if I can just bump the bound
08:50:29 <Fuuzetsu> oh, the bound is ‘lens >= 3.9’; is 4.0 out on Hackage?
08:50:55 <Fuuzetsu> hm, it is, it must be some dependency fighting then
08:52:03 <supki> carlosgaldino: ~/.cabal/bin
08:52:09 <supki> oh, os x
08:52:20 <supki> carlosgaldino: ~/Library/Haskell/bin, I think
08:52:29 <merijn> supki: Yes
08:53:19 * geekosaur points to the end of the /topic re mavericks / xcode 5
08:53:40 <Tehnix> when using cabal install on a .cabal file, is it possible from the command line to specify a minimum version of a package?
08:54:00 <bennofs> Tehnix: --constraint "package >= version"
08:56:13 <danilo2> Hi! Does somebody know why such error happens? I've got bunch of libraries. One of them is linked agains ghc library (using GHC-Options: -package ghc). Almost all of the libraries compile, but one results in: http://lpaste.net/99260 :(
08:56:35 <Tehnix> bennofs: thanks!
08:56:43 <indigo> bitemyapp: Left the clojure channel, eh? :P
08:58:19 <flebron> Is it normal for "Building haskell-src-exts-1.14.0..." to take like, 15 minutes?
08:58:52 <bennofs> flebron: yeah, haskell-src-exts takes a bit of time to compile
08:59:26 * hackagebot snap 0.13.2.2 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.2 (DougBeardsley)
08:59:59 <jle`> at least you should already have it for ghc-mod
09:00:55 * flebron is precisely installing ghc-mod :)
09:01:14 <jle`> haha
09:01:24 <jle`> well then...
09:08:11 <killy9999> can I use record syntax with newtype?
09:12:56 <jle`> killy9999: yes
09:13:04 <jle`> well..if you only have one field of course
09:13:15 <jle`> a lot of base libraries 'abuse' this
09:13:26 <jle`> by abuse i mean take advantage of in a harmless way
09:14:16 <jle`> newtype State s a = State { runState :: s -> (s,a) }
09:14:36 <jle`> newtype First a = First { getFirst :: Maybe a }
09:14:57 <rien_> hi folks. I need guidance porting some monads to another language. So I need to read the canonical definition for each, starting with Writer. There are at least 3 Writers on Hackage and I can't even find the definition of runWriter
09:14:57 <jle`> i see why they do it but it'll always feel hacky to me
09:16:02 <jle`> rien_: isn't there a Writer in HP?
09:16:24 <rien_> sorry, what is HP? :$
09:16:40 <Clint> transformers
09:16:40 <jle`> haskell platform
09:16:54 <jle`> transformers is probably the canonical implementation though
09:17:16 <jle`> i'm not sure if it differs too dramatically from mtl though
09:17:33 <rien_> jle`: I don't really know. but wouldn't there be a link like one of those Hackage links where I can just browse the source?
09:18:02 <jle`> LYAH has a good exposition on the writer monad
09:18:16 <jle`> as does http://adit.io/posts/2013-06-10-three-useful-monads.html
09:18:20 <rien_> jle`: don't they sometimes simplify the source to make it understandable?
09:18:28 <rien_> yes adit.io tutorials are nothing short of excellent
09:18:36 <simpson> rien_: There are two canonical implementations, one with a newtype and one without.
09:18:38 <jle`> i don't see how much simpler you can make the writer monad
09:18:52 <rien_> simpson: where do I read them?
09:19:00 <simpson> The one without a newtype is: instance Monoid w => Monad (w,) where ...
09:19:57 <rien_> well this is the kind of help I need. when I go here, it's missing a lot of code (like installing Writer as an instance of Functor, Monoid, Monad...) : http://hackage.haskell.org/package/mtl-1.1.0.2/docs/src/Control-Monad-Writer-Class.html#MonadWriter
09:20:16 <simpson> rien_: That's the MonadWriter typeclass, not the WriterT type.
09:20:20 <rien_> then I go here and the source references runWriter but does not define it: https://hackage.haskell.org/package/mtl-1.1.0.2/docs/src/Control-Monad-Writer-Lazy.html#Writer
09:20:37 <rien_> so I'm looking for the source where the Writer monad is defined entirely *as a reference* so I can copy it
09:20:56 <rien_> or some way to make sense of this because my to layman's perspective there are definitions missing :)
09:21:22 <jle`> do you have any questions?
09:21:43 <simpson> rien_: You're looking in mtl; the actual newtype is in transformers.
09:21:44 <simpson> http://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-Writer-Lazy.html#WriterT
09:21:57 <simpson> rien_: Also this should *not* be used as a reference.
09:22:06 <rien_> yes, where is the canonical implementation of Writer? must be in some white paper. I have no trouble finding the canonical interpretation for Parser for instance, seems to be everywhere.
09:22:22 <simpson> rien_: Mu. Writer is not some fundamental primitive.
09:22:42 <jle`> i think it's because they are just somewhat vague-ish design patterns
09:22:47 <rien_> simpson: it's not about that, but whoever invented it defined it, just like the Parser monad.
09:23:06 <Clint> which Parser is canonical?
09:23:07 <rien_> jle`: that makes it hard for a beginner like me :/ I really need some hand holding beyond Maybe but before Parser
09:23:16 <jle`> have you read the chalmers lecture series?
09:23:22 <jle`> they do a good bit on Parser monad
09:23:27 <mmmm> http://hackage.haskell.org/package/transformers-0.1.4.0/docs/src/Control-Monad-Trans-Writer-Lazy.html
09:23:32 <mmmm> Is that what you're looking for?
09:23:48 <rien_> Clint: the first papers by Hutton and Meier seem to look like it
09:24:05 <rien_> also the C9 video with Erik Meier gives a nice exposition
09:24:30 * hackagebot HaTeX 3.10.0.0 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.10.0.0 (DanielDiaz)
09:24:35 <rien_> jle`: I haven't but like I said, I have no problems with the Parser monad right now. I guesss I'll keep looking, thanks!
09:24:43 <jle`> rien_: http://www.cse.chalmers.se/edu/course/TDA452/FPLectures/Vid/ , week 4
09:24:45 <jle`> ah ok
09:24:48 <jle`> well
09:24:59 <jle`> you really can't be too complicated with Writer
09:25:05 <jle`> it's just... a tuple
09:25:10 <rien_> mmmm: that looks like it!!
09:25:28 <rien_> jle`: everything is complicated before I learn it, then it becomes simple :)
09:25:45 <jle`> :)
09:25:48 <jle`> well if you have any questions.
09:26:05 <rien_> mmm found it, see that's what I meant, that link defines all functions about the Writer monad, including the instance installations and runWriter etc
09:26:33 <rien_> mmmm++ (my imperative thanks)
09:26:49 <benj_> mmmbop
09:26:54 <mmmm> It might not be exactly what you want as Writer is defined in terms of WriterT
09:27:09 <mmmm> but if it is then np :)
09:27:49 <rien_> mmmm: basically I'm porting these definitions over to a language without as powerful types as Haskell, so that might be a problem. I'll need to find out how to break it down in terms of lambda + structs
09:28:40 <magicman> Dynamic .hs module loading, plugin-style. Still best done manually with the ghc-api, or do we have wrappers for that?
09:29:09 <rien_> so WriterT w m a means w is the writing side, a is the value side, m is the monad that will be transformed with Writer, then?
09:29:28 <simpson> @unmtl WriterT w Maybe a
09:29:28 <lambdabot> Maybe (a, w)
09:29:54 <supki> rien_: newtype declaration  newtype Writer w a = Writer { runWriter :: (a, w) }  automatically defines  runWriter (Writer (a, w)) = (a, w)
09:30:09 <supki> rien_: so, actually, your second link has all definitions too :)
09:30:16 <jle`> rien_: so a writer is basically a tuple (w,a), where a is the value.  we can step through the functor and applicative and monad instances
09:30:43 <rien_> supki: ah! I had no idea the type definition also defined the source. that helps!
09:30:46 <jle`> so if you have an f :: a -> b, the fmap f (w,a) is (w, f a)
09:31:21 <rien_> jle`: right fmap is straightforward. I guess I'm trying to understand "tell" for instance
09:31:41 <rien_> it's not intuitive for me how to write a function that does not take a value and simply changes something in the monad... I mean how to chain those binds...
09:32:08 <rien_> I'm guessing the desugared tell bind would take a _ variable on its lambda?
09:32:10 <simpson> rien_: It leans on the Monoid instance for w.
09:32:17 <simpson> @src tell
09:32:17 <lambdabot> Source not found. Maybe you made a typo?
09:32:35 <rien_> simpson: so that there's mzero and mappend, right? I think I get that part
09:32:37 <simpson> :t tell
09:32:38 <lambdabot> MonadWriter w m => w -> m ()
09:32:41 <jle`> so remember (>>=) is m a >>= (a -> m b)
09:32:47 <jle`> and you mean mempty, not mzero
09:33:05 <rien_> I guess what would help me lots is sugared do-notation side-by-side with desugared binds and lambdas :) so I'm slowly doing it by hand
09:33:15 <jle`> so in our type, our >>='s right hand side is (a -> (w, a))
09:33:15 <rien_> jle`: oops mempty yes
09:33:23 <simpson> (a, w) >>= f = case f a of (b, w') -> (b, w `mappend` w')
09:33:24 <rien_> agreed
09:33:35 <simpson> More or less.
09:34:21 <jle`> so basically >>= takes (w, a) >>= (f :: a -> (w, a))
09:34:40 <rien_> jle`: now let's look at the signature for tell. it's w -> m (). but shouldn't that be w -> m(a, new_w) ?
09:35:09 <jle`> m ~ (w,)
09:35:14 <jle`> so m a ~ (w,a)
09:35:27 <jle`> so m () ~ (w,())
09:35:31 <rien_> ~ means "equivalent" ?
09:35:42 <jle`> yeah
09:35:49 <simpson> tell w = ((), w)
09:36:10 <jle`> i'm backwards of simpson so i'll switch to his order
09:36:29 <jle`> so you >>= to an a -> (a, w)
09:36:39 <jle`> or a -> m b
09:36:51 <jle`> our monad, m is (,w)
09:36:55 <jle`> our b is ()
09:37:06 <jle`> so our total type is m b ~ (,w) () ~ ((),w)
09:37:26 <jle`> i'm sort of abusing type functions and type currying and type sections
09:37:35 <jle`> > (,x) ()
09:37:36 <lambdabot>  ((),x)
09:37:39 <rien_> I'm with you
09:37:47 <rien_> can lambdabot desugar do notation?
09:37:51 <jle`> yes
09:37:53 <jle`> @undo
09:37:53 <lambdabot> Error: expected a Haskell expression or declaration
09:37:57 <jle`> sorry lamdabot
09:39:03 <rien_> jle`: can you do one example so I can mimic it with my question?
09:39:24 <jle`> so the semantics of writer is that when you bind a (a -> (w', b)) to a (w, a), then you get a (w'', b), you get the b from the result of the bind, and w'' being w <> w'
09:39:39 <jle`> @undo do { x <- return y; f x }
09:39:40 <lambdabot> return y >>= \ x -> f x
09:40:31 <rien_> @undo do { x <- return 4; tell "4 went in" ; return x }
09:40:31 <lambdabot> return 4 >>= \ x -> tell "4 went in" >> return x
09:40:40 <jle`> so tell w = \_ -> (w,())
09:40:46 <rien_> aha
09:41:08 <rien_> that's what I was trying to understand. I feel my brain reshaping now
09:41:16 <jle`> so when i bind (w,x) >>= (\_ -> (w',()))
09:41:26 <jle`> the result is (w <> w', ())
09:42:18 <rien_> what's the function that extracts just the message? is it listen?
09:42:28 <simpson> :t listen
09:42:29 <lambdabot> MonadWriter w m => m a -> m (a, w)
09:42:32 <rien_> > do { x <- return 4; tell "4 went in" ; return x }
09:42:34 <lambdabot>  No instance for (Control.Monad.Writer.Class.MonadWriter
09:42:34 <lambdabot>                     [GHC.Types.Char] m0)
09:42:34 <lambdabot>    arising from a use of `e_144'
09:42:34 <lambdabot>  The type variable `m0' is ambiguous
09:42:34 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:43:09 <simpson> rien_: return x = (x, mempty)
09:43:28 <rien_> oh, so:
09:43:42 <rien_> > runWriter do { x <- return 4; tell "4 went in" ; return x }
09:43:43 <lambdabot>  <hint>:1:11: parse error on input `do'
09:44:24 <simpson> > runWriter $ do { tell "things"; return 4 }
09:44:25 <lambdabot>  (4,"things")
09:44:47 <rien_> > runWriter $ do { x <- return 4; tell "4 went in" ; return x }
09:44:48 <lambdabot>  (4,"4 went in")
09:44:52 <rien_> there we go!
09:44:57 <rien_> that's what I expected
09:45:08 <rien_> Ok that makes sense now :) I can go from here I think
09:45:32 <rien_> thanks a lot for the handholding simpson, jle` :)
09:45:52 <simpson> Sure.
09:45:56 <jle`> np
09:50:00 <rien_> oh quick small question, how should I model () in another language? just create a struct called "unit" that holds nothing? or does it need laws to make it composable?
09:50:14 <rien_> it's a Scheme where I'm porting this to
09:51:00 <guesting> Does anyone know a good algorithm for sparse svd? Or an already existing haskell function for sparse svd?
09:51:20 <`^_^v> why not just use '() in scheme
09:51:59 <rien_> `^_^v: would that be morally equivalent? heh
09:52:09 <rien_> I guess it's just a stand-in type then
09:52:24 <`^_^v> well you are going from a statically typed language to a dynamically typed one
09:52:33 <`^_^v> so just do whatever, man
09:52:50 <rien_> `^_^v: actually no I'm using algebraic types in this scheme (Racket)
09:54:24 <platz> I wonder how much low-hanging fruit there is for porting small/medium size libraries from other languages to haskell
09:54:41 <supki> rien_: () is a datatype with one value, e.g.  data Unit = Unit
09:54:54 <joehillen> platz: lots
09:55:27 <platz> thats encouraging, yeah
09:55:48 <rien_> supki: ok so it shouldn't matter what I pick, thanks.
09:56:47 <joehillen> platz: for example, I would personally love if there was a Haskell equivalent to the requests library in python http://docs.python-requests.org/en/latest/
09:57:44 <platz> joehillen: too much boilerplate in http-conduit?
09:58:13 <joehillen> well, it's the fact you have to use conduit, which doesn't isolate well
09:58:48 <CaveJohnson> Network/FastIRC/Messages.hs:31:1: Warning: Module `Data.Attoparsec.Char8' does not export `many'
09:58:50 <CaveJohnson> Hmm. :/
09:58:51 <joehillen> just a simple straight-forward http request library
09:59:34 * hackagebot chatter 0.1.0.4 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.1.0.4 (RoganCreswick)
10:01:06 <platz> I think kenneth reitz put a lot of hard work into making a nice API look easy
10:02:04 <joehillen> I don't think it looks easy, but it's definitely easy to use
10:02:52 <guesting> If there is no good sparse svd algorithm, can I use FFI to send a matrix to R which can do it?
10:02:56 <jfischof1> I find all the http libs good for more complex stuff, and annoying for a simple json post
10:03:38 <joehillen> jfischof1: exactly
10:04:39 <jfischof1> it would be nice to have a wrapper lib that just did a few simple things with tweet level keystrokes
10:05:20 <jfischof1> ruby has something like open(urlOrLocalFile) that I miss
10:05:37 <jfischof1> would be easy to make
10:10:02 <CaveJohnson> Ugh, still won't compile. :(
10:10:45 <orion> Hi. Are there any processors in existence which have a pure functional instruciton set?
10:10:48 <orion> instruction*
10:11:00 <simpson> orion: What would that entail, exactly?
10:11:04 <colDrMcBeardman> orion, long ago there was a lisp machine
10:11:22 <colDrMcBeardman> which was pretty cool in the sense that you could inspect any part of the system at run time in the interpreter.
10:11:29 <colDrMcBeardman> but they are long dead.
10:12:31 <orion> "The processor did not run Lisp directly, but was a stack machine with instructions optimized for compiled Lisp." <-- Lisp machine
10:13:02 <byorgey> orion: you might be interested in http://www.cs.york.ac.uk/fp/reduceron/
10:13:26 <platz> green arrays are interesting but i believe it's stack-based
10:13:57 <colDrMcBeardman> oh i forgot about reduceron
10:14:39 <Taneb> It saddens me that my university seemed to do so much Haskell until about 3 years before I got here
10:20:50 <lllllllllllll> @pl (\_ -> return "A")
10:20:50 <lambdabot> const (return "A")
10:23:57 <romm> Taneb: Unless your uni is into programming languages / language design, I guess it's pretty understandable, no?
10:24:36 * hackagebot clafer 0.3.5 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.5 (mantkiew)
10:24:47 <Taneb> romm, one of the authors of the Haskell report was one of my lecturers last term
10:25:19 <romm> Taneb: hah! Well in that case I have no idea :)
10:25:38 <colDrMcBeardman> a lot of schools have a board of `industry'
10:25:49 <colDrMcBeardman> ' people who help dictate the curriculum choices.
10:26:12 <colDrMcBeardman> these pointy-haired people care more about $buzzword than being able to actually understand concepts.
10:26:47 <thoughtpolice> Taneb: who?
10:26:49 <platz> i think it also has to do with job placement, if employer are demanding students have java experience
10:26:56 <romm> colDrMcBeardman: I actually meant in the other direction. From a CS point of view (diregarding programming languages) Haskell is not important.
10:26:58 <tac> Hey. Does anyone know where the SPJ presentation on Lenses is?
10:27:00 <Taneb> thoughtpolice, Colin Runciman
10:27:14 <tac> nvm
10:27:18 <Taneb> (I mentioned this because he worked on the Reduceron)
10:27:20 <tac> I guess it's not on youtube, but I found it
10:27:39 <colDrMcBeardman> romm, yet oddly cs programs pick java, despite the fact that hs would give you more concepts to talk about in a formal setting
10:28:09 <thoughtpolice> Taneb: ah, very cool
10:28:11 <tac> orr not....
10:28:14 <tac> wtf skillsmatter
10:28:43 <romm> colDrMcBeardman: Again, only in a "programming language" setting. Programming is like 5% of the courses you take in a CS major
10:28:55 <colDrMcBeardman> tac: i worked with someone who graduated from the same uni five years before me, and while he knew way more about java than me, i watched him try to solve a CF problem with 150 lines of regexes.
10:29:17 <romm> colDrMcBeardman: Almost all the other courses have an imperative, mutable, setting.
10:29:37 <tac> I guess I'll re-ask my question since I can't seem to find it
10:29:46 <tac> does anyone know where the SPJ lens video is? >__>
10:29:47 <mmmm> one sec tac
10:30:28 <mmmm> https://skillsmatter.com/skillscasts/4251-lenses-compositional-data-access-and-manipulation
10:30:43 <tac> There's no video on that page though, it seems
10:30:50 <tac> Or I guess I have to log in now?
10:30:51 <platz> tac: you need to log in to view it
10:31:02 <tac> That's stupid... but all right. Thank you :)
10:31:13 <colDrMcBeardman> romm, in the cs classes i took where there was not much programming, it was generally theoretical enough to not dictate a priori mutability or imperativity.
10:31:27 <colDrMcBeardman> in fact, most of the abstract stuff was very declarative.
10:31:52 <colDrMcBeardman> yet the introductory materials were all java and C++.
10:32:11 <magicman> For some reason my ghc --version is 7.4.2, but its -cpp option reports __GLASGOW_HASKELL__ as 704. O_o
10:32:19 <mmmm> The first taught language for me was haskell
10:32:28 <romm> colDrMcBeardman: I find it hard to believe. Take a look at Cormen, or any datastrcuture book.
10:33:00 <romm> colDrMcBeardman: Take a look at classic AI courses. Almost all non-math courses have a very imperative setting.
10:33:05 <magicman> a) Is this what it's supposed to be? b) If not, how do I fix it, short of reinstalling my entire haskell? ( c) If "reinstall everything", then oh, well...)
10:33:08 <Redz> is it okay to use CC0 as license for code?
10:33:19 <supki> magicman: 704 means 7_04
10:33:33 <supki> magicman: e.g. 7.10.1 will be 710
10:33:43 <magicman> Ahhh, that makes sense.
10:33:48 <magicman> *phew*
10:33:52 <colDrMcBeardman> romm, data structured were introductory stuff.
10:34:09 <magicman> Then I'll have to dig further to find out where stuff is going wrong, but thanks :)
10:34:10 <colDrMcBeardman> once you get to algos, theory, and complexity, it's much more math-oriented.
10:34:27 <Clint> Redz: why wouldn't it be
10:34:38 <romm> colDrMcBeardman: Cormen is algos, as I'm sure you're aware. All the pseudo-code is pretty imperative.
10:35:27 <darkangel> Hi All. Can somebody point me how to write in one line monadic if then else?
10:35:30 <romm> colDrMcBeardman: And in the more theoretical courses we didn't do any programming at all, so there's no point talking about them
10:35:49 <Redz> Clint: license compatibility or something else. or maybe same reasons why other CC licenses aren't used for code.
10:36:07 <mello> can anyone explain me what's happening here? (>>= readMay)
10:36:10 <mello> :t readMay
10:36:11 <lambdabot> Not in scope: `readMay'
10:36:32 <mello> readMay is Read a => String -> a
10:36:35 <romm> colDrMcBeardman: All I'm saying is that since all the intro stuff is in an imperative setting, it's understandable why schools choose python/c++/java over FP language.
10:36:45 <mello> (>>= readMay) :: Read a => Maybe String -> a
10:36:46 <Clint> Redz: should be fine, afaik
10:36:57 <mello> (>>= readMay) :: Read a => Maybe String -> Maybe a*
10:37:01 <Redz> thanks Clint. :)
10:37:03 <darkangel> Hi All. Can somebody point me how to write in one line monadic if then else?
10:37:10 <Clint> darkangel: what do you mean by that
10:37:17 <colDrMcBeardman> romm, vacuously, yes. and yet once people get past those intro courses, many end up getting totally lost because things get too "abstract"
10:38:08 <darkangel> do { b <- someAction; if b then c else d; } - i wanna something line someAction =>> ...
10:38:13 <colDrMcBeardman> romm, like when they got to a class they called language concepts, they would be lost by things like templating... because they think of C++ templates and had no idea of what ASTs are
10:38:24 <darkangel> i dont wanna introduce b variable
10:39:00 <colDrMcBeardman> not saying haskell would automagically fix that, but it gives you some better options to discuss things like type systems and syntax tree manipulation at a much earlier stage.
10:40:04 <romm> colDrMcBeardman: I never had a class about language concepts :) I don't mind optional courses about FP and language concepts, but I still don't think teaching Haskell instead of Java is a good idea.
10:40:39 <ReinH> romm: the University of Texas used to use Haskell and Dijkstra objected to switching to Java. Then he left. And they switched to Java.
10:40:57 <colDrMcBeardman> romm, i think leaving out imperative languages is as foolish as leaving out function languages.
10:40:59 <romm> ReinH: Yeah, I've read about that.
10:41:16 <ReinH> I think that Haskell provides a great base for understanding impertive languages
10:41:40 <ReinH> Because haskell provides ways to write powerful imperative langauges in the runtime without sacrificing the ability to reason about your code
10:41:53 <darkangel> Clint: do { b <- someAction; if b then c else d; } - i wanna something line someAction =>> ...
10:41:57 <colDrMcBeardman> ReinH, honestly in a sense most people are more used to declarative syntax from basic mathematics, so i think you make a good point
10:42:09 <darkangel> Clint: i dont wanna introduce b variable
10:42:17 <colDrMcBeardman> that learning imperative style in the context of something like haskell would be a gentler introduction in a way.
10:42:31 <ReinH> :t when
10:42:32 <lambdabot> Monad m => Bool -> m () -> m ()
10:42:32 <Clint> darkangel: i guess it depends on the monad then
10:42:44 <darkangel> Clint: IO
10:42:45 <ReinH> @pl \b -> when b c d
10:42:45 <lambdabot> flip (flip when c) d
10:42:55 <ReinH> darkangel: I'd suggest introducing a b variable
10:43:46 <darkangel> ReinH: when is for only one action - "then" i need "else" too
10:44:07 <ReinH> darkangel: you can write your own function
10:44:24 <ReinH> darkangel: and I know, I was just pointing out the difficulty of using a similar function pointfree in the position you want
10:44:39 * hackagebot claferwiki 0.3.5 - A wiki-based IDE for literate modeling with Clafer  http://hackage.haskell.org/package/claferwiki-0.3.5 (mantkiew)
10:44:51 <darkangel> ReinH: :) I know that. I can write i just looking for something existing
10:45:43 <darkangel> ReinH: actual case is if deosFileExists "foo" then a else b
10:46:35 <darkangel> ReinH: How to write this without introducing c <- doesFileExists binding?
10:46:42 <colDrMcBeardman> darkangel, someone asked earlier about m Bool -> m a -> m a -> m a and i found ifM but it's in some weirdly specific package.
10:48:27 <supki> darkangel: does  a  do something with "foo"?
10:48:32 <darkangel> colDrMcBeardman: cant find that package
10:48:39 <ReinH> darkangel: I don't know of a nice way. I would just add a binding.
10:48:58 <darkangel> supki: y
10:49:22 <supki> darkangel: in general, you just do  a  and catch whatever exception is thrown if "foo" actually does not exist
10:49:25 <colDrMcBeardman> darkangel, fwiw, the ifM in scyther-proof uses a binding.
10:49:30 <supki> otherwise there's a race condition
10:49:39 <darkangel> supki: actualy both a and b take "foo"
10:49:53 <supki> darkangel: what if someone deletes "foo" between a check and  a?
10:50:15 <ReinH> darkangel: if I *really* wanted to avoid adding the binding for some reason, I would write my own (rather odd) ifM that took the bool in the last position
10:50:30 <darkangel> supki: i think this is wierd solution to handle exception where i should't
10:50:34 <ReinH> but I don't see why I should be allergic to a binding there
10:51:09 <ReinH> just: let ifM ma ma' b = if b then ma else ma'
10:51:23 <darkangel> ReinH: coz i dont like to NAME it :)
10:51:27 * ReinH sighs
10:51:36 <ReinH> darkangel: I don't share your phobia for naming things
10:51:45 <ReinH> naming things provides valuable information
10:51:50 <colDrMcBeardman> it's not like the name isn't contained in that scope, either.
10:51:57 <darkangel> not in this case for sure
10:52:29 <ReinH> so I find it difficult to entertain "what if you were going to do this thing you wouldn't actually ever do?" type questions ;)
10:53:45 <supki> aren't we going to have  bool :: a -> a -> Bool -> a  in 7.8?
10:53:58 <supki> it would help with this problem
10:54:24 <defanor_> i'm trying to use acid-state (have only a vague idea how it works btw, just trying to practice in haskell), but looks like it stores only initial state, and i can't find out why. here is the code: http://paste.uberspace.net/acid-state.hs.html, some help would be.. helpful
10:54:35 <supki> darkangel: surely you can choose not to handle a race condition, that just does not mean it goes away :)
10:54:45 <edwardk> wow, the fact that yu have to log in to watch the SPJ video is really really annoying
10:54:47 <ReinH> you can import it from Data.Bool.Extras in the meantime
10:55:01 <tac> edwardk: isn't it, though?
10:55:01 <ReinH> edwardk: which spj video?
10:55:07 <edwardk> ReinH: the one on lenses
10:55:13 <ReinH> ah
10:55:22 <ReinH> edwardk: trying to learn about lenses are we?
10:55:29 <edwardk> had i known it required registration/login these days I wouldn't have linked from the haddocks for lens
10:55:58 <tac> Does Skillsmatter end up owning some kind of copyright on the videos on their site?
10:56:07 <tac> It would be nice to see that video put on YouTube
10:56:12 <ReinH> +1
10:56:18 <tac> because it was one of SPJ's best... not that SPJ has anything but the best.
10:56:19 <darkangel> supki: what kind of races u talking about? Than 0.000001% chances that some UFO remove my file from disc? Or put it on?
10:56:51 <darkangel> supki: :)
10:57:14 <edwardk> Yeah, with everyone talking about lenses these days I figured I should learn what they are.
10:57:14 <platz> it looks like the video was hosted on vimeo, but it's hidden from public view
10:58:03 <tac> I actually have a semi-plausible usecase for lens in my IRC bot
10:58:06 <ReinH> edwardk: well the SPJ video is a good introduction for someone who's new at lenses, like you are.
10:58:27 <tac> So I figured as long as I'm going to rip it apart, I might as well try out lens
10:58:28 <edwardk> My best guess is that a Lens from S to V is a monad-algebra of the delta-sigma monad in the slice category of Hask/V, or that they somehow involve proarrow equipments and functors between proper subcategories of Prof, but that video was going to set me straight.
10:58:52 <ReinH> yeah probably best to just watch the video then
10:59:17 <edwardk> yeah, surety is better, rather than guessing at its contents.
10:59:17 <tac> I can't tell if you just made up "delta-sigma" monad or not.
10:59:28 <edwardk> tac: it is real ;)
10:59:48 <tac> edwardk: But it's not real enough to appear in Google's search results.
10:59:55 <edwardk> tac: that actually does work as a characterization of lenses.
10:59:57 <edwardk> one sec
11:01:26 <edwardk> tac: see http://comp.mq.edu.au/~mike/papers/74.pdf  and the monad T_{\Delta\Sigma}
11:02:03 <edwardk> section 2.3 makes the first part of what i said there rigorous
11:02:16 <edwardk> for the profunctor version you need access to my whiteboard ;)
11:02:46 <syllogismos> i tried watching that spj video a while back.. i only understood maybe 30 percent of it.. i couldn't help but think why does setter and getters have to be that complicated..
11:03:23 <edwardk> syllogismos: in isolaton? they don't, but taking that approach has a _lot_ of extra benefits you don't get from simpler approaches
11:03:30 <tac> syllogismos: Part of what makes them so complicated is Haskell lets you *make* them complicated.
11:04:12 <defanor_> tried to create checkpoing in a loop after closing acid state (by an accident), and now it stores the data, but crashes
11:04:18 <jfischof1> syllogismos: its so they compose with other things that benefit from the complexity
11:04:19 <syllogismos> haskell can be very hard on newbs..
11:04:21 <defanor_> checkpoint*
11:04:31 <edwardk> syllogismos: when written that way they just compose correctly, you can write getters and setters that aren't the opposite and so only work in one direction, you can generalize to things that view multiple targets, you can reverse and pattern match with their dual and compose those in series.
11:05:04 <edwardk> syllogismos: lens is definitely _not_ targeted at the haskell newbie audience. it is more a powertool for someone who already knows how haskell fits together.
11:05:08 <defanor_> when trying to do it before loop, it does not work
11:05:50 <edwardk> syllogismos: parts of it can be used without that understanding but you'll be asking a lot of questions. on the other hand, the benefit of this complexity is that the abstraction _remains_ relevant to you even once you do know what you are doing
11:06:11 <jfischof1> lens is only partially about lenses. I wish it was named something else :(
11:06:20 <AlainODea> syllogismos: learning lens as a start is akin to learning Java via a dependency injection framework.  It's an advanced use case even for experienced Haskell programmers
11:06:27 <syllogismos> yeah i figured that earlier.. but no other language introduced me to soo many concepts that i never even heard about..
11:06:30 <jfischof1> something like mono-base
11:06:32 <edwardk> jfischof1: given it to do over again i might call it traversals or optics
11:06:40 <jfischof1> yeah
11:06:45 <jfischof1> traversals is betters
11:07:07 <edwardk> syllogismos: yeah that was true for me in haskell as well long bfore lens existed. lens just steepens the learning curve a bit ;)
11:07:08 <jfischof1> optics sounds cooler :)
11:07:11 <romm> syllogismos: You're like me 4 months ago. I still have no idea what these people are talknig about.
11:07:28 <platz> optics sounds like politics and marketing
11:08:06 <jfischof1> syllogismos: prisms, and custom traversal are so useful, that once you get the hang of it, you put up with the complexity
11:08:08 <AlainODea> syllogismos: if I enumerate the things I needed to learn to be effective at Java they outnumber those I required for Haskell. Everything is obvious once you know the answer
11:09:02 <napping> syllogismos: of course, "needed to learn to be effective" is a much smaller set of things than all the concepts that can be helpful to know
11:09:14 <jfischof1> Like so many things in Haskell lenses types make more sense when you perform subsitutions for the type variables and expand the newtypes and type syms
11:09:15 <edwardk> replace the legend with Foldable/Traversable: red, Applicative: blue, Monad Transformers: green, Lens: black in http://mmoreporter.com/wp-content/uploads/2011/02/LearningCurve1.jpg and it is pretty accurate.
11:11:28 <Apocalis_> edwardk: That chart speaks the truth.
11:12:08 <oinkon> if a recurcive function is not tail recursive and can't be tail called optimized, does ghc eventually run out of memory? is there a tracked max recursion depth or something like that?
11:13:20 <napping> oinkon: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/Stack
11:13:29 <Apocalis_> oinkon: http://www.haskell.org/haskellwiki/Stack_overflow
11:13:51 <napping> hmm, my link doesn't actually have what I meant
11:14:18 <lispy> oinkon: we don't use a call stack in Haskell
11:14:53 <lispy> oinkon: GHC (as an optimization) has a stack for evaluation, but it's different than what eager languages use for saving activation records.
11:15:42 <napping> oinkon: https://ghc.haskell.org/trac/ghc/blog/stack-chunks
11:17:38 <napping> oinkon: if the recursive function is building something like a lazy list there might not be any overflow, and no stack is generally used
11:17:40 <merijn> oinkon: To clarify the previous answers, you can write a haskell function that recurses arbitrarily many times, without hitting a recursion depth/stack overflow. Although some other things (notably, pattern matching) can run you out of memory and crash
11:18:17 <napping> stack space is only used up when forcing things, so a strict recursive function could use up lots of stack
11:18:46 <jfischof1> I guess the short answer is you can run out of memory, but things link foldr to output that is consumed lazily don't necessarily need special opimizations to maintain constant space, even when using infinite input
11:19:03 <napping> As of 7.2 or so the stack can be split into heap allocated chunks, so a limit before you run out of RAM is just something configurable to stop things from running away
11:19:29 <syllogismos> i want to look at some haskell code.. not libraries.. but something like programming puzzles? so that i have a problem statement and a solution in haskell.. i want to know how things like tree traversals bfs, dfs, etc are done.. can someone point me at some.. i solved some problems in hacker rank in python.. i would love to see how you solve them in haskell..
11:19:43 * hackagebot email-validate 2.0.1 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-2.0.1 (GeorgePollard)
11:20:11 <paulschellin> syllogismos: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
11:20:34 <syllogismos> it has solutions too?
11:20:37 <paulschellin> People have posted solutions all over the web
11:21:10 <paulschellin> You will get to see truly varied solutions for each one
11:21:26 <thoughtpolice> napping: stack chunks had nothing to do with any sort of limits in allocating stack space. they're an optimization - the old mechanisms used to copy the entire stack, and traverse the entire stack for every GC, even if parts of it were unmodified
11:21:45 <thoughtpolice> which is comparatively expensive.
11:22:11 <oinkon> the subtlies of lazy vs eager evaluation are slowly sinking in.
11:22:28 <napping> Okay, I was a bit mistaken along those lines
11:22:31 <syllogismos> waaaw,. i think thats what i was looking for all these days.. thank you.. paulschellin
11:22:45 <paulschellin> No problem
11:23:06 <napping> Still, stack chunks mean a stack can grow more or less indefinitely without extra expense
11:25:30 <magicman> Anyone here have experience with the plugins package in Windows?
11:25:42 <magicman> Code and errors here: http://lpaste.net/99263
11:26:35 <magicman> Basically, I use makeAll on a .hs file, then use load_ on the returned FilePath.
11:26:54 <magicman> Both are successful, otherwise another case alternative would be hit.
11:27:28 <magicman> Instead, it complains about "Could not load module C:\...\ghc-prim-0.2.0.0/HSghc-prim-0.2.0.0.o"
11:29:05 <zett_zelett> If I have a function `or' :: Bool -> Bool -> Bool; _ True = True; True _ = True; _ _ = False', what would be the leftmost-outermost reduction of `or' (1 == 2) (2 == (1+1))'?
11:29:24 <zett_zelett> Would (1 == 2) be reduced or not?
11:32:22 <platz> syllogismos: http://exercism.io has some good haskell problems, especially for beginners.  But the problems are fairly language-agnostic so you don't see a lot things requiring traversals (at least for the frist dozen problems or so).
11:32:50 <zett_zelett> On the leftmost-outermost thing, anyone?
11:32:54 <platz> you write to pass the provided tests
11:33:29 <platz> and get feedback from peers on your posted solutions
11:35:39 <klrr_> is there any way to use blaze-html without having to explicitly annotate toHtml's argument?
11:36:47 <magicman> zett_zelett: I can tell you about how GHC will cause it to be evaluated, I don't know if that corresponds to the definition of leftmost-outermost.
11:37:24 <platz> there's also https://www.fpcomplete.com/user/DanBurton/20-intermediate-exercises which is more idomatic to haskell
11:40:56 <klrr_> also, is there any way to convert a string or text to a attributevalue?
11:41:10 <levi> zett_zelett: This is my understanding, which may not be 100% correct: Pattern matching (unless it's irrefutable) forces evaluation to weak-head normal form, which effectively means until you hit an expression that's a data constructor. Patterns are tried from top to bottom, and evaluation stops at the first one what matches.
11:41:52 <klrr_> nvm toValue solves the latter quseton :)
11:42:02 <zett_zelett> Yeah, this is what Haskell does at least, levi. But is it leftmost-outermost reduction?
11:42:30 <zett_zelett> Maybe 'leftmost' should be 'topmost'.
11:42:46 <zett_zelett> And leftmost-outermost reduction is really topmost-outermost reduction.
11:43:01 <magicman> I wonder what, in a case expression, is the leftmost-outermost redex. Or topmost-outermost.
11:43:27 <magicman> I realize that that is essentially what you're asking >_>
11:44:07 <zett_zelett> So pattern matching are really case expressions in disguise?
11:44:31 <magicman> Yeah.
11:45:30 <levi> Most of haskell is based on data constructors and case expressions in various amounts of disguise.
11:47:19 <levi> Data constructors of a type together form the introduction rules, while case analysis of the type forms the elimination rules.
11:47:34 <platz> erik meijer made an interesting point that (i think) pattern matching is analagous to dynamic dispatch in OO, since both inspect the type to figure out which 'branch' to take
11:48:47 <bennofs> platz: except that GHC can check that you don't miss a pattern and warn about it
11:49:09 <levi> This is related to the algebra/coalgebra distinction and the notion that object-oriented programming is primarily coalgebraic.
11:49:18 <platz> bennofs: same thing with abstract classes
11:49:46 * hackagebot happstack-server 7.3.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.3 (JeremyShaw)
11:49:48 <levi> At least for some particular sense of what 'object-oriented' means.
11:50:49 <ReinH> levi: I was asked to explain "functional programming" the other day. I should have just said no.
11:50:59 <platz> how would I learn about coalgebras?
11:51:18 <platz> is it under the CT rubrik?
11:52:27 <ReinH> well, in a CT sense there are dual to unital associative algebras
11:52:34 <tac> First learn about algebras, then turn all the arrows around.
11:53:10 <ReinH> Or, perhaps more specifically to Haskell, F-algebras and F-coalgebras
11:53:17 <platz> I think i need to crack open my old abstract algebra book first then ;)
11:53:50 <platz> ReinH: thats a start, then, thanks
11:53:58 <levi> I learned about coalgebras by reading blogs and then browsing through google results on terms I wasn't familiar with. My understanding is not particularly deep, though.
11:55:00 <ReinH> levi: I basically learned by trying to figure out wtf a comonad is :)
11:55:32 <levi> One interesting thing is that, in Haskell, data and co-data share the same representation.  I.e. List is also Stream.
11:55:43 <ReinH> right
11:56:00 <platz> Young man, in mathematics you don't understand things. You just get used to them.
11:56:10 <ReinH> F-coalgebras as a way to model machines is also particularly interesting
11:56:16 <ReinH> platz: ha
11:56:18 <levi> I.e., List is the data type and Stream the codata type that share the same functor signature, or something to that effect.
11:56:38 <platz> Neumann was kind of a jerk
11:57:53 <levi> "F-coalgebras as automata" is essentially the same argument as "F-coalgebras as objects", as long as you have a view of object oriented programming that's compatible with that notion.
11:58:06 <platz> I tried reading http://www.cs.ox.ac.uk/jeremy.gibbons/publications/adt.pdf and it started talking about codata and got lost
11:58:49 <ReinH> levi: right
11:59:31 <ReinH> levi: thus "lenses are the coalgebras of the costate comonad" and the relationship between lenses and oop as well
12:00:14 <levi> platz: I didn't understand most of the papers I read at first either. I still don't grasp *all* of many of them. Just give it time and keep reading/thinking/using.
12:00:37 <ReinH> the using part cannot be overemphasized
12:00:48 <ReinH> well, I mean it could be, but you'd have to try pretty hard
12:00:55 <platz> levi: thanks, will keep at it then!
12:02:03 <levi> platz: And, at least for me, it was helpful to browse and skip around in my sources. Eventually, when I come back to something, my brain has processed the previous reading and I have a bit of different context and a different set of ideas sink in.
12:02:42 <levi> And then I try to discuss it with people here and discover the terrible flaws in the way I'd put things together. ;)
12:04:03 <platz> good advice...
12:04:48 * hackagebot happstack-heist 7.2.3 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.2.3 (JeremyShaw)
12:06:04 <chirpsalot> Whoops. Managed to create a data type that makes just about 0 sense because there are no references >_<.
12:06:14 <ski> platz : rather pattern-matching is dual to message-dispatching
12:06:44 <BMeph_> ZipList is the Applicative instance for Streams (well, AN Applicative, anyway). That's how I think of it, anyway.
12:06:50 <platz> have to say this group is pretty stellar here.  There sure are other chans which are less encouraging and helpful
12:07:25 <ski> also, i'd say neither pattern-matching nor message-dispatching "inspect the type tofigure out which 'branch' to take"
12:08:16 <chirpsalot> platz: agreed :). I love how a bunch of people here are so willing to essentially code-golf your first attempts at doing something completely random.
12:08:17 <leino> Data.Binary.Get seems to work only with lazy bytestrings, and not with strict. Why is it that no strict versions of the functions are supplied?
12:08:30 <platz> ski: I hesitated to say "dispatch" , I was also thinking of something related to polymorphism, but I think erik used some "dispatch" word
12:08:53 <ski> possibly
12:09:29 <ski> anyway, imo, it's a misconception that pattern-matching somehow checks the type of the value
12:09:48 <leino> ...and on a related note, does it make sense to turn a strict bytestring into a lazy one just so I can use the functions from Data.Binary.Get?
12:09:48 * hackagebot happstack-hsp 7.3.0 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.3.0 (JeremyShaw)
12:09:50 * hackagebot happstack-jmacro 7.0.8 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.8 (JeremyShaw)
12:09:52 * hackagebot hsx-jmacro 7.3.4 - hsp+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.3.4 (JeremyShaw)
12:10:29 <jfischof1> ski: its an implementation detail, but operational thinking is many times a first start
12:10:51 <ski> (probably stemming from the bad attempt of simulating variant/sum types as an abstract base class (or interface) with concrete subclasses (or implementing classes) for the cases, e.g. using `instanceof' to branch)
12:10:52 <platz> although in scala i'm not sure that is the case
12:10:53 <jfischof1> maybe not the best start, that's another thing :p
12:11:30 <ski> jfischof1 : yes, a somewhat bad conception may be better than no conception at all .. for a while
12:12:08 * jfischof1 nods
12:12:19 <Yaniel> is it possible to use types for pattern matching at all?
12:12:22 <Yaniel> or just values
12:12:40 <levi> Well, I think the problem is rooted at using the same word, 'type', to describe static types and dynamic value variants.
12:12:59 <ski> Yaniel : imo, only the latter is sensible
12:13:08 <ReinH> Yaniel: types are usually matched at the type level. You know, like by the type system. ;)
12:13:12 <guesting> Let's say I have a tree:  data Tree a = EmptyTree | Node a !(Tree a) !(Tree a). How can I assign each node a UNIQUE value?
12:13:21 <levi> Well, in a dependent type system....
12:13:23 <guesting> oops, ignore the bangs
12:13:32 <ski> levi : possibly
12:13:37 <ReinH> levi: oh I thought we were talking about Haskell :)
12:13:45 <merijn> guesting: You mean you want no value in the Tree to appear twice in said tree?
12:13:59 <Yaniel> or is there some type that covers practically anything?
12:14:01 <guesting> merijn: I essentially want to label the nodes
12:14:01 <ReinH> guesting: uh, can you motivate that question such that I can't just answer "just assign them unique values"?
12:14:16 <levi> Well, we were talking about topics relevant to Haskell. Pointing out how Haskell is different from other things is sometimes relevant.
12:14:16 <merijn> guesting: Right, just add another field for a unique identifier?
12:14:33 <guesting> merijn, yes, but how can I traverse it giving each node a unique value?
12:14:43 <ReinH> tree annotation!
12:14:49 * hackagebot happstack-lite 7.3.3 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.3.3 (JeremyShaw)
12:14:51 * hackagebot boomerang 1.4.2 - Library for invertible parsing and printing  http://hackage.haskell.org/package/boomerang-1.4.2 (JeremyShaw)
12:14:54 <merijn> guesting: You need to change the data type
12:14:57 <guesting> right now I am recursively going through, but I can't just pass down an integer
12:14:58 <ReinH> effectful tree traversal!
12:15:31 <merijn> guesting: Or rather, you don't *need* to, but that'd be by far the easiest
12:15:48 <guesting> because giving a node, say n+1 and the next n+2 and passing down n+3 and n+4 won't work at all for obvious reasons
12:16:17 <guesting> merijn: What do you mean, change the data type? How so?
12:16:29 <merijn> guesting: One example: "data Tree a = Leaf | Node Int a (Tree a) (Tree a) | Root Int (Tree a)"
12:16:31 <ski> guesting : state monad ?
12:16:51 <merijn> guesting: Have the Root store the current maximum and make sure any update to the tree updates the root?
12:16:57 <ski> guesting : or a splittable environment could also work
12:17:06 <ReinH> merijn: you can just keep the same structure and annotate with a function a -> (b, a)
12:17:19 <ski> (if you don't care about ordering and contiguousness of tags)
12:17:29 <merijn> ReinH: Right, depends whether he wants to expose the tags or not
12:17:39 <ReinH> or create a separate tree with the annotations
12:17:52 <Yaniel> so basically would it be possible to match against the number 5 or any string in the same function?
12:17:58 <mmmm> Is this not a classic state monad practice question
12:18:08 <merijn> mmmm: "It depends" :)
12:18:09 <guesting> merijn: How will each new update to the tree, changing the root, change the other "half" of the binary tree though?
12:18:14 <ski> Yaniel : only if you first match on other data values first
12:18:57 <Yaniel> with _ ?
12:18:58 <BMeph_> guesting: Exploit that you know it's a binary tree - on each branch, when you use, say 'k', "pass down" 2*k. ;)
12:19:07 <Yaniel> as in, match whatever and then _
12:19:25 <Yaniel> but _ would accept other stuff than strings too
12:19:48 <ski> Yaniel : consider `data Value = forall a. Val (WhatsIt a) a' and `data WhatsIt :: * -> * where ItsAnInt :: WhatsIt Int; ItsAnotherInt :: WhatsIt Int: ItsAString :: WhatsIt String'
12:19:50 * hackagebot language-puppet 0.11.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.11.0 (SimonMarechal)
12:19:52 * hackagebot libjenkins 0.4.0.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.4.0.0 (MatveyAksenov)
12:19:52 <ReinH> per merijn, traversal in the state monad holding some enumerable label
12:20:06 <ReinH> er per mmmm
12:20:11 <guesting> BMepth_: that's guarenteed, isn't it?
12:20:13 <guesting> hmm
12:21:10 <ski> Yaniel : so then you can write `frob :: Value -> String; frob (Value ItsAnInt n) = show n; frob (Value ItsAnotherInt n) = show (n^2); frob (ItsAString s) = s'
12:21:47 <rien_> jle`: https://gist.github.com/peternmr/a0ad2b8f16071b972327
12:21:58 <ski> Yaniel : makes any sense, or was that all greak to you ?
12:22:11 <Yaniel> so kind of like C++ function overloading?
12:22:19 <ski> .. not at all
12:22:32 <Yaniel> or hm
12:22:33 <ski> (no overloading at all, there)
12:22:55 <merijn> Hakyll question: Anyone here know what the simplest way is to include a link to an alternate version of a post inside the post body? (i.e. I wanna say "my alternate version of this post is here" and then link to that, but the link to the alternate version is determined by Hakyll's routing, so I don't know it while writing the post body)
12:23:11 <ski> (well, `show' is overloaded, but we can pretend it has type `Int -> String', and also that `(^)' has type `Int -> Int -> Int', and the code will still work the same)
12:23:12 <Redz> is it possible to do code optimization via template haskell? it seems so.
12:23:25 <bitemyapp> Redz: ow.
12:23:27 <levi> ski was using a data type to enumerate the types you could store, and then using a *value* of that enumeration to match on in the case analysis.
12:23:37 <Yaniel> ah
12:23:42 <ski> yes
12:23:59 <ski> so in some sense, i was "simulating" (a restricted set of) types, in values
12:24:35 <ski> so that when the run-time knows it's seeing a particular value, then the type checker at compile-time knows that `n'/`s' must have a particular type
12:24:43 <Yaniel> I guess I'll come across this again when I get back to studying haskell
12:25:01 <ski> (one could think of this sortof as a kind of strange "backwards-in-time" communication ;)
12:25:18 <Redz> bitemyapp: is was thinking of writing structures where indizes can be automatically generated from used queries.
12:26:29 <ski> Yaniel : it's not needed in most everyday programming, but there do come up cases where it can be pretty handy -- perhaps as we get more experienced with it, we will find we reach more often for it
12:26:59 <ski> it's definitely one of the "fun things" to think about in Haskell
12:27:02 <Yaniel> maybe
12:27:07 <magicman> Retry, as I see some other people here: I'm having some trouble with the "plugins" package. The make-phase succeeds, as does the load-phase, but then it says "Could not load module" with something ghc-prim related.
12:27:14 <magicman> http://lpaste.net/99263
12:27:42 <guesting> BMepth_: Thank you! It seems to work well, I just hope that big numbers don't destroy it...
12:28:09 <Yaniel> I definitely need to study it more, I'm currently in an awful limbo between knowing some basic arithmetic and actually unders^Wgetting used to things
12:29:51 * hackagebot jsonrpc-conduit 0.2.3 - JSON-RPC 2.0 server over a Conduit.  http://hackage.haskell.org/package/jsonrpc-conduit-0.2.3 (GabrieleSales)
12:31:22 <rien_> this is a potentially stupid question: if return and bind are the building blocks of Monads, what are the building blocks of Monad Transformers?
12:31:40 <merijn> rien_: Monads :p
12:31:56 <dwcook> rien_, monad transformers leverage those as well as lift
12:32:03 <s778> Is http-client-conduit the same as http-conduit?
12:32:12 <rien_> so I get transformers for free?
12:32:15 <rien_> but...
12:32:15 <merijn> rien_: They don't really have a building block, tbh. monad transformers are just monads parameterised over other monads
12:32:29 <merijn> s778: I'm guessing http-conduit also has support for server side?
12:33:26 <s778> merijn: I don't think say, both  state 'http client package'
12:33:39 <rien_> merijn: then I don't understand something. I want a Writer ( Either a b, w ). I already have Writer and Either coded separately. so now what?
12:34:20 <s778> ah nevermind, turns out http-conduit is build on top of http-client-conduit ...
12:34:26 <rien_> merijn: how do I make the do notation understand that the things I do in the context should always be lifted appropriately to both those monads?
12:34:31 <merijn> rien_: Now you're boned and will have to implement a WriterT writer transformers
12:34:52 <merijn> rien_: You can't convert a Writer monad into a Writer transformer
12:35:38 <lemao_> platz: trying to grok data vs codata I came across this that helped me walk a few steps forward: http://types2004.lri.fr/SLIDES/altenkirch.pdf
12:35:57 <merijn> rien_: This is also why in reality State, Writer and Reader are just synonyms for StateT/WriterT/ReaderT + Identity monad, since the Identity monad "does nothing" it can be used as a transparent basis to turn the WriterT into Writer by just wrapping Identity
12:35:57 <rien_> merijn: ok so you're saying I'm supposed to write the plumbing myself
12:36:11 <merijn> rien_: However, there's no way to go the other way (i.e. from Writer to WriterT)
12:36:29 <rien_> merijn: that makes sense
12:36:59 <rien_> merijn: let me rephrase my question then
12:37:22 <merijn> rien_: The good news is: If you're actually coding something, someone already did this. If you're practicing, understanding WriterT after implementing Writer should be fairly easy
12:37:49 <rien_> merijn: I wrote Writer and Either in scheme. now I want a monad that acts like both (specifically like Writer (Either a b, c)) - question: do I have to write a brand new monad (new return and bind) to do the plumbing I want, or is there a way to compose the Either and Writer I already have?
12:38:15 <levi> There are two styles of monad transformer programming; in one, you manually lift things, and in the other, you use typeclasses to provide your monad operations at the type class for your transformer, and then you implement a combinatorial explosion of operations at instances for various transformers.
12:38:26 <merijn> rien_: You'll have to write a brand new monad
12:38:56 <rien_> merijn: ah, ok that's good to know, so I'm not missing anything then. :)
12:39:02 * ski isn't really satisfied with the typeclasses style
12:39:11 <rien_> I mean understanding-wise. obviously I'm missing the combined monad I'm yet to write, heh
12:39:18 <merijn> rien_: :)
12:39:56 <merijn> rien_: Essentially, if "Writer w a" is "(w, a)", then "WriterT w m a" is "m (w, a)"
12:40:10 <rien_> merijn: check out how your old friends look in a new skin: https://gist.github.com/peternmr/a0ad2b8f16071b972327
12:40:26 <rien_> merijn: yes but as you can see on that link I don't have that kind of machinery
12:40:30 * ski recalls making a monad, parameterized on *two* other monads
12:40:33 <merijn> :)
12:40:45 <merijn> I've been meaning to learn Racket, but I keep putting it off :p
12:41:06 <rien_> merijn: you can start from that. no excuses now!
12:41:13 <ski> if you don't know about them, you should learn about hygienic macros
12:41:17 <levi> Racket is a pretty slick system, and only getting slicker.
12:41:17 <Qett> is there a description of a nice haskell programming style anywhere?
12:41:22 <Qett> like indentation and stuff
12:42:29 <levi> I'm not sure there's a complete consensus on 'good haskell style'.
12:42:37 <rien_> merijn: there's nothing to it, I have a few colleagues learning it on my recommendation and they'd never seen lisp before, and they could dive right in
12:43:09 <levi> I mean, SPJ uses braces and semicolons all over the place, not to mention Comic Sans.
12:45:54 <levi> I think most people end up developing a style by reading the code of various authors and taking the stylistic conventions they like from them.
12:46:07 <sm> rien_: cool
12:46:34 <merijn> Qett: A few general rules of thumb: Layout > braces and where > let
12:47:23 <quicksilver> let > where
12:47:24 <quicksilver> :P
12:48:50 <ski> Qett : align things like crazy ?
12:48:55 <levi> There's let vs where, layout vs. braces, parens vs. $, amount of point-free constructions...
12:49:20 <ski> let's not forget tabs vs. spaces
12:49:58 <Yaniel> tabs vs spaces indeed
12:50:04 <Yaniel> and how many spaces
12:51:00 <levi> Does anyone stick with tabs in haskell?
12:51:09 <Rembane> No
12:51:10 <Fuuzetsu> no
12:51:11 <Twey> One guy, somewhere
12:51:11 <AlainODea> ski: I never use tabs unless a language or format explicitly requires it.  Tabs mixed with spaces are particularly bad in Haskell
12:51:13 <dv-> no
12:51:18 <Rembane> He lives on a mountain
12:51:25 <Fuuzetsu> he's the worst kind of guy
12:51:25 <Twey> Nobody likes that guy
12:51:25 <AlainODea> tabs are for hipsters. Just sayin'
12:51:55 <Rembane> He has 30 000 virgin warriors guarding his golden palace.
12:52:02 <levi> I didn't think it was a real point of debate, but I thought I might have been missing something.
12:52:21 <ski> AlainODea : unless you only use tabs for layout, and break line after all layout-introducing keywords followed by a block of at least two lines
12:52:27 <merijn> levi: Well, GHC uses 8 column tab stops, so people using tabs get punished swiftly and harshly for their assumptions :p
12:52:41 * ski knows some people in here uses tabs for indentation, but can't recall who
12:53:30 <kristof> One day we will ascend from the lowly depths of programming by means of feeding a stream of ascii text into a machine.
12:53:37 <levi> It would be nice to have a formalized syntax that didn't rely on fixed-width characters, though.
12:54:20 <kristof> levi: fixed-width characters aren't actually necessary for programming.
12:54:33 <merijn> kristof: Take a look at Lamdu :p
12:54:34 * ski imagines kristof feeding sexprs^WASTs into the machine, from a refactoring, compiler-conversing, structural editor
12:54:39 <Twey> There are a few people who code Haskell with variable-width fonts
12:54:42 <Rembane> APL font is needed!
12:54:53 <levi> kristof: I'm well aware of that, but the Haskell Report defines the grammar of Haskell with specific reference to fixed-width characters.
12:54:58 <benmachine> "let" is awkward with variable-width
12:55:00 <kristof> ski: Actually... you caught me. :)
12:55:05 <benmachine> especially in do
12:55:10 <Twey> Since you only care about the width of spaces *before text*, it's fine — all *spaces* are going to be the same width anyway
12:55:14 <benmachine> well, actually, no, not especially there
12:55:21 <benmachine> but I stand by my initial statement
12:55:53 <ski> Twey : depends
12:55:54 <kristof> ski: I have plenty of ideas on programming in a tool which organizes your code in arbitrarily complex ways, while circumventing the paradigm of "stream of text"; these ideas come in 2D and 3D varieties.
12:56:29 <ski> kristof : you might have fun talking with Peaker about Bottle^WLamdu
12:56:47 <levi> Since it defines the open columns with pseudo-tokens, it should be possible to transform the Haskell grammar to define layout in terms of the abstract position of the pseudo-tokens that are still 'open' on a line, but the report doesn't currently do that.
12:56:47 <kristof> Unfortunately (or fortunately!) it doesn't lend itself well to object oriented program visualization.
12:57:09 <Twey> kristof: Oh no.
12:57:19 <kristof> Twey: :P
12:57:38 <Twey> That sounds *totally* useless.  How are you ever going to write *real* programs without objects?
12:57:39 <kristof> Twey: LightTable is pretty cool, in my opinion. I think it still falls in the same trap of "code as text", though
12:57:46 <Twey> Aye
12:57:54 <ski> kristof : hm, are you thinking of anything graph-like ? perhaps something "visual programming"-like ?
12:57:59 <Twey> Have you seen Bret Victor's stuff?
12:58:10 <Twey> Substroke &a.
12:58:27 <kristof> ski: I don't know what visual programming is but no, graphs would be kept miminal. I have some drawings on hand but I don't care much to upload them.
12:58:31 <erisco> wow was stuck with a parse error for some time
12:58:39 <erisco> was because I wrote "f a b" for function application
12:58:41 <erisco> damn you haskell!
12:58:42 <lukexi> dennda: re: GHC iOS, I haven't written the instructions down as precisely with the tarball i posted in mind (if that's what you mean) but otherwise they're up to date I think
12:58:42 <kristof> Twey: Negatory.
12:58:55 <erisco> oh sorry thought this was -blah
12:58:57 <jfischof1> preflex seen jmcarthur
12:59:20 <ski> kristof : <http://en.wikipedia.org/wiki/Visual_programming>. LabVIEW is one example
12:59:28 <kristof> Ha, here's a silly question I've had in my head. Is programming in a medium that's limited to two dimensions limit the expressiveness of programming itself?
12:59:28 <Twey> erisco: That's not a parse error
12:59:44 <erisco> Twey, yes I was not talking about Haskell. thought it was #haskell-blah
12:59:54 <Twey> Aha
13:00:39 <ski> some of the languages depicted at <http://strlen.com/language-design-overview> are also fun to ponder
13:01:11 <Twey> kristof: Ultimately program flow is currently two-dimensional, so for now I'm going to say no
13:01:22 <Twey> Concurrent programming might benefit from more dimensions, but you'd need n
13:01:22 <levi> I want to program in an n-dimensional hypercube.
13:02:02 <BMeph_> kristof: Aren't mocros the ultimate expression of "code as text"? ;)
13:02:07 <kristof> Twey: Program flow is one-dimensional.
13:02:10 <BMeph_> Er, *macros
13:02:15 <kristof> BMeph_: No
13:02:22 <ski> kristof : all knots dissolve in dimensions greater than three. this might or might not be relevant
13:02:44 <Twey> kristof: Er, yes, sorry
13:03:04 <Twey> ski: All 3D knots or *all* knots?
13:03:08 <kristof> ski: I was also thinking to myself that you can't project a sphere onto any two-dimensional surface, so I was wondering if that was relevant, too :P
13:03:47 <ski> Twey : all knots (iow injective (continuous) embeddings of the circle into some euclidean space)
13:03:58 <Twey> Huh.
13:04:08 <kristof> ski: Your examples are cool. I like that. But those tools can't, for example, show you all the AND gates in your system that interact with particular components
13:04:18 <jfischof1> why does this fmap id ~⊥ = id ⊥ break fmap id = id?
13:04:34 <ski> Twey : if you're talking about some kind of "knots" built from a surface rather than a "string", then i dunno
13:04:42 <levi> BMeph_: "text" in the sense of macros doesn't have to mean surface syntax, though.
13:04:58 <jfischof1> I'm trying to interpret https://twitter.com/jacobmcarthur/status/428990712219041792
13:05:14 <kristof> ski: The ability to very arbitrarily and promptly reorganize the view of a system, filtering components that aren't necessary and highlighting those that are, is pretty important. Are exception handlers really part of the code, for instance? Type signatures?
13:06:00 <kristof> Type signatures are easier to read in Haskell than in any other language, but consider how much more readable scala would be if you could flip the type annotations on and off.
13:06:04 <ski> BMeph_ : macros are about being able to extend the syntactical forms of the language (in particular, binders, in particular exotic such)
13:06:05 <maurer> Anyone know if it's possible to specify the global-package-db flag in a cabal sandbox?
13:06:06 <levi> jfischof1: The ~ before a pattern makes it irrefutable; it doesn't get evaluated unless you evaluate the binding later.
13:06:08 <Twey> jfischof1: Oh, that was supposed to be ¬ :þ  I interpreted it as lazy pattern-matching
13:06:17 <levi> Oh.
13:06:17 <jfischof1> no I know
13:06:18 <kristof> "I just want to look at logic. Ok, now I want to look at types. I have types off, but what type is this particular thing?"
13:06:21 <maurer> I'm looking to see if I can keep a "pristine" copy of the initial package db from each ghc I install
13:06:23 <ski> BMeph_ : it's one application of staged programming
13:06:32 <maurer> and then when I do sandboxes, reference that instead of my true global db
13:06:35 <Twey> jfischof1: The functor laws say that fmap id f = f, ∀ f
13:06:51 <maurer> so that sandboxes are actually clean-to-the-compiler instead of clean-up-to-global
13:06:56 <Twey> jfischof1: If one f is ⊥ but not the other, you've technically broken the functor laws
13:06:58 <tac> Twey: I have never seen ∀ used in a trailing sense like that before :X
13:07:07 <jfischof1> TWey: which I guess is different than fmap id = id?
13:07:10 <Twey> tac: Conversational mathematical notation :þ
13:07:24 <ski> kristof : it may be that Lamdu is attempting to do some of those things
13:07:29 <kristof> ski: Any decent programming language must be able to, either by extension or natively, support arbitrarily complex metaprogramming. The reality of programming is that every language actually does do compile-time programming already
13:07:32 <jfischof1> Twey: okay I see
13:07:36 <kristof> ski: (I'll look that up in a second)
13:07:43 <kristof> ski: we can continue this on haskell-blah or in here, your choice
13:07:47 <Twey> jfischof1: Right, fmap id = id is the same as fmap id f = id f is the same as fmap id f = f (there's nowhere to introduce a bottom)
13:08:17 <Twey> id f = ⊥ iff f = ⊥
13:08:40 <ski> kristof : i agree about staged programming, and probably also macros, being essential for some kinds of things
13:08:52 <jfischof1> I guess I would put it is the ~ means you are returning something that will evaluate to bottom, but is not bottom
13:08:58 <codygman> Why does the decodeUtf8 function documentation in Data.Text.Encoding say ByteString -> Text while when I look at the type in ghci it says Data.ByteString.Internal.ByteString -> T.Text?
13:09:08 <ski> (kristof : preferably (by-default, at least) hygienic macros ;)
13:09:12 <Twey> jfischof1: Anything that evaluates to bottom is bottom
13:09:17 <Clint> codygman: because you don't have Data.ByteString loaded?
13:09:37 <skypers> hi
13:09:53 <jfischof1> okay well them I confused because won't ~_|_ evaluate to bottom?
13:09:57 <skypers> I have a monad that is built with some monad transformers over IO
13:10:12 <skypers> let’s say MyIO
13:10:13 <Clint> who doesn't
13:10:40 <Qett> can someone show me an example of having an optional argument in optparse-applicative?
13:10:42 <skypers> in a function a -> MyIO, I want to call a function (Ptr a -> IO b) without “breaking” MyIO
13:10:45 <skypers> any idea?
13:10:47 <skypers> is it even possible?
13:10:59 <skypers> I mean I want to be able to run MyIO in such a function
13:11:00 <Twey> jfischof1: Oh, it *was* meant to be lazy pattern-matching
13:11:02 <maxiepoo> skypers, use liftIO
13:11:04 <maxiepoo> oh
13:11:10 <Twey> jfischof1: Sorry, just saw the rest of the conversation
13:11:16 <Twey> @src second
13:11:16 <lambdabot> Source not found. I've seen penguins that can type better than that.
13:11:26 <skypers> I’m not sure whether it’s ok
13:11:32 <skypers> I might also want to modify that function
13:11:49 <skypers> so I can so something like (MonadIO m) -> (Ptr a -> m b)
13:11:50 <Twey> jfischof1: second f ~(x, y) = (x, f y)
13:11:55 <skypers> s/->/=>
13:12:01 <jfischof1> yes I know
13:12:12 <skypers> I think it’s the best solution, right?
13:12:23 <jfischof1> its the functor law comment I don't understand
13:13:03 <supki> Qett: optional (strOption (long "foo"))
13:13:06 <jfischof1> or perhaps there is one interpretation that makes sense to me
13:13:12 <jfischof1> but it might be invalid
13:13:12 <levi> jfischof1: What's the definition of id?
13:13:17 <Twey> jfischof1: So second f ⊥ = (⊥, ⊥) — if the pair itself is bottom, then the *elements* of the returned pair are bottom, but because the pattern-match is lazy, the bottom isn't ‘triggered’ just by evaluating the pair itself — you always have a result of the form (a, b)
13:13:21 <jfischof1> id x = x
13:13:31 <levi> jfischof1: Does x get evaluated?
13:13:38 <Qett> supki: thats an option
13:13:43 <Qett> trying to do an argument
13:14:00 <supki> oh
13:14:26 <jfischof1> Twey, oh
13:14:35 <jfischof1> okay got that makes more sense
13:14:37 <Twey> jfischof1: ~ stops the bottom ‘infecting’ the return value of the function until one of the elements of the match is evaluated
13:14:56 * hackagebot claferIG 0.3.5 - claferIG is an interactive tool that generates instances of Clafer models.  http://hackage.haskell.org/package/claferIG-0.3.5 (mantkiew)
13:14:58 * hackagebot diagrams-cairo 1.0.1.1 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.0.1.1 (BrentYorgey)
13:14:58 <supki> Qett: I think  value  modificator is what you want?
13:15:00 <jfischof1> I get that
13:15:31 <supki> Qett: i.e.  strOption (long "foo" <> value 7)
13:15:56 <jfischof1> I just wasn't thinking about how foo ~(x, y) = (x, y) with foo undefined is (undefined, undefined)
13:16:07 <jfischof1> it makes perfect sense now
13:16:30 <Qett> supki: im trying to have just an argument (passed in without any dashes)
13:17:41 <levi> Twey: _|_ also inhabits the pair type, not just (_|_, _|_)
13:17:50 <Twey> levi: Yes
13:17:56 <supki> Qett: oh, okay then, there is an  argument  parser
13:18:06 <supki> Qett: which you can use with  optional
13:18:07 <Twey> levi: But it doesn't inhabit the return value of second
13:18:16 <Twey> :þ
13:18:53 <Qett> supki: yeah thats what im trying to do
13:18:54 <levi> Twey: I don't see why that is.
13:19:06 <Twey> levi: Because second f ~(x, y) = (x, f y)
13:19:18 <levi> The irrefutable binding just fails later, rendering _|_ due to a pattern match failure.
13:19:20 <jfischof1> levi: you are always constructing an new tuple
13:19:23 <Twey> levi: second always returns a pair without doing any matching
13:19:38 <levi> It returns a pair, and the pair type includes _|_ as a member.
13:19:49 <Twey> levi: Absolutely, but ‘later’ is the value *inside* the tuple, not the tuple itself — the return value can be (⊥, ⊥) but never ⊥
13:19:56 * hackagebot diagrams-svg 1.0.1.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.0.1.1 (BrentYorgey)
13:20:05 <Qett> supki: not sure how to probably do it though, should the type be a Maybe?
13:20:24 <Twey> levi: (we are of course discussing second as implemented, not second as typed)
13:20:28 <jfischof1> levi: the type (a, b) has _|_ as inhabitant, sure, but through inspection you can see the function does not
13:21:28 <levi> OK, I'm apparently missing the method of inspection that can show that.
13:21:43 <Twey> levi: f ∷ Int → Int; f _ = 3; -- 17 is an inhabitant of Int, but that doesn't mean f will ever return it
13:22:20 <levi> f also completely ignores its argument.
13:22:27 <supki> Qett: http://lpaste.net/2818011773293035520
13:22:39 <supki> Qett: yes, if something is optional, it's a good idea to use Maybe
13:22:44 <Twey> levi: As does second — in deciding whether or not it will produce a pair
13:22:58 <Twey> levi: The argument is only inspected when you ask for the *elements* of the pair
13:23:09 <Twey> That's what lazy pattern-matching gives you
13:23:14 <levi> Twey: But _|_ *is* a pair!
13:23:17 <Qett> thanks supki
13:23:35 <Twey> levi: But it's not the one that second returns
13:23:48 <Twey> levi: second f ~(x, y) = (x, f y)
13:23:50 <skypers> hm
13:24:04 <Twey> levi: It *always* produces something of the form (a, b), without inspecting any of its arguments
13:24:22 <levi> OK, it's starting to sink in.
13:24:26 <Twey> Only on evaluating the a or the b is the pair passed in inspected
13:24:39 <skypers> in (MonadM m) => m, is it possible to that: liftIO ioFunction ( liftIO monadIOFunction )?
13:24:40 <Twey> Which means that's the first time you can get a bottom out of it
13:24:48 <skypers> (MonadIO m)*
13:24:57 * hackagebot diagrams-postscript 1.0.1.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.1.1 (BrentYorgey)
13:25:00 <Twey> > let (a, b) = second undefined undefined in 3
13:25:01 <lambdabot>  3
13:25:02 <skypers> I guess the monad will be broken
13:25:10 <skypers> it’s quite annoying
13:25:18 <Twey> > let (0, b) = second undefined undefined in 3
13:25:19 <lambdabot>  3
13:25:31 <Twey> Dammit, I would like a stricter let for examples like these :þ
13:26:00 <skypers> why Twey?
13:26:01 <Twey> > case second undefined undefined of (a, b) → True
13:26:02 <lambdabot>  True
13:26:05 <triliyn> > let !(0,b) = second undefined undefined in 3
13:26:06 <Twey> > case second undefined undefined of (0, b) → True
13:26:06 <lambdabot>  *Exception: Prelude.undefined
13:26:07 <lambdabot>  *Exception: Prelude.undefined
13:26:21 <Twey> triliyn: Oh, yeah, that would do it — forgot about good old !
13:26:37 <skypers> > let (0,!b) = second undefined id in 4
13:26:38 <lambdabot>  Couldn't match type `(d0, b0)' with `a0 -> a0'
13:26:38 <lambdabot>  Expected type: (a0 -> a0) -> (d0, c0)
13:26:38 <lambdabot>    Actual type: (d0, b0) -> (d0, c0)
13:27:35 <Twey> skypers: second id undefined, I think you mean?
13:27:41 <triliyn> Twey: why is second defined this way? It seems kind of... not particularly bad, but surprising at least
13:27:59 <Twey> triliyn: *shrug* Mo' laziness, mo' better?
13:28:11 <skypers> Twey: I don’t even know :D
13:28:13 <triliyn> Yeah, I guess that's what it sounds like
13:28:13 <Twey> triliyn: It admits more programs that don't have to fail
13:33:26 <skypers> why isn’t there an unregister option bound to ghc-pkg unregister in cabal again?
13:33:52 <greg`> ive been trying to post something through hpaste.org into this channel, its not getting through
13:34:28 <dcoutts> skypers: because people actually want proper uninstall, and nobody had implemented that yet (though we did make some progress at a hackathon last year)
13:34:31 <merijn> greg`: Yeah, the anouncement is broken atm
13:34:37 <merijn> greg`: I would just copy the URL :)
13:34:48 <merijn> (and paste it, obviously ;)
13:35:19 <greg`> http://lpaste.net/99268
13:35:32 <greg`> its to do with control.concurrent.async
13:35:57 <merijn> greg`: Because "wait a1" doesn't return until a1 finishes
13:36:17 <merijn> greg`: So the "wait a2" won't start until a1 finishes and you only notice a2 failed when "wait a2" starts
13:36:57 <skypers> ok I see dcoutts
13:37:56 <merijn> greg`: Make sense?
13:38:19 <greg`> merijn: still thinking it over
13:39:23 <skypers> :t Ptr
13:39:24 <lambdabot>     Not in scope: data constructor `Ptr'
13:39:24 <lambdabot>     Perhaps you meant one of these:
13:39:24 <lambdabot>       `Str' (imported from Text.PrettyPrint.HughesPJ),
13:39:35 <greg`> merijn: Yes! i see thank you
13:39:50 <greg`> its a bit lame that you cant wait for them concurrently
13:40:02 <merijn> greg`: You can, just not *that* way :)
13:40:29 <merijn> greg`: I'm assuming you're reading Simon's book? He covers that later
13:40:38 <greg`> yes im working through it
13:41:03 <merijn> greg`: Basically, this example is to explain why you need to do it the other way to get the right behaviour
13:42:07 <skypers> how would you call a (MonadIO m) => m action from IO?
13:42:34 <Axman6> skypers: using whatever function the m monad provides to run itself
13:42:55 <skypers> if I don’t have m?
13:42:58 <skypers> juste (MonadIO m) => m
13:42:58 <Axman6> there'll usually be something like runStateT :: (StateT s m a) -> m (s,a)
13:43:03 <supki> skypers: you can't without a  m a -> IO a
13:43:05 <skypers> runIO ?
13:43:06 <zebr> hi all. is there an accessible introduction to lenses and prisms (especially the latter), perhaps in the context of imperative & exception handling? i saw that roconnor may have done a talk about it?
13:43:08 <geekosaur> skypers: IO has a liftIO (which is id)
13:43:12 <skypers> geekosaur:
13:43:13 <skypers> no
13:43:19 <Axman6> @hoogle runIO
13:43:19 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
13:43:19 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
13:43:19 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
13:43:21 <skypers> liftIO :: IO a -> m a
13:43:28 <skypers> I want the opposite
13:43:34 <skypers> m a -> IO a
13:43:35 <geekosaur> yes, the trick is that m here *is* IO
13:43:41 <Axman6> skypers: there's no general MonadIO m => m a -> IO a
13:43:47 <Axman6> ah
13:43:57 <greg`> thanks merijn im going to finish the talk, and work through to STM concurrency in async
13:44:05 <skypers> wuh, what? :D
13:44:05 <edwardk> zebr: a prism is just a smart pattern. it works like a constructor. _Left # 4     = Left 4  , but you can use it like a traversal to match Left 4 ^?_Left  asks if someting is Left
13:44:12 <edwardk> > Left 4 ^? _Left
13:44:14 <lambdabot>  Just 4
13:44:31 <geekosaur> skypers, I am having trouble understanding what an opposite would be
13:44:44 <edwardk> zebr: now with that in mind, Control.Exception.Lens provides prisms that let you pattern match on the possible members of SomeException
13:44:44 <skypers> liftIO lets you call IO from (MonadIO m) => m
13:44:54 <skypers> I want to run (MonadIO m) => m from IO
13:45:00 <edwardk> :t Control.Exception.Lens.catching Control.Exception.Lens._NonTermination
13:45:01 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => m r -> (() -> m r) -> m r
13:45:05 <greg`> how can i consisely express \b -> wait b >>= putStrLn
13:45:08 <geekosaur> right, the answer is your m is IO
13:45:09 <skypers> it might be impossible
13:45:09 <edwardk> :t catching _NonTermination
13:45:10 <lambdabot>     Ambiguous occurrence `catching'
13:45:10 <lambdabot>     It could refer to either `Control.Exception.Lens.catching',
13:45:10 <lambdabot>                              imported from `Control.Exception.Lens' at /home/lambda/.lambdabot/State/L.hs:39:1-29
13:45:22 <skypers> geekosaur: what if it isn,t?
13:45:23 <edwardk> :t Control.Exception.Lens.catching _NonTermination
13:45:24 <lambdabot> MonadCatchIO-transformers-0.3.0.0:Control.Monad.CatchIO.MonadCatchIO m => m r -> (() -> m r) -> m r
13:45:24 <skypers> isn’t*
13:45:30 <Clint> then your question wouldn't make sense
13:45:36 <geekosaur> if you are asking how to run some specified m that is *not* IO, then you need to find out how that m works
13:45:41 <zebr> edwardk: ahhh, that makes sense. could they be said to be first class patterns, then? also, why 'prism'?
13:45:47 <geekosaur> there is no generic mechanism, MonadIO *only* provides liftIO
13:45:48 <skypers> ok, reformulating it
13:45:52 <geekosaur> there CANNOT be a generic mechanism
13:46:00 <edwardk> this lets you avoid the tricky type annotations needed to work with catch, etc.
13:46:08 <greg`> i kinda want (wait) composed with putStrLn
13:46:09 <skypers> I have a function like that : foo :: (MonadIO m) => m b -> mb
13:46:13 <supki> greg`: wait >=> putStrLn
13:46:21 <greg`> oooh
13:46:27 <skypers> foo takes a MonadIO action then
13:46:38 <skypers> foo runs a Foreign function (IO), so I can liftIO it
13:46:39 <skypers> BUT
13:46:45 <greg`> thanks supki
13:46:54 <edwardk> we went around looking for names for a while before setting on prisms. if you look at a lens it views part of a product Lens' s a is saying that s is isomorphic to some product (c, a) where there exists a type 'c' for the rest of the stuff, and the a you are looking for
13:46:56 <skypers> this function is something like withArray
13:47:09 <skypers> I want to pass my MonadIO action to withArray
13:47:14 <skypers> I just can’t?
13:47:24 <skypers> the single way I found
13:47:27 <geekosaur> you just can't
13:47:30 <skypers> is to do something like:
13:47:36 <skypers> liftIO . newArray $ …
13:47:38 <skypers> g
13:47:38 <edwardk> if you look at a Prism' s a it is saying s is isomorphic to some _sum_ (Either c a) where there exists a type c covering only the other cases
13:47:43 <skypers> liftIO . free $ a
13:47:46 <geekosaur> unless your SPECIFIC m provides a way to do so
13:47:53 <geekosaur> there is no GENERIC mechanism
13:48:01 <skypers> I see
13:48:11 <skypers> my function is something like EitherT over StateT over IO
13:48:17 <geekosaur> (also note that runIO is a Template Haskell escape and not very useful here)
13:48:31 <skypers> (I don’t even know runIO ;))
13:48:47 <skypers> I think I’ll just stick to losing the withArray and use newArray/free
13:48:55 <edwardk> So, since lens was taken for the product notion for zooming in on part of a whole, we needed something that characterized that splitting behavior, and a (common) prism splits apart light, so we went with that, as it provided _some_ intuition
13:49:00 <edwardk> a Prism is a Co-Lens.
13:49:22 <skypers> edwardk: the more I study Control.Lens, the more I think this library is terribly wrong :D
13:49:28 <edwardk> but had we called it Colens, nobody but me, and maybe rwbarton would have ever used it
13:49:32 <skypers> (with all my respect though)
13:49:55 <geekosaur> so, depending on what you are doing, you may be able to capture your current state and inject it as a runStateT with an appropriate EitherT wrapper; see for example how one wraps gtk2hs callbacks in a custom monad
13:49:56 <ski> edwardk : hm, i suppose it reminds of display logic
13:50:03 <skypers> wrong in the way it’s too overhelming to be
13:50:04 <edwardk> skypers: i'm continually amused by the strength of opinions it drives people towards
13:50:15 <skypers> edwardk: ah? tell me more then :)
13:50:21 <zebr> edwardk: that kind of makes sense. thanks :)
13:50:38 <skypers> geekosaur: that’s why I thought at first
13:50:39 <edwardk> skypers: i get a lot of folks who love it or hate it or both, but very little indifference ;)
13:50:39 <zebr> edwardk: as a bit of an aside, do you think there would be a benefit in having an imperative language with its whole design based around lenses/prisms? or do you think lenses in haskell are as ingrained into the language as they'd need to be?
13:50:45 <skypers> and I actually have that in my FRP lib
13:50:50 <skypers> (a reintrant function)
13:50:55 <geekosaur> you didn't provide enough information
13:51:01 <skypers> edwardk: :)
13:51:14 <geekosaur> StateT is easdy enough to do, but if your MonadIO is a ResourceT then you have problems :)
13:51:14 <skypers> I think it’d be perfect with just basic operators and combinators
13:51:18 <edwardk> zebr: well, if you s/imperative // out of your question, it could be quite powerful and i could perhaps get behind it
13:51:37 <skypers> ^., .~, %~, <>~ and a few more among &
13:51:49 <edwardk> zebr: the idea of defining a new language with that label in this day and age, knowing what we know now doesn't sound like a terribly good idea.
13:51:58 <skypers> the issue with all the rest is that you inject too much expressivity in there to me
13:52:05 <skypers> here’s what I think:
13:52:19 <edwardk> It is like saying, "do you think a new dialect of APL that used the visitor pattern could be popular?" =)
13:52:31 <skypers> in C for instance, you have a few tools, very poor abstractions that don’t express that much information
13:52:32 <zebr> edwardk: well, i suppose when i say 'imperative' i just mean more focus on 'setting values', as it were. not in the sense of true mutability, necessarily, but it seems that what lenses are good at is 'mutating' data structures in a pure way
13:52:49 <skypers> in assembly you have ridiculus tools and barely no expressivity
13:53:08 <skypers> in “regular haskell”, you have a very limited set of tools as well, but a very large expressivity
13:53:14 <edwardk> so that said, there is some room for a type system that actualy let you compose lenses and retained the polymorphic type of the composition.
13:53:23 <skypers> in “haskell+lens”, you have A LOT of tools with A LOT of expressivity
13:53:25 <skypers> BUT
13:53:28 <edwardk> basically a very limited form of rank-n.
13:53:59 <skypers> a lot of expressivity can easily be achieved with some reusable functions
13:54:03 <ski> skypers : C is sorely missing universals and existentials
13:54:12 <Fuuzetsu> skypers: I hope you're aware you inserted NO-BREAK SPACEs there
13:54:20 <skypers> (using basic tools)
13:54:26 <Fuuzetsu> (otherwise you might have been putting those into your code all your life!)
13:54:45 <edwardk> skypers: i think that is a bit of a false analogy in the sense that comparing lens to assembly ignores the fact that lens gives you laws to reasn about moving code around. moving assembly instructions is ... pain.
13:54:48 <skypers> the issue with lens to me is that there’re so many tools you’re lost in there and don’t really can’t build solid new concepts
13:55:02 <skypers> I know
13:55:11 <skypers> but I’m only comparing tools
13:55:13 <skypers> as… tools.
13:55:19 <zebr> edwardk: in what way does lens composition lose the polymorphic type of the composition?
13:55:20 <skypers> (.) is a nice tool
13:55:29 <skypers> Functor is a magical tool
13:55:31 * ski . o O ( YOU NO BREAK SPACE ! )
13:55:39 <skypers> Applicative is lovely
13:55:43 <Fuuzetsu> I will end you, ski
13:55:55 <Fuuzetsu> are you really happy with those being your last NO-BREAK SPACEs?
13:55:58 <edwardk> as for the problem with there being too much stuff you can use, i'll take that complaint as a compliment. i don't want my tools to stop working when the problem gets hard.
13:56:11 <jle`> what's the IFDEF for if you are in windows?
13:56:15 <skypers> (^@..) is really powerful but you might use it something like once, or twice
13:56:22 <skypers> it’s the same thing for a lot of your tools
13:56:28 <skypers> (sorry about the newlines)
13:56:32 <Rembane> Snail with a cap?
13:56:49 <edwardk> lens-family exists, its quaint, unassuming and juuust useful enough to get people going, but tops out
13:57:31 <zebr> i spose with any set of tools it's important to know which are the bread and which are the butter
13:57:35 <skypers> edwardk: I’m just saying, who’ve already talked about that, you said “people would be happy about to tools to be there”
13:57:37 <zebr> otherwise you might just get lost.
13:57:37 <Fuuzetsu> jle`: perhaps #ifdef mingw32_HOST_OS
13:57:45 <Fuuzetsu> at least http://hackage.haskell.org/package/base-4.4.1.0/docs/src/System-Environment.html seems to be doing that
13:58:03 <ReinH> jle`: in other news I'm so sorry
13:58:09 <skypers> the thing is: when you can use a tool you know and use everywhere, like Data.Foldable.mapM_ with Bifunctor, you, you expose an operator just for that
13:58:13 <edwardk> skypers: i write tools for me, and try to make them as flexible as possible so i can use them later and get eyeballs to fix them and use them in other contexts. i choose to work at a fairly painful level of abstraction because it is at that level i can write code and solve a problem once and forall and use it for years to come. I could go bang on a web server for a year, but 10 years down the line i'd get nothing from it
13:58:15 <skypers> this is too specific to me
13:58:28 <jle`> Fuuzetsu: thanks, i'll try it :)
13:58:31 <jle`> ReinH: thank you :P
13:58:36 <jle`> on my linux server
13:58:40 <jle`> i can use SDL
13:58:47 <jle`> and then use Xvfb and x11vnc
13:58:53 <jle`> and view it on my windows box
13:59:05 <jle`> on windows, i can't install SDL-gfx properly so that the hackage package will build
13:59:08 <skypers> edwardk: I understand
13:59:13 <jle`> BUT i can use OpenGL and GLUT
13:59:15 <skypers> I’m just saying it’s too much
13:59:20 <skypers> I respect all you do
13:59:22 <skypers> it’s very impressive
13:59:25 <edwardk> skypers: if mapM_ fits your problem, by all means use it! congratulations. with that you just learned how to use mapMOf_ if you ever need to work in a situation where it _doesn't_ work.
13:59:26 <skypers> but too much
13:59:33 <jle`> however, on my linux server, I can't route OpenGL/GLUT through Xvfb
13:59:36 <jle`> and x11
13:59:40 <skypers> edwardk: well
13:59:45 <skypers> if it doesn’t work
13:59:50 <skypers> I might write one line
13:59:52 <skypers> or two
13:59:59 <jle`> so i wrote my program with two separate but parallel backends, one in openGL and one in GLUT...and i'm going to compile with one or the other depending on what OS i'm on.
13:59:59 <zebr> skypers: it does strike me that that is a little similar to the complaint in Amadeus that Mozart's compositions "just have .. too many notes." :p
14:00:01 <edwardk> skypers: i've written probably 2 dozen mapM_-like functions specific to different containers before that weren't quite Foldable.
14:00:02 <skypers> whereas you’d write mapMOf_
14:00:11 <edwardk> mapMOf_ lets me say hey just give me a Fold and I'll do it
14:00:48 <edwardk> and now i'm done thinking about the task
14:01:06 <skypers> edwardk: ok ok, just, sometimes, when I read this kind of library (very abstract and very cryptic), I just think you guys just race for the “shorter code” as possible
14:01:12 <skypers> and not “the more expressive”
14:01:29 <edwardk> and i'm not worried about whether or not tibbe remembered to export a foldMapWithKey from Data.Map, etc.
14:01:48 <johannesbodannes> Is there any particular reason why immutable datastructures like functional-style binary trees don't ever seem to feature in imperative languages like C?
14:02:01 <johannesbodannes> or maybe C++, let's say
14:02:05 <edwardk> skypers: short is nice, but it is on metric among many to judge code by
14:02:10 <jle`> johannesbodannes: well they do pop up in concurrency contexts
14:02:11 <johannesbodannes> since they have smart pointers
14:02:15 <johannesbodannes> oh?
14:02:20 <skypers> edwardk: I don’t think so
14:02:21 <simpson> johannesbodannes: Because the mutable versions are usually less expensive.
14:02:25 <edwardk> johannesbodannes: because cleaning up after them is hard in c
14:02:36 <Aetherspawn> sometimes I get said because there aren't all the combinations of Fold/Map in certain data structures
14:02:40 <edwardk> johannesbodannes: when do you throw them away? in java, haskell, etc. you can gc them
14:02:40 <merijn> johannesbodannes: Well, mostly because without ADTs and pattern matching the become more annoying to express
14:02:41 <Aetherspawn> /s/said/sad/
14:02:48 <Aetherspawn> *cough* IntMap/IntSet
14:02:49 <zebr> edwardk: i do think there would be a lot gained from some more introductory material on lenses and the sort. not that that's your job, of course. but i would like to see it. :p
14:02:58 <skypers> writing short code is ok if the code is expressive, otherwise, it’s far away better to write two more lines to make it clear IMHO
14:03:11 <dart> hi
14:03:12 <johannesbodannes> My thoughts about an implementation in C++ is that the data could be freed by smart pointers
14:03:14 <dcoutts> johannesbodannes: and because C++ has more expensive memory allocation (due to lack of GC that can relocate objects)
14:03:19 <ski> lo dart
14:03:23 <jle`> hi dart
14:03:26 <skypers> and I think my “limit” is functions like liftA2
14:03:35 <skypers> those functions can be a pain to read sometimes
14:03:44 <dart> if i want to create configuration file for my application like xmonad, how do i start ?
14:03:48 <skypers> when you’re used to them, it’s quite ok
14:03:53 <johannesbodannes> oh i see. why would heap memory allocation in C++ be more expensive than garbage collection?
14:03:54 <edwardk> zebr: I took 2 months off writing documentation for it. gave talks and workshops across the country. i'm happy to take patches, and may do another workshop this summer, but I've written up what I can personally in the short term ;)
14:04:04 <skypers> liftM2 (,) is just a function that extracts two monads actions and glue them in a pair
14:04:18 <dcoutts> johannesbodannes: memory allocation in ghc is literally incrementing a pointer and writing, it's so cheap
14:04:23 <skypers> but sometimes
14:04:30 <zebr> edwardk: it could also well be that i'm not looking in the right places. :)
14:04:37 <johannesbodannes> oh, so the memory is already allocated!
14:04:40 <skypers> I just think “hey, it would be quite clearer writing a <- io0; b <- io1; return (a,b)
14:04:43 <skypers> ”
14:04:45 <skypers> do you get my point?
14:04:45 <edwardk> skypers: then put lens back on a shelf and go beat on problems for a couple of years, it'll still be there when you have more familiarity with the legos its made of
14:05:00 <dcoutts> johannesbodannes: in fact it's usually less than the cost of incrementing a pointer, because all the allocations in the same block can be covered by a single increment of the heap pointer
14:05:17 <skypers> edwardk: yes, that brings me to the second point: teamwork
14:05:19 <edwardk> skypers: well, i tend not to use liftAn and just use the applicative combinators
14:05:24 <skypers> lens makes teamwork quite hard
14:05:36 <skypers> you mean <*> ?
14:05:38 <edwardk> skypers: my personal experience is quite the opposite
14:05:40 <dcoutts> johannesbodannes: no, it's not pre-allocated. The allocation is organised so that you have a fully free block of memory and you allocate heap objects into it sequentially.
14:05:42 <thoughtpolice> liftA2 isn't even a good example IMO, because the applicative combinators are shorter and once you read them, easier and clearer to understand
14:05:44 <edwardk> skypers: but YMMV
14:05:55 <skypers> thoughtpolice: I agree
14:06:02 <skypers> the example was not that good indeed
14:06:07 <edwardk> every project i've worked on with folks who know lens has gone amazingly well
14:06:18 <skypers> “folks who know lens”
14:06:24 <dcoutts> johannesbodannes: you can only keep getting free blocks of memory if you can deal with fragmentation, and that relies on the GC being able to move objects about
14:06:26 <skypers> this is not a lot of folks I guess
14:06:31 <edwardk> skypers: fortunately that is basically my social circle.
14:06:32 <jle`> well
14:06:36 <jle`> same for folks who know haskell
14:06:39 <jle`> but we write haskell?
14:06:41 <zebr> edwardk: i just found the lenses wiki. consider the documentation criticism withdrawn. :p
14:06:41 <triliyn> thoughtpolice: there are a couple in here who see the liftA2 and friends as more fundamental
14:06:46 <edwardk> there are 100+ of them sitting in the #haskell-lens channel ;)
14:06:54 <skypers> edwardk: how would you do with other circles?
14:06:56 <dcoutts> johannesbodannes: malloc/free inherently require that the location of the heap object stays fixed
14:07:01 <jle`> expressiveness/understanding is kind of in the eye of the beholder though.
14:07:05 <ski> dart : perhaps try #xmonad ?
14:07:28 <jle`> to someone first starting out to haskell, things that you find 'normal' now might be completely foreign and unexpressive to them
14:07:35 <johannesbodannes> I didn't know about all of this... that's pretty interesting.
14:07:39 <skypers> for a few weeks, I’m having great fun with parsec and applicative *>, <* and so on
14:07:48 <edwardk> skypers: i have had very good success with getting good haskell programmers to write code usng the core lens abstractions that can be consumed and edited by people with much more introductory backgrounds.
14:08:01 <edwardk> foo += 12    is pretty understandable to someone outside the lenserati
14:08:06 <skypers> I think this is a good abstraction because Applicative is a true and quite well spread abstraction
14:08:11 <johannesbodannes> I always believed that every language pretty much manipulated the heap in identical terms
14:08:14 <skypers> you might need it for a lot of stuff
14:08:24 <johannesbodannes> but with different levels of abstraction
14:08:31 <dart> ski: i think i didn't explain myself well, i've just found the dyre package that is exacltyy what i was looking for
14:08:34 <skypers> (^@..@ or <==// I don’t know why, I don’t think so
14:08:54 <jle`> skypers: maybe just for you?  your idea of what is true and well spread/comfortable might not be the same for everyone else
14:08:55 <skypers> edwardk: ok for +=
14:08:57 <skypers> lawyered
14:09:07 <skypers> what about more cryptic operators
14:09:08 <skypers> like…
14:09:09 <triliyn> skypers: over/(%~) are pretty general though
14:09:21 <skypers> yes
14:09:22 <triliyn> Which seem to be the main point of lens
14:09:24 <edwardk> ^. lets you start using a lens or getter chain.   ^.. lets you get multiple answers. read .. as a list .. its a cute pun.
14:09:27 <skypers> I think lens should be just that, triliyn
14:09:28 <jle`> every new abstraction you find will be unreadable at first
14:09:33 <skypers> .~, <>~ and so on
14:09:33 <triliyn> Most of the cryptic operators are just shortcuts, aren't they?
14:09:34 <skypers> but hm
14:09:34 <jle`> and then after a little bit
14:09:37 <jle`> it becomes obvious
14:09:40 <jle`> and makes it even more readable
14:09:42 <dcoutts> johannesbodannes: in GC speak, they talk about pinned and unpinned allocations. Pinned ones are those where their address has to remain fixed (e.g. because you gave the address to some C code, or moving is just too expensive).
14:10:02 * hackagebot http-conduit-downloader 1.0.13 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.13 (VladimirShabanov)
14:10:03 <edwardk> the use of @ arises when you want to use indices. 90% of the users of lens never care that that exists. ^@.. is give me a list of answers along with their indices
14:10:14 <skypers> (%@~)
14:10:15 <edwardk> indices are so lens can subsume various traverseWithKey scenarios
14:10:15 <dcoutts> johannesbodannes: most GC systems (proper ones, as opposed to conservative ones) use primarily unpinned allocations, and then they can do cheap allocation.
14:10:16 <skypers> what is that?
14:10:20 <skypers> without consulting your doc
14:10:29 <edwardk> %~ is modify with a function.
14:10:40 <edwardk> @ makes it also give you the index.
14:10:41 <thoughtpolice> %~ = modify, @ = indexed.
14:10:59 <edwardk> % is used for modify because % is 'mod' in C ;)
14:11:27 <skypers> so %@~ modifies, indexes and set?
14:11:42 <edwardk> there are about 90+ operators in there that fit that boilerplate op=   or op~ pattern    w/ op@~     op@=  being the indexed forms
14:11:50 <edwardk> no, modifies with access to the index.
14:12:04 <edwardk> > ("hello",2) & _1 %~ length
14:12:05 <lambdabot>  (5,2)
14:12:16 <edwardk> > ("hello",2) & _1 %@~ \a b -> (a, b)
14:12:18 <lambdabot>  ((0,"hello"),2)
14:12:28 <skypers> my god…
14:12:30 <edwardk> > "hello" & traversed %@~ \a b -> (a, b)
14:12:31 <skypers> :D
14:12:31 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
14:12:42 <jle`> when you use %~, the function you pass in can only see the value
14:12:48 <quicksilver> in what sense is the index of hello '0' in the first example?
14:12:48 <edwardk> "hello"^..traversed
14:12:48 <simpson> TIL.
14:12:49 <edwardk> > "hello"^..traversed
14:12:50 <jle`> using %@~, it gets botht eh value and the index
14:12:50 <skypers> I know jle`
14:12:51 <lambdabot>  "hello"
14:12:55 <edwardk> gives you the answer
14:12:55 <skypers> I use %~ and <>~ a lot
14:12:57 <quicksilver> how do you generalise index to nested structures?
14:12:58 <edwardk> > "hello"^@..traversed
14:12:59 <lambdabot>  [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
14:13:12 <skypers> :t (^..)
14:13:13 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
14:13:15 <guesting> This leads to a stack size overflow for large matrices, why? http://pastebin.com/dwNqxqSz
14:13:26 <edwardk> :t (^@..)
14:13:27 <lambdabot> s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
14:13:33 <skypers> also
14:13:35 <skypers> types are just
14:13:37 <skypers> you know
14:13:37 <jle`> guesting: without looking...unevaluated thunks
14:13:39 <guesting> The function uses a sparse matrix library and takes only the rows in the list
14:13:43 * skypers faints
14:13:47 <guesting> jle`: Meaning?
14:13:56 <jle`> after looking
14:14:05 <jle`> i am not sure, i haven't used that lib :)
14:14:15 <jle`> meaning that you are building up a list of evaluations
14:14:19 <jle`> lazily
14:14:25 <edwardk> skypers: i wrote lens because i needed it. other people liked it. it isn't going to disappear, it may fall out of fashion, but it currently eliminates a metric boatload of boilerplate from my codebases and a lot of other people's
14:14:29 <jle`> a list of future evaluations
14:14:46 <guesting> jle`: All I am doing is "looping" through a list of indices and adding those indices of a matrix to another matrix--ie getting the rows I want from a matrix.
14:14:53 <skypers> edwardk: I don’t know how you deal with it
14:14:54 <edwardk> when something better comes along people will switch or lens will morph to become that better thing
14:15:02 * hackagebot hlint 1.8.56 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.56 (NeilMitchell)
14:15:03 <skypers> boilerplate is not that bad you know ;)
14:15:06 <jle`> like (((1+1)+1)+1)...
14:15:09 <ReinH> guesting: you probably want that to be strict in `newMat'
14:15:12 <edwardk> skypers: that is where we fundamentally disagree
14:15:27 <skypers> clearly :)
14:15:28 <edwardk> i have a _VERY_ high budget for abstraction if it avoids boilerplate and repetition
14:15:30 <guesting> ReinH: Is there a way to rewrite it so I don't need to add strictness?
14:15:38 <ReinH> guesting: otherwise you'll be building a chain of unevaluated (S.<|)
14:15:44 <jle`> well you're going to need strictness no matter what
14:15:49 <jle`> hm
14:15:50 <thoughtpolice> honestly i'm not sure if the lens types bother me much... i mostly go by the laws, and I almost always start by writing my types first anyway - so the lens types immediately specialize to them for my use case, resolving a lot of the polymorphism. the bonus is if i change stuff, they're still polymorphic and very generic, so they're easy to coax into agreement.
14:15:51 <edwardk> i'll pretty much do anything to avoid writing the same kind of code in 10 years using the same kinds of tools.
14:15:52 <skypers> edwardk: then you’d be for the template mixin keyword in D whereas I don’t
14:15:55 <jle`> strictness in some form
14:16:02 <jle`> because if you're adding up, say, a million numbers
14:16:08 <guesting> ReinH: I feel like I always need strictness in every function I write :(
14:16:14 <jle`> you don't really want to build up a thunk of a million additions
14:16:27 <jle`> are you saying you want non-explicit strictness?
14:16:43 <edwardk> skypers: i wrote years and years of template metaprograms in c++ trying to get even a tenth of the code reuse i get out of haskell.
14:16:44 <jle`> strictness makes sense in a lot of cases.
14:16:48 <ReinH> well, if there is a way to get the compiler to reuse the pattern matching stack you could avoid stack overflow
14:17:00 <ReinH> but probably the best solution is just adding strictness
14:17:02 <bitemyapp> edwardk: you and bartosz both eh?
14:17:07 * ski idly wonders how high values of `n' for `n'th-order programming is typically used with lenses
14:17:10 <skypers> edwardk: C++ is not a really good candidate for abstraction :D
14:17:20 <edwardk> i like code that composes well and just works for deep law abiding reasons rather than adhoc nonsense.
14:17:20 <bitemyapp> skypers: it's better than C.
14:17:23 <guesting> Can I just tell the compiler to be strict so I don't need to rewrite a bunch of things?
14:17:25 <bitemyapp> skypers: void* sucks ass.
14:17:28 <skypers> :D
14:17:30 <skypers> classy
14:17:34 <bitemyapp> sorry, it does.
14:17:35 <jle`> guesting: ah, you want non-explicit strictness
14:17:42 <bitemyapp> I'm tired of people spreading this meme that C is somehow superior.
14:17:44 <jle`> you want strictness, but you don't want to manually write it in
14:17:51 <jle`> ?
14:17:51 <skypers> edwardk: so do I
14:17:54 <bitemyapp> C is fine but it's complicated and doesn't extend any better than C++.
14:18:05 <guesting> jle`: yeah, like is there a switch in ghc --strict or something like that?
14:18:08 <bitemyapp> would linear-typing help with strictness analysis?
14:18:10 <ReinH> the compiler might be able to optimize the stack if this were guarded recursion
14:18:12 <skypers> but I don’t want my code to be polluted by a lot of operators sometimes used only onced
14:18:15 <ReinH> but I would just add a bang pattern
14:18:34 <jle`> operators?
14:18:35 <guesting> ReinH: So it will work if I just use guards instead of patterns?
14:18:35 <edwardk> and i'm willing to put in a lot of legwork figuring out those laws and trying out different APIs, but 'i don't like X because it is uncomfortable or hard or different' doesn't hold a lot of water with me. i'm willing to completely reinvent myself in a new framework if its better than the one I have.
14:18:40 <ReinH> guesting: no
14:18:45 <bitemyapp> guesting: how do you do conditionals with universal strictness?
14:18:55 <triliyn> bitemyapp: doesn't C++ still have void? (Not that I'm disagreeing with you; I prefer c++ over C but I am confused by what you said)
14:19:01 <guesting> bitemyapp: No idea
14:19:04 <skypers> I’m not saying that edwardk
14:19:09 <skypers> if I did
14:19:13 <skypers> I wouldn’t be ther ;)
14:19:15 <triliyn> void*, I mean
14:19:15 <skypers> there
14:19:24 <ReinH> guesting: I'm talking about, e.g., http://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
14:19:33 <edwardk> now, there are things i can change. i can make better documentation, we can organize things better, i'm happy to make improvements, even big breaking one if they lead to a better thing
14:19:33 <bitemyapp> triliyn: I mean in terms of what tools are available to you for abstracting things.
14:19:40 <skypers> every new abstractions always make you feel stupid and rookie
14:19:54 <skypers> and I actually understand lens’ operators
14:20:03 * hackagebot haxr 3000.10.2 - XML-RPC client and server library.  http://hackage.haskell.org/package/haxr-3000.10.2 (BrentYorgey)
14:20:08 <bitemyapp> triliyn: C++ will generally catch more type errors (I realize this is nothing like what you get in OCaml and Haskell, but bear with me) and you have more relatively "safe" abstractions you can use assuming you 1. Know what you're doing 2. Use the right subset.
14:20:15 <skypers> I just don’t like imposing such a complexe dependency for “too much”
14:20:26 <triliyn> bitemyapp: hmm, okay
14:20:33 <edwardk> with each project i have very different settings w.r.t. how high my complexity budget is, and what features i'm willing to accept. with lens we rolled very high on the type system features, explicitly because there were a dozen boring interchangeable minimalist lens lbraries before, so i didn't have to comply with that model
14:20:38 <ReinH> Conor McBride has a newish paper about it that's interesting if you're really interested http://bentnib.org/productive.pdf
14:20:51 <bitemyapp> triliyn: I know C++ is messy, but if you have good internal standards and guidelines you can do a much better job than C.
14:21:00 <bitemyapp> triliyn: that having been said, I'm excited for Rust :)
14:21:04 <edwardk> skypers: then by all means don't use it. it is written so you can supply lenses without depending on the package. it is written so you can _consume_ lenses without depending on the package
14:21:06 <ReinH> guesting: but really you shouldn't be afraid to add strictness annotation to real world haskell problems to deal with space leaks
14:21:12 <simpson> skypers: I don't start with it when I write projects; I just end up thinking in those operators and eventually bringing it in to simplify operations.
14:21:14 <ReinH> s/problems/programs
14:21:26 <Nafai> bitemyapp: Rust looks compelling as a C and C++ replacement, for sure.
14:21:40 <guesting> ReinH: Yeah, but I just want the program to be consistent, not filled with lazy and strict
14:21:54 <edwardk> linear which is lenses to the bone didn't bring in an actual lens dependency until just recently
14:22:19 <guesting> ReinH: Also, adding a bang didn't work. I just put a "!" in front of "newMat", right?
14:22:26 <bitemyapp> Nafai: aye. Only viable one to roll around of late.
14:22:29 <ReinH> guesting: you need the BangPatterns pragma
14:22:38 <skypers> edwardk: about the ^@.., what does it do again?
14:22:39 <guesting> ReinH I have that too
14:22:48 <skypers> it reads with indexes?
14:22:50 <ReinH> guesting: well I could be wrong about where the leak is
14:22:59 <maurer> How do I tell cabal to use a different global package db?
14:23:00 <edwardk> and there it lets us do things like V2 (V3 1 2 3) (V3 4 5 6) ^. column _x    which reads very nicely.
14:23:06 <ReinH> but there's nothing "inconsistent" about mixing nonstrictness and strictness
14:23:10 <maurer> *cabal-install
14:23:30 <edwardk> > M.fromList [("hello",1),("skypers",2")] ^.. itraversed
14:23:31 <lambdabot>  <hint>:1:55:
14:23:31 <lambdabot>      lexical error in string/character literal at end of input
14:23:32 <dcoutts> maurer: by telling ghc & ghc-pkg via --ghc-options --ghc-pkg-options
14:23:36 <ReinH> edwardk: wait you can do that?
14:23:39 <edwardk> > M.fromList [("hello",1),("skypers",2)] ^.. itraversed
14:23:40 <lambdabot>  [1,2]
14:23:43 <edwardk> > M.fromList [("hello",1),("skypers",2)] ^@.. itraversed
14:23:44 <lambdabot>  [("hello",1),("skypers",2)]
14:23:55 <edwardk> it brings along the index/keys
14:24:22 <edwardk> > M.fromList [("hello",M.fromList [("skypers",'!')])] ^@.. itraversed<.>itraversed
14:24:24 <lambdabot>  [(("hello","skypers"),'!')]
14:24:27 <ReinH> guesting: where does SparseMatrix come from?
14:24:43 <guesting> ReinH: http://hackage.haskell.org/package/sparse-lin-alg-0.4.3/docs/Math-LinearAlgebra-Sparse-Matrix.html
14:24:54 <maurer> dcoutts: I'm trying to figure out if there's a way to put this in a config file so I can do it for a cabal sandbox
14:25:02 <edwardk> > M.fromList [("hello",M.fromList [("skypers",'!')])] ^@.. itraversed . Lens.indices (< "x") <.> itraversed
14:25:04 <lambdabot>  [(("hello","skypers"),'!')]
14:25:07 <edwardk> > M.fromList [("hello",M.fromList [("skypers",'!')])] ^@.. itraversed . Lens.indices (> "x") <.> itraversed
14:25:09 <lambdabot>  []
14:25:10 <maurer> dcoutts: Can I just set ghc-options and ghc-pkg-options as fields there?
14:25:16 <edwardk> ndices lets you filter on the index.
14:25:23 <edwardk> note t works evn when you ignore the index in the end
14:25:27 <edwardk> > M.fromList [("hello",M.fromList [("skypers",'!')])] ^.. itraversed . Lens.indices (> "x") <.> itraversed
14:25:29 <lambdabot>  ""
14:25:50 <maurer> dcoutts: I get unrecognized options when I try that
14:25:53 <edwardk> > M.fromList [("hello",M.fromList [("skypers",'!')])] ^.. itraversed . Lens.indices (> "x") . traverse
14:25:54 <lambdabot>  ""
14:25:57 <skypers> this is like being blind for the first time, edwardk :D
14:25:58 <ReinH> edwardk: you have a sparse matrix package right?
14:26:18 <ReinH> isn't it strict?
14:26:21 <edwardk> skypers: anyways that sort of thing is what all the crap you are saying is too complicated is for
14:27:06 <skypers> crap? :)
14:27:49 <edwardk> skypers: everything in lens correctly deals with those indices, preserving them where possible. a handful of us went nuts writing really hard code for 2 years so that most users would never have to care about how it works and could just reach for a combinator saying what to do, and stick together some lenses and prisms saying what to do it to, and all the pieces would just work together
14:28:45 <skypers> I understand edwardk
14:28:59 <codygman> I would like to convert a file read into a lazy bytestring into lazy Text. It is in latin-1 encoding. There is a Data.Encoding.decodeLatin1 function but it only seems to take strict bytestrings which if I understand correctly ar read into memory. When using strict bytestrings I get OOM errors because the file is being read into memory (I think).
14:29:19 <edwardk> and we're happily using all of those points in the design space that it supports, so i don't see how to lobotomize it and retain the usability and i don't want to
14:29:30 <skypers> edwardk: I just keep thinking Control.Lens is what Qt is to C++: another language
14:29:35 <edwardk> sure
14:30:38 <xplat> aw, man.  shake's Action is not a MonadPlus ...
14:31:02 <ReinH> it's almost as if we use sometimes languages to write other langauges within those langauges to work with certain problem domains.
14:31:07 <edwardk> i deliberately broke with many conventions, sort of latin-hypercube style, trying to find things that made lens be better at what it is. it didn't fit with a lot of my pre-existing code at first either.
14:31:12 <ReinH> s/use sometimes/sometimes use
14:31:29 <edwardk> i switched my conventions to suit it because it makes me more productive
14:31:54 <edwardk> there are still things i'd like to improve, better makeClassy support for superclasses on the classes it makes, etc.
14:33:00 <skypers> edwardk: maybe some day I’ll finally fall in luv with the whole Control.Lens
14:33:12 <skypers> I might lack problems’ experience
14:33:38 <edwardk> but my goal was very solipsistic -- to make everything in it work with as many other things in it for deep fundamental reasons rather than perl-like adhoc'ery.
14:34:01 <skypers> but up to now, and with the fact I’d like using a few tools to build what ^@.. is for (with mapM, Bifunctors and so on), I’m not about to dig in right now
14:34:11 <skypers> I’d rather like*
14:35:15 <edwardk> i added the indices to lens because users were running into situations where they had built up a bunch of lens code, and then had to tear it all down the moment they needed to work with the indices of the map they were iterating over.
14:35:51 <ReinH> edwardk: well that caused me to coin a ne word. Now I just need to figure out what it means and how to use it.
14:35:57 <edwardk> without that sort of thing you 'fall out of the band of applicability of the abstraction', so it is in there. it is in there as a safety net, keeping you from having this sharp culture shock where lens jus suddenly oesn't wrk
14:36:06 <xplat> that problem shows up a lot of places besides lens too
14:36:15 <ReinH> actually on second thought it a stupid word
14:36:30 <xplat> for example, foreach loops and python generators both handle it badly when you need to do something with the indices
14:36:40 <Axman6> hmmm, if I have the results of a one to one mapping of integers, is there a way I can figure out if there's a relatively simple function from a to b? the pairs look fairly random (and likely are supposed to be, it's the results of an error correcting code)
14:37:00 <edwardk> do i think you should write everything th lens way? not necessarily. but i do like the idea that if you have something 99% of the way there with lens, that reaching for the 1% shouldn't break you and make you go back to starting over.
14:37:09 <Axman6> when I say integers, I mean 16 bit integers, so it's not a huge space
14:37:15 <edwardk> xplat: exactly
14:38:25 <ReinH> Axman6: sounds like you're basically asking for line fitting.
14:39:18 <ReinH> Axman6: so the answer is generally no, but there are varying degrees of approximation.
14:39:23 <guesting> When I am using -xc for profiling and it says "Excpetion THUNK_STATIC" and gives a stack trace starting with a function, is THAT the function where the stack space overflow occurred?
14:39:37 <edwardk> skypers: i don't expect to convince you to use lens with that argument, but that is why those things and a bunch of others that you will probably never use and/or would find absurd are in lens.
14:40:41 <xplat> is there a standard MonadPlus instance you can write in terms of Alternative and Monad?  i'd kind of like to get this script done today instead of waiting for a new version of shake to be released
14:41:34 <Axman6> ReinH: yeah, but I doubt there's any nice line for this.
14:42:07 <skypers> I understand edwardk
14:42:21 <edwardk> xplat: you can just say mzero = empty; mplus = (<|>)   -- i have no counter-examples claiming it doesn't work.
14:42:28 <skypers> I’m just happy not feeling the need of using lens :D
14:42:51 <Fuuzetsu> …
14:42:53 <edwardk> I'm just happy that I've decided to stop bothering defending it to you :P
14:43:00 <pranz> but then why make it a monadplus in the first place?
14:43:05 <xplat> ReinH: maybe this is asking for boolean function minimization
14:43:18 <edwardk> pranz: "i have no counter-examples" doesn't mean one can't exist
14:43:29 <xplat> edwardk: good enough!  :)
14:43:30 <edwardk> pranz: the laws for Alternative are in terms of Applicative
14:43:50 <edwardk> pranz: they don't imply the laws for MonadPlus necessarily, though in practice they seem to
14:43:53 <pranz> edwardk: my question was directed toward xplat
14:43:58 <AshyIsMe> so pronunciation, do you guys say "hass kell" or "haskle"?
14:43:59 * Axman6 -> work
14:44:13 <Axman6> AshyIsMe: the latter for me
14:44:15 <edwardk> AshyIsMe: the latter
14:44:20 <Axman6> has-kul
14:44:31 <xplat> pranz: so i can use guard
14:44:46 <edwardk> AshyIsMe: shapr & ddarius put the emphasis on the latter syllable, but we've made fun of them for years ;)
14:44:53 <Fuuzetsu> hasklel
14:44:54 <pranz> xplat: ah, fair enough
14:45:12 <skypers> @hoogle (MonadTrans t) => t m a -> m a
14:45:12 <lambdabot> Control.Applicative.Backwards forwards :: Backwards f a -> f a
14:45:13 <lambdabot> Data.Functor.Reverse getReverse :: Reverse f a -> f a
14:45:13 <lambdabot> Control.Monad.Trans.Identity runIdentityT :: IdentityT m a -> m a
14:45:44 <skypers> the thing I’m seeking for might be something like a contra MonadTrans?
14:46:18 <skypers> a (MonadTrans t) => t has a morphism from m a to t m a, I want something from t m a to m a
14:46:44 <jle`> why can't i seem to use CPP stuff in my .cabal file?
14:46:49 <jle`> do i need to enable anything?
14:47:29 <dcoutts> jle`: you don't really mean "#if blah"-cpp stuff in the .cabal file right?
14:47:42 <edwardk> :t Control.Comonad.Trans.lower
14:47:43 <lambdabot> Couldn't find qualified module.
14:47:49 <edwardk> bah
14:48:58 <jle`> dcoutts: yes i do :|
14:49:07 <dcoutts> jle`: erm ok, no that's not a feature.
14:49:15 <jle`> darn
14:49:22 <jle`> well thanks.
14:49:32 <dcoutts> jle`: see the user guide about conditional stuff
14:49:32 <L8D> then why is it in GHC?
14:49:35 <skypers> :t Control.Comonad.Trans.Class.ComonadTrans.lower
14:49:36 <lambdabot> Couldn't find qualified module.
14:49:46 <skypers> :t Control.Comonad.Trans.Class.lower
14:49:47 <lambdabot> (Control.Comonad.Comonad w, Control.Comonad.Trans.Class.ComonadTrans t) => t w a -> w a
14:49:49 <skypers> ok
14:49:51 <skypers> thank you edwardk
14:49:52 <ReinH> I still totally don't grok the use of comonad transformers.
14:49:55 <ReinH> at all.
14:49:57 <skypers> that sounds just nice
14:50:03 <ReinH> are there any motivating examples lying around?
14:50:06 * hackagebot BlogLiterately 0.7.1.3 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.3 (BrentYorgey)
14:50:08 <edwardk> ReinH: they exist because they should ;)
14:50:09 * hackagebot strict-base-types 0.2.2 - Strict variants of the types provided in base.  http://hackage.haskell.org/package/strict-base-types-0.2.2 (SimonMeier)
14:50:11 <ReinH> edwardk: :p
14:50:13 <skypers> not a lot of instances :D
14:50:17 <skypers> (actually none ahah)
14:50:21 <ReinH> hah
14:50:29 <edwardk> ReinH: the main use case is with composing distribution laws for generalized catamorphisms
14:50:40 <ReinH> oh right yeah well obviously...
14:50:46 <ReinH> /s
14:51:24 <edwardk> IdentityT, EnvT, StoreT, DensityT, TracedT, various adjunction based transformers...
14:51:53 <edwardk> skypers: there are 4 in the package defining it http://hackage.haskell.org/package/comonad-4.0/docs/Control-Comonad-Trans-Class.html
14:52:24 <edwardk> there aren't any MonadTrans instances in base either =P
14:54:22 <L8D> > fmap length getArgs
14:54:23 <lambdabot>  Not in scope: `getArgs'
14:58:07 <ski> @type fmap length System.Environment.getArgs
14:58:07 <lambdabot> IO Int
15:00:18 <abdulsattar> Hello, is there any way I can access a function that is not exported by a module?
15:00:27 <merijn> abdulsattar: No
15:00:36 <abdulsattar> I just need to test it out in ghci
15:00:45 <merijn> abdulsattar: Ah, that's different
15:00:53 <Qett> whats the exclamation mark in { asdf :: !String } ?
15:00:58 <merijn> abdulsattar: Use ":load filename.hs" instead of "import"
15:01:08 <pranz> Qett: strictness
15:01:11 <abdulsattar> ok, great! thanks
15:01:15 <merijn> abdulsattar: :load will load the file directly, ignoring export lists
15:01:20 <Qett> oh
15:01:35 <abdulsattar> Thanks, never knew about that
15:01:36 <pranz> Qett: it means that asdf will evaluate to WHNF
15:01:56 <Qett> WHNF?
15:02:02 <merijn> Weak Head Normal Form
15:02:07 <Qett> oh
15:02:19 <pranz> there is a great article on how haskell evaluates stuff
15:02:34 <pranz> if you haven't read it, I suggest it
15:02:50 <Qett> what article?
15:02:54 <pranz> uh, what was the name now again
15:02:57 <pranz> sec
15:04:00 <pranz> Qett: here it was: http://chimera.labs.oreilly.com/books/1230000000929/ch02.html
15:04:15 <Qett> ah ok
15:04:16 <Qett> thanks
15:04:18 <abdulsattar> merijn: I am sorry, I wasn't asking about loading files. I need to load module and access functions that are not exported by it. Can I do that?
15:04:53 <merijn> abdulsattar: Not without the source file
15:05:33 <abdulsattar> Ok, just wondering is there anything like Reflection in Haskell?
15:06:16 <ski> Qett,pranz : monochrom's "Lazy Evaluation of Haskell" at <http://www.vex.net/~trebla/haskell/lazy.xhtml> might also be interesting
15:06:23 <edwardk> abdulsattar: we have a notion of reflection, but it is very different than what you are used to, so effectively no. that said you can do evil evil things with ghc-api or hint, etc.
15:06:55 <Qett> ok thanks ski
15:07:12 <ski> thank monochrom, not me
15:07:35 <Qett> thank jesus
15:07:49 <abdulsattar> edwardk: I don't think I know enough of Haskell to do those tools, but thanks for answering!
15:08:10 <zomg> lol just saw this on twitter, how to add a number to another number in Haskell
15:08:11 <zomg> http://i.imgur.com/sXnpa9M.png
15:08:14 <zomg> genius.
15:08:23 <edwardk> abdulsattar: basically you can't
15:08:32 <skypers> edwardk: do you know why such a name for lower?
15:08:36 <tac> hehehe zomg
15:08:36 <skypers> hm
15:08:37 <edwardk> zomg: stole it from rwbarton
15:08:40 <skypers> I have my idea
15:08:50 <edwardk> skypers: opposite of lift
15:08:58 <skypers> it’s because it lowers a monad layer
15:08:59 <skypers> yeah
15:09:03 <skypers> ok, quite obvious
15:09:12 <zomg> edwardk: ah right it was you who tweeted it, I just blindly click all links and then share them on irc
15:09:16 <zomg> haha
15:09:24 <skypers> comonads sound really great :)
15:09:30 <skypers> but I often mistaken them
15:09:32 <edwardk> skypers: note it works on comonads, not monads
15:09:32 <skypers> for instance
15:09:36 <L8D> wtf is lens anyways?
15:09:43 <lllllllllllll> when i have: (m, s) <- ask; why is m not in scope in a where?
15:09:47 <skypers> if I want to duplicate arguments of a function
15:09:55 <louiscipher> L8D: +1
15:09:58 <skypers> I could think of the comonad duplicate
15:10:00 <skypers> well NO
15:10:03 <skypers> it’s just join
15:10:07 <skypers> a regular monad
15:10:10 <edwardk> L8D: a library that is designed to provoke strong feelings
15:10:12 <skypers> +function
15:10:13 <simpson> L8D: Sometimes there are values that have other values inside.
15:10:17 <skypers> ahahaha edwardk
15:10:19 <skypers> <3 :D
15:10:28 <skypers> no wrong feelings though :)
15:10:28 <simpson> L8D: And so one defines getters and setters to get at and alter those inner values.
15:10:37 <skypers> just respect, edwardk :)
15:10:49 <simpson> L8D: The lens library is a collection of formalizations and tools for managing this idiom.
15:10:50 <skypers> I give you my cyclope smiley, .)
15:11:07 <edwardk> L8D: http://lens.github.io/
15:11:39 <edwardk> i need to figure out how to fix the jekyll on that site and push a year or so of lens news out
15:11:51 <L8D> it looks...dirty
15:11:51 <ski> lllllllllllll : `where' attaches to the defining equation, not to individual expressions like a `do'-block (or iondividual commands in it)
15:12:15 <ski> lllllllllllll : either use `let', or parameterize on the variables you want to use
15:12:43 <ski> lllllllllllll : .. if you paste you're actual code, you might get more concrete suggestions for improvement
15:12:56 <ski> (*sigh* s/you're/your/)
15:13:19 <merijn> ski: Yay, now I feel less stupid for continually typoing those two :p
15:13:32 <L8D> :t set _2 42
15:13:33 <lambdabot> (Num b, Field2 s t a b) => s -> t
15:14:13 <edwardk> > ("hello","world") & _2 .~ "L8D"
15:14:14 <lambdabot>  ("hello","L8D")
15:14:28 <ski> merijn : i deserve a thwap <http://www.angryflower.com/bobsqu.gif>
15:14:29 <L8D> So...Lens makes Haskell into Perl?
15:14:34 <tac> > ("hello","world") & _2 .~ 7
15:14:35 <lambdabot>  ("hello",7)
15:15:16 <lllllllllllll> ski, lpaste.net/99274
15:15:17 <skypers> L8D: lens makes you head explode ;)
15:15:26 <edwardk> L8D: in a rather more principled way. you can write that as > set _2 "L8D" ("hello","world") as well. & is just flipped function application and .= is assignment in state, with .~ being its functional analogue
15:15:29 <lllllllllllll> ski, http://lpaste.net/99274
15:15:37 <L8D> What's the difference between flip ($) and (&) ?
15:15:46 <edwardk> L8D: legibility ;)
15:15:49 <L8D> nevermind
15:16:05 <L8D> is (&) in prelude?
15:16:17 <L8D> :t _2
15:16:18 <lambdabot> (Functor f, Field2 s t a b, Indexable Int p) => p a (f b) -> s -> f t
15:16:25 <joelteon> no L8D
15:16:42 <johannesbodannes> and may it so remain forever
15:16:45 <edwardk> L8D: we recenty had a proposal to add it to Data.Function that passed the libraries@ mailing list and core libraries committee, so it'l wind up in base, but not the Prelude
15:16:49 <merijn> ski: You know what's really frustrating? Apostrophes indicate both possessie *and* plural in Dutch, so I always have a conflicting reflex while typing English >.>
15:17:26 <edwardk> merijn: 'its' must give you conniption fits ;)
15:17:36 <merijn> edwardk: Yes!
15:17:40 <L8D> merijn: I think the word you're looking for is 'possessive'
15:17:55 <ski> lllllllllllll : is the `m' in `messageFrom m' supposed to be the `m' from `(m, _, c) <- ask', or the `m' from `let m = Message { ... }' ?
15:17:58 <merijn> edwardk: I have to double think that word every single time
15:18:24 <edwardk> merijn: i know the rule and use it correctly when writing in a formal setting, but i always have to stop to remember it.
15:19:10 <lllllllllllll> ski, sorry i just edited it  it is let m' now
15:19:12 <ski> lllllllllllll : hm, i suspect it's the `m' from `(m, _, c) <- ask'
15:19:34 <ski> ok
15:19:38 <L8D> > _2 (1,2)
15:19:39 <lambdabot>  Could not deduce (Control.Lens.Internal.Indexed.Indexable
15:19:40 <lambdabot>                      GHC.Types.Int (,))
15:19:40 <lambdabot>    arising from a use of `Control.Lens.Tuple._2'
15:19:40 <lambdabot>  from the context (GHC.Base.Functor f,
15:19:40 <lambdabot>                    GHC.Num.Num a,
15:20:10 * hackagebot web-routes 0.27.5 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.27.5 (JeremyShaw)
15:20:51 <joelteon> > view _2 (1,2)
15:20:53 <lambdabot>  2
15:21:42 <Peaker> Twey: hey, you there?
15:22:21 <edwardk> > _2 (\x -> [x,x +1]) ("hello",3)
15:22:22 <lambdabot>  [("hello",3),("hello",4)]
15:22:40 <pranz> :t (&)
15:22:40 <lambdabot> a -> (a -> b) -> b
15:25:11 * hackagebot web-routes-boomerang 0.28.2 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-boomerang-0.28.2 (JeremyShaw)
15:25:13 * hackagebot web-routes-happstack 0.23.7 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.23.7 (JeremyShaw)
15:25:15 * hackagebot web-routes-wai 0.23.1 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.23.1 (JeremyShaw)
15:26:27 <lllllllllllll> ski, oh thank you, why did i not consider this? :)
15:28:03 <pranz> :t at
15:28:04 <lambdabot> (Functor f, Indexable (Index m) p, At m) => Index m -> p (Maybe (IxValue m)) (f (Maybe (IxValue m))) -> m -> f m
15:28:18 <merijn> lol
15:28:22 <pranz> isn't that something
15:29:23 <ski> lllllllllllll V
15:29:34 <xplat> gah, i cut back to making a simple test build system with shake and i can't even get that working
15:29:47 <bitemyapp> xplat: I use Make, why do you use Shake?
15:30:11 * hackagebot reform 0.2.3 - reform is an HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.2.3 (JeremyShaw)
15:31:49 <Rc43> Can anybody explain what is "normalization by evaluation"?
15:32:39 <xplat> http://lpaste.net/99278
15:32:56 * ski annotated "ask and where" with "using `let'" at <http://lpaste.net/99274#99276>
15:33:34 <xplat> bitemyapp: i was using make before, but make uses in-band signalling so it can't handle paths with spaces or several other characters
15:33:35 * ski annotated "ask and where" with "using parameterization" at <http://lpaste.net/99274#99277>
15:33:59 <bitemyapp> xplat: gotcha.
15:34:00 <ski> (dunno why lpaste didn't announce those)
15:34:24 <ski> lllllllllllll : those two ^ are the main alternatives
15:34:42 <tpsinnem> question on the ST monad: can i expect nice garbage collection behavior when overwriting the last STRef to some object?
15:35:10 <Peaker> Rc43: In the lambda calculus, you have only lambdas, applications, and variables.  When you have an application of a lambda, i.e:  ((\x -> ..) arg)   it is called a "redex".    Evaluation of the LC consists of replacing redex'es with the substituted lambda body.  When no redexes remain, an LC term is fully "normalized".  Normalization by evaluation is, iiuc, just doing redex reduction by "evaluation", which iiuc is simply the substitutions
15:35:12 * hackagebot reform-blaze 0.2.2 - Add support for using blaze-html with Reform  http://hackage.haskell.org/package/reform-blaze-0.2.2 (JeremyShaw)
15:35:12 <ski> tpsinnem : probably
15:35:14 * hackagebot reform-hsp 0.2.4 - Add support for using HSP with Reform  http://hackage.haskell.org/package/reform-hsp-0.2.4 (JeremyShaw)
15:35:16 * hackagebot reform-happstack 0.2.2 - Happstack support for reform.  http://hackage.haskell.org/package/reform-happstack-0.2.2 (JeremyShaw)
15:35:48 <Rc43> Peaker, what is "other" way?
15:35:51 <lllllllllllll> ski, thank you i kinda like the let one more, or is parameterizing the prefered way? i ask because in where i can use guards
15:35:51 <jmcarthur_mobile> Peaker: how does it differ from other methods of normalization?
15:35:59 <Peaker> Rc43, jmcarthur_mobile: I'm not sure :)
15:36:09 <ski> Peaker : kristof earlier was possibly interested in Bottle^WLamdu
15:36:23 <Peaker> ski: I saw, but was busy, couldn't hop by
15:36:41 <jmcarthur_mobile> tpsinnem: I don't expect any special behavior from the GC for STRefs
15:36:43 <Rc43> Peaker, or it is meant that we don't use any analytical ways for finding normal form, but just evaluate rules?
15:36:56 <ski> lllllllllllll : you can use guards in either (maybe you mean that you can use `where'-defined things in guards, though)
15:37:06 <Peaker> Rc43: that sounds like a good guess, I am not sure myself
15:37:22 <jmcarthur_mobile> tpsinnem: in fact, I expect the write barrier to sometimes be an issue
15:37:24 <ski> lllllllllllll : anyway, use whichever you think is prettiest -- in different circumstances, it might be the one, or the other, depending
15:37:41 <jmcarthur_mobile> tpsinnem: depending on how efficient the code needs to be
15:38:00 <xplat> Rc43: it's sort of the opposite, NbE is saying 'instead of normalizing by rewriting, normalize by interpreting lambda and application (and any other primitives) in a type that only contains normalized terms"
15:38:42 <Peaker> xplat: how do you interpret them in such a type without simply doing the substitutions?
15:38:58 <jmcarthur_mobile> xplat: oh, it just means having a different type for value forms?
15:39:46 <xplat> Peaker: you do hereditary substitution instead of forming redexes and then rewriting them away
15:39:54 <Rc43> xplat, you mean that we interpret lambda as a "function" in other (meta) language and just "apply" it?
15:40:04 <lllllllllllll> ski, ahh i see...it was the annoying layout thing that i had like 5 hours ago (the guards | not indented far enough)
15:40:07 <tpsinnem> ski, jmcarthur_mobile: thanks -- i should probably do more reading on the GC. if i find something particularly relevant w.r.t. mutation in ST, that'll be extra nice of course
15:40:12 * hackagebot reform-hamlet 0.0.2 - Add support for using Hamlet with Reform  http://hackage.haskell.org/package/reform-hamlet-0.0.2 (JeremyShaw)
15:40:18 <jmcarthur_mobile> Oh. It's just a final encoding of the lambda calculus?
15:40:19 <lllllllllllll> ski, so i got parse error
15:40:28 <lllllllllllll> ski, thank you very much!
15:40:38 <jmcarthur_mobile> Where the target is a value form.
15:40:45 <L8D> so...what is the point of lens again?
15:40:46 <Rc43> xplat, so, if e.g. we describe LC with haskell then we interpret "\x . x" as "is" and then apply it to arguement?
15:41:05 <xplat> jmcarthur_mobile: right.  and then to be proper you 'reflect' it back into the term type
15:41:33 <jmcarthur_mobile> Why is reflecting more proper than just leaving it in reified form?
15:41:41 <jmcarthur_mobile> Just convention?
15:42:44 <ski> Rc43,jmcarthur_mobile,Peaker : with NbE, the syntactic term is interpreted in the host language (more or less like compiling it on-the-fly into the host), which then computes as new syntactic term as result. the usual method of normalization just syntactically manipulates the term, contracting redices, possibly by using something zipper-like to keep track of the currently focused subterm
15:42:50 <ski> Rc43,jmcarthur_mobile,Peaker : iirc
15:42:55 <xplat> jmcarthur_mobile: because normalization is normally Term -> Term in rewriting systems, so reflecting allows it to fit into the 'API' of other normalization proofs
15:43:35 <ski> lllllllllllll : btw, you had lots of superfluous extra spaces at the ends of lots of lines. i removed those in the annotations. you should probably make sure you remove them from your source as well
15:44:26 <triliyn> ski: are extra spaces potentially harmful?
15:44:31 <jmcarthur_mobile> TIL almost all LC implementations I have ever made use NBA, just usually without reflection.
15:44:32 <Rc43> xplat, ski, Peaker, jmcarthur_mobile, now I understood. If I am right it uses "quoting" like in higher-order abstract syntax approach.
15:44:51 <jmcarthur_mobile> *NbE
15:45:18 <lllllllllllll> ski, it is just on lpaste because copied from vim i guess, but thx
15:45:31 <ski> triliyn : not really at end of lines, but it's annoying :)
15:45:47 <Peaker> Sounds like NbE would be better described by Evaluation-in-Host-Language?
15:45:50 <triliyn> ski: ah, right
15:46:32 <lllllllllllll> ski, yeah i have set listchars=tab:▸\ ,trail:¬ in my vimrc
15:46:36 <ski> (s/NBA/NbE/ ?)
15:47:19 <jmcarthur_mobile> Peaker: it seems to me that NbE isn't required to use HOAS, at least not in all the literature I've seen. I see a lot of de bruijn still
15:47:27 <xplat> Peaker: it's true you move the computation to a host language or other metalevel, but the 'Evaluation' in the name actually refers to the reify step
15:47:43 <jmcarthur_mobile> Peaker: hoas is normally what I think of when I think of evaluation in host language
15:48:17 <jmcarthur_mobile> At least when binders are in the syntax
15:48:22 <xplat> because it reifies a host-level Term into a host-level Value
15:49:08 <Qett> if i have a data Foo = Foo { a :: Int, b :: Int ... n :: Int} how can i pattern match on a specific member in a function definition?
15:49:14 <Qett> by its name
15:50:07 <Qett> oh i got it nvm
15:51:12 <xplat> jmcarthur_mobile: HOAS reifies away substitution by turning Term-in-context types into host-level functions of Term.  NbE is almost, but not quite, orthogonal to this
15:51:56 <jmcarthur_mobile> This agrees with my understanding I guess
15:52:59 <jmcarthur_mobile> Host syntax vs. host values
15:53:17 <jmcarthur_mobile> Not quite
15:55:32 <colDrMcBeardman> does ghc dislike /* c style comments */ in strings?
15:56:11 <sm> colDrMcBeardman: yeah man, that's the one thing I don't like about Haskell
15:56:19 <sm> no, just kidding :)
15:56:36 <frx> > "/* c style comments */"
15:56:37 <lambdabot>  "/* c style comments */"
15:56:42 <frx> what made you think it does?
15:56:47 <colDrMcBeardman> lol i thought i was going insane. i keep getting "parse error on input" and i have no idea what's going on.
15:56:51 <edwardk> L8D: lens is jquery for haskell data types with both the good and the bad that analogy entails
15:57:26 <L8D> hm...
15:57:27 <xplat> iow, lens is not a monad
15:57:50 <L8D> why does the functor instance for (a, b) map over b?
15:57:59 <L8D> > fmap succ (1, 1)
15:58:00 <lambdabot>  (1,2)
15:58:11 <xplat> L8D: (a, b) is sugar for (,) a b
15:58:36 <L8D> How would one map over the first element in the tuple?
15:58:52 <xplat> L8D: the Functor instance is for (,) a, because that's the only prefix that has the right kind
15:59:23 <edwardk> > over both succ (1,1)
15:59:25 <lambdabot>  (2,2)
15:59:35 <Fuuzetsu> L8D: it's the only possible functor for a pair
15:59:38 <xplat> so fmap has to have the type (b -> c) -> ((a,b) -> (a,c))
15:59:50 <edwardk> to answer your question from earlier with your question from now, over and both are from lens
15:59:51 <ReinH> L8D: you can use a lens, but the functor instance for (a,b) is the only legal one b/c of the kind as xplat mentioned
15:59:59 <jmcarthur_mobile> Fuuzetsu well, the only possible Functor for a Haskell tuple, at least
16:00:12 <L8D> okay...
16:00:14 * hackagebot happstack-authenticate 0.10.10 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.10 (JeremyShaw)
16:00:17 <Fuuzetsu> Haskell Functor for Haskell tuple
16:00:26 <jmcarthur_mobile> Fuuzetsu: other pair types exist of course
16:00:35 <L8D> @hoogle (a -> c) -> (a, b) -> (c, b)
16:00:36 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
16:00:36 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
16:00:36 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
16:00:46 <jmcarthur_mobile> data Pair a = Pair a a
16:00:57 <L8D> :t (,1)
16:00:58 <lambdabot> Num t1 => t -> (t, t1)
16:00:59 <ReinH> :k Functor
16:01:00 <lambdabot> (* -> *) -> Constraint
16:01:05 <ReinH> :k (,)
16:01:06 <lambdabot> * -> * -> *
16:01:06 <Fuuzetsu> jmcarthur_mobile: sure, but the talk is clearly about THE tuples
16:01:06 <L8D> > (,1) 2
16:01:07 <lambdabot>  (2,1)
16:01:13 <L8D> awesome
16:01:25 <ReinH> :k forall a. ((,) a)
16:01:26 <lambdabot> * -> *
16:01:35 <jmcarthur_mobile> Yes. Just trying to avoid confusion due to overgeneralization
16:01:42 <L8D> @pl (,1) 2
16:01:42 <lambdabot> (line 1, column 3):
16:01:42 <lambdabot> unexpected ','
16:01:42 <lambdabot> expecting expression
16:01:53 <Fuuzetsu> there's no evergeneralisation going on ;P
16:01:57 <L8D> @spl (,1) 2
16:01:57 <lambdabot> (line 1, column 3):
16:01:57 <lambdabot> unexpected ','
16:01:57 <lambdabot> expecting expression
16:01:58 <Fuuzetsu> over*…
16:02:02 <L8D> -.-
16:02:11 <Fuuzetsu> pl doesn't do tuple section
16:02:33 <Fuuzetsu> @pl (\x -> (x, 1)) 2
16:02:34 <lambdabot> (2, 1)
16:02:38 <Fuuzetsu> th-thanks
16:02:41 <ReinH> hah
16:02:44 <xplat> tuple sections weren't in the version of haskell when pl was written, i think
16:02:55 <L8D> what is spl?
16:02:55 <ReinH> Fuuzetsu: pl does do beta reduction :p
16:03:04 <Fuuzetsu> outsmarted
16:03:17 <L8D> @pl \x -> (,) x 1
16:03:17 <lambdabot> flip (,) 1
16:03:20 <Fuuzetsu> L8D: it's just @pl, lambdabot does some guessing in case you typo
16:03:25 <L8D> oh...
16:04:07 <L8D> @pl \x -> x >>= 1
16:04:07 <lambdabot> (1 =<<)
16:04:10 <xplat> @didyouvoteforpresidentnixon lambdabot?
16:04:10 <lambdabot> Unknown command, try @list
16:04:14 <ski> Rc43,jmcarthur_mobile,Peaker,xplat : type-directed partial evaluation and its relation to NbE and shift/reset is interesting
16:04:19 <xplat> i guess not that much guessing :)
16:04:32 <L8D> >>> 1
16:04:37 <L8D> >> 1
16:04:38 <L8D> < 1
16:04:45 <L8D> :r 1
16:04:52 <L8D> @soc flip
16:04:52 <lambdabot> flip f x y = f y x
16:05:07 <Fuuzetsu> xplat: it's like anything withing 3 character mutations IIRC
16:05:15 <ski> jmcarthur_mobile : i think there's at least two important variants of HOAS, depending on what host-level functions you use
16:05:19 <Fuuzetsu> there are rules for this somewhere, you could probably look at the source
16:05:38 <xplat> @plxon \a b -> b a
16:05:38 <lambdabot> It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
16:05:53 * Clint squints.
16:06:06 <guesting> Okay, this is driving me nuts. I know for SURE that http://pastebin.com/dwNqxqSz is causing the stack space overflow, but I can't figure out how to fix it!!
16:06:25 <ski> jmcarthur_mobile : one variant is to use computational functions (like `->' in Haskell). another is to use "syntactic/data functions", that don't do general computation, like in lambdaProlog and Twelf
16:06:42 <xplat> @mason dixon
16:06:43 <randomclown> I'm trying to debug my memory usage and there's a huge amount that's showing up as "Pinned"
16:06:43 <lambdabot> No match for "dixon".
16:06:47 <Fuuzetsu> guesting: what's with the ↩?
16:06:48 <ski> the nice thing with the latter is that we can match on them
16:06:53 <randomclown> how do I find what's responsible for the pinned memory/
16:07:01 <guesting> Fuuzetsu: From a copy and paste from vim
16:07:08 <L8D> @pl \x -> \y -> x + y
16:07:08 <lambdabot> (+)
16:07:11 <L8D> :)
16:07:24 <L8D> \x -> \y -> x y
16:07:30 <L8D> @pl \x -> \y -> x y
16:07:30 <lambdabot> id
16:07:41 <L8D> woah
16:07:47 <L8D> @pl ($)
16:07:47 <lambdabot> id
16:07:50 <L8D> woah!
16:08:07 <guesting> Ok, it appears to be because of the list
16:08:11 <ski> i think the latter basically corresponds to contexts with holes in them, iow parameterization (on possibly multiple parameters), without any analysis of the parameters, just plugging-in
16:08:15 <guesting> wait nevermind
16:08:17 <Fuuzetsu> I made some Agda glue syntax using ↯ the other day so it reminded me of that
16:08:19 <guesting> it's all of it
16:08:28 <L8D> > map succ `id` [1..10]
16:08:29 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
16:08:32 <L8D> lol
16:08:50 <Qett> L8D: wat
16:08:55 <L8D> Qett: ikr
16:09:00 <L8D> `id` is the new $
16:09:12 <Fuuzetsu> it was always $
16:09:12 <Qett> i mean
16:09:29 <Fuuzetsu> > map ($ 3) [succ, succ . succ, pred]
16:09:29 <Qett> u are very excited
16:09:30 <lambdabot>  [4,5,2]
16:09:37 <jmcarthur_mobile> ski: right, via higher order unification and such
16:09:38 <Fuuzetsu> > map (`id` 3) [succ, succ . succ, pred]
16:09:39 <lambdabot>  [4,5,2]
16:09:47 <L8D> map (flip id 3) [succ, succ . succ, pred]
16:09:51 <Peaker> (($) f) x    what does ($) have to do to `f` to make it applicable to `x`?
16:09:58 <jmcarthur_mobile> Which is a pretty awesome feature
16:10:13 <L8D> Peaker:
16:10:16 * hackagebot purescript 0.3.6.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.6.1 (PhilFreeman)
16:10:19 <L8D> @pl (($) f) x
16:10:19 <lambdabot> f x
16:10:22 <ski> *nod*, L-lambda unification
16:10:46 <Fuuzetsu> :t ($)
16:10:47 <lambdabot> (a -> b) -> a -> b
16:10:47 <Peaker> L8D: the answer is nothing, just keep f as it is, i.e: id :)
16:10:52 <xplat> there are various kinds of higher-order unification
16:10:53 <Fuuzetsu> @djinn (a -> b) -> a -> b
16:10:53 <lambdabot> f a = a
16:11:01 <L8D> Peaker: I understood that part
16:11:05 <Fuuzetsu> this doesn't seem right
16:11:14 <Fuuzetsu> did djinn mess up?
16:11:22 <xplat> no, that's right
16:11:22 <L8D> Fuuzetsu: it didn't
16:11:23 <Peaker> Fuuzetsu: why not? f = id
16:11:26 <jmcarthur_mobile> Nope
16:11:32 <L8D> @pl f a = a
16:11:33 <lambdabot> f = id
16:11:41 <Peaker> Fuuzetsu: f :: (a -> b) -> a -> b       the 'a' arg:  a :: (a -> b)
16:11:55 <jmcarthur_mobile> Fuuzetsu: ($)  = id
16:11:56 <Qett> what are all these @ thangs?
16:11:59 <L8D> @djinn Num a => [a]
16:11:59 <lambdabot> Error: Undefined type []
16:12:04 <L8D> @djinn Num a => [] a
16:12:04 <lambdabot> Cannot parse command
16:12:08 <Fuuzetsu> Qett: lambdabot commands
16:12:12 <Peaker> fun with augustuss's @pl and @djinn never ends :)
16:12:13 <xplat> @. pl djinn (a -> b) -> a -> b
16:12:14 <lambdabot> f = id
16:12:20 <Qett> ah
16:12:20 <Fuuzetsu> Peaker: oh, right
16:12:31 <ski> preflex: xseen preflex
16:12:33 <L8D> xplat: what. the. fack.
16:12:37 <ReinH> Fuuzetsu: (a -> b) -> (a -> b) ~ c -> c
16:12:41 <L8D> lambdabot is cool
16:13:03 <L8D> @src ($)
16:13:03 <lambdabot> f $ x = f x
16:13:21 <ReinH> Peaker: my favorite thing to do with @djinn is derive the (r->) instances for a bunch of type classes
16:13:22 <xplat> @. pl src ($)
16:13:22 <lambdabot> (line 1, column 8):
16:13:22 <lambdabot> unexpected " "
16:13:22 <lambdabot> expecting operator
16:13:36 <chaoslynx> @src (<*>)
16:13:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:13:37 <xplat> :(
16:13:44 <L8D> @pl f $ x = f x
16:13:44 <lambdabot> (line 1, column 8):
16:13:44 <lambdabot> unexpected " "
16:13:44 <lambdabot> expecting operator
16:13:49 <Fuuzetsu> I think I'd rather stick something in Agda than djinn, much less limited
16:13:54 <L8D> @pl ($) f x = fx
16:13:54 <lambdabot> (line 1, column 10):
16:13:54 <lambdabot> unexpected " "
16:13:54 <lambdabot> expecting operator
16:13:56 <L8D> @pl ($) f x = f x
16:13:56 <lambdabot> (line 1, column 10):
16:13:56 <lambdabot> unexpected " "
16:13:56 <lambdabot> expecting operator
16:14:07 <ReinH> L8D: you can talk to lambdabot by querying it too
16:14:08 <L8D> @pl d f x = f x
16:14:09 <lambdabot> d = id
16:14:22 <L8D> ReinH: oh yeah...
16:14:33 <xplat> well, because djinn is limited, it tends to actually finish, unlike agsy which is the closest agda equivalent
16:14:52 <ReinH> @djinn a -> r -> a
16:14:53 <lambdabot> f a _ = a
16:14:54 <ReinH> pure
16:15:06 <ReinH> @djinn (r -> a -> b) -> (r -> a) -> (r -> b)
16:15:06 <lambdabot> f a b c = a c (b c)
16:15:09 <ReinH> <*>
16:15:10 <ReinH> and so on
16:15:23 <xplat> @. pl djinn a -> r -> a
16:15:23 <lambdabot> f = const
16:15:38 <xplat> @. pl djinn (r -> a -> b) -> (r -> a) -> (r -> b)
16:15:38 <lambdabot> f = ap
16:15:40 <ReinH> xplat: oh nice
16:15:43 <ReinH> I didn't know you could do that
16:15:48 <xplat> that one's a little overeager
16:15:49 <Fuuzetsu> xplat: it gives a lot better results pretty much all the time ;P you can also pass arguments to agsy to make it do more stuff
16:16:13 <ReinH> xplat: well it doesn't know <*> :(
16:17:28 <xplat> @. pl djinn (r -> a) -> (a -> r -> b) -> (r -> b)
16:17:28 <lambdabot> f = flip flip id . (ap .) . flip (.)
16:17:48 <xplat> ...
16:18:05 <xplat> @djinn (r -> a) -> (a -> r -> b) -> (r -> b)
16:18:05 <lambdabot> f a b c = b (a c) c
16:18:08 <ReinH> xplat: it doesn't like that one
16:18:11 <ReinH> but it gets >>= right
16:18:20 <jroesch_> does anyone have a good resource for groking how to program with LogicT?
16:19:06 <xplat> jroesch_: i find what works best in these cases is being Oleg
16:19:32 <Fuuzetsu> just use logic
16:19:42 <tristan__> there is a whole channel for lens?
16:19:51 <jroesch_> xplat: I kind of get how to abuse the conts. to do what I want
16:19:53 <jroesch_> tristan__: yes
16:19:53 <ReinH> xplat: lmao
16:19:58 <simpson> tristan__: #haskell-lens
16:19:59 <Fuuzetsu> tristan__: soon to become the main Haskell channel I'm sure
16:20:07 <jroesch_> xplat: but I'm not oleg
16:20:15 <tristan__> why
16:20:23 <Fuuzetsu> become Oleg
16:20:48 <xplat> jroesch_: failing that, search for blog posts about it, if you don't find any you will need to learn to harness and bring out your inner Oleg
16:20:49 <Fuuzetsu> unsafeCoerce jroesch_ :: Oleg
16:21:09 <Fuuzetsu> @type unsafeCoerce
16:21:10 <lambdabot> Not in scope: `unsafeCoerce'
16:21:56 <jroesch_> even lambdabot doesn't want to use unsafeCoerce ;P
16:21:58 <xplat> jroesch_: which generally involves reading Oleg's site and playing around with the code samples until your eyes bleed, rest, then repeat.
16:22:10 <bitemyapp> the rest part is important.
16:22:20 <jroesch_> xplat: I'll just read the paper then :P was hoping to avoid that
16:24:24 <ski> @where Oleg
16:24:24 <lambdabot> http://okmij.org/ftp/
16:24:40 <Fuuzetsu> @where Fuuzetsu
16:24:40 <lambdabot> I know nothing about fuuzetsu.
16:24:43 <Fuuzetsu> ;1
16:24:46 <Fuuzetsu> ;(
16:24:53 <Fuuzetsu> @where lambdabot
16:24:53 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
16:25:19 <xplat> Fuuzetsu: if lambdabot knew about you you wouldn't be working properly
16:25:31 <ski> you're so secret even lambdabot doesn't know about you
16:25:37 <Fuuzetsu> I don't understand, xplat
16:25:44 <Fuuzetsu> I am the secretestestest.
16:26:01 <xplat> Fuuzetsu: think what you're named after
16:26:12 <Fuuzetsu> oh
16:26:29 <Fuuzetsu> after all, lambdabot is just a mere human, ne?~
16:27:29 <xplat> er.  well, for some purposes :)
16:27:36 <Saizan> so, closed type families over open kinds, good or evil?
16:28:05 <ski> hm, so partial ?
16:28:26 * ski isn't sure
16:28:41 <xplat> i'd say... er... 'naughty'?
16:29:24 <Saizan> not necessarily partial, eg. Eq (a :: *) (b :: *) :: Bool; Eq a a = True; Eq a b = False
16:30:32 <xplat> that one seems kinda bad
16:30:53 * ski agrees
16:33:00 <Saizan> next GHC will have them, iiuc
16:33:49 <Clint> the one coming out last month?
16:33:57 <Saizan> they seem fun, the problem is what "*" is
16:35:50 <randomclown> why does hp2any just segfault when it starts
16:36:35 <Saizan> Clint: 7.8 i think
16:37:01 <Peaker> Saizan: * is a wild-card or the kind?
16:37:39 <Clint> Saizan: that's the one
16:38:24 <Fuuzetsu> Clint: actually 7.8 rc1 got fingerprinted 2 hours ago, now all that's left is building and distribution
16:38:56 <Saizan> randomclown: i think i've used it successfully in the past
16:39:00 <Fuuzetsu> and I think you guys are discussing http://hackage.haskell.org/package/base-4.7.0.0/candidate/docs/Data-Type-Equality.html#t:-61--61-
16:39:28 <dhrosa> does anyone have reccomended reading past LYAH and real world haskell?
16:40:05 <Peaker> dhrosa: I'd recommend more writing at that point :)
16:40:12 <Clint> Fuuzetsu: oh wow
16:40:31 <merijn> dhrosa: Mostly from there it's papers and blog posts
16:40:49 <merijn> dhrosa: Depends what direction you wanna go in? Do you wanna learn practical tips and tricks? Theory?
16:42:17 <merijn> Saizan: Closed type familes over open kinds are semi-evil
16:42:35 <merijn> Saizan: Nice in theory, but likely to trigger subtle not-a-bug bugs
16:42:36 <maxiepoo> typeclassopedia
16:42:57 <ReinH> merijn: "subtle features"
16:43:03 <maxiepoo> that was probably more useful to me than all of lyah/rwh
16:43:11 <maxiepoo> well I didn't actually read rwh
16:43:12 <ReinH> +1 typeclassopedia
16:43:26 <merijn> Saizan: For example: https://gist.github.com/merijn/6130082/6c12ac84bbe86a473ef1cd28ab5dcb55ccedc307
16:43:33 <ReinH> and shameless plug for our interview with byorgey on the haskell cast
16:43:35 <Fuuzetsu> @where typeclassopedia
16:43:36 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
16:43:48 <merijn> Saizan: that code is broken due to the open kinds + type equality, resulting in the constraint always applying
16:44:55 <dhrosa> merijn: more practical
16:45:54 <merijn> dhrosa: Typeclassopedia as others mentioned, also read up on pipes and lens
16:46:16 <maxiepoo> I think lens is a bit much for a newb
16:46:19 <merijn> dhrosa: STM is worth learning
16:46:31 <mm_freak_> are all STM containers defined in terms of TVar?
16:46:43 <merijn> dhrosa: The STM paper (linked at the top of the Control.Concurrent.STM docs) is also a good and interesting read
16:46:48 <merijn> mm_freak_: afaik, yes
16:46:54 <mm_freak_> thanks
16:46:58 <xplat> in a way lens is perfect for a newb
16:47:15 <maxiepoo> I would suggest using some of the more approachable libraries like Parsec/Text.PrettyPrint in your code to get a feel for the way haskell libraries are structured
16:47:30 <merijn> dhrosa: Also, Simon Marlow's "Parallel & Concurrent Haskell" book
16:47:31 <xplat> it's useful and powerful, and when you're a newb all the type errors look scary, not just the lens ones
16:47:48 <merijn> maxiepoo: Well, parsec is already covered by RWH, and he was asking for things to read *after* RWH
16:48:07 <tpsinnem> ski, jmcarthur_mobile: fyi fwiw re: mutability and GC: after some browsing i came across these: https://ghc.haskell.org/trac/ghc/ticket/7662 https://ghc.haskell.org/trac/ghc/ticket/650 and others related to GHC and 'card marking' in the GC, which seems like the relevant concept
16:48:10 <maxiepoo> oh yea sorry haven't actually read rwh
16:48:43 <merijn> dhrosa: Personally I love GADTs and TypeFamilies, so the GADTs wikibook chapter (https://en.wikibooks.org/wiki/Haskell/GADT) and the "Fun with Type Functions" paper are good reads
16:48:44 <dhrosa> parsec is wonderful, haven't checked out pretty print yet
16:48:56 <maxiepoo> pretty print is very simple
16:49:18 <maxiepoo> the john hughes paper about it is good
16:49:19 <xplat> est suite shake-test: FAIL
16:49:28 <maxiepoo> Designing a Prettier Printer or something
16:49:29 <xplat> ... well, that explains that
16:49:40 <merijn> Anyway, all that combined should another half a year's worth of topics already ;)
16:51:55 <dhrosa> thanks :)
16:51:59 <codygman> I'm a bit confused by this type error: http://lpaste.net/99279
16:52:37 <Cale> You didn't link to a type error
16:52:42 <merijn> codygman: You forget to paste the error
16:52:52 <codygman> merijn: I just updated it
16:53:07 <niez> merijn, you can 'clone it in ide' :)
16:54:10 <Cale> codygman: The stuff you do with the result isn't enough to determine which decode it's meant to use
16:54:48 <hakujin> how do you guys use ghci during development? perspectives from vim & xmonad users especially welcome
16:55:01 <Cale> hakujin: Keep ghci running in a separate window
16:55:15 <Cale> hakujin: When file is updated, :r in ghci to reload
16:55:25 <maxiepoo> cabal repl running in an emacs buffer
16:55:50 <jfischoff> hakujin: Like Cale said. Almost all my develop involves ghci use.
16:55:54 <Cale> In fact, even when I used emacs, I would run ghci in a separate window
16:56:29 <Cale> I find having it running in an emacs buffer to be obnoxious, because of the way that emacs tends to deal with infinitely long lines and such
16:57:36 <codygman> Cale: Well I was trying to figure out how to decode correctly before doing more stuff with the result :P
16:57:45 <maxiepoo> Cale, what do you mean? I actually use it running in ansi-term in another window. Works great on linux, terrible on mac
16:57:45 <Cale> niez: also, that requires an account on FPComplete
16:57:54 <maxiepoo> buffer not window
16:58:23 <randomclown> How can I make +RTS -hc last longer
16:58:39 <Cale> "last longer"?
16:58:44 <randomclown> the time it keeps saying 6 seconds on the time scale on the bottom of the graph when I hp2ps
16:58:54 <Cale> Does your program exit normally?
16:58:55 <randomclown> the program was running for at least 30 seconds
16:59:05 <merijn> hakujin: I use tmux in my terminal to have splitscreen, vim on one half, ghci in the other and then I just use ":r" to reload a file
16:59:16 <randomclown> Cale: it had multiple threads so I just let the mainthread die
16:59:25 <randomclown> not sure how normal that is
16:59:30 <Cale> If the main thread dies, the whole program ought to die.
16:59:34 <randomclown> exactly
16:59:45 <dennda> lukexi: OK, thanks. I was just wondering because it said "theres this issue $foo that is already solved in 7.8"
16:59:56 <randomclown> Not sure why -hc is only giving me 6 seconds on the time scale
17:00:27 <hakujin> Cale, jfischoff, merijn: will you guys walk me through your exact workflows? e.g. "I use :t a lot; I test small functions with simple input, etc"
17:00:42 <Cale> randomclown: The only time I've ever seen that happen is when the program was exiting abnormally and not getting to flush the buffer on the .hp file
17:00:43 <hakujin> how is ghci beneficial to you guys
17:00:59 <hpc> it cured my foot fungus!
17:01:08 <Cale> hakujin: You just summarised it.
17:01:13 <randomclown> Cale: is there a way to make it flush faster?
17:01:13 <merijn> hakujin: I usually start by writing function type signatures without an implementation "foo :: Bar -> Baz; foo = undefined"
17:01:33 <merijn> hakujin: That means I can make sure all the types fit together, before bothering with an implementation
17:01:43 <Cale> randomclown: Maybe try explicitly using exitWith ExitSuccess
17:01:51 <merijn> hakujin: Then I load it in ghci and use ":t" to see how things would combine together
17:02:07 <hpc> hakujin: ghci is also sometimes a faster compiler
17:02:12 <hpc> ghci Foo.hs
17:02:26 <hpc> :r is faster to type
17:02:32 <merijn> 7.8 will have type holes, which will be much nicer than my current "foo = undefined" approach
17:02:36 <hpc> (yes, yes, up-enter is easy too)
17:02:48 <merijn> hakujin: btw, with vim you might wanna install hdevtools and syntastic
17:02:59 <hpc> merijn: i like foo = undefined
17:03:09 <merijn> hakujin: That will typecheck your file and hilight/annotate errors
17:03:10 <hpc> it makes it blatantly obvious that you need to put something there later
17:03:16 <merijn> hpc: Sure, but you can forget undefined
17:03:25 <merijn> hpc: type holes is a compile error, so you can't forget
17:03:28 <hakujin> merijn: I have ghc-mod, syntastic, necoghc, and YouCompleteMe which helps a lot; is hdevtools better than ghc-mod?
17:03:42 <hpc> oh, i see
17:03:49 <hpc> so it passes typechecking and fails on another pass
17:03:52 <dhrosa> how does the vector package manage to do O(1) indexing? does it use a C-binding? I can't see how to easily implement O(1) access with a normal haskell data structure
17:03:56 <merijn> hakujin: Not really, I just got hdevtools to work easier than ghc-mod :)
17:04:14 <merijn> hpc: Right, and it will in fact report the type of a hole in the error
17:04:29 <hpc> dhrosa: use the source, luke
17:04:34 <Cale> dhrosa: heh, I don't see how to do O(1) indexing at all ;)
17:04:37 <merijn> hpc: i.e. "this hole you left here has type X", which undefined doesn't do either
17:04:40 <hpc> http://hackage.haskell.org/package/vector-0.10.9.1/docs/src/Data-Vector.html#Vector
17:04:46 <kristof> dhrosa: Do you mean O(1) index access?
17:04:56 <Cale> But yeah, arrays
17:04:57 <kristof> dhrosa: That's sort of... the point of arrays in general.
17:04:58 <dhrosa> I was  trying, but I currently have shitty internet access, and d/ling a single file is taking a minute each
17:05:08 <hpc> ah
17:05:24 <hpc> data Vector a = Vector Int Int (Array a) deriving Typeable
17:05:34 <hpc> there's some strictness and unpacking going on too
17:05:35 <Cale> Also, unboxed vectors use lower level representations.
17:05:37 <dhrosa> Cale: well in C, you just load from a base-pointer + an offset, which is a constant time op
17:05:50 <dagnachew> hi all
17:06:08 <Cale> dhrosa: Only if you assume that pointers are fixed in size
17:06:18 <Cale> dhrosa: Which makes all the asymptotic analysis invalid
17:06:22 <dagnachew> anyone using vim here ? how can I solve this vim error ? https://github.com/spf13/spf13-vim/issues/508
17:06:40 <dhrosa> yes
17:06:47 <merijn> hpc: And type holes won't even require an extension \o/
17:06:53 <kristof> hpc: That's cheating, though
17:06:57 <hpc> dagnachew: the solution is there
17:07:02 <kristof> hpc: Because you already had arrays
17:07:18 <hpc> install hdevtools and ghcmod, then set the haddock browser
17:07:33 <hpc> kristof: yep :D
17:08:03 <kristof> hpc: Lmao. Is your name hpc because you do high performance computing or hewlett packard construction?
17:08:10 <dhrosa> hpc: I saw that link, but the actual implementation of (!) and friends is in another file, where the real source is in yet another file still..
17:08:15 <Cale> dagnachew: Install hdevtools and ghc-mod?
17:08:36 <Cale> dagnachew: I don't know what those things are but presumably you need them :)
17:09:06 <kristof> dhrosa: To answer your earlier question, a lot of GHC is written in C-- (which is a type of portable assembly language designed by Simon Peyton the Great and Friends)
17:09:21 <Cale> kristof: uhhhh
17:09:25 <kristof> Cale: No?
17:09:30 <Cale> GHC *generates* C-- code
17:09:37 <Cale> as an intermediate language
17:09:37 <kristof> Cale: so?
17:09:41 <hpc> ghc is written in haskell
17:09:50 <ivanm> Cale: I thought it was Cmm, which is similar to but different than C-- ...
17:09:51 <Cale> Essentially none of GHC is *written* in C--
17:09:52 <kristof> what was it written in before it was written in haskell
17:09:59 <Cale> (or Cmm, yes)
17:10:03 <hpc> the RTS is written in C
17:10:06 <Cale> (the m's stand for minus)
17:10:22 <Cale> kristof: It didn't exist before it was written in Haskell
17:10:30 <dhrosa> switching to other computer
17:10:33 <kristof> Cale: What was the first Haskell compiler, then?
17:10:34 <Cale> kristof: But eventually LML or something
17:10:43 <ivanm> wasn't the first haskell compiler written in a lisp dialect?
17:10:48 <hpc> the Array that vector uses is built off of some primitive type that's strangely hard to hoogle for
17:10:50 <Cale> I think Lazy ML
17:10:57 <ivanm> ahhh, right
17:11:13 <hpc> which is then provided by ghc by way of "here's the memory layout for it"
17:11:47 <kristof> Cale: oh, alright :/
17:12:21 <Cale> But that was *waaaaay* back. Even GHC 0.29 is written in Haskell
17:12:35 <hpc> kristof: the origin of my nick must be earned ;)
17:13:16 <Cale> Hugs was written in C
17:13:26 <dagnachew> Cale, know I get this error http://pastie.org/8684020
17:13:40 <Cale> hdevtools: hdevtools is not executable!
17:13:46 <dagnachew> hpc, know I get this error http://pastie.org/8684020
17:13:56 <Cale> I know!
17:13:58 <Cale> hehe
17:14:14 <lukexi> dennda: ah, that's referring to an issue when *compiling* ghc-ios with ghc 7.6 rather than 7.8, but not when *using* ghc-ios. it all gets a bit confusing with all these levels of compilation : )
17:15:03 <jfischoff> lukexi: how seemless will the ghc-ios experience be when 7.8 is out?
17:15:05 <hakujin> does ghc-ios need objc to bootstrap? what about bindings to uikit?
17:15:23 <Cale> I wonder if anyone has a version of GHC older than 0.29
17:15:32 <dennda> lukexi: Yeah; Will there be binary distributions of the compiler for easier cross-compilation (i.e. should I just wait), or not?
17:15:53 <lukexi> jfischoff: it will be a separate binary
17:16:02 <Peaker> The first Haskell compiler was written by augustuss, when he grew suck of waiting for the GHC efforts to come to fruition, iirc :)
17:16:14 <lukexi> you'll just call it with arm-apple-darwin10-ghc (or i386-apple-darwin11-ghc for the iPhone simulator)
17:16:18 <Cale> Right, there was HBC
17:16:21 <jfischoff> lukexi: there will different version of GHC build for cross-compiling?
17:16:28 <Peaker> he took his LML compiler and tweaked it for a few months until it was a valid Haskell compiler, iirc
17:16:44 <lukexi> jfischoff yeah. you'll have to download a separate ghc binary.
17:17:01 <zacts> what is the advantage of compiling haskell into C when GHC builds binaries so well already?
17:17:03 <randomclown> Cale: is there anything I can use to see who put all the ARR_WORDS on my heap?
17:17:20 <hpc> zacts: for architectures where ghc doesn't have a code generator
17:17:20 <randomclown> because just having a large chunck saying it's coming from bytestrings doesn't tell me anything
17:17:36 <hpc> zacts: (and where you can't go through llvm for whatever reason either)
17:17:41 <lukexi> hakujin: you can either launch your obj-c main from haskell, or call hs_init from obj-c
17:17:42 <jfischoff> lukexi: can't wait
17:17:50 <zacts> hpc: oh makes sense, thanks.
17:18:05 <Cale> randomclown: Which heap profiling mode are you using?
17:18:14 <Cale> -hd?
17:18:33 <hakujin> lukexi: what about access to the GUI framework? or I guess all of apple's frameworks? ffi or bust?
17:18:50 <lukexi> hakujin: bindings are very early. I am using a not-yet-public version of ObjectiveHaskell (i'll clean it up and release it soon) but there are other fantastic efforts underway, eg. language-c-inline
17:19:02 <dagnachew> hpc, Cale solved thanks for your time
17:19:18 <randomclown> Cale: none of them tell me anything, -hc tell me it's PINNED, -hd tells me ARR_WORDs
17:19:31 <hakujin> lukexi: godspeed! I would love to use haskell for primary ios dev
17:19:44 <lukexi> hakujin: language-c-inline should make all that magical : ) but we need to find a way to de-template-haskell-ize it until cross-compilers support TH
17:19:56 <jfischoff> lukexi: what are you binary sizes like?
17:20:05 <niez> codygman, http://lpaste.net/99283
17:20:29 <randomclown> There's also some wrap speed going on, I left it running for 5 minutes and RTS thinks it's only been alive for 10 seconds
17:20:31 <lukexi> hakujin: I use it as a "backend" in my project for doing lots of heavy lifting, and then just write my GUIs in ObjC as usual, to minimize my need for the FFI
17:21:09 <Cale> randomclown: hmm, maybe that's only mutator time or something
17:21:25 <hakujin> lukexi: does the threaded RTS work correctly? or do you still need GCD, et al?
17:21:27 <Cale> randomclown: PINNED is new to me
17:21:45 <lukexi> hakujin: threaded works perfectly : )
17:21:48 <jfischoff> lukexi: are you still using distributed process?
17:22:10 <lukexi> jfischoff: I'd have to check on binary sizes. I think we still need a fix for dead code stripping, once we have that it shouldn't be a big deal
17:22:16 <lukexi> jfischoff: yeah!
17:24:00 <Lemonator> so GHC's been on version 7.6.3 for 10 months now
17:24:11 <Lemonator> is there any news about the next iteration?
17:25:04 <hakujin> Lemonator: saw some talk about 7.8.1 release branch created; no idea on e.t.a.
17:25:23 <hpc> Lemonator: christmas of 2007
17:25:25 <hpc> https://developer.valvesoftware.com/wiki/Valve_Time
17:28:25 <dennda> lukexi: Yeah that's kind of how I'd see it used for some apps where it's applicable; business logic in hs and then gui in objc.
17:28:48 <Lemonator> also this channel seems a lot less active than when I used to visit over a year ago
17:28:51 <Lemonator> what gives
17:28:59 <dennda> lukexi: How do you do your interfacing? I will admit I have not looked at that port much, but I'm an iOS dev and have previously ported python so I'm somewhat familiar with the terrain
17:29:02 <hpc> Lemonator: everyone learned monads
17:29:11 <lukexi> dennda: yeah, it's a lovely marriage. but I'm also super pumped for some mad FRP openGL stuff driven by HS : )
17:29:13 <Lemonator> so
17:29:16 <Lemonator> it has come to this
17:29:50 <dennda> lukexi: I'm familiar with the GL, not so much with frp yet. I guess I'd have to look that up to see how that makes sense.
17:29:52 <Lemonator> we need the next "fundamental uncomplicated complicated thing that everyone needs to write a tutorial for"
17:30:52 <lukexi> dennda: ObjectiveHaskell just takes care of marshaling ObjC primitives (NSArray, NSDictionary, NSNumber, NSString, NSData, etc) into Haskell ones (Sequence, Map, Num, Text, ByteString, etc)
17:31:05 <lukexi> dennda: (and back again)
17:32:12 <hakujin> speaking of FRP: is reactive-banana still the current hotness? or is there another library that has quite a bit of attention these days?
17:33:24 <lukexi> hakujin: Stephen Blackheath, original creator of GHC iOS has a library called Sodium that he uses on iOS
17:33:41 <hakujin> lukexi: interesting, I'll check it out.
17:34:30 <simpson> Also netwire.
17:35:24 <lukexi> importantshock: you ready to get *all up in this* iOS haskell shit
17:36:46 <jle`> is there an efficient queue structure somewhere?
17:37:09 <Cale> Lemonator: Path induction
17:37:24 <simpson> jle`: Are you thinking of a doubly-linked list, or of a concurrency queue?
17:37:25 <defanor_> i'm using Network.Simple.TCP and reading data with recv (which uses Network.Socket.ByteString's recv), but looks like the program just hangs on recv when disconnect occurs (not a proper one, with TCP FIN, but a network disconnect). how could it be fixed?
17:37:45 <Lemonator> Cale: what, this? http://en.wikipedia.org/wiki/Induced_path
17:37:46 <Cale> jle`: Data.Sequence can do a decent enough job of a queue
17:37:47 <jle`> simpson: something in a single threaded context
17:38:03 <lukexi> if anyone is feeling adventurous re: ghc-ios there is a preliminary armv7/armv7s binary here https://github.com/ghc-ios/ghc-ios-scripts/releases . please let me know if you try it / need help doing so (this name @me.com is my email)
17:38:44 <jle`> Cale: thanks
17:38:47 <Cale> Lemonator: more like this: http://ncatlab.org/nlab/show/identity+type
17:38:48 <dennda> lukexi: OK. I'm not uninterested in trying it and providing some feedback once the time comes.
17:39:50 <Cale> Lemonator: Of course, out of context, that's a bunch of gibberish :)
17:40:18 <Lemonator> it is indeed gibberish
17:40:32 <Lemonator> as I have no experience with category theory
17:40:40 <Cale> Lemonator: It's something from homotopy type theory
17:42:05 <Lemonator> the notation on that page is selectable AND looks nice
17:42:13 <Lemonator> what is this sorcery
17:42:43 <Cale> One might wonder what the heck wikipedia is doing wrong
17:43:17 <Cale> and the answer probably has something to do with generating pngs
17:44:23 <randomclown> is 35 mb considered a large amount of memory for a haskell program?
17:44:30 <Cale> no?
17:44:41 <dwcook> nlab doesn't even require JS to look nice. It makes you wonder what a ton of other sites are doing wrong in that regard
17:44:46 <Cale> Depends on what it does
17:44:57 <randomclown> It's just a tcp server with 100 incoming connections
17:44:59 <Lemonator> randomclown: the question shouldn't be whether 35MB is "large"
17:45:22 <randomclown> I have no idea why it's using that much
17:45:24 <Lemonator> ask instead what the growth in memory use would be given larger inputs
17:45:50 <Cale> 35 MB is a trivial amount, at least to me
17:45:58 <Lemonator> try 1000 connections and if it stays within the 40MB range, you're fine
17:46:39 <randomclown> Lemonator: oh I was running at 1000 connections
17:46:44 <randomclown> mistyped
17:47:18 <Cale> okay, then try 10000 :)
17:49:47 <randomclown> looks like some connections started failing at ~5000
17:51:09 <randomclown> 50mb for ~1000-5000 connections is decent for me
17:51:32 <niotepx> Hey people..If anyone could help, I'd appreciate it: My cabal-install upgrade from 1.18.0.2 to 1.18.1.2 give me an install error, namely "cabal-install-1.18.0.2 depends on Cabal-1.18.1.2 which failed to install."
17:51:58 <niotepx> This is an i486 cpu.
17:55:25 <niotepx> Nevermind, problem solved.
17:59:24 <Cale> lolwut, 486?
17:59:38 <randomclown> that's not arch Cale's heard off
17:59:41 <randomclown> of*
17:59:53 <randomclown> jesus I can't type for some reason now
18:00:02 <randomclown> that's no arch Cale's heard of*
18:00:24 <Cale> I've heard of it, it just seems ridiculous to me that someone would still be trying to use one.
18:00:44 <randomclown> I'm fairly sure he meant i386
18:02:22 <simpson> The last 586 was the Pentium Pro.
18:02:32 <simpson> People nearly always mean 686.
18:14:54 <joey_> Is there a way to access the executable from a cabal file which my package depends on? I'd like to get the path of where it's installed so I can make calls to it using System.Process
18:15:23 <mm_freak_> joey_: import Paths_packagename
18:16:04 <joey_> Just that, exactly? I'm assuming I replace packagename with my pacakge name, does Paths stay the same?
18:16:08 <dcoutts> joey_: if you're asking what I think you're asking then no
18:16:22 <mm_freak_> it's autogenerated somewhere in dist/
18:16:37 <dcoutts> joey_: you mean your package depends on another one which provides not a lib but and exe, and you want to find out where that exe is installed so you can run it, right?
18:16:56 <joey_> @dcoutts that's exactly what I mean
18:16:56 <lambdabot> Unknown command, try @list
18:17:07 <mm_freak_> oh
18:17:08 <joey_> dcoutts that's exactly what I mean
18:17:33 <dcoutts> joey_: ok, then no, because we don't have to register exes, and so you can't tell if there're installed or where, unless of course you can find it in some other way
18:17:51 <dcoutts> joey_: you can make some guesses and follow conventions of course
18:17:57 <dcoutts> e.g. find it on the $PATH
18:18:02 <joey_> Yeah, makes sense. Thanks!
18:18:28 <dcoutts> or, plausibly, assume it's installed with the same bindir as your own package was configured to use
18:18:35 <dcoutts> with/in
18:19:06 <dcoutts> and that info *is* available via Paths_packagename
18:19:18 <dcoutts> but remember that's only information about how *your* package was configured
18:19:33 <dcoutts> and you're guessing that the thing you need may have been similarly configured
18:19:45 <dcoutts> joey_: but usual thing is just to expect it on the $PATH
18:21:28 <mm_freak_> alternatively you can use nix for development and deployment =)
18:23:40 <dcoutts> if you're in charge of the whole system then it's easy :-)
18:28:13 <jle`> is there anyway to list a package in a cabal file as only to be installed when not on Windows?
18:30:46 <alpounet> jle`: if os(windows) etc, see http://stackoverflow.com/questions/7456982/how-to-configure-build-dependencies-in-haskellcabal
18:33:18 <pingu> With +RTS -s output, does anyone know what Gen 0 and Gen 1 means?
18:33:30 <pingu> are these one of two parallel GC 'workers'?
18:33:51 <peddie> pingu: it's two generations in the generational garbage collector
18:34:14 <pingu> peddie: do you know where I can read more on how this works?
18:34:45 <peddie> pingu: I would start by googling "generational garbage collection" :)
18:35:24 <peddie> pingu: you could also probably find some tidbits about the specific GC in GHC on the GHC trac site
18:35:51 <peddie> @where trac
18:35:51 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
18:37:31 <pingu> peddie: so gen0 I presume is short term GC and gen1 is long term?
18:38:03 <pingu> Is the ptarallel GC work balance displayed below that between gen0 and gen1?
18:38:12 <jle`> alpounet: thanks :)
18:39:06 <Yep> hi, opinions? I see the following 2 conventions: newtype MyType a = MyType { getMyType :: a }; newtype MyType a = MyType { runMyType :: a }... are there any assumptions that are made depending on the naming, or is it just a personal choice?
18:39:09 <peddie> pingu: gen0 is the first generation, I think, yes
18:41:06 <Cale> Yep: personal choice. Usually you'll only see "run" if the intention is to think of the values of that type as computations of some sort rather than inert data.
18:41:28 <peddie> pingu: I don't know exactly what the parallel balance prints
18:42:32 <peddie> pingu: http://community.haskell.org/~simonmar/papers/local-gc.pdf I think is fairly up-to-date, but maybe someone else knows better
18:42:48 <Yep> Cale: Thanks
18:43:32 <shlevy> Hi, cabal sdist is failing because it can't find a generated module (which cabal configure puts in dist/build/autogen). Any ideas?
18:44:09 <shlevy> Note that this isn't my package (it's idris, FWIW) and travisci seems to be able to run cabal sdist fine
18:44:51 <pingu> peddie: thanks :)
18:45:52 <dcoutts> shlevy: try runghc Setup.hs sdist
18:46:19 <shlevy> dcoutts: testing...
18:46:34 <shlevy> Cool, worked!
18:46:35 <shlevy> Thanks
18:47:08 <jle`> is ther ea compiler flag to not warn on orphan instances?
18:47:39 <shlevy> dcoutts: I thought that was what cabal sdist did though :)
18:48:06 <peddie> jle`: '-fno-warn-orphans' I think
18:48:32 <jle`> peddie: thanks, that did it :)
18:48:38 <dcoutts> shlevy: historically no, because the Setup.hs sdist command line interface did not provide a way to produce an image dir ready to be tarred up, it only made a tarball directly.
18:49:11 <dcoutts> shlevy: so historically cabal-install did not call Setup.hs for sdist, which means it did not always work for custom build types
18:49:58 <dcoutts> shlevy: these days Setup.hs has a flag to create a src image dir, but I'm not quite sure if the latest cabal will now call Setup.hs
18:50:00 <peddie> jle`: no problem -- for reference, I just did 'man ghc' and searched 'orphan'
18:50:00 <shlevy> Ah so do I have an old cabal version?
18:50:34 <dcoutts> shlevy: I'm afraid I don't recall now if cabal-install is doing the right thing now, in a release or dev version
18:51:16 <shlevy> Cool, thanks! I'm assuming since the .travis.yml specifies running cabal sdist that it might work for newer versions
18:51:57 <jle`> peddie: thanks :) that definitely beats google
18:52:00 <jle`> heh
18:52:00 <jmcarthur> jfischoff: hey
18:52:59 <dhrosa> why can't hoogle find the control.monad module or anything relevant when I  search for monad?
18:53:18 <jmcarthur> jfischoff: ah, i see. it was all explained here
18:53:34 <dcoutts> shlevy: yep, quick look at the code, it's now doing the right thing
18:53:51 <frx> dhrosa search for `Monad' (uppercase)
18:54:20 <dhrosa> oh that's weird, if I use chrome to search using my hoogle shortcut, it lowercases everything
18:54:33 <dhrosa> but if I search uppercase Monad on hoogle  itself it works
18:55:30 <Yep> dhrosa: Double check that it's not autocompleting to an old search
18:55:44 <jfischoff> jmcarthur: yo
18:55:46 <Yep> dhrosa: I just tested in my Chrome and appears to work
18:56:22 <jfischoff> jmcarthur: I just read you other response
18:57:28 <jfischoff> jmcarthur: you finally forced me to gain a better understand of ~, with help from Twey
18:57:58 <jfischoff> s/understand/understanding
18:58:15 * jfischoff man do I wish I could do that on twitter
18:58:37 <ddere> hehe
18:58:39 <ddere> so do i
18:59:44 <bitemyapp> jfischoff: ~?
18:59:56 <jfischoff> lazy pattern matches
19:00:05 <jfischoff> I wrote a tip about them
19:00:32 <jfischoff> jmcarthur pointed out a subtle mistake I had bad related to them
19:00:45 <jfischoff> s/bad/makde
19:00:48 <jfischoff> bluh
19:01:25 <jmcarthur> huh, while i always had the intuition for it, i only just now realized that every Arrow can be a Functor
19:01:47 <Peaker> every Arrow can also be a Category+Applicative (and vice versa)
19:02:01 <jfischoff> bitemyapp: https://twitter.com/HaskellTips/status/428938124450729984
19:02:07 <jmcarthur> yeah, i guess i did know that
19:02:09 <Peaker> which is why Arrow in its current form is just a clumsy encoding of Category+Applicative, and not very useful
19:02:45 <jmcarthur> the only sort-of win for Arrow is its subclasses
19:03:03 <jfischoff> Peaker: what if you want ArrowChoice?
19:03:04 <jmcarthur> if only it didn't have arr...
19:05:06 <L8D> is (:[]) acceptable?
19:05:18 <scshunt> yes
19:05:30 <L8D> k
19:05:37 <L8D> > (:[]) 1
19:05:38 <lambdabot>  [1]
19:05:51 <jfischoff> > singleton 1
19:05:52 <lambdabot>  Not in scope: `singleton'
19:05:53 <lambdabot>  Perhaps you meant one of these:
19:05:53 <lambdabot>    `BS.singleton' (imported from Data.ByteString),
19:05:53 <lambdabot>    `BSL.singleton' (imported from Data.ByteString.Lazy),
19:05:53 <lambdabot>    `IM.singleton' (imported from Data.IntMap)
19:05:58 <jfischoff> eh
19:06:04 <L8D> (:[]) 'a'
19:06:05 <prophile> jmcarthur: what uses would there be for an Arrow without arr?
19:06:08 <L8D> > (:[]) 'a'
19:06:09 <lambdabot>  "a"
19:06:12 <L8D> hehehe
19:06:19 <external-reality> I am writing new refactories for structured haskell mode. I came across this instance
19:06:34 <jmcarthur> prophile: compilable DSLs
19:06:34 <external-reality> http://lpaste.net/99285
19:06:47 <external-reality> Can someone explain it to me.
19:07:02 <external-reality> why the undefined(s) and the {} brackets
19:07:03 <external-reality> ??
19:07:37 <prophile> jmcarthur: hm
19:07:53 <prophile> would this just be a category with products I wonder?
19:08:40 <L8D> external-reality: {} brackets are called braces
19:08:49 <bitemyapp> [] are brackets.
19:08:54 <external-reality> why thanks
19:08:57 <bitemyapp> {} are moustaches or braces.
19:09:08 <L8D> () are parens or parenthases
19:09:08 <bitemyapp> or curly brackets.
19:09:13 <bitemyapp> parentheses
19:09:25 <bitemyapp> ; is a semicolon
19:09:28 <bitemyapp> don't use semicolons.
19:09:31 <L8D> : is a colon
19:09:37 <L8D> use >> instead
19:09:39 <joey_> whoops, forgot about this window. Thanks for the help! Cheers.
19:10:08 <L8D> ' is a single quote or apostrophe(but not a true apostrophe)
19:10:25 <L8D> " is a double quote or a quotation mark.
19:10:34 <L8D> is a forward slasg
19:10:45 <L8D> '/' is a forward slasg
19:10:49 <L8D> '/' is a forward slash
19:10:59 <L8D> \ is a backward slash, or 'backslash'
19:11:21 <L8D> | is a pipe or a <insert name here>
19:11:35 <L8D> _ is an underscore or a low dash
19:11:45 <L8D> - is a minus sign or dash, or hyphen
19:11:51 <L8D> it should be called a hyphen
19:12:00 <external-reality> L8D: ...
19:12:20 <L8D> * is an asterisk or a star
19:12:33 <prophile> – and — are dashes, not -
19:12:39 <L8D> ~ is a tilda, or a squigly thing
19:12:52 <Cale> tilde
19:13:04 <L8D> ` is a grave mark, or a backquote
19:13:10 <L8D> tilde*
19:13:21 <L8D> # is a pound symbol, or a hash
19:13:22 <external-reality> whats is '...'
19:13:23 <Cale> Why are we enumerating the names of typographical symbols?
19:13:28 <prophile> # is not a pound symbol :|
19:13:32 <L8D> external-reality: ellipsis
19:13:33 <prophile> '...' is an ellipsis
19:13:50 <prophile> although it's more properly typeset …
19:14:07 <Cale> iirc, the intercal spec had interesting names for the characters
19:14:11 <L8D> prophile: how is # not the pound symbol?
19:14:17 <prophile> £ is the pound symbol
19:14:20 <L8D> lol
19:14:21 <prophile> # is a hash or an octothorpe
19:14:35 <L8D> did you live like 20 years ago?
19:14:55 <prophile> I'm over 20 if that's what you mean?
19:15:12 <L8D> do you live in europe?
19:15:32 <prophile> I do
19:15:56 <L8D> oh
19:15:57 <simpson> I live in the US and it's still not a pound symbol.
19:15:58 <Cale> I don't know why # is sometimes referred to as "pound"
19:15:59 <L8D> that makes sense
19:16:08 <Cale> But it is, specifically in the context of phones
19:16:11 <simpson> Sometimes I think of it as a sharp, although it's not quite the right character.
19:16:14 <L8D> https://en.wikipedia.org/wiki/Hash_symbol
19:16:18 <silasm> crunch
19:16:28 <theorbtwo> It's actually because £ is hard to slash into the side of a crate.  # is much easier.
19:16:28 <prophile> ♯
19:16:30 <L8D> Outside of North America the symbol is called hash and the corresponding telephone key is called the "hash key" (and the term "pound sign" often describes the British currency symbol "£")
19:16:42 <prophile> £ is much harder to play tic tac toe on
19:17:02 <L8D> # is also referred to as 'sharp'
19:17:06 <Cale> lol, the INTERCAL spec refers to # as a 'mesh'
19:17:11 <L8D> & is an ampersand or 'and'
19:17:23 <prophile> # is most certainly not a sharp, ♯ is a sharp :3
19:17:34 <prophile> hooray unicode
19:17:37 <prophile> (I'll shut up now)
19:17:39 <L8D> prophile: we're not talking about UTF-8 characters
19:17:50 <L8D> “”
19:17:59 <L8D> ………
19:18:11 <prophile> ♘
19:18:28 <theorbtwo> «ha!»
19:18:31 <L8D> ^ is a caret, or…and accent
19:18:34 <L8D> an*
19:18:41 <peddie> do you guys know about #haskell-blah?
19:18:48 <L8D> < is a less than symbol, or a left angle bracket
19:18:55 <L8D> peddie: we do
19:19:08 <mbuf> is there a recommended package in hackage for learning and experimenting on protocols above TCP layer?
19:19:34 <Cale> mbuf: network?
19:19:57 <mbuf> Cale: anything specific that you recommend that I can run like a TCP server?
19:20:12 <mm_freak_> mbuf: what exactly do you want to learn?
19:20:12 <Cale> http://hackage.haskell.org/package/network
19:20:20 <mbuf> Cale: just want to see how packet headers are defined and used
19:20:29 <mbuf> mm_freak_: ^^
19:23:05 <mm_freak_> mbuf: packet headers?  like IP packets?
19:24:48 <mbuf> mm_freak_: yes
19:25:38 * hackagebot damnpacket 0.2.0 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.2.0 (JoelTaylor)
19:25:45 <Cale> mbuf: You'd be better off reading RFC 793 or whatever if you're interested in what the packet headers look like
19:29:47 <mbuf> Cale: I am wanting to look at a Haskell implementation of an RFC
19:32:44 <Qett> fmap and map are the same for a list right?
19:33:32 <prophile> yes
19:33:54 <xplat> () are brackets or round brackets.  [] are square brackets.  {} are curly brackets.  <> are angle brackets.  \/ are slanty brackets.  «» are guillotines, avoid them.  @@ are swirly brackets.  ¿? are suspicious brackets.  ¡! are bang brackets.
19:34:24 <Qett> xplat: are those brackets all present in haskell?
19:34:29 <xplat> and db are bookends.
19:34:36 <prophile>    are ghost brackets
19:35:00 <xplat> prophile: i always forget about the ghost brackets.  out of sight, out of mind, as it were
19:36:37 <prophile> they can make programming in lisp much more interesting
19:37:23 <Qett> what dialect of list do you recommend to learn?
19:37:28 <Qett> i was thinking common lisp
19:37:51 <xplat> yeah, it really becomes and adventure.  then it gets split in three to fit on an 8-bit microcomputer and becomes a zork.
19:38:24 <Qett> wat
19:38:34 <xplat> if you want to actually get things done in lisp, but still want to learn something, common lisp
19:38:46 <xplat> if you're more interested in lisp as an esolang, scheme
19:39:08 <Qett> scheme is more academic?
19:39:38 <xplat> if you want to get things done but don't care how much you learn, elisp or clojure
19:40:12 <Qett> eh
19:40:45 <Qett> whats considered a bleeding-edge functional language besides haskell?
19:41:11 <prophile> idris
19:41:33 <xplat> yeah, idris is bleeding edge, still heavy on the bleeding last i checked
19:42:12 <xplat> disciple possibly bleeds even more, haven't tried it
19:42:16 <prophile> if the goal is to learn functional programming, ocaml may be more practical
19:42:18 <xplat> Eff maybe
19:42:55 <Qett> well im learning haskell and started reading a book on language theory that uses ocaml
19:43:00 <xplat> i'm not sure i'd even call ocaml bleeding edge though
19:43:20 <prophile> ocaml is current and practically useful
19:43:27 <xplat> way more so than sml though
19:43:29 <prophile> and functional
19:43:49 <prophile> could also look at clojure
19:43:58 <Qett> some ocaml people hate on haskell for some reason
19:44:02 <xplat> and it's probably more useful than any of the others mentioned except haskell.  can even be more useful thann haskell depending what you're doing.
19:44:05 <Cale> Qett: Agda, Coq
19:44:32 <prophile> or even javascript, which is basically scheme with c syntax, objects and horror beyond mortal comprehension
19:44:50 <Cale> (more functional programming languages which are worth checking out)
19:44:52 <AshyIsMe> haha
19:45:05 <AshyIsMe> horror beyond mortal comprehension
19:45:08 <simpson> JS isn't Scheme. JS is Self.
19:45:09 <Cale> AshyIsMe: ?
19:45:14 <Cale> oh
19:45:16 <mm_freak_> i wouldn't call agda and coq programming languages
19:45:23 <Cale> mm_freak_: why not?
19:45:41 <bitemyapp> simpson: JS is fucked.
19:45:43 <Cale> There are nontrivial things written in them even
19:45:43 <xplat> they're more theorem provers that you can write programs in
19:45:47 * bitemyapp mic drop
19:45:52 <mm_freak_> because programming with them is difficult…  they are mostly aimed at theorem proving
19:45:58 <simpson> bitemyapp: Once upon a time, there was Self. Ever wonder where JITs come from?
19:45:58 <Cale> Well, sure
19:46:31 <bitemyapp> simpson: you mean the magical fairy dust people that don't know systems think they can sprinkle on every performance problem when they're kicking hash maps all over their programs for no reason?
19:46:42 <bitemyapp> simpson: yeah, I'm familiar with them, but it's good to know who's responsible for it.
19:46:56 * bitemyapp scribbles something in red ink on a ratty old notepad
19:47:02 <Cale> But if you're interested in what the future of programming languages looks like, it's a pretty good bet that they've got some things right. :)
19:47:32 <Ralith> bitemyapp: hey, what data structure would you use to map message IDs to messages in a reliable unordered datagram protocol?
19:47:43 <prophile> mm_freak_: they are both turing complete
19:47:53 <mm_freak_> prophile: no, neither of them is turing-complete
19:48:04 <xplat> Ralith: a patricia trie?
19:48:11 <mm_freak_> you can't prove theorems in a turing-complete language
19:48:42 <simpson> Depends on your constant factors!
19:48:51 <xplat> mm_freak_: sure you can, you can even prove false!
19:49:08 <mm_freak_> xplat: well, in my view, if you can prove everything, you can't prove anything =)
19:49:13 <prophile> mm_freak_: interesting
19:49:14 <xplat> it's the not proving theorems you start having trouble with
19:49:22 <bitemyapp> Ralith: I was specifically referring to the needless use of hash-maps for data structures that are bounded and deterministic in their contents.
19:49:33 <mm_freak_> x : Even 3
19:49:34 <mm_freak_> x = x
19:49:35 <Ralith> bitemyapp: ah, yes, that's pretty terrible
19:49:36 <bitemyapp> Ralith: have you *seen* Python, JS, Clojure, or Ruby code anytime recently?
19:49:40 <bitemyapp> it's horrifi.
19:49:42 <bitemyapp> horrific*
19:50:01 <mm_freak_> or in agda…
19:50:05 <Ralith> xplat: that's what I'm planning on moving to if hash map lookup ever shows up in profiling
19:50:07 <mm_freak_> proof-that : 3 is-even
19:50:10 <simpson> bitemyapp: You're lumping all of those together based on...key-value mappings?
19:50:13 <mm_freak_> proof-that = proof-that
19:50:13 <mm_freak_> =)
19:50:26 <bitemyapp> simpson: I do a lot of Python and Clojure at work, and for this specific complaint, yes I am.
19:50:41 * hackagebot fast-logger 2.1.5 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.1.5 (KazuYamamoto)
19:50:51 <simpson> bitemyapp: I do quite a bit of Python, and I don't see horrific Python code from Python people; I usually see it from Java people.
19:51:01 <Cale> bitemyapp: Yeah, they should be using binary balanced trees. Hashes are disgusting :)
19:51:05 <xplat> istr self did not use hashmaps for slot lookups, at least
19:51:12 <Cale> ;)
19:51:16 <simpson> xplat: Correct.
19:51:17 <mm_freak_> simpson: depends on your standards…  to me every for/foreach-loop is horrific
19:51:50 <simpson> mm_freak_: To me, *PHP* is "horrific" and most other things are merely unfortunate at worst.
19:51:51 <bitemyapp> simpson: you're probably thinking of a different set of complaints.
19:51:56 <bitemyapp> I have many.
19:52:11 <simpson> bitemyapp: Probably! Also I happen to know, from a reading of dictobject.c, that dictionaries are not always hashmaps. >:3
19:52:14 <prophile> I do seem to recall that complaining about other languages is explicitly off-topic for #haskell?
19:52:15 <mm_freak_> simpson: fundamentally PHP is just a python with a lot more quirks =)
19:52:47 <simpson> That's almost infuriating, but you put a sarcasm mark at the end of your statement, so I'll take it as a joke.
19:52:55 <mm_freak_> prophile: it's difficult to prevent those discussions
19:53:00 <mm_freak_> it's about the only way to troll #haskell
19:53:08 <xplat> less than half the things that horrify me about software are ever likely to be solved by changing programming languages
19:54:22 <mm_freak_> simpson: well, it was sarcasm…  but it's not wrong…  remove all quirks, make the syntax match, replace inheritance by duck typing, and you've got python
19:54:53 <xplat> mm_freak_: remove php, add python, and you've got python?
19:55:19 <xplat> i suppose that's indeed true :)
19:55:26 <mm_freak_> to see it, you have to try to do something with python that is not provided by a ready-made library
19:55:40 <simpson> mm_freak_: Also fix the type coercions, fix some of the scope problems, fix the module system, fix the parser, add Unicode support, add a real FFI, etc.
19:56:05 <mm_freak_> xplat: no, you do not remove the imperative OO stuff
19:57:14 <xplat> mm_freak_: but you have a different inheritance model, different error-checking conventions, and a different MOP
19:57:14 <mm_freak_> simpson: sure…  but in both you use about the same coding style…  obviously i would choose python over PHP, but i'd choose pretty much any functional language over both
19:57:25 <frx> python has plenty of scoping problems that need fixing
19:57:29 <codygman> I started with PHP and I agree that python is PHP without quirks with a harder deployment process.
19:57:36 <mm_freak_> xplat: you still have imperative OO with loops and branches
19:57:36 <codygman> well not without, but "with less"
19:57:52 <simpson> mm_freak_: "Functional" probably doesn't exclude Python. PHP doesn't have objects; Python has nothing but objects. You can't surmount that with any amount of syntactic spackle.
19:58:00 <mm_freak_> simpson: it does exclude python
19:58:11 <simpson> mm_freak_: Please, define "functional".
19:58:11 <mm_freak_> i can't sensibly fold a tree in python
19:58:42 <mm_freak_> simpson: PHP doesn't have objects?  what?
19:58:55 <Platz> installed lambdabot from github repo, when it starts up I get "Plugin.djinn: Djinn command failed: fd:8: hClose: resource vanished (Broken pipe)".  any ideas how to fix djinn?
19:58:55 <bitemyapp> simpson: functional definitely excludes Python. No free theorems, no catamorphisms, no TCO, it's friggin' garbage.
19:59:09 <bitemyapp> hope you like mutation.
19:59:09 <xplat> i do agree that 'functional' excludes python, it's a matter of intent
19:59:34 <codygman> bitemyapp: Hy with pypy is kind of functional'ish... at least it has TCO IIRC
19:59:37 <simpson> Right, I forgot how stupid this argument is. I'll shut up now.
19:59:47 <mm_freak_> i don't have a formal definition of "functional", but if i can't fold trees, the language simply isn't functional
20:00:01 <mm_freak_> because folding data structures is a functional idiom
20:00:10 <xplat> wow, this really is a good way to troll #haskell, it even trolled me
20:00:30 <randomclown> c++ is functional
20:00:46 <randomclown> you can fold trees if you really tried
20:01:06 <mm_freak_> you can "fold" trees as well with a highly complicated loop and a custom stack implementation
20:01:14 <mm_freak_> both in python and C++
20:01:15 <bitemyapp> codygman: Hy is another, different kind of "ugh"
20:01:22 <randomclown> 1st class functions
20:01:32 <mm_freak_> functions in C++ aren't really first class
20:01:32 <randomclown> is usually where I draw the line
20:01:42 <randomclown> mm_freak_: oh yea?
20:01:44 <prophile> let's change the subject
20:01:46 <prophile> I love
20:01:47 <prophile> categories
20:01:51 <mm_freak_> also by that standard PHP is a functional language…  but only since version 5.3 =)
20:02:18 <mm_freak_> but yeah
20:02:20 <mm_freak_> i love functors
20:02:22 <bitemyapp> prophile: me too
20:03:03 <prophile> in particular
20:03:03 <xplat> prophile: you sound like someone who loves distributors.
20:03:07 <prophile> natural transformations
20:03:09 <prophile> are excellent
20:03:13 <Clint> Platz: is djinn in lambdabot's PATH?
20:04:08 <mm_freak_> randomclown: to make this on-topic i won't refer to any certain language, but i think the way you handle data structures is an important aspect in determining whether a language is functional or not
20:04:09 <Platz> Clint: hmm I guess I thought it was statically compiled in with lambdabot-haskell-plugins
20:05:10 <mm_freak_> if your primary tool is not recursion and pattern-matching, but rather loops and if/switch-branches, then the language is rather nonfunctional (pun intended) =)
20:06:00 <prophile> mm_freak_: so that definition seems to me similar to "are statements a core part of the language"?
20:06:42 <mm_freak_> prophile: not quite, because that would make scheme nonfunctional
20:07:19 <prophile> a fair observation
20:09:24 <ski> bitemyapp : free theorems presupposes static types
20:09:41 <bitemyapp> ski: I see no problem here.
20:10:08 <ski> wouldn't that then make Scheme and Erlang not "functional" ?
20:10:36 <prophile> or indeed the untyped lambda calculus
20:11:26 <bitemyapp> ski: >:)
20:14:49 * ski injects some hygienic macros in bitemyapp's blood stream
20:16:20 <bitemyapp> ski: I prefer full, evil macros.
20:16:53 <pharaun> stateful globally mutating macros
20:17:00 <carter> hygienic macros are turing complete
20:17:21 <carter> i think oleg has a cute hack that lets you do that + violate hygiene
20:17:31 <carter> via writing hygienic macros in CPS style
20:17:31 <bitemyapp> carter: which makes their restrictiveness even more pointless.
20:17:36 <carter> eh
20:17:53 <carter> hygienic macros are a nice tool that covers most use cases for macros
20:18:08 <bitemyapp> I didn't like them, but I was a CL user.
20:18:49 <carter> http://okmij.org/ftp/Scheme/macros.html#dirty-macros
20:18:52 <carter> heathen
20:18:55 <carter> :P
20:19:34 <bitemyapp> carter: >:]
20:19:42 <bitemyapp> carter: I'm here for the power, not the safety
20:19:53 <carter> somtimes safety IS the power
20:20:25 <carter> bitemyapp: that is,
20:20:36 <carter> by knowing exactly what effects lurk
20:20:52 <carter> you can do many more clever hacks that will still give you the same answer
20:21:01 <carter> and have them also be hidden from the end user
20:22:00 * ski thinks it's useful to talk about both "expressivity" (power, if you will), and also "reasonability", of a language
20:22:06 <bitemyapp> carter: sure!
20:22:16 <carter> fact
20:22:17 <carter> like
20:22:32 <carter> one reason why i may write code that i'd only support with 7.8 onwards
20:22:40 <carter> is I think llvm-general and friends will now work in ghci!
20:22:57 <Ralith> have we still not confirmed that?
20:24:00 <ski> "reasonability" covers how each it is to reason about the language : how easy it is to check properties of pieces of code (including checking that invariants are preserved, and preconditions implying postconditions), and also how easy it is to refactor code
20:24:07 <ivanm> ski: is that when a language is reasonable in terms of how it's defined without making too many crazy decisions? :p
20:25:30 <carter> Ralith: GAG
20:25:31 <ski> ivanm : more or less. typically, one quickly runs into a trade-off between these two (expressivity and reasonability). the trick is to find the "right" abstractions and notions/concepts, that increase expressivity, without unduly lowering reasonability
20:26:09 <Ralith> carter: ?
20:26:19 <carter>  *GAHHHHHH
20:26:23 <carter> i need to test then
20:26:24 <Ralith> heh
20:26:35 <shackleford> ski: What's an example of a language too far on the "expressiveness" end of the spectrum?
20:26:47 <ski> e.g. insisting on proper laws on type classes in a factor for increasing "reasonability"
20:27:46 <ski> shackleford : hm, how about "anything with side-effects" ;)
20:27:51 <carter> power weight ratio is one way of thinking about
20:27:52 <carter> it
20:27:57 <ski> yes
20:28:47 <athan> Hey yall I gots a question
20:29:04 <ivanm> we may or may not have answers
20:29:08 <carter> "can i write my name on the eye a lady bug, and on the man on the moon"
20:29:09 <athan> How do you know if you're in a situation where a phantom type would solve the problem?
20:29:14 <carter> athan: when it does!
20:29:19 <carter> athan: show us examples
20:29:20 <ivanm> athan: experience ;-)
20:29:20 <carter> and we cn help
20:29:32 <carter> athan: i wish that was all i needed to solve my problems
20:29:33 <athan> :/
20:29:44 <carter> half my problems are figuring out the right way to do really crazy clever phantom types
20:29:59 <ivanm> athan: often it's when you want to set some kind of type inside code without actually passing that value in
20:30:10 <carter> athan: the fun part is, when you have really really clever phantom types, you can publish a paper.... I need to get around to writing one :)
20:30:10 <athan> Ahh! Thank you!
20:30:15 <ivanm> other times you might be trying to fudge around the kind requried for a Monad instance or something
20:30:21 <athan> creating a simulated type dependancy
20:30:30 <ivanm> yeah
20:30:31 <carter> well, actual type dependency :)
20:30:40 <carter> just no runtime cost to it
20:30:53 <carter> Ralith: holy crap does llvm-general-pure take a while tobuild
20:30:55 <athan> ahh okay
20:31:02 <Ralith> carter: yeah, kinda weird
20:31:23 <Platz> this is what I'm getting when I try to install djinn
20:31:30 <Platz> http://lpaste.net/99287
20:31:32 <athan> ivanm: Thanks for the help :)
20:31:33 <ski> hm, what's a good example of phantom types that don't either secretly want to be GADTs, or be a `proxy' thing ?
20:31:33 <carter> Ralith: i think thats worth a ghc ticket
20:31:56 <ivanm> athan: np
20:33:10 <carter> Ralith: I KNOW WHAT is the REASON
20:33:24 <carter> ski: they're differnet
20:33:29 <carter> sometimes the same
20:33:40 <Ralith> carter: oh?
20:34:21 <carter> the Constant and Instruction modules have huge case data types with record notation
20:34:26 <carter> and overlapping field names
20:35:11 <carter> hell i didn't even know you could do overlapping field names, maybe thats only when its the same data type?
20:35:23 <ivanm> yeah
20:35:29 <ivanm> different constructors, same field name
20:35:52 <ivanm> though unless you duplicate every single field in every constructor, you get partial functions
20:36:15 <ivanm> (and if you _do_ duplicate every field, then why not just add an extra field indicating which "constructor" you're using?)
20:37:35 <shackleford> Man, I'm not even good at Haskell, and I'm upset that I can't use it for my school projects.
20:37:40 <carter> Ralith: weird cabal: The package 'llvm-general' requires Cabal library version 1.18.0 but no
20:37:41 <carter> suitable version is installed.
20:37:52 <carter> i have cabal 1.18.1.3 installed...
20:38:47 <ivanm> :o
20:38:54 <ivanm> carter: did you just copy the binary from somewhere else?
20:38:57 <ivanm> ghc-pkg list Cabal
20:39:11 <carter>    Cabal-1.18.1.3
20:39:12 <ivanm> carter: unless it wants that precise version of Cabal...
20:39:19 <carter> i can't see how it does
20:39:35 <carter> https://github.com/bscarlet/llvm-general/blob/llvm-3.4/llvm-general/llvm-general.cabal
20:39:50 <ivanm> I'm looking at the released version on hackage, and it just says it needs >= 1.8
20:40:01 <ivanm> check with verbose output to see if it says any more?
20:40:21 <carter> Using external setup method with build-type Custom
20:40:21 <carter> creating dist/setup
20:40:21 <carter> Using Cabal library version 1.18.0
20:40:21 <carter> Using ./Setup.hs as setup script.
20:40:22 <carter> Setup executable needs to be updated, compiling...
20:40:23 <carter> cabal: The package 'llvm-general' requires Cabal library version 1.18.0 but no
20:40:24 <carter> suitable version is installed.
20:40:40 <ivanm> oh, maybe it's something weird in the Setup.hs?
20:41:30 <ivanm> nothing obvious there in 3.3.8.2 ...
20:41:52 <carter> ivanm: are you on 7.8?
20:41:54 <carter> i'm on 7.8
20:41:57 <ivanm> nope
20:41:59 <carter> wel the rc
20:42:02 <ivanm> and I'm not even trying to build it
20:42:07 <carter> ANYONE HERE ON 7.8 RC?
20:42:10 <carter> ivanm: are you on  amc?
20:42:12 <carter> *mac?
20:42:12 <ivanm> just digging around wondering why it's that specific about Cabal version
20:42:14 <carter> i have a built
20:42:16 <carter> *buld
20:42:17 <ivanm> carter: nope
20:42:24 <ivanm> 64bit GNU/Linux with 7.6.2
20:43:01 <cmears> Can someone tell me where "Data.List.maximum2" comes from (e.g. in this example: http://lpaste.net/99288)?
20:43:35 <enthropy> carter: I'm using a 7.7 that's probably the same as the 7.8 RC (not mac though)
20:43:43 <carter> yes
20:44:02 <ivanm> cmears: could be core is just doing some renaming
20:44:11 <carter> enthropy: if you could try installing llvm-general
20:44:21 <carter> do you have cabal 1.18 and cabalinstall 1.18?
20:45:33 <cmears> ivanm, I noticed that the symbol "maximum2" does appear in Data.List.o from GHC's source; maybe it's just something introduced during the compilation of Data.List
20:46:40 <Yep> Is the use of undecidable instances commonplace or is it considered bad practice?
20:47:02 <carter> depends on the intenstance
20:47:14 <carter> it may be deciable or not, ghc just can't decide sometimes
20:51:59 <athan> how can I find out the associativity of a random function in ghci?
20:52:32 <ivanm> athan: :info
20:52:51 <tertl3-laptop> hello
20:52:54 <Yep> carter: Thanks, so if GHC can decide and it seems to make sense in the scenario then it's usually okay practice? (e.g. It's not something that would be considered bad practice for a reusable module?)
20:53:06 <carter> Yep: depends
20:53:08 <tertl3-laptop> this new fpcomplete site is really nice
20:53:11 <carter> Yep: what are you wonderin gabout?
20:53:16 <carter> tertl3-laptop: what changed?
20:53:29 <tertl3-laptop> carter nothing changed
20:53:47 <tertl3-laptop> ive just found it really helpful
20:54:32 <athan> ivanm: Thanks man!
20:54:44 <ivanm> np
20:55:44 <tertl3-laptop> and its got Yesod inside :\
20:56:02 <carter> tertl3-laptop: install snap too!
20:56:32 <tertl3-laptop> ive been meaning to try snap
20:56:45 <tertl3-laptop> coildnt get it to work on this windows netbook
20:59:04 <ski> athan : s/function/operator/
20:59:12 <tertl3-laptop> the little tutorial on monads and applicatives is easy to understand
20:59:38 <Platz> fixed it.  had to remove "-optl-Wl" from ghc-options: in djinn.cabal and then it installed
21:01:31 <tertl3-laptop> carter i want to start my website with one of them but ive still got design decisions to make
21:02:06 <tertl3-laptop> like a portfolio/biography/blog
21:02:18 <carter> tertl3-laptop: solution: make it a static site and use hakyll
21:02:36 <carter> so its all just presentation and writing
21:02:37 <carter> no ops
21:02:42 <carter> also much more scalable :)
21:02:49 <tertl3-laptop> that makes sense
21:03:10 <pharaun> i use hakyll
21:03:14 <pharaun> it works great
21:03:37 <tertl3-laptop> whos a good host for this?
21:04:46 <relrod> tertl3-laptop: anywhere that can serve static html. :)
21:04:50 <carter> i use nearly free speach
21:04:51 <carter> prepay
21:04:52 <carter> nice
21:04:55 <carter> simple
21:04:58 <carter> also does dns and other things
21:05:08 <carter> prepay === you can plan your costs!
21:06:17 <pharaun> this maybe a silly question but i'm trying to figure out the best design for an api. I have a network protocol that the simplest implementation seems to be an event loop that calls callback, but i'm not a fan of that approach, i would like to make the api like haskell's own network/file api (event backed but thread-alike in its usage (aka blocking))
21:06:44 <pharaun> so I can have a loop that is like "send x" then later on "recieve y" and it'll block at till it has recieved data. I was thinking some form of mvar?
21:07:19 <carter> pharaun:hy arent you using the haskell api?
21:08:12 <athan> What does a tilda in a type signature mean?
21:08:13 <pharaun> oh i'm using the normal network api sure, just wondering how i could provide a layer on top that interpret the protocol and if some additional action needs to happen such as replying to pings it'll do it on its own
21:08:29 <Yep> Maybe I'm misunderstanding undecidable instances: I have a classtype "FromNOnce" where "instance (FormatTime t) => FromNOnce t" is considered an undecidable instance while "instance (FormatTime t) => FromNOnce (NOnce t) where" is not... why is this so? They both need to be derived in a similar way right?
21:09:11 <relrod> athan: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/equality-constraints.html
21:09:22 <athan> thanks!!!
21:10:27 <pharaun> carter: i guess i could do like protocolRecv which basically is a protocol specific reciever that uses the normal network sockets but just wondering how i could react to events that the protocol user wouldn't need to care about such as ping for ex
21:10:45 <carter> hrm
21:10:47 <carter> i have no idea
21:10:57 <carter> i just do math and help out on ghc a teeny bit
21:11:04 <pharaun> hehehe np :)
21:11:22 <pharaun> i guess i could spawn a thread on the init of the state or so and let that take care of that aspect
21:11:29 <carter> pharaun: honestly
21:11:32 <carter> choose a scheme that works
21:11:37 <carter> and then optimize it later
21:12:23 <pharaun> a loop + callback is the simplest tbh and i've done that, i just am wondering how/if i can't provide a nicer experience other than just callback hell
21:12:58 <carter> pharaun: good question
21:13:41 <pharaun> that is the simplest approach, just would like to try a nicer approach if one exists, if not i can probably live with it just seems nicer if i could duplicate the haskell's normal model of "event loop for i/o" yet useland is like threads
21:13:55 <Tehnix> hmm, is there a super neat way of converting a record into a list of [(name, value)] ?
21:13:56 <pharaun> i really enjoy that model so i was just trying to see how i could provide similar experiences :)
21:14:15 <carter> pharaun: probably
21:14:31 <ivanm> Tehnix: I doubt it
21:14:46 <ivanm> for starters, unless your record only contains fields of the same type, you'll have type issues
21:14:54 <pharaun> carter: yeah its possible, just trying to find examples or hints :) its probably just my google-fu failing me here, i'll eventually figure it out probably
21:15:04 <Tehnix> ivanm: luckily, it does
21:15:36 <ivanm> well, if you're not willing to write your own conversion function specific to your type, you'd probably need to look at TH
21:16:08 <tertl3-laptop> i think my cabal is broken
21:16:10 <Tehnix> hmm, I'll do that. Thanks though :)
21:16:12 <tertl3-laptop> on windowa
21:17:07 <carter> Tehnix: delete your .ghc/
21:17:14 <carter> and wipe your .cabal
21:17:21 <carter> and things may reborn anew
21:18:42 <ivanm> keep your ~/.cabal/config though!
21:18:51 <carter> :)
21:18:56 <carter> not always needed, but ture
21:21:06 <misterbee> Yep, I think your problem is "Paterson condition b." documented here:  http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-rules    "The assertion has fewer constructors and variables (taken together and counting repetitions) than the head"
21:21:07 <misterbee> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances
21:21:11 <tertl3-laptop> BAHHH windows so bad
21:26:09 <Yep> misterbee: Ohh, the condition fails since (t) might not be terminates where in my case NOnce proves it does? Is that the correct understanding?
21:27:54 <codygman> Is functional reactive programming similar to state machines?
21:29:40 <misterbee> Yep, "instance (FormatTime t) => FromNOnce t"  has 2 (constructor OR variable) in each side.  "instance (FormatTime t) => FromNOnce (NOnce t) " has 2 on the left and 3 on the right.  I am not well-studied in the type-checker, but I would wildly guess that the "LHS < RHS" (Paterson b) rule is because the type-checker moves from right-to-left, so strictly-decreasing expression sizes are guaranteed to terminate
21:30:21 <misterbee> Whereas, non-decreasing-size constraints don't:    "instance (FormatTime t) => FromNOnce t ;  "instance (FromNOnce t) => FormatTime t""  could cause a loop?
21:30:38 <misterbee> someone please correct me if I am wrong!
21:31:45 <dhrosa> is there a Control.Monad equivalent of foldl (>=>) ?
21:32:03 <ski> @type foldl (>=>)
21:32:04 <lambdabot> Monad m => (a -> m b) -> [b -> m b] -> a -> m b
21:32:43 <dhrosa> @type foldl (>=>) return
21:32:44 <lambdabot> Monad m => [b -> m b] -> b -> m b
21:33:57 <dhrosa> i'm basically looking for a monadic equivalent of iterate
21:34:01 <ski> @type (. return) . foldr (.) id . map (=<<)
21:34:01 <lambdabot> Monad m => [a -> m a] -> a -> m a
21:34:12 <vishnu> Hello
21:34:15 <tertl3-laptop> has anyone tryied to make a web based vim or emacs?
21:34:24 <johnw> dhrosa: that gets asked for fairly often
21:35:04 <vishnu> \part [dun dunn duunnnn]
21:35:25 <Yep> misterbee: Makes sense, I'm not sure I 100% understand how the rule works but I can see that the first instance might not terminate... Thanks, makes sense. That atleast means I don't have to use undecidable instances which is probably a good thing is it's not needed
21:35:39 <dhrosa> oo there's a Control.Monad.Loops, let's see whats in there
21:35:57 <levi> tertl3-laptop: There are a number of web-based editors with vi or emacs keybindings, but I don't know about fully-faithful clones.
21:36:38 <johnw> dhrosa: https://gist.github.com/8727049
21:36:45 <johnw> not sure how useful that's going to be, though, without using lazy I/O
21:37:23 <dhrosa> johnw: what do you mean?
21:37:29 <johnw> it won't terminate
21:37:58 <dhrosa> yes, this is fine, this is part of my program's main loop
21:38:19 <Yep> tertl3-laptop: I know this isn't exactly what you meant, but emacs runs under it http://bellard.org/jslinux/
21:39:37 <johnw> dhrosa: this one works lazily: https://gist.github.com/8727078
21:42:17 <johnw> dhrosa: I've put both functions in monad-extras, and uploaded version 0.5.6
21:43:12 <tertl3-laptop> howo can I fix my cabal
21:43:14 <tertl3-laptop> its broken
21:45:54 * hackagebot monad-extras 0.5.6 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.5.6 (JohnWiegley)
21:48:34 <jfischoff> johnw: I think bind should be in base. Its odd that there named versions of some operators but not others
21:48:47 <MorehouseJ09> having trouble with types when I'm using `take 2 ["test", "test", "test"]
21:49:00 <MorehouseJ09> My function signature is like makeList :: [String] -> [String]
21:49:07 <johnw> jfischoff: agreed
21:49:40 <MorehouseJ09> so in my pattern matched section, I'm trying to call `x : makeList $ take 2 xs`
21:49:55 <MorehouseJ09> but its giving me an error saying that its passing in [Char] instead of [String]
21:50:48 <qrada> has anyone here installed the mongoDB 1.4.4 library? It's weird.. it is the only lib i can't import. I have a cabal sandbox setup, everythng installs fine. I see it in the .cabal-sandbox directory etc.. I can use all of my other libs just fine.. For some reason when I import, it can't locate it at all
21:50:53 <qrada> any idea?
21:52:31 <dmj`> qrada: what editor are you using
21:52:42 <misterbee> Yep, I think UndecidableInstances is fine ... if your program compiles. If the compiler gives you a stack overflow, then that's probably a loop in your type logic . related http://stackoverflow.com/questions/10830757/is-there-a-list-of-ghc-extensions-that-are-considered-safe
21:52:59 <qrada> vim ? im trying to import it from ghci and by ghc'n my .hs, no luck
21:54:12 <dmj`> qrada: what does 'ghc-pkg check | grep mongo' give you
21:54:58 <dmj`> qrada: I mean 'ghc-pkg list | grep mongo'
21:55:59 <qrada> nothing ;/, however, it is listed here: ./.cabal-sandbox/lib/....Database/MongoDB..
21:56:14 <qrada> etc.. it seems somehow my cabal build isn't using the .cabal-sandbox directory perhaps
21:57:21 <dmj`> qrada: what does 'which cabal' tell you
21:57:54 <tertl3-laptop> version/
21:57:56 <tertl3-laptop> ?
21:58:13 <qrada> 1.18, latest
21:58:27 <qrada> 1.18.1.2
21:59:08 <qrada> ok hm.. maybe im just noobing out hard eh
21:59:40 <qrada> cabal build seems to have built it in ./dist/build/something/the_bin
22:00:14 <qrada> is there any way to ghci using whatever is built in the sandbox? and not in ~/.cabal? i think that's what tripped me up and confused me
22:00:18 <qrada> sorry, thanks for the help folks
22:02:13 <dcoutts_> qrada: use cabal build -v to see how cabal is invoking ghc
22:02:44 <Ymesio> I have a quick theoretical question: I you need to parse a JSON data structure in haskell, do you need to define a data structure replicating the JSON structure first?
22:02:50 <dcoutts_> qrada: and yes, just as you can say cabal build, you can say cabal repl  to get a ghci session
22:03:21 <dcoutts_> Ymesio: no, but it's often a good idea
22:03:22 <qrada> ya dcoutts_ that's what i did.. that revealed my  (non) issues
22:03:27 <qrada> ah nice
22:03:27 <qrada> !
22:03:28 <dcoutts_> ok
22:04:16 <qrada> didnt know cabal repl loaded the libs i needed from current sandbox, very helpful
22:04:19 <qrada> cool
22:04:48 <dcoutts_> qrada: it does exactly the same as cabal build, but with ghci rather than ghc --make
22:04:54 <dcoutts_> so you get the same environment
22:06:46 <dcoutts_> @ops can you kick AngryBeers please, abusive privmsgs
22:06:46 <lambdabot> Maybe you meant: pl oeis docs
22:07:00 * dcoutts_ swears it was @ops
22:07:09 <qrada> nice
22:07:54 <Ymesio> dcoutts_: So can I go with something like JSONDecode( '{..JSON..}') with just one line? Will it automatically infer the types?
22:08:10 <AngryBeers> dcoutts_ is just being racist
22:10:41 <Ymesio> Ops, accidentally closed the window
22:14:25 * AngryBeers splashes his jism in ymesio's face
22:16:30 <pavonia> @where ops
22:16:30 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
22:16:40 --- mode: ChanServ set +o johnw
22:16:46 --- mode: ChanServ set +o johnw
22:16:46 --- mode: johnw set +b *!~AngryBeer@110.208.139.5nil
22:16:46 --- kick: AngryBeers was kicked by johnw (Kicked)
22:16:47 <dcoutts_> pavonia: ah, thanks, I was forgetting what the command was
22:16:59 --- mode: johnw set -o johnw
22:18:02 <randomclown>  /msg chanserv op #haskell dcoutts_ ?
22:20:47 <dareTake> Could someone explain to me how this works?
22:20:51 <dareTake> return "WoM" >>= (\x -> [x,x,x])
22:21:15 <dareTake> => ["WoM","WoM","WoM"]
22:21:18 <johnw> well, you are using the list monad here
22:21:30 <johnw> so return "WoM" means ["WoM"]
22:21:36 <randomclown> different monads have different behaviour with >>=
22:21:49 <dareTake> Shouldn't it be "Wwwooommm"
22:22:09 <johnw> >>= in the list monad means to apply every value from the input list (left argument) to the function on the right, which must return a list.  So you end up with a list of lists which >>= will then concat together
22:22:09 <dareTake> i mean >>= is concat (fmap f xs)
22:22:33 <dareTake> and "woM' is ['W','o','M']
22:22:39 <dmj`> :t flip concatMap
22:22:40 <lambdabot> [a] -> (a -> [b]) -> [b]
22:22:41 <johnw> so, first you get [["WoM", "WoM", "WoM"]]
22:22:48 <joelteon> "WoM" >>= (\x -> [x,x,x])
22:22:49 <johnw> and then concat turns it into [["WoM", "WoM", "WoM"]]
22:22:52 <johnw> sorry, ["WoM", "WoM", "WoM"]
22:22:53 <joelteon> > "WoM" >>= (\x -> [x,x,x])
22:22:54 <lambdabot>  "WWWoooMMM"
22:23:19 <randomclown> yeah I don't see a problem here
22:23:22 <dareTake> huh?
22:23:56 <dareTake> um so return makes the difference?
22:24:00 <joelteon> yes
22:24:12 <joelteon> return "WoM" is ["WoM"]
22:25:07 <dareTake> if  "WoM" >>= (\x -> [x,x,x]) is "wwwooommm", shoudldn't return be the same thing but in a list?
22:25:36 <Cale> dareTake: xs >>= f means concat (map f xs)
22:25:53 <Cale> > map (\x -> [x,x,x]) "wom"
22:25:54 <lambdabot>  ["www","ooo","mmm"]
22:25:59 <Cale> > concat (map (\x -> [x,x,x]) "wom")
22:26:00 <lambdabot>  "wwwooommm"
22:26:50 <dareTake> return $ concat (map (\x -> [x,x,x]) "wom") :: [Char]
22:27:04 <dareTake> > return $ concat (map (\x -> [x,x,x]) "wom") :: [Char]
22:27:05 <lambdabot>  Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'
22:27:05 <lambdabot>  Expected type: [GHC.Types.Char]
22:27:05 <lambdabot>    Actual type: [[GHC.Types.Char]]
22:27:16 <dareTake> > return $ concat (map (\x -> [x,x,x]) "wom") :: [[Char]]
22:27:17 <lambdabot>  ["wwwooommm"]
22:27:20 <jle`> dareTake: it might help to remember that >>= is like "fmap then join/collapse"
22:27:37 <jle`> > Just 1 >>= (\n -> Just (n*2))
22:27:38 <lambdabot>  Just 2
22:27:51 <jle`> > fmap (\n -> Just (n*2)) (Just 1)
22:27:52 <lambdabot>  Just (Just 2)
22:27:57 <jle`> so first you fmap the function into the Just
22:27:59 <jle`> and then
22:28:01 <jle`> you collapse it
22:28:05 <jle`> > join (Just (Just 2))
22:28:06 <lambdabot>  Just 2
22:28:23 <jle`> > Just 1 >>= (\_ -> Nothing)
22:28:24 <lambdabot>  Nothing
22:28:33 <jle`> > fmap (\_ -> Nothing) (Just 1)
22:28:34 <lambdabot>  Just Nothing
22:28:41 <jle`> > join (Just Nothing)
22:28:42 <lambdabot>  Nothing
22:28:50 <jle`> fmap it in, so it's a double-layered thing
22:28:54 <dhrosa> johnw: cool :)
22:28:55 <jle`> and then smash it down, collapse it back to one later.
22:29:11 <dareTake> yea i understand that, but how is  return $ concat (map (\x -> [x,x,x]) "wom")  different from the first one ie "Wom" >>= (\x->[x,x,x])
22:29:11 <dhrosa> johnw: the monad-extras
22:29:29 <dareTake> > "Wom" >>= (\x->[x,x,x]
22:29:30 <watermind> is there any syntactic sugar in the works for co-monadic programming?
22:29:30 <lambdabot>  <hint>:1:23:
22:29:30 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:29:39 <dareTake> > "Wom" >>= (\x->[x,x,x])
22:29:40 <lambdabot>  "WWWooommm"
22:29:50 <jle`> so try...fmap and collapse.
22:29:54 <dareTake> > return "Wom" >>= (\x->[x,x,x])
22:29:55 <lambdabot>  ["Wom","Wom","Wom"]
22:29:58 <dmj`> dareTake: one is of type [Char], the other [[Char]]
22:30:01 <jle`> > fmap (\x -> [x,x,x]) "Wom"
22:30:02 <lambdabot>  ["WWW","ooo","mmm"]
22:30:11 <jle`> collapses into WWWooomm
22:30:20 <jle`> > fmap (\x -> [x,x,x]) ["Wom"]
22:30:21 <lambdabot>  [["Wom","Wom","Wom"]]
22:30:29 <jle`> collapses into ["Wom","Wom","Wom"]
22:30:41 <dareTake> ah ok
22:30:45 <jle`> and yeah, looking at the types help.
22:30:57 <dareTake> > return "Wom" :: [Char]
22:30:59 <lambdabot>  Couldn't match expected type `GHC.Types.Char'
22:30:59 <lambdabot>              with actual type `[GHC.Types.Char]'
22:30:59 <jle`> m a >>= (a -> m b)
22:31:14 <jle`> m a >>= (a -> m b)  ==== m b
22:31:18 <triliyn> watermind: there is syntax for it, though I think it might be an extension or something?
22:31:18 <jle`> :t (>>=)
22:31:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
22:31:22 <jle`> so
22:31:26 <jle`> in the case of "Wom"
22:31:34 <jle`> m is []
22:31:36 <dareTake> > return "Wom" :: [[Char]] >>= (\x -> [x,x,x])
22:31:36 <jle`> a is Char
22:31:37 <lambdabot>  <hint>:1:31: parse error on input `\'
22:31:41 <triliyn> http://www.cl.cam.ac.uk/~dao29/publ/codo-notation-orchard-ifl12.pdf
22:31:41 <jle`> so let's fill in the types
22:31:47 <jle`> m a -> (a -> m b) -> m b
22:31:48 <triliyn> At least, I think this is implemented somewhere
22:31:51 <watermind> triliyn: thank you
22:32:12 <jle`> [Char] -> (Char -> [b]) -> [b]
22:32:20 <dareTake> > (return "Wom" :: [[Char]]) >>= (\x -> [x,x,x])
22:32:21 <lambdabot>  ["Wom","Wom","Wom"]
22:32:21 <watermind> triliyn: even if it's not, just looking at it would be enough
22:32:24 <jle`> and our function we see that it's also
22:32:33 <jle`> [Char] -> (Char -> [Char]) -> [Char]
22:32:37 <jle`> cool.
22:32:37 <dareTake> kk, got it. Thnx for explaining it :)
22:32:45 <jle`> so for ["Wom"]
22:32:52 <jle`> m a -> (a -> m b) -> m b
22:33:00 <jle`> :t ["Wom"]
22:33:01 <lambdabot> [[Char]]
22:33:04 <jle`> m is [[]]
22:33:10 <jle`> er
22:33:14 <jle`> m is []
22:33:18 <jle`> a is [Char]
22:33:35 <jle`> so we have [[Char]] -> ([Char] -> [[Char]]) -> [[Char]]
22:34:06 <dareTake> yup , the return made all the difference :). Both the statements looked similar.
22:36:18 <jle`> one thing neat about haskell is referential transparency
22:36:34 <jle`> where you can substitute the function's body and full expansion for the function call
22:36:40 <jle`> and be certain that the end result is exactly the same
22:36:47 <jle`> this is not the case in most languages.
22:37:07 <jle`> so if instead of return "Wom", you substitute in ["Wom"], then it becomes a little clearer.
22:37:52 <Ymesio> dcoutts_: I'm sorry, I got disconnected, and could have missed your answer. My question was: is it possible in haskell to decode JSON in just one line, and how will the types be deduced in this case?
22:38:31 <td123> Ymesio: decode "json_here" :: Maybe Aeson.Value
22:38:34 <jle`> Ymesio: decodedJson = decode (my json string)
22:38:47 <Ymesio> Thanks
22:38:50 <jle`> does that count as one line?
22:38:52 <jle`> :)
22:38:59 <Ymesio> jle`:  Yes
22:39:06 <Ymesio> How will it know the types?
22:39:13 <jle`> of the values?
22:39:15 <Ymesio> yes
22:39:21 <jle`> aeson tries its best to follow the JSON specifications
22:39:35 <jle`> which give some rules about what is typed as what
22:39:46 <dmj`> Ymesio: http://hackage.haskell.org/package/aeson-0.7.0.0/docs/Data-Aeson-Types.html
22:39:47 <jle`> http://www.json.org/
22:40:31 <jle`> json is for the most part unambiguous...it doesn't distinguish between different types of numbers though so when you decode it you have to specify yourself i think
22:40:36 <Ymesio> jldmj, jle`  great, makes sense, thanks
22:40:38 <jle`> when you extract it
22:41:46 <jle`> i wonder why json standard doesn't accept hexadecimal literals
22:42:27 <randomclown> jle`: because of doubles
22:42:38 <randomclown> javascript has only floating point numbers
22:42:48 <Ymesio> jle`: I think it was made with simplicity in mind, so they decided to have minimum types
22:45:07 <Ymesio> So does haskell type system allow to create objects with any properties?
22:45:34 <Cale> Ymesio: not sure what you mean by that :)
22:45:35 <jle`> that makes sense
22:45:41 <jle`> the simplicity
22:45:54 <Cale> Ymesio: You mean JSON values specifically?
22:46:00 <jle`> can you elaborate on the objects thing?
22:46:35 <Ymesio> I mean just in generate, can I create an instance of an object with properties a = 1 and b = 2
22:46:46 <Ymesio> without defining a class
22:47:08 <jle`> if you mean like javascript objects...you can make Maps
22:47:11 <jle`> key-value maps
22:47:20 <jle`> the keys have to be the same type or wrapped around a type if they aren't
22:47:31 <jle`> javascript objects are maps
22:47:33 <randomclown> keys can be anything
22:47:58 <Ymesio> Can one value in a map be a string and another one be a number?
22:48:06 <randomclown> I meant in JS obviously
22:48:16 <randomclown> But Aeson wraps it
22:48:18 <Cale> Ymesio: If you define a type which captures those possibilities
22:48:43 <Cale> Ymesio: I mean, really the answer is "no", but you can always create a type with constructors for each of the cases.
22:48:57 <Cale> Ymesio: http://hackage.haskell.org/package/aeson-0.7.0.0/docs/Data-Aeson-Types.html
22:49:08 <Ymesio> Got it
22:49:09 <dmj`> Ymesio: depends on how you do it. data Val = A Int | B String, "Map String Val" is a type where the keys can contain either Int or String
22:49:10 <Cale> Ymesio: If you look at the Value datatype defined here, that's what's going on for JSON
22:49:16 <jle`> do you know about algebraic data types?
22:49:28 <dmj`> I mean values, not keys
22:50:12 <Ymesio> dmj`: Nice example, makes sense
22:50:33 <Ymesio> jle`: I'm going to look it up right now
22:50:59 <jle`> basically, you can have have any arbitrary 'sum' of types that you want
22:51:06 <jle`> but you'll always know explicitly what they can and will be
22:51:11 <Ymesio> Cale, thanks, got it
22:52:09 <Ymesio> jle`: What do you mean by sum> Can you give me an example?
22:53:21 <jle`> data IntOrString = IOSInt Int | IOSString String
22:53:25 <jle`> http://en.wikipedia.org/wiki/Tagged_union
22:53:35 <Ymesio> jle`: Got it
22:53:42 <jle`> so basically if i say something is an IntOrString
22:53:52 <jle`> that means that either an IOSInt Int or an IOSString String
22:53:54 <jle`> and when i use it
22:54:01 <jle`> i typically have to explicitly hhandle both cases
22:54:18 <Ymesio> That's a good approach
22:54:42 <jle`> did i say i? i meant you
22:54:45 <jle`> my english is off today
22:54:48 <Ymesio> :)
22:55:00 <jle`> :)
22:57:15 <Ymesio> randomclown:, dmj`: jle` Cale, Thanks for your answers guys, I'm actually impressed by amount of people willing to answer at 2AM
22:57:29 <randomclown> lol timezones
22:57:31 <Ymesio> Makes me want to learn Haskell
22:57:53 <Ymesio> randomclown: I know, but other rooms are usually dead at this time
22:58:14 <blaenk> this channel is one of the classiest in my experience
23:01:03 * hackagebot packer 0.1.3 - Fast byte serializer and unserializer  http://hackage.haskell.org/package/packer-0.1.3 (VincentHanquez)
23:02:05 <Ymesio> If any of you happen to have spare weekends and would like to work on some weekend project with  haskell please let me know, I'd love to learn. I'm mostly JS/HTML/CSS guy, would be also glad to share what I know.
23:02:28 <syllogismos> newType EitherRight a b = EitherRight (Either a b)
23:02:50 <kristof> Ymesio: Pick up Learn You a Haskell, and get reading.
23:03:02 <syllogismos> how does an instance of EitherRight for a functor looks like?
23:03:20 <dhrosa> !lyah
23:03:24 <dhrosa> @lyah
23:03:24 <lambdabot> Unknown command, try @list
23:03:25 <dmj`> Ymesio: check out www.snapframework.com
23:03:27 <dhrosa> :(
23:03:45 <syllogismos> instance Functor (EitherRight a) where
23:04:10 <syllogismos> fmap f (EitherRight (Left x)) = EitherRight $ Left x
23:04:11 <Ymesio> dmj`: Bookmarked
23:04:19 <syllogismos> is that wrong?
23:04:27 <randomclown> syllogismos: what's the type of f?
23:04:42 <dhrosa> Ymesio: http://learnyouahaskell.com/
23:04:52 <syllogismos> a -> b
23:04:54 <Ymesio> dhrosa, kristof: Bookmarked as well, thanks
23:05:40 <syllogismos> i should have used _ for f in that line
23:05:51 <kristof> Ymesio: Don't bookmark it, reeeead it. That's step one. Don't do any Haskell without going through that first.
23:06:10 <dmj`> syllogismos: true, but that won't cause a error
23:06:12 <syllogismos> fmap f (EitherRight (Right x)) = EitherRight $ Right $ f x
23:06:21 <randomclown> looks right to me
23:06:30 <randomclown> not sure why you want to have an extra wrapper around either though
23:06:58 <syllogismos> its from a type class exercise..
23:07:05 <syllogismos> from fpcomplete..
23:07:19 <syllogismos> its showing me an error
23:07:27 <dmj`> randomclown: I think he's going through the 20 intermediate haskell exercises
23:07:29 <dmj`> http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
23:07:36 <syllogismos> yeah
23:08:38 <Yep> is there a way to get this CPP macro to work?
23:08:43 <Yep> #define DEFINE_FROM_CLASS(NAME) \ class FromNAME a where; \     fromNAME :: Byteable b => a -> b;
23:09:05 <Yep> FromName and fromName dont get replaced :(
23:09:30 <dhrosa> Yep replace the NAME in the macro with ##NAME I believe
23:09:31 <apples`> you need to use ##, probably
23:09:41 <dhrosa> Yep: as in: class From##NAME
23:10:03 <Yep> dhrosa apples` : thanks!
23:10:06 <syllogismos> oh it is right.. the online editor gave me an error for a long time
23:10:19 <watermind> in category theory, what's the notation for the dual of μ (join)
23:11:04 <syllogismos> so i slept on it and woke up and asked here.. now its saying theres no error lol
23:11:20 <zett_zelett> watermind: What do you mean by the dual of μ?
23:11:33 <apples`> like extend in Comonad?
23:11:38 <apples`> er, duplicate i mean
23:12:07 <watermind> apples`: zett_zelett: yes, extend or co-join
23:12:27 <watermind> is there a standard category theory notation for it?
23:12:43 <apples`> mac lane uses delta
23:12:56 <watermind> cool! thanks apples`
23:15:32 <Yep> dhrosa apples` : I wasn't able to get it to work in GHC -     Invalid type signature: from ## State :: Byteable b => a -> b
23:15:57 <dhrosa> what does the macro look like?
23:16:04 <Yep> #define DEFINE_FROM_CLASS(NAME) \ class From##NAME a where; \     from##NAME :: Byteable b => a -> b;
23:16:04 * hackagebot cmaes 0.2.2 - CMA-ES wrapper in Haskell  http://hackage.haskell.org/package/cmaes-0.2.2 (TakayukiMuranushi)
23:17:41 <chrisdotcode> guys, what's the most elegant way to check if an item matches at least one element in a list? I came up with a few solutions, but none are idiomatic
23:17:59 <dmj`> :t any
23:18:00 <lambdabot> (a -> Bool) -> [a] -> Bool
23:18:22 <dmj`> > any (==1) [1..10]
23:18:23 <lambdabot>  True
23:18:39 <dhrosa> > any (==1) [1..]
23:18:40 <lambdabot>  True
23:20:08 <chrisdotcode> er, I tried that; so maybe I'm not explaining my problem correctly. I'm build a search from a query string. and the search parameter is either "all", "user", or "places". so I was trying to return which category it was supposed to search if any
23:20:36 <dhrosa> how much more expensive is it to build a list, then call take and drop to take a slice of it, rather than only building  the relevant parts of the  list  in the first place?
23:20:40 <chrisdotcode> so like I tried: any (== query) ["all", "user", "request"] , but that only gives you the bool back
23:20:51 <dmj`> :t find
23:20:52 <lambdabot> (a -> Bool) -> [a] -> Maybe a
23:20:59 <dmj`> > find (==1) [1..]
23:21:00 <lambdabot>  Just 1
23:21:15 <jle`> dhrosa: it's hard to say
23:21:24 <jle`> without the context of what you use it for eventually
23:21:31 <chrisdotcode> dmj`: thanks! but it's not in Prelude; where is it?
23:21:45 <chrisdotcode> @src find
23:21:45 <lambdabot> find p          = listToMaybe . filter p
23:21:56 <jle`> Ymesio: you can always feel free to stop by here and we'll be down to help :)
23:21:58 <dmj`> :i find
23:22:11 <dhrosa> sounds like that's in Data.List?
23:22:14 <chrisdotcode> dmj`: lambdabot doesn't work with :i. But I found it, it's in Data.List! thanks! :)
23:22:16 <dmj`> dhrosa: yes
23:22:31 <dmj`> chrisdotcode: coolness
23:22:49 <ivanm> chrisdotcode: there's always @hoogle to find a function
23:22:53 <ivanm> or the hoogle website
23:23:02 <ivanm> or install hoogle locally on your machine
23:23:16 <Yep> any ideas dhrosa?
23:23:28 <chrisdotcode> ivanm: I usually go to hoogle first (with a great local install :) ), but I was thinking in the wrong domain this time :)
23:23:36 <ivanm> ahhh
23:23:41 <ivanm> search by type sig!
23:23:55 <Ymesio> jle`: Hopefully I will
23:24:01 <dmj`> no lambdabot when you private message?
23:24:54 <ivanm> dmj`: there is...
23:25:11 <dhrosa> I'm making a microcontroller simulator, one command the user can use is to dissassemble a region of memory, and print it to  the screen. I  find it more elegant to dissassemble all the memory lazily and just take the parts I want
23:25:29 <dmj`> ivanm: when I PM someone else, he doesn't stick around
23:25:30 <dhrosa> but I think I've decided I'll just make my function take a start and end parameter
23:25:44 <ivanm> dmj`: lambdabot is a _she_ :p
23:25:46 <apples`> Yep, strange, not sure
23:25:59 <dmj`> ivanm: my bad :)
23:26:14 <ivanm> dmj`: but I have a separate tab open in xchat to lambdabot all the time...
23:27:05 <dmj`> ivanm: what about a 3 way chat w/ lambdabot
23:27:08 <dmj`> and someone else
23:27:13 <ivanm> does IRC allow that?
23:27:29 <dhrosa> that sounds like an irc channel?
23:27:36 <dmj`> everyone does it differnet
23:28:00 <dmj`> it would be a nice feature
23:28:20 <ivanm> except it's not in the spec...
23:28:36 <dhrosa> create a temp channel and invite the bot to it?
23:28:42 <dhrosa> (can you invite someone to a channel in IRC?)
23:28:58 <dmj`> ivanm: neither is lambdabot
23:29:18 <apples`> Yep, this worked for me: http://lpaste.net/99292
23:29:27 <ivanm> but to be able to have a three-way conversation on IRC requires that the IRC server and all clients (including bots) know how to respond
23:29:38 <ivanm> for lambdabot to be able to work on IRC, she just has to follow the IRC spec
23:29:55 <ivanm> dhrosa: for lambdabot you need a mod to authorise her to join a new channel I think
23:29:59 <ivanm> same with any other bot
23:30:20 <ivanm> otherwise, an invitation is "/msg foo join me in my new channel #bar for some good times" ;-)
23:31:12 <pavonia> there's also /invite
23:31:20 <ivanm> oh? wasn't aware of that one
23:31:22 <ivanm> *shrug*
23:31:37 <ivanm> but I recall from other channels being created that lambdabot needs someone to authorise her to join
23:34:40 <Yep> apples`: GOSH! But thank you :)!
23:34:57 <apples`> no prob
23:40:45 <vishnix>  /quit
23:43:51 <codygman> How do I compile something with -rtsopts in a cabal sandbox? I tried cabal install -rtsopts but that doesn't work.
23:44:28 <bitemyapp> codygman: change the cabal file mate.
23:44:45 <ivanm> codygman: you add it to the ghc-options field
23:44:55 <ivanm> (in the .cabal file as bitemyapp said)
23:45:15 <bitemyapp> maslow's hierarchy of problem solving
23:46:22 <codygman> bitemyapp, ivanm: Thanks
23:52:53 <fragamus> @pl nub $ tails <=< inits
23:52:53 <lambdabot> nub (tails <=< inits)
23:53:29 <triliyn> @pl head 5
23:53:29 <lambdabot> head 5
23:55:58 <fragamus> @pl (\x->nub $ (inits <=< tails) x)
23:55:58 <lambdabot> nub . (inits <=< tails)
