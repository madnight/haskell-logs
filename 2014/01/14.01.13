00:08:02 <dleedev> where's the best place to learn about using Arrow in Haskell??
00:11:57 <Aleksejs> dleedev, http://www.haskell.org/haskellwiki/Arrow_tutorial#An_Example could be starting point
00:12:14 <dleedev> Aleksejs: thanks, I'll take a look
00:13:19 * hackagebot sizes 2.3.1 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.3.1 (JohnWiegley)
00:13:19 * hackagebot hasktags 0.68.4 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.68.4 (MarcWeber)
00:17:14 <zRecursive> In https://github.com/kazu-yamamoto/mighttpd/blob/master/Config.hs, is it ugly to aadd "!" before each field of "data Option = Option {}" ?
00:19:43 <zRecursive> Can we make it default strict for each field ?
00:21:39 <piezoid> I think you can't.
00:23:07 <zRecursive> i think so. but it is not comfortable to see "!" all around the fields ...
00:23:15 * hackagebot language-bash 0.3.0 - Parsing and pretty-printing Bash shell scripts  http://hackage.haskell.org/package/language-bash-0.3.0 (KyleRaftogianis)
00:23:24 <piezoid> But if the record is only threaded with a Reader (and not State), Strict fields are not really necessary
00:24:14 <piezoid> laziness would be a problem only if you create (or mutate) a lot of records
00:26:15 * Codex_ implemented laziness in c++. ;)
00:30:26 <zRecursive> piezoid: i see. Laziness will cause many function calls ? If so, i would like to add "!" before each fields
00:30:52 <zRecursive> as https://github.com/kazu-yamamoto/mighttpd/blob/master/Config.hs does
00:32:19 <piezoid> zRecursive: I guessed that you have only one Config (or few) per server instance, and you don't mutate it
00:32:23 <tdammers> implementing laziness isn't difficult... but making it as transparent as Haskell does is somewhat trickier in most languages
00:33:29 <piezoid> zRecursive: in this case it won't cause a lot delayed evaluation
00:34:40 <zRecursive> piezoid: so "!" in Config.hs is NOT necessary ?
00:35:43 <mrack> I am struggling to write errorf function, that will be like printf but pass the resulting string to error. is this even possible? what would be the signature?
00:35:44 <piezoid> zRecursive: yes
00:35:59 <ALBerto> Hello to everyone. Is there anyone who can help me with the library "hmidi"?
00:36:01 <zRecursive> ok
00:36:53 <piezoid> zRecursive: the fields will be evaluated only once, even with laziness
00:38:01 <zRecursive> yeah
00:39:54 <piezoid> zRecursive: strictness is usefull for something like state (doing a lot of mutations), because laziness can accumulate delayed evaluation
00:41:07 <zRecursive> i see
00:42:49 <maybefbi> isn
00:44:04 <maybefbi> isnt a web application just a set of types with rest apis exposed for each method related to that type, and each method just has a prerequiste to satisfy before it runs
00:44:20 <maybefbi> the rest is just views that use the rest api
00:44:57 <maybefbi> so why cant we have a edsl that lets people do just that?
00:45:07 <dleedev> maybefbi: that's one way to build a web application, I guess
00:45:26 <dleedev> maybefbi: of course, there are web applications that don't use REST APIs at all
00:46:20 <maybefbi> yeah but the coders who work on both back and front end code in those cases, tend to screw up one of them
00:46:41 <maybefbi> the backend coders won't care about good CSS rules, and will just make a haystack of rules
00:46:41 <roboguy_> dleedev: how do you feel about monads?
00:46:53 <dleedev> roboguy_: pretty good
00:47:02 <roboguy_> dleedev: okay good. arrows are a generalization of monads
00:47:05 <simpson> Technically, if your Web stuff *isn't* REST, then you should reconsider using the WEb.
00:47:15 <dleedev> roboguy_: generalization of monads?
00:47:22 <dleedev> roboguy_: isn't Monad a generalization of monads?
00:47:28 <maybefbi> simpson, yeah
00:48:10 <c_wraith> Don't learn arrows because you think you have to.
00:48:23 <roboguy_> dleedev: I mean a generalization of Monad
00:48:36 <c_wraith> They're not used very much anymore, and generaly considered to be something of a misstep
00:48:41 <c_wraith> As far as design space
00:48:55 <dleedev> c_wraith: but don't a few popular libraries use them?
00:49:16 <c_wraith> dleedev: maybe 2, and there are alternative libraries with similar functionality that don't use them.
00:49:29 <piezoid> maybefbi: scotty is close to a declarative REST DSL imho
00:49:41 <roboguy_> I've never really seen a useful example of a non-trivial Arrow instance
00:49:53 <maybefbi> piezoid, will check it out now
00:49:54 <roboguy_> mostly, I just see people work with tuples using the (->) instance
00:49:59 <c_wraith> dleedev: I've been using haskell for about 4 years now, and haven't had to use any arrow-based library yet.
00:50:02 <jrmithdobbs> arrow just looks like someones abandoned thesis
00:50:07 <jrmithdobbs> tbqh
00:50:18 <dleedev> c_wraith: hm... OK
00:50:32 <dleedev> then what should I learn now that I've become pretty comfortable with monads?
00:50:45 <c_wraith> learn rank-n types
00:50:51 <dleedev> I went from functor, applicatives, monoids, alternatives, monads
00:50:59 <dleedev> c_wraith: do you have a link for rank-n types?
00:51:06 <c_wraith> or any of the other really useful type system extensions
00:51:17 <dleedev> what about HT?
00:51:27 <c_wraith> TH, you mean?
00:51:30 <dleedev> :)
00:51:35 <dleedev> yeah, TH
00:51:43 <dleedev> I think lens uses it?
00:51:53 <c_wraith> template haskell is handy, and there's a good bit to learn, but.. It's not the most useful subject
00:52:17 <c_wraith> It's just a library, more or less.
00:52:44 <jrmithdobbs> dleedev: start changing things in type/kind signatures that you think should work but always wondered why it didn't and investigate all those extensions ghc tells you about ;p
00:52:53 <c_wraith> the type system extensions provide ways of fitting more of what you mean into the type system.
00:53:45 <dleedev> btw, how much should I rely on ghc extensions?
00:53:59 <dleedev> is GHC the only viable haskell implementation?
00:54:10 <jrmithdobbs> non-js, yes basically
00:54:14 <roboguy_> I think just about everyone relies on some ghc extensions
00:54:16 <c_wraith> It's not the only one, but it has a huge market share
00:54:19 <dleedev> (should I throw all my eggs into the GHC basket?)
00:54:56 <dleedev> why doesn't haskell proper just absorb ghc extensions if they're so useful and common?
00:55:06 <c_wraith> It has absorbed a few
00:55:15 <c_wraith> The hard part is getting people to agree on things to add
00:55:57 <dleedev> are the extensions made my third-party, or by GHC core?
00:56:02 <dleedev> s/my/by
00:56:37 <c_wraith> But things like the rank-n types extension - that's general knowledge.  Even if you can't use them in your particular choice of language, knowing what they are and that you can't use them still makes it easier to think about things.
00:57:27 <dleedev> c_wraith: I think I read about rank-n types... that's the "forall" stuff, right?
00:57:38 <c_wraith> and extensions are part of GHC, but many of them are contributed by third parties and accepted by the GHC developers if they're good.
00:58:07 <c_wraith> ConstraintKinds and DataKinds are a couple recent extensions that I know were the result of external projects.
00:58:07 <zRecursive> How big is GHC developers ?
00:58:07 <roboguy_> dleedev: yeah, rank-n types is one of the extensions that uses forall
00:58:17 <roboguy_> this reminds me, I really need to learn about type families
00:58:37 <jrmithdobbs> c_wraith: both of those are pretty interesting, too
01:00:12 <zRecursive> Can i make `ghc -ignore-dot-ghci -e "import Foo" -e "..."` use the installed Foo module NOT the Foo.hs in current directory ?
01:00:19 <c_wraith> I was playing around with ConstraintKinds stuff recently. It enables some fun things, though it's a little unwieldy to work with.
01:01:47 <dleedev> c_wraith: what should I learn after rank-n types?
01:02:05 <c_wraith> dleedev: whatever you need to learn to do what you want to do.
01:02:41 <c_wraith> dleedev: write bits of code. try to express ideas. When you can't figure out how, that's when you should learn something
01:02:59 <dleedev> c_wraith: I guess I'd like to get my feet wet enough to be able to comfortably understand at least 10% of all the libraries available
01:03:23 <c_wraith> then pick a library, and figure it out.
01:03:31 <dleedev> c_wraith: my guess is that there are certain extensions, libraries, types, and concepts that are wide-spread and popular
01:03:53 <jrmithdobbs> dleedev: you've covered the majority really in the list above
01:04:02 <jrmithdobbs> anything else depends entirely on what you're trying to accomplish
01:04:56 <dleedev> jrmithdobbs: cool, I guess I'm ready to jump in :)
01:04:58 <pavonia> zRecursive: Maybe ``import "foo" Foo'' using the PackageImports extension
01:05:05 <c_wraith> holy crap.  My experimental ConstraintKinds code...  I can't even remember what problem I was solving.
01:05:40 <c_wraith> I remember I tested lots of things, they all worked - but I can't remember what they were.
01:05:42 <shachaf> ConstraintKinds is so expressive that it can express solutions to problems that don't even exist.
01:05:57 <dleedev> I'd still like to wrap up learning about what Arrow is, since I've already started and learned enough about it to understand it generally
01:06:15 <dleedev> roboguy_: what feature of Monad is Arrow generalizing?
01:07:31 <c_wraith> I really need to document my experiments
01:07:36 <dleedev> roboguy_: maybe something like: Monad is an Arrow that does ___. Arrow is not restricted to ___ like Monad.
01:08:57 <dleedev> c_wraith: I read the description of ConstraintKind and still don't quite get it
01:08:58 <roboguy_> dleedev: I kind of forgot actually, haha. Arrows are parametrized over both an input type and an output type and Monads are only parametrized over an output type. I'm sure it has something to do with that
01:09:26 <roboguy_> dleedev: I think they are somewhere between Category and Monad
01:09:52 <dleedev> roboguy_: that doesn't mean anything to me, since Category and Monad aren't on a linear scale in my mind
01:10:10 <c_wraith> dleedev: It just lets you use constraints in types themselves, not just to constrain types.
01:10:35 <c_wraith> dleedev: this is why arrows aren't used much. They are between category and monad, and yes, that makes little sense.
01:11:03 <dleedev> c_wraith: but in your mind, there is some linear scale where that does make sense?
01:11:18 <simpson> Huh? Arrows generalize functions.
01:11:19 <simpson> :t arr
01:11:20 <c_wraith> No.  It's just what they blend features from. It doesn't make sense as an abstraction
01:11:20 <lambdabot> Arrow a => (b -> c) -> a b c
01:11:31 <shachaf> Many things generalize functions.
01:11:39 <jtcwang> i have a type newtype Auto a b = Auto { stepAuto :: a -> (b, Auto a b) }
01:11:42 <jtcwang> (automaton)
01:11:51 <simpson> ^^ imagine: arr :: Arrow (~>) => (a -> b) -> a ~> b
01:11:52 <jtcwang> i'm trying to derive Show for it
01:11:54 <shachaf> Arrow is not a very good generalization as generalizations go.
01:12:00 <eazar001> c_wraith: when you say not used much, is it because arrows are confusing, or have some negative property?
01:12:14 <c_wraith> jtcwang: it's awfully hard to show a function.
01:12:34 <jtcwang> yeah hence why i'm stuck :P
01:12:34 <zRecursive> pavonia: What does ``import "foo" Foo'' mean ?
01:12:42 <shachaf> Auto is also called Mealy.
01:12:52 <jrmithdobbs> eazar001: they don't seem to have much use outside of toys
01:12:55 <pavonia> zRecursive: Import module Foo from package foo
01:12:56 <jrmithdobbs> afaict
01:12:58 <shachaf> (->) is also an instance of Profunctor and Category, for example. Those are good generalizations of some aspects of functionhood.
01:12:58 <eazar001> import package  Foo from package "foo"
01:13:02 <roboguy_> zRecursive: he is using the PackageImports extension
01:13:22 <zRecursive> no standard way ?
01:13:25 <eazar001> {-# LANGUAGE PackageImports -#}
01:13:32 <shachaf> jtcwang: It's awfully hard, and in particular it's impossible (in general).
01:13:34 <eazar001> jrmithdobbs: toys?
01:13:35 <fabe> hi anyone here that know hows why i cant use functions that expect class types like normal functions? http://lpaste.net/98405
01:13:54 <eazar001> jrmithdobbs: i think i know what you mean ... but can you elaborate anyway?
01:14:07 <dleedev> simpson: what is ~>?
01:14:15 <jrmithdobbs> eazar001: yes, as in toy problems, trivial tasks ... they look neat until you try and do anything with them, basically
01:14:22 <jtcwang> shachaf, it's part of the machines package (for state machines). I'm pretty sure there is a way to display it. (My approach is likely wrong)
01:14:47 <roboguy_> jtcwang: what do you mean by display it
01:14:50 <shachaf> Well, it depends on what you mean.
01:14:52 <eazar001> jrmithdobbs: does some inherent property of arrows, make haskell code any less robust?
01:14:58 <shachaf> What do you hope to have happen?
01:15:04 <jtcwang> roboguy_, deriving show typeclass for it. I have this function:
01:15:12 <jtcwang> sumFrom :: Double -> Auto Double Double
01:15:12 <jtcwang> sumFrom x = Auto (\dx -> (x, sumFrom (x + dx)))
01:15:20 <jtcwang> i want to display the current result
01:15:28 <c_wraith> jtcwang: http://hackage.haskell.org/package/machines-0.2.3.1/docs/Data-Machine-Mealy.html  no Show instance
01:15:31 <shachaf> You want a Show instance. What should show give you?
01:15:32 <jrmithdobbs> eazar001: less robust? no, less readable for not much gain? definitely
01:15:33 <roboguy_> jtcwang: display it in what form?
01:15:44 <jtcwang> just regular string. i want to know the current state
01:15:56 <shachaf> A regular string containing what? It's a function.
01:15:56 <roboguy_> jtcwang: that is completely impossible
01:16:05 <c_wraith> jtcwang: there isn't a current state. It's a function.
01:16:06 <eazar001> jrmithdobbs: i see; but of course you are speaking generally right? I mean it must have some use cases?
01:16:08 <roboguy_> if you mean what I think you mean
01:16:13 <piezoid> jtcwang: to compute a result you need an initial state
01:16:19 <c_wraith> jtcwang: it's like asking what the current state of (+1) is
01:16:29 <jtcwang> haha yeah
01:16:42 <jtcwang> i'm making some fundamental mistake here (in understanding)
01:16:43 <shachaf> It's not good, Eric. It's a gazebo.
01:16:49 <jrmithdobbs> eazar001: I said it earlier and wasn't entirely joking, the whole thing feels like an abandoned thesis/research project
01:16:52 <jtcwang> but i think i have an idea
01:17:07 <eazar001> jrmithdobbs: nvm, I think i'll just read up on it, i won't beleaguere the point
01:17:13 <dleedev> jrmithdobbs: so everything that you can do with an arrow, you can do without an arrow in a cleaner way?
01:17:15 <eazar001> thanks for your input though
01:17:18 <Hafydd> fabe: have you tried :: Test test => [test -> test]
01:18:03 <jrmithdobbs> dleedev: the few times i've thought i found a use for one i realize i was thinking backwards and refactored
01:18:06 <fabe> doesnt work as well Hafydd
01:18:12 <jrmithdobbs> dleedev: that make sense?
01:18:35 <dleedev> jrmithdobbs: not the part about "thinking backwards"
01:19:52 <zRecursive> :k (->)
01:19:53 <lambdabot> * -> * -> *
01:20:06 <piezoid> jtcwang: if your type is flexible enough you can feed in a symbolic AST (implementing Num in your case)
01:20:20 <Cale> Anything you can do with an instance of Monad you can also do without one.
01:20:31 <jtcwang> i figured it out i thinkl. I'll  post a code sample
01:20:34 <dleedev> jrmithdobbs: but I do get your point that you think proper thinking will help you avoid arrows
01:20:53 <dleedev> Cale: but Monad makes things cleaner
01:21:02 <eazar001> jrmithdobbs: i see, perhaps with time it will prove
01:21:04 <Cale> However, the Arrow class is a bit awkward for many of the things you'd initially think it would be good at.
01:21:10 <eazar001> improve***
01:21:36 <roboguy_> eazar001: I've never seen an good example of a use for a non-trivial Arrow instance. maybe it exists, but i've never seen one
01:22:00 <Cale> roboguy_: Well, have you seen stuff like Yampa?
01:22:01 <dleedev> Cale: what's something you would initially think arrows are good for?
01:22:04 <jrmithdobbs> dleedev: ya that's all I was saying
01:22:16 <dleedev> Cale: in other words, what is Arrow supposed to help you do?
01:22:47 <eazar001> roboguy_: would you say it's worth delving into atm?
01:22:48 <dleedev> all I see in Arrow is split, first, second, and unsplit
01:22:59 <Cale> dleedev: The key thing about Arrow, looking at it vs. Monad, is that its primary means of composition, (>>>) and (***) especially, all involve only values of a type that you have control over.
01:23:34 <Cale> This means that you can do things like inspecting the things being composed to simplify the constructed computation before running it.
01:24:12 <roboguy_> Cale: no I haven't
01:24:21 <c_wraith> oh!  I know what I was solving now
01:24:31 <Cale> However, the primary way that Arrow provides of wiring results between computations (in any fashion more trivial than putting them end to end or side by side), is arr
01:24:34 <Cale> :t arr
01:24:35 <lambdabot> Arrow a => (b -> c) -> a b c
01:24:36 <c_wraith> I figured out the purpose for my ConstraintKinds code
01:24:45 <dleedev> Cale: what's something you can do with Arrow that you can't with Monad?
01:24:51 <Cale> Oh, I should actually properly contrast (>>>) with (>>=) here
01:24:55 <Cale> :t (>>=)
01:24:55 <lambdabot> Monad m => m a -> (a -> m b) -> m b
01:25:02 <Cale> The right parameter to >>= is a function
01:25:21 <dleedev> :t (>>>)
01:25:22 <eazar001> right
01:25:22 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
01:25:32 <Cale> Functions are black boxes, essentially. You can't tell what a function does ahead of time, apart from applying it to its parameter and seeing what you get.
01:25:34 <eazar001> category?
01:26:04 <Cale> eazar001: yeah, Arrow is a subclass of Control.Category
01:26:34 <zRecursive> Cale: what does subclass mean in Haskell ?
01:26:46 <eazar001> he means typeclass
01:26:55 <roboguy_> zRecursive: in this case, class Category a => Arrow a where ...
01:26:56 <randomclown> is there a way to write case statement without writing _ placeholders for all the arguments
01:26:59 <Cale> I mean subclass, in the sense of type classes.
01:27:07 <Cale> and yeah
01:27:17 <eazar001> cale: sorry not trying to put words in your mouth [=
01:27:31 <piezoid> zRecursive: an Arrow have to be a Category in the first place
01:27:38 <Cale> It means that the class declaration itself is constrained, so that when you define an instance of Arrow, you're also required to provide an instance of Category
01:27:44 <zRecursive> I always think subclass is OOP concept ?  i see now
01:28:15 <Cale> and whenever you know that Arrow a, you then can infer Category a
01:28:29 <roboguy_> zRecursive: it is. this is not really the same concept exactly
01:28:45 <zRecursive> sure
01:29:00 <dleedev> Cale: you were trying to contrast Arrow with Monad, how >>= takes a function to the right
01:29:04 <Cale> yeah
01:29:07 <dleedev> and functions are essential black boxes
01:29:33 <Cale> dleedev: So, looking at the type of (>>>), you have two parameters which are both something "function like", but which aren't necessarily black boxes
01:29:38 <Cale> because they're of a type you control
01:30:02 <Cale> *However*, the reliance of Arrow on this arr primitive screws everything up again
01:30:28 <Cale> arr introduces a black box, essentially
01:30:30 <Hafydd> fabe: it works when you allow the type to be instantiated: http://ideone.com/X1LvaF
01:30:33 <Cale> :t arr
01:30:34 <lambdabot> Arrow a => (b -> c) -> a b c
01:30:58 <dleedev> Cale: it's a function, in essence?
01:31:00 <Cale> ^^ it lets you take a function (which you can't really inspect), and turn it into a computation of your type
01:31:34 <fabe> oh thank a lot Hafydd
01:31:35 <eazar001> :t arr
01:31:36 <lambdabot> Arrow a => (b -> c) -> a b c
01:31:41 <Cale> The problem isn't really that arr is there at all (you can usually live with having a black box here and there through which you can't really do any optimisations)
01:31:45 <eazar001> :t (>>>)
01:31:45 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
01:31:53 <fabe> was on my way to stackoverflow :D
01:31:53 <Cale> but the real problem is that as soon as you want to have something of type
01:32:02 <Cale> a (u,v) (v,u)
01:32:10 <Cale> Then you need to use arr
01:33:02 <Cale> (you tend to end up with a lot of arrows which manipulate pairs, because one of the primitives is (***))
01:33:05 <Cale> :t (***)
01:33:05 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
01:33:25 * hackagebot parsec3 1.0.0.7 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.7 (ChristianMaeder)
01:33:32 <Cale> This takes two arrows, and glues them side by side into an arrow which operates on pairs
01:33:53 <Cale> But all the wiring you end up needing, that's all done with arr
01:34:09 <roboguy_> I'm not totally sure why I assume this since I have hardly used either and they are both for different things, but I think in the back of my mind I always assumed Profunctor was a better function generalization than Arrow (whatever that means)
01:34:17 <Cale> and if you use the proc/do arrow syntax, that's going to stick 'arr' in between every pair of lines in your do-block
01:34:46 <Cale> So, you lose the main potential benefit of using Arrow, which was the ability to inspect your computations meaningfully before you ran them.
01:35:13 <dleedev> Cale: and there are no other benefits?
01:35:19 <Sonarpulse> do any map implementations allow lookup of value with key nearest given key?
01:35:42 <Cale> dleedev: Well, it depends. Maybe you just want your means of composition to look like that.
01:36:22 <Cale> dleedev: Arrow gives you a kind of language for describing circuit diagrams
01:36:24 <Cale> abstractly
01:36:37 <Cale> It's just that it has some bad features which betray this
01:36:47 <supki> Sonarpulse: Data.Map allows that with lookupGT/LT/GE/LE
01:37:02 <Cale> Another thing which is missing is that the original paper on Arrows explicitly rejected the law that:
01:37:02 <Hafydd> fabe: however, the type of l there is not truly polymorphic: if you tried to use it with another instance of Test, you'd get a type error. If you want to work with truly polymorphic values other than top-level functions, I believe you need the ExistentialQuantification extension.
01:37:15 <Cale> (f >>> g) *** (h >>> k) = (f *** h) >>> (g *** k)
01:37:42 <fabe> oh ok thanks Hafydd
01:37:59 <Cale> This is because Hughes wanted to be able to say that Arrow generalises Monad
01:38:03 <fabe> i think im just going to end up using polymorchic stuff its just to painfull
01:38:23 <fabe> seems its bolted on and not very usable
01:38:26 <Cale> But if this law doesn't hold, you can no longer think of things nicely in terms of circuit diagrams
01:38:26 <roboguy_> Cale: so that law doesn't hold?
01:38:27 <Sonarpulse> supki: thank you very much, I was looking at old docs and didn't see it
01:38:36 <zRecursive> Cale: you light up my thought, thx
01:38:47 <Sonarpulse> I ask because I need a data structure to hold visited/unvisited regions
01:39:02 <Sonarpulse> I think Map (start, end) will work
01:39:10 <Cale> So it really *ought* to hold, and we ought to flat out reject instances which don't have it.
01:39:43 <Cale> It doesn't hold for Kleisli, because the effects in g and h happen in the opposite order
01:39:46 <dleedev> Cale: wait, you said the original paper does *not* require that law
01:39:49 <Cale> yes
01:40:00 <Cale> It doesn't require that law, and it should have, in my opinion
01:40:11 <tellmeahaskell> morning!
01:40:22 <Cale> morning!
01:40:25 <jtcwang> here's my very simple automaton code
01:40:26 <jtcwang> http://lpaste.net/98408
01:40:33 <dleedev> Cale: so then it *shouldn't* hold for Kleisli?
01:40:33 <jtcwang> and commands in ghci
01:40:40 <dleedev> Cale: in your mind
01:40:50 <Cale> dleedev: It doesn't hold for Kleisli m, unless m is a commutative monad
01:41:00 <Cale> (and there are not many commutative monads)
01:41:01 <jtcwang> roboguy_, c_wraith
01:41:21 <jtcwang> i think i got the idea
01:41:44 <Cale> i.e. monads for which  do u <- x; v <- y; return (u,v)  is the same as  do v <- y; u <- x; return (u,v)
01:42:04 <Cale> i.e. monads where it doesn't matter what order the effects happen in
01:42:13 <dleedev> Cale: I see
01:42:42 <tellmeahaskell> can someone tell me what i'm doing wrong here?
01:42:42 <tellmeahaskell> http://lpaste.net/98409
01:43:07 <roboguy_> tellmeahaskell: you can't start a function name with a capital letter
01:43:17 <jle`> jtcwang: it prints 1 because your sumFrom creates a function that returns (1, something)
01:43:19 <roboguy_> for one
01:43:42 <jtcwang> jle`, yeah its the 'last state' pretty much
01:43:57 <tellmeahaskell> erm.... where do i start a function with a capital letter?
01:44:05 <roboguy_> X :: a -> Double
01:44:09 <roboguy_> ^ tellmeahaskell
01:44:21 <jtcwang> your X is like a getter function
01:44:26 <roboguy_> technically that's a method, but same thing
01:44:27 <killy9999> can I explicitly put a type annotation on data declaration in TemplateHaskell?
01:44:35 <killy9999> data Foo :: * -> *
01:44:37 <killy9999> fir example
01:44:40 <roboguy_> tellmeahaskell: you can't have any variables start with a capital letter either
01:44:44 <tellmeahaskell> oh, ok!
01:44:54 <jtcwang> tellmeahaskell, what are you trying to achieve
01:45:05 <jtcwang> tellmeahaskell, it seems like you're overcomplicating things slightly
01:45:14 <dleedev> Cale: is there a webpage that further explains these cons of Arrow?
01:45:24 <Cale> dleedev: Really, Arrow is struggling to be a formalisation of symmetric monoidal categories (perhaps with a small handful of additional operations, but it really should be broken up into smaller classes anyway)
01:45:34 <Cale> Not as far as I'm aware
01:45:44 <Cale> I'm just relating my personal experiences with it
01:45:49 <roboguy_> Cale: there isn't another type class that better represents that, is there?
01:45:53 <jle`> tribal knowledge
01:46:16 <Cale> I worked for a small startup called iPwn studios on an action RPG in Haskell using an arrow-y FRP library
01:46:49 <Cale> and we ended up replacing Arrow with our own class hierarchy and implementing our own source -> source desugarer for the proc/do syntax
01:47:14 <dleedev> Cale: is proc/do at the syntax level?
01:47:19 <tellmeahaskell> jtcwang, i'm trying to create working code to tell me the x and y coordinates of given points (and lateron, calculate the distance between two points)
01:47:31 <roboguy_> dleedev: there is an Arrow syntax extension
01:47:41 <Cradam> > ['Z'..'a']
01:47:42 <lambdabot>  "Z[\\]^_`a"
01:47:43 <Cradam> Oo
01:47:48 <dleedev> roboguy_: and it overloads the meaning of do?
01:47:51 <Cale> dleedev: See http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
01:47:56 <jtcwang> tellmeahaskell, let me write you something
01:47:56 <roboguy_> dleedev: no, it introduces "proc"
01:48:00 <Cradam> why is haskell pulling emoticons at me
01:48:13 <piezoid> Cale: what smaller classes ? category, profunctor, ..?
01:48:17 <jtcwang> i think you're a bit confused regarding type, class, data
01:48:19 <dleedev> roboguy_: so then do still means composition of monads?
01:48:27 * hackagebot http-client 0.2.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.2.1 (MichaelSnoyman)
01:48:28 <jtcwang> (hey, I'm pretty new too but i may be able to help)
01:48:34 <roboguy_> dleedev: I don't think it affects do-syntax in any way
01:48:41 <Cale> piezoid: arr should be in its own class, probably (&&&) should be as well.
01:48:44 <jtcwang> tellmeahaskell, http://lpaste.net/98409
01:48:44 <tellmeahaskell> jtcwang, not just a bit!
01:48:46 <tellmeahaskell> :D
01:49:19 <roboguy_> dleedev: well, it does what it says in the link Cale gave
01:49:27 <Cale> piezoid: and when we introduce swap :: a (u,v) -> a (v,u), that should also probably be in its own class
01:49:53 <tellmeahaskell> jtcwang, unfortunately i dont understand what your code does within the { } ?
01:50:13 <jtcwang> tellmeahaskell, think of it as a getter function
01:50:18 <Cale> Though it is useful to have a class "Arrow" which is a subclass of a good fragment of all the others.
01:50:36 <Cale> btw, what we came up with was almost a direct parallel of http://www.cs.berkeley.edu/~megacz/garrows/
01:50:53 <piezoid> Cale: ok, i see. i need to write down the law to see how they depends on each other
01:50:58 <jtcwang> its like
01:50:58 <Cale> but there were a few differences
01:51:07 <jtcwang> obj.getX
01:51:18 <piezoid> Cale: oh i loved his papers on hardware compilers
01:51:20 <jtcwang> in imperitive programming
01:51:22 <Cale> http://en.wikipedia.org/wiki/Monoidal_category if you look here
01:51:36 <jtcwang> so getX allows you to access a double
01:51:43 <jtcwang> and getY allows you to access another double
01:51:44 <Cale> and you think of A ⊗ B as (A,B)
01:51:48 <Cale> and I as ()
01:51:54 <dleedev> Cale: what's a library that gets closest to getting good use out of Arrows?
01:52:13 <tellmeahaskell> phew... would you say i should try a different approach to write this, or would or rather say i just need to fix this code a bit?
01:52:41 <Cale> Then the data which are part of a symmetric monoidal category, especially the associator α, and the left/right unit maps λ and ρ, are what Arrow needs.
01:52:54 <Cale> dleedev: Yampa
01:53:05 <jtcwang> tellmeahaskell, yes because for your use case you don't need 'class' or 'type'
01:53:13 <jtcwang> as far as i'm aware
01:53:14 <zipper> Could you guys help me out with my fizzbuzz implementation that I can't seem to get right in Haskell
01:53:17 <zipper> https://gist.github.com/urbanslug/8397284
01:53:21 <Cale> Or more modern, netwire
01:53:43 <tellmeahaskell> jtcwang, my 'problem' is that i need/want to use data to create Point
01:54:10 <jtcwang> tellmeahaskell, a point is a coordinate no?
01:54:25 <tellmeahaskell> so i looked up some examples of how data is used in haskell, and tried to emulate the idea
01:54:31 <Cale> http://hackage.haskell.org/package/netwire-5.0.0/docs/Control-Wire-Core.html#t:Wire -- you'll notice, it has a nice Arrow instance
01:54:36 <tellmeahaskell> sure. but thats just a matter of semantics, isnt it?
01:54:48 <jtcwang> ok let me put it this way, data is like
01:54:58 <jtcwang> class in python or other languages
01:54:59 <tellmeahaskell> whether i call it Coordinate or Point doesnt really matter, i could also switch Coordinate to Point
01:55:10 <dleedev> Cale: jrmithdobbs tells me netwire is useless because libraries it depends on don't exist yet
01:55:11 <quicksilver> Cale: what happened to ipwn in the end? just ran out of money?
01:55:13 <jtcwang> ok let's call it Coordinate for now
01:55:22 <Cale> quicksilver: yeah
01:55:31 <jtcwang> what i just gave you before is called a record syntax
01:55:44 <tellmeahaskell> data seems unintuitive for this use! data makes sense when putting several 'things' into the same data type. like geometrical formes with different properties
01:55:51 <jtcwang> let me write it in a more verbose format for you
01:55:58 <jtcwang> as shown in here: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
01:55:59 <quicksilver> Cale: :( I guess that's the nature of small companies with cool ideas.
01:56:15 <zipper> Anyone please https://gist.github.com/urbanslug/8397284
01:56:19 <roboguy_> tellmeahaskell: you are putting two coordinates into the same type
01:57:16 <skypers_> ohai
01:57:33 <Cale> quicksilver: It was interesting and I learned a lot of stuff, so I don't feel too bad about it. (Also I was paid, though it would have been nice to actually sell something, as I would have made a portion of the profits.)
01:57:35 <merijn> Cale: I saw a neat SQL DSL library using arrows at NL-FP friday too, although they too suffer from the "arr sucks" problem
01:57:48 <tellmeahaskell> man i dont get this at all ._.
01:57:56 <jtcwang> tellmeahaskell, http://lpaste.net/98409
01:58:14 <jtcwang> more verbose, this should help you see what record syntax is doing
01:58:32 <Cale> jtcwang: you left out constructors!
01:58:35 <jtcwang> its ok, i'm still totally clueless too
01:58:54 <roboguy_> Cale: any plans to write up your experiences working with haskell for a big commercial project?
01:59:38 <piezoid> merijn: "arr sucks" means that you can't hide the real data ?
01:59:45 <tellmeahaskell> just to be sure. by typing :: i tell haskell "this is a function with the following input and output" and then the second line tells haskell how to create the output from the input it gets
01:59:48 <tellmeahaskell> correkt?
01:59:48 <jtcwang> haha Cale, silly me. I should stop giving ppl bad code :P
01:59:51 <tellmeahaskell> *correct?
01:59:52 <Cale> tellmeahaskell: http://lpaste.net/98413
02:00:10 <skypers_> I’ve been wondering, is Haskell really good to handle side effects? I mean, I’ve been using Haskell for almost two years now, and I think some hindsight is never wasted. Haskell is pure but lets you deal with side-effects – does it do it the right way? I mean, OCaml lets you make side-effects as well, without monads. Why would monads be a better candidate to side-effects? what do you think folks?
02:00:18 <Cale> roboguy_: It would be a good idea especially to write up the stuff about Arrow
02:00:33 <roboguy_> Cale: I'd be very interested to read it
02:00:35 <merijn> piezoid: "arr sucks" means that you *have* to implement a way to convert arbitrary functions into your type of arrow, thus losing any nice things you encoded in them as the function doesn't have them
02:00:45 <tellmeahaskell> jtcwang, where does the "Pt" come from?
02:00:48 <Cale> skypers_: I think Haskell does a better job than most languages at handling *effects*
02:00:56 <skypers_> why?
02:01:04 <Cale> skypers_: (I don't like calling them side effects, when they're not really off to the side any more)
02:01:05 <jtcwang> tellmeahaskell, what Pt?
02:01:10 <tellmeahaskell> in the code you linked
02:01:18 <skypers_> ok Cale
02:01:19 <tellmeahaskell> "data Point = Pt Double Double"
02:01:20 <jle`> skypers_: haskell's way of handling impure functions really has nothing to do with monads
02:01:26 <merijn> piezoid: This specific library got around by having "Foo (Bar a) (Bar b)" be the arrow where Bar was a datatype without exposed constructor so that constructing "Bar" was impossible (effectivelly stopping you from using 'arr'
02:01:30 <Cale> skypers_: Well, you've been using Haskell a while, so you probably know about STM
02:01:33 <tellmeahaskell> oh! cale postet that, sorry!
02:01:39 <tellmeahaskell> Cale: Where does the "Pt" come from? :D
02:01:45 <skypers_> yes Cale
02:01:49 <Cale> tellmeahaskell: the data declaration introduces two things:
02:01:50 <skypers_> I use it in my FRP library
02:01:57 <Cale> A new type called Point
02:02:02 <merijn> skypers_: Fun fact, Haskell hasn't always used monads for side-effects
02:02:04 <skypers_> it’s really great, but I’m not talking about concurrency
02:02:07 <Cale> and a new way of making values of type Point called Pt
02:02:16 <merijn> skypers_: They were added later when people realised that monads were a really nice way to handle them
02:02:19 <Cale> Pt has two Double parameters
02:02:25 <Cale> and produces a Point as its result
02:02:31 <Cale> i.e.
02:02:33 <merijn> skypers_: Also, OCaml isn't a pure language, so naming it as an example is rather counter productive
02:02:34 <skypers_> merijn: I see
02:02:37 <Cale> Pt :: Double -> Double -> Point
02:02:38 <tellmeahaskell> Cale: May these two be named different? Or is this stupid to do?
02:02:41 <jle`> skypers_: 'is this a good way to handle this issue?  excluding a large domain where this issue is relevant.'
02:02:44 <jle`> :)
02:02:47 <Cale> tellmeahaskell: Which two?
02:02:54 <skypers_> I don’t know jle`
02:02:57 <skypers_> just wondering
02:02:57 <tellmeahaskell> Point and Pt in your example
02:03:04 <Cale> Point and Pt are in completely separate namespaces, because Point is a type, and Pt is a value
02:03:06 <jle`> concurrency is a big deal (tm)
02:03:11 <dleedev> merijn: how was IO handled in Haskell before the IO monad?
02:03:14 <Cale> We can name them the same thing
02:03:20 <skypers_> I have encountered some issues with Haskell
02:03:30 <skypers_> and it was very tricky to get around
02:03:36 <Cale> But I chose to name them differently because it's easier to explain things without confusing them then
02:03:38 <tellmeahaskell> In your example, Point is the blueprint and Pt is a certain object created by this blueprint?
02:03:44 <Cale> Point is a type
02:03:55 <Cale> Pt is a data constructor which makes values of that type
02:03:56 <merijn> dleedev: Essentially by treating a program as a "[String] -> [String]" function, where the first was a list of input strings and the second the list of outputs. I'm not sure whether there were other approaches before/after that
02:04:09 <merijn> dleedev: I think monads weren't added until after Haskell 1.4?
02:04:20 <merijn> But I'm not 100% sure about all the history
02:04:22 <Cale> I could also, using somewhat newer syntax that you'd need to turn on compiler extensions for, write the data declaration like this:
02:04:22 <dleedev> merijn: IO monad, or monads in general?
02:04:22 <skypers_> a few days ago I designed a module that helps me send haskell algebraic lists to C
02:04:25 <jle`> Haskell's IO handling is not really best explained as monad-based, but rather composition-based.  You work by composing instruction 'objects'.
02:04:29 <skypers_> in C++ or C, it would be very simple with a void*
02:04:33 <merijn> dleedev: Monads in general (including the IO monad)
02:04:34 <skypers_> in Haskell, it’s a pain in the ****
02:04:36 <Cale> data Point where Pt :: Double -> Double -> Point
02:04:48 <jtcwang> tellmeahaskell, the whole (Pt x y) is your Point object
02:05:02 <c_wraith> jle`: monads are a composition abstraction.
02:05:03 <Cale> Thus, we can make points such as  Pt 1 (sqrt 2)
02:05:07 <skypers_> I’m not whilling because it’s the type system that restricts that – and it’s a good thing
02:05:12 <c_wraith> jle`: composition is all monads do
02:05:15 <dleedev> merijn: so in the [String] -> [String] era, are you talking about STDIN -> STDIO?
02:05:40 <Cale> and Pt (pi^2 / 6) 1
02:05:42 <jrmithdobbs> skypers_: rust is interesting to me for that reason
02:05:45 <jtcwang> tellmeahaskell, with your function, you're doing pattern matching and data binding
02:05:54 <Cale> tellmeahaskell: Does that make sense?
02:05:58 <skypers_> but making an array of floats AND ints or an array of floats, or just ints, or just doubles and floats – is a very simple task to do in C
02:06:05 <Cale> tellmeahaskell: In addition, Pt is a little more than just a function
02:06:13 <jtcwang> in getX, you're binding the first Double value of Point object to x, and second Double to y
02:06:19 <jtcwang> and then you return x
02:06:41 <skypers__> timeout dammit
02:06:43 <skypers__> I was saying
02:06:44 <Cale> tellmeahaskell: It is a data constructor, which means that we can pattern match on values of type Point, decomposing them into parts
02:06:56 <skypers__> the only solution I found was algebraic finite type
02:06:57 <skypers__> like
02:07:03 <m1dnight> @src foldr
02:07:04 <lambdabot> foldr f z []     = z
02:07:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:07:05 <Cale> magnitude (Pt x y) = sqrt (x^2 + y^2)
02:07:07 <jrmithdobbs> skypers_: not only do they have a decent ffi, but they export in c/c++ abi compatible ways so other people's ffis can use your code
02:07:24 <Yaniel> c++ and abi compatibility?
02:07:25 <Cale> tellmeahaskell: Actually, could you come to #haskell-overflow? This channel is a bit noisy
02:07:34 <jtcwang> Cale, I've been using record syntax so much I forgot how to write accessor functions
02:07:35 <skypers__> data Components = FloatingComp [Float] | IntegralComp [Integer] | UnsignedComp [Word32]
02:07:35 <tellmeahaskell> Cale: I dont really understand why/when to use Point and Pt in your example. I will use Point when I want to tell Haskell that it's handling a Point object, and Pt when telling Haskell what a specific Points values are?
02:07:41 <jrmithdobbs> Yaniel: for rust, yes, not haskell ;p
02:07:44 <skypers__> and write a painful Components -> Ptr Word8 function
02:07:52 <tellmeahaskell> cale - sure, i'll get over there
02:07:55 <Yaniel> I mean is that evebn possible
02:08:06 <skypers__> jrmithdobbs: yeah but rust is OOP right?
02:08:11 <skypers__> I really love FPL
02:08:25 <jrmithdobbs> skypers__: it's a weird mixed bag
02:08:28 <skypers__> concepts are elegant
02:08:28 <bjz> skypers__: no, Rust isn't OOP
02:08:28 <skypers__> ah
02:08:34 <skypers__> just like D then?
02:08:49 <jrmithdobbs> skypers__: i'd call it impure functional, like some mishmash of D/erlang/ruby/haskell
02:08:50 <bjz> skypers__: it's as OOP as Haskell is with typeclasses
02:09:01 <skypers__> I see
02:09:15 <jrmithdobbs> (none of that is meant as an insult, to be clear)
02:09:25 <bjz> definitely not
02:09:30 <Cale> tellmeahaskell: /join #haskell-overflow  should probably do it, if you have a remotely sane IRC client
02:09:30 <bjz> <3 Haskell
02:09:30 <merijn> dleedev: Essentially, yes
02:09:33 <skypers__> the thing is I want to stay in the Haskell world, because I believe in Haskell (and I don’t give a damn about industry)
02:09:59 <tellmeahaskell> I'm joining via webchat.freenode.net :D
02:10:00 <bjz> skypers__: but it's not pervasively functional unfortunately - they've have to make tradeoffs
02:10:08 <Cale> tellmeahaskell: that command should work then
02:10:14 <skypers__> I see bjz
02:10:37 <eazar001> :t sqrt
02:10:38 <lambdabot> Floating a => a -> a
02:11:39 <bjz> skypers__: but I'm sure the concepts that rust is pushing (inspired by MLKit) could possibly make it into a more functional systems lang in the future.
02:11:53 <jrmithdobbs> bjz: all the underpinnigs to do a full CPS functional framework is there, if I understand right, just some typeclasses to glue it together are missing, really
02:11:55 <skypers__> bjz: MLKit?
02:12:02 <skypers__> I don’t know that
02:12:06 <bjz> concepts as in regions and lifetimes, ownership etc.
02:12:15 <skypers__> ah
02:12:16 <skypers__> I see
02:12:19 <skypers__> oh btw
02:12:22 <bjz> skypers__: but it's not pervasively functional,
02:12:23 <jrmithdobbs> bjz: and their c++ type syntax (ugh) decision makes it a little convoluted to do abstractly
02:12:25 <bjz> woops
02:12:30 <bjz> copy/paste oops
02:12:33 <skypers__> talking about regions, why doesn’t GHC do region-gc optimization?
02:12:36 <bjz> http://www.itu.dk/research/mlkit/index.php/Main_Page
02:12:58 <m1dnight> @src map
02:12:58 <lambdabot> map _ []     = []
02:12:58 <lambdabot> map f (x:xs) = f x : map f xs
02:13:12 <jrmithdobbs> ownership is interesting for sure
02:13:34 <bjz> jrmithdobbs: yeah, it's unfortunate - I prefer haskelly syntax, but it's the semantics I'm after. I would take lots of tradeoffs for the combination of saftey and control over memory management that rust affords
02:13:57 <dleedev> zipper: check out the comment on your gist
02:14:14 <jrmithdobbs> bjz: i'm still sad they took out explict partial application (bind keyword)
02:14:14 <bjz> jrmithdobbs: but that's not as important for other application areas, where the excess compiler checks can get in the way of doing your work
02:14:22 <skypers__> sometimes I also wonder whether good programmers can get rid off any side-effects-related runtime bugs
02:14:46 <c_wraith> Ok.  Documented what I was doing with ConstraintKinds.  http://lpaste.net/98414
02:14:57 <c_wraith> I understand my own code now!
02:15:03 <bjz> jrmithdobbs: yeah
02:16:04 <bjz> jrmithdobbs: but composition is tricky when you have the option to pass by-val or by-ref, and when the compiler complains if they don't match up
02:16:32 <bjz> jrmithdobbs: somethings that haskell avoids it seems
02:17:00 <jrmithdobbs> bjz: you can do it more awkwardly with lambdas and their diverging function stuff could be used to build a more functional feeling env
02:17:20 <bjz> diverging function stuff?
02:17:20 <jrmithdobbs> bjz: all the {} makes me sad though
02:17:24 <bjz> :P
02:17:34 <jrmithdobbs> bjz: there's really just no need for that
02:18:30 * hackagebot tdoc 0.4.3 - TDoc is a typed document builder with support for (X)HTML  http://hackage.haskell.org/package/tdoc-0.4.3 (NicolasPouillard)
02:18:37 <bjz> jrmithdobbs: yeah... oh well - next language maybe
02:18:47 <dleedev> I just read this line of code for a lens tutorial: forall $ \tuple -> view _1 tuple == fst tuple
02:18:55 <dleedev> is forall really a function?
02:19:23 <dleedev> I haven't been able find it on hoogle
02:19:29 <supki> dleedev: what tutorial?
02:19:34 <dleedev> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
02:20:12 <bjz> http://www.haskell.org/haskellwiki/Existential_type#Existentials_in_terms_of_.22forall.22 ?
02:20:24 <bjz> I just searched: "haskell forall" :P
02:21:50 <Itkovian> Anybody recall what the video was from some user group where the claim was made that unit testing is insufficient?
02:22:03 <jrmithdobbs> bjz: I'll probably play with rust a bit more, the erlang-ish bits and ffi/abi are damned useful for such a high level language
02:23:05 <dleedev> bjz: yeah, but that forall's not a function
02:23:28 <bjz> jrmithdobbs: I struggle to pick where rust sits on the low/high level continuum.
02:24:30 <bjz> jrmithdobbs: but yeah, definitely let us know how you're going over on the mozorg server
02:24:41 <eazar001> @hoogle denominator
02:24:41 <lambdabot> Data.Ratio denominator :: Integral a => Ratio a -> a
02:24:46 <bjz> jrmithdobbs: lots of folks willing to help
02:25:41 <merijn> Any lens afficionados that can help me out with terminology? There's different types of traversals and I wonder which have names (and what those names are)
02:25:55 <merijn> i.e. traverals that produce 0 or 1 outputs per input, 1 output per input, 1 or more outputs per input and 0 or more outputs per input
02:26:01 <bjz> Quick question, are there any other projects like the Numeric Prelude that might be interesting to look at regarding numeric libs?
02:26:30 <bjz> I'm interested in different approaches to organising numeric typeclasses
02:26:57 <supki> @hackage algebra
02:26:57 <lambdabot> http://hackage.haskell.org/package/algebra
02:26:59 <supki> bjz: ^
02:27:18 <bjz> supki: cheers
02:27:41 <jrmithdobbs> merijn: er, traversals are a->a aren't they? folds are a->b, prims are a->Maybe b (conceptually)
02:28:02 <jrmithdobbs> s/prims/prisms/
02:29:04 <jrmithdobbs> merijn: prisms are specialized folds, eg, not traversals
02:29:29 <edwardk> prisms are specialized forms of traversals
02:29:51 <edwardk> > [1]^?traverse
02:29:53 <lambdabot>  Just 1
02:29:58 <merijn> jrmithdobbs: I don't mean lens type names like prism, but I see people throw around names like "prisms are an affine traversal", I was wondering if there's any more "proper" terminlogy and if so how they map to my examples
02:30:07 <edwardk> > Left 4 ^? _Left
02:30:08 <lambdabot>  Just 4
02:30:40 <edwardk> prisms are not just affine traversals, they require more than that, you need to be able to construct the whole uniquely from the part if it matches
02:31:01 <edwardk> something that gets a key out of a map iff its present is an affine traversal, but isn't a prism.
02:31:29 <edwardk> because 'matching' doesn't characterize the entire map
02:31:59 <merijn> edwardk: Sure, I'm just curious about where the "affine traversal" terminology comes from and what other types there are. (Because I find myself needing to describe many different types of traversals and I don't want to reinvent the wheel, terminlogy wise)
02:33:24 <haasn> I think you could say 0-or-1-traversal without reinventing the wheel
02:33:53 <edwardk> affine was something i coined by looking at the usage pattern of the supplied (a -> f b) functon. you can get affine 2 ways (actually tey are the same way somewhat obfuscated), which is to read a prism as     f x = a*x + b, the other is to note that the usage of the supplied function is 'affine' in that it may be weakened but never contracted in a logic sense
02:34:39 <eazar001> @hoogle intersect
02:34:40 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
02:34:40 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
02:34:40 <lambdabot> System.Posix.Files.ByteString intersectFileModes :: FileMode -> FileMode -> FileMode
02:35:59 <edwardk> what i mean by that is that the prism either gives you something with the value in it, or it doesn't, which if you set up the algebra of your types and look at the expressions in it, means the equation for such a 'match' precisely lines up with the definition of an affine transformation. Girard first used this structure in logic for talking about 'linear logic that still permits weakening' as affine logic
02:36:15 <haasn> edwardk: f x = a*x + b -- can you do something similar for regular or relevant traversals?
02:36:53 <edwardk> haasn: ys, but you wind up with a big generating function with no coefficient for x^0
02:37:04 <merijn> I think I started reading Girard at some point, but paused. Man, I have so much homework to do >.>
02:44:30 <skypers_> hi
02:45:22 <skypers_> I’m parsing a very large file, then I want to store parsed values into a Vector
02:45:30 <skypers_> how should I reserve memory?
02:45:37 <skypers_> in C++ I’d use std::vector::resorve
02:45:39 <skypers_> reserve*
02:45:48 <skypers_> do I just have to do something like
02:45:53 <skypers_> generate n id
02:45:54 <skypers_> ?
02:46:10 <skypers_> or replicate ?
02:47:25 <quicksilver> don't reserve the memory
02:47:27 <Cale> skypers_: You're using a mutable vector?
02:47:35 <quicksilver> just create the vector.
02:47:41 <skypers_> Cale: no, Vector
02:47:41 <Cale> new is the way to allocate a new mutable vector
02:47:50 <skypers_> quicksilver: it will be inefficient then
02:47:52 <Cale> okay, then that question doesn't even make sense
02:47:55 <quicksilver> skypers_: no, it won't
02:48:02 <skypers_> since I guess a lot of reallocations will be performed
02:48:04 <mm_freak> jle`: .llc
02:48:07 <quicksilver> skypers_: you are guessing how it works based on incorrect intuition from another language.
02:48:07 <Cale> Immutable vectors are allocated when you define them
02:48:10 <mm_freak> oops
02:48:23 <skypers_> hm
02:48:23 <mm_freak> jle`: well, you can use category theory to define it
02:48:41 <Cale> skypers_: Since you can't rewrite them, it doesn't make sense to allocate them separately
02:48:52 <skypers_> so what should I do?
02:48:53 <Cale> skypers_: They're constants
02:48:54 <mm_freak> jle`: define Auto as a functor instead of a category
02:48:57 <Cale> Don't worry about it.
02:49:00 <skypers_> I do a preparse pass
02:49:10 <skypers_> to know how many lines I have in the file
02:49:14 <skypers_> then for each line
02:49:21 <skypers_> I prepend some stuff into the Vector
02:49:27 <skypers_> will it be really efficient?
02:49:29 <mm_freak> jle`: newtype Auto cat a b = Auto (a `cat` (b, Auto a b))
02:49:35 <mm_freak> oops
02:49:38 <mm_freak> jle`: newtype Auto cat a b = Auto (a `cat` (b, Auto cat a b))
02:49:45 <Cale> skypers_: cons is O(n) on vectors
02:49:51 <Cale> skypers_: so no
02:50:03 <mm_freak> jle`: then Wire is the Auto functor applied to the kleisli category of the Maybe monad
02:50:06 <skypers_> I guessed well then
02:50:10 <skypers_> I have to worry about that
02:50:22 <Cale> skypers_: use accum
02:50:41 <mm_freak> jle`: type Wire = Auto (Kleisli Maybe)
02:50:44 <Cale> accum :: (a -> b -> a) -> Vector a -> [(Int,b)] -> Vector a
02:51:27 <skypers_> Cale: ok, it’s an update function?
02:51:35 <mm_freak> jle`: the regular Auto is then just the Auto functor applied to Hask
02:51:44 <mm_freak> jle`: type NormalAuto = Auto (->)
02:52:15 <Cale> or actually
02:52:18 <Cale> why not just use fromList
02:52:25 <Cale> Yeah, use fromList
02:52:37 <skypers_> Cale: the first thing I was thinking of was using lists
02:52:48 <mm_freak> jle`: in other words, you will learn the most interesting things about Wire, if you look at it from a categorical viewpoint =)
02:52:49 <skypers_> but I’m pretty sur I’ll get pretty bad performances
02:52:57 <Cale> skypers_: Why are you pretty sure of that?
02:53:07 <skypers_> Cale: because of reallocations?
02:53:19 <Cale> skypers_: fromList only allocates once
02:53:26 <skypers_> when you do a ++ b, there might be some garbage
02:53:34 <Cale> You're not doing a ++ b
02:53:47 <skypers_> I was saying if I keep stuck to lists
02:54:00 <Cale> Vector also doesn't support efficient concatenation
02:54:01 <skypers_> like “for each line, just prepend (++) to the main list”
02:54:14 <skypers_> so what’s the point of Vector?! :D
02:54:19 <c_wraith> I kind of want to find some way to tell GenericNewtypeDeriving to pass through every dictionary for a type.
02:54:38 <c_wraith> That's probably far beyond what it's supposed to do
02:54:42 <Cale> skypers_: In fact, while xs ++ ys is O(length xs) for lists, it's O(length xs + length ys) for Vectors.
02:54:55 <skypers_> so vectors are even worse
02:55:03 <Cale> They're also better in lots of ways.
02:55:15 <skypers_> because vectors are contigus area of memory I guess
02:56:04 <Cale> They have "O(1)" indexing and slicing. (Those are slight lies because they ignore log factors which are inherent to the problems being solved)
02:56:31 <Cale> But very fast indexing anyway
02:56:46 <quicksilver> memory locality is sometimes useful
02:56:51 <Cale> If you think that pointer dereferencing is O(1), then it's O(1) indexing ;)
02:57:01 <skypers_> Cale: yeah
02:57:05 <quicksilver> especially if you're doing random access on a 'smallish' vector which fits in cache
02:57:11 <skypers_> it’s a mult and and a add
02:57:15 <skypers_> -and
02:57:18 <quicksilver> if you believe that O(1) exists, then pointer dereferencing in cache is O(0)
02:57:44 <Cale> wat
02:57:49 <Cale> heh
02:59:45 <tdammers> not this again
03:02:37 <c_wraith> it's far too late.  Can someone tell me if it's coherent to want a newtype that passes through all instance dictionaries without enumerating them?
03:03:56 <c_wraith> Hmm.  I guess whether it's coherent or not, it doesn't play nice with the lookup mechanisms currently in place
03:04:14 <Axman6> @hoogle unsafePerformIO
03:04:15 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
03:04:15 <lambdabot> Foreign unsafePerformIO :: IO a -> a
03:05:48 <quicksilver> I don't think it's incoherent, c_wraith
03:06:10 <quicksilver> remember the "lookup" to the extent that there is one, is done at compile time
03:06:24 <quicksilver> instance lookup
03:06:25 <edwardk> c_wraith: the issue is coherence. someone defines an instance of Foo X and you can lift it to Foo Y, even f there is another Foo Y already in place
03:06:42 <c_wraith> edwardk: my use case is limited enough that I don't think that'd happen
03:06:51 <quicksilver> edwardk: oh, I assumed he meant "and there is no other way Y can get instances"
03:06:59 <quicksilver> which was quite a big assumption
03:06:59 <edwardk> c_wraith: in an open world you don't get to really make that call ;)
03:08:24 <c_wraith> edwardk: my case is...  special.  Someone could always try to add an instance like that, but it would always be rejected for overlapping
03:08:25 <edwardk> you can play some dangerous games with unsafe methods in my constrants package if you really want to move dictionaries around, but when it blows up its on your head ;)
03:09:19 <edwardk> the constraints package approach won't give you the overlapping complaint
03:09:56 <edwardk> and ghc doesn't have any way to say what you want more directly
03:10:09 <c_wraith> edwardk: http://lpaste.net/98422
03:10:28 <bezirg> guys, I want to download the whole archive of hackage packages. I used to achieve that with http://hackage.haskell.org/packages/archive/00-archive.tar but because of the new hackage this link is not available. What can I do? Is there a simpler way than doing a json call for the package names and loop them for fetching each package tarball?
03:10:53 <c_wraith> edwardk: the second-worst part of that approach is on line 56 - you need to explicitly copy the instance
03:10:58 <bezirg> I mean not a json call, an http get
03:11:11 <edwardk> c_wraith: see my reflection package examples for more like that, and thoughtpolice's tutorial on the topic, and jfischoff's reflection-extras package
03:11:16 <Axman6> urgh! why would you remove memmove from Data.ByteString.Internal >_<
03:11:23 <Axman6> bloody hell
03:11:26 <c_wraith> (the worst part is needing to write the wrapper type to make it work at all - unfortunate, but there's no other choice)
03:12:06 <edwardk> but consider your With1 Monad m -- it woudn't be sound to permit you to lift all dictionaries
03:12:17 <edwardk> because you want to handle Functor and Applicative yourself
03:12:59 <c_wraith> edwardk: what I want, were it syntactically valid, is something like     deriving instance con f => con (With1 con f)
03:13:12 <c_wraith> edwardk: so you would only copy the ones that are named in the type
03:13:29 <edwardk> now, if you're willing to be evil, are you familiar with http://hackage.haskell.org/package/constraints-0.3.4.2/docs/Data-Constraint-Unsafe.html ?
03:13:54 <edwardk> there you can do       unsafeApplicative $ use applicative operators here on your monad
03:14:25 <edwardk> i don't happen t believe that just because i _can_ do that, that i should though ;)
03:14:37 <c_wraith> I was really approaching it from the other side entirely - answering the "How do I say that all instances of ExistingClass are also instances of my class?"
03:15:01 <edwardk> well, you can't ;)
03:15:07 <Philonous> Why do type level nat literals not get normalized? (i.e. "2" instead of (1+1)) Is that not implemented yet?
03:15:08 <c_wraith> And the answer is "well, you use a newtype wrapper", and then I started wondering if I could make writing that wrapper easier
03:15:18 <c_wraith> Philonous: wait for 7.8
03:15:26 <Iceland_jack> c_wraith: But I want it *now*
03:15:31 <c_wraith> me too. :)
03:15:38 <edwardk> Iceland_jack: then install it now =)
03:15:57 <bjorkintosh> goodness. it looks like the clojure guys are having all the fun in the world these days!
03:16:11 <Cale> bjorkintosh: oh?
03:16:18 <bjorkintosh> i think it's the cool logo. yeah, at least on youtube.
03:16:20 <Iceland_jack> edwardk: Maybe I should
03:16:37 <c_wraith> edwardk: so my WithN wrappers would help automate that solution pattern - it *nearly* works at the moment.  I can almost say that "for things with a monad instance, fmap = liftM"
03:16:42 <Cale> Yeah, I was immediately jealous of the Clojure logo
03:17:22 <c_wraith> edwardk: applicative and monad were just handy examples, in that I didn't have to declare any new classes - the real intended use is more complex, such that unsafeCoercing isn't as handy
03:17:43 <eazar001> not . any . flip (tail $ subsequences [2,5])
03:17:48 <eazar001> > not . any . flip (tail $ subsequences [2,5])
03:17:49 <lambdabot>  Couldn't match type `[a1] -> GHC.Types.Bool' with `GHC.Types.Bool'
03:17:49 <lambdabot>  Expected type: (a1 -> GHC.Types.Bool) -> GHC.Types.Bool
03:17:49 <lambdabot>    Actual type: (a1 -> GHC.Types.Bool) -> [a1] -> GHC.Types.BoolCouldn't matc...
03:17:49 <lambdabot>              with actual type `[[a2]]'
03:17:58 <eazar001> >:t not . any . flip (tail $ subsequences [2,5])
03:18:39 <edwardk> c_wraith: having gone down this road before i can only say that you're in for a lot of pain and little benefit in terms of practical usecases.
03:18:44 <Philonous> c_wraith, That's what I'm doing and will keep doing for the foreseeable future.
03:19:20 <randomclown> What's the best way to turn a integer to a hex string in Text
03:19:22 <c_wraith> edwardk: well, the fact is, this whole pattern is too verbose to be useful in reality
03:19:30 <eazar001> not . (\x -> any (==x) $ tail $ subsequences [2,5])
03:19:33 <eazar001> >not . (\x -> any (==x) $ tail $ subsequences [2,5])
03:19:41 <edwardk> what i was left with in the end that i was willing to use was the core reflection package, which i still use when i need to make instances that depend on values in context.
03:19:52 <eazar001> > not . (\x -> any (==x) $ tail $ subsequences [2,5])
03:19:53 <lambdabot>  <[Integer] -> Bool>
03:20:02 <edwardk> but i don't use the more exotic side of 'constraints' very often at all.
03:20:22 <edwardk> nothing i've wanted to encode that way has wound up nicer than a more direct encoding
03:20:45 <m1dnight> guys, I have a theoretical question. In the chapter of functional equality (proofs) we need to do a proof with pointfree functions
03:20:49 <edwardk> the unsafeApplicative thing is at least sufficiently 'quiet' i can stomach it
03:20:54 <c_wraith> edwardk: But I wanted to see what issues I'd run into trying to automate it..  And this seems to be a case where ConstraintKinds fails to do as much it should - I can't use a constraint-kinded type variable in an instance declaration
03:21:04 <m1dnight> e.g; 'f. head = head . map f'
03:21:11 <m1dnight> how would one prove this in a pointfree fashion?
03:21:35 <edwardk> c_wraith: correct, there is no way to write 'instance p Foo => instance p Bar'
03:21:48 <edwardk> c_wraith: but even that wouldn't be enough. consider MPTCs, fundeps, etc.
03:22:09 <edwardk> what happens with class Iso a b | a -> b, b -> a, when you have Iso Foo Foo ?
03:22:33 <edwardk> naive applications of your rules would give both Iso Foo Foo AND Iso Foo Bar
03:23:07 <edwardk> so it just isn't sound to even try to write that sort of instance decl
03:23:17 <edwardk> even assuming you can get past the notational issues
03:23:45 <c_wraith> Yeah, it almost certainly fails hard for MPTCs and type families
03:23:47 * hackagebot tree-view 0.1 - Render trees as foldable HTML and Unicode art  http://hackage.haskell.org/package/tree-view-0.1 (EmilAxelsson)
03:24:36 <edwardk> so it is terribly verbose and only works for toy examples with provable counter-examples when things get interesting. i'm not in a hurry to build on that foundation ;)
03:25:36 <maxs`> What is the best way to fix: "<command line>: cannot satisfy -package-id bifunctors-4.1.1-d31480db09a39b09d2a08b0ef76152be"?
03:26:03 <maxs`> I'm even using a sandbox after emptying ~/.ghc and ~/.cabal
03:27:08 <c_wraith> Hmm.  It'd never run into MPTCs, the way I have it defined.  an MPTC doesn't have the right kind to fit in my type
03:27:27 <mm_freak> maxs`: if you changed the available packages, you need to delete the 'dist' directory
03:27:32 <c_wraith> How do associated types end up working with GeneralizedNewtypeDeriving?
03:27:43 <edwardk> c_wraith; Iso :: * -> * -> Constrant,   Iso Foo :: * -> Constraint
03:27:54 <mm_freak> maxs`: although just re-'configure'-ing should also do it
03:28:05 <maxs`> mm_freak: thanks! I forgot about that
03:28:08 <edwardk> the old way or the new way?
03:28:17 <c_wraith> new way..
03:29:20 <edwardk> before they just more or less coerced the dictionary contents, now we coerce each member of the dictionary which leads to more coherent error messages.
03:29:45 <edwardk> this was one of the things that led to last minute panic in terms of the GND fixes that eisenberg has been working on.
03:30:09 <c_wraith> yeah, GND doesn't play nicely with associated types, I'd expect
03:30:28 <edwardk> because he was previously treating dictionaries as having arguments that are of representational kind, where as really the arguments are all nominal, but the entries need to be representational
03:31:07 <c_wraith> I really need to understand this role stuff properly.  But that's a task for a time when I'm not so tired.
03:31:30 <edwardk> likewise. i have to be up in a couple of hours myself. so i should get some sleep
03:31:53 <c_wraith> well, thank you for the feedback
03:33:27 <Hafydd> More like unzipper, am I right?
03:56:27 <randomclown> What's the best way to turn a integer to a hex string in Text
03:58:37 <merijn> hmm
03:59:02 <merijn> I'm trying to build HEAD but building integer-gmp seems to fail?
03:59:04 <Cale> randomclown: I suppose you could use Data.Text.Format which has a Builder for that, but I'd probably just use showHex from Numeric and convert the result to Text
03:59:28 <Cale> merijn: (maybe ask in #ghc?)
03:59:32 <merijn> http://lpaste.net/1374636770217426944
03:59:56 <merijn> Maybe I need to make clean before trying to build...
03:59:57 <Cale> Unknown extensions: NegativeLiterals, RoleAnnotations
04:01:30 <merijn> Yeah, I updated from git and then ran make without cleaning in hopes of not needing to waste hours
04:01:36 <merijn> But I guess that may have been optimistic?
04:02:48 <Cale> When was the last time you compiled? It seems like NegativeLiterals was added in July 2013
04:02:58 <merijn> Cale: Long ago :p
04:08:57 * hackagebot io-streams 1.1.4.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.4.0 (GregoryCollins)
04:10:22 <Axman6> @hoogle Ptr a -> IO a
04:10:23 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
04:10:23 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
04:10:23 <lambdabot> Network.Socket.Internal peekSockAddr :: Ptr SockAddr -> IO SockAddr
04:10:48 <merijn> Cale: Right, seems one of the repos didn't update due to uncommitted local changes >.>
04:19:35 <Axman6> hmmm, memmove isn't doing what's it's supposed to... this is not good
04:29:00 * hackagebot tree-view 0.2 - Render trees as foldable HTML and Unicode art  http://hackage.haskell.org/package/tree-view-0.2 (EmilAxelsson)
04:35:34 <skypers__> hi
04:36:16 <skypers__> http://lpaste.net/8827479870113054720 < do you think this is a legit Semigroup instance, or should I just introduce a Monoid instance by adding a NullComponent ctor to my VertexComponent data (I don’t like that though)?
04:39:30 <Sagi> I get an error while deriving both a Monad and an Applicative instance for a newtype. It says Applicative is not in scope, while it's clearly imported.
04:39:47 <supki> skypers__: you may want to look into GADTs so you can statically ensure "types match"
04:39:58 <Sagi> There seems to be no such problem with Monad. Is this related to the missing link between Monad and Applicative in Haskell?
04:40:02 <supki> skypers__: that way you wouldn't need error calls
04:40:11 <skypers__> supki: hm, sounds great indeed
04:40:14 <supki> skypers__: otherwise your instance looks ok
04:40:23 <skypers__> I always forgot about GADTs :)
04:40:41 <skypers__> it will help me a lot, because I have plenty of functions that pattern match and raise errors
04:40:43 <skypers__> thank you :)
04:40:48 <Sagi> huh
04:41:45 <Sagi> why do I get a Monad type imported for free if I do import Control.Monad (liftM), while I do not get Applicative if I do import Control.Applicative ((<$>))?
04:41:51 <Sagi> I don't get that :o
04:42:04 <supki> Sagi: Applicative itself is not in scope
04:42:10 <supki> not an instances of Applicative class
04:42:16 <supki> those are always imported
04:42:32 <Sagi> yeah, I solved with an explicit import Control.Applicative
04:42:38 <Sagi> but why does it work for Monad?
04:42:45 <supki> Monad is in Prelude
04:42:47 <Sagi> oh
04:42:51 <Sagi> thanks
04:42:56 <Sagi> :$
04:43:52 <mr-> skypers__: disregarding the error, I think this would look nicer http://lpaste.net/8827479870113054720
04:44:31 <Reite> Im trying to make some generic functions to modify the state of my application that uses Acid State. Im not sure if its possible. Heres some code that shows the error Im getting: https://gist.github.com/reite/8399494
04:45:37 <skypers__> mr-: indeed
04:45:47 <skypers__> supki: how would GADTs help me here?
04:45:55 <skypers__> VertexComponent has no phantom types
04:46:10 <merijn> skypers__: You can trivially add a phantom type, no?
04:46:17 <skypers__> well
04:46:31 <skypers__> I still want to be able to use a list of mixed values
04:46:32 <skypers__> like
04:46:45 <skypers__> [FloatingComponent [1..10],IntegralComponent[1..5]]
04:47:07 <skypers__> I doubt it’s ok with a phantom type
04:47:26 <skypers__> what would be the type of that list?
04:47:33 <skypers__> [VertexComponent ?]
04:49:49 <randomclown> Oh I didn't know you could pattern match record types
04:49:50 <randomclown> with record names
04:50:04 <randomclown> MyType{} works
04:50:59 <merijn> randomclown: Fun fact: That syntax also works on non-record constructos
04:51:31 <merijn> randomclown: It's great for matching constructors where you don't care about the argument fields, means you don't have to update the code when the number of fields changes
04:52:05 <randomclown> exactly
05:07:28 <randomclown> how slow is appending to a really really long Text?
05:11:20 <klugez> randomclown: It will allocate a new Text, so very slow. If that's a problem, you should use Builders.
05:12:33 <randomclown> klugez: I'm assuming builders don't copy the whole Text
05:13:16 <klugez> randomclown: Yeah, repeatedly appending is exactly the use case they are for.
05:13:18 <randomclown> But when I take out the text is it still going to really slow?
05:13:35 <randomclown> I only need to append a small amount of data to the end of a very long Text
05:13:53 <bennofs> Wow, does travis-ci have ghc 7.6 finally?
05:14:04 <quicksilver> well the builder is always faster than doing the append by hand
05:14:21 <quicksilver> but if you literally only have one append, it makes no difference
05:14:37 <randomclown> yeah I literally have only one append
05:21:08 <Philonous> Is there an extension that allows conflicting family instance declarations? (Akin to OverlappingInstances)
05:30:43 <Philonous> Ahhh, GHC 7.8. Damn it.
05:31:07 <supki> skypers: I don't see much use of Semigroup instance if you plan to have "heterogeneous" lists then
05:46:09 <killy9999> type family Apply (f :: TyFun k1 k2 -> *) (x :: k1) :: k2
05:46:28 <killy9999> can anyone give me a hint why am I getting parse error with this definition?
05:47:06 <bennofs> killy9999: What's TyFun?
05:47:18 <killy9999> data TyFun :: * -> * -> *
05:47:28 <killy9999> or
05:47:29 <killy9999> data TyFun (d :: *) (c :: *)
05:47:34 <killy9999> which is the same
05:47:47 <bennofs> killy9999: you cannot have types in kind signatures. TyFun is a type constructor, so TyFun k1 k2 is a type, not a kind
05:48:11 <Philonous> killy9999, Have you enabled -XTypeFamilies ?
05:49:09 <bennofs> killy9999: what should the type family Apply do?
05:49:28 <byorgey> bennofs: you can have types in kind signatures if -XDataKinds is enabled
05:49:28 <killy9999> argh... TypeFamilies >_<
05:49:33 <Philonous> killy9999, Your definition works for me with -XTypeFamilies -XPolyKinds and possibly others
05:49:46 <killy9999> I have DataKinds and PolyKinds, but forgot about TypeFamilies
05:49:49 <Philonous> :D
05:49:54 <killy9999> yeah, I added TFs and it works
05:49:55 <killy9999> thanks
05:49:57 <byorgey> or rather, types can become kinds, and thus be used in kind signatures, with -XDataKinds
05:49:58 <killy9999> I needed a sanity check
05:50:32 <killy9999> bennof: Apply applies functions to arguments at the type level
05:52:33 <bennofs> byorgey: hmm right. I forgot that they automatically become kinds, I thought you needed an apostrophe for that
05:53:12 <kepta> join #jquery
05:53:32 <bennofs> Oh, why is case x of Nothing -> return (); Just x' -> do ... faster than for_ x $ \x -> do ... ?
05:54:01 <kepta> Hello
05:55:25 <quicksilver> bennofs: because something failed to inline
05:55:31 <quicksilver> which is a bit surprising...
05:55:49 <quicksilver> is there a type signature? could you have accidentally made it polymorphic?
05:56:10 <byorgey> hi kepta
05:56:18 <bennofs> x :: Maybe Event
05:56:36 <bennofs> quicksilver: I'm trying to inline manually atm and see if that gives a speedup
05:57:36 <quicksilver> bennofs: compiling with -O?
05:58:01 <bennofs> quicksilver: cabal does that if I don't force it not to, right?
05:58:16 <bennofs> cabal configure && cabal build is what I do
05:58:30 <merijn> bennofs: That's redundant
05:58:43 <merijn> bennofs: Recent cabals automatically configure when you run "cabal build" <3
05:59:04 <quicksilver> I think cabal defaults to -O
05:59:07 <quicksilver> btu I'm not confident
05:59:08 <bennofs> merijn: But I'll do cabal configure do be sure that I clear previous flags, like --enable-profiling
06:00:25 <bennofs> Btw, can I insert {-# SPECIALIZE #-} pragmas anywhere or only where the function is defined?
06:00:39 <merijn> bennofs: I think anywhere, but that's grounds for lynching
06:03:39 <bennofs> foldr is not defined INLINEABLE in the instance Foldable Maybe :|
06:04:06 <bennofs> Is there any easy way to test if declaring it INLINEABLE would help? I cannot patch base, can I?
06:07:23 <merijn> bennofs: Sure you can, but you'll need to rebuild GHC most likely?
06:07:52 <bennofs> merijn: yeah, and I'd like to avoid that :P (takes so much time and cpu power ...)
06:10:13 <quicksilver> bennofs: a definition that short shouldn't need a pragma to be inlined
06:10:58 <quicksilver> bennofs: for testing purposes why not copy-paste a fresh class "MyFoldable" though
06:11:07 <quicksilver> it's not like it's a lot of code
06:11:12 <quicksilver> make sure you put it in a separate module
06:11:18 <bennofs> quicksilver: Ok, I'll do that
06:15:06 <henk> I wonder if anyone could comment on a license/legal question: In my code I 'import' from the datetime package (http://hackage.haskell.org/package/datetime) which is released under GPL. Does that mean that my code has to be GPL as well?
06:15:53 <Maior> henk: pretty much
06:16:31 <killy9999> bennof: Apply applies functions to arguments at the type level
06:16:39 <killy9999> blah, sorry, wrong window
06:16:44 <henk> wow … So much freedom in this license …
06:17:31 <Blkt> could anyone tell me how to fix "Non-exhaustive patterns in case" using parsec?
06:18:41 <henk> Maior: thanks
06:20:05 <bennofs> quicksilver: Even defining the foldr2 function in the same module (as a class method of Foldable'), and putting a SPECIALIZE + INLINEABLE pragma on it, foldr2 ((*>) . c) (pure ()) x is still slower than case x of Nothing -> pure (); Just x' -> pure () *> c x'.
06:20:06 <Philonous> henk, No, you can release your code under whatever license you like (as long as it's compatible with GPL). The problem is that the aggregate result might have to be GPL.
06:20:22 <Maior> henk: er yeah sorry what Philonous said is way more accurate
06:23:14 <henk> Philonous: oh, so only if I distribute binaries, they have to be released under GPL, but since my source code does not yet (until interpreted or compiled) actually include that library, my source may be whatever license I want it to be?
06:24:18 <quicksilver> your source must be compatible with the GPL which doesn't mean it must actually *be* GPL
06:24:42 <Philonous> henk, The source you write is yours. Nobody can tell you what license to use. But If you combine it with GPLed code then you must distribute the combined result under the GPL.
06:24:44 <quicksilver> bennofs: i would report that to the glasgow-haskell-users list perhsonally
06:25:18 <Philonous> henk, More specifically: IF you distribute it it has to be under the GPL.
06:25:51 <henk> quicksilver: What does "compatible" exactly mean in that case?
06:26:03 <merijn> henk: *at least* as permissive as the GPL
06:26:34 <merijn> I really need to make an online version of the copyright talk I gave here to answer these sorts of questions
06:26:40 <Philonous> henk, It has to allow you to distribute it under GPL.
06:27:08 <henk> Philonous: My source code or the combined result? Is the "combined result" == "compiled binary"? Does static or dynamic linking make a difference?
06:27:30 <merijn> henk: Basically, you can license your code anyway you like. But binary distribution of a program/library that uses your code/library will include the GPL library. Binaries includingGPL code *must* be GPL
06:28:04 <merijn> henk: Which means that if the license of *your* code grants *more* rights than GPL (i.e. like BSD/MIT) *and* allows relicensing (like BSD/MIT), then you're fine
06:28:17 <henk> merijn: But the GPL is pretty restrictive regarding the license of products using GPL'ed stuff, so what I consider a more permissive license (like BSD 3 Clause e.g.) would not be allowed I think, or is it?
06:28:22 <Philonous> henk, Say you write code and and license it under CDDL. Then you can't combine it with GPL code because CDDL doesn't allow the combined result to be distributed under GPL.
06:28:30 <merijn> henk: If your code has some restrictions the GPL doesn't allow then you *cannot* legally distribute any binaries
06:29:29 <merijn> henk: The BSD3 license allows code under that license to licensed under a "more" restrictive license, taking BSD3 code and distributing it under a GPL license is valid (as you are still complying with all BSD requirements, e.g. listing authorship and including the license)
06:29:31 <Philonous> henk, While BSD3 code can be distributed under GPL. That's what "compatible" means in this case
06:30:03 <merijn> henk: Hell, you can take BSD3 code and distribute it as closed source, so you can definitely license it as GPL
06:30:22 <Philonous> merijn, That argument isn't sound.
06:30:26 <merijn> henk: GPL just states "any code distributed must provide *at least* these rights", BSD satisfies that requirement
06:30:41 <merijn> Philonous: It's not an argument, it's an example
06:30:42 * Kinnison tends to licence his stuff under MIT/BSD for these reasons
06:30:46 <Kinnison> license
06:30:47 <Kinnison> gah
06:31:20 <dv-> so it can be extended proprietarily?
06:31:31 <Philonous> merijn, A license may allow binary-only and still be incompatible with GPL. But anyway. In the case of BSD3 it's certainly right
06:31:38 <merijn> dv-: It can always be extended proprietarily
06:31:40 <Kinnison> more so people don't sit for ages discussing what they can and cannot do with the code
06:31:44 <merijn> dv-: It just can't always be distributed
06:31:48 <Lethalman> I love gpl
06:35:05 <Philonous> henk, Note that all this doesn't apply if you don't distribute your code. For example, you can combine GPL and proprietary code and run it on your server.
06:36:34 <tdammers> ...except if some of that code gets served...
06:37:26 <henk> Philonous: Yes, I know. I’ve been writing quite some software without having to worry about licensing yet, because it was never meant to be published really, but now that time has come …
06:37:43 <henk> s/software/code/
06:38:20 <Philonous> henk, Which license would you like to publish it under?
06:38:34 <henk> i.e. I hacked stuff together to get things working. Now I’m actually trying to write a software that may be of use for more people than just me …
06:38:49 <henk> Philonous: I’m strongly considering BSD 3-Clause
06:39:53 <Philonous> henk, BSD3 is GPL2/3-compatible. So you can just go ahead.
06:42:43 <johannes__> hmm.. why is Bool an instance of Ord?
06:42:57 <merijn> johannes__: Why not?
06:43:00 <bennofs> > False < True
06:43:01 <lambdabot>  True
06:43:01 <merijn> > False < True
06:43:02 <lambdabot>  True
06:43:20 <henk> Philonous: alright, thank you
06:43:26 <johannes__> What makes True greater than False.. hehe
06:43:37 <merijn> johannes__: Common consensus
06:45:12 <quicksilver> johannes__: a common injection into Int
06:45:13 <shiona> I guess the only reason is that people are used to the ordering being there. Which to me isn't a good reason
06:45:26 <quicksilver> > map fromEnum [False,True]
06:45:26 <lambdabot>  [0,1]
06:45:35 <quicksilver> shiona: no, that's not the *only* reason.
06:45:46 <quicksilver> there are pragmatic reasons, too
06:45:49 <merijn> shiona: By that logic there's no good reason to have ordering on Ints
06:45:52 <johannes__> quicksilver: so it has nothing to do with the programming convention to use 1 for True when a Boolean type doesn't exist..like in C
06:46:01 <merijn> johannes__: It does
06:46:11 <quicksilver> with an Ord instance you can use them as keys in Maps and indexes into Arrays
06:46:22 <merijn> johannes__: That's not really a C convention, it dates back to Boolean algebra
06:46:32 <quicksilver> and you can derive Ord instances for more complex types which use Ord
06:46:37 <quicksilver> ..which use Bool, I mean
06:46:37 <merijn> Which C merely copied
06:46:40 <johannes__> oh.. yes i didn't think about that
06:46:41 <quicksilver> like (Int,Bool,Int)
06:48:06 <Sagi> is there some way to do introspection in Haskell? For example, get the list of pattern matches to a function?
06:48:33 <merijn> Sagi: "It depends"
06:48:38 <merijn> Sagi: What are you wanting to do?
06:48:40 <Sagi> :-)
06:48:48 <Sagi> let me explain
06:49:48 <Sagi> I want to do activation of some functionality from the command line, which I do by matching against a list of known functionalities, currently defined as a list. But those functionalities actually correspond to functions.
06:50:00 <Sagi> it feels double to have both a list of acceptable names and a definition of these functions.
06:51:11 <Sagi> perhaps I could do a pair of ("name", name) and then match on the first entry and return the second.
06:51:43 <tdammers> Sagi: I think some Template Haskell would be the most feasible route
06:51:53 <merijn> I was thinking of TH too
06:51:58 <Sagi> hmm
06:52:13 <Sagi> I have never done anything using TH. Any primer you can recommend?
06:53:40 <Lethalman> Sagi, that helped me grasp the basic concepts: http://www.hyperedsoftware.com/blog/entries/first-stab-th.html
06:54:48 <Sagi> Lethalman: thanks!
06:58:21 <Aleksejs> Hi, is there any way to execute a haskell expression in cli? Currently I use something like that: echo "main = print $ [1..10]" | runhaskell <&0
06:59:42 <Maior> Aleksejs: ghci ?
07:00:01 <jonasw> Aleksejs: ghc -e
07:00:05 <Aleksejs> Maior, but without launching ghci
07:00:27 <Aleksejs> jonasw, thanks!
07:00:29 <kammerer> anyone here to help with msgpack in haskell (cc pingu)? it incorrectly parses a stream containing an int + an array
07:01:49 <kammerer> see http://lpaste.net/2728384692112850944
07:02:14 <simon> what's the point in using non-attoparsec libraries when attoparsec is really fast?
07:02:33 <kammerer> it fails with Left "Failed reading: invalid array tag: 0xCD", indicating it wants to interpret 0xCD twice, once at int and once as array?
07:02:41 <bennofs> simon: attoparsesc's error messages are not so nice
07:02:46 <byorgey> what's the point in using non-C programming languages when C is really fast?
07:02:59 <Jaak> just curious, are there any happy+alex vs attoparsec performance tests?
07:03:01 <simon> so error messages seems to be a valid point.
07:03:10 <Blkt> how do I provide custom error messages in parsec?
07:03:10 <kammerer> (0x91 indicates an array, 0xCD an integer)
07:03:24 <byorgey> I am not comparing attoparsec to C; just pointing out that there are many other desirable criteria than just speed.
07:03:29 <Jaak> or rather benchmarks
07:03:43 <simon> Blkt, the (<?>) operator.
07:03:45 <byorgey> Blkt: with the <?> combinator
07:04:09 <Blkt> thank you
07:04:17 <simon> Blkt, so if a parse error happens within a specific sub-parser-combinator, it displays the nearest message.
07:04:42 <merijn> preflex: seen carter
07:04:42 <preflex>  carter was last seen on #haskell 10 hours, 9 minutes and 40 seconds ago, saying: DSP filters or FP filters?
07:05:08 <maxiepoo> hey what's the difference between Data.ByteString.Lazy.readFile and Data.ByteString.Lazy.Char8.readFile ?
07:05:22 <b80905> How do I convert a Bool to Integer?
07:06:08 <Cale> b80905: Depends on what you mean. fromEnum might do what you want, if not then perhaps an if/then/else expression?
07:06:32 <merijn> maxiepoo: Anything in Char8 of ByteString is vile heresy that should be ignored
07:07:43 <Cale> maxiepoo: they appear to be the same
07:09:03 <b80905> Cale: so that a function that counts the number of occurences of a character in a string would look like `count c (ch:chs) =  (ch == c) + (count c chs)'
07:09:40 <maxiepoo> oh they are!
07:09:50 <merijn> b80905: eh, why no use an if/else there?
07:10:18 <merijn> "count c (ch:chs) = count c chs + if ch == c then 1 else 0" or something
07:10:20 <maxiepoo> I was looking at the src and thought "why are the implementations exactly the same?"
07:10:39 <merijn> maxiepoo: I think it's just so you only have to import one or the other
07:10:52 <merijn> maxiepoo: But I stand by my previous remark that Char8 is awful heresy
07:12:24 <maxiepoo> merijn, Yeah I'm trying to move away from Char8 but I need to be sure I didn't just make a behavioral change
07:19:53 <Rarrikins> > let count c xs = f 0 c xs where f n _ [] = n; f n c (x:xs) = f (if c == x then n + 1 else n) c xs in count 'h' "hello"
07:19:54 <lambdabot>  1
07:22:48 <timthelion> Anyone have any good ideas on how to uniquely serialize a non letter as a series of letters?  Perhaps a function that gets the official unicode name for the given symbol(but it appears that some names are more than one word, so how would I know they don't contain symbols too..)
07:23:02 <haasn> timthelion: zencoding
07:23:14 <haasn> preflex: zenc foo☃bar
07:23:14 <preflex>  fooz2603Ubar
07:23:33 <haasn> preflex: foo&bar,bat+baz
07:23:38 <timthelion> OK, so that will only include numbers, and then I convert the numbers manually...
07:23:38 <haasn> preflex: zenc foo&bar,bat+baz
07:23:39 <preflex>  foozabarz2cUbatzpbazz
07:24:00 <timthelion> haasn: thanks
07:24:15 <haasn> ah, I didn't realize zencoding includes numbers too
07:25:05 <k00mi> base64?
07:25:15 <haasn> base26 :)
07:29:22 <Blkt> could anyone help me removing all those strings? http://pastebin.com/R9FnMtBn
07:29:23 <mauke> The paste R9FnMtBn has been copied to http://lpaste.net/98427
07:29:40 <timthelion> I guess I'll just rewrite with a name monad.  Naming variables in autogenerated code after things your server receives over the wire is just stupid I guess...
07:30:53 <Cale> Blkt: choice . map string $ [...]
07:31:01 <Blkt> mmm
07:31:22 <Blkt> I don't get it
07:32:14 <Blkt> maybe I should clarify that my will is to remove the "case op of ..." part
07:32:30 <Blkt> because (1) is redundant (2) may fail badly while parsing
07:36:11 <timthelion> All of a sudden, I wish haskell had mixfix.
07:36:22 <danharaj> no you don't
07:36:28 <danharaj> no one got time to parse that
07:38:15 <merijn> I've been wishing for mixfix haskell since I learned someone invented mixfix
07:38:15 <timthelion> I'm having to add a bad input filter in a server side code generator now. And it would be really nice to be able to surround variables with my "filterSpecialChars" function rather than writting (filterSpecialChars $ fuction var)...
07:38:39 <timthelion> I mean, I guess I could just come up with a shorter name, but it still looks like crap.
07:39:09 <timthelion> This is code generation in the stile of "string literal"++somevar++"more string litteral"
07:39:22 * hackagebot flamethrower 0.0.1.2 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.1.2 (charmander)
07:39:46 <timthelion> style, not stile... My word I've lost my ability to type!
07:41:02 <watermind> danharaj: depends, mixfix is trivial to parse if the resulting expressions have non-optional delimiters, e.g.  if_  then _ else _  end_if
07:41:46 <watermind> hmmm my use of "_" in end_if just made that unnecessarily obscure
07:41:55 <watermind> if _ then _ else _ endif
07:44:33 * timthelion just realized that this program is even more borked than he thought.  It saves files to paths who's names are based on unfiltered network input!
07:45:19 <timthelion> And these people get *paid* to code'
07:46:46 <zett_zelett> *whose
07:52:04 <merijn> timthelion: :)
07:52:15 <merijn> timthelion: Time to start crying :p
07:52:42 <zomg> Time to get a job doing something else than programming
07:52:46 <zomg> :P
07:53:41 <ChongLi> timthelion: really, shouldn't the operating system take care of that?
07:53:49 <zomg> which is something I occasionally contemplate, but then remember I'm never going to buy the expensive cars I like with a job that doesn't pay as good, and thus I give up and hope that one day I can have competent coworkers
07:53:53 <zomg> lol
07:54:05 <ChongLi> we love Haskell so much because of the safety we get from the types
07:54:13 <benzrf> :t either
07:54:14 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
07:54:16 <benzrf> :t bimap
07:54:17 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
07:54:24 <ChongLi> wouldn't it be nice if the operating system had the same sorts of safety?
07:54:24 * hackagebot hebrew-time 0.1.1 - Hebrew dates and prayer times.  http://hackage.haskell.org/package/hebrew-time-0.1.1 (MichaelSnoyman)
07:54:24 <benzrf> hm
07:54:29 <ChongLi> capabilities, for example
07:54:43 <timthelion> ChongLi: well, in retrospect it might have been better if unix didn't allow for relative paths all.
07:55:01 <ChongLi> what about capabilities?
07:55:15 <ChongLi> seems like that'd solve pretty much all cases of the confused deputy problem
07:55:26 <ChongLi> which is what your issue is
07:55:50 <ChongLi> if your program only had the capability to write files in a specific place
07:55:54 <benzrf> timthelion: why would that be a good thing o_o
07:56:05 <benzrf> timthelion: wait, do you mean for system calls?
07:56:11 <benzrf> timthelion: so that shells can still figure out relative paths etc
07:56:26 <ChongLi> no, relative paths are not a problem if you have capabilities :)
07:56:35 <ChongLi> and now I'm starting to sound like a broken record!
07:56:49 <timthelion> I see where ChongLi is going.
07:57:10 <timthelion> benzrf: well, they could work the same way as aliases do(like ~) and just be handled by the shell.
07:57:11 <ChongLi> permissions are simply way too coarse-grained
07:57:34 <ChongLi> they are analogous to doing stringly-typed programming
07:57:40 <Blkt> could anyone help me with this? http://lpaste.net/98428
07:57:55 <benzrf> oh btw
07:58:04 <benzrf> ive been told to try the hutton variations or w/e
07:58:10 <benzrf> anybody have a link "
07:58:15 <benzrf> s/"/?
07:58:26 <ChongLi> Blkt: are you using Parsec?
07:58:29 <Blkt> yes
07:58:58 <Blkt> ChongLi: yes
07:59:07 <ChongLi> Blkt: okay, what you want to do is break that up into smaller combinators
07:59:48 <Blkt> ChongLi: the problem is that I don't know how to have smaller functions of type Parser MappingVal
08:00:05 <Blkt> well, parseEq and parseNeq apart
08:00:06 <Sagi> can't seem to get my cabal-dev sandbox to build with profiling enabled in order to use the -xc flag
08:00:22 <ChongLi> Blkt: Eq, Neq, Gt, Lt etc.
08:00:25 <ChongLi> what is their type?
08:00:33 <Blkt> MappingVal
08:00:43 <Blkt> let me annotate the paste
08:01:19 <ChongLi> Sagi: why not use cabal 1.18 sandboxes?
08:01:35 <ChongLi> they let you have separate configs for stuff like profiling and documentation
08:01:39 <Blkt> ChongLi: check the link now
08:01:42 <Sagi> I've installed the profiling version of the haskell-platform, put library-profiling: True and executable-profiling: True in an --extra-config-file before doing install-deps and install, but it still complains about the fact that it is built without -prof. What am I missing?
08:01:51 <ChongLi> Blkt: okay
08:02:17 <benzrf> :t fmap
08:02:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:02:18 <Sagi> ChongLi: do I understand correctly that cabal-dev is deprecated now?
08:02:21 <benzrf> :t flip fmap
08:02:21 <lambdabot> Functor f => f a -> (a -> b) -> f b
08:02:26 <benzrf> @hoogle Functor f => f a -> (a -> b) -> f b
08:02:26 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
08:02:27 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
08:02:27 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
08:02:31 <benzrf> hm
08:02:35 <ChongLi> Sagi: yeah, sorta
08:02:39 <ChongLi> it was a temporary fix
08:02:40 <Sagi> ChongLi: hmm, I still use cabal 1.16
08:02:59 <ChongLi> Sagi: does it ask you to update cabal every time?
08:03:11 <ChongLi> and you do so, yet it doesn't stop asking? :)
08:03:21 <ChongLi> Blkt: how about an association list?
08:03:34 <Blkt> can I associate type constructors?
08:03:43 <ChongLi> Blkt: those are data constructors
08:03:47 <Blkt> yes, sorry
08:03:48 <Blkt> my fault
08:03:50 <ChongLi> and yes, you can pass them around like any value :)
08:03:52 <Sagi> ChongLi: errm, no I think it nagged me about an old database, but update seemed to resolve that
08:04:06 <ChongLi> they are just functions which build a value of that type
08:04:39 <Sagi> I think I'd prefer to wait for debian testing to pick up a new cabal version, if that's possible with my profiling use-case
08:04:49 <Blkt> ChongLi: how should I do it then? I don't get how to pass it to the return after dispatching it
08:04:57 <ChongLi> so you can have [("=",Eq),("!=",Neq)]
08:05:02 <ChongLi> and then do a lookup on that
08:05:06 <Blkt> oh
08:05:24 <ChongLi> or you could write Read and Show instances for your MappingVal
08:05:29 <Blkt> ChongLi: could I use choice on something like that?
08:06:26 <ChongLi> actually, with choice you could just have parsers for each one individually
08:07:39 <Blkt> ChongLi: does it have anything to do with <$> ?
08:07:49 <ChongLi> <$> is just fmap
08:08:22 <ChongLi> you may be thinking of <*> which is applicative ap
08:08:38 <ChongLi> the really useful ones for parsing are <* and *>
08:09:03 <benzrf> :t <*
08:09:04 <lambdabot> parse error on input `<*'
08:09:06 <benzrf> :t (<*)
08:09:07 <lambdabot> Applicative f => f a -> f b -> f a
08:09:15 <Blkt> I'll have to give it a try
08:09:19 <benzrf> :t (*>)
08:09:20 <lambdabot> Applicative f => f a -> f b -> f b
08:09:23 <ChongLi> you can write a combinator like this
08:09:31 <benzrf> why not just use >>
08:09:31 <Blkt> all the code I wrote was based on Monad
08:09:45 <benzrf> @src (*>)
08:09:45 <lambdabot> (*>) = liftA2 (const id)
08:09:57 <ChongLi> Blkt: Applicative and Monad are interchangeable because all Monads are Applicatives
08:09:57 <Blkt> benzrf: I need to know what op I'm actually parsing
08:10:06 <benzrf> ChongLi: not quite
08:10:14 <Blkt> ChongLi: but not vice versa, right?
08:10:16 <benzrf> your sentence implied that applicatives can always be swapped for monads
08:10:27 <ChongLi> benzrf: good point
08:10:28 <benzrf> not all applicatives are monads
08:10:39 <Blkt> so I got it right
08:11:12 <benzrf> @src (>>)
08:11:13 <lambdabot> m >> k      = m >>= \_ -> k
08:11:19 <benzrf> @src liftA
08:11:19 <lambdabot> liftA f a = pure f <*> a
08:11:24 <benzrf> @src liftA2
08:11:24 <lambdabot> liftA2 f a b = f <$> a <*> b
08:11:30 <benzrf> ah
08:11:59 <benzrf> why does liftA exist?
08:12:04 <merijn> benzrf: Consistency
08:12:07 <benzrf> :\
08:12:17 <ChongLi> benzrf: there's a lot of extra stuff like that
08:12:20 <Sagi> so, how do I get profiling to work in my cabal-dev sandbox
08:12:27 <benzrf> a *> b == (const id) <$> a <*> b
08:12:28 <benzrf> yeah?
08:12:40 <benzrf> :t const id
08:12:41 <lambdabot> b -> a -> a
08:12:55 <benzrf> aha i get it
08:13:05 <benzrf> :t (<$)
08:13:06 <lambdabot> Functor f => a -> f b -> f a
08:13:44 <benzrf> :t (Just 1 <$ id) <*> Just 2
08:13:45 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `Maybe a1'
08:13:45 <lambdabot>     In the return type of a call of `Just'
08:13:45 <lambdabot>     Probable cause: `Just' is applied to too many arguments
08:13:52 <benzrf> ?
08:14:04 <benzrf> :t (Just 1 <$ id)
08:14:04 <lambdabot> Num a => a1 -> Maybe a
08:14:17 <benzrf> oh wait derp
08:14:25 <benzrf> :t (id <$ Just 1) <*> Just 2
08:14:26 <lambdabot> Num b => Maybe b
08:14:26 * hackagebot snap-testing 0.1.0.0 - A library for BDD-style testing with the Snap Web Framework  http://hackage.haskell.org/package/snap-testing-0.1.0.0 (DanielPatterson)
08:14:37 <benzrf> :t Just 1 *> Just 2
08:14:38 <lambdabot> Num b => Maybe b
08:14:47 <ChongLi> Blkt: there's actually a function in parsec for doing exactly what you want
08:14:50 <benzrf> ^_^
08:14:58 <ChongLi> buildExpressionParser
08:15:00 <benzrf> my brain feels good
08:15:09 <Blkt> ChongLi: let me check the docs
08:15:14 <ChongLi> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Expr.html
08:15:57 <benzrf> how do you define bind in terms of join again?
08:16:01 <benzrf> :t join
08:16:02 <lambdabot> Monad m => m (m a) -> m a
08:16:04 <benzrf> :t bind1
08:16:05 <lambdabot> Not in scope: `bind1'
08:16:08 <benzrf> :t (>>=)
08:16:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:16:38 <Blkt> ChongLi: oh my, that does exactly the trick...
08:16:52 <benzrf> oh right
08:17:03 <ChongLi> Blkt: yeah, these things are very common :)
08:17:04 <Sagi> benzrf: join a = (a >>=)
08:17:06 <benzrf> right
08:17:11 <benzrf> but als0o
08:17:16 <Sagi> :t (a >>=)
08:17:17 <lambdabot>     Couldn't match expected type `m0 a0' with actual type `Expr'
08:17:17 <lambdabot>     In the first argument of `(>>=)', namely `a'
08:17:17 <lambdabot>     In the expression: (a >>=)
08:17:19 <benzrf> m >>= f = join (fmap f m)
08:17:45 <benzrf> :t \m f -> join (fmap f m)
08:17:46 <lambdabot> (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
08:17:49 <benzrf> ;D
08:17:50 <Sagi> err, that was wrong, sorry
08:18:35 <Sagi> grr, why does cabal not work
08:18:51 <Sagi> I don't get why cabal install cabal does not simply yield a new cabal binary at the end.
08:19:06 <Sagi> it doesn't give me any errors, yet it also doesn't produce anything useful.
08:19:27 * hackagebot snap-core 0.9.6.0 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.6.0 (GregoryCollins)
08:20:44 <gwern> http://hackage.haskell.org/package/push-notify so I was looking at this, and do we still not have reverse dependencies on hackage?
08:21:00 * Sagi tries to get a simple stack trace to find out which 'undefined' call is triggering and has been messing with the build system for over an hour.
08:21:07 <Sagi> how difficult can this be?!
08:21:50 <merijn> gwern: They exist already, just not in the main interface
08:21:59 <gwern> 'Reverse dependencies. This feature has been implemented but is currently disabled because it used to much memory. This should be investigated, the data structured adjusted and the feature re-enabled. The number of reverse dependencies should be an important component of a package popularity/quality metric. See issue #40.' http://hackage.haskell.org/new-features oh, I guess that answers my question
08:22:07 <merijn> gwern: http://packdeps.haskellers.com/reverse
08:22:31 <gwern> (how could it use too much memory? it's an operation on a very small dag, it should use like hardly any memory at all...)
08:22:40 <Philonous> gwern http://packdeps.haskellers.com/reverse
08:23:11 <byorgey> gwern: it's not a small dag when you include all different versions of each package as a separate node
08:23:41 <gwern> byorgey: that's still what, 20k nodes? that's really small compared to lots of realworld datasets
08:24:42 <byorgey> gwern: well, true, I just remember someone talking about package versions being part of the problem.  But I don't really understand the issues.
08:25:04 <byorgey> gwern: writing up the GSoC results?
08:25:15 <gwern> yes
08:25:22 <byorgey> great, I look forward to reading it
08:25:35 <gwern> looks like the mobile stuff was a failure. *no one* is using it like 4 months later
08:25:56 <gwern> and the download count is like... 12. that could be bots and the author
08:27:20 <byorgey> looks that way
08:29:28 * hackagebot ihaskell 0.3.0.1 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.3.0.1 (gibiansky)
08:29:30 * hackagebot snap-server 0.9.4.0 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.4.0 (GregoryCollins)
08:32:48 * gwern marks mobile unsuccessful and moves on to better cabal dep solver errors
08:35:24 <gwern> http://cabal-summer.blogspot.de/ not very promising looking
08:37:38 <gwern> hm. no pull requests in https://github.com/mr-/cabal/pulls?direction=desc&page=1&sort=created&state=closed , no 'mr-' in https://github.com/haskell/cabal/graphs/contributors ...
08:37:51 <flazz> when developing against the haskell platform is it safe to not specify versions for platform packagaed libraries?
08:38:40 <ChongLi> flazz: usually you want to specify a version of base, at least
08:38:50 <flazz> ok
08:39:02 <monochrom> I don't know how safe is that. libraries change. it affects building.
08:39:20 <gwern> 'martin ruderer site:haskell.org/pipermail/cabal-devel/' nothing more recent than june
08:39:29 * hackagebot snap 0.13.2.0 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.0 (GregoryCollins)
08:39:32 <Hurg> hello everyone.
08:39:54 <ChongLi> hullo
08:40:30 <Hurg> How do I think recursively? I have a problem with that and I need it for this language and for the sake of efficiency i guess.
08:40:52 <Sagi> Can anyone have a look at http://lpaste.net/98430 and give me a hand?
08:40:59 <ChongLi> that's a difficult question to answer!
08:41:11 <Hurg> Tell that to my proessor
08:41:21 <Hurg> professor
08:41:25 <byorgey> Hurg: get lots of practice.
08:41:34 <Hurg> I guess he would tell me it's trivial, hehe.
08:41:38 <scriptor> look at your recursive functions as mathematical definitions
08:41:43 <scriptor> rather than step-by-step instructions
08:41:54 <ChongLi> Sagi: what about using ghci to debug it?
08:42:04 <ChongLi> ghci can let you set breakpoints and such
08:42:13 <flazz> does the haskell platform include an EitherT implementation?
08:42:18 <merijn> Sagi: Orthogonal question: Haskell stack traces are often...not quite as helpful as you'd expect. Have you tried using trace?
08:42:29 <Sagi> no
08:42:34 <ChongLi> flazz: it's called errorT
08:42:38 <ChongLi> err
08:42:39 <ChongLi> ErrorT
08:42:42 <monochrom> it is easy to think recursively. to add up 10 numbers, add up 9 numbers and then adjust for the remaining one
08:42:44 <ChongLi> :t ErrorT
08:42:45 <Sagi> ChongLi, merijn: perhaps I'm trying to use the wrong tool in the toolbox
08:42:45 <lambdabot> m (Either e a) -> ErrorT e m a
08:42:56 <gwern> preflex: seen dcoutts
08:42:56 <preflex>  dcoutts was last seen on #ghc 2 days, 19 hours, 3 minutes and 21 seconds ago, saying: but cabal-install will be well within its rights to check the resulting package reg info and complain loudly if it's not what it asked for.
08:43:01 <merijn> Sagi: Have a look at Debug.Trace
08:43:12 <Philonous> ChongLi, That type is a lie.
08:43:13 <merijn> Sagi: That lets you add (unsafe, obviously) debug prints inside pure code
08:43:29 <monochrom> or perhaps, add up 5 numbers, add up the other 5 numbers, put a + between those two answers
08:43:53 <Hurg> byorgey: hmm, that's what I try. And I do lots of retyping to get a feeling for it, but alas.
08:43:53 <Sagi> merijn: oh, I know that one. But that seems like a big leap to just get the line number of a call site?
08:43:57 <flazz> ChongLi: thanks
08:44:08 <Philonous> flazz, ErrorT ist EitherT if you ignore the Error predicate
08:44:30 * hackagebot snap-testing 0.2.0.0 - A library for BDD-style testing with the Snap Web Framework  http://hackage.haskell.org/package/snap-testing-0.2.0.0 (DanielPatterson)
08:44:44 <monochrom> to find a book in 3 bookshelves, you ask Sally to search one bookshelf, Robert to search another, and yourself to search the third one. except, you are also Sally and Robert.
08:44:56 <merijn> Sagi: The problem with a stack trace is that the undefined may be evaluated in a far different place than where it's passed as an argument
08:44:58 <ChongLi> Sagi: you can annotate line numbers
08:44:58 <Hurg> scriptor: hmm yeah, I try that. For an example, the take function, I try to solve it, but I don't get it.
08:45:07 <monochrom> so just think divide-and-conquer
08:45:17 <merijn> Sagi: (Also, this is why it's helpful to use 'error' instead of undefined)
08:45:44 <ChongLi> another way to think recursively is with the addition of natural numbers
08:45:54 <Sagi> merijn: ah, good point.
08:45:54 <scriptor> Hurg: let's start with something simpler, can you whip up a recursive copy?
08:46:02 <scriptor> to copy a list
08:46:12 <monochrom> to take 10 items from a list, take 1 item, then take 9 more items.
08:46:49 <Sagi> I guess I could try using ghci and breakpoints, but I would have to figure out how to pass command line args, off to do that :-)
08:46:55 <ChongLi> a natural number is either zero or the successor of another natural number
08:47:02 <scriptor> monochrom: the "take" in "take 1 item" is confusing there
08:47:03 <monochrom> in concrete code, you start writing "take n (x:xs) = ???". x is already 1 item. so just take n-1 items from xs
08:47:05 <scriptor> or could be
08:47:20 <monochrom> yes ok, but now I have concrete code to show it
08:47:36 <Sagi> oh, it's simply :main <args>, lol
08:48:01 <Hurg> Are there some easy to do exercises to learn recursion?
08:48:29 <scriptor> Hurg: have you read lyah?
08:48:30 <Sagi> ChongLi: hmm, I cannot seem to set breakpoints on non-interpreted files. So that seems like a dead end.
08:48:45 <ChongLi> Sagi: is this error in a library?
08:48:48 <scriptor> Hurg: one thing that helped me was to try and guess a function's definition on my own before reading it in the book
08:48:56 <scriptor> I think there's a version of the book with exercises, too
08:48:58 <Sagi> ChongLi, merijn: seems like the thing to do is to convert all foo = undefined to foo = error "undefined in foo" or similar
08:49:02 <monochrom> learn divide-and-conquer. learn code re-use. they combined subsume recursion.
08:49:43 <Hurg> scriptor: I am doing it right now. I have written the code for take' and try to solve it by using it.
08:49:50 <monochrom> here is why recursion is merely divide-and-conquer. to take 10 items, take 1 item and take 9 item.
08:50:09 <Sagi> ChongLi: all over my code basically. I wrote most of the project, but stubbed out code all over the place because it wasn't important just yet. Now I'm trying to fill in the gaps, while running tests. But that only works if I know which gaps. :-P
08:50:15 <merijn> GHC warns me)
08:50:27 <merijn> Whoops
08:50:41 <monochrom> here is why recursion is merely code reuse. to take 10 items, ... take 9 items. how to take 9 items? call the same function that took 10 items, just with different parameters.
08:50:58 <ChongLi> Sagi: ahh, have you tried just doing a global search and replace?
08:51:18 <ChongLi> to convert all those foo = undefined into appropriate errors?
08:51:27 <ChongLi> sometimes the low-tech approach is the easiest
08:51:33 <monochrom> it's just reusing the same code you're writing. there is nothing more.
08:52:01 <Sagi> ChongLi: yeah, I guess that's what I'll do now.
08:52:19 <ChongLi> Sagi: I had a similar issue with "Prelude.head: empty list"
08:52:27 <ChongLi> it was easier just to grep for head
08:53:30 <ChongLi> Hurg: if you think of natural numbers as just piles of beads or apple or something
08:53:34 <monochrom> recursion is just calling a function to do a subtask. oh it happens to be the same function you're writing! big deal.
08:53:37 <ChongLi> how would you go about adding them?
08:53:40 <gwern> https://www.google-melange.com/gsoc/proposal/review/google/gsoc2013/refold/71002 https://github.com/haskell/cabal/issues/976 hm. not sure how to evaluate that.
08:53:50 <ChongLi> take one apple from the left pile and place it in the right
08:53:58 <ChongLi> and then repeat that process until one pile is empty
08:54:09 <ChongLi> this is all recursion is
08:54:30 <ChongLi> a name for "repeat what I just did until I can't anymore, then return my result"
08:54:30 <Philonous> monochrom, Actually, it kinda is a big deal. You use the function before you're finished defining it. That can be surprising.
08:55:25 <katana-> think about how data is built up piece by piece, and basic recursions takes it apart piece by piece
08:55:37 <Hurg> http://lpaste.net/98431 is it like this?
08:56:19 <katana-> >take' _ []      = []
08:56:20 <katana-> no
08:56:21 <merijn> Sagi: That's what I usually do, that or leave patterns undefined so GHC warns me
08:56:26 <katana-> delete this line
08:56:41 <monochrom> if you keep considering it a big deal, you will never overcome the psychological barrier. and that is the only barrier.
08:58:34 <Hurg> http://lpaste.net/98431 better?
08:59:38 <monochrom> I use a function before I'm finished defining it all the time, recursion or not.
08:59:45 <katana-> did you try running the function
08:59:55 <monochrom> I'm pretty sure everyone does.
09:01:34 <Hurg> katana: works!
09:01:47 <Hurg> katana: but is this the way to think about it?
09:02:17 <katana-> yes
09:02:31 <katana-> good work
09:02:32 <monochrom> to take 10 items, you take 1 item yourself, and ask Sally to take 9 items. mytake n (x:xs) = x : sallytake (n-1) xs
09:02:47 <ChongLi> Hurg: http://lpaste.net/98433
09:02:59 <monochrom> this has "no" recursion so far, and you do that all the time. you haven't written sallytake.
09:03:05 <ChongLi> does this make sense?
09:03:12 <monochrom> now just write: sallytake = mytake. you're done.
09:04:30 <Hurg> ChongLi: a lot. I wonder why the professors never shows us.
09:04:50 <ChongLi> Hurg: the professors never went through SICP
09:05:16 <ChongLi> this is known as "the substitution model for evaluation"
09:05:32 <ChongLi> it's something we all learned in elementary school math
09:05:49 <ChongLi> how to simplify an expression by substitution
09:05:53 <monochrom> I don't know about your prof. I would show it to you, but I would also tell you it is not useful.
09:06:15 <ChongLi> monochrom: what's not useful?
09:06:24 <monochrom> you know how to execute code. big deal. the computer already does that better than you.
09:06:42 <monochrom> and it tells you nothing about how to invent that code in the first place.
09:06:43 <ChongLi> monochrom: the point is to gain an understanding of how the computer works
09:08:14 <monochrom> knowing how to execute code is useful for knowing how to execute code. yes. that's an obvious tautology.
09:09:03 <ChongLi> I don't appreciate your tone
09:09:49 <thebnq> eventually i think its good for understanding optimizations
09:09:56 <t7> the first rule of tautology club...
09:10:08 <thebnq> rather than have a case by case basis of whats generally 'better'
09:10:26 <Hurg> I start to hate university, they spout trivial all the time and expect you to do everything. Sure it's not a place for spoonfeeding and you gotta learn it for yourself, but I really wish I, as a total beginner, could have gained total insight about this. This is why I need to retry my A&D class. Oh well, life lessons.
09:10:35 <monochrom> yes, but the current problem is not figuring out optimizations.
09:11:02 <Hurg> ChongLi: thanks for this, gotta read that
09:11:05 <Sagi> ChongLi: lol, now I get the empty list too :-)
09:11:20 <ChongLi> Sagi: now search for head!
09:11:28 <ChongLi> Hurg: going to read SICP?
09:11:37 <ChongLi> Hurg: you might also enjoy the lectures
09:11:38 <Hurg> why not?
09:11:57 <ChongLi> the lecturers are very good
09:12:16 <Sagi> ChongLi: yeah, got it :)
09:12:26 <Hurg> I suck at CS/IT, you can only become better or burn everything while trying. ;)
09:12:54 <Sagi> doesn't help you much if you it three times within one function though. I should probably reduce its size and test them individually.
09:13:12 <ChongLi> Hurg: https://www.youtube.com/playlist?list=PLE18841CABEA24090
09:13:17 <ChongLi> this is the full course
09:13:34 <ChongLi> if you go through the lectures and read the text book and do the exercises
09:13:43 <ChongLi> you will feel very comfortable with all of this stuff
09:13:53 <monochrom> and I know where you can find empirical evidence for what I said, too. students who focus on unfolding recursion take longer to learn and are less able to invent recursive code. students who don't focus on unfolding recursion take less time to learn and are more able to invent recursive code.
09:14:21 <Hurg> ChongLi: you're the best. I wish I could hug you through the  internet.
09:14:36 <ChongLi> Hurg: no problem :)
09:15:04 <monochrom> but like I said, I would still show you execution. I agree that you must know. but it's for its own sake only.
09:15:37 <monochrom> and I say this as the author of http://www.vex.net/~trebla/haskell/lazy.xhtml
09:15:45 <Hurg> ChongLi: Oh god, it's the guy who crossed the Computer Science. This will be fun.
09:16:07 <ChongLi> Hurg: yeah, that's Harold Abelson
09:16:11 <ChongLi> co-founder of creative commons
09:16:33 <ChongLi> and one of the founders of the free software movement (along with Richard Stallman, of course)
09:16:35 <katana-> The way I think of recursion is to specify what the function will do before implemnting it, and then you are able to use that as a subroutine (as long as you use it on smaller data than input)
09:16:39 <ChongLi> and a whole host of other things
09:16:58 <monochrom> yes that's what I do too
09:17:17 <ChongLi> or abstraction, in other words
09:17:36 <ChongLi> first you create a machine and then you give it a name
09:17:37 <katana-> it's surprise to see you say that unfolding is not helpful but thinking about it, well yes - it's just for checking, not for writing code
09:17:51 <ChongLi> that way you can refer to its name without having to recreate it every time
09:22:19 <tippenein> monochrom: your writeups on vex.net are really good. thanks
09:22:28 <monochrom> thank you for choosing monochrom!
09:39:37 * hackagebot lazyio 0.1 - Run IO actions lazily while respecting their order  http://hackage.haskell.org/package/lazyio-0.1 (HenningThielemann)
09:39:39 * hackagebot http-monad 0.1.1 - Monad abstraction for HTTP allowing lazy transfer and non-I/O simulation  http://hackage.haskell.org/package/http-monad-0.1.1 (HenningThielemann)
09:40:13 <monochrom> hrm, lazy and respect order? that's interesting
09:42:04 <jfischoff> maybe if I have actions a, b, c and require c, a and b get executed first?
09:42:12 <Hurg> ChongLi: Oookay, now I tried to understand a recursion on the reverse function, but I have the feeling I should do SICP and focus on what I can rescue in my classes for now. http://lpaste.net/98434
09:43:00 <monochrom> yes, something like that
09:44:35 <ChongLi> Hurg: haha
09:44:37 * hackagebot Stasis 0.0.1 - A simple MVCC like library  http://hackage.haskell.org/package/Stasis-0.0.1 (zcourts)
09:44:42 <ChongLi> Hurg: stick with SICP
09:44:56 <ChongLi> it's fantastic
09:45:55 <monochrom> Hurg: http://lpaste.net/98436
09:48:19 <Sonarpulse> haskell-mode from melpa is currently not installing
09:48:45 <Sonarpulse> anbody know a work around so I can get cabal-repl support in haskell-mode?
09:49:39 <klrr> anyone know any swedish Haskell companies except Functor AB?
09:51:02 <Hurg> ChongLi: Alright, time to focus on general chemistry and microbiology while I refurbish the rest
09:51:28 <finchd> :win 42
09:51:29 <ChongLi> Hurg: sounds like you've got a lot on your plate!
09:51:52 <Hurg> monochrome: http://lpaste.net/98436 I guess this must be it. To be honest it IS fun and I must admit, I have yet to ingrain the mindset of the language
09:53:19 <Hurg> ChongLi:Yeah, have many deficiencies. aaand some other problems. Guess won't finish till I am thirty.
09:53:38 <yesthisisuser> klrr: I heard Scrive.com was using Haskell
09:53:55 <Hurg> monochrom: http://lpaste.net/98436 I guess this must be it. To be honest it IS fun and I must admit, I have yet to ingrain the mindset of the language
09:54:04 <yesthisisuser> *are using
09:54:14 <ChongLi> Hurg: ahhh! don't remind me, that's in just 3 weeks for me :(
09:55:28 <Hurg> ChongLi: also a late bloomer? Or do you mean, you will finish your studies in three weeks?
09:55:32 <klrr> yesthisisuser: cool
09:56:33 <ChongLi> Hurg: turn thirty!
09:58:48 <Hurg> Come on, if you do it right this will be your time of your prime: A stable job, a good carreer, maybe you'Re single and you'll have the money and freedom to do many things you never had the time for before. I look forward being thirty and then living my life peacefully.
09:59:19 <ChongLi> yeah, I'm not that worried about it :)
09:59:39 * hackagebot flamethrower 0.0.1.3 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.1.3 (charmander)
10:02:24 <klrr> is there anytrhing wrong with killing threads inside themselfs?
10:03:49 <tippenein> http://lpaste.net/98438 need to gzip decompress a list of results from HXT scraping a page
10:03:56 <Hurg> klrr: like dividing by zero? If I try to visualize it, it looks like they are falling apart into itself... I see myself out for now
10:07:57 <klrr> Hurg: i mean like after im done with a thread i simply call "myThreadId >>= killThread"
10:08:05 <klrr> from itself obviously
10:08:16 <klrr> (im new to threads and such :x)
10:09:00 <Hurg> klrr:(don't worry, I am new, too.)
10:10:15 <klrr> or does the thread get killed simply by returning unit?
10:10:19 <klrr> return ()
10:10:45 <ChongLi> klrr: return doesn't really do what it says :)
10:10:52 <Iceland_jack> klrr: The thread doesn't return ()
10:10:52 <ChongLi> :t return
10:10:53 <lambdabot> Monad m => a -> m a
10:11:02 <ChongLi> :t return ()
10:11:03 <lambdabot> Monad m => m ()
10:11:16 <ChongLi> it just gives you a value of type m ()
10:11:33 <klrr> well, is it possible to have a thread that simply dies when its done without having ANY other thread interacting with it?
10:11:49 <ChongLi> sure
10:11:52 <Iceland_jack> klrr: yes
10:11:53 <klrr> okey
10:11:58 <intrados> klrr: Have you looked at Control.Concurrent.Async?
10:12:06 <ChongLi> a thread dies when it finishes evaluating its expression
10:12:20 <Iceland_jack> Why don't you try it out yourself klrr, fork 10 threads that print their ThreadID that kill their own ThreadID after 1, 2, 3, 4... seconds
10:12:23 <klrr> so i dont need to call "myThreadId >>= killThread"?
10:12:36 <Iceland_jack> No
10:12:40 <Iceland_jack> but you can :)
10:12:44 <klrr> intrados: a little bit, is it useful in this case?
10:12:53 <klrr> okey so i should simply end it with "return ()"?
10:13:02 <ChongLi> killing threads is for when they're stuck in an infinite loop and otherwise not responding
10:13:05 <Iceland_jack> klrr: You don't need to end it with anything
10:13:25 <tippenein> unless it's in a do block..
10:13:28 <Iceland_jack> klrr: If you do
10:13:28 <Iceland_jack>     forkIO $ do
10:13:28 <Iceland_jack>       print 1
10:13:28 <Iceland_jack>       print 2
10:13:30 <intrados> klrr: I don't know much about your use case, but it is in some cases/senses a higher level/easier approach to concurrency
10:13:32 <Iceland_jack> the thread terminates after printing 1 and then 2
10:13:43 <klrr> okey
10:14:04 <klrr> is it good or bad design to have all recieved messages put in a new thread and let it die when done with it?
10:14:08 <klrr> im writing IRC bot
10:14:28 <ChongLi> threads are cheap
10:14:40 <Iceland_jack> klrr: What about messages that are received after that?
10:14:55 <tippenein> anyone have insight on my earlier question about GZip.decompress?
10:15:26 <klrr> well, it basically create a new thread for EACH message i recieve from the IRC server, and the thread then parse it and checks if it should do anything and after doing stuff it is supposed to terminate
10:15:39 <ChongLi> tippenein: the utf8 errors?
10:16:06 <ChongLi> if you want utf8 you should probably use Data.Text
10:16:16 <ChongLi> oh
10:17:18 <Iceland_jack> klrr: You'll want to process the messages sequentially wouldn't you?
10:17:24 <ChongLi> decompress :: Format -> DecompressParams -> ByteString -> ByteString
10:17:42 <ChongLi> tippenein: you're not supplying all the arguments needed
10:17:45 <klrr> Iceland_jack: how do you mean?
10:18:17 <klrr> my current theory is that it will get faster since if one message takes longer time it can do some other (like PONGS etc.) in meantime
10:19:03 <Iceland_jack> What exactly do you expect will take so long?
10:19:08 <ChongLi> tippenein: try something like this: let foo_decompressed = GZ.decompress gzipFormat defaultDecompressParams foo
10:19:26 <ChongLi> where foo is a ByteString
10:20:04 <ChongLi> Iceland_jack: the sequentiality of IRC is a bit of a lie :)
10:20:10 <tippenein> runX $ doc >>> css "scoretableContainer.scoretableStatement" ! "h2"
10:20:18 <ChongLi> every user gets their messages in potentially different orders
10:20:19 <Iceland_jack> ChongLi: (there's no need to add to it then ;])
10:20:44 <klrr> Iceland_jack: running a command
10:20:51 <klrr> Iceland_jack: that i send via IRC to my bot
10:20:52 <Iceland_jack> klrr: Then you should take that as a special case
10:21:14 <klrr> so i should first parse and then only fork those who contains commands?
10:21:21 <Iceland_jack> I.e.
10:21:21 <Iceland_jack>     case parse msg of
10:21:21 <Iceland_jack>       Command cmd   → forkIO (runCommand cmd)
10:21:21 <Iceland_jack>       somethingElse → ...
10:21:27 <Iceland_jack> yes for example
10:21:30 <klrr> oeky
10:21:51 <klrr> thanks, so having all message handling in other threads is bad idea?
10:22:05 <tippenein> :t Codec.Compression.GZip.decompress
10:22:06 <lambdabot> BSLC.ByteString -> BSLC.ByteString
10:22:18 <tippenein> that's the decompress I'm using
10:22:57 <tippenein> ChongLi: where'd you find that other decompress
10:22:58 <Iceland_jack> klrr: You /can/ do it, I don't see what it gains you
10:23:19 <ChongLi> tippenein: http://hackage.haskell.org/package/zlib-0.5.4.1/docs/Codec-Compression-Zlib-Internal.html#v:GZip
10:23:43 <ChongLi> I don't know which is a better lib to use
10:24:01 <tippenein> ooo, it says GZip is deprecated
10:24:10 <Iceland_jack> unless you expect to be spending significantly more time parsing a short string and displaying it (or what ever you plan on doing) than the time it takes to fork a new thread
10:24:23 <tippenein> or that's just Format constructors
10:24:35 <ChongLi> tippenein: yeah, there are smart constructors to take their place
10:25:35 <tippenein> oo, gzipOrZlibFormat is perfect
10:25:40 <klrr> Iceland_jack: okey
10:26:31 <Iceland_jack> klrr: Also let's say that you plan on printing incoming messages to stdout
10:26:36 <tippenein> :t Codec.Compression.Zlib.Internal.gzipOrZlibFormat
10:26:37 <lambdabot> zlib-0.5.4.1:Codec.Compression.Zlib.Stream.Format
10:27:08 <Iceland_jack> If you get ["hello", "world"] and fork two threads to parse and output them their content will probably appear interleaved
10:27:51 <Iceland_jack> > forM_ ["hello", "world"] $ \msg → forkIO (putStrLn msg)
10:27:51 <Iceland_jack> hewlolrol
10:27:51 <Iceland_jack> d
10:27:52 <lambdabot>  Not in scope: `forkIO'
10:35:31 <jfischoff> c
10:48:08 <Adsisco> anybody got any idea how should i implement the quickfind c algorithm in haskell?
10:49:33 <ChongLi> Adsisco: this? https://github.com/akojo/quickfind
10:50:16 <Adsisco> http://jaysonlagare.blogspot.sg/2011/01/union-find-algorithms.html
10:50:21 <Adsisco> this haha
10:50:50 <Adsisco> im trying to learn haskell and algorithm from sedgwick's book
10:51:00 <Adsisco> and i'm getting stuck at the very first example -_-
10:51:01 <aleksejs_> will it be effective enough for integer sqrt?
10:51:01 <aleksejs_> > let intSqrt x = length . takeWhile (<=x) $ scanl (\x y -> x+2*y+1) 1 [1..] in intSqrt 150
10:51:02 <lambdabot>  12
10:52:01 <aleksejs_> :t length . takeWhile (<=x) $ scanl (\x y -> x+2*y+1) 1 [1..]
10:52:02 <lambdabot> Int
10:52:36 <ChongLi> Adsisco: so this is a nested for loop
10:53:06 <ReinH> Adsisco: I'd recommend not using manual translation from C as your vehicle for learning Haskell
10:53:18 <ReinH> imperative data structures and algorithms do not always translate nicely
10:53:19 <zeiris> Algorithms are rooted in data structures: this one uses a mutable array, which is doable in Haskell but won't be hitting its strengths.
10:53:26 <Adsisco> @ReinH i'm starting to find it a bad idea too haha
10:53:26 <lambdabot> Unknown command, try @list
10:53:55 <zeiris> Figuring out what type signatures the algorithm involves, and providing a high level equivalent may help you discover interesting properties, however.
10:53:56 <ReinH> Adsisco: if you want to see examples of data structures and algorithms in Haskell, check out Functional Data Structures by Okasaki and Pearls of Functional Algorithm Design by Bird
10:54:05 <ChongLi> Adsisco: keep in mind that the original algorithm had to undergo a lot of nonsense to be translated into this imperative one
10:54:22 <Adsisco> ok, will check them out
10:54:24 <ChongLi> if you want to do it in Haskell, it may be easier to find an original definiton of union find
10:54:26 <Adsisco> thanks for the great advices
10:54:42 <SaBer> Adsisco: you should first understand the algorithm and data structure. Union-Find is more about the datastructure than the algorithm
10:54:50 <ReinH> (Okasaki isn't in Haskell but it is in a psuedo langauge that is easy to translate into Haskell)
10:54:50 * hackagebot rascal 1.1.6 - A command-line client for Reddit  http://hackage.haskell.org/package/rascal-1.1.6 (soli)
10:55:14 <Adsisco> any good book on data structure for haskell besides the 2 recommended?
10:55:24 <Adsisco> i started with learn you a haskell
10:55:36 <SaBer> Adsisco: e.g. http://en.wikipedia.org/wiki/Disjoint-set_data_structure gives a broader view on the subject
10:56:35 <katana-> ocaml is "a pseudo language that's easy to translate to haskell", haha
10:56:42 <ChongLi> hahahaha
10:56:58 <danharaj> lol
10:57:02 <ReinH> katana-: wait it's ocaml?
10:57:04 <ReinH> I need to look again
10:59:23 <timthelion> I wonder, if haskell was re-written today, if typeclasses could be defined with laws attached, and every instance would then be quickchecked at compile time to see if it obeyed the laws.
10:59:41 <aleksejs_> this probably better:
10:59:41 <aleksejs_> > let intSqrt x = length . takeWhile (<=x) $ map (^2) [1..] in intSqrt 150
10:59:42 <lambdabot>  12
10:59:46 <ReinH> Oh yeah, Standard ML
10:59:55 <ReinH> not ocaml
11:00:20 <ChongLi> timthelion: then we couldn't have IO
11:00:21 <ReinH> with unicode variable names and such, which is what threw me I think
11:00:46 <tippenein> mapM (\s -> decompress gzipOrZlibFormat defaultDecompressParams s) stuff
11:00:56 <tippenein> where stuff :: IO [String]
11:01:03 <ChongLi> or seq
11:01:06 <ChongLi> take your pick :)
11:01:34 <timthelion> ChongLi: seq is a monad, or did I missunderstand something?
11:01:57 <ChongLi> no, seq allows you to distinguish between undefined and \s -> undefined s
11:02:08 <timthelion> ChongLi: I think IO is such an exception, that it could be just an exception to that rule...
11:02:22 <jle`> mm_freak_: that's neat :)
11:02:39 <jle`> mm_freak_: sounds like a useful generalization
11:02:40 <ChongLi> seq itself is a very nasty little bugger
11:02:46 <ChongLi> but we need it for efficiency
11:04:51 <triliyn> timthelion: look into dependent typing if you're interested in that kind of thing though
11:08:09 <ChongLi> on second thought
11:08:18 <ChongLi> seq causes all monads to violate the laws
11:08:43 <carter> yes
11:08:44 <carter> :)
11:08:51 <shachaf> Does it actually?
11:09:00 <ChongLi> shachaf: you can try it in ghci
11:09:01 <carter> i wrote an illegal monad (or at least illegal on on things that dont' terminate)
11:09:37 <ChongLi> > seq (undefined :: a -> Identity b) ()
11:09:38 <lambdabot>  *Exception: Prelude.undefined
11:09:43 <ChongLi> seq (return <=< undefined :: a -> Identity b) ()
11:09:46 <ChongLi> > seq (return <=< undefined :: a -> Identity b) ()
11:09:47 <lambdabot>  ()
11:10:15 <shachaf> Identity is not "all monads"
11:10:29 <ChongLi> > seq (return <=< undefined :: a -> Maybe b) ()
11:10:30 <lambdabot>  ()
11:10:38 <ChongLi> > seq (undefined :: a -> Maybe b) ()
11:10:39 <lambdabot>  *Exception: Prelude.undefined
11:15:36 <dawik> > concat $ map show (take 3 [1..])
11:15:38 <lambdabot>  "123"
11:16:01 <dawik> > concat $ map show $ take 3 [1..]
11:16:03 <lambdabot>  "123"
11:16:40 <Iceland_jack> > "123"
11:16:41 <lambdabot>  "123"
11:17:01 <dawik> Iceland_jack: you win
11:17:34 <Iceland_jack> I take pride in my ability to constant fold
11:26:47 <tippenein> :t fmap Codec.Compression.GZip.decompress
11:26:48 <lambdabot> Functor f => f BSLC.ByteString -> f BSLC.ByteString
11:33:50 <dleedev> is there a list somewhere of production web sites that use haskell?
11:34:32 <ChongLi> I think big commercial outfits that use Haskell sometimes keep it a secret
11:34:57 <ChongLi> you have to scan through job listings to find the truth :)
11:35:07 <k00mi> there is http://www.haskell.org/haskellwiki/Haskell_in_industry
11:35:20 <k00mi> not about websites specifically though
11:35:22 <skypers> hey
11:35:55 <jfischoff> ChongLi: why do you say that?
11:35:58 <skypers> how would you compute a sum of values inside a list?
11:36:02 <skypers> with sum + map
11:36:05 <ChongLi> jfischoff: competitive advantage
11:36:06 <skypers> or with a foldl?
11:36:12 <ChongLi> Paul Graham talks a lot about it
11:36:49 <jfischoff> ChongLi: no I mean how did you come to believe that? What information is your view based on?
11:37:09 <ChongLi> jfischoff: based on Paul Graham's essays
11:37:12 <skypers> > let a = [(1,2),(8,2),(10,-2)] in sum . map fst $ a
11:37:13 <lambdabot>  19
11:37:15 <ChongLi> his personal experience
11:37:16 <skypers> vs.
11:37:24 <ChongLi> it's what he did!
11:37:39 <skypers> > let a = [(1,2),(8,2),(10,-2)] in foldr ((+) . fst) 0 a
11:37:40 <lambdabot>  19
11:37:46 <ChongLi> calling it "my view" is a bit too strong
11:37:53 <ChongLi> it's more of a suspicion
11:37:54 <skypers> which one is the faster?
11:38:51 <ChongLi> skypers: they should be equivalent if the rewrite rules for build/foldr fusion hold
11:39:04 <jfischoff> I seen that belief dispelled but I've never seen it confirmed.
11:39:19 <skypers> ok ChongLi
11:39:21 <skypers> thank you
11:39:33 <skypers> I think the sum + map is more intuitive to me
11:39:44 <ChongLi> of course, it's more abstract
11:42:40 <skypers> ChongLi: yep :)
11:43:48 <levi> "of course, it's more abstract" <- this seems like a suspect sentiment to me. If it held, everyone would find monads and category theory very intuitive. :P
11:44:24 <ChongLi> levi: what does intuitive even mean?
11:44:56 * hackagebot snap-cors 1.2.0 - Add CORS headers to Snap applications  http://hackage.haskell.org/package/snap-cors-1.2.0 (OliverCharles)
11:45:00 <Roklobsta> everyone except for me
11:45:14 <levi> ChongLi: What would it have to mean for your statement to make sense?
11:45:21 <ChongLi> if you're going to take the dictionary definition: 1.
11:45:23 <ChongLi> direct perception of truth, fact, etc., independent of any reasoning process; immediate apprehension.
11:45:47 <ChongLi> then almost nothing useful behaves this way
11:46:29 <ChongLi> the trouble with monads and category theory is that they violate people's prior assumptions
11:46:40 <levi> I just don't think "more abstract" is equivalent to "more intuitive" in general.
11:46:44 <ChongLi> but it is not monads and category theory's *fault* that people have these assumptions
11:46:57 <shachaf> Do you really have to say "monads and category theory" in the same sentence like that?
11:47:19 <levi> Things are intuitive when their abstraction level *matches* the way you're accustomed to thinking about them.
11:47:23 <ChongLi> shachaf: I was making repeated reference to levi's message
11:47:50 <ChongLi> levi: right, and so it'd be silly to expect everyone to be accustomed to what we know when we meet them
11:48:28 <levi> But things that are *more* abstract than the way you're accustomed to thinking about them are also not intuitive.
11:48:30 <ChongLi> it's like if we were all speaking German in here
11:48:38 <ChongLi> and people got mad because they didn't understand it
11:48:47 <ChongLi> is that because German is unintuitive?
11:48:57 <levi> I think you're missing my point.
11:49:07 <levi> But that's okay; forget I made it.
11:49:22 <ChongLi> no, I think my reasoning can be applied to abstraction as well
11:49:46 <ChongLi> we simply don't teach children about it in school
11:50:12 <ChongLi> instead we teach them nonsense such as rote memorization of facts
11:50:29 <ChongLi> we make them worse at learning than they started with
11:50:31 <levi> My original statement has nothing to do with what you're saying now.
11:51:03 <ChongLi> yeah, sorry, I went on a rant :)
11:51:17 <novodinia> I'm reading http://book.realworldhaskell.org/read/types-and-functions.html and I'm wondering: what class of errors will strong typing eliminate? I see that a lot of people still write unit tests, so what classes of errors are you eliminating?
11:51:38 <jfischoff> > 1 + "hey"
11:51:39 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
11:51:39 <lambdabot>    arising from a use of `GHC.Num.+'
11:51:39 <lambdabot>  Possible fix:
11:51:39 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])
11:51:58 <ChongLi> novodinia: you can eliminate any class of errors for which you can write types to distinguish
11:52:04 <novodinia> I meant static typing
11:52:08 <novodinia> My bad
11:52:26 <ChongLi> the more expressive your type system, the more power you have to eliminate classes of errors
11:52:26 <jfischoff> novodinia: the amount of errors is actually very large in theory.
11:52:28 <novodinia> You can eliminate type coercion, I understand that
11:52:35 <novodinia> ...with strong typing
11:52:45 <jfischoff> yeah that's the common case
11:52:55 <novodinia> I meant, static typing though since that's where the "eliminating certain classes of errors" phrase is brought up
11:53:21 <jfischoff> but other end you can GADTs to encode singleton types that can ensure pretty much any invariant you can think up
11:53:28 <jfischoff> in haskell that is
11:53:39 <levi> I just wanted to point out that more abstraction doesn't always make things more intuitive. Once you go *more abstract* than people typically think about, you may gain expressiveness but you lose intutiveness for the untrained.
11:53:42 <jfischoff> in something like Agda you have even greater power
11:54:21 <ChongLi> novodinia: array bounds checking, null pointer dereferencing, integer overflow, uninitialized variables
11:54:55 <ChongLi> http://www.st.cs.uni-saarland.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
11:55:19 <jfischoff> in practice in haskell we use sum types to cover our case, polymorphism to ensure that properties are held over all possible types
11:55:33 <quup> hi, how would I make a pattern for f::String -> String  such that it matches all strings starting with say 'A'?  f 'A':x = 'A' just gives me "Parse error in pattern: f"
11:55:44 <ChongLi> there's actually an argument going on about this on hacker news right now!
11:55:59 <ChongLi> I linked a Bob Harper article about it :)
11:56:05 <ChongLi> and I totally agree with him
11:56:07 <carter> which thread?
11:56:13 <Cale> quup: You're missing parens
11:56:21 <Cale> f ('A':x)
11:56:43 <ChongLi> https://news.ycombinator.com/item?id=7051611
11:56:45 <jfischoff> novodinia: think of bug, and maybe we can think of types could help prevent it
11:56:49 <Cale> f 'A':x would parse as (f 'A') : x
11:56:58 <quup> Cale: oh! thanks
11:57:29 <ChongLi> I think Bob Harper makes a very good point when he says that advocates of dynamic typing confuse types with classes
11:57:58 <ChongLi> types are what ensure our program is correct, classes give our values dynamic behaviour at runtime
11:58:18 <ChongLi> sum types are what give us the ability to classify different values of the same type
11:58:24 <carter> jfischoff: have you seen the idris DSL error reporting demo?
11:58:41 <jfischoff> yes
11:59:03 <ChongLi> viewed in that light, type classes are sort of like a globally namespaced sum type
11:59:06 <simpson> ChongLi: Is there a difference in typing between e.g. Forth and Factor?
11:59:08 <Cale> Where by classes you mean existentials? :)
11:59:11 <levi> ChongLi: I tried to explain that perspective on dynamically typed languages here a while ago.
11:59:44 <ChongLi> levi: it's tricky because the words have so many ambiguous meanings :)
11:59:48 <levi> Yes.
12:00:11 <Cale> novodinia: Let me give you an example
12:00:17 <Cale> novodinia: If you're still here?
12:00:42 <levi> simpson: To answer that question requires a common definition of what 'typing' is.
12:01:11 <Cale> Aren't Forth and Factor both untyped?
12:01:26 <Cale> Yeah, they are.
12:01:49 <levi> Depends on what you mean by 'typed'. If you include dynamic typing, then Factor is dynamically typed.
12:01:57 <lpsmith> Ugh,  running into cabal hell;  deps are rather messed up on hackage now.
12:01:58 <levi> Forth is just untyped.
12:02:03 <ChongLi> Bob Harper would probably define types as "propositions for which you provide proofs which are then checked by the compiler"
12:02:11 <levi> Factor does do static stack-effect inference, though.
12:02:15 <exicer> Anyone know with Aeson, my code works fine if I just import Data.Aeson, but fails if I do import Data.Aeson (Object(..)) ?
12:02:16 <djahandarie> Based Bob Harper
12:02:18 <simpson> So surely Factor's *stack effects* are typed!
12:02:22 <Cale> Dynamic types aren't types ;)
12:03:08 <timthelion> I wonder if it would be possible to create a "lazy" build system for haskell, which would build only the parts of dependencies need by the package you were installing.
12:03:14 <levi> Cale: They're instances of a uni-type that are differentiated at run-time in a 'dynamically-typed' language.
12:03:20 <Cale> Well, unless you want to say "everything is the same type"
12:03:41 <Cale> That's what I usually refer to as "untyped"
12:03:51 <simpson> I think that there's a difference between Forth, where everything is just a number on the stack and it's up to the programmer to give it meaning, vs. something like C where the types are paper-thin but nominally in place.
12:03:52 <levi> There's not even any run-time differentiation in Forth.
12:04:00 <Cale> Though I guess unityped would be a better word
12:04:06 <timthelion> I guess one coudln't go too much more fine grained than the module level for fear of accidentally not including a type class instance...
12:04:12 <Hodapp> Forth is one of those languages I need to learn someday.
12:04:58 <levi> Forth is kind of like Bliss in that respect.
12:05:15 <Cale> I've used a bit of Forth, in Minecraft of all places. :)
12:05:28 <Cale> (There was a mod called RedPower 2 which had computers you could program in Forth)
12:06:05 <simpson> Funny intersection. I wrote the first compiler for 0x10c; it compiled a Forth to standalone code.
12:06:05 <silasm> Cale: I was hoping you had a forth interpreter on a redstone computer
12:06:33 <silasm> simpson: what's the status of 0x10c anyways?
12:06:35 <Cale> (which were complete 6502 emulators)
12:06:46 <simpson> silasm: Dead, I hope? I can wish.
12:06:55 <simpson> Minecraft's sadly not dead.
12:07:16 <Cale> Why are you hoping for it to be dead?
12:07:17 <silasm> haven't looked into either for a long while.
12:07:18 <levi> 0x10c is no longer being developed by the Minecraft dude, whose name slips my mind at the moment.
12:07:26 <alexdoom> markus
12:07:26 <silasm> levi: Notch
12:07:43 <simpson> Because I got tired of playing catchup for four years. Writing Minecraft code is only fun for about the first year and a half.
12:08:05 <simpson> And now people just poke fun at me for not "finishing simple features" like "full feature parity."
12:08:22 <alexdoom> simpson: did you use to work for mojang or what?
12:08:40 <Cale> alexdoom: I suspect simpson is a modder
12:08:49 <simpson> alexdoom: No. I wrote Bravo, a Minecraft server. It was pretty awesome in terms of speed and cleanliness, but never got feature parity.
12:08:55 <Cale> Oh, I see
12:08:57 <alexdoom> simpson: ah, i see
12:09:02 <Taneb> silasm, there are some people making there own version of 0x10c, see trillek.org
12:09:26 <simpson> But that's in the past, just like my GPU days. I guess I'm a sysadmin now?
12:09:36 <alexdoom> i've always wondered how good/bad the minecraft codebase is
12:09:42 <alexdoom> i've had this feeling its pretty... hackish
12:10:32 <silasm> Taneb: neat, I'll bookmark that.
12:10:35 <simpson> I hear that it's bad; I only can speak as to the reverse-engineering parts of it. Game development's hard; developing for a system where the game demands some expensive and complicated algorithms just sucked.
12:10:47 <Cale> simpson: So... about that minecraft server, when is it going to support Forge mods? ;)
12:10:54 <Cale> lol
12:11:48 <catsup> anyone here have any experience with netwire?
12:12:23 <catsup> it seems that none of the documentation's examples work anymore :/
12:12:55 <Cale> The documentation has examples?
12:13:06 <catsup> haha, not many
12:13:45 <catsup> i mean the README.md that comes in the source distribution
12:13:49 <Cale> oh
12:14:04 <Cale> hah, I was looking through the Haddocks and wondering what I was missing
12:14:51 <Cale> Anyway, what goes wrong? I don't really know anything about netwire, but I could probably try to fix it :P
12:17:27 <catsup> well, i'm trying to get that last example ("netwireIsCool") to run, but actually i can't get any "for" expression to work, it's always a type error
12:18:35 <catsup> let me get an example...
12:19:39 <Cale> Yeah, it might help to know what the type error is :)
12:20:22 <catsup> wire = for 2 . "ok." --> time
12:20:47 <catsup> if i modify the 'time' example (which does work) to add that, then i get this error:
12:21:06 <pranz> :t (-->)
12:21:07 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
12:21:14 <catsup> Couldn't match expected type `Wire s () m a t' with actual type `[Char]'
12:21:21 <simpson> Cale: It's been relegated to Copious Spare Time. I'm a FTE at Google, so odds are slim. :3
12:21:33 <c_wraith> edwardk: ok, after some sleep, I understand the coherence issues you were talking about last night (this morning?) with my proposal - you certainly can't just create every instance that fits the necessary kinds.
12:21:46 <geekosaur> pranz: beside lambdabot's parser not quite getting comments right, netwire is not imported
12:21:56 <Cale> simpson: I was kidding :)
12:22:04 <edwardk> glad i could help =)
12:22:45 <c_wraith> edwardk: I have a related question, though - would the way GND works in GHC 7.8 detect all of the ways that can lead to incoherence?
12:23:03 <Cale> catsup: I'm really unsure how that could have been valid in the first place
12:23:14 <Cale> catsup: But try applying pure to the string
12:23:20 <catsup> i did try that
12:23:36 <simpson> Cale: Oh, okay. I've been trying to push it off to others to maintain; if the community actually cared, then it might stay alive. (Lack of community's kind of why it never was a big deal.)
12:23:54 <edwardk> probably not. in that there isn't anything that checks that you can't get two different dictionaries for the same thing
12:24:01 <catsup> that gives me a different error: Could not deduce (t ~ [Char]) from the context (HasTime t s) bound by the type signature for wire :: HasTime t s => Wire s () m a t
12:24:11 <edwardk> The example I gave earlier with Iso Foo Foo and Iso Foo Bar would pass muster
12:24:42 <catsup> Cale: what makes it (supposedly) valid, i guess, is that the package supplies (.)
12:24:43 <Cale> simpson: I figure porting all of Forge would be quite a task. That community is large enough, and they have trouble keeping up with Mojang updates even though they're modding the game directly.
12:24:52 <edwardk> it checks that representationally the dictionaries are safe to use in either context, but not that they are coherent
12:25:14 <Cale> catsup: I think this README is using OverloadedStrings in some perverse way
12:25:35 <c_wraith> does ghc still not detect illegally overlapping instances if they're used in different modules from each other?
12:26:32 <Cale> catsup: oh, well, that's bad
12:26:57 <catsup> incidentally, this gives the same error: wire = pure "ok."
12:27:14 <Cale> catsup: can you put all the code on lpaste?
12:27:30 <catsup> ok
12:29:53 <catsup> http://lpaste.net/98440
12:30:47 <gwern> https://www.google-melange.com/gsoc/project/google/gsoc2013/ofan/44001 hm. I can confused. the source code provided is a cabal package 'name: fficxx-swig'
12:30:55 <gwern> but that doesn't seem to be on hackage
12:31:04 <gwern> nor does feng's name appear on hackage
12:31:23 <gwern> can't seem to find a source repo for fficxx-swig. just 'fficxx', by feng's co-mentor
12:31:36 <gwern> so... did he write a tool and didn't even put it on hackage?!
12:32:53 <Cale> catsup: oh
12:33:09 <Cale> catsup: It's just because you've given an explicit signature for wire which is incorrect
12:33:52 <Cale> catsup: the result of pure "ok." surely isn't going to be a time, it's going to be a String
12:35:45 <Cale> try using:  wire :: (Monad m) => Wire s () m a String
12:36:12 <Cale> (In fact, m = Identity in this case)
12:36:59 <catsup> that gets it to print...
12:37:03 <Cale> (The one defined in Control.Wire)
12:40:13 <catsup> then adding back the 'for 2 .' produces another error: Ambiguous type variable `t0' in the constraints: (Num t0) arising from the literal `2' at hate.hs:7:12 (HasTime t0 s) arising from a use of `for' at hate.hs:7:8-10 Probable fix: add a type signature that fixes these type variable(s)
12:40:40 <gwern> hm... but google fficxx-swig does lead me to https://github.com/ofan/hqt  which... doesn't seem to be on hackage either?
12:41:03 <catsup> oh i almost got it i think
12:41:07 <gwern> actually, doesn't even seem to've been announced or anything, 'hqt site:haskell.org' shows nothing
12:41:10 <catsup> wire :: (Monad m, HasTime t s) => Wire s () m a String
12:41:43 <catsup> wire = for 2 . pure "ok."
12:42:17 <catsup> that prints "ok." for 2 seconds, and then prints I: ()
12:42:20 <novodinia> I came across this stackoverflow question because I tried to perform `lines (readFile "foobar.txt")` https://stackoverflow.com/questions/11229854/how-can-i-parse-the-io-string-in-haskell
12:42:24 <gwern> 'hqt Haskell Quran Toolkit -- A Haskell library for dealing with Quran texts.' haha
12:42:42 <catsup> but it gives me anotehr error if i try this:
12:42:43 <catsup> wire = for 2 . pure "ok." --> time
12:43:21 <Cale> catsup: well, --> will only combine wires of the same type
12:43:28 <novodinia> The chosen answer is stating that you should be able to read the returned value from readFile with lines. She/he states that the returned type is String, but it seems that ghc is telling me the return type is String IO like the original question was stating. Would anyone care to explain this?
12:43:49 <Cale> time results in a NominalDiffTime or whatever
12:44:09 <catsup> wire = for 2 . pure "ok..." --> pure "done."
12:44:10 <Cale> while (for 2 . pure "ok") will result in a String
12:44:16 <Cale> yeah
12:44:19 <catsup> that works
12:44:19 <silasm> > :t readFile "foobar.txt" >>= lines
12:44:20 <lambdabot>  <hint>:1:1: parse error on input `:'
12:44:27 <silasm> :/
12:44:36 <silasm> I'm bad at lambdabot
12:44:43 <geekosaur> ":t" *replaces* "> "
12:44:48 <silasm> ah
12:44:54 <timthelion> Ach, there should be a way to tell cabal update to stay 2-3 months behind hackage :/
12:44:59 <silasm> :t readFile "foobar.txt" >>= lines
12:45:00 <lambdabot>     Couldn't match type `[]' with `IO'
12:45:00 <lambdabot>     Expected type: String -> IO String
12:45:00 <lambdabot>       Actual type: String -> [String]
12:45:18 <dcoutts> timthelion: there is! don't run cabal update for 3 months :-)
12:45:22 <gwern> timthelion: it's called cron
12:45:29 <geekosaur> and yes, that won't work as is because lines is not itself in IO
12:45:36 <silasm> :t readFile "foobar.txt" >>= return . lines
12:45:37 <lambdabot> IO [String]
12:45:41 <Cale> timthelion: Why do you want it to remain out of date with what's on Hackage?
12:45:44 <silasm> novodinia: ^
12:45:45 <timthelion> dcoutts: that doesn't work. When I run cabal update I still get an up to date list of packages
12:45:55 <novodinia> fmap lines (readFile "foobar.txt") works
12:45:59 <Cale> timthelion: You can specify which versions of things you want to have installed
12:46:42 <gwern> woot. finished judging all 11 SoCs
12:46:46 <timthelion> Cale: When writting an application that takes 2-3 months to write, it's best not to mix the old with the new.
12:46:46 <silasm> novodinia: or that. The issue is you don't have a pure value when you read from a file. You have a value in a context which needs to be passed to a function which deals with the context.
12:47:01 <ij> Is there an other way to do (`mod'` 1) from Data.Fixed?
12:47:06 <Cale> timthelion: Well, sure, but you should specify versions in your cabal file then :)
12:47:45 <novodinia> silasm: That's what I think the author of the question was stating, but it seems the answer was stating exactly the opposite, that what it returns is of type String and not IO String, which is odd that it was selected
12:48:04 <geekosaur> it was selected because it tries to explain how things really work
12:48:11 <geekosaur> did you actualy *read* the answer?
12:48:12 <benmachine> novodinia: I think the term "returns" is being confused here
12:48:24 <Cale> novodinia: It's very important to understand that a value of type IO String is nothing like a value of type String. It represents some procedure you could carry out to get a String.
12:48:28 <benmachine> readFile "returns" a string in the sense that it fetches a string and then you can use it
12:48:38 <benmachine> but it doesn't return it in the sense that String is not the return type of the function
12:48:57 <Cale> novodinia: You can execute an IO action from inside another IO action using do-notation
12:49:01 <catsup> i'm still completely confused about how you would actually use this :/
12:49:13 <geekosaur> readFile is a thing that promises to deliver a String at some point. you cannot get at the String directly; you must, in effect, register a callback to run when the String becomes available
12:49:20 <Cale> When you write inside a do-block, something like  v <- x  it means "execute the action x and call its result v"
12:49:43 <silasm> novodinia: he's saying it *returns* something of type String, which is a little misleading. The type is still 'IO String'
12:49:45 <geekosaur> the >>= operator registers this callback, or you can use do notation to pretend that you are writing code to "directly" access it... with some restrictions
12:49:47 <Cale> So, for instance, you can write  main = do xs <- readFile "foo.txt"; ...
12:50:00 <Cale> readFile "foo.txt" :: IO String
12:50:00 <catsup> even the IsCool thing does not work with that type signature added
12:50:03 <Cale> and xs :: String
12:50:12 <Cale> xs will scope over the remainder of the do-block
12:50:34 <Cale> and you can pass it along and process it with other functions which needn't know or care that it came from doing I/O
12:50:47 <Cale> and finally do some kind of output with the result of that
12:51:16 <Cale> For example,  do xs <- readFile "foo.txt"; putStrLn (reverse xs)
12:51:25 <gwern> so, 5/11 SoCs were clearly successful, and 3 are still doubtful, but we may wind up with 8/11. not too bad
12:51:35 <Cale> will reverse the contents of the file, and print that back out to the terminal
12:51:39 <c_wraith> 5/11 is actually pretty good
12:52:01 <catsup> ha, i got it to run, by changing 0.5 to 1...  which incidentally ruins the effect since it's on a 1 second period
12:52:05 <c_wraith> what's the average success rate across all projects?
12:52:14 <gwern> c_wraith: nah, it's a little under the historical average of 65%
12:52:23 <catsup> of course i also inserted a bunch of calls to pure that were not in the original
12:53:01 <catsup> Cale: well, you did get it working for me, so thanks :)
12:53:13 <Cale> catsup: That's interesting. NominalDiffTime is an instance of Fractional, so fractional literals ought to work
12:53:32 <c_wraith> :t 0.5
12:53:33 <lambdabot> Fractional a => a
12:53:45 <c_wraith> yep.  That seems right.
12:54:08 <timthelion> Honestly, is there a way to simply get a package list that is 6 months old?  On my main comp I *never* run cabal update and I haven't had any problems so far.  Now I'm on a clean VPS(thus have no choice about the cabal update) and I've been 3 hours at trying to install 3 packages.
12:54:12 <Cale> catsup: Perhaps you should make it Wire (Timed NominalDiffTime ()) ... explicitly
12:54:31 <dcoutts> timthelion: copy an index that you had from elsewhere
12:54:33 <catsup> Could not deduce (Fractional t) arising from the literal `0.5'   ...   Possible fix: add (Fractional t) to the context of the type signature for netwireIsCool :: (Monad m, HasTime t s) => Wire s () m a String
12:54:42 <timthelion> dcoutts: that's one way...
12:55:05 * hackagebot shelly 1.4.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.1 (GregWeber)
12:55:12 <Cale> timthelion: What I would do is go to the other machine, take note of which package versions were installed, and then stick == constraints into the .cabal file which specified those versions precisely.
12:55:23 <catsup> Cale: yup, it works now
12:55:24 <catsup> netwireIsCool :: (Fractional t, Monad m, HasTime t s) => Wire s () m a String
12:55:55 <Cale> timthelion: Then you won't have to worry about package indices on any further machines
12:56:00 <dcoutts> timthelion: as it's currently structured hackage doesn't have any feature to provide a point in time snapshot, so if you want to take that approach it has to be done client side
12:56:31 <Cale> catsup: Yeah, I suppose another option is just accumulating constraints :)
12:56:32 <levi> It's handy when ghc's advice is actually helpful.
12:56:37 <dcoutts> timthelion: or as Cale is saying, use constraints in the .cabal file or local config file, that's the standard approach.
12:56:46 <timthelion> Cale: the problem is that I have 3 packages that are not on hackage, with a dependency list like this package3 depends on package2 depends on package1.  Package3 won't install right now due to a conflict with an indirect dependency of package1
12:56:54 <novodinia> https://gist.github.com/novodinia/8407886
12:56:57 <timthelion> Cale: so simply changing the constraints on package3 won't help me
12:57:09 <timthelion> Cale: or *even* changing the constraints on package 1
12:57:26 <timthelion> since the dependency is indirect
12:57:29 <geekosaur> novodinia, `lines` is not in IO
12:57:32 <Cale> novodinia: Remember, v <- x means "execute the action x, and call its result v"
12:57:39 <c_wraith> dcoutts: I have a questions about add-source in cabal sandboxes. Is there documentation on exactly what it does somewhere? I feel like all my questions have probably already been answered.
12:57:41 <geekosaur> it is not an IO action, it is a pure function
12:57:46 <Cale> novodinia: lines a is a list, not an IO action, and so you don't want to execute it
12:57:59 <Cale> novodinia: what you probably mean to write is  let b = lines a
12:58:00 <catsup> Cale: what do you mean accumulating constraints?
12:58:08 <dcoutts> c_wraith: If you mean how the impl works then no I don't think there is.
12:58:12 <Cale> catsup: I mean, your class context there is getting longer :)
12:58:16 <novodinia> The stackoverflow answer used lines
12:58:16 <novodinia>  contents <- readFile "text.txt"   -- use '<-' here so that 'contents' is a String
12:58:18 <ij> > (`mod'` 1) 1234.5678 -- Are there any other ways to do it?
12:58:19 <c_wraith> dcoutts: no, I just mean the semantics of it
12:58:19 <lambdabot>  0.5678000000000338
12:58:20 <novodinia>   let [a,b,c] = lines contents
12:58:29 <Cale> catsup: You could instead just specify the monomorphic type that you're using the thing at
12:58:31 <timthelion> dcoutts: are you the maintainer of cabal, or who is?
12:58:39 <dcoutts> timthelion: one of them, yes
12:58:39 <c_wraith> dcoutts: what does it *mean*, as far as what the build process will do?
12:58:57 <dcoutts> c_wraith: I think there's some documentation in the user guide
12:58:59 <Cale> novodinia: Does my explanation make sense?
12:59:10 <c_wraith> I'll check there, then.  thanks.
12:59:32 <dcoutts> timthelion: I'm not sure I get the detail of your problem. Your package 1 indirectly depends on something that your package 3 depends on directly.
12:59:38 <novodinia> Cale: does `<-` represent an IO action?
12:59:58 <novodinia> When you say execute, I take that to mean function application/execution
13:00:06 <Cale> novodinia: v <- x means "execute the IO action called x, and call its result v"
13:00:15 <Cale> This has nothing to do with function application or evaluation
13:00:23 <ion> or functions
13:00:26 <Cale> execution of IO actions is totally separate from evaluation of expressions
13:00:59 <Cale> (well, they're interleaved, but separate processes that take place as a Haskell program runs)
13:01:05 <timthelion> dcoutts: Yes, package1 indirectly depends on several packages(one of them being http-conduit).  And so when I install package1, then the newest(2.0 version of http-conduit) is installed, but package3 needs http-conduit-1.9.6.
13:01:06 <novodinia> Cale, great
13:01:08 <novodinia> Thank you
13:01:12 <Cale> Evaluation means reducing expressions to values
13:01:21 <timthelion> dcoutts: I fixed that by nuking everything and installing the old version of http-conduit by hand
13:01:22 <Cale> Execution means carrying out the effects described by an IO action
13:01:33 <dcoutts> timthelion: so what happens when you try to install package 3?
13:01:36 <timthelion> dcoutts: only to find I had the same situation with aeson
13:01:45 <Cale> (The IO action is itself a value, and there might be some evaluation which takes place in determining which value it is)
13:01:45 <novodinia> Cale: foo3.hs and foo4.hs use let b = lines a
13:01:57 <timthelion> dcoutts: and I have no idea how many more packages I will have to start over for...
13:02:00 <dcoutts> timthelion: the trick is always to ask for everything you want all at once, not to do it bit by bit. The solver needs to see the whole picture.
13:02:29 <timthelion> dcoutts: if I have 3 folders each with their own cabal files, can I list them on the cli all at once?
13:02:30 <novodinia> I am confused on whether I need to return at the end. I don't know if a return is implicit in a do block
13:02:33 <timthelion> dcoutts: I
13:02:35 <dcoutts> timthelion: sure
13:02:47 <timthelion> dcoutts: cool.  I'm not ready to realease on hackage yet ;)
13:03:01 <silasm> novodinia: 'return' isn't the same as 'return' in C.
13:03:01 <dcoutts> timthelion: you don't need to: cabal install ./foo ./bar ./baz --dry
13:03:23 <timthelion> dcoutts: OK, I didn't realize the solver would work better that way, but it makes perfect sense
13:03:36 <Cale> novodinia: For example,  getLine :: IO String  is a value which *represents* the action of getting a line of text from the user. Evaluating that action does nothing visible, it just makes your CPU slightly hotter perhaps. Executing it will cause the program to wait for the user to type a line of text into their terminal before producing a String result, which will be that line of text.
13:04:01 <dcoutts> timthelion: so for example if you ask it to install your package 3 then it can see that it needs http-conduit-1.9.6 and so it'll choose to compile package 1 with that. Otherwise it's unconstrained and it'll of course prefer later versions since that's usually what people want.
13:04:02 <silasm> novodinia: It just turns a pure value into a contextual one (e.g. 'return "hello"' in an IO context gives an 'IO String')
13:04:14 <silasm> novodinia: it doesn't stop execution or anything else
13:04:16 <Cale> silasm: I'm sorry, but I really dislike that way of explaining things
13:04:24 <Cale> IO is not a "context"
13:04:33 <timthelion> dcoutts: yes, I understand now :)
13:04:34 <Cale> A value of type IO String is *nothing at all* like a String
13:04:44 <Cale> It's like a program which constructs a String
13:04:48 <dcoutts> timthelion: right, it really needs to see the whole problem, not just parts, so it can see all the constraints.
13:04:50 <Cale> when executed
13:05:00 <Cale> evaluation does not cause execution to occur
13:05:25 <Cale> (any more than opening an executable program in a hex editor would cause it to run)
13:05:34 <timthelion> dcoutts: would there be great offence among cabal/hackage maintainers if I were to "compete" with them with my own set of tools
13:05:51 <dcoutts> timthelion: we worked this out ourselves some time ago but the UI currently doesn't really force users to work this way. It's part of the long term plan to move things over so that the UI really forces you to say everything you want all at once and discourage the piecemeal thing that users will otherwise default to doing.
13:06:26 <silasm> Cale: I see the value in viewing it that way (and I don't dispute that that's "more correct"), but I also found thinking of monadic values as values in a context a lot easier for understanding how monads worked in the first place. I'll duck out though since you can probably explain better than I can.
13:06:31 <Cale> i.e. getLine contains a String in the same sense that /bin/ls contains a list of files. There's no master list of files sitting inside /bin/ls waiting to get out
13:06:34 <dcoutts> timthelion: no, you'd be in good company, there are many cabal alternatives out there, most of which are wrappers of some sort.
13:07:18 <timthelion> dcoutts: I guess coulpled with cabal-dev the "whole picture" model works pretty well, though it still doesn't allow for 3 randomly unrelated packages to be installed globaly at different times
13:07:28 <dcoutts> timthelion: but it's of course also open to you to integrate improvements. The problem with cabal development is not a conservative mindset but lack of dev time.
13:07:50 <dcoutts> timthelion: right, the sandbox UI is part of the way towards that "whole picture" UI.
13:07:56 <silasm> Cale: or perhaps I should say "how to work with monads" rather than "how monads worked"
13:08:22 <silasm> your explanation is definitely better for the latter.
13:08:33 <dcoutts> timthelion: and we have ideas for how to do the same sort of thing for "normal" environments, ie not just sandboxes.
13:08:39 <Cale> It's important to be able to understand why we can write things like this:
13:08:52 <Cale> twice x = do u <- x; v <- x; return (u,v)
13:09:05 <timthelion> dcoutts: well my plan is to download all of hackage and then use brute force type analysis to determine which combinations of packages type check rather than have version constraints.
13:09:22 <timthelion> dcoutts: I presume this will require some super instance on ec2 several weeks ;)
13:09:24 <dcoutts> timthelion: that'd be great. From that you can generate version constraints.
13:09:39 <dcoutts> timthelion: you're not the first to think of this approach
13:09:42 <Cale> twice is a function which, if given an IO action, will run that action twice, and produce the results of both runs in a pair
13:10:22 <timthelion> dcoutts: I know, I saw some guy talking about it on reddit.  But I happen to have a time window opening up in about 6-7 months when I could potentially work on it full time for a couple months.
13:10:24 <Cale> Rather, it produces an IO action which will do this :)
13:10:34 <dcoutts> timthelion: the usual incarnation of the idea is to extract package interfaces
13:10:37 <Cale> twice :: IO a -> IO (a,a)
13:11:03 <dcoutts> timthelion: store the interface for each package and then to do interface compatibility checks
13:11:34 <Cale> novodinia: This might actually be interesting for you as well :)
13:11:44 <novodinia> I'm reading along
13:12:05 <Cale> So we could write  main = do p <- twice getLine; print p
13:12:12 <Cale> given that definition of twice
13:12:39 <timthelion> dcoutts: It might also be interesting to figure out how to install a large subset of hackage into a git-annex repo.  Do the work once, and then let people pull the files on demand.
13:12:40 <Cale> and what will happen is that the program will run the action getLine twice, collecting the results into a pair p, and then print that pair to the terminal
13:12:42 <c_wraith> dcoutts: one thing the documentation for sandbox add-source doesn't cover - will it ever install a package from hackage that also is in a locally-added directory, if the version in the local source isn't compatible with the constraints, and there is a version on hackage that is?
13:12:44 <Cale> (try it!)
13:13:03 <dcoutts> c_wraith: mm, tricky. I'm not sure.
13:13:05 <Cale> You'll have to type two lines of text when the program is run of course
13:13:16 <timthelion> dcoutts: but that would make hackage "generational" in that the sable gauranteed to work set of packages could only be updated once every couple of months/years.
13:13:46 <dcoutts> c_wraith: something along those lines came up during code review but I forget what the conclusion was.
13:13:55 <c_wraith> dcoutts: that's a case that terrifies me. Will I ever think I'm testing local updates, but not be because I'm accidentally depending on the wrong version?
13:14:03 <gwern> http://pastebin.com/Ld0TE8uR if anyone wants to review my writeup before I commit it and publish
13:14:09 <mauke> The paste Ld0TE8uR has been copied to http://lpaste.net/98445
13:14:33 <dcoutts> c_wraith: you can try it. I think the behaviour ought to be that it's constrained to pick the local one, and if not it's a bug.
13:14:39 <Cale> novodinia: This treatment of IO actions as values allows us to design new control structures as we see fit, by writing functions that simply take actions (or functions that construct them) as parameters, and produce new actions.
13:15:08 <c_wraith> dcoutts: ok, so long as that's the intended behavior I feel better.  I will test it out, though.
13:15:19 <Cale> novodinia: In a similar vein to twice, we might want to write a loop which executes an action n times, collecting up a list of the results:
13:15:23 <dcoutts> timthelion: I think it has to be more "live" than that. But having a large consistent subset on hackage is another common (good) idea.
13:15:49 <dcoutts> c_wraith: thanks. Let me know what you find.
13:16:05 <Cale> times 0 x = return [] -- To run x zero times, we just produce the action which does nothing except to return an empty list.
13:16:13 <c_wraith> dcoutts: will do.
13:16:48 <Cale> times n x = do v <- x; ... -- to run the action x, n times, we first run it once, getting some result v...
13:17:12 <Cale> times n x = do v <- x; vs <- times (n-1) x ... -- then we run it (n-1) more times, getting a list of results vs
13:17:36 <Cale> times n x = do v <- x; vs <- times (n-1) x; return (v:vs) -- and finally, return a list of the combined results
13:18:20 <Cale> A general version of this function is in the library Control.Monad, and it's called replicateM
13:19:27 <Cale> To explain that name, we could do something a little more general: given a list of actions, glue them together into a single action which will run each of the actions in the list in turn, and produce a list of the results:
13:19:49 <Cale> sequence [] = return [] -- if there are no actions, we produce the action which does nothing except to return an empty list
13:20:35 <Cale> sequence (x:xs) = do v <- x; ... -- if there's a nonempty list of actions starting with x, we first execute x to get some result v
13:20:58 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ... -- then we run the rest of the list of actions, getting some results vs
13:21:22 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs) -- and finally combine v and vs into a single list, and return that as our result
13:21:47 <Cale> For IO actions,  sequence :: [IO a] -> IO [a]
13:22:27 <c_wraith> ...  does cabal install support both --only-dependencies and --dependencies-only ?
13:22:29 <Cale> and it behaves as a kind of primordial loop: if we can decide what to do on each iteration of the loop ahead of time and make a list of the actions required, then sequence will glue those actions together into one action which will run them all
13:22:43 <dcoutts> c_wraith: as aliases I think
13:23:06 <c_wraith> dcoutts: anyway - it will install a version from hackage if the version from local sources doesn't fit the constraints
13:23:07 <Cale> So we could write:  times n x = sequence (replicate n x), where replicate is the function which makes a list of n copies of a given element
13:23:18 <c_wraith> dcoutts: which I find to be somewhat bad.
13:23:25 <dcoutts> c_wraith: yes, please file a ticket.
13:23:27 <Cale> Or as it's called in the library,  replicateM n x = sequence (replicate n x)
13:23:47 <Cale> We can also do a for-each loop in this manner:
13:23:56 <Cale> mapM f xs = sequence (map f xs)
13:24:36 <Cale> You can think of f as a kind of 'loop body' here, it takes as its parameter one of the elements of the given list, and produces an action to perform from that.
13:25:05 <Cale> There is also a version of this with the arguments flipped, so as to look more like a traditional loop:
13:25:06 <c_wraith> dcoutts: uh.  Where at?
13:25:13 <Cale> forM xs f = mapM f xs
13:25:28 <dcoutts> c_wraith: Cabal uses github's issue tracker
13:25:33 <Cale> So we can write things like  forM [1..10] $ \x -> do print x; getLine
13:25:37 <c_wraith> ah, it's on github.  ok
13:26:07 <Cale> This will, for each element x in the list [1..10], print the number x, and then get a line of text, collecting the lines into a list.
13:26:26 <dcoutts> c_wraith: and in general the appropriate bug tracker is linked from the hackage package page
13:26:48 <novodinia> success! https://gist.github.com/novodinia/8408388
13:27:07 <Cale> novodinia: :)
13:27:39 <jle`> novodinia: good job :)
13:27:41 <Cale> novodinia: have you been following along with my explanation here? Let me know if there are any questions.
13:27:58 <novodinia> I'm at "15:16 < Cale> and it behaves as a kind of primordial loop:"
13:28:04 <Cale> okay :)
13:28:17 <jle`> you might find it helpful that prelude exports an alias for (putStrLn . show), print.
13:28:41 <jle`> anyways i'll scuttle along now
13:31:17 <Cale> novodinia: This kind of ability to define our own control structures so tidily is one thing which I think makes Haskell a better imperative language than most imperative languages try to be :)
13:31:21 <gwern> no comments? alright then
13:33:37 <mercuryrising> why does this work in ghci (getStdRandom (randomR (1,6))) but not in a script? main = 	print $ getStdRandom (randomR (1,6))
13:33:46 <mercuryrising> (i imported System.Random in both)
13:35:14 * hackagebot explain 0.1.0.0 - Show how expressions are parsed  http://hackage.haskell.org/package/explain-0.1.0.0 (JoelTaylor)
13:35:14 <novodinia> Cale: Thanks for that thorough explanation!
13:35:28 <dhrosa> mercuryrising: what's the error?
13:35:29 <koala_man> mercuryrising: print expects something showable, and you're giving it an IO Int. use foo <- getStdRandom (randomR (1,6)); print foo
13:35:46 <joelteon> yeah, I too just finished putting those lines in my ghci
13:35:46 <dhrosa> woops didn't see the print
13:35:48 <novodinia> That entire conversation needs to be saved to a .lhs file
13:35:51 <joelteon> but you guys got it
13:35:57 <mercuryrising> so <- translates from IO to non-IO?
13:36:07 <joelteon> oh boy :D
13:36:16 <novodinia> https://gist.github.com/novodinia/8408540
13:36:25 <novodinia> Not exactly lhs
13:36:42 <ChongLi> so <- foo
13:36:50 <joelteon> mercuryrising, <- is part of do-notation
13:36:54 <joelteon> which is for monads
13:37:02 <ChongLi> so is just a name bound to the value produced by foo's action
13:37:03 <dhrosa> it extracts a value from a monad (in this  case IO)
13:38:26 <c_wraith> dcoutts: https://github.com/haskell/cabal/issues/1648 added
13:38:26 <jle`> mercuryrising: technically.  in the context of do notation, every line has a "result".  <- lets you name the result.
13:38:34 <dcoutts> c_wraith: ta
13:38:40 <jle`> mercuryrising: for future usage
13:39:03 <jle`> in ghci, it automatically prints all results as they happen
13:39:35 <Cale> novodinia: sequence, mapM, and forM are all in Control.Monad, and in fact, don't just work with IO, but with any monad at all (I didn't really try to explain what a monad is, but it's basically just something like IO for which we have definitions of return and another combinational device called (>>=) that the do-notation translates into)
13:40:32 <novodinia> and a monad is just a monoid of some sort
13:40:52 <Cale> Heh, if you generalise the hell out of the definition of monoid
13:41:10 <novodinia> rings are just a monoid of some group structure?...
13:41:19 <novodinia> All sorts of these types to be found, I can't recall all of them right now
13:41:44 <jle`> mercuryrising: you might have learned that do notation "attaches"/merges multiple IO values; do { getStdRandom (randomR (1,6)); print "hello world" }.  it takes two completely separate IO actions and glues them into one.  every IO action has a result, as you probably already know.  normalyl in a do block, these results just disappear with the next line.  <- lets you 'name' the result and refer to the result
13:41:46 <jle`> by name later.
13:42:03 <novodinia> Oh, monads are just functors, that's what I've heard, but interesting that a monad can also be a monoid
13:42:31 <joelteon> heh, I wish it was possible to edit an existing package on hackage
13:42:40 <joelteon> it's cute how many 0.1.0.0 -> 0.1.0.1 instant uploads you see
13:42:46 <joelteon> after someone uploaded a broken first version
13:42:51 <jle`> novodinia: be aware that not all functors are monoids :)  you need to have a way to 'flatten' it.  You need a way to turn T x T into T.
13:43:03 <Cale> A monad on a category C is a monoid object in the monoidal category of endofunctors C -> C (with functor composition as the monoidal operation on objects of the category, and the identity functor as its unit). An ordinary monoid is a monoid object in the category of sets (with Cartesian product as the monoidal operation on objects, and the one-element set as the identity)
13:43:04 <jle`> er
13:43:06 <mercuryrising> okay i think that kinda makes sense
13:43:06 <jle`> sorry
13:43:08 <jle`> not allf unctors are monads
13:43:42 <Cale> If that makes no sense, don't worry too much about it :)
13:43:45 <mercuryrising> is randomR not supposed to be used with numbers? i get the error now `No instance for (Num a0) arising from the literal `1' the type variable `a0' is ambiguous
13:44:04 <jle`> mercuryrising: the literal '1' is a polymorphic/overloaded literal
13:44:12 <jle`> it can be an Int, an Integer, a Float, a Double
13:44:17 <jle`> or any instance of the Num class
13:44:23 <Cale> (Unless you're really interested in studying the mathematics here, in which case, I'd be happy to explain it, but it's not likely to really help you with Haskell all that much :)
13:44:32 <mercuryrising> so it doesn't know what to do with it, since there's more than one thing it could be?
13:44:34 <jle`> so you need to somehow tell it that you want an Int, Integer, Float, Double, etc.
13:44:35 <geekosaur> in short, you need to tell it what *kind* of number
13:44:37 <jle`> yes, exactly
13:44:46 <jle`> overloaded numeric literals are a kinda cool thing in Haskell
13:44:51 <jle`> but you run into problems like this
13:45:09 <mercuryrising> cool if you know what's going on i'm sure :)
13:45:23 <jle`> to someone new it generates pretty unhelpful error messages
13:45:25 <jle`> > 1 && 2
13:45:27 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
13:45:27 <lambdabot>    arising from the literal `1'
13:45:27 <lambdabot>  Possible fix:
13:45:27 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Bool)
13:45:49 <dcoutts> mercuryrising: right, and fortunately they occur less in real programs because there's more context available to resolve which type you're talking about, compared to tiny snippets in ghci
13:46:04 <jle`> instead of telling you you can't && a numeral, it tells you that you need a way to read the polymorphic literal as a bool :P
13:46:11 <novodinia> Is it possible that a do block can contain several return commands on different lines?
13:46:26 <letrec> Is http://hackage.haskell.org/package/zlib-0.5.0.0/docs/Codec-Compression-Zlib.html thread-safe? I'm using forkIO a lot but I'm getting ZlibException (-3)
13:46:27 <jle`> because technically you can provide a way to read the polymorphic literal as a Bool.  but that's a Bad Idea(tm) most of the time
13:46:33 <jle`> novodinia: what do you mean by return command?
13:46:40 <Cale> novodinia: It can, but since for any value v, the action return v is an action which does nothing, but produces v as its result...
13:46:41 <dhrosa> novodinia: return doesn't exit a do block
13:46:44 <mercuryrising> okay, added the type signature and we're good to go!
13:46:44 <dcoutts> novodinia: yes but that will not do what you may be expecting.
13:47:00 <Cale> return won't behave like it does in most imperative languages
13:47:16 <mercuryrising> thanks!
13:47:35 <Cale> You could use it as a kind of poor-man's let though
13:47:39 <Cale> v <- return 5
13:47:51 <Cale> would make v equal to 5 in what followed
13:47:58 <Cale> (but don't do that)
13:48:02 <jle`> heh.
13:48:11 <joe9> I am trying to figure out how to get milliseconds from epoch: http://codepad.org/Pf47WbI2 but, it still gives the value in seconds. Any suggestions on what I could be missing, please?
13:48:14 <jle`> yeah the word 'return' has nothing to do with the keyword 'return' in most other languages.
13:48:24 <Cale> Well, it has *something* to do with it
13:48:27 <jle`> well
13:48:30 <jle`> yeah >.>
13:48:34 <Cale> return v is an action which ... returns v
13:49:18 <zett_zelett> I have a hard time reasoning about performance of Haskell code (or rather about how it actually does things).
13:49:31 <jle`> zett_zelett: reasoning about the performance of Haskell code is not an easy thing :)
13:49:31 <zett_zelett> Is there some sort of guidance out there? Some general help and tips?
13:49:35 <Cale> zett_zelett: It takes quite some time to build up an intuition for it...
13:49:46 <geekosaur> joe9: POSIX time is in seconds
13:50:09 <Cale> zett_zelett: Well... there's a whole bunch of useful discussion in the new book on concurrency in Haskell
13:50:21 * hackagebot explain 0.1.0.1 - Show how expressions are parsed  http://hackage.haskell.org/package/explain-0.1.0.1 (JoelTaylor)
13:50:24 <Cale> http://chimera.labs.oreilly.com/books/1230000000929
13:50:32 <Cale> (note that you can read it online)
13:50:35 <novodinia>  return is simply a function of type a -> IO a that converts a value of type a to a command of type IO a.
13:50:35 <zett_zelett> Like, I’ve heard that doing recursion on list expressions like 'xs ++ [x]' is a bad idea.
13:50:41 <zett_zelett> I don’t know why.
13:50:43 <Cale> novodinia: right :)
13:50:43 <novodinia> That is from http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html
13:50:52 <novodinia> That helps
13:51:05 <jle`> novodinia: there are times in your life when you have an a, but you want an IO a
13:51:06 <novodinia> But I haven't read the above conversation yet, so it might help as well
13:51:10 <zett_zelett> Thanks, Cale.
13:51:20 <jle`> when you get there
13:51:22 <jle`> you will know it :)
13:51:25 <geekosaur> joe9: rounding will not change to microseconds, it will *remove* microseconds. perhaps you want to multiply?
13:51:31 <Cale> zett_zelett: There are also some really good old papers if you really want to get into the fine details of how everything is implemented
13:51:31 <benmachine> zett_zelett: xs ++ ys takes time proportional to the length of the left argument
13:51:43 <jle`> benmachine: well, maybe
13:51:48 <jle`> benmachine: it depends on where you use it :P
13:51:55 <benmachine> zett_zelett: so xs ++ [x] is much slower than [x] ++ xs
13:52:10 <benmachine> jle`: to reach normal form, I guess
13:52:12 <jle`> take 1 $ [1,2] ++ [3]
13:52:18 <Cale> zett_zelett: But for the most part, I don't even think down at the level of thunks and closures when I reason about performance. I think about expression graphs being rewritten at runtime.
13:52:19 <jle`> take 1 $ [1] ++ [2,3]
13:52:23 <jle`> probably take the same amount of time
13:52:26 <jle`> ish
13:52:28 <benmachine> yeah, sure
13:52:38 <Cale> (and more likely, I don't even think too hard about the graph structure, just the expressions themselves)
13:52:53 <jle`> @src take
13:52:53 <lambdabot> take n _      | n <= 0 =  []
13:52:54 <lambdabot> take _ []              =  []
13:52:54 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
13:53:09 <zett_zelett> Cale: expression graphs – this seems like the way I want to think about code as well. How can I get there (still quite new to programming here)?
13:53:19 <Cale> zett_zelett: If you can understand what lazy evaluation does at the level of rewriting expressions, you can start to build up an understanding of how Haskell programs run which is useful enough to understand performance.
13:53:23 <Cale> Okay
13:53:31 <benmachine> zett_zelett: there's a tool that I wrote that would be useful for this if it wasn't so broken
13:53:34 <benmachine> hth
13:53:54 <Cale> I really wish there were a perfect reference for this...
13:54:18 <Cale> But let me point you at some GIFs to start with :)
13:54:34 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
13:54:37 <benmachine> there's some pretty pictures on http://www.vex.net/~trebla/haskell/lazy.xhtml
13:55:07 <zett_zelett> Okay.
13:55:23 <zett_zelett> Yeah, gifs to represent evaluation of expressions.
13:55:23 <Cale> HOPS is a programming language which unfortunately you can't download (dammit Dr. Kahl, you need to learn to release the cool stuff you do!)
13:55:39 <zett_zelett> This is nice. These images will stick to my brain forever.
13:55:45 <zett_zelett> Thank you!
13:55:48 <joe9> geekosaur: ok, thanks.
13:55:57 <Cale> But you immediately get a sense of what's going on in memory!
13:56:05 <Cale> because you can see it on your screen
13:56:37 <Cale> zett_zelett: so yeah, with those pictures in mind, let's take a look at what lazy evaluation means
13:57:24 <Cale> zett_zelett: In most programming languages, you're likely to find what's called strict evaluation, which means that expressions are evaluated innermost-first whenever we have a choice of where to reduce an expression
13:57:41 <Cale> My standard example to give is with the function  double x = x + x
13:57:50 <Cale> and we evaluate the expression  double (double 5)
13:58:02 <Cale> Under strict evaluation, this proceeds as:
13:58:05 <Cale> double (double 5)
13:58:12 <Cale> --> double (5 + 5)
13:58:15 <Cale> --> double 10
13:58:19 <Cale> -> 10 + 10
13:58:20 <silasm> zett_zelett: just going to drop this in as well, when it comes to reasoning about evaluation: http://www.haskellforall.com/2013/12/equational-reasoning.html
13:58:21 <Cale> -> 20
13:58:40 <Cale> We could also choose to evaluate expressions outermost-first
13:58:49 <Cale> That would look like:
13:58:52 <Cale> double (double 5)
13:58:52 <zett_zelett> Yeah, I already get that.
13:59:27 <zett_zelett> I wonder though what a good definition for a redex, leftmost-innermost and leftmost-outermost is and whether Haskell is really evaluating leftmost-outermost.
13:59:38 <Cale> ah, okay
13:59:51 <zett_zelett> I’ve read lazy evaluation = leftmost-outermost + graph reduction or something in the line of that.
13:59:56 <zett_zelett> Thanks silasm!
13:59:58 <Cale> So, if we're talking about GHC, what GHC does is not *really* lazy evaluation.
14:00:29 <Cale> Haskell is defined to have "non-strict semantics", which means that programs have to produce the same results and termination behaviour as if they were evaluated outermost-first
14:00:54 <Cale> (as it happens, the results will be the same with any order that terminates, and outermost-first will terminate if any order does)
14:01:34 <Cale> But GHC will be clever, and will try to find cases where it's safe to evaluate in a more efficient order
14:02:07 <Cale> However, imagining that everything is happening with lazy evaluation is close enough to understand the performance of programs reasonably well most of the time.
14:02:32 <zett_zelett> Is graph reduction the same as sharing?
14:02:38 <Cale> Sometimes you will be pleasantly surprised, very rarely, you'll find a performance bug in GHC
14:02:39 <Cale> yes
14:03:11 <Cale> Well... sharing refers to what happens in graph reduction where you have multiple arcs pointing to the same subexpression
14:03:36 <Cale> and when that subexpression is reduced then, each of the places where it's being referred to benefits from that reduction
14:03:39 <heatsink> Hoopl 3.9 hides FuelMonad methods that were exposed in 3.8.7.4.  How can I run a computation that uses fuel?
14:03:45 <zett_zelett> Is there a book or something that you can recommend?
14:04:08 <Cale> So, I didn't get to it in my double example, but we would have seen that outermost-first evaluation would have duplicated work
14:04:09 <danharaj> Cale: Been watching Harper's lectures. Beta equivalence is definitional equality while eta equivalence is intensional, is that right?
14:04:23 <danharaj> beta-eta equivalence, rather.
14:04:32 <silasm> @where iofpl
14:04:32 <lambdabot> I know nothing about iofpl.
14:04:36 <silasm> :/
14:04:58 <danharaj> @where tapl
14:04:59 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
14:05:18 <silasm> danharaj: does tapl help reason about evaluation?
14:05:22 * hackagebot bindings-mpdecimal 0.6.0.0 - bindings to mpdecimal library  http://hackage.haskell.org/package/bindings-mpdecimal-0.6.0.0 (OmariNorman)
14:05:23 <Cale> danharaj: In HoTT, function extensionality is something that you prove using the univalence axiom, and so it's a propositional equality
14:05:24 * hackagebot fullstop 0.1.3.2 - Simple sentence segmenter  http://hackage.haskell.org/package/fullstop-0.1.3.2 (EricKow)
14:05:27 <silasm> still haven't read it
14:05:42 <danharaj> Cale: I'm just confused about all the different notions of equality that are relevant at the same time.
14:05:46 <nisstyre> silasm: there is a book called PL:AI that tells you about evaluation
14:05:48 <Cale> danharaj: and yeah, beta is something you get as part of judgmental equality
14:05:53 <benmachine> danharaj: you sound like a type theorist!
14:05:53 <heatsink> Implementatin of functional languages is here: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/
14:05:58 <danharaj> silasm: tapl goes over confluence, normalization, and the difference between strict non-strict at least.
14:06:08 <silasm> oooh
14:06:20 <danharaj> Cale: But why isnt beta-eta equivalence considered judgmental?
14:06:26 <nisstyre> silasm: the wikipedia article on evaluation strategies is good to read
14:06:43 <silasm> nisstyre: think I've already read the wiki page.
14:06:46 <Cale> zett_zelett: Well, start with the book I linked on concurrency and parallelism -- in order to talk about performance, it goes over a lot of stuff, though in a bit of a different way than I have been
14:07:08 <nisstyre> silasm: what level are you at?
14:07:17 <nisstyre> silasm: you might like http://cs.brown.edu/~sk/Publications/Books/ProgLangs/
14:07:48 <Cale> danharaj: I'm pretty sure the answer is no for HoTT, though I'm not sure it's actually harmful to do that.
14:07:48 <zett_zelett> Okay.
14:08:00 <Cale> danharaj: You can get away without making it judgmental anyway
14:08:07 <danharaj> sure
14:08:10 <silasm> nisstyre: I was more asking for zett_zelett, I hadn't noticed danharaj was in a different conversation and thought he was linking tapl for zett_zelett
14:08:12 <zett_zelett> Cale: What is your background?
14:08:20 <nisstyre> silasm: oh ok
14:08:22 <Cale> zett_zelett: I have a BMath in pure mathematics
14:08:31 <danharaj> Cale: So is extensionality *just* uniqueness of identity proofs?
14:08:35 <silasm> nisstyre: but that's not to say I'm not interested ;).
14:08:37 <zett_zelett> BMath?
14:08:38 <Cale> zett_zelett: and I've been programming in Haskell for 12 years or so
14:08:48 <Cale> Bachelor of Mathematics
14:08:55 <zett_zelett> Yeah, I thought so.
14:09:01 <zett_zelett> Wow, how old are you?
14:09:04 <novodinia> https://gist.github.com/novodinia/8409004
14:09:05 <Cale> 30
14:09:06 <silasm> Cale: jealous. I may never finish mine.
14:09:18 <zett_zelett> I wish I knew Haskell when I was 18!
14:09:27 <danharaj> I knew Haskell when I was 17 ;)
14:09:49 <zett_zelett> Cale: What type of mathematics are you into?
14:09:58 <zett_zelett> (Other than category theory.)
14:10:04 <Cale> Lately I've been really interested in this homotopy type theory stuff :)
14:10:20 <Cale> Also, I rather like algebraic combinatorics
14:10:25 <zett_zelett> Are you doing your PhD?
14:10:29 <Cale> Nope
14:10:32 <zett_zelett> M.Sc?
14:10:39 <zett_zelett> Or M.A.?
14:10:41 <danharaj> He is doing his PhD in defending the homestead from bears, ice, and hockey players.
14:10:55 <Cale> I might do another degree at some point if I want to set aside a block of time to work with someone specific on a project.
14:11:11 <Cale> But for the most part, I know well enough how to study mathematics on my own.
14:11:17 <zett_zelett> Nice.
14:16:30 <jle`> novodinia: it might help you to write out your type signatures
14:16:39 <jle`> if at least so that we can be sure what you are doing :P
14:16:51 <jle`> but i'm guessing you want drop :: Int -> [a] -> [a] ?
14:17:04 <novodinia> THat is right
14:17:09 <jle`> remember that "do" chains together monadic values
14:17:17 <jle`> IO a >> IO b >> IO c, for example
14:17:38 <jle`> you use it to combine monadic values
14:17:50 <jle`> in this case you aren't working with monads
14:17:54 <jle`> you're just working with normal ol values
14:18:25 <Cale> novodinia: If you want to use let, you don't need do, but the expression form looks like  let <decls> in <expression>
14:18:30 <jle`> remember that "return" wraps a normal value a into a monad m a...for example, a -> IO a
14:18:56 <jle`> so if your monad is IO, you would be generating drop :: Int -> [a] -> IO [a]...which is probably what you don't want
14:19:04 <Cale> novodinia: another issue here is that if v = x, then v is the whole list
14:19:15 <Cale> novodinia: which probably isn't what you intended
14:19:32 <Cale> novodinia: You might consider using pattern matching to take the list apart
14:20:08 <Cale> (and define  drop' n [] = ... and  drop' n (x:xs) = ...  separately)
14:20:31 <Cale> also, don't forget to include a base case of some sort :)
14:20:40 <Cale> (apart from the empty list! :)
14:21:14 <jle`> anyone know how to fix this error in ghci "Cannot match a with (Something b, Something c)
14:21:16 <jle`> "
14:21:25 <jle`> it has something to do with the forall stuff
14:21:26 <jle`> right?
14:21:44 <jle`> because even if i make the type :: (Something b, Something c), it still complains
14:22:06 <joelteon> does it change the names to (Something b1, Something c1)
14:22:39 <jle`> oh no they are names
14:22:45 <jle`> they are actual types
14:22:48 <joelteon> oh ok
14:22:52 <jle`> but i was not sure if they were relevant
14:23:01 <joelteon> apparently not
14:23:09 <jle`> it's Text.Blaze.Internal.MarkupM
14:23:20 <jle`> i will try to make a self contained example
14:25:12 <heatsink> What is the origin of type variable a in your error?
14:25:30 <jle`> i enver specified a or anything
14:25:32 <jle`> :|
14:25:34 <jle`> no signatures
14:25:46 <heatsink> Do you have any existentially bound types?
14:28:29 <jle`> http://lpaste.net/98448
14:28:48 <jle`> i actually don't even know where the a is being used in the actual library
14:29:01 <jle`> oh
14:29:04 <jle`> it's used in one of the constructors
14:30:43 <jle`> here http://lpaste.net/98448
14:33:07 <jle`> "cannot bind b1 with actual type Something b"; 'b1' is a rigid type variable..."
14:33:51 <jle`> oops
14:34:30 <Iceland_jack> jle`: What are you trying to accomplish?
14:35:27 <jrmithdobbs> :t (.) . (.)
14:35:28 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
14:35:54 <jrmithdobbs> my head
14:35:59 <jle`> sorry, did everything wrong
14:36:01 <jle`> http://lpaste.net/98448
14:36:17 <novodinia> Thanks for the help, I should be on in a few minutes
14:36:25 <jle`> so Something a is a recursive data type that can have an AnotherThing (Something b, Something c)
14:36:40 <jle`> er, AnotherThing (Something b) (Something c)
14:36:50 <jle`> i want to write a function that splits an AnotherThing
14:36:52 <Cale> jle`: When it says something is a rigid type variable, it usually means that type variable originally came from an explicit signature somewhere, and thus can't be substituted for something more specific
14:37:03 <jle`> into Maybe (Something b, Something c)
14:37:05 <jle`> if it's AnotherThing
14:37:09 <jle`> and Nothing if it's another constructor
14:37:17 <Cale> i.e. you specified a type which is more polymorphic than your implementation
14:37:33 <dhrosa> treeName (File fName _ _ _) = fName
14:37:35 <dhrosa> woops
14:37:38 <Cale> jle`: and indeed, you have here
14:37:49 <heatsink> The type 'b' in AnotherThing has no relation to the type 'b' in the type of splitSomething
14:37:59 <Cale> jle`: If I call splitSomething, I get to specify the types a, b, and c
14:38:01 <dhrosa> what's a cleaner way of doing this pattern match, without having to enumerate all the args? treeName (File fName _ _ _) = fName
14:38:16 <Cale> jle`: Suppose I specify that a = Integer, b = String and c = String
14:38:17 <heatsink> dhrosa, use record syntax
14:38:33 <platz_> I haven't seen a lot in the tutorial so far about quantification, forall, existential types... are these more for library designers than applications?
14:38:40 <platz_> tutorial=tutorials
14:38:53 <dhrosa> heatsink: would it be treeName (File { fileName = myVar}) = ..?
14:38:55 <heatsink> They're ways of reasoning about programs, platz_
14:39:05 <jle`> Cale: hm. so how would i do the proper restriction (?)
14:39:08 <heatsink> Yes, dhrosa, as long as File was defined that way
14:39:26 <dhrosa> I just remembered that syntax from my xmonad configs
14:39:30 <Cale> platz_: They're language extensions which are useful in real programs, but the situations where they're useful are not all that common
14:39:42 <heatsink> forall is very useful, Cale
14:39:57 <Cale> heatsink: Higher rank types don't actually show up all that often
14:40:07 <jle`> but i cry now :'(
14:40:15 <jle`> all i wanted to do was add a class to every paragraph :'(
14:40:20 <jle`> sorry
14:40:26 <jle`> got emotionally overwhelmed for a second
14:40:29 * jle` composes himself
14:40:38 <ciaranm> you're an endoperson?
14:40:40 <Cale> Nor do existentials really...
14:40:52 <heatsink> Haha
14:40:54 <Cale> You can often eliminate existentials
14:40:54 <heatsink> ciaranm++
14:40:55 <jle`> haha
14:41:23 <heatsink> You don't often need to write forall explicitly, but you still have to understand universal quantification.  Which I think is part of what platz_ was asking about.
14:41:24 <jle`> anyways is there an easy way to do this splitSomething?
14:41:37 <jle`> i'm adding forall in random places
14:41:41 <jle`> but it's nto doing any good
14:41:41 <heatsink> It depends what you really want to do, jle'
14:41:46 <Cale> jle`: Maybe if you use OneThing?
14:41:57 <jle`> i want to split my Something if it is an AnotherTHing
14:42:03 <jle`> or return Nothing if it's not
14:42:05 <jle`> is that possible?
14:42:20 <Cale> jle`: You're not allowed to unpack the things of unknown type and then just use them as if they have the specific type of result that you've been asked by the caller of splitSomething to produce.
14:42:34 <jle`> oh there is an error in my source code
14:42:41 <Cale> also, what the heck is the type parameter of Something?
14:42:57 <Cale> You don't actually use it meaningfully anywhere
14:43:05 <Cale> It's a phantom existential
14:43:13 <Cale> er, kinda?
14:43:19 <Cale> What are you trying to do?
14:43:27 <heatsink> Your 'Something' data type has many type variables that aren't used, jle`.  That's an indication that the definition isn't right.
14:43:31 <Cale> This data declaration makes no sense
14:43:39 <jle`> the type of AnotherThing is forall b c. AnotherThing (Something b) (Something c)
14:43:49 <jle`> Cale: oh i reposted a fix http://lpaste.net/98448
14:44:01 <jle`> heatsink: well..that's how it is in the real library
14:44:01 <heatsink> You should be able to explain what each type variable means
14:44:03 <Cale> okay, it still makes no sense
14:44:09 <jle`> http://hackage.haskell.org/package/blaze-markup-0.5.1.7/docs/src/Text-Blaze-Internal.html#MarkupM
14:44:18 <Cale> jle`: What does the type parameter to Something mean?
14:44:30 <Cale> jle`: If I have a Something Integer, how is that any different from a Something String?
14:44:31 <jle`> i'm basically making a simplified MarkupM
14:44:37 <heatsink> Like, in [a], the list's elements have type 'a'.  I can't tell how the types a, b, and c here describe the data.
14:44:38 <Cale> Answer: it's not.
14:44:53 <Cale> oh, wait
14:44:54 <Cale> okay
14:44:55 <Cale> hah!
14:45:00 <Cale> You do use the 'a' now.
14:45:06 <jle`> yeah i added a usage of the a
14:45:19 <jle`> haha
14:46:02 <Cale> You absolutely cannot leak b and c like that without wrapping them in another existential
14:46:04 <heatsink> I'm looking at the library source that jle` linked.  My guess is that the type parameter 'a' is a phantom type representing the data type encoded by a 'Something a'
14:46:29 <jle`> Cale: so how should i wrap it? in the type signature of splitSomething?
14:46:31 <Cale> You should be able to write  splitSomething (AnotherThing b c) = Just (OneThing b, OneThing c)
14:47:24 <heatsink> I'm guessing that a 'Markup foo' is a 'foo' encoded in a markup language.
14:47:26 <Cale> Remember, b has type (Something t) *for an unknown type t*
14:47:50 <Cale> and in particular, you have no idea whether t is equal to the type b in the type declaration for splitSomething
14:47:57 <Cale> and cannot know
14:48:08 <heatsink> You have two choices when unpacking its contents: either return an unknown-type markup value, or typecheck the returned markup value.
14:48:08 <jle`> hm.
14:48:10 <Cale> (the type information is gone, it was discarded)
14:48:18 <heatsink> Dynamically typecheck, I mean
14:48:19 <jle`> okay
14:48:28 <jle`> so i have to return it in a constructor i know?
14:49:09 <Cale> Have a look at the type of the constructor OneThing
14:49:11 <Cale> In ghci
14:49:29 <Cale> You should see:  OneThing :: Something b -> Something a
14:50:34 <Cale> i.e. regardless of which type b is in the Something b you're required to produce, you can wrap the Something t that you have in OneThing to get a Something b
14:51:28 <heatsink> I'm looking at the Text.Blaze interface.  As far as I can see, the parameter of that data type only gets instantiated to ()
14:51:42 <Cale> Note that if you actually had any values of type a in your data structure, you'd lose the ability to ever tell what they were the moment that OneThing was applied
14:52:04 <Cale> This is a really silly data declaration
14:52:15 <jle`> Cale: mine, or Blaze?
14:52:20 <Cale> What does Blaze do? Can you link the haddock?
14:52:43 <jle`> http://hackage.haskell.org/package/blaze-markup-0.5.1.7
14:52:43 <heatsink> http://hackage.haskell.org/package/blaze-markup-0.5.1.7
14:52:49 <jle`> blaze represents an HTML document
14:52:52 <jle`> the ast and stuff
14:52:55 <skypers> is there any descent reason runState is not already flipped?
14:52:57 <jle`> and has stuff to compose and print it
14:53:06 <skypers> or runWriter
14:53:06 <jle`> skypers: runState is just a record accessor
14:53:18 <Cale> oh, this is *that* library
14:53:20 <Cale> lol
14:53:30 <Cale> They're abusing the concept of a monad
14:53:32 <skypers> jle`: what would it cost to make it a regular function and pattern match? :D
14:53:37 <Cale> just because they like do notation
14:53:47 <skypers> I thought I was the only one
14:53:51 <skypers> but the more lines I read
14:54:03 <skypers> the more I see everyone does like me: flip runState s $ do
14:54:15 <jle`> skypers: hm. remember newtype State s a = State { runState :: s -> (a, s) }
14:54:25 <skypers> jle`: yes, then?
14:54:27 <jle`> so runstate takes a state and returns the function
14:54:32 <skypers> yes…
14:54:33 <skypers> then?
14:54:46 <jle`> not too sure how it lends easily to a pre-flipped version
14:54:47 <Cale> So they define something which isn't even remotely close to being a monad, and moreover since it needs to have a type parameter just to be an instance, has to involve weird type hackery that it wouldn't otherwise need.
14:54:55 <heatsink> Oh dear
14:55:02 <jle`> besides just defining one
14:55:05 <Cale> I would recommend that you not repeat this in your own code.
14:55:11 <skypers> well, that’s it jle`
14:55:19 <jle`> so that's the 'decent reason'
14:55:21 <jle`> i guess
14:55:31 <skypers> it’s really decent to me
14:55:47 <jle`> Cale: yeah, i wouldnt :| but i'm trying to write a function that takes a blaze document and adds a class to every paragraph matching a predicate
14:55:53 <skypers> it’s juste like “Oh, we were lazy to write another function out of the record”
14:55:56 <Cale> okay
14:55:58 <shachaf> Their thing is a monoid, isn't it?
14:56:02 <Cale> shachaf: yes
14:56:11 <shachaf> So they could make it a monad by just using Writer.
14:56:17 <heatsink> > let applyState = flip runState
14:56:18 <lambdabot>  not an expression: `let applyState = flip runState'
14:56:22 <Cale> shachaf: That's what a sane person would do
14:56:35 <skypers> @let applyState = flip runState
14:56:37 <lambdabot>  Defined.
14:56:54 <Cale> shachaf: but instead they try to shove a square peg into a round hole, and actually manage to succeed using existential types
14:57:06 <skypers> a decent reasons would have been “because a lot of folks are used to pass the state after the stateful computation”
14:57:19 <Cale> fsvo success where the peg gets a bit wedged
14:57:22 <jle`> oh are you asking why there isn't an already defined/exported thing in the libraries that is flip runState
14:57:31 <skypers> but here it’s “huh, we wrote it as-is in the first time and now we can change it back”
14:57:40 <skypers> well not really
14:57:50 <skypers> I just wonder why we don’t have something like:
14:58:06 <skypers> newtype State s a = State (s -> (s,a))
14:58:28 <skypers> runState s (State f) = f s
14:59:11 <jle`> Cale: so...is there any real way to do what I'm trying to do?
14:59:18 <Cale> jle`: okay, so it's quite obvious that the authors of this library cared nothing for anyone who would ever want to manipulate the markup in any way other than to turn it into a string
14:59:26 <Cale> But yes, I'm sure there is
14:59:39 <Cale> However, you shouldn't need to define a new data declaration...
14:59:51 <jle`> Cale: oh i wasn't intending to
14:59:53 <Cale> okay
14:59:56 <jle`> that data decl was only for demonstration
15:00:00 <jle`> a self-contained simplified example
15:00:14 <Cale> so, what are you trying to do with this tree exactly?
15:00:22 <skypers> but yeah
15:00:28 <jle`> add a class to every element that matches a predicate
15:00:37 <skypers> an applyState or something like that would be neat
15:00:49 <jle`> maybe there is some better HTML library
15:00:50 <skypers> and I think we have the same issue with Writer
15:00:54 <Cale> What do elements look like?
15:01:00 <skypers> (and also the mtl versions)
15:01:04 <skypers> (dammit!)
15:01:08 <Cale> Yeah, this is not the library you want to be using to manipulate HTML
15:01:16 <jle`> um... <p></p>'s that begin with a certain string
15:01:18 <Cale> It is 100% only for generation.
15:01:31 <Cale> jle`: I mean, as MarkupM structures
15:01:38 <Cale> but I guess that's hard for you to tell
15:01:45 <jle`> oh, i was going to look into that as soon as i figured out how to inspect one
15:01:49 <Cale> given that there's no real Show instance
15:01:51 <jle`> well see Pandoc uses this
15:01:54 <jle`> to output their HTML
15:01:58 <jle`> so I got one from Pandoc
15:02:04 <jle`> and i was going to break it apart and check it out
15:02:08 <jle`> but i alas i cannot.
15:02:27 <Cale> http://hackage.haskell.org/package/html
15:02:29 <jle`> i guess i could just do it at the Text/bytestring level
15:02:38 <jle`> hm.
15:02:52 <Cale> here is a very simple HTML library which will nonetheless make this problem much easier to solve
15:03:02 <jle`> so Pandoc only outputs Blaze
15:03:11 <jle`> so I should...get the Blaze output
15:03:13 <jle`> convert it to HTML
15:03:18 <Cale> oh
15:03:18 <jle`> and
15:03:28 <jle`> then output that i guess.
15:03:34 <jle`> well see my templating engine runs on blaze
15:03:35 <skypers> blaze-html is a great lib
15:03:41 <Cale> oh, this one doesn't have a parser, let me find something else
15:03:52 <jle`> so having pandoc output blaze was pretty convenient because it integrated my blaze templates
15:03:57 <Cale> We just want something which generates a proper tree structure
15:04:04 <Cale> Not Blaze
15:04:18 <Cale> (I actually think Blaze is terrible in this regard)
15:04:47 <Cale> http://hackage.haskell.org/package/xmlhtml-0.2.3/docs/Text-XmlHtml.html -- here we go
15:04:49 <jle`> well...on the other hand i can hack pandoc to support syntax for adding classes to paragraphs
15:04:51 <Cale> this has a parser
15:05:08 <jle`> or i can add the classes in at the bytestring level
15:05:28 <jle`> hm okay.
15:05:41 <skypers> @let asState = flip runState
15:05:42 <lambdabot>  Defined.
15:05:46 <Cale> Or I suppose you could do something much more hacky and use tagsoup
15:06:07 <Cale> http://hackage.haskell.org/package/tagsoup-0.13/docs/Text-HTML-TagSoup.html
15:06:11 <vivian> what is Eq ?
15:06:24 <Cale> vivian: Eq is the class of types which support equality testing
15:06:26 <Iceland_jack> vivian: Eq is a type class
15:06:40 <vivian> I don't understand why do we need classes
15:06:40 <Cale> i.e. types whose values can be compared with (==) and (/=)
15:06:42 <Iceland_jack> vivian: You can think of it as a set of every type you can compare using (==)
15:06:43 <jle`> if you come from an OOP background you can think of it as an interface
15:06:57 <jle`> it is an interface which requires the method .isEqualTo
15:06:59 <jle`> (0
15:07:01 <jle`> ()
15:07:20 <dhrosa> vivian: it lets you write a function that can work on any type that is an instance of Eq (defines ==)
15:07:21 <skypers> > 0 `asState` (forM [1..3] $ \x -> do { s <- get; modify (+1); return s*x }
15:07:21 <adelbertc> if i have, say, "hoogle" isolated in a sandbox (cabal sandbox init; cabal install hoogle) and put on my PATH (so i may use the hoogle executable), how do i upgrade hoogle if there is one available
15:07:22 <lambdabot>  <hint>:1:74:
15:07:22 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
15:07:26 <Cale> vivian: Suppose that you want to write a function to sort a list. You'd like to write it once, rather than once per type of elements of the list, since it's the same algorithm each time
15:07:26 <Iceland_jack> vivian: Do you agree that there are some types you cannot compare for equality?
15:07:27 <dhrosa> vivian: so you can write generic code and still have type safety
15:07:34 <skypers> > 0 `asState` (forM [1..3] $ \x -> do { s <- get; modify (+1); return s*x } )
15:07:35 <lambdabot>  No instance for (GHC.Show.Show b0)
15:07:35 <lambdabot>    arising from a use of `M41316264182168698189085.show_M41316264182168698189...
15:07:35 <lambdabot>  The type variable `b0' is ambiguous
15:07:35 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
15:07:35 <lambdabot>  Note: there are several potential instances:
15:07:38 <skypers> holy
15:07:43 <platz_> HXT?
15:07:54 <skypers> > 0 `asState` (forM [1..3 :: Int] $ \x -> do { s <- get; modify (+1); return s*x } )
15:07:55 <lambdabot>  Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
15:07:55 <lambdabot>                                  b0 Data.Functor.Identity.Identity b0'
15:07:55 <lambdabot>              with actual type `GHC.Types.Int'
15:08:06 <skypers> gonna try that in ghci ahah
15:08:40 <Cale> vivian: You might hope that you could have sort :: [a] -> [a], but this won't work, because not knowing anything about the type a means that you can't apply any operations to those values to compare them, and for some types a there might not be a reasonable way to test whether x < y given x,y :: a
15:08:50 <Cale> vivian: For example, if a is some type of functions
15:09:21 <Cale> vivian: So you need a way to say that sort will take a list of values of any type on which an ordering comparison has been defined
15:09:31 <jle`> Cale: thanks for the help, i'll look into the library with a proper internal data structure and maybe go Markdown -> Pandoc -> Blaze -> Text -> XmlHtml -> Text -> Blaze -> Server
15:09:42 <Cale> and so in Haskell, we write  sort :: (Ord a) => [a] -> [a]
15:10:00 <Cale> Ord is a type class which defines operations such as (<)
15:10:24 <Cale> and also is a subclass of Eq, so sort will be allowed to test for equality as well if it wants to
15:10:45 <Cale> It looks like this:
15:10:49 <Cale> class Eq a where
15:10:51 <ChongLi> what do I do with a gtk Signal?
15:10:55 <Cale>   (==) :: a -> a -> Bool
15:10:57 <skypers> > 0 `asState` (forM [1..3] $ \x -> do { s <- get; modify (+1); return $ s*x })
15:10:57 <Cale>   (/=) :: a -> a -> Bool
15:11:00 <lambdabot>  ([0,2,6],3)
15:11:04 <skypers> :)
15:11:06 <Cale> class Eq a => Ord a where
15:11:08 <ChongLi> there don't seem to be any functions which accept a Signal
15:11:13 <Cale>   compare :: a -> a -> Ordering
15:11:20 <skypers> hm, the problem is that we need the same for exec and eval
15:11:26 <Cale>   (<), (<=), (>), (>=) :: a -> a -> Bool
15:11:48 <novodinia> "If a type contains type parameters, we say that it is a parameterised type, or a polymorphic type. If a function or value's type contains type parameters, we call it polymorphic." is confusing me.
15:11:58 <novodinia> "If a type contains parameters, we say it is a parameterized type. If the type of a function contains type parameters, we call the function polymorphic." is supposed to be clearer, but it's also confusing.
15:12:07 <novodinia> Does anyone want to comment on this?
15:12:16 <vivian> Cale: I kind of get it thanks!
15:12:22 <skypers> yeah, it would be better if runState, execState and evalState were already flipped :(
15:12:30 <skypers> what a pity
15:12:31 <the_berserker> > writeFile "abc"
15:12:32 <lambdabot>  <[Char] -> IO ()>
15:12:43 <skypers> the_berserker: it’s fordibbiden
15:12:46 <skypers> woh
15:12:48 <skypers> new word
15:12:50 <Saizan> novodinia: where is that from?
15:12:51 <skypers> fordibbiden
15:12:51 <Cale> vivian: no problem!
15:13:23 <skypers> I guess I’ll have to stick to flip {run,exec,eval}State{T} :(
15:13:49 <novodinia> Saizan: Real WorldHaskell
15:13:49 <Cale> novodinia: Can you express anything about what you find confusing?
15:15:17 <jfischoff> Learning how to recognize the kind of type makes the idea of type parameters clearer
15:15:24 <Cale> novodinia: It's not really saying anything all that profound. Just that if things have type variables in their types, then we call them polymorphic, because those type variables could be substituted for any type (or any type satisfying whatever type class constraints are present)
15:16:16 <novodinia> I think it is saying this: [a] is a parameterized type, because `a` can be any type, and if you create your own function, say `drop' n xs`, this function, in theory, is a polymorphic function because its parameters can be of various types?
15:16:27 <novodinia> maybe drop' is a bad example
15:16:31 <Cale> For example, map :: (a -> b) -> [a] -> [b] is polymorphic, as its type has the variables a and b in it
15:16:34 <jle`> well not all custom functions are polymorphic
15:16:44 <Cale> novodinia: Yeah, you've got it
15:16:54 <jle`> but yeah
15:16:55 <novodinia> since the definiton would be expecting to operate on some Integral n
15:17:21 <jle`> technically depending on how you define it it could be on any Num n
15:17:26 <novodinia> Okay, thanks Cale. The wording confused me.
15:17:36 <jle`> if you only use (-) and (> 0)
15:17:39 <novodinia> I wonder why Pat's suggestion wasn't included in the book.
15:18:05 <heatsink> Is it right to say that a parameterized type "contains" parameters?  That makes it sound like "Either Int Int" is a parameterized type.
15:18:10 <Cale> novodinia: Regardless of what sort of numbers are involved, your drop function will likely be polymorphic because it won't care what type the elements of the list have.
15:18:16 <heatsink> it contains two Int parameters.
15:18:19 <geekosaur> ChongLi: I think you can't find it because it actually belongs to glib, which is missing documentation on hackage
15:18:38 <Cale> heatsink: 'has' would be better
15:18:50 <Cale> 'contains' is a bit weird
15:19:08 <Cale> Either has two type parameters
15:19:15 <novodinia> Cale: a function is onsidered polymorphic if just one of its parameters will most likely vary in type?
15:19:18 <heatsink> As I understand it, "Either" is a parameterized type, and "Either a b" is just a type
15:19:25 <Cale> novodinia: It doesn't have to be a function
15:19:25 <henk> Philonous: https://www.gnu.org/licenses/gpl-faq.html#IfLibraryIsGPL ):
15:19:31 <Cale> :t 5
15:19:32 <lambdabot> Num a => a
15:19:35 <jle`> novodinia: it is considered polymorphic if it can operate on things with different types
15:19:38 <Cale> ^^ the literal 5 is polymorphic
15:19:50 <Cale> (It can be any type of number)
15:19:54 <geekosaur> ChongLi: although I have a recollection that the main thing you use it with is `on` (not the same as Data.Function.on) which is also missing documentation
15:20:03 <jle`> novodinia: for example, id is polymorphic
15:20:05 <jle`> :t id
15:20:06 <lambdabot> a -> a
15:20:08 <jle`> it works on Ints
15:20:12 <jle`> on Integers
15:20:19 <jle`> on Booleans
15:20:23 <Cale> :t maxBound
15:20:23 <lambdabot> Bounded a => a
15:20:29 <jle`> it even works on functions
15:20:35 <Cale> maxBound is also polymorphic, but likely not a function
15:20:38 <novodinia> Thanks for the help
15:20:47 <henk> Seems as soon as I import from one package that’s GPL'ed my program has to be GPL'ed too ):
15:20:49 <jle`> what is an example of a non-polymorphic function in Haskell...
15:20:50 <novodinia> Cale, you are answering questions left and right in here
15:20:51 <Cale> (it picks out the maximum element of a bounded type)
15:21:01 <jle`> hm
15:21:03 <Cale> novodinia: Yeah, I like helping :)
15:21:03 <jle`> :t chr
15:21:04 <lambdabot> Int -> Char
15:21:10 <jle`> chr is not polymorphic
15:21:10 <Philonous> henk, But that's what we told you?
15:21:15 <Cale> jle`: heh, yeah, it's a little hard to find them
15:21:16 <jle`> it only takes Ints and it only returns Char's
15:22:05 <jle`> chr can be made polymorphic though if you wanted to make it take any Integral...or even any Enum
15:22:11 <henk> Philonous: Hu? You said I could use BSD …
15:22:18 <jle`> but you can see in the type signature
15:22:25 <Cale> Sometimes you have to wonder whether ord and chr were left in (over fromEnum and toEnum) just so there would be examples of functions which weren't polymorphic in the basic libraries :)
15:22:29 <jle`> all of the types are concrete
15:22:37 <jle`> Cale: haha
15:23:14 <heatsink> :t not
15:23:18 <lambdabot> Bool -> Bool
15:23:43 <Philonous> henk, BSD is GPL-compatible
15:23:57 <jle`> heatsink: nice
15:24:07 <novodinia> Thanks again for the help!
15:24:11 <jle`> oh and i guess also and
15:24:15 <jle`> :t and
15:24:16 <lambdabot> [Bool] -> Bool
15:24:17 <jle`> well he's gone
15:24:24 <Philonous> henk, Maybe you are missing the "or a GPL-compatible license" part (it's in the next line)
15:24:25 <mietek> io-streams folks
15:24:39 <mietek> How the do you actually transform streams?
15:25:01 <silasm> BSD isn't GPL-compatible. It's not copyleft.
15:25:05 <mietek> http://hackage.haskell.org/package/io-streams-1.1.4.0/docs/System-IO-Streams-Tutorial.html#Examples doesn't actually show, say, transforming stdin
15:25:15 <Philonous> silasm, So what?
15:25:24 <henk> Philonous: Yeah, that just means that I can use GPL and BSD licensed libs in my code, but doesn’t mean my code can be BSD'ed.
15:25:28 <silasm> https://en.wikipedia.org/wiki/BSD_License
15:25:31 <henk> Philonous: https://www.gnu.org/licenses/gpl-faq.html#WhatIsCompatible
15:25:33 <csed> Hullo.
15:25:46 <henk> Philonous: + the following question
15:26:02 <silasm> Philonous: Code that depends on GPL has to be released copyleft
15:26:11 <Philonous> silasm, No.
15:26:19 <Philonous> silasm, The combined program has to be
15:26:26 <Philonous> silasm, The code you write doesn't.
15:26:35 <silasm> what's the difference?
15:26:56 <silasm> (seeing as I work on a linux distro I should really know these things...)
15:27:38 <quchen> silasm: You can use BSD-licenced code in GPL projects. You just can't re-release it "partially BSD", everything has to be GPL.
15:27:44 <Philonous> silasm, Say Anna write a GPL-ed library, Bob writes a piece of code that depends on it and he releases it as BSD3, then Charles can take this code, remove the part that is dependent on Annas code and release the (now unencumbered) version as BSD again (oder use it proprietarily)
15:27:50 <silasm> but yeah according to the wiki page BSD is *not* GPL compatible.
15:28:33 <silasm> quchen: okay, yeah, that I get.
15:28:51 <silasm> I thought henk was trying to release BSD
15:29:01 <henk> I am.
15:29:03 <quchen> GPL is a license ideal. Everything that touches GPL becomes GPL. GPL is closed under multiplication.
15:29:34 <silasm> ^
15:29:44 <supki> silasm: BSD-4 is not GPL-compatible
15:29:49 <supki> also noone uses it
15:30:04 <silasm> in that sense BSD is not GPL compatible (whereas, say, MPL (Mozilla Public License)) is.
15:30:19 <silasm> but you can use BSD code in a GPL-licensed codebase.
15:30:49 <silasm> but I think the term "GPL-compatible" refers to the previous meaning, for which BSD does not qualify.
15:31:16 <Philonous> silasm, You can write BSD-ed code that depends on GPLed code as long as you don't release it with the GPLed code. The code you write remains BSD until someone actually combines it.
15:31:18 <henk> So, can I publish my code under BSD and my binaries under GPL? (:
15:31:22 <zacts> silasm: well I think the gpl3 has a clause that allows you to retain the bsd notice, but mix it with the gpl code some how.
15:31:43 <zacts> but that sucks
15:31:51 <silasm> :S licenses are weird.
15:32:07 <zacts> you should contribute back to the projects under the same license of the project
15:32:13 <Philonous> henk, As soon as you combine it averyting becomes GPL.
15:32:19 <silasm> Philonous: ah
15:32:28 <pingu> Does anyone that works the hackage mailbox for upload privileges live here? I presume it's a faux pas to ask so I'm not asking.
15:32:43 <Philonous> henk, But the bits you write can be BSD3
15:32:47 <acowley> Can cabal-install be made to install things mentioned in the build-tools stanza of a cabal file? (i.e. cpphs)
15:32:47 <silasm> so you basically list GPL code as a dependency but only distribute the BSD part, works for me.
15:33:16 <henk> Philonous: Does dynamic linking count as combining?
15:33:28 <Philonous> henk, The idea being, that you can possible replace the dependency on the GPL-ed code later and release everything as BSD
15:33:28 <lispy> henk: no one knows for sure
15:33:39 <Philonous> henk, I think so.
15:33:44 <lispy> henk: It hasn't been sufficiently tested in the courts.
15:33:47 <henk> lispy: That’s my impression too ):
15:34:17 <lispy> Some people argue that it's a mechanicaly derived work and thus copyright doesn't count.
15:34:32 <lispy> And other say that it's a normal derived work and thus it does cover it
15:36:02 <henk> https://www.gnu.org/licenses/gcc-exception-faq.html
15:36:17 <zacts> see section 7 of the gpl3
15:37:08 <lispy> henk: I think this a less biased source: http://en.wikipedia.org/wiki/GNU_General_Public_License#Linking_and_derived_works
15:37:42 <zacts> I like the bsd > gpl merely because it is "free software", but it also is far less complex legally
15:39:15 <lispy> zacts: I like it because it allows businesses to use the software. If they really want to be jerks they could still exploit gpl'd stuff the way I see it.
15:39:21 <lispy> (it being bsd3)
15:40:00 <m1dnight> how can I ask lambdabot for the source of tell etc, for WriterMonad?
15:40:22 <lispy> m1dnight: it has a pretty small database for @src. You're better off using hoogle.
15:40:27 <geekosaur> probably can't; the @src database is tiny and sometimes lies.
15:40:33 * hackagebot case-insensitive 1.1.0.3 - Case insensitive string comparison  http://hackage.haskell.org/package/case-insensitive-1.1.0.3 (BasVanDijk)
15:40:42 <lispy> m1dnight: I setup a shortcut in my browser. I type 'h something' and it searches hoogle for something.
15:40:42 <silasm> I've heard of issues where companies take BSD code, use it in their proprietary products, and then turn around and sue the BSD developers for releasing their own source. Or something like that. Has that ever actually happened (I think it was Sony) or am I remembering wrong?
15:40:54 <geekosaur> hoogle or hayoo will have source links on the right
15:41:15 <m1dnight> oh never noticed the source on the right
15:41:16 <m1dnight> thanks guys
15:41:26 <lispy> m1dnight: you are welcome.
15:41:26 <geekosaur> (actually they have links to the hackage docs, which have those source links)
15:42:44 <quchen> silasm: The WTFPL is fairly easy and integrates well with other projects.
15:43:01 <silasm> regarding the "usable by companies" thing, I'm on the fence. I've been at startups where the GPL viral-ness was an issue and I'm currently at one where it's not.
15:45:34 * hackagebot hierarchical-exceptions 1.0.0 - Template Haskell functions to easily create exception  hierarchies  http://hackage.haskell.org/package/hierarchical-exceptions-1.0.0 (BenjaminBarenblat)
15:47:02 <silasm> sometimes I like the GPL forcing companies to adopt a model that works with open source, but at the same time I recognize that it doesn't always work, so ehhh...
15:52:23 <ChongLi> is there some website which documents all of the options in a .cabal file?
15:54:02 <henk> lispy: thanks
15:55:00 <geekosaur> ChongLi, http://www.haskell.org/cabal/users-guide/developing-packages.html#package-descriptions
15:55:22 <ChongLi> geekosaur: ahh, I was on that page but I didn't see that
15:55:24 <ChongLi> hmmm
15:55:37 <ChongLi> err
15:55:43 <ChongLi> no I was just on the users guide
15:55:56 <acowley> Can cabal-install be made to install things mentioned in the build-tools stanza of a cabal file? (i.e. cpphs)
15:56:12 <ChongLi> http://www.haskell.org/cabal/
15:56:20 <ChongLi> there's no link to that developing packages section from here
15:56:21 <ChongLi> :(
15:56:35 <geekosaur> not a direct one, but there is a link to the manual
15:56:40 <dcoutts_> ChongLi: it links to the user guide
15:57:03 <ChongLi> yeah, the developing packages link is sort've buried in the users guide
15:57:06 <dcoutts_> and the contents there links to the various sections, including creating packages
15:57:23 <mercuryrising> if anyone has a chance, could you look over my haskell craps game? http://www.reddit.com/r/haskellquestions/comments/1v59z5/code_critique_for_haskell_craps/
15:57:25 <dcoutts_> Contents >> Creating Packages
15:57:51 <dcoutts_> ChongLi: suggestions on making it clearer welcome
15:58:13 <lispy> acowley: it can complain if they're missing but I don't think it will try to install them
15:58:34 <acowley> lispy: Thanks, that's what I thought. I got a bug report about it so wanted to make sure I wasn't out of date.
15:58:34 <ChongLi> dcoutts_: just put a link to "Creating Packages" on the quick links here: http://www.haskell.org/cabal/
15:58:45 <lispy> dcoutts_: do you know?
15:58:57 <Iceland_jack> mercuryrising: You may want to create a data type for Winner/Loser
15:59:06 <ChongLi> dcoutts_: I hope it doesn't seem like I'm making a big deal of this
15:59:26 <ChongLi> it's just that I consider myself pretty savvy at finding information and I wasn't able to find this without asking here
15:59:31 <ChongLi> others may not be so patient
15:59:33 <mietek> http://hackage.haskell.org/package/pipes-bytestring-1.0.2/docs/Pipes-ByteString.html#v:lines
15:59:44 <mietek> Split a byte stream into FreeT-delimited lines
15:59:45 <mietek> Great
15:59:59 <mietek> What can I do with a FreeT (Producer BS.ByteString m)?
16:00:02 <geekosaur> enh. keep in mind I just drilled down to find it, thinking logically
16:00:19 <geekosaur> user's guide > developing packages > package descriptions
16:00:24 <ChongLi> ahh
16:00:30 <ChongLi> see I clicked on the user's guide
16:00:33 <Iceland_jack> mercuryrising: You don't need: getStdRandom (randomR (1,6))
16:00:37 <Iceland_jack> if you're using IO anyway
16:00:42 <ChongLi> took a quick glance at the content and assumed it was for end users, not developers
16:00:58 <mietek> Specifically, any idea how to get the number of lines out of that?
16:01:09 <mercuryrising> i'd rather not use IO so I can talk to other functions easily (is there an option for that with random?)
16:01:13 <Iceland_jack> randomR is a pure function, you can use randomRIO instead
16:01:14 <ChongLi> perhaps have a link "Developer's Guide" below "User's Guide" on the main page
16:01:16 <Iceland_jack> @hoogle randomRIO
16:01:17 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
16:01:48 <dcoutts_> acowley, lispy: cabal-install's dep resolver does not yet do anything automatic with dependencies other than Haskell libs. So it does nothing clever with C lib deps nor build tools.
16:02:28 <acowley> dcoutts_: Thanks for confirming! Would offering to install something like cpphs come with any downsides?
16:02:40 <Iceland_jack> mercuryrising: You can pass in a RandomGen
16:02:45 <Iceland_jack> or use a random monad
16:02:50 <dcoutts_> acowley: not sure what you mean exactly.
16:03:21 <dcoutts_> acowley: certainly it would be good if the solver were extended to understand a range of kinds of dependencies including C libs and build tools
16:03:27 <acowley> dcoutts_: There's a finite number of build tools cabal-install knows about. When it's printing a message "cpphs not found" it could offer to run "cabal install cpphs"
16:03:40 <Iceland_jack> > (\stdgen -> randomR (1, 6) stdgen) (mkStdGen 14) -- mercuryrising
16:03:41 <lambdabot>  (6,600210 40692)
16:03:51 <dcoutts_> acowley: actually it's not really cabal-install that is printing that error
16:04:00 <acowley> ah
16:04:07 <dcoutts_> acowley: and it does not know that there is a package corresponding to the build tool requested
16:04:19 <dcoutts_> acowley: since you can also list build-tools: perl
16:04:21 <Iceland_jack> mercuryrising: All of that is a pure computation, you just need to get an impure StdGen
16:04:59 <dcoutts_> acowley: doing it properly would involve extending the solver and making a mapping of build tools to the packages that provide them
16:05:05 <acowley> dcoutts_: I could have sworn I'd seen someplace in the cabal or cabal-install code where about a dozen build tools have specific associated definitions
16:05:45 <acowley> Here: https://github.com/haskell/cabal/blob/master/Cabal/Distribution/Simple/Program/Builtin.hs
16:06:21 <Iceland_jack> mercuryrising: (for something like ‘craps’ you can use something like ‘| diceSum `elem` [2, 3, 12] → lose diceSum’
16:06:37 <acowley> happy and alex are the most likely to benefit from a little bit of installation grease, but cpphs is a reasonable third candidate for special handling.
16:07:38 <Iceland_jack> mercuryrising: Also for ‘rollDice’ you can just as well end with ‘return (d1 + d2)’ and omit the let
16:08:05 <bitemyapp> acowley: oh, hullo there!
16:08:20 <Iceland_jack> Or you can make rollDice into
16:08:20 <Iceland_jack>     rollDice = liftM2 (+) rollDie rollDie
16:08:20 <Iceland_jack> or
16:08:24 <Iceland_jack>     rollDice = (+) <$> rollDie <*> rollDie
16:08:24 <acowley> bitemyapp: Hello!
16:09:57 <mercuryrising> Iceland_jack, thanks a lot, i'm making changes as you're talking, new to haskell so don't know all the fancy words yet
16:10:26 <Iceland_jack> mercuryrising: You can make all of your ‘random’ logic pure
16:10:52 <mercuryrising> if i do that, my functions can be functions, rather than having a do block in them?
16:11:11 <Iceland_jack> mercuryrising: (do-notation does not imply impurity)
16:11:32 <Iceland_jack> But yes you can have pure functions instead of impure ones then
16:13:26 <Iceland_jack> > let seed = mkStdGen 14; (d1, seed2) = randomR (1, 6) seed; (d2, seed3) = randomR (1, 6) seed2 in (d1, d2) -- mercuryrising
16:13:27 <lambdabot>  (6,1)
16:13:32 <Iceland_jack> > let seed = mkStdGen 14; (d1, seed2) = randomR (1, 6) seed; (d2, seed3) = randomR (1, 6) seed2 in (d1, d2)
16:13:33 <lambdabot>  (6,1)
16:13:55 <Iceland_jack> This always returns the same value (because the initial seed ‘seed = mkStdGen 14’ is always the same)
16:14:24 <acowley> Do we have binary literals?
16:14:48 <Iceland_jack> You can then use an impure function in main (or where ever) to get a new seed every time
16:14:48 <Iceland_jack> @hoogle stdGen
16:14:48 <lambdabot> System.Random data StdGen
16:14:48 <lambdabot> System.Random getStdGen :: IO StdGen
16:14:48 <lambdabot> System.Random mkStdGen :: Int -> StdGen
16:15:42 <Iceland_jack> mercuryrising: When you get tired of threading the random value through your computations, take a look at http://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random.html
16:16:09 <Iceland_jack> An alternative is to pass the ‘craps’ function an infinite list of random rolls
16:18:45 <Iceland_jack> mercuryrising: You can also omit the ($) from things like
16:18:46 <Iceland_jack>     pointCraps roll $ rollDice
16:18:46 <Iceland_jack>     pointCraps point $ rollDice
16:19:01 <Iceland_jack>     a b c d
16:19:01 <Iceland_jack> gets associated as
16:19:01 <Iceland_jack>     ((a b) c) d
16:22:42 <mercuryrising> thanks a lot Iceland_jack!!!
16:22:55 <Iceland_jack> no problem
16:23:02 <mercuryrising> still treading water, but I'll make some changes and see what happens
16:24:05 <Iceland_jack> mercuryrising: something like randomRs is a pure function that generates an infinite list (stream) of random numbers in a range
16:24:08 <Iceland_jack> @hoogle randomRs
16:24:08 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
16:24:25 <Iceland_jack> > randomRs (1, 6) (mkStdGen 14)
16:24:26 <lambdabot>  [6,1,5,2,6,2,3,4,4,6,3,5,3,5,3,4,6,6,2,3,6,5,5,3,3,6,4,2,6,1,6,4,2,5,1,3,6,4...
16:24:56 <mietek> *sigh*
16:25:19 <randomclown> why are there so many 5s and 3s
16:25:27 <mietek> I'd like to convince someone that Haskell is a pretty good language
16:25:40 <mietek> But I can't seem to be able to write a fast "wc -l" equivalent
16:25:49 <mietek> I wrote one using io-streams, and it's 10x slower than "wc -l"
16:26:17 <pqmodn> acowley: i wish we had binary literals, but i guess there's this http://hackage.haskell.org/package/binary-literal-qq
16:26:20 <randomclown> mietek: you probably want to use conduits or similar
16:26:41 <mietek> randomclown: io-streams is similar to conduits
16:26:46 <Iceland_jack> mercuryrising: so if you use ‘getStdGen’ in main you can use it like this
16:26:46 <Iceland_jack>     main = do
16:26:47 <Iceland_jack>       stdgen ← getStdGen
16:26:47 <Iceland_jack>       print (craps stdgen)
16:26:53 <mietek> While also being understandable by mere mortals such as myself
16:27:02 <ion> iceland_jack: No. You’ll want newStdGen.
16:27:04 <mietek> I tried to write another version using pipes, but I failed
16:27:10 <Iceland_jack> right
16:27:12 <mietek> I have no idea how people use these libraries
16:27:27 <acowley> pqmodn: Hmph, thanks. That seems a bit much to pull in for a smidgen of convenience
16:27:31 <mietek> Here's my io-streams version: http://pastie.org/private/5hzetgtzkqvx0eydsuxvfa
16:28:00 <pqmodn> acowley: agreed. though, maybe not, looking at the amount of code in the github repo https://github.com/mboes/binary-literal-qq :)
16:28:01 <mietek> The lazy IO one-liner is 1000x slower than "wc -l"
16:28:07 <mietek> main = interact (show . length . lines)
16:28:22 <mietek> The imperative-style System.IO runs out of stack
16:28:35 <quup> Hi, I have this problem: http://www.haskell.org/haskellwiki/How_to_get_rid_of_IO a function gives me type "IO a" and I want to apply a function that takes type "a" to the result, I can't google for =<< and the link to "do notation" is broken, what do I do? (say f::String -> IO [String] and g::[String]->Bool and foo holds a result of f)
16:28:41 <mietek> I am seriously starting to doubt my language choice right now
16:29:04 <Rembane> quup: fmap can help you.
16:29:11 <Rembane> :t fmap
16:29:12 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:29:23 <Rembane> Hm... not a very helpful type, bah.
16:29:31 <quup> Rembane: thanks, will check it out
16:29:43 <Ralith> :t Prelude.fmap
16:29:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:29:47 <Ralith> hm
16:29:50 <Rembane> quup: No worries.
16:29:54 <Ralith> oh right
16:30:05 <Ralith> it's . that has the weird type signature
16:30:51 <Rembane> :t (.)
16:30:52 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:31:03 <Rembane> It's in the wrong order! :D
16:31:10 <quchen> quup: You can use Hoogle to search for Haskell functions (by type, name, module, package, ...). http://www.haskell.org/hoogle/
16:31:26 <quup> quchen: yea, checking http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#v:fmap now
16:31:56 <quchen> quup: As for the IO issue, I suggest you read a proper introduction to Haskell instead of putting together the pieces from the internet.
16:32:02 <jfischoff> what is a good strategy for testing Shake files?
16:32:11 <quchen> LYAH is the usual reocmmendation, learnyouahaskell.com
16:32:14 <zett_zelett> Our homework was to write a function permutation :: [a] -> [[a]] which gives all permutations of a given list, i.e. permutation [1,2,3] = [[1,2,3],[1,3,2],[2,1,3],[2,3,1],…]
16:32:31 <zett_zelett> And we get extra credit if we do this without using the Eq typeclass.
16:32:32 <zett_zelett> ANYWAY.
16:32:37 <quup> quchen: trying to do homework 2 in http://www.cis.upenn.edu/~cis194/lectures.html
16:32:43 <zett_zelett> I managed to do it but it seems pretty inefficient.
16:32:45 <quup> quchen: (parse a log file)
16:33:08 <pqmodn> zett_zelett: paste your code at http://lpaste.net/new/haskell and someone might take a peek
16:33:13 <quchen> zett_zelett: There's Data.List.permutations http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#permutations
16:33:33 <quchen> Not fun to read, but probably your answer :-þ
16:33:37 <Iceland_jack> ..
16:33:58 <acowley> mietek: How does "main = BC.getContents >>= print . length . BC.lines" compare?
16:34:04 <acowley> import qualified Data.ByteString.Lazy.Char8 as BC
16:34:21 <acowley> Alternately
16:34:27 <quchen> ಠ_ಠ   Char8
16:34:32 <acowley> point me to a large enough text file to make this worth timing
16:34:42 <acowley> quchen: Does wc -l do something un-nasty?
16:34:45 <ij> Is it possible to shadow prelude without specifying each function?
16:34:58 <quchen> ij: Import it qualified
16:35:05 <shachaf> import Prelude ()
16:35:10 <ij> oh
16:35:11 <acowley> Obviously one can use Text
16:35:17 <shachaf> Or import Prelude hiding (...) or some other import.
16:36:16 <mietek> acowley: of course! ByteStrings
16:36:17 <mietek> Thanks.
16:36:51 <quchen> acowley: If what you want to do is count 0x0A bytes, why not do that. It won't count the number of lines though, because not every 0x0A is a newline.
16:36:51 <zett_zelett> quchen: It’s homework so we aren’t allowed to use it.
16:36:53 <zett_zelett> http://lpaste.net/98456
16:37:17 <quchen> zett_zelett: But you can let the source inspire you, that's why I linked it :-)
16:37:46 <zett_zelett> quchen: Well yeah, right.
16:38:03 <acowley> quchen: Fine, if you can count 0x0A bytes in less code than what I pasted then that's another answer to mietek's problem.
16:38:26 <quchen> I didn't know we were golfing, pardon
16:39:08 <zett_zelett> Yeah, well. My question is: How can I improve this http://lpaste.net/98456 performance-wise
16:40:25 <silasm> zett_zelett: the "l ++ [x]" is a red flag
16:40:30 <zett_zelett> Yeah.
16:40:39 <quchen> So is "last l"
16:40:47 <mietek> acowley: can we do the same with Data.Text?
16:40:59 <acowley> mietek: Sure!
16:41:00 <zett_zelett> But actually, my algorithm seems to be just as fast as the one in Data.List
16:41:02 <quchen> Well, at least it's a red hint.
16:41:19 <zett_zelett> As I just tested.
16:41:28 <acowley> mietek: But a common trap with comparing performance with classic C utilities is doing more than they do, then wondering why performance isn't as good.
16:41:32 <zett_zelett> So it’s okay, … I guess?
16:41:38 <mietek> acowley: true
16:41:58 <zett_zelett> I mean, the algorithm explodes anyway for really large n.
16:42:25 <quchen> > let sliceUp xs = zip (inits xs) (tails xs) in sliceUp [1..3] -- zett_zelett
16:42:26 <lambdabot>  [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
16:42:30 <silasm> I want to try a list monad approach to permutations now. Wonder how awful that would look...
16:42:41 <zett_zelett> Äh, of course!
16:43:01 <quchen> First (++ [x]) gone! :-)
16:43:43 <ij> mietek, What was the time now?
16:44:34 <shachaf> data Stream a = Cons a (Stream a); instance Semigroup Stream where x <> _ = x
16:44:43 <shachaf> Er, (Stream a)
16:45:09 <mietek> ij: that was actually faster than wc -l
16:45:29 <ij> sweet
16:45:39 <mietek> 0.450s vs 0.425s
16:46:01 <mietek> On a 500M file (mrna.fa from hg19)
16:46:18 <mietek> http://hgdownload.soe.ucsc.edu/goldenPath/hg19/bigZips/mrna.fa.gz
16:46:33 <mietek> And yeah, across several runs
16:46:42 <ij> Was about to ask that.
16:49:00 <mietek> utf8-string isn't the right choice, is it?
16:50:21 <dleedev> what's the associativity for :: (type declaration)?
16:50:35 <dleedev> for example: test1 = runProxy $ readInt >-> accum 2 >-> pairwiseAdd >-> printer :: IO ()
16:51:29 <Iceland_jack> You probably mean precedence
16:51:37 <dleedev> Iceland_jack: yes, precedence
16:52:06 <dleedev> does that mean test1 is IO ()?
16:52:19 <dleedev> or everything after $ is IO ()?
16:52:51 <Iceland_jack> dleedev: it should be easy to find out :)
16:52:53 <Iceland_jack> :t show $ 5 + 5 :: String
16:52:54 <lambdabot> String
16:52:55 <Iceland_jack> :t show $ 5 + 5 :: Int
16:52:56 <lambdabot>     Couldn't match type `[Char]' with `Int'
16:52:56 <lambdabot>     Expected type: Int
16:52:56 <lambdabot>       Actual type: String
16:53:29 <dleedev> Iceland_jack: so the whole line?
16:53:39 <Iceland_jack> yeah
16:53:44 <ij> mietek, hm? You mean which package to import from BS?
16:53:51 <ReinH> byorgey: pingly ping
16:54:04 <mietek> ij: no, I meant that utf8-string appears to be abandoned
16:54:21 * ij ducks.
16:54:42 <mietek> So if I wanted to process Unicode data, and not ASCII, I'd use Data.Text, right?
16:54:53 <acowley> mietek: Yes
16:54:59 <mietek> It appears to take 20 seconds for the same thing
16:55:01 <mietek> http://pastie.org/private/t8liuu3metnuqdmixls9wa
16:55:02 <shachaf> jfischoff: That's not a real isomorphism. It only works in one direction.
16:55:40 <acowley> mietek: Then maybe, no!
16:55:43 <acowley> :P
16:55:50 <mietek> :)
16:57:31 <ij> Would (concat.).map be slower than concatMap?
16:58:13 <quchen> dleedev, Iceland_jack: I think syntactic expressions `::` always span to the next syntactic element. Chapter 3 of the Report specifies the grammar.
16:58:35 <Iceland_jack> That's right, dleedev: :: is not an operator and doesn't have a fixity
16:58:54 <Iceland_jack> but if it did have associativity I would hope it's right associative :)
16:59:00 <Iceland_jack> no left!
16:59:02 <Iceland_jack> hah
16:59:13 <Iceland_jack> :t ((5 :: Int) :: Int) :: Int
16:59:14 <Roklobsta> bleah 39C outside and it's not even lunchtime.
16:59:14 <lambdabot> Int
16:59:22 <Roklobsta> fsck wrong channel
17:01:33 <silasm> mietek: Just making sure you don't have the same misconception I did: you can use ByteString to process Unicode; it just reads as raw bytes. It doesn't truncate or anything (assuming you're using, e.g. readFile and not, e.g. converting it from a String)
17:02:49 <silasm> if you try to convert a unicode String to a ByteString in ghci or so it'll truncate (because it's a map operation), but if you ByteString.readFile it reads every byte. That sidetracked me.
17:03:02 <mietek> silasm: yep yep
17:03:29 <mietek> I am aware that '\n' in UTF-8 are still '\n's
17:03:56 <silasm> so if you're doing, e.g. compression (like I was/am), use ByteString. If you're doing, e.g. Text Editing or Yesod or whatever, use Text.
17:04:00 <mietek> Was curious what it would take to count Unicode glyphs
17:04:48 <Axman6> Roklobsta: where in Aus are you? =)
17:05:52 <silasm> mietek: if you care about processing unicode character by unicode character you'd probably want Text, yeah.
17:06:00 <Roklobsta> Axman6: SW Vic
17:06:14 <Axman6> nice, near the coast?
17:06:19 <silasm> because ByteString would split them up and you'd end up with extras unless you processed them.
17:06:32 <Roklobsta> yeah, should get a sea breeze tonight
17:06:41 <mietek> silasm: indeed, thanks
17:06:49 <Axman6> hopefully it'll come our way (Canberra)
17:08:15 <Roklobsta> Axman6: I grew up there.  It'll be stinkin' hot all night.
17:08:32 <Axman6> not with the aircon on >_>
17:19:04 <ReinH> ~_~
17:27:18 <silasm> hm, I wonder if you could make Text sufficiently lazy that it would only evaluate the first Byte of each codepoint when writing a wc program. UTF-8 seems to allow that.
17:28:02 <silasm> s/writing/running/
17:29:04 <silasm> don't know that there'd even be anything to gain there, but random thought.
17:40:48 * hackagebot hsparql 0.2.5 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  http://hackage.haskell.org/package/hsparql-0.2.5 (RobStewart)
17:42:59 <dhrosa> how might I take a list, and divide it into chunks of let's say, 3?
17:43:18 <dhrosa> is there a built-in way / simple composition of built-in functions for this?
17:43:28 <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/split-0.2.2/doc/html/Data-List-Split.html#v:chunksOf
17:46:49 <pingu> dhrosa: try:
17:46:59 <pingu> chunk n [] = []
17:47:03 <pingu> chunk n xs = as : chunk n bs where (as,bs) = splitAt n xs
17:48:26 <dhrosa> i just came up with that chunk function independently,I  was hoping to not have to add more lines to my where block, oh well
17:48:39 * geekosaur points up
17:49:01 <pingu> dhrosa: in that case no, there's no magic prelude chunk
17:49:03 <geekosaur> [14 01:37] <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/split-0.2.2/doc/html/Data-List-Split.html#v:chunksOf
17:49:16 <geekosaur> not Prelude, but you should have the Platform installed
17:49:45 <dhrosa> oh, I wasn't aware that was part of the platform
17:50:44 <dhrosa> thanks
17:50:58 <dhrosa> also pingu, I think you need ++ there and not :
17:51:25 <geekosaur> no, (:) is correct
17:51:38 <geekosaur> one chunk : recursive list of following chunks
17:51:50 <dhrosa> oh derp
17:52:07 <dhrosa> my chunk function ends up being the identity, hah
17:52:13 <geekosaur> otherwise you end up concatenating the original list back together, yeh
18:10:33 <someguy123420> http://lpaste.net/98462  i'm trying to make a simple json pass through that can run bash commands.  problem i am running into now is OPTIONS/PUT not being in scope and not being able to import them (and probably other things)
18:10:40 <someguy123420> me.hs:13:73: Module `Network.Wai' does not export `Method(..)'
18:13:26 <jle`> is writeFile lazy? (does it write strings as it gets it, or does it wait for the function returning the string to finish evaluating and then writes it all at once)
18:14:22 <pingu> jle`: writeFile from lazy bytestring?
18:14:34 <jle`> pingu: writeFile from Prelude
18:14:39 <jle`> on String
18:14:53 <pingu> jle`: I'm pretty sure that's not going to be lazy in that sense.
18:14:58 <pingu> It's going to require as much memory as the file
18:15:14 <pingu> lazy bytestring should write in constant space though, that's kind of the point of it
18:15:39 <pingu> jle`: you could do a pretty simple test, write a big string and run with +RTS -s
18:15:45 <jle`> pingu: hm yeah.
18:21:15 <rasfar> anyone know how to make hp2ps output wider? running into trouble with ghc -L above 50...
18:21:52 <rasfar> hp2html is kinda broken (in this browser anyway)
18:22:18 <rasfar> hp2any -- would love to try, but can't get the GTK lib installed here
18:23:34 <rdevilla> Any opinions on TDD in Haskell?
18:25:34 <rdevilla> I am thinking of developing a small web application in Happstack using HUnit
18:25:59 <kyrylo> Hi! A simple question. Are the parentheses around class constraints mandatory?  That is, are these two type signatures equivalent? 1) foo :: Integral a => a -> String 2) foo :: (Integral a => a -> String
18:26:28 <kyrylo> Whoops, a typo in the second signature. 2) foo :: (Integral a) => a -> String
18:27:23 <roboguy_> kyrylo: they're mandatory if there is more than one constraint
18:28:02 <rasfar> there's hp2ps -e option, but -e24in and still no joy...
18:28:16 <rasfar> do people prefer hp2any mostly?
18:28:28 <kyrylo> roboguy_, is it a good habit to always write them?
18:31:19 <roboguy_> kyrylo: it can't hurt, but I don't think it matters too much
18:31:45 <roboguy_> it's a compile time error, after all
18:34:18 <kyrylo> I got it. Thanks!
18:35:54 * hackagebot language-bash 0.3.1 - Parsing and pretty-printing Bash shell scripts  http://hackage.haskell.org/package/language-bash-0.3.1 (KyleRaftogianis)
18:40:03 <lingxiao> hey all
18:40:15 <lingxiao> what's wrong with the way I'm declaring this class?
18:40:24 <lingxiao> https://gist.github.com/anonymous/9ec48cab81c2d73d7b7d
18:40:40 <lingxiao> I'm getting  `encode' is not a (visible) method of class `DeBrujin'
18:40:57 <roboguy_> lingxiao: the 'b' type is coming out of nowhere, for one
18:41:14 <roboguy_> that should probably be a multiparameter type class. probably with functional dependencies as well
18:41:45 <roboguy_> you probably shouldn't be getting that error either way though...
18:42:08 <roboguy_> definitely turn the tabs into spaces though. tabs are not good to use with haskell
18:42:39 <lingxiao> yeah even this does not work
18:42:39 <ChongLi> ant it should be 'DeBruijn'
18:42:42 <lingxiao> https://gist.github.com/anonymous/e0d604915b056ea9d83a
18:42:56 <lingxiao> ahhh
18:42:58 <lingxiao> it's a typo
18:43:24 <lingxiao> X(
18:43:58 <joelteon> it should be DeBruĳn
18:44:03 <ChongLi> and 'ant' should be 'and' :)
18:44:06 <flebron> This is perhaps a dumb question but, is there a way to use arbitrary precision floating point numbers, and compute logarithms to a given precision?
18:44:18 <flebron> (And by "is there a way", I mean "is there a usable library to")
18:44:27 <lingxiao> roboguy_: could you give me some tips on how to structure it with fun-dep?
18:44:28 <roboguy_> joelteon: yeah, but it's probably best to use characters in ASCII when possible
18:44:32 <ChongLi> joelteon: noooooo! ligatures and other utf-ness should stay out of source code
18:44:36 <joelteon> but why
18:44:51 <roboguy_> joelteon: better compatibility and no reason to do it here
18:44:51 <ChongLi> joelteon: because it causes display and input issues otherwise
18:44:57 <joelteon> lol, ok
18:44:57 <ion> LATIN SMALL LIGATURE RN
18:45:20 <roboguy_> lingxiao: a fun-dep tells the compiler than given a certain type another type will always be the same
18:45:27 <joelteon> by the way: http://hackage.haskell.org/package/valid-names
18:45:31 <lingxiao> I can see how it's a pair with two functions sending a to be and then back : (a,b,aTob,bToa) where aTob . bToa = id
18:45:32 <geekosaur> flebron: http://hackage.haskell.org/package/numbers-3000.2.0.0 but I odn't know if it supports logarithms for CReal
18:46:21 <roboguy_> lingxiao: for example, if we have a class like this: class SomeClass a b | a -> b, that means for each a there is exactly one instance giving a unique b
18:46:38 <lingxiao> ahh exaclty what I need
18:46:40 <roboguy_> so if we have instance SomeClass Int Char, we couldn't later add a instance SomeClass Int String
18:47:00 <roboguy_> because a uniquely determines b, according to the a -> b fun-dep
18:47:17 <roboguy_> I imagine you would want a -> b, b -> a
18:47:21 <roboguy_> maybe
18:48:11 <lingxiao> I do want that, in fact, thank you!
18:48:26 <lingxiao> https://gist.github.com/anonymous/9c5ee45e507c6b7466f5
18:48:41 <lingxiao> anyway i can encode (haha) "id = encode . decode" into the fundep?
18:48:45 <lingxiao> or using some other feature?
18:50:00 <roboguy_> lingxiao: no, fun-deps just help the type checker. if you have something like this "SomeClass Int a => a", the compiler wouldn't know how to resolve "a" unless you had a functional dependency like class SomeClass a b | a -> b
18:50:26 <roboguy_> lingxiao: it should be a encode and decode should form a valid Iso though if you're using lens
18:50:51 <roboguy_> uh, I mean "encode and decode should form a valid Iso though if you're using lens"
18:51:37 <roboguy_> wait, maybe not. when you convert from a DeBruijn index to a variable name it might not be the same variable name...
18:51:43 <lingxiao> um lens as in the lens library by kmett? I'm not actually ..
18:52:01 <lingxiao> implementation detail but in my case yes, since I'm storying the original name in the AST
18:52:06 <lingxiao> storing*
18:52:10 <roboguy_> that's something to look into sometime (probably not right now though). it's pretty awesome.
18:52:44 <roboguy_> anyway, I don't think there's a way to represent a law like "id = encode . decode"
18:52:52 <lingxiao> yea I played it with a while back, decided to really appreciate its inner workings,I'd have to get much better at haskell
18:53:00 <lingxiao> ahh ok, that's ok. I was just curious
18:53:21 <lingxiao> I guess even with things like monoids, there's no way to enforce mempty <> a = a
19:07:11 <roboguy_> lingxiao: yeah, I think it's impossible to enforce laws like that in general because of the halting problem
19:07:45 <roboguy_> at least, in a non-total language like haskell
19:10:58 * hackagebot ghc-mod 3.1.5 - Happy Haskell Programming  http://hackage.haskell.org/package/ghc-mod-3.1.5 (KazuYamamoto)
19:13:22 <TallerGhostWalt> I think.. I might have just found the tunnel out of cabal hell
19:13:26 <TallerGhostWalt> for the moment
19:13:52 <TallerGhostWalt> I wish that we could find a way to turn cabal library grinding into bitcoins
19:14:19 <mindleyhilner> in-place quicksort in haskell?
19:14:38 <mindleyhilner> would it involve strefs?
19:15:06 <roboguy_> mindleyhilner: "in-place" usually implies mutation, so probably
19:15:49 <Axman6> well, it'd at least need some form of mutable strings
19:16:13 <dcoutts_> mindleyhilner: STArray
19:16:24 <Axman6> or STUArray
19:16:29 <lingxiao> roboguy_: going off now, thanks for the help!
19:26:00 * hackagebot hopenpgp-tools 0.2 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.2 (ClintAdams)
19:26:19 <Twey> TallerGhostWalt: I wish we could find a way to turn Bitcoins into Cabal library grinding.  Or maybe protein-folding or something.
19:27:11 <Twey> mindleyhilner: Arguably an Array could provide that, depending on how smart the implementation is
19:27:23 <Twey> IArray, that is
19:27:27 <jle`> mm_freak_ / people who know netwire: can anyone help me get this simple wire stepper working? http://lpaste.net/98463
19:27:47 <jle`> basically it just takes a wire and logs the result of stepping it using a Writer monad
19:27:54 <jle`> the error is kinda weird though
19:28:12 <jle`> esp the Expected Type vs Actual Type
19:28:32 <mindleyhilner> Twey: iarray is immutable, right? doesn't that negate the possibility of in-place?
19:28:57 <jle`> mindleyhilner: he is probably talking about fusion
19:28:59 <jle`> or
19:29:05 <jle`> an Array that can log operations
19:29:09 <Twey> mindleyhilner: It's only immutable as far as the code can see — a smart enough compiler could implement it as a mutable array, if you're careful to write code that wouldn't break under that interpretation
19:29:42 <TallerGhostWalt> Twey: I like protein folding
19:29:44 <Twey> (I don't think GHC will do this, though)
19:29:50 <jle`> anyways afaik the first parameter for wire isn't a function (or supposed to be)...so why does it want one ><
19:30:08 <mindleyhilner> Twey: do you knwo of any compiler that does?
19:30:09 <TallerGhostWalt> What on earth is the syntax for using a full pacakge description for a function
19:30:20 <mindleyhilner> Twey: haskell or otherwise
19:31:09 <Axman6> TallerGhostWalt: what do you mean by "full pacakge description for a function"?
19:31:40 <Twey> jle`: You're not using ScopedTypeVariables, so your two ‘s’ variables are not the same
19:31:56 <Twey> (don't know Wire enough to tell whether that's what it wants, but seems like a likely candidate)
19:32:11 <TallerGhostWalt> i thought it was something like binary-0.7.0.1.Data.Binary
19:32:21 <geekosaur> oh, PackageImports?
19:32:41 <geekosaur> import "binary-0.7.0.1" Data.Binary
19:32:46 <TallerGhostWalt> I have two versions of Binary installed when I do a cabal info
19:32:49 <jle`> Twey: hm i'll investigate that. adding in the extension doesn't seem to help much right away
19:32:52 <geekosaur> with {-# LANGUAGE PackageImports #-} at the top
19:32:53 <Twey> mindleyhilner: Sounds like something Clean might do, but I don't know for sure
19:33:00 <TallerGhostWalt> sweet
19:33:00 <TallerGhostWalt> thx
19:33:10 <geekosaur> that said, you should probably fix things so you have only one version
19:33:14 <Twey> jle`: You also need to add a ‘forall’ on the outer declaration
19:33:30 <TallerGhostWalt> well I am on day 2 of library circus
19:33:50 <TallerGhostWalt> I am very tired of it
19:33:54 <TallerGhostWalt> thought I was out but noooo
19:34:05 <jle`> Twey: thanks, i'll play around with that
19:34:27 <geekosaur> @where sicp
19:34:28 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
19:34:30 <geekosaur> last link
19:36:55 <johannesbodannes> I understand that String is significantly less memory-efficient than ByteString. If I was anticipating using acidstate to store a lot of data containing textual information, should I probably care about using ByteString instead if it'll make my code uglier? <_<
19:37:32 <Axman6> johannesbodannes: are you storing text or data? use Text for text, ByteString for data
19:38:10 <johannesbodannes> Oh, text principally I guess. So maybe I should just use Text.
19:38:44 <TallerGhostWalt> geekosaur: Thanks, I am looking now.  Easily the worse part about haskell is this stuff. I hope I get better at it so I can get back to you know haskell.
19:38:45 <geekosaur> ByteString is best for binary data or network octets. if it's going to be primarily text, Text is the better choice
19:39:09 <geekosaur> yeh. perhaps the worst part is Cabal os often blamed when it's actually don te best it can with some very unfortunate GHC behavior
19:39:15 <geekosaur> *doing the
19:39:58 <johannesbodannes> Still, all of the explicit conversions between functionally identical string types is super irritating, augh
19:40:20 <Axman6> why do you need conversions?
19:40:25 <joelteon> they're not even close to functionally identical
19:40:33 <Axman6> indeed
19:40:45 <johannesbodannes> because i'm interacting with a lot of functions that take Strings, functions that take Text, functions that take ByteString...
19:40:50 <joelteon> bytestring is a vector of Word8, Text is a vector of Char
19:40:54 <joelteon> there's a big difference between the two
19:42:25 <Axman6> johannesbodannes: what're you doing?
19:42:38 <TallerGhostWalt> geekosaur: yeah I never hear anything about ghc having the flaw... I know something does!
19:42:43 <johannesbodannes> like, OK. for context suppose i want to hash someone's password, i'll receive it as Text. i'll have to convert it to ByteString to encrypt it first.
19:42:51 <Twey> johannesbodannes: Use OverloadedStrings
19:42:55 <joelteon> yeah, there's a reason for that
19:43:05 <pingu> Twey: that will only help for literals?
19:43:16 <joelteon> it's because the password is text, and the hash is data.
19:43:27 <Twey> Yes, but if you're converting between string types so much that this is an issue, you have bigger problems than a cluttered program :þ
19:43:37 <geekosaur> you will hear it occasionally but it is somewhat complex, relating to some things ghc does for performance reasons. meanwhile most people run into it via cabal because cabal is how they install things...
19:43:59 <geekosaur> shooting the messenger is sadly common
19:44:08 <Axman6> johannesbodannes: the conversion between Text and ByteString should be almost without cost
19:47:27 <TallerGhostWalt> geekosaur: yeah plus, I really like ghc and anthropomorphize it as my compiler buddy in a war against bugs.  Hard to have bad feelings for it.
19:47:38 <TallerGhostWalt> cabal meanwhile! Nothing but headaches
19:47:46 <TallerGhostWalt> I will know better now.
19:47:55 <geekosaur> I like ghc a lot and I understand why it does what it does, but oh the headaches.
19:48:12 <Twey> Why does it do what it does?
19:48:33 <geekosaur> cabal nor any other tool can really help, except by combinatorial explosion (compiling every possible combination of all libraries so that any possible combination will work)
19:48:54 <frege> I see that recursion is being used in haskell way more than imperative languages
19:48:55 <geekosaur> cross-module inlining has an incredibly high cost for the programmer :/
19:49:09 <frege> I barely use recursion in python
19:49:25 <Twey> Ah, that's what it is
19:49:33 <Axman6> frege: of course
19:49:38 <frege> Axman6: why?
19:49:46 <Twey> frege: That's because Python doesn't support it properly and will overflow if you use too much recursion.
19:49:51 <roboguy_> frege: recursion is the most basic looping primitive in Haskell
19:49:52 <Twey> >.>
19:49:57 <Axman6> because it's incredibly powerful
19:49:58 <geekosaur> frege: laziness means recursion behaves a lot differently. it's a mode of expression, but without the costs that it usually has in stack-frame languages
19:50:01 <frege> yeah I have seen the error in python
19:50:09 <roboguy_> frege: also, yeah, python doesn't have tail call optimization
19:50:28 <frege> geekosaur: oh I see
19:50:33 <geekosaur> tail call optimization helps in those languages, but laziness gives us something better essentially for free
19:51:01 <frege> so that means the recursion loop will not be evaluated first in haskell right?
19:51:17 <Twey> Recursion is a natural way to express many kinds of algorithms, but as you get more used to Haskell you'll mostly only use recursion to implement higher-order functions that capture your intent more granularly.
19:51:25 <geekosaur> because of the way haskell evaluates, apparent recursion actually behaves like looping
19:51:56 <frege> Twey: when you say higher-order functions what do you exactly mean?
19:51:58 <geekosaur> in fact, the most basic recursive structure, the simple linked list, is exactly how we do basic loops
19:52:06 <frege> aren't all functions the same in haskell?
19:52:26 <geekosaur> higher order functions are functions that take functions as parameters
19:52:29 <geekosaur> :t map
19:52:30 <lambdabot> (a -> b) -> [a] -> [b]
19:52:41 <frege> ah right
19:52:59 <frege> what's the name of functions that take normal types as arguments?
19:53:09 <geekosaur> they are "higher order" because they let you "transform" functions; map takes a simple function and turns it into something that operates on a list
19:53:09 <joelteon> [a] represents nondeterministic computations, right?
19:53:11 <Twey> frege: It's better style to use (say) map to loop over your data structure, rather than explicit recursion.  The higher-order function makes your intent clearer, and is usually shorter.
19:53:12 <frege> and what's the point of separating them?
19:53:22 <jle`> joelteon: [a] represents whatever you want it to represent :P
19:53:27 <geekosaur> think of the signature as: (a -> b) -> ([a] -> [b])
19:53:34 <nuttycom> In other words, a function that's not constrained by the arbitrary restriction that functions aren't values in some languages?
19:53:36 <joelteon> ok
19:53:40 <joelteon> regarding the list monad
19:53:42 <geekosaur> takes a function on items and produces a function on lists of items
19:53:44 <Twey> joelteon: [a] represents a list of values.  That can certainly be used to represent results of a non-deterministic computation.
19:53:53 <joelteon> ok
19:53:53 <roboguy_> frege: "higher-order" just emphasizes the fact that a function takes another function as it's argument
19:53:59 <Twey> joelteon: That's one interpretation.
19:54:00 <Axman6> frege: they're not separated, the "others" are just called functions. many languages do not support higher order functions
19:54:19 <Twey> (a pretty useful one, to be sure)
19:55:04 <nuttycom> Axman6: most popular languages support HOFs. They just call function values "objects"
19:55:12 <frege> and are all higher order functions in haskell partial?
19:55:19 <geekosaur> map isn't partial
19:55:25 <roboguy_> frege: why would they all be partial?
19:55:27 <frege> because I read that haskell functions have only one argument
19:55:31 <Axman6> frege: why would they be/
19:55:34 <geekosaur> that's a different thing
19:55:35 <Axman6> ?*
19:55:35 <lambdabot> Maybe you meant: v @ ? .
19:55:48 <geekosaur> oh, partial application, not the same thing as we usually mean by partial functions
19:55:58 <joelteon> ??
19:56:04 <geekosaur> partial application just means you can give one parameter and leave the others for later
19:56:09 <roboguy_> frege: technically that's true, but you can often effectively think of certain functions as taking multiple arguments
19:56:15 <joelteon> partial functions aren't defined for every input
19:56:16 <geekosaur> partial *functions* are functionswhich are not defined for some inputs
19:56:25 <Twey> > head []
19:56:26 <lambdabot>  *Exception: Prelude.head: empty list
19:56:35 <frege> ahh that's a different definition
19:56:35 <roboguy_> ahh, yeah partial application and partial functions are two different concepts
19:56:42 <Clint> where'd hdiff go
19:56:56 <Twey> luite broked it
19:56:57 <frege> have you guys worked with partials in python?
19:57:05 <jle`> mm_freak_: okay i think i figured it out :)
19:57:12 <frege> is that partial function ir partial application?
19:57:24 <Twey> frege: That's partial application
19:57:30 <Twey> (… kind of)
19:57:32 <roboguy_> frege: that refers to partial application not partial functions
19:57:44 <frege> so now what's partial function
19:57:59 <roboguy_> the term "partial function" comes from the math. it is a function that is not defined on some parts of it's domain
19:57:59 <tabemann> a partial function is a function that is not defined for all inputs
19:58:06 <Twey> frege: A partial function is a function that is undefined for some inputs, like ‘head’ (which will error out on an empty list).
19:58:08 <frege> so cury functions == partial application?
19:58:31 <Twey> Partial application is fun and wholesome.  Partial functions are of the devil.  ;)
19:58:31 <Axman6> curried*
19:58:42 <tabemann> partial application is when you don't provide all the inputs to a curried function
19:58:45 <Twey> frege: Partial application is a thing you can do with curried functions.
19:58:50 <frege> curried right
19:59:01 <roboguy_> frege: not exactly. currying is a way to have a function effectively take multiple arguments through functions that take one argument
19:59:03 <frege> right gotcha
19:59:18 <Twey> Curried happens to be the default representation for Haskell functions, by convention.
19:59:35 <frege> and for partial functions like head, you handle the problem with pattern matching?
19:59:43 <Twey> (but you can also define functions that take a tuple of arguments, if you prefer, which is basically what other languages do)
19:59:54 <Twey> frege: You handle the problem by not using head.  ;)
19:59:55 <roboguy_> frege: it depends on what you mean by "handle the problem". some functions must be partial, like head
20:00:14 <tabemann> but typically we like to avoid partial functions if we can
20:00:29 <tabemann> in the case of head, pattern matching is one way of avoiding the use of it
20:00:33 <frege> so what do you do? write a more general function?
20:00:50 <Twey> frege: You can just pattern-match the list into a head and a tail, making sure to handle the [] case
20:00:58 <geekosaur> frege, example of partial application: (+) takes two parameters. which can be seen as: takes one parameter, and returns a function which takes a second parameter. that second function produces a value.
20:01:04 <Twey> Or fold it, or map over it, or whatever, depending on what you want to do
20:01:05 <frege> right that's what I meant by handling the problem Twey
20:01:11 <geekosaur> :t (+) 5
20:01:12 <lambdabot> Num a => a -> a
20:02:18 <frege> geekosaur: so is that a tree structure that compiler tries to traverse?
20:02:32 <Twey> Sometimes I find it handy to define a function list ∷ (a → [a] → b) → b → [a] → b; list f _ (x : xs) = f x xs; list _ d [] = d
20:02:45 <gnuvince> I'm trying to convert this (imperative) OCaml code to perform a DFS of a graph in Haskell, and I just can't do it.  Can anyone help? http://lpaste.net/98466
20:02:45 <Twey> But usually it's easier to just match
20:02:54 <geekosaur> you could think of it that way
20:03:17 <frege> very interesting
20:03:57 <geekosaur> f a b = a + b      is the same as    f = (\a -> (\b -> a + b))   where each parenthesized thing is an anonymous function taking a single parameter
20:04:20 <frege> right right
20:04:30 <geekosaur> so any multiple parameter function can be broken down into single parameter funtions that return new functions
20:04:32 <roboguy_> frege: internally the code gets represented as a graph actually and evaluation is done through something called graph reduction
20:04:42 <jle`> oh i stumbled on a neat currying example the other day.
20:05:01 <jle`> or partial application
20:05:06 <geekosaur> which means function application can be broken down into steps and we can use individual steps or the whole thing, according to our needs
20:05:15 <maxiepoo> is there a semigroup version of Alternative?
20:05:41 <jle`> let's say your language does not provide you with a default log base 10 function.  Only logBase b n, which takes the log base b or n.
20:05:52 <frege> geekosaur: interesting, in a function like this "isPal (x:xs) = (x == (last xs)) && isPal (init xs)" the left side of = is the input right? why is it (x:xs)
20:05:58 <frege> it's confusing me
20:06:08 <geekosaur> thatis a smngle parameter which is a pattern match
20:06:08 <jle`> if you wanted to make your own log base 10 function, you would have to do logBase10 n = logBase 10 n
20:06:17 <jle`> but with currying/partial app you can just do logBase10 = logBase 10
20:06:17 <geekosaur> *single
20:06:27 <roboguy_> frege: that is a pattern match. it matches a list with at least one element and puts the head into x and the tail into xs
20:06:28 <pingu> frege: search for pattern matching
20:06:44 <geekosaur> so internally, a list [1,2,3] is represented as (1 : (2 : (3 : [])))
20:06:51 <frege> right
20:07:11 <mindleyhilner> 22:43:44 < geekosaur> frege: laziness means recursion behaves a lot differently. it's a mode of expression, but without the costs that it usually has in stack-frame languages
20:07:18 <geekosaur> you are symbolically taking that list apart with the pattern: x becomes 1 and xs becomes (2 : (3 : []))
20:07:21 <mindleyhilner> it does keep a stack of thunks
20:07:23 <frege> so when you say (x:xs) it will match any list that has at least one element
20:07:38 <geekosaur> it's more of a pattern matching stack, not a call stack in the imperative sense
20:07:44 <mindleyhilner> rather a list of thunks to call
20:07:45 <maxiepoo> I was just thinking about why `Gen` from quickCheck doesn't have an implementation but there isn't an identity
20:07:47 <mindleyhilner> that can overflow
20:07:52 <mindleyhilner> looping can never 'overflow'
20:08:08 <roboguy_> mindleyhilner: it keeps a sort of stack of pattern matches, as I understand it
20:08:19 <geekosaur> frege: yes, that pattern matches a non-empty list, puts its head in x and its tail in xs
20:08:49 <geekosaur> ("puts in" is very loose; it actually binds to those, they are not variables but essentially read-only pointers into the guts of the list)
20:08:55 <Axman6> frege: similarly, (x:y:xs) will match at least two elements etc
20:08:55 <frege> geekosaur: so I'm splitting the list right in the input?
20:09:04 <geekosaur> right
20:09:08 <frege> oh shit
20:09:15 <frege> that's not possible in python or other languagese
20:09:20 <jle`> well
20:09:25 <jle`> lots of languages have it
20:09:27 <jle`> :)
20:09:38 <roboguy_> actually you can do certain kinds of pattern matching in python
20:09:41 <pingu> frege: I think it is actually
20:09:45 <roboguy_> not to the extent that you can in haskell, though
20:09:47 <pingu> (a,b) = (1,2)
20:09:47 <jle`> Mathematica has it
20:09:48 <pingu> works in ruby at least
20:09:58 <frege> so I'm passing one list ---> func f that receives one list and it turns it into two lists before processing it inside the function
20:10:01 <pingu> and it works in python too
20:10:13 <Axman6> frege: two lists?
20:10:41 <frege> "isPal (x:xs) = (x == (last xs)) && isPal (init xs)"
20:10:45 <frege> x and xs
20:10:51 <jle`> x isn't a list
20:10:51 <frege> aren't they two lists?
20:10:54 <jle`> or well
20:10:59 <jle`> it's the element of the list
20:11:04 <jle`> remember that [1,2,3] is 1:2:3:[]
20:11:24 <frege> okay so we are separating one element of the list in the input?
20:11:26 <roboguy_> yeah, here we go, you can do a haskell like list pattern match in python: head, *tail = [...]
20:11:34 <frege> pingu: would you please write the python equivalent of this function?
20:12:04 <roboguy_> frege: x is the first element of the list
20:12:09 <roboguy_> xs is the rest of the elements
20:12:23 <maxiepoo> roboguy_, what happens if the list is nonempty?
20:12:28 <maxiepoo> I mean empty
20:12:41 <roboguy_> maxiepoo: the pattern match fails and it looks to see if it can find another pattern that does match
20:12:46 <frege> I don't get it, how do you call isPal here?
20:12:47 <Axman6> then the pattern match fails and the next pattern is tried
20:12:48 <roboguy_> in this case, a march on []
20:12:50 <roboguy_> *match
20:13:03 <maxiepoo> roboguy_, in python?
20:13:05 <roboguy_> frege: isPal [1,2,3,4]
20:13:06 <Axman6> and the only other pattern that could match is []
20:13:07 <jle`> frege: isPal [1,2,3,4]
20:13:12 <jle`> heh.
20:13:16 <frege> right
20:13:17 <roboguy_> maxiepoo: oh, it gives an error
20:13:39 <maxiepoo> yeah so it's a pretty limited form of pattern matching
20:13:46 <frege> and in order to match (x:xs) this list must have at least one element?
20:13:49 <roboguy_> if you have a call "isPal [1,2,3,4]", in the initial call, it puts 1 into x and [2,3,4] into xs
20:14:17 <roboguy_> frege: yeah, otherwise it can't put anything into xs
20:14:26 <roboguy_> or x I mean
20:14:40 <Axman6> > case [1,2,3] of (x:xs) -> (x,xs)
20:14:41 <lambdabot>  (1,[2,3])
20:15:22 <frege> when you say it puts; do you mean it becomes like this?  "isPal (1:[2,3,4]) = (1 == (last 4)) && isPal (init 2)"
20:15:36 <Twey> Can I have a GADT parameterized by itself?
20:16:09 <frege> when you say it puts; do you mean it becomes like this?  "isPal (1:[2,3,4]) = (1 == 4) && isPal 2"
20:16:20 <roboguy_> frege: well, "put" isn't really a good word for it. "bind" would be better. isPal [1,2,3,4] (which is the same as isPal (1:[2,3,4])) results in x being bound to 1 and xs being bound to [2,3,4]
20:16:22 <Axman6> it assigns the values names of x and xs
20:16:39 <maxiepoo> > init [1,2,3,4]
20:16:40 <lambdabot>  [1,2,3]
20:16:47 <Twey> I guess not =(
20:16:52 <frege> oh gotcha
20:17:02 <frege> roboguy_: thatnks a lot for rewording it, it makes sense now
20:17:05 <Axman6> so isPal [1,2,3,4] = x == (last [2,3,4]) && isPal (init [2,3,4])
20:17:16 <Axman6> uh, x should be 1 there
20:17:27 <frege> yup
20:17:48 <frege> isPal [1,2,3,4] = 1 == (last [2,3,4]) && isPal (init [2,3,4])
20:18:05 <maxiepoo> righ!
20:18:09 <maxiepoo> right*
20:18:15 <frege> oic
20:18:26 <frege> and recursion and life goes on
20:18:32 <frege> haha fascinating
20:18:40 <Axman6> which then calls sees that 1 /= 4 and returns False
20:18:46 <roboguy_> you can pattern match on many other things too, not just lists
20:19:18 <nuttycom1> hoogle is failing me... what is the name for (Eq b, Ord b) => (a -> b) -> [a] -> Map b [a]
20:19:20 <frege> do we have custom types in haskell?
20:19:23 <frege> like classes?
20:19:34 <Axman6> types yes, classes not as you know it
20:19:46 <nuttycom1> frege: see the 'data' keyword to start
20:19:46 <Axman6> this isn't OOP
20:19:53 <frege> can I make types that inherit?
20:20:00 <Axman6> data Maybe a = Nothing | Just a
20:20:03 <Axman6> no
20:20:09 <nuttycom1> frege: well, sort of
20:20:28 <Axman6> frege: what would they inherit?
20:20:36 <copumpkin> nuttycom1: I'd call it classify, but there isn't a single function for it that I know of
20:20:47 <pingu> nuttycom1: sounds like some kind of a groupWIth for maps?
20:20:54 <nuttycom1> pingu: yep
20:20:59 <frege> Axman6: like, I wanna have parent Ball, a child Red Ball and another Blue Ball, and I wanna match all Balls
20:21:02 <roboguy_> frege: classes don't work like python or any OO language
20:21:13 <pingu> nuttycom1: Never heard of it, are you hoping for it to exist?
20:21:17 <roboguy_> frege: it's actually a lot different. it's unfortunate that they have the same name
20:21:27 <frege> roboguy_: oic
20:21:32 <nuttycom1> pingu: Was hoping, yes. :)
20:21:38 <frege> so I should change my expectation
20:21:40 <copumpkin> :t \f -> M.fromListWith (++) . map (pure . f &&& id)
20:21:40 <Axman6> classes in haskell are somewhat like interfaces in Java
20:21:40 <nuttycom1> Scala calls it groupBy
20:21:41 <lambdabot> (Ord (f b), Applicative f) => ([a] -> b) -> [[a]] -> M.Map (f b) [a]
20:21:45 <copumpkin> hmm, whoops
20:21:48 <Axman6> very superficially though
20:22:17 <Axman6> frege: yes
20:22:23 <Axman6> @src Num
20:22:23 <lambdabot> class  (Eq a, Show a) => Num a  where
20:22:23 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:22:23 <lambdabot>     negate, abs, signum     :: a -> a
20:22:23 <lambdabot>     fromInteger             :: Integer -> a
20:22:50 <Twey> nuttycom1: We have groupBy but it produces a list (and doesn't store the result for each group ☹)
20:22:54 <maxiepoo> @src Eq
20:22:54 <lambdabot> class  Eq a  where
20:22:54 <lambdabot>     (==), (/=)   :: a -> a -> Bool
20:23:02 <copumpkin> whoops
20:23:04 <Axman6> frege: that's an example of the Num class, uses to allow different types to use (+), abs, signum etc
20:23:07 <copumpkin> @ty \f -> M.fromListWith (++) . map (f &&& pure)
20:23:08 <lambdabot> Ord c => (a -> c) -> [a] -> M.Map c [a]
20:23:11 <copumpkin> there we go
20:23:35 <maxiepoo> :t (&&&)
20:23:36 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
20:24:04 <frege> Axman6: so overloading will never happen externally?
20:24:23 <frege> it will be always defined in the same place that the class is?
20:24:27 <Axman6> classes are how we overload functions (sort of)
20:24:43 <roboguy_> frege: classes don't have definitions, they only have declarations. instances have definitions
20:24:49 <copumpkin> the *with variants of map functions are a huge miss in the scala std lib in my opinion
20:24:49 <nuttycom1> frege: You can kind of get objects with something like data Obj = forall a. (Eq a, Show a) => Obj a
20:24:53 <copumpkin> super duper useful
20:25:02 <nuttycom1> I think that's roughly the syntax.
20:25:09 <roboguy_> frege: so that stuff from lambdabot is the full code to those classes. they have instances that have definitions though
20:25:11 <frege> hmm
20:25:24 <nuttycom1> Basically, you capture a type in terms of its behaviors (hence the universal quantification over a)
20:25:31 <frege> @src head
20:25:31 <lambdabot> head (x:_) = x
20:25:32 <lambdabot> head []    = undefined
20:25:33 <roboguy_> nuttycom1: that's not generally a good idea
20:25:43 <frege> @src String
20:25:43 <maxiepoo> can you look up instance definitions with lambdabot?
20:25:43 <lambdabot> type String = [Char]
20:25:57 <roboguy_> @src Maybe (==)
20:25:57 <lambdabot> Source not found.
20:26:01 <nuttycom1> roboguy_: Oh, I know it's not very haskellish. But existential types are neat.
20:26:30 <maxiepoo> @instances Num
20:26:30 <lambdabot> Double, Float, Int, Integer
20:27:04 <roboguy_> nuttycom1: well, that's not really a good usage of existential types generally speaking. see this for example http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
20:27:36 <nuttycom1> copumpkin: excellent, I'll digest that, thanks!
20:27:59 <Axman6> frege: time to learn more?
20:28:03 <Axman6> @where lyah
20:28:03 <lambdabot> http://www.learnyouahaskell.com/
20:28:06 <copumpkin> nuttycom1: np :)
20:28:33 <nuttycom1> Figures luke would have written that what I thought was nifty is an antipattern. He's the person who first introduced me to Haskell.
20:28:38 <frege> Axman6: I'm reading haskell school of expression for music
20:28:51 <frege> Axman6: and these slides http://shuklan.com/haskell/
20:29:02 <frege> Axman6: I didn't find the style of lyah interesting
20:29:12 <copumpkin> nuttycom1: I think antipattern is a bit of a strong word
20:29:21 <copumpkin> pattern/antipattern are good thought-stoppers :P
20:29:52 <copumpkin> I still think emulating the OOishness with it adds unnecessary complexity to some code that could easily get away without it
20:30:02 <copumpkin> but there are cases in which it might be useful
20:31:29 <nuttycom1> roboguy_: reading that post, it looks to me like this is really only useful in libraries where the functions provided by multiple independent typeclasses need to interact
20:31:56 <nuttycom1> so the example of data AnyWidget = forall w. Widget w => AnyWidget w is a lousy use of the pattern because Widget is monolithic.
20:32:26 <roboguy_> nuttycom1: Widget probably should be a datatype and not a class
20:32:30 <nuttycom1> If Widget were broken down into independent typeclasses (which should be the case if there aren't laws which relate all its functions) then it might be necessary.
20:32:32 <nuttycom1> Right.
20:32:48 <nuttycom1> So, I call strawman. :)
20:34:35 <roboguy_> hah, maybe
20:39:58 <nuttycom1> copumpkin: style question, I noticed you used map there instead of fmap. Is there a reason to use the most-type-specific version of a function instead of the one provided by a typeclass instance?
20:40:44 <roboguy_> nuttycom1: it gives a nicer looking error message if the types are wrong
20:40:46 <copumpkin> nuttycom1: not really, it just seemed clearer to use the specific one, since I wasn't gaining any generality with the more general one
20:40:56 <roboguy_> and it also tells use that we are specifically using the [] functor
20:41:11 <roboguy_> *tells us
20:41:47 <copumpkin> well, that's also determined by fromListWith
20:43:50 <roboguy_> I know, but all we have to see is "map" to determine which Functor we're using. with fmap we have to look at the larger context
20:45:05 <nuttycom1> roboguy_: that's kind of what I was wondering about, since ordinarily you wouldn't want to add that restriction unless it was necessary, for example if fromListWith was just provided given a Foldable typeclass or some such.
20:45:35 <roboguy_> nuttycom1: true you want to be general when it possible, but there are some cases where it either isn't possible or wouldn't make sense to be general
20:45:42 <roboguy_> *when it is possible
20:46:41 <nuttycom1> coming from scalaz, I've had the "don't ask for types, ask for typeclasses" discipline hammered into me. :)
20:47:22 <roboguy_> well, in this case, fromListWith takes a list specifically (hence the name), so we must use a list regardless
20:48:15 <nuttycom1> roboguy_: that's purely historical though, right? my bet is it's implemented with a fold...
20:48:26 <nuttycom1> @src M.fromListWith
20:48:26 <lambdabot> Source not found. Whoa.
20:48:56 <int-e> @source Data.Map.fromListWith
20:48:56 <lambdabot> Unknown command, try @list
20:49:40 <nuttycom1> foldlStrict, yup
20:49:48 <int-e> @doc Data.Map.fromListWith
20:49:49 <lambdabot> Data.Map.fromListWith not available
20:51:01 <int-e> oh well. http://hackage.haskell.org/package/containers-0.5.3.1/docs/src/Data-Map-Base.html#fromListWith
20:52:53 <johannesbodannes> suppose i'm using acidstate, which stores a map of tens of thousands of entries. whenever i modify one of these entries i'm creating the entire map all over again, right? in anyone's experience isn't this prohibitively expensive?
20:53:37 <johannesbodannes> or am i exaggerating the effect?
20:53:40 <joelteon> yeah
20:53:58 <nuttycom1> johannesbodannes: you're not "creating the entire map again" - persistent data structures share all their state except what has changed.
20:54:11 <joelteon> I'm pretty sure the map structure is based on the key value, not the value-value
20:54:18 <joelteon> so the only thing that changes is the value associated with the key
20:54:26 <nuttycom1> so you'll probably be modifying a log(n) path from that particular key to the root.
20:54:46 <int-e> @doc Data.Map
20:54:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
20:54:51 <nuttycom1> where the log factor is the fanout of the tree
20:56:10 <nuttycom1> okay, binary... and modifying won't even cost you rebalancing
20:57:05 <johannesbodannes> ah here we go, it uses a tree structure. it's not so much rebalancing that i'm wondering about, more specifically the cost of recreating the antecessors of a node to preserve the guarantees of functional purity
20:58:12 <nuttycom1> johannesbodannes: so, that's roughly 17 values if you've got an 100k element map
20:58:31 <johannesbodannes> that isn't actually that many, in context : /
20:58:43 <johannesbodannes> alright that sounds extremely reasonable. thanks!
20:58:50 <joelteon> if you have a 100 million element list, it's like 25
20:59:21 <joneshf-laptop> umm, so whats up with this?
20:59:22 <joneshf-laptop> @pl eckses xs = [x | x <- xs]
20:59:23 <lambdabot> eckses = return . ((x | x) <-)
20:59:41 <int-e> hah.
20:59:48 <joelteon> lambdabot doesn't understand list comprehensions
21:00:05 <johnw> apparently neither does @pl :)
21:00:09 <int-e> | and <- make nice infix operators ... or so @pl thinks
21:00:52 <int-e> @. pl undo eckses xs = do x <- xs; return x
21:00:52 <lambdabot> (line 1, column 35):
21:00:52 <lambdabot> unexpected ';'
21:00:52 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
21:01:03 <int-e> aww.
21:01:12 <joelteon> @undo e xs = do x <- xs; return x
21:01:12 <lambdabot> e xs = xs >>= \ x -> return x;
21:01:20 <joelteon> @pl e xs = xs >>= \x -> return x
21:01:20 <lambdabot> e = id
21:01:25 <joelteon> @pl e xs = xs >>= \x -> return x;
21:01:25 <lambdabot> (line 1, column 29):
21:01:25 <lambdabot> unexpected ';'
21:01:25 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
21:01:30 <joelteon> oh
21:02:12 <roboguy_> @undo [x | x <- xs]
21:02:12 <lambdabot> concatMap (\ x -> [x]) xs
21:02:25 <joneshf-laptop> haha
21:02:44 <roboguy_> I feel like that could be optimized a little...
21:03:08 <int-e> @pl concatMap (\ x -> [x]) xs
21:03:08 <lambdabot> xs
21:03:27 <int-e> @. pl undo [x | x <- xs]
21:03:28 <lambdabot> xs
21:03:38 <int-e> @. pl excess xs = undo [x | x <- xs]
21:03:38 <lambdabot> Plugin `compose' failed with: Unknown command: "excess"
21:03:51 <int-e> @. pl undo excess xs = [x | x <- xs]
21:03:51 <lambdabot> (line 1, column 38):
21:03:51 <lambdabot> unexpected ';'
21:03:51 <lambdabot> expecting variable, "(", operator or end of input
21:04:00 <nuttycom1> So, haskell-noob breakthrough: I know I've looked at the type of (&&&) in previous years and never grokked it. Finally had the 'oh duh' moment of how to read the 'undeclared' type variables. :P
21:04:06 <int-e> (I don't know why @undo adds a semicolon there)
21:04:57 <adelbertc> nuttycom1 - how's haskelling going at your new gig? (assuming this is the same nuttycom from #scalaz)
21:05:40 <nuttycom1> adelbertc: well... I'm still trying to get good enough with haskell to be able to reasonably justify using it in production.
21:05:52 <joelteon> @undo excess xs = [x | x <- xs]
21:05:52 <lambdabot> excess xs = concatMap (\ x -> [x]) xs;
21:05:54 <nuttycom1> Right now, I'm not really there yet
21:06:01 <adelbertc> ah
21:06:06 <adelbertc> yeah i
21:06:17 <adelbertc> i've been brushing up on my haskell as well, never really got into it until recently
21:07:02 <nuttycom1> puffnfresh does, of course... but I don't want him to have to suddenly carry the weight of the world
21:08:01 <nuttycom1> so for the near term I'm hoping to just start introducing it for little bits we can carve out that make sense being independent
21:09:18 <mindleyhilner> how does "Num (IO b) => IO b" make sense?
21:10:38 <roboguy_> mindleyhilner: it doesn't
21:10:54 <roboguy_> what are you trying to do?
21:11:52 <mindleyhilner> :t getContents >>= const 3
21:11:53 <lambdabot> Num (IO b) => IO b
21:12:06 <mindleyhilner> trying to make sense of what that means
21:12:28 <joneshf-laptop> nuttycom1, what do you do?
21:12:29 <roboguy_> mindleyhilner: ghc doesn't know that IO b can't be an instance of Num
21:12:51 <roboguy_> :t getContents >>= const . return 3
21:12:52 <lambdabot>     Couldn't match type `b1 -> a0' with `IO b0'
21:12:52 <lambdabot>     Expected type: a0 -> IO b0
21:12:52 <lambdabot>       Actual type: a0 -> b1 -> a0
21:12:59 <shachaf> In particular, IO b *can* be an instance of Num.
21:13:00 <roboguy_> :t getContents >>= const (return 3)
21:13:01 <lambdabot> Num b => IO b
21:13:13 <roboguy_> shachaf: doesn't it have to be Num b => IO b?
21:13:37 <shachaf> It can be anything. But many things are not good ideas.
21:14:03 <roboguy_> well, I mean it can't be a sane instance of Num
21:14:44 <roboguy_> mindleyhilner: you probably want "getContents >>= const (return 3)" which is the same as "getContents >> return 3"
21:14:48 <mindleyhilner> yeah i know
21:15:05 <mindleyhilner> i'm trying to understand why the type system permits this
21:15:12 <roboguy_> mindleyhilner: numeric literals like 3 have a polymorphic type
21:15:17 <roboguy_> :t 3
21:15:18 <lambdabot> Num a => a
21:15:56 <mindleyhilner> :t getContents >>= const "derp"
21:15:57 <shachaf> Look at the type of each thing, and then unify. With your nick one would expect you to know how that works.
21:15:57 <lambdabot>     Couldn't match expected type `IO b0' with actual type `[Char]'
21:15:57 <lambdabot>     In the first argument of `const', namely `"derp"'
21:15:57 <lambdabot>     In the second argument of `(>>=)', namely `const "derp"'
21:16:15 <roboguy_> Strings, on the other hand, don't have a polymorphic type
21:16:23 <mindleyhilner> yes, i was making sure
21:17:10 <mindleyhilner> shachaf: actually i have no idea how hm with typeclass constraints would work
21:17:33 <nuttycom1> joneshf-laptop: I lead a team and write Scala for http://simpleenergy.com
21:17:35 <mindleyhilner> but clearly the type checker skipped over the part where there is no instance Num (IO a)
21:17:38 <roboguy_> mindleyhilner: type classes work sort of like prolog predicates
21:18:32 <roboguy_> mindleyhilner: I don't think it checks for instances at that point
21:18:48 <roboguy_> since you could define an instance later, I suppose
21:19:13 <mindleyhilner> that's silly, instance has no place inside a do block
21:19:21 <roboguy_> outside the do block, of course
21:19:34 <roboguy_> later in the code though
21:19:35 <mindleyhilner> i could but i haven't
21:21:09 <joneshf-laptop> nuttycom1, cool
21:21:54 <roboguy_> mindleyhilner: I don't think :t checks to see if instances exist
21:22:10 <roboguy_> :t (return 'a') + 3
21:22:11 <lambdabot> (Monad m, Num (m Char)) => m Char
21:22:35 <roboguy_> :t (return 'a') <> 3
21:22:36 <lambdabot> (Monad m, Num (m Char), Monoid (m Char)) => m Char
21:22:37 <mindleyhilner> roboguy_: sounds plausible
21:22:44 <joelteon> you *can't* check at that point
21:22:51 <joneshf-laptop> wait what?
21:23:11 <joelteon> what if that function is defined in module A, and module B imports module A, and also defines that instance
21:23:22 <joelteon> then B would fail to compile because A would fail to compile
21:23:38 <joneshf-laptop> hmm
21:24:19 <joelteon> even though the program is sound
21:39:24 <danharaj> edwardk: I've been investigating higher order unification problems recently because of their applicability to inference of type level lambdas. Wouldn't it be kinda great if linear ho-unification turned out to be decidable (it's an open problem)? That covers a ton of type-level lambda use cases.
21:41:16 * hackagebot STL 0.1.0.0 - STL 3D geometry format parsing and pretty-printing  http://hackage.haskell.org/package/STL-0.1.0.0 (bergey)
22:16:46 <randomclown> how do you turn a ByteString to Text?
22:17:08 <randomclown> nvm
22:28:28 <randomclown> 5 <> 6
22:28:32 <randomclown> > 5 <> 6
22:28:33 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
22:28:33 <lambdabot>    arising from a use of `e_156'
22:28:33 <lambdabot>  The type variable `a0' is ambiguous
22:28:33 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
22:28:33 <lambdabot>  Note: there are several potential instances:
22:28:46 <Axman6> @hoogle ByteString -> Text
22:28:47 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
22:28:49 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
22:28:51 <lambdabot> Data.Text.Encoding decodeLatin1 :: ByteString -> Text
22:29:24 <zRecursive> e
22:31:25 * hackagebot wai-extra 2.0.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.0.2 (MichaelSnoyman)
22:31:27 * hackagebot warp 2.0.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-2.0.2 (MichaelSnoyman)
22:31:29 * hackagebot warp-tls 2.0.1 - HTTP over SSL/TLS support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-2.0.1 (MichaelSnoyman)
23:39:59 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
23:39:59 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
23:39:59 --- names: list (clog zcourts xjiujiu martinga_ ademidov1 ioanel shock_one carminemlt poglesbyg_ halvorgb Beetny Voidness juxovec maoe klaut tsurutom MercurialAlchemi effy xexonixxexillion fabe Swizec Guest13248 dmilith yogurt_truck dgpratt MrGwen csakatok_ Revenrof zipper ilmig kcj hamid rishabhjain mno2 talzeus psiska jumblerg Isp-sec Pupnik ThomasLocke grohne polsab fujimura path[l] RayNbow`TU alpounet petercommand pheaver isenmann Twisol goldkatze kerrick blaenk)
23:39:59 --- names: list (ArcTanSusan monochrom osa1_ divyansr Apocalisp sclv Dtgr jefimenko1 ccc funfunctor finchd zhulikas master_j Aetherspawn alanz tiffany agjacome jtcwang RichyB oleo edwardk MedDev zRecursive Shin-LaC David Jesin otto_s_ amosr drlemon preflex Guest63687 mauke defanor deech```` ddellacosta johnw gnuvince shanse dolio echo-area talzeus_ quup d__ johannesbodannes Targen Ralith cdidd Neqoxec insejn n0n0 dongchao pxqr xl1 apaku chatsiri_ chrisdotcode Igloo rik_)
23:39:59 --- names: list (Gx10 mekeor gehmehgeh ashnur someguy123420 estewei amathew juhp jedai42 alang Watabou zarul ts33kr WraithM yogert adnauseam JobV AleXoundOS_ sShintah centrinia dimday sinclair|work alinab predator217 m00nlight shergill ndrei eazar001 shesek kragniz endojelly Sgeo frxx ThatCantBe SoupE csed bytbox caligula__ tavelram Maxdamantus psychicist_ Betal spacebug brandonw peterbb brushbox subleq dgvncsz0f mescalinum Plasmastar occamshatchet noteventime jix nullcone)
23:39:59 --- names: list (bjorkintosh _d3f dleedev maksbotan joefiorini voxpopuli catsup plucas s2r2 xinming sellout- joaopizani nominolo vili sw1nn mada ellipsis_ kylcarte iFire liyang gpampara minsa aztek dogmaT_ schell triliyn nemesit|znc newsham mv-- cads AshleyWaffle arrdem alderz_ dredozubov Kruppe `^_^v Kaidelong peterhil sross07 DasIch drAgda foxnorth ValicekB jobstijl0 m1dnight whaletechno [[zz]] mgsloan thunderrd jorj mm_freak_ zett_zelett ormaaj kludge` Excureo Philonous)
23:39:59 --- names: list (NiKo` DT`` mceier AntiSpamMeta jbauman rien hackagebot descender Jonno_FTW Myk267 Soft ccs4ever zeroskillor bars albel727 gniourf zasimov scott_ Brando753 covi cjsarette iArthur guampa MitchW Cr8 brainproxy joeyh julian_ fijimunkii fmapE ofan shoky Janiczek TheFuzzball ivan` mlh Boney kazagistar uu1101 Blkt Mangellan2497 MetaCosm carter ernst vpm dodgems luzie eL_Bart0 fayden TK009 dan64 zoktar justinls_ Yaniel ehd DarkLinkXXXX_ cdk omefire maxiepoo)
23:39:59 --- names: list (andrewsw Maerten klarh fionnan q66 tristan__ Wardje saep M-ou-se cognominal ParahSailin hugod yusukesuzuki si14 no0y geoffh pfurla zeiris ant0wn1 lokydor f8l ahf aninhumer alexsdut1on dtkatch simon rs0 zso noplamodo drbean horlicks lulf Tehnix pdxleif int-e twn_ xplat d3lxa Whazor Annamaria A1kmm rmunroe mrshoe myme1 nohluhtC dilinger_ henk liori mrowe paz_ mshroyer Nik05 joshsz mindleyhilner Starfire_ leocassarani annulus IbnFirnas eyem Eridius wrunt)
23:39:59 --- names: list (absence Arnar xahry mietek MK_FG dabradley vmeson bd_ reizuki benedikt kakos shachaf BlastHardcheese flazz_gone aegray_ voyd apples marmaton zaphar_ps dsp_ bholst mr- so aford jlouis dawik munro_ b0c1 bartavelle bitraten1 mononofu FliPPeh osfameron asm89 jayne nurupo dmead Baughn saurik Jello_Raptor go|dfish mantovani jrmithdobbs peltchu_ salvatoz lightquake mrb_bk tomh- tautologico etrepum Sieben__ Draggor zachmassia def-lkb statusfailed bunzen franksh)
23:39:59 --- names: list (mrmonday nikola Deewiant rhodesd quicksilver mami boyscared earthy flori ft asQuirreL davidbe_ lieven_ betawaffle kipras`away ryanakca nkpart leifw kini xrl__ keelo mirsal zpconn ConstantineXVI c_wraith lahwran MarcWeber ``rawr conehead_ bgyss bobry AlainODea_ raphie deavid bens ccasin joelteon acfoltzer jroesch davean linduxed xintron petantik larsrh lamilami JPohlmann jrib floatingman klz geekosaur MrWoohoo blast_hardcheese gseitz stepcut amatsu)
23:39:59 --- names: list (koala_man jmct gridaphobe ivan\ ggherdov kcliu_ divyansr__ CADD lacrosse Raynos ehamberg PatrickRobotham puzza007_ stephe BlankVerse_ thomasschroeter bkolera sweeks Xorlev srid liesen__ bicgena idnar akraut yeshuah aloiscochard eribeiro reiddraper xkb_ wilfredh percival__ nuttycom1 stephenmac7 iron_houzi gienah tbelaire jml bambams visi0n joneshf-laptop wollw tomprince thetallguy Cale hpc dj3p katis jonke dv- bernalex stiell CaveJohnson MoALTz_ waterlaz)
23:39:59 --- names: list (shepheb wting WarzoneCommand \q augur_ Mortomes indigo crs__ obcode jcristov1o phienone s4msung upgrayeddd dziga ryanbooker shennyg docsis Sibi__ DarthArachides lopex tobyp joshbohde davorb jodaro_ jzelinskie donri squimmy xorox90__ adnap GGMethos bb010g frontendloader hongminhee nik_89 kennycason Tarential stevely Cerise kfish DarwinIsGod melter srcerer mercuryrising sam_d benj_ jack_rabbit dropdrive caleb_9 aristid martin alexdoom biscarch jizanthapus)
23:39:59 --- names: list (tinyghost spion mornfall sm byorgey srhb og01 McManiaC threestrikes phryk magicman Elision ChongLi AleXoundOS tarmil stelleg CosmicRay OrangeDuck Hafydd tummy dsantiago majoh gthorslund jfhall Psycho_pr copumpkin majackson pnielsen thirsteh egads sondove ocharles otterdam Iceland_jack vobi paulschellin ninegrid neptunepink adlan shapr pikhq emma tg jxport dcoutts NeatBasis_ mendez dottedmag lenstr xaimus cbw thoughtpolice nwf marienz solrize willb2)
23:39:59 --- names: list (tridactyla FireFly pqmodn vikraman kaw qwandor prinsen japesinator arthur_honeynet Maior prophile Taneb Spockz barrucadu fnordbert levi adelbertc acharles anders^^ chirpsalot dyreshark utkarsh cschneid gereedy Spaceghost aji msavoury verement zacts junsuijin niko tahu pp^ simpson The_third_man Nimatek pyykkis qpls_ mist11^off ibid ttuegel shiona numberten mandu chrisirc mmathis gbarboza Rylee sleepynate mixi rdevilla yam nitin2 _janne asjo peder Fubar^)
23:39:59 --- names: list (lafa copton ZsoL DigitalKiwi MasseR_ Razz_ javawizard mm_bureau stass quaestor1 japaric zerokarmaleft tomboy64 Internet13 Kobata_ rasmusto vital Squid_Tamer erider Nickeeh wagle TakSuyu cwvh kloeri mcglk hape01 thalassarche td123 kadoban Martingale killy9999 mee ByronJohnson neurocyte froztbyte wunki noddy2OOO mastensg tych0 cmr thebnq Hodapp Artpicre popx `0660 vendethiel BMeph bgresham verrens brisbin cjay sclv_ Guest82519 jayferd xymox passiveobserver)
23:39:59 --- names: list (sa1 PHO__ BrianHV Walther helgar Thulsadu1 bogner` lpaste sajith lpsmith mephx_ cross zorzar ion Kabaka Khisanth Excedrin Lindrian bsmt kshannon troydm JesuZ vsayer_ Nahra jibi hamishmack jamesjb jle` thorkilnaur notdan DustyDingo Raynes sgs Ptival mikeplus64 Cryovat Martty_ theorbtwo identity dumbhat xnyhps h_chiro__ joachifm kryft frege burp_ jmcarthur tomejaguar Sagi taruti tpsinnem Guest81224 Shou croys stvc lusory honkfestival dhrosa Heffalump exicer)
23:39:59 --- names: list (Twey Gunni bind1 Liskni_si __class__ kqr Ulrar jchee skypers DarkFox kxra Zariel bitemyapp arnsholt Laney gdsx gargawel_ TheBrayn_ kosmikus gemelen dmwit wormphlegm d-snp nicoo jang ziman leroux webframp vvv_ kaol anhall_ schlumpi_ mak` SHODAN profmakx marsam bbastian cow-orker epta drewr dustinswan djahandarie Will| boegel|work valdyn drbop banjiewen bergey wchun morolin Fuuzetsu natte cpa KitB eagleflo Natch ahihi felipe_ lambdabot tristero thetallguy1)
23:39:59 --- names: list (mikecaruso tril noidi sunfun capisce luigy SLi cryzed Nafai LordDeath adimit dsrx DonVitoC- brixen ArkB Kneiva adinapoli mgaare mviljamaa FUZxxl NickHu ciaranm tromp__ jrw bezik tdammers yano haasn randomclown pyrtsa Guest31920 fran heikkih pi8027 posco_ finnrobi iulian RevJohnnyHealey AshyIsMe theDon davorak dqd aoh Dodek jzl_ jb55 vhz michaelpj mau_ mokus b_jonas ginmaniac Gracenotes sordina1 helmut sdx23 ocfx marky benbangert sipa boothead harski)
23:39:59 --- names: list (demolith1 pjstadig sababa rieper eevar_ Derander_ evax Drezil [swift] c_14 vnz m0g bcoppens felixsch robbert mike2 pfoetchen relrod klugez apo gallais Ke jaimef jj2baile johntrom_ kenkku mjo juuhaa jlewis Chousuke MooGoo Valodim mortberg kmicu Urchin flux Tesseraction_r dixie Gorroth chipdude radioxid spaceships jrslepak edk smarter kittensoup Axman6 ibab Cradam fabjan ReinH confound_ necroyeti Yawgmoth benmachine mattp_ mimi_vx moop Labrit justinjaffray)
23:39:59 --- names: list (jlamothe scshunt deggisv2 mythmon CindyLinz Sornaensis jcurbo tov_ mangaba_leitosa saiam zenzike _1126 castor3 Enigmagic JulyO_o Sebastiaan tawm_ tessier topi` koninkje_away dreixel Tene fikusz SaBer `bps bstrie lzm shlevy ixian flebron ent eyck lispy GaveUp akiress_ ido sleuth ejls thorstadt kbotnen @ChanServ tomaw b2coutts simonnn aszlig bbee pierreghz sunnavy mmaruseacph2 Bwild_ stbuehler alios jedavis mena pietore knyppeldynan jackhill yeltzooo dju)
23:39:59 --- names: list (epsylon` macron seliopou hc mlen FreakyPe1guin Athas Kinnison farn amontez duairc machisuji cynick nbouscal Edoxile zebr mechairoi Boreeas peddie greymalkin hdevalence|away raid drmegahertz tero- drdo Adeon SegFaultAX alexsdutton companion_cube bxc_ ircbrowse Reiser binarystarz Jaxan averell bgamari Eagle_Erwin hattmammerly Ornedan geal orospakr necronian qrada akurilin ps-auxw zeroXten jamwt1 Vq jorendorff_away Clint inarru_ dflemstr Vorpal petanqk)
23:39:59 --- names: list (solarus fryguybob slobo lab-notes Bigcheese heath bearclaw_ pcapriotti hiredman helgikrs daoo Rembane Licenser krakrjak_ Lemmih_ edwtjo Javafant bergmark mikeI dario` inr opqdonut vvein Dashkal cods aseidl Phlogistique tpatja_ XMunkki_ Belgarion0 mlinksva a11235 hpd jcande uniquenick erikl_ raek dlundy Amadiro fall_ smileface lattenwald Polarina Svedrin k00mi hvr otulp knyon jonasw luite tamiko k4nar_ qz loans dp_wiz fergusnoble plhk edunham jaspervdj)
23:39:59 --- names: list (pranz zomg Saizan __mkrull jliikka mrd Guest54616 sohum KaneTW yac _flow_ ortmage_ shutdown_-h_now colah ninzine Jaak Hardolaf integral orzo _br_ supki pharaun Gothmog_ tippenein Eelis satshaba1 Adios chreekat cmsd2 mero)
23:45:56 <Saizan> @ask danharaj what's a linear unification problem that's not in the pattern fragment?
23:45:57 <lambdabot> Consider it noted.
23:49:22 <Saizan> uh, probably something like M (f x) = ...
23:59:24 <refcell> Is there any difference between Data.IntMap.toList and Data.IntMap.toAscList?
