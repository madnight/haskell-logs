00:00:00 <mindleyhilner> what.
00:00:16 <prooftechnique> @unpl ((.).(.).(.))
00:00:16 <lambdabot> (\ l b c f i -> l (b c f i))
00:00:52 <dhrosa> @pl stackPop state = (readDMem (getSP state), decSP state)
00:00:52 <lambdabot> stackPop = ap ((,) . readDMem . getSP) decSP
00:01:04 <dhrosa> no.
00:01:21 <mindleyhilner> what's with the love affair with pl?
00:01:29 <prooftechnique> Maybe I can write a @lens directive for lambdabot
00:01:33 <prooftechnique> That'd be cute
00:01:35 <startling> prooftechnique: haha
00:01:39 <Twey> @pl \b a -> f a b a
00:01:39 <lambdabot> join . flip f
00:01:43 <dhrosa> I was curious if pl would produce something cleaner than what I had
00:02:11 <Twey> stackPush = join . flip (incSP . writeDMem . getSP)
00:02:18 <edwardk> i sometimes use @pl to figure out if it'd be worth using, and modify the result accordingly
00:02:31 <startling> yeah, same here.
00:02:33 <dhrosa> @pl stackPop state = (readDMem (getSP state) state, decSP state)
00:02:33 <lambdabot> stackPop = liftM2 (,) (readDMem =<< getSP) decSP
00:02:35 <prooftechnique> startling: It'd be an excuse to learn a chunk of lens, and maybe be a useful tool. Then again, I'm not edwardk :D
00:02:50 <dhrosa> that's what I meant to do, this result is tempting
00:03:14 <prooftechnique> dhrosa: liftM2 is Pro Haskell™
00:03:15 <Twey>  @pl is nice for short things when you know @pl will produce something decent and have a vague idea of what it should look like but can't be bothered to do the algebra
00:03:53 <simpson> Or you want a confirmation that you did the algebra right.
00:04:28 <Twey> dhrosa: stackPop = readDMem . getSP &&& decSP
00:04:32 <prooftechnique> Isn't there something to arrow-ify stuff, too?
00:04:36 <Qett> what are these {-# style comments?
00:04:48 <dhrosa> Twey: oo I forgot about arrows
00:04:50 <Twey> Qett: They're pragmata for the compiler
00:05:06 <Qett> ah ok
00:05:19 <startling> {-# is just multiline comments.
00:05:22 <shachaf> Sometimes @pl outdoes my naïve hand @pling.
00:05:35 <startling> {-# LANGUAGE and {-# PRAGMA are pragmas
00:05:47 <dhrosa> Twey: would arrows help with my incSP function?
00:05:59 <Twey> startling: Also INLINE, SPECIALIZE, &c.
00:06:01 <dhrosa> incSP x= setSP ((getSP x) + 1) x
00:06:03 <startling> yeah.
00:06:03 <shachaf> For example for prooftechnique's thing I might get (flip (((.) . (.))) (.)) . (.)
00:06:12 <shachaf> such is the way of optimizing compilers
00:06:18 <startling> shachaf, I heard artisinal pl is better for the environment.
00:06:48 <Twey> dhrosa: join $ setSP ((+ 1) . getSP)
00:06:58 <Twey> dhrosa: join . setSP $ (+ 1) . getSP
00:07:06 <prooftechnique> startling: I thought the parser choked on {-# because it thinks it should be a pragma
00:07:30 <Twey> dhrosa: Using arrows for PL is a bit of a hack, since you usually just want to take advantage of the fact that the arrow functions use pairs
00:07:37 <prooftechnique> And I think there's an outstanding bug where it thinks {- # is an ancient haddock comment format that hasn't been in use forever
00:07:54 <prooftechnique> *in forever
00:08:06 <Twey> dhrosa: But that does mean there are some nice functions for pair manipulation.
00:08:17 <Twey> Specifically, introduction and bimap
00:08:45 <startling> I love abusing the (->) r Applicative instance for pair functions.
00:08:49 <Twey> It would be good to have those in another form *cough*edwardk*cough* ;)
00:08:52 <startling> > (,) <$> snd <*> fst
00:08:53 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
00:08:54 <lambdabot>    arising from a use of `M971631871104182855805.show_M971631871104182855805'
00:08:54 <lambdabot>  The type variable `b0' is ambiguous
00:08:54 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:08:54 <lambdabot>  Note: there are several potential instances:
00:08:58 <startling> :t (,) <$> snd <*> fst
00:08:59 <lambdabot> (a, b) -> (b, a)
00:09:11 <ion> :t swap
00:09:12 <lambdabot> (a, b) -> (b, a)
00:09:17 <shachaf> Twey: Well. (&&&) is pretty related to the idea of a product in a category in general.
00:09:18 <startling> :<
00:09:33 <Twey> shachaf: Right, I keep expecting it to be in Control.Category
00:09:55 <prooftechnique> > (,) <$> snd <*> fst $ (1, "hello")
00:09:56 <shachaf> (And (|||) to coproducts.)
00:09:56 <lambdabot>  ("hello",1)
00:10:26 <edwardk> > ("hello","world") & partsOf both %~ reverse
00:10:28 <lambdabot>  ("world","hello")
00:10:44 <edwardk> > ("hello","world","!!!") & partsOf each %~ reverse
00:10:46 <lambdabot>  ("!!!","world","hello")
00:10:52 <prooftechnique> :t partsOf
00:10:52 <lambdabot> Functor f => Traversing (->) f s t a a -> LensLike f s t [a] [a]
00:10:55 <edwardk> > ("hello","world","!!!") & partsOf (each.traverse) %~ reverse
00:10:57 <lambdabot>  ("!!!dl","rowol","leh")
00:11:25 <prooftechnique> :t partsOf each
00:11:26 <lambdabot> (Functor f, Each (Control.Lens.Internal.Bazaar.BazaarT (->) f b b) s t b b) => LensLike f s t [b] [b]
00:11:33 <prooftechnique> Oh, no, Bazaar~
00:12:13 <edwardk> each is the 'do what i mean' traversal for one level of whatever thing you point it at. partsOf turns a traversal into a lens that views the list of all of its targets
00:12:26 <dhrosa> Twey: you're arrow code doesn't work for me, because readDMem also needs to take the state as a param
00:12:29 <edwardk> it is a legal lens so long as you don't change the length of the list
00:12:29 <dhrosa> your
00:12:50 <prooftechnique> edwardk: What's the intuition with Bazaar again? I think it's related to Store
00:12:54 <shachaf> Is it an arrow law that (&&&) :: (arr a b, arr a c) -> arr a (b,c) is an isomorphism?
00:13:06 <shachaf> (With the other direction using arr fst/snd.)
00:13:18 <Twey> dhrosa: Hm?  It takes it
00:13:27 <edwardk> Bazaar a b t is isomorphic to (b^n -> t, a^n) for some n
00:13:36 <Twey> Oh
00:13:48 <prooftechnique> Hmm
00:14:00 <Twey> dhrosa: stackPop = join (readDMem . getSP) &&& decSP
00:14:00 <edwardk> it says if for every a you can give me a b, i'll give you a t
00:14:17 <prooftechnique> Ah, okay. I need to read some more of your fpcomplete stuff.
00:14:32 <shachaf> Well, in particular you can look at all the 'a's before you decide on any of the 'b's.
00:15:20 <augur_> is anyone really familiar with Programming in MLTT?
00:15:25 <edwardk> it is a bit more complicated in that in the way we had to encode it to handle the infinite case gracefully
00:15:56 <shachaf> Should've asked roconnor whether the infinite case exists.
00:16:00 <shachaf> Would've made it easier.
00:18:31 <shachaf> prooftechnique: You might look at the alternative representation of it: data Bizarre a b t = Nil t | Cons a (Bizarre a b (b -> t))
00:18:43 <shachaf> But it might take a bit of looking before it makes sense.
00:19:07 <prooftechnique> Actually, I think that makes a little more immediate sense
00:19:28 <edwardk> the issue with that representation is you can't get answers out if you need to work with an infinite traversal
00:19:41 <edwardk> > [1..] & traverse +~ 1
00:19:42 <shachaf> Yep.
00:19:43 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
00:19:50 <edwardk> that wouldn't work off that rep
00:19:50 <shachaf> And also the other one is more obvious when you're using lens anyway.
00:20:14 <edwardk> the lens form of Bazaar is easy to spot given the definition of a traversal
00:20:27 <edwardk> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
00:20:32 <edwardk> flip it
00:20:42 <edwardk> type Traversal s t a b = s -> forall f. Applicative f => (a -> f b) -> f t
00:20:49 <edwardk> wrap that second half up in a newtype wrapper
00:20:58 <edwardk> and you have s -> Bazaar a b t
00:21:13 <prooftechnique> Oh, okay. That's way clearer
00:21:57 <edwardk> similarly if you do the same with Lens you get Pretext, and it makes it obvious how that relates to the store-comonad-coalgebra rep of lenses
00:22:00 <shachaf> Oh, you're NihilistDandy.
00:22:08 <prooftechnique> shachaf: Yes
00:22:53 <shachaf> Bazaar was worth making sense of.
00:23:04 <shachaf> You can tell I didn't understand it the first time because I alpha-renamed it to "Bazaar a b s".
00:23:08 <prooftechnique> edwardk: I have to admit that none of that store-comonad-coalgebra stuff really started clicking until the HaskellCast you were on
00:23:15 <prooftechnique> Hand motions make all the difference :D
00:23:28 <edwardk> heh
00:23:53 <edwardk> funny thing is when i was making them i didn't think they were going to make the video available ;)
00:24:00 <edwardk> so they were entirely subconscious
00:24:20 <edwardk> they liked them enough they made sure to release the uncut video for that and the later episodes
00:24:43 <edwardk> and i just realized we have a user on here named they
00:24:57 <prooftechnique> I still need to watch the one with byorgey.
00:25:05 <edwardk> that one was good
00:25:29 <prooftechnique> I have to imagine they has shut off highlights for their own sanity
00:35:04 <zett_zelett> Is yi still developed?
00:36:04 <prooftechnique> zett_zelett: Yup
00:36:16 <prooftechnique> Last commit was 8 hours ago
00:36:43 <prooftechnique> Last Hackage release was in October
00:39:20 <zett_zelett> Great, I wonder how this turns out.
00:40:11 <prooftechnique> It's kinda neat, but I never got deeply invested in it, especially now that structured-haskell-mode is a thing :D
00:41:42 <mjrosenb> I forget, if I have Instance Num a => Num (Foo a) where...
00:42:07 <mjrosenb> can I explicitly say something has type a inside of the declaration, or is this not allowed?
00:42:28 <shachaf> You can with ScopedTypeVariables.
00:42:44 <shachaf> Or, hmm, maybe I'm not understanding what you mean.
00:42:56 <shachaf> This is one of the few cases where ScopedTypeVariables can break backwards compatibility, though.
00:43:06 <mjrosenb> shachaf: ok, I don't actually need it
00:43:20 <mjrosenb> I was just trying to add it to get rid of something that was wrong
00:43:26 <mjrosenb> and it made the problem worse.
00:46:26 <mjrosenb> gr.  ghc's error messages were being unhelpful.
00:54:45 <carlo_au> what is "!.", e.g. https://github.com/kazu-yamamoto/ghc-mod/blob/master/src/GHCMod.hs#L95-L99
00:54:53 <carlo_au> cmdArg1 = cmdArg !. 1
00:54:56 <carlo_au> cmdArg is a list
00:55:06 <carlo_au> I would have used cmdArg !! 1
00:58:57 <carlo_au> oh right, it's defined later in the where clause, nevermind
01:00:26 <fragamus> hey can you guys help me restructure this
01:00:27 <fragamus> http://lpaste.net/99105
01:01:40 <fragamus> the use of maybe seems forced
01:01:58 <fragamus> case seems clunky
01:02:19 <Wizek> Good morning
01:03:46 <Wizek> What does this error mean? https://gist.github.com/Wizek/7f34c08f0e9a02448a70
01:04:15 <Wizek> As far as I can tell those two types are supposed to be identical
01:04:35 <Axman6> Wizek: you've got the wrong type of bytestring somewhere. is S Data.ByteString?
01:04:56 <Wizek> import qualified Data.ByteString as S
01:04:57 <Wizek> yes
01:05:01 <Axman6> hmm, odd
01:05:17 <verement> Wizek: where does x come from?
01:06:07 <Wizek> verement, Axman6: updated the gist with the relevan hs file
01:07:46 <Axman6> Wizek: what's that "" doing there? it should be some kind of IO action
01:07:52 <Wizek> In order to avoid an XY problem: I am trying to send a POST request over HTTPS with http-streams (I also tried http-conduit but I got different errors there)
01:07:54 <Axman6> but, the error is still odd
01:08:14 <verement> Wizek: my best guess would be that x is a lazy ByteString, while S.putStr is expecting a strict ByteString
01:09:54 <Wizek> verement, How can I change one or the other to be identical?
01:10:50 <verement> Wizek: try importing Data.ByteString.Lazy as S and see if that makes a difference
01:10:52 <mjrosenb> @hoogle Int -> Integer
01:10:53 <lambdabot> Data.Bits bit :: Bits a => Int -> a
01:10:53 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
01:10:53 <lambdabot> Data.Bits complementBit :: Bits a => a -> Int -> a
01:11:05 <mjrosenb> uhh... no.
01:11:08 <mjrosenb> :t fromIntegral
01:11:09 <lambdabot> (Integral a, Num b) => a -> b
01:11:48 * hackagebot arb-fft 0.1.0.0 - Pure Haskell arbitrary length FFT library  http://hackage.haskell.org/package/arb-fft-0.1.0.0 (IanRoss)
01:12:03 <verement> Wizek: there's also fromStrict/toStrict from Data.ByteString.Lazy
01:14:21 <Wizek> verement, Doesn't seem to make a difference If I import lazy. Also tried from/to, updated gist with the resuting errors
01:15:58 <Wizek> I should also probably tell that I had some problems with cabal installing outdated versions, so messed around with it and have multiple versions of bytestring on my computer. Can that couse such a problem?
01:16:17 <verement> it very well might
01:17:55 <Wizek> How can I uninstall outdated packages?
01:18:23 <Wizek> (Or rather, should I, given there is no such thing as uninstall for cabal)
01:18:48 <verement> I wish I could tell you… I'm afraid that's getting a bit outside my comfort level
01:26:50 * hackagebot elerea-examples 2.2.3 - Example applications for Elerea  http://hackage.haskell.org/package/elerea-examples-2.2.3 (GergelyPatai)
01:44:18 <mjrosenb> how does STArray work?
01:44:47 <mjrosenb> does it only exist inside the ST monad, and I can only compute values using the array, or can I return a finalized array that can no longer be mutated?
01:45:40 <Axman6> mjrosenb: the latter, you use freeze to turn the array into a non mutable array
01:45:40 <adnap> Is there a library that can extract rar files? I can't find one
01:45:50 <mjrosenb> :t freeze
01:45:51 <lambdabot> Not in scope: `freeze'
01:46:01 <mjrosenb> Axman6: where is freeze defined?
01:46:12 <mjrosenb> @hoogle freeze
01:46:12 <lambdabot> Data.Array.MArray freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
01:46:12 <lambdabot> Data.Array.MArray.Safe freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
01:46:12 <lambdabot> package safe-freeze
01:46:50 <Axman6> I think there's also a function runArray :: ST s (MArray s a) -> Array a
01:46:55 <Axman6> @hoogle runArray
01:46:56 <lambdabot> No results found
01:46:58 <Axman6> hmmm
01:47:01 <Axman6> something like that anyway
01:47:11 <Lethalman> @hoogle runSTArray
01:47:11 <lambdabot> Data.Array.ST runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
01:47:11 <lambdabot> Data.Array.ST.Safe runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
01:49:18 <codygman> I've been writing command line programs in haskell. Is this a good method for a simple program which will only ever take one un-named argument: http://lpaste.net/99106
01:51:53 * hackagebot JuicyPixels 3.1.3.2 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.3.2 (VincentBerthoux)
01:52:07 <augur_> anyone have ripley's cupboard type stuff you might be willing to contribute to an online pseudo-journal-thing?
01:54:57 <kwos> hi everyone :) I have a quick question that I'd like to ask
01:55:15 <kwos> is there a flag you can use in .cabal when the package is configured with --enable-tests?
01:59:27 <notdan> augur_: what's a ripley's cupboard?
02:00:50 <augur_> notdan: the place in your mind where you hide away all the misguided, but seemingly good, design choices you've made
02:02:04 <notdan> I see, th
02:02:04 <notdan> x
04:03:19 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
04:03:19 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
04:03:19 --- names: list (clog yorick ndrei martinalex dredozubov fredyr Roklobsta gauthier jophish raichoo shahn sepp2k1 simukis_ aergus fishkzn yesthisisuser gabor mm_freak plcplc inerkick reizuki thomasd Guest5541 hd2 Lemmih klrr_ lemao ant0wn Betal Earnestly nkoep io2_ H1FuelCell meoblast tharper bjz Hexagenic Icewing HugoDaniel jdnavarro DRMacIver epsilonhalbe kilian0815 implementation_ cwraith tril doomlord_ [1]Endy kludge` asQuirre_ liyang myoriel ZioCrocifisso jensgb poulson)
04:03:19 --- names: list (philed` ulfdoz kyrylo wolfnn jackneill brewbrew c_14 wollw roconnor_ nadirs Sgoettschkes julian_ MindlessDrone sidus mgsloan codygman pothepanda eazar001 alanz A1kmm Sculptor SoupEvil Kaini avaritia Lethalman ademidov datura Reite Vince_Juicy halu matheus23 odi Wizek danvet seschwar dnewby conehead rajeshsr misterbee TDJACR path[l] niko ktosiek_ EvanR2 ompaul maoe hamishmack codesoup MrWoohoo klaut marcus-aurelius aztek vili fabe ioanel cryptische Kiryx yitz)
04:03:19 --- names: list (xarts19 centrinia goldkatze RichyB Kaidelong m3ga mno2 araujo recycle johntromp sski jbauman_ conal edwardk bmuk Corey pierpa zacts tromp attilah pxqr frxx Rylee aji Eagle_Er1in vital_ KorriX_ bd__ ssedov Martty__ poucet_ newsham relrod FreeFull mietek_ nominolo_ Shin-LaC copumpkin otto_s verement shanse Argue kcj Watabou apaku chaoyi vikraman nus xexonixxexillion pfurla ashnur yayutf occamshatchet srh_ redir augur_ killown shepheb_ dolio flippo zxq9 fran)
04:03:19 --- names: list (jorj schell dmwit_ cowtown latro`a rola clemux frontendloader hongminhee alderz_ indigo iron_houzi adlan yusukesuzuki bsmt amosr ixti alskdj amathew1 xpika chrisdotcode oleo xinming_ bjorkintosh jobstijl0 mocrunsthecity d3lxa liori Guest35013 thunderrd kini timemage Sixmsj emma stepkut cjsarette fikusz mendez_ moto9 shesek Artpicre Qett OlegYch Mangellan2497 PaulFertser whaletechno oubiwann cory786 shutdown_-h_now vendethiel alexherbo2 tomejaguar BMeph)
04:03:19 --- names: list (joneshf-laptop [[zz]] iArthur_ jlamothe troydm Cale maximveksler profmakx MoALTz Soft dsirenko_ meretrix osa1 Belgarion0 lanbird descender sellout- Tinned_Tuna drbean erry smarter milessabin Kobata m1dnight_ Excureo DexterLB rawtass aristid Freeman42 ghorn Guest50881 rgrinberg Internet13 otterdam pnielsen edk thirsteh Iceland_` dreixel_ hackagebot randomclown jizanthapus Squid_Tamer ForNeVeR Natch gienah obcode arrdem Jesin omefire1 demolith1 jefimenko)
04:03:19 --- names: list (tomboy64 thetallguy1 sxn vmeson lpsmith tavelram sinclair|work Ralith shachaf Tesseraction edunham mcglk jml Sgeo bytbox _nano mononofu anders^^ mikeplus64 lol_ rien crs_ shlevy asm89 bernalex cjay scott_ funfunctor mlen noctux Myk267 jack_rabbit coeus_ geekosaur bounb ThatCantBe nik_89 phienone JesuZ tensorpudding xahry merijn milieu_ orospakr kloplop321 l0st1 monochrom MercurialAlchemi mephx knyon ByronJohnson Tene Nafai kqr effy mythmon sfvisser bbloom)
04:03:19 --- names: list (jlewis Guest25598 tristero sclv_ tahu Lindrian junsuijin creichert mavam Gunni hungryblank sajith blast_hardcheese klarh jonasw ccs4ever flebron drAgda jmcarthur Draggor jle` zarusky Vorpal tpsinnem dsantiago betawaffle Bwild brainproxy jcurbo thetallguy GaveUp mrd joshbohde bgamari sw1nn aseidl AntiSpamMeta kipras dennda yeltzooo __main__ andrewsw lzm MarcWeber mikeI jb55 catsup necroyeti mattp_ AncientPC larsrh maaku_ jackhill bxc chrra bholst caligula_)
04:03:19 --- names: list (mlinksva Cr8 pseudolio mindleyhilner DasIch eataix int-e _flow_ eyck jayferd bearclaw Phlogistique DT`` mmmm klz uniquenick Sonderblade cognominal aleksejs_ amiller GGMethos ernst tych0 twf zso grohne Edoxile mist11`off cyphase tsou lispy jaimef Raynes Axman6 ahf ibid mrmonday fmapE qrada Kabaka saep stevely__ intrados alexdoom etabot jibi stiell quaestor bitraten1 tero- ZsoL sam_d cdidd joe9 thomassgn akurilin ``rawr ejls dustinswan Guest55629 yano subleq)
04:03:19 --- names: list (nbouscal ts33kr Adeon ktos cdk Enigmagic pi8027 Martingale mr- s_e_zz AshleyWaffle Maerten honza kadoban ps-auxw Kruppe Khisanth Spaceghost sunfun hattmammerly ChongLi samrat_ Nik05 johnw kazagistar yriw Adios sohum willb1 robinbb _d3f iFire uncleBlazer julmac thebnq noteventime zorzar kylcarte dgvncsz0f dp_wiz otulp melter miconda jrw aford tinyghost wrunt Tamae chitech noam mjrosenb Maior pikhq wchun bicgena pdxleif visi0n DarkFox Mortomes_ ninzine lulf)
04:03:19 --- names: list (paulschellin stephenmac7 bergey asjo SHODAN defanor acharles kingscrusher stepcut hive-mind seanparsons mrb_bk keelo bigos Dtgr chirpsalot natte arcke kloeri Tarential _janne gbarboza ivan` lambdabot zerokarmaleft sleepynate Excedrin Tehnix Nimatek martin taruti Sagi adimit_away og01_ mandu_ kaol Hafydd ikke dv- adbge Blkt finnrobi zoktar tarmil benj_ arnsholt eyem FliPPeh dixie prinsen Aleksejs hvr Cradam DustyDingo frege juhp cwvh lafa zeiris maurer xaimus)
04:03:19 --- names: list (dlundy biscarch tburns jmct mjo brandonw dested jayne numberten lab-notes Averell ValicekB maskt jedavis minsa LordDeath dumbhat mtlatif drmegahertz bunzen sclv marsam lattenwald bduc a11235 Fuuzetsu socksy iNode000 pranz k00mi mornfall vobi go|dfish MK_FG jungnam yeshuah ggherdov shennyg they ethercrow identity tautologico jix Polarina klugez harski MetaCosm Zariel SaBer acfoltzer jang Ornedan majoh heikkih d-snp wormphlegm Brando753 cpa luigy kryft TK009)
04:03:19 --- names: list (jcande ciaranm banjiewen djahandarie pyrtsa eagleflo TheBrayn lusory simonnn passiveobserver StoneToad subleq_ Boney vnz ilmig derekv SegFaultAX tridactyla carter ninegrid OrangeDuck spion gseitz jrib gpampara verrens arthur_honeynet bens helgikrs goffrie zaphar_p1 aegray bartavelle osfameron b0c1 dmilith zeom HalfWayMan seliopou \u ofan adinapoli lpvb rmunroe_ jxport mortberg mm_burea1 uu1101 heath XMunkki dcoutts CosmicRay magicman JPohlmann lamilami)
04:03:19 --- names: list (Jonno_FTW noplamodo knyppeldynan fayden MooGoo dhrosa mami Athas shelf linduxed cynick thoughtpolice tixxit DarwinIsGod rhodesd dilinger myme1 kfish canta ivan\ M-ou-se keko_ tg PHO_ cods nemesit|znc henk joelteon mrshoe Arnar rasmusto tristan__ mrowe_away Meistarin lahwran ormaaj slobo xnyhps dario| Svedrin saiam farn killy9999 Iskarlar bmuk` zoglesby gspr Walther SLi anhall kenkku mviljamaa ent deggis zz_robj_ adnap rieper_ warpy qwandor kaw pqmodn FireFly)
04:03:19 --- names: list (drewr opqdonut gridaphobe idoru inr saarin BrianHV davean eL_Bart0 MitchW_ SimonJF levi brisbin jchee kshannon tov Valodim duairc finchd KitB zebr amontez DigitalKiwi geal ousado helmut deavid mikecaruso Paprikachu boyscared Taneb ski barrucadu so BlastHardcheese posco_ korpse_ jonathanj saurik dogmaT_ lieven_ DNA Whazor Maxdamantus zpconn lightquake Deewiant nurupo nkpart Jello_Raptor jlouis asQuirreL franksh zeroskillor etrepum radix ryanakca tomh- Baughn)
04:03:19 --- names: list (dschoepe dsp_ leifw def-lkb davidbe__ mantovan1 dottedmag AlainODea_ apples conehead_ zachmassia bgyss NobbZ|away Reiser tomprince sm neurocyte jroesch_ serge jrslepak alexsdutton qpls CaveJohnson deni dj_ryan mangaba_leitosa q66 katis drdo mbrock xintron kmicu kakos Eridius xymox udevd alexsdut1on Igloo kragniz Plasmastar joefiorini s2r2 `^_^v joeyh vpm dan64 justinls_ Yaniel DarkLinkXXXX_ fionnan Wardje ParahSailin si14 geoffh lokydor aninhumer dtkatch rs0)
04:03:19 --- names: list (horlicks twn_ xplat Annamaria paz_ mshroyer joshsz Starfire_ leocassarani annulus absence dabradley flazz_gone voyd dawik munro_ jrmithdobbs peltchu salvatoz statusfailed quicksilver earthy flori xrl__ ConstantineXVI bobry raphie ccasin petantik koala_man kcliu_ divyansr__ CADD lacrosse Raynos ehamberg PatrickRobotham puzza007_ stephe BlankVerse_ thomasschroeter bkolera sweeks Xorlev liesen__ idnar akraut aloiscochard reiddraper xkb wilfredh percival__)
04:03:19 --- names: list (nuttycom1 tbelaire bambams hpc wting WarzoneCommand s4msung upgrayeddd ryanbooker docsis Sibi__ DarthArachides lopex tobyp davorb jodaro jzelinskie donri squimmy xorox90__ kennycason Cerise srcerer dropdrive byorgey srhb phryk Elision AleXoundOS stelleg jfhall majackson egads sondove ocharles neptunepink shapr lenstr cbw nwf marienz japesinator prophile Spockz fnordbert dyreshark utkarsh cschneid gereedy pp^ simpson The_third_man pyykkis ttuegel shiona)
04:03:19 --- names: list (ashooby mixi rdevilla yam nitin2 peder Fubar^ copton MasseR_ Razz_ javawizard erider Nickeeh wagle TakSuyu thalassarche td123 froztbyte wunki noddy2OOO mastensg popx `0660 bgresham sa1 helgar Thulsadu1 bogner` lpaste cross ion Nahra jamesjb thorkilnaur notdan sgs Ptival Cryovat h_chiro__ joachifm burp croys stvc honkfestival Heffalump exicer Twey bind1 Liskni_si __class__ Ulrar skypers kxra bitemyapp Laney gargawel_ kosmikus gemelen nicoo ziman leroux vvv)
04:03:19 --- names: list (schlumpi_ mak` cow-orker epta Will| boegel|work valdyn drbop morolin felipe_ noidi cryzed dsrx brixen Kneiva mgaare FUZxxl NickHu tromp__ bezik tdammers haasn iulian RevJohnnyHealey AshyIsMe theDon davorak aoh Dodek jzl_ vhz michaelpj mokus ginmaniac Gracenotes sordina1 sdx23 ocfx benbangert sipa pjstadig sababa eevar Derander_ evax Drezil [swift] m0g bcoppens_ felixsch robbert mike2 pfoetchen apo gallais Ke jj2baile juuhaa Chousuke Urchin flux chipdude)
04:03:19 --- names: list (radioxid spaceships kittensoup ibab fabjan ReinH confound_ Yawgmoth benmachine mimi_vx moop Labrit scshunt CindyLinz Sornaensis zenzike _1126 castor3 JulyO_o tawm tessier topi` koninkje_away `bps bstrie ixian akiress_ ido kbotnen @ChanServ tomaw b2coutts aszlig bbee pierreghz sunnavy mmaruseacph2 stbuehler alios mena dju epsylon macron hc FreakyPe1guin Kinnison mero cmsd2 satshaba1 Eelis tippenein Gothmog_ pharaun supki _br_ orzo integral Hardolaf Jaak colah)
04:03:19 --- names: list (ortmage_ yac KaneTW __mkrull Saizan zomg jaspervdj fergusnoble qz k4nar_ tamiko luite fall_ Amadiro raek erikl_ hpd Dashkal vvein bergmark Javafant edwtjo krakrjak_ Licenser Rembane hiredman pcapriotti Bigcheese fryguybob solarus petanqk dflemstr inarru_ Clint jorendorff_away Vq jamwt1 zeroXten necronian Jaxan binarystarz ircbrowse companion_cube raid hdevalence|away greymalkin peddie Boreeas mechairoi machisuji)
04:03:20 <pothepanda> maybe not the right channel, but anyone knows if theres a library written in php implementing haskell's prelude functions?
04:03:39 <Axman6> I hope not...
04:05:12 <pothepanda> why ?
04:05:33 <yitz> Axman6, pothepanda: actually there almost certainly is, but it's likely proprietary and internal to facebook
04:05:35 <Axman6> though, I'm sure you could convince xexonixxexillion to write you one if you asked nicely, it's the sort of torture he'd love :P
04:05:47 <Axman6> yitz: ha, yes you're probably right
04:06:20 <Axman6> I imagine if it didn't already exist, simon marlow would've made that one of his first projects :P
04:07:52 <pothepanda> facebook uses haskell functions implemented in php ? didnt know that
04:08:28 <Axman6> facebook use a fair amount of haskell afaict. I believe they've got a PHP refactoring library written in it
04:09:00 <Axman6> and they didn't hire simon marlow for nothing I'm sure
04:09:06 <pothepanda> you mean hip hop ? no
04:09:17 <yitz> haha
04:09:46 <Axman6> no, I'd guess that's all C++
04:09:59 <Axman6> actually, that's open source isn't it?
04:12:15 <yitz> Axman6: i think pothepanda was talking about the hip hop star named marlow. we were talking about the haskell start named marlow.
04:12:23 <yitz> *star
04:12:54 <Axman6> not the hip hop VM that facebook wrote to convert PHP into C++?
04:13:05 <yitz> that is/was called marlow?
04:13:12 <Axman6> also, there'sd a hip hop star named simon marlow?
04:13:15 <yitz> even before simon went to work there?
04:13:21 <yitz> just marlow, not simon.
04:13:28 <Axman6> no, it's called hip hop...
04:13:32 <Axman6> what?
04:13:34 <Axman6> I'm so confused
04:13:37 <inerkick> how to do webscrapping in Haskell
04:13:38 <yitz> oh. funny.
04:14:21 <Axman6> https://www.facebook.com/hhvm
04:14:42 <yitz> disclaimer: i'm no hip hop fan. but after pothepanda's comment i googled and found out that there's a guy named marlow who records hip hop and seems to be well-known.
04:17:39 <nicoo> Axman6: No, the HipHop *VM* is a VM for running (and JITing) PHP. The earlier HipHop project compiled PHP to C++, yes
04:17:51 <Axman6> right
04:18:13 <Axman6> I only said VM to make it clearer I wasn't talking about music =)
04:18:35 <yitz> despite the wonderful coincidence, it doesn't appear that simon is working on the hhvm team from the picture. but who knows.
04:19:31 <nicoo> Axman6: Ah, right. Only read half of the messages :3
04:19:33 <nicoo> Sorry
04:19:52 <pothepanda> ok so no implementation for haskell funcs, thats not proprietary
04:20:47 <Axman6> pothepanda: not that we know, doesn't mean it doesn't exist
04:22:10 * hackagebot wai-extra 2.0.3.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.0.3.2 (MichaelSnoyman)
04:24:09 <Wizek> Is [this](https://gist.github.com/Wizek/1609fc6c637f69f6a7db) what people refer to as [cabal dependency hell](http://www.yesodweb.com/blog/2012/11/solving-cabal-hell)?
04:24:44 <notdan> Wizek: yeah
04:25:07 <notdan> Wizek: although I think maybe this parcticular one can be solved by reinstalling all the broken packages alongway
04:26:00 <Wizek> notdan, should I do a --force-reinstalls then?
04:26:20 <Wizek> (can that be reversed in case it doesn't work?)
04:27:57 <notdan> You can try cabal install hxt openssl-streams http-streams .. etc
04:28:03 <notdan> but you reallly should use sandbox
04:28:08 <notdan> in order to avoid problems like that
04:28:27 <pothepanda> Axman6, yup ok, thanks though
04:34:34 <ion> Would it make sense to modify System.Random to use GHC.Exts.build in randoms and randomRs?
04:49:45 <mjrosenb> huh, TIL: mjrosenb@ac:$
04:49:45 <mjrosenb> ~; factor 1111111111111111111
04:49:45 <mjrosenb> 1111111111111111111: 1111111111111111111
04:55:04 <SaBer> mjrosenb: http://primes.utm.edu/curios/page.php/1111111111111111111.html
05:02:14 * hackagebot RFC1751 0.1.0.0 - RFC-1751 library for Haskell  http://hackage.haskell.org/package/RFC1751-0.1.0.0 (XenoGenesis)
05:07:16 <narendra19> Can someone help me figure out the benefits of immutability?
05:08:43 <pothepanda> think of a beatiful wife that loves you. now think of an immutable beatiful wife that loves you.
05:10:43 <SaBer> narendra19: with immutable data structures you have no implicit shared state
05:10:54 <narendra19> pothepanda: a statue of bronze won't be my wife!
05:11:35 <narendra19> SaBer: no implicit shared state.. any examples?
05:14:23 <mornfall> pothepanda: she'll be missing u forever
05:15:23 <mornfall> narendra19: many bugs are much easier with mutation than without
05:15:38 <yitz> narendra19: if a datatype is guaranteed immutable, the compiler is free to optimize by garbage collecting them and recreating them later, creating multiple copies if needed, etc.
05:15:57 <mornfall> yitz: you mean pessimize? :-)
05:16:12 <SaBer> narendra19: Rick Hickey has a good talk about values, but it's from a larger point of view: http://youtu.be/-6BsiVyC1kM
05:16:18 <mornfall> having multiple copies of an immutable thing seems like a waste
05:16:25 <yitz> mornfall: well, we hope the compiler writers do a good job :)
05:16:48 <mornfall> yitz: but yeah, CSE is a canonical example, I guess
05:17:30 <yitz> mornfall: sometimes it helps and sometimes it hurts. like inlining.
05:17:50 <mornfall> yitz: CSE only hurts if your language is lazy ;-)
05:19:45 <mornfall> where it can go arbitrarily wrong, I guess (in that it can hold on to arbitrary amount of garbage that'd be collected without CSE)
05:20:38 <mornfall> all in all, laziness has some pretty counter-intuitive implications especially for space complexity
05:21:59 <yitz> SaBer: a more subtle advantage is the possibility of referential transparency: your functions always give the same output for the same input, nothing secret going on behind the curtains. i think that is what narendra19 was hinting at. we have found in practice that refererntial transparency is a huge advantage for clarity, correctness, and maintainability of code.
05:22:39 <Lethalman> I always think of laziness like this: it's hard to transform a strict program to a lazy program, because it's hard to make things lazy when they are not at the base.... it's rather easy to make strict something lazy
05:22:49 <Lethalman> so imo laziness is a virtue
05:23:21 <Lethalman> same goes for IO, it's easy to make everything IO, it's hard to do the opposite
05:23:26 <yitz> Lethalman: i think at the end of the day they are just two very differnt ways of expressing things. the translation in either direction isn't always so simple.
05:23:47 <Lethalman> yitz, it's certainly simpler to make strict something lazy
05:24:21 <mornfall> see eg. http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.27.4339&rep=rep1&type=pdf
05:24:40 <Lethalman> the problem is when you need laziness, but the underlying code you are using is not, at that point you have little to do
05:25:13 <yitz> mornfall: the implications are only counter-inuitive if you have spent many years building up your intuitions in strict languages exclusively. which was the case for everyone when haskell was new, but not as much today.
05:25:17 <mornfall> Lethalman: not really, making a random program that relies on laziness into a strict program naively will give you non-termination
05:25:37 <Lethalman> mornfall, that's true
05:25:45 <hpc> yitz: it's still quite a bit true today ;)
05:25:57 <Lethalman> mornfall, but that piece should not be "stricted" then :P
05:26:03 <yitz> hpc: yes. not *quite* as much.
05:26:07 <mornfall> yitz: I don't think that's entirely accurate. The problem is that the space effects are very non-local.
05:26:25 <mornfall> yitz: and most people's brains don't cope very well with that
05:26:46 <mornfall> (you could argue that space behaviour of lazy programs is non-composable)
05:27:31 <yitz> mornfall: i stand by my claim. "most people's brains" is a very subjective statement, and i firmly believe that your claim is based on a very skewed sample space.
05:27:34 <mornfall> this kind of non-composability is the main argument for purity too :)
05:29:53 <mornfall> yitz: well, you are saying that composable correctness is more important than composable complexity, I guess -- whether you expend the effort to "see through" correctness issues or complexity issues, it's still substantial effort
05:32:45 <mornfall> (also known as the conjecture of free lunch nonexistence)
05:33:06 <yitz> mornfall: i'm saying more that that. space effects can be global in strict languages, too; in fact, space usage is obvously uncomputable. there are well known techniques and practices for localizing and controlling space usage in strict languages. the same is true for lazy languages. the techniques are less well-known and less well-studiied, because they are newer. but i believe that due to better semantic clarity, they will utlimately prove to be be
05:33:41 <mornfall> (you probably got cutoff by IRC)
05:33:57 <yitz> mornfall: and yes, i know that harper disagrees with me. :) but just wait and see.
05:33:57 <arnsholt> yitz: you got cut off at "ultimately prove to be be"
05:34:33 <yitz> ok, sorry. will ultimately prove to be better, not worse.
05:34:39 <mornfall> yitz: also, the same is true of correctness and purity -- it's not a silver bullet
05:34:48 <yitz> mornfall: true
05:35:58 <yitz> there's no silver bullet. the space of general recursive functions is pretty intractable. but we practicle engineers do manage somehow...
05:36:59 <mornfall> yitz: the coping is a huge kludge, cf. Dijkstra on Mathematics, Inc. ;-)
05:37:13 <yitz> mornfall: yeah. sigh. what can we do.
05:37:36 <mornfall> invent better and bigger kludges
05:38:13 <yitz> right. looking forward to the next better and bigger kludge after haskell.
05:38:24 <mornfall> yitz: it's called Agda :D
05:39:26 <yitz> mornfall: or epigram or idris or something. well. we can start with liquid, or singleton types.
05:40:09 <mornfall> yitz: is there something you can't make better by slapping SMT on it? :-)
05:40:20 <yitz> there you go.
05:42:20 * hackagebot ascii85-conduit 0.1.0.0 - Conduit for encoding ByteString into Ascii85  http://hackage.haskell.org/package/ascii85-conduit-0.1.0.0 (KazuoKoga)
05:44:28 <lingxiao> hey all, has anyone tried installing agda
05:44:36 <Cale> I have
05:44:37 <mornfall> yitz: liquid types reek of CAV :-)
05:44:52 <Cale> (In fact, I think everyone talking right now also has Agda installed ;)
05:45:11 <lingxiao> hey Cale! I'm still having issues and feel bad bothering another day, especially since it's sunday
05:45:50 <lingxiao> well then you're all gods to me, because this is def have not been a pleseant language installtion expeirence i have
05:45:58 <mornfall> lingxiao: doesn't it come with your distro?
05:46:17 <Cale> iirc, lingxiao is on Mac OS X
05:46:24 <mornfall> .oO(distros still come without agda?)
05:46:32 <lingxiao> mornfall: guilty as charged
05:47:00 <lingxiao> oh man thanks for remembering Cale! sorry I'm crowding your mind with details of my machine here ..
05:47:09 <lingxiao> guilty as in I have a mac
05:47:25 <lingxiao> anwyas.. I ran "cabal install agda" and it succeeded, I believe
05:47:36 <mornfall> lingxiao: don't worry, Cale has eidetic memory :P
05:48:13 <lingxiao> this channel is filled with amazing people
05:48:25 <Cale> (I don't know if that's true :)
05:48:34 <Cale> But yeah, it is filled with amazing people
05:48:53 <mornfall> I don't think eidetic memory actually exists. :-)
05:49:21 <mornfall> But it's this kind of foo runs OSX moments that people usually make it out to be. Or something.
05:49:30 <lingxiao> so while running "cabal install --global Agda-executable", I get this error: https://gist.github.com/anonymous/f163c677c06cdc71c39d
05:50:29 <lingxiao> and this is after a fresh install of haskell platform, but before I install the library
05:50:30 <Cale> lingxiao: if you got cabal install agda to work, don't bother with that Agda-executable package
05:50:47 <lingxiao> ahh ok see that was my question, is what the difference is...
05:50:56 <lingxiao> but I'm not sure how to install agda-mode otherwise?
05:51:07 <Cale> It should be installed already.
05:51:22 <lingxiao> wow best thing I've heard in two days :)
05:51:36 <Cale> See if you have an agda-mode program
05:51:48 <Cale> (you ought to, it's part of the agda package)
05:52:00 <lingxiao> hmm.. how do I check?
05:52:11 <mornfall> try running it, I guess... if you have PATH set up
05:52:50 <mornfall> agda-mode setup might even do what you want
05:53:12 <Cale> If not then look in ~/.cabal/bin perhaps
05:53:23 <Cale> I'm not sure if that's where cabal puts binaries on OS X
05:53:34 <mornfall> if it's --global, probably not in ~
05:54:18 <lingxiao> mornfall: running `agda-mode setup` in bash returns command not found
05:54:29 <lingxiao> so maybe PATH is not set up ..
05:56:09 <lingxiao> Cale: well I opened my ~/.cabal/config file and changed user-install to False, ie: "user-install: False"
05:56:27 <Cale> before or after?
05:56:34 <lingxiao> before I installed agda
05:56:38 <Cale> ah, okay
05:56:40 <mornfall> lingxiao: look for something like /Library/Frameworks/GHC.framework/Versions/7.0.3-x86_64/usr/bin
05:56:57 <mornfall> lingxiao: (assuming you installed HP, fix the versions obviously)
05:57:42 <mornfall> but it's kinda weird that cabal-install is on PATH but the stuff you installed with --global isn't
05:59:24 <mornfall> lingxiao: http://www.haskell.org/haskellwiki/Mac_OS_X_Common_Installation_Paths
05:59:48 <mornfall> lingxiao: /Library/Haskell is the location --global uses, apparently
06:00:08 <lingxiao> ok taking a look now!
06:00:10 <Adeon> are exceptions masked inside finalizers?
06:01:37 <mornfall> Adeon: shouldn't finalizers be C code?
06:02:39 <Adeon> well, the ones in ForeignPtr are
06:02:52 <Adeon> maybe I should have given more information
06:03:12 <Adeon> I have IORefs made with mkWeakIORef and they have finalizers
06:03:18 <Adeon> haskell ones
06:04:24 <mornfall> docs are sure sparse on that one
06:06:35 <mornfall> Adeon: you may want to ask in #ghc
06:06:49 <Adeon> hmm, maybe
06:07:00 <Adeon> my program doesn't rely on this, I was asking on curiosity
06:07:03 <mornfall> Adeon: but I wouldn't think anything is guaranteed about those, considering the lack of specification
06:07:29 <mornfall> finalizers are shady business even when they are documented :-)
06:07:38 <Adeon> aye
06:26:06 <lingxiao> so running the agda-mode bin file is not the same thing as running "agda-mode setup" on the command line right?
06:28:25 <lingxiao> mornfall: could I direct that question above to you? --^
06:28:42 <mornfall> lingxiao: not the same, yes
06:28:46 <mornfall> lingxiao: run it from a terminal
06:28:58 <mornfall> lingxiao: it'll give you some instructions
06:29:27 <mornfall> lingxiao: you can do PATH=$PATH:/Libraries/Haskell/.../bin/ and then just "agda-mode"
06:29:38 <mornfall> lingxiao: no idea how to make that PATH change permanent on OSX tho
06:58:03 <klrr_> what does (!) do in blaze-html=?
07:00:53 <byorgey> klrr_: it adds an attribute
07:05:27 <shlevy> Hi, when building with ncurses the llvm libraries are linked to -lncurses as well as the binaries. Is this intended? I had assumed curses was only needed for some cli tool
07:05:30 <shlevy> whoops
07:05:38 <shlevy> meant for #llvm :)
08:17:21 <cschneid> To confirm - there's no way to run haskell inside a JVM?
08:17:47 <cschneid> llvm doesn't do anything like that?
08:20:13 <cmiller_> Does anyone here have any experience with JuicyPixels?
08:20:17 <Maior> cschneid: there's frege and jaskell which aren't quite that bit perhaps similar
08:20:20 <Maior> *but
08:20:57 <cschneid> Maior: that's what I figured, just similar languages. But no way to get GHC to spit out JVM bytecodes that work.
08:21:03 <Maior> cschneid: but http://www.haskell.org/haskellwiki/GHC:FAQ#Why_isn.27t_GHC_available_for_.NET_or_on_the_JVM.3F seems worth a read
08:23:02 <cschneid> Maior: yep - I know it's not an easy project. Makes sense that the answer is: "sure it's possible, patches accepted" - I'd rather GHC keep going in the direction it is now anyway
08:23:42 <misterbee> cschneid, OOC, what is your use case?
08:24:17 <cschneid> misterbee: we spiked out a distributed system based on zmq at work, and are running into... issues that just are hard to fix. So boss threw out Twitter's storm project as an idea
08:24:24 <cschneid> but then we get locked into only JVM languages
08:24:33 <cschneid> I think. Based on my first read of how storm works
08:25:45 <misterbee> Do you need to compile to JVM, or would interop (via JNI and FFI) suffice?
08:25:45 <cschneid> actually, I may just be wrong. There's a php adapter to the framework, and I don't think there's a viable php on the jvm. So that indicates it's language agnostic.
08:26:14 <cschneid> misterbee: I don't know. We're 95% a ruby shop, but something like haskell would make sense for fiddly data manipulation, or speedy math (with stuff like hmatrix)
08:26:21 <luite> there's a java implementation of php
08:26:49 <misterbee> Because there is this (research project, not super production-tested) and I would love to see people try it and tell me if it works before I try :-) https://hackage.haskell.org/package/java-bridge
08:31:51 <cschneid> ok, sorry for my confusion - seems there's a non-jvm thing for storm. Found a perl one, and reading it's impl, it's just stdin & stdout based
08:37:40 * hackagebot courier 0.1.0.9 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.9 (PhilHargett)
08:46:14 <meretrix> Is there any way to use the scheduling priority functions of System.POSIX.Process to control a subprocess created by the functions of System.Process, which only return a ProcessHandle, not a ProcessID?
08:57:07 <Raydiation> >> head []
08:57:15 <Raydiation> is there a bot?
08:58:19 <ij> > head []
08:58:21 <lambdabot>  *Exception: Prelude.head: empty list
08:58:26 <Raydiation> ty
08:59:31 <they> Wow, really? always though head [] would be [].
08:59:35 <Raydiation> so basically head　[] is like div by 0?
09:00:20 <benmachine> they: the type doesn't match
09:00:30 <aleksejs_> they, head [a] cannot be [a]
09:00:39 <benmachine> head xs has the type of *elements* of xs
09:00:42 <they> Oh yeah, duh. What was I thinking.
09:00:54 <aleksejs_> :t mapM_
09:00:56 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
09:01:01 <aleksejs_> :t forM_
09:01:02 <lambdabot> Monad m => [a] -> (a -> m b) -> m ()
09:01:07 <benmachine> Raydiation: yeah, pretty much
09:01:16 <benmachine> i.e. don't do it :P
09:01:21 <benmachine> most people avoid 'head' altogether
09:01:25 <enthropy> > tail []
09:01:26 <lambdabot>  *Exception: Prelude.tail: empty list
09:01:28 <enthropy> > drop 1 []
09:01:29 <shlevy> Hmm llvm-general fails to compile against 3.4, anyone know if this is just overly strict range checking or an actual problem?
09:01:29 <lambdabot>  []
09:01:33 <benmachine> usually it can be replaced by pattern matching, which makes you handle the empty case explicitly
09:01:34 <cschneid> I want a typeclass similar to show, but for human consumable text versions of data. Something like `Pretty`? But I can't seem to find anything
09:02:07 <aleksejs_> []!!0
09:02:10 <aleksejs_> > []!!0
09:02:12 <lambdabot>  *Exception: Prelude.(!!): index too large
09:02:13 <enthropy> cschneid: ansi-wl-pprint has one
09:02:49 <cschneid> enthropy: larger question: Should I just make my own typeclass instead? Pulling in a whole library seems like too much
09:03:23 <enthropy> do whatever you like
09:04:08 <pranz> what was the language extension where you can make type synonyms of restrictions?
09:04:30 <pranz> ReadAndShow = (Read a, Show a) for example
09:04:40 <pranz> and then you can just do
09:04:55 <pranz> val :: ReadAndShow a => ...
09:04:55 <monochrom> ConstraintKinds
09:05:11 <pranz> monochrom: thanks
09:09:46 <piezoid> shlevy: you have to use the llvm-3.4 git branch, this version is not yet on hackage
09:09:58 <Twey> djahandarie: I see you did some work on embedding pure type systems into Agda; how did that work out?
09:10:29 <shlevy> piezoid: Should I expect it to work? Any idea why it's not released yet?
09:11:26 <piezoid> it worked for me (i use the llvm package from arch linux)
09:12:09 <shlevy> OK thanks
09:30:14 <shlevy> piezoid: I assume I need llvm-general-pure from the same github rev?
09:31:17 <mornfall> shlevy: just build against 3.3?
09:32:15 <shlevy> mornfall: I'm trying to reduce dependencies on 3.3 :P
09:32:27 <mornfall> shlevy: aww
09:34:33 <aleksejs_> how to fix this? Not in scope: type constructor or class `Data'
09:35:09 <aleksejs_> caused by: deriving (Data, Typeable)
09:35:14 <shlevy> mornfall: Ack I'll just wait for the next release
09:35:15 <joelteon> import Data.Data
09:35:21 <mornfall> aleksejs_: did you import Dat... nvm :)
09:35:51 <joelteon> or you could import qualified Data.Data and deriving (Typeable, Data.Data.Data)
09:36:40 <Iceland_jack> joelteon: One should use Data.Data.Data whenever possible!
09:36:41 <mornfall> or import Data.Data(Data)
09:36:59 <enthropy> are there ways to define pretty-printers that can generate html or text with ANSI color escapes with one piece of code?
09:37:10 <joelteon> enthropy: ansi-wl-pprint
09:37:18 <enthropy> that doesn't generate html though
09:37:23 <joelteon> oh then idk
09:38:07 * enthropy can use something like https://github.com/theZiz/aha
09:38:38 <enthropy> but I think it's possible to do better than monospaced colored text in a browser
09:43:38 <skypers> :t (%%@=)
09:43:39 <lambdabot> MonadState s m => IndexedLensLike i ((,) r) s s a b -> (i -> a -> (r, b)) -> m r
09:43:43 <skypers> ahah
09:44:18 <ij> looks like an insane function name
09:44:20 <aleksejs_> hmm, newbie question: I have module Foo.Bar and "data Baz" in it. I imported thos module to main program "as Bar" and trying to "Bar.Baz", but it shows "not in scope "Bar.Baz"
09:44:53 <Twey> aleksejs_: Code?
09:45:43 <skypers> ij: totally
09:45:54 <skypers> :t (^@..)
09:45:55 <lambdabot> s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
09:46:00 <skypers> this one always makes me laugh
09:46:42 <dagle> Yay.... I have been trying to use a feature that isn't implemented...
09:46:47 <dagle> No wonder it doesn't work.
09:49:23 <aleksejs_> Twey, http://vpaste.net/EL3gf
09:51:50 <enthropy> aleksejs_: you just exported the type Baz, not the constructor Baz
09:53:07 <aleksejs_> enthropy, and how to import constructor?
09:53:50 <enthropy> you should  module Foo.Bar (Baz(Baz)) where
09:54:03 <enthropy> dunno why you want to be so explicit
09:54:12 <enthropy>  module Foo.Bar where -- works just as well
09:54:49 <aleksejs_> thanks!
10:11:54 <skypers> hey I need some advices!
10:12:08 <skypers> I’m parsing key/value pairs
10:12:35 <skypers> I want to build a structure that keeps order of keys
10:12:40 <skypers> then Map sounds quite great
10:12:50 <skypers> how should I do in parsec?
10:13:01 <skypers> I mean
10:13:10 <skypers> the many1 parser yields a list
10:13:12 <skypers> I want a map
10:13:37 <skypers> I might just outputs ()
10:13:44 <skypers> and use modifyUser?
10:17:53 <simukis_> skypers, make yourself a `Parser (Key, Value)`, which when combined with many1 would split [(Key, Value)] which you can convert to a Map or almost any other data structure which has a `fromList :: [(a, b)] → DataStructure a b`esque function.
10:18:09 <simukis_> s/split/spit/
10:18:44 <skypers> yes simukis_
10:19:08 <skypers> but won’t it be slower than directly using a Map?
10:19:19 <skypers> insert is in O log n
10:23:37 <simukis_> fromList is O(nlogn) which is same as n inserts… well, if you're afraid of intermediate list (almost nothing, given you properly abuse laziness) you could write yourself a custom parser combinator.
10:24:21 <anon_555> hi
10:24:48 <lingxiao> could someone here walk me through a hello agda program?
10:25:00 <lingxiao> or head over to #agda and answer question there?
10:27:29 <joelteon> is there a cabal conditional for whether tests are enabled
10:27:34 <skypers> thank you simukis_
10:27:46 <skypers> do you know how to create a Pico value?
10:28:15 <skypers> from Enum?
10:29:12 <Feuerbach_> skypers: e.g. using realToFrac
10:29:34 <Feuerbach_> > realToFrac pi :: Pico
10:29:36 <lambdabot>  3.141592653589
10:29:52 <skypers> ahahahah
10:30:05 <skypers> @let nan = 0 / 0
10:30:06 <lambdabot>  Defined.
10:30:11 <skypers> > realToFrac nan :: Pico
10:30:13 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
10:30:15 <skypers> :)
10:33:10 <Iceland_jack> @let nanBread = nan
10:33:11 <lambdabot>  Defined.
10:33:19 <Iceland_jack> > nanBread == nan
10:33:21 <lambdabot>  False
10:33:37 <skypers> :)
10:33:51 <skypers> > nan + nan
10:33:53 <lambdabot>  NaN
10:34:23 <Iceland_jack> > (nan < nan, nan == nan, nan > nan)
10:34:24 <lambdabot>  (False,False,False)
10:34:41 <skypers> > nan - nan
10:34:42 <lambdabot>  NaN
10:34:49 <skypers> > nan * 0
10:34:51 <lambdabot>  NaN
10:35:05 <skypers> > 0^nan
10:35:06 <lambdabot>  Could not deduce (GHC.Real.Integral b0)
10:35:06 <lambdabot>    arising from a use of `GHC.Real.^'
10:35:06 <lambdabot>  from the context (GHC.Num.Num a)
10:35:06 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
10:35:06 <lambdabot>  The type variable `b0' is ambiguous
10:35:07 <dagle> nan + nan + nan == "Batman"
10:35:13 <dagle> > nan + nan + nan == "Batman"
10:35:15 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
10:35:15 <lambdabot>    arising from a use of `GHC.Num.+'
10:35:15 <lambdabot>  Possible fix:
10:35:16 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])No instance ...
10:35:18 <lambdabot>    arising from a use of `L.nan'
10:35:18 <dagle> AWw.
10:35:20 <skypers> :D
10:35:41 <colDrMcBeardman> NaN is not a Num.
10:35:53 <skypers> :t nan
10:35:54 <lambdabot> Fractional a => a
10:36:12 <colDrMcBeardman> heresy.
10:37:10 <colDrMcBeardman> i was a little frustrated the other day because i had done some calculations with doubles and wanted to filter the list with isNan
10:37:23 <cmiller_> > nan == nan
10:37:23 <skypers> > floor nan :: Int
10:37:25 <lambdabot>  False
10:37:25 <lambdabot>  0
10:37:25 <colDrMcBeardman> had to do isNan' x = x == x
10:37:28 <skypers> :o
10:37:43 <cmiller_> That was a serious bug for me one time.
10:37:48 <skypers> > floor (nan :: Int) + 1
10:37:49 <lambdabot>  Could not deduce (GHC.Real.RealFrac GHC.Types.Int)
10:37:50 <lambdabot>    arising from a use of `GHC.Real.floor'
10:37:50 <lambdabot>  from the context (GHC.Real.Integral a)
10:37:50 <lambdabot>    bound by the inferred type of it :: GHC.Real.Integral a => a
10:37:50 <lambdabot>    at Top level
10:38:02 <colDrMcBeardman> cmiller_: it was a pain in the ass.
10:38:06 <skypers> > (floor nan :: Int) + 1
10:38:07 <lambdabot>  1
10:38:14 <skypers> this is…
10:38:21 <colDrMcBeardman> skypers: gotta be a bug.
10:38:34 <cmiller_> Makes for a good bad intervie question though.
10:38:38 <cmiller_> When does (x == x) return false?
10:38:42 <cmiller_> Or something like that.
10:38:52 <skypers> colDrMcBeardman: yes
10:39:17 <dagle> I'm trying to get Dyre to get a special cache and configuration dir from the commandline. I do this by setting ConfigDir and CacheDir but something weird happens and the program is run twice and doesn't seem to look in the directories I set.
10:40:00 <colDrMcBeardman> skypers: the standard for c library is that floor, ceil, etc return NaN if give NaN
10:40:11 <colDrMcBeardman> skypers: should someone file a ticket?
10:40:34 <skypers> I will
10:40:42 <cmiller_> There was a big debate with the numpy devs about this a while ago.
10:42:21 <skypers> > ceiling nan
10:42:23 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
10:42:28 <skypers> gosh
10:42:39 <skypers> > truncate nan
10:42:41 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
10:43:24 <cmiller_> Yeah that's not behavior I'd expect.
10:44:03 <dwcook> This should go in that "wat" video
10:44:09 <cmiller_> But I don't know how you'd fix it.
10:44:14 <cmiller_> > :t ceiling
10:44:16 <lambdabot>  <hint>:1:1: parse error on input `:'
10:44:44 <skypers> cmiller_: if a == NaN will fail
10:44:53 <skypers> it might be just be a binary test on the NaN bit
10:45:02 <Yaniel> I was just thinking of that video
10:45:02 <colDrMcBeardman> > 0 * NaN
10:45:04 <lambdabot>  Not in scope: data constructor `NaN'
10:45:15 <colDrMcBeardman> > 0 * nan
10:45:16 <lambdabot>  NaN
10:45:18 <dwcook> Though IEEE 754 float in general is pretty wat
10:45:55 <colDrMcBeardman> dwcook: and there's apparently no free copy online....
10:46:25 <cmiller_> skypers: so you'd just throw an error on ceiling nan?
10:46:35 <skypers> cmiller_: no
10:46:41 <skypers> I’d return NaN
10:46:52 <cmiller_> Is NaN integral?
10:46:53 <Iceland_jack> @ty isNaN
10:46:54 <lambdabot> RealFloat a => a -> Bool
10:47:02 <colDrMcBeardman> cmiller_: Floating
10:47:12 <skypers> hm
10:47:19 <skypers> then an exception yes
10:47:55 <shlevy> Is it expected that writeGenericPackageDescription might theoretically generate a cabal file that readPackageDescription might not be able to parse?
10:48:04 <shlevy> Because I have a test case where it's not theoretical :D
10:50:17 <edwardk> what happened to preflex
10:50:20 <colDrMcBeardman> a lot of languages make floor :: Floating -> Floating
10:50:25 <colDrMcBeardman> which is kind of dumb.
10:50:31 <enthropy> gone with mauke?
10:50:37 <colDrMcBeardman> but it lets them give back NaN
10:50:39 <edwardk> enthropy: what happened with mauke?
10:50:51 <enthropy> probably the same thing that happened to preflex :p
10:50:59 <edwardk> touché
10:51:01 <PTBD> hello, how would one read something n times from stdin?
10:51:02 <dwcook> Is preflex the bot that announces pastes?
10:51:21 <edwardk> dwcook: nah preflex was the bot with the working version of 'seen'
10:51:22 <enthropy> no that's a different bot (that's also gone)
10:51:24 <dwcook> @type replicateM
10:51:25 <lambdabot> Monad m => Int -> m a -> m [a]
10:51:27 <dwcook> PTBD, ^
10:51:30 <colDrMcBeardman> on the subject of bots, what happened to the lambdabot plugin that watched darcs repos?
10:52:05 <PTBD> thank you
10:53:30 <dwcook> @type replicateM 3 getLine
10:53:31 <lambdabot> IO [String]
10:53:41 <edwardk> ReinH: ping
10:54:31 <skypers> colDrMcBeardman: https://ghc.haskell.org/trac/ghc/ticket/8702#ticket
10:56:07 <djahandarie> Twey, I didn't. :-(
10:58:20 <Phyx-> hrm.. wtf is 'unsafeDupablePerformIO' and how does it differ from unsafePerformIO?
10:59:50 <Iceland_jack> Phyx-: http://hackage.haskell.org/package/base-4.5.1.0/docs/src/GHC-IO.html ?
10:59:56 <L8D> What was that function that would let you write to a file descriptor directly?
11:00:54 <colDrMcBeardman> skypers: https://ghc.haskell.org/trac/ghc/ticket/7866
11:01:49 <ReinH> edwardk: pong
11:02:14 <L8D> like: writeToFd 1 "foo"
11:02:28 <L8D> would call: write(1, "foo", 3) in C
11:05:51 <aleksejs_> :t q :: Query
11:05:53 <lambdabot> Not in scope: type constructor or class `Query'
11:06:17 <skypers> colDrMcBeardman: huh
11:06:26 <skypers> why is it closed?
11:08:11 <aleksejs_> > let n :: Float; n = 1 in n
11:08:12 <lambdabot>  1.0
11:08:18 <aleksejs_> hmm
11:08:22 <aleksejs_> strange
11:08:40 <colDrMcBeardman> skypers: see the comment above the last comment.
11:08:48 <Iceland_jack> > 1 :: Float
11:08:49 <lambdabot>  1.0
11:08:51 <Iceland_jack> > 1 :: Int
11:08:53 <lambdabot>  1
11:08:57 <aleksejs_> I'm typing "let q :: Query; q = "select 1" in q
11:09:17 <aleksejs_> it shows couldn't match expected type Query
11:09:49 <L8D> aleksejs_: Well, is Query a type synonym to string?
11:10:06 <L8D> do :i Query
11:10:18 <colDrMcBeardman> aleksejs_: if it's a synonym to Text or something else, you need -XOverloadedStrings
11:10:42 <Iceland_jack> You enable it with:
11:10:42 <Iceland_jack>     ghci> :set -XOverloadedStrings
11:10:49 <Phyx-> Iceland_jack: ah, thanks
11:11:08 <Phyx->  /ignore #Haskell JOIN PART QUIT
11:11:10 <Phyx-> oops
11:11:42 <L8D> Phyx-: what irc client are you using?
11:11:57 <aleksejs_> colDrMcBeardman, thanks!
11:12:06 <colDrMcBeardman> aleksejs_, np
11:12:23 <L8D> nvm
11:18:18 <L8D> How can I write to an arbitrary file decriptor, like an Int.
11:18:18 <L8D> ?
11:18:44 <mgoszcz2_> Hi. Does anyone know how to fix "push a = State $ \xs -> ((),a:xs)" for MTL2?
11:19:20 <colDrMcBeardman> L8D, fdRead?
11:20:07 <colDrMcBeardman> err, fdToHandle might be nicer.
11:20:38 <L8D> Well, there was a function somewhere that would take Int -> String -> IO ()
11:21:02 <L8D> When I say file descriptor, I mean a posix file descriptor, and Int
11:21:05 <L8D> an*
11:21:13 <shiona> how do I iterate the same function over until the value does not change? I first thought fix, but it doesn't seem to take an initial value
11:21:19 <colDrMcBeardman> L8D, oh, fdWrite
11:21:22 <L8D> I want to be able to write arbitrarily to an Int
11:21:33 <geekosaur> mgoszcz2_, replace State with state (lowercase)
11:21:33 <mgoszcz2_> Hello?
11:21:36 <L8D> fdWrite takes a Fd
11:21:47 <L8D> which is really just a FILE *
11:21:56 <geekosaur> no it's not, it's a wrapper for an Int
11:22:15 <geekosaur> ghc does not use stdio at all
11:22:20 <L8D> FILE * is a wrapper for an int
11:22:29 <geekosaur> no, it's much more than a wrapper for an Int
11:22:32 <colDrMcBeardman> the constructor is Fd CInt
11:22:35 <geekosaur> it's a whole buffer management system
11:22:42 <mgoszcz2_> Thanks. geekosaur (Nice nick BTW..)
11:22:42 <L8D> ooh.
11:22:44 <Phyx-> L8D: irssi
11:22:45 <L8D> I see
11:23:05 <L8D> > fdWrite 1 "foo\n" >>= return
11:23:06 <lambdabot>  Not in scope: `fdWrite'
11:23:21 <L8D> okay then...never mind
11:23:35 <L8D> Then...How can I get the file descriptor for a socket?
11:24:14 <colDrMcBeardman> L8D, that's kind of a general question. some programs will post sockets as pseudo files in the file system, in which case they would be named.
11:24:19 <geekosaur> painfully, because sockets have an additional bit of platform specific insanity (which is to say, on Windows a socket is not backed by a file descriptor)
11:24:40 <L8D> I'm only running on unix
11:24:56 <colDrMcBeardman> L8D, what is providing the socket?
11:25:00 <geekosaur> right, but you have to delve into the platform specific stuff to get at the file descriptor
11:25:09 <L8D> colDrMcBeardman: anything
11:25:17 <geekosaur> there isn't a general mechanism, because there isn't always a file descriptor there
11:25:18 <L8D> I want to be able to connect to something over TVP
11:25:20 <L8D> TCP*
11:25:24 <colDrMcBeardman> L8D, can you have it post the socket as a pseudofile in a known place?
11:25:31 <L8D> nonono
11:25:41 <L8D> C sockets are file descriptors
11:26:00 <L8D> send and recv are just wrappers for write and read
11:26:12 <geekosaur> on unix yes. on windows it's horribly ugly hackery. ghc, unlike you, cannot ignore windows
11:26:20 <geekosaur> and no, send and recv are not wrappers
11:26:25 <L8D> I don't care about windows
11:26:45 <Phyx-> ouch
11:26:46 <geekosaur> yes, you said that. so you are insisting that ghc is forbidden to care as well?
11:26:52 <colDrMcBeardman> L8D, so you're using raw C sockets in haskell?
11:27:14 <Phyx-> to be fair, he's not alone though
11:27:22 <Phyx-> a quick stroll through hackage proves that :P
11:27:22 <geekosaur> read() and write() work with streams. UDP sockets are not streams and read() and write() do not do the right thing with them
11:27:45 <ddsfww> where can I get happy 1.6?
11:27:47 <geekosaur> yes, I know your response is youre doing TCP, so again: this means UDP's existence must be ignored for your convenience?
11:28:00 * hackagebot happstack-authenticate 0.10.9 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.9 (JeremyShaw)
11:28:02 <colDrMcBeardman> geekosaur, don'
11:28:18 <colDrMcBeardman> t send and recv also change endianness if they need to?
11:29:09 <geekosaur> of the data? no. how does it know where (and what kind of) endianness matters?
11:30:06 <geekosaur> send() and recv() are datagram (self-contained entities with their own destinations and fixed sizes) oriented, read() and write() are stream (an ongoing "conversation") oriented
11:30:16 <colDrMcBeardman> geekosaur, idk, it's been a long time since i used anything that low level, but this all made me think of hostToNetwork
11:30:45 <geekosaur> right, that's something you need to do to prepare an address since all the calls take network byte order for addresses and ports.
11:30:56 <joe9> what is the recommended haskell package for dealing with file paths? I have a path such as "/home/j/" or "/home/j" where j is a directory. I want to get the last directory or the last 2 directories in such paths? I can put together functions from System.FilePath, but, am wondering if there is anything better out there.
11:31:46 <geekosaur> which leads to the confusing behavior of the Port newtype's Num instance in Haskell, because it assumes network byte order instead of native byte order...
11:32:55 <geekosaur> http://hackage.haskell.org/package/filepath http://hackage.haskell.org/package/system-filepath
11:33:29 <geekosaur> the former is more appropriate for portability, since the latter is oriented toward bytestring file paths (which is to say POSIX instead of Windows)
11:33:29 <monochrom> filepath already comes with GHC
11:34:22 <Twey> djahandarie: Oh?  But I found a presentation that said you were going to!
11:34:31 <colDrMcBeardman> L8D, is there a reason not to use Network.Socket?
11:34:35 <joe9> geekosaur: thanks a lot.
11:44:53 <klrr_> is there any mapM but let that function take two args ?
11:45:27 <klrr_> "... :: (a -> b -> m c) -> ..." instead of "... :: (a -> m b) ..."
11:45:41 <Twey> Like a zipM?
11:46:30 <supki> :t zipWithM
11:46:31 <lambdabot> Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
11:46:50 <L8D> colDrMcBeardman: I want to be able to write to either sockets or files
11:47:26 <klrr_> thanks!
11:48:02 <Twey> klrr_: In general this sort of function is just written using ‘sequence’.  mapM = sequence . map, zipWithM f as bs = sequence $ zipWith f as bs, &c.
11:49:44 <L8D> :t sequence
11:49:45 <lambdabot> Monad m => [m a] -> m [a]
11:50:32 <djahandarie> Twey, I ended up presenting some stuff for instantiations of PTSes, but didn't really get time to do the actual PTS construction / it was too hard.
11:50:42 <Twey> djahandarie: Aww.
11:50:50 <colDrMcBeardman> L8D, so wouldn't fdWrite work?
11:52:09 <klrr_> will Text be default string in haskell'?
11:52:36 <Twey> klrr_: I don't think there are any plans for that
11:53:02 <Twey> Text is often a more practical choice, but String is semantically nicer for a lot of things, so I'd imagine it'll remain the default
11:53:24 <colDrMcBeardman> has there been discussion on making OverloadedStrings a "default"? i imagine that would start a good argument.
11:53:53 <L8D> colDrMcBeardman: I plan to use fdWrite
11:54:04 <L8D> I want to generate a CInt from a TCP socket somehow
11:54:25 <Twey> I don't know of any, but it seems possible — we already do it for numbers, after all, and it shouldn't break much code
11:55:03 <L8D> I could just do some ffi to get IO CInt
11:55:10 <cschneid> is there an mconcat for alternative?
11:55:15 <cschneid> "find me the first one that works"
11:55:23 <L8D> and then from there use more ffi to call connect on it
11:55:58 <supki> cschneid: I think you're looking for asum
11:56:12 <cschneid> supki: yep. shoulda guessed based on monad plus's version
11:56:20 <supki> but what asum does depends on the semantics of the instance
11:56:31 <supki> it's not always "first that works"
11:56:36 <skypers> ahahahahahah
11:56:41 <skypers> > realToFrac nan
11:56:44 <lambdabot>  -Infinity
11:56:45 <skypers> :)
11:56:49 <Twey> Where's asum defined?
11:56:57 <skypers> @index asum
11:56:57 <lambdabot> bzzt
11:57:09 <supki> Twey: Data.Foldable
11:57:11 <klrr_> Twey: okey, hope they at least include Text in prelude and enable OverloadedStrings by default as colDrMcBeardman suggests
11:57:13 <Twey> Aha
11:57:45 <Twey> klrr_: Probably not in the Prelude
11:57:57 <Twey> It's already in the Platform though
11:59:10 <klrr_> i dont see why Strings are any better, Text derive all classes you would want to use when dealing with strings, or am i missing something?
11:59:19 <klrr_> s/are/is
12:00:47 <geekosaur> because String is a list and therefore operates with "primitive" list operations. in particular this means they fuse well (produce a lot better code), and short String-s perform much better than short Text-s
12:02:34 <hpc> also String is what you should use when you really do want "a list of characters" instead of a string of text, since you can use map/filter/etc
12:02:56 <hpc> ie, the input to a roguelike
12:04:20 <Twey> Although, if we did make Text the default we could eventually get rid of showList >.>
12:08:01 <hpc> that would be nice
12:08:52 <klrr_> could i get some help with these type errors? i dont quite understand what's wrong, ghc claims p and f is not the same type on line 33 but they are , any ideas?
12:08:56 <klrr_> http://lpaste.net/99118
12:09:07 <Twey> Plus PatternSynonyms and fmap ameliorate the downsides to just wrapping String in a newtype
12:10:11 <Twey> klrr_: Precedence: that's p <> (f : crawle p fs0)
12:10:12 <hpc> klrr_: p <> f : crawle p fs0
12:10:21 <hpc> haha
12:10:40 <Twey> You probably meant (p <> f) : crawle p fs0
12:11:01 <klrr_> oh shit that's emberrassing :x, thanks!
12:11:26 <Twey> klrr_: I did the same thing in Agda about half an hour ago :þ
12:11:48 <colDrMcBeardman> I remember before OverloadedStrings was a thing. yuck.
12:12:39 <Twey> I remember writing code littered with pack's, then giving up and going back to String
12:13:12 <colDrMcBeardman> Twey, hence "yuck"
12:13:23 <Twey> Indeed
12:13:39 <colDrMcBeardman> i actually hadn't done much haskell for a while and when i started working again, thought you still had to explicitly pack.
12:13:50 <colDrMcBeardman> found OverloadedStrings and almost died of joy.
12:14:10 <Twey> Heh
12:14:34 <colDrMcBeardman> one of the nice things about a fast-moving language like haskell... good luck trying to get G++ to automatically throw in the boilerplate for char* and std::string and so on
12:14:51 <hpc> lol
12:14:52 <Twey> I think I was introduced to OverloadedStrings via that blog post where the author implements Roman numerals and makes IsString Integer
12:15:01 <hpc> i still can't remember what the type of "" is in C++
12:15:19 <Twey> hpc: It's char *, but C++ will do automatic conversion
12:15:39 <Twey> (well, const char *)
12:16:24 <Twey> (to any type with a constructor that takes a single string…)
12:16:42 <colDrMcBeardman> Twey, heh, maybe we can do some IsStrings for hieroglyphics and greek numerals.
12:16:57 <Twey> Haha
12:17:07 <colDrMcBeardman> why not, haskell strings are unicode.
12:17:16 <Twey> True that
12:17:17 <codygman> Does anyone know of a native Haskell equivalent to python's dpkt?
12:17:45 <Twey> codygman: http://hackage.haskell.org/package/network-house
12:19:18 <codygman> Twey: Thanks. My sysadmin friend is attempting to replace something to do with snmp at the college he works at because their $1500 software sucks apparently, and I'm hoping Haskell may be his answer ;)
12:19:36 <Twey> Cool
12:20:22 <colDrMcBeardman> codygman, the uni i went to would take the people who couldn't get internships and have them work on stuff for ITS.
12:20:24 <hpc> codygman: see if you can open-source it!
12:20:38 <colDrMcBeardman> everything we had to use (like the registration software) sucked hardcore.
12:21:19 <Twey> Ouch
12:21:45 <colDrMcBeardman> i mean, registration day is basically a DDOS anyway, but then when you have the IT school flunkies writing the code..... bleh
12:22:14 <codygman> colDrMcBeardman: Yeah, he's been mostly using python to replace the other crap. However he needs a native binary with no dependencies now I believe and something a little faster. He was looking at Go, but I've been telling him of my adventures with haskell and he's interested.
12:22:25 <codygman> hpc: Oh definitely!
12:22:54 <codygman> hpc: I'll really be pushing that, and I know he won't be opposed to it/has some leeway with everyone.
12:23:26 <colDrMcBeardman> codygman, i really don't understand what the point of go is.
12:24:01 <hpc> it's algol68 with a wee bit of concurrency support
12:24:04 <colDrMcBeardman> google was like, hey ken and rob, can you rewrite java to be slightly less ugly?
12:24:06 <Twey> The aim seems to be the same as that of Rust: to provide a credible alternative to C or C++
12:24:23 <Twey> It's not very much like Java :þ
12:24:24 <codygman> colDrMcBeardman: Well, it's a more C rather than C++ java as far as I can tell.
12:24:44 <codygman> Twey: True, but I mean in terms of ease of development/"dumb code"
12:25:01 <codygman> well "ease of development" ;)
12:25:18 <colDrMcBeardman> i just look at it and think, aren't there enough languages in this tired arena? what good is one more that's only slightly different than the rest going to do?
12:25:29 <codygman> I've used Go a bit, and it's nice coming from python (which I did)... but then you see the other solutions and it's definitely not special.
12:25:44 <colDrMcBeardman> that's what i mean, it's a case of reinventing the wheel.
12:25:45 <hpc> well, just-slightly-different languages do have their place
12:25:57 <Twey> colDrMcBeardman: That's the problem: there is currently only one language in C++'s arena (type-safe low-level programming)
12:25:58 <hpc> where the slight difference is something other languages lack
12:26:03 <codygman> There are some interesting social effects it has had on getting people to read the source instead of googling for answers though.
12:26:14 <codygman> (at least for me and friends)
12:26:20 <hpc> for instance, if someone went off to make a C + STM language
12:26:21 <silasm> re go: I just like that people are actually *trying* to make tools for multicore programming that doesn't suck. I just wish they could see the ones that already exist.
12:26:25 <Twey> colDrMcBeardman: And C++ doesn't do a great job at it
12:26:34 <hpc> it would be "only slightly different" ;)
12:29:00 <codygman> silasm: Totally agree
12:29:18 <ReinH> silasm: the only interesting thing in that space for me right now is Rust tbh
12:29:20 <codygman> hpc: Wouldn't CPC be useful for that?
12:29:25 <codygman> (continuation passing C)
12:29:25 <Roklobsta> how does haskell go about partitioning code up to run on multicores?
12:29:48 <ReinH> Roklobsta: it provides a variety of concurrency and parallelism tools
12:30:16 <ReinH> a robust threading model and an efficient work-stealing heap for parallelism
12:30:21 <Roklobsta> ReinH: are they automatic or do you have to invoke them or hint towards them with certain ways of writing code?
12:30:32 <ReinH> Roklobsta: they are not automatic
12:30:38 <ReinH> but it is rather easy to invoke them
12:30:43 <silasm> Roklobsta: if you're interested, Simon Marlow released a book on the subject somewhat recently, and it's great.
12:30:46 <silasm> http://shop.oreilly.com/product/0636920026365.do
12:30:57 <silasm> it's freely available online too
12:30:57 <ReinH> yep, it's great
12:31:01 <ReinH> and free and awesome
12:31:12 <ReinH> also we had SimonM on the Haskell Cast recently and we talked about it a bit
12:31:18 <ReinH> /shameless plug
12:31:42 <silasm> ReinH: thanks actually, I was meaning to check that out but last time you mentioned it I was at work, will do that now.
12:31:47 <ReinH> silasm: :)
12:32:28 <silasm> oooh these look delicious, thanks for your contributions!
12:32:37 <colDrMcBeardman> silasm, with go they brought in channels from rob's newsqueak, but still, channels are easily a library thing
12:33:01 <ReinH> silasm: :)
12:33:04 <Roklobsta> hmmm, so much to do, so little time
12:33:32 <ReinH> colDrMcBeardman: they'd be easily a library thing given a sufficiently expressive langauge ;)
12:34:09 <ReinH> and a sufficiently powerful runtime
12:36:09 <colDrMcBeardman> it's definitely like silasm said, you have places dumping money into, e.g, entire new languages, when they could just put that money into langauges that are already doing it.
12:36:11 <Twey> Well, they still need language support (or MVars do, at least)
12:36:13 <colDrMcBeardman> like haskell ;)
12:37:03 <ReinH> Twey: right, you need sufficiently powerful tools to power your abstractions
12:37:34 <ReinH> you're going to struggle to write powerful concurrency libraries in a langauge with naive green threads
12:37:42 <ReinH> i.e. n-1 green threads, not n-m
12:38:39 <colDrMcBeardman> apropos: ick, pthreads.
12:39:13 <colDrMcBeardman> i tried to write a massively parallel port scanner with them. barf. i can't wait to get around to rewriting it in hs.
12:39:50 <ReinH> pretty much
12:40:30 <dagle> Gah, this Dyre thing makes me crazy.
12:40:40 <ReinH> colDrMcBeardman: with the new new IO manager that should be pretty awesome
12:40:45 <ReinH> and super easy
12:40:56 <colDrMcBeardman> also, boost threads were just as icky, but the portscanner could work on winblows.
12:41:20 <colDrMcBeardman> ReinH, when i saw some of the talks on haskell's parallelism, it was jaw dropping.
12:41:47 <ReinH> colDrMcBeardman: yeah :)
12:41:52 <colDrMcBeardman> never seen a thread that lightweight. i was having trouble using thousands of threads of C++, haskell makes millions easy.
12:42:03 <ReinH> colDrMcBeardman: well, Erlang does pretty well there too
12:42:11 <ReinH> but yeah, Haskell's parallel runtime is pretty impressive
12:43:07 <colDrMcBeardman> ReinH, yeah, i saw a presentation on erlang that gave a similar feeling of self-questioning and doubt about C/C++
12:43:16 <ReinH> pretty much
12:43:54 <dagle> Nobody that have any Dyre experiance? I have no clue why wrapMain gets run twice when I set configDir.
12:43:58 <colDrMcBeardman> i liked lisp/scheme but i feel like typing is important, and when i saw a presentation in a class on haskell i was almost immediately converted from everything i'd ever used.
12:44:03 <dagle> (sry for spamming)
12:44:29 <ReinH> I like clojure. If I had to program on the JVM that's probably what I would use.
12:44:31 <Twey> AFAIK Haskell's threads are currently the lightest around.  pthreads are are so heavy they're almost processes in their own right :þ
12:44:38 <Twey> ReinH: Not Scala?
12:44:46 <ReinH> Twey: scala makes me sick to my stomach
12:44:52 <Twey> dagle: You'd have to give code, I think
12:44:54 <Twey> ReinH: Why?
12:44:54 <ReinH> I keep expecting it to be like Haskell and I keep getting disappointed
12:44:58 <Twey> Heh
12:44:58 <simpson> I feel like "threads of control" vs. "threads of execution" might be a useful distinction.
12:45:18 <ReinH> Twey: part of it is limitations imposed by the JVM
12:45:21 <Twey> ReinH: My impression is that it's just a better-typed Java with (slightly) nicer syntax
12:45:29 <ReinH> part of it is limitations imposed by their dogmatic insistance on "object-functional" programming
12:45:36 <ReinH> i.e. broken OOP + broken FP
12:45:40 <Twey> Mm
12:45:45 <Twey> The OCaml curse
12:45:51 <ReinH> worst of both worlds more often than best of either it seems
12:45:57 <ReinH> pretty much
12:46:20 <ReinH> type inference that either lies or just gives up is annoying
12:46:41 <ReinH> "Well I dunno man I think it's `a -> b'? Maybe? Fuck, whatever."
12:46:54 <ReinH> Thanks compiler.
12:46:56 <Twey> Haha
12:47:08 <ReinH> And the types for even something as simple as fmap
12:47:09 <ReinH> are fucking insane
12:47:31 <ReinH> exposing ridiculously complex implementation details in a way that is only approached in Haskell by lens
12:47:44 <ReinH> and that's only because type synonym inference is bad
12:47:46 <ReinH> in Haskell
12:48:06 <ReinH> also the laundry list of things that edwardk mentioned
12:48:12 <ReinH> aanyway yeah give me clojure
12:48:19 <ReinH> at least it's a lisp with some nice added features
12:48:22 <ReinH> not a broken Haskell
12:48:31 <yogurt_truck> =\
12:48:47 <ReinH> and /rant
12:48:58 <yogurt_truck> "scala's type system ain't good enough, let's go dynamic!"
12:49:00 <jrmithdobbs> ReinH: my impressions of scala were just "wtf"
12:49:11 <dagle> Twey: http://lpaste.net/99119 the lines with "this makes it run twice" are my problems.
12:49:12 <ReinH> yogurt_truck: yeah, well at least clojure doesn't pretend that it has a type system
12:49:19 <Twey> implicit def Tuple7Functor[R, S, T, U, V, W]: Functor[PartialApply6Of7[Tuple7, R, S, T, U, V, W]#Apply] = new Functor[PartialApply6Of7[Tuple7, R, S, T, U, V, W]#Apply] {
12:49:20 * yogurt_truck isn't a fan of scala, but it's not bad enough that he'd switch to clojure
12:49:24 <Kaidelong> map[B](f: (A) => B) : Map[B]
12:49:28 <kini> ReinH: have you seen Ermine?
12:49:40 <Kaidelong> that looks like a javascript style type annotation
12:49:49 <Twey> (repeat for tuples 1 through 6, then functions 0 through 7)
12:50:00 <ReinH> Kaidelong: how about:    def map[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That = {
12:50:44 <triliyn> Twey: to be fair, tuples are kind of ugly to deal with anyway
12:50:47 <ReinH> Twey: well, to be fair, Haskell tuple machinery isn't much better
12:50:48 <yogurt_truck> ReinH: that's ridiculous. I still can eliminate sources of error with Scala's messy type system, with clojure it's back to dynamic nonsense
12:50:54 <ReinH> but Haskell's types are prettier
12:50:58 <Twey> ReinH: Aye
12:51:01 <yogurt_truck> though if typed clojure is nice enough I would switch to it
12:51:02 <Twey> triliyn: They don't have to be
12:51:15 <yogurt_truck> but I haven't studied it yet
12:51:23 <Kaidelong> ReinH: are they just using ad hoc overloading to simplify the types of these functions?
12:51:29 <triliyn> Twey: what can you do better other than replacing them with dependent HVects?
12:51:39 <ReinH> Kaidelong: ad hoc polymorphisms via typeclass-y but not quite things iirc
12:51:44 <Twey> dagle: I'm guessing it's probably running the main thing, then finding a configured version in ~/.config/taffybar2 and running that instead?
12:52:02 <Twey> triliyn: You can have just () and (a, b), for a start
12:52:06 <ReinH> whatever a "trait" is
12:52:20 <Twey> triliyn: (that's not a ‘better’, it's a ‘not as bad as currently’)
12:52:32 <triliyn> hmm
12:52:35 <dagle> Twey: From the output it seem the other way around.
12:52:35 <Twey> triliyn: Or you can have *non*-dependent HVects
12:52:48 <dagle> s/the/like/
12:52:56 <triliyn> How would that work? You mean with datakinds or something?
12:53:01 <Kaidelong> Twey: using type level nats?
12:53:03 <Twey> triliyn: Yes, with a type-level list
12:53:08 <triliyn> I guess that would be okay
12:53:20 <yogurt_truck> Kaidelong: there's no simplification of types in Scala ever. it's the opposite that's the problem.
12:53:40 <Twey> Dependent types aren't necessary at all for normal tuples, only if you want to do dependent tuples
12:54:34 <jrmithdobbs> i just don't get what scala was trying to solve i guess =/
12:54:46 <Twey> But even just *not* having 36 different sorts of tuples and making the higher-order tuple syntax sugar for nested pairs would be a drastic improvement over Haskell's current system
12:55:07 <dagle> Twey: I kinda fixed it. By not having a directory called .config/pName it seem to fix itself.
12:55:28 <dagle> Since that is the default directory.
12:55:35 <shachaf> Twey: fsvo "improvement"
12:55:39 <maurer> Twey: While not having lots of sorts of tuples could be nice, this loses some parametricity
12:55:39 <dagle> Sounds like a bug though.
12:56:09 <maurer> Twey: Like, if I have (a, b), then selecting a tuple for "a" or "b" should not have a special effect
12:56:53 <shachaf> maurer: Presumably the representation suggested here represents (a,b) as (a,(b,()))
12:57:05 <Twey> Right
12:57:19 <maurer> shachaf: If we do that, then we've got a second magical hidden tuple layer making things harder to reason about >_>
12:57:28 <maurer> And the compiler will have to go and unpack the tuples for efficiency later
12:57:38 <Twey> maurer: It's the same as lists, and people manage those fine :þ
12:57:59 <shachaf> The efficiency thing is a big disadvantage.
12:58:04 <maurer> Twey: The difference is that if you have a list, you expect that data structure. If you have a tuple, you don't expect to secretly have a list
12:58:16 <Twey> Rewriting things that are nice for humans to read to make them more efficient for a machine to run is what a compiler is for
12:58:37 <shachaf> OK, then fix the compiler to do it and then I might have a different opinion. :-)
12:58:38 <Twey> maurer: I think Python people would say the Haskell list is quite surprising, too
12:58:42 <maurer> Twey: I am arguing this would be harder for humans to read
12:59:34 <shachaf> maurer: It seems to me that it would be mostly indistinguishable from the current situation unless you were trying to do things that are impossible right now anyway.
12:59:48 <maurer> shachaf: Yes, but those thing should emit errors
13:00:01 <maurer> shachaf: Type systems are as much about rejecting things as accepting them
13:00:12 <shachaf> Can you give an example?
13:00:12 <Twey> maurer: It would look the same as it currently does, for the things we can currently write.  You'd just need a special syntax to indicate that you are using the underlying tuples in order to write definitions on n-tuples, which is currently impossible.
13:01:14 <maurer> Twey: Encoding things the way you describe would not provide n-tuples
13:01:32 <maurer> Twey: you'd just have an easier way of writing instances
13:02:01 <Twey> maurer: fst ∷ [a | tail] → a -- to borrow Prolog syntax
13:02:25 <Twey> This is already how it's done in e.g. Agda
13:02:55 <Twey> (except Agda has no sugar for it)
13:03:14 * hackagebot ghc-imported-from 0.1.0.2 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.1.0.2 (CarloHamalainen)
13:03:51 <benmachine> Twey: I suppose the problem is that writing case x of (y,_) -> z; (p,q,r) -> s would type-check
13:04:17 <maurer> Twey: With no sugar, you lose most of the confusion
13:04:43 <Twey> benmachine: No, you'd have to use a different syntax for underlying-pairs vs. finite-length tuples
13:05:09 <benmachine> Twey: I see
13:05:34 <enthropy> maurer: you know the cons list only has to be type level and the values can be in a normal array/hashmap/map/whatever you think is more appropriate?
13:05:35 <Twey> benmachine: (to keep correspondence with current syntax)
13:05:39 <benmachine> ...how upset would people be, *really*, if there were no tuples higher than pairs?
13:05:47 <enthropy> http://www.haskell.org/haskellwiki/CTRex for example
13:05:52 <Twey> maurer: I must admit, I don't really understand your objection — the ‘downsides’ for giving tuples sugar is exactly the same as for giving lists sugar (indeed, you can implement this in Haskell today with a type-level list)
13:05:54 <benmachine> and if you wanted a bigger product you just had to define a data type
13:06:38 <maurer> Twey: Basically my objections are that it will lose efficiency, and cause confusion between tuples and this other thing you want to create
13:07:04 <maurer> benmachine: I've definitely wanted 3 or 4 tuples before, but nothing higher than that
13:07:44 <Twey> The efficiency is a valid objection, but it's a simple compiler optimization to give tuples constant-time access; the confusion argument applies equally to lists, and we seem to have decided that's worth it
13:08:09 <joneshf-laptop> ReinH, speaking of haskellcast plugs
13:08:13 <maurer> Twey: It's not just constant time access, it's a matter of knowing that something is a closed size
13:08:14 * hackagebot shellmate 0.1.1 - Simple interface for shell scripting in Haskell.  http://hackage.haskell.org/package/shellmate-0.1.1 (AntonEkblad)
13:08:17 <joneshf-laptop> ReinH, thanks for them
13:08:19 <Twey> (to give the tuples we can currently write constant-time access, that is)
13:08:29 <maurer> Twey: And it doesn't apply to lists, because lists are lists, and tuples are tuples
13:08:34 <joneshf-laptop> ReinH, so far it's made my commute more bearable
13:08:40 <Twey> maurer: Tuples are just lists of types
13:08:40 <maurer> Twey: You're suggesting creating two different subtly different things, both called tuples
13:08:52 <ReinH> joneshf-laptop: :)
13:08:53 <enthropy> dunno if you even want constant-time reads from tuples
13:08:55 <joneshf-laptop> ReinH, I only have two qualms with it
13:09:00 <enthropy> since then you pay with the writes
13:09:20 <Twey> maurer: I'm not really suggesting that the underlying units/pairs be called tuples
13:09:31 <joneshf-laptop> ReinH, 1) the audio of some of the guests is a bit off: quieter, lower quaity, etc
13:09:41 <joneshf-laptop> ReinH, 2) there aren't enough of them :)
13:09:46 <Twey> I just didn't have a better name for them, and they look a bit like current units and pairs, which are called tuples :þ
13:10:33 <joneshf-laptop> ReinH, but in all seriousness, Thanks
13:10:55 <joneshf-laptop> ReinH, i don't know who the other co-host is, but thank him also
13:23:16 * hackagebot HaRe 0.7.1.0 - the Haskell Refactorer.  http://hackage.haskell.org/package/HaRe-0.7.1.0 (AlanZimmerman)
13:27:46 <Earnestea> joneshf-laptop: https://www.youtube.com/user/jekor
13:28:00 <Earnestea> Actually, I'm probably wrong, nevermind
13:32:04 <Twey> maurer: http://lpaste.net/99120 — it's not so bad, I think, though you get the O(n) access without compiler support
13:32:20 <Twey> (also no precedence lower than 0)
13:32:29 <k1tt3n_> Hi!
13:32:33 <Twey> Hi!
13:32:44 <k1tt3n_> I have a problem with BNFC
13:32:52 <k1tt3n_> on Debian v2.4 is available
13:32:58 <k1tt3n_> now I installed a newer version via cabal
13:33:21 <k1tt3n_> but when I call that program from the command line, I still end up with 2.4 and not the newer 2.5 version
13:33:37 <k1tt3n_> Am I missing something?
13:33:49 <Twey> k1tt3n_: You forgot to add the Cabal bin directory to your path
13:34:01 <Twey> Probably ~/.cabal/bin
13:34:37 <k1tt3n_> ok, I'll check this out. Thanks!
13:37:47 --- mode: ChanServ set +o Heffalump
13:38:02 --- mode: Heffalump set -b *!*6cb45e02@*.108.180.94.2
13:39:23 --- mode: Heffalump set -o Heffalump
13:58:14 <adnap> Often, a really old haddock is the top result from Google, and I click "Contents" and then the latest version.
14:02:38 <Platz> chrome web store: hackage-fu -> know if you're looking at the latest version and provide a link to most recent version
14:03:21 * hackagebot purescript 0.3.3 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.3 (PhilFreeman)
14:04:32 <L8D> how does one prevent the main thread from dying before child threads are done?
14:05:13 <shachaf> There's no concept of "child threads", just threads. No parent relationship between them.
14:05:28 <L8D> erm...
14:05:32 <L8D> "other threads"
14:05:33 <shachaf> Generally you would have other threads explicitly notify the main thread when they're done.
14:06:02 <L8D> If I do: main = forkIO (putStrLn "foo")
14:06:12 <L8D> then "foo" never gets printed
14:06:35 <shachaf> Right. When main exits the whole program exits.
14:07:01 <Twey> L8D: Wait for them, using a Chan or something to indicate when they're done
14:07:01 <L8D> I want to get main to wait until all other threads have exited
14:07:15 <shachaf> You might want to look at async for "threads that you can wait on"
14:07:26 <k00mi> L8D: http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Concurrent.html#g:13
14:08:17 <shachaf> Hmm, I'm not sure that that's actually the best advice. It depends on how your program works, I suppose.
14:08:31 <shachaf> But do look at async.
14:08:33 <shachaf> @hackage async
14:08:33 <lambdabot> http://hackage.haskell.org/package/async
14:08:33 <L8D> I'm just doing a bunch of parrallel HTTP requests...
14:10:22 <L8D> k00mi: thanks, I'll try that first
14:10:47 <k00mi> you mean shachaf?
14:11:07 <L8D> k00mi: you're the one who sent the link to the control.concurrent docs
14:11:22 <L8D> async also seems promising though...
14:11:51 <shachaf> You really don't need an unsafePerformIO global variable for something like this.
14:12:37 <shachaf> mapConcurrently in the async example is doing what you're doing: pages <- mapConcurrently getURL ["url1", "url2", "url3"]
14:12:42 <k00mi> ah, have a look at mapConcurrently in async
14:12:56 <k00mi> heh, too slow :)
14:13:30 <benmachine> async is great
14:13:57 <L8D> holy crap
14:14:12 <L8D> I just found out that haskell imports modules LAZILY
14:14:18 <L8D> at least in ghci
14:14:24 <L8D> mind = blown
14:14:41 <Platz> does haskell have something like Clojure's reducers which split out the reducing function from the 'forking' function?  I wondered if reduercers could be expressed with traversable, but since traversable observes items from left to right I'm not sure it fits
14:14:47 <hpc> you mean it loads packages lazily?
14:15:05 <L8D> hpc: yeah, that
14:15:21 <shachaf> I don't know Clojure's reducers, but Traversable isn't left-to-right, it's tree-shaped.
14:15:23 <hpc> yeah, it's kind of neat
14:15:27 <L8D> when you import, in only loads in the types of everything
14:15:39 <shachaf> Of course, if you're traversing a list, the tree will be right-biased.
14:16:58 <benmachine> the Concurrently type has an Applicative instance and an Alternative instance and both these things are awesome
14:17:04 <Platz> the documention on Data.Traversable  is a little misleading then "Functors representing data structures that can be traversed from left to right."
14:17:26 <benmachine> the Applicative instance meaning you can apply functions to things which will arrive later, and the function arrives when all the things do
14:17:32 <Qett> whats a good haskell programming style?
14:17:35 <benmachine> and the Alternative instance meaning you can race two ways of getting a thing
14:18:10 <L8D> ggeettCCoonntteennttss  >>>>==  ppuuttSSttrrLLnn
14:18:22 <hpc> Qett: the one where you can understand what you wrote 6 months from now ;)
14:18:27 <shachaf> I wonder why Alternative has an Applicative superclass.
14:18:59 <Qett> hpc: any good doc on haskell programming style?
14:19:04 <Qett> like generally accepted rules
14:19:06 <benmachine> shachaf: I've heard people propose laws of their interaction
14:19:17 <benmachine> but I suppose they're not official
14:19:20 <hpc> there's several, and they tend to all state the obvious
14:19:29 <hpc> don't mix tabs and spaces, pick one indentation style and stick to it, etc
14:19:55 <hpc> you'll learn more by reading existing code
14:19:58 <shachaf> It seems like Alternative is just, ahem, a monoid in the category of endofunctors.
14:19:58 <benmachine> https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
14:20:00 <Qett> ok
14:20:11 <shachaf> (Made monoidal using data (f :*: g) a = f a :*: g a, not with composition.)
14:20:59 * benmachine wonders about monoids on the monoidal structure from empty/union
14:21:26 <shachaf> union?
14:21:50 <benmachine> disjoint union
14:22:02 <shachaf> Oh, Either/Void?
14:22:07 <shachaf> The laws force it to be trivial.
14:22:33 <shachaf> I.e. unit :: Void -> a; unit = absurd; mult :: Either a a -> a; mult (Left x) = x; mult (Right y) = y
14:22:46 <shachaf> (And the same with the lifted version.)
14:22:58 <shachaf> (Er, lifted as in :+:)
14:24:15 <benmachine> shachaf: oh, I guess
14:24:31 <benmachine> hmph
14:26:54 <shachaf> And comonoids with Either/Void don't even work at all.
14:27:56 <Twey> benmachine: a + 0 = 0 + a = a
14:28:18 <Twey> The algebraic notation for types is beautiful ☺
14:29:09 <FrungyKing> I have question, need help.  I'm trying to use JuicyPixels to write to .png picture format.  Here's where I'm stuck: http://pastebin.com/BFjNUaaU
14:30:31 <benmachine> Twey: [a] = 1 + a * [a], so [a] * (1 - a) = 1, so [a] = 1 / (1 - a), so taking Taylor expansions, [a] = 1 + a + a^2 + a^3 + ...
14:31:00 <Twey> benmachine: Right
14:31:34 <Twey> benmachine: There's a nice paper recently on applying infinitesimal calculus to types
14:31:39 <benmachine> ooh, is there?
14:31:48 <benmachine> I knew there must be something in it but so far I've just been making it up
14:32:02 <benmachine> haven't heard anything on the subject since Tom Leinster's paper
14:32:30 <Twey> benmachine: https://www.duo.uio.no/bitstream/handle/10852/10740/thesisgylterud.pdf
14:32:57 <hpc> FrungyKing: reading, but so far it looks like that should work...
14:33:13 <Twey> benmachine: And a later presentation by Thorsten Altenkirch in the context of HoTT: http://www.cs.nott.ac.uk/~txa/talks/lyon14.pdf
14:35:07 <hpc> FrungyKing: can you run it again up to defining pic, then do :t pic?
14:35:16 <benmachine> Twey: "The
14:35:17 <benmachine> category of groupoids is in fact a model of intentional Martin-L ̈of type theory"
14:35:20 <hpc> the type should be V.Vector (PixelBaseComponent PixelRGB8)
14:35:30 <hpc> hopefully
14:35:34 <benmachine> Twey: oh dear, typos
14:35:37 <FrungyKing> yeah that's been confusing.  one sec.
14:35:41 <pavonia> FrungyKing: Is that really the error message from the previous input? Because there's no Word8 involved there
14:35:50 <Twey> benmachine: Yeah, the English isn't great
14:35:58 <benmachine> Twey: (there's a delightful paper around somewhere about unintentional type theory)
14:36:02 <Twey> Haha
14:36:37 <benmachine> Twey: http://www.cs.cmu.edu/~cangiuli/sigbovik/unintentional.pdf
14:37:04 <hpc> cabal-dev is not making it easy for me to try this code myself
14:37:05 <Twey> Oh, you were serious
14:37:10 <hpc> need to update ghc one of these days
14:37:24 <Twey> Haha, nice
14:37:36 <FrungyKing> hpc: I can't to :t pic because that's the line it crashed on
14:37:59 <hpc> erp, derr
14:38:01 <hpc> i meant picdata
14:38:20 <benmachine> Twey: well, there is seriously a nonserious paper :P
14:38:38 <benmachine> (the J eliminator is great)
14:38:48 <Twey> ‘This work explores the lesser-known unintentional type theory (UTT), which has a mistaken identity type x:A ≈? y:B of inadvertent conflations of the terms x:A and y:B.’  :-D
14:39:09 <pavonia> FrungyKing: What version of JuicyPixels do you have installed?
14:39:32 <hpc> that paper is the greatest
14:39:41 <FrungyKing> picdata :: V.Vector GHC.Word.Word8
14:40:18 <FrungyKing> pavonia: I did cabal install JuicyPixels yesterday so it should be the latest version
14:40:51 <hpc> ah, there's the problem
14:41:13 <hpc> FrungyKing: cabal doesn't always install the latest of things
14:41:25 <hpc> it installs whatever it can find that fits the constraints of other stuff you have installed
14:41:36 <FrungyKing> oh
14:42:22 <FrungyKing> package JuicyPixels-3.1.2
14:42:39 <hpc> anyhoo, something is up with the type of picdata
14:43:33 <FrungyKing> should this be happening: let a = 240 :: PixelBaseComponent PixelRGB8 ... :t a ... a :: GHC.Word.Word8
14:44:01 <hpc> oh, ahahaha
14:44:08 <hpc> PixelBaseComponent is a type family
14:44:32 <pavonia> heh
14:44:47 <hpc> try removing the type signatures from the end of picdata and pic
14:46:52 <hpc> you might also try something like
14:46:54 <hpc> :{
14:47:07 <hpc> let pic :: Image PixelRGB8
14:47:14 <hpc>     pic = ...
14:47:15 <hpc> :}
14:47:57 <hpc> and with that i am all out of ideas
14:48:28 <FrungyKing> Here's what happened when removing the type signatures from picdata and pic: http://pastebin.com/i2N7Cb5D   which is roughly what I had seen before going heavy on the type signatures
14:48:35 <maxiepoo> @unmtl ReaderT r (WriterT r m)
14:48:36 <lambdabot> Plugin `unmtl' failed with: `ReaderT r (WriterT r m)' is not applied to enough arguments, giving `/\A. r -> (WriterT r m) A'
14:48:40 <maxiepoo> @unmtl ReaderT r (WriterT r m) a
14:48:40 <lambdabot> r -> (WriterT r m) a
14:49:24 <hpc> i wish unmtl would be less pissy about partial applications and just give the lambda on its own
14:49:55 <hpc> last time i tried writing a patch to lambdabot i never could even figure out who to send it to
14:50:01 <hpc> @djinn-ver
14:50:01 <lambdabot> version 2011-07-23
14:50:10 <hpc> except apparently it's applied
14:50:17 <maxiepoo> @unmtl WriterT r m a
14:50:17 <lambdabot> m (a, r)
14:50:36 <maxiepoo> r -> m (a, r)
14:51:00 <maxiepoo> so Is ReaderT r (WriterT r m) isomorphic to StateT m?
14:52:11 <simpson> No; Writers write to a Monoid.
14:52:46 <maxiepoo> @src Writer
14:52:46 <lambdabot> Source not found. It can only be attributed to human error.
14:52:50 <maxiepoo> @src WriterT
14:52:50 <lambdabot> Source not found. stty: unknown mode: doofus
14:52:54 <benmachine> maxiepoo: the bind is different
14:52:57 <jmcarthur> maxiepoo: the thing you can read is still distinct from the thing you can write, unlike in state
14:52:58 <hpc> also if they were isomorphic they would have different instances of MonadReader/Writer
14:53:09 <hpc> and the latter would have no instance of MonadState afaict
14:53:19 <benmachine> the type is the same, but the instances are different
14:53:24 <maxiepoo> wait so not Writer,
14:53:32 <maxiepoo> but (r,)
14:53:38 <jmcarthur> same thing
14:53:51 <FrungyKing> !!!! hpc, I think you got it working.  I put that code into an .hs file: with type sigs for a, b, c, and pic, but not picdata.  It loads fine with :l in ghci.
14:54:08 <danharaj> edwardk: you know that Action part of lens that you think should be split off?
14:54:24 <pranz> doesn't this function exist in the Prelude? hoogle gives nothing
14:54:25 <pranz> (a -> b -> c) -> (a -> b) -> a -> c
14:54:26 <edwardk> yes
14:54:29 <benmachine> maxiepoo: think of it like this - the monad instance for StateT needs to know about both the tuple and the arrow, so it can feed one into the other
14:54:37 <edwardk> vaguely familiar with it =)
14:54:43 <benmachine> maxiepoo: so any Monad instance made by gluing together one for tuples with one for arrows isn't going to work
14:54:45 <maxiepoo> yea I get it
14:54:53 <danharaj> edwardk: I should defend it. I use it a lot to mix RNG into my state actions. Someone gave a talk at our haskell meetup showing how he used it to easily deal with RNG as well.
14:55:08 <maxiepoo> but it seems like there should be a way of composing those things to get state :/
14:55:15 <dagle> This exist in prelude (b -> c) -> (a -> b) -> a -> c
14:55:24 <danharaj> edwardk: Talk was fun to watch, would love to see it go up online soon.
14:55:29 <benmachine> maxiepoo: there is not
14:55:31 <dagle> Maybe it's flipped a bit. :)
14:55:36 <pranz> yeah, but not what I want
14:55:37 <pranz> but oh
14:55:41 <dzhus> Do types refine if I match a GADT with _ pattern? Specifically, are default associated type instances supposed to refine?
14:55:43 <benmachine> pranz: (<*) or ap
14:55:44 <pranz> a -> is applicate
14:55:45 <benmachine> er
14:55:47 <benmachine> yes
14:55:49 <benmachine> (<*>)
14:55:54 <pranz> right, ty
14:56:02 <benmachine> dzhus: I believe types only refine if you match a constructor
14:56:03 <edwardk> then write an impassioned plea for its survival on the issue ;)
14:56:17 <benmachine> so even if that _ could only be one thing, it's not refined unless you actually provide that thing
14:56:19 <danharaj> haha
14:56:31 <josiah14> Quick question on one of the learn you a haskell examples
14:56:33 <josiah14> map (\l@(x:xs)
14:56:34 <danharaj> ok I shall.
14:56:39 <josiah14> what is the @ doing there?
14:56:55 <geekosaur> it lets you name a subpattern
14:56:59 <Twey> josiah14: It binds the list both to the name and also to the pattern (x : xs)
14:57:18 <Twey> So l is the whole list, x is its head, and xs is its tail
14:57:27 <josiah14> aaaah
14:57:31 <josiah14> that's cool
14:57:32 <geekosaur> so l@(x,xs) lets you get at x and xs, but also refer to the whole thing as l (kinda like doing l and (x:xs) at the same time to the same value)
14:57:34 <josiah14> I like that
14:57:51 <josiah14> haskell makes me happy - gives me a reason to get up in the morning, hahaha
14:58:15 <japesinator> When does haskell decide that a number == Infinity
14:58:52 <Twey> japesinator: Depends on the type, but for floats it's according to the IEEE spec (in GHC)
14:59:05 <japesinator> I'm working on finding the first fibonacci number with a thousand digits, and at about 308 digits, it just gives me infinity
14:59:18 <japesinator> Is there a way to get it to use arbitrarily large numbers?
14:59:25 <dzhus> japesinator: yes, Integer
14:59:30 <Twey> japesinator: You're using Float where you should be using Integer
14:59:53 <japesinator> Oh OK, thanks
15:00:03 <FrungyKing> hpc: It compiles and runs and produces a sample picture now.  Thanks so much.
15:01:17 <japesinator> If I have fibs = 0 : 1: zipWith (+) fibs (tail fibs), how can I make use ints instead of floats?
15:01:44 <colDrMcBeardman> japesinator, add a type signature
15:01:49 <jmcarthur> japesinator: it should use either one depending on context
15:02:11 <hpc> FrungyKing: so basically, the issue is that ghc couldn't do typechecking on the type family the way it would for something more normal
15:02:22 <jmcarthur> :t let fibs = 0 : 1: zipWith (+) fibs (tail fibs) in fibs
15:02:24 <lambdabot> Num a => [a]
15:02:39 <hpc> could be worth a ghc ticket? i don't know enough to say if it's a bug or not
15:03:15 <FrungyKing> Interesting.
15:03:16 <japesinator> colDrMcBear:  I had only used type signatures with functions before, not with lists.  How do I do that?
15:03:17 <colDrMcBeardman> Twey, did you see earlier the NaN conversation?
15:03:27 <colDrMcBeardman> japesinator, fibs :: [Int]
15:03:32 <japesinator> jmcarthur:  :: Num a => [a]
15:03:34 <colDrMcBeardman> a name is a name
15:03:43 <japesinator> Oh OK, thanks
15:03:52 <colDrMcBeardman> i suppose you could also do fibs :: (Integral i) => [i]
15:03:58 <colDrMcBeardman> to be a bit more generic
15:05:04 <oisin> Are there any common Haskell libraries for 3D file format (.3DS, .OBJ, ...) parsing? I found a binding for Assimp but it looks like it is unfinished.
15:05:45 <jmcarthur> japesinator: ?
15:05:53 <kilian0815> Why do floating point types don't instantiate Bounded? What is the objective of not using +/- infinity?
15:05:57 <jmcarthur> japesinator: were you asking what that means?
15:07:06 <japesinator> No, I was posting what I got when I put the line of haskell you posted into ghci
15:08:19 <dzhus> kilian0815: probably because you'd normally expect maxBound to really exceed any other member of a type
15:10:35 <kilian0815> dzhus: and maxBound doesn't exceed NaN? Fair enough.
15:11:08 <benmachine> I don't think that's a good reason
15:11:13 <benmachine> NaN breaks Ord as well
15:11:24 <benmachine> hence Data.Set breaks if you put NaNs in it
15:12:06 <maurer> benmachine: "breaks" Ord?
15:12:24 <maurer> benmachine: Oh does it give Ord results corresponding to IEEE semantics?
15:12:27 <enthropy> > S.fromList [0/0,0/0,1/0,1/0]
15:12:28 <lambdabot>  fromList [NaN,NaN,Infinity]
15:12:29 <benmachine> I believe so, yes
15:12:51 <platz_> hrmm github search: unsafePerformIO size:>10000 = 2,595 code results ( https://github.com/search?p=1&q=unsafePerformIO+size%3A%3E10000&ref=searchresults&type=Code )
15:13:16 <benmachine> whereas Data.Set and Data.Map both assume that exactly one of x > y, x == y, x < y are true
15:13:27 <benmachine> (which tbf is a reasonable assumption)
15:15:28 <enthropy> > S.member (-1) $ S.fromList [0/0,0/0,-1,0/0,1]
15:15:30 <lambdabot>  False
15:16:01 <enthropy> so it's not just "I have multiple NaNs" but also that lookups can go wrong
15:16:06 <dwcook> S.isActuallyAMemberForgetThoseInvalidOrdInstances
15:16:27 <dwcook> (Though at that point you might as well just use the list :P)
15:16:30 <enthropy> > S.valid $ S.fromList [0/0,0/0,-1,0/0,1]
15:16:32 <lambdabot>  False
15:16:36 <maurer> And this is one of those cases where I wish we had a modular typeclass thingy
15:16:47 <maurer> because the Ord instance for floats _might_ be a reasonable default
15:16:51 <maurer> but is clearly not usable here
15:17:16 <dwcook> I guess you're doomed to write a newtype for Float
15:17:39 <enthropy> you'll probably find out you have NaNs later on, or you can check with the S.valid
15:18:22 <Twey> colDrMcBeardman: No, what NaN conversation?
15:18:33 <kilian0815> mhm. So what's a better reason for Float not being Bounded?
15:18:34 <Twey> colDrMcBeardman: Was the conclusion ‘IEEE floats are evil’?  :þ
15:18:50 <dwcook> Even that seems unsatisfying, since in the case where your Ord instance is fine, valid traverses the entire structure
15:21:32 <enthropy> dwcook: so you write  myValid :: forall t. Typeable t => Set t -> Bool; myValid | typeOf (undefined :: t) == typeOf (undefined :: Double) = valid | otherwise = const True ?
15:22:08 <enthropy> dunno if there's a nice way to go about checking "my type cannot contain any Double/Float"
15:22:26 <joneshf-laptop> erm
15:22:56 <joneshf-laptop> wat?
15:23:43 <joneshf-laptop> > S.member (-1) $ S.fromList [0/0, 0/0, -1, 0/0, 1]
15:23:45 <lambdabot>  False
15:23:48 <joneshf-laptop> > S.member (-1) $ S.fromList [0/0, 0/0, -1, 1]
15:23:49 <lambdabot>  True
15:23:58 <joneshf-laptop> so what's going on here?
15:24:29 <dwcook> joneshf-laptop, it's making an assumption about the Ord instance that turns out to be faulty
15:24:35 <Hafydd> Why are you surprised that an invalid data structure is giving inconsistent results?
15:24:57 <dwcook> < benmachine> whereas Data.Set and Data.Map both assume that exactly one of x > y, x == y, x < y are true
15:25:19 <joneshf-laptop> does set returnan ordered set?
15:25:20 <enthropy> you could have a slightly slower one that doesn't make that assumption probably
15:25:35 <dwcook> Yes, it would just use Eq and traverse a list
15:25:40 <enthropy> so if it hits a NaN in the tree, it'll take both branches
15:25:41 <dwcook> @type member
15:25:42 <lambdabot>     Not in scope: `member'
15:25:42 <lambdabot>     Perhaps you meant one of these:
15:25:43 <lambdabot>       `IM.member' (imported from Data.IntMap),
15:26:01 <dwcook> Though Float has an invalid Eq instance too, as I recall
15:26:13 <dwcook> > 0 / 0 == 0 / 0 -- simple example
15:26:15 <lambdabot>  False
15:26:48 <joneshf-laptop> Hafydd, what's invalid about the structure?
15:26:59 <dwcook> So it turns out your best bet is really find and isNaN
15:27:02 <Hafydd> joneshf-laptop: it contains values which violate the Ord axioms.
15:27:15 <dwcook> Or something like that
15:27:32 <joneshf-laptop> wait wait wait
15:27:40 <joneshf-laptop> why did ghci let this happen?
15:27:51 <Hafydd> ghci! How could you let this happen?!
15:27:55 <joneshf-laptop> ack, dammit brb
15:28:06 <dwcook> It's not GHC's fault at all, it's the fact that the language can't enforce variants of this sort
15:28:09 <dwcook> invariants*
15:29:53 <enthropy> dwcook: why?
15:30:24 <enthropy> http://hackage.haskell.org/package/containers-0.5.4.0/docs/src/Data-Set-Base.html#member could easily be changed to:
15:31:12 <enthropy>  go x (Bin _ y l r) | x == y = True | x > y = go x l | x < y = go x r | otherwise = go x l || go x r
15:31:15 <dwcook> I'm talking about on typeclasses
15:32:43 <enthropy> you could just blame the containers people who don't want to respect how floats work
15:32:48 <enthropy> because that'll slow things down
15:32:57 <matheus23> has anybody ever succeeded in compiling leksah?
15:33:08 <Fylwind> what is the analogous concept of "sigma types" in more traditional (e.g. set theoretic) mathematics?
15:33:31 <dwcook> or you could make intelligent decisions as a user of the language and not rely on illegal instances
15:34:24 <dwcook> Arguably you shouldn't *have* to do that, but the fact that they can write an efficient Map by ignoring that is often a reasonable tradeoff
15:34:41 <dwcook> It's not the worst thing people casually ignore when writing Haskell – How about _|_?
15:35:09 <byorgey> Fylwind: there isn't any specific analogous concept that I know of.  Usually the presence of a sigma type is indicated by words like "together with"
15:35:30 <byorgey> "a set together with a binary operation..."
15:35:39 <byorgey> or simply "which"
15:35:51 <byorgey> "a widget which is idempotent"
15:36:05 <byorgey> matheus23: yes
15:36:57 <matheus23> byorgey: wow. I'm failing. But it's too late to fix it right now, anyways, since I'm going to bed now.
15:37:06 <Fylwind> byorgey: i see, thanks
15:37:40 <byorgey> it's too bad matheus23 didn't ask a question with a more informative answer.
15:38:07 <byorgey> like, "can anyone take a look at this error log and give me suggestions on what might be wrong & how to fix it?" etc.
15:39:47 <td123> can anyone point me to some docs about ghc 7.6 removing type signatures for params in lambda expressions?
15:40:16 <enthropy> td123: you mean you have
15:40:24 <enthropy> \(x :: T) -> ...
15:40:29 <td123> when I try to add type signatures to the params, it says, illegal, perhaps you meant scoped type variables
15:40:29 <enthropy> and what to get rid of the :: T?
15:40:34 <Twey> Fylwind: In Currey–Howard it's often known as ‘exists’: Σx:A. P x ≈ ‘There exists x in A such that P x’
15:40:49 <Twey> Curry**
15:40:53 <td123> enthropy: ya
15:41:21 <td123> enthropy: I get away with adding a type sig. in the body that uses that param
15:41:33 <enthropy> you can write   \x -> (...) `const` (x :: T)
15:41:35 <Fylwind> Twey: yea, but sadly that interpretation doesn't work for what I'm trying to explain
15:41:35 <enthropy> yes
15:41:49 <Twey> Fylwind: What are you trying to explain?
15:41:59 <enthropy> @google ghc manual scoped type variables
15:42:01 <lambdabot> http://www.haskell.org/ghc/docs/6.12.1/html/users_guide/other-type-extensions.html
15:42:01 <lambdabot> Title: 7.8.�Other type system extensions
15:42:15 <Fylwind> Twey: a "Cartesian product" between two sets, one of which is parametrized by the other set
15:42:16 <dagle> Mmmm Curry.
15:42:48 <Fylwind> Twey: finite sets, in fact, nothing too scary
15:43:44 <Twey> Fylwind: That doesn't sound like a sigma… sigmas are when the second set is parameterized by an *element* of the first set
15:43:44 <mornfall> Fylwind: what is a parametrized set?
15:44:05 <Fylwind> it is parameterized by the element, i just wasn't clear
15:44:34 <Fylwind> parameterized set here means, the set varies depending on the element that is chosen from the first set
15:44:40 <Twey> Hm, what's the set-theoretic equivalent of a type family?
15:45:05 <dolio> You can have families of sets.
15:45:16 <dolio> And take their sum/disjoint union.
15:45:21 <dolio> That's sigma.
15:45:23 <Twey> Aha
15:45:29 <td123> enthropy: thanks, that const trick works well
15:45:45 <mornfall> Fylwind: a function from a set into a set of sets, then?
15:46:00 <Fylwind> mornfall: yeah
15:46:16 <td123> enthropy: I suppose the code snippet should be updated? http://hackage.haskell.org/package/esqueleto-1.3.4.5/docs/Database-Esqueleto.html#v:delete
15:46:20 <Fylwind> dolio: that makes sense
15:46:31 <mornfall> Fylwind: and you want to flatten that into a single set of tuples, right?
15:46:34 <Twey> Set theory is weird and unintuitive; people should just stick to type theory :þ
15:46:36 <td123> unless there is some kind of extension that could be enabled
15:47:47 <dolio> That's one reason why Σ is often called dependent sum.
15:47:52 <mornfall> i.e. { (x,y) | x \in A, y \in f(x) }
15:47:56 <Fylwind> mornfall: essentially yeah; I want a set with elements of the form (x, y) where x `elem` S and y `elem` T(x)
15:48:18 <mornfall> where f = T ;-)
15:48:24 <enthropy> td123: why is it a big deal to enable -XScopedTypeVariables?
15:48:33 * hackagebot diagrams-lib 1.0.1 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.0.1 (BrentYorgey)
15:48:35 * hackagebot diagrams-cairo 1.0.1 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.0.1 (BrentYorgey)
15:48:53 <dolio> Or why it's Σ in the first, place, even, since that's the letter used for summation.
15:49:33 <mornfall> dilinger: is the product type \Pi then? :)
15:49:39 <dolio> Yes.
15:49:44 <mornfall> hm
15:49:47 <mornfall> wrong tab obviously
15:49:52 <Twey> Heh
15:50:15 <enthropy> if anything it's clearer since you don't confuse people who think case / lambda is a polymorphic binding
15:50:20 <mornfall> dolio: the theory is suspect of making too much sense, IMHO, whatever it is :-)
15:50:36 <Twey> I always enable ScopedTypeVariables.  It's a nice extension.
15:51:19 <S11001001> succ Twey
15:51:41 <enthropy> td123: probably any compiler that supports esqueleto also supports ScopedTypeVariables
15:51:48 <Twey> (i.e. GHC :þ)
15:52:20 <mornfall> I don't think there are other compilers for GHC The Language (other than GHC The Compiler, that is).
15:52:51 <Twey> I gave up on standard Haskell a while ago — now I just use extensions that make sense and assume they'll make it into the spec at some point.
15:53:34 * hackagebot diagrams-postscript 1.0.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.0.1 (BrentYorgey)
15:53:35 <enthropy> http://www.cs.uu.nl/wiki/Ehc/UhcUserDocumentation#A_3.9_Lexically_scoped_type_variables
15:54:14 <mornfall> GHC The Eponymous :-) Maybe it's actually the second coming of perl. (Perl6 is obviously a -ing impostor.)
15:54:44 <mornfall> Twey: There is much need for Haskell 14 or whatever it should be called.
15:55:02 <mornfall> C++ got a whole lot of new life that way.
15:55:06 <joneshf-laptop> okay
15:55:29 <dwcook> Yeah, the next Haskell should make Monad imply Applicative, rename fmap to map and put it in the Prelude, and feature dependent typing!
15:55:44 <joneshf-laptop> so what's the deal with this NaN thing again?
15:55:46 <mornfall> dwcook: Well, I were right with you until the second comma.
15:55:50 <mornfall> I was, even.
15:55:53 <joneshf-laptop> :t [0/0]
15:55:54 <lambdabot> Fractional t => [t]
15:56:20 <dwcook> mornfall, :D
15:56:36 <dwcook> I tried to make it more facetious as it went on
15:56:42 <mornfall> dwcook: Some would say that a plausible numeric tower would be more useful.
15:57:07 <S11001001> dwcook: and map aliased to (.) :)
15:57:21 <dolio> Unfortunately someone would have to come up with a plausible numeric tower.
15:57:50 <mornfall> dolio: Implementation details. :P
15:58:25 <joneshf-laptop> i guess a better question is, where is the problem in `S.member (-1) $ S.fromList [0/0, 0/0, -1, 0/0, 1]`?
15:58:33 <joneshf-laptop> is it because NaN is Fractional
15:58:35 <dwcook> joneshf-laptop, in the Ord instance for Float
15:58:56 <dwcook> joneshf-laptop, alternatively, in the Set module for assuming Ord instances are a certain way
15:59:21 <dolio> > (0/0) <= (0/0)
15:59:22 <lambdabot>  False
15:59:27 <mornfall> Data.Set only makes sense for a linear ordering.
15:59:32 <dolio> > (0/0) >= (0/0)
15:59:34 <lambdabot>  False
16:00:08 <mornfall> You'd have to newtype Float and make a different Ord instance.
16:00:10 <dolio> > compare (0/0) (0/0)
16:00:12 <lambdabot>  GT
16:00:17 <dhrosa> wat
16:00:26 <S11001001> dolio: fabulous
16:00:28 <mornfall> dolio: that's kindof arbitrary (the GT)
16:00:38 <dolio> That's a default definition.
16:00:40 <mornfall> but I guess you can't say bottom :-)
16:00:42 <S11001001> @ty (>=)
16:00:43 <lambdabot> Ord a => a -> a -> Bool
16:00:43 <colDrMcBeardman> joneshf-laptop, ceil nan is not right
16:00:47 <colDrMcBeardman> > ceil nnan
16:00:48 <lambdabot>  Not in scope: `ceil'Not in scope: `nnan'
16:00:48 <lambdabot>  Perhaps you meant `nan' (line 143)
16:00:52 <colDrMcBeardman> > ceil nan
16:00:53 <lambdabot>  Not in scope: `ceil'
16:00:57 <dwcook> mornfall, you can't tell me what to do! :P
16:00:59 <colDrMcBeardman> > floor nan
16:01:00 <flebron> Hi. If I have a lazy ByteString, what's the easiest way to split it into 1MB chunks?
16:01:01 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
16:01:05 <colDrMcBeardman> there, dammit.
16:01:28 <colDrMcBeardman> should be either nan or an exception
16:01:31 <mornfall> dwcook: and did I?
16:01:36 <dolio> > (compare (0/0) (-1), compare (-1) (0/0))
16:01:37 <lambdabot>  (GT,GT)
16:01:42 <dwcook> mornfall, I was replying to < mornfall> but I guess you can't say bottom :-)
16:02:03 <dolio> It's not even a non-linear ordering. It's not an ordering.
16:02:06 <mornfall> dwcook: okey okey
16:02:23 <mornfall> dolio: well, as long as you stick to relational operators it gives False everywhere no?
16:02:30 <mornfall> dolio: compare is bustef ofcourse
16:02:40 <mornfall> busted, too
16:02:42 <dolio> > (0/0) /= (0/0)
16:02:43 <lambdabot>  True
16:02:45 * flebron is thinking it'll be something like iterate splitAt :p
16:02:54 <mornfall> dolio: well, that at least makes sense :)
16:03:10 <mornfall> (given /= should give the opposite of ==)
16:03:10 <colDrMcBeardman> mornfall, i think the relational operators are correct all around
16:03:12 <dolio> Does it? I'm not sure that's IEEE correct.
16:03:24 <DarkFox> Does hackage require email addresses? If so; could someone who can access them, report to BrandonWiley, that his Dust-crypto doesn't compile due to lacking header files to go with his c files.
16:03:35 * hackagebot diagrams-svg 1.0.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.0.1 (BrentYorgey)
16:04:17 <colDrMcBeardman> dolio, x /= x supposed to be false for x= nan?
16:04:19 <DarkFox> Nvm; found his twitter instead :P
16:04:24 <mornfall> dolio: dunno, but LLVM only has comparisons where (either nan => true) or (either nan => false)
16:04:29 <dolio> colDrMcBeardman: Wouldn't surprise me.
16:04:32 <mornfall> dolio: where => is implication
16:04:44 <dhrosa> > (0/0) == (0/0)
16:04:45 <lambdabot>  False
16:05:12 <colDrMcBeardman> it would be nice if they would publish a free copy of 754 to read...
16:05:15 <dwcook> > [0 / 0 == 0 / 0, 0 / 0 /= 0 / 0]
16:05:17 <lambdabot>  [False,True]
16:05:18 <mornfall> dolio: so you get to choose which way it fails to make an ordering and you have an interesting choice of combinations
16:05:24 <dwcook> Well at least it's *somewhat* consistent
16:05:24 <dolio> colDrMcBeardman: "All comparisons involving NaN are false" seems like something they'd do, and "all comparisons involving NaN are false except not-equal" doesn't.
16:06:12 <mornfall> dolio: yes, what GHC does here is not IEEE-correct in this sense
16:06:27 <mornfall> dolio: but GHC only provides one Ord instance anyway
16:06:32 <mornfall> +only
16:06:49 <dwcook> The correct thing, apparently, is to check all your strange Floats with isNaN before assuming that they behave sanely
16:07:00 <dwcook> But wait! There's infinity too!
16:07:07 <mornfall> dolio: it's called ORD(ered) and UNO(rdered)
16:07:14 <colDrMcBeardman> x != x returns true, according to an old draft.
16:07:21 <dwcook> Is isFinite a thing?
16:07:23 <dwcook> @type isFinite
16:07:24 <lambdabot> Not in scope: `isFinite'
16:07:37 <dolio> One could argue that putting floating point values in a map/set is a bad idea anyway, for reasons besides NaN.
16:07:54 <mornfall> dolio: depends where they came from, I guess
16:07:56 <dwcook> > maxBound :: Float
16:07:58 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Float)
16:07:58 <lambdabot>    arising from a use of `GHC.Enum.maxBound'
16:07:58 <lambdabot>  Possible fix:
16:07:58 <lambdabot>    add an instance declaration for (GHC.Enum.Bounded GHC.Types.Float)
16:08:12 <colDrMcBeardman> it also says x != y is equal to NOT (x = y)
16:08:14 <mornfall> dolio: you could argue doing anything with floating point values is a bad idea
16:08:21 <colDrMcBeardman> so i guess that's not broken
16:08:26 <dolio> colDrMcBeardman: I'm surprised.
16:08:45 <dolio> mornfall: Worse idea than some, then. :)
16:08:49 <mornfall> colDrMcBeardman: does it say how that's actually to be implemented?
16:08:56 <dwcook> Let's just use Rational for everything
16:09:02 <maxiepoo> oh ok so it's not ReaderT r (WriterT r m) ~= StateT m
16:09:16 <mornfall> dwcook: yeah, circles are for noobs
16:09:46 <colDrMcBeardman> dwcook, actually, the constructionist argument is exactly that,
16:09:48 <maxiepoo> it's (Compose ((->) r) (r,)) ~= State r
16:09:55 <dwcook> mornfall, floating-point is already an approximation
16:10:10 <colDrMcBeardman> nonterminating numbers and such aren't valid mathemitcal constructs
16:10:26 <maxiepoo> so the state monad is the monad arising from the adjunction that represents currying
16:10:28 <colDrMcBeardman> mornfall, yeah
16:10:39 <dolio> You can represent constructive reals.
16:10:56 <dolio> They're not going to be super fast, though.
16:10:59 <mornfall> dwcook: cf. abstrusegoose.com/549
16:11:16 <enthropy> http://www.haskell.org/pipermail/libraries/2013-April/019677.html for other reasons Double is not following the standard
16:11:35 <mornfall> dolio: more like super-slow
16:14:40 <colDrMcBeardman> dolio, i'm not sure exactly how the argument goes, but i think some of it rests on the fact that things that don't terminate can't be computed.
16:14:41 <Twey> dwcook: I think all those things are going to happen :þ  (though the last one may take some time)
16:15:26 <Twey> mornfall: Well, the changes likely to happen to Haskell in the next version are perhaps less profound, but yes
16:15:55 <dwcook> Twey, I'm having trouble imagining a language that's fundamentally Haskell but that has dependent typing
16:16:03 <mornfall> dolio: also, what do you mean with constructive? pi and e are transcendental... and you are *** without those
16:16:04 <Twey> dwcook: Have you seen Agda?
16:16:06 <dwcook> Twey, yes
16:16:23 <Twey> dwcook: How about Idris?  :þ
16:16:25 <dwcook> In other words, who's to say it should still be called Haskell at that point?
16:16:28 <dwcook> Yep
16:16:31 <Twey> Mm, yes
16:16:45 <mornfall> Agda and idris are both eponymous. That's dangerous.
16:17:00 <Twey> But Haskell is pretty much there already
16:17:07 <Twey> (well, GHC Haskell)
16:17:14 <Twey> It just has terrible syntax
16:17:19 <mornfall> And tons of cruft.
16:17:22 <Twey> Right
16:17:53 <dwcook> I won't be satisfied till _|_ has been eliminated :P
16:18:00 <mornfall> Also, agda and idris seem to be in a way very opposite languages.
16:18:01 <Twey> People used to be very against Haskell getting dependent typing, but as it's naturally evolved more in that direction it seems like the resistance has decreased
16:18:48 <Twey> And now the main difference between Haskell and a hypothetical Haskelly (inconsistent) dependently-typed language is the syntax :þ
16:18:54 <dwcook> Although, isn't Agda's totality the reason it can't infer types?
16:19:04 <dwcook> of functions
16:19:15 <mornfall> dwcook: No, it's the dependent types.
16:19:19 <Twey> dwcook: No, it's the lack of principle types
16:19:28 <dwcook> Twey, what is a principle type?
16:19:40 <mornfall> dwcook: Totality can be had much cheaper.
16:19:51 <Twey> A principle type is the ‘most general’ type you can give a term — it's what Haskell infers when you give it a term
16:20:06 <Twey> When you introduce type-level functions you throw that out
16:20:29 <mornfall> Twey: Which Haskell did already.
16:20:34 <mornfall> Well, GHC.
16:20:41 <Twey> Right, with the right extensions
16:20:43 <dwcook> Doesn't Haskell have type-level functions? It has type constructors and synonyms
16:21:02 <mornfall> dwcook: That's not a problem. Associated type synonyms are.
16:21:12 <Twey> dwcook: No, those aren't full functions, but things like type families can break inference
16:21:15 <hpc> haskell has a lot of things that are almost type-level functions
16:21:19 <mornfall> dwcook: Which are possibly non-injective type functions.
16:22:10 <mornfall> Either way, up to typeclasses, you get a nice clean algorithm for inference. When you want more, you blunder into the realm of heuristics.
16:22:15 <dwcook> So the problem, then, is *general* type-level functions
16:22:29 <Twey> dwcook: Specifically binders, I think
16:22:30 <mornfall> dwcook: The useful ones, yes.
16:22:35 <hpc> yep; general type-level functions are where you get into undecidable compilation
16:22:47 <hpc> if you let them have the full power of turing-completeness, ofc
16:23:06 <hpc> finding ways to restrict them to something provably terminating is where complexity seeps in
16:23:12 <mornfall> hpc: there are many turing-incomplete undecidable problems :)
16:23:14 <Twey> Right, if your type-checking involves evaluating possibly non-terminating functions then your type-checking is possibly non-terminating
16:23:18 <Twey> (obviously)
16:23:37 * hackagebot linux-inotify 0.1.0.0 - Thinner binding to the Linux Kernel's inotify interface  http://hackage.haskell.org/package/linux-inotify-0.1.0.0 (LeonSmith)
16:23:41 <mornfall> Twey: what I never understood is the obsession with terminating typecheckers...
16:24:07 <dwcook> Ah, so the language, instead of risking non-terminating compilation, makes you provide a proof that the type computation terminates?
16:24:10 <Twey> mornfall: Haha
16:24:22 <Twey> dwcook: For a very trivial notion of ‘proof’, yes
16:24:27 <hpc> mornfall: non-terminating compilation causes trouble with things like build servers
16:24:50 <mornfall> hpc: unit tests already cause all the trouble you could ever ask for in that department
16:24:57 <hpc> (which may do nice things like block commits until your code compiles, or block commits until it passes tests)
16:25:01 <Twey> True, you can always time-out
16:25:03 <mornfall> hpc: non-terminating compilers don't chink the armor any further
16:25:13 <hpc> yeah, but it's one more irritation
16:25:20 <dolio> Principal types, by the way.
16:25:28 <dolio> Agda's types are principled. :)
16:25:29 <Twey> dolio: Really?
16:25:33 <Twey> Oh, right
16:25:35 <hpc> and large projects tend to take a long time to compile, with less of a clear measure of "progress"
16:25:35 <Twey> Yes, of course
16:25:46 <mornfall> hpc: dunno if it was me, I'd probably not sink millions of research dollars into an "irritation" ;-)
16:25:50 <Twey> My spelling is terrible today; I wrote ‘Currey–Howard’ earlier
16:25:55 <hpc> whereas unit tests you can generally say "each test takes less than 5 seconds" and as many tests as you like
16:26:02 <ion> Currey-Howardey
16:26:09 <dolio> Be more discrete in the future.
16:26:27 <colDrMcBeardman> or discreet?
16:26:35 <Twey> dolio: I prefer my continuity
16:26:59 <mornfall> Twey: is there an uncountable set smaller than you?
16:27:09 <colDrMcBeardman> continuity is maddening.
16:27:15 <colDrMcBeardman> just ask georg.
16:27:18 <hpc> incidentally, undecidable instances admits non-terminating compilation
16:27:20 <Twey> mornfall: I think I'm a function, so I'm going to say yes
16:27:21 <dwcook> Discrete is boring, you only get identity arrows
16:27:35 <Twey> hpc: And that's why we avoid it
16:27:44 <hpc> yep
16:27:47 <jmcarthur> continuous is much better
16:28:00 <hpc> even though it takes a lot of effort to actually achieve non-terminating compilation
16:28:01 <mornfall> colDrMcBeardman: Cantor?
16:28:06 <colDrMcBeardman> mornfall, bingo
16:28:36 <Twey> colDrMcBeardman: I thought that was non-provability.
16:28:40 <mornfall> hpc: not everyone avoids it
16:28:45 <Twey> Nearly drove me crazy, once
16:28:49 <geekosaur> (have we recant(or)ed yet?)
16:28:52 <mornfall> hpc: also, if it terminates once, it will terminate again
16:29:07 <jmcarthur> it will terminate... forever!
16:29:26 <hpc> that gets trickier once you get into larger projects
16:29:39 <Twey> hpc: That said, I feel like our current interest in termination is probably going to terminate at some point; there are a lot of interesting computational systems that don't terminate, and some benefit to making even ones that do approach their answers as a continuous series of approximations
16:29:44 <hpc> where compilation is done by a script with lots of system-specific variables
16:29:51 <mornfall> hpc: g++ 4.8 has a funny bug where it spends about 8 hours deciphering a recursive decltype use, which clang unravels in less than 20 seconds
16:30:03 <hpc> what succeeds on this box might fail to terminate on that one
16:30:10 <Twey> mornfall: How does it manage that?
16:30:13 <mornfall> hpc: of course
16:30:14 <jmcarthur> Twey: i think the future is to just treat nontermination as an effect and provide a way to do it, but isolated, similarly to IO
16:30:16 <mornfall> Twey: I wish I knew
16:30:28 <Twey> jmcarthur: That's a hack (and so is IO)
16:30:33 <jmcarthur> i agree
16:30:37 <jmcarthur> but with benefits
16:30:47 <mornfall> Twey: but we found a workaround that's good enough
16:30:52 <colDrMcBeardman> Twey, i think just his work in general drove him into a serious depression
16:30:53 <mornfall> Twey: it only takes 5 minutes now
16:30:54 <Twey> Ultimately we want to understand both these things, not just lock them away from the bits of the code we *do* understand
16:31:03 <jmcarthur> total agreement
16:31:09 <mornfall> hpc: yes of course
16:31:14 <jmcarthur> i mean the near future, not forever
16:31:19 <Twey> Ah, right
16:31:20 <mornfall> hpc: it already happens in all practical languages anyway, from time to time
16:31:20 <colDrMcBeardman> we just need to put nonterminating stuff in a big burrito monad.
16:31:21 <hpc> Twey: locking it away is the first part of understanding, imo
16:31:23 <Twey> Yeah, Agda already does that
16:31:28 <Twey> hpc: Absolutely
16:32:00 <dagle> I remember the bug where gcc tried to staticly canonicalize paths.
16:32:16 <hpc> mornfall: for a good time, look up that one perl program that proves the grammar ambiguous
16:32:21 <dwcook> Twey, are you saying that, if we were smarter, you would prefer we all use a procedural language?
16:32:28 <jmcarthur> step one is to recognize the problem. if fixing the problem is too hard to do immediately then limiting its damage is a second best :)
16:32:41 <hpc> it undecidably sets a prototype to either () or ($), changing a string from parsing as a regex to division
16:32:52 <Twey> dwcook: No, probably something based on π-calculus
16:33:18 <jmcarthur> dwcook: i think it is totally conceivable that if we were generally much smarter in the right ways then perhaps we would be much less concerned with simple computational models
16:33:18 <Twey> Which feels a lot to me like a generalization of the λ-calculus
16:33:45 <mornfall> jmcarthur: fixing the problem is well proven to be impossible
16:33:46 <frxx> Twey why is IO is a hack?
16:33:51 <mornfall> jmcarthur: so the best you can do is limit damage
16:33:53 <hpc> jmcarthur: if we were smarter we would be highly paid php consultants ;)
16:33:56 <dwcook> Twey, I'm unfamiliar with that – How do side effects fit in?
16:33:57 <Twey> dwcook: The λ-calculus is already a procedural language, of sorts :þ
16:34:07 <jmcarthur> mornfall: oh i doubt, without proof, that it's impossible
16:34:29 <mornfall> jmcarthur: depends on what you mean, I guess
16:34:31 <jmcarthur> Twey: oh?
16:34:37 <Twey> dwcook: The π-calculus doesn't have functions, it has communication channels.  So side effects are trivially part of the calculus (but also you have non-determinism in some cases)
16:34:38 <hpc> dwcook: π-calc is λ-calc with concurrency
16:35:18 <Twey> π-calculus is similar to a λ-calculus where a) there's no single return from functions and b) calling functions don't have to wait to get an answer back
16:35:36 <dwcook> Neat.
16:35:38 <Twey> … though it's quite a crude analogy
16:36:11 <jmcarthur> i would not say π-calculus is λ-calculus with concurrency
16:36:26 <Twey> frxx: IO is a hack because it doesn't actually bring us any closer to understanding what's happening in the impure program, it just shuts it away from the pure program (admittedly in a rather nice way)
16:36:28 <jmcarthur> i would say the π-calculus is basically nothing *but* concurrency
16:36:28 <dwcook> Well, it sparked my interest in reading up on it, so it served a purpose of sorts
16:36:44 <mornfall> pi-calculus is a process algebra :)
16:38:10 <Twey> Yes, it's more accurate to say that π-calculus is concurrency with a λ-calculus :þ (you can embed a λ-calculus by passing in a ‘return’ channel and waiting on it after starting the process)
16:38:17 <mornfall> I love the WP article, with the "!P models a network service or a (goto) label" ...
16:38:28 <Twey> Heh
16:38:40 <Iceland_jack> Twey: I tried to split it up using Capabilities :)
16:38:45 <Iceland_jack> @hackage Capabilities
16:38:46 <lambdabot> http://hackage.haskell.org/package/Capabilities
16:38:54 <mornfall> Network service is such an absurdly specific thing...
16:39:07 <Iceland_jack> Didn't get far
16:39:16 <Twey> Iceland_jack: *nod* I like capabilities, but that's not really what I was talking about
16:39:27 <hpc> Twey: an easy way out of analysing IO would be hoare logic
16:39:39 <Iceland_jack> I know, effectfulness is just plain difficult to model
16:39:53 <mornfall> hpc: I'm wondering what are the hard ways for you.
16:39:58 <Twey> hpc: Hoare logic is bad at concurrency
16:40:04 <Twey> Haha
16:40:26 <hpc> mornfall: the hard way would be to find something that actually describes all of IO ;)
16:40:31 <mornfall> You just tossed 20 years of solid research into software correctness into the wind. ;-)
16:40:33 <Twey> There's a neat paper on analysing imperative programs with game semantics
16:40:43 <mornfall> Make that 30 I guess.
16:40:47 <Twey> … which I don't understand yet
16:40:58 <mornfall> Twey: How'd you know it's neat?
16:41:06 <mornfall> Could be bogus just as well...
16:41:34 <Twey> mornfall: It could, but it's by a very smart guy I trust and it's been peer-reviewed — the academic process in a nutshell
16:42:26 <shachaf> i hear edwardk is a big fan of hoare logic
16:42:31 <hpc> in any event, i am fine with tying the semantics of IO to the machine architecture
16:42:34 <Twey> http://arxiv.org/abs/1307.2004
16:42:48 <mornfall> hpc: good, that'll at least make it possible to run the programs
16:42:52 <Twey> Haha
16:43:02 <hpc> which would lead to a ludicrously complex formal specification, but it at least leaves us with something to go on
16:43:07 <mornfall> which you could treat either as a bug or as a feature, your call :)
16:43:11 <dwcook> You could make a Haskell virtual machine that runs Haskell byte code and have IO reason about that :P
16:43:27 <hpc> ooh, like runghc
16:43:31 <mornfall> dwcook: which won't help much, because the virtual machine needs to be implemented...
16:43:44 <mornfall> dwcook: if you want to run programs
16:43:58 <mornfall> but you could go Dijkstra and not demand your language to be executable
16:44:06 <dwcook> mornfall, yeah, but if you did something like that then the idea would be to normalize differences between OSes, practically by writing a new one
16:44:07 <hpc> mornfall: there's a lot more you can do to constrain what needs to be specified
16:44:12 <mornfall> afterall, we have lived a long time with non-executable languages
16:44:22 <hpc> mornfall: and then leave a teeny bit of ffi that gets specified as "here be dragons"
16:44:36 <dagle> You could write hardware that runs haskell and verify that? And the hardware is also written in haskell.
16:44:57 <hpc> writing hardware in haskell?
16:45:02 <dagle> Yes
16:45:07 * hpc writes a toilet with php
16:45:07 <dagle> Lava
16:45:08 <dwcook> And make sure all of reality is running Haskell, too
16:45:15 <mornfall> hpc: dragons don't seem to be confounded by the percieved amount of space you leave them
16:45:31 <mornfall> hpc: also, are very proficient at expanding
16:46:06 <dagle> hpc: http://raintown.org/lava/ lava is a haskell lib for generating vhdl.
16:46:32 <mornfall> dagle: haskell execution is very silicone-unfriendly
16:46:50 <hpc> mornfall: well, there's always going to be things that have no semantics, but it doesn't necessarily infect the whole language
16:47:02 <dagle> mornfall: Maybe so, they still mananged to produce a haskell-machine
16:47:10 <dagle> That wasn't to shabby.
16:47:10 <mornfall> hpc: you already have that with monads (sans unsafePerform)
16:47:22 <hpc> for instance, unsafeCoerce to ByteString gives an incredible amount of exposure of underlying details
16:47:27 <hpc> but unsafeCoerce has no semantics
16:47:38 <flebron> If I import Crypto.Hash.SHA256, I see that hash :: bytestring-0.10.0.2:Data.ByteString.Internal.ByteString -> ... . Is there a way to make it work with newer bytestring versions?
16:47:39 <hpc> so we can still reason about our pure code in its absence
16:47:42 <mornfall> of course, unsafeCoerce too
16:48:09 <hpc> it's extending the edge, as it were
16:48:12 <mornfall> hpc: what I percieve as a problem is that anyone can stick those things in a library and you will never know
16:48:19 <hpc> and taking things out of the has-no-semantics box
16:48:25 <Twey> hpc: Better, unsafeCoerce *from* ByteString gives you assembly language :þ
16:48:33 <mornfall> hpc: becoming possibly very infectuous
16:48:42 <hpc> mornfall: you would know from the semantics of the library
16:48:51 <hpc> (if the library doesn't follow the semantics, of course that's a bug)
16:49:00 <mornfall> hpc: relying on libraries giving semantics is dodgy at best
16:49:28 <hpc> there's only so much you can do though
16:49:39 <hpc> sort xs = [minimum xs] -- le gasp!
16:50:10 <jmcarthur> i think the characterization of IO as just some extensible free monad is fine. the problem, to me, isn't defining what *IO* is, but coming up with something better/simpler and more rigorous than IO
16:50:25 <thirsteh> if I have what is essentially a "const", e.g. top-level myGlobal :: Text; myGlobal = foo "bar", is myGlobal evaluated at compile-time, or does it start out as a thunk (with e.g. GHC -O2)?
16:50:32 <flebron> OK, it seems I have two different bytestring versions installed. :s
16:50:42 <hpc> jmcarthur: or just pulling parts out of IO, like STM
16:50:43 <mornfall> hpc: sure, but those things are easier to defend from
16:51:00 <mornfall> hpc: or ST for that matter :)
16:51:06 <jmcarthur> hpc: i consider STM to be a little more than just pulling parts out, since that alone would not result in transations
16:51:13 <hpc> mornfall: it's just as easy to defend against unsafeCoerce - just don't use it ;)
16:51:27 <jmcarthur> ST is perhaps a better example, yes
16:51:41 <flebron> How can I ... fix it? Perhaps by removing the old bytestring version? Can that break things if I have a newer one installed?
16:51:45 <mornfall> hpc: of course, for the parts of the code in your control
16:51:47 <flebron> In general, is there a way to "update" a package?
16:51:54 <kristof> STM is locks for free
16:51:56 <mornfall> hpc: but you don't want to start with the bare language every time
16:52:09 <mornfall> kristof: only it's neither locks nor for free
16:52:29 <hpc> STM is expensive open doorways
16:52:30 <jmcarthur> ST is also not all that hard to define the semantics for
16:52:35 <jmcarthur> denotationally
16:52:38 <jmcarthur> which is awesome
16:52:50 <mornfall> jmcarthur: the problem with ST? the syntax stinks
16:53:07 <jmcarthur> mornfall: the syntax for many effects stinks :\
16:53:20 <hpc> also you can't mix effects into ST
16:53:32 <jmcarthur> you can layer them on top at least
16:53:35 <hpc> no inter-thread communication, for instance
16:53:48 <jmcarthur> i am also not totally convinced that STT makes no sense
16:53:49 <mornfall> hpc: threads are a huge can of worms too
16:53:59 * flebron wonders if he should somehow twist his actual question into talking about STM in some way...
16:54:20 <jmcarthur> flebron: perhaps nobody knows the answer
16:54:30 <mornfall> jmcarthur: what's STT?
16:54:32 <hpc> jmcarthur: i can kind of see how it would work
16:54:36 <hpc> mornfall: ST transformer
16:54:37 <flebron> Nobody has ever gotten two package versions installed of any package? O.o
16:54:45 <hpc> STT s m a
16:54:45 <jmcarthur> flebron: it's not even an invalid state
16:54:57 <hpc> runSTT :: (forall s. STT s m a) -> m a
16:54:58 <geekosaur> flebron: it can be done but it is often painful and requires careful management
16:55:10 <mornfall> flebron: you need to rebuild the dependency in the middle
16:55:12 <kristof> Heh, if you all have ever read the recent MSDN (I say recent but mean within the past 3 years) you'll notice that all the bumps they hit in the road usually have something to do with mutable code (except for putting IO in STM, which Haskell simply flat out rejects)
16:55:17 <flebron> I just wanted to update my version of bytestring, and I ended up with two of them :(
16:55:19 <geekosaur> (actually it's trivial to get multiple versions installed. it's *after* you do it that the pain starts...)
16:55:27 <geekosaur> bytestring is a bootlib
16:55:33 <jmcarthur> kristof: likewise, many of our bumps in haskell come from _|_
16:55:37 <flebron> Which means...?
16:55:49 <geekosaur> bootlib = the only reliable way to upgrade it is to upgrade ghc
16:55:54 <kristof> wow, there are so many things wrong with what I just said gramatically. *Recent MSDN blog post *mutable vars
16:55:54 <mornfall> hpc: ah, obviously
16:55:58 <flebron> Damn.
16:56:00 <kristof> jmcarthur: I don't know if that's a "likewise" :P
16:56:11 <jmcarthur> kristof: it is. nontermination can be treated as an effect
16:56:29 <jmcarthur> kristof: in this sense, haskell is not actually pure!
16:56:31 <kristof> mornfall: Maybe not for free but STM is, at its core, implemented by locks. Unless Haskell's is implemented differently?
16:56:37 <flebron> So I should do that through my package manager, then? (In Gentoo, "emerge ghc"?)
16:56:50 <jmcarthur> flebron: avoid the package manager almost always
16:56:53 <mornfall> jmcarthur: space leaks can be considered an effect... in that sense, haskell is unlikely to ever be "pure"
16:56:58 <hpc> jmcarthur: i would argue that early termination is the effect and non-termination is semantically just fine
16:57:06 <flebron> So how should I update my GHC without my package manager?
16:57:08 <kristof> mornfall: There's a difference between semantics and implementation details
16:57:19 <hpc> (unless a slightly warmer cpu counts as an effect)
16:57:26 <jmcarthur> mornfall: many things can be considered effects, but not all of them are always worth isolating
16:57:27 <mornfall> kristof: it's implemented by locks because that's the only primitive you get from the silicone
16:57:30 * flebron really likes haskell, but the package manager issues are really a turnoff...
16:57:34 <kristof> hpc: the second law of thermodynamics is an effect, Haskell is impure!!
16:57:36 <dwcook> We just need to solve the problems of computations taking time and memory being finite
16:57:38 <jmcarthur> mornfall: nontermination often is worth isolating
16:57:42 <hpc> (or thread timing from long computations)
16:57:51 <jmcarthur> hpc: that is an interesting point of view
16:57:57 <Twey> flebron: Portage is fine
16:58:06 <geekosaur> flebron: build it yourself from source tarball. although I am not convinced that you must avoid ebuilds *if* they have the version(s) you need
16:58:20 <dwcook> Once we figure out how to make closed time loops, both of those problems should be solved
16:58:24 <Twey> flebron: If you use the gentoo-haskell overlay we also have some scripts that help you to avoid Cabal hell.
16:58:30 <mornfall> jmcarthur: I'm not arguing otherwise.
16:58:36 <Twey> Though sandboxes are so nice that you might want to use them instead.
16:58:38 <geekosaur> people vary on this a lot, but I think trusting the system package manager for ghc and often the platform is generally a good idea
16:58:41 <mornfall> jmcarthur: just that "purity" in itself is not a very good argument
16:58:46 <geekosaur> (unforutnately then you get exceptions. like ubuntu, sigh)
16:59:04 <hpc> geekosaur: my solution is to just blow away my entire box every so often :P
16:59:06 <jmcarthur> mornfall: sure. i have had enough meaningless debates over what "purity" means to understand that it is nearly meaningless
16:59:09 <flebron> I think I'll just try to uninstall the newer version of bytestring, and live without a Builder until I upgrade my OS :s
16:59:21 <geekosaur> hpc: that's pretty much my opinion of linux upgrades anyway...
16:59:22 <Twey> hpc: That's Gentoo's solution, too ;)
16:59:25 <jmcarthur> redundant use of "meaningless" was unintentional
16:59:46 <hpc> Twey: my understanding was that's the arch way, and gentoo just kind of makes you compile things forever
16:59:49 <mornfall> hpc: get nix ;-)
16:59:51 <flebron> (And, as in the xkcd comic, my trying to uninstall the accidentally installed newer version of bytestring will likely result in trashing my whole system...)
17:00:00 <hpc> anyway, another way to upgrade is to get a new ghc
17:00:01 <Twey> We have a script called ‘haskell-updater’ that looks for broken things and rebuilds them all from scratch
17:00:05 <flebron> (Then the sharks will come...)
17:00:15 <geekosaur> ghc-pkg unregister shluld be safe if you haven't installed anything using it yet
17:00:20 <hpc> which has a different ghc-pkg database and etc etc
17:00:22 <jmcarthur> degrees of purity are best expressed as "what effects are controlled and what effects are uncontrolled"
17:00:22 <geekosaur> or if you have, unregister those too
17:00:44 <hpc> it's also easier to do a controlled reset of packages if you never use global install
17:00:53 <flebron> geekosaur: Damn... that kind of sucks, the package I installed had a ton of dependencies, _after_ installing bytestring.
17:01:34 * flebron just tends to dislike all his interactions with cabal :s
17:01:51 <mornfall> it's cabal... system-level yuck
17:02:06 <hpc> appropriately named for the dark magic contained within
17:02:08 <geekosaur> rm -rf ~/.ghc ~/.cabal # won't damage the system, will unregister your user-installed packages
17:02:34 <geekosaur> but doublecheck for typoes before hitting Enter :p
17:02:36 <flebron> So after that I can reinstall all packages from scratch?
17:02:41 <flebron> (I like that notion, by the way.)
17:02:45 <geekosaur> system packages will still be there
17:02:53 <geekosaur> overriding those is still a very bad idea
17:03:05 <flebron> system = bootlib?
17:03:05 <hpc> rm -rf / user/src/mylibrary
17:03:12 <oakwhiz> I seem to be solving some of my cabal issues by testing stuff in virtual machines
17:03:30 <mornfall> hpc: that's a very good command, with that space in the middle
17:03:32 <geekosaur> flebron, bootlibs are the ones that come with ghc. there is also the haskell platform, which is often also installed via system packages
17:03:41 <geekosaur> and is similarly a bad idea to user-upgrade
17:03:47 <flebron> So "system" packages are the "bootlib" packages? No?
17:03:53 <mornfall> hpc: don't forget to stick sudo in front of it
17:03:58 <geekosaur> siiiigh
17:04:05 <geekosaur> [27 01:01] <geekosaur> flebron, bootlibs are the ones that come with ghc. there is also the haskell platform, which is often also installed via system packages
17:04:21 <geekosaur> is some part of that confusing?
17:04:30 <flebron> So I understand the definition of a bootlib package, but you also used the term "system packages", which is as of yet undefined to me.
17:04:36 <geekosaur> anyway: "system" packages are those listed in the system ghc configuration
17:04:55 <flebron> OK.
17:05:00 <mornfall> flebron: whatever your distro thought appropriate dumping in /usr
17:05:00 <geekosaur> if you "ghc-pkg list", you'll notice it has two parts. the first part is the system registry, the second the user registry
17:05:15 <jmcarthur> flebron: read http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml and http://www.vex.net/~trebla/haskell/sicp.xhtml
17:05:16 <geekosaur> bootlibs are a subset of system packages, the ones that come with ghc itself
17:05:19 <flebron> Ah, OK, so system just refers to how wide they affect.
17:05:31 <flebron> OK, got it.
17:05:44 <mornfall> (also, nixos :P)
17:05:47 <jmcarthur> flebron: cabal has some problems, but they are manageable
17:07:30 <dhrosa> is the main use of the Reader monad to define functions and combinations of functions without having to repeat parameter names everywhere?
17:07:43 <maxiepoo> dhrosa, that's definitely what I use it for
17:07:45 <mornfall> dhrosa: after a fashion
17:07:55 <hpc> dhrosa: that's in fact the very definition of Reader ;)
17:08:07 <maxiepoo> any time I have a bunch of functions that have a parameter that they only use so they can pass to other functions
17:08:15 <maxiepoo> reader cleans things up a lot
17:08:19 <dhrosa> is it exactly equal to the Monad instance of (r->)?
17:08:21 <silasm> dhrosa: it's also just generally nice when you have, say, a binary operator /given/ some static data
17:08:30 <Aetherspawn> nominolo_: so does lambdachine execute the code using an interpreter while the JIT compiles it?
17:08:43 <dhrosa> because the monad instance for r-> seems to do the same thing?
17:08:48 <jmcarthur> dhrosa: yes
17:08:49 <maxiepoo> it is
17:09:04 <jmcarthur> dhrosa: some people find the newtype easier to reason about
17:09:46 <maxiepoo> but I usually have a monad transformer stack with ReaderT r in it
17:09:53 <mornfall> what I don't like about reader is that it has a tendency to introduce superfluous coupling
17:10:22 <mornfall> (but that's a problem with monads in general, kind of)
17:11:10 <jmcarthur> i think it's more a problem with our newtype wrapping idioms
17:11:37 <jmcarthur> if it was more convenient to add and drop those wrappers without being super verbose we would tend to use them more sparingly
17:11:54 <jmcarthur> but as it is, it is easier to just leave many things all wrapped up
17:11:59 <mornfall> jmcarthur: the wrappers serve an important safety role, though
17:12:03 <jmcarthur> yes
17:12:12 <jmcarthur> it's not obvious how to get around it
17:12:30 <jmcarthur> the injectivity is necessary for type classes
17:12:35 <mornfall> dependent types!
17:12:50 <jmcarthur> always
17:12:54 <mornfall> obviously
17:13:09 <dhrosa> the "runReader" function confused me initially
17:13:38 <dhrosa> the name of it
17:13:48 <mornfall> that's an idiom too
17:14:07 <mornfall> you get a runMonad for all sensible monads ;-)
17:15:03 <Twey> And some non-sensible ones :þ
17:15:19 <joelteon> :þ
17:15:22 <mornfall> Twey: I didn't say anything about those. :)
17:15:26 <dwcook> runVoidT
17:16:16 <dwcook> Aw, I was hoping someone had written a VoidT
17:16:49 <mornfall> dwcook: what would it do?
17:17:15 <dwcook> I'm not sure
17:17:21 <mornfall> dwcook: throw away the underlying monad?
17:17:28 <jmcarthur> data VoidT m a
17:17:31 <jmcarthur> no rhs
17:17:55 <dwcook> I was just thinking that since there's an IdentityT there ought to be a VoidT
17:18:02 <dwcook> Maybe not the most logical of thoughts :P
17:18:12 <mornfall> dwcook: indeed
17:18:31 <lightquake> what library should I use for parsing html if I want to retain some of the structure (i.e., not tagsoup)?
17:18:43 <mornfall> dwcook: ConstT would make more sense as a companion to IdentityT
17:18:43 <dwcook> Is there even a "zero monad" in any reasonable sense?
17:19:03 <lightquake> you can't write VoidT because there's no return
17:19:31 <dwcook> lightquake, ah, yep
17:19:40 <lightquake> monads have to be inhabited (which is why there are no contravariant functors that are also monads)
17:19:51 <shachaf> There are contravariant functors that are also monads.
17:19:56 <shachaf> Well, there's one.
17:20:18 <lightquake> what is it?
17:20:24 <shachaf> data Proxy a = Proxy
17:20:49 <lightquake> ah right, I'm thinking of some other combination that you can't have an example of
17:21:24 <lightquake> ah right, you can't have a *co*monad that's also a contravariant functor
17:22:27 <shachaf> Or can you?
17:22:35 <jmcarthur> extract seems tough
17:22:42 <mornfall> it'd be pretty unintuitive
17:22:50 <shachaf> data Void1 a ?
17:23:10 <jmcarthur> ah
17:23:23 <dwcook> That's also a Functor
17:23:27 <dwcook> but not Applicative
17:23:35 <jmcarthur> why not applicative?
17:23:38 <dwcook> pure
17:23:40 <jmcarthur> oh
17:23:42 <shachaf> Of course. Every Comonad is Functor.
17:23:43 <jmcarthur> right
17:23:44 * hackagebot annotated-wl-pprint 0.5 - The Wadler/Leijen Pretty Printer, with annotation support  http://hackage.haskell.org/package/annotated-wl-pprint-0.5 (dchristiansen)
17:24:05 <lightquake> yeah, you can write a function with type (Contravariant f, Comonad f) => f a -> Void
17:24:21 <lightquake> ... right, so data Void1 a works.
17:24:36 <shachaf> It works in roughly the same way that Proxy works.
17:24:45 <shachaf> (Or the opposite way? Whatever.)
17:24:54 <mornfall> shachaf: roughly the same opposite way
17:24:54 <jmcarthur> looks dual to me
17:26:04 <mornfall> jmcarthur: count the number of co- prefixes and check the parity :P
17:26:30 <mornfall> (* only works sometimes)
17:26:59 <lightquake> what's a cofunctor? something that implements cofmap :: f (a -> b) -> a -> b? :P
17:27:09 <shachaf> A cofunctor is a functor.
17:27:37 <dwcook> shachaf, how is data Void1 a a Comonad? How do you write extract?
17:27:48 <shachaf> Instead of fmap :: (a -> b) -> f a -> f b you get cofmap :: (a <- b) -> (f a <- f b)
17:27:51 <shachaf> Which is the same thing.
17:27:53 <jmcarthur> dwcook: empty pattern match
17:27:56 <dwcook> shachaf, never mind
17:28:04 <dwcook> Just occurred to me
17:28:41 <shachaf> Void1 needs a better name.
17:28:46 <dwcook> Ex falso quodlibet
17:29:07 <jmcarthur> dwcook: or with rank 2 types you can define it as   newtype Void1 a = Void1 (forall b. b)   and then it's pretty easy to see how to define extract
17:29:49 <dwcook> jmcarthur, isn't that inhabited (besides _|_)?
17:30:03 <jmcarthur> dwcook: inhabited by what (other than _|_)?
17:30:45 <dwcook> Void1 "hey"?
17:30:46 <mornfall> I can't think of anything non-bottomey that'd inhabit all types.
17:30:51 <dwcook> I'm confused
17:30:54 <jmcarthur> dwcook: nope, that won't work
17:31:02 <jmcarthur> dwcook: try it in ghci
17:31:32 <jmcarthur> dwcook: whatever Void1 holds, it must be possible to unify it with *any* type. the only value than can do that is _|_
17:31:48 <dwcook> Oh. I see.
17:33:55 <jmcarthur> dwcook: dual to this is   data Proxy a = forall b. Proxy b
17:34:32 <jmcarthur> dwcook: extract (Void1 x) = x   ...   return = Proxy
17:34:39 <dwcook> Ooh, this actually points me to a solution to a problem I had the other day
17:34:53 <edwardk> you can just use data Proxy a = Proxy. no need to hold a value in it
17:35:04 <jmcarthur> edwardk: right, i was just trying to show the duality
17:35:06 <edwardk> since () is appropriately terminal
17:35:46 <jmcarthur> edwardk: likewise, at least if you can use empty patterns, there is no need to actually store a (forall a. a) in Void.
17:36:32 <dwcook> Namely that I have a function accepting a value of some type ServerAction world clientId result (just some transformer newtype), but I didn't want them to be able to pick or use anything about clientId
17:36:50 <Twey> Hrm, does Haskell allow pattern-matching on Void?
17:37:02 <jmcarthur> Twey: there is some new language extension for empty case, i think
17:37:05 <Twey> I can't think of any extensions that allow that
17:37:09 <Twey> Oh, okay
17:38:16 <jmcarthur> yup, 7.8 has -XEmptyCase
17:38:47 <twiceler> So I thought I'd give another PSA for those of you in the Washington DC area: We're having a Haskell meetup tomorrow at 7:00pm in Arlington! (http://www.meetup.com/Haskell-DC/events/160772452/)
17:39:29 <dwcook> Wish I could go, public transport isn't great around here
17:39:59 <mornfall> That's a long stretch from Europe. ;-)
17:40:14 <mornfall> Which reminds me that I should be probably asleep.
17:40:28 <dwcook> Only probably asleep, with some probability of wakefulness
17:40:39 <Twey> -XEmptyCase, apparently
17:41:00 <Twey> Oh, beaten to it terribly
17:41:26 <Twey> Only in 7.8?  The patch is from over a year ago
17:41:56 <shachaf> PSA: haskell meetup in mountain view, ca next week
17:42:03 <twiceler> EmptyDataDecls is enabled by default, it seems
17:42:09 <maxiepoo> does anyone use literate haskell in production or is it only used for papers/blog posts?
17:42:13 <Twey> EmptyDataDecls is Haskell2010
17:42:25 <Twey> maxiepoo: I used it for a school project once; does that count?
17:42:31 <maxiepoo> nope :)
17:42:46 <dwcook> Aren't papers and blogs basically what it's meant for?
17:42:51 <structuralist> is it possible to have interference between scoped type variables and type families?
17:42:54 <kristof> Speaking of meetups, I wonder how bitemyapp 's presentation is coming along...
17:43:05 <twiceler> My code is usually vastly under-commented, so definitely no literate for me!
17:43:18 <shachaf> A large part of GHC is written in lhs.
17:43:44 <Twey> I think it's nice for code that's heavy on meaning and light on syntax, the kind that's usually more common in academia than a business rushing to put out the next revolutionary CRUD app
17:43:48 <dwcook> I use descriptive names instead of comments, for the most part
17:44:10 <maxiepoo> ghc uses lhs? That's cool
17:44:11 <Twey> structuralist: Quite plausibly
17:44:48 <dwcook> All the comments in my latest code say "TODO"
17:45:08 <maxiepoo> yeah my secret plan was to find someone that does use it in production and then go work for them
17:45:28 <identity> okay, what the hell. withManager :: (Manager -> ResourceT m a) -> m a. httpLbs :: Manager -> m (Response ByteString)
17:45:37 <dwcook> As in "Todo un caos"
17:45:53 <identity> sorry, httpLbs :: Request m -> Manager -> m (Response ByteString)
17:45:56 <structuralist> I have a recursive function f with a type signature, and I call it recursively with the same type signature pasted next to it, and I get an ambiguous type variable error between s and s0 where GHC seems to have arbitrarily added a 0 to my type variable
17:46:14 <identity> yet, like from the code in the docs themselves, withManager $ httpLbs somerequest doesn't typecheck
17:46:17 <structuralist> (Currently trying to create a minimal example)
17:46:27 <jle`> serve
17:46:41 <twiceler> structuralist: Haskell is not "aware" of the outer type signature when you're in your definition, so it doesn't know the two s's are the same
17:46:59 <structuralist> twiceler: even with scoped type variables?
17:47:05 <geekosaur> structuralist, that typically means that it can't figure out how to unify the types, so it invents a new independent type variable
17:47:16 <structuralist> maybe I misunderstand how this extension work
17:47:17 <geekosaur> did you foreach the type variable in question?
17:47:18 <structuralist> s*
17:47:21 <Twey> structuralist: Did you forget a ‘forall’?
17:47:25 <shachaf> structuralist: With ScopedTypeVariables you need to specify that the variable is scoped with forall.
17:47:28 <structuralist> I have a forall on the outer signature
17:47:30 <Twey> geekosaur: foreach?  o.@
17:47:34 <geekosaur> it's not enough to just enable the extension, you must also declare which type variables to keep in scope
17:47:35 <shachaf> (Except in a few cases when you don't.)
17:47:36 <Twey> structuralist: Is it on the variable ‘s’?
17:47:37 <geekosaur> er
17:47:38 <geekosaur> forall
17:47:42 <Twey> :-D
17:47:43 <twiceler> Scoped typed variables only further reduce the scope, don't they?
17:47:47 <structuralist> yes, it's on all the variables
17:47:50 * geekosaur trying to multitask as local network splats...
17:48:01 <dwcook> geekosaur, got JS on the brain?
17:48:05 <Twey> twiceler: No, they're also used by ScopedTypeVariables to enable type variable scoping in the function body
17:48:23 <Twey> structuralist: You'll need to post code
17:48:35 <geekosaur> I don't JS. (although I do sometimes get victimized by someone else's JS, which means I'm fighting with firefox on top of everything else)
17:48:48 <structuralist> http://lpaste.net/99123
17:48:56 <structuralist> ^ not self-contained but hopefully gives the idea
17:49:01 <structuralist> (++) is a type family
17:49:35 <maxiepoo> how can you hide an instance for a typeclass?
17:49:46 <dwcook> maxiepoo, by not importing the module it's in
17:50:02 <geekosaur> maxiepoo: you can't
17:50:05 <maxiepoo> the module is Prelude...
17:50:20 <dwcook> Then you're stuck with it, unless you use another Prelude or something
17:50:52 <twiceler> Twey: I had no idea! Is there documentation on that somewhere?
17:52:08 <dwcook> maxiepoo, if you want to hide it so you can write your own, consider writing a newtype wrapper instead
17:52:09 <maxiepoo> so I can't import just the Monad typeclass without any of the instances?
17:52:29 <maxiepoo> dwcook, it's just for pedagogical purposes
17:52:42 <Twey> twiceler: http://www.haskell.org/haskellwiki/Scoped_type_variables
17:52:56 <maxiepoo> I want to put the implementation of some Functors/Monads in the file
17:53:10 <dwcook> maxiepoo, you might also be interested in LANGUAGE NoImplicitPrelude then
17:53:12 <Twey> maxiepoo: You can use NoImplicitPrelude and define the typeclass yourself
17:53:19 <shachaf> maxiepoo: You could define your own type class.
17:53:30 <twiceler> Twey: Oh heh, it was right there. Thanks!
17:53:32 <maxiepoo> yeah I guess if it's just Functor/Monad it's nbd
17:53:39 <geekosaur> do you also need to do something with RebindableSyntax to use do notation?
17:53:53 * geekosaur can never remember...
17:53:54 <shachaf> Yes.
17:53:59 <Twey> maxiepoo: The RebindableSyntax makes do &c. use your (>>=) instead of the default one
17:54:01 <jrmithdobbs> maxiepoo: it does seem like an oversight in the module system imho
17:54:22 <shachaf> Right, oversight. No one has ever thought about this topic before today.
17:54:38 <Twey> Heh
17:54:59 <dwcook> That one dependently typed language whose name starts with I lets you name instances, which is kind of neat
17:55:16 <jrmithdobbs> shachaf: i said it seemed like, not that it was
17:55:29 <twiceler> maxiepoo: Could you just not import Monad from Prelude and define Monad yourself?
17:55:44 <structuralist> Twey: I posted code above
17:55:53 <Twey> structuralist: I saw, I just don't know the answer to your question
17:55:57 <structuralist> ok
17:56:01 <structuralist> thanks anyway
17:56:22 <Twey> Maybe if I had the full code I could play with it, but without it I can't see what's wrong there
17:56:29 <shachaf> Hmm, linear types.
17:56:43 <shachaf> I should read those papers.
17:56:53 <Twey> But I'm impressed with your bravery at trying to do this in Haskell :þ
17:57:02 <Twey> shachaf: Which ones?
17:57:05 <maxiepoo> not using do notation anyway
17:57:18 <johnw> shachaf: make sure you read them one after the other
17:57:37 <Twey> And delete each one after you're done with it.
17:57:47 <maxiepoo> just showing how to make State/Store from the adjunction between ((->) r) and ((,) r)
17:58:48 * hackagebot diagrams-builder 0.5 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.5 (BrentYorgey)
17:58:49 <shachaf> maxiepoo: That's the only adjunction between Functors, by the way.
17:58:55 <twiceler> maxiepoo: perhaps this? http://stackoverflow.com/questions/2830907/is-do-notation-specific-to-baseghc-base-monad
17:59:36 <maxiepoo> shachaf, really? what about Identity and Identity
18:00:03 <shachaf> Well, that's ((),) and (()->)
18:00:46 <maxiepoo> huh never thought about it that way
18:01:18 <maxiepoo> so the only Monad that arises from adjoint Functors is State?
18:01:52 <maxiepoo> the adjunctions for all the other Monads are from functors over other categories?
18:01:53 <shachaf> State s for some s, yes. Up to isomorphism, of course.
18:02:11 <shachaf> If F and G are Functor instances, and F -| G, that means that (F a -> b) ~~ (a -> G b)
18:02:31 <shachaf> And in particular when a = (), (F () -> b) ~~ (() -> G b)
18:02:49 <byorgey> hah, nice
18:02:57 <shachaf> I.e. G b ~~ (F () -> b), so there exists some s -- s = F () -- such that G = (s ->)
18:03:46 <maxiepoo> interesting
18:04:36 <dwcook> shachaf, what does ~~ mean?
18:04:58 <shachaf> isomorphic
18:05:09 <shachaf> I meant G ~~ (s ->), if you want to be picky about it.
18:07:59 <maxiepoo> yeah I wrote up the whole thing using newtypes but that led to a lot of wrapping/unwrapping
18:08:22 <qrada> hey, does anyone know how I can use this specific UTCTime from time-1.4, not sure how to import it:     Couldn't match expected type `UTCTime'
18:08:25 <qrada>                 with actual type `time-1.4:Data.Time.Clock.UTC.UTCTime'
18:08:28 <qrada>  
18:09:50 <maxiepoo> but it looks like I need at least Compose to be a newtype
18:11:26 <maxiepoo> to write instance Functor (State s) where type State s = Compose (Reader s) (CoReader s)
18:11:52 <shachaf> Yes.
18:12:12 <maxiepoo> if Compose were primitive...
18:12:12 <shachaf> You might as well write instance (Functor f, Functor g) => Functor (f .: g)
18:12:17 <shachaf> Er, :.
18:12:25 <shachaf> Or whatever you call it. Anything goes these days.
18:12:40 <maxiepoo> I think I'm going to do just State directly as a newtype
18:12:47 <maxiepoo> to minimize wrapping/unwrapping
18:12:56 <shachaf> (But then you have to invent a different Compose for instance (Contravariant f, Contravariant g) => Functor (Compose f g) )
18:12:57 <geekosaur> qrada: that is a symptom of multiple package versions installed, which is a very bad place to be. if you absolutely must do this you can use the PackageImports extension, but you should probably consider your installation to be screwed up and jettison your user package db
18:14:11 <qrada> geekosaur: ya my packages keep getting wrecked heh.. ive had to unregister, clean, reinstall etc
18:14:24 <maxiepoo> ooh and if I'm redifining monad I can just use join instead of bind!
18:14:30 <qrada> do you think i can remove a package to fix this? idno, it's a wreck
18:15:08 <qrada> it says UTCTime is a member of a hidden module time-1.4.x etc
18:16:07 <shachaf> maxiepoo: You might have more fun defining "real" functors that work with multiple categories.
18:16:14 <geekosaur> you are apparently doing something wrong somewhere, like installing a version of something that is not compatible with your haskell installation
18:16:18 <shachaf> Like data-category does it.
18:16:35 <maxiepoo> yeah maybe I'll tackle that in the next next version
18:16:45 <geekosaur> cabal could handle this better but doesn't currently (bootlibs and platform packages should be 'constraint installed')
18:17:15 <qrada> gotcha... this getModificationTime is defined weird though, check this type sig (or is this a result of my wrecked packages?); :t getModificationTime
18:17:18 <qrada> getModificationTime :: FilePath -> IO time-1.4:Data.Time.Clock.UTC.UTCTime
18:17:19 <shachaf> maxiepoo: The adjunction that gives you Cont is clearly the best one.
18:18:30 <shachaf> @let ret :: a -> (a -> r) -> r; ret x = ($ x)
18:18:31 <lambdabot>  Defined.
18:19:12 <maxiepoo> is there a way to get ghci to unwrap your type synonyms?
18:19:23 <shachaf> @let joyn :: ((((a -> r) -> r) -> r) -> r) -> (a -> r) -> r; joyn = (. ret)
18:19:24 <lambdabot>  Defined.
18:19:34 <shachaf> maxiepoo: Maybe :kind! ?
18:21:20 <maxiepoo> nah
18:22:04 <maxiepoo> I want it to tell me that (Reader r (CoReader r a)) == (r -> (r, a))
18:22:15 <byorgey> those aren't type synonyms.
18:22:22 <maxiepoo> where I defined Reader and CoReader in exactly the way that would give that
18:22:32 <maxiepoo> byorgey, sorry I redefined them as type synonyms
18:22:39 <byorgey> oh.  then :kind! should work.  did you notice the ! ?
18:23:41 <maxiepoo> I did but when I do :kind! (Reader r (CoReader r a)) it says r, a aren't in scope
18:24:03 <maxiepoo> ah I just needed to fill those in
18:24:05 <triliyn> maxiepoo: use concrete types
18:24:07 <triliyn> Right
18:24:54 <shachaf> You can just quantify them.
18:25:02 <shachaf> :kind! forall r a. ...
18:25:25 <shachaf> You can put this in your .ghci if you use :kind! a lot: :def k! \x -> return (":kind! " ++ x)
18:27:11 <maxiepoo> how do I get language extensions in ghci then?
18:27:22 <apples> :set -XFoo
18:27:45 <maxiepoo> nice thanks
18:28:06 <kristof> maxiepoo: Your nick is hilarious and awesome
18:28:17 <maxiepoo> thanks :)
18:33:39 <hattmammerly> I'm trying to write a card game engine and currently I'm struggling with deck shuffling. to use getStdGen I have to work with IO - do I have to encase all my dealings with cards in IO?
18:35:03 <Peaker> hattmammerly: no -- you can randomize a stdgen in IO once and then pass it as an argument to your pure functions
18:36:06 <hattmammerly> Peaker: do you know an example offhand? I'd love to understand how to break out of IO and not have to tack IO back on later
18:37:46 <Peaker> hattmammerly: main = do { gen <- getStdGen ; print (somePureFunction gen) }
18:38:32 <meretrix> I tried to load a library in ghci that I had just installed, but it gave me this rather cryptic error:
18:38:34 <meretrix> Loading package engel-0.0 ... linking ... <interactive>: /home/me/.cabal/lib/x86_64-linux-ghc-7.6.3/engel-0.0/libHSengel-0.0.a: unknown symbol `pipeszmconcurrencyzm2zi0zi1_PipesziConcurrent_Unbounded_closure'
18:38:39 <meretrix> Any clue what I did wrong?
18:39:27 <hattmammerly> oh, so I do have to encase all the cards stuff 'inside' IO
18:40:09 <hattmammerly> well, still, I think I can still manage heh. thank you!
18:41:28 <hattmammerly> this is getting very hairy, because this is a card game engine for an IRC bot, and I don't want bot functions to cease while a game is happening. so the game itself will be stateful, wrapped inside IO, which needs to in turn be kept inside the bot state and passed around
18:42:09 <hattmammerly> I'm probably fighting with the type system more than I have to, but maybe I'll rewrite it all when I'm not an idiot ;) thanks Peaker!
18:42:09 <maxiepoo> @pl \f x r -> f (r, x)
18:42:09 <lambdabot> (. flip (,)) . (.)
18:42:35 <maxiepoo> @pl \x r -> f (r, x)
18:42:36 <lambdabot> (f .) . flip (,)
18:43:51 <shachaf> :t flip . curry
18:43:52 <lambdabot> ((a, b) -> c) -> b -> a -> c
18:43:56 <shachaf> Or flip (curry f)
18:44:11 <shachaf> (But don't use flip if you can help it. :-( )
18:44:42 <Kaidelong> why don't use flip
18:44:48 <Axman6> it's ugly
18:45:11 <Kaidelong> and the alternatives aren't?
18:46:17 <shachaf> I'd usually rather see (\x -> f x q) than (flip f q)
18:46:23 <shachaf> Or (`f` q)
18:46:27 <shachaf> Or even (f ?? q)
18:46:45 <maxiepoo> shachaf, I think i need to use flip in order to use ((,) r) and ((->) r) without newtypes
18:46:59 <Kaidelong> shachaf: but all of those requie you to have bound q somewhere
18:47:10 <Kaidelong> flip works even if there is no bound variable q
18:47:11 <FreeFull> I like (`f` q)
18:47:13 <shachaf> There are some valid use cases for flip.
18:47:20 <shachaf> But I think they are rare.
18:47:35 <maxiepoo> so I think it's clearer to make the iso (flip . curry) and (uncurry . flip)
18:47:54 <Kaidelong> I think flip curry and flip (,) are both very clear
18:47:58 <Kaidelong> tbh
18:48:07 <dwcook> @type flip curry
18:48:08 <lambdabot> b -> ((b, b1) -> c) -> b1 -> c
18:48:10 <Kaidelong> flip . curry*
18:48:24 <FreeFull> shachaf: flip const vs const id vs \x y -> const y x
18:49:00 <Twey> Lambdas are ugly special syntax; flip is a nice uniform function
18:49:06 <shachaf> I think it's usually the sort of thing that's clear when you're writing it and not clear when you're reading it.
18:49:22 <Kaidelong> I don't understand why pointfree stuff attracts such hate, so long as you didn't machine generate it or think too hard about it
18:49:32 <shachaf> Anyway, it has its place sometimes. I just think you should consider it carefully.
18:49:44 <shachaf> How hard you thought to write it down doesn't matter. It's how hard you have to think to read it.
18:50:11 <maxiepoo> @type (uncurry . flip) id
18:50:11 <shachaf> (Keeping in mind that "it" isn't going to be the point of the code you're reading, just another hump to get over in order to understand the actual code.)
18:50:12 <lambdabot> (a, a -> c) -> c
18:50:29 <Kaidelong> I don't think it's true that "it doesn't matter", how hard it was to write will affect how hard it was to read
18:50:35 <FreeFull> I'd rather see flip than lambdas
18:50:51 <FreeFull> Well, unless it's flip in those long lambdabot @pl expansions
18:51:04 <shachaf> OK.
18:51:19 <FreeFull> @pl flip flip
18:51:19 <lambdabot> flip flip
18:51:41 <FreeFull> @pl \x -> x + x*x + x*x*x
18:51:42 <lambdabot> ap ((+) . ap (+) (join (*))) ((*) =<< join (*))
18:51:46 <Twey> It's convoluted combinations of (.) that trigger my warning bells :þ  So long as the expression is in the a . b . c . d form I'm okay with it
18:52:18 <Kaidelong> (f .) . g --this idiom
18:52:32 <shachaf> Well, I think (f .) . g is confusing and a bad idiom but (. (. f)) is not.
18:52:34 <Twey> I don't like that much, though it's only one so it's not terrible
18:52:34 <shachaf> So there you go.
18:52:46 <FreeFull> (f .) . g is confusing
18:52:47 <enthropy> edwardk: http://hackage.haskell.org/package/reflection-1.3.2/docs/src/Data-Reflection.html is there a reason to not do the calculations in the last instance(s) at compile time (when the a/b are LitE (IntegerL . )))?
18:52:55 <Twey> f .: g is fine, though
18:54:06 <enthropy> also you stole $(5) might more conveniently stand for (Proxy :: Proxy $(5))
18:54:14 <FreeFull> (f .) . g  →  \x -> f . g x  →  \y x -> f (g x y)
18:54:28 <FreeFull> :t \f g -> (f .) . g
18:54:29 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
18:54:41 <FreeFull> I think I got that expansion wrong
18:54:54 <FreeFull> Yeah, swap that x and y in the lambda
18:55:07 <shachaf> When you use polymorphic proxy, you can write ([]::[T]) instead of (Proxy :: Proxy T)
18:55:08 <enthropy> edwardk:  (a + b) isn't seriously shorter than  [| $a + $b |]
18:55:21 <FreeFull> Twey: I like the way function composition works in stack-based languages
18:55:32 <haasn> only for T :: *
18:55:36 <haasn> sadly
18:55:47 <shachaf> Only for T :: *
18:55:50 <L8D> Does haskell support rope?
18:55:55 <shachaf> hi tiglionabbit
18:56:11 <FreeFull> map f .: zip  becomes  { f } map zip
18:56:33 <enthropy> shachaf, haasn do you have an opinion on the Num ExpQ instance in reflection?
18:56:50 <edwardk> enthropy: the main reason i wrote a Num instance at all was to get $(5)
18:56:50 <FreeFull> The problem is that you need quoting in stack-based languages
18:57:08 <edwardk> enthropy: if yu wanted to improve the (+) in the instance i'd take the patch
18:57:34 <mm_burea1> L8D: the data structure?
18:57:44 <enthropy> edwardk: I mean $(5 :: ExpQ) gives me the same as $([| 5 |]), right?
18:58:07 <edwardk> for ExpQ rather than Types i'm not as wedded t the solution i offer
18:58:18 <KevinC_> Sorry to intrude, but would someone mind helping out a newbie?
18:58:32 <Kaidelong> one thing that would be nice is if we had nemerle style explicit holes, I actually think that's nicer than currying
18:58:39 <edwardk> i wrote it because if i was supplying instances for the TH types i might as well supply both
18:58:48 <geekosaur> @where justask
18:58:49 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
18:58:54 <Kaidelong> f x _ z becomes an f' of one argument
18:58:56 <edwardk> making it generate Proxy :: Proxy $(n) is actually a pretty good idea
18:59:11 <Axman6> KevinC_: only if you tell us how we can help =)
18:59:22 <edwardk> but then handling +, etc. is a pain in the ass
19:01:54 <KevinC_> How would I go about printing a list of tuples comprised of strings? Or rather, after zipping a list of strings, how do I print it?
19:02:15 <Axman6> wirth print =)
19:02:16 <mm_burea1> KevinC_: print it how?
19:02:19 <Axman6> -r*
19:03:13 <mm_burea1> KevinC_: if you just want some debug-friendly printing you can just use 'print' or 'mapM_ print'
19:03:22 <mm_burea1> the latter prints every tuple on its own line
19:03:41 <edwardk> > show [("hello","world"),("!!!","I"),("am","a"),("list","of"),("pairs","of"),("strings",".")]
19:03:43 <lambdabot>  "[(\"hello\",\"world\"),(\"!!!\",\"I\"),(\"am\",\"a\"),(\"list\",\"of\"),(\"...
19:04:07 <edwardk> KevinC_: show will turn a structure made up of common things like that into a string you can putStrLn. print does just that
19:04:12 <edwardk> :t print
19:04:13 <lambdabot> Show a => a -> IO ()
19:05:03 <KevinC_> when I call mapM_ print directly, the compiler throws "Couldn't match expected type `[a0]'             with actual type `[b0] -> [(String, b0)]'" at me
19:05:19 <mm_burea1> KevinC_: you're trying to print a function
19:05:26 <KevinC_> ooooh
19:18:38 <rola> What's the relation between function composition and function application?
19:18:56 <enthropy> edwardk: the lack of Q for those instances is pretty painful. You are opposed to the extensions that (instance Num ExpQ) would bring in, right?
19:19:12 <enthropy> namely -XOverlappingInstances
19:19:29 <shachaf> rola: What sort of answer are you looking for?
19:21:37 <chrisdotcode> can someone please help me get out of dep hell? http://lpaste.net/99126
19:22:16 <chrisdotcode> I just deleted my cabal-dev/ and dist/ folders in a yesod project, and switched to cabal sandboxes.
19:22:30 <chrisdotcode> I have no idea why this is happening.
19:25:23 <jrm2k6> Hi guys, i have a stupid question, but i dont know how to solve it http://lpaste.net/99127
19:25:31 <jrm2k6> what if i want to generalize that
19:26:06 <jrm2k6> http://lpaste.net/99127
19:26:15 <rola> shachaf, hm. perhaps what are the similarities between them and where do they differ?
19:26:39 <jrm2k6> [(x,y) | x <- [True, False], y <- [True, False]] -> I dont know how to do that for n variables
19:26:46 <jrm2k6> any idea?
19:27:13 <shachaf> Start with figuring out what the type of the thing you want is.
19:27:47 <jrm2k6> hm
19:29:00 <jrm2k6> :replicateM
19:29:05 <jrm2k6> :t replicateM
19:29:06 <lambdabot> Monad m => Int -> m a -> m [a]
19:30:13 <lingxiao> um.. it's a computation where you drawn from n lists and create an n-tuple
19:30:40 <lingxiao> so the tuple has to be inductively defined if you want to generalized it right?
19:31:21 <lingxiao> uhh.... unless they're all the same type in which case it's just a list
19:31:22 <ReinH> if you want to generalize from tuples to lists,
19:31:50 <jrm2k6> lingxiao: they are all the same type
19:31:51 <ReinH> > sequence [[True, False], [True,False]]
19:31:52 <lambdabot>  [[True,True],[True,False],[False,True],[False,False]]
19:32:22 <jrm2k6> > sequence [[True, False], [True, False], [True, False]]
19:32:23 <lambdabot>  [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[Fa...
19:32:28 <jrm2k6> alright
19:32:30 <jrm2k6> this is what i want
19:32:40 <scott_> > replicateM 2 [True, False]
19:32:41 <lambdabot>  [[True,True],[True,False],[False,True],[False,False]]
19:32:45 <shachaf> sequence is the answer, but it's useful to figure out what the question is first.
19:33:00 <ReinH> Or
19:33:02 <ReinH> > (,,) <$> [True,False] <*> [True,False] <*> [True,False]
19:33:03 <lambdabot>  [(True,True,True),(True,True,False),(True,False,True),(True,False,False),(Fa...
19:33:10 <ReinH> depends on what you actually want
19:33:20 <jrm2k6> ReinH: Wow I am not advanced enough for this notation yet
19:33:26 <jrm2k6> I mean, for two variables it is easy
19:33:34 <jrm2k6> you dont need to deal with monad or anything
19:33:40 <jrm2k6> just a list comprehension works
19:33:48 <jrm2k6> :t sequence
19:33:49 <lingxiao> jrm2k6: at least for now, just think of <*> as cartesian product over lists
19:33:49 <lambdabot> Monad m => [m a] -> m [a]
19:34:03 <jrm2k6> sequcne is alreayd implying the usage of monads right?
19:34:04 <ReinH> well ... it isn't really
19:34:25 <jrm2k6> so I was kinda scared about that as I havent understood anything about monads yet
19:34:26 <lingxiao> jrm2k6: in fact that's the titular use case, which is why * appears in <*>, the "<>" just means some generlized version of what ever is in it
19:34:29 <jrm2k6> (newbie spotted) :)
19:34:34 <lingxiao> or you can think of it that way
19:34:51 <ReinH> jrm2k6: if you've used a list comprehension you've used the list monad
19:35:16 <ReinH> > do { x <- [1,2]; y <- [1,2]; return (x,y) }
19:35:17 <lambdabot>  [(1,1),(1,2),(2,1),(2,2)]
19:35:20 <jrm2k6> ReinH: This is the part I dont get then
19:35:38 <jrm2k6> so do { == [ | ..]?
19:35:51 <Twey> Hrmph
19:35:59 <ReinH> jrm2k6: sort of. do notation works for any monad, list comprehension works for lists.
19:36:00 <jrm2k6> I mean, I understand that you will deal with monads when you have a do block
19:36:02 <jrm2k6> right?
19:36:05 <lingxiao> jrm2k6: um.. for now in addition to reading about monads, and looking at all these monadic functions and using them as 'black boxes'
19:36:28 <Iceland_jack> > concatMap (\x -> concatMap (\y -> [x, y]) [1,2]) [1,2]
19:36:29 <ReinH> jrm2k6: but if you understand that this list comprehension is giving you the cartesian product of x and y
19:36:30 <lambdabot>  [1,1,1,2,2,1,2,2]
19:36:30 <lingxiao> jrm2k6: you might also do yourself a great favor by thinking about "computations", generic computations of any kind
19:36:39 <ReinH> and you understand that the do notation is doing the same thing
19:36:45 <Iceland_jack> > concatMap (\x -> concatMap (\y -> return (x, y)) [1,2]) [1,2]
19:36:46 <lambdabot>  [(1,1),(1,2),(2,1),(2,2)]
19:36:47 <ReinH> then you're on the right track to understanding the list monad
19:36:53 <jrm2k6> ReinH
19:36:58 <jrm2k6> thanks got that :)
19:37:12 <lingxiao> jrm2k6: so for your case, [(x,y) | x <- [..],  y <- [..]]
19:37:23 <Twey> You don't actually need the whole list monad for list comprehensions, just the applicative and the alternative (since you can't have multiple results)
19:37:37 <lingxiao> jrm2k6: or for the sake of arguements, [ [x,y] | x <- [..], y <- [..]]
19:37:42 <lingxiao> I see three computations:
19:38:09 <lingxiao> jrm2k6: [ putting things in a list | drawing element x from list, drawing element y from list ]
19:38:39 <lingxiao> and then finally, putting the whole thing in a list
19:38:59 <jrm2k6> lingxiao: yes i agree
19:39:04 <jrm2k6> i mean i got that
19:40:01 <lingxiao> jrm2k6: so what haskell suggest you do, is to get really general, and classify the space of "things"
19:40:12 <lingxiao> jrm2k6: so in space of compuations, a few computations come up a lot
19:40:23 <lingxiao> jrm2k6: like in space of all polynomials, a few come up a lot
19:40:32 <lingxiao> jrm2k6: for example: 1 + x + x^2 + x^3 ..
19:40:48 <jrm2k6> yep
19:40:53 <lingxiao> jrm2k6: so now you give it a name, so you may build even more complex computations from these now, atomic blocks
19:41:41 <lingxiao> jrm2k6: in case of polynomaisl, you can build a guassian curve for example, f (x) = e^f(mu,sigma)
19:41:58 <lingxiao> jrm2k6: in case of computations... a few comes up a lot
19:42:02 <lingxiao> a -> a -> a -> ...
19:42:23 <lingxiao> where a denotes a value, out of context .. ie it depends on nothing but the previous a
19:42:24 <jrm2k6> hm
19:42:31 <lingxiao> a -> m a -> a -> m a -> a ...
19:42:44 <lingxiao> where m denotes a context, a larger computation a runs in, that could affect a
19:43:11 <jrm2k6> i see
19:43:15 <jrm2k6> (kindof)
19:43:26 <jrm2k6> I just didnt find any really good explanations of monads
19:43:32 <jrm2k6> from a kind of superficial level
19:44:15 <lingxiao> so the way I understand it is to (sic: bang my head against it until it's clear as day) think about why people came up with to begin with
19:44:38 <Iceland_jack> jrm2k6: Just work with examples of (specific) monads instead of trying to see the big picture just yet
19:44:50 <jrm2k6> Alright, thanks for all your advices guys
19:44:52 <Iceland_jack> going into vague analogies breaks down very quickly
19:45:19 <jrm2k6> Thanks lingxiao for the explanation, I guess i would be back for bugging you more
19:45:20 <jrm2k6> ;)
19:45:39 <lingxiao> jrm2k6: yeah the polynomial analogy is very superficial. it's goes as far down as the fact they're both about finding a common pattern, putting a name on it, and then use it
19:45:58 <lingxiao> jrm2k6: yup np, people here are very helpful so if you're stuck, here's a good place
19:46:19 <jrm2k6> Thanks!
19:46:37 <lingxiao> yup np  :)
19:47:42 <lingxiao> http://www.seas.upenn.edu/~cis552/
19:47:55 <jrm2k6> btw i m working on the problem 48 of 99haskell problems, this is how my question came up
19:48:08 <lingxiao> jrm2k6: doing the hw there helped me a lot after I did LYAH
19:48:21 <jrm2k6> Oh nice,
19:48:24 <jrm2k6> cool resrouces.
19:48:31 <lingxiao> jrm2k6: yup, I did that too.. so I did 99probs >> LYAH >> CIS552
19:48:43 <jrm2k6> Ok
19:48:53 <lingxiao> LYAH was a gentle introduction to these concepts
19:49:18 <lingxiao> and CIS552 put them together, also if you find the jump too much, try: http://www.seas.upenn.edu/~cis194/
19:49:41 <jrm2k6> thats cool
19:49:42 <jrm2k6> thanks
19:49:50 <lingxiao> yup np
19:49:59 <jrm2k6> I 've begun to read LYAH but I stopped after the monois part if i rememebr well
19:51:57 <lingxiao> I second Iceland_jack in doing lots of examples, and think about why they're similar, it'll build your ability to abstract (read: ignore the right things)
19:52:59 <lingxiao> from my memory, this also helped: https://www.fpcomplete.com/user/DanBurton/20-intermediate-exercises
19:53:14 <lingxiao> here's some answers: https://gist.github.com/23Skidoo/5087060
19:53:17 <lingxiao> if you're stuck
20:00:22 <jrm2k6> thanks thats really cool of you
20:00:33 <dibblego> I didn't know my content had been stolen for fpcomplete, how interesting
20:01:16 <shachaf> https://www.fpcomplete.com/user/DanBurton/20-intermediate-exercises ?
20:01:23 <dibblego> Yes.
20:01:45 <shachaf> Hmm, it doesn't even mention your name.
20:02:00 <rola>  it says Shamelessly stolen from: http://blog.tmorris.net/posts/20-intermediate-haskell-exercises/
20:02:13 <dibblego> does it? I don't see it
20:02:19 <rola> on https://www.fpcomplete.com/user/DanBurton
20:02:22 <lingxiao> dibblgo: oh hey! thanks for making those exercises. yeah .. the original link doesn't work for me for some reason
20:02:39 <shachaf> That's, uh, not very nice.
20:02:43 <lingxiao> ahh there it is
20:02:58 <lingxiao> jrm2k6: just paying it forward
20:03:03 <dibblego> it's not a big deal, except those exercises were written years ago, and have been improved upon significantly since
20:13:37 <adek> I have algorithm which works on string-like types. Is there a way to write it in such a way that it will work both for Text and String? Whenever I use map or take I need special version of them for Text case. Maybe there is some typeclass that I am not aware of?
20:13:53 <joelteon> mono-traversable
20:13:54 <randomclown> fmap?
20:14:10 <randomclown> what about the foldable/traversable stuff
20:14:45 <Iceland_jack> @ty
20:14:46 <lambdabot> <no location info>: not an expression: `'
20:14:49 <Iceland_jack> @ty fmap
20:14:50 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:14:57 <Iceland_jack> What's the a and b? :)
20:15:25 <adek> Well, fmap would do, but not for take, right?
20:15:27 <joelteon> :t omap
20:15:28 <lambdabot>     Not in scope: `omap'
20:15:28 <lambdabot>     Perhaps you meant one of these:
20:15:28 <lambdabot>       `fmap' (imported from Control.Monad.Writer),
20:15:37 <shachaf> fmap doesn't work for Text since it's not parameterized.
20:15:44 <shachaf> It depends on how your algorithm works.
20:15:51 <dhrosa> ..why is fmap specifically imported from Control.Monad.Writer
20:16:05 <shachaf> Some things are so inefficient for one or the other that it doesn't make much sense to do them indiscriminately.
20:16:46 <frxx> Text is not a functor so fmap won't work on it
20:16:50 <adek> shachaf: Take a list and integer n and returns all windows of list of length n
20:17:25 <adek> And what I do is just compute tails and map (take n)
20:18:31 <adek> map (take n) $ take (length l - n) $ tails l
20:19:04 * hackagebot egison 3.2.9 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.9 (SatoshiEgi)
20:19:23 <adek> Another question is, how bad practice is it to unpack text into string?
20:22:21 <enthropy> http://lpaste.net/99129
20:23:59 <enthropy> edwardk: ^^ keeping the preprocessor-heavy stuff to the Num Type instance doesn't seem to be an option
20:24:03 <enthropy> :(
20:24:44 <johnw> adek: sometimes you just have to
20:25:22 <adek> johnw: Well, in this case I can just implement this function twice with specialization for Text and it will do...
20:25:27 <johnw> fortunately String and Text are isomorphic (to my knowledge), so it's just a CPU and memory cost; you can often find ways of limiting how many times you have to do it
20:25:57 <Iceland_jack> johnw: Well, not quite
20:26:15 <johnw> no?
20:26:26 <johnw> i thought one was UCS4 and the other was UCS2?
20:26:50 <Iceland_jack> No not UCS2!
20:26:50 <kristof> people still use UCS2?
20:26:56 <Iceland_jack> They shouldn't
20:26:57 <johnw> UTF16?
20:27:00 <Iceland_jack> Text is UTF-16 internally
20:27:03 <johnw> ok
20:27:13 <johnw> and UCS4 and UTF16 are not isomorphic?
20:27:17 <shlevy> uefi still uses it!
20:27:18 <Iceland_jack> and String allows invalid code points
20:27:21 <kristof> I thought everyone collectively realized UCS2 was a bad idea when Java adopted it for strings internally
20:27:24 <johnw> ah
20:27:42 <adek> Another, possible crazy, idea. Is there a way to execute function in changed environment? For example override take to be Text.take only for given function?
20:28:00 <geekosaur> nope
20:28:21 <joelteon> adek: mono-traversable
20:28:22 <shlevy> adek: Take the function as an argument to the funciton
20:28:24 <jle`> hm
20:28:27 <jle`> can't you shadow it?
20:28:45 <jrmithdobbs> ya just name something else that in your scope
20:28:46 <joelteon> did I ping out?
20:28:57 <Iceland_jack> > T.unpack ("\xD800" :: T.Text) == ("\xD800" :: String)
20:28:58 <Iceland_jack> False
20:28:58 <lambdabot>  Not in scope: `T.unpack'
20:28:58 <lambdabot>  Perhaps you meant `BS.unpack' (imported from Data.ByteString)Not in scope: t...
20:29:01 <Iceland_jack> johnw: ↑
20:29:02 <ij> joelteon, you're still here
20:29:08 <joelteon> ok
20:29:18 <adek> joelteon: Yeah, probably I will go for it.
20:29:30 <adek> shlevy: I would have to pass 3 functions, too messy
20:29:49 <jle`> maybe consider a data type
20:30:00 <jle`> with all three functions as fields
20:30:01 <shlevy> Yeah was my next suggestion
20:30:18 <joelteon> This exact situation is what mono-traversable is designed for
20:30:55 <adek> jle`: I have foo :: [a] -> Int -> [[a]] and for foo2 :: Text -> Int -> [Text], foo2 a b = foo a b where take = Text.take etc... but I believe this is statically binded, right?
20:31:21 <johnw> Iceland_jack: thanks!
20:31:33 <jrmithdobbs> :t const BS.pack >>= \pack -> return . pack
20:31:34 <lambdabot> Monad m => [Word8] -> m BSC.ByteString
20:31:56 <jle`> adek: yes the take only shadowsin that expression
20:32:04 <Iceland_jack> johnw: no problem :)
20:32:09 <joelteon> yep
20:32:10 <jle`> i would just pass in the taker function
20:32:22 <jle`> or
20:32:23 <jrmithdobbs> adek: like that?
20:32:24 <jle`> mono-traversable
20:32:28 <jle`> like someone else suggested
20:32:33 <jle`> was invented for exactly this purpose
20:32:54 <adek> Yeah, I will go for it. Just was exploring a bit to learn some more :)
20:33:12 <c_wraith> lens was also invented for exactly this purpose
20:33:18 <jle`> https://hackage.haskell.org/package/mono-traversable-0.2.0.0/docs/Data-Sequences.html
20:34:03 <jle`> mm_freak is not online
20:34:10 <jle`> :/
20:34:16 <jle`> here i was thinking everybody just idled 24/7
20:36:33 <jle`> anyone here use frp/afrp for games and sims and stuff?
20:37:31 <L8D> jle`: is your nick supposed to mean "jelly grave"?
20:37:44 <jle`> L8D: hm. no, i have not heard that
20:37:51 <jle`> and it was not quite intentional
20:37:55 <jle`> (unfortunately)
20:38:08 <L8D> that’s what I always think of when I read your nick
20:38:13 <jle`> it's actually from my name, Justin Le
20:38:19 <L8D> ah
20:38:26 <jle`> ah
20:38:29 <L8D> is jle registered?
20:38:33 <jle`> it might stick on me.
20:38:35 <jle`> yes jle is registered
20:38:38 <jle`> :|
20:38:42 <L8D> :(
20:39:40 <L8D> do you use linux?
20:40:50 <jle`> L8D: my laptop is windows 8.1 but i do most of my work ssh'd onto a persistent ubuntu server
20:41:28 <L8D> jle`: vim?
20:41:34 <jle`> L8D: yes
20:41:45 * L8D high fives jle`
20:42:24 <L8D> but sorry about windows though
20:42:28 <L8D> it must suck
20:42:30 <jle`> haha. o/
20:42:37 <jle`> nah i actually am happy with windows
20:42:39 <jle`> for non-dev purposes
20:43:04 <jle`> and i don't have too much problems developing haskell on my windows box when i do'nt have internet either
20:44:18 <L8D> Is it a big or small laptop?
20:44:47 <jle`> small --- but i fear this is slightly off topic
20:45:19 <L8D> well, running arch linux on a macbook air is wonderful
20:45:49 <ij> L8D, btw, there's #haskell-blah
20:45:53 <L8D> no one else is talking on this channel...there doesn't seem to be a topic to get off of.
20:45:58 <L8D> but whatever
20:46:09 * ij is just informing.
20:46:32 <jle`> still, it is probably more likened to noise than signal
21:16:36 <platz_> ghc actually perfoms quite well on both windows and linux.  scala is poor on windows, F# is poor on linux
21:17:05 <platz_> in terms of raw efficiency
21:22:02 <carter> hehe :)
21:26:23 <zRecursive> hehe what ?
21:36:03 <carter> jvm
21:36:05 <carter> :)
21:36:24 <carter> i just like giggling when people make jvm references
21:36:25 <carter> not sure why
21:36:40 <johnw> rockit!
21:37:35 <carter> johnw: why you no lurk on #numerical-haskell
21:37:36 <carter> :)
22:15:05 <zRecursive> After `git pull`, how can i only see the modified parts ?
22:15:45 <Axman6> git diff should be able to show you, i think
22:16:54 <zRecursive> `git diff` => WARNING: terminal is not fully functional ...
22:16:57 <mm_bureau> first you get a doctor in git, then you get nightmares, then you switch to darcs and use 'darcs pull' =)
22:17:18 <mm_bureau> SCNR
22:17:37 <zRecursive> what is SCNR ?
22:17:53 <mm_bureau> Sorry, Could Not Resist
22:18:01 <simpson> `git reflog` shows you what your previous heads were at, `git diff` shows you the diff between two commits, you can configure `git pull` to show you short diffs (or long diffs) on pull...
22:18:13 <mm_bureau> lol
22:18:15 <simpson> Sadly, there is no cure for darcs addiction.  :c
22:18:25 <simpson> But we have hope! It is possible to convert darcs repos to git.
22:18:31 <Axman6> unless you want something that isn't slow :\
22:18:36 <mm_bureau> i love how you need to read half a book to do the most basic things with git
22:18:48 <mm_bureau> Axman6: darcs isn't slow for most use cases
22:18:55 <jle`> for fay libraries, what exactly do i need to "have" on the system in order for fay to compile using them?
22:18:55 <simpson> Do you? I've never read a book on git, and I taught it to myself while I was learning C.
22:19:12 <simpson> Of the things I had to teach myself when I learned GPUs, git was *not* the hard one.
22:19:26 <enthropy> we are comparing to darcs
22:19:47 <simpson> darcs is not bad, just a tad slow.
22:19:49 <Axman6> yeah git's pretty easy to use... I'm not a huge fan of git, but it's not that hard to use. toold like SourceTree make is even nicer to use
22:19:50 <mm_bureau> simpson: every time i want to do something, i have to duckduckgo
22:19:54 <enthropy> also the comparison is "the VCS I know vs. the VCS I don't know as well"
22:19:58 <mm_bureau> something nontrivial i mean
22:20:05 <mm_bureau> something that isn't commit or push
22:20:29 <simpson> mm_bureau: And you'd have the same problem with hg, bzr, etc. I assume.
22:20:47 <simpson> I had to learn Perforce (gasp!) for work. There are worse things in life than git.
22:20:52 <mm_bureau> simpson: i really didn't have this problem with darcs…  that's because it uses a different data model than the others
22:21:19 <simpson> Sure.
22:21:38 <simpson> Anyway, I'm not really going to try to convince you to switch or anything like that; I just felt like one good rib deserves another. :3
22:23:30 <zRecursive> `git log -p` works :)
22:24:19 * hackagebot xml-html-conduit-lens 0.1.0.0 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.1.0.0 (MatveyAksenov)
22:35:49 <Redz> what does {-# SPECIALISE instance ... #-} do?
22:36:44 <Axman6> creates specialised versions of the functions for the given types. means that the class constraint doesn't need to be passed around when the type is know and it's a specialised instance
22:38:09 <Redz> thanks Axman6 .
22:38:29 <Axman6> best to check the GHC docs to be sure though
22:39:04 <Redz> ok
22:39:21 * hackagebot tls 1.2.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.2.0 (VincentHanquez)
22:39:23 * hackagebot tls-debug 0.3.0 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.3.0 (VincentHanquez)
22:39:25 * hackagebot connection 0.2.0 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.2.0 (VincentHanquez)
22:40:38 <mcjohnalds> Can someone spare some advice? I wanted to write a wrapper for some of OpenGLRaw, all the functions take C types like CInt rather than haskell's types like Int. How much slower would real time games be if the functions my wrapper provided all took regular haskell types and converted them to C types using functions like fromIntegral and realToFrac?
22:41:22 <Axman6> well, I believe fromIntegral on Int to CInt is basically id
22:41:42 <Twey> Only on 32-bit
22:41:48 <mcjohnalds> ?
22:42:11 <Axman6> I'd just make sure you're using the right Haskell alternatives to the C types (Int, Double, Float etc.)
22:42:29 <Axman6> Twey: isn't the size of Int defined to be the size of int on the host system?
22:42:35 <Twey> Axman6: Yep
22:42:37 <Axman6> (or at least 31 bits)
22:42:43 <Twey> But CInt appears to always be 32-bit
22:42:50 <Axman6> ew
22:42:54 <mcjohnalds> Sweet! Thanks.
22:42:56 <Twey> newtype CInt = CInt GHC.Int.Int32 -- Defined in `Foreign.C.Types'
22:43:24 <Axman6> then use Int32 and fromIntegral
22:44:25 <mcjohnalds> Okey dokey, that's real helpful
22:44:33 <Twey> You probably want to specialize Num and Integral for CInt to make it truly id
22:44:49 <Twey> (if they don't already have specializations)
22:46:01 <Axman6> mcjohnalds: Foreign.C.Types has quite a bit of info available
22:54:25 <jle`> bergmark: if i want to deploy fay to a production server with only haskell binaries...what binaries/files do i need to include from each library to run fay?
23:02:15 <jle`> just /share ?
23:09:24 * hackagebot snaplet-mongodb-minimalistic 0.0.6.11 - Minimalistic MongoDB Snaplet.  http://hackage.haskell.org/package/snaplet-mongodb-minimalistic-0.0.6.11 (PetrPilar)
23:22:43 <erisco> I am working with Shake and this is my script http://lpaste.net/99130
23:23:04 <structuralist> if I have a newtype Lifted τ = X {x :: forall γ. Cx' γ → γ ⊢ τ}
23:23:04 <erisco> when I run it, it says "lessc: createProcess: does not exist"
23:23:20 <erisco> however, I can run the exact same command on the same terminal and it works
23:23:34 <structuralist> ... and I'd like to use the constructors of the γ ⊢ τ in applicative style, is there a recommended way to do that?
23:24:12 <structuralist> Lifted isn't a "Functor", because it's U -> *. where U is a custom kind
23:24:48 <structuralist> and the argument isn't the codomain of the contained function
23:25:19 <structuralist> ("the argument" being τ)
23:27:35 <structuralist> if I didn't have to contain the universal quantifier in a newtype I'd obviously just use (→) Cx' γ, but :(
23:31:33 <Twey> Unfortunately Haskell makes you fully-apply type functions, so if you want to use partial application on the type level you need to make a newtype and deal with all that wrapping and unwrapping on the value level
23:31:44 <Twey> s/type functions/type synonyms/
23:32:23 <structuralist> Twet: was that at me?
23:32:38 <Twey> Oh, but I guess that's not relevant to you — misread, sorry
23:32:53 <pavonia> structuralist: I'm not familiar with the Unicode syntax, how does "Cx' γ → γ ⊢ τ" translate to ASCII syntax?
23:33:07 <Twey> Are you doing an Outrageous Coincidences?
23:33:11 <structuralist> pavonia: Cx' g -> Term g t
23:33:32 <structuralist> Twey: well no dependent types
23:33:38 <structuralist> well spotted though
23:34:03 <Twey> structuralist: Hm, but you're encoding the type as a function of the context?
23:35:22 <structuralist> terms as a function of the context - γ ⊢ τ is the type of terms of type τ in context γ - the point is that these use de Bruijn indices and I want to record just the increment of the index but keep it well-typed
23:35:37 <structuralist> to make weakening easy
23:35:50 <Twey> Oh, right
23:36:34 <structuralist> but now applying constructors to these "lifted" terms becomes a pain
23:37:25 <Twey> Yeah… the weakening approach is a pain to start with, though :þ
23:38:12 <johnw> I could really use a NonEmptySet...
23:38:44 <Twey> johnw: Wrap Data.Set?
23:38:58 <johnw> yes
23:39:14 <johnw> but, not worth it
23:39:33 <Twey> structuralist: Can you not unwrap the function with x and then use the (r →) instance?
23:40:12 <Twey> const (x Π) <*> S <*> T, or something
23:40:57 <structuralist> unwrap the constructor? I'm not sure what you mean
23:41:38 <Twey> structuralist: It's the function you want to use as applicative, right?  You only need the newtype to give you that existential type to start with — after that you can throw it away
23:43:55 <structuralist> I want to apply e.g. Succ :: γ ⊢ N -> γ ⊢ N, except acting on Lifted N instead of γ ⊢ N ... I can't apply x to Succ
23:45:48 <qrada> hey, if i have: data P a b c = P { one :: a, two :: a, three :: a }, then I have, newtype X a b c = X { getX :: P a b c } .. how can I use X? X (1,2,3) keeps complaining.. im asking because I did this with a triplet and it works fine: newtype Z a b c = Z { getZ :: (a, b, c) }
23:45:49 <markovirc> Hello qrada
23:46:02 <Twey> structuralist: After applying the context?
23:46:06 <structuralist> A basic problem is that τ in "Lifted τ = ..." is of kind U that isn't *, and so doesn't include any functions. So any "Lifted (a -> b)" is impossible
23:46:20 <Twey> Mm
23:46:30 <supki> qrada: X (P 1 2 3)
23:46:57 <qrada> awesome@#$@!$ thanks
23:47:02 <supki> qrada: first you construct a P, then you wrap it in X
23:47:46 <qrada> ya.. cool.. im thinking about doing that because then I probably will get a bit more power with my data type, for example making it an instance of fmap etc
23:49:56 <structuralist> to be a bit more concrete, I'm writing stuff like
23:49:59 <structuralist> eval Zero          ξ = X (const NZero)
23:49:59 <structuralist> eval (Succ  n)     ξ = X (NSucc . x (eval n ξ))
23:51:11 <supki> qrada: not sure you win anything; unless you meant  data P a b c = P a b c  and  newtype X a = X (P a a a)
23:51:24 <supki> these types have different Functor instances
23:51:28 <structuralist> something like "NSucc <$> eval n ξ" ... would be much nicer
23:52:18 <Twey> structuralist: Well, you can make it a sort of pseudo-functor on types in your universe
23:52:57 <AfC> What on earth does «Ambiguous module name `Control.Monad.Error': it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2» result from. I have mtl listed, but never herd of monads-tf and certainly don't have it in the .cabal file
23:53:21 <structuralist> right, I'm wondering what perversion of the notion of functor is the right one to use here
23:54:00 <supki> AfC: what command do you run to get this error?
23:54:05 <Twey> class UFunctor (f ∷ U → ★) where ufmap ∷ (a → b) → f a → f b -- or something
23:54:32 <Twey> All the standard classes work on ★, so you'll have to define your own
23:54:50 <structuralist> hmm
23:54:52 <structuralist> okay I'll try that
23:57:00 <Twey> Hm, GHC doesn't like that
23:57:31 <Twey> Oh, of course it doesn't
23:57:38 <AfC> supki: cabal build
23:57:48 <Twey> You can't have a type (a → b) if a and b are in U
23:58:33 <structuralist> class NotAFunctor (f :: U -> *) where notFmap :: (γ ⊢ τ -> γ ⊢ τ') -> f τ -> f τ'
23:58:36 <structuralist> works
23:58:42 <structuralist> as in is accepted
23:58:47 <Twey> Yeah, that'll work
23:59:05 <Twey> You just can't use (τ → τ')
