00:04:13 <individual> got it compiling now
00:04:17 <individual> thanks anyway :)
00:05:02 <individual> but somebody please, please, please replace integer-gmp as default. It's horrible.
00:06:29 <Axman6> how is it horrible? it's ridiculously fast, which is usually a good thing
00:07:04 <akegalj> just curious, what do you think haskell platform will be ready for ghc 7.8 ?
00:08:09 <akegalj> what do you think when*
00:08:36 <individual> Axman6: it's known to break C libraries that use GMP.
00:09:39 <individual> what's the use of performance if your program segfaults :)?
00:09:44 <Axman6> well m3ga is working on a native haskell implementation of Integer, using things like karatsuba multiplication etc.
00:10:14 <Axman6> but it's probably a little way off, especially since he's still seeking permission from his employer to release the code
00:10:31 <individual> I read about that. I hope he succeeds.
00:10:39 <Axman6> me too
00:10:43 <Axman6> I want to play with the code
00:10:58 * hackagebot concurrent-state 0.2.0.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.2.0.0 (JoelTaylor)
00:10:58 * hackagebot cab 0.2.7 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.7 (KazuYamamoto)
00:18:28 <individual> nice. The build failed in libraries/base/GHC/Real.lhs:372:19 because divInteger and modInteger were not in scope.
00:20:53 * hackagebot BigPixel 1.2.0 - Image editor for pixel art  http://hackage.haskell.org/package/BigPixel-1.2.0 (ManuelChakravarty)
00:22:16 <individual> Integer.hs from integer-simple doesn't even export modInteger
00:22:55 <individual> nor divInteger
00:23:43 <individual> should I hack Real.lhs to use divmodinteger? :P
00:24:31 <individual> oh, newer versions of integer-simple DO have those functions. 7.6.3 version doesn't.
00:29:23 <individual> I'll try with git master of integer-simple
00:30:09 <individual> doesn't work either of course :)
00:30:27 <individual> libraries/integer-simple/GHC/Integer/Type.hs:812:22:Not in scope: `isTrue#'
00:32:25 <individual> the master version actually does use divmodinteger :)
00:35:11 <qrada> hey, I posted a little test code here if anyone with knowlege of threads/executeFile is able to chime in... I'm having a weird issue. I'm seeing child processes get 'stuck', but it seems to be random. I'm thinking it has to do with executing something within a thread. If so, does anyone have any suggestions? Basically, I have a thread pool which I'm sending messages too.. when a message is received, it forkOS/exec's a file and waits for that to return a status.. and 
00:35:18 <qrada> http://hastebin.com/veyinuvuci.hs
00:36:12 <qrada> when I don't use threads, i don't seem to see any stuck processes
00:36:26 <qrada> it seems to work as intended.. fork / exec / wait / continue
00:38:51 <supki> qrada: how do you compile the file?
00:39:06 <qrada> ghc -threaded forkexec.hs
00:48:06 <qrada> when i strace those children, they are just blocked in a 'futex'
00:48:26 <dleedev> Hi, why is it important that Parsec's GenParser monad is an instance of the MonadPlus typeclass?
00:48:49 <dleedev> is mplus or msum ever used?
00:49:09 <qrada> so if it's stuck in a futex i imagine that has something to do with locking used by a thread?
00:49:12 <qrada> i dno
00:50:54 <individual> dleedev = <|> is mplus
00:51:05 <startling> dleedev, it's not super important, especially in parsec, but it's good practice to make your things instances of all the classes in 'base' that apply to it.
00:51:10 <individual> I don't know why I put '=' in there
00:51:28 <startling> :t guard -- there's also this
00:51:29 <lambdabot> MonadPlus m => Bool -> m ()
00:51:34 <dleedev> startling: the icky thing is that mzero = fail "mzero"
00:52:10 <startling> dleedev, what's the implementation of 'fail'?
00:53:00 <dleedev> startling: I don't know
00:53:12 <individual> I copied divInteger and modInteger from a newer version of integer-simple and now I get "cannot find -lHSinteger-simple-0.1.1.0-ghc7.6.3"
00:54:34 <startling> dleedev: ok. it might not be something icky.
00:55:22 <dleedev> startling: just straight reading it sounds like mzero is not supported
00:57:03 <startling> dleedev: where is GenParser?
00:57:12 <dleedev> Parsec
00:57:58 <startling> dleedev, yes. where in Parsec?
00:58:27 <dleedev> Text.ParserCombinators.Parsec
00:58:51 <startling> dleedev: oh. that's a compatibility module. Are you using an old version of parsec?
00:59:05 <dleedev> I'm just reading this: http://book.realworldhaskell.org/read/using-parsec.html
00:59:17 <dleedev> it might be showing old code
00:59:49 <startling> ah, yeah. RWH is kind of out-of-date.
01:00:41 <startling> dleedev: ok, yes, it's not super important but it's good to know
01:00:45 <startling> if you want to use e.g. guard
01:00:57 <startling> dleedev: but N.B. that parsec is somewhat different nowadays
01:01:16 <dleedev> what's N.B.?
01:01:31 <startling> "nota bene" -- "note well"
01:20:31 <drbean> Does ghc-7.6.3 work only with Cabal-1.14?
01:21:37 <drbean> Why would cabal configure be running '/usr/bin/ghc --make ./Setup.hs -o ./dist/setup/setup -odir ./dist/setup -hidir ./dist/setup -i -i. -package Cabal-1.14.0'
01:22:03 <drbean> When I have Cabal-1.16.0.
01:22:17 <Fuuzetsu> *shrug*
01:22:24 <Fuuzetsu> 7.6.3 works fine with more than 1.14
01:22:30 <Fuuzetsu> you should be on 1.18 by now
01:23:04 <drbean> I have haskell-platform on Fedora 20.
01:26:29 <merijn> drbean: Which package are you configuring?
01:26:50 <drbean> gf, ie Grammatical Framework.
01:27:24 <drbean> I don't see any dependency on cabal-1.14 in gf.cabal.
01:28:41 <drbean> I wonder where the '-package Cabal-1.14.0' comes from.
01:29:39 <merijn> No clue, tbh
01:31:27 <haasn> “cabal install gf” :(
01:32:43 <drbean> Surprised. That's working.
01:32:52 <rtpg> haasn, there's a gf package apparently
01:35:01 <drbean> It appears to be downloading it. But I wanted to get it from github.
01:38:38 <Fuuzetsu> haasn: not sure that a gf with ‘OtherLicense’ is a good choice
01:39:38 <thomasd> Hi #haskell, can anyone point me to a downloadable version of the Cabal users' guide, or is a cabal incantation to obtain it?
01:40:00 <merijn> drbean: If you want to grab the github version, clone the repo, go to the directory and run "cabal install" in there?
01:41:21 <drbean> That was what I was doing. At least, I was running "cabal configure," but it was erroring out with "-package Cabal-1.14.0"
01:41:50 <Fuuzetsu> thomasd: it is only about 4 html pages, you could simply download them
01:42:30 <Fuuzetsu> Cabal.css  developing-packages.html  index.html  installing-packages.html  misc.html
01:44:15 <Fuuzetsu> thomasd: http://fuuzetsu.co.uk/misc/users-guide.zip
01:44:57 <qrada> supki: i think i may have figured it out.. in my test code, I put a sleep 1 before getProcessStatus.. and now im no longer seeing random stuck processes being created
01:45:30 <qrada> so , pid <- forkProcess $ executeFile () ... then sleep 1 , getProcessStatus True False pid
01:46:09 <qrada> when I go back to my old code though, I imagine that sleep 1 may be a problem.. but maybe not, maybe itll only block that thread
01:49:03 <qrada> ya that sleep 1 sucks but that's what it was.. so now maybe ill loop getProcessStatus
01:49:08 <qrada> ok ill stop talking to myself, gn folks
01:49:30 <Ralith> qrada: sleep 1 is better than looping, since looping eats up all the cpu
01:50:09 <Ralith> if you just want to block until something completes, maybe you should find another way to invoke it
01:50:34 <drbean> What's a good place to read about how cabal works up the ghc make command when you run 'cabal configure?'
01:52:06 <joejev> I am confused by this error: No instance for (MArray (,) (a0 (t0, t10) e0) m0), what exactly does this mean?
01:52:36 <qrada> Ralith: ya.. just a flood of waitpid's. not sure why this is even happening though.. ie, why I would need to add that sleep after forkProcess and before getProcessStatus.. it seems to only be an issue when im in a thread
01:54:52 <drbean> 'runhaskell Setup.hs configure -v' doesn't error out with '-package Cabal-1.14.0'.
01:55:44 <joejev> wow, my sleepy code is getting to be shit
01:55:57 <drbean> 'runhaskell Setup.hs configure -v --user'
01:58:00 <drbean> This machine had cabal-1.14 on it before. There could be something in ~/.cabal causing this.
02:00:11 <individual> wow I finally got ghc built with integer-simple
02:00:14 <merijn> qrada: You're trying to run another program and wait for its output?
02:00:54 <individual> 1) copy divInteger and modInteger from a newer version of integer-simple if you're building 7.6.3 2) disable dynamically linked libraries in mk/build.mk
02:01:35 <merijn> individual: Have you told people in #ghc this and/or created a ticket on trac?
02:01:51 <individual> no
02:02:14 <individual> something may have been my fault, I don't know
02:02:19 <individual> but I'll go on #ghc
02:02:46 <individual> merijn: or should I create a ticket?
02:03:03 <dleedev> hi, I've read that Arrow can be used to build a faster parser, instead of going through many `try` in parsec, which is expensive
02:03:04 <qrada> merijn: ya, but within some a thread from a thread pool
02:03:09 <qrada> im getting some weird behavior
02:03:23 <dleedev> can someone explain what Arrow does that makes it faster?
02:04:11 <merijn> qrada: You should probably not use forkProcess, it's rather shady (see docs), it only copies one thread
02:04:15 <kosmikus> Twey: have you been looking for me earlier? or was someone else?
02:04:27 <merijn> qrada: You should probably use createProcess: http://hackage.haskell.org/package/process-1.2.0.0/docs/System-Process.html
02:04:31 <qrada> merijn: ya.. what do you suggest?
02:04:36 <qrada> oooh, nice
02:04:38 <qrada> didn't see that
02:04:49 <qrada> cool, im about to pass out, i will get this working tomorrow and check that out
02:04:50 <qrada> thanks alot
02:05:06 <merijn> qrada: Bonus, that's portable to windows to, unlike System.Posix.Process
02:05:28 <merijn> individual: I'm not sure, it probably can't hurt, but might wanna ask in #ghc if this is worth a ticket
02:05:46 <merijn> individual: Especially if you have a concrete set of steps on how things can be fixed
02:05:47 <qrada> nice
02:06:17 <qrada> pc
02:08:02 <merijn> dleedev: See the paper by Swierstra and Duponcheel, "Deterministic, error-correcting combinator parsers"
02:08:20 <dleedev> merijn: thanks
02:08:28 <dleedev> merijn: but I was hoping for a quick answer :)
02:08:45 <dleedev> can you summarize it for me?
02:08:50 <quicksilver> dleedev: the arrow version can collect static information
02:08:59 <quicksilver> which can be used to statically prune dead branches in teh search tree
02:09:14 <quicksilver> it can deduce the 'first letter' of upcoming productions
02:09:17 <quicksilver> or token
02:09:52 <quicksilver> although these days people tend to prefer the applicative formulation to the arrow one I think
02:10:12 <dleedev> there's an applicative version that can also prune dead branches before trying them?
02:10:32 <dleedev> non-manually, of course
02:11:06 <dleedev> here's a simple applicative version that's manually tuned:
02:11:06 <dleedev> let parser = (++) <$> string "HT" <*> (string "TP" <|> string "ML")
02:11:43 <dleedev> but that's ugly... I'd rather do: string "HTTP" <|> string "HTML"
02:12:57 <Fuuzetsu> I wonder if it'd be viable to design a library which did this kind of optimisation (less backtracking, right?) automatically
02:13:42 <thomasd> Fuuzetsu: thanks (sorry, I was away for a while)
02:13:42 <quicksilver> no backtracking at all in this case
02:14:00 <quicksilver> because the first-sets of "TP" and "ML" are disjoint
02:14:04 <quicksilver> being {T} and {M}
02:14:11 <quicksilver> so you can deterministically choose the right branch
02:14:30 <twiceler> May as well just use something like Alex, right?
02:14:32 <quicksilver> yes, you can design libraries which do this automatically
02:14:57 <quicksilver> but I don't remember which ones do it
02:14:58 <Fuuzetsu> I mean turn "HTTP" <|> "HTML" into ‘(++) <$> "HT" <*> ("TP" <|> "ML")
02:15:49 <eikke> Fuuzetsu: what would you do with data D = HTTP | HTML; (pure HTTP <* "HTTP") <|> (pure HTML <* "HTML") ?
02:16:10 <quicksilver> http://www.cs.uu.nl/wiki/HUT/ParserCombinators
02:16:19 <Fuuzetsu> unrelated question: I often see folk include category diagrams in their posts which have obviously been generated with some *TeX package, what are you guys using?
02:16:54 <Fuuzetsu> eikke: Probably nothing, depends on the library design
02:17:00 <Fuuzetsu> it'd optimise when it could or it wouldn't
02:17:36 <eikke> then I think you'll only cover a rather small set of parsing code (i.e. string to string)
02:18:33 <Fuuzetsu> quicksilver: Interesting, is this still being used somewhere? Everything seems to use Alex or [Atto]parsec nowadays
02:18:41 <quicksilver> you definitely cover that case
02:19:02 <eikke> Fuuzetsu: it is being used
02:19:38 <Fuuzetsu> Oh, it had an update in Nov 2013, great
02:19:46 <quicksilver> string "HT" *> ((HTTP <$ string "TP") <|> (HTML <$ string "ML"))
02:19:54 <Fuuzetsu> This looks great, I wish I heard about it before
02:20:08 <eikke> quicksilver: smart ;)
02:20:17 <eikke> didnt know about <$ actually
02:20:20 <quicksilver> I might have got <$ wrong I always forget which way around it is
02:20:24 <quicksilver> :t (<$)
02:20:25 <lambdabot> Functor f => a -> f b -> f a
02:20:31 <quicksilver> no, I got it right :)
02:20:50 <Fuuzetsu> @src (<$)
02:20:50 <lambdabot> (<$) = (<$>) . const
02:21:15 <johnw> aka fmap (const a) f == a <$ f
02:21:54 <quicksilver> or "pure a <* f"
02:21:55 <eikke> I should remember that and fixup my existing parsers :D
02:21:58 <quicksilver> which is the form eikke used
02:22:37 <quicksilver> or "f >> return a" as people more used to monads might write it
02:26:03 * hackagebot tasty-rerun 1.1.0 - Run tests by filtering the test tree depending on the result of previous test  runs  http://hackage.haskell.org/package/tasty-rerun-1.1.0 (OliverCharles)
02:26:48 <dleedev> quicksilver: so uu-parsinglib looks like an optimized version of parsec, is that right?
02:27:02 <dleedev> with error correction, I think
02:27:36 <Fuuzetsu> dleedev: It doesn't seem like it does although it does state that you can replicate Parsec with the ‘<<|>’ combinator they provide (greedy)
02:27:55 <daGrevis> is haskell code a data?
02:28:00 <quicksilver> dleedev: it's not really like parsec, no
02:28:13 <quicksilver> dleedev: except in some parts of its API, which is fairly generic
02:28:20 <Fuuzetsu> daGrevis: Hm?
02:28:23 <haasn> Fuuzetsu: MIT license, clearly
02:28:29 <dleedev> quicksilver: ah, too bad. parsec is so simple.
02:28:45 <daGrevis> Fuuzetsu, https://en.wikipedia.org/wiki/Homoiconicity
02:28:58 <Axman6> goffrie: no
02:29:01 <Axman6> uh, daGrevis
02:29:05 <Fuuzetsu> daGrevis: I guessed that's what you mean and I don't see where you'd get that idea.
02:29:08 <johnw> quicksilver: good point about f >> return a; I didn't realize I could be using <$ in those cases too
02:29:15 <dleedev> quicksilver: have you used uu-parsinglib before?
02:29:25 <dleedev> daGrevis: no
02:29:47 <daGrevis> ok, thanks. that's what I thought
02:29:55 <Fuuzetsu> :t ($>)
02:29:56 <lambdabot>     Not in scope: `$>'
02:29:57 <lambdabot>     Perhaps you meant one of these:
02:29:57 <lambdabot>       `$' (imported from Data.Function),
02:30:00 <Fuuzetsu> ehh…
02:30:02 <dleedev> is there any homoiconic language besides lisp?
02:30:06 <Fuuzetsu> :t flip (<$)
02:30:07 <lambdabot> Functor f => f b -> a -> f a
02:30:11 <Fuuzetsu> dleedev: some Prologs
02:30:14 <daGrevis> dleedev, i don't think so, no
02:30:25 <Fuuzetsu> There's a list on that Wiki article IIRC
02:31:03 <dleedev> lisp is beautiful as long as your AST is never nested more than 4 levels deep
02:31:09 <quicksilver> dleedev: nope
02:31:27 <daGrevis> dleedev, the same applies to any language with nesting
02:31:45 <Fuuzetsu> I see where this is heading, let's stop before we go into full blown argument
02:32:05 <dleedev> daGrevis: that's true
02:32:15 * Fuuzetsu dislikes Lisps as much as the next guy
02:32:17 <daGrevis> i won't start flame ;P
02:32:41 * yayutf likes lisp
02:32:47 * johnw loves lisp
02:33:00 <Fuuzetsu> johnw: You write ELisp, you should be scared for life
02:33:02 <haasn> I just read SICP! Well, sort of. I skipped most of it :(
02:33:08 <johnw> :)
02:33:11 <merijn> haasn: High five! :)
02:33:23 * Axman6 is watching SICP as we speak
02:33:28 <Fuuzetsu> haasn: Well, what did you think?
02:33:30 <merijn> I stopped reading quite quick, because I wasn't learning much news
02:33:34 <Axman6> but, it's not making me want to use lisp
02:33:50 <merijn> I haven't found a good "lisp/scheme for functional programmers" quick start, though
02:34:25 <Fuuzetsu> merijn: Isn't it because it's all ‘lisp/scheme is a better language than yours’ guides/tutorials/whatever?
02:34:26 <HugoDaniel> i stopped reading when youtube became mainstream
02:34:40 <haasn> Fuuzetsu: what merijn said; I learned a bit about lisp's ability to work with syntax trees as ordinary data but I pretty much knew that before the fact; for the most part I was cringing at the lack of typing and pattern matching
02:34:44 <haasn> “lack”
02:34:54 <Fuuzetsu> ``lack''
02:35:03 <boothead> @pl emailWithDefault e tr = TR._email tr <|> e
02:35:03 <lambdabot> emailWithDefault = flip ((<|>) . TR._email)
02:35:19 <yayutf> Fuuzetsu: Elisp is a particularly gross lisp
02:35:33 <johnw> haasn: it has pattern matching
02:35:37 <tdammers> is it worse than CL?
02:35:40 <Aleksejs> I'm trying to understand the term "homoiconicity" by googling. And I see that haskell actually can give you anything that homoiconicity does, but still, haskell is not homoiconic. Maybe someone smart could clarify this for me?
02:35:42 <Fuuzetsu> tdammers: yes
02:35:45 <tdammers> dear god
02:35:54 <merijn> Fuuzetsu: No, it's just all "basic people who don't know programming intro's", instead of stuff that help me do something useful
02:36:04 * hackagebot hakyll 4.4.3.2 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.4.3.2 (JasperVanDerJeugt)
02:36:11 <tdammers> btw, I never understand why anyone would consider lisp-2 a good idea
02:36:13 <merijn> haasn: Racket has typed Racket ;)
02:36:20 <haasn> johnw: all I saw is stuff like (if (null? x) (foo) (bar (car x) (cdr x)) etc.
02:36:30 <johnw> haasn: see `destructuring-bind'
02:36:33 <haasn> which to me looks like if null x then foo else bar (head x) (tail x)
02:36:37 <yayutf> Aleksejs: Haskell doesn't give you everything homoiconicity does; languages with minimal syntax tend to have a lot of metaprgrams, which are painful in other languages
02:36:38 <Fuuzetsu> Aleksejs: It just means that homoiconicity has a very limited usefulness as far as ‘oh, we have to use homoiconicity here and nothing else will do’ goes
02:37:00 <Fuuzetsu> merijn: Have you tried using Typed Racket? It's a piece of shit.
02:37:16 <ethercrow> typed clojure is painful
02:37:18 <merijn> Fuuzetsu: No, because I can't find a good Racket intro that doesn't bore me to tears :)
02:37:21 <yayutf> Fuuzetsu: i know people who advocate it as a good thing :(
02:37:23 <quicksilver> Aleksejs: homoiconicity makes it easy to write programs whose input and output are programs
02:37:30 <johnw> haasn: in ELisp we have "pcase"
02:37:41 <merijn> yayutf: Typed clojure will make it easier to convince clojure hacker to use haskell :p
02:37:49 <quicksilver> Aleksejs: it's quite hard in haskell to write a 'function' of type "Program -> Program" or "Function -> Function"
02:37:56 <yayutf> merijn: not as far as I've seen!
02:38:11 <tdammers> quicksilver: Function -> Function isn't that hard, is it?
02:38:15 <haasn> johnw: then maybe SICP should be rewritten to get rid of conditions/destructors in favor of pattern matching! :)
02:38:17 <yayutf> typed clojure seems to mainly entrench clojure people in the idea that types are annoying
02:38:20 <quicksilver> however that style of programming is rather unstructured and many people consider it unwise
02:38:37 <Fuuzetsu> merijn: Honestly, not worth learning. Check out this cool type for ‘map’: (All (c a b ...) (case-> ((a -> c) (Pairof a (Listof a)) -> (Pairof c (Listof c))) ((a b ... b -> c) (Listof a) (Listof b) ... b -> (Listof c))))
02:38:37 <Fuuzetsu>  
02:38:38 <quicksilver> tdammers: it is, if you read the secret subtext in my Function
02:38:52 <yayutf> quicksilver: but when it's what you want, it tends to -really- be what you want
02:38:57 <quicksilver> tdammers: it's about syntactic representation, not semantics
02:38:59 <daGrevis> Aleksejs, homoiconicity is like meta-programming and reflection on steroids
02:39:08 <tdammers> quicksilver: right. carry on.
02:39:12 <merijn> Fuuzetsu: I wanted to learn racket in general as a "I should probably know *a* Lisp/Scheme and Racket seems the most interesting one"
02:39:13 <haasn> Aleksejs: the closest thing Haskell has to metaprogramming is TH which is basically Syntax -> Syntax
02:39:25 <yayutf> and directly manipulating program structure is -handy- for things like refactoring tools, inspectors/browsers, etc
02:39:29 <haasn> but it's compile time only
02:39:32 <quicksilver> yes, TH is a reasonable stab at structured metaprogramming
02:39:41 <merijn> haasn: Don't forget Typed TH which is TypedSyntax -> TypedSyntax
02:39:44 <quicksilver> not as clever as the staged typed meta-ml stuff
02:40:36 <haasn> It wouldn't allow you to transform functions/syntax trees at runtime, say
02:40:43 <Aleksejs> ok, thanks guys, now I see the difference
02:40:44 <Fuuzetsu> merijn: Yeah, I'm going to properly sit down and down a few Lisp books in the next couple of months just for the sake of it but after trying Typed Racket, it's certainly not going to be that. I'll probably go with GNU Guile
02:40:54 <merijn> Ooh! More than half a year after finding it, it seems my reactive-banana bug may be fixed \o/
02:41:07 <yayutf> merijn: yay!
02:41:13 <Fuuzetsu> Half a year is a pretty good turn-around…
02:41:21 <merijn> Fuuzetsu: non-typed Racket has cool stuff, though
02:41:25 <haasn> Though at this point I actually ask myself: Doesn't the ability to transform syntax trees at runtime horrible break referential transparency?
02:41:27 <yayutf> Fuuzetsu: hm, guile's pretty weird in its own set of ways; have you considered sbcl or chicken scheme?
02:41:30 <haasn> I'm not sure I would want that, truth be told
02:41:41 <Fuuzetsu> merijn: Yeah, so I hear but there's a Guile project I want to dabble in a bit.
02:41:42 <tdammers> quicksilver: well, TH still draws a pretty hard line between "Haskell code that runs at compile time and outputs Haskell AST" and "Haskell code that runs at run-time" - Lisp completely eradicates this distinction
02:41:52 <Fuuzetsu> same to yayutf
02:42:05 <yayutf> Fuuzetsu: ah, good reason
02:42:09 <quicksilver> haasn: yes, absolutely.
02:42:34 <merijn> Fuuzetsu: Considering the subtlety of the bug and the fact that it'd have taken more than a year for me to fix it myself, I'm okay with it :p
02:42:37 <quicksilver> haasn: (note also that deriving Show, Ord, Enum break important code rewriting identities)
02:42:52 <haasn> quicksilver: what do you mean?
02:43:34 <quicksilver> haasn: for example, it is an obvious equational rule of haskell that constructor name doesn't matter, and renaming constructors throughout a program is safe and will not change semantics. "Alpha-conversion"
02:43:34 <merijn> haasn: I do sometimes want that ability to horribly break referential transparency, but then again I also like the ability to do really awful assembly hacks :p
02:44:23 <quicksilver> haasn: however, with data A = B | C deriving Show; f :: A -> String; f = show; then we have a program whose semantic changes if we rename the constructor A.
02:44:29 <haasn> quicksilver: oh, yes, of course. Makes sense :)
02:44:30 <quicksilver> ..constructors of A.
02:44:58 <quicksilver> pretty much all metaprogramming conceits break "obvious" rules of equational reasoning
02:45:24 <haasn> Interesting technicality, though I don't think the sky will collapse due to derived Show instances being dependent on the constructor names ;)
02:45:26 <quicksilver> generally in ways which "don't matter". Until you try to apply them automatically or extensively. And then it matters after all.
02:45:56 <yayutf> quicksilver: hence people who really like metaprogramming considering equational reasoning more of a curiosity than a driving goal ;-)
02:46:03 <quicksilver> the sky has, thus far, remained standing. But I seldom metaprogram without an umbrella.
02:47:12 <haasn> quicksilver: worst comes to worst we can use one of our powerful “derivation” libraries to provide a custom derivation that gives us the logic we want, irrelevant of the actual weird names our generated constructors might have
02:51:45 <matxyz> @pointful
02:51:45 <lambdabot> Error: expected a Haskell expression or declaration
02:51:50 <augur_> what does metaprogramming give us anyways
02:51:55 <matxyz> @pointful transform k z = reverse (foldr concat [] z)
02:51:55 <matxyz> 						where concat x y = y ++ [fst(head(filter (\a -> snd a == k-1) (zip x [0..])))]
02:51:55 <lambdabot> transform k z = reverse (foldr concat [] z);
02:52:34 <matxyz> @pointful y ++ [fst(head(filter (\a -> snd a == k-1) (zip x [0..])))]
02:52:34 <lambdabot> (y ++ ([fst (head (filter (\ a -> (snd a) == (k - 1)) (zip x [0 ..])))]))
02:52:45 <matxyz> @pl y ++ [fst(head(filter (\a -> snd a == k-1) (zip x [0..])))]
02:52:45 <lambdabot> y ++ [fst (head (filter ((k - 1 ==) . snd) (zip x [0..])))]
02:53:23 <matxyz> @pl (filter (\a -> snd a == k-1) (zip x [0..]))
02:53:23 <lambdabot> filter ((k - 1 ==) . snd) (zip x [0..])
02:53:48 <fsfs_> @pl filter(flip(==) k)
02:53:49 <lambdabot> filter (k ==)
02:53:52 <matxyz> @pl fst(head(filter (\a -> snd a == k-1) (zip x [0..])))
02:53:52 <lambdabot> fst (head (filter ((k - 1 ==) . snd) (zip x [0..])))
02:54:04 <fsfs_> @pl f1 k = filter(flip(==) k)
02:54:04 <lambdabot> f1 = filter . (==)
02:55:35 <matxyz> @pl  concat x y = y ++ [fst(head(filter (\a -> snd a == k-1) (zip x [0..])))]
02:55:35 <lambdabot> concat = flip (++) . return . fst . head . filter ((k - 1 ==) . snd) . flip zip [0..]
02:55:58 <matxyz> @pl transform k z = reverse (foldr concat [] z)
02:55:59 <lambdabot> transform = const (reverse . foldr join [])
02:57:10 <matxyz> @pl transform k z = reverse (foldr concat [] z)
02:57:10 <lambdabot> transform = const (reverse . foldr join [])
02:57:10 <matxyz> where concat x y = y ++ [fst(head(filter (\a -> snd a == k-1) (zip x [0..])))]
02:58:34 <matxyz> @pl transform k z = reverse (foldr (\x y -> y ++ [fst(head(filter (\a -> snd a == k-1) (zip x [0..])))]) [] z)
02:58:34 <lambdabot> transform = (reverse .) . flip foldr [] . (flip (++) .) . flip flip [] . (((:) . fst . head) .) . (. flip zip [0..]) . filter . (. snd) . (==) . subtract 1
03:01:56 <jonkri> Does anyone have any experience with using Haskell in a MDSD (model-driven software development) context? I guess TH would be one kind of code generator that could be used, but are there others?
03:03:47 <jonkri> What kind of Haskell generators are there, and would any of these be suitable for modeling?
03:17:16 <ski> augur_ : a way to manually program "partial evaluation"
03:17:55 <augur_> ski: who what
03:20:20 <skypers_> hi
03:20:25 <johnw> hi
03:20:46 <skypers_> I’m looking for a function like groupBy, but which apply the predicate on the left generated-on-the-fly list
03:21:17 <skypers_> the idea is simple: I have a list of words, and I like to create a list of lines truncated at 80 caracters
03:21:38 <skypers_> @let eightify = groupBy (\a b -> length a + length b <= 80)
03:21:40 <lambdabot>  Defined.
03:21:48 <skypers_> this function fails
03:22:03 <ski> <augur_> what does metaprogramming give us anyways
03:22:11 <skypers_> because when the predicate passes, a new list is generated, but the next predicate is not applied on the generated list
03:22:15 <augur_> ski: ah. how so?
03:22:30 <johnw> skypers_: I'm really not following you at all
03:23:12 <skypers_> > eigthify (words "hello, yes, this is dawg, I’m a very nasty dawg because I poop in the street and I think it might be 80 caracters long now so let’s try")
03:23:14 <lambdabot>  Not in scope: `eigthify'
03:23:14 <lambdabot>  Perhaps you meant `eightify' (line 158)
03:23:20 <skypers_> > eightify (words "hello, yes, this is dawg, I’m a very nasty dawg because I poop in the street and I think it might be 80 caracters long now so let’s try")
03:23:22 <lambdabot>  [["hello,","yes,","this","is","dawg,","I\8217m","a","very","nasty","dawg","b...
03:23:23 <ski> augur_ : you can manually perform the BTA and staging of the intended (off-line) partial evaluation in meta programming
03:23:32 <skypers_> johnw: it’s quite simple
03:23:43 <skypers_> the function chunksOf cuts words
03:23:48 <skypers_> chunksOf 80 "my text…"
03:23:56 <augur_> ski: i dont know enough about metaprogramming to know what that means :(
03:23:58 <augur_> but ok.
03:24:01 <skypers_> it will lines the text cutting words
03:24:03 <johnw> you want to write a word-wrapping function?
03:24:07 <skypers_> yep
03:24:10 <johnw> i see
03:24:29 <ski> "BTA" means "Binding-Time Analysis" -- it's about deciding which parts of a program to "perform early" and which parts to perform "late"
03:24:31 <johnw> interesting programming problem
03:24:43 <skypers_> I thought groupBy would have done it really simple
03:24:55 <skypers_> but I might misunderstand groupBy
03:25:05 <skypers_> [a,b,c,d,e]
03:25:08 <johnw> should be pretty easy with a fold over words
03:25:31 <skypers__> a fold over words, yes
03:25:41 <ski> in off-line partial evaluation, you first decide which parts of the program to specialize are to be early and which part are to be late -- only after that do you actually specify the early inputs
03:25:49 <ski> and then the early parts of the programs run on the early input, generating (residualizing) a remainder late program, which will later be applied to the late input
03:26:20 <skypers__> my version is actually working with a foldM + runStatet to hold the cursor position
03:26:21 <skypers__> -t
03:26:40 <skypers__> flip runState 0 (foldM fromWord ([],[]) x)
03:26:43 <skypers__> but it’s quite ugly
03:26:48 <skypers__> the pair
03:27:22 <skypers__> another way to do it is to write a cumulative version of groupBy
03:27:35 <quicksilver> nothing ugly about folding over a pair
03:27:37 <skypers__> by applying the predicate on the last left list that satisfied the predicate
03:27:43 <skypers__> it’s not over a pair
03:27:45 <skypers__> it’s a list
03:27:50 <skypers__> the accumulator is a pair
03:27:54 <ski> otoh, in on-line partial evaluation, the decisions about which parts of the program to specialize (perform early) and which parts to perform late (so residualize early) are only made when the early input is already known -- so e.g. in this variant, you can decide to specialize a multiplication e.g. in case you know at least one factor is a literal zero (or has already specialized to a literal value zero) -- thus depending crucially on the *values* of
03:27:56 <quicksilver> that's what I meant
03:27:59 <skypers__> oh ok
03:28:00 <quicksilver> bad use of the word 'over'
03:28:15 <quicksilver> nothing wrong - in general - with needing a tuple for your accumulator
03:28:18 <ski> (possibly cut off "... -- so e.g. in this variant, you can decide to specialize a multiplication e.g. in case you know at least one factor is a literal zero (or has already specialized to a literal value zero) -- thus depending crucially on the *values* of the early input")
03:28:24 <ski> augur_ : makes any sense ?
03:28:29 <quicksilver> in that *particular* case you're already in a state monad
03:28:41 <quicksilver> so you could push the part of it into the state if you wanted to
03:28:44 <augur_> skypers__: no :D
03:28:46 <ski> @src (^)
03:28:46 <lambdabot> x ^ 0            =  1
03:28:46 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
03:28:46 <lambdabot>   where f _ 0 y = y
03:28:46 <lambdabot>         f x n y = g x n
03:28:46 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
03:28:46 <augur_> but thats ok
03:28:48 <lambdabot>                       | otherwise = f x (n-1) (x*y)
03:28:50 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
03:28:51 <skypers__> what no
03:29:02 <skypers__> oh ok
03:29:04 <skypers__> wrong dude
03:29:15 <skypers__> quicksilver: yeah
03:29:25 <skypers__> I’ll try to write a proper version after lunch
03:29:30 <skypers__> talk to you later
03:34:19 <ski> augur_ : consider specializing `\x -> x ^ 6' to `\x -> let y1 = x * x in let x1 = x * x in let x2 = x1 * x1 in let y2 = x2 * y1 in y2'
03:34:44 <ski> augur_ : here `6' is the early input to `x ^ 6', and `x' is the late input
03:34:54 <augur_> ski: i'd rather consider going to bed x3
03:34:55 <augur_> night ski
03:35:01 <ski> ok, night
03:35:04 <augur_> btw ski: multicategories!
03:35:22 <ski> augur_ : but multiple alternative results ?
03:35:48 <augur_> ski: i think those are polycategories or something
03:35:55 * ski turns expressions on their head
03:36:00 <augur_> :p
03:36:01 <augur_> night
03:37:27 <mada> in the definition of (^), is there an advantage to writing g in an inner where, instead of at the same level as f?
03:38:20 <johnw> it has access to the variables passed to f
03:38:28 <johnw> otherwise, you'd need to pass them on to g
03:38:39 <mada> johnw: right, thank you
03:38:47 <henk> Can anyone recommend vim plugins for developing in haskell? My searchs all seem to strongly point to http://projects.haskell.org/haskellmode-vim/ but that project seems a little unmaintained and I would like to know if there is anything maintained, more modern or if haskellmode is still recommendable.
03:39:41 <quicksilver> johnw: but weirdly two of them are passed...
03:39:44 <quicksilver> it's a bit strange
03:39:54 <johnw> quicksilver: huh?
03:40:08 <quicksilver> where g x n
03:40:14 <johnw> ah, I see
03:40:16 <johnw> yeah, that is odd
03:40:17 <quicksilver> ^^ it doesn't need x and n
03:40:23 <quicksilver> it has access to them anyway
03:40:35 <quicksilver> if you were just going to pass them for style reasons, then why not pass y?
03:40:51 <quicksilver> also, why not just inline that guard into the defn of f directly
03:41:00 <quicksilver> it's a very strangely written bit of code
03:41:36 <johnw> let's vote it off the island
03:45:03 <akegalj> henk: i'm using https://github.com/dag/vim2hs and it works great
03:47:48 <henk> akegalj: Thank you
03:59:40 <TovenaarKlus> henk, akegalj: I used to run vim2hs but it was a bit sluggish at times.. Could be me, however.
04:09:03 <Drezil> o/ how do i add a library to the linking-stage of GHC?
04:09:34 <Drezil> i think i found my error -.-
04:26:12 * hackagebot digestive-functors 0.7.0.0 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.7.0.0 (JasperVanDerJeugt)
04:31:12 * hackagebot digestive-functors-blaze 0.6.0.3 - Blaze frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-blaze-0.6.0.3 (JasperVanDerJeugt)
04:31:14 * hackagebot digestive-functors-happstack 0.6.1.0 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.6.1.0 (JasperVanDerJeugt)
04:31:16 * hackagebot digestive-functors-heist 0.8.4.1 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.8.4.1 (JasperVanDerJeugt)
04:31:18 * hackagebot digestive-functors-snap 0.6.1.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.6.1.0 (JasperVanDerJeugt)
04:37:35 <Itkovian> :)
04:48:06 <eikke> mm_freak: here's my final take: http://lpaste.net/98846
04:59:56 <Arjunax> Hi Guys, this might be a stupid question I want a function like that f :: Int -> [[Int]] which will generate all possible lists over the Alphabet {1,0} with length of the first argument I guess it's done with list-comprehension, but I can't figure out how please help :)
05:00:26 <Arjunax> like, if I do call "f 2" I get [[0,0] [0,1], [1,0], [1,1]]
05:01:20 <ski> @type (`replicateM` [0,1])
05:01:21 <lambdabot> Num a => Int -> [[a]]
05:01:26 <ski> > (`replicateM` [0,1]) 2
05:01:27 <lambdabot>  [[0,0],[0,1],[1,0],[1,1]]
05:01:28 <ski> > (`replicateM` [0,1]) 3
05:01:30 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
05:01:49 <Arjunax> wow this is awesome! Thanks! Now I only need to understand how it works
05:01:53 <Arjunax> thanks big time :)
05:01:54 <Aleksejs> > replicateM 2 [0..1]
05:01:56 <lambdabot>  [[0,0],[0,1],[1,0],[1,1]]
05:02:25 <ski> Arjunax : hehe, it's probably better to write the list-comprehension (e.g.) version first
05:03:15 <ski> Arjunax : consider e.g. how if you had `[[0,0],[0,1],[1,0],[1,1]]', you could extend this in one "step", to make it `[[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]'
05:03:21 <Arjunax> I thought about list-comprehension too, but I just can't find out how it works
05:03:29 <ski> that step could be useful in your recursive case
05:04:20 <ski> the trick is finding a "smaller instance" of the same problem you're trying to solve, in the greater problem -- and then figuring out how to "bridge" between those two
05:05:13 <Arjunax> yes, I just need some time, but I see, how this will bring me to the solution
05:05:41 <ski> iow, how to convert input arguments to proper smaller input arguments for the smaller instance(s), then call recursively on that (/those) smaller instance(s), finally piece together the right result of the big problem from the result(s) of the small problem(s) (and possibly also the original inputs to the big problem)
05:06:15 * hackagebot egison-tutorial 3.2.2 - A Tutorial Program for The Programming Language Egison  http://hackage.haskell.org/package/egison-tutorial-3.2.2 (SatoshiEgi)
05:06:22 <ski> you'll also need an appropriate base case that fits together with this
05:06:41 <ski> (generally, one should strive to make the base case(s) "as simple as possible, but no simpler")
05:07:47 <ski> Arjunax : also, you'll need to decide on an ordering for the lists .. it might be that you can generate your lists more easily in another order than the one given by `replicateM' above
05:09:00 <ski> (e.g. `[[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1],[1,1,1]]' and `[[0,0],[1,0],[0,1],[1,1]]' would be another potentially sensible order)
05:09:02 <Arjunax> I see, I'll tell you when I find my own solution, but it might take some time, as I am not yet very good in this
05:09:12 <ski> practice makes perfect :)
05:09:12 <Arjunax> but I understand what you are saying
05:14:40 <Arjunax> well I guess this can be done much better
05:14:51 <Arjunax> but thanks to you ski I found a solution
05:14:53 <Arjunax> generateAll :: Int -> [[Int]]
05:14:53 <Arjunax> generateAll 1 = [[1], [0]]
05:14:53 <Arjunax> generateAll n =  [c:b | b <- generateAll (n -1), c <- [1,0]]
05:15:31 <Arjunax> now this must also be possible within one single list-comprehension right? :)
05:16:40 <ski> > let generateAll :: Int -> [[Int]]; generateAll 1 = [[1], [0]]; generateAll n =  [c:b | b <- generateAll (n -1), c <- [1,0]] in generateAll 1
05:16:40 <Arjunax> but this solution works for me now :) Thanks again ski for your nice help <3
05:16:41 <lambdabot>  [[1],[0]]
05:16:43 <ski> > let generateAll :: Int -> [[Int]]; generateAll 1 = [[1], [0]]; generateAll n =  [c:b | b <- generateAll (n -1), c <- [1,0]] in generateAll 2
05:16:44 <lambdabot>  [[1,1],[0,1],[1,0],[0,0]]
05:16:47 <ski> > let generateAll :: Int -> [[Int]]; generateAll 1 = [[1], [0]]; generateAll n =  [c:b | b <- generateAll (n -1), c <- [1,0]] in generateAll 3
05:16:48 <lambdabot>  [[1,1,1],[0,1,1],[1,0,1],[0,0,1],[1,1,0],[0,1,0],[1,0,0],[0,0,0]]
05:17:29 <ski> Arjunax : one small problem (related to my "as simple as possible, but no simpler" quip) :
05:17:33 <ski> > let generateAll :: Int -> [[Int]]; generateAll 1 = [[1], [0]]; generateAll n =  [c:b | b <- generateAll (n -1), c <- [1,0]] in generateAll 0
05:17:34 <lambdabot>  *Exception: stack overflow
05:17:49 <Arjunax> ohh yes, you are right
05:18:07 <Arjunax> so I have to add generateAll 0 = []
05:18:25 <Maior> apologies for the slight OT, but is there a term for / what's a term for a type system where you can do "f :: Int -> Int, g :: a -> a, g (Int x) = f x, g y = y"?
05:18:49 <ski> it makes sense to pass `0' (a list with number of elements being zero makes sense generally, and also happens to make sense in this case, even though it's perhaps not that "useful" on its own -- it's still not incorrect)
05:19:18 <ski> Arjunax : not quite
05:20:15 <Arjunax> mhm
05:20:34 <Feuerbach> Maior: that looks like ordinary ad-hoc overloading to me. You can do that in Haskell (with slightly different syntax and types)
05:20:41 <ski> Arjunax : `generateAll 0' should return a list of all possible lists of length zero, with each element in those lists either being `1' or `0'
05:20:57 <ski> Arjunax : how many such lists of length zero are there ?
05:21:15 <Arjunax> well you are right it needs to be [[]]
05:21:19 <ski> yes
05:21:22 <Arjunax> :)
05:21:31 <Maior> Feuerbach: if that's doable, and g still has type a -> a, then is it really valid to say "you know what const does from the type"?
05:21:36 <ski> Arjunax : now, the nice thing is that you can simplify your code
05:21:46 <ski> Arjunax : do you see how ?
05:21:52 <Arjunax> Thats what I thought xD
05:22:00 <Feuerbach> Maior: as I said, the type will be a bit different (it will have a class constraint)
05:22:15 <Arjunax> give me some time to think about it
05:22:18 <Arjunax> :)
05:22:29 <Feuerbach> Maior: is the type being exactly a -> a important to you?
05:23:01 <Arjunax> I can just kick this line : generateAll 1 = [[1], [0]]
05:23:03 <Arjunax> :)))
05:23:05 <Maior> Feuerbach: yes
05:23:23 <Arjunax> generateAll 0 = [[]]
05:23:24 <Maior> Feuerbach: because I'm not convinced by the statement "you know what const must do because of the type signature"
05:23:24 <Arjunax> generateAll n =  [c:b | b <- generateAll (n -1), c <- [1,0]]
05:23:28 <Arjunax> this looks already quite nice
05:23:32 <Maior> I mean, it feels "about right"
05:23:43 <Maior> but if you can define g as I did...
05:23:55 <Maior> (I may be getting too hung up on a technicality / verbal shortcut)
05:24:02 <ski> Arjunax : i mention this, because it's good habit to think about the corresponding thing for other recursions as well, attempting to remove unneeded (and thus redundant) code
05:24:11 <ski> Arjunax : indeed :)
05:24:22 <Feuerbach> Maior: well, that statement is presumably about Haskell (and still it's *almost* valid). No doubt you can invent your own language where it will be invalid
05:24:35 <Maior> Feuerbach: sure
05:24:39 <ski> (you may have heard of "DRY" - "Don't Repeat Yourself")
05:24:41 <Feuerbach> Maior: I think the term you're looking for is non-parametricity
05:24:52 <Maior> Feuerbach: ah cheers
05:25:22 <Arjunax> yep :)
05:26:26 <ski> Arjunax : anyway, you can't always "push back" the definition like this towards "more trivial/useless base case(s)", but you surprisingly often can (and it's usually worthwhile to do it, simplifying the code, apart from making it more general, also work in trivial cases that people might not write explicitly, but which could still happen implicitly)
05:27:01 <Arjunax> I see
05:27:47 <ski> e.g., if you call `generateAll n' from somewhere, instead of having to check for the trivial case `n == 0' manually, you can just pass on `n' to `generateAll', and it'll Do The Right Thing, even in case `n' is zero
05:28:37 <Arjunax> right, makes sense
05:28:45 <ski> sometimes it's not so clear what the Right Thing is for these trivial cases -- but it can often be deduced from the recursive case(s) and the "almost trivial" case(s) (like your `generateAll 1' case above, which is often easier to think of at first for humans)
05:29:08 <ski> with some practice, you'll find it easier to write the "trivial" case immediately
05:30:15 <ski> btw, the point about "trivial" cases also holds for data structures : it can help to introduce a trivial case into it, as an aid to simplifying implementation (and simplifying refactoring code using the data structure)
05:31:19 <ski> i believe Wadler had a pretty-printing paper where he introduced a case for an "empty document" to pretty-print
05:32:32 <Fuuzetsu> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
05:33:44 <ski> hm, yes
05:34:07 <cmiller_> Is there an analog of replicateM for applicative?
05:34:34 <ski> "A prettier printer" by Philip Wadler in 1997-04 & 1998-03 at <http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#prettier>
05:34:43 <ski> Arjunax : in case you're interested ^
05:35:02 <ski> @hoogle replicateA
05:35:03 <lambdabot> Data.Sequence replicateA :: Applicative f => Int -> f a -> f (Seq a)
05:35:19 <ski> @hoogle Applicative i => Int -> i a -> i [a]
05:35:21 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
05:35:21 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
05:35:21 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
05:35:37 <Cale> :t foldr (pure []) (liftA2 (:))
05:35:38 <lambdabot>     Couldn't match type `[a0]'
05:35:38 <lambdabot>                   with `(f0 a1 -> f0 [a1] -> f0 [a1]) -> f0 a1 -> f0 [a1] -> f0 [a1]'
05:35:39 <lambdabot>     Expected type: a0
05:35:44 <Cale> :t foldr (liftA2 (:)) (pure [])
05:35:45 <lambdabot> Applicative f => [f a] -> f [a]
05:36:03 <Cale> :t (\n -> foldr (liftA2 (:)) (pure []) . replicate n)
05:36:03 <lambdabot> Applicative f => Int -> f a -> f [a]
05:36:08 <ski> @type \n ia -> Data.Traversable.sequenceA (replicate n ia)
05:36:08 <lambdabot> Applicative f => Int -> f a -> f [a]
05:36:25 <Arjunax> Yes I am in general but now I have to get this exercise done first (have only 1h left) you helped me alot ski, one more times: thank you :)
05:36:42 <ski> ok, np
05:37:14 <cmiller_> Thank's for the replies.
05:37:25 <cmiller_> @hoogle thankYou
05:37:26 <lambdabot> No results found
05:37:38 <cmiller_> oh well. I can dream.
05:39:13 <ski> cmiller_ : there possibly should be a `replicateA' in `Control.Applicative', but apparently there doesn't seem to be
05:39:38 <merijn> repeat + some Traversable thing seems the easiest approach
05:40:47 <merijn> ah, repeat + sequenceA
05:41:22 <ski> Fuuzetsu : only noticed your link now
05:41:24 <merijn> :t \n -> T.sequenceA id . repeat n
05:41:25 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `[a2]'
05:41:25 <lambdabot>     In the return type of a call of `repeat'
05:41:25 <lambdabot>     Probable cause: `repeat' is applied to too many arguments
05:41:31 <merijn> eh
05:41:36 <merijn> :t \n -> T.sequenceA id . replicate n
05:41:37 <lambdabot> Traversable ((->) ([a] -> a1)) => Int -> a -> ([a] -> a1) -> a1
05:41:53 <merijn> Not quite...
05:42:03 <bennofs> :t fmap sequenceA . replicate
05:42:04 <lambdabot>     Not in scope: `sequenceA'
05:42:04 <lambdabot>     Perhaps you meant one of these:
05:42:04 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
05:42:08 <bennofs> :t fmap T.sequenceA . replicate
05:42:08 <lambdabot> Applicative f => Int -> f a -> f [a]
05:46:27 <gspr> Is Int32 from Data.Int guaranteed to have the same representation as C99's int32_t? If no, are there plans for a CInt32 having that property?
05:47:06 <merijn> gspr: I don't think that *can* be guaranteed as different C compilers may (conceivably) have different representations of int32_t
05:47:21 <gspr> merijn: Ah, that makes sense
05:47:27 <merijn> gspr: But I would assume, that for any sane platform they will match
05:47:36 <gspr> Hmm, ok
05:48:00 <gspr> Am I correct in believing the situation is the same for CDouble vs Double, at least with GHC?
05:48:32 <merijn> gspr: CDouble, CInt, CUInt use the available C compiler to figure out what to use, I think
05:48:45 <merijn> gspr: I dunno what guarantees exist for Double
05:49:20 <gspr> merijn: OK, thanks :)
05:50:15 <merijn> gspr: I would consider anything like CInt and things like Int32/Word32 to be portable enought that I wouldn't worry about compatibility unless you're moving to platforms other than x86/x86_64
05:50:51 <merijn> And even on other platforms it should (probably) work
05:51:14 <merijn> But by that time you'll probably want to consult one of the mailing lists or people in #ghc
06:01:49 <skypers_> about the word-wrapping function I was talking about earlier: https://github.com/skypers/skyoralis/blob/master/Graphics/Rendering/Sky/Utils/String.hs#L29 :) johnw
06:06:20 * hackagebot persistent-redis 0.1.0 - Backend for persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.1.0 (PavelRyzhov)
06:20:32 <mm_freak> eikke: good work, but note that there is an alternative way to implement takeWhile
06:21:16 <mm_freak> eikke: takeWhile :: (Monad m) => (a -> s -> (Bool, s)) -> s -> Producer a m r -> Producer a m r
06:27:37 <Twey> kosmikus: Not I
06:40:24 <xRamses> hey guys, I have a list of files which I want to check with doesFileExist, and take the first one which exists. However guards don't work as doesFileExist returns IO Bool so how do I do that?
06:42:23 <mm_freak> xRamses: you probably want to recurse
06:42:41 <mm_freak> there are filterM and foldM, but they traverse the entire list
06:42:58 <yayutf> mm_freak: you can still take 1 from the resulting list, though
06:43:39 <xRamses> yayutf: does it check all files or just the first one then?
06:43:45 <mm_freak> yayutf: if the resulting list is finite…  and if it's very long, taking that one element will take a long time
06:44:00 <mm_freak> xRamses: filterM checks all, but you can program foldM to check only one
06:44:03 <Feuerbach> mapM_ + EitherT would do, for example
06:44:11 <yayutf> mm_freak: it's a list of files, it sounds likely to be finite
06:44:28 <mm_freak> yayutf: that's not the point…  it's not the right thing to do
06:44:31 <Feuerbach> anyway, xRamses, do you have the code for just one file? can you show it?
06:44:37 <ReinH> xRamses: fmap listToMaybe . filterM
06:44:53 <mm_freak> ReinH: no, see above
06:45:09 <ReinH> mm_freak: no, it's lazy
06:45:13 <mm_freak> ReinH: no
06:45:19 <ReinH> @src find
06:45:19 <lambdabot> find p          = listToMaybe . filter p
06:45:21 <xRamses> Feuerbach: what do you want to see? It just returns the name of the file if the file exists
06:45:29 <mm_freak> ReinH: that's filter, not filterM
06:45:33 <ReinH> I know
06:45:43 <mm_freak> ReinH: filterM does not have the same laziness property
06:45:45 <ReinH> oh right, filterM can't be lazy :/
06:46:23 <eikke> mm_freak: yeah, I took the liberty to mimick what's already in pipes-parse
06:46:37 <mm_freak> xRamses: f (fp:fps) = do isFile <- doesFileExist fp; if isFile then return fp else f fps
06:46:37 <Feuerbach> xRamses: just want to see what the problem is for you. Are you comfortable with monads?
06:47:18 <ReinH> mm_freak: wait, look at filterM
06:47:27 <mm_freak> EitherT would also work, but i would consider this to be overengineering
06:47:30 <ReinH> ah, right
06:47:38 <ReinH> never mind
06:47:50 <eikke> I compiled a test using -ddump-rule-rewrites, that's pretty cool
06:48:26 <mm_freak> eikke: =)
06:48:40 <mm_freak> eikke: i don't always agree with the predefined stuff =)
06:48:57 <eikke> hehe
06:49:05 <mm_freak> in particular the current StateT stuff i find slightly awkward to work with
06:49:12 <eikke> it is indeed
06:49:17 <xRamses> mm_freak: thanks that should do it, although it surprises me that one needs explicit recursion for that
06:49:31 <mm_freak> xRamses: not all problems have monadic solutions =)
06:49:40 <eikke> especually since many parsers using it are one-shot (i think). as in, only one parser function is used within one runStateT call
06:49:43 <mm_freak> xRamses: also note that i left out the [] case
06:50:03 <xRamses> mm_freak: yes I know, but I can handle this myself ;)
06:50:04 <mm_freak> xRamses: btw, you can build this computation using foldr, but i don't know whether that would be an improvement =)
06:50:19 <eikke> mm_freak: your hint to implement that 'singles' FreeT thing was very helpful and instructive
06:51:11 <mm_freak> xRamses: foldr (\fp c -> do isFile <- doesFileExist fp; if isFile then return fp else c) (throwIO "None found")
06:51:14 <mm_freak> that should work
06:51:21 <mm_freak> you don't /need/ explicit recursion
06:51:57 <mm_freak> eikke: yeah, it helped me a lot =)
06:51:59 <xRamses> mm_freak: yeah, well you could make everything with foldr I guess
06:52:12 <mm_freak> xRamses: only building something from a list =)
06:52:45 <eikke> or a foldable
06:52:46 <ReinH> s/list/Foldable =)
06:52:51 <ReinH> :(
06:52:53 <mm_freak> xRamses: looking at it i might actually prefer the foldr variant =)
06:53:05 <Feuerbach> for Foldable that's no longer true, btw
06:53:35 <Feuerbach> (there are things that you can do recursively but can't do using fold. E.g. fmap)
06:54:28 <ReinH> right, it's forgetful
06:57:55 <Feuerbach> here's the mapM_ solution, fwiw: runEitherT . mapM_ (\f -> do isFile <- lift $ doesFileExist f; if isFile then left f else return ())
07:01:11 <xRamses> Feuerbach: that looks even more interessting
07:01:18 <xRamses> *-s
07:07:38 <eikke> mm_freak: guess I can start some more studying once Tekmo's lens-based parsing goes mainstream
07:08:11 <mm_freak> eikke: you don't have to wait for that
07:08:19 <mm_freak> the FreeT stuff will remain the same
07:17:45 <kristof> Does anyone here have experience using extensible effects (oleg style) in practice and actually find them easier to use than monad transformers?
07:18:50 <lingxiao> hey all
07:19:08 <lingxiao> if '[] is a type-level analogue of the value-level constructor [],
07:19:14 <lingxiao> then what inhaibts '[]?
07:19:30 <lingxiao> ditto for ':
07:19:53 <Cale> Nothing does
07:20:04 <Cale> and by that, I don't mean the value Nothing ;)
07:20:30 <Cale> lingxiao: The type level liftings of values don't themselves have values
07:21:03 <Cale> But they can be used as parameters to type constructors that make types which do.
07:22:47 <lingxiao> so just to be crystal clear through repetiion...
07:23:18 <lingxiao> if I have something like:  data Ty = Bool | Ty :-> Ty, and things get lifted from type to kind, and from value constructor to type
07:23:29 <lingxiao> then the type Ty is inhabited by Bool and Ty :-> Y
07:23:35 <lingxiao> Ty :-> Ty
07:23:53 <lingxiao> the type 'Bool is uninhabited, ditto for type ':->
07:24:32 <lingxiao> the kind 'Ty (tick mark infront of Ty?) is inhabited by type Ty only
07:24:37 <lingxiao> does Ty also inhabit * ?
07:25:23 <bmuk`> for functions, isn't <*> just composition?
07:27:47 <dabd> in the expression Product x `mappend` Product y = Product (x * y)  how do I know haskell won't parse it like (Product x) (`mappend` Product) y = Product (x * y) ?
07:28:28 <dabd> in other words how do i know the type constructor Product y has higher precedency than the infix function mappend?
07:28:31 <Twey> dabd: Because that's not how Haskell parses operators
07:28:48 <Twey> You might as well ask why x + y isn't parsed as x (+ y), which is also a type error
07:28:58 <Twey> (probably)
07:29:12 <quicksilver> dabd: applicaiton has higher precedence than any operator
07:29:12 <Twey> Oh, sorry, I think I misread
07:29:31 <merijn> dabd: Because function application *always* has higher priority than infix notation
07:29:40 <Twey> dabd: (but not record modification or some other special syntaxes)
07:30:00 <quicksilver> dabd: a b ~~ c d is always (a b) ~~ (c d) whatever operator ~~ is and whatever functions or constructors a,b,c,d are
07:30:27 <merijn> dabd: Haskell priority is as follows: infix has priority between 0 and 9, function application 10 and record syntax 11 (higher binds tighter)
07:30:30 <dabd> correction:ii wrote precedency when i meant precedence
07:30:42 <kristof> bmuk`: yes, but remember that you can't compose Just f with Just g :)
07:31:17 <merijn> dabd: The default fixity for infix operators is "infixl 9" (left associative, priority 9) you can query the fixity in ghci by running ":i operator" i.e. ":i (*)" will print the fixity of (*)
07:31:19 <Twey> :t (.) <$> Just (+ 1) <*> Just (* 2)
07:31:20 <lambdabot> Num c => Maybe (c -> c)
07:31:23 <merijn> dabd: No fixity == default
07:31:50 <triliyn> kristof, bmuk`: actually not quite
07:32:03 <triliyn> Composition is f . g = \x -> f (g x)
07:32:13 <Twey> bmuk`: <$> is composition for functions
07:32:20 <Twey> :t <*>
07:32:21 <lambdabot> parse error on input `<*>'
07:32:21 <triliyn> <*> is f <*> g = \x -> f x (g x)
07:32:22 <Twey> :t (<*>)
07:32:23 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
07:32:33 <Twey> Oh, yes, (<*>) is Schönfinkel
07:32:36 <dabd> merijn: i am looking for this info in the haskell 2010 report. This table only shows fixity for prelude operators: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-820061
07:32:52 <triliyn> So in (<*>), f receives the argument unmodified in addition g of the argument
07:33:04 <Twey> I.E. application of a function to an argument, where both function and argument receive an additional argument before application
07:33:22 <kristof> triliyn: What he was referring to was how <*> would behavior for functions in contexts
07:33:27 <lingxiao> so if some datatype T inhabits * to begin with, and is then promoted to kind, does T inhabit kind T and also kind *?
07:33:30 <triliyn> oh wait, did I get it wrong?
07:33:35 <merijn> dabd: Yes, which is why you can use :i to ask for the fixity of non-prelude operators
07:33:39 <lingxiao> or does type T only inhaibt kind T?
07:33:48 <dabd> ok thanks
07:33:54 <lingxiao> and what's the relationship between kind T and kind * ?
07:34:01 <merijn> lingxiao: Nothing
07:34:20 <merijn> lingxiao: The *type* T and the *kind* T are completely separate
07:34:20 <ReinH> @djinn (r -> a -> b) -> (r -> a) -> (r -> b)
07:34:20 <lambdabot> f a b c = a c (b c)
07:34:34 <merijn> lingxiao: Like how you can have a type and constructor with the same name
07:34:53 <ReinH> Twey: that's <*> for (r ->) ofc
07:34:53 <merijn> lingxiao: Types and kinds are different namespaces and in Haskell kinds other than * can't have inhabited types
07:34:59 <Twey> lingxiao: The kind 'Ty is inhabited by the types 'Bool and '(:->) (or however that's spelt)
07:35:16 <Twey> lingxiao: There's also a type Ty which inhabits ★
07:35:48 <Twey> lingxiao: And is in turn inhabited by values Bool and (:->)
07:36:30 <Twey> (well, both those (:->)s are need to be given types/values before they become members of 'Type/Type, but you get the idea)
07:36:43 <Twey> ReinH: Yes, that was the question (I think)
07:37:18 <kosmikus> Twey: yes, I read the log by now. I think it was lingxiao who asked whether I'm on this channel, and you just repeated my name with a proper umlaut.
07:37:36 <Twey> kosmikus: Oh, you're Andres Löh?
07:37:43 <kosmikus> Twey: yes
07:37:53 <lingxiao> oh hi kosmikus!
07:37:58 <Twey> I never realized!  I loved your paper on λΠ
07:38:02 <kosmikus> thanks
07:38:32 <lingxiao> so in other words type Bool and type :-> are uninhabited like Cale said earlier, and they inhiabit kind Ty
07:38:46 <Twey> lingxiao: Your original data type isn't changed by DataKinds.  There's still a type Ty with value constructors Bool and (:->).  There just happens to also now be a kind 'Ty with type constructors 'Bool and '(:->).
07:39:03 <Twey> lingxiao: And the original type still inhabits ★, obviously
07:39:10 <lingxiao> hmm.. ok that clears it up a lot
07:39:22 <Twey> lingxiao: The type-level 'Bool and '(:->) are uninhabited, yes
07:39:36 <lingxiao> guess the mechanism is opaque to me so I can only reason at the syntax level, which is to say not much at all
07:39:37 <kosmikus> lingxiao: so did you have a question for me, or have the others already cleared it all up?
07:39:38 <Twey> (as are the value-level Bool and (:->), because they're values)
07:39:41 <TheOtherCat> Hey there. I have a list g :: [Int] beeing [g1,...g10]. I want to create a list h :: Int beeing [h0,..h10] with h0:=1, h1=g1-h0, h2=h2-g1,... I think fold would be appropriate here but i'm failing badly... any help?
07:40:22 <mm_freak> lingxiao: it could help to use standard notation
07:40:27 <mm_freak> True :: Bool
07:40:34 <mm_freak> when True is a value, Bool is a type
07:40:39 <mm_freak> when True is a type, Bool is a kind
07:40:55 <ReinH> Twey: a.k.a. the Reader applicative, not that it matters ;)
07:41:15 <Twey> ReinH: Yep
07:41:17 <lingxiao> kosmikus: for now no, others are giving me tremendous help, but if you're on may I ask a few questions later?
07:41:38 <Twey> TheOtherCat: h2 = h2 - g1 is non-terminating; is that what you meant?
07:41:40 <lingxiao> mm_freak: hmm yes that looks much more familiar
07:41:43 <kosmikus> lingxiao: sure, you can always ask :)
07:41:48 <ReinH> Twey: I always thought calling it Reader was silly. The function arrow applicative is so useful, why hide it?
07:41:55 <TheOtherCat> Twey: yes
07:41:57 <merijn> lingxiao: For "normal" types in * we have "True :: (Bool :: *)", i.e. * is inhabited by Bool and Bool is inhabited by True (and False)
07:42:16 <Twey> TheOtherCat: Then I'm afraid I don't see the pattern in your list of h
07:42:19 <rajeshsr> hi all
07:42:30 <ReinH> I find myself using (r ->) applicatives all over the place now
07:42:34 <rajeshsr> any recommendations for haskell to js compiler?
07:42:35 <merijn> lingxiao: DataKinds creates a "parallel universe" were we have "? :: (True :: Bool)", i.e. Bool is a kind inhabited by the type True (and False)
07:42:48 <Twey> TheOtherCat: (or rather, I see more than one possible pattern)
07:42:50 <rajeshsr> i want something light weight and easily debuggable with the generated code...
07:42:57 <merijn> lingxiao: But the True and False types are both uninhabited in Haskell, because only types in * can be inhabited in haskell
07:43:04 <ReinH> rajeshsr: fay?
07:43:09 <TheOtherCat> i meant h_(n) = g_(n) - h_(n-1)
07:43:25 <kosmikus> merijn: and types in # ;)
07:43:26 <mm_freak> (for haskelly values of "uninhabitated")
07:43:27 <rajeshsr> ReinH, hmm! lemme explore that. Is it actively developed?
07:43:35 <ReinH> rajeshsr: quite.
07:43:36 <Twey> ReinH: Hm, I don't think I've used them much; what do you do with them?
07:43:55 <merijn> kosmikus: In the words of Knuth, I've lied in the interest of education :p
07:44:01 <lingxiao> merijn: so data kinds just an automatic way of doing something like:
07:44:04 <lingxiao> data True
07:44:07 <lingxiao> data False
07:44:08 <kosmikus> merijn: yes, sorry. couldn't help it.
07:44:17 <ReinH> Twey: e.g. constructing a record from some other value
07:44:20 <merijn> rajeshsr: ghcjs has by the far the best/mostc omplete Haskell support, but I think they won't have an official release until 7.8 is released
07:44:21 <rajeshsr> i have heard of fay, ghcjs, haste. Not sure which one to pick up. Main thing for me is debuggability, so generated code should not feel terrible! :)
07:44:30 <merijn> lingxiao: Yes
07:44:33 <triliyn> lingxiao: if you define data True and data False manually, they have kind *
07:44:34 <merijn> lingxiao: Including creating a new kind for those
07:44:40 <lingxiao> and then specifying True and False belong to some kind Bool, presumably kindBool is declared as well
07:44:52 <merijn> lingxiao: Pretty much, yes
07:44:59 <ReinH> Twey: like (Foo <$> getPart <*> getAnotherPart) bar
07:45:13 <lingxiao> merijn: ok that clears it up a lot, at least I can imagine some mechanism which will suffice for the next few days
07:45:18 <rajeshsr> merijn, hmm! but what about the quality of generated code? is it easy to reason about?
07:45:38 <rajeshsr> ReinH, same  question on Fay! :)
07:45:39 <merijn> rajeshsr: I don't dare say :)
07:45:44 <Twey> ReinH: Oh, I guess that works!  Nice
07:45:54 <rajeshsr> merijn, haha! :)
07:46:08 <Twey> Does Fay produce source maps?
07:46:26 <ReinH> I haven't used it much actually, I just know it's used pretty actively by, e.g., FPComplete IDE
07:46:28 <merijn> rajeshsr: ghcjs (unlike Fay and the others) fully supports lightweight threading, STM and all GHC extensions
07:47:12 <rajeshsr> meretrix, hmm, that;s not helping, for me! If it is too advanced then i guess it won't be debuggable when i use other JS libs! :)
07:47:26 <ReinH> Twey: the digestive functors / formlets thing
07:47:44 <ReinH> although I'm just using (r ->), I don't need to write my own functor.
07:47:57 <ReinH> s/functor/applicative
07:48:15 <luite> ghcjs is different in the sense from the others in that it does its own closure conversion. this has some advantages: everything haskell is inspectable (js closures are opaque), but the code looks less like the original haskell than with fay
07:48:21 <rajeshsr> merijn, ReinH anyway, thanks! lemme check out both and decide..
07:48:26 <rajeshsr> any idea on haste?
07:48:55 <ocharles> Is x <$ mzero ~ mzero?
07:48:58 <luite> haste doesn't have threading and is similar to fay in how it handles closures
07:49:09 <triliyn> luite: haskell closures are not opaque?
07:49:13 <Twey> ocharles: It depends no the MonadPlus >.<
07:49:15 <Twey> on**
07:49:16 <ocharles> Seeing as (x <$) == (>> return x) I think I can reason they are the same
07:49:22 <ocharles> Twey: urgh, is this due to the lack of laws thing again?
07:49:54 <Twey> ocharles: Apparently there are two conventions for mzero, where it's either an identity or an absorber
07:50:20 <ReinH> 1 or 0
07:50:33 <ReinH> well, it's zero fsvo "zero" I guess
07:50:52 <ocharles> looking at the source of ListT in pipes, it looks like my reasoning holds for that MonadPlus
07:51:14 <ReinH> "zero" is usually used to mean an absorbtive element, e.g. zero semigroup
07:51:18 <ReinH> but also used to mean identity :D
07:51:19 <luite> triliyn: they are to haskell code, but you can inspect them with some rts knowledge, and the rts itself inspects them for things like finalizers
07:51:34 <luite> triliyn: if you implement haskell closures as js closures, you can't implement those
07:51:57 <triliyn> luite: ah, okay
07:53:43 <luite> triliyn: also i found that the manual closure conversion was often faster (might have something to do with context chains being shorter, but that's obviously extremely js engine dependent)
07:58:54 <luite> (next major change in js engines is generational gc in firefox, first half is now in the alpha builds (exact rooting), that should help haskell -> js stuff quite a bit)
08:18:00 <kstt> hello
08:18:30 <kristof> luite: Will that coincide with the introduction of Rust as a core development language or is this unrelated?
08:19:58 <kstt> Does some package define this type of predicate combinators please ? http://lpaste.net/98888
08:21:52 <quicksilver> kstt: liftA2 (&&) and liftA2 (||)
08:21:56 <luite> kristof: i don't think it is. generational gc has been planned for a long time, but it's hard to move a large program from a simple marking gc to a compacting/copying one (which is highly preferred for generational gc :) ), since you have to track all pointers to mananaged data
08:22:17 <kstt> quicksilver: thank you ^^
08:22:31 <kristof> luite: That's even harder considering Firefox is a million lines of C++.
08:22:35 <kstt> I never use liftAN, I should look more at it
08:22:37 <quicksilver> kstt: they might well be defined privately in lots of places but I don't think they have an accepted/common module since they're pretty simple
08:22:44 <luite> kristof: so they had the rather tedious task of correctly marking every pointer to managed code in their huge codebase
08:22:48 <quicksilver> I have defined them locally sometimes just to make code read better
08:22:50 <kstt> indeed they are
08:22:58 <luite> kristof: yeah they used a combination of static analysis and hard work to find them all :)
08:23:03 <kristof> christ
08:23:12 <kristof> luite: And you KNOW they didn't find them all, there's going to be a leak somewhere
08:24:28 <Yaniel> as if there weren't enough of those already
08:28:03 <luite> kristof: yeah i imagine they have enough debug/instrumentation in place to find almost all offending code at runtime, but perhaps some obscure or hard to trap things are still there. still a generational gc is a huge win, so i guess it's worth it
08:28:13 <implementation> hey guys, is there some function in the standard library that does something like that:  [[1,2], [4,5], [7,8]] -> [1 `f` 4 `f` 7, 1 `f` 4 `f` 8, 1 `f` 5 `f` 7, ...] ?
08:29:06 <kristof> luite: I just use languages with garbage collection and that's that *shrug*
08:29:33 <implementation> or at least [[1,4,7], [1,4,8], [1,5,7], ...] ?
08:29:39 <Kaini> implementation, zipWith3?
08:29:43 <hodapp> I kind of like Rust's take to memory management.
08:29:45 <luite> kristof: haskell with firefox's old-fashioned gc wouldn't perform well
08:29:51 <hodapp> though I've yet to actually *use* it.
08:30:00 <implementation> Kaini: it needs to work on lists, not tuples
08:30:19 <luite> kristof: unless you find some other way around the lots of short lived data problem
08:32:22 <nooodl> implementation: map (fold f) . transpose
08:32:28 <nooodl> where fold is foldl1 or foldr1
08:32:29 <kristof> luite: Which part?
08:32:32 <c_wraith> implementation: write it in terms of transpose, then mapping a fold...  like nooodl just suggested...
08:32:41 <lingxiao> hey all, so in this line expressing a function over types:
08:32:42 <c_wraith> I was a bit slow there
08:32:44 <lingxiao> type family TypeProd (ts :: [Type]) :: Type
08:32:55 <lingxiao> both the first and second [Type] are list of kinds right?
08:32:57 <kristof> luite: I think rendering and the JS engine are the bottlenecks for every browser
08:33:29 <lingxiao> if we were to overload syntax over values, could you write this as: TypeProd :: [Type] -> [Type]
08:33:45 <implementation> nooodl, c_wraith: thank you, transpose is exactly what i was looking for :)
08:33:48 <lingxiao> where TypeProd is a function over types, sending types in kind [Type] to types in kind [Type]
08:33:56 <lingxiao> now what is the "ts" doing in there?
08:34:57 <implementation> err, not :/   transpose [[1,2],[4,5],[7,8]] = [[1,4,7],[2,5,8]], that's not what i'm looking for
08:35:17 <luite> kristof: oh i meant for haskell in general, not specifically for browsers, you want really cheap allocation / disposal of short lived data
08:35:45 <luite> so a generational gc is much better than a traditional single generation gc
08:35:48 <c_wraith> implementation: *oh*
08:35:50 <lingxiao> kosmikus: are you still around? :_
08:35:52 <lingxiao> :)
08:35:54 <c_wraith> implementation: I think you want sequence
08:36:14 <c_wraith> > sequence [[1,2],[4,5],[7,8]]
08:36:15 <lambdabot>  [[1,4,7],[1,4,8],[1,5,7],[1,5,8],[2,4,7],[2,4,8],[2,5,7],[2,5,8]]
08:36:22 <c_wraith> implementation: I misread what you were asking for
08:36:32 <kosmikus> lingxiao: yes, but not for long :)
08:36:41 <kristof> luite: Because garbage collection is arbitrary, right?
08:36:54 <lingxiao> oh shoot, do you think you have time to walk me through these three lines?
08:36:57 <lingxiao> type family TypeProd (ts :: [Type]) :: Type
08:36:57 <lingxiao> type instance TypeProd '[]       = Unit
08:36:57 <lingxiao> type instance TypeProd (t ': ts) = t :*: TypeProd ts
08:37:10 <implementation> c_wraith: thanks a lot!
08:37:10 <lingxiao> so I get the general gist of what's going on, but the syntax is confusing me ...
08:37:56 <lingxiao> is typeprod conceptually the same as "TypeProd :: [Type] -> [Type]" at the type level?
08:38:10 <lingxiao> here the [Type]  are kinds
08:38:24 <c_wraith> lingxiao: yes.
08:38:34 <lingxiao> so why is ts there?
08:38:47 <lingxiao> is it just a variable of kind [Type] ..
08:39:01 <c_wraith> quirk of the syntax, particularly related to the common use case of associated type families
08:39:12 <lingxiao> as in TypeProd is af function over ts only, where ts has kind [Type]
08:39:23 <c_wraith> where you put the type family inside a class definition
08:39:43 <lingxiao> ahh ok ... cool I can live with it I suppose
08:39:45 <luite> kristof: dunno what you mean by that, but scanning the whole heap every time is expensive (would need to be done a few times per second if you allocate multiple gigabytes per second, not uncommon for ghc compiled programs), and allocation for a non-compacting collector is a lot more expensive than just a single pointer bump (and a check to see if you haven't bumped it over the limit)
08:39:52 <Maior> wl
08:40:05 <lingxiao> kosmikus: so what's this: ':,  in the line "type instance TypeProd (t ': ts) = t :*: TypeProd ts"
08:40:16 <lingxiao> it's cons right ..
08:40:22 <c_wraith> it's *lifted* cons
08:40:24 <lingxiao> at the type level
08:40:31 <c_wraith> err.  promoted, not lifted
08:40:36 <c_wraith> to use the terminology of the paper
08:40:46 <c_wraith> It's syntax enabled by the DataKinds extension
08:40:55 <lingxiao> right ok I've been looking at it for so long I'm getting :: and : confused
08:41:13 <kosmikus> lingxiao: yes, the ' syntax is just disambiguating between a term-level and type-level construct if they'd otherwise be ambiguous
08:41:33 <c_wraith> or between type-level and kind-level, if they'd otherwise be ambiguous
08:41:42 <lingxiao> kosmikus: so all these questions came from the SO answer you wrote: http://stackoverflow.com/questions/21238508/how-do-you-formulate-n-ary-product-and-sum-types-in-this-typed-lambda-calculus-u
08:41:47 <kosmikus> lingxiao: '[] is the type-level empty list, whereas [] is the list type constructor
08:42:01 <lingxiao> right above the type family blurb, you wrote: "We then use a type family to collapse a list of types into a binary product type. Alternatively, we could add something like Product [Type] to the Type universe."
08:42:01 <kosmikus> lingxiao: yes, I've inferred that from your questions.
08:42:19 <kosmikus> lingxiao: but you've not actually asked the question this is an answer to, right?
08:42:26 <lingxiao> haha ... sorry just for completeness sake I suppose ...
08:42:29 <lingxiao> oh no I did
08:42:42 <lingxiao> like is that my SO account? yes
08:42:48 <kosmikus> I see.
08:43:04 <luite> kristof: anyway the problem is the unknown lifetime of almost everything that stresses the gc, if you find a way to significantly reduce the data with unknown lifetime (like region inference) you could perhaps get by with a simpler gc
08:43:11 <kosmikus> sorry then. you've been using GADTs and data kinds in your original question already.
08:43:18 <kosmikus> lingxiao: so I assumed you're familiar with them.
08:43:29 <lingxiao> yeah sorry... your answer is actually really amazin, this is just my first introduction to type level programming, thus I'm a bit confused by the terminology
08:43:32 <kosmikus> lingxiao: that's why I dumped so much code with relatively little explanation.
08:44:00 <lingxiao> or erm this is like my 3rd day of doing type level programming... so the stuff I wrote with GADTs above it, is all that I know
08:44:19 <lingxiao> no it's good! I can jumping in and swimming, and you gave me a pool to jump into
08:44:40 <lingxiao> c_wraith: thanks!
08:45:10 <lingxiao> so in your comment on SO: "lternatively, we could add something like Product [Type] to the Type universe."
08:45:31 <lingxiao> if I did that, then I wouldn't need type family TypeProd right?
08:45:37 <kosmikus> no
08:45:49 <kosmikus> everything would be "easier" then
08:45:56 <lingxiao> so what's the added expressiveness of the type family
08:46:13 <kristof> luite: Does RIIA/destructors come into play, here?
08:46:15 <lingxiao> eh I like harder so I'm glad you wrote it, I wouldn't learn otherwise
08:46:18 <kosmikus> but since I wanted to stick to my original point that you should actually be happy with binary sums and products, I've told you how you can define the n-ary and compile down to binary
08:46:37 <kosmikus> the n-ary sums and products are harder to work with; everywhere in your code
08:46:37 <lingxiao> ahhh ... ok very nice .. no I like that
08:47:02 <luite> kristof: RAII?
08:47:21 <kosmikus> but yes, you could just do "data Type = Type :-> Type | Prod [Type] | Sum [Type] | Boolean"
08:47:37 <kristof> luite: uhhhh that one ha
08:47:43 <kosmikus> lingxiao: you wouldn't need Unit because it's just "Prod []", and you wouldn't need Void because it's just "Sum []"
08:47:47 <kristof> C++ style
08:48:06 <lingxiao> wow I actually never knew such relationship existed
08:48:21 <lingxiao> between Unit and Product and Sum and Void
08:48:34 <kosmikus> lingxiao: well, in the same ways as "product [] = 1" and "sum [] = 0" on lists of numbers
08:48:36 <lingxiao> so if I were to do  data Type = Prod [Type] | Sum [Type] | ..
08:48:55 <lingxiao> hmm I see the connection
08:49:01 <lingxiao> and it's a good way to remember
08:49:20 <monochrom> it is along the same vein as: prod [] = 1, sum [] = 0
08:49:32 <monochrom> oops, you already know
08:50:10 <lingxiao> see this is where I'm a bit confused ... the function prod takes Env and send it to Term (TypeProd ts)
08:50:13 <kosmikus> monochrom: the #haskell channel is awful. whenever one tries to give a useful piece of info, someone else is faster. ;)
08:50:30 <lingxiao> which is a "list" of kind Type
08:51:00 <kosmikus> lingxiao: an Env is a list of terms, each of which can be of a different type
08:51:33 * hackagebot som 7.2.1 - Self-Organising Maps  http://hackage.haskell.org/package/som-7.2.1 (AmyDeBuitleir)
08:51:51 <monochrom> this is why I have changed to giving useless tautologies such as http://www.vex.net/~trebla/humour/tautologies.html :)
08:52:04 <kosmikus> so, for example, Uni ::: Tru ::: Fls ::: Nil is an environment with three elements, and it's of type Env '[Unit, Boolean, Boolean]
08:52:47 <kosmikus> monochrom: great :)
08:52:48 <luite> kristof: the ghc rts doesn't have prompt finalization stuff like destructors (heap data is always gc managed), destructors are a lot more heavyweight in general, with actual code to be called when a stack frame is popped
08:53:12 <lingxiao> kosmikus: so from def of (:::) I can see it takes Term t  as a parmeter
08:53:32 <lingxiao> but data env sends kind of [Type] to *
08:53:36 <luite> kristof: ghc's model is simpler, you can remove frames from the stack just by modifying the stack pointer
08:54:45 <lingxiao> sorry if my questions sound innane :(
08:54:46 <kosmikus> lingxiao: yes, you need to keep track of the types of the terms in an environment
08:54:55 <kosmikus> lingxiao: that's the whole point of your original question
08:55:08 <kosmikus> lingxiao: you can easily require all terms in a list to be of the same type
08:55:18 <kosmikus> lingxiao: or you can give up on keeping track of type info alltogether
08:55:37 <luite> kristof: (but that means that the user has more responsibility, fuctions that acquire/release resources must handle exceptions, see for example withFile)
08:55:50 <kosmikus> lingxiao: but if you want to allow different types and keep track of them, then such a list needs to have a type that specifies exactly how many elements are in it and what types they have
08:56:02 <kosmikus> lingxiao: that's what an environment is
08:56:32 <kosmikus> lingxiao: "Nil" says that it's an Env '[], that is, an environment containing zero elements.
08:57:07 <kosmikus> lingxiao: and (:::), the cons-operator for environments, takes a Term of type t, and an Environment containing types ts, and builds an environment containing elements of types t : ts
08:57:28 <kosmikus> lingxiao: so first step: Nil :: Env '[]
08:57:50 <kosmikus> lingxiao: second step: True ::: Nil :: Env (Bool ': [])
08:58:08 <kosmikus> lingxiao: which can be more easily written as Env '[Bool]
08:58:39 <kosmikus> lingxiao: third step: Uni ::: Tru ::: Nil :: Env '[Unit, Boolean]
08:58:41 <kosmikus> and so on
08:58:48 <kosmikus> I made a couple of minor typos there, sorry
08:58:53 <kosmikus> Bool instead of Boolean
09:01:34 * hackagebot creatur 4.3.3 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-4.3.3 (AmyDeBuitleir)
09:02:19 <lingxiao> kosmikus: ok things are a lot more clear now!
09:02:26 <lingxiao> thanks for walking through it with me :)
09:04:01 <kosmikus> lingxiao: ok, great. just try a few things in GHCi to see what types and what not. unfortunately, GHCi is extremely bad at printing such types in a readable form.
09:04:36 <lingxiao> yup I've been playing around with it for a bit and will continue to do so! thanks for sticking with me
09:05:45 <mm_freak> i wonder if constructing a Builder is faster than constructing a Producer
09:06:07 <kosmikus> lingxiao: have fun :)
09:06:34 * hackagebot cipher-aes128 0.6.4 - AES and common modes using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.6.4 (ThomasDuBuisson)
09:06:43 <lingxiao> I will! this stuff makes me feel like a beginner again :)
09:16:35 * hackagebot concurrent-state 0.3.0.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.3.0.0 (JoelTaylor)
09:22:00 <joejev> I have been told the error function is a bad way to do error handling; however, if I am writing an application (not a library), is there a better way to exit with exit failure printing a message to stderr, or is that okay?
09:22:32 <joejev> it is an interpreter, so the only way that these errors get called would be due to programmer error
09:25:38 <cwraith> joejev: error is fine for indicating programmer error
09:25:58 <cwraith> joejev: it's bad for indicating a recoverable condition
09:28:18 <quchen> Static error is even better.
09:29:14 <quchen> I typically throw my own Exception when I want to let the program crash.
09:29:52 <quchen> "error" is a bit generic, and it's used for "let's not worry about this case" by many libraries. I wouldn't recommend using it if otherwise possible.
09:30:02 <alpounet> how about 'fix undefined'
09:33:09 <test___> I'm thinking about to learn haskell and would like to hear how fast the binarys are that were generated from the compilers are there very slower as for example pascall or c programms
09:33:31 <athan> Is the UndecidableInstances extension stable in ghc right now? I just read an article about how you should conditionally macro-out code that uses it.
09:33:44 <athan> They're fast
09:33:46 <quicksilver> it's perfectly stable, athan
09:33:54 <quicksilver> it's a very simple extension indeed, it just turns off a check
09:33:58 <athan> I've heard that it can be faster than C++
09:34:05 <bennofs> test___: but it might require a bit of experience to make them fast
09:34:14 <quicksilver> however it does make it possbile to write code which compiles forever
09:34:15 <athan> quicksilver: Awesome, thanks
09:34:33 <test___> ok thaks
09:34:37 <athan> quicksilver: Oh! wow, that's good to know haha
09:35:04 <mm_freak> test___: depending on your coding style you can get anywhere from slightly faster than C to way slower than C
09:35:05 <test___> really faster than c
09:36:04 <SaBer> quicksilver: "forever" or forever?
09:36:12 <bennofs> Of course, the haskell rts is also written in C so you could possibly get as fast as haskell in the C code, with a lot of work
09:36:45 <mm_freak> test___: GHC-haskell with a good coding style usually outperforms C for complicated parallel tasks
09:37:02 <mm_freak> but with a lot of effort on the C side you can get close to haskell performance
09:37:45 <test___> ok thanks for your answers
09:39:01 <dv-> that assume you're doing something that's parallelizable
09:39:15 <athan> Does anyone have good white papers on functors and why they were introduced?
09:39:23 <athan> in haskell, in particular?
09:40:36 <mm_freak> athan: they were introduced as a side effect of introducing monads
09:41:51 <athan> mm_freak: Can you explain? Do you have references?
09:42:21 <mm_freak> athan: i can't give you references, but the explanation is simple enough:  every haskell monad is an endofunctor on Hask
09:42:41 <athan> --a functor that maps the category Hask back to itself, correct?
09:42:47 <mm_freak> but not every endofunctor on Hask is a monad, so something can be gained by providing a more general type class for these functors
09:42:50 <mm_freak> yes
09:42:51 <athan> I still don't have a grip on the terminology yet
09:43:04 <athan> WOW
09:43:10 <athan> that just clicked
09:43:18 <athan> so every monad in haskell is a Hask endofunctor
09:43:23 <mm_freak> yes
09:43:34 <athan> what kind of objects reside in Hask?
09:43:38 <mm_freak> types
09:43:39 <athan> What are their purposes?
09:43:48 <athan> hmm, okay
09:43:53 <athan> and the endofunctor itself
09:44:06 <mm_freak> Hask contains all types of kind *
09:44:06 <athan> must preserve categorical integrity
09:44:11 <athan> ...whatever that means haha
09:44:12 <mm_freak> so it does not contain the endofunctor itself
09:44:18 <athan> oh okay
09:44:20 <mm_freak> Maybe is not in Hask
09:44:20 <mm_freak> but Maybe Int is
09:44:23 <athan> so concrete types
09:44:27 <mm_freak> yeah
09:44:32 <athan> hmm
09:45:14 <quchen> Is there a category of type constructors then?
09:45:25 <quchen> Can't think of an identity there though
09:45:26 <mm_freak> quchen: what would be the identity morphism for Maybe?
09:45:57 <quchen> Is that a "no"? :-)
09:46:02 <mm_freak> not necessarily
09:46:06 <athan> what role to functors play in Hask related to monads?
09:46:21 <mm_freak> quchen: there is a category of functors, where morphisms are natural transformations
09:46:35 <mm_freak> f : forall a. Maybe a → Maybe a
09:47:00 <athan> natural transformation?
09:47:06 <mm_freak> type NaturalTrans f g = forall a. f a -> g a
09:47:12 <test___> which compiler is the actually best for haskell on linux
09:47:16 <mm_freak> idMaybe : NaturalTrans Maybe Maybe
09:47:23 <mm_freak> test___: most likely GHC
09:47:35 <test___> ok thanks
09:48:00 <mm_freak> athan: a natural transformation is a mapping from a functor to another with a set of naturality laws
09:48:08 <athan> do they have to use types of kind * -> *?
09:48:17 <athan> oh, okay.
09:48:29 <mm_freak> athan: in particular a monad is an endofunctor with two associated natural transformations
09:48:39 <athan> interesting!!!
09:48:49 <mm_freak> one is called unit, but you may know it as 'return' =)
09:49:03 <athan> hmm.
09:49:14 <mm_freak> the other one is called flatten/join/…, and you know it as 'join'
09:49:22 <mm_freak> :t join
09:49:23 <lambdabot> Monad m => m (m a) -> m a
09:50:08 <athan> and those can be seen as endofunctors on Hask, correct?
09:50:21 <mm_freak> ?
09:50:25 <athan> Call me a noob, but what's the difference between an endofunctor and a morphism?
09:50:36 <athan> join/flatten and unit
09:50:49 <athan> because they (when implemented) act upon the concrete types
09:50:50 <athan> gah
09:50:51 <mm_freak> athan: a morphism is an arrow in your category diagram
09:50:53 <athan> i don't know anymore haha
09:50:56 <tel> athan `m _` is the endofunctor, as is `m (m _)`
09:51:14 <mm_freak> if the objects happen to be categories, then every arrow from an object to itself is an endofunctor
09:51:29 <athan> ah okay
09:51:34 <athan> basically just a higher-order arrow
09:51:36 <athan> or something...
09:51:36 <athan> idk
09:51:41 <mm_freak> a regular arrow
09:51:48 <test___> are there any good and actualy german tutorials for lening haskell?
09:51:53 <tel> for `return :: a -> m a` we have the more obvious functor `m _` and the less obvious functor `type Identity a = a`
09:52:10 <tel> return :: Identity a -> m a
09:52:14 <tel> NaturalTrans Identity m
09:52:18 <athan> OH
09:52:20 <athan> WOAH
09:52:25 <mm_freak> test___: not aware of german tutorials, sorry
09:52:34 <mm_freak> test___: even though i often thought of writing one =)
09:52:40 <arcke> mapM print [1 .. ] outputs numbers infitely, however mapM print (map digits [ 1.. ]) builds up the list before it starts printing any values
09:53:00 <arcke> how can I force haskell to print before unfolding more
09:53:34 <athan> what does digits do?
09:53:37 <quchen> Lern dir ein Haskell für großes Gut
09:53:40 <shachaf> That depends on what digits is. (It actually doesn't, but you should say what digits is anyway.)
09:53:43 <mm_freak> hehe
09:53:55 <arcke> athan: it retrurns a list of Int, the digits of the input number
09:54:02 <shachaf> As a general rule you should use mapM_ in cases like these when you're not using the output.
09:54:12 <athan> hmm
09:54:24 <athan> strictness declaration on the output?
09:54:25 <arcke> digits x = digits (x `div` 10) ++ [x `mod` 10]
09:54:42 <mm_freak> arcke: that never results in anything
09:55:17 <shachaf> Why are people saying all these category theory definitions? It seems to me that they're the opposite of helpful for someone trying to understand Haskell.
09:55:22 <Cale> arcke: Perhaps you intended also to include a base case?
09:55:34 <athan> Look up the lens library
09:55:45 <athan> and you'll understand why I'm trying haha
09:55:48 <shachaf> arcke: Try a simpler example, like typing "digits 1" in ghci.
09:55:58 <mm_freak> shachaf: because a CT question was asked, if you're referring to my chat with athan
09:56:15 <arcke> Cale: i am going to modify this function to find all values that satisfy a certain condition, i dont know how many there are
09:56:54 <shachaf> The question being <athan> Does anyone have good white papers on functors and why they were introduced? </athan> ? :-(
09:56:56 <athan> is there a popular CT channel on freenode?
09:57:10 <Cale> ##categorytheory
09:57:17 <arcke> hmm, it seems my digits is outdated
09:57:35 <test___> are there then any goog german commented code to learn from it
09:57:37 <shachaf> I don't object to categories but it seems a bit gratuitous here. But who knows.
09:57:37 <arcke> i used this function in another program
09:58:07 <athan> shachaf: Have you heard of the lens library? It's a really advanced haskell library for elegand data manipulation (and probably a lot more) that leans heavily on CT topics. I just wanted to gain some useful knowledge, that's all.
09:58:13 <Cale> athan: Functors were introduced by MacLane in the 1950's or so in the context of algebraic topology, and he claims that he introduced them so as to be able to discuss natural transformations.
09:58:27 <Cale> (But this isn't a Haskell-relevant answer to that question)
09:58:29 <mm_freak> shachaf: it's wrong to overestimate someone's abilities, but it's equally wrong to underestimate them
09:59:27 <shachaf> I agree, but I didn't say anything about abilities.
09:59:36 <athan> thanks mm_freak, I'll move over to that channel. Thanks Cale! That helps me relate these terms!
09:59:50 <mm_freak> in german there is this expression, which i'm not sure how to translate:  as a teacher you should never serve everything on a silver salver
09:59:56 <athan> >< I'm the only one in the channel haha
10:00:23 <adityarajbhatt> I'm just getting started in haskell and I'm interested in what purely functional actually means. So can you write function (x) {...} n=4; ?
10:00:24 <Cale> Functors and monads in particular were used by Euginio Moggi in order to explain the semantics of programming languages, and then from there, I think it was Wadler who first realised their use directly within programs.
10:00:31 <adityarajbhatt> Or you can't because n is not a function?
10:00:44 <adityarajbhatt> You have to put n within a function?
10:00:45 <mm_freak> if someone asks a CT-related question and there is a valid CT-related answer, they deserve to get it =)
10:00:48 <Cale> adityarajbhatt: I don't know what you intend by that code.
10:00:52 <Iceland_jack> adityarajbhatt: Purely functional doesn't mean that everything is a function
10:00:59 <adityarajbhatt> Cale: Nothing just asking what Iceland_jack just said.
10:01:05 <dwcook> adityarajbhatt, basically: evaluation has no side effects.
10:01:08 <adityarajbhatt> Iceland_jack: Okay thanks. But then why the (purely) part?
10:01:17 <skypers> I have a ParsecT s u m a
10:01:25 <mm_freak> adityarajbhatt: purely functional means this: https://xkcd.com/221/
10:01:26 <mm_freak> =)
10:01:28 <skypers> I want to run it without any monad
10:01:33 <skypers> I guess it’s Identity
10:01:34 <Cale> adityarajbhatt: "Pure" refers to the property of referential transparency
10:01:56 <skypers> how should my parse function be typed?
10:01:58 <adityarajbhatt> dwcook: Hmm I'll have to read up on this. mm_freak : Yeah I had a good laugh over that too.
10:01:58 <shachaf> But it wasn't a CT question! If somene asks what Monad is, "every haskell monad is an endofunctor on Hask" is just making things complicated.
10:02:04 <tel> adityarajbhatt: most likely the `n=4` bit you wrote refers to *assignment* of the value 4 to the slot called *n* in a local or global variable context
10:02:08 <shachaf> But I will go now.
10:02:24 <Cale> adityarajbhatt: That whenever f x and g x produce the same result for every value of x, then f can safely be replaced by g anywhere without changing the meaning of the program.
10:02:25 <adityarajbhatt> tel: Yes.
10:02:26 <athan> do the functor laws withhold pure referential transparency?
10:02:31 <mm_freak> adityarajbhatt: seriously, purely functional means that we do not perform side effects in code, we merely represent them as values
10:02:33 <test___> mm_freak: I'm not a teacher
10:02:38 <tel> adityarajbhatt so, that part is considered a side effect and thus outlawed by Haskell's particular brand of purity
10:02:44 <mm_freak> test___: that wasn't for you
10:02:50 <adityarajbhatt> Cale: Wow, that's a very clear explanation, thanks that clears up a lot of things.
10:02:51 <mm_freak> i responded to shachaf
10:03:47 <mm_freak> shachaf: let's not discuss this further…  i think i'm able to tell cases when it's helpful from cases when it's not…  and this time my intuition was right, because athan found it helpful
10:03:48 <test___> ohh
10:04:14 <athan> mm_freak was right on the money! He said exactly what I needed to hear!
10:04:38 <athan> the question's context usually denotes noob-level haha
10:05:10 <skypers> @hoogle Identity
10:05:12 <lambdabot> Control.Monad.Identity module Control.Monad.Identity
10:05:12 <lambdabot> Control.Monad.Trans.Identity module Control.Monad.Trans.Identity
10:05:12 <lambdabot> Data.Functor.Identity module Data.Functor.Identity
10:05:28 <athan> So monads are endofunctors on Hask, correct?
10:05:31 <adityarajbhatt> tel: Why does n=4 represent a side effect? n will always be 4 on every evaluation.
10:05:40 <mm_freak> athan: and yes, the functor laws are related to side effects
10:05:55 <Cale> adityarajbhatt: ... it doesn't. You can define n to be 4 in Haskell.
10:06:11 <adityarajbhatt> tel told me my earlier example had side effects.
10:06:13 <platz> I thought I read somewhere that monads were only invented in the 90's.  is that true?
10:06:24 <tel> adityarajbhatt it depends a bit on what exactly `n = 4` means
10:06:35 <Cale> adityarajbhatt: Well, I'm not really sure how to read your example, because it's not Haskell code :)
10:06:38 <adityarajbhatt> tel: I am trying to say that I am assigning the value of 4 to n.
10:06:50 <mm_freak> athan: the functor laws pretty much require fmap not to have side effects of its own
10:06:51 <adityarajbhatt> Cale: Sadly I don't know haskell so I was trying my hand at pseudocode.
10:07:05 <mm_freak> athan: even if the functor itself represents effects (like IO or State)
10:07:06 <tel> adityarajbhatt if it's a mutable assignment then it's a side effect, but if you're just creating a name `n` locally then it isn't
10:07:12 <mm_freak> or example fmap cannot change the state in State
10:07:23 <tel> adityarajbhatt In Haskell you'd write `let n = 4 in ...` for the latter
10:07:36 <Cale> adityarajbhatt: One way to think of it is that every variable in Haskell is a name for a particular value, not a name for a location in memory where different values can be put.
10:07:44 <Hwkiller> Just a question from someone who uses R and is learning python (but loves functional programming): Does haskell vectorize everything it can?
10:07:46 <Hwkiller> ala R
10:07:54 <athan> mm_freak: While the monadic interface can??
10:08:02 <ParahSailin> Hwkiller: no
10:08:08 <adityarajbhatt> Hwkiller: Haha I was going to get to asking that here.
10:08:09 <Cale> (unless that value really is of a type which represents such a location in memory, but that's not the common case)
10:08:37 <Cale> adityarajbhatt: So, if you define n to be 4, you can't farther down the file decide that n will be 5 now.
10:09:13 <adityarajbhatt> Cale: So normally an assignment is like const int n = 5, you can't change it now?
10:09:19 <Hwkiller> also, I have a question about haskell as a 'purely functional' language. From what I understand, functional programming is a style in which the most basic unit is a function. Yet, in haskell, you can have the most basic unit be a non-function. Why then is haskell considered purely functional?
10:09:28 <Hwkiller> also, thanks, ParahSailin
10:09:34 <Cale> adityarajbhatt: Yeah, it's not even an assignment, it's a definition of n
10:09:39 <mm_freak> athan: no, the monad laws require (>>=) and 'return' not to introduce effects of their own
10:09:48 <adityarajbhatt> but why do that, then you'll have to create a separate variable for each separate value
10:09:49 <dwcook> adityarajbhatt, if you really need a variable to change, you probably want an IORef or an MVar or a TVar, though the majority of applications of variables in other languages can be covered using regular old immutable variables.
10:09:52 <athan> mm_freak: Is a functor (in CT) something like a type family or function that acts on categories? (and also follows the laws of category preservation, contravariant, etc)
10:09:57 <tel> Hwkiller I find it much better to think of "functional programming" as a community instead of a style. If you analyze it as a style too much then it tends to fall apart.
10:10:03 <Cale> adityarajbhatt: and having defined n to be 5, you can't later define n to be 6, because that would imply that 5 = 6
10:10:16 <adityarajbhatt> Cale: Oh, I get it now. I mean I get the concept, but not the use.
10:10:20 <Iceland_jack> adityarajbhatt: Have you tried looking at a Haskell resource?
10:10:20 <Iceland_jack> @where lyah
10:10:20 <lambdabot> http://www.learnyouahaskell.com/
10:10:33 <mm_freak> athan: if you find the CT aspect interesting, you should probably learn some basic category theory
10:10:37 <athan> mm_freak: Hmm. But it's the custom functions that each Monad introduces (like putStrLn) that affect state.
10:10:38 <adityarajbhatt> Iceland_jack: No, just wanted to prime myself up first for the basic concepts involved.
10:10:44 <mm_freak> athan: i found the wikibooks article on CT very helpful
10:10:51 <mm_freak> athan: exactly
10:10:59 <tel> adityarajbhatt You can create local, temporary names though. `map (\n -> n + 1) [1,2,3]` introduces the `n` name 3 separate times with three separate values
10:11:00 <mm_freak> athan: i wouldn't say state, i would say effects
10:11:01 <athan> mm_freak: I'm gonna read CT for the mathematician
10:11:10 <Hwkiller> tel: how so?
10:11:22 <athan> mm_freak: I see. This is awesome haha. Thank you.
10:11:23 <mm_freak> athan: monadic effects may not be state-related
10:11:27 <Cale> adityarajbhatt: So, if you want something which changes over the course of a computation, the one place where variables can in some sense take on different values as an expression evaluates is in the parameters to functions.
10:11:27 <Iceland_jack> adityarajbhatt: Maybe that's not the best way to go about it
10:11:31 <adityarajbhatt> tel: So how do you tell Haskell which value of n are you referring to?
10:11:32 <mm_freak> athan: for example Nothing is an effect of Maybe
10:11:39 <Cale> adityarajbhatt: If I define a function such as  double x = x + x
10:11:49 <dwcook> adityarajbhatt, I would recommend reading LYAH, which gives you concrete things to work with, rather than trying to understand the vague term "functional programming".
10:11:56 <Cale> Then I might apply the function double to many different values x over the course that my program runs.
10:12:13 <Cale> But *within* any application of double, the x will be fixed and not change value.
10:12:18 <mm_freak> athan: this may also give you an intuition about the categorical sense of "naturality"
10:12:34 <tel> adityarajbhatt You don't, you create a function (\n -> n + 1) which is pure no matter what the value of `n` is, and then map uses it 3 times
10:12:38 <adityarajbhatt> Iceland_jack: I'm just trying to get myself interested. It's very hard to learn a new language for me I have to motivate myself, plus everyone tells me "Haskell twists your mind in interesting ways" which I basically hear as "You're too dumb. Hasskell is for the smart comp. scientists."
10:12:57 <Iceland_jack> adityarajbhatt: That's not what that implies at all
10:13:00 <mm_freak> athan: fmap (f . g) = fmap f . fmap g;  fmap id = id…  these two laws tell you that 'fmap' is natural for the given functor, because it does not have special cases or other unexpected effects
10:13:10 <athan> mm_freak: Something that preserves the "fmap id = id" sense (but applied to monads and other things too)
10:13:26 <Cale> adityarajbhatt: That's a rather pessimistic reading. ;)  You could equally claim that it says Haskell will help you become a smart computer scientist :)
10:13:29 <yogurt_truck> adityarajbhatt: no idea why you would hear it like that
10:13:45 <Iceland_jack> Or that Haskell has interesting ideas :)
10:13:58 <adityarajbhatt> Cale: I know, but I heard the same things about lisp. But when I tried my hand at it, I found it really difficult to go beyond the basics.
10:13:59 <Cale> (but really, there's probably more to that than learning a single programming language)
10:14:11 <tel> Hwkiller Your question is basically a case in point of this. Haskell is an important language in the FP community, yet it has a style different than other functional languages. Seeking out the features of "functional languages" will tend to be pretty diffuse
10:14:13 <athan> mm_freak: Right! Okay, I think I'm starting to get a hang of it. Any function that doesn't withhold the "pure" sense of haskell doesn't really fit as a way of organizing your code
10:14:22 <athan> like a monad, functor, etc. do
10:14:38 <Cale> tel: Haskell isn't *that* different from the entire ML family...
10:14:40 <dwcook> athan, in what sense are you using the word "withhold"?
10:14:41 <mm_freak> athan: this isn't related to purity
10:14:53 <athan> Anything that causes effects that don't directly relate the input to the output can cause confusion easily
10:15:01 <Yaniel> adityarajbhatt: I found it not too hard to grasp basic stuff (haven't got very far though) but it sure has changed the way I think about stuff a bit already
10:15:01 <tel> Cale No, but it's pretty different from Clojure
10:15:03 <quchen> Cale: The ML family is as far away from mainstream as Haskell is though
10:15:09 <Cale> That's true
10:15:11 <Hwkiller> tel: ah, ok. is there really a 'purely' functional language then? (just curious)
10:15:16 <mm_freak> athan: you could say that they are anti-confusion laws =)
10:15:17 <Cale> quchen: So are all functional languages though ;)
10:15:21 <adityarajbhatt> Yaniel: Yes I know. But after lists when you get to the recursion, it gets a bit tough.
10:15:35 <tel> Hwkiller sorry, no, "purity" is a more potent term than "functional" in describing languages, imo
10:15:43 <quchen> Cale: When absolute numbers are bad, look at the first derivative. Haskell is growing etc :-)
10:15:47 <Yaniel> well isn't recursion pretty similar regardless of language?
10:15:53 <mm_freak> athan: for programmers that is…  mathematicians value those laws as well
10:15:56 <Iceland_jack> Yaniel: Yes it is
10:15:56 <athan> mm_freak Thank you! You've been so helpful!
10:15:56 <tel> Hwkiller though Rust users might call much of Haskell pretty impure
10:16:05 <mm_freak> athan: my pleasure
10:16:12 <Maior> tel: really now...?
10:16:19 <adityarajbhatt> And then I hear all sorts of things about Haskell...it considers anything but recursion ugly and other stuff. They may be just internet rumors, but I get bad vibes. But after talking to you guys, I'm definitely going to try my hand at it.
10:16:31 <Cale> adityarajbhatt: Yeah, that's wrong
10:16:33 <skypers> hey, I got an error with a type in parsec (ParsecT String () Identity a):     No instance for (Stream a10 Identity Char)
10:16:37 <skypers> any idea?
10:16:42 <Yaniel> if you have problems with recursion... better get a good idea of how it works & is used
10:16:45 <athan> mm_freak: I believe it! They'd like a clean definition of a function that relates it's input to its output in an intuitive, condensed way
10:16:50 <Yaniel> else you are, admittedly, screwed
10:16:54 <Cale> adityarajbhatt: For the most part we don't write things recursively, but instead use higher order functions.
10:17:00 <mm_freak> adityarajbhatt: in fact we generally avoid explicit recursion =)
10:17:01 <Cale> adityarajbhatt: For example...
10:17:05 <Cale> > map (*2) [1..10]
10:17:07 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
10:17:07 <adityarajbhatt> Yaniel: I know how it's used but when it's "involved" recursion, you know nested recursion, then for me it's hard to follow.
10:17:11 <dwcook> The only reason I can think of why Haskell might be considered impure is unsafePerformIO
10:17:15 <quchen> adityarajbhatt: Going from C++ to Python is learning another dialect. Haskell will be different, you'll be re-thinking everything you've previously known.
10:17:17 <Iceland_jack> adityarajbhatt: There are also some non-guys here :)
10:17:19 <adityarajbhatt> Cale: Oh that's good to hear.
10:17:34 <tel> Maior eh, I'll probably just lay back on saying that. I don't know enough about Rust. My point is more that referential transparency is defined by the domain and in Haskell we intentionally ignore memory side effects.
10:17:36 <adityarajbhatt> Iceland_jack: haha non-guys?
10:17:40 <Yaniel> quchen: like comparing japanese and english
10:17:43 <dwcook> Valid reason, I should say. People might look at the IO system and go "Side effects!"
10:17:54 <kazagistar> adityarajbhatt: very rarely do you need to do the recursion yourself. Generally, you just use functions over various kinds of collections that do the recursion for you
10:18:07 <Cale> adityarajbhatt: But you should understand recursion anyway, because it's really not that complicated at the end of the day, and it's what the higher order functions typically are written in terms of.
10:18:18 <Maior> tel: ahhh I see what you mean now
10:18:22 <skypers> adityarajbhatt: about what you said earlier, it’s because of nowadays people’s fucked-up-minds
10:18:28 <adityarajbhatt> Don't get me wrong, I like the idea of recursion and grok it well. But I saw some examples the other day and ran the other way immediately. (In scheme if anyone's interested)
10:18:29 <platz> erik meijer says recursion is the 'goto' of functional programming
10:18:30 <skypers> they think like we thought a decade ago
10:18:31 <yogurt_truck> dwcook: those people don't know what side effects are, then
10:18:50 <Iceland_jack> adityarajbhatt: People who don't identify as male, yes
10:19:01 <Cale> adityarajbhatt: Recursion is also easier to think about in Haskell *because* of the lack of mutation and side effects
10:19:09 <skypers> anyone about my parsec issue?
10:19:13 <Cale> adityarajbhatt: there's no program state to keep track of
10:19:13 <skypers> hey, I got an error with a type in parsec (ParsecT String () Identity a):     No instance for (Stream a10 Identity Char)
10:19:25 <mm_freak> adityarajbhatt: you want to print "hi"?  main = putStrLn "hi"…  you want to print "hi" again and again?  well, then you want 'main' again:  main = do putStrLn "hi"; main
10:19:29 <Cale> adityarajbhatt: You just have to think about what the parameters to functions are, and what their results will be
10:19:30 <mm_freak> adityarajbhatt: recursion is as simple as that
10:19:36 <dwcook> yogurt_truck, I mean, it's fair to say that the IO system causes side effects. But that's orthogonal to what's meant by saying the language is pure. :)
10:19:40 <kazagistar> platz: that is a reasonable sentiment. it can be useful sometimes, but almost always you just want to use a higher abstraction
10:19:46 <adityarajbhatt> Okay I'm definitely learning it. So what was that book again? Like what's the best place for a beginner to start?
10:19:49 <tel> dwcook Maybe I'm in the minority but I consider purity to be a relatively well-defined but arbitrary thing. We just pick the level of operation below which we decide to ignore.
10:19:50 <Iceland_jack> But definitely check Haskell out: start with LYAH
10:19:52 <Iceland_jack> @where lyah
10:19:52 <lambdabot> http://www.learnyouahaskell.com/
10:19:58 <Iceland_jack> adityarajbhatt: ↑
10:20:01 <adityarajbhatt> Iceland_jack: Yes thanks
10:20:05 <skypers> dammit noo one is actually reading me :D
10:20:19 <dwcook> tel, I don't understand in what sense something can be well-defined and arbitrary at the same time.
10:20:25 <Cale> yogurt_truck, dwcook: yeah, *execution* of IO actions causes effects, but *evaluation* is pure
10:20:37 <mm_freak> adityarajbhatt: the idea of haskell is to make recursion the primary language construct for representation and computation…  that's what makes everything in haskell short and concise and very powerful at the same time
10:20:44 <fizbin> adityarajbhatt: The best way to learn haskell is to write haskell, get it wrong, and get feedback from experienced haskellers. Which is to say, what you do with any language.
10:20:53 <quchen> NB: Execution = make machine do. Evaluation: do lambda calculus reductions.
10:21:01 <mm_freak> adityarajbhatt: it does /not/ mean that you would use recursion explicitly…  it really means that you can write your own while-loop if you want to
10:21:12 <adityarajbhatt> mm_freak: Got it, thanks. Somebody help skypers. I'm sorry for hijacking the channel like this, I usually don't feel trepidation at learning a language.
10:21:13 <Cale> Yeah, evaluation is the process of turning expressions into values
10:21:25 <adityarajbhatt> I'm off to LYAH.
10:21:27 <mm_freak> adityarajbhatt: because now 'while', try/catch, 'if', 'for', etc. are all regular functions
10:21:30 <Cale> Execution is the process of carrying out the effects described by IO actions.
10:21:38 <platz> was watching some of erik's haskell lecutres on channel 9 before.  He has a nice way of expressing the similarities between OO and FP
10:21:39 <yogurt_truck> these are probably the same people that claim that if your program does _anything_ at all, then "it's not pure!", entirely missing the point of what pure means
10:21:40 <fizbin> adityarajbhatt: I personally learned haskell from "A Gentle Introduction to Haskell 98", and then started solving Perl Quiz of the Week problems in Haskell.
10:21:54 <tel> dwcook In my mind there's a notion of Haskell-purity which most anyone here can pretty easily say whether a computation is H-pure or not, but I don't know if I should feel that H-pure is somehow the best dividing line
10:22:02 <tel> dwcook might be my own ignorance, though
10:22:03 <fizbin> But people have told me that "A Gentle Introduction" is too hard for newbies.
10:22:13 <dwcook> tel, in what other sense might the term be useful?
10:22:39 <quchen> @quote kmc gentle
10:22:39 <lambdabot> kmc says: i started to read the "tutorial" and it was incomprehensible. makes the Gentle Introduction to Haskell look like Teach Yourself PHP in 24 Hours
10:22:42 <quchen> ;-)
10:22:55 <Cale> Which tutorial was that?
10:23:03 <tel> dwcook if we had to reify some kind of memory model in order to describe a computation purely, perhaps
10:23:09 <quchen> I wish I knew. But it says something about how easy the gentle introduction is.
10:23:16 <fizbin> @quote gentle
10:23:17 <lambdabot> kmc says: i started to read the "tutorial" and it was incomprehensible. makes the Gentle Introduction to Haskell look like Teach Yourself PHP in 24 Hours
10:23:26 <mm_freak> quchen: in relation to The Tutorial =)
10:23:29 <fizbin> Is that the worst that can be said about it?
10:23:31 <Maior> <3 lyah
10:23:36 <Cale> The gentle introduction is actually pretty good, it's just tough to take all on its own.
10:23:47 <quchen> mm_freak: You can't say anything here without being held to high logical standards! ;-(
10:23:49 <Maior> BUT I did ML, lambda stuff, etc. as an undergrad
10:23:52 <Cale> If it's the only resource you're working from, then you'll likely have a hard time.
10:24:02 <fizbin> I found it and a collection of simple puzzles to code in a good combination.
10:24:04 <Cale> (unless you're already really familiar with ML or something)
10:24:10 <mm_freak> quchen: can't help it, sorry =/
10:24:14 <fizbin> These days, I might use projecteuler stuff.
10:24:15 <novodinia> http://book.realworldhaskell.org/admin/comments/comment/8780/ Why does this function cause a stack overflow?
10:24:22 <quchen> mm_freak: No worries, I know the feeling
10:24:23 <kristof> bitemyapp: Hey, here's a question that's been bugging me. Is there a good reason to put up with reader monads instead of just introducing dynamically scoped implicit variables into the language?
10:24:23 <novodinia> I didn't think this would ever happen with a Haskell program
10:24:24 <yogurt_truck> tel: do you have an example of something that haskellers (or others) consider pure but which you don't?
10:24:36 <Cale> novodinia: That link goes to a login page
10:24:50 * quchen thinks one of the main points of LYAH is keeping the reader entertained on the way to finding some concepts beautiful enough to continue with the "boring normal literature".
10:24:54 <dwcook> tel, it seems to me like involving claims about memory would make it harder to claim purity. In fact, I'd prefer to avoid conceptualizing memory altogether if I can.
10:25:11 <kazagistar> ive been doing pretty well with 99 haskell problems
10:25:13 <Cale> novodinia: You can get stack overflows in GHC Haskell, but the stack is not what you'd probably think of as a call stack.
10:26:05 <kazagistar> "lazyness" overflows?
10:26:15 <tel> dwcook I agree (and to be clear about alignment, I quite like Haskell's notion of purity) but I can see an argument that says that memory is material and can't be ignored
10:26:20 <Cale> novodinia: It would probably be better to think of it as a pattern match stack. You can imagine that at some level, whenever some value needs to be examined, there is a case expression matching on it, and if the patterns cannot immediately match the expression, then that case needs to wait on a stack until the expression is sufficiently evaluated to match.
10:26:28 <yogurt_truck> yes, one can go into implementations and past all abstractions and look at the CPU and say "see? it's modifying stuff, so your program isn't pure", but that _completely_ misses the point
10:26:31 <fizbin> I used "Gentle" and no prior ML, Agda, etc. experience to learn Haskell. However, the writing style appealed to me, as it was less dense than other stuff I was reading at the time. (I was in grad. school, and some of those math texts...)
10:26:43 <Cale> novodinia: For example...
10:26:45 <Cale> @src foldl
10:26:46 <quchen> yogurt_truck: Not only that. It's plain wrong to say that.
10:26:46 <lambdabot> foldl f z []     = z
10:26:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:26:47 <platz> I've been doing the haskell problems on exercism.io  . there are a couple of reviewers there that somehow review every submission in a 30 min window
10:26:51 <Cale> foldl (+) 0 [1,2,3]
10:27:00 <Cale> --> foldl (+) (0+1) [2,3]
10:27:06 <yogurt_truck> quchen: indeed
10:27:10 <Cale> --> foldl (+) ((0+1)+2) [3]
10:27:11 <Iceland_jack> yogurt_truck: Yes but if/do-while/for/… gets translated to jumps so they're unstructured programming :)
10:27:17 <Cale> --> foldl (+) (((0+1)+2)+3) []
10:27:17 <quchen> yogurt_truck: It's the same thing as saying mathematics isn't pure because when you think about it you change stuff in your brain. That's not even wrong.
10:27:24 <Cale> --> ((0+1)+2)+3
10:27:36 <platz> qnikst and etrepum
10:27:57 <Cale> up until this point, no stack is used (or one bit, depending on whether you think that list needed evaluation to match the pattern in foldl)
10:27:59 <tel> quchen yogurt_truck I'm not going to claim I'm making a good case arguing for a different notion of purity—that's not my stance and I haven't thought very hard about it
10:28:08 <Cale> But in any case, stack usage has been constant
10:28:17 <tel> it's more that if I want to claim that purity is somehow a universal concept
10:28:26 <Cale> But now you have this outermost +, the (...) + 3
10:28:37 <tel> I don't see how you can do that. It's defined against a particular notion of domain
10:28:39 <Cale> and it needs to know what its left parameter is in order to produce a result
10:28:51 <etrepum> platz: I have a lot of free time :)
10:28:53 <Cale> So, it's going to internally do some pattern match on it, which will wait on the stack
10:29:07 <Cale> and the evaluation will proceed with (0+1)+2
10:29:26 <Cale> but then we're in the same position, and again, this will wait on the stack until 0 + 1 is evaluated
10:29:39 <kazagistar> tel: purity is a concept class with a domain parameter?
10:29:54 * kristof 's head spins
10:30:02 <Cale> and then finally, 0 + 1 will be able to evaluate to 1, the stack will be popped, and 1 + 2 will be able to evaluate to 3, the stack will be popped again and 3 + 3 will evaluate to 6
10:30:05 <platz> etrepum: you do exellent work!  I am grateful for it!
10:30:14 <Cale> novodinia: Make sense?
10:30:31 <tel> So if we take the domain to be this nice one of types and mathematical models, CPOs and all, then purity makes perfect sense. But if I want to talk about computations in a different domain, such as moving bits of memory around, then I have to do so much more modeling to talk about that in Haskell.
10:31:02 <tel> kazagistar Maybe—it's how I've been thinking about it recently, but I'd love to be shown to be incorrect
10:31:18 <Cale> novodinia: So if you have something like foldl (+) 0 [1..1000000], the foldl itself won't use any stack, but it's going to construct a gigantic expression composed of (+)'s each of which will result in a stack entry as the evaluation process searches through this expression for something that can actually reduce
10:31:32 <Cale> (in an outermost-first way)
10:31:49 <kristof> Cale: Doesn't the compiler do constant folding?
10:31:58 <Cale> kristof: not like this
10:32:01 <kristof> D:
10:32:13 <kristof> So it actually has to expand that at runtime?
10:32:18 <Cale> But GHC, if you turn optimisations on, does do strictness analysis, and won't actually evaluate this expression in this order
10:32:18 <quchen> Haskell comes with a grammar and a set of rules how to reduce the values built with that grammar down to values of type IO something. That part is pure, and that part is where the pure magic happens, and it's fully pure.
10:32:22 <Cale> Yes, it will.
10:32:37 <quchen> Arguing about how executing the resulting code is impure is boring.
10:33:02 <Cale> quchen: Are you referring to my discussion here?
10:33:08 <quchen> No
10:33:10 <Cale> okay
10:33:13 <bennofs> kristof: If you're interested in that optimization, look for super compilation
10:33:56 <kristof> bennofs: I'm not sure why it's nontrivial to see that Num, +, 0 forms a monoid where 0 is mempty
10:34:01 <kazagistar> kristof: or just use foldl' which is strict
10:34:09 <Cale> Yeah, I suppose it's important to point out that I'm thinking of Haskell as it would be evaluated by a lazy evaluator not unlike what GHC will do with your code if it doesn't choose a different evaluation order instead.
10:34:10 <marunarkh> would you now how to get the child widget (or its value) in HTk (uni-htk package)?
10:34:18 * yogurt_truck doesn't see how computation of moving bits is more or less difficult to express with purely functional code
10:34:18 <tel> quchen I'm not arguing that and I agree with you
10:34:34 <quchen> Fine! kthxbye ;-)
10:34:55 <Cale> Yeah, you can use foldl' here, and it will use seq to force the evaluation of the inside bits of the expression before the farther out parts may be attempted
10:35:41 <Cale> If you compile with optimisations, GHC will discover this itself, generally.
10:36:07 <Cale> (but it's still probably good to be safe about it and use foldl' when you know you'll want that strictness)
10:36:18 <dwcook> yogurt_truck, technically, you can violate your purity invariants using IO, since the program is reasoning about the very same machine on which it's running
10:36:39 <quchen> It's often scary how hard it is to make code crash with GHC. Demonstrating how something overflows in -O code is *hard* :-D
10:37:09 <bennofs> quchen: use -O0 for demonstration :P
10:37:14 <bennofs> (or ghci)
10:37:20 <quchen> Dammit GHC, deadlock already! Stop throwing exceptions about deadlocks! I want to show someone something!
10:37:22 <kristof> dwcook: that's Goedel Escher Bach kind of spooky
10:37:49 <tel> quchen To take a step back on this whole purity conversation—it's not that I take a contrary position, it's just that I'd like to explain to someone exactly what "purity" means and to do so it always seems like you need to introduce a lot about the particular domain. I keep ending up with arguments like "purity means that Haskell behaves the way Haskell behaves" and since Haskell behaves kind of like these really interesting things like CT and TT it's "good".
10:39:17 <quchen> tel: I guess well-defined terms like "referential transparency" are more suitable for that.
10:39:41 <bitemyapp> kristof: uh, Haskell has typed implicit parameters.
10:39:57 <bitemyapp> kristof: but monads are more principled and the preferred solution by far.
10:40:25 <kazagistar> dunno, I find it a bit scary any time a program can run with optimization but fail without it, and foldl vs foldl' does that...
10:41:00 <cwraith> it's just optimizing for memory use
10:41:07 <skypers> :t f
10:41:07 <lambdabot>     Ambiguous occurrence `f'
10:41:08 <lambdabot>     It could refer to either `L.f',
10:41:08 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:163:1
10:41:13 <tel> quchen I kind of like referential transparency, but I don't know what to say about Bob Harper's criticisms of that term
10:41:14 <skypers> :D
10:41:16 <skypers> wtf
10:41:23 <skypers> I see you lambdabot
10:41:32 <etrepum> platz: you're welcome :)
10:41:36 <quchen> I don't know Bob Harper's criticism. :-/
10:41:40 <Cale> kazagistar: Well, that's the price you pay for having a smart compiler
10:41:44 <bitemyapp> quchen: don't worry about it :)
10:41:57 <quchen> bitemyapp: Good answer, thanks. :-D
10:42:13 <skypers> :t liftM id <=< readFile
10:42:14 <lambdabot>     Couldn't match type `[]' with `IO'
10:42:15 <lambdabot>     Expected type: FilePath -> IO (IO Char)
10:42:15 <lambdabot>       Actual type: FilePath -> IO String
10:42:16 <kazagistar> cwraith: right, but running out of memory is a crash condition, since our machines are linear bounded automatons, and not proper Turing machines
10:42:17 <Iceland_jack> > begin push 5 push 6 push 7 add add end
10:42:18 <lambdabot>  18
10:42:21 <Cale> kazagistar: I think at the end of the day, you just have to be aware of how some things are being compiled regardless.
10:42:24 <Iceland_jack> > begin push 5 push 6 add end
10:42:24 <bitemyapp> quchen: I've done my share of battle with minsky and harper, it's not a good use of time. They just don't value the same things we do and don't seem to really understand purity-by-default.
10:42:26 <lambdabot>  11
10:42:30 <roconnor> @quote calculator
10:42:30 <lambdabot> ricky_clarkson says: Sorry, I only use Haskell as a posh calculator.
10:42:33 <tel> quchen bitemyapp ha
10:43:15 <bennofs> @ty begin
10:43:16 <lambdabot> Not in scope: `begin'
10:43:32 <bennofs> Oh, secret lambdabot easter egg?
10:43:44 <dwcook> Iceland_jack, does that use something similar to the printf trick?
10:43:46 <dwcook> @type begin
10:43:47 <lambdabot> Not in scope: `begin'
10:44:01 <roconnor> @quote stack-calculator
10:44:01 <lambdabot> stack-calculator says: let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
10:44:29 <dwcook> Huh.
10:45:05 <marunarkh> Did you work with HTk.*?
10:45:23 <kazagistar> Cale: right, I guess in haskell with any more complex program, you are going to just have to test it. I just prefer to coerse strictness and get the same big-O behavior regardless of compiler... still not content with the compiler changing the time or memory complexity
10:45:39 <bitemyapp> kristof: it's just DI anyway.
10:46:22 <Iceland_jack> dwcook: begin f = f [], push xs x k = k (x:xs), add (x:y:ys) k = k (x+y:ys), end [x] = x
10:46:27 <tel> bitemyapp That may be true, but I'd like to learn what a good definition of referential transparency is, f x = y seems to either hold as tautology or be defined in terms of an interaction or evaluation. I probably just don't have my head around the question well enough yet, though
10:46:28 <triliyn> tel: the way I usually think about it is, unless you have a particular reason to worry about something else, it makes the most sense to be pure in your PROBLEM domain
10:46:35 <Iceland_jack> no magic
10:47:00 <Cale> kazagistar: Yeah, it's still generally good to be aware of it when you realise that you're doing something which typically demands strictness. The rule of thumb that I use is whenever you're taking lots of individually evaluatable values, and collapsing them down into some kind of summary which has few separately evaluatable parts, that's when you'll likely need some strictness.
10:47:03 <dwcook> Iceland_jack, "magic" is relative ;)
10:47:27 <Iceland_jack> That's true :)
10:47:44 <triliyn> So that unless you're trying to model memory in particular, explicitly showing every effect on pointers is not important
10:47:45 <dwcook> It looked like magic to me because it seemed to be working in a way I couldn't quite fathom
10:47:57 <bitemyapp> tel: do we have some prior interaction I'm not familiar with?
10:47:57 <yogurt_truck> wait, so "referential transparency" is also seen as a "subjective" thing? :/
10:48:04 <dwcook> But in fact I knew all the individual parts, just imagining them together was hard
10:48:04 <triliyn> (This can of course be modified by sufficiently serious performance needs)
10:48:16 <tel> bitemyapp I'm running off your response to quchen
10:48:45 <Iceland_jack> dwcook: check out the “Techniques for Embedding Postfix Languages in Haskell” paper
10:49:11 <Iceland_jack> also Okasaki's stuff on “Flattening combinators: Surviving without parentheses”
10:49:20 <dwcook> Neat.
10:49:28 <tel> triliyn Yeah, that's kind of my guiding intuition, too. I'd like to say something dumb like "purity just defines what's important to you", but I probably don't really mean purity there, really
10:49:55 <yogurt_truck> bitemyapp: Just googled for bob harper on RT but I didn't find anything useful. I'm sure he must have interesting views on it, but I think to claim that RT is too relative or not that good or whatever would be a silly stretch.
10:49:59 <Iceland_jack> Any sufficiently advanced combinator is indistinguishable from magic ;)
10:51:41 <tel> yogurt_truck: the best I can find is (http://existentialtype.wordpress.com/2013/07/18/what-if-anything-is-a-declarative-language/) point #6, but there was something I read elsewhere, too
10:51:44 <platz> this is some good stuff.  so much lol : http://www.haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
10:52:34 <zomg> phischu: Xaskell?
10:52:38 <Iceland_jack> “Haskell, the warm fuzzy nuclear waste.” has my vote
10:53:34 <Iceland_jack> Is it too much to ask not to mention laziness, monads, lambdas or bind in the logo? :)
10:53:46 <Iceland_jack> (or unsafePerformIO!)
10:54:24 <joelteon> yeah why are all of them about lambdas
10:54:25 <yogurt_truck> tel: yeah I found that. kinda hard for me to know what he's even saying there
10:54:32 <platz> Iceland_jack: I searched for the page because i wondered if the current logo was intentionally a little bind-like
10:54:45 <joelteon> there are some really good ones on that page
10:54:47 <joelteon> most of them are crap though
10:54:47 <yogurt_truck> "...In any case why you would decide a priori on what equivalences you want before you even know what it means to run a program?" o.I
10:54:55 <Iceland_jack> platz: It is
10:55:16 <zomg> joelteon: I would imagine not a lot of them are by people with design backgrounds...
10:55:24 <Iceland_jack> I'm not too keen about putting Haskell references or inside jokes into the logo
10:55:24 <zomg> taking that into account they're not *too* bad, but.. :D
10:55:44 <joelteon> zomg: well, that's why you don't ask programmers for graphic design services
10:55:52 <zomg> yeah.. =)
10:55:55 <joelteon> but http://www.haskell.org/haskellwiki/File:Haskell2v3.png, http://www.haskell.org/haskellwiki/File:Haskell-apankrat.png, and http://www.haskell.org/haskellwiki/File:Haskell_logo_ideas_5_falconnl.png could all be actual logos
10:56:11 <Iceland_jack> If you know what lambdas/monads/... are you probably know that Haskell has them, if you don't then it won't mean anything to you anyway
10:56:11 <dzhus> how do I define a type-level constant function?
10:56:33 <platz> nothing wrong with hiring a good graphic designer
10:57:17 <quchen> dzhus: type Constant a b = a?
10:57:25 <zomg> joelteon: yeah those are the couple good ones I noticed as well
10:57:40 <joelteon> all the rest are disastrous
10:57:56 <Iceland_jack> I think http://www.haskell.org/wikiupload/8/81/HaskellLogo-v2.png looks okay
10:58:24 <Iceland_jack> ‘haskell ∷ Pure’ doesn't make a whole lot of sense :)
10:58:24 <quchen> It's a lambda in a circle and it says "Haskell"
10:58:48 <Iceland_jack> de gustibus
11:00:01 <dwcook> Haskell for Google Chrome :P http://www.haskell.org/haskellwiki/File:Haskell_logo_falconnl_8_basic.png
11:00:08 <dzhus> quchen: kinded * -> *, not *
11:00:19 <triliyn> Iceland_jack: I like "H ELL ASK"
11:00:38 <bennofs> Haskell for nixos: http://www.haskell.org/haskellwiki/File:Sgf-logo-blue.png
11:00:59 <cmiller_> triliyn: "You're asking for hell if you use this language!"
11:01:01 <yogurt_truck> tel: found this https://groups.google.com/d/msg/comp.lang.functional/M8WMpZJgQfQ/-jOycYbVX3cJ
11:01:04 <platz> some langs doesn't even get a logo e.g. javascript, c#
11:01:48 * Iceland_jack is jealous of Clojure's logo
11:02:05 <yogurt_truck> "My own conclusion is that it's an oft-repeated, but empty, buzz-phrase." =/
11:02:32 <joelteon> clojure's logo is ugly
11:02:43 <bennofs> Pretty boring
11:02:53 <aleksejs_> platz, JS has an semi-official logo http://en.wikipedia.org/wiki/File:Unofficial_JavaScript_logo_2.svg because there's no organization, that would govern JS
11:02:56 <Sculptor> so haskell logo is a snowflake
11:02:59 <quchen> Haskell's logo is awesome and it is OT to argue otherwise! :-)
11:03:30 <joelteon> wow what an exciting logo
11:03:49 <Iceland_jack> Maybe Haskell needs a mascot :) the applicative functor cat
11:04:02 <platz> at least they didn't try to put something with prototypes in the logo
11:05:00 <bennofs> Iceland_jack: The category cat :p
11:05:08 <Iceland_jack> bennofs: A bit on the nose :)
11:05:16 <Iceland_jack> The category dog *rolls eyes*
11:05:29 <allsystemsarego> > runWriter (fmap and $ sequence [return True, return False])
11:05:31 <lambdabot>  (False,())
11:06:00 <eikke> hah, an ex-colleague :P
11:07:51 <mm_freak> dog is actually a functor
11:07:56 <platz> JS logo went for solidarity.  Pathos over Logos
11:08:05 <mm_freak> Dog : Cat → Meat
11:09:13 * quchen prefers the opposite category
11:09:23 <bennofs> god ?
11:09:41 <sleepynate> oh man, i've been using the Dog from Prelude, which is typed Dog : DogFood -> SulfericFart
11:09:55 <sleepynate> if only i'd known!
11:10:17 <dwcook> Dog : Cat → Meat×Poop -- ftfy
11:10:25 <dwcook> Wait
11:10:36 <FireFly> Iceland_jack: I don't think the >>= in the current logo is that noticeable if you don't already know about it
11:10:43 <dwcook> Never mind, it's fine as it is :P
11:10:54 <FireFly> Well, at least it wasn't to me before I knew about it :P  mostly just seemed like a stylish lambda
11:10:59 <Iceland_jack> FireFly: Yes I actually agree with that
11:11:00 <quchen> FireFly: Which is probably a good thing, otherwise people would think there was bit-wise right shift in the Haskell logo
11:11:10 <FireFly> quchen: yes, I agree.
11:11:25 <bennofs> I like the current haskell logo :=)
11:11:47 <mm_freak> except for the "oh, there is a lambda" i think the haskell logo is pretty much unintelligible for non-haskellers =)
11:11:48 <quchen> It's a funny moment when learning Haskell and you realize that inequality has become /= for you, and >>= isn't bitwise anything.
11:11:50 <mm_freak> which is fine
11:12:08 <bennofs> Oh, no 2014 news item on haskell.org yet?
11:12:26 <bennofs> Ah, at least under events there is something from 2014
11:13:19 <mm_freak> quchen: even more confusing when you realize that (<<=) is something even more mind-bending than (>>=)
11:13:21 <mm_freak> =)
11:13:33 <quchen> Arguably.
11:13:42 <quchen> It's just not as widely used, but not much harder conceptually.
11:13:48 <eikke> :t (<<=)
11:13:49 <lambdabot>     Not in scope: `<<='
11:13:49 <lambdabot>     Perhaps you meant one of these:
11:13:49 <lambdabot>       `<=' (imported from Data.Ord), `<<<' (imported from Control.Arrow),
11:13:56 <mm_freak> :t extend
11:13:56 <quchen> eikke: Control.Comonad
11:13:57 <lambdabot> Not in scope: `extend'
11:14:00 <bennofs> :t Control.Comonad.(<<=)
11:14:01 <lambdabot> Couldn't find qualified module.
11:14:01 <eikke> ah, ok
11:14:10 <quchen> It's Comonads "=<<"
11:14:11 <eikke> :t (>=>)
11:14:12 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
11:14:19 <mm_freak> it's extend or flip extend, i can't remember
11:14:35 <FireFly> quchen: I guess it also has a =>> to mirror?
11:14:40 <quchen> Yes
11:14:53 <quchen> There's also =>= etc
11:14:57 <FireFly> ._.
11:15:00 <quchen> (Which is co->=>)
11:15:13 <eikke> I should read up on comonads. Read an article about coeffects in F# today
11:15:18 <mm_freak> and coreturn aka "extract"
11:16:01 <kazagistar> hmm, what would be the best way to programatically verify properties about a datatype? for example, I want to ensure that given an instance of Person = Person {age :: Int, accompanied :: Bool}, the expression (age >= 18 or accompanied) must be True? where and how should I place my assertions or whatever in haskell?
11:16:15 <FireFly> >>> >>= >=> =>> =>=  <<< =<< <=< =<< =<=
11:16:21 <FireFly> @ty (==>)
11:16:23 <lambdabot> Testable prop => Bool -> prop -> Property
11:16:28 <bitemyapp> ocharles: hi! I got an appreciative comment for RT'ing your tasty-rerun, so I figured I'd pass on the love :)
11:16:37 <quchen> I'm still wondering why >>= was chosen for the Monad operation. I would probably have picked something that's not used in other languages.
11:16:51 <eikke> kazagistar: I guess you'll want a smart constructor, something like "person :: Int -> Bool -> Maybe Person"
11:17:35 <mm_freak> kazagistar: do you want to prove (compile time) or just check (run time)?
11:18:02 <ocharles> bitemyapp: wasn't that from me? :)
11:18:12 <kazagistar> mm_freak: preferably compile time of course, but runtime is fine
11:18:25 <mm_freak> kazagistar: for run-time what eikke said
11:18:44 <mm_freak> kazagistar: proofs will be a lot more involved
11:18:55 <kazagistar> but I would prefer it to be impossible to construct an invalid Person without hitting an assertion or something
11:19:08 <eikke> kazagistar: then you want what I showed above :)
11:19:42 <eikke> hide the actual 'Person' constructor, and expose a function which given the required values returns Just a Person, or Nothing (or if you want, Left an error or Right a Person)
11:19:50 <mm_freak> kazagistar: if you prove, then the compiler will make it impossible to construct a wrong person…  otherwise it's just an engineering question:  write a module and export a safe interface
11:20:48 <kazagistar> eikke: if I hide the person construct, does that mean I lose all the capability to use accessor/modifier syntax, pattern matching, etc? do I have to reimplement "safe" ways to do each of those?
11:21:11 <mm_freak> kazagistar: yes, you need to write accessors and mapping functions
11:21:49 <eikke> indeed
11:22:08 <mm_freak> kazagistar: you can also write getters and setters, if you prefer
11:22:19 <kazagistar> hmm, would it be possible to write a library to do it for me, as a macro or somesuch? so I could declare the invariants, and it would fill in the code to enable normal usage of the type?
11:22:20 <mm_freak> (you can write lenses, but they would have awkward Maybes in them)
11:22:29 <lllllllllllll> mm_freak, can you maybe hint me to a real world application using netwire5?
11:22:41 <mm_freak> lllllllllllll: right now none exist
11:22:44 <ocharles> lllllllllllll: does partial clone of Super Mario count?
11:22:47 <lllllllllllll> i really like it and want to look at some more code
11:23:02 <ocharles> a partial*
11:23:03 <mm_freak> lllllllllllll: ocharles is doing amazing stuff with netwire 5 =)
11:23:06 <lllllllllllll> ocharles, of course
11:23:19 <ocharles> d'aww
11:23:26 <ocharles> with that encouragement, I might do more tonight :)
11:23:34 <ocharles> lllllllllllll: let me push my shoddy code somewhere
11:23:36 <lllllllllllll> netwire5 and super mario what can be better :)
11:23:43 <mm_freak> hehe
11:24:13 <mm_freak> i would love to see a real game engine based on netwire some day =)
11:24:24 <mm_freak> chances are i will be involved in its development
11:24:42 <ocharles> i want to try and get beyond toy examples
11:24:48 <kazagistar> hmm, it seems like that kinda makes haskell sucky for normal verification, for anything hard to express in the type system...
11:24:54 <ocharles> dealing with the more "boring" stuff like menus and saving will still be interesting to try in netwire
11:25:11 <mm_freak> kazagistar: you can always do the traditional run-time checks
11:25:36 <mm_freak> kazagistar: in that regard it's about as sucky as every other language =)
11:25:40 <kazagistar> mm_freak: right, but where? everywhere I use the type?
11:25:51 <mm_freak> kazagistar: where you construct persons
11:26:20 <mm_freak> kazagistar: example:  person :: Int -> Bool -> Person
11:26:24 <eikke> kazagistar: http://www.haskell.org/haskellwiki/Smart_constructors
11:26:59 <mm_freak> kazagistar: but it's already a bad idea to have a Bool and an Int there, because they encode no semantic information on the type level at all…  only the field names give interpretation
11:27:04 <kazagistar> mm_freak: its just that I lose almost all the nice features of haskell as soon as I start building explict constructors, wheras, say, java, I can specify an assert at the end of my constructor, and lose nothing
11:27:15 <mm_freak> kazagistar: you may be interested in this article:  http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
11:28:02 <bennofs> kazagistar: But you only lose patterns matching, or?
11:28:06 <mm_freak> kazagistar: you would do pretty much the same thing in haskell…  java is based on validation, while in haskell we prefer more formal ways to construct correctness
11:28:25 <mm_freak> kazagistar: an algebraic data type ideally makes it impossible to construct a wrong value
11:28:37 <ocharles> lllllllllllll: https://github.com/ocharles/netwire-platformer
11:28:38 <eikke> bennofs: with pattern synonyms and view patterns, you might have them back :)
11:28:46 <ocharles> lllllllllllll: The most complete code is "OldCode.hs" but it's a bit of a mess
11:28:53 <ocharles> I was in the process of refactoring it into a bit more of a normal application
11:28:55 <kazagistar> mm_freak: ok, so how do I make it impossible to construct a data type given a restriction like the one I gave, or similar?
11:28:58 <lllllllllllll> ocharles, thx, much appreciated
11:29:06 <mm_freak> but there is a tradeoff…  you trade correctness for convenience sometimes, and in those cases you have to provide a safe interface
11:29:16 <bennofs> eikke: view patterns + pattern synonyms + lenses rock :)
11:29:28 <ocharles> lllllllllllll: it's really me just dumping ideas in a haskell file, so expect a mess :)
11:29:30 <mm_freak> kazagistar: this interface can have your assertions (if you really want to crash the program) or you can have Maybe and other helpers
11:29:34 <eikke> bennofs: how's lens involved?
11:30:14 <Cale> kazagistar: You should use a smart constructor for Person, hiding the Person data constructor behind a module boundary, because it can be used to construct values of that type which don't meet your invariant.
11:30:40 <noberkfast> http://lpaste.net/98907
11:30:50 <noberkfast> I'm getting the following errors..
11:30:57 <bennofs> eikke: You can have prisms for your constructors, so you can write (preview _Left -> Just x). Makes things easier
11:31:08 <kazagistar> Cale, mm_freak: Is there any way to save pattern matching through all this?
11:31:33 <mm_freak> kazagistar: prisms
11:32:02 <shachaf> Prisms won't give you everything.
11:32:02 <eikke> bennofs: got a more elaborate example of that?
11:32:03 <Cale> kazagistar: Not yet, but soon enough via the pattern synonyms extension
11:32:11 <shachaf> For example, you won't get exhaustiveness checking.
11:32:16 <Cale> or I suppose it might count to use view patterns
11:32:31 <mm_freak> view patterns would also work
11:32:36 <mm_freak> or pattern guards in some cases
11:32:55 <mm_freak> (i never understood why pattern guards became standard, but view patterns did not)
11:33:25 <lllllllllllll> ocharles, looks exactly like what i looked for (since i had the same idea of trying to make a super mario clone with netwire)
11:36:30 <kazagistar> Cole, mm_freak: thanks, i'll look into those options. I am learning OCL and modeling in software engineering classes, and haskell in my own time, and am trying to connect the two
11:37:44 <eikke> kazagistar: in my opinion, the way modeling is teached at uni doesn't always map very well on non-OO languages
11:38:00 <rajeshsr> Hi all,
11:39:08 <mm_freak> kazagistar: you might find this interesting: http://goto.ucsd.edu/~rjhala/liquid/haskell/blog/about/
11:40:16 <c_wraith> eikke: I found very little evidence it maps well to OO languages, either.
11:40:19 <kazagistar> eikke: I understand the approaches are different, and I know that one is not better in an absolute sense (OCL has everything nullable by default, for example, which seems terrible). I just find that learning alternative styles helps me get a good idea of the strengths and weaknesses of both. It is interesting if you can do something easily in one paradigm and not another.
11:41:10 <rajeshsr> apart from xmonad is there some simple well-written Haskell code that you recommend reading, to internalize Haskell idioms and ways of doing things?
11:41:25 <noberkfast> http://lpaste.net/98909 now pasted with the error im getting
11:41:27 <eikke> c_wraith: lol
11:41:42 <eikke> kazagistar: point is, maybe in Haskell you should use other approaches
11:42:17 <yayutf> i second rajeshsr's question :-)
11:42:18 <mm_freak> rajeshsr: required to be programs?  or do libraries count as well?
11:42:57 <kazagistar> eikke: that is why I am here, to find the best approach from the haskell side for checking correctness?
11:43:10 <noberkfast> can anyone help.. i dont understand the error.. or how to go forward from here..
11:43:39 <yayutf> kazagistar: i wouldn't call it 'correctness', per se, but if you want to find bugs, quickcheck can be handy
11:43:49 <jrmithdobbs> why isn't NewtypeDeriving free and just part of the standard?
11:43:51 <rajeshsr> mm_freak, both are fine
11:44:02 <mm_freak> kazagistar: the desire for one-size-fits-all is common in the OO world, and many haskell newcomers find it confusing that there is no one single abstraction/approach to rule them all…  in other words:  there are many approaches, and it really depends on the application which one to choose
11:44:12 <bennofs> jrmithdobbs: it isn't safe until GHC 7.8
11:44:28 <jrmithdobbs> bennofs: in what way?
11:44:42 <c_wraith> noberkfast: that error message is just a type error.  It's saying that you're mixing values of type a and AD s a somewhere that the types are expected to be the same.
11:45:17 <kazagistar> mm_freak: yeah, fair enough, thats why I went with a specific example and asked for solutions, rather then asking about absolute rules
11:45:21 <thoughtpolice> jrmithdobbs: you can basically cause unsafeCoerce through the interaction of NewtypeDeriving and TypeFamilies. TypeFamilies are like type-level functions. you may think these have nothing to do with each other, but they very much do
11:45:22 <bennofs> jrmithdobbs: Ah, it seems one needs TypeFamilies for that, which aren't in the standard either
11:45:31 <eikke> jrmithdobbs: roles
11:45:36 <mm_freak> rajeshsr: well, you could look into darcs, pandoc, happstack, pipes, etc.
11:45:36 <bennofs> jrmithdobbs: http://joyoftypes.blogspot.de/2012/08/generalizednewtypederiving-is.html
11:45:41 <c_wraith> noberkfast: well, in particular, it's saying that it's going on with stuff on line 30.  Double-check the types of the functions you're using there
11:45:42 <bennofs> snap
11:46:05 <noberkfast> from my understanding its working if the types of x and y belong to the typeclass Floating and any specific types like Double or Float
11:46:08 <rajeshsr> mm_freak, hmm! how simple are they? :) Can you order them by simplicity?
11:46:28 <mm_freak> kazagistar: your example is incomplete, because you still have to put it into the context of an application
11:46:29 <thoughtpolice> jrmithdobbs: anyway this problem has actually been known about for at least 5-7 years, but it wasn't finally fixed until recently
11:46:29 <jrmithdobbs> bennofs: is it ok without type families?
11:46:49 <noberkfast> and not any specific type like Double or Float.. but works if x :: Floating a => [a]
11:46:54 <c_wraith> noberkfast: I think you're reading polymorphic types wrong.
11:46:54 <mm_freak> rajeshsr: depends on your notion of simplicity =)
11:46:56 <thoughtpolice> jmcarthur: yes, without TypeFamilies, GND is safe. (SafeHaskell still ban GND, however)
11:47:07 <thoughtpolice> er
11:47:17 <thoughtpolice> jrmithdobbs: yes, without TypeFamilies, GND is safe. (SafeHaskell still ban GND, however)
11:47:32 <c_wraith> noberkfast: in particular, the type Floating a => a -> a means that both the argument type and the return value must be *exactly* the same
11:47:57 <rajeshsr> mm_freak, hmm! LoC is a good proxy and may be not using too much uncanny Haskell/GHC-internal features is another metric?
11:48:42 <c_wraith> noberkfast: It's not subtyping.  It's saying that Floating is a property a type can have, and that it's a function from some type that has the Floating property to that same type
11:48:50 <eikke> rajeshsr: how the usage of extensions counts might be up for debate ;)
11:49:10 <jrmithdobbs> so if i'm writing a library that needs it internally for creating a useful non-clashing monoid instance for Data.Tree and said library has no need of TypeFamilies it's ok, but if a consumer of said code also uses TypeFamlies then does it all come crashing down again?
11:49:17 <kazagistar> loc seems like a terrible proxy for simplicity :P
11:49:35 <rajeshsr> eikke, haha! well, i just don't want to keep track of too many things in my head when learning. Simple cognitive overhead is the issue! :)
11:49:53 <bennofs> thoughtpolice: well, https://ghc.haskell.org/trac/ghc/ticket/1496 says that there is still some issue (Somebody manages to break the Set invariant with only GND)
11:50:10 <rajeshsr> same is true with LoC. You don't want to be too overwhelmed as to npt be able to visualize where each data structure or function fits in..
11:50:14 <jrmithdobbs> thoughtpolice: or said simpler, does the problem only arise from usage within the same module?
11:50:24 <eikke> rajeshsr: point is, sometimes a construct which is trivial to implement using some extension is implemented using 'more standard', but more complex code. then it depends.
11:50:25 <rajeshsr> it helps in understanding strucuting of modules better
11:50:26 <mm_freak> rajeshsr: hmm, good question…  most real applications do use some of the more advanced abstractions
11:50:49 <mm_freak> pandoc is probably easy enough
11:51:09 <mm_freak> but then it may not qualify as a sufficiently complex application
11:51:17 <rajeshsr> eikke, True that! It is good for implementers, not for people to learn! :)
11:51:28 <rajeshsr> mm_freak, what does pandoc do?
11:51:36 <mm_freak> it converts between various text formats
11:51:53 <rajeshsr> ha, i see! seems too simple and "functional" ;)
11:52:00 <mm_freak> most notably between HTML and markdown in both directions
11:52:06 <noberkfast> http://lpaste.net/98910 this is working without any errors..
11:52:33 <noberkfast> replaced all Double or Floats with a type of typeclass Floating
11:52:46 <mm_freak> rajeshsr: you should really provide a narrower domain of what you would find interesting
11:53:14 <noberkfast> just load the code in ghci and type partdiffs 1 2 3
11:53:57 <rajeshsr> mm_freak, that makes sense. May be something along the lines of system design, may be simple web servers or even filesystems etc. Something that's more "imperative" by our current pre-dominant understanding of the problem.
11:54:38 <mm_freak> rajeshsr: you could look into darcsden
11:54:47 <mm_freak> the web application behind hub.darcs.net
11:55:24 <thoughtpolice> bennofs: FWIW, that's fixed with Roles in the new HEAD, IIRC
11:55:24 <rajeshsr> mm_freak, oh, thanks!
11:55:27 <mm_freak> it includes many nontrivial things like user management, a builtin SSH server and a darcs interface
11:55:55 <mm_freak> rajeshsr: another interesting application is gitit, which may be easier to digest than darcsden
11:55:56 <troydm> who is the ghc from source building expert here?
11:56:08 <jrmithdobbs> oh man, ya GND is not worth those risks
11:56:10 <mm_freak> rajeshsr: gitit is a wiki
11:56:11 <troydm> i have a problem compiling ghc
11:56:22 <jrmithdobbs> when is 7.8 actually getting released? ;p
11:56:24 <peddie> troydm: you could try #ghc perhaps
11:56:41 <platz> git-annex is written in haskell; I might study that one later
11:57:07 <thoughtpolice> jrmithdobbs: it's not really a module-level thing. see the example here: https://ghc.haskell.org/trac/ghc/wiki/Roles or here https://ghc.haskell.org/trac/ghc/ticket/1496 - note it's simply the interaction of GND for a newtype + type families over that newtype
11:57:16 <mm_freak> rajeshsr: for a more local application you can look into yi
11:57:17 <rajeshsr> interesting, i have heard of that, but never knew it was written in haskell, mm_freak
11:57:26 <jrmithdobbs> thoughtpolice: ya i finished reading that article and see how it doesn't matter
11:57:28 <mm_freak> =)
11:57:56 <rajeshsr> hmm, yi seems interesting as well.
11:58:18 <thoughtpolice> the fundamental problem is that the TypeFamilies will allow to 'speak' about the two types as if they are different nominally *and* representationally. in reality, they are representationally equivalent too and you have to check this. still, GND is a useful extension, it's just got a few sharp edges.
11:58:29 <thoughtpolice> (and those sharp edges will go away)
11:58:32 <rajeshsr> thanks a lot for the suggestions, mm_freak
11:58:59 <roconnor> what is representationally?
11:59:36 <alpounet> thoughtpolice: the role stuffs solve the issues right?
12:00:10 <thoughtpolice> alpounet: correct
12:00:16 <mm_freak> GND?
12:00:35 <S11001001> roconnor: as defined in http://www.haskell.org/pipermail/libraries/2013-November/021707.html I believe
12:00:37 <triliyn> GeneralizedNewtypeDeriving, probably
12:00:53 <thoughtpolice> roconnor: if they're nominally equal, they're equal by name. if they're representationally equal, they have the same runtime representation. 'newtype Age = Age Int' - Age and Int are representationally, but not nominally equal
12:01:18 <thoughtpolice> IMO the wiki page gives the best rundown still, and it has some of the highlights with 'coerce' and Coercible in 7.8: https://ghc.haskell.org/trac/ghc/wiki/Roles
12:01:23 <mizu_no_oto> Is there a nice way to get all of the types which implement a typeclass?
12:01:43 <mm_freak> mizu_no_oto: no
12:01:59 <shachaf> mizu_no_oto: :i in ghci will tell you all the ones that are in scope.
12:01:59 <roconnor> thoughtpolice: if I define Bool twice in two different modules (perhaps with different constructor names) are they represenationally equal?
12:02:01 <mm_freak> mizu_no_oto: but there is a nice way to get all types /in scope/ which do:  use :i Class in GHCi
12:05:30 <novodinia> > read "8.2" + 3.8
12:05:32 <lambdabot>  12.0
12:05:37 <novodinia> isn't that type coercison?
12:05:40 <novodinia> coercion*
12:06:25 <verement> :t read "8.2"
12:06:26 <lambdabot> Read a => a
12:06:33 <thoughtpolice> roconnor: at the moment, no, they are not considered representationally equal (or nominally, obviously.)
12:06:34 <verement> :t 3.8
12:06:35 <lambdabot> Fractional a => a
12:06:39 <verement> :t (+)
12:06:40 <lambdabot> Num a => a -> a -> a
12:06:56 <eikke> read "1.2 + 2.8" :: Float
12:07:00 <eikke> > read "1.2 + 2.8" :: Float
12:07:02 <lambdabot>  *Exception: Prelude.read: no parse
12:07:04 <eikke> damnit ;)
12:07:19 <verement> > read "1.2" + 2.8 :: Float
12:07:21 <lambdabot>  4.0
12:07:55 <hpc> > 4.0 -- the best version!
12:07:56 <lambdabot>  4.0
12:08:06 <novodinia> "8.2" + 3.8 = String + Fractional, right?
12:08:23 <novodinia> read converts 8.2 to a Fractional?
12:08:31 <geekosaur> Fractional is not a tyoe
12:08:33 <geekosaur> *type
12:08:34 <hpc> Fractional is a type class
12:08:40 <novodinia> >t 3.8
12:08:47 <novodinia> > :t 3.8
12:08:48 <lambdabot>  <hint>:1:1: parse error on input `:'
12:09:01 <hpc> it produces a value of some type which is an instance of Fractional
12:09:10 <geekosaur> literals can be polymorphic. read has to pick a specific type
12:09:30 <geekosaur> (more precisely read must be told *which* specific type.)
12:09:34 <noberkfast> Cale: c_wraith http://lpaste.net/98909 the annotate code with some changes works.. it compiles without any errors..
12:09:45 <noberkfast> scroll down to the end..
12:09:49 <timthelion> more importantly, don't use read!  Use readMaybe or some parser!
12:10:44 <yogurt_truck> does cabal keep a log somewhere?
12:10:54 <noberkfast> partdiffs gives error while partdiffs' works..
12:11:33 <noberkfast> partdiffs gets x and y from a text file.. whose type i force it to be [Double] or [Float]
12:11:43 <yogurt_truck> nvm, found them.
12:12:15 <noberkfast> but for partdiffs' i give xx and yy and make its type Floating a => a
12:12:20 <nadirs> novodinia: you don't need `>` before `:t` :)
12:12:36 <nadirs> :t 3.8 -- novodinia
12:12:37 <lambdabot> Fractional a => a
12:12:53 <noberkfast> it seems to work.. i dont know why its not working..
12:16:29 <dmj`> how do I persist an MVar between multiple web handlers in snap?
12:19:42 <stepkut> isn't there some function like, (Eq a) => [(a, b)] -> [(a, [b])], which takes an assoc list and then groups all the things that have the same 'a' value?
12:20:45 <Cale> stepkut: no, but I've written that function enough times that perhaps there ought to be. You'll need Ord to do it efficiently, and one of the simplest ways is to use Map.fromListWith and Map.toList
12:21:38 <stepkut> Cale: perhaps I have also written it enough that I remembering a time I wrote it :)
12:22:45 <stepkut> the fromListWitch and toList verions also needs a step to convert the [(a, b)] to [(a, [b])] where [b] is a singleton, right?
12:23:06 <Cale> :t Map.toList . Map.fromListWith (++) . map (\(x,y) -> (x,[y]))
12:23:07 <lambdabot> Couldn't find qualified module.
12:23:12 <Cale> :t M.toList . M.fromListWith (++) . map (\(x,y) -> (x,[y]))
12:23:13 <lambdabot> Ord k => [(k, a)] -> [(k, [a])]
12:23:19 <stepkut> yeah
12:23:26 <hpc> :t M.fromListWith (:)
12:23:27 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
12:23:27 <lambdabot>     Expected type: a0 -> a0 -> a0
12:23:27 <lambdabot>       Actual type: a0 -> [a0] -> [a0]
12:23:53 <hpc> :t M.fromListWith
12:23:55 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
12:23:57 <mightybyte> dmj`: Put the MVar in your application state
12:24:10 <stepkut> I think I am thinking of Generalised (SQL-Like) List Comprehensions actually
12:24:15 <hpc> too bad it isn't (a -> b -> b) -> [(k, a)] -> Map k b
12:24:28 <hpc> er, b -> Map k b
12:24:33 <Cale> Yeah, also, thinking about it, this might produce the wrong association of (++)'s
12:26:22 <Cale> Yeah, it's a left fold :S
12:27:14 <hpc> is it foldl' or foldl?
12:27:31 <hpc> oh, dumb question
12:28:02 <hpc> Map is strict
12:28:05 <Cale> :t map (\(x,f) -> (x, f [])) . M.toList . M.fromListWith (.) . map (\(x,y) -> (x,(y:)))
12:28:06 <lambdabot> Ord t => [(t, a)] -> [(t, [a])]
12:28:25 <hpc> er, lazy
12:28:37 * hpc goes back to sleep
12:28:43 <Cale> It's some custom strict left fold
12:30:05 <Cale> :t map (second ($ [])) . M.toList . M.fromListWith (.) . map (second (:))
12:30:06 <lambdabot> Ord d => [(d, a)] -> [(d, [a])]
12:32:12 <erisco> :t M.fromListWith (.)
12:32:13 <lambdabot> Ord k => [(k, c -> c)] -> M.Map k (c -> c)
12:32:33 <erisco> :t M.fromListWith
12:32:34 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
12:34:09 <stepkut> and idea what I am doing wrong? [(a, b) | (a, b) <- [(1,2), (1,3)], then group by a], I get, parse error on input `]'
12:36:49 <erisco> stepkut, I have never seen the notation "then group by a" before
12:37:39 <stepkut> erisco, section 7.3.10 http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html
12:38:29 <thomasd> hi #haskell, I'd like to ask for some advice on library design & polymorphism
12:38:58 <erisco> stepkut, I presume you have TransformListComp enabled?
12:39:07 <stepkut> yup
12:39:33 <stepkut> i think i must use a using clause in this case
12:39:48 <erisco> I think you need the "using"
12:39:50 <erisco> yes as you say
12:41:41 <erisco> stepkut, seems that you can just use the prelude group function
12:42:21 <erisco> thomasd, sure what is your question?
12:42:29 <shachaf> I think the example in http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/syntax-extns.html#generalised-list-comprehensions gives the same error.
12:42:39 <thomasd> say I have a library function f :: Vector CDouble -> Vector CDouble, should I provide some interface so people can call it using Vectors of other types (e.g. Vector.Unboxed, or Vectors of regular Doubles) with implicit conversions, or is it better to just leave it to the user?
12:44:38 <erisco> thomasd, first you should consider what it is your function actually needs to know about the type
12:44:47 <erisco> ie what operations it needs
12:45:38 <erisco> vectors are monads, functors, applicative, foldable, traversable, alternative, and monoid, so you may only need one of those classes
12:45:49 <thomasd> well, my function (actually it's Vector CDouble -> Vector CDouble -> CDouble -> CDouble) is an interpolation routine
12:46:17 <thomasd> wrapping a C library
12:46:20 <jrmithdobbs> how do you build the yi cocoa frontend? cabal install yi --flags='cocoa' gives me a weird error about Setup.hs
12:46:25 <novodinia> > let sq = x * x in map (sq (+1)) [1..5]
12:46:27 <lambdabot>  Couldn't match expected type `(a1 -> a1) -> a0 -> b0'
12:46:27 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
12:46:40 <novodinia> > let sq = x * x in map (map sq (+1)) [1..5]
12:46:42 <lambdabot>  Couldn't match expected type `a0 -> b0' with actual type `[b1]'Couldn't matc...
12:46:42 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
12:47:05 <novodinia> Tips for debugging type mismatch errors?
12:47:08 <erisco> thomasd, look carefully at what operations your routine performs directly on the vector. what are they?
12:47:09 <thomasd> erisco, so it could work on any vector of floating point values
12:47:30 <novodinia> Besides using `:t` within ghci, is there anything else that can be done?
12:48:14 <thomasd> erisco, in the current implementation, I use Vector.Storable.unsafeWith to pass a pointer to the C routine, so it takes Vector.Storable.Vector CDouble
12:48:22 <yogurt_truck> has anyone gotten a Could not find module `Control.Applicative.Backwards` error when trying to `cabal install pandoc`?
12:48:26 <erisco> novodinia, I don't know, but :t is quite powerful
12:48:49 <thomasd> erisco, so in that sense I need a storable vector
12:48:53 <erisco> novodinia, you can give explicit types, giving what you expect them to be, and that can lead to more useful errors
12:49:30 <jrmithdobbs> oh, cabal being stupid and not grabbing the newest version
12:49:55 <jrmithdobbs> had to cabal install 'yi>=0.7.0' --flags=+cocoa
12:50:10 <thomasd> erisco, but it could be useful to provide some common conversion operators from/to most "list-like" ([Double],Vector Double, [Float], Vector Float perhaps) types
12:51:46 <novodinia> erisco: noted
12:51:58 <erisco> :t map sq (+1)
12:52:00 <lambdabot>     Not in scope: `sq'
12:52:00 <lambdabot>     Perhaps you meant one of these:
12:52:00 <lambdabot>       `seq' (imported from Prelude),
12:52:10 <erisco> oh it is recursive
12:52:14 <novodinia> and by explicit types you are referring to the setting within ghci which gives you more type information?
12:52:30 <erisco> I mean, for example
12:53:14 <jfischoff> :i Maybe
12:53:16 <erisco> let sq = (x :: Int) * (x :: Int) in (map (map sq (+!)) :: type I expect here) [1..5]
12:53:25 <jfischoff> :(
12:53:34 <erisco> type of thing. that way the compiler can tell you exactly where the types do not match what you expect
12:54:34 <erisco> thomasd, for that particular operation your hands are probably tied from usefully abstracting anything
12:54:43 <erisco> thomasd, presuming it is specially designed for FFI
12:54:46 <novodinia> > let abc@(a,b,c) = (10,20,30) in (abc, a, c)
12:54:48 <lambdabot>  ((10,20,30),10,30)
12:54:49 <novodinia> What's going on here?
12:55:00 <erisco> novodinia, what did you expect instead?
12:55:11 <novodinia> I don't know what the @ symbol is
12:55:14 <novodinia> s/is/represents
12:55:31 <erisco> it allows you to both pattern match and not pattern match
12:55:34 <novodinia> it was the last example in tryhaskell
12:55:39 <erisco> which is a confusing way of putting it...
12:55:58 <erisco> let abc = (10,20,30); (a,b,c) = (10,20,30) in (abc, a, c)
12:56:01 <danil> novodinia: a pattern like "name @ (some other pattern)" matches whenever the pattern on the right matches, and it also binds the whole thing that got matched to the name
12:56:02 <erisco> it is a shorter version of that
12:56:28 <thomasd> erisco, yes, it is tuned for FFI.  So you would advise against wrapper code to take, e.g. regular Double instead of CDouble?  What's the rationale behind that?
12:56:52 <novodinia> Do you have exercises I could play around with?
12:57:10 <novodinia> e.g.: Try using the at symbol to pattern match against _
12:57:22 <erisco> thomasd, I do not know what is ideal in your case nor have I any experience with FFI in Haskell
12:57:41 <jrmithdobbs> novodinia: var@_ is equiv to var I'm pretty sure
12:57:41 <dhrosa> what does this notation mean in the documentation for Data.List.inits?  inits _|_ = [] : _|_
12:57:45 <erisco> but you should be asking whether or not a user of your library will want to use these special types
12:57:51 <erisco> or if they want something more Haskell-friendly
12:57:51 <jrmithdobbs> novodinia: *in that context*
12:58:06 <hpc> dhrosa: _|_ is the symbol for bottom; you can remember it by thinking of the compiler giving you the finger
12:58:18 <hpc> basically, inits undefined = [] : undefined
12:58:22 <jrmithdobbs> heh, yi's lexers compile slow as fuck with split-objs
12:58:29 <dhrosa> ahh
12:58:30 <hpc> > head (inits undefined)
12:58:32 <lambdabot>  []
12:58:35 <hpc> > inits undefined
12:58:37 <lambdabot>  [[]*Exception: Prelude.undefined
12:58:58 <Cale> _|_ is a value representing nontermination
12:59:04 <thomasd> erisco, thanks.  Guess I should just think harder :)
12:59:14 <hpc> or partiality
12:59:25 <hpc> or anything that's... not defined :P
12:59:28 <erisco> thomasd, I do not know if there are easy answers, but it may be better to let the user decide if they want to use Double over CDouble
12:59:36 <erisco> thomasd, seeing as they can always do the conversion themselves
12:59:37 <novodinia> Would _|_ be the cause of a stack overflow?
12:59:40 <noberkfast> :t _|_
12:59:41 <lambdabot> parse error on input `|'
12:59:53 <noberkfast> :t (_|_)
12:59:54 <lambdabot> parse error on input `|'
13:00:02 <noberkfast> lol it looks like butt..
13:00:03 <erisco> thomasd, if you do not expose the more raw interface, you bar users from gaining the best performance
13:00:49 <erisco> thomasd, as the same time you have to evaluate who (what kind of people) will be using the library and what they expect
13:00:54 <Cale> novodinia: Stack overflows are something separate, they may happen when an expression that would otherwise have a value fails to evaluate due to an arbitrary limit on the stack size.
13:00:59 <erisco> an easy experience? high performance?
13:01:33 <quchen> noberkfast: _|_ is called "bottom" (no joke), and it stands for a non-terminating computation (or one that throws an exception, or is generally misbehaved).
13:01:36 <Cale> _|_ is part of the semantics of Haskell, it's considered a value itself
13:01:56 <Cale> Every Haskell type is a directed-complete partial ordering
13:02:03 <noberkfast> why doesnt it have a type
13:02:07 <erisco> thomasd, these are the hard questions of trade off. Look at dynamic scripting languages for "easy" and to C++ for "high performance", and that roughly sets up both ends of the spectrum
13:02:15 <Cale> Where _|_ is the bottom element of that order
13:02:16 <hpc> it has a type
13:02:20 <hpc> :t undefined
13:02:21 <lambdabot> a
13:02:32 <quchen> noberkfast: It's a conceptual thing, not strictly present in Haskell syntax. "let x = x in x" is _|_, for example.
13:02:47 <Cale> and roughly speaking, u <= v whenever some occurrences of _|_ in u can be substituted for other values to obtain v
13:02:47 <quchen> Or `error "foo"`. Or `undefined`.
13:03:10 <noberkfast> :i a
13:03:17 <Cale> So, if you consider the type [Bool] for instance
13:03:28 <noberkfast> :t undefined
13:03:30 <lambdabot> a
13:03:32 <triliyn> noberkfast: "a" is a type variable that can be any type
13:03:33 <danil> noberkfast: the _|_ notation is trying to look like the math notation, which is an upside-down T; but in actual code we spell it "undefined"
13:03:37 <Cale> _|_ is at the bottom of the partial order, and then above it are [] and _|_ : _|_
13:03:57 <noberkfast> ohh..
13:04:06 <triliyn> An expression like "let x = x in x" can have any type
13:04:17 <Cale> and then lying above _|_ : _|_ are (True : _|_),  (False : _|_),  (_|_ : []), and (_|_ : (_|_ : _|_))
13:04:17 <triliyn> Because of the way type inference works
13:05:44 <Cale> The directed-complete nature of this partial order comes in when discussing infinite values, like the infinite list  x = True : x
13:06:02 <Cale> There is an infinite ascending chain of values in the ordering:
13:06:30 <Cale> _|_, _|_ : _|_, True : _|_, True : (_|_ : _|_), True : (True : _|_), ...
13:06:44 <aleksejs_> one guy asked me if haskell is good for embedded solutions. What are your thoughts?
13:06:45 <hpc> and the infinite list x is at the top
13:06:57 <Cale> and that chain has a limit, yes
13:07:00 <Cale> which is x
13:07:21 <hpc> it can also be interpreted as the fixed point of (True :)
13:07:29 <thomasd> erisco, thanks.  I was wondering if there would be a way to have both the raw interface and a nice interface, and handle that transparently (in C++ I would do that using template specialization or something)
13:07:31 <hpc> or the fixed point of "take a list and make it 'bigger'"
13:07:45 <erisco> aleksejs_, interesting question... I presume memory is limited in those environments
13:07:46 <dhrosa> does IORef work fine w ith infinite data structures? like, will writeIORef ref [0..] be fine as long as I don't actually try to evaluate the entire list?
13:08:16 <hpc> @hoogle newIORef
13:08:17 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
13:08:21 <quchen> dhrosa: Yes, IORefs are fully polymorphic in their contents. You can even store errors and other nasty things in it.
13:08:24 <Cale> aleksejs_: Depends on your definition of embedded. It can be very good as a metalanguage in which to write special purpose compilers for smaller embedded systems. If "embedded" includes, say, what will run on an iPhone, then sure, you could use Haskell directlu.
13:08:26 <Cale> y&
13:08:33 <triliyn> aleksejs_: I don't know anything about embedded things myself, but I've heard nice things about http://hackage.haskell.org/package/atom
13:08:43 <hpc> quchen: not polymorphic, lazy
13:08:43 <thomasd> erisco, e.g. accept Vector Double and Vector CDouble, copying Double's to CDouble's if necessary
13:08:56 <hpc> they keep their contents in thunk form
13:09:00 <quchen> hpc: Woops, right. Although they're also polymorphic ;-)
13:09:05 <hpc> yes, that too ;)
13:09:05 <triliyn> (From what I can gather, this is one of the metalanguages that Cale mentioned)
13:09:07 <bitemyapp> Cale: the traditional understanding of "embedded" has meant extremely resource constrained computers where things like heap fragmentation or GC pause are unacceptable.
13:09:10 <Cale> Yeah, atom was going to be my suggestion to look at for smaller embedded systems
13:09:13 <deni> can anyone recommend a good/simple http libray? there seem to be plenty of them so I'm not sure where to start
13:09:16 <erisco> thomasd, that is easily done by a function of type Double -> CDouble
13:09:24 <thomasd> but that is probably outside of the scope of irc :) I'll try to find something, and otherwise maybe make it a Stackoverflow question or so
13:09:28 <Cale> bitemyapp: I've seen people mean a lot of things by it
13:09:31 <hpc> deni: i think http-conduit is the current favorite?
13:09:38 <aleksejs_> Cale, it includes code that would run on controllers like arm
13:09:40 <danil> hpc: the fact that it's fully polymorphic limits the degree to which it could be strict even if it tried -- the most it could do is `seq` the top layer of whatever you gave it
13:09:49 <hpc> yeah
13:09:52 <bitemyapp> Cale: it's definitely an overloaded term.
13:09:56 <deni> hpc: did you hear anything about http-streams?
13:10:13 <Cale> aleksejs_: hehe, but with how much memory? GHC *can* compile to ARM, but you'll typically need a faster ARM processor and a fairly serious amount of RAM
13:10:14 <hpc> i don't keep very good track of new packages
13:10:27 <thomasd> erisco, I know,   But I wonder if it would be possible to have one function "Real a => Vector a..." , that handles conversion implicitly, and only when needed
13:10:33 <Cale> aleksejs_: However, the other option is to take the approach that atom does.
13:11:09 <deni> hpc: i don't want to reinvent the wheel if someone has already made a good http lib. personally http-conduit seems huge....like humonguos
13:11:20 <Cale> There's a talk about Atom's usage here: http://cufp.galois.com/2008/schedule.html
13:11:25 <Cale> "Controlling Hybrid Vehicles with Haskell"
13:11:54 * hackagebot dominion 0.1.0.1 - A simulator for the board game Dominion.  http://hackage.haskell.org/package/dominion-0.1.0.1 (AdityaBhargava)
13:11:56 * hackagebot curves 1.0.0 - Library for drawing curve based images.  http://hackage.haskell.org/package/curves-1.0.0 (UlfNorell)
13:12:14 <erisco> thomasd, you should first consider writing the conversion functions
13:12:38 <hpc> deni: try the example at the top of http://hackage.haskell.org/package/http-conduit-2.0.0.3/docs/Network-HTTP-Conduit.html
13:12:54 <hpc> *examples
13:13:19 <hpc> http is fairly complicated and some of http-conduit is just the ability to give options for all of it
13:13:38 <hpc> (the rest is probably just things being exposed for fiddly api purposes)
13:14:12 <hpc> oh no, that's the only module
13:14:27 <hpc> yeah, it's all just from http being a huge pain
13:14:41 <erisco> thomasd, I am not sure why Data.Vector.Storable.Vector does not have a Functor instance, but that is the typical way to do such conversion
13:14:53 <erisco> thomasd, if you just want to go from Vector Double to Vector CDouble
13:14:57 <hpc> but for most purposes you can adapt the examples and edge cases will just deal with themselves for you
13:15:28 <quchen> erisco: Functor has to work on all types, not just instances of Storable. For the same reason Set isn't a Monad, for example.
13:15:34 <erisco> thomasd, then you layer these conversions on top of your functions which work with CDouble, and now you've constructed a new function without rewriting anything
13:15:41 <erisco> quchen, thomasd ah good point
13:16:08 <erisco> so you cannot use Functor but you can still write a fmap-like function
13:16:34 <quchen> mapStorable :: (Storable a, Storable b) => (a -> b) -> Vector a -> Vector b
13:17:10 <erisco> exactly
13:17:17 <c_wraith> This is a big part of the motivating case for lenses
13:17:25 <c_wraith> Lenses are just fine working on restricted types
13:17:59 <shachaf> i,i data V a = forall x. Storable x => V (Vector x) (x -> a)
13:18:12 <shachaf> (That's useless for the intended purpose, of course.)
13:18:13 <thomasd> quchen, erisco: thanks, useful conversation
13:18:37 <deni> hpc: how come http is such a pain? sadly i don't write any piece of code that doesn't have http as a core part :D
13:18:41 <shachaf> (But you can write lift :: Storable a => Vector a -> V a; lower :: Storable a => V a -> Vector a; instance Functor V.)
13:18:42 <erisco> what I am trying to say thomasd is do not jump to type classing immediately
13:22:57 <hpc> deni: some sites have infinite redirects, you have to deal with the whole get/post distinction, cookies, maybe you want to try visiting test.host.com with the hostname forced to foo.host.com
13:23:04 <hpc> (say, a devel server or something)
13:23:11 <thomasd> erisco, point taken.  I'll write conversion functions first, see what it's like working with them, and then think about wrapping them if necessary
13:26:01 <hpc> also the obvious stuff like timeout, and neat features like if your connection craps out being able to restart from the middle
13:26:20 <deni> hpc: does haskell as a language make it harder to deal with this stuff or are you talking in general?
13:26:25 <hpc> in general
13:26:31 <deni> ah ok
13:26:50 <hpc> i find that haskell makes it easier to deal with, but library writers have a bad habit of making you actually have to think about them
13:27:21 <c_wraith> http is very leaky
13:27:22 <hpc> even when you can just as easily say "this won't ever happen" and there's an obvious way to fall back
13:27:56 <hpc> like say, having to enter a Map String String of cookies even though it's obviously going to be fromList [] 90% of the time
13:28:06 <hpc> (http-conduit doesn't do this, but it could have)
13:32:37 <augur_> Cale: maybe we should put ##category-theory in the topic, and start enforcing some kind of topic segmentation?
13:33:06 <Cale> augur_: why?
13:33:44 <Cale> Obviously, people should move there if they're talking about pure category theory, and it's disrupting other conversation.
13:33:58 <jrmithdobbs> what does this mean?
13:33:59 <jrmithdobbs> http://lpaste.net/98913
13:34:32 <Cale> jrmithdobbs: interesting
13:34:37 <augur_> Cale: fair enough. there's a thread on twitter about creating a subchannel for category theory
13:34:50 <Cale> augur_: Ah, I don't use twitter
13:35:00 <jrmithdobbs> Cale: ya i'm just trying to build the cocoa ui for yi to try it out :(
13:35:03 <Cale> But there is a category theory channel, if people want to use it :)
13:35:08 <hpc> in any event, the applications of CT to haskell are on topic here
13:35:16 <hpc> arguably moreso here than there
13:36:20 <augur_> hpc: we do often talk about pure CT here
13:36:41 <danil> So I'm working with a bunch of types that are completely analogous to normal types with * replaced by (k -> *) -- that is, the types are all indexed by an extra parameter.  There areclasses like "class IFunctor f where ifmap :: (forall i. a i -> b i) -> f a j -> f b j".  Is there a name (or better yet, a library) for this construction?
13:36:42 <Cale> augur_: btw, you wanted to see a practical application for higher inductive types, I found this nice presentation the other day...
13:37:02 <augur_> Cale: ok
13:37:04 <Cale> http://dlicata.web.wesleyan.edu/pubs/l13git/git.pdf
13:37:22 <hpc> danil: they are indexed things
13:37:27 <hpc> indexed functor, indexed monad, etc
13:37:28 <Cale> Patches as paths :)
13:37:54 <danil> hpc: that's what I would've called them, but those are already a thing and they're something else as far as I can tell
13:38:19 <mgsloan> jrmithdobbs: GHC 7.6 changed some FFI stuff - namely that now constructors need to be visible.  Not sure if that's causing those errors, but it might be related
13:38:23 <intrados> Does anyone know why static contracts seem to have languished? https://github.com/cpa/haskellcontracts and https://github.com/danr/contracts
13:38:35 <hpc> oh, you mean all of the * are expanded
13:38:39 <mgsloan> jrmithdobbs: See this thread - https://groups.google.com/forum/#!msg/haskell-cafe/6xfRR4TYIeA/GNlS_rqAdncJ
13:38:53 <intrados> And what are their relative merits compared to liquidhaskell?
13:39:01 * timthelion feels that many #haskellers search real world problems to apply their category theory to rather than looking to category theory to solve their real world problems.
13:39:33 <hpc> timthelion: some people just have really interesting problems, but yeah i agree ;)
13:40:12 <augur_> Cale: oh, i saw that. didnt read it. dont know enough about darcs/etc.
13:40:27 <Cale> timthelion: This is usually the more effective way to go about things when you find a tool, if you only care about being productive -- solve all the problems which are easily solvable with it, then figure out how to deal with whatever's left.
13:40:47 <Cale> augur_: ah, well, it doesn't use a fully realistic model of darcs or whatever
13:41:19 <augur_> still. i dont know anything about darcs at all
13:41:29 <Cale> augur_: it's a revision control system
13:41:38 <augur_> yes i know :p
13:41:48 <timthelion> Cale: that's one way of looking at it.
13:43:01 <Cale> You have a repository which consists of a set of patches which can be applied in order to reconstruct the current state of a bunch of files. Some patches affect different parts of the structure and therefore can commute with each other.
13:43:14 <Cale> and every patch has an inverse
13:43:29 <platz> "The problem with git’s merging is that it doesn’t satisfy the “merge associativity law” which states that merging change A into a branch followed by merging change B into the branch gives the same results as merging both changes in together in one merge."  http://r6.ca/blog/20110416T204742Z.html
13:43:33 <Cale> and any two patches can be composed
13:45:04 <danil> hpc: Yeah, they're functors that take indexed types (a i) to indexed types (f a i) and index-preserving functions to index-preserving functions.  It looks like in the category-extras version it's the functor (or monad) itself that bears the indices.
13:45:09 <noberkfast> http://lpaste.net/98915 I made the question easy to understand now..
13:45:16 <noberkfast> in the above code partdiff
13:45:30 <noberkfast> in the above code partdiff' works but partdiff doesnt..
13:45:53 <noberkfast> and the below error shows up when i have partdiff..
13:46:17 <noberkfast> i want a function that takes r::[(a, a)] as an argument..
13:46:27 <noberkfast> along with x and y
13:47:42 <Cale> augur_: In any case, the fact that patches form a free group with some additional laws about when they can be commuted with each other, they're easily modeled by giving a higher inductive type with a single basepoint, and then paths from that basepoint to itself for each possible patch, and then some paths-between-paths expressing the case when patches can be commuted with one another.
13:48:06 <Cale> er, I should just say a presented group rather
13:48:15 <Cale> i.e. a free group modulo some relations about commutativity
13:48:45 <augur_> Cale: sure
13:49:17 <Cale> and that greatly reduces the complexity of representing them
13:49:29 <Cale> (and operating on them)
13:49:34 <tippenein> anyone see a problem with my FromRow instance? http://lpaste.net/98916
13:50:06 <tippenein> says fromRow is not a (visible) instance, but I don't believe it
13:50:10 <Cale> Well, it shifts that complexity into the implementation of HITs and identity types and the libraries for working with those
13:50:15 <augur_> Cale: modulo all the horrible transports you have to write :)
13:50:23 <augur_> but in those cases you undoubtedly want the transports around
13:50:37 <Cale> The transports are all things you were going to have to write and wanted to be explicit about anyway, yeah
13:50:42 <augur_> since they're not merely coding up equivalence, but they're coding up something deeper
13:51:10 <augur_> arguably here they code up inequivalence
13:51:18 <supki> tippenein: you probably need to import something
13:51:24 <supki> tippenein: what package are you using?
13:51:25 <Cale> Heh, well, they're "proof relevant equivalence"
13:51:39 <augur_> Cale: theyre not really equivalences tho
13:51:47 <augur_> different versions in a repo arent "equivalent" in any normal sense
13:52:01 <augur_> the whole point of the patches is that they represent why/how two things are different
13:52:04 <Cale> Well, the versions are longer and shorter paths, which may or may not be equivalent
13:52:04 <tippenein> I edited it to show the packages I importedhttp://lpaste.net/98916
13:52:19 <Cale> But yeah, that first level is kind of artificial
13:52:43 <Cale> You have this basepoint and all the ways it's equal to itself are all the possible repositories :)
13:52:44 <supki> tippenein: ok, so  import Database.PostgreSQL.Simple.FromRow
13:53:02 <augur_> Cale: yeah, here is where i think the word "equal" is really confusing
13:53:09 <bitemyapp> are there any uses for type synonyms beyond lending some sanity to things that would otherwise have an API of all Int or String?
13:53:21 <tippenein> supki: that worked. Why does it require that import?
13:53:28 <Cale> It's confusing for maybe the first week or two, and then you wonder what the big deal was :)
13:53:28 <quchen> type Flip f a b = f b a
13:53:43 <supki> tippenein: top level module in postgresql-simple does not reexport everything
13:53:46 <augur_> Cale: i bet you this notion would permanently confuse people
13:53:49 <bitemyapp> quchen: nifty. :)
13:53:57 <tippenein> gotcha, thanks supki
13:54:22 <supki> tippenein: it only reexports class name (so you can write type signatures, I guess), but not the interface
13:54:27 <bitemyapp> augur_: I've run into people that genuinely believe that memloc equality should be the default "understanding" of equality.
13:54:42 <platz> does haskell have a popular probabilistic modeling library?  F# has Infer.NET, Scala has factorie,
13:55:18 <bitemyapp> platz: not a bad idea! http://www.haskell.org/haskellwiki/Probabilistic_Functional_Programming
13:55:38 <bitemyapp> platz: http://web.engr.oregonstate.edu/~erwig/pfp/
13:56:04 <platz> bitemyapp: pretty nice, thanks!
13:56:57 <bitemyapp> platz: well don't thank me yet, I'd like to hear if there's anything there that actually solves your problem or not.
13:56:57 * hackagebot dominion 0.1.0.2 - A simulator for the board game Dominion.  http://hackage.haskell.org/package/dominion-0.1.0.2 (AdityaBhargava)
13:57:02 <bitemyapp> platz: it's a subject of interest to me.
13:58:13 <platz> bitemyapp: just curious about the subject.  I took PGM from coursera a while ago and we built a bunch of stuff by hand, but I realized there were nicer libraries out there
13:59:00 <platz> I have yet to find a way to apply it
13:59:13 <bitemyapp> platz: in Haskell you often have LibraryFactories rather than a specific library.
13:59:26 <bitemyapp> platz: so I guess what I was wondering is whether the building material you saw in my links was interesting or useful to you or not.
13:59:49 <bitemyapp> platz: I've been thinking about tinkering with carter's work or one of the vector math thingies for this.
14:03:52 <platz> it looks like it provides distributions; i guess you'd have to build ontop of that?  I don't see mention of factors, conditional  probability distributions , inference, belief propagation,
14:04:24 <bitemyapp> platz: yeah. precisely.
14:05:14 <platz> those are some of the things you get in those other libraries.  you just set up the params and then call something like "infer"
14:06:58 * hackagebot hierarchical-exceptions 1.0.1 - Template Haskell functions to easily create exception  hierarchies  http://hackage.haskell.org/package/hierarchical-exceptions-1.0.1 (BenjaminBarenblat)
14:07:31 <platz> http://research.microsoft.com/en-us/um/cambridge/projects/infernet/docs/Two%20coins%20tutorial.aspx
14:08:32 <platz> pfp actually looks like it can do that already
14:08:51 <bitemyapp> platz: ouch @ mutation in the tutorial
14:09:00 <jrmithdobbs> well that haskell-cafe thread got me a different error where it's not a problem with not remembering to import definitions but it's trying to use one that isn't exported :(
14:09:07 <jrmithdobbs> re: yi and cocoa
14:09:18 <jml> I've just installed haskell platform on my mac. I'm trying to install packages with cabal install, but I get <command line>: cannot satisfy -package-id errors
14:09:58 <jml> e.g. <command line>: cannot satisfy -package-id mtl-2.1.2-94c72af955e94b8d7b2f359dadd0cb62
14:14:27 <jrmithdobbs> isn't yi supposed to have a structured-ish mode that auto formats :: and = to line up?
14:14:37 <platz> this is a start http://www.alpheccar.org/content/98.html
14:23:41 <deni> hpc: so no http library for humans then? :D
14:24:26 <bitemyapp> deni: http://hackage.haskell.org/package/http-conduit-2.0.0.3/docs/Network-HTTP-Conduit.html
14:24:38 <bitemyapp> simpleHttp "http://www.haskell.org/" >>= L.putStr             seems reasonable to me.
14:48:37 <merijn> deni, bitemyapp: That one works really well with html-conduit too, which was a pretty easy library for parsing HTML when I tried it
14:50:00 <[swift]> anyone know of any way to safeguard against blocking occurring inside an "unsafe" FFI call? (in a library in base, which I obviously can't change...)
14:51:16 <[swift]> timeout and the like don't work, but maybe there's some technique that might? (perhaps explicitly running a watchdog timer on a different OS thread?)
14:54:35 <deni> merijn: so http conduit is for parsing html as well? no wonder it's huge
14:55:02 <deni> bitemyapp: yeah i know that one. a simple get request is simple yes :)
14:57:33 <b0bbi10> hi
14:58:11 <bitemyapp> b0bbi10: hi
14:58:19 <b0bbi10> is 'Programming in Haskell' by Graham Hutton of any good? (for a beginner in Haskell with some knowledge in C and Java)? or should I find something else to look into?
14:58:39 <bitemyapp> b0bbi10: I personally didn't like PiH but I'm sure it has its defenders.
14:58:44 <shachaf> Yes, it is good.
14:58:57 <yayutf> b0bbi10: general advice on the channel seems to be 'learn you a haskell', but I fear I'm not familiar with Hutton's book
14:59:00 <bitemyapp> the notation in particular was annoying and slowed me down.
14:59:14 <bitemyapp> b0bbi10: I prefer a mix of Learn You a Haskell, Real World Haskell, and Haskell Fast & Hard
14:59:23 <shachaf> It's a bit old, so some of the things it says might need to be fiddled with a bit to make work (references to old libraries, old compilers, etc.)
14:59:32 <bitemyapp> b0bbi10: bouncing between LYAH and Haskell Fast & Hard primarily.
14:59:44 <bitemyapp> shachaf: I had an insanely terrible time with PiH.
14:59:59 <bitemyapp> it's one of my biggest book purchase regrets.
15:00:04 <b0bbi10> bitemyapp: yeah, LYAH and Real World Haskell are also on my list ;)
15:00:17 <bitemyapp> Haskell Fast and Hard is my favorite for introducing Haskell in a compact manner at the moment.
15:00:25 <shachaf> But it's a very good introduction to the language itself and to ways of thinking about it.
15:00:25 <b0bbi10> ok, thanks guys, I'll dive into LYAH first then
15:00:30 <sm> b0bbi10: yes PIH is good
15:00:55 <bounb> for what it's worth, ive just been through the first 3 chapters of RWH and i can't recommend it at all
15:01:08 <shachaf> I've only read some of LYAH, but I'd certainly recommend PiH over it.
15:01:10 <shachaf> PiH is also very short. :-)
15:01:23 <yayutf> b0bbi10: *don't* start with RWH; it's got some good stuff in it, and I like it, but some sections aren't very good at all, and it pretty much always seems to lose total beginners
15:01:31 <yayutf> dip into it, but don't start it or try to use it cover-to-cover
15:01:36 <geekosaur> rwh is a bit odd. starts off slow and then dumps you into advanced stuff with no warning
15:01:42 <yayutf> *don't start with it, rather
15:01:57 <geekosaur> it's a very bad beginner reference, but the later chapters are good for intermediate Haskellers
15:02:04 <b0bbi10> yayutf: that was the reason I asked in the first place. PiH or LYAH first, then carrying on with RWH
15:02:25 <yayutf> b0bbi10: RWH is the only one I have much experience with of the three, unfortunately :-)
15:02:37 <b0bbi10> still not clear which way to go after some other users recommend PiH^^
15:02:45 <yayutf> so I can very enthusiastically tell you several ways not to use it, but can't help with your other quandry
15:03:04 <yayutf> b0bbi10: pick up both, see what you like, and bounce between them if it makes you happy?
15:03:10 <yayutf> books aren't one size fits all, and we don't know you
15:03:21 <sm> b0bbi10: browse them all online, you'll know which one suits you
15:03:34 <b0bbi10> will do
15:04:03 <sm> or check them all out of your local library :)
15:04:12 <shachaf> You can't read PiH online. :-(
15:04:31 <sm> you can browse it eg at books.google.com or amazon
15:04:53 <bitemyapp> b0bbi10: LYAH is okay, but I got bored with it (moved too slow). If the same happens to you, check out Haskell Fast & Hard.
15:05:07 <merijn> deni: No, http-conduit is just for HTTP, but there is a html-conduit which can be neatly combined with it
15:05:21 <deni> merijn: ah. good to know. tnx
15:05:32 <merijn> deni: There's a billion different X-conduits that can all be easily combined
15:05:46 <deni> merijn: is it just me or is documentation for http-conduit awful, or non existent?
15:05:49 <b0bbi10> and if I might say that: my first impression is that you haskellers? are quite friendly and helpful without. though I asked a 'beginners' question which you certainly have come acrossed very often you provided me really comprehensive answers :) (in comparison to other programming channels here on freenode...) thanks for that :)
15:06:19 <merijn> deni: A little bit of both
15:06:53 <merijn> deni: It is a bit under documented, but on the other hand I could figure out most of the things from the types
15:06:54 <b0bbi10> bitemyapp: will put that on my list
15:07:00 <shachaf> http://books.google.com/books?id=olp7lAtpRX0C&pg=PA166 -- these are the symbols everyone complains about?
15:07:04 <merijn> deni: You may want to read a generic "conduit" tutorial
15:07:10 <sm> http://www.yesodweb.com/book/http-conduit is more docs than most such libs get I'd have thought
15:07:17 <shachaf> I don't care very much whether a book uses → or ->.
15:07:41 <deni> sm: tnx for the link, had that one open
15:08:17 <deni> merijn: but yeah it's under documented to say the least. i mean, a little API doc and a blog post aren't really what's called documentation in my book
15:09:13 <deni> the best http client lib i've used for far was in python: http://docs.python-requests.org/en/latest/
15:09:35 <deni> great docs as well....forgot that most other languages don't have the requests lib
15:09:38 <merijn> deni: As for the size, I'm not sure http-conduit is only client side, it might also do server-side HTTP parsing?
15:10:29 <deni> merijn: all i know is when it started downloading and compiling all those packages.... and there was no end...i mean wow.
15:10:58 <merijn> deni: Might wanna also take a look at https://www.fpcomplete.com/user/snoyberg/library-documentation/conduit-overview
15:10:59 <deni> i don't mean to be all that negative, i'm just learning this stuff as i go along, i really love haskell so far.
15:11:17 <carter> platz: bitemyapp  bayesian modelling is a subtle critter
15:11:30 <carter> platz: i do have doing something like infer.net in my roadmap
15:11:39 <carter> unless someone does a better job before i do
15:12:02 <sm> deni: that doesn't really mean http-conduit is large. Any real-world lib tends to pull in a lot of small usually well-factored packages
15:12:08 <bitemyapp> carter: I'll leave it to your capable hands then :)
15:12:18 <carter> bitemyapp: you mean you like how i'm a bit ocd ;)
15:12:24 <merijn> deni: It's fair to say that many libraries could use more documentation in the form of more complex examples. At the same time, as you get more experienced you'll get better at understanding libraries just by the types (not that this is an excuse for poor documentation)
15:12:56 <merijn> deni: The documentation situation used to be a lots worse in the past, so it's improving
15:13:15 <deni> merijn: yeah i'm finding haskell types to be very good documentation, still an example here and there would be nice
15:13:18 <merijn> @quote edwardk users
15:13:18 <lambdabot> edwardk says: normally i don't bother with little things like "documentation", "benchmarks" and "tests", but I recently discovered that when I do, I get these curious things called "users".
15:13:39 <deni> merijn: glad to hear it's improving. hopefully i can help soon
15:13:39 <quchen> edwardk also likes to take doc patches.
15:13:52 <quchen> So his tactic seems to be to get as much doc as necessary so the thing runs itself ;-)
15:13:57 <edwardk> patches are good
15:14:11 <platz> carter:  PGM was pretty hard.  I'd have to take the class over again to get a better understanding
15:14:22 <quchen> Oh hello there edwardk, forget what I said haha
15:14:28 <merijn> quchen: edwardk sees your doc patch and gives you commit rights to trick you into maintaing his stuff :p
15:14:30 <carter> platz: math is hard period :)
15:14:33 <bitemyapp> carter: hey, if you're willing to really dive into the problem and really do a proper job of it, then I'd rather you than me because I'm a slacker :)
15:14:38 <carter> well
15:14:44 <cschneid> edwardk / quchen: my only contribution to haskell so far has been a few doc & test patches to edwardk's stuff.
15:14:49 <carter> if someone does a strawman first, i'll be able to do better soon
15:14:58 <edwardk> i figure if i just keep spinning up projects and am visibly too busy to write all the docs myself, then others will step up to the plate and i won't have to spend months and months writing docs
15:15:15 <edwardk> so far it has been working quite well ;)
15:15:21 <merijn> edwardk: Smart, I should follow your lead :p
15:15:42 <merijn> Now I just need to learn to not sleep so I can be equally productive
15:15:53 <edwardk> A couple of months of me invested in writing lens docs have paid back handsomely in terms of adoption and more coauthors.
15:16:09 <yayutf> edwardk: awesome, url?
15:16:10 <quchen> inb4 giggling abut co-authors
15:16:19 <merijn> quchen: :p
15:16:22 <merijn> @quote co-workers
15:16:22 <lambdabot> No quotes match. Abort, Retry, Panic?
15:16:25 <merijn> @quote coworkers
15:16:26 <lambdabot> No quotes match. Are you on drugs?
15:16:28 <merijn> awww
15:16:31 <yayutf> i've felt like i want to understand lenses better in a vague way for years
15:16:32 <edwardk> yayutf: mostly the hackage docs for lens and lens.github.io and the wiki on github
15:16:38 <merijn> My coworkers quote got removed? :(
15:16:39 <yayutf> edwardk: thank you :)
15:16:55 <edwardk> quchen: hah!
15:17:00 <orion> Hey there. I am new to functional programming, and I compiled a 1 line application: "main = print (max 1 2)". It's > 1 MB. Is there any way I can trim that down a bit?
15:17:03 <shachaf> edwardk: Hmm, I think I only started caring about lens after seeing your talk.
15:17:04 <merijn> "coworkers == producer of work tasks?"
15:17:35 <edwardk> orion: ghc statically links in the whole RTS, which makes executables.. rather large
15:17:35 <platz> merijn: python also has serveral orders of magnitude more contributors to help with docs
15:17:49 <merijn> orion: See: https://stackoverflow.com/questions/6115459/small-haskell-program-compiled-with-ghc-into-huge-binary
15:17:53 <edwardk> orion: otoh, they don't grow much from there relatively ;)
15:17:57 <shachaf> Hard to say whether documentation had anything to do with it.
15:18:16 <shachaf> Well, you have to watch out with "main = print (max (max 1 2) (max 3 4))" being > 4 MB.
15:18:21 <jrmithdobbs> am I missing something? how do i change to the auto indent mode in yi?
15:18:28 <quchen> shachaf: The talk most certainly was documentation :-)
15:18:31 <edwardk> that is a good link for this issue
15:18:35 <jrmithdobbs> docs for this kind of suck
15:18:36 <kristof> Can anyone think of some uses for type-indexed open unions?
15:18:37 <merijn> orion: That also includes explanations on how to shrink the size (but you may not necessarily want to)
15:19:05 <orion> I See.
15:19:18 <orion> So, does the code actuall get compiled, or is it interpreted in a VM?
15:19:23 <carter> platz: that said, some initial straw man hackery to get a baseline is always good
15:19:24 <geekosaur> compiled
15:19:25 <merijn> orion: Maybe :)
15:19:29 <jfischof1> kristof: Papers? I kid ;)
15:19:33 <kristof> I can't really think of any examples where I would want to access an arbitrary collection of things based simply by its type
15:19:42 <geekosaur> well, if you use ghci or runhaskell it is interpreted. ghc is a compiler
15:19:46 <merijn> orion: If you ask "is haskell interpreted" the answer is "it depends on the implementation"
15:19:54 <merijn> orion: GHC normally compiles to native machine code
15:19:55 <geekosaur> but the runtime is fairly large
15:20:15 <geekosaur> and the default is static linking
15:20:25 <geekosaur> (currently)
15:20:29 <kristof> jfischof1: Ha, but really, there's ONE very cool use in Oleg's paper on extensible effects that makes use of a type-indexed open union to effectively replace monad transformers with something much more flexible
15:20:38 <orion> If GHC compiles to native machine code, why is a runtime necessary?
15:20:53 <orion> What is in that runtime?
15:20:54 <merijn> orion: Same reason C and C++ need a runtime?
15:20:55 <kristof> jfischof1: And it was ONLY possible with a type-indexed open union, so it got me thinking: where else could this be useful?
15:20:59 <jle`> orion: things like garbage collection, etc.
15:21:09 <merijn> orion: The garbage collector, lightweight threading, etc.
15:21:39 <kristof> I saw a very good diagram of the parts of GHC's runtime. I'll share it if I can find it again
15:21:52 <merijn> orion: The only difference is that the C runtime is several order of magnitude smaller than that of Haskell. On the other hand, in C you don't get threading and garbage collection built-in :)
15:22:00 <orion> right
15:22:23 <kristof> orion: https://ghc.haskell.org/trac/ghc/attachment/wiki/Commentary/Rts/rts-overview.png this will do for now
15:22:32 <jle`> orion: try compiling main = (print (max 1 2)) >> (print (max 2 3))
15:22:35 <merijn> orion: In C it just does things like set up the environment and argc/argv and call the main functions
15:22:37 <skypers> do you know whether Carmack’s Wolfenstein Haskell sources are available somewhere?
15:22:41 <jle`> (>> glues two IO objects together into one big one)
15:22:45 <jle`> and compaing the size
15:23:19 <orion> So just to reiterate, GHC does not transform my code in to an intermediate language.
15:23:33 <geekosaur> C is very simple and you trade off a small runtime for craptacular string support / need for large additional libraries etc.
15:23:39 <shachaf> It transforms your code to many intermediate languages.
15:23:46 <geekosaur> also manual pointer management
15:23:53 <shachaf> Sometimes it stops at some sort of byte code, which is then interpreted (e.g. with ghci).
15:24:13 <jle`> orion: if you are familiar with assembly
15:24:15 <FreeFull> It's a multi-stage process
15:24:15 <roboguy_> skypers: I was wondering the same thing
15:24:15 <shachaf> Sometimes it compiles all the way to, say, x86 code, which is then run directly.
15:24:19 <jle`> you can actually see the assembly that it compiles to
15:24:37 <merijn> orion: Well, it does transform it into multiple intermediate languages, but by default it in the end translates those to straight assembly and compiles that
15:24:38 <jle`> and see that much of what is written is directly translated into the low-level loops you would expect
15:24:44 <heatsink> kristof: Type-indexed open unions seem like the right way to allow new subtypes of a type to be created dynamically, like in dynamic class loading.
15:24:52 <roboguy_> skypers: he should definitely consider putting up them somewhere if he hasn't already
15:25:03 <merijn> orion: In some cases (like runhaskell/ghci) it will use a bytecode representation and run that
15:25:07 <skypers> roboguy_: definitely
15:25:11 <skypers> it’d be neat
15:25:27 <roboguy_> skypers: I wonder what the chances are that he would if I tweeted him about it... can't hurt
15:25:34 <kristof> heatsink: Everything you just said does not sound very haskelly :'(
15:25:44 <merijn> orion: If your question is "can I copy a haskell binary (assuming all the required libraries are present) to a new system and run it without installing haskell, like I can with C" then the answer is "yes"
15:26:02 <kristof> heatsink: Seriously speaking, though, I remember talking to someone about subtyping and he said that subtypes generally introduce problems related to behavior variance
15:26:12 <orion> ok
15:26:35 <yayutf> kristof: yeah, things like the liskov substitution principle can be harsh
15:26:40 <skypers> 00:22 < roboguy_> skypers: I wonder what the chances are that he would if I  tweeted him about it... can't hurt
15:26:45 <skypers> I’m gonna try it now
15:26:51 <kristof> yayutf: No idea what that is but I'm sure it's a big deal
15:26:59 <roboguy_> skypers: cool. let me know if you get a response
15:27:37 <jle`> orion: you can examine the assembly that is generated and see the low level loops that you'd expect; you can see an example of a simple-ish loop being compiled here http://neilmitchell.blogspot.com/2014/01/optimising-haskell-for-tight-inner-loop.html
15:27:59 <jle`> under "version  8"
15:28:09 <kristof> Hmmm, I don't think Idris has subtypes either.
15:28:11 <jle`> er, version 7
15:28:20 <kristof> heatsink: Thanks for piping in, though
15:28:21 <skypers> roboguy_: https://twitter.com/skypers_/status/425771008532824064
15:28:56 <heatsink> kristof: In practical terms, when you take advantage of subtyping, you cut back on the use of parametric polymorphism
15:28:58 <orion> Cool. Thank you for your help everyone.
15:28:59 <kristof> heatsink: I know Haskell is starting to include some hotloading capabilities, so if subtypes are ever introduced then type indexed open unions are going to be the bridge between those two concepts
15:29:21 <heatsink> because combining covariance and contravariance means that most functions end up invariant
15:29:32 <skypers> subtypes?
15:29:35 <skypers> what would it be?
15:29:39 <yayutf> kristof: http://en.wikipedia.org/wiki/Liskov_substitution_principle#A_typical_violation
15:29:41 <kristof> skypers: class inheritance in OO
15:29:49 <heatsink> I mean, most use cases have covariance and contravariance restrictions so that the result is invariance
15:29:51 <jrmithdobbs> does anyone actually use yi that can explain to me how the modes work?
15:29:52 <skypers> oh
15:29:55 <skypers> ok
15:29:56 <jrmithdobbs> eg, how do i change modes?
15:29:58 <skypers> that just sucks.
15:30:06 <roboguy_> heatsink: that sort of makes sense since anything that is a instance of both Contravariant and Functor doesn't do anything with it's argument in it's mapping operations
15:30:07 <skypers> we don’t need inheritance
15:30:11 <skypers> we have high order functions
15:30:15 <skypers> that’s quite enough
15:30:17 <shachaf> "does anyone actually use yi" -- I doubt it.
15:30:23 <skypers> I tried yi
15:30:29 <jrmithdobbs> I got it building (without cocoa) and the default vim2 keybindings are fine
15:30:30 <kristof> heatsink: Hmmm. I don't know what you mean by "cut back", though; in my head, it seems like you either have parameterized types or you don't
15:30:35 <skypers> I tried to open a 20MB plain-text file
15:30:37 <skypers> yi crashed.
15:30:38 <skypers> :D
15:30:44 <jrmithdobbs> but I can't figure out how to do anything useful with it ... it's like a vim with no functions
15:30:49 <sm> ay yi yi
15:30:57 <skypers> jrmithdobbs: keep using vim
15:31:07 <skypers> yi is a nice attempt but also a huge failure :)
15:31:33 <jrmithdobbs> skypers: ya i'm just trying to play with it and can't figure out how to switch modes even!
15:31:36 <roboguy_> it would be pretty hard to make a competitive programming-oriented text editor at this point
15:31:54 <bitemyapp> roboguy_: well. ibdknox of LightTable is doing an impressive job of it.
15:32:01 <heatsink> kristof: Maybe I should say that you generalize less, using more concrete types and fewer type variables
15:32:02 <jrmithdobbs> yi looks fairly competetive except for the most important part: the documentation
15:32:07 <kristof> heatsink: I see.
15:32:10 <bitemyapp> roboguy_: I'm very unlikely to abandon Emacs but I've been watching his work. It's damn good.
15:32:15 <cschneid> I feel like vim is hitting edges of what it can do (background processes mostly). I'd love vim rewrittem. VimImproved if you will
15:32:23 <roboguy_> bitemyapp: I've never heard of that. what's the editor called?
15:32:24 <jle`> vimim
15:32:31 <roboguy_> oh lighttable
15:32:37 <jle`> viim
15:32:55 <bitemyapp> roboguy_: ibdknox is a person.
15:33:05 <Earnestly> cschneid: vimproc
15:33:05 <kristof> yayutf: The example that someone gave me about this also had to do with mutability concerns (in my opinion), so I'm wondering: what are the classes of problems involving subtyping in the context of immutable state?
15:33:07 <roboguy_> bitemyapp: I'm an emacs guy myself, but I'm definitely open to different editors (especially since I don't use many of the fancy features of emacs. which I probably should at some point)
15:33:19 <skypers> vim rewritten?
15:33:22 <skypers> why?
15:33:43 <kristof> yayutf: Separating the different problems to analyze them distinctly might be fruitful. Or not, I dunno. :)
15:34:06 <jrmithdobbs> it's odd because yi actually seems noticably faster at syntax highlighting on haskell and ruby
15:34:30 <jrmithdobbs> but if I can't figure out how to use it that doesn't matter much
15:36:43 <platz> heatsink: interesting, I knew c# arrays were covariant, but I didn't know they were made that way because of *java* http://stackoverflow.com/a/3516637/176876
15:36:50 <jrmithdobbs> w/e i just wasted half my day looking at this, back to vim
15:39:43 <erisco> so... how does lighttable show the evaluation for, say, factorial?
15:41:31 <heatsink> platz: Java arrays have a covariant interface because it was felt that OO programmers expected it.  However, if you want to rule out run-time type errors, mutable arrays have to be invariant.
15:42:40 <hpc> heatsink: i still don't get what makes arrays different from other types in java in that respect
15:42:45 <triliyn> What does covariance mean in this context?
15:43:02 <hpc> that is, what makes an array of a generic type any different from a linked list of a generic type?
15:43:12 <triliyn> That a container-thingy's contents can be modified?
15:43:21 <heatsink> covariance has to do with subtyping
15:43:33 <triliyn> oh
15:43:41 <heatsink> If we write a < b to mean that a is a subtype of b,
15:43:41 <triliyn> So not at all related to covariant functors?
15:43:54 <heatsink> As far as I know, it's not related
15:43:58 <triliyn> okay
15:44:19 <heatsink> and if type constructor T is covariant in its parameter,
15:44:29 <heatsink> then a < b implies that T a < T b
15:44:39 <dleedev> hi, do pipes and conduits serve the exact same purpose?
15:44:59 <heatsink> For example, if Int < Float (every int is a float) then [Int] < [Float] (every list of ints is a list of floats)
15:45:14 <heatsink> So [] is covariant
15:45:22 <triliyn> ahhh, okay
15:45:27 <triliyn> That is interesting
15:46:00 <mm_freak> dleedev: pretty much, except that pipes might be more generic, at least in the way it's used
15:46:42 <Twey> dleedev: They're two approaches to the same problem
15:47:10 <hpc> the problem being "consume input over time to produce output over time"
15:47:15 <dleedev> what's the deciding factor?
15:47:21 <platz> I think they made arrays invariant in go
15:47:23 <dleedev> between pipes and conduit?
15:47:38 <Twey> dleedev: Conduit is a more monolithic approach, whereas Pipes is broken down into more orthogonal pieces
15:48:09 <Twey> Which usually leads to more elegant code, but Snoyman believes it would be better off monolithic
15:48:25 <L8D> How can I negate/reverse the succ and pred functions?
15:48:39 <skypers> jrmithdobbs: ahah
15:49:02 <heatsink> succ and pred are inverses except at the minimum and maximum values
15:49:03 <skypers> L8D: (-) . succ
15:49:03 <skypers> ?
15:49:13 <skypers> jrmithdobbs: ahah
15:49:18 <skypers> when I tried yi
15:49:25 <skypers> I tried something like :set nu
15:49:31 <skypers> it didn’t work out
15:49:34 <Twey> heatsink: The reason arrays are covariant is that otherwise you wouldn't get type-generic operations on arrays
15:49:35 <L8D> skypers: well...I'm trying to define an Num instance for (a -> a) -> a ->
15:49:36 <L8D> a
15:49:44 <L8D> (church encoding)
15:49:51 <heatsink> Twey, do you know if covariance of types is related to covariance of functors?
15:49:52 <skypers> I tried to open the 20MB+ document, it crashed -> sudo apt-get remove yi
15:50:04 <skypers> or ghc-pkg, don’t remember
15:50:09 <Twey> heatsink: If the array is invariant, then a function on Object[] can work *only* on Object[], and not on ‘arrays of any kind of object’, which is what you want it to be
15:50:18 <skypers> L8D: yes, then?
15:50:24 <Twey> Generics solve that problem in a better way, so you can make them invariant without losing genericity
15:50:31 <skypers> or
15:50:33 <skypers> oh*
15:50:36 <skypers> you need negate
15:50:39 <skypers> :i Num
15:50:43 <skypers> oops
15:50:46 <Twey> heatsink: Loosely, yes, it's the idea of a transformation preserving some kind of ordering
15:50:50 <L8D> skypers: I'm trying to reverse, not negate
15:50:58 <L8D> reverse succ == pred
15:50:58 <heatsink> okay
15:51:02 <L8D> reverse pred == succ
15:51:04 <Twey> I suspect they look the same in appropriate categories, but I don't know enough category theory to formulate them
15:51:15 <skypers> yeah, so you have it now?
15:51:19 <skypers> what’s the problem
15:51:20 <skypers> ?
15:51:48 <L8D> skypers: I'm needing something that works like reverse
15:51:56 <L8D> not the Data.List 'reverse' function
15:52:07 * hackagebot cookbook 2.1.2.0 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.1.2.0 (NatePisarski)
15:52:12 <skypers> you want a function that takes an Enum and revers succ and pred?
15:52:15 <skypers> reverse*
15:52:19 <L8D> but something that inverts the thing...
15:52:24 <Twey> heatsink: Oh, well, actually — I guess the array *is* a functor (in the categorical sense)
15:52:31 <L8D> skypers: okay, let me start over.
15:52:41 <skypers> ahah I’m all ears
15:52:45 <L8D> let's say we have a function: Int -> Int
15:53:06 <roboguy_> L8D: not all functions have inverses, so there isn't a general function that finds inverses
15:53:26 <L8D> roboguy_: I know
15:53:33 <roboguy_> L8D: in certain cases, you can define an isomorphism between things though
15:53:35 <heatsink> Twey, are you saying that Java was designed with covariant arrays to allow generic functions to be written when type parametricity isn't supported?
15:53:36 <L8D> I'm looking for best practicies on how to create one
15:53:50 <roboguy_> L8D: what about something like Iso from lens?
15:54:20 <Twey> heatsink: Java didn't have type-parametricity to start with: it was added later (by someone who's now a prominent Haskeller, if I remember correctly)
15:54:24 <L8D> roboguy_: I'm just trying to define a Num instance for (a -> a) -> a -> a
15:54:36 <heatsink> Yes, Philip Wadler worked on adding java generics
15:54:44 <Twey> Oh, not quite a Haskeller
15:54:55 <heatsink> and the JVM has never supported type parametricity
15:54:56 <skypers> (a -> a) -> a -> a?
15:55:01 <Twey> Right
15:55:06 <L8D> skypers: church encoding
15:55:11 <skypers> what is that?
15:55:17 <skypers> reverse -> a -> a ?
15:55:34 <L8D> https://en.wikipedia.org/wiki/Church_encoding
15:55:42 <Twey> So giving arrays a subtype was the *only* way to support type-generic programming on arrays
15:55:56 <heatsink> I see
15:56:37 <edwardk> L8D: i'd recommend newtyping it
15:56:44 <Twey> Of course, in retrospect everyone realizes they should have just had parametricity from the start, but hindsight is always 20/20 :þ
15:56:49 <L8D> edwardk: I did
15:57:02 <heatsink> Everyone except the designers of Go
15:57:02 <sipa> Twey: actually, it's +inf/20
15:57:05 <skypers> isn’t related to contravariance?
15:57:14 <Twey> sipa: Haha
15:57:14 <skypers> +it
15:57:17 <edwardk> newtype Church = Church { runChurch :: forall a. (a -> a) -> a -> a   }
15:57:40 <edwardk> ah k
15:57:41 <Twey> heatsink: Go's type system is… different
15:57:43 <L8D> edwardk: what
15:57:48 <L8D> is so special about that
15:58:02 <L8D> Why not type Church = Num a => (a -> a) -> a -> a
15:58:03 <skypers> L8D: if I understand well
15:58:24 <skypers> you just want a function that takes another function and reverses it?
15:58:32 <roboguy_> L8D: that doesn't compile
15:58:52 <roboguy_> I think
15:59:03 <skypers> plus, you can’t make that an instance of anything
15:59:27 <twiceler> So I wrote a dynamic programming algorithm using STUArray in the ST monad. I want it to be faster! Profiling tells me that it's spending a lot of time reading and writing
15:59:45 <twiceler> Does anyone have an idea for making it faster?
15:59:47 <edwardk> L8D: you can give instances to newtypes. the problem is the instance you want overlaps with other another possible, instance Num a => Num (b -> a)  which is used by many people. also it is very hard for the typechecker to figure out to fire for your instance, what happens when it figures out that you have zero, but since you didn't use the first argument it infers x -> a -> a   instead of (a -> a) -> a -> a.
16:00:03 <twiceler> (Other than doing it in C!)
16:00:19 <L8D> type Church a = Num a => (a -> a) -> a -> a
16:00:24 <edwardk> L8D: the instance you want is both brittle and overlaps other instances. hence the role of the newtype, which gives the typechecker a 'label' to grab onto, and structure to ensure that the functions have the right type.
16:00:35 <Twey> heatsink: They are, at least, making the same old mistakes in a brand new setting :þ
16:00:50 <skypers> good luck with your church
16:00:53 <skypers> I’ll pray
16:00:54 <skypers> ;)
16:00:55 <roboguy_> twiceler: are you using an unsafe operations?
16:01:00 <skypers> talk to you later
16:01:06 <edwardk> L8D: you don't want to put Num in the 'a' there. just instance Num Church where    with no constraints on 'a' needed.
16:01:07 <heatsink> haha Twey
16:01:21 <Twey> heatsink: But Stack Overflow seems to suggest that only immutable collections are covariant in Go, which is fine
16:01:28 <twiceler> roboguy_: I looked but didn't see any. like reading/writing without bounds checking?
16:01:31 <L8D> hm...
16:01:40 <Twey> heatsink: http://stackoverflow.com/questions/6684493/why-are-arrays-invariant-but-lists-covariant
16:01:57 <edwardk> instance Num Church where Church f + Church g = Church $ \s z -> f s (g s z); ...
16:02:26 <edwardk> notice how that didn't need Num on the 'a' that was tucked in the newtype
16:02:42 <jrmithdobbs> skypers: ya that has apparently not gotten any better, still trying to open the 9G binary file i told it to a minute ago, hasn't segfaulted but to 2G heap so far
16:02:52 <edwardk> Church encoded numerals are just about providing a base case and what to do for each iteration
16:03:05 <jrmithdobbs> skypers: so this is a dead research project. noted. ;p
16:03:05 <roboguy_> twiceler: huh, I could have sworn there were
16:03:09 <roboguy_> maybe not
16:03:27 <twiceler> roboguy_: I was suprised too! I think it's Data.Vector that has that
16:03:37 <jrmithdobbs> oh that's awesome, it traps INT and STOP while it's loading too, great
16:03:49 <roboguy_> twiceler: ahh that could be what I'm thinking of
16:04:28 <twiceler> Perhaps Data.Vector.Unboxed.Mutable will be faster?
16:05:53 <twiceler> I do have a 2D array, so STUArray was definitely more convenient in that regard
16:06:13 <heatsink> Unboxed mutable arrays will probably use the same primitive array read/write operations as STUArray
16:06:18 <heatsink> vectors, I mean
16:07:03 <heatsink> How large is the code that uses the STUArray?  You might want to look at the optimizer's output.
16:07:42 <twiceler> heatsink: Not sure. I could take a look
16:07:47 <jmcarthur> thoughtpolice: "yes, without TypeFamilies, GND is safe. (SafeHaskell still ban GND, however)" ... i realize you actually meant to say it to jrmithdobbs, but since i've look at it anyway, isn't GND also unsafe with GADTs?
16:08:04 <roboguy_> hmm, is a natural transformation type like this at all useful? {newtype Transformation f g a = Transformation (f a -> g a); type Natural f g a = forall b. a ~ b => Transformation f g a}
16:08:14 <jrmithdobbs> jmcarthur: indeed it is, was mentioned right after
16:08:18 <roboguy_> I notice the Functor and Contravariant instances seem interesting
16:08:35 <twiceler> It's possible that maybe it is fast, and it's just that it's got to spend its time doing something! I haven't done it in C to compare
16:08:36 <jmcarthur> jrmithdobbs: ah. i missed it.
16:08:48 <jmcarthur> i admit i only skimmed
16:08:49 <jrmithdobbs> jmcarthur: may have been in one of the linked articles
16:09:12 <danil> edwardk: So I followed the rabbit hole of getting Bound to work with more general term structures (e.g. System F terms with /\ and regular functions), and I ended up in a world where all the *s have turned into (k -> *) for some index kind k.
16:09:24 <twiceler> I sort of walk through a trie as I work with the array and that would be less pretty in C
16:09:59 <heatsink> Is the trie read-only?
16:10:11 <twiceler> heatsink: Yeah
16:10:11 <jrmithdobbs> there's got to be a prettier way to write this:
16:10:12 <jrmithdobbs> :t (((liftA (flip Node []) .) . liftA) .) . (.)
16:10:13 <lambdabot> Applicative f => (b -> a) -> (a1 -> b) -> f a1 -> f (Tree a)
16:11:54 <jrmithdobbs> it's the ending ... .) . (.) that I don't like
16:12:10 <Twey> jrmithdobbs: But you're fine with the rest of it?!  :þ
16:12:49 <jrmithdobbs> Twey: all instances of .) i should say i guess ;p
16:13:06 <dwcook> @unpl (((liftA (flip Node []) .) . liftA) .) . (.)
16:13:06 <lambdabot> (\ k q t -> liftA (\ c -> Node c []) (liftA (\ h -> k (q h)) t))
16:13:22 <jrmithdobbs> ya it's not much better
16:13:48 <heatsink> twiceler, I think you should check the core code.  Look for object allocation and indirect function calls.  In array-intensive Haskell code, overhead usually comes from those.
16:14:15 <roboguy_> I have a feeling that the answer is either "no" or "lens already does it", but does this formulation of natural transformations look like it could be useful somehow to anyone? http://lpaste.net/98921
16:15:09 <edwardk> not parsing the point of 'type NaturalWitness f g a = forall b. (a ~ b) => Transformation f g a'
16:15:20 <danil> edwardk: category-extras wouldn't happen to already contain this parallel class hierarchy of functors/monads between indexed types with index-preserving transformations ("class IFunctor f where ifmap :: (forall i. a i -> b i) -> f a j -> f b j"), would it?
16:15:25 <twiceler> heatsink: So GHC core? Thanks! I'm pretty unfamiliar with it; I guess now's the time to get familiar with it!
16:15:43 <edwardk> danil: it was under 'HFunctor' back then
16:15:55 <erisco> :t \f g x -> pure (pure . f . g) <*> x
16:15:56 <lambdabot> (Applicative f, Applicative f1) => (b1 -> b) -> (a -> b1) -> f a -> f (f1 b)
16:15:57 <roboguy_> edwardk: it requires "a" to be universally quantified
16:16:01 <edwardk> danil: i have a package that provides an updated form of it, but it isn't on hackage yet
16:16:07 <heatsink> twiceler, it will print the optimized code if you compile with -O2 -ddump-simpl -fforce-recomp
16:16:10 <erisco> jrmithdobbs, ^
16:16:22 <roboguy_> edwardk: so you can't give it a specific type. but when you use the synonym, you can still use "a" later in a type declaration
16:16:32 <twiceler> heatsink: Thanks
16:16:34 <roboguy_> by specific, I mean a type other than forall a. a
16:16:38 <erisco> :t (<*>) $ (pure . pure) (f . g)
16:16:39 <lambdabot>     Could not deduce (Show b0) arising from a use of `f'
16:16:39 <lambdabot>     from the context (Show a1, Applicative f, FromExpr c)
16:16:39 <lambdabot>       bound by the inferred type of
16:16:44 <erisco> oops
16:16:46 <roboguy_> edwardk: if that makes sense, hah
16:16:55 <erisco> :t (<*>) $ pure (pure . f . g)
16:16:56 <lambdabot>     Could not deduce (Show b0) arising from a use of `f'
16:16:56 <lambdabot>     from the context (Show a,
16:16:56 <lambdabot>                       Applicative f,
16:16:58 <edwardk> roboguy_: why not just Transformation f g -> f a -> g a   ?
16:17:20 <erisco> mkay not sure what it does not like about that version but whatever, you get the idea :)
16:17:23 <roboguy_> edwardk: for natural?
16:17:25 <erisco> does that work jrmithdobbs?
16:17:33 <danil> edwardk: Ah.  I'm basically just using those and an H-ified copy of prelude-extras right now
16:17:45 <edwardk> newtype Natural f g = Natural { unnatural :: forall a. f a -> g a }
16:18:24 <roboguy_> edwardk: but then I can't use it in a type signature like this (as far as I know): Natural f g -> f a -> g a, because the "a"s aren't the same
16:18:29 <edwardk> danil: https://github.com/ekmett/indexed/blob/master/src/Indexed/Functor.hs
16:18:35 <edwardk> roboguy_: sure you can
16:18:49 <edwardk> type that into ghci, and :t unnatural
16:19:03 <edwardk> you'll need rank-n types
16:19:06 <heatsink> twiceler, to find the relevant code in the output, it helps to search for the array-accessing functions, which have names like readDoubleArray# or readIntOffAddr#
16:19:16 <edwardk> but yu already needed it for the quantifier
16:19:24 <edwardk> you're trying to be too clever. the solution is easier
16:19:29 <greg`> i know im really late to the party but ive finally gorked monads
16:19:30 <twiceler> heatsink: cool; thanks
16:19:31 <jrmithdobbs> erisco: yes that's much closer to readable
16:19:31 <roboguy_> edwardk: oh, haha I didn't notice that. I *did* write this at like 3 am today
16:19:49 <greg`> ive known what they are and how they work for a while but i see why they are useful now
16:20:00 <erisco> jrmithdobbs, fmap $ pure . f. g  also works
16:20:10 <erisco> jrmithdobbs, since fmap f x == pure f <*> x
16:20:11 <edwardk> >>> newtype Nat f g = Nat { unnat :: forall a. f a -> g a }
16:20:12 <edwardk> >>> :t unnat
16:20:13 <greg`> *groked
16:20:14 <greg`> lol
16:20:15 <edwardk> unnat :: Nat f g -> f a -> g a
16:20:47 <edwardk> anyways with that definition and the new polykinded Category class in HEAD, you can actually make a category for Nat
16:21:00 <greg`> oh thats the first time ive seen that,
16:21:28 <greg`> an expression inside an accessor
16:21:37 <roboguy_> edwardk: would that be very useful? This is really an exercise for me to learn about natural transformations as the apply to Haskell (in this specific way)
16:22:38 <edwardk> roboguy_: well, with polykinds turned on the above is a once-and-forall solution for all arguments. note the natural transformation there has an argument of unspecified kind, its chosen by f or g. so Nat :: (k -> *) -> (k -> *) -> *
16:23:30 <roboguy_> edwardk: the arguments aren't necessarily of kind * -> *?
16:23:56 <edwardk> roboguy_: nothing requires the argument to be * in any of that. turn on polykinds and you get the more general type
16:24:02 <edwardk> roboguy_: this is a very good thing =)
16:24:21 <edwardk> roboguy_: as conor mcbride once showed you can use this to do all sorts of things.
16:24:40 <edwardk> roboguy_: in particular you only ever have to 'lift' like this once if you can do it for any kind.
16:25:11 <edwardk> that indexed package i was mentioning for unrelated reasons explores this further, as does a package by tekmo.
16:25:52 <bitemyapp> edwardk: for the daily double, does the package by tekmo involve free monads?
16:26:02 <edwardk> bitemyapp: probably =)
16:26:10 <roboguy_> edwardk: oh, you have Natural in Indexed.Types
16:26:15 <roboguy_> essentially
16:26:31 <edwardk> ah yes :~> or something
16:27:32 <erisco> edwardk, oh, I am sorry, you did not answer in the form of a question
16:27:35 <edwardk> i need to update that code to work with ghc head now that Typeable is baked in
16:27:45 <bitemyapp> erisco: lol
16:27:46 <edwardk> erisco: =)
16:27:57 * edwardk rephrases.
16:28:03 <edwardk> bitemyapp: probably? =)
16:28:09 <roboguy_> edwardk: maybe *someday* I'll be able to understand the foundations of your libraries...
16:28:49 <edwardk> roboguy_: this was mostly from me exploring the paper by conor
16:28:54 <mm_freak> bitemyapp: which package?
16:29:09 <mm_freak> pipes-parse uses free monads
16:29:16 <edwardk> roboguy_: //personal.cis.strath.ac.uk/conor.mcbride/Kleisli.pdf
16:29:30 <edwardk> i recommend that as a starting point for understanding the code there =)
16:29:49 <roboguy_> edwardk: ahh, cool. thanks!
16:30:29 <edwardk> that'll show you why the higher rank monad stuff is the way it is, the Coat stuff was me working out how to make the comonadic side work. it was a lot harder than i expected!
16:30:31 <roboguy_> edwardk: I was actually trying to figure out the foundations for lens, prisms, isos, etc, earlier from the page about how to use lenses without depending on lens
16:30:56 <edwardk> heh. lens is tricky, because it has to show all of its guts to work.
16:31:21 <roboguy_> yeah. ghc doesn't like to preserve type synonyms does it?
16:31:34 <roboguy_> (for reporting)
16:32:10 * hackagebot cookbook 2.1.2.1 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.1.2.1 (NatePisarski)
16:32:12 <edwardk> roboguy_: it trashes them fairly eagerly when it has to do any unification inside them
16:32:36 <edwardk> and most times when it doesn't
16:34:09 <danil> edwardk: that package is exacly what I was after, with bonus derpendent types
16:34:26 <edwardk> =)
16:34:40 <edwardk> note that those aren't sound w.r.t safe haskell!
16:35:14 <edwardk> sadly we're still without real product kinds for haskell =(
16:35:19 <Sagi> what's the goto vim-plugin for haskell these days? I see multiple listed on the wiki.
16:35:26 <edwardk> or sum kinds for that matter
16:35:47 * Sagi looks at https://github.com/eagletmt/ghcmod-vim
16:35:57 <edwardk> this basically is why the indexed package has never been released, as i can't finish it under the status quo
16:36:35 <roboguy_> edwardk: one think I always wondered is: what's a good way to get used to using lenses? because I think I understand a decent amount of how to use lens, but it seems like I haven't quite gotten to the point of being able to effectively design with those concepts
16:36:37 <edwardk> i can't work out indexed monad transformers, can't finish up my remote programming EDSL, etc.
16:36:48 <roboguy_> I guess the answer is just to use them, but I was wondering if you have any more specific tips
16:36:57 <edwardk> roboguy_: mostly lurk on the #haskell-lens channel and ask questions ;)
16:38:05 <ziman> "derpendent types", nice one :)
16:38:23 <edwardk> ziman: i was somewhat upset
16:39:12 <edwardk> it still galls me that Any inhabits every kind making every product kind distinguishably too big
16:39:36 <edwardk> the kind (x,y)   doesn't have x * y inhabitants it has x * y + 1
16:39:49 <roboguy_> I have no idea what that means. maybe I need to read that paper first, haha
16:39:53 <edwardk> er |x| * |y| inhabitants, it has |x| * |y| + 1
16:40:04 <roboguy_> I've only worked with "concrete" kinds (if that's the right word)
16:40:05 <edwardk> roboguy_: GHC.Prim.Any is a type of kind k.
16:40:06 <shachaf> The type (x,y) doesn't have |x| * |y| inhabitants, it has |x| * |y| + 1
16:40:18 <shachaf> But it's not so distinguishable.
16:40:49 <edwardk> shachaf: the trick is that there we are working in a CPO that prevents us from abusing that knowledge
16:41:12 <danil> undefined is also not living on the level where you need to convince the compiler that (Fst p, Snd p) = p in order to make things typecheck
16:41:15 <edwardk> shachaf: nothing requires the type family to be monotone w.r.t Any
16:41:21 <shachaf> edwardk: Right.
16:41:33 <shachaf> Hence the distinguishability thing.
16:41:43 <shachaf> edwardk: Not that that's enough for Harper.
16:41:52 <edwardk> and even if we had that condition, it'd not be good enough
16:42:21 <shachaf> At the type level you don't want _|_ anyway.
16:42:28 <edwardk> i confess i don't _like_ the fact that we only get these weak lifted product things, but hey
16:42:39 <edwardk> and yeah, that's why it'd not be good enough.
16:42:47 <chrisdotcode> hi guys; is there anyway to refactor "intToList x = take x $ repeat x"?
16:43:08 <roboguy_> chrisdotcode: replicate x x
16:43:11 <edwardk> you need the ability to refine the fact that given a product kind the only inhabitants are of the form '(xt,yt) for some xt and yt.
16:43:24 <chrisdotcode> @src replicate
16:43:25 <lambdabot> replicate n x = take n (repeat x)
16:43:26 <edwardk> and you can't refine that way safely in the presence of Any.
16:43:30 <chrisdotcode> roboguy_: sweet, thanks :)
16:43:32 <roboguy_> chrisdotcode: or join replicate, if you feel like you want some point free obfuscation
16:43:47 <chrisdotcode> > join . replicate 5
16:43:49 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
16:43:49 <lambdabot>    arising from a use of `M450880635957448503416228.show_M4508806359574485034...
16:43:49 <lambdabot>  The type variable `a0' is ambiguous
16:43:49 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:43:49 <lambdabot>  Note: there are several potential instances:
16:43:57 <c_wraith> roboguy_: nah, obfuscated would be take <*> repeat
16:44:00 <edwardk> it also requires changing details of GHC's internals to support the 'expansion' needed
16:44:02 <roboguy_> > let intToList = join replicate in intToList 5
16:44:04 <lambdabot>  [5,5,5,5,5]
16:44:14 <roboguy_> c_wraith: yeah, that's true
16:44:20 <chrisdotcode> roboguy_: heh, I'd prefer the just replicate variant, thanks :)
16:47:34 <cmiller_> Anyone know of a good resource for using/understanding the ST monad?
16:48:49 <shachaf> Do you understand rank-2 types?
16:48:52 <c_wraith> cmiller_: which part?  How it's externally pure, or what the actual implementation is?
16:49:10 <lingxiao> hey all
16:49:20 <cmiller_> I guess the actual implementation.
16:49:27 <lingxiao> I'm trying to grok the difference between type families and GADTs
16:49:45 <arcke> http://lpaste.net/98925 <- trouble with fractional use of integer, how to compile this?
16:49:49 <c_wraith> the actual implementation is mutable memory cells.  STRef = IORef, STArray = IOArray
16:49:53 <lingxiao> and the tutorial says: "However, all GADT constructors must be defined in one place, whereas type families can be extended"
16:50:11 <roboguy_> lingxiao: that won't be true in all cases when GHC 7.8 comes out
16:50:15 <roboguy_> they're adding closed type families
16:50:38 <lingxiao> so... closed to extension I'm guessing, in what case?
16:50:51 <c_wraith> Different syntax used to declare it
16:50:53 <lingxiao> like literally, if you defined it in moudule A, you could not add a def in module B
16:51:08 <roboguy_> lingxiao: you can't even add to it later in the same module
16:51:14 <c_wraith> When you use the alternate syntax, all the equations are in one spot.  Can't even spread it across the module
16:51:34 <lingxiao> hmm... so when would I want to use type family vs gadt?
16:51:42 <cmiller_> So the point of it I'm understanding is that you can't let the 's' type escape the do? Is that the idea?
16:51:50 <Twey> lingxiao: GADTs are normal type constructors, but restricted to certain parameters allowed by the constructors
16:51:56 <roboguy_> lingxiao: GADTs are a way to make constructors with different types than the default way to make constructors. type families are essentially type level functions
16:51:58 <Twey> lingxiao: Notably, they're injective
16:52:01 <c_wraith> cmiller_: you can't let s escape runST.  It can escape any particular do block.
16:52:13 <Twey> lingxiao: Type families are just arbitrary type functions
16:52:15 <lingxiao> https://gist.github.com/anonymous/3c767d3877419ae2aebb
16:52:31 <lingxiao> so could you give me an example I could do in Xlist that I can't do in Ylist?
16:52:45 <shachaf> s is a dummy parameter. The important part is that you don't know what it is.
16:53:00 <cmiller_> right. So the mutable ST values can pass between do levels as long as it doesn't move past the runST.
16:53:02 <cmiller_> ?
16:53:10 <shachaf> What are do levels?
16:53:16 <lingxiao> https://gist.github.com/anonymous/640352976c5cf7be198e
16:53:21 <cmiller_> like a nested do.
16:53:22 <lingxiao> a shorter example
16:53:45 <shachaf> I'm not entirely sure what that means, but the answer is probably yes.
16:53:53 <Twey> lingxiao: That's a data family, which is a bit different
16:53:57 <cmiller_> or I guess more precisely, a monadic operation inside another monad.
16:54:11 <shachaf> There's only one monad involved here.
16:54:24 <dmj`> do doesn't necessarily imply monadic operation
16:54:26 <dmj`> > do 4 + 5
16:54:28 <lambdabot>  9
16:54:39 <lingxiao> Twey: see this is confusing because the code says right there: "Data family", but in this tutorial: http://www.haskell.org/haskellwiki/GHC/Type_families
16:54:41 <shachaf> dmj`: That's technically true but probably entirely irrelevant.
16:54:45 <lingxiao> it's unders the heading Type Family
16:55:01 <shachaf> Well. "ST s" is one monad, and "ST t" is another.
16:55:16 <lingxiao>  Using type families, this list type could be declared as follows:
16:55:17 <lingxiao> -- Declare a list-like data family
16:55:17 <lingxiao> data family XList a
16:55:19 <lingxiao> and specifically says:
16:55:31 <lingxiao> erm.. specifically says  --^
16:55:40 <Twey> lingxiao: Data families are vaguely a kind of type family.  You can implement a data family using several different datatypes and a type family to switch between them, I think.
16:55:44 <shachaf> So for any particular "s", things of type "ST s ..." work together. You have (>>=) :: ST s a -> (a -> ST s b) -> ST s b and so on.
16:55:46 <roboguy_> lingxiao: a type family is more like a fancy type synonym that can do pattern matching
16:56:18 <shachaf> But you don't have (>>=) :: ST s a -> (a -> ST t b) -> ST t b or anything like that.
16:56:28 <Twey> lingxiao: Basically, a GADT lets you give different type arguments to different constructors, whereas a data family lets you give different constructors to different type arguments
16:57:12 * hackagebot htsn-import 0.0.1 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.0.1 (MichaelOrlitzky)
16:57:25 <cmiller_> kk So the monad isn't ST, it's ST s.  (Sorry if I'm being dense, I was born that way)
16:57:27 <erisco> who posted take <*> repeat? I have not looked at applicative for functions but it is quite interesting
16:57:35 <lingxiao> Twey: ok let me absorb that for a second
16:58:07 <roboguy_> erisco: it was c_wraith I think
16:58:20 <roboguy_> erisco: the applicative instance for functions can come in handy
16:59:18 <roboguy_> erisco: here's an example: positiveLessThanTen = (&&) <$> (>0) <*> (<10)
16:59:21 <shachaf> A Monad instance is always of kind * -> *. So Maybe is a monad, and Maybe Int is a type. Similarly "ST s" is a monad, and "ST s Int" is a type.
16:59:34 <roboguy_> erisco: that's True if and only if the argument is between 0 and 10
16:59:43 <lingxiao> by the way how did you guys learn this stuff?
16:59:58 <erisco> square = (*) <*> id
17:00:01 <lingxiao> what were some really good resources that help you organize these ideas in your head
17:00:03 <shachaf> Anyway, the important is in the parts of newSTRef and readSTRef and so on.
17:00:04 <Twey> lingxiao: I have no idea
17:00:05 <shachaf> :t newSTRef
17:00:06 <lambdabot> a -> ST s (STRef s a)
17:00:09 <roboguy_> lingxiao: mostly hanging out here and messing around with things on my own until they made sense
17:00:19 <shachaf> :t readSTRef
17:00:20 <lambdabot> STRef s a -> ST s a
17:00:26 <shachaf> ST s and STRef s share the same "s"
17:00:28 <roboguy_> lingxiao: like right now, I'm trying to see how the notion of a natural transformation can be used in haskell
17:00:37 <roboguy_> as an abstraction
17:00:43 <Twey> lingxiao: I read learnt Agda and read TAPL, and then suddenly I understood (most of) Haskell
17:00:51 <Twey> s/read //
17:01:04 <shachaf> So that means I can't write let var = runSTRef $ do { x <- newSTRef 0; return x } in runSTRef (readSTRef var)
17:01:21 <shachaf> Do you see what the problem is there?
17:01:27 <lingxiao> Twey: haha what ever you did it worked! And yeah I'm working through TAPL right now, it's really amazing and wished I had started sooner
17:01:44 <danil> lingxiao: for me it was some combination of reading papers, reading other people's code, and mucking about until stuff compiled
17:02:22 <roboguy_> erisco: by the way, I think this particular example is more readable when written without Applicative, but it might help illustrate the function instance some
17:02:31 <erisco> so basically you can take a function and pre-map its arguments with other functions
17:02:34 <lingxiao> roboguy_: yeah and I take it ekmett is helping you? he's an amazing dude
17:02:47 <qrada> merijn: createProcess did the trick, thanks !
17:03:02 <roboguy_> lingxiao: yep. he definitely is. his libraries are awesome
17:03:03 <erisco> sort of
17:03:27 <erisco> (all the functions work off the same input)
17:03:32 <lingxiao> very magnanemous in real life too, personable yet sophisticated like his code
17:03:41 <roboguy_> erisco: yeah. it's sort of when you want several functions over the same input
17:06:14 <erisco> increment by two: (fmap <*> id) (+1)  I am not sure why :D
17:06:21 <roboguy_> erisco: if you are familiar with the SK combinators, (<*>) = S
17:06:30 <erisco> nope
17:07:10 <roboguy_> ah. well, S = (<*>) f g = \x -> f x (g x)
17:07:41 <erisco> yeah I figured that much but I am still baffled at a glance how it works out
17:08:26 <joelteon> id (+1) . (+1)
17:08:35 <roboguy_> (fmap <*> id) => \x -> fmap x (id x) => \x -> fmap x x => \x -> (.) x x => \x -> x . x => \x y -> x (x y)
17:08:55 <roboguy_> then we have x = (+1), so \y -> (+1) ((+1) y)
17:09:26 <roboguy_> f would probably be a better name for x
17:10:10 <erisco> joelteon, ah yeah okay
17:11:03 <eazar001> anyone have any recommendations for a haskell framework similar to something like Python's "Scrapy"?
17:11:06 <erisco> fmap (+1) (+1) == (+1) . (+1) easy 'nuff
17:12:45 <roboguy_> erisco: the Monad instance for the function type is interesting too
17:13:04 <roboguy_> > join (*) 10
17:13:06 <lambdabot>  100
17:13:47 <dmj`> eazar001: you can try tag soup w/ parsec
17:13:54 <roboguy_> lingxiao: I also find that trying to explain things to people helps me understand them better. sometimes I'll try to explain something and I'll realize I don't understand it as well as I think I do so I learn more about it
17:13:58 <dmj`> eazar001: or read this: http://adit.io/posts/2012-03-10-building_a_concurrent_web_scraper_with_haskell.html
17:14:52 <eazar001> djm`: yea, i knew about tagsoup, i was just wondering if there was something as specific and kind of mature like scrapy
17:15:32 <eazar001> djm`: so i guess the short answer is i'll have to roll my own, but i saw this other called "shpider" that looks like it has a bit of a base to build off of
17:17:08 <eazar001> djm`: and thanks for the article i'll give it a good readf
17:17:17 <dmj`> np
17:18:04 <erisco> > (\x -> (foldl <*> const x) (flip (:))) [1,2,3] [4,5,6]
17:18:05 <lambdabot>  [6,5,4,1,2,3]
17:18:11 <erisco> just playing around :P
17:21:05 <erisco> not sure what cases there are for two <*>'s
17:21:49 <roboguy_> two <*>s? what do you mean?
17:22:07 <erisco> :t \f g h -> f <*> g <*> h
17:22:08 <lambdabot> Applicative f => f (a1 -> a -> b) -> f a1 -> f a -> f b
17:22:31 <roboguy_> erisco: usually you use <$> first
17:23:44 <roboguy_> > let f x y z = x * y - z in (f <$> (*10) <*> (*100) <*> (*1000)) 2
17:23:46 <lambdabot>  2000
17:24:35 <danil> > let xs = [1,2,3] in sum ((\a b c -> a * b - c) <$> xs <*> xs <*> xs)
17:24:36 <lambdabot>  54
17:25:21 <dmj`> (a,b,c) <- (,,) <$> getLine <*> getLine <*> getLine
17:26:18 <fistfulofmonads> :t (<*>)
17:26:19 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
17:26:22 <fistfulofmonads> :t (ap)
17:26:23 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:26:37 <dmj`> :t (,) <$> get <*> ask
17:26:38 <lambdabot> (Applicative f, MonadReader a f, MonadState a1 f) => f (a1, a)
17:27:13 <roboguy_> fistfulofmonads: ap = (<*>), conceptually at least
17:27:31 <fistfulofmonads> I figured as much, was confirming the types
17:27:42 <roboguy_> eventually it could literally be the definition, once Applicative is a superclass of Monad
17:27:56 <fistfulofmonads> will that happen in the next Haskell release?
17:28:28 <roboguy_> fistfulofmonads: I think the one after the next one
17:28:31 <roboguy_> the next one is GHC 7.8
17:31:26 <meretrix> I am testing a large haskell program I wrote that is designed to print messages when warnings occur, but I am seeing strange output like "[(),(),(),(),(),(),(),()]" (with maybe 200-300 elements).  Any idea what's going on?
17:31:42 <fistfulofmonads> meretrix: are you using mapM or something of the like?
17:31:52 <meretrix> fistfulofmonads: Yes, in many places.
17:32:19 <acowley> use mapM_
17:32:26 <meretrix> Ah
17:32:35 <fistfulofmonads> mapM has a return type of m [a], mapM_ returns m()
17:32:58 <meretrix> Thanks, I'll look for that.
17:34:27 <mightybyte> Just in case there are people here who don't subscribe to haskell-cafe or read the haskell reddit...
17:34:28 <mightybyte> http://www.haskell.org/pipermail/haskell-cafe/2014-January/112362.html
17:34:35 <lingxiao> roboguy_: yes that helps me too, though this channel is filled with teachers, I'd have to look elsewhere for people whom I could teach :)
17:35:02 <jrmithdobbs> :!git status
17:35:07 <jrmithdobbs> ...
17:35:11 <fistfulofmonads> oo that looks sweet
17:35:42 <roboguy_> jrmithdobbs: hmm?
17:35:50 <erisco> if teleporters are invented before April I'll attend
17:35:55 <fistfulofmonads> I think  he meant to do that in  vim or something
17:35:56 <jrmithdobbs> roboguy_: this is not the ghci terminal i was looking for
17:36:07 <roboguy_> ahh, hah
17:36:32 <fistfulofmonads> thanks jrmithdobbs , I just learned you can execute shell commands in ghci
17:36:52 <jrmithdobbs> heh, glad to help
17:37:47 <jrmithdobbs> fistfulofmonads: it even does fs tab completion without wonky retardedness ... unlike pry
17:38:50 <fistfulofmonads> i love zsh  autocompletion, I wish more programs had something like that
17:40:21 <JakeE> I'm trying to get some code haskell code from 1997 to work on a modern version of GHC. I'm sorrly lacking historical refrence and can't find old documentation however. The code is trying to import "randomInts" and "randomDoubles" from System.Random. These no longer appear to be functions. What were they?
17:40:47 <Twey> JakeE: Sounds like ‘randoms’ covers both
17:41:49 <Twey> JakeE: Or maybe it's http://www.haskell.org/ghc/docs/0.29/users_guide/user_74.html
17:42:13 <JakeE> Twey: that seems to be the documentation! Thanks!
17:42:44 <fistfulofmonads> did 1997 haskell not have typeclasses, or were they  just not used for the random package at the  time?
17:43:34 <Cale> 1997 Haskell had type classes
17:43:45 <Cale> as for Random, let me look
17:43:53 <Twey> fistfulofmonads: By the look of that documentation, it had type-classes, but might not have been able to dispatch on the return type
17:44:25 <Twey> Oh no, never mind, here's one that does so
17:44:27 <fistfulofmonads> haskell archaelogy
17:44:36 <Cale> Yeah, it just had:
17:44:40 <Twey> Guess they just decided not to use them
17:44:48 <Cale> random :: (Integer, Integer) -> Integer -> [Integer]
17:44:49 <Cale> and
17:44:55 <JakeE> lol even if this did have typeclasses they aren't being used. It's terrible code lol
17:44:59 <Cale> randomIO :: (Integer, Integer) -> IO [Integer]
17:45:26 <Cale> That was it, for the random numbers module :)
17:45:30 <Twey> Interesting, randomDoubles is curried but random and randomIO are uncurried
17:45:45 <Cale> Oh, are you seeing other stuff?
17:45:51 <Cale> What are you looking at Twey?
17:45:55 <Twey> Cale: We're looking at the HBC libraries: http://www.haskell.org/ghc/docs/0.29/users_guide/user_74.html
17:46:03 <Cale> ah, okay
17:46:19 <Cale> I was looking at the 1.4 report
17:46:20 <Twey> (from GHC 0.29… heh)
17:48:18 <fistfulofmonads> is there something like the cmdargs package, but for an internal command line for my program? or should I try messing with the  functions cmdargs provide that don't directly use IO/getArgs
17:49:40 <JakeE> looks like 'randoms' will be my replacement! Thanks Twey
17:49:41 <Cale> If you look in the Haskell 1.4 Prelude, there are some surprises
17:49:58 <Cale> like:  filter :: MonadZero m => (a -> Bool) -> m a -> m a
17:50:16 <Cale> filter p = applyM (\x -> if p x then return x else zero)
17:50:59 <copumpkin> applyM?
17:51:07 <copumpkin> oh
17:51:10 <jle`> hey...shouldn't C++ actually be ++C?
17:51:11 <copumpkin> >>=
17:51:14 <Cale> applyM f x = x >>= f
17:51:39 <roboguy_> jle`: probably because C++ means that it hasn't changed from C yet haha
17:51:49 <joelteon> it's undefined
17:51:55 <Cale> class (MonadZero m) => MonadPlus m where (++) :: m a -> m a -> m a
17:52:01 <roboguy_> joelteon: what is?
17:52:05 <Cale> concat :: MonadPlus m => [m a] -> m a; concat = foldr (++) zero
17:52:17 <joelteon> roboguy_: ordering of ++
17:52:43 <jle`> Cale: that must be from the good ol days
17:52:48 <Cale> yes
17:52:52 <jle`> where map was for all functors
17:52:55 <Cale> yep
17:52:56 <Twey> Cale: Nice
17:53:12 <Cale> class Functor f where map :: (a -> b) -> f a -> f b
17:53:13 <jle`> and there were no newcomers ever
17:53:21 <roboguy_> joelteon: no it's not... a++ means post increment and ++a means preincrement
17:53:38 <Twey> Never mind, I'm sure edwardk will give us back our genericity!
17:53:43 <roboguy_> joelteon: you're probably thinking of things like a++ + a++, which is undefined but for different reasons
17:53:58 <jle`> yeah, a++ increments it but returns the unincremented version
17:53:59 <roboguy_> joelteon: that's undefined because "+" isn't a sequence point in C++
17:54:05 <jle`> ++a increments but returns the incremted version
17:54:10 <jle`> so C++ should give you just C?
17:54:15 <roboguy_> jle`: yup, haha
17:54:29 <Twey> jle`: But there'll be an incremented version hiding somewhere else, where you can't access it.
17:54:46 <joelteon> roboguy_: whoops
17:54:48 <roboguy_> Twey: well, you can access it after a sequence point
17:55:14 <roboguy_> ... which is hard to fit into this metaphor
17:55:15 <joelteon> C++;
17:55:27 <joelteon> which is sort of like a winking anteater
17:55:31 <roboguy_> haha
17:56:18 <jle`> also, why did MonadPlus ever swallow up MonadZero
17:56:30 <jle`> what was the motivation behind that?
17:56:58 <roboguy_> why wasn't "fail" kept separate in MonadZero?
17:57:08 <kristof> What are the mathematical analog to algebraic effects? Is there any well understood theory around them?
17:57:10 <jle`> well fail is a different concept than MonadZero's zero
17:57:21 * hackagebot locators 0.2.3.1 - Human exchangable identifiers and locators  http://hackage.haskell.org/package/locators-0.2.3.1 (AndrewCowie)
17:57:35 <jle`> fail called on a pattern match fail
17:57:55 <jle`> zero represents the general concept of "failure" for that particular monad
17:58:04 <Cale> fail should also be in its own class
17:58:07 <jle`> so...one is tied to the language syntax
17:58:14 <jle`> the other is semantic-ish
17:58:18 <Cale> zero used to be tied to that language syntax
17:58:26 <jle`> really?
17:58:30 <Cale> In fact more closely tied than fail is now
17:58:39 <JakeE> Twey: the whole thing is working now (well it compiled) you saved me so much trouble
17:58:39 <Cale> because Haskell 1.4 had monad comprehensions
17:58:41 <jle`> that's interesting
17:58:45 <jle`> oh yeah
17:58:46 <Cale> So list comprehensions used MonadZero
17:58:47 <jle`> i remember
17:58:51 <kristof> Oh, algebraic effects are just algebraic operations.
17:58:57 <jle`> or well, i don't remember from being there
17:59:00 <jle`> i remember that it had them
17:59:12 <jle`> :)
17:59:23 <Cale> also, pattern match failure used zero
17:59:32 <roboguy_> wasn't fmap also called map originally?
17:59:36 <Cale> (in do and list/monad comprehensions)
17:59:39 <jle`> i perhaps was referring to the state of affairs of things today
17:59:39 <Cale> yes
18:00:05 <jle`> roboguy_: yeah, Cale posted it a bit earlier
18:00:13 <roboguy_> oh, I missed that
18:00:22 <Cale> So, monad comprehensions were removed because someone didn't want to teach his students about monads and they'd cause error messages which discuss monads
18:00:34 <roboguy_> that's unfortunate
18:00:48 <roboguy_> although I can kind of understand the reasoning
18:01:04 <jle`> it's similar to the fmap/map motivation...but actually probably kind of stronger
18:01:23 <roboguy_> there's a MonadComprehensions ghc extension right?
18:01:29 <Cale> and then someone else realised "oh, we don't need zero in its own class because it's just there for monad comprehensions anyway and all the instances of MonadZero in the libraries are also instances of MonadPlus anyhow", so they merged those
18:01:31 <jle`> hm. so was there a reason that MonadPlus swallowed up MonadZero? maybe because monad comprehensions/zero was 'eliminated' and turned into fail in Monad?
18:01:47 <jle`> ah
18:01:52 <jle`> i type too slow
18:02:03 <Cale> and then "oops, do-notation uses zero when failable patterns are used, but we don't want to restrict *that* to MonadPlus"
18:02:18 <Cale> and so for some reason that was a justification to stick fail into Monad
18:02:33 <roboguy_> are there any plans to separate out fail?
18:02:39 <Cale> It was not the best time for the Haskell committee there :)
18:03:37 <Twey> Language design is hard
18:03:47 <Cale> roboguy_: I don't see any great reason it couldn't be done. It would result in a little bit of pain, but I suspect not much more than removing Eq and Show as superclasses of Num.
18:04:02 <Cale> and I suspect most people would like to see it happen?
18:04:08 <Twey> I don't think I've yet seen a single programming language that didn't make some decisions in its youth that its designers lately greatly regretted
18:04:55 <roboguy_> Cale: I would like to see that happen
18:04:59 <Twey> later**
18:05:05 <Twey> I think everyone would like to see that happen
18:05:12 <Cale> Also, the Haskell 98 Report describes a translation for do-notation which always uses fail, but GHC never actually switched, as far as I'm aware
18:05:31 <roboguy_> I think the majority of Haskell's decisions were good though
18:05:35 <Twey> Or downright removed; fail is daft (why a String, of all things?  Surely we can do better than that in these heady days of MPTCs)
18:05:44 <Cale> from the older one described in 1.3 and 1.4 which checks to see if the pattern is failable before using the more elaborate translation
18:08:02 <Cale> I think I would be all right with the use of a failable pattern resulting in a MonadZero constraint
18:08:34 <Cale> The thing is, it's a little unfortunate because you get worse error messages then in the case of IO
18:08:43 <Cale> If someone does [x] <- getArgs
18:08:55 <Cale> you no longer get a message with the line number and such
18:09:42 <Cale> Unless that's just a type error
18:10:13 <Cale> They could write ~[x] <- getArgs
18:10:17 <roboguy_> Cale: nope, runtime error
18:10:25 <Cale> roboguy_: right *now* it is
18:10:26 <roboguy_> actually, it looks like it does give a line number
18:10:33 <Cale> I'm talking about if we get rid of fail
18:10:39 <roboguy_> ahh, oops
18:11:17 <Cale> We could make it a type error to write [x] <- getArgs if we wanted to
18:11:30 <Cale> Which I don't think would be too sad
18:11:47 <Cale> All you'd need to do if you wanted to be lazy is add a ~
18:12:06 <roboguy_> hmm
18:12:09 <Cale> But that does change the semantics
18:12:22 <Cale> deferring the runtime error to the point at which x is used
18:12:24 <Twey> Cale: You can always make the ‘fail’ for IO be some action that gets a line number via IO magic
18:12:46 <Twey> (and dies with a useful error)
18:12:48 <Cale> That's kinda tricky, what kind of IO magic?
18:13:02 <Cale> You'd need a lot of magic, I think
18:13:06 <Twey> Any kind of IO magic.  The point is that it's IO: it doesn't have to make sense :þ
18:13:50 <Twey> It's perfectly okay to have it just come up with the line number on which it originated, from nowhere, because it's IO
18:14:08 <Cale> Well, you still have to compile this somehow
18:14:47 <c_wraith> can you add rewrite rules for fail in IO?
18:14:52 <Cale> Also, "the line number on which it originated" -- is that the definition of mzero for IO? :)
18:15:39 <Cale> So, I dunno, I would also support keeping fail around, so long as it was moved into a new class
18:15:40 <Twey> I'm not sure whether MonadFail should be the same thing as MonadZero
18:15:54 <Cale> separate from MonadZero of course
18:15:54 <Twey> I can imagine a non-error use of MonadZero
18:15:59 <Twey> Yes
18:16:03 <jmcarthur> c_wraith: sure, why not?
18:16:20 <Cale> Well, yeah, most uses of MonadZero are *kinda* non-error cases
18:16:28 <defanor> could somebody recommend some key-value storage for haskell? i need to store/load just data of algebraic types, but it'd be nice to avoid manual writing of parsers and composers for that, if it's possible. and also keys are going to be of algebraic types as well
18:16:38 <Cale> In that the good ones are meant not to throw exceptions at least.
18:17:06 <Cale> defanor: Are you asking for Data.Map?
18:17:12 <c_wraith> jmcarthur: I just wasn't sure if the desuraring happened before the rewrite rules were applied
18:17:16 <c_wraith> *desugaring
18:17:27 * hackagebot wai-extra 2.0.3.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.0.3.1 (MichaelSnoyman)
18:17:32 <Cale> defanor: or perhaps something more like acid-state?
18:17:39 <Twey> If you do that, then, MonadFail's fail can take some kind of argument describing the failure case, like the current String but hopefully more flexible — at least a line number
18:17:43 <jmcarthur> c_wraith: it must happen before rewrite rules, as far as i know.
18:18:05 <Twey> Maybe a sum type — Either CompilerGeneratedError SomeUserDefinedError
18:18:10 <defanor> Cale: will check now, thanks. but i need to write it on disk also, hope it's possible with Map. and i've checked Acid-state, but it's not what i'm looking for: it's going to be too slow, i think
18:18:32 <Cale> defanor: Data.Map is just an abstract finite map data structure
18:18:40 <jmcarthur> c_wraith: the simplifier (where rewrite rules are applied, among other things) runs on Core, not the Haskell AST
18:18:44 <Twey> Where your SomeUserDefinedError type can be a second parameter to the MonadFail class
18:19:05 <Cale> defanor: It doesn't have anything to do with I/O
18:19:29 <Twey> That gives you a uniform interface for pattern-match failures and things whilst allowing the type to define its own failure conditions on top of that, and report them sensibly
18:19:38 <defanor> Cale: oh. i forgot to mention it in the question: by "storage" i meant like a persistent storage
18:19:46 <Cale> defanor: But I dunno, it seems like if you want a key/value store on disk, acid-state + a simple Data.Map structure should work
18:20:06 <Cale> I don't understand why you think it would be too slow, have you tried it?
18:20:39 <Twey> Or you could just have two class methods, of course
18:20:46 <defanor> Cale: but acid-state will store all the functions, right? i'm planning to have a lot of functions applied, unlimited amount of them
18:21:04 <defanor> Cale: have not tried
18:22:51 <JakeE> does parrlell evaluation mess with trace?
18:23:08 <Cale> JakeE: yes?
18:23:29 <Cale> JakeE: Well, trace prints its message when it is evaluated
18:23:34 <lingxiao> what pragma do I need for this to be legal syntax:
18:23:37 <lingxiao> https://gist.github.com/anonymous/45753d471158ea4eda26
18:23:50 <lingxiao> if any exist
18:23:51 <Cale> JakeE: But parallelism will affect when that is
18:24:30 <Cale> lingxiao: closed type families
18:24:59 <JakeE> Cale: so this code I got working. It's for genetic programing. It's from 1997 and it uses Trace to print messages. To speed it up I tried evaluating it in parlell (I have 8 cores). The trace is behaving very eradiclly. It looks like no computation is getting done even though my processors are being used preety hevially
18:25:12 <Cale> lingxiao: Unless you're using GHC 7.8, it's not available yet.
18:25:22 <lingxiao> hmm ok thanks
18:25:31 <lingxiao> would you advise getting GHC 7.8?
18:25:32 <mm_freak> is there any way to get/emulate linear/uniqueness types in haskell?
18:25:53 <JakeE> only use varibles once lol
18:25:58 <mm_freak> perhaps in the upcoming GHC 7.8?
18:26:14 <Cale> lingxiao: If you're adventurous you could
18:26:31 <lingxiao> lol I had fun once, I hated it :(
18:26:46 <jmcarthur> lingxiao: it will be released pretty soon anyway
18:26:51 <roboguy_> I've been using it some lately. I had some problems at first but I seem to have ironed them out
18:26:57 <Cale> It's taking a long time to come out, it's been close to release for months. Not sure exactly what's blocking release.
18:27:04 <roboguy_> jmcarthur: they said that a while ago...
18:27:07 <jmcarthur> lingxiao: of course, some might still advise you to wait for the platform, too
18:27:18 <jmcarthur> roboguy_: time estimation is hard. they still believe it should be soon.
18:27:22 <roboguy_> cabal doesn't seem to install on GHC HEAD
18:27:28 <roboguy_> actually, I should probably tell someone that
18:27:37 <mm_freak> certain abstraction patterns would really benefit from uniqueness types
18:27:48 <mm_freak> not that it has bitten me, but it feels unsafe
18:27:54 <roboguy_> mm_freak: I really wish I knew about uniqueness types. I have a vague idea of the general concept
18:28:15 <roboguy_> it's related to linear logic right (which I know very little about too)?
18:28:29 <Cale> mm_freak: Well, not that it's really the same thing, but you can ensure the same guarantees in client code using a monad.
18:28:29 <jmcarthur> mm_freak: the only way i know of to get anything resembling linear types is to do indexed monad trickiness, which is really not pleasant and only works for contexts, not for individual values
18:28:33 <lingxiao> ok thanks! for both sideof the story!
18:28:57 <JakeE> is there a guide on choosing the right parlell evaluation stradgy?
18:28:57 <Cale> Does it really have to be indexed?
18:28:58 <jmcarthur> i guess the index could be some typing environment for values or something...
18:29:29 <jmcarthur> Cale: it does if you want any of the type-state-like behavior most people are after with linear types
18:29:35 <Cale> JakeE: Exercise infinite wisdom
18:29:38 <jmcarthur> afaik
18:30:09 <Cale> jmcarthur: Okay, maybe I don't understand what people want out of uniqueness types
18:30:24 <mm_freak> hmm
18:30:33 <JakeE> Cale: so just try stuff and see what works best?
18:31:02 <Cale> JakeE: Yeah, and sometimes it requires you to change your algorithm to expose more of the inherent parallelism
18:31:07 <mm_freak> Cale: a state monad would work, but that makes things ugly in other ways
18:32:17 <mm_freak> well, for now i'll just follow a strict naming convention
18:32:18 <Cale> mm_freak: Having to explicitly pass around things which can only be used in one place regardless in a chain one after the other can also become painful
18:32:20 <rdevilla> How does one use `cabal repl`?
18:32:36 <rdevilla> I keep getting "cabal: no cabal file found"
18:32:40 <jmcarthur> Cale: for example, a state monad is great for tracking a state whose type never changes, but what if you want to, for example, restrict access to the state (or just some piece of it) after it transitions to some closed-like state? with a plain state monad, you just have to resort to using Maybe for that bit, and there is nothing guaranteeing that it will always be Just until it transitions after which it
18:32:42 <jmcarthur> will always be Nothing
18:32:55 <Cale> jmcarthur: well, sure
18:33:19 <Cale> jmcarthur: I guess when I think of uniqueness types, I mainly think about how Clean did (does?) I/O.
18:33:38 <jmcarthur> still does, as far as i know
18:33:42 <Cale> With a token that you're passing around and which doesn't really consist of anything
18:33:46 <jmcarthur> right
18:33:53 <jmcarthur> that's a pretty specific use case, though
18:33:57 <Cale> yeah
18:34:20 <jmcarthur> it just happens that IO solves the same problem in a different way
18:34:26 <Cale> So yeah, I suppose indexed monads
18:35:03 <mm_freak> i'm mainly interested in these types, because they can prevent major disasters with reusing IO actions and such
18:35:11 <Cale> btw, I realised the other day that indexed monads should really be indexed by the arrows of an arbitrary category, and join should compose composable arrows
18:35:42 <mm_freak> of course saving a bunch of allocations would be a nice side effect
18:35:47 <Cale> There was a paper on indexed comonads, but instead of being indexed by pairs of types, they were indexed by elements of a monoid
18:36:02 <edwardk> dominic orchard
18:36:34 <edwardk> we've talked about it. his is an interesting approach. if you generalize it to take a category rather than a monoid you get the existing indexed comonad iirc.
18:37:19 <Cale> er, what do you mean "existing"?
18:38:56 <Cale> The one that I'm aware of in Haskell has a pair of types as the index, but what I'm suggesting is to index them over all the arrows of a given category, i.e. you don't just have the domain and codomain, but also a chosen arrow from one to the other sitting in the type parameter
18:39:03 <jmcarthur> Cale: you mean an arbitrary category instead of   forall i. a i -> b i   ?
18:39:25 <Cale> It kinda requires dependent types, what I'm suggesting
18:39:55 <jmcarthur> note that the 'i' can at least be poly kinded
18:40:07 <Cale> This degenerates into the case of indexing by the elements of a monoid when the category has one object
18:40:30 <Cale> and it turns into the two-type-indices case when the category is the indiscrete category on some set of types
18:42:48 <jmcarthur> at this point i'm totally lost. which kind of indexed monad are you building off of / constrasting with?
18:43:05 <jmcarthur> *contrasting
18:44:00 <Cale> Okay, so there's the kind where you fix some monoid S, and you have  M : S -> Type -> Type
18:44:44 <Cale> and your  return : a -> M e a, where e is the identity of the monoid
18:44:51 <silasm> :t foldMap
18:44:52 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
18:44:58 <silasm> :t flip . foldMap
18:44:59 <lambdabot> (Foldable t, Monoid c) => (a -> b -> c) -> b -> t a -> c
18:45:00 <jmcarthur> ah, right
18:45:02 <Cale> and join : M a (M b t) -> M (a * b) t
18:45:08 <silasm> ^ how does that make sense?
18:45:37 <jmcarthur> yes, i follow
18:45:44 <Cale> and then there's the type which we can actually do sanely in Haskell with just two type parameters
18:45:58 <Cale> So, you can form a simultaneous generalisation of both of those
18:46:11 <silasm> shouldn't (flip . foldMap) be :: t a -> (a -> m) -> m ?
18:46:13 <Cale> Where the indices are the *arrows* of a category
18:46:38 <scott_> silasm: Are you thinking of flip foldMap?
18:46:40 <Cale> and return is (more) polymorphic, it produces something indexed by whichever identity arrow you want
18:46:49 <scott_> :t flip foldMap
18:46:50 <lambdabot> (Foldable t, Monoid c) => t a -> (a -> c) -> c
18:46:52 <silasm> scott_: derp.
18:46:54 <silasm> thanks
18:46:55 <copumpkin> Cale: we should just use that everywhere
18:46:59 <Cale> and join composes arrows which have to line up
18:47:35 <jmcarthur> to make sure i understand, this is still not the same thing as McBride's?
18:47:39 <Cale> copumpkin: What, index *everything* by the arrows of an arbitrary category? :)
18:47:49 <copumpkin> jmcarthur: not as I remember it
18:47:50 <Cale> Which one is McBride's?
18:47:55 <copumpkin> the single-index one
18:48:09 <copumpkin> Cale: nah, just replace our lame monads
18:48:11 <copumpkin> :D
18:48:35 <roboguy_> skypers: I'm not sure I understand Carmack's response, unless he deleted the code...
18:49:30 <roboguy_> which would be a bit of a waste
18:50:04 <jmcarthur> Cale: IMonad :: ((k -> *) -> (k -> *)) -> Constraint
18:50:07 <Cale> Oh, yeah, those are a little different
18:51:57 <Cale> Though I guess with sufficiently interesting kinds, it's the same :)
18:52:25 <Cale> Well, hmm
18:52:36 <acowley> Cale: What does this more expressive indexing buy you?
18:52:41 <acowley> roboguy_: link?
18:53:25 <copumpkin> acowley: I can write both Vec Monads for example
18:54:14 <acowley> Sorry, I'm being dens: which both?
18:54:25 <copumpkin> the ziplist-like monad
18:54:29 <copumpkin> and the list like one
18:54:32 <Hasjoy> Hi all.
18:54:36 <acowley> Oh
18:54:40 <Cale> It also gets rather interesting in the case of comonads
18:54:54 <copumpkin> so if you think of Vec n a = Fin n -> a
18:54:58 <acowley> What are the two arrows for those cases?
18:55:00 <acowley> yeah
18:55:05 <roboguy_> acowley: https://twitter.com/skypers_/status/425771008532824064
18:55:07 <acowley> Hi Hasjoy
18:55:08 <copumpkin> then the ziplist-like monad is like reader and takes the diagonal
18:55:12 <Cale> because your coreturn is only required to be able to pull out a result when the index is the identity
18:55:30 <Cale> So your indexed comonad doesn't have to be pure at other indices
18:55:48 <copumpkin> acowley: the list-like one is the natural multiplication monoid with a dummy object, naturals as arrows, and multiplication as composition
18:56:07 <copumpkin> acowley: the other one is constant
18:56:34 <acowley> I see, thanks
18:56:48 <acowley> okay, I'm sold
18:56:52 <acowley> Cale: make it happen
18:57:30 * hackagebot purescript 0.3.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.1 (PhilFreeman)
18:58:22 <Hasjoy> I am trying to build an email-centric application. The specifications I need are : a) Run on a webserver; b) import xml data from another domain name ; c) send mail based on certain rule sets  d;) track emails sent out addressing the xml import data; and e) present everything in a neat UI on the webpage with customer login. Is this something Haskell can do? I am new to Haskell and need to get
18:58:22 <Hasjoy> this working so I am exploring diving into Hasell and doing it the hard way. Any suggestions or other languages I might try isntead of haskell?
18:58:28 <Hasjoy> Hello acowley.
18:58:50 <Hasjoy> */s/domain name/domain
18:59:08 <levi> Hasjoy: Yes, haskell can do that!
18:59:35 <levi> Or, rather, you can do it with haskell, once you learn enough of it to write the program.
18:59:56 <Twey> Cale, copumpkin: heatsink had a question earlier that one of you can probably answer better than I: what do covariant functors and covariant types in subtyping (e.g. Java's arrays) have in common?
19:00:01 <eazar001> @faq
19:00:01 <lambdabot> The answer is: Yes! Haskell can do that.
19:00:07 <Hasjoy> hmmz levi any pitfalls I need to be aware of?
19:00:52 <copumpkin> Twey: same producer/consumer notion works, and covariant types support map, contravariant support contramap
19:00:58 <Twey> Hasjoy: Haskell is a general-purpose language.  It can do anything you'd expect of any other programming language.  It can probably even do it the same way as you'd do it in another language, though it generally has better alternatives.
19:01:25 <Cale> Twey: covariant type constructors are (covariant) endofunctors on the preorder category of types under the subtype relation
19:01:32 <Twey> Aha!
19:01:42 <Twey> I knew there was *some* category where that was true.  Thanks.
19:01:47 <Hasjoy> Twey yes but I am wondering if the pretty UI will be possible with Haskell. Maybe that depends on my html/css skills.
19:02:15 <levi> Hasjoy: Probably there are a lot of pitfalls, but I'm not sure which ones in particular you might run into. There's nothing insurmountable, though. People write things like that in haskell frequently.
19:02:41 <Twey> Hasjoy: Largely, yes.  Haskell has some nice tools to help you in that area, like Fay, or Yesod's Web DSLs, but it won't design a Web page for you.  :þ
19:04:00 <Hasjoy> Twey: True, just don't want to spend tons of time on the backend and get to the UI and realize I need to do something else, since the users will be less than techies.
19:04:28 <Cale> Hasjoy: There's not a whole lot of *frontend* web stuff in Haskell. The chances are good that unless you're okay with using very-experimental projects you might actually have to write some Javascript still.
19:04:32 <Hasjoy> Any suggestions on pharsing xml? I suppose that's something Haskell should be adept at.
19:04:49 <Cale> You can of course generate HTML and such
19:05:04 <Platz> I'm confused why someone would use Fay over writing javscript directly
19:05:15 <roboguy_> Platz: probably static typing, etc
19:05:17 <Cale> But the stuff for compiling Haskell code so that it runs in the web browser is still pretty embryonic
19:05:20 <Twey> Platz: It has types, nicer syntax, and FRP
19:05:26 <erisco> try writing Javascript for a bit and you'll figure it out
19:05:32 <Twey> Heh
19:05:34 <Platz> true, those are good
19:05:38 <Hasjoy> Cale Na I will run it on a linux server. So I figured that will work.
19:05:44 <Cale> Platz: Being able to reuse your backend datatypes for your frontend and not have to explicitly JSON encode/decode
19:05:58 <Twey> Platz: FRP is especially good when it comes to Web frontends
19:06:09 <Cale> and yeah, types, lol
19:06:10 <Twey> There's some FRP stuff in JS, but it's just not the same.  ☺
19:06:17 <roboguy_> I imagine stuff like Fay will get there someday though. it always looked like there's good progress being made
19:06:19 <bergey> Hasjoy: xml-conduit is my current favorite.  There are several good alternatives.
19:06:28 <greymalkin> Should hlint be cabal-installable?
19:06:29 <Twey> roboguy_: I imagine/hope it will merge with GHCJS
19:06:40 <mm_freak> the closest to real FRP i've seen in javascript is flapjax and bacon.js
19:06:54 <Hasjoy> bergey: Thanks, will keep that in mind.
19:06:58 <roboguy_> I should probably actually try FRP some time...
19:07:04 <mm_freak> and both are awkward to work with, mainly because it's javascript
19:07:13 <Twey> Right
19:07:17 <Hasjoy> If I link up cron with Haskell are there any problems with em the purity of the language itself?
19:07:27 <Hasjoy> Or is that something I need to worry about later on?
19:07:31 <mm_freak> although bacon tries really hard to provide a halfway usable interface
19:07:38 <Cale> Hasjoy: that question doesn't make sense :)
19:07:57 <Cale> Hasjoy: after you compile them, Haskell programs are no different from any other programs on your system
19:07:59 <roboguy_> Hasjoy: haskell can interact with IO and the outside world just like any other useful language
19:08:00 <Twey> FRP is a complex abstraction, and unityped languages don't handle complex abstractions all that well
19:08:16 <mm_freak> Twey: FRP isn't really that complex
19:08:39 <Twey> mm_freak: It has types that have to line up
19:08:48 <Hasjoy> Cale: Well my appologies, I am new to Haskell and what I know of Haskell being pure and the I/O being where all that gets affected is sort of why I aksed the question.
19:08:48 <roboguy_> it is based around sequencing Time -> ... functions, right?
19:09:07 <Cale> Hasjoy: the stuff about purity / referential transparency and such is referring to the evaluation of expressions in the language. There's still a way to describe in Haskell what input and output should occur, and what effects should happen. It's just not through the evaluation of expressions into values.
19:09:08 <mm_freak> Twey: everything has types that have to line up…  javascript uniformly pretends that's not the case
19:09:15 <roboguy_> Hasjoy: Haskell can do IO just like any other language, it's just a little different
19:09:16 <dolio> Twey: Just don't put the wrong thing in the wrong spot. :)
19:10:09 <Hasjoy> Sounds like a fun way to do things until I get caught up in Haskell noob land :)
19:10:13 <Twey> mm_freak: There's an (IMO) fairly compelling correspondence between the power of a language's type system and the complexity of abstractions that are commonly used in that language.  Untyped languages mostly don't even get to the ‘zipper’ level, with the exception of Clojure, and FRP is a good bit more complicated than zippers.
19:10:33 <Cale> Hasjoy: instead, we have values (of type IO t, for some type t) whose purpose is to describe something which could be done (and includes anything your computer can do) to produce a value of type t.
19:10:48 <frege> I love A gentle intro to haskell, don't know why ppl hate it so much
19:10:51 <Twey> roboguy_: No, not really
19:11:01 <mm_freak> Twey: generally i agree with you, but FRP isn't really so complicated that you couldn't sensibly do it in javascript (the two implementations i mentioned prove this)
19:11:06 <Cale> Hasjoy: Your 'main' in a compiled program will be one of these IO actions, as they're called
19:11:23 <mm_freak> you will not find yourself using free monads in javascript, but FRP is really practical
19:11:26 <Twey> roboguy_: I mean, yes, sort of, but for sufficiently abstract definitions of ‘time’ and often ‘functions’ as to make it almost meaningless :þ
19:11:27 <erisco> Twey, what is a zipper?
19:11:44 <Twey> mm_freak: You certainly *can* do it, but I think it's less likely to catch on
19:11:47 <roboguy_> Twey: that's pretty much what I'd expect
19:11:59 <roboguy_> Twey: what would you say is a good library to get started with?
19:12:12 <frege> are recursive types being used frequently in haskell code?
19:12:15 <Twey> erisco: A zipper is a data structure that encodes the concept of a ‘focal point’ or ‘current position’ in another data structure
19:12:15 <mm_freak> Twey: i'm using bacon.js in production code =)
19:12:21 <mm_freak> frege: all the time
19:12:29 <frege> it's elegant
19:12:41 <frege> is there any other language that has it?
19:12:46 <Twey> mm_freak: You're only one data point, I'm afraid :þ
19:12:49 <Cale> Hasjoy: *evaluating* main, i.e. turning it from an expression tree into some value (which you can't really inspect anyway since IO is an abstract type) doesn't cause anything visible to occur, except maybe your computer gets a little warm
19:13:01 <dolio> I wonder what Netflix's FRP system is in.
19:13:03 <erisco> Twey, oh okay. any reason to have this vs toList?
19:13:07 <Cale> Hasjoy: But main itself will also be executed, i.e. it will describe some stuff to do, and that stuff will be done.
19:13:09 <mm_freak> Twey: i'm just saying it's possible and practical, and you shouldn't care too much what others do =)
19:13:11 <dolio> I can't actually remember.
19:13:17 <Twey> roboguy_: I like reactive-banana; I've found it the least cluttered of the libraries I've worked with so far
19:13:20 <Twey> mm_freak: *nod* Absoluteyl
19:13:22 <Twey> Absolutely**
19:13:42 <Hasjoy> Thanks for all the inputs everyone: acowley; eacameron; levi; Twey; Cale; erisco; roboguy_; bergey; and mm_freak. I hope I got everyone.
19:13:45 <frege> I wished the pace of this channel was a bit slower
19:13:45 <mm_freak> Twey: sodium has less clutter, but i still prefer reactive-banana over sodium
19:13:48 <dolio> I suspect it might also be javascript, or similar.
19:13:51 <Twey> roboguy_: But to be fair, I've only really done anything with reactive-banana; I've only looked at the others
19:13:51 <dolio> And not have types.
19:14:05 <Twey> mm_freak: Why's that?
19:14:15 <Cale> I'm not sure I'm ready to recommend FRP to *beginners* yet
19:14:16 <mm_freak> Twey: because Moment is time-indexed
19:14:22 <Twey> Hasjoy: No problem; feel free to stick around and ask more questions.
19:14:32 <Hasjoy> Now the other question which was already answered, with a gentle introuction.
19:14:35 <mm_freak> Twey: this prevents some bad code
19:14:42 <Twey> mm_freak: Ah, right
19:14:46 <roboguy_> Twey: conduit and pipes aren't FRP right? they're something else?
19:14:46 <Hasjoy> What else is out there to tame this beast?
19:14:47 <levi> frege: Many languages allow recursive types.
19:14:48 <mm_freak> Twey: especially with respect to dynamic switching
19:14:58 <mm_freak> roboguy_: they aren't FRP
19:15:02 <Cale> Hasjoy: You're asking about where to find a tutorial?
19:15:02 <mm_freak> they are stream processing
19:15:06 <erisco> Twey, I was actually looking at something like this recently but concluded that it was no different than using toList
19:15:07 <frege> type Name               = String
19:15:07 <Cale> @where lyah
19:15:07 <lambdabot> http://www.learnyouahaskell.com/
19:15:08 <frege> data Address            = None | Addr String
19:15:12 <Cale> @where rwh
19:15:13 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
19:15:13 <Hasjoy> Cale yes.
19:15:17 <Twey> roboguy_: Right.  Theoretically speaking, we suspect they're closely related in some way we don't totally understand yet, but as it stands they're not the same thing.
19:15:19 <frege> what's the difference between type and data?
19:15:40 <Twey> erisco: Uhm, totally different, for any function I'd reasonably call ‘toList’
19:15:47 <Twey> erisco: Indeed, lists have zippers too
19:15:54 <levi> frege: Types describe some properties of data.
19:15:57 <roboguy_> frege: type is just a type synonym, sort of like a typedef in C if you're familiar with that
19:16:02 <Cale> frege: type Name = String defines Name as a *synonym* for String. The compiler might just, as the very first step, replace all occurrences of "Name" with "String" in types.
19:16:09 <roboguy_> frege: data defines a new type
19:16:11 <mm_freak> roboguy_: there are really only a handful of FRP libraries, and the two most popular are netwire and reactive-banana
19:16:12 <levi> frege: Or do you mean the keywords?
19:16:14 <erisco> Twey, what applications does this zipper have? I have seen it called a cursor before
19:16:24 <roboguy_> Twey: interesting
19:16:27 <frege> gotcha
19:16:28 <levi> Heh, of course you mean the keywords. Sorry.
19:16:30 <Twey> erisco: A zipper holds all the data and shape of the original type, but in addition supports a notion of ‘current position’ (with constant-time access)
19:16:37 <levi> frege: There's also 'newtype
19:16:41 <levi> 'newtype'
19:16:58 <erisco> Twey, that may be what it is, but I am asking what you'd use it for
19:17:00 <frege> isn't data making a new type?
19:17:22 <Twey> erisco: Oleg has a nice example where he uses a zipper to implement filesystems; basically, anything where you need to ‘move around’ in a data structure at runtime
19:17:26 <levi> frege: 'newtype' is a bit like 'type' and a bit like 'data'.
19:17:33 <Platz> i think it's odd that the reactive-extensions group has implemented rx for c#,js,java,scala,cpp,python but not haskell?  And erik meijer was one of the creators of rx, at that"
19:17:37 <Cale> data Address = None | Addr String -- this introduces three new things: a genuinely new datatype called Address, distinct from any others before it, along with a new value  None :: Address, and a function Addr :: String -> Address
19:17:44 <frege> levi: that was super vague
19:17:49 <Twey> erisco: The channel's busy: you'll have to pardon our messages not necessarily arriving in order :þ
19:17:50 <mm_freak> Platz: rx is not FRP
19:17:52 <erisco> Twey, does the zipper support both forward and reverse traversal?
19:17:56 <Twey> erisco: Yes
19:18:00 <Platz> hrmm
19:18:04 <levi> frege: It allows you to wrap a type in a wrapper that (mostly) disappears at runtime.
19:18:13 <mm_freak> Platz: it's RP without the F mostly =)
19:18:30 <frege> Cale: wow!
19:18:36 <Cale> frege: In addition, the values None and Addr are special in that they may occur in patterns when pattern matching, and values of type Address can be disassembled by matching on them
19:18:40 <Twey> erisco: (I also have a bad habit of not looking at the chat any more once I've started typing a reply)
19:18:42 <Platz> I'll buy that, yes
19:18:57 <erisco> Twey, hm. well I'll be on the look out for examples
19:19:06 <jrmithdobbs> Platz: what is rx?
19:19:11 <frege> Cale: that's so much abstraction behind a line of code
19:19:15 <Hasjoy> Thanks, Cale. I will look into these tutorials.
19:19:24 <mm_freak> interestingly bacon.js is inspired by rx, but a subset of its interface is actual FRP
19:19:26 <Cale> frege: That is, you can write  foo None = "No address provided"; foo (Addr s) = "Address is " ++ s
19:19:41 <Cale> frege: to define a function foo :: Address -> String
19:19:42 <mm_freak> jrmithdobbs: Reactive eXtensions for .NET
19:19:56 <levi> frege: You can only instantiate a type class once for any given type. And you can't use a type alias (created with the 'type' keyword) to create a type class instance. So you can use a 'newtype' to create instances of type classes at the same base type with different implementations.
19:20:00 <jrmithdobbs> mm_freak: they should be shot for choosing that name
19:20:07 <erisco> Twey, the problem I had when I was exploring something similar is that the concept of the zipper was isomorphic to lists. ie I could just call toList and work with the data that way
19:20:08 <mm_freak> jrmithdobbs: the name is fine
19:20:19 <erisco> Twey, so I ultimately did not see the point in bothering with an abstraction
19:20:27 <jrmithdobbs> mm_freak: "rx" means prescription to everyone on the planet, including search engines, so no, it's not
19:20:32 <Twey> erisco: http://lambda-the-ultimate.org/node/1036 http://learnyouahaskell.com/zippers http://okmij.org/ftp/continuations/zipper.html
19:20:42 <eacameron> Hasjoy: I don't think I was part of anything thankworthy. I pass the credit on to whomever it is due. :)
19:20:45 <Twey> erisco: It isn't at all isomorphic to a list
19:20:52 <frege> levi: sorry the angle that you are describing things from doesn't work for me; I can't understand it
19:21:04 <mm_freak> jrmithdobbs: by that standard, C should be banned =)
19:21:25 <levi> frege: You probably don't need to worry about newtype just yet. Just remember that it's there.
19:21:43 <Hasjoy> eacameron: I am sure if I trouble you enough in here you will help me again. :)
19:21:50 <Twey> erisco: A list flattens all the shape out of the structure, which a zipper doesn't do; also, a list (by itself) doesn't give you direct access to the current element, or allow for traversal in reverse
19:21:54 <Cale> frege: It's worth noting that data declarations can be recursive, and may have type parameters
19:22:05 <jrmithdobbs> mm_freak: C can be fixed by (<> " language") for searching, and this phenomenon did not exist when that name was chosen
19:22:10 <roboguy_> frege: basically, newtype is an efficiency thing (that's a slight simplification but it's okay for now. you should understand data first)
19:22:18 <Cale> frege: So, for instance, to define a type of binary trees whose internal nodes are labelled with values of type a
19:22:31 <Cale> frege: data Tree a = Tip | Branch a (Tree a) (Tree a)
19:22:39 <erisco> Twey, oh I see, so you can navigate a tree by selecting branches
19:22:45 <Platz> jrmithdobbs: it creates types of Observable and Observer which are the duals of Enumerable and Enumerator and some rich API's on top of those types for composing async & event-based expressoins
19:23:14 <jrmithdobbs> oh that's reactor not frp
19:23:14 <mm_freak> jrmithdobbs: the search engine needs special handling to make (<> " language") work…  for example google does that a little better than duckduckgo
19:23:22 <Cale> This introduces a parametric type Tree, which takes a type parameter, along with  Tip :: Tree a, and  Branch :: a -> Tree a -> Tree a -> Tree a
19:23:34 <levi> I read through the 2-3 finger tree paper today with the "polymorphic recursive" types.
19:23:43 <mm_freak> anyway, there is Reactive Programming, which is loosely related to Functional Reactive Programming…  RX is the former
19:23:44 <Twey> erisco: For example, the zipper for a list is a pair of lists, ([a], [a]): the second one holds the rest of the list from the current context, and the first holds the list leading up to the current context (reversed).  So the current context is (head . snd), and if you want to go back a step it's just (\((p : past), future) → (past, p : future))
19:23:45 <Cale> For instance,  Branch 1 (Branch 2 Tip Tip) (Branch 3 Tip Tip) :: Tree Integer
19:24:02 <erisco> Twey, yeah I get that
19:24:15 <erisco> Twey, I was interpreting "keeps the original structure in tact" much differently
19:24:25 <jrmithdobbs> mm_freak: it's a dumb name that is undescriptive and unintelligible or researchable without first know it's context simple due to it's name
19:24:29 <frege> Cale: right..
19:24:32 <jrmithdobbs> mm_freak: really don't know how you can defend it
19:24:43 <Cale> Branch "hello" (Branch "there" Tip Tip) (Branch "world" Tip (Branch "!" Tip Tip)) :: Tree String
19:24:49 <Twey> erisco: Ah.  I just meant there's a function from the zipper to the structure it represents, forgetting the position information.
19:24:51 <levi> jrmithdobbs: I'm not sure why you're wasting so much effort attacking it?
19:24:57 <frege> Cale: what's the "= Tip" part about?
19:25:07 <Cale> oh, right
19:25:15 <mm_freak> jrmithdobbs: well, i'm defending "Reactive eXtensions", because i assumed that you were complaining about the "reactive" part, not about the abbreviation
19:25:21 <Cale> Well, the other example had two cases as well
19:25:42 <Cale> After the = sign in a data declaration, there's a '|'-separated list of cases
19:25:44 <jrmithdobbs> mm_freak: no, I'm adverse to "rx" (or, how it will always be referenced in conversation)
19:26:03 <erisco> Twey, zipper from traversable looks very interesting
19:26:13 <frege> Cale: but what's = sign for?
19:26:17 <Cale> Each of which consists of a name starting with an uppercase letter for a new data constructor being introduced, followed by a whitespace separated list of types
19:26:24 <Clint> is there a type for annotating things?
19:26:29 <ddere> greymalkin: it is, i think
19:26:36 <roboguy_> Clint: annotating in what sense?
19:26:43 <Cale> frege: To the left of the = sign is the name of the datatype we're defining, and its type parameters
19:26:46 <greymalkin> Huh... it's failing to build for me
19:26:51 <jrmithdobbs> mm_freak: ReactiveX is a better name but i'm sure they don't want to add activex connotations to anything ;p
19:27:06 <Cale> frege: It's meant to look a bit like BNF notation for grammars, if you've ever seen that
19:27:06 <Clint> roboguy_: like "this is bad, for this reason"
19:27:13 <mm_freak> jrmithdobbs: well, i'm sure you have referred to "functional programming" as FP ;)
19:27:15 <ddere> greymalkin: ah lemme give it a try
19:27:16 <greymalkin> ... or at least "happy" is failing to compile
19:27:21 <frege> no I haven't Cale
19:27:31 <Platz> according to wikipedia: "(FRP) is a programming paradigm for reactive programming"
19:27:33 <frege> Cale: what does BNF stand for?
19:27:35 <roboguy_> Clint: well, that could mean a lot of things... can you give me a more specific example?
19:27:41 <Cale> Backus-Naur Form
19:27:43 <ddere> graymalkin: ah, did you install alex and happy separately first?
19:27:44 <jrmithdobbs> mm_freak: i don't
19:27:57 <Cale> It's just a particular way of writing out the grammar of languages, don't worry about it if you haven't seen it
19:28:00 <roboguy_> Clint: do you mean a type level annotation?
19:28:04 <jrmithdobbs> mm_freak: because its ambiguous with floating point even *in* context
19:28:18 <Cale> frege: Using some language extensions, we could equivalently express this data declaration like this, which some people find easier to grasp:
19:28:22 <Clint> roboguy_: no, i want something like Either (e,a) a or Something (Maybe e) a
19:28:23 <frege> Cale: is it something consistent for haskell syntax? I'm interested to learn it if it's useful
19:28:26 <Cale> data Tree a where
19:28:33 <Cale>   Tip :: Tree a
19:28:43 <Cale>   Branch :: a -> Tree a -> Tree a -> Tree a
19:28:53 <roboguy_> Clint: "Either e a" wouldn't work?
19:29:06 <Clint> roboguy_: i need to preserve the a in either case
19:29:18 <frege> Cale: why are they three? "a -> Tree a -> Tree a -> Tree a"
19:29:27 <frege> Cale: shouldn't it be two if it's a binary tree?
19:29:28 <mm_freak> Platz: i don't really like the wikipedia article for FRP
19:29:34 <Cale> Branch takes a value of type a, and two subtrees, and makes a tree
19:29:49 <roboguy_> Clint: I don't know if there's an official type. It would probably be isomorphic to (Maybe e, a)
19:29:59 <fistfulofmonads> is there a REPL-like library for your own EDSL's?
19:30:03 <Cale> frege: right?
19:30:04 <levi> frege: The bit after the last arrow is the return type; the previous ones are argument types.
19:30:07 <frege> Cale: ahh gotcha
19:30:09 <Clint> roboguy_: okay, i guess i'll use that, thanks
19:30:27 <frege> Cale: it's just weird the way haskell shows the input output of a function with those arrows
19:30:39 <Cale> Well, that's the relaxed way to read it
19:30:43 <frege> levi: so everything before the last arrow is the input?
19:30:44 <Platz> mm_freak: i agree it's not very informative
19:30:55 <Iceland_jack> frege: You can think of it like that, yes
19:30:57 <mm_freak> Platz: FRP has been tortured into many forms, and almost all of them ignore the formal advantages of its original formulation
19:31:08 <mm_freak> Platz: in particular that "discrete time" nonsense
19:31:11 <Cale> frege: Whenever you see f :: A -> B -> C -> D  in Haskell, it really means  f :: A -> (B -> (C -> D))
19:31:20 <roboguy_> frege: more or less, yeah. the reason it's written this way is because it is "curried", but you might not need to worry about that now
19:31:25 <roboguy_> there is a reason it's written that way though
19:31:27 <Cale> i.e. f is a function which takes a value of type A, and produces a function B -> (C -> D)
19:31:29 <frege> Cale: right because it becomes many curried functions
19:31:34 <Cale> yeah
19:31:42 <Twey> mm_freak: Nobody actually goes for discrete time, do they?  Most of the implementations I've seen have been trying to get to continuous time, with varying levels of success :þ
19:31:47 <greymalkin> ddere: Nevermind -- I think I found out why the versions seem mismatched... I just found the --upgrade-dependencies option for the first time..
19:31:48 <Cale> and whenever you see  f x y z  it really means  ((f x) y) z
19:31:54 <frege> roboguy_: I actually needed to know that; now it makes sense
19:31:57 <erisco> Twey, I go for no time :P
19:32:09 <levi> Twey: I believe elm uses discrete time.
19:32:16 <roboguy_> Twey: it's not really possible to have actual continuous time in a program though...
19:32:21 <ddere> greymalkin: ah cool ok :)
19:32:32 <mm_freak> Twey: you need a discrete interface for "reactimating", but the actual system should use continuous time semantics
19:32:40 <mm_freak> reactive-banana, sodium and netwire follow this rule
19:32:41 <greymalkin> although happy still doesn't seem to be the right version; I'm not sure what I'm doing wrong.
19:32:43 <erisco> roboguy_, the semantics can be such that you would not be able to distinguish discrete from continuous, however
19:32:53 <mm_freak> in JS flapjax follows the rule
19:32:57 <erisco> roboguy_, so you can treat the value as continuous even though, yes, ultimately it is discrete
19:32:58 <Cale> frege: But of course you can always think of a function A -> B -> C -> D as just being a function of three parameters of types A, B, and C, which produces a result of type D
19:33:01 <Platz> mm_freak: it seems like the person who wrote that article was trying to simulate electrical circuits or something
19:33:05 <frege> Cale: so in "f :: A -> B -> C -> D  in Haskell, it really means  f :: A -> (B -> (C -> D))"   C has the input D, B has the input (the output of C), and A has the output of B?
19:33:18 <Twey> mm_freak: bacon.js doesn't?
19:33:19 <Cale> no
19:33:22 <mm_freak> Platz: yes, that mistake is common (and i've made it myself as an FRP beginner)
19:33:24 <mm_freak> Twey: no
19:33:27 <frege> oh the other way around Cale ?
19:33:30 <Twey> How unfortunate
19:33:31 <Cale> The input to f has type A
19:33:38 <Cale> and then the input to its result has type B
19:33:39 <greymalkin> Yeah... I can't see the problem ... it wants happy > 1.17 and I just did a --force on 1.19.3 and haskell-src-exts still complains
19:33:46 <Cale> and then the input to the result of that has type C
19:33:48 <mm_freak> Twey: a subset of bacon.js' interface is proper FRP, but you need to be very careful
19:33:52 <Cale> and finally the result has type D
19:34:25 <Cale> f :: A -> B  means that f accepts an argument of type A, and produces a result of type B
19:34:29 <mm_freak> Twey: FWIW i prefer bacon.js over flapjax, because it has been tested with a lot more browsers
19:34:42 <frege> Cale: okay I'm trying to wrap my head around this; it's partial so I get what you mean now by 'the input to its result'
19:34:42 <mm_freak> but flapjax feels safer
19:35:16 <levi> Flapjax was done by some PLT Scheme guys, IIRC.
19:35:29 <Cale> f :: A -> (B -> C) means that f accepts an argument of type A, and produces a result which is a (function which accepts an argument of type B, and produces a result of type C)
19:35:51 <BMeph> mm_freak: Heh-heh, that's cute - like you need a reason to prefer something named "bacon"... ;þ
19:36:05 <mm_freak> BMeph: =P
19:36:11 <Hasjoy> What database is recommended for Haskell and any tools I should keep in mind?
19:36:20 <erisco> a vegetarian Muslim may need convincing BMeph :)
19:36:39 <Cale> Hasjoy: Whatever you like, pretty much, there are bindings to most things I'm aware of at least.
19:36:49 <Cale> Hasjoy: Maybe Postgres?
19:36:54 <mm_freak> Hasjoy: the common choice is between acid-state and postgresql-simple, but you can really use any database you like
19:36:56 <jrmithdobbs> Hasjoy: Nothing
19:36:57 <Hasjoy> I was thinking the same.
19:37:12 <BMeph> erisco: A vegetarian Muslim needed convincing to be a vegetarian Muslim. ;þ
19:37:13 <jrmithdobbs> Hasjoy: but that's my recomendation for any language re: rdbms
19:37:24 <jrmithdobbs> Hasjoy: it's just a funny pun for haskell as a bonus
19:37:55 <erisco> BMeph, yeah I guess you wouldn't have to worry about that
19:37:59 <Hasjoy> jrmithdobbs: Em, it plays nice and not so nice with everything? :)
19:38:11 <mm_freak> Hasjoy: acid-state adds ACID to your haskell types…  it's very nice and very safe, but it has some disadvantages compared to the more common RDBMSes
19:38:16 <jrmithdobbs> Hasjoy: no, rdbmses suck
19:38:26 <mm_freak> jrmithdobbs: why?
19:38:42 <Hasjoy> jrmithdobbs: So what do you use then?
19:38:46 <jrmithdobbs> mm_freak: i'll rephrase, they suck for something like >80% of uses they're abused for
19:38:59 <Hasjoy> mm_burea1 What are the disadvantages?
19:38:59 <mm_freak> jrmithdobbs: i actually agree about that
19:39:29 <mm_freak> but they don't suck, their users often suck =)
19:39:42 <mm_freak> Hasjoy: acid-state keeps your state (your "database") in memory
19:39:53 <Cale> (They also suck, just because SQL does, in various ways)
19:39:54 <BMeph> erisco: Yeah, instead, I'll worry about the persuasive powers of whoever convinced that Muslim to go vegetarian! ;þ
19:39:58 <mm_freak> Hasjoy: this is usually an advantage, but can turn into a disadvantages, when your state becomes larger than your RAM
19:40:06 <jrmithdobbs> well, some of them also straight up suck for other reasons, but yes in general they're actually very well implemented pieces of software
19:40:16 <jrmithdobbs> they just solve a problem that most people aren't trying to ;p
19:40:40 <mm_freak> jrmithdobbs: i think what you're really saying is:  mysql sucks and 100% of all mysql-using applications suck
19:40:43 <mm_freak> and i agree =)
19:41:07 <levi> In a world where languages like PHP exist, SQL is pretty far down on my totem pole of hate.
19:41:11 <jrmithdobbs> mm_freak: no i think the monolithic backing database concept sucks as well, i though I agree with that specific statement as well (who doesn't)
19:41:20 <jrmithdobbs> mm_freak: most problems don't actually involve relational data
19:41:33 <Cale> Ever want to have a column in a table whose type would naturally be Either (foreign key to table A) (foreign key to table B)?
19:41:40 <dolio> I wrote a mysql-using application once. I don't think it sucked.
19:41:43 <mm_freak> jrmithdobbs: no problem involves relational data…  it's a generic representation language
19:41:47 <copumpkin> I NEED MY SUM TYPES
19:41:49 <dolio> I think it was mysql....
19:41:52 <jrmithdobbs> mm_freak: but rdbmses are such old/mature/fast pieces of software that they're good enough for shared state on things that have no relational data
19:42:06 <dolio> Well, I mean, it sucked.
19:42:09 <Cale> The amount of stupid crap which goes on in databases because there's not even basic sum types is ridiculous.
19:42:13 <dolio> But it wasn't really my fault.
19:42:30 <Platz> about acid-state: "Unplug your machine .. recover to where it left off", how to reconcile this with "does not write your data types to disk every time you change it" ?
19:42:30 <copumpkin> Cale: nullable columns is all you need
19:42:31 <dolio> And i think an rdbms was appropriate.
19:42:43 <mm_freak> Platz: it does
19:42:44 <Cale> copumpkin: 1 + A + B + AB = A + B, right?
19:42:47 <copumpkin> yeah!
19:42:52 <copumpkin> hey, A + B is in there
19:42:56 <copumpkin> just ignore the 1 + AB
19:42:57 <Platz> ahh, well thats good then
19:43:12 <dolio> AB = -1.
19:43:20 <copumpkin> omg dolio has it all figured out
19:43:24 <dolio> I saw it on a bridge.
19:43:31 <copumpkin> genius
19:44:06 <jrmithdobbs> Cale: i've not actually used sql much since i've gotten a firmer grasp on ADTs ... but I think you're right, that really is where a lot of the complexity comes from
19:44:38 <Platz> the homepage for acid-state is a bit sparse
19:44:49 <Cale> jrmithdobbs: The next thing after that would be: try implementing a tree datastructure which isn't allowed to have cycles in it and must remain connected
19:44:50 <jrmithdobbs> Platz: welcome te haskell
19:44:51 <mm_freak> NULL, NULL, NULL, NULL, NULL, 15, NULL, NULL, 'blah', NULL, …
19:45:07 <mm_freak> who could possibly hate that?
19:45:28 <mm_freak> Platz: read the happstack tutorial…  it explains acid-state very well
19:45:45 <jrmithdobbs> Platz: and welcome to haskell, where none of the docs are where you think they should be
19:45:48 <jrmithdobbs> ;p
19:45:57 <stepkut> http://happstack.com/docs/crashcourse/index.html#acid-state
19:46:18 <copumpkin> Cale: nested sets!
19:46:20 <Cale> jrmithdobbs: In my day, the documentation consisted solely of type signatures, AND WE LIKED IT THAT WAY
19:46:48 <mm_freak> Cale: back then trifecta didn't exist
19:47:10 <jrmithdobbs> Cale: i almost went on that rant the other day at work except s/type signatures/poorly maintained man pages/
19:47:13 <Hasjoy> mm_freak: I understand so it's not very scalable. That is bad in my book.. I want this to be pretty scalable.
19:47:20 <Cale> http://www.haskell.org/ghc/docs/6.2.2/html/libraries/base/Data.Set.html
19:47:29 <jrmithdobbs> Cale: AND WE DIDN'T BOTHER PROCESSING THE ROFF
19:47:33 <dolio> Cale: You should make sure your schemas are fully normalized, too, and not use integer types for any non-key columns.
19:48:30 <mm_freak> Hasjoy: it is pretty scalable, just not for every application
19:49:01 <dolio> They have to be meaningless integer keys, too.
19:49:07 <Cale> actually, that's a little too modern, I think we should go back a little farther...
19:49:15 <dolio> Not actual data.
19:49:59 <mm_freak> Hasjoy: it depends on how much of your data is usually live…  after all you would increase your RAM size with growing databases, even if you use an RDBMS
19:50:02 <jrmithdobbs> or integers derived from hashes of the data
19:50:05 <jrmithdobbs> that is completely out of the question.
19:50:07 <Twey> dolio: Well, it stands to reason — IDs should never change, and if the ID has a meaning then it's information that the user might want to change
19:50:32 <Hasjoy> mm_freak: If this ever gets into a mode where I support third parties, I don't want to be increasing RAM as it grows.
19:50:50 <Cale> aw, I can't find the even older doc I'm thinking of
19:50:52 <Cale> anyway
19:51:08 <Cale> Yeah, a lot of the docs really were just type signatures :)
19:51:11 <levi> Hasjoy: Your operating system is probably pretty good at paging memory to disk.
19:51:56 <dolio> Twey: Yeah, might get a new SSN or something.
19:52:30 <Cale> http://www.haskell.org/ghc/docs/4.08.2/set/set.html -- yeah, here we go :)
19:52:33 <Twey> dolio: Happens
19:52:45 <mm_freak> Hasjoy: i'm happy to pay the price for better performance, better safety and a lot fewer lines of code =)
19:52:48 <Cale> http://www.haskell.org/ghc/docs/4.08.2/set/finitemap.html -- such map, so finite, very types
19:52:53 <jrmithdobbs> Cale: alot of them that don't happen to have associated tutorials still are ;p
19:52:54 <mm_freak> Hasjoy: you have a wrong measure for scalability
19:52:55 <dolio> That's why you have a table per-SSN, with a single foreign key column containing the formal key of that person in your database.
19:53:09 <jrmithdobbs> Cale: but the base stuff is all good ;p
19:53:47 <Hasjoy> mm_freak: Just worried it will cost too much with too few users, since the database will host a lot of PDF's and other documents as well.
19:54:13 <mm_freak> Hasjoy: you wouldn't store them in the database, would you?
19:54:14 <jrmithdobbs> speaking of people abusing RDBMSes
19:54:14 <Twey> Hasjoy: I think I see your problem
19:54:42 <mm_freak> Hasjoy: you would store PDFs in files and file paths in the database
19:54:44 <Hasjoy> Our current database is at 20gb. And no we don't store them in the database.
19:55:08 <stepkut> how much is 32GB of ram these days :p
19:55:31 <jrmithdobbs> stepkut: like 1000 or something
19:55:34 <Hasjoy> stepkut taht is just 4 users.
19:55:36 <erisco> why was singletonSet deprecated?
19:55:36 <mm_freak> Hasjoy: note that an RDBMS stores the data sparsely…  the data may very well fit in a lot less RAM by using a precise ADT
19:55:38 <Twey> stepkut: USD$160 on eBay
19:55:39 <Cale> I think 4.08.2 was the first version of GHC I ever installed. 5.0 happened before I really got to the point where I was really trying things out though.
19:55:42 <dolio> jrmithdobbs: Way less than that.
19:55:53 <jrmithdobbs> dolio: ecc
19:55:59 <Twey> http://www.ebay.com/itm/32GB-KIT-8X4GB-DELL-FBDIMM-PowerEdge-2950-1950-2950-1900-1955-R900-RAM-MEMORY-/141167233983
19:56:00 <dolio> Oh, maybe, then.
19:56:14 <jrmithdobbs> actually wait no that's 64
19:56:16 <jrmithdobbs> 500
19:56:16 <jrmithdobbs> ha
19:56:19 <dmwit> erisco: askin' the important questions =P
19:56:20 <levi> RAM is actually up lately.
19:56:40 <Twey> I wonder why that is
19:56:50 <Twey> erisco: For Set.singleton, I'd imagine?
19:57:06 <dmwit> Twey: No, for unitSet. Though presumably that was later deprecated in turn.
19:57:13 <Twey> Oh.  Obviously.
19:57:15 <dmwit> Twey: He's talking about http://www.haskell.org/ghc/docs/4.08.2/set/set.html
19:57:32 <Twey> Aye
19:57:41 <Twey> I just didn't know about unitSet
19:57:54 <dmwit> Well, it's in the comment that says singletonSet is deprecated...
19:57:55 <Twey> (… which isn't a unit for any operation I can think of)
19:58:22 <Platz> Software Engineering Radio, Episode 199: Dr. Michael Stonebraker declares traditional row-based rdbms "no longer optimal for any of the use cases that it is applied to".
19:58:29 <levi> There was some factory fire a while ago, and I think the manufacturers/resellers are riding the price bump for all it's worth.
19:58:30 <Twey> dmwit: Oh, sorry, I thought you were just referring to that version — I didn't look at the page :þ
19:58:38 <mm_freak> Hasjoy: it also gives you the opportunity to optimize for memory representation…  for example if you have a query-a-lot-but-change-only-very-little set, a sorted vector can make your memory representation very small and efficient
19:58:41 <Platz> being able to host the whole DB in memory has a lot do to with it
19:58:43 <Twey> levi: Ah
19:58:44 <Cale> cardinality     :: Set a -> Int
19:58:45 <Cale> :D
19:58:59 <levi> Kind of like the hard drive situation a while back.
19:59:09 <jrmithdobbs> Twey: i still don't see why unit is useful to begin with =/
19:59:34 <Cale> Also, in the FiniteMap module, all the names have FM on the end
19:59:36 <Twey> Cale: Ah, Roget's Method of avoiding name clashes
19:59:46 <Cale> but all you had to do to import it was
19:59:49 <Cale> import FiniteMap
19:59:54 <Cale> such luxury
20:00:20 <Twey> Cale: So you save characters on the import line, in exchange for characters everywhere else?  :þ
20:00:36 <Cale> Twey: you pay those characters everywhere else in any case
20:00:39 <Twey> (and better hope nobody comes up with another data structure with the initials ‘FM’…)
20:01:14 <Cale> Haskell already had qualified module imports
20:01:23 <Twey> Cale: Only in this case, because it happens to be short
20:01:24 <Cale> but people didn't try to force you to use them
20:01:44 <Twey> ‘singletonSet’ loses a character over S.singleton, for example
20:01:46 <erisco> did they have generic folds?
20:02:19 <Twey> Cale: But eventually they ran out of different (unpredictable, inconsistent) ways of saying ‘size’, so they gave up on that, I guess :þ
20:02:24 <enthropy> foldable is ghc-6.12 ish?
20:02:59 <erisco> what about just folds for lists?
20:03:09 <erisco> I am looking at unionManySets
20:03:31 <lingxiao> hey all, what can you do with this:
20:03:35 <lingxiao> https://gist.github.com/anonymous/b06bb5fa201e4a0bbc81
20:03:39 <lingxiao> other than check its kind?
20:03:44 <dmwit> It wouldn't surprise me to find out you can make a more efficient implementation of unionManySets than foldr union emptySet.
20:03:56 <lingxiao> for example, I can't construct the type False by typing "And True False" into ghci
20:04:02 <enthropy> nope, foldable is 6.6
20:04:28 <dmwit> lingxiao: Why not?
20:04:34 <dolio> Still newer than FiniteMap.
20:04:34 <Twey> lingxiao: You can typecheck things of type And True False against things of type False, and succeed
20:04:41 <dmwit> lingxiao: :kind! And True False
20:04:48 <Cale> Twey: well, cardinality for sets is pretty cute
20:05:04 <Twey> Cale: Granted, though I'm not sure it's worth the inconsistency
20:05:16 <Cale> (Though the fact that it's an Int is somehow even more hilarious when you use that word)
20:05:25 <Twey> Heheh
20:05:37 <lingxiao> dmit: ah didn't know that was a command
20:05:55 <lingxiao> so !kind evals a type level function
20:06:32 <lingxiao> I'm getting = 'False, which I should read as And True False evals to type False
20:06:34 <lingxiao> right
20:06:35 <lingxiao> ?
20:07:16 <dmwit> lingxiao: Even if you didn't know about :kind!, you could use :t Proxy :: Proxy (And False True)
20:07:23 <dmwit> lingxiao: right
20:08:11 <pavonia> Why does it evaluate the type instead of showing its kind?
20:08:17 <lingxiao> funny when I type in !kind And False False, which is not a covered case, it just gave me And False False back
20:08:21 <dmwit> pavonia: It does both.
20:08:36 <dmwit> lingxiao: Correct: And False False is a stuck term.
20:08:41 <dmwit> It does not evaluate any further.
20:08:46 <lingxiao> pavonia: I actually get:    And False True :: Bool = 'False
20:08:51 <lingxiao> so the kind and type are shown
20:09:15 <lingxiao> ah so I get the shortest string possible instead of some error message
20:09:21 <pavonia> Okay
20:09:24 <dmwit> lingxiao: eh?
20:09:30 <dmwit> lingxiao: No, there's nothing about string length involved here.
20:09:44 <lingxiao> I meant string as in expression, sorry imprecise veribage
20:09:53 <dmwit> Still nothing about expression length.
20:09:59 <dmwit> It just evaluates until it can't evaluate any more.
20:10:00 <enthropy> lingxiao: somebody could add type instance And False False = False in another module
20:10:22 <lingxiao> enthropy: so in otherwise it's opened/
20:10:23 <lingxiao> ?
20:10:48 <enthropy> I mean that is one reason you might not want to see an error message
20:10:56 <lingxiao> dmwit: I guess I meant shortest expression as in the expression that could not be reduced any further
20:11:09 <enthropy> when a type function "gets stuck"
20:11:41 <lingxiao> hmm ok, so if the decision was made s.t. that the type family could not be extended in another module, then you'd see an error message?
20:12:02 <lingxiao> I'm asking because it behavies differently than functions at value level, so I'm wondering what is going on underneath here
20:12:02 <dmwit> lingxiao: Okay. But you should definitely keep in mind that those are not the same thing. Type expressions can get longer during evaluation.
20:12:47 <lingxiao> oh that's true, and that could happen w/o recursion right?
20:13:00 <dmwit> yes, e.g. type Foo = Something Longer Than Foo -- =)
20:13:04 <lingxiao> like if you literally just wrote a def that lenghtened some type expression
20:13:16 <enthropy> lingxiao: no you don't error messages directly in that case either
20:13:18 <lingxiao> right haha... ok hwee I'm glad we cleared it up
20:13:35 <enthropy> but my guess is that ghc could detect such cases and be more helpful
20:13:56 <enthropy> closed type families are only about a year old or so?
20:15:19 <enthropy> but you can get errors indirectly when some code doesn't compile
20:15:25 <roboguy_> is there anything like break' p = safeTail . break p where safeTail [] = []; safeTail (_:xs) = xs?
20:15:34 <enthropy> let's say you have type family IntOrDouble (b :: Bool) :: *
20:15:35 <lingxiao> hmm ok
20:15:42 <roboguy_> I mean fmap safeTail . break p
20:15:48 <enthropy> and have   x = 1 :: IntOrDouble (And False False)
20:15:54 <dmwit> roboguy_: safeTail = drop 1
20:15:55 <lingxiao> do you guys know of any small and good projects involving type level programming?
20:16:01 <roboguy_> dmwit: ahh, right
20:16:06 <bicgena> haskell, should I relearn it?  where would I get a chance to use it?
20:16:09 <roboguy_> I always forget about drop
20:16:13 <dmwit> roboguy_: You might also like the split package, though it doesn't do only one break.
20:16:24 <enthropy> lingxiao: I have one for you https://github.com/aavogt/DimMat
20:16:38 <roboguy_> bicgena: I think so, yeah. you can use it any time you want to use it
20:16:47 <roboguy_> dmwit: yeah, I've been looking at that
20:16:53 <roboguy_> it looks like it might not *quite* fit my use case though
20:17:12 <roboguy_> I want to separate a string by spaces and [ and ]. but I also want to include the [ and ]
20:17:13 <lingxiao> enthropy: very small and looks very clean, thanks!
20:17:29 <enthropy> well it's not done yet
20:18:50 <dmwit> roboguy_: Split by spaces; on each chunk, split by [ or ] keeping delimiters.
20:19:10 <dmwit> ...then concat
20:19:11 <roboguy_> dmwit: it puts in ""s when I do that. unless I'm doing it wrong
20:19:29 <lingxiao> roboguy_: enough for me to sink into for now, thanks!
20:19:35 <lingxiao> ok I'm off, thanks for asnwer my questions
20:19:37 <dmwit> Hard to say. But you know the data people need. What you tried, what you expected, what happened instead.
20:20:16 <roboguy_> > concatMap (split (oneOf "[]")) . words $ "[abc] def"
20:20:17 <lambdabot>  ["","[","abc","]","","def"]
20:20:34 <roboguy_> I guess I could filter (not . null), but that seems a bit ugly
20:21:11 <jrmithdobbs> dmwit: why is tail even still there?
20:21:18 <jrmithdobbs> 100% serious question =/
20:21:40 <dmwit> jrmithdobbs: =(
20:21:57 <roboguy_> jrmithdobbs: for some things, it's better to have an error on an invalid case than have it accept that case and give a result that doesn't make sense
20:22:15 <dmwit> :t split
20:22:16 <lambdabot> Splitter a -> [a] -> [[a]]
20:22:19 <roboguy_> it's not the nicest thing though
20:22:19 <dmwit> :t oneOf
20:22:20 <lambdabot> Eq a => [a] -> Splitter a
20:22:21 <nisstyre> tail :: [a] -> Maybe a makes more sense than having it return an empty list
20:22:30 <nisstyre> er Maybe [a]
20:22:34 <dmwit> tail :: [a] -> Maybe a is a sign of weak thinking.
20:22:38 <dmwit> Not proof, just a sign.
20:22:56 <jrmithdobbs> ya just leave tail out completely
20:22:58 <roboguy_> nisstyre: yeah, but that could make things complicated. on the other hand, I don't use tail much
20:23:08 <nisstyre> roboguy_: I don't think it makes things complicated
20:23:08 <Twey> dmwit: Because it drops all the rest of the list?
20:23:15 <jrmithdobbs> if you have drop you don't need tail
20:23:19 <roboguy_> yeah, maybe not actually
20:23:39 <nisstyre> roboguy_: working with Maybe values is easy and nice enough imo
20:23:39 <dmwit> Twey: Well. What I really meant was that head :: [a] -> Maybe a is a sign of weak thinking.
20:23:41 <roboguy_> the problem is, split treats the []s as some sort of list delimiter
20:23:44 <Twey> Aha.
20:23:58 <dmwit> And for that the reason is that people usually want that because they think Maybe a is somehow cheaper than [a] in runtime.
20:24:00 <Twey> I wish we could kill head and tail and replace them with a ‘list’ eliminator
20:24:03 <roboguy_> nisstyre: yeah, they are. it probably would work good actually
20:24:20 <nisstyre> dmwit: it was honestly just a mistake that I wrote that though
20:24:31 <dmwit> tail :: [a] -> Maybe [a] is a strange beast that I Haven't seen requested enough to have an opinion about yet, but on principle I put it in the same category as safeHead.
20:24:45 <Twey> dmwit: Ehh.  Isn't it just about using the appropriate type?  You don't use lists when you want a Maybe.
20:24:59 <dmwit> For converting to a Maybe, it's the only choice.
20:25:26 <dmwit> But I would like to suggest that in most cases where people want to convert to Maybe, they should be converting their Maybe-consuming functions into []-consuming ones.
20:25:37 <dmwit> Again: a sign, not proof.
20:25:38 <roboguy_> lens does have _tail
20:25:40 <Twey> tail is a bit different, because you need a list anyway.  But it can still be useful to distinguish between ‘there were no elements’ and ‘there was one element, and I dropped it’.
20:25:46 <dmwit> And most cases, not all.
20:26:04 <nisstyre> dmwit: I suppose in principle returning [] instead of Nothing isn't bad
20:26:15 <nisstyre> since in both cases you won't get exceptions
20:26:24 <Twey> I don't like that.  I think it's more of a sign of sloppy thinking to be passing extra information into a function rather than converting it to the type the function is actually interested in.
20:26:45 <roboguy_> nisstyre: conceptually though, the tail function shouldn't give [] on []
20:26:57 <nisstyre> roboguy_: I also agree with that
20:27:12 <nisstyre> but that's less important than avoiding exceptions
20:27:18 <jrmithdobbs> Twey: but ify ou care about that case you really do want [a] -> Maybe [a] because that's what you're modeling
20:27:22 <roboguy_> > [] ^. _tail
20:27:24 <lambdabot>  []
20:27:29 <roboguy_> > [] ^? _tail
20:27:31 <lambdabot>  Nothing
20:27:34 <dmwit> Twey: In many of the cases that I have seen discussed here and have arisen in my own hacks, the function can (and ultimately should) be modified to correctly handle any number of arguments.
20:27:56 <jrmithdobbs> Twey: i don't think the exception is the right way to handle that case
20:28:00 <dmwit> Twey: I'm not saying [a] is inherently better than Maybe a. Just that it *happens to be useful in many cases where people mistakenly reach for Maybe first*.
20:28:28 <roboguy_> _tail probably covers most real uses of tail
20:29:07 <Twey> dmwit: I'll take your word for it
20:29:17 <dmwit> Twey: I don't know how to convince you of this other than "watch the next five requests for safeHead and see whether you like them as a pattern match or converting the continuation".
20:29:19 <jrmithdobbs> roboguy_: i'd agree
20:29:24 <jrmithdobbs> roboguy_: and without exceptions!
20:29:33 <dmwit> "...better", I mean
20:29:36 <jrmithdobbs> and you can still distinguish all 3 cases
20:29:39 <erisco> :t (^.)
20:29:40 <lambdabot> s -> Getting a s a -> a
20:30:18 <erisco> :t _tail
20:30:20 <lambdabot> Cons (->) f s s a a => LensLike' f s s
20:30:39 * erisco flips a table
20:30:41 <Twey> dmwit: I'm convinced.  I was just extrapolating from my own experience as a newbie, where I frequently could have used ‘list’ but, I think, never should have passed a list.  If you tell me plenty of people come here asking for safeHead when they want a list, I believe you.  ☺
20:30:42 <roboguy_> _head is handy too
20:31:01 <Twey> erisco: Haha, what's the matter?
20:31:04 <roboguy_> erisco: unfortunately, lens types are confusing. it's not possible for lens to work in any other way though (with clearer types)
20:31:13 <roboguy_> well, they *can* be confusing anyway
20:31:42 <Twey> roboguy_: It is possible, but you wouldn't get nice function composition.  ☺
20:31:50 <roboguy_> Twey: well, that's what I mean
20:32:20 <roboguy_> I guess you could use category but that's cheating. also, I still don't think it would be as composable as it is the way it's written
20:33:30 <roboguy_> erisco: here's the effective type of tail (for lists):  _tail :: Traversal' [a] [a]
20:33:32 <fistfulofmonads> is there a way for my data type to use a specialized show for one of its constructors, but use the derived one for the others?
20:33:48 <jrmithdobbs> erisco: the names make more sense: view = (^.) / headOf = (^?)
20:34:11 <roboguy_> erisco: and here is the effective type of ^. in this case: (^.) :: s -> Traversal' s m -> m
20:34:25 <jrmithdobbs> erisco: headOf is super useful for prisms since they're one way and you can't tell if it'll work beforehand
20:34:34 <erisco> > (S.fromList [1,2,3]) ^. _tail
20:34:35 <lambdabot>  No instance for (Control.Lens.Cons.Cons
20:34:35 <lambdabot>                     (->)
20:34:36 <lambdabot>                     (Control.Lens.Internal.Getter.Accessor (Data.Set.Base.Set...
20:34:36 <lambdabot>                     (Data.Set.Base.Set a0)
20:34:36 <lambdabot>                     (Data.Set.Base.Set a0)
20:34:46 <roboguy_> jrmithdobbs: I think headOf was deprecated by firstOf
20:34:51 <johnw> don't you need ^?
20:34:53 <jrmithdobbs> err ya, sorry
20:34:57 <jrmithdobbs> firstOf is the right name
20:35:21 <erisco> yeah I read through one of the tuts once and was turned off by the immense complexity
20:35:37 <erisco> but maybe some time in the future when simple things bore me
20:35:39 <jrmithdobbs> it's really straightforward if you do what you feel horrible doing
20:35:43 <erisco> I'll try again
20:35:45 <jrmithdobbs> ignore the types and open ghci
20:36:00 <roboguy_> erisco: huh, that works for me in ghci
20:36:11 <roboguy_> oh, S. is Set in lambdabot
20:36:27 <roboguy_> > (Data.Sequence.fromList [1,2,3]) ^. _tail
20:36:28 <lambdabot>  Not in scope: `Data.Sequence.fromList'
20:36:31 <subleq_> i have two functions, and i want to know which one is faster (in a programatic way, i'm not interested in reporting)
20:36:45 <roboguy_> > (V.fromList [1,2,3]) ^. _tail
20:36:46 <lambdabot>  Not in scope: `V.fromList'
20:36:47 <lambdabot>  Perhaps you meant one of these:
20:36:47 <lambdabot>    `M.fromList' (imported from Data.Map),
20:36:47 <lambdabot>    `S.fromList' (imported from Data.Set),
20:36:47 <lambdabot>    `IM.fromList' (imported from Data.IntMap)
20:36:52 <roboguy_> hmm, oh well
20:37:06 <jrmithdobbs> what fromList are you looking for? ha
20:37:15 <roboguy_> none of those, haha
20:37:25 <jrmithdobbs> vector?
20:37:28 <roboguy_> because none of them are ordered
20:37:29 <roboguy_> yeah
20:37:41 <subleq_> like, whichIsSlowest :: [a] -> (a -> ()) -> a
20:38:07 <roboguy_> subleq_: a -> ()?
20:38:37 <roboguy_> that would probably be whichIsSlowest :: [a] -> (a -> IO ()) -> IO Int
20:38:43 <subleq_> roboguy_: yeah, i don't know. In my case it's a -> Bool, but the return value doesn't matter
20:39:07 <jrmithdobbs> > (Data.HashMap.fromList [(1,2),(2,2),(3,3)] ^. _tail
20:39:08 <roboguy_> measuring time is a stateful thing
20:39:09 <lambdabot>  <hint>:1:52:
20:39:09 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:39:21 <jrmithdobbs> > (Data.HashMap.fromList [(1,2),(2,2),(3,3)]) ^. _tail
20:39:22 <roboguy_> I'm not sure it would make sense to get the tail of a hash map
20:39:23 <lambdabot>  Not in scope: `Data.HashMap.fromList'
20:39:31 <subleq_> ah right, so the result would have to be in IO
20:39:37 <jrmithdobbs> roboguy_: make sense? no but i think it works
20:39:38 <subleq_> but the function i'm interested in measuring isn't
20:42:03 <roboguy_> subleq_: the criterion package probably has something like that
20:42:15 <roboguy_> subleq_: also, you can measure runtime in ghci with :set +s
20:42:32 <roboguy_> jrmithdobbs: doesn't work for me
20:42:38 <jrmithdobbs> roboguy_: me either just tried in ghci
20:42:51 <roboguy_> I don't think HashMap is an instance of Cons
20:43:46 <roboguy_> I really like lens, I just wish I could start thinking in terms of writing programs with it. maybe with practice
20:44:37 <jrmithdobbs> kind of at the same point, i've made some use of lens-aeson but the use case there is so apparent as to be hard not to understand
20:45:17 <roboguy_> yeah. the concepts mostly make sense (and even some of the implementation) but I can't quite think practically in terms of lens yet
20:46:44 <roboguy_> it's a little frustrating because I know it's full of really good ideas, expressed in a really elegant way. I guess I just need to try using it more
20:51:07 <roboguy_> what's the advantage of finally tagless encodings?
20:53:57 <jrmithdobbs> roboguy_: this http://okmij.org/ftp/tagless-final/ ?
20:54:21 <roboguy_> jrmithdobbs: yeah
20:57:26 <jrmithdobbs> roboguy_: it looks interesting, the primary usefulness i can think of is pretty simple and straightforward: some people prefer E/DSLs
20:57:57 <roboguy_> jrmithdobbs: well, I mean advantages over initial encodings. both final and initial are EDSLs
20:58:20 <augur> anyone have any good recommendations in the program derivation literature?
20:58:26 <roboguy_> finally tagless encodings do look interesting, but I'm not sure I completely grasp the advantages/disadvantages wrt to initial encodings
20:59:01 <roboguy_> augur: I like Pearls of Functional Algorithm Design
20:59:08 <roboguy_> if that's the sort of thing you mean
20:59:17 <augur> probably not :x
21:08:46 <jamiis> anyone know an easy way to turn a list of numbers and a sequential list of indices into a sparse-ish list ... e.g. sparseMe [4,3,6,90] [1,2,5,7] would produce [0,4,3,0,0,6,0,90]
21:09:10 <jamiis> the second list being the indices where you want to place the values from the first list.
21:09:34 <roboguy_> jamiis: hmm, are the two input lists required to be the same size
21:09:43 <jamiis> yes
21:09:57 <roboguy_> in that case, it would probably be better to make the argument [(Int, Int)]
21:10:01 <roboguy_> then you don't need to worry about that
21:10:20 <roboguy_> or [(a, Int)]
21:11:59 <Twey> You're carrying around redundant information; if you make it just delta, e.g. [1, 1, 3, 2], you can just write: concat $ zipWith (\x d → replicate d 0 ++ [x]) items indices
21:12:11 <enthropy> > zipWith (\n x -> replicate (n-1) 0 ++ [x]) [4,3,6,90] [1,2,5,7]
21:12:13 <lambdabot>  [[0,0,0,1],[0,0,2],[0,0,0,0,0,5],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
21:12:20 <agibiansky> Does `iterate` force me to build up a list of results? i.e. if I want to just get the nth element of the list returned, how can I make it so the previous n-1 elements are not stored in memory (constant size memory consumption)
21:12:36 <enthropy> > map sum $ zipWith (\x n -> replicate (n-1) 0 ++ [x]) [4,3,6,90] [1,2,5,7]
21:12:37 <lambdabot>  [4,3,6,90]
21:13:47 <bicgena> what makes you guys and so many others like haskell?
21:13:50 <enthropy> > take 10 $ map sum $ transpose $ zipWith (\x n -> replicate (n-1) 0 ++ [x] ++ repeat 0) [4,3,6,90] [1,2,5,7]
21:13:52 <lambdabot>  [4,3,0,0,6,0,90,0,0,0]
21:14:23 <roboguy_> bicgena: I find it elegant and there are abstractions I can express in it that I can't express in other languages
21:14:31 <roboguy_> the strong, static typing is nice too
21:14:38 <fistfulofmonads> bicgena: I find my code much quicker to write, and more  concise than in other languages
21:14:39 <roboguy_> (and part of those other two things)
21:14:58 <fistfulofmonads> and much easier to reason about
21:15:04 <enthropy> agibiansky: some/all of the n-1 (or parts thereof) could get garbage collected
21:15:14 <dmj`> bicgena: type safety
21:16:00 <roboguy_> bicgena: parametricity is really, really nice too (this is a result of strong static typing)
21:16:29 <Twey> > let { indices = [1, 2, 5, 7]; values = [4, 3, 6, 90]; deltas = head indices : zipWith subtract indices (tail indices) } in concat $ zipWith (\x d -> replicate d 0 ++ [x]) values deltas
21:16:30 <lambdabot>  [0,4,0,3,0,0,0,6,0,0,90]
21:16:34 <fistfulofmonads> I also like the little embedded languages built around monads, like Parsec and Maybe
21:16:40 <dmj`> bicgena: it's really expressive too
21:16:41 <agibiansky> enthropy: yeah, that's what I would like. If I do `iterate f x0 !! 100`, will it discard the n-1 results (if it needs the memory) before computing the 100th result?
21:17:12 <enthropy> it kind of depends what f is
21:17:26 <enthropy> > iterate (1:) [] !! 10
21:17:27 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
21:17:32 <Twey> And what you do with the result
21:17:49 <agibiansky> I guess it would depend on how (!!) is implemented
21:18:12 <agibiansky> Since it discards any results its not actually returning, it should be free to GC them
21:18:19 <enthropy> in that case, there's no space to saved, since the list in the final result refers to the lists that would be in the n-1 results
21:18:27 <Twey> agibiansky: Not really, but depending on what's in the list and what your f does, the element you get back may share data from the previous elements
21:19:00 <agibiansky> Twey: fair enough, but I am interested in the case where there is no data shared - obviously if there is data shared it will not remove things it might use
21:19:10 <bicgena> fistfulofmonads: Are there any other languages similar to Haskell that you like?
21:19:29 <agibiansky> Something like (+1) but forced to be strict, for example
21:19:39 <fistfulofmonads> haskell's my first purely functional language, so not really
21:20:02 <fistfulofmonads> well, actually I also know bluespec as well, but that's relatively obscure
21:20:30 <fistfulofmonads> and it's meant for hardware description
21:21:04 <Twey> agibiansky: Then yes, the elements should be collected, unless you save them somewhere
21:21:26 <agibiansky> yeah, i have convinced myself of that
21:21:36 <agibiansky> made sense once i thought of the implementation of (!!)
21:21:37 <agibiansky> thanks
21:21:49 <fistfulofmonads> has anyone around here heard of Bluespec?
21:22:01 <roboguy_> fistfulofmonads: I haven't
21:22:08 <roboguy_> I've used an HDL before though
21:22:11 <roboguy_> (not much)
21:23:10 <roboguy_> the HDL I used struck me as being kind of pure in some ways, which surprised me
21:23:14 <roboguy_> the syntax was very ugly though
21:23:18 <fistfulofmonads> VHDL?
21:23:21 <roboguy_> yeah
21:23:31 <levi> I've heard of Bluespec, but not much.
21:23:43 <roboguy_> I had a lab that used VHDL
21:23:52 <roboguy_> in an electronics class
21:23:56 <fistfulofmonads> I've only used verilog and bluespec myself, VHDL looks to have a much much stronger type system and parameter system than verilog, but it looks really verbose
21:24:05 <fistfulofmonads> and it seems less and less people know it nowadays
21:24:11 <roboguy_> it is very verbose. I didn't like the syntax at all
21:24:22 <levi> VHDL = Ada for hardware description
21:24:29 <cdk> What would be a good data structure to represent a connected group of hexagonal tiles which can be moved around in various ways?
21:24:30 <roboguy_> ignoring the syntax, it seemed okay for what it was for the most part
21:24:52 <roboguy_> the sort of "module" system works in a weird way though
21:25:07 <roboguy_> I think they call them macros, which is confusing in itself
21:26:57 <fistfulofmonads> verilog doesn't have a type system really, and the main synthesizer for it is miserable (Xilinx). IF you pass an undefined wire as  an input into a module, Xilinx's synthesizer will replace the value with zero, and not warn you at all...
21:27:04 <levi> There are a family of HDLs as EDSLs in Haskell called Lava.
21:27:10 <fistfulofmonads> a wire that wasn't previouusly declared*
21:27:49 <fistfulofmonads> it will also gladly try to expand a one-bit value into a multi-bit value or vice-versa, that one might have an actual warning
21:28:11 <joelteon> so you can't do record updates on existentially typed record fields, huh?
21:30:17 <joelteon> then I need to figure out a new way to do this
21:33:50 <johnw> joelteon: why would that matter?
21:34:07 <joelteon> well, I'm going to have to figure out a different way to write this library
21:34:49 <johnw> i mean, why can't you do record updates?
21:35:09 <joelteon> because the field is apparently insufficiently polymorphic
21:36:00 <johnw> can I see the code/error?
21:36:05 <joelteon> sure, sec
21:36:39 <Hasjoy> http://www.youtube.com/watch?v=ZhuHCtR3xq8 Interesting intro to Monads. Hehe probably the worst place to start.
21:36:44 <joelteon> https://github.com/joelteon/bots/blob/master/src/ToyBot.hs#L8
21:36:52 <joelteon> "Record update for insufficiently polymorphic field:"
21:36:55 <joelteon> just clone that, cabal repl it
21:36:58 <joelteon> you'll see the error
21:37:01 <joelteon> not too dependency heavy
21:37:02 <nisstyre> Hasjoy: I thought "intro to monads" things were passe?
21:38:31 <joelteon> johnw: i'll give you a brief explanation of the way the library works if you want
21:38:38 <c_wraith> We need more introduction to Kleisli arrow articles.
21:38:44 <joelteon> or you should be able to haddock it and see that way
21:41:18 <roboguy_> Hasjoy: the best place to start with understanding Monads is probably Functors
21:41:38 <Hasjoy> nisstyre: Well I don't know I am just an hour into Haskell and that was the first thing I ever looked into.So probably the wrong place to start.
21:41:54 <nisstyre> Hasjoy: I was just being sarcastic
21:42:02 <nisstyre> some people don't like the whole "monad tutorial" thing
21:42:02 <johnw> joelteon: trying now
21:42:52 <Hasjoy> roboguy_: Will look into it thanks.
21:43:02 <johnw> joelteon: concurrent-state 0.3 isn't on Hackage :(
21:43:39 <joelteon> cabal update
21:43:52 <roboguy_> Hasjoy: well, Functors are not something you should look at yet either. eventually, but not when you're an hour in haha
21:44:09 <johnw> aha
21:45:38 <johnw> joelteon: aren't you modifying a function type with your record update here?
21:45:43 <joelteon> not sure
21:45:50 <joelteon> I didn't think I was, but I guess I am
21:45:55 <johnw> it looks like ircConnection returns a StatefulConnection, which is a type synonym for a function
21:46:11 <joelteon> right
21:46:17 <johnw> so, I would expect that to fail :)
21:46:21 <joelteon> interesting
21:46:56 <joelteon> if I apply ircConnection ... to undefined, same error
21:48:27 <joelteon> I think it's complaining about authenticate being used in a record update
21:48:33 <joelteon> maybe it's not polymorphic enough to be updated...
21:55:35 <joelteon> I don't know why you can't update that
21:56:31 <johnw> why type do you think the record is?
22:01:12 <joelteon> when applied to undefined it's Connection (StateC () IO)
22:01:51 <johnw> I didn't know you could do polymorphic record updates like that; I thought you meant that the type of the field of a specific type was rank-2 or something
22:02:16 <joelteon> well I don't think you can is the thing
22:02:23 <johnw> yeah
22:02:30 <joelteon> the type of that field is Handle -> AuthInfo backend -> env ()
22:02:35 <joelteon> backend is an existential type
22:02:46 * hackagebot ghc-imported-from 0.1.0.0 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.1.0.0 (CarloHamalainen)
22:04:00 <joelteon> johnw: if I remove the reference to backend, it typechecks
22:04:07 <dhrosa> using PArsec, how do I match the end of a string?
22:04:27 <johnw> dhrosa: isn't not eof?
22:04:41 <dhrosa> oh
22:04:54 <joelteon> so...
22:05:00 <joelteon> hm
22:05:05 <dhrosa> yes, yes it is johnw
22:05:33 <joelteon> if only you could put fundeps on associated types
22:06:28 <dmwit> joelteon: Why bother, when you have associated types?
22:06:46 <joelteon> well clearly I don't understand associated types
22:07:07 <joelteon> dmwit: if you read up, authenticate is of type Handle -> AuthInfo backend -> env ()
22:07:13 <dmwit> If you had a fundep a b c -> d e f, then you just make three type families for d, e, and f instead.
22:07:17 <joelteon> and GHC is complaining that it's insufficiently polymorphic to be updated
22:07:25 <joelteon> because of the reference to AuthInfo backend
22:07:34 <dmwit> I'll read up a bit.
22:07:36 <joelteon> why is it complaining about that?
22:07:46 <dmwit> Is there some code somewhere?
22:07:58 <joelteon> yeah, it's up
22:08:06 <joelteon> https://github.com/joelteon/bots
22:08:09 <joelteon> clone and cabal repl
22:12:32 <ReinH> oh hai
22:13:21 <copumpkin> oh bai
22:13:23 <dmwit> joelteon: Um, you're trying to do record update on something that has function type?
22:13:28 <dmwit> Why would you expect that to work?
22:13:38 <joelteon> yeah, johnw already mentioned that
22:13:46 <joelteon> just apply ircConnection ... to undefined
22:13:49 <joelteon> you get the same error
22:13:56 <ReinH> copumpkin: :(
22:14:03 <copumpkin> ReinH: :)
22:14:11 <ReinH> copumpkin: was that a co-greeting?
22:14:18 <copumpkin> probably!
22:14:24 <ReinH> fair enough
22:14:32 <dmwit> joelteon: Connection does not appear to me to be a record.
22:14:47 <dmwit> joelteon: So it seems perfectly reasonable for me that GHC complain about record update.
22:14:53 <dhrosa> can anyone tell me why this parser only matches the full string  "dissassemble"? parseDis = choice [string "disassemble", string "dis", string "d"] >> eof >> return Disassemble
22:14:58 <joelteon> oh
22:15:06 <joelteon> what makes it not a record?
22:15:24 <dhrosa> I have a very similar parser that works on both regs and r: choice [string "regs", string "r"] >> eof >> return Regs
22:15:50 <dmwit> joelteon: Hm, perhaps I'm just misunderstanding ghci's output.
22:15:51 <dmwit> moment
22:15:52 <dhrosa> actually nevermind, I thought they both worked..
22:17:08 <dmwit> joelteon: Okay. So you're trying to update the "authenticate" field to something, but surely you have to also update the "authInfo", "reactor", "backend", and "parser" fields at the same time...?
22:17:19 <dmwit> joelteon: Since they all have the same existential.
22:18:09 <joelteon> why would it change?
22:18:26 <dmwit> Why would it stay the same?
22:18:43 <joelteon> Because I didn't change it
22:19:07 <dmwit> That's not clear to me at all.
22:19:53 <joelteon> I'm changing authenticate, which takes a Handle and ()
22:20:20 <joelteon> because AuthInfo IRC is ()
22:20:26 <joelteon> and backend is type Backend IRC
22:21:22 <dmwit> backend is existentially quantified
22:21:26 <dmwit> it is not Backend IRC
22:21:54 <dmwit> Also, you may be interested to know that the following typechecks:
22:22:00 <dhrosa> is there concise syntax for saying that like 6 functions have the same type?
22:22:01 <dmwit> (\(Connection p b r c a _ e) -> Connection p b r c a (\h _ -> liftIO $ hPutStrLn h "")) (ircConnection "" (PortNumber 6667) undefined)
22:22:12 <dmwit> dhrosa: foo, bar, baz :: a -> b
22:22:23 <joelteon> oh, ok
22:22:26 <joelteon> Well, that makes sense
22:22:30 <dhrosa> aha
22:22:44 <dmwit> joelteon: Note that pattern matching brings the existential into scope. As long as you wrap it back up after, you should be okay.
22:22:54 <joelteon> so I'd somehow have to ensure that the backend didn't change
22:23:01 <dmwit> yes
22:23:03 <joelteon> but I don't think I can do that
22:23:06 <joelteon> maybe I can
22:23:19 <dmwit> Well, the particular update you're trying to do seems to work with any backend.
22:23:23 <dmwit> So that shouldn't be a problem.
22:24:10 <dmwit> You just can't do it with record update syntax is all.
22:30:23 <Hasjoy> http://www.youtube.com/watch?v=ZR3Jirqk6W8 This guy wrote everything from scratch to get things working. Makes me wonder if I will end up going the same route.
22:31:54 <Hasjoy> Or more likely reuse his code :)
22:35:22 <joelteon> dmwit: but I can't provide a library function that uses that pattern, because it would have to take something of type AuthInfo backend -> ... as an argument.
22:36:15 <dmwit> You can provide a library function which accepts suitably polymorphic authenticators.
22:36:21 <dmwit> i.e. ones which work for any backend.
22:36:26 <dmwit> That's about it.
22:36:38 <joelteon> so that makes sense
22:37:22 <dmwit> You could also provide a library function which *modifies* authenticators, I guess. Though I'm not sure what the right interface for that would be.
22:37:49 <dmwit> going to bed
22:37:51 <dmwit> good luck
22:37:59 <joelteon> Well, the reason I wanted to existential backend is so I can make a list of connections
22:41:53 <dmwit> one more thing before I hit the sack
22:42:00 <dmwit> if *all* you need is to put things in a container,
22:42:04 <dmwit> and you haven't seen it before,
22:42:16 <dmwit> you may get some ideas from https://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
22:42:49 <joelteon> yeah I've been thinking of that article a lot since starting on this library
22:43:27 <Redz> i have a class with a function without a parameter that just returns a number. now i want to convert something to a type that is a instance of this class. but i need access to this number. how i get this number? i actually looking at ScopedTypeVariables, but i couldn't figure out how and if it work.
22:44:21 <dmj`> Redz: can you show code
22:45:37 <Redz> one moment. i'll extract the code.
22:46:28 <Twey> Redz: You need to pass a dummy parameter so the compiler can tell which instance you want
22:50:36 <dmj`> is there going to be a real world haskell part 2?
22:50:49 <dmj`> "second edition"
22:51:01 <sdegutis> Hi.
22:51:10 <Redz> http://lpaste.net/98932
22:51:17 <sdegutis> I am almost ready to take the Haskell plunge. The only concern I have left is significant whitespace.
22:51:44 <dhrosa> that reminds me, all of the examples in the second half of real world haskell are all broken :/
22:51:46 <sdegutis> Someone told me it's sort of different than Python's, but it's hard for him to explain how so. Does anyone else feel this way?
22:52:05 <dhrosa> sdegutis: whitespace is much less significant in haskell than python, but still significant
22:52:23 <dhrosa> there's more freedom with whitspace in haskell
22:52:40 <Hasjoy> dhrosa why are the examples broken?
22:53:03 <dhrosa> Hasjoy: the script they use to automatically compile their sample code doesn't work on all of their examples in the second half
22:53:14 <dhrosa> and apparently according to the comments it might have made it to the print version?
22:53:35 <startling> dhrosa, RWH is pretty old by now.
22:53:59 <dmj`> RWH doesn't mention iteratees
22:54:05 <dmj`> unless I'm mistaken
22:59:06 <mhitza> hey guys, I would expect the following code to read two lines from input and print them afterwards http://lpaste.net/98933 However it gets stuck in an infinite loop :\
23:00:04 <mhitza> just saw it myself :)
23:00:07 <mhitza> disregard question
23:00:10 <sdegutis> What IDE do you recommend for Haskell?
23:00:28 <dhrosa> emacs and a command line :)
23:00:44 <startling> just emacs works too :)
23:00:58 <dmj`> emacs
23:01:00 <peddie> sdegutis: ghc-mod for emacs :)
23:01:02 <Hasjoy> emacs
23:01:16 <Hasjoy> hehe and I am 2 hours into Haskell.
23:01:24 <startling> are there length-typed vectors on hackage yet?
23:01:40 <dhrosa> i've seen a few
23:02:34 <peddie> http://hackage.haskell.org/package/linear-1.4/docs/Linear-V.html
23:03:24 <startling> peddie: oh, nice, I'm already using linear
23:03:36 <peddie> then off you go :)
23:12:31 <ethercrow> sdegutis: if you configure yi enough to use it as haskell IDE, that will mean you've learned at least some haskell.
23:12:34 <ethercrow> what's not to like
23:12:46 <rtpg> how is yi as a text editor?
23:13:52 <ethercrow> depends on what you expect from text editor
23:14:47 <sdegutis> Dang, Haskell experience starting off with yak shaving.
23:14:54 <ethercrow> editing small files is fine
23:15:00 <sdegutis> error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘__attribute__’ before ‘forkProcess’
23:15:01 <sdegutis> :(
23:15:18 <Twey> That doesn't look like a Haskell error
23:15:27 <ethercrow> vim mode is good if you use the right subset of vim features
23:15:34 <sdegutis> Linking error..
23:16:30 <sdegutis> Something about /usr/local/Cellar/ghc/7.6.3/lib/ghc-7.6.3/include/rts/Threads.h line 49
23:16:46 <jrmithdobbs> @src otherwise
23:16:47 <lambdabot> otherwise = True
23:16:52 <sdegutis> ooh i see, clang stuff
23:16:56 <sdegutis> mavericks problems
23:18:58 <Twey> mhitza: You wrote ‘b’ when you meant ‘b'’
23:19:36 <Twey> mhitza: (you'll also need to change your t1 to t in the type, because the output of the action and the input to the function need to match)
23:22:52 * hackagebot dominion 0.1.0.3 - A simulator for the board game Dominion.  http://hackage.haskell.org/package/dominion-0.1.0.3 (AdityaBhargava)
23:31:51 <mhitza> Twey, thanks :)
23:32:13 <Twey> mhitza: No problem
23:34:28 <hamster007> hey do you guys use literate haskell
23:34:40 <johnw> hamster007: not really
23:37:33 <Twey> hamster007: Sometimes
23:38:16 <hamster007> i need to set it up on my mac and im having difficulty
23:38:48 <Twey> What is there to set up?  Just run GHC on it normally
23:39:13 <hamster007> i mean lhs2TEX
23:43:13 <jrmithdobbs> ok, light table is actually kind of cool now that there's a plugin for a language i use
23:46:05 <kosmikus> hamster007: what's your problem?
23:46:24 <hamster007> freaking nothing works
23:46:32 <hamster007> lemme see
23:48:54 <hamster007> http://lpaste.net/98937
23:49:51 <kosmikus> hamster007: I'm not sure why you're trying to install 1.18. Try 1.18.1, which is the most recent version.
23:50:10 <hamster007> ok
23:50:15 <hamster007> lemme get that
23:53:01 <jle`> hamster007: try using pandoc
23:55:09 <kosmikus> jle`: pandoc and lhs2tex are two complete different tools
23:55:13 <kosmikus> *completely
23:55:26 <jle`> is he trying to convert lhs into tex?
23:55:49 <kosmikus> I have no idea what exactly he's trying to do.
23:57:55 <randomclown> how do I include a native build step in cabal?
23:58:13 <johnw> for what kind of target?
23:58:14 <randomclown> I have a .c file with functions that I'm using
23:58:37 <johnw> just add it to cc-sources, I think
23:58:54 <johnw> ah, c-sources
23:59:08 <randomclown> excellent thank you
