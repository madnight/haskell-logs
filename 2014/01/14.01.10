00:00:44 <JakeE> ah but that dosn't really help does it sense you still have to put spaces in
00:01:28 <roboguy_> you could put spaces in the .+ function
00:01:47 <roboguy_> you just need to end with an empty string (or some kind of string)
00:01:56 <JakeE> ya I just did that lol! still you might want OTHER strings between it and you might not want the space
00:01:57 <prooftechnique> Also, wouldn't that be something like foldr ((++) . show)?
00:02:14 <JakeE> ya that is it in pointfree style I think
00:02:18 <roboguy_> JakeE: you could have it generate a function and then have another function that tells it what to intersperse
00:02:23 <triliyn> But then you need to put the things in a list
00:02:30 <Axman6> JakeE: .= for a space, .+ for concat only
00:02:42 <triliyn> Which means you can't say 5 .+ 'a' .+ "then"
00:03:19 <JakeE> no you need another function like .+. that takes 2 showable items and binds more tightly than .+
00:04:07 <Axman6> anyone take a look at the tutorial on implementing a simple in haskell using LLVM? surprisingly compact and powerful
00:04:29 <prooftechnique> triliyn: Sure, but (.+) as defined is just going to throw extraneous quotes around stuff
00:04:48 <prooftechnique> I see your point, though.
00:04:58 <prooftechnique> No one liner is gonna do just the right thing.
00:05:02 <triliyn> It would be okay if it's left-associative, wouldn't it?
00:05:19 <JakeE> ya
00:05:22 <roboguy_> you could do something like x +. f = \m -> show x ++ m ++ f m; withSeparator = flip ($)
00:05:32 <JakeE> what I have right now: x .+ y = show x ++ " " ++ y
00:05:32 <JakeE> x .+. y = show x ++ " " ++ show y
00:05:32 <JakeE> infixl 7 .+
00:05:33 <JakeE> infixl 8 .+.
00:05:44 <triliyn> > let a .+ b = show a ++ b in 5 .+ ('a' .+ "six")
00:05:45 <lambdabot>  "5'a'six"
00:05:59 <triliyn> hmmm, that's not quite what you want for characters...
00:06:11 <JakeE> perhaps a diffrent type class is needed?
00:06:17 <Axman6> there's a reason Show has showList (I think)
00:06:21 <Axman6> :t showList
00:06:22 <lambdabot> Show a => [a] -> ShowS
00:06:42 <Axman6> it's basically explicitly there to support show on String aka [Char]
00:06:44 <JakeE> a typeclass that dosn't make a haskell expression but instead is more like toString in Java or C#
00:07:17 <JakeE> toString "asfasdf" == "asfasdf" and toString 'a' == "a"
00:07:54 <JakeE> I think this is no solution to the issue lol
00:10:04 <roboguy_> > let { x .+. f = \m -> show x ++ m ++ f m; x .+ y = \m -> show x ++ m ++ show y; withSeparator = flip ($) } in withSeparator " " $ 1 .+. (2 .+ 3)
00:10:05 <lambdabot>  "1 2 3"
00:10:59 <JakeE> getting somewhere!
00:12:14 <JakeE> also I wonder what the relation to contuniation passing style is given that  'withSeperator' is the "make a value a CPS delayed value" function
00:14:37 <roboguy_> of course, if we're doing that we could just do something like:
00:14:39 <roboguy_> > let { x .+. y = show x : y; x .+ y = [show x, show y]; withSeparator x = concat . intersperse x } in withSeparator " " $ 1 .+. (2 .+ 3)
00:14:40 <lambdabot>  "1 2 3"
00:15:21 <roboguy_> maybe not *quite* as cool as doing some CPS haha
00:15:51 <roboguy_> or pseudo-CPS I guess
00:16:18 <Twey> JakeE: There's an IsString typeclass
00:19:46 <roboguy_> I was going to say they might have different semantics w.r.t. bottom, but then I remembered this is haskell so they're probably the same
00:30:56 <JakeE> except IsString a) only has an instance for String and b) does fromString not toString
00:32:16 <JakeE> where as a new ToString typeclass could be made as an extension to Show such that String and Char were special and everything else just used show
00:35:06 <shachaf> It's a shame you can't write foo (cast -> Just x) -> ...x...; foo (cast -> Nothing) = ...
00:36:51 <JakeE> im confused as to what that would do
00:37:52 <JakeE> any how it's 2:30 and I think I've been up long enoghe
00:44:37 <Fuuzetsu> shachaf: What would that do? Looks like view patterns but I suspect that's not what you mean.
00:45:23 <shachaf> It's view patterns.
00:45:41 <shachaf> Well, I suppose I'm making it too complicated. The real issue is with just a case expression.
00:47:09 <Fuuzetsu> I feel like I'm missing the context of this discussion. I thought that view patterns let you write exactly that.
00:51:12 <jle`> where do binaries go when in cabal build them in a sandbox? apparently not .cabal-sandbox/bin
00:53:00 <supki> jle`: after cabal build all executables are in dist/build
00:53:08 <supki> whether sandboxed or not
00:53:40 <jle`> supki: ah thanks
00:54:27 <supki> jle`: cabal copy is what copies them into .cabal-sandbox/bin, I think
00:54:39 <jle`> what's the point of .cabal-sandbox/bin then?
00:54:50 <supki> that's where installed binaries are
00:55:05 <supki> it's like ~/.cabal/bin for sandbox
00:55:07 <Fuuzetsu> that's after ‘cabal install’
00:55:22 <jle`> oh it's all the bins of all my other sandboxed packages too
00:55:25 <jle`> all in one place
00:55:45 <jle`> i guess if i really only wanted the compiled binary i don't need to cabal install
00:56:10 <supki> yes
00:56:26 <supki> although it would not be stripped, for example
00:56:59 <supki> not sure what exactly is the difference between built binary and installed one
00:57:53 <zipper> supki: Installed is in your path?
00:58:10 <supki> installed as in after  cabal install
01:06:14 * hackagebot Rlang-QQ 0.1.1.0 - quasiquoter for inline-R code  http://hackage.haskell.org/package/Rlang-QQ-0.1.1.0 (AdamVogt)
01:21:55 <hooplahoops> Silly question, what do we call "instances" of algebraic data types? E.g. (Foo 10) ? Do we just call them objects, or values?
01:22:27 <Fuuzetsu> values of type Foo
01:22:51 <hooplahoops> Ok, thanks Fuuzetsu
01:57:21 <dleedev> are all functors in Haskell endofunctors since they map Hask to Hask?
01:58:06 <jle`> dleedev: yes
01:58:47 <dleedev> are all functions functors as well?
01:58:56 <zett_zelett> No.
01:59:40 <zett_zelett> Functors map between categories, in order to understand every function as a functor, you need to understand every type as a category in itself.
01:59:51 <mm_freak> dleedev: all Functor functors
02:00:22 <mm_freak> dleedev: but you can totally have other functors in haskell
02:00:28 <jle`> oh yeah.
02:00:32 <dleedev> so only functions where both sides can be considered categories...
02:00:42 <donri> the question was if all functions are functors
02:01:46 <zett_zelett> And not even those. Functors need to fulfill the identities F id_X = id_FX and  F (g.h) = Fg . Fh.
02:01:50 <dleedev> what's an example of a Haskell data type that can't be considered as a category?
02:02:19 <donri> in haskell that's true, it's the reader monad which is a functor
02:02:20 <shachaf> If you think of Haskell types as categories, you're going to have a bad time.
02:02:24 <jle`> oh i was wondering why my deployment server was still getting these weird bugs that i thought i had fixed. turns out that i was cabal build-ing and not cabal copy/install-ing, so i was deploying with old binaries
02:02:28 <jle`> how silly
02:02:47 <shachaf> And also if you think of Haskell functions as functors between them. So don't.
02:03:11 <zett_zelett> Hm.
02:03:25 <zett_zelett> One can bend them to look like categories.
02:03:30 <zett_zelett> Many types, at least.
02:03:51 <dleedev> I ask because it seems like I can fmap over functions as well
02:04:28 <dleedev> for example: fmap (+ 1) length
02:04:31 <shachaf> You can call a set a discrete category. It won't help confused people like dleedev (who's talking about an entirely different thing, the Functor instance for (r ->)) at all.
02:04:45 <zett_zelett> Okay, and why would this suggest that functions are functors?
02:04:47 <donri> @src (->) fmap
02:04:48 <lambdabot> fmap = (.)
02:06:30 <shachaf> I recommend to someone like dleedev who's learning Haskell to forget about category theory entirely. It probably won't help.
02:07:17 <shachaf> The class Functor has a reasonable meaning entirely in Haskell, and bringing up arbitrary categories and functors between them won't help much with understanding it.
02:08:24 <Iceland_jack> exactly
02:09:33 <dleedev> I think I get the Functor class in Haskell. I'm curious why a function is an instance of it.
02:09:59 <Iceland_jack> dleedev: Functions aren't special in that sense
02:10:22 <Iceland_jack> If you can implement fmap
02:10:22 <Iceland_jack> @ty fmap
02:10:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:10:32 <Iceland_jack> such that the laws are satisfied: it's a functor
02:10:39 <shachaf> A function is not an instance of it.
02:10:41 <donri> because it can be. because it's useful. because it's also a Monad which says it should be a Functor and Applicative as well.
02:11:01 <shachaf> An instance of Functor is a thing like Maybe or (Either e).
02:11:05 <DarkUnicorn> hello, i'm trying to remove explicit recursion in a function like "f (a:b:xs) = g a b : f (g a b : xs)". every recursive call depends on the result of the caller. any suggestions?
02:11:06 <Iceland_jack> Yes, ((→) r) is an instance
02:11:59 <donri> > liftA2 (,) length reverse [1,2,3]
02:12:00 <lambdabot>  (3,[3,2,1])
02:12:14 <dleedev> is there a way to check in ghci if something's an instance of a certain class?
02:12:18 <Iceland_jack> :info
02:12:48 <donri> > join (,) 3
02:12:49 <lambdabot>  (3,3)
02:13:14 <Iceland_jack> dleedev: If you want you should take the type signature of ‘fmap’ and replace every ‘f’ with a ‘r →’
02:13:57 <Iceland_jack>     fmap ∷ Functor f ⇒ (a → b) → f a     → f b
02:13:57 <Iceland_jack>     fmap ∷             (a → b) → (r → a) → r → b
02:14:04 <dleedev> Iceland_jack: yeah, that much I understand... it's just that I was surprised that ((->) r) is an instance of Functor
02:14:22 <Iceland_jack> Are you still surprised?
02:14:35 <dleedev> Iceland_jack: I guess I am
02:14:52 <Iceland_jack> Why is it more susprising than say Maybe being an instance of Functor?
02:15:03 <zett_zelett> You realise that Int -> Int for example is nothing but a type as well?
02:15:18 <dleedev> Iceland_jack: because all Maybe over all parameters is still a Functor
02:15:19 <Iceland_jack> @kind (->)
02:15:19 <lambdabot> * -> * -> *
02:15:26 <dleedev> Iceland_jack: but not all functions are functors
02:15:44 <dleedev> Iceland_jack: or that's what I was told just now
02:16:06 <Iceland_jack> (r →) is a functor, just like (Either r) is a functor
02:16:09 <zett_zelett> What is a functor to you?
02:16:13 <zett_zelett> dleedev?
02:16:17 <donri> dleedev: do you know about ReaderT? functions are like Reader but without a newtype, where ask = id
02:16:33 <donri> and runReader is function application
02:16:37 <dleedev> zett_zelett: functor is a mapping from category to category.
02:16:50 <zett_zelett> dleedev: And in terms of Haskell?
02:16:54 <Iceland_jack> I somehow doubt monad transformers will help
02:17:16 <donri> it might if you already have an intuition for Reader
02:17:30 <dleedev> zett_zelett: in Haskell, there is Functor. It's a reasonable approximation of a functor in Haskell, where it maps Hask to Hask.
02:17:33 <zett_zelett> (If you put it that way (->) r maps a type a to a type r -> a, so it’s a functor. You didn’t have to look at the values of r -> a (wich are functions) at all.)
02:17:42 <donri> > (do x <- id; return (x + 2)) 5
02:17:43 <lambdabot>  7
02:18:01 <donri> > runReader (do x <- ask; return (x + 2)) 5
02:18:03 <lambdabot>  7
02:18:04 <zett_zelett> *a type 'a' to a type 'r -> a'
02:19:26 <Iceland_jack> > replicateM 10 id 5
02:19:28 <lambdabot>  [5,5,5,5,5,5,5,5,5,5]
02:19:40 <donri> > runReader (fmap odd (do x <- ask; return (x + 2))) 5
02:19:41 <lambdabot>  True
02:19:44 <dleedev> zett_zelett: ah, sorry, Functor is a class where its instances are doing the functor-ish mappings
02:19:44 <Iceland_jack> > (\x → replicate 10 x) 5
02:19:46 <lambdabot>  [5,5,5,5,5,5,5,5,5,5]
02:19:50 <donri> > fmap odd (do x <- id; return (x + 2)) 5
02:19:51 <lambdabot>  True
02:20:01 <zett_zelett> Why would you need functions to be functors in order for (->) r to be a functor?
02:20:24 <zett_zelett> Wait a second.
02:20:25 <dleedev> zett_zelett: hmm... let me think about that some more
02:20:30 <zett_zelett> Haskell does understand unicode →?
02:20:39 <donri> UnicodeSyntax
02:20:43 <Iceland_jack> zett_zelett: What⁉
02:21:08 <zett_zelett> > \x → x+1
02:21:09 <lambdabot>  <Integer -> Integer>
02:21:28 * hackagebot matrix 0.2.3.0 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.2.3.0 (DanielDiaz)
02:21:29 <zett_zelett> Nice.
02:21:32 <donri> :t id :: a → a
02:21:33 <Iceland_jack> > (5 ∷ Integer)
02:21:33 <dleedev> zett_zelett: that last question you asked me is the heart of what Iceland_jack said here: "(r →) is a functor, just like (Either r) is a functor"
02:21:33 <lambdabot> lexical error at character '\134'
02:21:34 <lambdabot>  5
02:21:37 <donri> :(
02:21:50 <dleedev> zett_zelett: is that right?
02:22:38 <dleedev> zett_zelett: your point is that any parameterized type is a functor?
02:22:51 <zett_zelett> It is not and this is not my point.
02:23:10 <Iceland_jack> You must have kindedness ★ → ★ to be a Functor, it's necessary but not sufficient
02:23:11 <zett_zelett> You need to implement fmap, of course.
02:23:19 <Iceland_jack> @kind []
02:23:19 <lambdabot> * -> *
02:23:20 <Iceland_jack> @kind Maybe
02:23:21 <lambdabot> * -> *
02:23:24 <Iceland_jack> @kind Either a
02:23:25 <lambdabot> Not in scope: type variable `a'
02:23:27 <Iceland_jack> feck
02:23:33 <Iceland_jack> @kind forall a. Either a
02:23:33 <lambdabot> * -> *
02:23:56 <Iceland_jack> @kind forall a. ((->) a)
02:23:57 <lambdabot> * -> *
02:23:58 <Iceland_jack> (etc)
02:24:24 <maxs`> why isn't Bool a monad? f `fmap` True = True. return () = True, True >>= f = f (), etc...
02:24:36 <Iceland_jack> maxs`: Monads must have kindedness ★ → ★
02:24:42 <Iceland_jack> Bool is ★
02:25:07 <Iceland_jack> @src Monad
02:25:08 <lambdabot> class  Monad m  where
02:25:08 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
02:25:10 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
02:25:11 <lambdabot>     return      :: a -> m a
02:25:14 <lambdabot>     fail        :: String -> m a
02:25:16 <Iceland_jack> See the part with ‘m a’ and ‘m b’?
02:25:24 <zett_zelett> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#functors-redux did you read this, dleedev?
02:25:38 <Iceland_jack> If Bool were an instance of Monad the type of return would be
02:25:38 <Iceland_jack>     return ∷ a → Bool a
02:25:54 <Iceland_jack> and (>>=) would be
02:25:54 <Iceland_jack>     (>>=) ∷ Bool a → (a → Bool b) → Bool b
02:25:55 <maxs`> Iceland_jack: yeah, sorry, a better question is, do you know 'unit'- like instance of Monad?
02:26:02 <zett_zelett> Iceland_jack: What do you use to type in unicode symbols?
02:26:12 <Iceland_jack> zett_zelett: XCompose
02:26:20 <dleedev> zett_zelett: yes
02:26:22 <Iceland_jack> maxs`: I'm not sure what you're asking
02:27:06 <Iceland_jack> (This may be useful to dleedev: http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad)
02:27:55 <Iceland_jack> Not 100% relevant but still
02:28:27 <zett_zelett> Have you tried making (->) r an instance of Functor yourself?
02:28:49 <Iceland_jack> dleedev: I second zett_zelett suggestion
02:28:57 <dleedev> zett_zelett: no, let me try
02:29:09 <Iceland_jack> Make your own Functor2 typeclass and define a (r →) instance
02:29:42 <Iceland_jack> it would be even better to define a separate function ‘myfmap’ where you specify the type signature
02:30:15 <killy9999> is there a way to easily obtain latest version of a package on hackage in a bash script?
02:30:39 <killy9999> I need to write a script that downloads latest versions of listed packages
02:30:53 <killy9999> and right now I have to check latest versions manually
02:32:59 <mauke> http://hackage.haskell.org/api
02:35:05 <solrize> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html   Data.Text not mentioned here and also not in hackage?
02:35:42 <shachaf> Is text included in GHC?
02:35:59 <maxs`> no, haskell-platform
02:36:51 <dv-> solrize: http://hackage.haskell.org/package/text
02:36:59 <solrize> thanks
02:38:04 <shachaf> Then I wouldn't expect it to be in /ghc/docs/
02:38:10 <shachaf> But now I see that you were asking a different question.
02:38:31 <solrize> well i looked in ghc lib list and also in hackage lib list
02:38:44 <solrize> i mean here: http://hackage.haskell.org/packages/
02:41:34 <solrize> hmm OverloadedStrings doesn't extend to ghci...
02:41:52 <shachaf> Unless you turn it on.
02:42:17 <dleedev> zett_zelett, Iceland_jack: I got
02:42:18 <dleedev> class Functor2 a where
02:42:19 <dleedev>   myfmap :: (x -> y) -> a x -> a y
02:42:20 <dleedev> instance Functor2 ((->) r) where
02:42:21 <dleedev>   myfmap = (.)
02:42:29 <dleedev> does that look right?
02:43:25 <Iceland_jack> yes
02:43:53 <Iceland_jack> now I would suggest writing a separate function
02:44:01 <Iceland_jack> defining myfmap as
02:44:01 <Iceland_jack>     myfmap = myfmap'
02:44:11 <Iceland_jack> Just to have written the type signature down
02:44:44 <dleedev> Iceland_jack: the type signature of what?
02:45:00 <Iceland_jack> of myfmap specialized to (r →)
02:45:17 <Iceland_jack> You cannot write it in the instance declaration
02:45:49 <Iceland_jack> i.e.
02:45:49 <Iceland_jack>     instance Functor2 ((→) r) where
02:45:49 <Iceland_jack>       myfmap ∷ ...
02:45:49 <Iceland_jack>       myfmap = (∘)
02:45:52 <Iceland_jack> will not work
02:46:31 * hackagebot gloss-game 0.3.0.0 - Gloss wrapper that simplifies writing games  http://hackage.haskell.org/package/gloss-game-0.3.0.0 (ManuelChakravarty)
02:49:18 <dleedev> Iceland_jack: you mean like this:
02:49:20 <dleedev> myfmap' :: (x -> y) -> (r -> x) -> (r -> y)
02:49:20 <dleedev> myfmap' = (.)
02:49:29 <Iceland_jack> yes exactly
02:49:53 <supki> Iceland_jack: you actually can with -XInstanceSigs
02:50:02 <supki> in recent GHC
02:50:06 <Iceland_jack> Yes it's possible but that requires a newer GHC
02:50:22 <Iceland_jack> I thought this would be easier to understand
02:50:22 <zett_zelett> Can’t you make anything a (useless) functor by defining fmap id = id, fmap g = ()?
02:50:37 <zett_zelett> fmap g x = ()*
02:50:50 <zett_zelett> Or fmap g = const ().
02:51:02 <Iceland_jack> zett_zelett: That would have type
02:51:02 <Iceland_jack>     fmap ∷ (a → b) → f a → ()
02:51:02 <Iceland_jack> ?
02:51:53 <zett_zelett> Oh wait.
02:52:07 <zett_zelett> I mean something like fmap g = const ⊥.
02:52:11 <Iceland_jack> other than that it wouldn't satisfy the laws
02:52:23 <Iceland_jack> fmap g id = id?
02:52:38 <maxs`> oh, the identity functor??
02:53:19 <zett_zelett> What do you mean by that: fmap g id = id, Iceland_jack?
02:53:57 <Iceland_jack> That law is not satisfied by your definition of fmap
02:54:08 <dleedev> zett_zelett, Iceland_jack: btw, thanks for the exercise
02:54:19 <dleedev> I think I realized what was wrong with my thinking before
02:54:40 <zett_zelett> Do you mean fmap id = id?
02:54:42 <Iceland_jack> zett_zelett: *fmap id = id
02:54:42 <Iceland_jack> yes
02:54:54 <zett_zelett> `by defining fmap id = id, fmap g = ()?`
02:55:12 <zett_zelett> Well, fmap id = id, fmap g = bot where bot = bot
02:55:15 <Iceland_jack> well 'fmap g = ()' is badly typed no?
02:55:44 <zett_zelett> Since the bottom value is a value of any type.
02:55:56 <Iceland_jack> yes but if you're using bottom you can do it much simpler
02:55:57 <zett_zelett> This gives a function (a -> b) -> f a -> f b.
02:55:59 <dleedev> I was thinking that Haskell considered functions as Functors because functions mapped domain to codomain, but actually it's because you can map one type of function (r -> x) to another type of function (r -> y)... am I right?
02:56:02 <Iceland_jack> and just define
02:56:02 <Iceland_jack>     fmap = ⊥
02:56:18 <zett_zelett> That wouldn’t satisfy fmap id = id.
02:56:35 <zett_zelett> You need fmap id = id and fmap g = const ⊥, but then it would be a functor, no?
02:57:22 <Iceland_jack> If you define
02:57:22 <Iceland_jack>     fmap g = const ⊥
02:57:22 <Iceland_jack> then how do the laws hold?
02:57:37 <Iceland_jack> const ⊥ ≠ id
02:59:01 <zett_zelett> fmap id = id; fmap g = const ⊥. Then, fmap id == id by definition.
02:59:14 <zett_zelett> Hm.
02:59:20 <Iceland_jack> Are you saying that ‘fmap id = id’ is a definition?
02:59:23 <Iceland_jack> I'm not sure I follow
02:59:30 <zett_zelett> Can’t you do that?
02:59:32 <Iceland_jack> no
03:00:21 <zett_zelett> Yeah, that makes sense.
03:00:22 <Iceland_jack> Wait, are you attempting to pattern match on the identity function?
03:00:27 <bezirg> hi, I am trying to build this datatype `Data.Map.Strict (MVar a) [a]` but I am not allowed since MVar has no Ord instance. What can I do?
03:00:32 <zett_zelett> Yes.
03:00:35 <Iceland_jack> ah
03:00:44 <zett_zelett> I dunno, is f 3 = 3 also pattern matching?
03:00:48 <Iceland_jack> yes
03:00:53 <zett_zelett> Yeah, makes sense.
03:01:07 <maxs`> bezirg: what is the problem you are trying to solve
03:01:26 <Iceland_jack> bezirg: You probably don't want to use MVar's as keys
03:02:13 <zett_zelett> Also, if f and g were inverse functions, thenn fmap (f . g) == id, but (fmap f) . (fmap g) == (const ⊥) . (const ⊥) = const ⊥.
03:02:59 <bezirg> maxs`: I have a lot of jobs waiting on an MVar and when the MVar is available I want to wake up all these jobs that are depending on it. So I thought to built a Data.Map (MVar a) Job
03:03:12 <zett_zelett> If f 3 = 3 is pattern matching, what is the hidden value constructor?
03:03:36 <zett_zelett> Oh.
03:03:37 <zett_zelett> 3.
03:03:40 <zett_zelett> Isn’t it?
03:03:57 <Iceland_jack> What do you mean by ‘hidden’?
03:04:34 <Iceland_jack> When you do ‘f 3’ it matches on ‘fromInteger 3’
03:05:05 <zett_zelett> fromInteger is no value constructor, though, but a mere function?
03:05:12 <zett_zelett> How can you pattern match on functions?
03:05:54 <Iceland_jack> just by a case
03:06:33 * hackagebot hsparql 0.2.4 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  http://hackage.haskell.org/package/hsparql-0.2.4 (RobStewart)
03:07:01 <Iceland_jack>     f 0 = "zero"
03:07:01 <Iceland_jack>     f _ = "non-zero"
03:07:01 <Iceland_jack> becomes something like
03:07:01 <Iceland_jack>     f x = if x == fromInteger 0 then "zero" else "non-zero"
03:07:07 <Iceland_jack>       
03:10:03 <maxs`> bezirg: use a [(MVar a, Job)] instead
03:10:55 <bezirg> maxs`: that's an association list?
03:10:59 <maxs`> yeah
03:11:02 <bezirg> I like it
03:11:35 <killy9999> hm...
03:11:37 <killy9999> if I do
03:11:41 <killy9999> ghc Source.hs
03:11:43 <bezirg> maxs`: I know that it is not that efficient as a Data.Map. Are there any operations like update of an association list already builtin in a library?
03:11:55 <killy9999> and Source.hs is using import from the library
03:12:05 <killy9999> do I need to pass in some extra parameters to GHC ?
03:12:36 <Axman6> killy9999: that should be fine, it should compile a program, assuming main is defined in Source.hs
03:12:52 <killy9999> right
03:12:54 <killy9999> thanks
03:14:36 <maxs`> bezirg: lookup mvar will give you a Job. If you need to update, you should use a Vector instead.
03:15:13 <Axman6> eh, I don't think Vector is necessary...
03:16:33 <maxs`> this is used as some sort of event loop right?...
03:17:06 <dleedev> @src Functor
03:17:07 <lambdabot> class  Functor f  where
03:17:07 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
03:17:30 <dleedev> is f the object-map and fmap the arrow-map?
03:18:08 <donri> are there no linux builds of ghc HEAD? the nightlies only seem to do windows, os x and source
03:18:27 <Iceland_jack> dleedev: Yes basically, the objects are types in ‘Hask’ and the arrows are functions
03:18:53 <bezirg> maxs`: y exactly
03:19:47 <donri> fmap :: Hask a b -> Hask (f a) (f b)
03:20:20 <bezirg> maxs`: let's say I pay the price for now and use a naive update on association lists. Which way I should go u think `[(MVar a, Job)]` or `[(MVar a, [Job])` considering that one-to-many mvar to job correspondence
03:20:38 <donri> fmap :: (a -> b) -> (f a -> f b)
03:21:13 <Iceland_jack> If we rename Haskel as ↝ then donri's type signature becomes
03:21:13 <Iceland_jack>     fmap :: (a ↝ b) → (f a ↝ f b)
03:21:18 <Iceland_jack> *Hask
03:22:09 <dleedev> Isn't Hask a category?
03:22:21 <notdan> it is
03:22:24 <donri> newtype Hask a b = Hask (a -> b) deriving Category
03:22:31 <Iceland_jack> Eh..
03:22:34 <donri> ;)
03:22:46 <notdan> (a ↝ b) is the Hom-set of morphisms from a to b
03:22:48 <dleedev> how are you using Hask (renamed ↝) as an operator ↝?
03:22:50 <mm_freak> type Hask = (->)
03:22:52 <notdan> which are exactly functions of type a->b
03:23:02 <maxs`> bezirg: (MVar a, Job) is probably conceptually simpler, I can't think of a strong reason for either right now
03:23:18 <bezirg> maxs`: ty
03:23:42 <Grivr> good day, dear Sirs, I have a one-liner which doesn't compile. Been trying to solve that for a couple of hours with no luck. Could anyone have a glance at it please?
03:23:44 <donri> the point is to emphasise how fmap is an endofunctor in Hask
03:23:59 <Grivr> https://gist.github.com/Grivr/16c1627885c1510fda58
03:24:31 <notdan> Grivr: and what is the error
03:24:32 <notdan> ?
03:24:53 <Grivr> it thinks that i use generic bitstream
03:25:12 <Grivr> but when i change to Data.Bitstream.Lazy.fromByteString
03:25:26 <Grivr> haskell just don't see the module
03:25:46 <notdan> Can you please paste the full error somewhere? I am not sure I understand
03:26:38 <dleedev> where can I read up on the "Category" class in Haskell?
03:26:50 <donri> dleedev: there's a version of Functor for arbitrary Categories here http://hackage.haskell.org/package/categories-1.0.6/docs/Control-Categorical-Functor.html which corresponds to the normal Functor when the two categories are (->) and (->) ie. an endofunctor in Hask
03:26:58 <notdan> fromByteString has a signature :: Data.Bitstream.Generic.Bitstream (Bitstream d) => ByteString -> Bitstream d
03:26:59 <Grivr> sure, please find it: http://pastie.org/8620247
03:27:30 <dleedev> donri: I'm not sure how to understand the Category class in haskell
03:27:45 <maxs`> Grivr: no type for `compressed` is found. Annotate it with a type
03:27:56 <notdan> Grivr: so fromByteString doesnt what the resulting type should be
03:28:02 <donri> dleedev: same as any type class: it's just some type signatures and laws (:
03:28:12 <donri> anything that satisfies those constraints can be a Category
03:28:25 <notdan> try annotating compress with "Bitstream Bool" or something
03:29:03 <dleedev> donri: I guess I don't understand the parameters to Category
03:29:32 <Aleksejs> dleedev, http://en.wikibooks.org/wiki/Haskell/Category_theory
03:29:35 <notdan> dleedev: when you say `Category cat` it means that cat is basically \a b -> Hom(a,b)
03:29:57 <notdan> dleedev: so the signature for `id' is `cat a a', e.g. Hom(a,a)
03:30:02 <dleedev> Hom(a,b) is the set of arrows between object a and b?
03:30:03 <notdan> so id is an arrow from a to a
03:30:06 <notdan> yes, exactly
03:31:08 <dleedev> notdan: what about Arrow, then?
03:32:03 <dleedev> Aleksejs: the wikibooks link doesn't show how to use the Category class
03:32:16 <matzo> Hi guys, I'm completely new here. Is it okay to look for help regarding a question about a specific package (in this case, the persistent package)?
03:32:46 <alireza> Hi, I have written a program but when I run it in ghci, I get this error: GHCi runtime linker: fatal error: I found a duplicate definition for symbol
03:32:46 <alireza>    get_current_timezone_seconds
03:32:54 <Axman6> matzo: ask away! Can't guarantee you'll get answers, but it never hurts :)
03:32:59 <alireza> can anyone please tell me how to solve this?
03:33:02 <matzo> It might be a misunderstanding/error on my side, but it might just as well be a strange bug in the package
03:33:02 <notdan> dleedev: sorry, which Arrow?
03:33:22 <dleedev> notdan: Arrow class in Haskell
03:33:24 <donri> dleedev: you use Category the same way you use id and (.) from prelude, but imported from Control.Category instead and generalized to not just functions
03:34:11 <matzo> Ok, it's a strange problem with the persistent package, in combination with the persistent-postgresql package as a backend
03:34:44 <matzo> I.e. I'm trying to update a value in the database using the -=. combinator in persistent
03:34:49 <matzo> Like this: http://lpaste.net/98278
03:34:59 <dleedev> @src Hask
03:34:59 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
03:35:14 <dleedev> :k Hask
03:35:15 <lambdabot> Not in scope: type constructor or class `Hask'
03:35:20 <Iceland_jack> dleedev: It's not an actual thing
03:35:22 <notdan> dleedev: I don't think they are the same as arrows in category theory
03:35:36 <matzo> (I'm of course willing to provide more, or even the entire code, I just tried to isolate the 'offending method' to keep the code short and concise)
03:35:39 <dleedev> notdan: is the Category class the same thing as categories in category theory?
03:35:46 <notdan> dleedev: you can see in fact that Category is a superclass for arrows
03:35:59 <notdan> dleedev: I think so
03:36:37 <Axman6> matzo: well, the code that causes the error and any errors you're getting would be a good place to start...
03:36:37 <donri> to the extent you can say anything in haskell is "the same as in category theory" :P
03:36:44 <dleedev> notdan: that's unfortunate that there's a class named Arrow that isn't referring to arrows of category theory
03:37:26 <matzo> Well, I don't get any compile or runtime errors. It's unexpected behavior. I'll expand the lpaste with a problem description.
03:37:46 <donri> mm_freak: what is Arrow in category theory?
03:38:09 <mm_freak> donri: no idea
03:38:12 <donri> :D
03:38:12 <mm_freak> there is a paper though
03:38:27 <allsystemsarego> isn't an Arrow a profunctor in CT?
03:39:23 <serious> sorry, seems no one got my question. When running ghci, I get the error  I found a duplicate definition for symbol
03:39:23 <serious>    get_current_timezone_seconds
03:39:23 <serious> whilst processing object file
03:39:23 <serious>    /home/alireza/.cabal/lib/time-1.2.0.5/ghc-7.4.1/HStime-1.2.0.5.o...........can anyone help on what this means?
03:39:30 <dleedev> why is it named Arrow?
03:39:31 <matzo> Here's the code, and an explanation of the strange behavior: http://lpaste.net/98278
03:40:18 <dleedev> I'm glad I found out that Arrow is not a category theory arrow before I tried to make sense out of Arrow
03:40:22 <allsystemsarego> relevant slideshare: http://www.slideshare.net/khibino/profunctor-and-arrow-17939130
03:42:16 <dleedev> is everyone OK with Arrow named that way?
03:42:32 <Iceland_jack> dleedev: Why not?
03:42:34 <dleedev> there must be a reason it was named Arrow in the first place...
03:42:48 <Axman6> it's the -> in a -> b
03:43:12 <notdan> dleedev: because it's a generalization of functions
03:43:12 <Axman6> but also useful for things like Kleisli or whatever it's called
03:43:27 <donri> serious: ghc-pkg list time ?
03:43:53 <allsystemsarego> dleedev, yes, because it takes a signature f :: a -> b and turns it into (->) f a b, in other words it does the infix-to-prefix thing
03:44:01 <matzo> So, basically, the -=. combinator in persistent doesn't do anything for me if the rhs is negative. It does work when the right hand side is positive, or if I change -=. to +=. and put the minus sign before the value on the rhs
03:44:18 <Grivr> maxs':yup, you was absolutely right, thank you very much, it works
03:44:34 <Grivr> notdan:thank you, sir! you've helped a lot
03:44:46 <maxs`> no problem
03:45:02 <matzo> Doesn't do anything must be interpreted as: no error, no complaint at runtime, simply no change in the database.
03:45:04 <serious> donri , wow
03:45:06 <Axman6> matzo: sounds like a bug on face value, might be worth reporting if you can come up with a small enough test case
03:45:12 <serious> I get two items
03:45:20 <serious> /var/lib/ghc/package.conf.d
03:45:20 <serious>    time-1.4
03:45:24 <dleedev> Iceland_jack: wait, so are you saying that the Arrow class does refer to arrow in category theory?
03:45:31 <Iceland_jack> no
03:45:34 <serious> and /home/alireza/.ghc/x86_64-linux-7.4.1/package.conf.d
03:45:34 <serious>    time-1.2.0.5
03:45:49 <maxs`> ghc unregister time-1.2.0.5 and brace for impact
03:46:01 * Axman6 puts on helmet
03:46:04 <Grivr> \q
03:46:15 * Axman6 kisses arse goodbye
03:46:26 <serious> does that mean I have two different time packages?
03:46:33 <dleedev> does "Arrow" refer to the symbol (->)?
03:46:34 <maxs`> sorry ghc-pkg unregister time-1.2.0.5
03:46:41 <maxs`> some library you use depended on that version
03:46:49 <Axman6> dleedev: I believe so
03:46:55 <matzo> Ok thanks Axman6
03:47:08 <dleedev> Axman6: ah, now it makes sense
03:47:16 <matzo> I'm glad it's not just me
03:47:18 <notdan> dleedev: all instances of Arrow are also instances of Category; so all 'Arrow's are arrows in categories too
03:47:23 <serious> how is ghc-pkg related to another tool called Cabal?
03:47:33 <notdan> but yeah, it's a generalization of (->)
03:47:48 <dleedev> notdan: because Category is actually an arrow?
03:48:21 <maxs`> ghc-pkg is a package manager. cabal is a build tool and dependency management tool (that calls ghc-pkg to install packages)
03:48:23 <Axman6> serious: cabal is the framework for creating and installing haskell libraries. part of the instalation is registering the package with ghc (using ghc-pkg or something like it)
03:48:37 <dleedev> notdan: you said that instances of Category are arrows, not categories, right?
03:48:46 <Axman6> maxs`'s answer is probably better
03:48:52 <maxs`> hmm idk
03:49:05 <notdan> dleedev: well, it's not correct to say 'Categoy is X' where X is some formal object of category theory
03:49:10 <Iceland_jack> dleedev: It sounds to me like you'd seriously want to consider learning Haskell or learning category theory for now
03:49:11 <notdan> 'Category' is a typeclass
03:49:24 <Iceland_jack> xor.
03:49:43 <serious> when I put the command "ghc-pkg unregister time-1.2.0.5", it outputs a list of packages for which the dependcies will be broken if I proceed.
03:50:00 <notdan> dleedev: 'Category x' says that Haskell's types together with hom-sets 'x a b' form a category
03:50:14 <dleedev> notdan: ah, thanks
03:50:34 <dleedev> notdan: and that's why you're saying 'Category x' is actually just arrows
03:50:51 <maxs`> there needs to be an interactive website explaining how to fix cabal when things go bad
03:51:07 <dleedev> notdan: because 'x a b' is a set of arrows
03:51:10 <Axman6> "Nuke everything and start again"
03:51:12 <notdan> yeah... kinda I am trying not to say that because it doesn't make much sense
03:51:17 <zomg> maxs`: or maybe cabal itself could be improved to handle it? :P
03:51:20 <maxs`> Or use cabal sandbox
03:51:26 <Iceland_jack> maxs`: Clippy: “It looks like you're trying to resolve dependencies.”
03:51:27 <maxs`> zomg: yeah I recon :P
03:51:27 <notdan> Yes, "x a b" is a set of arrows if x is an instance of Category
03:52:40 <dleedev> notdan: and all instances of Category have objects that are types in Haskell... doesn't that make every instance of Category a subcategory of Hask?
03:53:00 <shachaf> Where "set" means "type" and "arrow" means "a thing of type x a b for some types a and b"
03:53:43 <serious> thanks guys, now I can run my program.
03:53:54 <serious> But somehow, i cannot import System.Random anymore
03:54:27 <serious> before running the command "ghc-pkg unregister -force time-1.2.0.5 " , i could import System.Random, but not any longer
03:54:54 <dleedev> shachaf: so can a tuple (a, b) be an instance of Category?
03:55:43 <maxs`> serious: cabal install random, but watch it doesn't install time-1.2.0.5 again on you!
03:55:48 <notdan> dleedev: I don't think so, the definition of subcategory says that morphisms of a subcategory should be morphisms of supercategory with the same id's and composition
03:56:36 <notdan> dleedev:
03:56:39 <maxs`> serious: if it does, I recommend actually fixing the bug. i.e. downloading time, removing that symbol and cabal install-ing it
03:56:45 <notdan> oops, sorry for the last hilight
03:57:15 <serious> thanks max
03:57:19 <serious> thanks maxs
03:57:19 <shachaf> (,) cannot be an instance of Category. If you try to make it one you will find out why.
03:57:21 <maxs`> oh that version is really old
03:57:27 <maxs`> they must of fixed it
03:57:36 <serious> which version ?
03:57:42 <maxs`> of time-1.2
03:57:50 <maxs`> 2011
03:58:20 <serious> i dont know how to download a package or how to remove a symbol from it
03:58:34 <maxs`> serious: yeah, so don't worry about that today :)
04:00:48 <serious> my ghci was working fine until I installed the EclipseFP plugin. Could it be that that software broke my dependencies, because I remember it started to install a whole lot of things
04:00:49 <serious> ?
04:01:20 <matzo> Axman6: http://lpaste.net/98283 I guess this would be an ok test case? This gives the same erratic behavior as my (only marginally) larger code.
04:02:31 <matzo> And something else: what other information should I provide? A description of the erratic behavior of course, and I suppose the version numbers of persistent, persistent-postgresql, is there anything else?
04:02:56 <maxs`> serious: yes, most likely. However, this tool can let you build programs without depending on system wide dependencies. http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
04:03:36 <Axman6> matzo: sounds like a good start. do you know of the package has a github repo? that'd be a good place to file the bug
04:03:54 <matzo> yes, it has, I'm already on there :)
04:03:56 <serious> maxs` thanks
04:07:14 <Sagi> hi everyone
04:07:39 <Sagi> what's the best way to have an offline hackage, mainly to view documentation while on the go?
04:08:20 <Sagi> I find that my Haskell productivity is much lower when I'm unable to access the internet due to lack of access to the docs, which feels stupid, because I know that shouldn't be necessary in the first place.
04:10:18 <maxs`> Sagi: the Haskell platform enables building documentation by default I think...
04:10:22 <hooplahoops> Is prepending values to lists more common in haskell code than appending?
04:10:41 <maxs`> hooplahoops: in Functional programming yes
04:10:47 <Axman6> prepending is O(1), appending is O(n)
04:10:58 <hooplahoops> maxs`: ok, cool
04:11:04 <Axman6> @src (++)
04:11:04 <lambdabot> []     ++ ys = ys
04:11:04 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:11:04 <lambdabot> -- OR
04:11:04 <lambdabot> xs ++ ys = foldr (:) ys xs
04:11:05 <hooplahoops> Right, thanks
04:11:28 <Axman6> and append is xs ++ [x], so it must traverse the whole first list
04:11:42 <maxs`> here is a list with O(1) append http://hackage.haskell.org/package/dlist
04:11:49 <hooplahoops> So cons cells really are typically heap allocated linked list values?
04:12:18 <Axman6> yes
04:12:35 <Axman6> unless the compiler eliminates them
04:12:39 <hooplahoops> Neat, very lispy
04:13:00 <hooplahoops> Axman6: what are typical optimizations to eliminate them, besides deforestation
04:13:24 <quicksilver> the typical usage of large lists is loops
04:13:32 <quicksilver> in which case the "whole list" never really exists
04:13:39 <quicksilver> it's being generated and consumed at the same rate
04:13:47 <quicksilver> that means all the allocation and GC is within the processor cache
04:13:51 <quicksilver> which makes it "free" in a sense.
04:13:59 <hooplahoops> Right, so that's the degenerate form of deforestation I suppose
04:14:15 <dleedev> it seems like most people in #haskell are fluent in category theory
04:14:17 <quicksilver> for long-lived data lists are often the wrong data type of choice
04:14:18 <dleedev> so general survey... which did you learn first: Haskell or Category Theory?
04:14:32 <quicksilver> category theory, but I don't think it helped my haskell in any way
04:14:39 <mr-> same
04:14:44 <hooplahoops> quicksilver: cool, thanks
04:14:47 <Axman6> Haskell
04:14:51 <Axman6> still don't know much about CT
04:14:58 <mornfall> I learned Haskell first, but I don't think it helped my Category Theory in any way.
04:15:02 <fizruk> same as Axman6
04:16:03 <Axman6> hooplahoops: well GHC does a lot of deforestation for all sorts of data types. the language shootout had to be changed because the haskell entries were never actually creating the trees the binary-trees benchmark asked for
04:16:27 <dleedev> mornfall: did you have trouble learning Category Theory because of what you "knew" about Functor, Monad, etc. from Haskell?
04:16:55 <mornfall> dleedev: No, I just don't think learning the two things is really related.
04:17:06 <maxs`> I think CT is only one way to "use" Haskell.
04:17:44 <dleedev> mornfall: but they share so much terminology that it would be hard to disassociate the two, no?
04:18:41 <mornfall> dleedev: monads are fairly obscure by CT standards I suppose
04:19:23 <Iceland_jack> If you want to learn category theory to understand monads in Haskell you're going to have a bad time
04:20:14 <dleedev> Iceland_jack: but why?
04:20:33 <mornfall> right, just because foo happens to be an instance of Bar doesn't mean it makes sense to study foo in terms of Bar
04:20:57 <mornfall> do I use model theory to think about C++ programs? not really
04:21:13 <mornfall> (or Haskell programs for that matter)
04:21:13 <hooplahoops> Axman6: heh :)
04:21:15 <Sagi> maxs`: ah, I'll have a look at the debian package for the platfo then, thanks
04:21:18 <Iceland_jack> dleedev: What mornfall said basically
04:21:26 <Sagi> platform even
04:21:39 <Iceland_jack> If you don't understand how to use monads in Haskell before studying category theory you probably won't understand them after studying it
04:21:46 <maxs`> Sagi: it is just a setting in your global cabal config, but you do need to rebuild all your packages
04:22:48 <dleedev> Iceland_jack: the thing is I believe I understand Monads in Haskell. I just don't know how to think of them as monads in category theory.
04:23:10 <Iceland_jack> dleedev: You can study category theory if you really want to then
04:23:12 <dleedev> Iceland_jack: and because of the mismatch, I lose confidence in my understanding of Monads in Haskell.
04:23:39 <mornfall> Yeah, Monad was a very crummy choice of names. :-)
04:23:42 <Iceland_jack> I've heard so many experienced Haskell programmers come up to me seriously doubtful that they understand monads
04:24:07 <Iceland_jack> The definition of a ‘monad’ is very simple and boring, the examples of monads aren't
04:24:13 <Axman6> I don't think I "understand" monads, and I've been programming with haskell for about 6 years
04:24:15 <quicksilver> dleedev: do you also believe you understand them in category theory?
04:24:22 <Iceland_jack> I suppose people think there is more to monads than there is
04:24:28 <Sagi> maxs`: hmm, that means it'll only benefit me for locally built packages (e.g. cabal-dev), right?
04:24:29 <dleedev> quicksilver: no, hence the mismatch
04:24:55 <Sagi> maxs`: unless there is some haskell platform doc package
04:24:56 <quicksilver> dleedev: ok. So is "thinking of Haskell Monads as categorical monads" a personal goal of yours?
04:25:02 <Iceland_jack> dleedev: Do you know what natural transformations are?
04:25:04 <quicksilver> dleedev: (and if it is, why is it?) ;)
04:25:14 <dleedev> Iceland_jack: barely
04:25:25 <dleedev> quicksilver: because I want to understand why Monads were named Monads
04:25:37 <Iceland_jack> sigh
04:25:37 <dleedev> quicksilver: then I can intuit what other things can be Monads
04:25:56 <Iceland_jack> dleedev: You can ‘intuit’ that without knowing category theory if you know the monad laws
04:26:13 <mornfall> they are arrows in functor categories? :-P
04:26:26 <maxs`> Sagi: it is just cabal. in ~/.cabal/config set documentation: True
04:26:27 <dleedev> Iceland_jack: but I don't know why the laws are there
04:26:41 <quicksilver> dleedev: OK, well the place to look for intuition might be "join"
04:26:43 <mornfall> dleedev: why are prime numbers there?
04:26:53 <mornfall> some things are not meant to be known
04:26:54 <Iceland_jack> Then *that* sounds like your actual question, not learning category theory
04:27:01 <Iceland_jack> but what ever
04:27:03 <dleedev> mornfall: for RSA of course =P
04:27:12 <quicksilver> dleedev: a monad is a structure which you can impose twice (to make a structure of structures) and then collapse that
04:27:26 <quicksilver> the laws specify the rules that collapse must obey.
04:27:42 <quicksilver> nested lists are a simple example.
04:29:25 <dleedev> quicksilver: yes, that much I know from Haskell's Monads. But why is that useful? What does it provide us?
04:29:43 <Iceland_jack> dleedev: What does ‘fmap’ provide you?
04:29:58 <quicksilver> dleedev: it's not supposed to be obvious :)
04:29:59 <Iceland_jack> Imagine if you remove one of the Functor laws and try to find useless definitions
04:30:22 <quicksilver> dleedev: it was a surprising insight that quite a few interesting notions of 'computation' take the form of collapsing structures in that sense.
04:30:44 <quicksilver> dleedev: you might find Moggi's original paper readable if you're interested in where the idea comes from.
04:31:01 <Sagi> maxs`: oh duh, debian does have a haskell-platform-doc package which pulls in the platform docs, so in addition to your suggestion, there's also an easy solution for stuff I pull through apt.
04:31:02 <dleedev> quicksilver: do you have a link?
04:31:06 <Sagi> maxs`: thanks!
04:31:26 <Iceland_jack> dleedev: Do you know about groups? Why do they have the laws they have? Why do they have the operations they have?
04:31:27 <quicksilver> dleedev: http://www.cs.cmu.edu/~crary/819-f09/Moggi91.pdf
04:31:46 <maxs`> Sagi: :)
04:31:48 <mornfall> Iceland_jack: that question bothers me :-)
04:31:58 <Iceland_jack> mornfall: It should! :)
04:31:59 <dleedev> Iceland_jack: I don't know why at all
04:32:33 <Iceland_jack> dleedev: ⅰ) People find ubiquitous, useful patterns, ⅱ) People make those patterns concrete by giving them names and laws
04:32:54 <quicksilver> groups are interesting because associativity is interesting.
04:33:04 <quicksilver> that's a little bit glib and simplifed, but basically.
04:33:07 <Iceland_jack> Monads are interesting for the same reason then :)
04:33:18 <hooplahoops> If I do something like (map f xs) and consume the result multiple times, does that prevent deforestation from triggering?
04:33:24 <Sagi> maxs`: oh wow, there's even a hoogle package for local api search. This is brilliant
04:33:27 <quicksilver> yes, but here the associativity is "associativit of collapse of nested structures"
04:33:43 <quicksilver> hooplahoops: no.
04:33:52 <quicksilver> hooplahoops: but it does mean you have the result definitely stored in memory.
04:34:08 <quicksilver> it is only calculated once and any deforestation involved in its production will still be fine.
04:34:15 <Iceland_jack> dleedev: http://www.haskell.org/haskellwiki/Monad_laws There you go
04:34:21 <Iceland_jack> “2 But why should monads obey these laws?”
04:34:32 <Iceland_jack>  Left identity:
04:34:32 <Iceland_jack>  return >=> g
04:34:32 <Iceland_jack> ≡
04:34:32 <Iceland_jack>  g
04:34:35 <Iceland_jack> Right identity:
04:34:36 <hooplahoops> quicksilver: right, yeah, it's kind of a "boundary"
04:34:39 <Iceland_jack>  f >=> return
04:34:40 <hooplahoops> quicksilver: thanks!
04:34:42 <Iceland_jack> ≡
04:34:45 <Iceland_jack>  f
04:34:48 <Iceland_jack> Associativity:
04:34:51 <Iceland_jack>  (f >=> g) >=> h
04:34:53 <quicksilver> Iceland_jack: erm?
04:34:55 <Iceland_jack> ≡
04:35:01 <Iceland_jack> ah! sorry
04:35:04 <quicksilver> :)
04:35:09 <bezirg> question: I am checking the API of Data.Map but there is no operation that deletes an element and returns the updated map paired with a Maybe removed value
04:35:10 <Axman6> the link was fine by itself...
04:35:20 <Iceland_jack> Axman6: I know, I didn't mean to paste the rest
04:35:27 <Axman6> =)
04:36:17 <dleedev> Iceland_jack: basically, the usefulness of monads comes from the fact that you can associatively compose functions of form (a -> m b), right?
04:37:10 <Iceland_jack> dleedev: Associativity is one of many useful properties
04:37:11 <quchen> bezirg: updateLookupWithKey?
04:37:11 <quicksilver> bezirg: you can do that with updateLookupWithKey
04:37:25 <quicksilver> bezirg: (the function you pass as the first argument should be \k a -> Nothing)
04:37:39 <Iceland_jack> function composition is also associative, addition is also associative,
04:37:41 <bezirg> oh nice, thank you!
04:38:07 <dleedev> Iceland_jack: so what more do monads provide?
04:38:24 <quicksilver> dleedev: that is absolutely one way of saying it.
04:38:28 <mornfall> Iceland_jack: not on IEEE floats though :-P
04:38:31 <Axman6> I wish Data.HashMap.* has a insertDefaultWith :: (v -> v -> v) -> k -> v -> HashMap k v -> HashMap k v
04:38:45 <Iceland_jack> mornfall: duh :P
04:38:51 <mr-> dleedev: You have been interested in CT, haven't you? One interpretation of these laws is that the Kleisli-category is actually a category, with return being the identity and >=> the composition.
04:39:02 <Axman6> or insertWithDefault
04:39:08 <quicksilver> dleedev: as a categorist what you just said is "m is a Monad if and only if (Kleisli m) is a Category"
04:39:22 <quicksilver> which is a well known CT theorem.
04:39:32 <Iceland_jack> dleedev: There is a reason why the definition of a category includes identity + associative composition
04:39:47 <dleedev> Iceland_jack: what's that reason?
04:39:52 <Iceland_jack> It's useful!
04:40:00 <Axman6> are there examples of m where Kleisli m isn't a category?
04:40:05 <dleedev> Iceland_jack: haha, ok
04:40:21 <mornfall> Because you can't get very far with magmas.
04:40:35 <mr-> Axman6: How do you define Kleisli m when m is not a monad?
04:40:52 <Iceland_jack> yes, you can strip properties away from your objects and they will become less and less interesting and useful
04:40:55 <quicksilver> Axman6: yes, the same as example of m where m is not a Mona
04:40:55 <mornfall> mr-: I think m is not a monad was the point. :)
04:41:00 <Axman6> well, I've heard rumours of things you can define as Monad that aren't monads
04:41:05 <Iceland_jack> (Well that's not true)
04:41:21 <Axman6> mysterious strange things
04:41:22 <Iceland_jack> Axman6: Some people do it to (ab)use do-notation
04:41:28 <Iceland_jack> if that's what you mean
04:41:37 <Axman6> Foo a = Foo (a,a) is one isn't it?
04:41:47 <mornfall> You can probably do it accidentally.
04:41:52 <mr-> Axman6: it's like quicksilver said, it is a monad if and only if Kleisli m is a category
04:42:20 <mornfall> mr-: Thing is, Haskell won't know if your Monad (typeclass) is not a monad.
04:42:25 <dleedev> I think this is where understanding category theory comes into play... defining Monads that aren't monads
04:42:55 <mornfall> dleedev: as long as you obey typeclass laws it's all fine
04:42:57 <Iceland_jack> dleedev: Haskell won't check the laws for you
04:43:11 <mr-> mornfall: yes, so the answer is, Kleisli m is not a Category when m is not a monad
04:43:13 <mornfall> dleedev: you don't need to know anything about CT for that
04:43:29 <dleedev> OK, nevermind
04:44:13 <dleedev> I guess another usefulness of understanding CT is knowing how Functor, Applicative, Monad, Category, Arrow, etc. all relate to one another
04:44:15 <mornfall> dleedev: but if you obey Monad laws, your Monads will be monads and world will be saved
04:44:28 <mr-> Yay
04:44:51 <Iceland_jack> I think you're overestimating how useful it is to Haskell
04:45:00 <mornfall> lllllllllllll: you have a bad case of connection hiccup
04:45:14 <mr-> What is the CT-interpretation of Applicative anyway?
04:45:50 * quchen wonders how often "but CT is surely useful to understand X" - "no, you don't need CT to understand X in Haskell" is going to be iterated here right now.
04:46:15 <Iceland_jack> quchen: I agree, let's make CT a bannable topic :)
04:47:18 <mornfall> Yeah, enough CT, the sky outside has a beautiful shade of blue. I am out of here. _o/ :-)
04:47:21 <dleedev> did the terms "functor", "monad", etc originate in the programming world, or did they originate in CT?
04:47:31 <bezirg> is there a function like Data.Map.updateLookupWithKey for association lists?
04:48:02 <bezirg> I want to delete an entry based on a key and return the updated association list together with the removed value
04:48:22 <Saizan> mr-: something like closed monoidal functor
04:48:22 <quicksilver> bezirg: no, there are very few functions for use on association lists
04:48:27 <quicksilver> they're probably a bad thing to use :)
04:48:39 <quicksilver> you can of course use fromList and then use Data.Map
04:48:51 <Iceland_jack> quicksilver: I believe the problem was Ord
04:48:57 <quicksilver> dleedev: they originated in CT
04:49:13 <quicksilver> although functor is complicated
04:49:15 <bezirg> quicksilver: yeah Iceland_jack is right, I cannot user Data.Map because of no Ord for my key type
04:49:28 <quicksilver> it might have emerged indepedently more than once
04:49:43 <quicksilver> and it has been used to mean different things
04:50:09 <quicksilver> I tried to track it down once but was unable to find convincing ansewrs on the internet
04:51:51 <mr-> Saizan: Ah, thanks
04:52:37 <dleedev> quicksilver: I was hoping it was the other way around
04:52:37 <quicksilver> Saizan: strong lax :)
04:52:46 <quicksilver> http://cstheory.stackexchange.com/questions/12412/explaining-applicative-functor-in-categorical-terms-monoidal-functors
04:54:39 <tdammers> not to mention that the OOP world calls a class that's been rigged up so that it can be called like a function a "functor", even though it's really more of a closure
04:55:24 <quicksilver> tdammers: that's what I meant 'used to mean different things'
04:55:28 <Iceland_jack> Yes words are assholes
04:55:34 <Iceland_jack> Polysemic assholes
04:55:42 <quicksilver> tdammers: it's used quite loosely in some contexts to mean "quite like a function but not a function"
04:55:56 <quicksilver> tdammers: (and used quite specifically in some OOP languages to mean something very precise)
04:57:43 --- mode: ChanServ set +o mauke
04:57:44 --- mode: mauke set +b lllllllllllll!*@*
04:58:21 <dleedev> why is the Reader monad called a Reader if you can write to it using 'local'?
04:58:28 <mauke> local doesn't write
04:58:35 <mauke> it locally overrides
04:58:48 <Iceland_jack> dleedev: Just like shadowing variables isn't mutation
04:59:01 <dleedev> maxs`: how far is the local visible?
04:59:14 <Iceland_jack> @ty local
04:59:15 <lambdabot> MonadReader r m => (r -> r) -> m a -> m a
04:59:21 <Iceland_jack> only in the first 'm a'
04:59:30 <dleedev> oops, I meant mauke
04:59:44 --- mode: mauke set -o mauke
05:00:00 <tdammers> quicksilver: I've been doing a bunch of C++ lately... I guess it's showing...
05:00:27 <Iceland_jack> http://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Reader-Class.html#v:local
05:00:33 <quicksilver> dleedev: inside it.
05:00:57 <quicksilver> do a; local (+1) b; c;
05:01:06 <quicksilver> ^^ only 'b' gets the locally +1'ed version
05:01:18 <quicksilver> although 'b' can be an arbitrary complex action, of course.
05:01:38 <quicksilver> it feels a bit like the dynamic scoping of perl's "local()" although it isn't really.
05:03:12 <dleedev> quicksilver: so then b must be holding onto the old version somewhere, right?
05:03:19 <dleedev> quicksilver: because b has to pass the old environment to c
05:03:34 <mauke> dleedev: no, it doesn't
05:03:34 <quicksilver> I'm not sure how useful that kind of intuition is, but
05:03:39 <quicksilver> "no" is the answer
05:03:44 <mauke> b doesn't know about c
05:03:49 <Iceland_jack> b doesn't do anything
05:03:55 <quicksilver> my unnamed action - the whole thing - holds onto the old value
05:04:01 <quicksilver> 'b' gets run in a context with the new value
05:04:12 <quicksilver> 'c' is run in the original context with the original value
05:05:08 <mauke> \x -> do a; let x = "stuff" in b; c  -- similar?
05:05:17 <dleedev> where can I see the source for local's implementation?
05:05:31 <mauke> depends on which implementation you want
05:05:40 <mauke> @src (->) local
05:05:40 <lambdabot> local f m = m . f
05:05:48 <mauke> @src Reader local
05:05:48 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
05:05:50 <mauke> aww
05:06:16 <dleedev> @src MonadReader local
05:06:16 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
05:06:55 <mauke> that can't be right; MonadReader isn't a type
05:08:06 <quicksilver> I would not recommend teaching dleedev to use @src :)
05:08:19 <Axman6> heh
05:08:21 <dleedev> quicksilver: why not :(
05:08:22 <quicksilver> dleedev: either the main library docs on the GHC website, or hoogle which links into them.
05:08:36 <quicksilver> dleedev: because @src is a little throw away tool which should have been thrown away.
05:08:51 <Axman6> @src IO
05:08:51 <lambdabot> Source not found. Abort, Retry, Panic?
05:08:58 <Axman6> wut, when did that happen
05:09:36 <quicksilver> dleedev: http://www.haskell.org/ghc/docs/latest/html/libraries/ is a good link
05:09:50 <quicksilver> (but the mtl isn't in there so no Reader)
05:10:00 <dleedev> quicksilver: is this good: http://hackage.haskell.org/package/mtl-2.1.2/docs/src/Control-Monad-Reader-Class.html#local
05:10:25 <quicksilver> yes
05:10:50 <mauke> dleedev: @src isn't real sources, it's just a text file someone wrote
05:11:12 <maxs`> nothing is real anymore
05:13:44 <quicksilver> Axman6: no idea, but I'm glad it did. The misinformed conversations about State# and RealWorld# were bad for me :)
05:14:22 <Axman6> bah, it so makes sense
05:14:58 <mauke> as a haskell beginner, RealWorld is terrible and should go
05:15:16 <quicksilver> can you really claim to be a haskell beginner, mauke?
05:15:39 <mauke> technically yes, but I can claim to remember being a haskell beginner
05:16:34 <mauke> and I remember the RealWorld stuff being a hindrance in understanding IO
05:17:20 <quicksilver> the haskell beginner who knew too much
05:17:46 <mauke> it's not even knowledge
05:17:50 <mauke> RealWorld is just nonsense
05:17:59 <mauke> it explains nothing
05:19:45 <quicksilver> I have a proposal
05:20:19 <mauke> is it modest?
05:20:27 <quicksilver> rename State# to Pointless# and rename RealWorld# to Nonsense#
05:20:40 <quicksilver> I try to avoid being modest.
05:21:33 <Axman6> what's a better implementation of IO then?
05:22:30 <mauke> Axman6: strings
05:22:49 <Axman6> do strings let me have forkIO?
05:22:53 <mauke> yes
05:22:55 <mauke> "forkIO"
05:23:09 <Axman6> oh, you're suggesting "IO"
05:23:19 * Axman6 hand quotes
05:23:46 <quicksilver> Axman6: IO can't be implemented inside haskell. To pretend it can does no favours from a pedagogical perspective.
05:23:54 <mm_freak> i didn't realize that boomerang is so modular
05:24:07 <mauke> data IO :: * -> * where Return :: a -> IO a; Bind :: IO a -> (b -> IO b) -> IO b
05:24:11 <quicksilver> Axman6: a "better" implementation of IO uses the primitive extension mechanism of the compiler.
05:24:11 <mm_freak> stuff that uses TH generally appears quite static and hardcoding
05:24:19 <dleedev> "IO" "IO" it's off to school we go.. To learn some junk.. and then we flunk! "IO" "IO"
05:24:48 <quicksilver> Axman6: .. and that's what GHC does. It's unfortunate that GHC's basic extension language resembles haskell, because it tricks some people into thinking it is haskell.
05:25:01 <Axman6> pfft
05:25:06 <mauke> quicksilver: I like the cut of your jib
05:25:13 <quicksilver> I stop short of saying it was the wrong choice for GHC - it might well be an excellent choice. But it's "unfortunate".
05:25:28 <quicksilver> in terms of helping otehr people understand.
05:25:40 <quicksilver> You can of course *model* IO in pure haskell.
05:26:03 <quicksilver> but such a model might not be useful to an actual compiler - it might not be a remotely possible to express an efficient in a way which uses that model.
05:26:15 <quicksilver> s/efficient/efficient implementation/
05:26:18 <dleedev> quicksilver: how do you model IO in pure haskell?
05:26:30 <mauke> RealWorld
05:26:32 <quicksilver> like mauke showed is a fairly direct approach
05:26:47 <quicksilver> but there are lots of flavours
05:26:54 <mauke> quicksilver: I think I get it now
05:26:56 <quicksilver> depending how deep you go
05:27:24 <mauke> RealWorld is something you can use to model IO, but it's useless for actually doing I/O
05:27:25 <dleedev> sorry, where did mauke show us?
05:27:41 <dleedev> can you repaste the line?
05:27:43 <mauke> dleedev: data IO :: * -> * where Return :: a -> IO a; Bind :: IO a -> (b -> IO b) -> IO b
05:27:55 <mauke> (not a complete implementation)
05:28:05 <mauke> you probably want at least PutChar and GetChar in there
05:29:05 <Axman6> and forkIO
05:29:07 <Axman6> implement that one
05:29:21 <Axman6> and newMVar
05:29:29 <dleedev> mauke: how does RealWorld interact with data IO?
05:29:56 <mauke> dleedev: it doesn't
05:29:58 <bennofs> Would it be possible to implement a JIT compiler for haskell? (Or maybe GHC core)
05:30:17 <mauke> Axman6: yes, it all depends on which parts you want to model
05:30:34 <Axman6> all of it
05:30:43 <Axman6> especiallt forkIO
05:30:44 <Axman6> t*
05:30:54 <dleedev> mauke: I thought you said that line was the one that shows how to model IO using RealWorld
05:31:12 <mm_freak> dleedev: if you understand IO as a domain-specific language for programs, then it becomes a lot less magic
05:32:48 <dleedev> mm_freak: I find that one drawback with thinking of IO as such is that the functions that interact with IO are not part of the DSL, and thus not part of the program
05:33:07 <mm_freak> dleedev: not sure what you mean
05:33:27 <mm_freak> functions do not interact with IO, they can take IO actions and return IO actions
05:33:56 <dleedev> mm_freak: right, but the logic of which IO actions to return is not itself encoded in the DSL
05:34:09 <mm_freak> dleedev: i don't understand
05:34:24 <dleedev> mm_freak: maybe I'm the one not understanding :)
05:34:50 <mm_freak> dleedev: do you understand the GADT above?
05:35:05 <dleedev> mm_freak: mauke's?
05:35:14 <mm_freak> yes
05:35:56 <mm_freak> dleedev: it's just regular data with constructors, not much different from how you would define a list or tree type…  this way you can also define a Program type
05:36:25 <mm_freak> data Brainfuck = MoveLeft | MoveRight | Incr | Decr | …
05:37:19 <mm_freak> mauke's IO is essentially like this Brainfuck type, except that it allows a lot more interaction with the real world than just reading and printing bytes
05:38:09 <dleedev> mm_freak: what's IO's kind?
05:38:15 <mm_freak> * -> *
05:38:37 <dleedev> mm_freak: is that a function?
05:38:54 <mauke> ...
05:38:55 <mm_freak> well, a type function…  it takes a type and returns a type
05:39:03 <mm_freak> IO :: * -> *
05:39:05 <mm_freak> Integer :: *
05:39:08 <mm_freak> IO Integer :: *
05:39:12 <mauke> Maybe :: * -> *
05:39:26 <dleedev> ah, a type constructor?
05:39:30 <mauke> yes
05:40:49 <dleedev> Isn't that the standard definition?
05:40:51 <dleedev> data IO :: * -> * where Return :: a -> IO a; Bind :: IO a -> (b -> IO b) -> IO b
05:41:03 <dleedev> how's that different from the real IO?
05:41:11 <mm_freak> dleedev: then 'return' and (>>=) would be all you get
05:41:32 <mm_freak> main = return () >>= return
05:41:41 <Axman6> IO a = State# RealWorld# a in GHC
05:42:15 <Axman6> and State# s a = State# (s -> (a,s)) or something similar
05:42:47 <quchen> No, no no no nono no. IO is not a State thing.
05:42:52 <mornfall> mm_freak: the non-intuitive bit is where you get values out of IO and apply functions to those values
05:43:19 <Axman6> quchen: sure it is, it's the state of the outside world
05:43:22 <Axman6> >_>
05:43:27 <mm_freak> well, that's where execution comes in
05:43:32 <mm_freak> Axman6: no, it's not
05:43:33 <mauke> Axman6: the outside world is not a value inside your program
05:43:37 <mauke> that's not how the universe works
05:43:48 <Axman6> sure it is
05:43:52 <mornfall> mauke: tell that to GHC folks ;-)
05:43:57 <dleedev> mauke: I asked, "how do you model IO in pure haskell?", and you answered, "RealWorld", then proceeded with the data IO :: * -> * definition
05:44:00 <mm_freak> Axman6: in the real implementation it's just used to build a data dependency, such that effects are ordered
05:44:01 <quicksilver> mornfall: they are very well aware of that.
05:44:04 <dleedev> mauke: did I misunderstand you?
05:44:05 <mauke> dleedev: both are possible
05:44:11 <mm_freak> Axman6: RealWorld# is really just a misleading name
05:44:14 <Axman6> mm_freak: right
05:44:22 <quicksilver> mornfall: they know that it's just a syntactic hack which gets the right result out of their code generator.
05:44:33 <dleedev> mauke: so the data IO :: * -> * definition is NOT the one for RealWorld?
05:44:41 <mauke> dleedev: yes
05:44:41 <dleedev> mauke: you were giving two alternates?
05:44:50 <mauke> RealWorld was more of a joke
05:44:53 <mm_freak> Axman6: also i don't recommend dumping the real definition of IO onto beginners ;)
05:45:04 <mornfall> quicksilver: sure, but they chose to give it names like State# and RealWorld#
05:45:12 <Axman6> he seemes old enough to handle the truth :P
05:45:23 <mornfall> well, it's not the real definition
05:45:28 <mornfall> it just happens to be what GHC uses
05:45:44 <quicksilver> mornfall: they did. Perhaps they regret that, perhaps they don't.
05:45:45 <Axman6> right, it's just the only real definition that matters :P
05:46:02 <quicksilver> mornfall: I regret it, because it gives people the wrong intuition and leads them to wrong conclusions.
05:46:15 <mm_freak> IO a = Dep# Existing# a
05:46:23 <quicksilver> Axman6: that language - GHC's implementation language - is unlike haskell in important respects.
05:46:39 <quicksilver> Axman6: it has complete control of strictness, laziness, and evaluation order
05:46:44 <quicksilver> Axman6: and it has true mutation.
05:46:51 <mauke> Axman6: it doesn't matter at all
05:47:24 <quicksilver> it share a haskell-like syntax because that's how they chose to implement it; as language extensions which align with the syntax of the target language
05:47:28 <Axman6> it does if I want to play with ST...
05:47:49 <quicksilver> but it's a different language and in *that* language, functions aren't pure
05:47:53 <quicksilver> they can really have side effects
05:48:03 <quicksilver> RealWorld# is a book-keeping trick
05:48:04 <mauke> Axman6: no
05:48:12 <dleedev> well folks, I'm going now. Thanks for all the chat!
05:48:20 <mm_freak> you could implement IO like this:  newtype IO a = IO (forall w. w -> (a, w))
05:48:21 <quicksilver> and the actual mutation is performed by real side-effecting functions, just like non-pure languages.
05:48:22 <mauke> I've used ST before
05:48:24 * Axman6 is also done baiting
05:49:04 <dleedev> many thanks to all those who've helped me
05:49:08 <dleedev> see you later
05:49:38 <Axman6> how do other compilers implement IO?
05:49:45 <mm_freak> or even like this:  newtype IO a = forall o. IO (forall i. i -> (a, o))
05:52:00 <mm_freak> but RealWorld# probably allows some useful optimizations
05:52:08 <mm_freak> like removing it =)
05:52:46 <Axman6> hard to remove something which doesn't exist right? isn't it defined as data RealWorld#?
05:52:56 <Axman6> EmptyDataDecls?
05:53:39 <mm_freak> Axman6: i don't know how it's defined, but it's assumed to contain at least one defined value
05:54:02 <mm_freak> because ∀ a. ⊥ `seq` a = ⊥
05:54:43 <fizruk> newtype IO a = IO (forall r. (a -> r) -> (forall i o. FFI o i -> o -> (i -> r) -> r) -> r)http://comonad.com/reader/2011/free-monads-for-less-3/
05:57:44 --- mode: ChanServ set +o mauke
05:57:44 --- mode: mauke set -b lllllllllllll!*@*
05:59:44 --- mode: mauke set -o mauke
06:07:43 <dabd> Is it possible to have access to an unexported function?
06:08:25 <dabd> ex: I'd like to test the cardSetVector function from https://hackage.haskell.org/package/poker-eval-0.3.1/docs/src/Data-Poker-Deck.html#singleton
06:09:02 <fizruk> dabd: use .Internal module ?
06:09:19 <fizruk> nevermind
06:09:50 <dabd> fizruk: haskell newbie here...
06:10:28 <fizruk> dabd: I'd expect Data.Poker.Deck.Internal module to export functions not exported by Data.Pocker.Deck
06:10:40 <fizruk> dabd: but that's not the case with this package
06:10:42 <dabd> it doesn't export cardSetVector
06:11:25 <fizruk> dabd: I think the only way is to get sources and test it directly (e.g. add cardSetVector to export list)
06:11:29 <hape01> In emacs haskell-mode (with ghc-mod) You can do:  C-M-d   ghc-browse-document ...  that is useful to lookup documentation, happy having found this
06:12:13 <dabd> fizruk: so I would need to recompile the whole package?
06:12:58 <fizruk> perhaps
06:13:28 <fizruk> I don't think it will take long
06:14:06 <dabd> what debugging/tracing? never tried it in haskell
06:16:34 <dabd> what about*
06:16:51 <fizruk> dabd: see Debug.Trace module
06:17:15 <dabd> ok ty
06:23:22 <bennofs> Can a transaction that only writes retry in STM?
06:23:53 <Axman6> if it writes to more than one variable I think so
06:24:14 <bennofs> And if there are no other threads that also write?
06:24:25 <Axman6> then probably not
06:25:03 <syntaxwhyusohard> nice, there's actually a haskell channel :D
06:25:18 <t7> biggest channel on freenode
06:25:20 <linduxed> syntaxwhyusohard: and it is the bestest
06:25:23 <syntaxwhyusohard> will i be kicked for asked stupid programming questions? :D
06:25:23 <linduxed> :-D
06:25:34 <t7> syntaxwhyusohard: and banned
06:25:50 <linduxed> syntaxwhyusohard: no, you will be served four cups of love and an answer
06:25:51 <Axman6> but really, we love all genuine questions
06:25:54 <syntaxwhyusohard> the bestest? but there are twentington other channels out there?
06:26:09 <linduxed> we won the buntington
06:26:34 <quicksilver> bennofs: it's an interesting question, actually.
06:26:56 <linduxed> syntaxwhyusohard: what is the question which you wish to start off your journey with?
06:27:04 <quicksilver> bennofs: in GHC's implementation, a transaction which only writes even a single variable will retry if that variable has been modified concurrently.
06:27:09 <linduxed> syntaxwhyusohard: what knowledge do you wish us to impart you with?
06:27:18 <quicksilver> bennofs: this is not necessary for serialisation
06:27:25 <quicksilver> bennofs: it's just a conservative algorithm
06:27:30 <quicksilver> I think I raised a bug about it once
06:27:55 <bennofs> quicksilver: But it can't retry if it's the only thread writing, because then the variable can't change, right?
06:27:58 * Axman6 is being reminded of his databases course
06:28:17 <quicksilver> bennofs: absolutely.
06:28:27 <quicksilver> bennofs: concurrent modification is the only reason for retry.
06:28:36 <quicksilver> well, that and explicit use of 'retry'.
06:28:45 <quicksilver> https://ghc.haskell.org/trac/ghc/ticket/2028
06:28:53 <syntaxwhyusohard> thats for the offers to help! :)
06:29:12 <quicksilver> my hobby: writing bug reports the only effect of which is to force Igloo to move milestones 2 or 3 times per year.
06:29:26 <Axman6> heh
06:29:58 <Axman6> you're a bad man
06:30:09 <syntaxwhyusohard> i defined data Point = point Double Double Double -- so i can create 3-dimensional points
06:30:23 <syntaxwhyusohard> and want to use getX, getY, getZ on those
06:30:24 <Axman6> Point not point
06:30:32 <Axman6> I assume
06:30:33 <syntaxwhyusohard> type. Point = point ....
06:30:37 <syntaxwhyusohard> erm
06:30:40 <syntaxwhyusohard> Point = Point ...
06:30:42 <syntaxwhyusohard> like that :D
06:30:46 <Axman6> =)
06:31:44 <syntaxwhyusohard> and i can neither wrap my head around where to actually put the getX, nor how to define it exactly. depending on what I try, I either get an parser error, or didnt actually define getX correctly, or get indentation remarks
06:32:21 <quicksilver> getX (Point x y z) = x
06:32:21 <syntaxwhyusohard> first question: do I put the getX part into the main, or before it?
06:32:22 <Axman6> @where lpaste
06:32:23 <lambdabot> http://lpaste.net/new/haskell
06:32:25 <quicksilver> or..
06:32:30 <quicksilver> getX (Point x _ _) = x
06:32:52 <syntaxwhyusohard> thats what i did. getX (Point x y z) = x
06:33:20 <Axman6> where did you put it?
06:33:33 <Axman6> it should be a top level definition probably
06:34:14 <syntaxwhyusohard> atm its infront of the main. the main consists of "print $ X p ----- p = Point 1 2 3 ----also infront of the main
06:34:41 <quicksilver> you don't want X, you want getX
06:34:50 <syntaxwhyusohard> right now i get the "not in scope error" for the print commands
06:34:50 <quicksilver> you can't call the function X since that starts with a capital letter
06:34:52 <syntaxwhyusohard> oooh!
06:35:08 <syntaxwhyusohard> nice. now it's running :9
06:35:09 <syntaxwhyusohard> :)
06:35:12 <syntaxwhyusohard> thank you!
06:36:42 <syntaxwhyusohard> i assumed that getX defines X of a specific Point as x of that Point
06:38:30 <syntaxwhyusohard> so getX is just a variable then?
06:39:34 <quicksilver> it's just a name, yes
06:39:38 <quicksilver> it's the name of a function
06:41:37 <bennofs> Is there something for compile-time fixed-size multi-dimensional arrays in Haskell? It can use TH, idc
06:41:51 <the_berserker> > scanl (*) 1 [1..]
06:41:52 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
06:42:35 <the_berserker> > map (2^) [0..]
06:42:36 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
06:43:44 <the_berserker> > (scanl (*) 1 [1..]) 25
06:43:45 <lambdabot>  Couldn't match expected type `a0 -> t0' with actual type `[b0]'
06:44:22 <the_berserker> > (scanl (*) 1 [1..])!!35
06:44:23 <lambdabot>  10333147966386144929666651337523200000000
06:45:12 <Lethalman> interesting, all those trailing zeros
06:45:17 <Lethalman> > (scanl (*) 1 [1..])!!36
06:45:18 <lambdabot>  371993326789901217467999448150835200000000
06:45:25 <Lethalman> > (scanl (*) 1 [1..])!!12
06:45:26 <lambdabot>  479001600
06:46:33 <ion> lethalman: Anything * 10 has a trailing zero. Anything * 2 * 5 has a trailing zero. Etc.
06:46:48 <Lethalman> > (scanl (*) 1 [1..])!!111
06:46:49 <lambdabot>  1762952551090244663872161047107075788761409536026565516041574063347346955087...
06:46:52 <Lethalman> > (scanl (*) 1 [1..])!!11
06:46:53 <lambdabot>  39916800
06:46:59 <Lethalman> > (scanl (*) 1 [1..])!!3
06:47:00 <lambdabot>  6
06:47:18 <bennofs> > length $ dropWhile (/= '0') $ show $ (scanl (*) 1 [1..])!!111
06:47:19 <lambdabot>  171
06:47:39 <bennofs> > dropWhile (/= '0') $ show $ (scanl (*) 1 [1..])!!111
06:47:40 <lambdabot>  "090244663872161047107075788761409536026565516041574063347346955087248316436...
06:48:02 <bennofs> > length $ takeWhile (== '0') $ reverse $ show $ (scanl (*) 1 [1..])!!111
06:48:03 <lambdabot>  26
06:52:43 <Aleksejs> > foldl (*) 1 [2..111]
06:52:44 <lambdabot>  1762952551090244663872161047107075788761409536026565516041574063347346955087...
06:59:20 <bennofs> Is there a package that provides the `vector` functions, but using the `Ix` typeclass?
07:02:16 * hackagebot hdocs 0.3.0.0 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.3.0.0 (AlexandrRuchkin)
07:05:15 <Sculptor> hi!
07:05:42 <rioch_> Could someone help me understand this output in ghci: http://lpaste.net/374817007033384960
07:06:05 <rioch_> I don't understand why the function call produces a list with one item, but the direct call produces a list with multiple.
07:06:49 <bennofs> rioch_: the later let's shadow the earlier f
07:07:08 <rioch_> bennofs: I thought pattern matching was from top to bottom?
07:07:10 <bennofs> rioch_: so, it's the same as if you just performed the last let
07:07:37 <bennofs> rioch_: to define a function with pattern matching in ghci, you need to define all its clauses in one let
07:07:56 <rioch_> ahhh, ok. How do I separate each clause?
07:07:59 <bennofs> rioch_: so, for example, let f 0 = 0:[]; f 1 = 0:1:[]; f n = N:[]
07:08:08 <rioch_> Great. Thank you.
07:08:34 <bennofs> But if your definitions get more complex, it's usually easier to just load it from a file and develop it inside the file
07:12:17 * hackagebot hdocs 0.3.0.1 - Haskell docs tool  http://hackage.haskell.org/package/hdocs-0.3.0.1 (AlexandrRuchkin)
07:19:24 <hape01> L.writeFile "$HOME/out.html" quellcode    says  openBinaryFile: does not exist      I guess  $HOME is evil here. I could replace by what?
07:22:16 <supki> hape01: http://hackage.haskell.org/package/directory-1.2.0.1/docs/System-Directory.html#v:getHomeDirectory
07:22:35 <hape01> supli: Perfect, I'll use this
07:22:46 <hape01> supki: Perfect, I'll use this
07:30:23 <fryguybob> bennofs: A transaction that only writes can retry, but it will always block.  Since it never reads (the runtime does perform reads, but the transaction doesn't use them) nothing can change to make it take a different code path and avoid the retry.
07:40:48 <timthelion> I recal reading somewhere that ghci has a pronoun for the last result(it I think) but 'it' doesn't work in my version of GHCI.  Does the pronoun have to be turned on, or have I remembered it incorectly?
07:42:54 <zett_zelett> How can I export data constructors in modules?
07:42:59 <quicksilver> works for me, timthelion
07:43:17 <quicksilver> zett_zelett: TypeName(..) or TypeName(ConstructorName,ConstructorName)
07:43:39 <zett_zelett> Thanks!
07:44:06 <timthelion> quicksilver: wait, I'm a real idiot :D  I issued it, and got an error.  A type error.
07:44:12 * timthelion bangs head against wall.
07:53:03 <hape01> it seems http-conduit ignores parameters like ...?a=10 in URLs  to me
07:53:14 <hape01> when using simpleHttp
07:53:38 <dv-> hm what was that lang related to racket that had a more haskell-y syntax?
07:59:54 <hape01> dv-: Typed Racket and Lazy Racket come to my screen
08:02:24 * hackagebot symbol 0.2.1 - A 'Symbol' type for fast symbol comparison.  http://hackage.haskell.org/package/symbol-0.2.1 (GeoffreyMainland)
08:06:33 <Wardje> Hey, I've been working on a project and have been adding libraries to the .cabal file as I needed them. However, I didn't specify version numbers. Now that things seem to work, how would I go about adding the version numbers to the .cabal file? (To be more exact, how do I find out *which* numbers I should use)
08:09:04 <dv-> rename your cabal file and have cabal autogenerate with the versions for you?
08:09:14 <supki> Wardje: ghc-pkg field $package depends
08:12:25 * hackagebot creatur 4.2.0 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-4.2.0 (AmyDeBuitleir)
08:15:34 <tolt> Does anyone know of an alternative to the hashtables library that is threadsafe?
08:20:45 <quicksilver> tolt: did you already reject persistent alternatives?
08:20:51 <quicksilver> like data.map and hashmap?
08:21:24 <quicksilver> (by hashmap I mean unordered-containers)
08:22:07 <tolt> I haven't tried them. There aren't any strict requirements though so I'll try that. Thanks.
08:31:46 <tolt> quicksilver: I'm looking for something that can keep simple state across multiple threads
08:33:24 <companion_cube> you can pack a Map in a MVar (or TVar)
08:33:35 <quicksilver> tolt: put your data.map or data.hashmap into an MVar
08:33:52 <tolt> Ahh. Thanks.
08:36:07 <startling> is data-store well-recommended?
08:36:35 <startling> oh, maybe it's not what I want.
08:37:01 <startling> I want an in memory data-store. It doesn't have to use lens or anything -- I just want indexing etc.
08:37:20 <quicksilver> why don't you want data.map?
08:37:22 <solrize> macid-state or whatever they call it now ?
08:39:12 <quicksilver> that one is on disk and transactional, solrize, presumably not what startling is after
08:39:41 <startling> quicksilver, I need indexing by multiple keys.
08:39:46 <startling> Sorry, should have been more clear.
08:40:01 <startling> I've been using tables but I think I could benefit from something with more polish.
08:59:38 <ChongLi> startling: what about something like Data.IxSet?
09:01:10 <Sagi> is there any way to swap two monads / functors?
09:01:21 <ChongLi> swap?
09:01:22 <Sagi> say from Reader Maybe a to Maybe Reader a?
09:02:04 <Sagi> I want to lift a function in a Reader in the Maybe monad, but if I do that, the runReader gets a Maybe
09:02:17 <Sagi> which (obviously) causes a compile error
09:02:45 <Sagi> In my head the solution is simple: somehow get the Maybe pushed past the Reader, because that's exactly what I want. But I don't see how :-)
09:03:01 <startling> Sagi, I think you should be looking at monad transformers.
09:03:14 <ChongLi> yeah
09:03:25 <startling> Sagi, ReaderT r Maybe a = Reader r (Maybe a)
09:03:36 <klrr> is there a equaliant of (++) for Text's?
09:03:46 <startling> but its monad instance behaves as both of theirs.
09:03:55 <startling> klrr, you can always uses (<>) from Data.Monoid
09:04:17 <Sagi> startling: but I like the stack I have now, I just need to call some function of type Text -> Reader Foo with an argument of type Maybe Text.
09:04:38 <Sagi> startling: your proposal sounds a bit excessive to just deal with a Maybe wrapper
09:05:06 <startling> klrr, (the actual equivalent is 'append' in Data.Text)
09:05:07 <Sagi> I could do it with a case statement, but that feels stupid
09:05:10 <startling> Sagi, oh.
09:05:15 <startling> :t maybe -- have you seen this?
09:05:15 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:05:29 <ChongLi> Sagi: Reader is literally defined as:
09:05:29 <ChongLi> type Reader r = ReaderT r Identity
09:05:36 <startling> :t fmap `asAppliedTo` Nothing -- or this
09:05:37 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `Maybe a1'
09:05:37 <lambdabot>     In the second argument of `asAppliedTo', namely `Nothing'
09:05:37 <lambdabot>     In the expression: fmap `asAppliedTo` Nothing
09:05:43 <startling> well
09:05:51 <Sagi> I use fmap now, that gets me into trouble :-)
09:05:52 <klrr> strax: thanks! did not thought of (<>) and appen actually make more sense
09:05:57 <klrr> append*
09:06:04 <startling> Sagi, you might want 'traverse', then.
09:06:05 <Sagi> I'll give you the equivalent code in a maybe or case expression
09:06:08 <startling> :t traverse print Nothing
09:06:09 <lambdabot> IO (Maybe ())
09:06:14 <Sagi> :t traverse
09:06:15 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
09:06:30 <startling> it's like fmap but it brings the Applicative type to the outside.
09:06:35 <Sagi> aaah
09:06:39 <Sagi> that might be what I'm looking for
09:06:46 <startling> (All monads are (or should be) Applicatives)
09:07:09 <Sagi> cool! thanks
09:07:12 <startling> Sagi: seeing your code might help anyway, though.
09:09:03 <osa1_> how to write FFI binding for C function with type void fun(void) ? is this simply IO () in Haskell?
09:09:27 <Clint> osa1_: sounds right
09:10:06 <startling> osa1_: yep.
09:10:12 <osa1_> thanks
09:13:09 <startling> > traverse (: []) (Just 12) -- this is a more instructive example.
09:13:10 <lambdabot>  [Just 12]
09:15:10 <startling> > runState 12 $ traverse (modify . (+)) (Just 13)
09:15:12 <lambdabot>  No instance for (GHC.Num.Num
09:15:12 <lambdabot>                     (Control.Monad.Trans.State.Lazy.State
09:15:12 <lambdabot>                        (f0 (Data.Maybe.Maybe ())) a0))
09:15:12 <lambdabot>    arising from a use of `e_11213'
09:15:12 <lambdabot>  Possible fix:
09:15:17 <startling> well.
09:16:20 <supki> > runState ?? 12 $ traverse (modify . (+)) (Just 13)
09:16:22 <lambdabot>  (Just (),25)
09:17:56 <startling> oh, right, runState is backwards.
09:18:02 <startling> always forget that. :(
09:24:06 <lllllllllllll> :t (??)
09:24:06 <lambdabot> Functor f => f (a -> b) -> a -> f b
09:24:49 <startling> :t map (+ 1) ??
09:24:50 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
09:24:52 <startling> er
09:24:59 <startling> :t map ?? []
09:25:00 <lambdabot> (a -> b) -> [b]
09:25:24 <Maior> :t runState
09:25:25 <lambdabot> State s a -> s -> (a, s)
09:25:32 <Maior> backwards?
09:25:42 <Maior> oh, you mean -> (a, s) instead of -> (s, a) ?
09:26:41 <startling> yeah. it's bad for composition.
09:26:44 <startling> no.
09:26:50 <aleksejs_> Hi, is there any easy method to get 0 if a > b or 1 otherwise?
09:26:52 <startling> I mean s -> State s a -> (a, s)
09:26:53 <geekosaur> Maior: they want the starting value before the State to be run
09:27:21 <Maior> oh right, sorry, yes
09:27:23 <startling> ideally you could do "runState s . runReaderT r . runWriterT" etc. you can't, because of how the arguments are ordered.
09:27:40 <pqmodn> aleksejs_: if a > b then 0 else 1
09:28:20 <supki> aleksejs_: fromEnum
09:28:25 <lpsmith> does GHC 7.8 have a release candidate yet?   I seem to remember seeing one,  but I can't seem to find it...
09:28:31 <supki> > (fromEnum (1 > 2), fromEnum (2 > 1))
09:28:32 <lambdabot>  (0,1)
09:28:43 <pqmodn> supki: neat
09:29:01 <aleksejs_> nice, thanks!
09:32:34 * hackagebot hsimport 0.2.6.7 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.6.7 (DanielTrstenjak)
09:33:35 <ReinH> I'm not sure I'd be happy coming back in 3 months and looking at fromEnum (a > b) versus go a b | a > b = 0 | otherwise = 1
09:33:54 <ReinH> sometimes it's nice to just say what you mean
09:34:13 <ChongLi> haha
09:34:56 <startling> I think maybe you don't want 0 or 1 but a Bool instead.
09:35:58 <ChongLi> or refactor away the boolean blindness
09:36:03 <startling> But if for some reason you're using a Bool as input to a numerical expression fromEnum is a perfectly reasonable way to do it.
09:36:57 <ReinH> I don't want to have to ask myself "what order is Bool defined in again?" every time I look at the code
09:37:07 <ReinH> it's indirection, not abstraction
09:37:21 <ChongLi> ReinH: same with using a Bool in general
09:37:35 * hackagebot shelly 1.4.0.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.0.1 (GregWeber)
09:37:37 <ReinH> ChongLi: the Bool blindness point was the best one so far
09:37:44 <ReinH> but I don't know enough context to provide an alternative
09:38:05 <ChongLi> ReinH: yeah, that's always the issue with trying to help based on tiny snippets here :)
09:38:42 <startling> yeah. ^
09:39:16 <ChongLi> if I'm writing a library to provide a better interface to another library (or group of libraries)
09:39:24 <ChongLi> does it make sense to wrap all the data types?
09:40:04 <ChongLi> it seems if I don't, then changing the back-end library would break my API
09:41:00 <chrisdone> reinh: read 'em and weep http://chrisdone.com/shm-skeletons.ogv
09:42:12 <chrisdone> cale: this is what writing in shm is /supposed/ to be like ^
09:42:21 <ChongLi> chrisdone: that's pretty nice
09:42:23 <chrisdone> (maybe i should make a screenscast?)
09:42:41 <ChongLi> it'd be nice to have some talking rather than just keyboard sounds
09:44:33 <startling> chrisdone: hey, I've been meaning to ask you something about god-mode. got a minute?
09:44:46 <chrisdone> sure
09:44:54 <prophile> is there a typeclass which provides f a -> f b -> f (a, b) - along the lines of MonadZip but without Monad as a superclass?
09:45:02 <prophile> I'm sure I've seen just that somewhere, but I can't remember where
09:45:15 <simpson> prophile: It's part of the original description of Applicative.
09:45:27 <ReinH> chrisdone: you are typing so furiously
09:45:29 <ReinH> it's adorable
09:45:30 <startling> chrisdone, when I'm in paredit-mode and I turn on god-mode-all, TAB toggles god-mode-all.
09:45:34 <ReinH> chrisdone: no but that's very cool
09:45:40 <simpson> :t ((,) <$>)
09:45:41 <lambdabot> Functor f => f a -> f (b -> (a, b))
09:45:42 <startling> chrisdone: is that a bug or something else?
09:45:43 <chrisdone> reinh: it's actually just normal speed but my keyboard is loud
09:45:53 <ReinH> chrisdone: shame I can't wrap my finger brains around emacs :(
09:45:54 <startling> prophile, that's Applicative
09:45:55 <simpson> :t ((,) <*>)
09:45:56 <prophile> simpson: not quite I don't think - the Applicative variant with that type signature doesn't require it to be commutative
09:45:56 <lambdabot> (a -> b) -> a -> (a, b)
09:46:10 <prophile> whereas mzip in MonadZip does
09:46:15 <startling> that signature is equivalent to (<*>).
09:46:32 <prophile> yes, but there are laws as well
09:46:47 <prophile> sorry, I wasn't clear with what I meant by 'along the lines of MonadZip'
09:46:51 <startling> you don't have pure?
09:46:52 <ReinH> chrisdone: also, hey girl
09:46:54 <chrisdone> startling: hmm that's weird. what does C-h k TAB give?
09:46:56 <ReinH> chrisdone: sup
09:47:25 <chrisdone> reinh: haha, yeah, i was listening to the chemical brothers just before recording =p
09:47:32 <ReinH> byorgey: ping :)
09:48:20 <prophile> startling: no, but (,) <$> x <*> y and (\x y -> (y, x)) <$> y <*> x are not necessarily equivalent
09:48:27 <prophile> they differ in the State applicative, for instance
09:48:30 <jrm2k6> Hi guys, is there a way I can achieve the same using some list comprehension one liner? http://lpaste.net/98295, my issue is how to check the subtype of an element without pattern matching
09:48:32 <startling> chrisdone: weird, it only seems to happen when I (global-set-key (kbd "C-i") 'god-mode-all)
09:48:42 <robstewartuk> Is it possible to instruct cabal to run an OS command prior to performing its own. E.g. When a user types `cabal install`, I'd like OS command `foo` to be executed to completion, before the usual cabal installation. Is there something in a cabal file I can add to make this happen?
09:48:58 <ReinH> prophile: how do you get that to not be the (r ->) applicative?
09:49:07 <dcoutts> robstewartuk: no, except writing your own wrapper script
09:49:09 <byorgey> ReinH: sorry, actually ended up submitting the paper yesterday, will get back to you soon =)
09:49:16 <ReinH> byorgey: ok great! and congrats :)
09:49:19 <robstewartuk> make it is :-)
09:49:23 <robstewartuk> dcoutts: thanks.
09:49:42 <prophile> :t \x y -> (,) <$> x <*> y
09:49:43 <lambdabot> Applicative f => f a1 -> f a -> f (a1, a)
09:49:49 <byorgey> ReinH: also, no, nothing ever happened with that text adventure thing
09:49:55 <prophile> :t \x y -> (\x y -> (y, x)) <$> y <*> x
09:49:56 <lambdabot> Applicative f => f t -> f t1 -> f (t, t1)
09:49:57 <chrisdone> startling: yeah -- C-i and TAB are the same in emacs, there's a translation. if your 70's keyboard didn't have TAB, you'd hit C-i. so when you hit TAB, it's being converted to C-i, your god-mode-all
09:50:04 <ReinH> byorgey: cool, I started working on my own with some ideas from yours.
09:50:13 <byorgey> ReinH: nice
09:50:21 <startling> chrisdone: oh, ugh, what a pain
09:50:34 <startling> chrisdone: wondering why it only shows up in paredit-mode
09:51:06 <chrisdone> startling: yeah. i have it bound to ESC which i swapped with caps lock
09:51:12 <startling> yeah, C-h k TAB shows (god-mode-all)
09:51:26 <startling> chrisdone: hm, ok. thanks for the help.
09:53:05 <chrisdone> anybody got a pre-made pure IO-monad and re-implementation of some standard things from System.IO?
09:54:27 <etrepum> does ghc-pkg or cabal sandbox have a flag to list the package databases that it will use, basically the output of "ghc-pkg list | grep ^/" (without the trailing colons)?
09:54:42 <osa1_> link in this hackage page are broken: http://hackage.haskell.org/package/llvm-general-pure any ideas why? is this a haddock bug?
09:54:52 <chrisdone> it's a hackage bug afaik
09:56:23 <dcoutts> osa1, chrisdone: we need someone to (either manually or automatically) delete those borked docs and let them be re-generated
09:57:37 * hackagebot hsimport 0.2.6.8 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.6.8 (DanielTrstenjak)
09:58:15 <pqmodn> chrisdone: i don't have such a thing, but is it for a bot or something? how could it work?
10:00:14 <chrisdone> pqmodn: for tryhaskell, someone asked for trivial IO. i could do it with a cont and state monad stack
10:00:36 <pqmodn> oh, neat
10:04:01 <Twey> When reactive-banana says ‘there is currently no garbage-collection for dynamically-created events’, does that mean I have to do something to explicitly clean them up when I'm done with them, or that if I use them I'm doomed to leak space?
10:06:07 <chrisdone> pqmodn: i'm thinking to e.g. exp = do putStrLn "Enter your name"; name <- getLine; putStrLn "Enter your age"; age <- readLn; putStrLn ("Hey " ++ name ++ ", age: " ++ show age) the steps would be like:
10:06:08 <chrisdone> runIO exp [] → (["Enter your name"],GetLine,[],[])
10:06:08 <chrisdone> runIO exp ["Christopher Lee"] → (["Enter your name","Enter your age"],GetLine,["Christopher Lee"])
10:06:08 <chrisdone> runIO exp ["Christopher Lee","91"] → (["Enter your name","Enter your age","Hey Christopher Lee, age: 91",Done,["Christopher Lee","91"])
10:06:20 <chrisdone> pqmodn: you would just keep running it repeatedly until it says Done
10:06:42 <chrisdone> pqmodn: and you'd ignore the stdout lines that you've already seen
10:07:32 <chrisdone> this keeps the evaluation pure and requires no state in mueval
10:07:38 * hackagebot spsa 0.1.1.0 - Simultaneous Perturbation Stochastic Approximation Optimization Algorithm  http://hackage.haskell.org/package/spsa-0.1.1.0 (yanatan16)
10:08:18 <startling> chrisdone, old Haskell IO used to work kinda like that
10:08:51 <chrisdone> =)
10:09:19 <pqmodn> chrisdone: that makes sense. though does exp change each time, or do you evaluate it from the start each time until it needs input?
10:09:52 <chrisdone> yeah, re-run the whole thing each time
10:09:58 <Iceland_jack> Bring back old Haskell!
10:10:06 <chrisdone> the only thing that changes is the number of "stdin" values
10:10:11 <pqmodn> is that because you can't easily return the "rest of the computation" as a value to the browser?
10:10:17 <c_wraith> chrisdone: yeah, the old IO system used to work like that.  It had the minor issue of making it trivial to write infinite loops accidentally
10:10:42 <chrisdone> pqmodn: right. i could keep the continuation in memory but then mueval would need to stay open, which i'd prefer not
10:11:25 <chrisdone> c_wraith: why were infinite loops easier to make?
10:12:21 <c_wraith> It was really easy to create accidental circular data dependencies between input and output
10:12:35 <pqmodn> i wish i could find the thing that had an example of old IO. it was very strange
10:13:47 <prophile> is there any reference on old IO?
10:13:55 <chrisdone> yeah, i'd be interested in that
10:14:03 * chrisdone pops to the supermarket
10:15:27 <prophile> http://stackoverflow.com/questions/17002119/haskell-pre-monadic-i-o
10:20:18 <mekeor> is there a somewhere pre-defined "class ConvertibleBoxes a b where convert :: a t -> b t"?
10:20:22 <Earnestea> prophile: http://pbrisbin.com/posts/the_advent_of_io/
10:21:13 <prophile> mekeor: that looks a lot like natural transformations
10:22:02 <mekeor> prophile: and what the duck is this? :) – and is it pre-defined somewhere? :)
10:22:26 <adelbertc> is this https://ghc.haskell.org/trac/ghc/wiki/DefaultSuperclassInstances the latest on default superclass instances for haskell?
10:22:40 <prophile> natural transformations are a concept from category theory
10:22:48 * mekeor nods
10:22:50 <prophile> usually people just type them manually as values of type (forall a. f a -> g a) though
10:23:12 <prophile> category-extras had some specialised goo for them but that disappeared when category-extras got broken up
10:23:37 <mekeor> hm, okay
10:24:17 <c_wraith> Hey, I've used things that unify with that before
10:25:36 <startling> mmorph has some smiliar stuff
10:26:13 <startling> class MFunctor t where hoist :: Monad m => (forall a. m a -> n a) -> t m b -> t n b
10:26:49 <c_wraith> Huh.  I'm pretty sure that's exactly the use case I had.
10:27:20 <startling> it's come up a few times for me.
10:27:21 <mauke> doest thou even hoist
10:28:38 <Elision> :t \f g h x -> f (g x) (h x)
10:28:38 <lambdabot> (t1 -> t2 -> t) -> (t3 -> t1) -> (t3 -> t2) -> t3 -> t
10:28:50 <Elision> is there any fancy thing that does this? ^
10:29:01 <startling> :t on
10:29:01 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
10:29:11 <startling> almost.
10:29:26 <Elision> hm, might be close enough
10:29:28 <joelteon> :t liftA2
10:29:28 <c_wraith> I think liftM2
10:29:29 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
10:29:31 <c_wraith> or liftA2, yes
10:29:40 <startling> :t liftA2 `asAppliedTo` const
10:29:40 <lambdabot> Applicative f => (c -> b -> c) -> f c -> f b -> f c
10:29:53 <startling> oh, heh
10:30:00 <Cale> @pl \f g h x -> f (g x) (h x)
10:30:00 <lambdabot> liftM2
10:30:02 <joelteon> :t liftA2 `asAppliedTo` (+)
10:30:02 <lambdabot> (Num c, Applicative f) => (c -> c -> c) -> f c -> f c -> f c
10:30:08 <joelteon> damn, this isn't gonna work
10:30:15 <joelteon> > liftA2 (+) succ pred $ 3
10:30:16 <lambdabot>  6
10:30:21 <Martingale> I'm trying to do some profiling, but i'm having trouble using RTS i get: Most RTS options are disabled. Link with -rtsopts to enable them.
10:30:23 <Martingale> any ideas
10:30:31 <startling> Martingale, link with -rtsopts
10:30:33 <c_wraith> Martingale: add -rtsopts to the compile command line
10:30:36 <Elision> ahh
10:30:48 <startling> Martingale: (e.g. with ghc --make -rtsopts)
10:30:49 <Elision> thanks
10:30:55 <Cale> :t [\f g h x -> f (g x) (h x), liftM2]
10:30:56 <lambdabot> Monad ((->) t) => [(a1 -> a2 -> r) -> (t -> a1) -> (t -> a2) -> t -> r]
10:31:08 <joelteon> there you go
10:31:16 <Martingale> startling I tried that, but i still get the error message?
10:31:29 <startling> Martingale, you might need to recompile everything.
10:31:35 <c_wraith> Martingale: then you probably didn't force a recompile
10:31:47 <startling> -fforce-recomp
10:31:54 <Martingale> startling thanks
10:32:20 <startling> I always think it should be -fforce-rrecomp
10:32:25 <Cale> Not sure why :t didn't get rid of the Monad ((->) t) constraint there. Maybe the same instances aren't in scope in :t as for evaluation in lambdabot.
10:32:34 <joelteon> -ffoorrccee-rreeccoommpp
10:32:41 <startling> joelteon: haha, yes
10:32:48 <c_wraith> the first f stands for flag
10:32:52 <c_wraith> of course.
10:32:58 <startling> I know. It's just what my fingers type.
10:32:59 <prophile> it's welsh
10:33:16 <c_wraith> you wouldn't know the command line flag was a flag if it didn't start with f
10:33:47 <c_wraith> :t liftM2 (+) (*2) (^2) 5
10:33:48 <lambdabot> Num a => a
10:33:49 <pqmodn> otherwise it could be anything really
10:33:58 <c_wraith> Cale: it has that instance in scope in :t
10:34:15 <joelteon> :t liftM2 (++) (map toUpper) reverse
10:34:16 <lambdabot> [Char] -> [Char]
10:34:19 <startling> it could be one of the extensions, couldn't it?
10:34:23 <joelteon> > liftM2 (++) (map toUpper) reverse "foobar"
10:34:24 <lambdabot>  "FOOBARraboof"
10:34:45 <startling> I think one extension leads to superfluous constraints in inference but I don't remember which.
10:34:47 <c_wraith> Huh.  Now that I see it, it seems odd to me that I've never seen raboof before
10:34:59 <Cale> :t [\f g h x -> f (g x) (h x), liftM2]
10:35:00 <lambdabot> Monad ((->) t) => [(a1 -> a2 -> r) -> (t -> a1) -> (t -> a2) -> t -> r]
10:35:02 <startling> c_wraith: haha, good point.
10:35:18 <Cale> c_wraith: Yeah, it must, but that's odd, isn't it? :)
10:35:22 <startling> Cale, why a list?
10:35:24 <startling> oh, I see.
10:35:31 <startling> :t asTypeOf -- :)
10:35:31 <lambdabot> a -> a -> a
10:35:32 <c_wraith> I certainly agree it's odd
10:35:35 <Cale> startling: As a way to show that the types unify
10:35:57 <c_wraith> :t fmap `asTypeOf` second
10:35:57 <lambdabot> (b -> c) -> (d, b) -> (d, c)
10:36:05 <c_wraith> instances stripped out of that signature!
10:36:31 <Cale> :t liftM2 `asTypeOf` (\f g h x -> f (g x) (h x))
10:36:31 <lambdabot> Monad ((->) t) => (a1 -> a2 -> r) -> (t -> a1) -> (t -> a2) -> t -> r
10:36:59 <dfsdfs> What's the proper way to do the following?  http://dpaste.com/1545544/plain/  I get '/bin/sh: 1: ./foo: Permission denied' instead of 'foo: error ...'.  foo is an empty file which is owned by root.
10:37:53 <Cale> dfsdfs: Perhaps try using System.Process to execute the thing directly
10:38:13 <dfsdfs> Cale: I have to use the shell.
10:38:41 <c_wraith> dfsdfs: I think the problem is that the *shell* is writing that error message to stderr
10:38:53 <Cale> Well, of course it is
10:39:10 <c_wraith> dfsdfs: so throw a 2>/dev/null on the command, or something
10:39:49 <Cale> Does system even throw an exception when the shell exits with a nonzero exit code?
10:39:58 <c_wraith> Probably not
10:40:06 <Cale> Right, it shouldn't.
10:40:20 <Cale> It's supposed to return that ExitCode as its result after all
10:40:53 <dfsdfs> Cale: So, can I get rid of 'catchIOError' and match on ExitFailure instead?
10:40:53 <Cale> dfsdfs: I think what you want is to move that "handler" code into the branch of the case for ExitFailure
10:40:56 <Cale> yeah
10:41:21 <dfsdfs> Cale: Thank you.  The docstring of 'system' confused me a bit.
10:41:45 <skypers> hi
10:41:46 <skypers>     Expected type: [(Word32, [Char])]
10:41:47 <skypers>       Actual type: [(Integer, String)]
10:41:49 <skypers> in order to solve that
10:41:52 <skypers> I can just do a
10:41:58 <skypers> first fromInteger
10:41:59 <skypers> right?
10:42:03 <skypers> :t first fromInteger
10:42:04 <lambdabot> Num a => (Integer, d) -> (a, d)
10:42:06 <Cale> dfsdfs: Yeah, that documentation is incorrect
10:42:24 <Cale> dfsdfs: system will throw an exception if given an empty string as its argument though
10:42:25 <c_wraith> skypers: That was a *lot* of lines to ask that question.  but the answer is yes, assuming you've imported Control.Arrow
10:42:36 <dfsdfs> Cale: You seem to be better informed on the subject.  Could you please report it?
10:42:36 <skypers> huh
10:42:37 <skypers> no
10:42:40 <skypers> I haven’t
10:42:45 <skypers> I use Data.Bifunctor
10:42:54 <c_wraith> Oh, ok.  That should work too
10:42:55 <Cale> I suppose it might also fail if you didn't have permission to run the shell
10:43:00 <Cale> Ah, okay
10:43:08 <skypers> the thing is, if I do that:
10:43:13 <Cale> Yeah, it really can throw those exceptions
10:43:15 <skypers> :t bimap fromInteger tail
10:43:16 <lambdabot> (Num b, Bifunctor p) => p Integer [a] -> p b [a]
10:43:25 <skypers> I get an error on the first part
10:43:30 <skypers> and I don’t get why
10:43:35 <Cale> It's just that it doesn't throw them for the more obvious sorts of reasons
10:43:39 <k0ral> Hello, is there already a library providing a GenParsec (or so) to parse URIs ?
10:43:55 <k0ral> or do I have to implement it myself for my project
10:44:07 <Cale> http://hackage.haskell.org/package/uri-0.1.6.2/docs/Text-URI.html
10:44:38 <Cale> That doesn't contain a Parsec parser, but it does have parseURI :: String -> Maybe URI
10:46:02 <Cale> http://hackage.haskell.org/package/network-2.4.2.2/docs/Network-URI.html might be considered a more canonical place to get that, actually
10:46:09 <k0ral> well, that's precisely my point: I know I can use parseURI from Network.URI, but I would like to know whether someone's already bothered implementing a parsec version
10:46:24 <skypers> Cale: http://lpaste.net/1836815714153922560
10:46:32 <skypers> the (1) is the line the error occurs
10:46:33 <Cale> oh, in that case I don't know
10:46:34 <skypers> any idea?
10:46:34 <dfsdfs> Cale: I see, thanks again.  Also, is it idiomatic to do what I did?  Would you do it differently?  (The name of the command will be hardcoded, and that code will be a part of a command line tool.)
10:47:52 <Cale> skypers: You're defining fromInteger recursively
10:48:01 <skypers> oh
10:48:02 <skypers> :D
10:48:15 <skypers> why don’t have I a warning for that
10:48:29 <dfsdfs> Cale: I guess it safe to drop exception handling in this case, what do you think?
10:48:43 <Cale> Because it's not unusual to define things recursively?
10:48:55 <Cale> I suppose it's unusual to shadow Prelude names :)
10:49:02 <no0y> //join #haskell
10:49:11 <Cale> dfsdfs: yes
10:49:40 <Cale> dfsdfs: I wouldn't bother handling those exceptions. They're not very recoverable.
10:49:49 <skypers> Cale: yeah, I was actually talking about the shadowing effect
10:50:20 <dfsdfs> Cale: OK, but would it be sane to move the current handler into the ExitFailure case?
10:50:32 <Cale> dfsdfs: yes
10:52:41 <dfsdfs> Cale: OK, no more questions.  You're very helpful (as always).
10:54:04 <dleedev> hi, is there something in ghci that allows me to translate from do notation to >>= notation?
10:54:26 <quchen> dleedev: No, but Lambdabot can do that for you.
10:54:35 <mekeor> dleedev: i don't know of GHCI, but lambdabot .... with @undo
10:55:05 <quchen> @undo do { x <- getLine; putStrLn x }
10:55:05 <lambdabot> getLine >>= \ x -> putStrLn x
10:56:16 <frx> dleedev I never used this, but it may give you what you want. http://www.haskell.org/haskellwiki/GHC/GHCi#GHCi_on_Acid
10:57:02 <augur> dleedev: do notation is pretty transparently related to >>= notation mind you
10:57:32 <augur> dleedev: in general,   do x <- y ; z   =   y >>= (\x -> z)
10:57:58 <augur> dleedev: and   do y ; z   =   y >>= (\_ -> z)
10:58:15 <dleedev> frx: looks like GHCi on Acid is simply installing lambdabot
10:59:01 <augur> do is actually a lot like let in strict languages
10:59:02 <chrisdone> yeah, ghci on acid is just lambdabot in ghci
10:59:09 <dfsdfs> Cale: Sorry, one more thing...  I can't find a way to convert 'ExitFailure n' into a human-readable error message.  Is there such a function?
10:59:14 <user`> ghci
10:59:21 <augur> let x = y in z   =   (\x -> z) y
10:59:31 <dfsdfs> Cale: For instance, it should output "File not found" for 127.
11:00:19 <augur> chrisdone: what does GHCi on Acid add, functionality-wise?
11:00:29 <ReinH> dfsdfs: Why is 127 file not found?
11:00:30 <Cale> I'm not sure you can rely on exit codes meaning anything in particular
11:00:43 <Cale> You just have to know what they mean for any given executable
11:00:47 <dfsdfs> ReinH: Perhaps, I messed it up.
11:00:52 <ReinH> There are some suggested meanings in, e.g., Advanced Bash Scripting Guide, where 127 is "command not found"
11:01:04 <chrisdone> https://github.com/chrisdone/goa
11:01:27 <ReinH> or in sysexits.h, where 77 is EX_NOPERM or "permission denied"
11:01:33 <monochrom> exit codes are specific to the exiting program
11:01:38 <ReinH> but generally there isn't an agreed upon standard aside from 0 is success and > 0 is not
11:02:01 <startling> chrisdone: neat!
11:02:24 <monochrom> but I have a cunning plan
11:02:30 <ReinH> So just write your showExitFailure (ExitFailure 127) = "File not found" and so on
11:02:42 <augur> monochrom: does it involve flags?
11:02:48 <user`> does anyone know when ghci will be available on arm?
11:02:52 <chrisdone> monochrom: like a fox that graduated from the University of Cunning with a master's degree in shrewdery?
11:02:58 <dfsdfs> ReinH: So will it be OK to print something like "foo: error: failed with" ++ exitCode?
11:03:01 <ReinH> chrisdone: lmao what
11:03:19 <ReinH> dfsdfs: usually you print relevant error messages to stderr anyway
11:03:27 <ReinH> you don't need to print the exit code
11:03:28 <dfsdfs> ReinH: Hm, but what about other exit codes?  I'd like to have something generic.
11:03:32 <ReinH> if they want to check they can find it out
11:03:38 <ReinH> with $?
11:03:53 <ReinH> dfsdfs: there isn't anything generic
11:04:01 <ReinH> dfsdfs: decide what they mean for your program and then implement that
11:04:03 <monochrom> after you catch an ExitFailure, connect to google to ask, then simply dump google's output to the user. that is now human-readable.
11:04:28 <ReinH> and useful errors printed to stderr are better than error numbers in most cases anyway
11:05:00 <jle`> hm. so i settled on starting out with a simple state monad-based game loop for my js game, but how/where do i handle those async javascript events?  should i fork a thread to handle all the events and then plop them into a messages channel to be emptied every loop?
11:05:01 <chrisdone> reinh: for users, yeah
11:05:16 <chrisdone> for programmatic use i hate parsing plain text error messages
11:05:35 <dleedev> why is a >>= f used more often than g >=> h? Haskell even provides special do notation for >>=.
11:05:57 <monochrom> then my plan is perfect for you, chrisdone. because google's output is going to be HTML, not plain text :)
11:06:04 <chrisdone> >=> is only useful once in a while in practice
11:06:06 <dfsdfs> monochrom: Hehe
11:06:31 <chrisdone> monochrom: cool
11:06:35 * chrisdone imports his regex library
11:06:50 <skypers> http://lpaste.net/98299
11:06:51 <monochrom> regex \∩/
11:06:52 <skypers> it WORKS!
11:06:53 <skypers> :)
11:06:57 <ReinH> chrisdone: it's not for parsing. It's for logging and then never ever reading.
11:07:07 <mrack> what is your preferred html parser for scrapping web pages?
11:07:18 <chrisdone> tagsoup or html-conduit
11:07:20 <monochrom> tagsoup or HXT
11:07:25 <chrisdone> or webkit =)
11:07:56 <dfsdfs> tagsoup is terrible.
11:08:03 <monochrom> html-conduit is probably faster than HXT, but I haven't learned it
11:08:14 <monochrom> tagsoup is not terrible
11:08:23 <dfsdfs> have you seen ndm's example?
11:08:31 <monochrom> no
11:08:34 <chrisdone> tagsoup lacks a good API
11:08:37 <dfsdfs> wait, I'll show you.
11:08:54 <monochrom> what is its relevance to my sentence?
11:09:13 <chrisdone> tagsoup + parsec is good http://lpaste.net/8903892191621939200
11:09:42 <monochrom> recall that "here is a program that is both terrible and uses tagsoup" does not prove much
11:09:55 <dfsdfs> I was talking about this https://rawgithub.com/ndmitchell/tagsoup/master/tagsoup.htm
11:10:14 <monochrom> perhaps he wrote terribly
11:10:19 <dfsdfs> look at all those 'drop 5's, etc.
11:10:26 <monochrom> perhaps he chose the wrong task for tagsoup
11:11:00 <davean> That is very much not what my tagsoup code looks like.
11:11:32 <monochrom> if you use bytestring for relational join, your code will be terrible too. does not prove that bytestring is terrible. rather, proves that you, you, are terrible.
11:12:05 <chrisdone> and a bad lover
11:12:31 <monochrom> you can pay me to write terrible code. it can help you smear the name of any library you choose.
11:12:38 <dfsdfs> Haha
11:12:54 <jle`> i'm going to copyright this movie concept so nobody get any ideas.
11:13:59 <dfsdfs> monochrom: OK, I agree that the word "terrible" wasn't appropriate.
11:14:20 <dabd> I was trying to test the poker-eval package using GHCi (which is a binding for a C library). For some reason calling functions which make foreign calls won't return correct results in the interpreter but it works fine if I compile the code.
11:14:27 <dabd> Why is this happening?
11:14:39 <monochrom> no no, it is appropriate. you just chose the wrong subject
11:14:49 <dabd> https://hackage.haskell.org/package/poker-eval
11:15:26 <davean> monochrom: haha
11:16:39 <dfsdfs> davean: Could you please show the code that you've mentioned?
11:22:23 <davean> I'd have to find it. I used it back in 2012 to import a set of working documents from google doc's HTML export (with custom embeded markup) format to markdown
11:24:19 <jle`> anyone know what this syntax can mean?
11:24:19 <davean> though I do have an example here (that isn't mine) that uses selector functions and case-based pattern matching on lists
11:24:23 <jle`> let h _ = ....
11:24:31 <jle`> where the h is a lowercase identifier
11:24:46 <triliyn> jle`: defining a function that ignores its argument
11:24:50 <jle`> ah
11:24:52 <monochrom> it is like "let h x = x + 1" except that it doesn't use x
11:24:53 <jle`> of course
11:25:09 <jle`> i was fixed on it being a pattern match on a data constructor
11:25:10 <jle`> ty
11:25:27 <jle`> i'd just use const ><
11:26:02 <monochrom> well, perhaps there are two lines, "h [] = False" and then "h _ = True"
11:26:27 <jle`> in this case there isn't so i was thrown off slightly
11:26:41 <augur> _ is just a way of explicitly saying you dont use the arg
11:26:48 <augur> its the same as using a name that you dont use
11:26:54 <augur> eg const can be defined as either
11:26:57 <augur> const x y = x
11:26:58 <augur> or as
11:27:02 <augur> const x _ = x
11:27:15 <dfsdfs> ReinH: Meh, I'm still failing to come up with a human-readable message.  'foo' can fail for various reasons, and I don't want to rely on exit codes.
11:27:16 <jle`> well _ stops my ghc-mod hlinter from complaining
11:27:19 <jle`> :)
11:27:37 <monochrom> haha
11:27:37 <jle`> so i am held hostage to the latter
11:27:42 <augur> yes, there are some optimizations that can occur when you use _, jle`
11:27:46 <monochrom> it is why I don't use hlint
11:28:11 <augur> namely, if you use _, then GHC knows it doesnt need to bind anything to a variable, avoiding a needless change to the variable environment
11:28:31 <chrisdone> ghc knows that anyway
11:28:31 <jle`> i'm sure ghc is smart enough to know it whether or not i even _ though
11:28:42 <augur> chrisdone: oh, well then
11:28:57 <augur> chrisdone: i guess its just for us mere mortals :)
11:29:00 <jle`> i think the warning is mostly to remind people that they might actually have wanted to use y
11:29:06 <jle`> and that they likely did something wrong
11:29:55 <jle`> 'you defined y...are you sure you don't want to use it?'
11:30:05 <jle`> mostly for mortals
11:30:12 <chrisdone> i don't think hlint gives that warning, ghc warns about unused names?
11:30:29 <chrisdone> λ> :set -Wall
11:30:30 <chrisdone> λ> let f x = () in f ()
11:30:30 <chrisdone> <interactive>:9:7: Warning: Defined but not used: `x'
11:30:56 <jle`> i get the big ol red arrow on my syntastic/vim2hs
11:31:05 <chrisdone> it's good for re-factoring. sometimes you realise you're passing something that's not needed anymore
11:31:29 <jle`> and one arrow makes the entire left margin huge to fit it
11:31:34 <jle`> so i have to have none ><
11:31:53 <chrisdone> syntastic moar like failtastic amirite
11:32:23 <jle`> well i do get a rush of satisfaction when the margin goes away
11:32:29 <jle`> sometimes i live off of it
11:32:32 <jle`> on those late nights
11:32:35 <jle`> those lonely nights
11:32:57 <chrisdone> those cold, lonely late nights by the extinguished fire
11:33:31 <chrisdone> jle`: let's wrestle like in Women in Live
11:33:40 <chrisdone> @choose chrisdone jle`
11:33:40 <lambdabot> chrisdone
11:33:41 <chrisdone> \o/
11:34:10 <jle`> i have been undone by my folly
11:35:14 <osa1_> apparently examples here http://hub.darcs.net/ertes/netwire/browse/README.md are not well-typed anymore, do we have a more recent netwire tutorial?
11:42:54 * hackagebot pandoc 1.12.3 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.3 (JohnMacFarlane)
12:04:08 <jle`> ugh do people really define ad-hoc local operators
12:04:19 <jle`> i guess it's okay if the definition is right there
12:07:44 <quchen> jle`: ?
12:07:57 * hackagebot purescript 0.2.9.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.9.2 (PhilFreeman)
12:08:06 <quchen> Operators are just functions with different syntax
12:08:34 <triliyn> quchen: it's very hard to give them descriptive names though
12:08:42 <jle`> quchen: yeah, but it can be a bit obfuscaty
12:08:51 <jle`> https://github.com/ghcjs/ghcjs-examples/blob/master/weblog/mouse/mouse.hs#L66-L70
12:09:11 <jle`> i guess it's not that bad if you define it right there.
12:09:32 <kakos> How do I get c2hs to use clang instead of gcc?
12:09:35 <kakos> In cabal
12:09:40 <FireFly> triliyn: if you take in an arbitrary binary function as a parameter, using something like (*) or so doesn't seem all that terrible to me
12:09:42 <chrisdone> seems good enough for tryhaskell =) http://lpaste.net/98302
12:09:57 <FireFly> triliyn: I mean, compared to something like f
12:09:59 <jle`> it just seems kind of cavelier to just define an operator and throw it away. maybe i should shift my mind and de-elevate operators
12:10:05 <triliyn> FireFly: yeah, if you take it as a parameter, that would be fine
12:10:09 <jle`> i feel like i want to treat them with some respect
12:10:12 <quchen> jle`: Obfuscaty is shadowing standard operators in your definitions
12:10:14 <quchen> @src on
12:10:14 <lambdabot> (*) `on` f = \x y -> f x * f y
12:10:17 <quchen> ^ Like that.
12:10:44 <triliyn> hmmm, but yeah, using existing names is a bit weird...
12:10:46 <FireFly> I don't think it's terrible :P
12:10:49 <jle`> w0w
12:10:53 <quchen> FireFly: You're wrong! :-þ
12:10:54 <FireFly> I wouldn't do it myself though, probably
12:11:04 <jle`> that feels all sorts of wrong v.v
12:11:17 <triliyn> I very rarely see operator arguments to functions at all
12:11:34 <FireFly> (f `on` g) x y = g x `f` g y  -- what I would've written
12:11:39 <triliyn> It seems like it would be nice in some cases
12:12:07 <danharaj> Cale: I need to know why you wrote a piece of code 7 months ago.
12:12:16 <danharaj> holla @ me in gtalk
12:12:21 <chrisdone> operators are poo
12:13:19 <quchen> chrisdone: :C
12:13:35 <quchen> (sum . take 100 . map (^2)) xs
12:15:18 <jle`> operators are just a free flip so what is the big deal
12:15:23 <jle`> :)
12:18:22 <skuares_> Hello?
12:18:27 <jle`> hello skuares_
12:18:33 <Twey> Hello‽
12:18:34 <chrisdone> jle`: most operators are a PITA to type, figure out what they mean and their precedence and fixity, and make people invent irregular indentation rules
12:18:35 <skuares_> Hi there
12:18:50 <chrisdone> y halo thar!
12:18:55 <jle`> well aren't you a party pooper.
12:19:17 <Twey> I like operators because they save me brackets
12:19:27 <skuares_> I have a quick question. Fair warning though: I'm quite new to programming so I might ask a few follow up questions:)
12:19:28 <chrisdone> curmudgeons gonna curmudge
12:19:29 <Twey> … that's about it
12:19:46 <chrisdone> twey: you mean ``‘“parentheses”’''? =p
12:19:46 <timthelion> chrisdone: It's amazing the number of parser bugs that show up due to the non-dry ness of requiring an extra operator pass in cobinatorial parsers too!
12:19:54 <ReinH> chrisdone: is your lawn suffuciently cleared?
12:19:54 <mekeor> how do you call something like "(SomeClass a, AnotherClass b) => ..."?
12:20:06 <jle`> constraints?
12:20:07 <ReinH> mekeor: type constraints
12:20:14 <Twey> chrisdone: Absolutely not.  I don't know of any programming languages that use brackets to parenthesize things, except FORTH.
12:20:17 <chrisdone> reinh: if i can still hear you, you're standing too close to my lawn =p
12:20:21 <ReinH> skuares_: not that quick, I guess ;)
12:20:33 <mekeor> okay. i forgot how to define type constraint synonyms (using an extension). how do you do it?
12:20:35 <Twey> skuares_: Fire away; no need to warn us :þ
12:20:47 <chrisdone> twey: wait, how do operators save you brackets?
12:20:58 <mekeor> like, such that you don't have to write "(Read t, Show t, RealFloat t) =>" but just "Number t =>".
12:21:00 <jle`> fixity games i'd imagine
12:21:08 <Twey> mekeor: Just use type synonyms
12:21:11 <drostie> Twey: they don't quite. you can write quchen's earlier thing in an hypothetical language as sum take 100 map [^ 2] xs, so it's one level more parentheses and more operators to write the way above.
12:21:14 <Twey> mekeor: With ConstraintKinds
12:21:31 <skuares_> I want to test if a list of Integers are a "correct" code, i.e. length 11 and they all have to end with seven
12:21:37 <mekeor> Twey: oh, ah meh, ah, aaah okay :D
12:21:41 <chrisdone> mekeor: type Number = (Read,Show,RealFloat) iirc
12:21:44 <drostie> (they don't quite save on parentheses, I mean.)
12:21:53 <mekeor> type Number t = (Read t, Show t, RealFloat t) -- works
12:21:57 <Kaidelong> is there a short name for [minBound .. maxBound] ?
12:22:02 <chrisdone> (oh, duh, missed the variable)
12:22:08 <jle`> Kaidelong: [minBound ..] ?
12:22:09 <Twey> mekeor: ConstraintKinds promotes constraints to first-class types of kind Constraint, so you can use all the usual type syntax with them
12:22:10 <jle`> that's all i got
12:22:15 <Kaidelong> @@ hoogle type [minBound ..]
12:22:15 <lambdabot>  hoogle type [minBound ..]
12:22:28 <Kaidelong> oh that's echo?
12:22:35 <Kaidelong> what was lambdabot's compose?
12:22:36 <jle`> skuares_: one way to check a length is to turn it into a string and check the length of the string
12:22:39 <dwcook> @.
12:22:39 <lambdabot> Not enough arguments to @.
12:22:46 <ReinH> skuares_: what do you want to do if some of them aren't?
12:22:47 <timthelion> skuares_: so you have a function test :: [Int] -> Bool.  What next?
12:22:47 <jle`> skuares_: or you can log it base 10
12:22:56 <mekeor> Twey: okay, interesting. :)
12:23:01 <skuares_> I've figured out how to do it as long as I change the list from [1, 2, 3] to ["1", "2", "3"] but I'm sure there's a neater solution
12:23:07 <jle`> did i give away too much :|
12:23:16 <jle`> oh, you want the list to be 11 items long
12:23:17 <jle`> ?
12:23:21 <skuares_> I want to return the correct one and discard the others
12:23:23 <Twey> drostie: Yep, concatenative languages are cool too.
12:24:02 <timthelion> Twey: it's interesting, that you need special syntax to make concatentative languages work with partial function application.
12:24:06 <ReinH> skuares_: if you have a function correct :: Int -> Bool that tests a single int then you can use `and . fmap correct' to test all of them
12:24:11 <jle`> skuares_: there is a math function that checks if something ends in seven. look into mod
12:24:13 <chrisdone> i made a comic once about how #haskell is like one of those pubs in horror movies when foreigners enter and everyone turns round and looks at them
12:24:13 <chrisdone> … except rather than turning back to talk amongst themselves, people start walking towards them with wide grins expectantly, packing snowballs of answers in their hands
12:24:23 <chrisdone> (but i lost it)
12:24:26 <jle`> shame
12:24:30 <Twey> timthelion: It's because concatenative words are uncurried
12:24:31 <ReinH> er, even just `all correct'
12:25:01 <FireFly> skuares_: do you know about `filter`?
12:25:04 <jle`> > 58324594358 `mod` 10
12:25:05 <lambdabot>  8
12:25:06 <skuares_> Yeah
12:25:21 <jle`> > 358749851 `mod` 10
12:25:22 <Twey> timthelion: Concatenative languages are isomorphic to strings of composed functions on a tuple
12:25:22 <lambdabot>  1
12:25:37 <Twey> The nice properties happen because function composition is associative
12:26:19 <FireFly> skuares_: well, I'd do it with `filter`, and pass it a function that uses `show` to convert the number to a string and then checks those conditions you mentioned
12:26:24 <timthelion> Twey: wow there, I'm not a math major(unfortunately).  I'm not sure I'll understand you untill you provide me with a proof.
12:26:33 <FireFly> I think going via string is the neater approach here
12:26:34 <Twey> So there's only ever one function application in a concatenative language: you apply the whole program to an empty stack to evaluate it
12:26:34 <timthelion> Twey: joking on the last part
12:27:36 <jle`> > ceiling (logBase 10 37654239454)
12:27:37 <timthelion> Twey: in say "3 4 +" What would you call the "poping 3 and 4 off the stack and applying it to +" if not an application?
12:27:37 <lambdabot>  11
12:27:38 <ReinH> > let correct x = x `mod` 10 == 7 && length (show x) == 2 in all correct [17,27,37]
12:27:39 <lambdabot>  True
12:27:55 <jle`> > ceiling . logBase 10 $ 235783454
12:27:56 <lambdabot>  9
12:27:58 <Wardje> Is there a shorter way to write <$> <*> <*> <*> <*> <*> ? (& How do you pronounce those symbols?
12:28:03 <skuares_> But how do I convert an entire list of "codes"? Let's say I have a list of 20 "codes" and they are all around 11 characters long. Won't show just turn the list into a strimg?
12:28:09 <ReinH> I don't think theree's a liftA7
12:28:17 <FireFly> Wardje: fmap and ap, probably
12:28:18 <ReinH> Wardje: "fmap" and "ap"
12:28:23 <Wardje> Thanks, both
12:28:43 <FireFly> (<$>) is an alias for Functor's fmap, and (<*>) has an alias in Monad which is 'ap'
12:28:45 <FireFly> (hence the names)
12:28:46 <ReinH> skuares_: what do  you mean by "convert"?
12:29:01 <ReinH> skuares_: the `correct' predicate does that
12:29:04 <ReinH> you don't do it on the list itself
12:29:15 <Twey> timthelion: It's a composition.  3 is (3,), 4 is (4,), and + is (\ (x, (y, rest)) →  (x + y, rest))
12:29:19 <skuares_> Turn all the elements in the list into strings
12:29:43 <FireFly> skuares_: do you want them to be strings in the end, or do you want the numbers out? (after filtering the correct ones out, I mean)
12:29:58 <ReinH> you have a predicate `correct' that tests a given number
12:30:01 <ReinH> from this you can do whatever you want
12:30:02 <chrisdone> twey: check this out http://chrisdone.com/shm-skeletons.ogv
12:30:05 <Twey> timthelion: Then "3 4 +" is really the composition + . 3 . 4, and to evaluate it you apply it to the empty tuple: (+ . 3 . 4) ()
12:30:11 <ReinH> with some use of any, all, filter, or whatnot
12:30:20 <skuares_> I'd like a list of them. The same list but without the incorrect ones.
12:30:30 <FireFly> So, a list of numbers
12:30:35 <drostie> timthelion: basically he's saying that if in Haskell you can write something point-free, then that thing is concatenative naturally.
12:30:36 <ReinH> > let correct x = x `mod` 10 == 7 && length (show x) == 2 in filter correct [1..100]
12:30:37 <lambdabot>  [17,27,37,47,57,67,77,87,97]
12:30:46 <FireFly> In that case, yeah, the predicate should probably take a number and verify it
12:30:47 <ReinH> There's the list of correct ones
12:30:56 <ReinH> in all cases the predicate should take a number and verify it :)
12:31:06 <ReinH> the interesting thing is what you do with that predicate
12:31:08 <skuares_> Ah, let me try that
12:31:20 <timthelion> Twey: I see.  I didn't really realize that on an abstract level you think of compozition and application as being fundamentally different.
12:31:24 <Twey> > let { three = (3,); four = (4,); plus = (\ (x, (y, rest)) -> (x + y, rest)) } in plus . three . four $ ()
12:31:25 <lambdabot>  (7,())
12:31:26 <FireFly> ReinH: would you do that even if you wanted the numbers as strings in the end? (for whatever reason)
12:31:39 <ReinH> FireFly: yes, I'd rather build the solution compositionally
12:31:49 <ReinH> and a predicate is a useful 'primitive'
12:31:51 <FireFly> Sounds reasonable
12:31:59 <ReinH> fmap show . filter correct
12:32:01 <FireFly> Well, otherwise you'd also have a predicate, just one that takes a string instead :P
12:32:10 <ReinH> is easier to write than unpacking correct and reimplementing something similar
12:33:12 <Twey> drostie: That's not quite true
12:33:32 <Twey> Only functions of one argument are naturally concatenative, hence the currying comment
12:33:44 <Twey> Because there's only ever one application
12:34:10 <timthelion> Twey: Am I not correct in assuming that any application can be transformed into a composition via inlining given a non-cyclic call graph?
12:34:36 <Twey> timthelion: Any single application, yes
12:35:45 <Twey> timthelion: You don't need to inline, though — it's just the transformation from foo (bar (baz quux)) to (foo . bar . baz) quux
12:36:58 <timthelion> Twey: Is there a difference between application and composition?
12:37:15 <ReinH> You mean aside from the obvious?
12:37:15 <Twey> chrisdone: I like this ☺  Is it ready to use?
12:37:47 <timthelion> ReinH: yeah, aside from the lack of names...
12:37:47 <ReinH> The obvious being:
12:37:47 <ReinH> :t ($)
12:37:47 <lambdabot> (a -> b) -> a -> b
12:37:47 <ReinH> :t (.)
12:37:47 <lambdabot> (b -> c) -> (a -> b) -> a -> c
12:38:00 <Kaidelong> okay I need a haskell parsing library that can handle Text
12:38:02 <Twey> timthelion: The names aren't relevant here, that's just a restriction on the sort of functions that can be composed
12:38:08 <ReinH> Kaidelong: parsec?
12:38:25 <Kaidelong> I am going to go to parsec unless someone who has used it tells me not to
12:38:37 <ReinH> Kaidelong: afaik it's pretty standard
12:39:13 <Twey> Kaidelong: Parsec is nice.  I think there are some new shiny things around that are supposed to be better, mind.
12:39:13 <ReinH> Twey: like what?
12:39:13 <timthelion> Kaidelong: it is really easy to use.  However, if you want to use infix operators you'll have to read a few dozen extra pages to figure out how.
12:39:18 <Twey> Kaidelong: I'd imagine trifecta is probably general enough to handle Text
12:40:13 <jrmithdobbs> holy crap applicative just kind of clicks when you go to parse something with a recursive grammar
12:40:15 <alkabetz> The exception definition code in https://hackage.haskell.org/package/base/docs/Control-Exception.html#g:1 looks like a lot of boilerplate.  Has somebody written a library for defining exception hierarchies?
14:40:30 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
14:40:30 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
14:40:44 <mercuryrising> but maybe this would be better as a separate script bash script
14:41:22 <fizbin> @type map . over _left
14:41:23 <lambdabot>     Not in scope: `_left'
14:41:23 <lambdabot>     Perhaps you meant one of these:
14:41:23 <lambdabot>       `left' (imported from Control.Arrow),
14:41:33 <fizbin> @type map . over _Left
14:41:34 <lambdabot> (a -> b) -> [Either a c] -> [Either b c]
14:41:56 <fizbin> Kaidelong: Is that your mapLeft?
14:42:05 <Kaidelong> parse' x = Control.Arrow.left (pack . show) . parse x ""  --this should be the glue I need to connect parsec and xml-unpicklers
14:42:29 <Kaidelong> @type over _Left
14:42:29 <lambdabot> (a -> b) -> Either a c -> Either b c
14:42:33 <Kaidelong> there you go
14:43:27 * hackagebot dictparser 0.2.0.0 - Parsec parsers for the DICT format produced by dictfmt -t  http://hackage.haskell.org/package/dictparser-0.2.0.0 (MarkWotton)
14:43:31 <fizbin> http://hackage.haskell.org/package/either-unwrap-1.1/docs/Data-Either-Unwrap.html
14:43:43 <roboguy_> Kaidelong: that's in lens, but you said something about avoid imports so...
14:44:02 <Happy0> Kaidelong: that might be useful to me :o. where can i find 'over'? ;x
14:44:04 <roboguy_> *avoiding
14:44:07 <roboguy_> Happy0: lens
14:44:08 <Kaidelong> roboguy_: I'm using Control.Arrow in my actual solution
14:44:14 <Happy0> ahh.. it's in lens. something i know nothing about =p
14:44:16 <Happy0> cheers roboguy_ ;x
14:44:21 <Kaidelong> Lenses are neat
14:44:31 <roboguy_> yeah, I highly recommend reading about them
14:44:35 <Kaidelong> so long as you don't try to understand how they actually work too hard
14:44:48 <Happy0> good shout ;x. i know nothing beyond the name at the moment.. only that they're apparently exciting =p
14:44:50 <roboguy_> Happy0: this might get you started, if you're interested https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
14:44:55 <Kaidelong> it's not complicated but it does obfuscate how they are used
14:45:46 <Happy0> roboguy_: good man :D
14:45:49 <roboguy_> Kaidelong: well, the little I know about how they do work is pretty cool. I'd say learn how to use them then if you feel like it try learning the details. definitely don't do it the other way though, haha
14:45:58 <benmachine> mercuryrising: "source" is a built-in command, there is no binary file for it
14:46:14 <dwcook> Does anyone know of a Haskell package that interfaces with a virtual machine? I would essentially like to run a Linux system using a Haskell program.
14:46:18 <benmachine> mercuryrising: bash recognises it as a special thing and does something different from what it does when you give it a program name
14:46:31 <Kaidelong> roboguy_: Agreed, that's basically what I was trying to say
14:47:02 <Kaidelong> actually it's the same pedagogical reason I was complaining about manifest types earlier, they expose unimportant information
14:47:50 <roboguy_> Kaidelong: well, it depends on how you use types I suppose. I would try to expose meaningful type names through type synonyms and newtypes
14:47:58 <dleedev> what are the proper terms for types of kind * -> * and types of kinds *?
14:48:02 <dwcook> Woops, didn't anticipate having to leave. >_< Please memo me or use lambdabot if you have an idea. Thanks!
14:48:07 <dleedev> "type constructor" and "concrete type"?
14:50:06 <dleedev> "parameterized type" and "type"?
14:51:03 <benmachine> I prefer your first alternatives
14:51:16 <benmachine> I would say that Maybe is not a type, except when speaking informally/loosely
14:51:34 <chrisdone> interesting
14:51:52 <hpc> @tell dwcook this might be relevant: https://www.vmware.com/support/developer/vix-api/index.html - obviously it would require some ffi
14:51:52 <lambdabot> Consider it noted.
14:51:52 <dleedev> benmachine: is there a consensus in Haskell?
14:52:07 <benmachine> dleedev: I don't know, wait and see if anyone disagrees with me :P
14:52:10 <chrisdone> i can't remember wwhat the report calls it
14:52:14 <chrisdone> maybe 'type constructor'
14:53:01 <hpc> benmachine: it's a type constructor and a type
14:53:06 <hpc> but not a concrete type
14:53:15 <chrisdone> probably anything that has a kind is a type
14:53:17 <hpc> (types are things that have a kind)
14:53:23 <chrisdone> like anything that has a type is a value
14:53:26 <dleedev> what do you call a type with kind * -> * -> *?
14:53:31 <hpc> (type constructors are types with capital letters at the start)
14:53:32 <dleedev> type constructor constructor?
14:53:40 <hpc> dleedev: just a type
14:53:57 <hpc> dleedev: (+) is a value (and a function, but not a "function function")
14:53:59 <nisstyre> dleedev: a kind is the type of a type, so a thing with any kind is a type (or type constructor)
14:54:06 <dleedev> hpc: but what if I want to differentiate between types of kind *, * -> *, and * -> * -> *?
14:54:09 <hpc> if haskell was more elaborate, it would be a type-level function
14:54:29 <dleedev> hpc: there are no terms that specify beyond "type"?
14:54:30 <nisstyre> dleedev: you can
14:54:52 <roboguy_> hpc: can't you use a type variable as a type constructor?
14:55:12 <nisstyre> roboguy_: yes you can
14:55:20 <nisstyre> e.g. Monad m => m a
14:55:29 <hpc> nisstyre: that's not really what he's asking though
14:55:38 <nisstyre> hpc: who? dleedev ?
14:55:39 <hpc> m is a type variable, not a type constructor
14:55:47 <hpc> nisstyre: roboguy_
14:55:56 <nisstyre> hpc: but it has to be instantiated with one
14:56:00 <nisstyre> eventually
14:56:10 <hpc> it could be instantiated as Maybe, or it could be instantiated as ST s
14:56:22 <nisstyre> yeah
14:56:25 <roboguy_> hpc: is 'a' a type?
14:56:42 <hpc> 'a' and 'm' are both type variables
14:56:48 <hpc> 'm' has kind * -> *
14:56:50 <hpc> 'a' has kind *
14:57:14 <hpc> a type constructor is something with a capital letter
14:57:19 <hpc> Maybe, IO, etc
14:57:24 <dleedev> hpc: Int?
14:57:29 <hpc> and Int
14:57:37 <hpc> this is similar to the distinction at the value level
14:57:42 <hpc> True is a constructor
14:57:46 <hpc> (:) is a constructor
14:57:50 <hpc> (+) is not a constructor
14:57:53 <hpc> but all three are values
14:58:02 <hpc> the latter two are both functions even
14:58:35 <hpc> so if you cared to list all the things 'm' is, say
14:58:50 <hpc> it's a type variable with kind * -> *, which you could also call a type-level function
14:59:22 <hpc> Either is a type constructor with kind * -> * -> *, also a type-level function
14:59:39 <hpc> (Either Int) is a type expression with kind * -> *, also a type-level function
14:59:58 <dleedev> is (Either Int) also a type constructor?
14:59:59 <hpc> as is (Either e), (t m ())
15:00:06 <hpc> Either Int is not a type constructor
15:00:19 <hpc> in the same way that (1 :) is not a type constructor
15:00:24 <hpc> er, value constructor
15:00:31 <chrisdone> hey schell
15:00:47 <hpc> dleedev: basically, take your understanding of constructor, value, expression, function
15:00:54 <hpc> dleedev: and lift it all from the value level to the type level
15:00:54 <Axman6> but Either Int has kind * -> * right?
15:01:02 <hpc> yes
15:01:04 <chrisdone> :k Either Int
15:01:05 <lambdabot> * -> *
15:01:05 <schell> chrisdone: yo chris
15:01:11 <chrisdone> sup? =)
15:01:12 <nisstyre> :k Either Int Int
15:01:13 <lambdabot> *
15:01:14 <Axman6> sp Either Int is a partially applied type constructor
15:01:17 <roboguy_> hpc: wait, (1:) isn't a value constructor?
15:01:19 <Axman6> so*
15:01:31 <schell> i'm in a work summit
15:01:36 <schell> you?
15:01:39 <chrisdone> axman6: long time no see
15:01:45 <chrisdone> schell: chillin' with a beer. what work summit?
15:01:46 <hpc> roboguy_: no; (:) is the constructor; constructors are identifiers, but (1:) is an expression
15:02:12 <Axman6> indeed. been getting back into haskell, irc, and programming over the xmas/new year break
15:02:15 <roboguy_> hpc: hmm, alright
15:02:29 <dleedev> hpc: I see, constructors are not a runtime concept
15:02:40 <schell> my company (the one i work for) is having a training session and future planning and party session today, tonight and tomorrow morning
15:02:43 <chrisdone> axman6: \o/ welcome back
15:02:47 <Axman6> =)
15:02:51 <schell> chrisdone: beer sounds good
15:03:01 <chrisdone> schell: sounds fun =)
15:03:17 <Axman6> chrisdone: work has meant little free time sadly. :(
15:03:25 <chrisdone> axman6: good work?
15:03:29 <schell> chrisdone: work today and then partying the rest of the time ;)
15:03:50 <Axman6> not really. I'm strongly considering leaving. patent examination is a very unrewarding job
15:03:56 <hpc> chrisdone: the summit of mount -l -t tmpfs
15:04:09 <hpc> (it's a fairly obscure mountain)
15:04:13 <Axman6> looking an internship at Galois at the moment, see if they'll have me
15:04:30 <schell> Axman6: isn't that what Einstein did for a while?
15:04:35 <Axman6> yeah
15:04:49 <hpc> i thought einstein's thing was the patent office
15:04:56 <Axman6> and Alexander Graham Bell, where he stoll the idea for the telephone from someone else's patent application
15:05:07 <hpc> oh, i suck at reading lol
15:05:16 <schell> :)
15:05:47 <dleedev> I have question whether I'm understanding Functor correctly: given Functor f a, is f (of kind * -> *) the mapping between categories C and D where Obj(C) = a and Obj(D) = f a?
15:06:12 <hpc> (my next objection was going to be that galois and einstein weren't even alive at the same time)
15:07:17 <chrisdone> axman6: good luck!
15:07:45 <jrmithdobbs> @pl \xs -> "<" <> xs <> ">"
15:07:45 <lambdabot> (<> ">") . ("<" <>)
15:08:04 <schell> hpc: if they were i'm sure einstein would have written some kick ass programs
15:08:37 <NickKidman> how do I do that right:
15:08:37 <NickKidman> f1 :: Integer -> Integer
15:08:37 <NickKidman> f1 x = x^2
15:08:48 <dleedev> hmm... maybe I should have said "Functor f => f a" instead of "Functor f a"
15:09:01 <hpc> schell: time machine + galois + ada lovelace + a doberman = tv show
15:09:08 <quchen> NickKidman: Looks right to me.
15:09:10 <joneshf-laptop> so i'm looking at dijkstra's
15:09:16 <joneshf-laptop> and comonad
15:09:18 <joneshf-laptop> 's
15:09:31 <Lethalman> dleedev, when talking about functors you should talk about fmap
15:09:37 <joneshf-laptop> it seems dijkstra's algo is comonadic
15:09:42 <quchen> :t let f1 :: Integer -> Integer; f1 x = x^2 in f1 -- NickKidman
15:09:43 <lambdabot> Integer -> Integer
15:10:01 <chrisdone> axman6: don't let axman1, axman2, axman3, axman4 or axman5 beat you
15:10:01 <joneshf-laptop> i wonder, does that mean A* could be comonadic as well?
15:10:12 <Axman6> chrisdone: they're already dead
15:10:16 <chrisdone> :D
15:10:17 <roboguy_> man, I wish SublimeHaskell was a little more stable...
15:10:28 <shachaf> Bynbo7 is the real threat here.
15:10:29 <chrisdone> what doth SublimeHaskell offere?
15:10:32 <joneshf-laptop> roboguy_, what issues are you runninginto?
15:10:44 <chrisdone> shachaf =)
15:10:47 <roboguy_> joneshf-laptop: it seems to crash semi-regularly and it can be a bit slow
15:10:52 <CADD> roboguy_: use emacs
15:10:54 <roboguy_> (on OS X)
15:11:04 <joneshf-laptop> roboguy_, yeh, or throw more cores at it
15:11:09 <CADD> chrisdone: you would know about the joys of emacs and haskell ;)
15:11:13 <joneshf-laptop> roboguy_, though emacs is the chaeper way :)
15:11:23 <chrisdone> hmm, that's strange. sublime is pretty stable and its extension language is python. i wouldn't expect hard crashes
15:11:26 <hpc> joneshf-laptop: huh, it really does look comonadic
15:11:28 <chrisdone> CADD: oh ja
15:11:36 <chrisdone> ≖‿≖
15:11:38 <roboguy_> yeah, but emacs needs a lot of tweaking usually
15:11:41 <joneshf-laptop> roboguy_, if you tunr off the module inspector, and something else it makes it go pretty nice
15:11:43 <roboguy_> I've used it a lot
15:11:51 <Lethalman> dleedev, you get a mapping from f a to f b for free if you have a mapping from a to b, that's it
15:11:56 <joneshf-laptop> roboguy_, there was an issue on the github repo, lemme see if i can find it
15:12:14 <jrmithdobbs> chrisdone: you don't expect hard crashes and deadlocks out of python by default?
15:12:32 <jrmithdobbs> chrisdone: because that's exactly how python's runtime acts in my experience?
15:12:35 <hpc> joneshf-laptop: you should definitely try writing a comonadic version of it; there's probably some interesting things to do there with applications to other graph stuff
15:13:16 <CADD> chrisdone: loving structured-haskell-mode by the way! Thanks SOOOOOOOOO MUCH!!
15:13:17 <chrisdone> jrmithdobbs: i've never really used python, i'd just assumed with it being a high level language that it wouldn't have crashes outside of in-language exceptions
15:13:25 <chrisdone> CADD: ヽ (＾▽＾) ﾉ!!!
15:13:30 * hackagebot purescript 0.2.10.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.10.2 (PhilFreeman)
15:13:44 <jrmithdobbs> chrisdone: python can crash/deadlock at a sneeze assuming the sneeze comes from the os in the form of a badly timed signal
15:13:48 <hpc> chrisdone: the problem with that is python loves exceptions; you will be hitting them constantly
15:13:58 <chrisdone> CADD: added some experimental stuff recently so that the "auto-fill" skeletons' "undefined" values are kind of ephemeral: http://chrisdone.com/shm-skeletons.ogv
15:14:03 <jrmithdobbs> chrisdone: it's a sad long standing issue
15:14:05 <dleedev> Lethalman: but is f's f_objects (object mapping) mapping f a to f b, or is it mapping (a,b) to f (a,b)?
15:14:06 <joneshf-laptop> roboguy_, https://github.com/SublimeHaskell/SublimeHaskell/issues/61
15:14:09 <roboguy_> chrisdone: well, the plugin crashes and I have to restart sublime to get the plugin to start again
15:14:11 <joneshf-laptop> roboguy_, though i thought there was another
15:14:16 <jrmithdobbs> chrisdone: I don't understand why people bitch about the GIL more, tbqh
15:14:22 <joneshf-laptop> hpc, yeah, i think that's my weekend project :)
15:14:28 <Lethalman> dleedev, ? what is f_objects
15:15:12 <chrisdone> roboguy_: yeah that's pretty horrific
15:15:13 <dleedev> f is a functor with a pair of mappings. f_objects is the object mapping.
15:15:18 <dleedev> Lethalman: ^
15:15:24 <chrisdone> emacs does crash sometimes, but i have to really do some obscure elisp with it
15:15:43 <CADD> chrisdone: OOO! *Downloads more dangerous alpha-level software!*
15:15:44 <joneshf-laptop> roboguy_, also, are you using ST2 or ST3?
15:15:48 <chrisdone> CADD: :D
15:15:52 <CADD> :D
15:16:15 <roboguy_> chrisdone: you're the author of that structured haskell mode right? I haven't tried that yet. I used to use emacs a lot, but I got tired of having to spend quite a bit of time figuring things out and tweaking things
15:16:17 <roboguy_> joneshf-laptop: ST3
15:16:18 <Lethalman> pair mapping? f_objects?
15:16:43 <Lethalman> dleedev, are you confident with OO languages like java?
15:16:44 <joneshf-laptop> you know, the other thing is that lighttable was just open sourced
15:16:49 <the_berserker> > let fibs = 0: scanl (+) 0 fibs in fibs
15:16:49 <dleedev> Lethalman: yes
15:16:50 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
15:16:52 <joneshf-laptop> with plugins
15:17:00 <joneshf-laptop> so you could make a haskell plugin for that
15:17:04 <Axman6> I'd like to see haskell support in light table
15:17:12 <joneshf-laptop> though, i imagine it'd be way more buggy
15:17:15 <NickKidman> I've written "[1..]" and now its looping, what do?
15:17:23 <the_berserker> > let fibs = 0: scanl (+) 1 fibs in fibs
15:17:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:17:24 <Axman6> NickKidman: ctrl-c
15:17:27 <Lethalman> dleedev, if ArrayList<T> was a functor, then you could map an ArrayList<A> to any ArrayList<B> if you had a function from A to B
15:17:28 <jrmithdobbs> NickKidman: ^c
15:17:35 <chrisdone> CADD: i wonder if it will be a solution to the "do x <- y" problem in shm… like, maybe writing do SPC should insert "do undefined" and then typing 'x <- ' should insert an "undefined" on the next line to ensure a valid tree is maintained
15:17:37 <the_berserker> @pl let fibs = 0: scanl (+) 1 fibs in fibs
15:17:38 <lambdabot> fix ((0 :) . scanl (+) 1)
15:17:54 <dleedev> Lethalman: yeah, that I understand
15:17:55 <Lethalman> hope people in here don't read what I said, but that should be clear :P
15:18:01 <NickKidman> @Axman6: thx
15:18:01 <lambdabot> Unknown command, try @list
15:18:10 <joneshf-laptop> Lethalman, too late
15:18:39 <CADD> chrisdone: wow, that sounds great!
15:18:54 <dleedev> Lethalman: I was trying to understand it in more of a category theory way
15:19:34 <Lethalman> dleedev, A and B are categories, and ArrayList is the functor :P
15:19:54 <dleedev> Lethalman: thank you
15:21:13 <dleedev> Lethalman: hmm... doesn't ArrayList map from T to ArrayList<T>?
15:21:32 <CADD> roboguy_: I think that the configuration issues have gotten much better with things like package-install, el-get, and customize-groups
15:21:34 <dleedev> Lethalman: if A and B are categories, then the function from A to B would be the functor, not ArrayList
15:22:06 <the_berserker> > let fib 0 = 0; fib 1 = 1; fib n = fib (n-1)+ fib (n-2) in map fib [0..]
15:22:10 <lambdabot>  mueval-core: Time limit exceeded
15:22:32 <Lethalman> dleedev, the function from A to B is a function from A to B
15:22:52 <chrisdone> lethalman: get outta town!
15:23:14 <roboguy_> CADD: yeah but some things are over complicated or at least feel over complicated. that affects my thought process when I use it, if nothing else. some questions seem to have answers more complicated than they need to be, for example "where is the redo button?"
15:23:16 <Lethalman> the functor takes a morphism from A to B and gives you a morphism from F A to F B
15:23:20 <monochrom> tautologies are reserved for monochrom :)
15:23:25 <Lethalman> chrisdone, hi :)
15:23:34 <chrisdone> hey there
15:23:42 <CADD> roboguy_: there is a very big difference between complicated and complex
15:23:46 <quidnunc> I have a library foo that depends on another (patched) library, bar. I'm trying to build an executable based on foo using cabal sandbox. When I try to install --only-dependencies building foo fails, it appears that it isn't using the patched version of bar. How do I fix this?
15:23:51 <dleedev> Lethalman: so A and B are objects in a single category, not two separate categories, right?
15:24:36 <roboguy_> CADD: it tends to make me feel overwhelmed and the last thing I need to feel while programming is even more overwhelmed haha
15:24:38 <chrisdone> CADD: agreed!
15:25:18 <CADD> roboguy_: things get complicated when you do not have the ability to do something right, things are complex when they have all the features you will ever need
15:25:26 <dleedev> Lethalman: the functor takes a morphism from A to B (an arrow in C) and gives you a morphism from F A to F B (an arrow in D), no?
15:25:41 <CADD> chrisdone: :D
15:25:50 <chrisdone> the mandelbrot set is complex, microsoft word is complicated
15:26:08 <roboguy_> CADD: also, I say this as someone who's used emacs for several years (although I haven't put too much time into learning all the tricks and shortcuts)
15:26:11 <CADD> couldnt have said it better myself!
15:26:55 <CADD> roboguy_: well, ive used vim for years. and emacs seems like a paradise in comparison
15:26:57 <chrisdone> roboguy_: written any elisp?
15:27:08 <roboguy_> I don't know, it feels like I would have to put a lot of time into it with not very much reward
15:27:30 <CADD> chrisdone: i cant wait until the guilemacs merge!
15:27:31 <roboguy_> chrisdone: not more than a few lines. I'm pretty familiar with lisp languages in general though
15:27:33 <bitemyapp> elisp isn't that hard to learn.
15:27:36 <jrmithdobbs> CADD: hilarious, because I did the opposite transition over a decade ago and felt the same way
15:27:36 <bitemyapp> It just never stops sucking.
15:27:39 <jrmithdobbs> CADD: ;p
15:27:43 <roboguy_> CADD: haha, *that* I can believe!
15:28:06 <Lethalman> dleedev, mh yes think so from a category theory pov, but the A->B is not an object in C, it's a morphism of the category C
15:28:13 <CADD> jrmithdobbs: different strokes for different folks!
15:28:20 <chrisdone> roboguy_: in my not-so-humble-opinion you aren't really *using* emacs until you've written your own elisp. until then you could easily be using sublime, vim or visual studio for all it matters
15:28:31 <jrmithdobbs> CADD: must say, it's weird to be a unix admin that knows more CL than vimscript though
15:28:48 <CADD> jrmithdobbs: what is your favorite part about vim?
15:28:58 <roboguy_> chrisdone: I agree, which is why I've pretty much decided I won't use emacs in any sense until (and unless) I decide to learn more about it
15:29:04 <Lethalman> dleedev, oh, yes in the ArrayList<A> and ArrayList<B> I was very misleading sorry
15:29:07 <CADD> jrmithdobbs: :D oh good, now i really want to hear your opinion!
15:29:13 * Lethalman never uses java again :P
15:29:22 <chrisdone> bitemyapp: let's make a haskell backend for elisp
15:29:30 <jrmithdobbs> CADD: editor state, simplicity, easy command repeatability without killing my wrist (that's not a joke, i actually switched at same time i switched to dvorak and a bunch of crazy desk stuff re: rsi issues)
15:29:37 <Lethalman> A and B are objects of the same category for which you have a morphism, that should be it
15:29:42 <roboguy_> chrisdone: I mean, emacs is interesting to me and it does seem very useful, it can just feel really intimidating and impenetrable and I don't know where to start
15:29:42 <jrmithdobbs> CADD: 'editor state' == input vs command mode
15:29:56 <chrisdone> jrmithdobbs: question: do you rest your wrists on the desk/pad/keyboard when you type?
15:30:02 <jrmithdobbs> nope
15:30:15 <chrisdone> roboguy_: yeah, it has a wide surface area
15:30:23 <CADD> jrmithdobbs: right, ive heard of emacs pinky. but ironically enough god-mode solves both the pinkey problem ad adds modes!
15:30:31 <chrisdone> CADD: you use god-mode, too?
15:30:38 <CADD> chrisdone: nudge nudge, sell your sdoftware
15:30:39 * chrisdone thinks CADD is his new best friend
15:30:47 <CADD> chrisdone: lol, i must be a secret fan boy of yours!
15:30:48 <roboguy_> I've heard people talk about emacs god-mode before. what is it?
15:30:53 <dleedev> Lethalman: A->B is an arrow in C, right?
15:30:53 <bitemyapp> chrisdone: I was thinking about that. Usually people do stuff like Pymacs.
15:31:19 <jrmithdobbs> CADD: and at this point anything i can't accomplish inside vim i can with multiple vim sessions and tmux so it's just not worth spending time on ;p
15:31:20 <roboguy_> ah, it gets rid of some of the modifiers?
15:31:27 <Lethalman> dleedev, yes
15:31:42 <chrisdone> roboguy_: so when you activate god-mode, any key n that you press, comes implicitly C-n. this avoids having to write key chords
15:31:54 <chrisdone> Before: C-p C-k C-n M-^ ) C-j C-y M-r C-x z z M-2 C-g C-g C-x C-s
15:31:55 <chrisdone> After:    p   k   n g ^ )   j   y g r     . .   2   g   g   x   s
15:31:56 <chrisdone> \o/
15:32:00 <jrmithdobbs> chrisdone: oh that's nice
15:32:02 <dleedev> Lethalman: so "fmap x" means take x (an arrow in C) and map it to an arrow in D
15:32:03 <roboguy_> chrisdone: kind of like vi?
15:32:04 <CADD> jrmithdobbs: there is also emacs-client. so you are connecting to a persistent emacs session. no slow rerestarts!
15:32:08 <jrmithdobbs> chrisdone: why did that take 3 decades?
15:32:15 <chrisdone> roboguy_: quite like vi/vim, yeah
15:32:38 <CADD> jrmithdobbs: idk, people were busy with making emacs awesome in different ways?
15:32:42 <chrisdone> jrmithdobbs: i guess people are hung up on there being only two ways to do it (emacs and vim)
15:32:42 <jrmithdobbs> CADD: d/c about startup time even, i leave macvim open all the time
15:32:49 <dleedev> Lethalman: then given "fmap x y", x is an arrow in C and y is an object in D?
15:32:52 <CADD> jrmithdobbs: as do it
15:32:58 <CADD> as do i*
15:33:01 <roboguy_> chrisdone: hmm, that does sound handy, with caps lock bound as esc like you suggest
15:33:32 <roboguy_> I'll have to get used to using the control key as control in other programs though, hah
15:33:43 <jrmithdobbs> CADD: my default languages i head to when half asleep/drunk/etc are sh and sed so that's probably the main reason for my affinity, if I really think about it
15:33:51 <Lethalman> dleedev, yes, seems right to me
15:34:11 <roboguy_> on the other hand, I bet it's impossible to do that mapping in OS X...
15:34:38 <CADD> jrmithdobbs: and i pine over the days when lisp machines were actually on the market.. TT.TT
15:34:39 <dleedev> Lethalman: then that means that given Functor f, f is the object mapping from C to D and fmap is the arrow mapping from C to D, right?
15:34:57 <CADD> jrmithdobbs: i wasnt even alive at that point.
15:35:01 <chrisdone> roboguy_: yeah, i kinda like my caps lock key and miss it a wee bit
15:35:08 <jrmithdobbs> CADD: sadly, i'm not nearly old enough for any of the above to make sense anyways ;p
15:35:26 <jrmithdobbs> CADD: (what I said, i know what a lisp machine is, obviously)
15:36:09 <Lethalman> dleedev, something like that, except you don't have the C -> D mapping, you only have fmap
15:36:17 <Lethalman> the C -> D mapping is this:
15:36:18 <Lethalman> :t pure
15:36:19 <lambdabot> Applicative f => a -> f a
15:36:31 <Lethalman> which is from applicative though in haskell
15:37:28 <dleedev> Lethalman: ah, ok. so pure is the object mapping and fmap is the arrow mapping?
15:37:34 <Lethalman> guess so
15:38:21 <slack1256> why this works
15:38:34 <dleedev> Lethalman: ok, thanks
15:38:34 <roboguy_> chrisdone: do you have any tips for learning more about emacs?
15:38:35 <monochrom> because Pete said so
15:38:43 <slack1256> > [n | (Just n) <- [Nothing, Just 5]]
15:38:44 <lambdabot>  [5]
15:38:48 <slack1256> while this not
15:38:48 <Lethalman> there's no way to can build an f a from an a simply with Functor, you don't know how to construct the type
15:38:50 <robonerd> is haskell suitable to rapid prototype web apps? (i like ruby but i also prefer static typing or at least an 'opt in' static typing support)
15:39:06 <slack1256> (Just 5) <- [Nothing, Just 5]
15:39:09 <slack1256> > (Just 5) <- [Nothing, Just 5]
15:39:10 <lambdabot>  not an expression: `(Just 5) <- [Nothing, Just 5]'
15:39:17 <slack1256> > (Just n) <- [Nothing, Just 5]
15:39:18 <lambdabot>  not an expression: `(Just n) <- [Nothing, Just 5]'
15:39:21 <monochrom> ah, the wonder of splitting a coherent question into a million incoherent pieces
15:39:38 <monochrom> you need to put that in a do-block, and it works there
15:40:01 <roboguy_> slack1256: when a pattern match fails like that in a do block (and I think a list comprehension) it calls "fail"
15:40:08 <dleedev> Lethalman: but you don't need to know how to build one, do you? you just need to know that there's a mapping?
15:40:11 <monochrom> > do { Just n <- [Nothing, Just 5]; return n }
15:40:12 <lambdabot>  [5]
15:40:15 <Axman6> robonerd: sure, there's plenty of ways to do that. you can get great performance from the prototypes too i understand
15:40:30 <robonerd> Axman6 have you built web apps in haskell?
15:40:36 <roboguy_> @src [] fail
15:40:36 <lambdabot> fail _      = []
15:40:43 <Lethalman> dleedev, well sometimes you need to put a value into some context, and that's what pure is for
15:40:44 <slack1256> Oh
15:40:49 <Lethalman> dleedev, like you do with return in monads
15:40:49 <Axman6> not really, web apps aren't my thing
15:40:53 <slack1256> that fail instance make sense
15:40:53 <Lethalman> :t return
15:40:54 <lambdabot> Monad m => a -> m a
15:40:55 <Lethalman> :t pure
15:40:56 <lambdabot> Applicative f => a -> f a
15:41:01 <chrisdone> roboguy_: probably i'll admit that it was some years before i actually started reading the emacs manual. probably knowing how to inspect emacs and really know what your environment is doing is an indispensable tool. so the real basics: C-h k (get whatever this key binds to), C-h v (describe some variable), C-h f (describe the given function), C-h m (describe this mode and all its keybindings). those are some uber useful utilities
15:41:05 <CADD> roboguy_: my suggestion: https://github.com/bbatsov/guru-mode
15:41:08 <roboguy_> slack1256: fail is a bit controversial because of the String argument
15:41:20 <slack1256> Yeah, but here is kind of nice
15:41:29 <quchen> No, it's controversial because many monads cannot have a sensible `fail`.
15:41:35 <Axman6> slack1256: what you wrote is equivalent to "[Nothing, Just 5] >>= \(Just n) ->" (roughly)
15:41:35 <ion> And because it’s not in a separate type class.
15:41:37 <roboguy_> quchen: that too
15:41:49 <CADD> roboguy_: that is mostly learning proper keyboard usage.
15:41:50 <roboguy_> chrisdone: thanks!
15:41:56 <monochrom> I guess I alone don't understand the question.
15:42:15 <dleedev> Lethalman: yeah, but that's at a different level than CT, right? because we're dealing with values instead of objects...
15:42:24 <roboguy_> CADD: I haven't heard of that. that looks cool for learning. thanks!
15:42:42 <robonerd> Axman6 ?
15:42:48 <skypers> I discovered something interesting
15:42:52 <skypers> when I have a list
15:42:57 <roboguy_> quchen, ion: the general consensus is that it should be removed and mzero used instead, right?
15:43:05 <slack1256> monochrom: Making it in a do block worked, neat
15:43:12 <Lethalman> dleedev, values instead of objects? no that's not the point
15:43:16 <skypers> I have two options to build a value with it
15:43:16 <CADD> roboguy_: also: http://emacsrocks.com/ https://www.youtube.com/playlist?list=PLABBCB510477C08DB
15:43:16 <chrisdone> roboguy_: also, e.g. try to scratch an itch all by yourself. find some thing that's very manual and boring to do in your editor and then automate it. learning the things necessary to do it will probably require hitting the manual and opening your familiarity with emacs as a system
15:43:19 <skypers> maybe three
15:43:26 <Axman6> robonerd: I said no, I'm not particularly interested in web apps
15:43:31 <slack1256> > [Nothing, Just 5] >>= (\(Just n) -> return n)
15:43:32 <lambdabot>  *Exception: <interactive>:3:24-44: Non-exhaustive patterns in lambda
15:43:34 * hackagebot dictparser 0.3.0.0 - Parsec parsers for the DICT format produced by dictfmt -t  http://hackage.haskell.org/package/dictparser-0.3.0.0 (MarkWotton)
15:43:42 <skypers> 1. a simple foldl; 2. State + mapM_; 3. Writer + mapM_
15:43:53 <quchen> roboguy_: A MonadFail class would be better, not all MonadPlus have `fail = const mzero` (e.g. STM)
15:44:00 <Lethalman> dleedev, everything can be an object, it's abstract
15:44:10 <chrisdone> it also sucks that fail takes a string
15:44:20 <CADD> roboguy_: also, learn about m-x customize
15:44:23 <chrisdone> String sucks because it's a  list of characters, and because it's text
15:44:26 <jrmithdobbs> yes, fail taking a string is the dumbest thing
15:44:29 <roboguy_> CADD: what's that do?
15:44:52 <robonerd> k
15:44:59 <Axman6> are there any parsers as powerful as Parsec for Text?
15:45:03 <robonerd> is there any haskeller around that uses it for building web apps?
15:45:05 <CADD> roboguy_: pretty much every setting that is provided has a gui made for it that you can then customize those setting with
15:45:07 <slack1256> Attoparsec!
15:45:21 <skypers> why is parsec so powerful?
15:45:22 <CADD> roboguy_: if you have haskell-mode installed
15:45:27 <chrisdone> parsec can be used with text, i'm sure, but i've never been able to get it working
15:45:32 <Axman6> Attoparsec isn't really designed for much more than binary parsing is it?
15:45:36 <quchen> Axman6: Yes, Parsec for example.
15:45:40 <dleedev> Lethalman: so pure is *a* functor from x to f x
15:45:44 <chrisdone> but yeah, attoparsec works well with text
15:45:45 <CADD> roboguy_: try: m-x customize-group RET haskell-mode RET
15:45:54 <roboguy_> Axman6: I thought it was for general purpose parsing
15:45:57 <Lethalman> dleedev, no pure is not a functor
15:46:05 <slack1256> Axman6: I don't know, but it pretty damn fast for text and bytestrings
15:46:07 <chrisdone> axman6: here's a trivial attoparsec parser for text: https://github.com/chrisdone/ini/blob/master/src/Data/Ini.hs
15:46:10 <CADD> skypers: its because its a parser *combinator* library, not a parser *generator* library
15:46:12 <Axman6> it could be
15:46:20 <dleedev> Lethalman: I mean pure is the arrow mapper of a functor
15:46:26 <skypers> CADD: what about it’s performances?
15:46:30 <Lethalman> fmap is the mapping between arrows
15:46:33 <dleedev> Lethalman: sorry, the object mapper
15:46:34 <roboguy_> CADD: I have haskell-mode installed but it doesn't list it in customize-group
15:46:34 <Axman6> hmm, turns out an attoparsec is just over 3cm
15:46:37 <chrisdone> axman6: there're different modules for ByteString vs Text with different combinators
15:46:38 <CADD> skypers: hmm?
15:46:44 <skypers> its*
15:46:45 <Saizan> dleedev: is it?
15:46:50 <dleedev> Lethalman: pure is the object mapper and fmap is the arrow mapper
15:46:57 <CADD> roboguy_: oh, you may need to enable it first. m-x haskell-mode RET
15:47:16 <dleedev> Saizan: that's what our conversation came down to so far... is that wrong?
15:47:18 <Lethalman> should be that, unless some here says something different :P
15:47:21 <roboguy_> CADD: emacs still doesn't like it
15:47:24 <CADD> skypers: i didnt understand your question
15:47:37 <chrisdone> M-x customize-group haskell   ← also works. it might load the mode automatically
15:47:42 <CADD> oh yeah
15:47:51 <roboguy_> ah, that works
15:47:54 <chrisdone> \o/
15:47:55 <CADD> just M-x customize-group haskell RET
15:47:57 <CADD> :D
15:48:00 <skypers> CADD: is parsec effective at runtime?
15:48:01 <Saizan> dleedev: i don't know if there's some POV where that's correct, but i'd say that 'f' itself is the object mapper that corresponds to fmap being the arrow mapper
15:48:02 <CADD> ty chris!
15:48:08 <chrisdone> np!
15:48:09 <skypers> I mean, parsing a lot of data in a few times
15:48:37 <CADD> skypers: it does what you tell it to do?
15:48:41 <Lethalman> dleedev, afaik, in haskell objects are the types, that is you are going from a to f a, which are two different types (objects)
15:48:44 <dleedev> Saizan: that's what I thought at first
15:48:49 <chrisdone> i think that attoparsec is faster than parsec by omiting things that are generally slower, like certain kinds of backtracking and repetition
15:48:56 <skypers> CADD: o–kay……
15:49:05 <CADD> skypers: what do you mean by effective?
15:49:10 <chrisdone> and more wordy error messages
15:49:19 <skypers> well some parsers are very slow
15:49:22 <dleedev> Lethalman: yeah, that's how I understood it
15:49:23 <quchen> chrisdone: Also Parsec is a transformer, Attoparsec is not
15:49:23 <skypers> for no descent reasons
15:49:32 <skypers> I just wonder what’s about parsec
15:49:36 <chrisdone> quchen: good point
15:49:44 <jrmithdobbs> chrisdone: ya like the issue i was running into confusing me earlier where you can't match against "not end of string" and backtrack it
15:49:51 <jrmithdobbs> chrisdone: without mondadic stuff
15:49:52 <chrisdone> generally i use parsec when i want extensibility, and attoparsec when i don't care and just want speed
15:50:07 <Lethalman> dleedev, but then that should be lowered at runtime, in that the real mapping is between objects of type a and f a
15:50:24 <chrisdone> jrmithdobbs: oh, what was that?
15:50:49 <xintron> For an efficient sed-clone in haskell, would one benefit from operating on (lazy) ByteString or Text (or read ByteString and convert to Text when needed)?
15:51:20 <skypers> xintron: using String would be idiot?
15:51:21 <CADD> skypers: its hard to say how something will perform without tests. parsec is slower on some things, that is why attoparsec was written
15:51:30 <ReinH> chrisdone: sorry I'm not familiar with digestive functors aside from a vague notion that they digest things
15:51:33 <jrmithdobbs> chrisdone: http://lpaste.net/98308
15:51:40 <roboguy_> skypers: String is a linked list of characters, so it's not usually the most efficient
15:51:41 <skypers> ok, thank you
15:51:43 <CADD> skypers: you usually want to avoid string and use text
15:51:45 <ReinH> and I'm not sure if digesting things helps with (pseudo) natural language processing
15:51:56 <roboguy_> skypers: in fact, type String = [Char]
15:52:00 <skypers> CADD: I actually use String everywhere
15:52:03 <xintron> skypers, Don't understand your question
15:52:06 <skypers> I know that roboguy_
15:52:16 <CADD> skypers: its pretty easy to switch it to text
15:52:30 <skypers> CADD: well, I don’t fell the need right now
15:52:39 <skypers> because as you just said, it’s a [Char]
15:52:45 <skypers> and perfectly fits some of my needs
15:52:53 <ReinH> chrisdone: my only familiarity with them is that they are used for form handling by happstack or something.
15:52:55 <chrisdone> einh: what about formlets?
15:52:56 <skypers> for instance, reading a file and pass it to a C function
15:52:58 <jrmithdobbs> chrisdone: the majority of the processing in taht is done with takeWhile1 which never fails parsing so can't be used with <|> and I need that parser passed to many1 which requires it to fail
15:53:12 <Axman6> String is fine if you don't need to work with big strings
15:53:13 <chrisdone> oh i see
15:53:22 <adnap> Will getDirectoryContents return "." and ".." on Windows?
15:53:35 <skypers> Axman6: and if I want to, I’d better switch to Text?
15:53:43 <adnap> I guess not.
15:53:49 <ReinH> chrisdone: oh it provides a nice applicative for processing forms. I'm not sure if that will help with tokenizing, tagging and etc for nlp
15:53:51 <CADD> skypers: yup String works really well
15:53:59 <Axman6> skypers: if it's textual data yes, if it's binary ByteString
15:54:09 <skypers> I see
15:54:10 <skypers> thank you
15:54:25 <skypers> I might need to switch really soon since I’m parsing assets stuff
15:54:27 <jrmithdobbs> chrisdone: I worked around it (as you can see) but I don't like it: = do { end <- atEnd ; if end then mempty else takeWhile1.... }
15:54:28 <skypers> 3D objects
15:54:33 <skypers> using String, it might be very slow
15:54:36 <dleedev> Saizan: if we say that f itself is the object mapper, then that means that by using Functor in Haskell, you'll only ever have one functor between a and f a, right?
15:54:37 <chrisdone> reinh: yeah, i guess one normally parses into tokens and then consumes into a command language. web forms and program arguments are good use-cases for formlets, so i figure it could be relevant
15:54:39 <jrmithdobbs> chrisdone: but I don't like that at all ;p
15:54:41 <skypers> plus I don’t use parsec, I only use reads
15:54:49 <jamiis> noob questions welcome here? I'm getting errors on my (inefficient) factoring implementation: factors n = [x | x <- [1..maxFactor], n `mod` x == 0] where maxFactor = ceiling $ sqrt n
15:55:14 <ReinH> chrisdone: I mean, tokenizing is `filter (not . isStopword) . words' so that's not too hard.
15:55:22 <roboguy_> jamiis: what sort of errors?
15:55:23 <Axman6> jamiis: what type is n?
15:55:34 <dleedev> Saizan: there's no other way to map object "a" in C to object "f a" in D. the only way is by using the type-level function f.
15:55:34 <roboguy_> ^ good point
15:55:37 <CADD> skypers: yes, you will notice pretty quickly how much faster text is!
15:55:51 <skypers> CADD: ok, sounds great, but why?
15:55:52 <Axman6> it looks like you want it to be an integer or some other Integral, but you're usingh sqrt which only works on...
15:55:55 <skypers> is it because it’s strict?
15:55:55 <Axman6> :t sqrt
15:55:56 <lambdabot> Floating a => a -> a
15:56:01 <Axman6> Floating values
15:56:03 <ReinH> chrisdone: And I probably don't need MUD2 style "DROP MY HEAVIEST WEAPON" parsing
15:56:07 <Saizan> dleedev: i wouldn't say that the functor is between a and f a, usually we say a functor is between a category C and another D, in this case they are both the same category
15:56:23 <roboguy_> jamiis: you probably want fromIntegral
15:56:26 <roboguy_> :i fromIntegral
15:56:27 <maxs`> Axman6: I have gone to sleep and woke up
15:56:30 <roboguy_> :t fromIntegral
15:56:31 <lambdabot> (Integral a, Num b) => a -> b
15:56:35 <jamiis> Axman6 n is an Integral. roboguy_ "No instance for (RealFrac t0) arising from a use of `factors'"
15:56:37 <chrisdone> reinh: mm, yeah, maybe not then. thinking about it more, the great use of formlets is that it's both a parser and a description at the same time. so it could parse "go here and do that" but also print "go <place> [and <do <thing>>]" (ish)
15:56:50 <Axman6> jamiis: you can't use sqrt on Integers
15:56:52 <robonerd> anyone interested in haskell web apps/sites/network services? join #haskell-web
15:57:00 <chrisdone> reinh: but maybe your domain is more complicated
15:57:00 <roboguy_> jamiis: right, but sqrt needs a Floating. there isn't anything that is both Integral and Floating so you must convert
15:57:02 <jamiis> axman6 ah
15:57:10 <CADD> skypers: because String is a singly linked list of char
15:57:23 <dleedev> Saizan: yeah, that's what I meant
15:57:25 <Saizan> dleedev: well, if you already specify the target of the functor has to be f a, then yeah
15:57:26 <Axman6> jamiis: maxFactor = ceil . sqrt . fromIntegral $ n
15:57:32 <skypers> CADD: what is Text then?
15:57:34 <skypers> a Vector?
15:57:44 <CADD> skypers: text is a binary representation of the string
15:57:51 <Axman6> I think it's a wrapped ByteString
15:57:56 <Axman6> essentially
15:57:57 <dleedev> Saizan: but that's what the class Functor is saying, right?
15:57:59 <CADD> mhm
15:58:02 <jamiis> axman6 roboguy_ thanks!
15:58:04 <skypers> and what is bytestring then?
15:58:11 <skypers> [Word32] ?
15:58:17 <skypers> [Word8]*
15:58:19 <roboguy_> skypers: that's still a linked list, I doubt it
15:58:22 <CADD> just like it sounds
15:58:39 <skypers> so what’s the real benefits of Text over String?
15:58:41 <Saizan> dleedev: the class Functor is letting you associate an arrow mapper to each object mapper
15:58:42 <Axman6> skypers: ByteString is a contiguous array of Word8
15:58:47 <dleedev> Saizan: it's saying an instance of Functor, f, is a object mapper between object a in category C and object f a in category D
15:58:50 <skypers> ooook
15:58:51 <chrisdone> Text is an array of Word16's
15:58:52 <roboguy_> skypers: I think ByteString uses arrays internally
15:58:52 <Axman6> or, a link list of chunkc made up of such
15:59:03 <skypers> C’s arrays?
15:59:07 <skypers> or Array?
15:59:09 <CADD> skypers:  its a series of bytes that serialize/deserialize between readable text and efficiently packed binary representations.
15:59:10 <ReinH> chrisdone: well, my domain is (some subset of) the English language, so almost certainly more complicated ;)
15:59:19 <roboguy_> skypers: probably C's arrays. it hides them though
15:59:20 <CADD> skypers: text is faster
15:59:32 <skypers> so why do we still use String?
15:59:32 <Axman6> skypers: malloc like arrays
15:59:41 <skypers> I saw Text exists in both strict and lazy version
15:59:43 <Saizan> dleedev: it's saying that 'f' is a functor between C and D (actually both = Hask)
15:59:46 <CADD> skypers: because its in the prelude
16:00:02 <Saizan> dleedev: well, 'f' is the object mapper part of it
16:00:04 <Axman6> because String being a list of Char is still quite useful
16:00:06 <chrisdone> reinh: possibly… it depends how your commands are defined =)
16:00:08 <jrmithdobbs> skypers: you shouldn't use String, basically
16:00:17 <ReinH> chrisdone: yep :)
16:00:18 <chrisdone> reinh: are you using attempto controlled english or just arbitrary grammar?
16:00:19 <Axman6> performance isn't the only factor
16:00:21 <dleedev> Saizan: where C is the category of where a is an object, and D is the category where f a is an object, right?
16:00:27 <Axman6> Strings are extremely easy to work with
16:00:32 <skypers> jrmithdobbs: whaat?
16:00:37 <skypers> why shouldn’t I use it?
16:00:37 <Axman6> jamiis: I disagree
16:00:41 <dleedev> Saizan: although in Haskell, they happen to be the same category Hask
16:00:42 <Axman6> uh, jrmithdobbs, not jamiis
16:00:47 <CADD> skypers: jrmithdobbs is right
16:00:54 <CADD> skypers: you shouldnt
16:00:55 <Saizan> dleedev: not necessarily, you can think of D as the whole category of haskell types, not just those that look like f a
16:00:57 <Axman6> no he's not...
16:00:59 <skypers> if I don’t, why is it in Prelude then?
16:01:03 <jrmithdobbs> Axman6: there's semantics and exceptions but in general i'll stick by that comment
16:01:09 <chrisdone> reinh: i've been wanted to do an app using ACE for a while and writing a parser for it would be fun. and then i'd make some converter to LogicT, etc.
16:01:18 <Saizan> dleedev: the codomain of a functor can be larger than its image
16:01:20 <ReinH> chrisdone: yeah, I need to decide how much flexibility I want. I'll probably just start with none and then see what feels missing.
16:01:22 <jrmithdobbs> skypers: because prelude was defined like 2 decades ago
16:01:24 <Axman6> Strings are perfect for simple text processing on small amounts of data
16:01:24 <jrmithdobbs> most of it
16:01:27 <roboguy_> skypers: it is okay for small strings, but for large strings it is slow
16:01:35 <Axman6> and you get them for free without any imports
16:01:41 <CADD> Axman6: yes, i wasnt denying that use case of string
16:01:41 <ReinH> chrisdone: and of course Inform 7's NLP codez are proprietary
16:01:46 <roboguy_> skypers: it's easy to use for small strings, too
16:01:51 <dleedev> Saizan: sure
16:01:57 <skypers> so all of you guys use OverridedStrings?
16:02:00 <CADD> Axman6: usually shouldnt would have been better
16:02:03 <dleedev> Saizan: I'm just writing out the minimum requirements
16:02:08 <ReinH> chrisdone: but looking at the old MUD2 stuff for instance it's surprisingly flexible
16:02:11 <dleedev> Saizan: the codomain has to contain at least the image
16:02:20 <c_wraith> skypers: sure, but you have to be careful with it.  It doesn't always do sane things
16:02:28 <c_wraith> skypers: also, it's OverloadedStrings
16:02:29 <CADD> Axman6: i still use string from time to time when im lazy and want things to type check ;)
16:03:01 <Saizan> dleedev: ok, but usually we think of the whole Hask as the codomain, so that e.g. composing such functors is well typed
16:03:09 <chrisdone> reinh: sounds fun =)
16:03:13 <jrmithdobbs> skypers: ya even on pure 2008/2010 code i'll turn just that on just not to annoy myself
16:03:19 <simpson> ReinH: Maybe I missed something, but isn't Inform 7 under the Artistic License?
16:03:20 <ReinH> chrisdone: it does :)
16:03:20 * chrisdone thinks writing games is infinitely more interesting than playing them
16:03:21 <dleedev> Saizan: ah, makes sense
16:03:39 <skypers> I see
16:03:44 <ReinH> simpson: inform 6 is open, I thought inform 7 wasn't
16:03:45 <dleedev> Saizan: btw, this is very interesting because for a whole I had the wrong notion of Functor
16:03:49 <monochrom> writing games is just playing a meta-game
16:03:53 <dleedev> Saizan: I thought it was a mapping between F a and F b
16:04:06 * monochrom churns out more tautologies!
16:04:11 <dleedev> Saizan: oops, f a and f b (didn't mean to capitalize F)
16:04:17 <simpson> ReinH: I know that it's in Debian repos and I've played with it on Gentoo and Debian boxes, so I'd be very surprised to learn that it's non-free.
16:04:27 <dleedev> Saizan: I wonder if that's a common misconception among newbies like me
16:04:38 <ReinH> simpson: Yeah, that would be surprising, but last thing I heard was that Inform7 is a proprietary front-end to Inform6
16:04:52 <ReinH> I could certainly be wrong
16:05:04 <roboguy_> c_wraith: like what? I haven't used it very much
16:05:05 <Saizan> dleedev: i haven't bumped into that misconception before, but i see how it might happen
16:06:11 <skypers> furthermore, what does “Subject to fusion.” mean?
16:06:20 <dleedev> Lethalman: it seems like you had this misconception too, right?
16:06:35 <jrmithdobbs> dleedev: I did too
16:06:40 <c_wraith> roboguy_: like.. there are libraries that abuse it by making strings an alternate representation of their non-stringy data type.  even without going that far, though..  the bytestring instance is partial, for instance. It crashes at runtime if you gave it invalid input.
16:06:43 <quchen> skypers: "There are rewrite rules to make this efficient when combined with other fusable functions"
16:06:44 <chrisdone> fusion is when you look at the composition of two functions and merge them into one
16:06:56 <dleedev> Saizan: does the word "fmap" appear in CT, or is it a Haskell thing?
16:07:04 <roboguy_> c_wraith: huh, that's really strange
16:07:05 <Saizan> dleedev: haskell thing
16:07:10 <chrisdone> map (+1) . map (*2) == map ((+1) . (*2))
16:07:31 <skypers> I see quchen
16:07:32 <dleedev> Saizan: what does the "f" in "fmap" stand for? "function"? "functor"?
16:07:33 <chrisdone> in Text there's some room for fusion too
16:07:44 <roboguy_> dleedev: probably Functor
16:07:47 <jrmithdobbs> functor pretty sure
16:07:54 <c_wraith> dleedev: Functor, to distinguish it from "map" which is for lists
16:08:01 <Saizan> dleedev: the notation in CT is to reuse the same name for both the object and the arrow mapper
16:09:02 <Saizan> dleedev: as the others said :)
16:09:47 <dleedev> Saizan: alrighty, thanks for the clarification
16:09:57 <jrmithdobbs> dleedev: i'd bet if we look at each other sideways we'll realize the misconception occurs more often people with less math (CT specifically) background
16:09:59 <dleedev> Saizan: very very helpful
16:10:20 <dleedev> jrmithdobbs: which is me
16:10:21 <Saizan> dleedev: np
16:10:25 <jrmithdobbs> dleedev: and me :)
16:11:12 <dleedev> jrmithdobbs: have you learned CT since?
16:11:34 <dleedev> jrmithdobbs: people keep telling me that CT is not useful for Haskell, but examples like this make me think otherwise
16:12:41 <jrmithdobbs> dleedev: not really, i understand some things trying to make lens not make my brain explode
16:13:10 <jrmithdobbs> dleedev: but they seem to be correct in that it's not necessary
16:13:25 <Saizan> well, Functor is specialized enough that you can understand it directly, the more general concept doesn't hurt anyone though :)
16:13:49 <jrmithdobbs> ya, not advocating naivity, just answering his question. :)
16:13:51 <jrmithdobbs> to be clear.
16:13:55 <dleedev> there's just enough similarities between arrows, functions, functors, morphisms, (basically any mapping) to let programmers have the wrong concept while still being able to use it
16:14:33 <dleedev> for example, if you has the wrong notion of Functor being a mapping between f a and f b, then you'll try to understand other concepts (such as monads) in that light
16:14:37 <dleedev> and that gets you into deep trouble
16:16:15 <adnap> Is there a way to make something like a chroot for System.Directory functions? Could I just run my program in a chroot? Is there another way that is cross-platform?
16:16:16 <roboguy_> dleedev: Functor isn't a mapping between f a and f b?
16:16:46 <adnap> I just want System.Directory functions to think "/" is some non-root directory on my filesystem.
16:16:59 <dleedev> roboguy_: we just discussed that, saying no
16:17:26 <dleedev> perhaps this is a far more common misconception than we think :)
16:18:08 <Saizan> roboguy_: a functor is made of two parts, the type constructor 'f' which maps types to types, and a function fmap :: (a -> b) -> f a -> f b which maps functions (a -> b) to functions (f a -> f b)
16:19:00 <dleedev> Saizan: the confusing part is "the type constructor 'f' which maps types to types"
16:19:39 <dleedev> Saizan: "types to types" is misunderstood to mean "f a to f b"
16:19:55 <dleedev> Saizan: whereas it should be understood to mean "a to f a"
16:20:18 <roboguy_> Saizan: right, so doesn't fmap give you a function that is a mapping from f a to f b when you give it a function from a to b?
16:21:10 <Saizan> roboguy_: if by "from f a to f b" you mean from values in f a to values in f b, yep
16:21:23 <roboguy_> Saizan: what else would I mean?
16:22:48 <dleedev> roboguy_: so when you asked "Functor isn't a mapping between f a and f b?", you probably should have asked "fmap x isn't a mapping between f a and f b?"
16:23:05 <Saizan> roboguy_: well, i guess there's not much else you could mean in haskell, but e.g. when dleedev says "f maps a to f a" he means that applying f to a you get f a, not that those are the domain and codomain, like you mean
16:23:15 <roboguy_> dleedev: yeah, that's true
16:24:35 <roboguy_> Saizan: well, I'm specifically talking about the Functor type class in Haskell
16:24:35 <dleedev> roboguy_: but the mapping that's going on with "fmap x" is not the same pair of mappings of a functor
16:24:45 <adnap> Nobody knows?
16:25:06 <Saizan> roboguy_: it's more a linguistic proble, both "(+1) maps Ints to Ints" and "(+1) maps n to its successor" are used in practice, we're getting confused about the two meanings here
16:25:15 <Saizan> *problem
16:25:24 <dleedev> roboguy_: fmap is the arrow mapping. fmap x an arrow in D.
16:26:43 <roboguy_> hmm alright. seems kind of like a small issue of semantics
16:27:41 <roboguy_> although, it would probably have been a little better at least if I said "isn't it a mapping between f a and f b given a function a -> b"
16:28:33 <roboguy_> adnap: would this work? http://hackage.haskell.org/package/Unixutils-1.44/docs/System-Unix-Chroot.html
16:28:43 <Saizan> roboguy_: also, "the functor" and "its fmap" aren't exactly the same thing
16:29:04 <adnap> roboguy_: No, I don't think so. I tried it and I think you have to run the program as root. Also, I'm not sure it's cross-platform
16:29:34 <roboguy_> Saizan: even if I'm talking about Functor in Haskell specifically?
16:29:42 <Saizan> roboguy_: yeah
16:29:59 <ReinH> the Functor, yes. ;)
16:30:30 <Saizan> roboguy_: the functor would be the pair of the type constructor and its fmap, but it's actually more common for "the functor" to refer to the type constructor if any of the two
16:30:54 <ReinH> Right, the functor maps arrows to arrows *and* objects to objects
16:30:56 <ReinH> fmap only does the former
16:31:24 <roboguy_> Saizan: hmm. that seems confusing since I usually think of type constructors as *having* functors rather than *being* functors. similar to how I think of types as *having* monoids
16:31:28 <dleedev> Saizan: btw, what do you understand "type constructor" to mean? I understood it to mean a type that constructs another type.
16:31:38 <ReinH> I think he means data constructor
16:31:44 <ReinH> i.e. Just, not Maybe
16:32:10 <ReinH> wait no
16:32:12 <ReinH> objects in Hask are types
16:32:15 <ReinH> so type constructors it is
16:32:52 <dleedev> ReinH: there was a whole discussion earlier though, that type constructors do not mean "types that construct other types"
16:32:59 <Saizan> roboguy_: if it works for you it's fine, but the convention is not that for monoids (or other algebraic structures) either
16:33:27 <Saizan> dleedev: i used it loosely here
16:33:42 <Saizan> dleedev: just to mean a type with kind * -> *
16:33:45 <roboguy_> Saizan: it makes more sense to me (in the context of haskell at least) because there are lots of types that have lots of potential Monoid instances (for example)
16:34:05 <roboguy_> so I would say they *have* several monoids
16:34:11 <dleedev> ReinH: hpc can chime in on that
16:34:38 <Saizan> roboguy_: yeah, that's why the correct thing is to say that (Int,0,(+)) is a monoid rather than Int is a monoid
16:34:43 <roboguy_> in a more general sense, you could refer to the monoid of integers under + I guess, but I generally think specifically in terms of haskell
16:34:51 <roboguy_> (and 0)
16:35:07 <dleedev> roboguy_: so you'd say that Sum *is* a Monoid instance, whereas Int *has* an Monoid instance, right?
16:35:20 <Saizan> roboguy_: but in contexts where the unit and the operation are clear from context the monoid is identified with the set
16:35:21 <ReinH> Well, Int doesn't.
16:35:25 <roboguy_> dleedev: not really, since Sum is just a name
16:35:40 <dleedev> roboguy_: so you'd say Sum *has* a Monoid instance?
16:35:42 <ReinH> Monoid has an instance named Sum
16:35:47 <roboguy_> dleedev: yeah
16:35:53 <Saizan> roboguy_: and yeah we do say 'F' has a Functor instance, but that's another thing entirely
16:36:11 <roboguy_> dleedev: it would be confusing to make it anything other than what it is in this case because of the name, but you could (correctly) make it different
16:36:36 <roboguy_> Saizan: hmm ok
16:36:40 <ReinH> Right, a type can have more than one valid Monoid instance
16:36:46 <ReinH> but only one (or zero) valid Functor instance
16:36:50 <roboguy_> ReinH: yep
16:36:56 <roboguy_> (in haskell)
16:37:15 <dleedev> ReinH: really? I don't think so...
16:37:28 <ReinH> dleedev: yes, really, it's a free theorem from the functor laws
16:38:12 <JakeE> is it possible to only export an instance from a module?
16:38:19 <dleedev> ReinH: but in the way you're using "have a constraint instance"... you can only have one
16:38:21 <roboguy_> dleedev: it's true
16:38:36 <ReinH> dleedev: any other instance would be equivalent
16:38:42 <ReinH> dleedev: http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
16:38:43 <roboguy_> I didn't believe it the first time I heard it either actually
16:38:57 <ReinH> if you have some function foo that obeys the functor laws it is equivalent to fmap
16:39:03 <Saizan> i think dleedev is objecting to the Monoid claim
16:39:06 <ReinH> ahh
16:39:22 <ReinH> well, what I should say is: a typed *could* have more than one valid Monoid instance
16:40:01 <Saizan> dleedev: what ReinH meant is that potentially there are different ways to make a Monoid instance for the same type, not that haskell actually allows them coexist
16:40:06 <ReinH> YEs.
16:40:15 * ReinH looks at his shift key
16:40:37 <dleedev> ReinH: but the way they're using "a type has a Monoid instance" does not mean "a Monoid instance for the type"
16:40:42 <dleedev> Saizan: ^
16:40:46 <ReinH> Ok :)
16:40:49 <ReinH> words are harder than math
16:41:14 <dleedev> a Monoid instance for Int is Sum. another one is Prod.
16:41:38 * Saizan doesn't follow
16:41:39 <dleedev> however, borrowing ReinH and roboguy_'s lingo, Sum has a Monoid instance
16:41:57 <Saizan> i'd say that Int has no Monoid instances :)
16:42:05 <Saizan> but fair enough
16:43:14 <dleedev> roboguy_: does Int have a Monoid instance, or does Sum have a Monoid instance?
16:43:35 <roboguy_> dleedev: Sum does, Int doesn't. both have many potential instances
16:43:56 <ReinH> See this is why I hate words.
16:44:02 <benmachine> pedantically, isn't it Sum Int that has a monoid instance?
16:44:06 <roboguy_> ReinH: yeah...
16:44:15 * benmachine ♥ words
16:44:23 <roboguy_> benmachine: well, Num a => (Sum a)
16:44:24 <ReinH> benmachine: pedantically, I believe it's Num a => Sum a
16:44:38 <benmachine> yes, of which Sum Int is a specialisation
16:44:39 <roboguy_> if we're being pedantic
16:44:44 <ReinH> which we are
16:44:47 <dleedev> :)
16:44:50 <ReinH> always
16:46:13 <tam1138> hello
16:46:46 <dleedev> roboguy_: can Sum Int have potentially many Monoid instances?
16:46:54 <roboguy_> dleedev: yeah
16:47:10 <roboguy_> dleedev: some of them might be counterintuitive though, give the name
16:48:03 <dleedev> roboguy_: hmm... this is getting confusing
16:48:04 <ReinH> dleedev: sure, one is <Sum Int, 1, (*)> ;)
16:48:12 <ReinH> It's not a particularly good sum monoid
16:48:13 <c_wraith> nearly all of them would be counterintuitive, given the name
16:48:14 <ReinH> but it is a monoid
16:48:21 <roboguy_> c_wraith: pretty much all but one
16:48:27 <ReinH> pretty much
16:48:44 <tam1138> sorry if this is a dumb question, but how can i find the definition of, eg, the functor instance for the tuple type?
16:49:06 <c_wraith> tam1138: :info in ghci
16:49:11 <roboguy_> tam1138: in ghci, if you type ": (,)" it will list where the instances for (,) are defined
16:49:43 <c_wraith> roboguy_: you forgot an important letter
16:49:51 <roboguy_> c_wraith: oh, oops. :i
16:49:52 <tam1138> okay, that tells me GHC.Base.  how do i find the code that implements that?
16:50:00 <roboguy_> c_wraith: actually : works too... weird
16:50:01 <dleedev> roboguy_: when you read "instance Monoid m", you read "add an instance of Monoid to m" instead of "m is an instance of Monoid"?
16:50:13 <c_wraith> tam1138: that particular module is probably documented on hackage.
16:50:33 <c_wraith> oh, not anymore it isn't
16:50:44 <c_wraith> well, then.  Find the ghc source and dig it up
16:50:46 <tam1138> i'm also interested in the general case =)
16:50:49 <tam1138> ah, okay
16:50:57 <roboguy_> dleedev: the second one. I read it as a selection of a specific Monoid instance
16:51:00 <tam1138> thanks
16:51:00 <c_wraith> tam1138: checking hackage *is* the general case
16:51:02 <levi> You can always browse it on github if you don't want to download it.
16:51:17 <c_wraith> tam1138: the fact that that module isn't documented on hackage is odd
16:51:34 <dleedev> roboguy_: you're selecting the specific Monoid instance called m?
16:51:50 <roboguy_> dleedev: no, I'm selecting the monoid instance with the definition that follows
16:52:08 <roboguy_> dleedev: and I'm making that the "canonical" monoid instance for the type
16:52:29 <ReinH> Well, there is only one valid Functor instance for a given n-tuple type, so just ask Djinn what it is ;)
16:52:36 <tam1138> (this came about because i was surprised fmap on tuples only applied the function to snd)
16:52:55 <c_wraith> tam1138: that's the only thing fmap *can* do on tuples
16:52:58 <mercuryrising> im having some trouble with shelly still, if i have something that's an "sh filepath", how do I convert that to just "filepath" so i can run the command?
16:53:06 <jrmithdobbs> tam1138: how could fmap do anything else?
16:53:08 <c_wraith> tam1138: the kinds matter.
16:53:21 <ReinH> @djinn (a -> b) -> (r, a) -> (r,b)
16:53:21 <lambdabot> f a (b, c) = (b, a c)
16:53:32 <tam1138> hmmm
16:53:43 <tam1138> i don't think well in haskell yet, gimme a sec =)
16:53:49 <jrmithdobbs> tam1138: you're looking for Bifunctor and bimap
16:54:01 <c_wraith> tam1138: in particular..  class Functor f where fmap :: (a -> b) -> (f a -> f b)
16:54:06 <roboguy_> tam1138: it might help if we change some names: fmap f (a, b) = (a, f b)
16:54:23 <benmachine> oh, that's an unfortunate choice of name
16:54:29 <c_wraith> tam1138: the important thing to notice there is that whatever the functor is, it must take one type argument
16:54:41 <c_wraith> tam1138: but (,) takes two type arguments
16:54:43 <benmachine> well, the a's and b's in the type sig don't at all correspond to the a's and b's in the definition
16:54:43 <tam1138> ahhhhh!
16:54:45 <tam1138> gotcha
16:54:52 <c_wraith> tam1138: so the functor instance must be on ((,) a)
16:54:57 <tam1138> i see now!
16:55:00 <jrmithdobbs> tam1138: and you can come at it from the other angle
16:55:01 <tam1138> thank you
16:55:04 <ReinH> And likewise for ((,,) a b)
16:55:19 <jrmithdobbs> tam1138: how could a function take a single argument that is one of two types?
16:55:24 <jrmithdobbs> (it can't)
16:55:26 <benmachine> tuples aren't a functor, but pair-with-x is a functor
16:55:28 <tam1138> right
16:55:48 <tam1138> i love that there are a bazillion different ways of approaching my confusion
16:55:53 <tam1138> thanks everybody
16:56:03 <c_wraith> you're welcome.  glad I could contribute something useful.
16:56:13 <tam1138> got another one for ya
16:56:39 <tam1138> even though it's easy to implement myself, why is something like "isLeft" not in Data.Either?  (where isJust *is* in Data.Maybe)
16:57:16 <jrmithdobbs> because unthoughtful usage of that can cause unexpected pattern matching exceptions?
16:57:22 <c_wraith> Usually it turns out to be better to structure your logic in a better way
16:57:44 <c_wraith> It's rare to want something like isLeft without wanting to find out what's inside it, too
16:57:45 <roboguy_> c_wraith: that's almost always true!
16:57:58 <c_wraith> roboguy_: hm.  unfortunate phrasing, on my part
16:58:00 <monochrom> demand and supply
16:58:05 <tam1138> makes sense
16:58:05 <jrmithdobbs> tam1138: also, there is 'lefts' which typically makes more sense
16:58:10 <tam1138> because i ended up using lefts
16:58:12 <tam1138> hah
16:58:12 <tam1138> yep!
16:58:53 <roboguy_> it seems like they should have something like mapLeft and mapRight in Data.Either, but I do have lens for that
16:58:55 <tam1138> okay, next question =D
16:59:06 <tam1138> are these questions more appropriate for beginners@ or haskell-cafe@ ?
16:59:14 <tam1138> (trying to get a feeling for which to join)
16:59:35 <monochrom> I bet beginners@
16:59:42 <c_wraith> probably beginners.  -cafe is *usually* slightly more advanced stuff
16:59:52 <benmachine> tam1138: why isJust and not isLeft is a good question, there isn't really a good reason for the difference between them
16:59:58 <tam1138> cool, thanks
17:00:04 <benmachine> I don't think I would miss isJust if it went away
17:00:18 <benmachine> well, maybe a little
17:00:49 <hpc> a lot of people who use old packages would surely mind
17:00:53 <monochrom> you can, in fact, ask "why doesn't Data.Either have isLeft" in haskell-cafe. but the semantics is different. its semantics is a debate in haskell-cafe
17:00:54 <benmachine> maybe it's just because Maybe is more common than Either, so it's worth more to get a little extra convenience there
17:01:12 <monochrom> whereas the same question has beginner semantics in beginners
17:01:24 <tam1138> monochrom: makes sense
17:01:27 <monochrom> let this be a lesson that syntax does not determine semantics
17:01:29 <c_wraith> I think the evolution is different..  Nothing contains exactly the same information as False
17:01:38 <c_wraith> So isNothing isn't an information-losing operation
17:01:52 <c_wraith> But once you add isNothing, you feel compelled to add isJust
17:02:10 <c_wraith> With Either, there's no initial foot in the door.
17:02:57 <hpc> i expect it's going to be more of a history kind of thing
17:03:13 <roboguy_> tam1138: are you on stackoverflow? that's another good place to ask questions
17:03:15 <hpc> someone wrote it in, nobody took it out, and after a while it stayed in so long it started to belong
17:03:28 <tam1138> i search stackoverflow, but i don't have an account
17:03:37 <monochrom> left foot first or right foot first? :)
17:03:42 <tam1138> maybe either
17:03:59 <c_wraith> that might be the worst (best) pun here ever
17:04:13 <tam1138> =D
17:04:22 * monochrom likes puns
17:04:56 <levi> I sometimes use isNothing/fromJust when it turns out to be more succinct than pattern matching, but I don't think isLeft would be very helpful for that.
17:05:09 <c_wraith> puns have an unsigned quality axis.  Good puns and bad puns are the same thing.  It's only a question of "how far is it from boring?"
17:05:31 <monochrom> usually "maybe" is most succint
17:05:31 <tam1138> levi: yeah, just like jrmithdobbs pointed out, i ended up using `lefts' anyway
17:05:39 <benmachine> perhaps c_wraith is right, and isJust is only sensible because it's not . isNothing
17:05:46 <monochrom> or "fromMaybe"
17:05:55 <benmachine> whereas with Either, whichever one you want there's some information inside as well
17:06:01 <jrmithdobbs> tam1138: lens makes working with n-tuples easier by quite a bit, btw
17:06:23 <jrmithdobbs> tam1138: if you're going to do a lot of it
17:06:41 <tam1138> jrmithdobbs: cool.  i have seen lenses mentioned quite a bit but haven't yet investigated.
17:06:45 <jrmithdobbs> as well as either
17:08:34 <roboguy_> tam1138: I thought this was a pretty good introduction to lenses, if you're interested https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
17:08:40 <benmachine> lenses are kind of intimidating and I'm not sure I'd introduce inexperienced people to them
17:08:40 <levi> monochrom: I am not sure what I did was the best example of style, but it seemed to be a reasonable way of writing it at the time even though I wasn't incredibly happy about it.
17:08:55 <jrmithdobbs> tam1138: i'd suggest looking sooner rather than later, it's going to warp you mind and then save you weeks of work
17:09:46 <tam1138> jrmithdobbs: that sounds like my experience with haskell in general ;)
17:09:55 <tam1138> roboguy_: thanks!
17:10:12 <jrmithdobbs> benmachine: ya well, i think yesod is a good way to teach people about monads too, so what do I know, ha
17:10:17 <benmachine> :P
17:10:31 <benmachine> in fairness I don't really know any better than anyone else ever
17:10:38 <levi> I think the basic idea of lenses is pretty easy to grasp, it's just the vast and intricate superstructure that hooks the basic idea into all the nooks and crannies of the type system that gets really mind-boggling. :P
17:10:57 <tam1138> levi: again, that sounds like my experience with haskell in general =p
17:11:15 <ReinH> tam1138: pretty much.
17:13:08 <jrmithdobbs> levi: I think it depends. If you're familiar with map/fold/something like Traverseable/lambdas/real functions/etc constructs in other languages lens seems a natural extension of the type system ... if you're not then you're in for a really wild ride
17:13:26 <jrmithdobbs> levi: introducing lens to someone knew to haskell and to functional-ish programming at the same time? ya, probably a bad idea.
17:13:31 <jrmithdobbs> s/knew/new/
17:14:21 <tam1138> i've been playing around with haskell for years, i've just never gotten very deep into it
17:15:12 <roboguy_> tam1138: lens is definitely a way to get deep into it, hah
17:15:19 <jrmithdobbs> also, ruby needs rename inject foldr for christ's sake
17:15:20 <jrmithdobbs> ;p
17:15:52 <levi> Talk of lens reminds me of this: http://cokmett.github.io/cokmett/
17:16:03 <roboguy_> jrmithdobbs: well, foldl
17:16:46 <levi> (clicking on the image starts an animation, if you haven't seen it before)
17:16:49 <jrmithdobbs> roboguy_: err ya, i type on dvorak it's past go-home-o-clock
17:19:01 <roboguy_> tam1138: although it's worth pointing out that you shouldn't try to understand *how* lenses work. not at first anyway, you can figure that out after you learn how to *use* them
17:19:30 <tam1138> certainly
17:19:36 <jonasw> A bit off-topic, but other Haskellers interested in audio DSP might enjoy http://en.wikipedia.org/wiki/FAUST_(programming_language)
17:20:56 <roboguy_> a much more memorable name...
17:24:54 <Eduard_Munteanu> Doh!
17:25:33 <Eduard_Munteanu> I was wondering why something recursing over a directory blew the stack and eated a lot of memory.
17:25:52 <Eduard_Munteanu> . and .. are part of getDirectoryContents' output :)
17:27:41 <Iceland_jack> Eduard_Munteanu: Heh :) been there, sadly
17:28:46 * hackagebot purescript 0.2.11 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.11 (PhilFreeman)
17:31:48 <Eduard_Munteanu> BTW, are there replacements for System.* that use Text or some other reasonable thing for FilePath?
17:32:23 <Eduard_Munteanu> Unless GHC manages to fuse the Strings if I unpack a Text.
17:37:28 <geekosaur> there is a POSIX ByteString API; I don;t know if Windows has a Text equivalent
17:38:03 <Eduard_Munteanu> Text wouldn't really make sense, yeah, since UTF-16 is quite restricting.
17:38:22 <geekosaur> but it is actually correct for Win32
17:38:42 <Eduard_Munteanu> Maybe, but it's incorrect wrt the general case. :)
17:38:57 <Eduard_Munteanu> (arguably the same would go for UTF-8)
17:39:23 <monochrom> well, the library could take Text from your side, and always translate that to UTF-16 on the Windows side. you need not touch UTF-16 directly
17:39:25 <Eduard_Munteanu> geekosaur: anyway, what package is that?
17:39:53 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-ByteString-FilePath.html
17:40:32 <Eduard_Munteanu> monochrom: if you supply literal directory names perhaps... but if you get them from the filesystem itself then I think any variation on Text would be "wrong" to some extent
17:40:47 <Eduard_Munteanu> Oh, thanks.
17:41:05 <Eduard_Munteanu> I must've missed that.
17:41:33 <geekosaur> (also see the "parent" System.Posix.ByteString)
17:42:01 * Eduard_Munteanu bows to LordAgda
17:48:25 * Eduard_Munteanu scratches head... there doesn't seem to be something like getDirectoryContents and readDirStream's type is confusing...
17:49:05 <Eduard_Munteanu> I suspect a null bytestring means there are no more entries.
17:50:11 <geekosaur> that's what the source says, yes
17:50:26 <geekosaur> an empty file name is illegal per POSIX so it does make some sense... but I would have used a Maybe
17:51:06 <Eduard_Munteanu> It is illegal? I suppose so, only the "no \0" rule came to mind.
17:51:14 <geekosaur> explicitly, yes
17:51:47 <geekosaur> you can still occasionally find programs that use "" to mean ".", which worked on ancient UNIX but is illegal per POSIX
17:52:45 <geekosaur> and it is impossible to have an empty file name (which leads to oddnesses like foo/ being a way to specify that foo must be a directory. it gets weird sometimes)
17:53:23 <Eduard_Munteanu> That oddness is common notation though.
17:53:25 <geekosaur> x//y is the same as x/y, instead of being illegal or nonexistent
17:53:44 <geekosaur> that common notation is why POSIX is somewhat inconsistent on this
17:53:47 <Eduard_Munteanu> A few unixy utilities treat foo vs foo/ differently
17:56:50 <monochrom> eg rsync
17:57:24 <Eduard_Munteanu> Yeah, that's what I was thinking of, actually.
17:58:46 <geekosaur> that's actually an rsync special; I don't think rdist had it
18:13:19 <randomclown> is Data.Hashtable threadsafe?
18:14:44 <monochrom> no
18:16:35 <joelteon> wat
18:17:08 <monochrom> watson
18:17:18 <monochrom> it's elementary
18:18:07 <Iceland_jack> @let isElementary = const True
18:18:09 <lambdabot>  Defined.
18:18:46 <monochrom> @type const (const True)
18:18:47 <lambdabot> b -> b1 -> Bool
18:28:58 * hackagebot higher-leveldb 0.1.0.2 - A rich monadic API for working with leveldb databases.  http://hackage.haskell.org/package/higher-leveldb-0.1.0.2 (jeremyjh)
18:39:57 <Morpheus> greetings fellow haskellers
18:40:19 <Morpheus> does anyone here know of simple addressbook application to learn from
18:42:18 <tertl3> Morpheus, https://gist.github.com/svdberg/765047
18:43:39 <Morpheus> just looking at it now, thanks.
18:43:47 <tertl3> i was gonna say start with a data thingy :\
18:44:01 <Morpheus> a lambda?
18:44:17 <brokenzebra> pythonic syntax makes my toy language look like a toy
18:44:18 <tertl3> no the data Contact =  Contact
18:44:37 <tertl3> data constructor maybe
18:44:48 <brokenzebra> i can't seem to avoid the use of enterprise-ready curly braces
18:44:57 <tertl3> lol
18:45:15 <Morpheus> @tert13 - thanks, I a raw beginner be.
18:45:15 <lambdabot> Unknown command, try @list
18:45:22 <tertl3> did you work a lot in industry?
18:46:01 <Morpheus> I have done a lot of c, cobol and asm programming, trying to learn fp to keep my ancient brain working.
18:46:37 <randomclown> How different is the Data.HashTable in base and the the one in hashtables?
18:46:41 <tertl3> yeah its fun, idont do much programming really but I like to read about it
18:47:31 <Morpheus> I am severely restricted in what I can do in a physical sense, but need to do something other than reading and watching tv
18:48:08 <tertl3> Morpheus, https://code.google.com/p/protobuf-haskell/wiki/Basics
18:48:26 <tertl3> idk what protocal buffer is ;P
18:48:39 <Morpheus> I have done a password generator in c++ using boost libraries for a tool to use recently. Also been doing doxygen work for another project.
18:49:06 <tertl3> what is doxygen?
18:49:15 <randomclown> tertl3: documentation generator for c++
18:49:22 <tertl3> oh ok
18:49:25 <Eduard_Munteanu> @google what is doxygen?
18:49:25 <lambdabot> No Result Found.
18:49:32 <Eduard_Munteanu> Hm, fair enough. :P
18:49:35 <tertl3> im interested in NLP lately
18:49:58 <tertl3> lambdabots on my side lol
18:49:59 <Eduard_Munteanu> tertl3: I hope that's not the crackpottery NLP :)
18:50:39 <tertl3> what do you mean Eduard_Munteanu ?
18:50:58 <Eduard_Munteanu> tertl3: Neuro-Linguistic Programming
18:51:09 <tertl3> no
18:51:17 <Eduard_Munteanu> I know. :)
18:51:24 <tertl3> natural language processing
18:51:42 <tertl3> :P
18:52:24 <tertl3> computerse are bad at NLP
18:52:36 <confuse> can we have a little off topic discussion? its related to math anyway.. and its the most counter intuitive thing i ever learned.. and its making me angry.. :D
18:52:41 <Eduard_Munteanu> Humans aren't great either, TBH.
18:53:00 <confuse> why is the sum of all natural numbers -1/12
18:53:03 <Morpheus> NLP is a very powerful tool to master,
18:53:15 <Eduard_Munteanu> confuse: it isn't, that's wrong
18:53:24 <confuse> apparantly.. 1 + 2 + 3 + 4 + 5 + ... inf = -1/12
18:53:25 <scott_> confuse: Some of my classmates were talking about a proof that claimed that today... I saw an obvious problem or two in it
18:53:40 <scott_> It's not true
18:53:40 <confuse> so string theory is major bull shit?
18:53:40 <Morpheus> And is much used by sales teams and other marketers to get to buy more stuff.
18:53:41 <confuse> lol
18:54:10 <tertl3> lol wut
18:54:12 <jle`> confuse: hmmm probably off topic.
18:54:17 <Eduard_Munteanu> confuse: probably a proof that manipulates ordering of summation incorrectly
18:54:27 <jle`> if you are insistent on querying the haskell community then you might be interested in #haskell-blah
18:54:28 <hpc> Eduard_Munteanu: it's easy
18:54:47 <Morpheus> Doxygen is a system for documenting c, c++ and other code by tags included in the source code. Not used by Haskell.
18:54:48 <jle`> yes i am a party pooper.
18:54:52 <hpc> ... = - (5 + 4 + 3 + 2 + 1 + 1/12 + inf)
18:55:04 <confuse> I'm not an expert mathematician or anything.. but in one of the proofs.. they are subtracting an element from one inf series for every two elements from another..
18:55:05 <Eduard_Munteanu> Heh, indeed.
18:55:19 <tertl3> iva also been doing jekor haskell from scratch
18:55:25 <Eduard_Munteanu> confuse: you might want to look up absolute convergence
18:55:28 <confuse> oh sorry..
18:55:49 <confuse> i didnt have anywhere to go..
19:00:21 <confuse> im gonna email terence tao lol..
19:00:47 <Morpheus> @help
19:00:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:00:57 <Morpheus> @hep list
19:00:58 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
19:01:03 <Morpheus> @help list
19:01:03 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
19:01:12 <Eduard_Munteanu> @list
19:01:12 <lambdabot> What module?  Try @listmodules for some ideas.
19:01:24 <Eduard_Munteanu> Morpheus: you can query lambdabot privately
19:01:46 <Morpheus> I need training  to to that
19:01:55 <Eduard_Munteanu> Morpheus: /query lambdabot
19:01:55 <Morpheus> please explain
19:02:33 <Morpheus> thanks
19:02:55 <Eduard_Munteanu> Morpheus: despite the name "query" it just sends messages privately
19:04:01 <Eduard_Munteanu> (that is, it works with anyone not just lambdabot, but it's common courtesy to avoid private messages)
19:07:03 <Morpheus> so I can use /query [nickname] ? for private message?
19:07:26 <Morpheus> I have only started using xchat
19:07:29 <Eduard_Munteanu> Morpheus: yes, but generally you should talk to people in the channel
19:07:50 <Eduard_Munteanu> It's not xchat-specific, rather an IRC thing.
19:08:35 <Morpheus> Eduar_Munteanu: I meant IRC, and accessing via xchat of my Debian system
19:08:49 <Fuuzetsu> How can I have GHC-compiler specific cabal settings? Say, I want to build profiling libs when using one version of the compiler but don't want to when using another.
19:09:16 <Eduard_Munteanu> Fuuzetsu: er, why would you?
19:09:53 <Fuuzetsu> Eduard_Munteanu: because I want to have profiled libs for one version but not for every other version
19:09:53 <Morpheus> Why would you have 2 versions of the compiler?
19:10:06 <Eduard_Munteanu> Profiling or not sounds like a system / user option, not a package option.
19:10:20 <Fuuzetsu> Morpheus: Why wouldn't you? If you ever dabble in GHC or want **bleeding-edge** features, you'll end up with multiple pretty soon
19:10:32 <Eduard_Munteanu> Oh, I think I misread.
19:10:42 <Fuuzetsu> Eduard_Munteanu: To profile, you need to build all used libs with profiling
19:11:13 <Morpheus> Fuuzetsu: I understand, but at present I am still trying to get some simple things to work
19:11:27 <Iceland_jack> Morpheus: What things?
19:11:32 <Eduard_Munteanu> Fuuzetsu: yeah, I thought you were asking how to do build that into your own package... I don't know how though, but in case you're running Gentoo and using the ebuilds, there are profile USE flags
19:12:00 <Morpheus> I was working on an IRC bot in one of the tutorials, but can not get it to work.
19:12:15 <Fuuzetsu> Eduard_Munteanu: I'm not using portage for Haskell, it does not like multiple GHC versions on a system. At the moment I'll just swap the Cabal config file when switching to a profiled compiler I think.
19:12:51 <Morpheus> The simple versions yes, but the last one I could not - it seems as if the tutorial was using depreciated features of Haskell.
19:13:36 <Fuuzetsu> Morpheus: Perhaps you should post what the code and the error was on lpaste.
19:13:40 <Iceland_jack> Morpheus: You can paste the error messages you get
19:13:40 <Iceland_jack> @where lpaste
19:13:40 <lambdabot> http://lpaste.net/new/haskell
19:14:03 * hackagebot bindings-mpdecimal 0.2.0.0 - bindings to mpdecimal library  http://hackage.haskell.org/package/bindings-mpdecimal-0.2.0.0 (OmariNorman)
19:14:20 <Morpheus> I am just finding the tutorial ...
19:14:54 <Fuuzetsu> Morpheus: was it http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
19:15:04 <Morpheus> yes
19:15:24 <bb010g> I think that needs updating with Exceptions, IIRC.
19:15:35 <Morpheus> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source - this is the one giving the problems.
19:15:46 <Iceland_jack> Probably exceptions yes
19:16:07 <Morpheus> So I have left it alone for a while to get better Haskell knowledge
19:16:25 <Iceland_jack> Morpheus: In that case I recommend Learn You a Haskell
19:16:25 <Iceland_jack> @where lyah
19:16:25 <lambdabot> http://www.learnyouahaskell.com/
19:16:38 <Morpheus> and then come back to it. My purpose to learn Haskell to write interface to control a RetroShare chatbot
19:17:08 <Morpheus> That is the one I am now working through, and have ordered Real World Haskell, as I like reading from book
19:17:26 <Eduard_Munteanu> Morpheus: you might want to try poking at more functional stuff first
19:18:11 <Morpheus> Eduard_Munteanu: I be having lots of fun - and headaches.
19:18:30 <Morpheus> finding it hard to change thinking patterns from asm, c, c++ etc
19:18:40 <Morpheus> brain is mostly ossified
19:18:42 <Iceland_jack> And ask questions at #haskell, this is a good environment to learn
19:18:48 <Eduard_Munteanu> Things that are IO-centric tend to require some background, at least to be elegant.
19:19:03 <Iceland_jack> Morpheus: Is there any particular concept you're stuck on?
19:19:42 <Morpheus> Elegance comes with knowledge and practice. Not stuck, just have trouble remembering concepts and converting from old way of thinking into the fp paradigm.
19:19:52 <Iceland_jack> Understood
19:19:59 <Morpheus> Bit like learning new spoken language.
19:20:08 <Iceland_jack> Yes that's a good analogy
19:20:35 <Morpheus> Know basics, and can do/say simple things, but get stuck with more complex things or fast speakers!
19:21:24 <Morpheus> I keep working and I will master, and keep coming here to get answers. I think one idea, was to write simple program in one language, then write in the language you are learning.
19:22:26 <Morpheus> Thanks everyone for assistance, I be going back to editor now. If someone wants to update that irc chat bot at some stage, I am sure many people would appreciate that.
19:24:28 <stevejb> Hello, I have a quick data structure question. I apolgize for the wall of text, but here goes.
19:24:35 <stevejb> I am trying to keep track of a quantity (or object) which is indexed by a few attributes. For simplicity, say I am interested in "est score" which have  attributes height and weight, where both height and weight can take on a small (~200) set of discrete values. I am interested in queries such as "given height = 2.3, what is the weight of the person with the maximum test score?" and things like that. I would typically use a matrix for
19:24:35 <stevejb> this, and my code currently uses repa for this. Meaning, I have a MxN table (height x weight), plus a M-vector and an N-vector. However, there is a bit of code which was calculating indices and the thing doesn't feel like I am doing things in a Haskell-like manner. What is a better data structure that I can use?
19:25:23 <stevejb> I suppose the easiest thing to do would be to create my own data type and simply use filters. Is there anything better?
19:26:11 <Eduard_Munteanu> stevejb: you can use a Map
19:26:45 <rasfar> sounds like you might want a database library
19:26:51 <stevejb> Eduard_Munteanu: would my key then be (height_i, weight_j) ?
19:27:23 <Eduard_Munteanu> stevejb: yes... assuming you want to query by height and weight
19:27:28 <stevejb> rasfar: I was thinking that it sounded like some kind of in-memory database, but I was worried that it would be overkill. This is just for simulation that will last a few minutes, and I really don't need the data structure to persist any longer than that.
19:27:43 <stevejb> but, can I use a map to say (height_i, _)
19:27:49 <stevejb> and get all weights for a given height?
19:27:57 <Eduard_Munteanu> stevejb: yes, given the usual ordering of pairs
19:28:21 <Eduard_Munteanu> :t M.lookupGE
19:28:21 <lambdabot> Ord k => k -> M.Map k v -> Maybe (k, v)
19:29:07 <Eduard_Munteanu> :t M.partition
19:29:08 <lambdabot> (a -> Bool) -> M.Map k a -> (M.Map k a, M.Map k a)
19:29:13 <Eduard_Munteanu> Er.
19:29:51 <Eduard_Munteanu> :t M.split
19:29:52 <lambdabot> Ord k => k -> M.Map k a -> (M.Map k a, M.Map k a)
19:30:37 <Eduard_Munteanu> stevejb: that gives you keys smaller, respectively larger than the argument. You can build your query for a particular height alone around that.
19:31:35 <stevejb> Eduard_Munteanu: That seems like that would work. I will need to experiment a bit but it seems reasonable. And this will scale to N sets of attributes, as long as each set is ordered
19:31:36 <stevejb> ?
19:32:50 <Eduard_Munteanu> stevejb: it should work for any number of attributes if said number is fixed and you query them in a particular order (e.g. height alone, then length, then weight, but not the other way around)
19:33:23 <stevejb> great. Thank you. I will play with that for a bit.
19:33:41 <carter> stevejb: oh hey!
19:33:57 <stevejb> carter: hey! long time no chat
19:36:03 <carter> stevejb: theres room for better analyitcal db style libs for haskell
19:36:23 <stevejb> carter: some kind of in-memory sqlite kind of thing?
19:36:29 <carter> yeah
19:36:41 <flebron> I dream of a day when values will not be judged by their type, but by the class of morphisms pointing to them. - Martin Luther Yoneda-King
19:37:23 <Eduard_Munteanu> stevejb: the complexity should be something like O(log n_1 + ... + log n_k) where k is the number of attributes and n_k the number of values for the kth attribute.
19:37:54 <carter> stevejb: theres edwardk's weekend hack lib, tables
19:38:32 <Eduard_Munteanu> Actually that's larger, since each refinement gives you a smaller set.
19:38:45 <Eduard_Munteanu> s/larger/an upper bound/
19:38:48 <stevejb> Eduard_Munteanu: that seems extremely reasonable for what I am doing
19:45:44 <Eduard_Munteanu> Meh, I'm probably lying... it's more like O(log n + log (n / n_1) + ... + log [n / (n_1 * ... * n_{k-1})])
19:46:30 <Eduard_Munteanu> (with n the total number of entries)
19:47:11 * Eduard_Munteanu needs sleep
19:47:14 <carter> do it
19:48:06 <Eduard_Munteanu> Sleep isn't something you do... it's a... state of mind! :P
19:54:38 <rasfar> Since it's quiet: In case anyone was puzzled by my heap profiling questions last night, the issue turned out to be options my build scripts were feeding GHC
19:54:50 <carter> cool
19:55:04 <rasfar> Or rather ... the RTS options
19:55:33 <rasfar> thought it was -hd but it was really -hT and, yeah both compile and runtime actually, it was a non-prof build as well
19:56:25 <rasfar> gotta love -hT (not needed -prof in compilation); but the -hd output is a lot easier to map to source locations!
19:57:16 <rasfar> and -hy gives you types, nice clean labels in the hp2ps plot, nice -- okay, end of update.
20:03:09 <hdevalence> is there a way to find where a function is defined from ghci?
20:03:24 <geekosaur> :info often shows it
20:08:11 <joelteon> I think it always does
20:08:46 <hdevalence> yes, it does
20:08:50 <hdevalence> one other thing
20:08:53 <hdevalence> well two
20:09:10 * hackagebot pure-io 0.1.0 - Pure IO monad.  http://hackage.haskell.org/package/pure-io-0.1.0 (ChrisDone)
20:09:26 <hdevalence> I was going to use Data.List.Split.splitEvery, but it gave a warning telling me to use chunksOf, defined in Split.Internals
20:09:48 <hdevalence> is there an issue with using stuff from Data.List.Split.Internals? (I assume not?)
20:10:34 <Ankhers> OSX 10.9, new install of Haskell Platform. when I use `ghc-pkg check` it tells me that there are a lot of broken packages. Any ideas how to fix this?
20:10:57 <geekosaur> ideally you don't, but ideally it would not say where the real definition is but where the public export version is
20:11:22 <geekosaur> in particular the public export of chunksOf is in Data.List.Split
20:11:34 <joelteon> what if it's exported from multiple places
20:12:09 <hdevalence> geekosaur: oh, I see. I didn't see it in the documentation page, so I assumed it wasn't defined there
20:14:10 * hackagebot pure-io 0.1.1 - Pure IO monad.  http://hackage.haskell.org/package/pure-io-0.1.1 (ChrisDone)
20:22:06 <jeronimo> how to check whether I am in ghci or not?  I thought `fmap (=="<interactive>") getProgName' but I am not sure how portable this is.
20:28:21 <c_wraith> jeronimo: why would you want to do that? The point of ghci is testing code interactively.  It's hard to test something that behaves differently when you try to test it.
20:28:38 <jeronimo> I want to do that so I can test the code interactively..
20:29:28 <joelteon> what?
20:29:30 <c_wraith> everything I can imagine you wanting to do with it would be better-served by factoring more things into top-level declarations
20:29:33 <jeronimo> I have some files in the program's path that I need to read, and they are either in getExecutableDirectory or in getCurrentPath depending if I am in ghci or not
20:29:44 <joelteon> import the Paths module
20:29:54 <joelteon> Paths_packagename
20:29:54 <c_wraith> yeah, the correct solution is Paths
20:31:19 <jeronimo> I don't have Paths. did you mean GHC.Paths?
20:31:22 <c_wraith> npe
20:31:25 <c_wraith> err.  nope
20:31:30 <joelteon> it's called Paths_yourpackagename
20:31:30 <c_wraith> It's auto-generated by cabal
20:32:07 <carter> jeronimo: just use doctests
20:32:18 <carter> also theres certain code thta will crash ghci
20:32:19 <jeronimo> and it will return source directory of the path?
20:32:21 <carter> but is ok compiled
20:32:25 <jeronimo> err, and it will return source directory of the module?
20:32:25 <carter> why do you want htat
20:32:29 <carter> why
20:32:41 <jeronimo> I think we are having a misunderstanding
20:32:56 <carter> you can get teh directory where its being built
20:33:02 <carter> but not the location of the source module
20:33:02 <jeronimo> that  is not what i want
20:33:06 <carter> whats the goal?
20:33:12 <chrisdone> http://tryhaskell.org/ -- now supports this IO monad: https://hackage.haskell.org/package/pure-io-0.0.2/docs/PureIO.html#g:2
20:33:16 <chrisdone> i wonder whether lambdabot could support it
20:33:53 <carter> o/ chrisdone
20:34:16 <jeronimo> I have "myprogram.glade" file that I need to pass go GTK's builderAddFromFile.  when in GHCI this file is in current directory (directory of the source), but when the program is compiled, this file will be in the same directory as the executable
20:36:19 <jeronimo> how would you handle this?
20:38:23 <carter> jeronimo: are you using cabal-instal 1.18 yet?
20:38:30 <carter> i'd use cabal repl
20:38:54 <jeronimo> no I am using 1.16
20:38:56 <carter> ok
20:39:02 <carter> so thats step 1 :)
20:39:16 <carter> "cabal update ; cabal install cabal-install"
20:39:16 <c_wraith> chrisdone: uh.  why are Input and Output wrapping ![String] ?  You know that's nearly useless to put the ! on, right?
20:39:33 <jeronimo> last time I tried to update cabal (a couple of weeks ago) it broke GTK
20:39:44 <carter> jeronimo: oh, i hear a new gtk2hs is out now
20:39:44 <jeronimo> is this fixed?
20:39:57 <c_wraith> updating cabal shouldn't affect any installed package
20:40:18 <carter> c_wraith: gtk is special
20:40:19 <carter> and fragile
20:40:25 <chrisdone> c_wraith: does it matter?
20:40:27 <carter> jeronimo: you probably tried befroe dec 1
20:40:41 <jeronimo> actually I wasn't able to install gtk, I don't know if updating it would break if I already had gtk installed
20:40:48 <c_wraith> chrisdone: that's what I was asking  you - does it do anything at all?
20:40:58 <carter> jeronimo: https://github.com/gtk2hs/gtk2hs/commit/0ac311bdc8f8dd86ae82ac619d456b368e915734
20:41:03 <chrisdone> c_wraith: oh
20:41:04 <carter> jeronimo: it won't break
20:41:24 <carter> jeronimo: if it does, i owe you apology and your choice of a pastry or beer
20:41:35 <jeronimo> ok. I am curious though how will cabal repl fix my issue?
20:42:05 <carter> jeronimo: does cabal isntall work?
20:42:15 <carter> if cabal build works, cabal repl works
20:42:23 <carter> if it doesnt work, you have a bug to report
20:42:23 <chrisdone> c_wraith: i generally default to banged fields unless i actually want laziness
20:42:27 <jeronimo> I have not tried yet. just curious if cabal repl is what I want
20:42:32 <carter> i think it is
20:42:45 <carter> if you have some project that has build time complexity
20:42:50 <carter> via setup.hs
20:42:55 <carter> and you want to use ghci to test stuff
20:42:59 <carter> cabal repl is it
20:43:03 <carter> if it doesnt work,
20:43:07 <carter> please file bug reports with examples
20:43:11 <carter> so we can make sure it wokr
20:43:13 <qrada> weird q, why in haskell 99 problems, alot of the strings are "abcdefghik" instead of "abcdefghijk" heh!
20:43:39 <carter> qrada: link?
20:43:44 <qrada> sec
20:43:49 <c_wraith> qrada: I blame it on someone having a keyboard that makes it hard to type j. :)
20:43:53 <carter> yes
20:43:53 <carter> that too
20:43:56 <carter> i was thinking that
20:43:57 <carter> aklfjdlksfjakls
20:43:57 <carter> :P
20:44:40 <jeronimo> ok I will try it
20:44:41 <qrada> for example, http://www.haskell.org/haskellwiki/99_questions/11_to_20
20:44:48 <qrada> search 'abcdefghik' ;f
20:45:02 <qrada> was just wondering
20:45:24 <jeronimo> by the way I am curious what you think about this use of unsafePerformIO?   `gladePath = unsafePerformIO (inExecutableDirectory "test.glade")'
20:45:48 <c_wraith> chrisdone: a more meaningful question - why not use a free monad construction that suspends the remainder of the calculation when it needs input, instead of just re-running everything (and, incidentally, appending to a list over and over)
20:45:54 <chrisdone> data X = X [String]; data Y = Y ![String]
20:45:55 <chrisdone> λ> case X undefined of X{} -> () → ()
20:45:55 <chrisdone> λ> case Y undefined of Y{} -> () → *** Exception: Prelude.undefined
20:46:02 <chrisdone> ^ if you were interested in the actual difference
20:46:09 <c_wraith> yes, but that's the only difference
20:46:19 <carter> jeronimo: why are you doing that
20:46:20 <c_wraith> It won't catch (undefined : undefined)
20:46:20 <carter> why
20:46:27 <chrisdone> c_wraith: so?
20:46:46 <carter> jeronimo: whats wrong with do notation
20:47:00 <jeronimo> carter it seemed convenient. and it is immutable in the sense that it won't change during the runtime
20:47:03 <chrisdone> c_wraith: the reason for re-running is because the use-case the monad is for can't have any state
20:47:13 <carter> jeronimo: if do notation would work, use that
20:47:44 <c_wraith> chrisdone: well, it still has state.  But I guess it's serializable state
20:47:45 <jeronimo> you mean make gladePath IO FilePath?
20:47:53 <carter> rm/
20:47:54 <carter> ?
20:48:02 <carter> jeronimo: do you have a repo of this code
20:48:07 <carter> because i have no clue what you just said
20:48:08 <chrisdone> c_wraith: ok
20:48:25 <c_wraith> easier to serialize a list of strings than a closure.  yeah, it has that.
20:49:01 <carter> :)
20:49:21 <jeronimo> carter I don't. you said to use do in response of my question about the appropriateness of using unsafePerformIO above. so I assumed you suggested to make gladePath of `IO FilePath' type instead of `FilePath'
20:49:31 <carter> nah
20:49:48 <carter> gladepath <- (inExecutableDirectory "test.glade")'
20:49:57 <carter> gladePath :: String then too
20:50:14 <jeronimo> oh
20:50:22 <jeronimo> gladePath is top-level though, again for convenience
20:50:36 <carter> code smell
20:50:41 <carter> even though in this case it'd be safe
20:50:54 <jeronimo> is using unsafePerformIO like this discouraged?
20:51:13 <carter> yes
20:51:16 <carter> i've used it quite a bit
20:51:16 <chrisdone> using unsafePerformIO flat out is discouraged
20:51:20 <carter> yes
20:51:31 <carter> unless you're a library writer and understand exactly exactly what it does
20:51:38 <carter> and even then, you need good rasons
20:51:47 <chrisdone> i asked SPJ for help once and he saw the word "unsafePerformIO" in my code and refused to help
20:51:50 <chrisdone> that's how discouraged
20:51:58 <carter> chrisdone: what was your use case?
20:52:05 <chrisdone> it was some TH bug
20:52:08 <carter> oh
20:52:10 <chrisdone> back in 6.12.3
20:52:14 <carter> yeah that'd be evil :P
20:52:22 <jeronimo> chrisdone interesting, because I recall SJP writing in some article that it is reasonable to use it for top-level IORef
20:52:27 <carter> yes
20:52:32 <chrisdone> that's the use-case i had it for
20:52:33 <carter> jeronimo: you're not doing that
20:52:36 <carter> :)
20:52:50 <carter> my sin in hOpenBLAS will be using unsafePrimToPrim
20:52:52 <jeronimo> carter I'd say top-level mutable IORef is even worse
20:52:53 <chrisdone> except the TH code was reading the IORef instead of runtime code
20:53:02 <c_wraith> I'm getting less-convinced over time that it's ok for a top-level mutable IORef
20:53:02 <carter> jeronimo: REPA is allowed to do that
20:53:15 <c_wraith> The problem with those is dynamic code loading.
20:53:21 <carter> oh yeah
20:53:32 <c_wraith> they don't play nicely with each other
20:53:41 <carter> i bet
20:53:49 <carter> i won't be copying that repa trick
20:53:51 <carter> but for different reasons
20:54:09 <carter> namely: doesn't maeke sense for distributed code
20:58:42 <Aetherspawn> :t foldl
20:58:43 <lambdabot> (a -> b -> a) -> a -> [b] -> a
20:58:44 <Aetherspawn> :t foldl1
20:58:44 <lambdabot> (a -> a -> a) -> [a] -> a
21:24:25 <simpson> Out of MonadPrompt, operational, Free, etc. which is recommended?
21:39:49 <randomclown> is here a demo of the usefulness of Free?
21:40:03 <randomclown> free monads that is
21:40:11 <carter> randomclown: write an interpreter
21:40:13 <carter> :)
21:40:47 <carter> monads are really "values you can run through an interpreter"
21:40:53 <carter> and Free is the one where you provide the interpreter
21:44:14 <chrisdone> having a single keybinding to create and jump to a "where" in your current decl is waaaay nice, can't believe i never defined it before
21:53:53 <lovewithacaveat> this is the book i had to read once upon a time: http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=pd_sim_b_69. it taught me to write function names like generateListContainingOnesUntilIndexKandZeroesAfter
21:58:50 <chrisdone> lovewithacaveat: orly
22:00:53 <carter> etrepum: well said point on the rust list
22:00:54 <carter> :)
22:01:36 <jeronimo>  ___
22:01:38 <jeronimo> {o,o}
22:01:40 <jeronimo> |)__)
22:01:42 <jeronimo> -"-"-
22:01:50 <carter> jeronimo: cabal repl working out?
22:02:12 <jeronimo> yes I am figuring it out
22:05:21 <mrack> how to use case on IO String? do I need to use <- first or is there a direct way?
22:06:03 <roboguy_> mrack: you have to use <- first basically
22:06:33 <roboguy_> or >>= or possibly fmap depending on what exactly you're doing
22:07:33 <mrack> args <- getArgs\n case args ...
22:08:33 <roboguy_> mrack: well, <- just desugars to an expression with >>= so you can always use that. as for fmap, again, it depends on specifics. but no, you can't pattern match on IO values directly
22:08:58 <satc> I have a function f :: a -> IO b and v :: Maybe a. Is there a pointfree way of applying f on v and getting IO (Maybe b)?
22:10:16 <shachaf> traverse
22:10:29 <satc> :t traverse
22:10:30 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:10:40 <satc> shachaf: thanks
22:16:41 <mrack> do you sometimes write foo >>= \x -> ...  instead of x <- foo; ... ?
22:17:01 <c_wraith> only if I want to do something as a one-liner
22:17:34 <roboguy_> mrack: usually I use >>= if I want to use a named function rather than a lambda. like foo >>= fn
22:19:34 * hackagebot parsec 3.1.5 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.5 (AntoineLatter)
22:23:49 <epta> How this compr. syntax [x + y | x <- xs, y <- ys, x < 3, y < 5] looks in do notation?
22:24:39 <roboguy_> epta: do { x <- xs; y <- ys; guard (x < 3); guard (y < 5); return (x + y) }
22:24:40 <joelteon> very bad
22:24:47 <joelteon> or not
22:26:30 <nstdloop> How do you guys solve the problem of clashing record syntax while avoiding looping imports?
22:26:58 <roboguy_> nstdloop: looping imports?
22:27:18 <nstdloop> file a imports file b, file c imports file b, file a imports file c
22:27:31 <nstdloop> file b imports file c
22:27:47 <roboguy_> nstdloop: you're talking about how record fields must have unique names?
22:27:50 <nstdloop> yes
22:27:58 <roboguy_> nstdloop: qualified imports can help some
22:28:06 <nstdloop> That's what I use
22:28:10 <nstdloop> but my problem is this
22:28:17 <nstdloop> I have a Game file which contains the Game type
22:28:21 <roboguy_> I don't think there's a particularly good solution yet, unfortunately
22:28:32 <nstdloop> I have a Play file which contains the logic for playing the game
22:28:39 <roboguy_> wait, how would that result in looping imports?
22:28:40 <nstdloop> and it has a function in it I would like to access from Game
22:28:48 <nstdloop> but Play imports the Game file
22:28:55 <nstdloop> so that would cause a loop
22:28:59 <nstdloop> so where should I define prompt
22:29:10 <nstdloop> without it just being a random utility module
22:29:20 <roboguy_> probably best to consolidate those into one module
22:29:37 <roboguy_> do they actually serve distinct, separate purposes?
22:29:55 <nstdloop> Well right now the only thing Play imports is Game
22:30:10 <nstdloop> actually
22:30:16 <nstdloop> I think that might be wise
22:30:27 <nstdloop> but I had this problem elsewhere
22:31:01 <nstdloop> I feel like it's mostly just the record field issue
22:31:13 <roboguy_> I'm not sure I see where record fields come into play here...
22:31:32 <nstdloop> I would just have more things in one module and not have this problem if I could have non-clashing record fiels
22:31:34 <nstdloop> fields*
22:33:01 <roboguy_> nstdloop: you could also separate them further. put the some of the types in one module and some of the functions in another
22:33:19 <roboguy_> and then use the type module in both other modules
22:33:39 <nstdloop> Ya I ended up doing that elsewhere
22:33:43 <nstdloop> Thanks for the tips
22:34:12 <roboguy_> sure!
22:37:21 <EdWoodRedWood> Hi.
22:37:37 <EdWoodRedWood> While reading a StackOverflow article about Haskell, I saw a statement that said " While working in a language with a strong type system, you are effectively proving free teorems about your code each time you compile". Can someone tell me what a free theorem is?What is this statement supposed to mean?
22:37:38 <EdWoodRedWood> Thanks!
22:38:01 <nstdloop> EdWoodRedWood: Basically, this means that types can tell you a lot about code.
22:38:07 <nstdloop> For instance, if you think about fst
22:38:18 <nstdloop> which has type (a, b) -> a
22:38:23 <nstdloop> @t fst
22:38:23 <lambdabot> Maybe you meant: tell thank you thanks thesaurus thx tic-tac-toe ticker time todo todo-add todo-delete type v @ ? .
22:38:28 <nstdloop> @type fst
22:38:29 <lambdabot> (a, b) -> a
22:38:29 <simpson> :t fst
22:38:30 <lambdabot> (a, b) -> a
22:38:47 <nstdloop> Because we know nothing about a or b
22:39:05 <nstdloop> we know that the code can't: construct new values of a, modify values of a, or view values of a
22:39:21 <nstdloop> so the only place it can get a value of a is from the first part of that tuple
22:39:53 <nstdloop> So, by knowing the type alone, we can infer that the only possible behavior of a non-pathological function with type (a, b) -> a is to return the first element
22:40:01 <nstdloop> AKA, we just got a free theorem
22:40:40 <Twey> Actually any function, modulo non-termination
22:41:23 <augur> nstdloop: that isnt quite a free theorem
22:41:45 <nstdloop> augur: I'm basically regurgitating RWH right there
22:41:49 <augur> nstdloop: thats just a fact about the possible programs that inhabit parametric types
22:42:05 <nstdloop> which is not a free theorem?
22:42:22 <augur> nstdloop: that f :: (a,b) -> a has to be fst
22:42:32 <roboguy_> augur: it's probably good to explain parametricity before free theorems though
22:42:33 <EdWoodRedWood> Thanks for responding nstdloop and augur. I appreciate your discussing it, helps me learn
22:42:36 <augur> i mean, maybe for pairs this happens to be true
22:42:51 <EdWoodRedWood> parametricity - another thing I need to learn about
22:43:16 <nstdloop> EdWoodRedWood: Oh you should definitely learn that first.
22:43:21 <augur> but free theorems are a little more subtle. the free theorem for lists, for instance, you get interesting facts about how these functions behave more broadly
22:43:30 <roboguy_> EdWoodRedWood: parametricity is when you can figure out all of the possible definitions of a function from it's type signature, essentially
22:44:01 <roboguy_> well, I mean you can always do that, but when it narrows it down to a small number of options due to polymorphism
22:44:09 <roboguy_> *maybe not always
22:45:10 <augur> nstdloop: i think the free theorem for [a] -> [a] is more subtle than just "f :: [a] -> [a] can only rearrange or duplicate elements or drop them using external criteria"
22:45:33 <nstdloop> what is it then
22:45:42 <augur> something about how map permutes
22:45:53 <augur> lemme find it
22:46:11 <c_wraith> yeah, it's that map g . f == f . map g
22:46:12 <roboguy_> well, the free theorem for fmap (and hence map) is the functor laws
22:46:22 <augur> ah yes, there you go, c_wraith
22:46:26 <roboguy_> I think
22:46:32 <nstdloop> Wow how do you figure that
22:46:44 <augur> nstdloop: well, thats what the paper on free theorems is about! :)
22:46:48 <augur> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
22:47:14 <nstdloop> I learn at least one new crazy thing from this channel every day
22:47:18 <augur> nstdloop: what you're talking about with (a,b) -> a being basically fst is true, but it has to do with the shape of possible proofs/programs with that type, nothing else
22:47:39 <augur> namely, there is exactly one proof of the type   `forall a b. (a,b) -> a`
22:48:09 <augur> so because you can show there is only one such proof/program, you know that any program with that type must be that unique program
22:48:12 <augur> but thats not a free theorem
22:48:27 <nstdloop> Right. Ok
22:48:38 <nstdloop> Makes sense
22:48:52 <chrisdone> can someone go here and just keep the tab open for a minute? i want to see if the 'active users' works as expected: http://tryhaskell.org/
22:49:18 <roboguy_> chrisdone: alright
22:49:18 <AshyIsMe> chrisdone: im there now
22:49:20 <augur> chrisdone: ok
22:49:28 <augur> nstdloop: p3 of the wadler paper has some more interestng free theorems
22:49:28 <nstdloop> chrisdone: doing it
22:49:43 <Cale> ... waiting for the number to report 1173
22:49:56 <chrisdone> seems like it doesn't work. thanks guys
22:50:02 <Cale> :O
22:50:17 <roboguy_> I kind of wish the wadler paper used some more haskell-like notation
22:50:26 <augur> nstdloop: the theorems for pairs are:   f . fst = fst . (a *** b)
22:50:33 <augur> er woops
22:50:36 <augur> nstdloop: the theorems for pairs are:   f . fst = fst . (f *** g)
22:50:46 <augur> and also   g . snd = snd . (f *** g)
22:50:48 <AshyIsMe> hehe, print [1..]
22:50:48 <Cale> roboguy_: It was written before Haskell existed!
22:50:53 <AshyIsMe> Unable to get reply from evaluation service. Did you go too far, this time?
22:51:00 <roboguy_> Cale: that's no excuse
22:51:02 <chrisdone> ashyisme: =p
22:51:02 <Cale> That's actually very Haskell-like for the time :)
22:51:06 <AshyIsMe> maybe i did little lambda, maybe i did
22:51:06 <augur> i think many of these free theorems are actually categorical definitiony things
22:51:25 <EdWoodRedWood> nstdloop, augur and roboguy_ - thanks. Let me read up those articles and come back
22:51:39 <nstdloop> This is cool.
22:51:41 <augur> EdWoodRedWood: the free theorems paper is really hard to grok
22:51:45 <c_wraith> chrisdone: can you copy one of ghci's hacks? In particular, for IO () expressions, don't print the () ?
22:52:05 <chrisdone> c_wraith: sure, good idea
22:52:06 <Cale> Actually, Haskell may have existed in some form. He refers to 'nub', which I don't think is a Miranda-ism
22:52:07 <c_wraith> chrisdone: I realize this is a brand new issue, since you only just started supporting pure io :)
22:52:38 <roboguy_> does that paper describe a method to systematically derive free theorems?
22:52:50 <EdWoodRedWood> Augur: I'm rather certain that at least 10 wikipedia articles will need to be opened before I get through it.
22:53:30 <roboguy_> EdWoodRedWood: are you familiar with haskell very much yet?
22:53:54 <simpson> roboguy_: Yes, it does. You just need a polymorphic function, and he describes a technique to wring a theorem from it.
22:54:40 <AshyIsMe> chrisdone: on a side note ive started writing the vimscript part for your structured-haskell-mode
22:54:43 <chrisdone> c_wraith: refresh, that should do it =)
22:54:46 <roboguy_> simpson: cool. I'll have to read it then. I always meant to read it, but I kept getting put off by the notation and distracted every time I've tried so far
22:54:51 <chrisdone> ashyisme: woot!
22:55:04 <AshyIsMe> though it's my first vimscript project so it may take me a while to get it useable
22:55:13 <EdWoodRedWood> roboguy_: A little - I'm getting back into programming (for kicks) as a hobby after working in management consulting for a bit. Since I'm not learning it for a job, Haskell seemed like the best thing to learn.
22:55:38 <roboguy_> EdWoodRedWood: ah, cool. good choice!
22:55:39 <chrisdone> ashyisme: keep me posted about progress =)
22:55:51 <AshyIsMe> will do :)
22:55:52 <EdWoodRedWood> Although I'm a comp. sci. major and have programmed in C and Java *many* years ago.
22:55:52 <augur> hm. i wonder how much these free theorems are narrowing the space of possible programs down
22:55:53 <roboguy_> djinn can't find free theorems can it?
22:55:58 <augur> does anyone happen to know?
22:56:16 <c_wraith> chrisdone: oh, hmm.  I'm not sure I actually like that - Because of the type displayed afterwards. It looks like print 5 has the value 5 and is of type IO ().  Hmm.
22:56:22 <simpson> @free (a -> b) -> [a] -> [b]
22:56:22 <lambdabot> Pattern match failure in do expression at src/Lambdabot/Plugin/Haskell/Free/FreeTheorem.hs:54:21-35
22:56:27 <simpson> @free f :: (a -> b) -> [a] -> [b]
22:56:27 <lambdabot> h . k = p . g => $map h . f k = f p . $map g
22:56:39 <simpson> roboguy_: No, but @free can! ^^
22:57:29 <roboguy_> simpson: hmm, that looks a little more general
22:57:31 <simpson> @free maybe :: (a -> b) -> b -> Maybe a -> b
22:57:31 <lambdabot> g . h = k . f => g . maybe h x = maybe k (g x) . $map_Maybe f
22:57:48 <roboguy_> actually, maybe not
22:58:04 <roboguy_> why does it introduce extra arguments?
22:58:18 <Cale> AshyIsMe: Something for vim which pays attention to layout keywords, and whenever an edit causes the first non-whitespace character after "let", "where", "do", or "of" to move, causes the corresponding block to move in the same fashion would on its own be quite nice.
22:58:40 <simpson> roboguy_: Because the theorems are actually slightly stronger than just starting with some f and g which can be composed.
22:59:11 <nstdloop> If I do an instance declaration for Show in a module, do I have to export show?
22:59:18 <roboguy_> simpson: so "map f . g = f . map g" isn't true in all cases?
22:59:20 <chrisdone> ashyisme: i implemented 'skeletons' with placeholders today: http://chrisdone.com/shm-skeletons.ogv
22:59:21 <augur> oh man
22:59:29 <roboguy_> err, I messed that up
22:59:31 <augur> is there a blog post explaining how @free works?
22:59:37 <roboguy_> "map f . g = g . map f"
22:59:39 <Cale> nstdloop: You have to export the instances you write, there's no way to control that.
22:59:50 <chrisdone> ashyisme: to avoid parse errors that come from typing case/if/let
22:59:59 <Hafydd> Does it have to be a blog post?
23:00:00 <nstdloop> Cale: so I do export show?
23:00:07 <nstdloop> or just the type?
23:00:13 <Cale> nstdloop: You don't export show, the Prelude does
23:00:23 <simpson> roboguy_: Well, yes, your version is true. lambdabot is stating a slightly more general version which is also true.
23:00:34 <roboguy_> simpson: ah, I see
23:00:36 <Cale> nstdloop: The instance, which doesn't have a name, will automatically be exported.
23:00:36 <nstdloop> Right. So if I have a type A and I make it an instance of show I just export A
23:00:44 <Cale> yes
23:00:50 <nstdloop> Ok that's what I thought
23:00:51 <nstdloop> great
23:01:30 <augur> roboguy_: map f . g = g . map f  in all cases where g :: forall a. [a] -> [a]
23:01:54 <augur> @free g :: [a] -> [a]
23:01:54 <lambdabot> $map f . g = g . $map f
23:02:08 <roboguy_> augur: ah, right that makes sense. it's not necessarily true if g is defined on a specific type right?
23:02:22 <augur> @free g :: [a] -> [Int]
23:02:22 <lambdabot> $map $id . g = g . $map f
23:02:36 <augur> @free g :: [Int] -> [a]
23:02:36 <lambdabot> $map f . g = g . $map $id
23:02:39 <augur> @free g :: [Int] -> [Int]
23:02:39 <lambdabot> $map $id . g = g . $map $id
23:03:00 <augur> well there you go: it seems as tho if a is instantiated, then f is forced to be id
23:03:03 <simpson> At that point, it's trivial from fmap id == id
23:03:35 <epta> chrisdone: looks great!
23:03:54 <augur> i think the case with one fixed a is more interesting
23:04:13 <nstdloop> How do I export a data constructor? I keep getting an error trying to do that.
23:04:20 <augur> g = g . map f   is interesting and so is   map f . g = g
23:04:54 <chrisdone> epta: :D
23:04:59 <epta> nstdloop: module M (Data(..)) where
23:05:15 <nstdloop> right right right thanks
23:05:33 <augur> these free theorems look like naturality squares to me
23:06:00 <epta> chrisdone: any chance to having this in vim someday?
23:06:49 <chrisdone> epta: AshyIsMe is re-implementing it in vim
23:07:19 <augur> and i find it delightful that i can say that, know what it means, and be confident that its correct. im please to know that my CT studying has paid off. :D
23:07:26 <roboguy_> chrisdone: that where jump is definitely a good idea
23:07:29 <augur> catsters, its all because of you. than you eugenia cheng
23:08:26 <roboguy_> augur: someday I need to actually learn something about category theory. how much of it would you say helps give a better understanding of how lens actually works, haha?
23:08:53 <chrisdone> oh yay: the active users works now: http://tryhaskell.org/
23:08:54 <chrisdone> roboguy_: yeah, also the 'undefined' and '_' are kind of evaporating "slots". when you type on them or paste onto them, they disappear. so you don't have to delete them
23:08:55 <roboguy_> I have a vague idea, but I mean some of the more complex details
23:08:55 <augur> roboguy_: lends? whooo boy. uh.. none? a little? its hard to say
23:09:04 <augur> roboguy_: read my lens tutorial!
23:09:07 <chrisdone> roboguy_: (and yet they exist in the buffer)
23:09:24 <epta> chrisdone: didn't see something related in his guthub repos
23:09:24 <roboguy_> chrisdone: man. maybe I should try it out! it looks pretty awesome
23:09:30 <roboguy_> augur: I probably already have. which one?
23:09:45 <augur> roboguy_: http://purelytheoretical.com/programming/Lenses.hs
23:10:03 <augur> its not perfect -- there are some things i would do differently/edit, but
23:10:14 <roboguy_> augur: huh, actually I haven't seen that yet. I'll take a look through it when I get a chance!
23:10:53 <roboguy_> some of the internals of lens (the Conjoined class for example) seem a little intimidating...
23:11:07 <Twey> augur: Syntax highlighting on that would be nice… =)
23:11:12 <roboguy_> Conjoined easily has the most constraints of anything I've seen so far in haskell
23:11:15 <augur> Cale, chrisdone: does that sounds aout right? free theorem = naturality square ?
23:11:21 <augur> Twey: yeah yeah :P
23:11:34 <Fuuzetsu> chrisdone: Is it still horribly broken like it was in the best, randomly giving errors or just wrong results?
23:11:49 <chrisdone> fuuzetsu: nope, that was fixed in the rewrite!
23:11:56 <Cale> augur: roughly. There are cases where there are still free theorems even though you can't make functors happen.
23:11:59 <roboguy_> augur: the description of things like Conjoined also makes me think a little category theory might help some
23:12:06 <roboguy_> "This is a Profunctor that is both Corepresentable by f and Representable by g such that f is left adjoint to g. From this you can derive a lot of structure due to the preservation of limits and colimits."
23:12:19 <augur> Cale: thats interesting. i'd be interested in seeing such cases elaborated on.
23:12:26 <chrisdone> fuuzetsu: although it's a bit slower than it was because it uses plain old mueval, no performance enhancements. but at least it's reliable
23:13:23 <augur> Twey: ill add syntax highlighting/github it when i rewrite some parts.
23:13:27 <Fuuzetsu> Mhm, the speed was never really an issue.
23:14:00 <Twey> augur: Oh, okay — I was just about to run it through emacs' highlighting for you :þ
23:14:14 <chrisdone> htmlfontify-buffer ftw
23:14:50 <Twey> Ah, that's the command I was looking for!
23:15:18 <chrisdone> :D
23:15:39 <chrisdone> when i get round to it, that's how i'll get agda support on lpaste -- just call emacs
23:16:01 <roboguy_> chrisdone: I really like that the docs say that structured-haskell-mode is incompatible with haskell-indentation-modes. those have caused me some trouble
23:16:15 <chrisdone> yeah that are kind of a kludge
23:16:16 <Fuuzetsu> It is already too late, emacs is now used as a separate tool.
23:16:51 <roboguy_> chrisdone: at least one of them tends to have some kind of runtime error especially with "case"
23:17:50 <Cale> @free f :: (c -> c) -> (c -> c)
23:17:50 <lambdabot> g . h = k . g => g . f h = f k . g
23:17:54 <randomclown> what's the adventage of bounded channels?
23:18:25 <Cale> augur: ^^ which functors is that a naturality square between?
23:18:50 <Cale> randomclown: Not filling up memory forever when the sending ends work more quickly than the receiving ends.
23:18:53 <augur> Cale: 0_0
23:19:09 <augur> Cale: needs more types
23:19:35 <augur> Cale: i take it g, h, k :: c -> c
23:20:02 <Cale> I wonder why it didn't specify the types of g, h, and k, it used to
23:20:16 <CADD> and f
23:20:23 <CADD> oops
23:20:26 <CADD> misread that
23:20:42 <CADD> thats a very interesting function
23:20:57 <hdevalence> if I have f :: a -> b -> c and g :: c -> d, is there a way to combine g and f pointfree to get a -> b -> d ?
23:21:06 <CADD> is that a constraint that lambdabot returned?
23:21:11 <Cale> (g .) . f
23:21:17 <CADD> Cale: ^
23:21:18 <Cale> Or fmap g . f
23:21:21 <hdevalence> thanks
23:21:29 <Cale> CADD: It's a theorem derived from the type of f
23:21:48 <CADD> its using djinn in the background, right?
23:21:54 <Cale> not djinn
23:22:00 <CADD> oh
23:22:01 <Cale> http://hackage.haskell.org/package/free-theorems -- this program iirc.
23:22:10 <CADD> neat, thanks!
23:22:21 <hdevalence> Cale: fmap works because functions are functors, or something?
23:22:52 <mrack> what would you say to someone who asks if haskell has loops?
23:22:57 <hdevalence> oh, yes
23:22:59 <Cale> mrack: yes
23:22:59 <hdevalence> I see, now
23:23:06 <hdevalence> Cale: thanks for the help
23:23:14 <Cale> hdevalence: No problem :)
23:23:22 <chrisdone> it has strange loops =)
23:23:29 <mrack> Cale yes it had loops? which ones?
23:23:45 <mrack> heh
23:23:53 <Cale> mrack: I can write things like  forM_ [1..10] $ \x -> print x
23:24:04 <Cale> mrack: The loops tend to be library functions
23:24:19 <mrack> Cale but that is just a function, right?
23:24:23 <Cale> yes
23:24:30 <Cale> Defined recursively
23:24:37 <flazz> is it possible to have a class require a type? e.g. class Space a where forall . p :: *; elem :: a -> p -> Bool
23:24:40 <Cale> forM_ [] = return ()
23:24:43 <Cale> er
23:24:47 <Cale> forM_ [] f = return ()
23:25:02 <Cale> forM_ (x:xs) f = do f x; forM_ xs f
23:25:27 <Cale> (It's actually defined in terms of something called sequence_ but that gives you an idea of how it can be done)
23:25:32 <eazar001> > forM_ [1..10] $ \x -> print x
23:25:33 <lambdabot>  <IO ()>
23:26:29 <Cale> flazz: Probably, but I'm a little unclear on what it is that you want.
23:27:15 <eazar001> > forM [1..10] $ \x -> print x
23:27:16 <lambdabot>  <IO [()]>
23:27:17 <Cale> flazz: There are associated types, and of course, you can just define methods which involve more type variables
23:27:39 <Cale> The difference between forM and forM_ is that the latter discards the results of each iteration.
23:27:56 <chrisdone> eazar001: try that on tryhaskell =p
23:28:07 <Cale> (or in ghci)
23:28:08 <mrack> would it be correct to say that Haskell has no loops, just recursion and recursive functions that act like loops?
23:28:10 <flazz> Cale: what can associated types do?
23:28:16 <eazar001> chrisdone: lol, yea okay
23:28:32 <chrisdone> cale: let's get IO in lambdabot! =p
23:28:38 <augur> Cale: hm.
23:28:41 <chrisdone> who runs it these days?
23:28:43 <Cale> mrack: Is there a meaningful difference between a loop and a recursive function which acts like one?
23:28:54 <augur> so i wonder -- are all naturality squares free theorems?
23:29:01 <augur> and what are free theorems from a CT perspective?
23:29:06 <Cale> mrack: In fact, forM_ in the libraries isn't recursive, it's defined in terms of something more primitive which is though :)
23:29:08 <augur> also, how the heck does @free work?
23:29:24 <Cale> mrack: We can define:
23:29:45 <Cale> sequence :: (Monad m) => [m a] -> m [a]
23:30:06 <Cale> which takes a list of actions, and glues them together into a single action which produces a list of the results
23:30:13 <Cale> sequence [] = return []
23:30:27 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:31:25 <Cale> and then define a for-each loop by mapping the loop body (which is a function of the index) over the list to be iterated over, getting a list of actions, and then applying sequence to it to glue those actions together into something which will run them all in turn
23:31:42 <Cale> mapM f xs = sequence (map f xs)
23:32:02 <Cale> forM f xs = mapM xs f
23:32:04 <Cale> er
23:32:12 <Cale> forM xs f = mapM f xs
23:32:21 <randomclown> Cale: is it standard to forkIO a thread purely for reading from a chan?
23:32:24 <Cale> ^^ the above was right, but the variable naming was confusing ;)
23:32:29 <Cale> randomclown: yes
23:32:34 <Cale> randomclown: forkIO is cheap
23:33:05 <Cale> randomclown: It's totally okay to start tens or hundreds of thousands of threads.
23:34:47 <Cale> mrack: So, it's all about where you draw the line. We could do away with recursion altogether and instead have the compiler provide us with the very primitive notion of a fixpoint combinator:
23:34:55 <Cale> fix :: (a -> a) -> a
23:34:56 <mrack> Cale I guess there isn't a practical difference between the two. I was just wondering what to answer to a haskell programmer who asked me if "recursion is the only way to loop in haskell"
23:35:19 <mrack> to a nonhaskell programmer, rather
23:35:25 <Cale> fix f = x where x = f x -- this is how we'd normally define fix using recursion, but if you'd like, I can show you how to go the other way around :)
23:35:34 <randomclown> Cale: say I have hundreds of threads, and I need to be able to send a unique message to each individually. How should I organise my program?
23:36:17 <Cale> mrack: It's too easy to say yes. More interesting to consider the ways in which the answer is no :)
23:36:33 <Cale> mrack: But really that question doesn't mean a whole lot.
23:36:51 <Cale> Because you can define things using recursion which will then allow you to write loops without using recursion.
23:37:15 <Cale> Does that mean you're "really" using recursion?
23:37:38 <randomclown> Oh lawd I should use CPS
23:37:40 <randomclown> nvm
23:37:47 <chrisdone> oh lawdy
23:38:53 <Iceland_jack> mrack: There are many different kinds of loops (https://en.wikipedia.org/wiki/Control_flow#Loops), if yo use “loop” to refer to built-in looping constructs like in C then Haskell doesn't have that
23:38:57 <Iceland_jack> *if you
23:38:58 <mrack> I would say we are using recursion indirectly
23:39:05 <Cale> randomclown: I'm a little unclear on what you mean by "a unique message to each individually" -- you can create a list of MVars or Chans, fork a bunch of threads each of which reads from one of those, and then in your main thread, send each of the Chans a different message
23:39:50 <Cale> An implementation of Haskell could put in fix as a primitive, and define explicit recursion as syntax sugar for fix.
23:40:03 <Cale> So that when you write:
23:40:14 <Cale> fac n = if n == 0 then 1 else n * fac (n-1)
23:40:20 <Cale> it's translated into:
23:40:33 <Cale> fac = fix (\f n -> if n == 0 then 1 else n * f (n-1))
23:40:55 <Cale> This can be done even with mutually recursive blocks of definitions.
23:40:58 <Iceland_jack> Since people think of for/do-while/while statements when they think of loops you can just tell them that Haskell doesn't have that kind of loops
23:41:10 <Cale> But it also kind of does!
23:41:31 <Cale> You can write your own variations on for or while loops
23:41:52 <Iceland_jack> Yes but come on, that's not what's being asked
23:41:57 <Cale> Any kind of imperative loop you can imagine, I can write it in Haskell and proceed to use it as if it were built in to the language
23:42:15 <Cale> I think that's important to get across in any kind of complete answer to that question :)
23:42:35 <Iceland_jack> Maybe so, I think it's just going to confuse more than not
23:42:48 <Iceland_jack> bringing in fix points etc.
23:43:22 <Cale> Well, okay, the point about fix was just that we could choose to have a primitive fixpoint function, rather than taking recursive definition to be primitive
23:43:32 <mada> I don't get the relation between the fix function and imperative loop constructs
23:44:09 <Cale> mada: Well, one might complain "all those loop constructs are defined in terms of recursion", to which a counterpoint might be "all that recursion is defined in terms of fix"
23:44:47 <Cale> Which things are really primitive is kind of a moot point.
23:45:05 <Cale> The compiler's going to get its hands on things and turn it all into something unrecognisable anyhow :)
23:45:39 <Cale> Many of the things which look like loops will end up looking something like the loops that assembly programmers would write, after sufficient optimisations.
23:45:47 <shachaf> define all recursion in terms of the y combinator
23:46:00 <shachaf> let's see your inliner now, ghc
23:46:05 <osa1> any recommended functions for stripping trailing and leading whitespace from string?
23:46:06 <Cale> (and that really does happen often enough)
23:46:25 <chrisdone> Data.Text.strip
23:46:40 <osa1> chrisdone, I need it for String
23:47:10 <Cale> reverse . dropWhile isSpace . reverse . dropWhile isSpace
23:47:17 <osa1> :-)
23:47:20 <Iceland_jack> ugh
23:47:51 <Iceland_jack> @ty Data.Text.unpack . Data.Text.strip . Data.Text.pack
23:47:52 <lambdabot> String -> String
23:47:55 <Cale> If you don't mind compressing intermediate whitespace, unwords . words is pretty good
23:47:59 <chrisdone> osa1: i still just use text functions
23:48:43 <Cale> (in fact, I find it's usually closer to what I want than just stripping the space at beginning and end)
23:49:21 <Cale> unwords . words $ "    here   \t  is  \n \n some text \v with random    whitespace   \n"
23:49:26 <Cale> > unwords . words $ "    here   \t  is  \n \n some text \v with random    whitespace   \n"
23:49:26 <lambdabot>  "here is some text with random whitespace"
23:53:06 <Iceland_jack> Cale: Can I use the whitespace as a source for randomness then? :)
23:53:20 <Cale> not very much randomness, but I guess
23:53:46 <Iceland_jack> Code on IRC is my primary source for randomness
23:54:50 * hackagebot pipes-attoparsec 0.3.1 - Attoparsec and Pipes integration.  http://hackage.haskell.org/package/pipes-attoparsec-0.3.1 (RenzoCarbonara)
23:55:33 <nstdloop> What's the best way to construct a short list based on a series of conditionals?
23:56:09 <chrisdone> huh?
23:56:13 <Iceland_jack> nstdloop: You'll need to provide a little more information than that
23:56:22 <Iceland_jack> What are these ‘conditionals’?
23:56:25 <nstdloop> Ok. I have an object with a few attributes
23:56:38 <Cale> nstdloop: Maybe something like [x | cond1] ++ [y | cond2] ...
23:56:39 <nstdloop> and I want to create a list of Strings that has differing strings based on these attributes
23:56:51 <Iceland_jack> nstdloop: map or list comprehension?
23:56:58 <nstdloop> Cale: I like that.
23:57:29 <Iceland_jack> [ if age > 18 then "old" else "young" | Person name age ← people ] ?
23:57:47 <Iceland_jack> If that's what you want then there are many ways of doing it
23:57:49 <nstdloop> Iceland_jack: that works but Cale's is more appropriate to my use case
23:57:53 <Cale> Iceland_jack: I took it to mean that he has one conditional for each element of the list
23:57:59 <nstdloop> I do
23:57:59 <Iceland_jack> ah
23:58:40 <Iceland_jack> Cale's solution traverses the list multiple times though and then concatenates the output
23:58:47 <Cale> no
23:59:05 <Cale> Those are one-element lists
23:59:12 <Iceland_jack> yes never mind
23:59:18 <Cale> well, zero-or-one element lists :)
23:59:31 <Cale> > ["hello" | False]
23:59:32 <lambdabot>  []
23:59:37 <Cale> > ["hello" | True]
23:59:38 <lambdabot>  ["hello"]
23:59:49 <roboguy_> Cale: huh, that's clever. I've never seen anyone do that before
23:59:58 <Iceland_jack> roboguy_: it's suggested by hlint
