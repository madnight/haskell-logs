00:13:32 <pyr> hi haskellers!
00:13:40 <attilah> Hi
00:14:09 <johnw> hi pyr
00:16:54 <pyr> I may have missed something, but is there a combinator or syntactic sugar within the IO monad to pipe the output of an IO call to a pure fn ? e.g: my_assignment <- readFile some_path <magic_operator>  lines
00:17:06 <pyr> (yes I know i can get lines directly, just wondering)
00:17:16 <johnw> where did lines come from?
00:17:24 <johnw> do you mean this:
00:17:28 <johnw> x <- lines <$> readFile some_path
00:17:38 <dv-> or lines `fmap` readFile path
00:17:48 <pyr> fmap!
00:18:02 <pyr> I knew there was a way
00:18:21 <pyr> thanks guys
00:18:39 <pyr> I get lost in all the combinators sometimes
00:18:46 <pyr> not enough practice / muscle memory
00:19:10 <mgsloan> Or if we want to get kmettian, <&> from Control.Lens could be substituted for <magic_operator>
00:19:30 <mgsloan> (it's just (flip fmap))
00:19:36 <pyr> ack
00:19:46 <mgsloan> Sorry for the combinator overload :P
00:20:02 <mgsloan> But it would fit in there, and even has <>
00:21:05 <johnw> and 80% of the people reading your code would see it and think to themselves, wtf does that do?
00:21:21 <johnw> unless your objective is to teach lens, then by all means!
00:22:01 <mgsloan> True, I wouldn't mind having such operators outside of lens
00:22:07 <johnw> i agree
00:24:00 <mgsloan> If the question of what <magic_operator> goes there is answered pedantically, then this is the best answer :)
00:24:49 <johnw> granted
00:26:07 <startling> is TypeLits not in 7.6?
00:27:12 <Twey> startling: It is
00:27:31 <Twey> Though I think (+) &c. are somewhat less limited in 7.8
00:28:03 <startling> oh, DataKinds switches it on. Thought it was its own pragma for some reason. thanks!
00:30:43 <attilah> What are lenses ? And what r they used for ?
00:30:50 <johnw> funny you should ask
00:30:58 <johnw> i'm using lenses right now
00:31:12 <johnw> they are a way of describing the parts of a data structure that you want to either examine or mutate
00:31:20 <attilah> Cool, johnw. :)
00:31:28 <jle`> attilah: mostly just a collection/grab bag of handy accessors and combinators and operators
00:31:38 <johnw> for example, I'm folding over a list mutating a map within a record
00:31:49 <johnw> so I'm writing: record.field.at index ~. Just value
00:31:50 <jle`> basically to get rid of boilerplate code
00:32:07 <johnw> rather than: record { field = insert index value (field record) }
00:32:23 <johnw> and lenses compose very nicely
00:33:07 <jle`> http://lens.github.io/tutorial.html
00:33:09 <johnw> so if you write your algorithm generically for any lens, you can express some algorithms very nicely
00:35:34 <johnw> sorry: record & field.at index ~. Just value
00:37:33 <johnw> attilah: by far the best intro to lenses that I've ever seen: http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation
00:38:27 <shachaf> Do you mean "the best intro to lens"? Or also lenses, which are a way simpler concept than the "lens" library?
00:38:46 <johnw> I mean more the latter
00:39:00 <johnw> with a segue to understanding the types in "lens" better
00:39:08 <johnw> at least, some of them
00:39:52 <attilah> Thx guys 4 d links. I'll dive in and ask any questions I might have later on.
00:41:44 <johnw> there is also a #haskell-lens channel
00:43:00 <startling> is there a way to spell this so that GHC understands what I mean? https://gist.github.com/startling/4746ca8f5539e20086a2
00:43:03 <startling> 7.6 specifically.
00:45:43 <shachaf> Probably not using TypeLits?
00:46:02 <mjrosenb> @hoogle bool -> a -> Maybe a
00:46:03 <lambdabot> Did you mean: Bool -> a -> Maybe a
00:46:03 <lambdabot> Prelude seq :: a -> b -> b
00:46:03 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
00:46:08 <shachaf> They don't really work, you know.
00:46:17 <startling> shachaf: oh, I didn't know.
00:46:18 <mjrosenb> @hoogle Bool -> a -> Maybe a
00:46:18 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
00:46:18 <lambdabot> Control.Exception assert :: Bool -> a -> a
00:46:18 <lambdabot> Control.OldException assert :: Bool -> a -> a
00:46:29 <startling> that's a shame.
00:46:40 <shachaf> 1 has no relation to 2. 1 + 1 is not equal to 2
00:46:54 <startling> shachaf: uh, weird.
00:47:02 <shachaf> So make your own Nat type, data Nat = Z | S Nat
00:47:47 <Twey> startling: I'm told it does in 7.8
00:47:49 <startling> yeah, fair enough. thanks!
00:48:15 <shachaf> mjrosenb: If you're OK with MonadComprehensions, you can use [x | b] :: Maybe ...
00:48:21 <Twey> There's no ‘succ’ in GHC.TypeLits, either.  It's a shame, because that makes it pretty useless in 7.6.
00:48:41 <mjrosenb> shachaf: I just rolled my own.
00:48:42 <mjrosenb> guard' True a = Just a
00:48:42 <mjrosenb> guard' False _ = Nothing
00:49:04 <shachaf> guard' b x = guard b >> return x -- also
00:59:34 <johnw> also: guard' b x = mfilter b (Just x)
01:08:51 <bernalex> a prof sent me an email with some interesting haskell questions I was hoping you guys could help me with
01:09:39 <bernalex> if making... Assassin's Creed 5 in Haskell - how can you deal with GC? and is things like type inferencing fast enough? etc
01:10:09 <bernalex> i.e. hwat would cause performance issues for Haskell Assasin's Creed 5 (which is of course just an example of a AAA game), and how can Haskell solve it as of today?
01:12:36 <tdammers> bernalex: type inference happens at compile time, it does not affect performance at all
01:12:58 <bernalex> tdammers: doh
01:13:06 <bernalex> tdammers: of course. so what about GC?
01:13:17 <tdammers> well, GC comes with Haskell, basically
01:13:24 <tdammers> so it happens one way or another
01:13:44 <bernalex> yes, but in C++ you do this manually to squeeze out every last bit of performance. is Haskell's GC good enough for... Asssasin's Creed 5?
01:14:52 <Aleksejs> bernalex, functional languages require very good GC, so I assume haskell's GC is good enough
01:15:04 <bernalex> Aleksejs: based on what?
01:17:25 <Aleksejs> bernalex, you can sheck here http://stackoverflow.com/a/15243682
01:17:30 <Aleksejs> check*
01:19:10 <bernalex> Aleksejs: interesting, thanks.
01:19:52 <Aleksejs> but I'm not saying you should make AC5 on haskell :)
01:21:09 <bernalex> Aleksejs: I'm trying to figure out what's stopping me. or Ubisoft, rather. apart from ecosystem/libraries/manpower/etc. i.e. what's wrong with Haskell itself (and by extension GHC).
01:26:02 <grohne> bernalex: an issue is the unpredictability of performance. when you look at a piece of code, you cannot trivially determine what will take long. specifically it is very hard to notice where strictness is needed to keep gc time low.
01:26:27 <bernalex> grohne: can't you "assume it works" until it doesn't, and then figure it out with profiling?
01:27:13 <grohne> bernalex: most of the time you can. but then you change a tiny bit and it blows up at the other egde
01:27:32 <bernalex> grohne: OK, so it's work. but it's not impossible, at least?
01:27:46 <bernalex> grohne: I'm looking for things that just block the idea entirely
01:28:32 <grohne> another issue is the rate of change in language and libraries. but again that's not a blocker.
01:29:06 <bernalex> grohne: I choose to ignore that as an ecosystem thing, along with not enough libraries.
01:29:31 <bernalex> but you are absolutely right in that it could be a real world problem.
01:29:44 <satc> Why haddock gives parse error on multiline constructor documentation like this http://lpaste.net/98939
01:30:07 <bernalex> however, game hackers typically need to be bleeding edge, and maybe even a bit further ahead than that. so they know all about that workflow.
01:30:43 <bernalex> satc: why -- ^?
01:31:12 <satc> bernalex: I want to document each parameter to the constructor. Thats a haddock documentation
01:31:15 <bernalex> satc: see what I have in e.g. https://github.com/plaimi/bweakfwu/blob/master/src/bweakfwu/World.hs
01:31:36 <bernalex> data World = ...
01:33:58 <satc> bernalex: I dont want to use record syntax. It gives same error with -- | too.
01:34:08 <bernalex> satc: what is the error?
01:34:15 <bernalex> it's kind of relevant...
01:34:37 <bernalex> also please just post the actual example instead of what you have, which isn't valid Haskell anyway
01:35:01 <tdammers> bernalex: if you need tight timing with predictable memory allocations, Haskell is not your friend
01:35:17 <tdammers> bernalex: but you can code the critical parts in C and wrap it in some FFI magic
01:35:22 <skypers_> isn’t roboguy here?
01:35:34 <tdammers> bernalex: and then use Haskell to write the higher-level parts of the program
01:35:37 <skypers_> Carmack answered back to me :)
01:35:38 <skypers_> https://twitter.com/skypers_/status/425923013180014592
01:36:17 <grohne> skypers_: he quit 2.5 hours earlier
01:36:34 <skypers_> quit what?
01:36:37 <skypers_> #haskell?
01:36:53 <grohne> skypers_: yes
01:36:56 <skypers_> omg
01:36:59 <skypers_> he was there?
01:37:10 <bernalex> skypers_: he tweeted at me this December. highlight of the day. :-P
01:37:24 <skypers_> bernalex: what was that about? :D
01:37:29 <skypers_> he seems to be a really nice person
01:37:36 <satc> bernalex: It gives parse error on the second parameter. And why is this not a valid haskell?
01:37:41 <skypers_> how do you know it was him 2,5 earlier?
01:37:54 <satc> bernalex: I meant the haddock generation not the code compilation
01:37:55 <startling> skypers_: I think grohne is taling about roboguy_
01:38:02 * hackagebot xmlgen 0.6.2.1 - Fast XML generation library  http://hackage.haskell.org/package/xmlgen-0.6.2.1 (StefanWehr)
01:38:05 * hackagebot clay 0.8.0.1 - CSS preprocessor as embedded Haskell.  http://hackage.haskell.org/package/clay-0.8.0.1 (SebastiaanVisser)
01:38:11 <skypers_> startling: ok, thank you
01:38:13 <johnw> preflex: seen Carmack
01:38:15 <bernalex> skypers_: I tweeted that I wondered what would have happened if he used quakelisp instead of quakec, with regards to programming language trends. :-)
01:38:23 <bernalex> satc: post the error and your actual code.
01:38:47 <skypers_> johnw: preflex?
01:39:08 <johnw> isn't he the one who knows when people were in the channel?
01:39:18 <startling> preflex: seen preflex
01:39:26 <startling> (he's not here)
01:39:40 <satc> bernalex: http://lpaste.net/98940 and error for `haddock foo.hs` is "foo.hs:4:16: parse error on input `Int'"
01:39:41 <bernalex> skypers_: followed you. I need more haskell-tweets in my feed.
01:39:49 <skypers__> damn connection
01:39:52 <skypers__> ok se he’s preflex?
01:39:57 <skypers__> I don’t get it :D
01:39:59 <johnw> no
01:40:04 <bernalex> satc: uhm that's not valid haskell
01:40:06 <johnw> preflex is a bot that records when people leave the channel
01:40:15 <skypers__> I see
01:40:19 <johnw> @preflex seen skypers__
01:40:19 <lambdabot> Unknown command, try @list
01:40:24 <johnw> oh well
01:40:24 <bernalex> satc: oh, wait. nvm.
01:40:25 <startling> @xseen skypers_
01:40:26 <lambdabot> Unknown command, try @list
01:40:28 <startling> sigh
01:40:31 <skypers__> :D
01:40:32 <merijn> johnw: Pretty sure it's when they last talk
01:40:37 <merijn> preflex: seen skypers__
01:40:41 <startling> preflex, though, is not here
01:40:50 <merijn> ah
01:40:52 <skypers__> ok, so he’s Carmack
01:40:57 <merijn> My bad :p
01:41:00 <startling> sigh
01:41:13 <Yaniel> @seen skypers_
01:41:13 <lambdabot> zKypErS_
01:41:19 <startling> haha
01:41:20 <skypers__> what? :D
01:41:23 <Yaniel> what
01:41:24 <satc> merijn: Any thoughts on haddock error in http://lpaste.net/98940
01:41:28 <merijn> Yaniel: Lambdabot doesn't have a "seen" command
01:41:29 <skypers__> @seen skypers
01:41:30 <lambdabot> sxYPerz
01:41:40 <merijn> Yaniel: It's autocorrecting to leet or something, I'm guessing
01:41:44 <bernalex> satc: right. I see. IDR how to do that without record syntax, sorry.
01:41:44 <merijn> @leet skypers
01:41:45 <lambdabot> 5xyP3Rz
01:41:47 <merijn> Yup
01:41:53 <startling> @leet seen
01:41:53 <lambdabot> 5EEn
01:41:58 <startling> @5een skypers_
01:41:58 <skypers__> is there the log?
01:41:58 <lambdabot> zxYPER5_
01:42:03 <skypers__> of the talk with carmack?
01:42:06 <skypers__> I’d love having a look
01:42:08 <startling> skypers_, sigh
01:42:13 <startling> skypers_, Carmack was not ehre.
01:42:30 <skypers__> startling: so why you guys said he was there?
01:42:51 <startling> skypers__, two concurrent conversations got mixed up
01:43:14 <skypers__> some one just said he “quit 2.5 hours earlier”
01:43:17 <startling> < skypers_> isn’t roboguy here?
01:43:21 <skypers__> ah
01:43:22 <skypers__> ahah
01:43:26 <skypers__> ok
01:43:27 <skypers__> :DD
01:43:28 <startling> < grohne> skypers_: he quit 2.5 hours earlier
01:43:34 <skypers__> okok
01:43:36 <skypers__> got it
01:43:36 <skypers__> :D
01:44:04 <startling> let's just roll back this conversation and try to get a consistent one.
01:44:34 <johnw> startling: it does have an ACID feel
01:44:48 <Axman6> but I've already observed the results!
01:44:52 <Axman6> ur fuxed!
01:45:08 <startling> Axman6, you are part of the results. you will be rolled back.
01:45:21 <Axman6> like hell I will!
01:45:25 * Axman6 holds onto desk
01:45:33 <Axman6> I ain't goin anywhere!
01:45:57 <Tekmo> That's why your desk has wheels
01:46:51 <Axman6> damnit, why did I bolt it to wheels and not the floor!
01:47:11 <startling> johnw, does the I in ACID stand for "inane"?
01:47:30 <merijn> startling: :D
01:47:49 <johnw> I was hoping we'd have this conversation all over again, so I could study the subtleties I missed on the first go round
01:49:31 <bernalex> johnw: seen Primer? ;-)
01:50:24 <Axman6> I have
01:50:35 <Axman6> I need to watch it another 9 times before I'll get it though
01:50:35 <johnw> bernalex: yeah
01:51:07 <ben__> hi guys, does there exists a quickcheck test for lens laws (like the monad and functor ones)?
01:51:24 <startling> ben__: yeah, it's in the repo
01:53:00 <ben__> startling, oh yes... written by the guy that sits next to me! I really must pay more attention!
01:53:19 <startling> ben__, haha, awesome
01:53:19 <skypers__> who is skramlife?
01:53:24 <skypers__> alexander
01:53:26 <bernalex> skypers__: hi
01:53:34 <skypers__> he/she follows me on twitter
01:53:36 <startling> https://github.com/ekmett/lens/blob/master/lens-properties/src/Control/Lens/Properties.hs
01:53:38 <skypers__> oh it’s you? ok :)
01:54:59 <Axman6> i used to know someone on IRC called Skram, I think
02:08:05 * hackagebot HTF 0.11.1.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.11.1.0 (StefanWehr)
02:14:31 <jophish_> yo yo yo
02:15:29 <jophish_> In am imaginary language with Haskell's syntax, what would the neatest way of specifying the type of a list with a fixed size. Something like: [Int, 5]
02:15:50 <jophish_> But obviously this doesn't fit haskell's syntax
02:17:21 <grohne> jophish_: the Agda people just say Vec A n
02:17:21 <jophish_> Apologies for the rather vague question
02:17:24 <merijn> jophish_: The usual representation is "Vector n a" i.e. Vector 5 Int
02:19:26 <grohne> same with Coq
02:21:48 <grohne> jophish_: and indeed you can actually write something very similar using the Vec package (Data.Vec)
02:26:08 <jophish_> This is using dependent types, right?
02:27:00 <merijn> jophish_: The mentioned languages use dependent types, yeah
02:27:18 <merijn> jophish_: In haskell you can kinda fake it using DataKinds and the singletons library, but it won't be very nice
02:27:59 <jophish_> This is for my toy language. Haskell with strict evaluation and no recursion
02:28:08 <jophish_> so lists are out the window
02:28:16 <Axman6> ouch
02:28:25 <jophish_> oh, an no dynamic memory allocation
02:28:25 <Axman6> how do you do... anything?
02:29:03 <jophish_> Axman6: things like map will probably be language primitives, iterating over fixed sized arrays behind the scenes
02:29:48 <merijn> jophish_: Well, if it's your own language and everything is statically known than statically knowing the size of vectors shouldn't be hard
02:30:06 <merijn> jophish_: Dependently typed vectors are only hard when they're dynamically allocated
02:30:28 <jophish_> merijn: you mean determining the maximum size within the compiler?
02:30:59 <merijn> jophish_: Well, if it can't be dynamically allocated your compiler doesn't have to guess user input to know the array size :)
02:31:49 <grohne> jophish_: the Vec package works without dependent types
02:32:11 <merijn> grohne: He was asking for syntax for his own language, afaict
02:32:26 <jophish_> merijn: Ah, I thought you meant, the compiler would look at the code and determine on it's own  that the maximum element accessed by the code is N, and statically allocate a vector of size N.
02:32:32 <grohne> merijn: true, but that means that can use the API for the Vec package as inspiration
02:32:41 <jophish_> merijn: exectly
02:32:49 <jophish_> ghorn: I'll take a look
02:33:01 <jophish_> It would be nice to use the vec package as is actually
02:33:32 <merijn> jophish_: Well, that's similar. Essentially, the hard part with dependent types is what if your type depends on user input (i.e. you read a dependently typed vector from the network), because now the type depends on the dynamic input
02:34:00 <merijn> jophish_: If you say "no dynamic allocation of vectors" that means your compiler can statically compute and/or infer the sizes :)
02:35:23 <jophish_> merijn: hahhaha, definitely no network interface in this language
02:35:34 <drAgda> merijn: that's not actually a problem though
02:35:37 <jophish_> merijn: yeah, everything is 'allocated' upfront
02:35:55 <jophish_> I suppose I could always allocate a pool upfront and use that
02:36:04 <jophish_> but I don't think that'll be necessary
02:38:52 <merijn> drAgda: Depends on what you mean by problem
02:39:14 <merijn> drAgda: I mean by problem "it's much harder to implement correctly when writing your own toy language" :)
02:39:21 <drAgda> you can easily define functions like readVecFromNetwork :: (forall (n :: Nat). Vec a n -> IO b) -> IO b
02:39:24 <merijn> drAgda: Clearly it *can* be done, see Agda, Coq and Idriss
02:39:56 <drAgda> maybe with some constraints on a :P
02:42:29 <bernalex> I received a question: if I have an 8GB RAM computer, and need to sort a 4GB array, this should not swap/gc/be problematic in C, because you can do it in-place fastly. what's the situation in Haskell on the same hardware?
02:43:11 <johnw> do it in-place fastly
02:43:32 <bernalex> johnw: how do you do that in Haskell?
02:43:59 <Axman6> bernalex: use the ST monad
02:44:06 <bernalex> ah. thanks.
02:44:20 <Axman6> since it's definitely a pure computation,using mutation within ST is fine
02:44:20 <bernalex> would this be as space efficient?
02:44:40 <johnw> or use a mutable vector
02:44:46 <Axman6> (really, if you can the ST monad, you're guaranteed your procedure is pure, unless you use unsafeIOtoST)
02:44:49 <bernalex> e.g. how big an array could you sort this way on a 8GB RAM computer without swapping etc in haskell?
02:45:21 <Axman6> bernalex: you can use an unboxed mutable array, so maybe a handful or so more bytes than the C version
02:45:29 <greg`> ok i grok monads, i can die in peace now
02:45:37 <Axman6> greg`: are you sure?
02:45:47 <Axman6> do you get the Cont manad?
02:45:58 <greg`> the cont monad?
02:45:59 <bernalex> Axman6: is there a way I can prove this?
02:46:02 <greg`> whats that?
02:46:11 <merijn> greg`: Pop quiz: Did you think "Actually, I don't understand why people make such a fuzz about monads?"? :)
02:46:44 <greg`> merijn a bit, i understand they are useful, but they are a bit overhyped
02:46:45 <Axman6> it's the continuation monad. lets you do some funky stuff, it's also the mother of all monads (you can implement most if not all other monads using cont)
02:47:03 <Axman6> greg`: it's usually people who don't know what they are or how to use them that overhype them
02:47:05 <greg`> thing is , i tend to organise my code into pipelines of functionality
02:47:28 <Axman6> @src Cont
02:47:28 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
02:47:30 <merijn> greg`: Right, then you're on the right path to enlightenment :)
02:47:32 <greg`> they are convienient, and the way they handle a change in mondad type is sweet
02:47:48 <johnw> greg`: you'd probably love conduit :)
02:47:55 <johnw> for effectful pipelines
02:47:59 <Axman6> indeed
02:48:01 <greg`> conduit?
02:48:05 <johnw> conduit!
02:48:06 <greg`> is that a monad?
02:48:09 <johnw> in fact, it is
02:48:21 <Axman6> the stuff just added to use a difgferent base monad in each stage in the pipeline is kinda cool
02:49:34 <greg`> ill look it up
02:49:41 <greg`> thanks for your patience with me
02:49:55 <merijn> greg`: Ignore johnw, look at pipes :)
02:50:06 <johnw> greg`: https://www.fpcomplete.com/school/advanced-haskell/conduit-overview
02:50:08 <merijn> pipes is much more elegant than conduit!
02:50:16 <johnw> it's elegance is highly overrated, imho
02:50:23 <Axman6> I agree
02:50:26 <greg`> thanks
02:50:36 <Axman6> sorry Tekmo
02:50:50 <greg`> is anyone using 7.8 yet?
02:51:00 <greg`> ghc
02:51:01 <johnw> I just added a nifty function to conduit yesterday: https://github.com/wowus/stm-conduit/pull/15
02:51:02 <merijn> greg`: No, because 7.8 hasn't been released yet :)
02:51:23 <greg`> i built it from head, cant say i noticed any difference
02:51:36 <greg`> lol, but i heard it will scale better over cores
02:51:57 <johnw> greg`: I think you mean the new parallel IO manager
02:52:56 <Axman6> greg`: if you've only just groked monads, you're not likely to hit any of the benefits of 7.8 over 7.6 for a while :P
02:52:59 <greg`> probably :)
02:53:27 <greg`> anyone using the fpcomplete ide?
02:53:55 <Axman6> I've played with it, but it doesn't work well in IE 9 at work so it's not much use to me
02:54:06 <Axman6> like, it's impossible to add new files
02:54:06 <johnw> Axman6: have you reported your problems?
02:54:15 <Axman6> no
02:54:18 <johnw> please do!
02:54:23 <johnw> and we will fix them
02:54:24 <Axman6> I have work I should be doing instead :P
02:54:34 <greg`> er why are you using IE9?
02:54:51 <Axman6> johnw: I'll send you a screen shot of it if you like.
02:54:55 <johnw> sure
02:55:05 <Axman6> greg`: government agency means no browser choice
02:55:21 <Axman6> johnw: won't be until friday though, I am off work tomorrow
02:56:23 <johnw> that's fine
02:56:25 <greg`> johnw any plans to make hdevtools work with 7.8 (ive just realised who you are - greetz)
02:56:57 <johnw> I don't directly work on hdevtools, but making sure it works would be at the top of my list
02:57:47 <greg`> i guess it'll only be an issue after 7.8 is released, it doesnt look like a big fix, but i dont have the skill yet
02:57:58 <HugoDaniel> :)
02:58:06 <HugoDaniel> can i use vim sintax in the fpcomplete ide ?
02:58:16 <johnw> you mean, vim keybindings?
02:58:19 <greg`> keybindings
02:58:21 <HugoDaniel> yes
02:58:24 <johnw> I'm not sure if we have a vim mode or not, actually
02:58:24 <HugoDaniel> sorry
02:58:51 <merijn> johnw: Well, start coding!
02:59:02 <johnw> haha, that's not the part I work on, bug mgsloan!
02:59:12 <greg`> cracks the whip *whapish*
02:59:12 <tdammers> my $0.02: any implementation of vim keybindings I have ever seen outside of vim itself was kind of a disappointment
02:59:15 <HugoDaniel> ahah
02:59:41 <osfameron> tdammers: I've vaguely thought about how to implement vim keybindings a few times
02:59:47 <osfameron> it's quite complicated iirc
02:59:59 <tdammers> well, there's an awful lot of them
03:00:27 <osfameron> oh, sure.  I was just thinking about the timeouts and remappings
03:00:42 <tdammers> oh yeah
03:01:00 <tdammers> also, avoiding duplication with all those composite commands
03:01:16 <tdammers> daw, dat, dip, that kind of thing
03:01:34 <tdammers> [csxd...][ai][wtsp...]
03:01:57 <johnw> let's just compile vim with emscripten and be done with it
03:03:34 <merijn> tdammers: Don't forget the lovely "gq}"
03:03:52 <greg`> hmmm
03:04:00 <greg`> johnw, do you use org-mode babel haskell?
03:04:32 <tdammers> merijn: seldom use that one myself, actually
03:04:42 <quicksilver> merijn: "bearded man with monocle sticks tongue up in vain attempt to reach nose"?
03:04:51 <merijn> tdammers: I mostly use it for paper writing
03:04:51 <johnw> greg`: I do, but I don't run it
03:05:10 <tdammers> oh wait
03:05:13 <tdammers> I use it all the time
03:05:13 <greg`> i know that sounds like complete gibberish to most -lol
03:05:13 <greg`> disconnected!
03:05:13 <greg`> i got disconnected
03:05:14 <tdammers> lol
03:05:21 <merijn> quicksilver: relinewrap from here to end of paragraph (i.e. reflow long lines to meet maxwidth you set)
03:05:24 <greg`> can anyone hear me?
03:05:33 <tdammers> it's become second nature... didn't even realize I'm doing it
03:05:35 <johnw> greg`: speak louder
03:05:41 <merijn> tdammers: Same here :p
03:05:50 <merijn> tdammers: I have to think hard when I tell people that one :p
03:06:07 <tdammers> gq%, gq}, gqgq, <VISUAL> gq
03:06:30 <greg`> yes i set up org2blog , but running it is awful because it tries to use ghci
03:06:32 <tdammers> also, set up a good equalprg, then =%
03:06:35 <quicksilver> merijn: I prefer my interpretation :)
03:06:40 <greg`> no way to run a decent file :(
03:06:58 <tdammers> ymmv for haskell and python, but it works wonders for C
03:07:43 <merijn> tdammers: Yeah, for haskell it doesn't work too well
03:07:56 <tdammers> but for haskell, the need is much less pressing
03:08:05 <quicksilver> greg`: maybe set up http://hackage.haskell.org/package/runghc-0.1.0.1 so it gets compiled?
03:08:08 <tdammers> simply because there is not a lot of code to indent in the first place
03:08:11 <quicksilver> greg`: (I don't know, I haven't tried that)
03:08:35 <greg`> oooh thanks quicksilver i'll try that
03:11:04 <greg`> well thanks for the tips guys , speak soon
03:12:01 <Fuuzetsu> So #haskell, why haven't you switched to Yi yet? We can even do native image support: http://fuuzetsu.co.uk/images/1390387663.png
03:15:40 <greg`> another question, what exactly is put in an execution context
03:15:50 <johnw> hmm?
03:16:01 <greg`> given M a , what is a, is it data or a type
03:16:09 <johnw> a type variable
03:16:15 <quicksilver> Fuuzetsu: (1) because I have considerable expertise in programming my existing editor and a new one would have to offer really compelling advantages (2) I don't need to view photographs in my editor to program haskell.
03:16:31 <quicksilver> although my editor can in fact few photographs if I really want.
03:16:34 <quicksilver> view.
03:16:52 <johnw> yeah, mine can too.  Number of times I've used that feature in my lifetime: zero.
03:17:10 * Fuuzetsu uses image viewing in emacs all the time
03:17:12 <johnw> I've mistakenly used it by opening a JPG when I meant to open a text file
03:17:26 <quicksilver> johnw: doesn't sound like zero then :)
03:17:29 <Fuuzetsu> Anyway, the idea is that it'd be useful when working with ‘diagrams’ or something
03:17:36 <johnw> well, I wasn't *using* it
03:17:43 <jonasw> Fuuzetsu: A problem I had with it was that it won't display a file at all if it fails to parse it, making it hard to fix (unicode syntax in this case). It was also too hard for me to fix in Yi, maybe not for someone else
03:17:57 <greg`> orgmode babel dot ftw
03:17:59 <greg`> lol
03:18:13 <greg`> i'll stop gibbering in a minute
03:18:30 <Fuuzetsu> jonasw: Not sure what you mean about ‘won't display’ but yeah, I hope to fix the unicode thing as soon as I get enough time to do so
03:18:39 <johnw> greg`: #emacs would welcome your gibbering
03:19:02 <jonasw> Fuuzetsu: It just says it failed to parse, and you don't get to see the file contents at all
03:19:53 <Fuuzetsu> jonasw: That's strange, it sounds like a broken mode. Probably fixed in HEAD but what exactly were you trying to open?
03:19:56 <greg`> its just so interesting that we can talk about types within execution contexts
03:20:00 <greg`> its mental
03:20:19 <jonasw> Fuuzetsu: Just a file that used the UnicodeSyntax extension
03:20:48 <johnw> greg`: what do you mean by "execution context"?
03:20:53 <Fuuzetsu> jonasw: It will load file if you try with HEAD although you'll get highlighting problems after first unicode character. It certainly shouldn't refuse to display the content.
03:21:06 <greg`> Like a monad
03:21:09 <greg`> or a list
03:21:17 <jonasw> Fuuzetsu: That sounds great. Gonna give it another go :)
03:21:38 <Fuuzetsu> Let me know if you stumble upon any problems, we can't fix what we don't know about.
03:21:50 <greg`> a monad is a kind of execution context no?
03:21:55 <johnw> we talk about types during type checking and evaluation.  While a program executes at runtime, types pretty much don't exist
03:22:35 <johnw> a function with a type like IO Int is evaluated to yield an action which may be executed at runtime; but the types concern the evaluation, not the execution
03:22:51 <johnw> sorry, not a function, just a value of type IO Int
03:23:24 <greg`> ah
03:24:26 <johnw> in general, it's very helpful not to think about how Haskell programs are actually run, at least not until later when you have a firmer grasp on types and other aspects of Haskell-the-language.  What happens during execution is a lot more about GHC than it is about Haskell per es
03:26:35 <greg`> hmmmm so a type is a type, and although it does somehow express some pseudo execution ideas , e.g. a type that claims to yield an action
03:27:00 <johnw> right, you can't examine what an IO a really is on the inside
03:27:22 <johnw> but it's still just a value until executed by the GHC runtime
03:27:28 <johnw> a value with the type IO a
03:27:57 <greg`> yeah it doesnt have execution inside it , i understand that, ghc makes it happen
03:28:29 <greg`> im a little fuzzy on what a context actually is
03:28:35 <johnw> "context" is a fairly vague term
03:28:40 <merijn> greg`: You might be interested in: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
03:28:42 <greg`> it seems to be a type
03:28:57 <greg`> and then othertimes its kinda like a promise
03:29:03 <johnw> I'd abandon that term for now then, it has no precise meaning
03:30:31 <greg`> and then sometimes if you squint its kinda like a function
03:30:40 <johnw> a Monad is a not a container, or a context, or a computation -- it's a set of requirements that a type of kind * -> * must fulfill.  Attempts to cast it into an analogy always comes with a perceptual bias
03:31:24 <greg`> thanks for the clarification, it sounds almost like a good quote
03:31:45 <merijn> greg`: I highly recommend reading the blog post I just linked
03:31:56 <merijn> And the mandatory quote
03:31:57 <Axman6> greg`: have you seen Tony Morris' 20 intermediate haskell exercises?
03:32:01 <merijn> @quote shachaf /bin/ls
03:32:01 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
03:32:09 <tdammers> Fuuzetsu: vim is everywhere; most distros install it by default. It's pretty hard to beat that.
03:32:26 <Axman6> tdammers: vi is everywhere, vim sometimes :P
03:32:29 <greg`> no please post , im reading the blog post
03:32:52 <tdammers> Axman6: but then, vi is often just vim in compatibility mode
03:32:57 <tdammers> Axman6: fair point though
03:33:03 <Fuuzetsu> tdammers: So? I imagine most of us don't have to change the machine they're working on 30 times a day.
03:33:18 <tdammers> Fuuzetsu: well, I do
03:33:53 <tdammers> Fuuzetsu: I work on a bunch of web projects, many of them with their own development servers
03:34:07 <Axman6> greg`: http://tmorris.net/posts/20-intermediate-haskell-exercises/index.html
03:34:15 <Fuuzetsu> Well, if that works for you then sure. Personally I'd just use my editor to work remotely.
03:34:27 <Fuuzetsu> I can't imagine having to deal with vanilla settings on multiple machines.
03:34:28 <tdammers> that's not always an option
03:34:36 <Fuuzetsu> Why is it not?
03:34:47 <Axman6> greg`: it'll take you through some exercises implementing things based on their types alone. the ones at the end can be quite tricky. Feel free to ask for help here, but make sure you make it clear to people you don't want answers
03:34:51 <tdammers> well
03:35:03 <tdammers> most servers don't have samba exposed (and rightfully so)
03:35:08 <tdammers> ftpfs is a clusterfuck
03:35:22 <tdammers> sshfs, hmm, not really comfy either, especially when the connection drops out
03:35:29 <tdammers> I prefer running the editor on the server
03:35:48 <tdammers> I just push my .vimrc once and that's that
03:36:11 <Fuuzetsu> tdammers: I don't know about vim but in emacs it's pretty much transparent: no different than working locally except that when you save, the transfer happens. Unlike working directly on the server, you don't have to deal with vanilla settings and any connection latency and the server is not aware that you're even doing this, it's just a regular connection.
03:36:33 <tdammers> vim doesn't do that itself
03:36:43 <Fuuzetsu> I'm sure there's an extension.
03:36:50 <tdammers> that wouldn't be unixy
03:37:01 <Fuuzetsu> Uh…
03:37:12 <tdammers> well, that's what ssh and filesystems and such are for
03:37:22 <ethercrow> ed is pretty unixy
03:37:29 <tdammers> yeah
03:37:41 <tdammers> vim actually violates unix tradition on multiple occasions
03:37:41 <Fuuzetsu> second answer http://stackoverflow.com/questions/601532/remotely-programming
03:38:39 <tdammers> ah right, yeah... netrw...
03:38:51 <Axman6> tdammers: less than emacs though, most systems already have an operating system doing what they're supposed to :P
03:39:01 <tdammers> Axman6: yep
03:39:28 <greg`> thanks
03:41:39 <tdammers> Fuuzetsu: anyway, I'm happy the way things are
03:42:15 <tdammers> Fuuzetsu: will look into Yi though
03:44:26 <derdon> hi. could it be that putStr is lazy while putStrLn is strictly evaluated because the content must be flushed immediately?
03:44:45 <derdon> how can I flush explicitly after a putStr?
03:44:56 <johnw> neither is lazy
03:44:58 <johnw> use hFlush
03:45:14 <johnw> or set the buffering mode for stdout
03:45:27 <derdon> oh sorry, should have googled that
03:45:33 <derdon> thank you
03:45:49 <johnw> not sure that would have been easy to google for :)
03:46:00 <johnw> not until you knew the exact words, which would imply you knew the answer
03:46:17 <johnw> :t hSetBuffering
03:46:18 <lambdabot> Not in scope: `hSetBuffering'
03:46:48 <johnw> anyway, it would be hSetBuffering stdout NoBuffering, for example
03:46:52 <alpounet> NoBuffering flushes automatically right?
03:46:59 <johnw> char by char, yes
03:47:11 <johnw> actually, there is no flush
03:47:15 <johnw> the output is simply not buffered
03:48:39 <derdon> johnw: well, googling for "haskell flush putstr" gave me the correct answer as the first result (stackoverflow)
03:48:46 <johnw> oh, great!
03:49:13 <johnw> solve a man's problem, and he codes for a day; teach him how to google, and he rarely codes at all
03:56:18 <quicksilver> johnw: teach him to use emacs and he will devise enough problems to keep himself busy for the rest of his life?
03:56:34 <johnw> yak farming is the ultimate occupation
03:58:14 * hackagebot github 0.7.4 - Access to the Github API, v3.  http://hackage.haskell.org/package/github-0.7.4 (JohnWiegley)
03:59:05 <jophish_> Axman6: you asked how my toy language can do anything. It's not really for general purpose computation. It's going to be compiled down to GLSL and run on a GPU. GLSL is a C like language with no pointers or recursion.
03:59:34 <Axman6> ah, very run =)
03:59:40 <Axman6> this I can approve of
04:00:00 <Axman6> any reason for GLSL and not OpenCL or something?
04:00:07 <Axman6> do you only want to do graphics work?
04:01:51 * Axman6 -> bed
04:02:04 <Axman6> jophish_: I'd love to chat to you about that some other time =)
04:02:25 <jophish_> Axman6: sure, ping me when I'm online
04:45:34 <bitraten> is there a recommended way to add packages, which i installed in a sandbox, to my path?
04:45:35 <BoR0> @src reverse
04:45:35 <lambdabot> reverse = foldl (flip (:)) []
04:45:43 <BoR0> @src flip
04:45:44 <lambdabot> flip f x y = f y x
04:49:20 <notdan> bitraten: what do you mean by adding packages to your path?
04:49:31 <notdan> bitraten: are you talking about the executable files?
04:49:39 <bitraten> notdan: for example git-annex, yep
04:50:07 <notdan> well they are probably statically linked, so you can just copy them or add them to the $PATH variable
04:50:23 <NickKidman> What is a good introductory resource to learn haskell if you already know "all the math" math?
04:50:23 <NickKidman> People recommend "Learn yourself...", but I always get frustrated if I have the feel the author hides stuff from my because it's potentially complicated, or first brings 1000 special cases and only later discuss the abstraction.
04:50:49 <notdan> NickKidman: Real World Haskell?
04:51:07 <NickKidman> mhm, well but it looks like it's for real world applications
04:51:12 <NickKidman> (applications are disgusting)
04:51:36 <bitraten> notdan: yes, but i asked myself if there was any simpler solution, so that i don't have to do this for every package i install to a dedicated sandbox
04:51:53 <notdan> NickKidman: hm, well A Gentle Intorduction to Haskell maybe? (it's a tutorial)
04:51:56 <NickKidman> I'm more interested in theory of computation and the philosophy of math
04:52:02 <quicksilver> if you don't want anything hidden and you just want to learn the facts, how about the online report, NickKidman
04:52:13 <quicksilver> then why do you want to learn haskell?
04:52:23 <notdan> bitraten: there is not general way of doing this; you may try writing a simple bash script or whatnot
04:52:33 <NickKidman> I'd learn Agda, but then there are not people to ask questions
04:52:53 <hpc> #agda is fairly well trafficked
04:53:02 <notdan> if you are interested in theory of computation then I recommend reading textbooks dedicated to that topic
04:53:14 <NickKidman> mhm, k
04:53:24 <notdan> It's very different from learning Haskell, tbqh
04:54:03 <NickKidman> yeah, but learning about primitive recursive functions without having a language and a compiler is kinda dry
04:54:14 <notdan> you may be also interested in http://www.haskell.org/haskellwiki/Category:Theoretical_foundations
04:55:13 <NickKidman> As I said, I have a good feeling about the math side
04:56:45 <notdan> Okay... so you don't need to learn any theoretical background stuff, yet you say that you want to read something about the theory of computation
04:56:54 <ibid> NickKidman: for the theory of computation, automata models are more standard, and there are simulators for the main models.  why haskell?
04:58:19 * hackagebot simpleirc 0.3.0 - Simple IRC Library  http://hackage.haskell.org/package/simpleirc-0.3.0 (DominikPicheta)
04:58:32 <NickKidman> ibid: thought I should learn a laguage
04:59:25 <ibid> NickKidman: ok.  why not learn the language in its own habitat?  applications are a big motivator for having programming languages
04:59:46 <ibid> NickKidman: if for no other reason, think of it as ethnography of a strange tribe :)
05:02:04 <NickKidman> I'm not literally saying I don't care at all about applications, but my main motivation is understanding math and Haskell seems sufficiently pretty for doing that while still having some sort of community
05:02:36 <NickKidman> whatever, I'll look at the Learn Yourself book again
05:02:47 <notdan> maybe you'll like this http://homepages.cwi.nl/~jve/HR/
05:02:52 <quchen> Also (GHC-) Haskell is arbitrarily dependently typed if you wait long enough :-þ
05:03:08 <notdan> but again, I am not sure what are you looking for
05:03:28 <Maior> NickKidman: I come from a "wanting to build systems" angle, also having spent some time with lambda calcs, SML, etc., but loved LYAH fwiw
05:03:38 <quchen> NickKidman: LYAH is mostly about syntax if you know all the math. But "all the math" probably doesn't include the intuition on how to apply Monad, for example.
05:03:48 <Maior> NickKidman: if you really want a maths angle, not sure what to recommend I'm afraid; maybe the wiki intros?
05:03:59 <Maior> (they tend to be criticised for being a bit dry and maths-y, ime)
05:04:03 <quicksilver> I don't think you'll learn much math by learning how to program haskell.
05:04:16 <quicksilver> there is some interesting maths in the type inference
05:04:48 <quchen> Go to #haskell-lens and ask edwardk how Lenses work. You'll get your share of math ;-)
05:07:29 <NickKidman> quchen: don't you have to work?
05:11:42 <prophile> I'm having a hard time figuring out the monad instance for newtype Automonad m a = Automonad (m (a, Automonad m a)) (assuming there is one)
05:11:55 <prophile> any suggestions?
05:12:11 <prophile> (map and return are simple enough, it's join that's difficulty)
05:12:14 <prophile> *difficult
05:14:59 <notdan> prophile: assuming that 'm' is a Monad?
05:16:19 <prophile> notdan: indeed
05:16:29 <prophile> pardon my not clarifying that
05:24:01 <merijn> prophile: You don't need to define join, though?
05:24:11 <merijn> prophile: All you need is return and >>=
05:27:21 <prophile> merijn: I was writing >>= as a combination of fmap and join for convenience is all
05:27:28 <prophile> since fmap is relatively easy
05:28:03 <piezoid> hi all
05:28:10 <piezoid> i have a Parsec question :
05:28:17 <piezoid> is there a way to extract context labels (set with labels or <?>) without triggering an error ?
05:28:22 * hackagebot hOpenPGP 0.13.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.13.1 (ClintAdams)
05:28:29 <merijn> prophile: One of the main reasons Monad has >>= instead of join is that >>= is frequently easier to implement correctly than join :)
05:28:53 <piezoid> from the code it look like they are only recorded in the error closures...
05:29:16 <merijn> piezoid: What did you want to use the labels for?
05:29:18 <prophile> merijn: is that so? in that case I amend my question to 'I can't implement >>=, any suggestions?' :)
05:29:21 <benzrf> why the heck dont i have ghci if i installed haskell-platform?!
05:29:34 <benzrf> prophile: what are you trying to implement it for, and are you sure that it is possible?
05:29:40 <benzrf> prophile: have you tried implementing join instead
05:29:51 <merijn> benzrf: He just said he didn't know how to :)
05:29:59 * prophile pops
05:30:00 <piezoid> merijn: for labeling my AST, to have better error messages
05:30:19 <prophile> well, I know a very similar looking arrow has an ArrowApply instance
05:30:23 <merijn> piezoid: Why not have a special "label" node in you AST and using that?
05:30:39 <prophile> so not certain, but certainly entertaining the possibility that it can be implemented
05:31:00 <merijn> prophile: I was about to say, I'm not confident enough to say whether that type *has* a monad instance
05:31:23 <piezoid> merijn: I have nodes for SourcePos, and I want to record label context too
05:31:52 <prophile> related then: is hackage searchable for newtypes?
05:32:13 <merijn> piezoid: Can't you just define you own combinator that is similar to label but returns an annotated SourcePos (or similar)
05:32:29 <merijn> prophile: Depends what you mean by that?
05:33:20 <prophile> merijn: I mean, can hackage tell me if anything else has a newtype/data of the form data <name> m a = <constructor> m (a, <name> m a)
05:33:38 <merijn> Probably not
05:33:46 <prophile> pity
05:35:44 <prophile> interestingly it looks like streams with the Identity monad, and like ordinary lists with Maybe, I wonder if that's relevant
05:35:48 * prophile continues to delve
05:37:18 <merijn> prophile: Wait
05:37:28 <merijn> prophile: Isn't it a variation of FreeT?
05:37:46 <piezoid> merijn: yes i can, but i was trying to have a Parsec monadic action doing it for me, like i do for SourcePos using getPosition : wrap :: ASTF (Mu ASTF) -> Parser (Mu ASTF)
05:38:10 <piezoid> but yes, wrap :: Context -> ASTF (Mu ASTF) -> Parser (Mu ASTF), would not be so bad =)
05:38:15 <prophile> merijn: maybe?
05:38:23 * hackagebot modulo 1.7.2 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.7.2 (HansHoglund)
05:38:27 <prophile> it's a product rather than a coproduct so I wondered if it was a variation of CofreeT
05:38:38 <merijn> prophile: That's beyond my ken :p
05:39:23 <prophile> I've read a couple of ekmett blog posts so now I put 'co' on the front of odd words
05:41:06 <prophile> looks like it is in fact CofreeT Identity
05:42:48 <mr-> So.. Cofree
05:43:46 <prophile> mr-: no - that would be putting Identity in for the other parameter if that makes sense
05:44:22 <prophile> CofreeT f Identity a = Cofree f a, this is CofreeT Identity w a
05:47:03 <benzrf> i misread cofree as coffee
05:47:08 <benzrf> ok so why dont i have ghci if i have haskell-platform
05:47:41 <mr-> prophile: ok, I thought the order was different
05:47:55 <merijn> benzrf: Bollocksed PATH?
05:48:01 <benzrf> hm
05:48:59 <benzrf> nope
05:49:05 <benzrf> locate finds:
05:49:05 <benzrf> /usr/lib/ghc/ghci-usage.txt
05:49:06 <benzrf> /usr/share/doc/happy/html/sec-happy-ghci.html
05:49:09 <benzrf> for 'locate ghci'
05:57:32 <cdk> What would be a good data structure to represent a set of hexagonal tiles which are connected by their edges and can be rearranged in whatever way so long as the entire group remains connected?
05:57:49 <cdk> it seems very graph-like, but I'm not sure a graph would let me rearrange the tiles easily
05:59:38 <quicksilver> the right data structure depends more on access patterns than the actual model
06:00:24 <bearclaw> sometimes it's a good idea to maintain a data structure with  multiple access path. Say coord -> tile, and tile->connected_tiles
06:00:26 <quicksilver> my instinctive minimal solution is to give the tiles unique ids, store the tiles themselves in Map Id Tile, and the connection information in Map (Id,Direction) Id
06:00:48 <cdk> quicksilver: I require random access to any of the tiles
06:00:54 <quicksilver> (data Direction = N | NE | SE | S | SW | NW)
06:01:05 <merijn> cdk: Map is pretty efficient though
06:01:20 <merijn> cdk: Especially read-only like in quicksilver's example
06:01:23 <dv-> what's wrong with Array (Int,Int) Tile?
06:01:34 <merijn> dv-: Makes less sense fo hexagonal tiles
06:01:40 <quicksilver> merijn: no it doesn't
06:01:47 <quicksilver> it makes perfect sense for hexagonal tiles
06:01:58 <tdammers> hex tiles are not much different from square tiles
06:01:58 <quicksilver> as long as you agree a convention on how to number your infinite plane of hexagons
06:02:02 <merijn> Well, it depends on whether you plan to have them suqare, I guess
06:02:05 <quicksilver> it was going to be my second suggestion.
06:02:19 <tdammers> merijn: not really, no
06:02:32 <dv-> hexagonal grid <=> https://en.wikipedia.org/wiki/File:Isohedral_tiling_p4-17.png
06:02:33 <tdammers> merijn: you still number them according to a two-dimensional grid
06:02:45 <tdammers> except that every other row is shifted by one tile
06:03:23 <tdammers> and possible movement directions in the underlying square grid depend on whether you're on an even or uneven row
06:03:25 * hackagebot mmorph 1.0.2 - Monad morphisms  http://hackage.haskell.org/package/mmorph-1.0.2 (GabrielGonzalez)
06:03:28 <quicksilver> shifted by half a tile surely tdammers
06:03:38 <tdammers> yeah, half a tile
06:04:48 <merijn> tdammers: Yeah, I stand corrected :)
06:13:26 * hackagebot modulo 1.7.3 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.7.3 (HansHoglund)
06:17:18 <Sagi> if I install Cabal 1.18 using my system Cabal 1.16 package as a local user, that should result in a new cabal binary placed somewhere, right?
06:17:42 <bennofs> Sagi: you need to install 'cabal-install'
06:17:42 <Sagi> I would expect ~/.cabal/bin/cabal, but it doesn't show up.
06:17:49 <Sagi> oh :-)
06:17:54 <bennofs> Sagi: 'Cabal' is only the library
06:18:04 <Sagi> O:-) thank you
06:18:43 <aninhumer> How does MultiWayIf behave with RebindableSyntax?
06:24:13 <merijn> aninhumer: An interesting question! You should try and tell me when you find out ;)
06:26:29 <aninhumer> Yeah, trying to install GHC 7.6 now
06:26:44 <aninhumer> My guess is that it desugars to case though :/
06:27:21 <merijn> Probably
06:28:20 <Sagi> awesome. Thanks for enabling all the cabal sandbox goodness in my world bennofs :)
06:28:27 * hackagebot conduit 1.0.12 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.12 (MichaelSnoyman)
06:28:30 * hackagebot network-conduit 1.0.1.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-1.0.1.1 (MichaelSnoyman)
06:45:20 <piezoid> @pl maybeTEndo f = Endo $ (>>= \a -> fromMaybe (return a) (f a))
06:45:20 <lambdabot> maybeTEndo = Endo . (=<<) . liftM2 fromMaybe return
07:04:17 <hamid> @undo [1,2,..]
07:04:17 <lambdabot> <unknown>.hs: 1: 6:Parse error: ..
07:04:37 <hamid> @help
07:04:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:04:43 <hamid> @help undo
07:04:43 <lambdabot> undo <expr>
07:04:44 <lambdabot> Translate do notation to Monad operators.
07:05:15 <hamid> @undo [1,2..]
07:05:15 <lambdabot> [1, 2 ..]
07:05:16 <Peaker> @undo [1,2..]
07:05:16 <lambdabot> [1, 2 ..]
07:05:29 <hamid> why the same?
07:06:12 <BoR0> @undo do putStrLn "test"
07:06:13 <lambdabot> putStrLn "test"
07:07:29 <BoR0> @undo do { x <- "hi" ; return x }
07:07:30 <lambdabot> "hi" >>= \ x -> return x
07:07:48 <hamid> hmm only do expr. :/
07:08:26 <geekosaur> `@undo` only desugars do notation. [1.2..] is not do notation and is not touched
07:20:49 <prinsen> I have some questions about exceptions. I have a parser written in HXT that uses read internally for some data types. Some documents are wrongly formatted so read throws a 'no parse' exception
07:21:42 <prinsen> I wan't to catch this outside the parsing function
07:22:20 <prinsen> I have a Maybe ParsedData from the parsing function
07:23:04 <prinsen> Can i do try (evaluate Maybe ParsedData) or need I do try (evaluate ParsedData) ?
07:24:08 <c_wraith> prinsen: I'd use something other than read
07:24:25 <c_wraith> since read is the underlying source of the problem
07:24:40 <merijn> prinsen: If you're using GHC 7.6 use readMaybe from Text.Read
07:25:49 <prinsen> merijn, c_wraith: I don't know how to combine that with HXT, code inc.
07:26:01 <bennofs> prinsen: if you don't use GHC 7.6, you can use readMay from the safe package or define your own readMay
07:27:56 <prinsen> merijn, c_wraith: http://lpaste.net/98957
07:28:10 <Spacer> hello. can somebody please help me instantiate Show in a way that it's show method will be used as standard method for that type (so that I dont have to put a "class_name.show $" before every statement)? thanks
07:29:09 <prinsen> merijn, c_wraith: The problem can more generally be put, how do I handle Maybe values with HXT
07:30:20 <merijn> Spacer: I don't understand what that question means
07:31:04 <Lethalman> Spacer, haskell does not coerce types automatically, i.e. from type Foo to String
07:31:17 <merijn> Spacer: When would you ever type "class_name.show"?
07:31:24 <merijn> What is "class_name" supposed to be?
07:31:25 <Spacer> merijn: I have implemented an instance of Num and I also need the show method working like any other class has it
07:32:25 <Spacer> merijn: so in ghci for example I can type 1+1 and it implicitely uses "show $ 1+1" to print string "2"
07:32:43 <Spacer> merijn: I want that to work in my class too
07:33:24 <Lethalman> Spacer, add an instance Show for your type, like you did for Num
07:33:46 <Spacer> merijn: my show method works just fine when I use it explicitely like in "class_name.show $ myOne + myOne"
07:34:40 <colDrMcBeardman> does anyone know why cabal would stop printing the "[n of m]" build info?
07:34:46 <Spacer> Lethalman: I implemented "instance Show Nat where" with "show x = ..."
07:35:02 <colDrMcBeardman> fairly certain all i did was change jobs: $ncpus in my .cabal/config
07:35:24 <Spacer> merijn: class_name is a class name
07:35:44 <Spacer> merijn: in my case it is Nat
07:38:33 <Spacer> Lethalman: It doesn't work. any further suggestions? when I type "Zero" it shoult print "0", I get a stack overflow. when I type "Nat.show Zero" it works
07:38:57 <Lethalman> Spacer, then your function is going in loop
07:39:06 <Lethalman> or anyway it's broken
07:39:18 <Spacer> Lethalman: why does it work explicitely?
07:39:32 <Spacer> Lethalman: or other way around: why does it not work implicitely
07:39:46 <merijn> Spacer: How are you defining your Nat "class"?
07:40:04 <merijn> Spacer: I'm still confused how "Nat.show" is valid syntax at all
07:40:15 <merijn> Unless you have a Nat module with a show function in it
07:40:40 <Spacer> merijn: recursively with "data Nat = Zero | Succ Nat". yes, it's a module, at least should be
07:41:06 <merijn> Spacer: lpaste your code, because what you're saying is nonsensical
07:41:59 <Spacer> merijn: "module Nat where" "data Nat = Zero | Succ Nat"
07:42:51 <merijn> That doesn't have your definition of show
07:42:56 <merijn> @where lpaste
07:42:57 <lambdabot> http://lpaste.net/new/haskell
07:42:58 <frx> so Nat is a module, not a class
07:43:17 <merijn> And so far I see a Nat module and a Nat datatype, but no Nat class
07:45:32 <prinsen> Anyone familiar with arrows and/or HXT??
07:46:27 <ben__> prinsen, I've used it a bit
07:46:46 <prinsen> ben__: http://lpaste.net/98957
07:47:21 <prinsen> ben__: I need to change read to some safe function returning Maybe _
07:47:40 <prinsen> ben__: but I don't know how to incorporate it in the above code
07:49:14 <Spacer> merijn: lol. nevermind. i forgow a whitespace before the definition of "show x"
07:49:22 <Spacer> forgot*
07:49:31 <Spacer> bummer.
07:50:42 <ben__> prinsen, what is securityLevel?
07:51:23 <prinsen> ben__: a data type with a read instance
07:51:33 <prinsen> ben__: a string in the document
07:53:34 * hackagebot hakyll-elm 0.2.1 - Hakyll wrapper for the Elm compiler.  http://hackage.haskell.org/package/hakyll-elm-0.2.1 (maxiepoo)
07:54:31 <ben__> prinsen, just found this: http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Read.html#v:readMaybe looks like what you want (assuming GHC > 7.6)
07:55:16 <prinsen> ben__: but then how do I fail the arrow
07:55:51 <Redz> @hoogle readFile
07:55:52 <lambdabot> Prelude readFile :: FilePath -> IO String
07:55:52 <lambdabot> System.IO readFile :: FilePath -> IO String
07:55:52 <lambdabot> Data.ByteString.Lazy.Char8 readFile :: FilePath -> IO ByteString
07:58:16 <Redz> @hoogle readFileMaybe
07:58:16 <lambdabot> No results found
07:58:20 <Redz> hm.
07:59:32 <greg`> 20-Intermediate haskell exercises, Exercise 3 , I dont want the answer but can someone tell me what type fluffy is
07:59:32 <greg`> correction i mean exercise 4
08:00:23 <ben__> prinsen, if securityLevel is already a Maybe (guessing from optionalAttr)  couldn't you just to (securityLevel >>= readMaybe) instead of read `fmap` securityLevel
08:00:26 <ben__> ?
08:01:23 <prinsen> ben__: good idéa, but for the non-optional values?
08:01:29 <c_wraith> greg`: where are the problems even listed these days?
08:02:20 <c_wraith> greg`: oh, is that the one about implementing Functor for ((->) a) ?
08:03:08 <prinsen> ben__: And it's not the right behaviour, as I want the parsing to fail if the document is invalid
08:03:53 <magneticduck> quick question about openGL / GLUT for haskell...
08:04:11 <merijn> greg`: Link?
08:04:11 <greg`> http://tmorris.net/posts/20-intermediate-haskell-exercises/index.html
08:04:20 <magneticduck> if I assign a redraw callback to idleCallback.. it takes forever to move the window around the screen, and it takes up a lot of CPU
08:04:31 <magneticduck> but if I don't, the screen almost never gets redrawn
08:04:45 <magneticduck> are you supposed to put a frame rate limiter or something on?
08:04:48 <Kron> hmmm, does anyone know any haskell tutorials for ocaml programmers? Like there's a huge amount of overlap
08:04:59 <Kron> and vice versa I guess
08:05:08 <magneticduck> kind of suprised that you can't get openGL to accept a "framerate callback" to redraw the screen every certain amount of time
08:05:09 <merijn> greg`: Fluffy isn't a type
08:05:15 <magneticduck> I really have to do it myself?
08:05:23 <greg`> fluffy function
08:05:27 <merijn> greg`: Fluffy is a typeCLASS, it's defined on the first two lines
08:05:41 <greg`> sorry i mean furry
08:05:41 <davean> magneticduck: Of course you do
08:05:57 <davean> magneticduck: if you actually think about it, what you're proposing isn't completely fesable
08:06:05 <merijn> greg`: Right, so if we have "class Fluffy f where furry :: (a -> b) -> f a -> f b"
08:06:08 <davean> magneticduck: First off, drawing isn't instantanious
08:06:20 <merijn> greg`: And then "instance Fluffy (EitherLeft t)"
08:06:26 <greg`> but for Fluffy EitherLeft a b
08:06:37 <merijn> greg`: This means you should replace all occurences of 'f' with "EitherLeft t"
08:06:42 <davean> magneticduck: There are frameworks that try to approximate what you speak of
08:07:01 <magneticduck> I'm making my own actually =P so I guess I'll just make my own little framerate limiter
08:07:08 <magneticduck> but... nothing in GLUT eh?
08:07:09 <davean> magneticduck: You'll quickly find why they aren't used much
08:07:13 <merijn> greg`: Ah, but it doesn't say "instance Fluffy EitherLeft a b" it says "instance Fluffy (EitherLeft t)"
08:07:21 <magneticduck> btw, when DOES the displayCallback get called back
08:07:48 <merijn> greg`: Essentially it's making the partially applied type "EitherLeft t" an instance of Fluffy
08:07:49 <greg`> so furry :: (a -> b) -> EitherLeft t -> EitherLeft t
08:08:08 <merijn> greg`: No, only the 'f' is replaced, you're removing the 'a' and 'b' too
08:08:19 <davean> magneticduck: when the window needs to be redrawn IIRC
08:08:24 <joe9> hello, Need some help with this error, please. this is my typeclass:  http://codepad.org/fswCKCNN  , error: http://codepad.org/3KQAL4it
08:08:26 <Kron> no it'd be furry :: (a -> b) -> EitherLeft a -> EitherLeft b
08:08:30 <Kron> it's basically fmap isn't it?
08:08:31 <greg`> thanks
08:08:35 <merijn> Kron: No, that's wrong too
08:08:38 <Kron> oh is it?
08:08:46 <merijn> Kron: You dropped the 't'
08:08:53 <Kron> do correct me, now I'm confused
08:09:10 <merijn> It's "furry :: (a -> b) -> EitherLeft t a -> EitherLeft t b"
08:09:15 <merijn> Kron: Which is indeed fmap
08:09:38 <Kron> ahh, right
08:09:44 <merijn> 'f a' with 'f' replaced by 'EitherLeft t' becomes 'EitherLeft t a'
08:09:46 <Kron> forgot about the way Either worked
08:09:55 <ocharles> tomejaguar: got a sec?
08:17:42 <greg`> outside it looks like im erudite and solving haskell, inside im weeping gently
08:18:36 * hackagebot hopenpgp-tools 0.4 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.4 (ClintAdams)
08:21:34 <nh2> when I try to install parsec, I get `changes: text-1.1.0.0 -> 0.11.3.1`. How can I get cabal to tell me WHICH package wants this downgrade?
08:23:08 <JakeE> does is there a naming convention for existensial types? Say I have a type class "Annotation" and I want to return a homogenous list of items which are instances of Annotation. I need a existensial type for this I think. What should it be called?
08:23:32 <merijn> JakeE: Are you sure you want to return a homogeneous list of items?
08:23:36 <merijn> JakeE: See
08:23:41 <merijn> @where existential-antipattern
08:23:42 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
08:25:00 <JakeE> I'll read the artical and then get back to you
08:25:22 <mr-> nh2: does cabal install text-1.1.0.0 parsec yield anything useful?
08:26:01 <bennofs> nh2: maybe -v2?
08:28:50 <JakeE> merijn: I fail to see the advantage of doing it his way. Why not use Any* over his way?
08:30:23 <nh2> mr-, bennofs: will try soon
08:31:18 <merijn> JakeE: Because there's no way to do something directly with an existential/heterogeneous collection
08:31:34 <mr-> nh2: the dependency-tree, unhelpfully, only states conflict: parsec => text==0.11.3.1/installed-e38...
08:31:44 <merijn> JakeE: You will be forced to write a lot of extra code to do something useful with them, while at the same time existentials don't get you any extra features
08:32:35 <JakeE> I'll look into it. Thanks!
08:40:12 <tippenein> http://lpaste.net/98958 not sure why field is having problems with [String] . It says in the docs it does a list of any length http://hackage.haskell.org/package/postgresql-simple-0.1.3/docs/Database-PostgreSQL-Simple-FromRow.html#t:FromRow
08:42:44 <monochrom> is String an instance of FromField? is [String] an instance of FromField? String and [String] are relevant because they are used in your Document
08:43:03 <gallais> That's weird: -fno-code seems to disable the warnings about incomplete patterns
08:43:10 <monochrom> and FromField is relevant because it's a requirement of "field :: (FromField a) => ..."
08:43:54 <quicksilver> String is an instance of FromField but [String] is not.
08:43:55 <monochrom> in retrospect the error message talks exactly about that
08:44:29 <quicksilver> tippenein: what were you hoping for? are you using postgresql arrays?
08:45:04 <tippenein> quicksilver: yes
08:45:33 <quicksilver> it would appear that postgresql-simple doesn't support pg arrays
08:45:41 <tippenein> I interpreted " Instances are provided for tuples up to 10 elements and lists of any length. " as, go ahead and use [String] type
08:45:59 <quicksilver> tippenein: where did you read that?
08:46:12 <tippenein> http://hackage.haskell.org/package/postgresql-simple-0.1.3/docs/Database-PostgreSQL-Simple-FromRow.html#t:FromRow
08:46:24 <tippenein> under class FromRow documentation
08:46:25 <monochrom> yes but that is not FromField
08:46:25 <quicksilver> yes I see
08:46:33 <quicksilver> but that's about a row which has multiple string columns
08:46:44 <tippenein> oooooh, I see
08:46:49 <quicksilver> they're saying you can use fromRow to turn a row with several columns into [String]
08:46:50 <monochrom> "field :: FromField a => ..."  it does not say "field :: FromRow a => .."
08:46:53 <quicksilver> not one with array columns.
08:47:02 <quicksilver> however I do see a separate array module
08:47:09 <quicksilver> http://hackage.haskell.org/package/postgresql-simple-0.4.0.2/docs/Database-PostgreSQL-Simple-Arrays.html
08:47:30 <quicksilver> I think you'll find arrays come back as a single String (in the first instance)
08:47:51 <quicksilver> and then you use that module I just posted to parse that string
08:47:58 <quicksilver> into a proper haskell array
08:48:22 <tippenein> quicksilver: thanks, that seems do-able
08:48:29 <quicksilver> I'm only guessing from module names and docs and my knowledge of Pg
08:48:34 <quicksilver> I haven't actually used this haskell module :)
08:48:39 <joe9> can someone help me, please? I cannot figure out this error message: http://codepad.org/v4sqLHM0
08:48:42 <tippenein> have you used persistent?
08:48:53 <quicksilver> but I do know how pg sends back arrays so this seems a plausible guess
08:54:46 <bergey> joe9: The type checker is having trouble because it can't pick a specific type for the output of workspaceIdTaskSpace and the input of taskSpaceToAction.  You'll need to help it along by giving a specific type.
08:55:15 <Sagi> Why is there no equivalent of MonadReader in transformers? If I understand correctly, this requires me to write wrapper functions.
08:55:48 <joe9> bergey: this is my typeclass: http://codepad.org/5Dh42wQJ . I am trying to write a function that can use the taskSpaceToAction.
08:56:10 <joe9> Is there any way to have such a function in the typeclasse?
08:56:27 <Sagi> is it because you usually want to provide limited access to the monad stack anyway?
08:56:27 <joe9> s/have/use/
09:01:35 <quicksilver> Sagi: they're in 'mtl'
09:01:54 <quicksilver> Sagi: there is some history about how the packages evolved and the classes were always in a separate package
09:02:04 <Sagi> quicksilver: oh, are those meant to use together?
09:02:11 <quicksilver> the classes used to be in monads-fd, but now they're all folded back into mtl
09:02:14 <Sagi> I though they were 'competitors'
09:02:24 <quicksilver> they were, and transformers won
09:02:27 <Sagi> thought*
09:02:28 <bergey> joe9: It's fine to have a function f :: WorkspaceId -> X () in the type class.  A particular instance for the type T could implement f i = taskSpaceToAction (workspaceIdToTaskSpace i :: T)
09:02:29 <quicksilver> it assimilated mtl
09:02:37 <Sagi> yeah, so why is MonadReader not in transformers?
09:02:43 <quicksilver> so transformers is now the actual implementation of mlt
09:02:44 <quicksilver> mtl
09:02:55 <quicksilver> read the description here : http://hackage.haskell.org/package/monads-fd
09:03:12 <Sagi> (or equivalently, some class providing access to the relevant Monad's functionality)
09:03:53 <quicksilver> Sagi: because the classes were in monads-fd and monads-tf
09:04:00 <quicksilver> two different approaches to the classes.
09:04:50 <Sagi> I'm confused
09:05:41 <Sagi> if transformers has become more popular, what is the reason that it doesn't include classes for each of the MonadT types?
09:05:41 <quicksilver> transformers was a reimplementation of the mtl. There were two possible ways to write the typeclasses and so they were in monads-tf and monads-fd.
09:05:51 <quicksilver> because those classes are in another package
09:05:54 <quicksilver> that was the choice
09:06:08 <quicksilver> the choice was to put the classes in another package because there are two implementations of the classes.
09:06:12 <Sagi> okay, so you get to choose the flavor
09:06:22 <Sagi> thanks, I think I get you now
09:08:28 <Sagi> so for the classes, I have the choice of using either mtl or monads-tf
09:08:40 <joe9> bergey: thanks.
09:08:43 * Sagi checks popularity
09:10:46 <statusfailed> Is there a simple http server package on cabal?
09:10:48 * Sagi finds https://stackoverflow.com/questions/5797091/monad-transformers-libraries-which-one-to-use
09:11:09 <statusfailed> I need to serve files in the current dir on a given port
09:12:09 <Maior> statusfailed: I can't help but want to suggest `python -m SimpleHTTPServer` without more context
09:13:25 <joe9> bergey, please excuse me if i did not understand you. this is my type class: http://codepad.org/STwDphCH and this is the error:  http://codepad.org/gAeH5NVJ
09:14:57 <dwcook> joe9, the type variable a must appear in the type of every method.
09:15:08 <joe9>  bergey, when I do this: http://codepad.org/Kv3gteX2 , i get the error : http://codepad.org/tQLv3qdm
09:15:11 <dwcook> Otherwise, how would you know which one to use?
09:15:14 <mm_freak_> statusfailed: happstack-server can do that
09:15:22 <mm_freak_> statusfailed: including directory listings, if you need them
09:15:29 <statusfailed> Maior: Actually i'm having problems using that which I can't pin down
09:15:38 <statusfailed> I just want to try something else to see if they go away
09:15:42 <bergey> joe9: My fault, what I told you doesn't work.  It's as dwcook says.
09:15:44 <statusfailed> mm_freak_: cool, will look into it, thanks :)
09:15:45 <mm_freak_> statusfailed: see Happstack.Server.FileServe
09:16:08 <ademidov> statusfailed: look at http://hackage.haskell.org/package/warp-static
09:17:05 <joe9> dwcook: I understand that. I am trying to write a function of  workspaceIdAction :: WorkspaceId -> X (), and this is my typeclass:  http://codepad.org/voXa2jPx .
09:17:18 <joe9> Is there any way to do have the above function in the typeclass?
09:17:30 <matxyz> @pl transform k z = reverse (foldr (\x y -> y ++ [fst(head(filter (\a -> snd a == k-1) (zip x [0..])))]) [] z)
09:17:31 <lambdabot> transform = (reverse .) . flip foldr [] . (flip (++) .) . flip flip [] . (((:) . fst . head) .) . (. flip zip [0..]) . filter . (. snd) . (==) . subtract 1
09:17:31 <dwcook> joe9, no, there isn't.
09:18:53 <magneticduck> question: is there a way of getting GHCi to "expand" a type?
09:18:56 <joe9> dwcook: no extension that could help me?
09:19:09 <bennofs> magneticduck: :kind! expands types, iirc
09:19:19 <magneticduck> like :<??> String would return [Char]
09:19:36 <magneticduck> huh
09:19:36 <dwcook> joe9, not that I'm aware of. I think you've run into a conceptual problem. Why do you want a method with that type?
09:19:41 <magneticduck> yeah, that does the trick bennofs
09:21:01 <jle`> huh that's a neat trick
09:21:12 <joelteon> interesting
09:21:22 <joelteon> :kind! exists but :k! doesn't
09:21:53 <platz> regarding transformers, are the any good articles that explain how to choose between things like "ReaderT (Mvar Env) IO a" vs "StateT Env IO a"
09:22:41 <quicksilver> choose the latter because it's simpler; choose the former if you have multiple simultaneous IO threads mutating the same environment.
09:22:53 <dwcook> platz, I imagine you'd use the same reasons for wanting a mutable variable in general. e.g., if thread intercommunication is involved.
09:22:54 <joelteon> if you multiple threads mutating the same environment, use concurrent-state
09:23:01 <jle`> platz: i'm not sure how your question generalizes enough to suggest an article
09:23:11 <jle`> what are "things like..."?
09:23:13 <jle`> (that)
09:23:30 <jle`> s/to /to be able to /
09:24:06 <platz> jle`: fair enough.  I have a habit of just wonder aloud sometimes without knowing why.
09:24:22 <statusfailed> ademidov: perfect!! works like a charm- and not slow :)
09:24:28 <magneticduck> havin' a problem with GLUT in haskell, resizing the windows I'm making takes forever!
09:24:34 <platz> I think because i saw a comment from someone saying since you're already in IO, you might as well just use the readert
09:24:34 <magneticduck> but moving them around the desktop doesn't
09:24:37 <statusfailed> mm_freak_: thanks also for the suggestion, warp looked easier though :)
09:25:03 <statusfailed> I wonder why SimpleHTTPServer was so slow?
09:25:15 <platz> but i could see that state might be simpler in a single threaded environment
09:25:17 <dwcook> platz, for single-threaded programs you can easily get away with that, yeah.
09:25:33 <mm_freak_> statusfailed: simpleHTTP nullConf (serveDirectory EnableBrowsing ["index.html"] "/my/directory")
09:25:48 <dwcook> Well, reader versus state is a matter of how/whether you want to pass on changes.
09:26:20 <dwcook> Remember that Reader a b is like a -> b and State a b is like a -> (b, a).
09:26:25 <monochrom> ah, but it's "Reader (MVar X)" vs "State X"
09:26:39 <magneticduck> anybody have any idea why the windows I'm makin with GLUT / openGL take so long to resize?
09:26:53 <mm_freak_> often, when you think you want MVar X or State X you really want Behavior X =)
09:26:59 <monochrom> or, for a more interesting, less clear-cut variation, "Reader (IORef X)" vs "State X"
09:27:12 <joe9> dwcook:  thanks.
09:27:43 <monochrom> but I guess "Behavior X" wins
09:27:52 <monochrom> and it should have been "Behaviour X"!
09:28:07 <mm_freak_> =)
09:28:33 <dwcook> The names of things are heavily biased towards American English in programming. :P
09:28:37 <monochrom> for example a program that keeps changing colour should be "Behaviour Colour", not "Behavior Color"!
09:29:18 <jle`> it would be interesting if both existed
09:29:19 <statusfailed> mm_freak_: I was looking for a binary i could just run out of the box- easier to install on a new machine
09:29:28 <dwcook> Why don't we localize Haskell? Make it so all the constructs make sense in your own language, be it English or Spanish or German or whatnot?
09:29:35 <mm_freak_> jle`: no problem:  type Behavior = Behaviour
09:29:40 <jle`> and....were different
09:29:44 <platz> monochrom: where Behavior X is a custom monad instead of a transformer?
09:29:46 * monochrom wants Chinese! :)
09:29:49 <mm_freak_> statusfailed: ah, i thought you need a library
09:30:14 <mm_freak_> platz: Behavior is a term from FRP
09:30:17 <jle`> if you just want a quick simple http setup, most ubuntu distros come with a python simplehttp
09:30:20 <mm_freak_> (Functional Reactive Programming)
09:30:40 <platz> ahh, i'll have to look into Behavior sometime
09:31:16 <mm_freak_> platz: you'll need to look into FRP then, because Behavior is not self-contained
09:31:51 <dwcook> mm_freak_, I misread that at first and wondered why you were trying to write a non-terminating type function
09:32:00 <platz> i see thanks
09:32:08 <dwcook> Type binding*
09:32:41 <mm_freak_> =)
09:33:43 * hackagebot htsn 0.0.5 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.0.5 (MichaelOrlitzky)
09:34:27 <nstdloop> What's the name of the type restriction everyone points out as the weirdest thing in Haskell (at least by name)?
09:34:30 <nstdloop> It's quite long
09:34:38 <Twey> The monomrphism restriction?
09:34:39 <dwcook> nstdloop, you mean the monomorphism restriction?
09:34:43 <nstdloop> No
09:34:44 <dwcook> Dang, ninja'd
09:34:46 <Twey> monomorphism**
09:34:49 <nstdloop> It's longer and more obscure than that
09:34:50 <Twey> Typo'd :þ
09:35:04 <mm_freak_> nstdloop: the dreaded monomorphism restriction?
09:35:11 <dwcook> That must be it
09:35:17 <Twey> Heh
09:35:21 <nstdloop> It's not. I'm sure.
09:35:27 <dwcook> Kidding, kidding
09:35:32 <nstdloop> It has like a 10 line article on haskell.org
09:35:40 <mm_freak_> nstdloop: you need to give us a hint…  there are many type restrictions
09:35:58 <mm_freak_> some of them may appear weird, until you understand them
09:36:07 <nstdloop> mm_freak_: I would if I could.. I've been reading through haskell.org for the last 20 minutes.
09:36:21 <jle`> how about the *pleasant* monomorphism restriction?
09:36:28 <nstdloop> I think it starts with a z
09:36:31 <nstdloop> but I could be wrong
09:36:39 <mm_freak_> nstdloop: is it an annoyance or does it allow some interesting patterns/guarantees?
09:36:40 <dwcook> You are thinking of something not to do with types, I think
09:36:45 <dwcook> zygo- something or other
09:36:49 <nstdloop> Yes
09:36:50 <jle`> ze dreaded
09:37:03 <nstdloop> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
09:37:05 <mm_freak_> zygomorphism restriction =)
09:37:09 <nstdloop> zygo was the hint I needed
09:37:11 <nstdloop> thanks
09:37:27 <Twey> Thet's not a restriction!
09:37:34 <nstdloop> You're right.
09:37:39 <nstdloop> I couldn't really remember what it was
09:37:40 <dwcook> That's actually what came to mind besides "monomorphism restriction" but your other requirement killed that possibility
09:37:53 <nstdloop> haha
09:37:55 <Twey> Aye.  That's cheating.  :<
09:38:15 <nstdloop> I remembered "morphisms" -> "polymorphism" -> "restriction/types"
09:38:48 <mm_freak_> nstdloop: again
09:38:51 <mm_freak_> nstdloop: is it an annoyance or does it allow some interesting patterns/guarantees?
09:38:58 <nstdloop> I found it.
09:38:59 <nstdloop> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
09:39:00 <dwcook> Now I'm imagining a search filter program that uses context and goes "Are you suuuuure you meant to add that filter?"
09:39:03 <nstdloop> It's neither.
09:39:33 <nstdloop> I felt I should add some kind of quantification to "what's this weird thing called?"
09:39:43 <nstdloop> qualification*
09:40:06 <mm_freak_> ∃ (thing : WeirdThings). (thing, nameOf thing)
09:40:37 <dwcook> Ha
09:41:19 <Baughn> mm_freak_: Error: IRC is not an instance of CommunicationChannelWithThingTransferalAbility. Suggested solution: Create an instance for type IRC.
09:41:48 <mm_freak_> Baughn: what's IRC?
09:42:23 <Baughn> mm_freak_: I'll just ignore that.
09:42:52 <mm_freak_> Baughn: why?  i can't write an instance without knowing the kind and semantics of IRC
09:43:24 <Baughn> mm_freak_: You're meant to know, automatically.
09:43:42 <mm_freak_> hmm
09:44:03 <dwcook> Type definition inference? Is that a thing?
09:44:04 <mm_freak_> i may be so used to FRP that i lost my ability to represent state monadically =)
09:44:15 <mm_freak_> dwcook: unlikely
09:44:56 <dwcook> I'm reminded of the types in OCaml that you can make up on the spot, I forget what they're called
09:46:05 <companion_cube> there are polymorphic variants
09:46:16 <companion_cube> and objects defined without classes
09:46:50 <dwcook> I believe I was referring to polymorphic variants
09:47:58 <cdk> is it possible to hide reimported modules of a module? For example, I want Control.Lens but not Control.Lens.Tuple
09:48:42 <dwcook> cdk, not quite what you asked, but you could import qualified or just import the bindings you need
09:49:07 <mm_freak_> cdk: if at all it probably looks like this:  import X hiding (module Y)
09:49:19 <mm_freak_> cdk: but i don't know whether that's valid syntax
09:49:50 <k00mi> just tried, it isn't
09:50:55 <mm_freak_> i guess there is no such way…  to the importing module it looks as if everything from Y is exported from X
09:51:02 <mm_freak_> so you need to hide stuff from X
09:52:23 <mm_freak_> and yes, Control.Lens uses up the whole namespace…  you should probably just import individual modules
09:53:01 <mm_freak_> http://ro-che.info/ccc/23
09:53:03 <edwardk> not everyone likes the style of lens ;)
09:53:35 <geekosaur> Control.Everything
09:53:41 <edwardk> hah
09:53:50 <edwardk> that'd be a good automation framework name
09:54:13 <edwardk> also need a good excuse for Control.Mind
09:54:32 <bennofs> edwardk: where's that?
09:55:03 <mm_freak_> System.AM
09:55:08 <edwardk> just looking for good puns involving control after geekosaur's comment, but that one being backwards is less fun
09:56:10 <bennofs> Control.It :)
09:56:26 <mm_freak_> i always thought that lens enables you to see things you've never seen before
09:56:29 <mm_freak_> Control.Lens.Matrix
09:56:32 <edwardk> iven that i already _have_ a monad named It that could work =)
09:56:57 <edwardk> It isn't quite an Iteratee
09:58:17 <mm_freak_> "you take the (bluePill :: a -> ()), the story ends"
09:58:36 <mm_freak_> "you take the (redPill :: Lens' Matrix RealWorld), you stay in wonderland"
09:58:46 * hackagebot concurrent-state 0.3.1.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.3.1.0 (JoelTaylor)
10:01:02 <manek> Hello! How would you code such monadic foldr in Haskell: m (a -> b -> b) -> m b ->  [m b] -> m b ? I was trying to figure out how to combine some functions but without success :(
10:01:25 <manek> Oh, there should be m (a -> b -> b) -> m b ->  [m a] -> m b
10:01:45 <edwardk> manek: i'd recommend choosing (a -> b -> m b) -> m b -> [b] -> m b  for the type instead
10:02:03 <edwardk> :t Data.Foldable.foldrM
10:02:07 <haasn> much stronger!
10:02:07 <lambdabot> (Monad m, Foldable t) => (a -> b -> m b) -> b -> t a -> m b
10:02:16 <edwardk> even stronger still
10:02:31 <edwardk> er and that should be [a]
10:02:43 <manek> edwardk: Thank you :)
10:03:02 <edwardk> you can make the base case monadically before passing it in, so that doesn't need the 'm' either.
10:03:32 <mm_freak_> manek: very often regular foldr will be what you really need
10:03:45 <mm_freak_> manek: including in the case of a list of monadic values
10:03:46 * hackagebot concurrent-state 0.3.1.1 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.3.1.1 (JoelTaylor)
10:04:07 <manek> mm_freak_: what do you mean ? how foldr would be suitable here?
10:04:18 <mm_freak_> manek: i don't know what you're trying to do
10:04:34 <mm_freak_> manek: but here is an example:
10:04:40 <mm_freak_> :t foldr (>>) (return ())
10:04:41 <lambdabot> Monad m => [m a] -> m ()
10:05:04 <manek> mm_freak_: right. Hmm, I have to check something
10:05:09 <manek> mm_freak_: brb
10:13:47 * hackagebot modulo 1.7.4 - Modular C code generator  http://hackage.haskell.org/package/modulo-1.7.4 (HansHoglund)
10:18:47 * hackagebot structured-haskell-mode 1.0.2 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.2 (ChrisDone)
10:20:32 <skypers> hi
10:32:24 <manek> mm_freak_, edwardk: hm, its not straightforward I think. Look, I'm wriitng a parser - I've got a function in monadp arser m (a -> b -> b) , starting value  m b  and a list of values from parser m [b] I'm looking for such foldrlike function m (a -> b -> b) -> m b ->  m [b] -> m b (there was a mistae before)
10:34:49 <manek> edwardk, mm_freak_: the function in monad parser is determined by few factors. I've got function (g :: id -> a -> b -> b) and (mkid :: (id ->f) -> m f) . So the function f = mkid g has a signature of m (a -> b -> b).
10:40:23 <jle`> manek: from your type signature it sounds very applicative
10:41:16 <jle`> is your m (a -> b -> b) "executed" only once?
10:41:37 <jle`> or is it re-"executed" (to get a new function and also to parse/execute the monadic action) every iteration?
10:42:27 <frege> > "hello" ++ " world"
10:42:30 <lambdabot>  "hello world"
10:42:34 <jle`> remember that if you don't have anything of the form ( a -> m b ) (a function that takes something pure and turns it into something monadic), it is probably applicative
10:42:44 <jle`> or functor even
10:42:52 <manek> jle`: No it should be something like foldr. So the m ( a -> b -> b) sohuld be folded over all m [b]
10:43:20 <jle`> so the m (a -> b -> b) is only executed once?
10:43:55 <levi> Is there an alternative to highlighting-kate that does a reasonable job at Haskell syntax?
10:44:30 <dwcook> manek, are you sure you didn't mean m [a]?
10:44:41 <dwcook> Otherwise you don't get an a from anywhere
10:45:00 <manek> dwcook: of course m [a], sorry
10:45:05 <rtpg> if I erase my .cabal, will that take all the packages with it (letting me reinstall everything with profiling without having to do dependeny managment)?
10:45:10 <dwcook> If you make that change then it looks just like a foldr where every parameter and the result are inside a monad
10:45:32 <manek> Of course I mean m (a -> b -> b) -> m b ->  m [a] -> m b
10:45:42 <jle`> if the function and the accumulator is just 'inside' a monad
10:45:48 <jle`> is ther eany reason why you can't bind them
10:45:51 <jle`> outside of your fold?
10:46:22 <dwcook> It would be straightforward to write it like this: myFold cons null list = do { cons <- cons ; null <- null ; list <- list ; return (foldr cons null list) }
10:46:31 <dwcook> Though you're perhaps looking for something prettier
10:46:50 <jle`> the type signature of m (a -> b -> c) implies that you are executing a monadic action and returning a pure function as the result
10:46:50 <manek> dwcook: exactly - I want something prettier :)
10:47:08 <timthelion> In haskell-mode(emacs) is it possible to "colapse functions" like in org mode?
10:47:21 <manek> jle`: The function is result of parser action - m is in real ParsecT something
10:47:26 <Baughn> Prelude.sum still causes stack overflows?
10:47:28 <jle`> manek: and it's only parsed once?
10:47:51 <jle`> so it's possible to pre-bind?
10:47:55 <dwcook> In fact come to think of it I think you only need Applicative for that
10:47:59 <jle`> yeah
10:48:04 <jle`> if you want to do dwcook's answer
10:48:05 <jle`> you can just do
10:48:18 <jle`> foldr <$> f <*> init <*> list
10:48:38 <jle`> this is the case if f, init, and list are all pure values
10:48:43 <jle`> that are the result of monadic actions
10:48:55 <jle`> executed only once
10:49:00 <manek> jle`: No, It is not even parsed. It is a little more complicated - I descirbed it above. There is a basic function g :: id -> a -> b -> b and a function, which passes each time differend id: mkid :: (id -> f) -> m f
10:49:33 <geekosaur> timthelion: there are minor modes that add that to any major mode, see hs-minor-mode
10:49:36 <manek> jle`: The basic function (m (a->b->b)) is just (mkid g) AND it should be "parsed" each time fold is made to make different ids
10:49:57 <geekosaur> there's also a folding-mode which is a more complex add-on
10:50:12 <jle`> so the function is parsed
10:50:20 <jle`> a new pure function is parsed at every step?
10:50:42 <timthelion> geekosaur: thankyou!
10:51:38 <jle`> so at every step
10:51:41 <jle`> you want to
10:51:50 <timthelion> geekosaur: man C-c @ C-h what a freekish key combo, no wonder there's the joke about "emacs hand" being an illness
10:51:50 <jle`> parse a function
10:51:53 <jle`> and then apply it?
10:51:54 <manek> jle`: Lets call the function "f", So "f :: m (a->b->b)" is just "g" (g :: id -> a -> b -> b) with applied id to it. But I want this id to be different eacj time, so when I'm making this fold - it should result in as many different ids as the elements in list
10:52:03 <jle`> becuase m [b] is executed/parsed once
10:52:04 <geekosaur> yeh, I'm not fond of the bindings
10:52:10 <manek> jle`: So yes, I want at every step parse it and apply
10:52:31 <jle`> and the id's come from the parse?
10:52:47 <jfischoff> is there an easy way to compare your installed packages with Hackage and list the out of date ones?
10:52:54 <jle`> your m [a] is only parsed once, right? not every way along your fold
10:53:01 <jle`> and so is your m b
10:53:08 <jle`> (initial accumulator)
10:53:13 <jle`> it is only your function that is re-parsed at every step
10:53:27 <manek> jle`: yes, look, the "mkid" function has a signature "mkdif :: (id -> f) -> m f" - so parser applies unique id to its argument. So "f" i just (f = mkid g)
10:54:09 <jle`> just clarifying that m b, m [a] are only parsed once.
10:54:14 <jle`> hm
10:54:48 <manek> jle`: Yes, only once of course :)
10:55:26 <timthelion> geekosaur: I'm just so afraid, that if I start customizing emacs I'll never be satisfied and I'll end up with a 200mb .emacs file and nothing else done :/
10:55:41 <geekosaur> that is the danger, yes :)
10:55:48 <colDrMcBeardman> timthelion, try using sam
10:56:57 <jle`> i guess what you can do
10:56:59 <jle`> is replicateM
10:57:02 <jle`> your function
10:57:09 <jle`> once for every element in your [a]
10:57:28 <timthelion> colDrMcBeardman: is that what you use?
10:57:34 <manek> and then sequence?
10:57:46 <jle`> no replicateM will get you [a -> b -> b]
10:57:48 <colDrMcBeardman> yes. it's like ed, but with a mouse.
10:57:54 <jle`> well
10:57:57 <jle`> m [a -> b -> b]
10:58:02 <jle`> replicateM is like a sequence
10:58:04 <jle`> @src replicateM
10:58:04 <lambdabot> replicateM n x = sequence (replicate n x)
10:58:05 <colDrMcBeardman> it will cure you of any desire to extend your editor :-P
10:58:22 <timthelion> colDrMcBeardman: OMG, a mouse!  I thought those things only worked with xeorox machines, I can't afford one of those!
10:58:35 <jle`> so that'll get you your list of every f
10:58:48 <jle`> as a result of the parse
10:58:56 <jle`> and then you have b and [a] already bound ...and
10:59:01 <jle`> some kind of zipping goes on here
10:59:07 <jle`> i'm sorry, i'm not sure if i can get it any prettier than that
10:59:18 <manek> jle`: Wait, how would you like to use it?> I want to get as a result a single value, not list of it - It should just work as foldr here
10:59:30 <jle`> well you don't have something similar to foldr
10:59:35 <jle`> because at every step
10:59:37 <jle`> you have a new function
10:59:40 <jle`> a new folding function
10:59:57 <jle`> so it isn't quite similar to foldr...it sounds more like some kind of zip
11:01:02 <jle`> so then your final result is the end of one of those lists
11:01:30 <manek> jle`: Hmm, ok, I'll try to make it, brb
11:01:38 <jle`> sorry, it's not quite ideal
11:01:47 <jle`> and it's kind of ugly...but not sure how else to make sense of it
11:01:57 <jle`> in this case the explicit recursion might be the simplest actually.
11:02:34 <jle`> the main thing is that you have a new zipping function every time so i don't think a foldr is what you are looking for
11:02:39 <jle`> *new folding fucntion
11:07:52 <saml> is compiler turing complete?
11:07:55 <asdacmn> Is there a way to specify non-Haskell dependencies in a .cabal file?
11:07:57 <manek> jle`: Hmm, ok, thank you. I will think about it. I do not want to move over monadic parser, because I want to keep it in applicative way (to be able to port over librarieslike uu-parsinglib in the future)
11:08:01 <jle`> asdacmn: other deps
11:08:22 <dcoutts> asdacmn: yes, foreign libs and build tools
11:08:22 <jle`> manek: zip your [a->b->b] and your [a]
11:08:42 <jle`> and then foldr on the [(a->b->b,a)]
11:08:53 <jle`> this is...non-monadic
11:09:03 <manek> jle`: I'll do it - I want just to see if there is not better way - maybbe by just refactoring some combinators :) thank you
11:09:12 <alkabetz> saml: It makes no sense to call a compiler Turing-complete.  Only a language can be Turing-complete.  Can you rephrase your question?
11:09:23 <jle`> this is still non-monadic and applicative, btw
11:09:27 <companion_cube> well, it makes sense for C++ templates
11:09:34 <manek> jle`: You are right of course
11:09:37 <jle`> hm
11:09:49 <companion_cube> the compiler is an interpreter for a Turing-complete language (the templates)
11:09:59 <manek> jle`: Sorry - I was just thinking about different solutions and my sentence about the monadic parsers was just a little of topic
11:10:07 <jle`> don't worry about it
11:10:10 <jle`> hm
11:10:13 <jle`> there might be a way to do this in applicative style
11:10:18 <alkabetz> companion_cube: Sure, but the compiler is not Turing-complete; the template language is.
11:10:23 <jle`> but it'll be something like
11:10:43 <yogurt_truck> ffs
11:10:45 <jle`> (\something -> something) <$> f <*> b <*> as
11:11:02 <jle`> wait, no
11:11:08 <yogurt_truck> in the past 2 days, cabal-install has gone from "simple tool that often works" to "incompetent tool that I will now avoid at all costs" in my mind
11:11:19 <jle`> reah, you can' do it that way.
11:11:22 <jle`> *yeah
11:11:33 <jle`> good luck though with the refactor and come back here when smarter people than me are around :)
11:11:59 <jle`> well
11:12:04 <jle`> smarter people who are free to help
11:14:12 <dwcook> jle`, fyi, id <$> f = f
11:14:37 <manek> jle`: Heh, thank you for your help :)
11:14:40 <asdacmn> dcoutts: according to the manual, 'build-tools' should be used for programs that are needed to build the package.  is it fine to use it for executables that the package calls?
11:16:07 <asdacmn> my haskell program is a script, basically
11:23:52 * hackagebot yesod-form 1.3.4.4 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.4.4 (MichaelSnoyman)
11:26:45 <felix89> hi!
11:26:55 <asdacmn> jle`: I can't find anything similar to "other deps".  Are you talking about 'other-modules'?  If so, it's not the thing I'm looking for.
11:27:23 <jfischoff> hi felix89
11:28:20 <bitemyapp> in the case of Lens, if I use it to modify a nested record and return the new overall result, what happened at a lower level? did a reference to repointed to a fresh copy? is there any structural sharing?
11:28:21 <felix89> I am puzzled why this does not work: http://pastebin.com/MDE1hVBm
11:28:54 <felix89> I can call foldr in main just fine, but in my len' function, I get a compiler error
11:28:55 <jle`> asdacmn: sorry, i think had some sort of memory failure...and also I don't think that's what you want.  i remember a field to specify non-hs files that are in your package
11:28:57 <shachaf> The same thing happens that would happen without lens.
11:29:18 <jle`> bitemyapp: lens isn't magic, it is just a shorthand for record accessors and stuff
11:29:22 <bitemyapp> shachaf: whole-copy of the record gets returned by the expression?
11:29:26 <felix89> It says "No instance for (Num a) arising from a use of '+'"
11:29:39 <bitemyapp> jle`: I know, it's just the context for trying to understand the underlying behavior.
11:29:54 <jle`> ah
11:30:07 <jle`> well the answer is a little complicated in a lazy language like haskell
11:30:20 <asdacmn> jle`: No worries.
11:31:03 <jle`> in a strict language, any modification of any nested record field requires allocation of a completely new record "tree" parent nodes (but not siblings, aunts, cousins, etc.)
11:31:10 <etandel> felix89: you can either specify the full type for your function or don't specify it at all. But if you do, you have to put your constraints yourself, so if you use "show" you have to put "Show a=>", if you use "+" you have to put "Num a=>" etc.
11:31:13 <jle`> in a lazy language like Haskell....it really depends on the context
11:32:08 <jle`> if you never asked for the "old" nested record as a whole (ie, printed it all out), then the runtime might be able to get away with never modifying/reallocating/destroying anything at all
11:33:25 <etandel> in this case, you probably want Integral b => [a] -> b.
11:33:29 <bitemyapp> jle`: thank you, very helpful.
11:33:34 <jle`> but in the case of completely strict behavior...all 'branches' parent of the modified field must be recreated, but the siblings are shared.  but that is rarely the case in Haskell
11:34:08 <jle`> actually...i'm not sure if the compiler/run time system ever does any reference repointing if it notices it is possible.
11:34:18 <jle`> i think it relies on garbage collection
11:34:23 <triliyn> jle`: I think it's not strictness/laziness that does this, but the possibility of side effects
11:34:37 <felix89> etandel: I specify that inline in my lambda expression?
11:34:41 <clahey> Does anyone here know sigc well?
11:34:43 <triliyn> or well, never mind, laziness does help because you can do some of the work later
11:34:50 <etandel> felix89: no, on the type signature of len'
11:35:03 <felix89> but it should not take b as a paramter
11:35:06 <felix89> a
11:35:08 <jle`> it might help to consider (++)
11:35:08 <etandel> len' :: Integral b => [a] -> b
11:35:12 <felix89> I see
11:35:16 <felix89> true!
11:35:26 <jle`> (++) is commonly cited as an 'expensive' operation
11:35:32 <clahey> Specifically, I'm looking for something similar to >> where sigc::compose is similar to >>=.
11:35:40 <jle`> and in a strict language, it is usually O(n) of the left side list
11:35:54 <jle`> becuase it has to completely destroy and re-create the left side
11:35:58 <felix89> etandel: Thanks so much
11:36:14 <etandel> By that you'd be saying to the compiler "this function len' takes a list of a's (whatever that may be) and returns a type that is an integral (usually either Int or Integer)".
11:36:15 <jle`> but in Haskell, this is rarely what actually happens
11:36:21 <etandel> felix89: you're welcome =)
11:36:38 <jle`> fsov rarely :)
11:36:50 <jle`> s/fsov/fsvo
11:39:14 <Twey> jle`: It's still O(n) — it doesn't evaluate the elements of the LHS, but the spine is still n long
11:39:54 <Twey> It just has a smaller constant ☺
11:39:56 <enthropy> or maybe every operation that is lazy is O(1) to jle?
11:40:09 <Twey> Heh
11:40:19 <Twey> > let x = x in 3 -- infinite computation in constant time!
11:40:20 <jle`> i made a conceptual mistake v.v i will rethink my life now
11:40:22 <lambdabot>  3
11:40:37 <jle`> i'm not even...sure what i was triyng to say anymore
11:40:55 <Twey> Hehe
11:41:16 <Taneb> Any alternative to MissingPy?
11:41:47 <jle`> hm
11:41:50 <jle`> something like
11:42:01 <jle`> > take 3 $ [1..10] ++ [11..20]
11:42:03 <lambdabot>  [1,2,3]
11:42:11 <jle`> maybe tha'ts what i meant
11:42:20 <Twey> Aha
11:42:40 <jle`> if you are strict, it's O(n)
11:42:47 <jle`> but in the case of Haskell it depends on the context of when you need it
11:43:18 <jle`> so it is hard to meaningfully reason about things like this in a vacuum
11:43:40 <jle`> also i'm late for class
11:44:00 <ademidov1> big-o is about worst case scenario
11:44:08 <ademidov1> and worst case is still O(n)
11:45:51 <jle`> i'm...not sure that that's what 'worst case' usually means when referring to big O. but i might be wrong
11:46:44 <Twey> jle`: We usually talk about the relative eventual cost of evaluating the whole thing in Haskell, since obviously everything else is constant
11:46:51 <chirpsalot> O(n) isn't necessarily worst case -- it could be even worse than that. It's just an upper bound.
11:47:03 <monochrom> you are right jle`, big O does not have to talk about worst case, and worst case does not have to talk about big O
11:47:19 <jle`> Twey: ah.  that's fair
11:47:31 <nstdloop> You can talk about "worst case" big O or you can talk about "average" big O
11:47:58 <monochrom> big O helps you classify functions. and you can use it to classify functions about worst cases, or functions about best cases, or functions not even about computers
11:48:01 <nstdloop> Like quicksort is O(nlogn) on *average* but O(n^2) in the worst case. There's nothing inherent about Big O
11:48:47 <monochrom> "big O is about worst cases" is similar to "paper is about writing". clearly you can use paper for whatever you please, and it does not have to be writing. you can wipe, for example.
11:48:59 <Hafydd> big O can be used to talk about things outside of software engineering? Now you're straining my credulity.
11:49:09 <jle`> well...yeah i see that it makes sense to normally talk about the cost of full evaluation. in this context though it might be relevant to mention the case of non-full evaluation as well
11:49:29 <nstdloop> big O is just a way to estimate
11:49:35 <jle`> besides, in many contexts knowing the cost of full evaluation is...pretty useless
11:49:43 <Twey> Eh… big-O notation is a well-defined mathematical construct
11:49:43 <jle`> in Haskell
11:50:02 <silasm> Hafydd: big O(f(n)) is just the set of functions upper-bounded by some multiple f(n) past some input constant c
11:50:10 <Twey> Amortized cost is technically an abuse, albeit a useful one
11:50:28 <monochrom> yeah, I speak of "the cost of take n (longlong ++ [i])" rather than "the cost of longlong ++ [i]" most of the time
11:50:28 <silasm> s/multple/multiple of/
11:50:48 <monochrom> silasm, I believe that Hafydd is joking
11:50:51 <silasm> there's not necessarily any context of runtime there
11:51:09 <Hafydd> (Yes)
11:51:11 <nstdloop> silasm is correct
11:51:19 <silasm> monochrom: ah, (leaves quietly)
11:51:21 <nstdloop> Big O is just notation
11:52:42 <silasm> but yeah when learning big O I found it infinitely more helpful to use f ∈ O(n) rather than f = O(n)
11:52:57 <jle`> well...in normal math
11:53:06 <jle`> big O is literally upper bound
11:53:14 <silasm> because the latter just feels like a huge and misleading abuse of notation
11:53:16 <jle`> but everyone knows that computer science peoples don't really use normal math
11:53:26 <Twey> silasm: Aye
11:54:15 <jle`> asymptotic upper bound
11:54:54 <Twey> When we say a function is O(n), it's the ‘is’ of ‘George is a cat’, not the ‘is’ of ‘x² is x times x’
11:55:18 <Hafydd> Solve: x^2 is a cat
11:55:55 <Twey> x = ±√cat
11:55:55 <FireFly> x = √George
11:56:05 <FireFly> well, ±
11:56:08 <silasm> (^) :: (Num a) => a -> a -> Cat
11:56:09 <Twey> Heheh
11:56:14 <FireFly> maybe cats are complex
11:56:23 * Twey wins the slightly-more-pedantic-than-FireFly award.
11:56:41 <FireFly> Congratulations
11:56:48 <Twey> We're lacking a category theory joke here
11:57:00 <Hafydd> I believe silasm just made one.
11:57:06 * geekosaur suspects cats are not so much complex as quaternions, but.
11:57:17 <FireFly> caternions
11:57:53 <Hafydd> No, I suppose that would need to be: (^) :: (Num a, Cat b) => a -> a -> b
11:59:34 <Twey> Hafydd: Kind error.  ☹
12:00:00 <Hafydd> Twey: is the kind of Cat not * -> *?
12:00:08 <Hafydd> Maybe I'm thinking of Category.
12:00:58 <Twey> Oh, maybe *I'm* thinking of Category
12:01:00 <Twey> What's Cat?
12:01:18 <Hafydd> As I intended it, Cat is Category, which has kind * -> *.
12:01:27 <Hafydd> But the joke only works if it's "Cat".
12:01:45 <djahandarie> If it has kind * -> * then it can't even be listed in the constraints.
12:02:14 <Twey> Oh, no, Category has (★ → ★ → ★) → Constraint
12:02:25 <Hafydd> Er...
12:03:17 <dzhus> Is it possible to instantiate a value with type equal to an associated type synonym, preserving type context? This does not typecheck: http://dpaste.com/1564836/
12:03:57 <djahandarie> Hafydd, and even if you meant (* -> *) -> Constraint, it's still a kind error because you failed to apply something to b at the end
12:03:58 <Twey> dzhus: You didn't use ScopedTypeVariables
12:04:08 <Twey> dzhus: You need to bring the type variable into scope with a forall before you can reference it
12:04:43 <Twey> barTest ∷ ∀ a. (ChildI (Asc a), ParentI a) ⇒ a → String
12:04:47 <Hafydd> Alright, I suppose it won't work.
12:05:02 <ski> @kind Control.Category.Category
12:05:03 <lambdabot> (* -> * -> *) -> Constraint
12:05:07 <Twey> barTest _ = test (undefined ∷ Asc a)
12:05:09 <dzhus> Twey: yay, that's it, thanks!
12:05:13 <Twey> No problem
12:05:32 <Twey> dzhus: You can also use ‘asTypeOf’ instead of ScopedTypeVariables
12:05:52 <FireFly> Twey: what do you use for fancy unicode character input, btw?
12:06:07 <Twey> dzhus: Or you could just pass that argument straight in
12:06:31 <Twey> FireFly: I use UIM's TeX input on IRC, and the Agda2 input in emacs
12:06:54 <Twey> I also have some common characters on my third-level, and some less-common characters using a compose key
12:07:49 <FireFly> Hm, okay
12:07:49 <ski> dzhus : another variant is to say `barTest a = test (toAsc a) where toAsc :: a -> Asc a; toAsc _ = undefined'
12:08:23 <etandel> (*-*) :: Cat a => a
12:08:31 <ski> (that works with just a `barTest :: (ChildI (Asc a), ParentI a) => a -> String')
12:10:15 <Hafydd> class Cat a where { meow :: a -> IO () }
12:11:54 <mmmmm> So.. is there any advice for when it appears cabal is horribly broken?
12:12:20 <nstdloop> sacrifice to the thunder gods
12:12:21 <geekosaur> @where sicp
12:12:21 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
12:12:27 <geekosaur> ...last link there
12:12:49 <Twey> Haha
12:15:33 <dwcook> Structure and Interpretation of Computer Programs, though not directly related to package management, will get you well on your way to making a PM. ;)
12:15:42 <skypers> what is the complexity of nub?
12:15:44 <skypers> quadratic?
12:15:56 <mm_freak_> skypers: linear in time and space
12:15:58 <nstdloop> Is there a version of Purely Functional Data Structures that uses Haskell as its primary language?
12:16:05 <skypers> linear?
12:16:08 <skypers> how is it even possible?
12:16:09 <dwcook> skypers, Hackage says O(n²)
12:16:11 <skypers> yeah
12:16:12 <nstdloop> mm_freak_: what? I'm pretty sure it's quadratic.
12:16:13 <skypers> O²
12:16:41 <mm_freak_> well, the question wasn't precise enough =)
12:16:51 <skypers> btw where is the name from?
12:16:52 <skypers> “nub”
12:17:00 <mm_freak_> remember that haskell is lazily evaluated
12:17:06 <skypers> I’d name it unique
12:17:09 <skypers> or something like that
12:17:13 <Twey> skypers: It gets to the nub of the matter!
12:17:13 <Hafydd> The Haskell report explains its origin.
12:17:14 <mm_freak_> the complexity of getting the next element is O(n)
12:17:14 <monochrom> nstdloop: appendix A uses Haskell as its primary language. is that good enough?
12:17:18 <Hafydd> nub means "essence".
12:17:23 <dwcook> skypers, oddly enough, Hackage tells you that too ;)
12:17:25 <Twey> 3. The essence or core of an issue, argument etc.
12:17:39 <nstdloop> monochrom: I've heard not great things about the experience of reading it as a haskeller.
12:17:39 <skypers> I see, thank you
12:17:56 <skypers> mm_freak_: yeah but I plan to traverse the whole nubbed list
12:18:00 <skypers> so it’s quadratic I guess
12:18:10 <Cale> You might want to use map head . group . sort instead
12:18:12 <mm_freak_> you can have O(log n) by replacing the Eq constraint by an Ord constraint
12:18:17 <monochrom> well ok, then I am not a haskeller
12:18:22 <Twey> nstdloop: It's not about Haskell
12:18:22 <Cale> Then it's O(n log n)
12:18:26 <nstdloop> skypers: You can also use Data.Set to get an nlogn version.
12:18:39 <mm_freak_> Cale: and O(n * log n) for getting the first element, which is bad
12:18:47 <Twey> The language (MIT Scheme, by default, though there are translations) is largely immaterial.  But that does mean it doesn't cover things like types.
12:18:57 <mm_freak_> a better way is to traverse the list using a Set
12:19:00 <Cale> yes
12:19:15 <Cale> :t nubOrd
12:19:16 <lambdabot> Not in scope: `nubOrd'
12:19:22 <Cale> :t ordNub
12:19:23 <lambdabot> Not in scope: `ordNub'
12:19:25 <nstdloop> Twey: I guess. But it's nice to be able to read the inline code samples.
12:19:35 <Cale> hmm, thought there was something along those lines in scope at one point
12:20:07 <Twey> nstdloop: If you can only read one programming language, you have bigger problems :þ  It teaches you Scheme as you go, I think, and it doesn't use any advanced language features.
12:20:15 <skypers> ok
12:20:17 <skypers> thank you Cale
12:20:29 <skypers> I might even not need that actually
12:21:24 <mmmmm> Twey: Doesn't he use Standard ML?
12:21:26 <Cale> skypers: But yeah, if you accumulate a Data.Set, and use that to check if each subsequent element has been seen, it's O(log n) time per element to test, but you don't have to sort, and you don't have to reorder the input.
12:21:53 <skypers> I always forget about Data.Set
12:22:01 <skypers> such a great type
12:22:07 <skypers> is it a black-red tree?
12:22:11 <mm_freak_> the sort version may get you better overall performance, though
12:22:25 <mm_freak_> if you're planning to traverse the entire list anyway, you might as well just sort it
12:22:36 <skypers> mm_freak_: I actually don’t need it anymore
12:22:44 <Cale> It's a "BST of bounded balance"
12:22:47 <skypers> I just filter the list with a convenient function
12:23:01 <Cale> http://groups.csail.mit.edu/mac/users/adams/BB/
12:23:22 <skypers> I’m liftingM over getDirectoryContents
12:24:08 <skypers> I’m filtering that discarding ".", ".." and "" after a suffix test
12:24:41 <Twey> mmmmm: Who?  Sussman?  SICP is all in MIT Scheme
12:24:52 <mmmmm> oh ok, wrong book
12:24:58 <Twey> Though I'm sure Sussman has used ML at some point :þ
12:28:09 <uncleBlazer> has anyone got experience with znc?
12:28:57 * hackagebot git-annex 5.20140116 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140116 (JoeyHess)
12:29:01 <darkpassenger> is there any data reflection in haskell (part of prelude ? )
12:29:21 <piezoid> is there a general method to convert Monad m => a -> m b to m (a -> b) ?
12:29:42 <piezoid> I have doubts, as Applicative is inferior to Monad...
12:29:52 <Twey> uncleBlazer: #znc have
12:30:52 <uncleBlazer> Twey: should it be keeping a log of channels by default? I keep disconnecting from it on purpose  but I'm not sure if I'm doing it right
12:31:13 <geekosaur> darkpassenger, no, and reflection has type safety issues so it's not really a Haskelly thing (although see Data.Typeable)
12:31:17 <dwcook> piezoid, to clarify, you're looking for (Monad m) => (a -> m b) -> m (a -> b)?
12:31:32 <piezoid> dwcook: yes
12:31:33 <frege> :t add
12:31:34 <lambdabot>     Not in scope: `add'
12:31:34 <lambdabot>     Perhaps you meant one of these:
12:31:34 <lambdabot>       `odd' (imported from Prelude), `and' (imported from Data.List),
12:31:39 <frege> :t map
12:31:40 <lambdabot> (a -> b) -> [a] -> [b]
12:32:03 <rien> Twey: he probably used ML in the comments ;)
12:32:36 <frege> what does it mean? (a -> b) -> [a] -> [b]
12:32:43 <frege> isn't 'a' a function?
12:32:53 <geekosaur> no, a -> b is a function
12:32:54 <monochrom> uncleBlazer: consider the module "log"
12:32:55 <dwcook> frege, it can be any type.
12:33:09 <dwcook> piezoid, nothing obviously comes to mind…
12:33:13 <Twey> piezoid: No, not in general, because it doesn't make sense
12:33:16 <geekosaur> you can also read that type signature as:  (a -> b) -> ([a] -> [b])
12:33:22 <frege> so a->b will return a function that has b as its argument?
12:33:28 <Twey> piezoid: The ‘context’ in the m b can depend on the a
12:33:41 <merijn> frege: No (a -> b) *is* a function from 'a' to 'b'
12:33:41 <geekosaur> no. (a -> b) is a function that, when given an a, produces a b
12:33:56 <merijn> frege: The entire '(a -> b)' bit is the first argument
12:33:59 <frege> merijn: what do you mean 'from a to b'?
12:34:07 <frege> ahhhh gotcha
12:34:08 <merijn> frege: Takes an 'a', returns a 'b'
12:34:40 <dwcook> Give me an a -> b and an a and I will give you a b.
12:34:41 <darkpassenger> thx geekosaur
12:34:52 <piezoid> Parsec.Expr use Applicative functions (ParsecT s u m (Term -> Term)) and I need to perform action in m monad depending on the Term argument
12:34:55 <merijn> frege: "map :: (a -> b) -> [a] -> [b]" can be parsed as: First argument has type 'a -> b', second argument has type '[a]', return type is '[b]'
12:34:57 <frege> so it's indeed a function
12:35:10 <frege> right right
12:35:33 <merijn> Or, yet another way is "(a -> b) -> ([a] -> [b])"
12:35:35 <Twey> uncleBlazer: By default it will store (in RAM) the messages from when you last connected; reconnecting will clear the buffers.  You can enable the log module to write text logs, or there's a setting that will make it not erase the buffers when you connect; see #znc.
12:35:39 <frege> so the first argument is a function a with the input b, ..
12:35:58 <geekosaur> input a, result b
12:35:58 <merijn> frege: i.e. it takes a function 'a -> b' and returns a function which takes an '[a]' and returns a '[b]'
12:36:05 <dwcook> No, a isn't the name of a function, it's the type of its input
12:36:17 <S11001001> piezoid: do you not then actually want the function Monad m => (a -> m b) -> m a -> m b?
12:36:23 <frege> [a] -> [b] is confusing
12:36:25 <merijn> frege: The 'a' and 'b' have nothing to do with the input arguments
12:36:32 <merijn> frege: What's confusing about it?
12:36:56 <frege> I can intellectually accept this but if I want to write one myself I don't think I can
12:37:07 <frege> (a -> b) represents a function?
12:37:17 <frege> and what ([a] -> [b])
12:37:23 <merijn> frege: A function
12:37:24 <frege> what's ^^?
12:37:40 <dwcook> Also a function, but from a list of a's to a list of b's
12:37:48 <dwcook> Where a is the same a as before and b is the same b as before
12:37:50 <Twey> a → b is a function that takes an a and returns a b.  [a] → [b] is a function that takes a list of a and returns a list of b.
12:38:18 <frege> Twey: well that's what I said in the beginning
12:38:19 <S11001001> piezoid: it is possible to write Distributive f => (a -> f b) -> f (a -> b).  That's just 'distribute'.  But not for Monad.
12:38:22 <dwcook> The type of map says "Give me a way to turn an a into a b, and I will give you a way to turn a list of a's into a list of b's."
12:38:33 <frege> ahhh no
12:38:42 <frege> my explanation was slightly wrong
12:38:44 <fizbin> :t map
12:38:45 <lambdabot> (a -> b) -> [a] -> [b]
12:38:53 <fizbin> :t concatMap
12:38:54 <lambdabot> (a -> [b]) -> [a] -> [b]
12:38:57 <Twey> frege: So where's your confusion?  ☺
12:39:31 <merijn> frege: "(+1) :: Int -> Int", "map :: (a -> b) -> [a] -> [b]", "map (+1) :: [Int] -> [Int]", since I pass "Int -> Int" argument for the "a -> b", 'a' must be Int and 'b' must be Int, thus the return must be "[Int] -> [Int]"
12:39:39 <frege> Twey: my confusion is that when you call map, you do it like this; map func []
12:39:54 <geekosaur> yes
12:39:58 <frege> func === (a -> b) ?
12:40:02 <piezoid> S11001001: no, i realy need '(Term -> ParsecT s u m Term) -> ParsecT s u m (Term -> Term)'
12:40:04 <merijn> frege: Right, which is conceptually the same as "(map func) []"
12:40:05 <merijn> frege: Yes
12:40:10 <frege> right
12:40:13 <dwcook> func :: a -> b
12:40:16 <frege> and what about []?
12:40:17 <S11001001> piezoid: well, you can't have that one.
12:40:24 <frege> is [a] == []?
12:40:24 <dwcook> [] is a list of any type
12:40:26 <merijn> frege: So "map func" returns a function [a] -> [b], and you pass [] as argument to that new function
12:40:38 <frege> ahh
12:40:44 <fizbin> > map undefined []
12:40:47 <lambdabot>  []
12:40:53 <frege> returns a function [a] -> [b] is confusing
12:40:59 <merijn> frege: "map func []" == "(map func) []", so "map func" returns a new function and you apply that function to []
12:41:09 <fizbin> frege: That's currying for you.
12:41:12 <silasm> frege: confusing at first, but it's powerful.
12:41:19 <silasm> frege: that's Haskell for you ;).
12:41:20 <S11001001> piezoid: the reverse is easy; it's just 'distribute' again.  But that's it.
12:41:30 <Twey> frege: Functions in Haskell are curried by default: we often talk about a function like a → b → c as ‘taking two arguments’ informally, but it's actually a function that takes *one* argument, and returns a function that takes one argument and returns the result
12:41:31 <frege> I know currying functions in python with partial
12:41:47 <dwcook> frege, this might be of help: http://learnyouahaskell.com/higher-order-functions#curried-functions
12:42:01 <Twey> frege: I.E. a → b → c is the same as a → (b → c), and dually f x y is the same as (f x) y
12:42:06 <frege> thanks guys; I just need to keep thinking about it until it sinks
12:42:45 <merijn> frege: Essentially "map func []" in haskell would be like "map(func)([])" in python
12:43:05 <merijn> i.e. "map(func)" returns a function that you then immediately call with []
12:43:21 <darkpassenger> the Eq class in Haskell
12:43:23 <frege> right right; or partial(map, func, [])
12:43:26 <darkpassenger> is a supertype kinda
12:43:27 <merijn> Maybe a bad example, since python *has* a map function
12:43:40 <magneticduck> darkpassenger: it's a class like any other class
12:43:40 <simpson> Also Python's calling convention is totally different.
12:44:39 <piezoid> S11001001: the solution i found is to have my expression parser producing 'm Term' with token parsers 'ParsecT s u m (m Term -> m Term)' and then lift the resulting action to get 'ParsecT s u m Term'
12:44:41 <darkpassenger> magneticduck but operators (which are functions ?) inherit from it ?
12:44:51 <merijn> frege: It'd be like "def map(func): return lambda l: [func(x) for x in l]"
12:44:59 <merijn> darkpassenger: No
12:45:11 <magneticduck> btw guys, if we use (a -> b) in the agda-ish sense to mean a implies b, then a typeclass is a deduction, right?
12:45:27 <merijn> darkpassenger: There is no such thing as inheritance in haskell
12:45:28 <simpson> Although map(), again, has weird behavior on edge cases like func == None, and also supports *l, not l.
12:45:37 <Twey> magneticduck: Yes, typeclasses are just the same as functions for the purposes of Curry–Howard
12:45:37 <dwcook> darkpassenger, you are confusing the OO notion of inheriting from a class with the Haskell notion of typeclasses, which shares nothing but a name.
12:45:42 <jle`> frege: what do you expect a function [a] -> [b] to do?
12:45:52 <magneticduck> Twey: gotcha.
12:45:56 <jle`> my intuition would be...it takes a list of a's
12:45:59 <jle`> and returns a list of b's
12:46:01 <bitemyapp> darkpassenger: if you want an analogue that actually at least a vague similarity, you want Java interfaces or Scala traits but without inheritance.
12:46:09 <Twey> magneticduck: They're just filled in for you by the compiler, like Agda's implicit arguments (though the rules for doing so are quite different)
12:46:16 <jle`> what do you expect a function a -> b to do?
12:46:22 <jle`> my intutiion would be that it takes an a and returns a b
12:46:26 <bitemyapp> darkpassenger: typeclasses are, frankly, simpler than any of the analogues you might be thinking of, life will be easier if you unlearn everything and just focus on the Haskell.
12:46:43 <bitemyapp> jle`: returns a b? way to make that sentence confusing :)
12:46:49 <darkpassenger> bitemyapp: the class Eq contain all sort of operators, which are used in which context ?
12:46:52 <jle`> bitemyapp: haha
12:46:53 <magneticduck> darkpassenger: by saying that Int has an instance in EQ, you're saying that there exists a function (==) :: a -> a -> Bool for a = Int
12:46:56 <shachaf> Twey: Maybe "=> is like a function, constraints are like values"
12:47:12 <merijn> darkpassenger: Sure, but the class doesn't have any code
12:47:14 <dwcook> We could use concrete types, which might be less confusing. A function Foo -> Bar, applied to a Foo, results in a Bar.
12:47:27 <Twey> shachaf: Aye
12:47:27 <merijn> darkpassenger: The instances of Eq hold the actual implementation
12:47:28 <magneticduck> darkpassenger: darkpassenger the idea is that you can then define a function of type (Eq a) => <type function on a>
12:47:39 <jle`> frege: so you have an intution for (a -> b), you have an intuition for ([a] -> [b])....so what map does it that it takes an (a -> b) and then *upgrades* it to an ([a] -> [b])
12:47:49 <shachaf> In particular an existential constraint is like a tuple.
12:47:51 <Taneb> I have not had a very good experience with missing-py2
12:47:55 <jle`> so i have a function like \x -> x + 2
12:47:58 <magneticduck> (in that function you can freely use the (==) operator on a)
12:48:01 <jle`> that is Int -> Int, maybe
12:48:09 <shachaf> Anyway, that's one interpretation of it.
12:48:19 <jle`> if i do map (\x -> x + 2)
12:48:25 <jle`> i get a new function [Int] -> [Int]
12:48:30 <magneticduck> correct
12:48:32 <jle`> my function now works on lists
12:48:37 <magneticduck> ( jle` )
12:48:44 <magneticduck> yes
12:48:55 <greg`> ok im on problem 13
12:49:12 <bitemyapp> darkpassenger: it's just way of abstracting the notion of "equality" as an interface.
12:49:42 <jle`> darkpassenger: do you have any experience with Interfaces in OOP?
12:49:56 <bitemyapp> darkpassenger: a given type either satisfies the typeclass (interface) or it doesn't.
12:50:04 <greg`> from http://tmorris.net/posts/20-intermediate-haskell-exercises/index.html
12:50:27 <silasm> jle`: (or, semi-equivalently, abstract base classes)
12:50:42 <bitemyapp> silasm: ABC is still inheritance
12:50:56 <bitemyapp> it's a rough analogy to work out.
12:50:58 <greg`> i have, apple :: (Misty m) => m a -> m (a -> b) -> m b
12:51:30 <silasm> bitemyapp: yeah, but if he's only used C++ he doesn't know interfaces but he might know multiple ABC inheritance.
12:51:31 <greg`> where i can : call banana :: (a -> m b) -> m a -> m b
12:51:32 <greg`> --  unicorn :: a -> m a
12:51:46 <tertl3> hello
12:52:00 <greg`> yet i cant seem to unwrap the a -> mb goodness
12:52:28 <dwcook> greg`, think about how to turn a -> m b into m a -> m b
12:52:35 <dwcook> That's essentially what it's asking
12:52:52 <dwcook> Or wait
12:52:55 <bitemyapp> silasm: *cringe*, I guess. :(
12:53:06 <dwcook> No I misunderstood
12:53:14 <merijn> greg`: Oh, that's a pretty nasty one :)
12:53:51 <dwcook> Oh I see, it's basically telling you to implement fmap in terms of Monad
12:53:57 <S11001001> <*>
12:54:07 <silasm> bitemyapp: personally I think multiple ABC inheritance is a little closer anyways since typeclasses can specify default implementations. But interfaces are closer conceptually as a whole imo.
12:54:07 <merijn> greg`: Hint: You'll need two separate banana application and probably want to use a lambda for each of them
12:54:11 <nooodl> it looks easier in do notation
12:55:21 <merijn> nooodl: Agreed, it's pretty nasty this way :)
12:55:40 <merijn> On the upside, if you finish this actual uses of Monad must feel so easy :p
12:56:01 <greg`> thanks
12:56:27 <silasm> merijn: yeah, on the one hand I'm jealous of people who get to do Haskell for their homework; on the other it's hard to be jealous of foobar madness like that.
12:56:53 <merijn> silasm: I don't think that's even homework
12:56:58 <jfischoff> @remember merijn Hint: You'll need two separate banana application and probably want to use  a lambda for each of them
12:56:58 <lambdabot> It is stored.
12:57:11 <merijn> If that's homework 70% of the class fails
12:57:32 <merijn> (conservative estimate based on my experience with FP classes :p)
12:58:00 <silasm> heh.
12:59:02 <merijn> greg`: If you really get stuck, look up the way do notation desugars in haskell (there's a nice chapter in the wikibook), that may give a bigger clue
13:00:00 <triliyn> lambdabot also has @undo
13:00:41 <rtpg> considering referential transparency and all that, why would GHC still want to inline things?
13:00:44 <tertl3> whats wrong with this code at parseCharacter's return? http://lpaste.net/98964
13:00:48 <bambams_> I'm having trouble understanding how ghci loads "modules". I have a file in the current directory. Foo.hs. When I say `:m + Foo' it says: <no location info>: Could not find module `Foo', etc.
13:00:53 <rtpg> I mean if f is always equal to f, better to calculate it once than twice right?
13:01:07 <triliyn> rtpg: inlining can expose more optimizations
13:01:31 <rtpg> oh, good point
13:01:40 <triliyn> For example, if you have something like: transform f = fromList . f . toList
13:01:48 <geekosaur> bambams_: that file is not a module and won't be seen by :m. modules are things registered with ghc's package manager (ghc-pkg)
13:01:49 <triliyn> transform (+1) . transform (+1)
13:02:08 <rtpg> so you have toList . fromList ?
13:02:09 <triliyn> If we inline that, GHC can fuse away toList . fromList (assuming you've defined an appropriate rule)
13:02:14 <triliyn> Right
13:02:24 <triliyn> There are also other reasons I think but this is probably the biggest one
13:03:01 <triliyn> (also, that should probably be transform (map (+1)) for it to make any sense...)
13:03:01 <rtpg> I was just looking at all the warnings involved in unsafe***IO functions and all the "tips" on using them
13:03:12 <tertl3> whats wrong with this code at parseCharacter's return? http://lpaste.net/98964
13:04:10 <rtpg> tertl3, do you get an error?
13:04:32 <geekosaur> where's the full error message? but what leaps out at me immediately is indentation on line 44 looks wrong
13:05:28 <tertl3> rtpg: yes
13:05:33 <tertl3> error at return
13:06:06 <rtpg> you need to tell us the error, if it's a parse error like geekosaur suggests, chances are you just need to add a space before the <|>
13:06:25 <bambams_> geekosaur: Hmmm, but I can import it directly from ghc... :\
13:07:01 <geekosaur> bambams_, yes, ghc and ghci are somewhat different environments. and things are actually more complex than I said
13:07:35 <geekosaur> the real point is :m loads something that has an interface file, i.e. is already compiled.
13:07:41 <hakujin> bambams_: in ghci :load Foo
13:09:35 <tertl3> hellook it was indentation
13:09:37 <tertl3> ty
13:10:47 <jle`> greg`: what is this?  do you have to implement a function with the proper type signature?
13:12:55 <jle`> the names ar ecute
13:13:03 <qrada> rm rf'n my ~/.cabal.. eee! it's odd, as root i installed a bunch of packages fine.. but as my normal user, it's breaking so much -> missingh complaining about regex-base etc.. same with when i compiled lambdabot
13:13:22 <qrada> should i completely reinstall cabal? dno
13:13:37 <geekosaur> you shouldn't use cabal-install as root
13:14:55 <qrada> ya, i did tho to test.. you think that messed something up?
13:15:10 <qrada> i just wiped my ~/.cabal and im updating/installing again
13:15:15 <rtpg> qrada, if you install as root, it will install to root stuff
13:15:16 <geekosaur> well, it means parts of ~/.cabal and ~/.ghc are only writable by root
13:15:27 <rtpg> with root write permissions
13:15:34 <qrada> o
13:15:55 <rtpg> using cabal purely in userspace is good (just make sure to add ~/.cabal/bin to your path)
13:15:55 <geekosaur> and yes, it probably only diud that to /root/.ghc and /root/.cabal, but I think I've heard of stuff getting the wrong owner in user (depends on how you switched to root)
13:16:00 <qrada> i didnt have any root owned files in my ~/.cabal, but ya that could surface
13:16:17 <qrada> cool thanks folks
13:16:24 <geekosaur> also note that removing ~/.cabal is not enough, ~/.ghc is where the package database lives
13:16:27 <rtpg> I just nuked my .cabal and .ghc dirs earlier, cabal update and cabal install cabal-install , good times
13:16:40 <qrada> cool
13:16:49 <rtpg> just remember never to sudo
13:16:50 <geekosaur> removing .cabal without .ghc leaves you with a bunch of registered but broken packages
13:17:11 <qrada> ya, i think i just ran into that geekosaur
13:21:18 <dgpratt> using lambdabot @free, it sometimes replies "Extra stuff at end of line in retrieved type..."
13:21:24 <dgpratt> what does that mean?
13:21:46 <dgpratt> cannot @free deal with TC constraints?
13:22:27 <triliyn> dgpratt: I don't think it can
13:23:22 <dgpratt> ok, thanks
13:24:02 * hackagebot concurrent-state 0.3.2.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.3.2.0 (JoelTaylor)
13:39:26 <lambda_male> Is there a channel for functional programming?
13:39:53 <alkabetz> lambda_male: You mean just in general?  Not associated with any particular language?
13:39:55 <companion_cube> there are channels for functional languages
13:39:56 <lambda_male> Yes
13:41:06 <lambda_male> alkabetz: I'm looking for a place to ask functional programming questions not related to any specific language
13:41:36 <dwcook> lambda_male, you could try #haskell-blah
13:41:49 <companion_cube> there's reddit, too :p
13:42:01 <rtpg> lambda_male, it depends on the question, but people here would probably end up being interested anyways
13:42:39 <lambda_male> rtpg: the question is, why don't "normal" languages support functional pattern matching
13:42:58 <companion_cube> because they don't care
13:43:29 <rtpg> I think that's more of a historical thing... languages like C are very much based on abstractions on the machine (descriptions of memory) than the notion of abstract data types
13:43:29 <lambda_male> but they usually implement some fun-prog features
13:43:32 <dwcook> From the standpoint of early computer languages, it's not an obvious innovation
13:43:33 <mizu_no_oto> Anyone know anything about the approximate release date of 7.8?  Another week?  Another month?   Another 6 months?
13:43:47 <dwcook> and many modern languages are essentially incremental improvements on earlier languages
13:44:36 <timthelion> mizu_no_oto: once you solve P NP tell us
13:44:47 <lambda_male> dwcook: C#, Java, Ruby, PHP are newer than Haskell
13:45:00 <lambda_male> actually PHP doesn't count
13:45:20 <rtpg> java and C#, as systems-y sorts of languages, are heavily influenced by C/++
13:45:33 <dwcook> And C# and Java are… what rtpg said
13:45:50 <bitemyapp> rtpg: they're applications languages influenced by procedural systems languages.
13:45:50 <rtpg> they're also languages which have a sort of "erased" type system
13:45:51 <dwcook> PHP even is influenced by C++
13:45:56 <rtpg> after you compile, you don't keep track of types
13:46:05 <bitemyapp> Java and C# are decidedly not systems languages.
13:46:14 <dwcook> Well that's true of Haskell too
13:46:18 <Twey> lambda_male: There's also ##programming.
13:46:27 <rtpg> granted in Haskell you don't necessarily do that either (modulo typeclasses) , but value constructors look enough like types
13:46:30 <rtpg> it's an extra tag
13:46:47 <dwcook> Languages considered dynamically typed, on the other hand, are pretty likely to keep type information around at runtime
13:46:50 <Twey> -.-
13:46:51 <rtpg> bitemyapp, what I meant is that their initial iteration was on the systems programming end of things, syntax and type wise at least
13:46:55 <dwcook> Though that's more a feature of the compiler/interpreter
13:47:18 <Twey> rtpg: Types are properties of terms, not of values — tags are fundamentally not the same thing as types
13:47:35 <dwcook> In fact, dynamic language "type tags" are rather like Haskell's data constructors
13:47:49 <Twey> You can keep tags around at runtime indicating what type a thing had at compile-time, if you like, but the tag itself isn't a type
13:48:04 <dwcook> A dynamically typed language is, essentially, a language with only a single type
13:48:04 <Twey> (or rather, what type the expression that evaluated to the thing had)
13:48:23 <rtpg> yeah, it's a bad analogy
13:48:50 <tdammers> PHP doesn't count because it's not really a language, more like a sick joke.
13:49:03 <rtpg> what first started doing pattern matching? ML?
13:50:56 <aleksejs_> I'm going to make a presentation about functional programming in one local programmers meetup. I'd like to hear your opinion about topics I'd like to cover. Assuming that most of the guys there are barely familiar with FP, I've decided that topics would be: 1) imperative vs declarative (difference) 2) basics of functional programming, pure functions, compositions, currying etc 3) nice features of modern FP languages, like lazyness, infinite lists, rec
13:50:56 <aleksejs_> ursive data types 4) monads 5) ...
13:51:01 <Twey> rtpg: I guess regular expressions with captures are the first example
13:51:30 <Fuuzetsu> rtpg: Wiki says regex stuff in a text editor but ignoring that, it seems that it was SNOBOL, 1962
13:51:36 <bitemyapp> rtpg: SNOBOL, SASL, NPL, KRC, a Lisp varient.
13:51:38 <bitemyapp> variant*
13:51:39 <Twey> aleksejs_: 1) Types  2) More types
13:52:14 <silasm> aleksejs_: I did a 2 hour presentation at my school and didn't even get to defining data types or monads :/. It was a great experience, though, have fun!
13:52:45 <Twey> aleksejs_: What exactly do you want to teach?  And what do they know?
13:52:56 <aleksejs_> Twey, the problem is that they don't really know what is the difference between FP and imperative. They are like "FP is when everything is a function" :)
13:53:00 <Twey> Something on purity might be good, and then maybe a bit on types
13:53:09 <Twey> aleksejs_: That's fair enough, because it's not a well-defined term
13:53:22 <rtpg> purity is a big one obviously
13:53:27 <silasm> aleksejs_: but yeah most of that was the stuff I covered in mine, and it went pretty well. I highly recommend a practice run-through with a similar but more friendly audience if you can manage it
13:53:28 <Fuuzetsu> Twey: some hand waving can make everything seem well-defined
13:53:31 <Twey> Heh
13:55:02 <silasm> when I did my practice run-through with a bunch of my friends who'd never seen haskell before they were hype as hell, it was unexpectedly funny. Probably helped that it was 3 AM.
13:55:10 <aleksejs_> but I think it's very important to explain them the difference between imperative and declarative, because w/out this it would be hard to explain the reason of "safe"
13:55:54 <silasm> aleksejs_: if you can (and if it's suited for your audience) try to fit in some equational reasoning / denotational semantics
13:56:10 <silasm> being able to reason about your code like you can in haskell is delicious.
13:56:11 <hamster007_> ok so I have general questions about literate haskell
13:56:17 <hamster007_> I have some lhs files
13:56:26 <hamster007_> and I want to make a pdf
13:56:33 <hamster007_> I was told about pandoc
13:56:42 <hamster007_> can it consume the lhs files?
13:56:53 <merijn> hamster007_: Meh, if you're familiar with LaTeX, you probably just want to use that?
13:56:57 <Fuuzetsu> @google pandoc lhs
13:56:59 <lambdabot> http://johnmacfarlane.net/pandoc/README.html
13:56:59 <lambdabot> Title: Pandoc - Pandoc User’s Guide
13:57:14 <Twey> aleksejs_: That's not true.  There are very interesting definitions of ‘safe’ for imperative languages.
13:57:30 <Fuuzetsu> Well, not exactly what I was hoping for… http://johnmacfarlane.net/pandoc/demo/example19/Literate-Haskell-support.html
13:57:34 <merijn> hamster007_: Pandoc can do lhs, but there's a lhs2TeX program that converts your lhs into a TeX file and prettifies the haskell code a bit
13:57:49 <aleksejs_> Twey, for example?
13:58:42 <hamster007_> so should I use laTEX or pandoc
13:59:24 <Fuuzetsu> up to you
13:59:30 <hamster007_> ok so lhs2TeX has the prettification
13:59:34 <silasm> aleksejs_: but yeah, sadly, for the uninitiated imperative programmer, you'll probably spend most of your time on what it means to be a functional language (which isn't bad, but it's a little boring when you think of how you could be teaching monads)
13:59:49 <Peaker> when explaining Haskell I don't say the word "functional" at all
14:00:03 <Twey> aleksejs_: There are established techniques for safe programming in imperative languages too; it's just that imperative programmers tend to use more side effects
14:00:06 <silasm> Peaker: how do you manage that?
14:00:23 <Twey> aleksejs_: But e.g. the ST monad is a pure imperative language
14:00:25 <Fuuzetsu> silasm: I don't think it's necessary to stick monads into every talk that has anything to do with Haskell.
14:00:35 <merijn> hamster007_: If you use lhs2tex, you probably want to use the "\begin{code}" style of lhs, instead of Bird-style (i.e. angle brackets)
14:00:36 <Peaker> silasm: I try to avoid "purity" too (or I just say its a misnomer) and explain that Haskell has "typed effects"
14:00:47 <silasm> Fuuzetsu: didn't say it was, but it's more fun ;).
14:00:53 <Peaker> silasm: and that typed effects have awesome consequences, and then explain some of those
14:01:02 <hamster007_> the code was written with bird tracks
14:01:19 <Peaker> "purity" is a pejorative for most people. "functional" is quite meaningless ("Oh, like lisp?")
14:01:45 <Peaker> "so if it's pure, programs can't do anything interesting?"
14:01:51 <Peaker> these words mislead more than inform
14:02:12 <hamster007_> "no they can't, but you can sleep at night"
14:02:25 <rtpg> the more I think about lisp the less I see it as functional, except as an accident due to homoiconicity
14:02:30 <Peaker> hamster007_: someone hears that, and the language is at best a silly toy
14:02:53 <Peaker> rtpg: well, "functional" is essentially a meaningless word as a description of languages
14:02:58 <Fuuzetsu> rtpg: Most Lisps are hardly functional. You can of course try very hard to program in functional style, just like in C or Java.
14:04:09 <dwcook> Lisp is a procedural programming language with procedures as values
14:05:49 <dwcook> Though of all procedural languages, Haskell must be my favorite
14:05:52 <dwcook> ;)
14:06:40 <silasm> this whole talk is reminding me about how I meet with a hacker group that's expressed they're actually willing to hear me out about Haskell, but they want me to tackle debugging. Which is kind of a sticky issue. I'm plenty happy with hopping back and forth from the REPL, but that's not quite sufficient for them; they're stuck on prints and sleeps like most imperative programmers are. Any advice?
14:06:44 <bitemyapp> Fuuzetsu: except for Clojure, but it's strict, impure, untyped so still blurgh.
14:07:01 <bitemyapp> silasm: I'm giving a talk on Fay at the ClojureScript meetup in SF. I gave a talk on Haskell at the last Clojure meetup here.
14:07:20 <bitemyapp> actively working to steal people.
14:07:32 <silasm> bitemyapp: heh
14:07:40 <dwcook> silasm, so introduce them to the Haskell way of debugging
14:07:44 <ChongLi> bitemyapp: that one seems tricky
14:07:48 <silasm> they're C#/java programmers though.
14:07:50 <ChongLi> cljs is a lot more mature than Fay
14:07:53 <bitemyapp> silasm: https://github.com/bitemyapp?tab=repositories
14:08:03 <bitemyapp> ChongLi: good thing I'm not really comparing it to CLJS.
14:08:04 <dwcook> And? I was a JavaScript programmer before I learned Haskell.
14:08:11 <bitemyapp> ChongLi: also, CLJS might be more mature, but the tools are still a fucking nightmare.
14:08:13 <ChongLi> good
14:08:25 <aleksejs_> dwcook, I guess, procedural by definition is the subclass of imperative
14:08:30 <bitemyapp> CLJS's tools are singlehandedly stymieing its growth more than anything else.
14:08:30 <ChongLi> they'll always be, without static types
14:08:42 <bitemyapp> ChongLi: no no, it goes deeper and gets worse than that.
14:08:50 <bitemyapp> ChongLi: most new people can't even get a reliable build.
14:08:55 <silasm> dwcook: I was a java programmer, but what got me attached to haskell was I thought that all functional programming looked like J ;)
14:08:58 <bitemyapp> ChongLi: the compiler is pretty unstable too.
14:09:21 <ChongLi> yeah, now that I think about it
14:09:24 <ChongLi> it's not all that mature
14:09:25 <bitemyapp> I realize Fay is very young, but it's on a trajectory to be much more usable and is in many respects, much nicer to get rolling with than CLJS.
14:09:34 <bitemyapp> (already, that is)
14:09:38 <jle`> there are a lot of people in the world who believe that IO is just a compiler flag to indicate impure/side-effectful/different on calls
14:09:39 <ChongLi> the main difference is that they got their collections libraries working
14:09:43 <silasm> I enjoyed J, but Haskell's semantics and syntax made a whooole lot more sense to me, so it was easy be comparison.
14:09:46 <jle`> sort of like the opposite of const in C++
14:09:48 <ChongLi> Fay needs type classes and then it'll be good to go
14:09:55 <bitemyapp> ChongLi: yeah.
14:10:12 <bitemyapp> silasm: J is puzzle-programming.
14:10:19 <rtpg> is Fay lazy though?
14:10:39 <jle`> i think Fay has all the run time semantics of Haskell
14:10:43 <jle`> becuase...it *is* Haskell
14:10:44 <dwcook> I haven't done any large projects, but I notice that, for the most part, if I get my types correct then my program behaves as expected. So my main experience debugging Haskell is getting types right, which might make my experience with it kind of shallow. :P
14:10:48 <bitemyapp> rtpg: Fay is lazy
14:11:00 <bitemyapp> rtpg: but the compiler can export an extra Strict module to make calling from JS natively nicer.
14:11:02 <jle`> does Fay have all of the concurrency stuff of ghc?
14:11:05 <jle`> or is that only ghcjs?
14:11:07 <bitemyapp> you can force the thunks if you want.
14:11:17 <ChongLi> that's ghcjs
14:11:19 <rtpg> hmm... it would be so great if this got coffeescript level of support
14:11:20 <silasm> silasm: and the puzzle, when put together, shows an image of a golf course full of weird ASCII, but at least it's not Unicode ;)
14:11:20 <jle`> darn
14:11:25 <bitemyapp> jle`: Fay is trying not to diverge from the host. That's a *good* thing.
14:11:30 <bitemyapp> jle`: no no dude, that's a good thing.
14:11:30 <rtpg> I would kill to be able to write nice frontend code
14:11:33 <dwcook> Which is not to say my well-typed programs are bug-free – but even bugs not caught by the type system may become more blatant.
14:11:40 <bitemyapp> jle`: you do not want to use something like GHCJS on the frontend for at least another 5-10 years.
14:11:45 <rtpg> the problem ends up being interfacing with existing JS libraries though
14:11:46 <ChongLi> ghcjs also happens to support a ton of LANGUAGE extensions
14:11:46 <silasm> s/silasm/bitemyapp/
14:11:59 <dwcook> I think that's more a consequence of the explicitness of program flow than anything.
14:11:59 <jle`> i just want to be able to compile any arbitrary hackage package into js
14:12:03 <silasm> (just ignore me talking to myself there)
14:12:04 <ChongLi> all of em, I think
14:12:09 <jle`> is that so much to askkkk
14:12:10 <jle`> :'(
14:12:12 <bitemyapp> jle`: you don't do much frontend work do you?
14:12:31 <bitemyapp> not intended as an insult, you just seem to have the priorities of someone that doesn't do much of it.
14:12:43 <jle`> bitemyapp: i don't actually; for frontend i've been playinf around with Fay; wouldn't do it in ghcjs
14:12:48 <jle`> but i have some nice games/simulations
14:12:52 <jle`> that run using an SDL frontend
14:12:56 <bitemyapp> yeah, something like Fay is critical.
14:12:59 <jle`> that i would love to be able to just compile to web
14:13:13 <bitemyapp> Another reason I'm presenting Fay at the CLJS meetup is that they'll appreciate the notion of "respecting and staying close to the host"
14:13:15 <jle`> without any hassle
14:13:22 <bitemyapp> jle`: emscripten ahoy
14:13:35 <dwcook> GTK+ bindings for browser JavaScript would be neat :P Actually, I think they have those
14:14:00 <jle`> dwcook: but i want the entire game/simulation in javascript
14:14:00 <rtpg> so fay has strictness stuff, and lets you be impure?
14:14:06 * hackagebot concurrent-state 0.3.3.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.3.3.0 (JoelTaylor)
14:14:08 <bitemyapp> rtpg: Fay isn't strict
14:14:14 <piezoid> silasm: trace is usefull for debugging, particularly when you debug unsafePerformIO
14:14:42 <bitemyapp> rtpg: "lets you be impure" only insofar as Haskell does.
14:14:59 <jle`> rtpg: Fay is haskell, for the most part
14:15:12 <jle`> i just want to be able to compile my game to javascript and be good to go :|
14:15:24 <silasm> piezoid: haven't used trace, I'll look into it.
14:15:48 <jle`> i got netwire to compile on ghcjs, so we'll see where that takes me
14:15:50 <rtpg> the biggest issue I would have is that most JS libraries are *very* stateful
14:15:54 <bitemyapp> alright back to puzzling over a goddamn lexer.
14:16:04 <bitemyapp> rtpg: uhhh, CLJS is helping with that.
14:16:29 <bitemyapp> rtpg: they're spreading the immutability-by-default virus, I'll be presenting the purity-by-default-too side of it.
14:16:40 <jle`> rtpg: C libraries are stateful too, but that doesn't stop ghc/haskell from having ffi
14:17:08 <rtpg> yeah but a non-trivial amount of my JS (at least) is interfacing with other libraries (and the DOM)
14:17:17 <bitemyapp> rtpg: so?
14:17:32 <bitemyapp> rtpg: I've rather enjoyed making Fay wrappers for stuff, the types alone help clarify and make my life easier.
14:26:56 <skypers> how would you get whether a file is a directory or a file?
14:27:11 <skypers> with doesFileExist / doesDirectoryExist?
14:27:14 <joelteon> does cabal support changelogs?
14:27:54 <dcoutts_> joelteon: you can include a changelog in your package and hackage will show it
14:28:05 <dcoutts_> a changelog file I mean, in the package tarball
14:28:13 <joelteon> just a file called changelog?
14:29:42 <Axman6> jophish_: still around?
14:30:46 <skypers> I guess I have to stick to does*Exist
14:30:52 <tam1138> hi there
14:31:18 <ski> aleksejs_ : i hope you mentioned that "FP is when everything is a function" is false
14:32:01 <jophish_> Axman6: yeah, fora  few minutes
14:32:04 <tam1138> i've got a value and a list of functions i'd like to apply to that value, resulting in a list of results (ie, [(a -> b)] -> a -> [b]).  is the "right way" to do this with pure and <*> ?
14:32:14 <dwcook> And then proceeded to confuse the issue by introducing Church encodings :P
14:32:29 <aleksejs_> ski, that's the exact quote I've heard from some people
14:32:34 <skypers> tam1138: there’s no « right way », only alternatives
14:32:46 <ski> aleksejs_ : i hope your 1) includes that FP is a different paradigm, and that learning a different paradigm isn't just like learning another language in the same paradigm. it's closer to learning to program all over from scratch again (closer to that, but not quite, since some things carry over)
14:32:46 <skypers> well, there might have performance issues of course
14:32:54 <tam1138> skypers: heh.  right.  is there are more idiomatic way?
14:33:04 <skypers> you could use fmap
14:33:04 <ski> aleksejs_ : .. just to prepare them that they have to pay attention to basics
14:33:12 <skypers> fmap ($ value) [functions]
14:33:15 <skypers> well, map.
14:33:17 <Axman6> jophish_: I was just curious about your GLSL language
14:33:23 <skypers> I’d do that
14:33:36 <jophish_> Axman6: I'm writing a compiler to translate a weird version of Haskell into LLVM IR. And also writing an LLVM backend to output GLSL
14:33:44 <ski> aleksejs_ : i presume that people say "FP is when everything is a function" because of the common slogan (roughly) "in OO, everything is an object"
14:33:47 <skypers> > map ($ 3) [(+1),(*2),(-1)]
14:33:51 <lambdabot>  No instance for (GHC.Show.Show b0)
14:33:51 <lambdabot>    arising from a use of `M476207082014742672919539.show_M4762070820147426729...
14:33:51 <lambdabot>  The type variable `b0' is ambiguous
14:33:51 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
14:33:51 <lambdabot>  Note: there are several potential instances:
14:33:52 <jophish_> Haskell makes a very nice shading language
14:33:57 <skypers> ahah
14:34:15 <skypers> > map ($ 3) [(+1),(*2),(-1)] :: [Int]
14:34:17 <lambdabot>  No instance for (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Int))
14:34:17 <lambdabot>    arising from a use of syntactic negation
14:34:17 <lambdabot>  Possible fix:
14:34:17 <lambdabot>    add an instance declaration for
14:34:17 <lambdabot>    (GHC.Num.Num (GHC.Types.Int -> GHC.Types.Int))
14:34:29 <Axman6> skypers: (-1) is the problem, you need subtract
14:34:30 <skypers> this is nic
14:34:31 <skypers> e
14:34:40 <skypers> > map ($ 3) [(+1),(*2),substract 1] :: [Int]
14:34:41 <lambdabot>  Not in scope: `substract'
14:34:41 <lambdabot>  Perhaps you meant `subtract' (imported from Prelude)
14:34:51 <tam1138> skypers: map ($ 3) [(+1),(*2),((-)1)] works too
14:34:52 <skypers> > map ($ 3) [(+1),(*2),id] :: [Int]
14:34:53 <lambdabot>  [4,6,3]
14:34:54 <silasm> ski: I feel like you don't really learn that until you're writing Prolog/Coq just to use the tutorials to learn the paradigm so you can program in Mercury/Idris
14:35:00 <ski> aleksejs_ : however, "pure FP" (cf. "pure OO") is not at all about making everything into a function. however one could say it's about making functions (as well) first-class values, to be passed as arguments, returned, and stored in extracted from data structures
14:35:03 <tam1138> skypers: thanks
14:35:07 <skypers> yeah
14:35:10 <Axman6> subtract, not substract...
14:35:15 <skypers> you could also do:
14:35:21 <ski> silasm : learn what ?
14:35:39 <silasm> ski: what part didn't you understand?
14:35:41 <skypers> > [(+1),(-)3,(*2)] <*> pure 3
14:35:42 <lambdabot>  [4,0,6]
14:35:44 <Axman6> tam1138: ((-)1) is not the same as subtracting 1
14:35:53 <mgsloan> rtpg: These days you can even write ffi wrappers inline.  E.g. ((ffi "prompt('What's your name?')" :: Fay String) >>= (ffi "console.log(%1)" :: String -> Fay ()))
14:35:53 <skypers> put this is quite stupid to me
14:35:53 <Axman6> it's \x -> 1 - x
14:35:54 <tam1138> Axman6: oh right, sorry
14:36:07 <ski> silasm : "that"
14:36:16 <lingxiao> Hey all, can I ask someone how to use `sumTy` in this blurb?
14:36:18 <skypers> because Applicative is a cartesian product for lists
14:36:19 <lingxiao> https://gist.github.com/anonymous/1155a411dbfae949a532
14:36:20 <triliyn> silasm: why learn from tutorials when you can stare at the language source until your eyes burn out? :D
14:36:50 <skypers> there’s also a lens for that
14:36:55 <skypers> maybe (&&)
14:36:57 <skypers> :t (&&)
14:36:59 <lambdabot> Bool -> Bool -> Bool
14:37:02 <lingxiao> a better version:
14:37:03 <lingxiao> https://gist.github.com/anonymous/8c868e5ee6df55acd825
14:37:04 <skypers> ahah :–’)
14:37:14 <skypers> :t (<&&>)
14:37:14 <joelteon> :t (&&~)
14:37:15 <lambdabot>     Not in scope: `<&&>'
14:37:15 <lambdabot>     Perhaps you meant one of these:
14:37:15 <lambdabot>       `<&>' (imported from Control.Lens),
14:37:15 <lambdabot> ASetter s t Bool Bool -> Bool -> s -> t
14:37:29 <joelteon> :t (_1 &&~ True)
14:37:30 <lambdabot> Field1 s t Bool Bool => s -> t
14:37:33 <silasm> ski: writing Prolog (logic language I don't want to write) / Coq (dependently typed language I don't want to write) because they have good tutorials for their languages, then transferring that knowledge over to Mercury (logic language I do want to write) / Idris (dpt language I do want to write) whose tutorials are more lacking
14:37:34 <hamster007_> http://lpaste.net/98966
14:37:53 <hamster007_> I got lhs2TeX installed. Yay!
14:38:10 <hamster007_> unfortunately it is huarfing as noted in http://lpaste.net/98966
14:38:30 <silasm> ski: basically learning a language I don't care about because it's in the paradigm of a language I do care about and has better tutorials.
14:39:08 * hackagebot concurrent-state 0.3.3.1 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.3.3.1 (JoelTaylor)
14:39:55 <silasm> Mercury is like Prolog GHC'd from what I hear (compiles to faster code and is well-typed), but I can't find any dang tutorials for it.
14:40:14 <epta> there is a nice irc channel, ask there
14:40:43 <Earnestly> silasm: Not even on their website?
14:40:43 <ski> silasm : i still don't know what "that" in "I feel like you don't really learn that until you're writing ..." refers to
14:40:51 <silasm> epta: I'll keep that in mind if I ever go back to it. I have more things on my plate now and haven't bothered to go down that path for a while.
14:40:57 <skypers> I’d like to combine mapMaybe and doesDirectoryExist
14:40:58 <skypers> any idea?
14:41:10 <ski> silasm : btw, re Mercury, you're aware of #mercury, right ?
14:41:14 <skypers> like, getting all directories from a directory
14:41:19 <triliyn> :t mapMaybe
14:41:20 <lambdabot> (a -> Maybe b) -> [a] -> [b]
14:41:21 <silasm> ski: ohhh, "that" refers to "learning a new paradigm is scores harder than learning a new language in the same paradigm"
14:41:44 <skypers> getDirectoryContents >>= mapM (doesDirectoryExist >=>  ?)
14:41:48 <skypers> you got the idea.
14:42:07 <joelteon> huh
14:42:12 <joelteon> all of a sudden, concurrent-state has 55 downloads
14:42:14 <joelteon> i don't think all of those are me
14:42:22 <joelteon> does hackage count downloads from the uploader?
14:42:59 <bitemyapp> silasm: the impression I got was that Idris is something you learn side-by-side with Agda.
14:43:03 <bitemyapp> silasm: using the resources for both.
14:43:08 <bitemyapp> silasm: also the idris IRC channel is great.
14:43:22 <skypers> ooh
14:43:26 <skypers> maybe with filterM actually
14:43:31 <skypers> gonna try it
14:43:52 <triliyn> filterM is nice
14:43:55 <silasm> bitemyapp: yeah I'm on #idris all the time. I think working through sf is fun enough in itself that I'll finish that anyways (maybe in idris itself now that it's got some more tactics).
14:43:56 <chrisdotcode_> @src liftIO
14:43:57 <lambdabot> Source not found. Just try something else.
14:44:02 <skypers> sounds great yeah
14:44:56 <skypers> :t getDirectoryContents
14:44:57 <lambdabot> Not in scope: `getDirectoryContents'
14:45:07 <skypers> I have my function \o
14:45:23 <skypers> getDirectoryContents  >=> filterM doesFileExist
14:45:27 <skypers> so.neat.
14:45:27 <silasm> bitemyapp: that said I have no intention of using Coq anywhere else. Its punctuation infuriates me for some reason.
14:45:55 <gabor> silasm: http://www.mercurylang.org/documentation/documentation.html
14:46:19 <skypers> oh
14:46:22 <skypers> there’s no partitionP
14:46:25 <silasm> gabor: I... don't know how I didn't find that before.
14:46:27 <skypers> partitionM
14:46:29 <skypers> that’s too bad
14:47:01 <silasm> gabor: thanks, if I ever find the time to study Mercury I'll use that (and #mercury, of course).
14:47:06 <gabor> silasm: it is only recently on github
14:47:08 <jrmithdobbs> i have weird philisophical question that's not directly related to haskell but http REST
14:47:28 <skypers> hey what do you think to add partitionM to Control.Monad?
14:47:39 <skypers> I really don’t understand why it’s not already thehe
14:47:41 <skypers> there*
14:48:43 <skypers> because if I want to get files and directories
14:48:54 <jrmithdobbs> if you have an entry lookup (think of it as Map Text Something -> Text -> Something) you want to perform via http in an otherwise rest-ful app, but the lookup requires passing a large json hash into it (but it behaves purely otherwise, always the same transform based on the input and some other known shared state) what kind of request should that be?
14:49:13 <jrmithdobbs> I mean, technically, it *should* be a get but cramming a huge json structure into PATH_INFO just seems wrong
14:49:40 <skypers> I have to do that: do { entries <- getDirectoryContents dir; files <- filterM doesFileExist entries; dirs <- filterM doesDirectoryExist entries }
14:49:44 <skypers> this is redundant
14:49:53 <skypers> something like:
14:50:20 <Twey> partitionM seems useful
14:50:28 <jrmithdobbs> or should i give up and just say the actual usefulness of this functionality is more important than idealogically conforming to REST
14:51:08 <skypers> (files,dirs) <- second (fst . filterM doesDirectoryExist) . partitionM doesFileExist <=< getDirectoryContents
14:51:20 <skypers> yeah Twey, partitionM seems useful!
14:51:33 <jrmithdobbs> no opinions on that? that seemed like the kind of thing people around here would have very strong opinions about =/
14:52:00 <ski> silasm : ok
14:54:09 * hackagebot snaplet-postgresql-simple 0.4.1.1 - postgresql-simple snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-postgresql-simple-0.4.1.1 (DougBeardsley)
14:54:42 <Twey> skypers: You could do something like getDirectoryContents dir >>= mapM (\file → (file,,) <$> doesFileExist file <*> doesDirectoryExist file) and then use a normal partition on the result of that
14:54:51 <joelteon> when does hackage generate documentation for new packages?
14:54:51 <Twey> I'm pretty sure there should be a nicer way to write that, too
14:55:41 <gabor> joelteon: when compiling it
14:56:54 <shachaf> :t liftA3 liftA2 (,,) doesFileExist doesDirectoryExist -- don't try this at home
14:56:55 <lambdabot> FilePath -> IO (FilePath, Bool, Bool)
14:57:21 <joelteon> gabor: is there a build log?
14:57:30 <skypers> liftA3 liftA2
14:57:39 <skypers> how can you even think of that :D
14:57:39 <Twey> Ah, beaten to it
14:58:02 <gabor> joelteon: yes there is
14:59:09 <gabor> joelteon: e.g. http://hackage.haskell.org/package/thrist-0.3.0.1/reports/1/log
14:59:10 <Twey> skypers: So there you go — it's just getDirectoryContents dir >>= mapM (liftA2 liftA2 (,,) doesFileExist) <&> map fst . partition snd
14:59:11 <joelteon> oh
14:59:16 <Twey> Ick
14:59:38 <skypers> huhu
14:59:49 <skypers> @let partitionM :: (Monad m) => (a -> m Bool) -> [a] -> m ([a],[a]); partitionM p l = foldM (\(y,n) x -> do {b <- p x; return $ if b then (y++[x],n) else (y,n++[x])}) ([],[]) l
14:59:50 <lambdabot>  Defined.
15:00:12 <skypers> might be slow on huge lists because of the (++)
15:00:13 <ski> @type Control.Monad.ST.stToIO
15:00:14 <lambdabot> ST RealWorld a -> IO a
15:00:23 <Twey> skypers: So there you go — it's just getDirectoryContents dir >>= mapM (liftA2 fmap (,) doesFileExist) <&> map fst . partition snd
15:00:33 <skypers> “just”
15:00:33 <gabor> joelteon: just shorten the URL to see administrative stuff
15:00:38 <ski> pondering whether `(ST RealWorld a -> ST RealWorld b) -> (IO a -> IO b)' would be safe
15:00:40 <Twey> Assuming you only ever have files and directories
15:00:48 <skypers> liftA2 fmap (,) -> brain overhead
15:00:55 <skypers> overheat*
15:01:24 <companion_cube> :t liftA2 fmat (,)
15:01:25 <lambdabot>     Not in scope: `fmat'
15:01:26 <lambdabot>     Perhaps you meant one of these:
15:01:26 <lambdabot>       `fmap' (imported from Control.Monad.Writer),
15:01:28 <companion_cube> :t liftA2 fmap (,)
15:01:29 <lambdabot> Functor f => (a -> f b) -> a -> f (a, b)
15:01:39 <companion_cube> oh my
15:01:47 <ski> oh, it's `graph'
15:03:27 <skypers> seriously
15:03:33 <skypers> liftA2 does what
15:03:38 <skypers> it takes a binary function
15:03:48 <skypers> two values in applicative
15:03:51 <skypers> and create another one
15:03:56 <skypers> right?
15:03:59 <skypers> like hm
15:04:03 <dgpratt> lambda_male, has anyone mentioned to you (or were you aware) that Rust has pattern matching in the style of Haskell?
15:04:09 * hackagebot mongodb-queue 0.4 - message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.4 (GregWeber)
15:04:16 <skypers> > liftA2 (+) (Just 2) (Just 5) == Just 7
15:04:19 <lambdabot>  True
15:04:21 <skypers> YES
15:05:10 <gabor> liftA2 (+) (Just 2) (Nothing) == Just 7
15:05:16 <skypers> so liftA2 fmap (,) just applies (,) <$> to the rest
15:05:17 <skypers> which is
15:05:22 <gabor> > liftA2 (+) (Just 2) (Nothing) == Just 7
15:05:23 <lambdabot>  <hint>:1:31: lexical error at character '\FS'
15:05:55 <gabor> > liftA2 (+) (Just 2) (Nothing)
15:05:56 <lambdabot>  Nothing
15:06:13 <skypers> that’s quite logic
15:06:13 <thebnq>  > liftM2 (+) (Just 2) (Just 5) == Just 7
15:06:22 <skypers> because >>= discards everything if we have nothing
15:06:26 <thebnq> > liftM2 (+) (Just 2) (Just 5) == Just 7
15:06:28 <lambdabot>  True
15:06:58 <thebnq> i'm assuming liftA and liftM are the same thing
15:07:10 <skypers> > liftA2 (<|>) Nothing (Just "hi!")
15:07:11 <lambdabot>  Nothing
15:07:15 <skypers> huh?
15:07:23 <skypers> oh yes
15:07:31 <skypers> that’s because we’re in Maybe
15:08:00 <skypers> thebnq: well, they’re defined the same way, but liftM is more general
15:08:22 <frege> > \x -> x+1
15:08:23 <lambdabot>  <Integer -> Integer>
15:08:39 <piezoid> liftA2 fmap (,) use the ((->) a) instance
15:08:45 <thebnq> true, i suppose that means two seperate names is still needed :(
15:08:57 <dgpratt> skypers, don't you mean liftA is more general?
15:09:02 <skypers> no dgpratt
15:09:10 <frege> > let f = \x -> x+1 in f 10
15:09:11 <lambdabot>  11
15:09:22 <frege> oh cool!
15:09:28 <frege> I didn't think that would work
15:09:29 <ski> `liftA' is more general
15:09:38 <dgpratt> ^
15:09:40 <ski> > (\x -> x+1) 10
15:09:42 <lambdabot>  11
15:09:45 <ski> frege : why not ?
15:09:55 <skypers> why is it more general?
15:10:03 <frege> ski: I'm not that open minded coming from python and c, ..
15:10:05 <skypers> I’d say Monad generalizes Applicative in some sense
15:10:12 <dgpratt> opposite
15:10:12 <ski> because every monad is an applicative functor
15:10:23 <ski> but not every applicative functor is a monad
15:10:30 <skypers> hm you’re right
15:10:36 <ski> so `liftA' applies in some cases where `liftM' doesn't
15:11:06 <Axman6> all monads are applicatives but not all applicatives are monads
15:11:32 <skypers> sure
15:11:49 <gabor> because Monad is more specialized than Applicative, it can assume more and perform more complicated things
15:11:57 * ski tries to recall a nice example of a non-monad applicative functor he saw a couple of days ago
15:12:16 <skypers> ski: a tree?
15:12:20 <dgpratt> isn't parsing a motivating example of Applicatives vs Monads?
15:12:25 <ski> yes, `Applicative' is weaker than `Monad'
15:12:36 <the_berserker> @pl \l -> (sum l) / (len l)
15:12:36 <lambdabot> liftM2 (/) sum len
15:12:37 <skypers> yeah, I use <|> and <?> a lot
15:12:51 <ski> skypers : which kind of tree ?
15:13:15 <ski> dgpratt : i think this was another one
15:13:19 <skypers> a binary tree?
15:13:33 <ski> with elements in nodes or in leaves ?
15:13:40 <frege> > (\x -> \y -> x+y) 4 2
15:13:41 <skypers> nodes
15:13:41 <lambdabot>  6
15:13:49 <ski> > (\x y -> x+y) 4 2
15:13:50 <lambdabot>  6
15:14:06 <skypers> > 4 + 2
15:14:07 <lambdabot>  6
15:14:12 <skypers> > 6
15:14:14 <lambdabot>  6
15:14:15 <frege> right
15:14:16 <skypers> NAILED YOU
15:14:22 <skypers> :)
15:14:46 <ski> skypers : how is your `(<*>)' working there ?
15:14:54 <skypers> > [1..4] <*> [2,3,4]
15:14:55 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
15:14:56 <lambdabot>    arising from the ambiguity check for `e_114234'
15:14:56 <lambdabot>  from the context (GHC.Enum.Enum (a -> b),
15:14:56 <lambdabot>                    GHC.Num.Num (a -> b),
15:14:56 <lambdabot>                    GHC.Num.Num a)
15:15:04 <skypers> > (+) <$> [1..4] <*> [2,3,4]
15:15:06 <skypers> ski:
15:15:06 <lambdabot>  [3,4,5,4,5,6,5,6,7,6,7,8]
15:15:06 <skypers> hm
15:15:10 <jle`> i've used the Applicative instance for (->) a much, much more than i've ever used the monad instance
15:15:17 <jle`> actaully i don't remember ever using the monad instance...
15:15:21 <ski> skypers : for your trees, not for lists
15:15:24 <jle`> in real code
15:15:24 <skypers> I recall now: I think it’s a dead-end
15:15:28 <jle`> but i use the applicative all the time
15:15:30 <skypers> trees can’t be applicative
15:15:43 <the_berserker> @pl -> \b l -> (sum (map (^b) l))/(len l)^b
15:15:43 <lambdabot> (line 1, column 1):
15:15:44 <lambdabot> unexpected "-"
15:15:44 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:15:55 <the_berserker> @pl \b
15:15:55 <lambdabot> (line 1, column 3):
15:15:56 <lambdabot> unexpected end of input
15:15:56 <lambdabot> expecting letter or digit, operator, pattern or "->"
15:16:00 <bitemyapp> skypers: you can try to embed trees in lists of lists.
15:16:03 <skypers> jle`: I use the monad instance with join
15:16:29 <skypers> in order to duplicate argument
15:16:36 <skypers> > join (*) 3
15:16:37 <lambdabot>  9
15:16:40 <skypers> §§
15:16:51 <jle`> zip tries are conceivably applicative
15:16:58 <the_berserker> @pl \b l -> (sum (map (^b) l))/((^) (length l) b)
15:16:58 <lambdabot> ap (ap . (((/) . sum) .) . map . flip (^)) (flip ((^) . length))
15:17:00 <jle`> *trees
15:17:05 <ski> @let data Tree a = T | N a (Tree a) (Tree a)
15:17:05 <lambdabot>  .L.hs:153:20:
15:17:05 <lambdabot>      Ambiguous occurrence `Tree'
15:17:06 <lambdabot>      It could refer to either `L.Tree', defined at .L.hs:152:6
15:17:06 <lambdabot>                            or `Data.Tree.Tree',
15:17:06 <lambdabot>                               imported from `Data.Tree' at .L.hs:104:1-16
15:17:15 <jle`> oops
15:17:22 <skypers> what is L?
15:17:28 <skypers> lambdabot’s module?
15:17:31 <ski> @let data BinTree a = T | N a (BinTree a) (BinTree a) deriving (Show,Eq)
15:17:32 <joelteon> do I have to list my changelog in extra-source-files?
15:17:34 <lambdabot>  Defined.
15:17:41 <Twey> skypers: L is where lambdabot saves its definitions
15:17:47 <skypers> ok
15:17:51 <skypers> funny
15:18:17 <Twey> @let longNameNobodyElseNeeds = 5
15:18:19 <lambdabot>  Defined.
15:18:25 <Twey> > L.longNameNobodyElseNeeds
15:18:29 <lambdabot>  5
15:19:11 * hackagebot mongodb-queue 0.4.0.1 - message queue using MongoDB  http://hackage.haskell.org/package/mongodb-queue-0.4.0.1 (GregWeber)
15:19:40 <skypers> :t L.partitionM
15:19:42 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m ([a], [a])
15:19:44 <skypers> yeah
15:20:58 <ski> hm, does the new lambdabot no longer have `{-# LINE 1 "<local>" #-}' near the end of the initial `L.hs' ?
15:21:56 <skypers> btw
15:22:15 <skypers> is it common to use lift{A,M}2 in production code?
15:22:25 <johnw> certainly
15:22:28 <skypers> that functions are nice but sometimes sounds very hard to understand to me
15:22:46 <skypers> I had hard times to get into liftM2 (>>)
15:23:28 <johnw> an example of that would be applying monadic functions to a Maybe within IO
15:24:04 <jle`> i don't use liftA/M, I use <$> and <*>
15:24:11 * hackagebot concurrent-state 0.3.3.2 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.3.3.2 (JoelTaylor)
15:24:15 <jle`> oh
15:24:29 <skypers> I also use <$> and <*> a lot
15:24:40 <skypers> especilly within IO
15:24:59 <skypers> like ctor <$> pickFromIO <*> pickFromIO <*> …
15:25:11 <jle`> i don't really know of a good use case for liftA/M where <$>/<*> can be used
15:25:52 <johnw> how about when you don't have the arguments
15:26:04 <etandel> <$> and <*> instead of list comprehensions, anyone?
15:26:16 <skypers> it can also be used not to repeat the argument
15:26:32 <skypers> for the reader monad for instance
15:26:45 <skypers> (the ((->) a) I mean)
15:27:44 <jle`> etandel: ah yeah
15:27:51 <jle`> i actaully rarely use list comprehensions
15:28:05 <skypers> so do I
15:28:08 <jle`> there is a cute use case though
15:28:12 <jle`> where they make things more expressive
15:29:00 <jle`> > let filterJust xs = [ x | Just x <- xs ] in [Just 10, Just 4, Nothing, Just 3]
15:29:01 <lambdabot>  [Just 10,Just 4,Nothing,Just 3]
15:29:38 <jle`> > let filterJust xs = [ x | Just x <- xs ] in filterJust [Just 10, Just 4, Nothing, Just 3]
15:29:40 <lambdabot>  [10,4,3]
15:30:06 <jle`> useful for filtering a list of data by their specific constructor
15:30:16 <jle`> it's a pain otherwise
15:30:38 <skypers> jle`:
15:30:54 <skypers> > catMaybes [Just 10, Just 4, Nothing, Just 3]
15:30:56 <lambdabot>  [10,4,3]
15:30:57 <skypers> :)
15:31:31 <jle`> in general :P when you want to filter a list of Algebraic Data Types by their constructor
15:31:39 <skypers> sure sure :D
15:31:58 <etandel> indeed, I just used a stupid filter (/= Nothing) hack today. That would've made a lot better.
15:32:01 <etandel> =o
15:32:14 <skypers>  /= Nothing?
15:32:15 <skypers> what.
15:32:24 <etandel> it works, don't judge. u.u
15:32:24 <skypers> you just mean isJust?
15:32:31 <jle`> keeps you from defining an "isParagaph" function, for example, for Pandoc types
15:32:39 <skypers> :t isJust
15:32:40 <lambdabot> Maybe a -> Bool
15:32:48 <skypers> :t (/=Nothing)
15:32:49 <lambdabot> Eq a => Maybe a -> Bool
15:32:58 <skypers> you have a useless constraint
15:33:04 <etandel> skypers: probably. this is my second week of haskell, so don't take what I say seriously.
15:33:10 <skypers> oh
15:33:11 <skypers> ok
15:33:14 <skypers> no problem :)
15:33:21 <etandel> =)
15:33:41 <supki> :t isn't _Nothing
15:33:42 <lambdabot> Maybe a -> Bool
15:34:05 <etandel> Haskell is making me feel like a total programming noob, but I'm loving it.
15:34:10 <bitemyapp> etandel: good :)
15:34:19 <skypers> etandel: that’s the feeling at first
15:34:33 <jle`> hasochism
15:34:34 <skypers> one year later, you can’t go back to C++ ;)
15:34:43 <qrada> when i started to learn haskell i hypnotized myself into thinking that i had never programmed anything
15:34:46 <qrada> ;f
15:34:48 <skypers> even two years later
15:34:53 <skypers> I still think noob
15:34:54 <shiona> skypers: which may or may not be a good thing
15:35:07 <skypers> shiona: I actually think it’s a good thing
15:35:10 <hpc> there's always more things to not understand ;)
15:35:21 <skypers> feeling like superman is never a good thinks
15:35:29 <etandel> Well, once you go c++, you never want to to back to c++.
15:35:29 <jle`> http://lukeplant.me.uk/blog/posts/why-learning-haskell-python-makes-you-a-worse-programmer/
15:35:38 <chrisdotcode_> I can't go back to any other language after 7 months of haskell...
15:35:39 <shiona> I would still need to finish the stuff I had going when I started haskell two years ago
15:35:40 <skypers> ahahah etandel
15:35:48 <shiona> that's in c++
15:35:50 <greg`> jellybean :: (Misty m) => m (m a) -> m a
15:35:55 <skypers> chrisdotcode_: yeah
15:35:59 <skypers> this is actually an issue
15:36:01 <greg`> jellybean = banana id
15:36:02 <greg`> ?
15:36:03 <jle`> etandel++
15:36:06 <skypers> for our job’s languages :D
15:36:20 <skypers> I do perl at work
15:36:24 <skypers> it’s really painful.
15:36:26 <chrisdotcode_> skypers: yeah, it's a shame that haskell has broken me beyond repair ... or has it fixed me?
15:36:27 <etandel> ouch
15:36:29 <hpc> i like perl
15:36:37 <hpc> it's my favorite functional language
15:36:42 <skypers> hpc: ahahah
15:36:44 <hpc> (haskell my favorite imperative)
15:36:51 <skypers> :)
15:36:53 <hpc> i say that with zero sarcasm
15:36:55 <jle`> @src join
15:36:55 <lambdabot> join x =  x >>= id
15:36:57 <skypers> yeah
15:37:02 <skypers> troll powered™
15:37:05 <silasm> what I like about haskell is that its reward function scales at least quadratically with respect to learning
15:37:06 <etandel> I do Python, so it's not actually that bad. And it taught me things like filter, map, partial applications etc. before i started haskell
15:37:25 <etandel> so did Lua
15:37:35 <greg`> jle` really?
15:37:40 <jle`> greg`: i guess so :)
15:37:47 <Twey> I hate all programming languages
15:37:47 <hpc> i hear good things about lua but i am always hesitant because my only experience with it is supreme commander
15:37:51 <Twey> They're all terrible
15:37:52 <greg`> id doesnt have type ( a -> m a)
15:37:57 <skypers> @pl x >>= id
15:37:57 <lambdabot> join x
15:38:05 <hpc> where it managed to bring an i7 to a crawl no matter what settings i used
15:38:15 <silasm> though I don't know how the axes are measured, so that could mean anything.
15:38:27 <greg`> its the solution i came up with but i am thinking its not right
15:38:27 <skypers> Twey: well, I don’t really know issues with Haskell
15:38:45 <jle`> greg`: you can think of bana as giving you access to the a inside m a
15:38:45 <skypers> C++ is terrible parsing issues, errors reporting, side-effects, and so on
15:38:50 <skypers> Java is… Java.
15:38:53 <jle`> hm
15:38:56 <etandel> hpc: Lua is awesome for the things it was created for (embedding in larger applications, gluing code etc.), but i wouldn't use it for systems programming.
15:38:57 <skypers> Haskell has a hard learning-curve
15:38:57 <greg`> thats what i am doing
15:38:58 <jle`> aactually wait you're right
15:39:00 <skypers> that’s all to me
15:39:07 <greg`> but i just feel its wrong
15:39:11 <jle`> oh
15:39:19 <silasm> skypers: quadratic (at least)
15:39:21 <jle`> it must be the Category id
15:39:25 <Twey> skypers: Programming is just wrong.  It takes vast amounts of effort to do even simple things.
15:39:27 <jle`> @src id
15:39:27 <lambdabot> id x = x
15:39:27 <greg`> meaning?
15:39:46 <etandel> hpc: and LuaJIT is probably the fastest JIT around, so it's great for gaming.
15:39:48 <qrada> i wrote my first haskell program this week.. super nub status but i love it so far: https://github.com/adarqui/relocated-hs
15:39:50 <Twey> Things you can explain to another human in five minutes take days to code up on a computer
15:39:57 <jle`> hm
15:39:59 <joelteon> Isn't there a package that generalizes forkIO to MonadIO?
15:40:02 <jle`> okay it's the normal id
15:40:05 <qrada> i wrote that in go/node prior to this.. it's hard to go back and look at the go/node code now
15:40:12 <jle`> think about what banana does
15:40:18 <hpc> etandel: yeah, it wasn't actually a deficiency of lua, just the devs truly suck at writing ai
15:40:19 <jle`> it takes the value inside the outer Misty
15:40:21 <greg`> have i just broken haskell
15:40:22 <greg`> lol
15:40:25 <jle`> does something to it that returns a Misty
15:40:33 <jle`> and then returns the Misty that that banana function returned
15:40:33 <greg`> i know
15:40:40 <jle`> so when you banana m (m a)
15:40:40 <greg`> i know it works
15:40:48 <skypers> 00:37 < joelteon> Isn't there a package that generalizes forkIO to MonadIO?
15:40:49 <jle`> the inside (m a) is passed to your function
15:40:57 <skypers> liftIO . forkIO?
15:41:00 <joelteon> so it's just called fork
15:41:05 <jle`> and then using id, you return nothing but the inside (m a)
15:41:07 <joelteon> yeah but forkIO still takes an IO action
15:41:11 <greg`> i know it works
15:41:12 <Twey> skypers: Haskell suffers slightly less from this sort of thing than most other languages, but it's still horrible.  And its type system makes it awkward to say things I want to say even compared to something like Agda.
15:41:19 <jle`> greg`: ah ok
15:41:25 <Axman6> greg`: having fun? =)
15:41:26 <greg`> but its wrong
15:41:30 <skypers> Twey: example?
15:41:33 <joelteon> skypers: liftIO . forkIO is type IO () -> m ThreadId
15:41:36 <joelteon> not m () -> m ThreadId
15:41:45 <greg`> Axman6 yes
15:41:49 <Yaniel> this channel never disappoints.. one week it should be #optics and the other #fruitsalad
15:41:56 <Twey> Heh
15:41:59 <skypers> :D
15:42:04 <Axman6> I'm not sure forkIO makes a lot of sense in many MonadIO instances
15:42:07 <yayutf_> Yaniel: don't forget the barbed wire
15:42:15 <joelteon> it often does
15:42:20 <greg`> id doesnt have type a -> m a
15:42:25 <joelteon> well, in *my* case, it does
15:42:26 <skypers> Twey: I actually think Haskell is really nice to express things
15:42:30 <skypers> filter (not . null)
15:42:31 <skypers> for instance
15:42:37 <skypers> is really convenient to read and write
15:42:38 <Axman6> greg`: but, it does have type m a -> m a
15:42:50 <joelteon> and it might make sense for MonadIO m => ReaderT r m a
15:42:52 <joelteon> for example
15:42:55 <skypers> the single exception is… Control.Lens.
15:42:57 <Twey> skypers: Haskell's type and value levels are very separate, so whenever you want to pass a type value to the value level you have to mess about with a couple of layers of typeclasses and singletons and stuff
15:42:59 <skypers> which is awful.
15:43:00 <greg`> i know that
15:43:09 <greg`> but thats not what it needs
15:43:19 <Twey> skypers: It's great for expressing things, compared to most other languages.  It's just that programming is terrible in general.
15:43:20 <Axman6> joelteon: yeah for reader it does. not State though (except that package someone in here released using TVars, which looked cool)
15:43:31 <joelteon> Axman6: yeah, I wrote that package
15:43:33 <joelteon> that's why I'm asking
15:43:39 <skypers> Twey: maybe it doesn’t fit you? :)
15:43:42 <greg`> banana :: (a -> m a) -> m a -> m b
15:43:43 <Axman6> ah, well good on you =)
15:43:46 <Twey> skypers: Control.Lens increases convenience significantly
15:43:55 <joelteon> layers looks ok
15:43:58 <Twey> skypers: No, we just don't know how to program yet
15:44:07 <joelteon> but it looks a little heavy
15:44:08 <skypers> convenience, maybe
15:44:09 <greg`> i just want to know why
15:44:17 <skypers> readability, definitely not
15:44:35 <skypers> 00:41 < Twey> skypers: No, we just don't know how to program yet
15:44:37 <skypers> ?
15:44:38 <Twey> skypers: All our current languages feel like baby-speak compared to natural languages, let alone something like DNA, which encodes incredibly complex programs in just a gigabyte or so of data
15:44:43 <skypers> do you have descents arguments?
15:44:56 <Twey> Sussman did a video on it if you're interested
15:45:05 <Twey> https://www.google.co.uk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&ved=0CC4QFjAA&url=http%3A%2F%2Fwww.infoq.com%2Fpresentations%2FWe-Really-Dont-Know-How-To-Compute&ei=nlXgUob-HIG2hQee3IGgBA&usg=AFQjCNG_hoY0ULRirSNZsDp0QrFHqjzfgQ&sig2=gAcvYuQqkBTpxuKAEI3-Hg&bvm=bv.59568121,d.ZG4 I think
15:45:09 <joelteon> maybe lifted-base
15:45:10 <Twey> Dammit, Google
15:45:15 <skypers> huh Twey
15:45:17 <jle`> haha
15:45:29 <simpson> CS is only about 100 years old or so; we don't have PE-style certification; we reinvent our best practices every decade.
15:45:29 <skypers> we actually do great stuff with our « terrible languages »
15:45:34 <simpson> We don't know how to program.
15:45:41 <skypers> video games, simulation, embedded software in space
15:45:50 <Yaniel> how expressive are natural languages actually compared to DNA? :D
15:46:01 <thebnq> actually we pay software developers to spend hours debugging to figure it out :|
15:46:01 <Twey> skypers: Absolutely.  It's amazing, and very useful.  But once you realize how limited it is compared to what's evolved already, it feels a little frustrating.  :þ
15:46:05 <Yaniel> skypers: especially the in space part
15:46:19 <simpson> skypers: Have you used Ada or Eiffel? The world of e.g. space-station code is *very* different from the world of video games.
15:46:25 <jle`> Twey: to be fair, DNA is probably more comparable to computer architectures/processors/von neumann architecture than programming languages
15:46:30 <joelteon> maybe monadIO
15:46:35 <jle`> *than to
15:46:40 <identity> do you guys think that programming(or perhaps rather software engineering) can be compared to, say, structural engineering? now that we're discussing what we can do with programming languages and so on
15:46:41 <joelteon> but the only instance for MonadIO is IO
15:46:48 <joelteon> so it doesn't look like it's in wide usage
15:46:49 <Twey> Yaniel: Not nearly as much, but that's okay because the computers that process it are very flexible.
15:46:50 <twiceler> And still, a gigabyte would be a huge binary!
15:46:51 <greg`> it kinda works because banana   id m m a = id m a, but id doesnt do what the type spec says
15:47:00 <Twey> twiceler: Almost a fifth the size of Firefox :þ
15:47:00 <bitemyapp> identity: no
15:47:05 <hpc> identity: there's very little in common between software and any physical science
15:47:20 <Twey> jle`: Eh, it's all the same at a semantic level
15:47:24 <Twey> Just implementation details
15:47:31 <identity> because I was wondering about the scale of some of the greatest structural engineering projects, and how they can be completed without, say, the building imploding
15:47:33 <bitemyapp> jle`: DNA has no semantics.
15:47:35 <skypers> 00:43 < simpson> skypers: Have you used Ada or Eiffel? The world of e.g.  space-station code is *very* different from the world of video  games.
15:47:39 <skypers> I can imagine
15:47:48 <skypers> Ada is used for space-station?
15:47:50 <bitemyapp> identity: that's why you can't compare programming to them.
15:47:54 <skypers> I thought it was assembly
15:47:55 <greg`> sorry to bother jle' but am i just plain wrong, or looking at things too closely
15:47:57 <jle`> Twey: yeah, but whoever programmed DNA did not do it at the DNA level, they did it at some high level, and it was compiled to DNA via natural selection
15:48:02 <identity> while bugs in software often result in .. well, catastrophic failures
15:48:13 <hpc> they may have used to use ada
15:48:15 <identity> (of course buildings do collapse etc)
15:48:16 <simpson> I don't know what's currently used, but Ada was developed in part because existing languages weren't sufficient.
15:48:22 <identity> yeah, I was just wondering about this today due to a discussion
15:48:24 <hpc> afaik the only place to majorly use it nowadays is dod
15:48:28 <simpson> That was the 70s though.
15:48:44 <hpc> anyway, from what i understand working on space station code is quite pleasant
15:48:50 <skypers> Twey: you say « what’s evolved »
15:48:54 <skypers> and « frustrating »
15:48:58 <skypers> what are you talking about?
15:49:02 <jle`> idk i can sort of compare programming to things like building clocks or machines or automation, it's all about fitting together abstractions
15:49:03 <hpc> there's absolute mountains of process that guard against bugs
15:49:13 <bitemyapp> systems programming in space programs usually means C, some but not much asm. there used to be some Forth and Lisp running around.
15:49:20 <yayutf_> for really important projects, there's no substitute for figuring out _exactly_ what you want, having several people look it over extremely carefully, and making sure programmers never work insane hours
15:49:24 <bitemyapp> it's a very different world.
15:49:37 <simpson> skypers: If we, as a fraternity of engineers, understood the Good Life and how to write Good Code, then why do things like PHP keep existing?
15:49:45 <greg`> anyone hack haskell for a living in uk
15:49:55 <identity> simpson: money
15:50:06 <yayutf_> simpson: because they're quick-and-dirty, and that's often what's needed
15:50:12 <identity> simpson: because idealistic programmers aren't the ones who choose the programming languages for products and platforms
15:50:16 <jle`> greg`: try manually applying it to specific Misty's and see if it does what you want
15:50:16 <bitemyapp> simpson: PHP == cheap labor done quick
15:50:16 <skypers> simpson: PHP exists because of the fact we – good programmers – are in minority.
15:50:17 <yayutf_> we understand structural engineering, but people still build shoddy treehouses and shanties
15:50:38 <simpson> identity, yayutf_, bitemyapp : So the problem is that we don't have PE-style certifications? >:3
15:50:40 <greg`> jle' it does, but i feel it shouldnt
15:50:46 <jle`> > Just Nothing >>= id
15:50:48 <lambdabot>  Nothing
15:50:49 <yayutf_> simpson: in a word, no.
15:50:49 <bitemyapp> simpson: we do not want that.
15:50:49 <hpc> more commonly, people take existing good houses that require maintenance and make complete pants of it
15:50:55 <jle`> > Just (Just 5) >>= id
15:50:56 <lambdabot>  Just 5
15:51:08 <jle`> > (Nothing :: Maybe (Maybe Int)) >>= id
15:51:09 <lambdabot>  Nothing
15:51:14 <bitemyapp> simpson: we stand as one of the most meritocratic professions in existence. We also don't want to attach cement blocks to the feet of progress.
15:51:31 <skypers> Haskell would fail to make it through with those peopl
15:51:31 <skypers> e
15:51:35 <Twey> jle`: The difference between a compiled language and an uncompiled language is largely one of the intelligence of the reader.  The smarter you are, the more easily you can determine the purpose of a piece of code.  Imperative programming is a good example: if you don't know anything about programming (apart from the syntax), for (int i = 0; i < n; ++i) t += a[i]; looks like so much rubbish: it adds something
15:51:35 <yayutf_> simpson: have you seen the kind of shit that passes as certification, or an "internet drivers license", or the general sense that good technical people have about things like mcse certs?
15:51:37 <Twey> to a ‘t’ repeatedly for every item of a?  But with sufficient intelligence you can figure out that it's summing the first n elements of the array (and that indirection is why imperative languages are generally less expressive than functional languages, which do the same thing but have better support for hiding it away under abstractions).
15:51:39 <shachaf> simpson: "fraternity" doesn't seem like a very good word here.
15:51:41 <bitemyapp> skypers: right, we'd end up stuck with Java.
15:51:49 <simpson> bitemyapp: Okay. Why do non-good and low-quality things keep existing in our profession if we are meritocratic?
15:51:49 <jle`> greg`: it might help if you understnad that >>= is just fmap and join
15:51:57 <bitemyapp> simpson: because we're meritocratic.
15:52:10 <bitemyapp> simpson: "good enough" is just that. There's nothing wrong with people futzing around with PHP and JS where they can get away with it.
15:52:11 <skypers> bitemyapp: that’s somewhere worse.
15:52:18 <mmmmm> The latest stable cabal version is 1.18 right? With sandboxes?
15:52:20 <bitemyapp> *I* don't want to work on those projects, but elitism helps nobody.
15:52:23 <bitemyapp> mmmmm: sure.
15:52:25 <simpson> shachaf: I'm drawing deliberate parallels with every other engineering discipline.
15:52:33 <greg`> hmmm thanks jle i  think i understand
15:52:34 <yayutf_> simpson: because they're often considered good enough; because they're often cheap or available; because people usually labor under poor conditions (not enough time, etc) and have to cut corners; because we as a species massively overestimate our ability to get it right
15:52:34 <shachaf> Anyway this whole thing seems way off-topic at this point.
15:52:40 <bitemyapp> simpson: don't, we're not an engineering and there's no structure to cast discipline upon.
15:52:45 <mmmmm> "cabal install cabal" should update it?
15:52:46 <skypers> bitemyapp: my point here is even if PHP, Java and all those crappy languages are digusting, they HAVE to be there
15:52:49 <yayutf_> and attempting to get it -right- tends to be very time-intensive and often go horribly wrong anyhow
15:52:51 <skypers> Haskell is not for all
15:52:57 <jle`> greg`: you can think of successive >>='s as building up successive layers of am m(m(m(m(a))) onion...and then "squashing it all down" at the end
15:53:01 <skypers> just like Lisp, Scala or C++
15:53:16 <jle`> the "logic"/"computation" of the monad occurs during the squashing process
15:53:17 <skypers> there must be lol-languages
15:53:23 <yayutf_> simpson: even structural engineering goes wrong surprisingly often; i suppose you've heard of the tacoma narrows bridge, the recent skyskraper in the uk that melts cars, etc
15:53:39 <Yaniel> melts cars?
15:53:43 <greg`> jle i understand how it works
15:53:44 <skypers> (to me Java is a big joke, but it has to be there)
15:53:44 <Twey> Haha, yes
15:53:59 <Twey> Yaniel: We decided it would be a great idea to have a shiny, concave building
15:54:09 <Yaniel> ahaha :D
15:54:10 <identity> Yaniel: sun's reflection
15:54:12 <identity> iirc
15:54:19 <identity> it's pretty funny
15:54:26 <Twey> Turns out that during the summer it focuses the sun's energy into a death ray that moves across the city as the day passes, melting anything it touches
15:54:35 <greg`> i just have an issue with id not maching the type signature (a -> m a) as is required by bind
15:54:41 <yayutf_> Yaniel: http://www.bbc.co.uk/news/magazine-23944679
15:54:43 <bitemyapp> simpson: it takes a very faulty impression of what the essence of programming is to believe we're some kind of engineering discipline that needs licensing.
15:55:02 <skypers> off, ttyl
15:55:05 <bitemyapp> simpson: that you have plenty of other people who believe similarly just reinforces that we're still too young a profession for that to make sense.
15:55:12 <greg`> Twey your from the uj
15:55:13 <greg`> uk
15:55:17 <bitemyapp> ie, nobody knows what in the flying fuck they're talking about.
15:55:33 <greg`> there was a nick name for the building i cant remember what it was
15:55:34 <yayutf_> simpson: licensing would make progress slow to a crawl; we wouldn't -have- haskell, we'd have cobol 3.0
15:55:34 <simpson> bitemyapp: My impression is only that CS is taught under the same umbrella as engineering in universities, not maths.
15:55:40 <yayutf_> greg`: walkie talkie
15:55:59 <StoneToad> simpson: depends on the school
15:56:05 <yayutf_> simpson: it has two roots; one is in math, the other is in electrical engineering. depending on the uni, it'll still be tied to one or the other quite often
15:56:14 <jle`> greg`: hm
15:56:33 <Twey> yayutf_: There's also the school that thinks it ought to be a subfield of physics
15:56:44 <Twey> For which I have some sympathy
15:56:56 <etandel> There will always exist crappy languages as long as there are different languages to choose from; it's just a matter of distribution: it's unlikely that all languages are equal in quality.
15:56:56 <jle`> :t \f -> Just (Just 1) >>= f
15:56:57 <lambdabot> Num a => (Maybe a -> Maybe b) -> Maybe b
15:57:02 <twiceler> Is there a partial order on languages by quality? Is there a language "strictly" better than, say, Java?
15:57:15 <yayutf_> Twey: hmm. While that's definitely a minority view, to some extent I think I see your point
15:57:17 <etandel> for a given definition of quality
15:57:42 <Twey> twiceler: I strongly believe that there is (but also that we have no idea what it is)
15:57:42 <hpc> twiceler: mmmmmaybe?
15:57:55 <hpc> you'd be hard pressed to say haskell is better than haskell+GADTs
15:58:02 <jle`> :t (>>=)
15:58:03 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:58:21 <twiceler> hpc: I do agree with that
15:58:27 <jle`> ah, that's it
15:58:30 <Twey> hpc: But simplicity is also a desirable property
15:58:39 <jle`> greg`: (>>=) is a -> m b
15:58:41 <jle`> not a -> m a
15:59:02 <hpc> Twey: i would argue the addition of GADTs doesn't constitute complexity, but abstraction
15:59:07 <twiceler> Twey: Hmm, but GADTs make things more consistent
15:59:17 <etandel> twiceler: I guess you can say Java is strictly worse than assembly for mcu programming.
15:59:40 <twiceler> maybe Haskell + GADTs - regular Haskell data definitions
15:59:41 <etandel> but java is strictly better then assembly for, say, web development
15:59:56 <greg`> ok so id doesnt match a -> m b does it?
16:00:02 <theorbtwo> I'm actually not sure you can; java-the-language is probably better then assembly for mcu programming... if you can get it to compile down to the bare metal.
16:00:03 <jle`> greg`: in this case, it does
16:00:06 <hpc> twiceler: maybe; ordinary data declarations can almost be seen as sugar for gadts
16:00:09 <twiceler> Right; and even php places where it shines
16:00:10 <jle`> the a is m a
16:00:20 <shachaf> This is way off-topic and drowning out the little bit of Haskell discussion that's trying to happen here.
16:00:21 <jle`> so it's m a -> m b
16:00:30 <greg`> AHA
16:00:32 <greg`> thanks
16:00:33 <jle`> and type inference finds that a ~ b
16:00:55 <shachaf> And "is programming language X better than programming language Y" discussions don't really belong here even if X or Y happens to be Haskell.
16:01:04 <hpc> shachaf: what if they are both haskell?
16:01:20 <thebnq> refl
16:01:21 <yayutf_> hpc: he didn't say xor
16:01:24 <greg`> then there is nothing to discuss
16:01:52 <sdegutis> I'd love to start trying out Haskell.
16:02:00 <jle`> sdegutis: congrats!
16:02:03 <sdegutis> But it's not building correctly for me.
16:02:06 <sdegutis> :'(
16:02:07 <yayutf_> sdegutis: then do!
16:02:08 <hpc> sdegutis: http://tryhaskell.org/
16:02:10 <jle`> drat :/
16:02:14 <greg`> why are you building it?
16:02:21 <Twey> sdegutis: Don't you have binaries for your platform?
16:02:26 <silasm> hpc: Ord requires Eq last time I checked, so assuming Eq is well-behaved, we already know the answer ;)
16:02:27 <greg`> fastest way is to head over to fpcomplete
16:02:28 <jle`> whatever platform you have should have pre-built binaries, except for rare cases
16:02:32 <sdegutis> Because I use homebrew to avoid accidentally doing something irreversible to my Mac OS X system.
16:02:45 <jle`> oh, if you have Mavericks
16:02:45 <greg`> ec2 instance?
16:02:47 <jle`> then
16:02:51 <sdegutis> jle`: I'm SOL?
16:02:59 <jle`> haha i was going to say that but backspaced.
16:03:01 <jle`> there are ways.
16:03:10 <greg`> i haskell on arm
16:03:16 <jle`> but mavericks has wreaked a slight hellstorm as of late
16:03:21 <greg`> that doesnt always go smooth :-\
16:03:23 <joelteon> yeah mavericks is quite a thing
16:03:23 <sdegutis> One of these days I want to make the switch to linux :'(
16:03:26 <roboguy_> hey sdegutis
16:03:30 <jle`> but i suggest looking up tutorials specifically for mavericks and GHC
16:03:31 <sdegutis> Hi roboguy_ :)
16:03:37 <Twey> greg`: Neat!
16:03:37 <shachaf> Plenty of people use GHC on Mac OS X.
16:03:39 <sdegutis> I DONT BELIEVE U R A REAL ROBOT
16:03:43 <sdegutis> re roboguy_
16:03:44 <Twey> greg`: Can't you just compile via LLVM?
16:03:48 <roboguy_> haha, I'm a fake robot
16:03:49 <shachaf> sigh
16:04:06 <jle`> it's possible, so now hopefully you have some keywords to search for
16:04:07 <roboguy_> sdegutis: did you download the Haskell Platform?
16:04:13 <sdegutis> i think ill just look for decent virtual machine software or something.
16:04:16 <sdegutis> roboguy_: nope
16:04:26 <roboguy_> that's probably the best way to get it
16:04:31 <sdegutis> oh hey btw guys
16:04:34 <roboguy_> I'm on OS X too, by the way
16:04:41 <sdegutis> i have a riddle that is totally off topic that i came up with the other day and told my wife and kids
16:04:47 <sdegutis> should i say it in here?
16:04:50 <jle`> unfortunately he is morally opposed to precompiled Haskell
16:05:02 <hpc> sdegutis: #haskell-blah
16:05:30 <jle`> maybe if you make it related to Haskell somehow
16:06:02 <roboguy_> jle`: that is unfortunate
16:06:09 <sdegutis> hpc: nope
16:06:11 <hpc> you must answer me these questions three:
16:06:15 <hpc> what... is your name?
16:06:19 <hpc> what... is your quest?
16:06:27 <hpc> what... the hell is Yoneda?
16:06:29 <sdegutis> i refer you to the relevant xkcd hpc
16:07:04 <jle`> hpc: it's a little unsettling that after all these years i still read that in his clear and exact voice
16:07:39 <jle`> maybe onliy a little
16:14:14 <greg`> so why cant i , banana id m (a -> b) to get (a -> b)
16:14:23 <greg`> confused.com
16:14:52 <jle`> the banana argument has to be a -> m b
16:14:52 <c_wraith> that'll work if m is id
16:15:05 <c_wraith> oh, you're mixing types and terms in one expression
16:15:08 <c_wraith> well that's confusing
16:15:13 <mmmmm> How is my cabal install this broken lol.. I can keep installing the same package over and over
16:15:18 <jle`> so it has to be (a -> b) -> m b
16:15:31 <jle`> id :: c -> c
16:15:35 <jle`> these two cannot be unified
16:15:43 <jle`> for any value of c
16:15:58 <jle`> what son
16:16:24 <greg`> im compiling your response......please wait
16:16:31 <quchen> m = (a ->)
16:16:31 <etandel> Funny, before I started to learn haskell I thought the hardest part would be Monads, Arrows and the like. But now I realize it's getting around ghc error messages.
16:16:54 <hpc> etandel: the trick to ghc errors is to put type signatures on things
16:17:04 <hpc> so it doesn't "infer backwards" and tell you the problem is somewhere else
16:17:34 <hpc> and then just read the words carefully, because it does explain what went wrong but in sometimes mathy language
16:18:18 <etandel> hpc: yeah, I guess it's not that complicated once you get used to it, but for a noob...
16:18:35 <hpc> yeah, it's one of those things you just have to have told to you, not really that learnable
16:26:31 <etandel> hpc: perhaps it would be useful to have a "ghc erros 101" wiki page? Something like "If you have something like X, see if you did Y".
16:26:50 <etandel> Googling around these days I found a wiki page about ghc erros, but it was just a stub.
16:27:45 <etandel> ttp://www.haskell.org/haskellwiki/GHC/Error_messages
16:30:21 <roboguy_> sdegutis: what sort of errors are you getting? are they like C preprocessor-looking errors?
16:30:34 <roboguy_> that's a known issue on OS X and there's a work-around
16:32:21 <intrados> Does anyone know why ghc-vis does this? Prelude Base> :switch
16:32:27 <intrados> <interactive>: Unknown opcode 0
16:33:16 <sdegutis> roboguy_: yes that's what happened for me
16:33:44 <roboguy_> sdegutis: did you get it figured out?
16:33:51 <sdegutis> nope
16:34:39 <carter> sdegutis: whats the error?
16:34:44 <carter> past it
16:34:47 <carter> also use my directions
16:35:11 <carter> https://gist.github.com/cartazio/7131371
16:35:14 <carter> via http://www.haskell.org/platform/mac.html
16:35:27 <carter> also ghc HEAD doesn't have some of the odd problems
16:35:55 <roboguy_> also type holes are pretty awesome!
16:35:58 <carter> AND i have a WIP patch i hope to get  mergediin that will make it even better
16:35:59 <carter> oy hean
16:36:02 <carter> those are cool
16:36:37 <roboguy_> I'm pretty happy with all the cool, new stuff they're doing with ghc now
16:37:20 <carter> roboguy_: you should help out too
16:37:23 <carter> sdegutis: you to soon :)
16:37:26 <carter> *too
16:37:33 <carter> sdegutis: what was the error message?
16:37:55 <roboguy_> carter: that would be really cool. I've thought about it, but I'm not totally sure where to start. I guess the GHC Commentary is probably the place?
16:38:01 <carter> nope
16:38:11 <carter> whats one part of GHC that you care about
16:38:16 <carter> or really really wanna focus on
16:38:21 <carter> GHC's too big to try to first learn everything
16:38:31 <carter> choose some thing you can care about
16:38:33 <carter> and dig deep
16:38:42 <carter> and you'll find fractal many things to do
16:38:47 <carter> and some other stuff along the way
16:38:49 <roboguy_> hmm, I'll have to think about ti
16:38:53 <carter> and vover time you'll learn more things
16:38:53 <roboguy_> it
16:39:17 * hackagebot dominion 0.1.0.4 - A simulator for the board game Dominion.  http://hackage.haskell.org/package/dominion-0.1.0.4 (AdityaBhargava)
16:39:20 <roboguy_> the optimization system interests me quite a bit, but I'm not sure that would be a good place to start
16:39:31 <carter> roboguy_: unless you're familiar with that already
16:39:34 <carter> terrible idea
16:39:55 <roboguy_> yeah. I only have a vague idea of how stream fusion works and that's about it
16:39:56 <roboguy_> hmm
16:40:02 <sdegutis> carter: i got lost at "type "ghc-pkg list"", trying to figure out where to type that
16:40:09 <sdegutis> bbl
16:40:18 <roboguy_> sdegutis: in the Terminal
16:40:25 <sdegutis> -bash: ghc-pkg: command not found
16:41:55 <qrada> hey, i just began messing around with some cloudhaskell examples.. it seems i always run into some cabal conflict which tells me i'd have to force a reinstall.. network-transpor-tcp is the package i need to install. Anyone know if there's something I need to do with cabal to fix these dependency/force resintall issues?
16:42:22 <sqrt2_> why is the type signature for take Int -> [a] -> [a] and not (Integral b) => b -> [a] -> [a]?
16:43:07 <Hafydd> :t genericTake
16:43:08 <lambdabot> Integral i => i -> [a] -> [a]
16:43:09 <dcoutts_> qrada: the trick is to always ask cabal to install all the things you need in one go, rather than asking it to install A, then B etc, ask it to install A B C
16:43:27 <sqrt2_> Hafydd: iow, historical reasons?
16:43:29 <Hafydd> sqrt2_: I believe because it's faster to specialise it to Int and/or an artifact of past mistakes.
16:43:40 <sqrt2_> alright, thanks
16:44:05 <Axman6> I don't think there's any good reason why genericTake could be marked SPECIALIZABLE
16:44:21 <Hafydd> Although maybe they weren't mistakes at the time, if there wasn't such a notion of specialising a function.
16:45:02 <merijn> sqrt2_: take, drop and length (and similar ones) are historical artifacts, mostly
16:45:08 <tam1138> where can one learn more about specializable functions?
16:45:28 <merijn> sqrt2_: Worry about newbie unfriendly type errors and efficiency concerns are the main reasons for not changing
16:46:08 <sqrt2_> i'd argue that it still being int is fairly newbie-unfriendly
16:46:36 <Axman6> I wouldn't
16:46:42 <roboguy_> sqrt2_: How so?
16:46:51 <sqrt2_> i'm a newbie and it produced errors that confused me
16:46:56 <Hafydd> What's an example of a beginner-unfriendly type error caused by genericTake?
16:47:08 <Axman6> tttp://www.haskell.org/ghc/docs/7.6.1/html/users_guide/pragmas.html#specialize-pragma
16:47:12 <roboguy_> > genericTake 3.5 [1..10]
16:47:13 <tam1138> thanks
16:47:14 <lambdabot>  Could not deduce (GHC.Real.Integral i0)
16:47:14 <lambdabot>    arising from a use of `Data.List.genericTake'
16:47:14 <lambdabot>  from the context (GHC.Enum.Enum a, GHC.Num.Num a)
16:47:14 <lambdabot>    bound by the inferred type of
16:47:14 <lambdabot>             it :: (GHC.Enum.Enum a, GHC.Num.Num a) => [a]
16:47:19 <roboguy_> Hafydd: ^
16:47:25 <Hafydd> > take 3.5 [1..10]
16:47:26 <lambdabot>  Could not deduce (GHC.Real.Fractional GHC.Types.Int)
16:47:27 <lambdabot>    arising from the literal `3.5'
16:47:27 <lambdabot>  from the context (GHC.Enum.Enum a, GHC.Num.Num a)
16:47:27 <lambdabot>    bound by the inferred type of
16:47:27 <lambdabot>             it :: (GHC.Enum.Enum a, GHC.Num.Num a) => [a]
16:47:35 <merijn> Hafydd: weird messages like "Could not deduce (Integral (a0 -> a1))" type things
16:47:54 <Hafydd> Plain take seems no better for that instance.
16:48:01 <sqrt2_> maybe i'm the only newbie to explicitly add type signatures to all of my functions
16:48:10 <merijn> sqrt2_: I hope not
16:48:17 <roboguy_> well, something like this makes it more apparent
16:48:22 <roboguy_> > genericTake 'a' [1..10]
16:48:23 <lambdabot>  Could not deduce (GHC.Real.Integral GHC.Types.Char)
16:48:24 <lambdabot>    arising from a use of `Data.List.genericTake'
16:48:24 <lambdabot>  from the context (GHC.Enum.Enum a, GHC.Num.Num a)
16:48:24 <lambdabot>    bound by the inferred type of
16:48:24 <lambdabot>             it :: (GHC.Enum.Enum a, GHC.Num.Num a) => [a]
16:48:27 <roboguy_> > take 'a' [1..10]
16:48:29 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
16:48:29 <lambdabot>              with actual type `GHC.Types.Char'
16:48:38 <merijn> sqrt2_: Explicit top-level types are a great habit, people that don't add those annoy me :)
16:48:54 <sqrt2_> the thing is, i use the integral class always basically
16:48:56 <roboguy_> sqrt2_: definitely keep doing that. it makes things *way* nicer
16:49:00 <merijn> Hafydd: Basically any typeclass polymorphic values produce cryptic errors
16:49:03 <roboguy_> the type signatures that is
16:49:09 <sqrt2_> so if i then use take with an argument that is the result of one of my functions, it errors, because it's not it
16:49:11 <sqrt2_> int*
16:49:41 <merijn> sqrt2_: Yeah, it's a pain sometimes, unfortunately even Haskell has warts :)
16:50:05 <Hafydd> If you don't like cryptic errors, I feel bad for you for using GHC.
16:50:37 <L8D> Has someone made a Haskell lib for libuv yet?
16:50:40 <L8D> @hoogle libuv
16:50:42 <lambdabot> No results found
16:51:10 * L8D assumes haskellers know libuv
16:51:26 <quchen> GHC errors have weird wording, but aren't undecipherable. "Could not deduce instance <function type>" usually means you forgot an argument. Takes some time to get used to, but is manageable.
16:51:27 <merijn> L8D: I read the two line summary, I have one question
16:51:29 <Axman6> lambdabot: isn;'t that what GHC's IO manager is built on in linux?
16:51:32 <merijn> L8D: Why would you want that?
16:51:38 <Axman6> uh, L8D
16:51:55 <merijn> L8D: Sounds like something better solved by threads and synchronous code in Haskell
16:52:05 <Axman6> L8D: if it is, the interface is exposed in a platform independant way somewhere inside a GHC.Foo module
16:52:17 <merijn> asynchronous, event-driven programming is for languages without a proper threading system
16:52:32 <merijn> Axman6: I think you're confused with libevent?
16:52:40 <Axman6> L8D: but merijn is right, you don't need it, threads are based on it already and provide an infinitely better interface
16:52:42 <jrmithdobbs> does Monad m => (a,m b) -> m (a,b); exist somewhere that I'm missing?
16:52:44 <Axman6> merijn: could be
16:52:52 <merijn> Axman6: That wraps kqueue/epoll/select
16:52:55 <jrmithdobbs> sequenceT or something?
16:52:57 <jrmithdobbs> heh
16:53:17 <Axman6> jrmithdobbs: f (a,mb) = fmap (\b->(a,b)) mb
16:53:26 <merijn> There was a neat formulation for that
16:53:36 <Axman6> merijn: ah yes, you are right. what's libuv then?
16:53:48 <L8D> merijn: I want to do asynchronous operations...
16:54:00 <L8D> not multi-threaded
16:54:06 <merijn> L8D: Why?
16:54:18 * hackagebot concurrent-state 0.4.0.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.4.0.0 (JoelTaylor)
16:54:46 <L8D> merijn: chaining threads is hard.
16:55:00 <Axman6> L8D: you know threads in GHC are incredibly light weight right? and provide you with exactly the same benefits, while being a lot easier to use
16:55:01 <merijn> L8D: What do you mean by chaining threads?
16:55:05 <L8D> but I haven't done multi-threading in haskell...so I have no claims on that
16:55:07 <jrmithdobbs> Axman6: ya i don't want f (a,m b) I want m (a,b)
16:55:27 <Axman6> jrmithdobbs: that's what the function I gave does...
16:55:31 <carter> roboguy_: sounds like hes not got things installed
16:55:38 <jrmithdobbs> Axman6: ha, i misread
16:55:39 <Axman6> :t let f (a,mb) = fmap (\b->(a,b)) mb in f
16:55:40 <lambdabot> Functor f => (t, f t1) -> f (t, t1)
16:55:42 <merijn> L8D: Haskell has lightweight threading, you can easily have 100k+ threads (think Erlang/Go) and the runtime system uses kqueue/epoll/select to wait for runnable threads
16:55:57 <roboguy_> carter: yeah. I think he doesn't want to install Haskell Platform for some reason and he wants to use homebrew instead
16:56:01 <L8D> merijn: where is the documentation for threads?
16:56:13 <quchen> Marlow's book
16:56:19 <Axman6> L8D: Control.Concurrent
16:56:24 <merijn> L8D: Simon Marlow's new book and Control.Concurrent
16:56:26 <roboguy_> carter: actually wait, can't you install haskell platform from homebrew?
16:56:27 <carter> roboguy_: whenever anyone uses brew to installl haskell, I WILL KILL A KITTIE
16:56:34 <merijn> carter: Word.
16:56:41 <dhrosa> why?
16:56:41 <carter> roboguy_: DONT DO IT
16:56:45 <merijn> carter: Same for macports
16:56:50 <Axman6> L8D: haskell's threading is about as good as you'll get in any language. they're more light weight than Erlang's, and up there with Go (better imo)
16:56:51 <roboguy_> carter: haha, tell him
16:56:53 <carter> THINGS BREAK BECAUSE THEY PATCH STUFF WRONG EVEN THOUGH WE TELL EM NOOOOO
16:56:54 <L8D> carter: I did
16:57:09 <L8D> I'm running 7.6.3 perfectly fune
16:57:12 <carter> i will not provide support for ghc installed via brew
16:57:13 <roboguy_> I installed haskell platform normally (originally anyway. I use HEAD now)
16:57:16 <carter> congrats
16:57:17 <carter> :)
16:57:19 <carter> you'er lucky
16:57:29 <bitemyapp> carter: dude, we had to fight with the homebrew people in the clojure community too
16:57:36 <Axman6> well, mine installed by the platform is completely broken now
16:57:37 <carter> bitemyapp: yeah
16:57:39 <bitemyapp> carter: I was the one that finally got them to remove Clojure from homebrew.
16:57:43 <Axman6> so, maybe i should try homebrew
16:57:46 <carter> Axman6: nope
16:57:48 <bitemyapp> carter: but some insane jackass got clojurescript added.
16:57:56 <carter> bitemyapp: dont call people names
16:58:02 <roboguy_> carter: is there a general rule of thumb for how often to reinstall/update HEAD if I'm not doing GHC development (yet)?
16:58:02 <bitemyapp> so there's clojurescript but not clojure on homebrew now
16:58:03 <merijn> Axman6: OSX? 10.9?
16:58:03 <L8D> bitemyapp: why don't you want clojure on homebrew?
16:58:05 <Axman6> I refuse to change what C compiler my system uses just to make GHC work
16:58:09 <Axman6> merijn: yeah
16:58:10 <bitemyapp> L8D: it's a frickin' library.
16:58:12 <carter> Axman6: thats standard
16:58:15 <carter> Axman6: thats 10.9
16:58:16 <carter> not brew
16:58:19 <carter> not installer
16:58:24 <L8D> bitemyapp: I'm talking about leinigein
16:58:25 <bitemyapp> L8D: Clojure is not an end-user binary or end-user anything for that matter.
16:58:25 <carter> Axman6: did you follow my directions? :)
16:58:26 <merijn> Axman6: homebrew can't solve that
16:58:33 <carter> yeah
16:58:36 <bitemyapp> L8D: "why don't you want clojure on homebrew?" is what you said.
16:58:43 <merijn> Axman6: Homebrew solves it by installing a different C compiler for your system
16:58:44 <carter> bitemyapp: don't call people names
16:58:47 <carter> yes
16:58:52 <Axman6> carter: I did until it got to the point of redirecting what gcc pointed to, I don't want to do that
16:58:55 <bitemyapp> L8D: I changed the Clojure recipe to tell people to use Leiningen.
16:58:58 <carter> Axman6: tough
16:59:03 <carter> :)
16:59:07 <carter> you can use the clang wrapper
16:59:10 <carter> but some code won't build
16:59:15 <L8D> bitemyapp: by "clojure" I meant, leinigen and all the necessary java deps
16:59:38 <bitemyapp> L8D: okay?
16:59:48 <bitemyapp> L8D: when I say Clojure I mean Clojure. When I say Leiningen I mean Leiningen.
16:59:49 <Axman6> I don't see why things are broken though, why isn't iconv already linked into libHSBase?
16:59:55 <L8D> merijn: what do you mean "different C compiler for your system"? OS X doesn't have a 'standard C compiler'
17:00:05 <bitemyapp> L8D: I got Clojure removed because it's a java library and changed it to point people to the actual end-user interface - Leiningen.
17:00:22 <merijn> L8D: It does, clang that's the one that ships with XCode devtools
17:00:40 <L8D> merijn: and it changes clang?
17:00:48 <Axman6> yeah OS X definitely has a default C compiler
17:00:51 <merijn> L8D: homebrew installs gcc to compile GHC
17:01:02 <merijn> L8D: Well, to do preprocessing for GHC
17:01:13 <carter> yes
17:01:20 <carter> homebrew install apple-gcc42
17:01:22 <merijn> Axman6: The iconv problem comes from using C libraries installed via brew/macports
17:01:23 <L8D> merijn: What's wrong with GCC and how does it 'change' the standard C compiler?
17:01:24 <carter> or uses whatever gcc you've got installed
17:01:34 <carter> on 10.9
17:01:39 <carter> "gcc" is an alias for clang
17:01:42 <carter> unless you install a real gcc
17:01:48 <carter> which leads to *FUN* bugs
17:01:52 <carter> when you dn't know whats going on
17:01:57 <merijn> Axman6: Because brew/macports insist on linking against their own iconv versions, rather than the iconv used by GHC
17:02:01 <L8D> who would ever use gcc when they mean to use clang?
17:02:17 <Axman6> merijn: why is my platform install of GHC trying to use them then?
17:02:18 <carter> no clue
17:02:25 <L8D> so then what's the problem?
17:02:26 <carter> why is what
17:02:35 <merijn> Axman6: I've never encountered that
17:02:35 <carter> Axman6: platform was made before xccode 5 and 10.9
17:02:46 <carter> if you're using the Brew stuff,  who the hell knows
17:02:48 <Axman6> hmm, that makes sense
17:02:56 <merijn> Axman6: But then, I didn't upgrade to 10.9 yet
17:03:03 <carter> merijn: my directions work
17:03:13 <Axman6> well, apart from GHC being borked, it's been worth it for me
17:03:17 <merijn> carter: I figure why update before a working platform comes out? :p
17:03:17 <jrmithdobbs> Axman6: how is that not defined somewhere, i'm shocked that i can't find a hoogle entry for that signature
17:03:22 <lispy> johnw: Do you have any statistics you can share about Haskell code that you guys wrote for the FP complete center?
17:03:33 <lispy> johnw: Even simple stuff, like # of lines
17:03:34 <merijn> carter: I'm actually still on 10.7
17:03:35 <carter> Axman6: its unborked i fyou follow my direcitons
17:03:38 <Axman6> jrmithdobbs: because it's not something I've ever seen anyone need before you ;)
17:03:40 <carter> merijn: howllly
17:04:00 <merijn> carter: Figured I'd skip 10.8 (nothing interesting) and then with the breakage of 10.9 I figured I'd wait until it's sorted
17:04:11 <jrmithdobbs> Axman6: i just assumed various synonyms for sequence under different circumstances existed ;p
17:04:16 <carter> merijn: its sorted
17:04:18 <carter> my directions work
17:04:19 <jrmithdobbs> Axman6: teach me to assume
17:04:34 <merijn> carter: But I'm lazy :( I want a one click platform install :p
17:04:35 <carter> and its even more fixed in HEAD / 7.8
17:04:36 <jrmithdobbs> actually, I think i can do it with lens a little clearer possibly
17:04:38 <carter> :P
17:04:43 <carter> .pkg
17:04:45 <carter> ok
17:04:50 <merijn> carter: I'm not in a rush to update :)
17:04:53 <carter> fair
17:04:56 <merijn> Anyway, I should go sleep
17:04:58 <carter> enjoy
17:06:09 <Axman6> carter: you sdaid my iconv issue came from using homebrew, but iconv isn't even installed in my homebrew!
17:06:22 <carter> no
17:06:32 <carter> i said if you have ghc issues and you used brew to install ghc
17:06:35 <carter> its brew
17:06:37 <jrmithdobbs> but ya, sequence ((\(a,mb) -> (\b -> (a,b)) mb) <$>
17:06:44 <carter> thats the problem
17:06:46 <jrmithdobbs> err stupid enter
17:06:48 <carter> because they do weird stuff
17:06:51 <Axman6> carter: but I haven't done that
17:06:53 <carter> oh
17:06:56 <carter> i thought you said you ahd
17:07:00 <carter> how didyou install your ghc?
17:07:04 <Axman6> I've never used homebrew to install ghc
17:07:06 <carter> oh ok
17:07:07 <Axman6> the platform
17:07:07 <carter> hrm
17:07:10 <carter> hrm
17:07:26 <carter> try brew install iconv ; brew link -f iconv then :)
17:07:33 <carter> eheh
17:07:44 <L8D> What is a better way to append something to a list than (++ [x]) ?
17:07:47 <Axman6> worth a shot...
17:07:55 <carter> L8D: cons on front, then reverse
17:08:05 <carter> or use a a tree shaped data structure
17:08:25 <Ralith> what carter means is "that depends on your access pattern"
17:08:26 <Axman6> L8D: that's pretty much the only way
17:08:34 <carter> Axman6: i'm just good at Ralith  yup :)
17:08:39 <L8D> so... reverse (x:reverse)
17:08:43 <carter> ummm
17:08:49 * Clint claps.
17:08:51 <carter> Data.Seq
17:08:58 <Axman6> L8D: requires two traverals
17:09:00 * L8D facepalms
17:09:08 <carter> https://hackage.haskell.org/package/containers-0.3.0.0/docs/Data-Sequence.html
17:09:20 <carter> migth be better
17:09:24 <Axman6> if you need append, you don't want list
17:09:28 <carter> yes
17:09:40 <carter> builder has the BEST append complexity :)
17:09:47 <carter> but terrible update complexity :)
17:09:47 <Axman6> DList is pretty good
17:10:03 <Axman6> for append/prepend only anyway
17:10:10 <jrmithdobbs> but ya, sequence ((\(a,mb) -> (\b -> (a,b)) <$> mb) <$> Prelude.zip (somethingThatProduces [Text]) (somethingThatProduces-[(IO Text)]) ... gets me a nice [Text] -> IO [(Text,Text)]
17:10:14 <carter> yeah
17:10:16 <Ralith> well, if you only need append a bunch of times in a row and then never again, then list + reverse is just fine
17:10:26 <carter> yeah
17:10:32 <carter> depends on the macro picture
17:13:13 <dmj`> Is there a way gain access to the snap monad from a forked thread? (forked from a snap handler) liftIO $ forkIO $ ..... re-access snap ....
17:13:28 <Axman6> carter: huh.....-L/usr/lib -liconv fixed my issues. wtf isn't that happening automatically?
17:13:38 <manek> Hello! I want to ask you if you have any idea how to make this code more pure and in applicative style: http://lpaste.net/98971 ?
17:13:48 <carter> Axman6: sounds like lyour load dir is wrong
17:13:55 <Axman6> manek: feel free to ask then :P
17:14:19 <manek> Axman6: Heh, ok! So does anybody has any idea? :D
17:14:19 <carter> manek: looks ifne
17:14:21 <carter> *fine
17:14:37 <carter> whats it supposed to do?
17:14:47 <carter> manek: ooo
17:14:48 <Axman6> manek: you could use pDotTermBase >>= mapM (\x -> Expr.Accessor <$> genID <*> pure x) if you wanted, but it doesn't make it any nicer
17:14:52 <carter> are you writing a computer algebra lib?
17:15:09 <manek> carter: But I want to transform it into applicative style (to use for example in uu-parsinglib instead of Parsec). So generally it works as follow:
17:15:31 <carter> manek: mapM === fmap :)
17:15:41 <manek> Axman6: (>>=) - is a monadic binding - and I want applicative style only
17:15:54 <magicman> mapM is not fmap. liftM is fmap.
17:16:06 <Axman6> indeed
17:16:16 <carter> :)
17:16:17 <carter> woops
17:16:20 <carter> long day
17:16:22 <carter> :t fmap
17:16:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:16:25 <dmj`> pDotTermBase >>= mapM (\x -> Expr.Accessor <$> genID <*> pure x) >>= flip foldl (flip ($)) .... might work
17:16:26 <carter> :t mapM
17:16:27 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
17:16:37 <magicman> @type Data.Traversable.mapM
17:16:38 <lambdabot> (Monad m, Traversable t) => (a -> m b) -> t a -> m (t b)
17:16:44 <carter> ok
17:16:45 <magicman> @type Data.Traversable.mapM_
17:16:46 <lambdabot> Not in scope: `Data.Traversable.mapM_'
17:16:53 <carter> sooo,  mapM makes it not applicative
17:16:55 <carter> right.
17:16:56 <carter> ?
17:17:01 <manek> carter: exactly
17:17:20 <magicman> Ah. You can use Data.Traversable.traverse
17:17:24 <carter> oh ook
17:17:27 <carter> :t traverse
17:17:29 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:17:35 <carter> ermm
17:17:41 <carter> bind == not applicative
17:18:05 <manek> carter: I've got a function, (Expr.Accessor <$> genID) which ha a signature of (m (a -> b -> b)). I've got a list of values pDotTermBase, which is basically (m [a]). I want something like: m (a -> b -> b) -> m b -> m [a] -> m b
17:18:16 <magicman> Oh, right. And because you need vars to get to expr, I don't think this is APplicative.
17:18:34 <carter> you may need to change your dsl!
17:18:49 <carter> or have an applicative way to introduce vars
17:18:50 <carter> or
17:18:51 <carter> umm
17:18:52 <carter> idk
17:18:53 <carter> :)
17:19:26 <qrada> dcoutts_: hey thanks, that worked.. i did:  cabal install network-transport network-transport-tcp distributed-process
17:19:37 <erisco> salut
17:20:11 <dcoutts_> qrada: right, you see that way the constraint solver can see what you're trying to do and do it, but if you only ever give it partial information then it cannot help you
17:21:06 <dwcook> Is there an existing version of hGetLine that handles both \n and \r\n as line endings?
17:21:19 <manek> carter, magicman: hmm, wait - I do not follow you :P Look, here is an applicative style code: "pDotTermE    = many1 (tok Expr.Accessor <* L.pAccessor <*> pVar)" - I want to change it in such way, that I will parse on the beginning the part "many1 (L.pAccessor <*> pVar)" (this is vars) and then construct equivalent to the first one. Is it possible ?
17:21:44 <qrada> ah...
17:21:49 <carter> manek: you're showing us only fragments
17:21:51 <qrada> ive been 'struggling with that' for a while
17:21:53 <carter> its hard to undertand the goal
17:21:57 <qrada> nic
17:21:58 <qrada> e
17:22:04 <Axman6> dwcook: are you sure it doesn't already?
17:22:12 <manek> carter: Ok, wait, I'll prepare a nicer ecxample, brb
17:22:34 <dwcook> Axman6, yes, I've checked.
17:22:56 <dwcook> Relevant code: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-IO-Handle-Text.html#hGetLine
17:23:15 <dwcook> I've also tested empirically.
17:25:41 <Twey> dwcook: I think you want to be using http://hackage.haskell.org/package/base-4.2.0.0/docs/GHC-IO-Handle.html#v%3AuniversalNewlineMode
17:26:03 <L8D> :t merge
17:26:04 <lambdabot> Not in scope: `merge'
17:26:15 <dwcook> Twey, perfect, thanks.
17:26:16 <Twey> dwcook: You can set it with hSetNewlineMode universalNewlineMode yourHandle
17:26:35 <Twey> Sorry, flip that
17:26:55 <dwcook> I saw the relevant function in the docs you linked, thanks
17:27:34 <manek> carter, magicman: Ok, here is a little nicer example. I was trying to simpliify it as much as possible: http://lpaste.net/98972
17:27:56 <Twey> Or if you want to output CRLF, you can create a NewlineMode CRLF CRLF
17:28:04 <manek> carter, magicman: The idea is, that I want to transform pDotTermE into pDotTermE2 in such way, that it will use pDotTermE2Base
17:28:16 <dmj`> anyone know if you can reaccess a monadic context that you've forked a thread from?
17:28:17 <manek> carter, magicman: Is it clear now?
17:29:07 <Twey> dmj`: What does that mean?
17:29:11 <AfC> I've got library-profiling: True in my ~/.cabal/config file, but is there a way to tweak the options used when passed to GHC for the .p_o pass? I'd like to change what appears to be -fprof-all (sic) to -fprof-auto-exported
17:29:15 <manek> carter, magicman: I've updated the code, sorry
17:30:35 <Twey> dmj`: forkIO takes IO (), but you can get the ‘context’ out of your monad (I presume you have something in MonadIO?) and pass it
17:30:37 <dcoutts_> AfC: you can cabal configure --ghc-options=
17:30:54 <magicman> manek: You mean split off the mkID from the pAccessor and pVar?
17:31:12 <magicman> manek: Gut instinct says that it's not going to happen without Monadic power.
17:31:14 <Twey> dmj`: get >>= liftIO . runMyMonad doSomething, for example
17:32:04 <magicman> manek: I must admit that I haven't looked at it more closely, but one of the things I thought of when looking at that earlier paste was "It would be possible if you could put the genID inside the pDotTermBase whenever you get an element".
17:32:11 <L8D> :t lift
17:32:12 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
17:32:15 <L8D> :t liftIO
17:32:16 <lambdabot> MonadIO m => IO a -> m a
17:32:26 <L8D> -.-
17:32:29 <L8D> Arrow
17:32:43 <Twey> L8D: Arrow?
17:32:56 <L8D> :i liftIO
17:33:04 <L8D> lambdabot needs :i
17:33:14 <L8D> it doesn't matter
17:33:16 <Twey> L8D: liftIO is the only method of the MonadIO class
17:33:25 <Twey> No arrows :þ
17:33:33 <manek> magicman: I can split it, but in reality "mkId" does NOT parse anything - it just generates new ID (a simple Int) for the Accessor DataType, so it could not have any sense to put it in pDotTerm2Base
17:33:36 <L8D> Arrow is an instance of MonadIO
17:33:38 <L8D> isn't it?
17:33:45 <Twey> L8D: Arrow is a typeclass
17:33:56 <L8D> hm...
17:33:57 <Twey> Some arrows probably are instances of MonadIO
17:34:09 <Twey> (the ones with IO underneath)
17:34:31 <magicman> manek: Yeah, I got that. But it's still part of the Monad/Applicative you're using for the parser.
17:35:09 <magicman> manek: I don't think you can *and* split off the mkId to outside the many1 *and* remain Applicative.
17:35:18 <roboguy_> why does Hoogle depend on shake?
17:36:05 <dmj`> Twey: yes, I am in a monad (transformer) that has an instance of MonadIO, I fork a thread, but still need access to the previous context. The functions I need to invoke need the context that the thread was forked from in order to make any sense. I need to opposite of liftIO, I need to lift an action from IO back to the context it came from
17:36:17 <dmj`> the*
17:36:23 <jle`> roboguy_: it might build the database? idk, neil mitchell maintains both
17:36:24 <manek> magicman: I do not want to put it inside pDotTerm2Base, because I want to spearate it - this is one of the reason to do what I'm doing. Hmm, In eality I'm looking fr a function (m (a->a) -> m [a] -> m a), but m (a->a) is monadic function different for each a in the list - I think it should be possible in applicative style, but I could be worng
17:36:50 <Twey> dmj`: That's what liftIO does
17:36:57 <roboguy_> jle`: hmm. well, shake doesn't compile on ghc HEAD right now so that means hoogle can't be either
17:37:12 <Twey> It lifts *from* IO, not *to* IO: it takes an IO action to lift into the MonadIO instance
17:37:13 <manek> magicman: The wrong part here is "vars <- ... ; mapM (\x -> Expr.Accessor <$> genID <*> pure x) vars" If I could write it in applicative, it would be great
17:37:20 <magicman> manek: I understand what you want. My gut instinct says that you're wrong.
17:37:39 <manek> magicman: I understand your instinct and I hope its wrong :D
17:37:46 <jle`> just as a long shot, are there any haskell libraries specifically for preprocessing-type stuff?
17:37:47 <Axman6> manek: do you really want mapM there?
17:38:01 <Axman6> jle`: preprocessing what?
17:38:09 <L8D> > putStrLn "I'm about to die!" >> myThreadId >>= killThread
17:38:12 <lambdabot>  Not in scope: `myThreadId'Not in scope: `killThread'
17:38:18 <jle`> Axman6: just preprocessing like plaintext source files
17:38:26 <jle`> where i can like...define my own syntax
17:38:29 <manek> Axman6: what do you mean? I think I need, because it generates a lot of Expr.Accessor **with different ID's** - this is what I want
17:38:35 <jle`> for macros and stuff
17:38:39 <jle`> or includes
17:38:44 <jle`> more importantly includes
17:39:02 <Axman6> manek: will map not do? and then use some fold to combine everything?
17:39:11 <dmj`> Twey: ok, well what I need to do is run a snaplet in the snap monad from a forked thread that is in the IO monad.
17:39:19 <dmj`> a snaplet action
17:39:26 <L8D> > ! repeat 1
17:39:28 <lambdabot>  <hint>:1:10: parse error on input `1'
17:39:36 <L8D> > ! (repeat 1)
17:39:37 <lambdabot>  <hint>:1:4: Parse error in pattern: repeat
17:39:38 <Twey> dmj`: Okay; can you not do as I suggested?
17:39:42 <L8D> > repeat 1
17:39:43 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
17:39:55 <roboguy_> L8D: what are you trying to do? a bang pattern?
17:40:19 <jle`> roboguy_: yeah he uses it to build the database
17:40:23 <jle`> roboguy_: https://github.com/ndmitchell/hoogle/blob/960a06f73f9e3fbef08fa6a10091125125a81e6c/src/Recipe/All.hs
17:40:26 <manek> Axman6: I do not think so. How would you want to use fmap here?
17:40:45 <jle`> Rules is a Shake monad
17:40:47 <roboguy_> jle`: ah. hmm. thanks
17:41:06 <Axman6> manek: map not fmap. it seems that it's not doing anything particularly monadic. i haven't looked too deeply though
17:41:34 <jle`> rather unfortunate that it makes it unable to build
17:41:41 <Twey> dmj`: Looks like it's a bit awkward to get the state, since there are four things that go into a Snap monad and then you get out an Iteratee that you'll have to run, but the principle should work
17:41:43 <jle`> however neil is pretty active
17:41:47 <jle`> and answers questions pretty quickly
17:42:02 <jle`> so you might want to open an issue
17:42:32 <manek> Axman6: I do not think so, because map (or fmap) takes a function, which is THE SAME for every value - and here we've got different functions for each value
17:43:55 <dmj`> Twey: I don't think I can just pass the function I want to invoke to the forked thread, since the functions signature has MonadIO and MonadState, and I'm only in the IO monad. It's like trying to call a heist function from a forked thread.
17:43:57 <manek> jle`: Hi! Do you remember, what we were talking bout before? You suggested me to use replicateM - I was trying to do it, but I ended on monadic style solution (replicateM needs the number of things, which we cannot access in pure applicative style as far as I know). I ended on: http://lpaste.net/98971 . Maybe I did not understand oyur solution then?
17:45:42 <jle`> manek: oh yeah
17:45:44 <jle`> you're right.
17:45:50 <jle`> hm.
17:45:54 <ski> @type let sequenceA = foldr (liftA2 (:)) (pure []) in \n ia -> sequenceA (replicate n ia)  -- manek ?
17:45:56 <lambdabot> Applicative f => Int -> f a -> f [a]
17:46:02 <Twey> dmj`: Right.  That's why you have to run the monad you want in the other thread.
17:46:14 <jle`> ski: but he needs the length that comes from a previous monadic action
17:46:31 <ski> @type \n ia -> Data.Traversable.sequenceA (replicate n ia)
17:46:32 <lambdabot> Applicative f => Int -> f a -> f [a]
17:46:34 <ski> jle` : mhm
17:46:46 <manek> ski: hmm, give me a second
17:46:49 <jle`> hm
17:47:11 <magicman> replicateA is applicative, but to get at the required Int, you need Monad. You only have an "m [a]". Best you get is an "m Int".
17:47:43 <Twey> dmj`: forkIO . runIteratee $ runSnap yourSnapAction logError timedOut request
17:47:51 <jle`> i don't think you can fork on a monadic result
17:48:01 <jle`> like the length of a monadic result
17:48:11 <jle`> without using a monad
17:48:32 <Twey> dmj`: (I think that's the correct way to run an Iteratee; it's been a while since I've used them
17:48:34 <Twey> )
17:48:39 <ski> jle` : i don't see a length at <http://lpaste.net/98971>
17:48:41 <Twey> dmj`: Where logError, timedOut, and request are your Snap state, which you should be able to get from the current Snap monad
17:48:44 <jle`> for example, do { n <- readLn; replicateM n (print "hello") }
17:49:11 <jle`> ski: this was a part of a separate solution that i gave him earlier in perhaps ill advice
17:49:41 <ski> mhm
17:49:54 <manek> ski: How would you use this sequenceA in my example? I'm sorry I cannot see it yet
17:50:07 <joejev> I have a list of filepaths, 'as' and I map my function over them that processes them as such: mapM_ (readAll . Right <=< stateFromFile) as, how do I make it fork each of the readAlls into their own thread, I keep getting type errors
17:50:13 <jle`> from what i gathered before...he parsed an initial value...and then he parses a list...and then he parses a list of functions of the same length as the list he pasred
17:50:28 <roboguy_> what about (`replicateM` print "hello") <$> readLn?
17:50:30 <dmj`> Twey: I don't think forkIO . runIteratee compose
17:50:33 <ski> manek : i don't know what you're trying to do in your example
17:50:46 <jle`> and then applies each function in order to successive items on the list in a zip-ish like manner
17:51:15 <dmj`> Twey: this is why you shouldn't put your database in snaplet :)
17:51:20 <Twey> dmj`: Yep, you're right.  There's some function to run an iteratee to completion, but I don't remember what it is.
17:51:32 <Twey> Heh
17:51:34 <ski> manek : though  Expr.Accessor <$> genID <*> pure x  could be written as  (`Expr.Accessor` x) <$> genID  or, if you prefer, as  flip Expr.Accessor x <$> genID  or  Expr.Accessor `flip` x <$> genID  (maybe with extra brackets)
17:51:34 <manek> jle`, ski: I'm parsing a list of values (m [a]) and I've got a function (id -> a -> b -> b) but I want to generate distinct id for each such function application, so I've got function (m (a -> b -> b)) and I want to combine it in such way ( (m (a -> b -> b)) -> m b -> m [a] -> m b )
17:51:43 <dmj`> It's convenient but also a straight jacket
17:51:47 <jle`> where do your distinct id's come from?
17:51:50 <jle`> a parse?
17:52:10 <Twey> dmj`: I'm a little suspicious about this whole idea of running a Snap in a different thread, though.  It doesn't look like it's meant to be used from multiple threads at the same time — I don't know how Iteratee will take to that.
17:52:11 <jle`> or from a State monad somewhere in your stack?
17:52:16 <manek> jle`: Yes, mkId is just (m Int) - its fdifferent for each "call"
17:52:28 <manek> jle`: from internal state monad in parser
17:52:53 <L8D> :t pure
17:52:55 <lambdabot> Applicative f => a -> f a
17:53:08 <manek> ski: hmm, brb
17:53:10 <jle`> manek: do you know the length of your list in advance?
17:53:17 <jle`> it looks like you do
17:53:20 <jle`> maybe
17:53:20 <manek> jle`: Of course not
17:53:22 <jle`> atually i'm not sure
17:53:24 <jle`> nevermind
17:53:26 <jle`> okay
17:53:28 <manek> jle`: this list comes form a parse
17:53:41 <jle`> but it's a nondeterministic parse on the length
17:53:44 <jle`> hm
17:53:47 <jle`> actually
17:53:52 <jle`> i know a really hacky alternative trick
17:53:55 <jle`> where you can fork on a length
17:54:01 <jle`> but it's not good practice
17:54:12 <jle`> Alternative as in Applicative a => Alternative a
17:54:43 <jle`> but for this in general you're going to need a monad
17:55:03 <jle`> because the result of your parse will determine the monad you return
17:55:10 <jle`> or the structure of the monad you return
17:55:11 <manek> ski: Would you be so nice and tell me how you imagine the final solution? It owuld help me a lot to understand how you are thinking about it
17:55:51 <jle`> you can't applicativize something like do { n <- readLn; replicateM_ n (putStrLn "hello") }
17:55:51 <ski> manek : i haven't imagined any final solution yet
17:55:55 <manek> jle`: Hmm, I prefer not to fork the length :P hmm
17:56:00 <manek> ski: ahh, ok
17:56:19 <jle`> well your parse result determines how many id's you generate
17:56:26 <dmj`> Twey: I want to run a check everytime a specific handler is called to determine whether a user is active based on a condition that is calculated in a forked thread. If that condition is met I need to make a db change, but I'm in a forked thread, and can't access my snaplet actions. I'm going to try and access the db outside of snap. I hate one off conditions that muck up code tho
17:56:36 <jle`> so it'll determine the structure of the next monadic action
17:56:40 <joejev> how would I make: "mapM_ (readAll . Right <=< stateFromFile) as" fork each of those into their own thread, I tried: forkIO $ void $ readAll . Right <=< stateFromFile but that didnt work
17:57:18 <dmj`> it's a fire and forget function
17:57:21 <manek> ski, jle`: Maybe it is a little complicated, maybe a better question would be this: look, I have got here a sample code http://lpaste.net/98972. I want to transform pDotTermE into pDotTermE2, which uses pDotTermE2Base
17:57:35 <manek> ski, jle`: Maybe now it is more clear and shows whats going on under the hood
17:58:42 <jle`> hm
17:58:50 <jle`> okay i think i see
17:58:59 <jle`> you want to do the parsing of m [a] and the id generation side-by-side
17:59:16 <manek> jle`: exactly
18:00:39 <jle`> does your first half already work?
18:00:41 <ski> @type let foo :: (Functor f,Applicative i) => i (a -> b -> b) -> i b -> f [a] -> f (i b); foo icons inil = fmap loop where loop [] = inil; loop (a:as) = liftA ($ a) icons <*> loop as in foo
18:00:42 <lambdabot> (Functor f, Applicative i) => i (a -> b -> b) -> i b -> f [a] -> f (i b)
18:01:15 <ski> @type let foo :: Applicative i => i (a -> b -> b) -> i b -> [a] -> i b; foo icons inil [] = inil; foo icons inil (a:as) = liftA ($ a) icons <*> foo icons inil as in foo
18:01:17 <lambdabot> Applicative i => i (a -> b -> b) -> i b -> [a] -> i b
18:01:27 <ski> manek : we can do ^
18:01:29 <manek> jle`: Yes, the first half works
18:01:38 <manek> jle`: My monadicsolution works also
18:02:31 <manek> ski: ok, I'm reading it, brb
18:03:08 <ski> however, to get to `i (a -> b -> b) -> i b -> i [a] -> i b', we need the ability to decide the rest of the computation structure (namely the number of ids to generate), *depending* on the *value* generated by the earlier parse (the value of type `[a]' generated by the `i [a]' parser)
18:03:17 <ski> this *appears* monadic to me
18:04:01 <jle`> he doesn't need to know the number of id's to generate
18:04:08 <jle`> i think
18:04:19 <manek> ski, jle`: Its probably not solvable in paplicatie style.
18:04:22 <sdegutis> Do any of you wonderful nerds hide your development stuff behind virtualization?
18:04:36 <ski> manek : would it be *possible* (not necessarily desirable) to generate the ids as you're generating the list ?
18:04:40 <jle`> sdegutis: well i use windows but i do all my dev on my linux server
18:04:42 <manek> ski, jle`: but I do not yet know why :(
18:04:50 <jle`> manek: i think it might be applicativable
18:04:51 <jle`> hm
18:04:55 <sdegutis> jle`: does it sit inside something like virtualbox?
18:04:58 <jle`> but i do not have too much time at the moment
18:05:00 <ski> manek : i'm not sure yet
18:05:04 <jle`> sdegutis: no it's just a physical ubuntu server
18:05:13 <sdegutis> Oh. Okay. Thanks.
18:05:14 <ski> manek : where is the list coming from ?
18:05:24 <manek> ski: It owuld be possible, but It would reak a lot of things, because these ids would not always be used then and I would have some "holes" between different ids
18:05:54 <manek> ski: the list is siple "dot and identifier" , so ".x.y.z" will give us ["x", "y", "z"]
18:06:33 <manek> ski: look here http://lpaste.net/98972
18:06:45 <manek> ski: the list is " many1 (L.pAccessor *> pVar)"
18:09:25 * hackagebot htsn-import 0.0.2 - Import XML files from The Sports Network into an RDBMS.  http://hackage.haskell.org/package/htsn-import-0.0.2 (MichaelOrlitzky)
18:09:58 <ski>   applyAll x fs = foldl (flip ($)) x fs
18:10:35 <manek> ski: I'm using it already - its in the code
18:11:02 <manek> si: http://lpaste.net/98971
18:11:04 <manek> ski: http://lpaste.net/98971
18:11:05 * ski notes manek doesn't believe in type signatures
18:11:42 <roboguy_> sdegutis: why would you want to do that?
18:11:50 <manek> ski: Oh, I'm sorry - I'm jutnot using type signatures when writing parsers
18:11:58 <manek> ski: is it wrong ?
18:12:06 <sdegutis> roboguy_: so much context, cannot go on
18:12:16 <Axman6> manek: it's never a bad idea to write a type signature
18:12:17 <roboguy_> sdegutis: ?
18:12:22 <ski> well, it makes it harder to follow what the parsers are supposed to parse
18:12:25 <Axman6> (except when it confuses GHC)
18:12:32 <ski> @ghc
18:12:33 <lambdabot> Ambiguous constraint
18:12:54 <sdegutis> roboguy_: well, im pretty tired of Mac OS X incompatibilities/problems
18:13:10 <sdegutis> so im thinking of running linux in a virtual machine like vbox and doing dev in there.
18:13:14 <Axman6> sdegutis: what problems are you having?
18:13:14 <roboguy_> sdegutis: you should really just install Haskell Platform. there's not really a reason not to that I can think of...
18:13:22 <sdegutis> or dual booting, but im not sure the linux drivers are up to par for my rMBP yet
18:13:29 <roboguy_> I use GHC on OS X all the time...
18:13:35 <sdegutis> Axman6: oh wow, i totally remember you from somewhere on IRC 5 years ago
18:13:42 <sdegutis> no idea where
18:13:49 <Axman6> =)
18:13:50 <sdegutis> roboguy_: its not just haskell. its so many things.
18:14:26 <Axman6> roboguy_: i've been having GHC problems until today, might be able to help
18:14:37 <ski> > map succ "Axman6"
18:14:38 <lambdabot>  "Bynbo7"
18:14:48 <roboguy_> sdegutis: like what?
18:14:58 <Axman6> "succ all the characters" something sus about that
18:15:09 <sdegutis> roboguy_: i cant say right now cuz i dont remember
18:15:15 <sdegutis> but im bettin somethin, prolly
18:16:03 <ski> Axman6 : i have a vague recollection of you using that as an alternate nick
18:16:13 <Axman6> ski: I still do =)
18:16:19 <sdegutis> Axman6: #macdev?
18:16:23 <Axman6> possibly
18:16:29 <sdegutis> oh. cool.
18:16:32 <sdegutis> i have a lifeban there.
18:16:37 <Axman6> I never spent a whole lot of time there though, Obj-C makes me cry
18:16:42 * ski can't recall when Axman6 appeared in #haskell, though
18:16:43 <sdegutis> yes, objc is not pleasant.
18:16:51 <Axman6> I seem to remember that wasn't too hard to do :P
18:16:59 <Axman6> we started #macosxdev for that reason
18:17:16 <sdegutis> neat
18:17:57 <Axman6> it's not particular popular though
18:21:09 <L8D> What does the infix operator do?
18:21:26 <L8D> not operator...
18:21:29 <L8D> keyword...
18:21:37 <Axman6> sets the fixity of an operator
18:21:50 <Axman6> left or right, and its precedence
18:21:51 <L8D> as in arity?
18:21:59 <L8D> or precedence?
18:22:04 <silasm> declares the fixity (and optionally precedence) of an operator
18:22:08 <roboguy_> L8D: no the arity is the number of arguments a function takes
18:22:11 <Axman6> no, infix operators "always" have arity 2
18:22:21 <roboguy_> except when they don't, hah
18:22:27 <silasm> left or right associativity
18:22:29 <Axman6> yeah :P
18:22:38 <L8D> What does that mean?
18:22:51 <L8D> I mean...Is there any documentation on it
18:23:05 <Axman6> sure, in the haskell... report?
18:23:12 <Axman6> I can't even remember what it's called
18:23:25 <L8D> I mean...where is the documentation on it?
18:23:36 <Axman6> @where report
18:23:37 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
18:23:46 <Axman6> hopefully it's there
18:23:52 <L8D> I know where the report is...
18:24:08 <Axman6> it's in there...
18:24:18 <roboguy_> L8D: $ associates to the right, so f $ g $ h x == f (g (h x))
18:24:21 <roboguy_> for example
18:24:38 <L8D> don't all operators associate to the right>
18:24:42 <roboguy_> no
18:24:42 <Axman6> no
18:24:43 <L8D> :s/>/?
18:24:55 <jle`> (:)
18:25:05 <L8D> I mean...don't all operators associate to the right by default?
18:25:05 <silasm> http://www.haskell.org/tutorial/functions.html#3.2.2
18:25:07 <jle`> oh wait
18:25:08 <Axman6> > a + b + c
18:25:10 <lambdabot>  a + b + c
18:25:12 <Axman6> urgh
18:25:13 <jle`> yeah heh
18:25:15 <enthropy> > 2 / 2 / 2
18:25:17 <lambdabot>  0.5
18:25:25 <silasm> not sure that'll properly bring you to 3.2.2, but scroll down to it if you need to.
18:25:26 <enthropy> that is infixl
18:25:32 <jle`> > 2 / 2 / 2
18:25:33 <enthropy> > 2 / (2 / 2)
18:25:33 <lambdabot>  0.5
18:25:34 <lambdabot>  2.0
18:25:46 <jle`> > (2 / 2) / 2
18:25:47 <lambdabot>  0.5
18:25:55 <roboguy_> L8D: infixl and infixr is how you control which way it associates (and it's precedence)
18:26:04 <sdegutis> > prnStrLn "foo"
18:26:06 <lambdabot>  Not in scope: `prnStrLn'
18:26:06 <lambdabot>  Perhaps you meant one of these:
18:26:06 <lambdabot>    `putStrLn' (imported from Prelude),
18:26:06 <lambdabot>    `BSC.putStrLn' (imported from Data.ByteString.Char8),
18:26:06 <lambdabot>    `BSLC.putStrLn' (imported from Data.ByteString.Lazy.Char8)
18:26:17 <sdegutis> welp, gave it my best
18:26:23 <jle`> > putStrLn "foo"
18:26:24 <lambdabot>  <IO ()>
18:26:25 <L8D> > putStrLn "foo"
18:26:26 <lambdabot>  <IO ()>
18:26:31 <L8D> > "foo"
18:26:32 <lambdabot>  "foo"
18:26:35 <sdegutis> oh yeah, mixing languages
18:26:37 * sdegutis sighs
18:26:44 <jle`> haha
18:26:52 <L8D> > foo
18:26:53 <lambdabot>  Not in scope: `foo'
18:26:53 <lambdabot>  Perhaps you meant `T.for' (imported from Data.Traversable)
18:27:00 <L8D> > a
18:27:01 <lambdabot>  a
18:27:04 <L8D> ???
18:27:09 <johnw> sclv: ping
18:27:16 <johnw> sclv_: ping_
18:27:21 <jle`> it's a part of reflections or something
18:27:21 <verement> :t a
18:27:22 <lambdabot> Expr
18:27:24 <jle`> meant for convenience
18:27:26 <dario|> lol "ping_"
18:27:33 <Axman6> > a / a / a
18:27:34 <lambdabot>  a / a / a
18:27:40 <L8D> > a + a - a
18:27:41 <lambdabot>  a + a - a
18:27:43 <Axman6> urgh, you're the worst lambdabot
18:27:51 <L8D> > a + (1 + 1)
18:27:52 <lambdabot>  a + (1 + 1)
18:27:58 <L8D> wtf lambdabot
18:28:01 <jle`> well...lambdabot does what is expected...it leaves off unecessary parentheses
18:28:08 <L8D> I wanna know what 1 + 1 is
18:28:09 <jle`> the parentheses in the first ones are not necessary
18:28:11 <jle`> oh
18:28:12 <Tekmo> > 1 + 1
18:28:14 <lambdabot>  2
18:28:20 <jle`> :t a + (1 + 1)
18:28:21 <lambdabot> Expr
18:28:34 <L8D> :t a >>= b
18:28:35 <lambdabot>     Couldn't match expected type `m0 a0' with actual type `Expr'
18:28:35 <lambdabot>     In the first argument of `(>>=)', namely `a'
18:28:35 <lambdabot>     In the expression: a >>= b
18:28:38 <jle`> ugh i upgraded a vim plugin and i think i broke ghc-mod integration
18:28:43 <L8D> :t a >>= putStrLn
18:28:44 <lambdabot>     Couldn't match expected type `IO String' with actual type `Expr'
18:28:44 <lambdabot>     In the first argument of `(>>=)', namely `a'
18:28:44 <lambdabot>     In the expression: a >>= putStrLn
18:28:55 <L8D> :t a >>= return
18:28:56 <lambdabot>     Couldn't match expected type `m0 b0' with actual type `Expr'
18:28:56 <lambdabot>     In the first argument of `(>>=)', namely `a'
18:28:56 <lambdabot>     In the expression: a >>= return
18:29:17 <L8D> :t a >>= return where a = Just 1
18:29:18 <lambdabot> parse error on input `where'
18:29:30 <Tekmo> > map f [a, b, c]
18:29:30 <L8D> @let a = Just 1
18:29:31 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
18:29:31 <lambdabot>    arising from a use of `e_1'
18:29:31 <lambdabot>  The type variable `b0' is ambiguous
18:29:31 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
18:29:31 <lambdabot>  Note: there are several potential instances:
18:29:33 <lambdabot>  Defined.
18:29:36 <roboguy_> :t let { ?a = undefined; ?b = undefined } in a >>= b
18:29:37 <lambdabot>     Ambiguous occurrence `a'
18:29:38 <lambdabot>     It could refer to either `L.a',
18:29:39 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:156:1
18:29:43 <L8D> @let a = Just 1
18:29:44 <lambdabot>  .L.hs:157:1:
18:29:44 <lambdabot>      Multiple declarations of `a'
18:29:45 <lambdabot>      Declared at: .L.hs:156:1
18:29:47 <lambdabot>                   .L.hs:157:1
18:29:48 <roboguy_> :t let { ?x = undefined; ?x = undefined } in x >>= y
18:29:49 <lambdabot>     Couldn't match expected type `m0 a0' with actual type `Expr'
18:29:51 <lambdabot>     In the first argument of `(>>=)', namely `x'
18:29:53 <lambdabot>     In the expression: x >>= y
18:29:59 <roboguy_> :t let { ?x = undefined; ?y = undefined } in x >>= y
18:30:01 <lambdabot>     Couldn't match expected type `m0 a0' with actual type `Expr'
18:30:01 <lambdabot>     In the first argument of `(>>=)', namely `x'
18:30:01 <lambdabot>     In the expression: x >>= y
18:30:03 <roboguy_> hmm
18:30:26 <Tekmo> > f a
18:30:27 <L8D> :t undefined >>= undefined
18:30:28 <lambdabot>  Ambiguous occurrence `a'
18:30:28 <lambdabot>  It could refer to either `L.a', defined at L.hs:156:1
18:30:28 <lambdabot>                        or `Debug.SimpleReflect.Vars.a',
18:30:28 <lambdabot>                           imported from `Debug.SimpleReflect' at L.hs:110:1-26
18:30:28 <lambdabot>                           (and originally defined in `simple-reflect-0.3.1:De...
18:30:29 <roboguy_> :t let { ?x = undefined; ?y = undefined } in ?x >>= ?y
18:30:30 <lambdabot> Monad m => m b
18:30:32 <lambdabot> Monad m => m b
18:30:32 <roboguy_> there we go
18:30:41 <Tekmo> :t f
18:30:42 <lambdabot> FromExpr a => a
18:30:48 <Axman6> holy lambdabot batman!
18:30:48 <Tekmo> Ugh, type classes
18:31:06 <Tekmo> > f (a :: Expr)
18:31:07 <lambdabot>  Ambiguous occurrence `a'
18:31:07 <lambdabot>  It could refer to either `L.a', defined at L.hs:156:1
18:31:07 <lambdabot>                        or `Debug.SimpleReflect.Vars.a',
18:31:07 <lambdabot>                           imported from `Debug.SimpleReflect' at L.hs:110:1-26
18:31:08 <lambdabot>                           (and originally defined in `simple-reflect-0.3.1:De...
18:31:08 <L8D> :t f a
18:31:09 <lambdabot>     Ambiguous occurrence `a'
18:31:11 <roboguy_> Tekmo: type classes are necessary sometimes
18:31:11 <lambdabot>     It could refer to either `L.a',
18:31:12 <L8D> :t f x
18:31:13 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:156:1
18:31:15 <lambdabot> FromExpr (Expr -> t) => t
18:31:21 <Tekmo> roboguy_: Yes, but this is a case of abuse
18:31:25 <L8D> > f x
18:31:27 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
18:31:27 <lambdabot>    arising from a use of `e_1'
18:31:27 <lambdabot>  The type variable `a0' is ambiguous
18:31:27 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
18:31:27 <lambdabot>  Note: there are several potential instances:
18:31:54 <roboguy_> Tekmo: hmm, how do you feel about makeClassy?
18:31:57 <Tekmo> :t L.a
18:31:57 <lambdabot> Num a => Maybe a
18:32:00 <L8D> Tekmo: are you responsible for this reflection BS?
18:32:03 <Tekmo> roboguy_: I do not like it
18:32:07 <Tekmo> No, not at all
18:32:16 <L8D> Who is?
18:32:20 <Tekmo> I think Cale?
18:32:24 <roboguy_> Tekmo: I had a feeling. I tried it a little bit, but it seems like generally a bad idea
18:32:27 <L8D> Cale: FIX IT!
18:32:59 <roboguy_> I guess you can kind of fake subtyping with it though
18:33:05 <Tekmo> roboguy_: The reason why is that type classes should have laws, otherwise there is no way to tell what a function that uses type class methods does
18:33:46 <Cale> wat
18:33:50 <Cale> It's not me
18:34:04 <L8D> then who is responsible for lambdabot ?
18:34:12 <geekosaur> @version
18:34:13 <lambdabot> lambdabot 5.0-int-e
18:34:13 <lambdabot> git clone git://github.com/int-e/lambdabot.git
18:34:13 <Tekmo> roboguy_: For example, if I see something use a field accessed using a type class, it tells me absolutely nothing about what that function does
18:34:16 <geekosaur> int-e
18:34:27 <Tekmo> roboguy_: It could literally do anything, depending on what types have fields of that name
18:34:31 <L8D> int-e: FIX IT!
18:34:47 <edwardk> Has anyone tried to talk to the chromium embedded C API from Haskell?
18:35:02 <jle`> check an ekmett library
18:35:04 <Axman6> Tekmo: you could, ya know, read the source :P
18:35:06 <jle`> i'm sure he has looked into it
18:35:11 <L8D> edwardk: couldn't you hook it up with a simple fii?
18:35:12 <ChongLi> edwardk: I was thinking about that the other week
18:35:13 <edwardk> jle`: will do =)
18:35:13 <L8D> ffi*
18:35:18 <ChongLi> I was playing with the webkit bindings
18:35:19 <Tekmo> Axman6: I'm talking about a function that is polymorphic over the type class
18:35:27 <Tekmo> Axman6: You can't know what the function does until the point of instantiation
18:35:32 <edwardk> L8D: I was mostly looking to see if someone beat me to it ;)
18:35:37 <ChongLi> and wondering whether it'd be worth doing a similar set of bindings for chromium
18:35:54 <Tekmo> edwardk: Have you had a chance to work on incorporating `void` into `base`?
18:36:03 <ski> > f a :: Expr
18:36:04 <lambdabot>  f a
18:36:08 <jle`> why is ghc-mod telling me that I can't use Template Haskell with a profiled compiler?
18:36:13 <ChongLi> what I'd really like is the ability to easily render a web page to a storable array of some kind
18:36:13 <jle`> i turned profiling off on my sandbox...
18:36:18 <edwardk> Tekmo: follow up with shachaf. it is his baby. =)
18:36:23 <ChongLi> and then be able to use that as a texture in OpenGL
18:36:36 <Tekmo> edwardk: I don't feel strongly enough about it to take it down
18:36:42 <Tekmo> edwardk: I just won't use it in my own code
18:37:06 <Tekmo> edwardk: Oh
18:37:13 <Tekmo> edwardk: I thought you were referring to `makeClassy`
18:37:14 <edwardk> Tekmo: i'm somewhat neutral on the issue. becomes harder to fix, and we're largely trying to take things _out_ of base at the moment, so it goes against the flow, but i don't care one way or the other more or less
18:37:25 <Tekmo> edwardk: Okay, I will ask shachaf about it
18:37:31 <ski> Tekmo : `void :: Functor f => f a -> f ()' ?
18:37:39 <edwardk> ski: Data.Void
18:37:39 <ChongLi> take things *out* of base? ahhh, interesting
18:37:42 <Tekmo> ski: No, I mean the `void` package
18:37:48 <ChongLi> Clojure went through a similar process
18:37:57 <ChongLi> they got rid of clojure contrib
18:38:05 <Tekmo> edwardk: I don't think there is anybody on the planet who will argue that the `Void` type should not be in `base`
18:38:25 <ChongLi> and put up a web page "Where did Clojure.Contrib go?"
18:38:39 <edwardk> Tekmo: i'm just not looking forward to fighting with people who want to kill an instance here or there
18:38:42 <ski> clearly if `Either' is in base, then `Void' should be as well
18:38:54 <Tekmo> edwardk: You have to play the politicis game, for all of our sakes! :)
18:38:57 <Tekmo> *politics
18:38:57 <jle`> how do i caball install a package at a given filepath?
18:38:58 <edwardk> but in general i see little problem with it
18:39:11 <ChongLi> edwardk: how small would you like to see base become?
18:39:14 <edwardk> Tekmo: it should be straightforward to move it into base
18:39:25 <Tekmo> edwardk: I spent some time to review that discussion about void
18:39:39 <Tekmo> edwardk: It seemed like the main hang up where the coercion things, like `vacuous`
18:39:47 <Tekmo> s/where/was
18:40:15 <Tekmo> edwardk: I think if you just said "we're keeping them" nobody would raise a serious stink about it
18:40:19 <roboguy_> doesn't vacuous potentially cause problems with GADTs?
18:40:51 <edwardk> ChongLi: with 7.10 we're just looking at fixing up the worst of it, e.g. moving Foldable/Traversable into the Prelude, getting rid of the monomorphic functions, etc.
18:40:52 <edwardk> Tekmo: a lot of that may become an easier sell around 7.10 with better roles support and coercible having had time to bae
18:40:52 <edwardk> er bake
18:40:54 <edwardk> i'm not in a hurry to cripple stuff that is in active use to satisfy a desire for minimalism
18:41:09 <ChongLi> edwardk: oh wow
18:41:21 <Tekmo> edwardk: No, I meant don't cripple it and transfer all those to `base`
18:41:39 <ChongLi> edwardk: that stuff has been the subject of countless arguments, I never realized it was actually going to happen :)
18:41:41 <Tekmo> edwardk: I really think nobody will care if you include those extra functions
18:42:15 <edwardk> ChongLi: we formed the core libraries committee so we could finally make these decisions, then they made the mistake of putting me in the chair. ;)
18:42:15 <ChongLi> what about moving pure, <*> and <$> into the Prelude?
18:42:40 <Tekmo> I agree with moving Applicative into the prelude
18:43:01 <Tekmo> edwardk: You need to be the "decider" :)
18:43:03 <edwardk> Tekmo: what'll likely happen at this rate is in 7.10 i'll push a patch adding it more or less as is, improving vacuous with whatever changes to functor come from the role changes
18:43:04 <Twey> That would be nice
18:43:18 <dwcook> edwardk, were you referring to pure versus return, or something else?
18:43:19 <Tekmo> edwardk: Alright, that sounds fine with me
18:43:28 <Tekmo> edwardk: I just wanted a concrete plan
18:43:38 <edwardk> dwcook: something else. pure vs. return will be with us for a long time.
18:43:50 <Twey> Oooh
18:44:06 <ChongLi> SPJ recently posted about pattern synonyms being merged into HEAD
18:44:11 <ChongLi> and it kinda scared me a little bit
18:44:12 <Twey> When we get Applicative as a true superclass of Monad, we can forget about ‘return’ and just use ‘pure’ everywhere
18:44:14 <Tekmo> Yeah
18:44:18 <Tekmo> I wish they would use Prisms
18:44:28 <Tekmo> Same thing with the new record proposal
18:44:29 <dwcook> Twey, except people will have written tons of Monad instances with return
18:44:37 <Tekmo> It seems like all they want to do is reinvent lens badly
18:44:40 <ChongLi> I'm worried the subtle evaluation order differences will make pattern matching really confusing
18:44:41 <Twey> dwcook: But nobody will have to use them
18:44:45 <edwardk> Tekmo: and now that you've dredged it up i can say that the last plan was to punt on it until we knew what was happening with fmapCoerce and Coercible and if that would be usable enough to get us a safe and sound O(1) vacuous. at which point the case for putting it in a supported location like base is very very strong
18:44:56 <jle`> what's the ListT that works?
18:44:58 <edwardk> and yes, the new pattern synonyms kind of make me sad
18:45:07 <edwardk> the only part i care about seems to be missing
18:45:08 <Tekmo> The one in pipes
18:45:26 <Tekmo> jle`: The `Pipes` module has the `ListT` that satisfies the laws
18:45:28 <jle`> Tekmo: thanks
18:45:36 <ChongLi> it doesn't seem very extensible
18:45:41 <Tekmo> jle`: The `pipes` tutorial also has a section explaining how to use it
18:45:52 <ChongLi> (the pattern synonyms, that is)
18:45:59 <dwcook> There's an illegal ListT? o_0
18:46:04 <Tekmo> edwardk: What was the part you were looking for?
18:46:13 <Tekmo> dwcook: Control.Monad.Trans.List violates the monad laws
18:46:18 <ChongLi> whereas Clojure has adopted the approach of predicate dispatch
18:46:19 <Tekmo> dwcook: It also doesn't stream
18:46:25 <jle`> dwcook: http://www.haskell.org/haskellwiki/ListT_done_right
18:46:26 <ChongLi> and separate destructuring bind
18:47:59 <AfC> dcoutts: thanks!
18:49:55 <AfC> dcoutts: so that works off the command line; is there a way to specify such options in .cabal/config? (it doesn't show up as one of the examples in the stock .cabal/config template
18:50:16 <edwardk> Tekmo: what I wanted is a way to hijack Coercible to get the cheaper lifting of f Void into f a, but it a.) doesn't quite work as is, and was the start of a very long 6 month discussion over how I could repurpose bits and pieces of the Coercible and role changes with Richard Eisenberg. So far, it isn't looking like I'll get all the things I need, but we're closer and they are at least aware of the limitations of the current approach
18:50:17 <edwardk>  w.r.t. monad transformers and the like
18:50:33 <Tekmo> edwardk: Alright
18:50:36 <Tekmo> edwardk: Then I can wait
18:51:08 <edwardk> Tekmo: so i'd rather have the right solution on a longer time table than a half-assed solution immediately that costs me functionality we can make better later ;)
18:51:44 <Tekmo> edwardk: That's fine with me
18:52:07 <ChongLi> it's the lazy evaluation approach to implementation :)
18:59:53 <manek> Hello :) Do somebody knows what does "Rec" mean in "RecConE" ? (TemplateHaskell)
19:00:16 <manek> Ahh Record!
19:09:53 <MitchellSalad> hey, i'm getting a non-exhaustive pattern match warning, can anyone see why? http://lpaste.net/98974
19:10:41 <MitchellSalad> is it a bug in viewpatterns?
19:13:17 <Twey> MitchellSalad: Yeah, GHC can't tell whether view patterns are exhaustive or not
19:14:26 <Twey> https://ghc.haskell.org/trac/ghc/ticket/595 https://ghc.haskell.org/trac/ghc/ticket/5762 &c.
19:15:02 <MitchellSalad> Twey: oh, ok thanks!
19:15:39 <dhrosa> what does &c mean?
19:16:07 <Iceland_jack> etc.
19:16:07 <geekosaur> "et cetera"
19:16:14 <Iceland_jack> & ≔ et
19:16:15 <dhrosa> ah
19:16:21 <roboguy_> it's a little weird to me that ScopedTypeVariables uses "forall"
19:17:12 <geekosaur> it is a bit weird, since it's kinda "backwards" from the normal meaning. on the other hand, it (a) existed already (b) already had (if inverted) "scoping" behavior
19:17:48 <geekosaur> and its normal meaning is pointless at the top level, so in that sense it was available
19:18:17 <Twey> It keeps backwards-compatibility without introducing a new keyword
19:18:46 <roboguy_> Twey: that's what I assumed. it still seems like it wouldn't break that much code to introduce a "scoped" or something
19:19:00 <roboguy_> especially since it's an extension
19:21:25 <Twey> roboguy_: It probably wouldn't, but it's nice to avoid the extra keyword.  If it were up to me we'd have ∀s everywhere and reduce our reliance on case distinctions, anyway.  :þ
19:22:21 <Twey> I think it's more that the ∀ serves as an indicator that whoever wrote the function was extension-aware and didn't expect H2010 compatibility
19:24:41 <mgsloan> It's certainly possible that it'd change the meaning of code without causing a compile error, though
19:25:07 <mgsloan> I agree it's unlikely
19:26:02 <roboguy_> mgsloan: it needs a period though
19:26:13 <roboguy_> forall a.
19:26:16 <Twey> mgsloan: But the idea is that if you're using ∀ you're already using non-standard features and understand the associated risks of instability
19:27:03 <mgsloan> And someone would probably only use a toplevel forall if they directly copied the type suggested by ghc for a top level function
19:27:29 <Twey> With ScopedTypeVariables, Rank2Types, or RankNTypes on
19:27:40 <roboguy_> well I mean, it's not really possible to change the meaning of code without error as long as it continues to require the .
19:28:22 <mgsloan> roboguy_: forall always requires a period though?
19:28:29 <Twey> roboguy_: The same code (using a ∀) can have different meanings with or without ScopedTypeVariables, though
19:29:25 <mgsloan> Yeah, some type might be more general without the extension
19:29:36 <Twey> Though I think the chance of it doing so without causing a compile error for either case is slim
19:29:39 <roboguy_> mgsloan: what I'm talking about is if they changed scoped type variables to use a different token (like scoped) and kept the period. so something like "scoped a."
19:29:53 <mgsloan> Twey: Yeah, it'd require some typeable or dynamic shenanigans
19:30:05 <Twey> Aye
19:30:28 <mgsloan> roboguy_: Gotcha, yeah, not a bad idea
19:30:31 <Twey> roboguy_: The thing is, ScopedTypeVariables is the right (default) behaviour
19:30:52 <Twey> It shouldn't really need to be explicitly introduced at all
19:30:59 <roboguy_> Twey: right. that would make more sense
19:31:03 <roboguy_> then forall would actually mean forall
19:31:15 <Twey> Well, it already does mean forall
19:31:30 <roboguy_> well, it does, but with scoped type variables it has additional meaning
19:31:55 <Twey> It just happens to indicate that the function is extension-aware, and therefore it's safe to use the (better) ScopedTypeVariables behaviour
19:32:38 <Twey> It would be nice if RankNTypes pulled in ScopedTypeVariables, I think, so there's no confusion
19:33:27 <Twey> (or if ScopedTypeVariables were just always on; it's triggered by syntax that's invalid in standard Haskell anyway, so there's no need to explicitly enable it)
19:33:49 <erisco> Twey, there does not seem to be anything standard for zippers yet. why is this?
19:34:00 <Twey> erisco: ‘Anything’?
19:35:25 <Twey> erisco: If you mean libraries, it's because the Haskell type system isn't powerful enough to talk about generic zippers, so it's a ‘design pattern’ rather than a generic library.  Quite a few data-type libraries define zippers for their types, though.
19:35:52 <roboguy_> Twey: lens has generic zippers doesn't it?
19:35:58 <Twey> erisco: Oh, there is this metaprogramming hack, though: http://hackage.haskell.org/package/syz
19:36:09 <Twey> roboguy_: I don't know; I don't think so
19:36:31 <Twey> A lens is kind of like a zipper semantically, but the performance characteristics are different
19:36:32 <mgsloan> lens does have some very generic zippers
19:36:38 <roboguy_> Twey, erisco: http://hackage.haskell.org/package/lens-3.10.1/docs/Control-Lens-Zipper.html
19:36:49 <mgsloan> Its actually a generalized zipper that allows you to descend into traversals
19:36:53 <roboguy_> I think they're going to put it into a separate library eventually
19:37:02 <mgsloan> which means you can move across some slice of the datastructure
19:37:24 <Twey> Ah, yep, that's neat
19:37:46 <mgsloan> iirc lens's zipper came from zippo: http://hackage.haskell.org/package/zippo-0.3/docs/Data-Lens-Zipper.html
19:37:46 <roboguy_> the problem is, it's hard for me to understand how to use it because it's so general. ekmett told me to look at an earlier version to get a better feel for the implementation
19:37:49 <Twey> You still have to generate the actual zippers for your types, though, I think
19:37:59 <Twey> « This is particularly powerful when compiled with plate, uniplate or biplate for walking down into self-similar children in syntax trees and other structures.
19:38:01 <Twey> »
19:38:03 <mgsloan> (or rather was inspired by it)
19:38:32 <roboguy_> lens sort of absorbed uniplate too
19:38:41 <erisco> mm okay
19:38:49 <mgsloan> Twey: Nah, you don't, you just need to use lenses that work on generics, or have lenses for your types
19:39:15 <Twey> Hm, okay
19:39:33 <mgsloan> The general idea is that if you can store the path you took down through the structure, along with the lenses that you took along the way, you've got a zipper
19:39:36 <Twey> What's the suggestion to use *plate all about, then?
19:39:58 <augur_> anyone know what i could read on the tension between modularity and code-on-code dependence?
19:40:10 <mgsloan> Twey: I think that's just a suggestion due to the efficiency of *plate
19:40:12 <Twey> mgsloan: That doesn't feel like a ‘real’ zipper — for me, constant-time access to the current element seems important
19:40:37 <mgsloan> You have constant time access to the current element - it's at the top of the list that leads back to the top
19:40:45 <edwardk> twey: you can use plate/biplate with the zippers to just walk down to all children of a given type
19:40:46 <mgsloan> err that was an ill formed statement
19:41:16 <Twey> mgsloan: But not to the next element?
19:41:17 <enthropy> those zippers don't let you delete elements though
19:41:21 <edwardk> Twey: we still have the constant time access in the lens style zippers
19:41:21 <mgsloan> What I mean is that the path from the root of the data you're modifying is in reverse order
19:41:27 <Twey> edwardk: Oh, okay
19:41:48 <edwardk> enthropy: to 'delete' you need to move up a level, then you can edit the current value to change the shape
19:42:09 <edwardk> enthropy: it is just a change in perspective
19:42:53 <edwardk> twey: it even comes with som nice features like log time jumping to keys in a Map/IntMap
19:44:04 <enthropy> edwardk: so lets say I have a zipper of [a], how do you express "delete the element above the focused element"?
19:44:42 <maxiepoo> is there a way to see the dependency graph for a cabal packages' dependencies?
19:44:45 <Twey> edwardk: Ooh, neat
19:44:59 <edwardk> well, in a lens style zipper you can have a zipper focused on the entire _tail_ not just an element of the list with the [a] a [a] style of derivative. at that point you can focus %~ tail
19:45:00 <enthropy> maxiepoo: did you try ghc-pkg dot?
19:45:00 <maxiepoo> i.e. so you can see what packages are pulling in a lot of dependencies
19:45:26 <intrados> What's the most sensible concurrency mechanism if I want a read-only thread (that, in mvar terms, doesn't empty an mvar) and a write-only thread (that, in mvar terms, replaces any previous contents)?
19:45:45 <intrados> readMvar doesn't work because "This function is atomic only if there are no other producers"
19:46:32 <Axman6> intrados: IORef?
19:46:51 <edwardk> enthropy: zippper [1..10] & fromWithin _tail & fromWithin _tail & fromWithin _tail & focus %~ tail
19:47:29 <edwardk> if you make a zipper using fromWithin traverse? yeah you can't delete, but then you can't sensibly do most anything, after al the data doesn't determine the rest of the structure!
19:47:42 <maxiepoo> enthropy, that looks like it should work, thanks
19:47:43 <edwardk> but there with the fromWithin _tail version you can because the 'focus' is a whole list
19:48:00 <edwardk> which is what you are punning when you edit a list zipper anyways
19:48:36 <enthropy> http://code.haskell.org/~aavogt/xmonad-hlist/src/XMonad/StackSet.hs is what I had before
19:48:40 <enthropy> maybe that _tail will help
19:49:18 <roboguy_> edwardk: has the zipper moved to another package yet?
19:49:22 <roboguy_> I don't see it in lens HEAD
19:49:44 <edwardk> roboguy_: we have a package for it on github IIRC, but i don't think we've moved everything over
19:50:02 <edwardk> in particular we want to restructure it so we can have simple zippers like 3.8 and the more complicated 3.9+ zippers
19:50:05 <augur_> is there a good discussion anywhere of solving for constraint-y things in general setting?
19:50:30 <intrados> Axman6: I think that should work. Thanks
19:50:46 <Axman6> intrados: do you need blocking?
19:53:19 <dwcook> I noticed a function type checked when in a where clause but did not outside, unless I gave it a type signature. Is this the DMR at work?
19:53:52 <intrados> Axman6: No. I think I can just seed the initial value and after that I don't need any blocking
19:55:25 <jfeltz> i find that I'm continually having to take a list of members of a data Constructor, and produce a list of (label, record access function), or (member description, record access function), is there a way to generalize this, or a pre-existing boilerplate tool for this?
19:57:40 <L8D> What are "numbers"?
19:57:44 <jfeltz> IE: something that infers from: Constructor { m1 :: Set Int, m2 :: Set Int }, it would infer a list of  [("m1", m1), ("m2",m2)] ?
19:57:44 <L8D> As used in...
19:57:57 <L8D> http://www.pyret.org/
19:58:05 <L8D> in the example comparing Java and Pyret
19:58:12 <L8D> about numbers
19:58:19 <enthropy> jfeltz: what do you do for data X = X { a :: Int, b :: Double }?
19:58:32 <enthropy> you can't make a list [a,b]
19:58:55 <L8D> enthropy: but you can make a union type
19:58:59 <jfeltz> enthropy: I understand, that isn't the case I'm interested in
19:59:01 <L8D> or use Either
19:59:05 <L8D> which is a union type
20:00:11 <enthropy> jfeltz: you know template haskell? You can write (reify ''X) and that will pretty much give you the definition of X
20:00:34 <qrada> im noobing out hard.. im in ghci, trying to import my modules in the current directory: import HMisc.Time ... and none of them seem to be available after I import.. However, when I compile my code that also imports them, it works fine.. any idea
20:00:38 <qrada> ?
20:00:59 <Hafydd> "noobing out hard" is my new favourite verb-noun phrase.
20:01:02 <L8D> qrada: use the :l or :i commands
20:01:25 <qrada> bang, thanks
20:01:33 <qrada> hah Hafydd
20:01:38 <enthropy> another option is add a deriving (Data), and that'll let you use a Data.Data.constrFields function
20:01:46 <L8D> :l loads the file directly if it's not a module
20:01:50 <L8D> :i loads the file as a module
20:02:25 <jfeltz> enthropy: thanks, I'll look into those!
20:02:29 <geekosaur> L8D: better off asking them than people here... like http://www.pyret.org/docs/s_numbers.html
20:02:50 <MedDev> qrada, you can also do :m +HMisc.Time
20:02:52 <qrada> cool.. im thinking about 'living inside' of ghci for a while, as a shell, for fun.. so ya :l worked
20:03:22 <L8D> geekosaur: I've already looked at that page. I'm wanting to know what exactly it is on a lower level. How it works, it's maximum size, etc..
20:03:23 <enthropy> L8D: yes that's one answer
20:03:38 <colDrMcBeardman> qrada: there's a bunch of helpers someone posted to a mailing list to put in your ghci
20:03:39 <L8D> I thought you guys might have an answer because I thought that Haskell has one of those
20:03:45 <colDrMcBeardman> maybe someone knows the reference.
20:03:46 <geekosaur> o.O
20:03:59 <MedDev> qrada, it's very useful. I use it all the time to get intermediate types and experiment with simple test data
20:04:12 <qrada> cool
20:04:48 <colDrMcBeardman> qrada: http://www.haskell.org/pipermail/haskell-cafe/2007-September/032260.html
20:04:58 <qrada> awesome, thanks for digging that up for me, checking it now
20:05:08 <colDrMcBeardman> found it. fun things like :pwd :ls
20:06:07 <colDrMcBeardman> qrada: http://www.haskell.org/haskellwiki/GHC/GHCi
20:06:15 <colDrMcBeardman> that also shows you how to plug hoogle and hlint into ghci
20:08:11 <qrada> nice, def going to add that into my env
20:08:21 <MedDev> qrada, ghc-mod is very useful too if you use vim or emacs
20:08:37 <qrada> :! ls
20:08:37 <qrada> word
20:09:57 <augur_> ahaha
20:09:57 <joelteon> is there no "safeUnmask" function in the standard library?
20:10:01 <joelteon> all I see is unsafeUnmask
20:10:05 <augur_> this twitter tiff between McBride and Harper is great
20:10:46 <nkpart> Hey is there a distributed-haskell irc channel around?
20:11:15 <qrada> #haskell-distributed
20:11:16 <qrada> i think
20:11:49 <ion> joelteon: mask (\safeUnmask -> …)
20:13:19 <joelteon> hmm...
20:15:57 <ion> (Well, calling that unmask is a bit inaccurate since it only restores the state outside the mask call.)
20:16:16 <ion> (But it’s probably what you want.)
20:16:50 <qrada> chsh -s /usr/bin/ghci
20:16:54 <qrada> eeuuuuughhh
20:17:07 <ChongLi> qrada: haha, wow
20:17:10 <L8D> how does one fix dependency hell with cabal?
20:17:17 <ChongLi> L8D: sandboxes
20:17:37 <L8D> ChongLi: Well, I'm installing things from cabal to use them on the command line...
20:17:45 <L8D> like hoogle
20:17:51 <ChongLi> sandboxes + path environment variable :)
20:18:20 <L8D> ...I don't think that would get me out of dependency hell...
20:18:26 <ChongLi> why not?
20:18:27 <L8D> If I needed to do that for each package
20:18:40 <ChongLi> you can group them together a bit
20:18:53 <L8D> If only cabal worked like npm...
20:19:14 <ChongLi> I have one that's xmonad + ghc-mod + hoogle + a few other utils
20:19:18 <ChongLi> it works fine
20:19:31 <ChongLi> it doesn't mess with my .cabal directory
20:20:15 <sdegutis> if i install the OS X haskell installer, is it uninstallable later?
20:20:27 <ChongLi> sure
20:20:52 <sdegutis> k
20:27:38 <qrada> omg :src
20:27:39 <qrada> dope
20:28:20 <L8D> qrada: though it only shows the pretty versions of functions
20:28:36 <L8D> like:
20:28:39 <L8D> @src sort
20:28:39 <lambdabot> sort = sortBy compare
20:28:47 <L8D> @src sortBy
20:28:47 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:28:52 <L8D> ^
20:29:31 <qrada> cool.. ya i've been going into source/bringing up links all of the time etc.. now i can do it in ghci
20:29:45 <qrada> this ghci shell thing is going to be fun
20:30:30 <L8D> I have four windows on my second monitor which are always open: Vim, Shell, Irssi and GHCi
20:31:55 <L8D> @src (+)
20:31:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:32:06 <L8D> @src (:)
20:32:06 <lambdabot> Source not found. I feel much better now.
20:32:19 <L8D> @src +
20:32:19 <lambdabot> Source not found. My pet ferret can type better than you!
20:32:48 <L8D> @src foldr
20:32:48 <lambdabot> foldr f z []     = z
20:32:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:33:01 <L8D> @src scanl
20:33:02 <lambdabot> scanl f q ls = q : case ls of
20:33:02 <lambdabot>     []   -> []
20:33:02 <lambdabot>     x:xs -> scanl f (f q x) xs
20:33:15 <L8D> @src sum
20:33:16 <lambdabot> sum = foldl (+) 0
20:33:21 <L8D> YEAH RIGHT
20:33:26 <roboguy_> why not?
20:33:43 <L8D> foldl (+) 0 is a reeeeaaaallly slow version of sum
20:33:55 <L8D> It should be using foldl2
20:34:03 <scott_> foldl'
20:34:04 <L8D> no, foldl'
20:34:07 <L8D> yeah, that
20:34:14 <qrada> L8D: ya im tmux with vim/shell/irssi, adding the ghci
20:34:16 <scott_> lambdabot just has 'theoretical' sources
20:34:20 <qrada> cabal install hoogle 2>&1 | awk '{print $1}' | xargs cabal install
20:34:27 <mikeplus64> i'm not sure what the point of a lazy left fold is at all
20:34:31 <Twey> foldl' isn't H98, though (and besides, GHC will optimize foldl to foldl' by strictness analysis with optimizations turned on)
20:34:32 <L8D> scott_: It follows the REPORT code
20:35:16 <qrada> is there a 'conventional' way to do that? basically, tried to install hoogle, complained about 20+ deps, then ran that, installed fine.. based on dcoutts suggestion earlier, specifying every library.. but is there a 'cleaner' way to install something like hoogle when it comaplains about so many deps?
20:35:22 <MedDev> qrada, i run ghci in vimshell. then i can collapse and expand it as a panel
20:35:27 <ChongLi> mikeplus64: it works fine for left-associative lists
20:35:30 <ChongLi> snoc lists
20:35:40 <roboguy_> it looks like the real source for sum isn't strict. hmm
20:35:55 <qrada> never heard of vimshell
20:36:26 <L8D> See how it preforms the ifdef USE_REPORT_PRELUDE in http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#last
20:36:33 <L8D> @src last
20:36:33 <lambdabot> last [x]    = x
20:36:33 <lambdabot> last (_:xs) = last xs
20:36:33 <lambdabot> last []     = undefined
20:36:42 <MedDev> qrada, https://github.com/Shougo/vimshell.vim
20:36:42 <L8D> wait a second
20:37:22 <Twey> roboguy_: You can have lazy numbers
20:37:28 <roboguy_> Twey: I know
20:37:34 <Twey> In which case you don't want sum to be strict
20:37:34 <qrada> MedDev: ah..
20:37:36 <MedDev> qrada, check out neocomplete (Lua version is much faster than the vimscript version) and neco-ghc, and ghcmod-vim :D
20:37:43 <Twey> Strictness analysis will take care of the cases where you do, anyway
20:37:43 <roboguy_> Twey: oh, you mean like lazy nats?
20:37:47 <Twey> roboguy_: Yes
20:38:04 <roboguy_> I've never used those, but I think I understand how they would work more or less
20:38:07 <qrada> in 3 months im going to force everyone's shell at work to be ghci with my .ghci
20:38:10 <qrada> lulu
20:38:11 <c_wraith> so if GHC gets stream fusion for lists, will that fix the foldl problem?
20:38:21 <Twey> 3 < sum [0 ..] -- this should terminate with lazy numbers
20:38:31 <Twey> c_wraith: What foldl problem?
20:38:31 <roboguy_> qrada: I kind of doubt ghci would make a good general purpose shell
20:38:32 <mikeplus64> ChongLi: well, foldl for a snoc list would be more or less foldr for lists
20:38:33 <c_wraith> (that problem being that with foldr/build fusion, foldl can't fuse)
20:38:38 <dhrosa> < 3 < sum [0..]
20:38:39 <Twey> Oh
20:38:40 <ChongLi> stream fusion is ideal for zip, foldl and filter
20:38:47 <qrada> roboguy_: ya im kidding but im toying with it
20:38:54 <Twey> dhrosa: I don't know if lambdabot has any lazy numbers in scope
20:38:59 <ChongLi> mikeplus64: yep
20:39:19 <MedDev> qrada, there was some discussions on reddit about a haskell shell called Hell :)
20:39:38 <MedDev> qrada, https://github.com/chrisdone/hell
20:39:59 <qrada> ya i saw it on github
20:40:00 <qrada> ya
20:44:25 <L8D> Plugin `sourcePlugin' failed with: state not initialized
20:44:27 <L8D> :(
20:55:52 <kazagistar> I know this is off topic, but I saw an article in the last few months sometime about a vaguely haskellish language/ide whose name I forgot that was AST centric, with the textual representations generated from the AST rather then vis versa, and I was wondering if anyone here could point me to it
20:57:26 <c_wraith> kazagistar: lambdu?
20:58:49 <ion> lamdu?
20:59:00 <dhrosa> lamdu!
20:59:17 <kazagistar> thats the one, thanks!
20:59:57 <kazagistar> it was something that looked really interesting, like something I would want to hack on, but I forgot to bookmark it, whoops
21:00:04 <Twey> It's Peaker's?
21:02:42 <ion> We like question marks?
21:03:01 <sclv> johnw: pong
21:03:20 <mgsloan> and exclamation marks!
21:03:21 <dhrosa> we like interrobangs!?
21:03:33 <johnw> sclv: the time is past, but thanks for ponging!
21:03:35 <Twey> ion: It was a request for confirmation :þ
21:03:52 <Twey> dhrosa: You call that an interrobang‽
21:04:21 <sclv> oh nevermind then
21:04:23 <sclv> glad to help
21:04:24 <dhrosa> I didn't realize a glyph for that actually existed
21:04:33 <ion> ⸘Do they use interrobangs like this in Spanish‽
21:06:17 <Twey> ion: I can only presume
21:06:33 <kazagistar> hmm, contribs seem to have died in July, but it is too interesting to not poke at when I get a chance, being freed from syntax in some sense makes for some really interesting possibilities
21:09:42 * hackagebot type-natural 0.0.6.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.0.6.0 (HiromiIshii)
21:10:28 <Twey> Hooray
21:13:01 <mgsloan> kazagistar: I think that's because they (peaker and yairchu) have gone into research mode
21:13:09 <mgsloan> trying to figure out the typesystem
21:13:23 <mgsloan> Or how type inference ought to work
21:13:26 <mgsloan> or something like that :)
21:13:59 <mgsloan> So, it's not dead it's just cogitating
21:16:10 <kazagistar> mgsloan: hmm interesting... I hope they use the IDE-ness to help make it fast and loose with decidability? Like... "hmm, this part here seems to be a bit difficult to infer, would you like to give us a hint to unfuck your code?" :P
21:17:26 <jfischoff> I would like to see that
21:17:35 <jfischoff> I think I would like it, but I'm not positive
21:17:43 <mgsloan> I think that's roughly the idea.  My impression is that their idea is that type inference is a UI aspect and should be integrated into the IDE
21:17:58 <kazagistar> same, not sure if it would be good, but it would be good to try
21:18:48 <lispy> mgsloan: Do you know if they've looked at type-correcting inference? I don't know if that's the proper name, but I once read a paper where the typing algorithm could suggest changes to your terms based on type errors.
21:20:39 <mgsloan> lispy: Sounds cool!  I know they're reading papers and such, but I'm not involved in the project at all, just another interested observer :D
21:21:03 <lispy> okay. I'm trying to find the research that I saw before.
21:21:32 <jfischoff> mgsloan: I'm late to the party, who is this?
21:21:44 <mgsloan> jfischoff: Peaker's lamdu project
21:21:56 <jfischoff> oh cool
21:25:33 <mgsloan> I'm not sure if this is one of lamdu's ideas, but it seems related:  It seems to make a lot of sense to store the types along with your code, so that type errors appear nearest to the location you're editing
21:27:11 <mgsloan> What I mean is that if you've already unified your type variables, and you're incrementally inferring the types of your modified AST, then the error can only happen at the point of modification
21:27:34 <mgsloan> The problem with this is that you can't cause the types to get more general
21:27:44 <mgsloan> So you'd need to have some sort of "re-infer" operation orso
21:27:50 <mgsloan> anywho, it's a big ol mess of UI design
21:28:48 <mgsloan> I'd love to see more research in this sort of area though - the intersection of type system and UI
21:29:18 <kazagistar> mgsloan: programming languages are always partially UI design. They are just moving a bit past the "text file, compile, spit errors" UI :P
21:29:37 <mgsloan> I certainly hope so!
21:29:38 <the_berserker> @pl \x y z -> x z (y z)
21:29:39 <lambdabot> ap
21:30:21 <nstdloop> what does @pl do?
21:30:30 <Iceland_jack> finds a pointless version :)
21:30:44 <Iceland_jack> @pl \a b -> a + b
21:30:45 <lambdabot> (+)
21:30:47 <the_berserker> Can you calculate everything using only `ap`, `const` and `id` and infinite types?
21:30:48 <nstdloop> How does it do that?
21:31:01 <nstdloop> That seems like it would be non-trivial
21:31:43 <dwcook> the_berserker, careful with your use of the word "ap". Hereabouts it refers to
21:31:44 <dwcook> @type ap
21:31:45 <lambdabot> Monad m => m (a -> b) -> m a -> m b
21:31:55 <Iceland_jack> @pl \xs n -> take n xs
21:31:55 <lambdabot> flip take
21:32:13 <dwcook> Um, okay. I guess I won't expound on SKI then :)
21:32:53 <roboguy_> S = ap = (<*>)
21:33:32 <Iceland_jack> @ty ap :: (r -> a -> b) -> (r -> a) -> r -> b
21:33:33 <lambdabot> (r -> a -> b) -> (r -> a) -> r -> b
21:33:34 <dwcook> For what type?
21:33:48 <dwcook> Ah.
21:34:07 <Iceland_jack> ((→) r)
21:38:18 <lispy> mgsloan, Peaker, et al: https://www.era.lib.ed.ac.uk/bitstream/1842/368/1/ECS-LFCS-02-427.pdf
21:40:15 <joelteon> what's the opposite of lift
21:40:33 <ski> "lower" ?
21:41:05 * ski expounds on DWCOOK
21:41:14 <dwcook> :P
21:41:21 * dwcook skis on EXPOUND
21:41:40 * ski bounces up and down
21:42:37 <ski> mgsloan : have you seen type error slicing ?
21:43:55 <mgsloan> ski: I have!  I even wrote an awfully hacky implementation for haskell: https://github.com/mgsloan/panopti/blob/f400f0fa5c4245042d0a2370d7bcfa51988e08a5/src/TypeInfo.hs#L153
21:44:44 * hackagebot concurrent-state 0.4.1.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.4.1.0 (JoelTaylor)
21:45:44 <mgsloan> lispy: Thanks! Taking a look at it now
21:45:46 <codygman> What would be the easiest way to set a default if a command line argument isn't provided? I was looking into getOpt, would that be easiest? I was thinking I might be able to do something with getArgs and a Maybe since there is only one possible command line argument. Any ideas?
21:45:56 <codygman> one possible valid*
21:46:54 <the_berserker> @pl \f m -> m >>= (\x -> return (f x))
21:46:54 <lambdabot> fmap
21:47:24 <the_berserker> What is the definition of fmap in point-free style
21:47:28 <lispy> codygman: I think the easiest way is to make a record that contains all your configuration.
21:47:42 <lispy> codygman: then create a defaultOptions value of that record with the default values.
21:47:53 <the_berserker> @pl \x -> return (f x)
21:47:54 <lambdabot> return . f
21:47:55 <Axman6> the_berserker: it depends on the type you're fmapping
21:48:04 <mgsloan> ski: Problem is I was trying to do everything without the GHC API, because back then it was freaky to me.  So I ended up doing things like starting to write a parser for GHC error messages: https://github.com/mgsloan/panopti/blob/f400f0fa5c4245042d0a2370d7bcfa51988e08a5/src/ErrorParser.hs
21:48:07 <Axman6> but for any monad, that will work ;)
21:48:13 <codygman> lispy: Alright, that seems a bit heavy for a one-time only script but not too bad. Thanks!
21:48:18 <lispy> codygman: If you're using something like getOpt you can have the argument parsing transform that defaultOptions value into the one for your particular program run.
21:48:24 <mgsloan> ski: And then interrogating the compiler about the types by way of the error messages
21:48:28 <Axman6> :t (pure .)
21:48:28 <lambdabot> Applicative f => (a -> b) -> a -> f b
21:48:48 <the_berserker> What is the definition of fmap in terms of bind and return in point-free style?
21:48:52 <lispy> codygman: This is the template I use whenever using getopts: http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt#Advertised_technique
21:49:17 <dwcook> @src liftM
21:49:17 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:49:20 <dwcook> Hrm
21:49:22 <codygman> lispy: Thanks for that, that'll do what I need and more :)
21:49:23 <ski> mgsloan : sounds like pure fun
21:49:32 <dwcook> @pl \f m1 -> do { x1 <- m1; return (f x1) }
21:49:33 <lambdabot> (line 1, column 13):
21:49:33 <lambdabot> unexpected '{'
21:49:33 <lambdabot> expecting variable, "(", operator or end of input
21:49:37 * johnw perks his ears at the mention of pure fun
21:49:38 <intrados> Is '#ifndef HLINT' supposed to prevent hlint parse errors?
21:50:01 <lispy> codygman: yw. My experience with 'simple scripts than need one cli option' is that pretty soon you'll want 2 or 3 more :)
21:50:37 <codygman> lispy: That is very true, but this one is for the stripe CTF challenge so I don't *think* it'll get more than one use ;)
21:50:46 <lispy> ah
21:51:13 <jfischoff> mgsloan: parsing code with the GHC api is surprisingly difficult
21:51:15 <dwcook> @pl \f m1 -> m1 >>= return . f
21:51:15 <lambdabot> fmap
21:51:18 <dwcook> >_<
21:51:34 * ski . o O ( "Pure Trance" by Junko Mizuno )
21:51:37 <mgsloan> jfischoff: Aye, I messed around with that in order to have a comparison test for HSE
21:51:46 <johnw> mgsloan: how much harder is it?
21:52:25 <mgsloan> johnw: It's not /that/ bad: https://gist.github.com/mgsloan/2dd89938de77375a86cc
21:52:43 <johnw> wow
21:52:54 <mgsloan> Everything after line 36 is application specific
21:53:08 <mgsloan> So really only 5 lines
21:53:27 <jfischoff> did you do CPP though?
21:53:31 <mgsloan> The real pisser is that the AST that results has bottoms in it
21:53:33 <mgsloan> nah
21:53:51 <jfischoff> right I think it is weird there is no "parse"
21:53:56 <mgsloan> This is why chris didn't use the GHC API for structured-haskell-mode
21:54:07 <jfischoff> you have to parse and get the extensions, and then run the passes, ugh
21:54:31 <mgsloan> also GHC's ASTs don't have the same amount of source annotation as HSE's iirc
21:55:46 <mgsloan> For a pure language compiler implementation, GHC seems to be awfully stateful, glorious and great though it may be
21:56:04 <jfischoff> johns, mgsloan: parsing with CPP https://github.com/jfischoff/modulespection/blob/master/src/Language/Haskell/TH/Module/Magic.hs#L108
21:56:17 <jfischoff> pretty much ripped and from GHC
21:56:26 <jfischoff> mgsloan: yeah
21:56:37 <dwcook> @pl flip (>>=) . (return .)
21:56:38 <lambdabot> fmap
21:56:53 <mgsloan> Or maybe it's not the statefulness, but the reluctance to define variants of the AST
21:56:55 <dwcook> Well that was fun to figure out even though that person left again
21:57:17 <mgsloan> jfischoff: Yeah, I remember you mentioning that project, cool stuff!
21:57:28 <mgsloan> Awful hacks, but handy ones
21:57:38 <jfischoff> thanks, I need to fix the remaining issues and advertise it
21:57:40 <jfischoff> yeah
21:58:26 <mgsloan> Have you seen fast-tags?  Not a perfect solution, but seems good if you only need names and not details
21:59:00 <mgsloan> And I guess if you don't care about the CPP environment
21:59:01 <jfischoff> interesting
21:59:31 <mgsloan> I guess you could apply cpphs before fast tags
22:00:10 <jfischoff> when is haskell-src-exts going to support LambdaCase
22:00:35 <jfischoff> I can't use it at work, because it breaks all the tools :(
22:01:52 <cbarrett> hello
22:02:13 <mgsloan> jfischoff: There is an open pull request for it: https://github.com/haskell-suite/haskell-src-exts/pull/33
22:02:49 <jfischoff> so close :)
22:03:03 <cbarrett> I'm working on file processing tool, think something like make or jekyll. comonads have been a great fit so far.
22:03:18 <mgsloan> Considering how many rough corners there are to HSE, I imagine it won't be a problem to merge a 90% solution in
22:03:27 <cbarrett> unfortunately I'm not sure how exactly to represent "while processing file A, we'd like to also consult the contents of file B"
22:03:42 <jfischoff> heh
22:04:03 <cbarrett> It seems like you'd either end up with MyComonad (IO a), or if you sequenced them, IO (MyComonad a), neither of which are particularly useful
22:04:19 <cbarrett> is there anywhere that I should look for possible inspiration?
22:04:24 <cbarrett> or if yall have ideas, happy to hear them
22:06:42 <osa1> do bytestrings provide faster lookups in hash based table structures?
22:07:31 <Ralith> do you have a program that is hash table lookup bound?
22:08:50 <osa1> I don't know if it's hash table lookup bound yet :-)
22:09:03 <jfischoff> vs what?
22:09:10 <osa1> vs. [Char]
22:09:22 <jfischoff> I bet they do
22:13:14 <jfischoff> osa1: from looking at the source I again think the answer is yes ByteString will be much faster
22:15:13 <kusut> is there a haskell beginner channel?
22:16:46 <dwcook> kusut, this is it
22:16:48 <dwcook> ask away
22:16:51 <randomclown> How do I guarentee that when I write a word8 into a foreign Ptr it's in little endian
22:17:05 <qrada> ya Hell (haskell shell) is fun
22:18:03 <randomclown> I mean word32 obviously
22:18:31 <enthropy> make people use a little endian architecture
22:19:05 <randomclown> enthropy: you can't be this dumb
22:20:41 <edwardk> cbarrett: you may want to consider constructing a typeclass for a comonad over the Kleisli category of IO.
22:21:12 <cbarrett> edwardk: I think I'm following but can you explain a little bit more
22:21:46 <edwardk> cbarrett: something like     class IOComonad w where extractIO :: w a -> IO a; extendIO :: (w a -> IO b) -> w a -> IO (w b)
22:22:01 <enthropy> randomclown: sure I can be. You might instead make the type (Ptr Word8) and then write the bytes in the order that you like
22:22:10 <manek> Hello :) I think this is a simple question, but I havent used something like this before. I've got a datatype "data X a = X {x :: a Int} deriving (Show)". GHC complains that "No instance for (Show (a Int))". How can I add constrain, that guarantees this situation and allows me to compile this code?
22:22:10 <cbarrett> edwardk: ah, yeah, I've considered that
22:22:25 <edwardk> or class KleisliComonad m w | w -> m where extractM :: w a -> m a; extendM :: (w a -> m b) -> w a -> m (w b)
22:22:47 <enthropy> probably there is a way to know if you have to do a conversion
22:23:11 <kusut> I installed GHC with apt-get, then tried to configure/build/install/bootstrap cabal-install from source. I plan to do some isolation with sandbox while learning haskell, is this a good way to go?
22:23:21 <cbarrett> edwardk: thanks
22:23:28 <dwcook> kusut, you might be better of installing haskell-platform to get cabal
22:23:34 <dwcook> s/of/off/
22:23:35 <edwardk> you can often modify extendM to get (w a -> m b) -> w a -> w b  as well, depends on the comonad. that latter is a stronger statement though, so it doesn't always work
22:23:44 <cbarrett> right.
22:24:04 <dwcook> or just install the cabal-install package
22:24:07 <kusut> dwcook: so it is okay to have some packages in global?
22:24:16 <cbarrett> edwardk: another thing I was considering was, since in this case the only operation I need to support is "I would like the contents of a particular file", a combination of TracedT and EnvT
22:24:21 <pavonia> manek: Try standalone deriving: "deriving instance Show (a Int) => Show X a"
22:24:51 <kusut> dwcook: cabal in haskell platform is outdated, cant do sandbox
22:24:52 <dwcook> kusut, not sure; I am going to change my suggestion to just installing cabal-install as that's probably safer
22:24:54 <edwardk> for me i wound up using that model when porting the .net reactive framework to haskell for a project, as the Observable type is both a monad, and a comonad over Kleisli 'Task', where Task is what permits IO actions and spawning new tasks
22:24:58 <dwcook> Oh, oh well
22:24:58 <pavonia> manek: But you probably need to constraint the 'a' too
22:25:45 <dwcook> Then I suppose you're on the right track already, though I've never done what you're doing
22:27:09 <tikhon> hey, has anyone here played around with some sort of sized vectors (ie with a type-level number for length)?
22:27:09 <manek> pavonia: This does not change anything. I'm trying other options, brb
22:27:35 <tikhon> I'm curious about what sort of problems this can help prevent in practice
22:27:39 <cbarrett> edwardk: Did you ever publish that? I'd be really interested in seeing that
22:28:45 <cbarrett> edwardk: thanks very much for the KleisliComonad idea, hadn't thought of that.
22:28:49 <edwardk> not really. there is an old-and-busted version on github.com/ekmett/reactor and a differently old-and-busted fragment on github.com/ekmett/tasks
22:29:27 <edwardk> tikhon: there are sized vectors in linear. V 4 Int, etc.
22:29:32 <manek> pavonia: I cannot make it working :( I was trying several ways, including osmething like (data X a = X {x :: forall a. Show (a Int) => a Int } ), ut still without success
22:29:34 <cbarrett> edwardk: thanks!
22:29:48 * hackagebot JuicyPixels 3.1.3.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.3.1 (VincentBerthoux)
22:29:53 <tikhon> edwardk: oh yeah, I've been meaning to look at that package for a while
22:30:28 <edwardk> cbarrett: the workstealing deque in reactor is busted. a fixed version is in the chaselev-deque package, a pretty version of that is in an old branch of my structures repo ;)
22:30:54 <tikhon> right now I'm mostly writing a blog post/quora answer about why I like static types, and I'm looking for interesting examples
22:30:57 <cbarrett> edwardk: :)
22:31:18 <cbarrett> edwardk: I've found your blog and all your code really helpful in moving into being a solid intermediate haskeller.
22:31:52 <edwardk> writing it was really helpful in moving me into being a solid intermediate haskeller as well ;)
22:32:23 <cbarrett> hahaha
22:33:53 <manek> pavonia: Ouch, do I have to use UndecidableInstances in such simpl code? It seems, the only version thath currently compiles is this one: http://lpaste.net/98977
22:34:36 <pavonia> Yeah, I noticed when I was preparing an example :)
22:34:52 <cbarrett> edwardk: is your background in mathematics?
22:35:22 <manek> pavonia: Hmm, but this is terrible. I'm trying not to use UndecidableInstances whenever I can. Is there other way to code it?
22:35:52 <edwardk> cbarrett: i was a programmer for a long time, then i went back and collected degrees. one of those was in math =)
22:36:26 <pavonia> manek: I don't think so. Why do you need a completly unconstrained 'a' at all?
22:36:32 <edwardk> cbarrett: i found haskell right as i was finishing up hiding in academia post-dot-com-crash
22:36:33 <cbarrett> edwardk: neat!
22:37:32 <manek> pavonia: hmm, It would be constrainted. Oh, maybe after giving some constrains it will work nicer (but after rethinking it, I do not think so)
22:37:49 <edwardk> cbarrett: i like to delude myself that the backwards order that i did everything gave me a good sense of the practical while preferring solutions that are a little bit farther afield and more interesting than the obvious
22:38:02 <edwardk> but i confess i sometimes fetishize abstraction =)
22:38:10 <johnw> edwardk: :)
22:38:19 <bitemyapp> edwardk: *composable and typesafe* abstraction
22:38:58 <edwardk> bitemyapp: it is easy to write painfully abstract code, it is hard to find the right abstractions that the code is usefully abstracted
22:38:59 <pavonia> manek: Yes, I think you need an additional type constructor in the constraint
22:39:22 <cbarrett> edwardk: I understand the temptation
22:40:20 <edwardk> about 2 years into writing haskell i realized i could get it to say anything i wanted. i'd learned enough of the oleg tricks to contort MPTCs and the instance resolution order to get all sorts of terrible abominations to compile, but then i realized i didn't want to maintain that crap.
22:41:07 <tikhon> that starts feeling a bit like writing half your code in a bastardized prolog with no tooling
22:41:15 <cbarrett> edwardk: hahaha
22:41:30 <jhinkle> manek: same thing you posted in #nixos? If so, leave off the deriving (Show) in the data declaration and add a constrained instance of Show separately. would that do what you want?
22:41:41 <edwardk> and fortunately folks around me, *cough* roconnor *cough* and the like were pestering me for simpler core packages at the time, so I went on a Haskell 98 binge. It forced me to clean up my coding style a lot. It also showed me how much better inference can be when you pick your extensions more judiciously
22:42:46 <manek> jhinkle: by accident
22:43:15 <edwardk> lens is somewhat of a foray back into the realm of every-extension-known-to-man, while trying to retain the benefits of the other approach. the jury is still out.
22:43:29 <manek> jhinkle: As I've written above: It seems, the only way of making it working is to use UndecidableIsntances: http://lpaste.net/98977 . This is ugly and I'm looking for something pretter if there is better solution
22:43:49 <manek> jhinkle: But as pavonia suggested, maybe I can write it other way around, brb
22:44:10 <cbarrett> edwardk: I have not used lens much myself yet. I'm eager to sit down and dissect it.
22:44:54 <ChongLi> I'm reading this paper about using HERMIT to do implement stream fusion of the concatMap operation
22:45:12 <jfischoff> One valuable nice thing about learning how Oleg's tricks work, is you have to learn a lot about type classes.
22:45:32 <ChongLi> this sounds very good, will it inform the development of new transformations in GHC?
22:45:37 <jfischoff> its also the style of programming for the GHC generics stuff
22:45:39 <ChongLi> or will it be relegated to plugin status?
22:45:53 <manek> pavonia: Could you tell more about the "additional type constructor in the constraint"? What do you mean by that?
22:45:57 <edwardk> jfischoff: yeah. i learned a lot by bumming around in every old cafe post or entry he'd ever posted to his site =)
22:46:39 <jfischoff> Yeah, I haven't gone through all his stuff yet, but it is on my todo list :p
22:47:00 <pavonia> manek: You need at least as much type constructors/variables on the left size as on the right or so
22:47:12 <cbarrett> oleg is amazing
22:47:22 <enthropy> you can get better inference sometimes by throwing more extensions at the problem
22:47:31 <pavonia> manek: here are the rules: http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/type-class-extensions.html#instance-rules
22:48:12 <enthropy> say -XConstraintKinds + some type families to do the calculations in each direction
22:49:00 <edwardk> ChongLi: well, concatMap was the last big holdout for why destroy/unfoldr fusion wasn't just basically universally better, it'd be nice to have swap from foldr/build to that style, as dcoutts' thesis on the topic seems to be at the heart of most 'let's compile this and optimize it into something faster' loop restructuring library in the last few years.
22:49:56 <ChongLi> edwardk: yeah, and concatMap is really important because it lets us do nested stuff
22:49:58 <edwardk> ChongLi: given sufficiently good numbers, the GHC folks can be won over about putting something like that in mainline, rather than some plugin
22:50:07 <manek> pavonia: Thank you
22:50:19 <ChongLi> I really hope it works out
22:50:49 <jfischoff> HERMIT is "fun" to play with
22:51:03 <jfischoff> The Core is prettier
22:51:26 <edwardk> enthropy: usually you get worse inference though. FlexibleInstances mean more opportunities for head match failures, because the kinds of things that _can_ fail can now typecheck, etc.   instance Foo (a -> a)  for instance wouldn't typecheck without it, but is very brittle.
22:51:28 <jfischoff> as in the UI for the core
22:51:38 <ChongLi> could something akin to HERMIT ever become mainline GHC?
22:51:50 <edwardk> jfischoff: i need to go deeper on that side
22:51:56 <ChongLi> that is to say, a high-level language for expressing core-to-core transformations
22:52:59 <ChongLi> it would knock off another one of Lisp's little "advantages"
22:53:03 <bitemyapp> carter: do people invent programming languages intended for industrial use without reading any papers or what?
22:53:13 <carter> bitemyapp: this is a -blah thread
22:53:18 <ChongLi> and maintain type safety pre/post transformation
22:53:30 <ChongLi> which is at the heart of everything we do
22:54:09 <jfischoff> edwardk: Loop unrolling works "well", I was able to incline a dictionary for (+) out, I'm still figuring it, every few months :p
22:54:29 <ChongLi> not that I'm all that interested in some kind of contest with lisp (I'm not)
22:54:43 <ChongLi> but I really like the idea of having a lot of the advantages of macros without having to write macros
22:55:00 <edwardk> bitemyapp: evidence suggests yes. that said, yeah, this is #haskell-blah material =)
22:55:10 <ChongLi> and that's what putting these sorts of transformations into the libraries would give us
22:55:17 <ChongLi> (and the compiler, of course)
22:55:19 <edwardk> ChongLi: learn scheme's syntax-rules
22:55:28 <jfischoff> edwardk: I think it is a better viewer for core than ghc-core, once you learn how to navigate (i.e. consider 'foo)
22:55:44 <bitemyapp> edwardk: yes sorry!
22:55:50 <ChongLi> edwardk: I will, I've previously only looked at macros in Clojure
22:55:52 <edwardk> jfischoff: that is a strong motivator for me to dig deeper
22:56:30 <cbarrett> what is #haskell-blah?
22:56:36 <edwardk> bitemyapp: no worries. i drift off topic here a lot myself, until folks complain. ;)
22:56:58 <ChongLi> edwardk: yeah, I do that too :)
22:57:03 <jfischoff> probably the easiest way to get started: http://www.ittc.ku.edu/csdlblog/?author=2
22:57:33 <edwardk> cbarrett: #haskell-blah is the channel for discussing off topic stuff, we usually send folks there when they want to talk to the #haskell folks about non #haskell topics and the channel is otherwise noisy with on topic material.
22:57:59 <cbarrett> makes sense
22:57:59 <ChongLi> I figure it's not a big deal most of the time, as long as people who are here to get help aren't being ignored
22:58:10 <roboguy_> hmm, do you guys know where the Haskell version of that paper on finally tagless interpreters is?
22:58:15 <ChongLi> I try to drop my OT stuff when I see someone who needs help
22:58:15 <edwardk> cbarrett: it also has the benefit of not being logged publicly, so it is easier to ramble on without consequence
22:58:28 <edwardk> roboguy_: sure. one sec.
22:58:36 <edwardk> http://www.cs.rutgers.edu/~ccshan/tagless/jfp.pdf
22:58:47 <cbarrett> edwardk: I tend to assume anything said on IRC is "public" but yes, that's true
22:58:59 <cbarrett> (never know who might be logging)
22:59:03 <jfischoff> roboguy_: did you mean this? http://okmij.org/ftp/tagless-final/course/lecture.pdf
22:59:13 <roboguy_> yeah, thanks
22:59:19 <cbarrett> I'm probably slightly more paranoid than your average bear because of $work though
22:59:21 <edwardk> cbarrett: sure. but with #haskell the logs are available in a very public place, etc.
22:59:26 <cbarrett> yeah
22:59:31 <cbarrett> indeed
23:00:08 <ChongLi> edwardk: so what was it you wanted to see in pattern synonyms that didn't make it?
23:00:31 <edwardk> my understanding from looking earlier was that the richer bidirectional syntax isn't in yet
23:00:53 <edwardk> that means i can't go through lens and provide patterns to go with all the prisms.
23:01:00 <ChongLi> ahhhh
23:01:07 <edwardk> that would have been a nice API addition fr 4.0
23:01:33 <edwardk> and would have made prisms a _heck_ of a lot nicer to use
23:01:34 <manek> Hmm, I was on the oficial website of HERMIT right now - its seem to be a big and complex thing. Could somebody who knows it tell me please what can it be used to? :)
23:01:47 <ChongLi> so would that entail the ability to apply prisms on the left-hand side of the equation?
23:02:20 <edwardk> well, it'd be boilerplate to set that up, but i was hoping to use TH to generate that boilerplate with something like makePrisms
23:02:38 <ChongLi> ahhh
23:02:56 <jfischoff> manek: its can rewrite the haskell core. It's used for compiler optimizations, like inlining and loop unrolling, etc
23:03:18 <edwardk> data Baz a b = Foo_ a | Bar_ b ; makeClassyPrisms ''Baz  could make the classy _Foo and _Bar prisms and patterns named Foo and Bar that used them
23:03:44 <edwardk> as it is i can't seem to write anything i want to write with them, but maybe that'll change
23:04:25 <ChongLi> what about stuff like the nat prism?
23:04:26 <manek> jfischoff: oh, so it is used by GHC internals? I'm asking just out of curious - could it be usefull for doing anything not related to GHC development?
23:04:35 <ChongLi> write a function that pattern-matches on natural numbers?
23:05:10 <cbarrett> Huh, associated pattern synonyms.
23:05:37 <randomclown> why did the ByteString to ForeignPtr functions disappear in bytstring docs 10
23:06:49 <cbarrett> heh, "I am not suggesting typed pattern synonyms for Haskell. Yet."
23:06:59 <edwardk> ChongLi: well, you'd have something like (Nat n) which could be used to matc
23:07:20 * edwardk falls asleep.
23:07:22 <ChongLi> something like: foo x^?nat = x + 1; foo _ = 0;
23:07:24 <edwardk> Night folks
23:07:28 <ChongLi> night!
23:07:33 <cbarrett> edwardk: good night, nice to talk to you
23:07:34 <edwardk> well
23:07:34 <cbarrett> thank you
23:07:43 <carter> o/ edwardk  the m4 sitch has been solved
23:07:48 <edwardk> foo (Nat x) = x + 1; foo _ = 0
23:07:58 <gabor> cbarrett: that would be me :-)
23:08:01 <ChongLi> right, but then you have to use a Nat type
23:08:02 <edwardk> carter: good, saved me the trouble of reading your patch =)
23:08:09 <ChongLi> whereas mine would be with an Integer type
23:08:15 <edwardk> ChongLi: using a view pattern for Nat
23:08:20 <ChongLi> ohhh
23:08:22 <carter> edwardk: some heroic person named peter gave my patch some pull requests
23:08:26 <cbarrett> gabor: omega looks really interesting
23:08:30 <edwardk> ChongLi: where that view pattern uses the prism
23:08:37 * ChongLi needs to learn view patterns
23:08:43 <edwardk> ChongLi: that was what i was grousing doesn't work yet
23:08:47 <ChongLi> ahhhh
23:08:59 <edwardk> ChongLi: as that is the feature that as i understand isn't going in this time
23:09:11 <ChongLi> well, hopefully it does go in
23:09:17 <ChongLi> because that would be really, really cool
23:09:19 <edwardk> well it is currently a ticket
23:09:23 <cbarrett> "Non-features: debugging"
23:09:26 <cbarrett> hah
23:09:37 <gabor> cbarrett: I am trying to put it on saner foundations, currently it is a maintenance grave
23:09:51 * hackagebot google-dictionary 0.1.0.2 - Simple interface to the google.com/dictionary API  http://hackage.haskell.org/package/google-dictionary-0.1.0.2 (mitchellwrosen)
23:10:50 <cbarrett> gabor: oh no :(
23:13:12 <gabor> cbarrett: the SVN HEAD has a parser updated to cabal parsec
23:15:28 <gabor> cbarrett: if you want to see some (maybe totally bogus) direction it is headed at: https://raw2.github.com/ggreif/seminar-opetope/master/opetope.html
23:16:09 <cbarrett> gabor: huh, Chrome's decided to render this as unformatted HTML.
23:16:26 <gabor> try: https://rawgithub.com/ggreif/seminar-opetope/master/opetope.html
23:16:52 <cbarrett> Thanks
23:16:57 <randomclown> how do I read a 256 bit integer encoded in a bytestring?
23:17:09 <randomclown> ByteString -> Int
23:17:14 <randomclown> Integer*
23:17:30 <johnw> you could write a Binary instance for your 256-bit Integer type
23:17:34 <manek> Is there any doc with introduction to HERMIT? on the site: http://www.ittc.ku.edu/csdlblog/?p=105 there is only a dead lin to "Introducing the HERMIT Equational Reasoning Framework" :(
23:17:41 <johnw> if it's just an Integer, there is already a Binary instance for it
23:17:55 <johnw> is it encoded in some special way?
23:18:14 <johnw> if so, you may want to extract the 8 Word8 bytes, and then assemble them yourself
23:18:29 <johnw> sorry, 32 Word8 bytes
23:18:29 <jfischoff> manek: the documentation is not that great. There are few papers that talk about the program, and there are examples in hackage package
23:18:32 <randomclown> hmm ok
23:20:09 <manek> jfischoff: If I may, I would love to ask you one question. I want to write something simmilar to ghci - an interactive haskell compiler / interpreter (it would be used as a backend for application processing images). It seems, that Hermit could be something I should be interested in - am I right?
23:20:24 * cbarrett signs off
23:20:26 <cbarrett> thanks folks
23:21:10 <manek> jfischoff: additional, could you tell what papers sohuld I look at to know more about it? :)
23:22:19 <jfischoff> HERMIT would be useful if your compiler produced GHC core. It might interesting as a general approach too.
23:22:28 <jfischoff> I can try to find the papers one sec..
23:25:53 <carter> manek: you probably only want to use hermit as a way of tyring out optimization ideas with computer assistance
23:26:00 <carter> not as part of a normal compiler
23:26:47 <ChongLi> so hermit is too powerful and thus probably too slow?
23:27:58 <carter> whats the goal?
23:28:10 <carter> hermit is a tool for using "rewrite step combnators"
23:28:13 <carter> that you can script
23:28:14 <jfischoff> manek: http://www.ittc.ku.edu/csdlblog/?author=2, http://www.ittc.ku.edu/~neil/papers_and_talks/hermit-tree-extended.pdf, http://dreixel.net/research/pdf/osie.pdf, http://www.ittc.ku.edu/csdl/fpg/software/hermit.html
23:28:22 <jfischoff> more papers at the bottom of the last link
23:28:40 <ChongLi> well, I mentioned it earlier in the context of concatMap stream fusion
23:29:03 <ChongLi> since it's apparently not possible to implement with REWRITE rules
23:29:18 <manek> jfischoff: Thank you! I will read about it :)
23:29:43 <jfischoff> I think the idea of a library having its own HERMIT script is very intriguing
23:29:45 <carter> ChongLi: theres apparently some tricky bits to the concatmap stuff
23:29:59 <carter> that still nead cleanup
23:30:20 <carter> and andrew farmer did mention doing some work to generalize / level up the rewrite ruls tooling
23:30:41 <jfischoff> for instance the finally tagless idea for Aeson might benefit from a HERMIT script to inline out the dictionaries completely
23:31:02 <jfischoff> that's my guess at least :p
23:31:50 <ChongLi> ahh, that would be cool
23:32:58 <ChongLi> jfischoff: I'm waiting to see what can be done when edwardk's succinct package comes out
23:33:11 <ChongLi> that lazy JSON indexing stuff just seems so cool
23:33:17 <carter> in 2015 right?
23:33:30 <edwardk> that reminds me i need to ship that some tim =)
23:33:31 <carter> or has there been recent progres?
23:34:42 <ChongLi> edwardk: I feel so bad! you're always nice and helpful with me and how do I repay you? reminding you of stuff like that!
23:35:14 <edwardk> carter: haven't had time to work on much of anything since early december.
23:35:22 <carter> i  can sympathize
23:35:29 <carter> i've been hosed myself
23:35:37 <carter> happy with how hopenblas is looming
23:36:03 <ChongLi> we need a cloning device!
23:36:13 <ChongLi> take over the world with an army of Haskelling clones
23:36:25 <ChongLi> an army of edwardks!
23:36:52 <carter> he had some clones for 2012- first half of 2013
23:36:56 <carter> but they all melted
23:37:04 <carter> sleep was their weakness i hear
23:37:11 <hamster007> hi guys... what is everybody using for matrix multiplication
23:37:30 <carter> hamster007: for what dimension matrices?
23:37:35 <peddie> @hackage hmatrix
23:37:35 <lambdabot> http://hackage.haskell.org/package/hmatrix
23:37:36 <hamster007> 2
23:37:38 <hamster007> and 1
23:37:42 <carter> 2 and 1 dim?
23:37:43 <carter> use linear
23:37:53 <carter> peddie: hmatrix will be outdated in a week or so :)
23:38:08 <hamster007> is linear ed kmett's thing
23:38:13 <ChongLi> yep
23:38:17 <carter> yup
23:38:20 <peddie> carter: I don't anticipate converting all my code within the next week, so . . . I'm not holding my breath :)
23:38:27 <carter> peddie: soke
23:38:34 <carter> i'll be here in march too
23:38:35 <carter> :)
23:38:37 <peddie> heh
23:38:55 <peddie> I don't have a reason yet to switch from hmatrix, especially because I'm already quite familiar with GSL
23:38:55 <hamster007> im going linear
23:39:02 <carter> hamster007: good call
23:39:08 <hamster007> is there any good examples for simple stuff somewhere
23:39:09 <carter> peddie: well, if gsl works for yo, great
23:41:35 <peddie> carter: to me, GPU codegen, for example, would be a pretty cool reason to switch :)
23:41:50 <carter> peddie: ok, that IS on the roadmpa
23:41:53 <carter> *roadmap
23:41:59 <peddie> I think I overheard that, yes
23:42:18 <carter> but may be a while out
23:42:27 * peddie shrugs
23:42:47 <carter> need to figure out an api design where theres subset of the api that is deep embedding friendly
23:43:04 <carter> while still being general purpose
23:43:07 <peddie> that's the real trick, ain't it
23:43:13 <carter> yup
23:43:18 <carter> i have most of the design figured out
23:43:21 <carter> but the devils in the details
23:43:32 <carter> peddie: im really pleased with the hopenblas layer though
23:43:37 <carter> though i've a bunch i need to do for it more
23:43:47 <peddie> cool, maybe I will get a chance to take a look one of these days
23:44:00 <peddie> my friend sent me a link to it a week or two ago
23:44:33 <peddie> got to roll; good luck
23:44:37 <carter> tahnkee
23:44:38 <carter> nejoy
23:44:54 <carter> peddie: mind you the hopenblas layer is "low leve"
23:44:58 <carter> and sitll not ready
23:45:00 <kosmikus> merijn: FYI. lhs2tex works fine with both styles of literate prorgrams, so you can use > and <
23:45:00 <carter> but yeah
23:45:02 <carter> mery evneing
23:45:19 <peddie> carter: that's what I assume when I see "BLAS" . . .
23:45:21 <kosmikus> hamster007: lhs2tex is a tool to support you if you want to write a LaTeX document and include beautified Haskell code in it
23:45:32 <kosmikus> hamster007: it is *not* a tool for fully automatic conversion of lhs to pdf
23:45:39 <carter> peddie: heres one thing i can do that hmatrix cant
23:45:48 <carter> i can do a non copying matrix slice!
23:45:59 <carter> hopenblas is just one "backend"
23:46:05 <carter> that i wan to be usable on its own
23:46:25 <carter> blas / lapack have certain needless constraints on the input / data model
23:46:35 <carter> that i wont have in my higher level stuff
23:50:14 <hamster007> hey is there a synopsis of linear
23:53:34 <hamster007> hey is edwardk in the house
23:57:40 <johnw> he was here not long ago
