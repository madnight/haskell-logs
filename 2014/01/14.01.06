00:03:15 <zRecursive> :t liftIO
00:03:16 <lambdabot> MonadIO m => IO a -> m a
00:03:47 <startling> zRecursive, the idea is that MonadIO is a class for transformer stacks that have IO at the bottom somewhere.
00:03:56 <startling> so liftIO lifts your IO thing all the way to the bottom.
00:04:02 <jfischoff> randomclown: how would you in C connect with a timeout? When you say C do you mean POSIX sockets?
00:04:18 <randomclown> you'd use select
00:04:20 <randomclown> on the fd
00:04:26 <randomclown> which lets you specify a timeout
00:04:29 <randomclown> jfischoff:
00:04:33 <startling> oh.
00:04:33 <zRecursive> startling: i am curious whether or not to change those signatures
00:05:00 <zRecursive> All are IO (...)
00:05:30 <startling> zRecursive: you'll be able to add things more easily if they're MonadIO, and IO is a MonadIO.
00:05:42 <startling> randomclown, I'm sure there's a select thing somewhere.
00:05:43 <zRecursive> i wonder if all the client codes need a big change ?
00:05:57 <startling> http://hackage.haskell.org/package/select
00:06:24 <randomclown> startling: the library needs to use that instead of threadWaitDelay
00:06:59 <startling> randomclown: ugh, what a pain.
00:07:18 <jfischoff> randomclown: I think the IO manager uses select internally. You should fork a thread where you would use select
00:07:27 <zRecursive> startling: do i have to replace "func1 ..." with "liftIO $ func1 ..." in client codes ?
00:07:42 <jfischoff> use the async package to get the result of the thread
00:07:54 <zRecursive> if using MonadIO instead of IO
00:07:58 <jfischoff> it handles exceptions for you also
00:08:10 <ChongLi> zRecursive: yes
00:08:27 <startling> zRecursive, only when you're directly calling something that's IO
00:08:33 <ChongLi> but luckily you can use "liftIO $ do .."
00:08:35 <zRecursive> ChongLi: then is annoying things
00:09:03 <ChongLi> so you can put a whole bunch of IO actions in one nested do block within a single call to liftIO
00:09:11 <randomclown> jfischoff: I'll still have to fix the internal state of the Socket object though
00:09:36 <randomclown> which is no different to just replacing the library function
00:10:46 <randomclown> yeah I'm going back to CPP, this is just pitfall after pitfall.
00:11:29 <randomclown> I'll raise an issue on the library's github page
00:11:31 <jfischoff> randomclown: what do you mean by fix the internal state of the socket?
00:12:36 <randomclown> jfischoff: http://hackage.haskell.org/package/network-2.2.1.7/docs/src/Network-Socket.html#connect
00:13:20 <zRecursive> Withing "liftIO $ do func1 ... ; fincN", how can funcX share a global value ?
00:14:09 <zRecursive> Now funcX will return MonadIO ?
00:14:15 <ChongLi> zRecursive: what do you mean by share?
00:14:47 <ChongLi> func1 .. funcN all have access to the values in the scope above the liftIO call
00:14:52 <zRecursive> ChongLi: a value from config. and cannot pass it around
00:15:39 <randomclown> hmm everything looks like it's just exported
00:15:55 <jfischoff> randomclown: Am not exactly sure what you want me to see. As far as I can tell the status is only changed if the connection is successful. Can you be more clear about the invalid state you are finding yourself in?
00:15:58 <randomclown> I'll copy and paste it and see if it'd work with hSelect replacing threadWaitDelay
00:17:25 <ChongLi> "do cfg <- ask ; baz' <- liftIO $ do { foo; baz <- bar cfg; return baz } ; qaz baz'"
00:17:32 <ChongLi> that's all perfectly fine
00:18:19 <zRecursive> can foo use cfg ?
00:18:25 <ChongLi> yes
00:19:41 <zRecursive> foo needs to call ask, right ?
00:19:47 <ChongLi> no
00:20:00 <ChongLi> cfg is available to everything after the first call to ask
00:20:18 <ChongLi> it's a free variable
00:20:26 <ChongLi> well, a bound variable at first
00:20:30 <ChongLi> and then a free variable
00:20:46 <roboguy_> @undo do cfg <- ask ; baz' <- liftIO $ do { foo; baz <- bar cfg; return baz } ; qaz baz'
00:20:47 <lambdabot> ask >>= \ cfg -> liftIO $ foo >> bar cfg >>= \ baz -> return baz >>= \ baz' -> qaz baz'
00:20:52 <ChongLi> there you go
00:20:54 <roboguy_> zRecursive: ^ it's the same as that
00:22:14 <zRecursive> but in foo, how to use cfg without passed to it as bar does ?
00:22:52 <ChongLi> ask >>= \ cfg -> liftIO $ foo cfg >> bar cfg >>= \ baz -> return baz >>= \ baz' -> qaz baz'
00:22:54 <roboguy_> zRecursive: it's bound by the lambda expression. it's just an expression in the lambda
00:22:55 <ChongLi> like that
00:23:23 <roboguy_> the thing with foo is just an expression, that is
00:24:12 <zRecursive> "liftIO $ foo cfg ..." willnot compile as the signature of foo is "foo::MonadIO (...)" ?
00:24:52 <ChongLi> zRecursive: the MonadIO constraint is not the relevant part
00:25:01 <ChongLi> if cfg :: Config
00:25:16 <ChongLi> then foo needs to be foo :: Config -> ..
00:25:33 <ChongLi> if it's foo :: MonadIO m => Config -> ...
00:25:36 <ChongLi> that doesn't matter
00:26:16 <zRecursive> i see. but foo canot be "foo :: Config -> .." now. because we cannot change its signature to add a more parameter
00:26:35 <roboguy_> zRecursive: what is foo then?
00:26:42 <roboguy_> and what do you want it to do?
00:26:52 <ChongLi> yes, foo needs to be typed to accept the arguments you want to pass to it :)
00:28:34 <zRecursive> foo is an legacy functions, i.e. foo :: Int -> ... -> IO, now i change it to "foo :: Int->...->MonadIO".  now i want make foo use a cofig value from outside foo...
00:29:24 <roboguy_> zRecursive: like ChongLi said, the MonadIO vs IO part isn't really relevant. what is the type of the config value? and how do you want to get it to foo? I don't really understand the question...
00:31:46 <roboguy_> well, I assume it's irrelevant. maybe you should put the code+the error on the paste site?
00:32:00 <zRecursive> roboguy_: i just donot want to add more parameters to foo
00:32:38 <zRecursive> and making it get the config value from outside
00:32:45 <roboguy_> zRecursive: maybe you want to have foo use the ReaderT monad transformer?
00:34:26 <zRecursive> roboguy_: Can ReaderT be in IO ?
00:34:35 <zRecursive> :hoogle ReaderT
00:34:36 <ChongLi> IO can be in ReaderT
00:34:47 <roboguy_> @unmtl ReaderT r IO a
00:34:48 <lambdabot> r -> IO a
00:34:51 <ChongLi> but you still have to change the type of foo :)
00:35:01 <roboguy_> you probably want something in the form ReaderT r IO a
00:35:05 <AVM> ReaderT r IO is an instance of MonadIO
00:36:14 <AVM> how do I ask djinn to convert something to point free style for me?
00:36:18 <zRecursive> then i just need to change "foo ... ::IO" to "foo ...::ReaderT r IO" ?
00:36:48 <ChongLi> @pl foo x y z = [z,y,x]
00:36:48 <lambdabot> foo = (flip (:) .) . flip (:) . return
00:36:57 <AVM> yes, but you have to call liftIO on all IO monadic values as well
00:37:13 <zRecursive> i feel "ReaderT r IO" will help us, thanks all!
00:37:24 <roboguy_> AVM: actually, I'm not sure djinn does that. lambdabot does though
00:37:31 <AVM> @pl f (a, b) = (b, a)
00:37:31 <lambdabot> f = uncurry (flip (,))
00:37:44 <AVM> thanks chong
00:37:46 <AVM> and robo
00:37:50 <ChongLi> :)
00:37:53 <AVM> it seems it does
00:38:31 <ChongLi> hacker news down for anyone else?
00:39:11 <AVM> Chong: http://www.downforeveryoneorjustme.com/
00:39:20 <ChongLi> AVM: that won't help
00:39:24 <ChongLi> the server itself is responding
00:39:30 <ChongLi> but giving a gateway error
00:39:58 <roboguy_> ChongLi: looks down to me
00:40:43 <helmut> Is there a simple way to load cabal built objects into ghci? No matter what I pass to -i, it completely fails to use the .hi files.
00:41:20 <AVM> @pl f s = runState s []
00:41:21 <lambdabot> f = flip runState []
00:41:56 <shachaf> Maybe -hidir or one of the many options other than -i will do what you want. I don't know.
00:42:02 <randomclown> ChongLi: down for about 12 hours now
00:42:17 <helmut> shachaf: tried that one was well without any success
00:42:29 <ChongLi> oh well, gives me a good excuse to do some work :)
00:43:05 <shachaf> Maybe one of the -package-* options like -package-conf will help you.
00:44:59 <helmut> shachaf: it cannot find the desired package (presumably because I didn't install it)
00:45:23 <shachaf> Hence passing it the package file.
00:45:30 <shachaf> That's the whole in-place registering ... deal.
00:45:30 <AVM> mtl has generally eliminated the need to use the lift function, correct?
00:45:35 <shachaf> I don't remember how it goes.
00:45:39 <helmut> ah. let me find it. thx
00:46:21 <AVM> or has it only eliminated nesting multiple lifts
00:59:57 * hackagebot egison 3.2.2 - The programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.2.2 (SatoshiEgi)
01:24:43 <donri> AVM: you still have to liftIO and lift if you use the same transformer more than once (lift up to a point in the stack where there is no more ambiguity) but other than that yes, no lifts
01:25:00 * hackagebot atom-msp430 0.5.3 - Convenience functions for using Atom with the MSP430 microcontroller family.  http://hackage.haskell.org/package/atom-msp430-0.5.3 (DanielBuckmaster)
01:26:02 <bjorkbsd> does anyone use haskell for serious scientific work in place of fortran?
01:26:13 <Tekmo> You mean for heavy duty numerical stuff?
01:26:24 <donri> @quote Jafet research
01:26:24 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
01:26:48 <bjorkbsd> yes Tekmo
01:26:54 <Tekmo> So the relevant library is `hmatrix`.  That's the Haskell bindings to LAPACK and BLAS
01:27:07 <Tekmo> There is one caveat: it's GPL licensed, but if you are doing scientific work that is probably not an issue
01:27:08 <donri> does Tekmo's work count as serious scientific? :P
01:27:19 <Tekmo> Well, it is scientific, but not heavy numerical stuff
01:27:31 <bjorkbsd> Tekmo, what do you do?
01:27:57 <Tekmo> I just graduated.  My PhD was a protein search engine for protein design
01:28:07 <Tekmo> bjorkbsd: You can read more about it here: http://www.haskellforall.com/2013/10/an-all-atom-protein-search-engine.html
01:28:07 <bjorkbsd> ah.
01:28:19 <donri> should we be calling you doctor gonzales now
01:28:22 <Tekmo> Yes :)
01:28:27 <donri> gonzalez*
01:28:39 <donri> cool
01:29:06 <Tekmo> bjorkbsd: You should also talk to carter who is working on a Haskell-based numerical library for really high-performance stuff, and it would be BSD licensed
01:29:18 <ilmig> is there anything comparable to the numpy/scipy/matplotlib ecosystem?
01:29:27 <Tekmo> ilmig: There's just hmatrix
01:29:36 <Tekmo> ilmig: That's basically the equivalent off numpy
01:29:42 <ilmig> which sounds as if it could at least partially replace numpy
01:29:43 <ilmig> yeah
01:29:50 <Tekmo> There are also several plotting libraries, too
01:29:59 <Tekmo> I forgot which one was the good one
01:30:00 <donri> lots of packages relating to linear algebra, if that's what you're after (i have no idea)
01:30:06 <Tekmo> There are like 10 and only 1 or 2 are decent
01:30:13 <donri> http://hackage.haskell.org/packages/search?terms=linear
01:30:28 <bjorkbsd> Tekmo, thanks. just skimmed your link. nice write - up.
01:30:35 <Tekmo> bjorkbsd: Thank you :)
01:31:14 <bjorkbsd> looking to not use fortran. not that there's anything wrong with it.
01:31:30 <bjorkbsd> it's for the 'because why not?' factor.
01:31:33 <Tekmo> bjorkbsd: hmatrix is a decent FORTRAN replacement
01:31:45 <ilmig> ah nice, hmatrix has also bindings to the GSL, so it does actually more than numpy (i.e. could also be a replacement for parts of scipy)
01:32:58 <bjorkbsd> Tekmo, "Haskell's foreign-function interface (FFI) is nice, but not having to use it at all is even nicer."
01:33:03 <bjorkbsd> why's that?
01:33:25 <startling> using C-compatible types is sometimes a pain, as is doing everything in IO
01:33:40 <Tekmo> bjorkbsd: Let me link you to the relevant code I had to write to patch over `hmatrix`
01:33:42 <shachaf> The type of lists (finite sequences) of As is the free monoid on A. What about colists (finite or infinite sequences)?
01:33:42 <ChongLi> and you lose type safety
01:33:46 <startling> but yeah, the FFI is really good.
01:33:51 <Tekmo> bjorkbsd: I mean, to replace the relevant `hmatrix` bits
01:33:59 <ChongLi> C code can do all sorts of unsafe things that Haskell can't detect
01:34:13 <shachaf> That makes a proper monoid (right?). Is it "free"/"cofree"/anything fundamentally related to monoids like that?
01:34:25 <Tekmo> bjorkbsd: In the end it turned out to not be a problem and now the code base goes back to using `hmatrix` again.  I got a personal confirmation from Richard Stallman that I could license my code under GPLv2, which was good enough for my university
01:34:29 <shachaf> (I mean, it's not either of those, but is it anything?)
01:34:46 <bjorkbsd> hah.
01:35:17 <Tekmo> bjorkbsd: Here's what the C bindings to LAPACK look like: https://github.com/Gabriel439/suns-search/blob/4e8393847d9c0ead740b59828620140a5b8dd73c/src/Matrix.hsc
01:35:32 <donri> colist, is that Dual [a]? :P
01:35:47 <Tekmo> bjorkbsd: *Haskell bindings to LAPACK
01:36:02 <shachaf> In Haskell [a] is more like a colist than a list (though it's not quite either, due to _|_ and all that).
01:36:14 <donri> wouldn't the dual of any monoid be that same monoid
01:36:52 <donri> i mean reversing the arrows in an endomorphism is noop isn't it?
01:36:59 <shachaf> No, it'd be the opposite monoid. But that's not the sort of dual I'm talking about.
01:37:02 <Tekmo> Wouldn't it also reverse composition?
01:37:04 <shachaf> No.
01:37:16 <bjorkbsd> thanks.
01:37:18 <shachaf> No to noop. Yes to reversing composition.
01:37:25 <bjorkbsd> did you enjoy working with haskell, Tekmo?
01:37:34 <Tekmo> bjorkbsd: Yes.  Very much
01:37:35 <shachaf> Data.Monoid even defines a type, Dual, for this.
01:37:56 <shachaf> Anyway, you can ignore the names "list" and "colist" if you don't like them.
01:37:57 <donri> i know but why? a -> a -> a flip arrows a <- a <- a same thing :P
01:38:17 <shachaf> It's enough to accept that I'm talking about finite sequences and finite-or-infinite sequences.
01:38:25 <Tekmo> bjorkbsd: Haskell has a smaller ecosystem than Python for scientific programming, but the code is much more maintainable and easy to update
01:38:36 <donri> is the reversal of composition mandated by theory or merely a human interpretation, so to speak? :P
01:38:48 <mirpa> donri: there is something like a <- a <- a?
01:38:59 <shachaf> Well. You have to figure out what question you're asking, first.
01:39:01 <donri> mirpa: yeah, it's spelled a -> a -> a
01:39:35 <shachaf> I interpreted the question as "viewing a monoid as a category, its opposite category is also a monoid viewed as a category. how does composition in these monoids relate?"
01:40:02 <donri> the dual of the free category would mandate a reversal of composition, but i don't see how the free monoid dictates anything of the sort
01:40:07 <shachaf> And since the ideas of "viewing a monoid as a category" and "opposite category" are standard and well-defined, the whole thing is pretty standard and well-defined.
01:40:20 <donri> i suppose (:
01:40:24 <bjorkbsd> Tekmo, and performance? what did you think?
01:40:41 <shachaf> I'm not sure what your question has to do with free monoids...
01:41:06 <Tekmo> bjorkbsd: Performance is excellent.  Better than Python
01:41:12 <bjorkbsd> Hmm.
01:41:16 <donri> well any monoid. free objects make these things obvious though
01:41:43 <Tekmo> bjorkbsd: The key libraries you need to familiarize yourself with are `containers`, `unordered-containers`, and `vector`
01:41:50 <Tekmo> bjorkbsd: That's how you write performant code in Haskell
01:42:17 <Tekmo> bjorkbsd: Also, use `bytestring` and `text` and `attoparsec`
01:42:21 <hamid> Tekmo, the pipe library is pretty cool though
01:42:25 <Tekmo> ... and of course, `hmatrix`
01:42:27 <Tekmo> hamid: Thank you!
01:42:33 <donri> yeah have you heard about pipes Tekmo
01:42:35 <Tekmo> I have something really cool in the works
01:42:39 <Tekmo> :)
01:43:19 <bjorkbsd> neat. thanks.
01:43:33 <Tekmo> I'm building something on top of `pipes-concurrency` that will simplify concurrent applications
01:43:48 <Kaidelong> I think my "xml library" is going to be  "< " ++ tagName ++ " " ++ getAttrs attrs ++ ">" ++ xs ++ "</" ++ tagName ++ ">"
01:44:06 <Tekmo> It's a neat system for removing concurrent logic from your applicatoin so that you have a pure core
01:44:15 <Kaidelong> I can learn HXT later but it seems like such huge overkill for doing what I want to do
01:44:15 <Tekmo> bjorkbsd: You're welcome
01:44:32 <Tekmo> Kaidelong: I recommend `Parsec`/`attoparsec` for this purpose
01:44:34 <donri> Kaidelong: hxt might be overkill but (++) is surely underkill :P
01:44:48 <Kaidelong> Tekmo: aren't those parser libraries?
01:44:55 <Tekmo> Kaidelong: Oops, misread your comment
01:45:33 <donri> hexpat and xml-{types,picklers,conduit} are good options (and pipes-xml in the future)
01:45:48 <Fylwind> ++ has quadratic behavior though
01:45:58 <Tekmo> It's only quadratic if you left-associate them
01:45:59 <merijn> Fylwind: Does not
01:46:06 <merijn> Fylwind: At least not usually
01:46:06 <Tekmo> They right-associate by default
01:46:23 <Kaidelong> I'm only going to be generating like 2000-4000 lines of XML
01:46:28 <bjorkbsd> oh right. you wrote the equational reasoning piece. i'll have to read it again.
01:46:29 <Fylwind> Tekmo: oh I see, never noticed that sorry
01:46:30 <donri> well you should be using text or bytestring Builder to render XML
01:46:35 <Kaidelong> maybe strings are too slow for that
01:46:43 <Tekmo> Fylwind: No apology necessary :)
01:46:55 <Tekmo> Builder is the best type for rendering large amounts of `text`
01:47:06 <Tekmo> Well, I should say "medium" amounts
01:47:10 <merijn> Fylwind: laziness can actually make (++) O(1) if you associate them so they can fuse
01:47:14 <Tekmo> Anything that fits in memory
01:47:40 <Fylwind> yea Builder is pretty nice; only downside is that I have to convert literals every time
01:47:48 <donri> Tekmo: isn't it still the best option for rendering the chunks of something larger than memory too, though?
01:47:59 <donri> Fylwind: overloaded strings?
01:48:04 <Tekmo> donri: Oh yeah, it works for lazy text, too
01:48:07 <Tekmo> I forgot about that
01:48:14 <Fylwind> Overloaded works for Builder too?
01:48:19 <Tekmo> Yes
01:48:22 <Fylwind> oh nice
01:48:32 <Fylwind> good to know
01:50:01 <donri> (but note that the bytestring Builder's IsString instance has the same caveats as bytestring's, and also it's not in the version that ships with current GHC IIRC)
01:50:03 * hackagebot stringprep 1.0.0 - Implements the "StringPrep" algorithm  http://hackage.haskell.org/package/stringprep-1.0.0 (GeorgePollard)
01:50:30 <Fylwind> caveat?
01:50:55 <Tekmo> It will case every character to a `Word8`
01:51:04 <Tekmo> So nothing above 256 will be converted correctly
01:51:19 <Tekmo> To fix this, you use `Text`, which also has a `Builder` that works with `OverloadedStrings`
01:51:27 <donri> the caveat is that they're only for the latin1 encoding, with neither compile-time nor even runtime errors for characters outside that range
01:51:53 <Fylwind> oh I guess a warning would've been nice to have
01:52:08 <Tekmo> There is a warning in the documentation, I think
01:52:46 <shachaf> What do you call an element x of a monoid such that xy = x for all y?
01:53:22 <Tekmo> Sounds like the zero of a semiring, but that doesn't answer your question
01:54:03 <Kaidelong> zero?
01:54:11 <shachaf> It's true of any infinite [co]list, and it actually seems like a pretty odd property.
01:54:30 <Kaidelong> oh I misread
01:54:33 <Tekmo> So a semiring is basically defined by: 0, 1, (+), and (*)
01:54:51 <shachaf> Perhaps I'll get clues by reading about it.
01:54:58 <Kaidelong> Tekmo: problem here is that the multiplication he is talking about is not commutative
01:54:59 <Tekmo> If the monoid in question is the semiring multiplication, then `x` would be the `0`
01:55:03 <Kaidelong> because he is appending two lists
01:55:16 <Tekmo> Kaidelong: Is semiring multiplication supposed to commute?
01:55:24 <Kaidelong> I think the zero is
01:55:30 <Tekmo> Oh yeah
01:55:31 <Kaidelong> even if the operation itself doesn't
01:55:35 <Kaidelong> and that zero doesn't commute
01:55:42 <Tekmo> Yeah, you're right
01:56:23 <shachaf> Aha, it does have a name, though.
01:56:30 <jfischoff> shachaf: http://en.wikipedia.org/wiki/Absorbing_element
01:56:46 <Tekmo> I feel like everything has a name in mathematics
01:57:17 <Fylwind> what do you call the property that "everything in mathematics has a name"? ^_^
01:57:23 <Kaidelong> non-commuting absorbing element?
01:57:27 <shachaf> jfischoff: Ah, thanks, that's even better than what I found ("annihilator", which is defined on a ring and a module and so is actually kind of far from what I wanted).
01:57:30 <Tekmo> Fylwind: Ha!
01:57:56 <Kaidelong> shachaf: the definition given by wikipedia still doesn't exactly match the example of infinite lists
01:58:02 <jfischoff> true
01:58:03 <Tekmo> Fylwind: I call it "taxonomy"
01:58:10 <jfischoff> it only works on the left
01:58:13 <bjorkbsd> Tekmo, what's your work environment like, if you don't mind me asking? emacs/vi/other?
01:58:18 <Tekmo> bjorkbsd: vi
01:58:29 <jfischoff> left absorbing element :p
01:58:30 <bjorkbsd> cool.
01:58:38 <shachaf> Well, jfischoff's page calls it a "left zero".
01:58:44 <Tekmo> bjorkbsd: Mainly I have a web browser open that I use to google "hackage <function/package>" and then a couple of terminal windows open with `vi`
01:58:47 <jfischoff> ah
01:59:09 <Kaidelong> left zero works
01:59:33 <bjorkbsd> i think i'll borrow that technique.
01:59:35 <Tekmo> jfischoff: I finally finished the answer to your question about a pure core for concurrent programs
01:59:45 <jfischoff> no way
01:59:48 <Tekmo> jfischoff: https://github.com/Gabriel439/Haskell-MVC-Library
01:59:55 <Tekmo> And I have a sample library that uses it, too
02:00:03 <Tekmo> https://github.com/Gabriel439/Haskell-RCPL-Library
02:00:19 <Tekmo> I even QuickChecked the core logic, just like you requested
02:00:29 <jfischoff> very cool
02:00:30 <Fylwind> Tekmo: out of curiosity, what kind area of programming do you do that needs LAPACK?
02:00:57 <Tekmo> Fylwind: In that case I was just implementing the Kabsch algorithm, which required an SVD and some other matrix operations
02:01:11 <Tekmo> Fylwind: I've also done some other geometry libraries for protein manipulations
02:01:14 <bjorkbsd> scientific, Fylwind
02:01:19 <Fylwind> ah I see
02:01:21 <bjorkbsd> LAPACK is a decent standard.
02:01:29 <bjorkbsd> or, should i say, defacto.
02:01:31 <Tekmo> LAPACK is fantastic
02:01:42 <Fylwind> I've been wondering myself if it's a good idea to continue down the Haskell path or go back to C++ for my research
02:02:01 <Tekmo> Fylwind: It depends a lot on your work environment
02:02:02 <Fylwind> main worry is that there aren't a lot of footprints here
02:02:09 <bjorkbsd> which area, Fylwind?
02:02:09 <Tekmo> Fylwind: i.e. how much development time you have and how long-lived programs are
02:02:37 <Fylwind> calculations in many-body theory
02:02:47 <Tekmo> I'd recommend C++ for that
02:03:00 <bjorkbsd> Fylwind, and there was nothing already in fortran?
02:03:07 <Tekmo> However, I'd recommend you follow Rust and try that out when it matures
02:03:07 <shachaf> jfischoff: Here we have the property that for any left zero z and element y, yz is a left zero (but usually a different one).
02:03:16 <Tekmo> It sounds like the functional successor to C++
02:03:41 <Fylwind> bjorkbsd: there's some ... but I'm not familiar enough with Fortran
02:04:06 <bjorkbsd> it is mostly procedural, with annoying formatting.
02:04:09 <jfischoff> shachaf: ha! colist /= list
02:04:22 <shachaf> ?
02:04:29 <flebron> What's a colist?
02:04:51 <jfischoff> I mean infinite list
02:04:54 <merijn> flebron: A (potentially) infinite list
02:04:58 <jfischoff> yeah
02:04:58 * flebron wonders if people define co(-algebraic types) by inverting the product and coproduct.
02:05:01 <merijn> flebron: As opposed to a finite list
02:05:07 <flebron> How is it co-?
02:05:20 <jfischoff> shachaf: that's just odd
02:05:24 <merijn> I dunno, I'm not a category theorist >.>
02:05:45 <merijn> flebron: I just know that in total languages "data" == finite, "codata" == potentially infinite
02:06:00 <jfischoff> I would have never thought of lazy lists as having such odd algebraic structure
02:06:45 <shachaf> Lists are an initial fixed point (and initial algebra), colists are a terminal fixed point (and terminal co-algebra).
02:06:57 <Kaidelong> Tekmo: doesn't OCaml do pretty well in those specific applications? Especially when used with FORTRAN
02:06:58 <shachaf> I'd guess that's where the co- comes from.
02:07:07 <Kaidelong> that might be an option too
02:07:21 <bjorkbsd> Kaidelong, ocaml lacks purity.
02:07:22 <shachaf> Of course in Haskell initial and terminal fixed points are the same.
02:07:31 <Kaidelong> bjorkbsd: but so does C++
02:07:43 <bjorkbsd> indeed.
02:07:51 <Tekmo> Kaidelong: I have no idea
02:07:51 <shachaf> But we can pretend.
02:08:15 <bjorkbsd> perhaps, he's more familiar with c++ than with ocaml. path of least resistance, and whatnot.
02:08:24 <merijn> I really need to tell people to fix their SAC website and buildsystem so I can do their PR in these discussions :p
02:08:49 <bjorkbsd> SAC?
02:09:48 <merijn> bjorkbsd: Single Assignment C, purely functional array language. They like to sell themselves as great for numeric stuff like n-body simulation
02:10:14 <bjorkbsd> i see.
02:10:40 <shachaf> Hey, http://maciejcs.wordpress.com/2012/04/17/free-monads-and-their-algebras/
02:10:45 <jfischoff> goodnight guys, hope to see you tuesday!
02:10:49 <shachaf> monads are just free monad monad monad algebras!
02:11:40 <Hafydd> Well, why didn't you say so?!
02:11:40 <Kaidelong> at my old university the computational science crowd actually used python of all things
02:12:06 <bjorkbsd> Kaidelong, python is quite well respected because of numpy and scipy.
02:12:38 <eazar001> computational crowd is still heavy on python i believe
02:13:08 <Kaidelong> yes, I got that impression, also they were mostly using things like CUDA rather than specialized supercomputer hardware
02:13:30 <eazar001> heh ... that and boinc
02:13:55 <eazar001> boinc is the new supercomputer
02:13:59 <Kaidelong> I actually worked with that crowd for a bit, it's how I learned to work with MPI in C
02:14:00 <merijn> Kaidelong: Python has SciPy which mostly has hand optimised C/Fortran libraries for things
02:14:00 <merijn> Kaidelong: So the python is just glue code
02:14:26 <merijn> Kaidelong: I'm sorry :(
02:16:51 <helmut> what are typical causes for "cabal build" producing a semantically different program from "cabal clean && cabal build"? (only added "trace" calls)
02:17:24 <Tekmo> helmut: Maybe if you change the configuration
02:17:32 <helmut> Tekmo: no, I didn't
02:17:33 <merijn> helmut: Code didn't change but your ghc flags did?\
02:18:13 <helmut> what kind of changes should watch out for?
02:18:13 <cool_dudette> Hi guys. Sorry if this is a stupid question: I've written a function that turns a hexadecimal character into an Integer. I want to overload the function to deal with Strings. Can I do ad hoc polymorphism without having to introduce a typeclass?
02:18:19 <tdammers> I get the impression that doing number crunching in python is a bit like building web applications with PHP that aren't dog slow
02:18:38 <tdammers> i.e., offload as much as possible to existing APIs
02:18:41 <merijn> cool_dudette: Overload it in what way?
02:18:53 <helmut> I  configured half an hour earlier and didn't upgrade ghc nor install any cabal packages in between
02:18:59 <merijn> cool_dudette: Oh, you want it to work on both Char and [Char]?
02:19:08 <cool_dudette> yeah, exactly
02:19:09 <merijn> cool_dudette: Why not only work on [Char]?
02:19:22 <Tekmo> cool_dudette: The non-type-class way to do this is to pass an additional argument containing the decoding method (but that puts you back where you started)
02:19:34 <merijn> cool_dudette: All you'd need to do is replace the type of quotes around the arguments
02:19:35 <shachaf> cool_dudette: No, not really. My recommendation is not to introduce a type class for it, either.
02:19:38 <helmut> anyway. I'll have to always run cabal clean now. :-(
02:19:55 <Kaidelong> cool_dudette: why not just use fmap yourFunction?
02:20:07 <merijn> i.e. 'foo "A"' instead of "foo 'A'"
02:20:11 * hackagebot parsec3 1.0.0.6 - Monadic parser combinators  http://hackage.haskell.org/package/parsec3-1.0.0.6 (ChristianMaeder)
02:20:16 <merijn> Kaidelong: Because that's something wildly different?
02:20:36 <merijn> Kaidelong: That would get him "[Int]" as result, not Int
02:20:44 <Kaidelong> oh right
02:20:48 <Kaidelong> he'd have to fold the integers
02:20:51 <Tekmo> If I were you, I would just define two separate functions
02:21:05 <merijn> Tekmo: Or really just one and treat Char as a singleton list
02:21:13 <Tekmo> Yeah, or that
02:21:30 <Tekmo> It's much more lightweight to follow merijn's suggestion and only define a function of Strings
02:21:39 <Kaidelong> @ty (:[])
02:21:40 <lambdabot> a -> [a]
02:21:51 <Kaidelong> @ty (. (:[]))
02:21:52 <lambdabot> ([a] -> c) -> a -> c
02:22:04 <cool_dudette> Okay
02:22:25 <Kaidelong> so if your function is String -> Int then (.(:[])) gives you Char -> Int and that can be the plan
02:22:31 <cool_dudette> I guess I'll go with that. I was assuming I needed an auxiliary function to deal with characters, but I guess that's not really necessary.
02:22:35 <shachaf> Kaidelong: That combination of characters is probably not something you should be typing into your program, let alone giving as advice to others. :-(
02:22:39 <Hafydd> (:[]) is more nicely written as pure.
02:22:43 <Tekmo> I prefer `return` to the robot monkey
02:23:08 <cool_dudette> Thanks all for the help!
02:23:08 <Tekmo> I wish Data.List had `singleton`
02:23:13 <Kaidelong> pure looks nicer but for the purposes of lambdabot it's more generic and more confusing
02:23:22 <Kaidelong> . return works
02:23:39 <shachaf> "foo [x]" also works.
02:27:09 <shachaf> C++-style ad-hoc overloading interacts badly with type inference and also with various other things that don't exist in C++, such as type classes and good taste.
02:30:08 <theorbtwo> shachaf++ # other things that don't exist in C++, such as ... good taste
02:33:16 <merijn> shachaf: Good taste exists in C++, they just use cotaste :)
02:34:53 <shachaf> Hmm, I wonder whether Free f () relates to Froo f () in some special way.
02:35:37 <shachaf> I guess not really?
02:35:54 <shachaf> Maybe I meant Cofree and Cofroo (i.e. Jet).
02:36:22 <shachaf> Or Free f Void and Froo f Void
02:36:44 <shachaf> By Froo I mean data Froo f a = L a | B (Froo f (f a))
02:37:05 <shachaf> OK, I guess those are both pretty boring.
02:39:10 <shachaf> I guess Free f Void is the (least?) fixed point of f.
02:41:59 <shachaf> Well, I'll think about the strange type later.
02:42:34 <merijn> Dr. Strange Type: Or, How I Learned to Stop Worrying and Love Category Theory
02:43:42 <companion_cube> :)
02:44:05 <bjorkbsd> is category theory absolutely necessary?
02:44:13 <merijn> bjorkbsd: Hell no
02:44:15 <shachaf> No.
02:44:20 <shachaf> It isn't even relatively necessary.
02:44:29 <bjorkbsd> good.
02:44:41 <bjorkbsd> 'cause i don't know the first thing about it.
02:44:42 <merijn> bjorkbsd: I can summarise my knowledge of category theory as follows: "huh?"
02:44:48 <bjorkbsd> hahah
02:45:48 <arnsholt> Also, co- all the things!
02:46:04 <merijn> bjorkbsd: In general #haskell encourages learning, so once you reach advanced haskell people start to branch out and investigate type theory, category theory, dependently typed languages and all sorts of cool advanced stuff (hence you'll frequently see them mentioned here)
02:46:42 <merijn> bjorkbsd: They're absolutely irrelevant for getting to intermediate-advanced haskell and writing real world code, though
02:46:55 <bjorkbsd> excellent.
02:47:12 <bjorkbsd> i was afraid it was a language strictly for nerds.
02:47:17 <merijn> bjorkbsd: Some libraries have design inspired by category theory (i.e. pipes), but knowing the theory isn't needed to understand the libraries. You'll just casually pick up some terms along the way
02:47:18 <bjorkbsd> err. uber nerds. sorry.
02:48:06 <shachaf> Maybe I should figure out conaturals before worrying about colists.
02:50:14 <shachaf> {0,1,...,∞} with addition is surely a common monoid to talk about.
02:51:00 <shachaf> It has an identity element (0) and a zero (∞).
02:51:19 <shachaf> Where can I read about it? Does it have a name?
02:52:29 <FliPPeh> I know Data.Monoid knows it as Sum
02:52:52 <Saizan> shachaf: the tropical semiring is close
02:53:08 <shachaf> instance Monoid m => Monoid (Maybe m) where mempty = Just mempty; mappend Nothing x = x; mappend x Nothing = x; mappend (Just x) (Just y) = Just (mappend x y) -- this is valid, right?
02:53:45 <shachaf> That one actually uses the underlying monoid structure so maybe it wouldn't make edwardk so sad. Or maybe it would make him sadder, hard to say. Is there a newtype for it?
02:53:58 <eazar001> lol
02:54:20 <shachaf> Saizan: Hmm.
02:55:22 <shachaf> I was looking at this as a special case of colists, where I don't think that would be so relevant.
02:56:32 <shachaf> Hmm, http://ncatlab.org/nlab/show/extended+natural+number
03:00:52 <helmut> what causes should I look at when an error passes catchError? (in http://paste.debian.ne/74509)
03:01:06 <shachaf> OK, I'm going to sleep.
03:03:38 * flebron has literally never learned a single thing from ncatlab.
03:04:09 <bjorkbsd> but you have, figuratively. right flebron?
03:04:11 <flebron> Every time I end up more or equally as confused/ignorant as when I issued the GET request.
03:06:44 <vektor> has haskell ever segfaulted upon any of you?
03:07:42 <flebron> Sure. Via GMP.
03:07:44 <helmut> oh, just pass it a broken system library and it instantly segfaults. ;-)
03:07:53 <vektor> O.o
03:08:02 <vektor> well, it was only NCurses. So yeah
03:08:06 <donri> all the time. usually because unsafe{Coerce,PerformIO} :P
03:08:22 <donri> duno if those are "haskell"
03:08:42 <vektor> running the NCurses library's hello world sample's main from GHCI crashes the whole thing
03:08:51 <vektor> http://hackage.haskell.org/package/ncurses-0.2.7
03:10:42 <vektor> i.e. "ghci ; :l Sample.hs ; main" crashes ghci.
03:12:07 <Twisol> vektor: What if you run it using `runhaskell Sample.hs` ?
03:14:02 <vektor> not too much better. Only difference is I don't get a error message from the crash
03:14:14 <vektor> i.e. the terminal gets wiped
03:14:29 <vektor> and I end up with a terminal that looks rather fresh. Not even an error.
03:15:05 <Twisol> that's lovely
03:15:09 <vektor> now, that's kinda odd... I can't type stuff in that terminal
03:15:11 <helmut> has "error" been an alias of "fail" in (possibly long) former times?
03:15:47 <vektor> helmut: huh?
03:16:28 <helmut> vektor: I am trying to ressurect code that tries to catchError an error, but it propagates
03:17:13 <Twisol> vektor: try a shell redirect on the error stream to capture any errors into a file
03:17:42 <Twisol> what platform are you on? what shell program?
03:18:36 <vektor> wait, the terminal seems to still operational. It's just that my input doesn't show up.
03:18:39 <merijn> vektor: I would use vty-ui instead of ncruses
03:18:47 <vektor> i.e. what I type ends up in a buffer, but not on the screen
03:18:53 <merijn> vektor: Depending on what kind of terminal UI you want
03:19:35 <Twisol> Sounds like the output state got a little messed up.
03:19:54 <vektor> that's all kinds of messed up.
03:20:05 <Twisol> can't imagine the hidden flag would be active, because it's not like that's very common, but it would explain it
03:20:07 <vektor> merijn: what does it do?
03:20:11 <merijn> vektor: vty-ui is a library that supports all sorts of widgets for terminal UIs and doesn't rely on the C ncurses library
03:20:37 <vektor> much more complex than ncurses? because I kinda liked the simplicity of the ncurses api
03:20:43 <merijn> vektor: It has support for things like text fields, button
03:20:51 <merijn> vektor: It's much higher level than ncurses
03:21:12 <Twisol> vektor: well, if ncurses left the shell's output brush in an unfortunate state, then it would just be a matter of sending a \e[0m, one would hope. But I don't know how to do that off the top of my head.
03:21:55 <vektor> @hackage vty-ui
03:21:55 <lambdabot> http://hackage.haskell.org/package/vty-ui
03:22:02 <vektor> thanks, lambdabot
03:23:52 <ion> thambdabot
03:25:55 <vektor> merijn: so is that only for terminal usage?
03:26:58 <merijn> vektor: Yeah, it's basically an ncurses replacement, so yeah it's only for terminal use
03:28:03 <vektor> I guess there's no way to implement pixel-based rendering on a terminal?
03:29:00 <merijn> vektor: Nope, there's no notion of pixels in a terminal
03:29:20 <randomclown> merijn: pretend the characters are pixels
03:29:23 <merijn> vektor: Or rather, pseudo terminals like this work on characters
03:29:43 <merijn> randomclown: Sure, but thats a rather unportable way to use your terminal
03:29:47 <vektor> (I'll have to represent lots of data, and having pixel based rendering would make that much easier. THen again, I'd like to have it work over a terminal, so I can use a ssh connection to tap in, etc)
03:29:54 <randomclown> the most fun way
03:30:12 <vektor> guess i'll have to implement two kinds of rendering then. One fancy graphical UI and a console one.
03:30:37 <randomclown> vektor: look for inspiration from DOS programs
03:31:50 <Twisol> vektor: Check out the Text Mode Demo Compo for some excellent insporation
03:33:58 <vektor> I'd like to have it look kinda like this: www.youtube.com/watch?v=uCYUCqrEZqA
03:34:46 <vektor> (also, that youtube account name :D )
03:35:22 <Twisol> there's a pretty tough resolution limit when it comes to the terminal
03:35:28 <vektor> yeah
03:35:43 <vektor> well, I guess I can only get soandso far using only terminals.
03:35:45 <Twisol> what kind of thing are you trying to do?
03:35:59 <vektor> pretty damn close to what that vid does.
03:36:07 <vektor> Representing data from an AI simulation
03:36:07 <tdammers> some terminals support framebuffer-style graphics IIRC... never used it though
03:36:31 <Twisol> What if you used a <canvas> element in a browser? You could do that pretty easily just by drawing text and rectangles.
03:36:55 <Twisol> would give you an excuse to try Fay or Elm ;)
03:37:14 <vektor> wat?
03:37:48 <Twisol> @hackage fay
03:37:49 <lambdabot> http://hackage.haskell.org/package/fay
03:37:52 <Twisol> @hackage elm
03:37:52 <lambdabot> http://hackage.haskell.org/package/elm
03:38:12 <merijn> tdammers: Some *consoles* support framebuffer graphics
03:38:14 <vektor> check the second link
03:38:15 <Twisol> err, capital E on the Elm
03:38:18 <merijn> tdammers: Terminals do not
03:38:18 <Twisol> !hackage Elm
03:38:44 <Twisol> merijn: What's the difference between the two?
03:38:48 <Twisol> @hackage Elm
03:38:49 <lambdabot> http://hackage.haskell.org/package/Elm
03:38:49 <Twisol> dangit.
03:39:14 <vektor> console is the application that shows what the terminal is doing, kinda, huh?
03:39:23 <tdammers> merijn: s/terminals/terminal emulators/
03:39:39 <merijn> Twisol: Terminals were physical terminals with a keyboard and the interface evolved to interact with those. All the interfaces are concerned with handling characters
03:39:55 <merijn> Twisol: Retrofitting those interface to handle something other than is really cumbersome
03:40:31 <merijn> Twisol: You could implement a terminal emulator that displays graphics, but the driver interface still doesn't let you send graphics to them
03:40:42 <Twisol> Ahh, I see.
03:40:46 <vektor> regarding fay and elm: I'm not the web dev kinda guy.
03:40:56 <merijn> Twisol: You'd need some hack like custom escape codes and sending the graphics as characters to said terminal emulator
03:41:33 <merijn> Twisol: Which means you'd have to provide your terminal is now incompatible with all the common terminals supported by many programs
03:41:39 <Twisol> vektor: TBH, you could just make a canvas as large as you want, then forget about all of the rest of the document and just draw to the canvas.
03:41:59 <Twisol> vektor: Fay's FFI is really easy to use, so you can wrap whatever drawing methods you need rather trivially.
03:42:54 <Twisol> merijn: well, it wouldn't be hard to appropriate a private-use ANSI code for your application. Applications certainly couldn't rely on it existing anywhere but your emulator of course.
03:43:03 <vektor> gonna stick with console gfx for the time being
03:43:10 <Twisol> vektor: cool, sounds good. :)
03:44:21 <vektor> the pixel based rendering is not gonna be remote by any means, so I can just patch stuff together locally.
03:45:14 <vektor> vty-ui's got a 70 page manual. duh
03:45:35 <merijn> vektor: tbh, I read maybe 5 pages before I got started
03:46:04 <merijn> Twisol: Sure, but if your goal is portability, you might want to take that into account :)
03:46:40 <Twisol> merijn: hah, yes indeed.
03:46:58 <vektor> I assume terminal-graphics buttons won't quite work over ssh? will that work at all over a ssh remote access?
03:48:24 <merijn> vektor: If you want something that works over SSH, stuff like vty-ui is the best I'm aware of being possible
03:48:37 <Twisol> the spirit of terminal stuff is to work over any link
03:48:38 <merijn> Unless you want to just tunnel X11 over SSH and use a GUI
03:53:48 <Walther> Hmmm. System.Random "can no longer be used together with base as of GHC7.2.1" - what are the implications?
03:54:03 <Walther> I seem to be able to cabal install random, but would this break other stuff badly?
03:55:55 <merijn> Walther: eh, where does it say that?
03:56:10 <Walther> Namely; what is the up-to-date "correct" way to import/use random?
03:56:37 <Walther> http://stackoverflow.com/questions/7265550/haskell-could-not-find-module-system
03:57:02 <Walther> the comment in the answer
03:57:05 <merijn> Walther: You are misreading that question and answer
03:57:15 <Walther> wholly possible. explain
03:57:33 <merijn> Walther: All it is saying is that "base" (i.e. the libraries shipping with GHC) *used* to include System.Random, but don't any longer
03:57:36 <Cale> Walther: Do you have the cabal executable?
03:57:44 <Cale> Walther: Try  cabal install random
03:57:49 <merijn> Walther: System.Random was split off into a separate package (i.e. random)
03:57:59 <Walther> Cale: yes, and I did run "cabal install random". I'm merely conserned of the implications stated at the comment of the answer
03:58:02 <merijn> Walther: So the correct way is "install the random package, import System.Random"
03:58:34 <merijn> Walther: The comment is just saying there was a reorganisation that moved which package the System.Random module is in
03:58:44 <Walther> and is that the haskell98 version?
03:59:31 <Cale> Walther: haskell98 isn't the package you likely want to use, unless you're very concerned about being backward compatible and don't really need a lot of modern library support.
03:59:34 <merijn> Walther: System.Random is still included in haskell98, because the standard still says it's part of that
03:59:48 <Cale> "Random" rather
03:59:52 <merijn> Walther: GHC defaults to Haskell2010 which isn't compatible with the haskell98 package
03:59:57 <Cale> (It's just "Random" in haskell98)
04:00:16 <Cale> Well, more to the point, it defaults to using "base"
04:00:25 <Cale> There's no haskell2010 package
04:00:39 <merijn> Cale: Eh
04:00:40 <merijn> Cale: http://hackage.haskell.org/package/haskell2010
04:00:45 <Twisol> so `base` is to Haskell 2010 as `haskell98` is to Haskell 98?
04:00:57 <Cale> oh, in that case, there is, but it doesn't default to that either :)
04:01:02 <merijn> Cale: :p
04:01:04 <Walther> Does `cabal install random`; `import random`; result in me a) "forcing" the use of the haskell98 random that is not compatible with `base` or b) use some newer version
04:01:13 <Walther> i guess that is what it boils down to
04:01:25 <Walther> i.e. will using System.Random cause any weird compatibility issues
04:01:26 <Cale> Walther: You want to import System.Random
04:01:29 <Cale> no
04:01:36 <merijn> Walther: "cabal install random" and "import System.Random" will result in 1) installing the random package and 2) import that for use
04:01:45 <Cale> To be compatible with modern stuff, cabal install random, and import System.Random
04:01:45 <Walther> erm, yeah, import System.Random of course
04:01:51 <Twisol> the `random` package exports the `System.Random` module.
04:01:59 <Walther> Thanks.
04:02:35 <merijn> Walther: The code of that package (or parts of it) used to be shipped with old GHC (so you didn't have to explicitly install it)
04:02:49 <merijn> Walther: That's all that changed
04:03:09 <Walther> merijn: nod, I was just worried about the incompatibility part; what am I breaking/missing etc
04:03:52 <merijn> Walther: Well, you'll be incompatible with really old GHC's, but you shouldn't care too much about that :p
04:05:22 <Walther> merijn: ok. The wording in the comment made it seem like using System.Random would be *using* some old package and break compatibility with *newer* systems, hence asking here :p
04:05:43 <Walther> (i had the thought that just has to be wrong)
04:11:29 <helmut> Where can I read about the difference between "fail" and "throwError"?
04:12:04 <mm_freak> helmut: their type signatures
04:12:10 <helmut> It appears that in former times you could "catchError" could catch a "fail
04:12:23 <helmut> mm_freak: but semantically they do the same thing?
04:12:36 <mm_freak> helmut: not quite
04:12:46 <Walther> ...i'm clearly thinking something wrong here: randomlist n = take n . (['A'..'Z'] !! random)
04:13:20 <tdammers> :t (!!)
04:13:21 <lambdabot> [a] -> Int -> a
04:13:23 <merijn> :t random
04:13:24 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
04:13:30 <helmut> mm_freak: I am working on code that used to work, now it fails and replacing "fail ..." with "throwError undefined" appears to make it work again.
04:13:52 <helmut> mm_freak: can you give me a clue for why?
04:14:03 <merijn> Walther: Your use of random there makes no sense?
04:14:14 <mm_freak> helmut: don't bruteforce-fix…  i'm assuming that you're getting a type error
04:14:26 <helmut> mm_freak: no, only runtime errors
04:14:50 <helmut> mm_freak: I am kinda out of options beyond brute force.
04:14:53 <merijn> :t stdgen
04:14:54 <lambdabot> Not in scope: `stdgen'
04:15:04 <merijn> Is there a stdgen accessible in lambdabot?
04:15:05 <Walther> merijn: quite possibly. I'm trying to take n random characters from the range A-Z. My logic was to take random-th element of that list, but clearly i'm thinking wrong
04:15:22 <Walther> sidenote: i'm *really* taking baby steps in learning haskell, more familiar with python and java
04:15:25 <merijn> Walther: You probably want "randomRs ('A', 'Z')"
04:15:30 <merijn> :t randomRs
04:15:31 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
04:15:35 <mm_freak> helmut: ok, let me put it this way:  explicit use of 'fail' is almost always a bad idea
04:15:38 <Rembane> > succ 'A'
04:15:39 <lambdabot>  'B'
04:15:41 <Rembane> :D
04:15:49 <Sgoettschkes> I am a bit lost trying to setup my project with a src and test directory and then run the tests using runhaskell. It cannot find the module because they are "hidden" in the src folder. Does anyone know a good tutorial?
04:15:51 <mm_freak> helmut: its purpose is to handle pattern match failures in do-blocks
04:16:02 <Walther> merijn: Woo. Thanks.
04:16:03 <mm_freak> helmut: which monad is it?
04:16:17 <merijn> Walther: "randomRs" takes a range of values (the tuple) and a generator and returns an infinite list of random values within your range
04:16:25 <helmut> mm_freak: I completely failed to load any parts of the code into ghci (fails to find .hi files no matter where I point it), I completely fail tell cabal to install profiled libraries, I have been using trace to isolate the cause.
04:16:28 <mm_freak> Sgoettschkes: library or executable?
04:16:46 <helmut> mm_freak: I guess it is ReaderT
04:16:57 <merijn> Walther: You need to use newStdGen, makeStdGen or getStdGen to obtain a generator
04:17:02 <mm_freak> helmut: sounds like you want to contact the original author =)
04:17:02 <Walther> ...gah, that's not quite enough. I still need one more char in the random range, the space character.
04:17:07 <Walther> merijn: nod, that's in the main
04:17:13 <Sgoettschkes> mm_freak: Not sure... Just some code for ProjectEuler I use to learn haskell
04:17:31 <mm_freak> Sgoettschkes: oh, i assumed that you use cabal
04:17:35 <helmut> mm_freak: maintainer states that he does not understand the code
04:17:49 <helmut> mm_freak: author unreachable
04:17:52 <Sgoettschkes> mm_freak: I am looking into this right now.
04:18:11 <mm_freak> Sgoettschkes: in that case there are two solutions:  1. tell your interpreter the search path, 2. cabalize your project
04:18:21 <Walther> Is there a way to explicitly give the random generator the list of possible options instead of begin,end range?
04:18:31 <Walther> namely, A-Z + space char
04:18:34 <merijn> Walther: You also might want to look into QuickCheck's Arbitrary which lets you generate "random" lists and such
04:18:44 <mm_freak> helmut: well, i'm afraid we can't really help without seeing the code
04:19:03 <Sgoettschkes> mm_freak: I cannot seem to find how to tell runhaskell the search path. This would be easier right now I guess
04:19:46 <merijn> Walther: I'm not sure if that exists
04:19:53 <Walther> case in point, I'm trying to write a simple Weasel Program (Dawkins' weasel, http://en.wikipedia.org/wiki/Weasel_program ) as a nice exercise to learn more haskell
04:19:58 <helmut> mm_freak: oh sure. http://paste.debian.net/74509/
04:20:03 <merijn> Walther: Well, presumably it does, but don't ask me how >.>
04:20:26 <Walther> merijn: there should be a way to hack that though- something like making an explicit list of the allowed chars and randomly taking nth element?
04:20:46 <Walther> random range being the length of that list...
04:20:47 <helmut> mm_freak: compared to the original source, I already fixed up the compilation errors.
04:21:00 <mm_freak> helmut: perhaps you shouldn't have done that
04:21:04 <jmcarthur> shachaf: i looked for one a couple times but never found one
04:21:09 <helmut> mm_freak: you can always unpull
04:21:28 <merijn> Walther: I can think of several ways, but they all strike me is rather involved, I'm not really up to date with System.Random
04:21:49 <merijn> Walther: But QuickCheck's Arbitrary has tools for controlling what sort of random output it produces
04:21:58 <merijn> (not that I've used that a lot)
04:22:11 <Walther> Nod. Will continue trying on my own. (I've been reading the examples of quickcheck, but that's probably too much for this usecase)
04:26:43 <mm_freak> helmut: the first step is to revert your changes…  don't trick the type checker, because it probably has a very good reason to complain
04:27:48 <mm_freak> helmut: since the code seems very old, you're probably suffering from breaking API changes
04:33:04 <skypers_> hi
04:33:11 <ChongLi> hey
04:33:30 <skypers_> I’ve been wondering, Haskell doesn’t support explicit allocation
04:33:43 <ChongLi> sure it does
04:33:47 <merijn> skypers_: Depends on whether you include the FFI
04:33:47 <ChongLi> through the FFI
04:33:56 <skypers_> without the FFI
04:34:02 <skypers_> imagine you have to parse a file
04:34:07 <skypers_> like an .obj file
04:34:17 <skypers_> I mean the shockwave 3D mesh format
04:34:33 <skypers_> you can’t built up a [Float] when reading vertex position values
04:34:38 <skypers_> if you have 80M of them
04:34:48 <ChongLi> just use Vector or Repa
04:34:50 <skypers_> it’ll result in poor efficiency
04:34:55 <skypers_> in C++
04:35:00 <skypers_> you’d do a first pass
04:35:22 <ChongLi> both Vector and Repa have Storable instances
04:35:26 <skypers_> in order to get how many positions they are, then use the reserve function of your favorite container in order to preallocate things
04:35:29 <merijn> You can use stuff like pipes to do process that in a streaming fashion
04:35:34 <ChongLi> and instances of NFData
04:35:39 <merijn> ChongLi: That doesn't help if you have more numbers than memory
04:35:39 <skypers_> merijn: what do you mean?
04:35:55 <skypers_> plus I’d like not to do it with FFI
04:35:58 <ChongLi> which means you can easily force it to normal form
04:35:59 <skypers_> is it even possible?
04:36:08 <ChongLi> skypers_: what are you going to do with the data?
04:36:21 <merijn> skypers_: The pipes library is designed to do stream processing on IO, so you can parse and deal with the floats are you read them from disk
04:36:23 <skypers_> built them up into a [Float]
04:36:34 <ChongLi> skypers_: and then what?
04:36:44 <skypers_> ChongLi: send them to the GPU ;)
04:36:56 <ChongLi> skypers_: that requires the FFI
04:37:00 <Walther> Hmm. Data.Random.Extras seems *very* useful for what I need now - however, I seem to have weird errors when using it - can't get GHCi to "show" / print when i e.g. `choices 5 ['A'..'Z']`
04:37:08 <skypers_> ChongLi: sure
04:37:17 <skypers_> I was just thinking of lists
04:37:28 <skypers_> when you call (:)
04:37:30 <skypers_> does it do so reallocations?
04:37:31 <Walther> > let a = choices 5 ['A'..'Z']
04:37:32 <lambdabot>  not an expression: `let a = choices 5 ['A'..'Z']'
04:37:35 <ChongLi> skypers_: if you instead parse your obj file into a Storable-based vector
04:37:35 <skypers_> some*
04:37:45 <ChongLi> you can send it to the GPU without an extra copy
04:37:46 <Walther> :t a -> a :: Data.RVar.RVar [Char]
04:37:47 <lambdabot> parse error on input `->'
04:37:58 <merijn> Walther: choices returns an RVar, RVars aren't showable
04:38:00 <skypers_> ChongLi: I don’t know Vector yet
04:38:20 <ChongLi> skypers_: it's pretty straightforward; most of the functions are similar to what you'd do with lists
04:38:26 <merijn> Walther: You want to use "runRVar" to get a specific random value out
04:38:30 <skypers_> :t choices
04:38:31 <lambdabot> Not in scope: `choices'
04:38:39 <merijn> Walther: Think of RVar as a "random variable generator"
04:38:41 <helmut> mm_freak: if you look at my fixes, you'll notices that I took the time to understand the individual causes
04:38:44 <ChongLi> it has map, foldl, foldr
04:38:55 <ChongLi> and index-based versions of those
04:38:57 <merijn> Walther: And runRVar as "generate a random value using this generator"
04:38:59 <helmut> mm_freak: and yes, api breakage did occur at various places
04:39:17 <skypers_> ChongLi: how is it implemented?
04:39:28 <ChongLi> skypers_: how is Vector implemented?
04:39:33 <Walther> merijn: ahhh so I get random "pointers" generated for the list as a target but no randomgenerator as to how to interpret those ...kinda.
04:39:37 <skypers_> ChongLi: yes
04:39:37 <skypers_> I mean
04:39:39 <ChongLi> skypers_: depends on the version
04:39:52 <helmut> mm_freak: specifically the api to "fail" appears to have changed in a semantic way that doesn't break type checking and I am still not getting how
04:39:53 <skypers_> you seem to say I can reserve memory up with it
04:39:53 <Walther> next question is obviously how the hell do I extract those values and get it to actually return me n chars from a list :P
04:39:53 <ChongLi> the Storable version is based on unboxed arrays stored on the C heap
04:39:56 <skypers_> with withBytes
04:40:07 <merijn> Walther: Basically, there's no Show instance for RVar since it's a generator type thing
04:40:12 <Walther> nod.
04:40:25 <merijn> Walther: As for how to extract them, use runRVar from Data.Random.RVar
04:40:33 * hackagebot threads 0.5.1.1 - Fork threads and wait for their result  http://hackage.haskell.org/package/threads-0.5.1.1 (BasVanDijk)
04:40:37 <skypers_> I’m going to look into the Vector package
04:40:41 <skypers_> thank you very much
04:40:45 <skypers_> and what’s about Repa?
04:40:51 <merijn> Walther: Which uses the RandomSource typeclass from Data.Random
04:40:53 <skypers_> parallels arary?
04:40:54 <skypers_> array*
04:41:01 <ChongLi> skypers_: yeah, parallel arrays
04:41:12 <skypers_> what does it involvel?
04:41:13 <skypers_> -l
04:41:18 <skypers_> dammit keyboard, be cool
04:41:19 <ChongLi> it's more complicated
04:41:31 <haasn> Hmm. I'm trying to find a blog post I remembered, about some Google mathematics challenge and how some guy used Haskell to solve it. It involved lots of monoids and stuff. I forgot anything more specific than that. Ring any bells?
04:41:44 <haasn> I don't even remember what specific google challenge it was, but the ultimate solution was a number
04:41:55 <ChongLi> Repa's based on the idea of delayed and manifest representations
04:42:12 <identity> god. Trying to deal with people from #java makes me appreciate how fucking awesome this community is.
04:42:17 <ChongLi> a delayed representation doesn't the data; just functions to compute it
04:42:19 <identity> what a bunch of f... assholes.
04:42:49 <ChongLi> identity: a lot of it has to do with the relative sizes of the communitie
04:42:50 <ChongLi> s
04:43:05 <ChongLi> generally, the larger a community the less personable and friendly it is
04:43:19 <merijn> ChongLi: #haskell is considerably larger than most programming channels on freenode
04:43:31 <merijn> ChongLi: Pretty sure it's larger than #java, for example
04:43:41 <mm_freak> helmut: the 'fail' function did not change
04:43:42 <skypers_> [13:37] <identity> god. Trying to deal with people from #java makes me appreciate how fucking awesome this community is.
04:43:45 <skypers_> that’s sadly true
04:43:53 <ChongLi> merijn: but Haskell in general is much smaller than Java
04:43:58 <skypers_> [13:38] <merijn> ChongLi: #haskell is considerably larger than most programming channels on freenode
04:44:00 <skypers_> I disagree
04:44:04 <helmut> mm_freak: it's interaction with catchError did change
04:44:11 <skypers_> they’re a lot of idleing folks here
04:44:17 <skypers_> we’re not that much
04:44:29 <mm_freak> helmut: for most monads 'fail' just yields a bottom
04:44:36 <ChongLi> skypers_: that is true
04:44:50 <ChongLi> I've been idling on/off in this channel for at least a couple of years now
04:45:05 <skypers_> yeah, it’s the first time I see you today :)
04:45:15 <ChongLi> I was out shoveling snow
04:45:16 <helmut> mm_freak: ok, so I somehow need to learn what kind of Error is desired here and change all exception-like uses of fail to throwError.
04:45:30 <ChongLi> we had a good 20-30cm!
04:45:34 <ChongLi> very heavy stuff
04:45:42 <skypers_> nothing in France
04:45:45 <skypers_> you got lucky
04:45:57 <ChongLi> haha, want to switch?
04:46:02 <skypers_> depends
04:46:06 <skypers_> where do you live?
04:46:10 <ChongLi> Canada
04:46:13 <mornfall> it's springtime here :-)
04:46:19 <skypers_> oh Canada
04:46:29 <skypers_> you might be afraid of the dark then!
04:46:33 <skypers_> ahah :)
04:46:36 <identity> skypers_: yeah. it's horrible
04:46:38 <identity> same with #c++
04:46:41 <identity> and #c, I believe
04:46:41 <ChongLi> it's 7:40 right now :)
04:46:44 <ChongLi> not that dark
04:46:49 <skypers_> identity: you mean idleing folks?
04:47:04 <identity> no, I mean people being assholes
04:47:06 <identity> bigots and rude
04:47:09 <Walther> How exactly am I supposed to use runRVar?
04:47:17 <ChongLi> one other comment I'd have to make about people being assholes with other programming languages
04:47:33 <ChongLi> is that those languages punish you a lot more for mistakes
04:47:46 <ChongLi> and thus people build up this natural hostility
04:47:47 <mornfall> ChongLi: that largely depends on what you are doing
04:47:54 <skypers__> identity: have you told them you’re into Haskell?
04:48:00 <ChongLi> by blaming the programmer for mistakes the compiler should have caught
04:48:09 <skypers__> it always breaks the talk
04:48:14 <identity> skypers__: haha, no
04:48:21 <mornfall> ChongLi: like space leaks? :-P
04:48:30 <ChongLi> haha
04:48:34 <Walther> if I just simply have used "choices n list" somewhere and want to get actual values out, how and where am I supposed to use runRVar?
04:48:39 <helmut> mm_freak: in any case this s/fail .*/throwError undefined/ hack makes the source work in a meaningful way for small examples. It cannot be too far off.
04:48:43 <ChongLi> like unrestrained mutation
04:48:47 <skypers__> yesterday I was talking about my friends that think I’m idiot writing Haskell programs, because Haskell will die soon
04:48:50 <ChongLi> data races
04:48:57 <merijn> Walther: "runRVar (choices n list) StdRandom" should work, I think?
04:49:10 <skypers__> nowadays, people only think OO
04:49:12 <skypers__> nothing else
04:49:20 <ChongLi> and casting
04:49:25 <mornfall> ChongLi: you can only get so far in high-performance parallelism without running a risk of data races
04:49:28 <skypers__> that’s why I like our community
04:49:28 <Gorroth> people think of FP a lot
04:49:35 <skypers__> Gorroth: Java ones?
04:49:39 <skypers__> not really…
04:49:45 <Gorroth> i write c++ on a daily basis, and we write FP in certain areas
04:49:55 <Gorroth> real programmers don't use java
04:50:00 <skypers__> I agree
04:50:00 <ChongLi> mornfall: yes, but a type-checker such as Haskell's can help you avoid a lot of them
04:50:09 <Gorroth> damn, you type fast, skypers__
04:50:09 <skypers__> but real programmers are rare
04:50:17 <skypers__> Gorroth: what do you mean?
04:50:17 <mornfall> ChongLi: every language has a number of weak spots, arguing that you can live with Haskell's better than with those of other languages is fairly subjective
04:50:19 <ChongLi> pure functions are a very good thing to have around
04:50:26 <Gorroth> skypers__: you responded to me very quickly; that's what i mean :)
04:50:38 <skypers__> Gorroth: yeah it’s due to my layout ;)
04:50:43 <Gorroth> ah
04:50:48 <skypers__> very comfy and speed-oriented
04:51:05 <ChongLi> mornfall: you're probably right
04:51:06 <Gorroth> i use a mech board on my desktops (damn chiclet on this laptop)
04:51:13 <Gorroth> but i don't use anything other than qwerty
04:51:15 <Walther> mechs <3
04:51:19 <skypers__> Gorroth: I use bépo
04:51:22 <skypers__> it’s a french layout
04:51:26 <Gorroth> ah, ok
04:51:27 <skypers__> for typing french and code
04:51:33 <skypers__> and it sucks at english languages
04:51:41 <ChongLi> I could point to some of Haskell's really great libraries, but that could be attributed to the programmers as much as anything
04:51:46 <skypers__> the w is very far, just next to return actually
04:52:05 <ChongLi> though I think it'd be very difficult to do something like lens or STM in other languages
04:52:18 <mornfall> ChongLi: for every great haskell library, there's a couple rather suboptimal
04:52:19 <skypers__> ChongLi: in C++ lens is stupid I guess
04:52:33 <mornfall> ChongLi: and you could just argue that lens is a workaround for a language weakness :)
04:52:42 <simon> it seems that installing GHC through a package manager gives me something like 700MB stuff. what's taking all that space?
04:52:43 <skypers__> STM is the clearly the future of concurrent models
04:52:47 <skypers__> -the
04:52:50 <ChongLi> mornfall: it is that, but it's so much more as well
04:53:05 <ChongLi> it goes way beyond fixing record syntax
04:53:17 <skypers__> ChongLi: it’s actually too powerfull to me
04:53:19 <Taneb> lens was a workaround until they realised how powerful an abstraction it was
04:53:31 <ChongLi> skypers__: you'll get there eventually
04:53:32 <simon> my .cabal, through which my actual GHC is installed, is something like 900MB, but I can't clearly determine how much of this is GHC itself and how much is other libraries.
04:53:42 <skypers__> ChongLi: no I mean
04:53:43 <mornfall> ChongLi: yes, and the type signatures are extremely scary
04:53:44 <skypers__> it’s too large
04:53:51 <mm_freak> helmut: sorry, but i can't help you right now
04:54:09 <mornfall> ChongLi: kind of like throwing erlang at unsuspecting folks
04:54:18 <skypers__> something great would be a fix in GHC to introduce lens into the record syntax update statement
04:54:19 <ChongLi> haha
04:54:23 <helmut> mm_freak: no issue. thanks for your effort anyway
04:54:28 <ChongLi> Haskell has an answer for that, too
04:54:35 <ChongLi> though I haven't heard much on its progress
04:54:45 <valdyn> simon: the statically linked stuff probably takes alot, see http://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
04:54:45 <skypers__> ChongLi: what for?
04:55:02 <mornfall> skypers__: as for STM, it's apparently not coming in hardware anytime soon
04:55:12 <ChongLi> skypers__: http://hackage.haskell.org/package/distributed-process
04:55:29 <ChongLi> mornfall: well, that would be weird, wouldn't it?
04:55:42 <Gorroth> what is "STM"?
04:55:52 <ChongLi> software transactional memory
04:56:00 <mornfall> ChongLi: well, hardware transactional memory is an option
04:56:01 <Gorroth> okay, thanks
04:56:06 <skypers__> it’s an abstraction over concurrency
04:56:18 <Taneb> Gorroth, sort of like IO actions that can fail and be undone or retried
04:56:19 <skypers__> I actually like the abstraction
04:56:29 <skypers__> it would be possible in other languages though
04:56:34 <skypers__> C++ supports delegates
04:56:35 <mornfall> skypers__: abstraction is nice, but it's pretty hard to implement efficiently
04:57:17 <ChongLi> skypers__: I mentioned earlier that I don't think STM is all that reasonable in other languages
04:57:18 <companion_cube> the more immutable values are, the more efficient STM can be, apparently
04:57:32 <mornfall> skypers__: at some point, you need to revert to atomic instructions to get the performance you need
04:57:34 <companion_cube> (less locks are required)
04:57:47 <ChongLi> with STM you need to be able to control side effects
04:57:47 <skypers__> mornfall: sure
04:57:54 <Gorroth> yano: yeah, i'm taking a look at it on wikipedia.  sounds cool in concept
04:58:11 <ChongLi> if you "launch the missiles" in a transaction, it may end up getting repeated
04:58:12 <Gorroth> i remember hearing a little bit about this back when i was in grad school
04:58:22 <ChongLi> you can't have that
04:58:46 <ChongLi> and so you need some way of making sure these side effects don't occur inside a transaction
04:58:52 <ChongLi> Haskell uses the type system to enforce it
04:58:57 <skypers__> ChongLi: is there a huge difference between Vector and Array?
04:59:07 <Walther> still having weird problems http://lpaste.net/1961171080550809600
04:59:08 <ChongLi> skypers__: yeah
04:59:25 <ChongLi> Vector has tons of work put in to do stream fusion
04:59:36 <ChongLi> it's a very fast library
04:59:58 <skypers__> whereas *Array are slow?
05:00:41 <Walther> somehow that "let rs" part just ...fails
05:00:50 <ChongLi> skypers__: yeah
05:01:08 <ChongLi> unless you have a specific reason for using Array, you should probably use Vector
05:01:15 <Walther> if I plain "runRVar..." in GHCi, it works - trying to set the value of that run into a variable (rs) and then print is doesn't work
05:01:25 <Walther> it*
05:01:39 <lllllllllllll> Walther: let rs = runRVar $ (randomsentence 28) StdRandom -- maybe?
05:01:40 <skypers__> ChongLi: I have a matrix library
05:01:44 <skypers__> it has to be fast
05:01:45 <skypers__> currently
05:01:57 <skypers__> it’s written with Array; should I consider using Vector instead?
05:02:05 <lllllllllllll> Walther: ah nvm
05:02:17 <ChongLi> skypers_: it's your own library?
05:02:32 <ChongLi> I'd say yeah, try Vector
05:03:11 <skypers__> damned network connection
05:03:17 <Walther> lllllllllllll: Nope.
05:03:45 <lllllllllllll> Walther: rs <- runRVar (randomsentence 28) StdRandom --shouldnt it be this since runRVar gives an m a?
05:03:58 <ChongLi> I thought the ISPs in France were very good?
05:04:10 <skypers__> ISPs?
05:04:18 <ChongLi> interenet service providers
05:04:19 <Walther> lllllllllllll: That works! Now: why? :P
05:04:35 <skypers__> ChongLi: I think it’s my company’s firewall’s fault here
05:04:40 <ChongLi> ah
05:05:08 <skypers__> hm
05:05:13 <lllllllllllll> Walther: runRVar :: RandomSource m s => RVar a -> s -> m a so you geht back an m a und you have to 'unpack' it with <-
05:05:36 <skypers__> I just read that map f . map g can be rewritten into map (f . g) by GHC
05:05:40 <skypers__> how does it do that?
05:05:41 <Walther> a) what is a "m a" b) errrwhat "unpack"
05:06:06 <skypers__> I do it on my own, but I never thought GHC would be able to do the same thing!
05:06:31 <Walther> lambdabot: can haskell do that?
05:06:40 <Walther> oh, heh, can't remember the syntax
05:06:56 <Walther> ("the answer is yes, yes haskell can do that" or something similar :P)
05:07:00 <alpounet> @faq can haskell materialize a cup of coffee out of thin air?
05:07:01 <lambdabot> The answer is: Yes! Haskell can do that.
05:07:14 <Walther> speaking of coffee ->
05:07:19 <jonasw> skypers__: Rewrite rules
05:07:30 <skypers__> jonasw: you mean, class’ laws?
05:07:41 <haasn> skypers__: language pragmas
05:07:43 <Gorroth> alpounet: sudo materialize coffee
05:07:44 <Walther> Also, if someone can explain to me that "let rs = foo" versus "rs <- foo" difference, I'd really appreciate it.
05:07:55 <haasn> skypers__: http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
05:07:57 <skypers__> Walther: the first one is just an alias
05:08:00 <lllllllllllll> Walther: RandomSource is a monad and there is the constraint that m should be a RandomSource and with <- you execute the monadic computation and get back the result and bind it to
05:08:04 <skypers__> the second one extract the value from the Monad
05:08:05 <lllllllllllll> something
05:08:13 <skypers__> in order to pass it to a monadic function
05:08:16 <Gorroth> @faq can Haskell get me the ladies?
05:08:16 <lambdabot> The answer is: Yes! Haskell can do that.
05:08:24 <skypers__> thank you haasn
05:08:34 <jonasw> skypers__: What haasn said :)
05:08:39 <skypers__> wooooooh
05:08:42 <skypers__> that’s awesome!
05:08:53 <theorbtwo> @faq can haskeeel give me irrelevant answers?
05:08:53 <lambdabot> The answer is: Yes! Haskell can do that.
05:09:06 <Gorroth> @faq how do you say hello to a woman?
05:09:06 <lambdabot> The answer is: Yes! Haskell can do that.
05:09:17 <Gorroth> hmmmmmmmmmmm
05:09:27 <skypers__> @faq can you guys please stop?
05:09:28 <alpounet> beware though, rewrite rules are a bit a source of headache sometimes. particularly, that'll make you get to know a lot more about inlining in GHC and how to make it play nicely with your custom RULES
05:09:28 <lambdabot> The answer is: Yes! Haskell can do that.
05:09:56 <skypers__> alpounet: I don’t use inline yet
05:10:16 <skypers__> I’ll do that in an optimization phase
05:10:18 <alpounet> GHC does inline stuffs
05:10:22 <alpounet> that's what i meant
05:10:28 <skypers__> along strictness
05:10:29 <haasn> you need to inline a lot if you want rules to be very effective, right?
05:10:44 <Gorroth> sweet, there are a set of Haskell exercises I can follow and try to do while i read lyah so that i don't feel like i'm wasting time
05:10:52 <haasn> well, depends on the rule I guess
05:10:52 <alpounet> haasn: it depends. you have to inline enough that your rewrite rule will be matched
05:10:56 <alpounet> but not more
05:11:06 <alpounet> so that the functions you mention in your rule haven't been inlined away
05:11:48 <haasn> if you want to inline more, you have to separate it into phases or something?
05:11:49 <skypers__> ok let’s download vector
05:12:06 <haasn> ie. if you want to inline stuff post-transformation
05:12:24 <alpounet> haasn: then you set inlining phases
05:12:28 <alpounet> INLINE [1] foo
05:12:29 <alpounet> etc
05:14:05 <alpounet> haasn: see "Phase control" (7.18.5.5) on http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/pragmas.html
05:14:16 <augur> anyone know how to turn corecursive defs using unfold into (co)pattern matching definitions and/or object-y definitions mechanically, like you can do with recursive defs using fold?
05:14:17 <haasn> yes, that's what I had open right now :)
05:16:05 <Gorroth> > head (tail (reverse [1,2,3,4]))
05:16:07 <lambdabot>  3
05:16:09 <Gorroth> yay
05:16:28 <Gorroth> > [1,2,3,4] !! (length [1,2,3,4] - 2)
05:16:29 <lambdabot>  3
05:16:31 <Gorroth> yay
05:16:55 <skypers__> > let a = [1..4] in a !! (length a - 2)
05:16:57 <lambdabot>  3
05:17:14 <Gorroth> okay, whoa, i'm not that advanced
05:17:22 <Gorroth> what does "in a" mean
05:17:33 <skypers__> you’ll get that very soon Gorroth :)
05:17:41 <haasn> Gorroth: “let <definitions> in <expr>” is a way of defining things locally
05:17:44 <skypers__> Gorroth: it’s a let..in expression
05:17:45 <haasn> > let x = 2 in x + x
05:17:46 <lambdabot>  4
05:17:58 <Gorroth> is that somewhere in LYAH?
05:18:00 <haasn> Yes :)
05:18:15 <Gorroth> hehe, i mean, where in LYAH is it?  i'll go read up on it
05:18:22 <Gorroth> oh...
05:18:24 <Gorroth> i see
05:18:30 <skypers___> you can see let…in expressions as a way to share things
05:18:31 <haasn> http://learnyouahaskell.com/syntax-in-functions#let-it-be
05:18:47 <haasn> skypers___: also a way to recurse
05:18:47 <Gorroth> let K = <value> in <do something with K's value here and return the result back into K again>
05:18:49 <skypers___> but it’s really locally defined names
05:18:50 <Gorroth> like that?
05:18:54 <skypers___> haasn: you mean fix?
05:19:04 <haasn> > let x = "meow" ++ x in "cats go " ++ x
05:19:05 <lambdabot>  "cats go meowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeo...
05:19:16 <Gorroth> lol
05:19:26 <haasn> Gorroth: “return the result back into K again” makes no sense
05:19:38 <haasn> “let <definitions> in <expr>” is an expression. It evaluates to whatever <expr> evaluates to
05:19:49 <skypers___> > cat go ++ fix ("meow"++)
05:19:51 <lambdabot>  Not in scope: `go'
05:19:51 <lambdabot>  Perhaps you meant one of these:
05:19:51 <lambdabot>    `g' (imported from Debug.SimpleReflect),
05:19:51 <lambdabot>    `o' (imported from Debug.SimpleReflect),
05:19:51 <lambdabot>    `to' (imported from Control.Lens)
05:19:57 <frohe> :t (+) . (*)
05:19:58 <lambdabot> (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
05:20:06 <skypers___> > "cat go" ++ fix ("meow"++)
05:20:07 <haasn> Definitions are immutable, the value of ‘x’ in “let x = 2 in x + x” can't change
05:20:07 <lambdabot>  "cat gomeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowm...
05:20:22 <haasn> the whole thing evaluates to 2 + 2 or 4
05:20:29 <skypers___> something really strange, fix is in Prelude
05:20:29 <haasn> compare:
05:20:31 <skypers___> I never use fix
05:20:33 <haasn> > (\x -> x + x) 2
05:20:34 <Gorroth> haasn: hmm, i sort of understand, but not completely.  i'll just have to work with it
05:20:35 <lambdabot>  4
05:20:36 <skypers___> I wonder why it’s there
05:20:46 <sergs> guys, bit of a silly question - have you ever had cabal give a binary that generates different results compared to a ghc --make binary?
05:21:03 <sergs> this is for a purely mathematical program
05:21:14 <haasn> sergs: different optimizations by default perhaps?
05:21:16 <sergs> minimal IO, just evaluates a single function ones, spits out the answer
05:21:18 <merijn> sergs: Define "different"?
05:21:30 <merijn> Also, are you using Double?
05:21:31 <sergs> the correct answer, that ghc --make generates
05:21:34 <sergs> is 49
05:21:47 <sergs> the cabal answer is a huge negative number
05:21:55 <sergs> which looks like an overflow
05:22:17 <sergs> close to -2^63
05:22:25 <identity> that sounds strange
05:22:37 <k00mi> sergs: different versions of a dependency?
05:22:47 <haasn> sergs: what's the program?
05:22:56 <sergs> one sec
05:24:11 <frohe> could anyone explain to me why the type of (+) . (*) is  (Num (a -> a), Num a) => a -> (a -> a) -> a -> a ?
05:24:36 <merijn> frohe: (.) composes functions that take one argument, (+) and (*) take two
05:24:39 <merijn> :t (.)
05:24:39 <haasn> :t (.)
05:24:41 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:24:41 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:25:05 <sergs> :haasn https://github.com/sergsr/projeu/blob/master/solutions/Solns2.hs
05:25:12 <merijn> frohe: Here "a -> b" == "Num a => a -> (a -> a)"
05:25:39 <merijn> frohe: So the 'b' in 'b -> c' is "Num a => a -> a"
05:25:49 <Gorroth> haasn: alright, i found the bit about it in LYAH.  so, let x = "meow" ++ x in "cats go " ++ x, means that you defined x infinitely recursively to be meow+mewo+meow..., and then you used that value in the "in" portion
05:26:02 <merijn> frohe: And because (+) expects two arguments of the same type, the second argument of (+) must also be "Num a => a -> a"
05:26:03 <Gorroth> > let x = "meow" ++ x in "cats go " ++ x
05:26:05 <lambdabot>  "cats go meowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeowmeo...
05:26:07 <Gorroth> sweeet
05:26:46 <Walther> Hmmmm. Is there a nice way to compare n lists of chars and pick whichever is the "closest" to a target list of chars?
05:26:46 <Gorroth> that looks all very mathematical
05:26:49 <skypers___> frohe: you might consider the monadic version
05:26:49 <merijn> Gorroth: You can even do cooler things like lazily zipping a list with itself
05:26:54 <skypers___> :t (+) >=> (*)
05:26:55 <Fylwind> is there a trick for repeating a nested list comprehension N times?  e.g. [[... | x <- foo y] | y <- foo z] etc
05:26:55 <lambdabot> Num a => a -> a -> a
05:26:57 <skypers___> :)
05:27:02 <Walther> Assuming equal length of chars per "sentence"
05:27:10 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- Gorroth
05:27:11 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
05:27:18 <sergs> Gorroth: it's from project euler, sorry for any spoilers
05:27:35 <skypers___> :t liftA2 (>>) (+) (*)
05:27:36 <lambdabot> Num a => a -> a -> a
05:27:46 <Gorroth> sergs: spoilers to what?  i didn't see anything about euler
05:27:54 <haasn> :t (.) `asTypeIn` \comp -> comp (+) (*) -- frohe
05:27:54 <lambdabot> (Num (a -> a), Num a) => ((a -> a) -> (a -> a) -> a -> a) -> (a -> a -> a) -> a -> (a -> a) -> a -> a
05:28:18 <Gorroth> merijn: okay... now you did something else i don't know how to do :)  i don't know what ":" and "(+)" means at all there
05:28:24 <haasn> the (+) takes on the form of (a -> a) -> (a -> a) -> (a -> a)
05:28:32 <haasn> Because you're essentially adding “the result of (*) applied once”
05:28:33 <skypers___> Gorroth: (+) is the Num addition
05:28:36 <skypers___> and (:) is cons
05:28:41 <sergs> Gorroth: they discourage having solutions online, i've obfuscated it a little bit, but it's nice to have something to show to potential employers
05:28:42 <skypers___> the constructor of a list
05:28:47 <merijn> Gorroth: : is list append, i.e. [1,2,3] == 1:2:3:[]
05:28:52 <merijn> Well, list prepend
05:28:59 <Gorroth> aaah
05:29:09 <merijn> Gorroth: And in haskell any operator can be made prefix by surrounding it with parentheses
05:29:12 <merijn> > 1 + 1
05:29:14 <lambdabot>  2
05:29:15 <merijn> > (+) 1 1
05:29:17 <lambdabot>  2
05:29:18 <skypers___> Gorroth: lists only have two constructors
05:29:20 <skypers___> [] and (:)
05:29:30 <lllllllllllll>  Walther, u mean something like levenshtein distance
05:29:53 <Gorroth> skypers___: okay, i'll have to look into the lists portion of LYAH again
05:29:56 <skypers___> [1,2] is just 1 : 2 : []
05:30:03 <skypers___> :)
05:30:13 <merijn> Gorroth: So "zipWith (+)" is just passing (+) (two argument addition function) as argument to zipWith (:: (a -> b -> c) -> [a] -> [b] -> [c])
05:30:28 <Gorroth> merijn: ohhhh, i had seen the part about making prefix into infix with backticks, but i hadn't seen the part about making infix into prefix with ()
05:30:37 <mm_freak> here is a nice way to express it:  (+) is the addition function =)
05:30:39 <merijn> Gorroth: in other words "zipWith (+)" takes two lists and sums each pair
05:31:04 <Gorroth> okay, that makes more sense now; thannk you
05:31:23 <sergs> haasn: https://github.com/sergsr/projeu/blob/master/solutions/Solns2.hs in case you missed it.
05:31:26 <merijn> Gorroth: And since "tail fibs" is fibs minus the first entry, "zipWith (+) fibs (tail fibs)" sums the first value of fibs with the 2nd, the 2nd with the 3rd, etc.
05:31:57 <Walther> lllllllllllll: More like hamming distance. I'm dealing with sentences of equal length
05:32:19 <Gorroth> merijn: yeah, looks cool.  i mean i understand it now, but i wouldn't think to come up with that kind of solution right now
05:32:31 <skypers___> Gorroth: #classic
05:32:37 <skypers___> when I learnt with lyah
05:32:42 <merijn> Gorroth: It takes a while before that stuff becomes natural, it's just a cool trick to show :p
05:32:48 <Gorroth> skypers___: :-)
05:32:53 <skypers___> I thought mapM_ sucked
05:32:55 <Gorroth> merijn: yeah, very cool :-)
05:33:01 <skypers___> I was innocent :)
05:33:02 <Gorroth> okay, i should try and get back to sleep
05:33:26 <Gorroth> goodnight all!
05:33:26 <sergs> hamming distance - you could sum $ zipWith (XOR)
05:33:32 <sergs> :Gorroth night
05:33:34 <skypers__> seriously, network…
05:33:40 <sergs> Gorroth: night**
05:33:46 <Walther> sergs: not dealing with binary though, does that work with [Char]?
05:33:49 <skypers__> night Gorroth
05:34:10 <sergs> Walther: if you import Data.Bits, i believe a Char works with their XOR
05:34:53 <sergs> Walther: oh, i guess you want hamming distance calculated byte per byte?
05:35:03 <merijn> Character per character, most likely
05:35:21 <merijn> In which case he can just "zipWith (/=)" and sum the number of True values
05:35:29 <xpika> how can i pass an arbitary addition to the gcc from ghc?
05:35:37 <sergs> that would work
05:35:38 <Walther> sergs: I'm writing a demo "genetical evolution" algo. I randomly generate n child sentences with n% probability of change for each Char in sentence, and want to take the "fittest" child as the new parent
05:35:44 * hackagebot language-puppet 0.10.5 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.10.5 (SimonMarechal)
05:35:45 <Walther> comparing to target sentence
05:36:07 <merijn> xpika: There's a flag in ghc for that, consult the GHC user manual and/or "ghc --help"
05:36:35 <sergs> Walther: yeah, i think what merijn said - something like length $ zipWith (/=)
05:36:45 <sergs> err
05:36:46 <Walther> Say, "KOFFEE" is closer to "COFFEE" than "QWEERR"
05:36:51 <sergs> a bit wrong
05:37:22 <xpika> merijn: i have that's why im asking here
05:37:23 <sergs> Walther: length $ filter (True) $ zipWith (/=)
05:38:12 <sergs> Walther: or something of that nature. i should probably sleep soon >_<
05:38:15 <theorbtwo> Walther: look for hamming distance.
05:38:24 <frohe> thanks guys, i wrote it down and understood it :)
05:38:25 <Walther>     Couldn't match expected type `Bool -> Bool' with actual type `Bool'
05:38:52 <sergs> Walther: yeah, sorry, the filter (True) should be filter id
05:38:53 <Walther> theorbtwo: exactly, the problem is how to implement hamming distance calculator in Haskell for [Char]s :P
05:40:12 <Walther> sergs: Woo. Thanks!
05:40:21 <Walther> now to try and understand that function :P
05:41:04 <sergs> Walther: the zipWith (/=) takes the lists, compares each value, gives true if they're not equal
05:41:38 <sergs> Walther: filter id turns the resulting list of trues and falses from the zipwith into a list of just the trues
05:41:55 <sergs> Walther: and length just counts how many trues happened
05:42:30 <Walther> Oh boy I love the #haskell community. Always eager to actually explain instead of telling to rtfm
05:42:35 <Walther> Thanks a lot!
05:42:41 <sergs> np
05:42:59 <sergs> i hope i don't have to write a bug report for what i've got >_<
05:43:25 <ChongLi> Walther: Haskell wouldn't survive without the nice community, IMO
05:43:39 <ChongLi> there's just so much to learn
05:43:56 <ChongLi> coming to Haskell from an imperative language is a daunting task
05:44:05 <ChongLi> but it's totally worth it
05:44:09 <xpika> heres another option: is it easy to compile ghc .o files with gcc?
05:44:38 <yepguy> hi, is there a monad-ish type that allows you to bind monads of different types (e.g. maybe and either)?
05:44:42 <Walther> it could be fun to have some sociologists/psychologists/etc to look at the whys - if there's any correlation between the types of people that enjoy haskell and the type of people that are willing to explain / understand etc
05:45:04 <Walther> as opposed to some other programming communities where bruteforcing / making it "just work" and telling to rtfm are more common
05:45:09 <sergs> xpika: there's some C backend to ghc, not sure how to invoke it, but i think if you google "ghc c backend" it might work
05:45:13 <ChongLi> yepguy: there's monad transformers
05:45:21 <ChongLi> they embed one monad within another
05:45:55 <sergs> that's because to use haskell, you kinda have to be an enthusiast =P typically
05:46:09 <ChongLi> yeah
05:46:27 <ChongLi> I think Haskell tends to break down the people who refuse outside help
05:46:36 <tdammers> ChongLi: no, not really
05:46:55 <ChongLi> and people who got a lot of outside help as they were learning tend to remember that
05:46:59 <ChongLi> tdammers: no?
05:47:06 <Walther> but even then there should be some research to be done - how much being an enthusiast at $thing affects your ..well, social skills, when withing the $thing community
05:47:10 <tdammers> ChongLi: Haskellers tend to be people who value things (in programming) that many programmers haven't heard about
05:47:23 <tdammers> oh wait
05:47:25 <tdammers> I misread that
05:47:44 <tdammers> as "breaks down *to* the people who refuse outside help"
05:47:49 <tdammers> nm
05:47:51 <tdammers> carry on
05:47:57 <ChongLi> haha
05:48:02 <Walther> :D
05:48:03 <ChongLi> I don't have any evidence, of course
05:48:10 <yepguy> ChongLi: great... transformers seem to make sense
05:48:20 <ChongLi> how am I supposed to know how many people try out haskell, refuse to ask for help and then give up and move on?
05:48:36 <ChongLi> it just seems intuitive that that would be the case
05:49:04 <ChongLi> yepguy: yeah, they take a bit of getting used to
05:49:14 <ChongLi> but they are very handy
05:49:23 <yepguy> ChongLi: I would disagree with the help thing. The first year of my haskell learning was self/internally driven... But yes, help from irc is great now that I use it :P
05:50:02 <ChongLi> yepguy: or perhaps you've just got a dedicated personality
05:50:05 <merijn> xpika: That question is malformed, .o files are object files, they are already machine code and "compiling them with gcc" makes no sense
05:50:21 <ChongLi> and those who don't have moved to an "easier language" like python or ruby
05:50:41 <mirpa> newtype A = A { unwrapA :: B } ... is there some idiomatic name for "unwrapA"?
05:50:41 <merijn> xpika: Perhaps you wanted to link them (as the system linker is usually called via gcc), but then you'd have to worry about linking all the right haskell libraries too
05:50:42 <Walther> Or continue to use
05:50:51 <sergs> ChongLi: you can do some interesting things with python, they're just not forced upon you
05:51:05 <tdammers> ChongLi: Python isn't really "easier", it just has a shallower learning curve
05:51:07 <merijn> mirpa: runA or getA
05:51:20 <ChongLi> tdammers: yeah, that's why I quoted the words
05:51:35 <augur> i like unwrap, tbh
05:51:49 <ChongLi> it's easier at first but then becomes a nightmare when you have to maintain a large codebase
05:51:51 <sergs> ChongLi: python's itertools were inspired by haskell, and they have iterators/generators and infinite listy looking things. too bad python 3 is getting rid of reduce (fold) and map
05:51:56 <tdammers> yeah, heh... actually, I consider python more difficult than Haskell for anything but tiny one-off scripts
05:51:56 <Walther> tdammers: disagree; I'd say a ducktyped language is "easier" in terms of writing. Testing/pureness are obviously harder to achieve, but that's a different thing
05:51:59 <ChongLi> as seems to be the case with all dynamic languages
05:52:07 <mirpa> thanks - I've seen those in std lib...
05:52:14 <augur> for things like this, where it's just cloaking something in a newtype? run to me is more for.. i dont know, more computation-y things
05:52:34 <ChongLi> sergs: yeah, and there's a big schism in the community over python 3
05:52:39 <tdammers> Walther: Python is more permissive, for better or worse
05:52:40 <yepguy> ChongLi: Personally GoLang led me to Haskell.. And I've already played with most other languages enough to know the ins and outs... but from GoLang (easy to pickup as a C++ programmer by trad) I learned enough to know that stepping away from typical OO paterns might be a good thing
05:52:54 <tdammers> Walther: it's easier to write "anything" and have it do something
05:52:59 <ChongLi> yepguy: yeah
05:53:06 <tdammers> Walther: but writing *correct* code is much much harder in Python than in Haskell
05:53:12 <Walther> tdammers: Nod.
05:53:16 <sergs> one thing i'd rather do in python than haskell - write a graph database / lib
05:53:21 <ChongLi> my biggest complaint with OO is that code reuse seems really hard to come by
05:53:22 <Walther> But for a beginner, "correct" is not a priority
05:53:27 <Walther> to a degree, obv.
05:53:33 <tdammers> Walther: of course, sacrificing correctness for development speed is acceptable
05:53:36 <tdammers> sometimes
05:53:45 <benj_> I have spent enough time with languages that were optimised for beginners
05:54:22 <tdammers> but *especially* for a beginner, correctness should be a high priority
05:54:25 <ChongLi> yepguy: how do you like GoLang?
05:54:32 <sergs> correctness doesn't get taught by learning haskell...
05:54:40 <sergs> it's easier to achieve
05:54:42 <Walther> my personal opinion in my personal experience is that python is about *the* best language for an absolute beginner to programming, as it reeealllly lets you focus first on what the heck are "if"s and "while"s etc instead of stumbling at syntax (think having to learn the first steps of programming and its logic with Java or C, eugh)
05:54:47 <yepguy> I would never in my dreams search C++ code in github, copy and paste large chunks of code into my programs and expect to have something working within an hour... but with haskell i do it all the time
05:54:47 <sergs> throw someone into an ANSI C assignment
05:55:00 <sergs> then watch them grow respect for easy correctness
05:55:01 <ChongLi> Walther: what about scheme?
05:55:09 <yepguy> ChongLi: GoLang is much better for code reuse then C++
05:55:17 <HugoDaniel> is there a way to produce a total static binary with ghc ?
05:55:20 <Walther> ChongLi: was scheme the lisp java or the java lisp? I always confuse scheme and scala ;)
05:55:21 <yepguy> or many other languages for that matter
05:55:27 <benj_> I think it's sad we still consider while loops and mutable variables as the essential beginner introduction to programming
05:55:28 <tdammers> Walther: the downside with Python as a first language is that it muddles a lot of concepts and pushes people deeply into the imperative paradigm
05:55:41 <ChongLi> Walther: scheme as a lisp dates back to the 1980s
05:55:41 <randomclown> tdammers: lol
05:55:52 <HugoDaniel> if i do an ldd on a simple hello world i get 9 dependencies
05:55:52 <sergs> beginners don't understand paradigms for the most part anyway
05:55:54 <ChongLi> it introduced the world to lexical scoping and closures
05:56:00 <sergs> imperative is one of the easiest to understand
05:56:03 <sergs> it's just a recipe
05:56:08 <sergs> you read it from top to bottom
05:56:12 <randomclown> imperative is way simpler than this monad crap
05:56:17 <sergs> ]i think forcing java and OO at the beginning
05:56:25 <Walther> tdammers: Agreed. I'd still say that for people with *no* experience in programming, you *have* to first learn the imperative stuff as you first have to reeeealllly get the grasp of computers as deterministic machines
05:56:26 <sergs> while practical, in some sens4e
05:56:28 <sergs> is a sin
05:56:29 <merijn> I disagree that imperative is simpler
05:56:34 <HugoDaniel> me 2
05:56:35 <ChongLi> without lexical scoping and closures, you really don't have functional programming, IMO
05:56:41 <tdammers> Walther: but then, C would be a much better choice than Python
05:56:48 <tdammers> (in fact, I actually think it is)
05:56:54 <sergs> imperative is simpler for people who don't think in math
05:57:00 <merijn> tdammers: lol, C and deterministic.
05:57:08 <ChongLi> imperative is easier, but not simpler
05:57:10 <yepguy> ChongLi: C++ is a great language, but if u get the OO wrong at the start by the time u realize it ur in trouble... Golang fixes most of those problems with it's interface pattern... But Haskell goes one step further by things pure
05:57:10 <Walther> disagreed; in C you spend too much time with syntactic clutter that you can ignore when taking your baby steps in a ducktyped language like python
05:57:13 <merijn> tdammers: Well, C would be, but there are almost no true C programs
05:57:26 <yogurt_truck> "imperative" is simpler compared to what again?
05:57:28 <ChongLi> evaluation order is inherently more complex than pure values
05:57:28 <tdammers> C was my third programming language or so
05:57:28 <merijn> tdammers: Most of them are technically undefined behaviour and thus not deterministic :p
05:57:37 <sergs> ok
05:57:39 <sergs> imagine
05:57:43 <sergs> you've never programmed before
05:57:47 <sergs> what's easier
05:57:51 <sergs> an imperative recipe
05:57:58 <sergs> or a declarative set of equations
05:57:59 <ChongLi> yepguy: I hear a lot of people complaining about a lack of generics
05:58:06 <tdammers> sergs: neither, really
05:58:07 <yogurt_truck> sergs: the latter, by far
05:58:09 <Taneb> sergs, about the same, I'd say
05:58:16 <randomclown> sergs: receipe
05:58:18 <Walther> case in point: with Python, you don't necessarily have to even *know* ints and doubles and whatnot to get hacking at a number-guessing game that gives you 15 tries
05:58:21 <ChongLi> sergs: easier /= simpler
05:58:38 <sergs> what simplicity are we talking about
05:58:41 <ChongLi> don't make me go all *Rich Hickey* on you!
05:58:42 <sergs> the simplicity of what
05:58:58 <sergs> analyzing the language / giving proofs? beginners don't care about that
05:58:59 <tdammers> Walther: sure... but you'll hit types eventually, if only by accident, and then you'll be all baffled because stuff doesn't do what you think and you can't explain why
05:59:01 <ChongLi> sergs: Rich Hickey gave a talk called "simple made easy"
05:59:02 <Walther> Oh, also what sergs said; there are probably about three-four ~separate arguments going on
05:59:13 <ChongLi> he draws a very sharp distinction between the two words
05:59:14 <sergs> they just wanna know what the damn thing does
05:59:15 <merijn> ChongLi: I wouldn't even agree that one of the two is easier either
05:59:21 <Walther> tdammers: and IMHO that's a good point where to try some other language than python :P
05:59:35 <ChongLi> one of his main points is that nothing is easy in an absolute sense
05:59:42 <ChongLi> ease is relative to one's own experience
05:59:46 <tdammers> well, personally, I started with MS-DOS batch scripts, then Pascal, then C
05:59:51 <arnsholt> There probably isn't an optimal first language for all beginners. Teaching a 10-year old and first year compsci students with no previous experience require different approaches
05:59:52 <ChongLi> whereas simplicity *is* absolute
05:59:56 <tdammers> before I picked up C, stuff was just magic to me
06:00:10 <HugoDaniel> anyone knows how i can produce an executable with ghc that has no dynamic object dependencies ?
06:00:21 <sergs> well if you want absolute, pure simplicity, why not write everything in SK combinator calculus
06:00:27 <sergs> only 2 symbols, right?
06:00:34 <Walther> But yeah, I'd say python is a good first language as a) absolutely low learning curve in terms of syntax as there's no clutter on types etc b) you get to focus on "computers are deterministic and you can imperatively tell them what to do" which is something non-programmers sometimes actually have a hard time believing
06:00:34 <sergs> i'm not sure what you mean by simplicity
06:00:37 <ChongLi> that's a naive metric for measuring simplicity
06:00:51 <Hermit> HugoDaniel: -static ?
06:00:53 <Walther> c) you can focus on learning how whiles/ifs/etc work
06:01:00 <Walther> But yeah, just my opinions.
06:01:03 <sergs> does it satisfy the triangle inequality?
06:01:16 <ChongLi> simplicity is defined relative to complexity
06:01:17 <HugoDaniel> Hermit: -static still dumps about 9 dynamic objects in the final hello world binary :(
06:01:19 <randomclown> hey how do I put polymorphism restrictions on 'data' declarations
06:01:24 <yepguy> ChongLi: Yeah no generics in Go is a problem... but u can work around it
06:01:35 <randomclown> i.e. data Crap a = ..., where a is Num
06:01:46 <ChongLi> and complexity is a measure of how much things are twisted or braided together
06:01:56 <ChongLi> simple things stand alone
06:01:59 <yepguy> anyways, thanks for ur help... i'll go read up on monad transformers
06:02:10 <ChongLi> yepguy: okay, have fun :)
06:02:38 <merijn> randomclown: You don't
06:02:41 <yogurt_truck> Walther: you're assuming types are clutter, which they're not. this idea that talking about types is a no-no for beginners is totally unfounded (or based on experience/trauma with subpar type systems)
06:02:45 <ChongLi> http://www.infoq.com/presentations/Simple-Made-Easy
06:02:55 <merijn> randomclown: Because that almost 99.9% certainly doesn't do what you think it does
06:03:13 <Walther> yogurt_truck: yes, in my opinion I personally *do* assume that when taking your first steps at programming, types are clutter.
06:04:21 <Walther> I'm basing my opinions partly on my own experience (duh), having started with Python and having successfully written a handful of programs when relatively young and having no-one teach me
06:04:40 <HugoDaniel> http://lpaste.net/98033
06:05:04 <benj_> I wrote a bunch of python once and felt good about it too, but I believe it harmed rather than helped my understanding
06:05:04 <Walther> i wrote a handful of prime number algorithms on my own on the third grade, a couple number-guessing games, some inversed with a AI that guesses a number that the user decides, etc
06:05:07 <yogurt_truck> Walther: and you don't see how that basis is totally no valid for making general claims about types?
06:05:35 <yogurt_truck> "I got started without X, therefore X are clutter for beginners"
06:05:42 <Walther> yogurt_truck: Oh of course it's not valid for making general claims. It's also not my *only* basis for those claims, but yeah, of course I'm talking opinions here :P
06:06:00 <Walther> I thought I had prefixed my claims with "imho" enough :P
06:06:13 <sergs> well
06:06:22 <Walther> my claims are also based on what i've discussed with friends about their experiences in learning and with what languages they started with
06:06:25 <yogurt_truck> Walther: they are _all_ opinions.
06:06:26 <sergs> do people at least agree that no one should start with prolog
06:06:26 <Walther> haven't really read that many papers on it
06:06:30 <randomclown> How Data.Aeson deal with non homogenious arrays?
06:06:34 <identity> Walther: I can provide the perspective that I am a new CS student. I am somewhat more advanced than my fellow students when it comes to programming, however. ANyway, we started with python for our intro to programming class. People liked it. Up and running and doing stuff very fast
06:06:35 <Walther> yogurt_truck: Yep.
06:07:00 <yogurt_truck> Walther: everything that is uttered is an opinion. the discussion is whether one opinion is more intersubjectively valid than another one.
06:07:02 <Walther> identity: that has been the experience i've heard from many people that started with python as their first language
06:07:03 <identity> However, we just moved to java for OOP. The general consensus from my classmates many of which are completely new to programming is that they like java more
06:07:14 <tdammers> well, "up and running and doing stuff fast" is actually a good argument
06:07:17 <identity> precisely because of its static typing, even though it isn't very strict
06:07:17 <Walther> identity: I find that weird.
06:07:33 <yogurt_truck> Walther: also note that "no static typing" != "no types"
06:07:34 <sergs> i strongly dislike java lol
06:07:40 <Walther> yogurt_truck: Of course.
06:07:48 <identity> They liked being told where their errors were before they ran their programs, mostly
06:07:52 <sergs> python has the advantage of not requiring putting everything in an OO infrastructure
06:07:53 <tdammers> Java did beat some discipline into me in any case
06:08:01 <identity> I detest java, but I'm forced to do it
06:08:10 <HugoDaniel> like slavery ?
06:08:14 <sergs> learn C for discpline
06:08:19 <tdammers> python doesn't really *have* an OO infrastructure
06:08:22 <identity> HugoDaniel: For ects :P
06:08:27 <Walther> identity: Hmmmm. That could be a nice area for a study - there's probably two types of people, those that prefer the java way and the python way, that could be correlated with e.g. people who prefer TI-84 and who Nspire
06:08:30 <tdammers> just a bit of syntax sugar bolted onto half-assed objects
06:08:34 <HugoDaniel> identity: that doesn't answer the question :)
06:08:46 <tdammers> Walther: what if I dislike both?
06:08:50 <identity> HugoDaniel: Not quite like slavery, no. But it is a required class and I have to pass it.
06:08:50 <Walther> tdammers: hehe
06:09:01 <sergs> tdammers: true but why should we give objects any more respect? are you a smalltalk fan =P?
06:09:02 <identity> tdammers: OO in Python is a joke.
06:09:02 <yogurt_truck> identity: Java is very terrible in transcendental ways. Mainly it gives people a very wrong idea about what static typing can or cannot accomplish. I hope your teachers make that very clear.
06:09:09 <Walther> tdammers: I'm trying to make a more general thingy here, don't stick with the examples :P
06:09:12 <HugoDaniel> identity: then you are not forced, only doing it because you actually want it :)
06:09:18 <identity> yogurt_truck: I don't know -- I don't really go to lectures. I just want to be done with java.
06:09:34 <identity> HugoDaniel: I actually want to graduate, yes. So java is a step to my ultimate goal :)
06:09:36 <tdammers> sergs: idk, never tried smalltalk, but if we have to do the class-based dynamically-typed OO thing, I much prefer how Ruby does it
06:09:50 <yogurt_truck> identity: Plenty of people who learn Java are the ones you see later on twitter claiming all kinds of hilarious things in the vein of "static typing can't do X!"
06:09:51 <ChongLi> objects are not as simple as values
06:09:55 <sergs> tdammers: never tried ruby
06:09:58 <yogurt_truck> identity: I see
06:10:30 <sergs> objects are just tagged unions with some function pointers =P
06:10:34 <tdammers> sergs: haven't dived into it too deeply, but from what I've sampled so far, Ruby (as a language) is pretty much what Python or PHP should have been
06:10:37 <Walther> More like ...there could be a group of people who prefer to have their (for int i; i<100; i++) instead of for i in range(1,100) in a similar fashion as there are people who want to use TI84 and search each operand from a calculator-y combination of menus and buttons and there are people who like the ability to just type abs() with Nspire's keyboard
06:10:59 <randomclown> There is also a group of people that fast programs and predictable memory usage
06:11:04 <identity> Walther: Anyway, to respond to your question.. Well, I don't know if we can just say "there are two types of people" and that's it
06:11:09 <randomclown> that perfer*
06:11:13 <Walther> identity: Oh pffff of course not
06:11:17 <ChongLi> sergs: what makes them complex is that they have state
06:11:17 <tdammers> Walther: so basically, imperative vs. declarative
06:11:24 <sergs> identity: there are 10 types of people*
06:11:33 <Walther> sergs: ...and those who don't expect jokes in ternary
06:11:45 <randomclown> sergs: any kind of number system
06:11:48 <sergs> ChongLi: well tagged unions are mutable at the assembly level
06:11:53 <yogurt_truck> Walther: no people who are into FP in your classification then? :(
06:12:06 <Walther> tdammers: Yeah. It would be fun to have a sociological research done on what kind of people prefer imperative versus declarative
06:12:09 <identity> But the right now, I'm sitting with 3 guys, and one says that he would prefer java for bigger programs but that's mainly because it has an IDE
06:12:16 <identity> the other guys are saying they'd prefer python
06:12:20 <tdammers> Walther: I prefer whatever is appropriate
06:12:23 <sergs> randomclown: just using a well known cultural reference
06:12:37 <yogurt_truck> "(for int i; i<100; i++) instead of for i in range(1,100)" just different kinds of... loops!  D:
06:12:40 <identity> because they feel java is .. hard to understand and 'grasp', but they are not representative of my class it seems
06:12:49 <ChongLi> Walther: what's amusing to me is the anti-intellectual vibe I get from some people re: FP
06:12:53 <Walther> because *fuck* if I've met people who are so strongly imperative in their lives. They have also tended to be smartass dicks to me ;)
06:13:04 <tdammers> identity: for i in range() is kind of closer to a proper map though
06:13:16 <ChongLi> they complain about academics and claim that their language is for people who do real work
06:13:37 <tdammers> ChongLi: workman ethics are detrimental to good programmer performance
06:13:38 <yogurt_truck> ChongLi: yes. the so-called "pragmatic" people. it's utter nonsense.
06:13:42 <Walther> tdammers: Oh of course actual uses is a different discussion. I'm talking about people now; and how it'd be damn interesting to have studies made on whether you could actually group people's behaviour also based on roughly programming paradigms
06:13:55 <ChongLi> and so I'd imagine it would be pretty hard to separate that effect
06:14:03 <ChongLi> in any sort of experiment
06:14:06 <tdammers> Walther: I maintain that a good programmer must be capable of using either paradigm efficiently
06:14:06 <sergs> just teach everyone lambda calculus at an early age
06:14:14 <ChongLi> or control for it, I should say
06:14:19 <Walther> tdammers: Of course. Again, different discussion :P
06:14:54 <ChongLi> I was talking to my friend the other day about teaching monoids to kids in elementary school
06:15:03 * yogurt_truck is _so_ pragmatic he uses a get-shit-done pragmatic dynamic untyped language that allows him to ship `undefinedThing.NonExistingMethod()` to production and stay there until someone gets hurt by it. So practical!
06:15:07 <ChongLi> teaching them the generality
06:15:09 <sergs> ChongLi: have you ever heard of the "new math" fiasco?
06:15:16 <ChongLi> sergs: I have not
06:15:21 <Walther> You know those people who start telling a story about something and then stop for thinking at which exact date it was on instead of continuing telling the story; to be able to tell their experience imperatively and precisely - compared to people who just try and declaratively talk about the experience they had and convey the idea and let it more up to interpretation
06:15:21 <fizbin> I was about to ask that, sergs.
06:15:58 <tdammers> Walther: honestly, I don't think I have ever met such a person
06:16:00 <sergs> ChongLi: in the US, to compete with soviets, they started teaching kids abstract algebra concepts, the "easy ones", in elementary school
06:16:02 <Walther> I may be drawing bad examples here becase I'm definitely more of a declarative guy. I may not think my examples through to be completely precise, i just try to convey the idea behind more effectively
06:16:17 <fizbin> ChongLi: Basically, it was an attempt in the 1960s to try to teach elementary kids really abstract math concepts.
06:16:28 <sergs> ChongLi: it failed so miserably, that it raised a generation of adults who couldn't do simple math and hated the entire subject
06:16:36 <ChongLi> ahhh
06:16:43 <ChongLi> well, what's the problem though?
06:16:49 <fizbin> It... was a disaster. Basically killed several years of general math ed.
06:16:59 <ChongLi> is it abstract math or is it the educational system in general?
06:17:00 <yogurt_truck> yeah, there's nothing like formal education for scaring people away from math
06:17:02 <sergs> little kids need imperative recipes drilled into their brains
06:17:09 <ChongLi> I'm inclined to lean towards the latter
06:17:13 <sergs> they need hardware optimizations wired early
06:17:16 <tdammers> a similar thing happened in europe btw
06:17:24 <tdammers> a decade or so later, but still
06:17:28 <sergs> before they can be fast enough to play with examples and see patterns
06:17:34 <ChongLi> I'm the opposite
06:17:34 <yogurt_truck> the education system is the number one reason people hate math. it's nothing to do with math.
06:17:44 <Walther> ^
06:17:46 <tdammers> elementary schools were supposed to introduce set theory and combinatorics and that kind of stuff to first graders
06:17:50 <fizbin> The generally accepted explanation for why it didn't work is two-fold: 1) drilling recipes, it turns out, has its place, and 2) much more math is learned at home than was thought.
06:17:52 <bezirg> hi, i defined an existential type as data Runnable = forall a . MkRunnable (IO a) but when I try to pattern-match to take out the value (MkRunnable io <- job) it does not type check with error: Couldn't match type `a0' with `a'
06:17:52 <bezirg>   because type variable `a' would escape its scope
06:17:52 <bezirg> This (rigid, skolem) type variable is bound by
06:17:52 <bezirg>  
06:17:52 <ChongLi> I think kids have wayy too much "drilling"
06:17:56 <ChongLi> and not enough learning
06:18:18 <yogurt_truck> ChongLi: specially not enough learning _culture_
06:18:26 <sergs> it depends on the country and the school
06:18:28 <yogurt_truck> you have to teach people to want to learn, too
06:18:39 <sergs> i like some of the changes they're making now
06:18:40 <tdammers> I think the reason stuff failed is because you can't really learn abstractions in a vacuum - you need to be familiar with the stuff you're abstracting over in the first place
06:18:45 <yogurt_truck> not just "you have to go through this shit so that you can get a job when you grow up"
06:18:50 <identity> I just know that since I started using haskell almost exclusively, not having a strict type system doesn't just feel silly to me but like.. directly strange. like counter-intuitive
06:18:52 <fizbin> The second part (that kids actually learn math from their parents, not really from school) is in my mind the big issue: with new math, many parents could no longer help kids with their homework.
06:18:54 <ChongLi> I would like to see more research into Sudbury Schools
06:18:55 <tdammers> otherwise the abstractions are just empty formal rules with no meaning
06:18:57 <sergs> they're emphasizing the ability to form your own opinion based on critical thinking
06:18:57 <identity> I feel like it should be everywhere
06:19:00 <yogurt_truck> you have to teach the importance of learning
06:19:15 <Walther> tdammers: but for example taking this discussion, you have seemed to cling to my specific examples (imperative) instead of trying to understand what I'm saying via providing multiple examples and trying to draw my meaning as a set of those (declarative)
06:19:17 <identity> First time I ran a python program and got a runtime error that should've been detected at 'compile time' I was just baffled
06:19:26 <Walther> Not saying it is bad or wrong, just different
06:19:27 <ChongLi> heck, even the word "teach" is too strong for me
06:19:35 <ChongLi> it sounds too much like "indoctrinate"
06:19:40 <FliPPeh> identity: Like mistyped function or variable names
06:19:46 <identity> FliPPeh: yeah
06:19:50 <FliPPeh> identity: I'm dealing with this bullshit with a medium sized python project right now
06:19:51 <sergs> well, most people would just watch TV all day / not care
06:19:56 <FliPPeh> It completely spoiled the language for me
06:19:57 <ChongLi> I'm helping my friend learn Haskell
06:19:58 <sergs> there's necessary coercion
06:20:00 <FliPPeh> I used to like python
06:20:00 <identity> FliPPeh: Hah, ow. Does it use "OOP"?
06:20:03 <tdammers> Walther: I understand that you're suspecting a correlation between certain approaches to programming and certain personality traits
06:20:09 <yogurt_truck> ChongLi: exactly. when I say "you have to teach them" I really want to express "you have to help them discover things" or something like that
06:20:10 <lieven_> I doubt that the home learning was the big deal. I was educated under new math in Belgium and it mostly went just fine. but we have the rule that in order to teach a subject you need an actual Master's degree in that subject. no <foo> Ed degrees.
06:20:11 <FliPPeh> identity: Sure
06:20:16 <ChongLi> and by no means would I describe what I'm doing as "teaching" (though I may have used the word in the past)
06:20:28 <Walther> tdammers: Nod.
06:20:28 <tdammers> Walther: but from your examples, I consider your hypothesis a bit far-fetched
06:20:42 <fizbin> There was an ACM article about a decade ago that argued that the persistent discrepancy in the US in math scores between "good" neighborhoods and "bad" ones was because ~ no one learned math in school, but rather from their parents.
06:20:43 <Walther> tdammers: Oh, could be. It would just be interesting to have some studies on this :P
06:20:47 <sergs> ChongLi: it doesn't work for everyone - some people really need to be handheld
06:20:50 <ChongLi> he's learning Haskell on his own; but we meet up a lot and he asks questions and we explore what he's trying to accomplish
06:20:53 <fizbin> At least at the elementary school level.
06:20:53 <identity> FliPPeh: I just remember thinking my eyes must've been playing tricks on me when I saw that, in Python, you can do something like foo = Foo().. foo.newMember = 3 ..
06:21:09 <Walther> to have more definitive answers than babbling at an IRC channel :P
06:21:09 <sergs> ChongLi: or they don't grow up in an environment conducive to the right way
06:21:12 <identity> that is, add all the variables you want to an object
06:21:12 <ChongLi> sergs: but is it in their nature to be like that? or is it simply that they were raised that way
06:21:14 <identity> randomly
06:21:15 <identity> spontaneously
06:21:37 <ChongLi> sergs: I think we ought to seriously consider the possibility that our entire educational method is broken
06:21:39 <FliPPeh> identity: I have wasted HOURS hunting down missing imports after breaking up a module into smaller modules because you don't notice them missing after you run a line that's using that import
06:21:50 <ChongLi> and leads to bored, burned-out teenagers
06:21:52 <FliPPeh> And I still find mistyped variables and functions in rarely used code paths
06:22:21 <sergs> there's no solution that works for everyone
06:22:21 <fizbin> FliPPeh: That's what pyflakes is for.
06:22:22 <yogurt_truck> ChongLi: I think "teaching" should be done in a way that drives the student to "discover" the "next step" of what they're doing at a particular point in time. The best university lectures and books and other teaching material I've used has been the one that makes my mind "guess the next thing", so to speak
06:22:22 <sergs> and not enough resources to personalize education
06:22:25 <ChongLi> you mentioned that the "new math" fiasco ruined an entire generation for math
06:22:37 <fizbin> That'
06:22:39 <tdammers> I think "teaching" should restrict itself to supporting the student's innate learning urge and providing a fruitful learning environment
06:22:39 <yogurt_truck> sometime my guess is very wrong, and that itself is very helpful
06:22:40 <ChongLi> sergs: sure there are
06:22:41 <FliPPeh> fizbin: They should advertise that better, I also spent quite some time looking for a program that finds such errors
06:23:01 <fizbin> That's probably an exaggeration (that it *ruined* a whole generation)
06:23:07 <ChongLi> you just need to do away with the assumption that kids need a teacher to tell them everything
06:23:25 <ChongLi> it's a bottleneck
06:23:26 <FliPPeh> Also, duck typing
06:23:26 <sergs> ChongLi: all i know, is every country that's extremely successful with their education program is about 10X smaller than the USA
06:23:39 <yogurt_truck> ("guess" is the wrong word here, but hopefully you get what I mean)
06:23:47 <fizbin> However, one effect is that it essentially killed the idea that professional mathematicians should try to right math educational policy.
06:24:01 <ChongLi> sergs: looking at the whole of the USA is not very useful anyway
06:24:10 <sergs> ChongLi: and i think it's more than coincidence. a lot of US problems stem from the sheer size and diversity of the place, as well as political fragmentation
06:24:14 <ChongLi> since each state has its own educational policies
06:24:15 <yogurt_truck> sergs: doesn't the US have big difference state-wise with regards to this? or is the whole education program a federal-level imposed thing?
06:24:32 <sergs> yogurt_truck: there are both components in action
06:24:34 <fizbin> sergs: The successful countries also do crazy things like give kids growing up in poor areas *more* teachers.
06:24:47 <fizbin> Which isn't something you could do in the US.
06:24:54 <ChongLi> if you get a chance, try reading about Sudbury Schools
06:24:56 <sergs> fizbin: get the republican congress to do that and you get a nobel peace prize
06:25:05 <ChongLi> I'm not saying they are a silver bullet for education
06:25:14 <ChongLi> but I think they're a pretty interesting idea
06:25:46 <fizbin> In the US, if you're growing up poor, you must be in classrooms with higher student/teacher ratios than if you grow up rich. It is not politically possible for it to be otherwise.
06:26:24 <sergs> ChongLi: those look fascinating, but i think they require really motivated students
06:26:35 <ChongLi> children are naturally motivated
06:26:47 <ChongLi> they do tons of stuff in their play
06:26:51 <sergs> not if they have a terrible home environment
06:27:02 <sergs> that needs to be fixed first
06:27:09 <ChongLi> that's a chicken-and-egg problem
06:27:18 <sergs> perhaps
06:27:20 <fizbin> Which the US has in spades, and doesn't particularly care about fixing.
06:27:21 <Dodek> there's a school in massechusetts which has no required academic activities and no expectations from students as for the completion. the graduates don't do worse in college than their peers drilled in regular schools
06:27:42 <ChongLi> Dodek: yeah, it's probably a Sudbury School
06:27:45 <sergs> there are plenty of fascinating systems in tiny parts of the country that do well
06:27:45 <yogurt_truck> sergs: looking at the US republicans from my non-american POV is funny. Like, they are _right_ about too much govt spending being awful (this is the case in every country). But _where_ they propose to cut spending is always _dumbfounding_.
06:27:50 <Dodek> if this doesn't prove that schooling system is broken as is, then i'm not sure what would.
06:27:54 <sergs> look at the preuss school at UCSD
06:28:03 <sergs> high school for low-income students
06:28:14 <sergs> gets a 96% 4 year college acceptance rate
06:28:39 <sergs> one of the top high schools in the country
06:28:40 <ChongLi> the other aspect to our educational system that's heavily broken is how much it's geared for producing employees
06:28:58 <ChongLi> we are inevitably sliding towards a post-labour world
06:29:01 <Dodek> us college acceptance rate is not really good metric when talking about schooling system
06:29:11 <Dodek> because of points awarded for background, diversity etc
06:29:23 <ChongLi> the demand for labour is falling so rapidly
06:29:45 <sergs> google's buying all the robotics firms
06:29:53 <ChongLi> and people are having to get more and more educational certification just to keep up
06:30:32 <ChongLi> and we're building an enormous student loan bubble to try and maintain the status quo
06:30:43 <Walther> Hmmmm. How do I have a function that returns/runs one function if run without parameters and another if there is an argument?
06:31:01 <sergs> Walther: partial application?
06:31:15 <sergs> Walther: what are you looking for specifically
06:31:15 <ChongLi> Walther: that's basically all functions in Haskell :)
06:31:29 <ChongLi> :t (+)
06:31:30 <lambdabot> Num a => a -> a -> a
06:31:35 <ChongLi> :t (+ 3)
06:31:36 <lambdabot> Num a => a -> a
06:31:44 <fizbin> Walther: I don't think you can necessarily do what you think you want.
06:32:11 <Walther> namely, i'm creating a spawner function that has to operate in one way on the first run and then take the "best" of the spawned [Char]s and spawn mutated/evolved kids based off the selected one
06:32:16 <Walther> an evolution function basically.
06:32:17 <fizbin> You need to try to think about what the type of the function will be.
06:32:21 <sergs> Walther: pattern match and throw out a lambda function
06:32:22 <Dodek> ChongLi: if the college prices weren't so inflated, it wouldn't be so bad
06:32:31 <sergs> Walther: as long as the types are the same, no problem
06:32:40 <Walther> well, it could make sense to have the first run imperatively though and then use the spawner separately on the rest of the runs
06:32:54 <ChongLi> Dodek: college prices are the inevitable result of demand
06:33:17 <ChongLi> demand is through the roof because employers can be pickier with their requirements
06:33:20 <fizbin> Ah! Well, then, it sounds like you want a function that always takes a list of "kids from the last generation", and do one thing for the empty list and another for non-empty lists.
06:33:39 <ChongLi> I even hear about places requiring a *degree* to work at mcdonalds
06:33:43 <Dodek> ChongLi: more like, result of high availability of students loans and low risk for lenders
06:33:48 <Walther> fizbin: Something along those lines, yes.
06:34:00 <ChongLi> Walther: why not have 2 different functions?
06:34:06 <Walther> ChongLi: is what i'm considering now.
06:34:18 <ChongLi> :t sort
06:34:19 <lambdabot> Ord a => [a] -> [a]
06:34:21 <ChongLi> :t sortBy
06:34:22 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
06:34:27 <Dodek> ChongLi: i mean, if people couldn't afford college, they would do it
06:34:43 <ChongLi> sort is just sortBy with a default comparison function already supplied
06:34:59 <Dodek> ChongLi: but if they can get loan for arbitrarily crazy amount of money, it's in school's best interest to raise prices up to the ceiling
06:35:11 <ChongLi> Dodek: yeah, hence the bubble
06:35:30 <sergs> Dodek: the college loan / price system is a well known circle of abuse / exploitation
06:35:40 <sergs> Dodek: at least in the US
06:35:42 <ChongLi> but if the government just said "forget it, we're taking away all the student loan requirements"
06:35:51 <sergs> and the gov't is part of it
06:35:54 <fizbin> Also, the traditional block against banks making ridiculous loans (that they'll be discharged in bankruptcy) is no longer there.
06:36:03 <ChongLi> then people would complain that the government is favouring the rich
06:36:10 <fizbin> That is, many loans are gov
06:36:25 <sergs> alright guys
06:36:27 <ChongLi> this problem is known as adverse selection
06:36:28 <Dodek> sergs: yep, that's totally broken.
06:36:34 <sergs> i gotta go buy a parking permit
06:36:39 <sergs> and start classes
06:36:40 <ChongLi> and adverse selection leads to control fraud
06:36:44 <sergs> gnight / morning?
06:36:48 <ChongLi> good morning!
06:36:53 <fizbin> ... many loans are gov't guaranteed and those that aren't are no longer dischargable in bankruptcy.
06:36:56 <sergs> who here is on the west coast?
06:37:01 <sergs> i'm at UCSD
06:37:14 <ChongLi> I am in the east
06:37:19 <ChongLi> Ontario, Canada
06:37:21 <yepguy> East Coast....... Australia
06:37:25 <ChongLi> haha
06:37:32 <sergs> nice, good spread
06:37:33 <sergs> alright
06:37:44 <sergs> good morning and i'll be on later, maybe
06:37:47 <ChongLi> I need to make some food
06:37:47 <sergs> bye
06:37:50 <ChongLi> bye!
06:37:57 <sergs> nice chatting
06:38:00 <ChongLi> yeah
06:39:35 <Dodek> but seriously, when i hear about $30k tuition per year (for non-residents) for good but not great school, and compare it to my university in my country, my mind is totally blown
06:39:50 <fizbin> Relevant to why new math failed: http://www.ams.org/notices/200502/fea-kenschaft.pdf
06:42:09 <yepguy> fizbin - new math it's easy http://www.youtube.com/watch?v=SXx2VVSWDMo
06:42:36 <fizbin> Yeah, I love Tom Lehrer
06:42:50 <Dodek> sometimes i wish i'd been born in the us, to have less troubles with visas and shit, but then i realize that i'd be poor and uneducated had that happened
06:45:58 <ndeine> Dodek: scholarships can alleviate some of that
06:46:29 <Dodek> how much is some? and how many people do actually get scholarship?
06:48:37 <ndeine> Dodek: Not much. Depends on income and merit, but sometimes just income. E.g. on a ~$40,000/year school, $20,000 need-based scholarships could be awarded to someone who is arbitrarily poor.
06:49:35 <merijn> This discussion is a bit off-topic, might wanna continue in #haskell-blah
06:50:08 <ndeine> merijn: sure, no more here.
06:55:41 <loans> another day, another false alarm highlight
07:00:37 <elderK> Hey guys. I'm not a Haskeller but I'm curious as to how you would approach a particular problem.
07:01:07 <elderK> I'm writing a simulator for the Motorola 68K in Scheme. However, I like to write things in as pure of a fashion as I can.
07:01:19 <elderK> Anyway.
07:01:44 <elderK> I'll need to have an emulated memory, which I'd like to avoid mutating. Problem is: memory can be large. Naive way would be to create a modified copy.
07:02:06 <elderK> Or perhaps represent the memory as a tree, maybe zip it. Not sure - only ideas so far.
07:02:06 <sheenobu> elderK: I can't even begin to help, but have it online?
07:02:14 <Cale> Use an immutable map structure?
07:02:27 <elderK> immutable map structure? :)
07:02:40 <elderK> Where the key's an address and it sends you to a byte?
07:02:50 <elderK> Depends on how the immutalbe map's implemented?
07:02:52 <Cale> Well, usually those are trees internally
07:02:58 <elderK> :) Keep in mind, I'll have to implement whatever myself.
07:03:38 <elderK> My goals are that it be reasonably efficient. It doesn't have to be lightning fast :) It's a simulator, not an emulator for running games or the like.
07:03:47 <elderK> so, aye. an immutable map sounds like a great idea.
07:03:57 <fizbin> elderK: I'm not familiar with the 68K. Is its memory access naturally broken into "pages"?
07:04:01 <elderK> with the ``values'' being perhaps not a byte but a small block.
07:04:10 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-IntMap-Strict.html is the sort of datastructure I'd use if I were doing it in Haskell, but I have the advantage that this module already exists.
07:04:15 <fizbin> If so, maybe an immutable map of memory pages?
07:04:17 <elderK> The 68k raw, no.
07:04:25 <elderK> 68010 onwards, yes, if virtual memory is enabled.
07:04:28 <elderK> (paged memory)
07:04:37 <elderK> the page size is configurable, however.
07:04:41 <elderK> but for emulation, I could make it whatever.
07:04:50 <elderK> Anyway.
07:05:35 <elderK> Thinking of it, I thought the real balance here is like... how many entries on whatever structure do I have, mapping addresses to some memory vs. how much copying is done when a memory / memory block is altered.
07:05:48 <elderK> Thanks for the link Cale.
07:06:26 <elderK> What would you store in that map, though? Would each key be a single byte address?
07:06:36 <rtpg> Has anybody ever tried using the type system to encode physical units? Like meters and seconds
07:06:37 <elderK> or would each key be aligned to some boundary? and each value be some block?
07:06:45 <randomclown> What's the current solution to record syntax namespace pollution>
07:07:07 <randomclown> how many years has it been and it's still stuffed
07:07:21 <Cale> elderK: If I wasn't too concerned about performance, whatever the instructions act on, probably.
07:07:25 <merijn> rtpg: Yes, I forgot the package name, though
07:07:50 <Cale> randomclown: Namespace pollution?
07:07:51 <elderK> Cale: It works on bytes, 16bit and 32bit words.
07:08:00 <RevJohnnyHealey> Does the 68K have word aligned memory? If so, it might make sense to use a map of words instead of a map of bytes.
07:08:01 <elderK> so, bytes really.
07:08:10 <elderK> RevJohnnyHealey: Yeah, that's what I figured.
07:08:17 <elderK> It does have word aligned memory.
07:08:25 <randomclown> data A = { x :: Int }, data B = { x :: String }, mutliple declarations for 'x' found
07:08:28 <rtpg> ok, I'll look around for it then
07:08:30 <randomclown> Cale;
07:08:44 <fizbin> randomclown: So far as I know, the current solution is to use ugly names like _mystructureBar :: Int and then use something in template haskell like lens's makeFields to give type classes for field access.
07:08:47 <Cale> elderK: Yeah, it depends I guess on which of those cases you think is most common. Doing bitwise operations on 32 bit words whenever a smaller size operation happens wouldn't be so bad either.
07:08:53 <elderK> I figured... like. You'd still have SOME copying. Like, say yo umutate a byte in a word. You'd have to copy the other bytes in that word.
07:08:55 <elderK> BUT
07:08:57 <elderK> You'd want to MINIMIZE the copying.
07:09:02 <randomclown> fizbin: gross
07:09:17 <Cale> randomclown: Well, you're aware that you're defining a field extraction function there?
07:09:34 <Cale> data A = A { x :: Int } is syntax sugar for
07:09:38 <Cale> data A = A Int
07:09:47 <Cale> x (A t) = t
07:10:05 <elderK> Also, patricia trees are awesome.
07:10:05 <elderK> :)
07:10:21 <randomclown> Cale: you need the same name sometimes
07:10:23 <rtpg> merijn, Dimensional seems to be a non-toy implementation of this, there's a wiki talk page on it (Physical Units)
07:10:46 <randomclown> even if I define extraction functiions, I still can't overload them
07:10:54 <Cale> Use a type class.
07:11:01 <randomclown> haha
07:11:07 <Cale> class HasX t where
07:11:08 <merijn> rtpg: Could be that's it, I just remember it coming up in the past :)
07:11:13 <Cale>   x :: t -> Int
07:11:32 <Cale> instance HasX A where x (A t) = t
07:11:34 <Cale> etc.
07:11:53 <randomclown> then reinvent subtype polymorphism while I'm at it
07:11:59 <Cale> If you *really* need them to have the same name
07:12:07 <Cale> then that implies you need polymorphism
07:12:11 <Cale> type classes provide that
07:12:15 <randomclown> I like code quality
07:12:24 <randomclown> I like having not gibberish names
07:12:54 <randomclown> And the typeclass only make sense if the data types are related
07:12:57 <randomclown> which they are not
07:13:05 <Cale> Usually what I do is just to prefix the names of the fields with the names of the types, or some abbreviation of that.
07:13:18 <Cale> If they're not related, then you shouldn't be naming them the same thing
07:13:33 <randomclown> JSON-RPC protocl implementation
07:13:57 <randomclown> data Request = Request { id :: lah ..., method :: blah }
07:14:25 <randomclown> data Response = Response { id :: blah , ..., method :: blah, params :: blah }
07:14:40 <Cale> data Request = Request { requestId :: blah, requestMethod :: blah, ...}
07:14:48 <Cale> similarly for response
07:15:57 <FunesTheAmnesiou> Hello fellow humans. Is anyone familiar with SublimeHaskell on OSX? I'm having trouble setting it up.
07:16:07 <randomclown> Cale: I thought there was a solution proposed
07:16:18 <randomclown> when is it going to be in HEAD?
07:16:37 <Cale> randomclown: If you define the Request and Response types in separate modules, you can name their fields the same thing
07:16:59 <randomclown> Cale: I'm more interested in the SPJ's solution now
07:17:06 <merijn> randomclown: SPJ and a GSoC student were starting on it this summer
07:17:11 <merijn> randomclown: So not anytime soon
07:17:26 <merijn> Well, last summer, I guess.
07:17:31 <mello_> \quit
07:17:32 <randomclown> so it's done?
07:17:42 <merijn> randomclown: No, I said started
07:17:44 <Cale> (But honestly, I don't want to have to deal with code where people name all their unrelated things the same way)
07:17:45 <boom583> Is reverse fast?
07:17:51 <randomclown> Oh it's summer in Australia right now
07:17:54 <merijn> randomclown: This stuff takes a lot of engineering work
07:18:06 <Cale> boom583: It is as fast as possible, but of course, that's linear time.
07:18:10 <maurer> boom583: Fast in what sense? It's O(n) if you force the entire list, just like any reversing function
07:18:13 <merijn> randomclown: And even more design work to make it play well with the rest of haskell
07:18:17 <maurer> actually, O(n) period :P
07:18:27 <maurer> boom583: If you want fast reversing, look at Data.Sequence
07:18:31 <boom583> Cale, maurer, ok, so if I want to construct a long list using ++, I'm better off using : and then reversing it?
07:18:47 <merijn> boom583: Yes, that's a common approach
07:18:47 <Cale> boom583: Or you could use the standard trick for fast concatenation
07:19:04 <boom583> merijn: ok
07:19:05 <randomclown> merijn: does it also solve algerbric data type namespace pollution?
07:19:08 <boom583> Cale, what trick?
07:19:15 <Cale> which is to replace lists of type [a] with functions [a] -> [a] that add elements to the beginning of another list, and replace (++) with (.)
07:19:17 <randomclown> data X = A, data Y = A?
07:19:22 <bezirg> I have a question: I have a forked thread and feed it particular jobs to run, the forked thread received the jobs through a `Chan` . Sometimes I want to identify if a request is completed. Does it make sense to create on each new job a newIORef () and pass it together to the Chan? Then I will check for equality if this IORef is in the Chan and if not that means it is complete. Am I correct with this or is it a better way?
07:19:26 <Cale> and [] with id, and [x] with (x:)
07:19:27 <merijn> randomclown: No clue
07:19:54 <Cale> Since (.) is constant time, while xs ++ ys takes O(length xs) time, this can improve the time complexity of the construction.
07:20:04 <Cale> You can apply the resulting function to an empty list at the end.
07:20:07 <merijn> bezirg: Well, that'd certainly work (although you may wanna use an MVar if you plan to block until a task finishes)
07:20:13 <Cale> For example, consider
07:20:14 <boom583> Cale, what's (.) ?
07:20:19 <Cale> Function composition
07:20:22 <boom583> ah of course
07:20:26 <boom583> forgot
07:20:36 <fizbin> :t (.)
07:20:37 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:20:38 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
07:20:51 <Cale> You might have an inorder traversal which looks like:
07:20:52 <fizbin> :t (,)
07:20:53 <lambdabot> a -> b -> (a, b)
07:20:55 <Cale> inorder Tip = []
07:21:01 * hackagebot hemokit 0.5.1 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.5.1 (NiklasHambuechen)
07:21:07 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
07:21:29 <bezirg> merijn: thx
07:21:34 <Cale> This has the problem that the complexity is quadratic. The worst case is a leftward leaning tree
07:21:53 <Cale> So, to fix it, we can instead build a function:
07:21:57 <Cale> inorder' Tip = id
07:22:10 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
07:22:29 <Cale> and then to recover an equivalent to the original function, apply the result to an empty list:
07:22:34 <Cale> inorder t = inorder' t []
07:22:45 <Cale> Now it's linear time
07:23:26 <boom583> Cale, can you show an example of that function approach to replace [1]++[2]++[3]++ ... ++ [100] ?
07:23:56 <Cale> Well, that literal code?
07:24:03 <randomclown> boom583: generate it backwards and prepend?
07:24:07 <Cale> You'd be better off just writing [1..100]
07:24:20 <boom583> yes but just as an example
07:24:26 <boom583> Cale: so i can see your method
07:24:31 <boom583> the function method, in action
07:24:36 <Cale> (1:) . (2:) . ... . (100:)
07:24:59 <Cale> (It won't be any faster in this case, because (++) associates to the right)
07:25:16 <boom583> ok
07:25:26 <tvynr> I'm a bit confused about constraints on GADTs.  Can anyone tell me why "Num a" is necessary on line 8?  I would've thought it was implied by the type "Foo a".
07:25:29 <tvynr> http://lpaste.net/8252228447456198656
07:25:33 <Cale> But it would be much faster than (...(([1] ++ [2]) ++ [3]) ++ ... ) ++ [100]
07:25:45 <Cale> (no matter which way you associated it)
07:26:30 <boom583> Cale: why is this slower?
07:26:33 <Cale> tvynr: Because you're not unpacking the Foo constructor
07:26:50 <Cale> boom583: Well, look at how (++) does its job:
07:26:53 <Cale> @src (++)
07:26:53 <lambdabot> []     ++ ys = ys
07:26:53 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:26:53 <lambdabot> -- OR
07:26:53 <lambdabot> xs ++ ys = foldr (:) ys xs
07:27:10 <Cale> (specifically let's look at the first version there, they're equivalent in performance)
07:27:43 <Cale> You can see that for each element of the list on the left, a reduction step will be required before all the occurrences of (++) are eliminated from the result
07:28:04 <tvynr> Cale: The "foo" method doesn't do the necessary unpacking to propagate the constraint?
07:28:59 <Cale> tvynr: Imagine if there were more constructors of the GADT, some of which didn't have Num constraints
07:29:54 <tvynr> Cale: That's an excellent way of putting it; thank you.  And I'm guessing that there's no way to constrain all constructors on a GADT?
07:30:32 <Cale> tvynr: The Foo data constructor actually carries around inside it (just like an extra hidden field) the dictionary of operations for Num a
07:30:56 <Cale> When you pattern match, that dictionary is extracted from the value, and can be used to fulfill Num a constraints
07:31:39 <Cale> Even if all the constructors were constrained, if you defined a value of type Foo a like  x :: Foo a; x = x
07:31:56 <Cale> then there wouldn't really be a Num dictionary in there that you could pull out
07:33:38 <Cale> If this did let me discharge Num constraints on a, I could pass x as an additional parameter to something which needed an instance of Num String :)
07:34:35 <Cale> and then even though there is no such instance around, somehow that constraint would be eliminated. That problem is solved by requiring the pattern match.
07:35:36 <Cale> boom583: anyway...
07:35:45 <Cale> boom583: So, if you have something like
07:35:56 <Cale> f 0 = []
07:36:05 <Cale> f n = f (n-1) ++ [n]
07:36:35 <Cale> boom583: and we apply f to 100
07:36:48 <Cale> then it'll evaluate to f 99 ++ [100]
07:37:00 <Cale> We know that f 99 will have 99 elements by construction in the end
07:37:01 <McManiaC> if i have a tchan for debugging output, can i rely on haskells lazyness that it wont actually fill up the chan with unused messages if i never read from it?
07:37:10 <Cale> So that'll require ~99 steps just there
07:37:28 <Cale> but then computing f 99 will similarly require a (++) which takes about 98 steps
07:37:29 <Cale> and so on
07:37:49 <tvynr> Cale: Thanks muchly for your help.  It would seem to me that it wouldn't be unsound to add a (Num a) constraint to the Foo type itself.  You'd be able to write something that allowed you to satisfy Num String, but you'd have to have a Foo String in order to do that.  You'd never be able to construct such a witness, so you have a guarantee that that function could never be called.  Though I guess that the argument is that most people don't w
07:37:49 <tvynr> ant that behavior.  :)
07:38:00 <Cale> McManiaC: No, it absolutely will fill up the channel
07:38:00 <tvynr> Cale: Thanks again for the tutorial.  It helped a lot.
07:38:27 <Cale> tvynr: You *can* construct a Foo String though
07:38:28 <McManiaC> Cale: thought so
07:38:40 <Cale> tvynr: Because it's not a kind error to write that, and undefined has every type.
07:38:48 <Cale> tvynr: Or you could write
07:38:52 <Cale> fooString :: Foo String
07:38:55 <Cale> fooString = fooString
07:39:07 <Cale> Make it an infinite loop :)
07:40:45 <ChongLi> Cale: and this is why we can't have Nats :(
07:43:21 <tvynr> Cale: Interesting.  Thanks for the help.  :)
07:43:39 <tvynr> Cale: (It took me a while to fully process your explanation.)
07:49:55 <FliPPeh> infinite loops in Haskell?
07:50:01 <FliPPeh> We're dealing with recursions here!
07:50:54 <boom583> Cale: i still don't get why  [1] ++ ( [2]++[3] )  is faster than ( [1]++[2] ) ++ [3]
07:51:07 <boom583> you add two. then add two. whats the difference
07:51:24 <FliPPeh> I'm more of a fan of 1:2:3:[]
07:51:32 <boom583> this is just an exam
07:51:33 <boom583> ple
07:51:37 <Cale> @src (++)
07:51:38 <lambdabot> []     ++ ys = ys
07:51:38 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
07:51:38 <lambdabot> -- OR
07:51:38 <lambdabot> xs ++ ys = foldr (:) ys xs
07:52:07 <Cale> [1] ++ ( [2]++[3] ) --> 1 : ([] ++ ([2] ++ [3])) --> 1 : ([2] ++ [3])
07:52:19 <scriptor> boom583: it's faster to ++ on shorter lists
07:52:20 <Cale> --> 1 : (2 : ([] ++ [3]))
07:52:28 <Cale> --> 1 : (2 : [3])
07:52:33 <Cale> done
07:52:34 <scriptor> so in one case you end up with [1] ++ [2,3]
07:52:49 <scriptor> and in the other you have [1,2] ++ [3]
07:52:52 <dawik> can someone show some forward pipe examples with lambdabot?
07:53:08 <Cale> ([1] ++ [2]) ++ [3] --> (1 : ([] ++ [2])) ++ 3
07:53:25 <Cale> oops
07:53:31 <scriptor> boom583: ++ has to traverse to the end of a list before it can append to it, and it's faster to traverse a one-element list than a two-element
07:53:33 <Cale> ([1] ++ [2]) ++ [3] --> (1 : ([] ++ [2])) ++ [3] -- rather
07:53:40 <djahandarie> Leave evaluation to computers
07:53:55 <Cale> --> 1 : (([] ++ [2]) ++ [3])
07:54:16 <Cale> --> 1 : ([2] ++ [3])
07:54:28 <Cale> --> 1 : (2 : ([] ++ [3]))
07:54:35 <Cale> --> 1 : (2 : [3])
07:55:01 <dawik> by that i mean |> operator ..
07:55:10 <Cale> On this short example, we don't get to see the difference too clearly
07:55:21 <Cale> But that was still 5 steps vs. 6 steps
07:55:36 <Cale> But it's a quadratic blowup
07:55:42 <boom583> ok
07:57:13 <Cale> Sorry 4 steps vs 5 rather
07:57:37 <Cale> In the right associated case, each (++) will take 2 reduction steps
07:58:12 <Cale> i.e. if we evaluate [1] ++ ([2] ++ (... ([n] ++ [n+1])...)), it'll take 2*n steps
07:58:22 <Cale> (before all the (++)'s are gone)
08:00:21 <Cale> If we go the other way around, ((...(([1] ++ [2]) ++ [3]) ... ) ++ [n]) ++ [n+1], then the outermost (++) will take n+1 steps (n for the elements of the list on its left, then 1 for the empty list at the end), and then each (++) as you go inward will cost 1 fewer step
08:01:13 <Cale> So, it'll be proportional to n^2 steps
08:01:30 <Cale> boom583: Does that make sense?
08:01:36 <boom583> Cale, i'm working through it
08:02:14 <DMcGill_work> I'm having an interesting problem: Integer takes a large chunk of my heap even though there shouldn't be any integers in the program at all - every single number is an Int. Do System.Random, Vector, or IntMap use some amount of Integers behind the scenes?
08:03:01 <Cale> boom583: Go into ghci and do: let f 0 = []; f n = f (n-1) ++ [n] in f 1000000
08:03:23 <Cale> and then try it the other way: let f 0 = []; f n = [n] ++ f (n-1) in f 1000000
08:06:33 <Cale> DMcGill_work: System.Random does use some Integer values internally, but StdGen values are built from Int32 values.
08:08:28 <DMcGill_work> Cale: that explains the chunk of Int32. To be honest I think profiling from random data is a stupid idea - I'm going to try having one module compiled with a big [(Int,Int)] in and then just use that each time.
08:09:11 <DMcGill_work> since at the moment the time taken is a product of whether or not the random problem was easy or not as opposed to a result of any of the small changes I'm making :(
08:09:16 <Cale> DMcGill_work: System.Random is also notoriously slow, and is frequently the cause of performance issues
08:13:53 <nadirs> Cale: was that "foldl" versus "foldr"?
08:14:09 <nadirs> (hello, by the way :P)
08:14:28 <DMcGill_work> nadirs: no, it's that (++) is O(n) in the first argument and O(1) in the second
08:15:26 <nadirs> DMcGill_work: oh, I see! :)
08:16:15 <dawik> using cons should be fastest right?
08:16:24 <dawik> instead of (++)
08:16:49 <DMcGill_work> f x xs = [x] ++ xs is basically the same as f' x xs = x : xs
08:17:24 <nadirs> dawik: cons is "prepend elem to list" while (++) is "join list to list"
08:18:00 <boom583> Cale:
08:18:00 <boom583> [1] ++ ([2]++[3]) = 1:( [] ++ ([2]++[3]) ) = 1:([2]+[3])
08:18:02 <boom583> but
08:18:03 <boom583> ([1]++[2]) ++ [3] = (1:([]++[2])) ++ [3] = (1:[2]) ++ [3] = [1,2] ++ [3] = 1:([2]+[3])
08:18:04 <boom583> right?
08:18:05 <boom583> Showing the slowness of the second approach.
08:18:33 <DMcGill_work> sure use x:xs instead of [x]++xs but the difference is just some constant factor as opposed to the complexity change of using (++) the wrong way around
08:18:57 <dawik> nadirs: sure, but you can write a function that does the same thing with cons
08:19:04 <dawik> which should be fast
08:19:09 <boom583> Cale: 4 steps instead of 2, just to get at the same point
08:20:19 <DMcGill_work> dawik: if you need to join two lists together then you need (++) - making your own (++) using a fold and (:) is just recreating the definition of (++). If you need to join a single element on front of a list then absolutely use (:) over (++).
08:21:03 <Walther> Hmm. I have a function that calculates a value for [char]s. How can I return only a "best" of a list of generated [char]s?
08:21:17 <geekosaur> filter?
08:21:29 <Walther> simplified, if I have a length function, what is a neat and tidy way to filter the shortest of a list of [chars]
08:21:44 <nadirs> dawik: indeed, in fact (++) is defined in terms of (:)
08:21:54 <DMcGill_work> Walther: if you want the single best then use maximum
08:22:18 <eikke> anyone familiar with type-families and kind constraints -> is there a way to get this to work? http://lpaste.net/98034
08:22:34 <nadirs> what I don't understand (probaby because I jumped in the middle of a conversation) is why would you ever want to do "[x] ++ xs" instead of "x : xs"?
08:22:47 <DMcGill_work> Walther: if you want all but the worst then filtering away the worst is probably the best way to do it if you have a list. If you have a Data.Map on the other hand then there are better ways.
08:24:24 <nadirs> nevermind my last message
08:24:31 <Walther> DMcGill_work: well, obviously this isn't actually a case of length but a hamming distance function. I know I can map the hamming function to a list of generated [char]s, but how to only grab the best of them when I'm not actually storing the hamming values for the [char]s?
08:25:22 <DMcGill_work> Walther: if you're happy to throw away the values then "maximumBy hamming" will return the [Char] with the highest hamming value
08:25:42 <DMcGill_work> whoops I mean "maximumBy (comparing hamming)"
08:25:48 <Walther> DMcGill_work: Oh, there's a maximum/minimumBy? Neat-o.
08:26:10 * hackagebot hydra-hs 1.0.0.2 - Haskell binding to the Sixense SDK for the Razer Hydra  http://hackage.haskell.org/package/hydra-hs-1.0.0.2 (MarcelRuegenberg)
08:35:49 <Alberto> Hello to all. I've a big problem with WinGHCi. Can anyone help me?
08:36:10 * hackagebot fay-jquery 0.6.0.2 - jQuery bindings for Fay.  http://hackage.haskell.org/package/fay-jquery-0.6.0.2 (AdamBergmark)
08:36:37 <ChongLi> Alberto: I can try :)
08:36:47 <Alberto> Thenk you
08:36:57 <Alberto> I inserted a wrong parameter ("-threaded") in the first Tool (:! ghc --make "<fileName><fileExt>"). Now, every time the program starts it enter in a never ending loop.
08:37:21 <Alberto> I searched in vain for the config file, but I have not found anything equivalent.
08:37:24 <ChongLi> that's distressing
08:37:35 <Alberto> In the end, I reinstalled the entire platform, but nothing has changed.
08:37:47 <ChongLi> let me see here
08:38:25 <ChongLi> did you look in \Users\Alberto\AppData\Roaming\cabal ?
08:38:34 <Alberto> no
08:38:58 <ChongLi> try it
08:39:11 <Alberto> I'm trying, thank you
08:48:28 <Walther> Uh. I'm getting "not in scope: comparing"
08:48:54 <ChongLi> Walther: import Data.Ord
08:53:38 <bennofs> How do you handle the case when you work on different projects that have different style guides (like tabs vs spaces, 2 spaces, 4 spaces, ...)? Do you configure your editor for each project again?
08:54:15 <geekosaur> both emacs and vi/nvi/vim support local file settings
08:54:17 <ChongLi> bennofs: both emacs and vim have support for doing this
08:54:20 <ChongLi> ahh!
08:54:24 <Walther> Hmm. Still having problems here, probaly doing something wrong. http://lpaste.net/5087555883584454656
08:54:35 <Walther> don't mind the other errors, it's WIP
08:55:00 <ChongLi> I like your mutation function!
08:55:04 <Walther> :P
08:55:12 <bennofs> But most projects don't have a -*- ... for emacs or vim at the top of each file
08:55:37 <ChongLi> bennofs: you can do it on a directory basis
08:55:40 <Walther> but yeah, i'm currently just :loading the .hs (well, trying to) and then manually testing each function to see they operate
08:55:49 <ChongLi> and then stick that in your global gitignore
08:56:09 <Walther> hamming "foo" "bar" definitely works, currently just can't get the minimumBy working
08:56:58 <ChongLi> Walther: minimumBy is a higher order function
08:57:01 <ChongLi> :t minimumBy
08:57:02 <lambdabot> (a -> a -> Ordering) -> [a] -> a
08:57:51 <Walther> ChongLi: And how do I succesfully use that with my little hamming function that works on a list of offspring
08:57:51 <ChongLi> the type of (comparing hamming parent) is not (a -> a -> Ordering), it is Ordering
08:58:26 <ChongLi> Walther: you could wrap another function around hamming
08:58:58 <ChongLi> the result of hamming being 0 means they're equal, right?
08:59:01 <Alberto> ChongLi, I searched in the cabal directory (the config file), but there is nothing regarding WinGHCi
08:59:02 <Walther> ChongLi: I don't need it to be overly complicated and as far as I understand, this should definitely be able to be done in a pretty straight-forward way with minimumBy
08:59:19 <ChongLi> so you need a function like this: Int -> Ordering
08:59:25 <Walther> ChongLi: yes, but that's a special case
08:59:40 <Walther> let's think of it this way
09:00:04 <Walther> minimum is a special case of minimumBy value
09:00:08 <ChongLi> Alberto: try moving that cabal directory out of there
09:00:24 <ChongLi> Walther: right, just a sec
09:00:32 <Alberto> Ok
09:00:38 <Walther> but now that I have my hamming function, i should be able to have a simple minimumBy hamming too
09:00:44 <ChongLi> I've got it
09:00:50 <ChongLi> you want compare
09:00:52 <ChongLi> :t compare
09:00:53 <lambdabot> Ord a => a -> a -> Ordering
09:00:59 <ChongLi> :t compare 0
09:00:59 <lambdabot> (Num a, Ord a) => a -> Ordering
09:01:16 <ChongLi> :t compare (0 :: Int)
09:01:17 <lambdabot> Int -> Ordering
09:01:24 <Walther> :t comparing
09:01:25 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
09:01:32 <Walther> ermh
09:02:21 <ChongLi> Walther: make sense?
09:02:31 <Walther> offspring is a list of [char]s, parent is a [char], hamming takes two [char]s and returns their hamming distance
09:02:49 <ChongLi> right, but that's no longer the case when compare is run
09:02:52 <Walther> fittest needs to return one [char] that has the lowest hamming distance from parent
09:03:07 <Walther> and no, i don't read type declarations fluently yet
09:03:14 <ChongLi> it's okay
09:04:41 <Walther> so,
09:05:59 <ChongLi> hamming returns an Int
09:05:59 <ChongLi> and compare needs an Int
09:06:20 <Walther> compare or comparing?
09:07:06 <Alberto> ChongLi, I moved the folder cabal in C:\TEMP, but WinGHCi does not function. Ghc instead is ok.
09:07:19 <ChongLi> compare
09:07:37 <ChongLi> Alberto: hmmm
09:07:40 <ChongLi> maybe it's the registry?
09:07:48 <Alberto> perhaps
09:07:49 <Walther> Mmh. And how do I (correctly) compare each element in offspring to parent with hamming, and get the minimumBy
09:08:13 <ChongLi> use hamming to compare each element
09:08:29 <ChongLi> and compare to compare the resultant Int with 0
09:08:37 <ChongLi> (compare 0 . hamming)
09:08:49 <Walther> I don't need the special case where they are equal
09:08:56 <Walther> that is dealt with separately elsewhere
09:09:12 <ChongLi> you may not, but minimumBy does
09:09:42 <ChongLi> it requires a function that returns an Ordering
09:09:49 <ChongLi> :info Ordering
09:09:53 <stelleg> Walther: I think maybe what you want is minimumBy (\x y -> compare (hamming parent x) (hamming parent y)) offspring
09:09:53 <ChongLi> @info Ordering
09:09:54 <lambdabot> Ordering
09:09:58 <ChongLi> hmm
09:10:23 <ChongLi> oh that's right
09:10:33 <ChongLi> sorry, I completely misread what you were trying to do
09:10:38 <Walther> parent = [Char], offspring = [[Char],[Char]], hamming a b = hamming a b (derp), and i need to find minimum of the offspring as their hamming value compared to parent
09:11:09 <Walther> stelleg: augh, that lambda is awfully unreadable
09:12:01 <stelleg> do you want your fittest to be the hamming distance or the string?
09:12:22 <Walther> fittest is the best string, next starting point
09:12:27 <stelleg> yeah
09:13:03 <Walther> I'm not saying your solution wouldn't work, i'm just saying it's beyond my understanding and hence using it wouldn't really contribute to my learning
09:13:10 <ParahSailin> eureka genomics is hiring haskellers
09:13:33 <Walther> current "fittest = minimumBy (compare hamming parent) offspring" definitely doesn't work, but is more readable (at least to me) :P
09:14:33 <shergill> ParahSailin: link?
09:14:56 <stelleg> so the problem is, as ChongLi was saying, that your compare function takes two arguments and tells you which one is bigger
09:15:07 <stelleg> *the compare function
09:15:19 <ParahSailin> actual position not posted yet, just send resume in https://www.eurekagenomics.com/ws/about/join.html
09:15:23 <stelleg> but youa re passing it a function and a string
09:15:44 * Guest46987 pretty sure this is a QAAF (question actually asked frequently), but where do i find a place that walks through questions like "wtf is a monad, and whytf should i care?"
09:16:00 <Walther> Personally i'm not sure I even want `compare` function :P I want minimumBy hamming
09:16:06 <Walther> of parent + all offspring
09:16:50 <Alberto> ChongLi, thank you very much, the error was in the register. Now is all OK.
09:17:11 <ChongLi> Alberto: I'm relieved :)
09:17:40 <Walther> genetic evolution demo- offspring is a n long list of "kids" i.e. mutated copies of parent with certain algo, and the closest of offspring to target will be selected as new parent
09:18:05 <Walther> (erm, obviously need to correct: fittest = minimumBy hamming target offspring)
09:18:11 <SaBer> davidfetter_disq: read Learn You A Haskell (aka. LYAH)
09:18:12 <stelleg> Walther: I understand that
09:18:31 <davidfetter_disq> SaBer, awesome. googling.
09:18:35 <stelleg> Walther: do you understand lambda notation?
09:18:44 <Walther> good :) I don't understand that complicated two-parameter lambda function, and would prefer it written out a bit
09:18:48 <SaBer> davidfetter_disq: typeclassopedia is another option
09:18:49 <stelleg> ok sure
09:19:24 <davidfetter_disq> SaBer, thanks :)
09:20:16 <Alberto> ChongLi, another question, please. Moving the cabal folder, I discovered a "huge" ammount of no more used libraries. After I had unregistered, can I delete them from cabal folder?
09:20:26 <Walther> could it be done with fmap instead?
09:21:01 <ChongLi> Alberto: there is also a ghc folder
09:21:16 <ChongLi> you may want to just get rid of both the cabal and ghc folders
09:21:16 <Walther> something like fittest = minimumBy $ fmap hamming target offspring
09:21:19 <ChongLi> and reinstall your packages
09:21:35 <Alberto> ok, thank you
09:22:02 <ChongLi> Walther: this is starting to suspiciously sound like a good use case for lens
09:23:41 <Walther> ChongLi: I don't want to make this overly complicated. `length` is a function that returns a length, and you can use minimumBy to get the shortest by length if you want. Now I just happen to have a hamming function here instead of a length; shouldn't be all that complicated
09:24:06 <Walther> even if it needs two parameters instead of one (in case of length), in this use case, the other argument is always the target
09:24:24 <ChongLi> Walther: right, but the structure you're operating on is a tree, no?
09:24:38 <ChongLi> and you're comparing a parent with its children
09:25:00 <Walther> ChongLi: Eh, not really. I have a recursive function as a wrap-around, you don't need to take care of that in this compare function.
09:25:32 <Walther> The compare function within the algo *just needs to* take the list of offspring, and return the one which has shortest hamming distance to target
09:25:52 <Walther> so it's a case of applying minimumby hamming to target and the list of offspring
09:26:04 <stelleg> Walther: this is what you asked for : http://sprunge.us/CSAd
09:26:21 <stelleg> but you aren't choosing chldren based on hamming to target
09:26:26 <stelleg> you are chossing based on hamming to parent
09:26:33 <stelleg> also your hamming is not hamming
09:26:43 <Walther> stelleg: thank you for that written out version
09:26:52 <Walther> and yes, that parent->target was a mistake, fix'd
09:26:59 <Walther> I am indeed comparing to target
09:27:05 <Walther> and taking the fittest as the new parent
09:27:13 <Walther> (breeding!)
09:38:12 <Walther> take takes first n elements of list; how do I instead return a list of n runs of a function?
09:38:15 <Walther> repeat?
09:38:36 <dv-> iterate?
09:38:39 <dv-> :t iterate
09:38:40 <lambdabot> (a -> a) -> a -> [a]
09:39:10 <dv-> > take 10 (iterate (+1) 1)
09:39:11 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
09:40:19 <tippenein> corecursion is just a different name for a generator, right?
09:40:31 <Walther> dv-: thanks!
09:40:48 <shachaf> What is a generator?
09:41:16 <johnw> shachaf: I think he means like an enumerator
09:41:17 <tippenein> fibonacci would be an example, I think..
09:41:37 <shachaf> OK, what is an enumerator?
09:41:41 <johnw> haha, fair enough!
09:41:43 <tippenein> like recursion from a base case to infinity
09:41:51 <johnw> tippenein: you mean, an unfold?
09:41:56 <johnw> :t unfoldr
09:41:56 <armlesshobo> > take 10 (iterate (+2) 1)
09:41:57 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
09:41:58 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
09:43:13 <tippenein> now I'm confused about what a generator and enumerator are
09:43:39 <armlesshobo> one generates, one enumerates
09:43:58 <johnw> tippenein: an enumerator is a inversion-of-control thing, where you hand it a function and it keeps calling that function for each element it produces; the function is then called an "iteratee" typically, if I have the terminology right
09:44:07 <shachaf> OK. Then I can't answer you.
09:45:16 <stelleg> is there a petition to change if to a function by default that I can sign?
09:45:33 <tippenein> afaik, a generator is called Enumerator in Ruby
09:45:39 <johnw> stelleg: I think the 'cond' package provides an if' you can use
09:46:05 <ChongLi> iteratee is just such a silly word
09:46:06 <shachaf> If there is such a petition, I will cosign it. By which I mean I'll sign the opposite petition.
09:46:08 <ChongLi> I don't know why
09:46:19 <c_wraith> "if" does feel really weird to have in haskell
09:46:22 <stelleg> johnw: yeah I know, thanks
09:46:40 <ChongLi> c_wraith: it is weird
09:46:43 <stelleg> johnw: just would prefer it to be standard
09:47:01 <ChongLi> I like Agda's approach: allow users to define their own mixfix operators
09:47:07 <S11001001> tippenein: a generator of lists only describes one kind of corecursion, I think
09:47:23 <johnw> shachaf: so cosigning for a loan means you oppose the loan?
09:47:59 <shachaf> tippenein: I would say that that's a type error, then.
09:48:05 <shachaf> tippenein: Is recursion a different name for a list?
09:48:20 --- mode: ChanServ set +o shachaf
09:48:37 --- mode: shachaf set +b *!*ircap@*.Red-83-33-196.dynamicIP.rima-tde.net
09:48:38 --- kick: mantiss was kicked by shachaf (/msg spam)
09:48:43 --- mode: shachaf set -o shachaf
09:49:59 <mgsloan> johnw: Nah, it means you're perpendicular to the loan
09:50:53 <johnw> that user was spamming me via PM also
09:51:24 * hackagebot th-lift 0.6.1 - Derive Template Haskell's Lift class for datatypes.  http://hackage.haskell.org/package/th-lift-0.6.1 (MathieuBoespflug)
09:53:58 <tippenein> a list comprehension seems like a generator. generative recursion wiki sorta confirms what I was thinking
09:54:29 <ChongLi> corecursion doesn't even have to involve a data structure at all
09:54:44 <ChongLi> unless you count a continuation, I guess
09:55:30 <c_wraith> Eh?  Isn't corecursion defined in terms of codata?  Such a definition requires constructors.
09:55:42 <tippenein> ChongLi: really? the wiki doesn't make it sound that way
09:56:34 <maxiepoo> c_wraith, I thought codata was defined by its destructors?
09:56:59 <ChongLi> you can store data in closures
09:57:06 <ChongLi> does that count as a data structure? I guess
09:57:48 <S11001001> forall z. z -> (a -> z) -> z
09:58:18 <Walther> Huh. How to implement a simple percentage toss as a conditional (guard) to a function?
09:58:41 <Walther> getStdRandom (randomR (1, 100)) > chance = foo --doesnt seem to work
09:58:42 <c_wraith> Walther: that's not actually conceptually simple.
09:59:08 <c_wraith> Walther: the whole idea of "random" number is very complicated, when you actually start to think about it.
09:59:28 <Walther> Of course. For the sake of simplicity i'm relying on StdRandom here quite a lot
09:59:29 <tippenein> ChongLi: I think I see what you're saying. The recurrence relation would be the corecursion but the data you apply it to is separate ?
10:00:12 <ChongLi> tippenein: no, the data is in there
10:00:42 <ChongLi> it's just stored as a closure rather than in a data constructor
10:00:42 <c_wraith> Walther: that should really be <, not >.  otherwise a chance of 90 is actually 10%
10:01:22 <c_wraith> Walther: regardless of that, the issue is that the randomness has to come from somewhere.  If it comes from IO, well, you can't do IO in a guard.
10:01:24 <Walther> c_wraith: gah, of course.
10:01:48 <c_wraith> Walther: that's because guards shouldn't change the state of the world, which doing IO can
10:02:03 <Walther> But in a guard I should be able to use another function, which then on its own should be able to handle IO
10:02:10 <c_wraith> Walther: on the other hand, if you were explicitly chaining a StdGen value around, you could make that work.
10:02:22 <ChongLi> tippenein: I learned this trick in SICP, by the way
10:03:03 <Walther> c_wraith: I'm very new to haskell, and here's what I want: a function to do either a or b, based on a d-100 roll and a chance that is available as a parameter elsewhere
10:04:16 <c_wraith> Walther: and I'm saying that it's conceptually very hard, because purity requires that you make your source of randomness explicit. You can't just have a function return different things for the same input.
10:05:08 <Walther> and I'm saying I use StdRandom to make it Someone Elses Problem to have a "reliable" source for randomness
10:05:10 <c_wraith> It doesn't make it someone else's problem.
10:05:16 <ChongLi> Walther: what you want is wackelkontakt
10:05:25 <Walther> ChongLi: Huh?
10:05:39 <ChongLi> Walther: it's a noise generator in FRP.Netwire.Noise
10:05:47 <ChongLi> it's a joke :)
10:05:57 <c_wraith> yeah, netwire isn't a beginner library. :)
10:06:26 <S11001001> Walther: for sure, you can't put whatever you do in a guard
10:06:27 <Walther> http://lpaste.net/3252643926569385984 here's some sketching, you should be able to get the idea
10:06:44 <Clint> there's no shortage of purity-breaking random functions on hackage
10:07:03 <tippenein> ChongLi: I'll have to dig out my dusty copy and read about that. Must be chapter 3 or 4
10:07:48 <Walther> S11001001: guards can make a function do foo or bar depending on baz. A random function can be used to a dice roll, which can be used as the baz, no?
10:08:15 <ChongLi> Walther: Haskell doesn't really have "random functions"
10:08:34 <c_wraith> Walther: guards can make an expression be chosen or not, depending on a Bool value.  IO Bool is not Bool
10:09:04 <ChongLi> random function is basically an oxymoron :)
10:09:33 <Walther> nod, bad terminology from me, i meant "random function" as the random generator / taking a "random nmumber"
10:10:08 <Walther> I hope you read the paste and try and understand what I'm trying to do and help based off that :)
10:10:09 <c_wraith> Surprisingly, that terminological difference actually reflects a semantic difference.
10:10:10 <c_wraith> and that semantic difference is a key part of haskell
10:10:15 <Walther> nod
10:10:40 <ParahSailin> @hoogle monadrandom
10:10:40 <lambdabot> package MonadRandom
10:10:41 <lambdabot> package MonadRandomLazy
10:10:46 <Hodapp> Walther: note that 'function' here almost always means 'pure function'.
10:10:56 <Walther> Basically I want a function that either mutates a letter or not (Maybe mutate_cell perhaps?)
10:11:02 <ChongLi> yeah, one way I like to think about it is that Haskell doesn't really "do IO"
10:11:19 <ChongLi> the runtime around Haskell does the IO
10:11:30 <Walther> and essentially the main mutate [char] function returns a new [char] that has zero or more of char's mutated
10:11:31 <ChongLi> Haskell just reduces down to an expression which is then run by that runtime
10:11:39 <c_wraith> :t \c a b -> do { x <- randomRIO (1, 100) ; if x <= c then a else b }  -- This is one approach.  I don't like it, because it depends on IO
10:11:40 <lambdabot> (Num a, Ord a, Random a) => a -> IO b -> IO b -> IO b
10:14:13 <ChongLi> I think it was someone on reddit that explained "An IO String no more contains a String than /bin/ls contains a list of files"
10:14:34 <shergill> ParahSailin: regd the eureka genomics posting. is it for general haskell programmer, or is there an opening for a data science role as well?
10:14:47 <jfischoff> @quote shachaf /bin/ls
10:14:47 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
10:14:59 <ChongLi> ahh, there you go!
10:15:08 <Hodapp> ooooh...
10:15:16 <ParahSailin> shergill: i guess its kind of data science
10:15:34 <c_wraith> :t let f c a b g | x <= c = (a, g') | otherwise = (b, g') where (x, g') = randomR (1, 100) g in f -- I like this approach a lot more. It makes the state-passing explicit, and it doesn't unnecessarily involve IO
10:15:35 <lambdabot> (Num a, Ord a, RandomGen t1, Random a) => a -> t -> t -> t1 -> (t, t1)
10:16:03 <ChongLi> tippenein: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-14.html#%_sec_2.1.3
10:18:31 <Walther> http://lpaste.net/3252643926569385984 still not working although the line 34 works if run on its own
10:21:00 <ChongLi> :t StdRandom
10:21:01 <lambdabot> Not in scope: data constructor `StdRandom'
10:21:01 <c_wraith> Walther: have you looked at the type signature for runRVar?
10:21:13 <ChongLi> yeah, I don't know what that is
10:21:21 <c_wraith> ChongLi: it's from random-fu
10:21:47 <ChongLi> ahhh, what a treasure trove this is!
10:22:24 <Walther> it's from Data.Random.Extras, and I used that for getting a random from ['a'..'z'] ++ [' '], and because nobody mentioned be a better way to get a random number from range 1..100 using stdrandom, i use it there too
10:22:33 <c_wraith> Walther: guards must have the type Bool
10:24:12 <Walther> Nod. That knowledge still doesn't help me figure out a) what I'm doing wrong b) how to fix it
10:24:19 <ChongLi> Walther: yeah this is a complicated library
10:24:21 <Walther> mind you; i'm still very new to Haskell
10:24:32 <Walther> ChongLi: if you have a better idea, do tell me.
10:24:41 <Walther> The pastie I linked has the code I'm working on
10:24:49 <ChongLi> yeah, I'm looking at it
10:25:14 <ChongLi> where will evolve be called?
10:25:44 <Walther> it's nothing overly complicated of difficult. In python, I'd probably whip up the entire thing in Python in very short time, but now I'm focusing on learning Haskell :P
10:26:13 <c_wraith> Walther: The problem seems to be that you don't have a good idea what's actually going on. You can't just manufacture randomness. You can't write a function that does. You can't even cheat to do so, because the compiler assumes purity, and attempting to cheat that way will probably end up breaking things.
10:26:15 <ChongLi> Walther: right, but python permits you to just "plug in" some side effects wherever you want
10:26:29 <Walther> ChongLi: Oh, the main function doesn't have jack shit yet. Main function will call evolve and print out how many times you needed to evolve stuff
10:26:35 <Walther> this is very much WiP
10:26:36 <ChongLi> in Haskell when you want side effects, you have to start in main
10:27:05 <Walther> ChongLi: Nod.
10:27:06 <ChongLi> think of the expression tree of Haskell
10:27:13 <c_wraith> Walther: I wouldn't use any of the Data.Random stuff. It's great for what it is, but it isn't good for learning.
10:27:19 <ChongLi> with main being the root and having type IO ()
10:27:46 <Walther> c_wraith: Data.Random is very good for the line 16 stuff.
10:27:48 <ChongLi> you can't just do IO on any leaf you want, you have to type all of the branches with IO back to the root
10:28:12 <Walther> It probaly isn't good for the d100 roll, but I haven't been told / haven't found via google a better way to do so
10:28:25 <Walther> ChongLi: mmhm, do continue
10:28:47 <ChongLi> so if evolve is going to do IO, it has to be type IO a
10:29:09 <Walther> there's a reason I haven't type declared evolve yet
10:29:22 <ChongLi> even if the only IO evolve is doing is calling mutate
10:29:42 <ChongLi> the IO monad is viral, there's no way to escape it
10:29:47 <c_wraith> ChongLi: I don't see any reason for it to be IO, though.
10:30:18 <ChongLi> c_wraith: generating random numbers involves IO
10:30:21 <Walther> c_wraith: it calls mutate, mutate potentially changes the parent to get kids
10:30:43 <ChongLi> but you could just generate your list of random numbers and pass that down
10:30:48 <c_wraith> Walther: calling map doesn't change anything
10:30:53 <colprofdrmcbeard> are we doing GAs?
10:31:01 <ChongLi> GAs?
10:31:05 <colprofdrmcbeard> genetic algos?
10:31:08 <ChongLi> yeah
10:31:10 <c_wraith> ChongLi: it's more typical to pass a StdGen or something around
10:31:37 <Walther> c_wraith: I'm aware; i'm trying to map mutate_cell to the [char] that is presented to mutate as the single argument, where mutate_cell is a probability toss to either change a single letter or keep it as the same letter
10:31:59 <c_wraith> Walther: but you're not *changing* anything there.  You're just creating a new value.
10:32:08 <ReinH_> ChongLi: I find a better way to think about it is not "do IO" but "provide an IO action"
10:32:18 <ChongLi> ReinH_: yeah
10:32:19 <Walther> Aware. Mutate returns a new [char] that is either similar to the original or not
10:32:20 <ChongLi> oh hey!
10:32:30 <ReinH_> This starts to make more sense when you use STM to provide IO actions, etc
10:32:35 <ChongLi> I love the Haskell Cast
10:32:36 <ReinH_> there's no real sense in which STM is "doing IO"
10:32:39 <ReinH_> ChongLi: thanks :)
10:32:43 <ChongLi> you guys should do more!
10:32:50 <ReinH_> ChongLi: we're scheduling for Jan and Feb now
10:32:54 <ReinH_> took a break for the holidays
10:32:58 <ChongLi> nice
10:33:36 <ChongLi> it seems like you could just bring back your first 3 guests again and again
10:33:49 <ChongLi> it's amazing how much stuff there would be to cover with each of them
10:33:58 <c_wraith> Walther: there's nothing fundamentally IO-ish going on in evolve.  There is a random process, but that could be modeled in numerous ways other than IO.
10:34:23 <ChongLi> ReinH_: if it's possible, try to get luite on
10:34:25 <Walther> so: mutate parent; this takes the parent (a [Char]), and maps mutate_cell to it, to get a possible mutation at each Char instead of the entire [Char]; a 5% chance for each individual letter to be changed. In the end, mutate returns a new [Char], a kid.
10:34:25 <colprofdrmcbeard> c_wraith: like a PRNG, eh?
10:34:40 <ChongLi> I tried to watch his talk on GHCJS but the audio was really poor
10:35:21 <ReinH_> ChongLi: good idea :) GHCJS is quite interesting
10:35:27 <Walther> I'm pretty sure "evolve" as a function is ready, apart from a proper type declaration. mutate needs work though, and main
10:35:35 <c_wraith> colprofdrmcbeard: well, nearly all the ways it could be modeled involve a PRNG. The key point is that you can use a PRNG explicitly, rather than implicitly via IO.
10:35:36 * mgsloan ++'s the idea of luite doing a haskell cast
10:35:49 <ReinH_> seems good
10:35:54 <ReinH_> luite: you interested?
10:35:54 <colprofdrmcbeard> c_wraith: yes, that's what I was driving at.
10:36:10 <colprofdrmcbeard> wouldn't have to hide it in IO bc it's deterministic.
10:36:14 <ChongLi> ReinH_: I think he's abroad right now, but I'm not sure
10:36:52 <ReinH_> ChongLi: sure, I'm good at async
10:39:33 <ChongLi> ReinH_: yeah and just to be fair
10:39:46 <ChongLi> you should also get on Chris Done to talk Fay and Anton Ekblad to talk haste
10:39:55 <ChongLi> but you don't have to do that all in a row :)
10:40:16 <ChongLi> haha, now that I think about it
10:40:21 <ChongLi> there's a ton of possible guests
10:40:24 <ChongLi> for all these libraries
10:40:44 <ReinH_> heh
10:40:45 <ReinH_> yeah
10:40:59 <ReinH_> maybe we could get them on at the same time and have them argue with each other ;)
10:41:14 <ChongLi> hahaha
10:41:19 <ChongLi> that'd be great
10:42:00 <ChongLi> same goes for the Snap, Happstack and Yesod teams
10:42:11 <bennofs> Or get Tekmo and Snoyman on pipes vs conduit :p
10:42:28 <ChongLi> yeah!
10:42:36 <Walther> http://lpaste.net/3252643926569385984 still not working
10:42:54 <Walther> help and explanations very much appreciated
10:43:39 <ChongLi> k, let me see here
10:43:55 <ReinH_> aaand I'm in a 4 hour meeting
10:44:14 <ReinH_> ChongLi: yeah, I have been secretly planning a Tekmo/Snoyman cage match for a while now
10:44:36 <ChongLi> that would be so fantastic
10:45:06 <ChongLi> they are probably Haskell's firiest commentators
10:46:20 <bitemyapp> ReinH: in what way are they opponents?
10:46:38 <ReinH> bitemyapp: in a non-serious way
10:46:51 <ReinH> I think it would be fun to have them discuss the various similarities and differences between their libraries
10:46:57 <ReinH> different design principles, etc
10:47:04 <bitemyapp> ReinH: I'd kill for a podcast like that.
10:47:16 <bitemyapp> ReinH: maybe Haskellcast or that new functional cast could do it?
10:47:23 <ReinH> bitemyapp: well I do Haskell Cast, so...
10:47:38 <bitemyapp> ReinH: welp. Hop to it.
10:47:42 <ReinH> alrighty :)
10:47:45 <ReinH> I'll run it by Chris
10:48:40 <Walther> So, any tips on http://lpaste.net/3252643926569385984
10:48:54 <ChongLi> Walther: working on it
10:49:07 <Walther> (take a [Char], for each Char either change it or don't based on chance, return a new [Char]
10:49:12 <Walther> ChongLi: Thank you.
10:49:39 <ChongLi> Walther: this function can't be [Char] -> [Char]
10:49:49 <ChongLi> unless [Char] is somehow used as a random seed
10:50:11 <fizbin> Oh, that reminds me - I should fire up my podcast-listening device and finish listening to the HaskellCast episodes I downloaded over the break...
10:50:27 <ReinH> you probably want StdGen Char -> [Char] -> [Char]
10:51:08 <ReinH> oh no
10:51:10 <Walther> ChongLi: Huh? It takes a [Char] and returns another [Char]. The StdGen stuff should be separate as it's not taken as a parameter
10:51:10 <ReinH> well maybe
10:51:14 <ReinH> it can't do random stuff without a source of (pseudo) randomness
10:51:26 <Walther> ReinH: the source is StdRandom, as stated in there
10:51:37 <ReinH> right, and the function needs it
10:51:41 <ReinH> so you have to pass it in or create it
10:51:44 <ChongLi> Walther: you conjured StdRandom out of thin air
10:51:44 <ReinH> and you can only create it in IO
10:52:06 <ReinH> and passing it in breaks the IO dependency and gives you a pure function
10:52:11 <Walther> couldn't the d100 be the IO function there
10:52:31 <Walther> it's outside the mutate function
10:52:36 <ReinH> what you probably want is to seed a d100 roller with randomness and then pass it in
10:52:45 <ReinH> that way it is predictable for a given seed
10:52:51 <ReinH> which might be useful in, e.g., testing
10:53:02 <Walther> I don't have the type declarations for a lot of things because a) i know the compiler is smart about those b) i don't understand type declarations well enough yet when it comes to complicated stuff
10:53:34 <ChongLi> Walther: well, let's start with those
10:53:34 <ReinH> A function [Char] -> [Char] cannot do anything random.
10:53:45 <ReinH> (ignoring unsafePerformIO or similar)
10:54:14 <ReinH> it can, however, do something pseudo-random if it has a source of pseudo-randomness
10:54:18 <ChongLi> or calling read on the [Char] to get an Int and then feeding that to mkStdGen
10:54:34 <ReinH> ChongLi: which requires IO
10:54:40 <ChongLi> :t mkStdGen
10:54:41 <lambdabot> Int -> StdGen
10:54:58 <Walther> current entire code, much stuff missing in e.g. main http://lpaste.net/3252643926569385984
10:55:02 <ReinH> ChongLi: ah right
10:55:17 <fizbin> A function [Char] -> State StdGen [Char] could work, though.
10:55:32 <simukis_> It's still not random. It's pseudo-random.
10:55:44 <fizbin> Sure. It's pseudo-random
10:55:54 <ChongLi> yeah, haskell can't do real randoms
10:55:57 <Chousuke> the only IO you need is the initial random bit to act as a seed for the PRNG. otherwise it's a pure computation.
10:56:00 <ChongLi> it has to get them from the OS
10:56:20 <DigitalKiwi> why is cabal logo still broken link :<
10:56:21 <Walther> a) I'm aware I have theoretical stuff to learn, especially when it comes to IO and random. b) For this usecase, I'm relying on StdRandom as the source for random. Pseudorandom is fine, this is a demo thingy I'm coding to learn haskell, not something that's actually used in research
10:56:27 <ChongLi> and of course, the OS can't either, it samples hardware to build its store of entropy
10:56:58 <fizbin> ChongLi: That's like saying the OS can't add, because it uses hardware to do that.
10:57:16 <ChongLi> fizbin: it seems like a silly distinction
10:57:16 <Walther> c) i'm late for a bar meeting because this stuff is so damn interesting and i want to get this to work :P
10:57:24 <ChongLi> but I think it's analogous to Haskell
10:57:45 <ReinH> Walther: the point is that a function that takes a list of chars and modifies it randomly needs a source of (pseudo) randomness
10:57:54 <Chousuke> Walther: if it helps any, you could transform the StdGen into an infinite list of pseudorandom input :P
10:57:56 <ReinH> which is either a StdGen-like generator or IO
10:58:26 <Walther> Let me repeat: pseudorandom / predictability is perfectly fine. And like in the random_sentence you can read, I use StdRandom for the random source. The current question is why doesn't the same thing work in mutate.
10:58:41 <fizbin> So instead of [Char] -> [Char], you need something like (StdGen, [Char]) -> (StdGen, [Char]), or something equivalent to that.
10:58:45 <ChongLi> Walther: StdRandom isn't a random source
10:59:16 <ChongLi> I think it'd be easier to do this without using random-fu
10:59:49 <Walther> But Data.Random.Extras is handy when I need the random sentences.
10:59:56 <Walther> If you have a better idea for the d100, do tell me.
11:00:10 <fizbin> Equivalent types for this purpose are StdGen -> [Char] -> (StdGen, [Char]), that same typ with the two arguments reversed, [Char] -> State StdGen [Char]. etc.
11:00:11 <stolaruk> ReinH: You are behind Haskell Cast? I've listened to all the episodes a number of times, they are great!
11:00:17 <Walther> give me an example instead of repeating that I do it wrong
11:00:31 <ChongLi> > mkStdGen 103124210 >>= randomR (1,100)
11:00:32 <lambdabot>  Couldn't match expected type `(a0, b0)'
11:00:32 <lambdabot>              with actual type `System.Random.StdGen'
11:00:37 <ChongLi> err
11:00:53 <ReinH> stolaruk: thanks :) it's a joint effort with Chris Forno
11:00:58 <Walther> > randomR (1, 100) StdRandom
11:00:59 <lambdabot>  Not in scope: data constructor `StdRandom'
11:01:06 <zammy> http://www.youtube.com/watch?v=LOhSjHxbvUo
11:01:11 <zammy> HIHIHII
11:01:15 <Chousuke> Walther: you can't do anything random inside the function because you declare its type such that it can't possibly have any randomness :/
11:01:16 <ReinH> Walther: I have a better idea for the d100, one sec
11:01:30 <Walther> Chousuke: type declaration is commented out
11:01:46 <Walther> Chousuke: don't mind the type declaration, instead help me to get it work
11:01:59 <ReinH> Walther: http://hackage.haskell.org/package/game-probability-1.1/docs/Numeric-Probability-Game-Dice.html
11:02:23 <Walther> Hehe.
11:02:41 <ChongLi> > randomR (1,100) (mkStdGen 110214241)
11:02:43 <lambdabot>  (19,1328924549 40692)
11:02:47 <ReinH> I'm planning on using that for pathfinder-style combat for a roguelike
11:03:01 <ReinH> since the pathfinder combat system has an open license
11:03:18 <stolaruk> ReinH: Hey you are making a roguelike in Haskell? That's awesome.
11:03:37 <ReinH> stolaruk: just for fun
11:03:46 <ReinH> there's LambdaHack ofc
11:03:49 <Walther> ReinH: that sounds a bit complicated though for just getting a random in range 1-100
11:03:55 <Walther> as in, importing a whole library
11:03:59 <ReinH> Walther: yeah, but it's super useful if you need to roll multiple dice
11:04:07 <ReinH> randomR (1,100) is totally reasonable
11:04:07 <stolaruk> ReinH: I'm working on a mud myself :)
11:04:11 <ReinH> stolaruk: nice :)
11:04:19 <stolaruk> should be finished in like 4 years
11:04:20 <stolaruk> haha
11:04:23 <Chousuke> ReinH: I'm not sure what runRVar d100 StdRandom (if its type even makes sense) returns but it's a constant, so there is no randomness in it :P
11:04:24 <ChongLi> > getStdGen >>= \g -> return $ randomR (1,100) g
11:04:25 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
11:04:26 <lambdabot>                     System.Random.StdGen)
11:04:26 <lambdabot>    arising from a use of `M593738053291296302115546.show_M5937380532912963021...
11:04:26 <lambdabot>  Possible fix:
11:04:26 <lambdabot>    add an instance declaration for
11:04:34 <ChongLi> > getStdGen >>= \g -> return $ randomR (1::Int,100) g
11:04:37 <ReinH> 2 * d4 + d6 sort of things
11:04:38 <fizbin> stolaruk: Too bad the name "LambdaMOO" is taken.
11:04:39 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable
11:04:43 <ChongLi> hmm
11:04:43 <lambdabot>                     System.Random.StdGen)
11:04:45 <lambdabot>    arising from a use of `M175576725220346033415564.show_M1755767252203460334...
11:04:47 <lambdabot>  Possible fix:
11:04:52 <ReinH> o_O
11:04:57 <ChongLi> > getStdGen >>= \g -> return . fst $ randomR (1::Int,100) g
11:04:59 <lambdabot>  <IO Int>
11:05:08 <ChongLi> ahh, fantastic :)
11:05:15 <stolaruk> fizbin: Yes I've heard of that one :( I am working with the name "hmud" tentatively.
11:05:25 <FunesTheAmnesiou> Is anyone familiar with SublimeHaskell on OSX?
11:05:41 <stolaruk> FunesTheAmnesiou: yes
11:05:42 <ChongLi> Walther: yeah, to answer your question
11:05:43 * fizbin had a character back on LambdaMOO, way back when.
11:05:52 <fizbin> I lost a college roommate to it too.
11:05:59 <ChongLi> just stick (mkStdGen 12041240) wherever you want a generator
11:06:07 <FunesTheAmnesiou> stolaruk: I'm having issues setting it up. Everything is on my PATH, but SublimeHaskell doesn't find it.
11:06:10 <fizbin> As in, he dropped out and it was a major contributing factor.
11:06:23 <stolaruk> fizbin: Was that mud coded in a functional lang?
11:06:49 <stolaruk> FunesTheAmnesiou: What doesn't it find?
11:06:50 <Jani__> hey there
11:07:03 <ChongLi> > fst $ randomR (1,100) (mkStdGen 110214241)
11:07:04 <lambdabot>  19
11:07:11 <ChongLi> > fst $ randomR (1,100) (mkStdGen 19)
11:07:12 <lambdabot>  50
11:07:18 <stolaruk> fizbin: I've heard a number of stories of mud dropouts
11:07:23 <fizbin> No idea. It had a weird OO lang. internally with some functional bits in it. (but mostly OO somewhat reminiscent of the "self" language)
11:07:52 <ReinH> fizbin: io?
11:07:53 <FunesTheAmnesiou> stolaruk: ghc-mod, primarily. Even adding the cabal path manually to SublimeHaskell config doesn't solve the issue.
11:08:28 <FunesTheAmnesiou> stolaruk: all the cabal packages are found just fine by the shell.
11:08:29 <stolaruk> hmmm... I never had such issues on mac
11:08:52 <ReinH> oh huh http://en.wikipedia.org/wiki/MOO_(programming_language)
11:09:06 <stolaruk> ah yes
11:09:12 <FunesTheAmnesiou> stolaruk: I wonder if this might be due to the fact that my haskell-platform is managed by brew.
11:10:50 <stolaruk> FunesTheAmnesiou: You are on a mac then? I'm afraid I don't know. Could be.
11:11:06 <FunesTheAmnesiou> stolaruk: Ah yes, sorry. Forgot to mention it.
11:11:11 <Walther> Is it not possible to use indented guards (|) within a where-syntax?
11:11:14 <FunesTheAmnesiou> stolaruk: Thanks for your help anyway.
11:11:33 <ChongLi> Walther: still around?
11:11:33 <ChongLi> ghc-mod is great!
11:11:33 <ChongLi> just don't use spaces in your directory names!
11:11:33 <ChongLi> Walther: guards can go wherever pattern matching goes
11:11:36 <Walther> I'm getting parse error (possibly incorrect indentation or mismatched brackets)
11:11:48 <fizbin> Even if you weren't getting a parse error there, Walther, you types are a bit confused.
11:11:48 <Walther> fizbin: aware
11:11:49 <ChongLi> ah
11:12:14 <ChongLi> your guard needs to be indented past the level of its parent declaration
11:12:36 <ChongLi> the first character of the identifier, that is
11:12:39 <Walther> http://lpaste.net/3252643926569385984 should be correct
11:12:57 <ChongLi> you're talking about mutate_cell?
11:13:11 <ChongLi> the | needs to be past the m of mutate_cell
11:13:12 <fizbin> "mutate_cell" needs an argument in that "where" clause.
11:13:31 <ChongLi> oh, yeah
11:13:38 <fizbin> And what ChongLi said about spacing too
11:14:21 <ChongLi> it's easier if you put mutate_cell on the line below the where clause
11:14:33 <ChongLi> and then just indent each level by 2 spaces
11:14:47 <ReinH> Oh god here come the acronyms. I love meetings at big companies. o_O
11:15:07 <ChongLi> ReinH: they don't mind you hangin' in IRC during the meeting?
11:15:36 <stolaruk> FunesTheAmnesiou: I think I followed someone's blog when I installed SublimeHaskell and the other necessary plugins; unfortunately I can't find that blog now :(
11:16:12 <ReinH> ChongLi: it's remote
11:16:19 <ChongLi> ReinH: ahhh, that's nice
11:16:22 <ReinH> Walther: if you have questions about indentation/layout, http://en.wikibooks.org/wiki/Haskell/Indentation
11:16:52 <FunesTheAmnesiou> stolaruk: don't worry; Google offers few results, so I'll likely find that blog on my own.
11:16:53 <Walther> ReinH: nod, wasn't aware that it's specific to the function name, not the beginning of clause
11:17:08 <ReinH> it isn't
11:17:18 <c_wraith> Walther: I'd use an approach that looks more like this - http://lpaste.net/98037
11:17:23 <Walther> 21:08:31 < ChongLi> the | needs to be past the m of mutate_cell
11:17:24 <Cale> Walther: The key thing to keep in mind is that things which are siblings should be at the same level, and anything which is part of something else should start in a deeper column
11:17:33 <Walther> instead of after "where" being enough
11:17:51 <ChongLi> Walther: you can have multiple children of a where clause
11:17:56 <Cale> Walther: But the *actual* hard rule is that 'let', 'of', 'do', and 'where' are special layout keywords
11:18:00 <ReinH> Walther: "Code which is part of some expression should be indented further in than the beginning of that expression"
11:18:03 <ChongLi> and they, being siblings, all line up
11:18:07 <ReinH> the beginning of the expression is the 'm' of mutate_cell
11:18:11 <ChongLi> but their children need to be indented
11:18:21 <Cale> and the first non-whitespace character after them determines the column that things have to start in to be part of that block
11:18:22 <ReinH> the rest of the expression needs to be indented further than the 'm'
11:18:43 <Walther> ReinH: that's where i got wrong; was aware of the rule, thought that "where" was counted too, but isn't.
11:19:10 <ReinH> Walther: ah :)
11:19:14 <Walther> too much python in the past, no worries
11:19:44 <Walther> http://lpaste.net/3252643926569385984 getting better already, now I'm getting     Couldn't match type `m0 [Char]' with `Char'
11:21:47 <ChongLi> I like "Eta reduce" is an error :)
11:22:31 <ChongLi> Walther: for reference, it's referring to "mutate a = map mutate_cell a"
11:22:39 <ChongLi> it would prefer if you used point-free style
11:22:51 <ChongLi> "mutate = map mutate_cell
11:22:52 <ChongLi> "
11:23:18 <FunesTheAmnesiou> stolaruk: I just solved the issue. SublimeHaskell config doesn't substitute $HOME for ~, so I just had to spell the path in full
11:23:23 <fizbin> But the type of mutate_cell is wrong for what he wants anyway.
11:23:29 <ChongLi> Walther: yeah, so to solve this issue
11:23:40 <Walther> a is the [Char] mutate takes as input
11:23:49 <c_wraith> Like I said...  http://lpaste.net/98037 is a different approach to this problem.  And I think it's a far simpler one.
11:23:49 <fizbin> Walther: You want mutate to be of type [Char] -> RVar [Char]
11:24:10 <Walther> fizbin: type is not manually declared anywhere, so I shouldn't be interfering with the compiler
11:24:23 <FunesTheAmnesiou> stolaruk: I thought of that while seeking blog posts on SublimeHaskell setup, so thanks for pointing me in the right direction
11:24:46 <ChongLi> Walther: the compiler's job is to help you figure out what your types should be, not the other way around
11:24:47 <fizbin> Walther: Type declarations aren't for interfering with the compiler. They're for making sure you and the compiler have similar ideas as to what's going on.
11:25:03 <fizbin> And right now, you really don't.
11:25:35 <fizbin> The type of mutate - as you've written it there - is [Char] -> [RVar Char] , which is really not what you want.
11:25:41 <Walther> fizbin: I'm aware type declarations aren't for interfering; i've just been told that a haskell code can be perfectly fine without any manual declarations
11:26:01 <Walther> Okay; how do I edit it to be [Char] -> [Char] as I want it to be?
11:26:01 <ReinH> Walther: that's true, but it's a good practice to specify them
11:26:07 <boom583> In Haskell you don't have objects with a state like in OO. You don't call a method on an object and that object's state (member variable) changes. What replaces this? Am I correct that the way to do this is to create functions that have one state argument (among other arguments) and RETURN a new modified state (among other results in a tuple), such that the new state will be passed into the next call to the function? Is that the way it's done in Has
11:26:07 <boom583> or am I full of crap?
11:26:15 <ChongLi> fizbin: actually, the types of the 2 guards are different from one another
11:26:16 <ReinH> if for no other reason than to ensure that the type is what you expect it to be
11:26:27 <Walther> ReinH: nod, but I want to dirst write this so it works and then learn the type declarations of the functions. Priorities, as I'm a beginner.
11:26:28 <c_wraith> boom583: your first line was too long for IRC.
11:26:32 <shachaf> boom583: That is a way to represent a thing with state, yes.
11:26:34 <ReinH> like most other things, it isn't (usually) for the computer's benefit: it's for the human's benefit.
11:26:43 <ChongLi> boom583: yes, that's how it's done
11:26:49 <dementorr> hi, can you tell me why this isnt compiling?: {-# OPTIONS_GHC -threaded #-} import GHC.Conc (numCapabilities)  main = do     putStrLn $ "number of cores: " ++ show numCapabilities it says: unknown flag in  {-# OPTIONS_GHC #-} pragma: -threaded
11:26:56 <Walther> fizbin: I'm fairly sure you know what is the simple edit needed here to make the type correct
11:27:01 <shachaf> boom583: Often the answer is not to represent a thing with state in the first place.
11:27:05 <bennofs> dementorr: please paste the code at
11:27:07 <Walther> I'd really appreciate the concrete example / tip
11:27:09 <bennofs> @where lpaste
11:27:10 <lambdabot> http://lpaste.net/new/haskell
11:27:12 <fizbin> Whoa... You're right, ChongLi. This is going to be some work.
11:27:16 <shachaf> So it might be a right answer to the wrong question.
11:27:20 <bennofs> dementorr: so that it is more readable to us
11:27:22 <fizbin> Walther: I'm working on it, but it isn't simple.
11:27:30 <shachaf> c_wraith: Yes, but only by 4 characters or so!
11:27:35 <ChongLi> Walther: in the first guard
11:27:36 <c_wraith> dementorr: that flag is part of the linking process, not per-file compilation.  You'll have to specify it from outside of the file.
11:27:40 <ChongLi> you return x
11:27:42 <boom583> Did only c_wraith not see my whole question?
11:27:58 <dementorr> http://lpaste.net/98039 sorry
11:27:59 <ChongLi> x :: Char
11:28:11 <boom583> shachaf, ChongLi, ok cool
11:28:12 <erisco> boom583, no it was cut off
11:28:15 <c_wraith> dementorr: like I said.  You can't specify that flag there.  It's the wrong scope.
11:28:28 <c_wraith> dementorr: that flag isn't part of per-file compilation.
11:28:29 <ChongLi> in the second guard, you call runRVar (spawn 1) StdRandom
11:29:02 <Walther> ChongLi: and the type is?
11:29:07 <ChongLi> not sure yet
11:29:08 <dementorr> so I can't declare the -threaded part in Options-GHC? or use some -with-rts-opts:"+RTS -N2 -RTS"
11:29:11 <ChongLi> but it's definitely not Char
11:29:15 <ReinH> Walther: I would suggest that you lift mutate_cell to top-level
11:29:20 <boom583> Ok, here's the full thing:
11:29:21 <boom583> In Haskell you don't have objects with a state like in OO. You don't call a method on an object and that object's state (member variable) changes. What replaces this?
11:29:22 <boom583> Am I correct that the way to do this is to create functions that have one state argument (among other arguments) and RETURN a new modified state (among other results in a tuple), such that the new state will be passed into the next call to the function?
11:29:23 <boom583> Is that the way it's done in Haskell or am I full of crap?
11:29:38 <ChongLi> boom583: yes, that's the way it's done
11:29:40 <c_wraith> dementorr: you can add that option at the command line, or you can put it in a cabal file
11:29:44 <boom583> shachaf: ok, so, what alternatives exist to this idiom?
11:29:51 <ChongLi> but we have ways of hiding the explicit passing of arguments
11:29:52 <boom583> shachaf: if it shouldn't be done with a state
11:29:56 <Walther> Oh right, spawn returns a [Char], even if it's just returing one-char long
11:29:57 <ChongLi> such as using the State monad
11:29:58 <boom583> ChongLi: thanks good to know
11:29:59 <shachaf> What shouldn't be done?
11:30:00 <Walther> rrrright
11:30:13 <dementorr> oh, ok thanks for the help :)
11:30:33 <ChongLi> Walther: what sort of tooling setup are you using right now?
11:30:34 <systemfish> so [9,9] > [1,1,1], what's going on?
11:31:13 <Walther> ChongLi: define tooling?
11:31:14 <merijn> systemfish: list comparison uses lexical sorting, afaik
11:31:16 <ChongLi> I assume it's a text editor + ghci
11:31:23 <Walther> Sublime Text 3, ghc(i), running atop debian jessie
11:31:32 <ChongLi> Walther: okay
11:31:40 <boom583> "shachaf: boom583: Often the answer is not to represent a thing with state in the first place."
11:31:42 <merijn> systemfish: so if the "(x:xs) > (y:ys)" if x > y
11:31:42 <ChongLi> so one of the tricks you can do
11:31:48 <boom583> shachaf: if it's not done with a state, how then
11:31:52 <ChongLi> is to replace things with undefined
11:31:52 <merijn> systemfish: if x == y then xs > ys
11:31:56 <shachaf> If what's not done with a state?
11:31:57 <ChongLi> and then ask ghci what type they are
11:32:24 <shachaf> What is the thing you are trying to do?
11:33:07 <systemfish> merijn: so length doesn't matter?
11:33:08 <merijn> systemfish: So [9,9] > [1,1,1] in the same way that "zzz" > "aa"
11:33:12 <merijn> systemfish: Correct
11:33:17 <boom583> shachaf: i don't have any examples in mind.
11:33:17 <systemfish> :O
11:33:18 <boom583> just asking in general
11:33:25 <merijn> systemfish: It sorts like you'd sort a phonebook alphabetically
11:33:27 <schell> i'm trying to fix an error in a project that uses base-4.7 that has to do with GHC.MatchGroup, which doesn't exist in base-4.7, but I also can't seem to find docs for it in base-4.6
11:34:06 <schell> does anybody know where to find GHC.MatchGroup in base-4.6?
11:34:13 <merijn> systemfish: So "zz" comes after (i.e. is greater than) "aaa" and [9,9] comes after [1,1,1]
11:34:26 <boom583> ChongLi: how long have you been haskell coding
11:34:37 <ChongLi> boom583: hmmm
11:34:58 <shachaf> boom583: Then I can't really answer.
11:34:58 <ChongLi> on and off for maybe 2-3 years?
11:35:01 <boom583> ok
11:35:05 <systemfish> merijn: ah of course, it'd look really confusing otherwise
11:35:07 <systemfish> thnx
11:35:11 <ChongLi> I'm not an expert, by any means
11:35:22 <ChongLi> but you will find Haskell experts in this channel
11:35:28 <shachaf> boom583: An object with state is a solution to a problem. There might be another solution, but I can't say without knowing what you're trying to solve.
11:36:12 <ChongLi> the question is: does the object with state represent some real world device with state?
11:36:13 <schell> the only thing on google i can find that has to do with it is GHC.SYB.Utils
11:36:19 <ChongLi> or is it just data
11:36:52 <ReinH> merijn: lexicographical order, right?
11:36:56 <merijn> ReinH: Yeah
11:37:17 <erisco> :t sortBy
11:37:18 <lambdabot> (a -> a -> Ordering) -> [a] -> [a]
11:37:25 <merijn> systemfish: See also https://en.wikipedia.org/wiki/Lexicographical_order
11:37:25 <boom583> ok, i'll think about this
11:37:26 <boom583> thanks all
11:37:32 <shachaf> I can invent an example.
11:37:39 <boom583> shachaf: sure!
11:37:44 <ChongLi> boom583: think about this how?
11:38:01 <erisco> what other higher order functions take a fun arg that returns Ordering or something else that has two or three values?
11:38:06 <boom583> well, find an example lol.
11:38:07 <shachaf> class Foo { int value; void transmogrify(); /* changes the value */ };
11:38:17 <erisco> (recursive functions that is)
11:38:29 <shachaf> Here we have an object with some state and a method to change the state.
11:38:37 <boom583> ok cool
11:38:42 <shachaf> Maybe a good representation for this is an infinite stream of values.
11:38:48 <ChongLi> erisco: how do you get an Ordering with 3 values?
11:38:58 <FunesTheAmnesiou> An entirely stylistic question: in your experience, is 2-space indent more common than 4-space?
11:39:00 <shachaf> I don't really know because I don't know what it's for.
11:39:17 <ChongLi> FunesTheAmnesiou: I think so
11:39:28 <ChongLi> horizontal real estate is precious
11:39:28 <erisco> ChongLi, because Ordering has three values
11:39:32 <boom583> shachaf: what if transmogrify() reads data from a file until EOF? say it's a integers.txt with integer in each line that it adds to value
11:40:02 <ChongLi> erisco: Ordering has 3 constructors
11:40:15 <shachaf> OK, now you're introducing I/O into it, not just state. I can introduce I/O too, but that makes it more complicated.
11:40:15 <boom583> shachaf: let's also make transmogrify() return another, independent, string that it outputs into another file strings.txt
11:40:17 <ChongLi> I'm talking about a function that takes 3 values and somehow returns an Ordering
11:40:30 <shachaf> OK, I'm done inventing examples.
11:40:39 <erisco> ChongLi, I do not understand what the difference is. wrt the function arity, I do not care
11:40:44 <shachaf> I'm no good at it.
11:40:51 <Walther> Is there a simple explanation to Expected type: [[Char]] Actual type: [[m0 Char]]
11:40:52 <boom583> boom583: is this more suitable for states or rather infinite list?
11:41:01 <ChongLi> erisco: oh I thought you were asking a question earlier
11:41:03 <ChongLi> sorry :)
11:41:16 <fizbin> Walther: I have modified your program to the point where it compiles.  Just a sec...
11:41:18 <erisco> I was
11:41:21 <ChongLi> oh
11:41:37 <ChongLi> Ordering represents a relationship between 2 values
11:41:45 <Walther> my current work in progress http://lpaste.net/3252643926569385984
11:42:10 <erisco> ChongLi, yes but Ordering is LT, GT, or EQ, which is three values. that is the sort of thing I am looking for
11:43:04 <fizbin> Walther: See http://lpaste.net/98040
11:43:05 <erisco> groupBy is good too since it returns Bool. Hoogle is not ideal for performing these queries =\
11:44:11 <ChongLi> erisco: and you're asking what other functions are like that?
11:44:11 <ChongLi> :t compare
11:44:11 <ChongLi> like this?
11:44:11 <ChongLi> hmmm, lambdabot is absent
11:44:12 <ChongLi> compare :: Ord a => a -> a -> Ordering
11:44:12 <ChongLi> http://www.haskell.org/hoogle/?hoogle=a+-%3E+a+-%3E+Ordering
11:44:28 <Walther> fizbin: Uh oh. Control.Monad stuff is something I have never ever dealt with.
11:44:29 <fizbin> Note that in that, Walther, I changed the logic slightly in the computation of "offspring": instead of making a bunch of kids by each mutating the previous kid, all the kids are made by mutating the parent.
11:44:30 <fizbin> The only thing from Control.Monad is replicateM
11:44:33 <lambdabot> Ord a => a -> a -> Ordering
11:44:35 <erisco> ChongLi, particularly I want recursive functions
11:44:41 <ChongLi> yeah hoogle has a tendency to go off into the weeds
11:44:47 <erisco> filter is good
11:45:09 <fizbin> Walther: I should have made it explicit that "replicateM" is all I was taking from Control.Monad. I can write it without that import if you want.
11:45:39 <Walther> fizbin: Hmm. Why is repeatM better than take kids (iterate mutate parent) ?
11:45:50 <fizbin> replicate, not repeat.
11:45:56 <Walther> erm, yeah
11:46:08 <Walther> Right.
11:46:31 <ChongLi> erisco: is there a specific function you're looking for?
11:46:39 <fizbin> And so there are two questions there: why is "replicate" preferred over (take n (something that makes an infinite list)), and why do I use the "M" variant.
11:47:32 <systemfish> [x*y | x<- [1,2],y<- [3,4]]  why does that produce a list of length 4? (I do know that 2*2 is 4). Also, why not use a pipeline here between the two <- definitions ?
11:47:46 <fizbin> The first... eh. it's a minor preference to not allow extra computation, and I think "replicate" is more readable. However, the second - "M" - is a big deal, and why I was on your case about types so much.
11:47:50 <erisco> ChongLi, no I am looking for any recursive higher order function which takes a function f that returns a bounded type (range or 2 or 3 items is ideal, but Int and such is okay too)
11:48:02 <ReinH> systemfish: 1) because the list monad is a cartesian product monad, so...
11:48:05 <fizbin> So... "mutate", you'll notice, is not [Char] -> [Char]
11:48:13 <ReinH> > [(x,y) | x <- [1,2], y <- [3,4] ]
11:48:14 <lambdabot>  [(1,3),(1,4),(2,3),(2,4)]
11:48:49 <ChongLi> erisco: hmmm
11:48:56 <erisco> this is my list thus far http://lpaste.net/98041
11:49:05 <Walther> fizbin: hmmm
11:49:10 <ReinH> systemfish: 2) a pipe between the two <- definitions would change the behavior and require an extension (ParallelListComprehensions)
11:49:15 <ChongLi> erisco: ohhh
11:49:32 <Walther> fizbin: this monad business is way too complicated for me for now, and makes this code ...uh, not really my work :P
11:49:32 <fizbin> Instead, "mutate" is [Char] -> RVar [Char]. This means that if you just do take kids (iterate mutate parent) you get something of type [RVar [Char]]
11:49:47 <erisco> and the reason is that I am working on a new module that can refactor these kinds of functions
11:49:52 <ChongLi> erisco: nubBy, deleteBy, deleteFirstsBy, unionBy, intersectBy
11:50:08 <ChongLi> insertBy, maximumBy, minimumBy
11:50:08 <fizbin> Well, you chose a random number generation library that was monad-based, not me.
11:50:16 <systemfish> ReinH: perfect example, thanks :)
11:50:18 <ChongLi> basically any *By function :)
11:50:54 <ReinH> systemfish: np
11:51:01 <fizbin> To make it... hrm. Let me see if I can rip out the monad part of this, and make it clear why what you wanted to do needed to be tweeked,
11:51:07 <erisco> ChongLi, thanks
11:51:15 <ReinH> fizbin: maybe use mapM?
11:51:20 <c_wraith> Walther: please take a look at my example.
11:51:31 <ChongLi> erisco: you're basically looking for all the higher order functions which take a 2-ary predicate
11:51:47 <Walther> c_wraith: which link again, sorry
11:52:02 <erisco> ChongLi, no I just need them to return a bounded value. I do not care what their arity is
11:52:14 <c_wraith> Walther: http://lpaste.net/98037
11:52:33 <c_wraith> Walther: it's a completely different approach, much less you have to understand to make sense of it
11:52:40 <ReinH> c_wraith: that's what I was referring to when I suggested a function StdGen -> String -> String
11:52:49 <ReinH> but providing the StdGen too makes more sense
11:53:05 <Jeanne-Kamikaze> would anyone know how to add library paths from a cabal build hook ?
11:53:19 <erisco> ChongLi, sorry, actually it must be enumerable
11:53:26 <Jeanne-Kamikaze> actually, from the .cabal file itself
11:53:27 <erisco> ChongLi, bounded is not sufficient
11:53:37 <ReinH> c_wraith: repeatedly split is a nice idiom
11:53:40 <c_wraith> Walther: and its basis is what I told you at the start - make the PRNG use explicit. Don't try to do magic stuff that you don't understand yet
11:54:01 <Walther> c_wraith: I'm sorry, but that looks overly complicated and like you said, is a completely different approach and hence doesn't contribute in my primary goal of learning how to do this by hacking at it on my own and asking for tips where stuff doesn't work :)
11:54:14 <c_wraith> Walther: it's much simpler, actually
11:54:19 <c_wraith> Walther: it's just more explicit
11:54:25 <ChongLi> erisco: ahhh, hmmm
11:54:35 <Jeanne-Kamikaze> ok, found it
11:54:53 <ReinH> Walther: if your approach to getting past a wall was to repeatedly bash your head against it, would you prefer suggestions for helmets or for door opening techniques?
11:55:16 <ChongLi> c_wraith: the trick is not to give someone the right answer but help them to discover it for themself
11:55:45 <c_wraith> ChongLi: That's not a complete answer.  It's a pretty minimal starting point.
11:55:47 <ChongLi> the issue here is that we've already gone down decently long path
11:56:05 <c_wraith> ChongLi: yes, but you went down the wrong path. Too many traps, too much new stuff at once.
11:56:08 <Walther> ReinH: heh. I just have a feeling I'm so close to getting this ;)
11:56:13 <c_wraith> ChongLi: you could have gone down the *easy* path instead
11:56:34 <ReinH> Walther: you'd be closer to getting this if you took the short path ;)
11:56:40 <ChongLi> c_wraith: right, but my goal is here not to just get a working program
11:56:43 * hackagebot idna 0.3.0 - Implements IDNA (RFC 3490).  http://hackage.haskell.org/package/idna-0.3.0 (GeorgePollard)
11:56:49 <ChongLi> but to help Walther understand what lies down this path
11:56:54 <Walther> ^
11:57:03 <erisco> ChongLi, mkay now I am looking for the same thing except for parametric return types now
11:57:04 <c_wraith> ChongLi: that's not appropriate at this phase of understanding.  It's too much at once.
11:57:11 <Walther> that's my goal too. To learn haskell. This is just an interesting enough problem/algo to get me hacking.
11:57:28 <Walther> this isn't my first piece of haskell code either, but perhaps the most complicated so far
11:57:28 <c_wraith> ChongLi: it's like someone asking how to calculate the area of a triangle, and you start by explaining integral calculus
11:58:07 <erisco> so there's map...
11:59:27 <ChongLi> erisco: is this a homework assignment?
11:59:46 <erisco> ChongLi, a scavenger hunt for functions? lol
11:59:58 <ReinH> homework is often shitty ;)
12:00:07 <erisco> no I said I am working on a new module which can refactor these types of functions
12:00:16 <Walther> Already better, http://lpaste.net/6052065191619723264
12:00:18 <c_wraith> Walther: The thing is, your entire approach came from your choice to use the random-fu library. If you'd just started with random, and never looked at random-fu, you would have stayed on the path of simple function application
12:00:50 <ChongLi> c_wraith: yeah, I should have been a bit more assertive with that earlier
12:01:02 <Walther> c_wraith: Possible. However, Data.Random.Extras seemed the sanest way to look at generating a random [Char] off a custom list ['A'..'Z'] ++ " "
12:01:15 <merijn> c_wraith: To be fair, I was trying to help him to use random earlier, but I couldn't see an easy way to do what he wanted
12:01:35 <c_wraith> Walther: there are advantages to the random-fu approach, but you need a higher level of understanding of haskell idioms and patterns (monads, in particular) to take advantage of them
12:01:41 <Walther> plain random looked easy when giving an explicit range of say, a-z, but I *need* that space character there too
12:01:41 <merijn> c_wraith: randomRs only supports ranges, and since there's no range that includes 'A'..'Z' and ' '
12:01:46 <ChongLi> > fst $ randomR ('A','Z') (mkStdGen 2140912)
12:01:47 <lambdabot>  'A'
12:01:52 <ChongLi> > fst $ randomR ('A','Z') (mkStdGen 21402)
12:01:52 <Walther> What merijn said.
12:01:53 <lambdabot>  'N'
12:01:55 <merijn> c_wraith: And I couldn't trivially figure out a way to get space in there
12:02:09 <ReinH> just pick one of ' ' : ['A'..'Z']
12:02:36 <fizbin> > (' ' : [
12:02:37 <lambdabot>  <hint>:1:9:
12:02:37 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
12:02:38 <Walther> ReinH: well that was the question I was asking a couple hours ago and data.random.extras seemed the only way back then
12:03:27 <fizbin> > (' ' :['A'..'Z']) !! (fst $ randomR (0 :: Int, 27) (mkStdGen 21402))
12:03:28 <lambdabot>  *Exception: Prelude.(!!): index too large
12:03:40 <Walther> current iteration seems almost fine; http://lpaste.net/6052065191619723264  Couldn't match type `RVarT Data.Functor.Identity.Identity Char'
12:03:49 <fizbin> > fst $ randomR (0 :: Int, 27) (mkStdGen 21402)
12:03:50 <lambdabot>  27
12:04:10 <fizbin> > (' ' :['A'..'Z']) !! (fst $ randomR (0 :: Int, 26) (mkStdGen 21402))
12:04:11 <lambdabot>  'B'
12:04:29 <c_wraith> merijn: that's just fear of (!!) biting you. :)
12:04:29 <ReinH> right that
12:04:39 <ChongLi> Walther: yeah, I apologize for not paying more attention earlier
12:04:40 <bearclaw_> is appending one element to a List O(1)?
12:04:45 <ChongLi> it could have saved some time here
12:04:47 <c_wraith> bearclaw_: nope
12:04:48 <Walther> ChongLi: hey no problem :)
12:05:00 <fizbin> bearclaw_: But prepending is.
12:05:05 <merijn> c_wraith: Well, I could think of a way using randomRs Int and a list of values, but it'd be kinda ugly for beginners
12:05:09 <Walther> I mean, I'm not paying anyone here. You're free to do whatever you want
12:06:23 <bearclaw_> hmm, I wanted to repetedly apply a function until some condition became true,  can't use a foldl and finish with a head dropWhile then
12:06:29 <ReinH> bearclaw_: (:) is O(1), (++ [elem]) is O(n)
12:06:47 <ReinH> bearclaw_: you might want a diff list, or you might just want to prepend
12:07:42 <bearclaw_> idealy the list is infinite, so if f(n+1) is prepended to f(n), f(n-1), ... f(0) I don't see how it can work
12:08:25 <ReinH> bearclaw_: is the condition guaranteed to become true?
12:08:30 <bearclaw_> yes
12:08:55 <dsfdsf> Could anyone familiar with the PCA help to test hmatrix-nipals?
12:09:04 <bearclaw_> I can implement a applyUntil clearly, but I kind of like the idea of transforming iteration/recursion into infinite list and using lazyness, wonder how far I can go with that
12:09:10 <ReinH> go p f x | p x = x | otherwise = go p (f x)
12:09:45 <ReinH> I'm not sure what benefit, practical or pedagogical, you would get out of adding in a list
12:09:46 <Walther> current iteration seems almost fine; http://lpaste.net/6052065191619723264  Couldn't match type `RVarT Data.Functor.Identity.Identity Char'
12:09:47 <fizbin> Walther: I'm confused about what "evolve" is supposed to do.
12:10:07 <ReinH> er otherwise = go p f (f x)
12:10:16 <bearclaw_> because recursion becomes just data
12:10:20 <fizbin> Walther: Is "evolve" supposed to do one step, or is it supposed to recurse until done?
12:10:37 <ChongLi> and in that case
12:10:40 <Walther> fizbin: it's supposed to recurse until done ...however, I'm going to need the middle steps too so it probably needs a partial rewrite
12:10:41 <ChongLi> how do we know when we're done?
12:10:54 <ChongLi> is it just a given number of steps?
12:10:57 <bearclaw_> (I like that for instance: repeatF n f = foldl (.) id $take n $ repeat f )
12:11:40 <ReinH> bearclaw_: you probably want foldr
12:11:54 <Walther> Gah. I should probably give up for the day and start again from scratch tomorrow
12:12:10 <Walther> it's been a really good day though, i've learned some 900 ways how to not do this
12:12:20 <merijn> c_wraith: I think adding a "(RandomGen g) => [a] -> g -> [a]" to System.Random would be convenient, so maybe I'll propose it
12:12:30 <ChongLi> Walther: it's a different mindset
12:12:42 <merijn> c_wraith: Seems like an obvious/straightforward function to have and would've solved Walther's problem directly
12:13:02 <ReinH> merijn: do you mean [a] -> g -> a?
12:13:03 <Walther> ChongLi: Oh definitely is. Again, this is not my first poke at Haskell, just the first one to involve Random. And oh boy is that a soup.
12:13:04 <ReinH> i.e. sample?
12:13:12 <ReinH> (i.e. something that should be called sample?)
12:13:40 <rasfar> I did just have an adventure in using random as well
12:13:42 <bearclaw_> one way to put it is that I want to feed a list from a continuation
12:13:42 <merijn> ReinH: No, I mean an infinite list drawn from elements in [a]
12:13:43 <ChongLi> Walther: one approach might be to just use iterate on the outside
12:13:47 <rasfar> tried randomRIO, it was leaky
12:13:47 <ReinH> merijn: ah
12:13:57 <rasfar> back to randomR, but found it was very costly
12:14:02 <ReinH> merijn: I think a random sampling from a list would also be useful
12:14:02 <merijn> ReinH: randomRs only deals with a consecutive range, which doesn't help Walther
12:14:06 <erisco> Walther, 100 more attempts and you might end up with a light bulb!
12:14:20 <merijn> ReinH: Sure, but that's just a trivial case of "take 1" :)
12:14:22 <fizbin> Walther:  I strongly urge you, again, to go look at c_wraith 's approach. You are not as close to compiling as you think you are.
12:14:23 <rasfar> so wrote a replacement for randomR that just returns head of a list of randoms ... much faster
12:15:08 <merijn> ReinH: Although I guess the list could be implemented using your idea too
12:15:10 <bearclaw_> the lazyness does that internally, it seems that there is some cases where that feature is not accessible to the user. If computations are independent, i can use map f [1..]
12:15:15 <ReinH> merijn: ah, sample : randomR :: your thing : randomRs
12:15:15 <Walther> fizbin: Oh very probably.
12:15:17 <bearclaw_> if computation depends on each other, I can't figure out how to do it
12:15:18 <Walther> And like I said, I'll probably re-write the whole thing in a different approach tomorrow
12:15:19 <ReinH> sample and samples?
12:15:26 <rasfar> totally working for me so far :)
12:15:27 <ChongLi> Walther: think of it this way
12:15:27 <ChongLi> you're climbing a tree to eat some lunch up in the branches
12:15:30 <ChongLi> but you forgot your drink
12:15:40 <ChongLi> so you have to go back down to the ground and bring it all the way up with you
12:15:52 <Walther> huge thanks to all you guys being all supportive and patient with my stupidity :P
12:15:57 <Walther> ChongLi: Indeed.
12:16:07 <Walther> but I get to learn the branches better every time I climb.
12:16:24 <Walther> and as the goal here is to learn Haskell, I don't mind having to do "the same thing" a couple times to get it right
12:16:35 <Walther> aaaand learning how to not do something can be important too
12:16:37 <ChongLi> Walther: that's a good attitude to have
12:16:46 <erisco> big hugz
12:16:56 <Walther> the only bad thing here is that i got so stuck to this problem that I pretty much missed a social event. Crap.
12:16:58 <ChongLi> I've seen a lot of people give up in frustration because of this very thing
12:17:17 <ChongLi> the issue of just wanting to insert a little bit of impurity
12:17:41 <ChongLi> Haskell won't let you do that because it would violate referential transparency
12:17:42 <Walther> But I do have to say- compared to some other stuff I've poked at (https://github.com/Walther/99-haskell or https://github.com/Walther/euler ) this exercise has been a whole lot more complicated
12:17:55 <ChongLi> and referential transparency is *critical* for lazy evaluation to work
12:18:07 <Walther> Yes, apparently Random is a bit of a swamp to swim through in Haskell
12:18:28 <Walther> either you half drown or you learn the safe spots
12:18:35 <ReinH> Walther: managing statefulness is a bit of a swamp
12:18:44 <ReinH> Walther: which is why haskellers brought out the big theoretical guns like monads
12:19:15 <ChongLi> Walther: have you gone through the section on Functors, Applicatives and Monads on LYAH?
12:19:45 <ReinH> (for randomness there's, e.g., http://hackage.haskell.org/package/MonadRandom)
12:19:50 <Walther> ChongLi: Can't honestly say I understood all of that chapter.
12:19:55 <bearclaw_> if I "foldr func [1..10^10] ..." can I get lazyness on the big list?
12:20:08 <ChongLi> Walther: those are the "big 3" of Haskell
12:20:09 <ReinH> bearclaw_: foldr is as lazy as its folding function allows
12:20:15 <bearclaw_> foldr will start by getting the end though
12:20:24 <ReinH> bearclaw_: no, it won't
12:20:37 <Walther> ChongLi: Nod. But first I need to even learn the easier stuff, like properly grasping the use of even basic syntax
12:20:41 <bearclaw_> func is fed elements from the end right?
12:20:53 <ChongLi> Walther: yeah, the layout thing is a bit tricky
12:21:05 <bearclaw_> what if the end code only need the 3 last elements? Because the accumulator is a list.
12:21:08 <ReinH> > take 10 $ foldr (:) [] [1..] -- bearclaw_
12:21:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
12:21:12 <ChongLi> you can use braces and semicolons if you want
12:21:26 <merijn> Walther: Random is one of those things that's really neatly designed once you understand the how/why of thins, but it's a bit confusing if you're just starting out
12:21:30 <ReinH> bearclaw_: can you make it only need the first three elements instead?
12:22:01 <Jefferson_> Is there a "zippable" typeclass?  I'm envisioning a function zip :: (Zippable f) => (a -> b -> c) -> f a -> f b -> f c
12:22:08 <ReinH> erisco: ZipList?
12:22:10 <ReinH> er
12:22:11 <ReinH> Jefferson_: ^
12:22:15 <ReinH> dunno how that happened
12:22:22 <ReinH> oh typeclass
12:22:24 <ReinH> no
12:22:31 <ReinH> Jefferson_: but any foldable should be zippable?
12:22:53 <ChongLi> the real issue here is that C's (and other languages') rand() is treated like a function
12:22:57 <ChongLi> but it's not
12:23:02 <ChongLi> it has internal state
12:23:29 <dwcook> When most programmers say "function", they aren't referring to functions in the mathematical sense. In Haskell, you (usually) are.
12:23:45 <ChongLi> dwcook: that's another issue
12:24:03 <shachaf> Jefferson_: The type class for that behavior is Applicative (or, more accurately, Apply), but the usual instance for that doesn't zip.
12:24:18 <ChongLi> relearning terminology can be disorienting to say the least
12:24:31 <shachaf> There is also MonadZip which is some crazy syntax overloading business.
12:24:42 <shachaf> dwcook: Not really.
12:24:50 <dwcook> shachaf, explain.
12:25:02 <dwcook> Oh, the second part.
12:25:12 <dwcook> Because of bottom.
12:25:21 <shachaf> Well, there are lots of mathematical senses of the word "function".
12:25:29 <shachaf> _|_ is part of it, yes.
12:25:50 <shachaf> Also computability.
12:26:30 <dwcook> Explain about computability.
12:27:13 <shachaf> Is e.g. https://en.wikipedia.org/wiki/Busy_beaver_function a Haskell function?
12:27:15 <bearclaw_> @let serieF f v0 = foldr (\ v l ->  f (head l) : l) [1..] [v0]
12:27:15 <lambdabot>  .L.hs:168:1: Warning:
12:27:16 <lambdabot>      Pattern match(es) are overlapped
12:27:16 <lambdabot>      In an equation for `serieF': serieF f v0 = ...
12:27:16 <lambdabot>  
12:27:16 <lambdabot>  <no location info>:
12:27:19 <erisco> this sounds like an NPC conversation
12:27:33 <bearclaw_> damm, what's that, it worked in PV
12:27:43 <bearclaw_> ah, same context I guess
12:27:47 <bearclaw_> > take 10 $ serieF (+1) 1
12:27:47 <erisco> explain PV
12:27:48 <lambdabot>  [2,1,2,3,4,5,6,7,8,9]
12:27:54 <bearclaw_> (private)
12:28:00 <shachaf> Instead of @let, just use > let ... in ...
12:28:09 <erisco> Thanks. I am done talking to you today.
12:28:27 <Jefferson_> shachaf, Oh I see how you could use an applicative to get that behavior
12:28:36 <bearclaw_> it seems to kinda work, not sure I understand why exactly yet :)
12:28:39 <dwcook> Probably not. Conversely, can we say that Haskell functions are mathematical functions?
12:28:58 <shachaf> Oddly enough, finite lists don't give you a zipping Applicative, since you can't write pure.
12:29:06 <bearclaw_> or if there is no hidden O(n) cost
12:29:13 <ChongLi> is bottom allowed in math?
12:29:22 <ChongLi> I guess it should be
12:29:32 <ChongLi> but it's not typical
12:29:35 <shachaf> Whatever you want is allowed. You make the rules.
12:29:50 <ChongLi> yeah, that's a bit of a silly question
12:29:57 <Jefferson_> you've got two data structures.  You would have to map one of your data structures using the function you want to zip, and then run <*>
12:30:14 <Jefferson_> partial application comes in handy there
12:30:39 <shachaf> <*> is a bit of a hack
12:30:50 <ChongLi> shachaf: a hack?!
12:30:55 <shachaf> Think of Applicative as having pure :: a -> f a and liftA2 :: (a -> b -> c) -> f a -> f b -> f c
12:30:57 <ChongLi> I thought it was elegant
12:31:20 <shachaf> Or as having unit :: f () and mult :: f a -> f b -> f (a,b)
12:31:22 <shachaf> (And fmap.)
12:31:42 <dwcook> @pl liftA2 id
12:31:42 <lambdabot> liftA2 id
12:39:29 <bearclaw_> ok, lol, I reversed the list and the initial accumulator value, that doesn't work
12:46:43 <systemfish> why is it called list COMPREHENTION? To me, comprehention means: to understand. Do they mean 'comprise' here, as in comprising the intended lists with short notations?
12:47:18 <ChongLi> systemfish: it derives from set comprehensions
12:48:10 <bluemanifold> Set theory
12:48:12 <ReinH> ChongLi: Ok. Why are they called set comprehensions? :p
12:48:12 <systemfish> oh, right
12:48:12 <systemfish> yeah :p
12:48:16 <ChongLi> which doesn't answer your question :)
12:48:16 <ChongLi> In linguistics, logic, philosophy, and other fields, an intension is any property or quality connoted by a word, phrase, or another symbol. In the case of a word, the word's definition often implies an intension. The term may also refer to all such intensions collectively, although the term comprehension is technically more correct for this.
12:48:31 <ChongLi> there we go
12:48:34 <ReinH> Ah, from intension, ofc
12:48:49 <ReinH> I didn't make the jump
12:48:52 <bearclaw_> sum $ take 100000000 $ [1..]   seems to asplode my ram in ghci
12:49:05 <fizbin> Walther: I have a working version of your program up at http://lpaste.net/98040 (with smaller number of kids) and it's interesting to run that program piped through "nl".
12:49:07 <ReinH> bearclaw_: laziness
12:49:29 <bearclaw_> I hoped for laziness to make it take a constant RAM and not build the whole list at one time
12:49:50 <bearclaw_> Am I overestimating its power?
12:49:53 <ReinH> bearclaw_: it builds a chain of thinks of the form 1 + 2 + 3 + ...
12:49:56 <ReinH> *thunks
12:49:59 <ReinH> > foldr' (+) 0 [1..1000000]
12:50:00 <lambdabot>  Not in scope: foldr'
12:50:00 <lambdabot>  Perhaps you meant one of these:
12:50:00 <lambdabot>    BS.foldr' (imported from Data.ByteString),
12:50:00 <lambdabot>    F.foldr' (imported from Data.Foldable),
12:50:00 <lambdabot>    IS.foldr' (imported from Data.IntSet)
12:50:05 <ReinH> > F.foldr' (+) 0 [1..1000000]
12:50:06 <lambdabot>  500000500000
12:50:24 <ReinH> > foldr (+) 0 [1..1000000]
12:50:25 <lambdabot>  *Exception: stack overflow
12:50:26 <ReinH> whoops
12:50:35 <rasfar> laziness saves time (possibly) in exchange for space
12:51:00 <Walther> fizbin: Neat!
12:51:10 <ChongLi> and sometimes it saves space *and* time when it's able to avoid unnecessary work!
12:51:24 <bearclaw_> I'm not understanding laziness correctly, I was expecting the values to be produced one by one and immediately consummed
12:51:34 <Walther> fizbin: increasing the amount of kids to 100 significantly reduces runtime though :P
12:51:36 <ChongLi> bearclaw_: that requires stream fusion
12:51:45 <rasfar> right, of course! it can save on unnecessary computation, that's time+space
12:52:14 <jle`> bearclaw_: all values are stored as uncomputed functions until they are required by some types of IO, typically
12:52:21 <jle`> for example if i wrote x = 2 * 3
12:52:31 <fizbin> Walther: Sure. Playing with the effect of different numbers of kids is interesting. E.g., with fewer than 10, the runtime can explode.
12:52:32 <jle`> it would store the uncomputed function (*) 2 3 in place of x
12:52:45 <jle`> but then later if i wrote print x, it would compute it in order to print it
12:52:53 <Walther> fizbin: Nod. That's kinda what the whole thing was originally created for, demonstrating genetic evolution :P
12:52:54 <fizbin> And with 1K, it converges in ~ 30 generations.
12:52:59 <quchen> ReinH: I don't think foldr' is of help for lists.
12:53:22 <ReinH> quchen: ?
12:53:31 <ReinH> quchen: it's not about the list, it's about the strictness of the accumulating function
12:54:00 <Walther> It shouldn't be too difficult to make chance and kids into editable parameters somewhere and run a boatload of automated runs
12:54:40 <fizbin> Walther: One of the nice things that I do see with 10 kids that I don't see with 100 is the occasional backward step.
12:55:17 <quchen> ReinH: Oh, foldr' is defined in terms of foldl' for lists. Then I still don't know how to interprete a foldr' for lists, but it somehow works.
12:55:25 <Walther> Nod. Sometimes even the best kid has more mutations to the worse than the previous gen
12:55:30 <ReinH> quchen: magic?
12:55:36 <ReinH> quchen: I could have just used a seq in there
12:55:50 <quchen> I don't think that would have helped.
12:56:00 <quchen> How would you define foldr' for lists?
12:56:04 <ReinH> quchen: I just need to force the accumulating function
12:56:23 <FreeFull> What would be nice would be a scanl'
12:56:26 <bearclaw_> length [1..1000000000] does not consume any memory for instance
12:56:43 <ReinH> it consumes *some* memory
12:57:00 <ChongLi> bearclaw_: try this out
12:57:02 <ChongLi> http://lpaste.net/804321407444975616
12:57:06 <ReinH> but it is spine strict, not value strict
12:57:09 <c_wraith> it allocates a bunch, because length isn't a good consumer.  But the GC keeps up with it.
12:57:16 <ReinH> summing a list is value strict
12:57:17 <bearclaw_> foldl (\a e -> a+1) 0 [1..1000000000] does
12:57:23 <quchen> ReinH: Accumulating function? You mean "f" in "foldr f z xs"?
12:57:29 <ReinH> quchen: yes
12:57:29 <c_wraith> bearclaw_: use foldl'
12:57:32 <ReinH> or "folding function"
12:57:37 <ReinH> I'm not sure how to properly refer to it
12:57:43 <rasfar> ChongLi: that gives stream fusion via Vecotr?
12:57:48 <ChongLi> rasfar: yeah
12:57:51 <quchen> ReinH: And how would you "force" that in order to avoid leaks?
12:58:14 <quchen> In other words, write down the definition of foldr'.
12:58:21 <ReinH> quchen: ah.
12:58:24 <ReinH> I meant foldl'
12:58:32 <ReinH> foldr' introduced too much magic
12:58:32 <quchen> Aaah.
12:58:49 <quchen> Yeah, that's why I'm asking. I was surprised there is a foldr' in Foldable at all.
12:58:57 <ReinH> quchen: yeah, now that you mention it
12:59:03 * rasfar is wondering how many programmers still trust plain list code to fuse, or use Vector / Sequence on principle...
12:59:27 <ReinH> lists are not a particularly good data structure in the large
12:59:28 <quchen> rasfar: Profile first.
12:59:41 <ChongLi> lists are a control structure, not a data structure :)
12:59:44 <ReinH> they are a particularly good linked list
12:59:45 <quchen> Also I don't think Vector and List are very interchangable.
12:59:49 <ReinH> ChongLi: indeed
13:00:03 <c_wraith> rasfar: I use lists as control flow, vectors as data storage.
13:00:12 <rasfar> oh come on, they're both control and data!
13:00:19 <rasfar> ok
13:00:25 <bearclaw_> ChongLi: (testing with crazy ulimits) requested 68157440 bytes
13:00:46 <rasfar> fusion is a control-flow more than a data-storage thing, i presume?
13:00:58 <quchen> Fusion is an optimization.
13:01:10 <quchen> It doesn't change the semantics of your program.
13:01:18 <rasfar> but i have the impression Vector is more fusable than List
13:01:31 <quchen> FSVO semantics etc.
13:01:32 <rasfar> so that is due to optimisations by the library developers?
13:01:52 <rasfar> not something fundamental about the nature of List / Vector as exposed in the API
13:02:17 <c_wraith> vectors use stream fusion.  lists use foldr/build fusion
13:02:36 <rasfar> i see, thanks for the specifics c_wraith
13:02:42 <quchen> rasfar: Could be. There are other Data.List (.Stream in particular) that use different fusion schemes than Data.List.
13:02:50 <monochrom> in GHC, fusion is done by library writers handwriting rewrite rules
13:02:50 <rasfar> wow
13:03:08 <ReinH> rasfar: both are due to optimizations by the library developers
13:03:16 <ReinH> i.e. rewrite rules
13:03:23 <ReinH> vectors are just more extensive/sophisticated
13:03:29 <rasfar> neat, that must be fun for them :-p
13:03:33 <ReinH> I bet it is
13:03:38 <ReinH> Vector is basically magic under the hood
13:03:45 <ChongLi> bearclaw_: when I profile that program
13:03:49 <ReinH> which is both amazing and a source of some consternation when trying to debug its performance
13:03:52 <ChongLi> it gives me this result:
13:04:07 <ReinH> (it's actually sufficiently advanced technology)
13:04:13 <ChongLi> http://lpaste.net/98046
13:04:14 <rasfar> refactoring between List and Vector (or Sequence) is a bit hectic
13:04:27 <ChongLi> note the line: 1 MB total memory in use (0 MB lost due to fragmentation)
13:04:39 <Jeanne-Kamikaze> any idea how to get relative paths to work with "extra-lib-dirs" in cabal ? It suggests using ${pkroot}, but I'm not quite sure how and the user guide doesn't even mention it
13:05:03 <stian> I have a bunch of small Ruby workflow tools that get launched by Keyboard Maestro (global shortcut manager) and pop up simple dialogues etc... I'd like to try to rewrite some of this in Haskell (both for speed, also because it would be great to be able to share with others). I know Haskell isn't strong in GUIs, but what framework would be easiest to start with?
13:05:24 <stian> Would love to have a little menubar daemon listening for global keyboard shortcuts (OSX).
13:05:28 <ChongLi> isn't it a good rule of thumb to always use saturated application when you want fusion?
13:05:31 <stian> And packaging as an .App.
13:05:42 <ReinH> ChongLi: "saturated application"?
13:05:52 <ChongLi> as opposed to partial application
13:05:57 <ReinH> total application?
13:06:01 <ReinH> er
13:06:04 <rasfar> ChongLi: well it makes the weakest assumptions about those rewrite rules the library devs had to make!
13:06:15 <ReinH> ChongLi: there isn't "partial application" :P
13:07:10 <rasfar> I actually like the term "saturated" for fully-applied -- could be my chem background
13:07:27 <monochrom> it is useless to harp that "haskell function is 1-ary" when we are talking about optimizing compilers
13:07:34 <rasfar> total / partial seems to be more about definedness over a domain
13:08:27 <monochrom> even GHC developers talk about saturated application. you bloody know that the function "map :: (a -> b) -> [a] -> [b]" is morally 2-ary.
13:08:32 <delimax> hey people, I've just begun learning haskell and I wrote these two functions to read an integer, the first one doesn't work but the second one does, any insights? http://lpaste.net/98045
13:08:39 <rasfar> ahaha!!
13:09:16 <ReinH> rasfar: I think you're confusing partial functions with partial application. I can tell because I did that too for a second. ;)
13:09:20 <monochrom> and the fact that it's morally 2-ary is important for generating half-decent machine code
13:09:27 <ReinH> monochrom: ok fine :p
13:09:39 <ChongLi> OverloadedTerminology
13:09:56 <stian> ReinH: I did that for a long time, I never understood why people complained that things like head in Prelude was partial, I thought partially applied functions were really neat :) (I've figured out the difference since)
13:10:07 <stian> ChongLi: There's a compiler flag for everything :)
13:10:23 <rasfar> I understand (perhaps) that "partial" is used in two contexts.
13:10:41 <rasfar> I'm just saying that doesn't justify using "total" in two contexts necessarily...
13:10:41 <ChongLi> delimax: you've told the compiler that [c] :: Integer
13:10:49 <ChongLi> but that's not true
13:11:01 <ChongLi> err
13:11:03 <ChongLi> nevermind
13:11:14 <ChongLi> I'm getting tired haha :)
13:11:52 * hackagebot NaturalLanguageAlphabets 0.0.0.1 - Alphabet and word representations  http://hackage.haskell.org/package/NaturalLanguageAlphabets-0.0.0.1 (ChristianHoener)
13:11:53 <rasfar> maybe i don't understand though...
13:12:13 <delimax> ChongLi: I put that there because ghci couldn't infer the integerness
13:12:39 <geekosaur> what you did was correct, ChongLi was wrong (and realized it after saying it)
13:12:43 <geekosaur> that part at least
13:13:12 <delimax> ah. well readInteger fails with a parse error
13:13:30 <rasfar> { partially applied / fully applied } and { partial function / total function } are basically disjoint concept classes?
13:13:45 <bearclaw_> ChongLi: regarding your profile, the  152,057,256 bytes allocated in the heap is the cumulated alloc count, not the peak allocated at one time, right?
13:13:48 <monochrom> yes
13:14:01 <rasfar> whew, thanks monochrom
13:14:02 <ChongLi> delimax: ahh, I think it's probably because of the newline
13:14:07 <monochrom> perhaps orthogonal rather than disjoint
13:14:16 <rasfar> :)
13:14:22 <ChongLi> it's looking at the newline and trying to turn it into an Integer
13:14:28 <raphie> does anyone know of a kind of "eval" parser for haskell? I want the user to be able to type in a function to stdin and get back Maybe ((a, a) -> a)
13:15:06 <delimax> ChongLi: but then wouldn't the 2nd one fail in the same way?
13:15:08 <tdammers> raphie: something like http://hackage.haskell.org/package/mueval
13:15:10 <geekosaur> no
13:15:12 <tdammers> maybe?
13:15:22 <geekosaur> the second one stops on a non-digit before trying to convert to a number
13:15:29 <geekosaur> the first one tries the conversion to number first
13:15:38 <raphie> tdammers: taking a look, will letcha know!
13:15:40 <hakujin> I wrote a set of Haskell bindings for the Neo4j graph database, inspired somewhat by HDBC (SQL) and Hedis (Redis). Anyone who has used database APIs in anger mind giving it a once over? http://github.com/hakujin/redpill
13:15:46 <geekosaur> and the `elem` happens too late and is pointless
13:16:08 <delimax> oo
13:16:47 <delimax> yea it could only be a single integer at that point, otherwise read would have failed, right?
13:16:53 * hackagebot phash 0.0.2 - Haskell bindings to pHash, the open source perceptual hash library  http://hackage.haskell.org/package/phash-0.0.2 (MichaelXavier)
13:17:12 <ChongLi> > read '\n' :: Integer
13:17:13 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
13:17:14 <lambdabot>  Expected type: GHC.Base.String
13:17:14 <lambdabot>    Actual type: GHC.Types.Char
13:17:26 <ChongLi> > read "\n" :: Integer
13:17:27 <lambdabot>  *Exception: Prelude.read: no parse
13:17:39 <delimax> ChongLi: can I fix it with a case?
13:17:44 <geekosaur> yes, and it is the read that is failing
13:18:29 <ChongLi> delimax: you could use when
13:18:31 <geekosaur> I'd make readOneInt return Maybe Int, and check if the character is a digit (then read and return Just the result) or not (return Nothing)
13:18:34 <ChongLi> :t when
13:18:35 <lambdabot> Monad m => Bool -> m () -> m ()
13:18:41 <benmachine> raphie: hint used to be able to do that, but I'm not sure it's been updated recently
13:18:45 <benmachine> raphie: cf. http://hackage.haskell.org/package/hint
13:19:20 <delimax> oooo
13:21:29 <delimax> thanks for the help :)
13:21:34 <ChongLi> no problem :)
13:27:52 <joneshf-laptop> am i understanding this correct? that if you have a type which is Foldable and Alternative it is a Monad?
13:28:52 <joneshf-laptop> since you'd have pure, fmap, and you could make join as: `foldr (<|>) empty` ?
13:30:27 <ReinH> :t foldr (<|>) empty
13:30:27 <lambdabot> Alternative f => [f a] -> f a
13:30:47 <ReinH> :t F.foldr (<|>) empty
13:30:48 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
13:31:26 <ReinH> if t ~ f then it at least has the right shape
13:32:37 <ChongLi> you need to obey the Monad laws
13:32:53 <benmachine> yeah, there's pretty much no reason to expect you'd get them
13:33:18 <benmachine> although you *do* get them in both the case of Maybe and []
13:34:08 <shachaf> Well, Foldable is made for things that are like [] and Maybe is just a special case of [].
13:34:28 <shachaf> @instances Foldable
13:34:29 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
13:34:33 <shachaf> @instances-importing Data.Foldable Foldable
13:34:34 <lambdabot> ErrorT e f, Maybe, WriterT w f, []
13:34:50 <joneshf-laptop> wonder where the info is on that
13:34:55 <joneshf-laptop> either a proof or disproof
13:35:17 <joneshf-laptop> I would imagine someone might have gone over this before now
13:35:36 * benmachine tries to think of any Foldables that aren't just isomorphic to lists
13:35:59 <shachaf> Trees?
13:36:59 <benmachine> are they Alternatives? I imagine so, but it's not obvious to me
13:37:10 <benmachine> well, depends what laws you like, I guess
13:37:42 <jle`> you could write an alternative instance if you treat each node like a Maybe
13:37:44 <jle`> maybe
13:37:46 <jle`> perhaps
13:38:01 <benmachine> jle`: perhaps!
13:38:21 <benmachine> I think in any case you wouldn't get a monad out of F.foldr (<|>) empty
13:38:27 <benmachine> because the foldr would destroy too much of the structure
13:38:33 <benmachine> you wouldn't be able to get the identity law to work
13:39:31 <raphie> this is probably pretty silly, but how do I "extract" the Right value from an Either?
13:39:41 <eazar001> fromRight
13:39:45 <benmachine> nooo
13:39:52 <benmachine> raphie: using a case expression
13:39:57 <ChongLi> or either
13:39:59 <ChongLi> :t either
13:40:00 <eazar001> what's wrong with fromRight?
13:40:00 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
13:40:06 <benmachine> eazar001: exceptions
13:40:21 <benmachine> if you have a Left instead, you get an unhelpful error message
13:40:24 <frxx> eazar001 nothing if you are sure that you have a right value (and you usually aren't).
13:40:35 <ChongLi> fromRight is the Haskell equivalent of derefing a pointer without testing for null :)
13:40:36 <eazar001> right
13:40:41 <benmachine> frxx: not only do you have to be sure, but the person reading your code needs to be sure too
13:40:46 <eazar001> i see
13:40:55 <eazar001> so your *general* advice is pattern matching ....
13:41:03 <benmachine> and all your future selves need to not screw that up too
13:41:06 <eazar001> but once you're absolutely comfortable fromRight is okay
13:41:18 <benmachine> eazar001: I'd still say pattern matching with an explicit error branch
13:41:27 <eazar001> hmmm
13:41:40 <shachaf> is fromRight even a thing
13:41:42 <ChongLi> why not either?
13:41:49 <ChongLi> :t fromRight
13:41:49 <colprofdrmcbeard> eazar001: you really never want to have your code eval something that might eval error.
13:41:50 <lambdabot> Not in scope: `fromRight'
13:41:54 <ChongLi> haha
13:41:56 <eazar001> that's in another library
13:42:01 <benmachine> ChongLi: either's cool, but pattern-matching is often clearer, imo
13:42:02 <eazar001> Data.Either.
13:42:03 <frxx> raphie maybe fmap will work for you too.
13:42:07 <eazar001> i forget
13:42:14 <frxx> > fmap (+10) (Right 1)
13:42:15 <lambdabot>  Right 11
13:42:29 <raphie> well okay, here's the real question. (trying not to do the whole asking for specifics when I need a bigger picture). I'm using a monad which returns (maybe that's the wrong word, whatever you call it when it spits out a value with <-) an Either ErrorType a
13:42:31 <erisco> your function is in another library
13:42:32 <frxx> > fmap (+10) (Left "error")
13:42:33 <lambdabot>  Left "error"
13:42:47 <raphie> I want to quit the program if it's Left, and do something with the Right value if it's right
13:42:57 <ChongLi> benmachine: if either isn't clear enough, you may need to find clearer names for your functions
13:43:22 <eazar001> that'ere also isLeft lol
13:43:26 <eazar001> but you can pattern match here too
13:43:37 <shachaf> @google boolean blindness
13:43:39 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
13:43:39 <lambdabot> Title: Boolean Blindness | Existential Type
13:43:55 <eazar001> you can pattern match ...
13:43:57 <eazar001> and fmap?
13:43:59 <ChongLi> shachaf: yeah, I had read that in the past and forgotten
13:43:59 <eazar001> i think
13:44:04 <shachaf> @where crossroad
13:44:04 <lambdabot> http://www.vex.net/~trebla/haskell/crossroad.xhtml
13:44:04 <ChongLi> but I've internalized the intuitions
13:45:35 <benmachine> raphie: is the monad a standard one or on Hackage, if so which?
13:45:38 <jle`> raphie: you probably want Either
13:45:42 <jle`> er
13:45:43 <jle`> either
13:45:50 <colprofdrmcbeard> raphie: why quit though?
13:46:14 <ChongLi> I keep seeing raphie and thinking ralphie
13:46:14 <pavonia> raphie: You might also want to look at EitherT, i.e. you could rewrite the complete IO action to "EitherT SomeErrorType IO a" and it would fail on the first Left value
13:46:15 <jle`> either (const quit) (somethingWithRight) yourEither
13:46:19 <ChongLi> be sure to drink your ovaltine!
13:46:25 <eazar001> btw side note: http://hackage.haskell.org/package/either-unwrap-1.1/docs/Data-Either-Unwrap.html
13:46:29 <raphie> colprofdrmcbeard: well, print an error and quit
13:46:35 <eazar001> that's where fromRight is, sorry
13:46:44 <shachaf> eazar001: Ew.
13:46:47 <colprofdrmcbeard> raphie: is what you're doing totally unrecoverable-from?
13:47:06 <shachaf> The Hackage page says that that's deprecated anyway.
13:47:14 <benmachine> colprofdrmcbeard: sometimes quitting is the most appropriate thing
13:47:15 <hakujin> agree with pavonia, monad transformers like EitherT will keep you sane
13:47:23 <shachaf> In favor of http://hackage.haskell.org/package/either-4.1/docs/Data-Either-Combinators.html
13:47:31 <shachaf> Which has a much more sensible fromRight
13:47:42 <colprofdrmcbeard> benmachine: true, i'm just wondering what raphie is doing.
13:47:51 <shachaf> fromRight (error "oh no") ...
13:48:18 <tautologico> so is Backpack already available for haskell?
13:48:44 <frxx> fromJust should do that too
13:49:03 <erisco> shachaf, an interesting article thanks
13:49:15 <eazar001> schachaf: this library is so much better
13:49:17 <jle`> lol at the unsafe operator in lens ^?!
13:49:22 <eazar001> thanks for the link!
13:49:26 <raphie> I'll show you guys my code soon and you can tear it apart!
13:49:34 <shachaf> I got to it by clicking on "Contents" from your link!
13:49:42 <eazar001> lol, whaddya know
13:49:50 <eazar001> i didn't know the one i was using was deprecated either
13:49:56 <eazar001> that's usually the first thing i look for
13:50:57 <eazar001> yea that error issue went through my mind as well
13:51:10 <colprofdrmcbeard> what's the library that allows you to print out source file/line numbers?
13:51:43 <bitemyapp> tautologico: It's getting presented at: http://popl.mpi-sws.org/2014/ so it seems unlikely that there would be something shake-n-bake.
13:51:57 <bitemyapp> tautologico: there are established patterns for making interfaces via typeclasses, if that's what you want.
13:51:57 * hackagebot git-checklist 1.0.0.0 - Maintain per-branch checklists in Git  http://hackage.haskell.org/package/git-checklist-1.0.0.0 (dougalstanton)
13:52:08 <colprofdrmcbeard> I thought I ran across one on hackage. Definitely applicable to use of error
13:52:13 <bitemyapp> tautologico: *got presented
13:52:39 <bitemyapp> sorry, getting presented, sigh. I'm dumb.
13:52:57 <hakujin> anyone have experience working with a database library and mind giving my new library a glance? I'd appreciate some feedback
13:53:12 <tautologico> bitemyapp: just wondering about it, and about its relation to cabal when it's available
13:53:58 <bitemyapp> tautologico: have you been following these kinds of white papers for very long?
13:54:02 <lllllllllllll> tautologico,  what is backpack?
13:54:15 <bitemyapp> tautologico: these kinds of things get published all the time and this isn't the first time SPJ has published something like this.
13:54:35 <tautologico> lllllllllllll: http://lambda-the-ultimate.org/node/4868
13:54:41 <bitemyapp> I have a hard time understand why I should expect anything to come out immediately unless there was a groundswell at the community level.
13:54:44 <lllllllllllll> thx
13:55:00 <tautologico> a better module system could be useful
13:55:24 <tautologico> also, MixML is cool
13:55:32 <bitemyapp> tautologico: uh, yes, but so would a nice ElasticSearch client library for Haskell. The latter I can do something about :)
13:55:42 <tautologico> I'd like to have MixML-like modules in Haskell
13:57:14 <ChongLi> is there a good primer on ML modules for someone like myself? I'm somewhat familiar with Haskell but never touched ML
13:57:58 <eazar001> isn't throwing an error on a non-right sometimes useful though?
13:58:03 <eazar001> or non-left for that matter?
13:58:17 <ChongLi> eazar001: depends on the error message
13:58:17 <eazar001> in cases where perhaps "graceful failure" is not so desirable
13:58:29 <benmachine> eazar001: yeees, but you should specify an error message yourself that is specific to one call-site
13:58:44 <benmachine> the message "Prelude.head: empty list" has caused much suffering over the years
13:58:51 <benmachine> being completely vague and impossible to track down
13:58:55 <eazar001> yea, because sometimes I like to have "fatal errors", it shows that something that shouldn't happen
13:58:57 <ChongLi> benmachine: yeah, was just going to mention taht one
13:59:11 <eazar001> hmmmm
13:59:19 <ChongLi> ghc-mod is rife with calls to head
13:59:19 <eazar001> headMay library is good for that
13:59:37 <ChongLi> and it cost me several hours to help my friend figure it out
13:59:40 <frxx> benc I wish ghc attached filename and line number to errors like that
13:59:44 <frxx> benmachine*
13:59:58 <tautologico> ChongLi: you can take a look at OCaml or SML books, they usually cover the module system
14:00:09 <burp_> solution is, don't use head ^^
14:00:14 <ChongLi> line numbers are not so easy to recover, due to Haskell's evaluation model
14:00:34 <frxx> how about name of the function?
14:00:45 <frxx> provided it exists
14:01:00 <benmachine> it's not in principle so hard a problem tos olve
14:01:12 <benmachine> I believe preprocessors have been written to annotate calls to head etc. appropriately
14:01:20 <benmachine> I don't know why they're not more widely used
14:01:43 <ChongLi> might as well just refactor them all out for safety
14:01:49 <eazar001> head is really that evil?
14:02:01 <ChongLi> eazar001: yeah
14:02:08 <hakujin> it is when the rest of the language is so safe
14:02:13 <hakujin> in a dynamic language it's the norm
14:02:16 <eazar001> hmmm
14:02:19 <frxx> well, less evil than calling p[1] on an empty array in C :)
14:02:24 <erisco> does that make tail the evil twin?
14:02:24 <eazar001> lol
14:02:25 <ChongLi> in a dynamic language we get a nice big stack trace
14:02:47 <ChongLi> with head all we get is this one message: "Prelude.head: empty list"
14:03:04 <eazar001> yea, that is kind of vague, in a specific way
14:03:11 <maurer> ChongLi: That... is not a difference between a dynamic and static language
14:03:31 <ChongLi> maurer: hmmm?
14:03:56 <maurer> ChongLi: You get a stack trace on errors in plenty of static languages, see also ocaml or sml
14:04:12 <maurer> ChongLi: That behavior has to do with the evaluation model rather than the type system
14:04:34 <ChongLi> right, I was just responding to "hakujin >> in a dynamic language it's the norm
14:04:36 <ChongLi> "
14:04:48 <eazar001> sml is a strict model of evaluation
14:05:07 <ChongLi> I didn't preclude the possibility of stack traces in other static language
14:05:39 <eazar001> laziness has really opened my eyes to different ways of programming, what i like about haskell
14:06:03 <ChongLi> well, this is one area where it rears its ugly head
14:06:06 <ChongLi> pardon the pun
14:06:12 <eazar001> hahaa
14:06:21 <hpc> you could try and get a stack trace kind of thing to work in IO
14:06:41 <hpc> which has strict /execution/ and in which you can throw the kind of errors that are likely to be caught and cared about anyway
14:06:55 <eazar001> that's possible
14:07:05 <ChongLi> ghci has good debugging tools for this
14:07:29 <jle`> head is really kinda un-ideal when you consider the fact that Haskell is sort of designed as a language where you have the ability to move so much error-ness/debugging to compiletime.  there are cases where it's useful but it inherently runs against the design philosophy of the language i feel
14:07:34 <ChongLi> my issue is that the exception was occurring in a program I was using as a *user*, not as a developer
14:07:38 <hpc> stack traces break referential transparency though
14:08:03 <hpc> because f = do {putStrLn "error"; throw SomeException "error"} is different from
14:08:07 <ChongLi> so the hours it took me were related to cloning it on github and messing around with it
14:08:15 <ChongLi> and finding out that it doesn't work in ghci
14:08:20 <hpc> g = throw SomeException "error"; f = do {putStrLn "error"; g}
14:08:44 <hpc> that might be a reason why such things haven't happened in ghc
14:09:05 <hpc> and more broadly, specifying stack trace functionality in haskell the language is somewhat constraining for execution strategies
14:09:26 <hpc> food for though
14:09:27 <hpc> t
14:09:30 <ChongLi> yeah, it's not critical
14:09:41 <jle`> do we really expect things to follow our fp ideals/models when we introduce errors?
14:09:42 <ChongLi> sometimes the low-tech solution is better
14:09:50 <jle`> (honest question)
14:09:55 <hpc> jle`: sometimes we do, sometimes we don't
14:10:03 <jle`> i always thought that any discussion of errors implicitly involve sthrowing ideals out the window
14:10:10 <ChongLi> grep -r '\<head\>' src/*.{hs,lhs}
14:10:14 <hpc> it's popular to assume bottom doesn't exist, except for when it does when you can divide by zero or something
14:10:28 <hpc> and in rewrite rules, which are usually written to preserve bottoms
14:10:50 <eazar001> there are ideal ways of handling non-ideal issues
14:10:53 <jle`> although it would be interesting to think about how GHC's error handing/Control.Exception preserve the fp ideals and stuff
14:10:54 <hpc> IO exceptions have a lot of semantics behind them which i think most programmers still don't care about
14:11:14 <jle`> eazar001: true
14:11:23 <hpc> they just think "eh, threads that do regular sequential things; Chan, STM, blah blah edwardk"
14:11:44 <hpc> but you can throw exceptions to other threads to trigger action and other wackado C-style things
14:11:51 <raphie> ok guys, here's the code I finally got working. tear it apart! (I mean, if you want to) https://gist.github.com/RaphiePS/8269f9e776119e9176c9
14:12:00 * hackagebot SHA 1.6.3 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.6.3 (AdamWick)
14:12:55 <jle`> raphie: eval? :/
14:13:51 <raphie> jle`: the idea is that the user can play with it in the terminal instead of having to edit source code
14:14:29 <hpc> raphie: what happens if you pass it an input of "removeFile \"/etc/passwd\""?
14:14:51 <ChongLi> > 10 / 0
14:14:52 <lambdabot>  Infinity
14:14:56 <ChongLi> ahh, okay
14:15:01 <hpc> > floor (10 / 0) :: Integer
14:15:02 <lambdabot>  1797693134862315907729305190789024733617976978942306572734300811577326758055...
14:15:15 <simukis_> woah.
14:15:21 <mauke> > round (0/0)
14:15:22 <ChongLi> haha
14:15:22 <lambdabot>  -269653970229347386159395778618353710042696546841345985910145121736599013708...
14:15:34 <jle`> raphie: so report could be report = fromRight "Error!" show , using the fromRight from the combinator library
14:15:35 <erisco> I did not know rounding off infinity gave such results
14:15:36 <raphie> hpc: well I'm telling it to parse as a (Float, Float) -> Float. lemme try something similar (but non-dangerous)
14:16:14 <jle`> also try to avoid using two $'s on the same line/parentheses if you can
14:16:17 <raphie> hpc: it errors
14:16:26 <hpc> raphie: oh, so you are
14:16:42 <hpc> raphie: i just didn't notice because there's no explicit type conversion, it's all inferenced
14:16:48 <jle`> i guess that's cool
14:16:59 <erisco> raphie, what about unsafePerformIO?
14:17:03 <hpc> raphie: neat code
14:17:16 <hpc> erisco: unsafePerformIO is out of scope so it shouldn't be a problem
14:17:27 <hpc> and you can't import either
14:17:28 <raphie> jle`: would it be better as putStrLn $ (report . fmap) sampleRk result
14:17:38 <jle`> well a direct translation would be
14:17:40 <erisco> lol as long as it is not public facing on some poor sap's server
14:17:46 <rasfar> regarding the stack trace thing (just catching up here)...
14:17:46 <jle`> printStrLn . report $ fmap sampleRk result
14:17:52 <ReinH> erisco: what could possibly go wrong?
14:17:56 <rasfar> i don't think anyone mentioned +RTS -xc ?
14:18:08 <erisco> ReinH, Absolutely Nothing (tm)
14:18:18 <rasfar> if you compile -prof (this is GHC), then run +RTS -xc, it will identify the location of those exceptions
14:18:22 <raphie> jle`: ooh that is nicer. thanks for all your feedback/help
14:18:26 <rasfar> this has been a revolution for me
14:18:35 <hpc> rasfar: that's some snazzy stuff
14:18:43 <jle`> raphie: or you can do like you did too
14:18:46 <hpc> rasfar: does it work by definition or cost point?
14:18:52 <jle`> putStrLn . report . fmap $ sampleRk result
14:18:57 <rasfar> hpc: i'm not sure...
14:19:01 <benmachine> jle`: no, you want that $ after sampleRk
14:19:03 <hpc> (--auto-all can surely turn the latter into the former)
14:19:20 <rasfar> it doesn't give line numbers (although extra instrumentation might do that), but it gives the name of the function in which exception occurred
14:19:31 <hpc> or whatever the option is now
14:19:41 <jle`> benmachine: oh yeah
14:19:43 <jle`> thanks
14:19:44 <jle`> my bad
14:19:48 <benmachine> raphie: if you're only thinking of things like "sin x * y^2", personally I'd just write a parser for your own minilanguage
14:19:49 <rasfar> (i am compiling --auto-all when profiling)
14:19:52 <simukis_> interestingly enough round, floor and ceiling does give the same result given an Infinity. The result depends on how you get the Infinity though (e.g. 0/0, 1/0 and -1/0 all are different somehow).
14:20:07 <benmachine> raphie: would be a bit more work but not as much as it sounds, probably, writing parsers in Haskell is lovely
14:20:12 <hpc> hmm, the ghc manpage doesn't mention --auto-all
14:20:31 <raphie> benmachine: yeah, for sure. I figure I might once I finish the rest of this
14:20:50 <rasfar> yeah, i find i need the full docs for GHC, the man page isn't really
14:20:52 <jle`> raphie: yes a parser like that is relatively straightforward and altogether pleasant to write in a language like Haskell
14:21:08 <raphie> I wrote a JSON parser the other day!
14:21:09 <hpc> simukis_: it comes from the normal form float formula, which is sign * mantissa * 2 ** exponent
14:21:10 <eazar001> or even a short text adventure game with built in parser
14:21:11 <shachaf> 0/0 and -1/0 are not Infinity
14:21:24 <hpc> and i guess the rounding operation is doing it bitwise
14:21:35 <jle`> i wonder, does Interpreter increase the binary size by a significant amount?
14:22:02 <hpc> this would mean you can get many values from floor (0/0) depending on which NaN your computer picks
14:22:18 <erisco> raphie, yeah it only took me all summer to design a math parser :P
14:22:20 <hpc> isn't float fun!
14:22:58 <erisco> raphie, is that Runge Kutta perchance?
14:23:22 <joneshf-laptop> hmm, i dunno, it seems to work out
14:23:30 <joneshf-laptop> Foldable + Alternative = Monad
14:23:40 <joneshf-laptop> i'll have to give it some actual rigor when i get some time
14:23:44 <benmachine> joneshf-laptop: I disagree
14:24:06 <benmachine> joneshf-laptop: I think foldr destroys too much structure to get you both identity laws
14:24:13 <ReinH> joneshf-laptop: Have you found any examples that aren't already monads?
14:24:28 <joneshf-laptop> benmachine, the identities were the easy parts, the associativity got out of hand
14:24:43 <raphie> erisco: why yes it is!
14:25:01 <joneshf-laptop> benmachine, i'm not entirely sure, so i'll reserve judgement until I put together an actual proof
14:25:15 <joneshf-laptop> unless someone else comes up with a counter
14:25:30 <simukis_> shachaf: you're right.
14:25:51 <joneshf-laptop> ReinH, i haven't looked too hard, just something i noticed last/this morning
14:26:03 <benmachine> joneshf-laptop: I think trees are a counterexample
14:26:08 <benmachine> but I'm not sure how you define (<|>)
14:26:22 <benmachine> what laws are you using for (<|>)?
14:26:23 <raphie> is there a nice way to "chain" multiple Eithers so that a Left in any will make the whole thing stop/fail? for instance, say I want to parse multiple functions, one after another, but if there's a parse error in the first one, quit with an error rather than continuing
14:26:33 <rasfar> (sorry, i should just add for completeness, +RTS -xc gives you the full "stack trace" (function call stack), not only the offending function itself)
14:26:44 <benmachine> raphie: yes, (Either e) is a monad
14:26:47 <hakujin> raphie: you want EitherT
14:26:54 <benmachine> no you just want Either
14:27:14 <monochrom> "chain" becomes >>=
14:28:00 <benmachine> raphie: depending on your GHC version, you may or may not have a instance Monad (Either e) predefined
14:28:08 <benmachine> if you do you can do something very similar to the Maybe monad
14:28:13 <benmachine> using do notation etc.
14:28:17 <hakujin> benmachine is right if you don't plan on using other monads. to understand how check out what bind does for Either and Maybe
14:29:03 <silasm> I love how perfectly that question was phrased.
14:29:08 <hpc> raphie: and if you use "fail", code for Either e and Maybe would be totally interchangeable
14:29:40 <joneshf-laptop> benmachine, i didn't check those, but i assume it's just the standard `empty <|> a = a` and `a <|> empty = a`?
14:29:40 <silasm> If only there was some magical thing that let me chain together functions in a nice way while keeping track of a computational context...
14:29:59 <benmachine> silasm: :D
14:30:05 <eazar001> as in make the left value carry and error?
14:30:12 <eazar001> *an
14:30:18 <roboguy_> benmachine: aren't the Alternative laws just the monoid laws?
14:30:21 <benmachine> hpc: eeer, don't count on it, "fail" just calls error for Either these days
14:30:27 <hpc> :(
14:30:28 <quchen> hpc: fail for Maybe is Nothing, fail for Either is undefined
14:30:37 <eazar001> oh
14:30:40 <benmachine> hpc: 'cause you can't magic an e out of nothing
14:30:42 <hakujin> yep, isn't fail sort of taboo these days?
14:31:06 <hpc> i like fail...
14:31:07 <benmachine> roboguy_: they are definitely those, I occasionally see others proposed about interactions with pure and <*>
14:31:29 <hakujin> hpc: I'm asking too. here to learn :)
14:31:32 <quchen> benmachine: You can't even define fail for `Either e`. (Well, you could make it `Left (error ...)`)
14:32:05 <benmachine> quchen: right
14:32:24 <benmachine> fail is... kind of icky
14:32:31 <benmachine> mostly because of the String
14:32:31 <raphie> so if I have Eithers a, b, c: a >>= b >>= c will be a Left value if any of them are left? how would I grab the Right values if all of them are Right?
14:32:33 <hpc> i used fail quite a bit in making my current website
14:32:38 <benmachine> raphie: no not quite
14:32:50 <benmachine> if you have Eithers a b c, there's a few things you can do
14:32:51 <hpc> but it has a natural meaning there as "print what just happened to the error log, close all html tags, exit"
14:33:19 <benmachine> > (\x y z -> (x, y, z)) <$> Right 6 <*> Right 'a' <*> Right ["hello"]
14:33:21 <lambdabot>  Right (6,'a',["hello"])
14:33:23 <shachaf> :t sequence
14:33:24 <lambdabot> Monad m => [m a] -> m [a]
14:33:35 <hakujin> raphie: probably the easest way is using do notation and <-
14:33:35 <hpc> so i could do things like (Just user) <- tryLogin -- must be logged in to view this page
14:33:39 <benmachine> (that lambda can be spelt (,,) as well)
14:33:45 <shachaf> > sequence [Right 1, Left "hi", Right 2, Left "ho"]
14:33:46 <lambdabot>  Left "hi"
14:33:49 <ReinH> sequence is pretty great
14:33:56 <shachaf> > sequence [Right 1, Right 3, Right 2, Right 4]
14:33:56 <jle`> sequence is your man.
14:33:57 <lambdabot>  Right [1,3,2,4]
14:34:12 <jle`> who invented this monad thing
14:34:12 <raphie> wow, sequence is exactly what I'm looking for!
14:34:14 <jle`> it's pretty neat
14:34:23 <raphie> but hakujin, how would I do it in a do?
14:34:27 <ReinH> shachaf: is `F.foldr (>=>) return' a generalization of sequence for any foldable?
14:34:30 <hpc> hmm, if only there was a function that could sequence a list of actions and collect the results
14:34:55 <benmachine> ReinH: I think they have different types
14:35:05 <benmachine> ReinH: however, see Data.Traversable.sequenceA
14:35:09 <ReinH> benmachine: well yes, it's a generalization from [] to Foldable f...
14:35:15 <jle`> raphie: the direct do notation conversion of benmachine's example is do { x <- Right 6; y <- Right 'a', z <- Right ["hello"]; return (x,y,z) }
14:35:18 <benmachine> ReinH: I mean, non-unifiable types
14:35:22 <ReinH> (if I'm correct)
14:35:22 <hakujin> do; a <- fnThatCanFail; b <- fnThatCanFail2; Right (a, b)
14:35:23 <ReinH> benmachine: ah
14:35:23 <quchen> hpc: What about explicit LambdaCase instead of implicit fail?
14:35:40 <benmachine> :t F.foldr (>=>) return -- I don't know why I'm being all "I think" about this, it's easy to find out
14:35:40 <lambdabot> (Monad m, Foldable t) => t (c -> m c) -> c -> m c
14:35:45 <raphie> > do { x <- Right 6; y <- Right 'a', z <- Right ["hello"]; return (x,y,z) }
14:35:46 <lambdabot>  <hint>:1:34: parse error on input `,'
14:35:46 <shachaf> More importantly it's a generalization from Monad to Applicative.
14:35:53 <raphie> > do { x <- Right 6; y <- Right 'a'; z <- Right ["hello"]; return (x,y,z) }
14:35:54 <lambdabot>  Right (6,'a',["hello"])
14:36:00 <raphie> > do { x <- Right 6; y <- Left 'a'; z <- Right ["hello"]; return (x,y,z) }
14:36:01 <lambdabot>  Left 'a'
14:36:03 <hpc> quchen: these were pages that it didn't matter if there were good error messages; i did use explicit case elsewhere
14:36:09 <raphie> oh so do automatically chains 'em?
14:36:15 <hakujin> yep, look at bind!
14:36:20 <jle`> are you aware of the desugaring?
14:36:22 <ReinH> benmachine: yes true
14:36:27 <hpc> @undo do { x <- Right 6; y <- Left 'a'; z <- Right ["hello"]; return (x,y,z) }
14:36:27 <lambdabot> Right 6 >>= \ x -> Left 'a' >>= \ y -> Right ["hello"] >>= \ z -> return (x, y, z)
14:36:57 * raphie should do some reading on this
14:37:04 <monochrom> in "a <- fnThatCanFail", I have problem accepting that fnThatCanFail :: Either X Y is a function, not an Either. in "a >>= b", I have problem accepting that b is an Either, not a function. why must people have them backwards?
14:37:21 <jle`> Right 6 >>= (\x -> Left 'a' >>= (\y -> Right ["Hello"] >>= (\z -> return (x,y,z)))), with the parentheses
14:37:33 <jle`> raphie: have you looked at LYAH?
14:37:43 <raphie> jle`: I did Real World Haskell
14:37:47 <jle`> ah
14:38:00 <raphie> got really bored by LYAH's list comprehension stuff and wanted to dive into functions
14:38:26 <jle`> stick through it :)
14:38:28 <raphie> > do { x <- Right 6; y <- Just 'a'; z <- Right ["hello"]; return (x,y,z) }
14:38:29 <lambdabot>  Couldn't match type `Data.Maybe.Maybe' with `Data.Either.Either a0'
14:38:29 <lambdabot>  Expected type: Data.Either.Either a0 GHC.Types.Char
14:38:29 <lambdabot>    Actual type: Data.Maybe.Maybe GHC.Types.Char
14:38:32 <hpc> or in plain english, "if Right 6 is right then let x be what's in the thing in if Left 'a' is right then ...
14:38:41 <jle`> i recommend sticking through LYAH
14:38:49 <hpc> (for very casual definition of "in")
14:38:56 <shachaf> You can think of a value :: Either E A as an action which might either be an exception (of type E) or just a value (of type A).
14:39:00 <hpc> yeah, stick to LYAH
14:39:17 <jle`> if you stopped at list comprehensions you stopped too early :P
14:39:23 <hpc> it introduces concepts in a very specific order to avoid skipping important concepts
14:39:37 <hpc> the worst thing you can do is skip a chapter
14:39:42 <hpc> worse than to just stop reading imo
14:39:51 <shachaf> LYAH is not all that great. I don't mind people recommending it but telling them to stop reading other books and read it instead when it didn't work for them is excessive.
14:39:59 <silasm> hpc: I read the last chapter on zippers pretty early.
14:40:32 <silasm> found that pretty helpful independently, but it would have been a lot better if I already knew how monads worked.
14:40:37 <notdan> I don't think the list comprehensions chapter is that important
14:40:41 <hpc> silasm: i am honestly not sure why there is a zipper chapter
14:40:43 <tom39291_> I have a haskell application that is running at 100% cpu. What options do I have for diagnosing why it's at 100%? strace... anything better?
14:40:56 <hpc> it's too bendy and not directly applicable
14:41:07 <shachaf> tom39291_: Without killing it or anything?
14:41:08 <hpc> tom39291_: profiling!
14:41:09 <benmachine> tom39291_: why do you expect it to run at less? what should it be doing instead?
14:41:14 <tom39291_> shachaf: Ideally yes.
14:41:15 <silasm> hpc: it tied things together in an interesting way, but yeah it does seem kind of out of place.
14:41:29 <ReinH> hpc: bendy? more like foldy amirite
14:41:45 <ReinH> see cause the zipper forms a y if you look at it... ok never mind
14:41:54 <shachaf> I've never read LYAH, only the parts people in here have asked questions about. So my view is biased. But I've seen many confusing and several wrong things in it.
14:41:54 <hpc> ReinH: wibbly wobbly mathy donsy... stuff
14:42:00 <ReinH> hpc: timey wimey?
14:42:10 <jle`> raphie: you see that that is trying to do Right 6 >>= \x -> Just 'a' ...
14:42:16 <geekosaur> bendy foldy spindly mutilatey?
14:42:16 <jle`> but if you look at >>=
14:42:18 <jle`> :t (>>=)
14:42:19 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:42:22 <ReinH> geekosaur: perfect :)
14:42:23 <jle`> you need the same monad on both sides
14:42:23 <hpc> it's spacey wacey!
14:42:56 <notdan> shachaf: wrong things? for example?
14:43:16 <notdan> maybe the explanations in LYAH are not perfect, but I am pretty sure the book is mostly correct
14:43:22 <silasm> I used zippers to do an awful, AWFUL depth-first-search algorithm for a go game I was writing (I knew about the paper and have read it since then, but the ST monad part still scared me at the time)
14:43:23 <jle`> everything i've ever read about Haskell has had wrong things unfortunately
14:43:24 <notdan> safe for typos maybe
14:43:42 <valdyn> tom39291_: you always have gdb
14:44:34 <ChongLi> to me, zippers seem like an ideal structure for implementing an emacs-style rings
14:44:38 <shachaf> I don't remember.
14:44:54 <ChongLi> kill ring, mark ring, etc.
14:45:09 <silasm> I read "ideal" and "ring" and got completely sidetracked.
14:45:32 <ChongLi> you don't like those ring structures?
14:45:32 <hpc> i read "ring" and immediately thought algebra
14:45:33 <monochrom> haha
14:45:57 <silasm> ChongLi: I don't know anything about emacs, unfortunately.
14:46:02 <ChongLi> silasm: ahh
14:46:09 <silasm> I was talking about algebraic like hpc was
14:46:12 <ChongLi> in emacs whenever you delete text (kill)
14:46:13 <monochrom> rings quotiented by ideals are ideal rings :)
14:46:20 <ChongLi> it pushes it onto a structure called the kill ring
14:46:36 <ciaranm> silasm: an emacs is just a bloatoid in the category of operating systems. what's the problem?
14:46:47 <ChongLi> you then use another command (yank) to grab whatever's on the top of the kill ring and insert it into the buffer
14:46:56 <silasm> ciaranm: haa
14:46:58 <ChongLi> a third command rotates the ring
14:47:01 <silasm> well played.
14:47:04 <ReinH> silasm: you just need a queue though :p
14:47:12 <jrmithdobbs> ciaranm: that entirely depends on whether the os laws require a bootloader impl or not, now doesn't it?
14:47:18 <jle`> ciaranm: literally laughed out loud in the middle of the uni student center
14:47:20 <jle`> thanks
14:47:31 <ReinH> ciaranm: <3
14:47:31 <ChongLi> it gives a nice UI for copy/paste with multiple pasteboards
14:47:32 <silasm> ChongLi: ooh, so it's different from vim's simple stack. That has to be interesting to use, I'd imagine.
14:47:39 <dibblego> how can I generalise these two operations to a type-family? https://gist.github.com/tonymorris/8291182
14:47:46 <jle`> what's the topology of the kill ring?
14:47:53 <shachaf> ciaranm: Please, no editor wars, editor bashing, etc. in here.
14:47:58 <ReinH> silasm: you can get a tree in vim with a plugin
14:48:22 <silasm> ReinH: weird.
14:48:28 <hpc> dibblego: ooh, neat
14:48:36 <ChongLi> emacs also uses a novel thing for its undos
14:48:44 <silasm> I don't really see the use case for anything other than a stack. Neat either way though.
14:48:47 <ChongLi> there is no "redo" command
14:49:09 <ChongLi> instead, undos are commands that get added to the undo ring as well
14:49:13 <ChongLi> so you undo your undos
14:49:16 <ChongLi> which is also undoing
14:49:21 <dibblego> hpc: I suspect I have to make a considerable compromise to achieve it
14:49:35 <ReinH> silasm: one of my favorite early algorithms eureka moments was that bfs and dfs are the same algo with a different (FIFO vs LIFO) queue ;)
14:49:57 <hpc> dibblego: it'd be neater if it was one operation
14:50:01 <hpc> x -> F x y -> G y x
14:50:09 <ReinH> ChongLi: emacs is my undoing, actually
14:50:16 <dibblego> hpc: yeah, but it's not in this case
14:50:17 <ChongLi> zippers also seem like they'd make sense for a scroll-bar type of deal
14:50:25 <nicoo> ReinH: Why ?
14:50:32 <ReinH> nicoo: ?
14:50:36 <ciaranm> ReinH: now try to work out the queue you want to do lds using the same algorithm
14:50:43 <nicoo> Why is emacs your undoing ?
14:50:44 <ChongLi> basically any sort of structure where the UI has some concept of a "cursor" you need to keep track of
14:50:46 * nicoo backlogs
14:50:47 <jrmithdobbs> ChongLi: they can be useful for lots of things if instead of lyah's zippers you use lens'
14:51:04 <dibblego> hpc: I think I will flip one of F and G
14:51:11 <ReinH> ciaranm: which one is lds?
14:51:15 <hpc> dibblego: well, to make type inference not suck horribly in both directions, i would have (in fundeps)
14:51:21 <ChongLi> jrmithdobbs: yeah
14:51:23 <jrmithdobbs> ChongLi: eg, walking large json responses with lens-aeson is *heavenly* using lens' zipper stuff
14:51:25 <ReinH> nicoo: because I keep trying it and I can't make it work for me
14:51:30 <silasm> ChongLi: yeah I like the filesystem example he gives
14:51:32 <nicoo> ReinH: Ah, ok.
14:51:32 <hpc> class Dibblego f g | f -> g, g -> f where
14:51:35 <ciaranm> ReinH: limited discrepancy. take your pick which kind.
14:51:40 <ReinH> ciaranm: ah
14:51:47 <ReinH> ciaranm: that involves backtracking yes?
14:51:55 <dibblego> hpc: yeah I will have at least that — I also need to constrain that first argument to op1/op2
14:52:00 <ciaranm> ReinH: that's an interesting question. naively, yes.
14:52:04 * hackagebot process-progress 0.9 - Run a process and do reportsing on its progress.  http://hackage.haskell.org/package/process-progress-0.9 (DavidFox)
14:52:19 <hpc> so class Foo f g x?
14:52:24 <ChongLi> jrmithdobbs: that's really interesting
14:52:31 <ReinH> ciaranm: so is "priority queue" too naive?
14:52:51 <hpc> er, and y because you are going in both directions
14:52:56 <ciaranm> ReinH: well, you'd have to add something to the algorithm to keep track of the number of discrepancies if you did that
14:52:58 <jrmithdobbs> ChongLi: zippers are one of those things that don't make sense until you find a muddle mess of a problem where nothing else does, heh
14:53:05 <ReinH> ciaranm: hmm
14:53:10 <ChongLi> I wonder if we'll eventually get the succinct dictionary version of that
14:53:15 <dibblego> hpc: I have managed to get; op1 :: a -> F a s -> G s a; op2 :: a -> F a s -> G s a
14:53:27 <ChongLi> walking down JSON without parsing it
14:54:05 <hpc> dibblego: and with that, the operation from G back to F would be just another instance with F/G reversed in the class params
14:54:10 <hpc> dibblego: i assume?
14:54:30 <dibblego> hpc: yeah should be easy now
14:54:55 <ChongLi> walking through a forest of trees that don't even exist in memory
14:54:57 <hpc> dibblego: i am curious what this is for; my brain is swimming now with ways to use this
14:55:13 <ReinH> ciaranm: I'm too brain dead from my 4 hour meeting this morning for your puzzle :p
14:55:21 <dibblego> hpc: prototyping at the moment, but hopefully something interesting
14:55:22 <dibblego> e.g. some and many combinators
14:55:26 <dibblego> *many1
14:55:32 <hpc> cool
14:55:42 <jrmithdobbs> ChongLi: ya, it's interesting.
14:56:03 <erisco> wind chill of -34c today... ow
14:56:17 <hpc> erisco: where i am it's supposed to drop 40F overnight
14:56:35 <ChongLi> it's -16C here right now
14:56:43 <ChongLi> and only 5:50PM
14:56:51 <hpc> quick, someone from australia make us all jealous!
14:56:57 <erisco> ChongLi, same time here.. you must be south a small ways
14:57:08 <scriptor> I'll take my windchill combined with decent heating
14:57:14 <dibblego> into a tunnel bye
14:57:19 <ChongLi> over giant spiders and snakes!
14:57:20 <jrmithdobbs> california good enough? nice ~55F here today
14:57:21 <jrmithdobbs> ;p
14:57:38 <hpc> today the cold somehow managed to get through my wool trenchcoat
14:57:46 <hpc> i really don't want to experience tomorrow
14:57:53 <hpc> 's weather
14:58:09 <erisco> hpc, and it is 40F?
14:58:18 <hpc> erisco: no, it's going to /drop/ 40F
14:58:20 <ChongLi> it took me 4 hours to shovel the snow this morning
14:58:23 <hhhhhhhh> what library should i be using if i want to write a web server which basically only needs routing? it seems like haskell has 1 million libraries for it and im not well informed enough to decide myself
14:58:24 <hpc> right now it's like 5 or so
14:58:31 <ChongLi> had to do it in 2 shifts
14:58:43 <geekosaur> -20C here right now, 17:53 about half an hour after sunset
14:58:55 <hakujin> hhhhhhhh: look at scotty
14:59:00 <hpc> erisco: in mercury temperature; i don't even know what the wind is
14:59:30 <erisco> hpc, good luck =\ hasn't been this cold around here in years
14:59:35 <erisco> it is painful
14:59:45 <hhhhhhhh> hakujin that's what i was leaning towards. thanks
14:59:45 <hpc> yeah
14:59:59 <hpc> hope my car starts tomorrow...
15:01:38 <ppppp> r
15:02:17 * geekosaur works from home; has simply locked the door and will not unlock untl Wednesday when temperatures moderate a bit :p
15:02:35 <maxiepoo> is there any way to get something like stringLiteral/charLiteral from http://hackage.haskell.org/package/parsec-3.1.4/docs/Text-Parsec-Token.html without using a lexer?
15:02:41 <shachaf> I read on the Internet that California is the place to be.
15:02:52 <hpc> shachaf: only people from california say that
15:02:56 <hpc> the rest of us know better
15:03:45 <shachaf> hpc: Well, I live in California, so it checks out.
15:03:56 <hpc> :D
15:07:04 <joneshf-laptop> shachaf, +1
15:07:34 <simpson> I read that Portland is weird. This also checks out.
15:07:47 <jle`> hhhhhhhh: do  you mean just delivering static pages based on routes?
15:11:26 <dleedev> Hi all, where can a newbie find best practices for Haskell? (e.g. pipes, lens, ...)
15:11:44 <shachaf> pipes is hardly a best practice.
15:11:48 <shachaf> Probably lens isn't either.
15:11:59 <shachaf> Well. I'm too biased to comment on lens.
15:12:15 <Clint> s/best practices/cutting-edge fun/
15:12:21 <jfischoff> but its a good point, many of the most popular libraries are very new
15:12:22 <rasfar> biased in favour of?
15:12:24 <ChongLi> think of lens like a really long rope
15:12:32 <ChongLi> it has many uses
15:12:39 <shachaf> Sure, in favour.
15:12:40 <danharaj> lens is essential to my work.
15:12:48 <danharaj> I have saved literally days of productivity because of lens.
15:12:50 <jle`> dleedev: best way is just to read read read good code/libraries...also to write code and have people review it
15:12:54 <rasfar> i mean, in favour of what, as opposed to __
15:13:00 <ChongLi> but it's also easy to hang yourself with it
15:13:10 <joneshf-laptop> ChongLi, i think there's a ... there it is
15:13:13 <danharaj> honestly I do not think the problem pipes solve is hard enough to warrant the complexity.
15:13:29 <dleedev> jle`: how can I find good code?
15:13:50 <jfischoff> dleedev: that is a good question
15:13:52 <jle`> but in terms of lens, edwardk has written a good introduction http://lens.github.io/tutorial.html
15:14:03 <rasfar> shachaf: what is your preferred alternative to lens? I'm not partisan, I haven't used lens yet, but I'm considering it.
15:14:05 <jle`> but beyond that...
15:14:31 <jfischoff> dleedev: I would look at the code of some of the most popular packages. Not a perfect way, but not terrible either
15:14:33 <ChongLi> rasfar: the other half of hackage
15:14:34 <ChongLi> :)
15:14:46 <dleedev> jfischoff: what are the most popular packages?
15:14:50 <jfischoff> http://hackage.haskell.org/packages/top
15:14:50 <rasfar> by which you mean half of hackage already depends on lens??
15:14:56 <shachaf> rasfar: I like lens. It's great. I'm the #2 committer.
15:14:56 <Clint> lens is trendy
15:15:04 <ChongLi> rasfar: no, lens replaces half of hackage
15:15:13 <rasfar> so there is no preferred alternative for you, alright
15:15:16 <ChongLi> but not literally
15:15:47 <ChongLi> the truth is that you can make your package work with lens without actually depending on it
15:15:54 <rasfar> i feel like it would have been a good match for my project, which does a lot of contextual operations in trees
15:16:13 <edwardk> danharaj: i more or less agree. Then again Tekmo says the same thing about lens, so I wonder how of that is a matter of perspective. ;)
15:16:17 <rasfar> but as I'm managing without, need to learn more before commit to such refactoring
15:16:43 <ReinH> edwardk: hai
15:16:47 <Clint> edwardk: representable-junctiors
15:17:01 <jfischoff> pipes is significantly less complicated now
15:17:14 <ReinH> vote to rename it "straws"
15:17:25 <Axman6> glad to hear, it used to be pretty horrible
15:17:41 <ChongLi> my main hangup on lens is the little voice in the back of my head that just keeps whispering "the law of demeter"
15:17:48 <edwardk> Clint: ack
15:18:00 <greghale> edwardk: In terms of solvedProblems/complexity, how is machines compared to lens?
15:18:09 <ChongLi> and I don't know what to do about it!
15:18:13 <greghale> edwardk: Sorry - compared to pipes
15:18:40 <maxiepoo> seems like lens is useful for pretty much everything simply because records are such a pain without it
15:18:42 <Clint> is pipes-conduit perma-dead?
15:18:45 <edwardk> ChongLi: i wrote more minimal lens packages before i worked on lens. because those other packages are out there data-lens, even roconnor's lens-family, etc. i didn't feel the constraint to 'build the minimal possible solution', but moreover, i found that that was actively working against the goal of adoption for lenses.
15:19:10 <ChongLi> edwardk: right, I'm not criticizing lens itself
15:19:24 <ChongLi> just the effect it has on my thinking
15:19:27 <edwardk> what would happen is someone would write some code that could fit the more minimal package and then they'd change something. at which point, inevitably, they were screwed and had to start all over without lenses because they needed something that didn't fit the paradigm
15:19:48 <edwardk> we still have that problem on some things, validation doesn't fit the lens package model for instance, etc.
15:20:18 <edwardk> effectful lenses don't make sense under this formulation, but somehow people seem to get by working with them in other systems. we trade them in for a different set of generalizations
15:20:29 <ChongLi> I'm mainly referring to how lens makes it easy for you to dive down into deeply-nested structures
15:20:37 <ChongLi> which is so tempting to do
15:20:52 <ChongLi> instead of putting in the hard work of building proper abstraction boundaries
15:20:56 <edwardk> greghale: machines is very much a work in progress/somewhat stalled.
15:21:25 <edwardk> greghale: it is me trying to figure out if we _can_ get away with something much simpler than conduit/pipes by imposing different limitations on the programming style
15:21:44 <ChongLi> I don't know if that's a good thing or a bad thing, however
15:21:59 <edwardk> greghale: sadly, i haven't had any problems that needed it lately so it has stalled for want of applcations
15:22:27 <greghale> edwardk: Ok, thanks for the update.  Every once in a while I wonder if there's anything new w/ it.
15:22:36 <edwardk> for me i use lenses to 'solve' composition of multiple MonadState, MonadReader, MonadWriter, etc.  constraints without lift.
15:23:18 <ChongLi> ahhh
15:23:32 <ChongLi> do you have some examples of that I could check out?
15:23:44 <edwardk> greghale: not much going on in my head. on the other hand, acowley has gone off the reservation, and has started building all sorts of things that extend it in all sorts of crazy ways, we haven't figured out how much of it we can/should roll back in
15:25:17 <greghale> edwardk: Googling to see if that exploration is online somewhere -
15:25:18 <carter> yeah, its cool stuff he's doing
15:25:22 <edwardk> greghale: check his fork
15:27:45 <greghale> edwardk: fanout module.  Hey that sounds handy :)
15:28:08 <edwardk> he has a system for fanout that is a bit different than the one i was working on with pchiusano
15:28:17 <edwardk> i don't really know how well the two compare yet though
15:28:57 <edwardk> there is a big integration effort ahead, but neither one of us has had bandwidth to do it ;)
15:30:49 <greghale> edwardk: Cool - thanks for the heads up.
15:31:41 <danharaj> edwardk: Have you seen the nominal sets approach to sets over names?
15:32:30 <danharaj> I have the book by Pitts and I'm trying to work out how it relates to the other formulations I've seen (e.g. presheaves ala fiore, modules ala hirschowitz).
15:32:40 <edwardk> http://www.cs.nott.ac.uk/~vxc/mgs/MGS2011_nominal_sets.pdf ?
15:33:00 <edwardk> i have that in my to-read pile
15:33:05 <danharaj> yup that's the one
15:33:32 <edwardk> i may have to get you to come up to boston and give me the executive summary ;)
15:33:40 <danharaj> haha
15:34:07 <danharaj> if you know Fiore's approach, the tersest thing I can say is "Objects in the Schanuel topos instead of PSh(FinSet^Op)
15:34:09 <danharaj> "
15:34:28 <hpc> you made up those words ;)
15:34:40 <danharaj> I don't know what the significance is, other than the fact that the latter has way more morphisms and objects.
15:35:00 <edwardk> i'm pretty weak on this side actually
15:35:23 <schell> this may be a duh question but does the GHC API change every HP release?
15:35:52 <intrados> If I want to make a time-sensitive POST, is there an idiomatic way to do that? (retry until success or x seconds/retries)
15:36:15 <danharaj> edwardk: Well I like to think of PSh(FinSet^Op) as "Nested data types with some functoriality condition."
15:36:21 <danharaj> Where you nest with Maybe.
15:36:54 <zett_zelett> Is there a way to "derive" Num for e.g. data Tuple = Tuple Double Double?
15:37:00 <danharaj> Since FinSet^Op is the free cartesian category generated by 1.
15:37:14 <zett_zelett> I basically want to write (a,b) - (c,d) for (a-c,b-d).
15:37:28 <danharaj> hpc: Some day I hope to have an abstruse piece of shit named after me ;)
15:38:19 <shachaf> What is 1?
15:38:33 <shachaf> Is this a thing where you make every set as a finite coproduct 1 + 1 + ...?
15:38:38 <danharaj> yeah.
15:38:56 <danharaj> It seemed like 1 was the quickest way to say "Object with only identity morphism"
15:39:28 <shachaf> OK, 1 as in a terminal category?
15:39:31 <danharaj> yeah.
15:41:13 <shachaf> Oh, you said cartesian, not cartesian closed.
15:41:21 <shachaf> That makes more sense now.
15:41:52 <danharaj> yup
15:42:05 <danharaj> So FinSet^Op models untyped cartesian contexts.
15:44:30 <zett_zelett> Do I understand it correctly, that +, -, *, / can only be used on Num and there’s no way to use it on tuples or something like that?
15:44:46 <danharaj> Here's a fact that might be deeper than I know: day convolution gives you a monoidal structure on [FinSet, Set] (because I'm sick of saying PSh(FinSet^op)) different from the cartesian product, and the monoid objects of that give you cartesian operads aka lawvere theories.
15:46:17 <erisco> zett_zelett, what do you mean by using them on tuples?
15:46:40 <zett_zelett> Say I have type Tuple = (Double, Double).
15:46:51 <erisco> :t uncurry (+)
15:46:52 <lambdabot> Num c => (c, c) -> c
15:46:53 <Axman6> zett_zelett: you're looking at it the wrong way. those are (except for /) all function in the Num class. anything which is an instance of the Num class defines how to use them. there's no reason you couldn't have instance (Num a, Num b) => Num (a,b) where
15:47:08 <shachaf> Well, there are some reasons you wouldn't.
15:47:54 <zett_zelett> http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num
15:48:01 <triliyn> zett_zelett: you could in theory do something like "instance Num a => Num (a,a) where ..."
15:48:04 <zett_zelett> What to with fromIntegral and signum?
15:48:07 <erisco> > let tuplePlus = uncurry (+) in tuplePlus (1, 2) -- is this what you mean zett_zelett?
15:48:08 <lambdabot>  3
15:48:30 <Axman6> zett_zelett: fromIntegral n = (fromntegral n, fromIntegral n)
15:48:54 <zett_zelett> Okay, of course you can do it somehow, it’s just not really natural.
15:49:06 <Axman6> how is it not natural :\
15:49:14 <zett_zelett> erisco: I cannot use + itself, right?
15:49:44 <erisco> zett_zelett, I did use (+), but if you mean (+) (1, 2) then no, because the types do not match
15:49:45 <zett_zelett> Well, because (3,3) doesn’t really represent 3 in (Int,Int).
15:50:13 <zett_zelett> erisco: Yes, I meant that. That’s kinda sad.
15:50:19 <Axman6> zett_zelett: you need to tell us how you want (+) on (Int, Int) or (double, Double) to behave
15:50:39 <zett_zelett> Well, pointwise, naturally.
15:50:47 <erisco> zett_zelett, you can define new operators if you wish
15:51:11 <zett_zelett> It’s not really the same. : – /
15:51:13 <zett_zelett> But yes.
15:51:43 <erisco> Haskell does not have overloading, so you cannot have multiple definitions for (+)
15:51:54 <erisco> (well, + is type classed, but that is slightly different than overloading)
15:52:09 <shachaf> Num is ugly anyway.
15:52:21 <zett_zelett> So, wait, erisco: It is not what I meant, by the way. I misunderstood. And now I see there’s another way of interpreting this.
15:52:36 <zett_zelett> What I really meant is (1,1) + (0,1) = (1,2).
15:52:46 <erisco> oh, that is much different
15:52:46 <ChongLi> erisco: type classes don't give you overloading? hmmm
15:52:56 <ChongLi> what's the distinction?
15:53:06 <zett_zelett> (+) :: (Double a, Double a) -> (Double a, Double a) -> (Double a, Double a).
15:53:08 <erisco> ChongLi, well overloading usually means you can reuse the same name with different type signatures
15:53:24 <erisco> ChongLi, in fact overloading typically requires just that
15:53:35 <Axman6> zett_zelett: Just Double, not Double a
15:53:41 <zett_zelett> Yeah.
15:54:02 <erisco> zett_zelett, I wonder if there is something in Arrows for this
15:54:08 <zett_zelett> I haven’t spent much time with concrete types lately. : – )
15:54:12 <ChongLi> erisco: isn't that picking nits, though?
15:54:23 <startling> Pretty sure you can write Num a => Num (a,a)
15:54:38 <Axman6> instance Num (Double, Double) where (a,b) + (c,d) = (a+c,b+d)
15:54:49 <benmachine> I think a lot of people call type classes overloading and they're not crazy to do so
15:55:01 <zett_zelett> Why can’t you derive Num anyway?
15:55:02 <erisco> ChongLi, yes, but overloading means different things so I was just clarifying. I was saying that you cannot reuse the (+) function name to directly work on tuples
15:55:08 <benmachine> after all, you have (+) :: Integer -> Integer -> Integer and also (+) :: Float -> Float -> Float
15:55:37 <Axman6> zett_zelett: because there's usually many ways to implement it, and it's not obvious which is the one you want derived
15:55:56 <erisco> ChongLi, having said that, it is type classed, so I think you could if you wanted
15:56:16 <Saizan> danharaj: any short definition of Schanuel topos?
15:56:29 <LordBrain> bbl
15:57:02 <ChongLi> erisco: and look at PrintfType
15:57:13 <zett_zelett> I think there should be classes Grp and Rng instead of Num.
15:57:27 <erisco> ChongLi, last time I did that my head went asplode... I knew less Haskell then but I don't want to risk it :P
15:58:24 <ChongLi> erisco: but that's gotta be considered overloading, no?
15:58:50 <dleedev> zett_zelett: that would definitely throw off non-math people like me :)
15:59:11 <dleedev> zett_zelett: but then again, I'd like to learn what Grp and Rng are
15:59:20 <erisco> ChongLi, overloading is more restricted for type classes than in the general sense. You may still call it overloading if you wish
15:59:44 <ChongLi> erisco: I'll grant you that
15:59:54 <scott_> It is overloading, but it's not the ad-hoc overloading you get in C++ and Java
16:00:02 <erisco> yes, ad-hoc
16:01:03 <zett_zelett> dleedev: Rng or rather Ring is just defining (+), (*) as well as 0 and 1, such that associativity and distributivity holds.
16:01:12 <erisco> zett_zelett, foo f a b let (m, n) = a; (p, q) = b in (f m p, f n q)
16:01:26 <erisco> zett_zelett, there may be a fancier way to get this, say with Arrows, but that is the nuts and bolts version
16:02:14 <dleedev> zett_zelett: both + and *, or just one of those?
16:02:14 <startling> "Rng" is sometimes "Ring without an i(dentity)"
16:02:16 <zett_zelett> Yes, Ring is better.
16:02:16 <zett_zelett> No, both.
16:02:16 <zett_zelett> Integers, +, *, 0, 1 form a ring.
16:02:31 <zett_zelett> Ring is basically Num without abs and signum.
16:02:39 <erisco> zett_zelett, what is Grp?
16:02:45 <zett_zelett> And a*b doesn’t have to be b*a.
16:02:58 <ChongLi> ah, so that gets you matrices?
16:03:07 <zett_zelett> For example.
16:03:12 <zett_zelett> Quadratic matrices form a ring.
16:03:23 <startling> ChongLi: it gets you a handful of things.
16:03:32 <erisco> zett_zelett, something to keep in mind is that some things are thrown into type classes for optimisation sake
16:03:42 <zett_zelett> And Grp or Group would be G,*,1,recip or something like that.
16:03:54 <erisco> zett_zelett, imo it is a complete abuse of type classing but practical always wins
16:03:58 <benmachine> something else to keep in mind is "making the mathematicians happier inside" is not really a goal of Haskell
16:04:03 <benmachine> speaking as a mathematician
16:04:11 <Axman6> thank goodness
16:04:21 <startling> honestly there's a handful of situations Group and Ring would have been useful to me.
16:04:28 <zett_zelett> I know, but rings are very common, enrisco.
16:04:38 <ChongLi> sometimes new optimizations are opened up due to limitations
16:04:42 <JakeE> I have a generic power function which seems to work for Ratio types but gives 2 times the correct awnser if doubles are used: http://lpaste.net/98070
16:04:43 <benmachine> it's all very well saying "we should have classes that reflect mathematical practice!" but basically what makes good mathematics and what makes useful software tools needn't be the same thing
16:04:45 <startling> Writing generic code that uses Num provides very few guarantees.
16:04:56 <ChongLi> such as Applicatives and the potential for implicit parallelism
16:05:19 <JakeE> hey sepp2k1! I'm ishkabible from dreamincode
16:05:29 <erisco> zett_zelett, also these good suggestions become mammoth to implement because of legacy =\ just something to consider
16:06:04 <zett_zelett> Yeah.
16:06:15 <erisco> why does a ring need + and *?
16:06:41 <ChongLi> that's how it's defined
16:06:41 <JakeE> anyways. I can't seem to track down the error with the power function. when I preform the computation in ghci step by step I get the write awnser but when I use my generic power function somthing off happens
16:07:01 <zett_zelett> By definition a Ring R is a tuple R = (R,+,·,0,1) such that several (natural) laws hold.
16:07:08 <erisco> ChongLi, fair enough I guess
16:07:13 * hackagebot hackport 0.3.6 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.3.6 (SergeiTrofimovich)
16:07:15 <erisco> any reason to stop at *?
16:07:20 <benmachine> by definition a ring is a one-object abelian category :P
16:07:32 <benmachine> erisco: well, if you have / then you have a field
16:08:09 <erisco> benmachine, interesting but I meant including exponentation and beyond
16:08:19 <ChongLi> is there a book that explains the etymology of all the names of these algebraic structures?
16:08:23 <zett_zelett> There are many reasons. One is that a ring is a natural generalisation of integers which occurs all the time in mathematics and so is an important object to be concerned with.
16:08:30 <johnw> ChongLi: any book on abstract algebra, pretty much
16:08:34 <dleedev> Why is a ring called a ring?
16:08:34 <benmachine> erisco: topological rings may let you define power series, or lie groups might come into it but I've never studied them
16:08:51 <zett_zelett> Exponentiation doesn’t always make sense with rings.
16:08:54 <jfischoff> Is there a easy way to infer the type of TH Exp?
16:08:58 <benmachine> dleedev: I don't know but I know why a group is called a group and it's exactly as moronic a reason as you'd guess
16:09:01 <erisco> zett_zelett, mm, so mathematicians are practical too eh? :)
16:09:02 <jfischoff> Or the kind?
16:09:04 <zett_zelett> Like what’s a matrix to the power of another matrix.
16:09:08 <ChongLi> johnw: hah, back in high school we didn't have time to read all that stuff
16:09:09 <benmachine> well, I know a story, I'm not sure it's true :P
16:09:11 <jfischoff> Kind of a type that is
16:09:25 <ChongLi> it was just "jump to page 342 and do all the exercises"
16:09:27 <benmachine> zett_zelett: there is such a thing as matrix exponentiation, at least
16:09:37 <benmachine> a matrix exponential function, I mean
16:09:52 <zett_zelett> benmachine: Yeah, if you hold a complete topological ring.
16:10:20 <Gorroth> > let x = x ++ "meow! " ++ x in "cats go.. " ++ x
16:10:24 <lambdabot>  mueval-core: Time limit exceeded
16:10:26 <Gorroth> nice
16:10:32 <Gorroth> > let x = "meow! " ++ x in "cats go.. " ++ x
16:10:33 <lambdabot>  "cats go.. meow! meow! meow! meow! meow! meow! meow! meow! meow! meow! meow!...
16:10:39 <erisco> zett_zelett, what is your plan for 3-tuples and up? with regards to the point-wise operations
16:10:50 <Axman6> > cycle "Meow! "
16:10:51 <lambdabot>  "Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meo...
16:11:07 <zett_zelett> They would be still rings?
16:11:14 <benmachine> the story I've heard wrt groups is that Galois was writing his stuff on conditions for soluble polynomials and said "Consider a group of permutations" and everyone else went "ah! a group!"
16:11:49 <ChongLi> benmachine: rather unfortunate
16:11:54 <erisco> zett_zelett, no I mean for your Haskell code. I am suggesting that if you need arbitrarily sized tuples, it may be more convenient to use lists, and then you can generically define a higher order point wise operation
16:12:03 <ChongLi> group is such a generic term
16:12:09 <zett_zelett> They went "Ah! A group." much, much later, though.
16:12:21 <benmachine> ChongLi: indeed. I had a fellow student whose native language was (I think) Hebrew in which the words "group" and "set" were literally identical
16:12:33 <johnw> In answer to erisco's question 'Why stop there': http://mathoverflow.net/questions/72867/an-image-of-the-hierarchy-of-algebraic-structures
16:12:40 <ayako> monoid is apparently also unforunately named :(
16:12:43 <benmachine> of course now we have "category" which is much better.
16:12:58 <zett_zelett> What would be a better name for a Group?
16:12:59 <shachaf> benmachine: The words in common use or mathematical use?
16:13:03 <ChongLi> benmachine: that's a big issue with a lot of math/cs terms, actually
16:13:04 <dleedev> what would be better names for group, monoid, and category?
16:13:04 <danharaj> Saizan: look at the category with objects the finite sets with only injective functions, call that I, look at [I, Set], only consider pullback-preserving functors as your objects.
16:13:25 <benmachine> shachaf: pass, I just remember them being confused
16:13:26 <erisco> johnw, hey cool diagram I'm saving that :)
16:13:30 <ChongLi> monoid is fine
16:13:48 <shachaf> "monoid" is awful because it ends in "oid"
16:13:55 <dleedev> are group and monoid similar?
16:14:04 <dleedev> It seems like monoid is a group minus the 4th law
16:14:06 <zett_zelett> Why does that make it awful, shachaf?
16:14:20 <danharaj> because -oid in modern terminology means "Now generalize to a category"
16:14:21 <S11001001> such mathmatcal
16:14:22 <zett_zelett> Yes.
16:14:23 <shachaf> Because "oid" often means a categorification of some sort, as in groupoid.
16:14:36 <scott_> I found this diagram useful, although it doesn't have rings and fields: http://en.wikipedia.org/wiki/Template:Group-like_structures
16:14:37 <ChongLi> what about ∞-groupoids?
16:14:38 <johnw> dleedev: yes, a group is a monoid plus an "inverse" for every element, such that a * a-1 = e
16:14:48 <shachaf> What about them?
16:14:50 <zett_zelett> A group is a monoid where you can revert operations.
16:15:05 <shachaf> Anyway, someone should tell me how colists relate to monoids. Other than being strange.
16:15:16 <johnw> shachaf: how is a Colist defined?
16:15:17 <danharaj> ∞-Groupoids are ∞-Categories that have all morphisms invertible.
16:15:32 <JakeE> data Colost a = Cons a (Colist a)
16:15:36 <Saizan> danharaj: that sounds oddly familiar
16:15:36 <shachaf> A colist is a possibly-infinite list.
16:15:39 <zett_zelett> What is a ∞-Category, though?
16:15:41 <dwcook> We could just call monoid mon and category monoid.
16:15:43 <shachaf> Like [a] in Haskell, roughly.
16:15:48 <johnw> is a colist what we often call a Stream in Haskell?
16:15:49 <dwcook> </facetious>
16:15:53 <johnw> i.e., List without nil?
16:15:58 <shachaf> No, it's what we call a list in Haskell.
16:16:06 <benmachine> all data in Haskell is secretly codata
16:16:11 <benmachine> well, most
16:16:15 <shachaf> All codata in Haskell is secretly data.
16:16:20 <JakeE> haskell mixes recursion and corecursion so a list in haskell is also ao colist
16:16:28 <benmachine> shachaf: wha
16:16:29 <ChongLi> only unlifted types aren't?
16:16:32 <danharaj> zett_zelett: http://ncatlab.org/nlab/show/infinity-category
16:16:34 <zett_zelett> What is corecursion?
16:16:45 <JakeE> ones = 1 : ones
16:17:06 <shachaf> benmachine: nothing much
16:17:30 <jfischoff> I think I finally get what an ∞-Groupoids is
16:17:33 <benmachine> zett_zelett: it's difficult to summarise quickly, but basically you recurse inside a bigger result instead of on a smaller argument
16:17:41 <JakeE> that is an example of corecursion. I know little about it however. best let google do the talking. some exclent papers by DA Turner show how seperating recursiona and corecursion can lead to fuller featured total functional programing
16:17:43 <zett_zelett> So, a ∞-category is the structure obtained by not only considering arrows, but also functors, natural transformations, and so on?
16:17:46 <zett_zelett> Hm, …
16:17:48 <johnw> from #haskell in Sept: "elliott: a list type that has to be of finite length is a real data list. a list type that can be infinite is a colist, which is codata. unending streams are codata"
16:18:12 <shachaf> Yes, that is still true 4 months later.
16:18:15 <benmachine> zett_zelett: you can recurse on whatever argument you like, but you can only do so inside a constructor
16:18:21 <shachaf> We need to innovate our terminology more quickly.
16:18:22 <benmachine> so ones = 1 : ones is corecursion
16:18:32 <JakeE> it is an example of corecursion
16:18:38 <ChongLi> and its result is codata?
16:18:41 <shachaf> Anyway, the type of lists of As is the free monoid on A.
16:18:43 <JakeE> yes
16:18:52 <shachaf> What's the type of colists of As? Is it a special thing of some sort?
16:19:23 <ChongLi> and what is the word to describe calling "take n" on codata?
16:19:39 <ChongLi> or the result of that?
16:19:40 <JakeE> in haskell lists are colists becuase there is no seperation in data/codata and recursion/corecursion so [A] but in other languges that do make a ditinction you have (list a) and (colist a)
16:19:45 <danharaj> shachaf: comonoids in Hask are all trivial so
16:20:00 <benmachine> ChongLi: you can see take n as corecursive, I think
16:20:05 <shachaf> danharaj: Yes, I'm not expecting it to be a comonoid.
16:20:09 <benmachine> maybe?
16:20:12 <benmachine> or recursive on n
16:20:14 <shachaf> danharaj: (Er, well, I am. But I don't care about it.)
16:20:19 <jonkri> What am I supposed to do if none of my possible values are suitable for the noMsg/strMsg methods of the Error typeclass?
16:20:33 <shachaf> danharaj: But it's a monoid, where zx = z for any infinite list z and any list x.
16:20:38 <JakeE> take n on strictly infinite codata (codata Colist a = Cons a (Colist a)) can't be defined.
16:20:38 <ChongLi> benmachine: I'd come to understand recursion as analyzing something down to a base case
16:20:57 <danharaj> huh
16:20:59 <ChongLi> and corecursion as synthesizing starting out from the base case
16:21:00 <JakeE> take n on potentially infinte codata however has just the type you would think
16:21:04 <benmachine> ChongLi: sounds reasonable
16:21:16 <tippenein> ChongLi: exactly how I understand the 2
16:21:24 <shachaf> danharaj: I just wonder whether it's a special monoid in some way, like the monoid of finite lists is free.
16:21:30 <danharaj> yeah
16:21:33 <danharaj> hm.
16:21:47 <benmachine> shachaf: it strikes me as interesting that it's not cancellative like finite lists are
16:21:49 <danharaj> it's not a very well behaved monoid.
16:21:58 <shachaf> If you have one generator you end up with conaturals, i.e. {0,1,...,∞}
16:21:59 <JakeE> codata Colist a = nil | Cons a (Colist a) means that take would have type Int -> Colist a -> Colist a
16:22:22 <shachaf> Where ∞ is a "zero" of the monoid (∞x = x∞ = ∞)
16:23:03 <shachaf> benmachine: Right, it's a bit of a strange structure.
16:23:15 <benmachine> it's not left-cancellative and it's not right-cancellative, but in sort of different ways :P
16:23:33 <ChongLi> so in a total language like Agda
16:23:52 <ChongLi> we can talk about distinctions between data and codata?
16:23:58 <ChongLi> and check them statically?
16:23:59 <JakeE> not sure about Agda
16:24:06 <benmachine> ChongLi: Agda used to have a codata keyword, but I think it went away?
16:24:15 <benmachine> I think it does have some codata, but I'm not sure how/if it works
16:24:17 <JakeE> in fact I recall that Agda simply dosn't allow infinte data structures but I could be wrong
16:24:34 <benmachine> normal data in Agda is bona-fide finite data
16:24:42 <benmachine> but there's the partiality monad which I believe is codata
16:24:43 <ChongLi> what about IO?
16:24:48 <ChongLi> ahh
16:25:08 <ChongLi> seems like almost any sort of IO you'd want to do would result in codata, no?
16:25:08 <shachaf> You should understand these two types to understand the data vs. codata thing: newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }; data Nu f = forall x. Nu x (x -> f x)
16:25:27 <shachaf> In Haskell they are isomorphic.
16:25:37 <Gorroth> > "Cats go " ++ (take 10 (cycle "Meow! "))
16:25:38 <lambdabot>  "Cats go Meow! Meow"
16:25:45 <Gorroth> oh... right
16:25:56 <Gorroth> forgot that it's counting each char as an element :-P
16:26:06 <JakeE> ChongLi: most would at the very least; codata has been proposed as a way to allow total functional languages to handle an abitariy number of "requests"
16:26:20 <Gorroth> > "Cats go " ++ (take (10*6) (cycle "Meow! "))
16:26:21 <lambdabot>  "Cats go Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! "
16:26:24 <benmachine> > "Cats go " ++ concat (take 10 (repeat "Meow! "))
16:26:25 <lambdabot>  "Cats go Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! "
16:26:35 <ChongLi> JakeE: and a program running forever on those requests would be "coterminating"?
16:26:40 <benmachine> > "Cats go " ++ concat (replicate 10 "Meow! ")
16:26:41 <lambdabot>  "Cats go Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! "
16:26:54 <JakeE> not "coterminating" but "productive"
16:26:57 <Gorroth> > "Cats go Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow!"
16:26:58 <lambdabot>  "Cats go Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow! Meow!"
16:27:13 <Gorroth> I think my last solution scales.
16:27:13 <benmachine> Gorroth: well yes that is also an approach you can take
16:27:15 <JakeE> these programs would not terminatie but run forever. we only care that each rquest terminates
16:27:28 <Gorroth> benmachine: ;-)
16:27:44 <ChongLi> ah
16:27:46 <JakeE> basiclly productive means that pattern matching always terminates
16:28:19 <ChongLi> JakeE: does that mean you'd have to statically include things like timeouts?
16:28:20 <benmachine> "write a program that calculates the first ten primes" main = print [2,3,5,7,11,13,17,19,23,29]
16:28:38 <benmachine> (is it bad that I find it harder to count to ten than recite prime numbers)
16:28:40 <JakeE> ChongLi: not sure
16:28:48 <Rembane> I actually have something like that in a solution for a Project Euler problem
16:29:18 <ChongLi> for the case that a user's request drops partway through the handshake or what-have-you
16:29:46 <Gorroth> benmachine: your algorithm is very scalable :-P
16:29:46 <JakeE> ChongLi: in theory a timeout should not occur on the codes end and such a prue language would make no requests of other code for a timeout to occur
16:29:52 <ChongLi> and then, of course, there's the issue of memory exhaustion
16:30:17 <ChongLi> or just resource exhaustion in general
16:30:22 <ChongLi> sockets, file handles
16:30:54 <JakeE> ya exhaustion of resources is the issue everyone passes up
16:31:04 <benmachine> ChongLi: I think the Haskell solution to IO works in Agda too
16:31:37 <ChongLi> benmachine: I guess Agda can't really guarantee termination then?
16:31:45 <benmachine> ChongLi: it depends what you mean
16:32:05 <benmachine> you wouldn't want Agda to "guarantee" that your "pause forever" program terminated
16:32:05 <JakeE> in general you have to hide away all of the details of the outside world for a total functional programing language. the idea is that a small impartive program would call the total language for each step
16:32:50 <benmachine> ChongLi: Agda functions are total. you view an IO-using program as a bunch of total callbacks computing other total callbacks computing "request tokens" that can then be acted on by some weird machine
16:32:51 <ChongLi> I guess my idea of termination is too concrete
16:33:05 <benmachine> totality is more precise a term than termination
16:33:36 <benmachine> you don't really care about whether or not your function stops, what you really want is when f : Bool -> Char and you give f a Bool, you really do get a Char
16:33:42 <ChongLi> JakeE: that's actually how I think about Haskell sometimes
16:33:49 <JakeE> so a function "handleRequests : Colist Request -> Colist Response" could be made and a wrapper program would translate what came from a socket to a request and send the "response" off
16:33:51 <ChongLi> even though it's not toal
16:34:10 <benmachine> JakeE: that's actually how IO worked in a very early version of Haskell
16:34:17 <benmachine> wait
16:34:20 <benmachine> no
16:34:27 <ChongLi> yeah, wasn't it?
16:34:29 <benmachine> we had main :: [Response] -> [Request]
16:34:31 <shachaf> Except from the other perspective.
16:34:41 <ChongLi> but lists in Haskell are colists
16:34:47 <ChongLi> as mentioned earlier
16:34:54 <benmachine> you *produce* requests, and give responses
16:34:57 <benmachine> er
16:35:00 <ChongLi> oh
16:35:00 <benmachine> process responses
16:35:01 <JakeE> a really early version had main :: String -> String lol
16:35:02 <ChongLi> right
16:35:32 <benmachine> but it's really super fragile because you can look too far ahead in the response stream and then your handler goes "I dunno lol" and explodes
16:35:44 <ChongLi> JakeE: perfect for your shell pipelines, I guess
16:36:24 <ChongLi> benmachine: yeah, it reminds me of the banking machine example from SICP
16:36:57 <ChongLi> how do you schedule a multi-user banking system in a completely pure system?
16:37:33 <JakeE> well if everyone is done talking about IO I've got this generic power function that I can't quite figure out how to do right.
16:37:37 <JakeE> http://lpaste.net/98070
16:38:01 <JakeE> pow 3.3 (22 % 10) works but pow 3.3 2.2 gives twice the correct awnser, any ideas?
16:40:19 <ChongLi> okay let me see here
16:40:29 <danharaj1> :t pow
16:40:30 <lambdabot> Not in scope: `pow'
16:41:12 <JakeE> the pow function in question has type (Real a, RealFrac b) => b -> a -> b
16:42:55 <JakeE> brb
16:43:36 <ChongLi> yeah I'm just getting type errors here
16:45:44 <raphie> anyone have a recommended learn-monads resource?
16:46:28 <ChongLi> raphie: http://dev.stephendiehl.com/hask/
16:46:37 <ChongLi> this + asking in here
16:47:02 <ChongLi> it's probable that you need to learn how Haskell's type system works, first
16:47:31 <ChongLi> that's okay though
16:48:28 <ChongLi> I think too many Haskell/Monad tutorials try to gloss over or skip past actually explaining what type variables are and how they're completely different from term variables
16:48:32 <JakeE> you get type errors on that code?
16:48:40 <raphie> ChongLi: I'm familiar with type type system. type variables as in Maybe a?
16:49:02 <ChongLi> JakeE: oh, just a sec
16:49:22 <ChongLi> JakeE: yeah, I made a typo when I pasted it into vim >_<
16:49:35 <ChongLi> raphie: yes, as in a
16:49:56 <rasfar> funny, I get type errors and I think I pasted correctly...
16:49:58 <ChongLi> Haskell's type system is kinda like a logic programming language
16:50:47 <JakeE> O whoops. I guess I made some changes before I posted it. apprently there are some type errors
16:51:05 <roboguy_> ChongLi: yeah, multiparameter type classes remind me of prolog sometimes
16:52:51 <raphie> is there a way to use other constructors in data definition within those constructors? that probably makes no sense, here's the code: https://gist.github.com/RaphiePS/e37330d7d89c028cab7c
16:53:00 <JakeE> I tried too quickly writing a bit of my code in point free style and goofed up a bit
16:53:26 <roboguy_> raphie: JString is a data constructor, not a type
16:53:40 <JakeE> http://lpaste.net/98070
16:53:46 <JakeE> sorry about that
16:53:50 <raphie> roboguy_: ooooh yes I forgot. is there a way to constrain it?
16:53:56 <roboguy_> raphie: JString is sort of like a function (with some extra stuff that allows pattern matching) such that JString :: String -> JValue
16:54:19 <raphie> writing a json parser if you can't tell :)
16:54:41 <geekosaur> why write one? aeson works well, and this is not really a wheel worth reinventing
16:54:57 <raphie> well I want to try my hand at writing a parser, never done that before
16:55:00 <JakeE> has anyone ever thought to teach that functions and constructors define new syntax for the rewrite system and that constructors are "normal form" expressions and that functions are reducable expressions?
16:55:06 <raphie> JSON seems like a nice combo of simple + common + useful
16:55:25 <roboguy_> raphie: oh, also avoid tabs at all costs when writing haskell. you'll run into problems
16:55:34 <merijn> JakeE: Yes
16:55:36 <raphie> roboguy_: just noticed that and switched to spaces :)
16:55:41 <geekosaur> maybe. except I get the feeling JSON has its annoying corner cases
16:55:47 <merijn> JakeE: Because I know languages that actually are implemented like that
16:56:04 <raphie> geekosaur: like what?
16:56:05 <merijn> JakeE: Also, TaPL uses that approach
16:57:10 <JakeE> O neat! I'll have to read that. my boss recomended that book to me a while back
16:57:10 <geekosaur> raphie, I',m inferring that from the Aeson docs
16:57:21 <geekosaur> but also, I know it's based on Javascript expressions, and Javascript itself has mnany fun corner cases
16:57:29 <roboguy_> raphie: Real World Haskell has a chapter about writing a JSON parser. that might help some: http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html
16:57:59 <roboguy_> raphie: they have JObject as JObject [(String, JValue)]
16:58:24 <raphie> roboguy_: nice! I'll follow along with that
16:58:35 <jfischoff> geekosaur: the main corner case I know of is that JSON supports a larger set of unicode then javascript
16:58:43 <jfischoff> s/then/than
16:58:51 <geekosaur> in any case, you'll find that there are no entirely satisfactory ways to deal with this; you can't break a type up the way you are trying to, and if you use a typeclass and type instances then you get into other kinds of trouble quickly
16:58:59 <geekosaur> (such as the existential antipattern)
16:59:17 <raphie> geekosaur: this is the json spec (graphically) http://json.org/
16:59:26 <raphie> pretty simple
17:02:25 <ChongLi> clear; ghci read.hs
17:02:33 <raphie> is there anything like go fmt for haskell that will format your code nicely?
17:02:33 <ChongLi> oh, right
17:02:36 <ChongLi> silly Vimux
17:02:51 <ChongLi> stylish-haskell
17:03:33 <ChongLi> https://github.com/jaspervdj/stylish-haskell
17:05:14 <pavonia> Is there no other way of manipulating the GHCi prompt than literal strings with %s replacement?
17:05:44 <geekosaur> not currently, at least
17:06:21 <pavonia> too bad
17:06:40 <ChongLi> yeah, it'd be interesting if you could set the prompt to be the result of an IO action
17:07:04 <ChongLi> it'd be like all the crazy stuff people do with bash prompts
17:09:29 <jle`> raphie: it is commonly considered a bad idea to constrain data types
17:09:39 <JakeE> anyway ChongLi. the type errors should be fixed if you check again. I got hasty with making some of my code point free
17:09:52 <jle`> raphie: in any case you probably don't want a jstring there
17:10:04 <jle`> you don't want something of the same 'type' of a json value as a key
17:10:10 <ChongLi> JakeE: yeah I commented out the sigma functions
17:11:17 <JakeE> they are not used anyhow (althought I did use them to write a pow function that worked for values bases between 1 and 2)
17:11:49 <ChongLi> clear; ghci read.hs
17:11:54 <ChongLi> gah
17:11:56 <ChongLi> hmm
17:12:16 <ChongLi> I guess Vimux has laid claim to my IRC pane :)
17:12:20 <schell> how do you hide a package from within a .hs file?
17:12:42 <hpc> schell: you generally don't worry about packages at the source level
17:12:47 <hpc> hide it in the cabal file
17:13:14 <schell> huh - i'm using hdevtools and it's telling me Control.Monad.State is an ambiguous module (mtl and monads)
17:15:24 <JakeE> ah I found the issue I think. I was assuming that toRational 2.2 would equal (22 % 10) but this is not the case thanks the the craziness of doubles
17:15:54 <ChongLi> JakeE: oh, right
17:16:11 <ChongLi> and so your root function gets a giant integer
17:16:13 <JakeE> and so I end up computing (root <insert huge number here> 2.2) which ends up being too small to accuratly represent (and is in fact 2 times to big)
17:16:49 <JakeE> well that took a day and a half to figure out...I feel I need to hoan my debugging skills a bit lol
17:17:17 <ChongLi> the IEEE-754 standard can bring even the most seasoned of programmers to tears
17:18:01 <schell> hpc: hiding it with ghc-pkg did the trick
17:18:42 <JakeE> I feel like hardware support for pairs of 32-bit integers would be a lot better method of representing "real" numbers
17:19:15 <JakeE> that is hardware supported add, mul, sub, divide, etc... for ratios of 32-bit integers
17:21:04 <ChongLi> that doesn't give you nearly the same range
17:21:44 <roboguy_> JakeE: isn't that what Ratio Int is?
17:21:49 <Axman6> only from 1/2^32 to 2^32 (and infinities I guess)
17:22:22 * hackagebot Shu-thing 1.1.3 - A vector shooter game  http://hackage.haskell.org/package/Shu-thing-1.1.3 (AlanHawkins)
17:22:35 <JakeE> ya range would not be as good I grant you but the accuracy and intutiveness would be much nicer
17:22:43 <stolaruk> "cabal install hdevtools" gives me "cabal: Could not resolve dependencies: trying: hdevtools-0.1.0.5" and immediately bombs. Has anyone seen this before?
17:22:57 <jonkri> What is the set of characters of A-Z and 0-9 called? (Not case sensitive.)
17:22:59 <ChongLi> whereas a Double can go from 2E-1022 to 2E1023
17:23:07 <JakeE> roboguy_: Ratio Int is implemented with software and thus is no where close to as fast as Double
17:23:14 <roboguy_> jonkri: alphanumeric
17:23:41 <roboguy_> JakeE: oh, I missed the hardware support part
17:23:51 <jonkri> roboguy_: Cheers. :)
17:24:16 <JakeE> bleh...I just can't help but think there is a better solution than IEEE floating point numbers
17:26:10 <roboguy_> JakeE: the speed difference probably isn't too bad. especially since it's only two 32 bit integers
17:26:22 <roboguy_> per ratio, anyway
17:26:48 <ChongLi> the other issue with ratios is that you can overflow easily
17:27:22 * hackagebot HGL 3.2.0.4 - A simple graphics library based on X11 or Win32  http://hackage.haskell.org/package/HGL-3.2.0.4 (AlanHawkins)
17:27:27 <ChongLi> long chains of expressions tend to overflow, even if you reduce to least terms at every step
17:28:46 <tvynr> When I run "cabal configure", I get "sh: 0: Can't open configure".  Google hasn't been very helpful so far.  Does anyone have any suggestions as to how I diagnose this problem?
17:29:05 <dcoutts_> tvynr: OS?
17:29:15 <tvynr> dcoutts_: Debian stable
17:29:15 <ChongLi> sounds like the bourne shell
17:29:19 <ChongLi> do you have bash?
17:29:20 <dcoutts_> tvynr: looks like a package that has a ./configure script
17:29:30 <dcoutts_> and failing to run ./configure for some reason
17:29:37 <tvynr> dcoutts: Thing is, I can't seem to get any info on *which* package.
17:29:49 <ChongLi> bash will give a more helpful error message :)
17:30:07 <dcoutts_> tvynr: if you're running cabal configure then it's the one in the local dir
17:31:38 <tvynr> I'm not sure how my cabal file could be causing this.
17:32:07 <dcoutts_> tvynr: do you specify a build-type in the .cabal file?
17:32:24 <tvynr> dcoutts, ChongLi: I have some bash commands that are being executed with "cabal-dev" but no context as to how they are executed.
17:32:37 <tvynr> dcoutts: It's build-type Make, apparently.
17:32:48 <ChongLi> ah, there you go
17:32:54 <dcoutts_> tvynr: is that what you want?
17:33:09 <egosum> is anyone familiar with Clojure's `reductions` [1]? is there a similar function in Haskell-land, or is something else isomorphic preferred/is this code-smell? [1]:http://clojuredocs.org/clojure_core/clojure.core/reductions
17:33:10 <stolaruk> Is anyone here using Fedora 20?
17:33:47 <JakeE> reductions looks like it could be easily implemented using fold
17:33:57 <geekosaur> egosum, that's more or less a fold
17:34:05 <egosum> JakeE: geekosaur: definitely could
17:34:05 <roboguy_> egosum: scanl and scanr
17:34:14 <tvynr> ChongLi, dcoutts: I think you've found the trouble for me.  The git shows that line as having changed.  My IDE probably threw a nutty and did this at some point.
17:34:22 <tvynr> ChongLi, dcoutts: Thanks.  :)
17:34:28 <roboguy_> egosum: it looks like reductions is specfically scanl1
17:34:34 <dcoutts_> tvynr: ok, so reset it to build-type: Simple
17:34:36 <egosum> roboguy_: perfect, yes, thank you
17:34:41 <geekosaur> actually yes, scan
17:34:54 <geekosaur> I missed that it was more than just reduce
17:39:58 <startling> can I set the default size of the inf-haskell-mode interactive buffer?
17:40:02 <startling> (for emacs).
17:44:36 <monochrom> I did (add-hook 'comint-mode-hook '(lambda () (setq comint-buffer-maximum-size 10000))) a long time ago, before inf-haskell-mode existed. it works for all inferior modes, not just haskell's.
17:44:47 <athan> noob question: how do I make an alias for a string that I could use within my code?
17:44:57 <athan> I'd like to be able to do something like this:
17:45:02 <athan> default :: String
17:45:07 <athan> default = "foo.txt"
17:45:11 <hpc> do that
17:45:14 <athan> but I get a syntax error.
17:45:21 <tvynr> athan: Just an alias would be "type MyAlias = String"
17:45:23 <hpc> but not with the name of "default"
17:45:32 <startling> monochrom: that's not quite what i mean.
17:45:33 <tvynr> athan: Oh; you mean a value.  :)
17:45:41 <athan> yeah sorry :P
17:45:51 <athan> is default a reserved keyword?
17:45:53 <tvynr> athan: No problem; I misunderstood.  :)
17:46:13 <erisco> athan, yes
17:46:13 <monochrom> yes, "default" is a reserved word. pick another name.
17:46:15 <startling> monochrom, when I do C-c C-l, a buffer opens below my current one. It's exactly half the size of the current window. I want to make it e.g. 10 rows tall instead.
17:46:23 <athan> ahhh awesome. Thank you!
17:46:25 <monochrom> then I don't know
17:46:43 <athan> "parse error on '='" >.<
17:47:36 <startling> monochrom: searching for comint seems to get better results, though, so thanks!
17:48:54 <monochrom> until the day the computer knows your intention, it is not going to figure out which token is the wrong token.
17:49:43 <monochrom> and when one day the computer knows your intention, your programming skill will not be needed anyway.
17:50:23 <JakeE> who is to say that intention is deciable?
17:50:25 <monochrom> programming skill will then become, like, swimming skill
17:52:00 <monochrom> you will still program and swim for recreation, and there will be Olympic matches for programming and swimming. but, it is not like you will get paid for programming or swimming all day, except possibly for a few athletes.
17:52:01 <jle`> like whoa
17:52:27 <JakeE> "Olympic matches for programming" I'm gonna start training now
17:52:29 <athan> hmm, I got another question
17:52:44 <athan> so you know how some datatypes are just aliases for Strings
17:52:48 <athan> like FilePath
17:53:00 <athan> they implement the typeclass IsString
17:53:13 <athan> but IsString only provides `fromString` as a function
17:53:21 <athan> is there any way I could do something like `toString`?
17:53:38 <athan> I'd simply just like to putStrLn a FilePath :S
17:53:42 <monochrom> that is probably called "Show"
17:53:45 <jle`> you can already do that
17:53:50 <JakeE> I actully have a major issue with that concept in other typeclasses, namely the number stack
17:53:59 <jle`> FilePath is basically a lexical alias
17:54:08 <jle`> (maybe i am wrong)
17:54:14 <athan> LOL
17:54:23 <athan> *smacks self*
17:54:30 <athan> thank you
17:54:35 <ParahSailin> there is another FilePath somewhere that is not a type synonym for String
17:54:40 <JakeE> to me being fractional should not mean that you can hold every rational (and this is how it is used too) so the function should be "toRational" not "fromRational" for fractional
17:54:58 <JakeE> another typeclass like AproxRational should be used for "fromRational"
17:55:30 <JakeE> likewise not all strings are file paths (well, semanticlly speaking) but all filepaths are strings so it should be "toString" not "fromString"
17:55:40 <JakeE> </rant>
17:56:22 <monochrom> we are too lazy to make FilePath its own type
17:56:41 <monochrom> but ideally FilePath should be its own type
17:57:12 <ParahSailin> well the point of the IsString thing is to let you type a string literal in code and use it with OverloadedStrings
17:57:17 <ChongLi> monochrom: isn't that the case with all these little isssues? backwards compatibility
17:58:02 <athan> hahahaha.
17:58:07 <JakeE> ?
17:58:27 <athan> Haskell needs to get born again
17:58:29 <athan> as...
17:58:31 <athan> Curry!
17:58:32 <monochrom> there would be no worry about backwards compatibility if we were not lazy on day 1.
17:58:47 <JakeE> "bah" born again haskell
17:58:53 <ChongLi> monochrom: or you could say we weren't lazy enough
17:59:00 <athan> "Curry -- the programming language that will stink up your whole apartment complex."
17:59:07 <ChongLi> in that we should have waited until now to commit to a decision :)
17:59:21 <JakeE> then I can write an extension to "bah" called "Humbug"
17:59:51 <athan> hahahaha
18:00:47 <JakeE> also netflix needs a chat window so I can watch shows AND chat
18:01:47 <monochrom> chat with whom?
18:01:49 <startling> emacs needs a netflix-mode
18:01:58 <monochrom> hahahaha startling wins
18:02:10 <startling> then you can just use erc or whatever. :)
18:02:28 <jlamothe> Does Haskell have anything similar to a ruby Gemfile?  I know there's cabal, but I'd like to be able to pull my code directly from GitHub.
18:02:39 <monochrom> plus, you can also watch shows and write code
18:03:08 <monochrom> I don't know ruby or gemfile.
18:03:16 <blaenk> jlamothe: not as far as I know
18:03:27 <blaenk> most packages on hackage/specified in cabal are sourced from github though
18:03:53 <Axman6> It'd be quite nice if we had a system based around git. it'd make getting patches people are making to fix their local versions back into dev much easier
18:04:11 <blaenk> jlamothe: there's this https://github.com/yesodweb/cabal-meta
18:04:19 <ChongLi> Axman6: like the nixpkgs git repo?
18:04:41 <Axman6> I don't know what that is
18:05:07 <ChongLi> nixpkgs is a package database for the nix build system for the nixos operating system
18:05:14 <ChongLi> it's hosted on github
18:05:25 <ChongLi> and really easy to create patches and submit pull requests
18:06:18 <ChongLi> nix itself is a purely functional package manager
18:06:30 <lovewithacaveat> i have a function that i am thinking of naming "generateListWithLengthXContainingOnesUntilIndexKandZeroesAfter" -- should i name it something else? why or why not?
18:06:31 <ChongLi> it's a pretty neat concept
18:06:45 <startling> jlamothe: no, usually you install things locally and then do things.
18:06:53 <startling> I wish we could install from git repositories though.
18:06:54 <Axman6> lovewithacaveat: you've been infected by Objective-C
18:07:01 <startling> it's so nice. :(
18:07:29 <lovewithacaveat> Axman6: maybe, maybe. what should i name it if i want to be all functional?
18:08:15 <simpson> lovewithacaveat: I'm thinking that maybe you want to just itertools it up?
18:08:25 <Axman6> lovewithacaveat: i'd call it ones k = replicate k 1 ++ repeat 0
18:08:27 <simpson> lovewithacaveat: Also, what does the list *mean*; what does it represent?
18:08:55 <lovewithacaveat> simpson: it's just a list
18:09:02 <startling> simpson: ah, itertools.generate_list_with_length_x_containing_ones_until_index_k_and_zeroes_after. classic.
18:09:05 <simpson> lovewithacaveat: Why are you making it?
18:09:06 <lovewithacaveat> Axman6: i want to name it something compact though, because i have to use that function a lot
18:09:30 <simpson> startling: chain(repeat(1, k), repeat(0)) # C'mon, I'm not *that* silly.
18:09:34 <Axman6> onesThenZeros :: Int -> [Int] says everything you need imo
18:09:35 <simpson> lovewithacaveat: Yes; what's it for?
18:09:39 <lovewithacaveat> simpson: it represents the counts of objects, and sub-objects that may be found in a string of characters
18:09:49 <lovewithacaveat> Axman6: i agree, that was beautiful
18:09:52 <simpson> Oh, hey, this is #haskell, not #python. Sorry.
18:10:01 <Axman6> tut tut tut
18:10:11 <lovewithacaveat> simpson: hehe, i am still stuck in python mode
18:10:42 <Axman6> lovewithacaveat: it's worth remembering that types tell you a lot and can make your names a lot smaller
18:10:43 <simpson> lovewithacaveat: So why not objectCount?
18:10:51 <lovewithacaveat> Axman6: simpson my last supervisor worked a lot with C++ before switching over to python. he made me read this book that said "you should always name your functions and variables nice long things because we have copy+paste"
18:11:12 <Axman6> the man's not a smart man
18:11:13 <lovewithacaveat> simpson: because it has to be added up with other objectCounts, and in reality it is just a list of 1s and 0s
18:11:24 <monochrom> digital signal processing people call it a pulse of width k.
18:12:07 <lovewithacaveat> monochrom: heh, i did think of calling it something similar at first "on until index k, zero after"
18:12:19 <lovewithacaveat> monochrom: "off after"
18:12:38 <Axman6> anything wrong with onesThenZeros?
18:12:43 <lovewithacaveat> Axman6: anyway axman, thanks for that heuristic, good tip, will keep it mind. thanks everyone else.
18:12:53 <lovewithacaveat> Axman6: nope, i love it. i am going to use it. nothing wrong with it at all.
18:13:01 <Axman6> good to hear
18:13:13 <Axman6> I assume ym cheque's in the mail?
18:13:16 <Axman6> my*
18:13:34 <lovewithacaveat> Axman6: no. open source. no royalties.
18:13:45 <monochrom> even better, the cheque is in the email
18:13:53 <lovewithacaveat> lol
18:14:03 <monochrom> even better, a picture of the cash is in the email
18:14:29 <lovewithacaveat> what more could you want than my gratuitous thanks?
18:14:36 <lovewithacaveat> what could be more precious than me?
18:14:45 <lovewithacaveat> anyway, time to go back to work. ty again everyone.
18:15:22 <Axman6> a picture of a spider with 7 legs is on the mail at least, surely?
18:15:48 <monochrom> it seems destructive to mail a spider
18:15:55 * derdon gets that reference :)
18:16:06 <Axman6> =)
18:16:15 <monochrom> ah damn obscure insider references
18:16:31 <Cale> http://www.27bslash6.com/images/spiderdrawing.gif
18:16:37 <derdon> monochrom: you just need to be an internet addict
18:16:56 <monochrom> I can play a hundred references that only I recognize. it's too easy.
18:17:02 <Cale> http://www.27bslash6.com/overdue.html
18:17:47 <monochrom> just by, like, drawing from a few animes from 1960s Japan, so that none of you ever knew
18:18:17 <monochrom> or 1970s Hong Kong TV shows
18:19:31 <monochrom> then again, I guess the point is the smug self-congratulating assurance that no one else recognizes them.
18:19:32 <Axman6> woah... watching the latest video for the Mill architecure.. it seems they have Maybe at a hardware level :0
18:19:52 <derdon> well, maybe they have
18:20:17 <Axman6> monochrom: read Cale's link, it's quite entertaining
18:24:35 <monochrom> a certain famous artist in ancient China was able to convince restaurants etc to accept his drawings as payments.
18:25:27 <Axman6> hmm, this metadata talk on the Mill is quite cool. Data carries around its flags (such as div by zero for FP ops) and info about whether the data is actually a result (NaR, Not a Result) or whether the data doesn't exist (None, sort of like Nothing)
18:32:56 <roboguy_> Axman6: isn't that sort of like NaN from the IEEE floating point standard?
18:33:41 <Axman6> sort of, but it works for any data. so dereferencing NULL returns something tagged NaR
18:34:23 <Axman6> http://www.youtube.com/watch?v=DZ8HN9Cnjhc explains is best (about 45-50 mins in, worth watching it all though so you don't miss any of the details needed to understand)
18:37:55 <jonkri> What am I supposed to do if none of my possible values are suitable for the noMsg/strMsg methods of the Error typeclass?
18:38:21 <hpc> pull it out of your _|_
18:38:22 <hpc> ;)
18:38:29 <Axman6> heh
18:41:48 <jonkri> :P
18:42:26 <jonkri> Seriously, should I create a dedicated type constructor for the error instance or just pick one (if possible)?
18:43:13 <Axman6> :t noMsg
18:43:14 <lambdabot> Error a => a
18:43:23 <Axman6> :t strMsg
18:43:24 <lambdabot> Error a => String -> a
18:43:42 <jonkri> Axman6: I have to define at least one.
18:43:58 <Axman6> what's your type?
18:44:08 <Iceland_jack> Axman6: Sound like a pick-up line
18:44:20 <Axman6> yeah I thought so too :P
18:44:26 <binroot> @pl (\x -> (f x) * (g x))
18:44:27 <lambdabot> liftM2 (*) f g
18:44:29 <ReinH> justhaskellthings
18:44:30 <jonkri> Axman6: Like "data ErrorType = Condition1 | Condition2 | Condition3"
18:44:47 <jonkri> Iceland_jack: :)
18:44:58 <Axman6> jonkri: I'd add ConditionNoMsg and ConditionMsg String
18:45:09 <ReinH> (*) <$> f <*> g for maximum operator usage
18:45:47 <jonkri> Axman6: You mean ErrorTypeNoMsg and ErrorTypeMsg String?
18:46:01 <Axman6> sure
18:46:43 <jonkri> But those are not actual error conditions of the system. Of course, I could avoid exporting them, but that would mean that I have to manually keep track of the data constructor exports every time I modify the type.
18:47:21 <Axman6> are you sure Error is the class you want? isn't it basically for things which are going to be thrown as exceptions?
18:48:53 <jonkri> Axman6: Hmm... I wanted to throw Condition1, Condition2 and Condition3, so that they could all be catched with the same code. But perhaps I should make three different Error instances.
18:49:49 <jonkri> I would have to re-think my structure.
18:50:14 <Axman6> are you sure you need exceptions at all? they're usually best avoided
18:50:49 <athan> does anyone know a good library for parsing command line arguments and handling "usage: [...]" errors?
18:51:05 <jonkri> Axman6: Well, I say exceptions, but I actually mean ErrorT computations.
18:51:11 <jonkri> Sorry. :)
18:51:12 <Axman6> there's a few, none of which I can remember the name of =)
18:51:18 <athan> :p
18:51:21 <triliyn> optparse-applicative is one
18:51:28 <zedik> Hi everybody. How to put multiline text here?
18:51:33 <triliyn> I'm not sure how good it is or whether others are at least as good
18:51:34 <lingxiao> hey all, I have a basic question concerning lambda calculus
18:51:45 <Axman6> zedik: here? in this channel?
18:51:52 <lingxiao> I feel like I'm getting the concept of substitution and reduction confused
18:51:54 <Iceland_jack> zedik: Use http://lpaste.net/new/haskell to show us code
18:52:06 <Axman6> zedik: if that's what you want, please don't, use a paste website ^^^^
18:52:39 <zedik>  Axman6 : thanks
18:52:42 <lingxiao> when I write `[x +-> c0](λx.x)`, it means I'm swapping out all ocurance of x for c0 right?
18:53:00 <lingxiao> But the lambda abstraction remains intact
18:53:03 <jrw> lingxiao: all *free* occurrences, yes.
18:53:09 <Iceland_jack> all free ones lingxiao
18:53:10 <jrw> so in your example, nothing happens.
18:53:21 <Iceland_jack> For example if you have (λx.(λx.x)) you don't swap anything
18:54:12 <lingxiao> jrw: ok so that's the other concept I'm confused about.. I thought free refer to a variable that's not bound by the lambda abstraction?
18:54:15 <zedik> http://lpaste.net/98076
18:54:31 <jrw> lingxiao: that's right, in your example, there are no free variables because the x is bound by the lambda
18:54:47 <jrw> lingxiao: the usual way of writing the beta reduction rule is: (\x.b)a -> [x |-> a] b
18:54:57 <lingxiao> jrw: ahh so I don't perform the swap, and  `[x +-> c0](λx.x)` = `λx.x`
18:54:59 <Axman6> (\x. y x) y is free, x isn't, right?
18:54:59 <jrw> notice that I've gotten rid of the lambda on the right hand side
18:55:05 <bomgaroto> Just started learning Haskell a couple of weeks ago. I programmed a few simple functions, but now I am stuck with how to find a substring in a longer string. I come from Python, and it is been very hard to try and see things this new functional way. Any pointers?
18:55:08 <jrw> Axman6: right.
18:55:26 <triliyn> zedik: splitAt returns a tuple, but then the code pattern matches on the tuple
18:55:29 <Iceland_jack> bomgaroto: Do you want to implement it yourself
18:55:37 <Iceland_jack> or do you want a preexisting solution
18:55:40 <triliyn> So that 'first' refers to the first element of the tuple and 'rest' refers to the second
18:55:44 <bomgaroto> yes. As practice.
18:55:49 <roboguy_> zedik: the where clause uses pattern matching to bind the first element of the tuple from splitAt to "first" and the second element to "rest"
18:56:00 <bomgaroto> Since I am learning.
18:56:01 <Iceland_jack> Well bomgaroto, are you familiar with how lists work?
18:56:03 <jrw> lingxiao: right.
18:56:11 <lingxiao> however with the expression `[x +-> c0](λy.xy)` = `λx.c0y`, right?
18:56:32 <bomgaroto> yes. I am fine with lists. I guess
18:56:40 <jrw> lingxiao: yes, provided y is not free in c0
18:56:43 <Iceland_jack> lingxiao: You'll want to stick with single character variable names or expressing application with something else than juxtaposition
18:57:08 <lingxiao> Iceland_jack : oops, sorry, I'll use c from now on
18:57:08 <zedik> triliyn: yes I got it, but how it becomes list of lists from the tuple?
18:57:16 <Axman6> > splitAt 3 "hello zedik"
18:57:17 <lambdabot>  ("hel","lo zedik")
18:57:19 <Iceland_jack> bomgaroto: Do you want to check if a substring exists (return a Bool?). Well then think of the possible cases
18:57:34 <roboguy_> zedik: the tuple gets deconstructed into first and rest, so the tuple is no longer a part of it after that
18:57:35 <Axman6> > let (first, second) = splitAt 3 "hello zedik" in first
18:57:35 <triliyn> zedik: the tuple is thrown away and its components are used in the call to (:)
18:57:36 <lambdabot>  "hel"
18:57:40 <Axman6> > let (first, second) = splitAt 3 "hello zedik" in second
18:57:41 <lambdabot>  "lo zedik"
18:57:53 <bomgaroto> I would like to retrieve it. Its position would be a good case
18:57:59 <Axman6> > let (first, second) = splitAt 3 "hello zedik" in first : []
18:58:00 <lambdabot>  ["hel"]
18:58:01 <lingxiao> jrw: so now I'm confused about how substitution relates to beta reduction
18:58:40 <jrw> lingxiao: did my phrasing of the beta reduction rule make sense?
18:58:44 <lingxiao> for example, `(λy.xy) c` should reduct to `xc` correct? is there a substitition in there somewhere?
18:58:44 <zedik> roboguy_: yes, ok, it's not longer a tuple. an output is like [ [1,2], [3,4], [5,6] ] - list of lists
18:58:48 <Iceland_jack> lingxiao: If you have a beta reduction you're calculating an application
18:58:52 <Axman6> zedik: do you understand how to construct and pattern match on lists?
18:58:55 <jrw> lingxiao: yes and yes
18:58:58 <Iceland_jack> lingxiao: Yes
18:59:23 <Iceland_jack> And if you have something like:
18:59:23 <Iceland_jack>     (λx. x + x) 7
18:59:23 <Iceland_jack> you beta reduce it to
18:59:23 <Iceland_jack>     7 + 7
18:59:33 <Iceland_jack> but substituting 7 for every occurrence of x
18:59:40 <zedik> Axman6: I thought that yes but not now I don't understand how is it transformed to list of lists
18:59:56 <lingxiao> Iceland_jack: but the substitution step I just used did not throw away the lambda abstraction?
19:00:04 <lingxiao> `[x +-> c](λy.xy)` = `λx.cy
19:00:05 <Iceland_jack> lingxiao: You *apply* it
19:00:08 <Axman6> zedik: do you understand recursion?
19:00:14 <roboguy_> zedik: the thing is, that part has nothing to do with the tuple really. it just uses those bindings that happen to be bound by deconstructing a tuple
19:00:17 <zedik> Axman6: yes
19:00:22 <Iceland_jack>     (λx. x + x) 7
19:00:22 <Iceland_jack>     x[x ↦ 7] + x[x ↦ 7]
19:00:22 <Iceland_jack>     7 + 7
19:00:48 <Iceland_jack> lingxiao: THe first step is the beta reduction
19:00:50 <jrw> lingxiao: for your new example, you could have (\x. (\y. xy)) c reducing to \y.cy
19:00:52 <Iceland_jack> but we haven't substituted yet
19:01:09 <zedik> roboguy_:  yes, we deconstruct tuple but it becomes list of lists ?
19:01:14 <Axman6> zedik: well, all the function is doing is using splitAt to split the list, which produces the tuple with first and rest in it, then it uses (:) to add first to the result of calling splitEvery n on rest
19:01:36 <lingxiao> jrw: ok follow so far, but then what?
19:01:38 <Iceland_jack> lingxiao: Here is a beta reduction without substitution
19:01:38 <Iceland_jack>     (λx. 5 + 5) 10
19:01:44 <Iceland_jack> *beta redux
19:01:54 <Axman6> zedik: first : (splitEvery n rest) places first (a list) on the front of the result of splitEvery n rest (a list of lists)
19:01:59 <jrw> lingxiao: that's it. I did the beta reduction and substitution in one step and now it's done.
19:02:11 <Iceland_jack> *dex
19:02:19 <Axman6> > "hello" : ["world"]
19:02:21 <lambdabot>  ["hello","world"]
19:02:48 <zedik> Axman6: yes . Could you please to show one line example of code which will reproduce an output? [ 1,2] : ( ( [3,4], [3,4] ) ) - doesn't work
19:02:49 <lingxiao> jrw: see now I'm really confused, from (\x. (\y. xy)) c to \y.cy, I only see beta reduction, where is the substition?
19:03:01 <lingxiao> can I ask you to give an example where both occur explicitly?
19:03:11 <roboguy_> > [1,2] : [[3,4],[3,4]]
19:03:12 <lambdabot>  [[1,2],[3,4],[3,4]]
19:03:13 <jrw> lingxiao: Iceland_jack already gave you one, but sure.
19:03:14 <roboguy_> ^ zedik
19:03:25 <Axman6> zedik: I don't understand., you seem to be mixing up tuples and lists
19:03:50 <jrw> lingxiao: (\x. (\y. xy)) c beta reduces to [x |-> c](\y. xy), the substitution is then performed, giving \y.cy
19:04:22 <zedik> Axman6: roboguy_ :  [1,2] : [[3,4],[3,4]] - we join list to list of list but how the first list [ [ ] ] was obtained?
19:04:57 <lingxiao> jrw: I thought beta reduction is a function that sends Term to Term?
19:05:05 <Axman6> > [1,2]:[]
19:05:06 <lambdabot>  [[1,2]]
19:05:14 <zedik> Axman6:  roboguy_ : first : ( splitEvery n rest ) how from that we get list of lists
19:05:15 <lingxiao> but `[x |-> c](\y. xy)` is not really a Term? am I thinking about this the right way?
19:05:15 <jrw> lingxiao: it's not a function, it's a relation.
19:05:16 <Axman6> > [3,4] : ([1,2]:[])
19:05:17 <lambdabot>  [[3,4],[1,2]]
19:05:30 <Iceland_jack> lingxiao: Not quite
19:05:31 <jrw> lingxiao: you bring up a good point. substitution is defined at the meta level.
19:05:39 <triliyn> zedik, others: I think something a bit confusing is that this particular implementation of splitEvery doesn't have a base case
19:05:46 <triliyn> It recurses every time, doesn't it?
19:05:55 <roboguy_> zedik: first is of type [a] and whenever the first argument of ":" is [a], the whole expression must be of type [[a]] (if it is correct)
19:06:05 <Axman6> triliyn: yeash I was thinking about that. I believe so
19:06:10 <jrw> lingxiao: I think it will be less confusing if you don't have multiple people explaining it at the same time, so I'll let Iceland_jack continue :)
19:06:15 <zedik> Axman6:  roboguy_ : triliyn : thanks, after that [3,4] : ([1,2]:[]) - it's more clear! thanks!
19:06:30 <ReinH> triliyn: which impl?
19:06:32 <Iceland_jack> lingxiao: I'm actually heading to bed!
19:06:50 <triliyn> ReinH: http://lpaste.net/98076
19:07:01 <Axman6> zedik: as triliyn points out, there is code missing. there needs to be a case for splitEvery [] = [] so you get the initial []
19:07:03 <lingxiao> Iceland_jack: oh ok thank you for answering my questions!
19:07:14 <Iceland_jack> lingxiao: no no, let's see this through
19:07:31 <Axman6> well, the [] at the end of the list
19:07:49 <Axman6> zedik: also, remember that [] and [[]] are different things
19:08:00 <lingxiao> Iceland_jack: oh are you sure? I don't want to keep you up expalining elementary (literally, haha) concepts
19:08:12 <Iceland_jack> lingxiao: I'll cope
19:08:12 <bomgaroto> []
19:08:13 <Iceland_jack>     (λx.x) y = x[x↦ y] = y
19:08:17 <zedik> Axman6: when this base case is going to be used? in the first iteration?
19:08:35 <Axman6> zedik: it's going to be used when rest becomes []
19:08:37 <ReinH> zedik: what happens when rest is []?
19:09:14 <zedik> Axman6: ReinH : Yes, no I got how it works ! It is possible only when it reaches the last 'iteration'
19:09:24 <Axman6> yep
19:09:27 <zedik> * now
19:09:27 <lingxiao> Iceland_jack: does what you wrote expand to:
19:10:19 <lingxiao> (λx.x) y = [x ↦ y](λx.x) = λx. x[x ↦ y] = x[x ↦ y] = y
19:10:25 <zedik> Axman6: ReinH : before now I didn't think about the edge condition, I knew about that but didn't pay too much attention. Thanks!
19:10:35 <Iceland_jack> lingxiao: No
19:11:08 <Iceland_jack> x is not free in (λx.x), so (λx.x)[x ↦ y] doesn't change anything
19:12:13 <lingxiao> Iceland_jack: see this is why I'm confused, what is the point of substition?
19:12:32 <Iceland_jack> When you have
19:12:32 <Iceland_jack>     (λx.M) N
19:12:32 <Iceland_jack> its β-converted form is just removing the lambda abstraction and substituting all occurrences of x with N
19:12:40 <startling> lingxiao, it's for when you're evaluating (λx.x)
19:12:48 <Iceland_jack> lingxiao: Are you familiar with Haskell?
19:12:51 <Iceland_jack> > (\x -> x) 5
19:12:52 <lambdabot>  5
19:13:01 <startling> lingxiao, (λx.x)(y) = x[x ↦ y] = y
19:13:04 <lingxiao> so that's beta reduction right?
19:13:07 <Iceland_jack> lingxiao: Yes
19:13:31 <Axman6> lingxiao: (\y. (\x. y x)) z -> (\x. z x) because you've applied the substitution of all y's for x when you applied the lambda to z.
19:13:44 <Axman6> the substitution happens inside the body of the lambda when you perform substitution
19:13:57 <startling> lingxiao: if you know Haskell, we can explain this in a nicer substitution-free way
19:14:00 <JakeE> love: lol, I'm guessing that that function is very specific and only needed in 1 other function or 1 module, correct? if so just name it genList and explain with comments
19:14:01 <Axman6> uh, all y's for z
19:14:25 <startling> (using type-level de bruijn indices)
19:14:30 <lingxiao> yes please do! I know haskell, and I can do lambda calculus on paper, but when I try to understand how subsitition fits in there my brain turns to mush
19:14:47 <Iceland_jack> Type level de bruijn indices aren't going to make things simpler
19:14:49 <JakeE> whoops I missed a bunch of chat and responded to somthing no longer being talked about
19:14:58 <Iceland_jack> substitution is not such a tricky concept
19:15:01 <startling> data Term a = Variable a | Apply (Term a) (Term a) | Lambda (Term (Just a))
19:15:06 <Axman6> Iceland_jack: but they can be useful =)
19:15:09 <startling> er, s/Just/Maybe
19:15:16 <roboguy_> it seems to me that all beta reduction is (capture-free) substitution + removing the outer lambda abstraction
19:15:19 <Iceland_jack> HOAS would be far more simpler
19:15:20 <lingxiao> I didnt' think so either! I don't know why the hiccup, it's kind of embarrasing
19:16:10 <lingxiao> startling: sorry why `Lambda (Term (Just a))` ? why the `Maybe`?
19:16:10 <Iceland_jack> lingxiao: For Axman6's example
19:16:11 <Iceland_jack>       (λy. (λx. y x)) z
19:16:11 <Iceland_jack>     ↝ (λx. y x)[y ↦ z]
19:16:14 <Iceland_jack>     ↝ y[y ↦ z] x[y ↦ z]
19:16:17 <Iceland_jack>     ↝ z x
19:16:17 <Axman6> > (\y -> (\x -> y (\y. x y))) a b c
19:16:18 <lambdabot>  <hint>:1:20: parse error on input `.'
19:16:22 <lingxiao> owr no that's not Maybe, it's `Just`, what's that?
19:16:24 <Axman6> > (\y -> (\x -> y (\y -> x y))) a b c
19:16:25 <lambdabot>  Couldn't match expected type `(t1 -> t0)
19:16:25 <lambdabot>                                -> Debug.SimpleReflect.Expr.Expr -> t2'
19:16:25 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
19:16:25 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
19:16:34 <startling> lingxiao, Nothing in the inner term means "the parameter".
19:16:41 <Axman6> bleh
19:16:47 <startling> lingxiao: so e.g. id = Lambda (Variable Nothing)
19:17:09 <startling> but const x = Lambda (Just x)
19:17:30 <startling> lingxiao: the nice thing about this is that we avoid having similarly-named things completely.
19:17:35 <startling> i.e., there's no shadowing.
19:17:58 <startling> lingxiao, (shadowing being the fundamental problem that substitution solves)
19:18:31 <startling> lingxiao, so, say we want to eval (\x -> x) y.
19:18:53 <startling> lingxiao: in our language, that's Apply (Lambda (Variable Nothing)) (Variable y)
19:19:14 <startling> so, we can write substitute :: Term (Maybe a) -> Term a -> Term a
19:19:16 <triliyn> startling: how would you do something like \x -> (\y -> x y)?
19:19:22 <Fuuzetsu> carter: you truly are a full time ‘patches welcome’ guy
19:19:27 <Axman6> (\y . exp) z means replace all y's in exp with z ([y -> z]), except when we hit a lambda that gives a binding for y. so, (\y. y (\y. y)) z becomes z (\y. y), not z (\y. z)
19:19:42 <startling> triliyn, Lambda (Lambda (Apply (Variable (Just Nothing)) (Variable Nothing), I believe.
19:20:00 <triliyn> hmmm, okay
19:20:00 <startling> missing a close-parens, but you get the idea.
19:20:00 <lingxiao> Iceland_jack : thank you for stepping through that, I really needed that! Something like that does not appear in Pierce's book at all
19:20:16 <Axman6> the inner lambda is shaddowing the outer one, but in a way protects all instances of y in the inner lambda from being changed
19:20:39 <triliyn> I think it has to be Variable (Just (Variable Nothing))
19:20:43 <triliyn> To be the right type
19:20:45 <triliyn> But that makes sense
19:20:47 <Axman6> the inner y is a different y from the outer y
19:20:49 <startling> triliyn: nah.
19:20:49 <lingxiao> startling: could you expand on what you mean by shadowing?
19:20:51 <Iceland_jack> lingxiao: There are embarrassingly many good introduction on the lambda calculus :) it's fundamentally a very simple model of computation
19:20:54 <startling> lingxiao, ok.
19:21:00 <Iceland_jack> but it takes the right introduction
19:21:07 <startling> lingxiao, consider "f (\f -> f)"
19:21:15 <Iceland_jack> good example
19:21:33 <startling> lingxiao, what's (f (\f -> f))[f -> g]?
19:22:06 <Axman6> good example
19:22:10 <lingxiao> yeah man, it seems so simple and I really like it, learning church encoding was a mini revelation of sorts, aided by some fine people found in this very channel
19:22:11 <startling> :)
19:22:38 <Iceland_jack> lingxiao: You're just getting started! Please continue digging :)
19:22:56 <Axman6> lingxiao: do you have an answer for startling's example?
19:23:09 <lingxiao> g (\g -> g) ?
19:23:16 <Axman6> no
19:23:19 <lingxiao> except f here is a variable?
19:23:23 <Axman6> (well, sort of... not)
19:23:32 <Iceland_jack> Axman6: hah
19:23:43 <Axman6> lingxiao: it should be g (\f -> f)
19:24:02 <Iceland_jack> lingxiao: (λf.f) = (λg.g) so you were right for the wrong reasons :)
19:24:33 <Axman6> Iceland_jack: except if g contained other variables called g
19:24:34 <triliyn> \g -> g is in some sense the same as \f -> f, but I think depending on how deeply you're buried in lambda calculus you don't consider them equal
19:24:35 <Axman6> I think
19:24:36 <Iceland_jack> right right
19:24:46 <triliyn> Extensional versus intensional equality
19:24:48 <lingxiao> is that why someon mentioned debrujin's index some comments back? since those two have the same representation with numbers?
19:25:28 <Axman6> lingxiao: right, you could reencode f (\f . f) as f (\1. 1)... I think
19:25:34 <triliyn> De Bruijn indexes do make this a bit easier, yeah
19:25:43 <Iceland_jack> lingxiao: You can represent simply typed lambda calculus using HOAS in about three lines :)
19:25:53 <Axman6> and (\f . f (\f . f)) would become (\1. 1 (\2 . 2))
19:25:58 <Iceland_jack> sorry, untyped you were looking for
19:26:59 <lingxiao> oh I'll get to it next, my goal is to implement some version of the core
19:27:05 <Axman6> lingxiao: so, (\f. f (\f . f)) z becomes (\1. 1 (\2 . 2)) z which becomes z (\2. 2)
19:27:28 <startling> lingxiao: basically: how substitution works is that, while substituting for x, you never substitute past a \x.
19:27:33 <triliyn> Axman6: isn't the inner f referring to variable 1?
19:27:37 * hackagebot monad-extras 0.5.5 - Extra utility functions for working with monads  http://hackage.haskell.org/package/monad-extras-0.5.5 (JohnWiegley)
19:27:43 <startling> triliyn, no.
19:27:44 <triliyn> (variable 1 in the new context I mean)
19:27:52 <startling> oh
19:27:58 <Axman6> well, possibly, but this makes it easier to see
19:27:59 <startling> people are doing this in different ways. :/
19:28:37 <triliyn> I would write it as \(1\1) because de bruijn indices can in principle be compact, but that is kind of ugly
19:28:39 <Axman6> startling: I think you put it most clearly, stop substituting x when you hit (\x. e)
19:29:07 <Iceland_jack> triliyn: They're nicer when actually implementing LC in a language
19:29:19 <startling> yeah.
19:29:19 <melonmechanic> if i have data Foo = A | B | C is there a way to write a function that matches f A A = ... f B B = ... f C C = ... or do i have to write out all 3 definitions?
19:29:25 <Iceland_jack> people are plenty good at substitution
19:29:30 <Iceland_jack> it's just annoying to implement
19:29:37 <startling> melonmechanic, you can use = in a guard.
19:29:38 <Iceland_jack> melonmechanic: case (x, y) of
19:29:40 <triliyn> yeah, it's just ugly to write out explicitly
19:29:48 <startling> triliyn: yeah.
19:29:58 <Axman6> melonmechanic: not in haskell sadly, Erlang has f a a meaning they are equal
19:29:59 <triliyn> Especially if you use backslashes instead of pretty lambdas
19:30:10 <Iceland_jack> There is a reason why Haskell doesn't allow non-linear patterns
19:30:15 <Axman6> right
19:30:17 <Iceland_jack> and they're quite uninteresting
19:30:23 <melonmechanic> Axman6: that's what I was afraid of.
19:30:42 <startling> triliyn, usually the first thing you do when you're writing a term in de bruijn representation is write a parser. :)
19:30:52 <lingxiao> that's exactly when I started having issue with subsition, is when trying to implement it
19:30:54 <Axman6> melonmechanic: f x y | x == y = f' x perhaps
19:31:23 <triliyn> I've seen de Bruijn indices used in like a toy language implemented in idris
19:31:29 <triliyn> That was actually really fun to read
19:31:33 <lingxiao> startling: I'm sorry, I feel like you're trying to tell me something really useful and simple but I just can't get it through my head, whne you say:
19:31:34 <lingxiao> "basically: how substitution works is that, while substituting for x, you never substitute past a \x."
19:31:45 <Iceland_jack> De Bruijn indices are fun when you have dependent types
19:32:02 <startling> lingxiao, hmmmm
19:32:05 <lingxiao> what do you mean by past a λx.
19:32:15 <lingxiao> and why is that a problem
19:32:38 <lingxiao> and trying to spell the word "substitution"
19:32:44 <startling> lingxiao, ok, let's talk about Haskell.
19:32:45 <Maxdamantus> lingxiao: λx.x[x/y] = λx.x
19:33:00 <melonmechanic> Axman6: hey that worked! didn't think of doing that
19:33:01 <melonmechanic> thanks
19:33:08 <Axman6> lingxiao: when you are working under the substitution [x -> y] you rteplace all y's in an expression UNLESS you hit a lambda that rebinds x. so you can substitute all x's in anything except in the body of e in (\x. e)
19:33:33 <Iceland_jack> lingxiao: If you know Haskell then just think how it would work with Haskell lambdas and you should be set
19:33:34 <Axman6> melonmechanic: sadly needs Eq though, which shouldn't be strictly necessary
19:33:52 <startling> lingxiao: ok, an important thing to realize is that there's a difference between variables and terms.
19:33:58 <Iceland_jack> melonmechanic: If you really want to avoid the Eq constraint you can just pattern match
19:34:02 <startling> lingxiao, substitution replaces a variable with a term.
19:34:26 <startling> lingxiao, so, consider something like (\x -> x) (1 + 1)
19:34:59 <startling> we can substitute first (in a strongly-normalizing language) so we get (1 + 1) and then 2.
19:35:20 <startling> lingxiao: now, consider something like (\x -> (\x -> x)) (1 + 1) (2 + 2)
19:35:48 <startling> lingxiao: can you see why your substitution procedure doesn't work there?
19:36:54 <lingxiao> wouldn't the inner lambda just throw away the first x?
19:36:55 <startling> you, aiui, would do "(\(1 + 1) -> (1 + 1)) (2 + 2)", which doesn't really make sense.
19:37:01 <startling> lingxiao: yep.
19:37:11 <startling> aside from not really making sense, it's also wrong.
19:37:26 <startling> since, pretending it did make sense would result in 2 rather than 4.
19:37:51 <Axman6> > (\x -> (\x -> x)) a b
19:37:52 <lambdabot>  b
19:37:53 <startling> so, what's (\x -> (\x -> x))[x -> (1 + 1)] ?
19:38:05 <Maxdamantus> It's the identity function over {2}
19:38:26 <AVM> > flip const a b
19:38:27 <lambdabot>  b
19:38:49 <startling> Maxdamantus, AVM: I know you guys mean well but it's really not relevant to the point I'm trying to make.
19:39:03 <AVM> sorry i just showed up
19:39:11 <AVM> so idk what point ur making, sorry
19:39:23 * Maxdamantus did too, but slightly earlier.
19:39:37 <lingxiao> startling: like what should the expression evaluate to?
19:39:50 <Maxdamantus> Sorry lingxiao. startling's description is good. Ignore me.
19:40:04 <startling> lingxiao: no. what is (\x -> (\x -> x)), substituting in (1 + 1) for x?
19:40:08 <Axman6> lingxiao: just how do you perform the substition startling gave
19:40:14 <lingxiao> Maxdamantus: all good, one day I'll pop back around ask you to explain that :)>
19:40:52 <lingxiao> (\x -> x) ?
19:40:58 <startling> lingxiao: exactly.
19:41:07 <lingxiao> which then binds (2+2)
19:41:09 * Maxdamantus wonders if `\(1 + 1) -> (1 + 1)` is valid in Haskell 98.
19:41:21 <startling> Maxdamantus: ugh, it totally is. shhhhh
19:41:22 <AVM> + is not a constructor
19:41:26 <triliyn> Maxdamantus: it's not, but I think \2 -> 1 + 1 is
19:41:35 <startling> triliyn, AVM: it defines (+)
19:41:44 <Axman6> lingxiao: and the thing to notice is that the x's in the inner lambda weren't substituted because the inner x "created" by the \x is a difdferent x from the one you're substituting
19:41:52 <triliyn> oh, hmm
19:41:54 <startling> oh, wait, not quite.
19:41:57 <Axman6> AVM: lambda calculus, not Haskell
19:41:59 <AVM> but its not a constructor. you can only pattern match on constructors
19:42:09 <triliyn> Right
19:42:16 <startling> yeah, but n + 1 patterns were a Haskell 98 thing
19:42:19 <AVM> Axman6: "Maxdamantus wonders if `\(1 + 1) -> (1 + 1)` is valid in Haskell 98"
19:42:19 <triliyn> There WERE n+k patterns forever ago
19:42:22 <Axman6> AVM: it's not pattern matching
19:42:32 <lingxiao> Axman6: see all this stuff makes intuitive sense, it's when I "slow it down" and try to increment through the steps as a machine would, that's when Ihave trouble
19:42:32 <triliyn> I'm not sure you could use them with two constants though
19:42:39 <startling> lingxiao, do you understand why it's not (\x -> 1 + 1)?
19:42:42 <Axman6> AVM: oh, it's valid for n+k patrerns I think =)
19:42:58 <AVM> i thought n + k was an extension, not in 98
19:42:58 <Maxdamantus> Yeah, was thinking of the n+k thing.
19:43:02 <lingxiao> yeah they're differnt variables
19:43:07 <Maxdamantus> but instead of an n you just have another k.
19:43:13 <Axman6> AVM: it was in 98, it got removed in 2010 I think
19:43:18 <lingxiao> though they have the same name, is that what you meant by shadowing?
19:43:24 <AVM> ah,s o it was never an extension?
19:43:25 <triliyn> > (\(1+1) -> 1 + 1) 2
19:43:26 <lambdabot>  <hint>:1:4: Parse error in pattern: 1 + 1
19:43:51 <lingxiao> like without shadowing it would be λx.λy.y
19:43:52 <Axman6> AVM: it's an extension now, it used to be part of the language standard
19:43:59 <lingxiao> or λ.λ.0 in index form
19:44:02 <Maxdamantus> I wouldn't be surprised either way .. @ isn't commutative either.
19:44:02 <AVM> ah i see
19:44:41 <lingxiao> assuming by shadowing you mean "malicious" choice of variable names
19:44:52 <startling> lingxiao: right. so, you don't substitute x inside of an (\x -> ...)
19:45:19 <lingxiao> ahh.. but in this expression `x (\x -> ...)` the first x is free
19:45:29 <startling> lingxiao: yep! but the second is bound.
19:45:37 <lingxiao> ohhhh...
19:45:57 <startling> lingxiao: so, substitution says "replace all free variables with a particular name with an expression"..
19:45:58 <Iceland_jack> Well there is no ‘second’ variable, there is only an abstraction to be precise
19:45:58 <lingxiao> ok omg... thanks, yeah stating the problem subsitution is trying to solve makes the whole business more palpable
19:46:08 <Iceland_jack> x may not apprear in …
19:46:10 <Iceland_jack> *appear
19:46:30 <startling> lingxiao, yeah. mathematicians are bad at explaining lexical scope. :)
19:46:31 <lingxiao> ok thanks! wow, that took way more effort on my and more importantly ya'll parts than it needed
19:46:44 <startling> lingxiao: it's a pretty common stumbling-block.
19:46:57 <Iceland_jack> It's fine as long as it helped lingxiao
19:47:16 <lingxiao> startling: yeah mean, I guess everyone decided it's such a simple thing that you can just look at, that no one bothers to spoon feed it
19:47:31 <startling> lingxiao: well, if you see it spoon-fed it's even more confusing. :)
19:47:34 <Axman6> data LamCalc = Variable String | Lam String Exp | App Exp Exp; substitute :: (String, Exp) -> Exp -> Exp; substitute (var,rep) (Lam var' exp') | var == var' = exp | otherwise = substitute (str, rep) exp'
19:47:39 <lingxiao> Iceland_jack: it helped a lot, thanks man! you stayed up 36 minutes past your bedtime
19:47:55 <Iceland_jack> I stayed up quite a bit more than that, was dying my hair
19:48:28 <Axman6> lingxiao: assuming the other cases for Variable anf App, does that make sense?
19:48:37 <Axman6> the code I pasted that is
19:49:05 <lingxiao> Axman6: i'm sooo sorry, can you paste it again?
19:49:17 <lingxiao> there were so many threads of answers, I got lost :(
19:49:38 <lingxiao> oh wait, I see it, it's right there
19:49:42 <startling> haha
19:50:05 <Iceland_jack> The problem with #haskell is too many answers for simple questions
19:50:10 <startling> yes.
19:50:29 * jrw tried to do his part by shutting up :)
19:50:34 <Iceland_jack> haha
19:50:36 <lingxiao> Iceland_jack: yeah man lots of nice people here wanting to help
19:50:37 <lightquake> huh. I just realized that there are no interesting comonads that are also contravariant functors
19:51:03 <Iceland_jack> “Help the #haskell community, don't answer questions!”
19:51:08 <triliyn> lightquake: are there uninteresting monads?
19:51:09 <Iceland_jack> lingxiao: I know :) this is a great place
19:51:31 <jrw> Iceland_jack++
19:51:34 <startling> are monoidal actions Comonads?
19:51:37 <triliyn> Or are monads (at least in Hask) necessarily covariant?
19:51:38 <lightquake> by 'uninteresting' I mean that there exists some `t` such that there is a value of type `f t`
19:51:49 <EmilyScott> Iceland_jack: honestly, I'm constantly impressed by this community compared to other programming communities... I wish there were places half this nice for talking about non-haskell topics... :/
19:52:11 <lightquake> triliyn: I don't know, my argument is just considering `extract . contramap absurd`
19:52:25 <startling> oh, I guess not.
19:52:28 <lingxiao> Axman6: sorry why `Lam String Exp | App Exp Exp`
19:52:29 <triliyn> Isn't extract a comonad thing?
19:52:36 <Axman6> lingxiao: http://lpaste.net/98077
19:52:37 <lightquake> right, that's what I said
19:52:50 <triliyn> oh, you did
19:52:53 <triliyn> I missed the "co"
19:53:18 <startling> triliyn, so you coread it?
19:53:32 <lightquake> I can't think of any contravariant functors that are also monads off the top of my head.
19:53:53 <lightquake> but I also can't think of any reason why there *can't* be
19:54:34 <Iceland_jack> EmilyScott: Yes there are channels that are just unpleasant to be in, at least there *is* #haskell :)
19:54:45 <startling> lightquake, well, you'd have liftM (fmap) and also contramap
19:55:22 <lightquake> right, so there's a term of type `m a -> m b`
19:55:47 <lightquake> ... data Trivial a = Trivial?
19:55:58 <startling> yeah.
19:56:05 <startling> or data Const a b = Const a
19:56:11 <lightquake> i don't think Const is a monad
19:56:22 <lightquake> can't write return
19:56:23 <triliyn> Const a can't be a monad because you can't invent a thing of type a
19:56:29 <EmilyScott> Iceland_jack: true, but I don't work in Haskell, and want to talk about it, but it's off topic here, so I don't... and I've tried other channels... and got the memo "please die in a fire"...
19:56:29 <startling> yeah.
19:56:46 <startling> you can do e.g. instance Monoid a => Monad (Const a) though
19:56:49 <Axman6> lingxiao: http://lpaste.net/98077
19:56:53 <triliyn> Right
19:57:05 <startling> (mappend gets used for (>>=)).
19:57:25 <startling> wait, does it? I might be misremembering.
19:57:33 <triliyn> I think you do need it
19:57:37 <startling> maybe Const is only Applicative.
19:57:41 <lingxiao> Axman6: yup reading over it right now, can I ask you why the Exp in `Lam String Exp | App Exp Exp`
19:57:53 <triliyn> If you don't use mappend, then you have to choose one of the Const values
19:57:53 <lingxiao> oh generic expression?
19:57:56 <startling> yeah, Const is only Applicative.
19:57:58 <triliyn> Which sounds not associative
19:58:06 <triliyn> hmmm, okay
19:58:18 <lightquake> triliyn: well, you can't get a Const value out of the monadic function
19:58:18 <lingxiao> as in `λx.E` for some E
19:58:26 <startling> triliyn, how do you get the c out of (a -> Const c b)?
19:58:38 <triliyn> oh, hmmm, that's right
19:58:39 <startling> you can't wthout an a, therefore Const is not a Monad.
19:58:40 <lightquake> so the only sensible definition is m >>= f = coerce m where coerce :: Const a b -> Const a c
19:58:49 <Iceland_jack> lingxiao: Yes, in that way of encoding it 'x' is a String and 'E' is an Exp
19:58:57 <Axman6> lingxiao: right, the lambda is made up of a name it binds and an expression that may or may not contain that name which, when the lambda is applied, substitutes all vatiables with that name with the value of the expression it was applied to
19:58:58 <startling> lightquake: yeah, and I don't think that follows the laws.
19:59:08 <lightquake> i assume it doesn't, otherwise there'd be a Monad instance for it :)
19:59:14 <lingxiao> got confused due to use of `exp'` in function `substitute`, which I misread as exp the exponetnial fucntion
19:59:16 <Axman6> variables*
19:59:17 <Iceland_jack> Axman6: Are ‘vatiables’ variables for use in the Vatican?
19:59:18 <startling> yeah. join can't do anything.
19:59:37 <startling> i.e. you have join = coerce, too
20:00:07 <startling> anyway.
20:01:52 <lingxiao> Axman6: ahh got it, thanks for writing it up and making things simpler by using `Exp`
20:01:59 <Axman6> lingxiao: oops, I got the definition for substitute for Lam wrong!
20:02:05 <startling> hahaha
20:02:26 <lingxiao> for some reason haskell code just says things better than english a lot of times.. or math notation which is surprisingly ambigous a lot of times
20:02:56 <startling> definitely.
20:03:04 <lingxiao> should `otherwise` be ` otherwise = Lam $ substitute (str, rep) exp'`
20:03:38 <Axman6> yes, except it should be Lam var' $ sub...
20:03:53 <lingxiao> oh oops yes
20:04:03 <Axman6> so, you see how it work now?
20:04:14 <lingxiao> point is subsittuion preseres the lambdas
20:04:24 <lingxiao> yup thanks for making the blurb!
20:04:25 <Axman6> if someone rebinds the name x, we no longer want to substitute x's inside that lambda
20:04:28 <lingxiao> preserves*
20:05:15 <Iceland_jack> lingxiao: Substitution can of course add new lambda abstractions
20:05:16 <lingxiao> ahhh, yes thanks for saying that, it echoes the whole "replace free ocurrances of x" thing
20:05:50 <lingxiao> Iceland_jack: yeah that's funny its like a rule that lengthens the string
20:06:14 <lingxiao> or preserve the length, but never shortens it?
20:06:23 <lingxiao> where as beta redux shortens the string
20:06:28 <Iceland_jack> I'm not sure if that's a helpful way of thinking about it
20:07:09 <lingxiao> Iceland_jack: yeah not sure how it relates to other things, but is that a fair observation? even if it's without content?
20:07:26 <lingxiao> wait no.. it doesnt lengthen the whole string, only the string being subsitiuted on
20:07:43 <Iceland_jack>       (λx. f x x) (λy. y)
20:07:43 <Iceland_jack>     ↝ f[x ↦ λy.y] x[x ↦ λy.y] x[x ↦ λy.y]
20:07:43 <Iceland_jack>     ↝ f (λy.y) (λy.y)
20:07:46 <Iceland_jack>     = f (λy.y) (λz.z)
20:07:47 <roboguy_> wait wouldn't that Monad stuff with Const be okay since it works with a phantom type? i.e., coerceConst (Const c) = Const c
20:09:07 <roboguy_> I think that violates the laws though
20:09:10 <startling> yeah.
20:09:20 <Iceland_jack> lingxiao: If your observation is that replacing variables with terms makes the expression ‘longer’ then sure you can use that intuition
20:09:21 <startling> not sure which one, and too lazy to look it up. :)
20:09:37 <Iceland_jack> assuming that you don't use long variable names
20:09:49 <lingxiao> have you read GEB? the guy spends a long time talking about lengthening and shortening strings in formal systems
20:09:51 <roboguy_> startling: it would violate the "return x >>= f == f x" one at least
20:09:58 <lingxiao> I guess that's why I made note of it...
20:10:00 <Iceland_jack> but it's a bit flimsy since it depends on the concrete syntax
20:10:23 <Iceland_jack> you can prove things using the length of the concrete syntax but still
20:10:56 <lingxiao> yeah meh I'm just kicking water at this point haha, but this stuff is really fascinating
20:11:18 <Axman6> hmmm, what happens in (\x. (\y. x y)) y z do you end up with z z? that seems wrong
20:11:45 <Axman6> because you get (\y. y y) z, but the outside y is a different y, so you must rename it surely?
20:12:11 <Iceland_jack> Axman6: α-renaming
20:13:18 <Iceland_jack>     (λy. y y) z ≠ (λu. y u) z
20:13:20 <lingxiao> can you rewrite that as `(λ.λ.1 0)yz`? wait how you you encode y and z using de-brujin's indx
20:13:42 <Iceland_jack> lingxiao: They'd have to be bound
20:13:50 <triliyn> lingxiao: free variables can't be de bruijn encoded
20:14:06 <Axman6> yusukesuzuki:  and z are just short hand names for some other expression (which is made up of functions)
20:14:09 <lingxiao> right so (λ.λ.1 0)(λ.0)(λ.0)
20:14:23 <Iceland_jack> lingxiao: no
20:14:31 <triliyn> \.0 is the identity function
20:14:45 <lingxiao> so λ.1? where 1 points to some free variable
20:14:45 <Iceland_jack> You could use ‘z’ and ‘y’ to refer to some numbers
20:14:51 <triliyn> In this case you kind of just have to leave them free
20:14:58 <lingxiao> or no, you can't have variables period
20:15:01 <Iceland_jack> and assume some ambient abstractions
20:15:13 <lingxiao> you'd have to specify the functions they stand for
20:15:49 <lingxiao> or no ..
20:18:01 <lingxiao> anways I'm going heading off, thank you Iceland_jack and Axman6 and have a good night!
20:46:01 <randomclown> How the balls does on convert from Data.Attoparsec.Number.Number to Double?
20:46:04 <randomclown> one*
20:46:41 <startling> randomclown, data Number = I Integer | D Double
20:46:56 <startling> randomclown: toDouble (D d) = d
20:47:26 <startling> randomclown: toDouble (I i) = fromInteger i
20:47:29 <randomclown> Do I actually need to import it and pattern match?
20:47:47 * hackagebot persistent-mongoDB 1.3.1 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.3.1 (GregWeber)
20:47:54 <randomclown> I was thinking it was going to be one of those fromRational, fromInteger functions
20:48:13 <randomclown> startling:
20:48:15 <startling> randomclown, oh, you might be right.
20:48:36 <startling> nope.
20:48:56 <startling> you can toRational it but I don't think that's what you want.
20:48:58 <startling> oh.
20:49:12 <startling> :t fromRational . toRational
20:49:12 <lambdabot> (Fractional c, Real a) => a -> c
20:49:27 <startling> :t fromRational . toRational :: Real a => a -> Double
20:49:28 <lambdabot> Real a => a -> Double
20:50:14 <startling> :t (fromRational . toRational) `asAppliedTo` (1 :: Data.Attoparsec.Number)
20:50:15 <lambdabot>     Not in scope: type constructor or class `Data.Attoparsec.Number'
20:51:28 <tristan_1> is there a tool to help figure out the type sig to use for a function... I have a function that simply creates an intance of a record and if I add the type sig a function that uses the function fails to compile because of a type error
20:52:03 <randomclown> startling: that did the trick, but why
20:52:13 <startling> tristan_1, ghci myFile.hs, :t myFunction
20:52:52 <startling> randomclown, toRational works on any Real, fromRational turns a Rational into any Fractional.
20:53:29 <roboguy_> tristan_1: you could try to give it a type you know is wrong and see what it says the expected type is
20:53:32 <tristan_1> startling: facepalm
20:53:53 <tristan_1> roboguy_: sort of what I was doing but thinking it was right ;)
20:53:54 <randomclown> startling: is that slower than just pattern matching?
20:53:59 <roboguy_> tristan_1: that's the idea behind type holes
20:54:09 <tristan_1> turns out having the constraint on it was the issue
20:54:19 <startling> randomclown, probably not significantly if at all
20:54:37 <roboguy_> tristan_1: you might find this kind of interesting http://matthew.brecknell.net/post/hole-driven-haskell/
20:54:39 <tristan_1> so was overthinking it :(, just need :: Recordname a
20:54:48 <carter> Fuuzetsu: someone has to say it :)
20:55:00 <tristan_1> roboguy_: ah yea, I wanted to read up on this. thanks!
20:55:26 <startling> randomclown: (GHC is pretty smart about inlining, especially with hints)
20:57:18 <startling> randomclown: (attoparsec provides those hints -- look at the {-# INLINE ... #-} pragmas in the instance declarations: http://hackage.haskell.org/package/attoparsec-0.10.4.0/docs/src/Data-Attoparsec-Number.html )
21:07:49 * hackagebot system-filepath 0.4.9 - High-level, byte-based file and directory path manipulations  http://hackage.haskell.org/package/system-filepath-0.4.9 (JohnMillikin)
21:09:43 <c_wraith> ok, uh..  how do you use any of the filepaths from that library?
21:10:03 <c_wraith> Oh, I see.  encodeString
21:12:50 * hackagebot system-fileio 0.3.12 - Consistent filesystem interaction across GHC versions  http://hackage.haskell.org/package/system-fileio-0.3.12 (JohnMillikin)
21:17:50 * hackagebot naturalcomp 0.0.3 - Natural-order string comparison  http://hackage.haskell.org/package/naturalcomp-0.0.3 (HironaoKomatsu)
21:21:17 <simpson> Hey, is there a way to see whether a list is a subsequence of another list in good (linear) time? I can't see any in Data.List.
21:21:42 <mm_freak> hmm, SafeT from pipes-safe doesn't really make sense…  how do i open a file without giving it a scope?  like 'allocate' for ResourceT
21:21:43 <Iceland_jack> simpson: You may want Data.Set instead
21:21:48 <Iceland_jack> and
21:21:49 <Iceland_jack> @hoogle subset
21:21:49 <lambdabot> Data.IntSet isProperSubsetOf :: IntSet -> IntSet -> Bool
21:21:49 <lambdabot> Data.Set isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
21:21:49 <lambdabot> Data.IntSet isSubsetOf :: IntSet -> IntSet -> Bool
21:22:26 <simpson> :t isInfixOf -- Oh, there it is.
21:22:27 <lambdabot> Eq a => [a] -> [a] -> Bool
21:23:16 <Iceland_jack> oh you wanted a substring
21:23:18 <Iceland_jack> not a subsequence
21:23:19 <mm_freak> this is one of the rare cases when i need openFile, not withFile
21:23:55 <mm_freak> i guess i'll switch to ResourceT for now
21:24:15 <simpson> Sorry, yeah. I'm not manipulating strings, so I figured I shouldn't call them strings.
21:24:35 <Iceland_jack> no problem simpson, my solution wouldn't be correct for subsequences either
21:24:39 <simpson> Iceland_jack: So! The algorithm I'm in pursuit of is actually pretty gnarly.
21:24:48 <Iceland_jack> How so?
21:25:18 <simpson> I have two collections of elements and I want to meld them together such that they have at least one order and any overlapping elements are in the middle.
21:25:55 <simpson> Like, {a, b, c} and {c, b, e} would be [({a}, [b, c], {e}] and probably simplify down to [[a, b, c, e]]
21:25:56 <Iceland_jack> What do you mean by “at least one order”?
21:26:12 <simpson> Well, there's another solution to that one: [[a, c, b, e]]
21:26:46 <simpson> I've been thinking about this for a bit. I'll post the writeup in a sec.
21:32:49 <qrada> > length [1,2,3]
21:32:50 <lambdabot>  3
21:33:17 <qrada> my lambdabot does this, when i run that: Ambiguous module name `Control.Monad.Writer'
21:33:20 <qrada> hm
21:36:40 <simpson> http://stackoverflow.com/questions/20842834
21:39:05 <simpson> Iceland_jack: That's basically my problem. It's kind of a silly one.
21:42:28 <Fuuzetsu> with cabal, can you rely on the package being build with a specific flag? Let's say I want to depend on foo-0.1 with -fsome_feature enabled
21:48:35 <simpson> So my thinking was that I could just attempt to smash together each pair of lists and hope for the best, but now I see that even isInfixOf isn't exactly what I want.
21:50:42 <simpson> I guess I want a sequence that has spans that are not ordered and spans that are ordered.
21:56:53 <pavonia_> How do you link in an extra .o file when building an executable with cabal?
22:07:12 <pavonia> Hhm, "ld-options: foo.o" seems to work but it feels a bit hackish
22:07:56 * hackagebot separated 0.0.3 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.0.3 (TonyMorris)
22:18:04 <Fuuzetsu> Are there any books on designing Haskell libraries? It seems that I always fumble it
22:26:09 <enthropy> the ghc manual book
22:26:32 <randomclown> Just keep fumbling
22:26:39 <randomclown> until you stop fumbling
22:26:50 <Fuuzetsu> flawless plan
22:26:58 <randomclown> can't go wrong
22:36:13 <randomclown> how do you get the exception instance when using `bracket`
22:36:20 <BlankVerse_> I have a package foo installing which leads to reinstall of other packages so that a package bar can be downgraded to a lower version. Does this imply that the package foo depends on the older version of bar?
22:37:04 <Fuuzetsu> BlankVerse_: Yes, either on foo or some other dependency needs lower version
22:37:19 <Fuuzetsu> it might just be that the only way for packages to play together is to use a lower version of something
22:37:31 <BlankVerse_> how do I find out that foo depends "indirectly" on bar?
22:37:39 <Fuuzetsu> you can probably dig around and find out what needs the upper bound bumping/fixing
22:37:54 <Fuuzetsu> it should tell you why it's reinstalling I think
22:38:07 <Fuuzetsu> what does your cabal install --only-dependencies --dry-run say?
22:38:22 <xpika> is it possible to invoke runhaskell with a package?
22:38:25 <BlankVerse_> yeah , true, it tells that binary needs to be downgraded from 0.7 to 0.5
22:38:41 <Fuuzetsu> BlankVerse_: Does it not say why next to it?
22:38:48 <BlankVerse_> Fuuzetsu: but the package plugins doesn't seem to depend on binary
22:39:07 <Fuuzetsu> xpika: You'll have to be more specific. You can ‘runhaskell’ on your Main module…
22:39:28 <Fuuzetsu> BlankVerse_: Can you lpaste the full message?
22:39:40 <BlankVerse_> Fuuzetsu: actually , i just did an install without dry-run and it went ahead and did all the downgrading
22:40:19 <BlankVerse_> but I would like that the package binary not be downgraded and find the offending package causing the downgrade and bump its cabal file
22:40:37 <xpika> Fuuzetsu: i want to run the equivalent of ghci -package ghc file_using_package.hs then :main
22:42:15 <Fuuzetsu> BlankVerse_: You could probably ‘cabal unpack plugins’, ‘cabal sandbox init’, ‘cabal install binary’ and then ‘cabal install’ and see what downgrades it. Not sure but if you care enough, it's worth a try
22:42:39 <enthropy> xpika: ghc -package ghc file_using_package.hs -e ":main"
22:43:43 <xpika> enthropy: thanks, that worked!
22:44:16 <BlankVerse_> Fuuzetsu: that did not result in any conflict/reinstall/downgrades
22:44:48 <Fuuzetsu> no idea then… you could check reverse dependencies of binary-0.5 and 0.7 and see how they differ
22:45:29 <joeyh> BlankVerse_: I find cabal install -v3 useful in these situations. Lets you examine the dependency resolver at work, and see what causes it to pick a suboptimal solution
22:46:08 <joeyh> recently a new version of text has been causing some problems like this
22:47:14 <BlankVerse_> Fuuzetsu: so now I don't understand how it can happen, say I have a sandbox of packages U and I try to install a new package plugins into the sandbox, and it leads to downgrading of binary, doesn't it mean that the existing set U was perfectly consistent with binary 0.7 and if it downgrades to 0.5, it must be due to plugins?
22:47:17 <roboguy_> is SublimeHaskell actively maintained? because it seems to be crashing a lot lately
22:49:18 <jle`> i found my facebook status i made when i first read LYAH. "learning haskell. i will think twice before ever saying 'i approach problems functionally' again"
22:49:24 <jle`> almost a year ago now
22:49:34 <jle`> my life was so different back then
22:49:41 <jle`> haskell you rocked my world
22:50:04 <randomclown> jle`: check trends.google.com
22:50:11 <randomclown> haskell is doing the slow decline to death
22:51:01 <jle`> randomclown: :'(
22:51:20 <simpson> randomclown: People still use FORTRAN and COBOL.
22:51:43 <randomclown> simpson: that's not something you want to compare yourself with
22:51:51 <jle`> i use fortran :'(
22:52:00 <randomclown> I use 4chan
22:52:07 <vishnix> simpson: avoid success at all costs ;-)
22:52:12 <zRecursive> randomclown: what does "decline to death" mean ?
22:52:21 <randomclown> zRecursive: trend is going do
22:52:23 <randomclown> downnnn*
22:52:24 <simpson> randomclown: Sorry; do you prefer FORTH for your all-caps language?
22:53:01 * hackagebot fast-logger 2.1.1 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.1.1 (KazuYamamoto)
22:53:11 <Fuuzetsu> randomclown: if the decline to death means all the new libraries Hackage has been getting then I hope it dies faster
22:53:37 <randomclown> The trends are how much people are searching for Haskell on google
22:54:13 <simpson> randomclown: Google is not the totality of humanity.
22:54:41 <zRecursive> Haskell will not die since Math will live forever :-D
22:54:54 <randomclown> simpson: it's merely the 99.9%
22:55:05 <simpson> randomclown: Well, are you a Googler?
22:55:15 <randomclown> No I wish I worked there
22:55:31 <Fuuzetsu> ITT: We argue about how Haskell is dying in one of the biggest channels on Freenode
22:55:33 <simpson> What do you want to do at Google?
22:55:44 <randomclown> Make money
22:55:55 <simpson> Oh. Money's lame. Wanna go write Haskell at Google?
22:56:04 <randomclown> simpson: don't insult the money
22:56:14 <Fuuzetsu> simpson: Pfft, everyone knows that Google use real languages, like Go and Python
22:56:19 <simpson> randomclown: Money is stupid; throw rocks at it.
22:56:24 <enthropy> google trends says it is going down, itself
22:56:25 <simpson> Fuuzetsu: There's Haskell at Google.
22:56:25 <jle`> boo money
22:56:32 <randomclown> simpson: that's just like your opinion man
22:56:43 <simpson> randomclown: Money, so they say, is the root of all evil today!
22:56:52 <zRecursive> use bitcoin instead of papaer money :P
22:57:01 <Fuuzetsu> simpson: Meh, there's just about every language everywhere
22:57:27 <simpson> Fuuzetsu: Okay, lemme rephrase. There are projects that are not dead that are written in Haskell at Google that are looking for people to work on them.
22:57:46 <randomclown> Is mvars the only way to make sure my main thread stays alive?
22:57:59 <randomclown> I need to block until all the forkedIOs are finished
22:58:14 <Fuuzetsu> simpson: Right. Do you know what they're actually doing? I hear they have been trying to recruit people off mailing lists but I don't think I heard of any actual projects.
22:58:47 <startling> Fuuzetsu, well, irc is dying too!
22:59:03 <startling> yeah, I got a google recruiter who mentioned a haskell project of mine.
22:59:07 <startling> several others here did too.
22:59:09 <simpson> Fuuzetsu: Can't say. Probably stuff with machines and learning.
22:59:12 <Iceland_jack> randomclown: You should find the answer on the Control.Concurrent page on Hackage
22:59:16 <Iceland_jack> using MVars
22:59:32 <startling> he was somewhat less interested when I told him I didn't have a degree.
22:59:33 <simpson> When I interviewed at G, the interviewer asked me which language I'd like to use, out of Haskell, C, or Python.
22:59:37 <Iceland_jack> or you could look at async
22:59:41 <Iceland_jack> @hackage async
22:59:41 <lambdabot> http://hackage.haskell.org/package/async
23:00:38 <startling> simpson: that's interesting.
23:00:57 <simpson> startling: Yeah, SWEs without degrees are rare.
23:01:18 <startling> yeah.
23:01:40 <startling> I was kind of miffed at the whole thing tbh.
23:02:12 <randomclown> Iceland_jack: can I use STM TVars and just keep 'retrying'?
23:02:16 <simpson> They insulted my GF when recruiting her. They recently made another pass at her and she told them off, explaining that she wasn't going to put up with rude recruiters and interviewers.
23:02:25 <mgsloan> When I was interning there, there was a big ol mailing list discussion about what the "next language" would be at google.  Haskell came up a lot, but certainly far from definitively
23:02:31 <startling> simpson, ouch.
23:02:43 <simpson> I was also quite irritated at the interview process. Lots of questions designed to infuriate people.
23:03:00 <startling> but yeah, he asked me why I didn't put my degree or experience on my CV (lol) and then stopped responding for a few weeks when I told him why.
23:03:46 <mgsloan> Would you say that the truth was startling??
23:04:04 <mgsloan> Hahah
23:04:14 * mgsloan can never resist an opportunity for a bad pun
23:04:17 <simpson> The "next language" at Google will probably just be more of the same.
23:04:59 <mgsloan> Well, yeah, look at go for example.  Cool stuff there, but nothing too risky or different
23:05:01 <startling> I heard it's Javascript.
23:05:36 <startling> most of Google's front-end development is done in it, anyway.
23:05:47 <jle`> javascript from top to bottom
23:05:50 <jle`> that is the future mang.
23:06:14 <mgsloan> Right, but they've at least got static types for it
23:06:34 <startling> that's microsoft.
23:07:08 <Fuuzetsu> mgsloan: Go's problem is that there is no cool stuff
23:07:16 <startling> the tooling is pretty nice.
23:07:18 <startling> other than that ...
23:07:28 <mgsloan> startling: Google "closure" also does gradual static typing
23:08:17 <startling> "gradual static typing"?
23:08:39 <mgsloan> Fuuzetsu: Yeah, the conundrum of every language!  The libraries and tooling are the most important part for success, even if the language is the most important part for quality
23:09:12 <mgsloan> startling: Yeah, dunno if I'm using the terminology 100% correctly there, but it means that types are annotations and aren't strictly required
23:09:24 <startling> mgsloan: oh, I see.
23:09:33 <mgsloan> In google's codebase you've gotta have a pretty darn good reason to not have types, though, iirc
23:10:02 <Fuuzetsu> types are hard and make you fight with the language, everyone knows that
23:10:07 <startling> I was under the impression that closure created extensonally identical code.
23:10:24 <jle`> ugh i don't want to spend half of my time fighitng with the compiler!!!
23:10:34 <jle`> i would rather spend double the time fighting with runtime errors in production
23:10:44 <mgsloan> startling: Yeah, most people use closure just for the optimization aspect.  But it's also a linter / typechecker / set of libraries
23:10:50 <Fuuzetsu> double is an understatement I think
23:12:51 <startling> jle`: I don't know.
23:13:00 <startling> Most statically-typed language are insane.
23:13:33 <roboguy_> am I going crazy or is this upside down? http://icfp06.cs.uchicago.edu/bird-talk.pdf
23:13:35 <startling> e.g. 90% of the type errors I get in Java are "you spelled this type declaration wrong".
23:14:03 <startling> or "Java forgets some types for no reason".
23:14:09 <Fuuzetsu> roboguy_: it is upside down… mupdf lets you rotate with ‘R’
23:14:25 <startling> haha
23:15:42 <BlankVerse_> can I force ghc --make to search for modules in a sandbox?
23:16:08 <startling> BlankVerse_: yeah.
23:16:34 <BlankVerse_> startling: how?
23:16:46 <startling> BlankVerse_: hang on, finding the argument
23:17:17 <roboguy_> I wonder why it would be upside down...
23:17:52 <lightquake> BlankVerse_: which sandbox are you using? cabal-dev, cabal sandbox, or other?
23:18:00 <BlankVerse_> cabal sandbox
23:18:20 <startling> BlankVerse_, ghc --package-db=.cabal-sandbox/myArch-etc.conf.d
23:18:46 <lightquake> do that, except you also want -no-user-package-db
23:18:59 <lightquake> and you want to ls .cabal-sandbox to get the proper value for 'myArch-etc'
23:19:04 <startling> oh, yes.
23:19:14 <lightquake> oh
23:19:29 <lightquake> also i think you need -package-db .cabal-sandbox/arch.conf.d, not --package-db=
23:19:53 <startling> oh, I'm looking at a cabal thing
23:27:09 <simpson> > let f xs ys = map (xs ++) (catMaybes (map (`stripPrefix` ys) (tails xs))) in f [1,2,3] [3,4,5]
23:27:10 <lambdabot>  [[1,2,3,4,5],[1,2,3,3,4,5]]
23:27:13 <simpson> Nearly there.
23:44:46 <helmut> when refactoring error handling code is there one particular way of error handling I should use for maximum compatibility with others?
