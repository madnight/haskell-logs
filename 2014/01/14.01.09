00:00:21 <Gerldus> Ok, can someone help introduce falling ball behavior in Sodium?
00:00:58 <codygman> What do you use if you need a value from something executed in forkIO? TVar?
00:00:59 <Gerldus> For me it is quite tricky for now. Just help to start )
00:01:39 <randomclown> supki: I get a "directory-1.2.0.1 (reinstall) changes: unix-2.6.0.1. -> 2.7.0.0" that messes everything up
00:02:48 <Axman6> abunchofdollarsi: Yesod has a fairly large focus on performance
00:03:19 <Axman6> abunchofdollarsi: oh and nettle or mcnettle or something is supposed to be the fastest software defined networking implementation around... or something
00:03:48 <c_wraith> well...  It's the fastest on a 40-core box
00:03:50 <Axman6> abunchofdollarsi: http://www.reddit.com/r/haskell/comments/1k6fsl/mio_a_highperformance_multicore_io_manager_for/
00:04:14 <abunchofdollarsi> Cool.
00:04:16 <Axman6> c_wraith: that's a pretty massive box... being fastest on a single core box isn't too interesting imo
00:04:34 <Axman6> "We also show that with Mio, McNettle (an SDN controller written in Haskell) can scale effectively to 40+ cores, reach a thoroughput of over 20 million new requests per second on a single machine, and hence become the fastest of all existing SDN controllers."
00:05:32 <c_wraith> I do wish there'd be a GHC 7.8 RC
00:07:21 <randomclown> how do I find which package is creating the dependency on 'directory-1.2.0.1' which is messing everything else up"
00:08:03 <c_wraith> if you want to be overloaded, you can add -v3 to the cabal command line
00:08:17 <c_wraith> It will give you *far* more information than you ever wanted to know
00:11:04 <randomclown> c_wraith: right problem solved
00:11:29 <randomclown> cabal should just output that whenever it wants people to reinstall and break everything
00:11:36 <Axman6> mo info mean no problems
00:12:31 * hackagebot text 1.1.0.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.1.0.0 (BryanOSullivan)
00:12:31 * hackagebot aeson 0.7.0.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.7.0.0 (BryanOSullivan)
00:12:39 <randomclown> oh wow
00:13:17 <c_wraith> bos is updating stuff again.  nice.
00:14:14 <randomclown> Building aeson-0.7.0.0; Installed aeson-0.7.0.0
00:14:28 <Axman6> Text-1.1? what is this! we only just had Text-1.0! I can't handle this kind of high speed development!
00:14:47 <randomclown> I got text-1.1 too
00:14:49 <randomclown> from that install
00:15:02 <randomclown> the one that I just fixed with the -v3
00:15:09 <Axman6> heh, "* encodeUtf8: Performance is improved by up to 4x."
00:15:20 <c_wraith> randomclown: yeah, hackagebot lags a bit
00:15:46 <c_wraith> A few minutes, usually
00:16:50 <randomclown> what's "cannot satisify -package-id 'name'-inplace'
00:25:19 <randomclown> I run cabal test
00:25:35 <randomclown> and I included my packages as a build-depends for my test-suite
00:26:08 <randomclown> and ghc is saying 'cannot satisify -package-id mypackage-inplace'
00:27:02 <randomclown> it says -v for more information
00:27:04 <randomclown> and -v does nothing
00:45:49 <jtcwang> how do you do anonymous io function?
00:45:52 <jtcwang> this is my attempt: http://lpaste.net/98232
00:46:05 <jtcwang> I've seen it done before but I can't find it on google or in books
00:47:14 <verement> replicateM 5 $ \x -> do
00:48:21 <jtcwang> ah ok
00:48:23 <randomclown> > replicateM 3 $ \x -> print 3
00:48:24 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
00:48:24 <lambdabot>    arising from a use of `M524821927140130635925005.show_M5248219271401306359...
00:48:24 <lambdabot>  The type variable `t0' is ambiguous
00:48:24 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:48:24 <lambdabot>  Note: there are several potential instances:
00:48:46 <randomclown> > replicateM 3 $ \x -> print "sdfdsfd"
00:48:47 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
00:48:47 <lambdabot>    arising from a use of `M385020046562962629525014.show_M3850200465629626295...
00:48:47 <lambdabot>  The type variable `t0' is ambiguous
00:48:47 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:48:47 <lambdabot>  Note: there are several potential instances:
00:48:56 <randomclown> :t replicateM
00:48:57 <lambdabot> Monad m => Int -> m a -> m [a]
00:49:08 <randomclown> > forM 3 $ \x -> print "sdfdsfd"
00:49:09 <lambdabot>  No instance for (GHC.Num.Num [a0]) arising from the literal `3'
00:49:10 <lambdabot>  Possible fix: add an instance declaration for (GHC.Num.Num [a0])
00:49:16 <verement> > forM [1..3] $ \x -> print x
00:49:17 <randomclown> > forM [1..2] $ \x -> print "sdfdsfd"
00:49:18 <lambdabot>  <IO [()]>
00:49:18 <lambdabot>  <IO [()]>
00:49:29 <jtcwang>  hmm still giving me errors
00:50:37 <jtcwang>     Couldn't match expected type `t0 -> IO ()' with actual type `IO a0'
00:50:53 <dv-> > replicateM 5 $ (\x -> print x) 6
00:50:54 <lambdabot>  <IO [()]>
00:53:05 <jtcwang> can we have anonoymous IO that takes no input?
00:53:15 <jtcwang> \ -> do gives me parsing errors
00:53:18 <dv-> > replicateM 5 (print 6)
00:53:19 <lambdabot>  <IO [()]>
00:53:55 <dv-> you are missing an argument
00:54:01 <Axman6> twanvl: \_ -> do
00:54:08 <dv-> (\x -> print x) expects something
00:54:12 <Axman6> uh, jtcwang
00:54:31 <triliyn> jtcwang: for no arguments, don't use a lambda
00:54:36 <triliyn> Just "do ..."
00:54:57 <jtcwang> righty
00:56:34 <jtcwang> thanks, but i'm getting this error
00:56:35 <jtcwang>     Couldn't match type `[()]' with `()'
00:56:35 <jtcwang>     Expected type: IO ()
00:56:35 <jtcwang>       Actual type: IO [()]
00:56:51 <triliyn> Try replicateM_ instead of replicateM
00:56:52 <jtcwang> is it beacause my do block has 2 io functions?
00:57:07 <FireFly> That shouldn't be it, no
00:57:08 <dv-> your main is IO (), but replicateM is returning IO [()]
00:57:30 <triliyn> replicateM_ is like replicateM but it ignores the results of the actions
00:57:32 <dv-> you can add a return () to the end of main to fix it
00:57:38 <triliyn> :t replicateM_
00:57:38 <lambdabot> Monad m => Int -> m a -> m ()
00:57:40 <triliyn> Or that
00:58:24 <jtcwang> hm
00:58:41 <codygman> Does the fact that forkIO is non-deterministic mean that there are some cases where your IO functions wont' get computed even if you use something like evaluate? Would the way to fix this be using strict-concurrency?
00:59:01 <jtcwang> thanks i'll look into it
00:59:48 <jtcwang> got it, its working thanks
00:59:57 <Axman6> codygman: what do you mean by non-deterministic? the action will be executed, as long as main doesn't terminate
01:01:24 <codygman> Axman6: I came across an SO link[1] which says that "the thunk may beat the evaluation of your expression" which I took to mean "sometimes your exprssion won't get evaluated. 1: http://stackoverflow.com/questions/10247555/haskell-concurrency-is-forkio-really-nondeterministic
01:07:15 <Axman6> codygman: if the thread is killed or the program terminates, it may not get executed, sure. but in general, and program that doesn't terminate will eventually run the thread that's been forked
01:09:37 <Axman6> codygman: did you read the first answer?
02:15:39 <park> I have a list of tuples (say [(a,b)]). I want to group these tuples  on the basis of b's value to form a list like [ (b, [a]) ]. What would be the best way to do it
02:16:39 <sipa> :t partition
02:16:40 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
02:19:06 <allsystemsarego> no, not partition
02:19:19 <allsystemsarego> :t M.fromListWith
02:19:20 <lambdabot> Ord k => (a -> a -> a) -> [(k, a)] -> M.Map k a
02:19:37 <allsystemsarego> oh wait
02:20:48 <allsystemsarego> > M.fromListWith (+) [('a',1),('b',1),('a',1)]
02:20:49 <lambdabot>  fromList [('a',2),('b',1)]
02:20:59 <allsystemsarego> park ^^
02:21:38 <Axman6> that didn't form a list though...
02:21:49 <Axman6> as in, (b,[a])
02:22:15 <park> yeah. I want a list
02:22:46 <Axman6> @hoogle groupBy
02:22:47 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
02:22:47 <lambdabot> Data.ByteString.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
02:22:47 <lambdabot> Data.ByteString.Lazy.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
02:23:16 <Axman6> > groupBy ((==) `on` snd) [('a',1),('b',1),('a',1)]
02:23:17 <lambdabot>  [[('a',1),('b',1),('a',1)]]
02:23:25 <Axman6> > groupBy ((==) `on` snd) [('a',1),('b',2),('a',1)]
02:23:26 <lambdabot>  [[('a',1)],[('b',2)],[('a',1)]]
02:24:41 <Axman6> > map ((head &&& id) . unzip) .groupBy ((==) `on` snd) $ [('a',1),('b',2),('a',1)]
02:24:42 <lambdabot>  Couldn't match type `([GHC.Types.Char], [b0])' with `[a0]'
02:24:42 <lambdabot>  Expected type: ([GHC.Types.Char], [b0]) -> a0
02:24:42 <lambdabot>    Actual type: [a0] -> a0
02:24:55 <Axman6> :t unzip
02:24:55 <lambdabot> [(a, b)] -> ([a], [b])
02:25:09 <Axman6> @hoogle both
02:25:09 <lambdabot> System.Posix.Terminal BothQueues :: QueueSelector
02:25:09 <lambdabot> System.Posix.Terminal.ByteString BothQueues :: QueueSelector
02:25:09 <lambdabot> Network.Socket ShutdownBoth :: ShutdownCmd
02:25:37 <Axman6> @hoogle (a -> b) -> (c -> d) -> (a,b) -> (c, d)
02:25:37 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
02:26:13 <Axman6> @hoogle (a -> b) -> (c -> d) -> arr (a,b) (c, d)
02:26:13 <lambdabot> No results found
02:26:20 <Axman6> :t first
02:26:21 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
02:26:21 <drAgda> :t Control.Arrow.(***)
02:26:22 <lambdabot> Couldn't find qualified module.
02:26:31 <Axman6> :t (***)
02:26:31 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
02:26:42 <Axman6> that's the one!, thanks drAgda
02:26:45 <drAgda> :)
02:26:51 <Axman6> > map ((head *** id) . unzip) .groupBy ((==) `on` snd) $ [('a',1),('b',2),('a',1)]
02:26:52 <lambdabot>  [('a',[1]),('b',[2]),('a',[1])]
02:27:02 <Axman6> bleh, needs swap too
02:27:04 <Axman6> :t swap
02:27:04 <lambdabot> (a, b) -> (b, a)
02:27:13 <Axman6> > map ((head *** id) . swap . unzip) .groupBy ((==) `on` snd) $ [('a',1),('b',2),('a',1)]
02:27:13 <lambdabot>  [(1,"a"),(2,"b"),(1,"a")]
02:27:37 <drAgda> might want a sortBy (compare `on` snd) as well
02:27:46 <Axman6> oh yes
02:28:00 <Axman6> > map ((head *** id) . swap . unzip) .groupBy ((==) `on` snd) . sortBy (comparing snd) $ [('a',1),('b',2),('a',1)]
02:28:01 <lambdabot>  [(1,"aa"),(2,"b")]
02:28:04 <Axman6> done!
02:28:16 <Axman6> it'd be nice if @pl could give you that
02:28:27 <allsystemsarego> or @djinn
02:28:36 <Axman6> yeah, that one
02:28:36 <park> that works
02:28:42 <Axman6> it's been a while for me in here =)
02:43:05 <frx> > M.fromListWith (++) . map (fst &&& show . snd) $ [('a',1),('b',2),('a',1)]
02:43:07 <lambdabot>  fromList [('a',"11"),('b',"2")]
02:44:26 <frx> monkey operator is probably a better choice than show
02:47:29 <frx> > M.fromListWith (++) . map (fst &&& (:[]) . snd) $ [('a',1),('b',2),('a',1)]
02:47:30 <lambdabot>  fromList [('a',[1,1]),('b',[2])]
02:49:18 <Axman6> frx: notice he wants (b,[a]), not (a, [b])
02:52:44 <frx> my bad
02:52:58 <frx> > M.fromListWith (++) . map (snd &&& (:[]) . fst) $ [('a',1),('b',2),('a',1)]
02:52:59 <lambdabot>  fromList [(1,"aa"),(2,"b")]
02:53:51 <larryx> what would be a good template haskell tutorial for someone already familiar with haskell and metaprogramming in other languages (scheme, clojure)?
02:59:21 <donri> i think this helped me but it was long ago, not sure if it's the one i read https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md
03:00:01 <donri> http://www.haskell.org/haskellwiki/Template_Haskell
03:00:38 <larryc> thanks donri
03:02:28 <larryc> I know it is hard to compare, but would template haskell be closer to scheme style macros than clojure/CL macros?  are they hygienic?
03:03:12 <donri> i haven't used the lisps, but my understanding is that TH is hygienic
03:03:48 <ChongLi> larryc: what sorts of problems are you trying to solve?
03:04:08 <ChongLi> generally TH is used only where a function would not solve the problem
03:04:23 <maxs`> @hoogle Either a b -> (a -> c) -> Either c b
03:04:24 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
03:04:24 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
03:04:24 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
03:04:28 <ChongLi> such as building the boilerplate for data types (lenses)
03:04:51 <larryc> ChongLi: I understand that
03:05:06 <ChongLi> or when you want to parse a non-haskell file into some data structure at compile time (the shakespeare libs)
03:05:22 <Taneb> maxs`, http://hackage.haskell.org/package/either-4.1/docs/Data-Either-Combinators.html#v:mapLeft
03:05:41 <maxs`> Taneb: thanks!! Been searching for it everywhere
03:05:45 <Taneb> Or http://hackage.haskell.org/package/bifunctors-4.1.1/docs/Data-Bifunctor.html#v:first
03:06:12 <Kaidelong> is that why bifunctor exists?
03:06:26 <Kaidelong> I always wondered
03:06:47 <maxs`> that use of it doesn't need to be a bifunctor
03:06:50 <Taneb> Kaidelong, Either and (,) are both pretty obvious bifunctors
03:07:51 <maxs`> Kaidelong: a Map would be a bifunctor. you can map over the keys, or the values
03:08:06 <maxs`> but it isn't
03:08:46 <Kaidelong> ah, bifunctors are more common than I thought
03:09:05 <Kaidelong> I always wondered why there was so much discussion over them but so little over profunctors, which I saw as a far more useful thing
03:09:16 <maxs`> ChongLi larryc: was this discussion on uses of TH?
03:09:36 <ChongLi> maxs`: yeah
03:09:44 <ChongLi> motivating examples
03:10:26 <ChongLi> most of the motivating examples you might translate from lisp can actually be handled by regular functions
03:10:48 <larryc> maxs`: only the end of it. I am interested in TH learning material, preferably from a perspective of someone familiar with haskell and metaprogramming in lisps. I got some recommendations buy feel free to add some more
03:11:02 <larryc> but
03:11:18 <Kaidelong> I guess in the sense of category theory profunctors are just a subset of bifunctors, but not in haskell
03:13:01 <maxs`> larryc: so ghc 7.6 can't prove (1 <= 2) or do type level subtraction. So instead can use TH to splice definitions of less than and subtraction for numbers up to a bound. https://github.com/maxpow4h/acme-numbersystem/blob/master/Acme/NumberSystem.hs
03:22:21 <larryc> maxs`: that is interesting
03:25:19 <larryc> I delayed learning TH because it is not needed as often in haskell, and also because I am likely to be disappointed by it compared to the ease of metaprogramming in lisps, but I finally decided to take the plunge
03:40:58 <currywurst> hi
03:41:36 <ChongLi> hi
03:41:39 <bjorkintosh> larryc, and?
03:41:43 <bjorkintosh> what did you think?
03:41:50 <maxs`> hi
03:42:16 <kau> Hi guys!
03:42:32 <currywurst> how to to printf \n x times in haskell ;)
03:43:05 <bjorkintosh> currywurst, just use the shell!
03:43:20 <bjorkintosh> bash can do that just fine.
03:43:28 <Lethalman> :t replicateM_
03:43:28 <lambdabot> Monad m => Int -> m a -> m ()
03:43:56 <ChongLi> > replicateM_ 10 (putStr '\n')
03:43:57 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
03:43:57 <lambdabot>  Expected type: GHC.Base.String
03:43:57 <lambdabot>    Actual type: GHC.Types.Char
03:44:04 <ChongLi> > replicateM_ 10 (putStr "\n")
03:44:05 <lambdabot>  <IO ()>
03:44:09 <donri> :t putStr (replicate 10 '\n')
03:44:10 <lambdabot> IO ()
03:44:11 <kau> Do you know some thinks that are instances of Category, beside Lenses and Pipes?
03:44:12 <maxs`> lol
03:44:23 <kau> and functions....
03:44:43 <currywurst> hey cool, not bad..
03:45:07 <donri> kau: netwire, anything that's an arrow, my path type
03:45:36 <kau> which path type?
03:46:15 <donri> it's under construction ;) https://github.com/dag/path actually not a Category yet because it needs ghc 7.8 for that
03:46:19 <mm_freak_> kau: Auto
03:46:27 <mm_freak_> newtype Auto a b = Auto (a -> (b, Auto a b))
03:47:31 <kau> waht's the use of Auto
03:47:33 <kau> ?
03:48:01 <kau> it's a sort of continuation?
03:48:03 <mm_freak_> kau: data LS a b = forall s. LS s ((a, s) -> (b, s))
03:48:09 <mm_freak_> kau: does this type make sense to you?
03:48:56 <kau> mmh, not really
03:49:01 <mm_freak_> ok, let me expand a little
03:49:04 <kau> :)
03:49:17 <mm_freak_> data LocalState a b = forall state. LS s ((a, state) -> (b, state))
03:49:19 <mm_freak_> how about now?
03:49:27 <mm_freak_> data LocalState a b = forall state. LS state ((a, state) -> (b, state))
03:49:33 <donri> kau: also boomerang is a category
03:51:37 <mm_freak_> kau: it's a locally stateful stream processor…  each time it takes an input value, it also takes a state value and returns both an output and an updated state value
03:51:37 <mm_freak_> kau: and Auto is isomorphic to it =)
03:51:37 <kau> ok
03:51:37 <donri> is that mealy or moore
03:51:37 <mm_freak_> mealy in machines terminology
03:51:37 <mm_freak_> you can generalize it in two ways
03:51:49 <kau> I see, and that is an instance of Category?
03:51:49 <mm_freak_> newtype Auto to a b = Auto (a `to` (b, Auto to a b))
03:51:52 <Lethalman> mm_freak_, is that something like ST?
03:52:04 <mm_freak_> newtype Auto m a b = Auto (a -> m (b, Auto m a b))
03:52:10 <mm_freak_> Lethalman: nope
03:52:47 <mm_freak_> kau: yes
03:53:04 <donri> kau: also there's some categories in the categories package
03:53:07 <mm_freak_> kau: AFRP is based on this type, but it's much more versatile
03:53:18 <mm_freak_> think of locally stateful components
03:54:13 <kau> Monads seems to be composable, what's their relation to Category?
03:54:26 <mm_freak_> monads are endofunctors
03:54:43 <mm_freak_> so they are a functor from a category to itself, in haskell's case Hask -> Hask
03:55:06 <mm_freak_> also each monad gives rise to a kleisli category
03:55:17 <mm_freak_> newtype Kleisli m a b = Kleisli (a -> m b)
03:55:23 <kau> Hask is the category of haskell functions?
03:55:28 <mm_freak_> types and functions
03:55:33 <kau> uh
03:56:00 <mm_freak_> Hask is almost like Set, except that every object is a lifted type
03:56:21 <k00mi> kau: another cool Category is HoleyMonoid: http://hackage.haskell.org/package/HoleyMonoid
03:57:01 <k00mi> you can use it for pretty printing: http://hackage.haskell.org/package/formatting
03:57:28 <ocharles> 'data MetronomeHandler a  = MetronomeHandler (E.EitherT Error IO a) deriving (Monad)'  yet:  Can't make a derived instance of `Monad MetronomeHandler'
03:57:31 <ocharles> Why -XGeneralizedNewtypeDeriving...
03:57:34 <ocharles> any ideas why that would be? This normally works...
03:57:59 <merijn> ocharles: "data"?
03:58:02 <ocharles> doh
03:58:08 <mm_freak_> from a practical usefulness point of view i found these categories very useful:  (->), Auto, Boomerang, Proxy, Wire
03:58:15 <ocharles> thanks merijn
03:58:23 <merijn> ocharles: :D
03:58:52 <kau> thanks!
03:59:44 <donri> kau: the free category is also useful. my path type is in fact a free category (but not parametric on the edge set, although it could be)
04:00:24 <kau> Proxy  is the one from Pipes library?
04:00:28 <donri> the free category is even called the path category because it represents a path in a graph
04:00:43 <kau> ok
04:00:55 <kau> Free like in Free monad?
04:01:05 <donri> same idea yes
04:01:09 <kau> sorry for the questions, that's quite a jungle for me :)
04:01:10 <larryx> bjorkintosh: nothing yet, I started learning about TH 20 minutes ago
04:02:37 <donri> stepcut experimented recently with a free category formlet
04:02:52 <kau> interresting
04:03:00 <ocharles> donri: o rly?
04:03:07 <ocharles> donri: I wasn't aware of that, that sounds interesting
04:03:09 <bjorkintosh> hmm. i keep seeing this word 'category', but i thought programming in haskell had next to nothing to do with it?
04:03:29 <Iceland_jack> bjorkintosh: That's right
04:03:54 <donri> well category theory is a generalization of mathematics and programming is applied mathematics :P
04:04:20 <Iceland_jack> It's not needed at all to program
04:04:34 <donri> but you don't have to know about commutative monoids to use addition in every-day life
04:04:45 <bjorkintosh> donri, if programming is applied math, then every BASIC and COBOL programmer is an applied mathematician.
04:04:53 <bjorkintosh> and applied math is HORRIBLE!
04:05:08 <kau> I think usually you take it for granted (as far as composition is concerned)
04:06:20 <kau> do you have a good reference to learn some category theory? ;)
04:06:24 <donri> category theory is a useful tool for library design, but users of the resulting libraries don't have to know the theory
04:06:35 <merijn> donri: I would argue that knowing about commutative monoids is probably far more important to programmers than categories :)
04:06:39 <bjorkintosh> donri, what about creators of the library?
04:06:50 <merijn> bjorkintosh: Even there you don't need too
04:07:14 <merijn> bjorkintosh: It's just that some category theory fans have found that basing their design on it helps create a nicely composable design
04:07:17 <donri> merijn: perhaps, but i was making a non-programmer analogy. you don't need to know abstract algebra to count apples in the store.
04:07:35 <kau> donri: does that mean that your library types have to be an instance of Category to allow you to claim "my library XXX is composable"?
04:07:59 <merijn> bjorkintosh: i.e. Pipes is really elegant, partially because the base of category theory, but there are other elegant libraries not inspired by category theory
04:08:07 <donri> bjorkintosh: it's not a requirement, but it helps for arriving at principled and generic designs
04:08:30 <kau> other way is trial and error, I suppose
04:09:19 <merijn> And intuition
04:09:22 <donri> kau: category theory (even categories) is about more than Category
04:09:30 <merijn> Which I suppose is a form of trial and error
04:09:31 <kau> yes
04:10:30 <bjorkintosh> isn't domain theory far more important, especially for reasoning about programs in lazy languages?
04:11:27 <donri> category theory is not an end-all be-all. let's just say there's a lot of overlap between theoretical computer science and mathematics!
04:11:59 <bjorkintosh> yes. theoretical CS. *not* programming!
04:12:19 <merijn> bjorkintosh: There's a lot of overlap between theoretical CS and non-buggy programs too :)
04:12:25 <bjorkintosh> hah!
04:12:38 <tdammers> non-buggy programs? what is this, magic?
04:12:47 <ChongLi> homotopy type theory!
04:12:48 <merijn> bjorkintosh: Basically, in my experience one of the best way to prevent errors is reasoning over program invariants
04:13:19 <bjorkintosh> merijn, indeed. which FP is supposed to help with.
04:13:41 <merijn> bjorkintosh: Types can help you encode/reason about invariants, so can things like proving laws for typeclasses
04:14:07 <merijn> bjorkintosh: i.e. proving the laws for monad instances lets you reason about correctness of generic monad code (assuming it follows those laws)
04:14:35 <kau> I cannot see the "instance Category" in the Pipes library...
04:14:53 <donri> if it was a Category it wouldn't be a Monad
04:15:07 <merijn> bjorkintosh: Category theory can be useful the same way, we have some laws for categories, you can then reason about whether your generic category code is correct while separately checking whether your code confirms to the laws
04:15:16 <kau> donri: really?
04:15:18 <donri> well it would be the wrong monad
04:15:27 <merijn> kau: There's 3 or 4 conceptual categories in pipes, they're mentioned in the docs
04:15:37 <donri> the point is not Category, the point is the category laws
04:15:43 <kau> OK I see
04:15:54 <merijn> kau: 5 categories, even
04:16:09 <merijn> kau: If you go to Pipes.Core the contents on the right list the heading "categories"
04:17:13 <kau> Each composition operator forms a category, apparently
04:17:33 <donri> composition plus identity
04:17:45 <donri> there's an identity pipe in each of the five categories too
04:18:03 <randomclown> merijn: > 3 or 4 conceptual categories in pipes, Jesus Christ how horrifying
04:18:41 <merijn> randomclown: Why?
04:19:06 <bjorkintosh> he prefers his programming, without applied math.
04:19:07 <bjorkintosh> :D
04:19:32 <merijn> pipes having 5 categories is bad in the same as "natural numbers have 2 monoids" is bad
04:19:33 <randomclown> merijn: that was a joke btw
04:19:39 <merijn> You could just ignore they exist, for one
04:19:46 <bjorkintosh> *gasp* which two?
04:19:50 <donri> randomclown: note that two of those are duals of two others so it's really three categories, representing bidirectional pipelines and horizontal/vertical composition
04:19:53 <bjorkintosh> i did not know this!
04:19:58 <merijn> bjorkintosh: Sum and Product?
04:20:34 <bjorkintosh> duh.
04:20:39 <bjorkintosh> i thought you meant something else.
04:20:45 <merijn> bjorkintosh: :)
04:21:08 <mgsloan> Of course, naturals really have infinitely many monoids, just most of them aren't very useful
04:21:22 <merijn> bjorkintosh: That's just one illustration of how this "Haskell is full of math!!!" thing gets way too much credit
04:21:35 <merijn> Haskell is full of math, but then again, so is everything else
04:21:55 <merijn> Haskellers just tend to get more enjoyment out of talking about it :p
06:35:38 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
06:35:38 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
06:38:25 * hackagebot digestive-functors-aeson 1.1.3 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.3 (OliverCharles)
06:38:41 <dmj`> donri: If I have 2 states, and they both use a specific type, I change that type. Won't I need to make two migration instances since I have two safe copy instances? Suppose its 2 maps across two states, the value type is the type of the type I change
06:38:57 <shlevy> dmj`: Why would you have two safe copy instances?
06:39:19 <dmj`> shlevy: yea I guess they wouldnt...
06:39:52 <donri> dmj`: safecopy is recursive. one instance per type. contained types have their own instances.
06:41:47 <dmj`> I see, ok, but still. If I have to backup my database, I now have 2 dbs, and 2 sets of checkpoint and event files that need to be in sync.
06:41:57 <donri> that's one reason orphan instances are problematic, because you can actually have two different, incompatible instances for the same type
06:42:30 <donri> dmj`: why would they need to be in sync?
06:42:55 <shlevy> dmj`: If all queries/updates are ultimately performed on the parent state, why would you need two separate files?
06:43:12 <donri> one constraint i added to that suggestion was "no cross-module atomicity" by which i mean that the events will not depend on each other
06:43:25 * hackagebot make-package 1.0.0 - Make a cabalized package  http://hackage.haskell.org/package/make-package-1.0.0 (PhilippBalzarek)
06:46:38 <Aleksejs> which would be the best solution for DB if I want to develope web app with happstack?
06:46:47 <dmj`> donri: suppose on an operation I modify two hashtables both located in different states. One succeeds and the other fails, since remote operations can fail. Let's say, it's something to do w/ user registration.
06:46:56 <donri> Aleksejs: if you have no further constraints, acid-state
06:47:57 <donri> Aleksejs: some would say it's not really a database, though you can use it to build a database of sorts.
06:48:26 <shlevy> :t flip const
06:48:27 <lambdabot> b -> c -> c
06:48:51 <donri> dmj`: yes, if you need cross-state atomic transactions, don't use multiple states
06:50:17 <donri> dmj`: (still don't see what this has to do with migrations though)
06:51:35 <dmj`> donri: when a migration gets applied does anything happen on disk?
06:52:52 <Aleksejs> donri, thanks! looks interesting
06:53:26 * hackagebot make-package 1.0.0.1 - Make a cabalized package  http://hackage.haskell.org/package/make-package-1.0.0.1 (PhilippBalzarek)
06:55:56 <dmj`> it has to get written to disk to replay the log properly from the last checkpoint. I was confused about what types safecopy handles. If I have 2 states, w/ 2 maps where the type of the value is the type I change then one migration is all that is needed and both states will add that to their log.
06:57:54 <dmj`> one map for each state
06:58:45 <donri> dmj`: migrations only affect how bytes are deserialized into haskell values. they don't affect the disk at all.
07:02:50 <donri> dmj`: the bytes on disk are tagged with versions. if the version is not the latest, the MigrateFrom type family resolves the previous version, recursively down to the first version, and we can then migrate the deserialized old version, again recursivly, up to the latest
07:03:05 <donri> dmj`: if you checkpoint, that migrated version is what is written to disk
07:03:25 <donri> but the effect of reading from such a checkpoint is the same as replaying the log
07:04:53 <donri> but i still don't see how multiple states make any difference here. as i said the effect is the same however you read the state
07:04:55 <donri> it's all pure
07:05:43 <danilo2> Hello! Does anybody know, why such exrpession does not compile? "tst2 = $(mkRTuple [[|1|],[|2|],[|3|]])", where signature of mkRTuple is "mkRTuple :: [ExpQ] -> DecsQ". The error I'm getting is: Couldn't match type `[Dec]'  with `Exp'. I think [|1|] should produce ExpQ, shouldnt it?
07:06:16 <merijn> dmj`: You're wondering how a single map on disk can have multiple serialisations (for different versions), right?
07:06:54 <dmj`> donri: I see, so the safecopy version number is saved to disk w/ the bytes. The migration information must also be saved to disk, how else will it know how to deserialize properly?
07:07:00 <donri> merijn: they're wondering how using the same type in two acid-state logs would affect safecopy migrations
07:07:40 <donri> dmj`: only the versions are written to disk. the rest is in the code, and yes you can screw it up if you change the code
07:08:33 <dmj`> donri: if I perform a migration successfully I thought I could remove that instance. As long as I incremented the deriveSafeCopy counter.
07:08:45 <donri> dmj`: only if you checkpoint
07:09:00 <donri> and yes then you have to checkpoint all states that use the type
07:09:56 <shlevy> Is there something similar to https://ghc.haskell.org/trac/haskell-prime/wiki/LambdaCase in ghc?
07:10:20 <donri> shlevy: yeah, LambdaCase :P
07:10:29 <shlevy> Heh just found that :D
07:10:55 <donri> the syntax is \case x -> y though
07:11:26 <shlevy> ah no of?
07:11:54 <dmj`> donri: Ah I see. And on the topic of checkpointing. Checkpointing means I only have to replay the log from the last checkpoint. So the entire current state is saved to disk on the last checkpoint. Won't there be a lot of redundant data on disk then?
07:12:30 <shlevy> dmj`: But you can delete the log after checkpointing
07:13:03 <danilo2> Hmm, a small update: does anybody knows, why such TH code doesnt work: "xxx = $(mkRTuple [e|1|])", while this one just works: "$(mkRTuple [e|1|])" (on top level)
07:14:06 <merijn> dmj`: No, after the checkpoint completes you can throw away all older info
07:14:22 <merijn> That's kind of the point
07:14:56 <shlevy> If I just care about the current state, is there any reason not to bracket every db call with a checkpoint?
07:15:09 <merijn> shlevy: Checkpoints are slow
07:15:19 <dmj`> merijn: so, shouldn't I be creating checkPoints after each update/query then? What if the process dies?
07:15:22 <donri> well that's the point of archive, which is only useful after checkpoint ;)
07:15:22 <merijn> shlevy: The reason to use a log is that you're much faster
07:15:29 <merijn> dmj`: That's what the log is for
07:15:30 <dmj`> shlevy: my question exactly
07:15:41 <donri> checkpoints can make loading state faster, although it can reduce sharing
07:15:51 <merijn> dmj`: The log stores all modifications. If the process dies you take the old state and replay all transactions in the log
07:16:05 <Philonous> danilo2, I suppose mkRTuple has type (... -> Q [Dec])? That means it can't be used in an expression context.
07:16:08 <merijn> dmj`: The idea is that storing a log is much cheaper than serialising the entire structure every time
07:16:08 <shlevy> So is it premature optimization to save space with checkpoints, or to save time by not checkpointing? :D
07:16:33 <merijn> shlevy: You want to checkpoint occasionally to avoid loads becoming to slow and wasting to much space
07:16:55 <merijn> shlevy: How frequently depends on how frequently you expect to reload and how many transactions you have
07:17:18 <jrmithdobbs> shlevy: a lot of time it is
07:17:30 <shlevy> jrmithdobbs: What is?
07:17:32 <mm_freak_> i checkpoint each time the program quits
07:17:36 <merijn> Also, checkpointing frequently wastes time
07:17:38 <jrmithdobbs> shlevy: it is premature optimization
07:17:46 <shlevy> jrmithdobbs: I gave two options :D
07:17:58 <jrmithdobbs> shlevy: you didn't say xor.
07:18:02 <merijn> mm_freak_: Sure, but if you have a long running daemon that might not be ever :)
07:18:13 <shlevy> jrmithdobbs: If I don't have any performance intuition, should I by default never checkpoint or always checkpoint?
07:18:14 <Philonous> danilo2, Splices in an expression context need to have type (Q Exp), IIRK
07:18:16 <shlevy> jrmithdobbs: :P
07:18:36 <merijn> shlevy: I'd say checkpoint once daily OR when you shut down
07:18:58 <jrmithdobbs> it entirely depends on how expensive your checkpoints really are
07:19:04 <merijn> Also true
07:19:07 <donri> i'd say ignore checkpoints until you know why you want them :P
07:19:12 <mm_freak_> merijn: if your database partition runs full, you get an exception, which causes the program to quit and the checkpoint to be created =)
07:19:22 <mm_freak_> merijn: (mostly joking)
07:19:22 <merijn> mm_freak_: ;)
07:19:34 <merijn> mm_freak_: I'm a big fan of crash-only applications :)
07:19:39 <merijn> Hence why I like acid-state
07:19:45 <mm_freak_> yeah
07:19:49 <mm_freak_> absolutely
07:20:05 <dmj`> merijn: is the log written to only when a checkpoint is made? And how is it written. forkIO $ BS.appendFile bytes ?
07:20:19 <merijn> dmj`: The log is written every time you do an operation, that is the point
07:20:27 <shlevy> dmj`: The point of the checkpoint is to not have to keep the old log
07:20:42 <merijn> dmj`: Whenevr you do an acid-state operations it guarantees that the operation will be stored to disk before returning (hence the ACID guarantees)
07:20:42 <donri> well, any time you issue an Update event
07:20:46 <jrmithdobbs> shlevy: also you have fun things like bitcoin where even if you checkpoint for auditbility you can't trash the log because the log is the system ;p
07:20:46 <mm_freak_> dmj`: every time you do an Update a log entry is written using a crash-safe transactional method
07:20:50 <donri> queries don't block and don't touch the disk
07:22:00 <dmj`> mm_freak_: so checkpoints just create new checkpoint files, and a new log. When there is no log all operations are appended to the current log, is that correct?
07:22:02 <merijn> dmj`: You can only "lose" an update if you crash after the update and before it finishes (because when it finishes it'll be on the disk), which is conceptually the same as if your application crashed right before it did the update
07:22:13 <dmj`> oops
07:22:15 <jrmithdobbs> shlevy: well, theorhetically you "can" but it's proving to be quite hard realistically.
07:22:19 <dmj`> I meant to say, "When there is no checkpoint"
07:22:20 <merijn> "after you *start* the update"
07:23:04 <mm_freak_> dmj`: a checkpoint writes an actual serialized representation of the current state
07:23:11 <Cale> Hehe, checking to see if edwardk is around, and I noticed there's an edk here, but his IRC client gives his name as Ed Kellett rather than Ed Kmett :)
07:23:26 <mm_freak_> dmj`: to reconstruct your state all you need is the latest checkpoint and all log entries written since then
07:23:29 <jrmithdobbs> so if there is no checkpoint you just write to the log
07:23:38 <merijn> jrmithdobbs: Yes
07:23:45 <jrmithdobbs> if there is no checkpoint or log then you create a log
07:24:20 <dmj`> donri: I'm confused about how queuries are non-blocking. The core of acid-state is an MVar. STM is only introduced when using acid-state's remote features
07:24:20 <merijn> jrmithdobbs: Well, I'm pretty sure that opening an acid-state "file" (or whatever they're called) creates a base checkpoint and empty log
07:25:23 <jrmithdobbs> merijn: sure it's hidden but that's still what's happening
07:25:27 <donri> dmj`: queries are just readIORef i think
07:26:01 <merijn> dmj`: It just uses CAS for updates, I think
07:26:07 <Cale> Anyone else have a look at the coeffects paper which uses monoidally indexed comonads?
07:26:15 <Cale> (http://tomasp.net/academic/papers/coeffects/coeffects-icalp.pdf)
07:26:18 <merijn> dmj`: So either you read before or after the update, but I don't see why you'd block
07:26:38 <merijn> dmj`: acid-state doesn't have a notion of transactions, so I don't see why queries would ever block?
07:26:58 <shlevy> Can someone give me a pointer to info about "associated types" of a typeclass? I get what they're for but not how they're used
07:27:24 <mornfall> shlevy: google type families
07:27:29 <merijn> shlevy: Try the "Fun with Type Functions" paper, that covers associated types/data too
07:27:37 <donri> merijn: well events are transactions
07:27:48 <merijn> donri: Sure, but you only have atomic events, no?
07:27:49 <shlevy> merijn, mornfall: Thanks!
07:27:52 <donri> also called methods. yes we have three words for this in acid-state. :P
07:28:10 <donri> merijn: not sure what you mean there
07:28:25 <donri> (what are transactions if not atomic, anyway?)
07:28:50 <dmj`> merijn: if it were an MVar and many threads were trying to read from it, the handle would have to be shared and blocking could occur right?
07:28:53 <merijn> I should maybe just stop talking here, as I've already exhausted my knowledge of current acid-state
07:28:54 <mornfall> donri: they are atomic and cid
07:29:30 <dmj`> merijn: please don't, it's helping my knowledge of acid-state :)
07:29:33 <donri> mornfall: :P
07:29:47 <merijn> dmj`: Not if I talk bullshit :)
07:30:12 <merijn> dmj`: I'm not sure to what extent/how acid-state transactions work, I only know the basic operation of logging/checkpointing :)
07:31:05 <Cale> It struck me that it would actually be useful to index monads and comonads by the arrows of an arbitrary category. It's too bad this is tricky :)
07:31:19 <donri> dmj`: so anyway an AcidState handle (for a Local state) just holds an IORef. for queries, it's just readIORef. for updates, it uses an mvar for [b]locking, but the state itself is not in the mvar. i think.
07:32:00 <Cale> The indexed monads in the sense of Edward's package are what you get when you pick the indiscrete category on the set of Haskell types
07:32:36 <Cale> You can also index analogously using a monoid, but you need the monoid multiplication at the type level.
07:32:46 <merijn> Am I a bad person for considering usin RebindableSyntax to get do notation for indexed monads? :>
07:33:21 <ion> If you’re asking “am I a bad person for…” you probably are.
07:33:31 <donri> merijn: no, it's the standard way to do it
07:33:57 <donri> @hackage indexed-do-notation is another way (QQ)
07:33:57 <lambdabot> http://hackage.haskell.org/package/indexed-do-notation is another way (QQ)
07:34:18 <donri> although i don't know if you can nest with that
07:34:22 <Cale> and combining the two approaches gives you a weird sort of family of endofunctors, one lying over each arrow in a chosen category, and you use the composition of the category in giving the refined type of join/cojoin (or bind/cobind), and you use the identities for the category in giving the refined type of return/coreturn.
07:34:27 <dmj`> donri: ok cool. big thanks, Have a better understanding how it all fits together.
07:35:15 <shlevy> Is it possible to constrain a type signature so that two associated types are the same?
07:35:18 <dmj`> were did the idea of acid-state come from? Serializing types and queries on them? Was it based on something? or just the planets aligned.
07:35:20 <dmj`> where*
07:35:34 <donri> shlevy: ~
07:35:48 <shlevy> donri: Sorry I need more than that :D
07:35:49 <donri> :kind (a ~ b)
07:35:51 <merijn> dmj`: It's based on the rather simple idea of "ACID persisted heap object"
07:35:58 <shlevy> thanks
07:35:58 <donri> :k (a ~ b)
07:35:59 <lambdabot> Not in scope: type variable `a'
07:35:59 <lambdabot> Not in scope: type variable `b'
07:36:02 <donri> :(
07:36:09 <merijn> (a ~ b) :: Constraint
07:36:27 <donri> in deed
07:36:31 <shlevy> so I can put a ~ b in the list of constraints?
07:36:35 <merijn> shlevy: Yes
07:36:39 <shlevy> cool
07:36:50 <merijn> shlevy: "a ~ b" is the constraint that 'a' and 'b' unify
07:37:17 <donri> :t 3 :: (Int ~ Char) => Int
07:37:18 <lambdabot>     Couldn't match expected type `Char' with actual type `Int'
07:37:18 <lambdabot>     In the expression: 3 :: Int ~ Char => Int
07:37:18 <lambdabot>     Couldn't match type `Int' with `Char'
07:37:55 <mauke> :t ?x
07:37:56 <lambdabot> (?x::t) => t
07:37:59 <merijn> shlevy: See also, my neat (but broken in current HEAD) constraint abuse: https://gist.github.com/merijn/6130082/6c12ac84bbe86a473ef1cd28ab5dcb55ccedc307
07:38:06 <mauke> :t ?x :: (?x ~ ?y)
07:38:06 <lambdabot> parse error on input `~'
07:38:18 <mauke> :t ?x :: (?x :: t ~ t)
07:38:19 <lambdabot>     Predicate `?x :: t ~ t' used as a type
07:38:19 <lambdabot>     In an expression type signature: ?x :: t ~ t
07:38:19 <lambdabot>     In the expression: ?x :: ?x :: t ~ t
07:38:25 <dmj`> merijn: Interesting, also any pointers for minimizing RAM consumption in acid-state? I have a message queue and a lot of maps in my state. What if the state gets over 3GB? Or are there multiple states necessary
07:38:33 <merijn> btw, if anyone knows how to fix that example with recent HEAD, lemme know so I can fix it. I'm too lazy to rebuild the newest head
07:39:09 <merijn> dmj`: acid-state always keeps your complete state in memory, personally I think promoting acid-state as a database replacement is bad, as it serves a different need then databases
07:39:40 <Clint> i agree
07:39:43 <merijn> dmj`: If you have data sets that are significantly larger than your RAM I'd probably just use a "real" database
07:40:08 <merijn> s/then/than
07:41:50 <donri> dmj`: it keeps the full state in memory but not the full log. you can issue updates that drop old messages and they'll GC just like anything else
07:42:35 <dmj`> merijn: Yea, for things like creating arbitraty queries I can see the shortcomings of acid-state.
07:43:07 <donri> queries and indexing becomes a data-structure problem with acid-state
07:43:51 <donri> (packages like data-store try to cater to that)
07:44:23 <merijn> donri: Sure, but there comes a point where you need to consider whether throwing a database at the issue might not be simpler :)
07:45:20 <donri> certainly. for some applications, an external database can complement acid-state very nicely.
07:48:48 <dmj`> Having type checked updates and queries is so nice though. If acid-state had a query language, use "select from where" syntax over hash tables, that'd be interesting
07:49:07 <dmj`> and probably inefficient
07:49:11 <donri> merijn: i feel like the same way acid-state is "not a database", people default to databases for problems that are more suited for something like acid-state. two different tools for different problems. (:
07:49:33 <donri> dmj`: that's what data-store and friends give you, more or less
07:49:50 <merijn> donri: Sure, I'm just trying to caution people to avoid noSQL like things where all they've got is acid-state and everything looks like a nail ;)
07:50:22 <merijn> For a simple blog or something you could easily use acid-state as a database, but for more complex things people should carefully consider what they want/need
07:50:27 <donri> i think the whole noSQL buzz is an indicator of this misuse of databases (for "mere persistence")
07:50:55 <donri> see also: ORMs
07:51:32 <merijn> Right, I feel acid-state fills the generic persistence gap pretty nicely :)
07:52:16 <donri> sql and relational databases are powerful tools for basically "big data", but people try to use them like acid-state :P
07:53:13 <Maior> donri: even in scare quotes, please, those words make me come out in hives
07:53:20 <donri> :D
07:53:40 <dmj`> merijn: I know what you're saying. I have a message queue in acid-state, worker nodes connect to it and pop off messages to do stuff. It seems to work well, definitely keeps things from becoming a 3rd party integration nightmare, we'll see how it holds up. So far haven't dropped any queue messages. I tcp/ip I trust.
07:53:51 <donri> Maior: http://www.serpentine.com/blog/2013/04/30/big-fucking-deal/
07:54:34 <Maior> lol
07:54:44 <dmj`> It would run over ssl too if I there was a 64-bit haskell platform for windows
07:56:47 <donri> dmj`: have you looked at distributed-process?
08:01:17 <dmj`> donri: A little bit. I like the idea of each node getting it's own queue. The only thing that wasn't immediately obvious was how to persist the queues if I shutdown a node.
08:02:16 <donri> ah yeah maybe need acid-state after all. or both. :D
08:03:21 <dmj`> donri: and what if I change the format of a queue message. Seems like I'd need version control. Both would definitely be cool. Next project.
08:03:36 <donri> :)
08:04:00 <donri> i've been vaguely pondering if distributed-process could be useful for the remote backend, and for the future replication and sharding support
08:05:35 <dmj`> donri: that is very interesting, I think the current replication (which I don't believe is currently working) attempts to use zeroMQ to shuffle the bytes around.
08:05:55 <dmj`> https://github.com/acid-state/acid-state/blob/master/src/Data/Acid/Replication.hs
08:09:32 <dmj`> stepcut mentioned at a user group meeting that in theory acid-state logs could be saved to an s3 bucket, just hasn't been tried.
08:11:00 <merijn> Any lens afficionados that can help me out with terminology? There's different types of traversals and I wonder which have names (and what those names are)
08:11:30 <merijn> i.e. traverals that produce 0 or 1 outputs per input, 1 output per input, 1 or more outputs per input and 0 or more outputs per input
08:13:55 <Philonous> merijn, The first one is a Prism (0 or 1), 1:1 is a Lens, and 0 or more is a Traversal. Does that make sense?
08:14:21 <merijn> Philonous: I didn't mean in lens terminology, I meant in more general terminology
08:14:32 <Philonous> Oh, ok.
08:14:38 <merijn> Philonous: i.e. I think people were calling prisms affine traversals
08:15:04 <Philonous> OK, I wouldn't know about that.
08:18:18 <Cale> lol, I kind of want a Monoid kind-class so that I can define type-level monoids now.
08:18:21 <merijn> Completely unrelated: UTLC doesn't have the Church-Rosser property, right?
08:19:19 <Philonous> merijn, Untyped?
08:19:20 <merijn> Since the different reduction strategies may result in different final terms (i.e. if one hits a non-terminating reduction sequence)
08:19:23 <merijn> Philonous: Yeah
08:19:32 <Philonous> merijn, No, it's confluent
08:19:39 <Philonous> merijn, It's just not normalizing
08:20:02 <companion_cube> I think it works because any term has at most one normal form
08:20:13 <Cale> It's actually a lot more surprising in the case of the untyped lambda calculus
08:20:53 <sradimmi> @pl \simplify this equation -> equation flip this simplify
08:20:54 <lambdabot> flip (flip . flip ($ flip))
08:22:12 <merijn> oh, looks like it's impossible to state UTLC has Church-Rosser or not as it's a property of the reduction system
08:22:17 <sradimmi> @pl \a b c d -> (a c) g
08:22:18 <lambdabot> const . (const .) . flip flip g
08:22:31 <sradimmi> @pl \
08:22:31 <lambdabot> (line 1, column 2):
08:22:31 <lambdabot> unexpected end of input
08:22:31 <lambdabot> expecting pattern
08:23:04 <Cale> merijn: Well, yes, if all you want are equivalences and you don't direct them somehow
08:23:29 <Cale> Well, okay, it's a little more than that :)
08:23:30 <merijn> Which would mean UTLC only has confluence (and thus Church-Rosser) if you use a reduction system that is guaranteed to find normal forms
08:23:52 <sradimmi> @pl \x -> let {factorial 0 = 1; factorial n = n * factorial (n-1)} in (factorial x)
08:23:52 <lambdabot> (line 1, column 11):
08:23:52 <lambdabot> unexpected "{"
08:23:52 <lambdabot> expecting "()", natural, identifier or "in"
08:24:09 <Philonous> merijn, There's no such thing. Some terms don't have normal forms under any evaluation strategy
08:24:10 <Cale> I think it still has confluence in the free reduction system where you can opt to reduce any redex.
08:24:23 <merijn> Cale: It's just that this paper was claiming "lambda calculus has Church-Rosser, thus we can do X", so
08:24:36 <merijn> Philonous: Those are still confluent, iff normals forms that exist are found
08:25:09 <Philonous> merijn, AFAIK UTLC doesn't specify the evaluation order. Church Rosser only makes sense when you can choose the evaluation step anyway.
08:25:23 <sradimmi> @pl \a b c -> (a b c) (b a c) (b c a) (a c b) (c a b) (c b a)
08:25:23 <lambdabot> ap (ap . (ap .) . ap (ap . (ap .) . ap (ap . (ap .) . ap (ap . (ap .) . liftM2 ap (ap .) (flip id)) (flip flip)) flip) (flip . flip id)) (flip (flip . flip id))
08:25:39 <merijn> Philonous: Confluence means that for any X "X ->* U" and "X ->* V" there are reduction sequences such that "U ->* Z" *and* "V ->* Z"
08:25:57 <Cale> merijn: Of course, if you fix an evaluation order, it's confluent.
08:26:00 <merijn> Philonous: UTLC doesn't specify evaluation order, hence why only a specific reduction system can have Church-Rosser
08:26:06 <Philonous> Cale, trivially
08:26:10 <merijn> Cale: Ah, true
08:26:11 <Cale> yes
08:26:18 <sradimmi> @pl \a b c -> a (b,c)
08:26:18 <lambdabot> (. (,)) . (.)
08:26:24 <Cale> merijn: But what's being claimed is more than that
08:26:39 <Cale> merijn: You can allow the application of beta reduction anywhere at any time
08:26:44 <Cale> merijn: and it's still confluent
08:26:53 <sradimmi> @pl \a (b, c) -> a b c
08:26:53 <lambdabot> (`ap` snd) . (. fst)
08:26:57 <Lethalman> flipper
08:27:34 <Philonous> merijn, If you specify evaluation order you will always get to the same terms, so there's no fork that can be closed again, hence Church Rosser becomes meaningless. Maybe I'm misunderstanding what you're saying
08:27:42 <sradimmi> @pl \a [b,c,d,e,f] -> a b c d e f
08:27:43 <lambdabot> (line 1, column 4):
08:27:43 <lambdabot> unexpected "["
08:27:43 <lambdabot> expecting operator, pattern or "->"
08:27:57 <merijn> Philonous: I'm not saying anything, I'm checking whether what this paper said made sense
08:28:31 <sradimmi> @pl \x y -> y x
08:28:31 <lambdabot> flip id
08:28:32 <Cale> merijn: Basically the proof of this involves tracking down where the sites at which you need to apply beta in the case where you have some application (\x. M) N and you applied beta somewhere in M or in N before applying it to this whole expression.
08:28:52 <nooodl> sradimmi: might wanna /query lambdabot
08:29:14 <sradimmi> @pl \x y -> (x y) (y x)
08:29:15 <lambdabot> ap ap (flip id)
08:29:18 <Cale> Well, that vs. applying it to the whole expression and then having to track down where to apply beta so that it becomes equivalent
08:29:58 <Cale> (Or I should say, so that it becomes equal)
08:30:26 <sradimmi> > let x = 1: map (3*) x in x
08:30:28 <lambdabot>  [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,143...
08:30:50 <Cale> (That's the interesting part at least, I think)
08:32:29 <sradimmi> > let x = x+1 in x
08:32:32 <lambdabot>  mueval-core: Time limit exceeded
08:33:10 <Cale> > let x = error x in x
08:33:11 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
08:33:38 * hackagebot twitter-types 0.2.20130101 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.2.20130101 (TakahiroHimura)
08:34:12 <sradimmi> Why does `x = 1:map (2*) x` work without a base case?
08:34:37 <simpson> The base case is the `1:` there.
08:35:23 <Cale> sradimmi: Do you know about how recursion finds fixed points?
08:36:45 <Cale> An undefined list is not a fixed point of the function (\x -> 1 : map (2*) x). If you keep applying that function, the list you obtain gets more and more defined:
08:36:48 <Cale> > undefined
08:36:49 <lambdabot>  *Exception: Prelude.undefined
08:36:55 <Cale> > (\x -> 1 : map (2*) x) undefined
08:36:56 <lambdabot>  [1*Exception: Prelude.undefined
08:37:02 <Cale> > (\x -> 1 : map (2*) x) (\x -> 1 : map (2*) x) undefined
08:37:03 <lambdabot>  Couldn't match expected type `a2 -> t0' with actual type `[a0]'Couldn't matc...
08:37:14 <Cale> > (\x -> 1 : map (2*) x) ((\x -> 1 : map (2*) x) undefined)
08:37:15 <lambdabot>  [1,2*Exception: Prelude.undefined
08:37:39 <Cale> > (\x -> 1 : map (2*) x) . (\x -> 1 : map (2*) x) $ undefined -- I think I'll switch to writing it this way, just to avoid paren hell
08:37:40 <lambdabot>  [1,2*Exception: Prelude.undefined
08:37:50 <Cale> > (\x -> 1 : map (2*) x) . (\x -> 1 : map (2*) x) . (\x -> 1 : map (2*) x) $ undefined
08:37:51 <lambdabot>  [1,2,4*Exception: Prelude.undefined
08:38:21 <joelteon> > let x = 1 : map (2*) x in x
08:38:22 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
08:39:45 <stelleg> @src concatMap
08:39:45 <lambdabot> concatMap f = foldr ((++) . f) []
08:39:49 <Lethalman> :t it
08:39:50 <lambdabot>     Not in scope: `it'
08:39:50 <lambdabot>     Perhaps you meant one of these:
08:39:50 <lambdabot>       `id' (imported from Data.Function),
08:40:46 <Lethalman> in order to use stream fusion, one should import Data.List.Stream ?
08:40:47 <Cale> So, it's like applying the function (\x -> 1 : map (2*) x) in a nested fashion, as many times as necessary.
08:40:57 <Lethalman> why isn't it built in?
08:41:22 <Cale> Lethalman: because it's not always better, iirc
08:42:05 <Cale> There are cases where the list version of stream fusion is better than the standard Data.List library's foldr/build fusion, and there are cases where it doesn't work out as well.
08:42:16 <Lethalman> Cale, ah
08:42:16 <Lethalman> Cale, do you have some reading handy?
08:42:20 <Cale> iirc, there was some problem with list comprehensions
08:42:22 <hooplahoops> Hello, hoes does GHC typically allocate variants? Does each allocated instance have a type tag?
08:42:25 <mello__> Hi all, I've got a question
08:42:26 <mauke> Cale: concatMap
08:42:45 <Cale> Well, yeah, the question is how well concatMaps stream fuse :)
08:42:56 <mm_freak_> hooplahoops: type information is lost after compilation
08:43:19 <mello__> I've got a function who's returnvalue is m (Maybe ByteString), how do i use <$> to manipulate it?
08:43:21 <mm_freak_> hooplahoops: polymorphism is realized through boxing, not through instantiation
08:44:07 <mello__> ((++) "foo" . BT.unpack) <$> otherfunction, fails
08:44:28 <mm_freak_> mello__: fmap (fmap f)
08:44:31 <mauke> hooplahoops: yes
08:44:38 <mm_freak_> mello__: or liftM (fmap f)
08:44:42 <mello__> mm_freak_, why? because it is wrapped in m?
08:44:53 <mm_freak_> mello__: the outer one is for the m, the inner one for the Maybe
08:45:05 <mm_freak_> mello__: and i'm assuming that m is a monad
08:45:15 <hooplahoops> mm_freak_: understood, so this means every value in polymorphic (unspecialized) code is a pointer to some data, correct?
08:45:15 <hooplahoops> mm_freak_: But that data has to identify which "case" it is in the variant, through a tag
08:45:30 <mello__> m is MonadSnap, actually mm_freak_
08:45:34 <Cale> hooplahoops: If I understand what you're trying to ask, data types with more than one constructor end up representing the constructors with integer tags
08:45:38 <mm_freak_> hooplahoops: yes to the first, no to the second
08:45:44 <mello__> but it is a monad as well
08:45:44 <mm_freak_> hooplahoops: GHC uses a tagless compilation scheme
08:45:50 <Cale> mm_freak_: uhhhh
08:46:26 <Cale> mm_freak_: the taglessness of STG doesn't refer to constructors not being represented
08:46:36 <Cale> oh
08:46:38 <mm_freak_> hooplahoops, Cale: btw, i'm assuming that this is about polymorphism, not about constructors of a single data type
08:46:54 <Cale> Well, I see how mm_freak_ is interpreting things
08:47:45 <Cale> hooplahoops: The pointers themselves won't *always* be tagged (in the sense of their low-order bits being used to store which constructor was selected once the expression they point to has been evaluated)
08:47:54 <hooplahoops> mauke: ok, thanks. Do (boxed) values in general carry tags (e.g. for garbage collection purposes)
08:47:55 <hooplahoops> Cale: I see, thank you
08:47:55 <hooplahoops> mm_freak_: yeah, that's right
08:48:26 <hooplahoops> This is about both polymorphic code and variants
08:48:32 <mm_freak_> hooplahoops: for differentiation between constructors (Nothing and Just) things are a lot more complicated…  GHC employs lots and lots of optimizations there, but generally it's safe to assume that there are tags, unless statically known
08:48:54 <Cale> hooplahoops: But when the code for the expression is entered, it returns a pointer on the stack to the info table for the constructor
08:49:13 <mm_freak_> the precise realization may not actually use a tag…  it can use a functional representation using continuations, for example
08:49:45 <Cale> mm_freak_: Does it actually do that now?
08:50:08 <mm_freak_> Cale: i'm not sure, but it's both in SPJ's book and IIRC also in the STG paper
08:50:35 <Cale> Okay, well, for the longest time, GHC didn't do anything of the sort. My knowledge of this is perhaps a couple years out of date
08:51:02 <Cale> But hand-converting things to continuation passing style could produce performance benefits for a long time
08:51:20 <mm_freak_> Cale: i noticed that the benefit isn't as huge as it used to be
08:51:23 <Cale> If GHC can actually eliminate constructors entirely in cases where it matters, I'd be somewhat surprised
08:51:48 <hooplahoops> Cale: I see, so it tracks the info table in the thunks, is that right?
08:51:49 <hooplahoops> And when it then applies some constructor, does it remember the info table as part of the data?
08:52:36 <Cale> Anyway, the simpler model is just to assume that when you have a constructor applied to some arguments on the heap, that it's an integer value together with some pointers to code for the arguments of the constructor
08:52:48 <mm_freak_> Cale: i suppose only examining the source code would shed light onto that
08:53:46 <mello__> mm_freak_, im still stuck. Actual type of the funciton is :: MonadSnap m =>
08:53:46 <mello__>      Data.ByteString.Internal.ByteString
08:53:46 <mello__>      -> m (Maybe Data.ByteString.Internal.ByteString)
08:53:50 <mm_freak_> anyway, i would really be interested how it would affect performance, if the compiler just CPS-transforms by default
08:53:57 <hooplahoops> Cale: makes sense
08:54:02 <Cale> Yesterday, I made a program run a whole heck of a lot faster for someone here by reducing the number of allocations it did by unboxing some Word32 values, and avoiding applying the constructors until later.
08:54:12 <hooplahoops> Thanks to both of you, I should probably read the STG paper to understand it somewhat better still
08:54:16 <scriptdevil> Hi, I was reading about rpar and rseq. If it only evaluates to WHNF, aren't you building up huge thunks that finally would get evaluated sequentially?
08:54:32 <mello__> mm_freak_,  there is a function called liftSnap, which has :: Snap a -> m a
08:55:17 <mm_freak_> Cale, hooplahoops: you might find this interesting:  http://stackoverflow.com/questions/14471737/performance-improvement-in-unsigned-integers-function/14472035#14472035
08:55:54 <Cale> hooplahoops: A variable binding the expression which evaluated to that constructor will be a pointer to some code which when run will put a pointer to the already-evaluated tag and parameters onto the stack
08:55:56 <mm_freak_> the CPS-transformed variant used to provide a huge performance boost, but since 7.8 the difference has become a lot smaller
08:56:10 <mm_freak_> mello__: what do you want to do?
08:56:20 <Cale> Oh, if you're talking about 7.8, then I *really* don't know :)
08:56:30 <mm_freak_> oh
08:56:33 <mm_freak_> sorry, 7.6
08:57:02 <mm_freak_> i guess i'm mentally preparing for the love that 7.8 will get from me =)
08:57:22 <mm_freak_> IIRC when i wrote the article i was on 7.4
08:57:30 <mello__> mm_freak_, so the value is m (Maybe ByteString), where m => MonadSnap, and I want to manipulate the value inside the Maybe, so in a sense i need to fmap fmap it, but i don't know how to because the type is MonadSnap
08:57:39 <Cale> anyway, it was exactly this sort of code which I made do 4x less allocation by avoiding constructor applications :)
08:58:00 <mm_freak_> mello__: if you want to apply the function f to the bytestring, you would do this:  liftM (fmap f)
08:58:22 <mm_freak_> let f :: A -> B
08:58:28 <mm_freak_> then fmap f :: Maybe A -> Maybe B
08:58:39 <mm_freak_> and liftM (fmap f) :: m (Maybe A) -> m (Maybe B)
08:58:47 <Cale> Though admittedly, I was going through really low-level pain to do that, since it was W32# constructors which were the problem.
08:59:04 <mello__> mm_freak_, ok thanks I got it now
08:59:07 <mm_freak_> Cale: honestly i've never touched primitives
08:59:39 <c_wraith> Cale: huh.  *usually* GHC is pretty good about converting loops to work on primitives.
09:00:23 <Cale> c_wraith: Yeah, it did do a surprising amount of work to get rid of them, but not everything.
09:01:00 <mm_freak_> Cale: i've never hit a case when it became necessary to deal with primitives, especially not when computing with fixed size integers
09:01:59 <Cale> Yeah, this guy was apparently operating on something on the order of 100MB of Word32 values, and multiplying that by 4 was taking a lot of allocation time.
09:02:26 <Cale> (It was code to compute some hash function)
09:02:36 <danilo2> Philonous: I lost my internet connection, sorry - you are right - there is wrong type! :) thank you :)
09:03:48 <lpsmith> if you cabal install something,  is there a convenient way to specify flags for one of its dependencies
09:03:49 <lpsmith> ?
09:04:00 <Cale> I just ripped out the core that GHC was generating and pasted it back into the source, but avoiding some constructors and making one thing work on unboxed types instead, and I got the main part of the hash to compile to something which operated entirely in registers.
09:04:14 <lpsmith> or are you pretty much left with cabal installing the dependency (with the appropriate flags) and then cabal installing the rest?
09:04:24 <Cale> Apparently it was faster than some C hashes :)
09:04:35 <mm_freak_> nice =)
09:04:43 <dcoutts> lpsmith: --flags actually works for deps too, though it probably should not.
09:06:36 <lpsmith> dcoutts, so cabal install --flags compiles all dependencies with the same flags set?
09:06:58 <dcoutts> lpsmith: yes
09:08:23 <lpsmith> dcoutts, am I correct in assuming that Setup.hs magic like this:  https://github.com/lpsmith/bytestring-builder/blob/master/Setup.hs   won't affect the flags of other packages being installed in the same cabal execution?
09:08:42 <dcoutts> lpsmith: nothing in the Setup can affect other packages
09:08:47 <lpsmith> ok, thanks
09:08:49 <mello__> thanks mm_freak_
09:08:53 <dcoutts> lpsmith: well, not what flags are passed to them
09:09:18 <lpsmith> of course,  after all you are still running on top of a very effect-ful OS =)
09:09:28 <Cale> I recall there was some project to let you interactively optimise your code at the level of Core -> Core transformations, and then store the things you did in some way so they could be used in future compilations.
09:10:05 <Cale> I saw a talk about it at some point on the interwebs
09:10:19 <lpsmith> Cale,  I remember that too,  wasn't Andy Gill (or his group?) involved?
09:10:40 <Cale> http://www.ittc.ku.edu/csdl/fpg/files/Farmer-12-HERMITinMachine.pdf
09:10:43 <Cale> seems like it
09:11:23 <scriptdevil> When I use rpar foo, is the value of foo still going to be computed in a separate thread when it is needed, or is the thread going to join back once WHNF evaluation happens?
09:13:09 <Cale> n-dolio: did we just witness the application of a quantifier?
09:14:15 <Cale> or did you pass to a specific fibre?
09:14:38 <n-dolio> The world may never know.
09:15:32 <ble> Is there a name for something like a parser that, in addition to accepting certain languages, can also enumerate what symbol or symbols it would accept next?
09:15:40 <alpounet> HERMIT looks quite awesome
09:17:13 <Cale> ble: I don't know if there's a name for that, but Parsec kind of does this, though specifically for the case that there's a parse failure.
09:22:35 <ble> Cale: you're saying I can enumerate all the tokens that would cause the parser to fail?
09:23:01 <ble> if my tokens are Bounded and Enum I guess this is trivially true, but not precisely what I had in mind
09:23:25 <Cale> ble: No, it knows what things would allow it to go on, in the case that it fails, and will display them for you. I don't know whether there's a way to access that directly though.
09:23:56 <Cale> (i.e. what it was expecting in place of what it found)
09:24:01 <ble> okay, so somewhere in the guts it's available
09:24:02 <ble> thanks!
09:24:11 <Cale> You can tag your parsers with <?> to name them
09:24:28 <Cale> and those names will be used instead of individual tokens
09:25:33 <mello__> How do you deal with multiple Maybe a values without resorting to case of? You can pattern match of course, but is there anything else?
09:26:14 <joelteon> :t catMaybes
09:26:14 <lambdabot> [Maybe a] -> [a]
09:26:39 <companion_cube> :t sequence
09:26:40 <lambdabot> Monad m => [m a] -> m [a]
09:27:10 <mello__> thanks guys
09:28:04 <companion_cube> > maybe [] (map (+1)) $ sequence [Just 1, Just 2]
09:28:05 <lambdabot>  [2,3]
09:28:12 <companion_cube> maybe [] (map (+1)) $ sequence [Just 1, Just 2, Nothing]
09:28:17 <companion_cube> > maybe [] (map (+1)) $ sequence [Just 1, Just 2, Nothing]
09:28:18 <lambdabot>  []
09:29:56 <mm_freak_> mello__: in haskell whenever you say "multiple A" you really say "F A"
09:30:02 <mm_freak_> where F is another functor =)
09:30:14 <mm_freak_> "multiple Maybe X" = F (Maybe X)
09:30:57 <mm_freak_> so at the very least you can use fmap (fmap f) again
09:30:59 <enthropy> can djinn (as a command line tool) figure out how to compose two provided functions?
09:31:33 <mm_freak_> @djinn (b -> c) -> (a -> b) -> a -> c
09:31:34 <lambdabot> f a b c = a (b c)
09:32:10 <enthropy> http://lpaste.net/98249
09:32:14 <enthropy> yes it can there
09:33:12 <mm_freak_> enthropy: i think A needs to have constructors
09:33:25 <enthropy> if I give it constructors, then the generated function will use them
09:33:48 * enthropy guesses the environment in djinn isn't interpreted the right way
09:33:51 <mm_freak_> enthropy: well, if you want to assume no information about the types, you should make them polymorphic
09:34:23 <mm_freak_> in any case the answer seems wrong
09:34:33 <mm_freak_> so you may want to file a bug report
09:34:52 <enthropy> it's right in one interpretation
09:35:07 <enthropy> that data without constructors is just undefined, so it doesn't matter which one you give
09:36:18 <mm_freak_> enthropy: well, IMO an ill-typed result is never right =)
09:36:23 <enthropy> the idea would be to use djinn to make expressions when hoogle can't find something
09:36:44 <enthropy> say you have  openFile :: FilePath -> IO Handle; hGetLine :: Handle -> IO String
09:36:46 <mm_freak_> unless you assume type equality up to isomorphism, but i'm very sure that's not what djinn does
09:37:15 <enthropy> it should be possible to make a  :: FilePath -> IO String
09:37:25 <ALOper478510> [ U y a r  ] : enthropy  : Ltfen Seviyeyi Drmeyiniz Aksi Taktirde Kanaldan Uzaklatrlcaksnz !.iyi sohbetler dilerim...
09:38:46 * hackagebot type-natural 0.0.5.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.0.5.0 (HiromiIshii)
09:39:05 <mm_freak_> enthropy: certainly, but you should keep in mind that djinn generally uses the first solution it can come up with…  in particular it won't tell you when there are other possible results
09:39:18 <enthropy> no I :set +m
09:39:28 <mm_freak_> enthropy: in any case, there is always a quantified solution
09:39:30 <enthropy> it enumerates all the solutions (up to 200 by default)
09:40:44 <mm_freak_> @djinn (fp -> io h) -> (h -> io str) -> (forall a b. io a -> (a -> io b) -> io b) -> fp -> io str
09:40:44 <lambdabot> -- f cannot be realized.
09:40:48 <mm_freak_> what?
09:40:59 <startling> Are there always an enumerable number of solutions?
09:41:04 <startling> I guess so.
09:41:13 <mm_freak_> @djinn (forall a. a -> a) -> b -> b
09:41:14 <lambdabot> f _ a = a
09:41:15 <enthropy> if 0 solutions is "enumerable"
09:41:35 <startling> enthropy: I think it is.
09:41:36 <scriptdevil> (repeat) When I use rpar foo, is the value of foo still going to be computed in a separate thread when it is needed, or is the thread going to join back once WHNF evaluation happens?
09:41:55 <enthropy> @djinn (fp -> io h) -> (h -> io str) -> (io x -> (x -> io y) -> io y) -> fp -> io str
09:41:55 <mm_freak_> @djinn (forall a. a -> b) -> c -> b
09:41:55 <lambdabot> -- f cannot be realized.
09:41:55 <lambdabot> -- f cannot be realized.
09:42:13 <mm_freak_> djinn seems to have problems with higher rank types
09:42:49 <startling> Does anyone have emacs working with cabal sandboxes?
09:45:51 <c_wraith> startling: just don't install anything haskell-specific, and it doesn't work any differently at all!
09:46:46 <startling> c_wraith: :/ :\
09:47:05 <startling> specifically I want inf-haskell-mode to detect and use the sandbox if it exists.
10:06:13 <klrr> i get "ghcapi.hs:3:8:\nCould not find module `GHC'\nIt is a member of the hidden package `ghc-7.6.2'.\n" when i run my file with runhaskell, anyway to explicitly making it visible? (GHC packaeg is installed ive chechked with ghc-pkg)
10:07:28 <klrr> nvm found out
10:14:59 <mello__> how do I "escape" out of a monad?
10:15:01 <mello__> Expected type: Maybe AuthUser
10:15:01 <mello__>       Actual type: Handler App App (Maybe AuthUser)
10:15:07 <mauke> you don't
10:15:15 <mauke> the concept makes no sense
10:15:37 <mello__> mauke, that's what I thought, but how do I get the correct type then
10:15:53 <mauke> your question is wrong
10:16:10 <mauke> because a possible answer is "Nothing"
10:17:25 <levi> startling: I have some haskell emacs stuff working with cabal sandboxes, but it's kind of fragile right now.
10:18:04 <bennofs> if I have data A = A | B | C, why is the unpack pragma unusable in data D = D {-# UNPACK #-} !A
10:18:47 <enthropy> because data A isn't a primitive thing
10:18:50 * hackagebot MiniAgda 0.2014.1.9 - A toy dependently typed programming language with type-based termination.  http://hackage.haskell.org/package/MiniAgda-0.2014.1.9 (AndreasAbel)
10:19:21 <levi> mello__: You usually 'lift' functions into monads rather than taking values out.
10:20:32 <noteventime> levi: fmap?
10:20:45 <noteventime> err
10:20:46 <noteventime> sorry
10:21:28 <noteventime> Just keeping an eye on the channel, so I misread :)
10:21:46 <ReinH> mauke: well that depends on the monad. It's pretty easy to "escape" from Identity.
10:22:22 <ReinH> But that's not because it's a monad
10:23:45 <ReinH> mello__: monads, generally speaking, do not "contain values". There's isn't a generic way to "get a value out of a monad".
10:24:18 <scriptdevil> mello__: If you are certain you aren't getting Nothing, Data.Maybe.fromJust, but try lifting first
10:24:48 <ReinH> fromJust shouldn't be the first thing we recommend to people who want to work with a Maybe value
10:24:54 <mm_freak_> fromJust does not exist
10:25:11 <scriptdevil> ReinH: I apologize.
10:25:12 <FreeLy> This is a Web Based radio started from 1st June 2012, we are a bunch of friends working together with a slogan 7 Sur Rishton kay.... it means to unit the bond of relation ship through music. As the music has 7 basic notes same is the relations it also has the 7 essential notes or behaviour which one should have to understand to make a stronger bond
10:25:13 <FreeLy>  thats why we call 7 sur rishton kay..
10:25:13 <FreeLy> In this site you can listen to the Radio, You can chat with people, also you can order Domain or Hosting for your site. we have all in one Place.
10:25:14 <FreeLy> http://7surhitfm.com/flash.html
10:25:39 <scriptdevil> wtf just happened?
10:25:54 <ReinH> spam just happened
10:26:02 <mm_freak_> scriptdevil: nothing happened
10:26:12 <ReinH> Spam does not exist. Right.
10:26:17 <mm_freak_> =)
10:26:20 <scriptdevil> mm_freak_: Punning with the Maybe monad still, right?
10:26:42 <mm_freak_> it was just a peak in the IRC background noise =)
10:27:23 <Hodapp> 7 basic notes?
10:27:32 <Hodapp> what in the name of numerological drivel is this?
10:27:47 <Maior> ABCDEFG
10:27:49 <mm_freak_> anyway, i'd like to point out that "how do i get a value out of a monad?" is a type error
10:28:04 <mauke> kind error?
10:28:12 <mm_freak_> type/kind error
10:28:27 <Chousuke> which sort of is a kind of a type error
10:28:39 <mm_freak_> well, you will get a kind error
10:28:49 <mm_freak_> :k Maybe -> Integer
10:28:49 <lambdabot>     Expecting one more argument to `Maybe'
10:28:50 <lambdabot>     In a type in a GHCi command: Maybe -> Integer
10:28:55 <Hodapp> Maior: That's more of a notational thing than some fundamental nature...
10:29:12 <scriptdevil> :k Maybe Int- -> Int
10:29:13 <lambdabot> parse error on input `-'
10:29:27 <scriptdevil> err. My bad.
10:29:30 <scriptdevil> :k Maybe Int -> Int
10:29:31 <lambdabot> *
10:29:44 <mm_freak_> scriptdevil: sure, but that's not what the question asks for =)
10:29:54 <noteventime> Does something strange happen if you have an left inverse of return?
10:30:11 <Maior> Hodapp: that's about all I know about music, so, if you say so!
10:31:52 <ReinH> mm_freak_: if "a monad" means a concrete monad than Monad is not "a monad" :p
10:32:08 <ReinH> *then
10:32:14 <bennofs> What data structure could I use in haskell when I want to delete from the end and insert at the beginning?
10:32:23 <ReinH> mm_freak_: oh wait I am dumb
10:32:26 <ReinH> need coffee I guess
10:32:44 <bennofs> (There will always be the same number of elements in the container)
10:32:44 <mauke> bennofs: Seq, maybe
10:32:53 <mauke> might be overkill
10:33:14 <mm_freak_> i'd use Seq
10:33:24 <bennofs> yeah, I always forget about Seq. thanks!
10:34:43 <bennofs> Are mutable IO vectors thread-safe?
10:35:01 <bennofs> (When I only modify the data inside the vector)
10:35:02 <mm_freak_> bennofs: in what sense?
10:36:11 <mm_freak_> IO vectors are not transactional, and it's generally a good idea to wrap reads and writes in critical sections
10:36:43 <mm_freak_> but most likely a better option is to avoid using a mutable vector from multiple threads
10:37:16 <bennofs> hmm ok
10:37:38 <bennofs> When can V.U.modify avoid copying?
10:38:12 <mm_freak_> bennofs: potentially when it's used in a composition
10:38:25 <theOtherCat> hello there
10:39:28 <Jeanne-Kamikaze> yo
10:39:30 <theOtherCat> i want to compile a program which should take [Int] as parameter, but getArgs just takes Strings. is there an easy way to do this?
10:39:48 <pqmodn> > read "100" :: Int
10:39:49 <lambdabot>  100
10:40:12 <c_wraith> bennofs: whenever ghc can assemble your use of the vector in a pipeline
10:40:49 <c_wraith> bennofs: most of the vector ops are implemented as something like fromStream . streamVersion . toStream
10:40:51 <mm_freak_> theOtherCat: fmap (map read) getArgs
10:41:15 <c_wraith> bennofs: and there's a rewrite rule to change (toStream . fromStream) to id
10:41:28 <mm_freak_> theOtherCat: but note that 'read' is not a total function…  it will crash your program with an exception when invalid input is received
10:41:42 <theOtherCat> wow cool, thanks!
10:42:26 <c_wraith> bennofs: so if you write your vector operations such that after inlining and simplification it has adjacent toStream and fromStream operations, it will remove the copying for that case.
10:42:31 <mm_freak_> theOtherCat: the proper solution of course is to use a command line handling library like optparse-applicative, but it may be overkill for your situation =)
10:42:31 <theOtherCat> no problem in this particular case with invalid input
10:42:57 <bennofs> c_wraith: Ah, thanks. I thought it somehow did some magic I didn't yet knew of to detect if the old vector won't ever be used again
10:45:35 <mm_freak_> theOtherCat: i'd prefer to talk here =)
10:45:54 <theOtherCat> compiles fine, but when i call ./app [1,2,3] this leads to: Prelude.read: no parse
10:45:58 <mm_freak_> theOtherCat: if you actually want the list parser, you can do this:  fmap (read . unwords) getArgs
10:46:11 <pqmodn> try ./app 1 2 3
10:46:11 <scriptdevil> cabal install threadscope; just failed with a lot of Ambiguous reference errors. Is there something I am doing wrong or is threadscope not building for others too?
10:46:41 <c_wraith> scriptdevil: I had that happen yesterday.  it's reported on the threadscope trac, but no comments about it have been made there
10:47:01 <c_wraith> scriptdevil: I got it to compile by adding hiding (Region, width, height) to imports in 3 files
10:47:12 <c_wraith> scriptdevil: hide the Cairo versions of those
10:47:26 <monochrom> a unix shell is also likely to clobber "[1,2,3]"
10:48:06 <scriptdevil> c_wraith: Is it an issue with threadscope 0.2.1 too?
10:48:28 <c_wraith> scriptdevil: I think the problem is that Cairo added some exports
10:48:33 <scriptdevil> c_wraith: I will try that as a last-resort. Generally, I dislike modifying package-manager managed sources.
10:48:36 <scriptdevil> Ok
10:48:43 <theOtherCat> thanks mm_freak_ and pqmodn, both solutions work for me
10:49:13 <scriptdevil> c_wraith: I will do that.
10:50:01 <mm_freak_> theOtherCat: i recommend using the first solution
10:50:01 <c_wraith> scriptdevil: http://trac.haskell.org/ThreadScope/ticket/32 is the relevant trac ticket I found
10:50:31 <scriptdevil> c_wraith: Thanks.
10:50:38 <theOtherCat> @mm_freak_ will do that since then i don't have to wrap some sed/awk inbetween ;)
10:50:38 <lambdabot> Unknown command, try @list
10:50:58 <mm_freak_> =)
10:51:14 <theOtherCat> ok, you have a good day, cu around
10:51:58 <mm_freak_> have fun
10:55:17 <Twey> What's a good reference for understanding some of the knottier details of FRP?  I'm particularly interested in implementation and the semantics of dynamic switching
11:02:00 <jfischoff> preflex seen basvandijk
11:02:01 <preflex>  basvandijk was last seen on #haskell 99 days, 10 hours, 45 minutes and 14 seconds ago, saying: johnw: Ah yes of course
11:02:45 <jfischoff> @tell basvandijk what is current opinion of the finally tagless Aeson approach?
11:02:45 <lambdabot> Consider it noted.
11:04:41 <mm_freak_> Twey: feel free to ask
11:05:38 <mm_freak_> semantically dynamic switching is just something like this:  Behavior a -> Event (Behavior a) -> Behavior a
11:05:54 <mm_freak_> or this:  Event (Event a) -> Event a
11:06:42 <mm_freak_> the implementation can be anything from trivial (AFRP) to very complicated
11:09:33 <dottedmag> I'm unable to install GLFW using cabal on OS X. Looks like Darwin as does not like assembler files produced by gcc: http://lpaste.net/98250
11:10:20 <dottedmag> GLFW.cabal explicitly says to use gcc on OS X: if os(darwin)
11:10:25 <dottedmag>   x-cc-name: gcc
11:11:15 <dottedmag> Does anyone have any pointers to go from here? Darwin as seems to be _the_ linker on OS X.
11:11:25 <dottedmag> s/linker/assembler
11:13:31 <prophile> this isn't strictly haskell, but what do free rings look like?
11:13:45 <jfischoff> polynomials
11:13:54 <jfischoff> free communative rings
11:14:19 <danharaj> it probably depends on which forgetful functor you are looking at.
11:25:50 <kakos> Which is more common: hsc2hs or c2hs?
11:25:59 <kakos> Which is better?
11:26:07 <johnw_> and don't forget c2hsc :)
11:26:24 <kakos> I'm not sure if you're joking or not......
11:26:27 <johnw_> c2hsc is more of a generator of hsc bindings
11:26:44 <noteventime> kakos: Depends on what you're doing, I think
11:26:46 <johnw_> hsc2hs and c2hs give you another syntax to write bindings in
11:27:03 <noteventime> http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/
11:27:43 <kakos> Well, I'm just writing some FFI bindings to interface some haskell code with a PAM module and I started in on c2hs, but I"m not necessarily attached and would prefer to learn the one that the community seems to be the most fond of
11:28:23 <johnw_> kakos: I most prefer hsc with the Bindings-DSL library
11:29:34 <Philonous> Writing a good interface is a lot of manual labor anyway.
11:29:42 <enthropy> johnw_: did you consider generating ffi bindings from dwarf info?
11:29:52 <johnw_> enthropy: no, I surely did not
11:44:52 <zett_zelett> Can someone give me an example of a useful and successful application of `fix`?
11:45:27 <alpounet> > fix (1:)
11:45:28 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
11:45:44 <zett_zelett> Thanks.
11:45:49 <alpounet> maybe not super useful
11:46:00 <alpounet> but that's the basis of many usages of fix
11:46:06 <zett_zelett> It’s okay, that does it for me.
11:46:23 <alpounet> it applies something forever but the "client code" will only consume a part of it
11:46:35 <bennofs> > fix $ \a -> 1 : map (*2) a
11:46:36 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:53:17 <ion> > iterate (*2) 1
11:53:18 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:54:02 <johnw> @pl \a -> 1 : map (*2) a
11:54:02 <lambdabot> (1 :) . map (2 *)
11:54:14 <aleksejs_> I stuck at Problem 18 @project euler, maybe someone could give a hint?
11:55:20 <ion> zett_zelett: Whenever you see “let x = foo x bar in x” you can write it as “fix (\x -> foo x bar)” and potentially also make it pointless wrt. the “x”. Both steps are likely to make the code less readable. :-P
11:56:45 <ion> zett_zelett: And of course the inverse applies.
12:02:24 <MagneticDuck> any idea what kind of power I should be able to expect out of the cool package "graphics-drawingcombinators">
12:02:26 <MagneticDuck> ?*
12:02:26 <lambdabot> Maybe you meant: v @ ? .
12:02:40 <MagneticDuck> reccomendable for making any sort of games?
12:02:51 <kakos> Okay, how do I return a Ptr data thingie from a function?
12:02:56 <MagneticDuck> I'm just trying out different graphics libraries
12:03:03 <zett_zelett> We got this kind of Tree-structure: data Tree a =  Leaf a | Branch a (Tree a) (Tree a) – 1. It is not possible to have a Tree with an even number of nodes, is it?
12:03:45 <zett_zelett> 2. How can I define a useful insert-function for (Ord a) => Tree a?
12:04:33 <zett_zelett> (i.e. insert :: Ord a => a -> Tree a -> Tree a)
12:06:18 <oldFash_07> Hi guys, I am wandering if anyone has ever worked with the tree navigation api of Hexpat (XML Parser) library. I am trying it with simple cases and I'm getting confusing exceptions
12:07:23 <MagneticDuck> the useful people aren't active atm it seems ^^
12:07:54 <jrmithdobbs> I'm a little confused re: attoparsec ... how do you construct a Parser such that it will actually terminate on end of input instead of creating a Partial without using parseOnly or am I missing something?
12:09:34 <S11001001> zett_zelett: there's an example of #2 early in okasaki
12:09:36 <pqmodn> jrmithdobbs: there's an endOfInput combinator
12:09:57 <jrmithdobbs> pqmodn: I see that but can't seem to figure out how to use it correctly
12:11:09 <pqmodn> jrmithdobbs: it's not fresh in my mind anymore, but have you tried something like example = "abc" .*> endOfInput ?
12:12:00 <jrmithdobbs> pqmodn: myparser = many1 baseParse :: Parser T.Text where baseParse = do { y <- atEnd ; if y then return "" else do { n <- peekChar ; case n of <few alternatives here that all end at Parser T.Text's> ; }
12:12:16 <jrmithdobbs> pqmodn: is my most recent attempt
12:12:50 <jrmithdobbs> pqmodn: i don't have a well defined terminating point, it's literally "when input stops you're done unless there's already been a parse error"
12:13:43 <jrmithdobbs> pqmodn: I thought the return ""; (i'm using Data.Attoparsec.Text but don't think that matters) would trigger a Done Result =/
12:13:43 <pqmodn> i'm not sure but i don't see how that terminates. i think because you're using many1, when you finally hit EOF you'll have [..., "", "", "", "", "" etc
12:14:16 <jrmithdobbs> pqmodn: yes but it acts as expected using same parser with parseOnly
12:14:31 <jrmithdobbs> pqmodn: other than shoving it into an Either I don't want
12:15:39 <pqmodn> have you tried something like myparser = many1 (do { alt <|> alt <|> alt}) <|> return ""
12:15:52 <pqmodn> sorry, you don't need the do { .. } notation in that example
12:16:12 <MitchellSalad> hi all, is there anything like this on hackage? http://lpaste.net/98251
12:16:27 <jrmithdobbs> pqmodn: alt <|> alt <|> alt ... contains a takeWhile so that won't work
12:16:42 <jrmithdobbs> pqmodn: at the end
12:17:42 <pqmodn> jrmithdobbs: i see. the best i can offer is moving the EOF test to the very outside. in fact i bet parseOnly p is something like liftA2 const p endOfInput
12:18:17 <quchen> MitchellSalad: There was some talk about Coercible last fall, but what you want to do seems more like a conversion function.
12:18:21 <jrmithdobbs> pqmodn: it kind of is (it's actually: not <$> wantInput; but wantInput isn't exported)
12:18:35 <platzhirsch1> When you need to find the closest pair to zero in a sorted list then from a procedural point of view you would use two pointers left and right and increment left, when the sum is smaller than 0 and decrement right if the sum is bigger than 0 (to minimize towards) zero. (e.i. closest [-6, -3, -1, 0, 3, 4, 5] => 0 for -3 and 3). But how would I solve this in a functional way? I don't see how map or list comprehension helps here
12:20:16 <jrmithdobbs> actually now i'm really confused, i even added a Nothing -> fail "danger will robinson"; to try and capture the eos there ... hrm
12:22:08 <quchen> platzhirsch1: Are you looking for a solution out of interest or do you just need to solve the problem?
12:22:37 <quchen> platzhirsch1: You could always fall back to using ST, that's why I'm asking. (Your input should probably be a Vector and not a list anyway.)
12:23:08 <platzhirsch1> quchen: Curiosity, I have solved it in Python and find it awfully boring so I wondered how to make this more interesting, for instance in Haskell
12:23:48 <quchen> You can't really iterate (singly linked) lists in reverse, that's the problem. You can reverse them in some way before of course.
12:26:17 <platzhirsch1> Maybe the problem is inherently procedural, I don't know
12:26:27 <S11001001> platzhirsch1: listwise, you could drop all (< 0), reverse, then operate over original & result list recursively
12:27:01 <S11001001> platzhirsch1: namely: recursion subsumes iteration.
12:27:03 <quchen> S11001001: The problem works for positive lists as well, you don't have to sum to 0, just get as close as possible to it
12:27:55 <S11001001> quchen: ah; skipping the drop then
12:28:41 <quchen> This looks like one of those problems that are naively O(n^2), easily optimized to O(n log(n)), and then there is a magic O(n) solution.
12:28:59 <ReinH> quchen: seems like a list zipper would be useful?
12:29:29 <quchen> ReinH: Maybe, I'm a bit worried about skipping valid candidates with that though
12:29:42 <quchen> ReinH: i.e. you discard a number that will later turn out to be part of the solution
12:29:49 <ReinH> quchen: maybe I'm misunderstanding the problem
12:29:53 <platzhirsch1> quchen: Pretty much, except that will all likelihood there is no O(n) solution
12:30:21 <pqmodn> do i understand the problems: find the two elements in a given list whose sum is closest to zero?
12:30:43 <quchen> ReinH: min [ abs (x + y) | x <- xs, y <- xs ]
12:30:49 <quchen> Something like that would be the naive solution
12:30:53 <ReinH> quchen: oh right
12:30:53 <mauke> pqmodn: I think the list is sorted
12:30:54 <quchen> xs is ordered
12:31:15 <pqmodn> oh, okay. and we're computing the minimum sum or finding the two elements?
12:31:21 <quchen> Sum.
12:31:29 <ReinH> I thought we were finding the pair
12:31:36 <ReinH> "find the closest pair"
12:31:39 <platzhirsch1> no the sum, sorry
12:31:42 <ReinH> ok
12:31:51 <platzhirsch1> pair would be maybe more interesting in terms of Haskell
12:31:54 <ReinH> So we want to do asymptotically better than your naive solution
12:32:27 <ReinH> Why isn't there an O(n) solution?
12:32:37 <platzhirsch1> ReinH: Because I believe the sorting is required
12:32:55 <ReinH> But you said the list is sorted
12:33:03 <quchen> ReinH: We don't know whether there is no O(n) solution I think.
12:33:22 <platzhirsch1> ReinH: To leave this out of the problem, but yeah you need to sort it before
12:33:33 <ReinH> Ok. O(n log n) then :p
12:33:34 <quchen> n * log(n) is easily achieved by binarily searching for the best partner.
12:33:36 <quchen> Yeah.
12:33:40 <mauke> > let foo xs'@(x : xs) ys@'(y : ys) = k : if k < 0 then foo xs ys' else foo xs' ys where k = x + y; foo _ _ = [] in ap foo reverse [-6, -3, -1, 0, 3, 4, 5]
12:33:40 <lambdabot>  <hint>:1:27: parse error on input `y'
12:34:08 <mauke> > let foo xs'@(x : xs) ys'@(y : ys) = k : if k < 0 then foo xs ys' else foo xs' ys where k = x + y; foo _ _ = [] in ap foo reverse [-6, -3, -1, 0, 3, 4, 5]
12:34:09 <lambdabot>  [-1]
12:34:10 <ReinH> O(n) seems achievable with a properly constructed structure
12:34:17 <ReinH> But how fast can you construct that structure?
12:34:30 <quchen> ReinH: The zipper version is probably O(n).
12:34:30 <ReinH> Split your list on 0 and reverse the first list. Both of these are O(n)
12:34:37 <joejev> so in a project I defined: tmap :: (a -> b,c -> d) -> (a,c) -> (b,d); is this equivelent to Control.Arrow.*** for tuples?
12:34:49 <ReinH> i.e. construct a zipper that privileges 0
12:34:53 <ReinH> then walk each side
12:34:59 <ReinH> it's foldable
12:35:09 <ReinH> should be O(n) all around
12:35:12 <ReinH> constructing the zipper is O(n)
12:35:14 <ReinH> walking it is O(n)
12:35:32 <ReinH> hmm
12:35:51 <ReinH> but is it sufficient to walk each list once or do you have to backtrack?
12:36:21 <quchen> :t uncurry ((***) `asAppliedTo` (undefined :: a -> b) `asAppliedTo` (undefined :: c -> d)) -- joejev
12:36:21 <lambdabot> (c -> d, b' -> c') -> (c, b') -> (d, c')
12:36:34 <quchen> Excuse the noise. I meant "yes"
12:36:40 <ReinH> No, you have to backtrack. Consider [-10, -5, 0, 1, 2, 3, 4, 6, 7, 8, 9, 10]
12:36:54 <quchen> ReinH: That's what I meant with "afraid of skipping" :-(
12:37:00 <ReinH> quchen: exactly
12:37:07 <joejev> quchen: what is the `asAppliedTo` function?
12:37:11 <ReinH> but you only have to rewind one of the lists
12:37:17 <quchen> asAppliedTo = const :: (a -> b) -> a -> (a -> b)
12:37:33 <quchen> :t id `asAppliedTo` (undefined :: Int)
12:37:34 <lambdabot> Int -> Int
12:37:35 <pqmodn> ReinH: i think i understand your point but why does that example require backtracking?
12:37:57 <ReinH> pqmodn: because the pair -10, 10 will never be visited otherwise
12:38:05 <joejev> quchen: what module is that from?
12:38:17 <quchen> joejev: I don't think it's in a module
12:38:22 <quchen> joejev: It's just for Lambdabot
12:38:29 <joejev> quchen: ah
12:38:31 <joejev> thank you
12:38:36 <quchen> (Mainly to use *** and not scare beginners) ;-)
12:39:10 <pqmodn> suppose i'm looking at -5 and walking through the positive list. i get to 4 and my sum is -1, then i move to the next positive number, my sum is +1, but now i know i won't get any closer to a pair for -5. so i could look at the next negative number -10 and 6, then -10 and 7, etc
12:39:12 <quchen> joejev: Actually you could define   asAppliedTo = undefined :: (a -> b) -> a -> (a -> b)
12:39:16 <MagneticDuck> @type ***
12:39:17 <lambdabot> parse error on input `***'
12:39:20 <quchen> :t (***)
12:39:21 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
12:39:21 <MagneticDuck> @type (***)
12:39:22 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
12:39:27 <MagneticDuck> ah yes arrows
12:39:30 <MagneticDuck> those.. things
12:39:33 <quchen> :t (***) `asAppliedTo` (undefined :: a -> b)
12:39:34 <lambdabot> (a -> b) -> (b' -> c') -> (a, b') -> (b, c')
12:39:35 <MagneticDuck> I.. know about them.. kind of
12:39:58 <MagneticDuck> ..huh
12:40:08 <quchen> ReinH: There *has* to be some O(n) solution. There is always one.
12:40:10 <MagneticDuck> @type (asAppliedTo)
12:40:11 <lambdabot> (a -> b) -> a -> a -> b
12:40:33 <ReinH> quchen: I find your argument compelling.
12:40:55 <quchen> ReinH: It's just a tad short of a formal proof.
12:41:00 <ReinH> pqmodn: but suppose you walk through the negative list instead
12:41:14 <ReinH> pqmodn: wait, no.
12:41:30 <ReinH> pqmodn: assume the list extends infinitely in both directions.
12:41:38 <pqmodn> okay, i'll grant you that
12:41:41 <platzhirsch1> I can't imagine, the point of looking at two numbers and walking the whole list...
12:41:50 <ReinH> Or at least far enough out to demonstrate the problem :)
12:42:28 <pqmodn> ... maybe i'll grant you that. i think it'll be easier if i propose a solution and someone can prove it wrong
12:42:34 <ReinH> pqmodn: seems good
12:42:43 <ReinH> Also this is the best nerd snipe I've seen in a few days
12:42:48 <quchen> :-)
12:42:48 <pqmodn> yeah
12:42:52 <ReinH> well played
12:43:06 <quchen> At least it's easily QuickCheck-able because the naive solution is trivial.
12:43:11 <ReinH> quchen: yay!
12:43:27 <ReinH> quchen: now we just have to beat O(N^2) :D
12:43:36 <pqmodn> i think infinite lists will be problematic, since finding the "0" won't even terminate?
12:43:45 <mauke> > let foo xs'@(x : xs) ys'@(y : ys) = k : if k < 0 then foo xs ys' else foo xs' ys where {k = x + y}; foo _ _ = [] in ap foo reverse [-6, -3, -1, 0, 3, 4, 5]
12:43:46 <lambdabot>  [-1,2,1,0,-3,-1,0,-1,2,0,-3,-2,-1]
12:43:47 <ReinH> pqmodn: dont' worry about infinite. Pretend I said "sufficiently finite"
12:43:51 <mauke> ah, there we go
12:44:03 <ReinH> well, "finite but sufficiently large"
12:44:04 <mauke> > let foo xs'@(x : xs) ys'@(y : ys) = (k, (x, y)) : if k < 0 then foo xs ys' else foo xs' ys where {k = x + y}; foo _ _ = [] in ap foo reverse [-6, -3, -1, 0, 3, 4, 5]
12:44:05 <lambdabot>  [(-1,(-6,5)),(2,(-3,5)),(1,(-3,4)),(0,(-3,3)),(-3,(-3,0)),(-1,(-1,0)),(0,(0,...
12:47:23 <ReinH> pqmodn: tempted to write a quickcheck for my assertion about the flaw in the O(n) solution
12:47:26 <ReinH> pqmodn: but whoops meeting time
12:48:06 <pqmodn> ReinH: i'll lurk but might have to get back to work-work before i finish
12:48:18 <ReinH> pqmodn: heh work-work
12:48:28 <ReinH> for me this now involves interminable meetings where nothing happens :/
12:48:39 <quchen> ReinH: Now you have something to do!
12:49:05 <quchen> Here's some toy QuickCheck code. http://codepad.org/CTMHLnaN
12:49:15 <quchen> Makes MonteCarlo-ing the solution easier.
12:49:35 <ReinH> quchen: well yes I know how to write that :p :p :p
12:49:54 <ReinH> quchen: am a bit concerned with the sample quality though
12:50:02 <quchen> I know how to make food, doesn't mean I don't enjoy an easy meal cooked for me
12:50:09 <ReinH> quchen: touche
12:50:25 <ReinH> I'm not sure arbitrary [Int] is going to have a useful distribution for this :/
12:50:39 <quchen> ReinH: Run it multiple times then :-)
12:50:47 <quchen> Oh maybe I should sort.
12:50:59 <ReinH> quchen: perhaps that would be a good start.
12:51:56 <quchen> I'm going to go with "log(n) is pretty constant" until your meeting is over
12:52:06 <ReinH> quchen: lol
12:53:41 <ReinH> log n should be good enough for anyone
12:54:11 <lightquake> log log log n
12:55:08 <pqmodn> argh, i'm forseeing an edge case for an input like [-1,-2]
12:55:40 <pqmodn> my incomplete solution is becoming less beautiful with every character i write
12:58:19 <ronbrz> hello #haskell! How are you today?
12:58:48 <MitchellSalad> ronbrz Good and yourself
12:59:29 <ronbrz> I'm doing well, just starting to learn haskell, its pretty fun :>
13:00:21 <quchen> pqmodn: I can't concentrate on anything now. Damn you
13:00:53 <pqmodn> neither can I, damn myself!
13:01:19 <pqmodn> an O(n) solution exists, i can feel it
13:01:27 <quchen> It always exists!
13:01:58 <platzhirsch1> If the resulting value would be known there is, but otherwise not
13:02:06 <platzhirsch1> like, pair which sums up to x
13:02:25 <Thooms> sorry, can someone explain me briefly what's exactly the problem ? I there's any chance I can help
13:02:50 <Thooms> (the pair with the maximum sum ?)
13:02:56 <pqmodn> Thooms: find the O(n) solution for min $ [ abs (x+y) | x <- xs, y <- xs ]
13:03:10 <pqmodn> for a sorted list xs
13:03:12 <Thooms> oh I see, thanks
13:03:23 <mauke> didn't I already do that?
13:03:26 <mauke> or was that algorithm wrong
13:03:44 <quchen> mauke: Your algorithm printed something that wasn't a number
13:03:51 <pqmodn> yeah, please don't fix it
13:03:57 <acomar> pqmodn: have you already tried the dynamic programming approach?
13:04:18 <platzhirsch1> something is good, it looked broken
13:04:23 <mauke> > let foo xs'@(x : xs) ys'@(y : ys) = k : if k < 0 then foo xs ys' else foo xs' ys where {k = x + y}; foo _ _ = [] in (minimum . map abs . ap foo reverse) [-6, -3, -1, 0, 3, 4, 5]
13:04:24 <lambdabot>  0
13:04:27 <pqmodn> no don't do it!
13:04:40 <pqmodn> argh, can't unsee
13:05:08 <dwcook> I'm bored, what's the latest neat language extension?
13:05:25 <pqmodn> strict
13:05:48 <pqmodn> manuel is working on LANGUAGE Strict in a branch of ghc
13:06:13 <mauke> copying perl yet again!
13:06:15 <quchen> mauke: QuickCheck says it's correct.
13:06:33 <dwcook> I'm having trouble finding that in a web search, got a link?
13:06:40 <pqmodn> dwcook: yep, one minute
13:08:36 <pqmodn> now i'm having trouble finding it. i saw it on google plus, still looking...
13:10:45 <pqmodn> damnit, this is old and it was johan tibell (not manuel). google+ somehow shows very old stories near the top. https://groups.google.com/forum/#!topic/haskell-cafe/J7KTTrzu43I
13:11:27 <ReinH> quchen: this meeting has not yet engaged my prefrontal cortex
13:11:44 <ReinH> but I have not given up hope yet
13:12:26 <pqmodn> dwcook: here's the branch fwiw https://github.com/tibbe/ghc/tree/strict
13:12:33 <quchen> ReinH: Mauke's solution seems to work out, 10 lines above
13:12:49 <dwcook> Is this supposed to be useful for writing strict versions of modules, like ByteString?
13:13:11 <mauke> quchen: to be honest, I simply copied platzhirsch1's algorithm
13:13:18 <mauke> I didn't come up with it myself
13:13:21 <ReinH> nice :)
13:13:29 <platzhirsch1> mauke: good, then I did understand it correctly
13:13:32 <ReinH> heh
13:13:33 <platzhirsch1> I was not sure :P
13:14:01 <platzhirsch1> I don't find it very appealing though, but I think the whole problem is just plain ugly
13:14:13 <pqmodn> dwcook: i think it was intended to flip the defaults, so ~ would denote a lazy pattern match and lack of ~ would denote a strict param
13:14:57 <pqmodn> dwcook: i don't know much about it. i assumed it was something recent and there would be more discussion but it looks kinda dead
13:15:07 <quchen> *** Failed! Falsifiable (after 139 tests):
13:15:08 <quchen> :-(
13:15:09 <geekosaur> buh? isn't ~ the lazy one?
13:15:25 <quchen> Hm, maybe it's an Int/Integer problem. Hold on.
13:15:27 <pqmodn> geekosaur: normally, but tibbe was working on {-# LANGUAGE Strict #-}
13:15:46 <pqmodn> geekosaur: sorry, i misunderstood your question, disregard me!
13:16:53 <pqmodn> geekosaur: i meant ~ would've been strict with LANGUAGE Strict and ! is implied
13:17:24 <geekosaur> yeh, that was what I was trying to ask
13:22:27 <MitchellSalad> Why does hackage sometimes return 404s for documentation?
13:22:31 <MitchellSalad> Is this the uploader's fault?
13:22:43 <MitchellSalad> like here: http://hackage.haskell.org/package/llvm-general-3.3.8.2
13:23:59 <joelteon> It's because the documentation hasn't been generated yet
13:24:17 <MitchellSalad> oh, so it was just uploaded then
13:24:18 <Clint> if that were true, those wouldn't be links
13:24:29 <MitchellSalad> oh, so it's a different problem then
13:24:50 <Clint> yes, i don't know why that's happening
13:25:20 <MitchellSalad> hm, and previous versions don't have hyperlinks. is that supposed to happen?
13:25:25 * LoRdToLsToI YouTube - Sting - Desert Rose original song
13:26:15 <Clint> MitchellSalad: that probably means it failed to build due to an external dependency not being on the build server
13:26:30 <MitchellSalad> ah, ok
13:27:00 <bennofs> Yeah, it's because llvm is not available on hackage: http://hackage.haskell.org/package/llvm-general-3.3.8.2/reports/1/log
13:27:13 <joelteon> oh that'll do it
13:33:34 <MitchellSalad> so i should just build the docs locally?
13:46:31 <jml> hdbc is still the thing to use for sql database stuff?
13:47:23 <Axman6> there's several choices these days. persistent looks quite nice, but possibly less powerful (less SQLy)
13:48:09 <Enigmagic> MitchellSalad: or follow the link on the top http://bscarlet.github.io/llvm-general/3.3.8.2/doc/html/llvm-general/index.html
13:48:39 <mello__> I want to apply two functions, let's say f and g, both to the same argument and then become a list of the results
13:49:49 <stelleg> mello__: [f x, g x]
13:50:18 <stelleg> or \x -> [f x, g x]
13:50:48 <mello__> lmao. thanks stelleg i was already thinking ten times harder
13:51:02 <mello__> i mean, like, a lot less simple than this solution :)
13:51:29 <stelleg> mello__: yeah there may be some fancy way to do it, and it does get addicting trying to look for those fancy ways :)
13:51:47 <mello__> i just came up with this one
13:51:56 <mello__> [f,g] >>= (\f-> [f x])
13:52:05 <mello__> but all it is is less readable
13:52:08 <jonasw> @pl \x -> [f x, g x]
13:52:08 <lambdabot> liftM2 (:) f (return . g)
13:52:18 <mello__> rofl
13:52:31 <mello__> what does that bot do, just exactly?
13:52:36 <stelleg> jonasw: whoa not familiar with @pl
13:52:49 <jonasw> Point-free refactoring
13:52:52 <dwcook> \x -> map ($ x) [f, g]
13:52:56 <jonasw> @pl \x -> x
13:52:56 <lambdabot> id
13:52:57 <mello__> that's awesome.
13:53:07 <jonasw> @pl \a b -> a
13:53:07 <lambdabot> const
13:53:10 <stelleg> dwcook: yeah I was thinking along those lines
13:53:34 <dwcook> That was just for kicks. I like \x -> [f x, g x] best
13:53:45 <scriptor> @pl \f g h -> f . g . h
13:53:45 <lambdabot> (. (.)) . (.) . (.)
13:53:52 <stelleg> oh god...
13:54:03 <scriptor> aaahhhh
13:54:04 <mello__> that looks more like boobies to me than haskell
13:54:05 <Maior> hahaha
13:54:07 <stelleg> its like total recall
13:54:08 <stelleg> almost
13:54:19 <Axman6> with a yo dawg boob
13:54:27 <stelleg> haha
13:54:47 <mello__> thank you guys btw, just saying
13:54:51 <mello__> appreciated
13:55:06 <adimit> :t (.)(.)
13:55:07 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
13:55:08 <stelleg> np
13:55:11 <adimit> :t (.).(.)
13:55:12 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
13:55:16 <adimit> I've actually used the latter.
13:55:18 <adimit> always fun.
13:55:24 <stelleg> yes I as well
13:55:47 <stelleg> like a new mother
13:55:51 <stelleg> useful boobies
13:56:04 <mello__> :t (.).(.(.(.)))
13:56:04 <lambdabot> (((b -> c2) -> c1) -> c) -> (a -> ((a1 -> b) -> a1 -> c2) -> c1) -> a -> c
13:56:11 <Maior> _anyway_
13:56:18 <adimit> it is pretty nifty to go through the exact unification steps to arrive at that signature.
13:56:28 <Twey> When using Gloss, can I run an action to make Gloss update the window when I want it to, rather than having Gloss poll?
13:56:43 <adimit> a good exercise to familiarize oneself with Haskell's type-level prolog.
14:09:02 <aleksejs_> trying to explain infinite list generating in haskell to "imperative" guy... please kill me
14:09:41 <cwvh> If said person has used Python generators in the past, you can use that as a start.
14:09:55 <erisco> class MyIterator { ... Int getValue() { return 1; } void next() { return; } ... }
14:10:21 <aleksejs_> this guy is from jav
14:10:25 <aleksejs_> java*
14:10:32 <Sorella> aleksejs_, given a strict language, it would be something like: `cons a, => cons b, => cons c, => ...` I.e.: all tails are wrapped in a thunk, so nothing gets evaluated until it's absolutely necessary
14:12:24 <jrmithdobbs> aleksejs_: w/e my imperitive language of choice does inf lists just fine ;p
14:15:04 <fizbin> jrmithdobbs: scala?
14:15:11 <jrmithdobbs> fizbin: ruby
14:15:38 <jrmithdobbs> (where said choice isn't affected by real world concerns like interpretter performance/impl details ;p)
14:15:59 <aleksejs_> I've tried ruby once
14:16:36 <aleksejs_> I hated @@var, @var and var expressions
14:17:18 <jrmithdobbs> well that's fine because 1/3 of those should practically never be used, and '@' is only used for writing your accessors/setters usually
14:17:29 <jrmithdobbs> so that's a weird thing to complain about ;p
14:17:47 <aleksejs_> if I remember right, @@var was class variable, @var was instance variable, and var vas local
14:18:24 <jrmithdobbs> yes, and class variables perform so badly you shouldn't use them (and in practice there's almost always a better way any how) and you should rarely access instance variable directly except through methods
14:18:40 <aleksejs_> jrmithdobbs, I'm not sure that class/instance variables should never be used in strictly oop language ;)
14:19:09 <jrmithdobbs> aleksejs_: in ruby class variables have a horrible performance overhead and if there's any way to avoid their use you should
14:19:36 <jrmithdobbs> aleksejs_: and in practice they're really not that useful except for a few fancy datastructure corner cases that you'll never implement that way either ;p
14:19:55 <aleksejs_> jrmithdobbs, so, what's the reason of oop, if I should not use class and instance variables?
14:19:57 <jrmithdobbs> aleksejs_: it's like class inheritence in ruby: just don't
14:20:45 <aleksejs_> anyway
14:21:03 <aleksejs_> after ruby I decided to switch to FP world
14:21:41 <aleksejs_> so, in some case, ruby helped me :)
14:21:45 <simpson> aleksejs_: Objects are about message-passing. Try something in Smalltalk or Self sometime.
14:21:49 <rtpg> I got yelled at on #ruby because I accidentally thought ruby was functional haha
14:22:08 <monochrom> heh
14:22:22 <aleksejs_> rtpg, JS guys think JS is pretty functional
14:22:29 <jrmithdobbs> rtpg: it has a bunch of functional pieces and functions are first order since they're objects
14:22:39 <jrmithdobbs> so it seems weird that that would anger them
14:22:48 <rtpg> I think JS is functional because it's easy to pass around functions
14:23:04 <rtpg>  but in ruby, the name of the function invokes it , so you have to do all that disgusting wrapping
14:23:22 <simpson> I think that JS is object-based because it looks like Self if somebody accidentally put it through a blender.
14:23:26 <jrmithdobbs> rtpg: not necessarily, that's what lambdas/Procs are for
14:23:33 <scriptor> there's gotta be a name for that primitive form of functions
14:23:35 <aleksejs_> both JS and ruby cannot be posisble functional, because functional is subclass of declarative
14:23:44 <scriptor> which essentially means it has functions-as-values and higher-order functions
14:23:50 <jrmithdobbs> rtpg: then you have to send :call to invoke execution
14:23:57 <scriptor> *form of functional
14:24:03 <aleksejs_> and both ruby and JS are imperative
14:24:15 <simpson> IYSS.
14:24:16 <rtpg> maybe I misworded it: I wanted to write Haskell-y code in ruby and it was painful
14:24:24 <Lethalman> how can functional be declarative? for me declarative is something like prolog
14:24:41 <Lethalman> I thought things were either declarative, or functional, or imperative
14:24:51 <aleksejs_> Lethalman, I can assure that functional is subclass of declarative
14:25:04 <aleksejs_> and haskell in most cases is declarative
14:25:30 <Lethalman> Aleksejs, in what way... you still write down the algorithm to solve the problem
14:25:40 <Lethalman> while declarative means you declare, and something else solves the problem for you
14:25:54 <aleksejs_> yes, that's how haskell works
14:25:55 <quchen> Paradigms flowchart time! http://i.imgur.com/9qG20WP.jpg
14:25:56 <Axman6> Lethalman: in haskell, you define what result you want, not how to compute it
14:25:59 <rtpg> Lethalman, in Haskell, with non-strict evaluation, you have a similar situation
14:26:10 <adimit> if functional were a subclass of declarative, then haskell should always be declarative, since Haskell is always functional. But that paradigm hogwash just keeps me from writing code.
14:26:23 <Axman6> since things are evaluted by need
14:26:27 <Axman6> a*
14:26:32 <scriptor> Lethalman: unification isn't the only way to implement a declarative language
14:26:52 <Twey> Lethalman: These are all very vague categories
14:27:01 <Twey> Haskell is declarative, and functional, and imperative ☺
14:27:09 <Axman6> > let f x y = (x+y, x*y) in f 7 345
14:27:10 <lambdabot>  (352,2415)
14:27:35 <Lethalman> if I would give a ranking, haskell is first functional, then imperative, then declarative at last
14:27:43 <Axman6> Lethalman: in that code, nowhere did it say compute x+y, and then compute x*y, it just said, the result will be a tuple with x+y and x*y
14:27:43 <aleksejs_> haskell has an option to put some piece of imperative, but it will be wrapped in IO/etc
14:27:45 <adimit> quchen: that's a pretty flowchart.
14:28:13 <aleksejs_> Lethalman, I guess you misunderstand the meaning of declarative
14:28:16 <Twey> Lethalman: Okay.  Your ranking has no informational content, though.
14:28:33 <Lethalman> Twey, just say: "I disagree"
14:28:47 <rtpg> paradigms mean what we want them to mean anyways
14:28:53 <rtpg> it's like when people talk about strong types
14:29:37 <aleksejs_> actually, paradigm in haskell depends on the code itself
14:30:06 <aleksejs_> you can wrap everything in "do" and it will work and it will be awfully declarative
14:30:10 <Twey> Lethalman: I don't disagree, because you haven't said anything I can disagree with :þ  None of those terms has a fixed meaning, so when you make a statement about them, you're just talking about how you feel about those terms at a particular time, which tells me very little about the terms and nothing about the languages :þ
14:30:15 <aleksejs_> imperative*
14:30:25 <startling> does "declarative" mean "names are declarations, not names for mutable data" or something else?
14:30:35 <adimit> aleksejs_: no no no. It will not be imperative. Monads are not just magic pixie dust that allows you to make imperative programs.
14:30:49 <adimit> in fact, you can easily just construct pure data types, monadically.
14:30:49 <aleksejs_> adimit, I know
14:30:55 <startling> do-notation is pretty imperative.
14:31:03 <startling> superficially at least.
14:31:08 <adimit> it sugar.
14:31:11 <startling> sure.
14:31:11 <adimit> *it's
14:31:25 <quchen> It's sugar for something pretty imperative. Superficially at least.
14:31:34 <startling> :)
14:32:15 <adimit> … whether it is "pretty imperative" depends on the Monad in question. IO, State, ST are the most common ones.
14:32:24 <adimit> (where it feels imperative.)
14:32:28 <Axman6> Lethalman: what's your definition of declarative? because I think it would be extremely hard to argue that declarative programming isn't one of Haskell's strong points due to laziness
14:32:51 <adimit> for example, I'm using do-notation to describe a graph, right now. (or trying to, at least.)
14:32:55 <Fristi> Hello
14:33:05 <Lethalman> Axman6, if it's for laziness, then pure lazy functional programming is declarative, not functional in general
14:33:09 <aleksejs_> .Hi
14:33:22 <Twey> Fristi: Hello!
14:33:39 <Axman6> to me, declarative means you define what results you want, not how they're computed, and that's exactly what you do with Haskell. Often there's an obvious evaluation order, but it doesn't have to be evaluated in that order; the compiler is free to decide
14:33:40 <rtpg> imperative/declarative/functional is more about code style, language design can make some easier than others, but in the end it's the code
14:33:54 <Axman6> Lethalman: so you're saying functional languages aren't functional...
14:33:56 <Lethalman> Axman6, yes, also gcc is free to decide -.-'
14:34:02 <quchen> Getting a working knowledge of free monads taught me to not worry about what imperative means that much anymore. I now call Haskell "purely functional" so people rather worry about the pure part. :-þ
14:34:13 <aleksejs_> Lethalman, declararive is above functional, because, both functional and logical, and some others are actually declarative
14:34:36 <Axman6> Lethalman: on the micro level GCC is free to decide, but not on the program level. C programs define the order in which things are to be computed\
14:34:39 <Twey> quchen: I prefer to focus on the type system.  :þ
14:34:41 <rtpg> actually Lethalman , gcc isn't free to decide on everything, there are rules about execution order on certain things. The operational semantics of haskell are a lot more open, because of lack of side effects in the language
14:34:51 <aleksejs_> functional is just a way to implement declarative paradigm
14:35:07 <quchen> Twey: Or that, yes.
14:35:12 <scriptor> speaking of declarative, is there any large list of declarative code examples
14:35:15 <Axman6> and not all functional languages are declarative right? OCaml would be an example no?
14:35:18 <quchen> Twey: I find it hard to explain to someone who's never heard of it though.
14:35:32 <Twey> quchen: Typing?
14:35:43 <startling> hmmm, I think Haskell's data declarations are pretty declarative.
14:35:55 <adimit> Axman6: arguably, lua just screws over all such definitions, as it can claim to be functional, imperative, and object-oriented.
14:36:01 <adimit> there's probably some person out there claiming that lua is declarative.
14:36:03 <startling> I'm not sure whether I'd consider regular declarations to be.
14:36:06 <dmj`> is there a better way to write something like this: filter (\x -> (x == 1 || x == 2)) [1..10]
14:36:10 <adimit> and he might even be right, I don't care.
14:36:14 <startling> adimit: it can be used declaratively, I'm sure.
14:36:28 <Fristi> I am having a problem to make the following code work: http://lpaste.net/98253, the getDefinition does get picked up.. do i need to constrain the generic or hint the compiler its type?
14:36:30 <startling> it often is, for games.
14:36:33 <quchen> Twey: No, Haskell-ish type systems. Many people are annoyed by mainstream statically typed languages and think more types mean even more hurdles.
14:36:58 <adimit> startling: the whole table-based programming can have a pretty declarative feel to it, to be sure. I've just yet to see someone actually use Lua that way.
14:36:59 <Lethalman> dmj`, [1,2] :P
14:37:04 <WraithM_> dmj`: take 2 [1..10] ? That's probably not helpful.
14:37:13 <acowley> :t (||) <$> (==1) <*> (==2)
14:37:14 <lambdabot> (Eq a, Num a) => a -> Bool
14:37:16 <WraithM_> Or Lethalman's answer
14:37:35 <dmj`> Lethalman: the actual example uses filepaths and extensions :)
14:37:45 <quchen> He said "better", not "fancier".
14:37:55 <dmj`> let filtered = filter ((\x -> x =="ext1" || x == "ext2") . takeExtension) contents
14:37:58 <pqmodn> dmj`: consider also filter (`elem` [1,2])
14:38:07 <Fristi> I am getting: Couldn't match expected type `Event e -> [Column e]'  with actual type `[Column c0]'
14:38:08 <startling> ^ that's what I was going to say
14:38:11 <acowley> Yeah, I use the elem approach when I'm going for compactness
14:38:21 <Lethalman> :t elemOf
14:38:21 <lambdabot> Eq a => Getting Any s a -> a -> s -> Bool
14:38:26 <Lethalman> :t elem
14:38:26 <lambdabot> Eq a => a -> [a] -> Bool
14:38:39 <Lethalman> dmj`, perhaps elem ["ext1", "ext2"]
14:38:50 <Fristi> anyone got a clue ? :)
14:38:50 * Lethalman didn't read
14:38:56 <Twey> quchen: I find telling them about type-inference is usually enough to get them to give it another look.
14:38:57 <monochrom> Fristi: maybe you just forgot one parameter or have one spurrious parameter
14:39:00 <acowley> I use the applicative approach when performance matters and the predicates are already bound to identifiers
14:39:22 <Fristi> monochrom: what is a suprrious parameter?
14:39:28 <pqmodn> acowley: does it get ugly with more than two tests?
14:39:38 <monochrom> a parameter that shouldn't be there
14:39:38 <startling> acowley: why would the Applicative approach be more performant?
14:39:40 <quchen> Twey: Hehe right, that usually makes people smile when you tell them the types are hidden. As long as you don't mention that omitting type sigs is often frowned upon ;-)
14:39:52 <dmj`> filtered = filter (flip elem ["ex1","ex2"] . takeExtension) contents
14:40:05 <acowley> startling: You know, I just assumed it's faster than `elem` but I've not actually benchmarked it
14:40:15 <Twey> dmj`: filter (`elem` [1, 2]) ?
14:40:20 <startling> acowley: I mean, it's still O(n) for the number of possibilities.
14:40:23 <acowley> pqmodn: Then I go to or
14:40:30 <dmj`> Twey: those extra parens kill me
14:40:30 <WraithM_> > filter (`elem` [1,2]) [1..10]
14:40:31 <lambdabot>  [1,2]
14:40:33 <startling> with inlining or whatever I'm sure it's comparable
14:40:35 <dmj`> I'd rather do flip
14:40:46 <Fristi> monochrom: i see.. cant see where though.. e is constrained to Event .. and there is a instance of columndefinition available for that http://lpaste.net/98253
14:40:48 <Axman6> acowley: I believe it's been shown to be yes. GHC does a much better job optimising \x -> x == a || x == b || x == c
14:40:55 <dmj`> same when doing (\_ -> return 4), why not jsut (const $ return 4)
14:41:01 <acowley> Axman6: I'd be surprised if it didn't
14:41:09 <Twey> dmj`: You still need them.  Well, I guess you can say: flip elem [1, 2] `filter` [1 .. 10]
14:41:14 <acowley> startling: It can still be a rather large constant factor
14:41:14 <Axman6> take a look at Neil Mitchel's latest post about optimising loops in haskell for an example
14:41:38 <Twey> Or if you're writing a definition of course you can go point-free and just say filter $ flip elem [1, 2]
14:41:48 <rtpg> considering the fact that core is built solely out of case disjunction, I'd hope it knows how to optimise it well
14:41:49 <dmj`> Twey: ghci let me get away w/ no parens :)
14:41:49 <startling> hey, I wonder if OverloadedLists would let us do instance IsList (Eq a => a -> Bool)
14:42:07 <pqmodn> rtpg: it is?
14:42:09 <monochrom> Fristi: I don't understand "bla :: Event e => [Column e]". is Event a class?
14:42:12 <Twey> dmj`: Huh?
14:42:42 <Fristi> monochrom; Event is a record with a generic param
14:42:48 <rtpg> pqmodn, yeah, the Core language contains only basic pattern matching (DataType val1 val2 val3 type) and function application only
14:42:48 <eazar001> Frist ...
14:43:00 <monochrom> so it is not a class? so what is it doing at a place where you should have a class?
14:43:01 <geekosaur> what
14:43:15 <startling> aww, no, we'd need toList too
14:43:20 <eazar001> it looks like it is expecting a function where it shouldn't be expecting one at least
14:43:22 <dmj`> Twey: see the code posted above, filter (flip elem ["ex1", "ex2"] . takeExtension), as opposed filter ((flip elem ["ex1","ex2"]) . takeExtension)
14:43:29 <dmj`> to*
14:43:30 <Twey> dmj`: You can use one of those permutations to do it without parentheses, but otherwise you need them: filter flip elem [1, 2] [1 .. 10] is not the same as filter (flip elem [1, 2]) [1 .. 10]
14:43:47 <Twey> dmj`: Oh, yeah, of course
14:44:01 <adimit> startling: you could implement it as the function that generates every possible predacite. No one said the list would have to be finite.
14:44:07 <rtpg> oh there are also let expressions and constructor applications
14:44:11 <Twey> I didn't see the extra code
14:44:19 <dmj`> Twey: what is different
14:44:20 <Twey> I would flip there, too.  ☺
14:44:32 <Twey> dmj`: The fact that you're composing it with another function
14:44:33 <startling> adimit: alas, it would break the IsList law.
14:44:48 <adimit> startling: bummer.
14:44:56 <Fristi> monochrom: nope, for what reason should it be a class? it does not have multiple instances right ? Its just a record  (data) which holds values.. Event will be serialized and stored
14:44:57 <pqmodn> rtpg: yeah, i think there are quite a few more constructs than pattern matching and function application. not hundreds, but you can't do much with those two alone
14:44:57 <adimit> we can't absue the thing becasue laws! How dull.
14:45:06 <adimit> *because
14:45:14 <Twey> dmj`: Although you can also avoid those: flip elem ["ex1", "ex2"] . takeExtension `filter` [1 .. 10]
14:45:16 <monochrom> so what does "Event e => [Column e]" mean?
14:45:53 <Twey> (well, not [1 .. 10], obviously)
14:46:14 <aleksejs_> is there a better alternative for Data.List permutations for [0..n] ?
14:46:16 <Twey> dmj`: Or, in a definition, filter $ flip elem ["ex1", "ex2"] . takeExtension
14:46:18 <rtpg> pqmodn, http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf page 20 contains the syntax, it's gotten a bit bigger now with threads and whatnot, but it's still really tiny
14:46:28 <rtpg> in theory all haskell constructs translate down to this
14:46:51 <monochrom> why is it not simply "[Column (Event e)]"?
14:47:10 <Fristi> monochrom: good one, that where i hit stuck :) the goal is to persist a list of e (Event e) in this case, e should have a column definition so i can use getDefintion to get the columns and serialize e
14:47:21 <aleksejs_> because for bigger n, permutations is dreadfully slow
14:49:14 <rtpg> pqmodn, http://freecomputerbooks.com/Implementing-Functional-Languages-A-Tutorial.html this book (written by SPJ) actually describes an ancestor to Core, and it's also extremely minimal in constructs used
14:49:32 <pqmodn> rtpg: i think your first link describes STG, not core.
14:49:36 <monochrom> I do not like the description "a list of e (Event e)". it sounds like not making up one's mind.
14:49:52 <pqmodn> rtpg: the last documentation on Core i've found is https://github.com/ghc/ghc/blob/master/docs/core-spec/core-spec.pdf?raw=true
14:50:11 <monochrom> either you have "a list of e", which is [e]; or you have "a list of Event e", which is [Event e]
14:50:40 <monochrom> and neither brings up "Column"
14:50:57 <Fristi> monochrom: ah i see :) , how would that be encodeable?
14:51:03 <Fristi> in the types
14:51:25 <monochrom> or you have "a list of e, but e has to be an instance of X", which is "X e => [e]". but then X has to be really a class.
14:51:43 <monochrom> I don't know how to encode it. I don't even know what you mean now.
14:52:24 <lllllllllllll> can someone maybe explain the difference between equational correspondence and equational equivalence?
14:52:50 <monochrom> but I can keep enumerating randomly generated but valid types and you can keep trying. the next one is "ColumnDefinition c => [Column c]"
14:53:08 <Fristi> i see.. hmm..
14:54:10 <monochrom> I'm pretty sure [Column (Event e)] is most likely
14:54:36 <rtpg> pqmodn, nice find, didn't know that coercion stuff was in there
14:54:52 <augur> whats some good contemporary literature on program derivation?
14:55:40 <Fristi> let me see if that might work :) , you see what the goal is ? i want to implicitly inject the right definition based on the type you pass in , so if i pass in a list of (Event e) i want the ColumnDefinition (Event e) to be available and be able to use getDefinition
14:57:25 <monochrom> then you don't even need bla. it's redundant. you already have getDefinition, it already implicitly injects the right definition based on type.
14:58:46 <Fristi> myea bla is misleading in this case.. i wanted to get to types work first
14:59:05 <Fristi> and then make it a more generic wherever possible
15:00:03 <monochrom> I am not convinced that "print (whatever that has type [Column whatever])" is possible. Column whatever is not a Show instance
15:00:19 <Fristi> currently coding that ;)
15:01:39 <Fristi> nice :) got it working http://lpaste.net/98253
15:05:03 <flazz> in cabal, is there a way to have a test-suite inherit all the build-deps of the executable or lib under test?
15:07:06 <Clint> flazz: that would be handy
15:07:11 <startling> flazz: yeah, I wish.
15:07:34 <startling> same thing with libraries
15:07:39 <startling> + executables, alas
15:07:48 <joneshf-laptop> i'm curious, there doesn't seem tobe much talk about commutativity when it comes to types in haskell
15:07:56 <joneshf-laptop> i assum ebecause most things aren't commutative
15:08:05 <flazz> like using a library or executable as a build-depend
15:08:11 <joneshf-laptop> but there are some pretty standard things that SHOULD be commutative
15:08:17 <joneshf-laptop> like Data.Map and Data.Set
15:08:24 <joneshf-laptop> for that matter, certain Trees
15:08:28 <startling> joneshf-laptop: what do you mean?
15:08:59 <joneshf-laptop> > (Data.Set.singleton 4 <> Data.Set.singleton 3) == (Data.Set.singleton 3 <> Data.Set.singleton 4)
15:09:00 <lambdabot>  Not in scope: `Data.Set.singleton'Not in scope: `Data.Set.singleton'Not in s...
15:09:02 <Fristi> monochrom: thanks for the help :)
15:09:03 <joneshf-laptop> bleh
15:09:28 <monochrom> you're welcome
15:09:37 <startling> > (S.singleton 4 <> S.singleton 3) == (S.singleton 3 <> S.singleton 4)
15:09:39 <lambdabot>  True
15:09:48 <startling> joneshf-laptop: sure, but what would commutativity let you do?
15:10:15 <startling> the only thing I can think of is, like class Monoid m => Commutative m; and then Commutative m => Set m -> m
15:10:19 <joneshf-laptop> startling, i'm not entirely sure, but shouldn't it allow for a different way to think about things?
15:10:57 <startling> joneshf-laptop: there's no reason it /should/. I'm not convinced it doesn't, but that's the only nice thing I can think of that you'd get from it.
15:12:34 <joneshf-laptop> startling, like parallelism in a different light? like if you were performing some operation on elements where they were associative. rather than processing elements in order, even if you divide and them different ways with associativity, you still have to go in order when you combine them
15:12:52 <triliyn> It's valuable to think about whether a particular operation commutes, but not in a way that would be captured by typeclasses I think
15:13:14 <joneshf-laptop> if things were commutative, couldn't you get some kind of compiler optimization out ofthere?
15:13:31 <joneshf-laptop> triliyn, why's that?
15:13:34 <triliyn> Like, if you're folding something that's not a list, in a number of cases you'd probably want to use a commutative folding function
15:13:42 <triliyn> (Sometimes you explicitly don't, but often you do)
15:13:54 <startling> yeah; if there's no order you want to care about you want commutativity.
15:14:07 <triliyn> But you wouldn't want to use a typeclass function for that
15:14:16 <startling> joneshf-laptop: well, the main thing is that you can't represent commutativity in Haskell
15:14:53 <startling> you can say "this typeclass operation is supposed to be commutative" but there's no way to e.g. have a typeclass member that says "this other function is commutative".
15:14:54 <joneshf-laptop> triliyn, sure, but then that wouldn't negate the idea of there being a typeclass would it?
15:15:04 <monochrom> I am too lazy to write an optimizing compiler that exploits commutativity
15:15:16 <monochrom> but it can be done
15:15:29 <pqmodn> fortress probably does that
15:15:39 <triliyn> joneshf-laptop: it wouldn't, but I think most of the applications of commutativity are similar
15:15:44 <maxiepoo> you can't encode associativity either but we all still use Monoid
15:15:48 <joneshf-laptop> startling, i'm not following
15:15:53 <triliyn> You don't want to have access to an arbitrary commutative operation
15:15:59 <monochrom> I am also too lazy to write an optimizing compiler that performs clever theorem proving to discover clever rewrites to your program. but it can be done.
15:16:07 <startling> maxiepoo: yeah, it's true.
15:16:08 <triliyn> Rather, you want to know that a particular operation you're using is already commutative
15:16:18 <monochrom> if you pay me 1 million bitcoins, I will do it for you.
15:16:34 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #2
15:17:11 <startling> monochrom, does it have to be in any particular blockchain?
15:17:42 <monochrom> I think it has to be. because I'm going to wait for validation or whatever it's called.
15:17:55 <startling> oh. never mind, then 1
15:17:56 <startling> !
15:18:17 <triliyn> monochrom: what if I give you 1 million bits of information instead? :D
15:18:28 <monochrom> hell, in fact I'm going to wait for all of it to be cashed at exchanges.
15:18:57 <monochrom> that may be worth nothing to me
15:19:29 <joneshf-laptop> triliyn, i dont understand what you're saying. are you suggesting that you might be implementing something on a structure that uses an underlying commutative operation, but you don't want it to use that commutative operation?
15:19:43 <joneshf-laptop> triliyn, or soething else entirely?
15:20:43 <triliyn> joneshf-laptop: I'm saying that you'd be more likely to want to do something like "foldEnsuringCommutative (+)" than "fold commutativeOp"
15:20:54 <triliyn> (Where commutativeOp would be the typeclass method)
15:20:56 <triliyn> If that makes sense
15:21:24 <danil> @seen edwardk
15:21:24 <lambdabot> edWardx
15:21:35 <maxiepoo> what optimization could be performed using commutativity anyway?
15:21:35 <startling> haha what
15:21:38 <pqmodn> lambdabot: there there
15:21:42 <startling> danil, ask preflex
15:22:43 <triliyn> danil: maybe if you're folding over a structure that is being generated by lots of concurrent sparks in nondeterministic order
15:22:45 <erisco> maxiepoo, a || b could become b || a if b is cheaper to evaluate or b is more likely to be true
15:22:54 <triliyn> You can process them as they come in rather than in order
15:22:58 <maxiepoo> how could the compiler know that though?
15:23:13 <joneshf-laptop> triliyn, ah, i see what you mean
15:23:15 <startling> you'd have a
15:23:20 <startling> type for it.
15:23:28 <erisco> maxiepoo, combined with associativity you can move arguments around and make use of other substitutions
15:23:41 <joneshf-laptop> triliyn, but surely that comes down to the api level or something, no?
15:23:50 <maxiepoo> erisco, right but then you'd need to encode a cost semantics into the type too
15:24:28 <monochrom> or write it in comments, and have the compiler read your comments
15:24:37 <maxiepoo> so for example foldMap can be optimized on a list to reduce the calls to mappend
15:24:51 <triliyn> joneshf-laptop: well, I think you can't really write foldEnsuringCommutative with a useful type
15:25:02 <maxiepoo> by using associativity to basically do everything pair-wise
15:25:15 <maxiepoo> and then keep going pairwise until you get a value
15:25:18 <triliyn> It can't inspect your arbitrary provided function to ensure that it is commutative
15:25:32 <triliyn> (So you can't even do runtime checking)
15:25:39 <maxiepoo> but I don't see what similar things could be done with only knowing about commutativity
15:26:10 <joneshf-laptop> triliyn, hmm, true
15:26:16 <maxiepoo> oh wait
15:26:21 <maxiepoo> it can't reduce the number of calls
15:26:22 <erisco> maxiepoo, x = a op b; y = b op a; this could be simplified to x = y = a op b;
15:26:32 <joneshf-laptop> triliyn, although, i guess the same could be said for associativity, but we still like that
15:27:14 <joneshf-laptop> i think also, what does it matter if we can see the immediate benefit to this?
15:27:19 <joneshf-laptop> aside from motivation purposes
15:27:37 <joneshf-laptop> someone miht find a use forit, and it'll catch on, or it'll go the way of Point
15:27:49 <triliyn> Yeah, it is indeed kind of weird that "Here, have an arbitrary associative operator" is used so much
15:28:16 <triliyn> (Not quite arbitrary because of the identity, but close enough)
15:28:38 <augur> copumpkin: what did you mean by that thing you said the other day
15:28:40 <augur> :X
15:28:53 <joneshf-laptop> triliyn, well, i think it'd be best if there were laws for the commutativity thing as well
15:29:02 <joneshf-laptop> though
15:29:08 <joneshf-laptop> actually
15:29:20 <erisco> maxiepoo, foldr could be replaced with foldl
15:29:30 <augur> copumpkin: about uniqueness and canonicity in implicits not being a substitute for type classes
15:29:34 <augur> erisco: not always!
15:29:45 <augur> not without simulating folds
15:29:51 <roger_> hello is there someone who can help me with a problem i am having with processes and reading from its handles ?
15:30:05 <maxiepoo> erisco, don't you just need associativity for that though?
15:30:36 <augur> maxiepoo: you need a monoid
15:30:40 <maxiepoo> right
15:31:00 <augur> if (f,z) form a monoid, then foldr f z ~ foldl z f
15:31:22 <erisco> maxiepoo, yes I suppose that is right
15:31:43 <pqmodn> :t foldr
15:31:44 <lambdabot> (a -> b -> b) -> b -> [a] -> b
15:31:47 <pqmodn> :t foldl
15:31:48 <lambdabot> (a -> b -> a) -> a -> [b] -> a
15:31:57 <erisco> maxiepoo, well I dunno I am out of ideas :)
15:32:01 <augur> oh it was just the args of the algebra that are reversed
15:32:02 <augur> well then!
15:32:08 <augur> foldr f z ~ foldl f z
15:32:25 <augur> i really hate the ordering on folds
15:32:27 <pqmodn> i think you may need flip f for one of them?
15:32:41 <augur> ive always felt it should at least be flipped from how it is
15:32:49 <augur> with the binop second
15:32:58 <augur> pqmodn: yeah that too. who cares. xP
15:33:00 <ReinH> augur: third list homomorphism theorem iirc?
15:33:02 <augur> you get the point
15:33:04 <hpc> augur: doesn't hold for infinite lists
15:33:12 <augur> hpc: that too!
15:33:16 <augur> ReinH: ??
15:33:33 <ReinH> if a fold is both a left fold and a right fold then it is a monoidal fold
15:33:44 <augur> i dont know quite what that means but ok
15:33:45 <ReinH> augur: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.2247&rep=rep1&type=pdf
15:34:01 <augur> anyway, left folds are silly
15:34:03 <ReinH> "y. It states that a function on lists that can be computed both from left to right
15:34:06 <ReinH> and from right to left is necessarily a list homomorphism|it can be computed according
15:34:09 <ReinH> to any parenthesization of the list.
15:34:12 <ReinH> "
15:34:13 <triliyn> hpc: for infinite lists don't they both have to be bottom?
15:34:14 <ReinH> argh sorry for multiple lines
15:34:42 * hackagebot HGL 3.2.0.5 - A simple graphics library based on X11 or Win32  http://hackage.haskell.org/package/HGL-3.2.0.5 (AlanHawkins)
15:34:59 <maxiepoo> and every monoidal fold can be parallelized!
15:36:08 <triliyn> Commutative monoidal folds parallelize better, don't they?
15:36:22 <triliyn> Or maybe I don't understand what you mean
15:36:44 <ReinH> triliyn: commutative operations parallelize better in general
15:37:23 <ReinH> but associativity is enough to get log n parallelization
15:37:28 <maxiepoo> a <> b <> c <> d
15:37:37 <maxiepoo> can turn into (a <> b) <> (c <> d)
15:37:41 <ReinH> commutativity is theoretically enough to get constant-tome parallelization
15:37:50 <ReinH> a tree fold is log n parallelizable, for instance
15:37:57 <maxiepoo> and then you can run (a <> b) and (c <> d) in parallel
15:38:01 <ReinH> exactly
15:38:04 <maxiepoo> right tree fold
15:38:06 <ReinH> (that's a tree fold)
15:38:12 <maxiepoo> er
15:38:15 <maxiepoo> right, a tree fold
15:38:27 <triliyn> ah, I was thinking of the case where the fold is occurring in parallel with the evaluation of the list
15:38:31 <ReinH> ((a <> b) <> (c <> d) <> ((e <> f) <> (g <> h)) and so on
15:38:50 <triliyn> Which potentially requires extra waiting if the elements of the list are materializing in random order
15:39:15 <ReinH> Actually O(n log n) and O(n) if you take into account lazy traversal
15:39:50 <dmj`> maxiepoo: ha :)
15:39:54 <ReinH> so associative operations parallelize almost as well as commutative
15:40:51 <ReinH> but the constant factor on a lazy traversal is so small as to be negligible in most cases
15:42:13 <quchen> ReinH: Now I'm wondering whether there's an online version of the minimum-sum algorithm.
15:42:19 <ReinH> triliyn: well, in cases like that you want per-process work stealing
15:42:26 <quchen> Or at least one that works for infinite lists.
15:42:27 <ReinH> like the RTS uses for isntance
15:42:49 <ReinH> quchen: hmm
15:43:12 <ReinH> quchen: I'm sure there is. You probably mean "is there an efficient one" ;)
15:43:20 <Tekmo> ReinH: What's the minimum sum algorithm?
15:43:32 <ReinH> Tekmo: some puzzle we were presented with earlier, not a standard algo
15:43:34 <quchen> ReinH: I was thinking about finding some form of minimum and then going away from that, instead of starting at the ends and narrowing it down.
15:43:50 <ReinH> if I have a list like [-3,-1,0,2,5], what pair of numbers has a sum closest to zero?
15:43:51 <quchen> That minimum won't be available without further constraints though.
15:44:12 <quchen> "What's the sum", not "which numbers"
15:44:16 <ReinH> Tekmo: or, alternatively, what is the minimum sum I can make from any two pairs
15:44:17 <quchen> Although that's closely related.
15:44:25 <ReinH> that was the original problem
15:44:40 <quchen> The list is sorted.
15:44:43 <quchen> Important detail.
15:44:46 <ReinH> also important
15:45:35 <quchen> And O(n) complexity is what we are aiming for.
15:46:57 <quchen> By the way, can I somehow tell QuickCheck to only produce lists of length > n?
15:47:31 <joneshf-laptop> ReinH, duplicates?
15:47:48 <quchen> For "list with at least 2 elements" something like "forAll arbitrary $ \(a,b,xs) -> a:b:xs …" works, but that doesn't scale well
15:47:49 <joneshf-laptop> ReinH, or distinct elements?
15:48:30 <joneshf-laptop> also, wasn't that a Functional pearl from like 92 or something?
15:49:13 <ReinH> quchen: My QuickCheck skills are rudimentary :(
15:49:43 <ReinH> joneshf-laptop: I don't know but I like functional pearls so if you have any I'd love to read them :)
15:49:44 * hackagebot language-bash 0.2.0 - Parsing and pretty-printing Bash shell scripts  http://hackage.haskell.org/package/language-bash-0.2.0 (KyleRaftogianis)
15:50:49 <mello__> another stupid question:
15:51:03 <quchen> What are Functional Peals anyway? I know a handful of papers titled that, is it a series or just some form of a catchword?
15:51:08 <mello__> i have f and g, with types (a->bool), how do i combine them to get another bool?
15:51:12 <Tekmo> ReinH: There's a Haskell wiki page with a lot of functional pearls
15:51:16 <ReinH> quchen: some sort of catchword
15:51:18 <mello__> (a->bool)->(a->bool)->a->bool
15:51:31 <ReinH> Tekmo: yeah I think I've seen most of them but I don't remember one about something like this.
15:51:50 <joneshf-laptop> quchen, it's a series that started in the back of the papers, i believe
15:51:53 <geekosaur> mello__, not really answerable when put like that. combine *how*?
15:51:59 <joneshf-laptop> quchen, Bird has a whole book wit them
15:52:00 <triliyn> mello__: you probably want to (&&) or (||) them
15:52:02 <quchen> In the back of papers?
15:52:04 <Tekmo> mello__: The least verbose way is `liftA2 (||)` or `liftA2 (&&)`, depending on how you want to combine the bools
15:52:20 <Tekmo> mello__: Note that if you wrap the bools in the `Any` or `All` monoids then the answer is just `(<>)`
15:52:25 <quchen> :t \f g x -> f x || g x -- mello
15:52:26 <lambdabot> (t -> Bool) -> (t -> Bool) -> t -> Bool
15:52:45 <ReinH> @djinn (a->bool)->(a->bool)->a->bool
15:52:45 <lambdabot> f _ a b = a b
15:52:48 <joneshf-laptop> quchen, The Journal of Functional Programming
15:52:49 <ReinH> done.
15:52:59 <Tekmo> mello__: Or if you define a `Num` instance for `Bool` and a `Num` instance for `((->) a)` then the answer is either `(+)` or `(*)`
15:53:11 <mello__> Tekmo, what is (<>)?
15:53:14 <mello__> :t (<>)
15:53:15 <lambdabot> Monoid m => m -> m -> m
15:53:15 <quchen> infix mappend
15:53:17 <Tekmo> mello__: mappend
15:53:26 <Tekmo> mello__: Are you familiar with `Monoid`s?
15:53:38 <mello__> Tekmo, haven't used them a lot, but i do know mappend
15:53:43 <ReinH> Let's pick one of Functor or Monoid to talk about first :)
15:53:52 <quchen> ಠ_ಠ  Num instance for   (->) a
15:53:58 <Tekmo> mello__: So there are two `Monoid` instance for `Bool`, both of which involve a newtype
15:54:15 <Tekmo> If you wrap bools in the `Any` newtype, then `mappend` is `(||)` and mempty is `False`
15:54:17 <mello__> Tekmo, ok, I follow so far
15:54:28 <Tekmo> If you wrap bools in the `All` newtype, then `mappend` is `(&&)` and mempty is `True`
15:54:41 <mello__> ah, that's neat
15:54:43 <Tekmo> So now, just pretend for a second that you were combining things that were not functions
15:55:02 <Tekmo> In other words, if your function signature was just `Bool -> Bool -> Bool`, then that looks pretty close to the signature for `mappend`
15:55:07 <ReinH> mello__: let's write a simple function that does what you want, assuming you want to && the results
15:55:25 <mello__> ReinH, yes I want && :)
15:55:31 <Tekmo> mello__: But you would have to wrap the `Bool`s in either the `Any` or `All` newtypes before mappending them together and then unwrapping them, so it's a little verbose
15:55:38 <ReinH> go f g a = f a && g a
15:55:43 <shachaf> There are many possible Monoid instances for Bool, but no actual instances.
15:55:49 <Tekmo> Now, it turns out that there is also an interesting monoid instance that looks like this:
15:55:50 <ReinH> you apply a to f and g and then && the results
15:56:06 <Tekmo> mello__: instance (Monoid b) => Monoid (a -> b) where ...
15:56:11 <mello__> ReinH, yeah that's the simplest one :)
15:56:18 <Tekmo> mello__: It basically says that if `b` is combinable, then so is `(a -> b)`
15:56:29 <Twey> quchen: A ‘Pearl’ is something surprisingly nice that you don't expect to find
15:56:36 <Tekmo> mello__: So if `Any`/`All` are combinable, then so are `a -> Any` and `a -> All`
15:56:56 <mello__> thanks ReinH, Tekmo I'll try the monoid way too, i want to get a grasp of it. Sorry if i'm slow, my brain is tired ;)
15:56:58 <ReinH> mello__: now, you can instead use liftA2 (&&) but you won't know *why* you can use that if you don't understand how functions are Applicative
15:57:03 <Twey> People used to have a much more negative view of Haskell and functional programming in general (‘wearing the hair shirt’ and all that)
15:57:27 <Tekmo> mello__: The way that latter Monoid instance is defined is:
15:57:35 <Tekmo> mello__: mempty = \_ -> mempty
15:57:45 <joneshf-laptop> ReinH, there's a thing, "Sorting pairwise sums" in Bird's book
15:57:47 <Tekmo> mello__: mappend f g = \a -> mappend (f a) (g a)
15:57:50 <mello__> ReinH, you are right. Let's say I have a grasp of Monoids Monads, functors and Applicative, but not always big enough to really "get" the complete picture
15:58:00 <ReinH> joneshf-laptop: functional pearls of alg. design?
15:58:04 <Tekmo> mello__: It turns out that you can simplify those two definitions using `Applicative`s
15:58:06 <ReinH> joneshf-laptop: funny I don't remember that. Awesome.
15:58:10 <Tekmo> mello__: When you do, the solutions you get are:
15:58:12 <ReinH> (I have the book)
15:58:13 <Tekmo> mello__: mempty = pure mempty
15:58:17 <quchen> Twey: Sure, but I've never heard of imperative pearls or physics pearls. I thought maybe it had another meaning I didn't know, some pun or whatever.
15:58:18 <Tekmo> mello__: mappend = liftA2 mappend
15:58:49 <Tekmo> mello__: So when I gave you the solution of either `liftA2 (&&)` or `liftA2 (||)` I was basically inlining the solution of `mappend` for `(a -> Any)` or `(a -> All)`
15:59:04 <ReinH> Tekmo: I think instance Applicative ((->) r) here is more relevant than instance Monoid All :)
15:59:08 <mello__> it's liftA2 here because it's only Applicative, not Monad right?
15:59:09 <ChongLi> pure (pure (pure (pure (pure ... mempty))))?
15:59:16 <ReinH> Tekmo: Oh I see how you got there.
15:59:17 <Tekmo> ReinH: They are both relevant in my opinion
15:59:31 <ReinH> Tekmo: I wasn't looking at liftA2 (&&) in terms of All but it makes sense.
15:59:32 <Tekmo> mello__: Actually both would work
15:59:41 <joneshf-laptop> ReinH, not sure it's the exact problem, but he mentions that it's O(n^2logn), unless the operation and the type form an abelian group, then it becomes O(n^2)
15:59:46 <Tekmo> mello__: First, let's understand how `liftA2` works when you apply it to functions
15:59:46 <joneshf-laptop> so there's commutativity in action
15:59:54 <joneshf-laptop> reducing algorithmic complexity
16:00:06 <Tekmo> mello__: Have you ever used `((->) a` as an `Applicative`/`Monad`?
16:00:23 <ReinH> joneshf-laptop: Awesome. I love that book :)
16:00:24 <mello__> Tekmo, nope
16:00:32 <ReinH> mello__: let's start with: have you ever used fmap for functions?
16:00:41 <mello__> isn't that just (.)?
16:00:46 <Tekmo> mello__: Are you more comfortable with `Applicative`s or `Monad`s, because you can do this with either one
16:00:50 <mello__> or well, i might be off but
16:00:50 <ReinH> mello__: let's not spoil the punchline :)
16:01:15 <mello__> I'd say applicative
16:01:33 <ReinH> mello__: SPOILER: yes, fmap is (.), so if you have composed functions then you have used their Functor behavior.
16:01:39 <Tekmo> mello__: If we do `Applicative`, then I'd like to make a small detour
16:02:00 <Tekmo> mello__: I prefer to think of `liftA2` as being a more fundamental operation than `(<*>)`
16:02:18 <Tekmo> mello__: Although they are interconvertible
16:02:26 <ReinH> Tekmo: despite its implementation in terms of (<*>) ;)
16:02:28 <Tekmo> mello__: You can define either one in terms of the other
16:02:45 <Tekmo> ReinH: I know.  I just mean that `liftA2` is much more generally useful in my opinion
16:02:48 <ReinH> Tekmo: and I like to build up from <$> to <*> :)
16:02:53 <ReinH> so from Functor to Applicative
16:03:03 <ReinH> Tekmo: yep, not saying either is more correct or valid
16:03:10 <mello__> <$> is fmap right
16:03:14 <mello__> :t (<$>)
16:03:14 <ReinH> mello__: yes
16:03:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:03:18 <mello__> :t (<*>)
16:03:18 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
16:03:50 <Tekmo> mello__: Okay, so anyway, let's try to define `(<*>)` for simplicity
16:03:58 <Jesin> Is there generally any expectation that fromEnum and toEnum should return/accept 0 or 1?  Or would it be acceptable to start at 2 and go up through 14 (for example when representing values in a deck of cards)?
16:04:00 <Tekmo> mello__: Replace the `f` in that type signature with `(r ->)`
16:04:04 <Tekmo> mello__: So you get
16:04:16 <Tekmo> mello__: (<*>) :: (a -> b) -> (r -> a) -> (r -> b)
16:04:27 <monochrom> Jesin: I think we expect to start from 0. well, I expect it.
16:04:40 <ReinH> Tekmo: not quite?
16:04:41 <mello__> Tekmo, and now you see
16:04:43 <mello__> :t (.)
16:04:44 <lambdabot> (b -> c) -> (a -> b) -> a -> c
16:04:47 <Tekmo> mello__: That's right
16:04:50 <ReinH> (r -> a -> b) -> (r -> a) -> (r -> b) ?
16:05:03 <monochrom> but you can make an exception because it is not like a lot of people will be affected
16:05:16 <Tekmo> mello__: Let me try a different tack
16:05:19 <ReinH> Tekmo: (<*>) :: (a -> b) -> (r -> a) -> (r -> b) is actually <$>??
16:05:27 <ReinH> you forgot to expand f (a -> b)
16:05:28 <Tekmo> mello__: When you use applicative style on functions, it is like you are operating on their results
16:05:49 <Tekmo> mello__: For example, here's a really inefficient way to compute the average of a list
16:06:01 <Tekmo> mello__: average xs = sum xs / genericLength xs
16:06:10 <Tekmo> mello__: With applicative style, you could just write that as
16:06:25 <Tekmo> mello__: average = (/) <$> sum <*> genericLength
16:07:03 <ReinH> mello__: it might be easier to see the relationship if you start with average xs =  (/) (sum xs) (genericLength xs)
16:07:36 <jonkri> How can I get the type constructor's name as a string?
16:07:48 <jonkri> Like, a -> String.
16:08:01 <quchen> You can't.
16:08:06 <Tekmo> jonkri: What do you mean?
16:08:07 <quchen> Well, you can write it yourself.
16:08:12 <quchen> But there's nothing standard like that.
16:08:27 <shachaf> :t show . toConstr
16:08:27 <lambdabot> Data a => a -> String
16:08:48 <mello__> so wait, then (/) <$> sum, because sum is a function and therefor a functor, the signature becomes (a->b)-> (r->a), and thus you get another function
16:08:50 <quchen> Oh. Hello Data. And Shachaf.
16:09:05 <jonkri> shachaf: That seems to do it. :) Thanks!
16:09:38 <ReinH> :t (/) <$> sum
16:09:38 <lambdabot> Fractional a => [a] -> a -> a
16:09:46 * hackagebot htsn-common 0.0.1 - Display/logging facilities used by both htsn and htsn-import.  http://hackage.haskell.org/package/htsn-common-0.0.1 (MichaelOrlitzky)
16:10:00 <Tekmo> mello__: Right.  It's like you applied `(/)` to one argument, but you have one argument left to go, so it's still a function
16:10:20 <ReinH> Tekmo: I still want to point out that you derived <*> for ((->) r) incorrectly
16:10:28 <ReinH> And that ((->) r) is not (-> r)
16:11:19 <ReinH> oh you said (r ->) never mind
16:11:29 <ReinH> but the first complaint stands
16:11:55 <Tekmo> ReinH: Oh yeah, oops
16:12:02 <Tekmo> Yeah
16:12:12 <Tekmo> mello__: ReinH is right
16:12:24 <Tekmo> mello__: So the mistake I made was that the signature of `(<*>)` is:
16:12:30 <Tekmo> mello__: f (a -> b) -> f a -> f b
16:12:36 <Tekmo> mello__: So the expanded type would have been
16:12:43 <Tekmo> mello__: (r -> a -> b) -> (r -> a) -> (r -> b)
16:12:53 <ReinH> :t (/) <$> sum
16:12:53 <lambdabot> Fractional a => [a] -> a -> a
16:12:54 <Tekmo> mello__: So function composition is not the implementation of it
16:12:59 <ReinH> this is where our r -> a -> b comes in
16:13:14 <ReinH> we have an (r -> a -> b) and we want an (r -> b)
16:13:34 <ReinH> i.e. we have an [a] -> a -> a and we want an [a] -> a
16:13:49 <mello__> ReinH Tekmo  is there some way i can get a log of IRC? I'd like to reread this again some time :)
16:14:10 <mello__> ReinH, now you're making me think about flip
16:14:22 <ReinH> :t genericLength
16:14:23 <lambdabot> Num i => [b] -> i
16:14:55 <ReinH> in this case it's [a] -> a because our length and sum have to provide the same type for (/)
16:15:38 <quchen> mello__: ircbrowse.net
16:16:16 <ReinH> so if (/) <$> sum :: [Double] -> Double -> Double and genericLength :: [Double] -> Double then (/) <$> sum <$> genericLength = [Double] -> Double
16:16:26 <ReinH> (I just picked a Fractional for `a')
16:17:55 <ReinH> mello__: so getting back to <*> for functions
16:18:07 <ReinH> (r -> a -> b) -> (r -> a) -> (r -> b)
16:18:33 <Tekmo> mello__: ircbrowse.net
16:19:12 <ReinH> (r -> a -> b) -> (r -> a) -> (r -> b)
16:19:14 <ReinH> \-----/-------------^
16:19:23 <ReinH> the first (r -> a) is substituted with the one you provide
16:19:47 * hackagebot zasni-gerna 0.0.7 - lojban parser (zasni gerna)  http://hackage.haskell.org/package/zasni-gerna-0.0.7 (YoshikuniJujo)
16:22:19 <mello__> ReinH im writing it on some paper because m too tired, one sec :)
16:22:28 <AshyIsMe> hmm, i seem to be having issues with hasktags
16:22:37 <AshyIsMe> every time i run it i get:
16:22:47 <AshyIsMe> hasktags: tags: openFile: resource busy (file is locked)
16:23:05 <mello__> ReinH,  could you explain exactly what -> means? is it just a function with one argument or?
16:23:12 <AshyIsMe> it creates an empty TAGS file (which i can rm each time)
16:23:23 <ReinH> mello__: -> is a type constructor for functions
16:23:40 <ReinH> a -> b is the type of functions that take an `a' and provide a `b'
16:23:52 <ReinH> :t succ
16:23:53 <lambdabot> Enum a => a -> a
16:24:18 <ChongLi> AshyIsMe: are you specifying the file with -o ?
16:24:20 <ReinH> eh less constraints
16:24:22 <ReinH> :t (++)
16:24:23 <lambdabot> [a] -> [a] -> [a]
16:25:01 <mello__> ReinH, it's this that i needed:
16:25:03 <mello__> :k (->)
16:25:04 <lambdabot> * -> * -> *
16:26:50 <ReinH> mello__: ah, well it's also a kind constructor :)
16:30:28 <AshyIsMe> ChongLi: that didnt seem to help either
16:31:18 <AshyIsMe> ChongLi: oh, it works if i say -c aswell
16:31:45 <joelteon> :k []
16:31:46 <lambdabot> * -> *
16:33:18 <mello__> ReinH,  telling you im not really capable of reasoning a lot now but
16:33:22 <mello__> i get stuck here (/) <$> sum :: [Double] -> Double -> Double
16:33:50 <ChongLi> AshyIsMe: do you want emacs or vim tags?
16:34:54 <mello__> wait, seems i missed that (/) takes 2 arguments
16:35:52 <AshyIsMe> ChongLi: vim tags, hasktags -c -o TAGS .   seems to have worked :)
16:36:29 <ChongLi> AshyIsMe: nice :)
16:38:21 <ReinH> :t (/) . sum
16:38:22 <lambdabot> Fractional b => [b] -> b -> b
16:39:11 <ReinH> :t \xs y -> sum xs / y
16:39:12 <lambdabot> Fractional a => [a] -> a -> a
16:40:00 <ReinH> mello__: do you see how those are the same?
16:40:26 <mello__> yeah ReinH :)
16:41:17 <ReinH> :t \f -> (/) <$> sum <*> f
16:41:17 <lambdabot> Fractional a => ([a] -> a) -> [a] -> a
16:41:36 <blaenk> is somethign of this type redundant? TVar (Map.Map String (TChan String, Integer))
16:41:44 <ReinH> mello__: so now we have a function that takes a function [a] -> a and provides a function [a] -> a
16:41:48 <ReinH> mello__: does that make sense?
16:42:05 <Iceland_jack> blaenk: Why should anything be redunant? You could make type synonyms for some of it
16:42:08 <blaenk> is it redundant because the whole thing is a TVar, so there's no point in making the inner Chan a TChan? does it not hurt to have it a TChan though?
16:42:16 <Iceland_jack> Ah
16:42:22 <mello__> ReinH, i'm sure I would after I get some sleep :)
16:42:26 <blaenk> what I pasted is what I currently have, but I just now wondered if it's redundant
16:42:31 <mello__> I'll get some sleep first, I'll reread this
16:42:33 <quchen> blaenk: No. The outer TVar is when you want to add another element to the "String -> Tuple", the channel is for communication or something.
16:42:36 <mello__> because now i'm just wasting your time
16:42:41 <blaenk> quchen: beautiful thanks
16:42:46 <Iceland_jack> mello__: That's impossible because our time is worthless
16:42:55 <Iceland_jack> </Futurama>
16:43:04 <mello__> Iceland_jack, overly poetic for 1:30 AM that it is here
16:43:20 <Iceland_jack> :)
16:43:20 <mello__> or 1:37 to be precise
16:43:38 <ReinH> mello__: think about the type of <*> as applied to (r ->) and the type of \f -> (/) <$> sum <*> f
16:43:45 <ReinH> mello__: and figure out what the <*> is doing there
16:44:57 <Twey> blaenk: TChans have their own specific semantics.  They're atomic, cross-thread queues, so there are valid use-cases for passing one inside another means of communication.
16:45:16 <Twey> blaenk: You might, for example, want to be able to switch the queue to be read from on the fly.
16:45:31 <Twey> If you're not using anything that's specific to TChans, though, you could probably use a list there instead.
16:45:48 <ReinH> mello__: And in fact you can get the implementation of <*> for (r ->) for free.
16:46:05 <Twey> (you might also want to keep track of whether some other thread has read a particular item)
16:46:16 <ReinH> the fact that there are free theorems is amazing
16:46:27 <ReinH> one of my first true mind blowing experiences with Haskell
16:47:18 <mello__> well ReinH  the only thing i can deduce is that with <*> you still have 1 more argument to apply compared to <*>
16:47:33 <ReinH> mello__: compared to <$> but yes, that's important
16:49:33 <mello__> ReinH, i'm really going to stop here i'm sorry. I'm unable to get it being tired.
16:49:39 <ReinH> mello__: np :)
16:49:50 * hackagebot htsn 0.0.4 - Parse XML files from The Sports Network feed.  http://hackage.haskell.org/package/htsn-0.0.4 (MichaelOrlitzky)
16:49:52 <mello__> I'll reread it and then hopefully I can continue my journey ;)
16:49:56 <mello__> see you around ReinH
16:49:59 <ReinH> mello__: sure thing
16:51:17 <jchee> is there a library for creating REPLs? I'm thinking something like interact on steroids
16:51:37 <dmj`> can I infix two functions? like `(flip catch)`
16:51:51 <Feuerbach> no
16:52:33 <Feuerbach> jchee: look at http://hackage.haskell.org/package/Shellac
16:53:14 <ReinH> dmj`: you might just like to do something like: thing `catching` badStuff where catching = flip catch
16:54:05 <ReinH> Feuerbach: oooh nice that might come in handy for my own things
16:54:22 <Feuerbach> dmj`: just in case you really need it for Control.Exception.catch, there's handle = flip catch
16:54:40 <jchee> Feuerbach: thanks
16:54:41 <ReinH> oh yeah
16:58:25 <blaenk> Twey: thanks
17:07:06 <d-snp_> does haskell have some nice syntactic sugar for working with maybe in do? it gets real ugly..
17:08:48 <davean> Maybe is a monad
17:08:49 <Hafydd> d-snp_: what's an example of such an ugly expression?
17:10:05 <shlevy> Suppose I have types A and B, a data Relationship = Relationship A B, and a finite Universe of As, Bs, and Relationships. Is there any way to verify at compile time that if the Universe has a Relationship a b, that it also has A a and B b?
17:10:28 <shachaf> What is Universe?
17:11:25 <shlevy> shachaf: A data type whose constructor takes a Set A, a Set B, and a Set Relationship (at least in essence if not exactly that)
17:12:58 <shachaf> Wait, what are A and B?
17:13:09 <shachaf> a :: A, so A :: A -> A?
17:13:12 <shlevy> Maybe a concrete example would be better :D
17:14:04 <d-snp_> Hafydd: I'm trying to get it to compile, just a sec :P
17:14:09 <schell> anyone ever have problems with hdevtools not finding modules?
17:14:10 <shlevy> OK, so I have Users constructed by user names, Groups constructed by group names, and a relationship "IsInGroup" constructed by a User and a Group.
17:14:53 <shlevy> I want to model a database of Users and Groups and the relationship between them, and ensure at compile time that if IsInGroup refers to some User u, u is in the database (idem for some Group g)
17:15:29 <ReinH> shlevy: at compile time? I would be surprised if you could.
17:15:33 <ReinH> But I am frequently surprised.
17:16:05 <shachaf> Well. You could have the database contain only the relationship, and then extract the users and groups from it as needed. So there's no separate notion of users and groups.
17:16:47 <ReinH> Well.
17:16:51 <shlevy> shachaf: Ah, but some users are not in any group
17:16:54 <shlevy> and some groups are empty
17:17:00 <Twey> You'd still have to deal with the database being modified after compile-time
17:17:14 <Twey> You could compile-time enforce a check
17:17:47 <shachaf> Twey: Well, the question is probably along the lines of "can i make a type such that you can't even have an inhabitant not satisfying my criteria"
17:17:52 <shachaf> shlevy: OK.
17:18:11 <shlevy> shachaf: Yes, that :)
17:18:15 <ReinH> Ok. now your universe is just Relationship (Maybe A) (Maybe B) ;)
17:18:36 <ReinH> where Relationship (Just User1) Nothing is a user without a group
17:18:47 <shachaf> Ew.
17:18:49 <Twey> ReinH: Eww
17:18:54 <ReinH> I'm not saying it's a good idea
17:18:56 <ReinH> At ALL
17:19:00 <ReinH> In fact I hate it
17:19:11 <shlevy> ReinH: And what if I have Relationship (Just u1) Nothing and Relationship (Just u1) (Just g1)? :)
17:19:14 <shlevy> what does that mean?
17:19:14 <ReinH> But that wasn't the question ;)
17:19:25 <ReinH> shlevy: that also wasn't the question :p
17:19:30 <shachaf> What?
17:19:34 <Twey> ReinH: Relationship A (Maybe B), at least
17:19:42 <d-snp_> so, it doesn't quite compile but it does parse: http://lpaste.net/98264
17:19:44 <ReinH> There's nothing to stop you from having Relationship a1 b1 and Relationship a1 b2 either
17:19:48 <shlevy> Lemme paste some psuedocode I mocked up after briefly browsing about data kinds
17:19:52 <shlevy> ReinH: But that is meaningful
17:19:58 <d-snp_> is there a prettier way? I guess case makes it ok
17:19:58 <shlevy> ReinH: A user can belong to multiple groups
17:20:20 <ReinH> Ok, well a user can be in the no group group and the group b group
17:20:24 <ReinH> deal with it
17:20:56 <ReinH> Nothing is the empty group, and group membership is the free Group moonid
17:21:00 <shlevy> Something like this http://lpaste.net/98265
17:21:01 <ReinH> it's beautiful and you're all wrong
17:21:13 <shachaf> sigh
17:21:22 <Twey> ReinH: But what does Relationship Nothing Nothing mean?  :þ
17:21:26 <ReinH> Twey: nothing!
17:21:28 <ReinH> it's brilliant!
17:21:51 <shachaf> Are you just being unhelpful on purpose?
17:22:04 * ReinH stops now
17:22:06 <shlevy> Except it gets ugly because then a Universe should be defined in terms of Sets of ExistentialA, ExistentialB, ExistentialRelationship over that very universe
17:22:12 <shachaf> I think I can think of types that can represent what you want but not very nice ones.
17:22:15 <shlevy> and by ugly I mean impossible :D
17:23:38 <shachaf> E.g. how about something like data Universe = forall (us :: Nat) (gs :: Nat). Universe (Vec us User) (Vec gs Group) (Set (Fin us, Fin gs))
17:23:43 <shachaf> I bet you could make a thing like that work.
17:24:25 <Twey> Wait, is this ‘database’ local to the program's memory?
17:24:28 <shlevy> What is Fin there?
17:24:41 <Twey> I assumed we had to think about external influences.
17:24:45 <shlevy> Twey: For now yes :)
17:24:58 <Hafydd> d-snp: I see; well, I don't know of any syntactic sugar you could use to make that nicer. It doesn't look too bad to me.
17:24:58 <shachaf> Fin n is the type of natural numbers smaller than n.
17:25:13 <shlevy> shachaf: Ah OK
17:25:15 <shlevy> indexing
17:25:23 <Twey> shlevy: Fin n is (isomorphic to) the natural numbers from 1 to n.  So Fin 0 is empty, Fin 1 has one inhabitant, Fin 2 has two inhabitants, &c.
17:26:21 <Jesin> How does one specify strictness of data fields when declaring a constructor using record syntax?
17:27:27 <geekosaur> data Foo = Foo { a :: !Int }
17:29:55 * hackagebot ipython-kernel 0.1.0.0 - A library for creating kernels for IPython frontends  http://hackage.haskell.org/package/ipython-kernel-0.1.0.0 (gibiansky)
17:30:10 <Jesin> geekosaur: yay, thanks
17:31:11 <Twey> d-snp: Purely syntactically, http://lpaste.net/98264
17:31:39 <Twey> (er, that topmost do is redundant, too)
17:34:40 <BMeph> Is Maybe (Fin 0) isomorphic to Fin 1? Specifically, can the compiler recognize it?
17:34:55 * hackagebot ihaskell 0.3.0.0 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.3.0.0 (gibiansky)
17:35:12 <copumpkin> BMeph: in what way would you expect the compiler to recognize it?
17:37:06 <jle`> perhaps as an old friend?
17:39:56 * hackagebot ihaskell-aeson 0.1.0.0 - IHaskell display instances for Aeson  http://hackage.haskell.org/package/ihaskell-aeson-0.1.0.0 (gibiansky)
17:39:58 * hackagebot ihaskell-display 0.1.0.0 - IHaskell display instances for basic types  http://hackage.haskell.org/package/ihaskell-display-0.1.0.0 (gibiansky)
17:40:00 * hackagebot ihaskell-blaze 0.1.0.0 - IHaskell display instances for blaze-html types  http://hackage.haskell.org/package/ihaskell-blaze-0.1.0.0 (gibiansky)
17:40:02 * hackagebot ihaskell-charts 0.1.0.0 - IHaskell display instances for charts types  http://hackage.haskell.org/package/ihaskell-charts-0.1.0.0 (gibiansky)
17:40:04 * hackagebot ihaskell-diagrams 0.1.0.0 - IHaskell display instances for diagram types  http://hackage.haskell.org/package/ihaskell-diagrams-0.1.0.0 (gibiansky)
17:45:06 * hackagebot ihaskell-magic 0.1.0.0 - IHaskell display instances for bytestrings  http://hackage.haskell.org/package/ihaskell-magic-0.1.0.0 (gibiansky)
17:45:41 <joneshf-laptop> to bring back up what i was talking about earlier, why also no inverses?
17:45:50 <jonkri> Is there a function to count the number of elements in a list like this: Eq a => [a] -> [(a, Integer)]?
17:46:08 <jonkri> Like [1, 1, 2, 3] would become [(1, 2), (2, 1), (3, 1)].
17:46:12 <nisstyre> jonkri: zip xs [1..] ?
17:46:15 <joneshf-laptop> :hoogle  Eq a => [a] -> [(a, Integer)]
17:46:24 <joneshf-laptop> oh that doesn't work :X
17:46:32 <nisstyre> > zip "abcde" [1..]
17:46:33 <lambdabot>  [('a',1),('b',2),('c',3),('d',4),('e',5)]
17:46:59 <nisstyre> oh wait
17:47:07 <nisstyre> you want it to count the frequencies?
17:47:08 <S11001001> jonkri: foldMap (\n -> M.singleton (n, Sum 1)), give or take some uncurrying or whatever
17:47:12 <jonkri> nisstyre: Yes.
17:47:30 <koala_man> > map (\x -> (head x, length x)) $ groupBy (==) [1,1,1,1,2,2,3]
17:47:31 <lambdabot>  [(1,4),(2,2),(3,1)]
17:47:38 <nisstyre> yeah, use groupBy
17:47:47 <jle`> there's also that Data.Map.fromList
17:47:53 <koala_man> well, groupBy (==) is the same as group
17:48:09 <jonkri> > map (\x -> (head x, length x)) $ groupBy (==) [1,3,1,1,1,2,2]
17:48:09 <liyang> Yeah but what do you want [1,1,2,3,1,1] to give?
17:48:10 <lambdabot>  [(1,1),(3,1),(1,3),(2,2)]
17:48:18 <nisstyre> you should sort it as well I think
17:48:22 <jle`> nevermind it's nto fromList
17:48:42 <jonkri> I guess I could sort them before using that. :)
17:48:42 <jle`> it's insertWith
17:48:52 <koala_man> surely there's a better way
17:49:00 <jonkri> > map (\x -> (head x, length x)) $ groupBy (==) $ sort [1,3,1,1,1,2,2]
17:49:01 <lambdabot>  [(1,4),(2,2),(3,1)]
17:49:34 <jonkri> Thanks, S11001001!
17:50:19 <S11001001> jonkri: well, that needs Ord.  But maybe that's ok.
17:50:23 <Hafydd> @pl \x -> (head x, length x)
17:50:24 <lambdabot> liftM2 (,) head length
17:50:29 <joneshf-laptop> > map (head &&& length) . groupBy (==) $ sort [1,2,1,1,1,3,2,4]
17:50:30 <lambdabot>  [(1,4),(2,2),(3,1),(4,1)]
17:50:40 <nisstyre> there is a better way, use a map
17:50:42 <Hafydd> That was it.
17:50:45 <nisstyre> as in a dictionary
17:50:55 <jle`> here
17:50:56 <S11001001> nisstyre: that's what the fun I wrote above uses
17:51:09 <jle`> > foldl' (M.insertWith (+1) 1) M.empty [1,3,1,1,2,2]
17:51:10 <lambdabot>  Couldn't match type `Data.Map.Base.Map k0 a0'
17:51:10 <lambdabot>                with `Data.Map.Base.Map k0 a0 -> Data.Map.Base.Map k0 a0'
17:51:10 <lambdabot>  Expected type: Data.Map.Base.Map k0 a0
17:51:10 <lambdabot>                 -> Data.Map.Base.Map k0 a0 -> Data.Map.Base.Map k0 a0
17:51:11 <lambdabot>    Actual type: Data.Map.Base.Map k0 a0 -> Data.Map.Base.Map k0 a0
17:51:21 <jle`> > foldl' (Data.Map.insertWith (+1) 1) Data.Map.empty [1,3,1,1,2,2]
17:51:23 <nisstyre> S11001001: ah yeah, that's clever
17:51:25 <lambdabot>  Not in scope: `Data.Map.insertWith'Not in scope: `Data.Map.empty'
17:51:32 <jle`> :'(
17:51:36 <koala_man> > toList $ fromListWith (+) $ flip zip [1,1..] $ [1,1,3,1,2,1,1]
17:51:36 <joneshf-laptop> yeah isn't ... jle` there it is
17:51:37 <lambdabot>  Not in scope: `toList'
17:51:37 <lambdabot>  Perhaps you meant one of these:
17:51:37 <lambdabot>    `F.toList' (imported from Data.Foldable),
17:51:37 <lambdabot>    `IS.toList' (imported from Data.IntSet),
17:51:37 <lambdabot>    `S.toList' (imported from Data.Set)Not in scope: `fromListWith'
17:51:45 <koala_man> > M.toList $ fromListWith (+) $ flip zip [1,1..] $ [1,1,3,1,2,1,1]
17:51:46 <lambdabot>  Not in scope: `fromListWith'
17:51:46 <lambdabot>  Perhaps you meant one of these:
17:51:46 <lambdabot>    `IM.fromListWith' (imported from Data.IntMap),
17:51:46 <lambdabot>    `M.fromListWith' (imported from Data.Map),
17:51:47 <lambdabot>    `IM.fromAscListWith' (imported from Data.IntMap)
17:52:06 <koala_man> > M.toList $ M.fromListWith (+) $ flip zip [1,1..] $ [1,1,3,1,2,1,1]
17:52:07 <lambdabot>  [(1,5),(2,1),(3,1)]
17:52:31 <joneshf-laptop> isn't there insertWith?
17:52:33 <joneshf-laptop> :t insertWith
17:52:34 <lambdabot>     Not in scope: `insertWith'
17:52:34 <lambdabot>     Perhaps you meant one of these:
17:52:34 <lambdabot>       `IM.insertWith' (imported from Data.IntMap),
17:52:38 <joneshf-laptop> :t M.insertWith
17:52:39 <lambdabot> Ord k => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
17:53:07 <joneshf-laptop> ugh, that's not what i was expecting
17:53:28 <jle`> it's there in :t but not in > for some reason
17:53:49 <frxx> @src groupBy
17:53:49 <lambdabot> groupBy _  []       =  []
17:53:49 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
17:53:49 <lambdabot>     where (ys,zs) = span (eq x) xs
17:53:57 <frxx> @src group
17:53:58 <lambdabot> group = groupBy (==)
17:54:32 <joneshf-laptop> :t Data.Map.Base.Map
17:54:33 <lambdabot> Couldn't find qualified module.
17:54:36 <joneshf-laptop> :t Data.Map
17:54:37 <lambdabot> Couldn't find qualified module.
17:54:42 <geekosaur> joneshf-laptop, Data.Map has too many collisions with Data.List and Prelude, and is imported qualified
17:54:44 <joneshf-laptop> who knows
17:55:25 <Twey> Hey, anybody know what happened to Neil Mitchell's Supero?
17:55:44 <geekosaur> and there is no constructor Map so :t wouldn't work anyway
17:56:07 <geekosaur> (the actual constructors for the Map type are hidden, because you could violate necessary invariants if you had access to them)
17:58:42 <ReinH> byorgey: did anything ever happen to http://byorgey.wordpress.com/2011/05/27/bit-rotted-text-adventure-edsl-free-to-a-good-home/ ?
18:00:22 <jle`> > foldl (\m x -> M.insertWith (+) x 1 acc) M.empty [1,1,3,1,2,1,1]
18:00:23 <lambdabot>  Not in scope: `acc'
18:00:23 <lambdabot>  Perhaps you meant one of these:
18:00:23 <lambdabot>    `act' (imported from Control.Lens),
18:00:23 <lambdabot>    `bcc' (imported from Data.Graph), `scc' (imported from Data.Graph)
18:00:47 <jle`> > foldl (\m x -> M.insertWith (+) x 1 m) M.empty [1,1,3,1,2,1,1]
18:00:48 <lambdabot>  fromList [(1,5),(2,1),(3,1)]
18:00:53 <jle`> apologies.
18:01:28 <jle`> -- jonkri , but you'll have to call M.fromList at the end to get it back to a list.  Usually though you don't really want a List for things like this.
18:04:55 <copumpkin> I wish haddock would have source links for typeclass instances
18:04:58 <copumpkin> they're hard to find otherwise
18:05:04 * hackagebot hemokit 0.6.0 - Haskell port of the Emokit EEG project  http://hackage.haskell.org/package/hemokit-0.6.0 (NiklasHambuechen)
18:05:06 * hackagebot hidapi 0.1.2 - Haskell bindings to HIDAPI  http://hackage.haskell.org/package/hidapi-0.1.2 (NiklasHambuechen)
18:05:11 <startling> why is Data.Functor.Foldable.Foldable named Foldable?
18:05:43 <c_wraith> I'm confused by that question
18:06:00 <startling> Why pick a name that conflicts with Data.Foldable.Foldable (which is in base)?
18:06:22 <c_wraith> Oh.  I missed the extra module names
18:08:56 <jonkri> Thanks jle`. :)
18:11:13 <startling> what should I call data X a = Product (NonEmpty a) | Sum (NonEmpty a) | Empty?
18:11:33 <startling> (It's for representing datatypes)
18:11:56 <startling> (I'm using Datatype as newtype Datatype = Datatype (Fix X)
18:16:17 <startling> edwardk: do you have a reason for the Foldable name conflict in recursion-schemes?
18:19:46 <brokenzebra> in, "getAuth Config{..} = ... ", what does the "{..}" refer to?
18:20:37 <startling> brokenzebra, Config has some arguments but getAuth doesn't care about them.
18:21:02 <startling> brokenzebra: it's like (Config _ ...) for however many arguments Config takes
18:21:12 <brokenzebra> startling: so how's it different from, "getAuth _"? especially if data Config has only one constructor?
18:21:26 <startling> brokenzebra, it's not, if Config only has one constructor.
18:21:30 <jle`> um that's {}
18:21:44 <geekosaur> um, isn't that {} ? I think {..} is RecordWildcards and you should get all the fields locally bound?
18:21:45 <jle`> {..} is when it pulls in the record fields as methods
18:21:51 <jle`> record wildcards
18:21:53 <startling> oh, oops.
18:22:03 <brokenzebra> well at least i have a google-able name now
18:23:18 <jle`> so if you had First { getFirst = Just 5 }, if you use First{..}, it'll introduce a local value getFirst = Just 5, shadowing the outside getFirst (:: First a -> Maybe a)
18:23:40 <jle`> it's kinda wonky
18:25:34 <rasfar> startling: how about "Representation"?
18:31:41 <nstdloop> @paste
18:31:41 <lambdabot> Haskell pastebin: http://lpaste.net/
18:36:04 <nstdloop> Can anyone help me debug this really easy error
18:36:05 <nstdloop> http://lpaste.net/98268
18:36:14 <nstdloop> I'm just getting a parse error on this line and just can't figure it out
18:37:07 <Hafydd> How do you know it's really easy if you can't solve it?
18:37:16 <nstdloop> It's a parse error
18:37:22 <nstdloop> so I assume it's not that complicated
18:37:27 <nstdloop> I'm just doing something silly
18:37:44 <geekosaur> what/where is the actual error?
18:37:54 <geekosaur> oh wait I see the commentnow
18:37:57 <nstdloop> parse error on line 24
18:38:07 <geekosaur> G.game seems wrong
18:38:12 <geekosaur> G.Game?
18:38:26 <nstdloop> No
18:38:27 <nstdloop> what
18:38:29 <nstdloop> *facepalm*
18:38:30 <nstdloop> what
18:38:37 <Hafydd> Okay, I agree it was easy.
18:38:39 <nstdloop> I've been staring at this for way too long
18:42:13 <berserker_> > let x = 1 : x in x
18:42:14 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:43:04 <chrisdone> this is cool for newbies: http://chrisdone.com/tryhaskell-progressive-types.png
18:43:08 <geekosaur> to be fair, while ghc is pretty good at type errors and such, often it gives you no help whatsoever on parse errors
18:43:29 <geekosaur> that one really should be reported as "bad type" or something, not just as "parse error"
18:44:06 <nstdloop> Really I should have spotted that. I just haven't slept in a while.
18:44:10 <ion> chrisdone: neat
18:44:24 <berserker_> > let x = 2 : map ((*2) . (\x -> x - 6)) x
18:44:25 <lambdabot>  not an expression: `let x = 2 : map ((*2) . (\x -> x - 6)) x'
18:45:08 * hackagebot spsa 0.1.0.0 - Simultaneous Perturbation Stochastic Approximation Optimization Algorithm  http://hackage.haskell.org/package/spsa-0.1.0.0 (yanatan16)
18:45:46 <chrisdone> > length
18:45:47 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
18:45:47 <lambdabot>    arising from a use of `M285146911146786750227682.show_M2851469111467867502...
18:45:47 <lambdabot>  The type variable `a0' is ambiguous
18:45:47 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
18:45:47 <lambdabot>  Note: there are several potential instances:
18:45:55 <berserker_> > let x = 1: map ((*2).(\x -> x-5)) x in x
18:45:56 <lambdabot>  [1,-8,-26,-62,-134,-278,-566,-1142,-2294,-4598,-9206,-18422,-36854,-73718,-1...
18:46:12 <chrisdone> ^ yeah, that -- i got around it by not trying to eval the value
18:46:31 <Twey> chrisdone: Is this just :t ?
18:46:31 <chrisdone> so if > length fails, it instead tries :t length
18:46:37 <berserker_> > 2^10
18:46:38 <lambdabot>  1024
18:47:18 <Twey> Oh, I see
18:47:45 <chrisdone> twey: yeah, implicit. but fixed so it doesn't barf on ambiguous types. be nice to get this in lambdabot
18:47:55 <Twey> Or GHC
18:48:04 <Twey> (i)
18:48:16 <berserker_> > let x = 1: map (^2) x in x
18:48:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:48:19 <Twey> Would be much nicer to show the type instead of giving a ‘no instance of Show’ error when something isn't Show
18:48:25 <chrisdone> yeah, i think i never really want to see "no instance for show", ever
18:49:42 <berserker_> > let x=x in x
18:49:45 <lambdabot>  mueval-core: Time limit exceeded
18:50:23 <chrisdone> my love for you is like a truck, berserker_!
18:50:28 <berserker_> > let x = 1: map (*2) x in x
18:50:29 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:50:41 <chrisdone> would you like some making functor, berserker_!
18:51:30 <berserker_> > map (2^) [0..]
18:51:31 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:53:11 <berserker_> > let x = 1:map (*2) x in x==(map (2^) [0..])
18:53:15 <lambdabot>  mueval-core: Time limit exceeded
18:53:36 <berserker_> Why does my equality not work?
18:54:02 <triliyn> berserker_: it tries to compare the lists elementwise
18:54:03 <hakujin> writing haskell bindings to the neo4j graph database. assuming every api command returns an Either Neo4jError a, if you guys were library users would you want to have the functions alredy wrapped up in an EitherT? or leave that to the users to determine which errors they care about?
18:54:05 <triliyn> And it never finishes
18:54:33 <hakujin> already*
18:54:42 <triliyn> > let x = 1 : map (*2) x; y = map (2^) [0..] in take 20 x == take 20 y
18:54:43 <lambdabot>  True
18:55:13 <triliyn> But you can't compare the entire lists, because even though they happen to be equal, the program can never be sure because there are always more elements
18:57:10 <berserker_> triliyn: Do I need a computer algebra system with symbolic math to do such things?
18:57:39 <startling> berserker_, something like that.
18:57:42 <geekosaur> pretty much, yes.
18:59:02 <nstdloop> So I've got this playTurns function, which takes a game and keeps playing more turns until playTurn returns a Left
18:59:08 <nstdloop> Which makes sense.
18:59:15 <nstdloop> The problem is that I want playTurn to do a lot of IO
18:59:32 <nstdloop> which would mean it would have to return an IO value
18:59:43 <nstdloop> ... right?
18:59:45 <hakujin> yep
18:59:57 <nstdloop> I'm having trouble seeing how I should structure this
19:00:07 <Twey> chrisdone: Fuuzetsu objects to the irregular behaviour and would rather it wrote ‘maybe 5 (+ 2) :: Num b => Maybe b -> b’ when it can't show, for consistency
19:00:39 <startling> berserker_, you could write an AST defining a small number of operations which you want to look at.
19:00:51 <hakujin> nstdloop: sounds like you want IO (Either something something) correct?
19:00:58 <nstdloop> Yes
19:01:02 <nstdloop> But how do I pattern match to that
19:01:08 <nstdloop> in playTurns
19:01:12 <startling> you don't.
19:01:22 <startling> you can pattern-bind on it though.
19:01:46 <nstdloop> can I just do
19:01:49 <startling> e.g. "(Left a) <- whatever" in do notation or "whatever >>= \(Left a) -> ..." otherwise.
19:01:58 <nstdloop> ptResult <- playTurn game
19:02:04 <nstdloop> then match on ptResult?
19:02:22 <startling> nstdloop, you can do "case" on ptResult, yeah
19:02:36 <berserker_> > map (2^) [0..]
19:02:37 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
19:03:18 <berserker_> foldl (^) [1..5]
19:03:34 <berserker_> > foldl (^) [1..5]
19:03:35 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
19:03:35 <lambdabot>    arising from a use of `M161690869519631410027848.show_M1616908695196314100...
19:03:35 <lambdabot>  The type variable `t0' is ambiguous
19:03:35 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:03:35 <lambdabot>  Note: there are several potential instances:
19:04:31 <berserker_> > map (^2) [0..]
19:04:33 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
19:04:57 <berserker_> > sum [2,3]
19:04:58 <lambdabot>  5
19:05:26 <startling> :t (^)
19:05:27 <lambdabot> (Integral b, Num a) => a -> b -> a
19:05:49 <berserker_> > sum (map ((1/).(^2) [1..12])
19:05:49 <lambdabot>  <hint>:1:29:
19:05:50 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
19:06:50 <berserker_> > sum (map ((1/).(2^)) [1..16])
19:06:51 <lambdabot>  0.9999847412109375
19:07:13 <berserker_> What does this evaluate to:
19:07:43 <berserker_> > sum (map ((1/).(2^)) [1..])
19:07:47 <lambdabot>  mueval-core: Time limit exceeded
19:08:09 <srhb> berserker_: sum essentially folds the list with a strict operator.
19:08:37 <berserker_> What does the above expression evaluate to?
19:08:47 <rhodesd-alt> 2, I think
19:08:51 <srhb> berserker_: bottom, undefined,...
19:09:41 <monochrom> it is not supposed to give any answer
19:10:21 <berserker_> monochrome: the answer is 1
19:10:53 <monochrom> a theorem prover can give that answer. a haskell executor cannot.
19:11:06 <monochrom> haskell is not a computer algebra system
19:11:07 <BMeph> berserker_: The answer can't be 1, because the first term of the sum is 1, and the terms are never negative.
19:11:20 <ion> Depends on how the type implements Enum. :-P
19:11:48 <ion> > 1/2^1
19:11:50 <lambdabot>  0.5
19:11:55 <BMeph> Oh, wait, you flipped the 2 on the exponent... tricksy hobbitses. Yes, it's 1.
19:12:42 <monochrom> first illusion for math fans who stumble on haskell: the syntax looks so much like math, they think the semantics is also omnipotent omniscience math
19:13:00 <monochrom> and the first disillusionment: haskell is just a programming language
19:13:09 <ion> > sum . map (\x -> 1/2^fromIntegral x) $ [1 :: Word8 ..]
19:13:10 <lambdabot>  1.0
19:13:40 <monochrom> it is not even Mathematica
19:16:17 <chrisdone> monochrom: programming languages, the great levellers
19:16:50 <bb010g> Are there any good tutorials for using Servers in pipes?
19:21:22 <tertl3> anyone tried Ihaskell notebooks?
19:23:44 <tertl3> im installing it now
19:25:13 * hackagebot swish 0.9.0.12 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.9.0.12 (DouglasBurke)
19:31:17 <dmwit> The correct, unhelpful answers is "it depends". The helpful answer is "the thought process that led to that question was screwed up".
19:32:26 <dmwit> Luckily, here at #haskell, we gave both answers!
19:32:28 <dmwit> yaaaay
19:32:36 <bb010g> dmwit: Whom was that for? tertl3, me, or monochrom?
19:33:11 <dmwit> berserker_
19:34:20 <Cale> hehe
19:34:31 <Cale> > product [1,1..]
19:34:35 <lambdabot>  mueval-core: Time limit exceeded
19:34:42 <Cale> Why won't it finish??? :)
19:35:03 <triliyn> > fix (return . product)
19:35:07 <lambdabot>  mueval-core: Time limit exceeded
19:35:09 <Cale> (I have been guilty of doing that by accident, albeit in a much more obscure form)
19:35:39 <danil> Question for edwardk (or anyone else familiar with Bound): is it ever reasonable to use `Scope b f a` for non-monad f?  I'm representing what is basically "polytype = monotype | forall (a < polytype). polytype" and wondering how (or if) I can make use of Bound.
19:35:51 <tertl3> bb010g, anyone
19:36:07 <edwardk> danil: never tried. let me know how it works out
19:36:20 <tertl3> dependancy issues atm :\
19:36:28 <edwardk> you can use basic substitution-for-vars with that, if not the monad
19:38:05 <JakeE> question: I have a system for preety printing types (basiclly haskell types) and I wonder, what varibles are generally used to display polymorphic values? I have 'a', 'b', 'c', and 't' but I wonder if it wouldn't be better to have more
19:38:34 <dmwit> The more polymorphic a thing is, th shorter its name should be.
19:38:36 <tertl3> the ole dependancy hades
19:38:52 <dmwit> However, I feel obligated to suggest
19:39:00 <dmwit> ?hackage ipprint
19:39:01 <lambdabot> http://hackage.haskell.org/package/ipprint
19:39:02 <danil> edwardk: yeah, I got a Bound instance with only a little finagling (necessitated by Functor not being a superclass of Monad) but I'm not sure if I can get the quotiented Eq/Ord instances in any reasonable way
19:39:34 <JakeE> ya I would use a preety printing system except this is for fun
19:39:57 <dmwit> right =)
19:40:00 <edwardk> yeah there i don't think it'll do you much good
19:40:12 <dmwit> pprinting is very fun, tackled it many times myself
19:41:16 <tertl3> omg its twerking
19:41:29 <rasfar> got lots of reading for when offline, but if anyone can give me a hint how to find out what "THUNK_1_0" and friends mean in my hp2ps profiles, I'd owe you one...
19:41:31 <JakeE> also this isn't about formating; it's about printing a type discribed with De Bruijn indices into somthing more humen readable
19:41:53 <rasfar> (not what it means so much as how to locate it in the source code)
19:41:54 <JakeE> and so all I really need to know is what varibles to replace the numbers with
19:42:57 <JakeE> right now my system uses a then b then c then t and then it starts over with a1, b1, c1, t1, etc... to however many you need
19:45:06 <rasfar> I guess it could be stack? since ghc-prim:GHC.Types.: is not far down
19:45:30 <rasfar> but there's three kinds of "THUNK_*" which very much are dominating
19:46:38 <rasfar> suppose it would be silly to look at the core, since these are run-time internal identifiers they won't appear there
19:47:44 <ReinH> edwardk: What kind of algorithm construction is Bird's Sudoku solver? What's the term for that style of "program derivation"? Constructive algorithms?
19:48:17 <ReinH> It's the one where he generates a list of all possible solutions using sequence w/ [] monad and then adds pruning and such
19:49:07 <rasfar> oh well
19:49:08 <ReinH> Also his Functional Pearls book
19:51:41 <rasfar> it seems like there ought to be some documentation covering these identifiers that arise, there's scads of them -- it's comparatively rare to see something familiar using -xd
19:52:44 <danil> rasfar: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Thunks might help
19:53:56 <rasfar> thanks danil, i'll be sure to get that open for offline
19:55:24 <danil> THUNK_0_1 appears to be a thunk closing over a single non-pointer variable
19:56:18 <rasfar> i have a feeling i'm finally going to (begin to) learn what "thunk" and "closure" really mean
19:56:46 <rasfar> that looks to be a great resource, thanks again
19:58:41 <startling> "closure" is kind of a bad word.
20:00:39 <JakeE> agreed; it was at the heart of much of my suffering when first learning about lambda functions
20:01:10 <lispy> ReinH: I thought the term was program derivation. And that you say that you calculate programs.
20:02:01 <JakeE> also it seems to not have just one meaning. example "transitive closure" "reflexive closure" and "transitive reflexive closure" talk about somthing diffrent
20:02:35 <JakeE> also there is some "closure" word for matrices (which as I understand it comes from the idea that matrices are functions from vectors to vectors)
20:02:53 <lispy> matrices are not functions
20:03:06 <lispy> linear transformations are functions that can be encoded using matrices (among other encodings)
20:03:07 <startling> JakeE: yeah, that's a different sense of "closed".
20:03:09 <JakeE> no but they are sometimes thought of as "linear transformatioons"
20:03:47 <dolio> "Closure" is a fine word. It's just not fine for what many people use it for.
20:03:48 <JakeE> lispy: ya that is a better way to put it
20:05:05 <JakeE> can all linear transformations be encoded as matrices or just some?
20:05:17 * hackagebot http-common 0.7.1.1 - Common types for HTTP clients and servers  http://hackage.haskell.org/package/http-common-0.7.1.1 (AndrewCowie)
20:06:21 <triliyn> All linear transformations can
20:06:29 <danil> in finite-dimensional vector spaces they can be
20:06:36 <triliyn> (And nothing other than linear transformations)
20:07:07 <JakeE> so F is a linear transformation if and only if it can be encoded in a matrix? that's preety neat actully
20:07:47 <triliyn> Yeah
20:07:48 <Cale> You have to fix a basis for the vector spaces involved though
20:07:48 <c_wraith> it's a pretty straight-forward result in linear algebra
20:08:01 <JakeE> I rather hope that gives me a leg up in matrix theory next semester. as I understand it matrix multipication is compostion
20:08:20 <JakeE> "fix a basis" what does that mean?
20:08:32 <c_wraith> informally, "give it a proper coordinate system"
20:08:35 <johnw> choose a basis set for the vector space
20:08:41 <Cale> If T: V -> W is a linear transformation, and you have {b_1,...,b_n} is a basis for V, and {c_1,...,c_m} is a basis for W, then the first thing you should note is that
20:09:29 <Cale> since any v in V can be written uniquely as a_1 b_1 + ... + a_n b_n, and since T is linear, we have T(v) = T(a_1 b_1 + ... + a_n b_n) = a_1 T(b_1) + ... + a_n T(b_n)
20:09:32 <c_wraith> a basis for a linear space is a set of orthonormal vectors that span it.
20:09:57 <Cale> This means that once we know what T(b_1), ..., T(b_n) are, we know what T does to every vector in V.
20:10:02 <c_wraith> that is, you can describe any point in the space as a linear combination of the vectors
20:10:07 <Cale> So, the question just becomes how to encode those
20:10:12 <c_wraith> so, informally - a coordinate system.
20:10:18 * hackagebot http-streams 0.7.1.1 - An HTTP client using io-streams  http://hackage.haskell.org/package/http-streams-0.7.1.1 (AndrewCowie)
20:10:20 <lispy> algebra is so elegant like that
20:10:20 * hackagebot purescript 0.2.9 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.9 (PhilFreeman)
20:10:31 <Cale> I'm not taking bases to be orthonormal
20:10:39 <Cale> Just linearly independent is all you need
20:10:57 <c_wraith> It's all you need, but orthonormal makes them nicer to work with.
20:10:58 <Cale> (and spanning)
20:11:22 <Cale> In order to say what orthonormal means, you need an inner product, and it's not always easy to provide a good one
20:12:04 <c_wraith> I suppose that's true when you get outside of R^n spaces
20:12:19 <JakeE> "{b_1,...,b_n} is a basis for V" means that elements of V are in {b_1,...,b_n}?
20:12:58 <c_wraith> it means that each of those values is in V, they are linearly independent, and all points in V are linear combinations of them
20:12:59 <Cale> anyway, if we focus on some T(b_i), we know this is some vector in W, and so we can write it uniquely as the linear combination T(b_i) = A_1i c_1 + A_2i c_2 + ... + A_mi c_m
20:13:45 <JakeE> whoops I mess up my terminoly
20:14:18 <triliyn> Every finite-dimensional vector space is isomorphic to R^n, isn't it?
20:14:20 <JakeE> I meant to ask: "{b_1,...,b_n} is a basis for V" for all x in V the elements of x are in {b_1,...,b_n}?
20:14:29 <Cale> JakeE: It means that 1) b_1,...,b_n are linearly independent, i.e. that whenever a_1 b_1 + ... + a_n b_n = 0, then a_1,...,a_n are all equal to 0
20:15:08 <Cale> and 2) that they span the space, i.e. for every v in V, there is some bunch of coefficients a_1,...,a_n such that a_1 b_1 + ... + a_n b_n = v
20:15:34 <JakeE> Cale: got it! thanks
20:15:58 <Cale> If we wanted to talk about infinite dimensional vector spaces, these would have to be adjusted slightly -- we'd be taking some finite subset of the basis in any case (infinite sums don't mean anything until you put some extra structure in to be able to define them after all)
20:16:28 <Cale> triliyn: Every finite dimensional vector space over R
20:16:41 <triliyn> ahhh, right, makes sense
20:17:03 <JakeE> so I'm guessing the whole linear transformation thing ties in with abstract algebra quite a lot too?
20:18:17 <Cale> JakeE: Yeah, linear transformations are the functions between vector spaces which preserve the operations we care about, that is, they preserve vector addition: T(v + w) = T(v) + T(w) (for any vectors v and w), and they preserve scalar multiplication T(a*v) = a*T(v) (for any scalar a and vector v)
20:18:37 <lispy> aka homomorphisms
20:18:58 <Cale> Throughout mathematics, and especially in abstract algebra, we tend to care very much about the mappings between structures which preserve certain operations or structure that we care about.
20:19:34 <JakeE> ya. I'm very intrested in abstract algebra but I can't take it until next next semester
20:19:54 <johnw> nice, I wish I were back in Uni waiting to take an abstract alg course
20:19:58 <JakeE> I tried teaching it to my self but I apprently wasn't intrested enoghe to keep at it lol
20:20:14 <johnw> it helps to paly with the ideas in Haskell
20:20:17 <Cale> It becomes both an expression of what's important about the things we're studying and what features of examples are (at least presently) irrelevant to us, as well as a way to relate structures to each other so that we can solve more complicated problems by understanding a bunch of smaller ones.
20:20:25 <johnw> otherwise it can get a bit dry and detail-overwhelming
20:21:12 <JakeE> I got to groups, group isomorphisms (and homomorphisms), and a bit with subgroups. I havn't touched on rings or anything like that
20:21:44 <Cale> So yeah, just like with linear transformations (vector space homomorphisms), you have group homomorphisms and ring homomorphisms and field homomorphisms.
20:21:52 <bobajett> speaking of math :-) Im trying to write a primitive (primitive as in basic) function isSet [given a list of unique numbers] => True
20:21:59 <Cale> And then in analysis, you have topological spaces and continuous functions between them.
20:22:11 <Cale> As well as metric spaces and contraction mappings.
20:22:24 <JakeE> bobajett: sort it and make sure that subsequent items are not equal
20:22:24 <Cale> (and many other examples like that)
20:22:35 <bobajett> I have: isSet [] = True; isSet (x:xs) = if x `elem` xs then False else isSet xs
20:22:50 <Cale> bobajett: That'd work
20:22:55 <bobajett> which works, except when I try to do isSet []
20:23:07 <JakeE> if you want to use equality use isSet xs = xs == nub xs
20:23:10 <bobajett> I get     The type variable `a0' is ambiguous
20:23:51 <Cale> bobajett: ah, that's because it doesn't know what type of list you want. I would expect that GHCi's defaulting should sort that out for you, but if not, give an explicit type signature to the list, and it should work
20:23:53 <JakeE> but if you are ok with Ord then isSet xs = fold (/=) (sort xs) is way better
20:23:56 <Cale> isSet ([] :: [Integer])
20:24:14 <joey_> Does anybody know of a good code-formatter for Haskell? I've got code and the indentation is correct but messy, I'd like to clean it up automatically. Is there such a tool?
20:24:36 <Cale> JakeE: er, I don't think that means anything like what you want it to mean
20:24:52 <Cale> joey_: That's tricky because indentation is meaningful
20:25:04 <JakeE> Cale: did I mess up? if so how so
20:25:36 <bobajett> Cale: what does this mean? "I would expect that GHCI's defaulting should sort that out for you". When I load the file in GHCi that's when I get this error.
20:25:37 <JakeE> wiat ya that is all kinds of messed up
20:25:46 <JakeE> give me a sec
20:26:18 <Cale> JakeE: Well, whether by fold you mean foldr or foldl, one of the arguments to the function given to the fold will be an element of the list, and the other will be the same type as the result of that function
20:26:22 <Cale> :t foldr
20:26:22 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:26:25 <Cale> :t foldr (/=)
20:26:26 <lambdabot> Bool -> [Bool] -> Bool
20:26:39 <joey_> @Cale: but couldn't it clean it up, assuming the initial indentation/nesting was correct? I'm mostly just looking to have standardized indenting. A program could figure out the proper nesting from the current indenting, and then just clean up the style.
20:26:39 <lambdabot> Unknown command, try @list
20:26:47 <Cale> This will only work on lists of boolean values, and it will essentially be taking the xor of the values.
20:26:52 <joey_> Cale: but couldn't it clean it up, assuming the initial indentation/nesting was correct? I'm mostly just looking to have standardized indenting. A program could figure out the proper nesting from the current indenting, and then just clean up the style.
20:27:03 <Cale> joey_: Yeah, I suppose it's possible
20:27:20 <JakeE> Cale: ya; I'll fix it here in a sec
20:27:27 <Cale> joey_: One thing which I've done before is used haskell-src-exts to read in a bunch of source, and then spit it back out
20:28:11 <Cale> JakeE: I think perhaps you were thinking of something like  let ys = sort xs in (map head . group) ys == ys
20:28:37 <joey_> I'll take a look at that, thanks!
20:28:47 <Cale> joey_: How bad are we talking about?
20:29:42 <JakeE> Cale ya that does what I was thinking of
20:30:24 <JakeE> n*lg n better than n^2 by a lot
20:30:53 <joey_> Not terribly bad, I'm just looking at releasing a librar and I want it to be pretty
20:32:08 <jle`> is there any sort of comprehensive comparison of the different frp libraries?
20:33:30 <JakeE> Cale: sense I dislike 'head' I have a less efficent version based on yours: group (sort xs) == map (\x -> [x]) xs
20:33:48 <Cale> JakeE: That doesn't work.
20:33:54 <JakeE> why not?
20:33:55 <Cale> (It doesn't typecheck)
20:34:06 <JakeE> meh I need to use ghci before I saw stuff lol
20:34:15 <Cale> Also note that head is safe when applied to the elements of the result of group
20:34:41 <Cale> The result of group is a list of nonempty lists of adjacent equal elements
20:34:45 <joelteon> yeah, group could be Eq a => [a] -> [NonEmpty a]
20:34:45 <triliyn> :t group . sort
20:34:46 <lambdabot> Ord a => [a] -> [[a]]
20:34:48 <joelteon> but NonEmpty isn't part of Prelude
20:36:03 <JakeE> if we had dependent typeing it would be Eq a => Vec a (Fin 0) -> Vec a (Fin 1)
20:36:09 <Cale> JakeE: Also, even in the case where the list is a set, you want to be comparing the sorted lists
20:36:47 <Cale> Uh... not Fin
20:36:51 <Cale> also not Vec
20:36:52 <Cale> heh
20:37:43 <JakeE> ok some type that means greater than. what about Vec though?
20:38:04 <JakeE> Vec to me just means list with depdently type size
20:38:20 <Cale> Yeah, that's something with a fixed natural number size
20:38:21 <Twey> JakeE: I think you mean Vec (S n) a → a
20:38:37 <Twey> Which is acceptable in modern Haskell
20:38:44 <bobajett> still trying to understand my isSet problem ... is the issue that isSet expects its list to be of class Eq? Why can't I do something like: empty_Eq_able_list :: (Eq a) => [a]; empty_Eq_able_list = []; isSet empty_Eq_able_list. GHCi doesn't like this either :-)
20:39:02 <tertl3> > putStrLn "hello pls"
20:39:03 <lambdabot>  <IO ()>
20:39:04 <Cale> bobajett: It needs to know which Eq instance to supply
20:39:14 <bobajett> Cale: ah ok.
20:39:22 <bobajett> Cale: makes sense now. thanks
20:40:03 <Cale> bobajett: empty_Eq_able_list is secretly also a function of that instance
20:40:22 * hackagebot melody 0.2 - A functional scripting language  http://hackage.haskell.org/package/melody-0.2 (jozefg)
20:40:44 <Cale> *Eventually* the types have to be determined somewhere in your program. You can always defer the choice one more time, but for the program to actually do anything, you need to pick a type.
20:40:59 <Cale> (in order to use type classes anyway)
20:41:47 <bobajett> gotcha.
20:41:48 <Cale> JakeE: I don't know whether there's a type in the Agda or Coq standard library for colists which have at least n elements, but you could write one.
20:42:39 <jle`> is it that bad to program a big-ish game using only the State monad and no FRP stuff?  does FRP really offer that much
20:43:11 <startling> jle`: it's not really bad.
20:43:19 <startling> it can get claustrophobic but it can also work well.
20:43:21 <Cale> jle`: Nobody has decided on a one-true-way to do FRP yet (at least in my opinion)
20:43:36 <Cale> jle`: So you could definitely be excused for staying out of the fray :)
20:43:58 <jle`> i have been caught in choice paralysis
20:44:09 <jle`> and i keep on asking 'why do i even need to choose a framework'
20:44:12 <kryft> I've spent most of my life in choice paralysis
20:44:42 <jle`> i wish there was some sort of guide that compared the philosophical underpinnings and design decisions of the various FRP frameworks
20:44:44 <Cale> jle`: There's never anything too wrong with just using good old functional programming
20:44:53 <jle`> yea but so much hype around FRP :/
20:45:52 <jle`> i feel like just plopping down a state monad and an event-update-redraw game loop
20:45:56 <jle`> just like the good ol days
20:46:15 <Cale> FRP can be really cool, but I've spent significant amounts of time working on an (unreleased, closed source) FRP library, and I don't think it's something that just anyone would want to jump into lightly.
20:46:38 <Cale> (It's interesting and it can be fun, but it also is not the quickest way to get results)
20:47:16 <Cale> Maybe you'll find that one of the FRP libraries seems to provide everything you need already, and if that's the case, then go for it.
20:48:57 <jle`> but otherwise i won't have much of a harder time doing a large-ish scale game with just a game loop/state monad?
20:49:11 <jle`> i just feen uncomfortable because game loops feel so 'business as usual
20:49:13 <jle`> '
20:49:23 <jle`> and i want my mind to be blown and my entire world to be rocked using Haskell :/
20:49:36 <ReinH> johnw: ping
20:50:06 <Cale> Maybe do some small tests before you take on some multi-year game project :)
20:50:24 <jle`> Cale: advice noted
20:50:26 <Cale> I would recommend trying sodium in particular
20:50:33 <manju> Hello
20:50:40 <jle`> hello manju
20:50:43 <manju> I am trying to compile json-b
20:50:44 <Cale> It was developed by a former coworker of mine
20:50:56 <manju> http://hackage.haskell.org/package/json-b-0.0.4
20:51:20 <Cale> (blackh, he lurks in this channel quite often)
20:52:18 <manju> http://lpaste.net/98270
20:52:21 <manju> I get this error.
20:52:27 <manju> Can anyone help me ?
20:52:52 <manju> I tried cabal install on ubuntu 13.10 and I ran into cabal hell. So I manually downloaded and tried to compile.
20:53:39 <Cale> manju: Why that package in particular?
20:53:47 <Cale> Does it need to be json-b?
20:53:52 <manju> Cale, Hawk depends on it.
20:53:55 <Cale> That package seems extremely old
20:54:06 <manju> I saw it on reddit and it helps my work.
20:54:09 <manju> Yes, it is.
20:54:10 <Cale> well, perhaps "extremely" is a bit much
20:54:26 <Cale> It's got 5 years of bitrot :)
20:54:28 <manju> It is from 2009, so I think you are right.
20:54:56 <manju> https://github.com/gelisam/hawk#readme
20:54:57 <ReinH> lispy: I thought program derivation was a generalization of this
20:55:01 <manju> err..
20:55:06 <ReinH> so I guess that would be right
20:55:08 <manju> http://www.reddit.com/r/haskell/comments/1unuu4/ann_hawk_10_manipulate_text_from_the_command_line/
20:55:15 <manju> This was posted 2 day ago.
20:55:19 <Cale> The reason it shouldn't have gotten started is that it depends on base < 4
20:55:37 <Cale> and the base which comes with GHC 7.6.3 is 4.6.0.1
20:55:54 <johnw> ReinH: pong
20:56:14 <manju> I think, I maybe wrong.
20:56:16 <manju> One moment.
20:56:39 <Cale> manju: There's a more recent version of haskell-awk on hackage
20:56:43 <Cale> http://hackage.haskell.org/package/haskell-awk
20:56:47 <manju> Nevermind, I think, cabal install hawk != cabal install haskell-awk
20:56:51 <Cale> This should be buildable
20:56:58 <manju> Yeah, it is buildable.
20:57:18 <manju> Sorry about the confusion.
20:57:34 <manju> Why are things that do not work anymore removed from cabal ?
20:57:57 <startling> manju, because they still work if you have the correct GHC.
20:58:23 <manju> If things, start breaking immediately due to unavailability, people would've the incentive to fix things, I think.
20:58:28 <manju> startling, ah
20:58:49 <startling> (that is, the old one).
20:58:54 <manju> So make old versions of GHC not access the new repos ?
20:59:13 <manju> Disallow people from downloading updates for old GHC.
20:59:19 <startling> manju, you said you got an error and you ignored it.
20:59:26 <startling> manju, and then tried downloading things yourself.
20:59:40 <startling> that error (something about base, probably) is exactly what you're asking for.
20:59:57 <manju> startling, Hmmm...
21:01:24 <startling> and yeah, it looks like Hawk is something very different from haskell-awk
21:02:22 <ReinH> johnw: I'm getting a lot of <<server error>> errors from FPComplete IDE :(
21:02:28 <ReinH> johnw: was having a lot of fun with it too :/
21:02:41 <johnw> oh, what kinds of things were you doing?
21:02:43 <ReinH> johnw: and also "Code run failed: user error (Cannot run before the code is generated.)"
21:03:01 <NemesisD> any users of the tasty framework? i was thinking about how i could build a tool that automatically reruns tasty tests when source files change
21:03:09 <ReinH> johnw: Nothing unusual at all, really. Writing some haskell and compiling it.
21:03:34 <johnw> i'm having issues too
21:03:44 <ReinH> johnw: if I restart the instance it'll work for a few minutes
21:04:11 <Twey> Cale: Why did you advise Sodium in particular?
21:05:26 * hackagebot purescript 0.2.9.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.9.1 (PhilFreeman)
21:05:37 <carter> bitemyapp: bytestring doesn't signal encoding
21:05:42 <Cale> Twey: Well, I know that Stephen has the same ideas about the right kinds of semantics for FRP systems that I do, so I trust that he's implemented those :)
21:06:15 <lispy> heh
21:06:20 <Cale> also, I know that he's used it for real stuff
21:06:23 <lispy> Cale: I thought netwire was all the rage now.
21:06:45 <Twey> Aha :þ
21:06:46 <lispy> Cale: Do you know how sodium compares to yampa or reactive-banana?
21:07:11 <Cale> I think it's closer to reactive-banana
21:07:21 <Cale> Sodium isn't arrowy
21:07:41 <Twey> I ask because I'm getting into FRP, so I did a quick survey of the options and settled on reactive-banana — so I was wondering what your (relative) objection to that is
21:07:50 <lispy> I found arrows to be a pain because you can't make an ArrowApply instance
21:08:11 <lispy> Twey: I had really bad performance issues with reactive-banana.
21:08:32 <lispy> Twey: any sort of integration caused my programs to grind to a halt within seconds
21:08:58 <Twey> lispy: That's odd
21:09:07 <lispy> Twey: I still have the code if you'd like to look at it
21:09:08 <Cale> Sodium uses a monad just to construct the dataflow graph, it doesn't have an intrinsic notion of time, it's impossible to internally tell when behaviours change (i.e. they're effectively "continuous")
21:09:21 <Twey> I've used it for a couple of things with low latency (Gloss and OpenGL) and it didn't seem to introduce a significant delay
21:09:27 <lispy> Twey: https://github.com/dagit/1GAM/blob/master/pong/reactive-banana/Main.hs
21:10:24 <Cale> reactive-banana as I understand it *does* have an intrinsic notion of time
21:10:39 <Twey> Cale: So does it only support ‘pull’ FRP?
21:10:45 <lispy> Twey: the version (also in that repo) that uses yampa is more complete and doesn't have the leakiness.
21:11:14 <Twey> reactive-banana has an abstract notion of time — there's a time parameter, but I don't think it's ever instantiated
21:11:14 <Cale> Twey: I actually don't know much about how Stephen decided to implement Sodium
21:11:39 <Cale> (Whether it's "push" or "pull" is more a feature of the implementation than it is of the interface)
21:12:07 <Cale> Ah, okay
21:12:42 <Cale> I could be wrong about reactive-banana, I've never actually used it.
21:12:49 <bitemyapp> carter: well. True.
21:12:55 <carter> jah
21:13:03 <Twey> It's been pretty good to me so far
21:13:14 <carter> bitemyapp: that said, i *MAY* write a lying bytestring parsing only json lib soon
21:13:17 <carter> for a specific use case
21:14:16 <lispy> Twey: if you know what I'm doing wrong with that reactive-banana code i'd love to hear it
21:14:32 <Twey> Cale: (a quick check for instances of the ‘time’ class, Frameworks, shows that there's no parameter that actually satisfies it, so I'm pretty sure it's purely abstract)
21:14:58 <Cale> Twey: I feel a bit weird about that Moment type
21:15:00 <Twey> lispy: I'm having a look through it; I doubt I'll have enough experience to find the error, but I've done something similar, so I'll compare
21:15:28 <lispy> Twey: I'm also sure some of that code is total crap so if you have ideas on how to improve it, also let me know :)
21:16:09 <bitemyapp> carter: actually, I no longer know what copumpkin was asking about and cannot distinguish it from the docs for 0.7.0.0
21:16:15 <lispy> I find it very hard to understand FRP code
21:16:17 <Cale> (But I'd have to analyse what was possible with it to really convince myself whether it was harmless or possibly problematic)
21:16:20 <Twey> lispy: Mine's worse :þ  The FRP bit was tacked on rather hurriedly for a deadline
21:16:21 <lispy> It hasn't clicked in my brain yet
21:16:31 <Twey> Cale: What makes you suspicious of it?
21:16:39 <carter> bitemyapp: theres no FromJson instance for bytestring
21:17:06 <bitemyapp> carter: as distinguished from just using the decode function?
21:18:00 <carter> bitemyapp: decode requires a FromJSON
21:18:27 <carter> the bytestrings in the decode section
21:18:30 <carter> are all "utf8"
21:18:34 <bitemyapp> carter: it returns a FromJSON. http://hackage.haskell.org/package/aeson-0.7.0.0/docs/Data-Aeson.html
21:18:56 <carter> yeah
21:19:06 <bitemyapp> carter: so is the contract that any bytestring passed to decode should be a valid JSON UTF8 sequence of bytes?
21:19:10 <Cale> Twey: It turns out to be very problematic to design these systems around the ability to refer directly to arbitrarily old points in time. Also, if you can end up with a behaviour whose value is always the current time, even that can be a problem if not treated with respect.
21:19:17 <carter> hrmmm
21:19:34 <bitemyapp> carter: as distinguished from defining it universally for all bytestrings instead of bytestrings passed to the function?
21:19:41 <carter> sooo
21:19:43 <Twey> lispy: Ugh, I wanted to run it but I had to downgrade GLFW-b for Gloss ☹
21:19:55 <Cale> (The reason being that its value is perpetually invalid, and anything which depends on it will constantly require recomputation)
21:20:11 <lispy> Twey: Well, I don't think it's tied to a GLFW-b version...let me look
21:20:12 <bitemyapp> I'm trying to draw a line in the sand so I know the difference. What I'm saying is universal typeclass for all members of type vs. a function with a contract for what it expects above and beyond type membership.
21:20:38 <Twey> lispy: It is: you're using GLFW 3 (and the associated GLFW-b), but I had to downgrade to GLFW 2 (and the associated GLFW-b)
21:20:58 <lispy> Twey: oh you mean previously you had to downgrade it.
21:21:24 <Twey> lispy: Yes, I wrote my thing with 3, but then I wanted to use Gloss, which only supports GLFW 2.
21:22:34 <JakeE> do you think you could use shaddow types with generlized algebraic data types to express the kind of a type in the type system of haskell?
21:22:50 <carter> bitemyapp: ok, heres the reason
21:22:55 <carter> http://www.haskell.org/pipermail/libraries/2013-September/020859.html
21:23:13 <Twey> lispy: Without being able to play with it, I think the best I can say is that a) it sounds like you have a space leak somewhere, and b) I've done much more resource-intensive rendering, so this certainly isn't an intrinsic limit of reactive-banana
21:23:14 <carter> json doesn't specify how to handle binary data
21:23:26 <JakeE> sorry I should specify. the kind of a type being represented by a generalized algebraic data type. like say how GHC might represent types
21:23:28 <carter> and bytestring is binary data
21:23:36 <bitemyapp> carter: okay man, that's what I said.
21:23:40 <carter> ok
21:23:43 <bitemyapp> carter: so the answer is "yes" to what I said, but with extra info.
21:23:44 <carter> i somehow didn't see that
21:23:47 <lispy> Twey: Oh I know where the space leak is. It's because I want to use integration to calculate the ball's position (it's a pong game)
21:23:51 <carter> so yes
21:23:52 <bitemyapp> carter: the contract I was referring to is the encoding
21:23:52 <carter> we agree
21:24:02 <carter> well
21:24:03 <carter> hrmm
21:24:04 <carter> sooo
21:24:08 <bitemyapp> carter: you can't assume the contract universally for all possibly valid values the bytestring can be
21:24:13 <carter> you're wondering "why bytestring rather than text/"
21:24:14 <carter> ?
21:24:16 <bitemyapp> no.
21:24:20 <bitemyapp> I'm not at all.
21:24:23 <bitemyapp> Did you read what I said?
21:24:24 <lispy> Twey: Maybe there is a different way to get the balls position. I don't even know why it has to be leaky. I just want to accumulate it.
21:24:31 <carter> i am
21:24:34 <carter> i'm trying to understand
21:24:46 <carter> bitemyapp: remember what I said abouthow to frame questions please?
21:24:49 <carter> i'm trying help
21:24:58 <bitemyapp> carter: I understand bytestring just fine. I was distinguishing why a typeclass instance vs. a function, and the way I described it is in terms of a more constrained contract than what bytestring allows.
21:25:05 <carter> oh
21:25:16 <bitemyapp> carter: type allows values a, b, c. typeclass applies to all members of type. But the only valid values are actually a and b.
21:25:33 <bitemyapp> shifting typeclass instance to function is more semantically correct than defining the instance for a set of values that are not all valid.
21:25:37 <bitemyapp> sets the wrong expectation.
21:25:43 <carter> ok
21:25:46 <carter> now you're saying confusing stuff
21:26:06 <carter> lets zoom out
21:26:16 <bitemyapp> this is zoomed out, I'm speaking in the abstract about it.
21:26:21 <Twey> lispy: Oh, I see
21:26:31 <carter> decode :: FromJSON a => ByteString -> Maybe a
21:26:32 <bitemyapp> you don't want to go up the ladder of abstraction if my explanation is problematic, you want go down and be more specific.
21:26:41 <carter> we are talking about decode
21:26:53 <bitemyapp> carter: yes. I know.
21:26:54 <carter> there is no notion of binary data in standard JSON format
21:27:02 <bitemyapp> Okay. following you.
21:27:06 <carter> thus,  no FromJSON instance for bytestring
21:27:19 <carter> however, JSON itself is utf encoded text format, right?
21:27:27 <carter> *utf-8
21:27:28 <carter> right?
21:27:35 <bitemyapp> hum, that's a different semantic quibble I think but it's related to the same problem.
21:27:53 <carter> ok
21:28:49 <carter> bitemyapp: http://en.wikipedia.org/wiki/JSON says "the default character encoding for json is utf8"
21:28:51 <bitemyapp> I'm talking about the set of all values that bytestring can take and why a typeclass instance is poor semantics given what bytestring actually is (not necessarily text, not necessarily utf8, not necessarily utf8 JSON)
21:29:08 <bitemyapp> carter: I know that too, I've actually spent a lot of time with JSON, parsers, and similar formats text and binary alike.
21:29:18 <bitemyapp> carter: I'm trying to explain why I agree with the change for a different reason.
21:29:23 <carter> ohh
21:29:23 <carter> ok
21:29:24 <carter>  yeah
21:29:35 <carter> so we agree
21:29:42 <carter> i was misunderstanding the intent of your explanation
21:29:46 <carter> and was getting confused
21:29:52 <bitemyapp> in the absence of dependent types, if we're going to only accept a subset of values that a type allows we should at least make it a function and not a typeclass instance.
21:30:05 <bitemyapp> Right, good, great.
21:30:09 * bitemyapp high fives carter
21:30:12 <carter> ok
21:30:22 <carter> well, i'm not understanding the function vs type class part
21:30:34 <carter> all thats changes is theres one less tpye class instance
21:30:41 <carter> *changed
21:31:02 <bitemyapp> carter: I'm setting a higher bar for defining the instance than I would for function accepting the type in one of its arguments.
21:31:09 <carter> ok
21:31:50 <bitemyapp> carter: that higher bar is that, "if an instance is defined for the type, the set all valid values of that type should also be acceptable for the instance"
21:31:59 <carter> oh yeah
21:32:08 <carter> and theres no semantics for that
21:32:09 <carter> yeah
21:32:18 <Cale> ByteString is an efficient representation of [Word8]
21:32:20 <carter> it was just "extended ascci goes here"
21:32:22 <Twey> lispy: If you just want to accumulate it, I think you don't need to integrate over all of time — you can simply accumulate with accumB, something like bBallPosition = accumB (0, 0) $ (\(x, y) _ → (x + 10, y + 10)) <$> eClockTick
21:32:22 <carter> yeah that too
21:32:29 <bitemyapp> Cale: I think we're all on board with that, yeah.
21:32:55 <Twey> lispy: (eventually using ‘apply’ to get the delta from a Behavior rather than a constant, obviously)
21:33:03 <Cale> So you might expect it to be encoded as a JSON array of numbers
21:33:15 <lispy> Twey: I think I tried that, but I could try it again
21:33:17 <carter> Cale: Texheh
21:33:20 <carter> hrmmm
21:33:23 <bitemyapp> carter: right, so if you're expecting a specific encoding or subset of values, a function seems more proper (to me) than a typeclass instance.
21:33:30 <Twey> lispy: That's the approach I used, and it worked out okay
21:33:35 <Cale> I would.
21:33:39 <lispy> Twey: right now I'm trying to build a nes game so FRP is sort of out of the picture :)
21:33:53 <Twey> Hehe, maybe if you compiled it right… ;)
21:33:54 <bitemyapp> carter: because it goes above and beyond merely not being valid JSON, it's just totally otherworldly, not at all related sorts of data.
21:33:57 <carter> do we have any bytestring focused parser combinator libs that try to do zero copy slicing of bytesrings?
21:34:14 <carter> 'cause i'd love to not have to write one in the near future
21:34:18 <Cale> carter: I think all of them implicitly will
21:34:25 <carter> implicitly copy?
21:34:31 <bitemyapp> carter: I don't know about the specific constraints, but does attoparsec not do what you want?
21:34:32 <Cale> Implicitly slice
21:34:42 <carter> bitemyapp: i'll look
21:34:43 <Cale> When you drop an element from a ByteString, it just slices.
21:34:48 <lispy> Twey: and I'm already pushing the envelope on that one by insisting on using C :)
21:34:54 <Cale> (by default, unless you explicitly take a copy)
21:35:12 <carter> Cale: so if you accept a subinterval of a bytestring, its sliced?
21:35:15 <carter> rather than copied?
21:35:22 <lispy> Twey: I might rethink that and use an assembly eDSL in Haskell, but I figured I'd give C a chance first
21:35:39 <bitemyapp> carter: "Original GHC implementation by Bryan O'Sullivan. Rewritten to use Data.Array.Unboxed.UArray by Simon Marlow. Rewritten to support slices and use ForeignPtr by David Roundy. Polished and extended by Don Stewart."
21:35:41 <Cale> tail :: ByteString -> ByteString
21:35:41 <Cale> tail (PS p s l)
21:35:41 <Cale>     | l <= 0    = errorEmptyList "tail"
21:35:41 <Cale>     | otherwise = PS p (s+1) (l-1)
21:35:53 <carter> huh
21:35:53 <carter> ok
21:36:00 <carter> oh frabjous days
21:36:01 <Cale> See, it just adjusts some indices, the pointer to the bytes remains :)
21:36:08 <carter> ok
21:36:22 <carter> but... aeson can't be zero copy
21:36:40 <carter> because it has no byte strings
21:36:41 <carter> ok
21:36:41 <carter> hrmm
21:37:06 <Twey> lispy: Good luck!  It would be cool to hear about it if you succeeded in doing it in Haskell.  ☺
21:37:16 <Cale> I think the instance for ByteString in Aeson, if it doesn't already, should behave the same way as the instance for [Word8]
21:37:28 <bitemyapp> carter: huh? Aeson uses bytestring by default, as well as attoparsec.
21:37:45 <bitemyapp> so far as I can tell from the docs anyway.
21:37:47 <carter> bitemyapp: but no fromJSON instances for bytestring
21:37:49 <Twey> Er
21:38:01 <Cale> bitemyapp: I thought we were talking about how it encodes things to JSON, not the type that it encodes to.
21:38:06 <bitemyapp> carter: sure? it's unclear to me why that would be problematic.
21:38:20 <carter> zero copy parsing
21:38:27 <Cale> wait, what?
21:38:33 <Cale> What does this have to do with copying?
21:38:45 <carter> Aeson 0.7
21:38:54 <carter> has no FromJSON Bytestring insance
21:38:57 <Cale> The part which would be problematic is if it treated ByteStrings as text.
21:39:07 <lispy> Twey: I could make a basic assembler in a few hours I bet. I've done it before when making a compiler backend.
21:39:10 <bitemyapp> it's not clear to me why the instance would have any bearing on copying.
21:39:22 <copumpkin> if Text were backed by UTF-8, then you could provide zero-copy Text values :)
21:39:24 <lispy> Twey: But, I doubt haskell itself could ever run on there :)
21:39:26 <carter> you give a a bytestring http response/equest body
21:39:34 <carter> copumpkin: yes, but its utf16
21:39:35 <carter> sooooo
21:39:40 <copumpkin> yes, so you get copies
21:39:44 <carter> yeah
21:39:50 <Cale> They're nothing like copies though...
21:40:02 <Cale> Or at least, if you make the instance do the sane thing, they wouldn't be
21:40:02 <copumpkin> or you write something like a Base64 newtype around a ByteString
21:40:11 <carter> copumpkin: oh, neat idea
21:40:19 <copumpkin> and then only accept encoded strings
21:40:27 <carter> heh
21:40:28 <bitemyapp> base64, cheat code of the universe.
21:40:29 <carter> sooo
21:40:29 <Cale> (which is to unpack the ByteString to a [Word8] and encode that)
21:40:43 <copumpkin> still copied, but less crap than going through utf16
21:40:46 <copumpkin> anyway, going to sleep
21:40:49 <carter> cool
21:41:47 <Cale> But I guess the Aeson people figured that it's easy enough to unpack the ByteString yourself, though that's a little unhelpful if you have some data structure with little ByteStrings strewn through it.
21:42:43 <Cale> (I'm assuming it's clear why you can't just copy the input to the output here)
21:42:48 <carter> well
21:43:01 <carter> i've a use case that aeson's not quite right for anyways
21:43:17 <Twey> Cale: The t parameter in reactive-banana is ‘the time at which this value begins’: it doesn't allow arbitrary-timed access (because there's no value for t).
21:43:40 <Cale> Twey: hmm, okay
21:43:47 <carter> because i need to quickly parse stuff that may not valid json :)
21:44:08 <Twey> (apfelmus' blog seems to indicate that it's basically Identity, but the reactive-banana source looks rather more complicated — I'm not really sure how it works, but I'll take his word for it :þ)
21:44:13 <carter> context is something where you'd have 5k-20k requests per second, and you want to parse them, do something quickly, reply
21:44:19 <ParahSailin> lispy: kanzure in ##hplusroadmap is interested in nes assembler for pokemon
21:44:28 <carter> in under 100ms each, idealy under 10-50ms
21:52:24 <lispy> ParahSailin: a nes assembler as a Haskell dsl though?
21:52:38 <prooftechnique> Is there a good tutorial or something for MVars? I was reading ezyang's blog today and I wanted to do some more reading on the topic
21:53:03 <lispy> prooftechnique: Simon Marlow wrote a book about parallel and concurrent Haskell that talks about them.
21:53:18 <prooftechnique> Oh, that's right. I keep meaning to read that!
21:53:20 <djahandarie> (Which is accessable for free online.)
21:53:21 <prooftechnique> Thanks for the reminder
21:55:28 <danl-ndi> anyone familiar with the fix to ghc to compile OpenGLRaw on mac osx?
21:56:56 <Cale> prooftechnique: Also, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
21:57:32 <prooftechnique> Thanks, Cale.
21:58:53 <Cale> prooftechnique: Really, all you probably need to know from there are the real primitive things: newEmptyMVar, newMVar, takeMVar, and putMVar
21:59:11 <lispy> danl-ndi: I just typed 'cabal install OpenGLRaw' on osx mavericks and it installed no problem.
21:59:12 <Cale> (and I guess occasionally the try- versions are nice to have too)
21:59:26 <lispy> danl-ndi: I installed my ghc through homebrew
21:59:47 <danl-ndi> lispy: which version of ghc?
21:59:52 <lispy> danl-ndi: 7.6.3
22:00:22 <danl-ndi> lispy: damn, that's what I have. I get src/Graphics/Rendering/OpenGL/Raw/EXT/SceneMarker.hs:30:44:
22:00:23 <danl-ndi>     parse error on input `glBeginScene'
22:01:00 <danl-ndi> lispy: github issue page says its an issue with the c preprocessor
22:01:30 <lispy> danl-ndi: and that's OpenGLRaw 1.4.0.0? How did you install GHC?
22:01:39 <prooftechnique> Cale: Yeah, definitely. I have a really basic idea of how to use the primitives, but I'd like a better understanding of the theory, I guess.
22:01:57 <Cale> ah okay
22:02:04 <danl-ndi> lispy: 1.4.0.0 yes. I forget howI installed... I think it was homebrew
22:02:39 <lispy> danl-ndi: I guess you could check if the tap/keg/whatever they call it has updated since you installed. My install is only a couple weeks old.
22:02:45 <prooftechnique> Cale: Concurrency is still a bit magic to me :D
22:04:04 <danl-ndi> lispy: uh-oh. "brew update" has failed for me :(
22:04:24 <Cale> http://research.microsoft.com/~simonpj/papers/concurrent-haskell.ps.gz -- there is this old paper, but note that instead of being an error, writing to a full MVar in the modern implementation will block.
22:05:13 <Cale> (but they mention that as a possible option)
22:05:38 <danl-ndi> lispy: oh, i installed the haskell platform. that's probably why...
22:06:50 <prooftechnique> Cale: Yeah, I just opened that from the C.C.MVar docs and I'm adding http://community.haskell.org/~simonmar/par-tutorial.pdf to my reading list, too
22:07:14 <prooftechnique> Though I imagine his book covers similar material and then some.
22:07:23 <danl-ndi> lispy: aaand the haskell platform page has instructions on fixing the preprocesor issue.
22:08:00 <cwvh> danl-ndi: I use the haskell-platform brew and installed openglraw on mavericks just now, FWIW
22:08:35 <cwvh> danl-ndi: there should be hooks to apple-gcc42 as the ghc C compiler in brew, but, if not.. looks like you found the fix.
22:08:56 <danl-ndi> cwvh: how do you install haskell-platform via brew?
22:09:25 <danl-ndi> cwvh: ah nevermind, dumb question
22:09:56 <danl-ndi> mixed up "search" and "list" in brew
22:10:19 <prooftechnique> What's the status of that preprocessor bug in HEAD, anyway? Is it #8528 on trac, or is it in clang's court now?
22:10:47 <lispy> danl-ndi: cool. Sounds like you've got a way forward.
22:10:55 <sccrstud92> @pl f a = a
22:10:55 <lambdabot> f = id
22:10:58 <danl-ndi> lispy/; yup
22:11:11 <sccrstud92> @pl f a b = not a && b
22:11:11 <lambdabot> f = (&&) . not
22:11:33 <cwvh> danl-ndi: If you want to live on the edge, I've used gcc48/llvm from brew to provide my GHC C/llc/opt without any issues.
22:12:13 <danl-ndi> cwvh: heh. i do not want to live on the edge! but I do want to do some cool frp + opengl stuff
22:14:18 <lispy> danl-ndi: you say tomato I say tomato
22:14:20 <lispy> :)
22:14:30 <ReinH> Ok, I like this for creating a comma-separated list http://lpaste.net/98271
22:14:41 <ReinH> Using the oxford comma as god intended, of course. I am not a barbarian.
22:15:59 <JakeE_> what?
22:16:15 <ReinH> Oh nothing, I just figured out a nice way to turn [String] into a comma separated list
22:16:39 <JakeE_> no: I got kicked and my client auto rejoined but my old id is still in the room
22:17:17 <ReinH> JakeE_: oh heh
22:17:23 <lispy> you can /msg nickserv and ghost it
22:17:58 <JakeE_> what command do I send after "/msg nickserv"?
22:18:14 <JakeE_> or is nickserv handled by an actual person?
22:18:16 <lispy> help
22:18:20 <lispy> It's a bot
22:18:26 <JakeE_> k thanks
22:18:27 <Connorcpu> I always like /msg nickserv help :P
22:19:30 <JakeE> well it went away before I could ghost it but thats good to know
22:21:25 <ReinH> I have a style question for folks about do notation vs undo http://lpaste.net/98272 which do you prefer?
22:22:26 <JakeE> first for that as it rends "prompt then getinput and send it to handle"
22:22:30 <JakeE> *reads
22:22:43 <ReinH> which is what it does
22:22:51 <JakeE> but for more complex stuff I prefer do for sure
22:23:13 <ReinH> pretty much anything beyond this and I will switch to do
22:23:18 <sccrstud92> when im writing a function ill usually use do for simpler stuff
22:23:24 <ReinH> so this is an interesting case
22:23:32 <ReinH> because I'm sort of indifferent
22:23:33 <sccrstud92> but when im finished i might convert to using binds
22:24:08 <sccrstud92> unless doing so would require writing lambdas or arrow combinators
22:24:34 <JakeE> there might be certain, possibly highly generic, code that I might not use the do notation for
22:25:03 <sccrstud92> @hoogle map
22:25:04 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
22:25:04 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
22:25:04 <lambdabot> Data.ByteString.Char8 map :: (Char -> Char) -> ByteString -> ByteString
22:25:44 <JakeE> @djinn a
22:25:44 <lambdabot> -- f cannot be realized.
22:26:04 <JakeE> @djinn forall a. a
22:26:04 <lambdabot> -- f cannot be realized.
22:26:14 <JakeE> @ty undefined
22:26:15 <lambdabot> a
22:26:22 <JakeE> djinn lies!
22:26:28 <sccrstud92> how so?
22:26:46 <JakeE> it says type 'a' can't be realized but it can
22:26:58 <ReinH> djinn is silly sometimes
22:26:59 <JakeE> but by that token anything can be realized using undefined
22:27:02 <ReinH> but other times it is awesome
22:27:17 <ReinH> @djinn (r -> a -> b) -> (r -> a) -> (r -> b)
22:27:18 <lambdabot> f a b c = a c (b c)
22:27:25 <ReinH> so <*> is a free theorem
22:27:36 <ReinH> well <*> for (r ->)
22:27:41 <Twey> ReinH: Top (two votes)
22:27:55 <ReinH> Twey: ok :) I'm leaning that was as well.
22:28:02 <Axman6i> @djinn (a->b)->b->a
22:28:03 <lambdabot> -- f cannot be realized.
22:28:05 <JakeE> ya it is basiclly a theorem proover by the curry howard coraspondence
22:28:25 <ReinH> Twey: but on the other hand I prefer to undo this one:
22:28:27 <JakeE> lol the identity function can't be realized?
22:28:36 <ReinH> score += 1 >> location .= newLocation >> look
22:28:43 <ReinH> even though it is similarly complex
22:28:48 <enthropy> JakeE: note the (b -> a) isnt (a -> b)
22:28:49 <startling> JakeE: where did someone ask the identity function?
22:28:52 <startling> ah.
22:29:07 <JakeE> my bad, I got type dyslexic
22:29:09 <Twey> ReinH: The top one was the non-do version
22:29:15 <ReinH> @djinn a -> a
22:29:15 <lambdabot> f a = a
22:29:25 <ReinH> Twey: right, but in this other case I prefer the do version. Oh I misspoke.
22:29:28 <Twey> I'd not use do for that either
22:29:29 <JakeE> I thought it was (a -> b) -> (a -> b)
22:29:31 <ReinH> Twey: in my second example I prefer the do version
22:29:34 <ReinH> not the undo version
22:29:34 <Twey> Ah, okay
22:29:35 <startling> @djinn (a -> b -> c) -> b -> a -> c
22:29:35 <lambdabot> f a b c = a c b
22:29:37 <zRecursive> what does djinn mean ?
22:29:48 <Twey> I use do only when there'd otherwise be a lambda (or sometimes a lot of brackets)
22:29:50 <startling> zRecursive: it derives a function with the type you gave it.
22:29:58 <JakeE> if this strictly uses primitave recursion that it is actully a legit proof finder
22:30:09 <sccrstud92> @djinn Int -> Int -> Int
22:30:09 <lambdabot> Error: Undefined type Int
22:30:11 <zRecursive> startling: weird name ?
22:30:18 <ReinH> It does this http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
22:30:31 <startling> @djinn a -> (a -> a -> a -> a -> b) -> b
22:30:31 <lambdabot> f a b = b a a a a
22:30:49 <JakeE> then that explains why bad types can't be found! I'm much more impressed
22:30:55 * startling . o O ( Sheep can do theorem-proving? )
22:31:16 <sccrstud92> djinn doesnt recognize types?
22:31:21 <sccrstud92> just type variables?
22:31:29 * startling . o O ( Theorem-hooving? )
22:31:39 <johnw> sccrstud92: What would it know about a concrete type?
22:31:46 <JakeE> @djinn [a] -> [[a]]
22:31:46 <lambdabot> Error: Undefined type []
22:31:48 <startling> @djinn a -> Maybe a
22:31:48 <lambdabot> f = Just
22:31:48 <sccrstud92> same stuff haskell knows
22:31:57 <JakeE> lol what?
22:31:58 <startling> it does; it doesn't do /recursive/ types.
22:32:15 <JakeE> well that takes out all the fun then
22:32:16 <startling> @djinn (a, b) -> (a, a)
22:32:16 <lambdabot> f (a, _) = (a, a)
22:32:19 <Iceland_jack> @djinn () -> ()
22:32:19 <lambdabot> f a = a
22:32:25 <Twey> I assumed it had its own types
22:32:29 <sccrstud92> see it doesnt recognize [] as a type constructor either
22:32:31 <JakeE> it dosn't have to recurse at all then...no induction is used
22:32:33 <sccrstud92> or Int
22:32:39 <startling> sccrstud92, lists are a recursive type.
22:32:51 <sccrstud92> what about Int's then?
22:32:57 <sccrstud92> Ints*
22:33:11 <JakeE> Int in thoery is viewed as Nat which is recursive
22:33:16 <startling> I don't know.
22:33:18 <ReinH> StateT a IO b feels a lot like cheating
22:33:39 <startling> Int doesn't really have constructors, which might be why.
22:33:39 <Iceland_jack> ReinH: You can implement functions for StateT a IO b that are pure, so there
22:33:59 <cwvh> ReinH: If that's cheating, what is RWST?  :-)
22:34:00 <zRecursive> @unmtl StateT a IO b
22:34:00 <lambdabot> a -> IO (b, a)
22:34:06 <ReinH> Iceland_jack: like all of them, yes. Even still.
22:34:16 <JakeE> cheating is undefined lol
22:34:18 <ReinH> Oh @untl is a thing? o_O
22:34:23 <ReinH> unmtl that is
22:34:50 <prooftechnique> That's pretty neat
22:34:56 <prooftechnique> I didn't know about that, either
22:34:58 <sccrstud92> so is unmtl what you would get if you called runX ?
22:35:03 <ReinH> I knew it was a -> IO (b, a) but I didn't know there was an unmtl to show me
22:35:14 <ReinH> figuring out the correspondence helped me grok StateT a lot
22:35:47 <sccrstud92> @unmtl RandT a IO b
22:35:47 <lambdabot> a -> IO (b, a)
22:35:56 <sccrstud92> @unmtl BleghT a IO b
22:35:56 <lambdabot> BleghT a IO b
22:36:02 <ReinH> hah
22:36:16 <sccrstud92> oh right
22:36:25 <sccrstud92> RandT is just a StateT newtype
22:36:34 <sccrstud92> or type synonym
22:36:43 <JakeE> preety printing question for my type system. do you prefer "List (forall a. List a)" or "List forall a. (List a)"
22:36:51 <startling> @unmtl StateT s BleghT b -- I think that's just how it treats any type it doesn't know.
22:36:51 <lambdabot> s -> BleghT (b, s)
22:36:51 <scshunt> the former
22:37:16 <startling> seconded.
22:37:21 <sccrstud92> JakeE: are those equivalent types?
22:37:33 <JakeE> yes
22:37:51 <Axman6i> @unmtl ErrorT a b c
22:37:51 <lambdabot> b (Either a c)
22:37:52 <JakeE> unless I'm being stupid which wouldn't be the first time
22:37:55 <sccrstud92> im surprised the parenthesization doesnt matter
22:38:41 <Axman6i> @unmtl StateT s (ErrorT String IO) a
22:38:41 <lambdabot> s -> (ErrorT String IO) (a, s)
22:38:48 <sccrstud92> @djinn Bool -> Maybe ()
22:38:48 <lambdabot> f a =
22:38:48 <lambdabot>     case a of
22:38:49 <lambdabot>     False -> Nothing
22:38:49 <lambdabot>     True -> Just ()
22:38:56 <sccrstud92> awww
22:38:58 <JakeE> well if the language had a defined grammar then it would patter
22:39:17 <JakeE> but it's just an abstract syntax tree that I can print out however I want
22:39:33 <sccrstud92> does djinn's response to that mean there is no builtin that does that?
22:39:53 <startling> no.
22:40:10 <sccrstud92> no it doesnt mean that or no there is no builtin?
22:40:10 <ReinH> @hoogle Bool -> Maybe ()
22:40:10 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
22:40:10 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
22:40:10 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
22:40:14 <startling> I don't think djinn knows builtins.
22:40:20 <ReinH> That probably does though :)
22:40:38 <sccrstud92> thx ReinH =)
22:40:54 <Axman6i> djinn knows very little really
22:41:21 <prooftechnique> Though I suppose that's the point.
22:41:33 <JakeE> just so you guys can see it once more: "(List Nat -> List (forall a. List a)) -> List Nat" or "(List Nat -> List forall a. (List a)) -> List Nat"
22:41:33 <sccrstud92> i would have never thought of those monad functions for what i need
22:42:06 <sccrstud92> i like the first one
22:42:15 <sccrstud92> because the forall is right after the paren
22:42:32 <sccrstud92> but i have no good reason for why what appeals to me should matter
22:42:42 <JakeE> that is what I thought personally but 2 others said oppisite
22:42:57 <startling> @djinn Reader a b -> a -> b
22:42:57 <lambdabot> Error: Undefined type Reader
22:43:08 <startling> @djinn Either a b -> Maybe a
22:43:08 <lambdabot> f a =
22:43:08 <lambdabot>     case a of
22:43:08 <lambdabot>     Left b -> Just b
22:43:08 <lambdabot>     Right _ -> Nothing
22:43:38 <startling> I feel like it could probably do Reader, Writer, and State.
22:44:32 <JakeE> I guess my vote is the tie breaker lol
22:44:42 * ReinH is getting child-like pleasure from having an Adventure transformer and using runAdventure
22:44:57 <JakeE> lol are you writting a game?
22:45:04 <ReinH> JakeE: writing a text adventure game
22:45:21 <ReinH> JakeE: the eventual goal is to turn it into a twitter bot that plays the game with people who @ it
22:45:34 <JakeE> what is the type of your adventure monad?
22:45:35 <tertl3> can I play it?
22:46:00 <ReinH> Right now just StateT GameState IO a
22:46:01 <JakeE> ya I would so totatlly make a twitter account just to play it lol. brillient idea!
22:46:14 <ReinH> tertl3: once it exists, sure!
22:47:33 <sccrstud92> tertl3: you can't play it yet because it's only in WHNF
22:47:40 <sccrstud92> ReinH is forcing it hard though
22:50:57 * hackagebot pandoc-citeproc 0.3 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.3 (JohnMacFarlane)
22:52:55 <sccrstud92> ReinH have you picked a twitter library yet?
22:53:00 <ReinH> sccrstud92: nope
22:56:22 <sccrstud92> @hoogle Int -> Maybe () -> Maybe Int
22:56:23 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
22:56:23 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
22:56:23 <lambdabot> Control.Parallel.Strategies demanding :: a -> Done -> a
23:07:16 <JakeE> what would you ever want Maybe ()?
23:07:53 <JakeE> it has 2 values; why not just use Bool?
23:08:45 <startling> JakeE, because you're using other Maybes.
23:09:37 <JakeE> ya in a polymorphic case I can see but would you ever have it on its explicitlly typed out in a function type?
23:10:04 <startling> I don't know, but you do see Monad m => m () quite a bit.
23:10:18 <startling> oh, that's what you mean.
23:11:13 <JakeE> the other "explicit" case I can think of is in a data/type/newtype decleration
23:11:33 <Cale> I guess it's not *exactly* the same as Bool semantically, but I don't know of a use case for the difference
23:11:57 <startling> newtype Bool = Bool (Maybe ())
23:12:06 <JakeE> haha
23:12:06 <Cale> If you consider the partially defined values as well, Bool consists of _|_, False, and True (where _|_ represents a nonterminating expression)
23:12:32 <Cale> Maybe () consists of _|_, Nothing, Just _|_, and Just ()
23:12:43 <Cale> So it has 4 values instead of 3
23:12:54 <enthropy> you can sometimes distinguish between different _|_, so let's say 5 values?
23:13:14 <Cale> You can't distinguish between different _|_'s in the evaluation of an expression
23:13:22 <JakeE> good point; also why I like the idea of total functional programing becuse _|_ dosn't mess up my intuitions lol
23:14:00 <sccrstud92> JakeE: I have a list of bools, and I want and list of indexes in this list where a true is held
23:14:12 <sccrstud92> so I convert the bools to Maybe ()
23:14:26 <sccrstud92> use zipWith (<$) [1..]
23:14:38 <Cale> heh
23:14:38 <sccrstud92> to fill in indexes
23:14:42 <sccrstud92> the catMaybes
23:14:46 <enthropy> Cale: the function you write that will give a the string use name the value could just as easily call show on the exception it catches
23:14:48 <sccrstud92> then catMaybes*
23:15:01 <enthropy> *the string you use to
23:15:05 <sccrstud92> so whole thing
23:15:10 <Cale> > findIndices id [True, False, False, True, True, False, True]
23:15:12 <lambdabot>  [0,3,4,6]
23:16:01 <sccrstud92> catMaybes $ zipWith (<$) [1..] $ map guard [True, False, True]
23:16:09 <sccrstud92> > catMaybes $ zipWith (<$) [1..] $ map guard [True, False, True]
23:16:10 <lambdabot>  [1,3]
23:16:22 <sccrstud92> @hoogle findIndicies
23:16:22 <ReinH> sccrstud92: o_O I think I like findIndices id better
23:16:23 <lambdabot> No results found
23:16:33 <ReinH> @src findIndices
23:16:33 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
23:16:38 <sccrstud92> me too but i didnt know it existed
23:16:47 <sccrstud92> oh i see
23:16:48 <ReinH> oh
23:17:10 <ReinH> yeah makes sense
23:17:19 <supki> > [True, False, False, True, True, False, True] ^.. ifolded.filtered id.asIndex
23:17:20 <lambdabot>  [0,3,4,6]
23:17:23 <JakeE> > (map snd . filter fst) (zip [True, False, True] [0..])
23:17:24 <lambdabot>  [0,2]
23:17:31 <ReinH> o_O
23:17:35 <JakeE> that is how I would implement findIndices
23:18:11 <ReinH> JakeE: you need filter (p fst) but yes
23:18:18 <sccrstud92> a lot of times i prefer functions that dont require zipping tuples then throwing away
23:18:43 <johnw> sccrstud92: a lot of times, the compiler never generates them in the first place
23:18:45 <shachaf> I'd bet ifolded is worse.
23:18:54 <sccrstud92> in my mind its harder to understand when you are zipping up into tuples
23:18:58 <shachaf> Actually, maybe we fixed ifolded. I can't remember.
23:19:03 <Cale> I'd use the list comprehension that @src gave
23:19:10 <JakeE> lol
23:19:20 <Cale> except that I'd have ordered the pairs the other way
23:19:22 <sccrstud92> johnw: not because of performance
23:19:34 <Cale> zip xs [0..] feels weird, it should be zip [0..] xs
23:19:37 <JakeE> I never think to use list comprehensions and yet they tend to make certain tasks so simple
23:19:39 <sccrstud92> the tuples methods just seems less "clean" to me
23:19:50 <shachaf> > [y | x <- [True, False, True], x | y <- [0..]]
23:19:51 <lambdabot>  [0,1]
23:19:53 <shachaf> :-(
23:19:56 <sccrstud92> because i find them harder to understand quickly
23:20:11 <Cale> Whenever you want to consider the indices of a list, zip [0..] tends to be the right thing to apply right away
23:20:17 <roboguy_> sccrstud92: aren't you making maybes then throwing them away?
23:20:19 <sccrstud92> shacaf i wishe parallel list comp worked like that lol
23:20:43 <sccrstud92> im basically throwing away falses
23:20:48 <sccrstud92> and keeping trues
23:21:10 <sccrstud92> its like filter id but the elements remember where they were originally
23:21:34 <roboguy_> sccrstud92: but I mean you're introducing a structure then throwing it away in a similar way as the tuple thing
23:22:04 <sccrstud92> "not as much" structure as with the Maybes
23:22:06 <sccrstud92> in my mind
23:22:12 <sccrstud92> the maybes are like holes
23:22:13 <Cale> weird :)
23:22:16 <ReinH> > let go i True = Just i; go _ _ = Nothing in catMaybes $ zipWith go [0..] [True, False, True]
23:22:16 <sccrstud92> that are filled or not
23:22:17 <lambdabot>  [0,2]
23:22:22 <Cale> > let slow xs = concat $ zipWith replicate [1..] xs in slow "slow"
23:22:23 <lambdabot>  "sllooowwww"
23:22:25 <JakeE> Cale: thanks for the "zip [0..]" after I did that I was able to make it point free
23:22:52 <sccrstud92> when i zipWith (<$)
23:23:03 <JakeE> > map fst . filter snd . zip [0..] $ [True, False, True]
23:23:04 <lambdabot>  [0,2]
23:23:06 <sccrstud92> its like the holes are getting filled with numbers
23:23:18 <sccrstud92> unless the hole was filled already
23:23:19 <Cale> JakeE: Yeah, that's sensible
23:23:44 <sccrstud92> JakeE: thats my favorite tuple solution so far
23:24:30 <JakeE> yaaa! I kinda impressed a better haskell programmer! lol
23:24:31 <sccrstud92> @hoogle [a] -
23:24:32 <lambdabot> Parse error:
23:24:32 <lambdabot>   [a] -
23:24:32 <lambdabot>        ^
23:24:36 <sccrstud92> oops
23:24:52 <sccrstud92> @hoogle [a] -> (Int -> a -> b) -> [b]
23:24:52 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:24:52 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
23:24:52 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
23:25:16 <sccrstud92> you know how Map has mapWithKey?
23:25:17 <Axman6> JakeE: that version should fuse quite nicely too I think
23:25:23 <sccrstud92> im surprised list doesnt have something similar
23:25:28 <Axman6> assuming you've got a much larger list of Bools
23:25:32 <JakeE> what does "fuse" mean?
23:25:46 <sccrstud92> like stream fusion?
23:25:50 <Axman6> yeah
23:25:55 <sccrstud92> i think it means remove intermediate results
23:26:00 <Axman6> http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion
23:26:17 <Cale> Only in this case, it won't be stream fusion, but foldr/build fusion
23:26:36 <Axman6> is that because of the list of Bool?
23:26:45 <sccrstud92> build?
23:26:52 <Cale> Because lists don't use stream fusion by default
23:27:14 <Cale> build g = g (:) []
23:27:18 <Cale> build   :: forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
23:27:29 <ReinH> It's certainly lazy enough
23:27:33 <ReinH> > take 10 . map fst . filter snd . zip [0..] $ repeat True
23:27:34 <lambdabot>  [0,1,2,3,4,5,6,7,8,9]
23:28:46 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#build
23:29:07 <Cale> you'll see there a bunch of RULES
23:29:15 <Cale> "fold/build"    forall k z (g::forall b. (a->b->b) -> b -> b) .
23:29:15 <Cale>                 foldr k z (build g) = g k z
23:29:38 <Cale> ^^ that one being perhaps the most important one
23:30:21 <Cale> and then elsewhere in the module there are more RULES pragmas which turn list functions into various combinations of foldr and build
23:30:28 <Cale> (and augment)
23:30:33 <augur> essentially, the g in build is foldr partially applied to a list
23:30:45 <sccrstud92> cant believe ive never heard of that function before when its in base
23:30:51 <Cale> It's not exposed
23:30:53 <augur> build (\f z -> foldr f z xs) == xs
23:31:03 * hackagebot pandoc-citeproc 0.3.0.1 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.3.0.1 (JohnMacFarlane)
23:31:07 <sccrstud92> that too
23:31:14 <sccrstud92> oh haha
23:31:49 <sccrstud92> i recently installed stream-fusion but i didnt notice any difference for my particular application
23:31:55 <augur> theres some good literature on build-fold fusion
23:32:05 <ReinH> The other useful rule is probably "filter"     [~1] forall p xs.  filter p xs = build (\c n -> foldr (filterFB c p) n xs)
23:32:05 <sccrstud92> hardly rigorous testing though
23:32:35 <ReinH> (from http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-List.html#filter)
23:32:37 <Cale> ReinH: Well, there's something like one of those for most of the functions on lists
23:32:38 <Axman6> sccrstud92: you know you've got to use the functions from that library instead of the Prelude ones right?
23:32:42 <the_berserker> > let x = 1 : map (1+) x in x
23:32:43 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:32:44 <Cale> But yeah
23:33:21 <sccrstud92> Axman6: I imported then had to hide all the prelude ones
23:33:28 <Axman6> right
23:33:37 <the_berserker> > scanl (*) (1:[1..])
23:33:39 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
23:33:39 <lambdabot>    arising from a use of `M208119594796753968528653.show_M2081195947967539685...
23:33:39 <lambdabot>  The type variable `a0' is ambiguous
23:33:39 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:33:39 <lambdabot>  Note: there are several potential instances:
23:33:42 <ReinH> Cale: right, map and filter both become build rules
23:34:20 <Twey> :t flip zipWith [0 ..] -- sccrstud92
23:34:21 <lambdabot> (Enum a, Num a) => (a -> b -> c) -> [b] -> [c]
23:34:41 <Twey> :t flip (flip zipWith [0 ..])
23:34:41 <lambdabot> (Enum a, Num a) => [b] -> (a -> b -> c) -> [c]
23:34:50 <Twey> :t flip (flip zipWith [0 :: Int ..])
23:34:50 <lambdabot> [b] -> (Int -> b -> c) -> [c]
23:35:03 <jle`> manju: i had the same problem :P hawk is not haskell-awk
23:35:16 <jle`> just wanted to share in the frustration and revelation
23:35:27 <Cale> A really simple example of fusion is turning map f (map g xs) into map (f . g) xs (i.e. avoiding the intermediate list). You can pretty much rely on things like that happening automatically if you turn on optimisations, because of the fusion in Data.List
23:35:48 <sccrstud92> Cale: you dont need Data.List.Stream?
23:36:07 <Cale> sccrstud92: Data.List.Stream will accomplish the same thing in a different way in that case
23:36:25 <sccrstud92> do they compile down to the same thing?
23:36:25 <the_berserker> > putStrLn "Hello world!"
23:36:26 <lambdabot>  <IO ()>
23:36:48 <Cale> Both Data.List and Data.List.Stream have some capacity for fusion, they use two different systems to do it, neither of which completely beats the other.
23:36:48 <the_berserker> > getLine
23:36:49 <lambdabot>  <IO [Char]>
23:37:07 <sccrstud92> interesting
23:37:12 <Cale> It was hoped that stream fusion would eventually completely retire foldr/build fusion
23:37:19 <the_berserker> > unsafePerformIO getLine
23:37:20 <lambdabot>  Not in scope: `unsafePerformIO'
23:37:25 <Cale> But I'm not sure exactly where the sticking points were.
23:37:36 <ReinH> Cale: uh, something something concatMap? I don't know the details.
23:37:49 <Cale> yeah, it's something to do with concatMap in particular
23:37:53 <JakeE> do you think there is anyway to make a "rotate" combinator that would rotate the arguments of a function? a -> b -> c -> t would become c -> a -> b -> t? maybe using techniques like in "func with functional dependencies"?
23:38:05 <ReinH> Cale: I should have asked dons ;)
23:38:16 <Cale> List comprehensions turned out bad under stream fusion compared to foldr/build (which indicates that concatMap is the likely suspect)
23:38:39 <Cale> But as to why, I couldn't explain it
23:38:42 <sccrstud92> :t flip zipWith [0 :: Int ..]
23:38:43 <jayferd> :t \f a b c -> f c a b
23:38:43 <lambdabot> (Int -> b -> c) -> [b] -> [c]
23:38:43 <lambdabot> (t1 -> t2 -> t3 -> t) -> t2 -> t3 -> t1 -> t
23:38:43 <the_berserker> @pl \a (b,c,d,e) -> b a c d e
23:38:44 <lambdabot> (line 1, column 9):
23:38:44 <lambdabot> unexpected "d"
23:38:44 <lambdabot> ambiguous use of a non associative operator
23:38:56 <jayferd> JakeE: ^that
23:39:20 <Cale> the_berserker: I don't think @pl even knows that larger tuples exist
23:39:31 <the_berserker> Who is lambdabot?
23:39:40 <jayferd> a very smart person
23:39:40 <Cale> It uses a weird little untyped fragment of Haskell.
23:39:41 <sccrstud92> my uncle
23:39:52 <JakeE> jayferd: but I mean for any number of arguments. that is for 2 arguments it would be equivlent to flip. for 3 what you wrote. for 4 somthing else, etc...
23:39:55 <Cale> lambdabot is running on int-e's machine at present, iirc.
23:40:00 <Axman6> the_berserker: he's a guy in china who we pay to evaluate haskell for us
23:40:24 <jayferd> hmmmm varargs functions are hard
23:40:39 <JakeE> ya but maybe with typeclasses doable?
23:40:46 <Cale> jayferd: If you really think you need one, see Text.Printf for the trick
23:40:46 <jayferd> yeah potentially
23:40:56 <jayferd> JakeE: ^that
23:41:07 <jayferd> there was an article about this technique a bit ago lemme see if i can dig it up
23:41:13 <augur> hmm
23:41:33 <jayferd> JakeE: http://chris-taylor.github.io/blog/2013/03/01/how-haskell-printf-works/
23:41:48 <sccrstud92> JakeE: I think that (a -> b -> c -> t) -> (c -> a -> b -> t) is really flip in disguise
23:42:04 <the_berserker> > ((++"!!!!!").(++"rrrrrrrrrrrrgggggghhhh").(>>"aaa")) "Fuck you bitches!!"
23:42:05 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaarrrrrrrrrrrrgggggghhh...
23:42:07 <sccrstud92> you are flipping a -> b with c
23:42:22 <sccrstud92> oh wait nvrm
23:42:24 <sccrstud92> im dumb lol
23:42:30 <Cale> However, it's usually better not to set out to construct a function of a variable number of arguments. If the polymorphism that's naturally expressed ends up allowing your function to produce other functions as results in some cases and not others, then you'll end up with something like that in a more natural way. Forcing it usually results in awkwardness.
23:42:32 <JakeE> I make those mistakes ALL the time lol
23:43:10 <sccrstud92> JakeE: is there a good example fuction with that sig?
23:43:13 <sccrstud92> function*
23:43:38 <JakeE> it proabably wouldn't be 1 function but some crazy typeclass nonsense
23:43:39 <jayferd> printf is, in all honesty, awkward
23:44:05 <jayferd> despite its clever implementation
23:46:01 <Iceland_jack> jayferd: It's far more pleasing to the eye than "..." ++ show x ++ "..." ++ show y ++ "......." though
23:46:04 <JakeE> if you were wondering about the practicality of a rotate combinator it might ease a lot of point free code. like when you want to compose to just the 3 argument it would be (rot . rot $ f) . g
23:46:34 <Iceland_jack> If only it were type safe
23:46:41 <jayferd> yeah
23:46:45 <Cale> Iceland_jack: I think that sort of thing can be good if you replace the repeated ++ with concat or unwords
23:46:54 <triliyn> There's a typesafe printf somewhere
23:47:09 <Cale> I think mauke had one?
23:47:27 <Iceland_jack> Cale: That's an improvement :)
23:47:29 <jayferd> i mean, printf is basically a templating framework
23:47:43 <triliyn> I seem to remember chrisdone being involved... not sure though
23:47:49 <Iceland_jack> I'm partial to Rust's approach to make it a macro
23:47:55 <jayferd> yeah actually
23:47:57 <Iceland_jack> In the absence of dependent types
23:48:02 <JakeE> I feel as though some kind of depdent typing might allow vararg functions. I know I read somthing that was arguing AGAINST depdent typing that showed how to make a depdent zipN
23:48:21 <triliyn> http://hackage.haskell.org/package/formatting-3.1.0/docs/Formatting.html
23:48:33 <Cale> JakeE: It's not hard to do with dependent typing
23:48:47 <Cale> JakeE: But it's also not *that* hard with type classes alone
23:49:06 <JakeE> I should really learn Agda more :/ I'd like to know more about dependent typing
23:49:10 <bjz> Iceland_jack: Rust uses a syntax extension, which is abit more complex than a macro
23:49:29 <Cale> Oh, with dependent typing you can make a typesafe printf
23:49:44 <Iceland_jack> bjz: I haven't used Rust but the documentation call it a macro
23:49:49 <Cale> which actually parses the string to determine the type of the result
23:49:55 <Cale> (i.e. how many parameters)
23:49:56 <Iceland_jack> http://static.rust-lang.org/doc/0.3/tutorial.html: “The compiler defines a few built-in syntax extensions. The most useful one is #fmt, a printf-style text formatting macro that is expanded at compile time.”
23:50:10 <Cale> However, proving that the string will have the right structure will be tricky if it's a variable string
23:50:11 <bjz> Iceland_jack: I work on Rust as a contributor ^_^
23:50:11 <Twey> Guh.
23:50:27 <Axman6> you don;t need dependant typing to make zipN do you? unless you mean you specify n as a number and not just take a variable arity function
23:50:30 <bjz> Iceland_jack: woah 0.3 docs!
23:50:36 <Iceland_jack> Printf "Hello, %s\n" = String → String
23:50:47 <Cale> Axman6: right
23:50:48 <Iceland_jack> http://static.rust-lang.org/doc/master/std/fmt/index.html master
23:50:55 <bjz> Iceland_jack: http://static.rust-lang.org/doc/master/tutorial.html
23:51:10 <Cale> Axman6: if you just want a polymorphic zipN, you can use type classes
23:51:35 <triliyn> Using a pure string argument to printf is kinda silly
23:51:56 <triliyn> I prefer the approach taken in the Formatting package I linked
23:52:17 <Iceland_jack> triliyn: Yes that's a nice approach
23:52:26 <bjz> Iceland_jack: http://static.rust-lang.org/doc/master/tutorial.html#syntax-extensions
23:52:38 <Iceland_jack> bjz: Yes
23:52:49 <Iceland_jack> Thanks for clearing up my misunderstanding
23:52:49 <Cale> triliyn: I mean, what happens when you write  printf xs 1 2 3
23:52:54 <roboguy_> wow, I think this is the first time I realized that the 'f' in 'printf' probably stands for 'format'
23:53:10 <Iceland_jack> roboguy_: It stands for ‘f’ast
23:53:16 <Iceland_jack> print FAST
23:53:30 <bjz> print foolishly?
23:53:31 <Axman6> it should really be printn, print NAOW!
23:53:38 <Cale> triliyn: you suddenly have an obligation to discharge that xs is some string with three substitution markers in it, and that sort of thing can be tricky to prove
23:53:57 <Iceland_jack> I remember working on a system in the 80's that had PRINTS
23:54:05 <Iceland_jack> bad times
23:54:09 <triliyn> hmm
23:55:16 <maxs`> I have a lib that adds "syntax expressiosn" to C, and transforms them. But the only functions that use it are FFI generators. https://github.com/maxpow4h/cpppp/blob/master/tests/example.c
23:55:31 <JakeE> it would be nice if there was a binary operator, say .+ that had type Show a => a -> String -> String. x .+ y = show x ++ y
23:55:38 <maxs`> and I didn't know they were called "syntax expressions"
23:55:52 <JakeE> print $ x .+ y .+ z .+ a .+ ....
23:57:23 <sccrstud92> JakeE: not putStr?
23:57:41 <JakeE> o ya, putStr would be more like printf
