00:04:20 <xintron> Reading learn you a haskell and specifically about monads. runWriter - will that do more than unwrap the computation? Will it also be the one "forcing" it to evaluate just as if you were printing it?
00:06:26 <shachaf> runWriter does no forcing.
00:06:42 <shachaf> The newtype Writer isn't necessary at all.
00:06:59 <shachaf> You could have instance Monoid w => Monad ((,) w) instead. The newtype is just for convenience.
00:07:11 <shachaf> But Writer w a is exactly like (w,a)
00:08:27 <tdammers> hmm, I thought the newtype was to hide the implementation
00:08:50 <tdammers> to make sure the only way to access the Writer internals is through the blessed Writer methods
00:10:07 <simpson> In my view, the primary purpose is to make WriterT possible by making Writer w a newtype of WriterT w Identity.
00:10:21 <shachaf> But you can already convert back and forth using runWriter and writer.
00:10:23 <dleedev> why does "readLn >>= putStrLn" result in an exception in ghci?
00:10:51 <enthropy> because you're not typing something that can be parsed as a string
00:11:14 <simpson> Try "some string" with quotes. Should work.
00:11:50 <simpson> This is because putStrLn requires a String, and readLn reads in something belonging to Show.
00:11:55 <simpson> > show "some string"
00:11:57 <lambdabot>  "\"some string\""
00:12:21 <simpson> ...Er, belonging to Read. Clearly I'm up too late.
00:12:30 <simpson> > read "\"some string\"" :: String
00:12:31 <lambdabot>  "some string"
00:13:06 <BlankVerse_> Is it possible to set a custom -package-db in some config for ghc so that it need not be passed as argument to ghc?
00:15:11 <dleedev> simpson: hhmm... why didn't the type checker complain?
00:17:39 <dleedev> simpson: ah, never mind, I understand now
00:19:14 <simpson> dleedev: Right; the types get unified so readLn expects to read a String.
00:30:49 <enthropy> is there a straightforward way to get a "representative" body of haskell code?
00:30:59 <enthropy> for the purpose of deciding which extensions are most popular
00:33:27 <dleedev> enthropy: I'm interested in this as well
00:33:52 <enthropy> well I am just going to use hackage
00:34:05 <enthropy> github doesn't seem to let you search code in all repos
00:34:16 <enthropy> weight by "# of downloads"
00:34:31 <enthropy> check for LANGUAGE pragmas and also the extensions: field in the cabal file
00:35:32 <bergmark> "# of downloads" might be messed up, apparently a lot (all?) packages went down in download count
00:36:22 <bergmark> but the weight would probably be pretty similar
00:36:58 <mm_freak_> enthropy: hackage and hub.darcs.net
00:37:49 <mm_freak_> and i'd exclude packages/repos that haven't been updated for more than two years
00:38:06 <mm_freak_> you could probably also include github
00:40:30 <Lethalman> isn't there something like this already without using a new primitive? http://blog.ezyang.com/2014/01/when-a-lock-is-better-than-an-mvar/
00:40:37 <Lethalman> I remember seeing something about critical sections in hackage
01:31:20 * hackagebot data-size 0.1.1.5 - Profiling of data structures  http://hackage.haskell.org/package/data-size-0.1.1.5 (UweSchmidt)
01:46:22 * hackagebot inquire 0.1 - Console client for encyclopedias  http://hackage.haskell.org/package/inquire-0.1 (orbifx)
01:47:20 <jle`> you could do something like pagerank to rank packages by their significance
01:47:23 <jle`> perhaps
01:48:38 <donri> ie. revdeps?
01:55:46 <arnsholt> Revdeps are pretty much exactly the kind of thing PageRank uses, so that should be pretty doable
01:56:38 <merijn> arnsholt: revdeps already exists, is what donri was pointing out, afaict
01:59:38 <arnsholt> Yeah. I was agreeing with him
02:00:08 <dleedev> is it correct to say that monads carry two channels of information?
02:00:15 <dleedev> one for control, and one for effect?
02:00:33 <merijn> dleedev: Not really
02:00:50 <merijn> dleedev: What do you mean by "control" and "effect", for example?
02:01:17 <dleedev> merijn: the information in the control channel determine what information gets piped through the effect channel
02:01:38 <merijn> What is "the effect channel"?
02:02:44 <jle`> dleedev: usually we say that monads allow us to work with values in a context. maybe the context is what you are thinking of as control, and the value is waht you are thinking of as effect.
02:02:45 <merijn> dleedev: Consider the Maybe or tuple monad, what are the control and effect channels for these?
02:02:59 <dleedev> jle`: the opposite, actually
02:03:20 <dleedev> jle`: I'm thinking the values are returned to functions so that the function that properly bind more monads
02:03:29 <donri> monads carry effects and results ;)
02:03:47 <dleedev> jle`: and there's a value that gets passed from monad to monad behind the scenes
02:03:51 <donri> m for the effects and a for the result!
02:04:02 <dleedev> jle`: that behind the scenes passing from monad to monad is basically the effect
02:05:11 <dleedev> merijn: Maybe a >>= a -> Maybe a, right?
02:05:31 <individual> I import something in cabal's Setup.hs. When I have run cabal build, changing that something will not cause Setup.hs to be rebuilt. Is this intended?
02:05:35 <dleedev> merijn: err.... >>= :: Maybe a -> a -> Maybe a
02:05:51 <jle`> :t (>>=)
02:05:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:06:08 <donri> :t (>>=) `asAppliedTo` Nothing
02:06:09 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
02:06:16 <merijn> individual: cabal build/install don't invoke Setup.hs
02:06:25 <dleedev> jle`: thanks
02:06:30 <merijn> individual: Setup.hs is for installing on machines that do not have cabal-install
02:06:34 <jle`> i don't think the two-channels thing is a helpful illustration for monads in general
02:07:00 <jle`> why don't you give a concrete example of what you mean
02:07:02 <dleedev> so a is the values used for control (it helps what monad is returned in the second argument (a -> m b))
02:07:21 <dleedev> jle`: IO is a good example, I think
02:07:23 <merijn> individual: Unless you specify a custom build, in which case I think cabal does invoke Setup.hs, but you have to specify the right build type
02:07:28 <donri> maybe your distinction is like that of "applicative effects" vs the "control" monads get you over applicative
02:07:39 <individual> merijn: yes I have specified a custom build
02:07:57 <individual> Setup.hs most definitely runs (I have checked with putStrLns)
02:08:05 <donri> applicative gives you the effects, and with monads you can also make effects depend on each other
02:08:13 <dleedev> jle`: in IO a, a is the control value, and "World" (conceptually) is the type that is passed from monad to monad behind the scenes
02:08:39 <jle`> dleedev: how a bout a non State-like monad
02:08:41 <dleedev> jle`: each monad passes a modified World to the next
02:08:58 <merijn> I actually think IO is a terrible monad example as it's not very much like many other monads
02:09:09 <jle`> also the RealWorld State concept really isn't the best way to think about IO as a monad either :P
02:09:16 <merijn> dleedev: Also, the "World passing"-model of IO is pretty terrible
02:09:39 <dleedev> merijn: but that's how IO conceptually works, right?
02:09:43 <merijn> dleedev: No
02:09:55 <dleedev> merijn: although in reality, it does dirty stuff
02:09:57 <jle`> thinking of it that way actually impairs a lot of reasoning
02:10:01 <merijn> dleedev: It's how IO is implemented in GHC, which is a dirty implementation detail best forgotten
02:10:03 <jle`> especially with concurrency etc.
02:10:11 <donri> RealWorld is just an implementation detail to enforce strict state threads through data dependencies, it has little to do with actual I/O
02:10:36 <jle`> http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
02:10:44 <dleedev> alright, forget the IO / World example
02:10:59 <merijn> Once you add forkIO RealWorld is nonsensical, does it "conceptually" split the world into two copies and work concurrently on them and then allow communication between parallel universes
02:11:26 <dleedev> let's use Maybe as an example
02:13:01 <dleedev> Given Maybe x, x would go through the control channel and existence/presence would go through the effect channel
02:13:29 <donri> well monads can change the type of the result
02:13:45 <dleedev> I think a State monad probably gives the clearest picture of this two-channel concept
02:13:45 <jle`> monads are actually extremely general so it is somewhat fruitless to try to find a common characteristic/conceptual pattern through all of them, because any pattern you think of you can probably find a monad that defies it.  although i think i saw an interesting classification once of the useful monads into three categories.
02:14:17 <jle`> dleedev: yes but state monads != monads in general :P
02:14:39 <jle`> monads are an extremely general concept
02:14:47 <jle`> all you need is a bind and return that follow the monad laws
02:14:50 <c_wraith> It's hard to come up with a better description of monads than the type signatures of return and (>>=), and the laws that explain how they're related
02:14:51 <simpson> dleedev: Where's the second channel in Reader?
02:16:48 <jle`> dleedev: what about Gen?
02:16:50 <jle`> from quickcheck
02:17:06 <jle`> i guess Gen is state-like
02:17:31 <donri> dleedev: but yes, to some extent you're not completely off. people say monads let you model "side-effects" meaning pure values in combination with effects. it seems you call these pure values "control" which is a bit confusing but alas.
02:17:39 <c_wraith> Gen is more or less a state wrapper around a PRNG.  (except it's not really random)
02:17:56 <jle`> yeah.
02:18:07 <dleedev> simpson: in Reader, the environment would be in the effect channel
02:18:09 <mr-> c_wraith: return and >=> are better, of course!
02:18:19 <dleedev> simpson: it would also be passed through to the control channel
02:18:49 <dleedev> donri: I'm thinking you are understanding me the best
02:18:49 <donri> mr-: pure, join and fmap!
02:19:10 <jle`> dleedev: the main reason why this is shaky is because monads are literally just a mathematical construct.  yes you can see common usage/semantic patterns between many of them or a lot of them
02:19:14 <c_wraith> mr-: the laws are easier to describe that way. And it's much easier to describe that formulation to anyone who knows category theory. But to the completely uninitiated, I think (>>=) is more useful.
02:19:18 <jle`> but it is shaky to say that monads "are" something
02:19:23 <jle`> more than they actually are
02:19:31 <jle`> a lawful implementation of >>= and return
02:19:57 <mr-> donri: right, that's good too :-)
02:20:19 <dleedev> jle`: OK, then what about this: Monads are mathematical constructs that let you "do this side-channel thing"
02:20:36 <donri> dleedev: but yes, monads are abstract and general. you could think of a mathematical set as a box containing things, but that model easily breaks down too (like say a box of metaphorical concepts?). etc.
02:21:15 <eazar001> dleedev: i had this issue a long time ago
02:21:16 <c_wraith> dleedev: nah.  Side effects aren't really the point.  The point is it's an abstraction that lets you treat lots of things the same way.
02:21:17 <eazar001> I kept saying to myself what are monads?
02:21:18 <eazar001> what are they?
02:21:19 <dleedev> jle`: you want to easily "do side-channel thing" and the best model for that happens to be a mathematical model called a monad
02:21:19 <jle`> dleedev: they might allow you to do that, but that's not what they *are*
02:21:20 <eazar001> once i stopped trying to define them i had an easier time
02:21:27 <jle`> functions are things that allow me to add things together
02:21:29 <jle`> i want to add two things...i need a function
02:21:34 <jle`> therefore, functions are things to add things together.
02:21:34 <eazar001> dleedev: take my advice with a grain of salt .... just let go for now
02:21:37 <dleedev> jle`: exactly
02:21:42 <jle`> but it's not
02:21:46 <jle`> there are other functions besides (+)
02:21:53 <grohne> what are my options to track down memory usage of a progragam, if the --enable-executable-profiling causes "(GhcException You can't call hscCompileCoreExpr in a profiled compiler)"?
02:22:00 <jle`> and functions are useful for other things besides addition
02:22:15 <dleedev> jle`: but what would you use if you wanted to add two things?
02:22:32 <jle`> dleedev: you would use (+), a function, but that doesn't mean that functions *are* addition
02:22:37 <jle`> functions are functions
02:23:05 <jle`> you can also use them to, say...divide
02:23:21 <jle`> you can't say that monads *are* effects channels
02:23:40 <jle`> or are enablers of side effect channels etc.
02:23:45 <jle`> because they are more than that
02:23:50 <jle`> that's just one useful application
02:23:57 <merijn> Understanding monads in 5 easy steps: 1) Let go and stop worrying about what they are, 2) Learn to understand haskell types, 3) Learn to understand type classes, 4) Examine the monad typeclass and the laws defined for its functions, 5) Enlightenment.
02:24:01 <jle`> i'm not sure if i am making any sene
02:24:08 <c_wraith> jle`: I'd argue that they're less than that.
02:24:10 <dleedev> jle`: you are
02:24:19 <eazar001> agreed with merijn
02:24:28 <c_wraith> jle`: monad is just the pattern.  Any uses of it are irrelevant to what a monad is.
02:24:36 <jle`> c_wraith: good point
02:24:50 <jle`> even closer to what i was trying to say than what i was saying :P
02:25:01 <merijn> c_wraith: I think this is the usual "there are two ways to to look at things" confusion of more/less
02:25:18 <eazar001> they are vehicles that obey laws and have well defined operations
02:25:18 <c_wraith> probably :)
02:25:18 <eazar001> what monads are .... is completely up to you
02:25:19 <donri> well any use will vaguely satisfy this idea of two channels simply because of the types... how much you read into that is another question
02:25:19 <dleedev> jle`: and I guess my point is that the best pattern to use for side-channel information passing is to use a monad
02:25:31 <jle`> dleedev: best? relative :P
02:25:38 <merijn> c_wraith: Like monads are a superset of applicative functors in the sense that their operations are a superset of applicative, but monads are a subset of applicative functors because not all applicatives can be monad
02:25:41 <jle`> but haskellers like it
02:25:41 <c_wraith> merijn: I actually found understanding kinds to be important, too.  I had to understand that the class was on types with kind * -> * before I really got it.
02:25:57 <merijn> Understanding kinds is good in general
02:26:01 <jle`> i'll stop nitpicking now though :)
02:26:17 <merijn> I would actually put understanding kinds under learning types for haskell :p
02:26:44 <c_wraith> types of types...  kinds are metatypes! (ok, that term is probably used to mean something else)
02:27:15 <donri> kinds give you another channel in the type system... ok i'll shut up now
02:27:29 <merijn> Is there a special name for monoids that are commutative?
02:27:45 <c_wraith> just call 'em abelian, everyone will understand
02:27:55 <mr-> Yes, commutative monoid
02:28:29 <donri> won't people think of groups if you say only abelian
02:28:32 <mr-> And their category is called ComMon (sometimes CommMon :-)
02:54:29 <dleedev> it's been silent for a while... here's another question:
02:54:58 <dleedev> inasmuch as it is true that a program is run for its effects, is it true that all code in Haskell exists to properly compose IO monads together?
02:55:16 <ciaranm> no
02:55:46 <dleedev> ciaranm: how so?
02:56:01 <ciaranm> dleedev: there is nothing particularly special about IO
02:56:21 <dleedev> ciaranm: it's the only way a haskell program can cause an effect
02:56:32 <Hafydd> What about evaluating something by GHCi?
02:56:37 <_2_keishla> olaaa
02:56:57 <_2_keishla> hi
02:56:58 <dleedev> Hafydd: I'm assuming that underneath GHCi is an IO monad that's looping the REPL
02:57:13 <simpson> dleedev: This is kind of a philosophical question, isn't it?
02:57:20 <_2_keishla> bello
02:57:23 <Hafydd> dleedev: what about evaluating something in an interpreter that isn't written in Haskell.
02:57:29 <dleedev> simpson: I guess
02:57:35 <mbrock> heard a podcast with a terrorism expert talking to philosophers.  he wasn't interested in talking much about the "definition" of terrorism, preferring instead to discuss different varieties of terrorism along with the various tactical approaches to actually dealing with it.  I might write an article comparing monads to terrorism
02:57:53 <Hail_Spacecake> what's people's favorite 2d graphics library?
02:57:58 <Hail_Spacecake> ultimately I'm trying to write a raytracer
02:58:11 <Hail_Spacecake> and I just want to make individual points on an image be some rgb color
02:58:26 <_2_keishla> hellooo hail
02:58:29 <dleedev> Hafydd: I'm assuming even that is triggered by an IO monad underneath
02:58:34 <Hail_Spacecake> hello _2_keishla
02:58:54 <Hafydd> dleedev: no. Why should it be?
02:58:58 <simpson> dleedev: Even if the interpreter's language and substrate aren't Haskell?
02:59:09 <simpson> dleedev: How do you feel about Hugs evaluating a pure non-IO term?
02:59:10 <dleedev> Hafydd, simpson: conceptually
02:59:16 <_2_keishla> wat asmer
02:59:19 <Jeanne-Kamikaze> would anyone know how to access the installation directory from a hook other than a copy hook, i..e one that is triggered with cabal install? My documentation reading skills are failing me
02:59:22 <dleedev> I'm talking about a Haskell program, here
02:59:27 <simpson> dleedev: Conceptually Hugs is still written in C.
02:59:31 <Hafydd> What is a Haskell program?
02:59:39 <dleedev> a program written in Haskell
02:59:57 <Hafydd> Can it have a type other than IO a?
03:00:12 <dleedev> Hafydd: it can have all the types you want
03:00:20 <Hafydd> So it can have type [Int]?
03:00:22 <dleedev> Hafydd: but in the end, it's IO top to bottom
03:00:41 <jle`> dleedev: well there is a fair portion of haskell code in librries that have nothing to do with IO
03:00:45 <_2_keishla> helloooo mainemis keishla no o Pablo ingles
03:00:54 <jle`> in fact almost all of the code has nothing to do with IO
03:01:03 <dleedev> jle`: but they will never be run without being triggered by an IO monad
03:01:05 <jle`> so it's not really fair to say that all haskell code exists to compose IO monads
03:01:06 <Hafydd> dleedev: it sounds like the answer to your question is "yes" but your (narrow) definition of what a Haskell program is.
03:01:11 <jle`> they don't exist in order to compose IO monads
03:01:15 <jle`> they exist independently of them
03:01:19 <jle`> and if IO never existed
03:01:28 <_2_keishla> alguien suave español
03:01:29 <jle`> they would have been written exactly the same
03:01:29 <mbrock> this just hinges on the role of the "main :: IO ()" convention
03:01:29 <Hafydd> *by
03:02:05 <mbrock> which is basically just a kind of calling convention for writing Unix-like executables in Haskell, no?
03:02:08 <jle`> if IO did not exist, 99+% of haskell "code" would be exactly the same
03:02:10 <dleedev> jle`: and they would never be run, right?
03:02:26 <jle`> dleedev: yes, but they weren't thinking about it running when tehy wrote it
03:03:01 <jle`> that haskell code does not 'exist to compose IO monads'
03:03:13 <jle`> it exists on its own right for reasons that have nothing to do with IO monads
03:03:21 <jle`> or IO at all
03:03:57 <dleedev> I prefaced the question with "inasmuch as it is true that a program is run for its effects"
03:04:07 <dleedev> I should have said "inasmuch as it is true that a program written to be run for its effects"
03:04:15 <jle`> ah.
03:04:24 <jle`> well program does not necessarily imply all haskell code
03:04:29 <ciaranm> inasmuch as it is true that gerbils have six legs, can submarines swim?
03:04:35 <dleedev> ciaranm: yes
03:04:42 <jle`> because most haskell code is not an executable :P
03:05:17 <dleedev> I'm trying to imagine what's conceptually going on in a Haskell program
03:05:42 <dleedev> the image I come up with is a giant IO monad, composed with tiny IO monads
03:05:49 <jle`> well
03:05:54 <dleedev> interspersed between the tiny IO monads is your code
03:05:55 <jle`> a haskell *executable*
03:06:05 <jle`> is described by a composition of IO monads
03:06:24 <eazar001> dleedev: saying all haskell code exists to compose IO monads, is a bit like saying that humans exist to metabolize oxygen
03:06:29 <Guest82587> i am new to haskell. can someone help me write this function in a more concise form. andPredicate pred1 pred2 val = (pred1 val) && (pred2 val)
03:06:30 <dleedev> and the giant IO monad, composed of tiny IO monads, form a tunnel or pipe
03:06:39 <dleedev> and the World passes through the tunnel or pipe
03:06:44 <eazar001> the things i do wouldn't be possible without consumption of oxygen, but i don't exist solely for that purpose
03:06:50 <dleedev> and comes out a different World
03:07:16 <jle`> here is a kind of look conceptually at a haskell exectuable -- http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
03:07:22 <jle`> aw darn the site is down
03:07:25 <jle`> can someone contact the admin
03:07:34 <ciaranm> dleedev: the "World as a parameter" way of thinking about things is a bad idea
03:07:53 <dleedev> ciaranm: how else would you think about it in a functional pure programming world?
03:08:01 <jle`> i contacted him, he fixed it
03:08:06 <jle`> dleedev: check out the article, it explains :P
03:08:18 <ciaranm> dleedev: monads
03:08:41 <dleedev> ciaranm: that's exactly what I'm saying... conceptually, the world passes through the IO monad
03:08:46 <ciaranm> dleedev: but it doesn't
03:08:50 <tdammers> you ignore the world altogether; instead you just use a pure expression to construct an imperative program
03:09:07 <Guest82587> i am new to haskell. can someone help me write this function in a more concise form. andPredicate pred1 pred2 val = (pred1 val) && (pred2 val)
03:09:09 <dleedev> imperative program is conceptually illegal
03:09:22 <tdammers> it's not
03:09:35 <tdammers> the imperative part isn't written in Haskell
03:09:57 <jle`> Guest82587: try @pl :)
03:10:02 <tdammers> you write a pure expression which, when evaluated, yields an opaque data structure which is your imperative program
03:10:13 <ChongLi> @pl andPredicate pred1 pred2 val = (pred1 val) && (pred2 val)
03:10:14 <lambdabot> andPredicate = liftM2 (&&)
03:10:20 <tdammers> you can't inspect or run the program from within Haskell (unsafePerformIO notwithstanding)
03:10:22 <ChongLi> Guest82587: there you go
03:10:37 <dleedev> tdammers: that I understand is what's actually going on
03:10:49 <jle`> Guest82587: I prefer applicative instance of function though
03:10:51 <tdammers> the only way to run it is to point the runtime at it by making Main.main evaluate to it
03:11:21 <ChongLi> the key insight, for me, is realizing that the evaluation of that data structure is interleaved with the execution of the side effects
03:11:38 <tdammers> 'interleaved' is maybe the wrong word
03:11:41 <tdammers> or maybe not
03:11:43 <dleedev> which conceptually is the same thing as passing the World (not a Haskell type, but the real world) through an IO monad
03:11:58 <ciaranm> dleedev: it's not!
03:11:59 <ChongLi> it's like if the C preprocessor was a lazy language
03:12:13 <ChongLi> and this didn't happen until runtime
03:12:20 <ciaranm> dleedev: conceptually they're very very different
03:12:43 <ChongLi> you'd realize pretty quickly how important the control of side effects are in that scenario
03:12:48 <Guest82587> jle`: can you please elaborate? what is @pl?
03:12:50 <tdammers> IO values are just values, from a Haskell point of view
03:12:55 <dleedev> ciaranm: one constructs a set of instructions to mutate the world, one constructs a monad in which a world is passed through to exit a different world
03:12:57 <tdammers> nothing gets passed in or anything
03:13:08 <ciaranm> dleedev: there is no passing through. this is important.
03:13:19 <dleedev> ciaranm: I understand there is no passing through in actuality
03:13:29 <eazar001> the IO monad can obtain something from the world
03:13:33 <ciaranm> dleedev: not even conceptually. this is important.
03:13:36 <eazar001> but the world cannot pass through it
03:13:49 <ciaranm> dleedev: if you insist upon thinking about a World (which you shouldn't), conceptually an IO () is a sequence of steps which are allowed to talk to the World. there is no passing around of the World.
03:14:23 <dleedev> ciaranm: but it's more than talking, it has to change the World
03:14:28 <ciaranm> dleedev: if World were passed around, conceptually, then you would be able to copy it and go back to an earlier state of the World. you can't do this.
03:14:32 <ChongLi> Guest82587: @pl is a feature of lambdabot
03:14:46 <dleedev> ciaranm: only because of the difficulty of implementation
03:14:46 <eazar001> it can change the world
03:14:56 <eazar001> but it minimizes it as much as possible by isolating the pure from the impure
03:14:58 <dleedev> ciaranm: and by difficulty, I mean impossibility
03:15:05 <ChongLi> it converts expressions into point-free style (eta-conversion)
03:15:29 <ciaranm> dleedev: but that's the point! you can't copy the World, so the whole "passing around" analogy is wrong.
03:15:47 <mbrock> yet GHC uses it!
03:15:57 <dleedev> ciaranm: you can't copy the World only because implementation of it is impossible
03:16:15 <ciaranm> dleedev: so your analogy is bad
03:16:27 <dleedev> ciaranm: but I'm talking about concepts, not implementation
03:16:30 <ciaranm> dleedev: and so long as you continue to think that way, you won't understand what's really going on
03:16:53 <ciaranm> dleedev: conceptually, you aren't understanding it, and you're stuck with an analogy which makes understanding it impossible
03:17:01 <Guest82587> ChongLi: ok. i will look into it. can you think of a point-free version of this function?
03:17:04 <dleedev> ciaranm: I already understand what's actually going on
03:17:10 <ciaranm> dleedev: evidently not...
03:17:18 <dleedev> ciaranm: I understand that what's going on under the scenes is what you're describing
03:17:31 <dleedev> ciaranm: I'm not trying to describe what's actually happening...
03:17:36 <ChongLi> Guest82587: I gave on earlier
03:17:41 <ChongLi> @pl andPredicate pred1 pred2 val = (pred1 val) && (pred2 val)
03:17:41 <lambdabot> andPredicate = liftM2 (&&)
03:18:04 <dleedev> ciaranm: I'm trying to describe how you can imagine a haskell program is executed in a purely functional world
03:18:31 <ciaranm> dleedev: kleisli category explains all.
03:18:32 <dleedev> ciaranm: in a purely functional world, you can't apply a set of instructions to the world, because the world can't mutate
03:18:45 <ciaranm> dleedev: kleisli category.
03:18:49 <Guest82587> thanks lambdabot. this is what i was looking for. now i just need to learn about this liftM2
03:19:06 <ChongLi> Guest82587: and that is a whole can of worms :)
03:19:16 <simpson> dleedev: It might interest you to know that not all Haskell implementations use a World value for IO.
03:19:22 <ChongLi> Guest82587: you may want to learn Functors first
03:19:44 <dleedev> simpson: I understand. I didn't even know GHC used a World value.
03:19:57 <dleedev> simpson: I'm speaking conceptually here
03:19:57 <quicksilver> GHC doesn't really use a World value
03:20:20 <Guest82587> ChongLi: do you know of any good resources? i am currently reading lyah
03:20:21 <quicksilver> it's a syntactic hack which exploits GHC's compilation method.
03:20:30 <mr-> @src liftM2
03:20:30 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
03:20:31 <ChongLi> Guest82587: lyah is a good one
03:20:44 <Lethalman> @src liftA2
03:20:44 <lambdabot> liftA2 f a b = f <$> a <*> b
03:20:45 <dleedev> May I state once and for all that I'm not speaking about what's ACTUALLY going on? I'm speaking conceptually here.
03:20:59 <dleedev> none of the code in Haskell ever runs functionally, they're all converted to imperative steps.
03:21:04 <ciaranm> dleedev: conceptually, kleisli category.
03:21:15 <simpson> dleedev: Yes, one can compute by graph reduction.
03:21:16 <eazar001> that's what actually happens
03:21:17 <dleedev> but we like to think about haskell programs functionally, because it's a nice abstraction
03:21:28 <ciaranm> haskell programs are functional
03:21:33 <ciaranm> IO is functional
03:21:33 * hackagebot log-effect 0.2.0.1 - An extensible log effect using extensible-effects  http://hackage.haskell.org/package/log-effect-0.2.0.1 (ibotty)
03:21:34 <ciaranm> deal with it
03:21:42 <dleedev> ciaranm: IO is functional, yes!
03:22:20 <dleedev> ciaranm: the question is, conceptually, what is IO used for mapping?
03:22:48 <dleedev> ciaranm: and I'd say conceptually, IO is used for mapping an old World to a new World
03:23:09 <simpson> Alternatively, IO is a completely opaque type that happens to have a Monad instance.
03:23:19 <ciaranm> dleedev: but it isn't
03:23:35 <Guest82587> thanks ChongLi. just realised lambdabot is really a bot :)
03:23:36 <ciaranm> dleedev: that's a bad concept
03:23:42 <ChongLi> Guest82587: :)
03:23:42 <dleedev> ciaranm: which part is bad?
03:23:52 <ciaranm> dleedev: the part where it implies things which aren't true
03:23:55 <eazar001> lol 82587
03:23:58 <eazar001> that was cute
03:24:04 <dleedev> ciaranm: all of programming is an abstraction
03:24:37 <dleedev> ciaranm: when you write a function in haskell, it doesn't remain a pure function, it gets converted to bytes
03:24:43 <ciaranm> dleedev: yes, and there is a very nice abstraction for IO which doesn't suggest things which aren't true.
03:24:46 <simpson> Programming might sometimes be abstract, but it's not really an abstraction; various sorts of computation might be equivalent, but none of them are *the* computational model.
03:24:52 <ciaranm> dleedev: that abstraction is in fact IO...
03:26:21 <dleedev> ciaranm: OK, let's say this, then. You're stuck in Haskell-land. You can only imagine things in the Haskell-way.
03:26:37 <dleedev> you can't run imperative programs
03:26:49 <dleedev> how do you conceptualize IO monads?
03:27:07 <tdammers> dleedev: they're just values
03:27:09 <dleedev> everything must be functional and nothing may mutate
03:27:22 <tdammers> they're pure values, and nothing mutates
03:27:32 <tdammers> you're not interacting with the world
03:27:39 <tdammers> there is no world
03:27:52 <ciaranm> dleedev: one way of viewing it is as the free identity monad, with some extra functions and equations shoved in
03:27:59 <dleedev> tdammers: you can represent the world as a pure value
03:28:08 <ciaranm> you can't represent the world as a pure value
03:28:15 <simpson> dleedev: Well, first things first. Let's build `data Stack a = Stack [a] | Empty`
03:28:27 <tdammers> ciaranm: you can, theoretically speaking, but it doesn't make a lot of sense
03:28:31 <eazar001> f(x)=x+2
03:28:33 <eazar001> that is functional
03:28:37 <eazar001> it doesnt change
03:28:51 <eazar001> think about it algebraically?
03:28:57 <eazar001> it just is
03:29:04 <eazar001> my pencil from the world ....
03:29:06 <dleedev> eazar001: exactly
03:29:07 <simpson> dleedev: And now let's build some operations: `push (Stack as) a = Stack a:as` and `pop (Stack (a:as)) = Stack as`
03:29:08 <eazar001> can feed it the number 2
03:29:12 <tdammers> ciaranm: mostly because travelling through time or between alternate universes is not a thing yet
03:29:16 <simpson> dleedev: (Extra cases left as an exercise for you)
03:29:17 <eazar001> but f(x) is still f(x)
03:29:20 <simpson> dleedev: And now we can program in Forth!
03:29:26 <mbrock> when I imagine Haskell land, it feels like I'm inside of mathematics, and questions of I/O are similar to an engineer asking "but where are the actual bricks and girders?"
03:29:32 <ciaranm> tdammers: that's precisely dleedev's problem, though: he thinks that's a technicality
03:29:42 <eazar001> dleedev: so what are you trying to say then?
03:29:45 <simpson> dleedev: Forth is far superior to Haskell anyway.
03:30:10 <dleedev> eazar001: one may imagine the world to be a value of type World
03:30:12 <tdammers> ciaranm: well, technically it is :P
03:30:19 <dleedev> eazar001: analogous to State
03:30:30 <eazar001> you're fighting the current dleedev
03:30:42 <eazar001> haskell is not an entity trying to lie to you
03:30:45 <zomg> I'm probably the only person who keeps being reminded of JoJo's Bizarre Adventure with all this discussion about "The World"
03:30:48 <zomg> lol
03:30:49 <mbrock> talking about "the world" is obviously frought with immense philosophical difficulties!
03:30:50 <eazar001> these "abstractions" are there to help you
03:31:03 <eazar001> it's not trying to feed you propoganda
03:31:14 <tdammers> dleedev: IO is not a State
03:31:18 <eazar001> people talk about purity, because it helps foster a greater understanding of pure functional programming
03:31:20 <eazar001> that's all
03:31:42 <tdammers> dleedev: if it were, you could do something like do { world <- get; putStrLn "Hello, world!"; set world }
03:31:57 <tdammers> and your output would be magically undone
03:32:16 <tdammers> probably by travelling back in time, or by transporting you into an alternative universe where the output never happened
03:32:17 <haasn> @hackage acme-realworld tdammers ;)
03:32:17 <lambdabot> http://hackage.haskell.org/package/acme-realworld tdammers ;)
03:32:22 <dleedev> tdammers: that's exactly what I'm saying!
03:32:48 <mbrock> we should maybe acknowledge that this is by no means an easy problem -- and that if you look at GHC's internals, IO is actually a State... and that this conceptualization is not an unheard-of crackpot idea
03:33:02 <mbrock> it's just been shown to be fairly problematic, especially in the presence of concurrent effects and so on
03:33:05 <dleedev> World is a type where each value is a snapshot of the world
03:33:15 <tdammers> yes, I understand the concept
03:33:26 <haasn> you can get rid of RealWorld by treating IO as a free monad instead
03:33:32 <dleedev> tdammers: so you understand the concept
03:33:43 <dleedev> tdammers: what part of the concept is bad?
03:33:50 <haasn> but GHC doesn't do that for various reasons, none of which matter to the end user since it's internal
03:33:51 <dleedev> tdammers: not the implantation, just the concept
03:34:09 <dleedev> tdammers: sorry, implementation (*bad autocorrection)
03:34:25 <tdammers> being able to save and restore snapshots is kind of integral to the State concept
03:34:38 <dleedev> tdammers: and conceptually possible with World too
03:34:43 <tdammers> dleedev: no
03:34:49 <eazar001> dleedev: would you say that the sole purpose of C code is to accept input?
03:34:57 <tdammers> dleedev: unless you accept time travel or alternate universes as conceptually sound
03:35:14 <dleedev> eazar001: the premise is that all programs are to cause effect
03:35:30 <dleedev> tdammers: if God programmed in Haskell, this is how he would have implemented it
03:35:38 <mbrock> can you give a coherent explanation of forkIO in terms of State World?
03:35:54 <eazar001> dleedev: okay that's the premise, what is your conjecture then?
03:35:56 <dleedev> tdammers: if God wanted to program in Haskell in a pure way, he would use a World type
03:36:08 <ciaranm> no he wouldn't. he'd use monads.
03:36:12 <eazar001> or conclusion if that's what you're aiming for?
03:36:16 <dleedev> and pass that world through the IO monad
03:36:39 <ciaranm> there is no passing.
03:36:43 <dleedev> ciaranm: the monads are simply a way to manipulate the world
03:36:47 <eazar001> you can't pass an entire computer monitor through a monad
03:36:49 <eazar001> yet
03:36:54 <ciaranm> dleedev: uh huh. but there is no passing.
03:37:11 <dleedev> ciaranm: what do you mean "there is no passing?"
03:37:11 <tdammers> dleedev: you know, the State RealWorld thing has been tried before, and it turned out to be highly problematic
03:37:31 <dleedev> tdammers: how was it highly problematic?
03:37:40 <dleedev> tdammers: I'd assume on implementation-wise, not conceptually
03:37:43 <ciaranm> dleedev: i mean, IO does not work that way
03:37:48 <tdammers> dleedev: both
03:37:56 <tdammers> dleedev: concurrency is a big problem
03:37:56 <dleedev> eazar001: but I'm talking about concepts here, not implementation
03:38:07 <tdammers> dleedev: both conceptually and implementation wise
03:38:21 <dleedev> tdammers: now this is something I want to hear... please explain more
03:38:23 <eazar001> dleedev: if you mean for that for an effect to be produced that ....
03:38:29 <ciaranm> dleedev: there is already a perfectly good concept for computation, and IO is it.
03:38:36 <eazar001> humans need to make meaninful use of it by seeing the result with their own eyes ....
03:38:39 <eazar001> then yes you are right
03:38:56 <eazar001> i will not deny that
03:38:57 <mbrock> dleedev: one big problem is concurrency
03:39:06 <dleedev> ciaranm: but there are different ways to conceptualize IO
03:39:16 <mbrock> dleedev: here's an article you might find interesting: http://blog.ezyang.com/2011/05/unraveling-the-mystery-of-the-io-monad/
03:39:29 <ciaranm> dleedev: uh huh, and IO is the correct abstraction over all of those ways
03:39:34 <mbrock> dleedev: read the comments also for some discussion of the problems with State World
03:40:53 <mbrock> dleedev: ezyang at one point calls the State model an "incomplete and inaccurate, but *adequate* denotational model for IO," which conal has some strong objections to
03:40:54 <dleedev> ciaranm: I agree with you that IO is the correct abstraction
03:41:10 <dleedev> ciaranm: what we're dealing with is how to conceptualize IO
03:41:21 <eazar001> that yang guy has some pretty well written blogs
03:41:25 <mbrock> the whole thing is a pretty interesting and non-trivial discussion and actually touches on some open questions
03:41:30 <ciaranm> dleedev: you conceptualise it by understanding the IO monad
03:41:48 <dleedev> ciaranm: what do you mean by "understanding"?
03:42:41 <eazar001> dleedev: investigating monads more itensely might help
03:42:43 <ciaranm> dleedev: i mean you need to know what a monad is. even more ideally, you need to understand what a monad really is, and the kleisli category, and concepts like freeness.
03:42:44 <eazar001> monads in general
03:42:58 <eazar001> intensely**
03:42:59 <JuanDaugherty> understanding is about as primitve as "truth" but harder to define
03:43:17 <JuanDaugherty> more fundamental though
03:43:38 <ciaranm> dleedev: the way to understand IO is to understand monads in general, and see that IO is just a monad that's defined by having certain extra properties
03:43:48 <eazar001> JaunDaughtery: yea, it is hard to define
03:44:14 <JuanDaugherty> pretty sure unlike judgements there's no (at least no well know) mathesis of it
03:44:15 <eazar001> it's kind of like taking it all in but not trying to grasp it all in one ball
03:44:15 <JuanDaugherty> (outside AI)
03:45:07 <eazar001> buddhist like almost
03:45:57 <dleedev> mbrock: thanks for the article
03:46:20 <dleedev> I guess the main objection to the RealWorld (borrowing article's terminology) is fork/threads?
03:46:29 <dleedev> are there other objections?
03:46:35 <ciaranm> dleedev: uh huh. you can't save and restore world.
03:46:50 <dleedev> ciaranm: again, you're talking about implementation, not concepts
03:47:02 <ciaranm> dleedev: uh, no. conceptually, you can't save and restore the world.
03:47:08 <dleedev> ciaranm: let's imagine that we're gods, able to manipulate time and world
03:47:13 <ciaranm> we're not
03:47:18 <ciaranm> that's a bad concept
03:47:25 <dleedev> ciaranm: why is that a bad concept?
03:47:37 <eazar001> ciaranm: okay seriously ....
03:47:37 <ciaranm> dleedev: because you can't manipulate time and world
03:47:43 <eazar001> try to see it from his point of view
03:47:53 <eazar001> you really are manipulating the world now, aren't we?
03:47:57 <dleedev> ciaranm: if you're God, then you can
03:48:04 <ocharles> dleedev: I'm not sure that saving the state of the world makes sense because that's inherently recursive - saving the world depends on the state of yourself which depends on saving the state of the world which depends on...
03:48:23 <dleedev> ocharles: an initial World state - creation
03:48:26 <ciaranm> dleedev: can this god of yours solve the halting problem?
03:48:46 <dleedev> ciaranm: don't know, you're the god
03:48:48 <simpson> dleedev: http://en.wikipedia.org/wiki/Laplace's_demon
03:48:51 <dleedev> ciaranm: you can manipulate time and world
03:49:12 <dleedev> ciaranm: you can save every snapshot of the world as a pure value
03:49:19 <eazar001> dleedev: you can manipulate time and world ... but a haskell program doesn't HAVE to
03:49:30 <simpson> dleedev: Read what I linked first.
03:49:35 <ciaranm> dleedev: well if you're inventing an impossible model of computation, why stick to one impossibility?
03:49:57 <eazar001> your needs for a haskell program is not the definition of what its sole motivation is... that is relative to your mind
03:50:27 <eazar001> its the same mistake one makes by trying to pigeonhole a monad ...
03:50:39 <eazar001> by doing that ... you make monads one-dimensional
03:50:45 <dleedev> ciaranm: because it's a good conceptual model
03:50:55 <dleedev> ciaranm: it uses IO :)
03:51:23 <ciaranm> dleedev: it's a crap conceptual model, because it's full of impossibilities. and it's extra crap because we have a better conceptual model which is exactly right.
03:51:44 <dleedev> ciaranm: but not pure
03:51:55 <ciaranm> dleedev: yes pure.
03:52:18 <dleedev> ciaranm: how do you cause an effect in the world?
03:52:51 <ciaranm> dleedev: you don't. you describe a sequence of actions which would cause an effect, if such a thing as the world existed.
03:52:51 <Philonous> dleedev, You don't. You only create a description/program for that effect.
03:53:00 <merijn> dleedev: Have you read the compromiseless reconciliation of purity article that was linked?
03:53:12 <merijn> dleedev: It explains this entire thing very well
03:53:41 <dleedev> merijn: that one was down, but it's up now, I'll take a quick glance
03:53:59 <ciaranm> dleedev: don't take a quick glance. give it a long, slow, careful read.
03:55:07 <dleedev> ciaranm: I'm already familiar with the concept
03:55:22 <dleedev> ciaranm: please understand this. It's not that I don't understand your concept.
03:55:33 <dleedev> ciaranm: and the article gave me a good name for it: "Instructions as Data Structures"
03:55:45 <ciaranm> dleedev: you've shown plenty of evidence that you don't actually understand it at all
03:56:02 <dleedev> ciaranm: I understand it. Why do you think I don't?
03:56:17 <dleedev> ciaranm: understanding it and agreeing it are different things
03:56:31 <ciaranm> dleedev: the way you keep making statements that are consistent with someone who thinks they understand it but actually don't, but not consistent with an actual understanding
03:56:34 <dleedev> ciaranm: one can understand classical physics and disagree with it
03:57:02 <dleedev> ciaranm: please give me an example of what I wrote that demonstrates that I don't understand your concept
03:57:22 <eazar001> classical physics is arguably more debatable don't you think?
03:57:32 <dleedev> eazar001: just a quick analogy
03:57:34 <ciaranm> dleedev: the way you keep talking about viewing it as "passing around world"
03:57:50 <dleedev> ciaranm: because I'm trying to argue for that point of view...
03:58:03 <dleedev> ciaranm: do you understand that understanding and agreeing are different?
03:58:04 <eazar001> dleedev .... there is no world value ...
03:58:08 <eazar001> and IO () ...
03:58:08 <ciaranm> dleedev: that point of view is completely different
03:58:10 <eazar001> is an empty tuple
03:58:13 <eazar001> that is your result
03:58:16 <eazar001> not the world
03:58:32 <eazar001> it signifies nothing ... except that  side effect potentially occurred
03:58:34 <dleedev> eazar001: what are you talking about?
03:58:44 <eazar001> i'm not takling about passwing the world
03:58:45 <ciaranm> dleedev: it's like saying "i understand the bohr model of the atom, and i want to explain it in terms of flying monkeys"
03:58:46 <eazar001> it's not happening
03:58:55 <eazar001> it just doesn't happen dleedev
03:59:02 <eazar001> you can create side effects ...
03:59:04 <eazar001> yes
03:59:06 <eazar001> not in the program
03:59:09 <eazar001> but in the world yes
03:59:16 <eazar001> that is the point of the IO
03:59:24 <eazar001> when i have IO MONAD ....
03:59:31 <eazar001> the result is an IO TUPLE
03:59:34 <eazar001> which is ()
03:59:37 <Philonous> eazar001, What are you walking about?
03:59:47 <Philonous> talking, even
04:00:09 <eazar001> errr just trying to understand his whole passwing the world around argument
04:00:14 <eazar001> i don't agree with it
04:00:42 <dleedev> ciaranm: It's like I understand the bohr model, but I'm trying to explain the quantum model
04:00:45 <eazar001> but i guess i never fully understood the conclusion dleedev was trying to arrive at
04:00:57 <eazar001> dleedev: what is your conclusion?
04:01:08 <ciaranm> dleedev: it really isn't...
04:01:54 <dleedev> ciaranm: do you really think I don't understand the concept of "Instructions as Data Structures"?
04:02:09 <ciaranm> dleedev: yes
04:02:21 <simpson> dleedev: Do you know Godel numbering?
04:02:26 <Philonous> dleedev, I don't know this concept, can you please elaborate?
04:02:29 <dleedev> simpson: no
04:02:56 <dleedev> Philonous: "Instructions as Data Structures" is ciaranm's point of view, and is well explained here: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
04:03:19 <ciaranm> my point of view isn't "instructions as data structures". my point of view is that IO is a monad.
04:03:26 <dleedev> Philonous: it's the commonly accepted point of view
04:03:34 <dleedev> ciaranm: I agree that IO is a monad
04:03:45 <dleedev> ciaranm: I've repeated that several times now
04:04:28 <dleedev> Philonous: basically, it's understanding the IO monad as "actions" or "instructions"
04:04:37 <ciaranm> dleedev: no no. my point of view is that IO is a monad, and that's exactly what IO is. yours is that IO is a monad, but the monad is somehow implemented in terms of "passing around real world". there's a very important difference.
04:04:49 <dleedev> Philonous: composing IO monads results in "actions" or "instructions" being composed/stacked/ordered
04:05:02 <ciaranm> (you don't compose monads)
04:05:08 <ciaranm> composing monads means something else
04:05:56 <Philonous> ciaranm, I don't think it's important that IO is a monad. The point is that IO actions are values. They could just as well support some other kind of interface
04:06:10 <dleedev> ciaranm: sorry, what word should I have used instead of "compose"?
04:06:22 <eazar001> execute?
04:06:34 <ciaranm> dleedev: you compose actions. "actions" is a friendly name for "arrows in the kleisli category over the IO monad".
04:06:46 <eazar001> evaluate
04:06:48 <dleedev> ciaranm: then I do mean compose
04:06:59 <ciaranm> dleedev: no. you compose the *actions*, not the *monads*
04:07:02 <renjith> hi all.. i was just trying out haskell..
04:07:18 <dleedev> ciaranm: then what's the word I'm looking for.... "bind"?
04:07:51 <ciaranm> dleedev: no. you don't talk about the monads at all. an "IO ()" isn't an IO monad.
04:08:07 <Philonous> dleedev, OK, I think that blog post is misleading. It should say "values" instead of "data structures"
04:08:26 <ciaranm> dleedev: what you're composing is functions in a category, not monads. composing monads is something else.
04:08:34 <eazar001> dleedev: i'll send you a futurama episode that explains this all [;
04:09:32 <renjith> Prelude> func x = x +1
04:09:32 <renjith> <interactive>:2:8: parse error on input `='
04:09:33 <renjith> Prelude> func x = x +1
04:09:33 <renjith> <interactive>:2:8: parse error on input `='
04:09:33 <renjith> Prelude> func x = x +1
04:09:33 <renjith> <interactive>:2:8: parse error on input `='
04:09:37 <dleedev> ciaranm: what do you call it when you line up monads like this f >=> g >=> h?
04:09:52 <ciaranm> dleedev: kleisli composition of *functions*. not monads.
04:09:59 <ciaranm> dleedev: you are not lining up monads there.
04:10:10 <dleedev> ciaranm: well, you're lining up functions that return monads
04:10:19 <dleedev> ciaranm: that's what I"m trying to get at
04:10:19 <Philonous> dleedev, The point is that (print "hello world") is a value just like an Int or a Bool and you can pass it around and store it in a dictionary and whatnot. But you don't get to execute it. All you do is compose those values into a big value, and call it "main".
04:10:20 <ciaranm> dleedev: no. f, g and h are not monads in your example.
04:10:32 <dleedev> ciaranm: I know that f, g, and h are not monads
04:10:42 <dleedev> ciaranm: they're functions that return monads
04:10:54 <dleedev> Philonous: precisely
04:10:55 <ciaranm> dleedev: no. they're functions that return monadic values.
04:11:11 <ciaranm> dleedev: they are not monads, and they do not return monads.
04:11:30 <dleedev> ciaranm: OK, monadic values
04:11:57 <Philonous> dleedev, Your terminology is wrong. They return monadic values (or "actions"). A monad is an entire set/type of such values (plus some operations on them)
04:11:59 <ciaranm> dleedev: the differences here are important. you need to understand this before we can have a useful discussion...
04:12:13 <dleedev> Philonous: yes, I understand
04:12:21 <dleedev> Philonous: sorry about the terminology mixup
04:12:57 <dleedev> ciaranm: I understand the differences, sorry about the mixup
04:13:28 <dleedev> anywho, the question is what does lining up these functions that return monadic values amount to
04:13:44 <simpson> Another value.
04:14:03 <Philonous> dleedev, Btw. your world-passing model isn't entirely wrong. You can understand the semantics of IO that way, but it's not a particularly good model. For one it can't explain concurrency.
04:14:05 <dleedev> simpson: yes, what does that value represent?
04:14:22 <ciaranm> dleedev: kleisli composition forms a category. that's the point.
04:14:31 <merijn> Philonous: "it can't explain concurrency", so you're saying you *can't* understand the semantics of IO that way
04:14:35 <dleedev> Philonous: I would argue the only reason concurrency doesn't work is because of impure elements
04:14:48 <Philonous> merijn, Well, yes. But any model has limitations.
04:14:49 <merijn> dleedev: There are no impure elements
04:15:03 <ciaranm> there's no such thing as impurity
04:15:05 <simpson> dleedev: It's a value.
04:15:11 <Philonous> merijn, That's why it's not a particularly good model.
04:15:18 <merijn> Aside from unsafePerformIO and friends there is no impurity in Haskell
04:15:22 <dleedev> merijn: is concurrency a concept in the functional world?
04:15:28 <merijn> Hence why it's a *purely* functional language
04:15:30 <Philonous> unsafePerformIO isn't even in Haskell
04:15:36 <merijn> Philonous: It is in Haskell2010
04:15:54 <Philonous> merijn, Really?
04:16:00 <merijn> Philonous: in 98 it was part of the FFI addendum, but now that the FFI is part of haskell2010 so is unsafePerformIO
04:16:01 <Taneb> merijn, no it isn't
04:16:14 <dleedev> merijn: I'd say that concurrency *cannot* be implemented in Haskell, it must be provided from outside of Haskell, since concurrency is not a functional concept
04:16:21 <Taneb> Unless it's in a weird place
04:16:48 <Taneb> https://maths.york.ac.uk/moodle/pluginfile.php/60854/mod_resource/content/1/calc_jan2013%20corrected.pdf
04:16:55 <Taneb> Sorry, wrong link
04:16:58 <Taneb> http://www.haskell.org/onlinereport/haskell2010/
04:17:11 <dleedev> any who, the debate is on how we should understand the resulting monadic value
04:17:13 <simpson> dleedev: According to whom? Are you familiar with pi calculus?
04:17:20 <simpson> dleedev: It's a value.
04:17:21 <AshyIsMe> hmm
04:17:22 <ciaranm> dleedev: it's a value in the kleisli category over the IO monad
04:17:27 <AshyIsMe> does the vim2hs author hang out in here?
04:17:54 <donri> AshyIsMe: he does
04:18:04 <AshyIsMe> he recommends using this https://github.com/kana/vim-textobj-indent
04:18:05 <ciaranm> dleedev: there is absolutely no difference between an "IO a" that comes from a function, and the >=> composition of two such functions
04:18:14 <dleedev> ciaranm: yes, and what should we do with the monadic value at the end?
04:18:20 <AshyIsMe> but i get vim startup errors trying to load that plugin
04:18:27 <ciaranm> dleedev: it's the type of main
04:18:35 <donri> AshyIsMe: did you install vim-textobj-user also?
04:18:37 <AshyIsMe> unknown function textobj#user#plugin
04:18:44 <AshyIsMe> oh, nope
04:18:46 <AshyIsMe> heh
04:18:55 <dleedev> ciaranm: yes, and what happens after that?
04:19:04 <merijn> Taneb: Last time I said unsafePerformIO someone linked me part of haskell2010 that stated it was, but now I can't find it
04:19:11 <dleedev> ciaranm: conceptually, main is a function that returns a monadic value
04:19:14 <donri> AshyIsMe: bad docs, admittedly :)
04:19:17 <ciaranm> dleedev: reductions
04:19:29 <merijn> dleedev: No, main is a monadic value
04:19:29 <dleedev> ciaranm: do you agree that main is a function?
04:19:36 <merijn> dleedev: Not a function that returns a monadic value
04:19:38 <ciaranm> dleedev: no
04:19:51 <merijn> Specifically, main is an IO action
04:20:16 <dleedev> well, I guess not main in Haskell
04:20:29 <dleedev> sorry about that mixup
04:20:43 <dleedev> main must do something with that resulting IO monadic value
04:20:51 <ciaranm> when you understand why main in Haskell is not a function, but still allows command-line arguments, then you are one step closer to enlightenment
04:20:53 <dleedev> sorry, overloaded "main" again
04:21:02 <ciaranm> main doesn't do anything. main is just a value.
04:21:13 <donri> main doesn't "do" anything, it just references an IO computation that the runtime system "interprets"
04:21:16 <dleedev> ciaranm: I understand... I'm just mixing up stuff
04:21:19 <AshyIsMe> donri: yeap that fixed it, cheers!
04:21:26 <donri> AshyIsMe: \o/
04:21:58 <dleedev> ok, something does something with the monadic value called "main" in Haskell, right?
04:22:08 <AshyIsMe> now i need to figure out how to use it
04:22:13 <donri> yes, the rts :)
04:22:19 <Philonous> dleedev, The runtime system runs it.
04:22:22 <ciaranm> dleedev: you can do lots of things to that value
04:23:43 <eazar001> nice, so that settles it all then
04:23:46 <benj_> I don't think it's hugely important that main isn't a function. One could imagine a haskell-like language where main is [String] -> IO (); it just has an implicit (getArgs >>=) applied to it.
04:23:50 <eazar001> interesting discussion
04:23:56 <AshyIsMe> donri: what is the default key that it defines to mean an indent?
04:24:12 <donri> AshyIsMe: basically it makes ai and ii text objects for "contiguous lines indented at least as much as current line"
04:24:21 <donri> AshyIsMe: you know text objects?
04:24:29 <AshyIsMe> oh, two letter text objects
04:24:42 <AshyIsMe> so i'd do: daai to delete around the current one?
04:24:43 <eazar001> that was intense, and enlightening [=, ain't #haskell great?!
04:25:10 <donri> AshyIsMe: no just dai or dii (i forgot if there's a difference to ai and ii in this plugin)
04:26:09 <dleedev> eazar001: my proposal is that the way to conceptualize what the runtime system does it to imagine it does "runWorld main oldWorld"
04:26:14 <AshyIsMe> ah yeap, cheers
04:27:03 <dleedev> eazar001: does that make sense?
04:27:05 <merijn> dleedev: But what does that conceptualisation add that you can't have with the conceptualisation of the runtime doing "runAction main"?
04:27:05 <merijn> Why worry about a world at all there?
04:27:09 <simpson> dleedev: What if it doesn't do things that way?
04:27:19 <Philonous> dleedev, World passing isn't a particularly good model. For example. you can't explain concurrency.
04:27:29 <merijn> dleedev: Extra details only make sense if they improve your model
04:27:43 <dleedev> Philonous: I would argue that concurrency does not belong in the functional world
04:27:52 <merijn> dleedev: You seem to take the existing model "runAction main" and add a World to it, even though the world doesn't actually tell you anything
04:28:09 <dleedev> Philonous: you can't implement concurrency with a functional language, you can only outsource concurrency
04:28:16 <AshyIsMe> donri: hmm, i think im looking for something like paredit for haskell within vim
04:28:20 <Philonous> dleedev, Why? Because your model can't explain it? But it's there. It works great. And it's well-understood.
04:28:45 <dleedev> merijn: "runAction main" in your understanding would result in doing impure stuff, like mutation
04:28:53 <Philonous> dleedev, Concurrency isn't a feature in pure haskell, it's part of the operational semantics of IO.
04:28:57 <AshyIsMe> i might have a go at writing the vimscript to get chrisdone's structured-haskell-mode to work with vim
04:28:59 <merijn> dleedev: Yes, but "runAction" isn't haskell, so who cares?
04:29:08 <dleedev> Philonous: exactly, it's not a functional concept
04:29:16 <Philonous> dleedev, So?
04:29:19 <merijn> dleedev: *Haskell* can't do impure operations, the *runtime* can do whatever the fuck it wants
04:29:28 <dleedev> merijn: that I understand
04:29:35 <simpson> dleedev: I dare you to define "functional programming."
04:29:42 <Philonous> dleedev, Haskell needs an operational semantics anyway. Without it it would be completely useless.
04:29:55 <dleedev> Philonous: the point of the World model is to let everything reside in functional-land
04:30:07 <Philonous> dleedev, We don't need it to achieve that goal.
04:30:11 <dleedev> Philonous: let nothing leak out conceptually into imperative land
04:30:30 <merijn> Ok, I'm done with this conversation. I need to go be productive
04:30:34 <dleedev> Philonous: well, there's a lot of stuff you don't *need* to do, but would be nice to do
04:31:29 <dleedev> and that's the whole point of conceptualizing IO in the World-passing model
04:31:30 <ciaranm> anything you can do with world-as-a-parameter you can do with world-as-a-monad. but the converse is not true.
04:31:41 <dleedev> so that your whole concept, including runtime, can reside in functional-land
04:32:25 <dleedev> ciaranm: I'm not sure what world-as-a-monad would look like
04:33:16 <ciaranm> dleedev: State, or some variant
04:34:13 <donri> AshyIsMe: yeah textobj-indent doesn't come close to anything that intelligent unfortunately
04:34:24 <dleedev> ciaranm: I see, more precisely, world-change-as-a-monad or world-action-as-a-monad?
04:34:48 <JuanDaugherty> *known
04:34:58 <donri> AshyIsMe: one idea might be to extend vim-hdevtools since it already has some of the necessary machinery (the type inspection stuff knows about expression boundaries)
04:35:07 <ciaranm> dleedev: your question does not make sense
04:35:25 <ciaranm> dleedev: you still aren't getting the difference between monads and functions
04:35:35 <dleedev> ciaranm: I do get the difference
04:36:30 <donri> AshyIsMe: you could also try emacs with evil-mode...
04:37:05 <AshyIsMe> nah i tried that and it wasnt my preference
04:37:33 <AshyIsMe> this'll be fun to learn vimscript a bit better too
04:38:07 <donri> fun is the right word; you'll laugh at the crazy hacks that are considered idiomatic :)
04:38:14 <dleedev> ciaranm: my conclusion is this: conceptualizing IO monad as a way to pass a World value allows you to remain in functional-land even during runtime
04:38:55 <dleedev> ciaranm: runWorld someWorldChangingMonad theOldWorld
04:39:07 <donri> runtime doesn't matter if the program is verified at compile time
04:39:15 <donri> see also: type erasure
04:40:07 <dleedev> donri: I'd argue that even runtime is not a functional concept
04:40:24 <donri> apples and oranges (:
04:40:42 <dleedev> donri: yes, apples and oranges
04:40:47 <donri> "functional" as a math concept doesn't mean anything related to computers or programming :P
04:40:51 <ciaranm> dleedev: read Moggi's paper and be enlightened
04:41:15 <dleedev> ciaranm: link, please
04:41:45 <ciaranm> dleedev: http://www.cs.cmu.edu/~crary/819-f09/Moggi91.pdf
04:42:11 <dleedev> donri: right, in the end, we're just modeling mappings
04:42:34 <donri> yes we're just borrowing a model. the fact we can run the model is incidental.
04:44:24 <dleedev> ciaranm: yikes, that paper is too mathy for me
04:44:56 <ciaranm> dleedev: well, you're repeating all the mistakes people made until they understood that paper
04:46:13 <merijn> ciaranm: That's the one Wadler's paper is based on, no?
04:47:02 <ciaranm> merijn: yes, but Wadler's paper is still roughly consistent with the things dleedev is getting wrong.
04:47:03 <dleedev> ciaranm: is there a non-mathy summary for people from programming backgrounds?
04:47:21 <skypers__> hi
04:47:38 <dleedev> ciaranm: also, can you pinpoint what I'm getting wrong?
04:47:49 <ciaranm> dleedev: well, either you can accept that your conceptualisation stuff is unnecessary and bad, or you can understand that paper to understand it
04:47:52 <skypers__> if I have a type data Foo = Foo [Float], is it possible to use GeneralDeriving ?
04:47:58 <skypers__> well yes
04:48:02 <skypers__> I meant, for Storable
04:48:14 <dleedev> ciaranm: so there's no way of understanding besides reading that paper?
04:48:42 <dleedev> ciaranm: no summary or blog or something more approachable to non-math people?
04:48:42 <ciaranm> dleedev: i suppose you could get someone to write an easier version of that paper
04:49:10 <ciaranm> dleedev: Wadler's monads paper is much easier to understand, but it doesn't cover some of the truth and beauty
04:49:34 <dleedev> ciaranm: is it something that you can explain here in simple terms?
04:50:41 <ciaranm> dleedev: the simple version is that the kleisli category over a monad gives you precisely what you need to describe sequencing of effects
04:51:15 <ciaranm> dleedev: but your problem seems to be that you want to view IO as being something more than "it's what it's defined to be"
04:51:42 <ciaranm> dleedev: and to get why that won't help, you really need to understand mathematical concepts like freeness
04:52:38 <ciaranm> not necessarily because you should view IO as being "free identity plus stuff", but just so you get the idea that "free identity plus stuff" gives you a way of seeing sequences of effects
04:52:58 <merijn> I think Occam's razor helps, you should prefer the simplest adequate explanation. Since in this case the more complex explanation (i.e. the one using "World") doesn't adress any issues that the simpler one doesn't already address
04:53:58 <dleedev> ciaranm: I guess the benefit is that you can conceptualize changes to the world
04:54:38 <dleedev> ciaranm: with the instructions as a value, you can only conceptualize instructions to change the world
04:54:38 <arnsholt> Since I started skimming that paper: Is \beta\eta-conversion showing that two programs are equivalent by beta and eta reducing to the same lambda term, or something else?
04:54:38 <ciaranm> dleedev: there is no world
04:55:17 <dleedev> ciaranm: I guess that's why I'm trying to incorporate the world
04:55:22 <dleedev> ciaranm: into my view
04:56:02 <dleedev> ciaranm: because everywhere else in your code with dealing with IO, you're conceptualizing the world
04:56:31 <dleedev> ciaranm: functions and types are named in ways assuming the world
04:56:55 <ciaranm> dleedev: up to isomorphism, there is no world
04:57:17 <dleedev> ciaranm: but in your view, after you're done typing up a Haskell program, you must say, alright, actually there was no world, I was merely coding up a way to sequence instructions
04:57:39 <ciaranm> dleedev: the point is that it doesn't matter whether there is or isn't a world
04:57:55 <dleedev> ciaranm: in your view it doesn't matter
04:58:03 <donri> man that's deep
04:58:07 <dleedev> ciaranm: because at the end of it all, you're just coding up a way to sequence instructions
04:58:12 <ciaranm> dleedev: things that are the same up to isomorphism are generally the-same-enough to not matter
04:58:54 <dleedev> ciaranm: but real-world programs like HTTP, file access, pixel manipulation does generally get conceptualized with a world
04:59:08 <merijn> dleedev: Why does it matter whether there is or isn't a world?
04:59:32 <dleedev> merijn: because most people assume a world when they program
04:59:48 <JuanDaugherty> C'est ne pas une Monde
05:00:19 <spion> if I'm understanding it correctly, basically IO is a hack that gets stuff to work and it shouldn't be made anything more than that? :)
05:00:27 <ciaranm> anyway, i'm off to listen to some javascript people :(
05:00:43 <dleedev> ciaranm: ok, thanks for all the chat
05:00:59 <dleedev> ciaranm: I appreciate all the things you've pointed out and taught me
05:01:06 <merijn> spion: It's not a hack
05:01:19 <merijn> spion: It's rather a very elegant way of modeling something ugly
05:01:46 <dleedev> merijn: actually, what you're modeling is not ugly at all... a sequence of instructions is not ugly
05:01:46 <spion> i didn't mean hack in the bad sense
05:01:53 <dleedev> merijn: but you were conceptualizing a world, weren't you? :)
05:02:00 <merijn> spion: Well, the "IO is a monad" bit is very elegant, IO itself is an ugly hack filled with spiders and rotting entrails
05:03:39 <merijn> spion: Anyway, if you missed it, this article linked earlier has a good explanation of IO and purity: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
05:04:11 <merijn> spion: Also, if you've finished LYAH the Wadler paper on monads is pretty readable and enlightening
05:05:30 <Aetherspawn> paper on monads?
05:05:34 <Aetherspawn> Are you trying to kill the man?
05:05:39 <spion> thanks, I am accumulating reading material -- still stuck on the basics of category theory though
05:06:02 <spion> eh, why not :) it can't be that hard, its just a bunch of words that I'm not comfortable with yet.
05:06:07 <merijn> spion: Meh, I recommend skipping those until you get to more advanced Haskell :p
05:06:23 <Aetherspawn> I can only think of one thing more satanic
05:06:32 <Aetherspawn> and that's directing him towards something edwardk wrote
05:06:57 <merijn> spion: Look for "Monads for Functional Programming" by Wadler
05:07:01 <merijn> Need to run now
05:07:05 <Aetherspawn> bye merijn
05:07:15 <spion> merijn, thanks -- I will
05:08:10 <Sorella> Aetherspawn, hm, really? I haven't read Wadler's paper yet, but glancing through it looked very readable.
05:09:09 <Aetherspawn> tbh I haven't read it either, but FP papers are generally scary
05:09:23 <dleedev> merijn: bye, and thanks
05:09:44 <Aetherspawn> I would expect a paper on monads to try and provide proof and stuff like that
05:09:54 <Aetherspawn> probably not that useful to someone trying to learn them :P
05:11:30 <yesthisisuser> with all this hype around FP in the "industry" one would imagine there must be some research on hardware and computer architectures that follow a more "functional" style
05:12:41 <zomg> yesthisisuser: like Lispmachines?
05:12:42 <Aetherspawn> yesthisisuser: reduceron
05:13:16 <Sorella> Aetherspawn, from the abstract, he just walks through how monads solve the problem of functional programming in three different use cases. Also, Why Functional Programming Matters and some other papers by Hughes have no proofs :)
05:13:40 * Sorella also finds Simon's papers fairly readable, even for someone that hardly knows maths like her
05:13:40 <Aetherspawn> cool, that doesn't too bad
05:14:07 <Aetherspawn> I thought simon was a guy
05:14:46 <zomg> Sorella: yeah some of them are readable but don't make any sense anyway :p
05:14:58 <Polarina> Aetherspawn, the "her" was referencing to Sorella.
05:15:01 <zomg> They're generally so inpractical
05:15:12 <Sorella> Aetherspawn, oh, reduceron looks cool!
05:15:39 <Aetherspawn> heh didn't realize it was a /me
05:16:03 <Aetherspawn> Sorella: yeah, its pretty cool
05:16:06 <Sorella> zomg, try reading OOP papers :P
05:16:06 <Aetherspawn> the benchmarks are really impressive
05:16:40 <zomg> Sorella: yeah, probably same thing. You have to know all the other theorycrafting stuff first
05:16:55 <arnsholt> zomg: Weren't most of the Lisp machines really von Neumann Turing machine hardware with Lisp on top though?
05:17:38 <Sorella> zomg, thesis are usually easier to read. But more often than not you can ignore the proofs, unless you're doing research on top of a particular paper. Simon's papers are also filled with examples, which is great.
05:17:54 <zomg> arnsholt: I wasn't even born when those things were around so don't ask me :D
05:18:14 <arnsholt> Heh. Me neither =)
05:19:13 <mbrock> Lisp itself is strict and imperative -- the machines just had some nice microcode support for type tags, GC, etc
05:19:17 <yesthisisuser> i think "lisp machine" was also a dialect of the language itself
05:20:05 <arnsholt> mbrock: There's that too, yeah. Don't tell #lisp ;)
05:21:04 <yesthisisuser> so the Reduceron is also using Field Programmable Gate Arrays. I saw that mentioned somewhere else but didn't really understand what it is about
05:21:18 <yesthisisuser> "FPGA"
05:22:21 <yesthisisuser> "FPGAs can be reprogrammed to desired application or functionality requirements after manufacturing."
05:23:42 <dleedev> mbrock: how much of my blabbering about conceptualizing IO did you follow?
05:25:31 <yesthisisuser> this looks amazing: http://s7.computerhistory.org/is/image/CHM/500004885-03-01
05:26:47 * hackagebot io-streams 1.1.3.0 - Simple, composable, and easy-to-use stream I/O  http://hackage.haskell.org/package/io-streams-1.1.3.0 (GregoryCollins)
05:27:09 <donri> i want that keyboard
05:27:51 <yesthisisuser> does the computer come with that branded coffee mug..?
05:28:31 <mbrock> dleedev: a bit :) it's interesting to think about IO in different ways.  we still don't have a great "theory of I/O" and it's a subject of ongoing research... it's a question of "denotational semantics," i.e., what can we say about the meaning of an IO value?
05:28:55 <dleedev> mbrock: can you point out any mistakes or wrong-thinking on my part?
05:30:47 <mbrock> I don't have much to add to that discussion at the moment, but I'll point to another article, by Conal Elliott: http://conal.net/blog/posts/can-functional-programming-be-liberated-from-the-von-neumann-paradigm
05:31:00 <mbrock> which I think touches on some of your concerns
05:31:32 <dleedev> mbrock: thanks, will take a look
05:33:31 <yesthisisuser> some words of wizdom there from John Backus there in that article
05:34:16 <mbrock> amen!
05:35:02 <yesthisisuser> although wisdom is probably the correct spelling in english (?)
05:35:39 <Mindmaster> yes :)
05:36:02 <mgore> I've got a question regarding the haskeline library: is it possible to retrieve the (incomplete) user input on interrupt, e.g. when using System.Console.Haskeline.IO.cancelInput? (analogous to readline's getLineBuffer) plz help
05:36:33 <Tekmo> mgore: what's the reason that you need this?
05:37:12 <mgore> i've got a concurrent console app, where one thread can interrupt user input
05:37:55 <mgore> (... then some output is performed, and user input resumed)
05:37:56 <Tekmo> I wrote up a library just for this purpose
05:37:59 <Tekmo> One second while I pull up the link
05:38:03 <mgore> wow thx
05:38:10 <Tekmo> mgore: https://github.com/Gabriel439/Haskell-RCPL-Library
05:38:15 <Tekmo> It's not as featureful as Haskeline
05:38:17 <Tekmo> It's still in beta
05:38:18 <mgore> ok checking it out
05:38:20 <Tekmo> But it does what you ask
05:38:29 <Tekmo> You can print to the console and it won't clobber the user input
05:39:05 <Tekmo> It's specifically designed for concurrent input and output
05:39:58 <Tekmo> Let me give you an example program
05:40:34 <mgore> hm... seems like the perfect solution to my problem ;)
05:41:46 <Tekmo> mgore: Here is an example program using the library: http://lpaste.net/98186
05:42:47 <Tekmo> Just beware that there are still lots of corner cases I'm working out
05:42:52 <Tekmo> It should be much more polished in a few days
05:43:18 <mbrock> I have a pipes-based program that logs a lot of junk to stdout from several threads, so sometimes the output is interleaved wrongly...
05:44:01 <Tekmo> So the `writeLine` function is atomica, meaning that multiple concurrent invocations of `writeLine` won't get interleaved
05:44:10 <Tekmo> Same thing for the derived `writeLines` pipe
05:44:12 <mgore> @Tekmo great coincidence, I'll be testing your lib these next days. Thanks a lot!
05:44:12 <lambdabot> Unknown command, try @list
05:44:18 <Tekmo> mgore: You're welcome!  I'm glad it helped
05:44:27 <Tekmo> mgore: Please file any bugs you encounter on the issue tracker
05:44:31 <larsrh> Does anybody know a short algorithm which can be efficiently implemented in Haskell because of laziness?
05:44:39 <mbrock> which itself is a pretty easy problem but I'll try your library, I was avoiding console input but that'd be nice to add...
05:44:40 <mgore> Tekmo: k, done.
05:44:44 <Tekmo> larsrh: The classic example is finding the maximum of a list
05:45:13 <larsrh> Tekmo: yeah, know that one. Looking for a bit more sophisticated ones.
05:45:30 <Mindmaster> /?
05:45:37 <Tekmo> Edward kmett is the expert on this because he does a lot of composable and efficient algorithms
05:45:42 <Tekmo> He's the best person to ask
05:45:58 <Tekmo> This is literally his Haskell spiel
05:46:28 <edwardk> larsrh: take 10 . sort is my usual elevator pitch
05:47:06 <edwardk> larsrh: lazy memo combinators are another example
05:47:29 <marx2> rcpl looks interesting. I can't find it on hackage though,  only githube?
05:47:32 <larsrh> edwardk: oh, that sounds intriguing. Any link?
05:47:37 <Tekmo> marx2: That's because it's still in beta
05:47:40 <larsrh> (for the memo combinators)
05:47:46 <Tekmo> marx2: I'm working on it as we speak
05:47:49 <marx2> Tekmo ah ok
05:47:53 <Tekmo> marx2: It will probably be on Hackage within 1-2 weeks
05:48:04 <marx2> neat
05:48:07 <edwardk> https://www.quora.com/Reviews-of-Haskell/review/Edward-Kmett?share=1 talks a bit about take 10 . sort at least
05:48:21 <larsrh> edwardk: Were you talking about this? http://hackage.haskell.org/package/data-memocombinators
05:48:31 <edwardk> re memo combinators luke palmer probably wrote up something
05:48:52 <larsrh> okay, thanks!
05:48:56 <edwardk> data-memocombinators is one verson of the idea that is short and sweet. i have a more verbose implementation as well in representable-tries
05:49:22 <edwardk> http://lpaste.net/97230 is me tackling them with GHC Generics
05:49:25 <osa1> can anyone recommend me some arrow tutorials?
05:49:51 <Tekmo> Are you interested in arrow syntax or applications of arrows?
05:49:59 <osa1> Tekmo: both
05:50:03 <edwardk> ocharles: "they are willing to give it up when they think my bindings are ready" is kinda crappy. =(
05:50:06 <Tekmo> Netwire is a good place to start
05:50:17 <utkarsh> If I have 2 files: ./foo/bar.hs and ./baz/something.txt, is it possible to get the path to something.txt from bar.hs? getCurrentDirectory from System.Directory returns the dir of where it's called from, not the dir of the file.
05:50:17 <Tekmo> It's an arrow-based library
05:50:34 <osa1> Tekmo: so you're recommending learning by using a library?
05:50:44 <Tekmo> osa1: Not just the librayr
05:50:51 <Tekmo> osa1: You might also wnat to read this: http://ocharles.org.uk/blog/posts/2013-08-18-asteroids-in-netwire.html
05:51:09 <Tekmo> Wait, never mind
05:51:17 <Tekmo> That tutorial has very little arrow content
05:52:38 <Tekmo> osa1: So FRP and some types of parsers are where I've mostly seen uses of arrows
05:53:43 <Tekmo> osa1: So if you don't mind papers then this is a good place to start: http://www.haskell.org/arrows/biblio.html
05:54:01 <Tekmo> osa1: I don't know of a good arrow tutorial, though
05:54:04 <jeremy_> are monads more powerful than arrows?
05:54:12 <osa1> Tekmo: awesome. I don't mind papers at all. thanks.
05:54:20 <Tekmo> osa1: You're welcome
05:55:28 <mgore> Tekmo: with RCPL's githhub version, I seem to be in dependency hell... requires text<0.12, i've got the 1.0, as well as a newer version of pipes-concurrency is required than the one on hackage.... guess I'll have to wait till the release then ;_;
05:55:42 <Tekmo> mgore: Let me update the dependency
05:56:07 <larsrh> edwardk: I like the GHC.Generic thing, but I guess that's nothing to show to beginners :-)
05:56:30 <edwardk> my code is rarely classified as such =)
05:58:41 <donri> Guest57672: every monad can be made an arrow but not all arrows can be made into a monad
05:59:06 <Guest57672> donri i see
05:59:45 <donri> although it might be more about the Category constraint that comes with Arrow than with Arrow itself
05:59:52 <Guest57672> I wanted to make a monad wrapper for HXT library
06:00:04 <donri> i hear Arrow is equivalent to (Category,Applicative) although not sure
06:00:41 <donri> hxt's arrows can be made into monads though. ArrowApply is a give-away ;)
06:01:11 <donri> i think it's just the list monad, in fact
06:02:35 <Feuerbach> no, Arrow is "stronger" than Applicative
06:02:37 <donri> Feuerbach: but combined with Category?
06:02:40 <Feuerbach> http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
06:04:16 <bennofs> donri: Maybe you're thinking about (Profunctor, Category) ?
06:04:29 <donri> i'm not, but maybe i should be ;)
06:05:16 <bennofs> I think arrow is (Profunctor, Category, Strong) :P
06:10:42 <Feuerbach> donri, bennofs: not sure, maybe you're right
06:12:16 <skypers__> hello
06:12:22 <skypers__> given Ptr Float and Ptr Int
06:12:38 <skypers__> how could I copy those two arrays into a Ptr ()?
06:12:48 <Tekmo> Side by side?
06:12:54 <skypers__> yes
06:13:05 <skypers__> I know how to create the Ptr ()
06:13:09 <quicksilver> you can convert ptrs just by using castPtr
06:13:18 <skypers__> I compute the required space in bytes
06:13:18 <skypers__> yes
06:13:19 <quicksilver> and you can do the pointer arithmetic using storable, probably
06:13:21 <skypers__> I already do that
06:13:27 <skypers__> but Ptr () is not a Storable instance
06:13:33 <skypers__> then I canât call copyArray with that
06:13:40 <quicksilver> castPtr it to Ptr Float
06:13:47 <ocharles> Any tips for debugging a Haskell app that's trigger the OOM killer? :?
06:13:48 <Feuerbach> donri, bennofs: how'd you even interpret "Applicative+Category", given that they're of different kinds?
06:13:52 <skypers__> quicksilver: ?
06:14:06 <quicksilver> skypers__: use castPtr to turn your Ptr () into a Ptr Float.
06:14:11 <skypers__> I donât want to cast between types
06:14:18 <skypers__> Iâd loose precision
06:14:20 <skypers__> lose*
06:14:21 <Feuerbach> ocharles: have you done heap profiling?
06:14:30 <Tekmo> ocharles: A quick and dirty solution is to have your program catch and gracefully quit on Ctrl-C
06:14:36 <quicksilver> skypers__: that is not what castPtr does.
06:14:37 <Tekmo> ocharles: Then you can run the heap profiler on it
06:14:49 <Tekmo> ocharles: Just ctrl-C right before it goes OOM
06:14:54 <skypers__> quicksilver: I donât understand then
06:15:07 <bennofs> Tekmo: IIRC the heap profile also outputs a profile if you don't catch ctrl-c, doesn't it?
06:15:16 <Feuerbach> yes (at least on Linux)
06:15:21 <quicksilver> skypers__: you can use castPtr to turn your Ptr () into a Ptr Float.
06:15:22 <Tekmo> bennofs: Yes, but it sometimes screws it up if you don't quit gracefully
06:15:29 <quicksilver> skypers__: then you can call copyArray
06:15:42 <ocharles> Feuerbach: no, will that work when the kernel kills it?
06:15:42 <Feuerbach> I've seen problems under Windows or cygwin, though
06:15:55 <ocharles> Tekmo: ah right, I didn't know that'd work
06:15:57 <ocharles> I'll try that!
06:16:02 <skypers__> I have Ptr Float and Ptr Int, I want to put them in the same contiguous C memory. So youâre saying, I create the Ptr (), then IÂ just have to cast the Ptr () into Ptr Float, not Ptr Float into Ptr ()?
06:16:12 <quicksilver> yes.
06:16:15 <skypers__> ok
06:16:17 <skypers__> that sounds nice
06:16:18 <Feuerbach> ocharles: perhaps not, but as others said, terminate it before it gets too big
06:16:19 <skypers__> thank you!
06:16:48 <quicksilver> skypers__: where did you get a Ptr () from though? that seems odd.
06:17:02 <skypers__> quicksilver: I create it
06:17:07 <quicksilver> how?
06:17:32 <skypers__> I foldl an algeabraic datatype that contains [CFloat], [CInt] and [CUInt]
06:17:42 <skypers__> then I put all those arrays together in the Ptr ()
06:18:09 <Feuerbach> donri, bennofs: what they did in that paper is translate "theories" (e.g. translate a program written using applicatives into a program written using arrows). But I don't see how to use both abstractions in the same "theory"
06:18:16 <quicksilver> skypers__: but where did the Ptr () come from?
06:18:27 <ocharles> osa1: I learnt arrows by just gritting my teeth and writing code
06:18:37 <skypers__> itâs allocated in my haskell program
06:18:37 <ocharles> osa1: it was painful, but it gets easier. it just takes practice
06:18:40 <skypers__> with allocaArray
06:19:00 <quicksilver> ah, that's the answer I wanted
06:19:16 <quicksilver> skypers__: allocaArray is polymorphic
06:19:21 <quicksilver> why get a Ptr() out of it?
06:19:29 <osa1> ocharles: what arrow-based libraries did you use for that?
06:19:30 <quicksilver> if you just got a Ptr Float out of it, you wouldn't need to cast...
06:19:40 <skypers__> I would
06:19:58 <skypers__> because I donât know what types I have in the algebraic list
06:20:03 <skypers__> I can only send CFloat
06:20:06 <skypers__> or only send CInt
06:20:16 <skypers__> it depends
06:20:48 * quicksilver nods
06:21:13 <quicksilver> well Ptr Word8 would seem more sensible if you're calculating byte sizes but, anyway, you know where you are now :)
06:23:39 <donri> Feuerbach: (Category f, Applicative (f a)) shrug
06:23:44 <donri> brb
06:29:19 <Feuerbach> donri: how'd you implement arr?
06:31:05 <quicksilver> Feuerbach: with a pirate
06:31:07 <quicksilver> *ducks*
06:33:08 <skypers__> ok I failed :D
06:33:15 <skypers__> I canât allocArray a Ptr ()
06:33:18 <skypers__> then I just allocated a Ptr Word8
06:33:24 <skypers__> I hope itâs okay
06:33:25 <quicksilver> yes
06:33:33 <quicksilver> because you're mesauring size in bytes
06:33:38 <quicksilver> Word8 is the right thing
06:33:58 <skypers__> quicksilver: okâ¦ thank you for your help!
06:36:42 <quicksilver> Feuerbach: arr g = pure g <*> id
06:36:44 <quicksilver> Feuerbach: I think.
06:36:56 * hackagebot grid 7.6.1 - Tools for working with regular grids (graphs, lattices).  http://hackage.haskell.org/package/grid-7.6.1 (AmyDeBuitleir)
06:36:58 * hackagebot som 6.5.1 - Self-Organising Maps  http://hackage.haskell.org/package/som-6.5.1 (AmyDeBuitleir)
06:38:05 <quchen> (pure f <*>) = fmap f
06:42:35 <Feuerbach> ok, that sounds legit
06:43:22 <quicksilver> quchen: yes, if you like, but I was using the Applicative constraint because that's what we had
06:44:07 <Feuerbach> luckily, Functor => Applicative
06:45:41 <quicksilver> yes
07:12:52 <owst> I'm seeing some strange GHC profiling behaviour. My program is taking ~7seconds to run, but the profiling report says total time 0 seconds (however the alloc value seems about right). Has anyone experienced this before?
07:13:22 <owst> I'm using cabal with --enable-executable-profiling and running with ./prog +RTS -p which has always worked before
07:15:53 <Polarina> owst, this is a known bug.
07:16:40 <Polarina> owst, https://ghc.haskell.org/trac/ghc/ticket/5282
07:16:46 <owst> Polarina: Oh. My searches turned up nothing. Thanks!
07:17:53 <owst> Oh, I did find that, but it didn't seem relevant. I'm on Linux and my profiling has been working fine before this afternoon (I don't know what I've done to break it!)
07:18:57 <owst> (that ticket suggests compiling with -threaded will fix the issue. I'm already doing that, and it doesn't fix it)
07:33:02 <structuralist> I'm trying to do something weird and a little confused... I want something like a double unfold, where I start out with some F :: * -> * -> *, and some function c :: a -> b -> F a b, and produce kind of unfolder :: a -> b -> "Fix (Fix F)". But that doesn't quite make sense.
07:33:52 <structuralist> That last result type should be something different, I think
07:34:30 <structuralist> F could be something like ListF a x = Nil | Cons a x
07:34:53 <int-e> structuralist: if there were a type level lambda you could have Fix (\a -> Fix (F a))
07:35:20 <int-e> (But I probably shouldn't use -> that way.)
07:35:30 <mm_bureau> int-e: that feels quite impredicative
07:35:51 <mm_bureau> almost like Fix (forall a. Fix (F a))
07:36:26 <merijn> Impredicative types always make me sad, because they don't work well in GHC :(
07:37:15 <int-e> data Fix2 F a = Fix2 (F a (Fix2 F a))
07:37:27 <int-e> (well, newtype)
07:38:09 <merijn> "Fix (Compose (Fix F))" :)
07:38:41 <merijn> Type level fix was Mu in lambdabot, right?
07:40:20 <structuralist> Expecting one more argument to `ListF'
07:40:20 <structuralist> In a type in a GHCi command: Fix (Compose (Fix ListF))
07:40:24 <structuralist> (says ghci)
07:40:31 <haasn> :t In
07:40:32 <lambdabot> f (Mu f) -> Mu f
07:40:51 <merijn> o:t Mu
07:40:54 <merijn> :t Mu
07:40:55 <lambdabot> Not in scope: data constructor `Mu'
07:40:57 <merijn> eh
07:41:01 <merijn> :k Mu
07:41:01 <lambdabot> (* -> *) -> *
07:41:05 <int-e> :t out
07:41:06 <lambdabot> Mu f -> f (Mu f)
07:41:27 <int-e> lambdabot has newtype Mu f = In { out :: f (Mu f) }
07:41:55 <merijn> :k Mu (Compose (Mu Identity))
07:41:56 <lambdabot>     Not in scope: type constructor or class `Compose'
07:42:02 <merijn> :k Mu (Data.Functor.Compose (Mu Identity))
07:42:03 <lambdabot>     Not in scope: type constructor or class `Data.Functor.Compose'
07:42:08 <merijn> :k Mu (Data.Functor.Compose.Compose (Mu Identity))
07:42:09 <lambdabot>     Kind mis-match
07:42:09 <lambdabot>     The first argument of `Data.Functor.Compose.Compose' should have kind `*
07:42:09 <lambdabot>                                                                            -> *',
07:42:21 <merijn> oh, right
07:43:11 * haasn is not sure what exactly we are trying to achieve
07:46:11 <structuralist> I'm confused myself, but I'd like to do something vaguely like taking the fixpoint of ListF to get List, and then taking the fixpoint of that
07:48:25 <ocharles> How are you meant to use cabal to do profiling on test executables? I've added '--enable-library-profiling --enable-executable-profiling', and set 'ghc-options' to '-auto-all'
07:48:29 <ocharles> Is that the correct approach?
07:49:03 <bennofs> ocharles: I think --ghc-options: -rtsopts is pretty useful too
07:50:03 <structuralist> so if I define newtype M r f a = M (r (f a))
07:50:11 <owst> ocharles: yes, that's what's mostly working for me. You need -rtsopts
07:50:16 <structuralist> then this seems to give what I want: Fix (M Fix ListF)
07:50:35 <ocharles> yea, I have rtsopts on the test-suit
07:50:43 <ocharles> My heap profile is just one big black area graph though :/
07:50:50 <structuralist> I have a feeling there's a better way to do this
07:51:28 <ocharles> looking at the .hp file though I think that might be because that line just dwarfs everything else significantly
07:56:21 <bennofs>  ocharles: You might also like the -c option to hp2ps, it gives colors :)
08:00:52 <ocharles> Yay, I found my memory leak
08:00:58 <ocharles> let expected = Aeson.toJSON [ expected ]
08:01:06 <ocharles> Surprisingly, that doesn't really make a whole lot of sense
08:01:08 <ocharles> </sarcasm>
08:01:14 <bennofs> haha
08:01:38 <bennofs> Sadly, it's not so easy to find memory leaks in a program using the GHC API :(
08:02:06 * hackagebot data-size 0.1.1.6 - Profiling of data structures  http://hackage.haskell.org/package/data-size-0.1.1.6 (UweSchmidt)
08:02:08 * hackagebot creatur 4.1.7 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-4.1.7 (AmyDeBuitleir)
08:10:53 <pmade> Is it likely that the next Haskell report will adopt GHC changes to exceptions, like using throw from pure code?
08:12:33 <JuanDaugherty> interesting if the two diverged
08:12:34 <mello_> hi all
08:12:34 <pmade> I know it's a speculative question, I'm just curious how the back and for goes between GHC and the standard.
08:12:35 <JuanDaugherty> th
08:12:35 <pmade> yep.
08:12:44 <mello_> I've got a snap question; when trying to use "execute" it says "No instance for (HasPostgres (Handler App (AuthManager App)))
08:12:44 <mello_> "
08:12:45 <bennofs> pmade: It probably won't adopt throw from GHC (is it even only throw?). I think throw is considered to be pretty bad
08:12:57 <mello_> I did do initial configuration, and the regular Authentication snaplet just works as expected. Any ideas?
08:13:50 <bennofs> mello_: do you have the code somewhere, so we could look at it? (maybe github/gist if there are more files?)
08:14:09 <mello_> bennofs: sure just give me a sec.
08:14:14 <pmade> bennofs: Right.  There's also the Exception class too.
08:14:58 <pmade> And that catch only catches matching exceptions, where Haskell 2010 says that catch gets all exceptions.
08:15:16 <mello_> bennofs: https://gist.github.com/froginvasion/83163b43fffde17d977e
08:15:27 <merijn> pmade: Throw is pretty much a misfeature, so I don't think that should be adopted anyway
08:15:28 <mello_> bennofs: the configuration i did is in http://tinylink.net/nknkd, I'll make a gist as well
08:15:36 <bennofs> pmade: I only know that some of the extensions of GHC are going to be in the next haskell standard (FlexibleContexts, DoAndIfThenElse, ... iirc)
08:15:51 <merijn> bennofs: DoAndIfThenElse is already in
08:16:03 <mello_> bennofs:the error is in https://gist.github.com/froginvasion/ad9cbd7fe3ec42f9d3a9
08:16:04 <merijn> Although I actually oppose that one
08:16:45 <merijn> pmade: But yeah, extensions are adopted into the report at times, however the report is rather conservative
08:17:41 <merijn> pmade: Firstly, some extensions in GHC are somewhat controversial (i.e., some people have theoretical objections. Secondly, and perhaps more importantly is that there is a feeling that the report should remain somewhat attainable for new implementations
08:18:01 <bennofs> mello_: do you have the instance
08:18:09 <bennofs> instance HasPostgres (Handler b App) where
08:18:10 <bennofs>     getPostgresState = with pg get
08:18:12 <mello_> bennofs: i have this one: https://gist.github.com/froginvasion/95881f581ca678dc68c3
08:18:13 <merijn> pmade: i.e. things that require a lot of engineering effort are opposed somewhat on grounds that it would make it too hard for new implementations to confirm to the standard
08:18:15 <testAcc> hey, could ya explain me, why i need to swap line 2nd and 3rd to make this function work: http://pastebin.com/SmnW8sqv   (what's the difference here?)
08:18:19 <mauke> The paste SmnW8sqv has been copied to http://lpaste.net/98189
08:18:37 <pmade> merijn: The interesting thing about exceptions in GHC is that it just works that way, you don't have to enable any special extension.
08:19:12 <bennofs> mello_: hmm, you should probably 'import Application' from 'Site.hs'
08:19:13 <mello_> bennofs: its in  https://gist.github.com/froginvasion/95881f581ca678dc68c3
08:19:14 <merijn> pmade: I didn't mean the exceptions themselves are bad, just throw (i.e. throwIO/throwM is fine)
08:19:25 <pmade> merijn: Sure.
08:19:35 <mello_> bennofs: i do have that, because it's created with snap init. i just didnt include
08:19:38 <testAcc> this is the solution from 99 haskell problems. I'm wondering, why ghci says: "multiple declaration"
08:19:55 <pmade> merijn: But what about `error' throwing an exception?  Isn't that different than the report?
08:20:02 <mello_> import           Application on line 39 in Site.hs
08:20:04 <merijn> pmade: I believe GHC's fancy exceptions are just implemented on top of the report stuff
08:20:23 <merijn> pmade: I'm not sure what the report says about error, but I would bet that error is just defined as "bottom"
08:20:50 <merijn> pmade: "bottom" being any non-terminating/crashing expression, if I recall correctly implementations are free to handle it any way they like
08:20:58 <mello_> bennofs: there is an instance for Handler b App, but not for Handler App (AuthManager App), so this obviously seems the problem?
08:21:03 <pmade> merijn: Makes sense.
08:21:06 <merijn> pmade: Although the report suggest they might want to "print a helpful error message"
08:21:22 <merijn> pmade: So in that sense having error be an exception is fine
08:22:16 <bennofs> mello_: yeah, that seems to be the problem. I'm not an expert on snap myself
08:22:20 <merijn> pmade: The problem with throw/error is laziness, you can't control when the exception is actually evaluated, so it's almost impossible to properly catch them. throwIO uses the IO monad to sequence throwing, just allowing deterministic catching
08:22:46 <pmade> merijn: Right, I have the same complaints.
08:22:52 <mello_> bennofs: maybe a simple solution is to change the types to one that has the instance, and just pass the AuthUser
08:22:57 <mello_> that should work.. theoretically
08:23:58 <cschneid> can I build haskell platform without the opengl and GLUT stuff? It's on a server that will never do opengl related stuff
08:24:40 <merijn> cschneid: In essence platform is just a set of library versions, you could just grab the version list and have a script build those exact versions, skipping opengl/glut
08:24:40 <pmade> cschneid: Why do you need the platform there?  Just push binaries.
08:25:03 <cschneid> pmade: seeing if I can get a working env setup on nitrous.io for dev work.
08:25:13 <cschneid> pmade: this is development box, just "in the cloud" :)
08:25:23 <pmade> I see.  Then what merijn said ;)
08:25:51 <cschneid> so haskell platform is the same as a ton of calls to `cabal install ....` with the right versions of everything?
08:26:02 <testAcc> Ø³ÙÙÙÙÙÙÙÙÙØ­Ø® Ì·Ì´ÌØ® Ì·Ì´ÌØ® Ì·Ì´ÌØ® Ø§ÙØ§Ø±ØªÙØ® Ì·Ì´ÌØ®
08:26:32 <merijn> cschneid: Yes
08:27:00 <merijn> cschneid: And some constraint flags to make sure the dependency checker doesn't select a wrong dependency somewhere
08:27:30 <merijn> cschneid: But other than that there's literally no difference between installing platform or just manually installing the relevant versions of packages
08:27:58 <cschneid> cool. seems weird to have such haskell platform not have a flag to turn off 3d stuff. Patch time I suppose
08:28:05 <cschneid> unless that's outside of what platform is for
08:28:11 <cschneid> (being consistent)
08:29:38 <mm_bureau> cschneid: the platform isn't supposed to be a minimal environment, it's supposed to be a set of libraries that provide a common and stable ground to base your work on
08:29:49 <mm_bureau> cschneid: you can just as well install GHC, cabal-install and the libraries you need
08:30:29 <cschneid> cool, I'm ideally working on a tarball that somebody can grab, and be up & running doing haskell on nitrous.io.  (a ide/server in the cloud/etc for free)
08:31:27 <mm_bureau> cschneid: well, you could just build the GL stuff anyway
08:31:47 <cschneid> mm_bureau: the server doesn't seem to come w/ it is the issue, so it adds the step of building glut myself :)
08:31:54 <cschneid> not a huge deal, just wanted to skip if possible.
08:42:41 <mello_> How do I make a new instance of HasPostres to work with AuthManager?
08:44:11 <bennofs> cschneid: How can I use a custom tarball on nitrous.io?
08:44:45 <cschneid> bennofs: I am building stuff manually into a directory under the homedir. Then I plan on just packaging it up, and telling people to fetch it, and untar it
08:45:00 <cschneid> bennofs: tl;dr - lots of --prefix=/home/action/installs/ in my ./configure calls
08:45:24 <cschneid> bennofs: then LIBRARY_PATH and LD_LIBRARY_PATH are important variables to get libgmp to work right with ghc
08:47:16 * hackagebot cabal2nix 1.58 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.58 (PeterSimons)
08:47:34 <bennofs> cschneid: Does building GHC on nitrous require NO2?
08:47:48 <cschneid> I believe so. I certainly ran over disk space at 2gb
08:48:10 <cschneid> the server I'm using is at like 600ish of their server-points, but I just gave it some memory without worrying
08:48:11 <cschneid> (1gb)
08:48:24 <cschneid> I've heard that compiling ghc is rough on low-memory systems
08:50:08 <bennofs> cschneid: Maybe it would be easier to just grab the GHC ubuntu packages, unpack them and use them?
08:50:23 <cschneid> bennofs: perhaps? I have a working ghc already. Just wanted to have the package libs too
08:50:25 <rose_> What's wrong with this formatting? http://lpaste.net/98190
08:50:26 <scriptor> are the ubuntu package up-to-date?
08:50:33 <cschneid> err platform libs
08:50:59 <johnw> rose_: the final , at the very end?
08:51:06 <bennofs> scriptor: no, but hvr provides a PPA that you can use to get a later GHC (it only provides packages for the ubuntu version that travis-ci uses though)
08:51:54 <rose_> johnw: thanks!
08:52:16 * hackagebot git-annex 5.20140108 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140108 (JoeyHess)
08:52:21 <rose_> johnw: Actually that's not it
08:52:53 <rose_> johnw: It's fine now, thanks
08:53:06 <johnw> what was it?
09:01:17 <cschneid> bennofs: here's where I'm at if you're curious: http://cl.ly/image/3I0m1S2E1K0f
09:02:48 <bennofs> cschneid: can nitrous also do syntax checking for haskell? I guess not ;p
09:03:06 <bennofs> ah, not even syntax highlighting :(
09:07:47 <cschneid> bennofs: no, but you can vim inside of nitrous. Or presumably emacs.
09:08:03 <cschneid> mostly I'm trying to justify to myself the purchase of a cheapo chromebook as a mobile programming platform
09:08:37 <mgsloan> cschneid: Have you tried using FPHC for that?
09:08:48 <cschneid> fphc?
09:09:00 <mgsloan> FP Complete's IDE
09:09:02 <johnw> heh, I wondered if anyone would know that abbreviation :)
09:09:16 <cschneid> the google is surprisingly useless at that acronym.
09:09:47 <cschneid> mgsloan: sure, that may work - but I do other work too (ruby / haskell / go / etc). But yeah, it's pretty similar of a use case, just tailored toward haskell
09:10:26 <ReinH> cschneid: hai
09:10:41 <cschneid> ReinH: hi
09:10:59 <mgsloan> cschneid: Gotcha, cool, just curious about the upsides / downsides of the two
09:11:30 <cschneid> mgsloan: generic vs. dedicated to a task I think is the biggest difference. although I've only glanced at the FP ide
09:11:34 <mgsloan> If you find yourself using FPHC and really missing something from nitrous, be sure to let us know!  I've messed with it a bit, but not too much, seems like a cool idea
09:11:43 <bennofs> Isn't the setup basically github's editor + travis, but github's editor has haskell syntax highlighting iirc?
09:12:00 <mgsloan> cschneid: Indeed!
09:12:33 <lingxiao> hey all could someone step through substitution of this lambda expression encoded by de-brujin's index for me
09:12:36 <lingxiao> or with me?
09:12:54 <lingxiao> (Î».Î».12)(Î».(21)0)
09:13:04 <lingxiao> so far I've got:
09:13:40 <lingxiao> (Î».12 ) [0 -> Î».(21)0]            by beta reduction
09:14:50 <lingxiao> Î». (12) [0 + 1 -> shift 1 Î».(21)0]              since the substitution went underneath one binder
09:15:18 <lingxiao> Î». 1 [ 1 -> Î».(32)1] 2 [ 1 -> Î».(32)1 ]
09:15:25 <lingxiao> Î». (Î».(32)1) 2
09:15:40 <benzrf|semiafk> :t (.)
09:15:41 <lambdabot> (b -> c) -> (a -> b) -> a -> c
09:16:04 <lingxiao> then the whole expresssion shifts back one index due to the original beta reduction
09:16:05 <benzrf|semiafk> @hoogle (c -> d) -> (a -> b -> c) -> a -> b -> d
09:16:06 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
09:16:06 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
09:16:06 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
09:16:07 <lingxiao> to become:
09:16:28 <lingxiao> Î». (Î».(31)0)1
09:16:30 <lingxiao> but this is wrong
09:16:43 <benzrf|semiafk> @pl c a = f . g a
09:16:43 <lambdabot> c = (f .) . g
09:16:47 <lingxiao> the answer should be: Î». (Î».(32)0) 1
09:17:29 <ReinH> benzrf|semiafk: some people define (.:) = fmap . fmap and say c = f .: g
09:17:35 <ReinH> other people think that's hideous
09:17:46 <ReinH> I'm not sure what I think yet
09:19:17 <mello_> is there any way I can lift this? Expected type: Handler App (AuthManager App) GHC.Int.Int64
09:19:18 <mello_>       Actual type: Handler App App GHC.Int.Int64
09:20:52 <donri> i like: fmap f . g
09:21:09 <donri> think of 'g' as a reader monad that we can fmap over the result of
09:21:30 <ReinH> donri: not bad
09:22:00 <ReinH> I think I prefer that
09:22:44 <ReinH> donri: I guess I just think of it as the function functor (which is a different name for the same thing ofc)
09:23:09 <ReinH> donri: rather a shame that pointfree doesn't use the Functor instanced for ((->) r)
09:23:11 <donri> in deed :) where fmap = (.)
09:23:25 <ReinH> it should be able to come up with fmap f . g
09:23:55 <donri> but i like it because it works without a section or new operator and feels intuitive when you think of it as a reader monad
09:24:30 <ReinH> donri: yep, although for me the intuition is the one I've built for the function functor, which is why I use that name
09:24:54 <donri> fmap (fmap f) g  ;)
09:25:05 <donri> fmap fmap fmap f g  even?
09:25:06 <donri> :D
09:25:09 <ReinH> indeed :D
09:25:19 <ReinH> well it is fmap fmap fmap
09:25:22 <ReinH> so yes :p
09:29:46 <donri> :t liftM liftM liftM sequence liftM `asTypeOf` mapM
09:29:47 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
09:37:52 <ReinH> donri: ...
09:38:15 <ReinH> donri: I like how any sequence of 1 or more `fmap' is a valid expression.
09:39:16 <simon> so is any sequence of the identity function
09:39:29 <ReinH> true
09:40:01 <simon> but yeah, there's something nice about a subset of typed functions for which any application is valid :)
09:40:30 <ReinH> simon: it's a buffalo expression ;)
09:40:47 <ReinH> simon: any sequence of one or more "buffalo" is a valid english sentence.
09:41:06 <simon> ReinH, I didn't know that it scaled arbitrarily.
09:41:22 <ReinH> simon: I don't have a proof
09:41:29 <ReinH> simon: but I have yet to find any counterexamples
09:42:29 <Iceland_jack> Proof by in-exhaustion
09:44:52 <Hodapp> Buffalo!
09:45:24 <ReinH> Iceland_jack: any sequence of one or more "buffaly" might be a valid english sentence.
09:46:54 <jimstutt> jaspervd1 hi, snap-heist.hs uses an old bindSplices syntax cf. github current Snap.Snaplet.Heist.
09:47:39 <Iceland_jack> ReinH: Zero or more!
09:47:42 <Iceland_jack> â£.
09:47:48 <ReinH> Iceland_jack: is that a valid sentence?
09:48:00 <Iceland_jack> I don't deal with vacous cases
09:48:41 <jimstutt> jaspervd1 I've posted the details here: http://lpaste.net/98002
09:57:20 <jaspervdj> jimstutt: Could you mail me? I'm just going home from work and I'm bound to forget about this :-)
09:57:24 * hackagebot crypto-api-tests 0.3 - A test framework and KATs for cryptographic operations.  http://hackage.haskell.org/package/crypto-api-tests-0.3 (ThomasDuBuisson)
10:15:56 <danilo2> Hello! I think I saw a time ago something like type operators in Haskell, am I right? Right now I cannot find any info about it - how is this functionality called?
10:15:57 <Walther> I'm not sure if I yet understand the concept completely, but how does tail recursion compare to "regular" recursive functions in Haskell (well, mainly in terms of how the compiler handlese those / what gives you the best results) http://stackoverflow.com/questions/33923/what-is-tail-recursion
10:16:25 <Walther> danilo2: this perhaps http://learnyouahaskell.com/making-our-own-types-and-typeclasses ?
10:18:09 <danilo2> Walther: No, i dont think so. I've got a type "type RTuple1 a = (a,())" I want to declare  "type RTuple2' a = (a,) `dotT1` RTuple1" , where dotT1 is like "." in normal functions
10:18:16 <ClaudiusMaximus> danilo2: http://chrisdone.com/posts/haskelldb-and-typeoperator-madness maybe
10:20:51 <enthropy> danilo2: there are no sections at type level though
10:21:10 <enthropy>  type RTuple2' a = (,) a `DotT1` RTuple1 -- might work
10:21:35 <danilo2> ClaudiusMaximus: hmm, hmm, hmm. enthropy got the point - I was confused because there are no sections on type level :( but why!?
10:22:03 <enthropy> well (,a) would imply you have a type-level flip
10:22:31 <danilo2> enthropy: which is easy to implement, isnt it?
10:22:41 <ClaudiusMaximus> maybe related to http://stackoverflow.com/questions/4922560/why-doesnt-typesynonyminstances-allow-partially-applied-type-synonyms-to-be-use
10:22:52 <danilo2> enthropy: type Flip f a b = f b a
10:23:11 <enthropy> sure, but ClaudiusMaximus link probably explains the issue
10:23:43 <enthropy> you pretty much are asking for  newtype Flip f a b = Flip (f b a), without the constructor
10:26:31 <danilo2> enthropy: for the first time I will not agree with you (but I can be of course wrong). simple Flip f a b = f b a would make its job, if tupel sections would be a syntactic sugar over such flips, wouldnt it?
10:27:23 <enthropy> yes it would be fine if you could partially apply type Flip f a b = f b a
10:27:30 <enthropy> but you cannot
10:29:49 <jimstutt> jaspervd1 willco :)
10:32:28 * hackagebot cipher-aes128 0.6.2 - AES and common modes using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.6.2 (ThomasDuBuisson)
10:32:30 * hackagebot commsec 0.3.5 - Provide communications security using symmetric ephemeral keys  http://hackage.haskell.org/package/commsec-0.3.5 (ThomasDuBuisson)
10:32:32 * hackagebot commsec-keyexchange 0.3.2 - Key agreement for commsec.  http://hackage.haskell.org/package/commsec-keyexchange-0.3.2 (ThomasDuBuisson)
10:33:12 <danilo2> enthropy: ahh, I get it! Hmm, why partially applied types are not allowed? ClaudiusMaximus linked to a SO question about it, which links to a "nonfix" bug, but in its description we can see
10:33:34 <danilo2> "I think that this is very unlikely to be implemented, and even if it is, would be better discussed in another forum, so I'm closing this ticket."
10:34:02 <ReinH> There is a very good chance that I won't be doing any actual coding of any kind for the next year o_O
10:34:07 <ReinH> (For work, at least)
10:36:14 <enthropy> danilo2: because it involves type-system features that aren't worked out?
10:36:59 <danilo2> enthropy: fair enough, thank you :)
10:38:45 <danilo2> enthropy: So finally "type RTuple2' a = ((,) a) `DotT1` RTuple1" has no chance to work, because we cannot use "RTuple1" as partially applied type, am I right?
10:39:59 <enthropy> depends how you defined RTuple1
10:40:45 <danilo2> enthropy: RTuple1 v1 = (v1,())
10:40:47 <johnw> mgsloan: ping
10:41:19 <danilo2> enthropy: is there a better method to do it?
10:41:21 <enthropy> so change it to   data RTuple1 v1 = RTuple v1?
10:42:50 <danilo2> enthropy: oh, ok, but then it will make an overhead in compiled code? I will make a **heavy** use of such types and I want them to be optimized away
10:43:27 <enthropy> then use newtype
10:46:07 <danilo2> enthropy: brb
10:51:32 <rioch> Do I have to have a main in a script to run it? I ask because in python it's not required.
10:51:47 <johnw> yes
10:52:02 <danilo2> enthropy: Probably I missunderstand something or simply I'm trying to do it work, but I canniot get it working - I was trying right now soemthing like this: http://lpaste.net/98193
10:52:29 <danilo2> enthropy: *[...] do it wrong [...]"
10:53:19 <rioch> johnw: ok, thanks
10:53:36 <donri> rioch: main = or runIO $  ;)
11:01:44 <jemendja> hello
11:01:50 <johnw> jemendja: hello!
11:02:09 <rioch> Could someone explain why this fails: http://lpaste.net/4023421686677241856
11:02:25 <rioch> It's an easy one I'm sure
11:02:39 <rioch> (for all you smart haskell folk)
11:03:13 <rioch> I get: Couldn't match expected type `Int' with actual type `[Int]'
11:03:13 <saml> is forall good?
11:03:25 <saml> f :: a -> a    vs.  f :: forall a. a -> a
11:03:30 <saml> i don't see difference
11:03:36 <johnw> rioch: the return type should be [Int]
11:03:47 <johnw> saml: in that case, there is no difference
11:04:12 <rioch> johnw: ahhh yes. I need to get used to these error messages :)
11:05:32 <saml> f :: A -> a   vs.   f :: forall a. A -> a
11:05:48 <saml> i don't see difference there either
11:06:53 <geekosaur> there isn't one when it's at the top level, unless you have ScopedTypeVariables enabled in which case it declares scope for a
11:08:16 <rioch> if putStrLn is for a String, what do I use for a list or int?
11:08:35 <johnw> saml: it only starts to make a difference if you have, say, f :: (forall x. x -> c) -> b -> c
11:09:05 <saml> hrm thanks
11:09:41 <cschneid> would somebody mind writing a haskell plugin for lighttable: http://www.chris-granger.com/2014/01/07/light-table-is-open-source/
11:10:01 <jle`> rioch: you can use show to turn anything into a string
11:10:02 <Fuuzetsu> cschneid: Sounds like we have a volunteer.
11:10:05 <jle`> anything showable at least
11:10:11 <jle`> but [Int] is showable
11:10:12 <cschneid> Fuuzetsu: don't wait on me :)
11:10:14 <jle`> so you're in luck
11:10:28 <jle`> rioch: so you would do putStrLn (show yourThing)
11:10:48 <skypers_> sometimes
11:10:49 <jle`> or (putStrLn . show) yourThing
11:10:51 <skypers_> I look at my code
11:10:52 <aleksejs_> > 2^(-1)
11:10:54 <lambdabot>  *Exception: Negative exponent
11:10:58 <aleksejs_> why?
11:11:06 <jle`> but be aware that prelude offers an alias for putStrLn . show, print
11:11:10 <jle`> so you can do print yourThing
11:11:15 <skypers_> and really wonder whether Haskell will be great to write games at some day
11:11:17 <jle`> aleksejs_: (^) is for integer exponentiation
11:11:27 <jle`> use ** for non-natural
11:12:06 <jle`> sorry, natural exponentiation
11:12:07 <aleksejs_> > 2**(-1)
11:12:07 <lambdabot>  0.5
11:12:07 <aleksejs_> thanks!
11:12:07 <jle`> i meant exponentiation closed over the integers
11:12:07 <jle`> :t (^)
11:12:07 <lambdabot> (Integral b, Num a) => a -> b -> a
11:12:07 <jle`> :t (**)
11:12:07 <lambdabot> Floating a => a -> a -> a
11:12:13 <rioch> jle`: thanks, gonna lookup show now :)
11:12:25 <skypers> something about Haskell is frightening me: the fact that despite progress, weâre still stuck to the academia way
11:12:58 <bennofs> What do you mean by "academia way"?
11:13:00 <dmj`> skypers: how so?
11:13:26 <skypers> bennofs: the fact that the community aims are not that important at some times
11:13:40 <skypers> for instance, Control.Lens is a great lib
11:13:58 <skypers> but for sure is not suitable for almost all projects
11:14:06 <skypers> because itâs too cryptic
11:14:08 <skypers> too academic
11:14:14 <jle`> lens is academic?
11:14:22 <skypers> jle`: Profunctors, Prism
11:14:23 <skypers> and so on
11:14:26 <skypers> everywhere
11:14:31 <cschneid> skypers: to understand how it works perhaps. But I can code java without knowing how the jvm does JIT
11:14:45 <cschneid> similarly, I can use lens without really understanding how it does its work
11:14:56 <skypers> cschneid: I just want to point something out here
11:15:11 <jle`> practical lenses are pretty non-academic...
11:15:18 <bennofs> I think that is actually a great strength of haskell that it is based on mathematics and laws. The abstractions from mathematics are often very powerful
11:15:27 <jle`> are you saying that Java's object.method() is academic?
11:15:32 <skypers> bennofs: so do I
11:15:33 <jle`> having a period in between the object and the method...
11:15:38 <skypers> Iâm not talking about that
11:15:40 <jle`> too advanced to understand how it is implemented
11:15:43 <jle`> too academic
11:15:50 <skypers> nope, jle`
11:16:18 <skypers> I remember being frustrated while writing C++
11:16:37 <lispy> johnw: I just ran into a problem with using shelly (not shelly's fault exactly) that I don't know how to solve.
11:16:46 <skypers> because I felt annoyed to write code that doesnât have any sense for the solution itself
11:16:50 <johnw> I have a hard time seeing how a Profunctor is "academic", it's simply the name of an interface.  Does that make an "Enumerator" any more academic?
11:16:55 <johnw> lispy: what?
11:16:56 <lispy> johnw: I'm converting a bash script that has to source a file that I don't control.
11:16:58 <skypers> for instance, writing patterns are shit like that
11:17:12 <skypers> but with foresight, itâs quite the same thing in Haskell sometimes
11:17:22 <skypers> the best example is the a monad stack
11:17:34 <johnw> lispy: what is the problem?
11:17:36 <skypers> it can transform to something really complex
11:17:52 <skypers> and we spend time to think in term of lift and liftIO
11:17:58 <dmj`> other framework jargon of "Service, Directive, Controller" sounds like a hardware store.
11:18:19 <ReinH> skypers: if you have to think about that more than once then you should be providing yourself with a better interface
11:18:21 <lispy> johnw: I can't source a bash script from Haskell.
11:18:31 <skypers> ReinH: yeah
11:18:37 <ReinH> That's a usability problem
11:18:39 <skypers> but itâs not that easy sometimes
11:18:42 <lispy> johnw: this thing i want to automate assumes that you automate it from sh
11:18:55 <skypers> ReinH: so you think thereâs always a way to make a concept really simple in Haskell?
11:19:00 <johnw> run "bash" ["-c", scriptPath]?
11:19:12 <jle`> complicated concept != academic
11:19:18 <Clint> that's not sourcing
11:19:23 <skypers> forget about the academic, jle`
11:19:24 <johnw> oh
11:19:28 <johnw> he needs the environment
11:19:33 <lispy> johnw: bingo
11:19:35 <skypers> Iâm talking about uses of haskell here
11:19:37 <skypers> just uses
11:19:38 <johnw> ok, you could do this:
11:19:48 <johnw> bash -c "scriptPath; env"
11:19:49 <ReinH> skypers: ok, goal posts shifted. Go on. ;)
11:19:54 <johnw> and then parse the output in Haskell
11:19:58 <skypers> to write a file parser, Haskell is really neat
11:19:59 <jle`> are you saying that haskell is too complicated to use?
11:20:06 <skypers> to write games
11:20:14 <lispy> johnw: that might work. Seems a bit hackish :)
11:20:14 <skypers> Haskell is nice, but not that much sometimes
11:20:29 <lispy> johnw: Can parents read the envs of children more directly?
11:20:33 <skypers> jle`: to me no, because I got to know how to use it
11:20:40 <skypers> but for common other people, sure
11:20:41 <johnw> lispy: it's not really all that hackish, I don't think; instead of having the "source" be applied to the environment, you're asking bash to report the environment after sourcing the script
11:20:42 <c_wraith> skypers: that's a library issue as much as anything.
11:20:48 <ReinH> Everything is hard to use until it is not
11:20:53 <ReinH> Is that on the tautologies list?
11:21:02 <skypers> another point: it requires you more brain activity than other languages
11:21:04 <skypers> for the same thing
11:21:07 <Chousuke> If you didn't call Profunctors profunctors chances are you'd call them something that instead of making sense only to category theorists make sense to no-one
11:21:08 <johnw> lispy: I don't think they can, unless the child reports it back to them
11:21:09 <jle`> is that really the case?
11:21:18 <lispy> johnw: I'm picturing that parsing the output of env is a bit more than I'd like to do (will I get all/any corner cases?)
11:21:21 <johnw> Chousuke++
11:21:26 <c_wraith> skypers: I disagree with that strongly.  Haskell requires less brain activity in most cases, because the compiler helps you so much.
11:21:30 <ReinH> skypers: if that's so then the question becomes: what do we *get* for that extra effort?
11:21:34 <ReinH> I think we get a lot
11:21:42 <skypers> sure
11:21:42 <johnw> lispy: parsing environment variables is very standard stuff, at least
11:21:48 <skypers> I have no counter argument about that
11:21:51 <skypers> and I love haskell
11:21:53 <jle`> i think it is just people who have been using haskell for one year complaining that it takes more effort than the language they have been using for ten years
11:21:56 <johnw> NAME=VALUE, where VALUE can contain anything but a newline
11:22:09 <skypers> jle`: thatâs a very true statement
11:22:15 <skypers> people are not ready for the transition
11:22:19 <Chousuke> c_wraith: I like to think that you get to spend more brain power on things that actually matter
11:22:25 <johnw> lispy: you could do something else
11:22:28 <c_wraith> honestly, I think haskell would be *really* good for game dev, if there were good-quality libraries oriented towards game development available.
11:22:28 <skypers> but still
11:22:47 <johnw> lispy: you could write a Haskell script to take the environment and persist it to disk using binary, and then read that persisted state in the parent
11:22:48 <skypers> c_wraith: what do you think of lambdacube ?
11:22:56 <ReinH> c_wraith: python wasn't particularly good for game dev before, e.g., pygame
11:22:58 <johnw> so, bash -c "source scriptPath; persistEnv"
11:23:04 <johnw> that way, you avoid any possible corner cases
11:23:06 <skypers> Iâm a demomaker and migrating my 3D C++ demoscene engine into Haskell
11:23:08 <skypers> Iâm almost done
11:23:10 <skypers> but hm
11:23:18 <skypers> I think Iâll need to refactor some part of it
11:23:24 <c_wraith> skypers: that's a pretty new lib, I know little about it.  But it's only the graphics side, iirc
11:23:25 <Chousuke> c_wraith: I mean, making the types match takes some thinking usually, but once you get to the point of having some running code, it becomes easier to keep the code running as you add things
11:23:30 <skypers> because itâs sometimes really disturbing and full of lifts
11:23:35 <lispy> johnw: true.
11:23:51 <c_wraith> There's a *lot* more to games than graphics.
11:23:58 <skypers> sure :)
11:24:03 <Chousuke> whereas with eg. python it's often the case that I run a script just to see how it breaks so that I can proceed :P
11:24:05 <lispy> johnw: I can also tell env -O and it will null terminate strings. That might make it more robust too
11:24:05 <dmj`> skypers: have you looked at the helm game engine? http://hackage.haskell.org/package/helm
11:24:08 <skypers> but itâs one of the hardest part, c_wraith
11:24:13 <skypers> nope dmj`
11:24:32 <c_wraith> skypers: I don't know about that.  I think the hardest part is sane user interfaces, and sane multiplayer systems.
11:24:35 <lispy> er, -0
11:24:39 <ReinH> c_wraith: netcode
11:24:54 <ReinH> which is possibly subsumed by "sane multiplayer systems"
11:25:06 <johnw> lispy: -O doesn't work on Mac
11:25:12 <johnw> nor -0
11:25:16 <bennofs> Chousuke: well, you can replace your functions with undefined and run it
11:25:23 <Jesin> Does the Haskell standard specify that (:+) is strict in both arguments?
11:25:31 <Chousuke> bennofs: I suppose
11:25:37 <bennofs> Chousuke: or use -fdefer-type-errors to get python-like type errors at run time (I haven't tried this yet)
11:25:40 <c_wraith> :t (:+)
11:25:40 <lambdabot> a -> a -> Complex a
11:26:08 <skypers> I also think Haskell could make it through, but on the other hand, itâs been there for over 20 years, and we still lack descent public applications
11:26:09 <lispy> johnw: I'm on linux :)
11:26:12 <c_wraith> Jesin: if it specifies that the fields of a Complex value are strict, then yes. Otherwise, no.
11:26:20 <skypers> when friends of mine ask me âWhat apps are built with Haskellâ
11:26:25 <skypers> I freeze
11:26:28 <Jesin> GHC defines it as "data Complex a = !a :+ !a"
11:26:30 <skypers> âHm wellâ¦â
11:26:35 <Jesin> c_wraith: yes, I know
11:26:42 <Chousuke> skypers: most apps that matter aren't publicly known though
11:26:47 <lispy> johnw: For this task, I'm deeply locked into linux so portability is not an issue.
11:26:51 <c_wraith> Jesin: those ! marks mean the fields are strict.  They will be evaluated at the same time the constructor is.
11:26:55 <skypers> Chousuke: thatâs just an excuse
11:26:59 <Jesin> I thought the use of strict data fields was nonstandard
11:27:03 <Chousuke> honestly, half of the world's infrastructure consists of perl hacks I bet
11:27:09 <Jesin> c_wraith: I know, that's what GHC uses
11:27:17 <Jesin> I was wondering if that's standard behavior
11:27:19 <c_wraith> Jesin: nope, that's part of the standard.  The non-standard part is putting them on function arguments
11:27:34 <ReinH> Jesin: it's part of the standard and also a standard practice
11:27:37 <skypers> Chousuke: ok, letâs say that way: highend-user programs
11:27:43 <lispy> johnw: I'm also tempted to not source that script. Diffing the env before/after I see that it makes really small changes.
11:27:48 <Jesin> c_wraith: ah, thans
11:27:50 <Jesin> *thanks
11:27:55 <johnw> lispy: watch out for process coding issues when reading the output from env -O
11:28:11 <lispy> johnw: I don't think I'll use -0
11:28:24 <geekosaur> the real worry might not be envars, but functions
11:28:24 <skypers> Haskell is awesome, why arenât there a lot of programs?
11:28:41 <c_wraith> A lot of haskell programs are web services
11:28:41 <lispy> I'll hard code the env and document that fact. That should work quite well for what i'm doing.
11:28:42 <lispy> johnw: thanks for the ideas!
11:28:58 <Chousuke> probably because Haskell is also kind of different
11:28:59 <skypers> in which aspect, Chousuke ?
11:29:05 <johnw> lispy: anytime :)
11:29:15 <c_wraith> The majority of the rest of haskell programs are proprietary business tools, or tools for working with haskell
11:29:37 <skypers> itâd be time to write high end user programs imho
11:29:44 <Chousuke> skypers: in the aspect that you can actually use equational reasoning and mathematical proofs in real-world haskell :P
11:29:46 <skypers> and this is something very frightening
11:29:55 <ReinH> skypers: hard to do that without a GUI story
11:30:09 <c_wraith> skypers: end-user programs have two major negatives in haskell-land.  Lack of GUI libraries, and windows being a third-class citizen
11:30:18 <ReinH> Probably why so many Haskell programs lean on HTML/CSS/JS to provide the interface
11:30:36 <skypers> we have gtk2hs
11:30:43 <ReinH> It's also as portable as you can get
11:30:46 <skypers> I guess a qt port already exist
11:30:53 <skypers> s
11:31:00 <ReinH> gtk2hs is not what I would call a GUI story
11:31:12 <skypers> what do you mean by âstoryâ then?
11:31:35 <skypers> I also hear cabal is kind of a bad program
11:31:37 <skypers> I donât get it
11:31:44 <skypers> cabal is just awesome
11:31:51 <skypers> I never had such a tool in other languages
11:31:56 <ReinH> A good enough set of libraries, a robust ecosystem, a wide set of deployment targets, etc
11:31:57 <skypers> C++ doesnât have any of that kind
11:32:14 <cwvh> That's a low bar.
11:32:16 <bennofs> I think if there is a thing that many haskellers hate, it's cabal :P
11:32:18 <ReinH> cwvh: it's a start
11:32:24 <skypers> bennofs: why?
11:32:28 <ReinH> and it's not something we have right now
11:32:31 <Jesin> skypers: ruby "gem", python "pip", perl "cpan"
11:32:43 <skypers> Jesin: haskell hackage
11:32:55 <ReinH> bennofs: the only thing worse than cabal are all the other haskell package installers
11:32:57 <skypers> so whatâs the problem?
11:33:11 <skypers> why is cabal wrong?
11:33:14 <bennofs> It got better, but before there were sandboxes, you often got dependency conflicts or broken packages
11:33:23 <skypers> yeah
11:33:28 <skypers> and we played with cabal-dev
11:33:31 <skypers> but nowadays
11:33:35 <bennofs> cabal is not really a package manager. You cannot uninstall packages, and you cannot "depend" on executables iirc
11:33:35 <skypers> cabal has that
11:33:43 <ReinH> bennofs: that's why I said "package installer" ;)
11:33:44 <bennofs> Yeah, I said, it's got better :)
11:33:48 <rioch> Yay! I solved the first project euler problem using haskell. I feel like a boss! ;)
11:33:49 <Jesin> bennofs: I have not heard about these "sandboxes", have you a link to an explanation?
11:34:11 <Jesin> Oh Haskell makes certain Project Euler problems really easy
11:34:11 <skypers> Jesin: sandboxes are local package repo
11:34:22 <bennofs> Jesin: http://coldwa.st/e/blog/2013-08-20-Cabal-sandbox.html
11:34:31 <dmj`> rioch: nice!
11:34:34 <rioch> Jesin: It took me 45 minutes :)
11:34:39 <cwvh> I prefer hsenv for non-development work.. if that makes any sense.
11:34:45 <rioch> I'm learning though, which is the point
11:35:10 <skypers> it feels impossible regular guys get their hands on haskell
11:35:12 <skypers> like Java ones
11:35:28 <ReinH> skypers: there's a scarcity of beginner/intermediate education resources
11:35:31 <ReinH> absolutely agree
11:35:33 <ReinH> but it's getting better
11:35:36 <skypers> I donât know the truth, but sometimes I feel like Haskell is for elites only
11:35:48 <ReinH> skypers: there is also a perception problem :)
11:35:55 <skypers> ReinH: I know!
11:35:58 <JuanDaugherty> regaler guyz, lulz
11:36:03 <Jesin> rioch: if you know how to use Data.List, Project Euler Problem 8 is the easiest thing ever
11:36:08 <skypers> I often say that Haskell is quite simple ONCE you decided to TRY
11:36:18 <ReinH> skypers: or even, dare I say it, regular gals? ;)
11:36:24 <chirpsalot> skypers: I think a lot of people that have programmed in Java avoid Haskell like the plague because strong / static typing in Java is kind of awful in comparison :P.
11:36:26 <skypers> ahah gals :)
11:36:45 <mello__> I've formulated my question on stackoverflow, if you guys could check it out, i could use some help.https://stackoverflow.com/questions/21002912/how-to-use-auth-and-postgresqlsimple-in-one-handler?noredirect=1#comment31566773_21002912
11:36:53 <JuanDaugherty> AKA, sane, DTE, etc. etc.
11:36:54 <ReinH> chirpsalot: and I'm sure a lot of people who have programmed Haskell avoid Java like the plague for similar reasons...
11:36:55 <skypers> chirpsalot: that, and also the fact that âNO NO NO, Haskell is so illisible! Iâd rather code in brainfuckâ
11:37:02 <skypers> I already heard of thatâ¦
11:37:25 <mello__> skypers: What I do find as a haskell beginner is, that once it compiles, it usually works as you'd expect.
11:37:27 <JuanDaugherty> translation: my intellectual peers that don't make me feel stoopid
11:37:31 <mello__> just throwing that in there.
11:37:33 <Jesin> "illisible"?
11:37:35 <skypers> mello__: yep
11:37:41 <skypers> Jesin: thatâs what they say, yes
11:38:11 <chirpsalot> Jesin: "illegible", I believe.
11:38:17 <skypers> nope
11:38:17 <mello__> skypers: been fighting with snap now, and well, 99% of the time, there's an error with my types not being correct. One it compiles... it works. Brilliant.
11:38:21 <Jesin> skypers: I don't know what that word means  ^^;
11:38:24 <skypers> illisible is french, sorry
11:38:27 <skypers> I meant hm
11:38:30 <mello__> unreadable?
11:38:34 <skypers> unreadable
11:38:34 <skypers> yes
11:39:20 <skypers> I had a brief trek in C++14 a few months ago
11:39:29 <skypers> lambdas with reference capturing isâ¦ ahah
11:39:39 <skypers> you know, hitting your balls with your legs.
11:40:13 <chirpsalot> skypers: how else do you play soccer :P
11:40:25 <ReinH> chirpsalot: legball, please
11:40:58 <chirpsalot> skypers: I haven't heard many people say Haskell is illegible... A couple have said they don't understand it, but I think that's a bit different.
11:41:44 <skypers> chirpsalot: some of my friends, C guys, donât think Haskell is a good language
11:42:03 <skypers> they think itâs only for brain-jizzing
11:42:05 <skypers> â¦
11:42:16 <chirpsalot> skypers: I'm much more of a C programmer than a Haskell programmer, to be honest.
11:42:19 <silasm> skypers: that's kind of funny considering the only one of my friends that's at all interested in Haskell is the C guy.
11:42:36 <skypers> silasm: he might be really nice and clever then :)
11:42:40 <skypers> and open-minded
11:42:54 <Iceland_jack> skypers: If you haven't used it an all your hear are people talking about monads and functors you might be excused for thinking that
11:43:20 <aleksejs_> skypers, most of my ex colleagues - php devs - think Haskell is completely useless language, because nothing is written on it
11:43:21 <skypers> Iceland_jack: well
11:43:23 <skypers> I donât really agree
11:43:27 <skypers> Haskell is like C
11:43:34 <silasm> aleksejs_: those are php devs.
11:43:39 <chirpsalot> Iceland_jack: yeah -- there is definitely a wall around Haskell :P.
11:43:40 <skypers> if youâve never heard of binary shifts nor preprocessor
11:43:48 <skypers> itâs really unreadable
11:43:56 <silasm> anyone who willingly uses php probably doesn't know anything about good language design, or doesn't care.
11:44:14 <skypers> aleksejs_: what do you tell them back?
11:44:27 <skypers> PHP is not a language
11:44:30 <davidfetter_disq> is a language design actually "good" if it takes a 150 IQ just to write hello world?
11:44:31 <skypers> itâs a joke.
11:44:43 <davidfetter_disq> i'm not saying haskell has this property, btw
11:44:44 <aleksejs_> there's nothing I can tell them back that they are able to understand
11:45:01 <skypers> aleksejs_: I donât have PHP friends
11:45:02 <skypers> I avoid them
11:45:03 <skypers> :D
11:45:08 <aleksejs_> :)
11:45:12 <silasm> davidfetter_disq: languages shouldn't be measured in how easy it is to write easy programs, but how easy it is to write hard programs.
11:45:13 <chirpsalot> davidfetter_disq: depends what the language is designed for :P?
11:45:19 <skypers> well IÂ have only one, but he has reasons
11:45:20 <mello__> skypers: PHP is a collection of tools, that's what i would call it
11:45:25 <silasm> at least, languages for professionals.
11:45:28 <silasm> for beginners, sure.
11:45:30 <skypers> (no heâs not mentally retarded)
11:45:39 <dmj`> the biggest misconception I've heard is that it's a language that you can't "get stuff done" in. It's not "pragmatic"
11:45:43 <aleksejs_> php is template engine with language-like features
11:45:48 <Iceland_jack> Some of my best friends are PHP programmers
11:45:50 <johnw> dmj`: I hear that often too
11:46:02 <skypers> 20:40 < Iceland_jack> Some of my best friends are PHP programmers
11:46:02 <davidfetter_disq> silasm, you've made an unsupported assertion there. a language you can't hire for could be bad no matter how well it deals with what you think of as hard programs.
11:46:16 <skypers> might have been hard to murder them then, no? :D
11:46:20 <johnw> dmj`: that's like saying Hungarian isn't a language people actually speak, just because no one around you is speaking it
11:46:21 <skypers> just kidding ;)
11:46:25 <levi> PHP is a frankenstein's monster of a language, but if you're already a good programmer you can do reasonable things with it, and it's a really cheap and ubiquitous platform.
11:46:40 <silasm> davidfetter_disq: you're conflating "bad for business" with "bad language design". Those are different things.
11:46:45 <Sorella> silasm, "how easy it is to write *correct* programs" is a more meaningful metric for me.
11:46:49 <Iceland_jack> skypers: It was a mercy killing :)
11:46:55 <mello__> I hope you guys think better of Javascript than PHP?
11:47:06 <skypers> sure mello__
11:47:07 <Sorella> Even easy programs can be difficult to write correctly ;P
11:47:08 <dmj`> johnw: ha exactly, the assumption is that if it's difficult there must be a problem w/ the language, not w/ my understanding
11:47:10 <skypers> but not that much
11:47:16 <skypers> Javascript is quite stupid
11:47:24 <silasm> Sorella: well yes, I figured correctness and some degree of efficiency were implied.
11:47:24 <davidfetter_disq> silasm, a language you can't actually get any code deployed in is pretty irrelevant. whether you want to call that "bad" depends very heavily on the criteria you're using
11:47:28 <johnw> dmj`: or the fact that *they* aren't doing productive things with Haskell doesn't mean that no one is!
11:47:37 <aleksejs_> javascript not that bd, but it has awful design features
11:47:37 <skypers> {} + [] â  [] + {} and yiels some JS shit
11:47:44 <skypers> like [] or {[]}
11:47:55 <Iceland_jack> mello__: Just keep in mind that there are many criteria by which to judge a language, people in Haskell generally use different criteria than users of other languages
11:48:02 <Sorella> silasm, that would be a good thing, but doesn't seem to be the case when you look at what the industry is doing. I mean, there are people who still use null.
11:48:12 <chirpsalot> Iceland_jack: how so?
11:48:21 * davidfetter_disq uses null all the time
11:48:22 <aleksejs_> skypers, it's because {} at beginning of line is not an object, but empty block of code
11:48:23 <davidfetter_disq> ... in SQL
11:48:33 <skypers> aleksejs_: ahah what theâ¦
11:48:39 <mello__> skypers: I agree, since I've seen past Java and PHP, boy do i hate those languages now..
11:48:39 <aleksejs_> and it's bad design decision
11:49:06 <Iceland_jack> chirpsalot: Some people value productivity, some people value safety, some people value aesthetics, some people value how much the language changes the way they view programming, ...
11:49:12 <skypers> about Haskell
11:49:16 <aleksejs_> I mean, when you see {}, you think it's an empty object
11:49:44 <skypers> the only thing it lacks to me is a nicer record syntax update
11:49:45 <bennofs> Iceland_jack: you managed to list only thinks where IMO haskell is good at :p
11:49:46 <skypers> âbut you have lenses for that!â
11:49:48 <skypers> yeah, well, noâ¦
11:49:52 <silasm> davidfetter_disq: good design has more to do with reusability of features than simple deployment imo. You can hack together something in C or PHP and get it deployed, but you'll be hard pressed to use anything from that project in a different context compared with something in, say, Haskell.
11:49:54 <johnw> what I like most about Haskell is that it makes it harder to do stupid things, but not so hard that the problem gets lost in the solution
11:50:25 <carter> johnw: and actual abstractions
11:50:30 <johnw> for example, an "uninitialized value" isn't a concept that even makes sense in Haskell
11:50:43 <skypers> :t undefined
11:50:44 <lambdabot> a
11:50:47 <carter> :p
11:50:50 <skypers> :D
11:50:50 <silasm> Sorella: again, "good design" and "good for business / what the industry is using" don't always match up :/
11:50:59 <carter> sadly true
11:51:00 <johnw> skypers: haha
11:51:03 <aleksejs_> what I like in Haskell is that when you write a Haskell code, it actually makes sense, and you can feel it
11:51:05 <Sorella> silasm, which is really sad
11:51:06 <Hodapp> "Industry standard" is another word for "average".
11:51:11 <johnw> I like to pretend I live in a world without _|_
11:51:20 <Iceland_jack> johnw: Total..ly
11:51:25 <Hodapp> Iceland_jack :P
11:51:26 <Sorella> Ahaha
11:51:28 <skypers> johnw: undefined is actually handy
11:51:30 <chirpsalot> johnw: there is no _|_ it's turtles all the way down?
11:51:33 <Hodapp> Iceland_jack: I'm partial to that joke.
11:51:35 <JuanDaugherty> a bottomless pit?
11:51:37 <skypers> for alignment, sizeOf
11:51:37 <johnw> undefined is greats until my code is done
11:51:40 <carter> "I like big _|_'s, thats a lie"
11:51:47 <lispy> johnw: Whenever I try that* * * Exception: Pattern match failure
11:51:51 <yesthisisuser> i like undefined when getting the types in order
11:51:56 <skypers> though it should be placed in a module
11:51:57 <carter> skypers: alignment
11:51:57 <Iceland_jack> carter: You missed a ââ¥ â Aâ joke there
11:51:58 <carter> hehe
11:51:59 <Sorella> johnw, actually, that concept doesn't make sense in a strict language with extreme late binding of all names either, like Newspeak :)
11:52:02 <skypers> not in Prelude
11:52:03 <Iceland_jack> âI like bit â¥ and that's absurd.â
11:52:06 <Iceland_jack> *big
11:52:37 <quchen> johnw: There are a couple of legitimate uses of undefined though, the paper on reflections uses them for example.
11:52:57 <johnw> quchen: true, like skypers mentioned with sizeOf
11:52:59 <silasm> so before I got sidetracked by the mention of php, I came here to ask if there's some way to make a monoid out of a "a -> a -> Reader a"
11:53:03 <silasm> or something of that sort
11:53:06 <johnw> though I'm a big fan of Data.Proxy now
11:53:16 <bennofs> Is there a MonadEither class somewhere for the either package?
11:53:21 <quchen> johnw: Oh, I didn't see that. Yeah, sizeOf is effectively what undefined is used there.
11:53:22 <johnw> silasm: a monoid must be a -> a -> a
11:53:36 <silasm> johnw: yeah, that's the issue.
11:54:04 <skypers> has John Carmack ever made a trip in here at some day?
11:54:17 <silasm> johnw: I have a function that *given* a fixed value is a monoid, but without it isn't
11:54:39 <silasm> hang on, I'll link the file (it's still kind of a mess, but it's reasonably well commented)
11:55:03 <johnw> skypers: I've not seen him
11:55:27 <silasm> https://github.com/silasm/psubseq/blob/55bdf04c26436de7e2902e70db20eddf89087984/src/psubseq.hs
11:55:49 <skypers>     No instance for (MonadIO ((->) BufferTarget))
11:55:55 <skypers> god I hate that error.
11:56:09 <saml> @src flip
11:56:09 <lambdabot> flip f x y = f y x
11:56:18 <silasm> I'm trying to build up a monoid to mapreduce the problem of finding the largest subsequence shared by two sequences
11:56:25 <quchen> johnw: Is there documentation for Proxy somewhere?
11:56:43 <saml> flip id 1 2 == id 2 1 ?
11:56:59 <skypers> :t flip id 1 2
11:57:00 <lambdabot> (Num b, Num (b -> c)) => c
11:57:15 <geekosaur> :t flip
11:57:15 <lambdabot> (a -> b -> c) -> b -> a -> c
11:57:25 <skypers> > flip id 1 2 == id 2 1
11:57:27 <lambdabot>  No instance for (GHC.Num.Num a1) arising from the literal `1'
11:57:27 <lambdabot>  The type variable `a1' is ambiguous
11:57:27 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:57:27 <lambdabot>  Note: there are several potential instances:
11:57:27 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
11:57:37 <skypers> you got your answer
11:57:57 <skypers> > flip id 1 2 == const 2 1
11:57:58 <lambdabot>  No instance for (GHC.Num.Num a0) arising from the literal `2'
11:57:58 <lambdabot>  The type variable `a0' is ambiguous
11:57:58 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:57:58 <lambdabot>  Note: there are several potential instances:
11:57:58 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
11:58:00 <bennofs> Can I mix conduit with resourcet with EitherT?
11:58:06 <skypers> dammit
11:58:07 <johnw> quchen: http://hackage.haskell.org/package/tagged-0.7/docs/Data-Proxy.html
11:58:28 <skypers> > flip const 1 2 == const 2 1
11:58:29 <lambdabot>  True
11:58:34 <johnw> bennofs: I don't see why not
11:58:45 <quchen> johnw: That page is why I'm asking :-Ã¾
11:58:52 <skypers> > flip const undefined 2 == const 2 undefined
11:58:53 <lambdabot>  True
11:58:56 <triliyn> :t flip id
11:58:57 <lambdabot> b -> (b -> c) -> c
11:59:02 <silasm> alternatively if I could make something like (Reader s a -> Reader s a -> Reader s a) out of this, that'd work, but the 's' would have to be the same for all 3, and I don't think I can specify that constraint.
11:59:19 <triliyn> > flip id 1 succ
11:59:19 <johnw> quchen: in place of undefined :: a, you would use Proxy :: proxy a, so it doesn't necessarily work with sizeOf
11:59:20 <lambdabot>  2
11:59:22 <quchen> johnw: Proxy a = Tagged a ()?
11:59:33 <johnw> yeah, pretty much
11:59:44 <quchen> Alright, let's see whether the Tagged docs help then.
12:00:02 <skypers> :t loeb
12:00:03 <lambdabot> Not in scope: `loeb'
12:00:08 <bennofs> johnw: But what is the correct nesting? EitherT over ResourceT or the other way arround=
12:00:10 <skypers> ahah, that function was funny
12:00:28 <johnw> bennofs: I would nest ResourceT over EitherT
12:00:29 <Philonous> Bah, it's annoying when ghci infers a type annotation that it doesn't accept
12:00:45 <c_wraith> Proxy and Tagged are pretty much the same thing, but they switch between positive and negative position for the extra type variable
12:00:46 <quchen> johnw: Oh, it's just a way of avoiding the `undefined` in the reifications?
12:00:58 <skypers> I think so quchen
12:01:09 <johnw> quchen: that, and the types make it clearer that the argument is only for proxying a type variable
12:01:20 <triliyn> Philonous: that's probably either a type name that's not in scope or something that requires ScopedTypeVariables
12:01:53 <c_wraith> johnw: are you familiar with using proxy a instead of Proxy a in type signatures?  It's actually a really nice trick.
12:02:03 <johnw> c_wraith: yes, I usually use proxy a
12:02:12 <johnw> that way only the caller needs the tagged dependency
12:02:17 <Philonous> triliyn, ScopedTypeVariables are enabled
12:02:28 <Philonous> triliyn, Oh, my bad
12:03:22 <skypers> 20:57 < sam> tant que c'est pas du Haskell n'importe qui peut comprendre
12:03:25 <skypers> once againâ¦
12:03:48 <skypers> translation: âas long as itâs not Haskell, every one can get itâ
12:03:53 <mello__> skypers: sorry late reply, yeah i totally understand :). Trust me that my views have changed since I started using other languages but java and php
12:03:56 <johnw> bennofs: actually, maybe not
12:03:58 <johnw> bennofs: http://hackage.haskell.org/package/easy-api-0.1.0.0/docs/src/Network-HTTP-API.html
12:04:04 <johnw> bennofs: that code nests EitherT over ResourceT
12:04:10 <skypers> mello__: :)
12:04:34 <skypers> :t (1,2) & _2 .~ 5
12:04:35 <lambdabot> (Num t, Num b) => (t, b)
12:04:44 <skypers> Iâm going to paste that to sam
12:04:46 <shiona> is there a datastructure that 1) keeps elements in order 2) allows iteration (is a zipper or something like that?) 3) allows item insertion while iterating?
12:04:48 <skypers> itâll love that ahah
12:05:03 <skypers> huh, Set?
12:05:13 <ReinH> shiona: []?
12:05:16 <skypers> not sure for the 3.
12:05:21 <johnw> shiona: rather than insert while iterating, you'd fold and generate a new structure sharing elements from the old
12:05:48 <triliyn> Insertion for lists is linear in your position in the list
12:05:52 <ReinH> fold that either does (:) or inserts an element
12:06:02 <quchen> triliyn: Only when you start at the beginning.
12:06:09 <skypers> > (1,"Hello") & _2 <>~ ", world!"
12:06:11 <lambdabot>  (1,"Hello, world!")
12:06:36 <shiona> hmm, I'll have to take a peek at set, brb
12:06:48 <triliyn> skypers: are you one of the people who doesn't like lens operators?
12:07:00 <skypers> triliyn: yes I am
12:07:12 <skypers> I know itâs handy
12:07:17 <skypers> but too cryptic
12:07:27 <quchen> Waaaait, <>~ is "mconcat="?
12:07:34 <triliyn> Yeah, I never would have guessed <>~ without seeing what it did
12:07:40 <quchen> How did I not see this before
12:07:51 <quchen> Eh, "mappend="
12:08:06 <ion> <>~ fits the pattern.
12:08:31 <triliyn> But it is distractingly shaped like a fish!
12:08:38 <skypers> <>~ is looking for some ovules.
12:08:41 <quchen> Rat. It's a rat.
12:08:43 <triliyn> And it made me think of other things I don't remember that have been called "fish operator"
12:09:13 <quchen> Can't beat robot monkey. (:[])
12:09:20 <skypers> dafuck is that
12:09:25 <Jeanne-Kamikaze> xD
12:09:40 <ion> > (:[]) "hello"
12:09:41 <lambdabot>  ["hello"]
12:09:54 <skypers> oh
12:09:55 <skypers> yes
12:10:03 <skypers> :t (:[])
12:10:04 <lambdabot> a -> [a]
12:10:04 <johnw> i use robot monkey pretty frequently
12:10:05 <adelbertc_> given Ord is a super class of Ix, is there an implementation of compare using the methods required by Ix?
12:10:23 <skypers> I like the snail operator as well
12:10:28 <skypers> :t (^@..)
12:10:29 <lambdabot> s -> IndexedGetting i (Endo [(i, a)]) s a -> [(i, a)]
12:10:49 <quchen> adelbertc_: What's wrong with Ord's comparison functions?
12:11:42 <adelbertc_> quchen - nothing - I'm trying to encode the Ix type class in Scala and am wondering if Ix provides a default implementation of Ord's compare (so that instances need only define Ix functions)
12:11:59 <adelbertc_> I'm having a bit of trouble locating the source for Ix to see if this is true as well..
12:12:03 <Twey> http://hackage.haskell.org/package/numeric-prelude-0.4.0.3/docs/src/Number-DimensionTerm.html#T â why is there an undefined in this Show instanceâ¦?  x.x
12:12:32 <quchen> adelbertc_: Source: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Ix.html
12:12:54 * hackagebot hsimport 0.2.6.6 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.6.6 (DanielTrstenjak)
12:13:27 <adelbertc_> quchen - Saw that, seems to simply be.. content-less? (Please excuse my naive-ness, a bit new to Haskell)
12:13:27 <quchen> adelbertc_: I guess you can use `index` and then compare the resulting integers, although that is hardly very efficient
12:13:39 <geekosaur> Twey: because only the type matters, not the value? (consider for example how Data.Fixed works)
12:13:46 <quchen> Oh, right, that module is a bit empty. Sorry :-)
12:13:46 <lingxiao> hey call, could someone tell me what this lambda expression evaluates to?
12:14:00 <lingxiao> (Î»x.x)z
12:14:11 <lingxiao> does it evaluate to z ? or simply to (Î»x.x)z
12:14:32 <Twey> geekosaur: But it's passed to showsPrec
12:14:39 <quchen> adelbertc_: ixCompare x y = compare (index (x,y) x) (index (x,y) y)   -- That's what I meant
12:15:11 <Twey> lingxiao: z
12:15:12 <philed> lingxiao: Its normal form is z.
12:15:23 <geekosaur> Twey: sure. I imagine that dimensions are represented as type witnesses, and in this case showsPrec for a dimension witness ignores the value and shows a constant string
12:15:42 <Twey> Oh, I see
12:15:43 <lingxiao> but the normal form of z(Î»x.x) is z(Î»x.x) correct?
12:16:33 <mello__> :t id
12:16:34 <lambdabot> a -> a
12:16:45 <mello__> :t (<$>)
12:16:46 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:16:50 <philed> lingxiao: Yeah.
12:16:58 <Twey> lingxiao: That's irreducible, yes (because you don't know the value of z)
12:17:42 <lingxiao> ok awesome. the example (Î»x.x)z evaluating to z makes intuitive sense
12:18:13 <ReinH> lingxiao: what does `f id' evaluate to?
12:18:24 <lingxiao> but the small step operational semantics states that "(Î»x.t)v  -> [x +-> v]t "
12:18:35 <adelbertc_> quchen - ah interesting
12:18:45 <Twey> geekosaur: That makes sense; thanks.  I was trying to write âdata MyUnit = MyUnit deriving Showâ which gave me an undefined error; I guess I should be writing âdata MyUnit; instance Show MyUnit where show = const "MyUnit"
12:19:00 <lingxiao> I'm assuming only the outside term has to be a value? where value = some lambda abstraction
12:19:00 <Twey> lingxiao: But you don't have an expression of that form
12:19:20 <Twey> lingxiao: The pattern (Î»x.t)v does not match the term z
12:19:29 <Twey> So that rule can't be applied
12:19:49 <lingxiao> right that's why I'm confused as to why z is substituted for x
12:20:01 <lingxiao> z is irreducible, so none of the other rule apply
12:20:18 <lingxiao> it seems like the normal form of (Î»x.x)z then is just (Î»x.x)z
12:20:26 <Twey> lingxiao: Oh, sorry, I was talking about the z(Î»x.x) example
12:20:55 <lingxiao> Twey: oh sorry yeah I wasn't clear, so yeah I'm still confused about this rule:  "(Î»x.t)v  -> [x +-> v]t"
12:21:01 <lingxiao> in relation to "(Î»x.x)z"
12:21:18 <lingxiao> i'm guessing the v in (Î»x.t)v doesn't have to be a value? the variable is unfortunately named?
12:21:20 <Twey> lingxiao: (Î»x.t)v matches (Î»x.x)z assuming variables are part of the syntax for the metavariable âvâ
12:21:27 <hhhhhhhh> how can i make `cabal update` use less memory? my vps only has 128mb and it's imploding before it can finish :d
12:21:34 <philed> lingxiao: The v is any term.
12:21:43 <lingxiao> ok cools thanks for clearing it up, I just assumed v stands for something it doesnt
12:21:48 <Twey> Well, it depends on your evaluation strategy
12:21:50 <c_wraith> hhhhhhhh: I don't think you can.
12:21:58 <lingxiao> call by value
12:22:09 <lingxiao> I'm currently doing
12:22:12 <Twey> Then v will be any value, i.e. non-error irreducible term
12:22:12 <ion> hhhhhhhh: Add swap, and also why so little memory for a VPS? à² _à² 
12:22:25 <c_wraith> hhhhhhhh: it downloads the whole package database, and has it all in memory at once
12:22:25 <ion> Thatâs barely more than my Amiga has.
12:22:32 <Earnestly> +RTS -M200m
12:22:45 <Twey> Including free variables
12:22:51 <hhhhhhhh> ion: Â£10/year
12:22:52 <Earnestly> Assuming cabal is built with -rtsopts
12:23:19 <lingxiao> see this is where I got confused, in Pierce's book, he defines value as v ::= Î»x.t
12:23:24 <lingxiao> so lambda abstractions only
12:23:48 <Twey> What page?
12:23:49 <lingxiao> as if to suggest some variable z is *not* a value
12:23:55 <lingxiao> page 72
12:24:03 <lingxiao> figure 5-3
12:24:15 <c_wraith> hhhhhhhh: there are haskell libs that take over a gig to link.
12:24:38 <ReinH> c_wraith: o_O
12:24:41 <c_wraith> hhhhhhhh: compilation on that vps is going to be chancy no matter what.  I'd strongly recommend compiling on a local vm and just copying binaries.
12:24:44 <lingxiao> then he further states:
12:24:45 <lingxiao> "Notice how the choice of metavariables in these rules helps control the order of evaluation. Since v2 ranges only over values, the left-hand side of rule E-AppAbs can match any application whose right-hand side is a value."
12:25:11 <c_wraith> ReinH: partly due to ld not being optimized for low memory, partly due to the insane amount of inlining.  HXT is one example.
12:25:12 <lingxiao> making a point of saying something like: "(Î»x.E)z" does not reduce
12:25:20 <frege> is there an actual serious lean book that I can get for haskell? I don't enjoy reading long paragraphs from learn haskell
12:25:30 <hhhhhhhh> c_wraith: haha ok
12:25:31 <Twey> lingxiao: Yep, I think you're right
12:25:35 <c_wraith> frege: graham hutton's book?
12:25:44 <Earnestly> frege: The Craft of functional Programming is nice
12:25:46 <frege> c_wraith: would you link me?
12:25:47 <Twey> (Î»x.x)z won't reduce under this system, with call-by-value evaluation
12:25:55 <lingxiao> Twey: arggh :(, even though it defies common sense
12:26:01 <Twey> You'd need to reduce z first
12:26:03 <dmj`> frege: typeclassopedia
12:26:05 <c_wraith> frege: http://www.cs.nott.ac.uk/~gmh/book.html
12:26:13 <Twey> It makes sense for call-by-value; call-by-value is just unintuitive ;)
12:26:28 <c_wraith> frege: like most real books, it's not free. :)
12:26:30 <Earnestly> c_wraith: How old is that?
12:26:44 <c_wraith> Earnestly: 2007.  Recent enough for learning the basics.
12:26:51 <Twey> lingxiao: Think of it like in C: foo(bar) doesn't compute if bar doesn't compute
12:27:05 <lingxiao> Twey: ahh ok that makes sense
12:27:09 <tippenein> :t skipMany
12:27:09 <lambdabot> Not in scope: `skipMany'
12:27:12 <frege> so what's the conclusion?
12:27:15 <lingxiao> what is the strategy called where (\x -> x)z does reduce to z
12:27:29 <Earnestly> c_wraith: As long as it doesn't start talking about hugs ;p
12:27:31 <quchen> Î² reduction?
12:27:43 <frege> c_wraith: "it requires no previous programming experience and all concepts are explained from first principles via carefully chosen examples."
12:27:44 <Twey> lingxiao: Some kind of non-strict evaluation
12:27:53 <frege> c_wraith: I know programming, I need something lean
12:27:56 <lingxiao> ahh ok thank ou Twey!
12:28:11 <c_wraith> frege: if you want to really learn haskell, you should treat it as learning something entirely new.
12:28:23 <Earnestly> frege: The Craft of Functional Programming (3rd Edition if you can)
12:28:42 <c_wraith> frege: I had a devilish time learning haskell, because unlike every other programming language I'd learned, it was actually something new.
12:28:49 <Twey> frege: RWH is a bit leaner than LYAH, with more code examples and fewer paragraphs
12:29:02 <ReinH> Prog. in Haskell or CoFP?
12:29:05 <mello__> can haskell do string interpolation Ã  la ruby ish?
12:29:14 <mello__> I suppose not but worth asking
12:29:17 <johnw> mello__: with libraries, yes
12:29:18 <c_wraith> I'm firmly of the opinion that RWH is very bad for *learning* haskell.
12:29:19 <Twey> But yes, you shouldn't expect it to be like going from Java to Python
12:29:29 <frege> what do you guys think of The Craft of Functional Programming?
12:29:31 <Twey> mello__: You can do it with Template Haskell or various type-level tricks
12:29:31 <quchen> What's this "lean" you're talking about?
12:29:32 <philed> Which is the Haskell book that covers FRP. I love that one.
12:29:32 <johnw> mello__: for example, Haste, Shakespeare, or 'here'
12:29:44 <c_wraith> RWH is great for improving your haskell.  But it's very bad for learning.
12:29:52 <frege> philed: which book?
12:29:52 <mello__> Twey: you mean {-# LANGUAGE TemplateHaskell #-}?
12:29:56 <conal> philed: Paul Hudak's  School of Expression
12:30:01 <philed> That's the one.
12:30:05 <ReinH> c_wraith: I have to say I found RWH rather hard to follow
12:30:12 <Earnestly> ReinH: Agreed
12:30:18 <ReinH> both when I was first learning Haskell and when I came back to it a couple years later
12:30:20 <philed> Figured conal would know.
12:30:26 <conal> ;)
12:30:30 <ReinH> conal: hi :)
12:30:33 <quchen> Especially after LYAH's infotainment (in the good sense) RWH is a bit dry.
12:30:42 <conal> ReinH: howdy
12:30:46 <ReinH> there are very few cartoons :(
12:30:46 <c_wraith> I tried to use RWH when I was learning - it implicitly assumed a lot of haskell knowledge.
12:31:03 <ReinH> c_wraith: for me also the pacing was strange
12:31:08 <Twey> mello__: Template Haskell is a metaprogramming system for Haskell; {-# LANGUAGE TemplateHaskell #-} just enables the syntax extensions.
12:31:15 <frege> ok so you guys like Paul Hudak's  School of Expression ?
12:31:15 <ReinH> "here are functors... aaand now we're writing a parser from scratch" sort of thing
12:31:36 <mello__> Twey: ok; thanks i'm not getting into that now ;p but good to know it exists
12:31:36 <Twey> mello__: It's kind of like the C preprocessor (but better typed, and you write the macros in Haskell :Ã¾)
12:31:39 <dmj`> ReinH: c_wraith: those rwh examples were way over my head when I started
12:31:51 <quchen> ReinH: http://abstrusegoose.com/474
12:32:10 <ReinH> quchen: yes exactly
12:32:22 <Twey> quchen: Haha, perhaps
12:32:24 <philed> frege: It gets my recommendation.
12:32:26 <frege> I'm ordering 'Paul Hudak's  School of Expression'
12:32:26 <frege> last chance to change my mind
12:32:27 <frege> any thoughts?
12:32:28 <Earnestly> frege: I was in the same position.  Didn't like rwh and found lyah too casual and hard to mitigate all the colourful language.  Try Craft, read excepts.  I found it brilliant
12:32:30 <ReinH> quchen: or alternatively, http://www.joe-ks.com/archives_may2011/HowToDrawAnOwl.jpg
12:32:51 <philed> frege: I'm not so keen on Craft, but its got lots of exercises, and I like the stuff with pictures.
12:32:58 <ReinH> Earnestly: how would you compare Craft with Programming Haskell?
12:33:05 <Earnestly> ReinH: I don't know the latter sadly
12:33:09 <ReinH> ah
12:33:09 <frege> I'm gonna go with Paul Hudak's  School of Expression
12:33:19 <ReinH> frege: you could even get more than one if you want :D
12:33:21 <Earnestly> Or that, I should have a peek
12:33:38 <Earnestly> There are ways of "previewing" these books before you fork out the money
12:33:42 <c_wraith> frege: that's not a bad choice
12:33:58 <Earnestly> (I've been burned by expensive programming books, I always make sure they're worth it these days :\)
12:34:05 <tristan_1> i assume someone asked already, but why not LYAH or Real World Haskell?
12:34:08 <frege> Earnestly: yeah of course
12:34:20 <tristan_1> (both free or paid)
12:34:50 <ReinH> tristan_1: they have been tried and found wanting
12:34:51 <ReinH> sort of
12:35:00 <bjorkintosh> frege, hold on.
12:35:05 <bjorkintosh> he's written another book.
12:35:13 <bjorkintosh> it's on his website. you might want to look at that first.
12:35:27 <tristan_1> and RWH is not leaner than LYAH... it is larger
12:35:50 <frege> bjorkintosh: which one?
12:35:56 <bjorkintosh> hudak.
12:36:03 <quchen> Again, what's this "lean" you're talking about? :-\
12:36:04 <tristan_1> I didn't do any haskell for a long time and came back with LYAH and RWH out and have found them useful
12:36:06 <bjorkintosh> let me see if i can find it.
12:36:31 <frege> bjorkintosh: which book I mean
12:36:51 <c_wraith> One time I asked for a scala book that just explained the language's semantics, to someone who was experienced in both java and haskell.  No one could come up with anything that just explained what the various language constructs are and what they mean.
12:36:56 <frege> quchen: I'm looking for the right book to learn haskell, that's all
12:36:59 <tristan_1> I do find it odd, and I think unique to Haskell, that books and tutorials spend so much time doing the internal workings of libraries tho
12:37:16 <c_wraith> tristan_1: nah, scala books do that too
12:37:17 <bjorkintosh> it's called the haskell school of music, frege.
12:37:26 <dmj`> frege: if you want pure haskell check out the typeclassopedia
12:37:34 <dmj`> @typeclassopedia
12:37:34 <lambdabot> Unknown command, try @list
12:37:44 <frege> bjorkintosh: that sounds interesting actually, since my need is on DSP side
12:37:53 <bjorkintosh> yeah. plus, it is free.
12:37:54 <dmj`> frege: http://www.haskell.org/haskellwiki/Typeclassopedia
12:38:03 <tristan_1> c_wraith: I find it very annoying for wanting to look up stuff, hehe
12:38:10 <frege> dmj`: checking it now
12:38:23 <bjorkintosh> plus, frege, i believe it is more fun.
12:38:25 <frege> bjorkintosh: I can't find it though, would you please link it?
12:38:33 <philed> Twey: It's been some years since I read Pierce's book. Is the rule that lingxiao was talking about there to prevent you from reducing the (\x. x) y part of (\y. (\x. x) y) ..., when really you should wait for the outer-lambda to be reduced?
12:38:34 <frege> dmj`: http://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf ?
12:38:37 <ReinH> carter: anagrams :D
12:38:45 <carter> ReinH: you sir, are clever
12:38:49 <bjorkintosh> frege, here's the website: http://haskell.cs.yale.edu/euterpea/haskell-school-of-music/
12:38:55 <dmj`> frege: yes
12:38:58 <ReinH> carter: I, sir, looked it up with an anagram generator.
12:39:02 <bjorkintosh> click on publications.
12:39:03 <Earnestly> bjorkintosh: ta
12:39:08 <philed> I seem to remember there being some annoyances having to shove extra arguments onto values to get them to properly normalise, or something.
12:39:08 <ReinH> carter: I mean yes. Clever.
12:39:09 <carter> ReinH: thats even more clever
12:39:12 <ReinH> :D
12:39:21 <frege> http://www.haskell.org/haskellwiki/Typeclassopedia look lean and very interesting.....
12:39:33 <ReinH> frege: it's a nice crash course and a good reference
12:39:49 <c_wraith> Typeclassopedia is a good reference for commonly used abstractions, but that's not the same as the language itself
12:40:01 <Earnestly> bjorkintosh: Lovely latex too â¤
12:40:22 <bjorkintosh> yeah. i think it's neat.
12:40:40 <bjorkintosh> frege, you'll find a few things on DSP and reactive functional programming on the publications page.
12:40:49 <bjorkintosh> another lean one is hutton's programing in haskell.
12:41:20 <c_wraith> bjorkintosh: he rejected that as being "too beginner", which I think is missing the point entirely
12:41:54 <bjorkintosh> well, there are a few gotchas in haskell which kept biting me in the ass. i thought it was useful as a super quick reference.
12:41:54 <ReinH> c_wraith, frege: I've been using haskell for a few years and I'm just starting Hutton's book now.
12:42:05 <frege> bullshit
12:42:10 <frege> ReinH: is trolling
12:42:15 <ReinH> nope
12:42:16 <frege> ahh sorry
12:42:18 <ReinH> Literally just bought it
12:42:31 <ReinH> I've been meaning to read it but haven't yet
12:42:37 <quchen> ReinH: Visual proof in the next Haskell cast required
12:42:39 <frege> I misunderstood you
12:42:39 <frege> I thought you were misquoting me
12:42:42 <frege> ReinH: sorry
12:42:45 <ReinH> quchen: well I bought the kindle version :p
12:42:46 <bjorkintosh> there aren't many books on haskell. lots more on ML at different levels, so you don't have that many options frege.
12:43:00 <ReinH> frege: no worries, but that langauge isn't helpful :)
12:43:01 <frege> bjorkintosh: you mean ML with haskell?
12:43:07 <bjorkintosh> no.
12:43:10 <bjorkintosh> just ML.
12:43:19 <c_wraith> let's see if I can install threadscope cleanly on my vm.  This'll be interesting
12:43:37 <philed> Forgive me, but I think the only popular MLs now are F# and Ocaml, and I don't know of many books for either. I learned Ocaml from the horrible website.
12:43:51 <wXeno> bjorkintosh: it's not exactly blooming with ML books either... there are some on SML (which are kinda dated), and 1-2 useful on O'Caml
12:43:56 <ReinH> c_wraith: I got threadscope to work on mac only by finding a precompiled binary :/
12:44:05 <tippenein> philed: oreilly has a new ocaml book
12:44:13 <philed> tippenein: Real World Ocaml?
12:44:16 <c_wraith> ReinH: fortunately, I'm using a linux vm.  it should be somewhat easier
12:44:22 <tippenein> philed: ya, that one
12:44:22 <philed> I'm pretty excited about that one.
12:44:24 <ReinH> c_wraith: hopefully
12:44:25 <bjorkintosh> wXeno, yes, that is true. however, i find the nuggets of 'FP' wisdom are spread all over the place.
12:44:26 * wXeno got that one in his bookshelf 
12:44:49 <bjorkintosh> i use the SML books, dated as they are, for further clarification when i get lost.
12:45:08 <wXeno> there's a new version of "ML for the working programmer" btw
12:45:15 <bjorkintosh> new? no!
12:45:20 <bjorkintosh> really? lemme see.
12:45:21 <wXeno> yeah, new
12:45:22 <wXeno> 2012
12:45:28 <bjorkintosh> bah. i'm going to be poor.
12:45:46 <wXeno> nah, even september 2013
12:45:51 <frege> ReinH: I'm really sorry to judge what you said too quickly without thinking about it, just want to let you know
12:45:58 <ReinH> frege: no worries
12:46:01 <ReinH> frege: and thanks
12:46:22 <ReinH> Also must my fingers persist in typing langauge every time? *sigh*
12:46:42 <quchen> ReinH: So why did you buy the book? It's more basic than LYAH even
12:46:53 <quchen> I feel like I'm missing something her.e
12:46:56 <ReinH> quchen: I wanted another presentation of the basics
12:47:13 <bjorkintosh> wXeno, it looks like a reprint of the second edition.
12:47:31 <wXeno> oh it is
12:47:32 <wXeno> sorry
12:47:36 <wXeno> I screwed up
12:47:37 <ReinH> quchen: I'm especially looking forward to the equational reasoning section
12:48:21 <wXeno> I think I even had the second edition, but somehow it ended up in the paper trash during a book shelf cleaning
12:48:21 <ReinH> frege: btw there are some video lectures for Hutton's Programming in Haskell http://www.cs.nott.ac.uk/~gmh/book.html#videos
12:48:42 <bjorkintosh> pity. it's a nice book, wXeno
12:48:47 <wXeno> yeah
12:48:47 <c_wraith> aaagh.  I need "pkg-config", which I assume is a gtk tool, but I have no clue what debian package includes it.
12:48:55 <frege> oh cool
12:49:02 <wXeno> bjorkintosh: problem is of course that I have a backlog of 800ish nice books :/
12:49:11 <geekosaur> not a gtk tool, a general developer toolchain tool
12:49:21 <ReinH> frege: the countdown problem is a nice example, although I prefer Bird's presentation in Pearls of Functional Algorithm Design slightly
12:49:24 <Hodapp> wXeno: here, take this book that will help instill in you good habits to help you read more!
12:49:28 <c_wraith> geekosaur: oh.  Do you have any guess what debian package it might be in?
12:49:45 <ReinH> frege: that sort of equational reasoning is a hallmark of Haskell programming and quite impressive imo
12:49:47 <geekosaur> should be pkg-config
12:49:52 <c_wraith> oh.  yeah.
12:49:54 <c_wraith> thanks
12:50:00 <geekosaur> also, should be included in build-essential
12:50:05 <ReinH> c_wraith: You know. For config. Of pkgs.
12:50:07 <wXeno> got a new book today even - that Coq book
12:50:22 <c_wraith> geekosaur: I didn't install build-essential.  I built this vm from the smallest set of packages I could
12:50:31 <ystael> wXeno: what Coq book?  Bertot/Casteran?
12:50:32 <ReinH> c_wraith: you might want build-essential for building things. Just a thought.
12:50:43 <ReinH> Seems... essential.
12:50:46 <c_wraith> pfft
12:50:49 <ReinH> hah
12:50:56 <geekosaur> ah. you are likely to find other missing things then; build-essential is really a minimal set fo things you are almost certain to need for compiling stuff
12:50:57 <wXeno> ystael: http://www.amazon.com/Certified-Programming-Dependent-Types-Introduction/dp/0262026651/
12:51:01 <frege> ReinH: you mean Hutton examples?
12:51:07 <c_wraith> geekosaur: it's likely. :)
12:51:08 <ystael> oh, chlipala's book.  i didn't know it had reached print.
12:51:16 <ReinH> frege: Hutton has a video on the countdown problem
12:51:33 <ReinH> frege: which uses a similar derivation to Bird's, but I prefer Bird's just slightly for pedagogical purposes
12:51:33 <geekosaur> you might, if nothing else, pull it up on packages.debian.org and see which subpackages you are likely to need
12:51:55 <ReinH> frege: it's also in the Programming in Haskell book
12:55:21 <c_wraith> holy crap.  cairo has a billion dependencies
12:58:19 <dmj`> this one? http://hackage.haskell.org/package/cairo
12:58:31 <c_wraith> I meant the native lib that compiles against, actually
12:58:35 <dmj`> o
12:59:57 <ReinH> I have doubts about the veracity of the Mark Twain testamonial for Hutton's book.
13:00:24 <c_wraith> Mark Twain invented time travel, didn't he?
13:00:40 <quchen> He even wrote a detailed Haskell implementation of it.
13:00:48 <wXeno> ystael: not your favourite Coq book, I take it?
13:00:55 <c_wraith> Which, unfortunately, the margin was too small to contain
13:01:00 <ReinH> My doubts remain unassuaged.
13:01:09 <fizbin> I'm sure he gave the testimonial after being handed a copy of the book when the Star Trek, TNG people took him into their century briefly.
13:01:26 <ReinH> fizbin: ah.
13:01:31 <ReinH> but how did we get it?
13:02:12 <ystael> wXeno: no such judgment is implied.  I audited the course where he was developing the first draft.  It was difficult and often frustrating.
13:02:28 <wXeno> ah
13:02:30 <fizbin> Well, I'm sure to prevent a paradox he would have been handed a preprint without his testimonial, then after reading the book he liked it so much he wrote a letter to be delivered as Hutton was writing it.
13:02:32 <ystael> I understand dependent types better now than I did then.
13:02:42 <fizbin> (ala the end of Back to the Future 2)
13:03:10 <wXeno> ystael: I have just a basic idea of dependent types... been reading TAPL, but only halfway through it :/
13:03:31 <ReinH> fizbin: hmmm http://en.memory-alpha.org/wiki/Time_travel_episodes
13:03:47 <triliyn> ReinH: that reminds me of the testimonials on the hackage page for Reactive Banana
13:03:48 <adelbertc_> edwardk - ping
13:05:06 <ystael> wXeno: One thing I think is a valid criticism of CPDT is that Chlipala is very focused on proof automation -- but if you put in too much automation before you know Coq well, you don't know what the automation is doing
13:05:13 <ystael> it's just magic and when the magic breaks you can't fix it
13:05:18 <ystael> but this is off topic for #haskell :)
13:05:37 <Cale> http://www.youtube.com/watch?v=mxI9ba6Rexc -- oh wow, new Catsters videos :)
13:07:30 <wXeno> ystael: does Coq have the same problem as Prolog? that is, you need to know how it works internally?
13:07:40 <intrados> Is there way to specify a ghc version dependency in a .cabal file?
13:07:43 <c_wraith> I think I got it.  Just had to install pkg-config and -dev packages for cairo, pango, and gtk
13:07:48 <ReinH> Cale: Today I learned about the Catsters! OMG!
13:07:58 <ystael> wXeno: let's take this to #coq
13:08:12 <Clint> intrados: why are you depending on a specific version of ghc?
13:08:24 <c_wraith> At least, gtk bindings are building now.  That's the toughest part of threadscope
13:08:38 <intrados> Clint: Because closed type families only became available in recent versions
13:09:05 <intrados> Clint: But as far as I can tell, still just fall under the TypeFamilies extension
13:09:11 <bjorkintosh> wXeno, knowing how it works internally doesn't sound like a problem :)
13:10:31 <wXeno> bjorkintosh: usually, that's not good (another term for it is "leaky abstraction"), like Prolog (where you have to know how to avoid non-terminating programs), and a.e. Hibernate, where you basically need to do as much on the inside as on the outside of the abstraction
13:11:18 <Cale> ReinH: It had been quite some time, I think at least a year since they last posted a video.
13:11:36 <ReinH> Cale: ah, but that's still 79 videos I have never seen!
13:13:21 <identity> Is there a compsci channel?
13:13:27 <identity> on freenode, that is
13:13:57 <wXeno> identity: if you find one, tell me... there's #proglangdesign
13:14:01 <wXeno> #ltu died :/
13:14:18 <identity> there seem to be a few
13:14:26 <identity> ##computerscience has 39 users in total
13:14:32 <identity> which is .. not a massive amount
13:14:38 <c_wraith> aaagh.  threadscope itself failed.  I think it was last built against older versions of gtk and cairo, because there's a name overlapping issue
13:14:41 <seeg> hello
13:14:58 <identity> no, make that 19
13:15:00 <identity> 19 users
13:15:12 <ciaranm> ha ha ha
13:15:17 <scriptor> an even smaller not-massive amount
13:15:20 <pavonia> identity: ##programming
13:15:42 <jle`> haskell's insistence on type syntax/notation mirroring data syntax/notation ... anyone have any opinions?  (Int, Int) vs Int * Int, Maybe Int vs Int Maybe, etc.
13:15:46 <seeg> I'm using HDBC.PostgreSQL, but when I do this: liftIO $ withTransaction db $ \d -> run d "INSERT INTO geo VALUES (?, ?)" [SqlDouble $ 3.0, SqlDouble $ 2.0] I get "Server error: SqlError {seState = "22P02", seNativeError = 7, seErrorMsg = "execute: PGRES_FATAL_ERROR: ERROR:  invalid input syntax for integer: \"3.0\"\n"}"
13:15:52 <identity> pavonia: general compsci questions are accepted there?
13:15:56 <seeg> anyone have any idea what's going on here?
13:16:09 <pavonia> identity: At least the topic says so
13:16:17 <identity> i see, thanks!
13:16:20 <joelteon> seeg: looks like that first value should be an integer but you're giving it a double
13:16:29 <seeg> but it's not an integer
13:16:33 <joelteon> right
13:16:34 <seeg> it is a double
13:16:38 <joelteon> it looks like it SHOULD be an integer
13:16:39 <seeg> i mean in the db
13:16:41 <joelteon> oh
13:16:45 <joelteon> well then I dunno
13:17:05 <seeg> postgresql query debugging gives this: 2014-01-08 22:09:01 CET ERROR:  invalid input syntax for integer: "3.0"
13:17:05 <seeg> 2014-01-08 22:09:01 CET STATEMENT:  INSERT INTO geo VALUES ($1, $2)
13:17:20 <seeg> so first an "integer" 3.0 is passed, then some $1 $2 params
13:18:00 <seeg> enetring this query in psql shell works fine (i mean with $1 replaced with actual values)
13:18:38 <seeg> ah, OK, might have a clue: there's an 'id' element which IS integer
13:18:44 <seeg> hmm, ok, this might be it
13:18:48 <seeg> thanks joelteon :)
13:19:41 <ReinH> seeg: as a side note, `SqlDouble $ 3.0' is just `SqlDouble 3.0'
13:20:32 <seeg> yeah, I had some other stuff there before :)
13:20:38 <ReinH> or fmap SqlDouble [3.0,2.0], or SqlDouble <$> [3.0,2.0]
13:20:52 <seeg> yeah :)
13:22:03 <c_wraith> I had to add hiding clauses to 3 files in threadscope to get it to build against the current cairo bindings.  But I got it to build!
13:22:17 <c_wraith> Where do I report threadscope issues?
13:22:31 <ReinH> c_wraith: /dev/null perhaps
13:22:51 <c_wraith> someone must sort of maintain it.
13:23:18 <c_wraith> oh, the hackage page points to a bug tracker
13:24:23 <c_wraith> looks like someone already reported it.
13:24:28 <c_wraith> guess like /dev/null is it!
13:26:00 <intrados> Would anyone be willing to look at my proof of concept for integrating quickchecked properties into the type system with phantom types? https://github.com/pseudonom/phantheck
13:26:15 <petesbloodyhand> could anyone give me a brief explanation regarding how to print tuples in haskell?
13:26:23 <c_wraith> intrados: sorry, I don't review code that falsely eats.
13:26:34 <c_wraith> intrados: though honestly, that sounds cool if it works. :)
13:26:43 <mauke> petesbloodyhand: print (1, 2)
13:26:57 <WraithM_> > print ("a", 7)
13:26:58 <lambdabot>  <IO ()>
13:26:58 <intrados> c_wraith: "falsely eats"?
13:27:00 <ParahSailin> @src (a,b) show
13:27:01 <lambdabot> Source not found. Maybe you made a typo?
13:27:06 <ParahSailin> @src (,) show
13:27:06 <lambdabot> Source not found. Just try something else.
13:27:15 <c_wraith> intrados: that github username
13:27:46 <intrados> c_wraith: Ah.
13:30:14 <petesbloodyhand> lemme rephrase that :p I have this function which returns me a tuple named Alumni (name, id, course, etc).
13:30:32 <zett_zelett> Alumnus?
13:30:33 <mauke> "alumni" :-(
13:30:54 <c_wraith> petesbloodyhand: how is the tuple named anything?
13:31:07 <petesbloodyhand> not named, sorry
13:31:19 <c_wraith> ok, just checking for low-level confusion
13:31:21 <petesbloodyhand> just an example
13:31:34 <mauke> .oO( an examples )
13:31:55 <maurer> petesbloodyhand: Well, if you mean "This is an ADT", then there is a different potential issue
13:32:03 <petesbloodyhand> it returns me a tuple, like (id,name,course)
13:32:04 <maurer> petesbloodyhand: What error do you get when you try to pass that value to print?
13:33:12 <petesbloodyhand>  Couldn't match type `(id,name,address,course)' with "[Char]'
13:33:30 <petesbloodyhand> Expected type: String
13:33:41 <petesbloodyhand> Actual type: Aluno
13:33:51 <mauke> what
13:33:53 <frxx> print does not expect a String
13:33:56 <frxx> :t print
13:33:56 <petesbloodyhand> (type created by myself. It's a tuple)
13:33:57 <lambdabot> Show a => a -> IO ()
13:34:05 <mauke> (id,name,address,course) is not a type
13:34:18 <Philonous> petesbloodyhand, Maybe you could put the code into a gist / pastebin?
13:34:21 <Philonous> @where hpaste
13:34:22 <lambdabot> http://lpaste.net/new/haskell
13:34:27 <mauke> and the error message too
13:34:35 <petesbloodyhand> yeah ill do that
13:34:35 <petesbloodyhand> sec :p
13:34:59 <hhhhhhhh> if i want to compile packages and then upload them to my vps, do the ghc versions need to match up for it to work
13:36:02 <petesbloodyhand> http://lpaste.net/5448437521333616640
13:36:33 <petesbloodyhand> I've done some confusion with print also... I think I meant putStr, not print
13:36:36 <mauke> that doesn't contain 'print'
13:36:48 <petesbloodyhand> it doesn't
13:36:52 <triliyn> :t putStr
13:36:53 <lambdabot> String -> IO ()
13:36:55 <triliyn> :t print
13:36:55 <lambdabot> Show a => a -> IO ()
13:36:57 <mauke> petesbloodyhand: why not?
13:37:04 <Philonous> petesbloodyhand, You need to convert the tuple to a string first. See "show"
13:37:09 <Philonous> @type show
13:37:10 <lambdabot> Show a => a -> String
13:37:29 <pavonia> hhhhhhhh: yes, they have to match perfectly, as far as I know
13:37:40 <Philonous> petesbloodyhand, For convenience, there is is print x = putStrLn  (show x)
13:37:58 <shlevy> :t (>>) . return
13:37:59 <lambdabot> Monad m => a -> m b -> m b
13:38:01 <hhhhhhhh> pavonia: and then can i basically just copy my ~/.ghc and ~/.cabal dirs
13:39:04 <pavonia> hhhhhhhh: Not sure this will work, I guess cabal is keeping some kind of list wich packages are installed which has to be updated too
13:39:11 <petesbloodyhand> can I use the show function with this kind of arguement?
13:39:14 <petesbloodyhand> show (getUsuarioNomeOrRG [(12,"13","k","l","m","n"),(13,"14","t","g","b","e")] scan1)
13:39:50 <shlevy> :t (>>) . putStrLn
13:39:51 <lambdabot>     Ambiguous occurrence `putStrLn'
13:39:52 <lambdabot>     It could refer to either `L.putStrLn',
13:39:52 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:143:1
13:39:59 <mauke> @undefine
13:39:59 <lambdabot> Undefined.
13:40:02 <shlevy> :t (>>) . putStrLn
13:40:02 <lambdabot> String -> IO b -> IO b
13:40:05 <hhhhhhhh> pavonia: bah
13:40:06 <shlevy> mauke: thanks :)
13:40:25 <petesbloodyhand> getUsuarioNomeOrRG returns a tuple afaik
13:40:33 <Philonous> petesbloodyhand, Yes, show is overloaded
13:42:47 <FrungyKing> Data.List.intersperse 'f' "Hello"
13:45:50 <Tehnix> with the recent open sourcing of Light Table, is there anyone considering working on a Haskell plugin (Haskell support)?
13:46:23 <skypers> ok big question: do you think itâs ok to write a Storable intance for newtype CFloats = CFLoats [CFloat] ?
13:47:05 <c_wraith> skypers: seems impossible to me
13:47:05 <skypers> so that when I do a poke p, I get a [CFloat]
13:47:09 <skypers> arf
13:47:21 <c_wraith> skypers: Storable instances must have fixed sizes
13:47:35 <skypers> yeah, sounds legit
13:47:36 <skypers> thank you
13:47:51 <skypers> Iâm going to look for something else then
13:48:01 <c_wraith> skypers: I've done some work that is related to this, and may do what you want.  lemme dig it up
13:48:02 <ReinH> Tehnix: I have at least heard someone ask that question before.
13:48:20 <skypers> c_wraith: nah, forget it
13:48:38 <skypers> the thing is now I know how to pass from a list of algebraic lists
13:48:40 <skypers> like
13:48:52 <skypers> [ integral [1..10], floating [2..5] ]
13:48:54 <skypers> into a Ptr ()
13:49:02 <skypers> Iâm designing a better interface to that
13:49:27 <c_wraith> skypers: http://hackage.haskell.org/package/storable-static-array is appropriate if your data sizes are known at compile time.
13:49:39 <skypers> integral and floating are functions I wrote and generate the same algeabraic type
13:49:47 <skypers> algebraic*
13:49:57 <skypers> c_wraith: mine are not
13:50:05 <c_wraith> ah.  Then it won't help.
13:50:39 <c_wraith> But that library has Storable instances for wrappers around arrays/vectors whose sizes are known at compile time.
13:50:40 <skypers> the type is something like data Foo = FloatingFoo [CFloat] | IntegralFoo [CInt] | UnsignedFoo [CUInt]
13:50:53 <c_wraith> Which is a handy thing to have
13:50:57 <skypers> I can transform a list of [Foo] into a Ptr ()
13:51:12 <skypers> well
13:51:14 <skypers> a Ptr Word8
13:51:16 <skypers> actually
13:51:41 <skypers> I just need to work on a better interface and it will make it through :)
13:53:27 <c_wraith> skypers: there are also peekArray and pokeArray in Foreign.Marshal.Array
13:53:30 <c_wraith> those might help
13:54:32 <skypers> c_wraith: yeah I already use them
13:54:44 <c_wraith> ok.  Then I have nothing to add. :)
13:55:33 <skypers> hm
13:55:47 <skypers> does castPtr actually perform some type casts?
13:55:53 <skypers> or just only on Ptr?
13:56:05 <c_wraith> it just changes the type of the Ptr.
13:56:09 <skypers> if I have a Ptr Float
13:56:28 <skypers> if I cast it to Ptr Word8, do I lose something?
13:56:49 <c_wraith> Nope.  At least not on x86 hardware, where all pointers are the same size.
13:57:01 <c_wraith> It might do something on hardware where some pointers are different sizes than others
13:57:01 <skypers> yeah
13:57:09 <skypers> does it even exist?
13:57:18 <c_wraith> all kinds of crazy hardware exists. :)
13:57:37 <hpc> i expect it would also not be guaranteed to do the same thing in other compilers
13:58:17 <bezirg> hi, what GHC extension do I need to allow infix symbols for data constructor names
13:58:33 <shachaf> None.
13:58:42 <shachaf> It is part of Haskell.
13:59:07 <geekosaur> but they have to start with :, I believe
13:59:36 <bezirg> geekosaur: u r right, that's the reason
13:59:41 <bezirg> geekosaur: ty
14:02:23 <ilmig_> can I somehow easily create a new type alias of an existing record type, where one of the elements of the record is constrained to a particular value?
14:02:55 <magneticduck> quick question -- say an IO value has the side effect of writing to stdout.. is there a simple way to channel stdout into another stream from inside haskell?
14:03:08 <magneticduck> (the stdout of the value)
14:03:12 <Cale> magneticduck: It would be cool, but no.
14:03:26 <Cale> Well...
14:03:29 <c_wraith> Isn't there something you can do with dup2?
14:03:44 <Cale> Yeah, there might be some unix-specific hackery you can do.
14:04:01 <magneticduck> cool
14:04:05 <magneticduck> what might that be
14:04:51 <petesbloodyhand> still, no luck with printing the results of this search
14:04:58 <petesbloodyhand> i've updated the code:
14:04:59 <petesbloodyhand> http://lpaste.net/5448437521333616640
14:05:02 <Cale> ilmig_: On the face of it, no. You can define a newtype wrapper with a smart constructor that sets the field appropriately.
14:05:04 <petesbloodyhand> errors included this time
14:05:24 <hpc> magneticduck: there's a module somewhere that lets you screw around with Fds directly, which is likely the most relevant place to look
14:05:32 <ilmig_> Cale: something like this was my first idea, but I find this rather cumbersome...
14:05:34 <hpc> stdout is 1, iirc
14:05:39 <Cale> petesbloodyhand: You're using show where it would make sense to use print
14:05:49 <petesbloodyhand> i see
14:05:50 <petesbloodyhand> sec
14:06:01 <ReinH> ilmig_: is the thing that creates the IO value something you have control over? I'd think providing a version that accepts a handle would be better
14:06:03 <Cale> (print = putStrLn . show)
14:06:12 <shlevy> When pattern matching on a record, can I ignore all but the field I want somehow?
14:06:22 <ReinH> than trying to much with fds and/or IO redirection
14:06:26 <ReinH> er
14:06:28 <ReinH> magneticduck: ^ for you
14:06:30 <ReinH> ilmig_: sorry
14:06:34 <petesbloodyhand> No instance for (Num String) arising from the literal `1'     Possible fix: add an instance declaration for (Num String)
14:06:54 <Cale> shlevy: If it's defined in record syntax, then yes!
14:06:57 <petesbloodyhand> i just replaced show for print
14:07:04 <shlevy> Cale: How?
14:07:08 <ilmig_> Cale: thank you anyway
14:07:16 <Cale> shlevy: f (MyRecord { fieldX = x }) = ... use x ...
14:07:17 <_shad_> shlevy: use guards instead
14:07:23 <hpc> petesbloodyhand: can you paste your code?
14:07:23 <shlevy> Cale: oh
14:07:24 <c_wraith> magneticduck: at a super-low-level approach, you open a new file descriptor, then do something like dup2(new_fd, 1).  That'll close the tty output stream though, unless you've dup'd it first.  I have no clue how to do any of this in haskell
14:07:29 <shlevy> Cale: now I feel dumb :D
14:07:30 <hpc> oh, you did
14:07:35 <magneticduck> ReinH: well yeah, in this case I can define whatever kind of handle I want to catch the input, but I was just wondering if this was possible
14:07:37 <petesbloodyhand> hpc: http://lpaste.net/5448437521333616640
14:07:51 <hpc> petesbloodyhand: opc is a String
14:07:58 <magneticduck> c_wraith: hmm
14:08:11 <hpc> you might want case opc of "1" -> ...; "2" -> ...; _ -> ...
14:08:27 <c_wraith> magneticduck: I think the necessary tools are available in some unixy package or another.
14:08:30 <petesbloodyhand> oh shi-
14:08:44 <petesbloodyhand> thank you so much hpc
14:08:49 <Cale> It's something that I've sometimes thought would be nice as well.
14:08:51 * petesbloodyhand slaps himself around a bit with a large trout
14:09:00 <ReinH> c_wraith: I would strongly suggest not pursuing down the road of low-level fd manipulating system calls...
14:09:02 <hpc> you can also go through readIO and deal with things that aren't numbers, but for something like that it's a bit overkill
14:09:11 <hpc> or reads
14:09:23 <c_wraith> ReinH: there's no other way to change what things that write to stdout write to.  *shrug*
14:09:51 <ReinH> c_wraith: That's true. Which is why I'm saying change it so it isn't a thing that writes to stdout at all.
14:09:52 <hpc> petesbloodyhand: ... you wouldn't happen to be on foonetic? that's the only other place i have ever seen "slapping someone with a trout" used...
14:10:08 <benmachine> hpc: I've seen it a lot, although mostly years ago
14:10:14 <Cale> hpc: It's also a default thing in mIRC
14:10:16 <ReinH> I would literally rather reimplement it and replace putStrLn with hPutStrLn or whatever
14:10:17 <triliyn> hpc: I think it's a monty python reference or something
14:10:18 <benmachine> I have a vague idea that some IRC clients have a built in.. yeah that
14:10:20 <hpc> oh, hmm
14:10:20 <ReinH> than suffer through that
14:10:27 <Cale> There's a /trout command iirc.
14:10:34 <hpc> heh
14:10:54 <hpc> clearly a demographic difference between networks then ;)
14:11:14 <Cale> I only used mIRC back in 1996 or so
14:11:41 <hpc> Cale: back before you knew better than to pay for a client to a plaintext protocol
14:11:50 <Cale> Oh, I never paid for it
14:12:09 <petesbloodyhand> yeah, it's a built in mirc command
14:12:10 <petesbloodyhand> :p
14:14:23 <jrm2k6> Hi guys, I have checked about the let syntax but I am not able to achieve this http://lpaste.net/926721382606176256
14:14:41 <jrm2k6> is this the way of doing it or am i totally wrong (beginner question)
14:14:54 <roboguy_> jrm2k6: what's wrong with it?
14:15:11 <roboguy_> I would guess that the "in" has to be indented the same or more as the rest of the let
14:15:15 <jrm2k6> I got a 'possible indentation' error
14:15:28 <geekosaur> yeh, that's incorrect indentation
14:15:41 <jrm2k6> hm
14:15:53 <pavonia> Don't mix tabs and spaces in Haskell!
14:15:56 <geekosaur> and I am seeing tabs for indentation which is a recipe for unhappiness
14:16:01 <jrm2k6> Ok.
14:16:01 <roboguy_> jrm2k6: also, all the innerPacks should line up
14:16:10 <boom583> I don't get this example from LYAH: http://pastie.org/private/wkehem7rfndgrjdwy9x1g
14:16:10 <boom583> Why can we put impure IO stuff in the if-else function? I thought all the Haskell stuff needed to be pure. if-else is just a Haskell function. So why can we put impure into it?
14:16:24 <roboguy_> jrm2k6: I would suggest you turn on the tabs-to-spaces option in your editor
14:17:04 <geekosaur> boom583, if-else does not care about what type you use aside from that it matches. IO () is just as good as String, as far as it is concerned
14:17:09 <roboguy_> boom583: IO a is just a type like any other. it's just not possible to bring the a outside of it
14:17:18 <dmj`> you need to indent the 2nd and 3rd definitions of innerpack to the same level as the 1st
14:17:21 <geekosaur> (but note that the predicate must be Bool, not IO Bool or etc.)
14:17:31 <fizbin> boom583: That doesn't put any impure stuff into the if-else.
14:17:50 <Hafydd> Apparently there's something called withStdOut in a GHC module IOExts, but I can't see a way to use that externally of GHC.
14:17:59 <fizbin> boom583: "line" is of type String, not of type (IO String)
14:18:22 <fizbin> And likewise, (null line) is of type Bool, not type (IO Bool)
14:18:25 <roboguy_> boom583: also, if-else is not a function
14:18:36 <roboguy_> (technically)
14:18:52 <_shad_> can anybody explain or suggest good tutorial about control flow in reactive-banana?
14:18:57 <Hafydd> It would be nice to have something like that, because it would allow great abstraction!
14:19:29 <danl-ndi> what is the right way to install a cabal package (OpenGL) of a later version than is available in cabal?
14:19:40 <jrm2k6> http://lpaste.net/926721382606176256 i simplify it, no tabs, still the same
14:19:53 <roboguy_> there is an ifThenElse function in some packages I think
14:21:00 <roboguy_> jrm2k6: you need something after the = on the third line
14:21:01 <boom583> how do haskell programmers introduce IO deep within some codebase that was previously pure? sounds like a lot of hassle to restructure everything
14:21:02 <boom583> maybe they want to output some result deep somewhere to a file
14:21:32 <roboguy_> boom583: it depends on exactly what you mean, I guess. it's pretty easy to read a file in the main function and give the data to a pure function
14:22:08 <roboguy_> well, main is probably better called an "IO action", but you know what I mean
14:22:10 <jrm2k6> roboguy_: what if i want some pattern matching code, as it complaisn about having two equals sign on the same line, if i move the line after the equals on the same liine
14:22:19 <ilmig_> hmm, with haskell every innocent question seems to lead into a rabbit hole about either lambda calculus or category theory...
14:22:23 <jrm2k6> meaning let innerPack l acc = innerPack _ acc = acc doesnt work
14:22:26 <ilmig_> a bit distracting, but in a good way ;)
14:22:30 <Cale> ilmig_: oh?
14:22:35 <jrm2k6> if i have several condition how can i do?
14:22:45 <Cale> ilmig_: Depends on how innocent the question is ;)
14:23:01 <roboguy_> jrm2k6: I'm not sure what you mean
14:23:05 <ReinH> Cale: I'm so happy I just found https://www.youtube.com/user/TheCatsters :)
14:23:08 <ReinH> Cale: thanks again
14:23:18 <Cale> ReinH: no problem :)
14:23:18 <fizbin> boom583: The answer is that they nearly never actually want to do that.
14:23:21 <ilmig_> Cale: I just started reading about church encoding, which seems to be related to my question about creating a new type of an existing type with an added constraint
14:23:26 <boom583> fizbin: ok
14:23:43 <Cale> boom583: The usual thing is to take that bit that you want to write, and produce it as part of the result of your pure function, or factor your computation into a part which computes that intermediate result and the rest.
14:23:45 <ReinH> Cale: yes yes please draw more commutativity diagrams nom nom
14:24:22 <ReinH> Cale: for some reason I just learn better this way
14:24:24 <boom583> Cale: you mean gather what you want to write and write it "later", instead of writing it "on the fly"?
14:24:24 <Cale> ilmig_: Church encoding is mostly about how to represent data constructors in an untyped lambda calculus
14:24:44 <silasm> boom583: typically if you want to e.g. embed printlns (putStrLns, rather) as opposed to just evaluating a function in ghci, it's because you're not decomposing the function as well as you should be.
14:24:55 <_shad_> jrm2k6: simple example      f x | x > 3 && x < 5 = 2
14:25:14 <Cale> boom583: sort of
14:25:20 <roboguy_> jrm2k6: also, those lines defining innerPack should be reversed for it to work right. l already pattern matches everything so the second line would never get used
14:25:25 <ReinH> boom583: for effectful computation there are monads, of course
14:25:36 <roboguy_> and you should do some kind of pattern match in the place where l is
14:25:37 <jrm2k6> roboguy_: yes sorry that is just for the example
14:25:38 <jrm2k6> http://lpaste.net/926721382606176256
14:25:39 <ReinH> boom583: (monads other than IO, even)
14:25:47 <jrm2k6> so theoritically this should work
14:25:48 <silasm> yeah, for everything else there's Writer.
14:25:49 <Cale> boom583: There's no sense of when things happen inside pure evaluation of expressions.
14:25:59 <Cale> boom583: So "after" is a bit funny to talk about.
14:26:03 <boom583> oh
14:26:09 <jrm2k6> but lets say i dont want to separate function, but a function containing another one through a let binding
14:26:23 <jrm2k6> roboguy_: is it clearer with my last example?
14:26:59 <jrm2k6> i dont want two separate function, but only one
14:27:07 <roboguy_> jrm2k6: yeah. you should be able to do it by directly putting it in the other function with a let before it and an in after it. everything just needs to line up
14:27:18 <Cale> boom583: Also, if you produce some string to be output, you might construct it lazily. It might even be infinitely long.
14:27:22 <jrm2k6> this is what i thought to
14:27:24 <roboguy_> jrm2k6: another possibility is using a "where" clause rather than let, which is what I would do
14:27:30 <jrm2k6> oh ok
14:27:35 <jrm2k6> checking that then
14:27:49 <jrm2k6> how is one better than the other? just a matter of style?
14:28:52 <roboguy_> jrm2k6: it really just depends on which one looks better for what you're doing. usually I put functions in where clauses because it generally looks less cluttered (to me, anyway)
14:28:54 <boom583> Can you guys imagine Haskell being used as the language for a GUI framework? It seems sort of like a pipe dream. In a GUI everything is flying around. Notifications, events getting sent all over the place. Everything seems impure. Not a realistic use case for Haskell is it?
14:29:07 <Twey> jrm2k6: The scoping rules are a little different; âwhereâ clauses can only attach to things that have branches, like top-level definitions or case analyses, and they span over all the branches
14:29:09 <Cale> boom583: Well, I shouldn't say *no* sense. It's just that GHC gets the ultimate final say in what order to evaluate expressions in. It'll be something close to the order that lazy (outermost-first) evaluation would evaluate them in, but might be stricter in some places.
14:29:18 <roboguy_> Twey, jrm2k6: ah, right that too
14:29:23 <Twey> boom583: FRP is a pretty nice answer to the GUI problem, I think
14:29:27 <Cale> boom583: You think Haskell doesn't have a good IO system?
14:29:32 <jrm2k6> roboguy_: Twey thanks ;)
14:29:39 <Twey> boom583: This is an interest of mine, actually âº
14:29:41 <fizbin> boogie: You're aware that there's a moderately popular Xwindows window manager written in Haskell, yes?
14:29:43 <boom583> I haven't looked into it clearly enough apparently...
14:29:45 <Cale> There's lovely concurrency primitives :)
14:29:46 <boom583> got more to learn
14:29:54 <jle`> boom583: actually Haskell is very well suited for GUI programming
14:29:58 <fizbin> Ooops, that was supposed to be to boom583
14:30:15 <Cale> (Unfortunately, we can't actually use concurrency with any external GUI library, because they all suck and are not threadsafe.)
14:30:25 <boogie> fizbin: :)
14:30:31 <ReinH> jle`: now we just need someone to write a good library for it
14:30:31 <Cale> (Because C programmers are bad.)
14:30:48 <Philonous> Cale, It's lonely at the top ;)
14:30:53 <jle`> boogie: GUI makes a *lot* more intuitive sense in the perspective of FRP than from an imperative perspective...and FRP isn't even the only good way to look at GUI's in haskell
14:30:59 <jle`> Haskell is very good at IO
14:31:01 <ReinH> boom583: there is nothing impure about evented systems per se
14:31:05 <jle`> in fact better at IO than most imperative languages :P
14:31:15 <jle`> better at reasoning for sure
14:31:16 <Cale> Well, it's more that the observer pattern is bad
14:31:24 <Cale> I guess
14:31:27 <Twey> jrm2k6: âletâ clauses let you attach a definition to any expression, which is nice, but you can't scope one over a branching construct (unless you embed it in a larger definition).  I prefer to use âwhereâ where possible, because it keeps the body of the function cleaner; I know many people share that preference, though not all.
14:31:31 <ReinH> jle`: especially with the new parallel IO manager, but even before.
14:31:34 <shlevy> Using acid-state, why do I need a safecopy instance for a type that is returned from a query but never stored in the db?
14:32:10 <boom583> Interesting
14:32:45 <jle`> gui's using events are actually pretty messy and very uncomposable
14:32:48 <jle`> ew
14:33:01 <ReinH> jle`: fsvo events
14:33:05 <Cale> shlevy: Well, I can tell you the shallow answer to that ;)
14:33:19 <Cale> Let me think about the deeper answer
14:33:24 <jle`> ReinH: yes :P
14:33:33 <jle`> but i am in a hand wavey mood.
14:33:50 <shlevy> Cale: Thanks :) Is the shallow answer something like "that's the way the types are written"?
14:33:50 <jle`> "events as approached by imperative gui frameworks"
14:33:56 <ReinH> Ok.
14:34:16 <Cale> shlevy: yes
14:34:23 <jle`> actually i think that Haskell is the only place where IO actually makes sense
14:34:34 <dmj`> shlevy: is that type being used for Updates as well?
14:34:35 <ReinH> shlevy: "Because if you don't you get a type error."
14:34:39 <jle`> (this is my third or so attempt this week at getting into HWN)
14:34:52 <Cale> shlevy: The definition of Method ev demands SafeCopy ev and SafeCopy (MethodResult ev)
14:34:53 <Tekmo> jle`: You might be interested in my MVC library
14:34:54 <ReinH> jle`: HWN?
14:35:03 <ReinH> Tekmo: hi!
14:35:09 <Tekmo> Hi!
14:35:09 <shlevy> dmj`: Oops, query was the wrong word :D
14:35:23 <shlevy> The type is literally
14:35:23 <boom583> Can you realistically write a native app on any OS these days with Haskell?
14:35:25 <boom583> WIndows or OS X
14:35:27 <shlevy> data CreateUserResult = Success | Exists
14:35:30 <Tekmo> jle`: It's basically a way to take concurrent applications and distil out the pure core
14:35:36 <boom583> GUI app
14:35:47 <boom583> i guess it's hard
14:35:50 <shlevy> I want to show a status code depending on how the Update goes
14:35:53 <Twey> jle`: Ehh.  :Ã¾   It's still basically an escape hatch: rather than try to prove interesting things about the impure code, we just wall it off where it can't do any harm to our proofs about the pure code.
14:35:55 <Cale> boom583: You can, and it's not hard.
14:36:07 <boom583> Microsoft and Apple have their own recommended ways of doing native apps on their platforms
14:36:09 <boom583> oh
14:36:10 <shlevy> But the value itself never has to be serialized
14:36:27 <Cale> boom583: Well, not any harder than writing GUI apps in pretty much anything else.
14:36:35 <Twey> jle`: Which admittedly is still about as good as it gets at the moment (I guess there's something to be said for splitting it into inductive/coinductive types) but I'm not sure I'd go so far as to call it an approach that âmakes senseâ
14:36:39 <Tekmo> boom583: It depends on whether or not you can get `gtk` to compile on your OS.  After that point you are golden
14:36:46 <roboguy_> what are the recommended GUI libraries now? I haven't done any GUI programming in haskell yet
14:36:55 <boom583> ok
14:37:00 <Cale> boom583: Well, I suppose it also depends on what you'll accept as native. GTK is rather nice to use as a cross-platform solution.
14:37:06 <Cale> Well, "nice"
14:37:11 <boom583> Cale: yeah true GTK could be used
14:37:15 <boom583> i think bitcoin uses GTK?
14:37:17 <boom583> no, or QT
14:37:26 <ReinH> Tekmo: I think I saw your thread on the MVC proposal. Is that a library now?
14:37:29 <boom583> anyway
14:37:29 <Twey> Is QtHaskell still maintained?
14:37:31 <Tekmo> ReinH: It is
14:37:33 <jle`> @faq "Can Haskell be used to effectively build native GUI apps?" boom583
14:37:33 <lambdabot> The answer is: Yes! Haskell can do that.
14:37:36 <ReinH> Tekmo: Nice!
14:37:42 <Tekmo> ReinH: Let me link you to the most current branch
14:37:46 <ReinH> Tekmo: <3
14:37:53 <Twey> I don't really hear much about it
14:37:54 <Tekmo> Gah
14:37:57 <ReinH> jle`: please note the difference in meaning between "Haskell can do that" and "Haskell does do that" ;)
14:37:59 <Cale> Theoretically, a much nicer GUI library could exist. Using GTK in Haskell is not that much nicer than using GTK in C (though there are some advantages, for instance, when you're defining event handlers)
14:38:00 <Tekmo> ReinH: Github is down at the moment
14:38:03 <ReinH> Tekmo: it is! :D
14:38:05 <c_wraith> magneticduck, Cale: this is actually really easy with GHC.IO.Handle.  \h m -> do { h2 <- hDuplicate stdout ; hDuplicateTo h stdout; x <- m ; hDuplicateTo h2 stdout ; return x }
14:38:09 <Tekmo> ReinH: I will link you once it is up
14:38:13 <ReinH> Tekmo: no worries
14:38:28 <Cale> c_wraith: Oh, interesting!
14:38:42 <c_wraith> magneticduck, Cale: just be aware it's very not-thread-safe
14:38:46 <ReinH> c_wraith: o_O
14:38:46 <Cale> c_wraith: How will that interact with concurrent IO actions?
14:38:48 <Cale> yeah
14:39:01 <ReinH> Mutex? What mutex.
14:39:32 <Cale> Is hDuplicate a thin wrapper for dup'ing the file descriptor?
14:39:41 <Cale> Or is it something more clever?
14:39:53 <shlevy> I'm always wary of syntax extensions... if ghc is suggesting I do -XDoAndIfThenElse is there a better way to clean up my code?
14:40:02 <c_wraith> Cale: It's a thin wrapper for FD-backed Handles.  It probably explodes on handles that aren't FD-backed
14:40:05 <shlevy> case pred of True False? :D
14:40:07 <Cale> shlevy: Lay out if/then/else correctly :)
14:40:12 <Cale> if foo
14:40:12 <Twey> shlevy: Indent the branches more
14:40:13 <shlevy> ah it's just layout?
14:40:13 <donri> shlevy: indent
14:40:14 <Cale>    then bar
14:40:15 <Cale>    else quux
14:40:16 <shlevy> aah
14:40:17 <shlevy> ok
14:40:20 <donri> shlevy: or haskell2010 :P
14:40:20 <shlevy> thanks
14:40:28 <donri> default-language: Haskell2010 in cabal
14:40:30 <geekosaur> it did, there was a mailing list discussion recently  which involved trying to hack it :)
14:40:33 <Cale> I really wish that DoAndIfThenElse would just die.
14:40:38 <donri> :)
14:40:40 <geekosaur> (explode on non-fd Handles, that is)
14:40:49 <donri> DieAndOfYouGo
14:40:58 <c_wraith> geekosaur: did those hacks lead to anything?
14:41:05 <Cale> In fact, I would make a counterproposal that would assert that the 'then' and 'else' must always start in a deeper column than their corresponding 'if'
14:41:12 <danl-ndi> hi, anyone able to answer a question about cabal/package installation?
14:41:18 <geekosaur> I would support that :)
14:41:25 <dmj`> shlevy: Why would a user fail to be created?
14:41:27 <geekosaur> c_wraith, I think they ended up with a different solution
14:41:40 <jle`> danl-ndi: don't ask about asking, just ask :)
14:41:51 <Twey> Speaking of: if I have a .cabal file that specifies some extensions, can I make GHCi turn them on when loading files or importing modules?
14:41:54 <shlevy> dmj`: If it already exists in the db
14:42:11 <danl-ndi> jle`: hmm. I tried... no response. I was kinda checking for a hellban :/
14:42:12 <donri> Twey: nope, need ./.ghci and :seti -X
14:42:19 <Cale> Also, tab characters in source files should be a lexical error, the same way that vertical tabs are handled.
14:42:46 <geekosaur> http://www.haskell.org/pipermail/haskell-cafe/2014-January/112030.html is what they ended up with when hDup games failed
14:42:47 <ystael> Cale: and the error message is "Die, monster! You don't belong in this world!"
14:42:51 <ReinH> Tekmo: was github.com/tekmo unavailable?
14:43:00 <Tekmo> Cale: Maybe a simpler solution would be to implement a Haskell equivalent of `gofmt`
14:43:01 <donri> Twey: although not sure if it loads default-extensions... but not other-extensions or any LANGUAGE pragmas
14:43:12 <danl-ndi> jle`: how can I install OpenGL-2.9.2.0?
14:43:13 <shlevy> I'm sad http://nickgravgaard.com/elastictabstops/ hasn't caught on
14:43:17 <dmj`> shlevy: Oh, just make a query for that. acid-state lets you use liftQuery inside of the Update monad for that kind of thing.
14:43:19 <ReinH> Tekmo: And are you indeed the 440th Gabrial to register on github?
14:43:26 <Tekmo> ReinH: No
14:43:33 <Tekmo> ReinH: Just my MVC repository is down
14:43:37 <ReinH> *Gabriel
14:43:43 <donri> ReinH: was github.com/Gabriel439/pipes unavailable? :P
14:43:43 <ReinH> Tekmo: was referring to your github username :)
14:43:46 <Cale> Tekmo: I just don't want the compiler to accept unacceptably trashy formatting in the first place, so that people will tend to do better.
14:43:52 <Tekmo> The 439 is a legacy of my GMail username
14:43:54 <ReinH> vs your irc and everything else username
14:44:02 <Tekmo> It was hard to get a lower number
14:44:06 <dmj`> addUser uid = do { exists <- liftQuery (exists uid); when (not exists) mkUser uid }
14:44:07 <dmj`> something like that
14:44:08 <ReinH> heh
14:44:16 <ReinH> Tekmo: well I'll just watch for it to come back up. https://github.com/Gabriel439/Haskell-MVC-Library I presume
14:44:18 <donri> Tekmo: i'm gonna start call you DrGabe
14:44:21 <Tekmo> ReinH: Right
14:44:27 <Tekmo> donri: :)
14:45:00 <shlevy> dmj`: Then how do I see outside of the addUser call if it succeeded?
14:45:26 <Twey> donri: I don't think that works for modules I :m in, though, does it?
14:45:47 <Twey> So I still need to put two dozen LANGUAGE pragmata at the top of each file :Ã¾
14:45:58 <jle`> are there any languages that are strict on &&?
14:46:06 <jle`> and ||
14:46:11 <jle`> all languages have non-strict aspects then huh
14:46:18 <donri> Twey: you can put them in default-extensions to have them implied for each file when compiling, it just won't affect cabal repl
14:46:27 <koala_man> jle`: visual basic
14:46:33 <ReinH> jle`: there are languages where && and || do not short-circuit
14:46:38 <jle`> aw
14:46:39 <ReinH> But they are silly languages.
14:46:45 <jle`> well they are at least non-strict of if-then-else
14:46:47 <jle`> i am sure
14:46:47 <Cale> jle`: I think they're all strict in the strict definitional sense ;)
14:47:06 <donri> Twey: (i don't think. arguably it should, for default-extensions.)
14:47:06 <ReinH> They are strictly strict
14:47:12 <ReinH> And non-strictly non-strict.
14:47:14 <tautologico> anyone working on a LightTable plugin for Haskell?
14:47:17 <nh2_web> can I use cabal flags to disable building a whole executable?
14:47:19 <Cale> A function f is called strict when f _|_ = _|_
14:47:28 <donri> nh2_web: buildable: False
14:47:36 <nh2_web> donri: much appreciated
14:47:39 <Twey> donri: But only if I compile via Cabal, not if I load the modules into a REPL, right?
14:47:46 <donri> nh2_web: might want to put the build-depends under the flag too
14:47:53 <donri> nh2_web: otherwise they're still considered
14:48:20 <donri> Twey: right, although it should work from cabal repl
14:48:36 <Twey> Hmm, I wonder if I can integrate cabal repl with haskell-mode
14:48:44 <donri> that is the modules should load with the right extensions, but it won't set it for the ghci session itself
14:48:46 <dmj`> handleAddUser uid = do { result <- query acid (Exists uid); if result ... then .. else .. }
14:48:48 <Cale> Oh, I suppose perhaps it's not in Haskell, since (&&) undefined isn't quite undefined (it's const undefined)
14:48:50 <dmj`> shlevy: ^
14:49:13 <Cale> Though that's a bit accidental, I think :)
14:49:29 <bearclaw_> I think I finally got laziness and foldr, http://lpaste.net/98207 , returning accum means "try next", not using accum stops
14:49:53 <triliyn> Cale: if you consider analogous concept that applies to expressions, rather than functions, I think most languages are pseudo-nonstrict
14:49:59 <shlevy> dmj`: Ah fair enough
14:50:01 <triliyn> In && and ||
14:50:06 <Cale> bearclaw_: Yeah, don't think of it as an accumulator, think of it as the foldr over the rest of the list.
14:50:10 <donri> Twey: i think i heard haskell-mode supporting cabal repl
14:50:15 <dmj`> shlevy: is this a web app?
14:50:18 <shlevy> dmj`: Still think it's strange that my approach doesn't work
14:50:28 <jle`> triliyn: as stated just before, there are languages that are strict on && and ||
14:50:42 <triliyn> jle`: right, but not all of them
14:50:42 <Cale> triliyn: Yeah, I was just pointing out the obvious fact that they'll always evaluate the left parameter. ;)
14:51:01 <shlevy> dmj`: Nope, cli tool for managing service authorization
14:51:07 <shlevy> dmj`: Mostly just a toy
14:51:14 <shlevy> dmj`: that could eventually be something more :)
14:51:19 <ReinH> triliyn: Let's use the term 'short-circuiting' to describe this "pseudo-nonstrictness"
14:51:24 <jle`> all languages with meaningful if/then/else must be non-strict on if/then/else then
14:51:26 <jle`> right?
14:51:27 <ReinH> so we don't have to make those words sad
14:51:32 <jle`> i guess they don't count as functions
14:51:34 <benmachine> I suppose flip (&&) is non-strict
14:51:42 <ReinH> It's pretty common that && and || are short-circuiting
14:51:51 <ReinH> i.e. True && x does not evaluate x
14:51:57 <ReinH> er True || x
14:51:58 <ReinH> sorry
14:52:01 <roboguy_> jle`: well, we started by talking about && and || which are often not functions also
14:52:03 <triliyn> ReinH: indeed, we have now recovered the standard word used to refer to this concept!
14:52:15 <ReinH> triliyn: WEll yes, that's why I'm using it :D
14:52:16 <jle`> in languages with short circuiting &&/||, they are often used as control flow
14:52:18 <Cale> (&&) False isn't strict.
14:52:24 <ReinH> triliyn: Got tired of the "it's strict!" "no it isn't" thing
14:52:26 <Cale> > (&&) False undefined
14:52:27 <jle`> so the languages actually rely on their short-circuiting
14:52:27 <lambdabot>  False
14:52:35 <Cale> > (&&) True undefined
14:52:36 <lambdabot>  *Exception: Prelude.undefined
14:52:39 <Cale> ^^ strict
14:52:56 <ReinH> Cale: but we're also referring to langauges where strict/nonstrict isn't well defined
14:52:59 <ReinH> i.e. other languages
14:53:15 <jle`> isn't if/then/else a first-class function in lispy languages?
14:53:18 <benmachine> yeah it becomes a whole lot more complicated when you have side effects
14:53:23 <Twey> donri: Hm, yes, I'm trying to figure out how this works
14:53:30 <ReinH> jle`: isn't everything a first class function in lispy languages? :p
14:53:33 <triliyn> I think in most other languages you also need to adjust the notion of strictness to account for multi-parameter functions
14:53:36 <jle`> :p
14:53:43 <jle`> do strict lispy languages have problems with if/then/else?
14:53:48 <nh2_web> donri: you are guessing my problems very well here :D
14:53:53 <ReinH> triliyn: I just try to avoid talking about "strictness" of other languages in #haskell
14:53:58 <triliyn> ReinH, jle`: in Common Lisp, if is a macro (or sometimes a special form)
14:54:04 <triliyn> (It's implementation dependent I think)
14:54:06 <ReinH> Since invariably the Haskell definition will be applied and almost invariably it shouldn't be
14:54:15 <jle`> triliyn: ah
14:54:23 <triliyn> It could probably be a function in Scheme but I haven't used scheme
14:55:09 <monochrom> if/then/else cannot be a function in lisp, only a macro or special form or something like that. because of execution order.
14:55:23 <monochrom> but first-class, yes
14:56:06 <Cale> jle`: No, if is syntax
14:56:11 <Cale> (in lispy languages)
14:56:34 <Cale> It *looks* like it's first class, because those languages like to trick you. :)
14:56:50 <Cale> But really lisps have a lot more syntax than they might appear to have at first :)
14:57:02 <henk> How/why does a list comprehension like '[thingie | Green thingie <- stuff]' work? AFAIU it returns a list of all 'Green thingies' in my 'stuff', i.e. no Blue or Yellow thingies, is that correct?
14:57:13 <Cale> That's correct
14:57:24 <hpc> henk: the list comprehension desugars to do-notation
14:57:27 <monochrom> I guess there is the chicken-egg problem of "if if-then-else is defined in terms of something else, what is that something else?" in lisp
14:57:41 <hpc> the pattern match of (Green thingie <- stuff) desugars in do-notation to
14:58:13 <Cale> http://www.haskell.org/onlinereport/exps.html#list-comprehensions gives the translation for list comprehensions
14:58:17 <hpc> stuff >>= \thingie -> case thingie of (Green thingie) -> the rest of the do-block; _ -> fail "pattern match failure on ..."
14:58:26 <hpc> henk: for lists, fail _ = []
14:58:28 <monochrom> you need lisp to give you one built-in conditional primitive, before you can handwrite other conditionals
14:58:34 <Jesin> :t fail
14:58:35 <lambdabot> Monad m => String -> m a
14:58:43 <hpc> henk: and combined with the semantics of (>>=), you get what you are seeing
14:58:57 <monochrom> for Haskell you start with the built-in case-of primitive
14:59:04 <Jesin> > fail "placeholder" :: [Integer]
14:59:04 <Cale> [ e | p <- l, Q ] = let { ok p = [e | Q]; ok _ = [] } in concatMap ok l
14:59:05 <lambdabot>  []
14:59:46 <Twey> jle`: You can write if as a function in strict Lisps, but you'd have to wrap all the branches in lambdas because strictnessâ¦ they usually choose to use a macro instead
14:59:52 <Cale> So in this case, it's just [thingie | Green thingie <- stuff] = let { ok (Green thingie) = [thingie]; ok _ = [] } in concatMap ok stuff
15:00:37 <lispy> I feel so popular today. Getting all the mentions :)
15:00:48 <danl-ndi> cabal is not a package manager
15:01:43 <Cale> danl-ndi: That's pretty true. It's mainly a build system.
15:01:55 <henk> Cale, hpc: Thank you very much
15:01:56 <hpc> it does happen to tell a package manager what to do during normal operation
15:02:03 <hpc> ghc-pkg
15:02:16 <benmachine> cabal-install is an installation tool, it's not so crazy that it might one day become a package manager
15:02:20 <shlevy> If I have a newtype around Text and I want a Show instance that just shows the text, not the newtype bits, should I implement showsPrec or show?
15:02:22 <dmj`> shlevy: your approach would work, but you're inside the update monad, all events inside there must be serialized.
15:02:45 <Cale> I really wish that cabal-install had some rudimentary support for uninstalling things cleanly.
15:02:45 <benmachine> shlevy: it doesn't matter too much
15:02:51 <Tekmo> shlevy: If you don't care about performance, `show` is easier
15:03:04 <mornfall> Cale: cabal unregister
15:03:12 <danl-ndi> cabal is not cabal-install    :/
15:03:15 <dmj`> shlevy: my comment was in response to what you wrote earlier
15:03:20 <Cale> mornfall: You mean ghc-pkg unregister
15:03:21 <benmachine> even if you do, sometimes the default showsPrec is pretty much as good as what you'd define
15:03:40 <mornfall> Cale: apparently, I do... meh :-)
15:03:42 <Cale> mornfall: But that doesn't remove the files, it just removes the entry from the package database
15:03:43 <shlevy> dmj`: Ah right, acid-state serializes the log
15:03:48 <shlevy> ok
15:03:50 <mornfall> Cale: yes, clearly
15:04:00 <Cale> mornfall: So eventually you end up with lots of junk that you have to clean up by hand
15:04:06 <hpc> or you might be like me and barely able to write a good showsPrec anyway
15:04:10 <Cale> It's not *too* hard to do
15:04:15 <monochrom> I think that "cabal is not a package manager" is pretty irrelevant. cabal is exactly what its authors makes it, no more no less. and the authors have, clearly, made it a can't-make-up-mind bastard of partial package manager, partial build manager, partial dependency chaser, and partial downloader.
15:04:15 <Twey> donri: Cool, cabal repl loads default-extensions always
15:04:20 <Cale> But it would be nice if it were taken care of automatically.
15:04:32 <Cale> monochrom: :D
15:04:38 <Twey> monochrom: Heheh.
15:04:44 <mornfall> Cale: I guess. In an ideal world, you'd never need to install things through cabal directly, though.
15:04:56 <danl-ndi> monochrom: what's a newbie to do?
15:05:10 <benmachine> use cabal-install, it's actually pretty nice
15:05:13 <monochrom> the command names "cabal update", "cabal install", "cabal upgrade" (now deprecated) clearly refer to apt-get
15:05:39 <benmachine> it's been getting a lot better recently, as well
15:05:52 * shlevy should probably not mention nix-env as a haskell package manager
15:05:52 <monochrom> and the command names "Setup configure", "Setup build", "Setup install" (which is not equal to "cabal install") clearly refer to autoconf and make
15:05:52 <Dasuraga> I was wondering, what's the fastest way to print out to standard output
15:06:12 <Dasuraga> It seems to me that building up strings to be printed can be time consuming , especially for big strings
15:06:22 <Cale> danl-ndi: For the most part, don't worry too much. You might find it nice to use the new sandbox feature for larger projects where you're going to need bigger sets of dependencies (especially any of the web frameworks)
15:06:28 <Twey> Dasuraga: Use Text :Ã¾
15:06:37 <mornfall> shlevy: yeah, haskell in nixpkgs is kinda broken by design :P
15:06:44 <Cale> danl-ndi: monochrom has some really nice guides about how not to do things which will result in broken packages
15:06:50 <shlevy> mornfall: ghcWithPackages works well for me
15:07:12 <Cale> http://www.vex.net/~trebla/haskell/sicp.xhtml
15:07:15 <mornfall> shlevy: that's better yes, but still far from optimal
15:07:17 <danl-ndi> Cale: I'm trying to install a cool project off github. getting supporting packages up is a bit of a jungle.
15:07:24 <monochrom> that's http://www.vex.net/~trebla/haskell/sicp.xhtml . see also http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml
15:07:27 <Gx10> Hello
15:07:28 <ReinH> Cale: Not what I thought SICP meant.
15:07:32 <shlevy> mornfall: What would optimal be?
15:07:35 <monochrom> cabal tries to be everybody and ends up being nobody
15:07:35 <Cale> ReinH: :)
15:07:37 <danl-ndi> jungle of apt-get, cabal install, and git clone etc...
15:07:41 <ReinH> Although I suppose that was intentional.
15:07:53 <mornfall> shlevy: not having to do manual dependency chasing
15:08:04 <shlevy> mornfall: Ah you mean for cabal2nix?
15:08:14 <Cale> danl-ndi: For the most part, I avoid using my system package manager for anything related to Haskell. I do use it to grab underlying C libraries when required though.
15:08:15 <mornfall> shlevy: Well, how else do you install stuff from hackage? :)
15:08:28 <shlevy> mornfall: So far most of what I've needed was already there :D
15:08:30 <mornfall> shlevy: It still takes considerable luck to have what you need already in nixpkgs.
15:08:35 <shlevy> I see
15:08:58 <Cale> Maybe my fears are somewhat irrational at this point, but I still don't really trust the linux distributions to get anything right with respect to Haskell packages.
15:09:04 <danl-ndi> Cale: yeah that has been what's necessary
15:09:20 <Tekmo> Debian is pretty good about Haskell package management
15:09:30 <monochrom> I think linux distros now get it right but also too slow
15:09:35 <ReinH> Cale: For quite a while debian-based distributions of Ruby packages were purposefully broken in rather annoying ways
15:09:35 <Twey> I call cabal via my system package manager, so I have a single package database
15:09:36 <mornfall> Cale: I wouldn't as much blame the distro side of the equation here. :-P
15:09:39 <ReinH> Cale: so I feel your pain
15:09:42 <bitemyapp> Tekmo: really? How'd they fuck up Ruby so badly then?
15:09:42 <monochrom> s/slow/lagging behind/
15:09:45 <Cale> Tekmo: Kind of, except that when you install GHC, you don't get everything that you get when you install a binary GHC.
15:09:49 <mornfall> Cale: Cabal does have an outlandish dependency model.
15:09:51 <ReinH> bitemyapp: heh
15:09:52 <Tekmo> bitemyapp: I don't know.  I don't use Ruby
15:09:56 <Gx10> Would you say that this is a good resource to learn Haskell in further details after grasping some basic knowledge? (http://www.haskell.org/ghc/docs/latest/html/users_guide/index.html)
15:09:57 <bitemyapp> ReinH: oh herro.
15:09:57 <shlevy> mornfall: Hmm we could use __noChroot + import from derivation to generate cabal2nix expressions on-the-fly
15:10:01 <Cale> Because they split it up into teeny tiny pieces that you have to be careful about.
15:10:02 <ReinH> bitemyapp: herro!
15:10:08 <shlevy> mornfall: And that could automatically chase dependencies for you
15:10:11 <bitemyapp> Tekmo: neither do I (anymore) but Ruby Drama echoes across the galaxy.
15:10:13 <dmj`> has anyone tried to make a different haskell pkg mgr, besides cabal?
15:10:22 <Twey> Gx10: Dear gods, no
15:10:22 <Tekmo> Cale: What do you mean?
15:10:23 <bitemyapp> dmj`: there's no need, cabal is fine.
15:10:26 <Tekmo> bitemyapp: :)
15:10:31 <shlevy> mornfall: Alternatively we could write a small wrapper around nix-build so we could avoid the __noChroot hack
15:10:35 <bitemyapp> dmj`: the only real original problem was sandboxing-by-default.
15:10:38 <Twey> Gx10: That's like trying to learn C++ by reading the g++ manual :Ã¾
15:10:47 <ReinH> Gx10: you can learn all about GHC version numbering!
15:10:49 <mornfall> shlevy: that'll break 95 % of the time because cabal2nix doesn't know when it needs jailBreak (and for that matter, neither do I)
15:10:58 <monochrom> like, after a version of Haskell Platform comes out, it takes a linux distro another year to catch up. and Haskell Platform itself is already pretty conservative. the extra lagging is really unacceptable.
15:11:13 <Cale> Tekmo: I mean, you couldn't just install ghc and have it be like installing the generic linux binary package of GHC from the GHC website. You also had to install a bunch of libghc-* packages.
15:11:14 <bitemyapp> dmj`: the deeper issues are endemic to any dependency mgmt system (like diamond dependencies) and without some kind of highly sophisticated sandboxed classloader-esque system (which would require a new compiler) I don't think there's anything you can do.
15:11:26 <shlevy> mornfall: Well OK we could go the npm2nix route and actually respect dependency specifications :D
15:11:28 <Tekmo> Cale: I use Debian stable's Haskell Platform and I haven't had any problems
15:11:47 <bitemyapp> dmj`: having split namespaces across versions could be really fucking confusing, I'm not sure it's superior to having unified module semantics and just fixing your goddamm build.
15:11:51 <Cale> tbh, I don't have much experience with this in the last couple years or so
15:11:53 <shlevy> mornfall: If we're doing it dynamically that way makes more sense as there's no worry about lots of duplication of expressions
15:11:58 <nh2_web> donri: can I also set a flag's default like `default: !os(windows)`?
15:12:05 <benmachine> I think the main problem with cabal is that it mostly manages software that is packaged by people who like shiny things and don't prioritise stability
15:12:15 <Tekmo> Cale: I specifically develop using Debian stable because I view it as the lowest common denominator to target
15:12:21 <benmachine> I like shiny things, I don't prioritise stability, but this causes hard work for poor cabal
15:12:23 <mornfall> shlevy: MarcWeber already did that a while back, but it was voted out of nixpkgs.
15:12:36 <Cale> Because installing the generic linux binary of GHC is easy and does the right thing.
15:12:54 <shlevy> mornfall: MarcWeber's stuff often has good ideas in frankly weird implementations
15:13:09 <monochrom> oh and yeah, linux distros shred one single GHC into a million shards because of "policies"
15:13:12 <shlevy> mornfall: Didn't his thing try to implement a complete SAT solver?
15:13:19 <Tekmo> The only thing I miss is not having cabal sandbox, yet, but I can wait for it
15:13:22 <Cale> monochrom: Yeah, that's what I was just complaining about
15:13:28 <benmachine> to be fair GHC is pretty monolithic as-is
15:13:53 <Cale> benmachine: I don't think they should split it though. If it's monolithic, it's monolithic. It's none of their business :)
15:14:22 <Gx10> Twey: hmm.. I want to learn about profiling and some practical GHC options, there is a whole profiling chapter there, what other resource would you suggest?
15:14:25 <shlevy> Cale: Well... As a package maintainer I disagree about "none of their business"
15:14:30 <monochrom> so we good people in #haskell get newbie questions like "I'm confused, I don't have profiling libs", "I'm confused, I don't have System.Process"
15:14:35 <Tekmo> Gx10: A good start is the RWH chapter on profiling
15:14:46 <shlevy> Cale: Allowing users to only get the stuff they actually need is important
15:14:47 <Cale> It's annoying because you get beginners in here who installed the ghc package through their package manager, and things like the cabal-install bootstrap.sh won't work because even less stuff is installed than you'd get with a plain install of GHC.
15:15:01 <shlevy> Cale: That being said the default should be sane, not minimal
15:15:04 <frerich> Hi, is anybody here familiar with how the GHC preprocessor feature works - does it call something like cpp (i.e. the C preprocessor shipped with e.g. XCode on this MacBook)? I noticed that when running 'cabal build threepenny-gui' I get errors such as http://lpaste.net/98209 - somehow the preprocessor chokes and I don't know how to debug this.
15:15:34 <Tekmo> Cale: It seems like that would be solved by requesting a meta package that installs all those things
15:15:40 <frerich> Alas it seems I can't just disable the preprocessing entirely because other parts of the code rely on it.
15:15:40 <Tekmo> Cale: You should run it by Joachim
15:15:49 <schell> frerich: are you using Xcode 5?
15:15:50 <Gx10> Tekmo: I am aware of its existance but it seemed a little bit short for me. will read it anyway thanks.
15:15:58 <monochrom> on the bright side, the answer "if you don't have profiling libs or System.Process, your GHC installation is corrupted" is technically correct, regardless of cause :)
15:16:00 <Tekmo> Gx10: The nest best source is the GHC manual itself
15:16:07 <Tekmo> Gx10: Let me find the relevant chapter
15:16:18 <Cale> Tekmo: yeah, the ghc package should perhaps be a metapackage which depends on some ghc-small package or something, if they really want to do that
15:16:25 <Tekmo> Gx10: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/profiling.html
15:16:41 <monochrom> i.e., if the linux distro splits it, it still counts as corrupted
15:16:53 <Cale> I don't really understand why you'd want to install GHC without all the stuff which comes in the generic linux binary distribution.
15:16:58 <frerich> schell: Let me check... no, version 3.2.6
15:17:10 <Cale> But if they really want to make that possible, it definitely shouldn't be the default :P
15:17:12 <Tekmo> Cale: In the case of Debian, it's probably to minimize disk space or bandwidth
15:17:15 <schell> hmmm, then it's not the same problem i've had
15:17:17 <Tekmo> Cale: Debian people are anal about htat sort of thing
15:17:22 <mornfall> Cale: because there are people that want to build haskell software not develop it out there?
15:17:22 <Gx10> Tekmo: thanks.
15:17:41 <Tekmo> Cale: The ideal Debian developer lives in a cabin in the mountains and only has internet for 5 minutes a day and develops on a machine with 500 MB disk space
15:17:42 <frerich> schell: but indeed, I seem to recall Google gave some hits about XCode 5 (that's what made me wonder whether my XCode setup is related to this)
15:17:53 <Cale> Tekmo: lol
15:18:14 <monochrom> the ratio "build haskell programs but not write haskell programs" : "write haskell programs" is diminishing
15:18:33 <schell> frerich: AFAIK GHC uses gcc/clang for cpp stuff and on mac gcc/clang is provided by Xcode, mostly
15:18:48 <frerich> schell: Hm, I see, thanks!
15:19:07 <Cale> monochrom: I wonder how many people are in that first camp who are not Xmonad users.
15:19:47 <schell> frerich: but you may find that your problem can be solved by installing a newer gcc with brew and then pointing ghc to it in the ghc settings file
15:19:50 <Cale> (and even those guys wouldn't be well-served by splitting up GHC, because it makes Xmonad harder to set up)
15:19:51 <geekosaur> (or xmobar; it does have a small following in the awesome camp)
15:20:21 <geekosaur> (but even then they only build it once)
15:20:47 <joneshf-laptop> is >>= distributive over <>?
15:20:54 <ReinH> frerich: the current haskell platform docs include steps for installing with Xcode 5. IIRC they include a shell script to configure ghc.
15:20:56 <monochrom> probably not
15:21:00 <frerich> schell: Some more Googling with XCode in the query suggests that this may actually be related to differences in the clang and gcc preprocessors (and I'm on OS X 10.9, i.e. I have clang by default AFAIK)
15:21:00 <ReinH> Actually I think it might install a small wrapper script.
15:21:02 <Tekmo> joneshf-laptop: You mean over `mplus`?
15:21:05 <joneshf-laptop> like, is that an already known thing, or would ithave to be proved?
15:21:14 <Cale> joneshf-laptop: Which monoid are you referring to?
15:21:16 <joneshf-laptop> Tekmo, sure that'd work also
15:21:22 <schell> frerich: yes, then it is the same problem i've run into
15:21:38 <joneshf-laptop> Cale, would it matter?
15:21:43 <Cale> joneshf-laptop: Yes
15:21:43 <Tekmo> joneshf-laptop: I think it usually is.  I'm not aware of a case where it's not
15:21:45 <schell> frerich: you may want to check out the note below the download here -> http://is.gd/H4sEub
15:21:54 <joneshf-laptop> Cale, hmm
15:22:01 <Cale> joneshf-laptop: >>= and <> aren't even related to each other
15:22:07 <Cale> :t (>>=)
15:22:08 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:22:10 <Cale> :t (<>)
15:22:11 <lambdabot> Monoid m => m -> m -> m
15:22:17 <Tekmo> Cale: I think he meant `mplus`
15:22:28 <Cale> :t mplus
15:22:28 <lambdabot> MonadPlus m => m a -> m a -> m a
15:22:49 <Tekmo> He's probably using the list monad
15:23:02 <shlevy> If I have foo a = bar a . qux, how can I point-free it?
15:23:35 <joneshf-laptop> Tekmo, well, i did actually mean <>, but mplus would work for what i'm trying to prove
15:23:37 <joneshf-laptop> Tekmo, i think
15:23:42 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal -- see here for a discussion of the various sorts of MonadPlus instances that are around.
15:23:51 <Tekmo> shlevy: (. qux) . bar
15:23:58 <shlevy> Tekmo: thanks
15:23:58 <Cale> joneshf-laptop: If you're talking specifically about lists, then yes, there's a sort of distributivity
15:24:03 <Tekmo> shlevy: You're welcome
15:24:18 <joneshf-laptop> Cale, but in general no?
15:24:24 <Cale> In particular, that (xs ++ ys) >>= f = (xs >>= f) ++ (ys >>= f)
15:24:24 <frerich> schell: Bingo, that helped! Thanks! :-)
15:24:32 <Cale> joneshf-laptop: In general, it's a type error.
15:24:34 <schell> frerich: gladly :)
15:24:47 <joneshf-laptop> well let's say this then
15:24:52 <shlevy> Tekmo: Any advice for how to figure that out? I have a sort of gut-feel kind of approach currently
15:25:05 <Cale> joneshf-laptop: and even if there happens to be a monoid instance, there's no guarantee
15:25:06 <joneshf-laptop> if something is an instance of Monoid, would >>= distribute over <>?
15:25:09 <joneshf-laptop> Cale, ^
15:25:10 <Tekmo> shlevy: First, you try to rearrange it so that the value you are tryng to eliminate is positioned at the end
15:25:14 <Cale> joneshf-laptop: no
15:25:19 <Tekmo> shlevy: For example, the first step I did was to rewrite it like this:
15:25:19 <Cale> not in general
15:25:19 <joneshf-laptop> Cale, heh :)
15:25:40 <Tekmo> shlevy: (. qux) (bar x)
15:25:52 <Tekmo> shlevy: Oops, that should be `a` instead of `x`
15:26:05 <Tekmo> shennyg: So all I did was use the section notation to place the `x` at the end of the line
15:26:17 <shlevy> Ah ok
15:26:21 <Tekmo> shlevy: Then the last step was just to use function composition to make that point-free
15:26:27 <shlevy> Thanks!
15:26:33 <Tekmo> shlevy: You're welcome!
15:28:03 <Tekmo> ReinH: It's up now: https://github.com/Gabriel439/Haskell-MVC-Library
15:28:18 <Tekmo> ReinH: Note that it uses a slightly newer version of `pipes-concurrency` that's not on Hackage yet
15:28:20 <ReinH> woo!
15:28:33 <Tekmo> ReinH: It just modifies `send` to be an `IO` action instead of an `STM` action, but that's the only differnece
15:29:09 <Tekmo> ReinH: If you want to see a concrete example of a library built on top of it, see my `rcpl` library
15:29:09 <ReinH> thanks!
15:29:09 <Tekmo> ReinH: https://github.com/Gabriel439/Haskell-RCPL-Library
15:29:09 <Tekmo> You're welcome!
15:29:14 <joneshf-laptop> Cale, so what is like Tekmo suggests, it's a MonadPlus?
15:29:33 <ReinH> Tekmo: when I saw the thread I thought about using it for a (suuuuper simple) game engine
15:29:52 <Tekmo> joneshf-laptop: To a first approximation, you can think of `MonadPlus` as the same thing as the `Monoid` class, except it takes a "higher-kinded" type parameter as an argument
15:30:05 <Tekmo> ReinH: It's designed for games and GUIs.  Those are the motivating use cases
15:30:22 <Tekmo> ReinH: It arose when jfischoff asked me how to design GUI logic that could be QuickChecked
15:30:36 <jle`> joneshf-laptop: http://www.haskell.org/haskellwiki/MonadPlus
15:30:40 <ReinH> Tekmo: awesome :)
15:30:45 <Tekmo> ReinH: He wanted to build a native Haskell GUI and this is one of the pieces of that bigger effort
15:30:47 <ReinH> Tekmo: look forward to messing with it
15:30:51 <ReinH> awesome!
15:30:53 <Tekmo> ReinH: Great! )
15:31:02 <joneshf-laptop> erm, i think i typoed that sentence out of a meaning
15:31:03 <ReinH> Tekmo: please to be blogging as well
15:31:06 <Tekmo> ReinH: I will
15:31:12 <ReinH> excellent!
15:31:12 <jle`> joneshf-laptop: mplus is supposed to be left-distributive, but there is some controversy around it
15:31:14 <Tekmo> ReinH: I'm just polishing up the `rcpl` first before I release and blog about it
15:31:17 <joneshf-laptop> s/what is/what if it's/
15:31:23 <ReinH> cool
15:31:28 <Tekmo> ReinH: I want people to have a specific library to consult as an example for best practices
15:31:41 <dEPy> what are arrows good for? I need some practical example.
15:32:03 <Tekmo> They are great for building "graphs of things" for a very general notion of graph
15:32:07 <joneshf-laptop> jle`, great link!
15:32:22 <jle`> joneshf-laptop: remember that there is a difference between monoids and Monoids
15:32:43 <jle`> mplus is an associative binary operation with an identity, so it creates a monoid over Monads
15:32:50 <jle`> but it is not a haskell Monoid, so it's not actually <>
15:33:18 * hackagebot hledger 0.22.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.22.1 (SimonMichael)
15:33:20 * hackagebot hledger-web 0.22.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.22.1 (SimonMichael)
15:33:22 * hackagebot hledger-lib 0.22.1 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.22.1 (SimonMichael)
15:34:08 <Tekmo> joneshf-laptop: The `mzero` method of the `MonadPlus` type class is analogous to `mempty` and `mplus` is analogous to `(<>)`
15:34:33 <Tekmo> joneshf-laptop: They also obey laws similar to the monoid laws
15:35:00 <jle`> well...they are supposed to be exactly the same monoid laws, right?
15:35:02 <Tekmo> joneshf-laptop: x `mplus` mzero = x, mzero `mplus` x = x, and (x `mplus` y) `mplus` z = x `mplus` (y `mplus` z)
15:35:05 <Tekmo> jle`: Yes
15:35:29 <joneshf-laptop> hmm
15:35:44 <joneshf-laptop> so how does alternative factor into this?
15:35:47 <joneshf-laptop> OH!!
15:35:51 <joneshf-laptop> nvm, i think i see it
15:35:56 <Tekmo> joneshf-laptop: Alternative is similar, too
15:36:06 <Tekmo> `empty` is like `mempty` and `(<|>)` is like `(<>)`
15:36:07 <Twey> There's an edwardk explanation: http://stackoverflow.com/a/10168111/1423873
15:36:20 <Tekmo> `Alternative` and `MonadPlus` were introduced for two reasons
15:36:27 <Tekmo> One is that they accept higher-kinded parameters
15:36:31 <joneshf-laptop> <|> would be like left catch vs mplus being left dist
15:36:32 <joneshf-laptop> right?
15:36:35 <Tekmo> For example `[]` is a higher-kinded type constructor
15:36:55 <jle`> joneshf-laptop: <|> and mplus are actually supposed to be identical
15:37:04 <jle`> the same way that *> and >> are
15:37:05 <Tekmo> joneshf-laptop: My rule of thumb is that they should all have identical implementations
15:37:10 <Tekmo> joneshf-laptop: mempty = empty = mzero
15:37:18 <Tekmo> joneshf-laptop: (<>) = (<|>) = mplus
15:37:21 <jle`> it's all a big mess as a result of the whole monad/applicative superclass mess
15:37:27 <joneshf-laptop> ugh
15:37:38 <shachaf> []? Why?
15:37:39 <jle`> really the Plus in MonadPlus is Alternative
15:37:45 <Tekmo> The second reason they were introduced is because of what `jle` said: people wanted `Applicative`/`Monad` constraints on them
15:37:48 <shachaf> [] is just :: * -> *.
15:37:53 <jle`> MonadPlus offers a reasonable >>= over Alternative
15:37:59 <jle`> so MonadPlus is Alternative + >>=
15:38:05 <Tekmo> I prefer to use `Monoid` for all three cases
15:38:10 <jle`> and offering reasonable ways that >>= should behave over alternativey stuff
15:38:10 <shlevy> OK, this is the first time I've really *felt* the magic of "if it compiles it works" :)
15:38:23 <Tekmo> shlevy: Awesome! :)
15:38:36 * jle` throws party for shlevy
15:38:42 <pavonia> Can anyone explain the semantics of HookedBuildInfo to me? http://hackage.haskell.org/package/Cabal-1.18.1.2/docs/Distribution-PackageDescription.html#t:HookedBuildInfo
15:39:20 <shachaf> Well, perhaps "higher-kinded" just means "not *". Who knows.
15:39:25 <jle`> really though technically Alternativey stuff need not be Applicative
15:39:38 <jle`> but we stop there because it becomes less productive to splinter off so much
15:39:44 <Tekmo> shachaf: Yeah, that's what I meant.  Was that the wrong word?
15:40:38 <Tekmo> The reason that it has the `Applicative` constraint is just so that they can add `some`/`many` as methods to the type class
15:41:05 <jle`> joneshf-laptop: there are a lot of things in Haskell that are monoids but not Monoids. this confused me a lot at first because whenever somebody told me it was a monoid i would look for the Monoid constraint and not find any
15:42:16 <jle`> or Monoid instance
15:42:56 <joneshf-laptop> jle`, i dont understand what you mean by the difference between monoid and Monoid
15:43:15 <jle`> joneshf-laptop: Alternative provides a monoid over Applicatives
15:43:18 <joneshf-laptop> jle`, do you mean that while it obeys the Monoid laws, there's no actual Monoid instance of it?
15:43:21 <jle`> but they aren't instances of the Haskell typeclass Monoid
15:43:24 <Tekmo> The Haskell `Monoid` type class is not as general as the category theory notion of a monoid
15:43:31 <jle`> joneshf-laptop: yes that's what I mean
15:43:38 <joneshf-laptop> jle`, k cool
15:43:43 <jle`> whenever you have any sort of associative binary operator
15:43:47 <jle`> and an identity for it
15:43:49 <jle`> you have a monoid
15:43:53 <jle`> and you can do monoidal reasoning about it
15:44:04 <jle`> so you can have this without actually being a part of the Monoid typeclass
15:44:15 <joneshf-laptop> right
15:44:21 <Cale> Well, it's not even just the thing Tekmo's referring to, but the fact that things satisfy the constraints to be a monoid, but nobody's written an instance of Monoid
15:45:23 <joneshf-laptop> so let me go back and rephrase my question.
15:45:54 <Cale> What I believe Tekmo's referring to is the general notion of a monoid object in a monoidal category (where the usual mathematical notion of a monoid is a monoid object in the monoidal category Set together with Cartesian product and a one-element-set
15:45:55 <joneshf-laptop> if something is a monad and monoid, would bind be distributive over mappend?
15:46:09 <joneshf-laptop> not necessarily in the haskell typeclass hierarchy
15:46:27 <Cale> joneshf-laptop: Even if M t is a monoid for every t, and M is a monad you have no guarantee about distributivity.
15:46:29 <jle`> it depends on the semantics of your monoid
15:46:30 <philed> For every natural number k, the multiples of k are a monoid under addition.
15:46:41 <philed> Not sure what instance that is.
15:46:43 <jle`> your binary operator can 'mean' anything you want
15:46:49 <jle`> as long as it is associative and there exists an identity
15:46:49 <Cale> That's something extra which you'll have to prove using the definition of M
15:47:44 <jle`> you can make a binary operator with semantics/meanings that destroy distributivity
15:47:52 <jle`> if at least by construction
15:48:17 <Cale> Moreover, there are many practical examples where distributivity fails.
15:48:19 * hackagebot enummapmap 0.6.0 - Map of maps using Enum types as keys  http://hackage.haskell.org/package/enummapmap-0.6.0 (MatthewWest)
15:48:45 * ReinH imagines a Haskell world in which (.) = fmap
15:48:47 <benmachine> philed: up to isomorphism that's just the instance for Natural
15:48:50 <ReinH> > let (.) = fmap in succ . [1,2,3]
15:48:51 <lambdabot>  [2,3,4]
15:48:59 <ReinH> > let (.) = fmap in succ . succ . [1,2,3]
15:49:00 <lambdabot>  [3,4,5]
15:49:01 <ReinH> o_O
15:49:06 <benmachine> ReinH: you're not the first to think along those lines
15:49:18 <ReinH> benmachine: I assumed not but it is surprisingly hard to google for
15:49:20 <philed> benmachine: But up to isomorphism, isn't is really [()]?
15:49:24 <benmachine> ReinH: the functor laws become id . f = f and (f . g) . h = f . (g . h) -- :)
15:49:40 <Cale> ReinH: I've half-seriously advocated that for a long time.
15:49:41 <benmachine> philed: I question your use of "really" but yes
15:49:49 <ReinH> philed: well, [()] is isomorphic to the natural numbers
15:49:51 <joneshf-laptop> hmm, this seems unfortunate
15:50:02 <Cale> ReinH: In fact, for most of the time I was running lambdabot, I had the definition that (.) = fmap in scope :)
15:50:03 <philed> benmachine: Replace "really" with "just".
15:50:04 <joneshf-laptop> also, it feels like i'm trying to define a ring here or osmething
15:50:20 <benmachine> philed: sure
15:50:23 <ReinH> Cale: heh :)
15:50:24 <jrmithdobbs> ReinH: why not > succ <$> succ <$> [1,2,3]
15:50:39 <ReinH> jrmithdobbs: because then I couldn't "overload" .
15:50:47 <Cale> jrmithdobbs: Why not succ . succ . [1,2,3]? :)
15:50:54 <benmachine> succ <$> succ <$> [1,2,3] doesn't mean what you think it means, but does work
15:51:03 <benmachine> (<$> is left-associative)
15:51:11 <Cale> Oh, good, that's what I thought it meant
15:51:16 <benmachine> shh :P
15:52:06 <ReinH> heh
15:53:00 <shachaf> Whenever both type-check, (a <$> b) <$> c = a <$> (b <$> c)
15:53:27 <quchen> That's the second Functor law, isn't it
15:53:27 <Cale> yes, as we just pointed out above in another notation :)
15:53:29 <ReinH> benmachine: and that formulation of the functor laws helps to drive home their monoid-nature as well.
15:53:30 <Cale> yes
15:53:55 <Cale> ReinH: well...
15:54:01 <benmachine> ReinH: I kind of disagree
15:54:06 <ReinH> benmachine: ok, no it doesn't.
15:54:19 <quchen> ReinH: monoid-nature?
15:54:20 <jle`> shortest debate ever
15:54:21 <Cale> It's really kind of sketchy to say that there's anything too monoid-like here.
15:54:33 <ReinH> Cale: identity and associativity + hand wave = monoid
15:54:34 <ReinH> QED
15:54:48 <Tekmo> Cale: Yeah, I was wondering about that the other day when I saw this note:
15:54:50 <Tekmo> @src (.)
15:54:50 <lambdabot> (f . g) x = f (g x)
15:54:50 <lambdabot> NB: In lambdabot,  (.) = fmap
15:54:53 <Cale> ReinH: Why not + hand wave = category?
15:55:06 <ReinH> Cale: well yes. Even less hand waving involved
15:55:09 <quchen> "Literal associativity" :-)
15:55:15 <benmachine> f . id and id . f are differently-typed expressions when . is fmap
15:55:28 <Cale> Tekmo: tee hee, it seems someone put back the definition of (.) without adjusting @src
15:55:35 <ReinH> benmachine: right, so we are really getting the category laws, not the monoid laws
15:55:40 <triliyn> :t fmap id f
15:55:41 <lambdabot> (Functor f, FromExpr (f b)) => f b
15:55:41 <ReinH> id_A and id_B
15:55:54 <triliyn> er, wait
15:56:04 <triliyn> :t fmap id ?f -- does this work?
15:56:05 <Cale> ReinH: But even the category bit is a little sketchy here. You're not really using the same function.
15:56:05 <lambdabot> (Functor f, ?f::f b) => f b
15:56:19 <ReinH> Cale: I didn't say f . id = id . f :p
15:56:19 <shachaf> No category laws here.
15:56:25 <triliyn> aha, right, I should have been able to know that
15:56:26 <Cale> otoh, it does work for (<=<) and return
15:56:44 <Tekmo> However, it's always fun to bring this up when somebody asks about the `(.:)` operator, because then you can just define it as `fmap fmap fmap`
15:56:45 <Cale> (Those do get you an honest category)
15:56:47 <monochrom> > not . [True]
15:56:48 <lambdabot>  Couldn't match expected type `a0 -> GHC.Types.Bool'
15:56:48 <lambdabot>              with actual type `[GHC.Types.Bool]'
15:56:56 <ReinH> Tekmo: or fmap `fmap` fmap
15:57:07 <benmachine> Cale: woo kleisli, etc.
15:57:08 <Tekmo> ReinH: I like the former because it's even more confusing
15:57:23 <ReinH> Tekmo: I thought that was why I liked mine
15:57:27 <ReinH> fmap fmap fmap makes sense
15:57:27 <Tekmo> ReinH: :)
15:57:35 <ReinH> (.) (.) (.) = (.).(.)
15:57:39 <ReinH> obv
15:57:46 <benmachine> :t fmap`fmap`fmap
15:57:47 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:57:49 <triliyn> (.) `fmap` (<$>)
15:57:54 <Cale> fmap . fmap is probably the easiest way to understand that idiom
15:58:06 <benmachine> fmap`fmap`fmap = fmap fmap fmap, we are forced to deduce ` =
15:58:12 <ReinH> Cale: yep, I used fmap . fmap for a while without realizing the significance
15:58:22 <hpc> benmachine: QED!
15:58:22 <shachaf> There is no significance.
15:58:29 <benmachine> shachaf: story of my life
15:58:31 <shachaf> People say "fmap fmap fmap" just to be confusing. It's the only reason to say it.
15:58:37 <ReinH> Cale: for instance newtype Grid a = Grid [[a]]; instance Functor Grid where fmap = fmap . fmap
15:58:45 <Tekmo> See, shachaf agrees with me!
15:58:57 <monochrom> people do not reason
15:59:06 <mauke> shachaf: that's not true
15:59:13 <Cale> shachaf: Well, I was thinking specifically of the case where you choose the functors to be (->) e
15:59:26 <ReinH> shachaf: significance referring to the fact that (.) = fmap
15:59:27 <dwcook> Once we're able to overload function application, it won't be so simple. :P
15:59:28 <t7> @type fmap . fmap
15:59:28 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:59:35 <Cale> It's easier to typecheck fmap . fmap than it is to typecheck (.) . (.) at least for me
16:00:03 <Cale> So that's one case where generalisation helps a little to make things understandable
16:00:04 <quchen> shachaf was just getting at the third fmap, which is an obfuscated (.).
16:00:09 <Tekmo> Maybe we should define a new branch of mathematics called `fmap theory` where everything uses `fmap` instead of `(.)`
16:00:10 <randomclown> can you put pattern guards on a case statement?
16:00:26 <monochrom> yes
16:00:34 <Cale> case expression*
16:00:40 <ReinH> Tekmo: I'm going to use `fmap` in place of (.) from now on.
16:01:04 <quchen> ReinH: Enjoy your automatically generated fixity riddles
16:01:06 <Tekmo> ReinH: Okfmap
16:01:42 <ReinH> > case () of () | 1 + 1 == 2 -> "yep" -- randomclown
16:01:43 <lambdabot>  "yep"
16:01:48 <Cale> quchen: Well, the fixity isn't usually much of an issue
16:01:52 <Tekmo> quchen: You can technically add an `infix` statement for `fmap`
16:02:00 <Tekmo> quchen: Just make it match the statement for `(.)`
16:02:15 <ReinH> quchen: fixity errors are my favorite errors
16:02:18 <dwcook> Tekmo, Couldn't match expected type `[ReinH]' with actual type `Okfmap'
16:02:22 <quchen> Then it's even more pointless: it's not even pointless!
16:02:26 <Tekmo> dwcook: :)
16:02:27 <ReinH> heh
16:02:36 <Cale> quchen: Note that, as was pointed out a few times, if (.) = fmap, then one of the Functor laws can be written (f . g) . x = f . (g . x), so it doesn't matter whether it's infixl or infixr
16:02:45 <dwcook> (Assuming data ReinH = ReinH and data Okfmap = Okfmap)
16:02:57 <Tekmo> Cale: That just blew my mind
16:02:59 <ReinH> dwcook: what else?
16:03:00 <Cale> and whenever one typechecks, then so does the other
16:03:03 <monochrom> oh god
16:03:25 <Tekmo> Cale: So you also get one of the identities, but not the other one
16:03:36 <Tekmo> fmap id = id => id . x = x
16:03:37 <Cale> Tekmo: yeah
16:03:38 <blaenk> byorgey: you around?
16:03:49 <joneshf-laptop> hmm, can't seemto find counter examples to this distributivity thing, anyone have a quick one?
16:03:56 <Cale> Tekmo: the other one has too special a type to apply generally, of course
16:04:09 <quchen> Within 10 minutes someone here will discover that both Functor laws are free theorems of the appropriately funny notation.
16:04:17 <Tekmo> Cale: So I guess you could use that as a justificaiton that the composition operator is more fundamental than `fmap`
16:04:23 <ReinH> quchen: I was waiting for that
16:04:29 <ReinH> quchen: but edwardk seems to be out
16:04:33 <edwardk> ?
16:04:37 <quchen> :-D
16:04:37 <ReinH> oh hai
16:04:41 <edwardk> sup?
16:04:42 <shachaf> sigh
16:04:49 <schell> does any know how to turn http://lpaste.net/98213#line20 into point free?
16:04:55 <ReinH> edwardk: honestly I'm not even sure
16:05:03 <joneshf-laptop> crap, no time, i'll be back to bug you all
16:05:14 <shachaf> schell: lambdabot knows:
16:05:14 <Tekmo> schell: The whole program?
16:05:14 <edwardk> well, that makes my answer easy. not sure either ;)
16:05:14 <hpc> schell: you probably don't want to
16:05:16 <shachaf> @pl popoutUnsafe xs ys = catMaybes $ popout xs ys
16:05:16 <lambdabot> popoutUnsafe = (catMaybes .) . popout
16:05:17 <ReinH> joneshf-laptop: fmap catMaybes . popout
16:05:19 <jfischoff> schell: if you have to ask, you probably shouldn't, but ther is @pl
16:05:21 <shachaf> But I don't recommend it.
16:05:23 <edwardk> GIGO ;)
16:05:35 <ReinH> edwardk: agreed!
16:05:44 <schell> ahhh
16:05:48 <Cale> Tekmo: Well, it is, in the sense that you need to define composition before you can say what functors are.
16:05:48 <shachaf> schell: At most, popoutUnsafe xs = catMaybes . popOut xs
16:05:50 * jfischoff has never made it all the way through "Theorems for Free" :(
16:05:51 <schell> double dots
16:05:54 <schell> mind blown
16:05:55 <ReinH> Any time you see (f . ), substitute fmap f and wonder why pointfree doesn't do that
16:05:59 <shachaf> Don't write (f .) . g. It's just confusing.
16:06:07 <Tekmo> Cale: Oh yeah, I totally missed out on that :)
16:06:11 <Cale> Tekmo: But then once you do that, the covariant Hom functor is a functor.
16:06:12 <monochrom> I agree with shachaf
16:06:13 <schell> it is
16:06:13 <edwardk> agreed
16:06:20 <edwardk> i tend to disliked sectioned (.) in point free code
16:06:21 <Cale> and it captures the notion of composition again
16:06:25 <Tekmo> jfischoff: I can give you a really dumbed down version of it
16:06:26 <shachaf> ReinH: Come on. Don't give people the advice "fmap f . g". That's even worse, and this person is asking a genuine question, not making fmap jokes.
16:06:37 <ReinH> shachaf: I don't think it's worse, I am not trying to troll.
16:06:46 <jfischoff> Tekmo: sure, but if you have any other links to read that would also be nice
16:06:49 <Cale> I actually don't mind (f .) . g too much in some circumstances
16:06:52 <Tekmo> jfischoff: If two functions modify different sets of type parameters, then they commute
16:06:56 <schell> and what's the 'point' of point free? is it just style? like K&R brackets etc?
16:06:56 <edwardk> fmap f <$> g -- clearly
16:07:06 <Cale> But I only stopped minding it once I understood that (f .) was fmap f
16:07:10 <jfischoff> huh
16:07:13 <Tekmo> jfischoff: That's not as general as the true version, but it gets you part of the way there
16:07:16 <Tekmo> Let me explain
16:07:18 <edwardk> schell: it is often easier to read off the dual construction when you have it point free
16:07:30 <Tekmo> Take for example the `first` and `second` functions, specialized to the `(->)` arrow
16:07:32 <edwardk> dual (f . g) = dual g . dual f, etc.
16:07:34 <Tekmo> :t first
16:07:34 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
16:07:37 <Tekmo> Blah
16:07:46 <schell> dual construction.. ah thanks
16:07:48 <Tekmo> first :: (b -> c) -> (b, d) -> (c, d)
16:07:50 <Cale> I actually really think that fmap f . g is frequently okay
16:07:51 <jfischoff> its cool I know the type
16:08:00 <ReinH> schell: the point of pointfree is to break up functions into composable units in a way that improves readability.
16:08:00 <Twey> I like fmap f . g
16:08:10 <monochrom> when you write or read pointfree, you focus more on combining functions and less on chasing parameters
16:08:17 <Twey> Though not as much as f .: g
16:08:17 <Tekmo> jfischoff: Okay so now imagine we give `first` and `second` concrete functions of types: `f :: A -> B` and `g :: C -> D`
16:08:18 <ReinH> I think that fmap f . g is an idiom that, once learned, is easy to understand and reuse
16:08:22 <monochrom> because you omit parameters
16:08:22 <Cale> But it helps if you somehow are in a bit of code which is really consistently manipulating things at the level of functions.
16:08:26 <Tekmo> jfischoff: first f :: (A, x) -> (B, x)
16:08:41 <Cale> If it's just a one-off thing, it can be a bit jarring to see that
16:08:42 <Tekmo> jfischoff: second f :: (x, C) -> (x, D)
16:08:43 <quchen> schell: You can rewrite `maybePop` in terms of `listToMaybe` and `drop`. The function will then traverse the input list only once, and will even work on infinite ones.
16:08:52 <ReinH> schell: my favorite pointfree code is the Richard Bird style
16:08:57 <Tekmo> jfischoff: Notice how each function is polymorphic in one part of the type and concrete in the other
16:08:59 <monochrom> syntax conditions mind. you see what, you think what.
16:09:13 <Tekmo> jfischoff: The `first f` function is polymorphic in the second field of the tuple and concrete in the first
16:09:16 <jfischoff> yeah it click when you said they commute
16:09:22 <Tekmo> jfischoff: Yeah
16:09:30 <jfischoff> It just never occured to me
16:09:41 <Tekmo> So since they deal with different "fields" of the type, they commute: first f . second g = second g . first f
16:09:46 <Tekmo> That's an example of a free theorem
16:09:51 <schell> quchen, ReinH : thanks - more things for me to try and read
16:09:57 <Tekmo> It's a theorem you get purely from inspecting the type
16:10:01 <ReinH> shachaf: and as monochrom says, with a pointfree style the focus is on the functions and how they compose and the parameters become implicit
16:10:12 <jfischoff> I'm impressed
16:10:29 <ReinH> jfischoff: free theorems are impressive
16:10:30 <Tekmo> here's another exapmle
16:10:36 <dario`> @pl (
16:10:36 <lambdabot> (line 1, column 2):
16:10:36 <lambdabot> unexpected end of input
16:10:36 <lambdabot> expecting lambda abstraction, expression or ")"
16:10:36 <Tekmo> jfischoff: Consider the `listTomaybe` function
16:10:39 <Tekmo> :t listToMaybe
16:10:40 <lambdabot> [a] -> Maybe a
16:10:50 <dario`> @pl (\x -> isUpper x || x == '!')
16:10:50 <lambdabot> liftM2 (||) isUpper ('!' ==)
16:11:01 <Tekmo> jfischoff: Then compare that to `fmap (f :: A -> B)`
16:11:04 <ReinH> Well. Free theorems are often not very impressive. The fact that they are free is pretty impressive.
16:11:13 <Tekmo> fmap (f :: A -> B) :: (Functor f) => f A -> f B
16:11:18 * quchen wonders whether there is a case where @pl is actually helpful
16:11:25 <Tekmo> jfischoff: `fmap f` only modifies the second type parameter
16:11:31 <ReinH> quchen: I've found a few but it generally produces worse code
16:11:37 <Tekmo> jfischoff: Whereas `listTomaybe` only modifies the first type parameter (the functor)
16:11:41 <Tekmo> jfischoff: Therefore they commute
16:11:45 <Cale> There is a place for points-free style, it's just not everywhere.
16:11:45 <jfischoff> yeah
16:11:48 <Tekmo> listToMaybe . fmap f = fmap f . listToMaye
16:12:17 <ReinH> Cale: and it's usually derived in a pretty natural way, not asked for from an oracle.
16:12:18 <jfischoff> yeah
16:12:40 <Cale> One of the more secret reasons that I always advocate that people write f . g . h $ x rather than f $ g $ h $ x is that it helps prepare your head for it :)
16:12:49 <Tekmo> jfischoff: Natural transformations are all about taking what I just said and making it super-rigorous
16:12:52 <ReinH> Cale: like, I always find Richard Bird's pointfree style to be elegant and expressive.
16:12:53 <jfischoff> spj had a quote about trying to make things pointfree
16:12:56 <Tekmo> jfischoff: but also more general
16:12:59 <Twey> schell: The distinction between âpoint-free codeâ and ânot point-free codeâ isn't all that clear in Haskell.  Any time you pass around a function f instead of (\x â f x), you're in some sense using point-free code, so the question of âwhy use point-free style?â makes about as much sense as âwhy use infix operators?â â point-free is the default; adding extra parameters to eliminate it is
16:13:01 <Twey> just redundancy.  Of course, sometimes a little redundancy isn't a bad thing.
16:13:10 <jfischoff> hmm
16:13:13 <ReinH> Cale: right, although chrisdone seems to hate f . g . h $ x and prefer (f . g . h) x
16:13:14 <blaenk> hey I cloned this project https://github.com/byorgey/haxr how can I run the tests in test/ ? it uses quickcheck. I tried cabal test, but it says "this package has no test suites"
16:13:23 <Cale> ReinH: Well, that's okay too
16:13:24 <Tekmo> ReinH: I also prefer the latter style
16:13:25 <jfischoff> @quote spj pointfree
16:13:26 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
16:13:30 <jfischoff> heh
16:13:35 <schell> Twey: that makes sense
16:13:52 <ReinH> Cale: which actually makes a bit of sense, as the latter also says "maybe you need to let meaningfulName = (f . g . h)" a bit more
16:13:54 <benmachine> people arguing about using fmap as a prefix composition operator: how about "result" as a better name for it? (cf. semantic editor combinators)
16:13:57 <Cale> ReinH: Though it can be nice to avoid the parens if either the composition is quite long, or the x afterward is.
16:14:10 <ReinH> Cale: I think the idea is that the parens are a smell
16:14:18 <ReinH> which is sometimes true
16:14:22 <benmachine> <3 parens
16:14:28 <Tekmo> benmachine: Once you get into semantic editor combinators you should be using `lens` and the `mapped` lens specifically
16:14:29 <ReinH> and that a meaningful name is a better solution than a $
16:14:30 <shachaf> benmachine: Sure, when used as a lens/traversal/setter thing.
16:14:30 <ReinH> which is sometimes true
16:14:42 <Cale> A big point of using composition in the first place is to make that refactoring easy though, so I'll agree to that extent.
16:14:49 <benmachine> Tekmo: you're not the boss of me :P
16:14:53 <Tekmo> benmachine: :)
16:14:54 <Cale> But sometimes the composition doesn't show up in more than one place
16:15:01 <Cale> So it's okay if you don't define it separately then
16:15:15 <ReinH> Cale: yep, although even them meaningfulName can be better than f . g . h when you come back to it in 3 months
16:15:26 <ReinH> and sometimes not
16:15:30 <pavonia> Is the Setup.hs file ignored if I supply the Simple build-type to cabal?
16:15:53 <ReinH> Cale: again I think Bird strikes a great balance between use of composition and use of meaningful names
16:15:55 <Cale> ReinH: The best is when you use a meaningfulName which is actually inappropriate. ;)
16:16:02 <ReinH> ha!
16:16:08 <ReinH> and then a comment that is also wrong in a third way
16:16:08 <vektor> how would I utilizy event handlers? I'm using vty-ui. Let's say I take the basic example from http://jtdaugherty.github.io/vty-ui/manuals/vty-ui-users-manual-1.6.1.pdf (page5) and I want to access some variable from the main = do context from within the event handler's context. How do I do that?
16:16:16 <Tekmo> If I have a long function composition chain I like to document the intermediate types
16:16:30 <Tekmo> I'll put each function on a separate line and the types as comments on lines in between them
16:16:31 <Cale> Especially if it's emotionally or politically charged
16:16:35 <dcoutts_> pavonia: if you use build-type Simple then tools are free to bypass Setup.hs. That doesn't mean you don't need a Setup.hs however.
16:16:35 <Twey> schell: When people argue about when or whether point-free code is a good idea, what they're really discussing is where the code stops looking ânaturalâ to them.  I don't think anyone would seriously argue in favour of map (\x â f x) xs, but some people think (\x y â x == y) looks better than âliftM2 (==) x yâ, &c.
16:16:51 <jfischoff> Tekmo: I do the same thing
16:16:58 <Tekmo> jfischoff: Awesome! :)
16:17:12 <Cale> https://www.thc.org/root/phun/unmaintain.html has some nice examples of that ;)
16:17:18 <ReinH> Cale: for instance boxs = unpack . map cols . pack (with subsequent bindings for pack and unpack) from http://www.cs.nott.ac.uk/~gmh/sudoku.lhs is perfectly factored to my eyes
16:17:18 <pavonia> dcoutts_: And if I use Custom I make sure Setup.hs is always used?
16:17:49 <ReinH> neatly separated into logical units and then composed
16:18:02 <Cale> marypoppins = (superman + starship) / god
16:18:06 <blaenk> how can I build the test file in test/ in this repo https://github.com/byorgey/haxr ?
16:18:20 <Tekmo> Cale: Every time I read that site I laugh so hard
16:18:24 <blaenk> trying to figure out how to run the tests. cabal test doesn't work cause I guess they didn't register the tests in the cabal file
16:18:29 <Tekmo> Cale: I think it's funnier though if you have experience in C/Java
16:18:30 <ReinH> Cale: I once gave a talk called Unfactoring from Patterns: Job Security Through Code Obscurity.
16:18:32 <schell> Twey: ah, i haven't looked into liftM2 - those two expressions are equivalent?
16:18:38 <Tekmo> Cale: I tried showing it to some Python-only people and they didn't get a lot of it
16:18:45 <ReinH> Cale: it was scarily well received.
16:19:21 <ReinH> I rewrite the Ruby on Rails framework just enough to use pig latin for everything
16:19:50 <ReinH> class OgblayOntrollerCay < ApplicationWayOntrollerCay and so on
16:19:58 <ReinH> Unfortunately I didn't have time to rewrite the ruby lexer
16:20:03 <Twey> schell: No, I screwed up :Ã¾  I meant (\x â f x == g x) vs. liftM2 (==) f g
16:20:11 <ReinH> That would have been especially epic
16:20:12 <Tekmo> I love this one: "If your manager presses you, insist that no-one else uses it, and point out that it doesn't work with your large suite of tools like lint and plummer that work around C's failings. "
16:20:24 <Tekmo> That's in reference to using Ada
16:20:28 <ReinH> Tekmo: ha
16:20:35 <Tekmo> I feel that the same applies to people saying why not to use Haskell
16:20:55 <Tekmo> "It doesn't work with your large suite of tools that work around your current language's failings"
16:20:57 <schell> Twey: ahhh - i see
16:21:01 <ReinH> Tekmo: I love the "It doesn't work with tools that we only even need because other langauge is bad"
16:21:08 <Tekmo> ReinH: Exactly! :)
16:21:33 <Cale> wtf, is github down?
16:21:37 <ReinH> Tekmo: But I went further: pig latin naming conventions.
16:21:39 <Tekmo> Cale: Partially
16:21:42 <ReinH> Deal with it.
16:21:42 <schell> Twey: i should have know from liftM
16:21:43 <hpc> up for me
16:21:50 <hpc> probably a cdn thing
16:21:56 <Tekmo> Cale: Check status.github.com
16:21:58 <ReinH> Cale: it has been in various stages of outage all day
16:22:01 <Cale> I'm getting 503's about half the time
16:22:05 <schell> Cale: it's been slow for me all day
16:22:08 <ReinH> Cale: sounds about right
16:22:21 <roboguy_> Cale: I like how they include the m_ thing
16:22:23 <Cale> anyway, here's some hilarious code: https://github.com/gpc/grails-searchable/blob/master/src/java/grails/plugin/searchable/internal/compass/mapping/SearchableGrailsDomainClassPropertyMappingFactory.java
16:22:36 <roboguy_> that convention never made sense to me
16:22:58 <ReinH> Tekmo: Oh I replaced things like @posts.each {|post| ... } with for i in [0...@posts.length] too
16:23:08 <Tekmo> ReinH: Ha!
16:23:15 <Cale> This entire project is full of stuff like that. YAY PATTERNS
16:23:16 <ReinH> Tekmo: the ... provided a nice opportunity for an off-by-one error that you can then fix.
16:23:21 <ReinH> Tekmo: because fixing bugs is progress!
16:23:34 <shachaf> ReinH: That's not an off-by-one error.
16:23:37 <Tekmo> ReinH: Fixing bugs = more commits = visible progress
16:23:44 <ReinH> Tekmo: (... is exclusive range, so [0...4] is [0,1,2,3])
16:23:46 <Cale> public abstract class AbstractSearchableGrailsDomainClassCompassClassMapper implements SearchableGrailsDomainClassCompassClassMapper { ... }
16:24:12 <ReinH> shachaf: fence-post error, whatever.
16:24:26 <schell> omg that's long
16:24:35 <ReinH> That is short for Java classes
16:24:42 <shachaf> ReinH: The only error is [0...x] instead of (0...x)
16:24:47 <jack_rabbit> That's absurd...
16:24:55 <schell> ReinH: are you joking or serious?
16:25:00 <ReinH> shachaf: no?
16:25:02 <Tekmo> Cale: But what if they need to modify their `SearchableGrailDomainClassCompassClassMapper` construction in the future without breaking client code?  Then they need `AbstractSearchableGrailsDomainClassCompassClassMapperFactor`
16:25:06 <schell> i'm laughing and terrified at the same time
16:25:15 <ReinH> shachaf: I'm using a language's range syntax.
16:25:28 <ReinH> shachaf: oh I see what you mean.
16:25:31 <shachaf> ReinH: Oh, maybe that's not Ruby. It looks like Ruby.
16:25:39 <hpc> schell: it's on the medium side, but replace the crazy long names with <generics> and interfaces instead
16:25:51 <ReinH> Yes, or in this case [0...x] vs [0...x)
16:25:52 <jack_rabbit> schell, And I was arguing that succinctness is overrated just last night... now I see this.
16:26:01 <Cale> Tekmo: they might get by with https://github.com/gpc/grails-searchable/blob/master/src/java/grails/plugin/searchable/internal/compass/mapping/SearchableGrailsDomainClassCompassClassMapperFactory.java
16:26:03 <schell> haha
16:26:14 <Tekmo> Cale: I'm laughing so hard
16:26:22 <shachaf> ReinH: What?
16:26:23 <schell> my brain is screaming already
16:26:29 <schell> it looks like zebras in grass
16:26:41 <jack_rabbit> Cale, I need a wider screen.
16:26:44 <shachaf> [0...x) is probably a syntax error in Ruby. Maybe it's not in your language.
16:26:52 <chrisdone> you guys seen this? it's a neat tool, it's like some chat+code+slides integrated teaching tool https://www.enginehere.com/stream/430/preview-intro-to-haskell/
16:26:56 <bitemyapp> Cale: maybe they've figured out something we haven't?
16:26:59 <Tekmo> Cale: I cannot imagine how somebody can type that out and not realize that something is wrong
16:27:01 <ReinH> shachaf: I thought you were referring to intervals when you said [0...x] vs (0...x)
16:27:04 <ReinH> shachaf: so I was too
16:27:11 <chrisdone> seems there's a newbie class being taughht presently, but it's cool
16:27:21 <ReinH> [0...4] is x such that 0 <= x < 4
16:27:24 <jfischoff> @hpast
16:27:24 <lambdabot> Maybe you meant: paste part
16:27:30 <chrisdone> the video only seems to work in chrome, not firefox. but oh well
16:27:32 <jfischoff> @hpaste
16:27:32 <lambdabot> Haskell pastebin: http://lpaste.net/
16:27:33 <shachaf> I'm referring to Ruby syntax. 0...x is a Range object. [0...x] is an array with one element.
16:27:35 <ReinH> chrisdone: hi :)
16:27:44 <ReinH> shachaf: ah, right.
16:27:46 <chrisdone> hei reinh
16:27:59 <ReinH> shachaf: too much Haskell and too little Ruby
16:28:11 <shachaf> (0...a.length).each {|i| ...a[i]... } is a correct way to iterate over a.
16:28:16 <Tekmo> ReinH: I think you just discovered a new way to make your code unmaintainable
16:28:17 <jrmithdobbs> ReinH: that's the way i'm starting to prefer things personally
16:28:24 <ReinH> jrmithdobbs: me too.
16:28:24 * hackagebot attoparsec 0.11.1.0 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.11.1.0 (BryanOSullivan)
16:28:29 <shachaf> If you're being pedantic, at least don't be wrong at the same time.
16:28:31 <Tekmo> ReinH: Make it look like you are iterating over a range when you are in fact iterating over an array with one element
16:28:40 <ReinH> shachaf: wait, *you* are calling *me* pedantic.
16:28:43 <ReinH> I love it.
16:29:06 <bitemyapp> chrisdone: could you say anything about how you're using Fay at work?
16:29:08 <zRecursive> It seems Ruby code is much elegant. but i heard Ruby is VERY slow ?
16:29:16 <bitemyapp> chrisdone: I'd like to include a blurb in a lightning talk I'm possibly giving on Fay.
16:29:20 <jfischoff> any ideas: http://lpaste.net/98216 ?
16:29:27 <Tekmo> zRecursive: I think that's based off of the benchmark shootout results
16:29:31 <jrmithdobbs> ReinH: also, i agree with shachaf as well, replacing the Enumerable #each with for ... in ruby always feels "wrong" to me
16:29:43 <ReinH> jrmithdobbs: that's not what shachaf was saying, and it was *supposed* to be wrong
16:29:46 <zRecursive> Tekmo: in detail
16:29:54 <ReinH> jrmithdobbs: you missed some context wherein I was trying to make the code worse.
16:29:56 <jrmithdobbs> ReinH: teach me to skim ;p
16:30:04 <shachaf> sigh
16:30:10 <jfischoff> wait let me explain :) I'm getting on cabal update: http://lpaste.net/98216
16:30:12 <Tekmo> zRecursive: http://benchmarksgame.alioth.debian.org/u32/which-programs-are-fastest.php
16:30:16 <shachaf> I recommend not talking about either Ruby or Java in here.
16:30:18 <jfischoff> any ideas?
16:30:19 <chrisdone> bitemyapp: we have 13k lines of fay code for the fp complete ide, and some small amount for the school of haskell
16:30:19 <ReinH> But it wasn't supposed to be functionally incorrect and shachaf pointed out that it was.
16:30:23 <eazar001> doing a runhaskell Setup.lhs configure --user should put the package under my $HOME/.cabal/packages directory right?
16:30:24 <ReinH> That's all
16:30:53 <shachaf> It's not all, but whatever.
16:31:03 <bitemyapp> chrisdone: pros/cons? I think bergmark said he was working on integrating fay packages with Cabal?
16:31:04 <chrisdone> bitemyapp: we make extensive use of shared server- and client-side data types, and a tiny bit of shared code
16:31:16 <ReinH> shachaf: ...
16:31:21 <bitemyapp> chrisdone: so sharing centers mostly around data types and not code, that sounds about right.
16:32:44 <chrisdone> bitemyapp: uhmm, in our use-case packages are a very small issue. most of our code is written by ourselves and we bind to a bunch of JS libraries with FFIs or drop to JS when fay isn't fast enough
16:33:43 <chrisdone> bitemyapp: when ghcjs lands in ghc 7.8 we'll probably give that a spin, and haste is also a potential candidate replacement for fay, as it follows a similar philosophy
16:34:06 <Tekmo> shachaf: Is there any work being done to improve type synonym inference in ghc?
16:34:48 <randomclown> @pl \x -> f x <|> g x
16:34:48 <lambdabot> liftM2 (<|>) f g
16:34:49 <shachaf> What's type synonym inference?
16:34:58 <chrisdone> bitemyapp: the main thing that fay provides that none of the other ones do is a really convenient FFI. ghcjs is getting smaller, and is pretty fast (i'm told). haste is small and reasonably efficient. both have sucky FFIs. although ghcjs might make that not matter as much. we'll see
16:35:12 <bitemyapp> chrisdone: do you know anything about how ghcjs' output compares with Fay?
16:35:26 <bitemyapp> payload matters for the sort of people I'm presenting this to.
16:35:28 <Tekmo> shachaf: By this I mean `ghc` doing a pass over an inferred type to simplify it using selected type synonyms
16:35:37 <shachaf> Oh.
16:35:38 <Tekmo> shachaf: You would explicitly opt-in type synonyms for this thing
16:35:49 <Tekmo> shachaf: I think such a feature would greatly improve the usability of both `lens` and `pipes`
16:36:29 <shachaf> So "improve" is really "implement", since it doesn't do it at all right now. It just sometimes doesn't expand synonyms.
16:36:41 <Tekmo> Right, that's what I meant.  Implement
16:37:04 <Tekmo> So nobody is working on this, right?
16:37:17 <Tekmo> I was just asking because I wanted to take a stab at it and I didn't want to step on anybody's toes
16:37:29 <shachaf> Nothing as far as I know.
16:37:31 <chrisdone> bitemyapp: well it used to be a lot larger, then it got just larger. i'm not sure how big it is these stays. luite can answer better. fay's runtime is a couple kb and modules are small, and it compresses super well. if payload matters, fay or haste might be best. but i've not seen a recently generated ghcjs app, maybe it's smaller today
16:37:36 <shachaf> lightquake was talking about it the other day, though.
16:37:41 <bitemyapp> is there anything approximating a road-map on when GHC 7.8 is believed to land?
16:37:44 <shachaf> I think he was working on a program for it or something.
16:38:09 <bitemyapp> chrisdone: I think I'd be happy to use Fay, I'd just like to see typeclasses.
16:38:12 <lightquake> yeah, I was vaguely hacking on that. but only vaguely.
16:38:12 <shachaf> But of course introducing synonyms is much trickier than expanding them.
16:38:13 <Cale> Tekmo: To make the whole thing even more ridiculous, this thing is a binding to something called Compass, which itself is a wrapper around Lucene, which is used to do full text searches inside databases. It was being used in a web application backend to do a search that could easily be handled by a SQL query.
16:38:14 <chrisdone> lightquake was working on mapping types to corresponding synonyms, yeah
16:38:19 <jfischoff> bitemyapp: ask carter ;)
16:38:25 <Tekmo> Cale: Haha
16:38:30 <chrisdone> bitemyapp: wouldn't we all =)
16:38:45 <chrisdone> bitemyapp: in that case haste might be a good compromise
16:38:46 <carter> eh?
16:39:05 <lightquake> Tekmo: feel free to work on it, I'm not claiming the project as my own or anything
16:39:07 <Tekmo> Cale: All it's missing is to send a web request somewhere in there
16:39:22 <Tekmo> lightquake: Ok
16:39:29 <jrmithdobbs> Tekmo: lucene talks http
16:39:30 <jrmithdobbs> iirc
16:39:43 <quchen> bitemyapp: The current status seems to be that nobody really knows, but maybe PatternSynonyms is added because why not.
16:39:49 <Tekmo> jrmithdobbs: Sometimes reality is stranger than fiction
16:39:50 <lightquake> and yeah, `lens` and `pipes` were the use-case I had in mind
16:39:50 <bitemyapp> jrmithdobbs: you don't often use that.
16:40:07 <Tekmo> lightquake: Yeah, that's the #1 complaint I get about `pipes`
16:40:15 <Tekmo> lightquake: Poor type inference and bad error messages
16:40:34 <carter> quchen: status fo what?
16:40:35 <bitemyapp> jrmithdobbs: generally lucene is embedded within something else and spoken to via the Java API ala Solr or ElasticSearch, the latter being the best I've used.
16:40:40 <quchen> carter: 7.8
16:41:08 <carter> its happening soon Or i'm travelling to the release engineers house at night and banging on the door
16:41:08 <Cale> Tekmo: Do you have some good examples of pipes code where the full generality of Proxy is actually important?
16:41:12 <carter> for 12 hour shifts
16:41:15 * quchen is a little confused by the current release information public relations department
16:41:16 <carter> :)
16:41:17 <Tekmo> Cale: You mean upstream direction?
16:41:21 <Cale> Tekmo: yes
16:41:28 <carter> quchen: i'm about as knowledgable as anyone
16:41:40 <Tekmo> There are two practical reasons for it and one theoretical reason
16:41:50 <carter> quchen:the honest answer is ghc devs have been a disorganized cluster fuck, for which i appolgoize
16:41:59 <Cale> Tekmo: It struck me the other day that everything is much more comprehensible if we do away with it, and turn some of the type synonyms into newtypes.
16:42:01 <carter> i will take measures to pester thigns like this from not happenign again
16:42:13 <Tekmo> Cale: So the first practical reason is parametrizing requests
16:42:18 <chrisdone> cale: the best thing about SearchableGrailsDomainClassCompassClassMapperFactory is that i read it as a joke and laughed, then i realized it wasn't a joke, and laughed harder
16:42:21 <carter> quchen: ok :)
16:42:22 <quchen> carter: It wasn't me who brought your name up.
16:42:25 <joejev> does there exist a good graphics library for doing visualizations other than gloss (I am having problems with gloss). I do not need it to do any input handling or anything
16:42:26 <carter> i know
16:42:30 <carter> i'm just addressing the 7.8 matter
16:42:32 <carter> ;)
16:42:33 <Cale> chrisdone: hahaha
16:42:35 <Tekmo> Cale: An example of this is would be parametrizing the number of bytes to consume instead of always requesting a fixed chunk size
16:42:42 <carter> jfischoff: was the one who said my name
16:42:45 <Tekmo> Cale: Another example would be an RPC-like interface to some service
16:42:48 <carter> g2g dinner
16:43:10 <Tekmo> Cale: The second practical use case arises when you use `pipes` as an `io-streams` replacement
16:43:24 <Tekmo> Cale: It turns out that there is a really elegant way to map `io-streams` on to the `request`/`respond` categories
16:43:48 * hackagebot fast-logger 2.1.2 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.1.2 (KazuYamamoto)
16:43:55 <Tekmo> Cale: And when you do that, the upstream support corresponds to being able to parametrize reads and recieve results from writes
16:44:27 <Tekmo> Cale: The theoretical reason for it is the internal implementation is much simpler and more symmetric
16:44:49 <Tekmo> Cale: it's also easier to reason about formally because you get more laws than you do for the unidirectional case
16:45:05 <monochrom> joejev: perhaps diagrams or threepenny-gui. I don't really know.
16:45:17 <Tekmo> Cale: For example, a lot of pipes laws that I haven't written about yet are actually free theorems once you add upstrema support
16:46:04 <Tekmo> Cale: An example of this is something like
16:46:25 <Tekmo> Cale: p >-> for cat (\a -> yield (f a)) == for cat (\a -> yield (f a))
16:46:33 <Tekmo> Cale: That's a free theorem you get
16:46:37 <Tekmo> Oops
16:46:41 <Tekmo> The right-hand side should be
16:46:45 <Tekmo> for p (\a -> yield (f a))
16:47:22 <lightquake> Tekmo: oh, that reminds me. if you have a Server b' b m (), then for each b' the server receives it sends exactly one b downstream, correct?
16:47:27 <Tekmo> lightquake: That's right
16:47:41 <Tekmo> lightquake: Technically the answer is more nuanced
16:47:54 <Tekmo> lightquake: It's more appropriate to say that it cannot receive another `b'` until it sends a `b` downstream
16:47:55 <Cale> Tekmo: Also, have you considered using type-level pairs with better naming, and perhaps some simple type families to try to simplify reading things?
16:48:07 <Tekmo> Cale: I prefer just adding the type synonym fix I mentioned
16:48:13 <Tekmo> Cale: It seems like a milder extension
16:48:25 <Tekmo> Cale: Oh, and there's another reason why type-level pairs don't work
16:48:34 <Cale> Oh?
16:48:34 <vektor> how would I utilizy event handlers? I'm using vty-ui. Let's say I take the basic example from http://jtdaugherty.github.io/vty-ui/manuals/vty-ui-users-manual-1.6.1.pdf (page5) and I want to access some variable from the main = do context from within the event handler's context. How do I do that?
16:48:34 <Tekmo> Cale: They don't place nicely with the request/respond category
16:48:36 <lightquake> Tekmo: got it
16:48:38 <Tekmo> Cale: Or maybe they do
16:48:44 <Tekmo> Cale: I might not fully understand how type level pairs work
16:48:58 <Tekmo> Cale: But the issue I'm referring to is that the type variables of the pairs also appear in the argument and return value
16:49:32 <Cale> Tekmo: Yeah, so you could give nice names to the projections like Down and Up
16:49:41 <Tekmo> Cale: Yeah
16:49:44 <chrisdone> so the use-case for pipes and conduits is essentially to easily do chunked streaming? without doing manual hGetSome's and messing about with unsafeInterleaveIO and handling resource close exceptions
16:49:50 <Tekmo> However I still prefer the type synonym solution
16:50:00 <Tekmo> Also, the type synonym solution would benefit lens, too
16:50:34 <Tekmo> Improving type synonym inference is something Haskell will need eventually anyway
16:50:40 <shachaf> Type synonym expansion is easy and type synonym introduction is impossible.
16:50:50 <Tekmo> Right now libraries have to choose between being sufficiently general or having nice type inference and error messages
16:51:00 <lightquake> chrisdone: i wrote a simple IRC bot using it, where each plugin was a separate thread and basically had type Pipe Message Response m ()
16:51:02 <jfischoff> chrisdone: with Pipes you can model streaming in a pure way too
16:51:02 <Tekmo> It would be nice to be able to have both
16:51:11 <shachaf> I hope people use type synonyms less, not more.
16:51:24 <chrisdone> like, iteratees i've used and all they do is yield (finish), continue or error
16:51:30 <ocharles> Tekmo: there is a lot that you have to reimplement with type synonyms
16:51:33 <Twey> vektor: Use a closure: define your handler as a function of the variable
16:51:34 <Tekmo> shachaf: So you're saying we shouldn't use `Lens'`?
16:51:39 <quchen> shachaf: Is the introduction algorithm a version of some well-known uncomputable function?
16:51:42 <ocharles> as in a lot more API space you have to fill
16:51:52 <shachaf> quchen: No, it's just not confluent.
16:52:01 <Tekmo> ocharles: Can you give me a motivating example so I can understand the problem space?
16:52:02 <ocharles> Pipes are co- and contravariant functors, and they are also profunctors
16:52:19 <ocharles> but you can't just reuse the contramap api, because the type is in the wrong place
16:52:27 <Tekmo> Oh, I understand that
16:52:29 <ocharles> and you can't create type synonym instances, so that doesn't help either
16:52:31 <Tekmo> I have no intention of solving that problem
16:52:34 <edwardk> one hazard with 'magicing up type syonyms' is that users often use them with implied contacts. type UserId = String; type Lens s t a b = ... carries connotations about the laws, etc.
16:52:42 <vektor> Twey: But from what I can tell, I have next to no control over the handler's function definition.
16:52:53 <ocharles> I suppose "re-implement" is not what I meant, but you have to pollute the set of function names and that requires people learn new things
16:52:57 <chrisdone> shachaf: yeah, i hate type synonyms. i don't like reading them, i don't like that they're not separate like newtypes, i don't think they're a substitute for documentation either
16:53:04 <edwardk> you don't want to just replace Sting with UserId because it is in scope
16:53:11 <Tekmo> ocharles: So I have dabbled in solving that separate problem
16:53:16 <edwardk> now, trying harder to preserve the synonym? sure
16:53:19 <Twey> vektor: You define the handler
16:53:23 <Tekmo> ocharles: I think that lenses might make that problem tractable
16:53:40 <Tekmo> ocharles: The idea is that you use lens support for isomorphisms to automate newtype wrapping and unwrapping
16:54:01 <Tekmo> ocharles: However, then you have to upgrade type class operator to accept the lens isomorphism
16:54:03 <lispy> It's unfortunate that when a TH splice "splits" your module that GHC can't give you better error messages.
16:54:07 <Tekmo> ocharles: And also make it syntactically wieldy
16:54:13 <Twey> vektor: If you're defining it right in your main, you can refer to the variable all you like, since you've already got it in a closure: main = do foo â getFoo; e `onActivate` \this â doSomethingWith foo
16:54:23 <Tekmo> ocharles: For now, I'm content to just improve type synonym inference until i figure out a better solution to that harder problem
16:54:25 <lispy> For example, if you have a top level splice and a type defined below it and used above it, then you get an error saying the type is not in scope
16:54:30 <ocharles> Tekmo: you mean Contravariant has to be aware of some Iso?
16:54:36 <Tekmo> ocharles: Something like:
16:54:47 <lispy> data Foo = Foo Bar; $(someTH); data Bar = Bar
16:54:48 <jfischoff> lispy: yeah that's annoying
16:54:50 <Twey> vektor: If not, you'll have to pass it as an argument: makeActivateHandler foo this = doSomethingWith foo; main = do foo â getFoo; e `onActivate` makeActivateHandler foo
16:54:50 <Tekmo> ocharles: (f . g) theIso
16:55:08 <Tekmo> ocharles: In other words, the `.` basically has a type like:
16:55:23 <Tekmo> ocharles: (Iso -> b -> c) -> (Iso -> a -> b) -> Iso -> a -> c
16:55:25 <jfischoff> lispy: I have all my TH at the bottom of files in one splice if I can
16:55:41 <Tekmo> ocharles: Then you can use that to automate isomorphism passing while still having passable syntax
16:55:59 <Tekmo> ocharles: So using `pipes` as an example
16:56:07 <lispy> jfischoff: the alterantive here is that I'm not actually using lens so I could remove the splices...
16:56:09 <Tekmo> ocharles: If you had a `PullIso` that was an isomorphism to the true category
16:56:12 <Tekmo> ocharles: You would just write
16:56:16 <lispy> jfischoff: I just assumed it would be useful
16:56:19 <Tekmo> ocharles: (p1 . p2) pullIso
16:56:32 <Tekmo> ocharles: And it would take care of supplying the correct category instance
16:56:55 <ocharles> Hmm, not quite following
16:57:09 <ocharles> I would have thought if you wanted lens/newtypes, you'd use  ala  and friends
16:57:18 <vektor> Twey: ahh, the first one was what I had in mind. The second one goes a bit beyond my knowledge of the language I think. Passing parameters alongside with callback functions didn't quite work in c++ unless the API explicitly allowed it :D
16:57:24 <Tekmo> ocharles: (.) would internally use `ala`
16:57:25 <ocharles> So if you want to map over the input to a producer, you could  ala Producer lmap whatever
16:57:28 <Twey> vektor: If you need more complex control flow, like updating âfooâ from the handler, you can use something like IORefs or (better) a FRP implementation like reactive-banana
16:57:30 <ocharles> Oh, right
16:57:31 <Tekmo> ocharles: It would be a different (.)
16:57:40 <ocharles> I got that, but I wasn't quite following how
16:58:07 <Twey> vektor: Functions aren't parameterized by their captured variables in Haskell, since it's a bit pointless with garbage collection.
16:58:49 <Tekmo> ocharles: Note that I haven't fully thought this out yet
16:58:54 <Tekmo> ocharles: It may indeed be half-baked
16:58:59 <Tekmo> ocharles: It was just a vague idea
16:58:59 <ocharles> :)
16:59:03 <ocharles> the best ideas1
16:59:04 <ocharles> !
16:59:06 <Tekmo> :)
16:59:22 <Tekmo> ocharles: I think you also have to modify the pipes themselves to take the iso
16:59:26 <Tekmo> ocharles: I'm not sure
17:00:00 <joejev> is it common to use continuation passing in haskell, it is something I picked up without knowing it, and now looking at other people's code, I do not see it that much.
17:00:21 <ocharles> Is there a monoid for Data.Bits .&.?
17:00:21 <Tekmo> joejev: I consider it a last resort
17:00:26 <hpc> joejev: we like to hide CPS behind other things
17:00:34 <Tekmo> joejev: If I may make an analogy to other languages, continuation passing style is very "frameworky"
17:00:36 <hpc> joejev: technically, do-notation is CPS
17:00:59 <jfischoff> ^ this
17:01:03 <Tekmo> joejev: It's easy to write a library tat uses continuation passing style, but it's hard to modify such a library because it is in the driver's wheel
17:01:04 <shachaf> "technically", it's not. Informally it's a lot like CPS.
17:01:20 <shachaf> But there's no point in getting into that.
17:01:25 <Tekmo> joejev: Sorry, by modify, I mean od something with it that it was not intended to od
17:01:27 <vektor> Twey: so when I do your first approach (accessing the variable from the outer closure), the original variable remains unchanged?
17:01:32 <vektor> Twey: such that incrementing foo in the handler and returning to the outer closure won't change the outer closure's variable?
17:01:33 <ocharles> hmm actually I guess you can't write a .&. monoid, because the identity element depends on the amount of bits in a
17:01:45 <shachaf> ocharles: Or just use -1
17:01:54 <jfischoff> shachaf: because it returns?
17:02:03 <ocharles> Though bitSize gives you that...
17:02:13 <ocharles> shachaf: that assumes that there is Num a, no?
17:02:38 <Tekmo> joejev: For example, consider the case of iterating over a list to do something
17:02:46 <Twey> vektor: You can't increment a value like that in Haskell
17:02:53 <Tekmo> joejev: Let's say you have a list of ints, i.e. [Int]
17:02:58 <shachaf> ocharles: Well, what will you do otherwise?
17:03:02 <joejev> Tekmo: ok
17:03:07 <shachaf> ocharles: Keep in mind that Integer is Bits.
17:03:13 <Tekmo> joejev: Now, for iterating over that list, I could either give you the a funciton of type `(Int -> IO ()) -> IO ()`
17:03:14 <Twey> vektor: All values are immutable (though they may point to mutable values, with things like IORefs or MVars)
17:03:25 <Tekmo> joejev: That function's first argument would be the action to apply for each element
17:03:39 <Tekmo> joejev: But that function is very brittle because the only thing you can do with the list is apply an `IO` action for each element
17:03:53 <Tekmo> joejev: If I don't give you the actual list proper, you can't use the data in any other way
17:04:14 <Tekmo> joejev: This is what I mean when I say that CPS style is like a framework.  It's very inflexible about how you can use it
17:04:32 <joejev> Tekmo: I think I might have misused that term
17:04:45 <Tekmo> s/CPS style/CPS/g
17:04:56 <blaenk> can someone please tell me how to compile/build the test in this package? https://github.com/byorgey/haxr
17:04:58 <blaenk> I'm inside a cabal sandbox
17:05:03 <blaenk> and I successfully built the package
17:05:05 <Twey> Continuation-passing CPS style
17:05:09 <ocharles> shachaf: Well, i was thinking mempty = foldl (\i b -> setBit i 1) (setBit 1) (bitSize mempty) or something
17:05:09 <blaenk> but I now want to compile and run the tests
17:05:12 <Tekmo> Twey: :)
17:05:13 <vektor> Twey: And the return is only a bool. Dammit. So I guess I need to deal with one of those things...
17:05:19 <ocharles> erm
17:05:23 <Tekmo> joejev: If you give me an example of what you have in mind I can give a more specific suggestion
17:05:32 <ocharles> foldl .. [ 1.. bitSize mempty]
17:06:01 <joejev> Tekmo: so I commonly see recursion written like f a b = g a : f b c or something
17:06:43 <joejev> Tekmo: where I commonly make the normal function just wrap a helper function that holds an accumulator list or something that will be returned at the base case
17:06:52 <joejev> Tekmo: I guess my use of the term is incorrect
17:06:53 <shachaf> ocharles: How about complement 0? However you get 0.
17:06:57 <ocharles> shachaf: heh, bitSize is partial for 0
17:07:01 <ocharles> erm
17:07:03 <ocharles> for Integer
17:07:05 <jfischoff> blaenk: `cabal repl` then load the file and run the prop_'s with quickCheck ... I guess
17:07:06 <ocharles> man I should sleep it seems
17:07:08 <shachaf> ocharles: complement (xor (bit 0) (bit 0)) -- whatever
17:07:09 <Twey> vektor: IORefs are basically your standard imperative mutable variables: you can update them from anywhere so long as you're in IO, the changes will be seen throughout your program, and they're not thread-safe.  FRP is a framework for thinking about events that happen at certain times and values that change in response to them.
17:07:21 <blaenk> jfischoff: thanks
17:07:33 <Tekmo> joejev: Oh, I understand what you mena
17:07:40 <Tekmo> joejev: So you want to automate the use of a helper function?
17:07:46 <ocharles> shachaf: right, that just requires you to be able to 0, so I guess you could consider the .|. monoid instead
17:07:52 <ocharles> but it doesn't seem possible to get the 0 here
17:08:04 <joejev> Tekmo: I guess, is this a thing?
17:08:06 <Twey> vektor: IORefs are probably easiest for you to jump into, but FRP will become increasingly more worthwhile as your control flow gets more complex (and it's awesome, so you should learn about it at some point anyway :Ã¾).
17:08:08 <Tekmo> joejev: So usually if you don't want to introduce a helper function you can use the `fix` function
17:08:09 <shachaf> ocharles: ?
17:08:31 <ocharles> shachaf: a monoid for a Bits instance with .|. would need all bits 0 for identity, right?
17:08:34 <shachaf> ocharles: I don't know what the Bits laws are but what I said is probably the identity for .&. for any reasonable instance.
17:08:42 <Tekmo> joejev: Let me see if I can think of a simple example
17:08:47 <ocharles> and again, I can't work out how to construct a 0 for any Bits a => a
17:08:53 <joejev> Tekmo: I know of the fix function
17:08:58 <ocharles> that was more my point
17:09:08 <Tekmo> joejev: The `fix` function is the way you introduce anonymous recursion really easily
17:09:15 <ocharles> (I'm not sure it can really be done)
17:09:23 <Tekmo> joejev: It's very often used for the purpose you describe
17:09:33 <Tekmo> joejev: When you don't want to introduce a named helper function
17:09:46 <shachaf> Except you name the lambda argument anyway.
17:10:38 <blaenk> jfischoff: ugh I have to add it to the cabal file apparently
17:10:39 <vektor> Twey: first, I'll take a look at IORefs. If I can get my stuff to work with it, fine. I'll make this project, and then get back to LYAH where I left off (monoids, iirc) to do some practical work.
17:10:56 <jfischoff> add what?
17:11:02 <blaenk> the quickcheck dependency
17:11:16 <blaenk> can't load the test file in the cabal repl cause it says quickcheck (which it imports) isn't in my cabal file
17:11:26 <joejev> Tekmo: I think an example would be like, mySum [] = 0; mySum (x:xs) = x + mySum xs vs mySum' = mySum'' 0; mySum'' r [] = r; mySum'' r (x:xs) = mySum'' (r + x) xs
17:12:02 <joejev> Tekmo: I know you can use a foldr but this is just an example
17:12:09 <joejev> how would I use fix here?
17:14:31 <jfischoff> blaenk: yeah
17:14:49 <blaenk> yeah, never done this before so I'm gonna give it a shot
17:15:18 <jfischoff> one gotcha the build-depends are case sensitive
17:15:50 <blaenk> thanks
17:30:27 <Twey> What's the right name for a term that's in WHNF but not fully evaluated?  Is it correct to call it a value?
17:32:02 <Cale> Twey: Well, you might just call it a term in WHNF but not NF
17:32:14 <Cale> I don't know if there's any special term for that condition
17:32:45 <Twey> data TermInWHNFButNotNF doesn't sit so well with me :Ã¾
17:32:48 <triliyn> Is "value" only used for fully-evaluated things? I've been using it informally for "things that live at the term level as opposed to at the type level"
17:33:17 <Twey> triliyn: I believe so (formally)
17:33:36 <Twey> triliyn: But generic things that live at the term level are called âtermsâ :Ã¾
17:33:48 <triliyn> hehe, right
17:34:25 <triliyn> I was going to say "as a synonym for term", but my brain is in dependent typing mode, where "term" does not carry an implicit "as opposed to type"
17:36:04 <Twey> triliyn: I think that's actually a feature of Pure Type Systems; there are âdependentâ languages that still have a term/type/kind hierarchy
17:36:17 <triliyn> hmmm, okay
17:36:23 <triliyn> My terminology as always is imprecise!
17:36:24 <bitemyapp> carter: that tweet sounded like something Data from TNG would say if he wasn't at all interested in learning how to be more human,.
17:36:45 <Twey> Oh, Wikipedia says no to that, too T_T
17:36:58 <Cale> bitemyapp: What tweet?
17:41:04 <blaenk> if I'm inside a cabal sandbox and I build the package that's sandboxed, how can I then compile a file in the same directory so that it can find the package?
17:41:18 <blaenk> it's just a simple file that imports the package in question
17:41:49 <blaenk> nevermind :)
17:41:53 <jfischoff> :)
17:41:57 <bitemyapp> blaenk: I take it you tried the obvious thing and it worked?
17:42:26 <blaenk> nah, I realized it wasn't the question I meant to ask
17:42:39 <blaenk> I had forgotten what the actual problem I was encountering was heh
17:42:41 <jfischoff> that should just work with :l
17:42:48 <bitemyapp> blaenk: I dunno if that's better or worse :)
17:42:48 <blaenk> yeah it did
17:42:59 <carter> Cale: i'm curious too
17:43:02 <blaenk> haha, I took a break from this issue for a while
17:43:18 <blaenk> having a hard time trying to run the tests for this hackage package
17:43:23 <blaenk> can't figure out how
17:43:31 <carter> bitemyapp: ohh, theres people who know me via twitter who don't realize that focus
17:43:46 <blaenk> I made some changes I want to contribute/submit but I wan't to be sure the tests pass
17:45:00 <bitemyapp> blaenk: which library?
17:45:14 <blaenk> https://github.com/byorgey/haxr/
17:46:09 <blaenk> I first did cabal repl and was going to :l the test file, but then it said QuickCheck wasn't in the cabal dependencies, so I added it (importing it manually in the repl would give the same error)
17:46:44 <blaenk> now that I did that and tried to :load it again, it says there's an error on line 30 column 5 of Properties.hs that 'coarbitrary' is not a visible method of class 'Arbitrary'
17:46:46 <joejev> whats a good 2d drawing library
17:47:06 <carter> joejev: diagrams and gloss
17:47:08 <carter> depending on what you want
17:47:17 <carter> diagrams is ideal for vector graphicsy things
17:47:24 <carter> and gloss is great for interactivbe 2d things
17:47:31 <hpc> diagrams is for diagrams
17:47:58 <hpc> last i tried it, diagrams was not terribly expressive for being used as a full-on canvas
17:48:16 <hpc> but that might have also just been me not looking through the whole package
17:48:19 <joejev> carter: I wrote a game in gloss, and I am having problems with it (crashes when I close the window under XMonad) but I just want something for visualizing something, no interaction
17:48:29 <carter> joejev: diagrams is great
17:48:35 <carter> hpc: its not there yet
17:48:43 <carter> for a raster stuff diagrams isn't right
17:48:44 <blaenk> bitemyapp: that file was last modified 7 years ago apparently, so perhaps QuickCheck has changed since then and those tests are no longer valid
17:49:06 <carter> probably
17:49:17 <carter> which file?
17:49:28 <blaenk> https://github.com/byorgey/haxr
17:49:39 <blaenk> been trying to figure out how to run the tests in that package. the file in question is test/Properties.hs
17:49:57 <codygman> lol a haskell thread got to the top of /g/
17:50:48 <joejev> does diagrams do animation
17:51:26 <bitemyapp> http://boards.4chan.org/g/res/39412965
17:51:29 <bitemyapp> NSFW ^^
17:51:33 <bitemyapp> has Haskell though.
17:51:54 <joejev> bitemyapp: why would you post /g/ here?
17:52:15 <bitemyapp> joejev: codygman referenced it, and some people are curious georges.
17:52:49 <hpc> that conversation is curiously high-level for 4chan
17:52:56 <codygman> joejev: Yeah, I referenced it... pretty crappy place... but thought people might want to know Haskell showed up. Apologies.
17:53:10 <blaenk> <hpc> that conversation is curiously high-level for 4chan
17:53:18 <blaenk> sure sure, we all know all of you guys are the ones partaking in that conversation right now
17:53:27 <hpc> haha
17:53:35 <codygman> lol
17:53:49 <hpc> that is... the third time ever i have clicked a 4chan link
17:53:51 <joejev> lol, but does anyone know if the diagrams library will do animation?
17:54:09 <hpc> maybe second time
17:54:22 <hpc> joejev: it doesn't do animation that i know of
17:54:46 <hpc> it has some kind of feature for "sequences" though, maybe?
17:54:53 <carter> joejev: theres plans for that
17:54:57 <hpc> it just kinda shows every frame at once
17:55:02 <carter> but if you want animation now
17:55:07 <blaenk> bitemyapp: actually I'd like to know the answer to my original question, if you know it. that is, I sandboxed a package and I have a simple file.hs that imports it to test it out, inside the same directory as the sandbox, and I want to compile that file so that it can find the package (even though it's sandboxed)
17:55:07 <carter> gloss or opengl or something
17:55:12 <blaenk> does anyone know how to do that?
17:55:14 <joejev> hpc: hmm, well then does anyone know why gloss behaves the way it does: when I close the window that my game is spawned in, it dumps me back at my login screen and kills all my applications
17:55:22 <joejev> (arch with XMonad)
17:55:46 <hpc> joejev: try reducing your code to a minimal reproduction and pasting it here
17:56:27 <joejev> um, can I just post the repo to the game? small tetris clone
17:56:29 <carter> joejev: that sounds lie a bug
17:56:29 <hpc> joejev: that's a weird enough issue that it will be either a configuration problem you need to fix in your WM
17:56:29 <bitemyapp> blaenk: if you mean to add the file *to* the sandbox, then you just add it to the cabal file. If you mean to make the sandbox available *to* the file then you add the cabal sandbox to the GHC package path environment variable.
17:56:33 <carter> *like
17:56:36 <hpc> or a real actual bug in gloss
17:56:44 <bitemyapp> blaenk: if you don't mean to do either of those things, then I am intensely confused.
17:56:47 <blaenk> yeah I think I mean the latter, bitemyapp. how can I accomplish that?
17:57:25 <blaenk> basically what I has is somepackage/ which is a sandbox, and I cabal built the package all fine. and I have somepackage/somefile.hs that imports that package, how can I build somefile.hs so that it can find the somepkg/
17:57:32 <blaenk> er, somepackage/
17:57:36 <bitemyapp> blaenk: https://www.google.com/search?client=safari&rls=en&q=GHC_PACKAGE_PATH&ie=UTF-8&oe=UTF-8#q=%22GHC_PACKAGE_PATH%22&rls=en leading to http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/packages.html leading to section "4.9.4.1" leading to ...
17:57:37 <blaenk> lol what I has, what I have
17:57:37 <hpc> i would try to reproduce your issue, but it's late and my box doesn't X, just ssh
17:57:38 <joejev> also, I had to comment out the text portions because they don't work, can't find the font or something
17:57:40 <bitemyapp> blaenk: ...your answer.
17:57:53 <joejev> hpc: thanks
17:57:53 <blaenk> bitemyapp: meh if it's such a bother, you shouldn't have bothered
17:58:11 <hpc> link it here and see who bites
17:58:13 <jle`> it looks like microsoft allows you to make develop windows 8 apps using js+html5
17:58:14 <bitemyapp> blaenk: it's not a bother, I'm showing you how to get your answers.
17:58:20 <bitemyapp> blaenk: and the answer *is* in the link.
17:58:27 <bitemyapp> blaenk: I just don't like dropping flat answers with no sourcing.
17:58:31 <bitemyapp> it's lazy and doesn't teach as much.
17:58:35 <jle`> does anyone know of anyone who has gone through with building a windows 8 app in Haskell + a JS compiler?
17:58:43 <bitemyapp> people don't learn where to look in the documentation if you don't source/
17:58:54 <joejev> this is the game that causes my wm to die when I close it: https://github.com/llllllllll/hTetris
17:59:42 <Cale> joejev: I think you should change some of the l's in your github username to I's
17:59:43 <Twey> Why does Gloss require such an ancient version of GLFW-b?
17:59:49 <blaenk> <bitemyapp> blaenk: it's not a bother, I'm showing you how to get your answers.
17:59:50 <bitemyapp> joejev: and 1's.
17:59:52 <blaenk> that's not patronizing at all
18:00:04 <bitemyapp> I'm trying to be nice and helpful, sincerely so :(
18:00:11 <blaenk> it's like if I had asked how you build a package with cabal, and you linked to google "which leads to" etc etc, you could just say 'cabal build' and not have to be a douche about it
18:00:21 <blaenk> if it really bothered you to answer then you shouldn't have bothered
18:00:24 <bitemyapp> I don't like getting flat answers dropped on me, I like knowing where the people found the answer so I can use the resource myself
18:00:28 <bitemyapp> I just got done saying it wasn't a bother
18:00:30 <blaenk> but in any case you did provide me with the answer, so I appreciate it regarldess
18:00:36 <bitemyapp> the only thing bothering me is your hostility to my sincere attempt to *HELP* you.
18:00:45 <blaenk> oh sure turn this around
18:00:52 <bitemyapp> blaenk: you are not encouraging me or the others here to help you again.
18:00:58 <blaenk> really?
18:01:01 <joejev> bitemyapp: I wouldn't do 1's, it's a starcraft thing and you cannot have 1's, I's might be funny though
18:01:12 <bitemyapp> joejev: oh you play SC2? Barcode user?
18:01:21 <joejev> bitemyapp: not me, no
18:01:27 <bitemyapp> joejev: spectator?
18:01:47 <joejev> oh, I played, but I wasn't a barcode
18:02:42 <bitemyapp> blaenk: part of the reason for providing sources is that it introduces the possibility of serendipitous discoveries, especially when the specific intended answer wasn't precisely what was needed.
18:02:57 <bitemyapp> blaenk: providing sources is a critical part of making the internet and information in general more useful and valid.
18:03:11 <bitemyapp> "I believe this to be true" is useless if there isn't a [1] at the end.
18:03:13 <joejev> bitemyapp: [citation needed]
18:03:20 <bitemyapp> right. See? He gets it.
18:03:32 <Cale> I tend to provide sources for things, but moreso after answering on my own.
18:03:39 <bitemyapp> people are so grumpy even when you're taking time to help them. Nuts. :(
18:03:43 <blaenk> I'm well aware, and I do appreciate it. but your linking to the google link first gave me a different impression, like I can't google it myself
18:03:52 <blaenk> I would if I had known the env var to google to begin with
18:03:59 <bitemyapp> blaenk: I try to provide complete "source" paths to answers.
18:04:20 <bitemyapp> blaenk: obscure free-standing pages can have a "well, gee if only I'd guessed that random page" feel to them.
18:04:37 <bitemyapp> blaenk: the path I provided is a faithful recording of what I *actually* did in order to *remember* the answer I was providing you.
18:04:49 <bitemyapp> blaenk: thereby giving you material for remembering, in future, the path I used to remember the answer.
18:05:19 <bitemyapp> blaenk: I really am sorry the internet has poisoned sourcing and providing example Google queries for you, but I'd appreciate the benefit of the doubt here.
18:05:38 <blaenk> in that case, again, I appreciate your answer, and I'm sorry for having misunderstood your tone
18:06:17 <bitemyapp> blaenk: it's no problem, sorry for not structuring it in a way that was more amenable to you. Good luck with your hacking :)
18:06:18 <blaenk> I tend to see google links as "lmgtfy" links. I normally would've expected the name of the env var, and I would've googled it myself. it's not everyday I encounter someone that provides answers like this, which I admit is refreshing
18:06:44 <bitemyapp> I hate "lmgtfy" for you because it misses the utility of having sufficient knowledge to even know what query to articulate to begin with.
18:06:50 <blaenk> exactly
18:06:51 <bitemyapp> I also hate it because it poisons the well for what I just did.
18:06:55 <Cale> (I think there is a valid point to be made here about putting the bibliography last ;)
18:07:06 <bitemyapp> Cale: does lambdabot have karma?
18:07:09 <blaenk> yep. and I admit/agree again that internalizing the 'path taken to reach the destination' is very useful
18:07:14 <Cale> @karma lambdabot
18:07:15 <lambdabot> lambdabot has a karma of 24
18:07:22 <blaenk> makes it more memorable
18:07:27 <bitemyapp> Cale: how do you increment somebody's karma?
18:07:34 <Cale> lambdabot++
18:07:35 <bitemyapp> blaenk: precisely!
18:07:37 <bitemyapp> Cale++
18:07:40 <bitemyapp> @karma Cale
18:07:40 <lambdabot> Cale has a karma of 38
18:07:44 <bitemyapp> there.
18:07:57 <JakeE> @karma JakeE
18:07:57 <lambdabot> You have a karma of 0
18:08:06 <eazar001> what is karma?
18:08:09 <codygman> @karma codygman
18:08:09 <lambdabot> You have a karma of 0
18:08:11 <eazar001> or should i google that?
18:08:13 <eazar001> lol
18:08:15 <bitemyapp> LOL
18:08:20 <bitemyapp> I was restraining myself on that one.
18:08:21 <JakeE> apprently people can up you or maybe down vote you
18:08:29 <eazar001> hahaha i set that one up clear
18:08:35 <JakeE> as you help people I suppose people would up your karma?
18:08:48 <eazar001> makes sense
18:08:59 <bitemyapp> JakeE: I think pithy comments probably generate more karma, but I'm sure that does too.
18:09:02 <Cale> and then every once in a while the karma database gets corrupted and everyone ends up at 0 or something, because lambdabot
18:09:12 <bitemyapp> Cale: karma jubilee!
18:09:23 <Cale> @karma dons
18:09:23 <lambdabot> dons has a karma of 2
18:09:28 <JakeE> bitemyapp: haha; that is how it is in most comunities
18:09:29 <shachaf> Not that people keep backups of the lambdabot database or anything.
18:09:45 <shachaf> /msg lambdabot @karma-all
18:10:00 <shachaf> monochrom++ # wisdom
18:10:23 <JakeE> well that was neat
18:10:27 <shlevy> With optparse-applicative, how do I make an optional positional argument? I'm getting a type error I don't get
18:10:34 <Cale> shachaf: Well, the karma database is especially pointless, and it's kind of tough to know if it's been reset.
18:10:41 <codygman> What do you guys make of this: http://prog21.dadgum.com/36.html
18:11:00 <BMeph> Isn't karma the #1 killer of dogmas? ;)
18:11:14 <shlevy>  Couldn't match type `Command' with `Maybe URI -> Command'
18:11:50 <geekosaur> there is a function where a simple value is wanted, or vice versa
18:11:52 <bitemyapp> codygman: his primary exposure to FP is Erlang.
18:11:57 <JakeE> codygman: a really terrible idea that sorta kind acts like "side effects"
18:11:59 <shachaf> Cale: Yes. It would probably be better gone.
18:12:09 <shachaf> But I went through a bunch of trouble reconstructing the quote database once.
18:12:49 <Cale> codygman: He has a point, but I think it's still a win even just to be explicit about what your states are.
18:12:51 <chrisdone> ircbrowse knows people's karma =p
18:12:53 <shlevy> Lemme see if I can make a simplified version
18:13:03 <chrisdone> dons has a karma of 171
18:13:11 <chrisdone> http://ircbrowse.net/nick/dons?recent=false
18:13:18 <bitemyapp> chrisdone: this clearly demonstrates the superiority of historical logs over mutable state.
18:13:30 <chrisdone> bitemyapp: =)
18:13:42 <bitemyapp> chrisdone: I'm being quite serious, as a Datomic user :)
18:14:00 * hackagebot wai-util 0.7 - Collection of utility functions for use with WAI  http://hackage.haskell.org/package/wai-util-0.7 (StephenWeber)
18:14:03 <chrisdone> i like the appropriate random quote for dons
18:15:13 <Jesin> <codygman> What do you guys make of this: http://prog21.dadgum.com/36.html
18:15:15 <Jesin> um
18:15:18 <Jesin> I don't think I get it
18:15:33 <Jesin> "(No destructive updates need occur, just the returning of a different list.)"
18:15:36 <chrisdone> bitemyapp: seems pointless that lambdabot needs to keep any state for any length of time if it can be replayed easily
18:15:53 <bitemyapp> chrisdone: "Oleg: A unit of measurement of type system complexity. Also, a famous computer scientist." is particularly good from dons' quotes.
18:16:15 <Cale> He's just awkwardly referring to the idea that instead of having a program which acts on a mutable state of type s in order to produce a result of type a, you can instead write a function of type s -> (s,a)
18:16:20 <Twey> codygman: Functional programming is never about eliminating state; it's just about making state *explicit*.  Sure the list might be arbitrarily mutated in some crazy way that you didn't expect, but at least you know it's *only* the list that's mutated like that, and that the change won't propagate to other random parts of your code (unless you explicitly pass the list around).  Furthermore, if you did want
18:16:22 <Twey> to restrict the computation further, you could (say by making your function return an element to be cons'd to the list, rather than arbitrarily mutating the whole list).
18:16:27 <Cale> a.k.a. the State s monad
18:16:31 <Jesin> ... well if you pass in a parameter to a function and then use part of the return value for that...
18:16:52 <Jesin> um
18:16:54 <Jesin> yeah
18:16:58 <bitemyapp> Cale: Haskell might be the next Lisp for the material that gets rediscovered and implemented badly.
18:17:00 <Jesin> that's what the State monad is *for*
18:17:07 <Jesin> how do you do that by accident
18:17:10 <bitemyapp> Jesin: see why I try to tell people this.
18:17:12 <Jesin> =/
18:17:15 <Twey> Heh
18:17:24 <Cale> Jesin: Before the State monad existed, this was an idiom
18:17:25 <schell> is there a way to check hackage for packages that depend upon a given package?
18:17:41 <Cale> Jesin: which goes back at least to the 1960's, probably in lisp
18:17:47 <chrisdone> @google hackage reverse dependency monitor
18:17:48 <lambdabot> http://packdeps.haskellers.com/
18:17:48 <lambdabot> Title: Hackage dependency monitor
18:17:54 <Jesin> okay, but there is now a State monad
18:18:00 <Cale> (perhaps one could argue it's even older than that :)
18:18:09 <schell> chrisdone: awesome!
18:18:16 <chrisdone> ã½ (ï¼¾â½ï¼¾) ï¾
18:18:20 <codygman> Twey, Jesin, JakeE, bitemyapp: Thanks. I'm going to read up on the State monad. I had a feeling there was a better way to implement what he was describing.
18:18:23 <Cale> Jesin: sure, and when you see code like that, you might consider using it!
18:18:35 <Cale> Jesin: but that doesn't change the nature of the point being made here
18:18:40 <eazar001> bitemyapp: imo haskell is already on a fastrack to bad implementation with cabal
18:19:11 <Cale> which is just that if you use this kind of idiom, you still have to be careful in some sense about the sort of bugs that stateful programs can run into.
18:19:16 <chrisdone> eazar001: cabal doesn't have any competition to spur it on =p
18:19:54 <c_wraith> chrisdone: that's a strange statement, given that cabal sandbox was a direct response to at least 4 competing things
18:20:03 <bitemyapp> eazar001: hum? cabal's been fine for me since cabal sandbox cleaned house.
18:20:11 <eazar001> chrisdone: heh, except for itself, i is its own worst enemy
18:20:15 <eazar001> woaaah
18:20:16 <Cale> However, because that state is so explicit and usually much simpler than the amount of state which the average imperative program has access to, the reasoning which is required is typically much simpler, and can piggyback on our ability to reason equationally about functions.
18:20:19 <shlevy> Can someone help me with this compile error? http://pastebin.com/qwc77cnv
18:20:20 <eazar001> what an exodus
18:20:21 <mauke> The paste qwc77cnv has been copied to http://lpaste.net/98217
18:20:29 <chrisdone> c_wraith: cabal didn't have a way to do sandboxing, that's not competition. that's implementing something cabal lacks entirely
18:21:00 <bitemyapp> chrisdone: c_wraith might be thinking of cabal-dev.
18:21:01 <chrisdone> c_wraith: competition would be a new package system for collections of .hs files
18:21:31 <eazar001> bitemyapp: i actually haven't tried a hand at cabal sandboxes, but I heard it solves a lot of headaches
18:22:18 <Cale> shlevy: Try (\x y -> Command (Options x y)) <$> ...
18:22:18 <c_wraith> chrisdone: you have a strangely limited perspective.  Everything else wrapped cabal heavily to provide their own wrapped versions of everything it does.  Therefore, cabal did all the same things they did, but they did something more useful.  so cabal added that more-useful bit to itself to compete with them.
18:22:24 <bitemyapp> eazar001: it moved Haskell from "unusable" to "pure joy" for me.
18:22:28 <bitemyapp> Seriously.
18:22:33 <bitemyapp> it fixed all my problems.
18:22:40 <eazar001> hmmm
18:22:50 <bitemyapp> cabal will still hiss and spit if I try to do something stupid, but the elimination of global state solved the intractable stuff.
18:22:53 <Twey> eazar001: Cabal sandboxes are a very big return on investment.  I'm enjoying them.
18:23:08 <eazar001> investment?
18:23:11 <eazar001> are they troublesome to set up?
18:23:15 <Twey> No
18:23:18 <eazar001> oh
18:23:21 <Twey> âcabal sandbox initâ
18:23:23 <Cale> I haven't tried cabal's sandboxes yet, but I've used cabal-dev and such in the past to good effect.
18:23:25 <eazar001> so even bigger than my first impresion [=
18:23:26 <triliyn> I should probably learn to use these things at some point
18:23:27 <chrisdone> c_wraith: sure, but the authors of those tools wanted that thing in cabal, but knew it'd take ages to get something into cabal. not because cabal was an inherently different philosophy. everyone wanted it merged into cabal anyway
18:23:32 <eazar001> hmmm
18:23:38 <Twey> Then use Cabal normally âº
18:23:41 <Cale> eazar001: The investment is mostly build time
18:23:42 <eazar001> should i rebuild my platform then?
18:23:57 <shlevy> Cale: It worked with just x
18:24:23 <c_wraith> chrisdone: so, my point is, you're defining "compete" exceptionally narrowly.  More or less to the point where you could be saying "compete means exactly what I need it to mean for my statement to have a way to be true"
18:24:25 <chrisdone> c_wraith: whereas i'm using competition (i mean, i did use the word first in this discussion) to mean for cabal itself, not for some particular handy features
18:24:29 <Cale> shlevy: (\x -> Command . Options x) would also work
18:24:47 <Cale> shlevy: Or (Command .) . Options
18:24:50 <chrisdone> c_wraith: yes, i am defining compete narrowly. am i not allowed to use meanings of words in a particular way?
18:24:57 <shlevy> Cale: oh duh
18:24:59 <Cale> shlevy: Or fmap Command . Options :)
18:25:00 <shlevy> augh thank you
18:25:01 <dcoutts_> chrisdone: I think a lot of those impls overestimated how hard it is to get stuff into Cabal. It's really not that hard.
18:25:06 <shlevy> Been staring at this too long
18:25:07 <jle`> shlevy: your error has to do with using . with functions with two parameters
18:25:24 <shlevy> jle`: yeah the "(Command .) . Options" drove it home :D
18:25:28 <jle`> oh cale already answered
18:25:48 * jle` shakes fists
18:25:53 <Cale> hehe
18:25:59 <dcoutts_> chrisdone: though smaller scale experimenting with UI is good of course
18:26:16 <Cale> It might be nice to have some kind of syntax to help with that.
18:26:42 <Jesin> hmm
18:26:43 <Cale> (but it's hard to imagine what syntax to use that wouldn't horribly get in the way of other things)
18:26:52 <chrisdone> c_wraith: uhc, ghc, jhc are all 'competitors' -- ghcjs is not a ghc competitor, but eventually it will be merged into ghc 7.8. if i expand my definition to your "everything" scope, then ghcjs competes with ghc
18:26:57 <Jesin> I wonder if Erlang is worth learning
18:27:05 <jle`> Cale: can we help it at the operator level?
18:27:15 <Cale> Jesin: There are definitely some good ideas for distributed computation there.
18:27:16 <Jesin> what is "ghcjs"?
18:27:29 <c_wraith> chrisdone: the difference is ghcjs is just a different code emitter.
18:27:31 <Cale> Jesin: We're in the process of stealing them in the form of distributed-process :)
18:27:36 <dcoutts_> Cale, Jesin: which is why we stole them for Cloud Haskell :-)
18:27:41 <Jesin> Oh good.  ^_^
18:27:47 * dcoutts_ is beaten to it by Cale 
18:27:53 <Jesin> All of them?
18:27:57 <chrisdone> c_wraith: and cabal-dev was just a way of passing flags to cabal
18:28:12 <Jesin> "Haskell to JavaScript compiler"...ah
18:28:13 <c_wraith> chrisdone: it doesn't compete with ghc because it doesn't do anything replace any ghc functionality
18:28:16 <Jesin> well that's interesting
18:28:21 <Cale> dcoutts_: Well, I was echoing you too! I liked your lectures about Cloud Haskell :)
18:28:39 <dcoutts_> :-)
18:29:01 <chrisdone> c_wraith: neither did cabal-dev. it /added/
18:29:02 <jle`> is it safe to expect those js compilers to target ghc-haskell? i feel like half of the useful libraries use a ghc extension in one way or another and i'd like to be able to develop for js with them
18:29:23 <jle`> can i even expect to be able to use hackage packages in my js-compiled projects?
18:29:40 <chrisdone> c_wraith: cabal-dev foo was just cabal -package-conf .cabal-dev/etc foo or so
18:30:04 <c_wraith> chrisdone: ok, but my experience isn't with cabal-dev.  It's with an alternative that did the same thing better.
18:30:06 <Cale> jle`: Pure stuff, I would expect should work. Anything which does too much I/O or FFI obviously will be problematic.
18:30:07 <chrisdone> jle`: with ghcjs, sure!
18:30:12 <c_wraith> chrisdone: and it *did* replace every cabal command
18:30:31 <jle`> Cale: so things like lenses, mtl, etc.?
18:30:33 <Cale> yeah
18:30:39 <Cale> That stuff should all be fine
18:30:44 <dcoutts_> ghcjs is pretty impressive
18:30:45 <jle`> that's comforting
18:30:52 <jle`> but i forgot that ghcjs is actually ghc
18:31:16 <Cale> ... now where were luite's old demos ...
18:31:22 <chrisdone> c_wraith: well i also use hsenv which makes cabal, ghc, etc. behave "locally". i don't know of other cabal enhancements like thatâ¦
18:31:34 <c_wraith> chrisdone: I was using coup
18:31:36 <jle`> ghcjs supports a big set of ghc's concurrency stuff? that's cool
18:31:48 <c_wraith> chrisdone: and there were several others that weren't publicized.
18:31:52 <dcoutts_> c_wraith: I've not even heard of that one
18:32:00 * chrisdone neither
18:32:35 <Cale> There was a nice demo showing a physics simulation
18:32:55 <Cale> with a bunch of balls and some obstacles in a box which you could rotate
18:33:03 <chrisdone> there are a bunch here http://weblog.luite.com/wordpress/?p=127
18:33:08 <chrisdone> e.g. http://hdiff.luite.com/ghcjs/examples/balls1/
18:33:33 <Cale> ah, those are the newer ones
18:34:11 <Cale> (More fun in terms of the code, but somewhat less interesting simulation)
18:36:22 <chrisdone> i'm excited that hamishmack's released his webkit patches to hackage, now you can access the DOM directly. no ghastly javascript required. now you can write web crawlers in haskell \o/
18:37:27 <jle`> balls1 is so unsatisfying in my physics background intuition and triggers unhappy feelings >.>
18:37:29 <chrisdone> also my xmonad panel is now just pure haskell <3
18:40:24 <chrisdone> http://chrisdone.com/suave.png â haskell panel
18:45:22 <ReinH> chrisdone: do you use xmonad on a mac?
18:45:47 <johnw> he runs Linux on his MacBook
18:45:52 <ReinH> nice
18:45:59 <ReinH> I might try that
18:46:22 <chrisdone> \o/
18:46:25 <geekosaur> would have to be linux, none of the haskell panels I'm aware of know how to get information from anywhere but linux /proc
18:46:46 <geekosaur> (so useless on freebsd [the linuxulator doesn't populate nearly enough] or os x)
18:47:09 <chrisdone> geekosaur: this uses i3status
18:47:10 <lingxiao> hey all, I've got some computation of signature: `Monad m => ReaderT [Id] m r`
18:47:10 <ReinH> sysctl?
18:47:28 <lingxiao> so `Comp1 = Monad m => ReaderT [Id] m r`
18:47:49 <lingxiao> and `Comp2 = forall m. Monad m => WriterT String m r`
18:48:02 <chrisdone> (which supports freebsd and openbsd, for example)
18:48:13 <lingxiao> now I want to put them togethr into `Comp3 = comp1 >> comp2 >> return`
18:48:34 <lingxiao> now the types don't workout since one is a Reader and another is a Writer, so is there a way to make it work?
18:48:46 <lingxiao> I'm trying to use hoist from Control.Monad.Morph
18:49:04 * hackagebot blink1 0.3.1 - Control library for blink(1) LED from ThingM  http://hackage.haskell.org/package/blink1-0.3.1 (DylanSimon)
18:49:05 <lingxiao> ie, `comp3 = comp1 >> hoist comp2 >> return ()`
18:49:10 <lingxiao> but it doens't seem to work
18:49:22 <johnw> lingxiao: you'll have to do: runReaderT comp1 x >> runWriterT comp2 y >> return
18:49:36 <chrisdone> geekosaur: do you use xmonad?
18:49:51 <geekosaur> use it and hack on it :)
18:50:00 <chrisdone> geekosaur: (âÂ´âï½â) https://github.com/chrisdone/chrisdone-xmonad
18:50:44 <geekosaur> (I seem to be the most active person in #xmonad these days)
18:51:28 <eazar001> xmonad is a killer wm
18:51:35 <eazar001> death to the mouse
18:54:43 <Adeon> can you run xmonad on mac without linux
18:55:44 <eazar001> Adeon: Not sure but ... http://xmonad.org/documentation.html
18:56:06 <lingxiao> johnw: ok cools thanks
18:57:20 <Twey> Adeon: I'd assume so, but it's an X11 window manager, so it will only manage X11 windows; Quartz windows probably won't work
18:57:36 <chrisdone> i know brian mckenna uses xmonad on the mac. some patched version
18:57:52 <chrisdone> "osxmonad"
18:57:59 <chrisdone> http://brianmckenna.org/blog/osx_tiling_window_manager
18:58:42 <Cale> Someone should write a nice-looking proper ordinary floating window manager in Xmonad.
18:58:47 <Cale> I would use it :)
18:59:02 <Cale> (i.e. a drop-in replacement for metacity's behaviour, to start)
18:59:02 <chrisdone> that feels like a perversion, like augustsson's BASIC in haskell
18:59:25 <Cale> I honestly do not like tiling WMs.
18:59:26 <Twey> Cale: Like Bluetile?
18:59:28 <chrisdone> oh you mean to ease them into it?
18:59:35 <Cale> No, I don't want tiling at all.
18:59:36 <Twey> Oh, I guess that's the opposite
18:59:39 <chrisdone> "install xmonad but retain  your evil ways for a while"
18:59:49 <ReinH> chrisdone: osxmonad o_O
18:59:56 <chrisdone> reinh: inorite
18:59:56 <Cale> I might like some of the rest of the configurability.
19:00:05 <tiffany> I like modal and tiling interfaces but I also like using my mouse instead of remembering which keyboard shortcuts are used for which of the 3 layers of tiled panes in xmonad -> tmux -> vim
19:00:10 <eazar001> it takes some getting used to
19:00:25 <chrisdone> i use my mouse with xmonad when i can't be bothered using the keyboard
19:00:28 <eazar001> but you'll generally find that freeing yourself from resizing moving windows makes you more productive
19:00:41 <Cale> Too many of the things I run do not make sense being squished into an arbitrary rectangle, and running everything fullscreen sucks.
19:00:47 <Twey> Well, floating is just a trivial case of tiling
19:01:08 <Twey> (where you get the position from the user instead of an algorithm)
19:01:14 <geekosaur> if only :(
19:01:28 <chrisdone> aren't there some workspace layouts for xmonad that do floating by default?
19:01:28 <Twey> In theory, at least
19:01:40 <chrisdone> e.g. for running GIMP and w/e
19:01:48 <Cale> chrisdone: Do they provide window borders and controls?
19:01:54 <Twey> tiffany: Doesn't Bluetile do that?
19:02:17 <geekosaur> also the standalone bluetile is probably badly bitrotted. it was folded into xmonad-contrib several years ago
19:02:20 <chrisdone> cale: don't know, never looked into it. just heard about it
19:02:22 <Twey> IMO GIMP is an ideal case for tiling
19:02:22 <tiffany> the only thing I use that doesn't lend itself to less-than-fullscreen is the web browser, but that is a pretty important thing
19:02:51 <Cale> I tend to run my web browser at less than fullscreen.
19:02:55 <Twey> I run that at less-than-fullscreen with a bar on the side, too
19:03:07 <geekosaur> osxmonad does not provide window borders or controls; there is rather limited ability to intercept those in Core Graphics
19:03:09 <chrisdone> twey: i quite like gimp for tiling, buuuut on the other hand it's also annoying. i prefer it in full-screen-mode
19:03:18 <tiffany> I hope you two like horizontal scrollbars
19:03:26 <yrdz> I just have a workspace dedicated to my web browser
19:03:26 <geekosaur> there are some oither tiling window managers for OS X that attempt to do so, not always successfully
19:03:42 <Twey> chrisdone: Where you can't access any of the dialogs?
19:03:59 <Cale> tiffany: Most things work fairly well in a web browser that's at about 60% of the width of a 1920x1080 display
19:04:31 <tiffany> I suppose, I haven't tried it since getting a second monitor (which happens to be 1080p)
19:04:36 <chrisdone> twey: well, i hypothetically prefer full-screen-mode =p
19:04:41 <Twey> tiffany: I'm fine with horizontal scrollbars (I scroll by holding a button and moving my trackball, so both dimensions have pretty much the same level of privilege for scrolling), but my laptop is widescreen, so I don't get many of them
19:05:03 <Cale> actually, it would be interesting to have a floating WM which would slowly adjust the position (but not the size) of background windows so as to try to make some piece of each one visible.
19:05:06 <eazar001> uhhh piece of advice since i'm just experimenting with sandboxes, and i still don't fully know what the hell they are ... Should I do cabal-dev or just sandbox?
19:05:10 <tiffany> just wait though, the moment the average resolution bumps over 1366x768 that won't be practical anymore
19:05:12 <triliyn> I run my web browser at like half of a 1600x900 display and I don't even get horizontal scrollbars sometimes :(
19:05:22 <triliyn> Instead, the webpage just pretends my browser is wide enough
19:05:38 <triliyn> And half the page is invisible until I resize
19:05:38 <Twey> eazar001: I don't know what cabal-dev is for :Ã¾
19:05:47 <chrisdone> twey: inkscape is pretty good with its own management. it's annoying with GIMP that it doesn't properly assign window types, so a dialog pop-up isn't properly propertized as a dialog popup, so xmonad doesn't treat it as such, and it smerges with all my other windows
19:05:50 <Twey> triliyn: Ych
19:05:55 <geekosaur> therer are some seriously broken web pages out there, that's not the browser it's an idiot web "designer"
19:05:59 <Twey> chrisdone: That's true
19:06:06 <Cale> tiffany: For the most part, web pages are text which doesn't mind being squished into a vertical column.
19:06:17 <chrisdone> twey: i could probably make a custom workspace in xmonad that could figure out how to layout and auto-float some windows, though, i guess, thinking about it
19:06:19 <tiffany> it depends on what kind of pages you visit
19:06:19 <geekosaur> they actually do extra work to *turn off* the browser's ability to adapt to different window sizes
19:06:20 <Twey> chrisdone: I feel like I don't want my image editor to be doing its own window-management, though
19:06:20 <Cale> In fact, it can even make many sites easier to read
19:06:32 <tiffany> anything using bootstrap won't resize at all
19:06:38 <tiffany> it's a fixed 900 pixel wide layout
19:06:41 <Cale> What's bootstrap?
19:06:43 <shlevy> Is there a way to error out on incomplete pattern matches?
19:06:54 <Twey> Cale: s/web pages/well-designed web pages/
19:06:56 <tiffany> the thing twitter put out that people use to make their websites look pretty with minimal effort
19:07:04 <Cale> What's twitter? :)
19:07:05 <tiffany> twitter itself uses it
19:07:18 <Twey> Isn't Bootstrap supposed to be fluid?
19:07:25 <tiffany> there is a fork of it that is, twey
19:07:30 <tiffany> but it is not a fluid layout itself
19:07:31 * geekosaur has the Maximize layout modifier bound to mod-shift-= for such cases, it temporarily pulls the tiled window out to a near-fullscreen pseudofloating arrangement
19:07:36 <tiffany> unless that was changed since I last saw it
19:07:42 <chrisdone> twey: i find i always have the toolbox on the right, and below it the options box. and then maybe i have layers below that. on the left i'll put the open images. but i find whenever i add an image or remove, i have to re-rotate the window arrangement to bring/remove things from the right. but perhaps, again, xmonad configuration can handle this for me
19:07:49 <triliyn> Yeah, I've seen a lot of pages that require scrollbars even though they're just text and would work perfectly well if they were squished to fit in my browser =/
19:08:12 <triliyn> (It's better than floating off the edge without offering me a scrollbar, but only just)
19:08:42 <Twey> tiffany: There's a thing: http://getbootstrap.com/2.3.2/scaffolding.html#fluidGridSystem
19:09:10 <Twey> chrisdone: Right â that's pretty much a textbook use-case for a customizable tiling WM
19:09:10 <chrisdone> this is using bootstrap: http://tryhaskell.org/
19:09:38 <chrisdone> there are two columns, console on the left, guide on the right. if you resize the window thinner, it will adjust the layout a bit, and eventually bring the right-hand-side down
19:09:40 <Twey> That's pretty nice
19:10:33 <Cale> Sometimes I still miss Enlightenment's old snapshotting iconbox and pager
19:11:03 <Cale> It seems you could do an even better version of that with compositing.
19:11:49 <Twey> Cale: As in, it shows you a thumbnail of what's on the desktop?
19:11:57 <tiffany> I suppose it's not as bad as it used to be
19:12:17 <Cale> Twey: yeah
19:12:29 <Twey> Cale: Don't all the DEs do that nowadays?
19:12:46 <Twey> GNOME, KDE, and e17 do, at least
19:12:48 <Cale> All I've got in Cinnamon is some rectangles with a boring 1, 2, 3 in them
19:13:15 <tiffany> xfce sort of shows you what's in each workspace in the switcher
19:13:22 <Cale> and in Gnome, it displayed simple rectangles rather than proper scaled screenshots
19:13:43 <Cale> (in the panel pager, anyway)
19:13:56 <Twey> GNOME has this huge bar on the right now that shows you exactly what's on each desktop
19:14:02 <tiffany> yeah it shows rectangles sometimes with icons in them for xfce, instead of a screenshot
19:14:06 <Twey> I don't think there's a panel pager any more
19:14:08 <Cale> Well, I can't stand Gnome 3 at all
19:14:14 <Cale> So there's that
19:14:29 <Twey> It's pretty neat, though it does take some getting used to
19:14:57 <Cale> There are still things which I miss from the Gnome 2 panel
19:15:05 <chrisdone> at some point i went uber barebones and now all i have is xmonad, my read-only panel at the top and i open a terminal to run a program (e.g. gimp&disown;exit), i have no idea which workspace i'm on except for what's on the screen. not intentionallyâ¦ at some point i guess i forgot to unbarebonesize my setup and this turned out to be mostly sufficient
19:15:43 <Cale> Primarily the ability to put multiple volume controls on my panel for master/front/headphones, and the world clocks/sunlight map/calendar thing
19:15:48 <Twey> chrisdone: A panel?  Luxury!
19:15:57 <chrisdone> twey: =p
19:16:10 <Twey> I just have xmonad and a prompt shortcut
19:16:15 <chrisdone> twey: but i wrote it miself, does that give me more 'cred?
19:16:57 <Cale> Also, the fact that Cinnamon's panel is buggy as shit whenever you try to drag things around or add them makes me pretty unhappy.
19:17:00 <chrisdone> the unity panel is no longer usable /outside/ of unity. they discontinued the unity-2d-panel package in the latest ubuntu. so i thought to hell with them and made my own
19:17:25 <chrisdone> cale: let's make our own!
19:17:32 <Cale> It feels like we've constantly been going backwards in terms of desktop software capability over the last few years
19:17:49 <Twey> chrisdone: Back in my day we had to get out of bed at three in the morning, write our own panels on the hard drive platter with a poisoned needle sharpened at both ends, â¦
19:18:22 <chrisdone> twey: then we'd wear our sunday best to logon to the internet and when we were finished we'd all stand up and sing the national anthem
19:18:40 <Twey> Cale: I don't know about backwards, but I don't think we've really been going forwards very much either.  GNOME 3 is the first step forwards I've seen, but it comes at the expense of customizability.
19:18:59 <Cale> Twey: That loss of customizability makes it pretty much a non-starter for me
19:19:03 <chrisdone> twey: what's particularly forwardsy about gnome 3?
19:19:10 <Twey> chrisdone: You try telling that to the kids today, they won't believe you!
19:19:55 * geekosaur notes that Cinnamon *is* GNOME 3
19:20:18 <Twey> chrisdone: It's a lot more device-independent, it has far better keyboard support, and it's generally more efficient (in numbers of clicks/keypresses to accomplish a task)
19:20:22 <Cale> geekosaur: Kind of. It's not Gnome Shell though.
19:20:24 <chrisdone> cale: i really really like anything to do with more tools being available upon which i can make my own desktop environment
19:21:04 <chrisdone> twey: device-independent? so it'll work on a phone?
19:21:11 <Twey> chrisdone: Unity did something pretty cool, too â it took those drop-down menus you get at the tops of windows and turned them into a rudimentary command interface Ã  la Raskin
19:21:22 <chrisdone> oh yea -- the HUD idea was very cool
19:21:24 <Twey> chrisdone: Yeah, it's touchscreen-friendly
19:21:59 <chrisdone> hmm, maybe i can ressurect that. i technically run unity and then just kill compiz and run xmonad. unity's still thereâ¦ in my base, removing my window menus
19:22:03 <Twey> (though I think you need to reflow the default layout a bit to make it fit on a small screen)
19:22:05 <geekosaur> but in any case I have given up on most of the current crop of desktop environments; I use xfce4+xmonad. gnome 3 as it is in fedora 19 drives me to fits of rage....
19:23:05 <slack1256> If I load code to ghci, can I run closures inside a function?
19:23:25 <Twey> slack1256: What does it mean to run a closure?
19:23:31 <chrisdone> slack1256: you mean local definitions that close over the local scope?
19:23:37 <slack1256> Yeah
19:23:39 <Twey> Oh
19:23:41 <chrisdone> sadly not
19:23:54 <chrisdone> although that would be interesting to have
19:24:03 <slack1256> Oh, okay
19:24:29 <Twey> It would be impossible â the values wouldn't be instantiated
19:24:37 <Twey> I guess you could do lambda-lifting or something
19:25:02 <slack1256> it's probably complicated
19:25:03 <Cale> chrisdone: Here's the stuff I'd like to have on my panel. Launchers which are simple icons that can be added and removed easily. Some variant of the Applications menu and Places menu. Multiple configurable ALSA volume controls which pop out a vertical slider when clicked and mute/unmute on double click. A system monitor with charts for CPU/memory/network(in/out) and hard drive usage. The system notification area. Weath
19:25:04 <Cale> er reports, preferably configurable to display detailed weather for multiple locations when clicked. Time and date with configurable world clocks on click and a sunlight map. A taskbar. A pager.
19:25:10 <slack1256> maybe not even worth it.
19:25:20 <slack1256> but thanks guys for the help
19:25:29 <Cale> Doing all that is enough that I'm probably not going to do it myself :)
19:25:41 <geekosaur> ...lxde panel or xfce panel :)
19:26:10 <geekosaur> neither of which ropes you into the rest of their desktop
19:26:36 <Twey> slack1256: I think GHC already does lambda-lifting at some point, though I could be wrong.  But yeah, it's not exposed to you as it stands.
19:26:52 <Cale> The xfce panel seemed really minimalist last time I looked at it.
19:26:54 <chrisdone> cale: hmm. well to make the system display i have here https://github-camo.global.ssl.fastly.net/9b0cc05d0effbd2c2ddc66842a7cd0bfefef3fa3/687474703a2f2f6368726973646f6e652e636f6d2f73756176652e706e67
19:26:54 <chrisdone> cale: i just imported webkit and configured i3status, and the clock is just Data.Time. for the other things...
19:28:11 <novochar> i'm trying to start a scotty server instance from within ghci, why might this not work? https://gist.github.com/novodinia/8328902
19:28:43 <Cale> novochar: If you use braces, you must use semicolons
19:28:57 <novochar> Oh, okay, I'll try that
19:29:00 <Cale> novochar: You can use semicolons without braces, but not the other way
19:29:08 * hackagebot control-monad-omega 0.3.1 - A breadth-first list monad.  http://hackage.haskell.org/package/control-monad-omega-0.3.1 (LukePalmer)
19:29:12 <chrisdone> cale: things like weather and informational things can just be written in vanilla haskell. i think the taskbar items could be taken from xmonad's usual api (the panel runs within the same process as xmonad)
19:29:28 <chrisdone> cale: what's a pager in this context?
19:30:05 <Cale> chrisdone: A thing which displays your desktops in some form and ideally shows what's running on them, but the important bit is it lets you switch desktops.
19:30:16 <Cale> (and shows you which you're on)
19:30:36 <Cale> I actually mostly use the keyboard to switch anyway, but it's nice to have some sense of location.
19:30:38 <chrisdone> ah, ok. right, that info is also available in xmonad's api
19:30:58 <chrisdone> the bit i'm not sure about is the notification area. i don't know how that works
19:30:59 <Cale> Enlightenment's old pager actually let you drag windows around in the pager
19:31:18 <Cale> and you could drag a window out of the pager onto your current desktop and it would appear where you dropped it
19:31:38 <Cale> (but it was larger than would fit in a panel)
19:32:09 <geekosaur> xfce4-panel minimalist? amazing what people think is minimalist these days
19:32:28 <Cale> geekosaur: Did you see my list of requirements ;)
19:32:46 <Twey> I have a project that uses Gloss.  I'd like to install this project into a clean sandbox.  However, when pulling in Gloss as a dependency on âcabal installâ, I'd like to pass --flags="GLFW -GLUT".  How can I do that?
19:33:24 <geekosaur> yes. most of that is in the xfce4 panel in fedora 19; less in the version that ships with linux mint
19:33:51 <dcoutts_> Twey: what's wrong with just using --flags=...  ?
19:33:57 <Cale> geekosaur: oh, okay, I was trying the mint version
19:34:41 <Twey> dcoutts_: I'm typing âcabal installâ to install my project into the sandbox; I don't have anywhere to pass the flags to Gloss
19:35:05 <Twey> Unless âcabal install --flags="GLFW -GLUT"â will pass those flags to everything that gets installed as a result of the command?
19:35:14 <dcoutts_> Twey: iirc, it passes them down to deps
19:35:21 <Twey> Oh, okay
19:35:28 * Twey tries
19:35:29 <geekosaur> Twey: or install gloss into the sandbox first, with those flags
19:36:05 <Twey> geekosaur: I can't figure out how to do that, either :Ã¾  âcabal install glossâ complains that it would have to break packages I have outside the sandbox
19:36:06 <Redz> is there a way to use a module with an ambiguous module name without deleting packages?
19:36:35 <Twey> Redz: Several; you can use -hide-package some_package, or you can use the package imports extension
19:36:38 <chrisdone> redz: yes, either hide the package that's not intended, or import "thepackage" TheModule with -XPackageeImports
19:37:12 <chrisdone> twey: i like how our suggestions lacked the detail in the former and latter parts, together making a complete answer
19:37:18 <Redz> thank you. :)
19:37:21 <Twey> Hehe
19:37:25 * dcoutts_ does not recommend package imports except for the case where you need to depend on both packages that export the same name
19:37:37 <Twey> dcoutts_: It did seem to pass it down; thanks!
19:37:46 <Cale> dcoutts_: Why is that?
19:38:01 <Cale> Is it somehow broken?
19:38:59 <chrisdone> i think probably because it's a bit of an anti-pattern outside of the specific both-packages use-case
19:39:19 <dcoutts_> Cale: we invented the feature just for making the base3/4 shim
19:39:26 <dcoutts_> it's not needed in other cases
19:40:02 <dcoutts_> and I have a gut feeling it's not good to use generally, though I don't have any killer arguments
19:40:48 <dcoutts_> one (admittedly minor) downside is that it's harder to migrate between impls if you fix the package name in the imports
19:41:58 <Twey> Arguably that's an upside: different implementations might not be compatible, so they should break when interchanged for the same reason as types with the same names
19:42:00 <chrisdone> it also encourages you to not really care much what packages are specified in your environment or cabal file, not noticing the problem
19:43:01 <Cale> chrisdone: To be honest, sometimes I'd love to be able to care a bit less about that :)
19:43:20 <chrisdone> cale: welcome to fp haskell center! </marketing>
19:43:34 <ReinH> heh
19:43:43 <Cale> But then sometimes even hierarchical modules still make me a bit sad
19:43:52 <chrisdone> yeah, me too
19:44:00 <Cale> What was so wrong with  import Set ?
19:44:34 <Cale> I didn't even have to qualify the import because the module was careful not to reuse Prelude names too.
19:44:49 <Cale> wow such module so import very nice
19:44:59 <chrisdone> "i'm making a scrobble library, i'm gonna call the module Scrobble" hackage: âWarning, unallocated top-level nameâ geez, thanks for the warning, Java
19:45:27 <Cale> Data.Control.Miscellaneous.Anything.MyVerySpecificModuleName
19:45:59 <chrisdone> Text.Blaze.Html.Renderer.Utf8
19:46:37 <Twey> Cale: At that point you might as well just have one big namespace, like in PHP
19:46:57 <chrisdone> twey: what's specifically wrong with that?
19:47:06 <chrisdone> package names have one big namespace
19:47:07 <Cale> Twey: Well, I like the last-resort ability to deal with namespacing issues sanely
19:47:21 <joelteon> yeah, but Data and Control are so generic they're meaningless
19:47:27 <joelteon> "Data: this module deals with data in some way"
19:47:27 <Cale> Twey: But on the same time, I wish modules would at least *try* to avoid stepping on each others' toes
19:47:33 <Cale> at the same time*
19:47:34 <Twey> chrisdone: Clashes; and to avoid clashes you introduce naming conventions, which are just a more limited version of namespaces
19:47:35 <joelteon> "Control: this module deals with functions or something"
19:48:09 <Twey> Cale: So would you advocate renaming Set.filter to setFilter, Map.filter to mapFilter, &c.?
19:48:22 <monochrom> CDC = Centre for Data Control :)
19:48:22 <Cale> I wouldn't mind it :)
19:48:27 <Twey> Or perhaps filter, removeIfNot, collander?
19:48:39 <Cale> lol, collander
19:48:47 <monochrom> um, I thought Set.filter was supposed to be Set.Filter.v
19:48:49 <chrisdone> here's the hackage module landscape as of 2010: https://gist.github.com/chrisdone/463423/raw/f8458d83b1a7cc26cdbf812747188993e50cd8a2/The+Haskell+module+landscape
19:48:51 <joelteon> I wish qualified was default.
19:48:54 <Cale> monochrom: haha
19:48:56 <Twey> Cale: But the only difference between Set.filter and setFilter is that Set.filter has language support so you can rename it
19:49:06 <joelteon> import Data.Set as S
19:49:07 <Cale> Twey: But you pay a price
19:49:24 <Cale> Now you need a second import line to not have to qualify the name of the type
19:49:54 <Twey> Cale: Yes, but that's to do with how Haskell handles imports, not to do with namespacing issues
19:50:23 <Cale> Whereas before I could just type import Set at the top of my module and use mapS, filterS etc. now I have  import qualified Data.Set as S; import Data.Set (Set)
19:51:08 <Twey> If we could re-export modules that would be a non-issue: you could âimport Setâ and have Set export the Set type, as well as the Set module
19:51:12 <Cale> I'm all in favour of other answers, I just think the direction we've taken is a bit strange.
19:51:46 <chrisdone> twey: i don't think the namespaces as-chosen avoid clashes really. libraries using their own package name namespace name works well, e.g. Blaze.* or Scrobble.*, but Control.*, Data.*, System.* are just nonsense
19:51:47 <triliyn> It would be interesting (but perhaps not ideal) if modules could declare whether a particular name is to be exported qualified by default or not
19:52:01 <Twey> chrisdone: Absolutely
19:52:07 <Twey> That's why we have to have PackageImports
19:52:36 <triliyn> So that you could have a Set module that exports a Set type and Set.filter
19:52:44 <Twey> The real solution is something like Java's package-naming convention, assigning responsibility for clashes to an external database of ownership
19:52:46 <chrisdone> import Time; import IO of ye olde haskell is so much saner =(
19:52:47 <Cale> base5 should abolish Control. and Data.
19:52:49 <Cale> :)
19:53:11 <Cale> and System too, yeah
19:53:37 <Cale> System at least makes some kind of minimal level of sense
19:53:43 <enthropy> Foreign
19:53:45 <enthropy> Numeric
19:53:47 <Cale> But it's unclear what the distinction between Control and Data is
19:54:21 <Twey> Or typed modules: âimport Functor (fmap â· (a â b) â f a â f b)â meaning âI'll accept any implementation of Functor that provides fmap with type (a â b) â f a â f b
19:54:24 <chrisdone> Text.* and Data.* tend to be interchangeable
19:54:42 <Twey> â
19:54:49 <Cale> Data.Text, Text.Data
19:54:52 <Cale> ;)
19:54:57 <chrisdone> twey: hehe, funky
19:55:43 <chrisdone> Language.Haskell.Exts.Parser
19:55:49 <Cale> Twey: I'd actually really like to have ML-style modules *just* to deal with the silliness surrounding Strict and Lazy ByteStrings and similar things like that
19:55:53 <chrisdone> i hate typing that
19:55:56 <triliyn> Twey: where is the f defined there?
19:56:03 <Twey> Cale: Yeah
19:56:12 <Cale> There are many other things which type classes are certainly better at
19:56:15 <Twey> triliyn: It's implicitly forall'd
19:56:37 <triliyn> So it has to be polymorphic?
19:56:43 <Twey> Agda-style modules would probably be good enough
19:56:48 <chrisdone> cale: yeah, strict/lazy bytestrings, texts, anything drives me doolally sometimes
19:56:49 <Twey> triliyn: Yep
19:57:23 <chrisdone> triliyn: what would it be otherwise, skolem?
19:58:20 <triliyn> chrisdone: well, the current fmap is not fully polymorphic in the functor
19:58:26 <chrisdone> sometimes i'm working on a function in which string, text and bytestring are all used, and both lazy and strict versions of text or bytestring
19:58:45 <chrisdone> so i have to import three extra lines for conversion functions
19:58:47 <triliyn> Because only certain type constructors of the correct kind have functor instances
19:59:27 <chrisdone> triliyn: oh you mean about the lack of class constraint, nod
19:59:37 <Twey> Oh, yes
19:59:39 <Twey> Sorry
19:59:46 <Twey> That was just me being four a.m.
20:00:15 <triliyn> okay, if it's not polymorphic that makes more sense o.o
20:00:42 <tippenein> how can I use getHomeDirectory with FilePath? like expandHome :: FilePath -> IO FilePath ?
20:00:56 <tippenein> getHomeDirectory </> filepath was my initial idea
20:01:16 <triliyn> Twey: would this work with Haskell's existing typeclass system or subsume it?
20:01:33 <Twey> import Functor (Functor â· (â â â) â â; fmap â· Functor f â (a â b) â f a â f b)
20:01:45 <Twey> triliyn: With, I would imagine
20:01:52 <chrisdone> twey: back in my day we got up four hours before we went to sleep to work in the mine, and pay 'mill owner fo' privilege of lerrin' us work there
20:01:57 <triliyn> ahhh, okay, I think I get it now
20:02:01 <Twey> Hehehe
20:02:58 <Twey> import Functor (Functor â· (â â â) â Constraint; fmap â· Functor f â (a â b) â f a â f b) -- oh, there's a Constraint kind
20:03:19 <triliyn> Right
20:03:56 <chrisdone> â¯(â â â)â¯ï¸µ â»ââ»
20:04:15 <Twey> chrisdone: What's that in response to?  :Ã¾
20:04:42 <triliyn> So would that import the typeclass definition or instances? And would instance importation work the same way as it does now? (Implicitly)
20:05:02 <chrisdone> i should go to bed =p
20:05:08 <chrisdone> ciao ã¾(ï¼¾âï¼¾)
20:05:12 <Twey> Adieux!
20:05:23 <triliyn> I think implicit instance importation would work... at least as well as it does now?
20:06:06 <Twey> triliyn: It imports the type of the class, nothing more (the fmap method is imported separately)
20:06:12 <Twey> Er, kind
20:06:28 <triliyn> ah, right
20:06:41 <Twey> triliyn: I guess instances would work as they currently do, yes, purely in the interests of expanding on a single idea rather than single-handedly redesigning Haskell :Ã¾
20:06:59 <triliyn> hehe, I suppose that is sensible!
20:07:13 <triliyn> And yeah, I think I understand how this would work now
20:07:17 <Twey> (I'm not really happy with how second-class instances are, but that's a totally different discussion)
20:08:27 <Twey> Also you should be able to infer a lot of this the normal way, so you could just type âimport Functorâ
20:08:47 <triliyn> hmmm
20:09:07 <triliyn> Where Functor here is the module, not the typeclass?
20:09:12 <Twey> Yes
20:09:18 <triliyn> In which case it basically works like our current import system
20:09:49 <Twey> Right, except the types of the names used are inferred from the code and used to select the module, rather than the other way around
20:10:05 <Twey> â¦ wait, never mind, that's stupid
20:10:30 <Twey> You'd have to import qualified or give an explicit list of names, or you don't know which names come from the module :Ã¾
20:10:43 <Twey> import Functor (Functor, fmap) then
20:26:27 <jle`> is there a word contrasting something like Maybe Int from Int?  Something like a type with a type constructor?  I would say 'derived' type (derived from applying the type-level function Maybe to the type Int) but i'm sure that that word is already used
20:26:56 <Cale> A type application?
20:27:54 <jle`> something that would also apply in ocaml to contrast `int` from `int maybe`
20:28:03 <jle`> i think that works
20:28:39 <Cale> http://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/Language-Haskell-TH-Syntax.html#t:Type :)
20:28:59 <scooty-puff> is there anything along the lines of iter :: Monad m => f a -> (a -> m b -> m c) -> m (), looking something like iter xs $ \ x next -> ...; next?
20:29:04 <scooty-puff> idiom, type class, whatever
20:29:39 <scooty-puff> i recall the syb stuff had something where you could return True (or maybe False..) to have it stop
20:29:42 <Cale> scooty-puff: I'm not sure what that type is meant to mean
20:30:00 <shlevy> How do I do where clauses in do notation? http://lpaste.net/98220 gives me an indentation error
20:30:17 <NemesisD> any of you guys use doctest?
20:30:26 <Cale> You don't. Where clauses are part of the syntax of declarations, not expressions.
20:30:30 <scooty-puff> the idea is that it will be passed the first element and an action to continue
20:30:53 <Twey> scooty-puff: Shouldn't that be âm aâ?
20:30:55 <roboguy_> scooty-puff: is that f supposed to be an m?
20:31:06 <Cale> shlevy: However, the only reason your thing is failing is that the cases aren't indented far enough
20:31:16 <roboguy_> scooty-puff: also, where does the m b come from?
20:31:18 <scooty-puff> the first one is not - would be something like class Iter f where iterM_ :: f a -> ...
20:31:20 <Cale> shlevy: They have to start in a deeper column than the f in foo
20:31:32 <shlevy> oh :D
20:31:37 <scooty-puff> nothing after next would be sequenced
20:31:41 <shlevy> I'll learn these indentation rules some day
20:31:42 <scooty-puff> :t callCC
20:31:42 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
20:32:10 <scooty-puff> "sequenced" is probably not the right word..
20:32:12 <Cale> scooty-puff: I was thinking of recommending callCC
20:32:41 <Cale> scooty-puff: It kind of sounds like you want a combination of callCC and forM/mapM
20:33:04 <scooty-puff> yeah - the only reason is because it would be involving ReaderT - would want local (...) next
20:33:05 <jle`> shlevy: i like putting my where-stuff on a new line after the where
20:33:31 <scooty-puff> though that reminds me of how ContT turns Reader in to State, or maybe the opposite?
20:34:27 <Cale> @mtl ContT r Reader a
20:34:27 <lambdabot> Maybe you meant: url unmtl pl msg
20:34:30 <Cale> @unmtl ContT r Reader a
20:34:30 <lambdabot> Plugin `unmtl' failed with: `Reader r' is not applied to enough arguments, giving `/\A. r -> A'
20:34:44 <Cale> @unmtl ContT z (Reader r) a
20:34:44 <lambdabot> (a -> (Reader r) z) -> (Reader r) z
20:35:01 <Cale> @unmtl ContT z ((->) r) a
20:35:01 <lambdabot> (a -> ((->) r) z) -> ((->) r) z
20:35:05 <triliyn> Hey, I recognize that /\ now! It's a type lambda!
20:35:11 <Cale> triliyn: yeah
20:35:20 <scooty-puff> (a -> r -> z) -> r -> z
20:35:27 <triliyn> It turns out reading ancient GHC papers is useful after all! :D
20:35:42 <Cale> Yeah, I'm not sure that counts as State exactly :)
20:35:57 <Cale> triliyn: System F is pretty nice
20:36:02 <scooty-puff> @unmtl ContT z (State s) a
20:36:03 <lambdabot> (a -> (State s) z) -> (State s) z
20:37:05 <scooty-puff> i'm forgetting the lambda encoding of tuples..  (a -> (s, a)) == (a -> ((s -> a -> r) -> r))?
20:37:26 <Cale> State s a ~= s -> (s,a)
20:37:46 <Cale> oh
20:37:51 <Cale> I see what you mean
20:38:00 <scooty-puff> i probably got the terminology wrong..
20:38:01 <triliyn> What is the relationship between System F and Core? Are they different names for the same thing, or is System F a newer successor, or is Core a simplified fiction used in papers and System F is the real thing?
20:38:18 <Cale> scooty-puff: no, that's reasonable, I just missed your point. Yes, that's right.
20:38:27 <triliyn> (as opposed to an older successor, which I suppose is not complete nonsense but is kind of unlikely...)
20:39:06 <Cale> triliyn: System F is simple and not really what's used. Core is one of GHC's intermediate languages.
20:39:38 <triliyn> oh, right
20:39:51 <triliyn> System F is like the theoretical basis and Core is kind of an adjustment of that
20:40:04 <Cale> yeah
20:40:09 <scooty-puff> so from ContT z (Reader r) a, (a -> r -> z) -> r -> z, where (a -> s -> r) -> s -> z, ((a, s) -> r) -> s -> r, think i'm missing a step, but feels pretty much there
20:40:10 <triliyn> There was a paragraph about that toward the beginning of the most recent paper I read
20:40:23 <Cale> There's actually much fancier variations of System F which come closer to explaining what Core is
20:40:28 <triliyn> (Which had the most delightful title: Secrets of the Inliner)
20:41:34 <Cale> There's what's called System FC, which adds constraints, and type equalities
20:41:54 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/tldi22-sulzmann-with-appendix.pdf
20:42:06 <triliyn> Yeah, I was reading about that forever ago in the context of datakinds and dependent kinding
20:42:22 <triliyn> I think I still have that tab open
20:42:25 <triliyn> http://cis.upenn.edu/~justhsu/docs/nokinds.pdf
20:42:49 <scooty-puff> what i'm really thinking from earlier is: forWithDepth_ :: Monad m => f a -> (a -> m b -> m c) -> m ()
20:43:03 <Cale> that page 6
20:43:08 <scooty-puff> forWithDepth tree $ \ elem down -> do stuff with elem; down
20:43:18 <scooty-puff> or something..
20:43:37 <triliyn> Wow, I don't think I'd even reached page 6
20:43:40 <Cale> wow, many rule, so logic, much derivation, such types
20:44:32 <Clint> how can i create a mapping between a sum type and a bunch of members of a typeclass without using an existential?
20:44:37 <Cale> I love the fact that they even have somehow needed to subscript the turnstiles
20:45:07 <Cale> Clint: I'm not sure what you mean
20:45:19 <Cale> Clint: Can you elaborate what you're trying to do?
20:46:04 <Cale> scooty-puff: The b and c in that type seem suspicious
20:46:52 <Cale> scooty-puff: Though maybe...
20:47:02 <scooty-puff> the m c i'm assuming - _ convention, and the m b i'm hoping will end up happening, if similar enough to callCC, though i have not implemented it yet
20:47:30 <scooty-puff> depthFirstSearch_ dag $ \ elem down -> ...; down
20:47:51 <scooty-puff> the use case i have is i need to provide some information to pointed to nodes, but not adjacent nodes
20:47:59 <scooty-puff> but i do need to visit all nodes
20:48:06 <Clint> Cale: i have a type which names a blockcipher, and i want to be able to substitute the equivalent of (undefined :: BlockCipher a => a) for each option
20:48:13 <Cale> scooty-puff: Is this thing never supposed to finish?
20:48:29 <Cale> scooty-puff: Or I guess if it finishes, you don't use the result
20:48:39 <NemesisD> does anyone know how to get doctest to load the package its testing?
20:48:57 <scooty-puff> correct - it doesn't use the reslt
20:48:59 <scooty-puff> *result
20:49:02 <NemesisD> is it a bad idea for a test suite in cabal to require the package as a dependency?
20:49:06 <scooty-puff> one that would would look like:
20:49:28 <scooty-puff> hmm
20:49:36 <Cale> Clint: Maybe you could put your code on lpaste or something?
20:50:09 <dcoutts_> NemesisD: no that's fine
20:51:03 <Clint> Cale: http://lpaste.net/98221
20:51:10 <Clint> where'd the bot go
20:52:01 <Cale> I don't know what's up with the lpaste bot
20:52:20 <NemesisD> dcoutts_: so i'm trying to get this working in ghci: i've got a package structure like src/Data/PHash.hs. but if i do ghci -isrc. import Data.PHash, it can't find the module
20:52:32 <NemesisD> dcoutts_: shouldn't gchi be able to find that file interactively?
20:53:09 <dcoutts_> NemesisD: you need to load the file
20:53:45 <dcoutts_> import just changes what is in scope, it does not change the set of loaded modules
20:53:50 <dcoutts_> use :l
20:54:16 <Cale> Clint: Well, I'm not really sure, but perhaps you'd like BlockCipher to be a subclass of Typeable?
20:55:01 <Clint> Cale: it's not my type
20:55:04 <dcoutts_> NemesisD: the slightly confusing thing is that modules from packages are considered always loaded so that's why you can import or :m them at any time
20:55:04 <NemesisD> ohh i get it now. so now to translate this to doctest
20:55:25 <Cale> Clint: oh, whose type class is that?
20:55:37 <Clint> Cale: http://hackage.haskell.org/package/crypto-cipher-types-0.0.9/docs/Crypto-Cipher-Types.html
20:55:56 <triliyn> Can't you write typeclass instances without changing the definition of the type?
20:56:10 <triliyn> Or does Typeable need to be derived or something?
20:56:12 <Cale> triliyn: You can't make some class a subclass of another
20:56:15 <dcoutts_> NemesisD: but local source files have to be loaded with :load or :add, and after that you can fiddle with what is in scope at any moment using :m or import
20:56:15 <NemesisD> dcoutts_: wooo. what a misleading error. the error seems to be solved because i forgot to add a shared library flag
20:56:25 <triliyn> oh, it's a class, not a type
20:56:28 <Cale> triliyn: For that, you'd have to mess with the declaration of the class
20:56:28 <triliyn> I see
20:57:49 <Cale> Clint: Is it really okay to be using undefined there?
20:58:04 <Cale> It looks like you're meant to get a value of the cipher type using cipherInit
21:00:17 <Cale> I guess in many cases you'd expect to be able to get the blockSize from the instance without passing in a legitimate value of the cipher type.
21:01:55 <Clint> Cale: right, i was for some reason thinking that there were multiple BlockCipher methods that just threw away the cipher
21:05:10 <NemesisD> oh man doctest is sweet
21:05:36 <Clint> Cale: oh, it's cipherName and cipherKeySize from the superclass
21:11:30 <shiona> someone posted this earlier: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity . I'm not sure I understand the "Purity challenged?" section.
21:11:59 <shiona> To me the author seems to say "because the source parses deterministically, the program is pure"
21:12:22 <shiona> but that would make pretty much any programming language pure
21:12:46 <shiona> what am I missing
21:13:40 <Twey> shiona: Evaluation is pure, execution isn't
21:13:48 <roboguy_> shiona: he does seem to imply that 'evaluation' (as opposed to 'execution') doesn't have the halting problem, which isn't true (unless I'm misreading it)
21:14:08 <Twey> Eh?
21:14:23 <Twey> I don't know where the halting problem comes into it
21:14:51 <shiona> but isn't saying "because evaluation of haskell source is pure, haskell IO is pure" as valid as "because evaluation of C source is pure, C IO is pure" ?
21:14:57 <carter> shiona: sounds like its a terribly written blog post
21:14:59 <Twey> All it's saying is that you purely, deterministically build up an IO value, which value then represents an impure program that can be executed
21:15:01 <carter> like most blog posts
21:15:04 <carter> :)
21:15:33 <shiona> carter: I usually take blog posts with a huge grain of salt, but it was posted here and people here seem to know quite a bit more about haskell than I do
21:15:34 <roboguy_> Twey: he links to the wikipedia page on the halting problem
21:15:39 <Twey> shiona: No, that's not what it's saying (though you're dangerously close to a Conal Elliott post on the topic :Ã¾).
21:15:56 <carter> halting problem has nothing to do with io :)
21:16:03 <roboguy_> carter: exactly
21:16:18 <Twey> shiona: A better analogy is the C preprocessor.  The C preprocessor is pure (well, almost), and it purely builds a C program, which is impure
21:16:23 <roboguy_> so that seems misleading and possibly sends an incorrect message
21:16:35 <johnw_> "because evaluation of haskell source is pure, haskell IO is pure" -- that doesn't really make sense to me.  Evaluation of a function returning IO yields an action whose execution has side-effects in the real world, so while the evaluation is pure, the execution is not -- if I know what the author meant by "pure"
21:17:01 <Twey> Except in Haskell we write in the âpreprocessorâ most of the time, and our impure program can refer back to âpreprocessorâ functions
21:17:08 <shiona> johnw_: that's along the lines I thought
21:17:55 <carter> shiona: just 'cause a link is posted to irc #haskell doens't mean its good
21:18:01 <Twey> Am I reading a different article here?
21:18:05 <shiona> carter: true
21:18:13 <Twey> I see no mention of the halting problem, and I can't see johnw_'s quote either
21:18:29 <carter> huh
21:18:31 <carter> oh
21:18:40 <shiona> johns quote was from me, it was my interpretation of the article
21:18:46 <Twey> Ah
21:18:48 <roboguy_> Twey: in the 'Purity Challenged' section the phrase 'potentially unpredictable' links to the halting problem wikipedia page
21:19:08 <Twey> Oh, right
21:19:53 <Twey> It doesn't actually say pure code halts, but I guess I can understand why one might interpret it that way
21:20:13 <roboguy_> to me it seems like a bad (or, actually, incorrect) example of the difference between purity and impurity. but I could be misreading it
21:20:19 <shiona> but to me "main will always evaluate to the exact same computation data structure" sounds like deterministic compilation
21:20:20 <Twey> Also that's a very misleading use of âunpredictableâ given the context :Ã¾
21:20:43 <Twey> shiona: That's a part of it, to be sure
21:20:50 <shiona> roboguy_: that was what I hoped it was
21:21:05 <roboguy_> shiona: what do you mean?
21:21:16 <Twey> shiona: The main difference being that the âcompiledâ program can call back into the deterministic part
21:21:17 <tautologico> but main WILL always evaluate to the exact same computation structure
21:21:35 <tautologico> the structure, when executed, may have different results
21:21:54 <Twey> shiona: http://conal.net/blog/posts/the-c-language-is-purely-functional
21:22:33 <shiona> Now you're just messing with me :D
21:22:54 <Twey> :Ã¾
21:23:19 <mm_freak> it's sad that most articles that explain the benefits of haskell's IO fail to explain that one of its main benefits is first class actions
21:23:27 <carter> no yeah
21:23:29 <carter> *yeah
21:23:56 <Twey> shiona: If you understand that article, you understand how Haskell IO works, and how purity applies
21:24:06 <carter> shiona: just write cool code :)
21:24:11 <Twey> (though the conclusion is a bit tongue-in-cheek, obviously)
21:24:19 <Twey> mm_freak: Agreed
21:25:00 <mm_freak> mapM (blah >=> blubb)
21:25:16 <triliyn> Speaking of IO, is unsafePerformIO a GHC thing or is it part of Haskell98 or is there some third alternative I'm failing to consider?
21:25:28 <mm_freak> and of course algebraic reasoning:  mapM (f >=> g) = mapM f >=> mapM g
21:25:52 <shiona> Twey: in that article couldn't you just say that you can evaluate a value of type C to B, and ADT that represents a list of cpu instructions. Still being pure?
21:25:58 <mm_freak> well, that one isn't true =/
21:25:59 <blaenk> what's the preferred package for json encoding/decoding. aeson?
21:26:06 <mm_freak> blaenk: pretty much
21:26:11 <blaenk> mm_freak: thanks
21:27:33 <shiona> :DD love the kleene star joke in there
21:28:10 <Twey> shiona: Yep
21:28:25 <Twey> shiona: But none of these things are *executing* the code yet.
21:28:37 <shiona> ok, so I got it all right from the beginning
21:28:38 <shiona> thanks!
21:28:47 <Twey> No problem âº
21:29:32 <Twey> triliyn: I think we investigated this a while back and came to the conclusion that it's not standard
21:30:08 <carter> Twey: it hink its ghc only
21:30:18 <carter> otoh, its handy ifyou're careful
21:30:22 <carter> and its pretty safe
21:30:27 <carter> unsafeINLINEIO is the scary one
21:31:31 <ReinH> carter: I'mma let you finish but reallyUnsafePtrEquality#
21:31:37 <ReinH> it's right there in the name
21:31:38 <carter> ReinH: lemme top that
21:31:43 <carter> i have someting worse that that
21:31:56 <carter> https://gist.github.com/cartazio/c0b0f624ff0ba7489085
21:32:05 <carter> i cast arbitrary values to Int
21:32:07 <ReinH> but is it in GHC's primitives module? :p
21:32:37 <carter> you can write reallyUnsafePtr a b =   (asInt a) == (asInt b)
21:32:41 <carter> :p
21:32:43 <carter> ReinH: :)
21:32:54 <ReinH> carter: yeah saw the comment
21:32:56 <ReinH> well played
21:33:33 <carter> it also works fine when compiled, but makes ghci crash hard
21:33:35 <carter> Bus Error
21:33:50 <carter> idk if reallyUnsafePtrEquality# makes ghci crash
21:35:51 <ReinH> find out
21:35:52 <ReinH> for science
21:36:27 <triliyn> :t reallyUnsafePtrEquality#
21:36:28 <lambdabot> Not in scope: `reallyUnsafePtrEquality#'
21:36:38 <triliyn> What would you need to import to bring it into scope?
21:36:44 <ReinH> GHC.Prim
21:36:57 <ReinH> triliyn: you could also hoogle it ;)
21:37:27 <triliyn> hmmm... I need the MagicHash thing to invoke the name
21:37:35 <triliyn> I guess that would be ghci -XMagicHash?
21:37:50 <triliyn> Or is there a way I can turn it on from a running ghci?
21:38:50 <ReinH> There is a way. :set something or other.
21:38:59 <Twey> :set -XMagicHash
21:39:21 <ReinH> righto
21:39:51 <triliyn> Prelude GHC.Prim> reallyUnsafePtrEquality# [1,2] [1,2]
21:39:52 <triliyn> <interactive>:4:1:
21:39:52 <triliyn>     Couldn't match kind `*' against `#'
21:39:52 <triliyn>     Kind incompatibility when matching types:
21:39:52 <triliyn>       a0 :: *
21:39:52 <triliyn>       Int# :: #
21:39:54 <triliyn>     In the first argument of `print', namely `it'
21:39:56 <triliyn>     In a stmt of an interactive GHCi command: print it
21:39:58 <triliyn> Prelude GHC.Prim>
21:40:15 <triliyn> Am I doing something wrong or do you need to dismantle more safeguards?
21:40:20 <roboguy_> triliyn: you need to give it an unboxed type
21:40:30 <roboguy_> *an unboxed value
21:40:34 <triliyn> ah, right, lists have to be boxed
21:40:45 <roboguy_> triliyn: # is the kind of unboxed types
21:41:25 <fabe> Hi can you alias a type definition in haskell? I have some rather verbose things like "Vector (lots of crap ...)" that I would like to shorten
21:41:38 <roboguy_> fabe: yep, with "type"
21:41:48 <roboguy_> type TypeSynonym = ...
21:41:53 <fabe> to easy :D
21:41:59 <fabe> thx
21:42:23 <triliyn> hmmm, integer literals don't seem to be able to produce unboxed ints, and I read somewhere that 1# should work but it doesn't seem to...
21:42:36 <triliyn> Wait, it does work
21:43:24 <jle`> shiona: hi :) the blog post is actually pretty badly written
21:43:50 <shiona> jle`: good to know
21:43:51 <triliyn> But maybe the arguments are not supposed to be unboxed? It does say a0 :: *
21:43:57 <jle`> but someone earlier mentioned cpp
21:44:03 <jle`> and that is the best analogy
21:44:08 <jle`> cpp generates a C source code
21:44:11 <triliyn> Except that reallyUnsafePtrEquality 1 1 doesn't work either
21:44:31 <Twey> Except that running C can't call CPP macros, but running IO code can call Haskell functions.
21:44:52 <jle`> it is mostly to indicate that there is a difference between evaluation and execution
21:44:56 <triliyn> oh wait
21:45:02 <triliyn> It returns an Int#
21:45:09 <triliyn> And maybe you can't pass that to show?
21:45:22 <jle`> shiona: ghc will turn the IO object into assembly code, or whatever target you specify
21:45:29 <jle`> this process is the 'pure' part
21:45:33 <jle`> (barring certain exceptions)
21:45:36 <roboguy_> triliyn: you can do this showUnboxedInt n = (show $ I# n) ++ "#"
21:45:41 <jle`> your computer then executes the assembly that ghc generates
21:45:47 <roboguy_> maybe
21:45:48 <jle`> this is the execution/impure part
21:46:04 <jle`> so yes, it can be said that C/c compiler works a similar way
21:46:13 <jle`> however, Haskell is very careful to conceptually separate these two parts
21:46:27 <jle`> whereas in C, evaluation and execution are somewhat muddled together
21:46:51 <jle`> there is a cute joke article on this http://conal.net/blog/posts/the-c-language-is-purely-functional
21:47:04 <roboguy_> triliyn: ah, you have to putStrLn the result of that because ghci doesn't like evaluating expressions that have an unboxed type at the top level
21:47:05 <jle`> although i do not think the author was joking
21:47:08 <triliyn> ghci> I# (reallyUnsafePtrEquality# [1,2] [1,2])
21:47:09 <triliyn> 0
21:47:09 <triliyn> ghci>
21:47:10 <triliyn> aha!
21:47:17 <shiona> googling the subject a paper pops up, that sums purity up as non-dependancy of function execution
21:47:39 <shiona> ... order
21:47:45 <jle`> it is 'kind of the same' as for C source code, but someone mentioned earlier that this way gets you things like first-class instruction data structures
21:48:06 <jle`> purity in this context refers to lack of side-effects and functions always retuning the same thing every time they are called
21:48:14 <shiona> a language that doesn't depend on its functions being executed would be rather esoteric
21:49:32 <shiona> jle`: yes, and that IO actions aren't functions as such
21:49:51 <jle`> shiona: IO actions *represent* impure actions
21:50:00 <jle`> however, the functions that return the actions themselves are all pure
21:50:06 <shiona> yea
21:50:11 <jle`> for example, putStrLn :: String -> IO () is a pure function
21:50:24 <jle`> it represents the idea of an impure action that would be run by a computer
21:50:31 <jle`> or a web browser, or a person, etc.
21:50:35 <shiona> I think I've got it, thanks to these blog posts
21:51:01 <shiona> and most of all because that one post was so bad it made me think
21:51:02 <jle`> it's very easy to mix this up with things like C and I had to struggle with how to explain this when i was writing the post admittedly
21:51:18 <jle`> this debate comes up very often
21:51:53 <jle`> the main thing to remember is that IO actions are pure *objects*/functions that *represent* impure actions, and that Haskell allows us to purely chain these actions together
21:52:01 <jle`> so it's kind of like a macro language in that sense
21:52:54 <jle`> after all ghc directly translates any given IO object into C--/Assembly so there is basically a one-to-one correspondence
21:53:43 <ReinH> jle`: Best to say that they are pure values.
21:54:16 <triliyn> Is C-- an actual thing or is it just a silly name for something else?
21:54:23 <ReinH> triliyn: yes, it's actually a thing
21:54:26 <tautologico> it's a thing
21:54:30 * hackagebot commsec-keyexchange 0.3.3 - Key agreement for commsec.  http://hackage.haskell.org/package/commsec-keyexchange-0.3.3 (ThomasDuBuisson)
21:54:38 <jle`> C-- is mostly a limited flavor of C
21:54:45 <tautologico> http://www.cminusminus.org/
21:55:29 <roboguy_> that's a different C-- than ghc uses, right?
21:56:05 <lispy> roboguy_: I think they were the same at one point, but the c--.org stuff got forgotten maybe?
21:56:40 <lispy> I think there was a vision at some earlier point to make c-- into a standalone language. In the end, I think only ghc made serious use of it.
21:57:34 <tautologico> the original goals are similar to what LLVM has become
21:58:52 <triliyn> hmm, I see
21:59:09 <jle`> roboguy_, shiona: thanks for pointing out the fallacy.  i was mostly embarassingly mixing up non-determination in relation to the state of the world being unpredictable with computational non-determination. removed all mention!
21:59:26 <jle`> non-determinancy?
22:00:08 <tautologico> non-termination?
22:00:32 <jle`> the inability to determine termination
22:00:35 <tautologico> non-determinism?
22:00:47 <Cale> http://www.cminusminus.org/c-downloads/ has a list of projects which are using the standalone C-- implementation
22:01:54 <jle`> undecidable-ness?
22:02:30 <roboguy_> jle`: sure! other than that, skimming through it, it looks like you illustrate the difference between IO actions and pure functions pretty well
22:03:04 <tautologico> undecidability
22:03:26 <tautologico> (or non-decidability)
22:04:05 <jle`> oh that's perfect (-ish)
22:04:31 <jle`> ty
22:04:51 <tautologico> when I was learning about monads and IO it took some time to me to understand that IO a was a pure value
22:05:22 <jle`> yeah there is a commonly passed around idiom is that we just 'tag' functions that are impure with IO, so impure functions and pure functions are the same, but we add an IO before the type
22:05:25 <tautologico> i.e. the difference between an action and a value describing the action
22:05:50 <jle`> as if purity and impurity were built into the language
22:06:10 <jle`> (but it's not)
22:07:17 <jle`> and that IO is just like an inverse analogy to const in C/C++
22:11:53 <Cale> tautologico: also, I think it's confusing sometimes to make a big deal out of the fact that IO happens to be a monad. Sure, its monad structure is important, but the much bigger deal is that IO actions are values.
22:12:27 <Cale> (That's what really rescues the purity of evaluation)
22:12:48 <Cale> The monad bit just says something about how we're allowed to glue those values together
22:13:31 <tautologico> Cale: yeah, it may emphasize the wrong things... that's why initially I wondered how could the language still be pure, and this was only solved by learning that IO things are pure values
22:14:41 <zRecursive> except you lift IO ?
22:15:44 <jle`> yeah, knowing that IO is a monad actually does not help you at all to understand IO in haskell
22:15:58 <jle`> its monadness offers more or less absolutely no insight
22:16:04 <jle`> more or less absolutely. yup.
22:16:15 <Jesin> it's much more important to understand *why* it's a monad
22:17:10 <zRecursive> IO is pure if you donot touch it. Once touched, IO is not pure ?
22:17:32 <jle`> how can one that is impure become pure?
22:17:51 <shiona> it doesn't
22:17:57 <zRecursive> pure means "same input gets same output"
22:18:34 <Jesin> zRecursive: IO is pure (disallowing unsafePerformIO, which is called "unsafe" because it breaks the language)
22:19:20 <zRecursive> Jesin: with monad. IO is pure
22:19:43 <Jesin> but, that is because the "input" provided via file-reading and stdin is not "input to the evaluator"
22:21:38 <Jesin> zRecursive: (putStrLn "Hello, World!") is a value of type (IO ())
22:22:24 <Jesin> furthermore, getLine is a value of type (IO String)
22:22:26 <zRecursive> it is pure before you do computation
22:23:12 <zRecursive> Once evaluated, who knows what will happen ? then NOT pure ...
22:23:50 <Jesin> zRecursive: no, it is pure even when evaluated, it is not pure when EXECUTED
22:23:54 <zRecursive> :t randomRIO
22:23:56 <lambdabot> Random a => (a, a) -> IO a
22:24:41 <zRecursive> randomRIO is pure
22:25:01 <Jesin> at least until executed
22:25:05 <Jesin> :t getLine
22:25:06 <lambdabot> IO String
22:25:09 <Jesin> getLine is pure
22:25:14 <zRecursive> sure
22:29:20 <joelteon> let f = getLine in do { f; f; f; f }
22:29:34 * hackagebot text 1.1.0.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-1.1.0.0 (BryanOSullivan)
22:29:36 * hackagebot aeson 0.7.0.0 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.7.0.0 (BryanOSullivan)
22:31:32 <Kaidelong> haskell is a pure language that can't do any IO of its own but can generate programs that can do IO
22:31:38 <Kaidelong> as its single side effect
22:31:40 <Jesin> While Haskell is purely functional, it is still possible to write Haskell in an imperative style, for example if all of your functions are (a -> IO b) or similar
22:31:41 <Kaidelong> that's kind of how I think of it
22:31:42 <triliyn> http://lpaste.net/98222 this is a nice toy program I came up with to show the difference between evaluation and execution
22:31:59 <Jesin> or (a -> State s b), etc
22:32:13 <Cale> Haskell evaluation can't have effects, but execution of IO actions does.
22:32:19 <Cale> (and that's part of what Haskell is)
22:32:26 <Jesin> ^ yeah that
22:33:07 <Kaidelong> in practice if haskell really did work like that unsafePerformIO wouldn't do anything but it provides a good explanation of what IO does and why it is useful to encapsulate IO even in languages that aren't pure
22:33:27 <Kaidelong> (well it would allow the compiler to reference things in the environment I guess)
22:33:46 <Cale> hm?
22:34:25 <shiona> I'm not sure how much work has been done, but at least this paper from 1998 starts off by shooting a few definitions of purity down and then proposes its own. I would guess we still don't have a formal definition people agree on
22:34:35 <Kaidelong> with an IO monad you have pure functions that work over computer programs, which are a very nice abstraction and it's nice to conceptually be able to represent an external program as a wrapped type in your language
22:34:35 <Jesin> Kaidelong: unsafePerformIO doesn't have to do anything.
22:34:53 <Cale> unsafePerformIO is a hook in the evaluator which allows evaluation to cause the execution of an IO action
22:34:56 <Jesin> I'm pretty sure the standard doesn't mandate any behavior for it.
22:35:17 <Jesin> (am I correct?)
22:35:20 <triliyn> I just asked about this recently, but I think unsafePerformIO is a GHC-specific thing that only works in GHC's (somewhat hacky) IO system
22:35:29 <Jesin> alright then
22:35:36 <Cale> i.e. when unsafePerformIO x is evaluated, the IO action x is executed, and the result of that execution is the result of the evaluation.
22:35:44 <joelteon> all the compilers' IO systems are hacky
22:36:11 <triliyn> joelteon: well, GHC's "RealWorld" thing is particularly hacky from what I've heard
22:36:19 <Cale> unsafePerformIO is part of the FFI spec
22:36:25 <triliyn> oh, is it?
22:36:28 <Cale> and hence it's part of the standard now
22:36:35 <Jesin> D:
22:36:36 <Jesin> what
22:36:59 <Jesin> that's unfortunate
22:37:07 <Jesin> I was hoping it wouldn't be necessary
22:37:22 <Kaidelong> windows powershell cmdlets kind of capture the nice thing about typed IO
22:37:22 <Cale> That doesn't mean you have to treat it as "standard Haskell". It's a low-level hook which exists for low-level purposes.
22:37:25 <triliyn> Don't you need GHC-specific extensions to use it safely? Or are other compilers expected to provide extensions that can also make it work?
22:37:41 <BlankVerse_> is it possible to make a cabal sandbox some sort of "default" so that all ghc invocation uses a particular user-defined package.conf
22:37:57 <BlankVerse_> by writing some env variable or ghc config?
22:37:59 <Cale> triliyn: Well, you're only meant to apply it to IO actions whose execution doesn't cause any visible effects.
22:38:04 <Jesin> ... I suppose if you want to enable people to write Haskell wrappers for arbitrary effectful foreign libraries, you'd have to standardize something like that.
22:38:05 <triliyn> Powershell looks interesting and sounds much nicer than the stringy unix shells
22:38:17 <triliyn> I haven't been able to find a nice online source for learning it though =/
22:38:17 <Cale> Of course, "visible effects" is hard to define precisely.
22:38:30 <Kaidelong> triliyn: try using the powershell ISE
22:38:38 <Kaidelong> that's how I finally started using it
22:38:43 <Kaidelong> the ISE makes the language discoverable
22:38:56 <Jesin> it'd be easy to specify unsafePerformIO . return = id
22:39:06 <Jesin> what exactly is specified?
22:39:08 <triliyn> hmmm, that might be nice
22:39:20 <triliyn> Windows with the standard command prompt is terrible
22:39:38 <Kaidelong> that's why WinGHCi exists after all
22:39:42 <dv-> windows is terrible
22:40:19 <lispy> BlankVerse_: I don't think so. I think tools like hsenv are geared more towards that use case than cabal sandboxes.
22:40:25 <Cale> Jesin: not a whole lot. Since the manner in which evaluation proceeds is unspecified, it's hard to ascribe precise semantics to unsafePerformIO.
22:40:48 <lispy> BlankVerse_: For example, I've noticed that cabal looks in the current directory for the cabal.sandbox.config. So that makes it harder to have a global sandbox.
22:41:05 <Jesin> Cale: yeah I'm hoping not a lot is specified...  I'm curious what is.  >_>
22:41:20 <Kaidelong> dv-: Haskell development on windows is terrible, but short of religion it's hard to say "OS is better than OS" at this point except when talking about specific aspects
22:41:38 * lispy does Haskell on windows
22:41:58 <lispy> Kaidelong: main thing to avoid are libraries that have crappy C deps that you can't satisfy on windows.
22:42:02 <triliyn> Really the main annoying thing about windows is the lack of a good package manager
22:42:22 <triliyn> You can find third-party repos on almost every linux distribution for almost anything you might want to install
22:42:33 <lispy> Kaidelong: all the othre problems I've encountered on windows have reasonable workarounds.
22:42:45 <Cale> Oh, that's interesting
22:42:46 * lispy is looking at you UTF-8 bugs
22:42:55 <Cale> unsafePerformIO was in the original FFI spec
22:43:03 <triliyn> There are a few fragmented attemps at Windows package managing things but they're not generally very good
22:43:06 <Cale> But that section isn't in Haskell 2010
22:43:18 <zRecursive> Both *linux and *bsd are free
22:43:21 <triliyn> Also, most open-source software development stuff is aimed at Linux
22:43:28 <Kaidelong> triliyn: the lastest incarnation of windows store is probably here to stay
22:43:28 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html -- the original FFI specification
22:43:38 <triliyn> Which means it requires additional finesse to manipulate on windows
22:43:45 <Cale> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1690008.6 -- the corresponding part of H2010
22:43:47 <Kaidelong> triliyn: MSI also survived, which is a kind of rpm-ish package manager
22:44:13 <triliyn> Kaidelong: hmmm, windows store is an interesting point I guess... I'm on Windows 7 so I haven't seen it
22:44:37 <Cale> HOWEVER, the H2010 spec still lets you import C functions at non-IO types
22:44:37 <Kaidelong> there was some form of the windows store all the way back to at least windows me
22:44:39 <triliyn> I'm assuming it's not as good for open-source stuff as most linux package managers are
22:44:51 <Cale> Which implicitly unsafePerformIO's them
22:45:03 <triliyn> hmm, I hadn't heard of it
22:45:09 <zRecursive> :t unsafePerformIO
22:45:09 <lambdabot> Not in scope: `unsafePerformIO'
22:45:28 <Cale> unsafePerformIO :: IO a -> a
22:45:33 <Kaidelong> triliyn: depends on your values, if you like slackware's approach to package management which aims for robustness over automation, then MSI is more of the sort of thing you want. If you want something that breaks easily but automates a lot of things then you want something more like portage
22:46:23 <Cale> "A static function can be of any foreign type; in particular, the result type may or may not be in the IO monad. If a function that is not pure is not imported in the IO monad, the system behaviour is undefined. Generally, no check for consistency with the C type of the imported label is performed."
22:46:31 * lispy waits for someone to mention nixos
22:46:47 <Kaidelong> why not nix?
22:47:07 <Kaidelong> nix is nice because it mixes dependency resolution with isolating packages from each other so that it's hard to break things
22:47:34 <triliyn> Mostly what I want is automation I guess... but also ease of maintaining third-party repositories
22:48:25 <triliyn> I want to be able to find a repository that has the somewhat-niche thingies I want to install and then let me keep those packages up to date without thinking about it
22:48:42 <Kaidelong> generally the windows approach seems to be to include all the libraries you rely on with the program itself and reinstall them with each program, if WinFS ever came about there would probably not have been many downsides but WinFS never did end up happening
22:48:57 <Kaidelong> so you end up with duplication to avoid dll-hell
22:49:09 <triliyn> But there are a few other things that I should probably not go into because this is kind of off topic
22:49:17 <Kaidelong> oh yes it is, sorry
22:49:50 <zRecursive> :t callCC
22:49:51 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
22:50:03 <zRecursive> why needs "m b" ?
22:51:25 <triliyn> zRecursive: the first argument to the first function doesn't need to have the same return type as callCC itself
22:51:38 <triliyn> *first argument to the first argument
22:51:52 <zRecursive> thx
22:51:58 <triliyn> Because that function never actually returns
22:52:48 <triliyn> (Or well... I guess it's possible for it to return? In which case the types will match. But it doesn't HAVE to return, and the types don't HAVE to match.)
22:53:13 <zRecursive> can it be "((a -> _) -> m a) -> m a"
22:53:51 <triliyn> I don't think that's valid syntax, but it's a reasonable way to think about it as far as I can tell?
22:54:05 <triliyn> Except that it should be ((a -> m _) -> m a) -> m a
22:54:22 <triliyn> Because that inner function DOES need to be in the monad
22:54:35 <zRecursive> see
22:55:01 <triliyn> Someone who knows more about continuation-passing style should probably answer your questions though
22:55:11 <triliyn> I only have a very basic and uncertain knowledge
22:55:38 <zRecursive> it is better to show me code snippets
22:56:01 <triliyn> The MTL haddock page has some simple ones I think
22:56:35 <triliyn> Or maybe not...
22:58:03 <jfischoff> @tell dcoutts turns out it was an issue with my HTTP lib. Upgrading Network, HTTP, and cabal-install did the trick.
22:58:03 <lambdabot> Consider it noted.
22:59:21 <triliyn> http://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Cont.html ah, this has examples
22:59:27 <roboguy_> would there be a nice composition of builtin functions/newtypes that would give us a function like this (where the resulting b is the maximum b): tupleZipM (Monad m, Ord b) => (a -> b -> m (a, b)) -> b -> [a] -> m ([a], b)
22:59:36 <triliyn> Not very good ones in my opinion but maybe better than nothing?
22:59:54 <triliyn> I can't come up with better ones though; I don't know what CPS is useful for
23:03:13 <verement> http://www.vex.net/~trebla/haskell/cont-monad.xhtml
23:10:05 <harasskell> @pl \x y z a -> reduce x y (map a z)
23:10:06 <lambdabot> flip flip (flip map) . (((.) . (.)) .) . reduce
23:10:41 <Aetherspawn> oh dear
23:12:17 <harasskell> @pl \a b c d e f g h -> (map a b) ++ (foldl c d e) ++ (foldr f g h)
23:12:18 <lambdabot> flip flip (flip flip foldr . ((flip . (((.) . (.) . (.) . (++)) .)) .) . foldl) . (((.) . (.) . (.) . (.) . (.) . (.) . (++)) .) . map
23:13:34 <harasskell> And now, the shortest one:
23:14:09 <harasskell> @pl \f g x -> f (g x)
23:14:09 <lambdabot> (.)
23:14:50 <harasskell> @pl \f g x -> g (f x)
23:14:50 <lambdabot> flip (.)
23:15:56 <triliyn> hehe, I love "flip flip"
23:16:56 <harasskell> \a b c d e f g h i j k l m n -> a (b (c (d (e (f (g (h (i (j (k (l (m n))))))))))))
23:17:47 <harasskell> @pl \x -> (x x)
23:17:48 <lambdabot> join id
23:19:05 <harasskell> @pl flip flip
23:19:06 <lambdabot> flip flip
23:19:15 <harasskell> @pl flip 2
23:19:15 <lambdabot> flip 2
23:19:38 <Aetherspawn> wow
23:19:43 <Aetherspawn> someone must have broken @pl
23:19:47 <Aetherspawn> it was working so well not so long ago
23:20:06 <triliyn> I think it just doesn't typecheck
23:20:36 <triliyn> I wonder, is it just assuming everything is a variable?
23:21:00 <triliyn> @pl \x -> 2 (3 x)
23:21:00 <lambdabot> 2 . 3
23:21:24 <harasskell_> @pl \a f b -> f a b
23:21:24 <lambdabot> flip id
23:21:25 <c_wraith> pfft.  2 and 3 can be functions
23:21:30 <triliyn> Well, on top of that, it doesn't typecheck
23:21:38 <c_wraith> it can typecheck.
23:21:39 <triliyn> Because join id is an error... I think?
23:21:42 <triliyn> :t join id
23:21:43 <lambdabot>     Occurs check: cannot construct the infinite type: a1 = a1 -> a0
23:21:43 <lambdabot>     Expected type: a1 -> a1 -> a0
23:21:43 <lambdabot>       Actual type: a1 -> a1
23:22:05 <triliyn> :t \x -> x x
23:22:05 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
23:22:06 <lambdabot>     In the first argument of `x', namely `x'
23:22:06 <c_wraith> but yeah, join id can't work
23:22:06 <lambdabot>     In the expression: x x
23:22:28 <harasskell_> :t unsafeCoerce join id
23:22:29 <lambdabot> Not in scope: `unsafeCoerce'
23:22:37 <triliyn> c_wraith: sure, they can be functions, but not variables
23:23:12 <triliyn> You're right though, my test didn't prove that it was treating them as variables
23:23:31 <harasskell_> @pl \a f b -> b f a
23:23:31 <lambdabot> flip (flip . flip id)
23:24:17 <triliyn> I'm imagining someone flipping pancakes now
23:24:21 <triliyn> flip flip      flip
23:25:21 <randomclown> how do I cabal install dependencies for tests?
23:28:31 <supki> randomclown: cabal install --enable-tests --dependencies-only
23:29:13 <randomclown> supki: thank you
23:29:20 <harasskell_> @pl (\f x y -> f y x)(\f x y -> f y x)
23:29:20 <lambdabot> flip flip
23:30:57 <randomclown> so I'm using cabal with the sandbox
23:31:04 <randomclown> and it's unhappy that I've added hspec
23:31:18 <randomclown> with: the following packages are likely to be broken by reininstalls
23:32:10 <lispy> randomclown: in sandboxes that warning is silly
23:32:22 <lispy> randomclown: worst case, just delete your sandbox and reinstall.
23:35:28 <randomclown> lispy: unordered-containes-... depends on bytestring .. which failed to install
23:36:17 <lispy> okay. and why did bytestring fail to install?
23:37:23 <randomclown> everything that depended on bytestring failed
23:38:31 <Gerldus> Hello friends! Is there someone who can can help with FRP and Sodium?
23:50:07 <supki> randomclown: you shouldn't need to reinstall bytestring; it's a core package which comes with ghc
23:50:54 <randomclown> well I added hspec to the .cabal and everything went to hell
23:50:54 <pavonia> Gerldus: it's best to just ask your question or/and link sample code showing your problem
23:51:25 <randomclown> supki:
23:54:04 <supki> randomclown: hmm. you can add --constraint='bytestring installed' to forbid the upgrade
23:54:17 <supki> that will probably help to generate better error
23:56:00 <abunchofdollarsi> I see this http://www.haskell.org/haskellwiki/Simple_Servers and I read "Tackling the Awkward Squad..."; any examples of people writing production network servers in haskell?
23:57:10 <Axman6> well, all the web frameworks have people using them in production I believe
23:57:43 <abunchofdollarsi> Which are then running on haskell web servers? Or something else.
23:58:10 <abunchofdollarsi> Okay I see happstack.
