00:03:29 <the_berserker> > {- -}
00:03:30 <lambdabot>  not an expression: `{- -}'
00:03:40 <the_berserker> >
00:03:50 <c_wraith> > {- -} ()
00:03:51 <lambdabot>  ()
00:04:52 <the_berserker> > scanl (^) [2..]
00:04:53 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
00:04:53 <lambdabot>    arising from a use of `M896646894073305489014371.show_M8966468940733054890...
00:04:53 <lambdabot>  The type variable `t0' is ambiguous
00:04:53 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:04:53 <lambdabot>  Note: there are several potential instances:
00:04:57 <pavonia> > ({-_-})
00:04:58 <lambdabot>  ()
00:06:39 <the_berserker> > <$> (add 2) 3
00:06:40 <lambdabot>  <hint>:1:1: parse error on input `<$>'
00:06:59 <the_berserker> > add 2 $ 3
00:07:00 <lambdabot>  Not in scope: `add'
00:07:00 <lambdabot>  Perhaps you meant one of these:
00:07:00 <lambdabot>    `odd' (imported from Prelude), `and' (imported from Data.List),
00:07:00 <lambdabot>    `F.and' (imported from Data.Foldable)
00:07:16 <the_berserker> > (+) 2 $ 3
00:07:17 <lambdabot>  5
00:07:27 <the_berserker>  (&
00:07:34 <pavonia> the_berserker: you can use lambdabot in /query too, btw
00:07:38 <levi> You can message lambdabot privately...
00:07:43 <the_berserker> > ($) ((+) 2) 3
00:07:44 <lambdabot>  5
00:08:07 <the_berserker> @unpl flip id
00:08:08 <lambdabot> (\ b c -> c b)
00:08:24 <levi> You can also build it locally.
00:08:32 <the_berserker> @pl ($)
00:08:33 <lambdabot> id
00:08:53 <the_berserker> > (1 $)
00:08:54 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
00:08:54 <lambdabot>    arising from a use of `M395822380450857755414511.show_M3958223804508577554...
00:08:54 <lambdabot>  The type variable `b0' is ambiguous
00:08:54 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:08:54 <lambdabot>  Note: there are several potential instances:
00:09:08 <the_berserker> > ($) 1
00:09:09 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
00:09:09 <lambdabot>    arising from a use of `M442050459602854042714526.show_M4420504596028540427...
00:09:09 <lambdabot>  The type variable `b0' is ambiguous
00:09:09 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:09:09 <lambdabot>  Note: there are several potential instances:
00:09:32 <the_berserker> @pl fix
00:09:32 <lambdabot> fix
00:09:33 * hackagebot slidemews 0.3 - ws convert markdown to reveal-js  http://hackage.haskell.org/package/slidemews-0.3 (j4pe)
00:09:34 * hackagebot ggtsTC 0.5 - A type checker and runtime system of rCOS/g (impl. of ggts-FCS).  http://hackage.haskell.org/package/ggtsTC-0.5 (brianchon)
00:09:43 <the_berserker> > fix fix
00:09:44 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = a0 -> a0
00:09:45 <lambdabot>  Expected type: (a0 -> a0) -> a0 -> a0
00:09:45 <lambdabot>    Actual type: (a0 -> a0) -> a0
00:10:58 <the_berserker> > fix id
00:11:01 <lambdabot>  mueval-core: Time limit exceeded
00:11:38 <the_berserker> What are the fixed points of `id`?
00:12:21 <the_berserker> > fix (1:).(2*)
00:12:22 <lambdabot>  Couldn't match type `[a0]' with `b0 -> c0'
00:12:23 <lambdabot>  Expected type: (b0 -> c0) -> b0 -> c0
00:12:23 <lambdabot>    Actual type: [a0] -> [a0]
00:12:49 <the_berserker> > fix (1:)
00:12:50 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:14:28 * hackagebot egison 3.2.10 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.10 (SatoshiEgi)
00:33:11 <Macfiron> re
00:34:04 <edwardk> @ask tibbe would it be possible to update ekg to work with current aeson and text? this just started blocking me =/
00:34:05 <lambdabot> Consider it noted.
00:35:51 <ReinH> edwardk: :(
00:36:11 <piezo> oh, >>> and . are both right-associative :/
00:39:31 <qrada> cabal sandbox might be saving my sanity.. maybe too early to tell
00:46:04 <pavonia> :t (>>>)
00:46:05 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
01:02:50 <Macfiron> pdxleif: You were right, it's not a problem with pandoc but with (pdf)latex and the template (I created my own one which uses ngermen)
01:03:02 <Macfiron> ngerman
01:08:30 <Macfiron> thanks for your help! cu!
01:34:54 <Twey> piezo: They should both be associative
01:38:40 <piezo> Twey: yes they are, but i'm building a right associative list (f :>>> (g :>>> Id)), so I have to reorder them
01:40:17 <piezo> so i'm wondering what should be the canonical associativity...
01:45:10 <Twey> piezo: Haskell uses right
01:45:19 <Twey> Might as well stick with that
01:45:38 <shachaf> Twey: The question is "what is right".
01:45:53 <ion> and/or “what is love”
01:46:41 <shachaf> The answer is probably to go along with what (.) does.
01:46:53 <shachaf> Are you making a "free category" thing?
01:47:03 <piezo> shachaf: yes
01:47:37 <piezo> i'm trying to normalize arrowized dataflows
01:47:50 <shachaf> That already exists somewhere, so you should just do whatever that does.
01:48:21 <Twey> shachaf: I meant ‘right’ as in ‘opposite of left’, not as in ‘opposite of wrong’.  ☺
01:48:33 <shachaf> Twey: Yes, so did I.
01:49:21 <shachaf> Twey: (If (.) and (>>>) are both right-associative, and go in opposite directions, saying "stick with right" doesn't help.)
01:49:40 <shachaf> Aha, it exists here: http://hackage.haskell.org/package/thrist-0.3.0.1/docs/Data-Thrist.html
01:49:57 <Twey> So the question was not ‘which associativity do I choose?’ but ‘which operator do I choose?’?
01:50:04 <Twey> Ooh, thrists!
01:50:08 <piezo> shachaf: arrow normalization ?
01:51:14 <shachaf> The question isn't about any operator.
01:51:20 <shachaf> The question is about a data type.
01:51:27 <passiveobserver> Hi All. -- I want to convert io int to int and bind it to a name. Why doesn't k <- getline let me write 'let' in front of k? Is there a convenient syntax that will allow me to bind a result of io operation to a name (such as let k = ... getLine ...)?
01:51:46 <shachaf> ANyway, I'm going to sleep.
01:51:58 <shachaf> passiveobserver: You can't convert IO Int to Int because they're completely different things.
01:51:59 <Twey> passiveobserver: You're experiencing monad confusion
01:52:09 <piezo> i got a general version working : http://lpaste.net/99141
01:52:13 <shachaf> passiveobserver: You should read the FAQ, it answrs this question:
01:52:15 <shachaf> @where faq
01:52:15 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
01:52:39 <ion> passiveobserver: fmap :: (Int -> Foo) -> IO Int -> IO Foo
01:52:40 <Twey> passiveobserver: ‘An IO Int contains an Int in the same way that /bin/ls contains a list of files’ — someone with a pithy turn of phrase
01:52:43 <passiveobserver> I can write k <- getLine ; let l = k
01:52:52 <passiveobserver> is there a one-liner for this?
01:52:59 <ion> l <- getLine
01:53:01 <shachaf> piezo: Yep, your type is the same as Thrist.
01:53:50 <Twey> passiveobserver: The thing on the left is a pattern, so you can also write l@k ← getLine to bind both names at once
01:54:02 <merijn> passiveobserver: What do you think "k <- getLine ; let l = k" does differently from "l <- getLine"?
01:54:03 <Twey> (though doing so is a bit pointless)
01:54:18 <merijn> Twey: It's actually doubly pointful ;)
01:54:25 * Twey groans.
01:54:37 <merijn> I try, I try
01:54:39 <mangaba_leitosa> passiveobserver: let l = System.IO.Unsafe.unsafePerformIO getLine
01:54:46 <passiveobserver> so basically if user inputs abc, then effectively k1 <- getLine is equal to let k1 = "abc" ??
01:54:51 <merijn> mangaba_leitosa: Please don't mention that to new people?
01:54:54 <ion> mangaba_leitosa: No. Bad advice.
01:54:57 <shachaf> Twey: "someone", eh?
01:55:05 <Twey> shachaf: Was it monochrom?
01:55:16 <merijn> Twey: Now you're making him sad
01:55:19 <mangaba_leitosa> merijn: but saying that it does not exist is a lie! :-)
01:55:22 <Twey> :þ
01:55:34 <shachaf> mangaba_leitosa: No, you're just being unhelpful. Stop it.
01:55:39 <merijn> mangaba_leitosa: And saying it does exist is utterly unhelpful
01:55:42 <mangaba_leitosa> ok
01:55:56 <Twey> mangaba_leitosa: It doesn't exist *in standard Haskell*.
01:56:08 <mangaba_leitosa> Twey: makes sense
01:56:12 <merijn> For all practical purposes when a confused new comer asks questions, it doesn't exist
01:56:41 <merijn> Twey: Last time I said that, someone said it was part of the FFI addendum which was included in Haskell2010, although after checking I couldn't actually find it mentioned in the report
01:56:59 <ion> passiveobserver: In both cases, k1 ends up being "abc", yeah.
01:57:04 <Twey> merijn: We looked this up — IIRC it's not there
01:57:27 <merijn> Twey: Good, then I can go back to saying it's not Haskell :)
01:57:42 <nexx> oh, I'm as well :)
01:57:49 <passiveobserver> ion: so to make myself clear in both cases k1 ends up to be a name with a binded value to it of "abc"?
01:58:00 <nexx> -'m
01:58:06 <passiveobserver> * to make it clear to myself.
01:58:07 <merijn> passiveobserver: You might also want to read the following blog post about IO: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
01:58:44 <merijn> It gives a good intuition about how to think of IO, which should (hopefully) clear up why some things can't be done
01:58:54 <ion> ghci> do { k <- getLine; print k }  -- enter abc
01:58:56 <ion> ghci> do { let { k = "abc" }; print k }
01:58:59 <ion> Both will print "abc"
01:59:14 <shachaf> I recommend reading the FAQ.
01:59:19 <piezo> passiveobserver: yes, but the only way to get it out of the 'do' block is to put it back in IO with return :: String -> IO String
01:59:49 <shachaf> sigh
01:59:49 <piezo> passiveobserver: so you're just manipulating it "inside the monad"
01:59:52 <Twey> passiveobserver: (the ‘list of files’ quotation is shachaf's, in case that was unclear)
02:00:00 <shachaf> I'm going to sleep.
02:00:06 <Twey> shachaf: 'night!
02:00:22 <ion> shachaf: Good night, sigh tight.
02:01:46 <mjrosenb> >  filter (\ l -> 1 == (length $ group $ map (fst . randomR (1,6*l) . mkStdGen) [1..2000])) [1..2000]
02:01:50 <lambdabot>  mueval-core: Time limit exceeded
02:01:56 <mjrosenb> >  filter (\ l -> 1 == (length $ group $ map (fst . randomR (1,6*l) . mkStdGen) [1..200])) [1..2000]
02:01:57 <lambdabot>  [1,3,9,13,19,27,39,57,117,171,247,351,513,741]
02:02:15 <mjrosenb> well, that is an interesting list of numbers.
02:02:35 <mjrosenb> >  filter (\ l -> 1 == (length $ group $ map (fst . randomR (1,6*l) . mkStdGen) [1..20])) [1..2000]
02:02:37 <lambdabot>  [1,3,9,13,19,27,39,57,117,171,247,351,513,741]
02:02:41 <mjrosenb> >  filter (\ l -> 1 == (length $ group $ map (fst . randomR (1,6*l) . mkStdGen) [1..20])) [1..20000]
02:02:43 <lambdabot>  [1,3,9,13,19,27,39,57,117,171,247,351,513,741,2223,6669]
02:18:05 <bernalex> hmmm where is maybeRead? I thought it was in Data.Text. I'm not talking about the Network one.
02:18:26 <bernalex> oh, probably in Text.Read
02:18:42 <bernalex> maybe not
02:20:14 <merijn> bernalex: Text.Read but 7.6 and up only
02:20:42 <bernalex> merijn: I have that. and I have used it before. I imported it into ghci, but maybeRead doesn't tab complete.
02:20:56 <bernalex> <interactive>:14:1: Not in scope: `maybeRead'
02:21:24 <osa1> bernalex: fmap pack . readMay
02:21:31 <osa1> readMay is in Safe package
02:21:38 <osa1> pack is from Text
02:21:39 <Cale> "When I was a boy, we used readsPrec, uphill, in the snow!"
02:21:45 <supki> bernalex: it's readMaybe
02:21:47 <merijn> bernalex: It's readMaybe
02:21:50 <merijn> Not maybeRead
02:22:06 <bernalex> omg
02:22:07 <bernalex> thanks
02:22:08 <merijn> osa1: No, since 7.6 there's a version in GHC's base
02:22:24 <osa1> merijn: really? what module has that?
02:22:29 <merijn> osa1: Text.Read
02:22:30 <osa1> I didn't know ..
02:22:43 <merijn> readMaybe and readEither were added (well, exported they already existed internally)
02:29:44 * hackagebot reactive-banana 0.8.0.0 - Library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.8.0.0 (HeinrichApfelmus)
02:34:44 * hackagebot reactive-banana-wx 0.8.0.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.8.0.0 (HeinrichApfelmus)
02:40:05 <asm89> lol, reactive banana?
02:42:48 <ghorn> asm89: http://www.haskell.org/haskellwiki/Reactive-banana
02:43:20 <asm89> ghorn: the logo is also great :p
02:43:30 <ghorn> asm89: according to the testimonials it's a top quality product
02:43:44 <asm89> haha
02:43:51 <asm89> made my day :)
02:44:48 <merijn> reactive-banana is one of the better FRP libraries
02:45:21 <mikeplus64> hm, why not have IO be defined by "data IO a = IO a". IO's implementation is already hidden, so i don't really see the problem with that
02:45:34 <csed> So uh, what exactly is FRP? Not quite getting the entire idea.
02:46:28 <mikeplus64> it could pretend to be a state monad with "data World = World; getWorld :: IO World; getWorld = IO World; runIO :: World -> IO a -> a; runIO World (IO a) = a" (the World constructor would be hidden)
02:48:06 <merijn> mikeplus64: What would the point of that be?
02:48:13 <merijn> csed: Functional Reactive Programming
02:48:22 <mikeplus64> merijn: to simplify the implementation of IO i suppose
02:49:06 <csed> merijnL Yeah, got that bit. Just haven't the slightest about what the Reactive bit would mean.
02:49:12 <merijn> csed: You may want to look at the "Functional Reactive Animation" and "Push-pull functional reactive programming" papers
02:49:21 <merijn> csed: See: http://conal.net/papers/
02:49:35 <merijn> csed: The idea is programming with continuous time, instead of discrete steps/polling
02:49:45 <csed> merijn: I'll check it out, thanks.
02:50:34 <mgsloan> merijn: have you taken a look at sodium?  I haven't quite formed my opinions about frp libs yet, but it seems rather nicely simple
02:51:27 <ghorn> merijn: so would reactive programming be when I use "on" from glib signals in my gtk programs?
02:52:19 <merijn> ghorn: on sounds like the FRP notion of an event, but FRP also has behaviours (i.e. time varying values)
02:52:59 <merijn> For example, a clock would be "Behaviour Time" that is a Time value that varies over time (i.e. every second the Time value is a second higher)
02:55:03 <merijn> In a video game you might have "Behaviour Velocity" which would be the velocity of a player/vehicle, which is obviously a value that varies over time
02:55:44 <merijn> ghorn: The papers I mentioned should be fairly readable at an intermediate Haskell level, so might be worth looking at
02:56:14 <ghorn> merijn: thank you!
02:56:46 <jle`> has anyone managed to get the SDL libraries to compile on windows?
02:56:56 <jle`> it keeps on saying that SDL is not installed...
02:57:03 <jle`> have no idea where they want me to put the SDL binaries
02:57:04 <jle`> er
02:57:06 <jle`> dll's
02:57:10 <jle`> for it to notice that they are installed
02:58:38 <merijn> jle`: You should specify the dll location using the --extra-lib-dirs flag when running "cabal configure"
02:58:55 <jle`> merijn: thanks, i'll try it out :)
02:58:56 <merijn> At least, that's what you'd do on OSX/linux for external libraries
02:59:15 <jle`> is there any way to do it in the cabal file? although i guess that doesn't make too much sense
03:00:00 <merijn> jle`: You can specify library paths in the cabal file, but it's usually useless as there is no general way to figure out where a library will be installed
03:00:18 <jle`> or maybe in cabal.config?
03:00:20 <jle`> in a sandbox?
03:03:10 <jle`> "Missing C library: SDL"
03:03:12 <jle`> hm.
03:03:17 <jle`> i'll check this out in the morning, it's getting late
03:03:18 <jle`> thanks though
03:10:05 <osa1> jle`: maybe you're pointing it SDL 2 instead of SDL
03:10:30 <osa1> jle`: we also have bindings for SDL2 https://github.com/Lemmih/hsSDL2/
03:18:36 <osa1> is there a way to set user-agent in http-conduit functions?
03:19:13 <zgredzik> hey, does anyone know how can I sort values from the window of each iteration of accelerate's stencil operation?
03:19:13 <markovirc_> Hello zgredzik
03:19:49 * hackagebot hit 0.5.4 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.5.4 (VincentHanquez)
03:24:04 <Xedir> Hey
03:24:05 <markovirc_> Hello xedir
03:25:07 <Xedir> and here it comes, my first question of the day: is there a way to get a executeable file out of a .hs file for mac like there is for windows with :! ghc O2 Name.hs?
03:25:36 <merijn> Xedir: Yes, just compile it?
03:25:53 <Xedir> i dont rly have haskell on my mac right now
03:26:00 <Axman6> Xedir: exactly the same way, though it's 0O2 not O2
03:26:03 <Axman6> -O2*
03:26:20 <merijn> Xedir: You can easily* install the Haskell Platform on OSX
03:26:42 <Xedir> there seems to be something missing all the time
03:26:47 <merijn> * - Depending on which version of OSX you have, 10.9 might be slightly less easy due to the dropping of gcc
03:26:55 <Xedir> yes
03:26:59 <Xedir> got a new macbook pro
03:27:17 <Axman6> it's easy enough, you just need to install the clang wrapper script
03:28:05 <Xedir> okay, i will give it an other go
03:28:30 <Xedir> thing is, when i type 'ghc' in my terminal i can use it
03:28:36 <Axman6> my only problem was with iconv, which I figured out how to fix (not sure why it was broken though)
03:28:48 <Xedir> ghci*
03:29:12 <bernalex> I'm not sure how exceptions work. how do I catch
03:29:17 <bernalex> > canonicalizePath "lulz"
03:29:18 <lambdabot>  Not in scope: `canonicalizePath'
03:29:38 <bernalex> ok... that'll throw Exeption: lulz: canonicalizePath: does not exist (No such file or directory)
03:29:50 <Aetherspawn> :t System.Directory.canonicalizePath
03:29:51 <lambdabot> FilePath -> IO FilePath
03:29:54 <Axman6> @hoogle catch
03:29:54 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
03:29:54 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
03:29:54 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
03:29:57 <merijn> bernalex: See Control.Exception
03:30:02 <Aetherspawn> > System.Directory.canonicalizePath "lulz"
03:30:03 <lambdabot>  Not in scope: `System.Directory.canonicalizePath'
03:30:04 <merijn> Ignore all those results
03:30:13 <Aetherspawn> why, lambdabot, WHY.
03:30:16 <bernalex> merijn: thanks.
03:30:18 <Axman6> @hoogle Control.Exception.catch
03:30:18 <lambdabot> Control.Exception.Base catch :: Exception e => IO a -> (e -> IO a) -> IO a
03:30:18 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
03:30:18 <lambdabot> Control.Exception catches :: IO a -> [Handler a] -> IO a
03:30:19 <merijn> You want Control.Exception.catch
03:33:30 <bernalex> merijn: so catch (canonicalizePath "lulz") f -- how does f need to look to just return the string "omgfail"?
03:33:47 <bernalex> can it be let f lol = return "omgfail"?
03:33:53 <merijn> Yes
03:33:54 <bernalex> I'm not very good with return as of now...
03:33:59 <bernalex> OK
03:34:37 <merijn> bernalex: f needs to take a type of exception (SomeException to catch everything, but you probably want IOError to only catch IO exceptions)
03:36:31 <bernalex> merijn: right, so let f :: IOERROR -> IO FilePath; f _ = return "lulz"
03:36:34 <bernalex> merijn: thanks!
03:41:51 <osa1> is there a way to request a page with some specified user-agent using http-conduit or http-client packages?
03:44:21 <Xedir> where should i have the file i would like to compile on my mac?
03:45:21 <bernalex> uhm I don't understand howto typesystem magic.
03:45:41 <bernalex> how do I make return $ printf "something" be an IO FilePath?
03:46:22 <bernalex> > :t printf "test" :: String
03:46:23 <lambdabot>  <hint>:1:1: parse error on input `:'
03:46:29 <alpounet> osa1: yeah, you have to change the user-agent HTTP header in your request
03:46:31 <sipa> bernalex: printf doesn't produce a filepath
03:46:43 <bernalex> sipa: printf produces pretty much what I want it to, afaiu
03:46:48 <supki> bernalex: if you only need to catch IOError you can as well use System.IO.Error.catchIOError without any annotations
03:46:50 <Axman6> sure it does, FilePath is just String
03:46:55 <sipa> oh!
03:46:59 <sipa> apologies then
03:47:06 <Axman6> @hoogle FilePath
03:47:07 <lambdabot> Prelude type FilePath = String
03:47:07 <lambdabot> System.IO type FilePath = String
03:47:07 <lambdabot> System.FilePath.Windows type FilePath = String
03:47:23 <bernalex> Axman6: so how do I make return $ printf "test" type check?
03:47:26 <haasn> > printf "a" :: String -- do we have this here?
03:47:28 <lambdabot>  "a"
03:47:29 <Axman6> bernalex: just wrap it in brtackets and give it an explicit type
03:47:31 <bernalex> the function is IOError -> IO FilePath
03:47:43 <bernalex> haasn: y
03:47:52 <bernalex> > putStrLn . printf $ "test"
03:47:53 <lambdabot>  <IO ()>
03:48:02 <Axman6> bernalex: you should not be using anything that accepts IOError, use the new exception stuff, not the old
03:48:13 <haasn> bernalex: that does type-check, mind
03:48:16 <haasn> :t return $ printf "test"
03:48:17 <lambdabot> (Monad m, PrintfType a) => m a
03:48:24 <mr-> Axman6: what's the new stuff?
03:48:25 <sipa> return (printf "bla" :: FilePath)
03:48:38 <Axman6> mr-: "new", just Control.Exception
03:48:50 <Axman6> the IOError stuff is very old afair
03:48:51 <bernalex> haasn: my problem isn't typing apparently. it's no instance for PrintfArg IOException
03:49:06 <haasn> bernalex: that means “printf” doesn't know how to format an IOException (how would it?)
03:49:17 <bernalex> ah, right
03:49:28 <haasn> you could of course use “show” on it and use %s as the format placeholder
03:49:44 <haasn> (why are you printing an IOException into a FilePath?!)
03:49:59 <Axman6> yeah this seems very broken
03:50:05 <bernalex> haasn: "omg '%s' doesn't exist"
03:50:29 <haasn> (http://hackage.haskell.org/package/xformat-0.1.2.1/docs/Text-XFormat-Show.html#g:5 handles Show arguments, by the way! wooh!)
03:50:59 <bernalex> haasn: however, the exception is of course not what I should be doing this on. doh. :-)
03:51:17 <Axman6> @hoogle fileExist
03:51:17 <lambdabot> System.Posix.Files fileExist :: FilePath -> IO Bool
03:51:17 <lambdabot> System.Posix.Files.ByteString fileExist :: RawFilePath -> IO Bool
03:51:17 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
03:52:00 <bernalex> Axman6: that doesn't let me handle the canonicalizePath Exception. IDK what you mean.
03:52:26 <Axman6> bernalex: why don't you telll us what you're actually trying to do
03:52:41 <bernalex> Axman6: I have been talking about it for a while now.
03:52:58 <merijn> fileExist is a terrible function and if you use it you should feel terrible about yourself
03:53:08 <bernalex> Axman6: I am using canonicalizePath, and when it fails I want to print "'%s': No such file or directory".
03:53:54 <haasn> so the %s you want to print is the original argument to canonicalizePath?
03:54:52 <Axman6> fooFilePath str = canonicaliseFilePath str `catch` (\(e:SomeException) -> printf "'%s': No such file or directory (%s)" str (show e))
03:54:55 <haasn> catching_ _IOException (canonicalizePath s) $ printf "'%s': No such file or directory" s -- ?
03:55:30 <Axman6> @hoogle canonicalizePath
03:55:30 <lambdabot> System.Directory canonicalizePath :: FilePath -> IO FilePath
03:55:33 <timthelion> wait, printf exists?  I thought that was a joke when I saw it in the TH paper.
03:55:37 <bernalex> haasn: I don't know what that does, so I don't know if that helps.
03:55:52 <hpc> timthelion: and it doesn't even use TH!
03:55:54 <haasn> it doesn't type check, actually
03:55:58 <Axman6> timthelion: yep, it's pretty useful. that one doesn't use TH though
03:55:58 <mr-> timthelion: multiple versions of it exist, btw
03:56:03 <merijn> bernalex: Look at Axman6's example
03:56:11 <bernalex> Axman6: show e will give you "canonicalizePath: does not exist (No such file or Directory)".
03:56:18 <Axman6> I'm not sure mine typechecks either, but it's pretty close :P
03:56:20 * timthelion has always been content with putStr and friends
03:56:36 <merijn> bernalex: No it won't
03:56:36 <bernalex> Axman6: oh, I might have misread it
03:56:36 <haasn> the correct function will likely look something like
03:56:43 <Axman6> bernalex: yes ;)
03:56:53 <Axman6> I'm just also printing out the exception
03:56:58 <haasn> canonicalizeFilePath str >>= (doSomething :: FilePath -> IO ()) `catch` (\(e :: IOException) -> printf ...)
03:57:02 <merijn> btw
03:57:04 <Axman6> because that's usually not a terrible idea
03:57:13 <haasn> catching SomeException though isn't something I'd be very keen on doing
03:57:17 <merijn> "\(e:SomeException)" is a syntax error
03:57:27 <Axman6> it should be e::SomeException
03:57:34 <merijn> And "\(e::SomeException)" requires ScopedTypeVariables
03:57:43 <haasn> Lenses to the rescue.
03:57:47 <merijn> Use "\(SomeException e)"
03:57:59 <Axman6> or, even \e -> printf "..." str (show (e :: SomeException)) because that doesn't need an extension
03:58:21 <Axman6> @hoogle SomeException
03:58:22 <lambdabot> Control.Exception.Base SomeException :: e -> SomeException
03:58:22 <lambdabot> Control.Exception SomeException :: e -> SomeException
03:58:22 <lambdabot> Control.Exception.Base data SomeException
03:58:29 <merijn> "\(SomeException e) -> printf ..." doesn't rquire an extension either :p
03:58:53 <Axman6> I thought SomeException was an opaque type. I've always just printed it
03:58:59 <bernalex> why should I take SomeException rather than IO exception?
03:59:10 <merijn> bernalex: You shouldn't necessarily
03:59:13 <Axman6> because SomeException allows you catch all exceptions
03:59:13 <merijn> Either would work
03:59:23 <merijn> Axman6: That's argument not to use it :p
03:59:30 <bernalex> exactly
03:59:32 <Axman6> in case you don't know ahead of time which exception will be throen
03:59:40 <Axman6> thrown*
03:59:55 * hackagebot GLUT 2.5.1.0 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.5.1.0 (SvenPanne)
04:00:09 <bernalex> hm. this does spectaluarly not work.
04:01:42 <bernalex> I get a big exception "PrintfType (IO a): result should not be used"
04:01:43 <haasn> “all exceptions” is a bit big
04:01:52 <haasn> includes also stuff like SIGINT
04:02:24 <merijn> haasn: SIGINT doesn't throw an exception
04:02:54 <hpc> SIGINT runs a signal handler the first time
04:03:05 <hpc> the second time is captured by the RTS which kills your program anyway
04:03:32 <hpc> so you can be sure to always be able to kill your programs
04:03:51 <merijn> You can be sure to always be able to kill your programs using "SIGKILL" >.>
04:04:16 <hpc> i mean kill them with ^C
04:04:34 <merijn> I know, but that's only true if the user didn't install handlers
04:04:40 <hpc> instead of having to do the which pid am i now dance
04:04:42 <merijn> Well, "user" meaning 'programmer"
04:04:53 <merijn> hpc: l2killall :p
04:05:00 <bernalex> so what do I do about the whole printftype result shouldn't be used?
04:05:02 <merijn> Unless you use Solaris, then do not learn that :)
04:05:04 <hpc> merijn: runghc ;)
04:05:57 <hpc> in any event, ever getting into a situation where you need to handle sigint twice is going to be quite iffy
04:06:04 <Axman6> haven't you guys been reading hacker news? never use kill -9. always, -15, then -2, then -1 then delete the executable from your system because it's clearly defective
04:06:12 <Earnestly> merijn: Do you know what killall does on some UNIX's? ;p
04:06:21 <haasn> merijn: oh, you're right; it seems different from when you run it via runhaskell
04:06:42 <merijn> Earnestly: See my Solaris remark
04:06:53 <Earnestly> pkill/pgrep is the tools you're after, and Solaris created those originally
04:06:59 <Earnestly> s/is/are/
04:07:09 <Earnestly> merijn: Ah, missed it heh
04:07:27 <haasn> Earnestly: cool, good to know. Shorter, too :)
04:07:54 <Earnestly> haasn: It has many useful arguments which bring sanity to your killing
04:07:54 <merijn> Earnestly: No, I'm not after those, because that'd mean having to install all sorts of silly programs while I already have perfectly working alternatives available
04:08:09 <hpc> Axman6: whut
04:08:36 <merijn> SIGINT is for people who can't produce crash-only software
04:08:39 <Earnestly> merijn: Both of those come from procps-ng which you are very likely to already have
04:09:00 <haasn> merijn: huh, they come by default here!
04:09:03 <Earnestly> (If you're on a *nix of some kind)
04:09:07 <haasn> Yeah, sys-process/procps-3.3.9 has them here
04:09:09 <bernalex> currently, I have:
04:09:11 <bernalex> fooFilePath  :: FilePath -> IO FilePath
04:09:13 <bernalex> fooFilePath f = canonicalizePath f `catch` (\(SomeException _) -> printf "'%s': No such file or directory" f)
04:09:22 <merijn> Earnestly: You seem to think every *nix is linux
04:09:25 <bernalex> and I do fooFilePath file >>= putStrLn
04:09:31 <Earnestly> merijn: pkill comes with BSd, OSX, etc.
04:09:31 <haasn> bernalex: but that's misleading
04:09:36 <Earnestly> Solaris…
04:09:43 <bernalex> haasn: it dies at the first exception
04:09:51 <bernalex> because zomg PrintfType (IO a): result should not be used
04:09:53 <haasn> rightfully so, too
04:09:55 <merijn> Earnestly: My FreeBSD and OSX box both lack pkill, I just checked
04:10:01 <bernalex> haasn: why?
04:10:05 <Axman6> hpc: http://unix.stackexchange.com/questions/8916/when-should-i-not-kill-9-a-process
04:10:10 <merijn> Earnestly: Neither do they have pgrep
04:10:11 <Axman6> second answer
04:10:13 <haasn> You want to run (canonicalizePath f >>= putStrLn) `catch` zomgExceptions
04:10:27 <haasn> bernalex: printf returns IO (), you're trying to use it as IO FilePath
04:10:32 <haasn> there's no sane FilePath to return on error
04:10:33 <bernalex> haasn: yes, I was more or less copy pasting Axman6's code. I orginally have what you said.
04:10:38 <Earnestly> merijn: Strange, because I see pkill in BSD's src tree
04:10:40 <bernalex> ah
04:10:40 <haasn> that's why you put the catch *outside* the processing logic
04:10:51 <bernalex> yes, again, that's what I had. going back to that now.
04:10:57 <Earnestly> (FreeBSDs anyway)
04:12:14 <Earnestly> merijn: " They made their first appearance in FreeBSD 5.3." From the manual
04:12:35 <merijn> Earnestly: Hmm, lemme check again
04:13:10 <Earnestly> "http://svnweb.freebsd.org/base/head/bin/pkill/"
04:13:21 <Earnestly> No pgrep though
04:13:28 <merijn> oh, blah, I forgot to open SSH to my home box when I installed a new modem
04:13:56 <Earnestly> Anyway, killall is fairly competent these days, no longer a shell script at least in GNU land
04:14:24 <bernalex> haasn: OK, so what would the type signature of zomgExceptions be?
04:14:41 <haasn> what?
04:14:49 <zomg> ZomgException z o m g
04:15:09 <bernalex> haasn: in (canonicalizePath file >>= putStrLn) `catch` zomg
04:15:33 <haasn> (ZomgException z o m g, Effectful f) => LensLike f z o mg -- clearly
04:15:35 <bernalex> how would zomg look like to be able to print "'%s': No such file or directory", where %s should be file
04:15:43 <hpc> ZomgException :: U -> H -> O -> H -> ZomgException
04:16:03 <haasn> bernalex: it needs to end with -> IO () because that's the type of putStrLn
04:16:16 <haasn> bernalex: and the argument is based on what kind of exception you want to catch
04:16:26 <haasn> SomeException is the catch-all but as explained multiple times that's probably not what you really want
04:16:29 <bernalex> well, right now I have IOError -> IO ()
04:16:30 <haasn> Try IOException or whatever
04:16:37 <haasn> cooking now, afk
04:16:57 <bernalex> but as you said,I'll get PrintfArg IOException
04:18:07 <bernalex> with handleDoesntExist f = printf "'%s': No such file or directory" f
04:20:50 <bernalex> meh. I'll just do
04:20:52 <bernalex> handleDoesntExist ::  String -> IOError -> IO ()
04:20:54 <bernalex> handleDoesntExist f _ = printf "'%s': No such file or directory" f
04:20:56 <bernalex> for now
04:25:01 <ij> :t foldl
04:25:02 <lambdabot> (a -> b -> a) -> a -> [b] -> a
04:25:51 <ij> :t (+)
04:25:52 <lambdabot> Num a => a -> a -> a
04:25:54 <ij> > foldl (+) (0 :: Integer) (repeat (1 :: Word8))
04:25:55 <lambdabot>  Couldn't match expected type `GHC.Integer.Type.Integer'
04:25:55 <lambdabot>              with actual type `GHC.Word.Word8'
04:26:21 <merijn> ij: (+) needs identical arguments
04:26:29 <ij> ah
04:26:34 <staffehn> * argument types
04:26:37 <mr-> > (+) 3 4
04:26:38 <lambdabot>  7
04:26:39 <mr-> :->
04:26:49 <merijn> It's "Num a => a -> a -> a", not "(Num a, Num b) => a -> b -> a"
04:27:11 <ij> So should I map (fromIntegral :: (Int -> Integer))?
04:27:28 <merijn> ij: Well, the signature would be redundant (GHC can infer it), but yes
04:27:46 <merijn> > foldl (+) (0 :: Integer) . map fromIntegral $ repeat (1 :: Word8)
04:27:50 <lambdabot>  mueval-core: Time limit exceeded
04:27:53 <ij> thanks!
04:27:56 <merijn> That's an infinite loop of course, but no type error
04:27:58 <ij> It typecheks.
04:28:00 <ij> yup
04:28:37 <merijn> ij: Since GHC can infer that Integer is required (from the (+) and (0 :: Integer)) and Word8 can be inferred from the input list, the type of fromIntegral can be inferred too
04:29:04 <kqr> how thread-safe is putMVar?
04:29:17 <merijn> kqr: 100% ?
04:29:21 <kqr> i see
04:29:23 <merijn> I don't understand the question :p
04:29:25 <kqr> hah
04:29:29 <merijn> How could it not be threadsafe?
04:29:44 <kqr> i'm curious what happens if two threads try to putMVar to the same MVar at the same time
04:29:55 <staffehn> one wins :D
04:29:57 <kqr> i know if they do it in sequence the second call will block
04:29:58 <merijn> kqr: One will succeed, the other will block until the MVar is emptied
04:30:11 <kqr> i see
04:30:17 <merijn> kqr: They obey sequential consistency
04:30:39 <kqr> very nice
04:30:43 <kqr> that's what i hoped for
04:30:45 <merijn> kqr: i.e. at then end there will be *a* globally agreed upon order of operations
04:31:06 <kqr> (on the other hand that means my thing has bugs somewhere else...)
04:31:18 <kqr> oh well, i'll find 'em
04:31:18 <merijn> kqr: If you have MVar bugs, you may wanna look into STM? :)
04:31:34 <johnw> STM++++
04:31:36 <merijn> Control.Concurrent.STM (see the paper linked at the top for a good introduction)
04:31:51 <johnw> these days I feel like using MVar is low-level
04:31:59 <merijn> kqr: With STM you can have transactional MVars :)
04:31:59 <kqr> if MVars are sequentially consistent they should not be the cause of my bugs
04:32:05 <kqr> but i'll look into STM
04:32:10 <kqr> maybe that makes things simpler as well
04:32:24 <johnw> also, in STM you often don't need a TMVar, but can just use a TVar, which makes a lot of things simpler to think about
04:32:27 <kqr> i just picked MVar because it was the first thing i encountered that looked useful
04:32:52 <kqr> the way i use 'em is that i have one mvar
04:33:02 <kqr> a bunch of worker threads try to put their results in it
04:33:09 <kqr> and then a logger thread reads it and logs the results
04:33:17 <merijn> kqr: Maybe you want a Chan?
04:33:49 <johnw> or a TChan :)
04:34:03 <merijn> kqr: Chan/TChan don't cause writers to block
04:34:26 <merijn> kqr: (Which may leak memory of your producers out produce your consumer(s) by a large margin)
04:34:39 <merijn> But they're good for these kinds of data sinks
04:34:49 <johnw> there's always TBChan
04:35:01 <merijn> johnw: For multiple consumers Chan is better than TChan, though
04:35:06 <johnw> to put an upper bound on the buffering
04:35:08 <kqr> merijn, are Chans part of STM or cloud haskell?
04:35:22 <merijn> kqr: Chan are just normal haskell, they're implemented using MVars
04:35:27 <johnw> merijn: better how?
04:35:30 <kqr> oh
04:35:33 <merijn> kqr: See everything under Control.Concurrent
04:35:34 <kqr> that sounds like what i want
04:35:40 <merijn> johnw: No thundering herd problem
04:35:52 <kqr> my producers should never outproduce the consumers anyway
04:36:07 <kqr> i was looking for channels but i only found cloud haskell, which requires a backend and felt a bit overkill
04:36:26 <merijn> johnw: Lots of consumers blocking on a single Chan will result in a single consumer being woken up. With TChan *all* consumers will be woken up
04:36:31 <quchen> Hooray, 7.8 fork happened!
04:36:33 <johnw> ah, I see
04:36:37 <johnw> quchen: woohoo!
04:36:53 <quchen> I'm sure lots of people here lots their bets of it not being released till August or something ;-)
04:37:03 <merijn> kqr: I would take some time browsing everything under Control.Concurrent (including the STM bit and reading the paper linked in those docs), it's useful to be familiar with those things :)
04:37:11 <kqr> merijn, is that literally the difference between chan and tchan or is it a byproduct of the "real" differences?
04:37:35 <merijn> kqr: It's a byproduct of the "real" difference (i.e. thundering herd is inherent in the way STM works)
04:37:46 <kqr> ah
04:37:54 <merijn> Which should be explained by the STM paper :)
04:38:00 <kqr> yeah i was just gonna ask about that
04:38:17 <kqr> the paper you're talking about is the tim harris et al (2005) one?
04:38:35 <merijn> The only way to avoid thudering herd in STM is to be omniscient/precogniscient :)
04:38:50 <johnw> merijn: read the STM minority report
04:38:55 <kqr> i'm all about being omniscient!
04:39:04 <merijn> kqr: Composable memory transactions by Harris and the Simons, yes
04:39:23 <kqr> oh yeah a couple of simons were in there yeah
04:40:01 <mr-> The paper does not even mention "thunder"! ;-)
04:42:00 <kqr> is getChanContents considered good or bad practise? or the more general question, what's the stance on unsafeInterleaveIO?
04:42:03 <jmcarthur> oh it didn't even occur to me that STM suffered from the thundering herd problem
04:42:20 <kqr> (getChanContents :: Chan a -> IO [a])
04:43:22 <jmcarthur> i bet there are some scheduling tricks one could do to make that nicer
04:43:54 <jmcarthur> since transactions can't perform IO anyway, it's not like queueing behavior of some sort would be easily observable
04:44:07 <jmcarthur> so long as all cores are utilized
04:44:15 <merijn> jmcarthur: You can't really do a scheduling trick, I think?
04:44:30 <Cale> You can
04:44:38 <merijn> jmcarthur: Any transaction involving a TVar 'x' will have to be rerun if 'x' changes
04:45:04 <merijn> jmcarthur: Because it's impossible to distinguish "retry due to empty channel" from an other condition that could provoke a retry
04:45:26 <jmcarthur> merijn: transactions can live in a queue such that if you have k capabilities no more than k transactions are running at once
04:45:36 <jmcarthur> merijn: actively running, i mean
04:45:45 <Cale> Well, yes, but you can make it take longer to write to x when there's a transaction which reads it and is having trouble completing
04:45:47 <merijn> jmcarthur: Thundering herd problem exists due to non-running transactions
04:46:05 <jmcarthur> i understand, but i think i haven't expressed the idea well enough
04:46:16 <jmcarthur> the idea is that transactions wouldn't be in that queue while blocked
04:46:20 <Cale> (Well, you have to be a little cleverer than that)
04:46:34 <merijn> jmcarthur: Not sure how that'd avoid the problem?
04:47:09 <merijn> jmcarthur: Suppose I have 20 threads reading from an empty TChan and blocking. Now I have 0 running transactions and 20 blocked on the same TVar
04:47:17 <Cale> STM's abstract semantics actually allows for many clever things to happen
04:47:25 <jmcarthur> it still means cores are utilized but is less likely to result in tons of wasted transactions that just end up stepping all over each other in the end. this idea isn't exactly scalable to huge numbers of cores though
04:47:28 <merijn> jmcarthur: TVar is updated, now how can I avoid waking up all 20 threads to check if they *can* succeed now?
04:47:50 <Cale> merijn: By waking up one of them?
04:47:52 <merijn> I don't see how the number of cores influences anything here?
04:48:11 <jmcarthur> merijn: oh you just mean you want to avoid the work of checking them at all? that's not what i think of when somebody says thundering herd
04:48:13 <Cale> (Or some fixed number)
04:48:15 <merijn> Cale: But you can't know whether they were really blocked on only reading, rather than any other condition involving that TVar
04:48:41 <merijn> Cale: The entire reason Chan *can* avoid thundering herd is that with an MVar there can only be one reason for blocking
04:48:54 <jmcarthur> merijn: i think of the bunch waking up, stomping around for a while, finding that most of them conflict with each other anyway, just to go back to sleep again until the first few successful ones finish, then starts again
04:49:11 <jmcarthur> merijn: different from just seeing whether to wake up at all
04:49:23 <merijn> jmcarthur: Well, you wake up 20 and 19 of them run only to suspend again because the first to succeed emptied the Chan again
04:49:27 <jmcarthur> right
04:49:38 <jmcarthur> i'm proposing that fewer of them would actually run at once this way
04:49:56 <jmcarthur> (again, unless you have a lot more cores available than most machines do now)
04:49:58 <merijn> jmcarthur: A lot of the cost is waking up and rechecking conditions, not the actual running
04:50:05 <Cale> merijn: You probably should only ever wake up as many threads as you have capabilities
04:50:15 <jmcarthur> i agree, but that's still not what i think of when somebody says thundering herd
04:50:18 <jmcarthur> well
04:50:25 <jmcarthur> i guess you mean rerunning bits of the transactions
04:50:28 <Cale> (or maybe even fewer than that, depending)
04:50:29 <jmcarthur> in which case i agree
04:50:39 <merijn> Cale: That doesn't help
04:50:51 <Cale> Why not?
04:50:52 <merijn> Cale: You'll still have to run the rest eventually, even if not concurrently
04:50:54 <jmcarthur> it reduces the impact significantly
04:50:58 <merijn> Thus you are burning cycles
04:51:13 <jmcarthur> maybe by the time the rest run the conditions for them to complete are met anyway, just because the system is more productive overall
04:51:21 <Cale> merijn: It means that those (or at least one of the smaller number of them) get to complete without competing for resources with all the others
04:51:34 <jmcarthur> whereas if all run at once it is much more likely they wont' be able to finish
04:51:46 <merijn> Cale: Sure, but the problem here isn't "competing for capabilities" (well, that's a part of it)
04:52:00 <jmcarthur> it's competing for TVars, roughly
04:52:11 <merijn> Cale: It's *also* "wasting a lot of CPU time by rerunning the same small bits of transactional code over and over for no progress"
04:52:18 <jmcarthur> right
04:52:23 <Cale> If you have all those transactions live, then eventually you're going to want to complete them all
04:52:30 <jmcarthur> this also helps with that problem
04:52:42 <Cale> So you better wake them up some of the time
04:52:51 <merijn> Cale: Compared to say using "Chan" and only waking up 1 thread per write, the Chan is going to be a lot more efficient
04:53:06 <merijn> (Which was my initial point, after all
04:53:12 <Cale> Okay, well, I don't know what code is being discussed here
04:53:38 <Cale> There are a lot of things which could be done in a more clever way with regard to scheduling STM transactions though
04:53:39 <merijn> Cale: Not anything specific, I was saying that in many consumer scenario Chan outperforms TChan and people asked why
04:53:44 <jmcarthur> merijn: the idea is that writing a TVar doesn't mean "wake up all the things" but "make sure everybody is scheduled to run some time in the future when resources permit", which means the thundering herd just doesn't waste so much
04:53:45 <Cale> hmm
04:54:33 <jmcarthur> Cale: yeah. STM doesn't even have to be optimistic the way it is, although it's pretty low overheard like this.
04:55:41 <jmcarthur> Cale: i've had in the back of my head thoughts of adapting known schedulers for database transations to STM, e.g. timestamp ordering with blocking and partial rollbacks
04:55:47 <jmcarthur> orElse always complicates such ideas though
04:56:18 <jmcarthur> i don't think it's incompatible, just less straightforward
04:58:52 <Cale> There perhaps ought to be ways to give hints to the thread scheduler / STM about the reason for retrying in the case that a future success would cause others who retried for the same reason to fail.
04:59:32 <Cale> (Or maybe there's a way to discover this)
05:02:44 <tangentstorm> anyone care to critique some j-flavored code snippets? http://tangentstorm.github.io/mini-rosetta.html
05:02:56 <Cale> I suppose another option is: when a transaction retries, record not only which TVars it read on the way to the retry, but also their values. If they still have those values, then waking the transaction will certainly have the same result.
05:03:22 <Cale> That could be made more efficient if there were a way for transactions to retry and place blame on a specific TVar's value
05:04:16 <k00mi> tangentstorm: [[0..n]|n<-[0..10]] is inits
05:04:21 <Cale> tangentstorm: mhook = ap
05:04:28 <hpc> was about to mention that
05:04:44 <tangentstorm> i had a feeling i was reinventing the wheel in a few places :)
05:04:54 <hpc> dyco = on
05:04:55 <Cale> mfork = liftM2
05:05:11 <Cale> er, with different parameter order
05:05:24 <hpc> rfx = join
05:05:25 <tangentstorm> i looked at on... i'm not sure it's the same thing...
05:05:26 <Cale> > liftM2 (/) (1+) (2*) 2
05:05:27 <lambdabot>  0.75
05:05:36 <Cale> It is
05:05:46 <Cale> :t on
05:05:47 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
05:06:11 <Cale> > on (+) (*2) 3 5
05:06:13 <lambdabot>  16
05:06:29 <hpc> > do {x <- [0,1,2,3]; y <- [0,1,2,3]; return (x + y)}
05:06:30 <lambdabot>  [0,1,2,3,1,2,3,4,2,3,4,5,3,4,5,6]
05:06:33 <tangentstorm> oh, nm... i was looking at 'on' when i wrote comd
05:07:08 <tangentstorm> where do i find 'ap' ?
05:07:15 <Cale> Control.Monad
05:07:18 <tangentstorm> better yet, /how/ do i find ap ? :)
05:07:30 <Cale> @hoogle ap
05:07:30 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
05:07:30 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
05:07:30 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
05:08:03 <hpc> > scanr (+) 0 [1..10]
05:08:04 <lambdabot>  [55,54,52,49,45,40,34,27,19,10,0]
05:08:15 <Cale> @pl mhook f g x = f x (g x)
05:08:16 <lambdabot> mhook = ap
05:08:17 <tangentstorm> we have lambdabot in #learnprogramming... is there a way to get some of the things it provides (like hoogle and @pl) right from the ghci prompt? (or some nice wrapper)?
05:08:17 <hpc> > scanl (+) 0 [1..10] -- keep forgetting scans are reversed from folds
05:08:18 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
05:08:30 <Cale> @pl dyco f g x y = f (g x) (g y)
05:08:30 <lambdabot> dyco = join . ((flip . ((.) .)) .) . (.)
05:08:32 <Cale> lol
05:08:42 <Cale> simplifier failed there
05:08:49 <tangentstorm> :)
05:08:58 <Cale> @pl comd f g x y = f (g x y)
05:08:58 <lambdabot> comd = (.) . (.)
05:09:23 <FireFly> tangentstorm: I think there's a @pl thing in cabal, but I usually just /query lambdabot
05:09:32 <hpc> :t (<*> id)
05:09:33 <lambdabot> (a -> a -> b) -> a -> b
05:09:46 <hpc> your mhook (+) id = join (+)
05:09:53 <Cale> @pl mfork f g h y = (f y) `g` (h y)
05:09:54 <lambdabot> mfork = (ap .) . flip (.)
05:09:58 <Cale> @pl mfork g f h y = (f y) `g` (h y)
05:09:59 <lambdabot> mfork = liftM2
05:10:36 <tangentstorm> i'm surprised by liftM2 since i'm not using a monad anywhere.
05:10:43 <Cale> It's the function monad
05:10:46 <FireFly> It's using the function monad
05:10:52 <Cale> :t liftM2
05:10:53 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:10:54 <tangentstorm> oh hey FireFly :)
05:11:00 <FireFly> hi :P
05:11:00 <markovirc_> Hello FireFly
05:11:02 <Cale> well, let's write that as
05:11:12 <Cale> (a -> b -> c) -> m a -> m b -> m c
05:11:25 <Cale> Now replace m t with (e -> t)
05:11:38 <Cale> (a -> b -> c) -> (e -> a) -> (e -> b) -> (e -> c)
05:11:57 <tangentstorm> i just didn't realize a function was a Monad
05:12:02 <Cale> A function isn't
05:12:13 <Cale> The type constructor (->) e is a monad for any type e
05:12:40 <bernalex> I'm going to remember how to do this once (sometime soon), but right now I don't.
05:12:50 <tangentstorm> > (->) Int Char
05:12:51 <lambdabot>  <hint>:1:2: parse error on input `->'
05:12:59 <FireFly> @ty (->) Int Char
05:12:59 <Cale> :k (->) Int Char
05:12:59 <lambdabot> *
05:13:00 <lambdabot> parse error on input `->'
05:13:03 <hpc> to be a bit fair to the J parts, i am not sure some of those examples would be written tha way either
05:13:04 <FireFly> er right
05:13:06 <Cale> :k (->)
05:13:07 <lambdabot> * -> * -> *
05:13:09 <Cale> :k (->) Int
05:13:09 <bernalex> if I have foo bar >>= putStrLn (assume foo bar works), how do I putStrLn foo bar ++ "fubaz"?
05:13:10 <lambdabot> * -> *
05:13:12 <Cale> :k (->) Int Char
05:13:12 <hpc> like "double the sum of the arguments"
05:13:12 <lambdabot> *
05:13:31 <hpc> it seems weird for something that's such a basic math expression
05:13:41 <Cale> bernalex: do s <- foo bar; putStrLn (s ++ "fubaz")
05:13:42 <bernalex> so foo bar is an IO String, and I want to ++ "some string" to that before putStrLn
05:13:52 <Cale> bernalex: Or use a lambda, if you really insist
05:14:04 <bernalex> YES
05:14:12 <bernalex> Cale: I just did it by myself before you answered heh
05:14:12 <Cale> bernalex: foo bar >>= \s -> putStrLn (s ++ "fubaz")
05:14:21 <bernalex> I finally remembered
05:14:30 <FireFly> > (\xs -> all (zipWith (<) (init xs) (tail xs))) [0..9]
05:14:31 <tangentstorm> hpc: i was just looking for a simple example to illustrate the idea... in j, i'd probably just write *:+/  ((2*).sum)
05:14:31 <lambdabot>  Ambiguous occurrence `all'
05:14:31 <lambdabot>  It could refer to either `L.all', defined at L.hs:153:1
05:14:31 <lambdabot>                        or `GHC.List.all',
05:14:31 <lambdabot>                           imported from `Data.List' at L.hs:84:1-16
05:14:31 <lambdabot>                           (and originally defined in `base:GHC.List')
05:14:36 <FireFly> .__.
05:14:49 <tangentstorm> er whoops. i mean +:+/
05:14:57 <FireFly> eh, oh
05:15:29 <FireFly> @pl all id
05:15:29 <lambdabot> and
05:15:36 <FireFly> right, that's what it's called
05:15:48 <FireFly> > (\xs -> and (zipWith (<) (init xs) (tail xs))) [0..9]
05:15:49 <lambdabot>  True
05:15:55 <ij> The pixs "average" gets is of length 1049088. It's the problem. What could cause it? http://sprunge.us/eWeM
05:16:43 <FireFly> tangentstorm: `init` and `tail` is ilke J's }: and }., and `zipWith` applies a dyad to corresponding elements of two lists
05:17:16 <FireFly> oh wait
05:17:17 <tangentstorm> comd = (.) . (.)    --  i like that! :)
05:19:15 <FireFly> There's also the generalised  fmap fmap fmap
05:19:21 <FireFly> aka  fmap.fmap
05:20:07 <tangentstorm> actually i think i got that {.}: implementation for srictly ascending from you, FireFly :)
05:20:54 <tangentstorm> thanks everybody :)
05:21:00 <FireFly> oh
05:21:17 <supki> ij: probably  foldl, try with  foldl'
05:21:45 <tangentstorm> :t inits
05:21:46 <lambdabot> [a] -> [[a]]
05:22:09 <tangentstorm> @pl map init
05:22:09 <lambdabot> map init
05:22:58 <tangentstorm> i guess it doesn't simplify if it's already tacit?
05:23:16 <tangentstorm> :t fmap.fmap
05:23:18 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
05:26:45 <ij> supki, Yup, thanks.
05:28:55 <Maior> :t flip
05:28:55 <lambdabot> (a -> b -> c) -> b -> a -> c
05:30:57 <Vektor> how do I explicitly assign a type to a variable in a let statement?
05:31:08 <Maior> let x = 1 :: Int
05:31:20 <Vektor> oh, alright.
05:31:37 <quchen> :t let x :: Int; x = 1+1 in x -- You can also pre-declare it
05:31:38 <lambdabot> Int
05:31:38 <Vektor> I was trying out x :: Int =1, but that didn't work
05:32:07 <quchen> (Post also works, but looks awkward)
05:33:36 <Vektor> I should totally learn my way around monads before writing IO stuff...
05:33:40 <Vektor> so little time
05:34:41 <Vektor> I'm mapping a readFile call over a list of filepaths. It returns a [IO String], but I think I need IO [String]
05:35:25 <Maior> Vektor: ooh that's...lifty
05:35:28 <Maior> or something
05:35:45 <Maior> @hoogle [m a] -> m [a]
05:35:45 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
05:35:45 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
05:35:45 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
05:36:18 <Vektor> lambdabot is awesome :D
05:36:23 <Maior> so one thing I really like the idea of with Haskell is having amazing IDE support
05:36:26 <BoR0> @src sequence
05:36:26 <lambdabot> sequence []     = return []
05:36:26 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:36:26 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
05:36:51 <Maior> "I have an A, I need a B, please give me routes"
05:37:02 <Vektor> :D
05:37:21 <Vektor> I'm starting to think you don't need much effort to make lambdabot self-aware
05:38:46 <BoR0> @src liftM2
05:38:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:39:30 <Vektor> @hoole zip
05:39:30 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
05:39:30 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
05:39:30 <lambdabot> Data.ByteString.Char8 zip :: ByteString -> ByteString -> [(Char, Char)]
05:43:08 <Vektor> :t read
05:43:09 <lambdabot> Read a => String -> a
05:43:38 <Vektor> ohh, derp. So it doesn't know what to return
05:44:08 <Vektor> type inference doesn't always work, apparently
05:49:14 <k00mi> Maior: regarding IDE: http://peaker.github.io/lamdu/
05:49:53 <Maior> k00mi: nifty; alas I'm unlikely to move from IDEA/vim
05:49:59 <tangentstorm> oh wow
05:50:08 <Maior> but that looks awesome
05:50:15 * tangentstorm is making something like that for j, but not nearly so pretty
05:50:22 <k00mi> it still needs a *lot* of work though before it's usable
05:50:42 <tangentstorm> is that yours, k00mi ?
05:51:03 <mmmm> Is there a simple explanation to the error message " Could not find module `GHC.Generics'" when using cabal install?
05:51:31 <k00mi> tangentstorm: no, Peaker is the main developer I think
05:51:52 <tangentstorm> ah
05:58:19 <dreixel> mmmm: uhm, is the package listing a dependency on ghc-prim ?
05:58:40 <dreixel> oh, actually it's in base
05:59:06 <quchen> Vektor: Type classes sometimes require explicit type annotations. Think about how "show 1" should be interpreted: Is the 1 an Int, an Integer, a Double? Each of these have their own Show instances, and just from looking at the code GHC can't tell which number you mean.
06:01:14 <quchen> (To be fair, there is a special rule that allows you to use "show 1" without trouble, but conceptually the explanation was what happens.)
06:01:31 <Vektor> I was actually reading an Integer from a String, and without doing any Int calculations on it, I just used it to call "show" on it. So GHC had no way of knowing what it was dealing with.
06:02:17 <quchen> show (read "...") is always a type error.
06:02:34 <k00mi> Vektor: usually in a real programm, GHC knows from context what type you want to read
06:02:36 <quchen> Read doesn't know which type it should read to, show does not know which type it receives.
06:02:56 <Vektor> looking at it now, it's obvious that I didn't need to parse/show it in the first place, but it's nicer this way imo
06:03:32 <Vektor> well, yeah, but I know that it's an Int, so I made it explicit.
06:04:05 <Vektor> I know it's kinda pointless and redundant, but the code is nicer to work with now. I can now work with the Ints if I need to sort them or do other stuff.
06:07:23 <fryguybob> Cale: when a transaction retries it does have the values of the reads and does check when woken if anything has changed before running the transaction again.
06:30:13 <kqr> merijn, if you're curious, i found out what caused the apparent race condition with the mvars: my external data source was behaving badly, hah. but i've saved the STM paper for later tonight and i'm happy to know about Chans, so thanks!
06:41:05 <zrho> I'm looking for a topic for a Haskell related Bachelor's thesis; more on the theory than the applied side. Do you have some interesting ideas?
06:42:18 <identity> So I'm trying to create a FromJson instance for a newtype Foo a = Foo { unFoo :: Either [Text] a }. Basically, I want to parse "errors" from the json data and return Foo (Left errors) if there are any. Else return Foo $ Right (parsed data)
06:43:06 <identity> But it says it can't deduce the type from attempting to parse the errors, even though it is being used farther on, which I figured would disambiguate the type
06:47:22 <maxiepoo> is there an automated tool that will enforce things like alphabetical/aligned import statements? I vaguely remember seeing something like this but now I can't find it. Also I don't think it was hlint
06:50:12 <sopvop> stylish-haskell
06:51:05 <maxiepoo> aha that's it! thanks
07:00:16 * hackagebot reflection 1.4 - Reifies arbitrary terms into types that can be reflected back into terms  http://hackage.haskell.org/package/reflection-1.4 (EdwardKmett)
07:06:56 <dareTake> Hi, I was going through LYAH, and the part about Foldable confuses me
07:06:56 <markovirc_> Hello dareTake
07:07:24 <dareTake> There is an instance of a tree for Foldable.
07:07:49 <dareTake> and the book used it like F.foldMap (+) 0 tree
07:08:14 <sopvop> :t foldMap
07:08:15 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
07:08:19 <dareTake> where the tree is data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show)
07:08:58 <dareTake> How is (+) of type (a->m) ?
07:09:20 <sopvop> > (1 +) <> (2 +) $ 0
07:09:21 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
07:09:22 <lambdabot>    arising from a use of `e_1120'
07:09:22 <lambdabot>  The type variable `a0' is ambiguous
07:09:22 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
07:09:22 <lambdabot>  Note: there are several potential instances:
07:09:39 <sopvop> hm
07:09:43 <k00mi> LYAH covers Foldable?
07:09:48 <dareTake> yea
07:10:09 <dareTake> are functions monoids?
07:10:13 <tangentstorm> perhaps because ((+) 0) :: (a->a)
07:10:25 <k00mi> dareTake: can you post a link?
07:10:35 <tangentstorm> i just learned that -> is a monad... so perhaps it is also a monoid :)
07:10:44 <dareTake> k sure , gimme a min
07:11:02 <k00mi> dareTake: functions whose result types are monoids are monoids
07:11:23 <k00mi> that is: instance (Monoid b) => Monoid (a -> b) where ...
07:11:32 <ciaranm> functions whose result types are some kind of algebra are some potentially weaker kind of algebra
07:11:34 <tangentstorm> in which case (+)::(a -> a -> a)  matches (a -> m)
07:11:41 <dareTake> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids
07:11:50 <dareTake> should be at the last
07:12:25 <dareTake> but are numbers monoids?
07:12:36 <johnw> integers are two kinds of monoid: Sum, and Product
07:12:38 <dareTake> i mean the value of the tree are numbers
07:12:46 <ciaranm> johnw: only two?
07:12:52 <dareTake> but those are with newtypes right?
07:12:52 <johnw> well, in Haskell's base library
07:13:09 <johnw> there are infinite numbers of monoids over integers, once you start considering submonoids, etc.
07:13:16 <k00mi> dareTake: that's F.foldl there, not foldMap
07:13:21 <k00mi> F.foldl (+) 0 testTree
07:14:40 <dareTake> guess I'm confused again, F.Foldl used F.foldMap?
07:14:48 <dareTake> er uses*
07:15:18 * hackagebot ekg 0.3.1.4 - Remote monitoring of processes  http://hackage.haskell.org/package/ekg-0.3.1.4 (JohanTibell)
07:15:19 <paulschellin> So I've been reading "Generic Storage in Haskell" by Sebastiaan Visser (published ~3 to 4 years ago) and I'm curious as to whether anyone has implemented any of the concepts (introduced?) in that paper, or if there are more effective ways to maintain morphisms of Traversable structures?
07:15:28 <tangentstorm> @src F.Foldl
07:15:29 <lambdabot> Source not found. It can only be attributed to human error.
07:15:40 <k00mi> dareTake: it's part of the Foldable type class but has a default implementation
07:15:48 <k00mi> that uses foldMap
07:16:55 <dareTake> import qualified Data.Foldable as F
07:17:46 <dareTake> hmm k thnx, just needs to clear my head a bit. Too many terms :D
07:18:08 <k00mi> no problem :)
07:18:28 <k00mi> Data.Foldable.foldl is exactly a generalized Prelude.foldl
07:21:49 <sfvisser> paulschellin: Parts of it were implemented, I had a working prototype of the fingertree on disk. But it was never more than a prototype.
07:22:21 <sfvisser> paulschellin: no idea what state it is in, but the code is here: https://github.com/sebastiaanvisser/islay
07:22:37 <paulschellin> sfvisser: I've been reading through that implementation. After you defended, did you move on to other projects?
07:23:02 <sfvisser> Yeah, I found a job :-)
07:23:24 <dareTake> foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z  for the src
07:24:00 <dareTake> so when I define foldMap in an instance, I can use foldl. How does foldl use the foldMap ?
07:24:24 <dareTake> I can't understand anything in the source though
07:25:55 <paulschellin> sfvisser: I'm attempting to write a file system, and your work seemed like it was a very useful tool for my purpose. Do you think that it's in my interest to try your generalized approach, or do you think it will be less work and less mess to manage every representation separately?
07:26:23 <johnw> dareTake: foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
07:26:46 <dareTake> could you tell me what that means?
07:27:05 <johnw> well, in this case it means that foldl can be implemented in terms of foldMap :)
07:27:12 <johnw> I leave what it's doing to your research
07:27:14 <k00mi> dareTake: Endo is the Monoid for function composition, so what that line does is, it builds a chain of composed functions and in the end it applies the zero value
07:27:15 <sfvisser> paulschellin: hard to tell. My conclusion was that writing every operation on your datatype as an f-algebra is hard.
07:28:12 <sfvisser> paulschellin: I'm still playing around with composability of f-algebras for fun a bit, but I'm not sure this will ever be 'the true way' to write algorithms for recursive data types.
07:28:26 <dareTake> ah ok, (Dual . Endo . flip f) must be (a->m)
07:29:10 <dareTake> k thnx guyz, I'll check out those  funcs
07:31:40 <paulschellin> sfvisser: I imagine my mathematical intuition isn't quite up to the challenge at the moment, but I'll probably play around with the idea for a couple of days to decide if I will take that route. I might be back later this week stumped and with questions, if you are available.
07:33:09 <sfvisser> paulschellin: sure. I'm not that active on IRC. Feel free to send me an e-mail if you have questions.
07:33:34 <ronbrz> set_conf_mode 1
07:36:13 <identity> http://lpaste.net/99213 <- some issues with defining a FromJSON instance with a newtype wrapping either. Anyone care to take a look?
07:36:30 <paulschellin> sfvisser: Thanks! It's cool that you happened to be on the channel when I asked my questions, I can't say I expected the author to answer!
07:39:16 <bergmark> identity: there is no FromJSON instance for Either
07:39:27 <identity> ah. I see
07:39:42 <identity> I can't create a specialized instance for only Either SomeConcreteType a
07:39:57 <sfvisser> paulschellin: I wasn't really on the channel to be honest, a coworker warned me someone mentioned me :-)
07:40:07 <bergmark> you could, but i think that instance was left out for a reason
07:40:15 <sfvisser> small world
07:42:16 <prophile> how would FromJSON work for, for instance, Either Int Int
07:43:10 <ion> With evilness such as [False, 42], [True, 42]? :-P
07:43:26 <ion> {'left': 42}, {'right': 42}
07:44:07 <bergmark> i wouldn't want aeson to decide on that format for me
07:45:25 <ion> A fair point, but OTOH one is free to refrain from using the instance just as she does right now as no such instance exists.
07:46:13 <ion> My reason for not wanting the instance is that all the possible JSON representations are nasty. :-P
07:47:17 <ion> Oh, huh. An instance does exist. /me looks at which representation it uses
07:47:33 <identity> prophile: Yeah, I can see why it's strange
07:47:42 <identity> oh?
07:48:01 <Twey> The boolean one isn't *nasty* (it's basically just a tagged union like Either is internally anyway); it's just a bit arbitrary in the representation of the tag
07:48:18 <identity> I just need a type to represent failure with errors and success with data
07:48:29 <identity> for which I guess I can just roll my own type, which I am doing
07:48:45 <ion> It seems to use {"Left": 42}, {"Right": 42}
07:48:48 <bergmark> oh wow i missed it somehow
07:48:51 <Twey> Another option is [null, 42] vs. [42, null]
08:10:05 <HugoDaniel> how can i transform (Maybe (Maybe a)) into Maybe a ?
08:10:30 <SimonJF> join
08:10:33 <Maior> @hoogle m m a -> m a
08:10:33 <lambdabot> Control.Applicative.Backwards forwards :: Backwards f a -> f a
08:10:33 <lambdabot> Data.Functor.Reverse getReverse :: Reverse f a -> f a
08:10:33 <lambdabot> Control.Monad.Trans.Identity runIdentityT :: IdentityT m a -> m a
08:10:38 <HugoDaniel> ahh cool :D
08:10:50 <Maior> bah
08:10:59 <Maior> :t join
08:11:00 <lambdabot> Monad m => m (m a) -> m a
08:14:36 <shackleford_> Which GUI toolkits do you like to use for haskell?
08:16:19 <identity> shackleford_: you would probably be best off with the browser one
08:16:24 <identity> the name eludes me right now
08:16:27 <rayman_> hi all. What is Future type from reactive-banana. What does it means?
08:16:48 <identity> shackleford_: threepenny-gui
08:16:56 <andresrtm> hey folks! any help with haskell ... I do not want to write a lot ... http://lpaste.net/99215
08:17:11 <shackleford_> identity: https://hackage.haskell.org/package/threepenny-gui this one?
08:17:15 <identity> shackleford_: yes
08:17:29 <shackleford_> identity: I'll give it a try. Thanks.
08:17:29 <identity> it seems it's the one to use these days. wxhaskell bindings are a pain as I understand and gtk isn'tm uch better
08:17:56 <identity> andresrtm: hmm?
08:18:15 <identity> map makePhoto ourTeam will create a list of html, yes.
08:18:34 <mr-> shackleford_: depending on your needs, gloss may be good
08:18:54 <kqr> andresrtm, you probably want mapM_
08:18:59 <kqr> andresrtm, and not map
08:18:59 <mr-> andresrtm: maybe something like mapM ?
08:19:02 <identity> andresrtm: maybe you want mapM?
08:19:03 <identity> yeah
08:19:12 <identity> or mapM_ yes
08:19:26 <shackleford_> While the topic is up, what's the difference between mapM and mapM_?
08:19:36 <mr-> :t mapM
08:19:37 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
08:19:38 <mr-> :t mapM_
08:19:39 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
08:20:00 <mr-> notice the "m ()" in mapM_'s type. You don't get to use the results of your actions.
08:20:07 <identity> shackleford_: one performs computations in a monad and returns the results of those. The other just executes the effects of the computations and discards the results
08:20:23 <shackleford_> I really need to start checking those myself. Thanks, guys!
08:22:02 <andresrtm> yeah! mapM and mapM_ works ! :D
08:33:21 <Rflax40> Hello!
08:33:22 <markovirc_> Hello Rflax40
08:40:31 <mr-> Hi
08:40:32 <markovirc_> Hello mr-
08:40:59 <Rflax40> Hey, Anyone have a recommendation on where to learn Haskell, with previous knowledge of Java?
08:40:59 <markovirc_> Hello Rflax40
08:41:08 <johnw> @where lyah
08:41:09 <lambdabot> http://www.learnyouahaskell.com/
08:42:30 --- mode: ChanServ set +o geekosaur
08:42:37 --- mode: geekosaur set +b *!*markovirc@67.43.244.*
08:42:37 --- kick: markovirc_ was kicked by geekosaur (markovirc_)
08:42:48 --- mode: geekosaur set -o geekosaur
08:43:00 <Clint> did it ever once produce a markov chain?
08:43:25 <monochrom> the constant chain is a degenerate markov chain, too :)
08:43:25 <geekosaur> not so far as I have seen; probably just collecting data. which would have been fine except for the noise
08:43:35 <aleksejs_> Hi, is there a way to differ ajax from non-ajax requests with happstack?
08:44:29 * geekosaur admits to be not quite fully awake and a bit grumpy though
08:45:05 <Maior> aleksejs_: why do you care?
08:46:02 <aleksejs_> Maior, because I want to give different responses if it is ajax or non-ajax request
08:46:19 <Maior> that sounds horrible
08:46:39 <aleksejs_> ?
08:47:45 <Maior> aleksejs_: I mean, this is somewhat OT, but why?
08:50:23 <aleksejs_> fo example, user requests /foo/bar with ajax, he will get only response as json string, but if he opens url /foo/bar, the whole page will be loaded and then ajax request to /foo/bar will be sent
08:51:21 <colDrMcBeardman> markvshaney did a much better job.
08:52:16 <Maior> aleksejs_: read about the HTTP Accept header, serve different content accordingly
09:01:34 <k_bx> Hi everyone! Which type class should I use for a data type that can be merged and has "zero"? Something like a monoid except it isn't parameterised by a type. Thanks!
09:02:44 <Peaker> k_bx: a monoid instance isn't parameterized by a type, what do you mean?
09:03:15 <Iceland_jack> k_bx: Are you simply looking for Maybe?
09:03:31 <Iceland_jack> where zero = (mzero :: Maybe a)
09:03:36 <ion> maybe
09:03:45 <Iceland_jack> > mzero :: Maybe a
09:03:46 <lambdabot>  Nothing
09:04:08 <k_bx> @Peaker sorry, I'm getting crazy, you're right
09:04:09 <lambdabot> Unknown command, try @list
09:04:44 <Fuuzetsu> maybe he wants Alternative
09:04:45 <k_bx> @Iceland_jack no, I think I'm looking for a Monoid (I have "mergeable" data)
09:04:45 <lambdabot> Unknown command, try @list
09:05:29 <Iceland_jack> k_bx: To direct a message to a user you should prefer ‘<nick>:’ to ‘@nick’
09:05:32 * hackagebot unbound 0.4.3 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.4.3 (BrentYorgey)
09:05:32 <quchen> Are typed holes even an extension as of a couple of days ago? Did I read the commit right that it's just another compiler warning feature now?
09:05:48 <Fuuzetsu> quchen: it's no longer an extension, it's on by default
09:05:51 <k_bx> Iceland_jack: got it, terribly sorry
09:05:56 <ski> Iceland_jack : or with no angle brackets either
09:06:23 <Iceland_jack> ski: right, I meant to use <nick> as a placeholder but forgot it in the latter example
09:06:27 <Iceland_jack> k_bx: don't be terribly sorry :)
09:06:46 <quchen> Fuuzetsu: I thought it was turned into an on-by-default extension, that's why I was surprised to see it as a -f flag
09:07:03 <quchen> Anyway: neat! :-)
09:07:05 <bergmark> k_bx: merging may not have an identity element, so you may have just a semigroup
09:07:06 <Fuuzetsu> no, it was just removed as an extension all together
09:07:32 <ski> (Iceland_jack : i mentioned it because i've seen people direct messages in that way. it because very confusing since it looks like they are quoting the other person all the time)
09:07:44 <ski> (s/because/becomes/)
09:08:13 <Fuuzetsu> ski: That substitution doesn't make sense…
09:08:35 <Iceland_jack> s/because very/becomes very/? :)
09:08:36 <Fuuzetsu> Oh, there was a second ‘because’.
09:08:45 <Fuuzetsu> That is better however.
09:09:04 <Iceland_jack> Some clients display messages as
09:09:04 <Iceland_jack>     <nick> foo bar
09:09:04 <Iceland_jack> so that may be why
09:09:37 * Fuuzetsu is about to write a client and that's how it'll be
09:09:50 <k_bx> bergmark: thanks for pointing there! I think I should have an identity, but if not -- I'll use semigroups.
09:10:03 <quchen> @quote incompatible
09:10:03 <lambdabot> kmc says: Haskell is a language where the community observes that there are 50 incompatible error handling monads, and the response is 50 incompatible packages for generically handling all error handling monads
09:10:15 <quchen> s/error handling monads/irc clients/
09:10:31 <Fuuzetsu> quchen: This is for Yi so there are precisely 0 ;)
09:11:55 <Fuuzetsu> there only seem to be 3 IRC libraries on hackage anyway
09:12:08 <Fuuzetsu> oh okay, ignore that
09:12:36 <quchen> Plus 3 libraries for generically handling IRC libraries?
09:13:04 <Fuuzetsu> it's not as bad as one would expect from such a… hmm… entry-level project
09:13:06 <Fuuzetsu> https://hackage.haskell.org/packages/search?terms=irc
09:13:40 <quchen> What confused me quite a bit was the crypto libs. A bad IRC lib is annoying, a bad crypto lib is dangerous, and I can't really tell which one to trust.
09:13:43 <Fuuzetsu> at least I'm not rolling my own
09:13:52 <quchen> Plus the more trustworthy-sounding ones were incompatible with each other. :-)
09:14:23 <Fuuzetsu> Ffft, here I thought I'll get away with trying to build a package from 2010!
09:16:27 <klatch> I'm working on an IRC client that's gonna blow yer minds!
09:16:42 <Fuuzetsu> sure
09:17:23 <klatch> it's colourful like a bag of M&Ms and has pretty lambdas
09:17:29 <monochrom> an IRC client cannot blow one's mind
09:17:55 <monochrom> at least, not my mind. perhaps I'm simply not easily impressed.
09:17:55 <hvr> klatch: ...does that mean I have to be color blind to be able to use it? :)
09:18:34 <klatch> well, it depends on the mind! https://www.dropbox.com/s/5q6ezsueddxxu8o/klatch%20haskell.png
09:18:46 <monochrom> I guess unless the IRC client comes with a scripting language that is strictly more powerful than Turing machines or lambda calculus.
09:18:54 <Fuuzetsu> I thought I had colours turned off in my client (or rather they weren't on by default) until some idiot came into -blah
09:19:11 <hvr> monochrom: maybe it could analyze your communication patterns via markov-chains, and auto-generate conversations for you while you're afk
09:19:35 <Fuuzetsu> hvr: will it also respond to bug reports?
09:19:39 <monochrom> that would blow my mind 10 years ago. today it's rather standard fare.
09:20:00 <hvr> Fuuzetsu: sure, there's always something compassionate you can say when you get a bug report
09:20:12 <Fuuzetsu> WontFix
09:20:15 <Fuuzetsu> close ticket
09:20:21 <Fuuzetsu> restrict comments
09:20:34 * hackagebot pontarius-xmpp 0.3.0.3 - An XMPP client library  http://hackage.haskell.org/package/pontarius-xmpp-0.3.0.3 (JonKristensen)
09:20:39 * quchen takes note that iff he discovers strong AI, he has to make it into an impressive IRC client to amaze Monochrom and possibly prove him wrong about the necessity of needing a better-than-Turing IRC client to be amazed
09:21:54 <rayman_> hey. How to convert Behavior to Event in reactive banana? 'changes' not works :(
09:21:58 <monochrom> oh quchen, the problem is that an intelligent autonomous client is indistinguishable from a today's client plus a human. and I've seen the latter for 20 years.
09:21:58 <hvr> quchen: I'm sure we'll find all sorts of inadequate applications for a strong AI ;)
09:22:52 <klatch> the way to blow minds with an IRC client is just to be somewhat better than 20 year old curses programs, no?
09:22:53 <hvr> (we'd just have to make sure the AI doesn't fight against being used that way)
09:23:16 <monochrom> similar to being impressed by something strictly more powerful than Turing machines because I've already seen enough Turing machines, I am impressed by superhumans because I've already seen enough humans and their stupidity
09:23:17 <quchen> monochrom: Now you're laughing, but when the world is overrun with Terminators because of my client let's see about that!
09:23:50 <hvr> quchen: and those Terminators will all be rfc2812 compliant? =)
09:23:56 <monochrom> it is not enough for your IRC client to be on par with humans. it has to be smarter than humans. it has to prove more theorems, for example.
09:24:19 <monochrom> it has to teach me agda
09:24:30 <monochrom> it has to invent a better language than agda
09:24:49 <Fuuzetsu> would IRC client in Agda be good enough?
09:25:01 <hvr> monochrom: if it takes away all the fun, what's left there for you to do then?
09:25:06 <quchen> It's going to bootstrap an Agda compiler written in a subset of Agda where type inference is decidable (yeah let's make it >Turing while we're discussing fancy things)
09:25:17 <quchen> Wait, subset wouldn't work for that very well.
09:25:21 <quchen> Call it Bgda.
09:25:42 <monochrom> hvr: you get it backwards. it gives you all the fun, not takes away.
09:26:10 <hvr> monochrom: ok, but if it implements everything you'd want implemetned, there's nothing left for you to implement, is there? :)
09:26:14 <monochrom> cars run faster than you. the invention of cars is when running becomes a fun activity, not a dreadful duty
09:26:46 <klatch> when IRC chatting is finally fully automated, we will be free to enjoy our leisure time by just programming
09:26:51 <quchen> 150 years ago people had to run to buy groceries, run to get to work, run silently to not wake up the neighbours at night. Dark times
09:27:23 <hvr> and they had no lolcats
09:27:31 <quchen> Good times
09:27:32 <monochrom> before cars, running was a job, in fact a fatal one too. look at that guy who ran the first marathon. it was a messenger job, and it cost his life. today, marathons are fun sports because we already have cars for the job kind.
09:28:03 <monochrom> similarly, if computers could write programs, then programming would become fun sports not resentful jobs for us
09:28:21 <hvr> monochrom: ok, but wouldn'
09:28:28 <hvr> t some of the challenge be missing?
09:29:06 <monochrom> what challenge? do you miss some of the challenge of running?
09:29:13 <hvr> I don't run :-)
09:29:15 <zrho> Programming isn't a fun sport?
09:29:39 <quchen> monochrom: There's no DRY for running.
09:29:47 <monochrom> what is DRY?
09:29:52 <quchen> Don't repeat yourself.
09:29:55 <trideon> you get WET while running sadly
09:30:05 <quchen> The thing where you don't want to do things that others have done sufficiently well already.
09:30:13 <monochrom> um, I thought running was full of repetition
09:30:25 <quchen> Yes, and in programming you try to avoid it.
09:30:48 <quchen> I mean you can only program that many cool programs that others have written already, until you feel like making something new.
09:31:07 <quchen> In other words, I like to produce entropy with my programs.
09:31:21 <monochrom> you are imposing a limit on yourself
09:31:30 <quchen> A lower limit! :-þ
09:31:45 <klatch> all the programs I need are pretty much done already.  I'm not sure why we're still messing around with computers so much
09:31:56 <monochrom> I for one enjoy reinventing programs that smarter people have already invented. I find it fun. I also use it for learning.
09:32:15 <monochrom> I don't sell it as new, no. but it's my own sport.
09:32:17 <Sculptor> klatch, because there's a lot of  crapware
09:33:45 <monochrom> I don't hear arguments like "those Olympic splinters have already run better than you, why are you repeating their work and inferiorly?"
09:34:58 <Maior> monochrom: <3
09:35:27 <monochrom> I definitely don't hear arguments like "cars already run better than you, why are you running?"
09:35:29 <zrho> Although I would have liked to hear that back in school sports; never was a fan of running.
09:36:01 <monochrom> so now just change "cars" to "automatic programmers" or "automatic provers" or whatever.
09:37:51 <monochrom> really, that DRY thing is only because programming is still a job, someone is paying you to get the job done, you DRY just because the payer wants to pay less or you want to be more ethical
09:38:25 <monochrom> for sports, you RY all the time. just look at all the programming contests
09:38:50 <monochrom> N contestants means you are RY N times. that's sports for you.
09:38:54 <zrho> Hm, well. Rewriting something for the sake of learning is not a violation of DRY.
09:38:54 <klatch> on a related note, I think it's very nice to have Haskell variants of common software that people use daily
09:39:20 <klatch> for example, it seems to me that xmonad has been very good for the Haskell community!
09:39:45 <Iceland_jack> I'm pleasantly surprised by how many non-Haskellers use and love XMonad
09:39:49 <klatch> that's of course also a high-quality piece of software regardless of language advocacy
09:40:19 <Kaidelong> debuildDamage ds = do {e,(d,f) <- Data.Map.toAscList(ds) ; when (d /= 0) (Base e d) `mplus` when (f /= 0) (Scaling e f)}
09:40:25 <Kaidelong> does this style offend anyone?
09:40:36 * hackagebot arb-fft 0.2.0.0 - Pure Haskell arbitrary length FFT library  http://hackage.haskell.org/package/arb-fft-0.2.0.0 (IanRoss)
09:40:47 <Kaidelong> not sure if people generally work with lists like this
09:40:52 <Kaidelong> and if not, what they do instead
09:40:59 <monochrom> it does not offend me. I did it myself.
09:41:24 <monochrom> http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.hs
09:42:03 <monochrom> also, admire how doc and comments are 5 times more than code :)
09:42:22 <Kaidelong> I actually consider that a good sign
09:42:23 <monochrom> hmm, maybe 10 times too, I suck at counting
09:42:47 <Kaidelong> having little code means the underlying abstractions are probably good
09:43:10 <Kaidelong> also easier to test each individual documented bit
09:43:35 <Kaidelong> well maybe not for black box testing, but definitely for white box testing
09:46:30 <bitemyapp> comment/code ratios have more to do with conceptual/abstractive density than any universal notion of quality.
09:46:51 <bitemyapp> it might be an advantage, it might be a disadvantage. Hard to draw any hard/fast conclusions that will work universally based only on those properties.
09:48:48 <Kaidelong> bitemyapp: I'd say that when it's not a good sign there will be some corresponding section of code that is very verbose, generally
09:49:24 <Kaidelong> a lot of the productivity of PHP is rooted on complex subroutine invocations rather than good abstractions, but you can see that in the C libraries that PHP invokes
09:51:06 <aleksejs_> could anyone help me? http://vpaste.net/dnYil why route "comment" doesn't work neither with nor without that header set?
09:51:38 <aleksejs_> it works if I remove that part with getHeaderM
09:53:06 <sm> klatch: that sounds cool, it'd have to be extraordinary to pry me away from erc though
09:54:09 <klatch> sm: yeah, I used to use erc (and then rcirc), it's of course nice to remain in Emacs-land!
09:54:23 <sm> are you aiming to target non-emacs, non-gui irc lovers ?
09:56:08 <klatch> sm: basically targeting myself. there's a kind of "mission statement" at https://github.com/mbrock/klatch
09:56:54 <klatch> sm: also want to do things like "daily digest" of certain channels, good searchable logs, etc
09:57:23 <sm> cool
09:57:32 <sm> woah, rabbit mq
09:57:43 <bitemyapp> Kaidelong: well easy vs. simple, right? the subroutine invocations are "easy" and "easy to understand" but can't be stretched beyond their original purpose.
09:58:21 <sm> for persistent irc I use dtach+emacs+erc.. but emacs does crash pretty easily, so +1 to your goal
09:58:29 <bitemyapp> Kaidelong: other programming communities are more accustomed to being given a lego set of building blocks and coming up with whatever they need, the problem is that making that leap of understanding is something that has to be learned and gives people new to Haskell from other langs a spot of trouble.
09:58:49 <bitemyapp> sm: I'm lazy, so despite being an Emacs users, I use GNU Screen + irssi for my IRC.
09:58:53 <bitemyapp> user*
09:59:06 <Kaidelong> I came from .NET and there are lots of good abstractions there so Haskell was very familiar in that regard
09:59:57 <bitemyapp> Kaidelong: I used to work in .NET, I don't really remember many people leveraging any of that.
10:00:13 <bitemyapp> Kaidelong: except for the two guys in the office that were really excited about LINQ.
10:00:14 <platz> Kaidelong: I'm from .Net too.  There are a few good abstractions, but there are a lot of leaky ones too.
10:00:48 <Kaidelong> platz: the same is true of haskell, really
10:00:59 <klatch> sm: it should be usable within a couple of weeks :)
10:01:12 <Kaidelong> platz: Data.Set makes me sad
10:01:14 <bitemyapp> klatch: is RabbitMQ the only form of persistence?
10:01:29 <bitemyapp> if it can even be called that.
10:01:37 <skypers> hey, how I could a make my parser which Stream = String to (Stream s m Char) => s?
10:01:53 <skypers> I use reads in my parser
10:02:08 <platz> Kaidelong: hrmm.. is this the "containers with constraints" issue?
10:02:16 <Kaidelong> yes
10:02:20 <klatch> bitemyapp: weeell, no, there's a persistent store of the event log. unfortunately it's a file with a JSON array
10:02:28 <bitemyapp> klatch: ;_;
10:02:51 <Kaidelong> especially given that the Ord constraint isn't actually what Set needs, it's closer to Typeable, but Ord is nicer when it is available
10:02:53 <klatch> bitemyapp: that should obviously be replaced but it's convenient as a bootstrap
10:02:56 <bitemyapp> klatch: I use Datomic at work, so I'm on board with the historical data thing, but it would be really nice if there were practical immutable data stores for embedded and deployed use.
10:03:12 <platz> ord does seem odd on a set
10:03:27 <bitemyapp> does acid-state have an immutable/historical dipswitch?
10:03:29 <AncientPC> I have a simple typeclasses question on how to derive an instance of fromIntegral: http://lpaste.net/4440452887880925184
10:03:52 <Kaidelong> it's exposed implementation detail, I blame it on the fact that haskell cannot really encapsulate things properly due to the way its parametric polymorphism works
10:03:57 <Kaidelong> although I guess there are existential types
10:04:08 <skypers> ok I might need to keep stream set to String
10:04:13 <klatch> bitemyapp: in my case I could just acid-statify a [Event] value, basically -- the data format is extremely simple
10:04:30 <bitemyapp> klatch: that seems a nicer bootstrap than smashing a JSON file :)
10:04:36 <AncientPC> I'm not sure how to derive fromIntegral from a simple data constructor (e.g. data Person = Age Int)
10:04:42 <bitemyapp> klatch: but I don't really like/want language specific data stores.
10:04:53 <platz> Kaidelong: what makes me sad is how we tell everyone haskell is referentially transparent, but due to unsafePerformIO, "Haskell programs are not typically built from 100% referentially transparent code, however, it is the only moderately common language that is pure by default." - don stewart.  So we should be telling folks, only the stuff you build from *scratch* is referentially transparent.  And I think most devs expect to use othe
10:04:54 <bitemyapp> klatch: I'd like something more general than that for historical data/OLTP.
10:04:57 <byorgey> AncientPC: you need to make an instance of Integral for Person
10:05:05 <klatch> bitemyapp: I'm internet-deprived at home, so some of my design choices revolve around not having hackage access when the inspiration strikes :)
10:05:08 <Kaidelong> AncientPC: Functor is derivable with an extension, I'm pretty sure
10:05:15 <bitemyapp> klatch: weird. Okay.
10:05:15 <Kaidelong> oh
10:05:19 <byorgey> AncientPC: instance fromIntegral Age does not make sense, since fromIntegral is not a type class
10:05:28 <Kaidelong> that's not importance
10:05:53 <byorgey> AncientPC: also, Age is a data constructor for Person, not a type
10:05:54 <ski> AncientPC : why do you think it makes sense to add,subtract,multiply, and divide-with-remainder persons ?
10:06:04 <Kaidelong> @ty let data Person = Age Int in fromIntegral . Age
10:06:05 <lambdabot> parse error on input `data'
10:06:10 <Kaidelong> not allowed?
10:06:12 <Kaidelong> oh well
10:06:22 <skypers> what do you think of parsec-numbers?
10:06:23 <AncientPC> ski: it's a contrived example for learning purposes
10:06:25 <geekosaur> that question is just so confused
10:06:25 <byorgey> AncientPC: also also, Num is a type class, not a type.
10:06:26 <Kaidelong> @ty fromIntegral . fromIdentity
10:06:26 <lambdabot>     Not in scope: `fromIdentity'
10:06:26 <lambdabot>     Perhaps you meant `runIdentity' (imported from Control.Monad.Identity)
10:06:31 <Kaidelong> @ty fromIntegral . runIdentity
10:06:32 <lambdabot> (Integral b, Num c) => Identity b -> c
10:06:52 <Kaidelong> does lambdabot know about copointed?
10:06:58 <AncientPC> byorgey, Kaidelong: thanks, it looks like I'm misunderstanding a lot of Haskell concepts. Time to review type classes *again*. D:
10:07:07 <klatch> bitemyapp: at some point I'll look into making other storage backends... I dunno, couchdb or something? haven't thought about it that much
10:07:13 <ski> AncientPC : if you really wanted this, then s/data/newtype/
10:07:36 <klatch> bitemyapp: love the concepts behind datomic, but it's not really suitable for open source projects, right?
10:08:04 <bitemyapp> klatch: I don't think that's true.
10:08:15 <bitemyapp> klatch: it's perfectly suitable, the real problem is talking to it from a non-JVM language.
10:08:47 <ski> AncientPC : btw, perhaps you really wanted something like `data Person = MkPerson {age :: Int,name :: String,...}' in your case
10:08:53 <bitemyapp> klatch: we released the REST wrapper we're using at work so we can talk to Datomic from Python et al, but it's a bit like breathing through a straw.
10:09:59 <platz> Kaidelong: so after reading [1], I have to conclude this referential transparency business is the most leaky abstraction.  Of course I want these guarantees in working applications, not just thought experiments with throwaway code!  [1] http://stackoverflow.com/questions/3124591/is-haskell-really-a-purely-functional-language-considering-unsafeperformio
10:10:40 * hackagebot git-annex 5.20140129 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140129 (JoeyHess)
10:10:46 <geekosaur> unsafePerformIO is not something people should use generally
10:11:04 <bitemyapp> klatch: Don't use couchdb :(
10:11:08 <geekosaur> of course if you consider it normal then all the guarantees evaporate and you're left with an impure language
10:11:11 <platz> yet it seems people do
10:11:13 <Kaidelong> platz: actually unsafePerformIO is probably one of the better examples of something useful that is also dangerous
10:11:20 <bitemyapp> klatch: I've been thinking about ways to turn PostgreSQL into a pseudo-historical store.
10:11:49 <Kaidelong> platz: the philosophy in haskell seems to be that if you intentionally break the abstractions bad things happen, so use stuff that can break it with care, as far as I'm concerned this mentality is fine
10:12:02 <geekosaur> the reasons people use unsafePerformIO are (a) it's the only way to declare a particular FFI function to actually be pure; (b) as a performance hackaround
10:12:10 <Kaidelong> it's similar to old LISPs where you weren't prohibited from setting true to false but you really shouldn't
10:12:29 <platz> I don't mind keeping my code pure, but how many acutally  applications will be written without using anyone else's code?
10:12:33 <geekosaur> (c) because they're trying to write impure code and are in effect deliberately turning off pure functional
10:13:03 <geekosaur> ((c) is usually done by people who can't think pure functional yet and are flailing)
10:13:22 <Kaidelong> geekosaur: (c) actually should be avoided, if you are doing impure code, unsafePerformIO can break sequencing
10:13:38 <Kaidelong> unsafePerformIO is better thought of as "assertPure"
10:13:48 <Qett> is there a way to test if a certain functon is lazy?
10:14:37 <platz> http://www.haskell.org/haskellwiki/Top_level_mutable_state - argues there are valid uses for unsafePerformIO
10:14:40 <Kaidelong> geekosaur: IIRC, using unsafePerformIO instead of IO has undefined behavior
10:15:04 <Kaidelong> (except if unsafePerformIO is being used to expose a pure value)
10:15:08 <geekosaur> Kaidelong, did you even notice my addendum, or are you using me as a rubber duckie?
10:15:39 <Qett> oh i found the answer, should have googled first
10:15:46 <Kaidelong> geekosaur: I dunno if it can be said it's a crutch, people who are using it because they can't think pure function should be using IO and not unsafePerformIO, period
10:16:02 <platz> "We could trust programmers to do the right thing, restricting themselves to sensible IO actions like newIORef. -> Objections: This breaks Haskell's tradition of bondage and discipline."
10:16:24 <geekosaur> Yes, they should, but I'm talking about the folks who are still stuck at the "what do you mean I can't get the Int out of an IO Int?" stage
10:16:52 <Kaidelong> those newbies should be told in no uncertain terms not to touch unsafePerformIO =(
10:16:52 <geekosaur> point being that (c) is a beginner who's wandered off the path completely
10:16:59 <Kaidelong> that's how I was taught
10:17:06 <geekosaur> yes, exactly
10:17:07 <seliopou> geekosaur it's silly to contemplate use cases like that when discussing the merits of unsafeperformio
10:17:20 <geekosaur> I did not say anything about merits
10:17:32 <seliopou> what did you say then?
10:17:41 <Kaidelong> the problem with it is that it's not even correct, someone using unsafePerformIO for (c) is likely to get surprised
10:17:54 <Qett> wait but you can get an int out of IO int..
10:17:56 <Kaidelong> confusing them even more than if they stuck to IO
10:18:01 <Qett> with >>= and such
10:18:02 <Qett> right
10:18:03 <etandel> If no one should ever use unsafePerformIO, why does it exist? Isn't it like the Tree of Knowledge of the Garden of Eden?
10:18:07 <geekosaur> I was mentioning when it does get used, and aparently failingt o strongly hint that (c) is nonsense and (b) is only for use by people who know exactly what they are doing (and are working around what amounts to compiler deficiencies)
10:18:21 <Kaidelong> etandel: it has legitimate uses
10:18:25 <platz> etandel: see the "top level mutable state" i linked above
10:18:39 <bitemyapp> etandel: some people, in certain rarefied cases, will need it.
10:18:50 <geekosaur> unfortunately you do see (c), see the current thread on -cafe fr example
10:18:51 <etandel> platz: I just joined the channel, can you link it again?
10:19:00 <platz> http://www.haskell.org/haskellwiki/Top_level_mutable_state
10:19:02 <etandel> thx
10:19:04 <bitemyapp> etandel: better to have it and not need it, but that doesn't mean you shouldn't redirect people away from mutation so that they don't get the wrong idea about how to write nice Haskell code.
10:19:07 <seliopou> geekosaur: my observation has been that whenever anybody asks about unsafeperformio they get thrown into bucket (c)
10:19:30 <Kaidelong> etandel: when dealing with foreign libraries it's actually quite normal to need it too, because the haskell type system can't inspect non-haskell stuff for purity and just assumes it is impure unless you use unsafePerformIO to hint to the type system that it is in fact pure
10:19:47 <etandel> ohhh
10:19:49 <etandel> i see
10:19:59 <platz> bitemyapp: my point is that even if you resolve to remain pure, as soon as you want to take advantage of the cabal ecosystem all bets are off
10:20:17 <Kaidelong> platz: I have not found that to be the case in practice
10:20:25 <bitemyapp> platz: you're making purity out to be something like virginity, once lost, is gone forever.
10:20:27 <geekosaur> seliopou, that's because (c) is by far the most common reason people do ask about it.. .which is why I included it
10:20:29 <bitemyapp> platz: that's not the way I see it.
10:20:37 <geekosaur> it's a newbie trap :(
10:20:40 <bitemyapp> platz: I just want type-annotation dirtiness, not code-virginity.
10:20:45 <bitemyapp> type-annotated*
10:20:54 <geekosaur> unforutnately, since there are valid uses for it, you can't get away with just hiding it from everyone
10:21:11 <platz> then thats great, i just think the message to newcomers is dishonest
10:21:16 <bitemyapp> I don't really care what other people do in their libraries for efficiency's sake as long as it doesn't damage the referential transparency of my code.
10:21:19 <bitemyapp> and in general, it doesn't.
10:21:20 <Kaidelong> renaming it to assertPure would probably make sense
10:21:29 <bitemyapp> platz: only in your bizarro alternate universe. it's not harming anyody.
10:21:33 <bitemyapp> anybody*
10:21:53 <bitemyapp> nobody suddenly finds their code no longer violates what it says on the tin just because they imported some Data.* module.
10:22:01 <bitemyapp> no longer does*
10:22:05 <Kaidelong> platz: to put it more gently than bitemyapp did most haskell developers are clever enough not to make libraries that break the abstractions and to avoid the ones that do
10:22:50 <platz> Then I just have to stick to the trustworthy devs and avoid the untrustworthy ones
10:22:54 <c_wraith> rejoice! the long-awaited coming of GHC 7.8 is nigh!  (no, really, this is exciting)
10:23:01 <skypers> ok I changed my mind about parsec-numbers: it’s not that good
10:23:05 <skypers> it’s very restricted
10:23:05 <jrmithdobbs> c_wraith: orly?
10:23:07 <skypers> what a pity
10:23:15 <jrmithdobbs> c_wraith: like today or this week? ;p
10:23:33 <c_wraith> jrmithdobbs: the email suggested RC1 would be available today
10:24:10 <jrmithdobbs> hooray, that means there's almost no way it wont be an official release before my deadlines, good news ;p
10:24:11 <geekosaur> they've been trying to push rc1 out, hopefully this means it's for real
10:24:36 <c_wraith> jrmithdobbs: http://www.haskell.org/pipermail/ghc-devs/2014-January/003896.html is the relevant email
10:25:33 <bitemyapp> c_wraith: yay!
10:25:36 <jrmithdobbs> edwardk: did you figure out what was causing it to segfault when build with --enable-library-profiling or was that just something that krept into HEAD
10:25:38 <bitemyapp> c_wraith: I need to fiddle with GHCJS :)
10:25:43 <jrmithdobbs> erm, wrong channel but ya
10:25:59 <edwardk> jrmithdobbs: i mentioned it to thoughtpolice, i guess he and simonm have seem this issue elsewhere
10:26:19 <edwardk> jrmithdobbs: but it is a ghc issue, not a lens issue
10:26:23 <jrmithdobbs> maybe i should file a bug then cause that should probably be a blocker =/
10:26:26 <skypers> ok I guess my parsers are easy to build with that:
10:26:27 <jrmithdobbs> on 7.8.1
10:26:31 <skypers> :t readDec
10:26:32 <lambdabot> (Eq a, Num a) => ReadS a
10:26:40 <skypers> and readSigned
10:26:45 <jrmithdobbs> because not being able to build profiling in sucks :(
10:27:09 <jfischoff> I feel like the FPComplete sign up to project flow is a little long
10:27:26 <johnw> jfischoff: do you have to do it often?
10:28:04 <jrmithdobbs> edwardk: is there an existing bug for this that you know of?
10:28:09 <thoughtpolice> edwardk: well, no. we just know it's a GHC issue.
10:28:11 <jrmithdobbs> edwardk: in ghc trac i mean
10:28:12 <thoughtpolice> :P
10:28:14 <jfischoff> johnw: no I just went through it, and I was thinking if it went right to project it might lead to more engagement
10:28:34 <johnw> please leave feedback if you have the time
10:28:45 <thoughtpolice> jrmithdobbs: https://ghc.haskell.org/trac/ghc/ticket/8696
10:28:46 <jfischoff> johnw: I will where should I do that?
10:28:49 <johnw> we're still at that point where we read them all ;)
10:28:53 <jfischoff> nice
10:29:08 <jrmithdobbs> thoughtpolice: that's the one! thanks :)
10:29:18 <johnw> hmm... where did that feedback button go...
10:29:19 <bitemyapp> jfischoff: hullo!
10:29:24 <thoughtpolice> in any case, it IS a blocker for the actual release
10:29:28 <jfischoff> bitemyapp: yo!
10:29:36 <bitemyapp> jfischoff: try not to get sucked into twitter critique. They're just tips :)
10:29:36 <jfischoff> SF in the house!
10:29:42 <bitemyapp> jfischoff: we should get lunch!
10:29:45 <thoughtpolice> but we've decided to push the RC anyway. there will likely be an RC2 within < 2wk
10:29:46 <jfischoff> yeah totally
10:29:46 <johnw> jfischoff: http://fpcomplete.desk.com/customer/widget/emails/new
10:29:51 <jrmithdobbs> thoughtpolice: ya, i can't upgrade this project to lens4/ghc7.8.1 until i can profile it ;p
10:29:54 <bitemyapp> jfischoff: when are you free?
10:29:55 <jfischoff> johnw: thanks john
10:29:55 <edwardk> thoughtpolice: with that in mind then i'll ship 4 lens today
10:30:06 <edwardk> er lens 4
10:30:12 <jrmithdobbs> thoughtpolice: the rest of the code already works, kind of frustrating
10:30:17 <bitemyapp> edwardk: but thanks for making my eyes cross :)
10:30:24 <jrmithdobbs> edwardk: from HEAD, i'm targeting something 2-3 months out
10:30:35 <thoughtpolice> edwardk: feel free, i'm sure i'll be at the mercy of a million GHC tickets soon
10:30:45 <thoughtpolice> (it feels like nobody ever checks for duplicates)
10:31:02 <jfischoff> bitemyapp: I'll pm you
10:31:54 <jrmithdobbs> it's actually pretty funny, i tried to build and everything links and runs great without profiling but I can't measure the differences
10:32:02 <jfischoff> bitemyapp: but per the twitter criteque, its doesn't bother me when you guys discuss the tips, I'm glad.
10:33:28 <edwardk> It is done, lens 4.0 is released, God have mercy on our souls.
10:33:38 <maxiepoo> \o/
10:33:53 <bitemyapp> edwardk: Boilerplate Assassin 4.0
10:34:11 <thoughtpolice> edwardk: when was the last time lens even had a major release?
10:34:16 <klatch> bitemyapp: I see, thanks. well, I'm keeping the data storage stuff very simple & lightweight, in the spirit of "the database is an implementation detail," to stay nimble
10:34:18 <johnw> edwardk: congrats!!
10:34:20 <edwardk> thoughtpolice: almost a year ago today
10:34:31 <edwardk> thoughtpolice: i was going to ship in september with ghc 7.8 ;)
10:34:39 <bitemyapp> klatch: no please, you'll make me cringe so hard I'll fold up into a black hole and fall into a different universe
10:34:44 <Qett> is there a standard-ish way of handling command line arguments?
10:34:59 <johnw> Qett: I really like optparse-applicative
10:35:12 <Qett> ok ill take a look at it, thanks
10:35:16 <edwardk> I'm also partial to optparse-applicative
10:35:17 <bitemyapp> klatch: I get it, persistence isn't a big part of what the thing is trying to do. It's cool. I just don't like needlessly ghetto persistence :(
10:36:00 <johnw> is ghetto persistence the opposite of gentrification?
10:36:51 * hackagebot git-annex 5.20140129 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140129 (JoeyHess)
10:36:51 * hackagebot tables 0.4 - In-memory storage with multiple keys using lenses and traversals  http://hackage.haskell.org/package/tables-0.4 (EdwardKmett)
10:36:53 <klatch> bitemyapp: persistence is a big thing, it's just that the "event sourcing" style doesn't need complex database stuff for event storage
10:37:30 <bitemyapp> klatch: sorta? 'ish? I mean, smacking a file over and over can still lead to lost data if you're not synchronizing access.
10:37:31 <klatch> bitemyapp: but my interest is piqued w/r/t good implementations of append-only event storage
10:37:58 <klatch> oh yeah, the file thing is very ghetto :)
10:38:08 <bitemyapp> klatch: you said yourself it's a JSON array, that implies reading in the JSON blob, appending "in terms of" JSON, then writeback/fsync. I can easily construct a scenario where that leads to data loss because of a lack of read/write locking.
10:38:25 <bitemyapp> it's not a hard thing to fix *either*
10:38:39 <bitemyapp> you just have to stop doing cringey things with persistence :(
10:40:32 <klatch> bitemyapp: I agree! what I have now is too simple, but most database systems I know seem like overkill...
10:41:30 <bitemyapp> klatch: acid-state is pretty shake-n-bake for most haskell users.
10:42:55 <klatch> yeah, that might be the sweet spot for now
10:42:58 <bitemyapp> klatch: I've been getting awful tempted to make such a historical data store thingy on top of PGSQL or ES, but neither are nice for "embedded", but I think realistically you should use acid-state in those cases.
10:43:20 <klatch> what's ES?
10:46:46 <klatch> I'm happy to avoid database servers that users would have to set up and run on their servers -- I'm already forcing you to install RabbitMQ :)
10:46:47 * hackagebot lens 4.0 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.0 (EdwardKmett)
10:46:49 * hackagebot linear 1.6 - Linear Algebra  http://hackage.haskell.org/package/linear-1.6 (EdwardKmett)
10:46:59 <klatch> dinnertime. thanks for the conversation bitemyapp!
10:48:59 <syllogismos> can someone review my code.. finally i implemented simple linear regression using AD.. http://lpaste.net/99218 i could have done it without AD, but i wanted to learn and understand that particular library.. anyway. i dont have any AD related doubts.. for now. but am i doing things like reading from file, etc the right way?
10:49:55 <ion> As a foreigner, i have no idea if “…is pretty shake-n-bake for most haskell users” is good or bad. :-P
10:53:21 <sebastian_> I've a nice cabal sandbox here, but cabal fails to find a repo that was added with cabal sandbox add-source
10:53:27 <sebastian_> anyone has an idea?
10:53:53 <dcoutts> sebastian_: build that added package directly
10:54:10 <sebastian_> dcoutts: in the sandbox?
10:54:12 <dcoutts> yes
10:54:25 <syllogismos> also I don't like my function theataAfterNIters, thats how i would implement it in python.. is it the proper way in haskell too? Its a recursive definition.. and its taking an 'n' argument to do n iterations.. instead i want my function to give an inf lazy list and if i want to do n iterations i would do 'take n myFancyNewFunction args args' etc.. how do i implement it
10:54:49 <dcoutts> sebastian_: iirc, add-src packages don't get picked up as deps 'til they've been built for the first time
10:55:21 <sebastian_> dcoutts: that's odd.
10:55:33 <dcoutts> sebastian_: yes, it's not sensible behaviour
10:56:48 * hackagebot trifecta 1.4 - A modern parser combinator library with convenient diagnostics  http://hackage.haskell.org/package/trifecta-1.4 (EdwardKmett)
10:59:22 <joeyh> anyone know of a rename function that can rename directories on Windows? Seems that System.PosixCompat.Files.rename just calls renameFile on windws
10:59:32 <codygman> How would I go about handling a file in "ISO-8859 text, with very long lines, with CRLF line terminators"? I got the error hGetContents: invalid argument (invalid byte sequence).
11:00:37 <codygman> joeyh: I'm not sure if this has what you need after a cursory glance, but it could be: http://hackage.haskell.org/package/filepath-1.3.0.1/docs/System-FilePath-Windows.html
11:00:44 <s778> This might be a stupid question but is it possible to load a hs file at runtime? I want to use plain haskell as a config file
11:01:03 <codygman> s778: xmonad does that. Maybe look at how they do it?
11:01:24 <Qett> what are angle brackets in haskell?
11:01:45 <joeyh> not unless it has some IO actions I'm not seeing
11:01:48 * hackagebot sparse 0.9 - A playground of sparse linear algebra primitives using Morton ordering  http://hackage.haskell.org/package/sparse-0.9 (EdwardKmett)
11:02:00 <joeyh> it seems I will have to use System.Win32.File.moveFile
11:02:00 <bergey> codygman: how about http://hackage.haskell.org/package/text-1.1.0.0/docs/Data-Text-Lazy-Encoding.html
11:02:05 <joeyh> which despite its name can move directories
11:02:17 <s778> I thought xmonad did it at compile time, but either way that's a good idea. Thanks
11:02:24 <codygman> Qett: What angle brackets in particular? This page or hoogle might be of use: http://www.haskell.org/haskellwiki/Keywords
11:03:35 <codygman> bergey: Maybe, though it seems like I would have to do something before that step since I can't even read the file with hGetContents.
11:03:51 <bobajett> how can I reverse this filter?  files_that_start_with_a = filter (isPrefixOf "a") allFiles. I'd like to get all files that do not start with "a".
11:04:07 <geekosaur> not . isPrefixOf ...
11:05:06 <ion> I’m not sure i like a number implementation in which “3 / 3 :: Data.Scientific.Scientific” is bottom.
11:05:09 <bobajett> geekosaur: thanks. duh! I was doing (not(isPrefixOf "a")).
11:06:01 <bergey> codygman: Yes.  I'd also suggest switching to Data.ByteString.getContents (which should work fine because it doesn't care about character encodings) and Data.Text instead of String.
11:06:04 <thoughtpolice> for anyone interested: an approximated diffstat between GHC 7.6.x and 7.8
11:06:08 <thoughtpolice> 964 files changed, 99952 insertions(+), 116187 deletions(-)
11:06:12 <thoughtpolice> (from #ghc)
11:06:16 <ion> thoughtpolice: nice
11:06:27 <codygman> bergey: Duh... that's right. Thank you.
11:06:41 <thoughtpolice> that's only GHC itself, the libraries probably saw some decent changes too
11:06:49 * hackagebot structures 0.1 - "Advanced" Data Structures  http://hackage.haskell.org/package/structures-0.1 (EdwardKmett)
11:07:12 <Qett> hey im reading the doc on optparse-applicative and i don't understand what the angle brackets (<>) are
11:07:26 <ion> (<>) = mappend from Data.Monoid
11:07:42 <Qett> oh
11:09:59 <jle`> no monomorphism restriction on ghci by defaut is neat
11:10:23 <jle`> @hoogle (<>) Qett
11:10:23 <lambdabot> Warning: Unknown type <>
11:10:23 <lambdabot> Prelude undefined :: a
11:10:23 <lambdabot> Test.QuickCheck discard :: a
11:10:28 <jle`> aw darn
11:10:57 <Qett> hoogle site gives me some templatehaskell doc stuff
11:11:08 <jle`> what gives hoogle
11:11:12 <jle`> this is apretty common operator
11:11:40 <identity> :info (<>)
11:11:48 <identity> @info (<>)
11:11:48 <lambdabot> (<>)
11:11:51 <identity> yay.
11:11:56 <identity> thanks lambdabot
11:12:05 <Qett> lol
11:12:14 <Qett> maybe some escape characters needed?
11:12:22 <identity> @ty (<>)
11:12:23 <lambdabot> Monoid m => m -> m -> m
11:12:28 <Qett> @hoogl (\<\>)
11:12:28 <lambdabot> Maybe you meant: hoogle hoogle+
11:12:32 <identity> nah, no such
11:12:41 <Qett> @hoogl '(<>)'
11:12:41 <lambdabot> Maybe you meant: hoogle hoogle+
11:12:43 <identity> @hoogle (Data.Monoid.<>)
11:12:43 <lambdabot> Parse error:
11:12:43 <lambdabot>   (Data.Monoid.<>)
11:12:43 <lambdabot>         ^
11:12:54 <Qett> lol
11:12:55 <identity> @hoogle (Data.Monoid.(<>))
11:12:55 <lambdabot> Parse error:
11:12:55 <lambdabot>   (Data.Monoid.(<>))
11:12:55 <lambdabot>         ^
11:13:08 <Qett> @hoogle ('<>')
11:13:09 <lambdabot> Parse error:
11:13:09 <lambdabot>   ('<>')
11:13:09 <lambdabot>    ^
11:13:17 <Qett> @hoogle "(<>)"
11:13:17 <lambdabot> Parse error:
11:13:17 <lambdabot>   "(<>)"
11:13:17 <lambdabot>   ^
11:13:22 <identity> Qett: there is no need for escape characters
11:13:35 <Qett> ah
11:13:42 <Qett> @hoogle ( <> )
11:13:43 <lambdabot> Warning: Unknown type <>
11:13:43 <lambdabot> Prelude undefined :: a
11:13:43 <lambdabot> Test.QuickCheck discard :: a
11:13:45 <identity> I'm not sure why hoogle doesn't index Data.Monoid really
11:14:00 <jle`> maybe we should drop neil an issue
11:14:38 <jle`> hoogle doesn't even index all of HP so maybe it's not an urgent thing to the dev goals
11:15:04 <Qett> seems like it wouldnt require much effort
11:15:10 <Qett> probably just add it to some list
11:16:23 <syllogismos> hayoo searches all packages too
11:16:33 <syllogismos> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:%3C%3E
11:17:35 <joneshf-laptop> syllogismos, did you ever get an answer?
11:17:44 <syllogismos> no
11:19:45 <sebastian_> syllogismos: I'm currently building a new hayoo version. any whishes?
11:23:28 <syllogismos> umm.. i dont know.. let me thing.. so far its has larger index than hoogle.. but hoogle is more popular? so make it more popular :D i remember hoogle left me frustrated by not giving me the result i wanted once.. and some one here suggested hayoo
11:23:47 <syllogismos> so i stuck with hayoo from then on..
11:24:03 <ski> iirc Hayoo doesn't do type-based search ?
11:24:18 <geekosaur> it does, just differently from hoogle
11:24:22 <sebastian_> a little bit, but hoogle is a lot better
11:24:39 <geekosaur> hoogle generalizes better... which is both blessing and curse
11:25:42 <sebastian_> type based search is on my todo, but getting my version usable is a little bit more important
11:26:24 <joneshf-laptop> sebastian_, what isn't usable?
11:27:05 <joneshf-laptop> syllogismos, i only took a quick look so i dont think i'll be that helpful
11:28:02 <syllogismos> i dont know what is better.. i only wanted to search one function and hoogle didnt come up with what i wanted.. but when i first learned that i can search functions based on type signatures..  it seemed cool for some reason to me..
11:28:05 <sebastian_> joneshf-laptop: a lot. it's based on a new searchengine
11:29:15 <syllogismos> joneshf-laptop: does it look okay?
11:29:37 <syllogismos> when i see peoples haskell code i see them use bind, mapM_ etc etc..
11:29:41 <syllogismos> in main..
11:30:06 <syllogismos> but i feel like i cheated by using let
11:30:34 <syllogismos> does it look okay.? and is this how are my file reading skillz
11:30:50 <lispy> sebastian_: I haven't used hayoo much, but I use hoogle regularly. My biggest complaint with it is that it doesn't index enough stuff. I've never tried installing it locally because I assume it would have an even smaller index if it were tried to my sandboxes.
11:31:06 <lispy> sebastian_: So, I guess the lesson for hayoo is to make sure you index as much of hackage as you can.
11:31:27 <sebastian_> http://thehammer.spawnhost.de/Bildschirmfoto1.png
11:32:02 <lispy> sebastian_: Perhaps next on my list would be that it doesn't seem to know much about versions of packages. Sometimes I want to know when something was added, removed, or changed in an API. hayoo/hoogle are not made with taht in mind, afaict
11:32:59 <sebastian_> lispy: hayoo is just indexing the last version
11:33:12 <lispy> sebastian_: That makes sense.
11:33:17 <lispy> sebastian_: I think hoogle is doing that too
11:33:21 <sebastian_> yep
11:33:53 <sebastian_> syllogismos: what do you think?
11:33:55 <lispy> sebastian_: Honestly I don't know how to make it doing multiple versions in a nice way, I just know that it would be useful at times.
11:34:43 <syllogismos> all the back slashes are confusing me.. what is it esarching exactly
11:35:14 <sebastian_> lispy: the index would be ten times larger. I don't think it's worth it
11:36:09 <sebastian_> syllogismos: it's searching for a type "(a -> Maybe b)" the results aren't that great at the moment
11:38:00 <sebastian_> dcoutts: you always have to install dependencies in a sandboy with cabal install --only-dependencies
11:39:03 <syllogismos> you like hoogle results for a -> Maybe b more?
11:39:24 <syllogismos> sebastian_: you like hoogle results for a -> Maybe b more?
11:40:03 <sebastian_> sure
11:40:09 <sebastian_> syllogismos: sure
11:41:08 <darkPassenger> hi all
11:41:46 <darkPassenger> anonymous var '_' matter : how do we do something like _ == _ = False in an instance of a custom data ?
11:42:42 <darkPassenger> oh nevermind
11:43:20 <joneshf-laptop> darkPassenger, `otherwise`? or give each a name so they aren't anon
11:44:49 <geekosaur> they left already... presumably after trying it (that happens to be valid)
11:45:19 <geekosaur> @src Maybe (==)
11:45:20 <lambdabot> Source not found. Just try something else.
11:45:22 <geekosaur> aw
11:45:28 <syllogismos> joneshf-laptop: did you see my second questions?
11:45:59 <syllogismos> my current function takes n as an argument and computes new thetas after n iterations..
11:46:47 <syllogismos> but i want a function that generates a infinite list of thatas.. and if i want to get the theta after n iterations.. i would do something like last $ take n $ myFunction
11:47:24 <syllogismos> did you get my question?
11:48:28 <syllogismos> im happy with my current implementation.. but i want to see how to do that sort of thing.. i'm asking a general question by the way..
11:48:48 <identity> DOes anyone see anything obviously very wrong with this FromJSON instance for my GADt? I had a 'different' gadt before and it worked fine. Now, nothing seems to decode properly. https://gist.github.com/saevarb/8695476
11:51:33 <bitemyapp> welp. cabal install cabal-install --max-backjumps 2000 --force-reinstalls
11:51:59 <c_wraith> identity: are those constraints inside the GADT actually useful?  It looks like the typical case where they're not doing anything helpful.
11:52:23 <identity> c_wraith: I don't know, really. I feel like what I'm doing here is .. I don't know, it feels smelly.
11:53:14 <identity> Hmm. I don't really know. I may be doing it wrong, really
11:53:41 <identity> Maybe I should just be parsing the whole thing every time like I did initially, checking the error field
11:53:42 <c_wraith> identity: how is it failing?
11:53:56 <merijn> c_wraith: Well, with a GADT you can use the right hand of the typeclass without needing a constraint on the function using it
11:53:59 <identity> c_wraith: I've just been using aeson's 'decode'. It's just returning "nothing"
11:54:12 <merijn> c_wraith: So they are useful in a way that DatatypeContexts aren't
11:54:26 <c_wraith> merijn: yes, but the benefit there is almost nonexistent.
11:54:29 <identity> I think this may be the wrong way to model it, really
11:54:36 <identity> so maybe my issue now is irrelevant
11:54:37 <merijn> c_wraith: I didn't actually look at the code xD
12:00:20 <Kaidelong> GHCi is giving me grief about Couldn't match expected type `Text' with actual type `[Char]' even though OverloadedStrings pragma is on, what on earth
12:00:43 <Kaidelong> it's inferring a literal string to have type String in a context where it's expecting Text?
12:00:55 <merijn> Kaidelong: monomorphism
12:01:04 <merijn> Kaidelong: Strings presumably default to String
12:01:21 <merijn> Kaidelong: Did you use "let"?
12:01:37 <Kaidelong> merijn: why would they default to String in the context Data.Text.append "primary" suffix
12:02:06 <Kaidelong> merijn: no, it's complaining about a literal
12:02:30 <Clint> is the answer that you didn't actually turn OverloadedStrings on?
12:02:42 <Kaidelong> does GHCi not respect pragmas in source files?
12:03:16 <Clint> i would expect it to only respect it for that source file
12:03:28 <Kaidelong> oh
12:03:33 <Kaidelong> there was a mistake in the pragma
12:04:35 <c_wraith> ghci doesn't use pragmas from a file when you :load that file, though
12:04:42 <c_wraith> it uses imports, but not pragmas
12:04:49 <c_wraith> That's something that always struck me as odd
12:04:59 <Kaidelong> really? Fixing the pragma solved the problem
12:06:56 * hackagebot log-domain 0.8.1 - Log-domain arithmetic  http://hackage.haskell.org/package/log-domain-0.8.1 (EdwardKmett)
12:07:07 <thoughtpolice> Kaidelong: i think c_wraith means that if you :load a file and it has, say, -XFooBar enabled, then that *file* can use -XFooBar. but GHCi *itself* does not turn on -XFooBar when you load it
12:07:23 <c_wraith> oh.  yes, that's what I meant.
12:09:42 <Clint> that is what i thought we were all talking about
12:17:52 <joneshf-laptop> syllogismos, im a bit distracted so maybe someone else can chime in but can't you use `iter` or `repeat` or something?
12:18:03 <joneshf-laptop> :t iter
12:18:03 <identity> speaking of pragmas and ghci
12:18:04 <lambdabot> Not in scope: `iter'
12:18:07 <joneshf-laptop> gah
12:18:19 <joneshf-laptop> :t iterate
12:18:20 <lambdabot> (a -> a) -> a -> [a]
12:18:20 <identity> does cabal repl not :set pragmas in extensions field in .cabal file?
12:18:28 <joneshf-laptop> syllogismos, ^
12:18:54 <dcoutts> identity: it doesn't use :set, it use -X on the command line, just as it does for build
12:19:09 <dcoutts> identity: you can see how cabal invokes ghci with -v
12:19:37 <jozefg> Hello, is anyone aware of nice high level DSL's for generating C code?
12:20:13 <identity> dcoutts: Oh, I see. It doesn't seem to be setting the extensions I use in the file
12:20:21 <identity> is there another field that's not 'other-extensions' ?
12:20:25 <identity> maybe just 'extensions'?
12:20:32 <dcoutts> identity: default-extensions
12:20:37 <dcoutts> identity: default-extensions & other-extensions
12:21:05 <dcoutts> identity: other-extensions just means "this package uses these extensions", rather than "please compile all the modules in this package with these extensions turned on"
12:21:30 <identity> ah! thanks!
12:21:34 <identity> that saves me some typing :)
12:21:40 <identity> I see cabal turning it on now
12:21:55 <dcoutts> identity: the two approaches are use default-extensions, or use other-extensions + LANGUAGE pragmas. Choice is up to you.
12:21:58 <geekosaur> in other words it's a sanity check on the compiler (can it handle these?)
12:22:33 <dcoutts> geekosaur: and the build system needs to know about certain extensions (TemplateHaskell) to be able to do the right thing
12:24:13 <xplat> why does 'myshakescript.hs foobies' not complain that it doesn't know how to make foobies?
12:24:51 <xplat> (the only rule right now is for phony "all")
12:27:55 <quchen_> Default fixity is infixl 9, right? Or is that only for `infix`?
12:28:16 <jle`> so i got a package to build and install only with special configuration stuff...is there any way to specify that when i'm requiring that package to build another one?
12:28:37 <jle`> (SDL only installs on with special flag,s and i have a sandboxed package that i want to use SDL with)
12:28:42 <supki> > let (+) = undefined in (+0$0)
12:28:43 <lambdabot>  The operator `+' [infixl 9] of a section
12:28:44 <lambdabot>      must have lower precedence than that of the operand,
12:28:44 <lambdabot>        namely `GHC.Base.$' [infixr 0]
12:28:44 <lambdabot>      in the section: `+ 0 $ 0'
12:30:24 <quchen_> Ah, Report: "Any operator lacking a fixity declaration is assumed to be infixl 9". PDF page 51.
12:30:32 <xplat> > (+-+-+-+ 1$1)
12:30:33 <lambdabot>  Not in scope: `+-+-+-+'
12:31:13 <xplat> @let (+-+-+-+) = undefined
12:31:14 <lambdabot>  Defined.
12:31:19 <xplat> > (+-+-+-+ 1$1)
12:31:20 <lambdabot>  The operator `L.+-+-+-+' [infixl 9] of a section
12:31:20 <lambdabot>      must have lower precedence than that of the operand,
12:31:20 <lambdabot>        namely `GHC.Base.$' [infixr 0]
12:31:20 <lambdabot>      in the section: `+-+-+-+ 1 $ 1'
12:31:35 <ski> @undefine
12:31:35 <lambdabot> Undefined.
12:31:49 <c_wraith> > (+5*3) 1
12:31:50 <lambdabot>  16
12:31:51 <ski> @let infixl 0 ++-+-+-+; (+-+-+-+) = undefined
12:31:51 <lambdabot>  .L.hs:143:10:
12:31:51 <lambdabot>      The fixity signature for `++-+-+-+' lacks an accompanying binding
12:31:59 <ski> @let infixl 0 +-+-+-+; (+-+-+-+) = undefined
12:32:00 <lambdabot>  Defined.
12:32:16 <ski> > (+-+-+-+ 1$1)
12:32:17 <xplat> > (+-+-+-+ 1$1)
12:32:17 <lambdabot>  No instance for (GHC.Num.Num a0) arising from the literal `1'
12:32:17 <lambdabot>  The type variable `a0' is ambiguous
12:32:17 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:32:17 <lambdabot>  Note: there are several potential instances:
12:32:17 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
12:32:19 <lambdabot>  No instance for (GHC.Num.Num a0) arising from the literal `1'
12:32:21 <lambdabot>  The type variable `a0' is ambiguous
12:32:23 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:32:25 <lambdabot>  Note: there are several potential instances:
12:32:27 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
12:32:36 <xplat> race condition
12:35:26 <xplat> @let infixl 0 (>:-|); (>:-|) = undefined
12:35:27 <lambdabot>  Parse failed: Parse error: (
12:35:47 <ski> drop the initial brackets
12:35:54 <xplat> oh, right
12:36:13 <xplat> @let infixl 0 >:-|; (>:-|) = undefined
12:36:15 <lambdabot>  Defined.
12:36:27 <FireFly> That has always annoyed me.  Parens in the infix declaration would feel better
12:36:31 <FireFly> and more consistent
12:36:38 <ski> why ?
12:37:04 <FireFly> Well, it feels similar to me to having them in `let` declarations
12:37:29 <DanBurton> Sanity check: for an Ord instance, usually "a < b == False" means that "a >= b == True". Do you think it is ever okay to violate this assumption?
12:37:33 <ski> `infix',`infixl',`infixr' are specifically about operators (not about operators-turned-into-expressions)
12:37:39 <FireFly> though I guess that might imply that using plain identifiers would also work in infix declarations
12:37:41 <FireFly> Yeah, that's true
12:37:42 <xplat> > (>:-| -1-4)
12:37:42 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t1)
12:37:43 <lambdabot>    arising from a use of `M695868732529770988618024.show_M6958687325297709886...
12:37:43 <lambdabot>  The type variable `t1' is ambiguous
12:37:43 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:37:43 <lambdabot>  Note: there are several potential instances:
12:38:05 <xplat> > (>:-| -1-4) :: Integer
12:38:06 <lambdabot>  Couldn't match expected type `GHC.Integer.Type.Integer'
12:38:06 <lambdabot>              with actual type `t0 -> t1'
12:38:35 <xplat> > (>:-| -1-4) :: Integer -> Integer
12:38:37 <DanBurton> Or to elaborate further, (a < b) == False and (a == b) == False usually implies (a > b) == True.
12:38:38 <lambdabot>  <Integer -> Integer>
12:38:58 <FireFly> > let nan = 0/0 in [ nan < nan, nan >= nan ]
12:38:59 <lambdabot>  [False,False]
12:39:11 <ski> @let infix 3 `isSupersetOf`; a `isSupersetOf` b = b `S.isSubsetOf` a
12:39:13 <lambdabot>  Defined.
12:39:15 <DanBurton> I ask because the numbers library has some cases that violate this, which I've noticed in light of this PR: https://github.com/DanBurton/numbers/pull/10
12:39:19 <ski> FireFly ^
12:39:39 <FireFly> Huh, that works..
12:40:05 <ski> `infix 4 elem' is in `Prelude', after all
12:40:13 <ski> well
12:40:18 <ski>   infix 4 `elem`
12:40:21 <DanBurton> FireFly: o_O IEEE is weird
12:40:34 <DanBurton> but thanks for pointing that out
12:40:36 <xplat> NaN:IEEE::NULL:SQL
12:40:50 <ski> DanBurton : it's not clear to me whether `Ord' should imply a total order
12:41:01 <DanBurton> > let inf = 1/0 in [inf < inf, inf >= inf]
12:41:02 <lambdabot>  [False,True]
12:41:22 <DanBurton> > let inf = 1/0 in inf == inf
12:41:24 <lambdabot>  True
12:41:30 <ski> (i suppose that would be a reasonable assumption, judging e.g. from `sort', though)
12:41:53 <dv-> when I run :i UTCTime in ghci it just shows Eq and Ord instance, but in the docs it also has Show and Read, why's that?
12:43:44 <benzrf> gcc: error: unrecognized command line option ‘-Wl’
12:43:45 <benzrf> ??
12:43:50 <benzrf> ^cabal install fail
12:44:01 <FreeFull> > let nan = 0/0 in sort [3,5,nan,1,0,nan,nan,5]
12:44:02 <lambdabot>  [3.0,5.0,5.0,NaN,NaN,0.0,1.0,NaN]
12:44:16 <geekosaur> benzrf: sounds like a portability fail maybe
12:44:22 <benzrf> bah
12:44:23 <bergmark> dv-: i see all of them
12:44:29 <s778> I have a data with a large number of properties, what is the preferred way to get the properties I want in a function? Just typing out every property seems a bit unpractical
12:44:40 <benzrf> s778: records?
12:44:59 <etandel> @hoogle Bool -> a -> a -> a
12:44:59 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
12:45:00 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vertex3 :: a -> a -> a -> Vertex3 a
12:45:00 <lambdabot> Graphics.Rendering.OpenGL.GL.Tensor Vector3 :: a -> a -> a -> Vector3 a
12:45:01 <bergmark> dv-: ah, orphan instances
12:45:14 <benzrf> @djinn Bool -> a -> a -> a
12:45:14 <lambdabot> f a b c =
12:45:14 <lambdabot>     case a of
12:45:14 <lambdabot>     False -> c
12:45:14 <lambdabot>     True -> b
12:45:34 <FreeFull> :t if'
12:45:34 <lambdabot>     Not in scope: if'
12:45:35 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
12:45:44 <FreeFull> :t ifelse
12:45:45 <lambdabot> Not in scope: `ifelse'
12:45:48 <benzrf> huh
12:45:51 <s778> benzrf: thanks
12:45:53 <bergmark> dv-: you see orphan instances in the module where a type is defined in haddock if both modules are in the same package
12:45:59 <xplat> hoogle fail; Vector3 a can't equal a, even if a is not constrained to be Bool
12:46:44 <etandel> thx benzrf
12:46:48 <benzrf> np
12:47:08 <etandel> but i was curious if there already existed something like that (i know, if else etc.)
12:49:28 <dv-> benzrf: ah they're in Data.Time.Format
12:49:31 <DanBurton> > let nan = 0/0; inf = 1/0 in (nan, inf) -- why doesn't Prelude export these?
12:49:32 <lambdabot>  (NaN,Infinity)
12:49:46 <bergmark> s778: there's NamedFieldPuns and RecordWildCards too, but I dislike them both because they shadow variables (and even more ugly things for RecordWildCards)
12:51:44 <etandel> DanBurton: it's very pythonic indeed. nan = float('nan') --> nan = read "NaN" :: Float
12:51:47 <geekosaur> DanBurton, nan at least is nowhere near as simple as that (thanks, IEEE754)
12:55:33 <s778> bergmark: good to know about though, thanks
12:58:31 <jle`> how do i tell sdl-gfx where to look for SDL_gfx ?
12:58:51 <jle`> i already have extra lib dirs and extra include dirs pointing at the .a's, .h's, .dll's
12:58:59 <jle`> i'm not even totally sure what it's looking for
12:59:44 <jle`> it says "SDL_gfx lib not found! Get SDL_gfx from..." (broken link)
12:59:52 <jle`> i'm trying to get it to compile on windows btw
13:12:54 <FireFly> geekosaur: because of signalling/non-signalling NaNs and payloads?
13:13:23 <geekosaur> yeh
13:13:47 <geekosaur> and that NaN is not comparable with anything including NaN, and there are multiple NaNs (is that what you meant by payloads?)
13:14:03 <geekosaur> so having an NaN value is kinda useless
13:14:27 <killy9999> how can I install haddock documentation for packages?
13:14:43 <geekosaur> only possible use is a sentinal with isnan, and you're better off using Maybe in Haskell anyway
13:14:48 <killy9999> also, can I have cross-package hyperlinks in documentation?
13:15:33 <jle`> killy9999: it's a flag in your ~/.cabal/config file
13:15:52 <jle`> killy9999: documentation: True
13:15:55 <geekosaur> killy9999: cabal's documentation story is kinda annoying, you need to enable it and then throw out your cabal installed libraries and reinstall everything. and I think there's some magic needed to get it to hyperlink with other user-instaleld libraries
13:16:08 <FireFly> geekosaur: yeah, I think I've seen it referred to elsewhere as payloads. Basically, a bunch of bits (the mantissa?) that don't matter for it being a NaN, but could contain metadata for an application using them
13:16:10 <geekosaur> there was a thread on one of the lists recdently
13:16:25 * geekosaur goes looking for the discussion
13:16:34 <jle`> you can choose to install only the documentation
13:16:37 <jle`> intead of reinstalling everything
13:17:23 <jle`> it hink
13:19:24 <acowley> An easy way to generate docs for an existing database seems like it would be awfully useful
13:19:52 <killy9999> geekosaur, jle`: thanks
13:20:35 <killy9999> what I would like to have is cross-referencing on hackage
13:20:40 <killy9999> is that supported?
13:21:12 <geekosaur> thread "Broken documentation on hackage." on cabal-devel and libraries mailing lists discuss that
13:21:29 <killy9999> thanks
13:22:21 <geekosaur> apparently hyperlinking is annoying enough to require a script to do it right, which is why I'm pointing at the thread
13:22:33 <geekosaur> since there were several iterations of the script involved
13:23:42 <jfischoff> johnw: sent
13:23:57 <johnw> jfischoff: thank you!
13:28:58 <enthropy> killy9999: https://github.com/feuerbach/standalone-haddock might also be of interest
13:34:57 <enthropy> "Local definition of ‛join’ clashes with a future Prelude name - this will become an error in GHC 7.10"
13:35:08 <enthropy> odd how they'd decide to do that
13:35:40 <enthropy> when the rest of that reorganization probably causes less programs to break
13:36:27 <athan> Hey guys I've got an IO question
13:36:36 <Rembane> athan: Shoot!
13:36:39 <jle`> cool
13:37:27 <athan> Now, I've been reading some articles, and they say that Haskell provides no way of "extracting" a value out of an IO monad, ie: there is no way to simply remove the wrapper, because there could be side-effects related to the computation and that would create an impure function
13:37:31 <athan> now here's my question
13:37:55 <athan> Is that because Haskell doesn't make any of the IO monad constructors visible/available to pattern match against?
13:38:21 <jle`> i think you might be mixing up the cause and the effect
13:38:35 <jle`> but...not exporting the IO constructor does achieve that ends
13:39:05 <mm_freak> @quote /bin/ls
13:39:06 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
13:39:12 <mm_freak> @ athan
13:40:10 <jle`> but yes it doesn't even make sense to have an IO constructor
13:40:10 <mm_freak> getLine is not an impure string, it is an action that, when executed, eventually produces a string
13:40:22 <geekosaur> if you could pattern match you still would not get an Int. you would get an I/O action
13:40:25 <mm_freak> jle`: it does actually…  because of the above
13:40:28 <geekosaur> with no way to evaluate it
13:40:48 <mm_freak> jle`: imagine a GADT:  GetLine :: IO String
13:41:01 <jle`> ah
13:41:03 <jle`> yeah.
13:41:18 <jle`> jut not one that would work with ghc's io implementation
13:41:44 <mm_freak> jle`: GHC's implementation is optimized for speed
13:41:47 <jle`> but yeah, even if you could have an IO constructor, it doesn't make sense to just 'extract' a value out of it
13:41:56 <jle`> because the constructor represents a future computation
13:42:01 <jle`> not a container for a value
13:42:12 <jle`> er, it represents a computation action.
13:42:20 <athan> ahh wow
13:42:33 <athan> so you have have data types represent future computations instead of being containers?
13:42:40 <geekosaur> no, just IO
13:42:49 <mm_freak> athan: you simply have data types that represent actions
13:42:52 <geekosaur> and IO is strange not because it is a monad but because it is IO
13:42:53 <athan> ahh okay.
13:43:03 <jle`> http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/
13:43:03 <geekosaur> basically IO works as chains of callbacks
13:43:11 <mm_freak> well, IO isn't really that strange, and you have tons of monads like IO
13:43:28 <jle`> but its strangeness doesn't come from its monadness
13:43:29 <mm_freak> at least i do =)
13:43:47 <Peaker> the relationship between IO and monad is way too emphasized and beginners shouldn't care that IO happens to be a monad
13:44:01 <quchen_> mm_freak: What monads are you talking of?
13:44:02 <athan> I'm not
13:44:09 <athan> I like the structure of it
13:44:14 <geekosaur> these chains are themselves pure, and the monad helps us manipulate them more easily than if we just exposed callbacks
13:44:15 <athan> I just need to understand monads better
13:44:28 <mm_freak> quchen_: data MyTinyLittleToyAssemblyLanguage = Mov … | Rcx … | …
13:44:31 <Peaker> athan: then ignore IO
13:44:38 <quchen_> mm_freak: Ah, so free ones. Okay
13:44:49 <mm_freak> quchen_: pretty much, yeah
13:44:58 <jle`> athan: the article i linked kind of is a way to express IO (it's slightly different than GHC's implementation), but it shows you how it doesn't really make sense to arbitrarily extract a value from an IO
13:45:00 <quchen_> free-ish ones, modulo the type argument :-)
13:45:12 <jle`> also, learning about how IO works won't help you understand monads
13:45:48 <athan> That's cool, I plan on keeping them separate in mind
13:46:25 <jle`> in the article you sort of construct an IO monad of sorts from scratch
13:46:29 <athan> So monads can be thought of as both a container and a future computation (or at least a computation specification)?
13:46:31 <mm_freak> FWIW, i'll now list an infinite number of monads for which it doesn't make sense to extract values:  forall e. (->) e
13:46:50 <jle`> athan: different monads can be thought of as different things
13:47:01 <jle`> what they are 'thought of as' has nothing to do with if they are monads or not
13:47:03 <c_wraith> athan: Monads *should* be thought of as an abstraction that supports composing values.  If you try to apply any more meaning to them, you're wrong.
13:47:07 * hackagebot tasty-hunit-adapter 1.0 - Use existing HUnit tests with tasty  http://hackage.haskell.org/package/tasty-hunit-adapter-1.0 (JanStolarek)
13:47:41 <kryft> Monads: exactly what it says on the (typeclass) tin
13:47:43 <jle`> it's like trying to understand programming languages by understanding text editors
13:47:48 <athan> so monads are really just an algebraic utility to use
13:47:55 <athan> down to the definition of them, at least?
13:47:58 <jle`> 'so different text-editor languages...some usee parentheses?'
13:48:16 <jle`> 'can i categorize text-editor-written languages?'
13:48:37 <jle`> 'in some languages i write using text editors...i see that some use tab delimiters.'
13:48:54 <jle`> focusing on the text editor won't really help you understand the programming language you are writing
13:49:18 <athan> ahh I see
13:49:22 <jle`> monad x can be thought of as... x
13:49:28 <mm_freak> monads are a fancy way to apply fancy functions =)
13:49:58 <c_wraith> athan: yep. Monad is a useful abstraction because any arbitrary control flow for ways of sequencing those compositions can be expressed using them. And so it's useful to use the abstraction for making bits of control flow independent of concrete implementation.
13:50:27 <mm_freak> c_wraith: actually that isn't true
13:50:47 <mm_freak> that's why we have applicative functors and arrows
13:51:10 <c_wraith> mm_freak: those are both more limited in terms of what they can express.
13:51:25 <athan> regardless, though, it should still be thought of as merely a design principal that becomes useful, correct?
13:51:45 <c_wraith> mm_freak: that gives additional knowledge about how they're used, which can be handy - but it doesn't mean that they're control flows that can't be expressed.
13:51:57 <mm_freak> c_wraith: more things are instances of them, and they obviously have less expressive power
13:52:08 * hackagebot yaml-light-lens 0.3 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3 (AnthonyCowley)
13:52:33 <c_wraith> athan: yep. It's a handy abstraction, because the monad laws more or less work out to mean "It doesn't do anything unpredictable"
13:52:34 <enthropy> http://lpaste.net/99223
13:53:08 <mm_freak> or as the category-theorist would say:  it doesn't do anything unnatural =)
13:53:31 <enthropy> so it seems ghc-7.6 kind of allowed overlap with normal type families
13:54:17 <enthropy> that constraint on lines 23,24 would be nice to not have
13:56:20 <aleksejs_> I have foo "f = a >> b >> c >> f" . Is it possible to declare "bar = b >> c" and then use "foo f = a >> bar >> f" ?
13:57:02 <geekosaur> possible but you may need an explicit type signature for bar
13:57:09 <geekosaur> because of the monomorphism restriction
13:57:13 <erisco> referential transparency says "yes"
13:57:30 <geekosaur> @where dmr
13:57:30 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:57:55 <hpc> i like that this where is a thing
13:58:32 <c_wraith> erisco: well, referential transparency and the associativity portion of the monad laws.
13:58:59 <erisco> c_wraith, granted
13:59:56 <erisco> easy to forget all the implicit parentheses
14:01:03 <c_wraith> But that's an excellent illustration of what I meant by the monad laws working out to mean "not doing anything upredictable". :)
14:02:32 <nander> Hi, first of all, what I'm about to ask is NOT homework ;)
14:02:46 <nander> I have a huge wordlist and I want to know all words that follow a certain pattern
14:02:50 <athan> I wish I was in school :(
14:03:00 <nander> So, for instance, I might know it starts with a t and has 3 characters
14:03:03 <nander> (t..)
14:03:17 <enthropy> so far it's not well-defined enough to be homework
14:03:21 <erisco> nander, look at "tries"
14:03:32 <c_wraith> enthropy: I've seen homework that badly defined before!
14:03:39 <athan> 't':_:_:xs?
14:03:49 <FreeFull> > undefined :: Any
14:03:50 <lambdabot>  Any {getAny = *Exception: Prelude.undefined
14:03:55 <silasm> well, tries are a data structure that can be useful for that (at least as long as it's all a forward pass)
14:04:05 <FreeFull> > 3 :: Any
14:04:06 <lambdabot>  No instance for (GHC.Num.Num Data.Monoid.Any)
14:04:06 <lambdabot>    arising from the literal `3'
14:04:06 <lambdabot>  Possible fix:
14:04:06 <lambdabot>    add an instance declaration for (GHC.Num.Num Data.Monoid.Any)
14:04:10 <silasm> why not just use regex though, if this is just a problem you're trying to solve?
14:04:15 <FreeFull> > [3] :: Any
14:04:16 <lambdabot>  Couldn't match expected type `Data.Monoid.Any'
14:04:16 <lambdabot>              with actual type `[t0]'
14:04:31 <FreeFull> :t getAny
14:04:31 <lambdabot> Any -> Bool
14:04:41 <nander> I don't care if it takes half an hour ;)
14:04:44 <FreeFull> > Any True :: Any
14:04:45 <lambdabot>  Any {getAny = True}
14:04:46 <nander> Or even longer
14:04:54 <erisco> nander, then do it by hand? :)
14:04:59 <FreeFull> The twitter lied
14:04:59 <nander> How do I calculate all permutations of words?
14:05:12 <c_wraith> what do permutations have to do with it?
14:05:17 <c_wraith> also,
14:05:21 <c_wraith> @hoogle permutations
14:05:21 <lambdabot> Data.List permutations :: [a] -> [[a]]
14:05:21 <lambdabot> package action-permutations
14:05:44 <Iceland_jack> > permutations "abcd"
14:05:45 <lambdabot>  ["abcd","bacd","cbad","bcad","cabd","acbd","dcba","cdba","cbda","dbca","bdca...
14:05:56 <Iceland_jack> > length (permutations "abcd")
14:05:57 <lambdabot>  24
14:05:59 <nander> It's more a choose one from a-z, and one other from a-z ;)
14:06:29 <silasm> nander: you just need to know the number you'd get from that?
14:06:35 <FreeFull> > permutations ["Meow","Moo"]
14:06:36 <lambdabot>  [["Meow","Moo"],["Moo","Meow"]]
14:06:48 <nander> I want to know the words :)
14:07:04 <c_wraith> nander: isn't that just a filter?  What do permutations have to do with anything?
14:07:55 <xpika> is it possible to define the function fix with just lambdas in haskell?
14:07:56 <rose_> I have a concurrency bug, but I don't explicitly use concurrency. How can I track it down? The error message is: *** Exception: thread blocked indefinitely in an MVar operation. This error appears randomly when I'm running my program. Here's the Main.hs file. I think it contains the bug. https://github.com/roseperrone/phil/blob/master/src/Main.hs
14:08:10 <acowley> Does cpphs not work on travis-ci?
14:08:32 <nander> I was thinking the wrong way around (fix all combinations that could be a word with the t..) and then remove the ones that aren't words
14:08:37 <nander> But I could do it the other way around
14:08:40 <rose_> When I say "I don't explicitly use concurrency" I mean, I didn't write the concurrency myself.
14:08:52 <silasm> :t mapM (\x -> (. (++ x))
14:08:53 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
14:09:16 <shachaf> rose_: Maybe try rts-xc?
14:09:18 <shachaf> @where rts-xc
14:09:18 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
14:09:18 <athan> :t mapM (\x -> (. (++ x)))
14:09:19 <lambdabot> [[a]] -> ([a] -> c) -> [[a] -> c]
14:13:47 <pranz> :t guard
14:13:48 <lambdabot> MonadPlus m => Bool -> m ()
14:13:58 <Peaker> I wish it was called "the IO type" (that happens to be a Monad instance) and not "the IO monad"
14:14:43 <athan> YES
14:14:46 <shachaf> how about just "IO"
14:14:50 <athan> That would be ideal.
14:15:11 <shachaf> "the Int type"
14:16:08 <athan> Why not give students the clairvoyancy that IO is a datatype with a monad instance, so everyone knows what's what :P
14:20:02 <sebastian_> scotty is usising Text.Lazy and aeson ist using Text. Either I have tons of {to|from}Strict in my json instances, or I have tons of {to|from}Strict in my scotty dispatcher. ARGH
14:20:42 <Kaidelong> http://www.haskell.org/haskellwiki/Top_level_mutable_state I don't really understand why people need this
14:20:57 <johnw> Kaidelong: it has its uses
14:20:58 <rose_> shachaf: My program is a CLI, and whenver I enter any command, I get an error like the following, even though my program otherwise behaves as usual. http://lpaste.net/99224. When I run through my program, the concurrency bug that raises the 'blacked' exception and causes the program to hang doesn't appear, but I'll wait and run it some more. What are all the errors in the lpaste about?
14:21:13 <Kaidelong> johnw: but doesn't parameterization achieve the same end?
14:21:21 <Kaidelong> IORef foo -> IO ...
14:21:25 <johnw> Kaidelong: if you can, yes
14:21:44 <Kaidelong> you could even just use the reader monad
14:21:54 <johnw> you're assuming a lot about how much code can be rewritten
14:22:00 <Kaidelong> make a ReaderT IO
14:22:25 <enthropy> ReaderT (IORef myState) IO?
14:23:57 <Kaidelong> yes
14:24:12 <acowley> I wish I didn't feel bad for travis-ci instances recompiling the same code over and over
14:27:18 <athan> acowley: What's your favorite testing framework for haskell?
14:28:18 <acowley> athan: I don't think I have one. I like some aspects of doctests, but they don't scale up too well, so then I switch to hunit in test-framework... but no days tasty seems to be recommended for that role.
14:28:34 <acowley> If I have properties, then of course QC
14:28:46 <acowley> But frankly, smoke tests are some of the most useful things to me
14:28:57 <athan> smoke tests?
14:29:09 <acowley> Yes, just to check that nothing catches on fire
14:29:20 <acowley> i.e. plug it in, see if there's smoke
14:29:50 <athan> hahha
14:29:51 <athan> right on
14:29:55 <kuribas> How does haskell turn a number into a type?  Does it do automatic coercion of numbers, or is it some buildin functionality?
14:30:08 <kuribas> I mean determine the type of the number.
14:30:11 <acowley> Types are the first, second, and third lines of defense. Then something that just flips the switch. Then something that checks correctness beyond types.
14:30:21 <johnw> kuribas: it looks at how it is used
14:30:27 <acowley> kuribas: type inference
14:30:34 <johnw> if you pass "10" to a function expecting an Int, it will decide that it's an Int
14:30:46 <Iceland_jack> kuribas: You may want to see ‘fromInteger’
14:30:47 <geekosaur> kuribas: numeric literals are applications for fromIntegral (for something without a decimal point) or fromRational
14:30:48 <Iceland_jack> @ty fromInteger
14:30:49 <lambdabot> Num a => Integer -> a
14:30:53 <Iceland_jack> as an example
14:31:06 <geekosaur> type inference and defaulting generally take it from there
14:31:08 <kuribas> Does it work when you define Num instances yourself?
14:31:12 <ski> yes
14:31:13 <Iceland_jack> kuribas: Yes
14:31:15 <aristid> the directly inferred type is either Num a => a or Fractional a => a, depending on whether it is a whole number, i think. then with unification it may become a more specific type.
14:31:34 <Iceland_jack> kuribas: you define “fromInteger” yourself and then you can use Haskell integer literals for your own type
14:31:35 <aristid> :t 4
14:31:36 <lambdabot> Num a => a
14:31:39 <aristid> :t 4.0
14:31:39 <lambdabot> Fractional a => a
14:31:53 <kuribas> That's really neat...
14:32:31 <kuribas> I am making a system for defining variables like in metafont.
14:32:45 <Iceland_jack> kuribas:
14:32:46 <Iceland_jack> > data Number = One | Two | Three | Four deriving Show
14:32:46 <Iceland_jack> > instance Num Number where { fromInteger 1 = One; fromInteger 2 = Two; fromInteger 3 = Three; fromInteger 4 = Four }
14:32:46 <Iceland_jack> > 4 :: Number
14:32:47 <lambdabot>  <hint>:1:1: parse error on input `instance'
14:32:47 <lambdabot>  Not in scope: type constructor or class `Number'
14:32:47 <lambdabot>  can't find file: L.hs
14:32:49 <Iceland_jack> Four
14:32:52 <Iceland_jack> > 1 :: Number
14:32:53 <lambdabot>  Not in scope: type constructor or class `Number'
14:32:54 <Kaidelong> okay so the argument sems to be that global variables can be optomized automatically in ways explicit threading of state can't, I guess I also can't really see why they should be forbidden in libraries
14:32:55 <Iceland_jack> One
14:33:01 <ski> @let data Number = One | Two | Three | Four deriving Show; instance Num Number where { fromInteger 1 = One; fromInteger 2 = Two; fromInteger 3 = Three; fromInteger 4 = Four }
14:33:02 <lambdabot>  .L.hs:157:10: Warning:
14:33:02 <lambdabot>      No explicit method or default declaration for `+'
14:33:02 <lambdabot>      In the instance declaration for `Num Number'
14:33:02 <lambdabot>  
14:33:02 <lambdabot>  .L.hs:157:10: Warning:
14:33:09 <ski> > 4 :: Number
14:33:10 <lambdabot>  Not in scope: type constructor or class `Number'
14:33:22 <Kaidelong> maybe libraries should be allowed to have their own special bindings kind of like "main" in a real program?
14:33:31 <Kaidelong> "initialize" and "finalize"
14:33:36 <aristid> Iceland_jack: if you paste code, at least please don't use "> " as the prefix.
14:33:52 <Iceland_jack> aristid: I know, forgot to change my prompt
14:33:57 <Kaidelong> I guess that's kind of what the ACIO proposal is about
14:34:15 <ski> @let instance Num Number where { fromInteger 1 = One; fromInteger 2 = Two; fromInteger 3 = Three; fromInteger 4 = Four; [(+),(-),(*)] = undefined }
14:34:15 <lambdabot>  Parse failed: illegal method definition
14:34:18 <ski> bah'
14:35:12 <Iceland_jack> @let instance Num Number where { fromInteger 1 = One; fromInteger 2 = Two; fromInteger 3 = Three; fromInteger 4 = Four; (+) = undefined; (-) = undefined; (*) = undefined; abs = undefined; signum = undefined }
14:35:13 <lambdabot>  .L.hs:143:14: Not in scope: type constructor or class `Number'
14:35:14 <lambdabot>  
14:35:16 <lambdabot>  .L.hs:144:25: Not in scope: data constructor `One'
14:35:18 <lambdabot>  
14:35:19 <Iceland_jack> bah
14:35:20 <lambdabot>  .L.hs:145:25: Not in scope: data constructor `Two'
14:35:28 <quchen_> Parse failed: instance violates the laws of good taste and reason
14:35:30 <ski> @let instance Num Number where { fromInteger 1 = One; fromInteger 2 = Two; fromInteger 3 = Three; fromInteger 4 = Four; (+) = undefined; (-) = undefined; (*) = undefined; abs = undefined; signum = undefined }
14:35:30 <lambdabot>  .L.hs:143:14: Not in scope: type constructor or class `Number'
14:35:30 <lambdabot>  
14:35:30 <lambdabot>  .L.hs:144:25: Not in scope: data constructor `One'
14:35:30 <lambdabot>  
14:35:30 <lambdabot>  .L.hs:145:25: Not in scope: data constructor `Two'
14:35:55 <ski> > 4 :: Number  -- there
14:35:56 <lambdabot>  Four
14:36:13 <Iceland_jack> kuribas: Hope the point didn't get lost in the noise :)
14:36:23 <kuribas> nope, point taken!
14:36:34 <magneticduck> what's the most concise way you can think of to check whether some value was constructed with some constructor?
14:36:41 <magneticduck> like what isJust does
14:36:50 <magneticduck> what's a cool way to do that
14:36:53 <magneticduck> trying to think
14:36:53 <Iceland_jack> magneticduck: pattern matching with Constructor{]?
14:36:55 <kuribas> I have a type for a number that can be an unknown variable.  It will lookup that variable in a environment and can construct a linear combination of unknown variables.
14:36:56 <Iceland_jack> Contrustor{}
14:37:03 <magneticduck> (besides an inline case statement)
14:37:10 <magneticduck> Iceland_jack: no
14:37:14 <magneticduck> hm?
14:37:14 <Iceland_jack> It's quite a powerful feature, but it's a shame that it requires all that unrelated stuff (signum?)
14:37:17 <kuribas> The neat thing is that I can make it a number, and use the normal math functions on it.
14:37:26 <magneticduck> mm
14:37:30 <acowley> Btw, for posterity, I needed to apt-get install cpphs in my travis-ci config
14:37:36 <magneticduck> waht is Contrustor
14:37:46 <geekosaur> @src fromJust
14:37:46 <lambdabot> fromJust Nothing  = undefined
14:37:46 <lambdabot> fromJust (Just x) = x
14:37:59 <magneticduck> geekosaur: I mean, in-line
14:38:10 <jrmithdobbs> am I missing something? How can you take a Builder and get the underlying functions backing it without dumping the whole thing in ram first
14:38:11 <geekosaur> then you need case
14:38:16 <magneticduck> (\x -> case x of (Just _) -> True _ -> False) or something
14:38:18 <magneticduck> but cooler
14:38:22 <Iceland_jack> magneticduck: Just any constructor
14:38:23 <magneticduck> isn't there a cooler way?
14:38:30 <magneticduck> haskell is cool
14:38:33 <ski> > let isJust Just{} = True; isJust Nothing{} = False in map isJust [Nothing,Just 2]
14:38:34 <geekosaur> unless you want to be craply partial: \(Just x) -> x
14:38:35 <lambdabot>  [False,True]
14:38:35 <magneticduck> I mean, case is nice
14:38:53 <magneticduck> but I'm tryin' to do all the haskell ninjain' I can
14:39:13 <ski> > let isJust x = (not . null) [() | Just{} <- x] in map isJust [Nothing,Just 2]
14:39:14 <jrmithdobbs> trying to use aeson to generate some json but it's final destination is a conduit but I can only find ways to get lazy bytestrings out :(
14:39:14 <lambdabot>  Couldn't match expected type `[Data.Maybe.Maybe t0]'
14:39:15 <lambdabot>              with actual type `Data.Maybe.Maybe a0'Couldn't match expected ty...
14:39:15 <lambdabot>              with actual type `Data.Maybe.Maybe a1'
14:39:15 <magneticduck> oh, didn't know that syntax
14:39:30 <ski> > let isJust x = (not . null) [() | Just{} <- [x]] in map isJust [Nothing,Just 2]  -- rather
14:39:31 <lambdabot>  [False,True]
14:39:34 <magneticduck> ski: there!
14:39:38 <magneticduck> very cool
14:39:46 <magneticduck> now uh, hmm?
14:39:48 <magneticduck> uh
14:39:53 <supki> > has _Just (Just 3)
14:39:54 <lambdabot>  True
14:40:03 <magneticduck> ................
14:40:10 <ski> magneticduck : however, what do you want this for ?
14:40:15 <ski> @where boolean-blindness
14:40:15 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
14:40:26 <magneticduck> ski: nothin'
14:40:29 <magneticduck> just fooling around
14:40:35 <FreeFull> > let isJust = maybe False (const True) in isJust (Just 3)
14:40:36 <lambdabot>  True
14:40:40 <magneticduck> trying to figure out the last thing you did
14:40:48 <FreeFull> > let isJust = maybe False (const True) in isJust Nothing
14:40:48 <lambdabot>  False
14:40:51 <pranz> :t for
14:40:52 <lambdabot>     Not in scope: `for'
14:40:52 <lambdabot>     Perhaps you meant one of these:
14:40:52 <lambdabot>       `T.for' (imported from Data.Traversable),
14:40:57 <pranz> :t T.for
14:40:58 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
14:41:01 <magneticduck> felipe_: yeah there's always maybe
14:41:28 <ski> > reverse "ratfor"
14:41:29 <lambdabot>  "roftar"
14:41:54 <magneticduck> > let isJust x = (not . null) [() | Just{} <- [x]] in map isJust [Nothing, (Just 1)]
14:41:55 <lambdabot>  [False,True]
14:42:06 <magneticduck> I still don't get that
14:42:10 <magneticduck> what is Just{}?
14:42:13 <FreeFull> @let for = flip map
14:42:14 <lambdabot>  Defined.
14:42:16 <Iceland_jack> magneticduck: Constructor{} matches a constructor of type Constructor
14:42:16 <FreeFull> :t for
14:42:17 <lambdabot> [a] -> (a -> b) -> [b]
14:42:20 <Iceland_jack> It's what I posted earlier
14:42:32 <magneticduck> mm
14:42:37 <FreeFull> @let for = flip fmap
14:42:38 <lambdabot>  .L.hs:160:1:
14:42:38 <lambdabot>      Multiple declarations of `for'
14:42:38 <lambdabot>      Declared at: .L.hs:159:1
14:42:39 <lambdabot>                   .L.hs:160:1
14:42:44 <geekosaur> magneticduck, it's the degenerate form of a record
14:42:47 <quchen_> magneticduck: Remember how to pattern-match record syntax? "{}" is like matching on "any amount of fields containing anything".
14:42:48 <magneticduck> how is [Just 1] matching Just{}
14:42:48 <FreeFull> :t for
14:42:51 <lambdabot>     Not in scope: `for'
14:42:52 <magneticduck> oh wait
14:42:55 <lambdabot>     Perhaps you meant one of these:
14:42:56 <FreeFull> @let for = flip fmap
14:42:57 <lambdabot>       `T.for' (imported from Data.Traversable),
14:42:59 <lambdabot>  .L.hs:142:12:
14:43:01 <lambdabot>      No instance for (Functor f0) arising from a use of `fmap'
14:43:03 <lambdabot>      The type variable `f0' is ambiguous
14:43:05 <lambdabot>      Possible fix: add a type signature that fixes these type variable(s)
14:43:07 <lambdabot>      Note: there are several potential instances:
14:43:10 <magneticduck> lol shut up lambdabot
14:43:15 <Iceland_jack> magneticduck:
14:43:16 <Iceland_jack> > [ x | Just x <- [Just 'a', Nothing, Just 'b'] ]
14:43:16 <lambdabot>  "ab"
14:43:25 <FreeFull> @let for :: (Functor f) => f a -> (a -> b) -> f b; for = flip fmap
14:43:26 <lambdabot>  Defined.
14:43:27 <Iceland_jack> That's just regular list comprehension
14:43:29 <magneticduck> I.. I didn't know that..
14:43:31 <magneticduck> what..
14:43:35 <Iceland_jack> Well now you do :)
14:43:37 <magneticduck> well. Learned something.
14:43:40 <magneticduck> that was satisfying
14:43:47 <Iceland_jack> @src catMaybes
14:43:47 <lambdabot> catMaybes ls = [x | Just x <- ls]
14:43:50 <Iceland_jack> There you go
14:43:52 <magneticduck> I thought it knew all of base haskell pretty much
14:44:01 <FreeFull> > fail :: [Int]
14:44:02 <lambdabot>  Couldn't match expected type `[GHC.Types.Int]'
14:44:02 <lambdabot>              with actual type `GHC.Base.String -> m0 a0'
14:44:09 <FreeFull> > fail "something" :: [Int]
14:44:10 <lambdabot>  []
14:44:18 <magneticduck> @type fail
14:44:19 <lambdabot> Monad m => String -> m a
14:44:27 * magneticduck facepalm
14:44:32 <magneticduck> oh, that's right
14:44:43 <quchen_> Facepalm is the appropriate reaction to that type, yes
14:45:03 <magneticduck> yeah, also a reaction to my forgetting about it
14:45:17 <rose_> shachaf: I think it's fixed.
14:45:56 <magneticduck> I still don't understand records and list comprehensions it seems
14:46:20 <athan> records are just syntactic sugar
14:46:32 <magneticduck> yeah
14:46:32 <athan> for extracting type parameters
14:47:00 <Peaker> records let you give names to fields, I wouldn't call it syntactic sugar
14:47:09 <Qett> is <*> just an infix form of fmap?
14:47:16 <athan> so data Foo {getA a, getB b} == Foo a b, but with getA defined as getA Foo a _ = a
14:47:20 <Peaker> Qett: no, but <$> is
14:47:27 <Iceland_jack> @src (<$>)
14:47:28 <lambdabot> f <$> a = fmap f a
14:47:33 <Qett> ah
14:47:35 <Qett> ok
14:47:38 <Iceland_jack> (<*>) doesn't have the same type as fmap :)
14:47:40 <Iceland_jack> @ty (<*>)
14:47:41 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:47:54 <quchen_> (pure f <*>) = fmap f -- though
14:48:05 <Qett> oh yeah
14:48:07 <Qett> i see
14:48:11 <Iceland_jack> (of course neither does (<$>))
14:48:54 <Peaker> Qett: http://lpaste.net/99225
14:50:07 <ski> @type [fmap,(<$>)]  -- does too :)
14:50:08 <lambdabot> Functor f => [(a -> b) -> f a -> f b]
14:50:15 <Iceland_jack> heh
14:50:15 <silasm> nander: grr, all that work and it turned out to just be replicateM; I wanted to figure out how to do it using the list monad.
14:50:21 <Iceland_jack> @ty fmap
14:50:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:50:24 <Iceland_jack> @ty (<$>)
14:50:25 <lambdabot> Functor f => (a -> b) -> f a -> f b
14:50:37 <silasm> > replicateM 3 "abc"
14:50:38 <lambdabot>  ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","bb...
14:50:45 <silasm> nander: ^
14:50:48 <nander> silasm, I used an equals function ;)
14:50:52 <nander> I just wrote my own equals
14:51:02 <nander> With some pattern matching, recursively
14:51:15 <ski> (your own equals on what ?)
14:51:46 <silasm> ski: he was trying to do some weird string matching, so I assume on strings.
14:52:01 <silasm> (so I assume he doesn't mean Eq)
14:52:19 <nander> http://www.pasteall.org/49153
14:52:32 <silasm> nander: I still can't figure out why you aren't using regular expressions.
14:52:41 <nander> Probably because I 'm a noob ;)
14:53:37 <Peaker> nander: "equals" is a bad name for "matches" :)
14:53:49 <silasm> that was a fun exercise in simplicity. I spent like half an hour trying to figure out how to do replicateM n <list>; I was trying to do it mixing applicatives and monads and that was weeird.
14:54:43 <Peaker> silasm: it's purely Applicative, apparently
14:54:53 <nander> The functional programming course I took (for 5 credits) really handled just the basics
14:55:18 <nander> I try to maintain my haskell a bit, so it's just my language for solving puzzles ;)
14:55:27 <nander> It's a neat language for puzzling
14:55:32 <silasm> nander: regular expressions aren't functional programming; they're pretty much a DSL for string matching.
14:56:08 <Qett> i wish all these wierd symbols for monads and functors had alphabetical names
14:56:40 <athan> ?
14:56:49 <athan> Qett: how do you mean?
14:57:27 <Qett> athan: like mmap for >>= and stuff
14:57:49 <Iceland_jack> (>>=) would be bind
14:57:59 <Qett> yeah
14:58:02 <athan> Qett: oooooh, you mean standardized symbols for them?
14:58:32 <Qett> well yeah standardized names
14:59:22 <athan> Qett: Look up the "Applicative Monad Proposal"
14:59:45 <FreeFull> <*> is ap
14:59:54 * ski . o O ( "renaming `Functor' to `Mapplicative'" )
15:00:03 <athan> Qett: It relates a lot of those functions together. I feel like standard names will evolve in the future (at least in Haskell2014 there will be better coordination of typeclasses)
15:00:20 <Qett> oh ok ill read it
15:00:21 <hpc> . o O (Joiniplacative)
15:01:37 <joelteon> so the haddocks for thyme say that NominalDiffTime has a Real instance. but apparently it doesn't.
15:01:55 <Peaker> Copointed => Lift0, Functor => Lift1, Applicative => (Lift0, Lift2), Monad => (Applicative, Join)
15:02:34 <FreeFull> Copointed?
15:02:52 <Peaker> class Lift0 f where lift0 :: a -> f a ; class Lift1 f where lift1 :: (a -> b) -> f a -> f b ; class Lift2 f where lift2 :: (a -> b -> c) -> f a -> f b -> f c ; class Join j where join :: j (j a) -> j a
15:03:04 <Peaker> oops, Pointed, I guess :)
15:03:16 <FreeFull> What would Copointed be again?
15:03:28 <athan> WOAH
15:03:47 <quchen_> FreeFull:  f a -> a
15:03:53 <quchen_> "Comonad without =>>"
15:03:56 <Peaker> class Pointed p where point :: a -> p a  (basically pure)   and   class Copointed p where copoint :: p a -> a    (basically extract, from Comonad)
15:04:33 <athan> What are some practically useful comonads?
15:04:38 <athan> do you ever see them in the wild?
15:04:56 <Kaidelong> so what exactly does Backwards mean?
15:05:01 <athan> or co-<term>'s?
15:05:01 <FreeFull> Ah, that makes sense
15:05:03 <Peaker> Kaidelong: from Applicative?
15:05:06 <Kaidelong> applicative functor with left associative <*>?
15:05:12 <acowley> joelteon: It does for me?
15:05:24 <Peaker> Kaidelong: reverse effect ordering..  <*> runs effects right-to-left
15:05:33 <FreeFull> athan: I think one of the things about Comonads is that their use tends to be very localised
15:05:48 <Kaidelong> yes but what does that actually mean, you can't simply flip(<*>)
15:05:55 <Peaker> Kaidelong: you sort of can:
15:06:10 <Peaker> <*> = liftA2 ($)
15:06:14 <ski> hm, i wonder whether "backwards" wouldn't be called "opposite"
15:06:22 <acowley> joelteon: http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Clock.html
15:06:32 <Peaker> @type flip (liftA2 (flip ($)))
15:06:33 <lambdabot> Applicative f => f (a -> c) -> f a -> f c
15:06:53 <Peaker> Kaidelong: you flip inside and outside, the effect ordering is reversed
15:06:58 <FreeFull> :t (<*>)
15:06:58 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:07:18 * hackagebot http-conduit-downloader 1.0.11 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.11 (VladimirShabanov)
15:07:26 <Peaker> Kaidelong: Backwards is one of the ways that Applicative's difference from Monads is highlighted in a useful way - you can't do this with Monad (without insane, dangerous recursive knot tying)
15:07:31 <joelteon> acowley: thyme, not time
15:07:39 <Kaidelong> do you have a yes or no answer regarding if it just changes the way (<*>) associates?
15:07:41 <Peaker> (and MonadFix'ness hell, too, I think)
15:07:42 <joelteon> thyme is a verbatim rewrite
15:07:49 <joelteon> that's a bit faster
15:08:01 <acowley> joelteon: Oh, I thought they re-exported NominallDiffTime!
15:08:07 <Peaker> Kaidelong: I don't know, need to think about it
15:08:14 <ski> @hoogle Dual
15:08:14 <lambdabot> Data.Monoid Dual :: a -> Dual a
15:08:14 <lambdabot> Data.Monoid newtype Dual a
15:08:14 <lambdabot> package dual-tree
15:08:24 <ski> hm, what's it called for `Ord' ?
15:08:36 <Kaidelong> I just looked at the definition
15:08:43 <shachaf> ski: Down?
15:08:55 <Kaidelong> Backwards f <*> Backwards a = Backwards (a <**> f)
15:09:28 <Peaker> @src (<**>)
15:09:28 <lambdabot> (<**>) = liftA2 (flip ($))
15:09:30 <Kaidelong> <**> has a different type from <*>
15:09:40 <Kaidelong> so I'm not sure how that work... oh!
15:09:44 <Peaker> note the "f" and "a" are swapped
15:09:46 <Kaidelong> I see
15:09:56 <Kaidelong> yes, just noticed that
15:10:14 <randomclown> :t <**>
15:10:14 <lambdabot> parse error on input `<**>'
15:10:15 <Kaidelong> mmm, so if we have
15:10:19 <randomclown> :t (<**>)
15:10:20 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
15:10:31 <randomclown> :t ))<>((
15:10:32 <lambdabot> parse error on input `)'
15:10:35 <randomclown> back and forth forever
15:11:01 <Kaidelong> (f <*> g) <*> h, translate that to h <**> (g <**> f)
15:11:06 <Kaidelong> associativity doesn't change
15:11:15 <Kaidelong> oh
15:11:17 <Kaidelong> maybe it does
15:11:21 <Kaidelong> yes it does
15:11:27 <ski> @hoogle Down
15:11:27 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Down :: KeyState
15:11:28 <lambdabot> GHC.Exts Down :: a -> Down a
15:11:30 <lambdabot> GHC.Exts newtype Down a
15:12:02 <ski> shachaf : mhm, ok
15:12:19 * hackagebot http-conduit-downloader 1.0.12 - HTTP downloader tailored for web-crawler needs.  http://hackage.haskell.org/package/http-conduit-downloader-1.0.12 (VladimirShabanov)
15:15:04 <Kaidelong> actually I'm not so sure about that now
15:27:49 <kuribas> Does haskell make a difference between a function defined as f a b c = ... of f a b = \c ... ?
15:28:42 <quchen_> kuribas: Haskell does not, but implementations might have subtle differences.
15:28:49 <quchen_> Only fully qualified functions are inlined, for example.
15:29:04 <quchen_> So if you have "f a b c" and you use "f a b", there will be no inlining.
15:29:14 <Saizan> kuribas: i think ghc sometimes uses differences like that as a hint of how to compile the function
15:29:24 <kuribas> I see...
15:29:37 <quchen_> On the other hand, if you use "f a b = \c ->", then using "f a b" might get inlined.
15:30:19 <Peaker> also, for the first argument:  f = \x -> ...    and f x = ...     are different because the former triggers the dreaded MR (if not accompanied by a type signature)
15:32:05 <mm_freak> sometimes the lambda form can be used to precompute something for a function that will be called many times
15:32:26 <mm_freak> f x = let y = … in y `seq` \z -> …
15:32:31 <kuribas> right
15:32:41 <kuribas> That's actually what I wanted.
15:33:00 <Peaker> seq is so ugly, surely BangPatterns can be relied upon instead?
15:33:12 <mm_freak> then you say:  let g = f x in g `seq` map g xs
15:33:14 <mm_freak> something like that
15:33:27 <mm_freak> Peaker: why?  seq is perfectly clear there
15:33:46 <Peaker> f x = let !y = ... in \z -> ...   is nicer, 'y' is usually a longer name to repeat
15:34:10 <mm_freak> Peaker: does that even have the same effect?
15:34:27 <Peaker> What would let !y = ... do if not that?
15:34:40 <mm_freak> no idea…  bang patterns for non-arguments are weird
15:34:45 <mm_freak> seq makes sense to me
15:34:49 <mm_freak> bang patterns never did
15:35:10 <Peaker> foo $! bar   is so much nicer than bar `seq` foo bar    too
15:35:22 <quchen_> preflex: seen Tibbe
15:35:36 <mm_freak> Peaker: yes, ($!) is nice, but sometimes seq is simply the most appropriate tool
15:35:51 <jfischoff> preflex: seen tibbe
15:35:58 <jfischoff> preflex seen tibbe
15:36:02 <mm_freak> simply because it is very easy to understand and predict
15:36:02 <quchen_> Preflex isn't online.
15:36:05 <jfischoff> eh
15:36:17 <jfischoff> mauke runs it I think
15:36:19 <quchen_> Unfortunately, neither is Tibbe, who would also be able to answer the question.
15:37:00 <jfischoff> leave a message perhaps
15:38:07 <Peaker> mm_freak: It violates DRY.. nicer to learn the rules behind BangPatterns IMO
15:38:43 <mm_freak> Peaker: if that violates DRY, then haskell as a whole violates it…  you do write type signatures and then you repeat the name to define it
15:38:46 <mm_freak> this is no different
15:39:15 <mm_freak> one mention is the definition/bind, the next is the evaluation sequencing and finally you have application
15:39:18 <Peaker> mm_freak: indeed, that is an annoying part of Haskell too :)
15:39:25 <mm_freak> Peaker: it's not, it makes sense
15:39:35 <Peaker> application and definition using the same name is not a DRY violation
15:39:51 <Peaker> but definition and accompanying type signature is
15:39:57 <mm_freak> Peaker: the sequencing and application is not either
15:40:10 <Peaker> "sequencing" as in "seqing"?
15:40:19 <mm_freak> yes, hence the name ;)
15:40:23 <mm_freak> it sequences evaluation
15:40:39 <Peaker> well, it doesn't, it just gives the strictness semantics
15:40:45 <Peaker> (that's why "pseq" has to exist)
15:41:06 <Peaker> but anyway, bangpatterns and ($!) let you say the same thing as seq more concisely (and IMO more readably too)
15:41:06 <quchen_> jfischoff: For what it's worth, you can also ask IRCBrowse for nicknames. Tibbe seems to be gone for two weeks now.
15:41:34 <mm_freak> anyway, all i know is that i understand the time and space requirements of my programs today, because i have moved away from bang patterns (which i never understood) to seq (which is very easy to understand)
15:41:44 <mm_freak> i do use ($!)
15:42:07 <Peaker> mm_freak: if that's because you haven't bothered to learn what bang patterns do -- then it's akin to someone porting his Haskell program to Java and saying the same? :)
15:42:22 * hackagebot HList 0.3.1.0 - Heterogeneous lists  http://hackage.haskell.org/package/HList-0.3.1.0 (AdamVogt)
15:42:30 <mm_freak> Peaker: you're getting offensive, because i don't agree with your way of thinking
15:42:53 <Peaker> mm_freak: sorry, didn't mean to offend -- just that bang patterns like many tools have a learning cost and benefit trade-off
15:43:07 <quchen_> BangPatterns are hard to understand? Then I don't understand BangPatterns
15:43:16 <mm_freak> Peaker: and my opinion is that the learning cost is high and the benefit is near zero
15:43:51 <Peaker> there's no new concept to learn - just simple rules about what forcings are attached to what?
15:44:03 <Peaker> I don't think this can be a high learning cost..
15:44:07 <mm_freak> also seq allows you to be more precise about evaluation
15:44:21 <mm_freak> f x = … f $! succ x
15:44:27 <simpson> @unmtl EitherT a (State s a)
15:44:27 <lambdabot> EitherT a (State s a)
15:44:33 <simpson> @unmtl EitherT a (StateT s m a)
15:44:33 <lambdabot> EitherT a (StateT s m a)
15:44:36 <mm_freak> in most cases better than:  f !x = … f (succ x)
15:44:46 <Peaker> @unmtl EitherT a (StateT s m) a
15:44:46 <lambdabot> EitherT a (StateT s m) a
15:44:56 <Peaker> I guess it doesn't know EitherT
15:45:01 <simpson> Yeah, guess not.
15:45:05 <mm_freak> a side effect of bang patterns is that the base case will often leave one layer unevaluated
15:45:17 <Peaker> @unmtl ErrorT a (StateT s m) a
15:45:17 <lambdabot> (StateT s m) (Either a a)
15:45:18 <mm_freak> was that clear to you before i just said it?
15:45:42 <mm_freak> if no, then bang patterns are too hard to understand
15:45:45 <simpson> runEitherT :: m (Either e a)
15:45:54 <Peaker> mm_freak: I've encountered that -- but IIRC it's more a question of how the recursion is expressed than of Bang vs. seq?
15:45:56 <maxiepoo> :t runEitherT
15:45:56 <lambdabot>     Not in scope: `runEitherT'
15:45:57 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
15:46:09 <mm_freak> Peaker: no, it's indeed bang patterns vs. seq
15:46:14 <Peaker> @src foldl'
15:46:14 <lambdabot> foldl' f a []     = a
15:46:14 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:46:18 <simpson> So it looks like: s -> (Either e a, s)
15:46:27 <simpson> Which is roughly what I wanted.
15:46:28 <mm_freak> because seq will allow you to produce an evaluated result
15:46:40 <mm_freak> Peaker: just write foldl' using bangs
15:46:51 <mm_freak> you will notice that the base case will leave the final application unevaluated
15:47:09 <mm_freak> and many forcing algorithms are in essence left folds
15:47:16 <Peaker> mm_freak: foldl' seems more like a case for ($!) than bangs
15:47:26 <Peaker> there's a seq of an arg and then an application of that arg
15:47:32 <mm_freak> now write the recursive case of foldl' using ($!)
15:47:34 <mm_freak> and compare
15:47:59 <Peaker> if I use bangs, I'd place bangs on both a args in both equations
15:48:09 <mm_freak> but that's not enough
15:48:19 <mm_freak> the final application will remain unevaluated
15:48:40 <mm_freak> wrong: foldl' f !z (!x:xs) = foldl' f (f z x) xs
15:48:43 <Peaker> yeah, a' /= a, a' = f a x
15:49:07 <mm_freak> ugly:  foldl' f z (x:xs) = (foldl' f $! f z x) xs
15:49:13 <mm_freak> (and even wrong, too)
15:49:44 <Peaker> why is the ($!) one wrong?
15:50:00 <Peaker> bang patterns are wrong here because the forcing is not of an arg we get
15:50:14 <mm_freak> because it forces the evaluation before fully applying the recursion
15:50:34 <Peaker> just like the seq does?
15:50:44 <mm_freak> no, the seq does exactly the right thing
15:50:56 <mm_freak> foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
15:51:46 <Peaker> this should be equivalent to: foldl' f z (x:xs) = let !y = f z x in foldl' f y xs
15:51:53 <mm_freak> here the result of the recursive call will force y
15:52:03 <mm_freak> i have no idea what that 'let' does
15:52:20 <jle`> anyone here use netwire?
15:52:22 <Peaker> afaik it should be equivalent
15:52:28 <mm_freak> jle`: me (obviously) =)
15:52:34 <jle`> :P
15:52:44 <jle`> i am using a became wire to pop out an event when a predicate is true
15:52:50 <jle`> became pred -< val
15:52:55 <jle`> but i don't want an event of the type of val
15:53:08 <mm_freak> jle`: an event when a predicate is true?
15:53:10 <jle`> i want an event with a value i want...say...Nothing
15:53:12 <Peaker> mm_freak: but anyway, the only difference between foldl' with seq and with (... $! f z x) xs    seems to be argument saturation which is irrelevant here?
15:53:15 <jle`> mm_freak: yes
15:53:18 <jle`> so right now i'm using
15:53:25 <mm_freak> jle`: could you give an example?
15:54:20 <jle`> ev <- ((const DesiredContent)<$>) <$> became (pred :: Int -> Bool) -< (val :: Int)
15:54:24 <mm_freak> Peaker: it's not irrelevant…  you are indeed telling the compiler that you want y evaluated before fully applying foldl'
15:54:35 <jle`> so whenever val starts satisfying the predicate, an event pops out...but it's an Event Int
15:54:39 <jle`> I want an Event DesiredContent
15:54:46 <jle`> right now that works...i think....
15:54:47 <Peaker> mm_freak: but y `seq` foldl' ... y ...   is also telling the compiler the same thing
15:54:52 <jle`> but there is probably a more expressive way?
15:55:07 <triliyn> :t (<*)
15:55:10 <lambdabot> Applicative f => f a -> f b -> f a
15:55:36 <mm_freak> jle`: crap…  'became' should not be exported by FRP.Netwire
15:55:48 <mm_freak> became violates FRP
15:55:53 <jle`> heh
15:55:57 <jle`> oops
15:56:50 <jle`> well how do I make an event stream of DesiredContent (a constructor with no arguments)...that has an event whenever val begins to satisfy a predicate?
15:57:06 <jle`> what i'm doing works right now but i do'nt think it...is what i'm supposed to be doing
15:57:53 <mm_freak> jle`: well, you can turn a boolean signal into an interval
15:58:24 <mm_freak> do you understand inhibition/intervals?
15:58:46 <jle`> hm i feel like i do
15:58:53 <jle`> but i always feel like i understand everything before i find out i don't
15:59:03 <jle`> oh
15:59:06 <jle`> so i can use when
15:59:19 <jle`> and then...
15:59:41 <jle`> hm.
16:00:08 <jle`> oh
16:00:18 <jle`> i can use when...and then a switch?
16:00:20 <jle`> er
16:00:22 <jle`> until
16:01:10 <jle`> something --> now
16:02:30 <jle`> (_,ev) <- unless (\(val,_) -> pred val) --> snd <$> now -< (val,DesiredContent)
16:02:33 <jle`> ?
16:02:54 <jle`> is this the right track?
16:05:08 <mm_freak> jle`: do you remember me saying that in netwire time is a topological space?
16:05:16 <mm_freak> this is related to signal inhibition
16:05:22 <Sculptor> signals
16:05:51 <mm_freak> jle`: i wanted to preserve continuous time semantics while allowing weird cases like the arrow hitting to be written exactly
16:06:12 <mm_freak> so i've been slightly lying about the semantics of netwire earlier =)
16:06:27 <mm_freak> type Behavior a = Time -> Maybe a
16:07:00 <mm_freak> intuitively a behavior in netwire is a time-varying value that may be absent from time to time…  but the intervals of presence and absence must have nonzero length
16:07:36 <mm_freak> thus netwire actually does allow you to convert a Behavior Bool to a Behavior () that inhibits…  and you can use that together with (-->) or (<|>) to formulate your system
16:09:53 <jle`> hm. okay, so is this switching that I'm trying to do the proper approach sorta? once I get the types to compilr
16:10:31 <mm_freak> jle`: well, 'became' is wrong…  it's a bug that it is exported by FRP.Netwire
16:10:55 <jle`> hm. how about the unless/until and now?
16:10:56 <mm_freak> but 'when' and 'unless' are correct
16:11:05 <jle`> i'll be sure to avoid uses of became
16:11:14 <mm_freak> all wires in Control.Wire.Interval are correct
16:11:33 <jle`> although I'm not totally sure I understand why became breaks semantics
16:11:55 <mm_freak> became :: (a -> Bool) -> Behavior a -> Event a
16:11:58 <mm_freak> try to write this function
16:12:10 <mm_freak> you will run into the arrow-hit problem
16:12:44 <jle`> but unless/when do not?
16:12:52 <mm_freak> nope
16:13:30 <jle`> also as a side note is is rather unfortunate that I chose archers, as I can't make a "data Arrow" heh
16:13:34 <mm_freak> i have proven all interval wires correct on paper…  i will probably translate my paper proofs to real proofs in agda some day
16:13:48 <mm_freak> well…
16:14:01 <mm_freak> data Arrow = Arrow { position :: V2 Double, … }
16:14:15 <mm_freak> except perhaps you should choose a different name =)
16:14:41 <jle`> heh yeah I'm using AArrow... but still annoying
16:14:55 <mm_freak> if your archers use modern crossbows you can call it Bolt =)
16:15:13 <jle`> this is a major design flaw of the hierarchical Haskell libraries in HP/base
16:15:24 <jle`> I can't make medieval battles.
16:15:29 <mm_freak> hehe
16:16:04 <jle`> Bolt is nice :)
16:16:17 <mm_freak> nice, but wrong =)
16:16:35 <colDrMcBeardman> mm_freak, they had handheld crossbows in the middle ages.
16:16:43 <jle`> okay, I'm in class now but I'll try to try to figure out later the fundamental difference between became and when and why one breaks and the other doesn't
16:17:21 <jle`> I still feel like you can implement became using when/unless and switching but I'm sure after playing around with it I i'll see the point
16:17:56 <colDrMcBeardman> jle`, you could also use dart, or missile, though missile is more than just arrows.
16:19:15 <jle`> darts feel rather impotent in comparison
16:19:25 <mm_freak> jle`: just translate them to the model
16:19:28 <jle`> to the power of the mighty arrow
16:19:40 <mm_freak> became :: (a -> Bool) -> Behavior a -> Event a
16:20:08 <jle`> hm. are you saying that I can implement when/unless without a time step, but not became?
16:20:09 <Fuuzetsu> there's the package old-locale, is there a new-locale that we're meant to use?
16:20:10 <mm_freak> when :: (a -> Bool) -> Behavior a -> Behavior a
16:20:22 <mm_freak> jle`: yes, that's what i'm saying
16:20:31 <colDrMcBeardman> jle`, no, they called arrows darts as well in ye olde days.
16:21:01 <colDrMcBeardman> missile sounds pretty cool, if you don't plan on having slingers.
16:22:18 <jle`> colDrMcBeardman: thanks, that helps legitimize it in my head
16:28:14 <defanor_> how to stop execution of a function in haskell-mode?
16:28:55 <kuribas> C-c C-c?
16:29:05 <defanor_> kuribas: thanks
16:29:21 <kuribas> no problem
16:31:09 <jle`> thanks again mm_freak
16:40:31 <mmmm> Is there a simple explanation to the error message "Could not find GHC.Generics" when using cabal install __ ?
16:41:33 <athan> @src sequence
16:41:33 <lambdabot> sequence []     = return []
16:41:33 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:41:33 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
16:41:51 <athan> @src forM
16:41:52 <lambdabot> forM = flip mapM
16:41:57 <athan> @src mapM
16:41:57 <lambdabot> mapM f as = sequence (map f as)
16:43:38 <Peaker> athan: have you studied Applicative?
16:44:16 <Peaker> athan: you might be interested to know that "sequence" and thus "mapM" and "forM" are all Applicative-compatible, and Monad-requiring for historical reasons
16:44:21 <ivanm> @type foldr (liftA2 (:)) (pure [])
16:44:22 <lambdabot> Applicative f => [f a] -> f [a]
16:44:28 <pavonia> mmmm: What GHC versions do you use?
16:44:33 <pavonia> *version
16:44:36 <ivanm> though I suppose if you were going to do that you might as well use sequenceA from Traversable
16:45:36 <jle`> mm_freak: does "now" break semantics?
16:45:56 <athan> Peaker: Thank you!
16:45:57 <hpc> as in acme-now? i would say yes
16:46:15 <athan> Peaker: I have a little bit
16:46:20 <jle`> or.. well I guess it doesn't heh because it can be implemented without dt
16:46:40 <jle`> what about (-->) then?
16:46:47 <Fuuzetsu> I wait for the day when Google will serve me what I want when I search for ‘transformers base’
16:47:05 <athan> Could you write a haskell program that transforms + fills-in haskell code?
16:47:17 <athan> like substituting terms, etc.?
16:47:20 <ivanm> athan: by "transforms", look at HaRe
16:47:53 <hpc> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
16:47:53 <lambdabot> f a b = a (\ c _ -> b c) b
16:47:57 <athan> awesome! Thank you!
16:48:15 <colDrMcBeardman> jle`, np.
16:51:17 <ReinH> well, you can ask djinn to write your, e.g., (r ->) Applicative instance for you
16:51:19 <mmmm> pavonia: 7.4.1
16:52:45 <ReinH> @djinn a -> r -> a
16:52:45 <lambdabot> f a _ = a
16:52:48 <ReinH> that's pure
16:52:51 <ReinH> @djinn (r -> a -> b) -> (r -> a) -> (r -> b)
16:52:52 <lambdabot> f a b c = a c (b c)
16:52:56 <ReinH> that's <*>
16:53:26 <hpc> someone should special-case djinn to output a c (d c)
16:53:32 <ReinH> hah
16:54:32 <pavonia> mmmm: Weird. Can you run "cabal install yourpackage -v" and paste the output?
16:56:23 <mmmm> http://lpaste.net/99228
16:58:38 <pavonia> mmmm: ghc-prim is not in the dependency list of the .cabal file
17:04:28 <mmmm> thanks pavonia! I guess it does say haha
17:04:52 <mmmm> I was put off as it threw up more errors
17:04:59 <mmmm> but I've fixed them now as well
17:05:07 <mmmm> time to make a pull request...
17:17:43 <jle`> mm_freak: just got out of class. so wait...is the eventual solution not going to require Events at all?
17:20:12 <maxiepoo> is there no MonadEither class?
17:20:24 <maxiepoo> as in not MonadError
17:20:44 <maxiepoo> because I want to propagate my own Error Type
17:21:21 <jle`> i got ev <- never . unless (\(v,_) -> pred v) --> arr (snd <$>) . now -< (val, DesiredEventThing)
17:21:32 <jle`> but it is still a little...feel kinda not right.
17:21:34 <jle`> but it works.
17:22:05 <athan> When the AMP gets worked into the Haskell Prelude, does that mean we will have the.. IO Applicative/Functor?
17:22:24 <jle`> athan: what do you mean? IO is already an Applicative and a Functor
17:22:27 <ivanm> athan: well, it'll still be a Monad...
17:22:34 <jle`> and it'll be a monad too, yeah.
17:22:50 <athan> jle` Really? I thought it was exclusively a monad
17:22:55 <maxiepoo> otherwise I'd have to explicitly `lift` which is for the birds
17:23:09 <jle`> athan: well...all monads are functors and applicatives
17:23:11 <ivanm> maxiepoo: define your own!
17:23:20 <ivanm> jle`: in theory, not necessarily in practice
17:23:21 <jle`> (but not all Monads are Applicatives and Functors, at least not now)
17:23:29 <ivanm> good save :p
17:23:32 <jle`> :P
17:23:38 <jle`> just like how not all monoids are Monoids
17:24:05 <jle`> anyways, if you have a Monad, you can implement an Applicative and Functor instance for free
17:24:13 <athan> hahaha.
17:24:17 <mgoszcz2> Guys. Can you teach me how to simplify this: (map $ map read) . map words . lines <$> readFile input
17:24:20 <jle`> IO already has a Functor and Applicative instance
17:24:37 <jle`> > map toUpper <$> getLine
17:24:38 <lambdabot>  <IO [Char]>
17:24:43 <ivanm> mgoszcz2: map (map read . words) . lines <$> readFile input
17:25:00 <Axman6> mgoszcz2: map (map read . words) . lines <$> readFile input
17:25:04 <Axman6> ha
17:25:08 <Axman6> hey ivanm =)
17:25:11 <ivanm> hey Axman6
17:25:28 <mgoszcz2> So the only way to do this is to use lot's of 'map'?
17:25:30 <Axman6> how's it going?
17:25:41 <ivanm> not too bad
17:25:47 <Axman6> mgoszcz2: no, there's literally infinite other ways, but that way is very clear
17:25:51 <ivanm> Axman6: when's dibblego going to be here?
17:26:14 <Axman6> um, next week I think
17:26:22 <frx> athan you have never used fmap with IO?
17:26:29 <Axman6> you could ask in #haskell.au to be sure though :P
17:26:42 <frx> > fmap reveres getLine
17:26:43 <lambdabot>  Not in scope: `reveres'
17:26:44 <lambdabot>  Perhaps you meant one of these:
17:26:44 <lambdabot>    `reverse' (imported from Data.List),
17:26:44 <lambdabot>    `BSC.reverse' (imported from Data.ByteString.Char8),
17:26:44 <lambdabot>    `BSLC.reverse' (imported from Data.ByteString.Lazy.Char8)
17:26:46 <ivanm> just did; keep up! :p
17:26:49 <frx> > fmap reverse getLine
17:26:50 <lambdabot>  <IO [Char]>
17:27:06 <athan> frx: Not yet! Now I will! haha
17:27:10 <mgoszcz2> Axman6: Ok thanks. I just hoped there is a cleaner way..
17:27:19 <pavonia> maxiepoo: What is wrong with MonadError?
17:27:21 <ivanm> is <$> left or right associative?
17:27:31 <ivanm> if it's right associative, you could remove another map from mgoszcz2's code
17:27:50 <kristof> infix is lame
17:27:57 <ivanm> kristof: how so?
17:28:18 <kristof> ivanm: "is <$> left or right associative?" I don't like having to remember weird rules
17:28:28 <colDrMcBeardman> kristof, RPN FTW.
17:28:36 <ivanm> kristof: fair enough, though usually it doesn't matter
17:28:37 <kristof> What is this, Forth?
17:28:43 <colDrMcBeardman> someone needs to make HaForth
17:28:51 <erisco> :t words
17:28:52 <lambdabot> String -> [String]
17:28:57 <kristof> colDrMcBeardman: Haskell doesn't properly support varargs, can't happen
17:29:03 <colDrMcBeardman> :(
17:29:12 <colDrMcBeardman> i love forth.
17:29:19 <kristof> Do you? That's weird.
17:29:37 <colDrMcBeardman> i would never seriously use it. but it's kinda cool
17:29:54 <kristof> Why is it cool if you can't use it?
17:29:59 <ivanm> bah, I was getting confused; it'd be too much of a pain to use another <$> there
17:30:03 <bitemyapp> kristof: varargs are just a fold and a list away...
17:30:19 <mgoszcz2> kristof: I presume infixl is left associative.
17:30:27 <kristof> bitemyapp: you weren't in #clojure, so I thought you weren't online
17:30:38 <colDrMcBeardman> kristof, i used it for a programming class and it was kinda fun and different and oddly fast and small, but i wouldn't want to use it every day.
17:30:47 <bitemyapp> kristof: I'm always online.
17:31:01 <bitemyapp> kristof: I'm just not in #clojure anymore.
17:31:17 <kristof> bitemyapp: Yeah, technomancy mentioned that. What happened?
17:32:00 <Cale> @let start k = k ()
17:32:01 <lambdabot>  Defined.
17:32:07 <Cale> @let end (x,_) = x
17:32:08 <lambdabot>  Defined.
17:32:14 <maxiepoo> pavonia, the Left of my Either type doesn't fit the Error class
17:32:20 <Cale> @let push x s k = k (x,s)
17:32:20 <lambdabot>  Defined.
17:32:30 <Cale> @let pop (_,s) k = k s
17:32:31 <lambdabot>  Defined.
17:32:49 <Cale> @let app (f,(x,s)) k = k (f x, s)
17:32:49 <lambdabot>  Defined.
17:33:18 * ivanm is intrigued by what Cale is doing
17:35:13 <Cale> @let ad (x,(y,s)) k = k (x + y, s)
17:35:14 <lambdabot>  Defined.
17:35:16 <Cale> oops
17:35:19 <ReinH> hah
17:35:21 <Cale> meant for that to be add
17:35:25 <Cale> @let add (x,(y,s)) k = k (x + y, s)
17:35:26 <lambdabot>  Defined.
17:35:32 <ReinH> well unlet it then :p
17:35:37 <Cale> > start push 1 push 2 add end
17:35:38 <lambdabot>  Could not deduce (GHC.Num.Num (((), t2), t20))
17:35:39 <lambdabot>    arising from the ambiguity check for `e_112'
17:35:39 <lambdabot>  from the context (GHC.Num.Num t2,
17:35:39 <lambdabot>                    GHC.Num.Num (((), t2), t1),
17:35:39 <lambdabot>                    GHC.Num.Num ((), t2))
17:35:42 <Cale> lol
17:36:09 <ivanm> heh
17:36:17 <Cale> hmmm :)
17:36:24 <ivanm> did you need to use app in that?
17:36:50 <ivanm> add = app . app . push (+) ? :p
17:36:51 <Cale> Well, I was going to use app, but figured I'd do something simpler
17:37:26 <Cale> :t push
17:37:27 <lambdabot> t1 -> t2 -> ((t1, t2) -> t) -> t
17:37:34 <Cale> :t add
17:37:35 <lambdabot> Num t1 => (t1, (t1, t2)) -> ((t1, t2) -> t) -> t
17:37:40 <Aetherspawn> heh
17:37:48 <Cale> hmmm :)
17:37:49 <Aetherspawn> thats really clever usage of saturation
17:37:51 <Cale> :t start
17:37:52 <lambdabot> (() -> t) -> t
17:38:00 <Cale> :t end
17:38:01 <lambdabot> (t, t1) -> t
17:38:33 <Cale> > start (push 1) (push 2) add end
17:38:35 <lambdabot>  3
17:38:48 <Cale> I recall there's a way to not need those parens
17:38:58 <Cale> But this isn't it :)
17:39:46 * mgoszcz2 is confused about what Cale did.
17:40:02 <Cale> @let swap (x,(y,s)) k = k (y,(x,s))
17:40:03 <lambdabot>  Defined.
17:40:09 <colDrMcBeardman> trying to make 4th in hs.
17:40:28 <Cale> > start (push 1) (push (+)) L.app (push 2) swap L.app end
17:40:29 <lambdabot>  Ambiguous occurrence `swap'
17:40:29 <lambdabot>  It could refer to either `L.swap', defined at L.hs:152:1
17:40:29 <lambdabot>                        or `Data.Tuple.swap',
17:40:29 <lambdabot>                           imported from `Data.Tuple' at L.hs:106:1-17
17:40:33 <Cale> > start (push 1) (push (+)) L.app (push 2) L.swap L.app end
17:40:35 <lambdabot>  3
17:40:59 <mgoszcz2> Oh. So it's like a stack..
17:41:01 <Cale> It can be done, sort of
17:41:08 <Cale> It's just you'll get *horrible* type errors
17:41:24 <colDrMcBeardman> mgoszcz2, yes, 4th uses stacks, and you push operands and operators off the stack and pop to eval
17:41:27 <colDrMcBeardman> it's kinda neat.
17:41:37 <colDrMcBeardman> it's also weirdly fast
17:41:48 <JeroldHaas> Cale: is this Calem?
17:41:54 <Cale> JeroldHaas: ?
17:42:07 <JeroldHaas> nvm :D
17:45:44 <Cale> http://lpaste.net/99230
17:45:47 <Cale> @undefine
17:45:47 <lambdabot> Undefined.
17:57:37 <tac> how do you edit the default language exts for GHCI?
17:57:50 <ivanm> tac: you can have a ~/.ghci file with options
17:58:12 <tac> thanks
17:58:15 <ivanm> e.g. ":set -XOverloadedStrings"
17:58:27 <ivanm> make sure you set the file permissions so that no-one else can write to it
17:58:31 <ivanm> or ghci will complain
17:58:43 <ivanm> .ghci can either be in $HOME or the root directory of a project
18:01:31 <Benzi-Junior> How do I get the contents of an IO (x :: IO (Either a b))
18:02:04 <ivanm> Benzi-Junior: within an IO block, you can do "x <- myIoEitherValue"
18:02:07 <ivanm> or use >>= explicitly
18:02:09 <ivanm> @type (>>=)
18:02:10 <lambdabot> Monad m => m a -> (a -> m b) -> m b
18:02:31 <Benzi-Junior> ivanm: ofc how silly of me
18:03:24 <Iceland_jack> @ty join
18:03:24 <lambdabot> Monad m => m (m a) -> m a
18:03:33 <Iceland_jack> @ty join :: IO (IO a) -> IO a
18:03:34 <lambdabot> IO (IO a) -> IO a
18:13:06 <tac> In aeson lens, how do you automatically make instances for your type?
18:17:23 <tp43_> what the preferred db?
18:17:43 <Axman6> whatever your prefered db is
18:17:54 <tp43_> hmmm, couchdb?
18:18:02 <Axman6> sure, if there's bindings
18:19:29 <mgoszcz2> Is Colem still here?
18:19:37 <tp43_> aha bindings...mostly targeting sql I notice
18:19:47 <tp43_> takusen
18:23:34 <mgoszcz2> Cale: http://lpaste.net/99232
18:24:49 <novochar> How does this work? https://gist.github.com/novodinia/8701468
18:25:31 <novochar> I struggled with coming up with this function, and ended up giving in, reading the comments at the end of chapter 3 in RWH
18:25:48 <novochar> I don't know how to use comparing
18:25:51 <frx> @src comparing
18:25:51 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:25:55 <novochar> I also don't know how to use sortBy
18:25:56 <ivanm> @type comparing
18:25:56 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
18:26:03 <Iceland_jack> > comparing 'a' 'd'
18:26:04 <lambdabot>  Couldn't match expected type `GHC.Types.Char -> a0'
18:26:04 <lambdabot>              with actual type `GHC.Types.Char'
18:26:12 <Iceland_jack> oops
18:26:16 <ivanm> comparing f = compare `on` f
18:26:20 <ivanm> @src on
18:26:21 <lambdabot> (*) `on` f = \x y -> f x * f y
18:26:44 <Iceland_jack> comparing f = \x y → f x `compare` f y
18:27:22 <Iceland_jack> > (comparing abs) 5 (-5)
18:27:23 <lambdabot>  EQ
18:28:17 <Iceland_jack> novochar: You might use it somehow like this
18:28:17 <Iceland_jack> > sortBy (comparing abs) [4,-2,-3,1]
18:28:18 <lambdabot>  [1,-2,-3,4]
18:28:20 <novochar> Are there other functions that you can compare a list with?
18:28:33 <novochar> abs, okay
18:28:36 <Iceland_jack> What do you mean by that novochar?
18:31:08 <frx> novochar you can compare by any function that takes an element from your list and returns an Ord
18:32:58 <novochar> > sortBy (comparing abs) $ sortBy (comparing sin) [1,2,3,4,5]
18:32:59 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
18:33:04 <novochar> Is there a better way of doing this?
18:33:17 <ReinH> novochar: define "better"
18:33:40 <Iceland_jack> novochar: Do you mean for two arbitrary comparison functions?
18:34:06 <Iceland_jack> or for abs and sin
18:34:25 <novochar> Iceland_jack: I was asking if there were other functions I could feed comparing with to compare lists with, e.g., in the original paste, I used `length`. `abs` seems to be something you would use to sort a list of numbers, not necessarily a list of lists
18:34:46 <levi> There's a monoid instance for Monoid.
18:34:53 <Axman6> Ord*
18:34:55 <ReinH> Iceland_jack: well, that sorts by sin and then throws that away and sorts by abs :)
18:34:58 <levi> Er.. Ordering.
18:35:07 <Axman6> yeah, that one
18:35:09 <Axman6> =)
18:36:36 <Iceland_jack> ReinH: Right but novochar might be interested in sorting something like the result of a stable sort, that's why I asked if they asked because of that particular example or for a more general view
18:36:46 <novochar> ReinH: defining better for you: shorter. If I chain/pipe (I don't know the appropriate terminology here) multiple expressions together, it could get long, e.g.: sortBY (comparing abs) (sortBy (comparing sin) $ sortBy (comparing cos) [1,2,3,4,5])
18:37:00 <ReinH> novochar: well, that doesn't do what you want anyway
18:37:10 <novochar> sortBy*
18:37:10 <ReinH> unless you actually want to sort by abs and throw everything else away
18:37:34 <ReinH> that's not the same as sortBy (comparing (abs . sin . cos))
18:37:42 <novochar> ReinH: It's just an example, I don't really know what I would be sorting by at this moment, I'm just trying to understand compare, comparing, sortBy, etc.
18:38:03 <ReinH> that sorts the same list three times, throwing away the first two results and providing the last result
18:38:04 <Iceland_jack> novochar: Start with understanding ‘compare’
18:38:09 <ReinH> so probably not what oyu want
18:38:13 <Iceland_jack> > compare 'a' 'c'
18:38:14 <lambdabot>  LT
18:38:16 <Iceland_jack> > compare 'c' 'c'
18:38:17 <lambdabot>  EQ
18:38:22 <Iceland_jack> > compare 'g' 'c'
18:38:22 <lambdabot>  GT
18:39:58 <ReinH> novochar: maybe you can give us a more specific example
18:40:07 <novochar> >sortBy (comparing $ abs . sin . cos) [1,2,3,4,5]
18:40:08 <ReinH> ah
18:40:14 <novochar> > sortBy (comparing $ abs . sin . cos) [1,2,3,4,5]
18:40:15 <lambdabot>  [5.0,2.0,1.0,4.0,3.0]
18:40:20 <novochar> That's neat!
18:40:32 <Iceland_jack> The definition of compare is
18:40:32 <Iceland_jack>     compare x y
18:40:32 <Iceland_jack>       | x == y    = EQ
18:40:32 <Iceland_jack>       | x <= y    = LT
18:40:35 <Iceland_jack>       | otherwise = GT
18:40:40 <Iceland_jack> btw
18:40:45 <novochar> Okay, sorry for being distracted, I'll get back to reading what you all are saying.
18:40:54 <Axman6> Iceland_jack: that's the default definition, it may be more efficient than that
18:41:13 <Iceland_jack> Axman6: Yes but I'm trying to give the general idea
18:41:26 <Axman6> ok
18:42:33 <Iceland_jack> novochar: And when you write
18:42:33 <Iceland_jack>     (comparing abs) x y
18:42:33 <Iceland_jack> it's the same as saying
18:42:33 <Iceland_jack>     compare (abs x) (abs y)
18:42:40 <ReinH> > sortBy (comparing (sin . (*pi))) [1..10] -- novochar
18:42:41 <lambdabot>  [10.0,8.0,6.0,4.0,2.0,1.0,3.0,5.0,7.0,9.0]
18:43:09 <Axman6> ReinH: that's quite an interesting result
18:43:12 <ReinH> :)
18:43:26 <Axman6> > sin (10*pi)
18:43:27 <lambdabot>  -1.2246467991473533e-15
18:43:31 <Axman6> > sin (8*pi)
18:43:32 <lambdabot>  -9.797174393178826e-16
18:44:21 <Iceland_jack> > sortBy (comparing fst) [(6,'g'),(2,'s'),(4,'i'),(1,'e'),(0,'t'),(3,'t'),(5,'n')]
18:44:22 <lambdabot>  [(0,'t'),(1,'e'),(2,'s'),(3,'t'),(4,'i'),(5,'n'),(6,'g')]
18:44:25 <ReinH> Axman6: it's not as interesting as it seems
18:44:31 <Iceland_jack> > map snd $ sortBy (comparing fst) [(6,'g'),(2,'s'),(4,'i'),(1,'e'),(0,'t'),(3,'t'),(5,'n')]
18:44:32 <lambdabot>  "testing"
18:44:33 <frx> ReinH the result of the first sort is not thrown away. if two elements are equal in the second sort order of the first sort will be retained
18:44:44 <ReinH> Axman6: or, alternatively, it's more interesting than it seems
18:44:56 <ReinH> Axman6: what you're actually witnessing is floating point jitter :)
18:44:57 <Axman6> I think the former
18:45:01 <Axman6> yeah
18:45:34 <novochar> off topic, but for later discussion: Axman6: how can you make the default definition more efficient?
18:45:43 <Iceland_jack> novochar: Depends on the type
18:45:48 <ReinH> novochar: definition of which?
18:45:51 <Iceland_jack> compare
18:45:52 <novochar> compare
18:45:54 <ReinH> ah
18:45:59 <levi> > sortBy (comparing fst) <> (comparing snd) [(6,'g'),(2,'s'),(4,'i'),(1,'e'),(0,'t'),(6,'t'),(2,'n')]
18:46:01 <lambdabot>  Couldn't match type `GHC.Types.Ordering'
18:46:01 <lambdabot>                with `[(a0, GHC.Types.Char)]'
18:46:01 <lambdabot>  Expected type: [(a0, GHC.Types.Char)] -> [(a0, GHC.Types.Char)]
18:46:01 <lambdabot>    Actual type: [(a0, GHC.Types.Char)] -> GHC.Types.OrderingCouldn't match ty...
18:46:01 <lambdabot>  Expected type: [(a0, GHC.Types.Char)] -> a1
18:46:01 <novochar> 20:38 < Axman6> Iceland_jack: that's the default definition, it may be more efficient than that
18:46:16 <ReinH> liyang: more parens?
18:46:19 <ReinH> er levi
18:46:20 <Axman6> for Int, it's a subtract and then check for 0 and the high order bit for EQ or LT
18:46:29 <levi> > sortBy ((comparing fst) <> (comparing snd)) [(6,'g'),(2,'s'),(4,'i'),(1,'e'),(0,'t'),(6,'t'),(2,'n')]
18:46:30 <lambdabot>  [(0,'t'),(1,'e'),(2,'n'),(2,'s'),(4,'i'),(6,'g'),(6,'t')]
18:46:30 <Iceland_jack> novochar: http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-prim-0.2.0.0/src/GHC-Classes.html
18:46:44 <ReinH> levi: I particularly like that monad
18:46:46 <ReinH> monoid
18:46:48 <Iceland_jack> Search for ‘instance Ord … where’
18:46:55 <Iceland_jack> and it may include a compare definition
18:46:57 <ReinH> @instances Ord
18:46:58 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:47:11 <novochar> > sortBy (comparing $ sin . (*pi)) [1..10] --ReinH
18:47:12 <lambdabot>  [10.0,8.0,6.0,4.0,2.0,1.0,3.0,5.0,7.0,9.0]
18:49:01 <novochar> I'm slowly catching up on the comments
18:49:46 <ReinH> novochar: heh
18:49:54 <ReinH> novochar: that one is actually trolling you ;)
18:50:03 <novochar> What happens when comarping has two equal values?
18:50:17 <Axman6> it returns EQ
18:50:20 <novochar> How does sortBy handle EQ?
18:50:25 <Iceland_jack> > sortBy (comparing (const EQ)) [1,3,2,4]
18:50:27 <lambdabot>  [1,3,2,4]
18:50:28 <Axman6> > comparing abs 1 1
18:50:29 <lambdabot>  EQ
18:50:48 <Axman6> novochar: it's a stable sort, so the order is unchanged
18:51:09 <novochar> What is the (<>) in levi's example?
18:51:15 <Iceland_jack> mappend
18:51:15 <Axman6> mappend
18:51:20 <Axman6> :t (<>)
18:51:21 <lambdabot> Monoid m => m -> m -> m
18:51:28 <Iceland_jack> It's not strictly necessary for what you're asking about
18:51:33 <Axman6> > [1,2,3] <> [4,5,6]
18:51:34 <lambdabot>  [1,2,3,4,5,6]
18:51:42 <Axman6> > Sum 1 <> Sum 2
18:51:43 <Iceland_jack> but if you want to learn about monoids please do :)
18:51:43 <lambdabot>  Sum {getSum = 3}
18:51:55 <Axman6> EQ <> LT
18:51:58 <Axman6> > EQ <> LT
18:51:59 <lambdabot>  LT
18:52:30 <Axman6> > show <> const "hello" $ "test"
18:52:31 <lambdabot>  "\"test\"hello"
18:52:39 <Axman6> that's a fun one
18:52:41 <ReinH> novochar: monoids are awesome
18:52:44 <novochar> Iceland_jack: regarding your link, it looks like case expressions are used, maybe this is the more efficient definition
18:53:06 <ReinH> Axman6: things like that are why I'm starting to loathe ($)
18:53:25 <Iceland_jack> novochar: It wholly depends on the type in question though
18:54:04 <Iceland_jack> you might have a primative type where you call an efficient primitive function
18:54:07 <Axman6> ReinH: why?
18:54:14 <novochar> Iceland_jack: Your example regarding how sortBy handles equal values was helpful. So sortBy doesn't change the ordering if they are equal?
18:54:25 <Axman6> > (show <> const "hello") "test" -- slightly clearer in this example
18:54:26 <lambdabot>  "\"test\"hello"
18:54:28 <Iceland_jack> No, sort (and sortBy) use *stable* sorting algorithms
18:54:29 <ReinH> Axman6: it's not "wrong", I just find it easier to see where the groupings are with (show <> const "hello") "test"
18:54:31 <novochar> Axman6 answers yes immediately after the example, so yeah
18:54:45 <Iceland_jack> Are you familiar with that concept novochar?
18:55:09 <ReinH> Axman6: like, if I'm working in a codebase that uses ($) there I'll try to follow along
18:55:15 <ReinH> but with a bit of mental friction :)
18:55:26 <Axman6> I use $ a lot
18:55:41 <ReinH> Axman6: meanwhile chrisdone basically never uses $
18:55:49 <ReinH> I'm somewhere in the middle, leaning closer to him
18:57:07 * mgsloan leans towards using one or two nested parens, and trying to use 
18:57:23 <novochar> Iceland_jack: I am not familiar with *stable* sorting algorithms, that is what you were asking, right?
18:57:24 <mgsloan> $ or . or where clauses beyond that
18:57:39 <Twey> I don't understand the aversion some people have to $
18:57:51 <Iceland_jack> The *asterisks* were just for emphasis :)
18:58:17 <Iceland_jack> basically a sorting algorithm keeps items with the same key in order
18:58:42 <Twey> If you prefer the simplicity of prefix and don't want to think about precedences, fine, don't mix operators ever; but if you ever mix operators, you might as well take full advantage of them to save you many levels of nesting
18:59:34 <Iceland_jack> novochar: So for
18:59:34 <Iceland_jack> > sortBy (comparing abs) [4, -4]
18:59:34 <Iceland_jack>  
18:59:35 <lambdabot>  [4,-4]
18:59:45 <Iceland_jack> an unstable algorithm might produce [-4, 4]
19:00:16 <mgsloan> my theory is that it depends on how much lisp you've trained your eyes on
19:01:19 <Twey> mgsloan: Nobody actually writes Lisp-style, ((+) foo ((+) bar baz))
19:01:22 <novochar> Neat, thanks Iceland_jack!
19:01:22 <ReinH> Twey: it's not because I don't understand fixity
19:01:42 <ReinH> Twey: but I tend prefer () for separating expressions to $
19:01:47 <Twey> I'd understand people who did avoiding $
19:01:48 <Iceland_jack> Twey: No I write
19:01:49 <Iceland_jack>     (sum foo bar bz)
19:01:49 <Iceland_jack> ;)
19:02:03 <novochar> It's amazing how nice everyone has been to me here, thank you #haskell!
19:02:09 <jle`> i've started to slowly phase out $
19:02:13 <Iceland_jack> You're welcome novochar
19:02:19 <ReinH> for instance I prefer when (p x) (act x) to when $ px $ act x
19:02:38 <mgsloan> yeah, i definitely used to be much heavier in the (.) and ($)
19:02:39 <ReinH> novochar: welcome to Haskell :)
19:02:40 <jle`> when (p x) . act $ x
19:02:47 <Iceland_jack> ($) is almost indispensable when working with something like
19:02:47 <Iceland_jack>     bigBlock $ \x → do
19:02:47 <Iceland_jack>         undefined
19:02:49 <Twey> But given that people always use operators anyway, I don't understand why they hate $ in particular, especially when it can easily save you keeping track of 10+ levels of nesting (and makes the associativity of function composition more obvious)
19:03:09 <ReinH> jle`: well, I mean, in that case it's also when <$> p <*> act $ x
19:03:11 <ReinH> but that's not my point
19:03:14 <jle`> :P
19:03:34 <jle`> i use $ for $ \x -> do
19:03:36 <ReinH> I like grouping things that ought to be grouped with parents
19:03:47 <ReinH> jle`: yes that's about the only place I use it now, i.e. where syntax forces me to
19:03:52 <Twey> ReinH: when $ px $ act x is evil because the fixity of ($) is backwards and I'm still hoping for the day it will be fixed :þh
19:03:54 <jle`> i've started using less frivilous uses of $
19:03:56 <Twey> s/h$//
19:04:06 <Iceland_jack> I would like Haskell to have nicer syntax for that though :)
19:04:17 <ReinH> Twey: I find my style has tended more and more towards Bird's style
19:04:26 <ReinH> which I find to be incredibly elegant and expressive
19:04:40 <jle`> Bird's style?
19:04:45 <ReinH> Richard Bird
19:05:01 <Twey> Oh
19:05:08 <jle`> is this bird style qualified in any way?
19:05:17 <Twey> ReinH: But, er, when $ p x $ act x is when (p x (act x)), not when (p x) (act x)
19:05:17 <ReinH> well, I can provide exemplars
19:05:25 <Twey> Hence the evil
19:05:30 <ReinH> Twey: ok, so maybe I don't use $ because I don't understand precedence
19:05:31 <ReinH> :p
19:05:34 <Twey> Haha
19:05:41 <mgsloan> is that where you only use the combinator birds? ( http://www.angelfire.com/tx4/cus/combinator/birds.html )  :D
19:05:41 <jle`> i mostly use ($) when there is a meaningful mental barrier
19:05:57 <jle`> return $ f x (g )
19:05:59 <ReinH> Twey: but in general I prefer (f . g . h) x to f . g . h $ x, I think that's the best example
19:06:02 <jle`> er, (g y)
19:06:10 <ReinH> no precedence issues, I just prefer the style
19:06:35 <ReinH> Twey: partially because it makes it more obvious to me where I can extract a function and where the points are, etc
19:06:45 <ReinH> partially because I have better editor support for working with blocks of ()
19:06:50 * ReinH shrugs
19:07:07 <jle`> whenever i see the $ i kind of automatically visualize butterfly wings of parentheses stretching out over it though
19:07:22 <jle`> kind of like in the matrix
19:07:28 <jle`> where the guy doesn't see the code but sees the things.
19:07:30 <jle`> yes that is me.
19:07:32 <ReinH> jle`: Bird is the author of _Introduction to FP using Haskell_ and _Pearls of Functional Algorithm Design_
19:07:57 <jle`> the $ is like the spine of a butterfly
19:08:02 <jle`> ReinH: ah ty
19:08:03 <ReinH> but if you want an exemplar of Bird style it might be http://www.cs.nott.ac.uk/~gmh/sudoku.lhs
19:08:14 <ReinH> his pearls book is fucking fantastic btw
19:08:17 <Twey> ReinH: You can extract the things on the left of the $ :þ  And beware of fitting your language use to your editor rather than the other way around
19:08:50 <ReinH> Twey: I am not disgreeing with you
19:09:05 <ReinH> it's a personal preference, not some gospel
19:09:26 <mgsloan> I dunno, making your editor fit your style is quite reasonable.  It just makes it hard for others to work on the code, since they don't have the same automations as you
19:09:52 <Twey> mgsloan: Did you mean ‘making your style fit your editor…’?
19:10:34 <ReinH> I just like that parens visually group related things :)
19:10:39 <mgsloan> no, i meant making your editor fit your style.  e.g. automating deep indents that line things up, letting you create and navigate parenthesis structures, etc. structured haskell mode stuff
19:11:08 <ReinH> I still want structured haskell mode for vim
19:11:19 <ReinH> the haskell tooling for vim is decent but very fragmented, all over the map, of uneven quality.
19:11:22 <ReinH> :/
19:11:31 <ReinH> but I hate writing VimL with the fury of a thousand suns :(
19:11:59 <mgsloan> I often will need to edit chris's code.  and while it's not at all a big deal, i do need to spend a bit of time either reformatting it or reindenting it to what i think his style would be
19:12:10 <ReinH> mgsloan: heh
19:12:14 <ReinH> chris is a bit of a special case
19:12:54 <Twey> mgsloan: If you're making your editor fit your style, i.e. you're configuring your editor to help you code in the style you'd be coding in anyway, there's no problem and nothing to discuss :þ  If you're making your style fit your editor, that's where the problems start: you begin by using a few more deeply nested brackets because your editor likes them, and you end up with Java…
19:13:02 <mgsloan> really i just need to jump on the structured haskell mode train :)
19:13:10 <mgsloan> but that would also mean getting on the emacs train
19:13:11 <ReinH> mgsloan: I tried but I can't make emacs work for me.
19:13:14 <ReinH> yeah
19:14:29 <mgsloan> Twey: well, I actually agree with chris that his code looks better that way.  So, I guess I'm going with the scenario of you explicitly asking your editor "I want to do this heavily indented stuff"
19:14:54 <ReinH> Twey: no, with lisp :p
19:14:58 <mgsloan> I can't read the heavily parenthesized stuff, but the heavily indented stuff is lovely
19:15:05 <ReinH> Twey: we are talking about emacs here after all ;)
19:15:05 <mgsloan> till i need to edit it
19:15:26 <ReinH> I don't like lots of nested parens but I like a few groups of unnested parens a lot
19:17:01 <mgsloan> Yeah, me too.  I'm definitely preferring (foo (bar baz) (zapf ding)) to (foo (bar baz) $ zapf ding)
19:17:51 <mgsloan> Sometimes i wish there weren't so many choices, but eh, style can be an interesting thing
19:17:55 <ReinH> yep
19:18:12 <ReinH> I try to be flexible, especially when working with others' code
19:18:17 <ReinH> some things make me twitch a bit though
19:23:18 <simpson> Hey, when doing free monads for ASTs, how does one deal with heterogenous AST types?
19:23:35 <simpson> I have an Expr type, and that's the main top-level AST type, but I also have some nodes that are things like Patterns.
19:23:48 <simpson> And the Patterns are functors too, but I'm not sure how to correctly intertwine them.
19:24:56 <carter> simpson: sounds like you want hbound!
19:25:06 <carter> simpson: or some sort of GADT based AST
19:25:14 <carter> simpson: are you comfy with GADTs?
19:26:41 <simpson> carter: Meh. I'm not uncomfy with them, although I couldn't quite figure out how to GADT this particular setup.
19:26:48 <carter> ok
19:26:59 <carter> link us a lpaste / gist of your code
19:27:15 <simpson> http://lpaste.net/99235
19:27:58 <carter> huh
19:27:59 <carter> ok
19:28:46 <simpson> Yeah. It's exciting!
19:29:11 <carter> simpson: lets fix this piece wise
19:29:27 <carter> simpson: starting with Object a
19:29:28 <carter> ok?
19:29:32 <simpson> Awesome. Let's do it.
19:29:58 <carter> im gonna skip SccriptObj for now
19:30:03 <carter> because I don't know what it is yet :)
19:30:10 <jmcarthur> umm... is there actually a bug in that code? or is there something you're wanting to add that doesn't work?
19:30:20 <simpson> Well, for starters, eval doesn't have complete cases.
19:30:23 <carter> jmcarthur: he wants a strongly typed AST
19:30:39 <simpson> I want *an* AST. I hear that free monads are awesome for ASTs.
19:30:55 <jmcarthur> free monads are... alright :)
19:30:59 <carter> simpson: they let you do some cute functor tricks
19:31:06 <carter> but lets first make this a typed AST for fun :)
19:31:07 * jmcarthur looks to make sure Tekmo isn't around
19:31:11 <jmcarthur> ^_^
19:31:25 * carter high fives jmcarthur 
19:31:44 <carter> he's a smart guy
19:31:46 <jmcarthur> in case it wasn't clear, i'm not a huge fan of the free monad bandwagon
19:31:49 <carter> but he's got a favorite hmmer
19:31:54 <jmcarthur> okay it was clear :)
19:32:11 <carter> haskell is for tool kits not hammers
19:32:24 <carter> jmcarthur: so i'm gonna walk simpson  through GADTifying it first
19:32:30 <carter> then we can maybe do other fun things
19:32:36 <carter> simpson: still there?
19:32:38 <jmcarthur> is that really what simpson wanted?
19:32:41 <carter> no clue
19:32:47 <simpson> carter: Yep!
19:32:50 <carter> he wanted hetergenuous types :)
19:32:55 <carter> which I think means "typed asts"
19:33:06 <carter> which makes me think "time for our GADTs"
19:33:09 <simpson> jmcarthur: I've written this about a half-dozen times in three (four?) different languages and gotten about halfway each time. :3
19:33:12 <jmcarthur> it wasn't clear to me whether that meant a typed AST or just an AST made up of multiple ADTs
19:33:37 <jmcarthur> typed ASTs are fun
19:33:45 <jmcarthur> bounds is also fun
19:33:50 <carter> yes
19:33:50 <jmcarthur> hbound is unfortunately less fun :(
19:33:53 <carter> yeah
19:34:01 <jmcarthur> s/bounds/bound/
19:34:02 <carter> any way to fix hmbound?
19:34:04 <newsham> someone should write a hacker-challenge game where each level you have to break the security of a different haskell program.
19:34:13 <carter> newsham: unsafeCoerce
19:34:14 <carter> DONE
19:34:28 <newsham> carter: you dont write the program.
19:34:33 <jmcarthur> carter: hmbound?
19:34:37 <carter> hbound
19:34:38 <simpson> By "bound" are you talking about the delights of renaming bound variables inside enclosed scopes?
19:34:39 <carter> butter fingures
19:34:48 <carter> @hackage bound is amazing
19:34:49 <lambdabot> http://hackage.haskell.org/package/bound is amazing
19:34:49 <simpson> This particular language doesn't have that.
19:34:50 <jmcarthur> simpson: bound is a nice package for working with binders
19:34:54 <newsham> something like https://microcorruption.com/ but with haskell instead of asm
19:35:08 <carter> simpson: i think theres some examples of using boudn for a lang with pattern matching
19:35:11 <carter> lets look!
19:35:13 <jmcarthur> i wouldn't go so far as to call it "amazing," but it is certainly useful
19:35:34 <carter> its nice
19:35:47 <Twey> Pattern-matching should be sugar for eliminators.  >:(
19:35:50 <carter> simpson: https://github.com/ekmett/bound/blob/master/examples/Overkill.hs#L43 :)
19:36:25 <carter> i wonder how pattern matching is modeled in edwardk's ermine
19:36:27 <carter> lets go look
19:37:22 <carter> woah ermine is slick
19:37:50 <simpson> So, if we're starting with Object, I think we have data Object = IntObj Integer | Obj (M.Map Name Object) [Script] Matcher
19:37:55 <carter> ok
19:38:19 <simpson> Where the Obj has a closure frame, a bunch of Scripts (methods) and a Matcher for cleaning up unmatched messages.
19:38:27 <carter> is this a dynamicly typed lang?
19:39:00 <simpson> In type theory, as I understand, it's "unityped". Not totally sure, though. There's no way to talk about types from within the language.
19:39:11 <carter> hrmmm
19:39:31 <carter> ok, so it  doesn't even make senes to do the GADT then
19:40:00 <simpson> Why? There's type information available to us, just not to the runtime.
19:40:09 <carter> well
19:40:14 <carter> same is true in haskell
19:40:15 <jle`> proc blocks inside proc ec blocks
19:40:20 <jle`> *proc rec
19:40:27 <jle`> this is fun but it feels very hacky
19:40:55 <jmcarthur> simpson: the language you are *implementing* is dynamically typed, or are you *targetting* a language that's dynamically typed?
19:41:13 <simpson> jmcarthur: The former. I'm not targetting anything; I want to evaluate it in Haskell.
19:41:13 <carter> yeah, thats what we need to know!
19:41:18 <S11001001> that edwardk has a "bound" package is very amusing, as he also has "free" which is unrelated
19:41:19 <jmcarthur> ah
19:41:30 <jmcarthur> okay, then a typed AST makes less sense here
19:41:37 <edwardk> S11001001: hah!
19:41:40 <jmcarthur> S11001001: it'
19:41:43 <jmcarthur> oops
19:41:44 <edwardk> hadn't connected those =)
19:41:46 <jmcarthur> it's somewhat related, actually
19:41:53 <jmcarthur> only in that they can be useful together
19:41:55 <simpson> Everything's of type Object. Some of Object's constructors are typed based on information from the source, like literal ints and strings.
19:42:15 <simpson> And some types can propagate, but that's all higher up in the compiler. At the end of the day, I have an AST, and I want to evaluate it.
19:42:22 <joelteon> "The package 'hoauth2' requires Cabal library version 1.18.1.3 but no suitable version is installed."
19:42:27 <joelteon> wtf, Cabal-1.18.1.3 doesn't exist
19:42:32 <carter> joelteon: computerssssss
19:42:37 <carter> also oauth2 scares me
19:42:39 <carter> sooo complex
19:42:56 <joelteon> i don't care how complex it is, I'd like to be able to install it
19:42:58 <carter> joelteon: i've started getting sleep again!
19:43:04 <carter> joelteon: cabal get
19:43:07 <carter> then edit the .cabal
19:43:16 <jmcarthur> simpson: the point is... why abandon that after type checking? why not have the host language (haskell) retain that type safety in the implementation as well?
19:43:55 <simpson> jmcarthur: This isn't a language that I invented. This is a slightly customized formalization of E's desugared AST.
19:43:55 <jmcarthur> simpson: it sounds like you are thinking of the AST you've shown us as an untyped target language for some other typed AST you have not shown us? is that how you are thinking of it?
19:44:08 <jmcarthur> ah
19:44:28 <simpson> https://github.com/MostAwesomeDude/secret/blob/master/colonel.capn
19:44:36 <simpson> This is the AST's description and typing.
19:44:59 <carter> woah, i've not seen a capn protocol file before
19:45:00 <carter> neat
19:45:11 <levi> simpson: Is this E as in erights.org?
19:45:12 <simpson> Yeah. It's slightly nicer than protobufs. I like it.
19:45:14 <simpson> levi: Yes.
19:45:26 <joelteon> carter: the .cabal specifies Cabal >= 1.8
19:45:34 <levi> Ah cool. I always thought it was an interesting language.
19:45:35 <carter> joelteon: did you try installing in a fresh sandbox?
19:46:05 <carter> joelteon: OR, if you installed in a sandbxo, do you have cabal 1.18 installed globally or in user?
19:46:10 <simpson> I'm just not sure what the right way to construct ASTs is, and I can't figure out whether free monads are useful for these heterogenously-typed interweavings of Patterns and Exprs.
19:46:16 <joelteon> carter: oh, it fixed itself
19:46:20 <joelteon> yay :u
19:46:24 <carter> :u?
19:46:30 <joelteon> :U
19:46:38 <carter> whats that mean?
19:46:50 <joelteon> it's a face
19:47:04 <carter> what kind?
19:47:20 <jmcarthur> how does one shape one's mouth that way?
19:47:32 <carter> looks like a dog
19:47:32 <geekosaur> mouth wide open
19:47:48 <carter> :O
19:47:50 <jmcarthur> oh! back of head on bottom
19:47:54 <simpson> http://v.cdn.cad-comic.com/comics/cad-20090302-fb219.jpg
19:48:08 <joelteon> ¨< - "yay"
19:48:12 <carter> :)
19:48:14 <simpson> Oh, sorry for the language; was just the first result on GIS.
19:48:27 <carter> GIS?
19:48:34 <simpson> Google Image Search.
19:49:20 <carter> GIS == geo information systesms
19:49:21 <carter> :)
19:49:59 <carter> ok
19:50:03 <carter> i need to go off webs
19:50:05 <carter> ttyl all
20:09:34 <athan> Is there a taxonomy for the different kinds of reductions that a Haskell compiler/programmer can employ?
20:17:08 <S11001001> eta, or "the awesome one"
20:19:02 <flebron> What's an idiomatic way to, given a string s, change the character at position i of s from x to y?
20:19:28 <flebron> (And by change I mean return a new string such that blah blah...)
20:21:33 <Twey> flebron: Lenses: someList & ix i .~ y
20:21:50 <flebron> What type will that reutnr?
20:21:53 <flebron> ... return.
20:21:58 <jle`> mm_freak: have you seen ocharles's Asteroids netwire iplementation? https://github.com/ocharles/netwire-classics/blob/master/asteroids/Asteroids.hs#L243-L295 --- does his main game wire follow the semantics of FRP that you were talking about earler, and is it safe to use it as an inspiratino of sorts?
20:22:05 <Twey> flebron: The list
20:22:12 <flebron> Thanks :)
20:23:01 <Twey> > "abcdef" & ix 2 .~ 'g'
20:23:03 <lambdabot>  "abgdef"
20:24:53 <Twey> flebron: (& is just backwards function application, x & f = f x)
20:25:17 <Twey> (the function that does it is ix i .~ y)
20:25:56 <joelteon> (ix 2 .~ 'g') "abcdef" might be a better way to write it
20:27:58 * hackagebot pattern-arrows 0.0.1 - Arrows for Pretty Printing  http://hackage.haskell.org/package/pattern-arrows-0.0.1 (PhilFreeman)
20:28:35 <silasm> is there a program that views haddock output (like the equivalent of man/info?), or is it primarily just an internet thing?
20:30:30 <ReinH> > set (ix 2) 'g' "abcd" -- if you aren't into the whole operators thing
20:30:32 <lambdabot>  "abgd"
20:31:36 <L8D> Does haskell have anything like the Go playground?
20:32:08 <ReinH> L8D: http://tryhaskell.org/ ?
20:32:36 <ReinH> I mean there's also a web IDE
20:32:41 <L8D> where?
20:32:51 <L8D> I want to do a Haskell by Example site
20:33:00 <L8D> similar to https://gobyexample.com
20:33:15 <ReinH> fpcomplete has a bunch of tutorials and an ide
20:34:59 <L8D> I want to be able to post code snippets somewhere, and have them run
20:35:17 <Twey> ideone.com?
20:37:02 <jle`> fpcomplete does that too
20:37:05 <L8D> it doesn't have good support for using the file system or stdin very much...
20:37:18 <L8D> jle`: fpcomplete lets you post executable snippets?
20:37:27 <L8D> Twey: Also, ideone runs the code only one
20:37:29 <L8D> once*
20:37:35 <jle`> it lets you type in snippets and execute them? is that what you mean
20:37:54 <jle`> or do you mean post snippets for other people to run
20:38:00 * hackagebot purescript 0.3.5 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.5 (PhilFreeman)
20:38:02 <L8D> post snippets for other people to run
20:38:18 <jle`> well...you can share files that people can open on FPComplete...not sure if they offer an embedded api
20:38:26 <L8D> see: https://gobyexample.com/reading-files
20:38:41 <L8D> click the little thing in the top-right corner of the code
20:40:45 <jle`> http://ideone.com/3xTRw9
20:40:52 <jle`> if you click edit
20:41:04 <jle`> you can type and click "ideone it!" to run it there
20:41:33 <L8D> jle`: only you can see the edit button
20:41:40 <jle`> aw :(
20:41:48 <L8D> sorry
20:41:53 <L8D> but you're delusional
20:41:54 <L8D> jk
20:41:58 <jle`> is there any way to fork it?
20:42:04 <L8D> um...
20:42:11 <L8D> oh yeah, I can fork it
20:42:13 <jle`> oh yeah you can
20:42:17 <jle`> it's an extra click i guess
20:43:38 <L8D> http://ideone.com/n8SAX7
20:44:39 <jle`> i'm surprised that that compiled
20:45:24 <jle`> but this is neat, i wonder if they have an auto publish api
20:45:46 <L8D> Why are you suprised that it compiled?
20:46:49 <jle`> because i thought main had to have type :: IO ()
20:46:59 <L8D> It's mapM not map
20:47:01 <L8D> :t mapM
20:47:02 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
20:47:05 <jle`> yeah
20:47:11 <L8D> IO [()]
20:47:16 <jle`> yeah
20:47:18 <L8D> oh
20:47:38 <L8D> I'm pretty sure haskell doesn't care about the type of main
20:47:39 <jle`> ikr
20:47:41 <jle`> hm
20:47:48 <joseph07> :q
20:48:00 <Twey> Yeah, main ∷ IO a is fine, the return value is silently ignored
20:48:28 <L8D> silently...or blatently?!
20:48:33 <L8D> nvm
20:48:35 <L8D> inside joke
20:48:39 <Axman6> reluctantly
20:48:55 <L8D> > return ()
20:48:56 <lambdabot>  No instance for (GHC.Show.Show (m0 ()))
20:48:56 <lambdabot>    arising from a use of `M727164875983583932023075.show_M7271648759835839320...
20:48:56 <lambdabot>  The type variable `m0' is ambiguous
20:48:56 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
20:48:56 <lambdabot>  Note: there are several potential instances:
20:49:06 <Twey> « … main is performed, and its result (of type τ) is discarded »
20:49:07 <L8D> mother
20:49:08 <L8D> fucker
20:49:13 <Twey> — 2010 Report
20:49:36 <jle`> hm
20:49:37 <L8D> What if it was IO CInt ?
20:49:46 <Twey> I'm always surprised that we don't get defaulting to Maybe or something
20:49:49 <Twey> L8D: Ignored
20:49:52 <L8D> How does one return a status code in Haskell?
20:50:04 <Qett> exitWith
20:50:06 <Twey> There's a function in System.IO or somewhere
20:50:19 <jle`> if i runghc a main :: IO a...it'll print out the result
20:50:24 <jle`> but if i compile it, it doesn't print anything
20:50:45 <Twey> System.Exit.exitWith, that's it
20:50:57 <jle`> hm
20:50:59 <Twey> jle`: That sounds like a bug
20:51:02 <jle`> if i run a main :: IO a
20:51:04 <L8D> There's an entire module for exiting?
20:51:05 <jle`> but a is not Show
20:51:05 <L8D> nice.
20:51:11 <jle`> then it doesn't print anything
20:51:33 <jle`> try it -- runghc a file that's just "main = return True" or something
20:51:42 <L8D> how much of ghc is not written in Haskell?
20:52:04 <jle`> hm.
20:52:06 <Twey> jle`: Yeah, I tried it; I think it's non-standard behaviour, i.e. a bug
20:52:21 <jle`> i get different behavior for different non-showables
20:52:39 <Twey> Oh?
20:52:41 <jle`> main = return print gives a type error because there is no show instance for print
20:52:58 <jle`> but data Unshowable = UnShowable; main = return Unshowable
20:53:01 <jle`> doesn't print anything
20:53:14 <jle`> *Unshowable
20:53:28 <jle`> c'mon ghc get your act together
20:53:46 <jle`> oh...if i compile main = print, i get a type error.
20:53:59 <jle`> oh wait, that's not because it can't print print
20:54:04 <jle`> it's because print doesn't have a concrete type.
20:54:16 <Twey> Heh
20:54:34 <L8D> :t print
20:54:34 <jle`> yeah nvm
20:54:34 <lambdabot> Show a => a -> IO ()
20:54:45 <jle`> if i do (\x -> x + (5 :: Int))
20:54:46 <L8D> @src print
20:54:46 <lambdabot> print x = putStrLn (show x)
20:54:47 <jle`> it prints out nothing
20:54:57 <flebron> Is there a better way to say f <$> (sequence x)?
20:55:05 <L8D> print = putStrLn . show
20:55:06 <L8D> geez
20:55:34 <Twey> flebron: Well, you don't need the brackets ;)
20:55:41 <flebron> Ok :p
20:55:59 <jle`> do { xs <- sequence x; return (f xs) }
20:56:02 <Twey> But no, I don't think so apart from that
20:56:12 <Twey> jle`: They said ‘better’ :þ
20:56:20 <jle`> :P
20:56:39 <Qett> flebron: i think u can use mapm
20:56:46 <L8D> sequence x >>= f
20:56:50 <Twey> flebron: Depending on f, you might be able to mapM f x, but that performs more computation
20:57:03 <Twey> L8D: sequence x >>= return . f
20:57:04 <jle`> i think his f is [a] -> [a]
20:57:05 <L8D> :t sequence
20:57:05 <lambdabot> Monad m => [m a] -> m [a]
20:57:06 <Axman6> L8D: that's not the same
20:57:08 <Twey> Which is also not better :þ
20:57:31 <jle`> so mapM f wouldn't really work in general
20:57:34 <jle`> unless f is a map of some sort
20:57:44 <Twey> Right
20:57:46 <flebron> My f is [a] -> a, specifically (it's ByteString.concat)
20:57:52 <L8D> fmap f . sequence
20:57:57 <flebron> Yeah :p
20:58:14 <jle`> maybe foldM?
20:58:20 <Axman6> that's exactly what f <$> sequence x is ;)
20:58:28 <Axman6> :t foldM
20:58:29 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
20:58:33 <codygman> Trying to install yesod in a cabal sandbox and get this error, not sure what to do next: http://lpaste.net/99237
20:58:36 <L8D> fmap f . sequence $ x
20:58:52 <jle`> pure f <*> sequence x
20:58:54 <jle`> of course.
20:59:28 <L8D> flebron: where are you writing this? a function definition?
20:59:48 <flebron> L8D: Yep.
21:00:03 <L8D> fn f x = f <$> sequence x
21:00:04 <L8D> ?
21:00:26 <defanor_> i've installed acid-state via cabal, and it required newer bytestring version, but now it conflicts with other packages (they require the older version, so i can't remove it). here is the error output - http://lpaste.net/7959323390244814848, how could it be fixed?
21:00:35 <Twey> fn = flip (.) sequence . fmap
21:00:39 <Twey> … but don't :þ
21:00:51 <jle`> @pl \f x -> f <$> sequence x
21:00:51 <lambdabot> (. sequence) . (<$>)
21:01:04 <jle`> flipping an operator
21:01:05 <L8D> fn f = fmap f . sequence
21:01:11 <jle`> i have been yelled at by hlint enough times
21:01:15 <flebron> L8D: f is fixed, and x is in a 'where' clause.
21:01:29 <flebron> But no biggie, it's not ugly as it is.
21:01:41 <L8D> f <$> sequence x isn't bad at all
21:01:46 <Twey> jle`: flip fmap sequence `fmap` fmap
21:01:52 <Twey> jle`: Better?
21:01:54 <L8D> unless there is some other way of generating x
21:02:08 <Axman6> :t fmap `fmap` fmap
21:02:09 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:02:19 <jle`> (`fmap` fmap) (flip fmap sequence)
21:02:22 <jle`> ...does that work
21:02:22 <Axman6> :t fmap `fmap` fmap fmap
21:02:23 <lambdabot> (Functor f, Functor f1) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
21:02:26 <codygman> I don't understand why cabal is saying "try reinstalling offending packages" when I have a freshly created sandbox.
21:02:30 <Twey> flebron: You should write f <$> sequence x; none of these are serious suggestions.  :þ
21:02:30 <Axman6> :t fmap `fmap` fmap fmap fmap
21:02:31 <lambdabot> (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
21:02:38 <L8D> @spl fmap fmap fmap
21:02:38 <lambdabot> fmap fmap fmap
21:02:39 <jle`> :t flip fmap sequence `fmap` fmap
21:02:40 <Twey> jle`: Yes
21:02:40 <lambdabot> (Monad m, Functor m) => ([a] -> b) -> [m a] -> m b
21:03:01 <Clint> is there a generic parser type outside of incremental-parser?
21:03:02 <jle`> :t (`fmap` fmap) (flip fmap sequence)
21:03:02 <lambdabot> (Monad f, Functor f) => ([a] -> b) -> [f a] -> f b
21:03:19 <L8D> @pl f :: a -> b; x :: Monad m => m a; f <$> sequence x
21:03:19 <lambdabot> (line 1, column 10):
21:03:19 <lambdabot> unexpected '>'
21:03:19 <lambdabot> expecting operator
21:03:22 <jle`> how weird
21:03:24 <ski> simpson : i assume your `a's are to be thought of as `this'/`self' ?
21:03:37 <carter> codygman: your problem is yesod
21:03:52 <Kaidelong> I see you guys have discovered semantic combinators
21:03:59 <Kaidelong> or was it editors?
21:04:01 <Kaidelong> semantic editors
21:04:07 <codygman> carter: Oh, it's not compatible with cabal sandboxes?
21:04:07 <Twey> Kaidelong: Semantic editor combinators, actually
21:04:10 <ski> @where SEC
21:04:10 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
21:04:18 <L8D> :t fmap
21:04:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:04:44 <carter> codygman: no, its got such insanely complex and fragile build deps
21:04:51 <carter> use snap or happstack
21:05:00 <L8D> :t (fmap :: (a -> b) -> Maybe a -> Maybe b) fmap fmap
21:05:01 <lambdabot>     Couldn't match expected type `Maybe (a0 -> b0)'
21:05:01 <lambdabot>                 with actual type `(a1 -> b1) -> f1 a1 -> f1 b1'
21:05:01 <lambdabot>     In the second argument of `fmap ::
21:05:22 <carter> codygman: basically whenever someon gets build hell these days, i can guess "are you trying to install yesod"
21:05:25 <carter> and i'm usually right :(
21:05:35 <L8D> yesod or snap?
21:05:42 <carter> ?
21:05:47 <L8D> I want the smaller, simpler one
21:05:54 <ski> @type fmap `asTypeIn` \f -> f fmap fmap
21:05:55 <lambdabot> (Functor f, Functor f1) => ((f1 a -> f1 b) -> f (f1 a) -> f (f1 b)) -> ((a -> b) -> f1 a -> f1 b) -> (a -> b) -> f (f1 a) -> f (f1 b)
21:05:55 <carter> snapp i ssimpler
21:06:01 <Platz> what about scotty.. too simple ?
21:06:02 <carter> as is happstack
21:06:03 <carter> yes
21:06:05 <carter> thats nice too
21:06:12 <carter> i know folks who are happy with it
21:06:13 <L8D> Platz: correct!
21:06:16 <ski> @type fmap `asTypeIn` \f -> fmap f fmap
21:06:16 <lambdabot> (Functor f, Functor f1) => (f1 a -> f1 b) -> f (f1 a) -> f (f1 b)
21:06:21 <ski> @type fmap `asTypeIn` \f -> fmap fmap f
21:06:21 <lambdabot>     Could not deduce (Functor f0) arising from a use of `fmap'
21:06:22 <lambdabot>     from the context (Functor f)
21:06:22 <lambdabot>       bound by the inferred type of
21:06:22 <simpson> ski: No, there's no this/self reference to the current frame. The `a` was just supposed to be the placeholder for the free monad.
21:06:55 <codygman> I'm making a website that's basically a wrapper to ffmpeg, any thoughts on which would offer more of an advantage there? I think I may end up needing to use the upload extension in nginx for speed anyway though.
21:07:00 <codygman> Since videos will be uploaded
21:07:03 <L8D> what happened to github?
21:07:33 <carter> codygman: snap has a very very cool 1.0 pending
21:07:52 <ski> simpson : well, i meant that you'd otherwise say `data Expr = Assign Expr Expr | BindingExpr Expr | Call Expr String [Expr] | ...', and then use this `Expr' instead
21:07:56 <carter> codygman: where i may seriously build some really crazy perf heavy web  servery things using it
21:08:14 <carter> codygman: all the libs are great
21:08:19 <codygman> carter: Yeah? Can you expand on that? I know an advantage happstack has is maturity and has been around a while.
21:08:33 <simpson> ski: That's what I'm currently experimenting with.
21:08:36 <carter> honestly happstack and snap are kind converging
21:08:42 <simpson> ski: I had just thought that free monads were the cool thing.
21:08:45 <carter> they have some style difference
21:08:51 <carter> and you can kinda mix an dmatch em
21:08:52 <stepcut> carter: converging in what way?
21:08:58 <carter> :)
21:09:09 <Twey> Doesn't Snap still throw away useful type information in places?
21:09:11 <carter> i mean in that they differ in style, but you can mix and match libs form each
21:09:14 <carter> i know nothing
21:09:16 <ski> simpson : and if you used such direct recursion, then `Pattern' and `Expr' would have been mutually recursive, yes ?
21:09:18 <carter> *from
21:09:21 <simpson> ski: Yeah.
21:09:47 <carter> stepcut: welll, when one of the snap authors says they also like happstacks design,
21:09:52 <carter> thats positive thing i htink
21:10:06 <L8D> now i'm depressed
21:10:15 <L8D> I have to relearn rails
21:10:18 <L8D> for work
21:10:36 <carter> L8D:?
21:10:38 <L8D> I've been enjoying haskell for so long
21:10:44 <carter> L8D: enjoy good engineering
21:10:45 <ski> simpson : then i think you'd now need something like `data Expr pat expr = ... | Call expr String [expr] | ... | Try expr pat expr'
21:10:55 <L8D> and now I have to go back to the madness
21:11:23 <ski> hm
21:12:01 <ski> i suppose a `Pattern' possibly can't contain an `Expr' here
21:12:06 <L8D> I hate ruby
21:12:17 <carter> L8D: i'm not saying you should like it
21:12:20 <L8D> Does anyone have a job for a Haskeller?
21:12:26 <carter> where do youlive?
21:12:32 <L8D> Austin TX
21:12:38 <codygman> L8D: I can relate a bit, I recently got a new job where the pythoncode looks like C, the there are misspellings everywhere, and most of the lines are 125+ chars long.
21:12:43 <L8D> I can work remotely
21:12:46 <tsou> L8D: depending on the work, you can try getting away by building the app in, say, snap, and adding a footer with "Powered by Rails", with the rails logo or something
21:13:03 <carter> L8D: yeah, it'd also be faster
21:13:08 <carter> so you'd need fewer servers
21:13:11 <L8D> tsou: I'm not doing that type of work
21:13:26 <codygman> tsou: That only works for very certain types of work ;)
21:13:28 <tsou> L8D: heh ok, it was just a suggestion that sometimes work :P
21:13:40 <L8D> I'm needing to go back to rails because I'm needing to do tutoring on this site: http://www.hackhands.io/
21:13:45 <ski> simpson : i'm mostly trying to figure out what AST(s) you're actually after, atm
21:13:58 <codygman> tsou: I was called out for using python instead of php a few years back... but everything worked perfectly.
21:14:01 <simpson> ski: Well, the one from that capn is really it.
21:14:04 <simpson> https://github.com/MostAwesomeDude/secret/blob/master/colonel.capn
21:14:23 <L8D> carter: do you have a serious position for a job somewhere?
21:14:30 <carter> ?
21:14:52 <carter> i've work for clients
21:14:54 <L8D> you asked me where I live, after I asked if there are any jobs for haskellers
21:14:57 <carter> well
21:15:00 <carter> i'm in nyc
21:15:03 <carter> theres 1-2 places here
21:15:09 <carter> soostone.com
21:15:17 <ski> simpson : e.g. i'm not sure why you say `| Via a (Pattern a)' rather than `| Via a a'
21:15:17 <tsou> codygman: i've run openbsd on a server after not being able to convince the owner that it was a better choice than linux, and the "powered by linux" made him happy
21:15:31 <ski> (also i'm not sure what a "via pattern" is supposed to capture)
21:15:49 <tsou> codygman: that's the only similar experience i have, but i think it would work on many levels like the rails suggestion above..
21:16:28 <ski> (also, i'm not happy about the "should be"s)
21:17:50 <tsou> carter: what goodies did you have in mind about the new snap?
21:18:08 <codygman> tsou: I recently tried salvaging a broken python site based on a deprecated shopping cart. The server was running Ubuntu 8.10. I put everything on Debian wheezy, put the source code into a VCS, had a great CI pipeline going with vagrant... then I got fired because things weren't fixed fast enough. Then I got an email asking for help after I was fired... lol.
21:18:11 <carter> gcollins has wip fast httpserver thigy
21:18:23 <carter> its nearly ready for release
21:18:32 <carter> and should be able to use the improved io manager work
21:18:54 <simpson> ski: The "should be" is a constraint that I couldn't quite figure out how to encode in the type.
21:19:04 <carter> i'm told theres wip for happstack and yesod too
21:19:12 <carter> but the snap one is due out actulaly soon
21:19:16 <ski> simpson : and `Via' ?
21:19:57 <tsou> codygman: heh
21:20:00 <simpson> ski: Via patterns are for doing mapping. The expression is treated as a callable object and is passed the result of the pattern.
21:20:10 <tsou> carter: i see
21:20:19 <ski> (and should a `Catch' really be an expression ? can it ever occur anywhere, except directly inside an `Escape' ?)
21:20:33 <carter> i don't understand all of gcollin's code style, but he's very very methodical about perf
21:20:36 <ski> simpson : like "view patterns" in Haskell ?
21:20:40 <simpson> ski: Yes, it can occur anywhere.
21:20:51 <simpson> Yeah. This is for the E language, an object-based expression language.
21:20:58 <codygman> tsou: The funniest part is the people who replaced me emailed asking for access to the rackspace account with the server on it. Why is that funny? Because they had the login to the correct rackspace acocunt with the server, but didn't realize it.
21:21:26 <ski> > let map f [] = []; map f ((f -> y):(map f -> ys)) = y:ys in map (^2) [0 .. 9]  -- view patterns
21:21:27 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
21:21:58 <tsou> carter: i'll give it a try soon, I guess ;)
21:22:03 <ski> simpson : i don't know much about E, except that it supports "capabilities" and "(revokable) promises"
21:22:08 <carter> tsou:? they're all nice
21:22:23 <carter> i just think yesod gives people too many build hells
21:22:45 <tsou> carter: i've only used scotty and it was simple and nice
21:22:49 <carter> cool
21:22:54 <carter> i should use it probably :)
21:23:40 <simpson> ski: Ah, yes, the sales pitch is a little rough, but the main idea is that a bunch of higher-level language constructs desugar to via-patterns for things like testing and transformation.
21:23:41 <pdxleif> You could also just use raw WAI - https://github.com/LeifW/online-typechecker/blob/master/index.hs#L21
21:23:42 <tsou> carter: i prefer the minimalistic stuff, and yesod, though i have not used it, feels like a beast
21:23:53 <carter> understatementttttt
21:24:19 <codygman> tsou: I can agree with that. I thought using DSL's for javascript was cool... but I could just use fay I think.
21:24:19 <tsou> heheh
21:25:03 <carter> codygman: have you seen jmacro?
21:25:08 <codygman> Though I'd choose Yesod over rails, Django, etc that I've been working with :)
21:25:15 <carter> http://hackage.haskell.org/package/jmacro
21:25:35 <ski> simpson : via-patterns was like view-patterns, yes ?
21:25:45 <codygman> carter: Whoa, that looks interesting.
21:25:54 <carter> yes
21:25:55 <carter> it is
21:26:08 <carter> ghcjs uses it for code gen + writing the ghcjs RTS
21:26:17 <carter> and other peopleuse it to write js
21:26:47 <tsou> codygman: i think if i was forced to choose between yesod and rails, i'd go with rails, but i've worked with neither so that doesn't really say much
21:26:48 <simpson> ski: Yeah, very similar. `def via(foo) x := 42` is equivalent to `def x := foo.run(42, null)`
21:27:25 <tsou> codygman: in the sense that both look like beasts to me, but rails is definitelly a tamed one and way more tested/stable, i suppose..
21:27:31 <L8D> Anyone of you have a job doing FP?
21:27:36 <tsou> carter: thanks i was not aware of that..
21:27:41 <ski> simpson : anyway, i would probably either unfold `Catch' into `Escape', or, if you don't like the code (type) duplication, fold the `Catch' case out into a separate type
21:27:56 <carter> FP isn't a job, software engineering done well is a job :)
21:28:01 <ski> (and then refer to that from both `Catch' and `Escape')
21:28:04 <carter> or math, applied, is a job
21:28:22 <L8D> I mean, using languages like Clojure or Haskell
21:28:29 <L8D> or F#
21:28:48 <simpson> ski: They do different things, though. Catch is for handling runtime problems; Escape creates a delimited continuation for use within it.
21:28:56 <simpson> *within the Escape, that is.
21:28:57 <L8D> or others with really strict and clean formats and paradigms.
21:28:57 <carter> L8D: stop asking for languages
21:29:07 <L8D> carter: why?
21:29:08 <carter> ask for work that has / values good engineering
21:29:12 <carter> and great colleauges
21:29:17 <carter> yes, better tools are nice
21:29:21 <carter> but only when the people are too!
21:29:22 <codygman> tsou: I didn't use rails long enough to really comment, and this could very well be baseless, but I get a feeling of being very unsafe when coding in rails-land (and ruby-land, but less so).
21:29:25 <L8D> touche
21:29:43 <ski> simpson : i didn't claim they didn't do different things (i wouldn't know), i just started from `| Escape (Pattern a) a (Expr a) -- should be Catch'
21:30:02 <simpson> Oh, sorry. I meant that that last `Expr a` should really be `Catch a`.
21:30:03 <carter> people who say they want an FP job really mean "great work and colleuage, using tools that help us focus on the goal"
21:30:09 <codygman> carter: Definitely! For instance, I'd rather be working with great PHP engineers than bad python ones... even though PHP is technically and provably a worse language.
21:30:24 <carter> codygman: so you work at fb?
21:30:27 <carter> :)
21:30:32 <ski> simpson : exactly. which was what my suggestion was meant to fix
21:30:52 <codygman> carter: Haha, that's a good one... I never realized that.
21:31:08 <simpson> ski: Oh, I see. Yeah.
21:31:21 <carter> they even have a  gradually typed better than php lang that runs on the same vm i hear
21:31:46 <tsou> codygman: i did go through a lot of trouble trying to install yesod when i wanted to give it a try..  i had a site with quite a lot of functionality using rails, and i was checking both in parallel
21:32:04 <tsou> codygman: in any case, as i said, neither of them really appeals to me
21:32:05 <ski> simpson : what does `List' do ?
21:32:24 <simpson> ski: Matches lists. `def [x, y] := [1, 2]`
21:33:03 <ski> simpson : ok. so what does `def [via(foo) x,via(bar) y] := e' amount to ?
21:33:32 <eazar001> Hi all, I have a problem in which i make a datatype an instance of two different classes, but haskell complains that i have duplicate instance declarations ...
21:33:49 <eazar001> what am i doing wrong?
21:33:55 <ski> (i'm checking the semantics of `via', if you're wondering)
21:34:39 <pdxleif> Curious why WAI is getting beaten by jruby-rack here: http://www.techempower.com/benchmarks/#section=data-r8&hw=i7&test=json
21:35:01 <simpson> ski: Hm. It should attempt to match `e` to a two-element list and then map the first with `foo` and the second with `bar`, calling the implicit ejector in case of error. (There's extra syntax to pick an explicit ejector.)
21:35:12 <ski> simpson : maybe it amounts to basically `def [a,b] := e' followed by `def [x,y] := [foo.run(a,null),bar.run(b,null)]' (with `a' and `b' fresh) ?
21:36:07 <levi> eazar001: Could you be more specific about what you did?
21:36:22 <chrisdotcode> hey guys, can' you pattern match like this:
21:36:22 <chrisdotcode> fn :: X -> (Y, Z) -> A
21:36:22 <chrisdotcode> fn x (y,z) = ...
21:36:34 <ski> you can
21:36:50 <chrisdotcode> ski: thought so. thanks :)
21:36:56 <eazar001> levi: sorry, i was in the middle of getting a link preped, here it is: http://github.com/k0ral/hbro/blob/master/Hbro/Config.hs
21:37:04 <simpson> ski: I don't have an E on this computer right now, but it actually gets pretty gnarly. There's lots of explicit calls to the various patterns there.
21:37:10 <eazar001> it's at line 76 and 79 that compiler complains
21:37:34 <simpson> ski: http://bazaar.launchpad.net/~washort/monte/old-e/view/head:/monte/test/test_expander.py has a good number of expansions if you're interested in the horrifying sausage factory. :3
21:37:39 <ski> simpson : i just wanted to confirm the semantics of `via' (at least to a first approximation)
21:38:26 <ski> simpson : so, this means that a via-pattern in fact *does* contain both an expression and a pattern
21:38:53 <ski> simpson : iow, we *do* have an actual mutual-recursion between `Expr' and `Pattern' (which i wanted to check)
21:38:53 <levi> eazar001: Are you sure there aren't instances for those defined already at that datatype? I see you've imported it.
21:38:54 <simpson> ski: Yeah. In `def via (foo) x`, `x` is the pattern, and `foo` is the expression.
21:39:27 <ski> simpson : however, for `| List [Pattern a] a', i'm not sure what the trailing `a' is for ?
21:39:50 <ski> simpson : can a list-pattern contain an expression as well as a list of patterns ?
21:40:09 <levi> eazar001: The compiler can auto-derive Eq and Show for most data types, so it's fairly common for those instances to already exist.
21:40:10 <codygman> Can I use local packages (or packages in another cabal sandbox) in a cabal sandbox to avoid having to recompile them again when installing in a new sandbox?
21:40:18 <simpson> ski: IIRC the second `a` is the Expr containing an ejector which covers the entire list.
21:40:44 <ski> hm, some kind of expression to evaluate in case the match fails, i suppose
21:41:06 <simpson> Right.
21:41:16 <ski> (though i'm not sure why one would attach it to the pattern like that)
21:41:27 <simpson> The idea is that that expression covers the entire list. It's more convenient than using a via-pattern to slug along the entire list one element at a time.
21:41:31 <levi> codygman: Is 'cabal sandbox add-source' what you're looking for?
21:42:26 <ski> simpson : anyway, at least to a first (non-`Free') approximation, i think you here mean `data Pattern = ... | List [Pattern] Expr | ... | Via Expr Pattern'
21:42:41 <codygman> levi: I believe it is, though I'll have to test it... one moment
21:42:58 <simpson> ski: Yeah, and that's what I've currently got down in my non-free version.
21:44:10 <ski> simpson : and thus, to a second (IndirectComposite) approximation, you do want something like `data Pattern expr pat = ... | List [pat] expr | ... | Via expr pat'
21:44:15 <ski> @where IndirectComposite
21:44:15 <lambdabot> <http://web.archive.org/web/20051126141834/http://haskell.org/hawiki/IndirectComposite>
21:44:49 <sam___> Hello , I was wondering if I could ask something related to the whole maybe concept , can't understand what the interpreter keeps yelling at me...
21:44:53 <simpson> ski: Interesting.
21:45:21 <ski> (`Free' is basically a variant of IndirectComposite where you can inject values (sometimes thought of as variable names) into the AST)
21:46:35 <ski> simpson : by going GADT, it would be possible to reduce the two (or more, for more mutual recursion) type arguments to a single one, by introducing a GADT index -- that might make it simpler to use a version of `Free'
21:47:39 <sam___> I was wondering if someone could point out the error/errors in the following tidbit [http://lpaste.net/99240] ?
21:48:15 <ski> simpson : anyway, with `data Pattern expr pat = ...' and `data Expr pat expr = ...' (or with the type parameters in the same order, if you prefer), the idea is that both `Pattern' and `Expr' (which are to be thought of as incomplete, single-level versions of the types we're actually after) will be handed the complete versions of those two types as actual parameters, and will then construct these two actual AST types
21:48:58 <ski> simpson : more or less `type RealExpr = Expr RealPattern RealExpr; type RealPattern = Pattern RealExpr RealPattern' (though we can't type exactly that)
21:49:22 <Axman6> sam___: what errors? that code should compile, and do exactly nothing at all
21:50:37 <sam___> Axman6 keep getting this [http://lpaste.net/99241]
21:50:53 <sam___> Axman6 :  keep getting this [http://lpaste.net/99241]
21:51:06 <Axman6> sam___: well, the error is saying that 1.0 isn't something of type Maybe Int
21:51:10 <Axman6> which it isn't
21:51:22 <Axman6> you need to give adder something of tyoe Maybe Int
21:51:26 <Iceland_jack> > 1.0 :: Maybe Int
21:51:27 <lambdabot>  No instance for (GHC.Real.Fractional
21:51:27 <lambdabot>                     (Data.Maybe.Maybe GHC.Types.Int))
21:51:27 <lambdabot>    arising from the literal `1.0'
21:51:27 <lambdabot>  Possible fix:
21:51:27 <lambdabot>    add an instance declaration for
21:51:28 <Iceland_jack> huh
21:51:40 <carter> :t Just 1.0
21:51:40 <lambdabot> Fractional a => Maybe a
21:52:44 <Iceland_jack> instance Num n ⇒ Num (Maybe n) where { … fromInteger = Just . fromInteger; … }
21:52:45 <Iceland_jack> ;)
21:53:08 <Iceland_jack> same for Fractional and fromRational
21:53:41 <sam___> em here's the thing , I'm a newbie ,(big time newbie) , so must of the stuff Iceland_JAck typed in , doesn't make sense to me
21:53:43 <ski> simpson : if you want to think about it like that, `Fix f' is basically `Free f Void', and `Free f a' is basically `Fix (Const a :+: f)'
21:53:46 <ski> (ok ?)
21:53:53 <Iceland_jack> sam___: Ignore what I wrote :) it was a joke
21:54:11 <sam___> Iceland_jack: my bad
21:54:15 <Axman6> sam___: are you following a tutorial?
21:54:26 <Iceland_jack> No I shouldn't add noise when someone is looking for help
21:54:33 <sam___> tbh just trying to fiddle with the concept of maybe and just
21:54:44 <Iceland_jack> @src Maybe
21:54:44 <lambdabot> data Maybe a = Nothing | Just a
21:54:46 <sam___> Axman6:tbh just trying to fiddle with the concept of maybe and just
21:54:46 <Axman6> you should follow a tutorial...
21:55:17 <Iceland_jack> @ty Nothing
21:55:18 <lambdabot> Maybe a
21:55:20 <Iceland_jack> @ty Just
21:55:21 <lambdabot> a -> Maybe a
21:55:24 <sam___> Axman6: Real World Haskell didn't make the concept any clearer
21:55:28 <Iceland_jack> sam___: Do the types of Nothing and Just make sense?
21:55:35 <Iceland_jack> You should check out Learn You a Haskell
21:55:36 <Iceland_jack> @where LYAH
21:55:36 <lambdabot> http://www.learnyouahaskell.com/
21:55:50 <levi> sam___: What's your current understanding of how the Maybe type works?
21:56:00 <ski> sam___ : next time, "Annotate" your original paste with updates. that way one can view them on the same page, comparing stuff more easily
21:56:15 <Axman6> sam___: use LYAH
21:56:20 <sam___> ski : understoof
21:56:32 <Iceland_jack> (can I second LYAH when I've already proposed it?) :)
21:56:40 <sam___> Axman6 , Iceland_jack: LYAH starts out with typeclasses at the very start !
21:56:51 <Axman6> no it doesn't, does it?
21:56:53 <Iceland_jack> No
21:57:01 <eazar001> levi: sorry for the stirrup i resolved my issues for now ....
21:57:02 <sam___> in chapter 2 it does
21:57:08 <Iceland_jack> sam___: LYAH mentions type classes in chapter 3
21:57:16 <eazar001> levi: im just having a few dozen more issues \=
21:57:17 <levi> eazar001: Glad to hear it.
21:57:27 <levi> Er..
21:57:31 <levi> I spoke too soon. :)
21:57:39 <eazar001> lol, thx for your attention though
21:57:39 <Axman6> sam___: type classes aren't exactly a difficult concept though. did you read chaper 1?
21:57:44 <NemesisD> LYAH is the gentlest intro that i know of unless i misremember
21:58:01 <flebron> Say I have a [IO (Maybe a)], how can I get the first IO a that is a Just?
21:58:07 <NemesisD> but it leaves you well short of useful programs
21:58:24 <Axman6> :t foldM
21:58:25 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
21:58:25 <simpson> ski: Very interesting, thanks.
21:58:51 <ski> simpson : anyway, what i was suggesting was to place `Expr' and `Pattern' more on an equal footing, so to speak
21:58:54 <flebron> Perhaps I could sequence, then msum?
21:59:03 <NemesisD> flebron: dang, beat me to it
21:59:26 <sam___> Axman6: -shrugs- I found RWH to be much better , -shrugs-
21:59:36 <ski> simpson : it's not completely clear that this is a good thing to do, but i think it is probably a good thing to do, at least temporarily, to figure out what you really want the AST types to look like
21:59:38 <Iceland_jack> flebron: That doesn't stop running the commands
21:59:50 <ski> simpson : *because*, i suspect that you currently have bugs in the AST design
21:59:59 <levi> sam___: Maybe is a sort of type that "enhances" another base type with the possibility of having no value. But to do that, it creates a new type that doesn't work with functions expecting the base type. Fortunately, there are a few ways to safely get back to the base value (if it has one!).
22:00:13 <Axman6> sam___: well, clearly not, the topics you're having problems with are quite fundamental. RWH isn't designed as a haskell tutorial, and it's sort of a shame it even has a basic tutorial in the beginning
22:00:17 <flebron> Iceland_jack: Ah, is there a better way, that stops when it finds a Just?
22:00:23 <Iceland_jack> monad transformers
22:00:44 <ski> simpson : in your current design, you call `Free' on `Expr' -- this means that your `a' in `Expr a' will be fed with "the final version of `Expr'", let's call it `RealExpr' for the sake of discussion
22:01:12 <ski> (simpson : there's also an `Object a' in `Free Expr (Object a)', but i'm ignoring that part for the moment)
22:01:24 <NemesisD> more than meets the eye
22:01:36 <sam___> <Axman6> IS there another tutorial of Haskell that you recommend , ..em here's the thing, I have looked over LYAH over the past two years ..and for some reason I keep abandoning it ....not sure what that means
22:01:42 <ski> simpson : then, `Expr' indirectly calls out to itself (i.e. really `RealExpr') by using `a' in various places
22:02:10 <ski> simpson : and it explicitly calls out to `Pattern', by using `Pattern a' (effectively `Pattern RealExpr')
22:02:16 <NemesisD> Axman6: what about erik meijer's channel 9 lectures, do you think he'd benefit from those?
22:02:23 <Axman6> sam___: it's by far the best introduction to haskell, there's not much else I can recommend. just need to stick with it, and ask questions here when you get stuck
22:02:35 <Axman6> NemesisD: I'm not sure I've seen them
22:02:37 <ski> simpson : which means that `a' in the definition of `Pattern a' will also refer to `RealExpr' (not `RealPattern', which i first thought)
22:02:45 <Iceland_jack> sam___: Is there any particular point in LYAH where you get stuck?
22:03:03 <NemesisD> i remember watching those lectures early on, maybe i just liked his enthusiasm
22:03:06 <Iceland_jack> Do you get lists?
22:03:06 <Iceland_jack>     [1,2,3,4]
22:03:06 <Iceland_jack> being sugar for
22:03:06 <Iceland_jack>     1:2:3:4:[]
22:03:11 <Iceland_jack> which parses as
22:03:15 <Iceland_jack>     1:(2:(3:(4:[])))
22:03:18 <sam___> Iceland_jack : yeah that I get
22:03:30 <ski> simpson : so when you mention `a' in the definition of `Pattern a', it essentially means `RealExpr', and when you mention `Pattern a', it essentially means `Pattern RealExpr', iow it essentially means `RealPattern', as desired
22:03:30 <Iceland_jack> Do you get that lists *only* have two cases? Empty and non-empty
22:03:33 <sam___> Iceland_jack: I have had a course in Miranda -shrugs-
22:03:40 <Iceland_jack> Miranda, interesting
22:03:53 <Iceland_jack> Are list comprehensions clear to you?
22:04:05 <sam___> Iceland_jack: I would think so
22:04:13 <ski> simpson : *however*, when in `Expr a' you call out to `Script a', this means that you essentially call `Script RealExpr' (call it `RealScript')
22:04:26 <Iceland_jack> @let length' xs = sum [ 1 | _ <- xs ]
22:04:27 <lambdabot>  Defined.
22:04:28 <Iceland_jack> > length' [1..100]
22:04:31 <lambdabot>  100
22:04:41 <Iceland_jack> So that definition is clear sam___?
22:04:56 <sam___> Iceland_Jack: yes , it counts the number of items in a list . right?
22:04:57 <ski> simpson : and *then*, when in `Script a' you refer to `a', it means `RealExpr', and when you refer to `Expr a', it means `Expr RealExpr' .. wait, *huh* ! :)
22:05:06 <ski> simpson : i suspect that you didn't intend this to happen
22:05:12 <ski> simpson : are you following ?
22:05:18 <levi> flebron: liftM (head . catMaybes) ?
22:05:21 <Iceland_jack> sam___: Well the length, yes. It doesn't touch the content of the list
22:05:44 <Iceland_jack> @undef
22:05:44 <lambdabot> Undefined.
22:06:08 <Iceland_jack> sam___: Does
22:06:08 <Iceland_jack> @let length' = sum . map (const 1)
22:06:08 <Iceland_jack>  
22:06:08 <lambdabot>  Defined.
22:06:13 <Iceland_jack> make sense?
22:06:13 <Iceland_jack> > length' "testing"
22:06:14 <lambdabot>  7
22:06:19 <simpson> ski: Well, I did intend for Script to refer to a collection of Exprs which are closed over.
22:06:31 <Axman6> :t maybe
22:06:31 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:06:33 <sam___> Iceland_jack: const 1?
22:06:38 <Iceland_jack> sam___:
22:06:39 <Iceland_jack> @src const
22:06:39 <lambdabot> const x _ = x
22:06:46 <ski> simpson : what do you mean by "closed over" ?
22:06:55 <Axman6> :t foldM (\ma mio -> maybe mio return ma) Nothing
22:06:56 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = Maybe a0
22:06:56 <lambdabot>     Expected type: Maybe (Maybe a0)
22:06:56 <lambdabot>       Actual type: Maybe a0
22:07:24 <Iceland_jack> so
22:07:25 <Iceland_jack>     length = sum . map (const 1)
22:07:25 <Iceland_jack> is the same as
22:07:25 <Iceland_jack>     length xs = sum (map (const 1) xs)
22:07:25 * ski . o O (`\ma mio -> ma ma mio')
22:07:28 <Iceland_jack> and
22:07:31 <Iceland_jack>     length xs = sum (map (\_ -> 1) xs)
22:07:34 <Iceland_jack>     
22:07:50 <Iceland_jack> :t \ma mio -> ma ma mio
22:07:50 <lambdabot>     Occurs check: cannot construct the infinite type:
22:07:51 <lambdabot>       t1 = t1 -> t2 -> t0
22:07:51 <lambdabot>     In the first argument of `ma', namely `ma'
22:07:51 <Iceland_jack> ;)
22:08:05 <simpson> ski: A Script is effectively a method on an Object, so it has two sources of bound values: The names closed over in the creation of the Object, and the parameters to the method.
22:08:08 <sam___> Iceland_jack: I got the length xs = sum (mao (const 1) xs ) ..but still odn't understand the one above it
22:08:20 <ski> @type \(ma :: forall a. a -> a) mio -> ma ma mio
22:08:21 <lambdabot> (forall a1. a1 -> a1) -> a -> a
22:08:22 <Iceland_jack> okay I see
22:08:24 <Iceland_jack> @src (.)
22:08:24 <lambdabot> (f . g) x = f (g x)
22:08:24 <lambdabot> NB: In lambdabot,  (.) = fmap
22:08:30 <Iceland_jack> Does that definition make sense sam___?
22:08:44 <NemesisD> hey speaking of mio, how likely is the new io subsystem going to improve those web framework benchmarks that haskell keeps coming up short in
22:08:48 <Iceland_jack> (That's function composition which plays a vital role)
22:08:54 <sam___> Iceland_jack: function composition does make sense
22:08:57 <Iceland_jack> okay
22:08:58 <ski> simpson : mhm, so a closure ?
22:09:16 <levi> sam___: . is function composition and $ is function application, in case you run across them.
22:09:17 <Iceland_jack> so when we write a definition as
22:09:18 <Iceland_jack>     foo x = g (f x)
22:09:28 <Iceland_jack> it should be the same as defining it as
22:09:29 <Iceland_jack>     foo = g . f
22:09:30 <Iceland_jack> right?
22:09:44 <simpson> ski: Yeah. Here's a version with the AST being all concrete; it seems to work-ish. http://lpaste.net/99242
22:10:11 <sam___> Iceland_jack: I suppose so ..
22:10:22 <Iceland_jack> sam___: You don't seem certain :) let's take it one step at a time
22:10:28 <Axman6> :t maybe (undefined :: IO (Maybe a)) return
22:10:29 <lambdabot> Maybe (Maybe a) -> IO (Maybe a)
22:10:53 <Iceland_jack>     foo x = g (f x)
22:10:53 <Iceland_jack> is the same as
22:10:53 <Iceland_jack>     foo x = (g . f) x
22:10:54 <Iceland_jack> right?
22:10:59 <Iceland_jack> by the definition of (.)
22:11:02 <Iceland_jack> @src (.)
22:11:02 <lambdabot> (f . g) x = f (g x)
22:11:02 <lambdabot> NB: In lambdabot,  (.) = fmap
22:11:11 <sam___> Iceland_jack : okay now it makes sense
22:11:17 <Iceland_jack> good :)
22:11:34 <ski> ok, that has `data Script = Script Verb Expr [Expr] [Expr] [Expr]' instead of [strangeness]
22:11:36 <Iceland_jack> Okay sam___, do you want to learn about type classes or data types?
22:11:53 <sam___> Iceland_jack: typleclasses would be nice
22:12:06 <Iceland_jack> LYAH introduces type classes way before telling you how to define your own data types, not sure I'd go that route but what ever
22:12:07 <sam___> The hwole ord,show,eq didn't make sense to me
22:12:23 <Iceland_jack> sam___: okay, that's fairly common
22:12:41 <Iceland_jack> You can (informally) think of type classes as being sets of type
22:12:56 <Iceland_jack> Eq is the set of all types whose elements you can compare for equality
22:13:10 <Iceland_jack>     Eq = { Int, (), Bool, … }
22:13:21 <simpson> ski: Yeah. An object name, a return value guard, a list of interfaces, the actual list of methods, and the matchers for when no methods match.
22:13:30 <Iceland_jack> there are some types that you cannot compare for equality
22:13:30 <Iceland_jack>     (Int → Bool) ∉ Eq
22:14:12 <Iceland_jack> So basically we want to restrict what types are and are not allowed into our functions
22:14:19 <sam___> Iceland_jack: why make it so explicit though?
22:14:36 <Iceland_jack> sam___: Let's say that you have a function which compares three numbers for equality
22:14:57 <sam___> Iceland_jack: noted ..
22:14:57 <ski> simpson : anyway, i'm not sure yet what gain you hoped to get by using `Free'
22:15:01 <Iceland_jack>     threeSame :: a -> a -> a -> Bool
22:15:01 <Iceland_jack>     threeSame x y z = x == y && y == z
22:15:10 <Iceland_jack> (assuming transitivity)
22:15:22 <sam___> Iceland_jack: noted ..
22:15:25 <ski> simpson : one possible gain could be to be able to annotate each node of an AST with extra information
22:15:28 <simpson> ski: I don't know either. I just have heard that that's the way to do it.
22:15:29 <Iceland_jack> What happens when passing three functions to ‘threeSame’?
22:15:41 <ski> or to be able to manage incomplete ASTs (e.g. in an editor)
22:15:43 <NemesisD> is this not a thing you can do? instance Foo a => Bar a where, in other words, if a type has a valid Foo instance, this defines its Bar instance?
22:15:47 <sam___> Iceland_jack: eh error?
22:15:59 <Iceland_jack> well, a compile-time error
22:16:07 <Iceland_jack> (or that's what we'd want anyway)
22:16:15 <levi> sam___: Another way to think about it.... what do you know about a type when it only appears in a signature as 'a' or some other type variable?
22:16:47 <sam___> levi: polymrphic?
22:16:55 <Iceland_jack> sam___: a type of polymorphism (ad-hoc)
22:16:58 <Iceland_jack> sam___: Let's ask lambdabot what the type of ‘threeSame’ is
22:17:08 <Iceland_jack> @let threeSame x y z = x == y && y == z
22:17:09 <lambdabot>  Defined.
22:17:09 <levi> But what can you say about its structure? What kind of function can you write on a type 'a'?
22:17:13 <Iceland_jack> :t threeSame
22:17:14 <lambdabot> Eq a => a -> a -> a -> Bool
22:17:44 <Axman6> where'd that Eq a => come from!
22:17:47 <Axman6> D:
22:17:49 <levi> (you don't know much about it, because any function you write must work for *any* type! you can't depend on the structure of the type at all in such a function)
22:17:50 <ski> simpson : anyway, i'm not saying that my suggestion necessarily is much better than your <http://lpaste.net/99242> (it depends on what you want to do) -- i'm merely saying it's where i would start to go, if i wanted to do something IndirectComposite-like (which i think `Free' is a variant of)
22:18:07 <sam___> Iceland_jack: so it accepts basically anything (as long of the same type) and hence typeclaases limit it to a certain subset?
22:18:25 <Iceland_jack> lambdabot noticed that since we use (==) to compare x, y and z for equality: those must
22:18:25 <Iceland_jack>     ⅰ) be of the same type
22:18:25 <Iceland_jack>     ⅱ) must be members of Eq (since every type that you can use (==) or (/=) on must be in Eq)
22:18:51 <ski> simpson : anyway, the basic IndirectComposite relies on using a `Fix :: (* -> *) -> *' construction (and `Free :: (* -> *) -> (* -> *)' is a variant of that)
22:18:57 <Iceland_jack> sam___: Well I'm not so sure what you mean by the first part by the latter part is spot on
22:19:24 <levi> sam___: That's exactly it. A type class puts a constraint on the polymorphism of a type variable, such that you can depend on the type class's methods being defined for types that 'fit' that type variable.
22:19:42 <Iceland_jack> You can read
22:19:42 <Iceland_jack>     threeSame :: Eq a => a -> a -> a -> Bool
22:19:42 <Iceland_jack> as
22:19:42 <Iceland_jack>     “I accept three values of any type and return a Boolean AS LONG AS I can use (==) on those values.”
22:20:21 <sam___> Iceland_jack,levi: understood..understood ...but wait, but why is Show a typeclass ? now sure if that's a valid question...
22:20:28 <Iceland_jack> If you use (>) or (<) or (>=) or (<=) or compare on a value, lambdabot would infer that it belongs to the Ord type class (is an instance)
22:20:31 <ski> simpson : if you have `Expr pat expr' and `Pattern pat expr', then you need something roughly like `Fix2 :: ((*,*) -> (*,*)) -> (*,*)' :)
22:20:34 <Iceland_jack> sam___: That's a good question
22:20:45 <Axman6> :t show
22:20:45 <lambdabot> Show a => a -> String
22:20:49 <Iceland_jack> Show is a ‘set’ of all types whose objects you can show
22:20:52 <levi> Because Show places a constraint such that you know 'show' is implemented for the type.
22:21:01 <Axman6> show can only accept types which are members of the Show class
22:21:02 <Iceland_jack> where show means ‘turn into a string’
22:21:09 <Iceland_jack> > show 5
22:21:10 <lambdabot>  "5"
22:21:12 <shachaf> Hmm, (*,*) looks even more like an owl than I,I
22:21:13 <Iceland_jack> > show "test"
22:21:14 <lambdabot>  "\"test\""
22:21:18 <ski> simpson : `Fix' is defined as `newtype Fix f = In (f (Fix f))', and we get `type RealExpr = Fix Expr' for a simple (non-mutually-recursive) `data Expr expr = ...' AST
22:21:25 <Iceland_jack> > show id -- *BEEP*! ERROR!!
22:21:26 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
22:21:26 <lambdabot>    arising from a use of `GHC.Show.show'
22:21:26 <lambdabot>  The type variable `a0' is ambiguous
22:21:26 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
22:21:26 <lambdabot>  Note: there are several potential instances:
22:21:27 <levi> Well, it means a bit more than 'turn into a string', but that's the basic idea.
22:21:48 <ski> simpson : alternatively it can be defined directly as `newtype RealExpr E (Expr RealExpr)'
22:21:59 <Iceland_jack> sam___: So for example, the ‘print’ function
22:22:02 <Iceland_jack> @ty print
22:22:03 <lambdabot> Show a => a -> IO ()
22:22:07 <simpson> ski: Hm. I like your suggestion of figuring out what I *want* to do before getting any fancier.
22:22:18 <Iceland_jack> Can print any value (as long as it's Show-able)
22:22:20 <Iceland_jack> *its
22:22:22 <levi> simpson: that's excellent advice!
22:22:23 <Iceland_jack> *it's..
22:22:41 <sam___> ICeland_jack, levi: is it meaningfull to ask why would anyone  not want a string representation of  data-type ..I suppose that 's questioning the foundations huh? just the idea that it had to be explicit bugs me..
22:22:56 <Iceland_jack> sam___: print is one use :)
22:23:02 <Axman6> sam___: how do you show a function?
22:23:11 * hackagebot hspec-expectations-lens 0.2.1.1 - Hspec expectations for the lens stuff  http://hackage.haskell.org/package/hspec-expectations-lens-0.2.1.1 (MatveyAksenov)
22:23:13 <levi> sam___: Well, that's kind of what I was getting to with the suggestion that it means more than just 'can be printed to a string'
22:23:13 * hackagebot hspec-expectations-lens 0.3.0.0 - Hspec expectations for the lens stuff  http://hackage.haskell.org/package/hspec-expectations-lens-0.3.0.0 (MatveyAksenov)
22:23:14 <ski> simpson : for your `Expr pat expr' and `Pattern pat expr' you could define `newtype RealExpr = E (Expr RealPattern RealExpr)' and `newtype RealPattern = P (Pattern RealPattern RealExpr)'
22:23:15 <Iceland_jack> oh sorry, misread the question
22:23:32 <simpson> ski: Hmmmm.
22:23:35 <ski> simpson : defining those explicitly via some kind of `Fix2' will be somewhat uglier, i think
22:23:36 <Twey> sam___: It means more that it has a *meaningful* string representation
22:23:51 <sam___> Axman6 : I suppose that wouldn't make sense
22:23:55 <sam___> Twey: makes snese
22:23:56 <levi> sam___: It's meant to print things out in a way such that they can be read back in with the Read typeclass. And some things just can't be printed in such a way.
22:23:57 <Twey> You can define all functions to print as "λ" if you want, but it's not generally useful
22:23:58 <Axman6> indeed =)
22:24:45 <Axman6> sam___: also, showing an IORef doesn't make a whole lot of sense. Either you need to perform IO to read the value inside the reference, or do something like print the address of the reference, which makes it a leaky abstraction
22:24:48 <Twey> It's considered polite to make read . show = id, but not all instances do
22:24:54 <Iceland_jack> sam___: now, does using two type classes make sense?
22:24:55 <Iceland_jack> @ty \x -> x == x && show x == "hi"
22:24:55 <lambdabot> (Eq a, Show a) => a -> Bool
22:25:14 <Axman6> @hoogle a -> TypeRep
22:25:15 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
22:25:15 <lambdabot> Prelude id :: a -> a
22:25:15 <lambdabot> Data.Function id :: a -> a
22:25:16 <ReinH> You *can* make functions an instance of Show if you really want
22:25:17 <ski> simpson : i should also mention the GADT route. instead of `(*,*)' we can use `ASTkind -> *' where `data ASTkind = E | P', and then instead of `Expr pat expr' using `expr' and `pat', we instead get `Expr ast' using `ast E' and `ast P'
22:25:19 <ReinH> > (++"foo")
22:25:20 <lambdabot>  <[Char] -> [Char]>
22:25:21 <sam___> Axman6 :  IORef is greek to me atm
22:25:27 <Iceland_jack> sam___: ignore IORef
22:25:31 <ReinH> lambdabot does but the Prelude does not
22:25:32 <sam___> Iceland_jack: YEah mate, it does make a lot of snese now
22:25:34 <Axman6> ? show (typeOf putStrLn)
22:25:37 <ski> simpson : not sure if you're following this
22:25:39 <Axman6> > show (typeOf putStrLn)
22:25:40 <lambdabot>  "[Char] -> IO ()"
22:25:41 <Iceland_jack> sam___: Okay, good
22:25:47 <Axman6> sam___: it's just a mutable reference
22:25:51 <Iceland_jack> sam___: care to quickly cover defining your own data types?
22:26:07 <simpson> ski: I'm kind of following. I'm thinking about concrete evaluation.
22:26:33 <sam___> Iceland_jack: stuff like type, and data something = Chnage Int Int | Green Doube Double Double ?
22:26:38 <Iceland_jack> yeah
22:26:54 <Iceland_jack> Just wondering if stuff like this makes sense
22:26:54 <Iceland_jack> @src Bool
22:26:54 <lambdabot> data Bool = False | True deriving (Eq, Ord)
22:27:08 <levi> data is for constructing new types; type is for giving an existing type an alias for convenience/readability.
22:27:11 <Iceland_jack> (now the ‘deriving (…)’ part should make more sense after learning a bit about type classes)
22:27:37 <Iceland_jack> Saying
22:27:37 <Iceland_jack>     deriving Eq
22:27:37 <Iceland_jack> means that you can write
22:27:37 <Iceland_jack>     True  == False
22:27:42 <Iceland_jack>     False /= True
22:27:49 <sam___> Iceland_jack: I am very grateful and tbh I wish I discovered theis place a long time ago , how often are you on here? also I have to get ready to go to school
22:28:02 <Iceland_jack> sam___: I need to catch a flight and I haven't packed :)
22:28:07 <Iceland_jack> I'm here most of the time
22:28:12 * hackagebot wai-extra 2.0.3.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.0.3.3 (MichaelSnoyman)
22:28:16 <Platz> wow, the conversations regarding a suggestion to make the javascript Promises A+ spec incorporate monads are pretty intense
22:28:34 <ski> simpson : in the simplest design, we merge `Pattern' and `Expr' into a single declaration `data AST (ast :: ASTkind -> *) :: ASTkind -> * where ...; List :: [ast P] -> ast E -> AST ast P; ...; Def :: ast P -> ast E -> ast E -> AST ast E; ...'
22:28:39 <ReinH> Platz: oh god, let's not ever talk about that
22:28:46 <Twey> Platz: Oh, are they adding a type system to Javascript?
22:29:02 <levi> The deriving bit is asking Haskell to write the instances for the typeclasses for you. It only works on a few of the built-in type classes, but it's still a nice bit of boilerplate reduction as you need those bulit-in type classes quite a lot.
22:29:03 <sam___> Iceland_jack: Once again I'm grateful for the help, but I'd like to give LYAH another shot , and yeah I'll come back here for more doubts and stuff.Damn a flight huh?
22:29:08 <Iceland_jack> Definitely drop me a line if you're in #haskell again sam___
22:29:12 <ReinH> Twey: there's a lot of "I don't know what monads are but I know that you're wrong"
22:29:17 <Twey> Hahaha
22:29:23 <Iceland_jack> Yes, a flight ;) I'm blaming you if I miss it sam___
22:29:26 <ski> simpson : so now `AST ast E' plays the role of `Expr pat expr' (with `ast' playing the role of the two `pat',`expr' parameters), and `AST ast P' plays the role of `Pattern pat expr'
22:29:29 <Platz> no this was 10 months ago.   someone just noticed .then was like >>= and suggested some tweaks.  fallout ensues
22:29:33 <levi> sam___: There's usually someone around willing to help.
22:29:38 <Axman6> sam___: I should stress that LYAH + #haskell is by far the best haskell tutorial ;)
22:29:42 <Iceland_jack> Yes, #haskell is very helpful
22:29:47 <simpson> ski: Ow.
22:29:49 <Platz> goes on for untold pages
22:29:51 <Twey> Hahahahah
22:29:58 <sam___> Iceland_jack: my apologies .
22:29:59 <ReinH> it's so cringeworthy
22:30:00 <Iceland_jack> The problem on #haskell is usually too many people helping
22:30:03 <sam___> I'll keep that in mind
22:30:07 <Iceland_jack> sam___: (joking) :)
22:30:13 <Twey> ReinH, Platz: There's a beautiful ticket: ‘Incorporate category theory’
22:30:22 <ReinH> hahaha
22:30:23 <levi> Sometimes a bit of interaction/tutorial help is just what you need to have things make sense.
22:30:28 <sam___> Oh one last thing....
22:30:33 <ReinH> "Make Promises more mathy"
22:30:37 <shachaf> Axman6: Is this a "two wrongs make a right" thing?
22:30:43 <sam___> how important is learning category theory ?
22:30:46 <Iceland_jack> sam___: Not at all
22:30:47 <ion> @quote two.wrongs
22:30:47 <lambdabot> ion says: Three lefts make two wrongs
22:30:55 <Iceland_jack> but you should still check it out
22:31:01 <ReinH> sam___: you'll find yourself picking it up a bit here and there whether you want to or not ;)
22:31:27 <sam___> hmm...noted
22:31:28 <levi> sam___: You will here people on #haskell talk about it here occasionally, but you can safely ignore it unless it sounds interesting to you.
22:31:45 <Iceland_jack> There are better ways of spending your time if you're interested in becoming better at Haskell
22:31:47 <ski> simpson : however, we could factor this into `data AST (ast :: ASTkind -> *) :: ASTkind -> * where AST_E :: Expr ast -> AST ast E; AST_P :: Pattern ast -> AST ast P' and then we get back simpler separate `data Pattern (ast :: ASTkind -> *) = ... | List [ast P] (ast E) | ...' and `data Expr (ast :: ASTkind -> *) = ... | Def (ast P) (ast E) (ast E) | ...'
22:31:51 <Axman6> sam___: I've been using Haskell for 6 years and know very little CT. I can tell you what a monoid is, and possibly what a monad is... but that's about it. it's not necessary
22:31:53 <sam___> but wouldn't it be difficult to follow if not exposed to propositional logic and first order logic ?
22:32:01 <Iceland_jack> but if you want to learn category theory for its own sake, please do
22:32:05 <Axman6> not really
22:32:12 <ReinH> sam___: once it gets all jargony it can be
22:32:15 <levi> Monoids are not really from category theory, although Monads are.
22:32:28 <Iceland_jack> sam___: If you want to learn something ‘mathy’ what will help you with Haskell, learn type theory and lambda calculus and so on
22:32:36 <Axman6> see, shows how little CT I know :P
22:32:38 <levi> I mean, CT talks about Monoids, but they were around from before.
22:32:42 <Iceland_jack> but once again, not needed to actually program in Haskell
22:32:58 <ski> simpson : in fact, this "factored" definition might even be good in case you have some constructions which work uniformly on all your ASTs (like if you had `if' for both `Expr' and `Pattern', e.g. .. which you don't have here)
22:32:59 <simpson> ski: I get what you're saying, but also my head hurts. :3
22:33:08 <ReinH> abstract algebra and category theory are a great source for "oh that's the name of that thing I've been using"
22:33:49 <ski> simpson : anyway, the main point here is that if we want to use some kind of fix-point on this, instead of needing `Fix2 :: ((*,*) -> (*,*)) -> (*,*)
22:34:04 <ski> ' (which we can't do exactly, though we can get something similar)
22:34:15 <levi> Algebra is far more useful for Haskell than category theory, but you don't *really* need to dive into the guts of the fancy algebraic terminology either.
22:34:26 <Iceland_jack> sam___: Think of it as “whether to learn human anatomy to be able to become a runner”
22:34:29 <ReinH> but you can use monads without knowing what the category of monoids is or what T-algebras are.
22:34:40 <ski> simpson : we can here now actually use a fix-point with kind `((ASTkind -> *) -> (ASTkind -> *)) -> (ASTkind -> *)' on `AST'
22:35:11 <ski> simpson : again, i'm not saying you *want* to use this here, merely offering it as another way to think about this all
22:35:17 <simpson> ski: I...I can't keep up any longer. I think that I've filled up my head for the night. :3
22:35:32 <ski> simpson : well, i'm done with what i wanted to say, anyway :)
22:35:32 <sam___> Iceland_jack: it would be nice to the weight distribution and how it changes while running right?
22:35:44 <sam___> know*
22:36:06 <ReinH> sam___: analogies are like things that are sometimes not entirely accurate.
22:36:10 <ReinH> Also I am bad at analogies.
22:36:11 <Iceland_jack> There would be some benefits no doubt, but if all you're interested in is becoming a better runner there is a better use for your time :)
22:36:25 <Iceland_jack> Yes, analogies are like jokes: sometimes they work and sometimes they leak
22:36:30 <Iceland_jack> no, analogies are like faucets
22:36:35 <sam___> Iceland_jack: I'll keep that in mind..but I suppose the basics first huh?
22:36:54 <keep_learning> Hello All
22:37:06 <Axman6> ReinH: that analogy was more a definition than an analogy :P
22:37:08 <ski> simpson : .. in my case, i figured out this arcane stuff (the GADT version) because i actually needed it (for quasi-quotation purposes)
22:37:08 <Iceland_jack> Yes, I know some very good Haskell programmers who haven't studied category theory
22:37:09 <keep_learning> I am trying to write a interpretor for while language
22:37:12 <keep_learning> http://lpaste.net/99243
22:37:21 <ReinH> Axman6: thatsthejoke.jpg
22:37:23 <simpson> ski: And my ears have perked up again. E's got quasiliterals.
22:37:25 <keep_learning> but getting compiler error.
22:37:27 <Twey> ReinH, Platz: I like this one: « I'm not 100% sure of the behavior of ap and map since you haven't included source code for them, but those two functions would (obviously) be different for promises vs. traditional monads. Since there are vastly more libraries using promises than monads, it is the monads that are preventing you from writing DRY code.  If you provide JavaScript source for ap and map using
22:37:29 <Twey> monads, I will write the corresponding functions for promises. Otherwise, stop trolling. »
22:37:39 <keep_learning> The reason is
22:37:45 <keep_learning> that in my eval function
22:37:48 <ski> simpson : i suspect that for some kind of stuff one can do with `Free', this would be a good way to do it, in case you have mutual recursion
22:37:53 <ReinH> Twey: oh god you went and read it I'm sorry
22:37:58 <keep_learning> when I am calling eval ( Con b ) _ = b
22:38:02 <Platz> heh
22:38:17 <sam___> Anyways I'm off, thanks for the help and good to one and all and Iceland_jack: Good Luck for your flight.
22:38:22 <keep_learning> the type variable t is not getting the instance of bool
22:38:25 <Iceland_jack> Thanks sam___, you too :)
22:38:29 <levi> sam___: A word of advice: don't try to think too hard about what things like Monads and Monoids are, at least not at first. They are actually very simple, it's just that they have consequences that aren't obvious, and really the only way to figure them out is to memorize the simple rules and play with them to see how they work.
22:38:40 <Iceland_jack> levi: gah!
22:38:41 <keep_learning> though I am not expert in GADT but http://en.wikibooks.org/wiki/Haskell/GADT
22:38:46 <Axman6> Twey: link?
22:38:52 <Iceland_jack> Too bad sam___ missed that, it was a good poitn
22:38:54 <Iceland_jack> *point
22:38:54 <keep_learning> suggest the same thing
22:38:58 <keep_learning> which I am doing
22:39:01 <Twey> Axman6: https://github.com/promises-aplus/promises-spec/issues/94
22:39:15 <keep_learning> Could some one please tell what I am missing ?
22:39:21 <levi> Oh well. Hopefully he'll be back another time.
22:39:25 <ski> simpson : i don't know if you're familiar with staged computation a la MetaML or MetaOCaml .. or even plain Lisps (usually in the form of macro programming, though macros aren't strictly speaking necessary) ?
22:39:29 <Platz> raganwald even got in on the fun
22:39:30 <Twey> There's a guy going ‘look, if we make it a monad we can write these functions that work for any monad, including promises’ and then about five other people shout him down with ‘but we can already write these functions for promises!’
22:39:35 <kristof> Why are we talking about lisp in here?
22:39:41 <ski> why not ?
22:39:52 <simpson> ski: Yeah, I am, but right now I want to get to the self-hosting goalpost first.
22:41:02 <Platz> Dunning–Kruger effect clearly in effect
22:41:03 <Twey> keep_learning: Your type definition is wrong
22:41:36 <ski> simpson : anyway, to make a long story short, i wanted to be able to have expressions which evaluated to values representing (quoted) patterns, expressions, declarations, &c. -- and i wanted to reuse the datastructures for the latter to form the former -- except i wanted to allow unquoting back to arbitrary expressions
22:41:47 <simpson> ski: I see.
22:42:00 <Twey> keep_learning: All your terms return values of type ‘Expr a’ or ‘Expr b’ where your ‘a’ and ‘b’ aren't fixed, so ‘Con b’ is of type ‘Expr b’ (forall b) where you want it to actually be ‘Expr Bool’
22:42:25 <Twey> keep_learning: You should have e.g. Con ∷ Bool → Expr Bool
22:42:30 <ski> simpson : also, ideally, i want to allow patterns which match literally on quoted expressions/patterns/declarations -- except that inside an unquotation, i can get back to patterns (e.g. a variable name), so i can bind it to a value representing the relevant part of the quotation
22:42:46 <ski> simpson : and, i wanted to be able to do all this, nestedly :)
22:42:58 <keep_learning> Twey: and for Num :: Interger -> Expr Integer ?
22:43:14 * hackagebot lens-properties 4.0 - QuickCheck properties for lens  http://hackage.haskell.org/package/lens-properties-4.0 (EdwardKmett)
22:43:16 * hackagebot free 4.4 - Monads for free  http://hackage.haskell.org/package/free-4.4 (EdwardKmett)
22:44:07 <keep_learning> Twey: Thank you.
22:44:31 <Axman6> t notice all that JS stuff is 10 months old...
22:44:55 <athan> Is there a taxonomy for the different kinds of reductions that a Haskell compiler/programmer can employ?
22:45:03 <ski> simpson : anyway, i hope my discussion was of some help to you, however small
22:45:09 <simpson> ski: Yeah, I learned a lot.
22:45:33 <Axman6> Twey: I notice *
22:45:46 <ski> athan : some refactoring steps are known as "commuting conversions"
22:45:52 <athan> or the different kinds of evaluations + expansions?
22:46:00 <athan> ahh cool, thank you
22:46:09 <ReinH> athan: some of them are from lambda calculus, like eta and beta reductions. Some are based on equational reasoning or free theorems.
22:46:34 <athan> ReinH: Interesting! Thank you!
22:46:55 <Twey> keep_learning: Right
22:47:52 <Twey> Axman6: Yeah, it's just notably hillarible and this is the first time I've encountered/suffered it :þ
22:47:59 <keep_learning> Twey: So if just change these two constructors then from rest of a and b will inferred or I have to change all a by Integer and b by Bool ?
22:48:03 <ski> athan : one example of a commuting conversion is that `(case e of Left x -> ..x..; Right y -> ..y..) e0' is equal to `case e of Left x -> (..x..) e0; Right y -> (..y..) e0'
22:48:14 * hackagebot http-client-tls 0.2.0.3 - http-client backend using the connection package and tls library  http://hackage.haskell.org/package/http-client-tls-0.2.0.3 (MichaelSnoyman)
22:49:35 <Twey> keep_learning: I don't understand your question
22:50:43 <Axman6> Twey: basically, smart people shouldn't try to teach less smart people that there are better ways to do things. that seems to be the lesson
22:51:05 <ReinH> Axman6: yeah, I remember when it was fresh
22:51:09 <keep_learning> Twey: If I change my constructor Num :: Integer -> Expr Integer and Con :: Bool -> Expr Bool and leaving other constructors as it is with a and b then will a going to infer as Integer and b as Bool
22:51:29 <keep_learning> or I have to replace all the a with Integer and b with Bool ?
22:51:35 <ReinH> I was actually talking to one of the original people who wanted to introduce monads about it and they directed me to the thread
22:51:40 <ReinH> and I just noped my way back out of it
22:51:42 <keep_learning> Although I changed all a to Integer and b to Bool
22:52:01 <keep_learning> but I am trying to clear my understanding of GADT
22:52:39 <Twey> keep_learning: Your problem is that you've said the constructor ‘Con’ returns a value of type ‘Expr a’, for any ‘a’ that can be decided by calling code in the future.  So Con True ∷ Expr Integer is valid, as is Con False ∷ Expr (Either Integer (IO String)).  GHC is complaining because you've then said you'll return something of that type ‘a’ (for any possible ‘a’) but you've only
22:52:40 <Twey> returned something of type Bool.  If you restrict Con to return something of type Expr Bool, GHC will know that that case only needs to return a Bool; you'll need to do make a parallel change to any other constructors that are supposed to return a specific type
22:54:06 <Twey> keep_learning: If you have an expression like Not (Con True) where Not ∷ Expr b → Expr b, Con ∷ Bool → Expr Bool, you'll get an Expr Bool back, but you probably want to make Not ∷ Expr Bool → Expr Bool, because otherwise you also have type-correct expressions like Not (Num 3) ∷ Expr Integer
22:54:19 <Twey> (but maybe that makes sense in your language; I don't know, but I suspect not)
22:54:36 <keep_learning> Twey: Thank you :)
22:55:00 <keep_learning> Twey: now it makes sense.
22:55:02 <Twey> No problem
22:57:30 <Twey> keep_learning: I predict you'll have issues with Var, too, because you've said that eval (Var v) env ∷ a
22:57:44 <Twey> You'll need to introduce a newtype with an existential type to get around that
22:57:45 <keep_learning> Twey: Yes
22:58:33 <keep_learning> Twey: When I am chaning to it Expr String, Parser is complaining of Integer
22:59:34 <Twey> keep_learning: Changing what?  Complaining where?
23:01:06 <keep_learning> Twey: I changed my constructor Var :: String -> Expr String
23:01:10 <keep_learning> then I am getting
23:01:38 <Twey> keep_learning: Why did you do that?
23:01:47 <keep_learning> then I have problem in
23:01:51 <keep_learning> aExperssion
23:02:07 <keep_learning> it's type is Parser ( Expe Integer )
23:02:27 <keep_learning> and type of  Var <$> identifier is Expr String
23:02:50 <Twey> keep_learning: You're modelling the type system of your language.  The type you pass to Expr is the type the term ought to have in your language.  You don't know ahead-of-time what type a Var should have, so you want to introduce an existential type
23:03:08 <Twey> But you can be pretty sure that it won't have type String, because no terms in your language have type String
23:03:16 * hackagebot xml-html-conduit-lens 0.1.0.1 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.1.0.1 (MatveyAksenov)
23:03:18 * hackagebot xml-html-conduit-lens 0.2.0.0 - Optics for xml-conduit and html-conduit  http://hackage.haskell.org/package/xml-html-conduit-lens-0.2.0.0 (MatveyAksenov)
23:03:20 * hackagebot egison 3.2.11 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.11 (SatoshiEgi)
23:03:46 * ski would prefer some proper HOAS
23:03:54 <Twey> Agreed
23:04:09 <ski> (a la lambdaProlog or Twelf)
23:04:12 <joelteon> is there a typeclass like Enum where pred/succ are id on minBound/maxBound respectively, rather than runtime errors
23:04:46 <dhrosa> lol "optics"
23:05:35 <dhrosa> eventually we're going to have 8 layers on top of lens and no one will remember the reason things are named that way
23:05:35 <Twey> keep_learning: data AnyValue = AnInt Integer | ABool Bool; Var ∷ String → Expr AnyValue
23:06:14 <Twey> keep_learning: Is the less type-safe way to do it; an example of a safer way might be to use HOAS as ski suggested, where you represent binding constructs in the object language as binding constructs in the host language
23:06:26 <ski> i was pondering whether one could do `Expr :: (Type -> *) -> (Type -> *)' with `Var :: var typ -> Expr var typ' -- the problem is how to build a usable `var'
23:07:14 <edwardk> dhrosa: we started calling the connection of lens-likes optics, because it lets us describe all of them via the same 2 laws.
23:07:17 <ski> a "syntactic lambda" construction would be really nice in Haskell
23:07:19 <quchen> dhrosa: I think people call lensy stuff optics is because lenses are technically scoping down into products (tuples). To look at sums (Either) you need prisms, and all Haskell types are sums/products of types. So "optics" stands for what lenses are really supposed to do, namely giving you total data access.
23:08:40 <Twey> ski: Well, you build and decide on your ‘var’ in the binding construct, I guess
23:08:47 <edwardk> basically if you adopt the right 'pure profunctor view then you get a statement in terms of l (Procompose f g) ~ Procompose (l f) (l g)   and l id = id
23:08:50 <Twey> The problem is connecting them up
23:09:25 <edwardk> which turns all the lens laws int just functor laws for functors between appropriate sub-categories of Prof
23:09:34 <ski> hm .. perhaps you could say `Lam :: Expr (Extend typ1 env) typ1 -> Expr env (typ0 -> typ1)'
23:09:54 <edwardk> the hard part is properly describing all of those categories, but having all the laws just be functor laws? that's very handy.
23:11:58 <Twey> ski: Someone managed to implement a system in Haskell earlier where the type of a term is a function of its context
23:12:37 <ski> hm, not sure how you mean
23:12:39 <Twey> I think that's probably going a bit far for introductory pædagogical purposes, though :þ
23:13:17 * hackagebot monad-unify 0.1.0.0 - Generic first-order unification  http://hackage.haskell.org/package/monad-unify-0.1.0.0 (PhilFreeman)
23:13:23 <Twey> ski: Have you read Conor McBride's ‘Outrageous Coincidences’ paper?  I don't know where the system originally came from, but he talks about it as established wisdom at the start of that paper
23:13:42 <Twey> (and then extends it for dependent types)
23:14:44 <Twey> Instead of a typing judgement like Γ ⊢ t : T, you have a judgement like t : T where t and T are functions of [ Γ ]
23:14:47 <ski> Twey : i don't think i've read it
23:15:34 <ski> where does `Γ' come from ?
23:15:43 <ski> (some environmenty thing ?)
23:15:59 <notdan> what do you mean by "functions of [ Г ]"?
23:16:07 <Twey> Γ is the typing context, a mapping from variables to types
23:16:26 <notdan> [G] == list of [G]?
23:16:42 * ski assumes not
23:16:47 <Twey> notdan: No, ‘meaning of’ — sorry, I couldn't figure out how to type the double-bracket character on this input method :þ
23:17:25 <Twey> ⟦ Γ ⟧
23:18:18 * hackagebot purescript 0.3.6 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.6 (PhilFreeman)
23:19:23 <ski> anyway, i'd really like for a value of type `var typ' to be something "atomic", which is easy to check equality for
23:35:55 <codygman> I found this snaplet on patch-tag, how do I install snaplets manually without cabal? Here is the snaplet: http://patch-tag.com/r/mf/snaplet-file-dialog/home
23:36:13 <codygman> wait I can post this to #snap-framework..
23:38:05 <bergmark> codygman: why don't you want to use cabal?
23:39:03 <codygman> bergmark: It's not that I don't want to, just that there isn't a .cabal file there and I'm unsure of whether snaplet cabal files are different or not.
23:42:50 <bergmark> http://patch-tag.com/r/mf/snaplet-file-dialog/snapshot/current/content/pretty/snaplet-file-dialog.cabal
23:56:05 <akegalj> does anyone knows if ghc-7.8 targets arm? any link on that?
23:57:30 <makalu> how do I use a cabal sandbox with ghci?
23:57:38 <jle`> makalu: cabal repl
23:58:41 <makalu> jle`: that requires me to have a .cabal file. If I want to just experiment with a library then I have to install it globally?
23:59:04 <makalu> I mean I don't have a project, just a single .hs
23:59:18 <Feuerbach_> makalu: with cabal from git you don't need a .cabal file for cabal repl
23:59:42 <makalu> I have cabal 1.18.1 :(
23:59:52 <Feuerbach> you can install one from git
23:59:53 <makalu> cabal-install is 1.18.0.2
