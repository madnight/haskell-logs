00:00:18 <zRecursive> bye
00:04:37 <adnap> Is there a more compact version of if then else?
00:05:00 <adnap> A function like branch :: a -> a -> Bool -> a
00:07:05 <flebron> finally done with the compile-time checked avl tree insertion :) http://lpaste.net/1989195381379956736
00:07:32 <flebron> (the 17 cases were even less fun than you imagine)
00:08:36 <Polarina> adnap, you'll have to write it yourself.
00:08:37 <ChongLi> my friend is getting Prelude.head: empty list when he calls ghc-mod
00:08:47 <ChongLi> but I am not able to replicate his error
00:10:47 <ChongLi> what's the most straightforward way to debug this?
00:11:27 <Fuuzetsu> You should use the same file as him and make sure you're calling it from the same spot; it might be GhcMod bug though
00:11:36 <Polarina> ChongLi, make a standalone program that provokes this behaviour.
00:14:51 <ChongLi> Polarina: no, I mean he's calling the standalone ghc-mod application
00:15:12 <ChongLi> he's not using the library
00:15:18 <Jookia> Is there an IO monad transformer? Something to give me the type of IO Maybe a?
00:15:44 <Fuuzetsu> ChongLi: But he has to be calling it with some parameters… probably asking for a type of something on a certain line and column in a certain file
00:15:47 <epta> Jookia: IO (Maybe a) is not enough?
00:15:52 <shachaf> There is no IO monad transformer.
00:15:56 <shachaf> What is the type of IO Maybe a?
00:15:57 <Jookia> oh crap
00:16:00 <ChongLi> this is a bug within ghc-mod (likely one of its dependencies) and I am not able to replicate it, despite using the same version, same input file, same arguments etc.
00:16:06 <Jookia> I just read as I spent the past half-hour looking at this
00:16:08 <RustyShackleford> I am having a hard time grasping how to anything
00:16:10 <Fuuzetsu> if he's just doing ‘ghc-mod’ and getting this problem, it's probably a bug with ghc-mod
00:16:16 <Jookia> It occured me to try IO (Maybe a)
00:16:18 <Jookia> Damnit
00:16:20 <Jookia> Thanks guys <3
00:16:25 <RustyShackleford> this is certainly different than any code I've seen before
00:16:26 <ChongLi> he's just doing ghc-mod check Main.hs
00:16:37 <ChongLi> and I am doing the same thing on the same file
00:16:39 <shachaf> Hmm, I was about to mention MaybeT, since MaybeT IO a = IO (Maybe a)
00:16:40 <shachaf> Oh well.
00:16:47 <Fuuzetsu> *shrug*
00:18:40 * hackagebot sdl2 1.0.2 - Bindings to SDL2  http://hackage.haskell.org/package/sdl2-1.0.2 (Polarina)
00:18:41 <satc> Why is there no instance for Storable for a pair. Something like instance (Storable a,Storable b) => Storable (a,b) ??
00:21:06 <enzo_> can you stand alone derive instances of multiparameter type classes?
00:21:10 <enzo_> anyone?
00:21:19 <ChongLi> ahhh, it looks like he installed ghc-mod into our project sandbox
00:21:33 <enzo_> if so, what is the syntax?
00:21:36 <ChongLi> and it picked up an old version of one of our dependencies
00:22:02 <Polarina> satc, because the alignment of `b' may not necessarily be divisible by the sizeOf `a'. This would require padding.
00:24:08 <FliPPeh> Given a cabal project I'm developing for another cabal project, just to split up the codebases since they are unrelated until the main application uses the library, how best do I use them together in the end?
00:24:35 <FliPPeh> Say I have ~/Programs/Haskell/JSON-RPC and ~/Programs/Haskell/SomethingUsingJSONRPC
00:24:51 <FliPPeh> How do I add the former as a dependency to the latter without going all out on hackage?
00:25:01 <FliPPeh> Because that's simply not worth it for my tiny pet project
00:30:10 <ctrl> Have you voted for Haskell here? http://code2013.herokuapp.com/ It's a rating of languages programmers used in year 2013
00:31:58 <FliPPeh> Does "cabal sandbox add-source" help me here?
00:32:51 <flebron> So I have to tweet your link to vote? heh
00:32:57 <ctrl> Nope
00:33:05 <ctrl> You tweet #code2013 Haskell
00:33:22 <flebron> If I have no twitter account, I can't participate then, I assume.
00:33:24 <ctrl> (and probably other languages you like, separated)
00:33:37 <ctrl> Yes, you can't. No big deal, it's just silly statistics
00:33:38 <FliPPeh> What ever happened to good old voting on the website? :(
00:33:51 <FliPPeh> I don't like how you need social networks for EVERYTHING now
00:34:26 <ctrl> Well, it kinda makes voting not-so-anonymous so no bots can participate
00:34:35 <simpson> How are you going to prevent bots?
00:34:40 <shachaf> Is this your website?
00:34:41 <FliPPeh> Except about 70% of Twitter is bots :|
00:34:46 <ctrl> Nope, it's not mine
00:34:46 <simpson> I am seriously tempted to ballot-stuff ANS FORTH.
00:36:20 <dsrx> #code2013 MUMPS
00:37:05 <ctrl> is it even a language?
00:42:15 <awestroke> What's a good resource for learning about monad composition? For example, the ActionM type in http://hackage.haskell.org/package/scotty-0.0.1/docs/src/Web-Scotty.html seems to contain several monads that *just work* in tandem when using do notation
00:42:37 <FliPPeh> You mean monad transformers?
00:43:37 <awestroke> I have no idea what it's called
00:43:59 <awestroke> ah
00:44:00 <awestroke> thanks
00:44:07 <FliPPeh> Looks like a monad transformer alright
00:44:40 <FliPPeh> It's just a monadic computation that returns another monadic computation that returns another
00:44:47 <FliPPeh> Of course, that's the very brief nutshell
00:44:48 <shachaf> What?
00:45:35 <FliPPeh> http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
00:45:45 <FliPPeh> This is a nice introduction for *using* monad transformers
00:46:28 <FliPPeh> If you want to know how they work underneath you could have a look at a more detailed paper of look at the STM package source
00:47:17 <ctrl> Monad transformers are actually not so difficult. I understood them once I caught myself implementing one (:
00:48:07 <haasn> is the law lift (m >>= f) = lift m >>= lift . f equivalent to lift (a >> b) = lift a >> lift b ?
00:48:18 <haasn> The second obviously immediately arises from the former (and lift . return = return)
00:48:26 <FliPPeh> I know how they work, what they do and how to implement them, but for some reason my brain still goes "wat" when I try to read the basic >>= implementation for a transformer
00:49:01 <FliPPeh> Good thing I rarely need to build my own monads
00:49:11 <haasn> err, never mind that last line; I was confused about the definition of >> there
00:50:56 <haasn> it still arises, of course: lift (a >> b) = lift (a >>= const b) = lift a >>= lift . const b = lift a >>= const (lift b) = lift a >> lift b
00:51:04 <haasn> But what about the other way?
00:56:49 <shachaf> What are the laws with join rather than >>=?
00:59:42 <ChongLi> okay, so we tested a bit more
00:59:54 <haasn> lift . join . fmap f = join . fmap (lift . f) . lift
00:59:56 <haasn> Something like this?
00:59:56 <ChongLi> and ghc-mod is only crashing when run within a project that has a sandbox
01:01:33 <shachaf> That's a direct translation, yes.
01:01:45 <shachaf> Surely you can make it nicer?
01:02:07 <shachaf> E.g. lift . join == join . fmap lift . lift
01:02:09 <shachaf> Or something.
01:02:24 <haasn> by specializing ‘f’ to id that's possible, yes; I don't know if you sacrifice expressive power that way
01:03:09 <haasn> I guess it boils down to the same thing, though; binding and then lifting is the same as lifting both then binding
01:03:11 <shachaf> Well, this law makes a bit of sense -- you can join and then lift, or you can lift (inside and outside) and then join.
01:04:06 <haasn> lift is a homomorphism with respect to join and return, or something?
01:04:08 <haasn> given lift . return = return
01:04:23 <haasn> almost like.. a monad homomorphism?
01:06:13 <shachaf> I guess that's all the law there is.
01:07:20 <shachaf> There's also the secret extra law that it's a natural transformation.
01:07:45 <shachaf> But yes, it's just a monad homomorphism. OK.
01:07:49 <haasn> mmorph states ‘lift’ is a monad morphism
01:08:12 <leggo> can haskell win this cool golf challenge? probably not, but I'd be curious to see the shorter possible code. http://codegolf.stackexchange.com/questions/17005/produce-the-number-2014-without-any-numbers-in-your-source-code/17103#17103
01:09:22 <merijn> > '\2014'
01:09:23 <lambdabot>  '\2014'
01:09:26 <merijn> hmm
01:09:34 <merijn> Not what I was hoping to achieve :p
01:09:46 <merijn> > chr 2014
01:09:47 <lambdabot>  '\2014'
01:10:18 <haasn> > text "\2014" -- merijn
01:10:19 <lambdabot>  ߞ
01:13:20 <dv-> the year of the ߞ
01:13:42 <merijn> leggo: Some combination of ord and multiplication should get you there in probably less then 12 characters, assuming you don't have to print
01:15:49 <haasn> > sumOf (folded.from enum) "Happy new year to you!" -- hehe
01:15:51 <lambdabot>  2014
01:15:57 <Lethalman> :O
01:16:23 <Polarina> o.O
01:16:24 <Lethalman> awesome haasn
01:16:45 <haasn> no credit to me, I just lensified it
01:17:14 <leggo> you can't use any numbers in source, so that includes numbers inside string or character literal. and you have to print
01:18:21 <haasn> main=print$ord'ߞ' -- is the shortest I can think of
01:18:36 <haasn> oh, need a space before ' too
01:18:39 <awestroke> FliPPeh: is a monad transformer like a decorator in OO then?
01:19:05 <merijn> awestroke: No
01:19:22 <merijn> awestroke: monad transformers are more like composable monads
01:19:24 <Lethalman> awestroke, a decorator is simply composition
01:19:35 <Lethalman> yourfunc . decorator
01:19:49 <merijn> awestroke: i.e., "I wish I had a monad that could do both State, IO and something else"
01:20:21 <merijn> awestroke: Just use the State transformer and (for example) Reader transformer to add both of those to the IO monad
01:20:54 <awestroke> merijn: yeah, I get that, but then I saw the definition of MaybeT and it's just packaging a maybe inside a monad
01:21:01 <Cale> Why would you use sumOf (folded.from enum) when you could use sum . map fromEnum? (or map ord)
01:21:10 <merijn> awestroke: Well, yes
01:22:15 <maxiepoo> maybe is a monad
01:26:17 <leggo> was that a question? Maybe is a monad
01:26:41 <maxiepoo> no I was talking to awestroke
01:32:51 <funfunctor> howdy
01:33:04 <Polarina> Hi there.
01:35:25 <jose`> \leave
01:35:40 <funfunctor> jose`: /part ;)
01:43:50 * hackagebot coordinate 0.0.7 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.7 (TonyMorris)
01:45:57 <dawik> > 1+1
01:45:58 <lambdabot>  2
01:48:50 * hackagebot simple-bluetooth 0.1.0.0 - Simple Bluetooth API for Windows and Linux (bluez)  http://hackage.haskell.org/package/simple-bluetooth-0.1.0.0 (StephenBlackheath)
01:48:52 * hackagebot sphero 0.1.0.0 - Orbotix Sphero client library  http://hackage.haskell.org/package/sphero-0.1.0.0 (StephenBlackheath)
01:52:41 <Polarina> How can I see why haddock documentation on hackage is not being generated?
02:08:34 <awestroke> maxiepoo: I know that, but what I said is still true, even if it can be generalized to "MaybeT is just packaging a monad inside another monad"
02:09:40 <maxiepoo> oh and that's what decorators are like?
02:11:21 <awestroke> the decorator pattern I've learned is making a class that keeps a reference to an object of another class and acts as a proxy, as an alternative to subclassing
02:11:24 <ivanm> Cale: you pinged me before?
02:12:06 <FliPPeh> Decoraters are just classes that wrap more classes of a common type
02:12:06 <Cale> ivanm: erisco is playing with graph representations, I mentioned you'd be a good person to talk to maybe
02:12:26 <FliPPeh> The famous example is Coffee wrapped inside a Milk wrapped inside a Sugar so you get a Coffee with Milk and Sugar
02:12:30 <ivanm> ahhh
02:12:37 <ivanm> yeah, I've got some I was working on, but I burnt out
02:12:48 <FliPPeh> And getPrice() calls Milk.getPrice, Milk.getPrice then calls Coffee.getPrice and they all get added together
02:12:54 <ivanm> trying to get the underlying container library for it working first was a PITA :s
02:12:55 <FliPPeh> Fairly disgusting pattern if you ask me
02:13:36 <FliPPeh> But that's apparently what the OO folks like to do
02:14:45 <ocharles> FliPPeh: No, that's an anti-pattern in OO too
02:14:57 <ocharles> Somewhat, anyway
02:15:28 <Cale> ivanm: He's playing around with all sorts of tying-the-knot sorts of representations which I usually couldn't be bothered with ;)
02:16:32 <FliPPeh> ocharles: It is, but it's still being taught as a good thing to do
02:16:45 <FliPPeh> At least I was not 2 years ago
02:17:02 <FliPPeh> Gang of Four nonsense
02:19:38 <Dodek> funny how oo world evolves. inheritance used to be the crux of oop, now it's discouraged.
02:19:50 <ivanm> Cale: ahhhh
02:20:03 <FliPPeh> Discouraged in certain circles
02:20:16 <FliPPeh> Namely the critical thinking circles
02:20:21 <ivanm> nah, I'm playing with having a way of letting the user choose whether to have Map, IntMap, Vector and hopefully even MVector (to run it in ST and thus improve performance)
02:21:10 <FliPPeh> Because sadly the vast majority of programmers learns what they have to learn to pass university or college, go to work and never inquire about better ways to solve the usual programming problems
02:21:19 <Cale> ivanm: Yeah, I'm pretty firmly in the camp of "just represent the adjacencies somehow explicitly"
02:23:10 <ivanm> definitely works a lot easier
02:23:56 <ivanm> though this C code I'm meant to be playing with represents planar graphs where nodes are pointers to an arbitrary edge adjacent to it :s
02:24:07 <ivanm> (makes it a lot more performant, but a PITA to debug!)
02:24:37 <nisstyre> ivanm: hmm, isn't there a more efficient and easier to work with representation of planar graphs?
02:24:54 <danilo2> Hello! :) Is it possible (probably it is, but does anybody know how?) to create lenses manually? I've got data structure data X = X Int String and I want now (not in declaration) create named lens for first and second element. So I would be able to eval: (x^.myfirstelement) ?
02:25:53 <FliPPeh> While records are certainly not the best design choice in Haskell, what's wrong with data X = X { firstElem :: Int, secondElem :: String }?
02:26:45 <Cale> FliPPeh: nothing
02:27:08 <ChongLi> okay this is really disconcerting
02:27:14 <FliPPeh> Cale: I meant that as an alternative to danilo2's question :)
02:27:15 <ChongLi> I'm trying to debug GhcMod
02:27:18 <Cale> ah
02:27:21 <ChongLi> but I keep getting this error
02:28:31 <ChongLi> http://lpaste.net/97865
02:28:55 <supki> danilo2: sure, see the implementation of  lens  function in  Control.Lens.Lens
02:29:01 <FliPPeh> At least GHC is apologizing :(
02:29:39 <danilo2> supki: thank you :)
02:29:43 <edwardk> danilo2: secondElement f (X a b) = X a <$> f b
02:29:59 <edwardk> firstElement f (X a b) = (`X` b) <$> f a
02:30:58 <ChongLi> edwardk: hey, how do I debug a Error:Prelude.head: empty list without using ghci's debugger?
02:31:29 <Cale> ChongLi: Find all the occurrences of head in your code and replace them with (\(x:xs) -> x)
02:31:43 <ChongLi> well, it's not my code
02:31:45 <edwardk> ChongLi: i usually start by not calling it ;)
02:31:59 <ChongLi> it's part of GhcMod
02:32:03 <Cale> You'll get a pattern match failure message that gives the line number
02:32:06 <FliPPeh> Afterwards you build safeHead :: [a] -> Maybe a and be happy!
02:32:19 <Cale> Well, probably just use case
02:32:22 <Cale> Or something
02:33:33 <jtcwang> do you guys integrate vim with ghci?
02:33:37 <Cale> I don't
02:33:41 <jtcwang> so you have it in the same buffer etc
02:33:41 <FliPPeh> Nah
02:33:48 <PTBD> hello. How would I read n times the input from a user? I tryed like this http://pastie.org/private/zxbodot95gmscfcu6l78zw but it doesn't work
02:33:56 <Cale> I run them in entirely separate windows
02:34:21 <FliPPeh> PTBD: You could use sequence
02:34:22 <jtcwang> Cale, for my application it prints quite a lot of stuff in one go so i lose them..
02:34:26 <Cale> PTBD: replicateM n readLn
02:34:37 <FliPPeh> sequence (repeat n readLn)
02:34:39 <Cale> :t replicateM
02:34:40 <lambdabot> Monad m => Int -> m a -> m [a]
02:34:42 <PTBD> Cale, also tryed that, doesn't work too
02:34:43 <FliPPeh> Meh
02:35:09 <Cale> PTBD: Well, your problem then will be that it doesn't know which type to read, I suspect, given that code.
02:35:44 <Cale> jtcwang: What do you lose?
02:35:55 <jtcwang> part of my printouts etc
02:36:17 <jtcwang> cuz i'm doing a simulation
02:36:19 <Cale> oh, maybe just compile the program and use your shell to redirect its output to a file?
02:36:20 <PTBD> Cale, I don't know how to tell him in this example. I know for one number it is just: n <- readLn :: IO Int.
02:36:35 <PTBD> FliPPeh, thanks, I'll take a look what it is
02:36:35 <Cale> Or just make the program write to a file?
02:36:45 <jtcwang> Cale, that'd work but it makes the REPL quite slow
02:36:45 <FliPPeh> PTBD: replicateM is the better approch tho!
02:36:52 <FliPPeh> Mine's silly
02:36:52 <Cale> replicateM n (readLn :: IO Int) would work
02:37:05 <Cale> FliPPeh: Also, you did mean replicate rather than repeat
02:37:12 <FliPPeh> Yes!
02:37:21 <FliPPeh> :t replicateM 4 (readLn :: IO Int)
02:37:22 <lambdabot> IO [Int]
02:37:30 <Cale> But yeah, sequence is the missing piece of the puzzle from PTBD's original code
02:37:56 <Cale> it just happens that there's a good name already for  sequence (replicate n x) :)
02:38:03 <klrr> i get a *really* strange problem, i use Data.Text.Lazy and then it says it cant find the package but its in the cabal file and its installed     css-text-0.1.1
02:38:07 <klrr>     shakespeare-text-1.0.0.6
02:38:14 <klrr> ups pasted by mistake sry
02:38:22 <klrr> https://gist.github.com/klrr/8217423 <- any ideas?
02:38:43 <PTBD> Cale, thank you. no errors compiling but the print at the and (print num) ist empty: ()
02:38:57 <Cale> klrr: Check that you don't have two separate versions installed.
02:39:05 <FliPPeh> () or []=
02:39:07 <FliPPeh> ?*
02:39:07 <lambdabot> Maybe you meant: v @ ? .
02:39:12 <klrr> Cale: i provide that information in the paste
02:39:14 <FliPPeh> No lambdabot
02:39:19 <klrr> i only got the questioned version installed
02:39:28 <PTBD> ()
02:39:39 <FliPPeh> PTBD: Did you use replicateM or replicateM_?
02:39:44 <PTBD> reaplicateM_
02:39:53 <FliPPeh> That one discards its result
02:40:15 <PTBD> FliPPeh, duh, ok. that's confusing but it works now :)
02:40:19 <klrr> Cale: the weird thing is when i just import "import qualified Data.Text as T
02:40:26 <klrr> " it finds the text package
02:40:28 <FliPPeh> It's useful when you just want the side effects
02:40:32 <klrr> but when i use Data.Text.Lazy it doesnt
02:40:53 <FliPPeh> Because replicateM 4 [putStrLn "asdf", ...] will return you [(),(),(),()] which is not terribly useful
02:41:01 <FliPPeh> Because you just wanted those prints
02:41:13 <PTBD> FliPPeh, Cale, thank you. :)
02:41:21 <Cale> No problem!
02:41:24 <Cale> klrr: hmm
02:42:37 <klrr> Cale: wait, it must be some other problem, now it doesnt find System.Directory either although its specified in cabal file
02:43:02 <Cale> Interesting
02:44:04 <danilo2> Just one more question :) Is it possible to put recursive data structures in separate files? I want them to have the same field names (with generated lenses)
02:45:14 <Cale> You mean mutually recursive?
02:46:24 <Cale> I wouldn't bother defining them with the same field names if you're just going to make lenses for them anyway. There's a version of makeLenses which takes a list of the names to use, iirc.
02:46:50 <Cale> Yeah, makeLensesFor
02:47:28 <Cale> (also, makeClassyFor)
02:47:51 <danilo2> Cale: hmm, makeLensesFor could solve my problem. I want them to have the same names, because I will call them by qualified name
02:48:33 <jtcwang> Cale, i figured a way out to get ghci to work in vim using conqueterm
02:48:36 <jtcwang> not bad atm
02:48:59 <Fylwind> sometimes I find myself writing complicated foldl' expressions like: foldl' (\(x, z) -> ...) z0, where "z" is a tuple of some kind; is there a more idiomatic way of rewriting these kinds of processes?
02:49:03 <FliPPeh> Sooo, anyone here has experience with Data.Aeson?
02:49:34 <FliPPeh> Apparently it will not decode singleton objects like numbers and strings or booleans if they're on their own instead of in an object
02:49:40 <FliPPeh> It's silly, but is it a bug?
02:49:42 <Fylwind> in imperative I would write something like: z = z0; for (...) { mutate z in some way }
02:50:09 <FliPPeh> Because "4" and "true" are still valid JSON documents as far as I know, they don't have to be rooted in an array or object
02:52:35 <Cale> Fylwind: It depends on what you're computing.
02:52:59 <ChongLi> hmm
02:52:59 <Cale> Certainly, foldl' can be the right thing sometimes
02:53:06 <ChongLi> cabal.sandbox.config is rife with absolute paths
02:53:44 <ChongLi> so we figured out the offending file: cabal.sandbox.config
02:53:53 <ChongLi> but can't quite figure out why the error is happening
02:53:56 <quicksilver> FliPPeh: JSON was widely used before being standardised. The ECMA standard for JSON has no notion of document and nothing which would exclude your interpretation.
02:53:58 * hackagebot coordinate 0.0.8 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.8 (TonyMorris)
02:54:12 <quicksilver> FliPPeh: however, RFC4627 is clear that a JSON 'text' must be either array or object.
02:54:15 <quicksilver> FliPPeh: http://www.ietf.org/rfc/rfc4627.txt
02:54:20 <ChongLi> oh wait
02:54:26 <ChongLi> I think I might know
02:54:45 <ChongLi> a *space* in the path!
02:54:47 <FliPPeh> quicksilver: Oh wow, you learn something new every day
02:54:49 <FliPPeh> Thanks!
02:57:10 <ChongLi> yeah, here we go
02:57:27 <ChongLi> the space in the path caused the arg-parsing to fail somewhere
02:57:30 <Fylwind> well here's what i'm doing, I have this Map and I'm using fold to [P and F are some fixed functions]: check if P(x) is true; if so, append f(x) to a list (which is initially empty); if not, append x to a Map (also initially empty)
02:57:45 <ChongLi> and then an empty list of files had head called on it
02:59:57 <danilo2> Hmm is it possible to create mutually recursive data types when -XTemplateHaskell is enabled? It seems like it is impossible - am I right?
03:01:14 <quicksilver> danilo2: you can't create them using separate splices or putting splices between them, because they linearises things.
03:01:40 <quicksilver> I thought it was fine if the two data types don't contain any splices though?
03:02:55 <danilo2> quicksilver: ahh, that is the reason for the error - thank you - I've got splices between them
03:03:43 <quicksilver> it may keep you saner to put the TH-independent data types in a seperate module
03:03:48 <quicksilver> but it's not required.
03:03:59 <quicksilver> sanity is overrated and not correlated with good haskell programming.
03:04:21 <jtcwang> a spark of insanity goes a long way
03:25:50 <durm_> hi guys! if I create a new module with new data type like data Site {name, desc} and import new data type in another module will functions (name, desc) be import automatically??
03:27:44 <durm_> hi guys! if I create a new module with new data type like data Site {name, desc} and import new data type in another module will functions (name, desc) be import automatically??
03:29:02 * hackagebot geodetic 0.1.0 - Geodetic calculations  http://hackage.haskell.org/package/geodetic-0.1.0 (TonyMorris)
03:29:34 <donri> durm_: only if you do one of: import Module, import Module (Site(..)), import Module (Site(name,desc))
03:29:58 <donri> durm_: or you can do import qualified Module as Mod, and then Mod.Site, Mod.name...
03:30:30 <ChongLi> or even just import qualified Module and then Module.Site
03:30:50 <ChongLi> and even a mix of the two
03:31:11 <durm_> ooo thank you
03:31:48 <ChongLi> it would be nice if there was a way to import only the type constructors from a module
03:32:04 <ChongLi> so you could import that type constructors unqualified and the functions qualified
03:33:14 <ChongLi> or just all type and data constructors but not functions
03:33:28 <ChongLi> since it's usually only the functions that clash
03:34:02 * hackagebot nimber 0.1.3 - Finite nimber arithmetic  http://hackage.haskell.org/package/nimber-0.1.3 (AndersKaseorg)
03:35:21 <awestroke> ChongLi: import qualified Module; import Module (Constructor1, Constructor2, ...)
03:35:25 <awestroke> is that possible?
03:35:38 <ChongLi> sure, but the number of constructors is staggering
03:35:39 <ChongLi> hundreds
03:35:46 <awestroke> ah
03:36:31 <awestroke> Well, you could just to "import qualified Module; import Module" and always reference the functions qualified
03:36:40 <awestroke> do*
03:36:47 <ChongLi> ah, that's very true
03:36:57 <Fylwind> what about name clashes though?
03:37:04 <ChongLi> I deal with em
03:37:17 <ChongLi> Flycheck is pretty good at catching those
03:37:37 <ChongLi> oh, I guess you're right
03:37:46 <ChongLi> the problem is not with name clashes from Module
03:38:00 <ChongLi> it is the other side of the clash
03:38:07 <ChongLi> i.e. everything else
03:38:52 <Cale> I would be somewhat worried about cases where my datatypes had hundreds of constructors or hundreds of fields
03:39:13 <ChongLi> Cale: no, this is hundreds of different data types
03:39:17 <donri> doesn't haskell allow clashes as long as you don't use the clashing names?
03:39:18 <ChongLi> OpenGL
03:39:21 <Cale> ah
03:39:21 <donri> i forgot
03:39:42 <ChongLi> yeah clashes lurk silently until you invoke their names
03:39:56 <donri> awestroke: btw that's the same as just import Module, and you can do import Module as Mod also
03:40:58 <donri> :t Prelude.id
03:40:59 <lambdabot> a -> a
03:41:20 <ivanm> nisstyre: seeing as how this particular program is meant to be one of the most efficient ones around at generating planar graphs... I doubt it :/
03:41:45 <ChongLi> donri: my main complaint is dealing with long top-level type signatures
03:42:06 <ChongLi> it's just so annoying having to qualify them all, since ghc-mod doesn't qualify the templates it inserts
03:42:32 <donri> ChongLi: agreed. i also wish there was syntax for importing internals so we didn't need .Internal modules. but similarly, some packages provide .Types modules exporting only types
03:42:57 <ChongLi> yeah
03:43:05 <donri> although sometimes that's just the place where all types are defined, including term-level constructors and fields...
03:43:43 <ChongLi> maybe I should check out Agda some more
03:43:48 <donri> (:
03:44:07 <ChongLi> doesn't it allow overloaded record names?
03:44:11 <donri> in general i just wish the module system didn't suck :P
03:44:25 <ChongLi> seems like it'd be trivial to do with dependent tyeps
03:44:29 <donri> duno agda, but i imagine it might resolve based on types
03:44:43 <donri> i don't think it's about dependent types, rather the lack of type inference
03:44:55 <ChongLi> what? agda is loaded with inference
03:45:15 <ChongLi> it just doesn't infer top-level type signatures
03:45:19 <donri> exactly
03:45:33 <ChongLi> you write the top-level type signature first
03:45:43 <ChongLi> and then agda pretty much infers the entire function for you
03:46:11 <donri> plus it doesn't have type classes
03:46:30 <ChongLi> whenever it can't infer that, you're immediately reminded that your type is probably not refined enough
03:46:45 <donri> given top-level type signatures and no type classes it's easier to infer namespace based on type
03:46:59 <ChongLi> there's lots of work using inferred implicits to replace type classes in agda
03:47:14 <jle`> it might be because it's almost 4am, but is there a sortByM? where the comparison function is a monadic action returning a value in a monad?
03:47:18 <donri> given type inference with type classes, you sort of need the user to resolve the names so you can infer the types based on those names
03:47:34 <ChongLi> and all data contructors in agda are automatically overloaded
03:48:01 <aristid> ChongLi: last time i tried to use these type class replacement implicits in agda they were severely limited
03:48:08 <jle`> sortByM :: Monad m => (a -> a -> m Ordering) -> [a] -> m [a]
03:48:11 <ChongLi> aristid: oh yeah?
03:48:49 <donri> i'm not trying to make a point about agda being limited. i'm saying it's easier to resolve names based on types when you don't first have to resolve types based on names.
03:49:00 <ChongLi> yeah
03:49:12 <ChongLi> agda made the decision to do only one form of inference
03:49:20 <donri> of course ambiguity can always arise in both haskell and i imagine agda anyway
03:49:27 <ChongLi> that is, inferring the details given a plan
03:49:39 <aristid> ChongLi: there are two kinds of implicits in agda
03:49:40 <ChongLi> inferring a plan from a few of the details is much harder
03:49:46 <aristid> with different inference rules
03:49:56 <aristid> normal implicits don't have any special rules actually
03:50:02 <aristid> but i think the {{}} implicits do
03:50:26 <ChongLi> ahh, I wasn't aware of the other form of implicits
03:50:35 <ChongLi> only the ones denoted by braces
03:50:49 <aristid> the {{}} ones are the ones that can kind-of-sort-of replace type classes
03:51:02 <donri> but i imagine if you tried to do haskell's type inference combined with full type-directed name resolution (without special syntax as in the TDNR proposal), you'd very easily trigger insanely long and obfuscated compiler errors :P
03:51:06 <aristid> i forgot the name though:D
03:51:23 <ChongLi> yeah, just as how you can manually translate haskell type classes into an extra argument
03:51:24 <dmisback> any ideas on how one would get a list of local minimums and maximums of a list of ints in Haskell?
03:51:26 <ChongLi> and pass it around
03:51:53 <maxs`> dmisback: fold
03:53:05 <Hafydd> What are the local maxima of [0,1,1,1,0]?
03:53:05 <dmisback> I guess it's not a haskell specific question. What algorithm would one use to determine that certain point on a graph is a local minimum or maximum
03:53:10 <ChongLi> > map (minimum &&& maximum) [[1,4,2],[4,6,3]]
03:53:12 <lambdabot>  [(1,4),(3,6)]
03:53:43 <quicksilver> you just run along the list looking for changes in direction
03:54:03 <quicksilver> but you have to make some decisions about whether or not you report inflections and how you report multi-point maxima
03:54:07 <dmisback> I'm guessing there needs to be some kind of "weight" factor. As in how much direction is interpreted as a max/min
03:54:08 <quicksilver> [0,1,1,1,2]
03:54:10 <FliPPeh> :t (&&&)
03:54:11 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
03:54:15 <ChongLi> dmisback: does my solution help?
03:54:18 <Twisol> personally would try a zipWith or some such to get a list of (i-1, i, i+1) and grab i whenever appropriate
03:54:29 <Twisol> where i-1 for the beginning is 0, and i+1 for the end is 0
03:55:37 <ChongLi> dmisback: so you're looking for absolute changes in direction?
03:56:01 <zett_zelett1> How do Haskellers feel about scala?
03:56:16 <dmisback> Basically imagine a sine wave, but the tops and bottoms are not always at the same level. so a wonky sine wave. sometimes it's a bigger peak, sometimes it's smaller
03:56:22 <FliPPeh> Boo JVM
03:56:29 <ChongLi> zett_zelett1: edwardk had a lot of issues with it
03:56:39 <ChongLi> zett_zelett1: I'm trying to digg up his reddit post
03:56:40 <donri> zett_zelett1: my impression from others have been that they think it's good enough that they try to do things like monads in scala only to realize it's not *quite* good *enough*
03:56:43 <dmisback> would want to know at which point in time (t) each peak has happened
03:57:24 <maxs`> scala is interesting
03:57:29 <ChongLi> dmisback: and your list of values is a bunch of samples?
03:57:45 <dmisback> ChongLi: yes
03:57:47 <maxs`> its typed fp but with a subtype relation
03:57:55 <zett_zelett1> Do I need to know who edwardk is other than someone in this channel?
03:58:15 <Twisol> He's a well-known Haskeller. Prolific library writer. Made lens.
03:58:16 <donri> zett_zelett1: edwardk is the author of 50% of hackage ;)
03:58:16 <awestroke> Why is there separate exponentiation operators (^, ^^, **) for different types (Num, Fractional, Float) rather than a typeclass Exponentiable the ^ method for Num, Fractional and Float to implement?
03:58:29 <zett_zelett1> Ah, okay.
03:58:39 <Fylwind> if the data has noise in it you'll need to do some smoothing to make it work
03:58:41 <donri> the rest is 25% dons 25% bos :D
03:58:54 <FliPPeh> We already have too many typeclasses for numbers
03:58:56 <FliPPeh> Let's not add more
03:59:18 <maxs`> scala has type lambdas and path dependent types. two things haskell can't have.
03:59:30 <donri> (not really. loads of productive people who deserve a mention but hey it's a joke.)
04:00:36 <edwardk> maxs`: the difference is for some reason some folks in scala seem to think those are good ideas ;)
04:00:52 <maxs`> heh yup :P
04:01:21 <merijn> Does anyone know of a minimal, hackable functional language?
04:01:29 <FliPPeh> Scheme probably
04:01:31 <edwardk> the path dependent type thing is kind of interesting, but if you look at what doesn't work in their compiler, pretty much most of it centers around those two features =P
04:01:37 <ChongLi> well, some of those ideas may be good, but it seems like the JVM is a very difficult place for them
04:01:43 <merijn> FliPPeh: Hindley-Milner style FP
04:01:47 <edwardk> merijn: i'd go with scheme as well
04:01:48 <edwardk> oh
04:01:57 <ChongLi> like the implicits thing
04:02:16 <merijn> I want to experiment with some type system things, but I feel that hacking GHC directly might be a bit too cumbersome/intimidating
04:02:21 <ChongLi> I would say implicits make a lot more sense in agda than they do in scala, but that's just my gut feeling
04:02:34 <donri> merijn: idris?
04:02:52 <merijn> i.e. adding a simple per-thread GC to the GHC runtime seems a rather daunting task
04:02:54 <edwardk> merijn: the easiest system i know to get your head around that isn't a toy is something like HMF from daan leijen
04:03:17 <merijn> edwardk: I'd actually be ok with a toy language, provided it's a semi-serious toy
04:03:30 <edwardk> merijn: he has two versions of it up on his MSR page IIRC, one implemented in a straightforward way, one with mutable references to do unification
04:03:36 <merijn> edwardk: i.e. just a minimal runtime and compiler that I can easily extend as a proof-of-concept
04:03:44 <edwardk> merijn: well, it is a toy, it is just one that can be extended to rank-n types ;)
04:03:53 <edwardk> is is just a type checker though
04:03:57 <ezyang> merijn: Well, that's daunting not so much because of GHC, but becausconcurrent GC is hard
04:04:01 <merijn> donri: I feel Idris is not likely to be less intimidating/complex than GHC
04:04:09 <edwardk> depends on what you are looking for as a starting point
04:04:15 <donri> wasn't there a haskell compiler emphasising hackability / code quality of compiler
04:04:49 <donri> merijn: well it's easier to (re)compile idris itself and it's more modern haskell code than ghc
04:04:50 <merijn> ezyang: Well, I don't want to do concurrent GC, or rather I want to eliminate the notion of a shared heap :)
04:04:55 <donri> but i duno either
04:05:17 <merijn> ezyang: concurrent GC with no sharing is trivial, it's just N times non-concurrent GC
04:05:19 <ezyang> merijn: Hack on Rust then? ;)
04:06:27 <ChongLi> merijn: isn't that basically erlang?
04:06:44 <merijn> ezyang: I and some colleagues have some ideas/interest in a NUMA Haskell, but as I said I don't feel doing that directly in GHC in my spare time will work out
04:06:59 <ChongLi> is there anything like Erlang with hindley-milner and ML-style syntax?
04:07:20 <merijn> ezyang: Although, if you know of any "guided tour of the GHC runtime system" I'd be interested in knowing about that too :)
04:07:35 <merijn> ChongLi: In the same way that haskell is "basically erlang", yes
04:07:50 <ezyang> merijn: Well, we've been working on a JFP submission which is basically that
04:07:56 <ChongLi> merijn: right, but there are major social differences
04:08:14 <merijn> ChongLi: And major technical differences :)
04:08:20 <ezyang> But you're right, working with something like the GHC RTS is a lot of work. The benefit is that people can start using it immediately
04:08:28 <ChongLi> right, but technical differences can change
04:08:35 <ChongLi> social differences are much more intractable
04:08:56 <merijn> ezyang: I'd be interested in hearing about that submission
04:09:04 <ChongLi> there are tons of obsolete assumptions built into the libraries of many old languages
04:09:30 <ChongLi> this is one of the reasons I find programming languages so fascinating
04:09:46 <allsystemsarego> does anyone have a rough cut ETA for GA of GHC 7.8?
04:10:05 <ChongLi> the initial conditions of a language (its restrictions, usually) have a dramatic impact on the evolution of its community and libraries
04:10:11 <ChongLi> take Haskell, for example
04:10:27 <ChongLi> laziness had a *profound* impact on everything
04:10:53 <ChongLi> I forget who said this
04:11:05 <ezyang> http://web.mit.edu/~ezyang/Public/jfp-ghc-rts.pdf
04:11:08 <ezyang> draft copy
04:11:33 <ChongLi> but without laziness, it's difficult for a community to hold to the purity ideal
04:12:06 <ezyang> it needs to cook quite a bit more
04:12:11 <merijn> ezyang: Thanks
04:13:04 <ChongLi> dmisback: okay, any luck?
04:14:02 <merijn> ezyang: Can I ask your opinion on something? Part of these questions come from a discussion I had with colleagues, they working on SAC and one of them is implementing a type system for memory layout of their arrays, causing them have such as "layout polymorphism" and otherwise verifying that different bits of code work on compatible layouts
04:15:13 <merijn> ezyang: I've personally looked at GHC scaling on multicores which, in 7.6, was abysmal above 10 or so cores and the idea arose of tagging values as belonging to a specific GC domain (i.e. per-capability GC) with explicit hand-offs between domains, eliminating the need for a global GC stop.
04:15:58 <merijn> ezyang: From there we sorta got into a discussion on why languages only have a single type system, i.e. why not have separate types for layout, GC domains, laziness/strictness and even more
04:16:54 <merijn> So one thing I've been brainstorming on is what it'd look like to just type the AST in multiple orthogonal passes, rather than trying to stuff every bit of info into a single type system (as some people like me are wont to do in haskell's type system)
04:18:28 <ezyang> And you're wondering how good an idea this is?
04:19:03 <merijn> ezyang: Both how good an idea that is and whether other people have considered it before
04:19:37 <Jookia> How would I chain IO (Maybe a) ?
04:19:46 <jle`> Jookia: example?
04:20:02 <merijn> I've looked around and found some things that seem slightly related (e.g. "pluggable type systems", where people can write their own typing judgements and the IDE checks them), but nothing quite like a language designed with this idea in mind
04:20:14 <Jookia> jle`: http://sprunge.us/AFHE
04:20:15 <merijn> Jookia: You probably want to look at the MaybeT transformer?
04:20:20 <merijn> @mtl MaybeT IO a
04:20:20 <lambdabot> Maybe you meant: url unmtl pl msg
04:20:24 <merijn> eh
04:20:26 <merijn> @unmtl MaybeT IO a
04:20:26 <lambdabot> IO (Maybe a)
04:20:41 <Jookia> The maybe is affected by the IO monad
04:20:55 <jle`> if you want to be able to do IO stuff while inside a Maybe
04:20:59 <Jookia> So I kinda wanna 'bind' in to the IO monad, do maybe monad stuff, then return it?
04:20:59 <jle`> then MaybeT IO is your man
04:21:03 <ezyang> It's pretty difficult to say for something as general as "extensible type system"
04:21:12 <merijn> Jookia: "MaybeT IO a" combines the bind of both IO and Maybe
04:21:26 <merijn> Jookia: Sounds like it's exactly what you want
04:21:57 <ezyang> It's a very alluring goal, but many people would say that you should first figure out how you'd achieve it in some concrete cases, before attempting to generalize
04:22:17 <Jookia> I had problems with MaybeT, but I'll see. Quick question: Doesn't that imply that it returns a `Maybe (IO a)' instead of `IO (Maybe a)'?
04:22:47 <merijn> ezyang: Yeah, hence my earlier questions on what would be a simple functional language to hack :)
04:22:49 <ezyang> So let's take GC domains as an example, because people have been workin on that
04:23:06 <merijn> Jookia: No, see the earlier unmtl
04:23:11 <merijn> @unmtl MaybeT IO a
04:23:12 <lambdabot> IO (Maybe a)
04:23:13 <Jookia> unmtl?
04:23:15 <jle`> Jookia: Maybe (IO a) is different than MaybeT IO a
04:23:19 <ezyang> The current thinking seems to be that you want to achieve this with a linear type system
04:23:20 <Jookia> What's mtl?
04:23:28 <FliPPeh> monad transformer library
04:23:30 <merijn> Jookia: mtl is the Monad Transformer Library
04:23:56 <merijn> Jookia: unmtl is a lambdabot command that "decodes" monad transformer stacks from mtl into "real" types
04:23:59 <Jookia> Ah
04:24:03 <ezyang> So the development of the field proceeded along the lines of "study linear type systems", "figure out how to combine linear types with normal types", "figure out how to actually make this nice to program in"
04:25:13 <merijn> This is the umpteenth time I run into linear type systems, I need to read up on those...
04:25:18 <ezyang> Here, the addition of linearity is a very fundamental change to your type system (really a generalization, actually), so it's hard to imagine a framework that would have given you this generalization for free
04:25:43 <maurer> ezyang: I'm surprised that for an actual programming language you want a linear system instead of an affine system
04:25:45 <ezyang> merijn: I like this tutorial: http://lambda-the-ultimate.org/node/3581
04:26:08 <ezyang> maurer: I'm using terminology interchangeably here ^_^
04:26:44 <ezyang> OK, let's take your other example, fancy types for layout
04:26:55 <ezyang> Also something people have looked into
04:27:24 <ezyang> Here is one school of thought: if you have a dependently typed language, you can do anything you could possibly want in the type system: the sky's the limit
04:27:47 <ezyang> So the answer to, "I want my type system to do lots of orthogonal things" is, "use a dependent type system"
04:27:55 <ezyang> Idris is pursuing the realization of this dream
04:28:45 <maurer> ezyang: I mean, affine and linear are fundamentally different, and ther would be some rare cases wher eyou might want linear
04:28:59 <maurer> ezyang: For example, if you used linear types to describe file handles, that might be superior to affine types
04:29:08 <maurer> ezyang: As it would guarantee that they were destroyed somehow
04:29:10 <merijn> ezyang: Part of the idea actually followed from how awful some signatures in dependently typed languages look because people are trying to stuff all the orthogonal things into one type
04:29:43 <ezyang> On the other hand, dependent types are pretty hard to use, and have been for a long time, and probably will continue to be for more years from now. So another school of thought is, "Use dependent types as inspiration, but special-case for your domains, to make it more programmable." the example I'm most familiar of this mantra is Ur/Web, but there are plenty of others
04:30:19 <ezyang> maurer: I mean, I'm just generally talking about substructural systems. I don't think the distinction is relaly relevant for the discussion here
04:30:25 <maurer> OK
04:30:38 <merijn> ezyang: Although I find the idea that Ur/Web is "more programming" mildly amusing :) I've looked at it and love the idea, but I don't think it's possible to invent a more intimidating syntax :)
04:30:50 <ezyang> merijn: But that's not fundamental, there are plenty of ways to do abstraction
04:30:57 <merijn> ezyang: Sure :)
04:31:12 <ezyang> As an example, consider McBride's ornaments, or the most recent paper on type theory in color
04:31:27 <ChongLi> yeah, I need to read about ornaments
04:32:12 <merijn> How readable is it? I'm *still* struggling with View from the Left >.>
04:32:36 <ChongLi> as an aside, isn't it interesting how our struggles with abstraction (specifically, naming) in programming are mirrored in English?
04:32:51 <ezyang> I have not properly read the ornaments paper, I just know enough about it to know what it's working towards
04:33:31 <ChongLi> the fundamental challenge of abstraction is making a name and its semantics interchangeable
04:33:52 <ezyang> Or, let's consider laziness and strictness
04:34:03 <ChongLi> not just in terms of referential transparency, but in terms of understanding
04:34:38 <ChongLi> one of the most common complaints I see about Haskell is that the *word* monad is strange and frightening
04:34:59 <ChongLi> they say that the word does not describe what it means
04:35:00 <ezyang> The impression I've gotten is that the literature is quite weak (there are some very interesting systems, e.g. projection analysis), in no small part due to the fact that outside of Haskell, no one really likes Haskell
04:35:26 <ezyang> *laziness
04:35:33 <ezyang> slip of the tongue
04:36:03 <ChongLi> yeah, this goes back to my early point about social evolution
04:36:14 <ChongLi> laziness forced the Haskell community to evolve in a particular way
04:36:26 <ezyang> And we're still developing techniques for talking about laziness and partiality in the laboratories of proof-assistants like Coq
04:36:29 <ChongLi> specifically, to make evaluation-order-robustness a top priority
04:36:56 <ChongLi> and this has given Haskell a lot of benefits that are now unrelated to laziness
04:38:19 <erisco> I did not get the message someone sent me
04:38:22 <ezyang> Let me point another line of work: "Using Programmer-Written Compiler Extensions to Catch Security Holes", Dawson Engler
04:38:37 <ChongLi> nice
04:39:05 <ChongLi> Ken Ashcraft?
04:39:09 <ezyang> In this paper, Dawson and Ken suggested that an important way forward would be for software writers to develop custom static analyses passes, to catch domain-specific security vulnerabilities
04:39:10 <ezyang> yep
04:39:34 <ChongLi> that's really cool
04:39:49 <ChongLi> and perhaps that idea could be stacked in layers
04:39:52 <merijn> ezyang: Oh, that's a good one. Too bad it's to late to cite that now
04:39:52 <ezyang> This never really caught on. But the analysis passes that you might have written for a system like that would compose in the way that you would have liked. Of course, it's not a type system.
04:40:19 <Jookia> MaybeT why are you so confusing
04:40:26 <ChongLi> so that userspace programming would be a subdomain of general programming, with its own static analyses
04:40:38 <ezyang> I think user-written dataflow passes are still a good idea, and the primary barrier that needs to be overcome is one of education and transparency
04:40:58 <ChongLi> and legacy codebases
04:41:01 <merijn> Jookia: It takes a while of playing around with transformers before they become intuitive
04:41:23 <Jookia> But I don't want to play around with transformers, I want to be able to write this :(
04:41:30 <ezyang> So there you go. Taken individually, each of the orthogonal considerations are things people have thought about. (Given any good idea, someone has probably thought about it before)
04:41:54 <Jookia> I can't use IO in MaybeT because it's not a Maybe :\
04:42:10 <jle`> Jookia: liftIO :)
04:42:11 <merijn> Jookia: That last remark makes no sense to me?
04:42:23 <merijn> Jookia: Ah, yes, you want to use lift/liftIO
04:42:25 <merijn> :t lift
04:42:25 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
04:42:27 <ezyang> But there doesn't seem to be any good starting point for assembling the mess together.
04:42:45 <merijn> :t lift (return () :: IO ()) :: MaybteT IO ()
04:42:46 <lambdabot>     Not in scope: type constructor or class `MaybteT'
04:42:46 <lambdabot>     Perhaps you meant `Maybe' (imported from Data.Maybe)
04:42:51 <merijn> :t lift (return () :: IO ()) :: MaybeT IO ()
04:42:52 <lambdabot>     Not in scope: type constructor or class `MaybeT'
04:42:52 <lambdabot>     Perhaps you meant `Maybe' (imported from Data.Maybe)
04:42:55 <merijn> awww
04:43:04 <merijn> :t lift (return () :: IO ()) :: Control.Monad.Maybe.MaybeT IO ()
04:43:05 <ezyang> The litmus test is how little work you need to do in order to get running code, a compiler that people can actually talk to and run experiments with, and as of right now, the best approach still seems to be "make it from scratch"
04:43:05 <lambdabot> Couldn't find qualified module.
04:43:35 <jle`> Jookia: how about this to get you started: do { x <- MaybeT (return ()); y <- liftIO readLn; return (x + y) }
04:43:41 <jle`> um sorry
04:43:50 <merijn> :t lift (return () :: IO ()) :: Control.Monad.Trans.Maybe.MaybeT IO () -- last attempt
04:43:51 <lambdabot> Control.Monad.Trans.Maybe.MaybeT IO ()
04:43:51 <jle`> do { x <- MaybeT (return (Just 5)); y <- liftIO readLn; return (x + y) }
04:44:15 <jle`> a monad block that binds x to the 5 in Just 5, y to the IO result of readLn, and returns the sum in a MaybeT IO
04:44:24 <Jookia> I'll have a bit more of a fiddle around now that I have liftIO. I assumed liftM would've worked instead?
04:44:26 <merijn> ezyang: Yeah, that's what I figured
04:44:40 <jle`> that should give you everything you need to do anything
04:44:52 <jle`> ...that was an audacious claim
04:45:23 <jle`> anyways, to turn a MaybeT IO into an IO, you runMaybeT it.  and then that gets you an IO.
04:45:30 <merijn> ezyang: Anyway, thanks for your input, at least the idea is not obviously insane (although attempting to implement it might be)
04:46:22 <dmj`> f = runMaybeT $ do { liftIO (print "hi") }
04:47:02 <jle`> if you have an IO action f :: IO (Maybe a), you would bind it as { x <- MaybeT f }
04:47:12 <ChongLi> ezyang: yeah, maybe we'll eventually need to get help from the people trying to do general AI
04:47:41 <jle`> and you can bind the result of an g :: IO a with { x <- liftIO g }
04:47:49 <ChongLi> create some extremely expressive, powerful and type-safe language with a highly readable but cumbersome syntax
04:47:55 <ezyang> I don't really know how to do theory research; I have the same temperament as my advisor, "Do something that makes your life together today!"
04:48:01 <ChongLi> and an AI you converse with that writes this code
04:48:10 <jle`> and you can beind the result of an h :: Maybe a with { x <- MaybeT $ return h }
04:48:34 <ChongLi> the question is: can a language be made that's easier to read and reason about than to write?
04:48:44 <ChongLi> it seems like it ought to be
04:48:48 <merijn> ezyang: Most of the life improvements I want to research are rather hard to get funded :p
04:49:07 <dmj`> anyone know if you can run main as sudo in ghci? In snap I'd do :main -p 8000 to run on an unprivileged port, would like to do :main -p 80
04:49:08 <merijn> See structural editors and structural version control :p
04:49:20 <ChongLi> structural regular expresssions!
04:49:21 <merijn> dmj`: sudo your ghci
04:49:25 <merijn> ChongLi: Yes!
04:49:57 <ChongLi> yeah, I'd love to see a nice text editor that combines structural regexes with a vi-like command syntax
04:49:58 <dawik> meh dont run as sudo, just reroute 8000 to 80
04:49:58 <ezyang> I think, if you grew up with an HCI background, there'd be an audience for research like that
04:50:00 <dawik> with iptables
04:50:02 <ChongLi> fully extensible in Haskell
04:50:07 <dawik> --> dmj`
04:50:16 <ezyang> "the great thing about being a PhD student is you have basically unlimited flexibility"
04:50:24 <merijn> ezyang: hah
04:50:30 <merijn> ezyang: That's a lie if I ever heard one
04:50:42 <ChongLi> and designed from the start with a fully-asynchronous, immutable buffer system
04:50:50 <Jookia> At this point I'm basically adding 'return' to see if the errors go away
04:51:11 <Jookia> I could just use error instead and bail
04:51:13 <ChongLi> possibly the most annoying thing about all these editors is all the latency they attach to my keystrokes
04:51:15 <ezyang> Unlimited flexibility is pretty paralyzing!
04:51:30 <ezyang> but usually the problem is insufficient skills/resources/etc
04:51:41 <dmj`> merijn: hm ok, I'm in emacs haskell-mode, will probably have to edit some elisp to see what C-c C-l is doing. dawik: I'll try that
04:51:51 <merijn> ezyang: Most of the phd positions I saw when looking around were pretty strict in the topic, since they're all funded by project money
04:52:09 <ezyang> ah yeah, sorry, Euro-PhDs work a bit differently
04:52:23 <merijn> ezyang: Although the project funding my own position is so broad I have a pretty luxury position
04:53:37 <merijn> Although I guess the upside is that it's significantly cheaper than doing a phd in the US
04:53:41 <ezyang> I feel like, in the end, it's all mental barriers; but mental barriers are real and you can't just wish them away
04:53:59 <ezyang> merijn: Not if you're funded; it's just cheaper in opportunity cost
04:54:15 <jle`> Jookia: don't give up :)
04:54:21 <jle`> Jookia: what are you trying to bind to what?
04:55:01 <merijn> Jookia: Can you pastebin the code + errors you have right now on lpaste?
04:55:09 <merijn> Jookia: plus what you'd like it to do, obviously
04:55:18 <Jookia> I'd like it to compile. I'll sprunge it
04:56:32 <Jookia> http://sprunge.us/dDVQ
04:56:40 <Jookia> http://sprunge.us/dDVQ?haskell *
04:57:32 <arach_> sorry if it sounds like I am trolling, but is haskell a practical programming language?
04:58:09 <ezyang> arach_: yes
04:58:11 <merijn> arach_: Define practical? It's replaced all use of python for me
04:58:30 * merijn even writes his one-off programs for shell scripts in haskell nowadays
04:58:43 <jle`> Jookia: line 53
04:58:49 <jle`> you need a MaybeT
04:59:00 <jle`> MaybeT $ return case ...
04:59:06 * ezyang finds it pretty annoying that MaybeT is not in mtl proper 
04:59:13 * hackagebot time-exts 1.1.0 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-1.1.0 (EnzoHaussecker)
04:59:21 <arach_> merijn: interesting.. by practical I meant usable for developing real programs.
04:59:28 <threestrikes> merijn: what exactly pushed you more to haskell from python?
04:59:31 <dmj`> arach_: yes, facebook uses it
04:59:32 <aristid> ezyang: i think it's worse that the bad ListT is in :)
04:59:34 <jle`> like i said earlier, if you want to bind an h :: Maybe a, you would use { x <- Maybe T $ return h }
04:59:47 <donri> dmj`: maybe something like setcap 'cap_net_bind_service=+ep' $(which ghci)
04:59:57 <arach_> I am struggling to make simplest things in haskell
05:00:10 <Jookia> jle`But then I get a 'Couldn't match type `MaybeT m0' with `IO''
05:00:15 <merijn> Jookia: I'm not sure why there is a >>= in "json str = decode str >>= \d ->" on line 39?
05:00:26 <threestrikes> arach_: I'm new to it as well and definitely struggling
05:00:36 <Jookia> merijn: decode is IO so I'm getting the string out
05:00:37 <jle`> yeah decode str is definitely not a MaybeT IO a
05:00:48 <merijn> Jookia: decode is not IO according to the docs
05:01:00 <merijn> Jookia: "decode :: JSON a => String -> Result a"
05:01:06 <Jookia> Uhh not IO, Result
05:01:13 <Jookia> Wait what am I doing
05:01:17 <merijn> Jookia: And the case-of already takes care of the Result
05:01:53 <jle`> also is there a reason why you aren't using do notation w/ maybeHTTP?
05:01:55 <dawik> arach_: it is a turing complete language, so yes !
05:01:55 <threestrikes> I am new to programming in general and was told to start with python.
05:02:02 <merijn> arach_: I use it for real programs too, whenever I can.
05:02:10 <jle`> i understand do notation considered harmful, but this is probably a case where it might be helpful
05:02:11 <merijn> threestrikes: I think python is not a bad first language, tbh
05:02:21 <Jookia> merijn: Making it just the case statement gives 'Couldn't match expected type `MaybeT IO JSValue''
05:02:23 <maxs`> :t Data.Aeson.decodeEither
05:02:24 <lambdabot> Not in scope: `Data.Aeson.decodeEither'
05:02:34 <Jookia> jle`: Because I don't understand what I'm doing and I want to understand
05:02:36 <merijn> Jookia: You'l want "case decode str of ...."
05:02:39 <threestrikes> I would never knock python I was starting to pick it up.
05:02:41 <jle`> Jookia: ah ok
05:03:07 <dmj`> donri: on osx, not sure setcap is available :/
05:03:21 <donri> dmj`: very unlikely
05:03:41 <maxs`> :t Data.Aeson.eitherDecode
05:03:42 <lambdabot> aeson-0.6.2.1:Data.Aeson.Types.Class.FromJSON a => BSLC.ByteString -> Either String a
05:03:49 <threestrikes> As I learned more about programming and the idea that there were different paradigms it opened my eyes a lot.
05:03:57 <merijn> arach_: Basically, it probably took me 6 months before I was comfortable enough in Haskell to write *real* programs (i.e. not just learning the syntax but also understand commonly used libraries like monad transformers, etc.) and I had 2 short-failed attempts at learning Haskell before then
05:03:59 <donri> dmj`: don't think iptables is either though
05:04:05 <threestrikes> and it being haskell and functional programming
05:04:07 <donri> but there might be an equivalent
05:04:23 <jle`> Jookia: simpleHTTP uri returns an Either?  not a Maybe, right?
05:04:36 <dmisback> I'm really struggling doing something in haskell which is quite easy in an imperative language. maybe someone can help?
05:04:37 <merijn> arach_: In hindsight I would still say it was more than worth the effort, even during the times I was doing C/python for work
05:04:41 <Jookia> jle`: Yes
05:04:45 <dmisback> Here is a list of samples I made up: [50,55,60,65,70,75,70,68,75,79,92,89,92,93,11,14,16,15,17,23,33,37,51,52,49,48,21,23,21,25,27,28,29]
05:04:48 <dmj`> donri: unfortunately no
05:04:51 <Jookia> jle`: But simpleHTTP is IO
05:04:58 <dmisback> I want to find local minimums, so the result [11,21] in this case.
05:05:15 <jle`> Jookia: so remember that (something IO a) >>= \x -> etc.
05:05:20 <jle`> binds the x to the a
05:05:22 <dmisback> The logic that need to be implemented is "if the value drops, and stays BELOW the max it dropped from, for over 3 samples, it's a local minimum"
05:05:26 <jle`> so in your case, your r is an Either
05:05:28 <jle`> not a Maybe
05:05:52 <Jookia> jle': I know
05:06:07 <jle`> so you can't case on r as a Maybe
05:06:11 <jle`> oh
05:06:13 <jle`> sorry
05:06:15 <jle`> i totally misread
05:06:18 <arach_> merijn: sounds like my story. except the becoming comfortable enough to write real programs ;). I enjoy writing small pure functions, but I am lost when attempting to write an actual useful program
05:06:25 <jle`> you did do it as an Either
05:06:29 <donri> dmisback: you doing the waterflow problem? :P
05:06:39 <donri> variation of*
05:06:48 <merijn> arach_: It can take a while to get over that hump
05:06:51 <n-ick> hello chaps :-)  can I ask a total n00b question?
05:06:56 <merijn> arach_: I assume you have finished something like LYAH?
05:07:04 <ocharles> dmisback: one option is to traverse that using a stateful applicative functor
05:07:05 <jle`> Jookia: can you post the full error once you put the MaybeT $ ...?
05:07:07 <donri> n-ick: only if it's not sophisticated!
05:07:11 <jle`> n-ick: don't ask to ask :)
05:07:14 <merijn> arach_: Have you looked at Real World Haskell or Write Yourself a Scheme in 48 Hours?
05:07:15 <dmisback> donri: not that I'm aware of. Trying to solve a real world problem :). do you have a link to the waterflow problem?
05:07:20 <n-ick> alright :-)
05:07:33 <Jookia> jle`: Yes, okay, one sec.
05:07:34 <merijn> arach_: Those have some less trivial examples in there, i.e. a CSV parser or a simple Scheme implementation
05:07:45 <donri> dmisback: http://philipnilsson.github.io/Badness10k/articles/waterflow/
05:07:52 <Jookia> jle`: `MaybeT . return $ case r of' right?
05:07:57 <jle`> Jookia: yes
05:08:07 <dmisback> ocharles: stateful applicative functor? ok. I will google that.
05:08:12 <n-ick> I've installed the haskell package on my os x, and I can run ghci and evaluate little maths things and so on. works good.
05:08:17 <merijn> arach_: (The downside of the CSV parser in RWH is that it uses parsec 2 so isn't directly runnable using parsec 3, but understanding Parsec 3 using those examples should be trivial)
05:08:28 <ocharles> dmisback: if you traverse   [a]  with  Compose (StateT a) (Const [a])  then you can accumulate a list of minimums as you traverse, and use state to determine what a minimum is
05:08:32 <arach_> merijn: I started lyah but I kind of got lost at the applicative chapter. I should probably read it again from start
05:08:39 <ocharles> dmisback: that's a fairly advanced technique though...
05:08:56 <Jookia> jle`: http://sprunge.us/BjCe?haskell
05:08:57 <merijn> arach_: Ah, yes. The Applicative stuff becomes very important for many real world programs
05:09:05 <jle`> arach_: might i recommend simon marlow's book on parallel and concurrent computing?  even if you don't plan on writing parallel or concurrent programs, it helps you 'think' in idiomatic Haskell and shows how you approach problems in haskell, how you put them together, etc.
05:09:18 <ocharles> dmisback: which could be done in a simpler way by just writing a fold on the list
05:09:21 <threestrikes> arach_: everytime I read it I learn something new.
05:09:31 <dmisback> donri: thanks, this may be of great help!
05:09:38 <merijn> arach_: I dare say that less than 1% of my modules are missing "import Control.Applicative" in the code :)
05:10:07 <dmisback> ocharles: I;m trying to use a fold and struggling. Guess I've tackled too difficult of a task, seeing as I've only just read the tutorials.
05:10:20 <ocharles> dmisback: ok, what I suggested is definitely not what you want :)
05:10:33 <ocharles> dmisback: what do you have so far? what's your current idea to solve this problem?
05:10:44 <jle`> Jookia: try doing liftIO (simpleHTTP request) >>= \r ... instead of using the dollar sign
05:10:51 <merijn> dmisback: I would probably implement the solution without a fold (i.e. doing the recursion explicitly)
05:11:07 <jle`> the compiler might be triyng to >>= on the simpleHTTP request (an IO), and not on the liftIO (...) (a MaybeT IO)
05:11:20 <jle`> n-ick: congrats!
05:11:33 <dmisback> I was thinking of doing a fold, and on each item doing a Take of some kind to get the last 3 samples before that item, and looking at those values
05:11:49 <Jookia> jle`: That fixes it. I don't know why I didn't spot that, I usually get nervous around that kind of stuff. My other question is the JSON part, I sneakily changed it to be a Maybe, and I want to understand, how do I promote a `Maybe a' to `MaybeT IO a'?
05:11:51 <dmisback> but I'm not sure how to do a take of X prior elements during a fold
05:11:52 <threestrikes> arach_: One thing that helped me understand a little more about how a real program is structured in haskell was to actually look at one in github
05:11:54 <merijn> jle`: You can scrap the "might" in that sentence
05:12:08 <quicksilver> Jookia: MaybeT
05:12:18 <merijn> jle`: $ binds less tight than >>=
05:12:18 <ocharles> dmisback: well, a fold has the ability to look at a single element of the list it uses some sort of accumulator, right?
05:12:20 <threestrikes> I chose hledgar
05:12:24 <quicksilver> Jookia: (MaybeT and return)
05:12:30 <jle`> Jookia: MaybeT . return
05:12:36 <merijn> quicksilver: Nope
05:12:36 <merijn> quicksilver: That wraps "IO (Maybe a)" :)
05:12:40 <n-ick> jle`, thanks! I just started actually looking at my problem (package dependencies when using cabal) and I think I'll be able to solve it ;-)
05:12:41 <ocharles> dmisback: so what you can do is look at the current state of the accumalator, and append the current element. Then take 3 elements from this new accumulator
05:12:43 <merijn> jle`: Don't you mean "lift"?
05:12:48 <arach_> thanks for suggestions everyone, I will keep trying :)
05:12:49 <threestrikes> the great thing about open source is you can actually see what's under the hood.
05:13:01 <merijn> :t lift (Just 5) :: Control.Monad.Trans.Maybe.MaybeT IO Int
05:13:02 <lambdabot>     Couldn't match type `Maybe' with `IO'
05:13:02 <lambdabot>     Expected type: IO Int
05:13:02 <lambdabot>       Actual type: Maybe Int
05:13:10 <merijn> oh, duh
05:13:23 <merijn> I'm an idiot, apparently
05:13:30 <jle`> hardly
05:13:47 <Jookia> Ooh, my currying using binds was what was stopping me there
05:13:56 <merijn> arach_: Have you looked at xmonad? I believe it's only like 1100 lines of code
05:13:58 <jle`> although you could be using lift instead of liftIO
05:14:04 <jle`> i think
05:14:07 <dmisback> ok,so the accumulator just grows through the fold. that should work. I'm still not sure I'll get away with just a single variable (the accumulator), but let me try
05:14:17 <arach_> I havent, I will take a look
05:14:26 <ocharles> dmisback: it doesn't grow without bounds though - the length of the accumulator is always <= 3
05:14:35 <merijn> arach_: See also: http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
05:14:35 <threestrikes> xmonad in github?
05:14:46 <jle`> welp i'm off. night all
05:15:05 <threestrikes> thanks merijn I'll take a look as well
05:15:13 <Jookia> Thanks guys. I'll have to go read up on this. Have a nice day/night. <3
05:15:14 <dmisback> ok, let me go down that path and get back to you. thanks
05:15:20 <arach_> merijn: out of curiosity, roughly how does your line count for haskell code compare to python code for doing the same thing?
05:15:23 <ocharles> dmisback: sure thing!
05:15:54 <merijn> arach_: I don't really know, I don't usually implement the same thing twice :)
05:15:58 <jle`> wish MaybeT had those convenient helper functions that EitherT had
05:16:16 <jle`> oh well
05:16:19 <merijn> arach_: Depends how close the library is to what I want
05:17:05 <jle`> where left = EitherT . return . Left
05:17:11 <jle`> right = EitherT . return . Right
05:17:19 <jle`> so just = MaybeT . return . Just
05:17:27 <jle`> i guess it's slightly less useful
05:18:08 <jle`> oh, hoistEither = EitherT . return
05:18:15 <jle`> hm is there a general hoist?
05:18:56 <frx> arach_, see http://eyallotem.blogspot.com/2013/05/comparing-python-and-haskell.html
05:18:56 <jle`> hoogle does not like it
05:19:11 <jle`> but then he could have used hoistMaybe instead of the ugly MaybeT . return
05:19:22 <jle`> why do i keep myself up at night doing this
05:21:50 <donri> dmj`: i might have a solution but it's saying 15 fits the specification
05:21:56 <arach_> frx: that is interesting thanks
05:21:59 <donri> >>> tails samples & filter ((>= 2) . length) & map (\(a:b:xs) -> if a > b && b < minimum xs then [b] else []) & concat
05:22:00 <donri> [11, 15, 21]
05:22:55 <quicksilver> jle`: isn't MaybeT . return . Just === return ?
05:23:12 <ocharles> That's O(N^2), right?
05:23:27 <dmj`> donri: might be for dmisback
05:23:36 <donri> it's probably O(shiiiit)
05:23:39 <ocharles> haha
05:23:48 <donri> yes dmisback, sorry
05:24:44 <donri> ocharles: my favourite complexity is O(leg n) where the computation is done in the type system at compile time!
05:24:52 <ocharles> :P
05:24:57 <jonasw> :D
05:25:39 <jle`> quicksilver: yes, thanks :P
05:25:56 <quicksilver> jle`: ISTR that some more recent library tried to make hoist generic
05:25:56 <jle`> which explains why there is no just
05:26:01 <quicksilver> to answer your other question
05:26:06 <jle`> ah, thanks :)
05:26:13 <jle`> i was looking through transformers and seeing where it was
05:26:20 <jle`> i could have sworn i herad aobut a generic hoist somewhere
05:26:29 <quicksilver> mmorph perhaps
05:26:41 <jle`> ty
05:27:14 <quicksilver> yes, that's the one
05:32:06 <zebr> hi all. looking at lambdabot's djinn, i'm interested in what big-O complexity one could derive a simply-typed lambda term from a simple type in. does anyone know of any papers etc on that?
05:32:33 <merijn> zebr: djinn uses free theorems, so you'd wanna look at papers on those, I guess?
05:32:41 <companion_cube> I'm not sure of how expressive it is, but it may be undecidable
05:32:51 <companion_cube> since it's basically a proof-search problem
05:33:09 <PTBD> hello. I'm trying to understand this: http://en.literateprograms.org/Matrix_multiplication_%28Haskell%29#Matrix-by-matrix_product and my question is: ...
05:34:06 <PTBD> the function mulMV is still expecting a vector to multiply with. But it gets a matrix. How does it pull out the correct vector out of the matrix and multiplies it?
05:34:16 <zebr> merijn: that could be a start. do you know what kinds of things to google for? :p
05:34:32 <merijn> zebr: "free theorems" on google scholar?
05:35:04 <merijn> zebr: Ah, here we go "Theorems for Free!" by Wadler
05:35:11 <edwardk> @tell shachaf it was from rob ennals' dissertation. "optimistic evaluation"
05:35:12 <lambdabot> Consider it noted.
05:35:13 <zebr> merijn: ah, that's brought some up, thanks. google proper was having none of it :p
05:35:34 <merijn> zebr: Golden rule is always use scholar when looking for papers :)
05:36:12 <merijn> It's usually quite good at finding free PDFs and bibtex entries for said papers too
05:39:13 <ChongLi> okay, I'm back
05:39:38 <osa1> does anyone here edit heist templates using vim + vim2hs? I was wondering if is there a way to have indentation + automatic tag closing for tpl files ..
05:39:39 <PTBD> nobody?
05:40:57 <pxqr> how to convert Pico to Milli?
05:41:09 <pxqr> from Data.Fixed
05:41:28 <pxqr> (assumming some precision is lost)
05:42:13 <n-ick> ok so here's my noob question. I try to cabal install Crypto; cabal tells me "cannot satisfy HUnit-....". I try to cabal install HUnit, cabal tells me already installed. Is this a global/local package directory thing, or am I being crazy, or what?
05:42:51 <frx> pxqr realToFrac
05:42:55 <ChongLi> n-ick: ghc-pkg list | grep -i hunit
05:43:13 <ChongLi> err
05:43:17 <ChongLi> that won't help much :)
05:43:22 <merijn> n-ick: "cannot satisfy" means, the dependencies are asking for 2 different versions of hunit
05:43:38 <pxqr> frx: thanks
05:43:46 <frx> welcome
05:44:09 <ChongLi> I remember SPJ talking about this issue on the haskell cast
05:44:18 <merijn> n-ick: i.e. library A wants hunit version X and library B wants hunit version Y. Cabal can't link with two different hunit versions, so it says "sorry, can't do this"
05:44:27 <n-ick> ChongLi, that tells me HUnit-1.2.5.2 is there.
05:44:54 <merijn> n-ick: You need to figure out which packages are wanting hunit and which versions they want (there was a command for this, but I forgot)
05:45:18 <n-ick> ... it told me that the cache was out of date, so I sudo ghc-pkg recache 'd, and .. now the cabal install crypto appears to have worked.
05:45:21 <ChongLi> n-ick: well, Crypto itself doesn't care about HUnit's version
05:46:18 <ChongLi> n-ick: ahh, but now your package manager is likely to be upset
05:46:28 <n-ick> oh...
05:46:37 <ChongLi> sudo ghc-pkg will modify the global package database
05:46:58 <merijn> You almost never want to sudo your ghc-pkg/cabal commands
05:47:28 <n-ick> right. well, since this is a brand new install, I might just start over :)
05:47:38 <merijn> Some linux distro's insist on meddling with your global package database and it inevitably goes wrong
05:47:39 <ChongLi> my personal preference is to install only ghc and cabal-install with my package manager
05:47:42 <n-ick> however, cabal-install installed now
05:48:04 <christiansen> does anyone know how to programmatically define CPP macros in Setup.hs?
05:48:08 <merijn> n-ick: The usual approach is to only install ghc/cabal-install (or platform) via your package manager
05:48:09 <ChongLi> and then use the global cabal-install to install a local cabal-install
05:48:12 <christiansen> I'm failing to find it in the cabal docs
05:48:24 <ChongLi> and then from there I install what I want
05:48:29 <yitz> christiansen: why not set them in the cabal file?
05:48:37 <ChongLi> which tends only to be executable tools
05:48:45 <n-ick> sorry, I didn't mention clearly, I'm on os x, so the installer evidently installed a bunch of stuff for me. I guess "globally".
05:48:57 <ChongLi> all the libraries I want go in the cabal sandbox
05:49:04 <christiansen> yitz: I'm putting Git hashes into version strings to aid in getting good bug reports
05:49:16 <n-ick> that's how I'd like to operate too, ChongLi
05:49:17 <merijn> n-ick: Oh, on OSX I recommand just installing the haskell platform binary and using cabal install for everything else
05:49:25 <christiansen> i've tried code generation but I can't get it to play nicely with cabal sdist
05:49:28 <ChongLi> n-ick: it's a good method
05:49:28 <merijn> s/recommand/recommend
05:49:49 <ChongLi> n-ick: are you using brew?
05:50:02 <n-ick> merijn, that's what I tried - that's when I got this dependency error, which the recache appears to have fixed (though messily, I gather)
05:50:18 <merijn> n-ick: incidentaly, if you're reinstalling from scratch, ensure you have "documentation: True" and "library-profiling: True" in ~/.cabal/config
05:50:24 <merijn> n-ick: Or you'll regret it later :)
05:50:27 <yitz> christiansen: cpp-options: -DFLAG
05:51:03 <ChongLi> merijn: I wish there was an option for --haddock-hoogle in ~/.cabal/config
05:51:11 <n-ick> ChongLi, my install method was to download the dmg from haskell.org and run the installer
05:51:15 <n-ick> no brew
05:51:27 <ocharles> Hmm, I get [11, 49, 48, 21] to  dmisback's problem (donri)
05:51:29 <ChongLi> n-ick: ahh, the platform then?
05:51:33 <merijn> n-ick: (Those options enable local installation of documentation and creation of profiling libraries)
05:51:38 <christiansen> yitz: i can put that in my .cabal file - but I need to define to be something specific
05:51:40 <yitz> christiansen: oh. yeah we use codegen for that. but integration with cabal stopped working recently - now there's no way that i know of to force cabal to build the codegen program and run it *before* other components.
05:51:52 <donri> ocharles: with my snippet and his samples?
05:52:00 <ocharles> no, just his snippet. my own solution
05:52:04 <yitz> so we just have a build script that runs cabal twice
05:52:04 <n-ick> ChongLi, os x, 10.9.1
05:52:17 <ocharles> but I think my solution is wrong actually. It should reset the backtracking when there is a drop
05:52:21 <ChongLi> n-ick: no, I mean the haskell platform
05:52:28 <Saizan> christiansen: there's going to be a cppOptions field in some of the records (inside BuildInfo inside LocalBuildInfo) and i think one of the hooks (postConf?) allows you to set it
05:52:30 <ChongLi> you downloaded the dmg for that and just ran the installer?
05:52:34 <yitz> christiansen: although dcoutts told me a while back that there is a way - i haven't had time to look into it
05:52:55 <n-ick> ah, sorry - how do I tell? ghci says "GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help"
05:52:57 <christiansen> the codegen way breaks cabal sdist because it looks for the nonexistent module
05:53:13 <ChongLi> n-ick: what's the name of the dmg file?
05:53:18 <yitz> Saizan: it would be better to work it out without a custom Setup.
05:53:23 <christiansen> Saizan: i'll look more closely
05:53:32 <n-ick> ChongLi, Haskell Platform 2013.2.0.0 64bit.pkg
05:53:37 <ChongLi> there you go :)
05:53:38 <christiansen> yitz: we need a custom Setup for other things anyway, so it's no biggie
05:53:43 <n-ick> lol.
05:53:51 <ChongLi> yeah, that's a good basis
05:54:05 <ChongLi> what you want to do is put ~/.cabal/bin in your PATH
05:54:17 <ChongLi> reinstall the platform to make sure it's clean
05:54:19 <n-ick> ah hah
05:54:22 <n-ick> ok
05:54:31 <donri> ocharles: i think mine is wrong too because it included 15 which should be excluded because it's part of the "3 larger samples following the 11" unless dmisback missed it and 15 should be included ;)
05:54:39 <ocharles> Ha, and now I get []
05:54:46 <ocharles> I give up trying to be smart with Compose :)
05:55:01 <ChongLi> oh, and get rid of ~/.cabal and ~/.ghc
05:55:14 <ChongLi> then after the platform is nice and clean
05:55:15 <yitz> christiansen: ok. i'd like to see a solution that is less hacky.
05:55:18 <ChongLi> do cabal update
05:55:18 <n-ick> there's a ~/.cabal/bin? I only have two config files in there
05:55:30 <ChongLi> n-ick: there will be later
05:55:31 <christiansen> Saizan: do you know of somewhere where the various hooks and their effect on the build info is documented?
05:55:35 <n-ick> ok.
05:55:47 <merijn> n-ick: You want ~/Library/Haskell/ghc-version on OSX
05:56:00 <ChongLi> merijn: ohhh, I didn't know that
05:56:04 <merijn> n-ick: i.e. ~/Library/Haskell/ghc-7.6.3
05:56:28 <ChongLi> that's annoying
05:56:31 <merijn> Library/Haskell also has compiled binaries and documentation
05:56:34 <n-ick> merijn: as well as ~/Library/Haskell/bin ?
05:56:38 <ChongLi> means you have to update your PATH when you update ghc
05:56:39 <merijn> n-ick: Yes
05:56:46 <n-ick> got it
05:57:05 <merijn> n-ick: No, there's also a bin directory that symlinks to the GHC that compiled a binary first
05:57:08 <merijn> eh
05:57:13 <merijn> s/n-ick/ChongLi
05:57:21 <ChongLi> oh okay
05:57:29 <christiansen> yitz: there's a way to do it with Template Haskell as well, but that's also a bit of a hack
05:57:36 <ChongLi> so you don't need a version number in your PATH
05:58:06 <n-ick> there's no symlink in there yet
05:58:09 <yitz> christiansen: right.
05:58:12 <christiansen> yitz: and for some reason using template haskell causes things that link to llvm to fail to compile right now, so we can't use it
05:58:23 <christiansen> (supposedly this will be fixed in next ghc)
05:58:24 <ChongLi> n-ick: don't worry about it
05:58:27 <yitz> oh my
05:58:46 <christiansen> and the idris llvm backend is more important than a fancy version string atm :)
05:58:47 <ChongLi> the key thing we need is to get you on cabal-install 1.18
05:59:02 <ChongLi> so that you can use sandboxes in your projects
05:59:18 <ChongLi> and then you can avoid all this business of cabal hell
05:59:18 <yitz> we're not using llvm but that's a serious problem. we *do* use TH extensively so you are now telling me that we're locked out of llvm.
05:59:30 <ChongLi> well, not all of it
05:59:42 <n-ick> ok, running the installer again, after I move away my ~/.cabal and ~/Library/Haskell
05:59:48 <ChongLi> it is still possible to get dependency resolution failures in a sandbox, it's just unlikely
05:59:53 <yitz> christiansen: are you writing real apps in idris?
06:00:02 <christiansen> yitz: not right now, i'm working on idris itself
06:00:17 <yitz> christiansen: ah ok. it looks promising.
06:00:20 <christiansen> but it's a testbed for a dsl i'm working on
06:00:33 <ChongLi> so I've been thinking more about the new text editor
06:01:19 <ChongLi> and I'd like to combine the unix philosophy with the Haskell/XMonad philosophy
06:01:36 <ChongLi> (for how to structure the application and its extensibility)
06:01:37 <yitz> ChongLi: we spend hours and hours on resolving dep resolution problems in sandboxes. without the sandboxes it would be completely hopeless.
06:01:51 <ChongLi> yitz: yikes :(
06:01:52 <donri> are you talking about a specific text editor or a hypothetical one
06:01:59 <ChongLi> donri: I hypothetical one :)
06:02:06 <ChongLi> based on structural regular expressions
06:02:29 <donri> what does that mean?
06:02:44 <ChongLi> well, the typical regular expressions we're all used to are line-based
06:02:51 <ChongLi> they match from ^ to $
06:03:00 <donri> not necessarily
06:03:01 <magneticduck> http://ix.io/9CR <-- what exactly am I supposed to do now? kind of rusty on debugging cabal packages
06:03:02 <ChongLi> structural regular expressions are recursive
06:03:13 <ChongLi> they can match from any text to any text
06:03:37 <RustyShackleford> I'm having a hard time wrapping my head around haskell
06:03:41 <magneticduck> (building on fresh install of arch linux)
06:03:47 <magneticduck> RustyShackleford: aren't we all =P
06:03:57 <RustyShackleford> mostly the fact that you don't use state
06:04:07 <magneticduck> you can have all the state you want
06:04:13 <ChongLi> think of something like this (from sed): sed -e 'g/foo/s/bar/baz'
06:04:18 <magneticduck> but you have to specify it
06:04:24 <RustyShackleford> i'm used to using state to solve problems
06:04:33 <RustyShackleford> magneticduck, a do block, yes?
06:04:42 <magneticduck> monads are one way of carrying state, yes
06:04:43 <ChongLi> RustyShackleford: yeah, that's very common for new Haskell users
06:04:56 <magneticduck> RustyShackleford: try to understand monads before you think you understand do blocks though
06:04:56 <n-ick> ChongLi, merijn : reinstalled, ran "cabal", checked my .cabal/config for Documentation and Profiling, and ran "cabal install cabal-install" - tells me "<command line>: cannot satisfy -package-id HTTP-4000.2.8-cdf033f9d7051824f52cd5101df67509" - should I run that recache command *without* sudo this time?
06:05:01 <dmj``> > flip evalState 5 $ do { num <- get; return $ num + 1 }
06:05:03 <lambdabot>  6
06:05:15 <dmj``> RustyShackleford: there is some "state"
06:05:21 <ChongLi> n-ick: ahhh, yikes
06:05:23 <magneticduck> RustyShackleford: do blocks look like imperative languages, but it's really just syntatic sugar for an operation with monads
06:05:37 <ChongLi> looks like the Haskell platform is a no-go :(
06:05:40 <n-ick> ChongLi, that was the initial error I was asking about :)
06:05:49 <magneticduck> http://ix.io/9CR anyway can anybody help me with my little silly cabal problem?
06:05:58 <ChongLi> n-ick: ohhh, I didn't realize you were trying to install cabal-install
06:06:09 <ChongLi> n-ick: your best bet may be to use brew
06:06:32 <n-ick> ChongLi, when I try to install HTTP, it says already installed.
06:06:54 <n-ick> ChongLi: so I guess it is a global/local thing
06:07:00 <ChongLi> n-ick: yes
06:07:04 <geekosaur> magneticduck, dunno where EuclideanThings came from, but a constraint on "base" is effectively a constraint on the ghc version
06:07:08 <geekosaur> and yours is too new
06:07:41 <magneticduck> geekosaur: oh ofc, reading the error message again
06:07:50 <geekosaur> it's not that obvious from the error message
06:07:59 <magneticduck> sometimes I just convince myself I don't see what's going on
06:08:08 <ChongLi> RustyShackleford: do you do much shell scripting?
06:08:14 <n-ick> .. when I run ghc-pkg recache without sudo, I get : "nickm@uluru ~ % ghc-pkg recache
06:08:14 <n-ick> ghc-pkg: /Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/lib/ghc-7.6.3/package.conf.d/package.cache: you don't have permission to modify this file"
06:08:39 <ChongLi> n-ick: yeah, basically your best bet here is to uninstall the haskell platform
06:08:41 <threestrikes> :q
06:08:48 <RustyShackleford> ChongLi, well not really. Why do you ask?
06:09:00 <geekosaur> so your ghc has base 4.6.0.1, your best bet may be to change the dependency on base in EuclideanThings to allow that version and then see what breaks
06:09:06 <ChongLi> RustyShackleford: in shell, it's very common to write pipelines of commands
06:09:10 <merijn> n-ick: Hmm, that's no good
06:09:38 <n-ick> .. so the os x package ships with a poor setup?
06:09:39 <ChongLi> ls -1 | grep foo | awk '{print $1}'
06:09:42 <ChongLi> that sort of thing
06:09:53 <ChongLi> n-ick: unfortunately
06:10:02 <n-ick> oh. lame :)
06:10:03 <merijn> n-ick: I'm not sure why you ever ran "ghc-pkg recache" in the first place?
06:10:03 <ChongLi> it's not only OS X
06:10:09 <merijn> n-ick: It shouldn't be necessary...
06:10:16 <n-ick> because it suggested it
06:10:20 <ChongLi> it's common to all the versions of the Haskell platform
06:10:33 <RustyShackleford> ChongLi, okay I know about pipes. So you're encouraged to use them?
06:10:42 <merijn> ChongLi: Why are you saying that he should use homebrew, btw?
06:10:47 <n-ick> nickm@uluru ~ % ghc-pkg list
06:10:47 <n-ick> WARNING: cache is out of date: /Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/lib/ghc-7.6.3/package.conf.d/package.cache
06:10:47 <n-ick>   use 'ghc-pkg recache' to fix.
06:10:49 <ChongLi> RustyShackleford: yeah, you use them for a lot of things
06:11:11 <merijn> n-ick: Well, haskell-platform on OSX 10.9 is currently a bit flaky due to Apple dropping gcc
06:11:12 <ChongLi> merijn: well, homebrew or any other package manager that will make it easy to install ghc and cabal-install
06:11:15 <dmisback> ocharles: you there?
06:11:19 <ChongLi> without any other libraries
06:11:20 <n-ick> ah hah
06:11:26 <n-ick> I see
06:11:29 <merijn> ChongLi: I've used the binary install for OSX for years without issue
06:11:38 <merijn> n-ick: I believe the topic also has a link about it
06:11:45 <dmisback> here's what I came up with, it works, but it's so hard to read. Is it the best way to do this? http://pastebin.com/zpuPAGjq
06:11:45 <dmisback> http://pastebin.com/zpuPAGjq
06:11:49 <ChongLi> merijn: right, but were you using cabal 1.18?
06:11:53 <mauke> The paste zpuPAGjq has been copied to http://lpaste.net/97870
06:11:53 <mauke> The paste zpuPAGjq has been copied to http://lpaste.net/97869
06:12:14 <merijn> n-ick: One of the reasons the new platform release has been delayed is that people are still deciding how to best accommodate the lack of gcc
06:12:15 <ocharles> dmisback: Im' here
06:12:17 <Dodek> hey, is there an explanation somewhere how all the lens type magic works?
06:12:31 <merijn> ChongLi: I just ran "cabal install cabal-install" after installing the platform to upgrade to 1.18
06:12:32 <dv-> dmisback: why use { ; } ?
06:12:37 <ChongLi> dmisback: I like your usage of braces and semicolons, a classic look!
06:12:48 <merijn> ChongLi: Works fine
06:12:50 <dmisback> i used a weird tuple accumulator so I can keep track of the history and keep track of local lows
06:12:52 <Dodek> right now i'm at the point where i see cool examples, but i cannot create my own, because i cannot learn anything from reading documentation
06:12:54 <ChongLi> merijn: odd
06:13:03 <merijn> ChongLi: How so? Why wouldn't it work fine?
06:13:04 <n-ick> merijn: ok, understood. I might run it in a linux VM then
06:13:05 <ChongLi> I had the same problem n-ick is having
06:13:12 <ChongLi> like 8 months ago or something
06:13:26 <ChongLi> this was on windows, I believe
06:13:27 <dmisback> dv-: not sure. still not sure when they are needed. never?
06:13:33 <ChongLi> so nothing to do with Apple
06:13:36 <dmisback> ChongLi. thanks.. sarcasm? :)
06:13:53 <n-ick> ChongLi, merijn : I could get it to install, but I had to run "sudo ghc-pkg recache" first. then it worked - but I understand that makes a mess.
06:14:27 * hackagebot hoodle-core 0.13.0 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.13.0 (IanWooKim)
06:14:29 * hackagebot hoodle 0.2.2.0 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.2.2.0 (IanWooKim)
06:14:31 * hackagebot hopenpgp-tools 0.0.3 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.0.3 (ClintAdams)
06:14:37 <ChongLi> dmisback: no :)
06:14:38 <ChongLi> SPJ uses them too, I think
06:14:49 <ChongLi> n-ick: well, you can always just shrug your shoulders and carry on, worrying about other issues as they crop up
06:15:10 <ChongLi> that's come back to bite me so many times over the years, though
06:15:11 <merijn> n-ick: There should be an uninstaller in /Library/Frameworks/GHC.framework/Versions/Current/Tools
06:15:25 <ChongLi> now I always try to work from a clean basis
06:15:48 <ChongLi> RustyShackleford: still here?
06:15:57 <merijn> n-ick: I'd be curious to see a more verbose error of when it complains about needing to run "recache"
06:15:58 <n-ick> merijn: yes, found it
06:16:08 <ChongLi> anyway, my point about shell pipelines is that they teach you compositionality
06:16:14 <n-ick> merijn: ok, let me paste it
06:16:25 <merijn> n-ick: According to the ghc-pkg documentation you should only need to run that when you have manually messed with the package database
06:16:36 <merijn> n-ick: Have you had a previous haskell install on the machine?
06:16:41 <RustyShackleford> ChongLi, i'll keep that in mind, thanks
06:16:46 <ChongLi> the idea of building a series of simple, re-usable steps and composing them together
06:16:54 <merijn> n-ick: See also http://www.haskell.org/platform/mac.html for 10.9 details
06:16:58 <ChongLi> well, that's functional programming in a nutshell
06:17:09 <n-ick> merijn: uhhm... I don't think so.
06:17:12 <ChongLi> the only difference with Haskell is that it uses types
06:17:17 <n-ick> merijn: look - "nickm@uluru ~ % ghc-pkg -v list
06:17:17 <n-ick> using cache: /Users/nickm/.ghc/x86_64-darwin-7.6.3/package.conf.d/package.cache
06:17:17 <n-ick> WARNING: cache is out of date: /Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/lib/ghc-7.6.3/package.conf.d/package.cache
06:17:17 <n-ick>   use 'ghc-pkg recache' to fix."
06:17:29 <ChongLi> and so you don't have to parse strings all the time to get anywhere :)
06:17:37 <merijn> n-ick: Try deleting .ghc and .cabal before installing? :)
06:18:04 <geekosaur> takes more than that
06:18:16 <n-ick> I didn't know about .ghc - I'll reset again
06:18:17 <geekosaur> ~/Library/Haskell serves most of the purposes of ~/.cabal
06:18:20 <merijn> n-ick: And also ~/Library/Haskell to be sure
06:18:31 <n-ick> merijn, ok, here we go...
06:18:49 <ChongLi> anyway, getting back to my text editor philosophy
06:19:35 <ChongLi> what if the editor has a very tiny core and all of its extensibility is done with commands that operate asynchronously and communicate through pipes
06:19:56 <ChongLi> like vi, but asynchronous rather than synchronous
06:20:43 <ChongLi> and how should asynchrony jive with an interactive editor and long-running commands?
06:20:50 <ChongLi> via STM, of course!
06:21:05 <ChongLi> every time the user types a keystroke, he does so atomically
06:21:21 <ChongLi> so a long-running command would get restarted by the STM automatically
06:22:02 <ChongLi> the data structure of the text itself would have to be a persistent one
06:22:30 <ChongLi> with new tree branches being created by structural regular expressions
06:23:13 <ChongLi> and so you can run a command on a region of text within the file and then go about editing somewhere else without interrupting it
06:23:33 <ChongLi> and you can have processes constantly running things like syntax checkers and syntax highlighters without ever interrupting your typing
06:23:49 <ChongLi> as well as auto-completion, of course!
06:24:32 <merijn> ChongLi: So, when are you starting work on it? ;)
06:24:39 <ChongLi> merijn: hahaha
06:25:01 <ChongLi> I guess a lot of the work is already in place
06:25:30 <ChongLi> anyone here use ansi-terminal?
06:25:30 <christiansen> Saizan: the cpp solution seems to be a non-starter, as it forces recompilation of everything for each commit
06:25:38 <christiansen> ChongLi: yes
06:25:54 <ChongLi> christiansen: is it nice?
06:26:04 <christiansen> ChongLi: quite easy to work with, imo
06:26:07 <merijn> ChongLi: Are you wanting to do terminal UI things?
06:26:17 <merijn> ChongLi: I'd recommend looking at vty-ui instead of ansi-terminal
06:26:28 <christiansen> we use it for semantic highlighting of terms in the idris repl
06:26:29 <merijn> ChongLi: vty-ui gives you much higher level primitives to work with
06:26:31 <n-ick> ChongLi, merijn : ok, so, I guess I must have had some files from a previous install lying around. I deleted ~/.cabal, ~/.ghc, ~/Library/Haskell, and ran the uninstaller, and after a reinstall it appears to be working like it should
06:26:39 <ChongLi> merijn: ahh, nice
06:26:41 <merijn> n-ick: \o/
06:26:51 <ChongLi> n-ick: YAY!
06:26:52 <merijn> ChongLi: It has things like buttons, text entry fields, etc.
06:27:00 <ChongLi> merijn: oh, wow
06:27:02 <christiansen> those would be horrible in ansi-term
06:27:17 <n-ick> ChongLi, merijn: now I can start learning :-) hooray! thank you both.
06:27:35 <ChongLi> n-ick: no problem
06:27:40 <ChongLi> make sure you stay in here while you learn
06:27:43 <merijn> ChongLi: I think the design of the library is suboptimal (it is to much like traditional GUI libraries, imo), but it's *much* better than implementing all that from scratch
06:27:45 <ChongLi> this place is a fantastic resource
06:28:03 <merijn> n-ick: I expected something like that, like I said I've never had to run recache with the binary install before :)
06:28:36 <ChongLi> merijn: hmmm, that reminds me of the other aspect of the editor
06:28:50 <ChongLi> how to deal with the event handling
06:28:52 <ChongLi> FRP?
06:29:14 <merijn> ChongLi: I started along these lines, but got stuck yak shaving and working on a zeromq library :)
06:29:16 <dmisback> ocharles: does it look like the right way to implement this?
06:29:25 <merijn> Which I should really get to semi-alpha this week
06:29:27 <Saizan> christiansen: ah, makes sense
06:29:33 <dmj``> there was a recent post on ansi-term usage here: http://yannesposito.com/Scratch/en/blog/Holy-Haskell-Starter/
06:29:34 <ocharles> dmisback: that is generally what I was suggesting yea
06:29:41 <ChongLi> merijn: ahhh, I yak-shave wayyy too much
06:29:44 <ocharles> dmisback: I would have just rewritten it using sligtly more idiomatic syntax - no braces, etc
06:30:11 <dmisback> ok thanks. it's quite terse. Can't imagine people reading this easily, but I guess that's because I'm not fluent in it.
06:31:01 <ChongLi> speaking of FRP
06:31:09 <ChongLi> does anyone have a good sense of the landscape here?
06:31:14 <merijn> dmisback: incidentally, if you use lpaste it will automatically run hlint on your code and tell you when parenthesis are redundant
06:31:39 <ChongLi> I'm interested in an FRP library that doesn't depend on any GUI library (such as gtk)
06:31:39 <dmisback> noticed that merijn, thanks. removing them now.
06:31:46 <merijn> dmisback: Also, I personally would use "where" let/in
06:31:48 <maxs`> ChongLi: netwire
06:32:03 <ChongLi> maxs`: how does it compare to reactive-banana?
06:32:13 <ChongLi> that's the only one I've looked at so far
06:32:13 <threestrikes> exit
06:32:41 <christiansen> Saizan: so i guess it's back to getting cabal sdist to work with generated code, as the cpp and template haskell options are both unusable :(
06:32:47 <christiansen> or give up, i guess
06:33:29 <dmisback> dont' remember how where works. will look it up now, thanks.
06:33:51 <maxs`> ChongLi: I think you will learn more by trying the tutorial http://hub.darcs.net/ertes/netwire
06:33:58 <ocharles> ChongLi: I do quite a lot of netwire programming these days
06:34:00 <maxs`> than me attempt to explain
06:34:13 <ChongLi> maxs`: that's what I was looking for, thanks :)
06:34:50 <merijn> dmisback: More idiomatically would be: http://lpaste.net/97871
06:35:03 <ChongLi> ahhh, Prelude hiding ((.))
06:35:04 <ChongLi> !
06:35:34 <isomorphic> @src fromIntegral
06:35:34 <lambdabot> fromIntegral = fromInteger . toInteger
06:35:47 <dmisback> ah... so where is an area to define stuff. gotcha
06:35:48 <isomorphic> @src fromInteger
06:35:49 <lambdabot> Source not found. Are you typing with your feet?
06:36:02 <merijn> dmisback: I would also recommend giving https://en.wikibooks.org/wiki/Haskell/Indentation a quick read and then using layout instead of braces/semicolons, as the majority of haskellers use layout
06:36:22 <ChongLi> dmisback: where and let
06:36:33 <merijn> dmisback: Every definition can have a where clause where you can have additional (local) definitions. In fact, even the definitions inside a where clause can have where clauses
06:36:48 <ChongLi> the 2 tools you need to control the scope of your values
06:40:55 <dmisback> thank you sirs
06:41:17 <ChongLi> does the Category version of (.) have any overhead due to the type class constraint?
06:41:25 <ChongLi> or in general?
06:42:47 <RustyShackleford> http://xkcd.com/1270/
06:43:01 <hhhhhhhh> i have http://ix.io/9D2. how do i make loadPosts return a [ Post ] and is that a good idea
06:43:03 <pqmodn> ChongLi probably not, dictionary passing can be eliminated (e.g., your call to Category.. will be replaced with Prelude..)
06:43:25 <ChongLi> pqmodn: ahh, nice
06:43:45 <ChongLi> then it seems to me that if we started over again, we'd have used Category instead?
06:43:52 <pqmodn> ChongLi: unless you've got an expression that is generic in c, Category c => ...
06:43:53 <magneticduck> GUYS HELP ME I'm having font trouble; running a little Main.hs that imports Gloss
06:44:13 <magneticduck> and writes some text to the screen.. upon running, I get the following error
06:44:15 <magneticduck> http://www.prinmath.com/csci5229/misc/install.html
06:44:25 <magneticduck> shit wrong link
06:44:36 <magneticduck> http://ix.io/9D3
06:44:37 <ChongLi> pqmodn: makes sense
06:44:38 <pqmodn> ChongLi: maybe. usually the Prelude doesn't use typeclasses because it was thought the error messages would be hard for beginners to understand
06:45:02 <ChongLi> magneticduck: that's a tough one
06:45:13 <magneticduck> the fonts on my system are a bit messed up I think
06:45:35 <ChongLi> pqmodn: yeah, hence all the classyprelude etc. wars
06:45:49 <ChongLi> defaults are just so hard to get right
06:46:41 <ChongLi> just imagine if lens was part of the Prelude
06:47:53 <ChongLi> then again, isn't a lot of what lens does a hack to avoid having to use Control.Category.(.) ?
06:48:58 <ChongLi> RustyShackleford: hey, here's another thought that might help you a bit
06:49:15 <ChongLi> global state is just an implicit argument to every function
06:49:35 <ocharles> ChongLi: that was more a side effect of how it was implementefd
06:49:38 <ocharles> it's just an added bonus
06:49:54 <ChongLi> ocharles: ahhh
06:50:37 <ChongLi> but isn't the use of newtypes in order to get the dictionaries passed correctly a hack? hmm
06:50:42 <RustyShackleford> i need to dive in and write some code already
06:50:49 <ChongLi> runIdentity . Identity .. etc.
06:51:01 <RustyShackleford> not sure which toy problem i wanna use
06:51:35 <ChongLi> are you going through LYAH?
06:51:40 <allsystemsarego> is it just me, or has the release of GHC 7.8 been postponed indefinitely?
06:52:20 <aristid> i'm sure it will happen at some time
06:52:36 <aristid> in a strictly finite timespan, too
06:52:56 <ChongLi> allsystemsarego: according to Austin Seipp, it'll be released around Nov 25th!
06:53:09 <allsystemsarego> comforting :)
06:53:13 <merijn> Wasn't it initially scheduled for ICFP? :P
06:53:30 <aristid> ChongLi: 2013, i assume?
06:53:35 <ChongLi> aristid: yeah
06:55:25 <eikke> yeah, ghc might benefit from a different releng strategy imho
06:56:36 <magneticduck> question: is "(id :: (<type> -> type)) . <...>" a valid way to typecast a value?
06:56:52 <merijn> magneticduck: Haskell doesn't have typecasts
06:57:09 <ChongLi> merijn: barring the FFI :)
06:57:19 <allsystemsarego> @hoogle cast
06:57:21 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
06:57:21 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
06:57:21 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
06:57:29 <magneticduck> merijn: I mean, specify
06:57:43 <magneticduck> like (id :: (Float -> Float)) $ 1
06:57:46 <merijn> magneticduck: You can annotate functions inline, yes
06:57:47 <magneticduck> is that possible?
06:57:55 <magneticduck> I mean, does that give the desired result
06:58:02 <ChongLi> there are even worse functions than those, however
06:58:04 <merijn> magneticduck: Although it might need ScopedTypeVariables extension
06:58:04 <magneticduck> I would imagine it does but I just wanted to be sure
06:58:06 <ChongLi> I won't mention here
06:58:08 <dv-> > (id :: (Float -> Float)) $ 1
06:58:09 <lambdabot>  1.0
06:58:12 <eikke> > (id :: (Float -> Float)) $ 1
06:58:13 <lambdabot>  1.0
06:58:24 <merijn> magneticduck: If the desired result is "type error if I do something other than pass the right type argument", then yes
06:58:24 <magneticduck> > 1
06:58:26 <lambdabot>  1
06:58:27 <magneticduck> kk
06:58:30 <ChongLi> I've gotten yelled at before for mentioning these functions :)
06:58:36 <magneticduck> merijn: =P
06:58:46 <merijn> magneticduck: You are allowed to write types that are *less* general than necessary, yes
06:58:52 <eikke> ChongLi: for somewhat good reason, no? :)
06:59:01 <ChongLi> eikke: yeah
06:59:10 <ChongLi> this one in particular can corrupt the runtime
06:59:18 <merijn> magneticduck: i.e. since "id" is "a -> a" you are allowed to annotate it as "Float -> Float" as that is a valid more specific version of "a -> a"
06:59:24 <magneticduck> I mean, sometimes this syntax is preferable to wrapping an entire expression in (<expression> :: <type>)
06:59:42 <magneticduck> instead you can just put a little (id :: a -> a) $
06:59:47 <magneticduck> on the beginning
07:00:01 <magneticduck> sorry newlines, still getting used to this keyboard is seems
07:00:08 <merijn> magneticduck: Like I said, inline type annotations *may* require ScopedTypeVariables, but I'm not sure
07:00:11 <ChongLi> so I'm slowly reading through this tutorial on netwire
07:00:17 <ChongLi> so far, it's extremely well written
07:00:25 <hhhhhhhh> how do i read a file into a string
07:00:26 <merijn> Then again, ScopedTypeVariables is an entirely sensible extension, so that shouldn't matter :)
07:00:32 <ChongLi> I especially like the start with the Applicative interface
07:00:35 <hhhhhhhh> OR ignore the exception if it fails and let the program die
07:00:45 <merijn> hhhhhhhh: hGetContents
07:00:49 <magneticduck> hhhhhhhh: http://www.haskell.org/hoogle/?hoogle=FilePath+-%3E+IO+String
07:01:04 <magneticduck> hhhhhhhh: hoogleftw
07:01:20 <magneticduck> ohk
07:01:28 <christiansen> so, Cabal experts: I've got a preSDist hook generating the appropriate module, but I get the error that it could not find the module with any suffix, and then gives a list of file endings
07:01:45 <hhhhhhhh> magneticduck: i'm using readFile at the moment but i want to get rid of the IO if it suceeds.
07:02:20 <eikke> hhhhhhhh: if I understand correctly, the answer is: you can't
07:02:26 <pqmodn> hhhhhhhh: you probably misunderstand IO. you cannot "get rid" of it!
07:02:36 <christiansen> I think i'm putting the file in the right place, because the error message changes from not being able to find the module in the sdist autogen directory to not being able to find it with the right suffix
07:02:59 <pqmodn> hhhhhhhh: in other words, "IO a -> a" is ill-conceived
07:03:25 <hhhhhhhh> pqmodn eikke: do i have to write do { ... } everywhere then
07:03:45 <eikke> no
07:03:50 <christiansen> hhhhhhhh: the idea is to structure most of your program without IO, then have a little IO layer at the top
07:03:52 <hhhhhhhh> because this seems like its going to get horrible :p
07:03:59 <aristid> :t unsafePerformIO
07:03:59 <lambdabot> Not in scope: `unsafePerformIO'
07:04:05 <eikke> aristid: oh come on
07:04:07 <aristid> heh
07:04:14 <pqmodn> hhhhhhhh: no, you don't. have you read much of LYAH?
07:04:15 <ChongLi> ahhh! what is happening!
07:04:26 <ChongLi> the forbidden word!
07:04:27 <osa1> interesting. I have "deriving (Show)" in my record type but for some reason the instance is not implemented and I can't see "instance Show" when I run :i MyRecordType
07:04:28 <hhhhhhhh> pqmodn i read it a few months ago
07:04:32 <ChongLi> the function which must not be named!
07:04:33 * hackagebot yesod-markdown 0.8.2 - Tools for using markdown in a yesod application  http://hackage.haskell.org/package/yesod-markdown-0.8.2 (PatrickBrisbin)
07:04:38 <eikke> hhhhhhhh: you only need the IO monad where you do IO. Fetching the data from the file is IO, transforming the data might not be IO-related, so doesnt need IO
07:04:38 <merijn> aristid: ಠ_ಠ
07:04:41 <aristid> eikke: i really like that unsafePerformIO has "unsafe" in the name.
07:05:07 <aristid> unlike
07:05:11 <aristid> :t fromJust
07:05:11 <lambdabot> Maybe a -> a
07:05:18 <ChongLi> or head
07:05:19 <dv-> if the file doesn't change during the execution of the program then it's safe to unsafePerformIO $ readFIle ...
07:05:34 <merijn> dv-: eh...
07:05:41 <magneticduck> hhhhhhhh: there is unsafe evaluate IO, if you really need to, for instance, read a config file or something and you really don't want to have to use IO
07:05:44 <merijn> dv-: You and I must have very different definitions of safe :)
07:05:49 <ChongLi> but crashing your program is not as bad as giving an incorrect result, or so I hear
07:06:04 <magneticduck> http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO-Unsafe.html#v:unsafePerformIO
07:06:07 <merijn> magneticduck: Even if you need to read a config file you don't need unsafe
07:06:24 <merijn> Can everyone please stop talking about unsafePerformIO to newcomers?
07:06:45 <magneticduck> merijn: I know
07:06:53 <aristid> Don't mention the war^H^H^HunsafePerformIO
07:06:54 <magneticduck> it's just used for that sometimes I've heard
07:06:58 <osa1> how to calculate sizeOf and alignment for C structs? (for Foreign.Storable instance)
07:07:07 <merijn> You are being 1) unhelpful 2) confusing 3) deliberately telling someone something that will break their program in unexpected ways
07:07:12 <ChongLi> it's like saying Voldemort
07:07:17 <ChongLi> it isn't just a name
07:07:27 <ChongLi> when you say it, bad people show up and attack you :)
07:07:28 <merijn> osa1: c2hsc can auto-generate Storable instances for you
07:07:49 <merijn> osa1: There are some other tools too, but I haven't used them
07:07:59 <aristid> merijn: i think the fact that the only wait to get IO a -> a has "unsafe" in the name is actually a good hint that it's dangerous.
07:08:07 <aristid> -wait+way
07:08:26 <merijn> aristid: You overestimate how attractive that looks to confused beginners
07:08:31 <merijn> aristid: eh, underestimate
07:08:45 <merijn> aristid: That type signatures attracts confused people like moths to a flame
07:08:49 <merijn> With much the same result...
07:08:58 <aristid> merijn: they actually do use it? oO
07:09:12 <merijn> aristid: Of course people use it when they learn of it
07:09:38 <merijn> Why do you think we have
07:09:43 <merijn> @quote Lemmih not.a.bug
07:09:44 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
07:09:53 <aristid> lol
07:10:08 <aristid> merijn: i never felt much attracted to using it.
07:10:22 <aristid> but then i guess i'm not a valid scientific sample
07:10:53 <aristid> merijn: but i guess your handwringing now might be more persuading?
07:11:12 <dv-> i've never seen newbies use uPIO
07:11:30 <dv-> if anything, its existence tells them that they're missing something
07:12:50 <merijn> hhhhhhhh: The usual solution to working with IO is to define your program as a pure function that accept a String and then use "fmap" to run your code "inside" the IO
07:13:14 <merijn> hhhhhhhh: In other words, instead of getting the value "out" of IO, you'll want to get your pure programs "in" to IO
07:13:21 <merijn> :t fmap
07:13:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:13:41 <merijn> hhhhhhhh: Since IO is a functor, you can think of "fmap" as having type "(a -> b) -> IO a -> IO b"
07:14:29 <merijn> hhhhhhhh: Another common way to use IO is >>= which effectively has this type: "IO a -> (a -> IO b) -> IO b"
07:15:02 <merijn> There was a nice blog post on IO in haskell, but it appears to be down at the moment
07:15:14 <McManiaC> why does System.IO.hIsOpen block if there are other threads waiting on input on a handle?
07:16:22 <durm_> guys, whats the one-word name of '<-' operator in Haskell
07:16:37 <merijn> McManiaC: I believe the runtime has locks around Handle so only one thread interacts at a time
07:16:38 <merijn> McManiaC: Sounds like that may cause the "hIsOpen" to block until the reading thread releases it. Sounds like a bug, though
07:16:46 <ChongLi> durm_: I've often wondered that myself
07:16:52 <merijn> durm_: There is no "<-" operator, it's syntactical sugar for the bind operator ">>="
07:17:20 <McManiaC> durm_: "bind", but what merijn said
07:17:21 <merijn> durm_: I recommend reading https://en.wikibooks.org/wiki/Haskell/do_Notation
07:17:24 <ChongLi> merijn: the correct answer is "drawn from, or from"
07:17:34 <ChongLi> http://www.haskell.org/haskellwiki/Pronunciation
07:17:36 <durm_> ooo thanks
07:17:56 <ChongLi> <- isn't just used in do notation
07:18:03 <ChongLi> it's also in list comprehensions
07:18:04 <merijn> durm_: I usually recommend beginners use >>= and >> explicitly until you get comfortable with that and only then using do notation
07:18:21 <merijn> ChongLi: Which is actually a form of do notation, hence why we have MonadComprehensions in GHC :)
07:18:31 <McManiaC> ChongLi: list comprehension is even more syntactical sugar, but even then "bind" isn't completly wrong
07:18:39 <twanvl_> in list comprehension I read it as "in", i.e. [x | x <- xs] is "x for x in xs"
07:18:46 <McManiaC> merijn: which i have developed \o/ woohoo
07:18:47 <McManiaC> :D
07:19:02 <merijn> ChongLi: "[x | x <- [1..10]]" is identical to "do { x <- [1..10]; return x }" :)
07:19:08 <ChongLi> yeah
07:19:27 <hhhhhhhh> merijn: fmap looks like what i want. thanks
07:19:34 <ChongLi> it all gets translated down to >>=, right?
07:19:46 <McManiaC> basically yeah
07:19:55 <McManiaC> but only if you really use MonadComprehensions
07:19:57 <merijn> ChongLi: >> is implemented using >>= yes
07:20:08 <McManiaC> if not, the list comprehension stuff is separate code
07:20:16 <ChongLi> it makes sense that Haskell's logo is >>= mixed with lambda then
07:20:35 <McManiaC> it does :)
07:20:49 <ChongLi> it really captures Haskell's philosophy
07:20:54 <merijn> hhhhhhhh: I also recommend readin this post (if the blog ever gets fixed): http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
07:21:18 <aristid> jle`: sounds like it's your blog, from the domain?
07:22:45 <christiansen> yitz, Saizan: I think I solved it finally
07:22:53 <christiansen> thanks for the help
07:24:56 <yitz> christiansen: which one of the four or so basic approaches we mentioned did you end up using?
07:25:17 <christiansen> yitz: code generation
07:25:40 <christiansen> i got sdist to work by hooking into the codegen step and also generating it in the sdist dir
07:25:44 <yitz> ooo. so i'm interested in more details pls :)
07:25:57 <yitz> wow. ok.
07:26:17 <hhhhhhhh> is there a way to force readFile to consume all input so it closes its handle
07:26:21 <christiansen> https://github.com/david-christiansen/Idris-dev/commit/e9858150b1c2ddeca2080d5cd6e6a275a94cbee9 is perhaps the easist way to explain
07:27:01 <christiansen> so the problem before is that sdist would complain because of a missing library module
07:27:12 <christiansen> (the paths module is special-cased)
07:27:23 <yitz> christiansen: if the user will be running the code gen before building, then why does the output of codegen need to be in sdist? seems like the sources *before* codegen is what you'd want.
07:27:37 <christiansen> it's just to make cabal happy
07:27:49 <christiansen> when the sdist package is built, the generated file is overwritten anyway
07:28:05 <christiansen> if it wasn't there cabal would complain :)
07:28:07 <yitz> ah because you specified the modules in the cabal file so sdist is insulted not to find them?
07:28:10 <christiansen> yes
07:28:25 <christiansen> and if the module is not listed in the cabal file, then it can't be imported
07:28:25 <yitz> christiansen: well we have a stub module for that purpose.
07:28:34 <christiansen> stub module?
07:28:35 <merijn> hhhhhhhh: No, it's one of the common problems with lazy IO. Several solutions adress the issue, you can either use non-lazy IO (i.e. something like Data.ByteString.Strict), which has the downside of reading the entire file into memory
07:28:37 <yitz> christiansen: codegen overwrites it
07:28:40 <christiansen> ah
07:29:12 <christiansen> i'd rather not rewrite something that's under version control - that seems to be likely to cause lots of repo noise
07:29:17 <merijn> hhhhhhhh: Alternatively, libraries like pipes, conduit and iteratees allow you to do streaming IO with control over when a handle is closed. Unfortunately they tend to be a bit intimidating for beginners
07:29:24 <fabe> hi im a haskell nub and dont understand whats why this fails http://pastebin.com/cFakxB0S
07:29:27 <fabe> any help?
07:29:28 <dv-> :t readFile "..." >>= \c -> length c `seq` return c
07:29:29 <mauke> The paste cFakxB0S has been copied to http://lpaste.net/97877
07:29:29 <lambdabot> IO String
07:29:58 <christiansen> hell, I thought I fixed it, but travis is still unhappy. back to the drawing board.
07:30:10 <yitz> christiansen: riigght. actually someone recently removed the file from vc for that reason, which will then cause your problem. hmm. i should talk to her about that.
07:30:34 <yitz> ouch
07:31:03 <merijn> fabe: decode doesn't return a ByteString
07:31:20 <bennofs> How does profiling in GHC work? If i have let x = [very resource intensive computation] in f x, and I add a cost centre annotation to f (which forces x to compute it's result), will the costs of x be attributed to that cost centre?
07:31:25 <yitz> christiansen: wait a minute. sdist needs to work before you've ever built?
07:31:28 <merijn> fabe: Decoding Base64 can fail, so decode returns "Either String ByteString" (i.e. it returns an error message *or* a decoded ByteString)
07:31:49 <merijn> fabe: It's complaining that you are comparing a ByteString (bytes) with an "Either String ByteString" (the result of decode)
07:31:51 <fabe> so how do i fix it?
07:31:54 <christiansen> yitz: it's how the test setup is right now
07:31:58 <yitz> i see
07:32:03 <christiansen> to make sure that we don't break sdist :)
07:32:09 <yitz> heh
07:32:33 <dv-> fabe: case bytes of Left err -> (handle decode failure); Right str -> (success)
07:32:37 <merijn> fabe: You'll want to use "case B64.decode (B64.encode bytes) of Left _ -> False; Right result -> result == bytes"
07:32:42 <aristid> dv-: why the parens?
07:33:05 <fabe> ok thank merijn
07:33:17 <merijn> fabe: i.e. pattern match on the Either datatype and return False (decode error means it doesn't match, right?) and otherwise compare the decoded result with the actual ByteString
07:33:31 <christiansen> yitz: it seems to have worked because i was lucky..
07:33:44 <yitz> christiansen: so a build script that reverts the stub at the end of the build. (and saves a renamed copy outside of vc to be able to inspect it afterwards)
07:33:52 <yitz> ?
07:33:53 <fabe> hay moop fancy seeing you here :D
07:34:01 <dv-> aristid: to not confuse it with valid code
07:34:10 <merijn> fabe: Alternatively, you can use the functor instance of "Either String" "fmap (bytes==)" will return "Either String Bool" (effectively propagating the error of the decode fails)
07:34:10 <moop> fabe: hello \o/
07:34:23 <aristid> dv-: doesn't make it invalid per se:)
07:34:26 <christiansen> yitz: yes, this is a possibility, but i'd still rather just generate the darn thing
07:34:43 <merijn> fabe: But at some point you'll want to pattern match to get rid of the Either and deal with the fact that the decode might fail
07:35:01 <ChongLi> wow, html pages look really good on a kindle
07:35:28 <ChongLi> now I can read the rest of this netwire tutorial on the go :)
07:35:31 <yitz> christiansen: we actually don't use sdist very much in practice so it's probably not worth spending more time here. i'll probably just leave out the stub for now.
07:35:45 <yitz> christiansen: ok gl!!
07:35:54 <christiansen> edwin calls it for every release
07:36:06 <christiansen> and it's a pain when things we've done break the release process but not our tests
07:36:12 <christiansen> so the tests run the release process
07:36:50 <snizzo> what is the usefullness of left and right? (prelude ones)
07:36:56 <merijn> :t left
07:36:57 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
07:37:06 <bennofs> @hoogle left
07:37:06 <lambdabot> Control.Arrow left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
07:37:06 <lambdabot> Control.Arrow leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
07:37:06 <lambdabot> Data.Either lefts :: [Either a b] -> [a]
07:37:28 <merijn> snizzo: There is no "left" in Prelude, do you mean Left?
07:37:36 <snizzo> merijn: yeah
07:37:46 <yitz> ChongLi: a little warning - there are some really weird css behaviors in kindle and some surprising things that aren't supported, at least inside a mobi. if your css isn't tailored specially for mobi, strange things will happen.
07:37:49 <Axman6> @src Either
07:37:49 <lambdabot> Source not found. My brain just exploded
07:37:53 <Axman6> wut
07:37:55 <merijn> snizzo: Either is a datatype that's commonly used for alternatives/errors
07:38:01 <ChongLi> yitz: ahhh
07:38:06 <merijn> snizzo: So "data Either a b = Left a | Right b"
07:38:07 <Iceland_jack>     data Either a b = Left a | Right b
07:38:09 <ChongLi> well, this particular page looks great
07:38:17 <ChongLi> even the code listings are nicely formatted
07:38:30 <merijn> snizzo: We need a constructor to tell whether the value is an 'a' or a 'b', that's what Left/Right are for
07:38:39 <yitz> ChongLi: ok great. are you viewing in in a browser or as a mobi book?
07:38:50 <ChongLi> a mobi book, produced by calibre
07:38:57 <merijn> snizzo: You could've also called them "One" and "Other", but Left/Right help remember whether they belong to the 'a' or 'b'
07:39:14 <ob__> Could someone please explain to me why this generates prime numbers: pgen (p:xs) = p : pgen [x|x <- xs, x `mod` p > 0]
07:39:16 <yitz> ChongLi: very nice. i wonder if calibre is smart enough to fix some of the quirks.
07:39:41 <snizzo> merijn: I quite got it
07:39:42 <merijn> snizzo: Take a look at fabe's question earlier, where "decode" returns "Either String ByteString", "Left" means it has a String error messages (i.e. the decode failed), Right means it succesfully decoded and returned a ByteString
07:40:22 <snizzo> thank you :)
07:40:56 <christiansen> ob__: take a look at www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
07:42:09 <ob__> thanks, christiansen
07:42:25 <christiansen> no prob, that paper does a good job discussing how laziness works
07:42:34 <cheeseen> o/
07:42:38 <ChongLi> yitz: it has a bunch of heuristic processing you can turn on
07:43:32 <bennofs> Converting PDFs to EPUB failed horribly with calibre for me
07:44:05 <ChongLi> PDFs are much harder than HTML because they assume a fixed page layout
07:44:11 <yitz> bennofs: i'm sure it's highly dependent on the rendering style inside the particular pdf
07:44:37 * hackagebot watchdog 0.2.2 - Simple control structure to re-try an action with exponential backoff  http://hackage.haskell.org/package/watchdog-0.2.2 (JanVornberger)
07:44:39 * hackagebot watchdog 0.2.2.1 - Simple control structure to re-try an action with exponential backoff  http://hackage.haskell.org/package/watchdog-0.2.2.1 (JanVornberger)
07:45:00 <bennofs> But I found k2pdfopt, which doesn't convert to EPUB but makes the pdf much easier to read
07:45:10 <bennofs> Now I can finally read haskell papers :)
07:45:33 <tomejaguar> Can I shorten 'Pattern -> case x of x | cond = exp' to something like 'Pattern -> | cond = exp'?
07:45:33 <Axman6> I just use an iPad and enjow the wonders of a great PDF rendering engine =)
07:45:43 <merijn> I just got the 10 inch kindle for reading PDF papers :)
07:45:56 <Axman6> tomejaguar: Pattern | cond -> expr
07:45:57 <merijn> tomejaguar: 7.6, LambdaCase extension
07:46:16 <tomejaguar> merijn: Yeah I don't want the case at all! :)
07:46:18 <Axman6> you use = when it's in a function definition, and -> when it's in case
07:46:24 <tomejaguar> Axman6: Looks good I'll give it a go
07:46:33 <merijn> tomejaguar: Oh, you just want an if with multiple conditions?
07:46:41 <merijn> tomejaguar: 7.6, MultiWayIf extension :)
07:47:19 <yitz> bennofs: for me regular pdfs - in particular haskell papers - look great on my android 7" tablet and are easy to read
07:47:38 <tomejaguar> Axman6: Yup does exactly what I want!
07:47:40 <Axman6> what's Android use for PDF rendering?
07:47:49 <Lethalman> tomejaguar, also XMultiWayIf
07:48:06 <tomejaguar> I was trying to do 'Pattern -> | cond = exp', but I needed 'Pattern | cond -> exp'
07:48:42 <yitz> Axman6: i downloaded an app aptly called PDFReader. but there's a built-in reader (which i didn't know about at the time) which seems to work fine too.
07:48:57 <yitz> Axman6: or are you asking which rendering engine under the hood? no idea.
07:49:18 <yitz> Axman6: popler if i would venture a guess
07:49:38 * hackagebot pointedlist 0.6 - A zipper-like comonad which works as a list, tracking a position.  http://hackage.haskell.org/package/pointedlist-0.6 (JeffWheeler)
07:53:29 <dmj``> tomejaguar: can also pattern match inside cases, w/o extensions
07:53:35 <dmj``> > case 4 of x | x == 4 -> 4; otherwise -> 0
07:53:36 <lambdabot>  4
07:53:37 <osa1> is there an idiomatic way for (\(CFloat f) -> f) ?
07:54:00 <dawik> > (\x -> x + 1) 1
07:54:01 <lambdabot>  2
07:54:23 <dmj``> i mean use guards, not pattern matching
07:54:33 <dawik> haskell is so bootiful
07:54:35 <tncardoso> hi, i am getting ambiguous module name when trying to 'cabal install pngload' (http://lpaste.net/95358) Is there a workaround?
07:55:13 <nadirs> > (+1) 1
07:55:14 <lambdabot>  2
07:55:16 <christiansen> yitz: i think i solved it again, by having sdist make the dummy module, then delete it again when done
07:55:16 <dawik> and elegant
07:55:20 <dawik> nadirs: nice !
07:58:21 <flebron> Hi. When making a binary tree data structure, I can impose a static (compile time) notion of "balance" by mildly-clever use of constructors and DataKinds. Is there a similar way to implement the "binary search tree" property? That is, that if v is a node, and l and r its left and right children respectively, then every node in l < v, and every node in r > v?
07:59:17 <Axman6> I think that requires dependant types
08:00:03 <christiansen> flebron: you might be able to fake it
08:00:31 <christiansen> by using datakinds to track upper and lower bounds of subtrees
08:00:35 <flebron> Ideally I'd like to statically know that no tree can be encoded that violates this invariant.
08:01:45 <Axman6> you can ensure that using smart constructors. it's not checked by the compiler but it is simple enough
08:01:46 <flebron> christiansen: How would I encode that restriction in the types?
08:02:01 <christiansen> i'm terrible at fake dependent types in haskell
08:02:22 <christiansen> but the thing you need to do is represent evidence that one node is less than another
08:02:44 <christiansen> you might need real dependent types
08:03:18 <Axman6> branch :: Ord a => Leaf a -> a -> Leaf a -> Maybe (Leaf a); branch l x r | max l < x && min r > x = Just (Branch l x r) | otherwise = Nothing
08:03:39 <flebron> Yeah :)
08:04:16 * christiansen is much better at thinking type gymnastics in idris than in haskell :-)
08:04:36 <Peaker> flebron: I don't think you can do that, but: https://github.com/yairchu/red-black-tree/blob/master/RedBlackTree.hs#L27-37  does everything *except* that for RB trees
08:04:59 <flebron> Peaker: That's what I imitated when doing this last night: https://github.com/fedelebron/AVL/blob/master/AVL.hs
08:05:06 <Peaker> and https://github.com/yairchu/red-black-tree/blob/master/AvlTree.hs for AVL
08:05:32 <Peaker> ah that looks nice
08:06:03 <flebron> Yeah same ideas :)
08:13:15 <flebron> Would it make sense to finish this up, polish it, and upload it to hackage?
08:13:42 <hhhhhhhh> can i just pretend [GHC.Word.Word8] is ByteString.Char8 in my code
08:13:44 <flebron> (Meaning make it a member of all the typeclasses one reasonably expects it to, write a .cabal, and document it.)
08:14:41 * hackagebot msu 0.0.1 - Monitor Setup Utility  http://hackage.haskell.org/package/msu-0.0.1 (PatrickBrisbin)
08:15:17 <Axman6> hhhhhhhh: ByteStrings aren't a list of Word8, they're a contiguous array of Word8
08:15:35 <Axman6> hhhhhhhh: use Data.ByteString.pack to turn it into a ByteString
08:15:54 <flebron> Also, if there's already a package called Foo.Bar, is it bad manners to name yours Foo.Bar.Baz?
08:16:14 <pranz> flebron: that code looks a lot more like Idris than haskell :p
08:16:34 <hhhhhhhh> Axman6: so to convert [GHC.Word.Word8] to String i need to do: Data.ByteString.Char8.unpack . Data.ByteString.pack
08:16:37 <Axman6> depends on what it does. it's pretty common to do it, if Foo.Bar.Baz extends Foo.Bar
08:17:01 <Axman6> hhhhhhhh: sure. why are you dealing with [Word8] though?
08:17:03 <osfameron> or if you're bring passive-aggressive:  Foo.Bar.Simple or Foo.Bar.ButMaintained
08:17:15 <pavonia> flebron: Such naming is very common, so I guess it's not that bad
08:17:19 <hhhhhhhh> Axman6 http://hackage.haskell.org/package/hopenssl-1.6.2/docs/OpenSSL-Digest.html
08:17:43 <flebron> In my case it would have no implementation shared, there's a library Data.Tree.AVL which is a dynamically-maintained invariant, and I'd make Data.Tree.AVL.Static, which ensures the invariant statically
08:18:18 <yitz> hhhhhhhh: that's not the best way to convert [Word8] to String
08:20:17 <yitz> hhhhhhhh: really you want to use a decoder from Data.Text.Encoding or the icu library to convert a ByteString to Text. but if you want just naive ascii decoding, you can always just do map (toEnum . fromIntegral)
08:27:08 <snizzo> Are there cases in which Prelude.Left>Prelude.Right  is True?
08:27:41 <christiansen> yitz: tests passed, now I can go home :)  thanks again
08:27:51 <bennofs> snizzo: No
08:28:17 <yitz> yay
08:28:32 <bennofs> snizzo: Earlier constructors always compare less than later defined constructors
08:29:10 <snizzo> oh sorry I meant like... Left 4 > Right 5 returnsTrue?
08:29:19 <Peaker> bennofs: with "deriving Ord" you mean
08:29:28 <yitz> > Left 4 > Right 5
08:29:29 <lambdabot>  False
08:29:44 <yitz> > Right 4 > Left 5
08:29:45 <lambdabot>  True
08:29:52 <flebron> Long shot but, does anyone know "Adrian Hey"? He's a maintainer of a hackage lib I'd like to contact, but everything about him on google stops circa 2008 O.o
08:30:41 <ziman> > Left undefined > Right undefined
08:30:42 <lambdabot>  False
08:31:31 <Axman6> > [minBound .. maxBound] :: [Either Bool Bool]
08:31:32 <lambdabot>  No instance for (GHC.Enum.Enum
08:31:32 <lambdabot>                     (Data.Either.Either GHC.Types.Bool GHC.Types.Bool))
08:31:32 <lambdabot>    arising from the arithmetic sequence `GHC.Enum.minBound .. GHC.Enum.maxBound'
08:31:32 <lambdabot>  Possible fix:
08:31:32 <lambdabot>    add an instance declaration for
08:31:37 <Axman6> :(
08:31:50 <aristid> :t \x y -> Left x > Right y
08:31:51 <lambdabot> (Ord a, Ord b) => a -> b -> Bool
08:32:09 <yitz> > Right "snizzo" > Left "ziman"
08:32:11 <lambdabot>  True
08:32:17 <Axman6> > sort [f x | f <- [Left, Right], x <- [()]]
08:32:18 <lambdabot>  [Left (),Right ()]
08:32:40 <snizzo> yitz: http://lpaste.net/97880 I got this piece of code and I can't get why it gets into otherwise case
08:33:29 <haasn> Axman6: enumFromThenTo (Left 3) (Right 1) (Right 7) = ?
08:33:39 <aristid> > compare (Right "a") (Right 4)
08:33:40 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
08:33:40 <lambdabot>    arising from the literal `4'
08:33:40 <lambdabot>  Possible fix:
08:33:40 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])
08:33:48 <pavonia> snizzo: For what input?
08:33:58 <haasn> Or, well, enumFromTo (Left 3) (Right 7)
08:34:06 <hhhhhhhh> is haskell having literally 1 million types of string something that stops being annoying
08:34:14 <yitz> pavonia: it should never reach the otherwise clause for any input
08:34:31 <pavonia> yitz: Yes, that's why I'm asking
08:34:34 <aristid> hhhhhhhh: if by 1 million you mean 2, yes, it keeps being slightly annoying.
08:34:46 <yitz> snizzo: i'll bet you think it is but it's really not.
08:35:48 <snizzo> yitz: you won
08:36:06 <yitz> heh
08:36:52 <mreh> quicksilver: didn't you implement a reactive at some point?
08:36:58 <quicksilver> yes
08:37:02 <quicksilver> partially.
08:37:22 <mreh> quicksilver: any progress on an efficient implementation yet?
08:37:37 <quicksilver> no progress at all in the last few years
08:37:42 <quicksilver> been busy with other stuff
08:37:57 <mreh> quicksilver: that's fair enough
08:38:03 <yitz> quicksilver: do you think the new lvar stuff would help?
08:38:12 <Axman6> hhhhhhhh: for text data, there's String and Text, for binary data there's ByteString. that's about it these days
08:38:25 <mreh> I would like to help, but I'm not sure what I can offer
08:38:53 <mreh> a sense of enthusiasm and a keen pair of eyes/hands?
08:39:57 <quicksilver> yitz: I don't know. It is not obvious to me that they do.
08:40:34 <quicksilver> the challenges that struck me - in a direct implementation - was the degree of trust you put in the thunk/GC/demand-driven-evaluation system to keep your data flowing
08:40:57 <quicksilver> and that the current RTS doesn't make it particularly easy for you to check that's running smoothly or understand how it degrades when you reach limits
08:41:09 <quicksilver> but I never pushed hard enough against those limits to have a more intelligent analysis
08:41:15 <yitz> quicksilver: it appears to be a principled approach to implementing unamb, and evidence that unamb doesn't really make sense for types for which lvars can't be defined.
08:41:54 <yitz> quicksilver: i.e. that it's not just an implementation detail of the runtime.
08:42:10 * quicksilver didn't trust unamb and, therefore, didn't use it.
08:42:19 <yitz> oh i see.
08:42:23 <quicksilver> I might have been wrong though.
08:42:26 <yitz> that was good intuition :)
08:42:39 <quicksilver> my modelling had explicit IO in some places
08:42:54 <quicksilver> although the ordinary usage of reactives was still completely combinator driven and pure
08:43:04 <quicksilver> but the 'execution' of Futures was honest about its IO
08:43:11 * yitz nods
08:43:18 <quicksilver> users didn't generally need to touch that bit, except when writing new Event sources e.g.
08:43:28 <mreh> when I played with it, the RTS was hanging on to a lot of memory
08:43:33 <quicksilver> yes, mreh
08:43:36 <mreh> and it wasn't being GCed
08:43:48 <quicksilver> I made one example which GCed perfectly
08:43:53 <quicksilver> but I had to tweak things to make it work
08:43:59 <quicksilver> which is the point I was making above
08:44:46 * hackagebot metricsd-client 0.1 - Client for the metrics aggregator Metricsd  http://hackage.haskell.org/package/metricsd-client-0.1 (JanVornberger)
08:45:34 <mreh> quicksilver: you had to tweak your choice of combinators?
08:45:46 <quicksilver> I can't remember :(
08:45:54 <quicksilver> I think I had to put some explicit forcing somewhere
08:46:05 <quicksilver> to stop a thunk building up just because it didn't happen to be inspected.
08:46:23 <avaritia> has anyone tried embeding haskell as an interpreter in an app?
08:46:29 <quicksilver> basically if one of your behaviours is never observed
08:46:35 <quicksilver> then it builds deeper and deeper thunks
08:46:45 <fizbin> avaritia: besides mu-eval?
08:46:57 <quicksilver> this is quite annoying because a very distant change can make something go from observed to unobserved.
08:46:59 <RustyShackleford> i find the indentation rules for haskell kind of wierd
08:47:11 <RustyShackleford> everything is so wierd
08:47:21 <RustyShackleford> why was I going to learn haskell again?
08:47:32 <fizbin> I do find myself occasionally wishing that the ghc runtime had better options for controlling thunk depth.
08:47:37 <avaritia> fizbin: thx
08:47:42 <Saizan> RustyShackleford: it's about alignment more than indentation
08:47:52 <Phlogistique> RustyShackleford: you can avoid them altogether with {;}
08:48:29 <mreh> quicksilver: did you have your work on a github or an FTP server somewhere?
08:48:43 <quicksilver> nope
08:48:47 <quicksilver> it's in a mailing list archive :)
08:49:00 <mreh> Jules... Bean?
08:50:37 <Axman6> RustyShackleford: the rules are really simple once you learn them
08:52:20 <quicksilver> mreh: http://www.haskell.org/pipermail/reactive/2008-December/000139.html and http://www.haskell.org/pipermail/reactive/2009-March/000253.html
08:53:27 <RustyShackleford> i think my head is going to explode
08:53:50 <quicksilver> fizbin: controlling and also inspecting
08:54:10 <quicksilver> fizbin: it's hard to understand the runtime evolution of programs which use complex structures of thunks "implicitly"
08:54:50 <quicksilver> fizbin: higher-order combinator style abstractions allow us to present a simple way to compose very complicated evaluation structures -- but when it goes wrong, the tools don't make it easy to debug.
08:54:54 <quicksilver> or that's what I found
08:55:10 <quicksilver> and that pushes us back to more imperative style programming models simply becayse we understand how to debug them. Which would be a shame.
09:00:06 <mietek> dist/dist-sandbox-2ecd6704/build/Crypto/Skein/Internal.hs:6:3:
09:00:06 <mietek>      error: invalid preprocessing directive
09:00:06 <mietek>      #-}
09:00:13 <mietek> eh?
09:00:19 <mietek> Am I missing some preprocessor package?
09:00:51 <hhhhhhhh> how can i pass a unix timestamp (integer) to formattime
09:01:05 <fizbin> quicksilver: I do remember watching a talk by someone who had implemented an OS in Haskell and his big take-aways were that enforced purity turned out to be a net positive, albeit in initially unexpected ways, but that laziness was a royal PITA he found himself constantly needing to work around for that kind of work.
09:02:03 <danilo2> Hello! I'm refactorig some code and want to make better usage of types. I've got AST, which got something like data Decl = .. | DataD { ..., tp :: Type, ... } (data declaration with type) and data Type = ..
09:02:10 <fizbin> I understand why explicit laziness markers aren't as a practical measure sufficient, but...
09:02:22 <danilo2> Ouch I pressed enter accidentaly - I'll finish the question, brb
09:02:53 <ocharles> mietek: ENEEDTOSEEMORECODE
09:03:19 <mietek> ocharles: cabal install snap
09:03:20 <mietek> :(
09:03:30 <ocharles> Which GHC?
09:03:41 <mietek> ocharles: 7.6.3
09:04:12 <mietek> ocharles: I literally did  cabal update && cabal sandbox init && cabal install snap
09:04:26 <mietek> snap-0.13.1.2 depends on skein-1.0.8 which failed to install.
09:04:27 <Guest22323> Is is expensive to use Data.Text.pack and Data.Text.unpack?  Should I try to reduce the number of times I do that?
09:04:56 <mietek> https://github.com/snapframework/snap-core/issues/185
09:05:07 <ocharles> mietek: that file looks weird...
09:05:15 <Axman6> Guest22323: it's probably a good idea to avoid it
09:05:18 <mietek> https://github.com/meteficha/skein/issues/12
09:05:30 <ocharles> oh wait, that's just weird {-# LINE #-} stuff
09:06:09 <ocharles> mietek: I guess try from source then
09:06:32 <ocharles> mietek: are you on OS X?
09:06:40 <mietek> Yep, and yep, and also hi :)
09:06:45 <ocharles> hello :)
09:06:59 <ocharles> mietek: make sure to nag meteficha on that issue to release a new version
09:07:50 <Guest22323> Axman6: I'm not sure because the docstrings mention O(n) as well as "subject to fusion."  From the Data.Text module: "Most of the functions in this module are subject to fusion, meaning that a pipeline of such functions will usually allocate at most one Text value."
09:07:53 <bennofs> Ah, I need pipes-xml, pipes-http and pipes-html! :(
09:08:42 <bennofs> Guest22323: it means that if after inlining, if you have T.pack . T.unpack . T.pack, that will probably be fused away to just id. But why do you need to pack/unpack anyway?
09:08:58 <Guest22323> bennofs: Ah, OK.
09:09:15 <danilo2> Hello! I'm refactorig some code and want to make better usage of types. I've got AST (see the sample code here: http://lpaste.net/97882). I'm thinking what should be better form - I know, that field "tp" of DataD is for sure "DataT something". The current types does not show this.
09:09:20 <danilo2> On the other hand, after refactoring, we get some nested structures, which are a lot longer and harder to use. What is the "right" way to code such data structures?
09:09:30 <Guest22323> bennofs: Some functions I have to use work only on String while others work only on Text.  And main have to return String.
09:09:56 <Axman6> main returns () ...
09:09:57 <bennofs> Guest22323: main has to return String? Why is that? Have you looked at Data.Text.IO ?
09:10:37 <aristid> bennofs: you could probably easily build a pipes-xml upon http-client, which is a refactored http-conduit without any conduit dependencies
09:10:55 <aristid> pipes-http i mean
09:10:56 <Guest22323> Axman6, bennofs: Sorry, I meant that I have to use putStr, which accepts String.
09:11:26 <Guest22323> bennofs: Ah, no. I haven't.
09:11:35 <hhhhhhhh> how do i convert an Integer to a NominalDiffTime
09:11:48 <donri> :t fromInteger
09:11:49 <lambdabot> Num a => Integer -> a
09:13:20 <Axman6> Guest22323: Text supplies functions for Text IO in Data.Text.TextIO I believe
09:13:23 <hhhhhhhh> donri thanks
09:13:25 <Axman6> Text.IO*
09:13:45 <Guest22323> Axman6: Yeah, thanks. bennofs has already mentioned it.
09:14:00 <Jack93> Hi!
09:14:06 <Jack93> I've been going through Hutton's Haskell book
09:14:18 <Guest22323> Axman6: I guess I'll convert into Text once and work with that.
09:14:21 <Jack93> he is using an (n + 1) pattern in some examples, such as:
09:14:22 <Jack93> pred 0 = 0, pred (n+1) = n
09:14:26 <Jack93> But this doesn't compile
09:14:31 <Jack93> Am I doing something wrong?
09:14:33 <shachaf> Jack93: That's been deprecated in Haskell.
09:14:38 <Jack93> Oh.
09:14:41 <Jack93> When was that?
09:14:47 <shachaf> 2010, probably.
09:14:49 * hackagebot persistent-sqlite 1.3.0.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.3.0.1 (MichaelSnoyman)
09:14:57 <Jack93> OK, thanks for the info!
09:15:00 <shachaf> Try pred n = n - 1 instead.
09:18:27 <bennofs> > pred 0
09:18:28 <lambdabot>  -1
09:18:33 <bennofs> > pred (0 :: Word8)
09:18:35 <lambdabot>  *Exception: Enum.pred{Word8}: tried to take `pred' of minBound
09:18:47 <bennofs> > pred (-1 :: Word8)
09:18:48 <lambdabot>  254
09:22:42 <mreh1> :t pred
09:22:43 <lambdabot> Enum a => a -> a
09:22:59 <mreh1> :t  (-1)
09:23:00 <lambdabot> Num a => a
09:23:41 <danilo2> Hello! I'm refactorig some code and want to make better usage of types. I've got AST (see the sample code here: http://lpaste.net/97882). I'm thinking what should be better form - I know, that field "tp" of DataD is for sure "DataT something". The current types does not show this.
09:23:42 <danilo2> On the other hand, after refactoring, we get some nested structures, which are a lot longer and harder to use. What is the "right" way to code such data structures?
09:24:12 <zennist> hi I got parse error for filter (not . `elem` list) list2
09:24:28 <zennist> but filter (`elem` list) list2 works fine
09:24:36 <zennist> can't understand what's wrong here
09:26:01 <conehead> > filter (not . (`elem` [1..5])) [3..8]
09:26:02 <lambdabot>  [6,7,8]
09:26:05 <Guest22323> Should I use Text instead of String when dealing with large amounts of textual data?
09:26:07 <geekosaur> that parses as trying to apply (.) as a parameter to elem. you must ues parentheses around a section, (not . (`elem` list))
09:26:25 <zennist> okay thanks!
09:26:59 <bennofs> Guest22323: yes
09:27:04 <geekosaur> you can think of it as being related to naming an operator as a function (e.g. (+))
09:27:13 <geekosaur> where you insert a parameter on one side
09:27:36 <bennofs> Guest22323: Text uses a more efficient representation of strings than the simple linked-list-of-char that String uses.
09:27:59 <c_wraith> Guest22323: if you're going to perform text manipulations on it, then yes, use Text.  If you're just going to store and forward data, and not even change encodings, use ByteString.
09:29:16 <Guest22323> bennofs: OK, could you explain this (from Data.Text): "Those functions will substitute Char values that are not valid Unicode scalar values with the replacement character "�" (U+FFFD)."  Does it mean that I may lose some data?  Would String do the same?  Should I be concerned about invalid values at all?
09:29:39 <Guest22323> c_wraith: Yep, I'm going to perform text manipulations.
09:29:40 <bitemyapp> http://awelonblue.wordpress.com/2012/10/21/local-state-is-poison/
09:30:23 <fizbin> Wait, how can Char values not be valid Unicode values? Are there Char values that fall in the surrogate range?
09:30:34 <Guest22323> fizbin: I have no idea.
09:30:43 <fizbin> Or is Char bigger than the Unicode scalar range?
09:30:56 <bennofs> > maxBound :: Char
09:30:57 <lambdabot>  '\1114111'
09:31:08 <bennofs> > T.pack [maxBound :: Char]
09:31:09 <aristid> fizbin: sounds like a case of looking at the code :D
09:31:09 <lambdabot>  Not in scope: `T.pack'
09:31:10 <lambdabot>  Perhaps you meant `BS.pack' (imported from Data.ByteString)
09:31:19 <bennofs> @let import qualified Data.Text as T
09:31:19 <lambdabot>  .L.hs:104:1:
09:31:20 <lambdabot>      Data.Text: Can't be safely imported!
09:31:20 <lambdabot>      The package (text-0.11.3.1) the module resides in isn't trusted.
09:31:23 <quicksilver> > 2^24
09:31:24 <lambdabot>  16777216
09:31:30 <aristid> > chr (2^24)
09:31:31 <lambdabot>  *Exception: Prelude.chr: bad argument: 16777216
09:31:42 <fizbin> > maxBound :: Char
09:31:43 <lambdabot>  '\1114111'
09:32:24 <c_wraith> fizbin: Char is a machine word internally.  Constructors limit the allowed range
09:32:38 <fizbin> > showIntAtBase 16 intToDigit 1114111 ""
09:32:39 <lambdabot>  "10ffff"
09:32:44 <aristid> "UTF-16 surrogate code points are not included in the set of Unicode scalar values, but are unfortunately admitted as valid Char values by Haskell. They cannot be represented in a Text. This function remaps those code points to the Unicode replacement character (U+FFFD, '�'), and leaves other code points unchanged."
09:33:13 <fizbin> Ah, so it is surrogate values.
09:33:37 <aristid> http://hackage.haskell.org/package/text-1.0.0.1/docs/src/Data-Text-Internal.html look for safe :: Char -> Char
09:34:29 <aristid> hmm surrogate values being in Char doesn't make much sense
09:34:53 <aristid> i guess it's so Char is a continuous range of values?
09:34:55 <bennofs> @ty mapping
09:34:57 <lambdabot> (Functor f, Functor f1, Profunctor p) => AnIso s t a b -> p (f a) (f1 (f b)) -> p (f s) (f1 (f t))
09:35:13 <fizbin> So, I wouldn't worry about what gets dropped unless you are handling data poorly converted from a UTF-16 stream, or are not actually handling text but are handling serialized strings from some language with 16-bit characters, such as java String objects.
09:35:36 <Guest22323> fizbin: Yeah, I feel the same way.
09:35:51 <aristid> lol a fail encoding http://en.wikipedia.org/wiki/CESU-8
09:35:51 <fizbin> Since java's Strings have no issue containing unmatched UTF-16 surrogates.
09:36:03 <Guest22323> Thanks for clarifying!
09:36:59 <fizbin> I've come to the conclusion that except for in-memory representation, where UTF-32 might be a reasonable choice, all encodings that are not UTF-8 are wrong.
09:38:16 <fizbin> Basically, there's three choices for character encoding: explicitly ASCII-only, UTF-8, and WRONG. Anyone trying to tell you otherwise better be pointing at some very explicit legacy interface requirements when doing so.
09:38:43 <fizbin> (And even then, "legacy" can be considered one possible subset of "WRONG")
09:38:43 <geekosaur> sadly Java is not "legacy"
09:38:59 <pseudolio> All text is English.
09:39:15 <pseudolio> Am I rite?
09:39:20 <aristid> Text uses UTF-16, but i think it uses it mostly correctly
09:39:38 <aristid> pseudolio: no, there are also european languages. cannot ignore those.
09:39:42 <fizbin> geekosaur: No, but Java code writing input or output not in UTF-8 is doing it wrong.
09:40:04 <geekosaur> indeed. I very carefully did not say that it is not WRONG :p
09:40:29 <aristid> fizbin: utf-16 in files is probably not a good idea indeed; but i guess that properly compressed utf-32 might not be that bad actually
09:40:59 <cdk> could someone please provide an lpaste of the Category and Arrow instance for newtype Hyper b c = Hyper { runHyper :: Hyper c b -> c } ? I've been unable to figure it out
09:41:31 <fizbin> So... okay, I guess I can also admit that there are situations where UTF-16 makes sense as an in-memory encoding, though that should be accompanied by a careful rationale  as to why memory is too expensive to use UTF-32 as the in-memory representation.
09:43:21 <fizbin> aristid: Compressed UTF-32 only makes sense if it's done because what the file really is is a compressed memory dump, and so you don't actually have a text file at all.
09:44:13 <aristid> fizbin: text files are obsolete anyways:)
09:46:44 <fizbin> That I'm not sure about. ASCII Text files are *the* standard long-term-viable archival digital format. I can read 40-year-old ASCII text files without any special conversion software, and I have every reason to believe that that will be the case 40 years from now as well.
09:47:33 <RustyShackleford> thats interesting
09:47:50 <fizbin> At this point, I'd be willing to bet on the multi-decade viability of UTF-8 plain text as well. Anything else... I'm not so sure.
09:47:52 <RustyShackleford> .txt is basically futureproof
09:50:11 <fizbin> I guess I should qualify that with "I can read 40-year-old ASCII text files assuming that the system they were on had 8-bit bytes, or that there's been a 7-bit-byte to 8-bit-byte conversion done"
09:50:57 <aristid> fizbin: probably the hardest problem for those old machines is getting a reader for those weird floppy drives ;)
09:51:31 <RustyShackleford> so I can't seem to code anything without loops
09:51:44 <fizbin> Floppies? I'm talking reel-to-reel tape drives here.
09:52:00 <RustyShackleford> given a string "to be or not to be", I want to output TOBEORNOTTOBE
09:52:00 <fizbin> Either that, or dishwasher-sized hard drives.
09:52:05 <aristid> fizbin: ok i don't know when exactly they started with floppies
09:52:17 <RustyShackleford> how might you do this?
09:52:43 <aristid> > map toUpper . filter isAlpha $ "to be or not to be"
09:52:44 <lambdabot>  "TOBEORNOTTOBE"
09:53:08 <fizbin> RustyShackleford: The typical way to do this is by pattern-match recursion, if you want to do it "from scratch"
09:53:15 <geekosaur> > concat . map toUpper . unwords $ "to be or not to be"
09:53:16 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[a0]'
09:53:16 <lambdabot>  Expected type: GHC.Types.Char -> [a0]
09:53:16 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Types.CharCouldn't match type `GHC.Type...
09:53:16 <lambdabot>  Expected type: [GHC.Base.String]
09:53:16 <lambdabot>    Actual type: [GHC.Types.Char]
09:53:19 <geekosaur> whoops
09:53:36 <geekosaur> > concat . unwords . map toUpper $ "to be or not to be"
09:53:37 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[a0]'
09:53:37 <lambdabot>  Expected type: [GHC.Base.String] -> [[a0]]
09:53:37 <lambdabot>    Actual type: [GHC.Base.String] -> GHC.Base.StringCouldn't match type `GHC....
09:53:37 <lambdabot>  Expected type: GHC.Types.Char -> GHC.Base.String
09:53:37 <lambdabot>    Actual type: GHC.Types.Char -> GHC.Types.Char
09:53:40 <aristid> geekosaur: i think mine was more elegant
09:53:47 <geekosaur> I am doing real well tday :/
09:53:55 <aristid> compared to the version you'll fix up at some point
09:54:04 <geekosaur> probably, the qyestion might be which one is closer to what they actually want
09:54:19 <aristid> > concatMap (map toUpper) . unwords $ "to be or not to be"
09:54:20 <lambdabot>  Couldn't match type `GHC.Types.Char' with `[GHC.Types.Char]'
09:54:20 <lambdabot>  Expected type: [GHC.Base.String] -> [[GHC.Types.Char]]
09:54:20 <lambdabot>    Actual type: [GHC.Base.String] -> GHC.Base.StringCouldn't match type `GHC....
09:54:20 <lambdabot>  Expected type: [GHC.Base.String]
09:54:20 <lambdabot>    Actual type: [GHC.Types.Char]
09:54:24 <aristid> ah well:D
09:54:31 <fizbin> RustyShackleford: e.g. MyFunc ' ':xs = MyFunc xs ; MyFunc x:xs = toUpper x : MyFunc xs ; MyFunc [] = []
09:54:40 <aristid> lambdabot is too spammy, was it always like that?
09:55:09 <aristid> fizbin: but i thought he wanted a version without loops?
09:55:12 <fizbin> > let MyFunc ' ':xs = MyFunc xs ; MyFunc x:xs = toUpper x : MyFunc xs ; MyFunc [] = [] in MyFunc "to be or not to be"
09:55:13 <lambdabot>  Not in scope: data constructor `MyFunc'Not in scope: data constructor `MyFun...
09:55:13 <lambdabot>  Bound at: <interactive>:1:16-17
09:55:13 <lambdabot>            <interactive>:1:42-43Not in scope: data constructor `MyFunc'Not in...
09:55:29 <aristid> MyFunc is not a type construcotr.
09:56:02 <fizbin> > let myFunc ' ':xs = myFunc xs ; myFunc x:xs = toUpper x : myFunc xs ; myFunc [] = [] in myFunc "to be or not to be"
09:56:03 <lambdabot>  <hint>:1:5: Parse error in pattern: myFunc
09:56:23 <fizbin> Oh stupid parens. Anyway, add some parens, that's the idea.
09:56:26 <aristid> for complicated code, it can make sense to query lambdabot first. i am guilty of not doing this too, of course
09:57:14 <RustyShackleford> okay, lets see if I understand this notation right: x:xs
09:57:16 <fizbin> aristid: I'm not sure what RustyShackleford is counting as "without loops"
09:57:29 <aristid> geekosaur: lol i found the second problem with your code. use words, not unwords :)
09:57:29 <RustyShackleford> x would be the head of a list, xs would be the tail/remainder
09:57:36 <geekosaur> yeh
09:57:50 <geekosaur> I am not brainful today, still catching up on lost sleep
09:57:51 <RustyShackleford> fizbin, I was referring to imperative languages
09:57:57 <aristid> geekosaur: and of course the need for map-map, not the single map, but i already tried to fix that the first time
09:58:06 <RustyShackleford> that tends to be the way I attack problems
09:58:19 <RustyShackleford> I'm out of my comfort zone, haha
09:58:21 <fizbin> > let myFunc (' ':xs) = myFunc xs ; myFunc (x:xs) = toUpper x : myFunc xs ; myFunc [] = [] in myFunc "to be or not to be"
09:58:22 <lambdabot>  "TOBEORNOTTOBE"
09:58:35 <ChongLi> RustyShackleford: Haskell has loops, too :)
09:59:27 <fizbin> Whether tail-recursion like that counts as a "loop" or not can depend on where/when you learned about loops and how that's explained.
10:00:50 <ChongLi> well, what about tail-recursion in the IO monad?
10:01:00 <ChongLi> that's basically a loop with side effects :)
10:01:03 <aristid> RustyShackleford: ah, so you were interested in the by-foot way as fizbin showed? or also the high-level version that geekosaur and I showed?
10:01:04 <RustyShackleford> if you want to emulate like: for (int i = 0; i < 10; i++), whats the idiomatic way to do it?
10:01:23 <aristid> map foo [0..9]
10:01:27 <ChongLi> RustyShackleford: but what does that do?
10:01:28 <scooty-puff> for [0 .. 9] $ \ i -> ...
10:01:28 <shachaf> forM_ [0..9]
10:01:50 <shachaf> Or for_. Probably not for.
10:02:48 <aristid> :t for
10:02:49 <lambdabot>     Not in scope: `for'
10:02:49 <lambdabot>     Perhaps you meant one of these:
10:02:49 <lambdabot>       `T.for' (imported from Data.Traversable),
10:02:55 <aristid> :t T.for
10:02:55 <lambdabot> (Applicative f, Traversable t) => t a -> (a -> f b) -> f (t b)
10:03:13 <aristid> looks like for is just flip mapM for applicatives?
10:03:18 <ChongLi> yeah
10:03:22 <aristid> and traversables
10:04:02 <aristid> RustyShackleford: but which way is the best one really depends on what is in the loop
10:04:38 <qrada> hey, i'm just messing around and want to see some of the intermediate files that are generated,im passing -keep-* flags, but the only thing I ever get is .o and .hi.. i want to see the C/llvm files if possible. any idea?
10:05:11 <shachaf> qrada: Probably the intermediate files are going in /tmp?
10:05:25 <qrada> ya i checked there too, nothing in the /tmp/ghc* directories, they are empty
10:05:26 <shachaf> Try -tmpdir blah
10:05:29 <qrada> im using -keep-tmp-files too
10:05:34 <shachaf> And -keep-tmp-files
10:05:38 <shachaf> OK.
10:05:56 <shachaf> Well, if you're not using LLVM, you wouldn't expect GHC to generate LLVM files.
10:06:11 <shachaf> And GHC doesn't compile via C (though there might be some C generated anyway in some cases).
10:06:20 <shachaf> But you should be seeing intermediate files.
10:07:04 <qrada> im using Glasgow Haskell Compiler, Version 7.6.3, stage 2 booted by GHC version 7.4.1... ya nothing ends up 'staying' in the tmp dirs
10:08:20 <geekosaur> there shouldn't be any intermediate C files either unless you're using the FFI or -fvia-C
10:08:21 <shachaf> Even with "ghc -keep-tmp-files -tmpdir . foo.hs"?
10:08:28 <geekosaur> -fasm does not compile to C
10:08:56 <shachaf> geekosaur: There might still be intermediate C files.
10:09:11 <shachaf> Like a file with main() that just calls hs_main().
10:09:30 <shachaf> At least, that's what I saw.
10:10:09 <qrada> sorry, laptop freaked out. ghc -keep-tmp-files -tmpdir . test.hs, yields test.o test.hi and test, also a directory ghcXXXX which is empty
10:10:26 <qrada> sounds normal or.. ?
10:10:26 <shachaf> Hmm.
10:10:34 <shachaf> For me it is not empty.
10:10:44 <shachaf> It has .o/.s/.c files.
10:11:01 <shachaf> Wait, are you sure you're actually compiling the file?
10:11:08 <qrada> ya hah.. for sure
10:11:10 <qrada> it is ;f
10:11:11 <shachaf> Delete your .hi/.o file. GHC could just not be wasting work.
10:11:13 <qrada> odd..
10:11:22 <shachaf> Or compile with -fforce-recomp.
10:11:56 <shachaf> If it doesn't actually say "Compiling ..." then it's probably not compiling.
10:13:10 <qrada> ok so that's my fault, it wasn't actually recompiling
10:13:18 <qrada> -fforce-recomp worked
10:13:18 <qrada> nice!
10:13:39 <shachaf> Maybe GHC should print a message when it doesn't compile.
10:20:24 <mkscrg> Hey all. The GHC docs suggest a type families pattern that replaces functional dependencies. Is this "the right way" these days? Is there a reason to avoid the fundeps extension/syntax?
10:20:55 <aristid> mkscrg: no, both functional dependencies and type families appear to be here to stay
10:22:33 <mkscrg> aristid: cool, thanks
10:23:05 <geekosaur> one of the things that now distinguishes the two is that type families can be closed
10:23:27 <bennofs> What exception does GHC throw when I press Ctrl-C?
10:23:55 <bennofs> Ah, found it: UserInterrupt
10:24:24 <aristid> i think the most basic advantages of each are that type families don't require leaking the additional "type parameters" everywhere, and fundeps can often result in more succinct code
10:29:35 <dagano> how would I do a seemingly imperative task such as : incrementing some accumulator if the ith value in a list is different from the (i-1)th?
10:30:53 <fizbin> dagano: you need to rephrase your question.
10:31:17 <dagano> i do?
10:31:17 <fizbin> The thing is, "increment" is an inherently imperative concept.
10:31:23 <dagano> right, i am aware of that
10:31:35 <flebron> dagano: You can carry your state while you recurse, and sometimes change your state, sometimes not change your state.
10:31:49 <fizbin> Do you mean "how to count the number of places where the ith spot differs from the i-1 - th spot?
10:31:50 <Lethalman> :t Data.List.Ordered.nub
10:31:51 <lambdabot> Couldn't find qualified module.
10:32:03 <dagano> i am learning about the state monad right now .. so i assume that is the way to go
10:32:26 <Lethalman> dagano, I guess length (Data.List.Ordered.nub list) - length list -- could be interesting
10:32:28 <Lethalman> ops
10:32:32 <Lethalman> negate
10:32:37 <dagano> fizbin: i guess that would be a more declarative way of putting it
10:32:54 <Lethalman> that's the number of equals to i-1 though
10:33:28 <bennofs> lambdabot > fst $ foldl (\(acc, lastVal) currVal -> if Just currVal == lastVal then (succ acc, Just currVal) else (acc, Just currVal)) (0, Nothing) [1,2,3,4,4,5,6]
10:33:32 <fizbin> dagano: So what you're asking about seems like a classic case of "fold" .
10:33:32 <bennofs> > fst $ foldl (\(acc, lastVal) currVal -> if Just currVal == lastVal then (succ acc, Just currVal) else (acc, Just currVal)) (0, Nothing) [1,2,3,4,4,5,6]
10:33:34 <lambdabot>  1
10:33:52 <threestrikes> exit
10:33:55 <threestrikes> :quit
10:34:05 <fizbin> dagano: While you can probably write your fold in a verbose fashion in the state monad, that feels like overkill.
10:34:08 <S11001001> just the length of nub then
10:34:18 <Lethalman> what I'm saying :S
10:34:32 <Lethalman> Data.List.Ordered.nub
10:34:38 <ParahSailin> @let {dagano a [] = a; dagano a (s:p:q) = if s == p then dagano (a+1) (p:q) else dagano a (p:q)}
10:34:39 <lambdabot>  .L.hs:146:1: Warning:
10:34:39 <lambdabot>      Pattern match(es) are overlapped
10:34:39 <lambdabot>      In an equation for `dagano':
10:34:39 <lambdabot>          dagano a [] = ...
10:34:39 <lambdabot>          dagano a (s : (p : q)) = ...
10:34:41 <dagano> :t Data.List.Ordered.nub
10:34:41 <lambdabot> Couldn't find qualified module.
10:35:05 * flebron doesn't think so, since we understand what he wants to do.
10:35:54 <bennofs> > dagano 0 [1,2,3,4,5,4,5,5,6,7,7]
10:35:57 <lambdabot>  *Exception: L.hs:(146,1)-(148,63): Non-exhaustive patterns in function dagano
10:36:10 <flebron> dagano: f (x:y:ys) = f (y:ys) (if x == y then i else i + 1)
10:36:18 <Lethalman> > length . nub $ [1,1,1,2,2,3,4,5,5,6]
10:36:19 <lambdabot>  6
10:36:51 <bennofs> > S.length $ S.fromList [1,1,3,4,4,2,3,3]
10:36:52 <lambdabot>  Not in scope: `S.length'
10:36:52 <lambdabot>  Perhaps you meant one of these:
10:36:52 <lambdabot>    `P.length' (imported from Prelude),
10:36:52 <lambdabot>    `BS.length' (imported from Data.ByteString),
10:36:52 <lambdabot>    `BSC.length' (imported from Data.ByteString.Char8)
10:36:58 <bennofs> > S.size $ S.fromList [1,1,3,4,4,2,3,3]
10:36:58 <lambdabot>  4
10:37:08 <flebron> And f [y] i = i, f [] y = i.
10:37:17 <Lethalman> bennofs, that should be 5
10:37:19 <flebron> Err, f [] i = i.
10:37:33 <dagano> flebron: ah
10:37:48 <bennofs> so just length . group?
10:37:55 <ParahSailin> @let {dagano a [] = a; dagano a [s] = a; dagano a (s:p:q) = if s == p then dagano (a+1) (p:q) else dagano a (p:q)}
10:37:56 <lambdabot>  Defined.
10:37:58 <Lethalman> bennofs, also yes
10:37:59 <bennofs> > length . group $ [1,1,3,4,4,2,3,3]
10:38:00 <lambdabot>  5
10:38:06 <ParahSailin> > dagano 0 [1,2,3,4,5,4,5,5,6,7,7]
10:38:07 <lambdabot>  2
10:38:15 <flebron> dagano: You don't need the state monad for this.
10:38:16 <S11001001> bennofs: that doesn't satisfy the adjacency constraint
10:38:27 <dagano> :t group
10:38:28 <lambdabot> Eq a => [a] -> [[a]]
10:38:35 <Lethalman> S11001001, why not?
10:38:43 <Lethalman> isn't group grouping adjacent elements?
10:39:05 <Lethalman> it does adjacently
10:39:09 <S11001001> Lethalman: ah, I was referring to the S bits
10:42:01 <dagano> thanks .. as always .. i'll copy the above and reread it 100 times.
10:47:42 <danharaj> edwardk: what is the best lib for writing shell scripts in Haskell?
10:50:31 <aristid> there are multiple?
10:52:27 <fl00r> can anybody recommend some resources or libraries for doing data transformation for database prep (etl)? I've looked on the goog and hackage anc can't turn up much...
10:53:29 <fl00r> it may be too general of a thing or maybe just needs a combination of tools like one of the csv libraries, a database library, and some glue
10:57:14 <fl00r> for an idea of the scale, we have on the order of 1000s of files total, none of which are too large to fit in memory on a normal desktop individually
10:57:50 <fl00r> and i'd like to automate the terrible process we're using now (and the right answer may be just to write something myself)
10:58:34 <ocharles> tomejaguar: hey, did you post about (| |) and arrows at somepoint?
11:08:26 <bennofs> Is there something like criterion, but for whole programs, maybe also measuring memory usage?
11:11:37 <FliPPeh> Good practice question: Are exceptions discouraged? If I'm already in the IO monad (because I'm dealing with the network), is it "unhaskellish" to throw an exception for things that *could* be done with Maybe/Either?
11:11:46 <danharaj> good split
11:12:42 <FliPPeh> In this case, if my rpc proxy function fails to convert the server response into the requested type I *could* just make the return type "IO (Maybe (Result a))" but "IO a" is much more convenient if you know your server won't be a jerk
11:12:43 <bennofs> FliPPeh: I can only say that I personally don't like using APIs that throw exceptions instead of using Either(T)/Maybe(T)
11:13:21 <FliPPeh> Maybe I'll just export two functions
11:13:23 <bennofs> It's just too easy to forget catching an exception. I like that to be explicit
11:13:39 <FliPPeh> One that returns the maybe and the other one that uses the former and throws an exception on Nothing
11:13:49 <FliPPeh> I think that's the best course of action here
11:14:15 <monochrom> FliPPeh: see my http://www.vex.net/~trebla/haskell/exception.xhtml
11:14:17 <prasadi> Hi ! I've written the following Haskell code to download the CSV file (daliy prices) available on yahoo finance web site . In the last part of the code, there's a case statement. I would like to know when actually "rcode" contains the "Left" value. I've mentioned three cases, but all of them refer to "Right" values. I may be wrong. I'm referring to the HTTP response codes available on the following web site. http://lpaste.net/97885
11:14:25 <FliPPeh> λ> callRpc' con "foo" [toJSON 4, toJSON 6] :: IO Float
11:14:25 <FliPPeh> 10.0
11:14:30 <FliPPeh> It's just too convenient :>
11:14:31 <merijn> FliPPeh: It depends
11:14:41 <merijn> FliPPeh: Library functions should return failure as Maybe/Either
11:14:56 <merijn> FliPPeh: Inside an application where you don't plan on handling failure? Exception
11:15:20 <FliPPeh> Thing is, you can't really handle this type of error
11:15:31 <FliPPeh> If my server decides to return "screwyou" I cannot do anything
11:15:35 <merijn> FliPPeh: For a library it's bad design to assume your user won't want to deal with an error. For an application where you know you don't want to handle it, then use an exception
11:15:41 <FliPPeh> Network programming is fun
11:16:09 <merijn> FliPPeh: Why do you have "IO (Maybe (Result a))"?
11:16:24 <merijn> FliPPeh: Aren't Maybe and Result redundant?
11:17:24 <FliPPeh> merijn: IO because of network, Maybe because the result could fail to parse (invalid JSON) and result can either be a valid JSON result that converts to the correct type (Just) or fails to convert (Nothing) or it can be a server error message like "unknown message"
11:17:28 <FliPPeh> There's a lot that can go wrong
11:17:49 <merijn> FliPPeh: Why not combine the Maybe and Result?
11:18:18 <FliPPeh> Because the Result is exported from my json rpc support module that should not be concerned with parse errors
11:19:02 <merijn> That's no reason why your actual RPC call should return that...
11:20:38 <FliPPeh> So you suggest something like "data CallResult a = Ok a | ServerError ErrorCode | ParseError"?
11:21:19 <scshunt> personally I prefer Data Bool = True | False | FileNotFound
11:23:54 <dhun> Hello, i would like to do reading IO operation (get url) in paralell. I think I can do that with paralell Haskell. I found Control.Concurrent to low level. So I made a simple module. I would like to discuss it with you  http://lpaste.net/2728956588483149824
11:24:00 <marshjello> how do you know when you have mastered haskell?
11:24:16 <merijn> dhun: Have you looked at the async library?
11:24:23 <Iceland_jack> dhun: async
11:24:31 <monochrom> async comes with Haskell Platform
11:24:37 <merijn> marshjello: Depends what you mean by mastered? :)
11:24:43 <FliPPeh> Also, <$> is a function from Control.Applicative
11:24:53 <FliPPeh> could be confusing
11:25:05 <Iceland_jack> marshjello: Replace Haskell with any other subject
11:25:11 <PTBD> hello. what am I doing wrong here? http://bpaste.net/show/163966/
11:25:34 <marshjello> My entire intent focuses on internet security
11:25:34 <PTBD> in case the parameter a is Just (Just 5) for example
11:25:38 <monochrom> marshjello: the same as how do you know when you have mastered English, or carpentry, or anything. you always thinks you know. you never really know. Dunning-Kruger effect.
11:25:55 <marshjello> The problem is  I don't know if I even know English.
11:25:55 <shachaf> PTBD: You can't know that the parameter is Just (Just 5) because its type is Maybe a.
11:26:07 <marshjello> Cannot verify it for some reason. I just don't have that level of certainty.
11:26:08 <Iceland_jack> PTBD: You're misunderstanding the type of a?
11:26:12 <bennofs> marshjello: you know when you understand all of ekmett's libraries, all of oleg and contributed to GHC
11:26:14 <shachaf> You don't know that a is Maybe x.
11:26:22 <marshjello> now that's a useful comment bennofs just made.
11:26:24 <dhun> yeah I think async is it thanks a lot
11:26:25 <marshjello> noted.
11:26:28 <PTBD> Iceland_jack, seems so
11:26:41 <monochrom> computers are merely incomplete *or* inconsistent. human minds are incomplete *and* inconsistent.
11:26:56 <jfischoff> PTBD: 'a' is of type 'a', so you don't need to check it with isJust
11:27:00 <merijn> PTBD: You're calling "isJust" on the 'a' in "Maybe a", but isJust requires a Maybe value
11:27:09 <aristid> monochrom: i think it's perfectly possible to make an incomplete *and* inconsistent computer
11:27:18 <Iceland_jack> marshjello: No the question just doesn't make much sense because there is no concrete meaning behind “Haskell expert”
11:27:21 <merijn> PTBD: It's not possible to check whether 'a' happens to be "Maybe Int" this way
11:27:41 <marshjello> I see. so there's no measurement. No way to compare who is better
11:27:52 <Iceland_jack> Is that what I said marshjello?
11:27:56 <merijn> Iceland_jack: To be fair, I was gonna say "when you've contributed to GHC" too as measurement for mastering haskell :)
11:28:00 <merijn> Actually
11:28:01 <marshjello> It's what I paraphrased.
11:28:03 <PTBD> but how would I gife the function f an a if it happens to be Just (Just (Just a))
11:28:07 <PTBD> sorry for the bad english
11:28:11 <merijn> I guess that means I've mastered haskell, whooo!
11:28:16 <Iceland_jack> marshjello: Yes and that's wrongly paraphrased
11:28:23 <merijn> PTBD: The same way you normally do?
11:28:25 <marshjello> Maybe, I'm still incompetent.
11:28:30 <marshjello> I'm a child.
11:28:34 <marshjello> Just seeking new info
11:28:41 <PTBD> huh
11:28:51 <Iceland_jack> Worry about learning rather than measuring your own status
11:28:54 <merijn> PTBD: If 'a' == Maybe (Maybe Int), then the function (a -> b) must be "Maybe (Maybe Int) -> b"
11:29:10 <marshjello> A mild form of schizoprehenia.
11:29:15 <Iceland_jack> merijn: Yes, but the type of contribution matters and that opens up another can of worms
11:29:18 <dhun> merijn, Iceland_jack, async looks nice but I think I still need the liftA2 function a realtives from my modules, or can did I miss something
11:29:29 <PTBD> merijn, ok, but what if I don't know the type exactly?
11:29:35 <Iceland_jack> Correcting a spelling mistake in a comment in GHC does not equal mastery :)
11:29:37 <ocharles> mm_freak_: I took another look at animating Mario using events to switch, and I'm finding the event syntax a bit messy... http://lpaste.net/5701419564743524352
11:29:46 <ocharles> see L8
11:29:48 <merijn> dhun: Async is an instance of Applicative, so you can use the Applicative functions for that
11:30:10 <merijn> PTBD: You don't have to know the type the 'a' in "(a -> b) -> Maybe a -> Maybe b" can be *anything*
11:30:28 <merijn> PTBD: Including "Maybe Int" or "IO (Maybe Char)", or wahtever you want
11:31:00 <merijn> PTBD: You don't have to know what it is, because the type signature of that function already guarantees that you function works with whatever 'a' happens to be inside the Maybe
11:31:13 <dhun> according to the hackage docs its functor but not applicative. And I wanted to make my module applicative to but didn't mange to do so https://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html merijn
11:31:19 <PTBD> merijn, this was my inital function
11:31:21 <PTBD> http://bpaste.net/show/163970/
11:31:28 <donri> merijn: it's not, do you mean Concurrently?
11:31:33 <enthropy> is there a ghc-pkg dot that also gives the hashes?
11:31:34 <PTBD> but it can't work with for example Just (Just 5)
11:31:39 <merijn> donri: I dunno, I don't use async :p
11:32:28 <merijn> dhun: Looks like you want the "Concurrently" newtype at the bottom, that one is Applicative
11:33:02 <merijn> PTBD: Why not? paste the code + error of you using that function with "Just (Just 5)"
11:33:34 <subbyyy> select the dom in the browser then do angular.element($0)
11:33:45 <subbyyy> x window sorry
11:34:03 <monochrom> haha
11:34:09 <donri> enthropy: -v
11:34:46 <PTBD> merijn, applyM (+1) (Just (Just 5))
11:34:54 <PTBD> oh wait
11:34:55 <Komier> evenin all
11:35:01 <enthropy> donri: seems it still prints lines like "regex-compat-0.95.1" -> "array-0.4.0.1"
11:35:19 <PTBD> nope, doesn't work
11:35:19 * enthropy calls the ghc-api directly instead
11:35:21 <merijn> PTBD: (+1) has the wrong type :)
11:35:33 <donri> enthropy: oh dot, missed that
11:35:36 <donri> no clue
11:35:42 <merijn> PTBD: What is 'a' in that use of applyM?
11:36:05 <PTBD> in my example?
11:36:08 <merijn> Yes
11:36:12 <PTBD> Just 5
11:36:17 <PTBD> i hope
11:36:18 <pavonia> :t applyM
11:36:19 <lambdabot> Not in scope: `applyM'
11:36:30 <monochrom> (+1) is the wrong type.
11:36:34 <merijn> PTBD: I mean, the type of applyM is "(a -> b) -> Maybe a -> Maybe b"
11:36:41 <merijn> PTBD: What is 'a' in that type signature?
11:36:46 <monochrom> try instead: applyM (applyM (+1)) (Just (Just 5))
11:37:04 <PTBD> merijn, an Int
11:37:07 <merijn> PTBD: No
11:37:08 <donri> > Just (Just (5 :: Int)) & template +~ 1
11:37:09 <merijn> PTBD: Maybe Int
11:37:10 <lambdabot>  Just (Just 5)
11:37:14 <merijn> :t Just (Just 5)
11:37:15 <lambdabot> Num a => Maybe (Maybe a)
11:37:42 <PTBD> I see
11:37:51 <merijn> PTBD: So the function (the (+1) in your example) must have "Maybe Int" as input, but it doesn't
11:37:54 <dhun> merijn its good, but I still don't feel that happy with it. Here I can run url loading operations in paralell. But I have to block until all loads have finished before I can go on. My idea is to lift a normal function that returns a type IO a to a function that starts the IO a operation a once but just return s a promise that the operation will conclude
11:37:58 <donri> > (fmap.fmap) (+1) (Just (Just 5))
11:37:59 <lambdabot>  Just (Just 6)
11:38:54 <donri> > (fmap fmap fmap) (+1) (Just (Just 5))
11:38:55 <lambdabot>  Just (Just 6)
11:38:56 <donri> mwahah
11:39:12 <mauke> > fmap Just Just 5
11:39:12 <lambdabot>  Just (Just 5)
11:39:22 <PTBD> merijn, ok, I think I got it
11:39:50 <donri> > fmap fmap fmap succ $ fmap Just Just 5
11:39:51 <lambdabot>  Just (Just 6)
11:40:17 <monochrom> "fast & furious & fmap 6"
11:40:36 <donri> > fmap fmap fmap succ `fmap` fmap Just Just $ 5
11:40:37 <lambdabot>  Just (Just 6)
11:42:46 <dmj``> is there a silent getLine? One that doesn't display command line output, or displays an asterisk
11:42:56 <Ralith> monochrom: I'd watch that movie
11:43:31 <PTBD> merijn, nope, I maybe explained my problem wrong.
11:43:54 <FliPPeh> dmj``: You'd need to set the necessary ANSI flags that disable shell output
11:44:05 <FliPPeh> There's probably a module on hackage somewhere that does it
11:44:23 <monochrom> dmj``: there is hSetEcho in System.IO
11:44:54 <PTBD> for example, I have a parameter (Just (Just (Just 6))) and I want to increment the 6 in my function. so wouldn't I have to extragt that 6 from the maybe type?
11:45:07 <merijn> PTBD: You have to extra it from 3 maybe types
11:45:23 <PTBD> yes.
11:45:33 <monochrom> applyM (applyM (applyM (+ 1)))  (Just (Just (Just 6)))
11:46:15 <PTBD> and is there a way to do this recursiv? so I don't have to write something like monochrom did?
11:48:52 <dhun> merijn i found the module i want Control.Concurrent.Future
11:50:52 <monochrom> there is a way using type class
11:52:06 <Polarina> What does one do when documentation on hackage isn't being generated?
11:52:39 <merijn> Polarina: Fetch and build locally?
11:52:59 <merijn> Polarina: Hackage only builds documentation if the package can build on the hackage server
11:53:17 <merijn> Polarina: I've been informed it's now possible to upload pre-generated haddocks, but I haven't figured out how
11:53:31 <Polarina> merijn, it works flawlessly on my computer.
11:54:22 <merijn> Polarina: Are you relying on new GHC features? C headers/libraries? etc.?
11:54:32 <Polarina> merijn, it's a binding to a C library.
11:54:44 <Polarina> But other bindings seem to have a documentation working.
11:54:59 <merijn> Polarina: Right, so if the hackage machine doesn't have that library, the compile will fail and so does the documentation generation
11:56:04 <Polarina> merijn, what do farmers do then?
11:59:22 <flebron> Hi. I have a type "data AVLTree a = forall n. T (AVLNode n a)". I also have a function "unZip :: AVLNode m a -> Zipper m a". Now, is it possible to make a function AVLTree a -> Zipper m a? (Basically the type m, a DataKind Nat indicating the height of the tree the Zipper was created from, is erased by the forall in AVLNode.)
12:00:00 <flebron> I tried writing forall m. AVLTree a -> Zipper m a, to no avail. What I'd like to say is "When you give me an AVLTree a, I'll give you a Zipper m a, for some m."
12:00:24 <shachaf> Perhaps you want an existential type.
12:00:40 <Guest71239> when is 7.8.0 coming out?
12:00:44 <flebron> AVLTree is such an existential type, isn't it?
12:00:53 <shachaf> AVLTree is not an existential type.
12:01:03 <flebron> Ah. What would be, and how would it help me?
12:01:31 <dmisback> my brain hurts from Haskelling..
12:01:57 <ChongLi> dmisback: it's a good hurt, though
12:02:10 <ChongLi> like the soreness after exercise
12:02:12 <flebron> It's like post-workout pain.
12:02:14 <flebron> ;)
12:02:22 <dmisback> 24 hours in and I feel like it's not a productive language. but will give it another 24
12:02:37 <geekosaur> it will take you more than 24 hours to become productive in it
12:02:40 <Komier> lol
12:02:44 <flebron> Heh, 5 years in, and I still think "Woah, it's so powerful, I just wish I weren't this dumb."
12:02:58 <dmisback> 5 years?! holy schmolly
12:03:31 <flebron> Haskell's pretty old :)
12:03:33 <ChongLi> the analogy to exercise is apt in more ways than one
12:04:02 <ChongLi> coming to Haskell from an imperative language is really like working muscles you've never used before
12:04:08 <Komier> I'm doing it as a hobby so I don't have to worry about productivity ;)
12:04:12 <flebron> Where's my Haskell pump? :)
12:04:24 <dmisback> I find it's kind of like vi
12:04:28 * flebron imagines it as a small, pulsating lambda on the back of his neck
12:04:50 <dmisback> a little masochists and in specific casses can be be so productive.. but as a whole..
12:04:59 <dmisback> *masochistic
12:05:00 <ChongLi> I love vi
12:05:00 <dilinger> flebron: ahhh, get it off, get it off
12:05:18 <tristan_1> definitely increases productivity
12:05:26 <dmisback> yeah, I suspect there is a large correlation between vi-love and haskell-love :)
12:05:27 <shachaf> The worst thing about "forall" being used for existential types is that people see a "forall" and think "existential!".
12:05:53 <ChongLi> yeah, it'd be nice if there was something like "exists"
12:05:59 <shachaf> When the connection between the two is actually subtle.
12:06:09 <dmisback> does anyone here love haskell but hate vi?
12:06:17 <tristan_1> I don't hate vi...
12:06:21 <ChongLi> lots of emacs users around here
12:06:22 <tristan_1> but I don't use vi
12:06:23 <shachaf> dmisback: No editor wars in here, please.
12:06:26 <ChongLi> but I don't know if they hate vi
12:06:26 <merijn> Polarina: Like I said, supposedly it's possible to build docs locally and upload it to hackage, but I haven't figured out how
12:06:34 <dmisback> it's not a war, relax
12:06:39 <tristan_1> yea, vi is fine, just not my cup of tea
12:06:51 <Komier> not my thing either.
12:06:52 <flebron> shachaf: How could an existential type fix my problem? (I see " data T = forall a. MkT a
12:06:58 <flebron> " as an existential type in the Haskell wiki)
12:07:11 <tristan_1> always surprised to find functional programmers who use vi though
12:07:22 <tristan_1> since emacs usually has more tooling for each language
12:07:23 <companion_cube> why?
12:07:23 <Gunni> i like vim but not vi, i havent figured out how to use vi, i always EDITOR=vim ... if i get put into vi
12:07:45 <simpson> tristan_1: You'd be surprised how many of us just want something that we can type quickly and efficiently with, and that has syntax highlighting.
12:07:54 <shachaf> Now look what you've started. :-(
12:07:59 <ChongLi> Gunni: learning how to use vi will change the way you think about vim
12:08:00 <Komier> Don't like emacs much either though if im honest
12:08:09 <shachaf> flebron: "data T = forall a. MkT (Foo a)" means: If you have a T, you know that you have "Foo x" for some x, but you don't know what x is.
12:08:11 <tristan_1> simpson: type quickly? you have to hit i first! ;)
12:08:32 <ChongLi> vi has a lot of really powerful features that vim users neglect because they have plugins
12:08:33 <flebron> shachaf: So you suggest saying data Iterator = forall m. Zipper m a?
12:08:45 <flebron> Err, Iterator a, obviously.
12:08:54 <ChongLi> but plugins are just so heavy and clunky compared to simple shell commands and such
12:09:11 <simpson> tristan_1: IYSS.
12:09:12 <shachaf> flebron: I don't know if I'm suggesting it, but maybe it's what you want.
12:09:16 <merijn> I suggest the editor discussion moves to #haskell-blah?
12:09:19 <shachaf> Stop it, everyone. Editor wars, even jokey ones, are off-topic and harmful.
12:09:37 <tristan_1> simpson: is a joke
12:09:44 <tristan_1> does no one use Yi?
12:10:08 <ChongLi> shachaf: who is engaging in editor wars, anyway?
12:10:10 * hackagebot herringbone 0.0.4 - A library for compiling and serving static web assets.  http://hackage.haskell.org/package/herringbone-0.0.4 (hdgarrood)
12:10:17 <dmisback> no one is
12:10:38 <mreh> this room is for discussing haskell
12:10:43 <StahlGrau> still a bit off topic
12:11:28 <ChongLi> right, and editors are pretty important for using Haskell
12:11:47 <ChongLi> where is the harm in discussing editors if nobody's saying much otherwise?
12:12:01 <dmisback> there is no harm
12:12:05 <mauke> ChongLi: you're off topic
12:12:11 <mauke> ಠ_ಠ
12:12:16 <dmisback> similar to how stack overflow posts get closed for no reason
12:12:28 <mreh> now you've made him sad
12:12:50 <mreh>  /mad
12:13:35 <ChongLi> sad missing glyph boxes
12:13:43 <ChongLi> whatever those are called
12:14:26 <dmisback> so who here feels more productive in Haskell than in any other programming language?
12:14:36 <dmisback> and how long have you been writing Haskell
12:14:48 <dmisback> or how long did it take to become your most productive language rather
12:14:56 <StahlGrau> I wish I felt productive in any programming language
12:15:04 <ChongLi> ain't that the truth!
12:15:08 <mreh> dmisback: no one will pay me to write haskell, so it rarely feels productive to me
12:15:17 <benbangert> is there a cleaner way to do conditional sub-scans on a list than nested folding? I'm doing a lot of stateful computations over a list and sub-lists and the code is not quite as clean as I was hoping for..... code: http://paste.ofcode.org/TBNxiuNKF3fYBLi5spxhEq
12:15:20 <ChongLi> dmisback: I'd say Edward Kmett would definitely answer yes
12:15:43 <ChongLi> his productivity is indisputable
12:15:44 <merijn> dmisback: I would say about 6 months of learning before I became productive, a bit more before it replaced python as my "I need to hack something quick" language
12:16:15 <benbangert> also, I breaking it into more functions seems to hurt cause so much needs to be passed in vs. the closure scope the where nesting provides
12:16:17 <tristan_1> dmisback: I feel more productive in Haskell than many othe rlanguages, like Java
12:16:21 <tristan_1> but it is not my most productive language
12:16:26 <dmisback> 6 months eh? ok thanks...
12:16:31 <ChongLi> dmisback: it really depends on how many hours you put in, how much pre-Haskell functional programming experience you have, etc.
12:16:34 <tristan_1> and hard to say how long I've been coding in it...
12:16:49 <StahlGrau> I've been trying to stay motivated in learning it but I get bouts of distraction super easily
12:16:57 <ChongLi> my friend is learning Haskell as his very first programming language
12:17:05 <ChongLi> and he's become productive rather quickly
12:17:10 <benzrf> hi, is there a specific name for a function that returns a function vs one that takes a function when talking about HOFs?
12:17:12 <flebron> shachaf: In that case, I can't possibly make a function Iterator a -> Zipper m a that unhides it, right?
12:17:21 <ChongLi> he's really smart, though
12:17:27 <ChongLi> he learns a lot of things quickly
12:17:30 <dmisback> it's a tough one isn't it.
12:17:34 <tristan_1> ChongLi: is he documenting this?
12:17:47 <shachaf> flebron: Right, because that turns "you get to choose" into "I get to choose".
12:17:50 <ChongLi> no, why do you ask?
12:17:51 <merijn> dmisback: If you ask me "is it worth it, considering the long time to productivity?", I'd say yes. In my opinion haskell has a large hump of inproductivity between "trivial LYAH examples" and "real world code", the latter requiring familiarity with some intermediate topics like transformers, etc.
12:18:00 <tristan_1> I've always argued people becoming ingrained with imperative OOP languages is what makes functional hard
12:18:02 <ChongLi> I could ask him if he wants to
12:18:04 <tristan_1> not it being hard on its own
12:18:09 <benzrf> tristan_1: same
12:18:16 <merijn> dmisback: I would say that for almost any project X, X would take me less time in haskell than another language
12:18:18 <lafa> Hey, i have a function call returning IO (Maybe ByteString), but ghc keep complaining "Couldn't match type `IO' with `Maybe'"
12:18:28 <ChongLi> maybe he'd be willing to talk about his experience in a youtube video or something
12:18:29 <benzrf> ive thought that haskell is probably not all that much harder than, say, python
12:18:33 <benzrf> well. maybe just a little
12:18:33 <lafa> does all the calls within x = do ... need to match the type of x?
12:18:35 <tristan_1> I was lucky and started with C and functional
12:18:37 <mreh> lafa, you might need to paste the program
12:18:39 <tristan_1> many are not so lucky :(
12:18:40 <mauke> lafa: no
12:18:45 <ParahSailin> i dont fallback to python hardly at all these days
12:18:51 <spaceships> harder to learn, easier to use
12:18:59 <benzrf> tristan_1: i did imperative for like 7-8 years before looking @ haskell
12:18:59 <ChongLi> my friend did flat-out tell me he thought monads were easy to learn and didn't see what the big deal was
12:18:59 <benzrf> :D
12:19:03 <bernalex> I used python a month ago. I used random choice.
12:19:04 <flebron> shachaf: So, is there a way to return to the user an opaque "iterator" into the tree, such that inside of my module, I can use these iterators as Zipper m a's? (And the user doesn't have to know the 'm', which is an implementation detail)
12:19:10 <benzrf> ChongLi: thats because monads arent hard
12:19:18 <tristan_1> python can be 'less hard'
12:19:21 <benzrf> ChongLi: the problem is that people from imperative langs try to learn them without learning haskell first
12:19:24 <Komier> ChongLi: just out of interest does your friend have a strong math background?
12:19:26 <benzrf> ChongLi: and get mega confused
12:19:29 <ChongLi> right, I know they aren't hard, I find them easy myself
12:19:29 <shachaf> flebron: The question is always "who gets to choose m?".
12:19:29 <benzrf> ChongLi: see: myself
12:19:40 <flebron> shachaf: I (the tree) do.
12:19:49 <dmisback> all the haskell i've ever written: http://lpaste.net/97889  10 hours to write 200 lines!!
12:19:50 <ChongLi> Komier: he does tutor people for college-prep calculus
12:19:51 <tristan_1> but I've found even python has similar issues to anything I groan about in a typed language :)
12:19:52 <benzrf> if you actually use them a bit you get the hang of em p quick
12:20:03 <merijn> dmisback: I feel that the saying "Writing wrong programs in Haskell is hard, but writing correct programs is hard in any language." is very true. I notice haskell is preventing me from making many shortcuts that would result in subtle bugs if I had taken that shortcut in Python
12:20:03 <tristan_1> "It wants a URL obejct instead of a string?! AAAAAAA"
12:20:08 <shachaf> flebron: Maybe you meant something else by "Iterator a -> Zipper m a".
12:20:28 <benzrf> tristan_1: ick
12:20:29 <Komier> ChongLi: Ok thanks, just curious.  I'm doing something similar, but with a "moderate" math background. lol
12:20:32 <flebron> shachaf: Well, I'd want to give the user an iterator into the tree, and then be able to receive that iterator from the user.
12:20:33 <benzrf> tristan_1: that's my #1 beef in java
12:20:40 <flebron> Say, "Hey, tree, find this node. Now find its successor."
12:20:42 <shachaf> flebron: You can write case foo of MkIterator blah -> {- use a value :: Zipper m a here, without knowing what m is -}
12:20:42 <lafa> mreh: http://lpaste.net/97890 << program; http://lpaste.net/97888 < error
12:20:42 <benzrf> tristan_1: it forces you to use fancy objects for EVERYTHING even when strings work
12:20:46 <tristan_1> benzrf: I've found the same to be the csae with python
12:20:48 <ChongLi> Komier: honestly, I think we all could use a much better math background
12:20:50 <dmisback> merijn: how long you been writing HAskell?
12:20:51 <benzrf> tristan_1: only with the worse libs
12:20:51 <aristid> Peaker: around? :)
12:20:52 <mreh> tristan_1: URLs aren't strings
12:21:03 <merijn> dmisback: I'd say about 2-3 years?
12:21:09 <ChongLi> I was just thinking earlier today that we should be teaching monoids to 2nd and 3rd graders
12:21:12 <benzrf> tristan_1: one nick convention ive seen in Ruby is methods that take either strings OR fancy objects
12:21:37 <benzrf> tristan_1: so you can use the simpler or more complicated version depending on your level of need
12:21:37 <ChongLi> we should be teaching them some of the most basic elements of category theory
12:21:40 <tristan_1> benzrf: that is one thing I find myself wanting in haskell coming from Erlang
12:21:48 <benzrf> tristan_1: one of the things i really like about ruby right there
12:21:50 <ChongLi> after all, it's a foundation for mathematics
12:21:57 <dmisback> merijn: ok thanks
12:22:00 <merijn> dmisback: Somewhere around 6-10 years of experience in C, Python and Java
12:22:09 <benzrf> tristan_1: it's just really convenient
12:22:11 <benzrf> in general
12:22:16 <benzrf> sometimes at the expense of consistency though :\
12:22:20 <ChongLi> our current method of teaching, involving memorization of tables, is extremely silly
12:22:33 <Komier> ChongLi:  Given how much real world math I have had to teach myself to get by witht hings I want to do, and my work, I can't help but agree.
12:23:09 <ChongLi> again and again, one of the biggest barriers I see people having
12:23:15 <ChongLi> when it comes to learning Haskell
12:23:24 <ChongLi> is learning all these "scary math words"
12:23:25 <tristan_1> um
12:23:31 <mreh> lafa, you need to bind the result of hostLookup to a variable and then analyse the case of that
12:23:49 <tristan_1> and when people think they need ot learn, or worse they actually do learn, category theory ;)
12:23:53 <ParahSailin> tristan_1: im always a little uneasy around the crazy-random polymorphism i see in javascript and python libraries
12:23:57 <mreh> hostLookup has type :: IO a
12:24:06 <benzrf> ParahSailin: you should see ruby ;)
12:24:15 <mreh> not sure what `a' is, but it's something in the IO monad
12:24:22 <benzrf> ParahSailin: ruby has crazy shit like that
12:24:31 <ParahSailin> benzrf: so i hear
12:24:35 <mreh> host <- hostLookup
12:24:37 <mreh> case host of
12:24:39 <benzrf> ParahSailin: example: Array#inject (which is reduce) will take a block with two args
12:24:46 <tristan_1> ParahSailin: yea, I'm no fan. I was just refering to in Erlang I can match on the type, as well as the arity (which you can't in haskell becuas of currying)
12:24:51 <benzrf> OR a symbol representing a method name to call on the accumulator with the next element!
12:24:54 <benzrf> so you can do:
12:25:03 <benzrf> arr.inject {|a, n| a + n}
12:25:05 <benzrf> OR just
12:25:08 <benzrf> arr.inject(:+)
12:25:12 <lafa> mreh: thx i'll try!
12:25:21 <merijn> dmisback: One of the beneficial things of the Haskell community, imo. Is that there's lots of people actively experimenting with all sorts of things, learning all sorts of advanced things is encouraged a lot. In Java/python it's much easier to hit a point where there's just not much more to learn
12:25:23 <flebron> shachaf: That seemed to work, thanks! So I can pattern match on it, I just can't explicitly say "Here's a function which returns a Zipper m a", because on each pattern match, the m will be different, whereas the function says there's a specific m?
12:25:54 <flebron> (Or that the user gets to chose which m it is, which is also bad.)
12:25:55 <benzrf> so are zippers and lenses used for similar things?
12:26:04 <ParahSailin> tristan_1: variadic stuff in erlang?
12:26:05 <ChongLi> merijn: yeah, or the things you're learning are the particulars of one framework or another
12:26:19 <ChongLi> instead of learning general rules of compositionality
12:27:10 <tristan_1> ParahSailin: no, functions are just dependent on their arity. So f/2 is different from f/3
12:29:29 <shachaf> flebron: foo :: ... -> Zipper m a means: The user (caller) of foo gets to choose what m is.
12:29:36 <shachaf> flebron: There's an implied :: forall m. ...
12:29:44 <shachaf> So you can't write that function.
12:30:03 <sdfsds> 'cabal install numerals' fails for me.  Could anyone try to reproduce?
12:30:15 <merijn> Would "Advanced Topics in Types and Programming Languages" be a better book than TaPL for someone already familiar basic type theory?
12:30:24 <merijn> sdfsds: Run with -v3 for better error messages?
12:30:25 <flebron> Right, right.
12:30:38 <benzrf> sdfsds: fails for me as well
12:31:21 <sdfsds> benzrf: Thanks.  Is there a way to workaround the "Illegal standalone deriving declaration" error?
12:31:33 <sdfsds> Can I pass a flag to cabal or something like that?
12:31:58 <benzrf> i dunno
12:32:21 <lafa> mreh: does `hostLookup = do ...` not bind the result to hostLookup? not sure what the difference would be :/
12:32:35 <flebron> sdfsds: {-# LANGUAGE StandaloneDeriving #-}?
12:33:34 <mreh> lafa: the simple explanation is that you need to the value of your host lookup out of the IO monad before you can do your case analysis
12:33:52 <sdfsds> flebron: The module lacks this declaration, but I don't want to patch it myself. I'd rather pass the -XStandaloneDeriving flag to cabal if that's possible. So is it possible?
12:34:15 <mreh> so it has to be bound to a value in that code block with the case statement
12:34:42 <mreh> the reason we have to do that is so we ensure the ordering of the execution of the statements is the same
12:34:42 <mreh> as the way they are written
12:34:44 <ChongLi> sdfsds: are you planning on writing an orphan instance?
12:34:59 <flebron> extensions: StandaloneDeriving perhaps, sdfsds?
12:34:59 <mreh> that's the complicated explanation
12:35:04 <flebron> (See http://www.haskell.org/ghc/docs/7.0.3/html/Cabal/authors.html )
12:35:32 <sdfsds> ChongLi: I'm simply trying to install the 'numerals' package, which fails with Data/Text/Array.hs:104:1: Illegal standalone deriving declaration Use -XStandaloneDeriving to enable this extension
12:35:44 <ChongLi> sdfsds: ahh, okay
12:36:29 <mreh> lafa: think of it this way too, you can't do pattern matching on a value inside IO, because the constructor isn't visible to you
12:36:45 <mreh> it's not exposed to the programmer
12:37:31 <tristan_1> but then how do I hide that something isn't pure!
12:37:36 <ChongLi> mreh: can't you just do foo >>= bar
12:37:37 <tristan_1> oooooooo ;)
12:37:40 <lafa> mreh: okey, I think I got it!
12:37:41 <ChongLi> and do your pattern matching in bar?
12:37:46 <mreh> ChongLi: yes
12:37:58 <edwardk> dmisback: It took me about 8 months to rewire my brain to think in Haskell. Since then, I've _definitely_ become a much more productive programmer by almost any objective measure.
12:38:19 <lafa> mreh: easiest would be moving hostLookup to it's own function which only returns `Maybe ByteString`; hiding that it actually does any IO/
12:38:22 <lafa> ?
12:38:26 <ChongLi> edwardk: but you came from a scala background?
12:38:35 <ChongLi> how long had/have you been programming scala?
12:40:00 <edwardk> No. I learned scala because we needed to use it in the enterprise here. I've been writing scala for around 3 years, but it was a fairly easy transition for me. I was up and running in scala in maybe 1-2 months pushing that language up against the limits of its compiler, but that was based on the understanding of type theory and category theory I had from learning Haskell.
12:40:32 <edwardk> I've been active in the Haskell community for ~6 years now.
12:40:37 <ChongLi> edwardk: aahhh
12:40:40 <sdfsds> flebron: I've looked through the page, but I can't see anything relevant.  Are you aware of the solution or simply suggested to check there?
12:40:52 <ChongLi> that's pretty cool!
12:40:58 <danharaj> edwardk is the first person to be charged with thoughtcrime in the realm of C++.
12:41:05 <edwardk> I spent about 20 years programming imperatively before I found Haskell.
12:41:24 <merijn> danharaj: I've been preemptively banned from writing C++ for fear of template atrocities :(
12:41:29 <flebron> sdfsds: Search for "extensions: identifier list". In particular, " Extension names are the constructors of the Extension type. These determine corresponding compiler options."
12:41:34 <ChongLi> edwardk: and Haskell was your first functional language?
12:41:34 <edwardk> danharaj: cooperatively jitting c++ by stealing control of your pthread is not a thought crime. ;)
12:41:46 <ChongLi> those early days must have been rough
12:41:48 <benzrf> Haskell was def MY first functional language
12:41:53 <benzrf> it was a tad tricky
12:42:02 <mreh1> <- Miranda
12:42:11 <ChongLi> old school!
12:42:13 <HectorAE> Before Haskell I used Scheme so...
12:42:24 <HectorAE> It's like my second or third functional language
12:42:27 <mreh1> ChongLi: I'm not even that old
12:42:37 <jle`> merijn, aristid: aw darn, i just spent the entire weekend trying to fix it.  didn't know it was still down. do you guys remember the error message or anything?
12:43:09 <sdfsds> flebron: AFAIK, this field is for the authors.  But I'm simply trying to install someone else's package.
12:43:25 <merijn> jle`: "Something went wrong" or something similarly helpful :)
12:43:31 <flebron> sdfsds: Can you not edit that field to add that extension?
12:43:32 <edwardk> ChongLi: i'd written some lisp/scheme maybe 10 years before, but it hadn't really clicked. I was _very_ solid on template metaprogramming in C++ though before I found Haskell. e.g. I'd actually implemented IEEE754 compliant doubles with cordic functions for sin/cos, etc. as template metaprogramming tools so i could get the compiler t precompose FFT lookup tables, and generally had moved to templates for everything already. Haskell
12:43:33 <edwardk>  just removed all the ridiculous overhead of that Turing tarpit for me.
12:43:40 <aristid> jle`: no i don't remember. it works again
12:44:07 <ChongLi> edwardk: haha, wow
12:44:19 <aristid> merijn: now you can link to your beloved link without disclaimer again:)
12:44:36 <benzrf> ive never done c++
12:44:38 <edwardk> So in that sense I'd already learned to think functionally to some extent with that, and with the built in data types in perl to a lesser extent
12:45:14 <merijn> aristid: It's not so much a beloved link as it is "thank god I don't have to type this explanation again" :p
12:45:14 * hackagebot time-exts 1.1.1 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-1.1.1 (EnzoHaussecker)
12:45:29 <edwardk> The nice thing about Haskell for me is that all of the incidental complexity of my problems really melts away, leaving me with more or less just 'bare truth' to write.
12:45:32 <aristid> jle`: merijn linked this blog post of yours _six_ times :) and half of the time with a "it's probably down" disclaimer
12:45:59 <ChongLi> edwardk: if only we all were so gifted!
12:46:00 <aristid> who needs a panopticon when he has irc logs
12:46:09 <jle`> merijn: haha yeah v.v it's Heroku's automatic errors
12:46:15 <jle`> if my app throws an error it just displays that page
12:46:17 <jle`> super helpful.
12:46:32 <aristid> jle`: did you write the blog software yourself?
12:46:41 <ChongLi> it's not fault of Haskell's, my incidental complexity stems from my lack of experience and understanding
12:46:55 <jle`> aristid: i did, but i feel like my problems came from using their free tier Postgres server
12:47:03 <aristid> jle`: hmm couldn't you make it a static site? that should be easier to host
12:47:03 <jle`> and i was getting too much traffic
12:47:10 <jle`> at least that's what i was telling myself to make myself feel better
12:47:22 <aristid> heh
12:47:24 <jle`> i considered a static site, but i like being able to push my entries early and then have them auto-publish
12:47:34 <jle`> and queing them
12:48:09 <aristid> jle`: heroku can probably host static sites, so how about generating the sites in heroku? :D
12:48:13 <ChongLi> edwardk: are you still doing stuff with succinct data structures?
12:48:15 <edwardk> ChongLi: My best recommendation is to stick with it. Learn everything even remotely around the spaces that interest you and just implement your first thought. Don't be afraid to throw away code. e.g. I've gone through probably 2 dozen iterations on a probabilistic programming EDSL in Haskell. Each time I learned something, but I've yet to ship one.
12:48:29 <jle`> aristid: static won't work because i want to be able to queue :/
12:48:29 <tristan_1> jle`: heroku?
12:48:43 <ChongLi> edwardk: thanks, I will keep that in mind
12:48:43 <aristid> jle`: no i mean, still put it in the database
12:48:46 <edwardk> ChongLi: yeah. the succinct package will likely ship once i can figure out how to get mihai patrascu's succincter encoding of rank-select to work
12:48:56 <aristid> jle`: but once it's to be published, generate static sites
12:49:11 <ChongLi> I often get caught up in the "perfect is the enemy of the good" internal struggle
12:49:24 <RustyShackleford> okay, what is a monad?
12:49:25 <edwardk> actually i should probably just ship it, hrmm.
12:49:27 <ChongLi> and end up procrastinating
12:49:28 <jle`> aristid: so have the site auto-generate whenever there is a new entry?
12:49:28 <aristid> jle`: sorry if my ideas don't make too much sense, i'm just thinking out loud ;)
12:49:34 <jle`> aristid: haha no worries
12:49:35 <aristid> jle`: yes
12:49:43 <mreh1> @quote monad
12:49:43 <HectorAE> Also read http://realworldhaskell.org it's an awesome book.
12:49:43 <lambdabot> quicksilver says: It's replaced by the farm comonad, EIEIO.
12:49:57 <RustyShackleford> is there a guide you'd recommend? Or a good example of using one/
12:50:06 <danharaj> edwardk: you forgot to say: don't try to implement FRP. that way lies madness and danharaj will probably shiv you in that insanitarium.
12:50:09 <Komier> ChongLi: procrastination is too easy! I do it alot, including reading too much #Haskell. lol
12:50:09 <edwardk> ok, major blockers are working succincter and wrking range-min trees
12:50:13 <aristid> @where lyah -- RustyShackleford
12:50:13 <lambdabot> http://www.learnyouahaskell.com/
12:50:39 <Earnestly> (Fwiw, I really like the Craft of Functional Programming book)
12:50:43 <SLi> One thing that I somewhat miss in Parsec: The ability to use regexps to match a piece of input. Because despite all the derision against regexps and their difficulty, they are extremely suitable for that kind of thing (and the regexp libraries provide much faster matching than parsec incantations like many1 (try (string "foo") <|> string "bar")...)
12:50:47 <HectorAE> LYAH is also good
12:50:51 <aristid> edwardk: this stuff you're saying right now has nothing to with analytics?
12:50:54 <ChongLi> edwardk: I'm just remembering back from your talk
12:50:58 <edwardk> danharaj: It isn't in my rational self-interest to dissuade folks from trying FRP. If they succeed, I learn something. If they fail, they learn something. ;)
12:51:05 <danharaj> haha
12:51:08 <jle`> aristid, merijn: was it running when you posted it five hours ago?  or perhaps you didn't check
12:51:11 <ChongLi> is it wavelet trees that allow you to lazily index large JSON documents without parsing them?
12:51:12 <seeg> hello
12:51:19 <aristid> jle`: it didn't work.
12:51:26 <tristan_1> jle`: heroku's automatic erors?
12:51:33 <Earnestly> Although I haven't read the 3rd Edition.  Opinions welcome \o/
12:51:37 <tristan_1> jle`: curious abotu this since I work at Heroku :)
12:51:52 <edwardk> aristid: analytics has been split up. succinct is the working version of the succinct indexed dictionary code without prejudging the use to be for large data sets
12:51:59 <aristid> ChongLi: lazily index? you're not joking?
12:52:02 <edwardk> aristid: eventually i may restart analytics on top of that code base
12:52:08 <aristid> edwardk: ah
12:52:10 <jle`> tristan_1: i am probably using heroku as a scapegoat :P but if it is heroku's fault at all it would be because i am using the free tier and i have too much traffic
12:52:12 <edwardk> ChongLi: its not a wavelet tree
12:52:13 <seeg> suppose I have multiple values v1, v2, v3 of same type Either a b. What are some good ways to write: 'execute f if v1, v2, v3 are all of type Right b, execute g otherwise' ?
12:52:15 <edwardk> aristid: it is in my talk
12:52:17 <jle`> so not their fault, but my pocketbook's
12:52:21 <aristid> edwardk: Resteverwertung, if you excuse my use of a german word :>
12:52:25 <ocharles> ChongLi: not really, you just build an index based on the amount of parenthesis and things you see
12:52:27 <jle`> aristid: did it say "something went wrong" earlier?
12:52:32 <ChongLi> aristid: yeah, it's brilliant
12:52:34 <aristid> jle`: i don't remember, sorry
12:52:42 <jle`> aristid: no worries :)
12:52:45 <SLi> Need to try attoparsec. Of course it should probably be possible to write template haskell code to convert a regexp into an attoparsec rule? :)
12:52:45 <ocharles> There's a bit more to it than that, but the paper isn't as breath taking as you might imagine
12:52:48 <ocharles> just a clever trick :)
12:53:09 <aristid> jle`: are you using haskell on the heroku btw?:D
12:53:10 <jle`> tristan_1: the actual error is that i have too many connections open.  so if it was my fault, it would be because Persistent isn't closing its connections properly
12:53:11 <edwardk> ChongLi: it is a succinct indexed dictionary of the interesting bits of the json document and a second dependent structure that contains pairs of balanced parentheses for each interesting bit in succinct frm
12:53:21 <tristan_1> jle`: free tier doesn't limit your traffic, but would be true if by free tier you mean becuase you onlyhave 1 dyno
12:53:23 <jle`> aristid: i'm building to a binary and deploying the binary :) with ruby gems and stuff
12:53:24 <ChongLi> edwardk: ahhh, that's right
12:53:25 <HectorAE> Don't like Parsec? Solution: write a new monad
12:53:36 <tristan_1> jle`: ooo, the DB free tier, yea that is very limited in connections
12:53:46 <jle`> tristan_1: i am not sure if rising traffic = more connections
12:53:52 <edwardk> aristid: in https://www.youtube.com/watch?v=uA0Z7_4J7u8  i talked about it.
12:53:57 <jle`> i do not know enough about this fancy database stuff
12:54:12 <tristan_1> yea, would depend on your code
12:54:15 <jle`> so it might be Postgres
12:54:16 <jle`> er
12:54:16 <jle`> Persistent
12:54:21 <aristid> edwardk: cool, i'll try to watch it later:)
12:54:30 <merijn> Type theory experts, ATTaPL or TaPL for people who are comfortable with the basics of type theory?
12:54:41 <mm_freak_> ocharles: what do you find messy about it?
12:54:42 <edwardk> I'd start with TaPL regardless
12:54:46 <ChongLi> I bet this technology might somehow be useful for doing search on a static page website
12:54:48 <HectorAE> In Scheme you write domain specific languages. In Haskell you write monads. Pretty easy analogy.
12:54:51 <ChongLi> is that a crazy idea?
12:54:53 <edwardk> ATTaPL is more or less just a bunch of papers
12:54:54 <jle`> anyways i moved off my dependence on the postgres so i had hoped it would work.  i only update my acidstate-like thing at startup
12:55:04 <ocharles> mm_freak_: (pure idleFrame <$) <$> became (== 0) is not exactly poetry
12:55:04 <aristid> jle`: this may be a very superficial opinion but i don't like Persistent. because it didn't initially support JOINs at all, and i think even now it doesn't support them that well
12:55:06 <jle`> sad to hear i am still having problems
12:55:14 <merijn> edwardk: I already worked my way through about half of McBride's thesis, so I just wanted to make sure TaPL wouldn't be a waste of time :)
12:55:15 <jle`> aristid: I use esqueleto for my selects
12:55:17 <ChongLi> the usual problem with search on static pages is that your keyword indices can get really large
12:55:24 <jle`> but i really like their type-safety system etc.
12:55:30 <edwardk> ChongLi: not sure. i've been meaning to build up and release a full json parsing library that uses the semi-indexing machinery
12:55:31 <ocharles> mm_freak_: and I don't like that I have to express the (== 0) predicate twice to get the positive and negative events
12:55:34 <aristid> jle`: esqueleto is no longer mysql-specific?
12:55:35 <merijn> edwardk: Also, you need to be less productive so I have time to catch up with all the stuff you've already done >.<
12:55:44 <ChongLi> but if you can split them up into small, compressed chunks and use a succinct dictionary to index it
12:55:47 <ocharles> merijn: what's his thesis?
12:55:50 <jle`> aristid: nope i've been using it for postgres
12:55:52 <mm_freak_> ocharles: well, you can always generate the events separately and combine the Event values later
12:55:57 <ChongLi> then wouldn't that help a lot?
12:56:14 <SLi> HectorAE: Parsec would be reasonably ok, were it not five times slower for many tasks than a regexp solution (which is unwieldy solely because none of the regexp libraries support named groups, requests for which tend to always be answered with "you should use parsec for something that complicated" :-)
12:56:26 <mm_freak_> ocharles: yeah, that isn't pretty…  so there should be some compound event
12:56:30 <merijn> ocharles: Dependently Types Programs and Their Proofs (or something similar), basically an overview of this Epigram approach of type directed program derivation
12:56:33 <mreh1> in your opinion, what's the best (working) haskell FRP library out there with first order signals/behaviours and event streams?
12:56:43 <ocharles> merijn: ah right, that's probably quite interesting
12:56:44 <mreh1> s/opinion/opinions/
12:56:49 <SLi> HectorAE: But I've heard attoparsec is blazingly fast!
12:56:52 <merijn> ocharles: So iterative refinement of typed holes
12:56:52 <mm_freak_> mreh1: "first order"?
12:56:54 <tristan_1> jle`: well if you need anything let me know :), always wantot help when it comes to languages like Haskellbeing used on Heroku
12:57:14 <ocharles> mreh1: by first order you presumably mean 'first class'?
12:57:16 <merijn> ocharles: It's very readable compared to, say, View from the Left and Clowns to the Left of me, jokers to the right
12:57:18 <HectorAE> Welp to each their own SLI.
12:57:21 <mreh1> ocharles: yes!
12:57:26 <ocharles> mreh1: I am biased to having only used netwire, but I generally love it
12:57:34 <mreh1> ocharles: okay
12:57:38 <ocharles> mm_freak_: what is a "compound event" in this situation?
12:57:40 <jle`> tristan_1: thanks :) i'll keep that in mind. i do like heroku so i try my best to target it
12:57:40 <mreh1> felt icky to me, but okay
12:57:50 <flebron> Glad Haskell feels the same way I do. "My brain just exploded.  I can't handle pattern bindings for existential or GADT data constructors."
12:58:02 <SLi> :)
12:58:04 <ocharles> Fwiw - I'm using events here to switch animations because I want time to restart. I was previously using intervals, but that doesn't let me restart the clock
12:58:37 <tristan_1> jle`: cool, and we released an API for uploading slugs. I haven't looked into it much but planned to for building Erlang slugs, will probably be the way to go for haskell too
12:58:40 <ocharles> merijn: good to know. I have TaPL on my shelf to read first :(
12:58:46 <ocharles> merijn: first as in - that's what I want to focus on next
12:59:03 <jle`> tristan_1: i have heard about that actually!  considering my builds take longer than 15 minutes, so i can't use any sort of buildpack
12:59:05 <merijn> ocharles: That is probably better
12:59:12 <jle`> i have been hackign around by uploading a binary this whole time
12:59:19 <jle`> and building on a VM
12:59:26 <merijn> ocharles: I feel like reading his thesis first was maybe a bit...challenging :p
12:59:32 <tristan_1> jle`: I can extend that if you need ;)
12:59:41 <merijn> ocharles: But maybe I'm just a glutton for pain
12:59:45 <ocharles> merijn: half the time i can never decode what subtle message mcbride is trying to get across
12:59:48 <ocharles> the man is too darn smart
12:59:56 <jle`> tristan_1: really? o_O
13:00:06 <prasadi> Hi ! pls help me to locate the error in the following code . http://lpaste.net/1278939276750356480
13:00:08 <RustyShackleford> what are some well known projects written in Haskell?
13:00:15 <tristan_1> jle`: yea, there is a per app flag to extend the build time limit
13:00:21 <jle`> i got to go now, but i'll try to remember to give you a call later
13:00:27 <jle`> RustyShackleford: do know Pandoc?
13:00:28 <merijn> ocharles: I can usually figure out the big picture, it's "why does this actually work?!" that I can't figure out :)
13:00:36 <tristan_1> jle`: cool
13:00:41 <merijn> RustyShackleford: pandoc, xmonad, darcs
13:00:57 <tristan_1> xmonad!
13:01:07 <merijn> prasadi: You didn't paste the error
13:01:23 <ChongLi> RustyShackleford: lens!
13:01:32 <mm_freak_> ocharles: something like 'edge'
13:01:44 <ocharles> merijn: I got a stack overflow answer from him once saying "you stay in f unless you fugging have to go to g" it took me a few days to realise that was probably a play on 'f under g'
13:02:32 <HectorAE> Ever heard of GHC, RustyShackleford?
13:02:32 <benzrf> what does this mean -> class Lift a b | a -> b
13:02:33 <edwardk> merijn: the nice thing is TaPL gets through a lot of raw theory about why we can't have nice inference for System F_sub, so even if the beginning is wasted on you the later chapters are good.
13:02:43 <benzrf> is it some kind of extension?
13:02:50 <merijn> Is the "Finally Tagless, Partially Evaluated" paper a good place to start for the implementation of a functional languages?
13:02:59 <ChongLi> RustyShackleford: study xmonad if you want to see a nice architecture for a user-extensible application
13:03:03 <ocharles> mm_freak_: but it's not quite edge because I need to respond to both events. I dunno, maybe this is all neccesary complexity
13:03:06 <prasadi> <merijn> The error is quite long. I can't type it  over here. Is there a way to attach an image (error) ?
13:03:07 <merijn> Or should I just try and steal TaPL from the university library and start with that
13:03:19 <RustyShackleford> okay but if the compiler is the best program written in Haskell, isn't that kinda bad?
13:03:20 <merijn> prasadi: Why can't you just copy+paste it?
13:03:24 <ChongLi> the idea of "everything is a library" is pretty powerful
13:03:38 <RustyShackleford> I'll look at xmonad and pandoc
13:03:54 <quchen> prasadi: Use a paste site, not this channel. like lpaste.net, which is the #haskell-go-to-pastebin.
13:03:55 <benzrf> help?
13:04:07 <ChongLi> RustyShackleford: Haskell is a very library-oriented community
13:04:18 <ChongLi> most of the best software in Haskell is libraries, not applications
13:04:27 <HectorAE> Like Parsec.
13:04:27 <quchen> benzrf: the "| a -> b" is called a fundep (functional dependency).
13:04:39 <zipper> I have noticed this thing in Haskell. The first time I run a function it runs slowly in a way but after that it's blazing fast.
13:04:40 <ChongLi> applications are often little throw-away things that use the powerful libraries to do their work
13:04:44 <zipper> Why is this?
13:05:03 <ChongLi> zipper: in GHCI?
13:05:09 <zipper> ChongLi: Yes
13:05:15 <zipper> How'd you know?
13:05:16 <benzrf> quchen: what does it do?
13:05:19 <tomberek> rawtass: hi there
13:05:22 <Komier> Didn't realise you could actually look at source code of modules on hoogle <sigh> such a nub.
13:05:24 <benzrf> zipper: maybe it's JIT
13:05:25 <zipper> "< ChongLi> applications are often little throw-away things that use the powerful  libraries to do their work"
13:05:27 <mm_freak_> ocharles: it's not…  one could turn became/noLonger into a single event
13:05:32 <mreh1> :t nub
13:05:33 <lambdabot> Eq a => [a] -> [a]
13:05:44 <ChongLi> zipper: how'd I know that?
13:05:45 <mm_freak_> ocharles: not a single event, but a single event generator
13:05:54 <benzrf> > nub [1, 2, 3, 4, 1, 4, 3, 5]
13:05:56 <lambdabot>  [1,2,3,4,5]
13:06:00 <ChongLi> zipper: just look at Xmonad, for example
13:06:07 <ocharles> mm_freak_: maybe:   foo :: (a -> Bool) -> Wire a b -> Wire a b -> Wire a b  . Then I can run one wire until the predicate holds true, switch into that as long as it's true, and then back out to the first wire when it's false. And I can do that by restarting time, which is key
13:06:09 <ChongLi> it is not one single application to fit all
13:06:09 <zipper> ChongLi: Yeah how'd you know that it was happening in GHCI
13:06:17 <quchen> benzrf: It resolves an ambiguity problem with multiparameter typeclasses, see http://www.haskell.org/haskellwiki/Functional_dependencies
13:06:20 <nadirs>  I often read that XMonad is a great example to learn from, but how do you actually get started with that?
13:06:20 <nadirs> Did you started from the top main file or from a sub-library or did you load it in a REPL and play around with its functions? I'd like to give a try to the "learn from xmonad" advice
13:06:22 <benzrf> quchen: ok
13:06:32 <ChongLi> zipper: oh, because GHCI is interpreted
13:07:06 <ChongLi> nadirs: have you installed Xmonad and are you using it as your WM?
13:07:09 <zipper> benzrf: Really? I thought it compiles all functions in a file when I call the file.
13:07:29 <merijn> nadirs: I usually start by thinking what kind of data I need and design a rough data structure. I then write down the types of the operations I want/need to perform. Once I have a rough skeleton, I start implementing functions and as I do I figure out which helpers I want/need
13:07:36 <nadirs> ChongLi: ah, that's a good advice :) (I'm on Openbox actually)
13:07:40 <merijn> nadirs: So I write down the types for those and continue
13:07:51 <mm_freak_> ocharles: i'd have to check whether that is allowed
13:08:05 <ChongLi> nadirs: xmonad makes you write a Haskell program in order to configure it
13:08:07 <merijn> nadirs: There's several blogposts explaining the design of xmonad too
13:08:22 <ocharles> mm_freak_: check as in avoid the risk of exposing discrete time?
13:08:29 <mm_freak_> ocharles: yes
13:08:31 <benzrf> zipper: iunno
13:08:34 <prasadi> <merijn> is it possible to paste an image in lpaste.net ? no any other solution ?
13:08:42 <mm_freak_> ocharles: and i have a feeling that it won't be allowed
13:08:44 <benzrf> zipper: i know little to nothing about haskells impl
13:08:45 <ChongLi> when you change a setting, you press a hot-key and it recompiles and switches to the new version (maintaining the layout of all your windows)
13:08:46 <nadirs> merijn: I'd love to read some you might suggest :)
13:08:50 <benzrf> zipper: slow then fast just sounds like jit
13:08:51 <mm_freak_> ocharles: you can only switch based on events
13:08:51 <benzrf> :p
13:09:01 <ChongLi> and all your other settings
13:09:12 <merijn> nadirs: Wiki is probably a good place to start: http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
13:09:19 <benzrf> quchen: so a fundep states that one of the params will always be the same if one or more of the other params are the same?
13:09:21 <nadirs> ChongLi: so you start from the functions and modules that you need to configure it
13:09:22 <ocharles> mm_freak_: indeed. but I think what I wrote is just a refactoring of what I wrote earlier
13:09:30 <ChongLi> nadirs: yeah
13:09:36 <ChongLi> specifically the XConfig type
13:09:39 <nadirs> merijn: thanks
13:09:46 <nadirs> merijn++
13:09:48 <nadirs> ChongLi++
13:10:11 <mm_freak_> ocharles: rewrite it to something like:  Wire a b -> Wire a b -> Wire (a, Event X) b
13:10:26 <ChongLi> the most basic "config file" for Xmonad is:
13:10:32 <ChongLi> import XMonad
13:10:38 <ocharles> mm_freak_: so you're suggesting basically a flip-flop type thing?
13:10:40 <ChongLi> main = xmonad defaultConfig
13:10:56 <mm_freak_> ocharles: in combinator form this is quite usual
13:11:06 <ChongLi> then, from there, you just use a little record syntax and pry open defaultConfig
13:11:26 <ChongLi> http://xmonad.org/xmonad-docs/xmonad/XMonad-Core.html#t:XConfig
13:12:16 <ChongLi> I've heard numerous anecdotes from people who decided to learn Haskell after trying Xmonad
13:12:24 <quchen> benzrf: Something like that. There's also an answer on SO that explains it with a little more focus than the wiki, http://stackoverflow.com/questions/20040224/functional-dependencies-in-haskell
13:12:32 <nadirs> ChongLi: ok, I think I can do this. Definitely giving a try. Thanks!
13:12:42 <mkscrg> Is there a way to allow overlapping type instances?
13:13:16 <benzrf> OK
13:13:23 <benzrf> @src either
13:13:23 <lambdabot> either f _ (Left x)     =  f x
13:13:23 <lambdabot> either _ g (Right y)    =  g y
13:13:29 <benzrf> @src Either bimap
13:13:29 <lambdabot> Source not found. You type like i drive.
13:13:30 <ChongLi> mkscrg: there's an extension for it
13:13:31 <benzrf> hm
13:13:35 <benzrf> :t bimap
13:13:36 <lambdabot> Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
13:13:37 <nadirs> mkscrg: I don't know what that is, but I know there's a GHC extension for that
13:13:52 <prasadi> <merijn> I typed a part of the error ...http://lpaste.net/97897
13:14:04 <ChongLi> Cons: Makes it very easy for incorrect programs to still typecheck.
13:14:13 <ChongLi> Can cause confusing error messages.
13:14:15 <prasadi> and the question once again http://lpaste.net/97895
13:14:31 <benzrf> :t fmap
13:14:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
13:14:34 <benzrf> :t liftA2
13:14:35 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:14:42 <benzrf> :t liftA4
13:14:43 <lambdabot>     Not in scope: `liftA4'
13:14:43 <lambdabot>     Perhaps you meant one of these:
13:14:43 <lambdabot>       `liftA' (imported from Control.Applicative),
13:14:43 <benzrf> :t liftA3
13:14:45 <lambdabot> Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
13:14:49 <benzrf> hm
13:15:12 <benzrf> why does liftA exist when theres fmap
13:16:04 <ChongLi> or any of the others, for that matter, when there's <*>
13:16:37 <mkscrg> ChongLi nadirs available in 7.6?
13:17:17 <adimit> the choice between liftAn f x1 .. xn and f <$> x1 <*> .. <*> xn is largely stylistic.
13:17:27 <ChongLi> mkscrg: yes
13:17:28 <benzrf> yes, but what about liftA?
13:17:33 <benzrf> liftA is 100% the same as fmapE
13:17:34 <benzrf> *fmap
13:17:37 <zipper> Is there no way we can hold haskell pattern functions in braces or identation?
13:17:41 <benzrf> @src liftA
13:17:41 <lambdabot> liftA f a = pure f <*> a
13:17:45 <benzrf> hmm
13:18:01 <zipper> Reading from: V
13:18:02 <zipper> http://learnyouahaskell.com/syntax-in-functions
13:18:22 <prasadi> pls somebody help me to resolve the following error http://lpaste.net/97895      error is http://lpaste.net/97897
13:18:32 <ChongLi> zipper: I'm not sure what you mean, specifically
13:19:11 <ChongLi> Haskell supports both braces+semicolons and layout (indentation)
13:19:24 <ChongLi> you can mix and match them as you please
13:19:34 <adimit> benzrf: I honestly don't know, though my guess is that there could be a way where you could write implementations of fmap and <*>/pure of a certain data type that do behave differently.
13:19:40 <adimit> Though that doesn't seem like a sane thing to do.
13:20:02 <eikke> that'd be pretty insane at least indeed
13:20:18 <zipper> ChongLi: https://gist.github.com/urbanslug/8227083
13:20:36 <benzrf> adimit: that would be violating the applicative laws i think
13:20:40 <benzrf> !g applicative laws
13:20:44 <ChongLi> zipper: yes, what about it?
13:20:46 <benzrf> oh crap wrong bot
13:20:51 <benzrf> @wiki applicative laws
13:20:51 <lambdabot> http://www.haskell.org/haskellwiki/applicative_laws
13:21:07 <adimit> yes, it would most definitely violate the laws.
13:21:14 <zipper> ChongLi: How can that be written with indenting what happens in the function factorial
13:21:39 <ChongLi> zipper: I'm not sure what you mean
13:21:46 <ChongLi> there's no need for indenting there
13:21:57 <ChongLi> there's only one level of scope
13:23:17 <zipper> ChongLi: https://gist.github.com/urbanslug/8227083
13:23:25 <zipper> Look at it now
13:24:08 <ChongLi> ahh, I see
13:24:14 <zipper> Sorry I didn't pass a param
13:24:36 <zipper> ChongLi: So? can something close be done?
13:25:15 <ChongLi> zipper: you could use case, I suppose
13:26:08 <benzrf> zippers and lenses have similar use cases right ?
13:26:43 <edwardk> zippers are about going down into a structure and staying there so you can work locally more cheaply
13:26:50 <zipper> benzrf: You people are using my name and confusing me :O
13:27:13 <edwardk> lenses are kind f about staying outside of the structure, running down in and doing something and coming back up, before diving back down.
13:27:28 <ChongLi> zipper: https://gist.github.com/chongli/8227193
13:27:31 <ChongLi> something like this?
13:27:31 <benzrf> but similar use cases??
13:27:44 <edwardk> the lens package provides a notion of a zipper where you 'descend' using a lens or traversal, which helps bring them closer together, but really it is the usage pattern that sets them apart
13:27:50 <benzrf> alright
13:27:57 <benzrf> so should i learn both?
13:28:08 <edwardk> i use a zipper when i need to go in and do a lot of work in an area. i use a lens when i want to just tweak something
13:28:23 <ocharles> I have never used the zipper functionality in lens, so i'd say lenses are more worthwhile to learn
13:28:25 <benzrf> alright
13:28:25 <zipper> ChongLi: Yes I believe that is one way
13:28:27 <edwardk> both are useful abstractions and are part of the "culture" of Haskell
13:28:40 <adimit> benzrf: zippers a simple, lenses are more flexible. I think you might try starting out with zippers.
13:28:47 <zipper> When you said about having one level of scope though what did you mean
13:28:51 <adimit> You "should" learn both, ultimately.
13:29:06 <edwardk> ocharles: we're factoring zipper into a separate package in lens 4, because the 3.8 zippers were more accessible while the 3.9 ones are more powerful, and we want users to be able to choose.
13:29:09 <zipper> ChongLi: ASFAIK scope implies state
13:29:13 <ChongLi> when I think of a zipper, I think of a backtracking automaton in some decision tree or something
13:29:14 <ocharles> edwardk: yea, I thought you were
13:29:33 <edwardk> zipper: you've chosen the wrong nick for working in haskell if you don't want false positives ;)
13:29:53 <benzrf> i used to say 'aww' all the time whenever i was disappointed back in my #python days
13:29:59 <ChongLi> zipper: scope just controls how names are used
13:30:05 <edwardk> The only guy I can think of who is worse off is so.
13:30:10 <benzrf> and this guy with the nick 'Aww' would always respond with 'o:'
13:30:10 <zipper> edwardk: I chose this nick well before I started learning haskell
13:30:38 <ChongLi> zipper: scope allows us to re-use names
13:30:47 <ocharles> argh, accidental recursive let bindings
13:30:49 <ChongLi> that's basically it
13:30:50 * ocharles shakes a fist
13:31:05 <edwardk> ocharles: should have used nested cases ;)
13:31:12 <zipper> ChongLi: Yes exctly
13:31:12 <edwardk> ocharles: or -Wall
13:31:15 <zipper> *exactly
13:31:16 <merijn> ocharles: So annoying when the compiler doesn't read your mind on whether you want a recursive or non-recursive let, no? :p
13:31:24 <ocharles> edwardk: -Wall has so much noise right now, I would have missed that ;)
13:31:31 <ocharles> merijn: yea, wtf.
13:31:31 <zipper> variables without scope is so weird though
13:31:47 <edwardk> pretty much everything i write builds -Wall clean with a warning disabled here or there
13:31:49 <ChongLi> zipper: what variable doesn't have some scope?
13:32:28 <ocharles> edwardk: so does mine, but only when I settle down on what I want to do. right now I'm just fiddling, and I prefer to remain in the "does this idea actually make any sense?" context before switching to a clean up context
13:32:30 <zipper> I meant state not scope
13:32:34 <zipper> ChongLi: ^
13:32:37 <ChongLi> edwardk: I'm just glad it's not an error to have unused imports
13:33:10 <adimit> zipper: you're gonna have to rethink that mentality… Haskell variables are always immutable.
13:33:25 <edwardk> ChongLi: i'd like to know when i import a module i don't need, but to do that i just ask ghc to export the minimal version and tweak it
13:33:53 <edwardk> using -ddump-minimal-imports
13:34:21 <ChongLi> ahh, that's very nifty
13:34:27 <donri> needs better tooling
13:34:42 <edwardk> donri: agreed
13:34:43 <donri> there's a tool for it but requires recompiling with --ghc-options
13:34:45 <zipper> adimit: When I run a function and get different return values I feel like the state of the return value changes. So hard to accept that it is a different variable with the same name
13:34:47 <ChongLi> donri: that's what I'm working on here, albeit indirectly
13:34:52 <donri> oh (:
13:35:06 <ChongLi> the more we grow the community, the more people we'll have to write better tooling :)
13:35:30 <adimit> zipper: functions are referentially transparent in Haskell. I.e. their return value does *not* change given the same input.
13:35:32 <zipper> ChongLi: In the one you gisted earlier. Why did you pass n and use n' inside the function?
13:35:53 <donri> would be nice if we could extend cabal itself. most tools have problems that cabal solves ...
13:36:01 <donri> i rarely write haskell without a .cabal
13:36:11 <ChongLi> zipper: n' is in a nested scope
13:36:11 <donri> only for quick tests
13:36:14 <zipper> adimit: Well I meant when given different input.
13:36:24 <ChongLi> whereas n is in the parent scope
13:37:06 <ChongLi> I could have named them both n, but then the child would shadow the parent
13:37:20 <zipper> shadow?
13:37:26 <erisco> ivanm, ping
13:37:48 <ChongLi> shadowing just means you re-use the name, causing the old name to be unavailable until that scope exits
13:37:56 <zipper> ChongLi: I am used to all of them being called n.
13:38:01 <adimit> > let { x = 1 ; x = 2 ; in x + 2 }
13:38:02 <lambdabot>  <hint>:1:23: parse error on input `in'
13:38:19 <ocharles> mm_freak_: I got something nicer with your suggestions :) http://lpaste.net/2647801802740727808
13:38:30 <adimit> … oh wait, that won't even work.
13:38:32 <ocharles> mm_freak_: are 'edge' or 'alternate' anything you would like in netwire?
13:38:42 <ChongLi> zipper: the point is that n' can be treated differently from n, even if they both have the same value in this case
13:38:45 <zipper> ChongLi: I thought shadowing was a good thing/natural
13:39:02 <adimit> > let x = 1 in let x = 2 in x + 2
13:39:03 <lambdabot>  4
13:39:26 <ChongLi> zipper: it can force you to rename variables if you find you actually need the shadowed one
13:39:28 <zipper> Without explicitly passing the value of n to n' I wonder how it figures out that n is n'
13:39:29 <adimit> zipper: the above demonstrates shadowing. I assign 1 to x, then I assign 2 to x in a nested scope.
13:39:43 <adimit> (don't shadow. It's usually terrible.)
13:41:01 <mm_freak_> ocharles: holy crap!
13:41:13 <mm_freak_> i was sure i had at least edge in the release
13:41:48 <mm_freak_> 'alternate' would be useful as a combinator, so i might add it as well
13:41:55 <zipper> adimit: In this case https://gist.github.com/chongli/8227193 how does the compiler know that n is referring to n' without assignment?
13:42:11 <eikke> heh, my GHCs brain exploded ^_^
13:42:21 <ChongLi> zipper: this is how the case expression works
13:42:23 <merijn> zipper: There is no such thing as assignment in haskell
13:42:45 <ChongLi> case is one of the most fundamental parts of the language
13:42:50 <merijn> zipper: assignment means "copying a value to a location", haskell doesn't have locations, so values can't be copied into them either
13:42:55 <ocharles> mm_freak_: heh, i thought edge was there too
13:43:03 <jfischoff> when pattern matching you are introduce a name into scope
13:43:04 <mm_freak_> ocharles: it was in every older version =)
13:43:07 <ocharles> yea :)
13:43:13 <mm_freak_> can't believe i forgot to add it
13:43:14 <ocharles> mm_freak_: would you like me to try and write that in your style, or shall I leave it for you?
13:43:43 <ocharles> mm_freak_: well, users are for reminding you about all your imperfections, right? ;)
13:43:43 <mm_freak_> ocharles: would be very helpful if you did…  i have a lot on my desk right now =/
13:43:54 <ocharles> i'll give it a shot!
13:44:02 <zipper> merijn: What are lets?
13:44:30 <adimit> zipper: there is "implicit assignment" if you wish to call it that way in case statements. case p of { 0 -> … ; 1 -> … ; n -> … } says: if p is of the form 0, do this, if it is of the form 1, do the other thing, and if it is of any other form, call it n', and do the third.
13:44:32 <zipper> merijn: No assignment at all?
13:44:50 <mm_freak_> ocharles: just follow the general 4-space-indentation (2-space for 'case'), and it should be readable…  then that's fine
13:44:52 <ChongLi> zipper: unless you consider static single assignment
13:45:15 <adimit> we're using an informal version of the word "to assign" here. I.e. call this value "n."
13:45:31 <mm_freak_> ocharles: and yeah, from time to time i need you to remind me that i'm still only human =)
13:45:34 <merijn> zipper: Let associates a name with a value
13:45:49 <ChongLi> zipper: this is a necessary evil in order for Haskell code to actually run on a computer
13:46:01 <zipper> ChongLi: I figured
13:46:11 <merijn> zipper: You could call that "assignment" as in the English word, i.e. assigning names to values. It is not assignment in the traditional sense of other languages
13:46:38 <merijn> zipper: In other language "let foo = 1" says "there is a memory location, indicated by the name foo, and we store 1 into that location"
13:46:52 <zipper> merijn: but in haskell
13:46:56 <ChongLi> when most people talk about assignment in programming, they speak of repeatedly re-writing a value to a specific location
13:47:16 <merijn> zipper: Not so in haskell, where it just means "foo refers to value 1", the compiler may store this copy of 1 somewhere, or it may compute it on the fly or it may inline and eliminate it
13:47:19 <zipper> Here I see it as writing a value to a location but only once
13:47:20 <mm_freak_> ocharles: also remind me to add the Profunctor instance, i've been forgetting to add for weeks =)
13:47:36 <chrisdotcode> is there a name for "foldr `mappend` mempty"? because I feel it has some (special) name that I should know...
13:47:50 <mm_freak_> chrisdotcode: 'fold'
13:47:53 <mm_freak_> see Data.Foldable
13:48:03 <erisco> if I just need the a -> f a function then is Applicative the "smallest" standard class I can constrain to?
13:48:13 <chrisdotcode> mm_freak_: thought so. it has Monoid m as a constraint, of course, right?
13:48:22 <mm_freak_> erisco: either Applicative or Monad
13:48:30 <mm_freak_> chrisdotcode: yes
13:48:33 <ocharles> mm_freak_: would me just doing it be a sufficient reminder? :)
13:48:34 <mm_freak_> :t F.fold
13:48:35 <lambdabot> (Foldable t, Monoid m) => t m -> m
13:48:35 <chrisdotcode> mm_freak_: awesome. thanks :)
13:48:36 <merijn> erisco: There is Pointed, but it's not standard and has fallen out of favour (wtih reason)
13:48:36 <ocharles> you can always change my code
13:48:42 <mm_freak_> ocharles: of course =)
13:48:46 <adimit> chrisdotcode: wouldn't that be mconcat?
13:49:07 <ChongLi> Applicative is useful because it gives you some laws
13:49:08 <mm_freak_> ocharles: at some point feel free to add an AUTHORS file =)
13:49:20 <adimit> :t mconcat
13:49:20 <lambdabot> Monoid a => [a] -> a
13:49:26 <ocharles> mm_freak_: heh. do we have contravariant too?
13:49:54 <adimit> :t foldr mappend mempty
13:49:55 <lambdabot> Monoid b => [b] -> b
13:50:01 <ocharles> oh wait, we're not the right kind for contravariant
13:50:02 <ocharles> ignore that :)
13:50:58 <chrisdotcode> mm_freak_: oh, yes, I think so >_>
13:51:06 <chrisdotcode> the bad naming gets me confused, sorry
13:51:26 <chrisdotcode> mempty is the empty element. mconcat is the operation. so what's mappend again?
13:51:43 <shachaf> mappend is multiplication.
13:51:45 <chrisdotcode> mm_freak_: sorry that was to adimit
13:52:08 <shachaf> mconcat is a different deal. It is less important.
13:52:13 <mm_freak_> ocharles: Profunctor is closest to that
13:52:15 <adimit> chrisdotcode: actually, mappend is the operation, mconcat is just a convenience function.
13:52:52 <adimit> Kinda like with Σ, where it's really just a pretty way to write lots of instances of addition (+)
13:52:53 <chrisdotcode> adimit: oh, wait, I think I'm even more confused. isn't mconcat == foldr `mappend` mempty ?
13:53:00 <ocharles> mm_freak_: yea I know, ignore me
13:53:03 <shachaf> mconcat is important, but since you can't define a Monoid instance using just mconcat (since there are no default definitions for mappend/mempty), it's less important.
13:53:09 <bitemyapp> #python was no help, is there a credible equivalent to Parsec in Python?
13:53:23 <bitemyapp> Closest I've found is PyParsing and an abandoned blog post.
13:53:36 <bitemyapp> and PyParsing doesn't make it very easy to return parse-tree results that are nice to use in Python.
13:53:53 <hpc> i imagine if one was to write such an equivalent it would end up having lots of "lisp problems"
13:53:58 <adimit> chrisdotcode: no mconcat == foldr mappend mempty. foldr `mappend` mempty makes little sense besides adding a monoid constraint to your result.
13:53:59 <hpc> which is to say... )))))))))))))))))))))))
13:54:18 <Hafydd> ))))))))))))))))))))))):
13:54:45 <chrisdotcode> adimit: oh, my mistake, I'm so used to doing x `mappend` y that I did it instinctively.
13:54:54 <marshjello> How come I can only remember words or numbers when I repeat them in my head silently but not vocally?
13:55:17 <adimit> chrisdotcode: the tragic thing here is that foldr `mappend` mempty actually typechecks :-P
13:55:20 <rhodesd> bitemyapp: pyparsing is pretty good, but I've found pyPeg to be a bit better.
13:55:23 <adimit> :t foldr `mappend` mempty
13:55:24 <lambdabot> Monoid b => (a -> b -> b) -> b -> [a] -> b
13:55:24 <hpc> marshjello: gremlins in the atmosphere steal the words before they get back to your ears
13:55:33 <hpc> marshjello: solution is to say the words out loud in space
13:55:50 <simpson> bitemyapp: The correct equivalent is probably PLY, which has the same ability to commit to a choice as Parsec.
13:55:59 <simpson> bitemyapp: Also don't cross-post; you're having a fine conversation in #python.
13:56:11 <marshjello> lol
13:56:19 <marshjello> ok ill go to space
13:56:44 <bitemyapp> simpson: I'm not using something that relies on lex and yacc.
13:56:55 <Komier> sum. takeWhile (<10000) . filter odd . map (^2) $ [1..]
13:56:59 <hattmammerly> can you declare more than one thing in a where clause?
13:57:04 <Komier> argh soz wrong window
13:57:10 <simpson> hattmammerly: Sure!
13:57:12 <Fuuzetsu> hattmammerly: try and see
13:57:13 <adimit> hattmammerly: as many things as GHC will parse.
13:57:25 <simpson> > a * b where { a = 6; b = 7 }
13:57:26 <lambdabot>  <hint>:1:7: parse error on input `where'
13:57:34 <hattmammerly> Fuuzetsu: I did, but I'm getting possible indentation error and I can't tell why
13:57:39 <simpson> Oh right, needs braces.
13:57:41 <hpc> hattmammerly: where clauses are commonly used for lots of definitions, more so than let-in
13:57:58 <hattmammerly> alright, that's what I thought.
13:58:00 <hpc> simpson: it needs to be something that can actually have where attached
13:58:02 <Fuuzetsu> hattmammerly: it's the same syntax as ‘let’, really
13:58:09 <Fuuzetsu> make sure your definitions line up
13:58:10 <hpc> simpson: "where" is a modifier to definitions, not expressions
13:58:11 <mm_freak_> bitemyapp: python doesn't exactly make it easy to have parser combinators
13:58:23 <bitemyapp> mm_freak_: believe me, I know.
13:58:24 <simpson> hpc: Ah, that's right.
13:58:33 <Fuuzetsu> mm_freak_: Python doesn't exactly make it easy.
13:58:41 <mm_freak_> bitemyapp: lack of relevant optimization, syntax, etc…  i'd almost say:  just use a parser generator
13:58:44 <benzrf> i dont think ive ever used let-in
13:58:59 <Komier> Do you guys ever get used to using so many symbols when you typing?  Going wear my shift key out. lol
13:59:07 <benzrf> only do-lets, occasionally
13:59:11 <S11001001> Komier: yep
13:59:20 <Fuuzetsu> Komier: Join the ‘Programmer's Dvorak’ keyboard layout master-race
13:59:33 <Fuuzetsu> mast symbols are no longer shifted
13:59:45 <hpc> Komier: to a certain extent; there's a certain popular package which may or may not have an absolute overload of operators
13:59:48 <hpc> ;)
14:00:01 <mm_freak_> Fuuzetsu: URL?
14:00:04 <hpc> but for the most part the operators get quite comfortable to use
14:00:09 <Fuuzetsu> mm_freak_: to?
14:00:16 <hpc> over time learning what each of them do, ofc
14:00:24 <mm_freak_> Fuuzetsu: programmer's dvorak
14:00:26 <Fuuzetsu> http://www.kaufmann.no/roland/dvorak/
14:00:33 <mm_freak_> thanks
14:00:54 <hattmammerly> oh, I was missing a paren :(
14:01:10 <Komier> Fuuzetsu : now that's a weird keyboard layout :O
14:01:11 <SLi> Hmm, I wonder if it's possible to unconditionally fail a parse in attoparsec? In a simpler way than something like satisfy (const False).
14:01:21 <AshyIsMe> woah, i use dvorak
14:01:26 <AshyIsMe> i should switch to programmer's dvorak
14:01:29 <AshyIsMe> that looks awesome
14:01:41 <Komier> hpc: hope so!  Feels very awkward doing all this shift and stretch :D
14:01:45 <Fuuzetsu> Komier: Weird? It's like Dvorak (unarguably superior layout than QWERTY for English) except with some things moved around for programming
14:01:47 <hpc> Fuuzetsu: he wastes the homerow on non-english letters when he could be using them for $@%& and other ridiculous perlisms
14:01:49 <adimit> I tried programmer's dvorak, but the difficult access to numbers didn't make it much easier to use in the end.
14:02:26 <SLi> I wrote a program a while ago to optimize (using simulated annealing) keyboard layout to efficiently produce a text corpus. And a scoring function.
14:02:28 <hpc> Komier: the general rule is that if you find yourself ever being slowed down by typing, you have not thought enough ;)
14:02:43 <SLi> In C and Python, so I cannot show it to you because it's so shameful :(
14:02:50 <hpc> you'll often find there's a better way to do it which reduces typing significantly
14:03:00 <Fuuzetsu> SLi: Was it a genetic algorithm? Because if yes, then you might need to reupload it all because it has been a dead link on the Internet forever
14:03:02 <Komier> hpc: hah I like that.
14:03:15 <hpc> and that's really what the operators let you do
14:03:25 <SLi> Fuuzetsu: No, simulated annealing.
14:03:34 <hpc> but yeah, it does get better
14:03:38 <hattmammerly> next question! can I somehow use pattern matching to turn an IO String into a String inside a where clause?
14:03:43 <Fuuzetsu> oh, I don't know what that is so I mentally skipped over that part
14:03:47 <adimit> hattmammerly: no you cannot.
14:03:48 <Polarina> hattmammerly, you can not.
14:03:52 <benzrf> hattmammerly: thats ridiculous
14:03:53 <Fuuzetsu> oh boy here we go
14:03:59 <dwcook> @where /bin/ls
14:04:00 <lambdabot> I know nothing about /bin/ls.
14:04:01 <adimit> hattmammerly: you cannot escape the IO monad.
14:04:04 <dwcook> @quote /bin/ls
14:04:04 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:04:10 <hattmammerly> haha alright, that's what I thought. thanks all
14:04:12 <SLi> I use dvorak myself and wouldn't switch back to qwerty. Not so much for the typing speed (I'm not sure if my typing is faster than it used to be with dvorak), but it feels so much more comfortable to my wrists - and I didn't even realize my wrists felt bad before I tried dvorak.
14:04:22 <SLi> s/with dvorak/with qwerty/
14:04:37 <merijn> hattmammerly: To answer your next question, the way you want to work with "IO x" is most likely fmap and/or >>=
14:04:43 <Fuuzetsu> SLi: I actually switched to Dvorak to be able to type again without major pain after 20 mins
14:04:45 <adimit> I switched to dv because of emacs/quertz/latex-induced RSI.
14:04:49 <jfischoff> I think its not an unusual question
14:04:55 <Fuuzetsu> and seeing as I was switching layouts anyway, I went for Programmer's like 2 days after
14:05:06 <mm_freak_> hmm…  i wish there was something like dvorak for germans
14:05:08 <Polarina> Writing for 4 hours straight with Dvorak hurt my wrists just as much as with QWERTY.
14:05:10 <merijn> hattmammerly: Specialising their types to IO you get "fmap :: (a -> b) -> IO a -> IO b" and "(>>=) :: IO a -> (a -> IO b) -> IO b"
14:05:18 <hattmammerly> merijn: I knew that much. I'm dealing with two types of monads at the moment and I'm trying to stay neat
14:05:20 <adimit> mm_freak_: you can use xcompose for umlauts. that's what I use.
14:05:23 <Fuuzetsu> mm_freak_: isn't there? There are quite a few language-specific versions
14:05:25 <jfischoff> Most monads have their constructors exported and pattern matching is useful
14:05:29 <adimit> plus there actually is a German version of Dvork.
14:05:32 <hattmammerly> err, concise
14:05:46 <merijn> hattmammerly: "two types of monads" usually means it might be time to look up monad transformers :)
14:05:51 <adimit> mm_freak_: http://rffr.de/dvorak
14:06:10 <mm_freak_> Fuuzetsu: the author of that page states that a german typer will not gain from dvorak, because it follows analysis that was made for english
14:06:13 <merijn> hattmammerly: Depending on which monads you have
14:06:17 <Komier> how long it take you to get used to the new layout?
14:06:17 <mm_freak_> adimit: thanks
14:06:18 <hattmammerly> merijn: huh, new to me. I'll look at those!
14:06:20 <hattmammerly> merijn: parsec and IO
14:06:24 <erisco> I think some people are ergonomically reckless and dvorak helps because it initially slows them down but also causes different stresses
14:07:00 <Fuuzetsu> mm_freak_: Yes, that's right. I even mentioned that a bit above but fortunately a bulk of programming is done in English and as programmer's, you probably type in English most of the type anyway
14:07:05 <merijn> hattmammerly: Ah, Parsec already is a monad transformer, you might be able to get away with just writing "liftIO" in front of your IO type
14:07:18 <Polarina> mm_freak_, but it depends how much you generally write in English vs. German. For me, having my language variant of Dvorak is just a convenience so I don't have to switch all the time, not that Dvorak helps much with it.
14:07:45 <mm_freak_> Fuuzetsu: my code is in english, but at work i have to alternate a lot between programming (en) and using various other systems (de)
14:07:47 <adimit> yeah, I write German and English in Dvorak + xcompose.
14:07:53 <SLi> Well, I very much doubt I'm still temporarily slowed down with dvorak compared to qwerty after, what, 5 years of use. I'm fairly sure I'm now quite a bit more proficient with dvorak than qwerty (but haven't made speed tests).
14:08:12 <mm_freak_> i'll look into xcompose
14:08:14 <adimit> and cyrillic using an actual cyrillic layout that makes sense.
14:08:28 <Fuuzetsu> mm_freak_: Well, it won't be worse than QWERTY!
14:08:49 <merijn> Fuuzetsu: It will, because QWERTY skills are at least portable :p
14:08:50 <adimit> I find it reasonably comfy for writing German, actually.
14:08:58 <mm_freak_> Fuuzetsu: qwertz is actually great for german
14:09:01 <Fuuzetsu> SLi: Well, it's not about speed to begin with
14:09:33 <mm_freak_> it's almost like qwert* was originally made for german and later bent into english
14:09:35 <Fuuzetsu> merijn: When I have to type QWERTY, I just look at the keyboard to see what I'm doing. In any case, my housemate for example can type pretty well in both so it's not impossible
14:09:44 <erisco> SLi, for example I used to play xbox 360 a lot and I developed intense pain in my right thumb. I was gripping the controller unconsciously too tightly, which was poor ergonomically, and using a different controller layout helped because the angles were different
14:09:53 <Komier> qwerty was made to stop typewriters jamming lol
14:10:19 <Fuuzetsu> Eh, the origins are… unclear
14:10:27 <Taneb> Komier, having used a typewriter, it doesn't stop me
14:10:51 <Taneb> I can jam my typewriter easily :(
14:10:54 <SLi> http://sli.dy.fi/~sliedes/kbgen/ (no warranty, sorry, and it's not even Haskell :p) And those layouts tuned are for a mixture of Finnish and English (and no Haskell). Still I think it should be possible to get an improvement of roughly the same size of qwerty->dvorak by switching dvorak->custom.
14:10:57 <merijn> Either was product type and tuple sum type, right?
14:11:07 <adimit> qwerty was invented so you can write "typewriter" all in the first row.
14:11:23 <Fuuzetsu> merijn: no, the other way
14:11:39 <benzrf> SLi: qwerty -> dvorak is uninhabited silly
14:11:46 <merijn> Fuuzetsu: right, thanks
14:11:48 <SLi> benzrf: :-)
14:12:20 <SLi> http://sli.dy.fi/~sliedes/kbgen/11813581.pdf is the worst layout I could figure out, just because I can :P
14:12:24 <Fuuzetsu> benzrf: There's always usafeCoerce!
14:12:28 <adimit> merijin: Either a b is inhabited by all types inhabiting a + all types inhabiting b. (a,b) is inhabited by a * b.
14:12:37 <adimit> easy way to remember :-)
14:12:54 <Fuuzetsu> SLi: I think you could do better by moving ‘a’ farther away
14:15:24 <SLi> Fuuzetsu: That's possible. Actually I think the optimized layouts use a nice idea that I haven't seen anywhere. For example in http://sli.dy.fi/~sliedes/kbgen/6478937.pdf if you look at where 'a' is, above it is 'å' (really never used in Finnish either) and below it 'y' (rare), so it's not only about the placement of keys alone: This way you nearly never need to move your finger from the common 'a' key. Usually the focus in layout design seems to be just in
14:15:24 <SLi> making each common letter easily (or difficultly, in case of qwerty) reachable in isolation.
14:16:31 <SLi> That obviously results from my scoring heuristic which gives scores to digraphs (or di-keys really) based on my subjective feeling of how painful it is to press those keys in succession.
14:16:48 <merijn> Notation question, what does the middle rule of the bottom left table on page 4 mean? https://dl.dropboxusercontent.com/u/1841232/Chapman%20et%20al.%20-%20The%20Gentle%20Art%20of%20Levitation.pdf
14:17:10 <Fuuzetsu> SLi: I can't say that's true. Wasn't Dvorak designed with common letter sequences being close to each other rather than just lumping common letters on the home row?
14:17:48 <hpc> merijn: figure 3?
14:17:55 <SLi> Fuuzetsu: yeah, to some extent. And things like vowels on the left hand side.
14:18:31 <merijn> hpc: eh, I guess I mean page 2 (I was looking at the page numbering which for some reason starts at 3)
14:18:38 <hattmammerly> Fuuzetsu: supposedly dvorak also factors in that it's easier to roll fingers pinky->pointer than the other way around
14:18:56 <hpc> oh, those are reduction rules i think?
14:19:00 <jle`> be advised that any claim involving the efficacy of keyboard layouts is at best psuedo-science and should be taken with a grain of salt
14:19:06 <hpc> i don't know the exact name for what they are
14:19:23 <threestrikes> exit
14:19:25 <merijn> hpc: No, they're deduction rules
14:19:35 <merijn> hpc: I just don't understand the middle one
14:20:14 <merijn> Although now I'm doubting my understanding of the 3rd row too
14:20:17 <hpc> merijn: close enough in a d-t language ;)
14:20:53 <hpc> merijn: my understanding of row 3 is that s -> (s -> t) -> (s, t)
14:21:48 <hpc> row 4 i think is the dependent version of such?
14:23:58 <hpc> it looks like from row 3 to row 4, T changes to take some "s" as a parameter
14:24:32 <hpc> oh, it's just Σ
14:24:36 <merijn> hpc: I thought row 3 was "S :: *, T :: *" and t is a term with type T with s replaced by 'x'?
14:24:57 <merijn> i.e. T is a dependent term
14:24:59 <hpc> merijn: yeah; which you can interpret as T :: S -> *; T[s/x] = T x
14:25:24 <merijn> I'm unsure why he went with "(x :: S) x T :: *" for the tuple syntax, though
14:25:27 <hpc> so it's, assume x : S, T : S -> Set, t : T x
14:26:01 <merijn> hpc: Right, so basically a tuple whose remaining argument depends on the initial one
14:26:14 <hpc> and we get a dependent tuple for S, consisting of x, t
14:26:31 <merijn> Yeah
14:26:44 <merijn> But I don't understand the square bracket subscript syntax in row 4, then
14:26:56 <hpc> yeah, that part is weird
14:27:08 <benzrf> why are single-letter type variables so prevalent?
14:27:16 <hpc> i think that's meant to be his notation for constructing a dependent tuple
14:27:43 <benzrf> why do we always have '(a -> b) -> [a] -> [b]' instead of '(arg -> result) -> [arg] -> [result]'?
14:27:44 <merijn> benzrf: Well, what else would you use?
14:27:51 <merijn> benzrf: Brevity
14:27:55 <hpc> [s,t] : x `cross` T -- or something like that
14:27:56 <benzrf> ...
14:27:57 <Fuuzetsu> benzrf: we're lazy
14:27:59 <merijn> benzrf: I find the latter harder to read, tbh
14:28:16 <merijn> benzrf: Longer variable names make it harder to see the "shape" of a type
14:28:27 <hpc> benzrf: there's no more descriptive name
14:28:44 <hpc> benzrf: (in this case the main obfuscator is his abuse of [])
14:29:15 <Fuuzetsu> ⟦ ⟧ ×
14:29:29 <erisco> I don't think arg -> result adds any information to the type
14:29:33 <hpc> the subscript is confusing too
14:29:38 <donri> SLi: didn't follow discussion but i take it you've looked at colemak, workman, carpalx?
14:29:43 <erisco> it is like saying  int aVariable = 5;
14:29:52 <hpc> benzrf: anyhoo, it's really not much different from using i,j,k in loops
14:29:57 <benzrf> meh
14:30:43 <shachaf> one function's argument is another function's result
14:30:55 <Fuuzetsu> hpc: stringIterotorOfAListOfStrings is so much clearer!
14:31:01 <kleinucopia> is there a way to make a local hoogle search every .hoo file? combining them seemed to have no effect.
14:31:37 <Fuuzetsu> kleinucopia: combine what you need and make it your default database
14:31:52 <maxiepoo> the main thing bothering me lately about type annotations in Haskell is that foralls are implicit
14:31:58 <Fuuzetsu> you can't tell it to search separate databases at once
14:32:09 <maxiepoo> so you have to read through the entire type to see how many things are being universally quantified
14:32:12 <Fuuzetsu> maxiepoo: -XExplicitForall
14:32:28 <maxiepoo> Fuuzetsu: yeah but that doesn't make all the libraries I'm using do it
14:32:29 <kleinucopia> Fuuzetsu: how would you call hoogle to do that?
14:32:48 <Fuuzetsu> kleinucopia: isn't it like ‘hoogle combine <files>’?
14:33:29 <donri> maxiepoo: does the count itself matter?
14:34:13 <maxiepoo> it's not the count itself but it's saying "these are the things we're abstracting over"
14:34:32 <Polarina> mm_freak_, when using netwire, how would you begin to attack the problem of saving state, like the current state of a game?
14:34:34 <kleinucopia> Fuuzetsu: hmm, must have broken before when I tried, worked this time. thanks
14:34:41 <hpc> merijn: he doesn't seem to be using that bracket notation anywhere else in the paper, perhaps read the rest and see if there's anything in that which requires understanding of the rule?
14:34:42 <Fuuzetsu> no problem
14:36:00 <mm_freak_> Polarina: currently it's pretty much impossible
14:36:23 <mm_freak_> Polarina: funny enough that i'm working on an FRP abstraction that uses STM and acid-state =)
14:38:16 * eikke is stuck and hates it :(
14:38:32 <Polarina> mm_freak_, :-)
14:39:05 <Fuuzetsu> eikke: What's the problem? Have you tried to use the type system to guide you?
14:39:41 <eikke> Fuuzetsu: sure. I sent a message to the cafe a couple of hours ago (note I don't expect an instant reply, but been looking at this for way too long and getting frustrated ;))
14:40:02 <aristid> mm_freak_: netwire is getting support for STM? oO
14:40:13 <mm_freak_> aristid: no
14:40:26 <Polarina> mm_freak_, how do you plan on using STM in any meaningful way with netwire?
14:40:26 <mm_freak_> not netwire…  it's a different abstraction
14:40:33 <Fuuzetsu> eikke: what thread?
14:40:38 <mm_freak_> Polarina: ^
14:40:43 <Polarina> Ah, I see.
14:40:49 <aristid> mm_freak_: so what's the new abstraction?
14:42:13 <mm_freak_> aristid: only ideas so far…  for this purpose it would be beneficial to have first class behaviors, so it will be a monad that can produce events and behaviors
14:42:24 <Polarina> mm_freak_, I thought of something like this myself: instead of producing a new function for the next step, it's always the same function backed by a lens (or something) to keep track of the state.
14:42:24 <aristid> mm_freak_: what's the goal?
14:42:30 <kleinucopia> Fuuzetsu: seems like hoogle combine a b followed by  hoogle combine c b eliminates a.
14:42:32 <eikke> Fuuzetsu: will get back to you in a minute, my wifi is acting up
14:42:36 <mm_freak_> i've been successful in writing an STM-based FRP abstraction, but without storage
14:42:42 <kleinucopia> Fuuzetsu: guess that's the point of rehoo
14:43:04 <mm_freak_> Polarina: my approach is a lot simpler
14:43:22 * Polarina is now very curious.
14:43:31 <ocharles> mm_freak_: ok, Profunctor, Choice and Strong instances added
14:44:00 <ocharles> mm_freak_: is this STM stuff related to ContinueT?
14:44:01 <mm_freak_> aristid: the goal is to have first class behaviors with the inhibition model that relate to stored data
14:44:06 <mm_freak_> ocharles: indeed
14:44:16 <mm_freak_> ocharles: and thanks, i will merge it tonight =)
14:44:32 <ocharles> Just adding "alternate" now
14:44:42 <eikke> Fuuzetsu: http://www.haskell.org/pipermail/haskell-cafe/2014-January/111992.html
14:44:43 <merijn> hpc: Ooh!
14:44:50 <merijn> I think x.T might be a lambda!
14:44:52 <Eduard_Munteanu> Is there a UTF8 Text variant?
14:44:57 <merijn> i.e. "x -> T"
14:45:07 <danilo2> If anybody did not see it, I think it is worth mentioning: https://news.ycombinator.com/item?id=6919216 :D
14:45:18 <merijn> Eduard_Munteanu: EQUESTION_DOES_NOT_MAKE_SENSE?
14:45:31 <merijn> Eduard_Munteanu: You mean which uses UTF8 internally?
14:45:35 <Eduard_Munteanu> merijn: yes
14:45:45 <Eduard_Munteanu> Unlike UTF16.
14:45:48 <merijn> Eduard_Munteanu: Yes, but it was scrapped after it was benchmarked to have worse performance in almost every way
14:46:08 <merijn> I believe it was a GSoC project
14:46:21 <Eduard_Munteanu> Hm, that's odd.
14:46:33 <hpc> merijn: man, you know what my favorite thing is?
14:46:41 <hpc> weirdo dynamic scoping in math papers
14:46:43 <eikke> it was a GSoC project by jaspervdj indeed iirc
14:46:55 <Eduard_Munteanu> Well, not so odd for the per-char operations.
14:46:57 <hpc> the one place in the whole damn world where \x -> T is not a constant function
14:47:45 <merijn> hpc: Essentially, I think [s,t] is the value level of the above "(x : S) x T" dependent tuple!
14:48:04 <hpc> yeah, that's what i said
14:48:06 <hpc> i think
14:48:08 <merijn> Especially since the below note mentions that square brackets are tuples
14:48:21 <erisco> wow such notation much clarity
14:48:28 <merijn> hpc: That's how I feel all the time with these papers
14:48:39 <merijn> erisco: tbh, I can't fully blame the authors
14:48:49 <Eduard_Munteanu> Any idea if it was a purely Haskell implementation, as opposed to calling out to straight C?
14:49:03 <hpc> merijn: i wish you could just reject that notation outright :(
14:49:12 <merijn> erisco: I read both the "pre-print" version of View from the Left as well as the printed one
14:49:12 <Komier> Do people use lambda functions a lot in Haskell / programming?
14:49:21 <hpc> even /perl/ programmers don't use dynamic scope anymore
14:49:25 <merijn> erisco: i.e. after editors and reviewers were through with it
14:49:42 <hpc> Komier: very rarely will you see an actual lambda
14:49:42 <merijn> erisco: Page count got halved and everything became a lot less readable
14:50:00 <merijn> erisco: When I talked to pigworker he said he was basically forced to do that to get it published
14:50:04 <hpc> Komier: when something gets used often enough, it gets abstracted away; so it is with many common lambda functions
14:50:08 <merijn> hpc: I use them quite a bit
14:50:18 <merijn> hpc: With stuff like bracket
14:50:19 <hpc> instead of writing \x -> 5, you see const 5
14:50:28 <erisco> merijn, there is something about the academic publication media that does not make much sense
14:50:44 <merijn> erisco: And by something you mean "nearly all of it"?
14:50:45 <merijn> :)
14:50:56 <mm_freak_> aristid: to answer your question:  the goal is to get reactive web applications with storage and components
14:51:14 <Komier> hpc: Yeh, I was looking at some examples and I get how they are used, but couldn't really understand why you would use them often, if at all.
14:51:16 <erisco> from what little I've seen, the methods appear dated and rooted in tradition
14:51:23 <aristid> mm_freak_: with non-continuation URLs?:)
14:51:24 <merijn> hpc: Right, now the rest of the rules make sense too :)
14:51:34 <hpc> Komier: sometimes they are unavoidable
14:51:37 <hpc> Komier: try this in ghci
14:51:46 <merijn> mm_freak_: Have you ever looked at Ur/Web?
14:52:00 <hpc> import Control.Monad; forM_ [1..10] $ \x -> print (x, x**2)
14:52:02 <mm_freak_> aristid: ContinueT takes care of that…  you get good URLs, but the API still looks like continuations
14:52:09 <mm_freak_> merijn: yes
14:52:21 <hpc> Komier: you can eliminate the lambda there but it's ugly
14:52:30 <hpc> and what if that print is more complex?
14:52:34 <erisco> merijn, for example, why is there such a strong insistence on the author commenting on related works when we have search engines?
14:52:41 <aristid> mm_freak_: huh, is that a different ContinueT than you showed me some months ago?
14:52:47 <merijn> mm_freak_: Please learn from their mistake of assuming that all form submissions come from properly rendered forms :)
14:52:49 <erisco> it seems like an old way for academics to browse through papers
14:52:51 <mm_freak_> aristid: it's the one from:
14:52:55 <mm_freak_> @hackage continue
14:52:56 <lambdabot> http://hackage.haskell.org/package/continue
14:53:02 <zipper> Thank you guys
14:53:07 <merijn> erisco: Because the search engines are fairly sucky and limited
14:53:08 <zipper> Good night
14:53:19 <merijn> erisco: Also, the clarify what the difference between things are
14:53:28 <mm_freak_> merijn: one of the things i do professionally is security consulting =)
14:53:28 <merijn> erisco: As well as hilight similarities
14:53:31 <hpc> merijn: do you ever wish that those papers would be single-column?
14:53:37 <Eduard_Munteanu> Oh, hm, I guess UTF8 does involve possibly unaligned access for non-ASCII chars.
14:53:38 <Komier> hpc: hmm ok thanks.  Still new at this programming lark. :)
14:53:52 <hpc> i feel like i have to take a 1080p monitor sideways to read comfortably
14:53:54 <merijn> hpc: It varies by day :)
14:53:57 <ParahSailin> i seem to use lambdas a lot when the arguments of a function are in the "wrong" order and its more than two of them
14:54:03 <eikke> JPohlmann: I wish papers wouldnt be PDF, but something which can be adapted to screen ratio etc
14:54:08 <Eduard_Munteanu> I care about ASCII stuff though, to feed it to Alex.
14:54:13 <hpc> ParahSailin: oh god i know exactly what you mean
14:54:34 <eikke> oops
14:54:40 <eikke> hpc: ^^ above was for you
14:54:48 * bennofs would like to get the original latex source for papers
14:54:53 <erisco> merijn, that is useful perhaps, but I did not like the burden when I just wanted to write my meagre undergrad paper :P
14:54:58 <merijn> mm_freak_: You can handle it gracefully in Ur, but it's not the default, which is just poorly thought out. That and the syntax is horrendous, which has been the main reason not to do much with it yet :)
14:55:02 <eikke> benj_: +1
14:55:03 <ParahSailin> i also seem to use lambdas a lot for foldl and foldr
14:55:39 <Eduard_Munteanu> BTW, how do you convert Word8 <-> 8bit Char, and fast?
14:56:05 <ParahSailin> Data.Char?
14:56:06 <flebron> Eduard_Munteanu: In case you care && remember, this is what I did with the existential types: https://github.com/fedelebron/AVL/tree/master/Data/Tree/AVL
14:56:27 <ParahSailin> or if you mean really fast, unsafeCoerce
14:56:31 <erisco> merijn, someone can always come along as write a survey or separate paper for comparison. *shrug* just does not seem scalable
14:56:32 <eikke> Eduard_Munteanu: Data.Char.chr . fromIntegral ?
14:56:38 <hpc> Eduard_Munteanu: if you know the Word8 never has the last bit flipped, unsafeCoerce maybe?
14:56:39 <Komier> ParahSailin: Ah that makes sense too, will keep that in mind for when I can actually cod :D
14:56:44 <Komier> code ^
14:56:48 <Eduard_Munteanu> ParahSailin: yeah, I'm looking for a fast way to do it, without calling unsafeCoerce myself.
14:56:51 <Fylwind> is there a way to specify a Constraint that indicates "every type allowed in Haskell" (i.e. the "null constraint")
14:56:59 <erisco> not only do you have to do your own research but somehow be versed in all related research to make apt comparisons *shrug*
14:57:08 <Eduard_Munteanu> Fylwind: ()
14:57:08 <merijn> Fylwind: Yes, ()
14:57:11 <bennofs> Fylwind: ()
14:57:14 <Fylwind> ah thanks
14:57:14 * bennofs is slow
14:57:18 <hpc> Eduard_Munteanu: it worked in my highly unscientific example of 32
14:57:26 <ParahSailin> you can do a safe coerce with that Word2Int# thingy or whatever it is from GHC.Base
14:57:44 <ParahSailin> er word2Int#
14:57:49 <hpc> ooh, that's much better
14:57:52 <bennofs> @check \(x :: Word8) -> unsafeCoerce x == chr (fromIntegral x)
14:57:52 <lambdabot>  <unknown>.hs: 1: 15:ScopedTypeVariables is not enabled
14:57:53 <hpc> and then chr
14:58:36 <mm_freak_> merijn: i'm taking the digestive-functors route, adding some of the benefits of reform
14:58:48 <mm_freak_> merijn: of course with automatic validation and CSRF
14:59:26 <merijn> mm_freak_: Sounds like I really need to start looking into netwire 5, but my queue of things to look into is write-only, it seems xD
14:59:31 <hpc> huh, coercing works across the whole range of Word8
14:59:40 <ParahSailin> @ty \(W# w8) -> (C# (chr# . word2Int# w8))
14:59:41 <lambdabot> Not in scope: data constructor `W#'
14:59:41 <mm_freak_> merijn: wait, this has nothing to do with netwire
14:59:41 <lambdabot> Not in scope: data constructor `C#'
14:59:41 <lambdabot>     Not in scope: `chr#'
14:59:58 <hpc> @src Char
14:59:58 <lambdabot> data Char = C# Char#
15:00:03 <Eduard_Munteanu> flebron: btw, instead of a "deep" embedding like that, you might also be able to use singletons of said type to pattern-match
15:00:05 <hpc> @src Char#
15:00:05 <lambdabot> Source not found. Sorry.
15:00:24 <shachaf> I'd double-check that the Core generated for the obvious code isn't already what you want.
15:00:25 <flebron> Eduard_Munteanu: Whaddayamean? (What's a "deep" embedding?)
15:00:29 <Eduard_Munteanu> eikke: how does that compare to unsafeCoerce? I'm unclear if it's a noop indeed.
15:00:38 <eikke> Eduard_Munteanu: ask ghc-core
15:00:45 <Eduard_Munteanu> Ah.
15:00:59 <mm_freak_> merijn: there was a proof of concept web framework using an old version of netwire, but the signal network concept does not handle storage very well
15:01:07 <mm_freak_> it's called webwire, if you're interested
15:01:16 <erisco> merijn, have you written many papers? I am considering aiming for a research career and wouldn't mind some insight
15:01:30 <ParahSailin> id guess that the core generated for the one above would not have redundant instructions
15:01:39 <mm_freak_> merijn: it was nice to work with, until you wanted acid-state and multiple threads
15:01:39 <Eduard_Munteanu> flebron: er, well, that's not deep, sorry. I meant keeping the value that decides the tree height out of the tree itself.
15:01:49 <merijn> mm_freak_: I dropped in the middle of the conversation, I though you were referring to something based on netwire :)
15:02:12 <Eduard_Munteanu> But the existential is already like that.
15:02:30 <mm_freak_> merijn: netwire is a good option, if you have something scene-based that you can sensibly split into individual frames
15:02:34 <merijn> erisco: Wrote 6, got published 4 times. Although I think the only paper of the 6 that was worth anything was rejected
15:02:47 <merijn> erisco: I still need to redo and resubmit that one
15:02:56 <mm_freak_> merijn: like real-time games and game servers…  it's not a good option for web applications
15:03:07 <erisco> I don't even know where most of these journals are found
15:03:34 <merijn> mm_freak_: yeah, so same stuff as netwire 4 :)
15:03:39 <mm_freak_> currently i'm torturing reactive-banana for my web stuff, but it doesn't handle it well either
15:03:39 <Eduard_Munteanu> Hm, I think I'll just use a normal bytestring.
15:03:45 <merijn> erisco: CS doesn't really do journals all that much
15:03:50 <mm_freak_> merijn: same stuff as any AFRP =)
15:03:53 <merijn> erisco: Most stuff gets done in conference proceedings
15:05:31 <erisco> merijn, other than uni profs who else is hiring phds for research? companies like IBM?
15:05:56 <merijn> erisco: You mean to do a phd or if you already have one?
15:06:10 <erisco> merijn, assuming you already have one
15:06:31 <merijn> erisco: Google, Facebook, MS, those type of dealios
15:06:47 <merijn> erisco: Lots of obscure companies you haven't heard about, depends on your field
15:07:01 <SLi> hmm, there used to be getInput in attoparsec to get (without consuming) remaining input, but no longer is :(
15:07:46 <SLi> How would I now write, given a custom function that takes a bytestring and splits it at some point, a parser to parse that portion?
15:08:02 <SLi> (I'm trying to write a takeRegexp for attoparsec using the regexp libraries.)
15:08:53 <hattmammerly> http://bpaste.net/show/164041/ if the pattern match in the first function fails an exception is thrown. How might I better accomplish what I'm trying to do there? The function is supposed to evaluate to a list of URLs found in the input string.
15:09:15 <erisco> is there some extension for constraint aliases?
15:09:17 <Eduard_Munteanu> SLi: parse what?
15:09:48 <Eduard_Munteanu> erisco: aliases? You can write   type Foo m = (MonadState Bar m, Monad m, ...)
15:09:55 <deech> Hi all, is there a way in the Haskell FFI for checking that a pointer has been freed? I don't think I can set it to NULL on the Haskell side.
15:10:15 <Eduard_Munteanu> erisco: with ConstraintKinds, that is
15:10:24 <jfischoff> deech: yo
15:10:25 <ParahSailin> what is curlGetString
15:10:33 <deech> jfischoff: Sup, man!
15:10:51 <erisco> Eduard_Munteanu, that allows you to write   blah :: (Foo m) => a -> m a   type of thing?
15:10:52 <deech> jfischoff: Have you rooted out PHP yet?
15:10:54 <jfischoff> So is the pointer getting freed in c land?
15:10:55 <FreeFull> Anyone here used IHaskell?
15:10:57 <hattmammerly> ParahSailin: return html of page as a string
15:11:04 <deech> jfischoff: Yup.
15:11:06 <ParahSailin> cmon yo, http-conduit
15:11:15 <jfischoff> deech: Oh they're smart enough to have me touch that stuff
15:11:18 <hattmammerly> ParahSailin: from Network.Curl, not home-rolloed
15:11:22 <jfischoff> err not have me
15:11:39 <hattmammerly> ParahSailin: oh, hadn't heard of that. I'll check it out
15:11:42 <SLi> Eduard_Munteanu: So, I'm trying to write a takeRegex :: Regex -> Parser ByteString, which could be used with something like takeRegex (makeRegex "some_regular_expression"). Mainly because what I want to eat is quite amenable to regexes and because the regex libraries perform significantly better here than attoparsec.
15:11:52 <merijn> deech: No, you can't check when pointers are freed, welcome to the lovely world of C :)
15:12:09 <jfischoff> right how would you know in C?
15:12:27 <merijn> jfischoff: By being very careful and making sure you don't use after you free
15:12:31 <SLi> Eduard_Munteanu: Mainly because attoparsec needs to backtrack while the regex libraries can prebuild a DFA to match the regex.
15:12:36 <jfischoff> merjin: right
15:12:36 <deech> merijn: But at least I can set the pointer to NULL after freeing and just do an `if (ptr) { blah } else { blah }'
15:12:41 <ParahSailin> hattmammerly: also, dont regex for html tags, thats just silly
15:12:52 <merijn> deech: That doesn't stop people who have copies of the pointer
15:12:56 <jfischoff> but all the other pointers are not set to NULL
15:13:06 <hattmammerly> ParahSailin: I'm not regexing for html tags, I'm parsecing for html tags, because I wasn't aware of a better way >.>
15:13:09 <erisco> Eduard_Munteanu, seems ideal thanks. will save me a lot of space and typing :)
15:13:11 <Eduard_Munteanu> SLi: it might be possible to get chars with anyChar and if it fails to match, just use fail
15:13:20 <ocharles> mm_freak_: ok, alternate pushed too... but I don't think you're going to like that one
15:13:25 <Eduard_Munteanu> erisco: they're called constraint synonyms, btw
15:13:31 <jfischoff> deech: can you give haskell ownership, ie. use a ForeignPtr?
15:13:32 <merijn> deech: Haskell just has a copy of the pointers value
15:13:38 <ParahSailin> hattmammerly: ok, html-conduit
15:13:44 <deech> merijn, jfischoff: The use-case is that I'm working on a GUI binding and testing the case where some widget is deleted in a callback.
15:13:48 <SLi> Eduard_Munteanu: I did think about that, too. Maybe. I just wonder why the lookahead was removed...
15:13:54 <SLi> Well, I'll try to do that :)
15:14:08 <Eduard_Munteanu> SLi: are you using Parsec or Attoparsec?
15:14:21 <SLi> Eduard_Munteanu: Attoparsec.
15:14:30 <SLi> Eduard_Munteanu: I used parsec first, but that was way too slow.
15:14:44 <hattmammerly> ParahSailin: alright, I'll look into using those instead. thank you
15:14:45 <deech> merijn, jfischoff: Currently if the callback is run twice I get a seg-fault for understandable reasons.
15:14:45 <Eduard_Munteanu> SLi: then attoparsec backtracks automatically, no need to "try"
15:15:03 <SLi> Eduard_Munteanu: right.
15:15:07 <mm_freak_> ocharles: if it's readable, follows the indentation rule and is correct FRP, i'll probably like it =)
15:15:21 <Eduard_Munteanu> SLi: there's peekChar too, IIRC
15:15:22 <mm_freak_> ocharles: the latter one is only required when it's visible through FRP.Netwire
15:15:38 <merijn> deech: Eh, good luck? xD
15:15:43 <Eduard_Munteanu> If you need to look ahead.
15:16:03 <deech> jfischoff: Yes, I could use a ForeignPtr. Although talking through it I'm inclined to let it crash and introduce a better static layer at a higher level.
15:16:18 <SLi> Eduard_Munteanu: There's also takeByteString, so I guess it's at least semantically equivalent to do {input <- takeByteString; ...; fail} to using getInput... I'm just wondering if there's a huge performance penalty or something behind removing the getInput which used to return the rest of input without consuming :)
15:16:20 <ocharles> mm_freak_: the implementation feels a bit of a weird way to write it, but I think it does the job
15:16:27 <SLi> Eduard_Munteanu: But I'll try with takeByteString and fail.
15:16:29 <deech> merijn: Thanks! I think the other GUI bindings have similar problems.
15:16:51 <jfischoff> deech: yeah it sounds like the ownership model might not work well with a ForeignPtr
15:17:13 <Eduard_Munteanu> SLi: takeBytestring sucks in that context... it will take it *all*, fail, backtrack, fail, backtrack, ...
15:17:14 <ocharles> mm_freak_: oh, pushed now. I keep forgetting 'darcs push' is interactive and tab away too fast
15:17:41 <jfischoff> I got kicked off, but it sounds like having the callback also call into haskell to alert your code the ptr is invalid might be the way to go
15:17:50 <Eduard_Munteanu> SLi: if you want to use regexes, I suggest looking into Alex too
15:18:27 <deech> jfischoff: That's a good idea. I might try that. What do you think of just letting it seg-fault, but introducing better static safety at a higher layer?
15:19:11 <deech> jfischoff: This is a pretty low-level layer that I hope to make compatible with some of the other Haskell compilers.
15:19:47 <jfischoff> Depends on the overhead of the static safety I guess. My gut so make it not crash
15:19:54 <jfischoff> s/so/says
15:20:09 <SLi> Eduard_Munteanu: Well, I'm not sure if there needs to be a penalty to consuming the rest of (strict bytestring) input, then backtracking... Maybe. :) Still, the input is only one line (hmm, maybe 200 chars), but there's millions of them.
15:20:10 <flebron> Is there a Haskell notion of a monotonic function between Ord types? (I'm thinking what restrictions I need to ask on a function f, such that my binary search tree acts as a Functor when fmapping f.)
15:20:12 <deech> jfischoff: Ok great. Thanks for your input.
15:20:33 <jfischoff> deech: thanks for working on a GUI library ;)
15:21:46 <hattmammerly> how might I best discover the right tools for a given job in haskell? clearly cursory google searching has not been accurate; should I just habitually browse Hackage?
15:22:15 <bennofs> hattmammerly: hackage has a search
15:22:23 <shachaf> flebron: What is a Haskell notion?
15:22:29 <Eduard_Munteanu> SLi: aren't you matching each char anyway? Why not just peekChar, check, anyChar and repeat?
15:22:39 <sm> hattmammerly: definitely worth doing a quick hackage search for likely keywords
15:22:43 <SLi> Eduard_Munteanu: Mut alex might be worth looking at. The language I'm parsing is not quite easily tokenizable, though... Just that part of the input is fairly amenable to regexes. Well, really regexes would be a semi-reasonable solution for parsing the entire line, if there just was a way to name groups (so I don't need to adjust indices every time I add () to the regex string)...
15:22:51 <flebron> shachaf: A way to express that restriction.
15:23:03 <shachaf> Ah.
15:23:06 <SLi> Eduard_Munteanu: Hmm, the regex library at least can match ByteStrings instead of a list of chars.
15:23:16 <erisco> hattmammerly, hoogle is also helpful
15:23:38 <greg`> can someone explain in laymans terms what an inductive graph is
15:23:41 <stian> Trying to get my head around the chart library. Can't find a tutorial anywhere, and the examples are quite complex. Can anyone give me a minimal example of plotting a simple function f :: Double -> Double over a range [1..100]?
15:23:46 <sm> hattmammerly: also be aware of ocharles's 2012 and 2013 package reviews
15:24:39 <hattmammerly> bennofs sm erisco: noted. thank you!
15:24:59 <jfischoff> greg`: you mean like fgl?
15:25:04 <Eduard_Munteanu> SLi: no, not a list of chars, I just meant checking each char in succession, and only once.
15:25:32 * hackagebot time-exts 1.1.2 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-1.1.2 (EnzoHaussecker)
15:25:56 <stian> In Python, plot([xs], [ys]) is a nice one-liner... I need the Haskell-equivalent, if I am going to be able to use IHaskell for some exploratory stuff.
15:25:59 <Eduard_Munteanu> stian: http://hackage.haskell.org/package/Chart-1.1/docs/Graphics-Rendering-Chart-Simple.html has two examples at the top
15:26:11 <greg`> yes like fgl
15:26:42 <stian> Eduard_Munteanu: That looks like exactly what I need.
15:26:43 <greg`> i am feeling its like a graph where the shape is defined by the type
15:26:45 <greg`> is that right?
15:27:00 <jfischoff> greg`: I think it is even simplier than that
15:27:20 <ParahSailin> hm Chart looks like I could dump matplotlib
15:27:58 <jfischoff> greg`: I think professor Erwing just meant that it is graph type that can built up starting with an empty base case and gluing on more "contexts"
15:28:11 <Eduard_Munteanu> SLi: there's also   scan :: s -> (s -> Char -> Maybe s) -> Parser Text
15:28:14 <jle`> my new favorite thing about monad transformers is just wrapping and unwrapping them on the fly like it's nothing
15:28:35 <jfischoff> s/Erwing/Erwig
15:28:36 <jle`> just like one small part of a larger function or do block
15:28:57 <greg`> ah thats quite nice, i suppose its kinda slow
15:28:57 <flebron> Sometimes, documentation will say a function is "subject to loop fusion". How can I make sure a given function I write is so?
15:29:05 <greg`> i need a graph that i can map quickly
15:29:18 <shachaf> flebron: By knowing about the relevant rewrite rules.
15:29:39 <mm_freak_> flebron: there is a GHC switch that tells you when and which RULEs fire
15:29:43 <jle`> flebron: by making the appropriate sacrifices to the GHC gods
15:29:59 <jle`> living sacrifices are more effective
15:30:01 <jonasw> flebron: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/rewrite-rules.html
15:30:19 <flebron> Thanks guys :)
15:30:40 <mm_freak_> btw, 7.0.1 is outdated ;)
15:30:57 <mm_freak_> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
15:31:08 <jonasw> Oops :)
15:31:19 <mm_freak_> be careful with search engine results =)
15:31:29 <joelteon> does cabal repl support the Paths_* modules
15:31:43 <SLi> Eduard_Munteanu: well, that would be equivalent to building the thing that the regex matches with attoparsec combinators, right? There's still the problem that it may need to backtrack multiple times while the regex need not since the matching automaton has been determinized (IOW there are such matching strings that not all their prefices are matching).
15:32:03 <joelteon> It doesn't look like it does
15:32:15 <SLi> Eduard_Munteanu: Hmm, except I'm not really sure I'm not backtracking in the regexes either, since the fastest I found are perl regexes )
15:32:16 <SLi> :)
15:32:50 <nicoo> SLi: Perl “regex” implementation is backtracking and not really fast
15:32:59 * nicoo notices he is on #haskell
15:33:00 <Eduard_Munteanu> SLi: ah, no, I was suggesting you can feed your regex lib using scan.
15:33:05 * nicoo is full of fail.
15:33:18 <SLi> nicoo: for some reason it's still way faster than the other regex libraries I tried on haskell (the ones that did build).
15:33:58 <SLi> Eduard_Munteanu: hmm... Maybe. But then it also needs to consume all of input, since it cannot tell what is the longest matching rexeg without consuming all of it :)
15:34:25 <Eduard_Munteanu> SLi: yeah, I was hoping you had well-behaved regexes
15:34:28 <SLi> :)
15:34:30 <erisco> for ambiguous class instances I wish GHC would just pick one for you
15:34:52 <merijn> erisco: You can specify defaulting rules
15:34:59 <erisco> oh?
15:35:30 <merijn> Probably not a good idea, though
15:35:42 <bennofs> or use evil IncoherentInstances
15:35:51 <bennofs> (iirc)
15:35:56 <nicoo> SLi: Including haskell-re2? Even when using lots of | operators (and re-using the same regex on multiple sequences) ?
15:36:43 <SLi> Eduard_Munteanu: The problem is not entirely well-behaved :P I need to match (but not parse besides that) C++ function names, followed by either a space or a semicolon. They can include beasts like "std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::_Grow".
15:36:44 <erisco> it is the case where I have an input foldable of t1 and output foldable of t2
15:36:51 <erisco> then when composing, the type of t2 becomes ambiguous
15:36:58 <erisco> I don't care what foldable it picks (a list is fine)
15:37:35 <erisco> one solution is to make the type less generic but I don't like the idea of simply gimping the function
15:37:49 <Eduard_Munteanu> SLi: not sure why you need a regexp for that though
15:37:57 <SLi> nicoo: Hm, I'm not sure I ever ran into haskell-re2. I think I tried the 9 candidates from http://www.haskell.org/haskellwiki/Regular_expressions .
15:38:28 <SLi> Eduard_Munteanu: Well, it's not strictly necessary, and I do have attoparsec code doing the same, but it's just not as fast.
15:39:03 <erider> can someone explain to me in simple terms what a combinator is
15:39:19 <Eduard_Munteanu> SLi: are your attoparsec parsers backtracking too?
15:39:20 <erisco> erider, specific to some library?
15:39:21 <flebron> A higher order function :p
15:39:26 <nicoo> SLi: IIRC, that's the name of the RE2 binding for haskell
15:39:28 <shachaf> In the context of Haskell, "combinator" means "function" or "value" or "thing".
15:39:30 <sclv_> its a function that does nothing except apply its arguments to some another in some combination
15:39:31 <SLi> Eduard_Munteanu: I think the problem comes from having to backtrack, since for example a space *can* terminate the match, but not necessarily does (as in "unsigned short" or "> >").
15:39:41 <sclv_> although we tend to use the term more generally
15:39:42 <shachaf> People use the term indiscriminately.
15:39:57 <shachaf> There's a technical meaning but no one who uses the word here pays any attention to it.
15:40:14 <sclv_> to also mean something that applies arguments to one another but also uses a few other functions
15:40:17 <wting> Is there a ghci command to explain what a function does? The closest thing I know of is :t for displaying type signature.
15:40:20 <sclv_> typically typeclass functions
15:40:22 <erisco> for example, (+) is an Int combinator :P
15:40:29 <sclv_> haha yes.
15:40:45 <sclv_> it tends to get used to mean something with respect to a data type
15:40:54 <sclv_> as in one of the arguments is some type of data, and the result is also that type
15:41:00 <SLi> Eduard_Munteanu: Yes, they are. The fastest I've been easily able to come up with is pNamedAddr = return BS.concat <*> many1' (try (string "unsigned ") <|> try (string " >") <|> takeWhile1 (notInClass " ;u")). (And yes, the trys are not needed and are a legacy from using Parsec.)
15:41:02 <Eduard_Munteanu> SLi: you should be tokenizing the space away when enclosed in some inner structure
15:41:03 <merijn> shachaf: I'm curious, what is the technical meaning?
15:41:06 <sclv_> one (or more) of the arguments
15:41:17 <Eduard_Munteanu> SLi: ew.
15:41:26 <erisco> erider, I think typically a combinator is going to be of the form  a -> a -> a   or  f a -> f b -> f c
15:41:38 <Eduard_Munteanu> SLi: as long as you're inside a < > you should never stop, right?
15:41:57 <Fuuzetsu> eikke: Not an answer to your RPC question, but have you heard of session types? I think it might interest you.
15:42:10 <SLi> Eduard_Munteanu: Hmm, I guess that's true too. Maybe. Not sure if there can be an ::operator < :P
15:42:12 <erider> so a function that acts on arguments is a combinator
15:42:14 <Eduard_Munteanu> SLi: also, don't use "notInClass"
15:42:29 <SLi> Eduard_Munteanu: Figured out that's not fast, but then I'm not sure what to replace it with.
15:42:42 <erider> I thought it was a function that have no free variables
15:43:07 <Eduard_Munteanu> SLi: for that purpose an explicit \c -> c /= ' ' && c /= 'u' && c /= ';' should do
15:43:08 <Fylwind> Feel like I'm missing something obvious here ... "Not in scope: type construct or class 'Constraint'"
15:43:38 <erisco> erider, the vague idea is that a combinator should take many things and reduce it to one thing such that the one represents the many
15:43:38 <hpc> Fylwind: you need to import a ghc module, but i forget which
15:43:52 <Eduard_Munteanu> Fylwind: import GHC.Prim
15:44:06 <shachaf> GHC.Exts
15:44:07 <erisco> erider, so for (+), it takes two numbers and combines it into one number, where the one is the sum of the two
15:44:15 <Eduard_Munteanu> Oh, it's been moved there?
15:44:18 <Eduard_Munteanu> Hm.
15:44:20 <hpc> Fylwind: obviously, you didn't miss something obvious ;)
15:44:21 <shachaf> No, it's exported from there.
15:44:27 <SLi> Eduard_Munteanu: I do wish that the lines were easily parseable. Actually what this portion of code tries to do is just split the line into a few parts: A beginning (identical in every line); an address (which can be hex or a C++ name); a separator (which can be either ; or a number of spaces), and the rest of the line. I'm only interested in the address/C++ name and the rest of the line. I wish I had control over the format the log file is in; it's not really
15:44:27 <SLi>  very machine-parseable :P
15:44:28 <shachaf> GHC.Exts is where you should get GHC extensions.
15:44:33 <Eduard_Munteanu> Ah.
15:44:58 <SLi> Eduard_Munteanu: hmm, that should be faster? I'll try :)
15:45:41 <erisco> erider, another example is compose (.), which takes two functions and makes one function. ie (.) f g x = f (g x)
15:45:51 <Eduard_Munteanu> SLi: yes, there's no list and no pattern-matching, it can compile to straightforward comparisons
15:45:54 <erider> erisco: so any function that has a value is a combinator? or returns a value
15:46:05 <Fylwind> ah I see, thanks; GHC.Exts and GHC.Prim both worked but I didn't have to add a dependency for Exts
15:46:09 <erisco> erider, all functions return a value
15:46:33 <erider> are they combinators?
15:46:57 <shachaf> My recommendation is this: Don't use the word "combinator".
15:47:10 <shachaf> Unless you're, say, implementing a compiler or something.
15:47:10 <erisco> erider, combinator is vague :) I am just giving my interpretation which is also vague
15:47:45 <erisco> and my interpretation is functions of roughly of the form a -> a -> a or f a -> f b -> f c
15:47:56 <erider> erisco: is it related to reduction
15:48:30 <erisco> well what is "reduction"?
15:48:57 <erisco> I described a combinator as reducing many things into one thing, yes
15:49:36 <erider> ok
15:49:36 <erisco> but not in the sense that filter reduces many things into one thing, which was my second part: the one must represent the many
15:50:22 <erisco> an ideal example is parser combinators
15:50:43 <Eduard_Munteanu> Considering the common usage, I'd say "combinator" usually applies to EDSL-ish functions... e.g. parser combinators
15:51:13 <SLi> Eduard_Munteanu: I'm also not sure the BS.concat is good there. What's the proper way to match multiple repetitions of either "foo" or "bar" and return just a single string? Is it concat $ many1' (string "foo" <|> string "bar")?
15:51:18 <Eduard_Munteanu> Or lens combinators that mimick assignment and operations in other languages.
15:51:37 <erisco> given parser A which recognizes the string "hello" and parser B which recognizes the string " world", then given the parser combinator 'followedBy', followedBy A B recognizes the string "hello world"
15:52:01 <erisco> so you can say parser C = followedBy A B and that C is the combination of A and B
15:52:28 <SLi> erisco: Interesting :) Thanks.
15:53:11 <Eduard_Munteanu> SLi: the list might not fuse away, yeah... not sure there's a nice fix
15:53:45 <sevak> hi guys, am I on the right track here? http://lpaste.net/643316406506487808
15:53:48 <Eduard_Munteanu> SLi: you might be able to code it as a 'scan' for short words
15:54:12 <SLi> nicoo: Hmm, the haskell-re2 is not in hackage? That's probably why I didn't run to it :)
15:54:13 <Eduard_Munteanu> (with common prefixes)
15:54:39 <erisco> sevak, are you? is there a problem?
15:54:56 <bennofs> Is there a way to only preprocess cabal targets but not build them?
15:54:59 <jfischoff> SLi: its on github, and I found it easy to build
15:55:02 <sevak> yes I get an error, it says..
15:55:31 <Eduard_Munteanu> SLi: oh... maybe you could only count repetitions?
15:55:51 <erisco> sevak, revNs is a list, so in (x:y) <- revNs, x is the head of the list (an element) and y is the rest of the list (a list itself)
15:56:02 <skypers> it will always impress me how laziness is useful
15:56:04 <erisco> sevak, therefore 2*y does not make sense because y is a list
15:56:07 <SLi> Eduard_Munteanu: Well, I could live with the number of characters consumed now that I think.
15:56:10 <erider> erisco: so I combinator doesn't have a value itself. it take somethings and combines them to make a result
15:56:14 <skypers> > groupBy undefined [1]
15:56:15 <lambdabot>  [[1]]
15:56:17 <erisco> skypers, indeed!
15:56:36 <skypers> erisco: it’s really convenient for a lot of things
15:57:00 <sevak> hmm ya that makes sense, I also tried x:y:zs
15:57:07 <erisco> erider, I am not quite sure what you mean by "combinator does not have a value itself", but yes, a combinator takes things and combines them (but that is a cyclic definition)
15:57:20 <sevak> but that would grabe the first two and all the rest would be in zs
15:57:20 <bennofs> I meant, let cabal only generate autogen/... files?
15:57:53 <SLi> jfischoff: nicoo: But I did try posix regexps, which were not as slow as advertized on the wiki page, but nevertheless slower than pcre.
15:58:13 <sevak> should I be trying to pattern match to solve this? Also, is it correct that I reverse the list?
15:58:34 <Eduard_Munteanu> SLi: maybe you should tokenize that thing properly, so that you e.g. skip parsing things between parens altogether...
15:58:39 <nicoo> SLi: Not very surprising. The regex implementation in glibc isn't balzingly fast.
15:59:00 <erisco> sevak, your first two cases are good, but the third is a bit off
15:59:24 <erisco> sevak, that is [] = [] is right, (x:[]) = [x] is right, but reconsider what your final case should be
16:00:08 <erider> erisco like map it take a list and a function and applies the function to each element in the list and then produces a list
16:00:25 <sevak> ya I'm following that resource and the first two cases were in an example, I'm hesitant if I'm even approaching the third case correctly
16:00:27 <erisco> :t map
16:00:28 <lambdabot> (a -> b) -> [a] -> [b]
16:00:47 <erisco> erider, see it does not follow the form a -> a -> a or for some a, b, c the form f a -> f b -> f c
16:00:56 <greg`> can i just say that today i got that haskell experience of everything just working
16:01:01 <greg`> once it compiledf
16:01:07 <erisco> erider, map takes a function, a list, and returns a list
16:01:22 <erisco> erider, so the items are of different types. personally I do not consider this a combinator
16:01:31 <erisco> erider, I think a combinator should only be working with same types
16:01:38 <erisco> but that is just my interpretation
16:01:42 <erider> map is not combinator
16:01:49 <Eduard_Munteanu> sevak: consider  doubleEveryOther (x:y:rs) = ... doubleEveryOther rs
16:02:02 <greg`> it was a little odd to be fair , im very happy im starting to like haskell more and more
16:02:02 <greg`> think im just going to go with data graph by the way
16:02:02 <greg`> i think its a monoid
16:02:24 <erisco> sevak, well you have an empty list and a list with one element solved. what would you do with a list containing two elements?
16:02:31 <Eduard_Munteanu> sevak: can you fill in the "..."?
16:02:46 <SLi> nicoo: Hmm, if haskell-re2 supports the named groups that the underlying library supports, I think I could drop (atto)parsec entirely. In fact that's how I'd do it in python; it's just that counting the group indices by hand is so painful that I haven't been able to do that in Haskell...
16:02:58 <SLi> Because I already have a regexp which seems to split what I need :)
16:03:11 <SLi> It's not just maintainable without named groups.
16:03:12 <jle`> greg: congrats :D
16:03:25 <erisco> erider, I think (++) is a combinator, though
16:03:28 <erisco> :t (++)
16:03:28 <lambdabot> [a] -> [a] -> [a]
16:04:07 <L8D> @src (++)
16:04:08 <lambdabot> []     ++ ys = ys
16:04:08 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:04:08 <lambdabot> -- OR
16:04:08 <lambdabot> xs ++ ys = foldr (:) ys xs
16:04:30 <greg`> @jle thanks
16:04:30 <lambdabot> Maybe you meant: pl let
16:04:50 <sevak> Eduard_Munteanu: hmm I think so :] that actually helps frame things, erisco: double the first element
16:05:00 <greg`> oh and can i say that if you are not using emacs with flycheck-hdevtools you are missing out on a party
16:05:19 <L8D> What's the difference between a monoid and a monad?
16:05:21 <erisco> sevak, [1,2,3] -> [2,2,6] or [1,2,3] -> [1,4,3] ?
16:05:31 <L8D> I haven't seen very many monoids in the wild
16:05:38 <geekosaur> yes you have
16:05:41 <greg`> monoid = map able
16:05:52 <L8D> but isn't a functor mapable?
16:06:00 <L8D> hence the `fmap` function.
16:06:01 <jfischoff> yeah
16:06:01 <geekosaur> monoid: 0 and addition, 1 and multiplication, [] and (++)
16:06:05 <erisco> L8D Monoid is mempty and mappend, whereas Monad is return and >>= (also the laws are different)
16:06:07 <greg`> monad = composable
16:06:18 <sevak> [1,2,3]->[1,4,3]
16:06:22 <greg`> oh sorry i think i may have it wrong
16:06:33 <erisco> sevak, then given a list of two elements, would you double the first or double the second element?
16:06:58 <jle`> L8D moods are things where you have an associative binary operation, and an identity to that operation. things that can be "added" or "joined together" meaningfully
16:07:11 <geekosaur> s/moods/monoids/
16:07:19 <sevak> the first element
16:07:22 <L8D> joined together as in...concatenated?
16:07:40 <sevak> because it says from the right
16:07:47 <jle`> for example the canonical Haskell monoid is the list. your <> is concatenation and your identity is []
16:07:59 <jle`> anything concatenated to [] is itself
16:08:03 <erisco> L8D, not necessarily concatenated
16:08:19 <geekosaur> addition is another kind of monoid, with identity 0. multiplication is another kind of monoid, with identity 1
16:08:33 <shachaf> [] and (++) is a very special monoid.
16:08:49 <erisco> and unit is a monoid :)
16:08:51 <joelteon> hey, somebody update the fingertree/reducers dependencies on trifecta
16:08:56 <joelteon> please :D
16:09:23 <greg`> is it fair to say monoid is foldable?
16:09:28 <Eduard_Munteanu> > zipWith (*) [1,4,5] (cycle [1,2])
16:09:29 <jle`> a binary function is any function a - > a - > a, and for monoids it must be associative.
16:09:29 <lambdabot>  [1,8,5]
16:09:30 <L8D> So...What is the difference between mconcat and concat?
16:09:31 <greg`> and monad composable
16:09:34 <geekosaur> then there's the monoid formed by identity id and associative operator (.)
16:09:41 <Eduard_Munteanu> greg`: not really
16:09:44 <erisco> sevak, I do not understand... if the input is [1,2,3] and the output should be [1,4,3], are you not doubling the second element?
16:09:44 <geekosaur> concat is specific to lists
16:09:54 <jle`> L8D: it's like map and fmap
16:09:56 <silasm> L8D: concat only operates on lists, mconcat = concat where the monoid is a list
16:10:09 <L8D> got it
16:10:19 <jle`> concat is redundant, but it gives a lot less scary of error messages
16:10:29 <silasm> iirc that's mainly to avoid confusing newbies with the mconcat type signature
16:10:33 <L8D> > concat []
16:10:34 <lambdabot>  []
16:10:40 <jfischoff> greg`: the problem with trying to summarize these algebraic classes with one word, is that you lose parts of them that are key for the definition.
16:10:40 <L8D> o.o
16:10:43 <jle`> imagine starting Haskell and seeing an error about Monoids instead of an error about Lists
16:10:47 <greg`> concat is just a special case of mconcat for lists no??
16:10:59 <shachaf> Yes.
16:11:08 <jle`> greg` yes, like map and fmap
16:11:22 <Eduard_Munteanu> :t mconcat
16:11:23 <lambdabot> Monoid a => [a] -> a
16:11:27 <Eduard_Munteanu> :t join
16:11:28 <lambdabot> Monad m => m (m a) -> m a
16:11:45 <sevak> yes, but given a list of two elements [1,4], you would double the first element (1) because it's the second element from the right, or is my logic off?
16:11:50 <jle`> another neat Monoid is First
16:12:07 <jle`> which is a monoid instance of Maybe
16:12:11 <Eduard_Munteanu> concat is more like join really, if you're referring to the list monad.
16:12:15 <silasm> what I don't understand is the difference between Monoid and Foldable.
16:12:24 <greg`> yes jfischoff but you need a inkling to start off with without getting splatted with category theory
16:12:29 <erisco> sevak, in the list [1,2], '1' is the first element and '2' is the second element
16:12:32 <jle`> where any Maybe <>'d to another Maybe is the first Just
16:12:41 <jle`> the identity is Nothing
16:12:48 <Eduard_Munteanu> silasm: Foldable requires a value in a context, like Functor
16:12:57 <jfischoff> greg`: I agree.
16:13:08 <jle`> so if you mconcat a list of Firsts, you get the first Just
16:13:08 <erisco> sevak, so if you are given the list [1,2] and you want the list [1,4], you need to double the second element
16:13:22 <mastensg> Does anyone know how to parse dates like these with Aeson? "/Date(1388664014000+0100)/"
16:13:28 <silasm> Eduard_Munteanu: so it's not applicable to things like Sum and Product? Simple enough.
16:13:35 <Eduard_Munteanu> silasm: e.g. () isn't a Foldable, or a Functor for that matter, even if it can be a Monoid.
16:14:03 <greg`> wow the haskell channel is so abstract, we are talking about everything and nothing
16:14:15 <Eduard_Munteanu> silasm: note: Monoid [a], Foldable []
16:14:35 <silasm> Eduard_Munteanu: ah, that sums it up nicely, thanks :)
16:14:42 <erisco> sevak, are you aware that   [1,2] == 1:2:[]   ?
16:14:45 <sevak> but we're starting from the right according to the problem, so it would be [1,2] not [1,4]
16:14:51 <sevak> yes
16:15:13 <erisco> sevak, well how is your problem stated? I did not know you had to start from the right
16:15:47 <Eduard_Munteanu> sevak: you can compute the length to decide then
16:15:55 <greg`> can i just ask what ide everyone is using, as i am feeling a little smug about my hdevtools emacs setup
16:16:12 <sevak> it says from the right, http://lpaste.net/643316406506487808
16:16:40 <Eduard_Munteanu> greg`: Emacs, evil and haskell-mode
16:16:51 <hiptobecubic> a better question is who is using fp complete's offering?
16:16:56 <jle`> vim
16:17:01 <ParahSailin> mastensg: youre gonna have to use either the applicative or the monad instance of aeson's Parser
16:17:12 <hiptobecubic> Eduard_Munteanu, how is that working out? I keep think it will be worth it to switch, and then deciding that it isn't.
16:17:17 <sevak> Eduard_Munteanu: does that throw recursion out the window? It seems the list would be reversed each time.
16:17:40 <erisco> sevak, okay, the list [1,2,3] should become [2,2,6] then, not [1,4,3]
16:17:48 <Eduard_Munteanu> sevak: no, you only need to compute the length once
16:17:51 <sevak> unless there is a way to pattern match from the end of a list
16:18:22 <jle`> idk if L8D is still listening but Alternative is a very useful monoid
16:18:23 <sevak> erisco: no it should be [1,4,3]
16:18:23 <erisco> sevak, oh, I understand, sorry
16:18:53 <erisco> sevak, yes then you can first reverse the list, do your normal *2 stuff, then reverse again
16:19:11 <L8D> > mconcat [First Nothing, First $ Just 1, First $ Just 0]
16:19:12 <lambdabot>  First {getFirst = Just 1}
16:19:18 <L8D> Why?!
16:19:44 <silasm> L8D: what are you expecting to happen?
16:19:48 <Eduard_Munteanu> sevak: actually you can just compute both outcomes and decide at the end which you keep
16:19:57 <jle`> L8D the binary operation is the "first" Just
16:20:08 <L8D> Why is it First {getFirst = Just 1} as opposed to First (Just 1)
16:20:18 <jle`> they are the same
16:20:33 <jle`> the getFirst is the record syntax label
16:20:35 <sevak> Eduard_Munteanu: sorry which outcomes do you mean?
16:20:35 <L8D> Then why does it have getFirst in the first place?
16:20:35 <silasm> L8D newtype wrappers: there are multiple ways to make Maybe a monoid
16:20:40 <shachaf> Those are the same thing.
16:20:56 <jle`> are you familiar with record syntax?
16:21:03 <L8D> I am
16:21:08 <L8D> But why is it using it?
16:21:10 <erisco> sevak, you are either doubling every element starting at the first, or doubling every element starting at the second (going left to right)
16:21:18 <Eduard_Munteanu> sevak: instead of saying you start from the end of the list, you can say you double the even or odd elements depending on how long the list is.
16:21:20 <greg`> thanks for your answers
16:21:25 <jle`> if the record has been label, then it prints it by default
16:21:27 <silasm> so you wrap it in a newtype (which is treated the same other than typeclass instances) so that they don't conflict
16:21:31 <erisco> sevak, but you cannot determine which until you know if the list length is even or odd
16:21:35 <Fuuzetsu> See, here's something I never got. Why is it ‘Control.Applicative’ and ‘Control.Monad’ but ‘Data.Functor’? I basically fall into the ‘Was it Control or Data?’ routine every day.
16:21:38 <silasm> same thing is done with Sum and Product for numbers.
16:21:44 <greg`> can whats so good about Alternative Monoid
16:22:02 <merijn> Fuuzetsu: Silly historical reasons
16:22:15 <greg`> I think there is a historical schism, basically a ballsup
16:22:16 <merijn> Fuuzetsu: Most people agree the Control/Data distinction is pretty arbitrary and silly
16:22:32 <merijn> Fuuzetsu: But changing it now breaks everything for basically not reason :p
16:22:32 <erisco> sevak, so you can compuate both scenarios concurrently and then, once you see the end of the list, you can then determine which version to return
16:22:44 <erisco> sevak, or you can compute the length of the list and decide if it is even or odd ahead of time
16:22:45 <jle`> greg Alternative is First but generalize to all "failable" Monads
16:22:54 <Fuuzetsu> Mhm. I'm giving it a think and it might make sense if you squint. With Applicative and Monad, you can ‘control’ the program flow (*>, >>=), while with fmap you act upon the ‘data’ structures
16:23:05 <sevak> ah I see nice
16:23:08 <jle`> not sure right now if it is a Haskell capital M Monoid though
16:23:11 <greg`> ok im going to look up first first ;-)
16:23:14 <sevak> thank you guys
16:23:15 <erisco> sevak, or you can reverse the list and double every other starting at the second element, then reverse again
16:23:54 <sevak> cool
16:24:01 <erisco> personally I would reverse
16:24:01 <silasm> jle`: is there any significant difference between the Monad laws and the monad axioms?
16:24:14 <greg`> Fuuzetsu that does kinda make sense
16:24:18 <jle`> Monad axioms...?
16:24:23 <erisco> actually I might do the concurrent version to make use of the new module I'm working on :)
16:24:27 <Eduard_Munteanu> silasm: fail isn't a monad axiom
16:24:35 <greg`> i think these are the same things
16:24:48 <jle`> oh I see
16:24:57 <shachaf> Fuuzetsu: I recommend not squinting to try to make sense of something that doesn't make sense.
16:25:08 <Fuuzetsu> shachaf: Gotta squint harder.
16:25:32 <sevak> erisco: why just out of curiosity? cause I was thinking the first option (calculating the length ahead of time)
16:25:36 <greg`> first acceptance , then understanding
16:25:43 <Eduard_Munteanu> We should make some Haskell autostereograms.
16:25:56 <erisco> sevak, because it is simpler and more composable
16:25:56 <Eduard_Munteanu> Good way to strain your eyes while learning something. :P
16:25:59 <Fuuzetsu> what would those look like
16:26:30 <sevak> ok cool, I think I might try them all to practice
16:26:34 <erisco> sevak, good idea :)
16:26:46 <mreh> what happened to integral in netwire 5?
16:27:10 <Eduard_Munteanu> Fuuzetsu: they'd look like   Lens s Lens s t t a b a b :P
16:27:30 <adimit> Question: is it possible to construct a mutually recursive data structure using 2 circular ADTs without indirection, but (critically) *with typed* error handling? It is kind of a very convoluted knot tying. Here's what I mean: http://lpaste.net/97903
16:27:50 <adimit> (I'm using the evil fromJust here to escape the possibility of M.lookup failing. I would ultimately like to not do that.)
16:28:21 <Fuuzetsu> Eduard_Munteanu: ;_;… When is ‘Foo s t a b k i l l d e s t r o y’ making it into lens?
16:28:56 <greg`> general question: is haskell programming easier?
16:29:12 <erisco> by which metric?
16:29:14 <Eduard_Munteanu> Fuuzetsu: there's even worse... class (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), ArrowLoop p, ArrowApply p, ArrowChoice p) => Conjoined p
16:29:20 <Fuuzetsu> greg`: general questions: easier than what? how do we measure ‘easy’?
16:29:30 <jfischoff> its not easier to google for code to copy and paste
16:29:37 <sevak> :] thanks again guys I'm off to try it
16:29:39 <mreh> @faq will haskell make my life easier?
16:29:39 <lambdabot> The answer is: Yes! Haskell can do that.
16:29:40 <greg`> Lens is like . in java
16:29:47 <erisco> brian fuck has way easier syntax and semantics than Haskell
16:29:49 <L8D> greg`: It also heavily depends on what your programming in haskell
16:29:53 <greg`> lol - i was just trolling there
16:30:07 <Fuuzetsu> Poor ‘trolling’
16:30:12 <mreh> ;_;
16:30:12 <bennofs> Is there a way to get thread-safe stdout?
16:30:17 <Fuuzetsu> You didn't even claim that PHP was better
16:30:22 <bennofs> (So that lines don't get cluttered?)
16:30:24 * Fuuzetsu scurries away
16:30:33 <bennofs> Hmm, maybe I just have to use line buffering ...
16:30:41 <mreh> bennofs: write to a chan
16:30:46 <dwcook> bennofs, well, you could have a single thread handle all output, maybe
16:31:59 <jfischoff> bennofs: what dwcook said, use a thread safe queue, like TQueue to communicate with the printing thread
16:32:33 <erisco> sevak, lol I see you have the twoers of hanoi puzzle
16:32:39 <erisco> I never understood it
16:32:48 <greg`> i find i need to think a lot more when i program haskell than when i program python
16:32:58 <greg`> i dont know if thats a good thing
16:33:06 <bennofs> greg`: for me it's now the other way around
16:33:19 <bennofs> I start thinking: How do I transform Either into C++ ... ugh
16:33:32 <jle`> greg` you'll get used to it. how long have you been programming imperative?
16:33:41 <erisco> bennofs, lol now I have the same sickness
16:33:47 <jle`> imperatively
16:33:49 <jfischoff> I code faster in Haskell, because the type system catches mistakes for me
16:33:52 <erisco> and friends question my code
16:33:52 <greg`> not long , ive spent a lot of time reading
16:34:04 <jle`> I mean, before Haskell
16:34:11 <greg`> maybe about a year but not full time, like side projects mainly
16:34:38 <greg`> im just starting to cut my teeth once i found some libraries and ideas worth implementing in haskell
16:34:41 <mreh> what's wrong with a Chan?
16:34:42 <bennofs> C++'s type system also catches some mistakes, but I code faster in haskell because the error messages are way better and shorter and show only important things (really, in C++ I spend a lot of time scrolling through error messages ....)
16:34:53 <greg`> for example i really like the approach to concurrency
16:35:16 <erisco> merijn, so is there some way to configure defaulting?
16:35:17 <jmcarthur> bennofs: i also find that haskell's type system makes it much easier to encode my invariants, compared to C++'s
16:35:22 <greg`> oh before haskell sorry, for years
16:35:35 <greg`> ive been programming since i was about 10 years old
16:35:51 <jmcarthur> it might not really be type system related so much as just the way ADTs work, and C++ might be able to close the gap by just adding ADTs
16:36:02 <greg`> im 38
16:36:12 <bennofs> Hmm, using line buffering also fixed my problem. Stdout is only used for debug logging, so it doesn't have to be very nice ...
16:36:15 <jmcarthur> i know rust works out pretty well, simply because it had ADTs
16:36:19 <L8D> @src join
16:36:20 <lambdabot> join x =  x >>= id
16:36:23 <jmcarthur> *has
16:36:30 <jle`> yes, now compare how much you thought about programming when you were 11/12
16:36:39 * bennofs is 15, bzw
16:36:44 <jmcarthur> but i was turned off to rust by something silly... monomorphization means i can't use polymorphic recursion :(
16:36:49 <L8D> jle`: That's easy
16:37:00 <jle`> compare your proficiency at programming at 12 Years old to your proficiency at Haskell now
16:37:03 <jmcarthur> bennofs: i wish i had been using haskell at 15... :\
16:37:22 <L8D> hahahaha
16:37:33 <greg`> ah they are probably about the same , i think im a better learner now though
16:37:38 <L8D> I'll shut up
16:37:43 <jmcarthur> i've been programming since i was 7, but i didn't get to haskell until i was much older
16:38:08 <greg`> yes i see what you are saying jle`
16:38:35 <marshjello> jmcarthur, thanks, now i have someone to study
16:38:40 <greg`> i tend to spend a lot of time figuring out types
16:38:49 <jmcarthur> marshjello: study?
16:39:02 <bennofs> Since 7 ? :O I think I didn't even use a computer at that time
16:39:10 <marshjello> Everything you say I will analyze on a very deep cogntive processing level
16:39:11 <greg`> according to linus thats what distinguishes good programmers from great ones
16:39:13 <erisco> jmcarthur, no you don't! at least 99% of uni students seem to hate it (at my  uni anyways)
16:39:22 <marshjello> at age 7, that's considered a programming prodigy
16:39:31 <jmcarthur> erisco: a lot of uni students are there for good jobs, not for fun and learning :(
16:39:34 <mreh> I used to code at 10 without for loops
16:39:39 <marshjello> GM chessplayers begin at 7.
16:39:43 <mreh> I used to cut and paste sections of code
16:39:50 <jle`> greg` so once you have been using Haskell for 28 years
16:39:55 <erisco> jmcarthur, is that a reason to go for a phd and try for tenure? that is my thinking right now anyways :P
16:40:08 <jmcarthur> marshjello: i am classified as gifted, but i don't know what the criteria for prodigy is. also, none of this means i'm a good programmer.
16:40:41 <sevak> ya should be fun :], why is that funny huh ;?
16:40:54 <jmcarthur> gifted children tend to make the worst grades, for example.
16:41:00 <erisco> sevak, just amusing how similar the questions are across universities is all
16:41:07 <greg`> yes i dont think it will take that long hopefully, but its fun, i enjoy the mind bend
16:41:08 <jmcarthur> s/the worst/not so great/
16:41:13 <sevak> erisco: hehe
16:41:13 <AshyIsMe> depends on who's calling the children "gifted" i guess
16:41:17 <AshyIsMe> if it's the mother...
16:41:39 <bennofs> I don't remember that I ever copy-pasted code xD Somehow I just forgot how I learned Haskell/C++/Java/whatever
16:41:39 <Komier> I'm mostly oilfield trash that plays with electronics and computers in his spare time.
16:41:43 <jmcarthur> i mean objectively according to some stupid, arbitrary test
16:41:48 <sevak> ya found that resource online, not sure how
16:42:19 <marshjello> jmcarthur, tested your IQ before?
16:42:25 <jmcarthur> ah, apparently giftedness only applied to children, so i can no longer be considered gifted
16:42:32 <L8D> I feel like I should mention something
16:42:34 <greg`> i dont think there is any true gifts other than physical ability and creativity , the rest is just science
16:42:43 <mreh> this is really off topic
16:42:48 <mreh> like that?
16:42:55 <L8D> no
16:43:00 <L8D> I'm 13
16:43:09 <mreh> okay
16:43:15 <greg`> i test my IQ daily , while looking in the mirror and flexing my pecs
16:43:17 <jmcarthur> marshjello: yeah, but i don't remember the result. it was over 150. also, i agree with mreh that this is really off topic; on top of that, i don't really want to continue this conversation anyway.
16:43:22 <erisco> greg`, lol
16:43:49 <AshyIsMe> woah you guys are young, awesome that you're learning haskell
16:44:03 <jmcarthur> learning haskell at 13! i'm jealous
16:44:08 * bennofs too
16:44:10 <greg`> yeah dont go into oo land , its full of evil
16:44:21 <erisco> yes good. you have to get them in when their still easy to indoctrinate
16:44:22 <mreh> unless you want to make money
16:44:24 <greg`> ive been there and im scarred
16:44:28 <mreh> or code PHP or something
16:44:32 <L8D> greg`: There's too much to explain
16:44:33 <greg`> lol true mreh
16:44:53 <L8D> there's far more than just that "I'm 12"
16:44:56 <L8D> 13*
16:44:59 <marshjello> understood.
16:44:59 <Komier> do you guys use reference docs / hoogle alot?  Or do you just memorise the gazillion standard library functions? lol
16:45:07 <twiceler> On a related note, is it hard to learn Haskell as a first programming language? I have a friend who wants to learn programming, and I feel like Haskell would be a great language to learn first. Does anyone start with functional programming?
16:45:08 <marshjello> Just making a note on the side here.. jm...prodigy.
16:45:14 <mreh> Komier: hoogle is your friend
16:45:27 <greg`> ? L8D?
16:45:32 <twiceler> Komier: I use the haddocks on Hackage constantly
16:45:47 <mreh> Komier: and you can install the docs with cabal-install
16:45:47 <jmcarthur> twiceler: it's not from experience, but i claim without proof that haskell would make a fine first language.
16:45:52 <L8D> I do freelance web development and node.js development too
16:45:53 <greg`> now whats that quote by Einstein about remembering stuff?
16:45:55 <mreh> for offline
16:46:10 <L8D> I even have a lame portfolio
16:46:17 <greg`> hmmm i think i need the haddocks emacs plugin
16:46:22 <Komier> mreh: yeh i have them installed but can't access the damn things for some reason, need to work that one out.
16:46:33 <L8D> but let's go back on topic
16:46:38 <mreh> please
16:46:49 <L8D> vili?
16:46:56 <bennofs> Komier: yeah, I also use hayoo and hoogle (when hayoo's down ... happens far too often) and haddock, although mostly for packages other than base (like lens/text/vector/ghc/...)
16:47:18 <twiceler> Haskell came pretty easily to me compared to other languages, but I already had experience with imperative programming before I got to Haskell
16:47:26 <Clint> i haven't seen hayoo work for at least a week
16:47:54 <mreh> has anyone got hoogle running locally yet?
16:48:01 <Komier> Only asked really because I'm on the "Modules" section of LYAH... and it's just basically page after page list or functions and what they do.  Clearly not going to remember them all after looking at one example and a piece of text.
16:48:29 <mgsloan> The hoogle here searches a lot more of hackage than the standard hoogle: https://www.fpcomplete.com/hoogle
16:48:30 <greg`> yeah theres this weird thing about learning haskell
16:48:38 <Clint> mreh: apt-get install hoogle
16:48:50 <mreh> Clint: no, way
16:48:54 <greg`> which is that you need to know all the concepts before you write your first program
16:49:15 <mreh> Clint: you're kidding
16:49:22 <Clint> no, why would i be kidding
16:49:23 <mreh> not in ubuntu repositories
16:49:25 <greg`> and actually you really dont need to understand much at all, i would definately start writing first
16:49:27 <Clint> mreh: http://packages.ubuntu.com/search?keywords=hoogle
16:49:38 <twiceler> Relevant? http://www.willamette.edu/~fruehr/haskell/evolution.html
16:49:40 <mreh> Clint: not in my distro :)
16:49:43 <AshyIsMe> greg`: the 24 days of hackage articles are really good for that
16:49:44 <mreh> apologies
16:49:47 <Komier> Clint : hah thanks, installing now
16:49:54 <AshyIsMe> basic little demos of what you can do with a library with usually fairly minimal understanding
16:49:56 <bennofs> cabal install hoogle doesn't work?
16:50:28 <mreh> UBUNTU_DISTRO >= trusty only
16:50:36 <mreh> release, not distro
16:50:38 <greg`> thanks AshyIsMe ill add it to my reading list
16:51:09 <Komier> bennofs: i installed fine from cabal, but couldn't get it to work properly.
16:51:11 * mgsloan 's been programming since 8 and started haskelling at 16.  Nice round numbers :D
16:51:24 <dalaing> I have a very hand wavy question
16:51:30 <dalaing> suppose you have two free monads in a monad transformer stack, derived from functors f and g
16:51:30 <Komier> just did that apt-get clint linked and can now run from command line easily.... hoogle --query
16:51:42 <mreh> jelly
16:52:06 <mreh> could someone backport it for me?
16:52:14 <greg`> wow im loving 24 days thanks
16:52:54 <dalaing> I'm probably mangling some of the terms, but am wondering if there's some testing goodness to be had with the algebra of the free monad derived from f and the colagebra of the cofree comonad dervied from g
16:54:00 <greg`> just want to really get my head around quickcheck next
16:54:16 <greg`> i am again scarred by unit testing it seems strange
16:54:26 <dalaing> someone mentioned something vaguely related to this, and I've been wondering how to squeeze something quickcheck related out of it - either to help show that the layers interact correctly, or to help show that code using both layers is correct
16:54:47 <erisco> erm
16:54:55 <erisco> is there some way to make the constraints less dumb
16:55:04 <bennofs> erisco: which constraints
16:55:07 <erisco> ie  Monoid (t a)  should imply  Monoid (t b)
16:55:11 <greg`> erm
16:55:28 <bennofs> erisco: maybe you could use the class `Alternative` ?
16:55:37 <dalaing> greg`: real world haskell has a good chapter on quickcheck, and the quick check / monadic quick check papers are great for after that
16:55:38 <greg`> ?
16:55:47 <bennofs> erisco: Alternative t and then use (<|>) for mappend and empty for mempty
16:55:49 <erisco> bennofs, I dunno it is coming from foldMap (the Monoid requirement)
16:56:16 <dalaing> greg`: also, "the fun of programming" has a chapter that is like a combination of those papers, but it is a little gentler and has exercises
16:56:20 <bennofs> Hmm. No, I think there is no way to make them less dumb then
16:56:36 <greg`> yea i read that chapter dalaing, and i know how to use it, but it hasnt clicked, i dont see the power in wielding it yet
16:56:40 <bennofs> @ty \f -> msum . map f
16:56:41 <lambdabot> MonadPlus m => (a1 -> m a) -> [a1] -> m a
16:56:56 <greg`> i havent read the fun of programming will try that next
16:56:59 <AshyIsMe> greg`: 24 days is written by ocharles in this channel too
16:57:07 <dalaing> greg`: those papers / that fun of programming chapter really levelled up my quick check understanding
16:57:33 <greg`> ashyisme a quick look over the blog posts and it feels like its good enough to publish as a book
16:57:59 <dalaing> greg`: fun of programming is kind of like a sequel to intro to fp using haskell by Richard Bird, ins ome places FOP kind of assumes you're at the level of someone who has finished ITFP
16:58:04 <greg`> dalaing where are the papers?
16:58:10 <dalaing> both are high recommended
16:58:24 <erisco> bennofs, I can probably spin it to go through Alternative instead of Monoid so it is still a good idea
16:58:51 <dalaing> greg`: http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf
16:59:20 <dalaing> greg`: http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf
16:59:24 <dalaing> whoops
16:59:34 <dalaing> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.9275
16:59:37 <greg`> lots of talk about alternative today
16:59:43 <greg`> thanks
17:00:10 <mreh> Are these wires signal functions or actual signals?
17:01:25 <greg`> thanks guys
17:01:30 <greg`> im off to bed
17:01:35 <greg`> lots to read now l-)
17:04:23 <erisco> ivanm, ping
17:04:31 <ivanm> pong
17:04:36 <erisco> yay hello
17:05:13 * ivanm waves
17:05:15 <erisco> Cale mentioned your name. I am working on a direct graph representation. Cale said you had a lot of knowledge in this area
17:05:34 <ivanm> well, I don't know about a _lot_ :p
17:05:56 <ivanm> but I've played with different implementations, and in my not-so-copious spare time I've been trying to build up a new graph library over the past few years
17:06:04 <ivanm> what's yoru thinking on the topic?
17:06:20 <sleuth> what does "Haskell 98 compliant" mean in that book?
17:06:40 <ivanm> sleuth: that it satisfies the requirements of the Haskell 98 report
17:06:40 <erisco> ivanm, personally I want to make a direct graph representation practical (opposed to indirect representations)
17:06:59 <ivanm> just to be clear, what do you mean by "direct graph representation"?
17:07:02 <erisco> ivanm, and the challenge is both efficiency and clarity
17:07:49 <erisco> ivanm, for example you could describe a graph as the 2-tuple (vertices, edges) where edges is a set of vertex ids and edges is the mapping between vertex ids
17:08:21 <erisco> ivanm, I am calling this indirect because the graph structure is only implied by the interpretation of the data
17:08:34 <ivanm> sure
17:08:54 <erisco> ivanm, versus a direct implementation where you have Vertex and Edge data types which directly hold references to each other, which requires tying the knot for cycles
17:09:23 <ivanm> so I've played a bit with this kind of thing; the issue is when you want to go "I want to delete the edge with ID foo"... how do you find it?
17:09:34 <erisco> (require tying the knot in some circumstances). I realized in many cases you can let the algorithm infinitely unfold the cyclic graph
17:10:02 <ivanm> and IIRC updating one node/edge (e.g. changing the label) can cause the entire graph needing to be rebuild due to all the references
17:10:28 <ivanm> so your implementation might work if you're doing some kind of unfolding function to lazily build the graph... but not so much as to manipulate it after the fact
17:11:33 <erisco> ivanm, you would find the vertex probably by a depth first search. to make the operation more efficient you could maintain a separate data structure
17:11:33 <ivanm> not to mention debugging... have a look at the C code for plantri; it uses pointers everywhere (a node is just a pointer to its first edge, etc.) which makes it a PITA to debug and work out how it works
17:11:41 <ivanm> (not to mention magic numbers)
17:11:54 <erisco> but no matter your representation you can find an algorithm which is not optimal to implement using it
17:12:01 <ivanm> sure
17:12:08 <erisco> so my answer to that is to augment the representation where necessary
17:12:35 <dhrosa> @pl count sentence word = fromIntegral $ length $ filter (== word) sentence
17:12:35 <lambdabot> count = ((fromIntegral . length) .) . flip (filter . (==))
17:12:35 <ivanm> I'd be interested in seeing what you have, but my interest is in having graphs I can manipulate afterwards, and tying-the-knot implementations typically don't work too well in scenarios
17:12:39 <ivanm> *those scenarios
17:13:07 <erisco> ivanm, I would like having a set of update algorithms typically required so that I can test their implementation against what I have
17:14:49 <erisco> ivanm, chiefly what I am after is clarity of algorithm implementation. performance is a concern afterwards. I like the direct representation because so far, I think, it is clear to work with
17:14:58 <ivanm> fair enough
17:15:04 <ivanm> I quite like performance though :p
17:15:14 <danilo2> Hello :) Could somebody explain to me, why this simple program does not print the array lazy to screen, but waits until it is complete and then prints it? http://lpaste.net/97906
17:15:46 <erisco> ivanm, indeed it is important, but I think it is better to address it wrt a specific algorithm
17:16:32 <twiceler> danilo2: It's lazy for me
17:17:06 <twiceler> danilo2: (in ghci)
17:17:31 <Cale> danilo2: Maybe try importing System.IO and adding hSetBuffering stdout NoBuffering as the first line of main
17:17:33 <danilo2> twiceler: Could you test compiling using ghc or runhaskell?
17:17:37 <erisco> ivanm, there is a fair bit of code thus far (200 lines) including a small separate module that may need explaining
17:17:45 <erisco> ivanm, shall I email you the zip file?
17:17:54 <erisco> or I can just lpaste it
17:18:01 <Cale> danilo2: My guess is that it's just buffering a complete line before printing anything.
17:18:16 <danilo2> Cale: I'm checking it , brb
17:18:18 <twiceler> danilo2: Compiled, it came out all at once, yeah
17:18:37 <danilo2> Cale, twiceler: Cale is right. Thank you! :)
17:18:48 <ivanm> erisco: either-or
17:19:10 <ivanm> or put it on hub.darcs/github/etc.
17:21:35 <aleksejs_> I have an infinite list and I take some elements with takeWhile using some condition. Is it possible to get the first element that failed?
17:21:58 <twiceler> aleksejs_: See span
17:22:14 <twiceler> > span (<5) [1..10]
17:22:15 <lambdabot>  ([1,2,3,4],[5,6,7,8,9,10])
17:22:56 <Komier> :t span
17:22:56 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
17:23:37 <benbangert> I see tuples here and there prefixed by ~, what does that mean?
17:23:51 <Eduard_Munteanu> benbangert: irrefutable pattern
17:25:00 <Eduard_Munteanu> benbangert: it means the pattern cannot fail, and furthermore the pattern-matching isn't strict
17:25:06 <benbangert> ah
17:26:53 <benzrf> :t join
17:26:54 <lambdabot> Monad m => m (m a) -> m a
17:26:57 <benzrf> :t (>>= id)
17:26:58 <lambdabot> Monad m => m (m b) -> m b
17:27:12 <benzrf> how can you define bind in terms of join?
17:27:23 <Eduard_Munteanu> benbangert: join .: fmap
17:27:32 <Eduard_Munteanu> Er.
17:27:35 <Eduard_Munteanu> benzrf: ^^
17:27:37 <benzrf> .: ?
17:27:41 <benzrf> :t (.:)
17:27:42 <lambdabot>     Not in scope: `.:'
17:27:42 <lambdabot>     Perhaps you meant one of these:
17:27:42 <lambdabot>       `.' (imported from Data.Function),
17:27:48 <Eduard_Munteanu> x >>= f = join (fmap f x)
17:28:06 <Eduard_Munteanu> benzrf: it's common notation for composition with a function that takes two arguments
17:28:13 <benzrf> oh
17:28:35 <shachaf> m >>= f = join (fmap f m)
17:28:45 <shachaf> No need to get fancy about it.
17:29:12 <Cale> fancy?
17:29:13 <benzrf> ohhhhh
17:29:16 <benzrf> i feel silly -.-
17:29:29 <Cale> oh
17:29:33 <Fylwind> so I'm trying to use the data Fix f = Fx (f (Fix f)) machinery for my ASTs but can't seem to figure out how to write a Hashable instance for Fix f
17:30:22 <benzrf> hmmm... can fmap be written in terms of join?
17:30:30 <benzrf> I know that it can be written in terms of bin
17:30:31 <benzrf> d
17:30:47 <shachaf> It can't be written in terms of bind alone.
17:30:55 <shachaf> ANd not in terms of join either.
17:30:59 <shachaf> Nor in terms of retract.
17:31:03 <benzrf> wait, really?
17:31:08 <benzrf> oh yeah
17:31:20 <benzrf> :t retract
17:31:21 <lambdabot> Not in scope: `retract'
17:32:16 <benzrf> hmm...
17:32:44 <Eduard_Munteanu> :t join . return . ?f
17:32:45 <lambdabot> (Monad m, ?f::a -> m a1) => a -> m a1
17:32:51 <Eduard_Munteanu> :(
17:33:32 <benzrf> @djinn (m a -> (a -> (m b)) -> m b) -> (m a -> (a -> b) -> m b)
17:33:33 <lambdabot> -- f cannot be realized.
17:33:35 <benzrf> bah
17:34:09 <Eduard_Munteanu> djinn doesn't really handle functors.
17:34:37 <SLi> Ok, I don't think this is probably possible in general, but anyway: Is it possible to run, in a monad (right now thinking about attoparsec) code that does something like do { x <- someop; fail }, but anyway somehow manages to smuggle x out of the function? (In parser context it might make sense; for example, do { input <- parseSomething; fail (i.e. backtrack) }, but anyway return input, i.e. look ahead.
17:35:38 <Cale> SLi: I don't even understand what you mean
17:35:50 <benzrf> SLi: i dont think you can escape monads
17:35:55 <Cale> SLi: You mean like producing an exception which contains x?
17:35:58 <benzrf> SLi: otherwise IO would be unsafe
17:36:07 <benzrf> *impur
17:36:10 <benzrf> e
17:36:14 <Cale> I'm not sure that's what SLi is looking for...
17:36:20 <Cale> (But I don't really know)
17:36:31 <Cale> There's Cont/ContT
17:36:53 <Cale> Where you have callCC (\ret -> do x <- someop; ret x)
17:36:55 <Eduard_Munteanu> SLi: perhaps with a StateT on top
17:37:11 <SLi> Cale: :) Ok, I suspect it doesn't make much sense generally in a monad. What I'm looking for in (atto)parsec terms is a way to say "try to parse something, but don't consume the input even if you succeed".
17:37:22 <Cale> Oh, that's completely different
17:37:47 <Cale> That's what try is for
17:37:52 <Cale> er
17:37:57 <Cale> or lookAhead
17:38:24 <Cale> oh, does Attoparsec have lookAhead?
17:38:31 <SLi> There's no lookAhead in attoparsec.
17:38:37 <twiceler> SLi: perhaps (replicate n peekChar)?
17:38:39 <Cale> Well, we can probably write it
17:38:57 <Cale> twiceler: I think that'll give n of the same thing
17:38:58 <SLi> Actually I wrote a stackoverflow question about what I'm trying to do :) http://stackoverflow.com/questions/20894973/is-it-possible-to-efficiently-look-ahead-more-than-one-char-in-attoparsec
17:39:10 <twiceler> Oh, right! Good call
17:39:58 <SLi> There *used* to be a getInput which returns the rest of input as a ByteString. I don't understand (probably some internal reason) why I would need to convert it to a list of Chars just to do that since that's not what I'm going to use anyway.
17:41:16 <Cale> Have you considered using regular Parsec?
17:41:21 <Cale> It does have lookAhead
17:41:39 <Eduard_Munteanu> I think he should just tokenize his input properly to parse C++ stuff. :)
17:41:53 <aleksejs_> I'm trying to solve 12th PE problem, and my solution http://vpaste.net/k6Fpz works for small number, but for 500 it takes ages. Any advice how to optimize it?
17:42:16 <Cale> Yeah, that's anothat option, just do a lexing pass, and parse the resulting stream of tokens instead
17:42:32 <simpson> +1 on lexing. Smaller passes are better than bigger passes.
17:42:47 <Eduard_Munteanu> Cale: his current approach is applying some regexes and somehow getting Parsec to work with that
17:43:12 <simpson> That's pretty much *exactly* what Alex does.
17:43:24 <simpson> So put the regexes into Alex, get tokens out, and then use Parsec on the tokens.
17:43:24 <Eduard_Munteanu> I suggested Alex as well. :)
17:43:41 <Cale> aleksejs_: Factor the numbers into primes recursively dividing off small facters
17:43:44 <Eduard_Munteanu> He wants the input text though.
17:43:46 <Cale> factors*
17:44:01 <simpson> Hm.
17:44:08 <simpson> What's the reason for that? Error handling?
17:44:29 <Cale> aleksejs_: also, the number of divisors of p_1^k_1 * ... * p_n^k_n is equal to (k_1 + 1)*...*(k_n + 1)
17:44:40 <simpson> Alex can give you the positions of the inputs, and then you can hand that up to Parsec to get line/column error reporting.
17:44:47 <Eduard_Munteanu> He's parsing a very large file and concerned about performance, likely not for error reporting.
17:45:04 <Cale> aleksejs_: something like this: http://lpaste.net/97909
17:45:32 <SLi> Cale: I tried that, but it was too slow. In fact even my current attoparsec solution is slower than regexps, and I'm trying to make it faster, not slower :)
17:45:49 * hackagebot acme-year 2014 - Get the current year  http://hackage.haskell.org/package/acme-year-2014 (JoeyAdams)
17:45:51 * hackagebot web-routes 0.27.4 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.27.4 (JeremyShaw)
17:46:04 <Cale> SLi: I mean, use regular expressions to tokenise your input, or do whatever you're trying to do that way
17:46:12 <SLi> simpson: But the entire input is not sensibly to tokenizable, only a small portion of it is.
17:46:23 <Cale> SLi: and produce a list of tokens which you can then parse
17:46:32 <Cale> What language are you parsing?
17:46:50 <Eduard_Munteanu> SLi: your tokenizer can skip irrelevant things just as well
17:50:09 <SLi> Lines of OllyDbg debugger run trace. It's annoyingly non-parseable. It contains something like "main  address  assembly_instr  ;register_changes_etc".  But address can be either hex or a demangled C++ symbol with niceties like spaces. If it's too long, instead of spaces it's separated from the asm by a semicolon. Etc...
17:50:28 <L8D> How can you get the divisors of a number?
17:50:41 <L8D> Or, at least, how many divisors there are
17:51:11 <Cale> L8D: I just pasted some code to do that
17:51:28 <newsham> > [n | n <- [1..100], 93 `rem` n == 0]
17:51:29 <Fylwind> Is it even possible to write instances for Fix?
17:51:30 <lambdabot>  [1,3,31,93]
17:51:45 <SLi> I'd only need to get address (whether hex or c++ symbol) and the rest of the line for that, but I'd need to get it fast; the dump is gigabytes long...
17:51:55 <Eduard_Munteanu> Fylwind: yes
17:52:21 <Cale> L8D: I just did trial division against prime numbers, factoring out the smallest prime until none were left, and then did product . map ((+1) . length) . group on the resulting list.
17:52:23 <Fylwind> Eduard_Munteanu: how do you do that? :3
17:52:45 <Eduard_Munteanu> Fylwind: instances of what? I mean you can write instances just like for any other type.
17:52:51 <L8D> okay
17:52:57 <Fylwind> e.g. Show
17:53:07 <Eduard_Munteanu> Fylwind: sure
17:53:14 <Fylwind> instance ??? => Fix f
17:54:04 <SLi> A rather good regexp to split the entire line to the components I need would be "^(main)  ([0-9A-F]{8}|(unsigned |[^ ;]| >)+)( +|;)(.*)$"
17:54:14 <tomberek> Cale: I've been trying to express a concept in haskell for a while, but I'm running into difficulties. I want to say that one type points to another, and then another, then another, but it is a loop that has to close back to the begining. It's almost like Fix, that repeated applications of a type function should eventually create the original argument.
17:54:49 <SLi> Or "^(main)  (?P<addr>[0-9A-F]{8}|(unsigned |[^ ;]| >)+)( +|;)(?P<rest>.*)$" with named groups, and if there was support for named groups in haskell regexps, this is how I would do it
17:54:58 <Eduard_Munteanu> Fylwind: for any f? Try   instance Show (f (Fix f a)) => Show (Fix f a)  but it does seem tricky
17:55:22 <Fylwind> it requires UndecidableInstances I presume then?
17:55:27 <tomberek> Eg: Next Int=Bool, Next Bool=Int     or    Next a=b; Next b=c; Next c=a.....   how can I express that constraint so that the attempt to define Next without that loop is a compile time error? (I've been trying closed type families)
17:55:28 <Eduard_Munteanu> Fylwind: likely
17:55:44 <SLi> The regexp code is still 4x faster than my attoparsec code, but I need to match for things like [_, addr, _, _, _, rest] to extract the output I need, and the order and number of _:s changes with every change to the regexp :D
17:55:57 <Eduard_Munteanu> Fylwind: actually I don't think that works
17:56:27 * Eduard_Munteanu thinks
17:56:37 <SLi> And I just feel too bad about counting parentheses in a regexp string by hand and writing supposedly strongly typed Haskell to match it, so I turned to parser combinator libraries.
17:58:22 <SLi> Here's a somewhat pathological example of input string: "main  35E36D04                    call dword ptr ds:<&MSVCP71.std::basic_string<unsigned short,std::char_traits<unsigned short>,std::allocator<unsigned short> >::insert>;35ED71DC=7C3B4165 (MSVCP71.std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::insert);ESP=0018EBD0"
17:58:37 <SLi> And I'm seriously not interested in parsing the C++, only about extracting it from the rest.
17:58:43 <Eduard_Munteanu> Fylwind: it might work with UndecidableInstances, but it might require a few tricks, have you tried it?
17:58:51 <Fylwind> not yet
17:59:07 <SLi> Ok, that's not pathological even because it has a hex addr instead of... hmm.
18:03:28 <aleksejs_> Cale, "the number of divisors of p_1^k_1 * ... * p_n^k_n is equal to (k_1 + 1)*...*(k_n + 1) " << could you give some link where I can read about this?
18:04:23 <Eduard_Munteanu> aleksejs_: when p's are prime? It seems rather straightforward.
18:04:27 <Cale> aleksejs_: Well, just think about the possible primes occurring in the factorisation of a divisor of that number
18:04:35 <ashwin_> hey guys, quick question about CCCs, type theory, and Curry-Howard-Lambek (xpost from haskell-in-depth because I'm getting no joy there...)
18:04:41 <Cale> There are between 0 and k_1 occurrences of p_1
18:04:46 <ashwin_> seems like the definition of CCC makes no mention of the existence of coproducts
18:04:51 <Cale> and then between 0 and k_2 occurrences of p_2, and so on
18:04:57 <ashwin_> all you need to be a CCC is (1) terminal object, (2) products, (3) exponentials
18:05:04 <Eduard_Munteanu> ashwin_: yeah, it doesn't
18:05:06 <ashwin_> in type theory land, that corresponds to (1) unit type, (2) product types, (3) function types
18:05:19 <ashwin_> but then, how can such a type system have any types that are not (isomorphic to) unit?
18:05:25 <Cale> So that's k_1 + 1 options for the number of occurrences of p_1, and k_2 + 1 options for the number of occurrences of p_2, and so on.
18:05:25 <ashwin_> inparticular, without sum types, how can you build...anything?
18:06:05 <Eduard_Munteanu> ashwin_: it does have coproducts, just not solely as a CCC
18:06:20 * hackagebot web-routes-happstack 0.23.6 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.23.6 (JeremyShaw)
18:06:20 * hackagebot web-routes-wai 0.23.0 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.23.0 (JeremyShaw)
18:06:28 <Cale> ashwin_: Well, depends on the CCC in question
18:06:47 <ashwin_> Eduard_Munteanu: OK, but am I correct in understanding that Curry-Howard-Lambek tells us that simply typed lambda calculus, intuitionistic logic, and CCCs are all sort of the same?
18:06:58 <Eduard_Munteanu> If you wanted the dual of CCC, you'd need coexponentials as well, which we don't have.
18:07:21 <ashwin_> Eduard_Munteanu: agreed. I'm not talking about that. I'm trying to understand how simply-typed lambda calculus is isomorphic to a CCC.
18:07:24 <Cale> ashwin_: yes
18:07:47 <Cale> ashwin_: Also note that if you don't throw in any base types to start with, there are no well-typed terms of the STLC.
18:07:53 <Eduard_Munteanu> ashwin_: oh, well, depends on the STLC... commonly it doesn't have sum types
18:08:09 <ashwin_> Cale: OK, but CCC gives us one base type (unit) because it requires a terminal object.
18:08:12 <aleksejs_> Cale, I think I got it: if one of divisors f number is 27, then pfactor will contain [3,3,3] and it's length would be equal to [3,9,27]
18:08:36 <ashwin_> Eduard_Munteanu: wait a minute, so you're telling me that an STLC without sum types can still be isomorphic to intuitionistic logic? How do you get logical disjunction?
18:08:44 <Cale> Oh, well okay, yeah, you'll probably at least have the unit type if you're doing this in such a way as to make the correspondence work out
18:08:58 <dhrosa> if I want to pattern match against a constructor, but don't care about any of its args, are there any ways to do that concisely?
18:09:08 <ivanm> dhrosa: Foo{}
18:09:09 <ashwin_> Cale: precisely. What I'm asking is, how do you construct other types from unit, products, and exponentials (function types)?
18:09:18 <Cale> But it's boring if you don't put in anything else
18:09:25 <ashwin_> Cale: equivalently, how can you construct logical disjunction from truth, conjunction, and material implication?
18:09:34 <Cale> The idea is that you can interpret lambda terms in any category which happens to be a CCC
18:09:52 <Cale> But some CCCs are boring
18:10:18 <ashwin_> Cale: I agree with you there. All I'm saying is that, without any additional structure, I don't see how a CCC can be as powerful as STLC or intuitionistic logic.
18:10:27 <Eduard_Munteanu> ashwin_: you can get something like disjunction from a Heyting algebra.
18:10:27 <dhrosa> ivanm: like, myFunc (Foo {}) = ?
18:10:49 <ivanm> dhrosa: yup; don't think you need the parens but I can't recall
18:10:51 <ashwin_> Eduard_Munteanu: good to know. Is there a canonical way to construct a Heyting algebra from a CCC?
18:10:56 <Cale> Well, the analogue to only having the unit type is to just take the CCC which consists of a single object with only the identity arrow
18:10:57 <dhrosa> becaues that's a syntax error for me :(
18:11:12 <Cale> It has products and exponentials, and the single object is indeed a terminal object
18:11:13 <aristid> :t let foo Just{} = undefined in foo
18:11:14 <lambdabot> Maybe t -> a
18:11:28 <Eduard_Munteanu> ashwin_: https://en.wikipedia.org/wiki/Heyting_algebra second paragraph
18:11:28 <aristid> ivanm: yup not required
18:11:32 <dhrosa> helper (Just (File _ _ _)) works, but helper (Just (File {})) doesn't
18:11:36 <Cale> You can interpret the lambda calculus in this, but it's not very interesting.
18:11:52 <ashwin_> Cale: Yes, exactly. OK. So then, the content of Curry-Howard-Lambek must be different from what I understand. It's not saying that *any* CCC is isomorphic to *any* STLC or intuitionistic logic
18:12:03 <Cale> hm?
18:12:05 <ivanm> dhrosa: :o
18:12:08 <aristid> :t let foo Just (Just{}) = undefined in foo
18:12:09 <lambdabot>     Constructor `Just' should have 1 argument, but has been given none
18:12:09 <lambdabot>     In the pattern: Just
18:12:09 <lambdabot>     In an equation for `foo': foo Just (Just {}) = undefined
18:12:12 <Cale> Well, it kind of is
18:12:24 <Cale> There is a STLC which corresponds to this trivial case
18:12:26 <Eduard_Munteanu> ashwin_: particularly the  a -> b  <=>  ~a v b  correspondence
18:12:33 <ivanm> :t let foo (Just Just{}) = undefined in foo
18:12:34 <lambdabot> Maybe (Maybe t) -> a
18:12:41 <ivanm> dhrosa: ^^
18:12:42 <dhrosa> wait it works now, I must have had a typo
18:12:49 <Cale> It's just that all your types happen to be equal to each other and all your terms happen to be equal to the identity
18:12:53 <ivanm> aristid: you do need parens for the outer one :p
18:12:59 <aristid> ivanm: oh lol
18:13:01 <ashwin_> Cale: yes, I agree. but it is not the case that, for *any* CCC, *any* STLC/intuitionistic logic is equal to it
18:13:09 <Cale> oh, sure
18:13:12 <ashwin_> Cale: rather it's more like for *any* CCC, *there exists* an isomorphic STLC or intuitinoistic logic
18:13:15 <benbangert> I have a list of functions that I want to apply to a value to get a list of results, which function should I be looking for?
18:13:17 <Cale> for any CCC, *some* STLC
18:13:19 <Cale> yeah
18:13:59 <ashwin_> Cale: precisely. OK, got it. But then the more interesting case seems to be the correspondence between BCCs and (some) intuitionistic logics/STLCs
18:14:01 <Eduard_Munteanu> ashwin_: now IIRC, the usual construction is translating exponentials to a '<=' in such an algebra
18:14:31 <ashwin_> Eduard_Munteanu: OK, will take a look at that Wikipedia article (thanks).
18:16:14 <ashwin_> Cale: OK, seems to make sense.
18:16:18 <ashwin_> thanks!
18:16:25 <tomberek> Is there a way to ensure that repeated application of a type level function is cyclic?
18:17:56 <Eduard_Munteanu> ashwin_: I guess if you have an initial object you can write 'A v B' as 'B^(0^A)'
18:19:11 <Eduard_Munteanu> Er, he went away.
18:19:53 <tomberek> using type families, I can have something like Next Int = Bool ; Next Bool = Int (a cycle of just two). Can this be baked into the type system?
18:20:44 <Eduard_Munteanu> tomberek: is the cycle length known?
18:21:00 <ivanm> tomberek: somewhere say (a ~ Next (Next a)) ?
18:21:02 <tomberek> no, I think I can do it with fixed cycle length already
18:21:05 <ivanm> assuming it's always of length 2
18:21:33 <tomberek> ivanm: yeah, but I want something like a ~ Fix Next a  (bad parens)
18:21:47 <tomberek> but I havn't been able to get that working
18:21:54 <danilo2> Hello! I want to ask you about one thing. If I'm implementing a function, which will make several time consuming IO operations and I want to use logger (which will print logs to console) I cannot use WriterT to keep the logs? (because there is no way to pront these logs inbetween the havy operations?)
18:22:08 <ivanm> I don't think you want Fix, as that implies a fixed point
18:22:24 <ivanm> danilo2: yeah, WriterT is more for getting logs at the end
18:22:37 <tomberek> ivanm: is that not a fixed point? that repeated application is a cycle?
18:22:45 <Eduard_Munteanu> Er, shouldn't runWriterT be productive?
18:23:09 <danilo2> ivanm: Right now I'm using RWST and it is a problem I'm facing. I understand that in such situation the normal IO monad is the only (and preffered) solution?
18:23:17 <tomberek> a ~ Next (Next (Next ... a)))  reminds me a lot of Mu/Nu/Fix
18:23:30 <ivanm> ummm... I've never really had to do logging like that, so I'm not sure
18:23:37 <danilo2> Eduard_Munteanu: What do you mean by that?
18:23:43 <ivanm> tomberek: fixed point means you reach a point s.t. f a = a
18:23:51 <Eduard_Munteanu> @src runWriterT
18:23:52 <lambdabot> Source not found. You untyped fool!
18:23:54 <zRecursive> :t fix
18:23:55 <lambdabot> (a -> a) -> a
18:24:04 <Eduard_Munteanu> @src WriterT
18:24:04 <lambdabot> Source not found. I am sorry.
18:24:14 <Eduard_Munteanu> :t runWriterT
18:24:15 <lambdabot> WriterT w m a -> m (a, w)
18:24:27 <L8D> @src fix
18:24:27 <lambdabot> fix f = let x = f x in x
18:24:41 <tomberek> ivanm: i want to express that f ( f ( f (f ... a eventually equals a again
18:24:54 <tomberek> or that f.f.f....f = id
18:25:00 <L8D> :i fix
18:25:08 <tomberek> at the type level
18:25:21 <ivanm> tomberek: right, it's the _eventually_ bit that's a problem
18:25:31 <L8D> > fix (+ 1)
18:25:34 <ivanm> you want there-exists n. f^n a = a
18:25:35 <lambdabot>  mueval-core: Time limit exceeded
18:25:37 <ivanm> (at the type level)
18:25:41 <ivanm> > fix error
18:25:42 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
18:25:55 <tomberek> sure, but i don't expect there to be cycles that are too long (probably 4-6 at the most)
18:26:07 <L8D> > fix $ const (putStrLn "Yo")
18:26:08 <lambdabot>  <IO ()>
18:26:24 <danilo2> Eduard_Munteanu: ivanm: Here is very simple example of that problem (havy io operation was replaced with fibbonaci computation): http://lpaste.net/97910
18:26:25 <tomberek> i can just write out 6 instances, one for each cycle length.. I was looking for an elegant solution that subsumes them
18:26:50 <ivanm> yeah, might be your best bet unfortunately
18:26:52 <L8D> > fix $ const 0
18:26:53 <lambdabot>  0
18:27:13 <ivanm> L8D: if you're experimenting, you can always /message lambdabot > foo
18:27:22 <tomberek> ivanm: i was hoping with the addition of closed type families it would be possible
18:27:28 <L8D> What module is fix in ?
18:27:48 <ivanm> @where fix
18:27:49 <lambdabot> I know nothing about fix.
18:27:52 <ivanm> whoops
18:28:02 * ivanm tries to remember the lambdabot commands...
18:28:09 <L8D> :i fix
18:28:10 <ivanm> @hoogle fix
18:28:11 <lambdabot> Data.Function fix :: (a -> a) -> a
18:28:11 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
18:28:11 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
18:28:17 <ivanm> there we are ;-)
18:28:25 <ivanm> alas lambdabot doesn't have an @info plugin
18:28:30 <danilo2> Eduard_Munteanu: According to this example : http://lpaste.net/97910 , the IO Monad is the only way to go ?
18:30:28 <Eduard_Munteanu> Hm, it is productive but the inner monad is problematic.
18:30:56 <Eduard_Munteanu> danilo2: you can roll your own if you use MonadWriter as an API
18:31:24 <Eduard_Munteanu> There are some ready-made logging monads too.
18:31:51 <L8D> Is there a time where one would encounter nested IO monads?
18:32:18 <ivanm> L8D: well... you can't, really
18:32:23 <ivanm> IO isn't a monad transformer
18:32:45 <danilo2> Eduard_Munteanu: Can I? Could you tell me more how?
18:32:51 <L8D> Can't you have IO (IO a)
18:33:09 <enthropy> @type newIORef (print "hi")
18:33:10 <lambdabot>     Not in scope: `newIORef'
18:33:10 <lambdabot>     Perhaps you meant `newSTRef' (imported from Data.STRef)
18:33:14 <danilo2> Eduard_Munteanu: By logging monads do you mean System.Log.Logger ? (which is not a monad btw only some functions in unsafeperformio)
18:33:31 <Eduard_Munteanu> danilo2: no, there are some packages around
18:33:45 <enthropy> @type Data.IORef.newIORef (print "hi")
18:33:46 <lambdabot> IO (GHC.IORef.IORef (IO ()))
18:34:36 <ivanm> L8D: oh, right, that's what you meant
18:34:40 <Eduard_Munteanu> Possibly involving FreeT.
18:35:08 <L8D> interesting
18:35:12 <ivanm> L8D: except I don't think it'll do what you want: the inner IO just lets you construct IO statements you eventually execute in the outer one
18:35:14 <Eduard_Munteanu> @hoogle freet
18:35:14 <lambdabot> package freetype2
18:35:14 <lambdabot> package FreeTypeGL
18:35:39 <L8D> @hoogle yoda
18:35:40 <lambdabot> No results found
18:35:42 <L8D> :(
18:36:28 <Polarina> Haha!
18:37:12 <stian> Trying to get some very simple graphing work in IHaskell. This line: toRenderable $ plotLayout $ plot [0,0.1..10] sin; works perfectly, but the graph is too large. How can I set the size of the output svg? (I tried navigating the Hackage documentation, but got lost)
18:37:31 <ivanm> stian: svgs are vector graphics... they don't have sizes...
18:37:42 <ivanm> or is it just a display thing in IHaskell?
18:38:50 <stian> ivanm: Makes sense. In the computed HTML in IHaskell it says: <svg [...] width="800pt" height="600pt" viewBox="0 0 800 600"... I'm trying to figure out if this comes from Graph, or IHaskell, or the IPython backend somehow :)
18:38:58 <danilo2> Eduard_Munteanu: Hmm I do not know Free Monads, but I will read about them. thank you. I will search for something. Maybe you were talking about this:
18:39:18 <ivanm> stian: any idea where that toRenderable is from?
18:39:19 <danilo2> Eduard_Munteanu: http://hackage.haskell.org/package/monad-logger-0.3.4.0/docs/Control-Monad-Logger.html
18:39:21 <Fuuzetsu> Has there ever been a talk of allowing local module imports in ‘where’ blocks, like Agda does?
18:39:29 <ivanm> is it an inbuilt in IHaskell?
18:39:30 <stian> ivanm: From the Graph library.
18:39:33 <ivanm> or are you importing another library?
18:39:38 <Eduard_Munteanu> danilo2: yeah
18:39:45 * AfC waves to ivanm
18:39:45 <ivanm> stian: which Graph library?
18:39:50 * ivanm waves back to AfC 
18:39:51 <stian> ivanm: Haskell Graph.  Graphics.Rendering.Chart.Simple
18:39:56 <Eduard_Munteanu> ivanm: chart, he asked earlier
18:40:08 * ivanm also tries to restrain his shudders at using Graph to refer to plots... :p
18:40:16 <ivanm> ahh, chart...
18:40:28 <stian> ivanm: Sorry, chart. Got confused :) http://hackage.haskell.org/package/Chart-1.1/
18:40:47 <m3ga> is there a way to prevent a certain variable from 'escaping' a function?
18:40:53 * stian apologizes to channel for confusing graph and chart. 
18:40:55 <geekosaur> ?
18:41:07 * ivanm accepts stian's apology on behalf of the channel
18:41:13 <m3ga> geekosaur: was that directed at my question?
18:41:17 <AfC> ivanm: are you going to be in Perth next week?
18:41:23 <Fuuzetsu> stian: I think that nothing short of few new libraries on Hackage will make up for this mistake
18:41:34 <geekosaur> m3ga, yes. all I'm thinking of (that makes sense in Haskell) is ST
18:41:38 <ivanm> AfC: nope; I celebrate Christmas on the 7th, so I'm up in Brisbane atm
18:41:41 <stian> Eduard_Munteanu: And thanks a lot for setting me in the right direction. The weird thing is that I spent a bunch of time coming up with the right incantation, before finding it in the documentation of an old version of the library. The example was taken out of the current version, but still works. Weird.
18:42:07 <ivanm> stian: is Chart choosing svg output, or did you specify it somewhere?
18:42:09 <m3ga> geekosaur: hmm, interesting. yes, that does seem a little like ST
18:42:17 <m3ga> will look into it
18:42:23 <stian> Fuuzetsu: The Haskell world would probably be better served by waiting until I actually learn the language, before I begin inflicting code on you all :)
18:42:49 * ivanm hasn't touched Chart for a while
18:42:56 <Fuuzetsu> Well, it's very easy to contribute to existing stuff if you want to look into that.
18:43:19 <ivanm> oh, does Chart just use SVG's by default? I recalled it using gtk libraries
18:43:21 <stian> ivanm: There are four backends of the simple chart interface, PS, PDF, PNG, and plot, which just generates a layout. I think there's a IHaskell function that accepts a renderable and renders it.
18:43:45 <ivanm> *nod*
18:43:53 <danilo2> Hmmm, Could somebody explain to me what is the difference in using Control.Monad.Logger over hslogger?
18:43:57 <stian> Fuuzetsu: Well, if I could get one-line graphing working in IHaskell, and make some nice example notebooks demonstrating probability concepts using Haskell, I think that would be a nice contribution :)
18:44:14 <Fuuzetsu> best of luck
18:44:20 <ivanm> stian: are you using just Chart, or Chart-cairo or Chart-diagrams?
18:44:49 <danilo2> Eduard_Munteanu: I see, you've got not much time today, but If you could tell me more about benefits of using Control.Monad.Logger over hslogger, I would be very thankful :)
18:44:59 <dhrosa> how do you do a multi-argument bind?
18:45:04 <Eduard_Munteanu> danilo2: I don't really know
18:45:11 <ivanm> dhrosa: do you mean bind as in >>= ?
18:45:16 <dhrosa> instead of do a <- f; b <- g; h a b
18:45:18 <stian> ivanm: Chart-diagrams I think. Actually, I think the magic happens here, in the ihaskell-display/charts module (separate from the IHaskell main repo, which is why I didn't find it). Can't find any sizing info though. https://github.com/gibiansky/IHaskell-Display/blob/master/IHaskell-Charts/IHaskell/Display/Charts.hs#L1
18:45:18 <dhrosa> ivanm: yes
18:45:18 <Fuuzetsu> dhrosa: you don't
18:45:19 <danilo2> Eduard_Munteanu: Ok, thank you :)
18:45:39 <Fuuzetsu> dhrosa: you can desugar that with lambda if that please you
18:45:50 <Fuuzetsu> @undo do a <- f; b <- g; h a b
18:45:51 <lambdabot> f >>= \ a -> g >>= \ b -> h a b
18:46:02 <dhrosa> hmm, darn, thanks
18:46:27 <Eduard_Munteanu> dhrosa: like   (a, b) <- liftM2 (,) f g   ?
18:46:38 <stian> ivanm: I think I'll have to look at whether renderableToFile has a size option.
18:46:43 <enthropy> stian: try making the chart without IHaskell
18:46:46 <dhrosa> oh, I think that's what I want
18:46:56 <dhrosa> wait
18:46:58 * ivanm shudders at the implementation of the module stian linked to
18:47:18 <Fuuzetsu> there's certainly a lot of shuddering from ivanm tonight
18:47:49 <enthropy> but it works
18:47:58 <Fuuzetsu> for now!
18:48:16 <dhrosa> oh wait, I asked the wrong question :/
18:48:21 <ivanm> Fuuzetsu: heh
18:48:38 <ivanm> Fuuzetsu: can't be the weather: the sun is shining, and it's rather warm and humid atm
18:49:10 <Fuuzetsu> you must be living in one of those ‘somewhere that's not here’ countries then
18:49:31 <zRecursive> where is here ?
18:49:44 <ivanm> @time
18:49:45 <lambdabot> Local time for ivanm is Fri Jan  3 12:45:51
18:49:49 <Fuuzetsu> anywhere where the sun is not shining and it's not warm
18:49:52 <Fuuzetsu> @time
18:49:52 <lambdabot> Local time for Fuuzetsu is Fri Jan  3 02:45:59 2014
18:50:03 <Fuuzetsu> haha, I get a year as well!
18:50:14 <ivanm> doing a /whois on me might give you a hint on where I am... ;-)
18:50:16 <tippenein> @time
18:50:20 <lambdabot> Local time for tippenein is Thu Jan  2 20:46:23 2014
18:50:35 <zRecursive> @time
18:50:37 <lambdabot> Local time for zRecursive is Fri Jan  3 10:46:52 2014
18:51:00 <Fuuzetsu> ivanm: Oh, are you in that one country where every animal-like creature kills you on the spot? Keep the weather.
18:51:04 <tippenein> everyone is in the future!
18:51:06 <ivanm> Fuuzetsu: you really need to know which year I'm in? :p
18:51:16 <ivanm> Fuuzetsu: that's the one!
18:51:23 <Fuuzetsu> I'm simply curious why it didn't show the year for you.
18:51:27 <ivanm> @google come to Australia, you might accidentally get killed
18:51:28 <lambdabot> http://www.youtube.com/watch?v=eNEeq5qGh8I
18:51:28 <lambdabot> Title: "Come To Australia" by Scared Weird Little Guys - YouTube
18:51:28 <stolaruk> Fuuzetsu: What does your nickname mean?
18:51:38 <ivanm> Fuuzetsu: because it's up to the client to format and display the CTCP result
18:52:06 <Fuuzetsu> stolaruk: It's just a thing from this one anime: http://shakugan.wikia.com/wiki/Fūzetsu
18:52:26 <ivanm> Fuuzetsu: couldn't do an accent so you doubled the character instead? :p
18:53:01 <stian> I did it! :) Just had to modify the IHaskell-Charts function with size:       opts = def{_fo_format = format,_fo_size = (300,300)} . See the result: http://imgur.com/QEVYgld. Thanks for all your help - the pedagogical questions helped point me in the right direction.
18:53:03 <Fuuzetsu> ivanm: Yep. It's an accent where I can do one. For some reason all Haskell Trac sites I'm on do the accent except GHC Trac…
18:53:09 <stolaruk> Fuuzetsu: I thought it sounded Japanese, but it didn't come up in my dictionary
18:53:22 <ivanm> heh
18:53:29 <ivanm> maybe someone already registered the nick?
18:53:33 <Fuuzetsu> stian: That's pretty cool.
18:53:37 <ivanm> (maybe _you_ already registered and forgot? :p)
18:53:50 <stolaruk> ivanm: fuu is perfectly fine way to write that without the accent
18:53:52 <Fuuzetsu> ivanm: No, I could register it but could not use it to log in. It probably mangled it.
18:54:10 <Fuuzetsu> I certainly did not forget it 3 seconds after registering.
18:54:20 <Fuuzetsu> GHC Trac needs a Trac…
18:54:44 <Eduard_Munteanu> Yes, someone put it on the right trac, now.
18:54:59 <Fuuzetsu> Alright, I see this is going the wrong way.
18:55:19 <simpson> Yeah, I would not recommend Trac.
18:55:28 <ivanm> Eduard_Munteanu: *groan*
18:55:31 <Fuuzetsu> Oh, there's a ‘Trac & Git’ category on GHC Trac.
18:55:40 <stolaruk> Fuuzetsu: Do you speak Japanese?
18:55:43 <Fuuzetsu> Seems I have a ticket to… trac.
18:55:48 <Fuuzetsu> stolaruk: A bit, why?
18:56:24 <stolaruk> Fuuzetsu: Just curious. I do. The Japanese Haskell channel is, sadly, always silent
18:58:27 <Fuuzetsu> boo, they must have changed the Trac a bit because now I just get  ‘Warning: Username FūzetsuTest doesn't match local naming policy. ’ (should probably say ‘Error’…)
18:58:40 <Fuuzetsu> My ‘Fūzetsu’ account does exist though, can't remake it.
18:59:32 <Fuuzetsu> stolaruk: I never went into any regional Haskell channels, it just seems like they'd be very quiet and considering that the main channel is in the language I speak most, I just stay here (and some offsprings like -blah &c)
19:01:07 <stolaruk> Fuuzetsu: Yeah this is are really good channel all around.
19:05:46 <L8D> stolaruk: Do you speak japanese as a first or second language?
19:06:35 <stolaruk> L8D: Second. Japanese was my major at university and I lived there for 7 years, but I'm back in my home county now (US)
19:07:09 <L8D> cool
19:07:09 <djahandarie> The Japanese Haskellers don't really talk on IRC, unfortunately
19:07:18 <djahandarie> They are all quite active on Twitter though
19:07:48 <stolaruk> Yeah I've tried to talk to ppl on the channel, got no response whatsoever. I am starting to find some ppl to follow on Twitter
19:08:38 <stolaruk> There are Jpns translations of LYAH and RWH available.
19:09:08 <stolaruk> Someone must be reading them ;)
19:09:28 <djahandarie> You can look through https://twitter.com/djahandarie/following , I follow a bunch of Japanese Haskellers/related fields
19:09:40 <djahandarie> And other interesting people too! :P
19:10:19 <stolaruk> djahandarie: Awesome! I'll check it out now.
19:11:01 <shachaf> If you're not following me then your followees can't be *that* interesting!
19:11:17 <shachaf> My twitterings are the best.
19:13:00 <stolaruk> djahandarie: I'm following you now. How is it that you know Jpns?
19:13:35 <zomg> stolaruk: that's usually done by a process callead "studying"
19:14:06 <stolaruk> zomg: Not always.
19:14:21 <shachaf> I'd think that that's relatively rare among Jpns-knowers.
19:15:18 <zomg> shachaf: I'd guess that would apply for most languages
19:15:24 <djahandarie> stolaruk, dunno. Some combination of watching anime and studying Japanese linguistics. :P
19:15:33 <zomg> djahandarie: lol, sounds about same as for me
19:15:41 <Polarina> Never enough Anime.
19:17:28 <zomg> anyone who can understand at least some spoken japanese might wanna check out the raws for the new years gaki no tsukai special =)
19:17:33 <zomg> that shit's so fucking hilarious
19:17:59 <Ashton> So... I'm having an issue with cabal's repl command.
19:18:00 <Ashton> Can anyone help?
19:18:38 <m3ga> can anyone figure out why this http://lpaste.net/97157 is not compiling? i'm getting some incomprehensible (to me anyway) type errors.
19:19:03 <Ashton> http://pastebin.com/xD0CRC6x
19:19:08 <mauke> The paste xD0CRC6x has been copied to http://lpaste.net/97911
19:19:10 <shachaf> m3ga: I recommend including them even if they're incomprehensible.
19:19:30 <Ashton> Man, lpaste ruined all the syntax highlighting.
19:19:55 <Ashton> Anyways, I'm not getting any errors out of cabal, just being dropped back to bash
19:20:08 <Ashton> (All my source files are in src/)
19:20:10 <m3ga> shachaf: just updated
19:21:22 <dcoutts_> Ashton: does your .cabal file contain a library or executable section?
19:21:34 <Ashton> Yup.
19:21:56 <Ashton> Which only has build-depends, hs-source-dirs, and a default-language (Haskell2010)
19:21:59 <Ashton> Library section, to be precise.
19:22:13 <dcoutts_> does it expose any modules?
19:22:18 <Ashton> Oh, should it?
19:22:24 <dcoutts_> or contain any?
19:22:41 <Ashton> Contains 2
19:22:49 <dcoutts_> a library with no usable interface is a little degenerate
19:23:05 <Ashton> Any shorthand for exposing all modules during dev?
19:23:10 <dcoutts_> and iirc, it's a corner case where building or using repl just skips it as a no-op
19:23:29 <dcoutts_> I think we've improved the error message in the dev version
19:24:14 <dcoutts_> Ashton: no, it doesn't know what they are
19:24:20 <S11001001> m3ga: It's in runST's argument type.  Namely, *forall* s.  You're constraining that `s', at all, so it can't unify.
19:24:40 <dcoutts_> Ashton: hope that helps
19:24:47 * dcoutts_ has to disappear
19:25:27 <Ashton> yes, it did.
19:25:28 <Ashton> Thank you.
19:25:45 * shachaf also has to disappear in a few moments, but what S11001001 said sounds
19:25:46 <shachaf> right.
19:26:14 <S11001001> m3ga: thank you for including the types of the functions you're using so I could quickly spot that :)
19:26:20 <shachaf> Why are you doing the primToST business?
19:26:49 <shachaf> ST s is an instance of PrimMonad, it looks like.
19:26:55 <m3ga> shachaf: to avoid using unsafePrimToIO
19:27:17 <shachaf> You could just have mkArray len x = runST $ do { marr <- newArray len x; unsafeFreezeArraymarr }
19:27:52 <shachaf> (And I think ST has a thing to do a final unsafeFreeze for you safely, or something like that.)
19:27:58 <shachaf> But maybe I'm missing the point here.
19:28:14 <flebron> So, if I want to make an "a" type variable inside a "where" of my function f :: a -> b, I need to use "f :: forall a. a -> b", and ScopedTypeVariables, correct? What if a has an Eq constraint in f, what's the syntax for that?
19:28:21 <m3ga> shachaf: i was missing the point, you we not.
19:28:41 <m3ga> yes, it i just drop the primToST it works. thanks shachaf and S11001001
19:29:06 <flebron> (If I say Eq a => forall a. a -> b, I get Ambiguous constraint `Eq a' At least one of the forall'd type variables mentioned by the constraint must be reachable from the type after the '=>'.
19:29:06 <shachaf> I need to go, good luck with the rest of it!
19:29:22 <S11001001> flebron: the constraint goes after the .
19:29:31 <stian> Just translated my python notebook playing with (super-simple) probability into Haskell. Like the Haskell version much better. Python: http://nbviewer.ipython.org/github/houshuang/math-with-ipython/blob/master/information/chapter-1.ipynb Haskell: http://nbviewer.ipython.org/github/houshuang/math-with-ipython/blob/master/information/chapter-1-hs.ipynb
19:29:46 <shachaf> flebron: forall is a binder -- it gives meaning to the "a"s inside its body.
19:29:55 <stian> (although I don't understand what is happening with the axes in the last graph)
19:29:55 <shachaf> So (forall a. ...) is like (\a -> ...)
19:29:57 <djahandarie> stolaruk, I joined #haskell.jp and you're not even in there! :p
19:30:07 * shachaf has a couple more minutes.
19:30:29 <shachaf> So if you say foo :: Eq a => (forall a. ...), those are two different "a"s.
19:30:43 <flebron> Ah, cool, thanks :) That worked.
19:30:48 <shachaf> It really means: foo :: forall a. Eq a => (forall a'. ...)
19:31:21 <shachaf> forall really behaves a lot like a lambda. That's the key to understanding it.
19:32:14 * shachaf really vanishes.
19:33:54 <stolaruk> djahandarie: Yeah I gave up on it completely.
19:36:02 <AshyIsMe> stian: woah ipython does haskell too?
19:36:24 <stian> AshyIsMe: It does now, thanks to agibiansky (and others)! :)
19:36:26 * hackagebot web-routes-happstack 0.23.6 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.23.6 (JeremyShaw)
19:36:26 * hackagebot web-routes-wai 0.23.0 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.23.0 (JeremyShaw)
19:36:33 <enthropy> AshyIsMe: it's a separate program that's not as polished as the original
19:39:15 <stian> enthropy: It's not really separate - IPython (which really needs to change its name) can communicate with a bunch of different kernels - there are lots of Julia notebooks for example. So with very little work, we get a ton of stuff for free (the nice interface, Markdown + MathJax for Haskell math enthusiasts, CodeMirror etc). But yeah, IHaskell is quite new, and there is a lot of potential for polishing (nice HTML representatio
19:39:15 <stian> ns of different Haskell types etc)
19:39:35 <SLi> Shocking. For my use case, Text.Regex.PCRE is 2.6x faster than haskell-re2.
19:39:56 <danilo2> Hello! Does anybody know how can we use Control.Monad.Logger inside a WriterT, such as `$(logDebug) "This is a debug log message"` would be equal to "tell" ? I think it is possible, but I cannot get it working
19:40:19 <danilo2> inside Writer, not WriterT, osrry
19:40:24 <enthropy> yes I have done a bunch of work on it
19:40:30 <enthropy> less than andrew of course
19:42:15 <enthropy> danilo2: if the documentation isn't helping, look at the template-haskell code after it's expanded to real code by using -ddump-splices?
19:45:58 <danilo2> enthropy: Its expanded to call to monadLoggerLog (function of MonadLogger monad) with some info about the position  (monadLoggerLog (Language.Haskell.TH.Syntax.Loc "Pass.hs" "main" "Main" (72, 7) (72, 15)) (Data.Text.pack "")  LevelDebug) . (id :: Data.Text.Internal.Text -> Data.Text.Internal.Text)
19:47:29 <AshyIsMe> enthropy: stian that looks really cool, cheers
19:48:00 <enthropy> danilo2: so check if the class that has monadLoggerLog has instances to work with Writer Text
19:48:43 <enthropy> maybe the instance is for something like  Writer [(Text,Loc)]
19:49:08 <bitemyapp> what's the syntax to get point-free from lambdabot?
19:49:17 <bitemyapp> querying the bot in private didn't work.
19:49:35 <danilo2> enthropy: Its got instance to work with WriterT only (http://hackage.haskell.org/package/monad-logger-0.3.1.1/docs/src/Control-Monad-Logger.html#logDebugS). Hmm I'm checking some ideas, brb
19:49:36 <enthropy> @pl f a b c d e = b a c e (d e e)
19:49:36 <lambdabot> f = flip flip join . ((flip . (((.) . ap) .)) .) . flip id
19:52:05 <Iceland_jack> 'flip flip join . ((flip . (((.) . ap) .)) .) . flip id' is perfectly clear
19:55:24 <stian> AshyIsMe and enthropy: Wrote it up for reddit: http://www.reddit.com/r/haskell/comments/1ua97u/really_simple_plotting_in_ihaskell/
19:59:33 <danilo2> enthropy: Hmm, here is sample code, that works in IO (http://lpaste.net/97913). Could you look at it please? I cannot get it working (there is a commented line, that I would love to make working). Maybe I'm tired and I overlooked something simple :(
20:00:24 <apples> @pl \a b -> b a
20:00:24 <lambdabot> flip id
20:00:45 <AshyIsMe> stian: nice, upvoted :)
20:06:38 <xpika> @pl (\(a1,b1) (a2,b2) -> (a:a2,b1+b2))
20:06:38 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,) . (a :)) . (+) . snd
20:08:35 <dhrosa> i feel like there's definitely a cleaner way with arrows to do that
20:09:59 <xpika> @pl (\(a1,b1) (a2,b2) -> (a1:a2,b1+b2))
20:09:59 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (:))
20:14:02 <randomclown> xpika: you probably want to use arrows
20:15:26 <roboguy_> @pl \(a, b) -> first (a:) . second (b+)
20:15:26 <lambdabot> uncurry ((. (second . (+))) . (.) . first . (:))
20:16:17 <roboguy_> I'd probably leave the lambda in
20:16:36 <randomclown> Something like: (a:) *** (b+)
20:17:10 <roboguy_> oh right, I forgot about ***
20:18:39 <orzo> Does cabal define preprocessor macros indicating what version was selected for package dependencies?  That would make it easier to support multiple versions
20:21:06 <geekosaur> yes, and that's the most common use of CPP
20:21:21 <orzo> oh, well, how do i use it
20:21:34 <orzo> i'm searching the web but haven't found information yet
20:21:36 * geekosaur does not remember offhand what they look like
20:21:58 <orzo> is it in the cabal user guide?
20:22:54 <xpika> @pl (\(a,b) -> (a:) *** (b+))
20:22:54 <lambdabot> uncurry ((. (+)) . (***) . (:))
20:23:37 <geekosaur> http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
20:23:41 <geekosaur> orzo ^^
20:24:16 <orzo> good deal thanks
20:25:40 <AshyIsMe> woah, doing `cabal install cabal-install` succeeds in installing but then `cabal --version` still says the old 1.16
20:25:48 <geekosaur> hash -r
20:26:00 <geekosaur> also check that you have $HOME/.cabal/bin in $PATH
20:26:15 <geekosaur> *before* wherever the old one was
20:26:16 <m3ga> AshyIsMe: you probably have the old version in the path before thw new one
20:26:51 <geekosaur> (shells remember where they found a program rather than look it up again every time; "hash -r" makes it forget and look again)
20:26:51 <AshyIsMe> ah ok
20:27:12 <AshyIsMe> yeah it must be the path issue
20:28:59 <AshyIsMe> cool that fixed it, cheers
20:29:08 <enthropy> danilo2: looks like you have to define your own instance of MonadLogger for it to be useful
20:29:21 <enthropy> my guess is that some package in the yesod stuff does such
20:30:38 <enthropy> all the instances of MonadLogger in the package either ignore the input, or they are the same as applying lift to the monad one layer into the stack
20:32:13 <danilo2> enthropy: It started working after defining instance "(MonadWriter String (WriterT w Identity), Monoid w) => MonadLogger (Writer w)" but its bad solution - I have to rethink all this solution
20:32:16 <danilo2> thank you
20:32:25 <enthropy> why is it bad?
20:33:20 <enthropy> it's better than an ordinary tell because you get the source location
20:34:30 <danilo2> enthropy: because there is no such instance for IO - for IO there is "runStdoutLoggingT", which is, I think a little nicer solution. But honestly I have to go to sleep, because its middle in the night here and I'm so tired I can tell stupid things :)
20:46:45 <AshyIsMe> hmm, after fixing my PATH will i need to do the ghc-clang-wrapper thing again?
20:49:25 <AshyIsMe> http://lpaste.net/97914
20:49:41 <AshyIsMe> im getting errors trying to install IHaskell (from the latest git repos)
20:49:57 <AshyIsMe> zeromq4-haskell is failing to configure
20:50:39 <enthropy> AshyIsMe: this means you need to install a C library. It can be done with brew apparently
20:50:42 <AshyIsMe> http://lpaste.net/97914
20:51:00 <AshyIsMe> yeah i just tried and it's already installed but not linked apparently
20:52:04 <enthropy> you can cabal install --extra-include-dirs=/somewhere/it/actually/ended/up
20:52:31 <tertl3> hello
20:52:54 <tertl3> did you ever mess with yesod web framework
20:53:57 <enthropy> AshyIsMe: but I would expect that brew would put headers in places that ghc can find
20:55:44 <dhrosa> is there a way to take a data  record in an IO, and replace one or two of its fields in a short way?
20:55:48 <AshyIsMe> they're in /usr/local/Cellar/zeromq/4.0...
20:56:01 <AshyIsMe> adding --extra-include-dirs and --extra-lib-dirs got slightly further
20:56:30 * hackagebot herringbone 0.0.5 - A library for compiling and serving static web assets.  http://hackage.haskell.org/package/herringbone-0.0.5 (hdgarrood)
20:56:39 <dhrosa> nvm found a different way to do this
21:01:56 <AshyIsMe> ah looks like i had to `brew link zeromq`
21:21:33 * hackagebot geodetic 0.1.1 - Geodetic calculations  http://hackage.haskell.org/package/geodetic-0.1.1 (TonyMorris)
21:23:37 <frewsxcv_> http://xkcd.com/
21:26:13 <HectorAE> ^^^^^^^
21:27:42 <maxiepoo> :(
21:29:05 <qrada> hey quick q, im using HUnit. I have a TestCase which is testing something that will "return' Maybe (Just a | Nothing).. I can test for (Just a), it works fine.. But when I substitute Nothing in the test case, I get all types of errors saying to add a type signature , and ambiguous type variable for assertEqual.. It's as if it's complaining that Nothing is not apart of Eq ??? confused.. Anyone have an idea?
21:29:44 <Cale> qrada: Probably it can't infer which type of Maybe you want
21:29:45 <maxiepoo> qrada: It doesn't know what type the Nothing is
21:29:55 <maxiepoo> > :t Nothing
21:29:57 <lambdabot>  <hint>:1:1: parse error on input `:'
21:30:00 <maxiepoo> :t Nothing
21:30:01 <lambdabot> Maybe a
21:30:04 <Cale> qrada: and indeed Maybe t is only an instance of Eq when t is as well
21:30:23 <maxiepoo> could be a Maybe (a -> b)
21:30:51 <qrada> ah hm.. so i need a specific type sig i imagine
21:31:16 <HectorAE> Who thinks that after that xkcd comic we're going to get a huge popularity boost?
21:31:19 <Cale> Yeah, that should help
21:31:27 <qrada> cool thanks folks
21:31:34 * hackagebot modulespection 0.1.0.7 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.0.7 (JonathanFischoff)
21:31:56 <Cale> HectorAE: I dunno, I'd expect that anyone who reads xkcd should already have heard of Haskell
21:32:28 <HectorAE> Probably not
21:32:38 <HectorAE> I mean, not all
21:32:45 <Cale> That joke would have worked better with Agda or something.
21:33:04 <tertl3> what is the general consensus about the fpcomplete web ide?
21:33:10 <Cale> (Or one of the other languages where you can do useful work just by typechecking.)
21:33:27 <Cale> tertl3: I don't know that there is a general consensus about it.
21:33:59 <Cale> I certainly haven't tried it to be able to form an opinion. Maybe if they came out with a one-time purchase desktop version, I'd be tempted to pick it up.
21:34:15 <maxiepoo> Cale: that's THE joke about agda right?
21:34:33 <maxiepoo> but nobody's heard of Agda
21:40:00 <Fuuzetsu> If nobody has heard of it, you wouldn't be discussing it right now
21:40:06 * Fuuzetsu wrote Agda today
21:40:32 <maxiepoo> people on #haskell don't count :)
21:40:36 <maxiepoo> or #coq
21:40:40 <maxiepoo> or #agda
21:40:46 <Fuuzetsu> that's a lot of people
21:40:46 <maxiepoo> or #lens
21:41:08 <HectorAE> I never heard of it
21:41:33 <maxiepoo> I don't have anything against agda, it's pretty awesome
21:42:05 <Kaidelong> code written in haskell has exactly one side effect
21:42:13 <Kaidelong> it builds a binary
21:42:26 <maxiepoo> but definitely very few people outside of the academic programming languages community have heard of it
21:42:42 <mgsloan> Kaidelong: With TH you can have far more side effects than that!
21:42:44 <Kaidelong> except when it doesn't compile
21:43:09 <Cale> Code written in Haskell has exactly one side effect: rendering its programmer incapable of going back to writing code in imperative programming languages.
21:43:21 <maxiepoo> Cale: exactly what I was about to say
21:43:23 <Kaidelong> eeeh
21:43:52 <Kaidelong> maybe imperative programming languages specifically but imperative programming you often end up doing in haskell
21:43:54 <maxiepoo> it's a highly dangerous side effect for a programmer's career!
21:44:27 <Clint> luckily i'm not a programmer
21:44:36 <Fuuzetsu> maxiepoo: It's not exactly aimed at people outside of the academic programming languages community
21:45:15 <maxiepoo> Fuuzetsu: yeah I was just saying xkcd isn't going to make a joke about it :)
21:46:00 <Fuuzetsu> Kaidelong: Often? Certainly not. I wrote something imperatively in Haskell the other day (I was using GLUT so had an IORef) and god damn it felt dirty; I don't think I'd be able to do more programs like that
21:47:41 <mgsloan> Fuuzetsu: Hmm, that's not true at all.  Much of the code I write in Haskell is rather imperative, but I still wouldn't use a different language.  As SPJ put it, it's the best imperative language
21:49:06 <HectorAE> But academic programming languages are the best languages
21:49:29 <HectorAE> If it's a pure popularity contest then people would say Java or C++ are the best
21:49:37 <HectorAE> Or *shudder* PHP
21:49:38 <Fuuzetsu> mgsloan: Why is it imperative? Why do you do it to yourself?
21:50:00 <Fuuzetsu> Of course this all depends on the age-old ‘what is imperative and what is functional?’ debate
21:50:11 <mgsloan> Fuuzetsu: I'm working on an application that uses a database and who's primary responsibility is to service an external web request
21:50:23 <Fuuzetsu> Okay, and?
21:50:42 <mgsloan> run ghc, work with processes, etc etc
21:50:50 <xpika> @pl (>>= (return . f))
21:50:51 <lambdabot> (f `fmap`)
21:50:57 <Fuuzetsu> There's the part that talks to the database, there's the part that does the web request and then there's everything else
21:51:05 <mgsloan> On the clientside, there's lots of imperative haskell because most of your code is manipulating the DOM
21:51:35 <maxiepoo> mgsloan: hey were you at seahug this summer?
21:51:36 <HectorAE> Integration of state into the core language is unnatural though
21:51:46 <mgsloan> maxiepoo: Yup!
21:51:53 <maxiepoo> you work at fpc?
21:51:56 <mgsloan> Yup!
21:52:03 <HectorAE> It lets you create runtime errors in what should be pure code
21:52:21 <Fuuzetsu> HectorAE: head []
21:52:27 <maxiepoo> you guys do haskell->js?
21:53:18 <HectorAE> Fuuzetsu, that's a compile-time error.
21:53:19 <mgsloan> Fuuzetsu: If you've got a program that just does computation, then yes, I agree, the thin shell of IO works beautifully.  However, if the main task of your program is integrating many external services, you're not going to be very pure
21:53:38 <mgsloan> maxiepoo: Yep, most of our JS is in haskell, compiled via Fay
21:53:47 <maxiepoo> oh nice
21:54:07 <Fuuzetsu> HectorAE: Hm? What language are we talking about?
21:54:48 <geekosaur> HectorAE: try it....
21:55:08 <maxiepoo> > head []
21:55:09 <mgsloan> maxiepoo: We're you the guy who was up here for an internship??
21:55:09 <lambdabot>  *Exception: Prelude.head: empty list
21:55:16 <maxiepoo> mgsloan: yea!
21:55:16 <mgsloan> *were
21:55:28 <mgsloan> Cool!
21:55:46 <maxiepoo> too bad the september one was canceled, that was the day before I left
21:56:06 <mgsloan> Darn!  Yeah, I'm thinking there needs to be a backup location
21:56:19 <mgsloan> December meeting was cancelled too
21:56:36 <HectorAE> Well we all know Prelude has problems with unsafe functions
21:56:42 <HectorAE> That's not the point
21:56:58 <Fuuzetsu> head is pure
21:57:12 <Fuuzetsu> pure does not mean total
21:57:13 <mgsloan> pure evil!
21:57:13 <maxiepoo> does FPC have an office in Seattle?
21:57:26 <HectorAE> I didn't say pure means total
21:58:02 <mgsloan> maxiepoo: Nah, there is no office.  snoyberg is in israel, chrisdone is in italy, etc
21:58:27 <maxiepoo> you're like an international team of super-spies
21:58:38 <Fuuzetsu> No, of course not, but you said ‘It lets you create runtime errors in what should be pure code’; you can create runtime errors without state as we just showed so I don't see what you were trying to say
21:58:46 <maxiepoo> oh I didn't know chrisdone was there
21:59:10 <mgsloan> Something like that!
21:59:20 <Fuuzetsu> maxiepoo: it's the FP branch of NSA
21:59:38 <geekosaur> heh
21:59:48 <HectorAE> Okay I get that.
22:02:38 <ParahSailin> im pretty sure seq could be said to have side effects
22:03:44 <enthropy> ParahSailin: seq is just like pattern matching the outer-most constructor, which makes that not a very useful thing to say
22:03:56 <enthropy> case expressions would have side effects too then
22:04:03 <maxiepoo> what about http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Exception.html#v:evaluate
22:04:05 <maxiepoo> ?
22:04:15 <maxiepoo> I used it and I want to know how bad I should feel
22:04:59 <ParahSailin> enthropy: how would you write seq in terms of pattern matching or case statement
22:05:16 <dario`> @src seq
22:05:16 <lambdabot> Source not found. :(
22:05:29 <dario`> hm, would've been too easy
22:05:31 <maxiepoo> @src evaluate
22:05:31 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:05:31 <ParahSailin> yeah its an internal primitive
22:05:39 <enthropy>  seq :: Maybe a -> b -> b; seq Nothing b = b; seq Just{} b = b
22:05:55 <enthropy> and have one like that for every type you use it at
22:06:21 <ParahSailin> wouldnt the analogue be a bangpattern?
22:06:37 <enthropy> bangpattern is just a nicer way to write seq
22:07:30 <ParahSailin> so seq isnt exactly like that above example, it does something magical you can't express in "pure" code
22:07:50 <bitemyapp> arrdem: another soul converted! presented on and taught some Haskell today at the Clojure meetup.
22:08:26 <arrdem> bitemyapp: haha nice
22:08:34 <mgsloan> ParahSailin: Sounds to me like it could be made into a typeclass
22:08:49 <ParahSailin> and it has side effects that cannot be expressed in terms of the type system
22:08:52 <bitemyapp> arrdem: the person I did some 1:1 teaching with is a regular in #clojure.
22:08:54 <Fuuzetsu> I thought there was one for DeepSeq
22:08:59 <bitemyapp> ParahSailin: are you sure?
22:09:03 <mgsloan> Yeah, NFData
22:09:07 <Fuuzetsu> oh, hoogle changed its looks
22:09:22 <geekosaur> once upon a time, seq *was* a typeclass, no? (Eval, I think?)
22:09:29 <ParahSailin> dunno, im just thinking aloud
22:09:56 <geekosaur> someone decided that since you can't express seq of a function that way, it had to be a primitive
22:10:09 <geekosaur> (or of a polymorphic function, or something like that)
22:11:51 * enthropy writes class Seq2 a where seq2 :: a -> b -> b; instance Seq2 a where seq2 = seq
22:12:10 <zRecursive>  Why is Math called "the science of pattern" ?
22:12:31 <ChongLi> bitemyapp: I liked Clojure for a while, but then I started to miss types and came back
22:12:43 <ChongLi> I continue to follow it though
22:13:34 <tpsinnem> i'm reading the launchbury & peyton jones ST/IO paper 'lazy functional state threads' (http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.3718&rep=rep1&type=pdf) and i'm confused by figure 2 on page 8, 'semantics of state combinators' -- should there be a ρ (rho) also on the left-hand-sides of the equations for runST etc?
22:14:21 <HectorAE> zRecursive, because it is.
22:15:37 <zRecursive> HectorAE: IIRC, the Mach is called science to describe the relation between variables before
22:16:17 <HectorAE> wat
22:17:15 <zRecursive> then what is "pattern" here ?
22:18:15 <HectorAE> Relationships between variables?
22:19:07 <maxiepoo> mgsloan: Do you guys use any FRP stuff in your Fay code or would it be too slow for a responsive website?
22:20:38 <mgsloan> maxiepoo: We've got variables that have subscribers, but not "proper" FRP
22:21:20 <mgsloan> So, input fields usually are just attached to a variable that can be subscribed to by others
22:22:25 <maxiepoo> any of that open source?
22:23:21 <mgsloan> It needs to be cleaned up a bit yet
22:24:08 <mgsloan> Also, fay doesn't have a good way for a library to specify extra js that it depends on
22:24:38 <mgsloan> Not that this is a showstopper, it just makes releasing fay libs that have additional js a little less convenient
22:27:29 <mgsloan> We're definitely in favor of releasing as much stuff as makes sense, but wrapping up such things nicely takes time
22:27:59 <mgsloan> It'd be great to benefit from external contribution, though
22:28:15 <maxiepoo> yeah definitely
22:29:13 <mgsloan> Are people writing lots of fay apps?  Maybe it's a chicken-and-egg problem of libraries, but I'm not seeing a lot of demand atm
22:30:15 <maxiepoo> well that's why I asked, because I was curious to see some fay-specific code
22:31:29 <mgsloan> Hmm, yeah, maybe it is a chicken-and-egg problem!
22:32:46 <maxiepoo> I'm curious to see if programming the Fay monad just looks like JS written in do notation
22:34:29 <mgsloan> Well, typically it looks more like writing haskell without typeclasses, and access to the DOM
22:34:44 <mgsloan> I imagine with some cleverness you could make it look syntactically more like JS
22:35:06 <maxiepoo> not that I would want to!
22:38:09 <carter> dcool
22:38:24 <carter> btw: i can't seem to view pages on travis,
22:38:32 <carter> could someone tell me what the status of https://travis-ci.org/wellposed/hOpenBLAS is right now
22:38:34 <carter> ?
22:39:56 <maxiepoo> it's started
22:40:04 <maxiepoo> 3:45 in
22:41:11 <carter> wow, i guess no ones awake
22:45:22 <carter> anyone?
22:47:10 <maxiepoo> carter: I said it's started
22:47:14 <maxiepoo> what do you want to know?
22:48:55 <maybefbi> What if in future the type system got so advanced that typed code is indistinguishable from untyped code, sideeffecting and mutable state everywhere because everything is some futuristic MVar inside an IO monad. What if compilers automatically convert C# to Haskell ?!!
22:49:40 <Pupnik_> isnt that the same as using a dynamic language?
22:50:33 <maybefbi> Pupnik_: yeah
22:50:39 <brokenzebra> anyone here understand hindley-milner?
22:51:06 <jrw> brokenzebra: probably many people. what is your question?
22:51:26 <brokenzebra> well in the context of hm, what exactly is a free var?
22:51:31 <ChongLi> hey, when I get an error from cabal-install that a given package may be broken by the reinstall
22:51:45 <ChongLi> (I'm specifying a list of packages to install all at once)
22:51:45 <maybefbi> ChongLi: Use sandboxes
22:51:49 <brokenzebra> in hask, every polymorphic type has an implicit 'forall' behind it
22:52:01 <ChongLi> how do I find out which package is causing the reinstall?
22:52:20 <brokenzebra> eg, :t id :: a -> a which is actually '\forall a . a -> a'
22:52:41 <brokenzebra> so i guess in the context of hm, how is '\forall a . a -> a' different from 'a -> a'
22:53:01 <maybefbi> ChongLi: hmm use the reverse dependency search on each package, and then see if 2 packages depend on the same parent but of different versions
22:53:11 <brokenzebra> s/$/?/g
22:53:14 <Fylwind> Eduard_Munteanu: thanks for the help btw, your idea does actually work :3  Show (f (Fix f)) => Eq (Fix f) with Undecidable on
22:53:32 <ChongLi> maybefbi: what command is that?
22:53:34 <jrw> brokenzebra: are you familiar with system F?
22:53:46 <jrw> aka polymorphic lambda calculus
22:53:48 <brokenzebra> jrw: heard about it in some monad reader issue
22:54:28 <jrw> brokenzebra: ok. well maybe let's do it this way. imagine a version of haskell or ML without type inference, for a second.
22:54:32 <maybefbi> ChongLi: Use this: http://packdeps.haskellers.com/reverse/Cabal
22:54:39 <jrw> how should I write down a polymorphic function in this language?
22:54:59 <jrw> one way to do it is to introduce notation for binding type variables in side an expression
22:55:00 <brokenzebra> okay, it just clicked
22:55:19 <ChongLi> maybefbi: thanks
22:55:28 <jrw> brokenzebra: sweet. I didn't even explain anything!
22:55:34 <brokenzebra> 'a -> a' is a monotype, eg the lambda calc counterpart to a subscripted variable in analysis
22:56:07 <jrw> brokenzebra: I didn't really follow that, but sure.
22:57:30 <ChongLi> maybefbi: can I have a separate cabal config for each sandbox?
22:57:55 <ChongLi> like some with library profiling and some without
22:58:11 <maybefbi> ChongLi: yes
22:58:20 <brokenzebra> jrw: so the 'a' in the a->a monotype is 'free', right?
22:58:23 <ChongLi> does it just go in .cabal-sandbox/config ?
22:58:38 <jrw> brokenzebra: it really depends on your notation
22:59:09 <jrw> brokenzebra: in haskell, there are no free type variables, as you mentioned.
22:59:22 <GhostfromTexas> http://xkcd.com/1312/   :D
23:00:00 <jrw> so suppose we don't have type inference. let's use \ to mean lambda (ie, introduce variables) and /\ to introduce *type* variables. then the polymorphic identity function would be /\a.\x:a.x
23:00:23 <jrw> that thing has type (forall a. a)
23:00:40 <dhrosa> @pl liftM (length . show) (return 0)
23:00:40 <lambdabot> return (length (show 0))
23:00:46 <dhrosa> o
23:01:06 <dhrosa> @pf liftM (length . show) (return 0)
23:01:06 <lambdabot> Maybe you meant: pl bf
23:03:44 <jrw> no free type variables any where. now let's do polymorphic application: (/\a.\x:a.(/\b.\f:(a->b).f x)) : forall a. a -> (forall b. (a -> b) -> b)
23:04:22 <jrw> now think about the inner parenthesized expression. it refers to a, which was bound in the outer scope
23:04:28 <carter> woot
23:04:45 <jrw> so if we just look at that expression: (/\b.\f:(a->b).f x), it has a free type variable a.
23:05:18 <ChongLi> ahhh, using sandboxes for applications works really well, this is nice :)
23:06:03 <dhrosa> making infinitely recursive  file systems is easier to reason about in haskell :D
23:06:35 <maybefbi> ChongLi: how do you enable library profiling currently?
23:34:06 <carter> victory! https://travis-ci.org/wellposed/hOpenBLAS/builds/16303060
23:35:38 <Fuuzetsu> where are some Category instances I could look at?
23:37:00 <Fuuzetsu> except the default one for (->) that is
23:37:59 <erisco> so damn cold here right now... -22c or -7.6f
23:38:48 <Polarina> erisco, decide, which is it?
23:38:51 <mgsloan> Fuuzetsu: Only one I've seen in the wild is fclabels: http://hackage.haskell.org/package/fclabels-2.0.1/docs/src/Data-Label-Poly.html#Lens
23:39:28 <Fuuzetsu> pff, I was certain that if I get any examples, they'll have something to do with lenses
23:39:35 <mgsloan> Aye
23:40:01 <Polarina> Category isn't cool enough for lenses.
23:40:07 <mgsloan> In general, Control.Category is really awkward to work with
23:40:11 <fabe> hi im learing haskell and seem to stuck on this noob problem http://pastebin.com/5v475xuE
23:40:12 <mauke> The paste 5v475xuE has been copied to http://lpaste.net/97917
23:40:13 <fabe> any help?
23:40:18 <Twisol> Doesn't pipes have like five Category instances or something?
23:40:29 <Tekmo> Yes
23:40:31 <erisco> lol my system temps are markedly cooler
23:40:37 <Twisol> oh hi. Speak of the devil. :P
23:40:40 <Tekmo> :)
23:40:41 <Fuuzetsu> fabe: you're missing some parenthesis on the last line
23:40:42 <erisco> down about 4c
23:40:42 <Polarina> fabe, putStrLn ("some bytes: " ++ bytes16str)
23:41:21 <fabe> that was just to easy ...
23:41:28 <fabe> *shakes head*
23:41:35 <Polarina> fabe, your last expression is equivalent to `(putStrLn "some bytes: ") ++ bytes16str'. That is causing the compiler to cry.
23:41:36 <Tekmo> Twisol: See the `Pipes.Core` module which goes into detail about all five categories
23:41:53 <Twisol> Fuuzetsu: ^
23:41:57 <Fuuzetsu> alright
23:42:07 <erisco> putStrLn $ "some bytes: " ++ bytes16str
23:42:08 <Fuuzetsu> @package pipes
23:42:08 <lambdabot> http://hackage.haskell.org/package/pipes
23:42:15 <fabe> thx Polarina
23:43:29 <erisco> putStrLn . (++) "some byteS: " $ bytes16str
23:46:06 <Fuuzetsu> at least use the operator section
23:50:30 <augur> Cale: hahaha! i've figured it out! i've figured out what makes codata in a type theoretic sense!
23:50:32 <augur> ahahaha!!!
23:50:34 <augur> :DDD
23:51:00 <augur> or at least ive figured out a flavor of codata :x
23:53:56 <augur> namely, strictly infinite codata
23:54:20 <augur> the intermediate case of potentially finite codata is trickier
23:55:00 <augur> it can probably be achieved with the musical stuff that agda has
23:55:49 <hamid> :t unfoldr
23:55:50 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
23:57:06 <maxiepoo> augur: musical?
23:57:27 <augur> maxiepoo: agda has some kind of notation for codata that happens to use musical notation
23:57:32 <augur> sharps and flats and stuff
23:57:35 <maxiepoo> oh cute
23:58:16 <augur> maxiepoo: http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Codatatypes
23:59:07 <hamid> I need an example for unfoldr would someone please give me one?
23:59:34 <Tekmo> > unfoldr (\n -> Just (n, n + 1)) 0
23:59:35 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
23:59:37 <maxiepoo> but you can't mix inductive/coinductive properly with that iirc? you can't have trees with finite breadth and infinite depth?
23:59:42 <hamid> Tekmo, thanks
23:59:45 <augur> i was literally about to do that same one, Tekmo
23:59:46 <augur> :D
23:59:47 <Tekmo> hamid: You're welcome
23:59:48 <Tekmo> :)
