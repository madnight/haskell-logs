00:00:02 <ChongLi> SrPx: well, there's limits to the version, specified as a range
00:00:12 <c_wraith> jle`: evaluating the constructor actually can matter quite a lot, because it means that seq can hook a lot of evaluations to the constructor evaluation
00:00:15 <ChongLi> and we generally encourage people to use semantic versioning
00:00:22 <jle`> c_wraith: yeah
00:00:27 <jle`> well
00:00:30 <jle`> so much for the idea
00:00:31 <ChongLi> SrPx: http://semver.org/
00:00:55 <SrPx> ChongLi: also the sandboxing approach is limited per project... you can only have one version of each library in a sandbox, so if library A requires library C 1.0 and library B requires library C 2.0, you cannot use both library A and library B in your application. With npm you can, as libraries do not pollute the module namespace of things that depend on them.
00:01:19 <ChongLi> SrPx: yeah, that's a problem with ghc
00:01:34 <ChongLi> there's supposed to be a project to fix it
00:01:43 <ChongLi> but I haven't heard much about that
00:01:46 <Tekmo> c_wraith: Yeah, I think Joachim was the one working on `coerce`
00:01:58 <Tekmo> c_wraith: I'd be fine with a manual approach
00:02:05 <ChongLi> Tekmo: what about type roles?
00:02:27 <c_wraith> type roles are a significant part of the coerce mechanism
00:02:31 <Tekmo> ChongLi: I remember my only objection to type roles was they weren't implemented using {-# PRAGMAS #-}
00:02:44 <ChongLi> to solve the GeneralizedNewtypeDeriving + TypeFamilies unsoundness
00:02:52 <c_wraith> coerce uses a type class that is auto-generated for data types with the correct role
00:02:59 <ChongLi> ahhhh
00:02:59 <Lamen> (sorry for the interruption) why I get "hGetBufSome: resource vanished" everytime I run hackage-mirror, just curious. :-)
00:03:23 <Tekmo> Sounds like a lazy IO problem
00:03:32 <ChongLi> is there going to be a more general way to automatically generate type classes?
00:03:40 <Tekmo> That or it might be a connection problem
00:04:00 <ChongLi> or automatically generate modules the way cabal does with static resources :)
00:04:09 <ChongLi> first-class modules!
00:04:17 * hackagebot yamemo 0.6.0 - Simple memoisation function  http://hackage.haskell.org/package/yamemo-0.6.0 (NobuoYamashita)
00:04:20 <c_wraith> ChongLi: No idea..  but Typeable is also going to be auto-generated, so hopefully there will be some shared code
00:04:43 <Lamen> He's got the same problem: http://tinyurl.com/pjxbpdf
00:05:04 <ChongLi> hmmm
00:05:16 <ChongLi> and some form of Hashable? :)
00:05:25 <ChongLi> I guess there's just so many ways to hash things
00:05:49 <SrPx> ChongLi: ;c
00:05:53 <Tekmo> I hear people complain about a default `Hashable`.  I forgot the exact reason why
00:06:09 <ChongLi> well, it would make Haskell more like Java :)
00:06:22 <c_wraith> hashing has a bunch of different purposes, and a hash that is appropriate for one use is totally inappropriate for others
00:06:35 <c_wraith> Blessing one particular approach would make it be likely to be misused
00:06:44 <Tekmo> c_wraith: So are you saying that `Hashable` should not be a type class?
00:06:56 <c_wraith> much like java's hashcode() is often misused
00:07:03 <jle`> is a Stream ( a list with no Nil ) considered a Machine?
00:07:06 <ChongLi> couldn't you make the same argument for `Ord`?
00:07:20 <c_wraith> ChongLi: and many people have.
00:07:23 <ChongLi> there's so many different ways to order things
00:07:36 <Tekmo> jle`: Depends on how a Machine is defined
00:07:41 <ChongLi> this is actually one of Bob Harper's criticisms of Haskell
00:07:51 <ChongLi> the idea that type classes are canonical
00:08:03 <Tekmo> Well, this is also the canonical counterargument, too
00:08:12 <jle`> Tekmo: it's an Auto with no input? or an Auto () a ?
00:08:16 <Tekmo> You wouldn't want a `Set` with inconsistent `Ord` instances
00:08:40 <ChongLi> it's the same deal with `HashSet` and `Hashable`
00:08:40 <c_wraith> GHC has bugs that let you construct a set with inconsistent Ord instances
00:08:54 <c_wraith> It is *very* bad when that happens!
00:08:58 <jle`> i guess a stream is a Moore machine?
00:10:03 <Tekmo> jle`: Is there any reason you prefer to use an `Auto` over a `Stream`?
00:10:11 <johnw> if aynone wants to bulk-download all 82 of the Catster videos in a 2.4G file: http://ftp.newartisans.com/pub/catsters.tar.gz
00:10:26 <jle`> Tekmo: oh i'm writing a post building up to Auto
00:10:39 <jle`> and starting with Stream
00:11:06 <ChongLi> johnw: people don't know about youtube-dl?
00:11:20 <johnw> maybe they do, maybe they don't :)
00:11:27 <simpson> Or get-flash-videos. >:3
00:15:19 <ChongLi> I guess with homotopy type theory we can have types for hash functions and prove their equivalences
00:15:32 <ChongLi> and so every unique hash function would get its own type
00:15:46 <ChongLi> and then you wouldn't have the inconsistency issue
00:16:15 <shachaf> If F -| G -| F, does that tell us anything interesting about F and G?
00:16:36 <jle`> although i guess Stream Integer isn't really a Moore machine because the set of states is not finite?
00:16:48 <johnw> aren't they isomorphic then?
00:16:59 <shachaf> ?
00:17:03 <johnw> ok, maybe not
00:17:12 <ChongLi> and in HoTT, we can treat isomorphism as equivalence
00:17:26 <ChongLi> the univalence axiom :)
00:17:29 <Tekmo> I thought the rule was that
00:17:35 <Tekmo> isomorphism is isomorphic to equivalence
00:17:48 <dleedev> johnw: what are the catsters videos about?
00:17:54 <johnw> category theory mostly
00:17:56 <ChongLi> equality is equivalent to equivalence
00:18:22 <ChongLi> there's a bunch of ways of stating it
00:18:48 <ChongLi> the key is that isomorphism and equivalence are defined in a mutually recursive fashion, all the way up to infinity :)
00:19:57 <ChongLi> "if you tell a lie, support it by an even bigger lie, continue on up to infinity and you're good"
00:20:00 <ChongLi> or something like that
00:20:49 <ChongLi> it's somewhat analogous to the infinite tower of universes of types
00:21:10 <rien> if someone already understands monads, does it become easier to understand CT? or even useful?
00:21:46 <shachaf> What does it mean to understand monads?
00:21:57 <ChongLi> what does it mean to understand anything?
00:21:59 <rien> be able to use them in code
00:22:04 <rien> to one's advantage
00:22:12 <ChongLi> you can use a lot of things without understanding them :)
00:22:14 <shachaf> In Haskell, I guess.
00:22:20 <shachaf> Probably not much.
00:22:28 <rien> right, I stand corrected, that would have been a better way to phrase it :)
00:22:32 <jle`> i don't think practically using monads in haskell helps you understand CT at all
00:22:47 <johnw> yeah, I agree jle`
00:22:47 <shachaf> It isn't very useful, at any rate.
00:23:01 <ChongLi> the best thing I can say is that if Haskell teaches you one thing, it's that anything can be a value
00:23:04 <rien> but if I then study CT will it help me in turn write better monadic code?
00:23:04 <Tekmo> rien: Well, it helps a little in that it gives you an additional example of a category, the Kleisli category
00:23:18 <ChongLi> not just that which is represented directly as a bit pattern in memory
00:23:25 <shachaf> Two additional examples!
00:23:26 <Tekmo> rien: Sometimes, yes
00:23:30 <ChongLi> and once you've accepted the idea of anything as a value
00:23:44 <shachaf> Probably not.
00:23:46 <sclv> no the univalence axiom is equiv is eqiv to equality
00:23:52 <Tekmo> rien: However, programming in Haskell more will probably give you bigger gains
00:24:05 <sclv> you're changing the notion of equality to be bigger/"smoother"
00:24:20 <johnw> rien: have you studied type theory?  I think that will give more bang for the buck in terms of Haskell improvement
00:24:22 <Tekmo> rien: Haskell is like a lot of other programming languages: you need to code in it more to learn idioms
00:24:23 <ChongLi> sclv: ahh, yes
00:24:25 <rien> Tekmo: what's special about the kleisli category?
00:24:26 <shachaf> (The Kleisli category and the Eilenberg-Moore category.)
00:24:40 <Tekmo> rien: It's just another example of a category.  That's all that I meant
00:24:53 <sclv> + you can always send equals to equiv. univalence just says you can go the other way too
00:25:06 <ChongLi> the idea of types as paths and homotopies between paths and so and so forth
00:25:13 <ChongLi> up to higher and higher homotopies
00:25:26 <sclv> the key in understanding it is for me is don't start with univalence. start with a general notion of equality having constructors besides refl
00:25:41 <sclv> or just start with a groupoid structure on types and see where it takes you
00:25:48 <sclv> no types aren't paths
00:25:49 <sclv> types are spaces
00:25:56 <ChongLi> oh right
00:25:57 <sclv> equalities are paths
00:26:01 <ChongLi> yeah
00:26:13 <ChongLi> I need to review all this stuff
00:26:26 <Tekmo> So what would be the most direct application of homotopy theory to programming?
00:26:36 <Tekmo> *homotopy type theory
00:26:41 <ChongLi> Tekmo: there's a set of slides on /r/haskell right now
00:27:07 <Tekmo> ChongLi: I don't see it
00:27:19 <ChongLi> http://www.reddit.com/r/haskell/comments/1vlc9s/darcs_as_a_higher_inductive_type/
00:27:52 <Tekmo> Oh, I didn't know that was related to homotopy type theory.  I'll read it
00:28:10 <sclv> shachaf: i know a name for F |- G |- F but not much in the way of special properties other than those you can just "read off" from the construction itself: http://ncatlab.org/nlab/show/Frobenius+functor
00:28:33 <shachaf> sclv: Ah, thanks.
00:28:42 <ChongLi> Tekmo: I found the slides pretty opaque, going forward
00:28:48 <ChongLi> I want the talk to go with them :)
00:29:18 <shachaf> Not much, indeed.
00:30:34 <sclv> also as per http://ncatlab.org/nlab/show/adjoint+triple (of which this is a special case) you get a monad and a comonad out of it that are themselves adjoint in some sense
00:31:06 <ChongLi> sclv: so with HoTT could we define a type for some particular set of hash functions and then compute all the paths between them?
00:31:35 <sclv> well "compute" is a bit strong
00:32:03 <Tekmo> So this is a specific application, but I'm sort of interested in a "bigger picture" explanation
00:32:05 <ChongLi> well, what if each is defined along with a path to a canonical one?
00:32:08 <sclv> you have funext so if you have two functions Int -> Int you could theoretically prove they are exensionally equal
00:32:25 <sclv> tekmo then read the intro to the book. its v. accessible.
00:32:37 <ChongLi> FSVO accessible :)
00:32:55 <ChongLi> and watch Bob Harper's lectures
00:32:57 <sclv> but honestly spending a fair amount of time with ch 2 is the best way to actually see some deeper stuff
00:33:01 <shachaf> sclv: Oh, this explains some of the behavior of (e,) and (e->) in Haskell.
00:33:25 <sclv> it does?
00:33:39 <sclv> oh right
00:33:41 <sclv> hom-set
00:33:46 <ChongLi> http://www.cs.cmu.edu/~rwh/courses/hott/
00:33:54 <sclv> since they're iso, you have adjoints on both sides
00:33:57 <shachaf> Well, that's the only adjunction we get in Haskell.
00:34:00 <sclv> hence state and costate, etc.
00:34:17 <ChongLi> that lecture series was really good for me
00:34:20 * hackagebot hPDB 1.1.1 - Protein Databank file format library  http://hackage.haskell.org/package/hPDB-1.1.1 (MichalGajda)
00:34:28 <ChongLi> it starts all the way from first principles of IPL
00:35:04 <Tekmo> I guess my first question is whether homotopy type theory is of more interest to language implementors or library writers (or both?)
00:35:46 <ChongLi> I'd probably say both
00:36:02 <sclv> i'd say neither!
00:36:04 <ChongLi> until we have some magical HoTT language that doesn't require us to understand HoTT in order to use it
00:36:19 <sclv> its of interest to mathematicians and people interested in PL theory
00:36:29 <sclv> and people interested in developing theorem provers
00:36:39 <ChongLi> you don't think we'll have a language based on HoTT?
00:36:41 <sclv> or rather its useful to them at the moment and nobody else
00:36:49 <Tekmo> sclv: I'm interested in future applications
00:36:50 <sclv> it is interesting to many people, myself included
00:37:11 <ChongLi> Bob Harper's primary interest in it is in discovering a machine implementation of it
00:37:14 <sclv> well eventually we'll get better dependently typed languages out of it.
00:37:22 <sclv> right, but not necessarily to turn it into a language!
00:37:30 <sclv> just to "demonstrate it computes" at first
00:37:37 <sclv> since that's a natural constructivist thing to want to do
00:37:44 <ChongLi> well, that's up to implementers
00:37:55 <ChongLi> he's satisfied as an academic :)
00:38:00 <sclv> i mean unless you think you want to work on agda or write a better agda
00:38:06 <sclv> HoTT will _not_ be practically useful to you.
00:38:14 <sclv> if you learn it it may make you better _at_ agda
00:38:18 <ChongLi> yeah, a better agda
00:38:27 <sclv> because it helps reshape your understanding of what dependent types are "all about"
00:38:32 <ChongLi> one that infers my entire program from the types :)
00:38:35 <sclv> no
00:38:47 <sclv> it has no suggestions about how to make things better in terms of tactics
00:38:53 <sclv> or how to make compilers more clever
00:38:57 <sclv> or see things more automatically
00:39:09 <sclv> one day using ideas from it somebody might come up with such applications
00:39:12 <sclv> but nobody is working on that
00:39:17 <ChongLi> well, what else are we going to do with all these newfound notions of equivalence?
00:39:22 <sclv> use them manually
00:39:25 <sclv> to prove things about math
00:39:32 <sclv> in new ways
00:39:33 <ChongLi> hmmm
00:39:35 <sclv> that's what's happened so far
00:39:42 <sclv> in the future, maybe other things will happen
00:39:42 <ChongLi> proofs are programs :)
00:39:46 <sclv> but not only are they not there yet
00:39:54 <sclv> but nobody is even working on them
00:40:17 <ChongLi> it's pretty early to say that
00:40:18 <sclv> but one of the insights of HoTT is in fact that not all programs are proofs (or rather, not all types are propositions)
00:40:23 <Tekmo> So what's the point of implementing something in a machine if you don't automate anything?
00:40:41 <sclv> to verify it!
00:40:53 <ChongLi> automatic verification
00:40:55 <sclv> agda has no tactics, although it does fill a few holes for you, on occasion
00:40:58 <Tekmo> Ok, so automating verification is an application.  That's good
00:41:10 <Tekmo> I can dig that
00:41:19 <sclv> well before you can verify something you have to state it
00:41:30 <sclv> HoTT is at the stage where it is maybe going to help us state things better
00:41:40 <ChongLi> and that's really useful
00:41:41 <sclv> verifying them isn't hard once we know what we're doing
00:42:01 <sclv> right i'm just encouraging realism about where the research is at and what its focusing on.
00:42:07 <sclv> at the moment
00:42:16 <ChongLi> and I'm encouraging wild-eyed speculation!
00:42:22 <sclv> like here's a current problem
00:42:47 <sclv> known implementations of dependent pattern matching, like in agda and coq, don't work correctly with univalence.
00:42:56 <sclv> they basically assume "axiom k"
00:43:04 <Tekmo> I'm with ChongLi.  I'm more interested in wild-eyed speculation
00:43:12 <ChongLi> :)
00:43:18 <sclv> so how do we even make programming in HoTT as easy as programming in agda already is?
00:43:42 <sclv> we need to rework our systems for pattern matching to use safe elimination rules, and figure out what those are in general
00:43:50 <sclv> that's the stage we're at.
00:43:54 <ChongLi> ahhh
00:44:10 <ChongLi> where does totality come into the picture?
00:44:22 <ChongLi> do you think it'll ever be practical to work in a total language?
00:44:28 <ChongLi> for everything, not just proofs
00:44:38 <sclv> HoTT doesn't have anything to address that at the moment
00:45:00 <ChongLi> I thought the main limitation is the richness of your type system
00:45:03 <sclv> another line of research would be trying to connect the work there to work on various corecursion/codata systems
00:45:20 <sclv> type systems can be "rich" in many ways, often contradictory.
00:45:41 <ChongLi> i.e. we know with dependent types we can clear up the issue of a lot of Haskell's partial functions
00:45:49 <sclv> like system F and dependent type theories (HoTT included) are both more expressive in some ways and less expressive in others
00:46:01 <sclv> system f gives you impredicative polymorphism
00:46:10 <sclv> but you lose other stuff that you get in full dependent type theory
00:46:39 <ChongLi> you don't have impredicative polymorphism in ITT/ETT?
00:46:48 <sclv> nope, its unsound
00:46:57 <ChongLi> very interesting
00:47:24 <sclv> there's research on introducing limited or different notions of it
00:48:40 <sclv> i ultimately suspect that "practical programming" with dependent types will end up with an unsound, but practical type system.
00:48:48 <sclv> no more unsound than haskell's i mean
00:49:03 <ChongLi> hmmm
00:49:12 <sclv> but nonetheless less "true" than a mathematician would demand to verify a proof
00:49:24 <sclv> that's e.g. the idris approach
00:49:26 <ChongLi> another thing I would like to see is magical strictness inference :)
00:49:44 <sclv> we do have magical strictness inference in ghc
00:49:59 <sclv> it could be better, but the strictness analyzer is a key part of the optimization pipeline already
00:50:09 <ChongLi> right, but it's not at the point where we can take strictness annotations right out of the language
00:50:35 <sclv> right
00:50:45 <sclv> but they are often used when you want to _change_ inferred behaviour
00:50:57 <ChongLi> and then, you extend that even further and say
00:50:59 <sclv> not just because the inference system is inadequate
00:51:08 <ChongLi> "what about magical parallel evaluation inference"
00:51:11 <ChongLi> implicit parallelism
00:51:14 <sclv> of course you can't have that
00:51:16 <sclv> we tried
00:51:18 <sclv> it sucked
00:51:34 <ChongLi> there's a language out there that tries to do it
00:51:37 <ChongLi> ParaSail
00:51:46 <ChongLi> I don't know if it sucks or not
00:52:11 <ChongLi> I think it doesn't try to do inference, actually
00:52:12 <sclv> you can have limited blocks where you ask to parallelize "cleverly"
00:52:25 <ChongLi> it just has parallelism as the default semantics for everything
00:52:26 <sclv> the problem is it isn't always a win
00:52:36 <sclv> so you need control one way or the other
00:52:52 <sclv> where we could get better is in breaking down the compile/runtime barrier.
00:52:53 <ChongLi> and then gives you the option to annotate things where it doesn't make sense
00:53:15 <sclv> so you have JIT style paths that can be switched between based on runtime behavior
00:53:19 <sclv> but that's a different school of compiler architecture
00:53:56 <ChongLi> oh, and what about the old dream of automatically transforming a tree-like process into a flat one for easy parallel allocation?
00:54:00 <ChongLi> I forget the wording
00:54:32 <ChongLi> generalized nested data parallelism?
00:59:11 <bernalex> doesn't mighttpd have ssl support?
01:03:11 <dleedev> johnw: are your catsters videos better quality that the ones on youtube?
01:17:14 <bernalex> can someone link me some js made by haste and/or ghcjs? curious as to what it looks like
01:17:19 <bernalex> haskell src is interesting as well
01:18:29 <bernalex> looking at https://github.com/RudolfVonKrugstein/jshaskell-blog/tree/master/4_Pong/ now
01:24:23 * hackagebot conduit 1.0.11 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.11 (MichaelSnoyman)
01:38:39 <lieven_> is there an idiomatic way to get every second element of a list that is reasonably efficient?
01:39:12 <Fuuzetsu> lieven_: Using a better data structure is probably what you need.
01:39:32 <lieven_> good point
01:39:41 <dhrosa> > chunksOf 7 [1..10]
01:39:42 <lambdabot>  [[1,2,3,4,5,6,7],[8,9,10]]
01:39:45 <dhrosa> oops
01:39:47 <dhrosa> > chunksOf 1 [1..10]
01:39:48 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10]]
01:39:52 <dhrosa> I suck at typing
01:39:55 <dhrosa> but you get the idea
01:40:05 <Fuuzetsu> If it's a list and you're getting every 2nd element, you're always going to have to traverse it all no matter what you try (as long you actually use it somewhere because laziness &c)
01:40:20 <dhrosa> > chunksOf 2 [1..10]
01:40:21 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
01:40:30 <dhrosa> oh that's not quite what you want
01:40:47 <Walther> > zip [1..10] [1..10]
01:40:48 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
01:40:55 <Walther> hrmm
01:40:56 <dario|> > map head $ chunksOf 2 [1..10]
01:40:57 <lambdabot>  [1,3,5,7,9]
01:40:59 <lieven_> I don't mind traversing it. I just want something that's linear and not quadratic or similar.
01:41:20 <Fuuzetsu> > let f [] = []; f [x] = []; f (_:y:xs) = y : f xs in f [1 .. 10]
01:41:21 <lambdabot>  [2,4,6,8,10]
01:41:33 <dleedev> I'm reading Programming guidelines and it mentions problems when using lazy IO:
01:41:38 <dleedev> do s <- readFile f
01:41:39 <dleedev>     writeFile f $ 'a' : s
01:41:39 <Fuuzetsu> oh, could put the last case first and then have a catch-all for first two cases
01:41:48 <dleedev> how can I avoid the lazy IO problem?
01:41:58 <Fuuzetsu> dleedev: pipes
01:43:14 <mada> dleedev: newbie question: what's the lazy IO problem?
01:43:25 <lieven_> :t chunksOf
01:43:27 <lambdabot> Int -> [e] -> [[e]]
01:43:44 <lieven_> hoogle only finds a version of chunksOf in Data.Text
01:43:50 <Fuuzetsu> mada: in that case, he's trying to write to the same file that he's going to be reading from; due to lazy IO, the reading won't happen until the writing starts
01:43:58 <merijn> mada: With lazy IO it's impossible to control when memory/file descriptors are freed
01:44:06 <dleedev> mada: writeFile will start writing 'a', then try to resolve s, by which time the file has already been written
01:44:22 <dleedev> Fuuzetsu: is there another way besides pipes?
01:44:25 * hackagebot yesod-platform 1.2.6 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.6 (MichaelSnoyman)
01:44:35 <Fuuzetsu> dleedev: yeah, like 20
01:44:36 <mada> so 'readFile f' won't actually happen until 's' is (:)'d in writeFile?
01:44:38 <merijn> mada: For example "hGetContents :: IO String" lazily reads a file, so if you manually close the file descriptor the String of "hGetContents" might stop midway
01:45:03 <Fuuzetsu> dleedev: http://www.haskell.org/haskellwiki/Iteratee_I/O
01:45:21 <merijn> mada: So you're relying on the GC to (eventually) close the file descriptor for you, which is bad for long living processes (i.e. servers) because you might run out of file descriptors
01:45:30 <Fuuzetsu> see Implementations in particular
01:45:37 <merijn> dleedev: The main contenders at the moment are pipes and conduit, I believe
01:45:40 <mada> right
01:45:51 <mada> thanks :>
01:46:18 <merijn> mada: There have been a bunch of libraries inspired by the Oleg Iteratees paper that provide steaming IO with deterministic memory usage/file descriptor freeing (the best ones are pipes/conduits)
01:46:56 <mada> pipes is Tekmo's library?
01:47:01 <merijn> mada: Yeah
01:47:37 <shachaf> steaming IO
01:47:39 <shachaf> sounds right
01:47:45 <mada> heh
01:47:48 <merijn> shachaf: :D
01:48:12 <mada> well, I haven't done much IO besides trivial uses, so I haven't run into these problems
01:48:28 <mada> which seem ubiquitous on any moderately complex use case
01:48:31 <shachaf> i,i impossible to control when file descriptors are fread
01:49:05 <shachaf> Anyway, I hope neither of those libraries in its current state becomes anything close to standard.
01:49:21 <Fuuzetsu> patches welcome, I'm sure
01:49:26 * hackagebot blaze-markup 0.6.0.0 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.6.0.0 (JasperVanDerJeugt)
01:49:31 <mada> shachaf: are they not up to par?
01:50:57 <shachaf> Parallelism is a whole different story.
01:51:07 <dleedev> is there a library in haskell similar to nokogiri in ruby?
01:51:14 <shachaf> Anyway, it's hard to say. Who knows what par is?
01:51:26 <dleedev> basically, an HTML5 parser with CSS traversal
01:52:02 <dleedev> shachaf: you don't like pipes and conduit in their current state?
01:52:03 <Phlogistique> dleedev: there are nice traversal DSLs, although the learning curve is steeper
01:52:40 <dleedev> Phlogistique: which ones?
01:54:26 * hackagebot blaze-html 0.7.0.0 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.7.0.0 (JasperVanDerJeugt)
01:55:15 <Phlogistique> dleedev: I am not really up to date with these matters, but you can take a look at "HXT" and HaXml
01:55:19 <Phlogistique> http://www.haskell.org/haskellwiki/Web/Libraries/XML_and_HTML
01:56:20 <Phlogistique> http://www.haskell.org/haskellwiki/HXT
01:57:54 <mjga> anybody knows where to find dev builds of GHC for ARM?
01:59:22 <quicksilver> Pretty sure neither hxt nor haxml has the CSS traversal part dleedev asked for
01:59:40 <merijn> dleedev: html-conduit is pretty good, but I don't think it does CSS
02:00:03 <merijn> mjga: Not sure those exist, ARM isn't a tier1 support platform yet
02:00:25 <merijn> mjga: And I don't think official dev builds for tier1 platforms exist either, atm
02:01:09 <Phlogistique> quicksilver: to me "CSS traversal" meant "CSS selectors" as in "a handy way to select an element I'm interested in". I don't know about such thing in Haskell, but I'm pretty sure HXT has an arrows-based selector DSL
02:01:14 <mjga> merijn: thx
02:01:37 <mjga> merijn: I wish there was something like travis, but building Debian or Ubuntu packages
02:01:48 <mjga> merijn: and making them available
02:02:20 <tdammers> you can rig travis up to build .debs I think
02:02:31 <merijn> mjga: Infrastructure costs money, unfortunately. Some people here were running their own nightly builds, but only for x86 and x86_64, I think
02:02:32 <tdammers> but it's more a testing service than a deployment one
02:03:46 <mjga> merijn: I'm temporarily short on money, so I can't donate a proper 4G ARM build platform ATM
02:04:47 <dleedev> yeah, CSS selector support is what I'm looking for
02:05:25 <merijn> mjga: The wiki suggest that a replacement buildbot is in the works, unsure about the time frame, though
02:05:53 <dleedev> merijn: this looks promising: http://hackage.haskell.org/package/selectors-0.0.3.0
02:05:57 <dleedev> merijn: do you know anything about that?
02:06:15 <merijn> dleedev: Not really, I don't do much web related stuff
02:06:23 <mjga> merijn: but 300e chromebook would probably do the job, otherwise there seems to be gcc build farm... http://gcc.gnu.org/wiki/CompileFarm
02:08:17 <mjga> so I understand the main problem is to provide a proper buildbot
02:10:39 <merijn> mjga: Well, the problems are basically money to run a buildbot/-farm, setting it up (the old one was taken down for a reason I don't know) and maintaining it.
02:12:49 <kqr> is there a way to do (a -> f b) -> f (a -> b) or am I doing it wrong if i feel the need for that?
02:14:16 <Axman6> @djinn (a -> Maybe b) -> Maybe (a -> b)
02:14:16 <lambdabot> f _ = Nothing
02:14:20 <Axman6> ha
02:15:42 <Maior> mjga: that's very doable (re packages)
02:16:19 <Maior> I need to run right now, but can I pm you an email address and you let me know what you're after?
02:16:29 <Maior> (in a smidge more detail)
02:16:30 <merijn> kqr: That looks like something like traverse?
02:16:34 <merijn> :t traverse
02:16:35 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:17:02 <merijn> kqr: Actually, no I don't think that signature is possible
02:17:19 <merijn> kqr: What are you actually trying to do?
02:17:33 <kqr> if i relax the requirements to f b -> f (a -> b) it should be possible though, right?
02:17:46 <kqr> oh i'm not doing anything in particular, i'm just playing around with functions to see what i can do
02:18:07 <merijn> "f b -> f (a -> b)" is just "fmap const"
02:18:09 <merijn> :t fmap const
02:18:11 <lambdabot> Functor f => f a -> f (b -> a)
02:18:13 <kqr> yeah thanks
02:18:24 <kqr> just realised that as you typed it out!
02:18:25 <Maior> :t const
02:18:26 <lambdabot> a -> b -> a
02:18:37 <Maior> @source const
02:18:37 <lambdabot> Unknown command, try @list
02:18:39 <mjga> Maior: yes, sure
02:18:46 <merijn> Maior: "const x _ = x"
02:18:52 <merijn> > const 5 undefined
02:18:53 <lambdabot>  5
02:18:59 <Maior> merijn: cheers
02:19:03 <Maior> mjga: cheers
02:20:32 <mjga> Maior: cheers
02:20:59 <merijn> Maior: It's definition actually follows automatically from the type :)
02:21:11 <merijn> @djinn a -> b -> a
02:21:11 <lambdabot> f a _ = a
02:23:05 <kqr> i love the very general functions because they make it so easy to figure out their definition from their type
02:24:27 <dleedev> I think I found something for my needs: https://github.com/egonSchiele/HandsomeSoup
02:24:46 <dleedev> are those >>> from Arrow?
02:24:53 <merijn> kqr: There is in fact a paper about exactly what you can learn from types (which is where @djinn comes from)
02:25:03 <merijn> kqr: Phil Wadler's "Theorems for Free"
02:25:06 <quicksilver> yes, dleedev
02:25:32 <dleedev> quicksilver: so I guess I gotta learn Arrow
02:25:50 <quicksilver> dleedev: probably easiest to learn by example first of all
02:26:02 <kqr> merijn, i think i have skimmed through it at some point
02:26:12 <merijn> dleedev: The wikibook on arrows is pretty good: https://en.wikibooks.org/wiki/Haskell/Understanding_arrows
02:26:27 <quicksilver> dleedev: adit's own tutorial on that very github page looks promising
02:26:30 <dleedev> I was told that Arrow is useless and going away
02:26:35 <quicksilver> the wikibook on arrows is absolutely useless.
02:26:38 <quicksilver> :)
02:26:59 <merijn> quicksilver: The pictures helped me understand the combinators at least
02:27:10 <quicksilver> merijn: but it explains everything in terms of functions
02:27:28 <quicksilver> merijn: doesn't give even the slightest hint of what a non-function instance of arrow might
02:27:31 <merijn> Sure
02:27:31 <quicksilver> look like
02:27:45 <quicksilver> I finished it thinking "is Arrow really just a class of combinators to use on functions? how odd..."
02:28:07 <quicksilver> dleedev: arrow turns out not to be as useful as people once hoped
02:28:20 <quicksilver> dleedev: however it's a perfectly natural model of "selection and transformation"
02:28:30 <quicksilver> so it works well for HXT and similar
02:28:30 <merijn> quicksilver: Arrow is useful, it's just 'arr' that ruins most interesting uses :)
02:28:41 <dleedev> quicksilver: is there something I can read that goes into that more deeply?
02:28:42 <quicksilver> merijn: you mean 'Category is useful'
02:29:00 <quicksilver> arr is the whole point of Arrow
02:29:04 <merijn> quicksilver: Does category have versions of (***), (&&&), first,second, etc.?
02:29:37 <warpy> arrgh
02:30:24 <merijn> Category would be more useful if it had those and "CategoryChoice"
02:31:45 <merijn> quicksilver: I don't think 'arr' is the "whole point" of arrow, that logic implies that proc notation, arrowchoice and the first/second combinators are all of lesser importance than 'arr', I think 'arr' is of lesser importance than those things
02:32:37 <quicksilver> merijn: proc notation doesn't make sense without 'arr' existing
02:33:10 <quicksilver> arrowchoice, first and second do of course make sense for some non-arrow categories
02:33:31 <merijn> quicksilver: Why don't they make sense without arr?
02:33:48 <merijn> s/don't they/doesn't proc/
02:34:03 <quicksilver> because arr is used in the desugaring
02:34:08 <merijn> hmm
02:34:24 <merijn> I need to check up my knowledge of proc desugaring
02:34:33 <quicksilver> and without arr working some of the "laws" about refactoring proc notation don't work
02:34:54 <quicksilver> I've always found proc notation pretty weird to be honest
02:35:09 <quicksilver> the only times I've used transformation/selection arrows like HXT I haven't found it useful
02:35:32 <quicksilver> I always wanted to spend the time working out if any of my examples could have been rewritten using it
02:35:35 <quicksilver> but I never did
02:35:40 <jle`> oh hey i just came here to ask about arrows
02:35:50 <jle`> but this conversation sort of answered them...or at least made me forget what they were
02:36:22 <jle`> yeah i actually probably could never desugar a proc block for the life of me
02:36:29 <merijn> quicksilver: There was a presentation about an Arrow for generating SQL queries at NL-FP a week or so ago, it was a pretty neat use of proc notation
02:36:30 <jle`> they are my crutch
02:36:34 <Tekmo> There is a paper that says that Arrows are monoids in a suitably chosen category and that `arr` is (basicallly) the identity
02:36:39 <Tekmo> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.80.9990
02:36:44 <jle`> so i do'nt ever actually ahve to use (***), (&&&), first, second, and arr
02:36:54 <jle`> actually i have been able to do a lot without ever using any of those
02:36:57 <jle`> and especially not loop.
02:37:13 <jle`> )
02:37:26 <quicksilver> adit's tutorial doesn't seem to use arrow notation either
02:37:58 <jle`> I just think of Arrows as Categories i can use proc notation for
02:38:20 <jle`> (is that a bad way of thinking about it?)
02:38:35 <jle`> Arrows are just Categories with the proper combinators defined to use them in proc notation
02:38:39 <jle`> (?)
02:38:55 <jle`> all of the side stepping mechanisms and stuff
02:39:49 <quicksilver> that's reasonable jle`
02:40:21 <quicksilver> I think proc notation not only relies on the arrow methods but actaully relies in one or two places on the arrow laws
02:40:24 <quicksilver> but, I'm not sure
02:40:30 <quicksilver> my instinct for proc notation is week.
02:40:34 <quicksilver> weak :)
02:41:41 <Tekmo> The way I like to think of arrows is as ways to build directed acyclic graphs
02:41:48 <Tekmo> And cyclic if you have arrowloop
02:42:04 <Tekmo> So an arrow is roughly a "composable" graph
02:42:13 <Tekmo> By graph, I mean a graph that may have potentially loose ends
02:42:16 <Peaker> but need to get rid of "arr" and add more fine-grained structure instead, or Arrow just isn't useful
02:45:09 <Tekmo> No, you need `arr`
02:45:33 <Tekmo> It sounds like what you want is not an `Arrow` at all but something different
02:45:35 <Peaker> Tekmo: With "arr" Arrow degenerates into a cumbersome encoding of the same power you have from Category+Applicative
02:45:36 <merijn> quicksilver: Actually, after looking at the way proc notation uses arr, I think one could avoid arrow if there was an explicit "feed :: Arrow a b c => b -> a b c" function, although that raises the question whether that type is sensible or whether you'd want something else. Essentially you want to take something "out" and then apply a function to it before stuffing it in the remainder of the pipeline
02:45:51 <merijn> s/avoid arrow/avoid arr
02:46:22 <Tekmo> Peaker: Are you saying that Category+Applicative is isomorphic to Arrow?
02:46:41 <Peaker> Tekmo: Pretty much (Up to some artifacts involving instance selection)
02:46:54 <Tekmo> Peaker: Let me give it a shot.  One second
02:48:08 <Tekmo> Peaker: So how do you implement `arr` in terms of `Category`+`Applicative`?
02:48:18 <Tekmo> I'm assuming the signature looks something like this:
02:48:22 <Tekmo> arr :: (Category c, Applicative (c a)) => (a -> b) -> c a b
02:49:34 <Axman6> @info Catrgory
02:49:34 <lambdabot> Catrgory
02:49:35 * jle` grabs popcorn
02:49:38 <Axman6> @info Catergory
02:49:38 <lambdabot> Catergory
02:49:46 <nicoo> @info Category
02:49:47 <lambdabot> Category
02:49:51 <Axman6> -_
02:49:52 <jle`> Axman6: i think @info is implemented in lambdabot as @echo
02:50:05 <nicoo> @source Category
02:50:05 <lambdabot> Unknown command, try @list
02:50:09 <nicoo> @src Category
02:50:10 <lambdabot> Source not found. You speak an infinite deal of nothing.
02:50:10 <Tekmo> class Category c where
02:50:10 <quicksilver> Tekmo: mumble mumble pure + >>>
02:50:22 <quicksilver> Tekmo: it's not hard to work out if you write the types down
02:50:34 <jle`> Axman6: category extends (->) to other function-like things
02:50:35 <merijn> jle`: It's not implemented as echo, is just error-corrects to echo (missing commands are mapped to the closest existing command)
02:50:51 <quicksilver> Tekmo: arr g = pure g <*> id
02:50:54 <Axman6> jle`: right, i wanted to see what functions the class defines
02:51:02 <jle`> merijn: ah :)  was making a joke but i see it now
02:51:05 <jle`> Axman6: (.) and id
02:51:05 <quicksilver> Tekmo: (says my notes from when this came up in this channel last week)
02:51:09 <merijn> Axman6: Lamdabot doesn't support :info
02:51:10 <Tekmo> quicksilver: Got it
02:51:21 <Axman6> merijn: clearly it does :P just badly
02:51:32 <Tekmo> quicksilver: So it could also be `fmap g id`, right?
02:51:39 <merijn> Axman6: No, it's autocorrecting to echo, just like @vixen corrects to @nixon nowadays
02:51:50 <quicksilver> Tekmo: yes.
02:51:56 <Axman6> vixen was so fun :(
02:52:05 <quicksilver> Tekmo: functor + category is enough for arr
02:52:06 <c_wraith> I thought nixon was gone, too
02:52:16 <quicksilver> Tekmo: you need applicative for some of the other bits.
02:52:23 <quicksilver> Tekmo: first and second, probably, I can't remember
02:52:24 <Axman6> @nixon watergate
02:52:24 <lambdabot> You have to face the fact that whole problem is really the blacks. The key is to divise a system that reconizes this while not appearing to...
02:52:30 <c_wraith> guess not!
02:52:37 <Peaker> Tekmo: fmap f id ?
02:54:19 <Peaker> oh I see I am late with my response :)
02:54:28 <Tekmo> Yeah, quicksilver covered it :)
02:54:43 <Tekmo> Now I'm working on `first`, but this time I think I've got it
03:04:28 <Tekmo> So what I have is: first f = liftA2 (,) (arr fst >>> f) (arr snd)
03:06:33 <Tekmo> So is there a similar way to encode `ArrowChoice` in terms of other type classes?
03:06:55 <jle`> i always felt like you get arrows for free from categories and applicative and was always puzzled by their independent existence.  i am glad that people actually think about this.
03:08:00 <quicksilver> Tekmo: does "Alternative" do it?
03:08:17 <quicksilver> it would be logical if it did, but possibly more pieces or more laws are required
03:08:20 <quicksilver> I havent' tried to check
03:32:31 <jle`> does Tekmo or mm_freak who helped me understand machines or anyone who knows a bit about machines or anyone with some time to kill want to give a read over my first draft of my machines blog post and point out any horrible mistakes i have made?
03:32:33 <jle`> http://blog.jle.im/entry/intro-to-machines-part-1
03:37:04 <johnw> jle`: I'll definitely read it, but won't have comments for a while
03:37:52 <jle`> johnw: no problem :)
03:39:21 <jle`> don't expect too much because I only learned about this last week :)
03:39:35 * hackagebot tasty-rerun 1.0.0 - Run tests by filtering the test tree depending on the result of previous test  runs  http://hackage.haskell.org/package/tasty-rerun-1.0.0 (OliverCharles)
03:46:58 <darthdeus> what do you guys recommend for doing simple GUI?
03:47:56 <mr-> darthdeus: if you don't need widgets and want something pretty on the screen: gloss
03:48:23 <darthdeus> mr-: i need something like textboxes, labels, etc.
03:48:23 <mauke> html
03:48:29 <darthdeus> mauke: lol :P
03:49:32 <Lamen> quick note: after doing my own research, the local hackage-server prematurely closed the connection while the hackage-mirror client (using HTTP/1.1) still think it's alive. so PUT to it resulted in a reset packet. does some one have a known solution to this?
03:49:33 <mr-> darthdeus: I heard some good things about threepenny-gui
03:49:52 <mr-> (which is fairly close to mauke's suggestion, I think)
03:52:27 <darthdeus> mr-: i'll take a look, thanks :)
03:53:14 <prophile> can it be proved there is no ArrowApply instance for Automaton?
03:54:36 * hackagebot hoodle-core 0.13.0.0 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.13.0.0 (IanWooKim)
03:54:38 * hackagebot hoodle 0.2.2.1 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.2.2.1 (IanWooKim)
04:00:20 <c_wraith> prophile: like newtype Automaton a b = Automaton (a -> (b, Automaton a b)) ?
04:01:02 <c_wraith> prophile: given that ArrowApply is more or less Monad, and that type has a perfectly good Monad instance, I'm pretty sure that it does have ArrowApply
04:01:10 <Tekmo> jle`: I'm back.  I'd be happy to read over your machines post
04:01:13 <jle`> darthdeus: check out http://ocharles.org.uk/blog/posts/2013-12-07-24-days-of-hackage-threepenny-gui.html
04:01:25 <jle`> darthdeus: and also http://ocharles.org.uk/blog/posts/2013-12-10-24-days-of-hackage-gloss.html
04:01:27 <darthdeus> jle`: thanks
04:01:46 <jle`> but threepenny is probably closer
04:02:13 <prophile> c_wraith: it does?
04:02:14 <prophile> intriguing
04:02:19 <Lamen> in case someone's interested, http://lpaste.net/98810
04:02:45 <jle`> Tekmo: thanks :) if you've opened it before your message then you might want to refresh as i have made some significant modifications
04:02:47 <prophile> c_wraith: I was thinking in the general case of newtype Automaton a b c = Automaton (a b (c, Automaton a b c))
04:03:03 <Tekmo> jle`: Can you repaste the link?
04:03:11 <jle`> http://blog.jle.im/entry/intro-to-machines-part-1
04:03:28 <prophile> c_wraith: where might I find this instance?
04:04:16 <Tekmo> jle`: Thanks for the shoutout for compositional programming :)
04:04:55 <jle`> Tekmo: haha no problem, i loved the series
04:04:56 <c_wraith> prophile: which instance? Monad?
04:04:59 <prophile> c_wraith: yeah
04:05:04 <jle`> actually are there any more past the functor design pattern?
04:05:11 <jle`> i only read those two
04:05:53 <Tekmo> There's an upcoming one for natural transformations
04:06:09 <c_wraith> prophile: http://hackage.haskell.org/package/machines-0.2.3.1/docs/Data-Machine-Mealy.html is an implementation with ArrowApply and Monad
04:06:27 <prophile> this is very interesting
04:06:28 <Tekmo> However, most of what I'm working on is just expanding the basic ideas in the category and functor posts into a longer book
04:07:35 <jle`> Tekmo: ah. well i look forward to the book
04:07:48 <johnw> me too!
04:09:21 <Tekmo> jle`: Another term you can use to describe how auto works is that it is like a "scan"
04:09:27 <Tekmo> jle`: i.e. like scanl
04:09:50 <jle`> ah
04:09:57 <jle`> that would be a better analogy than fold
04:10:02 <jle`> for side-by-side type signature comparison
04:11:00 <c_wraith> prophile: by the way, I wasn't sure that instance was in that package.  The reason I was sure that type has a monad instance is the shape of the contents.  It looks a lot like the state monad.  A bit trickier, but the data flows in the same manner
04:11:06 <jle`> scanl op acc :: [a] -> [b]
04:11:18 <jle`> scanl op acc :: (->) [a] [b]
04:11:25 <jle`> autoScan op acc :: Auto [a] [b]
04:11:28 <jle`> er
04:11:30 <jle`> Auto a b
04:11:43 <Tekmo> jle`: I highly recommend defining functions to automate your example (i.e. define a `take` for your `Stream` examples and a feed function for your `Auto` examples)
04:11:47 <prophile> c_wraith: interesting
04:11:51 <prophile> I will have to consider this further
04:11:52 <prophile> thank you
04:11:53 <Tekmo> jle`: There are two reasons
04:12:03 <Tekmo> jle`: First, it will shorten your interactive code examples
04:12:21 <Tekmo> jle`: The second reason is even more important: it will make it easier for the reader to do experiments of their own with your code
04:12:33 <Tekmo> jle`: A really important principle of teaching is to always make it easy for the student to test out their own ideas
04:12:56 <jle`> hm
04:13:20 <jle`> initially, i left them explicit because running them manually helped me understand what was going on
04:13:21 <jle`> but
04:13:28 <jle`> i probably do not have to belabor the point
04:13:43 <jle`> after once or twice...i thouls probably provide an automation for the reasons you mentioned
04:13:52 <c_wraith> jle`: scanl op acc :: [a] -> [b] ; toScan :: Auto a b -> [a] -> [b]
04:13:55 <jle`> thouls? how did that happen
04:14:15 <c_wraith> jle`: just to *really* drive home the parallel..  and to make people look for the difference
04:15:28 <jle`> c_wraith: that's interesting, and i think that definitely fits, thanks
04:16:03 <Tekmo> jle`: Also, the names start becoming a bit long beginning at `settableCounterFrom`
04:16:40 <Tekmo> jle`: Actually, that example is okay
04:16:50 <Tekmo> jle`: The one that is hard to read is the one with `settableCounterFromIsEven`
04:17:02 <Tekmo> jle`: The reason why is that the names are very long and similar, so they are hard to distinguish
04:17:15 <jle`> yeah...i can see that happening
04:17:22 <Tekmo> saiam: They both begin with `settable` and end with `Even`, so they are visually similar
04:17:44 <Tekmo> Oops, that should have been addressed to `jle``
04:17:58 <jle`> it's actually pretty disgusting even despite the visual simularity
04:18:13 <jle`> haha
04:18:20 <jle`> now that i read it on the HTML page
04:18:40 <Tekmo> So I also have a "meta-critique"
04:19:23 <Tekmo> One of the things I try to avoid is teaching a wide menagerie of abstractions
04:19:52 <Tekmo> This is one of the dangers of having a long series-style set of posts
04:20:13 <Tekmo> It dilutes the importance of each abstraction by casting each one as just a component in a grab-bag of tricks
04:20:52 <jle`> hm. so you prefer each abstractions presented in the context of their actual utility?
04:21:25 <Tekmo> So as a PhD student, one of my committee members gave me a really great tip for writing
04:21:46 <Tekmo> He said something like: "When you write or present something, your audience will remember at most one thing from your paper/talk, maybe"
04:22:33 <Tekmo> So if you present several abstractions, the first thing your reader is likely only to walk away with a useful knowledge of one of those abstractions, if you are lucky
04:24:10 <Tekmo> Remember that your reader's comprehension of your subject material will typically be much lower than yours, so if you are writing at the limits of your comprehension, they are definitely going to be reading past the limits of theirs
04:25:16 <Tekmo> But other than that I think the content of the post is good
04:25:22 <jle`> hm. i'll take this to heart.
04:25:26 <jle`> i do see a lack of focus
04:25:28 <jle`> reading back
04:25:37 <jle`> it might help to make everything focused on one thing
04:25:58 <Tekmo> jle`: A good rule of thumb is that each post should be relatively self-contained
04:26:02 <Tekmo> i.e. you can still make it a series
04:26:07 <jle`> all of my articles in the past have started mostly kind of grab-bag, like you say...and after a week or two of editing i whiddle out the parts that don't contirbute to the main point
04:26:15 <Tekmo> But if somebody just picks up just one post in the middle of the series it should be able to stand on its own
04:26:49 <jle`> i can pull some things out completely or maybe throw some parts into asides/sidebars
04:26:58 <Tekmo> Writing is generally really difficult because of the audience
04:27:10 <Tekmo> It's very tempting to try to communicate a really complex idea all at once
04:27:34 <Tekmo> The art of writing is taking really complex ideas and distilling them down into smaller and simpler self-contained ideas
04:27:48 <jle`> interesting
04:28:01 <Tekmo> Think of it like refactoring code
04:28:14 <Tekmo> You begin with one monolithic function that has lots of responsibilities and logic
04:28:27 <Tekmo> Then you refactor it into smaller functions with well-divided responsibilities
04:28:29 <Tekmo> Writing well is like that
04:28:58 <Tekmo> It also requires a lot of persistence
04:29:15 <Tekmo> There are lots of ideas that I've wanted to communicate but still haven't because it takes time to build up to them in terms of simpler ideas
04:29:43 <Tekmo> But you just have to be patient and just keep chipping away the complex topic slowly with simpler ideas
04:30:25 <Tekmo> If you do this you give your audience time to digest it all
04:31:16 <jle`> Tekmo: thanks, i appreciate both the critiques and the meta-critique
04:31:34 <jle`> i'm still a bit new to the craft so this is pretty helpful :)
04:31:47 <Tekmo> jle`: Yeah, I can tell you really enjoy writing
04:32:09 <jle`> haha, does that really come across?
04:32:12 <Tekmo> jle`: It's a great skill to cultivate
04:32:26 <Tekmo> jle`: Yes
04:32:41 <Tekmo> jle`: You remind me a lot of myself when I first started blogging
04:32:53 <jle`> well..hopefully the enthusiasm is more of a positive feature than a negative one
04:33:04 <Tekmo> jle`: It's positive.  Don't worry
04:34:30 <Tekmo> I remember my inspiration for blogging was Dan Piponi's blog (blog.sigfpe..com)
04:35:14 <Tekmo> He got me really excited about Haskell and I just wanted to share that excitement with other people, so I tried to emulate him
04:35:26 <jle`> the comment is an honor :)  hopefully in two or three years time i'll be able to contribute to the community to some fraction of the level you do
04:35:41 <Tekmo> Thanks! :)
04:35:45 <Tekmo> I'll give you one tip
04:36:03 <Tekmo> Keep logs of traffic if you can
04:36:09 <Tekmo> It's a very good way to monitor post quality
04:36:27 <jle`> oh yeah i am a data nut.  i've had it on google analytics from day one.
04:36:37 <Tekmo> You can use post views to assess improvements in writing skill over time and use that to hone your writing
04:38:21 <jle`> that's a good tip. thanks
04:38:30 <jle`> previously i had associated it with relevance of subject matter to the public
04:38:31 <Tekmo> It also greatly increases enthusiasm to write :)
04:38:38 <jle`> but i had not thought about using it to gauge writing skill
04:38:58 <jle`> haha there's a certain game-like aspect to it
04:39:07 <Tekmo> Yeah
04:39:20 <Tekmo> One tip: the
04:39:41 * hackagebot antigate 2.0 - Interface for antigate.com captcha recognition API  http://hackage.haskell.org/package/antigate-2.0 (MikhailKuddah)
04:39:44 <Tekmo> hardest site to get visibility on is /r/programming
04:39:48 <Tekmo> Harder than Hacker news
04:40:15 <Tekmo> I consider that the highest standard for post quality
04:40:33 <Tekmo> Hacker News generates more views, but it's generally a lower bar
04:41:21 <jle`> Tekmo: oh nice, thanks...i wasn't even too aware of this subreddit
04:41:48 <Tekmo> I consider /r/programming to be the most stringent of the programming communities
04:44:02 <jle`> i'll keep an eye on it :)
04:44:12 <jle`> anyways...it is probably time for me to sleep here in the states.
04:44:21 <Tekmo> Alright
04:44:22 <jle`> thank you for your advice, it is much appreciated
04:44:25 <jle`> :)
04:44:28 <jle`> have a good day
04:44:29 <Tekmo> You're welcome! :)
04:44:31 <Tekmo> You, too
04:47:13 <eikke> Tekmo: did you happen to see my message of yesterday?
04:49:48 <passiveobserver> Hello All, the example of 'Extracting Results' on page http://hackage.haskell.org/package/sqlite-simple-0.1.0.2/docs/Database-SQLite-Simple.html doesn't compile: xs <- query_ conn "select name,age from users" gives me an error: The type variable `r0' is ambiguous, Possible fix: add a type signature that fixes these type variable(s), Note: there are several potential instances: FromRow (a, b), FromRow (a, b,
04:49:50 <passiveobserver> c), FromRow (a, b, c, d),... -- My question: how do I syntax-wise write this in the end of select? (assume I have a row with 2 fields).
04:50:29 <Tekmo> eikke: No.  What was it?
04:51:56 <supki> passiveobserver:  xs <- query ... :: IO [(String, Int)]
04:54:42 * hackagebot conduit 1.0.11.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.11.1 (MichaelSnoyman)
04:55:58 <passiveobserver> supki: thanks
04:57:31 <dabd> I was reading a bit about literate haskell and I wonder what is the best style: bird or latex? Any advice please?
04:58:00 <dabd> or not literate haskell at all!
04:58:19 <dabd> no literal*
04:58:59 <Tekmo> It depends on what you're using it for
05:04:37 <dabd> Tekmo: no particular goal in mind, just general purpose
05:04:40 <Cale> dabd: If you're writing a mailing list post or blog post, probably Bird style. If you're writing a paper, use LaTeX style in order to accomodate LaTeX (you might also want to get lhs2tex to make the code look prettier)
05:05:01 <merijn> dabd: pfft, latex style for blog posts too
05:05:07 <merijn> Bird style sucks
05:05:07 <Cale> lol
05:05:24 <merijn> I even added support for latex style rST in pandoc recently!
05:05:25 <hodapp> yeah, gotta make sure to use two Knuth creations instead of one
05:05:26 <dabd> but do people use literate haskell a lot?
05:05:33 <merijn> dabd: Mostly for papers/blog posts
05:05:37 <hodapp> I think a lot of us just use illiterate Haskell
05:05:38 <merijn> dabd: Not so much for actual code
05:06:00 <merijn> Sometimes main binaries will be in lhs too
05:07:35 <dabd> In this discussion http://stackoverflow.com/questions/2707645/literate-haskell-lhs-and-haddock one guy says literate haskell is a superfluous
05:07:44 <dabd> is  superfluous*
05:08:37 <Cale> dabd: Well, it's one of those nice things to have around where you can take it or leave it.
05:09:15 <dabd> ok, since i am learning the language i was wondering if writing lhs would help me grasp the concepts better
05:09:15 <merijn> dabd: For real world code writing I agree that it's probably superfluous
05:09:25 <merijn> dabd: But for paper writing it's nice to have "runnable" papers
05:09:52 <merijn> dabd: I wouldn't worry about it, if you find yourself writing more text and less code, using lhs is fine. If not, don't worry
05:10:11 <Cale> dabd: Oh, well, no. All it is, is a way to make comments the default, and have code sections be marked.
05:10:34 <Cale> So that you can conveniently embed Haskell code into other kinds of text, in such a way that people can still download and run it conveniently.
05:10:54 <tdammers> I hear some people actually use literate programming as their workflow
05:11:04 <tdammers> write a program like you would write a novel, that idea
05:11:16 <tdammers> never tried it myself, but I figure it takes discipline
05:11:22 <Cale> If you have a lot of explaining to do, that's good.
05:11:58 <Cale> The pipeline scheduler that I did one Summer way back was about 50% comments.
05:12:25 <merijn> dabd: Basically, in normal haskell you mark comments, in lhs you mark code.
05:12:53 <dabd> I was looking through diagrams examples and they are written in lhs: http://projects.haskell.org/diagrams/gallery/SymmetryCube.html. Looks good
05:17:38 <merijn> dabd: Yeah, that's a good example usecase
05:29:45 * hackagebot snap-blaze 0.2.1.2 - blaze-html integration for Snap  http://hackage.haskell.org/package/snap-blaze-0.2.1.2 (JasperVanDerJeugt)
05:44:40 <ski> shachaf : yes, though "inhabitable type" (or maybe "concrete type") for types in `*' is somewhat off as well, since it sounds like those terms would reasonable include types in `#' and `(#)' as well (but not types in `row' or `k0 -> k1')
05:45:24 <ski> perhaps one could add a "boxed" qualifier, when needed to disambiguate
05:53:30 <mbrock> tdammers: that's the way Knuth intended it!
05:54:12 <mbrock> "The practitioner of literate programming can be regarded as an essayist, whose main concern is with exposition and excellence of style."
05:54:59 <mbrock> moreove, "By coining the phrase 'literate programming,' I am imposing a moral commitment on everyone who hears the term; surely nobody wants to admit writing an *illiterate* program."
05:55:25 <mbrock> that's two similarities to functional programming
05:55:57 <mbrock> (quotes from http://literateprogramming.com/knuthweb.pdf )
05:57:34 <ziman> right, who would write illiterate dysfunctional programs?
05:58:07 <tdammers> mbrock: yes, I know, I've read this part of Knuth
05:59:31 <merijn> mbrock: Although Knuth's literate programming is rather different from what literate haskell does
06:13:59 <ocharles> Can anyone figure out why the monoid type can't be found in http://lpaste.net/98812 ?
06:14:08 <ocharles> I literally can't see what else I could possibly add type annotations to :?
06:14:37 <ocharles> note that this all gets fixed if I remove the 'foldResource' part
06:15:43 <ocharles> The weirdest thing is if I put 'foldResource = True' I get a type error with an expected type signature, but if I use that type signature as the type of 'undefined', then it becomes ambiguous
06:16:11 <Twey> ocharles: Add a type signature for treeFold
06:16:15 <ocharles> I have
06:16:28 <ocharles> there is a type on line 28 in that paste
06:16:31 <Twey> Oh, you did, I see
06:17:06 <Twey> Oh
06:17:11 <ocharles> I wonder if it's due to the existential type in http://hackage.haskell.org/package/tasty-0.7/docs/Test-Tasty-Runners.html#t:TreeFold
06:17:13 <Twey> I think it wants you to add a type for Tasty.trivialFold
06:17:43 <Twey> You've overwritten all the fields, so it can't tell what type the record was originally supposed to be
06:17:51 <Twey> It doesn't actually need to know, but it doesn't know that
06:18:14 <ocharles> Twey saves the day!
06:18:16 <Twey> (Tasty.trivialFold :: Tasty.TreeFold ([Tasty.TestName] -> [Tasty.TestTree])) { … }
06:18:22 <ocharles> That is a seriously weird type error
06:18:31 <Twey> It's unpleasant
06:19:01 <Twey> I think NoMonomorphismRestriction would avoid this
06:19:14 <mm_freak_> ocharles: what needs to be a monoid?  the 't' in foldSingle?
06:19:21 <Cale> What's the original type of trivialFold?
06:19:29 <Twey> mm_freak_: trivialFold :: Monoid b => TreeFold b
06:19:47 <ocharles> http://hackage.haskell.org/package/tasty-0.7/docs/Test-Tasty-Runners.html#t:TreeFold all other types there
06:19:50 <mm_freak_> yeah, but with what does that 'b' unify?  with the 't' in foldSimple?
06:19:58 <mm_freak_> because that's what the error message suggests
06:20:01 <Cale> Can you just use the constructor for that datatype instead?
06:20:04 <Fuuzetsu> Heh, someone's actually rewriting NetBSD is Haskell
06:20:05 <Fuuzetsu> in*
06:20:06 <Twey> Mm, true
06:20:07 <mm_freak_> i'm not familiar with tasty, thouch
06:20:10 <mm_freak_> though
06:20:14 <ocharles> Cale: I can, but it's discouraged
06:20:25 <Twey> Fuuzetsu: Link?
06:20:30 <ocharles> The idea being now my library becomes a bit more tied to the general algbrea of tree folds
06:20:34 <ocharles> But I'm willing to live with that
06:20:41 <eikke> Twey: see one of the latest messages on haskell-cafe
06:20:46 <Twey> ocharles: Does it stop complaining with NoMonomorphismRestriction?
06:20:50 <Cale> I mean, if you're replacing all the fields anyway, you might as well
06:21:03 <Cale> and it would likely avoid this issue
06:21:04 <Twey> Cale: But the record might change later
06:21:06 <mm_freak_> Twey: that would be weird
06:21:09 <ocharles> Twey: nope
06:21:10 <Twey> To add more fields that donn't break
06:21:12 <Twey> don't**
06:21:15 <Twey> ocharles: Oh, okay.
06:21:17 <ocharles> Cale: Yea, I will do that
06:21:18 <Fuuzetsu> Twey: check café but https://github.com/metasepi and http://metasepi.org/
06:21:27 <Cale> I suppose Twey has a point there :)
06:21:27 <mm_freak_> Tekmo: hi there
06:21:31 <Tekmo> mm_freak_: Hey!
06:21:41 <mm_freak_> Tekmo: did you read the discussion about FreeT?
06:21:46 <ocharles> Twey: that's the point of trivialFold, but this library probably should break if new folds are added
06:21:57 <Tekmo> mm_freak_: Yeah
06:21:58 <Twey> Fuuzetsu: Huh, ambitious
06:22:08 <Tekmo> mm_freak_: I agree with most points except performance
06:22:19 <Twey> If I did it I would probably just not expose the constructor
06:22:36 <Tekmo> mm_freak_: I won't make the change without benchmarks, but making the bind optional had a significant effect on performance for `pipes`
06:22:59 <Tekmo> The only reason I'm naming it `List` is because I couldn't think of a name that wouldn't clash with the existing `FreeT` name
06:23:05 <Tekmo> mm_freak_: I'm open to other name suggestions
06:23:46 <Cale> I suppose another option would be to define  reallyTrivialFold :: TreeFold ()
06:24:31 <Cale> (but that kind of has the same problems as using the constructor directly)
06:25:19 <Tekmo> mm_freak_: Oh, and the dependency thing is kind of an issue, too
06:25:42 <Tekmo> mm_freak_: I tolerate dependencies more for `pipes-parse` than `pipes`, so I could live with it
06:26:31 <Tekmo> mm_freak_: The main issue is that depending on a package of Edward's basically makes it impossible to eventually get into the Haskell platform.  That's a long term goal for `pipes` and (possibly) for `pipes-parse`, too
06:26:47 <Tekmo> I'll be right back in a few minutes
06:31:21 <mm_freak_> Tekmo: i understand the performance difference for pipes
06:31:32 <mm_freak_> Tekmo: that's why in netwire i have WGen and WPure, the latter being a pure variant
06:31:43 <halvorg> Is type class interchangeable with monad? i.e. the Maybe monad is the Maybe type class? It's a bit confusing to me, I understand >>= and return, but I don't get the full picture.
06:31:52 <merijn> halvorg: No
06:31:55 <mm_freak_> Tekmo: however, consider that in FreeT the binding only occurs when necessary anyway, for example when you actually 'next' the producer
06:32:12 <merijn> halvorg: Maybe is a type that happens to be an *instance* of the Monad typeclass
06:32:35 <halvorg> but when people write the maybe monad they mean the maybe type?
06:32:35 <mm_freak_> Tekmo: btw, i would be happy with a separate package for free monads
06:32:36 <Cale> halvorg: Maybe isn't a type class, it's a type constructor
06:32:39 <Cale> Monad is a type class.
06:32:43 <mm_freak_> Tekmo: but then make it a package for free monads =)
06:32:44 <halvorg> yes my typo
06:32:52 <merijn> halvorg: For example, we have the "Eq" typeclass, which implements equality. Types that have an instance of the Eq class can be used with "=="
06:32:54 <Cale> halvorg: Not all type constructors are monads
06:33:12 <lieven_> what's the problem with edward's packages versus the Haskell platform? licensing issues?
06:33:12 <merijn> halvorg: Similarly, types that have an instance of the Monad class can use "return" and ">>="
06:33:18 <Cale> halvorg: Only type constructors which have an appropriate definition of return and (>>=)
06:33:24 <halvorg> yeah I get that I think
06:33:42 <halvorg> You never see people refer to the "Eq Int" though
06:33:50 <halvorg> as you see "List Monad"
06:34:03 <merijn> halvorg: Yeah, that's just people being people (i.e. inconsistent)
06:34:05 <Cale> halvorg: Well, someone might refer to the list Eq instance
06:34:19 <mm_freak_> Tekmo: this is mainly because FreeT is a bit awkwardly defined in edwardk's package…  personally i'd define it like this:  newtype FreeT f m a = FreeT { runFreeT :: m (Either a (f (FreeT f m a))) }
06:34:28 <Cale> It depends on what aspect of the thing you're emphasising
06:34:31 <merijn> halvorg: When peope say "the X monad" they usually mean "the monad instance for X"
06:34:43 <Cale> But I generally would agree that too much weight is placed on things being monads
06:34:45 <halvorg> I see, thanks.
06:34:48 <mm_freak_> Tekmo: that makes the type a lot easier to digest and possibly also triggers some optimizations in the base package
06:34:54 <Cale> Knowing that something is a monad doesn't actually tell you a whole lot about it
06:35:20 <Cale> It just tells you that you can use return and (>>=) and the stuff in Control.Monad and other places which depends on those.
06:35:21 <merijn> halvorg: It's very inconsistent too, because people don't say "the X functor" or "the X applicative" as much, even though those are probably used more
06:35:35 <Cale> merijn: They don't?
06:35:55 <Cale> I would
06:35:58 <merijn> Cale: I can't remember the last time I saw someone say "the Maybe functor", but they say "the Maybe monad" all the time
06:36:37 <Cale> Well, if I was explaining how something which worked for all functors applied to the case of Maybe, then I would use those words.
06:36:59 <Cale> There are not quite so many things which apply to all functors as there do which apply to all monads.
06:37:09 <merijn> True
06:37:25 <Cale> But generally, I don't say "the Maybe monad" either, unless I'm trying to emphasise the fact that we can use monad operations.
06:37:29 <mm_freak_> Tekmo: anyway, if you really decide to make your own type with optional purity, i would ask you to define it like this:  data FreeT f m a = FPure (Either a (f (FreeT f m a))) | FGen (m (Either a (f (FreeT f m a))))
06:37:52 <mm_freak_> Tekmo: this has the same effect, except that now the type can be understood straightforwardly by people familiar with free monads
06:38:50 <Cale> The same goes for IO
06:39:39 <Cale> You likely ought not to say "the IO monad" unless you're explaining why you're allowed to use things like sequence or mapM
06:39:49 <Cale> (though people do)
06:40:20 <mm_freak_> merijn: i think i've said "the Maybe functor" here many times
06:40:30 <mm_freak_> i've even talked about the "IO functor"
06:41:16 <merijn> Two counterexamples doesn't invalidate my wide sweeping generalisation! :p
06:41:29 <merijn> s/doesn't/don't
06:41:48 <Tekmo> mm_freak_: Hmm, good point
06:42:11 <Tekmo> mm_freak_: Alright, let me see if I can get `FreeT` to work
06:42:21 <Tekmo> mm_freak_: It's certainly easier :)
06:42:27 <mm_freak_> =)
06:42:48 <Tekmo> mm_freak_: What I will probably do then is just add lens-based parsing for now and then postpone the decision on `FreeT`
06:43:08 <Tekmo> mm_freak_: That way people can evaluate lens-based parsing in isolation of the `FreeT` change
06:43:14 <mm_freak_> Tekmo: lens-based parsing?
06:43:27 <Tekmo> mm_freak_: Oh, this is one of the cool recent innovations
06:44:04 <zrho> Tekmo: Sounds cool, any articles about that out there?
06:44:04 <Tekmo> mm_freak_: Basically this greatly simplifies delimited parsing and also simplifies the pipes-parse API
06:44:05 <merijn> Tekmo: You're making me feel bad about my productivity levels :(
06:44:09 <Tekmo> Ha :)
06:44:15 <Tekmo> The trick is focus
06:44:29 <mm_freak_> Tekmo: i fell in love with FreeT =(
06:44:41 <mm_freak_> you're going to take it away =/
06:44:45 <Tekmo> The `FreeT` is unaffected by lens-based parsing
06:44:51 <merijn> I wish I had the option to focus on one thing at a time instead of working on 4 things in parallel >.>
06:44:54 <mm_freak_> =P
06:45:10 <mm_freak_> lens-based parsing:  the trick is focus =)
06:45:11 <zrho> The lens kind of focus or the human kind of focus? :P
06:45:17 <Tekmo> Both
06:45:17 <merijn> Tekmo: Out of curiosity, are you doing all the pipes stuff in your spare time or are you somehow get paid while hacking on it too?
06:45:29 <Tekmo> Lens-based parsing actually uses `zoom`, so there is an element of focus
06:45:36 <Tekmo> merijn: spare time
06:45:57 <Tekmo> I did a very brief write up here: https://groups.google.com/forum/?fromgroups#!topic/haskell-pipes/-fsWSm26l6U
06:45:57 <merijn> Tekmo: Impressive :)
06:45:59 <mm_freak_> 'zoom' used to be called 'focus' in data-lens anyway =)
06:46:06 <Tekmo> However, I can summarize it pretty quickly here
06:46:12 <urbanslug> Hey you guys this day has refused to end :C
06:46:17 <zrho> Someone in here that is familiar with "Practical type inference for arbitrary-rank types" by SP Jones?
06:46:19 <Tekmo> The basic idea is that `pipes-parse` has three abstractions that are "analogous" to pipes abstractions
06:46:28 <Tekmo> It's actually uncannily similar to conduit, but better
06:46:46 <Tekmo> So `Producer`s are the same.  There is no change there
06:46:56 <Tekmo> `Consumer`s are replaced by `Parser`s, which are defined like this
06:46:57 <merijn> zrho: Probably, but you're better of asking directly, rather than "asking to ask"
06:47:16 <zrho> merijn: Probably.
06:47:19 <Tekmo> type Parser a m r = forall x . StateT (Producer a m x) m r
06:47:34 <Tekmo> The analog of `Pipe`s are Lenses between `Producer`s of the form:
06:47:42 <Tekmo> Lens' (Producer a m x) (Producer b m x)
06:48:00 <Tekmo> `view`/`(^.)` is how you connect `Producer`s and lenses
06:48:19 <Tekmo> view :: Lens' (Producer a m x) (Producer b m x) -> Producer a m x -> Producer b m x
06:48:23 <Tekmo> YOu can think of that as:
06:48:30 <Tekmo> "Pipe" -> "Producer" -> "Producer"
06:48:31 <zrho> I'm trying to implement the type checker presented in that paper, extended with type class support. Jones argues that type classes would only require a minor change to the presented type checker, but I don't really see that right now.
06:48:41 <Tekmo> `zoom` is how you connect lenses and parsers
06:48:59 <Tekmo> zoom :: Lens' (Producer a m x) (Producer b m x) -> Parser b m r -> Parser a m r
06:49:02 <Tekmo> You can think of that as:
06:49:14 <Tekmo> "Pipe a b" -> "Consumer b" -> "Consumer a":
06:49:23 <mm_freak_> Tekmo: that's elegant
06:49:25 <Tekmo> And lens composition is how you connect lenses
06:49:42 <Tekmo> What's neat is that it gets a lot of things right
06:49:51 <Tekmo> For example, there is a `splitAt` lens which has type:
06:49:53 * hackagebot bindings-mpdecimal 0.8.0.0 - bindings to mpdecimal library  http://hackage.haskell.org/package/bindings-mpdecimal-0.8.0.0 (OmariNorman)
06:50:08 <Tekmo> splitAt :: Int -> Lens' (Producer a m x) (Producer a m (Producer a m x))
06:50:24 <Tekmo> Think of that as a lens that splits the producer after `n` elements into two separate producers
06:50:38 <Tekmo> You can either use it as a getter to split a pipe:
06:50:39 <Tekmo> i.e.
06:50:44 <Tekmo> p ^. splitAt 10
06:50:55 <Tekmo> Or you can use it to delimit a parser to the first 10 elements
06:50:59 <Tekmo> zoom (splitAt 10) someParser
06:51:12 <Tekmo> What's cool is that it will get pushback correct, unlike conduit
06:51:23 <Tekmo> If you did something like that and undrew input in conduit, the undrawn leftovers would be lost
06:51:34 <Tekmo> Using `zoom` to do this, the leftovers are preserved correctly when the delimited pipe ends
06:51:55 <mm_freak_> very nice
06:52:06 <Tekmo> And the lens laws translate perfectly into associativity laws
06:52:07 <Tekmo> For example:
06:52:25 <Tekmo> p^.(lens1.lens2) = (p^.lens1)^.lens2
06:52:27 <Tekmo> similarly:
06:52:43 <Tekmo> zoom (lens1.lens2) p = zoom lens1 (zoom lens2 p)
06:53:07 <bennofs> Tekmo: do you know if somebody is working on pipes-xml?
06:53:17 <Tekmo> bennofs: Somebody began it a while ago but then dropped it
06:53:22 <Tekmo> bennofs: Currently nobody is working on it
06:53:49 <Clint> Tekmo: is there a pipes equivalent of cereal-conduit?
06:53:57 <Tekmo> Clint: No.  There is only `pipes-binary`
06:54:04 <Tekmo> Clint: You'd have to translate that to work with `cereal`
06:54:37 <Tekmo> Clint: However, I'd recommend waiting until after I update `pipes-parse`.  I've already rewritten `pipes-binary` to use the new `pipes-parse` so it would be better to begin from that rather than the current version
06:55:23 <mm_freak_> i said it yesterday and i say it again
06:55:30 <Clint> Tekmo: hmm, ok
06:55:31 <mm_freak_> the more i use pipes, the less often i use (>->) =)
06:56:18 <mm_freak_> very often folding a producer seems to make more sense than connecting it to a consumer…  and it's faster, too
06:56:36 <Tekmo> mm_freak_: Yes
06:56:42 <Tekmo> mm_freak_: I personally prefer `for` loops whenever possible
06:57:00 <Tekmo> mm_freak_: I think `for`/`ListT` is one of the coolest parts of `pipes`
06:57:21 <mm_freak_> i've never actually used ListT
06:57:27 <Tekmo> mm_freak_: I can summarize it like this:
06:57:33 <Tekmo> mm_freak_: (>>=) = for, return = yield
06:57:40 <Philonous> Is it possible that ghc will create an exception when a thread is blocking on a TMVar that another only has a weak pointer to?
06:57:45 <mm_freak_> ah
06:57:54 <Philonous> another thread*
06:58:27 <Tekmo> mm_freak_: If you haven't seen my post already, you should really read this: http://www.haskellforall.com/2014/01/stream-fusion-for-pipes.html
06:58:44 <Tekmo> mm_freak_: It talks about how `pipes` now converts your code to `for` loops for efficiency whenever possible
06:59:32 <mm_freak_> reading
07:00:15 <Cale> Philonous: I would expect if the weak pointer was somehow GC'd, then you'd get thread blocked indefinitely.
07:02:00 <Cale> (i.e. if its key was GC'd)
07:03:01 <eikke> mm_freak_: wrt our conversation yesterday: I failed, until now. mind blown.
07:03:33 <Cale> eikke: I'm curious. What was that conversation about? :)
07:03:44 <Philonous> Cale, I'm creating it with mkWeakPtr, so the key is the STMVar itself. And it would be astonishing if it was GC'd while I'm blocking on it
07:04:04 <hc> moin
07:04:20 <Tekmo> Cale is the master of mind-blowing! :)
07:04:26 <hc> is there a simpler way to express \a -> (`mod` a) ?
07:04:42 <Philonous> hc, flip mod
07:04:43 <Cale> flip mod
07:04:47 <hc> aah, thank you!
07:04:48 <eikke> Cale: writing something like 'group :: Monad m => (s -> a -> (Bool, s)) -> s -> Producer a m r -> FreeT (Producer a m) m r'
07:04:58 <hc> what i'm ultimately doing is: mapM (\a -> (`mod` a) <$> randomIO) [10, 10]
07:05:17 <Tekmo> Philonous: What exactly are you trying to do?  The reason why I ask is that you are talking about something that sounds very similar to a problem that `pipes-concurrency` is designed to solve (avoiding concurrency deadlocks through garbage collection)
07:05:20 <Cale> hc: Use randomRIO
07:05:31 <eikke> Tekmo: that was my question to you I referred to before (well, the question was whether that's available somewhere, but seems not to be)
07:05:48 <eikke> Cale: basically, 'stateful grouping/chunking of input values'
07:06:00 <hc> thank you
07:06:27 <Tekmo> eikke: Hmmm.  I don't see an obvious way to get that from existing functions
07:07:05 <Tekmo> eikke: However, I could certainly write up this function for you for your own code
07:07:07 <eikke> Tekmo: me neither. Been trying to get something working based on reading groupBy, splitOn and takeWhile of pipes-parse, but didn't get there
07:07:45 <Tekmo> eikke: I think this function is sufficiently exotic that it's probably easiest to write it just by manually recursing over the `Producer` and building the `FreeT` by hand
07:07:57 <Philonous> Tekmo, I have a connection object that's supposed to be killed when all references to it go out of scope. Associated to that object is a thread that handles incoming messages and distributes them into TMVars. To avoid killing the connection while someone is waiting for a response each of those TMVars has a weak pointer to the connection object
07:08:16 <Tekmo> Philonous: This is definitely the problem that `pipes-concurrency` solves
07:08:53 <Tekmo> Philonous: There is a tutorial here: http://hackage.haskell.org/package/pipes-concurrency-2.0.1/docs/Pipes-Concurrent-Tutorial.html
07:08:57 <Tekmo> Philonous: I can also summarize it for you
07:09:07 <Tekmo> There is a `spawn` function in `pipes-concurrency` with this type:
07:09:19 <Tekmo> spawn :: Buffer a -> (Output a, Input a)
07:09:25 <Philonous> Tekmo, Don't bother, I'll read the tutorial
07:09:27 <Tekmo> spawn :: Buffer a -> IO (Output a, Input a)
07:09:30 <Tekmo> Okay
07:09:34 <Tekmo> Let me know if you have any questions
07:09:54 <Tekmo> Philonous: The relevant section is "Work Stealing"
07:09:55 * hackagebot yesod-platform 1.2.6.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.6.1 (MichaelSnoyman)
07:10:23 <Philonous> Tekmo, Actually, I do. conduits has a mechanism to handle "leftover" data. Can you point me in the right direction how to do this with pipes?
07:10:29 <Philonous> Then I'd be sold
07:10:45 <Tekmo> Philonous: This is what `pipes-parse` is for.  If you can wait a week or two, there is going to be an API overhaul for it
07:10:49 <eikke> Philonous: afaik that's what pipes-parse solves using StateT
07:10:54 <mm_freak_> Tekmo: yes, that was the task i gave eikke yesterday =)
07:11:08 <mm_freak_> recurse over the producer, build a FreeT
07:11:15 <eikke> mm_freak_: yeah :-/
07:11:23 <Philonous> Tekmo, Thanks!
07:11:24 <mm_freak_> eikke: so you've got it?
07:11:29 <Tekmo> eikke: It might help to exercise using simpler versions of the tasks
07:11:40 <Tekmo> eikke: For example, practice writing the `sum` fold from `Pipes.Prelude`
07:11:54 <Tekmo> eikke: This is a good way to practice recursing over a `Producer` without worrying about `FreeT`
07:12:14 <Tekmo> eikke: All you need is the `next` function from the `Pipes` module
07:12:22 <mm_freak_> eikke: i.e. does "until now" mean that you got it working now? =)
07:12:44 <eikke> mm_freak_: not now, now I'm doing paid-job-work, but later today I might pick it up again
07:13:10 <mm_freak_> eikke: begin with this one:  single :: (Monad m) => Producer a m r -> FreeT (Producer a m) m r
07:13:37 <eikke> which yields the input producer as a single 'group'?
07:13:43 <mm_freak_> single should turn "abc" into ["a", "b", "c"]
07:13:53 <eikke> oh, ok
07:14:09 <mm_freak_> and listen to Tekmo
07:14:09 <eikke> that's a good idea, should give some familiarity with constructing the FreeT part
07:14:19 <mm_freak_> if you have no experience recursing over producers, you should start with 'sum' =)
07:14:37 <mm_freak_> sum :: (Monad m, Num a) => Producer a m r -> m a
07:16:04 <eikke> hmh, OTOH that might be something like: sum p = loop p 0 where loop p acc = next p >>= \r -> case r of Left _ -> return acc; Right (v, p') -> loop p' (acc + v)
07:17:51 <Tekmo> eikke: Yeah, that slooks right
07:17:56 <Tekmo> *that
07:17:59 <Tekmo> *looks
07:18:30 <Tekmo> `FreeT` is trickier, in my opinion
07:18:40 <Tekmo> Even when I write `FreeT` code I often get it wrong the first couple of times
07:18:59 <eikke> I used FreeT to build DSLs before, including a port to OCaml, but for some reason the mental mapping/model of seeing as a 'list' somehow fails now
07:19:07 <Philonous> Tekmo, Oh, I think my explanation was ambiguous. I'm not trying to implement a load balancing kind of setup, but a request-response mechanism. You send a message over the connection and create and install a TMVar where the response will be put. Can pipes-concurrency handle that?
07:19:44 <eikke> e.g. https://gist.github.com/NicolasT/7833209
07:20:16 <lingxiao> hey all what's the most terse way to express stripping the prefix of one list with another list
07:20:32 <lingxiao> that fails if the other list does not overlap with the list to be striped
07:20:34 <lingxiao> ie ...
07:20:49 <lingxiao> stripPrefix [1,2,3] [1,2] = [3]
07:21:04 <lingxiao> stripPrefix [1,2,3] [2,3] = Nothing
07:21:09 <lingxiao> stripPrefix [1,2,3] [1,2] = Just [3]
07:21:42 <lingxiao> wait ... ok `stripPrefix` does just that ...
07:21:43 <Tekmo> Philonous: So what are the multiple `TMVar`s for?
07:23:06 <Philonous> That's where the response is put. The connection has a Map from (unique) message IDs to TMVars, if response matching one of the message IDs is recevied it's put into the TMVar (and the TMVar is removed from the Map)
07:23:56 <Tekmo> Philonous: So the answer is yes.  `pipes-concurrency` has a `Single` buffer type which under the hood is backed by a `TMVar`
07:24:07 <Philonous> OK, thanks.
07:24:31 <Tekmo> Philonous: It also implements reference counting, so if there are no more references to the `Input` then the `Output` will begin returning `False` if you `send` things to it
07:24:56 * hackagebot tasty-rerun 1.0.1 - Run tests by filtering the test tree depending on the result of previous test  runs  http://hackage.haskell.org/package/tasty-rerun-1.0.1 (OliverCharles)
07:25:04 <Tekmo> Philonous: I also want to mention something else
07:25:24 <Tekmo> Philonous: `Output`s are `Monoid`s, so what you can do is just mconcat the `Output`s for all of your `Single` buffers and then `send` to that
07:25:36 <Tekmo> Philonous: It will succeed as long as just one of the buffers is still live, and fail if all of them are dead
07:25:45 <Tekmo> Philonous: The tutorial gives an example of this, if I remember correctly
07:25:57 <eikke> that's pretty sweet
07:26:04 <Tekmo> Thanks! :)
07:26:31 <bergmark> ocharles: nice package :-)
07:26:32 <eikke> is it 'efficient', or backed by walking the list of outputs and finding the first which can take a message?
07:26:39 <Tekmo> It's inefficient
07:26:50 <Tekmo> Actually, it could be made efficient by overriding `mconcat`
07:26:51 <eikke> oh ;)
07:27:01 <Tekmo> I'll make an issue to remind myself to do that
07:27:34 <eikke> I wrote something alike for queues once, but on the consumer side (wait on several STM queues and fetch the first item available)
07:27:40 <eikke> didn't think about doing it monoidal though
07:28:30 <eikke> basically combining readTChans with orElse or something along those lines, cant remember exactly
07:29:32 <Tekmo> Yeah, it's slightly tricky
07:29:38 <Tekmo> I got it wrong the first time
07:30:06 <Tekmo> eikke: See this: https://github.com/Gabriel439/Haskell-Pipes-Concurrency-Library/blob/master/src/Pipes/Concurrent.hs#L85
07:31:15 <eikke> nice
07:31:28 <eikke> I should think about using alternative & monoid more often
07:31:52 <mm_freak_> Tekmo: nice article and once again a validation of my categorical approach =)
07:31:55 <Tekmo> eikke: Yeah, they are great abstractions
07:31:57 <Tekmo> mm_freak_: :)
07:32:28 <eikke> Tekmo: (a <|> b) or (b <|> a) can have very different behaviour, right
07:32:35 <Tekmo> eikke: Correct
07:32:41 <Tekmo> eikke: It prioritizes the left one
07:32:49 <eikke> mhm
07:33:05 <Tekmo> eikke: It's the same as STM's Alternative instance
07:33:21 <Tekmo> *roughly
07:33:43 <eikke> guess it'd be interesting to have something which takes a list of inputs, tries to fetch a single value, create a new 'group' input with the one who yielded all the way at the back, and return the value & this new input
07:34:17 <eikke> so you get round-robin like behaviour if all inputs are yielding at all times
07:35:04 <lingxiao> hey all, If I have the following formlation of a TLC
07:35:04 <Tekmo> I wonder if STM does this already or not
07:35:14 <lingxiao> what's a good way to reprsent product types?
07:35:22 <merijn> Tekmo: If STM does what?
07:35:24 <eikke> Tekmo: actually I hope it doesnt
07:35:25 <Tekmo> Because I think one of the concerns for STM was starvation from this sort of bias, but I don't know if they handle it or not
07:35:30 <lingxiao> https://gist.github.com/anonymous/b0ff96c86ffa5b7f756f
07:35:36 <merijn> STM is left-biased
07:35:40 <Tekmo> Or maybe I'm confusing it with something else
07:35:48 <eikke> that's a good thing, the bias
07:36:09 <tel> Is there a standard location anywhere for the purely applicative Either? instance Monoid e => Applicative (Either e)?
07:36:09 <Tekmo> So let's consider the case of just raw STM.  What would the type of your proposed round-robin API look like?
07:36:15 <lingxiao> I naive soln: `Prod :: [Term a] -> Term a` does not work since the product type is forced to have the same type for all fields
07:36:17 <merijn> Tekmo: It uses orElse, i.e. the right side is only tried if the left side retries
07:36:39 <Tekmo> merijn: Yeah, I think I was just confused
07:36:55 <merijn> eikke: Oh, I just saw your original question
07:37:01 <merijn> eikke: There's a simpler solution
07:37:12 <eikke> Tekmo: rr :: [STM a] -> STM (a, STM a) or something along those lines?
07:37:25 <merijn> eikke: I wanted to have STM that yielded in roundrobin fashion for network actions
07:37:56 <eikke> Tekmo: argh, no, I'm wrong
07:38:34 <merijn> eikke: In my case I have multiple TQueue's and I want to read (same approach works for writing) in round-robin fashion, is that similar to your problem?
07:38:51 <Philonous> Tekmo, I'm copying your trick with the weakIORefs and unsafeIOToSTM.
07:38:58 <Tekmo> Philonous: Awesome!
07:39:04 <eikke> merijn: oh, I'm not having that 'problem' now, but it's something I thought of during the discussion here. But I'd love to hear your input
07:39:06 <merijn> eikke: i.e. I want to pick the first ready TQueue, but repeated reads should first service other TQueue's before reading the first read one
07:39:54 <Tekmo> eikke: Maybe: [STM a] -> STM (a, [STM a])?
07:39:55 <eikke> Tekmo: data RR a = RR a (STM (RR a)); rr :: [STM a] -> STM (RR a)
07:40:00 <merijn> eikke: My approach is "TQueue (TQueue a)", basically, when I add an element to an empty TQueue I append it to the "queue queue"
07:40:29 <Tekmo> eikke: Maybe you could simplify it to
07:40:31 <merijn> eikke: When I want to read an item, I pop the first TQueue out of the "queue queue", read an item from it and if it's non-empty append it to the outer TQueue again
07:40:36 <Tekmo> eikke: [STM a] -> Producer a STM ()
07:40:43 <eikke> Tekmo: heh ;)
07:40:48 <Tekmo> eikke: :)
07:40:52 <mm_freak_> Tekmo: optimized my plines splitter a bit more…  it now splits 1 GiB of data in 1.2 secs =)
07:40:55 <eikke> merijn: nifty
07:40:59 <Tekmo> mm_freak_: Nice!
07:41:47 <merijn> eikke: If the outer queue is empty, I just block waiting for a queue to be appended, if there is only one TQueue with data I'll just repeatedly pop/append it from the outer queue, if there are other queues with data the outer queue ensures I fairly service all the other queues before going back to an already serviced queue
07:42:32 <merijn> eikke: Much simpler (and probably about as efficient as you can be) than more complex solutions :)
07:42:33 <eikke> mm_freak_: would be interesting to benchmark e.g. against awk ;-)
07:42:50 <eikke> merijn: indeed, makes sense
07:43:56 <mm_freak_> eikke: counting lines takes 1.2 secs, wc -l takes 0.2 secs…  however, the line splitter is FreeT-based, while wc just counts occurrences of \n
07:44:23 <mm_freak_> counting \n in haskell with pipes takes around 0.3 secs
07:45:59 <eikke> mm_freak_: that's why awk (or perl or whatever people consider 'fast' for text processing) could be useful: actually 'consume' all lines and count them, instead of counting \n's
07:47:35 <individual_> does anyone have information about building ghc with integer-simple instead of integer-gmp?
07:49:08 <eikke> mm_freak_: awk 'BEGIN{i=0}{i++;}END{print i}' should do the job (thanks SO :P). On a rather small logfile here, the difference with 'wc -l' is very measurable (> 2x more 'user' time)
07:50:20 <merijn> individual_: Is there a special reason you need to?
07:51:29 <individual_> merijn: because ghc uses its own allocators with gmp which means calling C libraries that use gmp will segfault
07:52:07 <individual_> it's a known problem, there are bugs on trac
07:52:10 <merijn> individual_: Ah :)
07:52:23 <merijn> individual_: May want to try #ghc
07:52:43 <Cale> https://ghc.haskell.org/trac/ghc/wiki/Commentary/Libraries/Integer
07:52:53 <Cale> has instructions at the very top
07:52:56 <eikke> individual_: set INTEGER_LIBRARY in mk/build.ml
07:53:32 <mm_freak_> Tekmo: this is weird…  the non-FreeT folding variant that counts '\n' is actually slower
07:53:40 <individual_> thank you
07:53:59 <individual_> I find this GMP issue very very awkward
07:54:58 * hackagebot glider-nlp 0.1 - Natural Language Processing library  http://hackage.haskell.org/package/glider-nlp-0.1 (klangner)
07:55:02 <mm_freak_> Tekmo: http://lpaste.net/98815
07:55:14 <frege> is this valid http://lpaste.net/98816 ?
07:55:15 <mm_freak_> if i use count (plines Pb.stdin), it takes 1.2 secs
07:55:16 <Philonous> Tekmo, Btw. why do you chose an IORef over a TVar? Would safe you the unsafeIOToSTM
07:55:26 <mm_freak_> Tekmo: but if i use countLines Pb.stdin it takes 1.3 secs
07:55:32 <mm_freak_> Tekmo: any idea?
07:55:34 <frege> I tried to implement a function that finds extremes in a list http://lpaste.net/98816
07:55:46 <frege> but I don't think that my syntax is valid
07:55:49 <Cale> Hopefully eventually someone will take the trouble to produce an Integer implementation which is fast enough to ditch GMP altogether. It's sort of an obnoxious dependency because it's LGPLed, so you can't statically link it.
07:56:19 <merijn> frege: Well, that function has a tuple argument?
07:56:47 <eikke> Cale: there was some BSD bignum lib which reached 1.0 recently iirc
07:57:01 <frege> merijn: yeah, I wanna recursively break a list down and pass every three elements to this func
07:57:09 <frege> merijn: do you think that's a good idea?
07:57:32 <Cale> frege: Your syntax is valid (if a little weirdly laid out), but extremesWorker doesn't handle all possible cases, and there's no point in defining the helper function here if you're just going to pass along the same argument.
07:57:38 <merijn> frege: Why three elements?
07:57:49 <merijn> frege: Wouldn't you just need a maximum and minimum?
07:57:56 <frege> merijn: because it's a local min/max algorithm
07:58:04 <frege> yeah but locally
07:58:04 <Cale> frege: Also, your function doesn't work with lists, it works with triples.
07:58:32 <frege> Cale: I have to use another function to go over a list and pass every triple to this function I think
07:58:38 <Tekmo> mm_freak_: Give me a second to study it
07:58:50 <frege> Cale: I have difficulty working with lists without indexes
07:59:00 <eikke> Cale: https://github.com/wbhart/bsdnt
07:59:24 <mm_freak_> Tekmo: as a reference 'wc -l' takes 0.2 secs
07:59:59 * hackagebot condor 0.3 - Information retrieval library  http://hackage.haskell.org/package/condor-0.3 (klangner)
08:00:54 <Tekmo> mm_freak_: Note that you can simplify `discardAll` to `discardAll p = runEffect (for p discard)`
08:00:58 <Cale> frege: Consider producing a list of elements from extremesWorker (which will have 0 or 1 element). You can then concatenate the results of applying extremesWorker to each triple of elements in the input list.
08:00:59 <Tekmo> mm_freak_: That would be faster
08:01:47 <frege> Cale: gotcha, gonna try now
08:03:13 <lingxiao> could someone take a look at this question I posted on SO?
08:03:14 <lingxiao> http://stackoverflow.com/questions/21238508/how-do-you-define-sum-and-product-types-of-type-t-when-t-is-parameterized-over-s
08:03:22 <Tekmo> mm_freak_: Your non-FreeT count is not strict in the accumulator.  I wonder if that makes a difference
08:03:24 <Cale> > let triples xs = [(x,y,z) | (x:y:z:_) <- tails xs] in triples [1..10]
08:03:24 <lingxiao> thank you :)
08:03:25 <lambdabot>  [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7),(6,7,8),(7,8,9),(8,9,10)]
08:03:33 <Tekmo> mm_freak_: Oh wait, never mind
08:03:34 <Cale> frege: ^^ might also be of use
08:03:36 <Tekmo> mm_freak_: I see the `seq`
08:03:57 <frege> Cale: http://lpaste.net/98816
08:04:05 <mm_freak_> Tekmo: the for-based discardAll is slower…  it takes 1.5 secs now
08:04:17 <Cale> frege: You want  | otherwise = []
08:04:27 <Tekmo> mm_freak_: Really?  That's so strange
08:04:33 <frege> Cale: is 'otherwise' a syntax?
08:04:39 <Cale> > otherwise
08:04:40 <lambdabot>  True
08:04:45 <Tekmo> mm_freak_: Oh wait, not it's not
08:04:46 <Cale> It's a constant defined as True
08:04:54 <mm_freak_> Tekmo: in fact this one is faster: discardAll p = runEffect (p >-> forever (await >>= discard))
08:04:57 <Cale> Specifically for use in making guards like that one look pretty :)
08:04:57 <Tekmo> mm_freak_: It's because `discardAll` skips `runEffect`, which has a cost
08:04:59 * hackagebot Condor 0.3 - Information retrieval library  http://hackage.haskell.org/package/Condor-0.3 (klangner)
08:05:12 <frege> Cale: http://lpaste.net/98816
08:05:14 <mm_freak_> Tekmo: with that one i'm back to 1.3 secs, with runEffect
08:05:19 <Tekmo> mm_freak_: Not just `forever await`?
08:05:26 <mm_freak_> uh, sure…
08:05:26 <Cale> frege: yes, that's right
08:05:37 <Tekmo> mm_freak_: That is really weird
08:05:45 <mm_freak_> yeah, changed it to 'forever await' now
08:05:46 <mm_freak_> same performance
08:05:53 <frege> Cale: how can I do the same thing in one line?
08:06:04 <Tekmo> Hmmm.  `for p discard` should always be faster than `p >-> forever await`
08:06:09 <Cale> frege: hmm
08:06:11 <mm_freak_> Tekmo: i have pipes 4.0.0 here…  does that make a difference?
08:06:23 <Tekmo> mm_freak_: Probably not
08:06:28 <frege> Cale: this doesn't work Prelude> extremes (a,b,c) | b>a && b>c = [b] | b<a && b<c = [b] | otherwise = []
08:06:35 <Tekmo> mm_freak_: What happens if you do `p >-> for cat discard`?
08:06:40 <frege> Prelude> let extremes (a,b,c) | b>a && b>c = [b] | b<a && b<c = [b] | otherwise = []
08:06:42 <Cale> frege: ghci wants expressions, not declarations
08:06:43 <frege> that worked
08:06:49 <frege> > let extremes (a,b,c) | b>a && b>c = [b] | b<a && b<c = [b] | otherwise = []
08:06:50 <lambdabot>  not an expression: `let extremes (a,b,c) | b>a && b>c = [b] | b<a && b<c = [...
08:06:50 <Cale> But you can use 'let' yes.
08:06:59 <mm_freak_> Tekmo: 1.3 secs
08:07:16 <Tekmo> mm_freak_: Very weird
08:07:41 <Tekmo> mm_freak_: `p >-> for cat discard` should be slower than `for p discard`
08:07:57 <Cale> frege: We could collapse the first two conditions into one, by using || and just put that conditional into a list comprehension which examines triples of adjacent elements in a list
08:08:17 <frege> Cale: oh neat, || == OR ?
08:08:28 <mm_freak_> Tekmo: probably some optimization rules firing/not firing
08:08:35 <Tekmo> mm_freak_: Yeah, maybe
08:08:41 <frege> Cale: like this? b>a && b>c = [b] || b<a && b<c = [b]
08:08:55 <killy9999> what is a context in forall ?
08:09:04 <Cale> > let extremes xs = [b | a:b:c:_ <- tails xs, (a < b && b > c) || (a > b && b < c)] in extremes "mississippi"
08:09:05 <lambdabot>  "iii"
08:09:15 <killy9999> I'm thinking here in context of template haskell
08:09:27 <killy9999> data Type = ForallT [TyVarBndr] Cxt Type | ... {- other constructors -}
08:09:48 <killy9999> [TyVarBndr] are binders that come before the .
08:10:06 <Cale> > let extremes xs = [b | a:b:c:_ <- tails xs, (a < b && b > c) || (a > b && b < c)] in extremes [0,9,2,1,6,3,5,4,7,8]
08:10:07 <lambdabot>  [9,1,6,3,5,4]
08:10:13 <mm_freak_> Tekmo: but i find it even weirder that the 'countLines' function is so slow
08:10:32 <mm_freak_> Tekmo: i remember one way to get wc-like performance
08:10:46 <mm_freak_> but i forgot how i wrote it
08:10:55 <Tekmo> mm_freak_: Have you tried this:
08:11:01 <frege> Cale: thanks! I have to get back to work; I will try to play around with that
08:11:10 <frege> Cale: what's the in extremes [0,9,2,1,6,3,5,4,7,8]
08:11:17 <frege> Cale: "in extremes [0,9,2,1,6,3,5,4,7,8]" ?
08:11:19 <Tekmo> mm_freak_: countLines p = P.sum (p >-> P.map yield B.count)
08:11:28 <Cale> frege: the syntax is  let <declarations> in <expression>
08:11:31 <Tekmo> mm_freak_: That would require `pipes-4.0.2` for the fusion optimization
08:11:37 <Tekmo> mm_freak_: Or you could implement it yourself using
08:11:45 <mm_freak_>     P.fold (\x s -> x + B.count 10 s) 0 id Pb.stdin >>= print
08:11:48 <Cale> frege: It's an expression form which allows you to define things locally.
08:11:51 <Tekmo> countLines p = P.sum (for p (yield . B.count 10))
08:11:53 <frege> Cale: ahh because it has to be like that for lambdabot? otherwise you could declare and then call the func?
08:11:54 <mm_freak_> Tekmo: that's what i'm doing right now
08:12:03 <whoami_> :t P.fold
08:12:04 <lambdabot> Couldn't find qualified module.
08:12:12 <Cale> frege: yeah, you could make this a top-level declaration in your module if you like
08:12:23 <frege> gotcha
08:12:26 <frege> thanks Cale !
08:12:28 <Tekmo> fold :: Monad m => (x -> a -> x) -> x -> (x -> b) -> Producer a m () -> m b
08:12:32 <Cale> No problem :)
08:12:49 <Tekmo> Note that the `foldl` library now has the `purely` function
08:12:54 <Tekmo> So you can wrap that in `purely` to get:
08:12:55 <merijn> whoami_: lambdabot doesn't have pipes installed (afaik anyway)
08:13:03 <Tekmo> purely fold :: Monad m => Fold a b -> Producer a m () -> m b
08:13:16 <mm_freak_> Tekmo: i suppose the performance won't change =)
08:13:25 <whoami_> ah
08:13:59 <Tekmo> mm_freak_: Maybe B.count is just slow for some odd reason
08:15:01 <mm_freak_> Tekmo: indeed, that seems to be the problem
08:15:07 <mm_freak_> with B.length i'm down to 0.3 secs
08:16:13 <boothead> hi guys, sorry in advance, I'm sure this has been answered before, (I did try google honest). Why can't a make and Iso beween text and bytestring with iso encodeUtf8 decodeUtf8?
08:17:23 <merijn> boothead: decodeUtf8 returns a Either/Maybe, I think
08:17:31 <merijn> boothead: Because decoding ByteString may fail
08:17:41 <roconnor> not every bytestring represents a valid unicode string
08:17:50 <Tekmo> boothead: The iso you want is more like: Iso' Text (Text, ByteString)
08:18:00 <Tekmo> boothead: ... where the `ByteString` represents the undecoded residue
08:18:01 <merijn> Oh wait, it doesn't return failure?
08:18:08 <merijn> ugh, that's awful
08:18:09 <boothead> merijn, they are Text -> ByteString and ByteString -> Text
08:18:19 <boothead> I get an error about profunctors
08:18:30 <merijn> roconnor: Apparently decodeUtf8 doesn't gracefully handle errors :\
08:18:31 <roconnor> Tekmo: even then there are simply invalid utf8 codes.
08:18:43 <Tekmo> roconnor: Yes, I know
08:19:05 <merijn> boothead: Why do you want this isomorphism?
08:19:09 <Tekmo> roconnor: That's probably the closest solution to his question
08:19:21 <merijn> boothead: In general you should probably use decodeUtf8With instead of decodeUtf8
08:19:31 <mm_freak_> Tekmo: 'length . B.elemIndices 10' is actually faster than 'B.count 10' =)
08:19:33 <Tekmo> roconnor: Also, you are going to hate me in a week or two
08:19:39 <roconnor> Tekmo: a prism would be closer I think.
08:19:39 <Tekmo> roconnor: I apologize in advance
08:19:51 <roconnor> Tekmo: that's okay, I already hate most people here :P
08:19:54 <Tekmo> roconnor: :)
08:20:01 <roconnor> damn you Time-Lens.
08:20:11 <Tekmo> mm_freak_: You should create an issue for it
08:20:17 <boothead> merijn, I have an EmailAddress with has a toByteSrring function I need that ByteString in Text so that I can fit it into my code
08:20:20 <mm_freak_> Tekmo: yeah
08:20:47 <merijn> boothead: ugh, I blame whatever library defined that type
08:21:02 <Sagi> what would be the non-IO variant of liftIO?
08:21:18 <Tekmo> Sagi: `lift`, from Control.Monad.Trans.Class
08:21:22 <Sagi> I'm looking at the types and it doesn't seem to match liftM, which I found to be a good candidate based on the name :-)
08:21:25 <Tekmo> Sagi: It's provided by the `transformers` library
08:21:38 <Sagi> oh, that makes even more sense
08:21:44 <quchen> liftM = fmap.
08:21:50 <merijn> Sagi: You're probably searching for lift, but unlike liftIO (which lifts arbitrary levels), lift only lifts one level
08:22:01 <Tekmo> Yeah, you have to call `lift` once for each layer you want to lift down
08:22:11 <Tekmo> However, note that there are two tricks to simplify this
08:22:26 <Tekmo> The first is the obvious one: you can bundle multiple calls to lift into a single one just by defining a new function
08:22:30 <mm_freak_> i'm down to 0.5 secs now with a recursive version that uses B.breakByte
08:22:37 <roconnor> Tekmo: Sorry about not patching lens-family with your request.  Unfortunately it is very low priority and I have many papers to review for MSFP
08:22:37 <Tekmo> i.e. `liftStateT = lift . lift` or however many layers down your `StateT` is
08:22:44 <Sagi> hmm, can I do the same thing without using a explicit monadtrans stack?
08:22:52 <mm_freak_> still a bit slower than 'wc'
08:22:52 <Tekmo> roconnor: No problem at all. It's really low priority for me, too :)
08:22:59 <quchen> Under no circumstances look at the type of `lift (. lift)^n` though
08:23:11 <Tekmo> Sagi: I actually prefer to use an explicit monad transformer stack
08:23:17 <Tekmo> Sagi: The type errors are much more useful
08:23:44 <Sagi> Tekmo: well, I just need this stack for one function: I have it returning Maybe (MyReader ...)
08:23:52 <Sagi> err, the other way around.
08:24:05 <Sagi> MyReader (Maybe a))
08:25:00 * hackagebot creatur 4.3.2 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-4.3.2 (AmyDeBuitleir)
08:25:18 <Tekmo> Sagi: Do you mean `MyReader Maybe a`?
08:25:21 <Sagi> I have been battling with this before. It feels stupid to lift every single part of that function into the Maybe monad, but I need access to the reader in a couple of places.
08:25:46 <Tekmo> Sagi: Oh, you should consider using `MaybeT`
08:25:51 <merijn> Sagi: Why not "lift $ do { code here }"?
08:25:58 <merijn> Or MaybeT, yes
08:26:07 <Tekmo> Sagi: It takes anything of the form `m (Maybe a)` and transforms it to `MaybeT m a`, automating all error handling
08:26:15 <merijn> Sagi: I find that if I need X lifts in a row, you're better of lifting an entire X line block
08:26:18 <Tekmo> Sagi: Just wrap it in the `MaybeT` constructor
08:26:27 <Tekmo> Sagi: MaybeT :: MyReader (Maybe a) -> MaybeT MyReader a
08:26:28 <Sagi> Tekmo: just for that function?
08:26:54 <Sagi> I really appreciate your help!
08:26:57 <Tekmo> Sagi: Maybe you need to explain a little more the context in which that function is used
08:27:14 <Sagi> but I get a bit confused as soon as you start using transformers, because it feels like more than I need.
08:27:43 <Sagi> let me paste an example
08:29:19 <Sagi> http://lpaste.net/98821
08:30:23 <Sagi> so what I want, is work in the Maybe monad, so I have the convenience of 'short-circuiting' on lines 23-27
08:30:44 <Sagi> but at the same time I occasionally need access to the NMLReader
08:30:52 <Tekmo> Sagi: That's what `MaybeT` does
08:30:53 <mm_freak_> Tekmo: i final optimization i managed to do was to replace the chunk size
08:31:06 <Tekmo> Sagi: Note that you don't have t ochange the type of `extendPath`
08:31:10 <Tekmo> Sagi: You keep its type the same
08:31:11 <mm_freak_> Tekmo: reading from stdin using hGet with 6144 bytes seems faster
08:31:23 <Sagi> Tekmo: oh?
08:31:25 <Tekmo> Sagi: You just wrap your `do` block with `runMaybeT`
08:31:30 <Tekmo> Sagi: In other words:
08:31:41 <Sagi> :t runMaybeT
08:31:41 <lambdabot> Not in scope: `runMaybeT'
08:31:42 <Tekmo> extendPath p n = encoding n >>= \tech -> runMaybeT $ do
08:31:56 <Tekmo> Then everything from that point onward is like a local `MaybeT` windows
08:32:11 <Tekmo> Anytime you need to do a `MyReader` action, you just use `lift`
08:32:21 <Sagi> hmm, I'll try that
08:32:22 <Tekmo> lift :: NMLReader x -> MaybeT NMLReader x
08:32:35 <Tekmo> And then any action of type `NMLReader (Maybe x)` you wrap in `MaybeT`
08:32:47 <Tekmo> MaybeT :: NMLReader (Maybe x) -> MaybeT NMLREader x
08:32:57 <Tekmo> Then `MaybeT` will automate all the short-circuiting
08:33:08 <Tekmo> `runMaybeT` then just unwraps it so that you are back to your original `NMLReader` type
08:33:10 <Sagi> somehow I always thought monad transformers were only used 'up front'
08:33:18 <Tekmo> Sagi: No, you can use them locally, too
08:33:29 <Sagi> thanks for explaining this so clearly, I'll take a moment to think about this and change my code.
08:33:37 <Tekmo> Sagi: You're welcome
08:33:41 <Sagi> and wrap my head around it :-)
08:33:43 <Tekmo> :)
08:34:57 <whoami_> do x; y. desugars to x >> y, and do a <- x; y a;  to x >>= y. but what about let? it has different syntax in do than outside of it
08:35:53 <merijn> whoami_: "do { a <- x; y a }" desugars to "x >>= \a -> y a"
08:35:54 <Tekmo> Outside of a do block the desugaring is: `let x = y in expr` desugars to `(\x -> expr) y` (sort of)
08:36:08 <Tekmo> With caveats: let actually does more since it allows recursive definitions
08:36:22 <Tekmo> OCaml distinguishes recursive and non-recursive lets for this reason, I think
08:36:33 <whoami_> merijn: which is x >>= y no?
08:36:34 <merijn> whoami_: See here: https://en.wikibooks.org/wiki/Haskell/do_Notation
08:37:03 <merijn> whoami_: Essentially, but if you do it recursively mine behaves as expected if you have multiple uses of "a" inside 'y' :)
08:37:27 <merijn> whoami_: i.e. what if you have "do { a <- x; y a; z a }"
08:37:36 <whoami_> yeah got it
08:37:59 <merijn> whoami_: That desugars as "x >>= \a -> do { y a; z a }" which is "x >>= \a -> y a >> z a"
08:38:08 <whoami_> Tekmo: what does it mean that let allows recursive definitions?
08:38:24 <merijn> > let ones = 1 : ones in ones
08:38:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
08:38:31 <merijn> That
08:38:34 <whoami_> ah
08:39:26 <dwcook> > let a = 'a':b ; b = 'b':a in a -- also mutual recursion
08:39:27 <lambdabot>  "abababababababababababababababababababababababababababababababababababababa...
08:41:34 <whoami_> dwcook: ok that is confusing :]
08:41:55 <Tekmo> whoami_: Think of it as being identical to: let a = 'a':'b':a in a
08:41:58 <mm_freak_> Tekmo: 'let' does not desugar in haskell, except as an optimization
08:42:08 <Tekmo> mm_freak_: Right, it's just a conceptual explanation
08:42:36 <mm_freak_> i'd explain 'let' simply as a binder =)
08:42:59 <whoami_> mm_freak_: isnt it correct to say that do let x = 1; ...  desugars to let x = 1 in do ...?
08:43:13 <whoami_> are those equal?
08:43:22 <hpc> yes
08:43:24 <mm_freak_> whoami_: that's correct, but that's a different 'let' =)
08:44:37 <Tekmo> Alright, I have to head out.  If you have any further questions, Sagi, you can email me at Gabriel439 at gmail
08:46:22 <dwcook> Oh neat, didn't realize that was Gabriel Gonzalez's handle
08:48:29 <whoami_> mm_freak_: different let? I dont get it
08:48:49 <kstt> hi. My function must read and validate input from a form. If everything is valid, the function can produce a data of type Value. Else, it will just fail. The function will therefore return a 'Maybe Value'. I want to take advantage of the Maybe applicative instance, to keep code short and expressive. However, form field must be accessed through IO. What should I do to both read the form fields and apply validation with the Maybe
08:48:49 <kstt> monad/applicative rules ?
08:49:04 <sipa> whoami_: 'let' inside do blocks is indeed syntactic sugar
08:49:49 <merijn> kstt: You probably want to use the MaybeT monad transformer
08:50:02 * hackagebot haste-compiler 0.2.10 - Haskell To ECMAScript compiler  http://hackage.haskell.org/package/haste-compiler-0.2.10 (AntonEkblad)
08:50:11 <merijn> kstt: "MaybeT IO" let's you combine IO's >>= together with Maybe's >>=
08:50:19 <kstt> Probably, and that's what I try actually. But I'm getting headaches at the moment.
08:50:46 <kstt> Do you have a good exemple to point me to please, so that I could take inspiration from it ? Thank you.
08:54:32 <kstt> Let's say I have a Value constructor and a 'validate' function. Can I write something like : Value <$> (validate <$> liftIO (readField form)) ?
08:54:38 <kstt> This is the form I'd like
08:59:04 <Sagi> merijn: would you be willing to have a look at some of the errors I get while trying to move to usage of MaybeT? (I'll lpaste them)
08:59:18 <Sagi> I'm having a hard time understanding why it doesn't stop nagging :-)
08:59:55 <mm_freak_> whoami_: the 'let' you use in do-blocks is syntactic sugar…  it translates into "the real" let
09:00:16 <mm_freak_> (do let x = y; c) = (let x = y in c)
09:00:27 <mm_freak_> (do let x = y; c) = (let x = y in do c)
09:01:01 <mm_freak_> whoami_: the real let however is primitive…  it's not syntactic sugar for something else
09:01:29 <whoami_> yeah I was talking about do let
09:10:04 * hackagebot cabal2nix 1.59 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.59 (PeterSimons)
09:15:04 * hackagebot xmlhtml 0.2.3.2 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.3.2 (DougBeardsley)
09:22:34 <veg4n> Hey Guys. Is anyone here familiar with the http-conduit package and using proxies with it? Help would be much appreciated.
09:24:06 <Cale> veg4n: I don't really know much about it, but I can guess from the documentation how you'd set it up
09:25:21 <Cale> (i.e. just modify your Request by setting the proxy field with a value of type Proxy before actually making it.)
09:25:43 <Cale> Or use  addProxy :: ByteString -> Int -> Request -> Request
09:27:03 <startling> is there a data App f a = App (f a) somewhere?
09:27:10 <startling> oh, is that IdentityT?
09:27:52 <startling> yep, guess so.
09:28:28 <veg4n> Cale: Right now i have something like req <- parseUrl <url>; let req' = addProxy (B.pack "<myproxy>") <myport> req
09:29:29 <veg4n> Cale: Is this how it's inteded to be used? I don't know why, but right now I'm really struggeling with this small problem ..
09:29:30 <Cale> veg4n: looks good
09:31:43 <pranz> :t over
09:31:44 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
09:34:34 <mknight_> MKRAND - A Quantum Cellular Randomness Well : http://www.tag.md/public/mkrand-TA1.tar.gz
09:35:06 * hackagebot haskell-pdf-presenter 0.2.5 - Tool for presenting PDF-based presentations.  http://hackage.haskell.org/package/haskell-pdf-presenter-0.2.5 (MichaelAdams)
09:40:46 <veg4n> Cale: I'm really not getting how to use the Request to get an actual response. The example really isn't helping me either
09:41:44 <veg4n> I'm trying to do the exact same thing as in the example (the \manager -> …  part) but it doesn't seem to work
09:41:54 <Cale> What happens?
09:42:15 <Cale> Does the code run, or are you getting a compile error?
09:42:29 <Cale> Does the same thing work if you don't have a proxy?
09:43:12 <veg4n> Well, it compiles but tells me "<appname> Network/HTTP/Client/Manager.hs:(334,9)-(336,45): Non-exhaustive patterns in case"
09:43:34 <veg4n> When I run the project
09:44:50 <veg4n> For the manager-part I basically just copied the first example from the docs using withManager
09:45:50 <ocharles> bergmark: thanks!
09:47:25 <Cale>         case (secure req, useProxy) of
09:47:25 <Cale>             (False, _) -> mRawConnection m
09:47:25 <Cale>             (True, False) -> mTlsConnection m
09:47:25 <Cale>             -- FIXME (True, True) -> getSslProxyConn (checkCerts m h) (clientCertificates req) h (port req)
09:47:27 <Cale> ^^ lol?
09:47:55 <zomg> Seems legit
09:48:29 <Cale> veg4n: You can safely say this is a bug in the library
09:50:46 <Cale> veg4n: Do you have to use http-conduit? Maybe you could get by just using HTTP?
09:51:24 <veg4n> Cale: Well, that's kind of good I guess :D At least it doesn't seem to be my fault
09:51:57 <veg4n> I'm going to give Network.HTTP a try, thanks for you kind help :)
09:52:06 <veg4n> (and sorry for my bad english)
09:53:39 <Cale> veg4n: Your English is fine :)
09:55:11 <pranz> @pl ((on (+) xpos c1 c2), (on (+) ypos c1 c2))
09:55:11 <lambdabot> (on (+) xpos c1 c2, on (+) ypos c1 c2)
09:55:30 <pranz> @pl \c1 c2 -> ((on (+) xpos c1 c2), (on (+) ypos c1 c2))
09:55:30 <lambdabot> ap (ap . ((,) .) . on (+) xpos) (on (+) ypos)
09:57:32 <Kaidelong> please don't actually do that
09:58:40 <joelteon> so does configurator just support reading from config files, not writing to them?
10:05:08 * hackagebot heist 0.13.0.6 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.0.6 (DougBeardsley)
10:09:18 <cschneid> warning: missing terminating ' character [-Winvalid-pp-token] parseM a al'
10:09:19 <cschneid> Why does ghc  complain about a single tick character:
10:09:45 <cschneid> hmm, that came out of order. But anyway, how do I make ghc be quiet about single ticks in function and var names.
10:10:31 <geekosaur> cschneid: you are on OS X with xcode 5, right?
10:10:38 <cschneid> geekosaur: am indeed
10:10:39 <geekosaur> that is not ghc complaining, it is clang's cpp
10:10:40 <cschneid> is it just that
10:10:44 <geekosaur> see the end of the /topic
10:10:51 <geekosaur> ghc expects gcc's cpp
10:11:09 <cschneid> ok
10:11:12 <geekosaur> xcode 5 does not have gcc, it emulates gcc imperfectly with clang
10:11:13 <cschneid> everything seems to work anyway
10:11:25 <geekosaur> clang's cpp is more pedantic than gcc's cpp
10:11:40 <geekosaur> (really, non-C stuff has no business using C's preprocessor)
10:11:44 <Tinned_Tuna> <flamebait> Why would anyone still use gcc over clang? </flamebait>
10:12:43 <geekosaur> Tinned_Tuna, ghc is using a C preprocessor to preprocess Haskell. my opinion is that that is prima facie insanity; why should a C preprocessor have any clue what to do with Haskell source
10:13:15 <cschneid> geekosaur: why has that persisted. A preprocessor can be cool, but why the C one still?
10:13:39 <geekosaur> because too much code already used it, and cpphs has the wrong license for general use
10:13:56 <cschneid> so just inertia at this point. Makes some sense
10:14:06 <geekosaur> presently, CPP is really the only way to deal with e.g. changing library versions
10:14:19 <geekosaur> it would be nice if we had a better way to deal with this, but.
10:14:57 <startling> are there lattices somewhere?
10:14:57 <geekosaur> at this point it'd take years to get an alternative (that didn't behave just like gcc's cpp) into wide use
10:15:44 <startling> or semilattices at least.
10:16:19 <Cale> http://hackage.haskell.org/packages/search?terms=lattice
10:16:32 <startling> right, searching.
10:16:53 * startling is writing a type-checker, is generalizing 
10:18:34 <lispy> geekosaur: if we had a Haskell-aware replacement for CPP that I could 'cabal-install' I'd start using it today.
10:18:49 <geekosaur> there is one. GPL.
10:18:57 <lispy> gpl?
10:19:17 <lispy> That's not very google-able
10:19:26 <startling> cpphs
10:19:30 <startling> it's GPL, so people don't use it.
10:19:32 <sm> LGPL
10:19:50 <startling> it's LGPL, so people don't use it.
10:20:01 <lispy> Isn't cpphs still just cpp?
10:20:11 <geekosaur> the consensus is that code processed with it generates code covered by the GNU Lesser General Public License and is not entirely compatible with the largely BSD-licensed Haskell ecosystem since code generation cannot be covered by replacing libraries
10:20:22 <Clint> i should use it
10:20:30 <geekosaur> it's the parts of cpp that we care about (mostly #if/#ifdef stuff)
10:20:40 <geekosaur> without the C-specific stuff we don't
10:20:56 <lispy> Are the .S files that gcc generates covered by the GPL?
10:21:06 <Clint> no
10:21:12 <lispy> Why should the .hs output of cpphs be covered by the LGPL?
10:21:25 <geekosaur> I think progressing beyond that is going to require more than someone tossing soemthing onto hackage, it's going to require consensus in the libraries community over better ways to deal with compatibility issues
10:21:53 <startling> right, using macros for library stuff is a hack anyway.
10:22:02 <geekosaur> lispy, I do not know the details, but I do know that ghc hq and many developers do not want to trust to license issues
10:22:12 <geekosaur> and have refused to use cpphs as a result
10:22:51 <geekosaur> (note that significant parts of the ghc runtime still use LANGUAGE CPP, even though there is ongoing work to remove e.g. the NHC98 compatibility stuff that is in base)
10:23:24 <geekosaur> (if nothing else, win32 vs. unix requires a fair amount of conditional code)
10:23:26 * startling pictures GHC HQ as a retrofuturistic laboratory with people furiously typing on keyboards
10:25:33 <Kaidelong> cpphs?
10:27:21 <joelteon> has anybody written a ConcurrentState monad that uses a TVar as the state holder
10:27:23 <joelteon> that would be cool
10:27:56 <Kaidelong> joelteon: isn't that what Orc is?
10:28:07 <Kaidelong> a concurrent state monad using TVar internally
10:28:19 <joelteon> what is that?
10:28:42 <Kaidelong> http://hackage.haskell.org/package/orc
10:29:08 <joelteon> I don't think so, is it?
10:29:42 <Kaidelong> mm, might have been something else like TChan or MVar but I'm pretty sure it was TVar that it used
10:30:28 <Kaidelong> http://hackage.haskell.org/package/stm
10:30:31 <Kaidelong> it uses this
10:30:46 <joelteon> doesn't look like a general-purpose state monad though
10:31:05 <Kaidelong> no it's IO specific because it can do nondet concurrency
10:31:22 <joelteon> right but it doesn't even have a statelike interface
10:31:31 <Kaidelong> but doesn't anything using a TVar have to be in IO?
10:31:44 <joelteon> it has to be in MonadIO
10:31:46 <joelteon> I think
10:31:59 <Cale> It has to be in STM
10:32:10 <joelteon> you can atomically perform it in MonadIO
10:32:12 <Cale> and then in order to run an STM transaction, you use atomically
10:32:16 <Cale> :t atomically
10:32:16 <lambdabot> Not in scope: `atomically'
10:32:17 <Kaidelong> which effectively means in IO because MonadIO guarantees (MonadIO m) => IO t -> m t
10:32:19 <joelteon> Orc doesn't have a modify primitive
10:32:26 <joelteon> for example
10:32:41 <Cale> atomically :: STM a -> IO a
10:32:47 <joelteon> I'm thinking of a drop-in replacement for State, replacing StateT s ... with Statet (TVar s) ...
10:32:55 <Tinned_Tuna> atomically is like god mode for mutability
10:40:30 <killy9999> thoughtpolice: ping
11:01:37 <rosslazer> Has anyone built cabal on the Raspberry Pi?
11:01:54 <rosslazer> I ran the bootstrap.sh script but keep getting an error with the getNumberOfProcessors function
11:02:19 <Maior> rosslazer: mjga and I are just talking about that
11:02:24 <Maior> fsvo "just"
11:02:50 <rosslazer> Maior I saw something on a Japanese GIST about changing some GCC settings but it didn't work for me
11:03:05 <rosslazer> Maybe because I had already compiled some stuff. Is there a clean function for bootstrap?
11:03:12 <Maior> rosslazer: er, pass, sorry
11:03:20 <Maior> currently more looking at ghci-pi
11:03:34 <rosslazer> Maior so I will take it you guys didn't have any luck?
11:04:06 <Maior> rosslazer: not at that stage yet
11:06:09 <rosslazer> Has anyone else gotten cabal on RPi working?
11:06:21 <rosslazer> If so let me know so I can make a doc for others
11:18:26 <rosslazer> anyone?
11:20:30 <Cale> rosslazer: It might also be worth asking on the mailing lists if you don't get a response here
11:20:49 <rosslazer> Thanks I just want to get LambdaBot running on my Pi
11:20:58 <Cale> rosslazer: I vaguely recall some chatter about it, but I don't really remember what was said.
11:21:48 <verement_> rosslazer: I seem to be able to use the cabal from Debian
11:22:48 <rosslazer> verement_ with an apt-get install cabal-install?
11:24:31 <verement_> rosslazer: yes, in my case it was installed as a dependency of haskell-platform
11:27:18 <rosslazer> verement_ Thanks I'm trying that now and it seems to be working +1
11:29:11 <mjga> rosslazer: yes there is Cabal and GHC on Raspbian, but without GHCi
11:29:25 <rosslazer> mjga It uses LLVM?
11:34:43 <klrr_> @pl \x y -> (x,y)
11:34:43 <lambdabot> (,)
11:35:29 <NemesisD> guys, i'm having really weird issues in the past few weeks where sandboxed cabal builds tell me that some datatype doesn't have an instance, but when I look up the haddocks for that code, it obviously defines it
11:35:34 <NemesisD> has anyone encountered that?
11:36:30 <hpc> are you looking up the right version?
11:37:02 <rosslazer> How do you configure Lambdabot? Is there a conf file somewhere if I installed it with cabal
11:37:04 <rosslazer> ?
11:37:14 <hpc> in particular, using a less recent ghc will give you a less recent base, which makes cabal pick a less recent almost-everything
11:37:44 <jle`> NemesisD: is it different data types every time?
11:38:05 <NemesisD> hpc: AFAICT yes. i looked in .cabal-sandbox/x86.../ and it is the version i'm looking up on hackage
11:38:30 <hpc> rosslazer: lambdabot is a huge pain; you probably should download the tarball, edit whatever files, and use cabal-dev
11:38:48 <rosslazer> hpc Think I should use a different IRC bot?
11:38:51 <hpc> NemesisD: hmm
11:38:52 <NemesisD> jle` it isn't random between builds
11:39:06 <hpc> rosslazer: well, it's good practice for other packages
11:40:12 <hpc> if you can manage a lambdabot instance, very few other projects will give you trouble
11:42:34 <NemesisD> this same thing happened with Validations and now it is happening with Groundhog
11:42:46 <NemesisD> every time i'm starting with a fresh cabal sandbox
11:44:17 <NemesisD> annoyingly, in cabal repl, i load that module and call :i on the typeclass and I can *SEE* the class it says doesn't exist
11:44:59 <NemesisD> oh wait no, after reloading repl, it shows no instances!
11:45:02 <NemesisD> wtf
11:46:02 <NemesisD> bah. its because groundhog stores instances in a separate module
11:46:46 <defanor> i'm going to practice haskell, want to write something like a console adventure game (i think it's a nice thing to play with types), but not sure how to model a world: i'll have a bunch of world objects of different types, with only common typeclasses. should i make smth similar to Either, but for a bunch of objects to apply functions like 'evaluate' to all the world objects at once, or is there some proper way to do such things?
11:47:33 <c_wraith> defanor: a type class is almost certainly the wrong thing to use there.  Don't treat them as anything like OO classes
11:47:51 <mmmm> you probably want to use record notation
11:48:14 <defanor> c_wraith: i thought to rely on them, to have that "evaluate" function. what should be used then?
11:48:20 <c_wraith> defanor: records of functions are much closer to OO classes.
11:48:32 <mmmm> what type do you want evaluate to have?
11:49:01 <defanor> like, say, "animal"
11:49:17 <defanor> and concrete types "cat", "dog", etc
11:49:50 <defanor> i'm not sure if i want to model OO classes here, just want to figure out what's the proper way to do such things
11:50:06 <mmmm> Use records and the lens library
11:50:18 <defanor> will check it, thanks
11:51:02 <startling> have I missed any obvious instances? https://gist.github.com/startling/ef904636a1d7b1befc16
11:51:14 <mmmm> You probably want a datatype "World" which holds all the information about the game
11:51:17 <c_wraith> I'm not sure I'd use the lens library on a first pass.  It's too easy to misuse when you don't have a good idea what you're doing.
11:51:27 <mmmm> nested records without it is eh
11:51:32 <mmmm> bit I see your point
11:51:34 <startling> I'm not convinced Monad and Applicative are possible, but I hope I'm wrong.
11:51:38 <alpounet> c_wraith: and the errors won't help a beginner heh
11:52:12 <defanor> mmmm: yep, a world type is planned too
11:52:13 <cory786> can anyone explain why the zip function can take two ranges but not for instance take 5 (repeat 5) in the example http://learnyouahaskell.com/starting-out
11:52:19 <c_wraith> startling: isn't that FreeT over your Abstract type?
11:52:26 <defanor> k, will be careful with lens and will try to use records. thanks
11:53:02 <startling> c_wraith: it might be. that would be useful.
11:53:08 <cory786> so zip [1..5] take 5 (repeat 5), instead of zip [1..5]  [5,5,5,5,5,]
11:54:25 <dmwit> How about replicate 5 5 instead of take 5 (repeat 5)?
11:54:26 <mmmm> Your brackets are in the wrong place cory786
11:54:48 <FreeFull> I have attempted to implement "Chinese Whispers" in Haskell, and I'm getting "thread blocked indefinitely in an MVar operation" when I run it. The print outputs once before it happens. Here is the code, what's wrong with it? http://lpaste.net/8332946542398799872
11:55:05 <c_wraith> startling: it looks like it probably is, though it might need a bit of rearranging to get there.  I'm only starting to think about free monads
11:55:33 <c_wraith> FreeFull: so I'm not the only one who saw that benchmark and thought "I wonder how haskell/GHC does on that"
11:55:41 <cory786> <mmmm> how so?
11:55:42 <startling> c_wraith, I don't think so; Abstract needs to have the parameters separated in order for Scope to work.
11:55:56 <dmwit> cory786: You need parentheses around (take 5 (repeat 5)).
11:56:07 <dmwit> > zip [1..5] (take 5 (repeat 5))
11:56:08 <lambdabot>  [(1,5),(2,5),(3,5),(4,5),(5,5)]
11:56:10 <startling> I've been aware of Free for a while but haven't seen FreeT at all; thanks for pointing it out to me!
11:56:13 <dmwit> > zip [1..5] (replicate 5 5)
11:56:13 <cory786> dmwit, because I did not know about it ;)
11:56:14 <lambdabot>  [(1,5),(2,5),(3,5),(4,5),(5,5)]
11:56:52 <mmmm> so the zip function is trying to zip together [1..5] and the function take
11:57:30 <dmwit> FreeFull: Perhaps you meant to forkIO (whisper left right).
11:57:41 <FreeFull> dmwit: Oh, yes, yes I did
11:57:43 <FreeFull> Stupid error
11:57:48 <c_wraith> FreeFull: that looks to have the same structure as (though a slightly different goal than) the debian benchmark shootout's thread ring problem
11:58:28 <c_wraith> FreeFull: you might want to look into the haskell implementation of that. It's one where GHC was destroying even C, until someone implemented a C version with its own custom threading in order to match what the problem asked for.
11:58:43 <FreeFull> Now it works
11:59:20 <startling> c_wraith: oh, I see. it's newtype TermT f a = TermT (FreeT (Abstract (TermT f)) f a).
11:59:23 <startling> that's a mouthful.
11:59:35 <startling> uh, maybe not.
11:59:48 <startling> yeah, that is very wrong.
12:00:13 <cory786> dmwit, thanks, it appears that I tried surrounding it initially but forgot the 5 after take ;P
12:00:25 <FreeFull> Slower than the Go version though
12:00:29 <c_wraith> FreeFull: http://benchmarksgame.alioth.debian.org/u32/program.php?test=threadring&lang=ghc&id=1   Actually looks closer than I thought, in purpose
12:01:11 <FreeFull> I probably didn't use the most efficient implementation
12:01:34 <FreeFull> I just used what seemed the closest to the Go/Rust code from http://thornydev.blogspot.co.uk/2014/01/chinese-whispers-in-rust.html
12:01:57 <c_wraith> FreeFull: well, I'm just pointing that out in case there's something you want to steal from that implementation
12:05:19 <FreeFull> c_wraith: If I wanted a more efficient implementation, the first step probably would be using MVars directly instead of Chan
12:05:52 <startling> c_wraith: yeah, I'd need something like data Free f g a = Pure (g a) | Free (g (f (Free f g) a))
12:06:07 <c_wraith> startling: ah, so it's a bit different
12:06:46 <startling> c_wraith: just a tiny, annoying bit.
12:08:02 <startling> it's sort of a higher-kinded recursion than Free.
12:08:20 <benzrf> @hoogle Functor f => (a -> f a) -> f b -> Bool
12:08:21 <lambdabot> Control.Seq withStrategy :: Strategy a -> a -> a
12:08:21 <lambdabot> Control.Parallel.Strategies withStrategy :: Strategy a -> a -> a
12:08:21 <lambdabot> Control.Parallel.Strategies using :: a -> Strategy a -> a
12:08:27 <benzrf> o:
12:09:01 <startling> I guess data Fixes f g a = Fixes (g (f (Fixes g) a)) would do it, too. I wonder if that exists.
12:09:15 <startling> Or if it has any useful instances.
12:09:22 <c_wraith> well, edwardk is around.  He'd know. :)
12:10:03 <c_wraith> benzrf: I'm having troulbe seeing what that'd be...
12:10:04 <benzrf> > let ceq c v = (c ()) == (() <$ v) in Just `ceq` Just 3
12:10:05 <lambdabot>  True
12:10:10 <benzrf> > let ceq c v = (c ()) == (() <$ v) in Just `ceq` Nothing
12:10:11 <lambdabot>  False
12:10:21 <benzrf> > let ceq c v = (c ()) == (() <$ v) in Nothing `ceq` Nothing
12:10:22 <lambdabot>  Couldn't match expected type `() -> Data.Maybe.Maybe ()'
12:10:23 <lambdabot>              with actual type `Data.Maybe.Maybe a0'
12:10:25 <benzrf> :|
12:10:58 <startling> :t (\_ _ -> True) :: Functor f => (a -> f a) -> f b -> Bool
12:11:01 <lambdabot> Functor f => (a -> f a) -> f b -> Bool
12:11:09 <benzrf> ha
12:11:12 <c_wraith> benzrf: I think you could do what you want to do with prisms
12:11:21 <benzrf> > let ceq x y = (() <$ x) == (() <$ y) in Just 3 `ceq` Nothing
12:11:22 <lambdabot>  False
12:11:24 <startling> oh, should there be a forall in there?
12:11:27 <benzrf> > let ceq x y = (() <$ x) == (() <$ y) in Nothing `ceq` Nothing
12:11:28 <lambdabot>  True
12:11:33 <c_wraith> benzrf: in fact, if I read your intended purpose correctly, that's exactly what prisms are for
12:11:38 <benzrf> oh
12:11:42 <startling> oh, you need Eq, too?
12:11:47 <c_wraith> > Nothing ?^ _Just
12:11:47 <lambdabot>  Not in scope: `?^'
12:11:48 <lambdabot>  Perhaps you meant one of these:
12:11:48 <lambdabot>    `^' (imported from Prelude), `^^' (imported from Prelude),
12:11:48 <lambdabot>    `??' (imported from Control.Lens)
12:11:50 <benzrf> its k
12:11:57 <c_wraith> heh.  I can't remember the name of anything ever
12:12:03 <c_wraith> > Nothing ^>? _Just
12:12:03 <lambdabot>  Not in scope: `^>?'
12:12:04 <lambdabot>  Perhaps you meant one of these:
12:12:04 <lambdabot>    `^>>' (imported from Control.Arrow),
12:12:04 <lambdabot>    `^!?' (imported from Control.Lens),
12:12:04 <lambdabot>    `^?' (imported from Control.Lens)
12:12:06 <c_wraith> ... ever
12:12:06 <benzrf> :t (??)
12:12:07 <lambdabot> Functor f => f (a -> b) -> a -> f b
12:12:09 <startling> > Nothing ^? Just
12:12:10 <lambdabot>  Couldn't match type `Data.Maybe.Maybe
12:12:10 <lambdabot>                         (a0
12:12:11 <c_wraith> > Nothing ^? _Just
12:12:11 <lambdabot>                          -> Control.Lens.Internal.Getter.Accessor
12:12:14 <lambdabot>                               (Data.Monoid.First a0) a0)'
12:12:15 <lambdabot>  Nothing
12:12:17 <startling> > has _Just Nothing
12:12:18 <lambdabot>                with `Data.Maybe.Maybe a1
12:12:19 <lambdabot>  False
12:12:21 <benzrf> wait what
12:12:23 <c_wraith> > Nothing ^? _Nothing
12:12:24 <benzrf> hold on
12:12:24 <startling> > preview _Just Nothing
12:12:25 <lambdabot>  Just ()
12:12:26 <lambdabot>  Nothing
12:12:32 <benzrf> :t (??)
12:12:32 <lambdabot> Functor f => f (a -> b) -> a -> f b
12:12:38 <benzrf> :t (<*>)
12:12:39 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:12:39 <c_wraith> > Just 20 ^? _Just
12:12:41 <lambdabot>  Just 20
12:12:45 <benzrf> oh
12:13:08 <startling> > Left 20 ^? _Left
12:13:09 <benzrf> @djinn Maybe (a -> b) -> a -> Maybe b
12:13:09 <lambdabot> f a b =
12:13:09 <lambdabot>     case a of
12:13:09 <lambdabot>     Nothing -> Nothing
12:13:09 <lambdabot>     Just c -> Just (c b)
12:13:10 <lambdabot>  Just 20
12:13:18 <benzrf> interesting
12:13:28 <benzrf> > Just (+3) ?? 4
12:13:30 <lambdabot>  Just 7
12:13:33 <startling> :t (+) ?? 2
12:13:33 <lambdabot> Num a => a -> a
12:13:35 <benzrf> > Nothing ?? 4
12:13:36 <lambdabot>  Nothing
12:13:49 <benzrf> >3
12:13:51 <benzrf> > 3
12:13:52 <startling> :t liftM ?? Nothing
12:13:52 <lambdabot>  3
12:13:52 <lambdabot> (a1 -> r) -> Maybe r
12:13:59 <benzrf> wat
12:14:07 <startling> the (->) r Functor.
12:14:08 <benzrf> these types are screwin with my brain
12:14:16 <sqrt2_> http://pastebin.com/emVprKYA boggles my mind
12:14:18 <mauke> The paste emVprKYA has been copied to http://lpaste.net/98827
12:14:23 <benzrf> > Right (+1) ?? 2
12:14:24 <lambdabot>  Right 3
12:14:25 <c_wraith> benzrf: anyway, assuming that what you really wanted was constructor equality, that's what preview and prisms are for
12:14:26 <benzrf> > Left (+1) ?? 2
12:14:27 <lambdabot>  Left <Integer -> Integer>
12:14:30 <benzrf> huh
12:14:31 <sqrt2_> why is isPrime not an infinite recursion?
12:14:35 <benzrf> c_wraith: ok
12:14:47 <benzrf> sqrt2_: i am examining the link which you typed in'
12:14:49 <startling> benzrf: the idea was "let's have an operator that looks like a blank space so we can reorder arguments nicely" but then someone generalized it.
12:15:30 <benzrf> sqrt2_: why would it be infinite recursion?
12:16:03 <sqrt2_> a more precise question is, how is primes in isPrime defined, when to evaluate it means to evaluate isPrime
12:16:07 <benzrf> also that code is probably cleverer than anything i could come up with
12:16:11 <sqrt2_> i assume it's [2] when isPrime 3 is called
12:16:12 <benzrf> sqrt2_: lazy eval
12:16:19 <sqrt2_> yes, but how exactly does it work?
12:16:25 <benzrf> work it out in your mind
12:16:26 <benzrf> :D
12:16:31 <sqrt2_> i'm trying, i can't
12:16:36 <startling> lazy evaluation doesn't have much to do with it.
12:16:41 <sqrt2_> why does haskell know it only needs to look at the first element in the list?
12:16:46 <c_wraith> it doesn't know
12:16:48 <benzrf> because you do not use the other one
12:16:55 <benzrf> so it never tries
12:16:59 <c_wraith> It just follows directions
12:17:17 <benzrf> sqrt2_: do you know what a thunk is?
12:17:22 <sqrt2_> no
12:17:35 <benzrf> it is basically a delayed calculation
12:17:36 <sqrt2_> i'm very new to haskell
12:17:52 <benzrf> in languages other than haskell where you do it manually, a thunk might look like an argsless lambdabot
12:17:55 <benzrf> *lambda
12:18:05 <benzrf> which lets you delay calculating the result until you need it
12:18:37 <startling> c_wraith: I'm beginning to think comonads are the thing.
12:18:42 <benzrf> in haskell's implementation as far as I understand, if you say '1:func 2', it will be stored as '1:<evaluate this to find out the rest>'
12:18:55 <benzrf> then if you match on x:xs, x will be 1
12:19:00 <sqrt2_> ok, let me phrase a more precise question
12:19:04 <benzrf> xs will be left pointing to the unevalled thunk until it is needed
12:19:16 <c_wraith> sqrt2_: I think the most important part there is what the expression primes actually refers to..  It's a pointer to a list constructor, (:). The list constructor has two arguments.  The first one is 2.  The second one is the rest of the list, which is...  well, it's not evaluated yet, because it's a function call.
12:19:45 <sqrt2_> what gets called is isPrimeHelper [3..] [2, <morethings>]
12:19:56 <sqrt2_> so we end up at the otherwise branch
12:20:04 <sqrt2_> oh wait, we don't
12:20:23 * hackagebot tagsoup 0.13.1 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.13.1 (NeilMitchell)
12:20:25 <c_wraith> actually, it's just isPrimeHelper 3 [2, <morethings>]
12:20:34 <sqrt2_> ah yes
12:20:38 <c_wraith> the first argument is the single value being tested, not the whole list
12:20:57 <benzrf> sqrt2_: we can solve without needing to figure out what <morethings> is in the case of 3
12:21:05 <benzrf> so it isn't evaluated until we need to
12:21:11 <defanor> is it possible to make data derive Show by default? and why it doesn't, btw?
12:21:12 <benzrf> and 3 becomes the next one
12:21:14 <sqrt2_> yes, i was thinking it would end up at otherwise immediately
12:21:16 <sqrt2_> but it doesn't
12:21:25 <benzrf> defanor: you can, as long as all of the fields' types also derive show
12:21:33 <benzrf> and im not sure its possible for parameterized types
12:21:37 <c_wraith> defanor: some types can't derive show.  That's why it's not the default - it wouldn't actually work.
12:21:39 <benzrf> no wait yep it is
12:21:57 <startling> is there a class with extract and pure?
12:22:07 <defanor> oh, thanks
12:22:48 <benzrf> g2g thx
12:23:24 <c_wraith> startling: There wouldn't be many things that have both of those
12:23:48 <startling> c_wraith, yeah, I'm aware.
12:24:21 <startling> it's "things that you can add or forget information about"
12:24:50 <dmwit> I don't think that's why it's not the default.
12:25:12 <sqrt2_> thanks for the help guys
12:25:17 <c_wraith> It'd have very limited law opportunity, too.  extract . pure = id, but..  pure . extract = id isn't a good law.
12:25:21 <dmwit> "Not an instance of any class" is a sane and uniform rule.
12:25:55 <dmwit> Of course, I wasn't on the committee, so I don't know for sure.
12:26:29 <kristof> Haskell seems to be a language that didn't suffer from "design by committee" woes, although I'm certainly not qualified to say anything about this
12:26:29 <startling> c_wraith: yeah, I think having both would just give you Identity.
12:26:56 <kristof> Maybe it's because they weren't juxtaposing old designs as much as they were treading the path for lazy, functional programming
12:27:00 <troydm> ok, going to try compiling ghc 7.6.3 on openindiana, let's see if it'll work
12:27:24 <c_wraith> startling: And with only the former, you haven't got much to rely on.  This is why pure and extract don't show up in classes alone - there just isn't enough meaning with them alone
12:27:29 <troydm> last time i've tried compiling it it was disaster
12:28:07 <startling> c_wraith, yeah, fair enough.
12:28:12 <geekosaur> I think last time I looked at doing that it involved first bootstrapping an intermediate version with the out of date available ghc
12:28:28 <startling> the thing is: my TermT Identity is a Monad. I'm trying to figure out which other things are, too.
12:29:38 <shachaf> c_wraith: Do you even need extract . pure = id?
12:29:52 <shachaf> (As a law, I mean. Don't you get that automatically?)
12:30:09 <mzero> sqrt2_: do you see that for any particular number, isPrime x only needs the front part of the list primes that is less than x
12:30:10 <mzero> ?
12:30:14 <startling> shachaf: we're not talking about Applicative and Comonad
12:30:25 <sqrt2_> mzero: i do now, yes
12:30:26 <c_wraith> shachaf: I suppose it is going to be automatic, unless one of them bottoms out
12:30:45 <c_wraith> startling: it was a question about parametricity, though.  You don't need to manually require it, you get it for free
12:30:54 <mzero> okay- they what you need to know is that when isPrime "passes" primes as an argument to isPrimeHelper
12:31:22 <startling> c_wraith: oh, I see. I thought shachaf meant from the Functor/Applicative/Comonad laws.
12:31:52 <mzero> it passes "lazily"
12:32:04 <mzero> that is, I doesn't need to evaluate primes at all
12:32:33 <mzero> it just says "here, here's a computation that is a list...." (loosly speaking)
12:33:04 <startling> do we have type-level sets yet? :x
12:33:19 <mzero> When isPrimeHelper "examines the list" by pattern matching (p:ps) against the list - then the first element of the list is "demanded" - and whatever computation is needed to get just that far is done
12:33:19 <eikke> mm_freak_: http://lpaste.net/98829
12:33:25 <startling> well, type-level lists and a type-level Elem
12:33:26 <mzero> (stop me if you know all this and see it now)
12:33:31 <eikke> mm_freak_: (remember discussion a couple of hours ago, and your assignment)
12:34:18 <fizbin> Can someone point me at what this "yield" function is that's being used in http://www.reddit.com/r/haskell/comments/1vcvxe/the_st_monad_and_conduit/cer0nra ?
12:35:12 <eikke> fizbin: http://hackage.haskell.org/package/conduit-1.0.11.1/docs/Data-Conduit.html#v:yield
12:35:25 <mzero> (or, sqrt2_ let me know it is helping)
12:35:52 <sqrt2_> mzero: i understand what's going on now, thanks
12:35:59 <mzero> cool
12:36:18 * mzero tends to over-explain :-)
12:36:23 <shachaf> startling: Oleg had that a decade ago or something.
12:36:56 <startling> shachaf, I changed my mind already.
12:37:06 <startling> I guess all I need is newtype Term x a = Term (x, (Abstract (Term x) a).
12:37:19 <sqrt2_> is there a way to say "filter until the first time you hit False, then stop"?
12:37:26 <startling> Then I get Monad and Applicative with Monoid x.
12:37:33 <c_wraith> sqrt2_: takeWhile ?
12:37:36 <startling> :t takeWhile
12:37:37 <lambdabot> (a -> Bool) -> [a] -> [a]
12:37:48 <sqrt2_> looks good, thanks
12:37:49 <c_wraith> sqrt2_: or do you want the first element that takeWhile would drop, too?
12:37:58 <c_wraith> > takewhile (< 5) [1..]
12:37:59 <lambdabot>  Not in scope: `takewhile'
12:37:59 <lambdabot>  Perhaps you meant one of these:
12:37:59 <lambdabot>    `takeWhile' (imported from Data.List),
12:37:59 <lambdabot>    `BSC.takeWhile' (imported from Data.ByteString.Char8),
12:37:59 <lambdabot>    `BSLC.takeWhile' (imported from Data.ByteString.Lazy.Char8)
12:38:05 <c_wraith> > takeWhile (< 5) [1..]
12:38:06 <lambdabot>  [1,2,3,4]
12:38:17 <sqrt2_> that is what i want, thanks
12:38:31 <c_wraith> Sometimes you want the first failing thing in the list, too.  Which isn't in the standard lib, sadly
12:46:56 <startling> so is newtype Fixes f a b = Fixes (a, f (Fixes x) b) anywhere? :)
12:47:04 * startling is desperately trying to avoid writing instances
12:48:27 <startling> oh, it works nicely with stuff from mmorph, hmmm
12:49:04 <triliyn> startling: hmmm, I was going to ask why that had a tuple argument instead of two arguments, but I guess newtype requires a single argument
12:49:27 <startling> triliyn: yeah, it works that way too.
12:49:39 <startling> it just seemed clearer to me this way.
12:50:11 <startling> triliyn: but good point. :)
12:50:15 <shachaf> What is x?
12:50:21 <startling> a Monoid, usually.
12:50:40 <startling> oh.
12:50:41 <shachaf> triliyn: So the next question is why it's newtype and not data.
12:50:56 <startling> yeah I spelled that wrong.
12:51:15 <startling> data Fixes f a b = Fixes a (f (Fixes f a b) b)
12:51:26 <triliyn> I wouldn't be surprised if tuples were ever-so-slightly smaller than non-newtype data constructors
12:51:50 <triliyn> But I wouldn't be surprised if they were the same size either
12:51:51 <shachaf> What is an example of f?
12:52:00 <triliyn> Either?
12:52:12 <startling> shachaf: https://gist.github.com/startling/ef904636a1d7b1befc16#file-abstract-hs-L15
12:52:13 <shachaf> They are the same size, unless you mean screen space.
12:52:19 <startling> triliyn: no, it's a different kind than either.
12:52:35 <triliyn> f (Fixes f a b) b
12:52:40 <triliyn> It seems like Either should fit there
12:53:06 <startling> oh, dang, I spelled it wrong again.
12:53:10 * startling got too excited.
12:53:16 <startling> data Fixes f a b = Fixes a (f (Fixes f a) b)
12:53:37 <triliyn> oh
12:53:51 <triliyn> So is that like... a monad transformer or similar?
12:54:03 <triliyn> Or wait
12:54:13 <triliyn> a is *
12:54:39 <startling> My Abstract is one. Scope x is another. If f is an MFunctor, you have Bitraversable etc. If a is a Monoid and f has some constraint, it's an Applicative and Monad
12:54:42 <bennofs> :k ReaderT
12:54:43 <lambdabot> * -> (* -> *) -> * -> *
12:55:12 <triliyn> no, that's not relevant. Fixes f a :: * -> *, f :: (* -> *) -> * -> *
12:55:34 <bennofs> Hmm, what does Fixes (ReaderT Int) a b look like?
12:55:35 <triliyn> Which is like monad transformers in the way I was thinking of
12:55:49 <triliyn> Though monad transformers are probably not the best comparison
12:56:01 <startling> bennofs, it's a kind error.
12:56:36 <roboguy_> startling: it is?
12:56:41 <joelteon> yeah, it's not a mean one
12:56:45 <bennofs> @let data Fixes f a b = Fixes a (f (Fixes f a) b)
12:56:47 <lambdabot>  Defined.
12:56:47 <joelteon> so don't you worry
12:57:10 <bennofs> :k Fixes
12:57:11 <lambdabot> ((* -> *) -> * -> *) -> * -> * -> *
12:57:11 <roboguy_> startling: it doesn't look like one and it didn't give me a kind error when I put it into ghci...
12:57:22 <bennofs> :k Fixes (ReaderT Int) Int Int
12:57:22 <lambdabot> *
12:57:30 <startling> oh, oops
12:57:35 <startling> interesting.
12:58:16 * startling feels dumb today
12:58:21 <bennofs> Oh, isn't that basically a ReaderT over a ReaderT over a ReaderT over a ... ?
13:00:24 <roboguy_> hmm, what about something like Fixes (TwistedUpStar a) b c where data TwistedUpStar d f c = UpStar (d -> f c)?
13:01:05 <startling> bennofs, yes
13:01:40 <startling> bennofs: I'm not sure it has any useful instances though
13:05:19 <defanor> http://paste.uberspace.net/game.hs.html -- now i have this, but i suspect it's ugly, especially that Animal'/Animal thing. the goal is to be able to map world's creatures with the grow function, and i'd appreciate if somebody will suggest what could be improved there
13:07:30 <defanor> age is copypasted now, and there's also going to be position
13:07:35 <StoneToad> is there an easy way to make attoparsec match up to N items?
13:08:26 <StoneToad> something like manyNM 0 15 foo
13:09:29 <BeardedCoder> StoneToad: I've not used attoparsec, but would count or many' be what you want?
13:10:20 <BeardedCoder> StoneToad: http://hackage.haskell.org/package/attoparsec-0.11.1.0/docs/Data-Attoparsec-Combinator.html
13:10:38 <StoneToad> hmm won't count only do exactly N times?
13:10:56 <BeardedCoder> There's other options in there.
13:11:49 <mzero> defanor: not bad - notice that Animal and Animal' are two different namespaces - the first is a type, the second a constructor. As such, you could name Animal' as Animal (without the tick)
13:12:47 <mzero> if you are going to have many common properties, and those are going to be treated the same (all living things age the same, all movable things move the same) then perhaps your factoring is not best -
13:12:59 <mzero> having to repeat age and position indicates some "isn't quite right"
13:13:18 <StoneToad> hmm guess that count is actually just a monad combinator
13:13:24 <defanor> mzero: yeah, i think so too, but want to find out what's the right way
13:13:39 <StoneToad> so I should be looking in the monad stuff for this, not attoparsec
13:13:48 <mzero> re: attoparsec: replicateM perhaps?
13:14:17 <defanor> what's the usual way to deal with common properties?
13:14:37 <mzero> make a common type!
13:15:39 <StoneToad> mzero: that's actually how count is defined: count n p = sequence (replicate n p)
13:15:55 <troydm> any experts on ghc building
13:16:16 <mzero> data Creature = Creature { age :: int, position :: Point3D, traits :: CreatureTraits }
13:16:16 <troydm> where can i find LD flags for Makefiles, configuration
13:16:19 <defanor> mzero: um, i've tried to make it: Creature. but probably i'm doing smth wrong
13:16:29 <defanor> mzero: oh, got it
13:16:32 <defanor> mzero: thanks
13:16:38 <mzero> data CreatureTraits :: Cat { ... } | Owl { ... } | | Plant { ... }
13:17:44 <mzero> You can replicate this pattern if there are sub-common traits shared by some creatures (Animal or Plant, say) --- but be careful to create the taxonomy your code needs - not the taxomony you think your HS Biiology teacher would like
13:17:47 <eikke> mm_freak_: hah, think I got it working! :-) thanks to your assignment
13:18:14 <mzero> (Or your CS OO Teacher!)
13:18:53 <defanor> mzero: heh, sure, but i'm going to try to make it easy-to-remember for myself first
13:19:03 <defanor> to make it handy to work with
13:19:04 <eikke> mm_freak_: http://lpaste.net/98830
13:20:42 <mzero> (When we were preaching OO, and treated like lunatics, we tended to over emphasize the taxonomy of classes. Later, when OO went mainstream, people took that emphasis as gospel, and made crazy deep heirarchies, despite that the code rarely needed it. Later, people measured well designed OO systems and discovered that the heirarchies were rarely deep. Or even more than one level!)
13:21:34 <defanor> i was never a fan of OO, so i hope i'm not in a risk group
13:23:12 <dhrosa> Dog inherits Canine inherits Mammal inherits Animal inherits Organism inherits Organic inherits Matter inherits ...
13:23:34 <Cale> You actually shouldn't encode OO ideas into Haskell like that most of the time
13:23:57 <Cale> Usually what you want is a type with one constructor that has all the methods
13:24:23 <Cale> and then "constructor" functions which take any private details as parameters to produce such a record
13:24:34 <Cale> (which are not literally data constructors)
13:25:31 <Cale> Most of the reason why you need subtyping in typed OO languages is because someone bizarrely decided that it would be a good idea to tie method implementations to the definition of the class.
13:25:40 <Cale> Rather than to the definition of the objects.
13:26:05 <dhrosa> I very much enjoy that method of OO in haskell
13:26:58 <ski> well, classes (a la OO) shouldn't be tied to typew
13:27:03 <ski> s/typew/types/
13:27:14 <Cale> ski: If you want to look at it that way.
13:27:26 <mzero> Well, to be fair, quite a number OO languages, or more corectly "prototype" lanagues /did/ encode the definitions into the objects... but that is a whole 'nother chapter
13:27:29 <Cale> ski: Personally, I don't see a need for any distinction beyond the types of objects.
13:27:38 <roboguy_> Cale: so this would be sort of like prototype-based programming (to use OO terminology)?
13:27:40 <Cale> mzero: right
13:28:01 <Cale> roboguy_: yes, it's closer to the original sort of OO from Smalltalk and its relatives
13:28:40 <Cale> Only where you have types that tell you what methods/messages your objects accept (and what their types are)
13:28:41 <defanor> uh, now i'm afraid of encoding too much OO
13:28:44 <mzero> uhm (Smalltalk guy here) - OO in Smalltalk (post Smalltalk-72) didn't look like prototypes - but classical Class/Object relationship
13:28:51 <ski> in OCaml you can specify an "anonymous" object, by simply specifying how it will respond upon receiving the relevant messages
13:29:38 <ski> and then you can pass that object anywhere you can pass another object supporting the same messages ("method name", plus types of arguments and result should agree)
13:31:13 <mzero> in Haskell, one can do the same with forall, Rank-2 (or sometimes -n) types, and type classes - but I often find my impluse to do so is best kept in check
13:31:14 <Kaidelong> is that data definition legal haskell?
13:31:22 <Kaidelong> I didn't know you could make a record type like that
13:31:31 <mzero> Kaidelong: which?
13:31:51 <Kaidelong> Cat { fluffiness :: Double, roundness :: Double } | Owl { roundness :: Double }
13:31:57 <hpc> yes
13:32:04 <hpc> fluffiness is a partial function
13:32:07 <ski> yes, but it's probably bad style
13:32:29 <hpc> you don't see it for good reason ;)
13:32:43 <hpc> Kaidelong: for extra fun, GADT sum type records :D
13:32:46 <dhrosa> ski: why, because of the fact that fluffiness exists for Cat and not Owl?
13:32:57 <alpounet1> dhrosa: yes
13:32:57 <mzero> well, it does exist for Owl
13:33:01 <mzero> - it just crashes!
13:33:04 <aristid> dhrosa: that is why it is partial, yes.
13:33:31 <Kaidelong> I actually wonder why we talk about partial functions and not just poorly typed functions
13:33:47 <aristid> Kaidelong: ?
13:33:48 <hpc> Kaidelong: we live in a language of partiality
13:33:50 <Kaidelong> shouldn't all functions that are correctly typed also be total?
13:33:57 <aristid> no.
13:34:11 <hpc> if you impose that restriction you lose turing-completeness
13:34:32 <hpc> also your compiler becomes a lot more complicated
13:34:59 <hpc> partiality can come from both undefined-like bottoms and non-termination
13:35:07 <aristid> and programming is, at least so far, much harder when you need to prove totality everywhere
13:35:10 <hpc> and guess what's really really hard to automatically detect!
13:35:24 <companion_cube> Kaidelong: you should try Idris
13:35:33 <hpc> or agda
13:36:05 <hpc> idris isn't so much "total haskell" as it is just dependently typed
13:36:07 <Kaidelong> non-termination, but I was just trying to say that partial functions (partial values are a different story) are really just when the domain in the type is bigger than the function's actual domain
13:36:16 <Kaidelong> hpc: that would help, though
13:36:23 <silasm> hpc: idris does have a notion of totality
13:36:25 <hpc> partial value?
13:36:34 <deggis> by the way is there a hlint switch or something to warn about partial functions used?
13:36:44 <silasm> though I wouldn't be surprised given the difference in goals between the two if agda was "more total"
13:36:46 <Kaidelong> hpc: [1..] or (_|_,_|_) and kin
13:37:03 <hpc> calling [1..] partial is losing out on a whole lot of abstraction
13:37:46 <Sawny> How would you translate this PHP code into haskell:
13:37:46 <Sawny> <?php
13:37:47 <Sawny> $data = file_get_contents("chiffer.txt"); //chiffer.txt is in this format: 1,2,2,3,3,3,83,83,2347,...
13:37:47 <Sawny> $data = explode(",", $data); //Split the string into an array/list [1,2,2,3,3,3,83,83,2347,...]
13:37:47 <Sawny> $data = array_count_values($data); //Returns an associative array: [1 => 1, 2 => 2, 3 => 3, 83 => 2, 2346 => 1]
13:37:50 <Sawny> arsort($data); //Sort the array into: [3 => 3, 2 => 2, 83 => 2, 1 => 1, 2346 => 1]
13:37:52 <Sawny> print_r($data); //Print it in a nice format, with indention and tabs
13:37:54 <Sawny> ?>
13:37:55 <lambdabot> Maybe you meant: v @ ? .
13:38:26 <Sawny> Syntax highlighted code at: http://pastebin.com/eZS2ef6G
13:38:30 <mauke> The paste eZS2ef6G has been copied to http://lpaste.net/98831
13:38:41 <hpc> yeah, don't paste lines of code into the channel
13:38:47 <Sawny> sorry
13:38:51 <roboguy_> Kaidelong: well, what do you mean by "correctly typed"? because there are definitely partial haskell functions that pass the type checker
13:39:12 <deggis> answering my own question, this looks promising http://community.haskell.org/~ndm/catch/
13:39:18 <benmachine> Kaidelong: [1..] isn't partial, it's just codata
13:39:25 <Kaidelong> roboguy_: the domain of the function is as narrow as possible, not always possible to do in haskell, probably not always possible to do in general because of the halting problem
13:39:28 <magneticduck> sooo, agda is cool, but are there alternatives to the emacs mode?
13:39:33 <magneticduck> I'm a hardcore vimmer
13:39:36 <magneticduck> actually, a softcore one
13:39:45 <magneticduck> but still, I don't want to use emacs =P
13:39:45 <mzero> Sawny - so ignoring the I/O aspects, the key is you want a histogram, sorted by occurance?
13:39:47 <hpc> Sawny: in extraordinarily cheaty style, i would do something like
13:39:50 <benmachine> Kaidelong: depends what you mean by "as possible"
13:39:52 <magneticduck> oh wait, maybe I should ask on #agda
13:40:12 <benmachine> magneticduck: someone did try to write a vim thing for it, but last time I tried it it didn't work
13:40:17 <Sawny> mzero: Yes. It's a frequency analysis program
13:40:21 <benmachine> I use emacs exclusively for agda
13:40:25 <hpc> do {s <- readFile "chiffer.txt"; let s' = "[" ++ s ++ "]"; print . group . read $ s'}
13:40:29 <hpc> :t do {s <- readFile "chiffer.txt"; let s' = "[" ++ s ++ "]"; print . group . read $ s'}
13:40:30 <lambdabot> parse error on input `}'
13:40:33 <magneticduck> benmachine: :<
13:40:37 <hpc> :(
13:40:38 <roboguy_> Kaidelong: you can sometimes turn partial functions into total functions with Maybe, if that helps
13:40:45 <alpounet> magneticduck: https://github.com/derekelkins/agda-vim ?
13:40:52 <benmachine> alpounet: that's the one I was thinking of
13:40:59 <magneticduck> mmm learning agda is so exciting
13:41:05 <benmachine> but I always have bad experiences with vimscript so maybe I'm just cursed
13:41:24 <hpc> er, print . group . sort . read
13:41:31 <Kaidelong> roboguy_: what would be really interesting is to have a language smart enough to derive a function a' -> b from a function a -> Maybe b
13:41:37 <alpounet> benmachine: i'm not a vimmer but I happened to see this while browsing the agda wiki back when i was toying around with it
13:41:43 <alpounet> looked cool but I haven't tried it
13:41:48 <alpounet> so I can't say how good it is
13:41:51 <hpc> :t (fromJust .)
13:41:52 <lambdabot> (a -> Maybe c) -> a -> c
13:41:56 <hpc> egads!
13:42:13 <Kaidelong> that gives you a partial function!
13:42:20 <benmachine> not necessarily
13:42:41 <benmachine> fromJust . Just is not partial
13:43:03 <Platz> RWH doesn't talk about IORef, ST, MVar a whole lot.  Is there a good resource for choosing which of these tools in different situations?
13:43:22 <alpounet> Platz: for MVars and anything related to concurrency, check out Simon Marlow's book
13:43:59 <alpounet> for the rest, it's mostly blog posts, haskellwiki articles, mailing list archives, etc. No real *reference* text about these
13:43:59 <mzero> > let hist = reverse . sort . map (\l -> (length l, head l)) . group . sort in hist [1,2,2,3,3,3,83,83,2347]
13:44:00 <lambdabot>  [(3,3),(2,83),(2,2),(1,2347),(1,1)]
13:44:18 <mzero> which is perhaps slow and janky
13:44:34 <Platz> alpounet: thanks, I've already found some stuff on haskellwiki
13:44:42 <hpc> Platz: quick primer, the type (IORef a) represents "mutable thing of type a"
13:44:49 <hpc> kind of like a C pointer that can never be null
13:45:02 <joelteon> what's the complexity of sort?
13:45:13 <hpc> joelteon: O(nlogn)
13:45:24 <hpc> joelteon: you should check the source; it's quite clever
13:45:26 <Sawny> mzero: How do I run and play around with that code? In ghci I get "not in scope sort"
13:45:30 * hackagebot chatter 0.0.0.4 - A library of simple NLP algorithms.  http://hackage.haskell.org/package/chatter-0.0.0.4 (RoganCreswick)
13:45:32 <joelteon> so group . sort is O(n) + O(nlogn)
13:45:41 <hpc> Platz: ST is "IO minus IO"
13:45:41 <alpounet> Sawny: import Data.List
13:45:54 <Sawny> Thx!
13:45:56 <hpc> you have STRefs which are basically IORefs, but you can't print things out
13:46:00 <Platz> Should I prefer MVars even if i don't care about concurrency though ? http://stackoverflow.com/a/5545599/176876
13:46:17 <mzero> Sawny:  you need to type    :m + Data.List    in ghci
13:46:20 <hpc> there's some type-level wizardry that keeps you from leaking mutable values
13:46:25 <mzero> to bring Data.List's functions into scope
13:46:31 <Platz> from that post "Generally, in Haskell, use MVars or TVars (STM-based mutable cells), over STRef or IORef."
13:46:59 <hpc> Platz: if you don't care about concurrency, there's still a semantic difference between MVar and IORef
13:47:07 <hpc> Platz: in that MVar can be empty
13:47:10 <joelteon> do you call group amortized in that situation
13:47:11 <Sawny> omg the code works. That is'nt so much code.
13:47:26 <Sawny> isn't*
13:47:29 <mzero> no - but we've left out reading the file, and formatting
13:47:51 <hpc> joelteon: doesn't matter; nlogn + n = nlogn
13:47:55 <joelteon> right
13:47:55 <mzero> > let hist = map snd . sort . map (\(v,n) -> (negate n,(n,v))) . Map.toList . Map.fromListWith (+) . map (\v -> (v,1)) in hist [1,2,2,3,3,3,83,83,2347]
13:47:56 <lambdabot>  Not in scope: `Map.toList'
13:47:56 <lambdabot>  Perhaps you meant one of these:
13:47:56 <lambdabot>    `M.toList' (imported from Data.Map),
13:47:56 <lambdabot>    `F.toList' (imported from Data.Foldable),
13:47:56 <lambdabot>    `IS.toList' (imported from Data.IntSet)Not in scope: `Map.fromListWith'
13:48:12 <mzero> > let hist = map snd . sort . map (\(v,n) -> (negate n,(n,v))) . M.toList . M.fromListWith (+) . map (\v -> (v,1)) in hist [1,2,2,3,3,3,83,83,2347]
13:48:13 <Sawny> Is reading files hard in haskell? Isn't it just something like openFile chiffer.txt?
13:48:13 <lambdabot>  [(3,3),(2,2),(2,83),(1,1),(1,2347)]
13:48:32 <mzero> but you need to type     import qualified Data.Map as M     in ghci first
13:49:00 <mzero> Sawny - no reading isn't hard... but perhaps a little mind bending at first
13:49:15 <mzero> readFile "chiffer.txt"   will get the whole contents of the file as a string  ----
13:49:37 <hpc> Platz: "Generally, in Haskell, use MVars or TVars (STM-based mutable cells), over STRef or IORef." - this is quite often accurate, with the caveat that you do very occasionally want to use STRef
13:49:38 <mzero> and you can use the Data.List.Split package to easily chop by commas
13:49:38 <benmachine> Sawny: it depends. in very simple or very complicated applications, Haskell is great at reading files
13:49:58 <mzero> and you'll need to explicitly change the digit strings into numbers with read
13:49:59 <benmachine> in the middle it's needlessly irritating because there are some things that really ought to be in the standard library that aren't
13:50:07 <hpc> Platz: for when it's just easier to write some imperative mutation-y code and give it a pure type
13:50:13 <hpc> :t runST
13:50:13 <lambdabot> (forall s. ST s a) -> a
13:50:15 <benmachine> but you can write them yourself in ten lines or something, so it's not so bad
13:50:17 <Platz> hpc: thanks, i'll focus on mvars for now then!
13:50:37 <Sawny> okay.
13:50:58 <mzero> the trick is that reading a file (and writing to stdout or a file) are computations "in IO"
13:51:14 <mzero> whereas what we've been typing in lambdabot and ghci are just "pure" computations
13:51:40 <Sawny> Im thinking of learning haskell or clojure or some good scripting language like ruby
13:51:41 <benmachine> I think IORefs are fine for many things
13:51:56 <Platz> hpc: yeah I saw ST was useful for deterministic things such as in-place quicksort
13:52:39 <Platz> but so far the guidance seems to be use MVar until you absolutely have to fall back to IORef
13:52:40 <Sawny> I like haskell and clojure because they are different from PHP and Javascript. Functional programming, bends the brain a bit.
13:52:49 <benmachine> Platz: I wouldn't give that guidance
13:52:50 <Twey> benmachine: I've yet to find something that IORefs are fine for :þ
13:53:00 <Sawny> The problem with clojure is all parentheses
13:53:12 <hpc> Platz: there's basically no reason to use IORef ;)
13:53:13 <benmachine> Twey: single-threaded applications or applications that don't need locking
13:53:14 <Sawny> So im leaning towards haskell :P
13:53:27 <Twey> benmachine: But there's almost always a better way to do it
13:53:33 <Twey> Often FRP
13:53:33 <mzero> Sawny - well, we're biased, but learn Haskell!
13:53:44 <Twey> IORefs are okay for hacking around impure libraries sometimes
13:53:47 <benmachine> Twey: hrrrm
13:53:50 <hpc> no wait, don't learn haskell
13:53:53 <hpc> learn vb6
13:53:55 <ski> Sawny : nothing wrong with a couple of brackets
13:54:05 <benmachine> I think if you're in an IO-heavy context (yes, they do exist) then you can use IORefs to your heart's content
13:54:07 <Twey> Sawny: Clojure has a lot of sugar for minimizing the number of brackets
13:54:13 <mzero> ah yes - I hear you can get a job if you know vb6....
13:54:18 <Platz> Sawny: thats like saying you're willing to jump in front of truck because you didn't like the color of the sidewalk
13:54:38 <Platz> i joke, of course ;)
13:54:58 <Twey> benmachine: I'm sure you *can*, but I don't think I've found one where it's necessary and not just using IORefs unnecessarily to encode some more interesting data flow
13:55:20 <Twey> (potential performance arguments aside)
13:55:31 * hackagebot env-parser 0.0.1.0 - Pull configuration information from the ENV  http://hackage.haskell.org/package/env-parser-0.0.1.0 (JosephAbrahamson)
13:55:45 <benmachine> Twey: to be honest I've just never done FRP except by accident
13:55:48 <companion_cube> is there a symbolic equivalent of `on` ?
13:55:50 <companion_cube> :t on
13:55:50 <benmachine> I would probably love it if I did :P
13:55:51 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
13:55:53 <Twey> FRP is good at encoding information flow
13:56:00 <Twey> You should try!  It's fun
13:56:05 * hpc has a vision of benmachine at his computer
13:56:06 <benmachine> I'm kind of accidentally inventing it at work
13:56:09 <benmachine> pretty sure I'm getting it wrong
13:56:18 <hpc> "whoops, i wrote an frp library"
13:56:25 <hpc> *takkatikkatakkatikka*
13:56:26 <Twey> It took conal to come up with it, so almost certainly ;)
13:56:28 <hpc> "oh, not again!"
13:56:36 <Twey> hpc: Hahaha
13:56:48 <Twey> It's like Greenspun's Tenth
13:58:41 <roboguy_> Sawny: in this case, reading from files would probably look something like withFile "filename" ReadMode (\h -> hGetContents h >>= map read . splitOn ",")
13:59:33 <roboguy_> maybe with an explicit type annotation on read if it's ambiguous
13:59:34 <hpc> i have so few occasions to use withFile anymore...
14:00:53 <roboguy_> you do have to be careful with it
14:01:03 * ski . o O ( `withoutFile "filename" ( ... )', pretend your file don't exist for the duration of `...' )
14:01:20 <hpc> ski: upload acme-file!
14:02:09 <hpc> it would chroot and then symlink everything on your fs except the chosen file
14:02:15 <ski> exactly
14:02:26 <hpc> what could possibly go wrong!
14:03:27 <roboguy_> companion_cube: symbolic equivalent?
14:03:41 <companion_cube> well, I mean, infix
14:03:50 <roboguy_> companion_cube: usually people us `on`
14:03:52 <roboguy_> *use
14:03:56 <geekosaur> hpc: unionfs has whiteout entries
14:03:57 <companion_cube> yeah, guess so
14:04:00 <geekosaur> on some platforms
14:04:15 <benmachine> differencefs?
14:04:16 <geekosaur> so mount unionfs over the current filesystem and create a whiteout for the file
14:04:26 <hpc> hehe
14:04:43 <hpc> benmachine: disjointsumfs
14:04:46 <benmachine> :P
14:04:52 <benmachine> where does it end
14:04:58 <benmachine> filteredcolimitfs
14:04:59 <ski> pushoutfs
14:05:10 <hpc> ski: that almost sounds real
14:05:51 <geekosaur> gitfs, checks the filesystem into git(-annex), branch it and git rm the file
14:06:33 <geekosaur> probably needs full git and not git-annex, come to think of it
14:06:37 <ski> you write `foo.h' and `bar.h', another person writes `foo.c' and `baz.c', the fs automatically constructs `bar.c' and `baz.h'
14:06:48 <hpc> https://github.com/g2p/git-fs
14:07:09 <benmachine> ski: :D
14:09:00 <hpc> ski: all well and good until someone creates jquery.1.10.2.tar.gz
14:14:38 <bambams_> `Int' is applied to too many type arguments
14:14:50 <bambams_> How would _you_ know, GHCi?! >:(
14:15:06 <roboguy_> bambams_: ?
14:15:49 <bambams_> I am trying to learn Haskell, and failing.
14:15:59 <TheOtherCat> hey there
14:16:16 <benmachine> bambams_: I am going to guess you are confused about the difference between typeclasses and types
14:16:25 <bambams_> This may be gibberish so don't be surprised if it makes no sense: let wrapper :: (Int n, LockerMap m) => n -> m -> String; wrapper number locker = let unwrap Left e = error e; unwrap Right c = show c in wrapper (lockerLookup number locker)
14:16:27 <benmachine> this is a common confusion, because they are similar
14:17:31 <simukis_> Why not just wrapper :: (LockerMap m) => Int -> m -> String?
14:17:31 <bambams_> benmachine: That is probably only scratching the surface of my confusion. :P
14:17:31 <TheOtherCat> I'm trying to generate all possible lists of length "k" with entries from 1 to "max", but i can't figure out what is wrong here -> http://lpaste.net/98832
14:17:42 <benmachine> bambams_: so, what's LockerMap?
14:18:11 <roboguy_> bambams_: Int isn't a type class, it's a type so you can't use it with => in that way
14:18:31 <benmachine> TheOtherCat: replicateM expects an Int, not an Integer (unfortunately)
14:18:35 <triliyn> TheOtherCat: replicateM wants an Int too I think
14:19:24 <benmachine> TheOtherCat: consider using toInteger, fromInteger, fromIntegral as appropriat
14:19:30 <bambams_> benmachine: data LockerState = Free | Taken deriving (Eq, Show); type LockerMap = Map.Map Int (LockerState,String)
14:19:51 <benmachine> bambams_: aha. then you probably want wrapper :: Int -> LockerMap -> String
14:20:14 <benmachine> bambams_: as a side note, I observe you haven't actually used unwrap
14:20:18 <bitemyapp> carter: I found dibblego's response HILARIOUS
14:20:52 <bambams_> http://learnyouahaskell.com/making-our-own-types-and-typeclasses <-- I'm trying to validate my understanding, and failing.
14:21:23 <roboguy_> bambams_: LockerState and Int are types though, not type classes
14:21:53 <bambams_> benmachine: Hmmm... I'm not really sure what I'm doing. :P I believe that recursive wrapper was meant to be unwrap (albeit, these names are horrid, and I'm doing this inline in ghci).
14:21:59 <roboguy_> in fact, neither of them *should* be type classes either
14:22:29 <roboguy_> bambams_: also, you probably want parenthesis around Left e and Right c
14:22:38 <benmachine> bambams_: yes, that sounds plausible
14:23:03 <hexagoxel> there is no constant::Float defined with isInfinite _ == true? (i know i can use 1.0/0.0.. but still?)
14:24:01 <bambams_> roboguy_: I suspect that I am forgetting some fundamentals about type constraints... I'm reading through this tutorial in pieces over several days so it doesn't surprise me that I'd get confused..
14:24:05 <shachaf> isInfinite is not the same as "is equal to Infinity"
14:24:10 <benmachine> > isInfinite 1e500
14:24:12 <lambdabot>  True
14:24:22 <roboguy_> bambams_: this doesn't involve any type constraints as it stands
14:24:27 <benmachine> lambdabot is a secret ultrafinitist
14:24:37 <roboguy_> haha
14:24:52 <bambams_> ... /o\
14:25:03 <bambams_> So what! It works! let wrapper :: Int -> LockerMap -> String; wrapper number locker = let unwrap (Left e) = error e; unwrap (Right c) = show c in unwrap (lockerLookup number locker)
14:25:43 <TheBlackCat> I got disconnected since my nickname was in use... thanks to whomever who helped me with the prelicate
14:26:00 <hexagoxel> > -1e500==1e500
14:26:01 <lambdabot>  False
14:26:05 <hexagoxel> hmm yeah
14:26:27 <bambams_> Albeit, I guess show c is redundant.
14:26:54 * bambams_ is very confused by the numeric typeclasses and types ...
14:27:25 <roboguy_> I feel like the numeric type classes aren't the best place to start learning about type classes
14:30:13 <roboguy_> type classes are a way to have multiple dispatch. this means a method of a type class runs different code depending on the type it is given, essentially
14:30:32 <hexagoxel> is 1.0/0.0 always defined?
14:30:35 <roboguy_> bambams_: here's a simple example of a type class I gave a day or two ago: http://lpaste.net/98751
14:31:01 <benmachine> hexagoxel: do you fix its type?
14:31:18 <hexagoxel> 1.0/0.0::Float
14:31:24 <hexagoxel> so, yes
14:31:27 <benmachine> ah, ok
14:31:36 <benmachine> then... how could it not be defined?
14:31:37 <joelteon> > 1.0 / 0.0
14:31:38 <benmachine> well
14:31:38 <lambdabot>  Infinity
14:31:40 <benmachine> it could not be defined
14:31:47 <benmachine> but how could it be not-always
14:31:53 <joelteon> :t isInfinity
14:31:54 <benmachine> what kind of variation are you worried about?
14:31:54 <lambdabot>     Not in scope: `isInfinity'
14:31:54 <lambdabot>     Perhaps you meant one of these:
14:31:54 <lambdabot>       `isInfinite' (imported from Prelude),
14:31:57 <ski> > 1.0 / 0.0 :: Rational
14:31:57 <lambdabot>  *Exception: Ratio has zero denominator
14:31:58 <joelteon> :t isInfinite
14:31:58 <lambdabot> RealFloat a => a -> Bool
14:32:00 <roboguy_> bambams_: actually, that might not be the best example either. hmm
14:32:12 <ski> hexagoxel ^
14:32:49 <shachaf> benmachine: Float isn't required to be IEEE
14:33:15 <benmachine> shachaf: ah, so you're worried about someone else coming along and writing a new implementation of Haskell that is basically a bit perverse :P
14:33:28 <benmachine> or rather, is perverse in a different way from IEEE
14:33:34 <shachaf> I'm not worried.
14:33:51 <shachaf> But I assume that "is ... always defined?" means "in any compliant implementation of Haskell"
14:34:44 <benmachine> shachaf: that's one possible answer, but I wouldn't answer "no" to that question without also adding "but it is in every extant implementation of Haskell that I'm aware of"
14:34:57 <benmachine> er, *all of the extant implementation of Haskell that I'm aware of
14:35:01 <hexagoxel> iirc, in certain other languages it is possible to enable/disable fpu exceptions. if there was such a flag for haskell somewhere..
14:35:07 <benmachine> ah
14:35:09 <shachaf> benmachine: You can just say "GHC", it's OK.
14:35:43 <benmachine> shachaf: :P but being needlessly obtuse keeps me entertained sometimes
14:36:02 <benmachine> hexagoxel: I'm not aware of that feature being available in Haskell
14:36:07 <benmachine> but I'm not an expert on floats
14:36:21 <troydm> any ideas? http://lpaste.net/1726202812880125952 i'm trying to build it on OpenIndiana
14:37:22 <bambams_> roboguy_: I haven't reached `class' or `instance' yet so I don't really know what that means anyway. :P
14:37:56 <roboguy_> bambams_: class and instance are how you define constraints, so you must learn them before you can really understand constraints
14:39:01 <defanor> http://paste.uberspace.net/game.hs.html -- now i have this, but the feed function seems quite repitative. and the same question: what's wrong there, what could be improved?
14:39:05 <hexagoxel> benmachine: thanks
14:39:17 <roboguy_> bambams_: all "class" really says is what methods a constraint provides
14:40:58 <roboguy_> so that would be a good place to start
14:41:21 <roboguy_> for example, this is the Eq class: class Eq a where (==) :: a -> a -> Bool
14:42:28 <roboguy_> (actually there's a (/=) method in there too, but I think that's in there for efficiency which you don't really need to worry about yet)
14:42:44 <startling> edwardk, have you ever thought about doing something more with the Bound class?
14:44:36 <aristid> n8i
14:44:47 <aristid> oops wrong channel sorry:P
14:46:38 <defanor-> uh, server with bnc and paste has gone. not sure if my last message was sent before that, so here it is again:
14:47:00 <defanor-> http://lpaste.net/1118997159958544384 -- now i have this, but the feed function seems quite repitative. and the same question: what's wrong there, what could be improved?
14:49:36 <startling> edwardk, e.g. I'm using this weird thing: https://gist.github.com/startling/c643352db8143c4a5ddc
14:50:19 <startling> cc: c_wraith (I figured it out)
14:50:35 * hackagebot hOpenPGP 0.13 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.13 (ClintAdams)
14:51:50 <roboguy_> defanor-: you could have a nutrition and a foodWeight function like: nutrition :: Food -> Double, foodWeight :: Food -> Double
14:52:52 <defanor-> roboguy_: yep, thanks
14:53:08 <mekeor> when is a program worth hackage?
14:53:32 <startling> when you come up with a cool name for it
14:53:52 <mekeor> it's called "Garepinoh"
14:54:03 <mekeor> is this cool?
14:54:06 <startling> not yet.
14:54:12 <mekeor> :D
14:54:17 <silasm> ...how do you pronounce that?
14:54:23 <sipa> you also need a version number
14:54:27 <startling> 0.
14:54:30 <mekeor> i'm not sure
14:54:36 <benmachine> 0.0.0.0
14:54:45 <mekeor> yeah, its version is 0.9.9 atm
14:55:28 <mekeor> G means GPL, RPN means reverse prefix notation, and H means Haskell. the vowels are just there...
14:55:42 <roboguy_> defanor-: also, it occurs to me that when you give food to a plant, the plant doesn't disappear (although whether or not the Maybe makes sense depends on what specifically you want from the function)
14:56:43 <silasm> mekeor: the way I pronounce it it sounds like a pokemon.
14:56:44 <mekeor> so, is hackage meant as the collection of everything useful written in haskell, or is it just... well, for some really good things?
14:56:53 <mekeor> silasm: :D hahahaha
14:56:55 <defanor-> roboguy_: yeah, thought about that too: 'feed' is going to be a player actions, so it should be like an error. but, for example, for rain (like a plant's food) i'm going to just do nothing with animals and make plants happier
14:57:03 <defanor-> action*
14:57:09 <Twey> mekeor: It's a place to put your programs so other people can use them
14:57:25 <benmachine> most useful things end up on Hackage but not all of them
14:57:40 <mekeor> Twey: they could also just... darcs get it and the cabal install
14:57:45 <benmachine> GHC isn't on there, and there wouldn't be much point in putting it there :P
14:57:47 <Twey> If anybody is likely to want to use it, please put it on Haskell :þ
14:57:52 <Twey> on Hackage** >.-
14:57:59 <mekeor> :D hehe
14:58:17 <Twey> If nobody is likely to want to use it, you don't have to bother if you don't want to, I guess
14:58:19 <mekeor> uhm, i don't think there's anybody who'd use it...
14:58:32 <mekeor> yeah
14:58:33 <mekeor> okay
14:58:58 <Twey> mekeor: This means ‘this is a program that prints out my cat's current age’
14:59:12 <mekeor> oh... but there's one cool thing about uploading to hackage though... – i will be mentioned by hackagebot
15:00:28 <startling> Twey, that's kinda like that one package that was just a very long list of prime numbers.
15:00:36 * hackagebot cipher-aes128 0.6.3 - AES and common modes using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.6.3 (ThomasDuBuisson)
15:00:41 <benmachine> prime numbers are useful
15:01:35 <hodapp> but booleans are not >_>
15:02:45 <Twey> startling: I think that's pretty useful, potentially
15:03:09 <Twey> Linear-time prime number generation doesn't seem like a bad thing to have
15:03:46 <dleedev> hi, is there a way to have multi-line strings in haskell without having backslashes every line?
15:03:53 * mekeor forgot his pw for old hackage and thus can't upgrade to new hackage on http://hackage.haskell.org/users/htpasswd-upgrade
15:03:53 <startling> dleedev: nope.
15:04:15 <startling> dleedev, sometimes people do "lines ["a",\n"b"]"
15:04:23 <startling> er, unlines
15:04:39 <benmachine> or concat, if you want to decide where the newlines go
15:04:43 <startling> ^
15:04:55 <benmachine> also useful because you can put variables in there instead of literals
15:05:06 <hpc> those are more wordy than just doing backslashes
15:05:10 <mekeor> or, intercalate "\n" or something
15:05:32 <startling> :t intercalate "\n"
15:05:32 <lambdabot> [[Char]] -> [Char]
15:05:34 <dleedev> hmm... I'm thinking how I can just paste a long block of text somewhere and have it be a string in haskell
15:05:36 <startling> :t unlines
15:05:37 <lambdabot> [String] -> String
15:05:37 <benmachine> who needs printf when you have concat ["You ate ", show x, " pies. That's ", if x > 10 then "a lot of" else "not very many", " pies"]
15:05:41 <greymalkin> Stupid question... after doing something like > v1 <- "blah blah blah" -- in ghci, how do I clear v1 to be used again?
15:05:42 <startling> dleedev: you can't.
15:06:00 <benmachine> sure you can
15:06:09 <benmachine> you just need to overengineer it
15:06:12 <hpc> greymalkin: just give it another definition
15:06:21 <mekeor> dleedev: you could use the find-and-replace-function of your editor (which should be emacs)
15:06:25 <benmachine> http://hackage.haskell.org/package/heredoc
15:06:29 <hpc> λ> let v = 5
15:06:31 <roboguy_> you could do some kind of template haskell magic
15:06:38 <hpc> λ> let v = 10
15:06:39 <mekeor> dleedev: and then replace newlines with something adequat
15:07:05 * geekosaur wonders if :r does anything when no file is loaded
15:07:36 <dleedev> this feels like an oversight in the language itself
15:09:00 <startling> dleedev: it is.
15:09:32 <geekosaur> dleedev: there are some here doc extensions (mostly using TH / quasiquoters) on hackage
15:09:47 <hpc> if i knew more ghc, a patch for that seems like it would be very easy
15:09:49 <geekosaur> that said, even C does not like it much when you do that
15:09:53 <quchen> geekosaur: let a = 1     :r     a  => a not in scope
15:10:13 <quchen> geekosaur: This matters when you want to have custom definitions in your ghci.conf for example
15:10:27 <roboguy_> looks like Hugs has builtin support for here doc-like stuff...
15:10:32 <roboguy_> I'm surprised ghc doesn't
15:10:36 * hackagebot persistent-mongoDB 1.3.0.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-1.3.0.2 (GregWeber)
15:11:25 <chrizz_> is it possible to install local libraries (not on hackage) into a cabal sandbox
15:11:38 <dmj`> yes
15:11:53 <benmachine> sandbox add-source is related
15:12:10 <chrizz_> dmj`: can you elaborate? haha
15:12:13 <dleedev> I think https://github.com/tmhedberg/here looks like a good workaround for now
15:14:07 <startling> chrizz_, cabal sandbox add-source path-to-my-package. cabal install my-package
15:14:23 <chrizz_> thanks!
15:15:37 * hackagebot structured-haskell-mode 1.0.1 - Structured editing Emacs mode for Haskell  http://hackage.haskell.org/package/structured-haskell-mode-1.0.1 (ChrisDone)
15:18:47 <hape01> I've got an "No instance..." error. Could anybody give me a hint, for http://lpaste.net/98834  please?
15:19:16 <shachaf> It's probably the monomorphism restriction.
15:19:17 <chrizz_> hape01: The type variable `a0' is ambiguous
15:19:25 <shachaf> Try adding an explicit type signature.
15:19:52 <chrizz_> or remove overloadedstrings
15:21:03 <hape01> :t toHtml "Test"
15:21:04 <lambdabot> Not in scope: `toHtml'
15:21:20 <hape01> @type toHtml "Test"
15:21:21 <lambdabot> Not in scope: `toHtml'
15:22:32 <chrizz_> try hoogle, but it's something like ToMarkup a => a -> Html
15:22:36 <hape01> shachaf, chrizz_: How could a explicit type signature look like?    x :: Html    is not enough
15:22:56 <chrizz_> hape01: String -> Htm
15:22:57 <shachaf> I don't know. Try asking ghci.
15:23:13 <shachaf> Or read about the monomorphism restriction and decide whether to turn it off.
15:23:32 <chrizz_> shachaf: he's obviously a total noob, i think we can be a little more helpful than that :P
15:24:06 <shachaf> OK, try typing the thing you just typed -- :t toHtml "Test" -- in ghci, with the relevant modules imported.
15:24:11 <shachaf> It'll tell you what the right type is.
15:24:31 <hape01> toHtml "Test" :: Html
15:24:49 <chrizz_> in ghci, the command line haskell repl
15:25:29 <shachaf> OK, then I don't know what "is not enough" means.
15:26:03 <hape01> I added the explicit type   x :: Html   in the coding, but the error has kept the same
15:26:24 <shachaf> Are you sure?
15:26:27 <startling> hape01, :: can associate in surprising ways.
15:27:10 <hape01> shachaf, yes i verified this now
15:27:39 <thetallguy> hape01: add   default (String) below the imports
15:28:09 <cin> hape01, it's because toHtml expects ToHtml a => a and you've probably got OverloadedStrings on, which makes all "foo" be IsString a => a
15:29:15 <hape01> cin, yes, I have OverloadedStrings on, as it has been in the blaze tutorial http://jaspervdj.be/blaze/tutorial.html
15:30:10 <cin> hape01, yes, with overloaded strings on, you don't need to write toHtml "foo", you can just write "foo", because Html is an instance of IsString
15:30:29 <hape01> cin, and how would i work-around this even having OverloadedStrings on
15:31:11 <hape01> cin, wow :-) yes
15:31:13 <cin> hape01, specify toHtml ("my string" :: Text) or toHtml ("my string" :: String), or specify a defaulting rule as thetallguy suggested
15:31:51 <startling> hape01, what happened when you said x :: Html ?
15:31:53 <thetallguy> the defaulting doesn't work in this case
15:32:03 <thetallguy> x :: Markup
15:32:03 <thetallguy> x = "Test"
15:32:10 <thetallguy> that works
15:32:25 <thetallguy> or   x =  toMarkup ("Test" :: String)
15:32:30 <hape01> I should go for python I think.
15:32:38 <startling> :/
15:33:12 <hape01> that is so complex
15:33:18 <hape01> can't believe
15:33:22 <thetallguy> hape01: nah, this is one of those little hiccups tha tyou get used to
15:33:31 <hape01> o yes :-)
15:33:37 <roboguy_> hape01: if you remove OverloadedStrings it will also work. you will want it later though
15:33:52 <jrmithdobbs> once you stop fighting it that's actually one of the benefits of haskell
15:33:58 <jrmithdobbs> it's just hard to understand why at first ;p
15:34:01 <hape01> as I see You all have already learned these lessons :-)
15:34:08 <roboguy_> jrmithdobbs: especially if this is your first encounter with it
15:34:29 <hape01> Thank You all
15:35:32 <yayutf> hape01: in haskell, you pay in annoyance upfront; in python, it bites you over time :)
15:35:38 * hackagebot Elm 0.11 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.11 (EvanCzaplicki)
15:35:52 <jrmithdobbs> roboguy_: ya, eg, i just changed a parser's type from Parser Text to Parser Tree (Either Text Text) and all i did across the whole project was change the functions i wanted type signatures and change everything that throw a type error and the code still works in the end
15:35:53 <yayutf> (source: I've been doing python for 14 years)
15:35:58 <jrmithdobbs> roboguy_: scares me how often that is true.
15:38:23 <startling> jrmithdobbs: yeah, it's nice when that happens.
15:38:47 <thetallguy> yayutf: well said
15:39:53 <yayutf> thetallguy: thanks. it's unfortunate, though ^-^
15:40:44 <cin> the approach would be similar in python https://gist.github.com/kstep/3516334 or https://github.com/fatiherikli/pyml
15:41:02 <cin> there are some strange notions in there, but the compiler will not tell you if you do it wrong
15:41:17 <thetallguy> yayutf: yes, I sometimes think that enforcing some "obvious" monomorphisms on strings would reduce the learning curve a lot.
15:41:38 <benzrf> hey, what does seq do
15:41:47 <cin> what does the documentation say?
15:41:53 <benzrf> -.-
15:41:54 <benzrf> ok
15:42:03 <startling> benzrf, it introduces strictness dependencies
15:42:11 <benzrf> ok...
15:42:18 <benzrf> thats what i thought
15:42:25 <chrizz_> benzrf: it evaluates its argument to whnf
15:42:26 <benzrf> but i tried 'seq [1..] 3' and it instantly returned 3?
15:42:29 <benzrf> oh wnhf
15:42:33 <benzrf> derp <_>
15:42:40 <cin> the documentation says: Evaluates its first argument to head normal form, and then returns its second argument as the result.
15:42:46 <chrizz_> not derp, it's not a concept that exists in strict languages
15:43:08 <startling> benzrf: right, being strict on the head of a list isn't terribly useful.
15:43:15 <startling> > seq (last [1..]) 3
15:43:19 <benzrf> ah
15:43:20 <lambdabot>  mueval: ExitFailure 1
15:43:21 <lambdabot>  mueval: Prelude.undefined
15:43:47 <startling> > (`const` last [1..]) 3
15:43:48 <lambdabot>  3
15:44:46 <cin> benzrf, would it be helpful if the documentation explained what head normal form means?
15:44:59 <benzrf> i think i know what it means...
15:45:15 <chrizz_> what does it mean, then?
15:45:42 <benzrf> given a thunk, evaluate it to get the constructor it has, but do not force the thunks in the constructors' fields
15:45:45 <benzrf> *constructor's
15:46:05 <chrizz_> yup
15:46:12 <startling> benzrf, almost
15:46:16 <cin> that depends whether the constructors is strict or not, but generally, yes
15:46:21 <benzrf> startling: hm?
15:46:40 <startling> benzrf, functions without applied arguments are also WHNF
15:46:46 <benzrf> oh
15:47:10 <benzrf> @src last
15:47:11 <lambdabot> last [x]    = x
15:47:11 <lambdabot> last (_:xs) = last xs
15:47:11 <lambdabot> last []     = undefined
15:47:42 <benzrf> wait, shouldnt whnf for 'last [1..]' be 'last [2..]'?
15:48:24 <startling> no. 'last [2..]' is not in WHNF.
15:48:47 <cin> Prelude> data StrictTuple a b = T { frst :: !a, scnd :: !b }
15:48:47 <cin> Prelude> T 1 undefined `seq` ()
15:48:47 <cin> *** Exception: Prelude.undefined
15:48:56 <cin> there is also the above to be aware of
15:49:17 <benzrf> i thought functions without applied args are whnf?
15:49:49 <roboguy_> benzrf: that has args applied
15:49:59 <startling> benzrf, 'last [2..]' has an applied argument
15:50:18 <benzrf> hm?
15:50:25 <startling> i.e., [2..]
15:50:28 <benzrf> oh wait
15:50:31 <benzrf> how is 'applied' defined
15:50:39 * hackagebot garepinoh 0.9.9.1 - reverse prefix notation calculator and calculation library  http://hackage.haskell.org/package/garepinoh-0.9.9.1 (MekeorMelire)
15:50:54 <mekeor> That's me!
15:50:55 <cin> a type of kind *, probably
15:50:56 <startling> mekeor: heh
15:51:10 <benzrf> oh
15:51:18 <startling> cin: not really.
15:51:20 <cin> a -> b is unapplied
15:51:23 <startling> well, not in this context.
15:51:58 <startling> benzrf, when you say "f a" , you're applying the argument a to f.
15:52:06 <benzrf> right
15:52:45 <shachaf> I would say "applying f to a"
15:53:05 <cin> a function is something you apply
15:53:12 <benzrf> oh
15:53:16 <cin> you don't apply values to things
15:53:30 <shachaf> Unless those values happen to be functions.
15:53:45 <benzrf> so whnf means, either you are in most normal form OR ELSE one of your arguments is an application
15:54:06 <benzrf> wait... hm
15:54:19 <benzrf> thats not quite right is it
15:54:41 <cin> consider the basic evaluation steps
15:54:54 <cin> (\x->x) a can be reduced to a
15:55:04 <cin> (\x->x) has no more reduction steps
15:55:20 <acowley> Anyone here using structured-haskell-mode?
15:55:40 * hackagebot garepinoh 0.9.9.2 - reverse prefix notation calculator and calculation library  http://hackage.haskell.org/package/garepinoh-0.9.9.2 (MekeorMelire)
15:55:53 * mekeor instantly found a mistake in his haskell-hackage-program-package-project and fixed it...
15:56:14 <mekeor> acowley: what is that?
15:56:25 <mekeor> is is that mode from chrisdone? O.o
15:56:33 <dhrosa> acowley: an emacs extension
15:56:45 <jrmithdobbs> ya that's chrisdone's isn't it
15:56:45 <acowley> mekeor: Yes
15:56:49 <roboguy_> acowley: I've used it a little
15:56:53 <startling> acowley: I use it.
15:56:58 <startling> it's kind of wonky sometimes.
15:57:01 <mekeor> jrmithdobbs: i don't thin he asked *what* it is ;D
15:57:06 <acowley> startling: It's driving me nuts when it comes to managing white space
15:57:20 <mekeor> ah.. dhrosa, i meant
15:57:28 <startling> acowley: it did for me at first but then I gave up and now my code is pretty and I don't have to worry about indenting.
15:57:37 <acowley> startling: I have a line with just some white space, and C-k kills too much, then C-w won't do anything
15:57:43 <startling> acowley: oh, yes
15:57:51 <mekeor> acowley: i think all modes suck at that
15:57:59 <startling> acowley: I usually M-d when that happens
15:58:03 <acowley> mekeor: No, this is just bog standard emacs
15:58:09 <startling> acowley: definitely bugs though
15:58:21 <acowley> M-d didn't do the right thing for me either
15:58:29 <mekeor> bog?
15:58:49 <acowley> The only way I can get it to work is to C-D all the individual white space characters
15:59:06 <acowley> mekeor: I mean standard emacs commands for killing and cutting
15:59:23 <mekeor> ah, okay... wait.. whut? :O
15:59:26 <startling> emacs users trace their lineage back to a tribe of mystics who made bog mummies and rearranged curved twigs until they looked nice.
15:59:39 <acowley> I can normally hit C-space C-n C-w and remove any intervening white space
15:59:43 <acowley> among other ways
15:59:46 <startling> acowley, SHM rebinds C-k
15:59:48 <acowley> but shm breaks those things
15:59:51 <acowley> yes, I know
15:59:56 <startling> ok
16:00:01 <acowley> I need an escape hatch for those kinds of things
16:00:02 <startling> you can probably rerebind it.
16:00:16 <acowley> If I disable shm temporarily, I"m stuck with a crippled haskell-mode due to the need to disable any indentation mode
16:00:19 <thetallguy> startling: guilty
16:00:23 <roboguy_> SHM has given me some trouble when I want to add/remove parens around an expression
16:00:30 <mekeor> you could ask chrisdone what he bind C-w &c to
16:00:35 <acowley> roboguy_: Oh yes, that's another soul crusher!
16:00:42 <startling> roboguy_: yeah, sometimes you end up with one undeletable paren
16:00:48 <roboguy_> yeah
16:01:07 <startling> we should probably report these bugs.
16:01:11 <acowley> roboguy_: Using C-d on the opening paren is pretty robust
16:01:13 <silasm> I'm going to learn emacs someday. I still need to set up my footpedals with joy2key.
16:01:17 <cin> perhaps report the issue, I doubt they will ever be fixed if nobody knows they exist
16:01:39 <acowley> startling: I'm asking here in case people have figured out the chrisdone-approved way of doing things
16:01:45 <acowley> which might be a mistake
16:01:51 <roboguy_> cin: I have a feeling that this would come up a lot
16:02:11 <roboguy_> at the moment at least, SHM feels like it might be so personal that it might be pretty hard for anyone who isn't chrisdone
16:02:22 <acowley> cin: It's tough because some of these are style-based.
16:02:27 <startling> acowley: chrisdone probably has
16:02:27 <acowley> Yes, what roboguy_ said
16:03:04 <acowley> Sometimes it does really neat things, though
16:03:09 <startling> right. the other issue is that it's hard to come up with test cases, since undo doesn't reliably put you back in the state you were in.
16:03:11 <acowley> I tried it and gave up on it a few weeks ago
16:04:14 <acowley> It has so much potential, I'd like to fight through the rough spots
16:04:48 <chrisdone> looks like that watch for shm i put on ircbrowse paid off =p
16:04:57 <startling> chrisdone, haha
16:05:02 <acowley> !
16:05:27 <chrisdone> hum
16:05:32 <acowley> chrisdone: I can't delete white space :(
16:05:51 <startling> chrisdone, while we've got you on the line, do you plan to add barf and slurp stuff?
16:05:54 <chrisdone> what's the test-case?
16:05:59 <chrisdone> startling: yeah that would be awesome
16:06:21 <acowley> chrisdone: Okay, here you go
16:06:22 <startling> chrisdone: cool, good to know. it's often frustrating to get things in and out of parens.
16:06:43 <Twey> chrisdone, acowley: I'm using SHM
16:06:47 <mekeor> wow! garepinoh achieved 7 downloads total! thank you guys!!!1! :D heheeh
16:06:56 <Twey> If you wanted any more datapoints
16:07:09 <acowley> chrisdone: In a do-block, type one statement, hit enter, hit space a few times, go down and enter a second statement.
16:07:11 <chrisdone> startling: for parenthesized stuff, definitely
16:07:16 <acowley> chrisdone: Now try to delete the second line with a few spaces
16:07:21 <acowley> chrisdone: C-w hangs on me
16:07:29 <acowley> chrisdone: C-k kills the third (non-empty) line
16:07:44 <startling> chrisdone, it'd be extra cool if it worked with $. 8)
16:07:47 <acowley> also, in this case, the hang recovers after a time
16:07:54 <chrisdone> acowley: is this on the latest git repo, btw?
16:08:05 <acowley> chrisdone: As of about 30 minutes ago
16:08:21 <chrisdone> startling: right -- that's why i've put it off for now, i'd like it to work for any kind of node nesting
16:08:24 <bitemyapp> carter: <3
16:08:36 <chrisdone> acowley: can you paste the exact code? whitespace is deleting okay here
16:08:39 <startling> chrisdone: fair enough. I look forward to it!
16:09:06 <acowley> chrisdone: I can delete it space-by-space, but I can't use normal emacs region stuff
16:09:20 <chrisdone> acowley: ahhh, C-w does hang. good catch
16:09:50 <acowley> chrisdone: I'd prefer if C-k would just do the normal kill thing when given a line of white space, too
16:09:54 <chrisdone> acowley: selecting and then DEL works, but C-w hangs and C-k continues onwards, yeah
16:10:04 <chrisdone> mmm, i agree
16:10:16 <chrisdone> hold up
16:10:16 <acowley> Yes, I don't use the delete key as often as C-w and C-k
16:10:22 <acowley> shorter finger trajectories
16:10:27 <carter> omg its an acowley !
16:10:29 <carter> bitemyapp: am i giving good advice?
16:11:01 <acowley> Hey carter!
16:11:15 <bitemyapp> carter: I think so! There might be exercises for learning the pedagogy involved beyond simply reading Plato's dialectics.
16:11:25 <bitemyapp> acowley: hi! I'm a fan too!
16:11:31 <chrisdone> should C-k actually put it in the clipboard if it's whitespace or just remove the whitespace?
16:11:31 <acowley> This is like high speed twitter
16:11:33 <carter> benmachine: point being, make sure its not a "X vs Y"
16:11:35 <startling> haha
16:11:39 <carter> oops
16:11:45 <acowley> chrisdone: Just removing it is all I use it for
16:11:47 <startling> chrisdone, remove it
16:11:47 <carter> bitemyapp: don't do X vs Y
16:11:52 <chrisdone> probably i haven't noticed this use-case because i don't use kill operations for stuff i don't want
16:11:54 <chrisdone> cool =)
16:12:01 <startling> chrisdone: thanks. :)
16:12:09 <acowley> Yeah, my use of the kill-ring is not very emacs-y
16:12:20 <acowley> C-k is so fast to hit, though
16:12:20 <startling> what do you use for stuff you don't want?
16:12:39 <chrisdone> i use DEL, personally
16:12:45 <chrisdone> (backspace)
16:12:49 <acowley> But it's so far away!
16:12:53 <startling> you hold it down???
16:12:54 <acowley> My fingers are lazier than Haskell
16:12:59 <roboguy_> chrisdone: I have to hit two keys for that
16:13:02 <Twey> chrisdone: What's the recommended way to a) make a region out of the current node b) remove surrounding brackets from a node?  :þ
16:13:04 <roboguy_> on my laptop anyway
16:13:16 <acowley> Twey: I think M-r does that!
16:13:28 <chrisdone> twey: make a region: C-M-SPC, replace parent node with current: M-r
16:13:35 <chrisdone> acowley knows where it's at =p
16:13:36 <roboguy_> oh, backspace I thought you meant delete. never mind
16:13:37 <Twey> Ah, beautiful
16:13:40 <startling> chrisdone: nice, thanks
16:13:52 <Twey> Should've guessed!  Thanks
16:13:54 <acowley> roboguy_: My backspace key says "delete on it" :/
16:14:00 <acowley> roboguy_: Apple is confusing the conversation
16:14:01 <roboguy_> acowley: so does mine, hah
16:14:15 <Twey> acowley: ‘Delete on it’ is a strange label for a key!
16:14:28 <hpc> my backspace says <- on it
16:14:30 <acowley> Yes, my labels are very verbose!
16:14:33 <hpc> (it also says backspace)
16:14:43 <Twey> Hrm
16:15:00 <startling> mine says "YOU WILL BE DELETED"
16:15:10 <acowley> I'm guessing Apple using a "delete" label has history behind it, and here we are trying to talk about it in conjunction with emacs which invented history
16:15:41 * hackagebot egison 3.2.8 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.8 (SatoshiEgi)
16:15:45 <Twey> a b |(c)|_   (node marked with |, cursor with _):  M-r does this: (c)_
16:16:13 <acowley> Twey: You want the node to be just |c|
16:16:17 <chrisdone> right, your selection should be |c|
16:16:52 <chrisdone> its behaviour's copied from paredit's raise-sexp
16:16:53 <acowley> chrisdone: Btw, I don't feel like my upvote on reddit was enough: Those videos on shm are really wonderful!
16:17:21 <chrisdone> i pushed the C-k fix
16:17:27 <chrisdone> acowley: oh thanks! =)
16:17:31 <Cale> chrisdone: What do you use the enter key for?
16:17:34 <Twey> Er, that's what I meant to type
16:17:50 <Cale> I don't understand why it's C-j instead
16:17:55 <Twey> … but maybe it's just the bracket highlighting hiding where the node actually is.  Hmm.
16:18:30 <startling> chrisdone: by the way, putting the cursor on a = or | in a data declaration should make the whole constructor thing the "current node", shouldn't it?
16:18:37 <triliyn> acowley: isn't backspace called DEL in emacs-speak anyway?
16:18:54 <roboguy_> chrisdone: speaking of emacs modes, god-mode seems a little awkward on OS X
16:19:08 <startling> chrisdone needs his own irc channel
16:19:10 <chrisdone> Cale: C-j makes a new sibling node on a newline, RET is a dumb kind of "just go to a newline at the column that M-m would jump to on this line"
16:19:23 <johnw> startling: #haskell-emacs :)
16:19:48 <Cale> chrisdone: But if you use C-j more, why not swap them?
16:19:59 <startling> Cale: C-j is easier than return
16:20:04 <startling> home row
16:20:05 <Clint> is there a tool for generating man pages from source comments?
16:20:05 <Twey> Ah, yes, I think that's it
16:20:09 <Cale> wat, lol
16:20:12 <c_wraith> return is home row
16:20:23 <startling> c_wraith, pff, you have to stretch your pinky
16:20:28 <Twey> startling: My Return is on a thumb
16:20:30 <acowley> Yay, C-k seems to be fixed!
16:20:37 <startling> how do I install the newest?
16:20:39 <novochar> How else can you create a NewTree? https://gist.github.com/novodinia/2d1410e85d24a8973412
16:20:44 <jrmithdobbs> j isn't on my homerow
16:20:49 <jrmithdobbs> bigots
16:20:50 <Twey> Nor mine
16:20:50 <novochar> How else could you write this? so it's not one long line
16:21:02 <acowley> triliyn: I think C-d is "delete-char"
16:21:07 <acowley> triliyn: Which is a forward delete
16:21:11 <Twey> novochar: Well, you could put it on more lines :þ
16:21:19 <NemesisD> i've got a problem. i think sandboxes use global packages. installing a package and I think it is pulling in a dependency from the global packages, but there is no corresponding profiling version of that library so my sandboxed build is failing
16:21:28 <triliyn> acowley: right, but backward-delete-char is bound to the key that emacs knows as DEL
16:21:37 <chrisdone> cale: it's just mirroring how i'm used to it in lisp modes. personally, j is easier. but shm's mode map is freely configurable, so if people prefer RET more i can swap it with C-j by default and then reconfigure it myself for my local emacs
16:22:06 <acowley> triliyn: I don't even want to think about this or I'm never going to be able to delete what I want :(
16:22:08 <c_wraith> novochar: are you required to use that representation?
16:22:22 <silasm> is there a package on hackage for mapreducing trees in parallel? I've been working on my own and it's been fun but... unfruitful in terms of performance.
16:23:19 <startling> I wonder if strategies can do that intelligently
16:23:20 <roboguy_> silasm: there's this https://hackage.haskell.org/package/reducers
16:23:23 <chrisdone> startling: umm i think = or | would mean "whole declaration". to select the current constructor use M-a on it until it's like data X = {Foo Int} | Bar
16:23:27 <novochar> c_wraith: No, I'm just working my way through RWH and someone mentioned had this in the comments
16:23:39 <startling> chrisdone: M-a widens the current node?
16:23:44 <novochar> I wish I wouldn't have read the comments, but I was stuck and couldn't do it myself
16:23:45 <silasm> roboguy_: I'll have a look at that, thanks.
16:23:56 <chrisdone> startling: yeah, M-a widens backwards, and ) widens forwards
16:23:57 <novochar> This has been the case on all the exercises so far
16:24:04 <startling> silasm, take a look at http://hackage.haskell.org/package/parallel
16:24:11 <roboguy_> silasm: I'm not sure if there's stuff in it for trees specifically
16:24:20 <c_wraith> novochar: it's probably a simpler representation to be data NewTree a = Leaf | NewNode a (NewTree a) (NewTree a)
16:24:34 <roboguy_> silasm: it probably wouldn't be hard to extend it though
16:24:39 <Twey> novochar: I prefer a more generic tree type, though, like data Tree f a = Tree a (f (Tree f a)), which would give you type NewTree a = Tree (Vec 2 :. Maybe)
16:24:59 <novochar> c_wraith: where would you put deriving (Show) after your NewTre definition
16:25:01 <Twey> … a
16:25:05 <silasm> startling: I was actually already using the Eval monad for my implementation; so I'm familiar with it (using the parallel haskell book; it's great).
16:25:08 <novochar> It seems appropriate to put it on the next line
16:25:09 <Twey> novochar: https://gist.github.com/novodinia/2d1410e85d24a8973412
16:25:13 <c_wraith> novochar: often on the next line.  *shrug*
16:25:19 <startling> silasm: cool, ignore me !
16:25:26 <novochar> Are trees representations of list structures?
16:25:38 <Twey> novochar: A list is a trivial tree
16:25:38 <startling> novochar: what does that mean?
16:25:41 <silasm> startling: heh, thanks for contributing anyways.
16:25:51 <chrisdone> acowley: when shm is acting up, at this stage i probably just haven't noticed it. please report any weirdness as it's usually easy to fix in 5 minutes and nothing (mostly) is set in stone
16:25:52 <triliyn> Twey: what extensions and auxiliary definitions are required to make (Vec 2 :. Maybe) valid?
16:25:55 <Twey> novochar: (where the number of children is 0 or 1)
16:25:55 <startling> lists in other languages are often trees
16:26:03 <novochar> c_wraith: where though, indented 2 to 4 spaces or after the equal sign?
16:26:07 <startling> especially lisp.s
16:26:26 <Twey> triliyn: TypeOperators, newtype (:.) f g a = O (f (g a))
16:26:36 <c_wraith> novochar: whatever you feel like. It needs to be indented, but that's the only rule.  Standard convention is probably putting "deriving" on column 4
16:26:43 <Twey> triliyn: TypeLiterals for the 2
16:26:46 <startling> chrisdone, one more thing: is there something I can hook into to say e.g. "if indentation would be >5 spaces, use 2 instead"?
16:27:00 <Twey> I think that's not an extension, though
16:27:10 <chrisdone> startling: expand on that?
16:27:16 <novochar> Twey: Do you have an example of a more complicated tree besides, say, a tuple or a custom data type?
16:27:36 <startling> chrisdone, often (e.g. if I have a long function name) I get indented too far to the right and have lots of wasted space on the left.
16:27:37 <triliyn> oh, so :. is a type-level version of ., not that fmap . fmap thing
16:27:37 <novochar> by custom data type, i mean algebraic data type
16:27:43 <Twey> novochar: The definition I gave generalizes to pretty much anything I can think of that I might class as a ‘tree’
16:27:50 <novochar> one that you create yourself that is
16:27:55 <Twey> It's just a question of passing the right functor
16:28:07 <chrisdone> startling: for that i tend to select the node with my cursor at the start and use C-j to bring the whole thing down. does that help?
16:28:48 <novochar> Twey: I didn't see your definition, I'm sorry
16:28:49 <chrisdone> startling: e.g. https://www.youtube.com/watch?v=kAa6Tv2ZvSw&t=0m14s
16:28:49 <startling> chrisdone: let me see
16:28:54 <Twey> triliyn: Yes, that's (.:)
16:29:05 <Twey> 231116 <Twey> novochar: I prefer a more generic tree type, though, like data Tree f a = Tree a (f (Tree f a)), which would give you type NewTree a = Tree (Vec 2 :. Maybe)
16:29:08 <roboguy_> triliyn: you can't have arbitrary operators begin with :
16:29:17 <roboguy_> they must be data constructors/type constructors
16:29:17 <novochar> Do you mean data Tree f a = Tree a (f (Tree f a))
16:29:19 <novochar> Ah, okay
16:29:22 <Twey> triliyn: : is capital punctuation.  ☺
16:29:25 <triliyn> hmmm, okay
16:29:40 <chrisdone> twey: capital of ;?
16:29:54 <Twey> chrisdone: You'd think, but no
16:30:22 <chrisdone> the world is a mystery
16:30:35 <Twey> We may never know how those ancients thought
16:30:43 <mmmm> Speaking of trees, can anyone think of a plausible use case for Tree a b = Empty | Fork (Tree b a) a (Tree b a)
16:31:00 <startling> mmmm: why's b there?
16:31:01 <Twey> mmmm: That's just a binary tree
16:31:09 <chrisdone> acowley: oh, by the way, are you actually manually writing a do expression and then hitting RET and hitting space to make the next statement?
16:31:09 <mmmm> No it isn't
16:31:25 <novochar> Is it possible to work with trees daily in a web development environment?
16:31:25 <roboguy_> chrisdone: one thing I've noticed is that shm seems to want to push things more to the right than I'd like (in function definitions, for example)
16:31:35 <startling> novochar, you already do.
16:31:38 <startling> novochar: e.g. HTML
16:31:45 <Twey> mmmm: It's isomorphic to Tree a = Empty | Fork a (Tree a) (Tree a) -- a binary tree with labels on the nodes
16:31:50 <startling> programming is all about working with trees. 8)
16:32:04 <shachaf> Twey: Look again.
16:32:11 <shachaf> It's a non-regular data type.
16:32:14 <Twey> novochar: Everything's a tree if you look closely enough
16:32:21 <Twey> Oh!  It switches!
16:32:25 <Twey> mmmm: I beg your pardon
16:32:38 <acowley> chrisdone: No, but my second attempt at using shm is only an hour old at this point so I don't have (m)any habits yet
16:32:40 <Twey> I believe there is some kind of a tree structure that does this
16:32:46 <startling> chrisdone: oh, no, that's not quite what I mean.
16:32:50 <chrisdone> roboguy_: does what startling just mentioned relate?
16:33:11 <chrisdone> acowley: ah ok
16:33:13 <roboguy_> chrisdone: I think so, yeah
16:33:16 <startling> chrisdone: oh, maybe I'm wrong.
16:33:27 * startling has been interchanging C-j and RET
16:33:28 <Twey> mmmm: It reminds me of a game play, maybe
16:33:32 <roboguy_> chrisdone: it seems to want to line it up with the equal sign and usually I just want two spaces
16:33:50 <roboguy_> if I wanted it lined up like that, I'd probably just keep it on the same line
16:33:53 <novochar> Why is the deriving function typically indented, as in the comment from Twey at https://gist.github.com/novodinia/2d1410e85d24a8973412
16:33:55 <Twey> mmmm: Here's a usage: http://en.wikipedia.org/wiki/Alternating_decision_tree
16:34:12 <startling> chrisdone: oh, another thing. I get "Wrong type argument: markerp, nil" pretty often.
16:34:32 <mmmm> oo interesting thanks
16:34:46 <Twey> novochar: Haskell typically does ‘banner’-style indenting, where everything under the first line of the block is indented
16:35:27 <Twey> novochar: The ‘deriving’ belongs to the type declaration, so it gets indented more
16:35:46 <Cale> http://dlicata.web.wesleyan.edu/pubs/l13git/git.pdf :D this is a great set of slides
16:35:54 <Cale> I wonder if this talk was recorded
16:35:56 <roboguy_> novochar: it looks nicer. also deriving isn't really a function
16:36:34 <Twey> novochar: Haskell will actually enforce this by default, so to not indent it would not be allowed (you can override this by manually inserting braces and semicolons if you like, though)
16:38:34 <chrisdone> woops, got d/c'd
16:39:25 <chrisdone> startling: if it helps to avoid the RET=C-j association, RET is a translation key for C-m (translations let elisp developers make maps for RET, and if the keyboard *has* a return key you can press it, otherwise you'd hit C-m, same for TAB=C-i, etc)
16:39:30 * mekeor is sorry for the disturbance
16:40:46 * hackagebot garepinoh 0.9.9.2.1 - reverse prefix notation calculator and calculation library  http://hackage.haskell.org/package/garepinoh-0.9.9.2.1 (MekeorMelire)
16:40:53 <Twey> novochar: When you have dependent types you get W-types, which are a nice way to define almost any type you can think of as a ‘tree’ parameterized over a ‘shape’ type, where the type of the next ‘branch’ can vary on the way down according to the ‘shape’ of the current node
16:41:08 <chrisdone> roboguy_: you mean when using C-j to add new constructors? if you put the = on a newline two spaces in, subsequent |'s will align with that, if that's what you mean
16:41:43 <Twey> They're cool.  I like them.
16:41:44 <chrisdone> startling: when that happens and you have time, can you run M-: (setq debug-on-error t) and re-run the same command? it will give a backtrace that you can paste into a ticket
16:42:05 <startling> chrisdone: yep.
16:42:08 <roboguy_> I mean if I have something like "someFunctionNameHere x y z = |f x y <> g z" (where my cursor is |) and I hit return, it puts everything way over to the right instead of only indenting it two spaces or so
16:42:12 * chrisdone adds this to the README
16:43:12 <oakwhiz> I'm having the same error as this person when trying to install Pango on Windows using Cabal: http://stackoverflow.com/q/20908829/755161
16:43:53 <chrisdone> roboguy_: try selecting the whole "f x y <> g z" and hit C-j
16:43:56 <roboguy_> chrisdone: or, I mean if I do C-j
16:44:06 <novochar> Thank you roboguy_
16:44:20 <roboguy_> chrisdone: if I do that, it wants to add another <>
16:44:22 <novochar> Thank you also, Twey, that is probably what I was looking for
16:44:24 <acowley> Using shm, I have occasionally ended up with big blocks of code just after what I'm editing un-indented by a single space
16:44:25 <dcoutts_> oakwhiz: try the solution suggested on that page
16:44:32 <acowley> I have no idea what I'm doing that's triggering it
16:44:32 <chrisdone> roboguy_: hmm, really?
16:44:34 * chrisdone tests
16:45:04 <acowley> Oh, I had the way over to the right thing, too!
16:45:09 <roboguy_> chrisdone: oh, it does if I have no arguments for f and g
16:45:39 <roboguy_> chrisdone: if I have arguments, it alternates between doing that and doing a newline+indent when it press C-j several times with it highlighted
16:45:43 <acowley> Here we go
16:45:48 <acowley> foo = bar x >>= baz y
16:45:53 <acowley> Put the cursor before baz
16:45:55 <acowley> hit C-j
16:45:58 <chrisdone> roboguy_: are you using M-a to expand the current node to "f x y <> g z"?
16:46:18 <roboguy_> chrisdone: oh, no. I didn't know about that
16:46:29 <roboguy_> ahh, I see
16:46:46 <roboguy_> it seems like if I'm right after an equals sign, though, I'd always want that behavior
16:46:50 <chrisdone> roboguy_: right, i should probably add some sensible behaviour in this specific right-hand-side case
16:46:57 <chrisdone> acowley: i'll try
16:47:11 <acowley> It's not "way" in that test case, but it moves a couple spaces over
16:47:19 <acowley> I had it move way over in a larger context
16:47:41 <acowley> What I wanted in that case was to line "baz" up under "bar", btw
16:48:10 <chrisdone> yeah, that does not behave nicely. agreed. humm
16:49:45 <chrisdone> acowley: hm, yeah, adding this use-case is straight-forward, hold up
16:55:22 <joelteon> would it be pretentious to call my library mtl-concurrent
16:56:32 <hodapp> you're using Haskell already
16:58:19 <joelteon> ok
17:04:40 <lispy> Does anyone know who is behind the new Haskell tips on twitter?
17:05:06 <lispy> So far the content is questionable/misguided at best.
17:05:19 <defanor> i want to save/load some things which could be shown/read. is it safe to use just show/read for that, if Show/Read are derived and not altered?
17:06:37 <lispy> defanor: Read/Show is only good for serialization if you're doing it as a quick 'n dirty hack.
17:07:09 <lispy> defanor: It's great if you just want something that works on your development copy, but as your program/library becomes more mature you'll run into the problems with that approach pretty quickly.
17:07:10 <ij> If a Functor instance is defined, would I still have to define a Monad one as well?
17:07:25 <lispy> It's slow, the error reporting is terrible, you don't always have control over the instances, and so on
17:07:34 <dwcook> ij, yes, Functor does not imply Monad
17:07:41 <dhrosa> ij: yes, if 'you want to use it as a monad, a functor is not neccessarily a monada
17:07:49 <Twey> lispy: Misguided how?
17:07:52 <defanor> lispy: got it, thanks
17:08:08 <Twey> I kind of thought it was chrisdone because it has his λ> prompt
17:08:11 <lispy> defanor: use something like cereal or binary if you want robust serialization. Make your own parser if textual is better.
17:08:11 <chrisdone> acowley: pushed. i've wanted this too. now: if you C-j at the start, it will bring the whole thing down to the same alignment as the parent, if you C-j at the end, it'll try to do the "copying" behaviour
17:08:17 <Twey> But I guess that might be popular by now
17:08:27 <chrisdone> twey: haha, not me. but i'm such a popularizer! /me poses
17:08:31 <Twey> Heheh
17:08:35 <ij> But it still would be possible to define the monad' >>= as just return . fmap?
17:08:39 <lispy> Twey: Well the advice about foldl' for strict value foldr otherwise seems to be missing a lot of stuff.
17:08:50 <oakwhiz> dcoutts_: Whenever I apply the fix and run 'cabal install' the file reverts back to the original.
17:08:52 <dwcook> ij, you can mechanically create a Functor instance from a Monad one, however: instance Functor Foo where { fmap = liftM }
17:09:00 <lispy> Twey: and the example with bang patterns seems to be mocking bang patterns :)
17:09:07 <Twey> chrisdone: Are you in the UK at the moment, by the way?
17:09:14 <lispy> Twey: and the suggestion to use FastString is just wrong.
17:09:19 <lispy> Twey: I stopped reading them after that.
17:09:21 <chrisdone> twey: at the moment, in italy
17:09:21 <Twey> lispy: Hrm.  Okay.
17:09:25 <pavonia> :t return . fmap
17:09:26 <lambdabot> (Monad m, Functor f) => (a -> b) -> m (f a -> f b)
17:09:38 <Twey> chrisdone: Ah, okay — guess you won't be making Fun in the Afternoon then?
17:09:54 <ij> hrm
17:10:07 <chrisdone> twey: haven't heard of that. sounds like fun =)
17:10:12 <mmmm> Is that the one at facebook in march Twey?
17:10:15 <Twey> Aye
17:10:32 <mmmm> I think I'll probably get to that, looks like fun
17:10:52 <Twey> I think the two Simons are talking, and edwinb… should be good
17:11:36 <chrisdone> good lineup!
17:11:44 <dhrosa> :t (>>=)
17:11:45 <lambdabot> Monad m => m a -> (a -> m b) -> m b
17:11:54 <Twey> Indeed!  Fancy making the trip?
17:12:30 <chrisdone> twey: ah, when is it? homepage doesn't say: http://sneezy.cs.nott.ac.uk/fun/
17:12:36 <Twey> Wednesday the 12th of March
17:12:47 <chrisdone> oh, totally
17:12:53 <Twey> Great
17:13:01 <mmmm> Do you need to RSVP?
17:13:07 <Twey> I think so
17:13:16 <Twey> There's a post on -cafe
17:13:25 <Twey> Sorry, on [Haskell]
17:14:01 <startling> chrisdone, ok, I added all the keybindings you mentioned to my *scratch* buffer comment. maybe I'll remember them now !
17:14:27 <lingxiao> hey could someone explain this bit of code to me?
17:14:41 <lingxiao> https://gist.github.com/anonymous/f0c0324ac5c3fdc6ea8a
17:14:43 <chrisdone> startling: \o/
17:15:18 <chrisdone> Fun in Afternoon link for convenience http://www.haskell.org/pipermail/haskell/2014-January/024038.html
17:15:23 <lingxiao> better linkd:
17:15:24 <Twey> lingxiao: It's keeping track of the types of the terms in the Env type
17:15:27 <lingxiao> https://gist.github.com/anonymous/0c09eb38198aec8bdd38
17:15:41 <lingxiao> so the line that says: "Nil   :: Env '[]"
17:15:42 <Twey> lingxiao: The ' indicates a type-level analogue of a value-level  constructor
17:15:57 <Twey> Nil is a constructor that produces a type Env '[]
17:16:02 <Twey> Where '[] is a type-level empty list
17:16:04 <rdevilla> Is TDD normally practiced in Haskell?
17:16:21 <rdevilla> or does it not even really apply in this context
17:16:21 <startling> rdevilla: it's more like type-error-directed-development ime
17:16:23 <Twey> (i.e. an environment containing no terms, of no types)
17:16:47 <Twey> rdevilla: It certainly *can* be practised, and we have some tools like QuickCheck that help with it a fair bit
17:16:48 <startling> rdevilla, but tests suites are very common. libraries like quickcheck and hspec are nice.
17:17:15 <Twey> But in my experience it's not used quite as much as in e.g. Python, because most of the ‘obvious’ properties that you check for are already covered by the type system
17:17:22 <startling> but usually I spend a lot of my time playing with code until it's /nice/, then I fix the bugs.
17:17:30 <rdevilla> hm, okay
17:17:37 <lingxiao> Twey: wait, can we back up one line and what does "data Env :: [Type] -> * where " mean?
17:17:38 <lispy> rdevilla: We tend to think about types as a specification and matching the type is one source of evidence that you're on the right track. You can also make multiple implementations and pit them against each other.
17:17:43 <startling> lingxiao: it's a kind signature
17:17:57 <lingxiao> so Env is a type constructor that takes a type of [Type] and construct a kind of *
17:18:00 <lispy> rdevilla: or come up with invariants (or properties) and then make sure they hold for some values (randomly chosen inputs?)
17:18:00 <Twey> lingxiao: ‘Env is a type constructor that takes a (type-level) list of Type and returns a type’
17:18:10 <lispy> rdevilla: and failing all that, we have hunit
17:18:16 <startling> "kind constructor" ?
17:18:16 <rdevilla> lispy: So really design starts from satisfying types as opposed to satisfying some spec
17:18:45 <lispy> rdevilla: It sort of depends on the level of thinking. For functions and small things like that, types are right. For APIs a spec is better.
17:18:50 <Twey> lingxiao: I.E. Env '[] is a type, and Env (foo ': bar) is a type
17:18:54 <lingxiao> Twey: how would you formulate that line without using this "_ -> *"
17:19:05 <lingxiao> is it possible?
17:19:05 <Twey> lingxiao: I wouldn't
17:19:08 <Twey> No
17:19:24 <rdevilla> I see
17:19:32 <Twey> The kind signature is necessary to set the kind of the argument (without it, it defaults to *)
17:19:34 <lingxiao> so this is not a normal GADT right? if there is such a thing, is there a nam efor it?
17:19:41 <rdevilla> I'm thinking of writing a website in Happstack or something as a first "real" Haskell project
17:19:45 <Twey> startling: There's no kind constructor here
17:20:03 <Twey> startling: Though [] is a kind constructor with DataKinds for example
17:20:16 <startling> Twey, oh, you're right. I'm getting stuff confused.
17:20:20 <lispy> rdevilla: In that case, using TDD in Haskell should be encouraged :)
17:20:33 <chrisdone> acowley: i caused a regression (yay tests!) with that kill-line tweak, but i fixed it and made some generally better C-k behaviour. let me know if it doesn't behave well for you anymore. it should, tho
17:20:41 <lingxiao> so `Env` is a function over types?
17:20:44 <Twey> lingxiao: It's a normal GADT, plus a custom kind, plus a kind signature
17:20:55 <Twey> lingxiao: It's a type constructor, yes
17:20:56 <lispy> rdevilla: We also, of course, have tools that work well for Haskell other than TDD that you can learn (thinking about types, quickcheck, etc)
17:21:46 <startling> chrisdone, is C-} one of those special keys? :/
17:22:08 <chrisdone> startling: what's C-}?
17:22:13 <chrisdone> i have no binding for't
17:22:22 <Twey> startling: What?  That's a perfectly normal key combination!  (on Programmer's Dvorak…)
17:22:32 <rdevilla> lispy: hm, I think I will look at HSpec and QuickCheck then
17:23:07 <lingxiao> Twey: so if I had to reformulate `Term` using custom kind and kind signature, just for practice ... what would it look like? here's the original:
17:23:13 <lingxiao> https://gist.github.com/anonymous/54f7d21fee5805b8278b
17:23:27 <Twey> rdevilla: In general you should craft your types to catch as many error conditions as you can, then use testing for the things that are left over
17:23:51 <Twey> lingxiao: This doesn't do anything, you know
17:23:58 <lingxiao> would it be: data Term :: a -> * where .. `
17:24:07 <lingxiao> what's "this"?
17:24:08 <startling> chrisdone, paredit says C-\} is paredit-forward-barf-sexp, but I'm not sure what the backslash indicates there. I tried (local-set-key (kbd "C-}") 'paredit-forward-barf-sexp) but C-} still doesn't appear to do anything.
17:24:14 <Twey> lingxiao: It's * -> *
17:24:20 <Twey> Oh, I see what you're doing
17:24:21 <rdevilla> Twey: I will keep that in mind, but I don't think I'm confident enough with Haskell's type system to know how to design my types as such :S
17:24:27 <Twey> Okay, yes
17:24:55 <chrisdone> startling: try (define-key shm-map (kbd "C-}") 'paredit-forward-barf-sexp)?
17:25:20 <startling> chrisdone: well, I'm not in SHM. I just thought you might know. :)
17:25:30 <chrisdone> startling: oh, lol
17:25:33 <lingxiao> so it's `* -> *` instead of `a -> *` because even though I intended "a" to be a variable over some type, inhabited by values, I can't use that syntax wise?
17:25:35 <Twey> lingxiao: For example, at the moment ‘Term (Maybe Int)’ is a valid term, which you might not want it to be
17:25:40 <lingxiao> I have to specify the kind of type ..
17:25:53 <lingxiao> but isn't "Maybe Int" also in *?
17:26:03 <Twey> lingxiao: No, you can absolutely use it (I think you need the PolyKinds extension), but it's not what you want to say here
17:26:04 <lingxiao> since it's inhabited by values like "Just 3"
17:26:13 <Twey> lingxiao: It is, and that's why you can use it here
17:26:17 <roboguy_> lingxiao: values don't inhabit kinds
17:26:19 <roboguy_> types do
17:26:46 <lingxiao> roboguy_: I meant Just 3 inhabit Maybe Int, which is why Maybe Int inhabit *
17:26:47 <Twey> lingxiao: By default, Term has kind * -> * (since you applied it to a type in the constructor)
17:27:07 <lingxiao> but how would *->* preclude the use of Term (Maybe Int)
17:27:10 <Twey> lingxiao: That means you can pass any * type as an argument to it
17:27:21 <lingxiao> so Maybe Int doens't inhabit *?
17:27:24 <Twey> lingxiao: It doesn't: that's just the correct reformulation of what you've already got
17:27:35 <Twey> I was getting to the actual usage :þ
17:27:45 <chrisdone> startling: what major mode are you adding it to?
17:27:56 <lingxiao> oh sorry... haha when I'm confused I get super needy to know :\
17:28:13 <Twey> lingxiao: With KindSignatures and DataKinds, you can instead say Term ∷ Type → ★
17:28:22 <startling> chrisdone, I'm just in *scratch* right now.
17:28:33 <Twey> lingxiao: So that now it's only valid to pass members of Type as a type argument to Term
17:28:40 <chrisdone> i guess fundamental-mode then
17:29:55 <defanor> isn't it lisp-interaction-mode in scratch?
17:29:58 <chrisdone> startling: i did M-: (local-set-key (kbd "C-}") 'doctor) in fundamental mode and C-} opened the therapist. seems ok
17:30:01 <lingxiao> ahh I made that change just now, thanks for making my code more expressive!
17:30:08 <Twey> lingxiao: DataKinds automatically lifts Type to the kind level and its constructors to the type level, so you can use them in types; then, KindSignatures lets you specify kinds other than * to be passed to type constructors
17:30:45 <startling> chrisdone: weird. might be something to do with OS X, then.
17:30:46 <chrisdone> defanor: yeah, true
17:30:48 * startling shrugs
17:30:51 <startling> chrisdone: thanks anyway
17:30:52 <lingxiao> ahh ... so when I say "data Term :: Type -> *`, the "Type" is a kind ... the same as * ?
17:31:01 <lingxiao> is it parralell to * ?
17:31:07 <chrisdone> OS X and problems with keybindings? say it ain't so!
17:31:09 <chrisdone> =p
17:31:25 <lingxiao> so what inhabits Kind "Type"? Just the data "Type"?
17:31:31 <geekosaur> control-} won't do anything sensible *in a terminal*
17:31:42 <lingxiao> where as things like Int etc, inhabit *
17:32:02 <geekosaur> there is no control character corresponding to it
17:32:24 <chrisdone> presumably startling is not in a terminal, though
17:32:38 <Twey> lingxiao: Yes, it is
17:33:04 <Twey> lingxiao: The things inhabiting the kind Type are the type-level equivalents of the things that inhabit the type Type
17:33:18 <geekosaur> chrisdone: the standard emacs on OS X only runs in a terminal
17:33:36 <Twey> lingxiao: So if data Type = TNat | TBool, you now have a kind called Type and types called TNat and TBool
17:34:00 <Twey> lingxiao: So you can say Term TNat or Term TBool
17:34:23 <Twey> geekosaur: Does OS X come with an emacs?
17:34:28 <chrisdone> geekosaur: but nobody uses it
17:34:28 <geekosaur> yes
17:35:03 <geekosaur> /usr/bin/emacs exists, only supports -nw mode. anyone who really wants to use emacs generally replaces yet, *if* they realize they need to do so...
17:35:41 <lingxiao> so if Type = Boolean | Type :-> Type
17:35:59 <startling> chrisdone, I'm not in a terminal, no.
17:36:24 <lingxiao> is "Type :-> Type" a type inhabiting kind "Type" now? and the sets are still separate because the "Type" in "Type :-> Type" refers to type, not kind ..
17:36:33 <lingxiao> uhh ... if that sentenence is not too convoluted to make sense
17:36:34 <startling> oh well, I rebound C-[ and C-]. What's this recursive edit stuff? Who even cares?
17:36:35 <Twey> lingxiao: You get a kind Type and type constructors Boolean ∷ Type and (:->) ∷ Type → Type → Type
17:36:43 <chrisdone> carbon emacs worked well for me when i had os x… but i guess each os x user uses a different emacs distribution
17:36:52 <Twey> lingxiao: The one on the type level refers to the kind
17:37:12 <startling> emacs has cocoa support now, I believe.
17:37:20 <startling> I just brew install emacs --cocoa
17:37:27 <roboguy_> startling: wait, really?
17:37:38 <startling> roboguy_, I guess so. I don't know for sure.
17:37:49 <roboguy_> I got mine from "Emacs For Mac OS X"
17:37:57 <Twey> lingxiao: You get two things by each name: a type and a kind called Type, and a value constructor and a type constructor called (:->), taking values of type Type (the type) and types of kind Type (the kind), respectively
17:37:58 <startling> maybe it uses some other build script.
17:38:12 <startling> roboguy_, updates are nice.
17:38:12 * geekosaur uses emacs-app from macports
17:38:22 <roboguy_> startling: huh. I'll have to look at that
17:38:29 <geekosaur> but yeh, there's a lot of different emacses for os x
17:38:35 <startling> roboguy_, make sure you brew linkapps afterwards.
17:38:54 <roboguy_> startling: does brew have an equivalent of -jN?
17:39:18 <Twey> lingxiao: ‘Type’ no longer looks like a word.  >.>
17:39:37 <startling> yeah, looks like it just uses emacs source: https://github.com/Homebrew/homebrew/blob/master/Library/Formula/emacs.rb#L80
17:39:59 <startling> roboguy_: set HOMEBREW_MAKE_JOBS
17:40:11 <lingxiao> Twey: haha I think it's a studied phenomon, where if you sense something often enough your brain changes the way it process it.. like you no longer notice a smelly room after sitting in it for a bit..
17:40:15 <roboguy_> startling: cool, thanks!
17:40:20 <startling> seems like it defaults to your number of cores though
17:40:29 <geekosaur> "semantic satiation"
17:40:33 <roboguy_> startling: echo $HOMEBREW_MAKE_JOBS gives me nothing right now
17:40:47 <lingxiao> so if I can back up one bit, when you said "Term :: * -> *" precludes something like "Term (Maybe Int)", you said it precludes it because Maybe Int doesn't have kind *? but it does?
17:40:47 <chrisdone> twey: semantic satiation semantic satiation semantic satiation semantic satiation semitic sanitation semiotic salination
17:40:56 <roboguy_> startling: oh, you mean that brew already uses that many regardless?
17:40:58 <Twey> chrisdone: Sa-salination?
17:41:08 <startling> roboguy_: yeah, I think so. that's what man brew says, anyway.
17:41:29 * Twey salts the word a bit, but that doesn't help it taste more like a word.
17:41:53 <roboguy_> looks like I already have the emacs brew package installed without cocoa support. I guess I'll reinstall
17:42:47 <roboguy_> lingxiao: I'm pretty sure that Term (Maybe Int) is fine
17:43:02 <chrisdone> twey: salinization -- adding salt, salination -- washing with salt water. iapprove.jpg
17:43:10 <lingxiao> roboguy_ : that's what I thought too... maybe Twey meant Term Type precludes Term (Maybe Int)
17:43:25 <lingxiao> and I just read it wrong
17:43:58 <lingxiao> so syntax wise, in the second line below:
17:44:00 <lingxiao> data Env :: [Type] -> * where
17:44:00 <lingxiao> 	Nil   :: Env '[]
17:44:03 * chrisdone tries go to back to sleep
17:44:15 <startling> chrisdone, your ircbrowse alert wakes you up???
17:44:39 <acowley> Now I feel guilty!
17:44:54 <lingxiao> simply buy putting ' in front of []: '[], denotes '[] is different than [[
17:44:58 <lingxiao> ah .. []
17:46:39 <lingxiao> by the way, generic question: what are some other IRC channels you guys recommend?
17:46:40 <athan> Can someone help me comprehend functors? (like mentally, not with a list. Haha.)
17:46:41 <Twey> lingxiao: Term ∷ ★ → ★ allows you to have types like Term (Maybe Int)
17:47:03 <lingxiao> ahh, ok thanks for confirming that .. I should have read more closely when you first said it :)
17:47:18 <Twey> lingxiao: Term ∷ Type → ★ only lets you have terms like Term Boolean or Term (Boolean :-> Boolean)
17:47:36 <lingxiao> like I'm in haskell-in-depth, haskell-overflow..but they're kind of dead ... btw these channels don't have to be just hasksell related
17:47:55 <startling> athan, a Functor is some f for which fmap :: (a -> b) -> f a -> f b is defined.
17:47:57 <roboguy_> athan: sure. what are you wondering about?
17:48:06 <lingxiao> Twey: ahh.. yeah that's much more expressive
17:48:08 <acowley> Every irc channel is haskell related if you try hard enough
17:48:26 <geekosaur> well, -overflwo only gets used when tangents are getting in the way or we otherwise need more "space" to work in
17:48:38 <startling> athan: so, for lists, fmap :: (a -> b) -> [a] -> [b]
17:48:52 <startling> athan, for Maybe, fmap :: (a -> b) -> Maybe a -> Maybe b
17:48:55 <geekosaur> (by tangents I mean something not quite offtopic enough to land in offtopic)
17:49:02 <startling> athan, does that make sense?
17:49:29 <athan> roboguy_: Hello again, thanks for helping me. So my first question: functors are like containers that can have computations mapped upon all of it's elements, right?
17:49:40 <lingxiao> acowley: haha, yeah I enjoy reading arguments about whether jquery is a monad
17:49:43 <roboguy_> athan: well, not necessarily, but some of them are
17:49:57 <lingxiao> on HN
17:49:57 <startling> yeah, a Functor is just literally something for which fmap is implemented.
17:50:09 <acowley> lingxiao: You need more ambition. Classic cars are really like functors for the memories associated with them...
17:50:49 <athan> startling: Yes, I think I've got the basic usage of them understood, I just need to learn more about their _purpose_. I'd like to learn the lens library sometime soon :/
17:51:04 <athan> hahahaha.
17:51:09 <zrho> athan: ambitous^^
17:51:09 <roboguy_> acowley: maybe you'd have a nostalgia preserving natural transformation between them
17:51:18 <startling> athan, ok, the purpose is to let you write generic code for any Functor.
17:51:31 <startling> athan, maybe your question is "how does writing code with typeclasses work?"
17:51:33 <acowley> roboguy_: !!!
17:52:10 <lingxiao> LOL
17:53:10 <acowley> "nostalgia preserving natural transformation" is incredible
17:53:30 <roboguy_> haha, well category theory is supposed to be general right?
17:53:30 <lingxiao> Twey: so 1000 lines ago, you said "The ' indicates a type-level analogue of a value-level  constructor"
17:53:36 <athan> startling: Hmm. I disagree. I understand polymorphism and how to use it, I'm just really trying to get the foundation of Functors well understood. How closely related is the category-theory definition tied into Haskell?
17:53:44 <lingxiao> and I do :k '[]
17:53:55 <lingxiao> and I get: '[] :: [AnyK]
17:54:15 <lingxiao> what's AnyK? the kind level analogy of a ? it's a variable over kinds?
17:54:19 <roboguy_> athan: it's somewhat like a Hask endofunctor, where Hask is the category of haskell types if you want to look at it in category theory terms. that's not necessary to understand it though
17:54:30 <tel> acowley do I see a "Monads are just ____" post getting its wings?
17:54:38 <Twey> lingxiao: Erm, I think that's what you get if you don't have PolyKinds on
17:54:57 <acowley> tel: Yes, I'll write a monad tutorial titled "80s kids will get this..."
17:54:58 <Twey> Yes
17:55:03 <lingxiao> uh .. even with PolyKinds pragma, I get [AnyK]
17:55:10 <Twey> lingxiao: If you turn on PolyKinds you get [k]
17:55:27 <Twey> lingxiao: You have to enable it separately in your GHCi — the pragma won't carry over
17:55:33 <Twey> :set -XPolyKinds
17:55:59 <zrho> athan: a functor in the categorical sense sends both objects to objects and morphisms to morphisms, s.t. some properties hold. You can observe the object to object (read type to type in Hask) aspect in the kind of functors: * -> *.
17:56:03 <tel> athan If you have instance Functor f then f is a covariant endofunctor on Hask, the category of Haskell types and functions between them
17:56:23 <zrho> athan: The morphism to morphism part (read function to function in Hask) then is fmap.
17:56:24 <lingxiao> Twey: I'm still getting AnyK ... but it's ok ... so what's k in [k]?
17:56:29 <lingxiao> is it a variable over kinds?
17:56:46 <roboguy_> not all covariant Hask endofunctors are instances of Functor though
17:57:00 <roboguy_> but all Functor instances are covariant Hask endofunctors
17:57:27 <lingxiao> acowley: hmm if classic records map progressions to memories, what do notes map to?
17:57:53 <lingxiao> notes in those classic records ...
17:58:02 <acowley> roboguy_: What are the functors that aren't Functors? Just class constrained ones?
17:58:07 <athan> hmm. What is a covariant?
17:58:11 <heatsink> To answer athan's question about the purpose of Functor, there is no purpose.  It's literally a type for which fmap is defined.  The category was invented to encompass various use cases that arise in practice and have similar solutions.
17:58:18 <tel> roboguy_ yup, one way implication
17:58:25 <roboguy_> acowley: well, the (,) functor that maps the first element
17:58:29 <Twey> lingxiao: http://lpaste.net/98835
17:58:32 <roboguy_> for one
17:58:34 <Twey> lingxiao: Yes
17:58:34 <acowley> Ah
17:58:46 <Twey> lingxiao: That's what PolyKinds gives you
17:58:47 <zrho> athan: A covariant functor F sends morphisms f: X -> Y to morphisms F(f) : F(X) -> F(Y).
17:58:58 <heatsink> Some people noticed that they were doing mathematically similar things repeatedly, so they made a mathematical abstraction for it.  Later it became a software abstraction.
17:59:04 <acowley> Well we should probably sprinkle some variant of the phrase "up to isomorphism" between every other word
17:59:04 <roboguy_> athan: it's probably important to emphasize: you don't need to know category theory to understand the Functor type class
17:59:25 <tel> athan because I want to get some use out of this: http://www.reddit.com/r/haskell/comments/1vc0mp/whats_up_with_contravariant/
17:59:33 <zrho> athan: A contravariant one maps f to F(f) : F(Y) -> F(X).
17:59:38 <tel> although ignore the last section because, as ekmett pointed out, it's just wrong
17:59:39 <shachaf> hi tel
17:59:49 <tel> shachaf hi :)
18:00:06 <shachaf> I was going to say the thing about Functor in here but you weren't around for a while.
18:00:09 <heatsink> Is there any relationship between covariance in category theory and covariance in type theory?
18:00:11 <zrho> I don't particularily like the notion of contravariance. A contravariant functor is a covariant one from the opposite category.
18:00:19 <roboguy_> Contravariant is a cool thing, but we should probably start with Functor
18:00:58 <jle`> is it even a little scary to anyone else that Auto and other such machines have a state that has dynamically varying type? (that the state of a Haskell Mealy machine at its nth iteration is impossible to know in general at compile time)
18:00:59 <tel> shachaf ah, no worries, it was past the edit deadline and completely a brain-o on my part
18:01:11 <athan> I feel as though in order to fully understand the vocabulary and language used throughout the Haskell community, one has to learn category/type/set/* theory lol
18:01:29 <athan> But, it's still beautiful haha. Thank you all for your help.
18:01:31 <tel> shachaf so, thanks for the correction :)
18:01:51 <zrho> athan: set theory shouldn't be that much of a problem ;)
18:01:52 <shachaf> Contravariance is a useful concept in Haskell.
18:02:08 <roboguy_> athan: not really. we use restricted forms of most of those terms (like how Functor is specifically a certain kind of covariant Hask endofunctor rather than any functor)
18:02:12 <shachaf> tel's explanation looks reasonable -- I think the most important thing to think about is "produce" vs. "consume"
18:02:17 <tel> athan Category theoretic terminology as used by Haskell programmers is significantly less general than that you might find in a book on CT.
18:03:01 <heatsink> athan, it's best to learn Haskell by example.  Once you've seen lots of examples, it's much easier to get the general concept.
18:03:04 <tel> athan And sometimes a little wonky. You can go quite a long way just building up intuitions about the terms from programming Haskell alone
18:03:07 <roboguy_> shachaf, tel: once I thought about it in those terms, it made sense (and so did Profunctor, as a consequence)
18:03:24 <shachaf> tel: You should edit Profunctor p => Category p out, though. :-(
18:03:45 <tel> shachaf I left a note since I didn't want to leave tailing comments that didn't make sense
18:03:46 <roboguy_> athan: I would definitely steer you away from trying to learn category theory first in order to learn haskell. you just need to learn category theory if you want to know it
18:03:54 <athan> tel I think I'm getting there, I just need a lot more exposure.
18:04:02 <tel> shachaf I suppose if I'm going to keep referencing it I should ^U it
18:04:05 <shachaf> Oh, what you have there is post-edit, I guess.
18:04:11 <roboguy_> "it" being category theory
18:04:55 <athan> roboguy_: I've had a curiosity about it for a while. I think it would be a good background for me when I hear strange words like endofunctor haha. I really do appreciate your help though.
18:05:02 <startling> roboguy_: thanks for asking about HOMEBREW_MAKE_JOBS, btw. Finally got me to set mine to 1 so I'm not completely useless when I'm brew upgrading. :<
18:05:15 <roboguy_> athan: alright. well, I know very little about category theory by the way
18:05:46 <roboguy_> I'm learning it (because it's interesting to me in and of itself) but I haven't gotten too far yet. and I learned about Functor before that
18:05:47 <zrho> athan: I learned the terminology from Haskell and later applied it to mathematics when needed. Had a course on Haskell for mathematicians which I used the other way round in order to understand the mathematics^^
18:05:56 <startling> zrho: haha
18:06:05 <athan> roboguy_: Good god hahaha. I'm just going to do a quick wiki to gain some vocab from it. I'll be back with more questions soon haha.
18:06:08 <tel> shachaf: there, made it quite a bit less misleading without covering up the story
18:06:16 <roboguy_> athan: ah, okay haha
18:06:25 <athan> zrho: SWEET MOTHER OF MARY CAN I HAVE YOUR NOTES??
18:06:30 <roboguy_> tel: the cover up's always worse, right
18:06:49 <tel> roboguy_ hah, it just gets awkwarder and awkwarder
18:06:57 <zrho> athan: I try to find some of the slides, hang on.
18:07:43 <lingxiao> could someone explain this to me?
18:07:44 <lingxiao> type family TypeProd (ts :: [Type]) :: Type
18:07:49 <startling> askell
18:07:51 <heatsink> Probably a tuple type
18:07:52 <shachaf> tel: I predict that people will skim that post and read the code first. At least, that's what I did. But eh, it probably works.
18:07:57 <athan> zrho: Thank you so much. I can't wait!!
18:07:59 <heatsink> "Product" in the sense of a product type
18:08:08 <mm_freak_> i think i fell in love with category theory when i read its formulation of monoids =)
18:08:23 <Twey> lingxiao: A type family is like a type-level function
18:08:27 <tel> shachaf to be fair, it's what I do too :)
18:08:33 <acowley> startling: I got a "Wrong type argument: markerp, nil" !!!
18:08:36 <heatsink> So, TypeProd [Int, Bool] is a type representing the tuple type (Int, Bool)
18:08:38 <tel> mm_freak_ +1
18:08:41 <zrho> athan: Is in German though: http://www.iai.uni-bonn.de/~jv/teaching/ffp12/kategorien.pdf
18:08:43 <mm_freak_> like you fall in love with a programming language, when you see an elegant one-liner for something that would be horrible to write in any other language =)
18:08:46 <shachaf> Matrices-as-a-category is an example I like to give, though. In fact I like it as a motivation for the definition of a category.
18:08:55 <lingxiao> btw all this stuff came from Andrews Loh
18:08:56 <startling> it's a nice example.
18:08:56 <Twey> lingxiao: So that's a kind declaration for a function TypeProd from [Type] to Type
18:08:59 <lingxiao> is he on this channel?
18:09:10 <startling> It helps me remember how matrix multiplication works, too. :)
18:09:13 <roboguy_> acowley: haha, if only emacs used a statically typed language...
18:09:22 <shachaf> Usually people get too hung up on objects.
18:09:31 <lingxiao> Twey: so type family is on the same level as something like Maybe? which also takes type to type?
18:09:32 <shachaf> Anyway this is off-topic by now.
18:09:33 <Twey> lingxiao: Andres Löh, ASCII ‘Loeh’ ☺
18:09:36 <athan> zrho: Crap... google translator will help haha. Thank you again!
18:09:54 <tel> shachaf I was writing it running off memory of Dan Piponi's profunctor composition article, so I flubbed it a bit
18:10:00 <lingxiao> Twey: man you're a master of haskell and symbols I can't make
18:10:05 <Twey> lingxiao: Yes, except that Maybe can only take things to types of the form Maybe a, and you can get the a back out of it
18:10:24 <shachaf> Oh, that's a different thing.
18:10:49 <tel> shachaf Yeah, that's why I did Profunctor => Category >_<
18:10:58 <Twey> lingxiao: A type function is more general: it can take any type to any type, such as Foo Int = Bool, and as such you can't get the original parameter (Int, in this case) back out
18:11:01 <shachaf> Matrices also make an interesting category in various other ways.
18:11:56 <tel> I know of Mat as the category with natural numbers as objects and nxm matrices as arrows
18:12:06 <lingxiao> Twey: uh what do you mean get it back out? like pattern match it?
18:12:13 <lingxiao> mat (Just a) = a
18:12:17 <lingxiao> for example
18:12:21 <roboguy_> every time I start to learn about category theory, it feels like they're leaving something important out or that there is something fundamental that I'm not understanding
18:12:29 <roboguy_> unfortunately, it's hard for me to put in more specific terms than that
18:12:35 <heatsink> lingxiao, you can determine what type would be stored in a Just value
18:13:15 <tel> roboguy_ the book that did a lot for me about CT intuition is Lawvere's Conceptual Mathematics... it's kind of a narrative slog, but it has lots of neat intuition tricks
18:13:29 <roboguy_> tel: hmm, I'll look into that
18:13:52 <roboguy_> I've been trying to follow along with the Awodey lectures on youtube
18:14:03 <Twey> lingxiao: Something like that, yes.  You can't pattern-match directly at the type level, but there are some operations you can do that rely on being able to extract the original type.  For example, you can write a function f ∷ Maybe a → a, but you can't write a function f ∷ Foo a → a
18:14:10 <roboguy_> it's frustrating because it seems (to me) like a lot of it should be pretty simple
18:14:49 <lingxiao> uhh ... sorry what is this Foo you're referring to?
18:15:02 <Twey> lingxiao: Foo is the example type family I declared above.
18:15:35 <Twey> lingxiao: For the same reason you can write a function that extracts the ‘3’ from ‘Just 3’, but you can't write a function that extracts the ‘sum [1, 2, 3]’ from ‘6’
18:15:43 <jle`> is there a name for a category without the identity morphism?
18:15:55 <roboguy_> jle`: I think it's semigroupoid
18:16:08 <Twey> lingxiao: We call the former things, where you can get back out what you put in, ‘injective’
18:16:19 <lingxiao> because you don't know that 6 was genereted by the function over values sum [1..3]?
18:16:23 <Twey> lingxiao: Right
18:16:37 <heatsink> lingxiao, suppose you have a type family for an index into a data structure.  An index into a list is an Int, so Index [a] = Int.  An index into a Vector is an Int, so Index (Vector a) = Int.  If I have Int = Index b, I can't solve for b.
18:16:52 <jle`> roboguy_: that sounds right
18:16:57 <heatsink> Here, 'b' is the parameter that I can't retrieve.
18:17:27 <zrho> type families do not need to be injective, basically.
18:17:58 <heatsink> In contrast, Maybe is injective.  If I have Maybe Int = Maybe b, I can solve for b.
18:18:54 <jmcarthur> roboguy_: yeah, CT is kind of "too simple" to understand right off the bat sometimes
18:19:06 <lingxiao> ahh that make sense, so syntax and terminology wise here: Foo Int = Bool, Foo is the non-injective function over types, Int is the parameter and Bool is the result
18:19:08 <lingxiao> rifht?
18:19:14 <jmcarthur> roboguy_: it's weird, initially, to assign names to such simple things
18:19:15 <roboguy_> jmcarthur: that's the feeling I keep getting, which is frustrating haha
18:19:28 <zrho> lingxiao: Right.
18:19:52 <lingxiao> zrho: but then this is different than the template Name Type1 = Type2: type family TypeProd (ts :: [Type]) :: Type
18:19:55 <Twey> lingxiao: The full syntax goes like: type family Foo ∷ ★ → ★; type instance Foo Int = Bool
18:20:12 <lingxiao> ahh ... so type family is like the "function signature"?
18:20:17 <Twey> Right
18:20:31 <roboguy_> jmcarthur: also, some things are a bit hard for me to picture (or I feel like I don't have a complete mental picture). like the arrow category
18:20:38 <Twey> You can also name the parameters, but I don't think that affects anything apart from readability
18:20:51 <lingxiao> x( it would be so much easier if they just overloaded the sytax, but use capitalized letters
18:20:55 * hackagebot dominion 0.1.0.0 - A simulator for dominion (the board game).  http://hackage.haskell.org/package/dominion-0.1.0.0 (AdityaBhargava)
18:20:57 * hackagebot env-parser 0.0.1.1 - Pull configuration information from the ENV  http://hackage.haskell.org/package/env-parser-0.0.1.1 (JosephAbrahamson)
18:21:16 <roboguy_> jmcarthur: it makes sense to me that arrow categories would exist, but it's hard for me to picture arrows being objects etc
18:21:35 <roboguy_> even though I know objects could be anything
18:21:40 <Twey> lingxiao: Preferably you wouldn't use capital letters for type functions at all, since they're not constructors, but unfortunately lower-case identifiers automatically introduce type variables
18:21:54 <tel> Speaking of injectivity and type families, can anyone explain what's going on here: http://hackage.haskell.org/package/fixed-vector-0.6.0.0/docs/Data-Vector-Fixed-Cont.html#t:Fun
18:22:22 <tel> roboguy_ That's one of the intuitions of Conceptual Mathematics... CT is all about the arrows, so the more you can do to move your intuition off the objects the more easily it'll flow
18:22:49 <shachaf> Yes, forget about objects. They're only there so that we can talk about the arrows.
18:22:51 <roboguy_> tel: well, I know that it's about arrows and not objects, but it bothers me that I can't picture the diagram very well
18:23:01 <shachaf> (And you can do without them if you try a bit.)
18:23:02 <roboguy_> shachaf: I know, I know, but I like to picture diagrams! haha
18:23:07 <shachaf> tel: What about it?
18:23:12 <lingxiao> Twey: wait if they're not constructors what are they?
18:23:25 <Twey> lingxiao: They're functions
18:23:35 <lingxiao> oh yeah meant the function name ..
18:23:45 <lingxiao> yes that was veryconfusing to me
18:23:59 <zrho> roboguy_: try to picture a commutative square. then make a circle around both the left and both the right objects. then collapse the arrow between the circles into one.
18:24:01 <tel> shachaf Maybe I've just never looked at it close enough, but it's strange that a newtype over a type family provides injectivity
18:24:03 <Twey> lingxiao: It mostly causes confusion when people expect them to be injective but they aren't
18:24:23 <lingxiao> but in this line: "type family TypeProd (ts :: [Type]) :: Type", "Type" is a kind or a type?
18:24:42 <heatsink> "Type" is a kind
18:24:46 <shachaf> Let's say F _ = Int. F isn't injective. Define newtype F' a = F' (F a). F' is certainly injective, because F' A is a different type from F' B
18:24:48 <lingxiao> Twey: yeah, I guess for me it makes sense to write non-injective functions over types, but if only it was over some unified styanx
18:24:53 <heatsink> The type ts has kind [Type]
18:24:56 <lingxiao> that reflected the symmetry in thought
18:25:03 <shachaf> Just like a phantom type.
18:25:26 <tel> roboguy_ another trick is to go "up a dimension". Instead of looking for diagrams that draw out lines between dots, think of an arrow category diagram as drawing out squares or sheets of paper between lines
18:25:34 <shachaf> newtype G a = G Int -- injective!
18:25:45 <Twey> lingxiao: What's a styanx?
18:25:56 * hackagebot egison-tutorial 3.2.1 - A Tutorial Program for The Programming Language Egison  http://hackage.haskell.org/package/egison-tutorial-3.2.1 (SatoshiEgi)
18:25:57 <roboguy_> tel: hmm, ok
18:26:00 <tel> shachaf ... Oh, I *way* overthought that
18:26:07 <geekosaur> typo for "syntax"
18:26:11 <heatsink> The river styanx
18:26:14 <tel> shachafs thanks :)
18:26:27 <tel> hah, each and every one of you shachafs
18:26:28 <lingxiao> syntax, see the poor spelling of the word syntax in english parallells the confusing syntax in haskell
18:26:54 <roboguy_> I wish I could find a good set of exercises for CT (preferably with answers)
18:26:54 <Twey> Oh!
18:26:58 <shachaf> There are more of us than you might think.
18:26:59 <zrho> lingxiao: or abominations like the word "snoc"
18:27:09 <Twey> I was trying to read it as some obscure Greek loanword
18:27:09 <tel> roboguy_ I'm not sure if it's exactly relevant to this point, but it might be fun to take a look at string diagrams as well
18:27:25 <Twey> … as opposed to a less-obscure Greek loanword
18:27:40 <roboguy_> tel: probably not yet, because some of the more basic things still confuse me
18:27:42 <tel> roboguy_ http://www.youtube.com/watch?v=USYRDDZ9yEc
18:27:44 <lingxiao> heatsink: man that is a metal name for a river, like it's full of greek monsters
18:28:02 <zrho> tel: you were faster ;)
18:28:04 <lingxiao> zirho: what's snoc? lol sorry.. I 've actually never seen the word, did I type it a while back?
18:28:36 <lingxiao> but anyways I learned so much tonight from you guys, I'm getting kicked outof the bookstore but thank you all!
18:28:39 <zrho> lingxiao: It appends an element to a list; cons spelled backwards.
18:28:54 <tel> zrho The enthusiasm of those videos.. :)
18:28:59 <lingxiao> woa that's really clever ..
18:29:09 <lingxiao> I thought my constructor :-> and deconstructor <-: was clever
18:29:20 <lingxiao> and especially thank you Twey!
18:29:56 <zrho> tel: never got to watch those new end ones.
18:30:22 <Twey> lingxiao: No problem ☺
18:30:30 <Twey> … slow
18:30:42 <tel> zrho I dropped off about 2/3rds through the sequence, but I should pick it up again
18:30:56 <zrho> tel: the string diagrams really helped me to grok natural transformations. felt just like lego then
18:31:24 <zrho> eeh
18:31:31 <zrho> I mean adjunctions^^
18:31:50 <heatsink> I'm not clear on the concept of type constructors as functions.  If I have a type-level 'id' function and I apply it to (), then I have id () which evaluates to ().  If I have Maybe, and I apply it to (), then I get Maybe (), which evaluates to what?
18:32:17 <tel> zrho yeah, when those click they click very nicely. They also sort of broke my mental mould around how to depict categories which was useful for reading about Kan extensions
18:32:55 <FreeFull> heatsink: Maybe () is the evaluated result
18:33:03 <zrho> tel: speaking of kan extensions, are there some useful applications for them in Haskell out there?
18:33:21 <jle`> can there possibly be a "thereexists" type "quantifier" analogous to "forall" ?
18:33:47 <tel> zrho I don't think I understand them well enough to answer that... but I see them tossed around from time to time, so I think somebody is getting good use out of them
18:33:52 <heatsink> But the application hasn't been eliminated, FreeFull.  That's like saying 1 + 2 evaluates to 1 + 2.
18:34:14 <jle`> heatsink: it's...more like saying Just 1 evaluates to Just 1
18:34:26 <FreeFull> http://www.haskell.org/haskellwiki/Existential_type
18:34:26 <shachaf> Codensity can be useful.
18:34:33 <shachaf> And Yoneda/CoYoneda.
18:34:54 <shachaf> Those sorts of things are the obvious examples, I guess. They don't really justify thinking about kan extensions in general.
18:35:00 <tel> shachaf I suppose I understand each of those independently, but not as Kan extensions yet
18:35:19 <FreeFull> jle`: I don't think an additional keyword is planned, since it's not needed
18:36:01 <FreeFull> jle`: You can use either forall in the right place or GADTs
18:36:42 <tel> jle` You write them like `data X = forall a . X a` compare the universal quantification `data X = X (forall a . a)`
18:37:54 <heatsink> jle`, I don't understand that either.  At a term-rewriting level, we say that applications of constructors can't be reduced.  But it's not clear what Just 1 is.
18:38:08 <dwcook> heatsink, one way you can think about it is to say that Maybe () represents both the application and the name of the resulting type. (After all, there's not really a better name for it.)
18:39:08 <athan> Hey y'all, I've got a knit-picky question for you (y'all).
18:39:48 <athan> Could a simple numeric function be considered a homomorphism, or does a homomorphism have to be on the scale of Types and not Values?
18:40:08 <eazar001> Is there a way to direct a haskell script to import a module from a sandbox package database?
18:40:31 <eazar001> just trying to get a hang of sandboxing
18:40:39 <shachaf> "homomorphism" doesn't really have a precise definition.
18:40:41 <dwcook> athan, you might have to specify what sort of homomorphism you're thinking of
18:40:53 <shachaf> If someone says e.g. "set homomorphism" they probably mean just any function at all.
18:41:03 <shachaf> I don't know what "on the scale of Types and not Values" means.
18:41:06 <roboguy_> athan: you mean something like f (x + y) == f x + f y?
18:41:47 <tel> athan "homomorphism" tends to just mean "structure preserving function", so somebody has to pick what "structure" is getting preserved
18:43:12 <heatsink> dwcook: I can understand that, if type expressions normalize to a canonical form so that two types are equal iff the expressions representing them are equal.
18:43:29 <heatsink> Is the canonical form required for that interpreatation?
18:44:58 <Twey> heatsink: It simply doesn't evaluate to anything.  Maybe () is the canonical form of Maybe ().
18:45:31 <Twey> It's equal to other things that have the canonical form Maybe ().
18:45:55 <dwcook> Trivial example: type Foo = Maybe ()
18:46:10 <Twey> Or type functions, &c.
18:46:15 <athan> A functor's `fmap` be a morphism between `f a` and `f b` through `a -> b`, correct? Would this be considered a homomorphism?
18:46:31 <athan> ** `fmap` _could_ be...
18:46:33 <athan> sorry
18:47:29 <roboguy_> well, fmap is structure preserving by definition
18:47:35 <dwcook> athan, a morphism is a homomorphism in that it preserves category structure
18:48:12 <dwcook> Or, I should say, a functor is
18:48:27 <tel> athan, after a sense, though technically you need both `(Maybe, fmap)` to make the homomorphism explicit
18:48:31 <athan> dwcook: In that it doesn't add a morphism to the existing category?
18:48:39 <tel> or whatever functor you like, not just Maybe obviously
18:48:49 <dwcook> athan, are you familiar with the functor laws?
18:49:08 <dwcook> Those basically describe what it means to preserve the category structure
18:49:09 <athan> tel I'm probably going to get more than I bargained for by inquiring this, but why is that?
18:50:26 <tel> athan It's not that big of a deal—a Functor is a morphism between categories so you need to map both the objects of the category and their maps
18:50:33 <athan> dwcook Can you remind me? I'm aware of fmap's functionality
18:50:42 <shachaf> Well, mapping the arrows is enough.
18:50:53 <tel> In Hask the objects are types, so Maybe maps types to types then `fmap :: (a -> b) -> (f a -> f b)` maps arrows to arrows
18:51:08 <athan> dwcook just not it's strict purpose
18:51:52 <athan> tel does every higher-order data type map types to types?
18:51:57 <shachaf> I mean that if you have something mapping arrows between categories that satisfies the functor laws, then there's only one possible object mapping for it.
18:51:57 <tel> shachaf yeah, but I'm just tracking all of the pieces
18:52:04 <athan> tel ie every type with a kind greater than *?
18:52:37 <shachaf> Every Functor instance has kind * -> *, and not everything with kind * -> * is a Functor instance.
18:52:55 <roboguy_> athan: something with kind (* -> *) -> * doesn't really map types to types
18:53:12 <tel> tel I'm not completely sure how to talk about higher kinded types here, I'd say not
18:53:18 <tel> oops, athan
18:54:03 <dwcook> athan, http://www.haskell.org/haskellwiki/Typeclassopedia#Laws
18:54:10 <athan> How could you create a morphism in haskell that _doesn't_ preserve categorical integrity?
18:54:25 <shachaf> newtype Fix f = Fix (f (Fix f)) is a functor from the category of Haskell Functors and natural transformations to the category of Haskell types and functions.
18:54:30 <shachaf> But maybe I'm not helping by saying that.
18:54:37 <shachaf> What is categorical integrity?
18:54:50 <shachaf> And what do you mean by morphism?
18:55:18 <tel> for all definitions above, unsafePerformIO ; )
18:55:21 <athan> that's my question, lol
18:55:56 <dwcook> athan, data Foo a = Foo Int a ; instance Functor Foo where fmap f (Foo n a) = Foo (n + 1) (f a) -- This is an illegal functor.
18:56:01 <heatsink> dwcook, Twey: Maybe types have a canonical form in Haskell because type functions have to be fully applied.  But I get the feeling that because System Fω has type-level lambdas, finding a canonical form requires being able to compute equality between functions.
18:56:04 <shachaf> You're the first person to use the phrase, so I don't know what you mean.
18:56:22 <roboguy_> athan: I'm not really sure what you mean by "create a morphism in haskell"
18:56:25 <shachaf> dwcook: Sure, you can make an illegal Functor instance. But a legal Functor instance exists.
18:56:48 <dwcook> shachaf, I was answering the question "How could you create a morphism in haskell that _doesn't_ preserve categorical integrity?"
18:57:02 <shachaf> newtype P a = P (a -> Bool) doesn't have a legal Functor instance at all.
18:57:14 <heatsink> For instance, is Just const equal to Just (\x y -> if myTheoremHolds then x else y) ?
18:57:16 <shachaf> OK. I still don't understand that question.
18:57:21 <Twey> heatsink: You often just don't bother
18:57:31 <tel> data U = U (e :: U -> Bool)
18:57:44 <heatsink> don't bother deciding whether functions are equal, you mean?
18:58:02 <shachaf> tel: ?
18:58:07 <Twey> heatsink: You can do function extensionality like that in your equality test, but that makes your type-checker undecidable
18:58:12 <tel> shachaf well, with the correct braces
18:58:45 <Twey> heatsink: So the more popular way at the moment is to not check for function equality when deciding judgemental equality and just assume they're unequal (or maybe just check trivial syntactic equality)
18:58:46 <roboguy_> athan: this is why I'm not sure that trying to frame haskell questions in terms of category theory is a good idea at this point...
18:59:03 <tel> it's the topic of another neighborhood of infinity post, it encodes Russell's paradox
18:59:26 <shachaf> Looks a lot like Curry's paradox to me.
18:59:36 <tel> http://blog.sigfpe.com/2008/01/type-that-should-not-be.html
18:59:39 <shachaf> Then again those are pretty similar.
18:59:58 <Twey> heatsink: You can always prove the functions are the same later, using propositional equality inside the system (or at least that they provide the same outputs for the same inputs — whether that equates to literal equality of functions depends on your theory too)
19:00:11 <shachaf> Especially when you parameterize it: newtype Rec a = Rec { unRec :: Rec a -> a }
19:00:12 <athan> roboguy_ good point haha. I just want to understand the meaning behind all these definitions.
19:00:17 <shachaf> You can make GHC panic with that type.
19:00:22 <tel> The money shot is: U $ \a -> not (a `e` a)
19:00:46 <roboguy_> athan: well, the haskell usage of the terms are more specific than the category theory usage, so it would probably be easier to understand it in terms of haskell (for the moment at least)
19:00:48 <tel> shachaf Really? Now I have to play
19:01:07 <shachaf> Not in ghci.
19:01:22 <tel> oh, what else do you need? modules?
19:01:31 <shachaf> It's an inliner thing, so you need some optimizations.
19:01:37 <tel> ah
19:01:51 <shachaf> Since you're writing a recursive value without using the kind of recursion it knows to ignore.
19:02:17 <shachaf> You can write fix without recursion using Rec!
19:02:26 <roboguy_> athan: so, a Functor instance is just an instance of a type that satisfies the fmap laws. that's pretty much all there is too it (although admittedly this doesn't give you much intuition about it in the beginning)
19:02:31 <shachaf> (Without value-level recursion.)
19:02:53 <tel> Is that one of the ways to encode Y?
19:03:03 <Twey> tel: Basically this post says ‘Haskell's type system is inconsistent’, which is trivially true
19:03:11 <athan> roboguy_ Why are the functor laws useful? What securities do they give you within your code?
19:03:29 <johnw> athan: the ability to reason, that's what any laws give you
19:03:30 <heatsink> Twey, that's certainly a way to do type checking, but I'm really asking about semantics.  Semantically, we can ask whether (Just const) and (Just (\x y -> if riemannHypothesisHolds then x else y)) denote the same object.  What do we say about that?
19:03:39 <shachaf> Twey: Well. This is more interesting than most cases.
19:03:39 <roboguy_> athan: they mean that a Functor cannot modify the "structure" of the data (to put it somewhat informally)
19:03:41 <athan> roboguy_ sorry if my questions seem shallow, my brain is just straining right now so every chance I get at a good question is taken without hesitation haha.
19:04:25 <athan> roboguy_ the structure of the data parameter? Like the a in `Maybe a`?
19:04:31 <johnw> athan: if fmap had no laws, it would simply be less valuable as an abstraction
19:04:31 <roboguy_> athan: the example dwcook gave earlier would be an example of an invalid functor instance: data Foo a = Foo Int a ; instance Functor Foo where fmap f (Foo n a) = Foo (n + 1) (f a)
19:04:37 <cmiller_> Hi, trivial syntax function. Is it ok to have a where block inside a guard?
19:04:38 <Twey> heatsink: We can say that they are equal iff riemannHypothesisHolds :þ
19:04:49 <heatsink> haha, okay
19:04:55 <shachaf> cmiller_: It won't be inside the guard.
19:04:56 <roboguy_> athan: an example of an invalid functor instance for Maybe would be: instance Functor Maybe where fmap _ _ = Nothing
19:05:08 <cmiller_> At the bottom of all the guards?
19:05:10 <roboguy_> that's not a Functor
19:05:16 <shachaf> E.g. if you write "f x | ... = ... | ... = ... where ...", the last ... will be shared among the two guards.
19:05:29 <shachaf> Twey: If you were trying to make Haskell consistent, the first step you might take is eliminating recursive values.
19:05:32 <cmiller_> KK. That basically answers it.
19:05:33 <heatsink> So they're the same object iff riemannHypothesisHolds?
19:05:38 <roboguy_> athan: note how it doesn't preserve Just
19:05:39 <Twey> shachaf: It seems to come down to non-terminating values having any type
19:05:52 <shachaf> Not that you need to eliminate them entirely, but even if you do, that turns out to not be good enough.
19:06:06 <shachaf> You also need to eliminate some kinds of type-level recursion.
19:06:15 <shachaf> (Negative recursion, in particular.)
19:06:20 <Twey> Yes
19:06:24 <athan> roboguy_ By preserve, do you mean that Just is impossible, thus it's not preserved?
19:06:38 <roboguy_> athan: Just input should give you Just output and Nothing output should give you Nothing output
19:06:41 <roboguy_> to be valid
19:06:47 <Twey> Oh, right, that's a negative type too
19:06:58 <shachaf> Yes, that's the problem with U.
19:07:04 <athan> roboguy_ Or do you mean that somewhere in the Functor, there must be a direct relation between the origional data and the manipulated data (by the function argument of `fmap`)?
19:07:05 <roboguy_> athan: this example doesn't satisft fmap id == id
19:07:19 <athan> AH
19:07:23 <roboguy_> athan: I just mean that fmap id == id
19:07:26 <roboguy_> that's the first law
19:07:47 <roboguy_> the other one is fmap f . fmap g == fmap (f . g)
19:07:48 <Twey> I miss negative types in Agda more than I miss general recursion
19:08:05 <Twey> I wonder if there's a way to reconcile consistency with negative types
19:08:17 <tel> I'd love to see augustuss' approximation to the infinite domain of U... I get a few ways that it's problematic, but I don't have enough machinery to see all the reasons why
19:09:07 <roboguy_> athan: actually, every type has at most one valid Functor instance. this isn't necessary to know at this point, but I thought it might be interesting to point out
19:09:21 <athan> hmm
19:10:37 <athan> roboguy_ So functors allow you to work with more advanced features, while still using primatives that _never_ break, like fmap id = id
19:11:13 <athan> roboguy_ and it's those primatives that are a haskeller's bread-and-butter, so to speak
19:11:31 <athan> roboguy_ man, this is awesome haha. Thank you for being so kind and helpful.
19:11:35 <roboguy_> athan: well, it's the Functor's bread-and-butter
19:11:37 <roboguy_> sure, no problem!
19:12:33 <roboguy_> athan: most type classes have laws like this, by the way
19:13:20 <athan> roboguy_ I've seen them, like monoids, monads, etc. I just don't understand how they can be useful (yet)
19:13:43 <roboguy_> athan: work with Functor some before those
19:14:01 <roboguy_> athan: also, don't skip right to Monad. learn about Applicative first
19:14:06 <tel> did anyone link the typeclassopedia yet? because you can never link the typeclassopedia too many times
19:14:26 <tel> http://www.haskell.org/wikiupload/e/e9/Typeclassopedia.pdf
19:15:20 <athan> roboguy_ I've already worked with them a bit, I've got some experience working with Yesod. What I really need to learn are the principals of each of these law-sets, so that I can understand the philosophy of working with them. I feel like this knowledge will then help me understand how the lens library works (and how haskell in general has been so successful)
19:15:36 <roboguy_> athan: that's a good idea
19:15:56 <shachaf> I've never read the Typeclassopedia. Maybe I should read it.
19:17:09 <cmiller_> Lol @typeclassopedia "anyone ignorant of the types in their code is doomed to eternal uncertainty. “Hmm, it doesn’t compile. . . maybe I’ll stick in an fmap here. . . nope, let’s see. . . maybe I need another
19:17:11 <cmiller_> (.) somewhere? . . . um . . . ”
19:17:19 <cmiller_> That's 100% me
19:18:39 <heatsink> Yah, I've seen others do that
19:19:59 <heatsink> It helps a lot to figure out if the types in error messages are the types you actually want
19:20:16 <jrmithdobbs> i dunno, understanding it doesn't help that much either it just changes to "what fmap/(.) did i forget damn it"
19:20:18 <roboguy_> I usually try to do the type hole thing
19:20:43 <heatsink> What is a type hole?
19:20:54 <tel> ha, yeah, ImplicitParams is the only thing in my .ghci
19:21:09 <roboguy_> heatsink: http://matthew.brecknell.net/post/hole-driven-haskell/
19:21:10 <Platz> are there any FP or Haskell podcasts besides The Haskell Cast?
19:21:40 <roboguy_> heatsink: it's basically when you put something in that you know won't type check so you can see the error. GHC 7.8 will have official support for it and GHC HEAD already has it
19:22:09 <roboguy_> that's actually one of the main reasons I installed GHC HEAD, haha
19:22:12 <heatsink> I see
19:22:12 <jrmithdobbs> roboguy_: why is that a video and not text
19:22:33 <tel> heatsink You can use ImplicitParams to name unknown parts of code and GHC will spit out the inferred type even in GHC 7.6
19:22:39 <roboguy_> jrmithdobbs: I guess he decided to make it a video?
19:22:46 <roboguy_> here's some text http://www.haskell.org/haskellwiki/GHC/TypeHoles
19:22:51 <jrmithdobbs> screencasts of text editors make me angry
19:22:52 <jrmithdobbs> heh
19:23:02 <Twey> tel: People use ImplicitParams?  :þ
19:23:12 <athan> You know what really grinds my gears? How Ubuntu 13.10 doesn't support happy 1.19.
19:23:13 <Twey> Oh, as holes?
19:23:23 <tel> Twey only reason I touch 'em
19:23:27 <Twey> Interesting
19:24:04 <tel> :t fmap . ?f . fmap
19:24:04 <lambdabot> (Functor f, Functor f1, ?f::(f1 a1 -> f1 b1) -> a -> b) => (a1 -> b1) -> f a -> f b
19:24:16 <roboguy_> athan: really? huh
19:25:18 <athan> roboguy_: I know! I can't compile ghc >= 7.8 until either ubuntu 14.04 gets released, or I do something daring like install gentoo on my work computer... haha..... *cringe*
19:25:35 <roboguy_> athan: what kind of errors is it giving?
19:25:53 <tel> ta ta #haskell
19:26:00 * hackagebot simple-templates 0.7.0.1 - A basic template language for the Simple web framework  http://hackage.haskell.org/package/simple-templates-0.7.0.1 (AmitLevy)
19:26:31 <athan> well, I mean, ghc 7.8 requires happy 1.19, and ubuntu has only 1.18.x available (same with hackage for ghc <= 7.6)
19:27:41 <roboguy_> athan: did you try installing GHC HEAD directly?
19:28:02 <roboguy_> because I think that should take care of happy, etc
19:35:13 <BrianHV> I have a cabal sandbox in which cairo and ghc-mod are installed, as confirmed by ghci. however, "./.cabal-sandbox/bin/ghc-mod list" responds with "Dummy:0:0:Error:<command line>: cannot satisfy -package cairo". what should I be checking?
19:36:01 * hackagebot concurrent-state 0.1.0.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.1.0.0 (JoelTaylor)
19:36:39 <johnw> joelteon: handy!
19:38:35 <athan> roboguy_ I tried to install it straight from the github repo from the standard instructions there, I'm still new to programming, but I'm pretty sure I tried to compile the head of the master branch.
19:38:53 <roboguy_> athan: that didn't work?
19:39:20 <athan> roboguy_ nope :/ I'm honestly just going to go with gentoo haha.
19:39:43 <athan> roboguy_ I heard ghc 7.8 has some new IO stuff in it
19:40:05 <frege> my dear friends
19:40:06 <Twey> athan: What kind of new IO stuff?
19:40:08 <frege> how's your night?
19:41:01 <roboguy_> athan: yeah, I the parallelism should be faster I hear
19:41:24 <athan> roboguy_: I heard it has a completely new IO implementation. I heard this from the mostly erlang podcast featuring the author of yesod, michael snoyman
19:41:39 <athan> whoops, I meant Twey
19:41:57 <roboguy_> that's probably not stuff that the programmer would be exposed to, though
19:42:01 <Twey> Another one?
19:42:22 <frege> > let extremes xs = [b | a:b:c:_ <- tails xs, (a < b && b > c) || (a > b && b < c)] in extremes [0,9,2,1,6,3,5,4,7,8]
19:42:23 <lambdabot>  [9,1,6,3,5,4]
19:42:27 <Twey> Oh, no, Mio's coming: « Mio will be released as part of GHC 7.8.1 »
19:42:29 <Twey> Awesome
19:42:33 <frege> this doesn't work in ghci let extremes xs = [b | a:b:c:_ <- tails xs, (a < b && b > c) || (a > b && b < c)] in extremes [0,9,2,1,6,3,5,4,7,8]
19:43:00 <frege> there is no tails!!!!!!!!
19:43:12 <Twey> frege: import Data.List
19:43:16 <dwcook> frege, import Data.List
19:43:39 <Twey> athan: Mio is fast
19:43:53 <Twey> athan: Mio does fast things.  I don't know what it does that makes it fast, but I've seen graphs!
19:44:05 <athan> Twey: I can't wait!!
19:44:20 <joelteon> well, it's better on multi cores
19:44:21 <athan> Twey: well, Mio will probably fix that lol
19:44:38 <Twey> Wasn't it a scheduler?
19:44:38 <frege> tnx
19:44:39 <jrmithdobbs> oh mio got pushed?
19:44:43 * Twey looks it up again
19:44:45 <joelteon> is there going to be a 7.8.0?
19:44:48 <_davide> hi guys -- is there an haskell function I can use to circularly rotate strings?
19:45:11 <joelteon> @let rotate [] = []; rotate (x:xs) = xs ++ [x]
19:45:12 <jrmithdobbs> Twey: it does magic to have more than one io thread
19:45:13 <lambdabot>  Defined.
19:45:20 <joelteon> > rotate "hello"
19:45:20 <lambdabot>  Ambiguous occurrence `rotate'
19:45:21 <lambdabot>  It could refer to either `L.rotate', defined at L.hs:162:1
19:45:21 <lambdabot>                        or `Data.Bits.rotate',
19:45:21 <lambdabot>                           imported from `Data.Bits' at L.hs:56:1-16
19:45:31 <joelteon> oh, whoops
19:45:33 <jrmithdobbs> the effects of how it works is pretty straight forward, how it works not so much ;p
19:46:02 * hackagebot language-c-inline 0.3.0.0 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.3.0.0 (ManuelChakravarty)
19:46:22 <roboguy_> ^ that could come in handy for me
19:46:47 <Twey> Oh right, it's an IO manager inside GHC
19:46:55 <_davide> jrmithdobbs: thanks
19:47:03 <athan> Sorry if I'm annoying everyone, but just to be clear of a definition of an isomorphism: a hash like SHA256 is NOT isomorphic, correct?
19:47:06 <Twey> jrmithdobbs: Right, just found the paper (or rather, added a third copy to my ‘to read’ list)
19:47:07 <_davide> sorry -- joelteon
19:47:20 <roboguy_> athan: correct. you can't get the original data back
19:47:25 <Twey> athan: An isomorphism means you can go there and back again with no loss of information
19:47:31 <Twey> And vice versa
19:48:24 <Twey> SHA256 is not an isomorphism: you crush a big thing into a small hash, so most of the data is inevitably lost, even if the hash function were completely useless at preventing its recovery
19:49:12 <athan> Twey: Ahhh, so these definitions are more about information loss than about their physical composability (like how types need to match, etc. The definitions like isomorphism, endomorphism, etc. all try to explain information availability rather than physical composability)
19:49:21 <athan> I think I'm starting to get it...
19:49:25 <nexx> It is not even injective even though we often tread hash functions like that
19:49:37 <Twey> athan: I'm not sure what you mean by ‘physical composability’
19:50:03 <nexx> * treat
19:50:25 <dwcook> athan, an isomorphism is a pair of morphisms (functions if we're discussing Set) f and g such that f . g = id and g . f = id. e.g., rot13 forms an isomorphism with itself, since rot13 . rot13 = id.
19:50:42 <dwcook> But hashing functions are specifically designed such that there *is* no inverse.
19:50:45 <jrmithdobbs> athan: but a -> (Sha256digest,a), is isomorphic again (so long as a is used to produce _1 anyways)
19:51:14 <jrmithdobbs> athan: because you're storing the hashed data with the hash so you can get the data back and drop the hash and you can always derive the hash from the data.
19:51:53 <athan> dwcook: I see. Thank you
19:52:08 <Twey> I.E. pairHash . fst = id, fst . pairHash = id
19:54:41 <heatsink> athan, most of the time you can think of a type as a set of values.  Bool is the set {True, False}.  Int is the set of all integers, and so forth.
19:55:12 <heatsink> It helps to think of isomorphisms, injections, and surjections as drawing arrows from the values in one set to the values in another.
19:55:16 <dwcook> By the way, a fun thing is that you *can* compose sha256 with another function to get id. You can come up with a g such that sha256 . g = id.
19:55:31 <dwcook> You just can't compose it the other way: There is no f such that f . sha256 = id.
19:55:51 <shachaf> dwcook: Well, maybe. It would be hard to prove.
19:56:15 <athan> dwcook: would g be simply a brute-force search?
19:56:17 <roboguy_> shachaf: you mean the first thing?
19:56:38 <dwcook> Maybe instead of "can" I should have said "don't know definitively that you can't". I haven't bothered proving it myself.
19:56:39 <roboguy_> (with g)
19:56:57 <nexx> heatsink I think your statement could lead to confusion between bijection and isomorphism
19:56:59 <athan> I've got a strange idea in my head guys...
19:57:16 <athan> Is a type of kind * -> * basically just a morphism between concrete types?
19:57:35 <athan> Like `a -> f a`, after f * -> * is applied to a?
19:57:39 <roboguy_> athan: well, it's a morphism between *types* (not necessarily concrete)
19:57:43 <athan> much like a function?
19:58:06 <jrmithdobbs> dwcook: well, there's the intutive example where g is a finite set since dups don't need to be considered as long as you have one successful value that hashes
19:58:07 <roboguy_> it's like a (restricted) type level function
19:58:07 <athan> roboguy_: right, you could have recursive types like lists, too. Right?
19:58:16 <jrmithdobbs> err a lookup on a finite set
19:58:50 <dwcook> jrmithdobbs, that's basically what I was thinking of
19:58:53 <roboguy_> athan: it is sort of like a type level function. type families are even more flexible type level functions (you can pattern match on types)
19:59:52 <athan> roboguy_: Yeah, I glanced at them. I really need to get comfortable with ghc extensions
19:59:58 <shachaf> I would be impressed if you successfully "bothered" to prove that sha256 is surjective.
20:00:00 <jrmithdobbs> dwcook: but i think the more general point you were trying to state isn't actually true for all cases
20:00:50 <heatsink> nexx, I think they're equivalent on sets.  If two sets are in bijection, then all the other properties of the first set hold when you map them to the corresponding elements of the second set.
20:00:57 <jrmithdobbs> dwcook: because there is no way to force sha256 to output a larger digest so you *cannot* compose it such that it will produce any original input which was larger than the digest size
20:01:06 <dwcook> I also think I misstated or missed a detail from the definition of isomorphisms
20:01:09 <heatsink> So they'd be isomorphic, right?
20:01:12 <shachaf> fsvo "properties"
20:08:54 <roboguy_> athan: Rank2Types/RankNTypes is an important one
20:08:59 <roboguy_> lens needs it
20:09:08 <roboguy_> (at least, internally)
20:09:15 <roboguy_> and sometimes externally
20:09:20 <nexx> heatsink I guess I don't really understand what a "isomorphism on sets" means. I know them as bijective homomorphism. If "on sets" means leaving out the operation on it, it should be the same
20:09:40 <carter> o/
20:09:43 <carter> i've not bee here in a while
20:09:57 <carter> who here like numerical computations?
20:10:04 <carter> i wanna ramble about those!
20:10:07 <carter> :)
20:10:09 <carter> in haskell
20:10:14 <enthropy> roboguy_: when? There's cloneLens to work around one case you might think you need RankNTypes
20:10:21 <carter> (base numerical type classe woes aisde)
20:10:29 <carter> *i can't spell, long day
20:11:04 * hackagebot xxhash 0.0.1 - A Haskell implementation of the xxHash algorithm  http://hackage.haskell.org/package/xxhash-0.0.1 (ChristianMarie)
20:11:44 <roboguy_> enthropy: oh, maybe there isn't then
20:11:52 <roboguy_> I forgot about cloneLens
20:12:06 <roboguy_> carter: I like it when my numerical computations are fast
20:12:08 <ddere> carter: Have you written an article on it or something?  I'm interested in it, but have no idea what to ask or where to start, and have never really had to do it yet, I'd definitely like to read something on the subject
20:12:08 <nexx> heatsink but why would you say "isomorphism on sets" instead of "bijection"?
20:14:07 <heatsink> nexx, that's what I understand people to mean when they say that two types are isomorphic
20:14:22 <roboguy_> enthropy: it's still a good extension to know especially if you want to understand how lens works
20:14:43 <carter> ddere: good question
20:14:46 <enthropy> sure. It's not a nice extension because it makes you write type signatures.
20:14:55 <enthropy> but then again so do type class instances
20:14:56 <carter> ddere: honestly i need to start blogging for serious
20:14:57 <carter> BUT
20:14:57 <nexx> heatsink I guess I really should start with category theory https://en.wikipedia.org/wiki/Bijection#Bijections_and_category_theory
20:15:16 <carter> ddere: idontgetoutmuch.wordpress.com is a lovely blog that has numerical computation and math
20:15:20 <carter> heatsink: hows the hacking?
20:15:48 <ddere> carter: yeah you definitely should considering the stuff you have written
20:15:48 <roboguy_> enthropy: instanciating a type class, in and of itself, doesn't require you to write type signatures...
20:15:56 <carter> what stuff have i written?
20:15:59 <carter> i'm writing stuff
20:16:04 * hackagebot language-c-inline 0.3.0.1 - Inline C & Objective-C code in Haskell for language interoperability  http://hackage.haskell.org/package/language-c-inline-0.3.0.1 (ManuelChakravarty)
20:16:05 <carter> but its not really ready for use / consumption yet
20:16:06 * hackagebot flippers 1.0.1 - Variations on flip for multiple arguments  http://hackage.haskell.org/package/flippers-1.0.1 (ChristianMarie)
20:16:08 <carter> YUP
20:16:12 <carter> language inline c === matic
20:16:14 <carter> *magic
20:16:34 <ddere> carter: well you have written parts of what you are currently writing....
20:16:39 <carter> true1
20:16:44 <roboguy_> I've been hoping someone would make an inline c library for a little while now
20:16:52 <carter> roboguy_: this is better
20:16:57 <roboguy_> especially inline Obj-C, which they also covered
20:16:57 <carter> it also does inline objective c!
20:17:00 <roboguy_> haha
20:17:40 <enthropy> roboguy_: the stuff between "instance" and "where" follows the same syntax as a type though
20:17:42 <heatsink> I found that someone had already instrumented the interpreter to find peephole optimization opportunities and I turned that on, carter.  Still need to set up a TH-intensive example so I have something to profile.  But I haven't been working on the interpreter for the last few weeks.
20:17:47 <roboguy_> that should improve the support for iphone development
20:17:53 <athan> Hmm, I think I understand the difference between categorical functors and haskell functors now (or at least a significant detail)
20:17:55 <carter> heatsink: oh cool!
20:18:00 <carter> so even less wokr than you thought?
20:18:04 <dwcook> roboguy_, you mean like a library that reasons about C programs, e.g., letting you construct them dynamically?
20:18:12 <carter> is that peephole stuff documented anywhere?
20:18:13 <roboguy_> enthropy: well, that's less like a type signature and more like a type application
20:18:26 <roboguy_> dwcook: I mean a library like the one hackagebot just mentioned (language-c-inline)
20:18:54 <ddere> carter: thanks for the link!
20:18:58 <dwcook> Ah, neat.
20:19:04 <enthropy> call it whatever you like
20:19:14 <carter> ddere: i can't really blog about stuff in an accessible way till i have a lib thats human friendly ready!
20:19:18 <carter> though i am writing up the ideas
20:19:28 <athan> The categorical definition of a functor can be created in haskell when you supply a function of (a -> b) to fmap on a type a. The category has the explicit morphisms between the categories defined, while haskell's idea of a functor is polymorphic both in it's underlying type, and in the atomic morphism to be applied to each value.
20:19:43 <ddere> carter: haha you may find the former will help with the latter...
20:19:52 <maurer> @hoogle [a] -> Int -> Maybe a
20:19:53 <lambdabot> Prelude (!!) :: [a] -> Int -> a
20:19:53 <lambdabot> Data.List (!!) :: [a] -> Int -> a
20:19:53 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
20:19:57 <maurer> Really?
20:19:58 <carter> ddere: so you agree? :)
20:20:14 <heatsink> The instrumentation isn't documented, carter.
20:20:28 <carter> ok
20:20:29 <heatsink> From the bytecodes, I'm guessing they used it to optimize stack push/pop operations
20:20:46 <carter> heatsink: honestly, a patch adding some documentation would get merged in super fast
20:20:50 <carter> and would be really cool!
20:20:57 <carter> sounds like no one knew about that1
20:21:06 <ddere> carter: I mean to say the blog might help you get feedback that could help you make your lib user friendly
20:21:11 <carter> yes
20:21:15 <heatsink> By documentation, you mean source code comments?
20:21:27 <carter> heatsink: were there comments?
20:21:47 <roboguy_> maurer: ix will do that
20:22:41 <carter> ddere: tricky bit is i'm still polishing the not quite human friendly api
20:22:45 <carter> :)
20:22:53 <ddere> carter: ah ok
20:23:08 <carter> i've a lib thats nearly ready thats not meant for human use
20:23:29 <roboguy_> > [1,2,3] ^? ix 1
20:23:32 <lambdabot>  Just 2
20:23:34 <roboguy_> ^ maurer
20:23:36 <carter> but rather for lib author use so no one has to write an ffi binding ever again for blas / lapack ('cause too many bindings have design decisions baked in)
20:23:40 <heatsink> Two lines of comments in 80 lines of code, carter.  Mostly I figured things out from the variable names.
20:23:46 <carter> ok
20:23:48 <carter> hrmmm
20:24:08 <maurer> @src ^?
20:24:08 <lambdabot> Source not found. Are you on drugs?
20:24:13 <carter> if adding comments could make it more discoverable / usable for future adventurers, worth a patch!
20:24:14 <maurer> @src (^?)
20:24:14 <lambdabot> Source not found. My mind is going. I can feel it.
20:24:17 <roboguy_> maurer: it's in lens
20:24:31 <nexx> so lib authors aren't humans?
20:24:33 <heatsink> okay
20:24:34 <roboguy_> carter: is your library something that, for example, linear would use (potentially)?
20:24:43 <carter> the ffi stuff or the stuff above it?
20:24:45 <carter> nexx: nope
20:24:54 <carter> they're machines to make things that are meant for humans
20:25:08 <bb010g> Could you make a generic index for foldable/traversable (I tend to confuse their abilities)?
20:25:27 <carter> :)
20:25:37 <carter> roboguy_: linear is its own thing really
20:25:48 <carter> like, the use case of linear that will be really awesome (and i have some ideas about)
20:25:58 <carter> is to have a deep embedding DSL for simd  for cpu and gpu
20:26:07 <roboguy_> bb010g: that's actually kind of what ix is, except it's general enough to work for different Traversals as well
20:26:11 <nexx> carter so you are a meta machine? Making things for machines wich make things for humans?
20:27:54 <roboguy_> or well, actually that's not true. but it does compose with other lens stuff which is nice
20:27:57 <athan> How are contravariant functors possible?
20:28:09 <athan> Don't their types mismatch on composition?
20:28:10 <carter> nexx: i'm not that awesome :)
20:28:13 <roboguy_> athan: I wondered the same thing at first
20:28:17 <carter> (yet)
20:28:20 <nexx> carter :)
20:28:45 <athan> roboguy_:  D:
20:28:48 <roboguy_> athan: conceptually, you can think of a (covariant) Functor as maping on output and a Contravariant functor mapping on the input
20:29:04 <roboguy_> athan: are you familiar with the function type Functor?
20:29:08 <roboguy_> *Functor instance
20:29:32 <athan> roboguy_:  Are normal functors covariant? And I am familiar with the typeclass, not the type, though
20:29:48 <roboguy_> athan: the Functor type class is only contravariant functors
20:29:48 <athan> Ah, somewhat, I may need a refresher
20:30:00 <dwcook> roboguy_, covariant, surely?
20:30:06 <roboguy_> we have a Contravariant type class (in a library) for (some) contravariant functors
20:30:09 <roboguy_> dwcook: yep
20:30:10 <roboguy_> oops
20:30:21 <roboguy_> athan: the Functor type class is only for *covariant* functors
20:30:27 <athan> roboguy_ gotchya haha
20:30:43 <roboguy_> athan: anyway, are you familiar with the ((->) r) instance of Functor?
20:30:54 <athan> roboguy_ Not very, no
20:31:00 <roboguy_> athan: do you know it's definition?
20:31:08 <roboguy_> that might be a good exercise
20:31:22 <roboguy_> and it'll lead right into Contravariant!
20:31:26 <roboguy_> (afterwards)
20:31:32 <athan> roboguy_: Doesn't it just leverage (.)?
20:31:37 <roboguy_> yep
20:32:05 <athan> roboguy_: hmm, okay. Do contravariants basically invert (.)?
20:32:11 <roboguy_> well, sort of
20:32:11 <athan> for the function implementation, I mean
20:32:26 <roboguy_> for the Functor instance of ((->) r), we have fmap = (.)
20:32:35 <roboguy_> this is the same as fmap f g = f . g
20:32:52 <roboguy_> so, we are mapping f over the output of g, conceptually
20:32:54 <athan> Ahh! Okay!
20:33:07 <athan> interesting......
20:33:14 <athan> keep going though, please!
20:33:30 <roboguy_> our Contravariant instance for opposite functions (data Op a b = Op (b -> a)) looks like this: contramap f (Op g) = Op (g . f)
20:33:34 <augur_> roboguy_: you're skirting very close to that perilous lemma...
20:33:39 <roboguy_> note we map over the input instead of the output
20:33:43 <roboguy_> augur_: which?
20:33:55 <augur_> yoneda
20:34:04 <roboguy_> I'm not very familiar with yoneda actually
20:34:21 <augur_> once you cross the yoneda boundary, there's no return
20:34:26 <augur_> your mind will be forever blown
20:34:41 <roboguy_> I tried to read some stuff about it before, but I haven't quite grasped it yet. I'll have to look over it again
20:34:50 <augur_> i can explain yoneda if you want. :D
20:34:52 <roboguy_> it reminded me of parametricity sort of
20:34:54 <roboguy_> sure
20:34:57 <athan> hmm, I see, so contramaps are good for prefixing morphisms instead of appending a suffix on their computation
20:35:04 <dwcook> Ooh, story time!
20:35:07 <dwcook> Err, lemma time?
20:35:08 <augur_> roboguy_: you know what a continuation is?
20:35:12 <roboguy_> augur_: yeah
20:35:41 <augur_> roboguy_: ok, so you know, then, how given a type A, we have  A ~ forall r. (A -> r) -> r
20:36:09 <roboguy_> yeah
20:36:25 <augur_> roboguy_: ok, so now stick a functor in there:   F A ~ forall r. (A -> r) -> F r
20:36:36 <roboguy_> hmm, ok
20:36:40 <dwcook> augur_, could you write functions to witness that fact?
20:36:55 <augur_> dwcook: yep.
20:37:05 <augur_> roboguy_: so consider the normal continuation case:
20:37:29 <augur_> continuize :: forall a. a -> (forall r. (a -> r) -> r)
20:37:36 <augur_> continuize x = \f -> f x
20:37:52 <augur_> decontinuize :: forall a. (forall r. (a -> r) -> r) -> a
20:37:59 <augur_> decontinuize k = k id
20:38:24 <dwcook> Neat.
20:38:26 <augur_> and you can calculate that these form an iso
20:38:32 <augur_> now just do this for the functorial case
20:39:07 <augur_> continuizeF :: forall a f. Functor f => f a -> (forall r. (a -> r) -> f r)
20:39:23 <augur_> continuizeF x = \f -> fmap f x
20:39:45 <augur_> decontinuizeF :: forall a f. Functor f => (forall r. (a -> r) -> f r) -> f a
20:39:55 <augur_> decontinuizeF f = f id
20:40:31 <augur_> the non-functorial continuize is obviously the special case for f = Identity
20:40:40 <roboguy_> right
20:40:59 <johnw> cool way to present Yoneda
20:41:00 <augur_> roboguy_: thats the yoneda lemma!
20:41:06 * hackagebot concurrent-state 0.2.0.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.2.0.0 (JoelTaylor)
20:41:33 <dwcook> augur_, why is it significant?
20:41:42 <roboguy_> I'm not sure what that accomplishes
20:42:12 <augur_> dwcook: well, for category theory it means that you can treat an object as "the same" as the functions out of it
20:42:37 <augur_> dwcook: so the type A is morally equivalent to the type of functions from A to something else
20:42:47 <dwcook> You mean that an object is uniquely determined by the morphisms that have it as a source?
20:42:50 <johnw> roboguy_: the "continuized" form is itself a functor
20:43:06 <augur_> dwcook: i dont want to say determined, just, "basically the same as"
20:43:09 <roboguy_> athan: that is one way to think of it, but be careful thinking about them too much as computations. not all of them could be described that way
20:43:22 <roboguy_> hmm
20:43:29 <augur_> dwcook: a way of thinking of it is that a thing is "the same as" the sum total of what it can do
20:43:55 <dwcook> I think someone was touching on that earlier when they said that we didn't need to mention objects, just morphisms. I forget the context.
20:44:05 <augur_> sort of
20:44:26 <augur_> there's also a nice video on yoneda being used to reason about things, i think its called Reasoning Isomorphically
20:44:56 <augur_> where the basic idea is that because of the isomorphism, you can prove that certain things exist, even if you dont know quite what they "are" in any simpler terms
20:45:50 <augur_> you can use yoneda to get into a domain where its easy to prove, say, that there are exponentials between functors, even if you dont quite know what such a thing should be without using yoneda
20:46:36 <frege> guys I have some noobie questions
20:46:43 <frege> in "let extremes xs = [b | a:b:c:_ <- tails xs, (a < b && b > c) || (a > b && b < c)] in extremes [0,9,2,1,6,3,5,4,7,8]"
20:46:43 <johnw> frege: cool!
20:46:44 <augur_> noobie doobie
20:46:55 <frege> what does b | a:b:c:_ is about?
20:47:10 <augur_> frege: in a list comprehension, you have this:
20:47:16 <augur_> [ x | t ]
20:47:17 <frege> what is "b | a:b:c:_" about?
20:47:23 <augur_> x is the thing the list will consist of
20:47:31 <augur_> t is the condition under which it will contain that thing
20:47:32 <frege> ah I see
20:47:33 <roboguy_> frege: it is part of a list comprehension
20:47:36 <frege> so it's the output
20:47:38 <augur_> its like a set comprehension
20:47:43 <dwcook> You're quoting a fragment of a list comprehension when it's best understood as a whole
20:47:44 <augur_> { x | t }
20:47:50 <augur_> { (x,y) | x < y }
20:47:57 <augur_> the pairs (x,y) such that x < y
20:48:02 <frege> gotcha
20:48:04 <augur_> same thing for list comps
20:48:08 <dwcook> a:b:c:_ <- tails xs, in particular, binds the parts of the result of tails xs to those variables
20:48:21 <frege> how about the arrow? <- tails xs
20:48:25 <augur_> yeah. sometimes you also want to pattern match too
20:48:28 <dwcook> Your b is the second element you get from tails xs
20:48:30 <augur_> <- means is in
20:48:45 <dwcook> (This match will fail on a list with fewer than three elements)
20:48:51 <augur_> frege: so this means something like   { b | [a,b,c,...] is in tails xs, and ... }
20:49:06 <roboguy_> > [x * 10 | x <- [1..5]]
20:49:07 <lambdabot>  [10,20,30,40,50]
20:49:14 <frege> interesting
20:49:25 <augur_> frege: its basically just set comprehensions
20:49:28 <roboguy_> > [(x, y) | x <- [1..5], y <- [1..5]]
20:49:29 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3,...
20:49:33 <frege> how can I pattern match lists with less than three elements and return an empty list or the list itself?
20:49:42 <cschneid> What does this tweet mean? https://twitter.com/HaskellTips/status/425488986824404992 -- Where could I go read more about what its doing
20:49:55 <augur_> frege: i think it skips those cases entirely
20:50:07 <roboguy_> yeah, it does
20:50:27 <roboguy_> > [x | [x] <- [[], [], [], [1], [2], [3,4,5,6]]
20:50:28 <lambdabot>  <hint>:1:46:
20:50:28 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
20:50:32 <augur_> i think there's probably something like MonadPlus or something going on here, so that you can have "failure" values or something
20:50:33 <roboguy_> > [x | [x] <- [[], [], [], [1], [2], [3,4,5,6]]]
20:50:34 <lambdabot>  [1,2]
20:50:38 <frege> does the direction of <- matter?
20:50:42 <roboguy_> yes
20:50:45 <frege> how does the direction work?
20:50:45 <roboguy_> it can only go to the left
20:50:53 <frege> really
20:50:59 <augur_> thats just notation, frege
20:51:00 <roboguy_> no reason to have it any other way
20:51:03 <maurer> Hey, is there an easy way to connect another Handle to stdin? Specifically, I'm doing runInteractiveProcess, and want to forward all from my stdin
20:51:04 <frege> is it ONLY left? because list is a right associative?
20:51:15 <augur_> frege: no, its just a notational choice
20:51:19 <frege> gotcha
20:51:33 <augur_> frege: <- represents, roughly, a kind of relationship of membership, here. x <- xs means "x is in xs"
20:51:34 <frege> for me 'is in' is more like ->
20:51:35 <athan> Does anyone have an example of a bifunctor?
20:51:40 <roboguy_> cschneid: well, this is the library http://hackage.haskell.org/package/tagged
20:51:51 <roboguy_> cschneid: Proxy is just data Proxy a = Proxy
20:51:53 <frege> no? am I stupid?
20:51:57 <augur_> the idea being you're taking x out of xs, so the arrow points in the direction of the "pulling"
20:52:08 <frege> ahhh gotcha augur_
20:52:10 <cschneid> roboguy_: ok, to get the "a" bound there, without ever actually using it (phantom types - yes?)
20:52:16 <roboguy_> cschneid: yep!
20:52:40 <augur_> frege: or you can see it as the direction that values are being pushed into variables
20:53:00 <augur_> more generally, in do notation, x <- y looks like you're pushing the value that y computes into the variable x
20:53:10 <cschneid> roboguy_: "bound" == type system only, not any value - yes?
20:53:43 <augur_> this is a traditional CS notation for assignment, which runs in parallel with :=, whenever people want to distinguish between assignment and mere equality
20:53:47 <roboguy_> cschneid: yeah, Proxy a can't have any value other than Proxy
20:54:20 <frege> augur_: got it, I have seen its use in goLang for channels
20:54:37 <frege> augur_: is <- usage being limited to only list comprehension in haskell?
20:54:53 <roboguy_> frege: no, it's used in do notation as well
20:54:57 <augur_> frege: no, its used for do notation as well, which is related to comprehension
20:55:02 <roboguy_> haha
20:55:06 <augur_> -> is mutliple-y used as well
20:55:35 <augur_> -> at the value level is used in lambdas, cases, and view patterns
20:56:52 <frege> the value level?
20:57:06 <dwcook> I'm disappointed you can't use case and of in type signatures. Tons of lost potential for obfuscation.
20:57:29 <roboguy_> dwcook: there are type families
20:57:44 <dwcook> I meant as type variables.
20:57:51 <roboguy_> ahh
20:58:41 <roboguy_> frege: he's talking about it's use in constructing values, like lambda abstractions
20:58:45 <jrmithdobbs> case a of ... oh god
20:58:48 <roboguy_> and manipulating values
20:59:06 <augur_> frege: syntax of values vs syntax of types
20:59:23 <augur_> -> is part of the syntax of some values (lambdas, case, view patterns)
21:00:16 <frege> okay I will keep that in mind as I read the gentle guide
21:00:27 <frege> I haven't reached to lambdas, case, view patterns yet
21:00:41 <frege> I know what lambda is from other languages, but anyway
21:00:43 <augur_> you dont even know what lambdas are yet?! :o
21:00:46 <augur_> gosh
21:00:52 <augur_> in haskell a lambda is written \x -> M
21:00:52 <heatsink> If you're learning Haskell, Gentle Introduction to Haskell isn't the recommended source
21:01:04 <augur_> yeah read lyah
21:01:05 * johnw envies frege all the cool stuff he has yet to discover
21:01:06 <augur_> @where lyah
21:01:06 <lambdabot> http://www.learnyouahaskell.com/
21:01:18 <augur_> johnw: theres plenty of cool stuff to still discover!
21:01:18 <srhb> johnw: One mind wipe coming up!
21:01:21 <augur_> like category theory!
21:01:34 <johnw> augur_: yeah, that's where I'm at now, and type theory
21:01:47 <frege> johnw: hahaha :)
21:01:56 <augur_> johnw: TT is great :D
21:02:11 <johnw> it really is far more interesting that one would think at first :)
21:02:38 <augur_> johnw: have you watched pfenning's oplss 2012 lectures?
21:02:41 <frege> I have checked them out; Gentle Intro is good. I like the style; it's lean
21:02:44 <johnw> not yet, but I've downloaded them
21:03:05 <joelteon> @pl     waitAll (a:as) = wait a >> waitAll as
21:03:05 <lambdabot> waitAll = fix ((`ap` tail) . (. head) . flip ((.) . (>>) . wait))
21:03:09 <jrmithdobbs> johnw: my favorite so far was the moment "abstract nonsense" made sense as an endearing term finally
21:03:25 <jrmithdobbs> (keyword being endearing)
21:03:39 <frege> so I coded in python for a year until I reached to the point that I knew what sucks in python and how it could be improved; so basically the limits
21:03:45 <joelteon> oh it's foldr ((>>) . wait)
21:03:47 <frege> how long do you think it will take for haskell?
21:03:53 <srhb> frege: A few minutes ;)
21:04:00 <frege> no srsly
21:04:00 <Platz> oh my..
21:04:01 <johnw> frege: depends on which limits you care about :)
21:04:03 <simpson> > (-5) -- frege
21:04:03 <srhb> You'll be all "augh, why no dependent types!"
21:04:04 <lambdabot>  -5
21:04:18 <srhb> Then spend a few years working around that :P
21:04:25 <frege> johnw: mostly the expressiveness of the language
21:04:26 <simpson> > (5-) 3
21:04:27 <lambdabot>  2
21:04:41 <Platz> haskell started as a reasearch language, so if it can keep PHD's busy I don't think you'll hit the end
21:04:42 <johnw> frege: there's more expressiveness that you'll probably want
21:04:53 <frege> johnw: in haskell you mean?
21:04:56 <johnw> yes
21:05:06 <johnw> it has all kinds of awesome features that I still never need, like GADTs
21:05:09 <enthropy> > (\x@ ~~~~~~~~~~ y -> x + y) 1
21:05:09 <lambdabot>  <hint>:1:6: parse error on input `~~~~~~~~~~'
21:05:18 <johnw> just waiting for the day that I can use it
21:05:20 <frege> yeah that's what attracted me in the first place
21:05:30 <enthropy> > (\(x@ ~~ y) -> x + y) 1
21:05:31 <lambdabot>  <hint>:1:7: parse error on input `~~'
21:06:00 <enthropy> > (\(x@ ~(~ y)) -> x + y) 1
21:06:01 <lambdabot>  2
21:06:07 <johnw> frege: the thing is, the typed lambda calculus at Haskell's core is already pretty darn expressive.  Python uses syntax to express a lot of things that Haskell relegates to ordinary functions and data types
21:06:26 <enthropy> @quote tarpit
21:06:26 <lambdabot> monochrom says: yeah, get out of Turing tarpit, provable termination, only to get into Gödel tarpit
21:06:44 <frege> johnw: right!
21:06:55 <simpson> But, on the other hand, Python has with-statements. Haskell has ResourceT. One of these is easier to grok than the other.
21:07:05 <simpson> (And no, `bracket` isn't quite sufficient.)
21:07:15 <roboguy_> johnw: GADTs are pretty cool, but I haven't used them for anything practical yet
21:07:18 <jrmithdobbs> frege: just don't go looking for reactor, it is not the solution you want, and you'll be fine ;p
21:07:22 <NemesisD> is there an equivalent of nats that are positive numbers only? i find myself needing to convert an int into a positive only type
21:07:27 <frege> johnw: and python fails sometimes, it's like a disorganized shortcut cheat sheet language to me
21:07:27 <johnw> simpson: yeah, I work in ResourceT a _lot_
21:07:40 <roboguy_> NemesisD: natural numbers are positive or zero
21:07:48 <srhb> NemesisD: Replace Zero with One?
21:07:49 <simpson> NemesisD: Did you want the stuff in Data.Word?
21:07:59 <johnw> frege: to me Python feels a bit lobotimized, I just find it too boring to enjoy; but for its purpose, that's actually usually a good thing
21:08:03 <simpson> > (-1) :: Word16
21:08:04 <lambdabot>  65535
21:08:10 <Platz> all the GADT examples I've seen are example of AST's for interpreters
21:08:20 <srhb> Platz: Same.
21:08:23 <Platz> still don't understand them though
21:08:37 <roboguy_> usually GADTs work in conjunction with phantom types
21:08:38 <srhb> Or well, not quite ASTs, but relevant
21:08:44 <roboguy_> to make things more type safe
21:08:49 <frege> johnw: yeah for the purpose..
21:09:10 <NemesisD> simpson: you can still represent zero with word though
21:09:14 <qrada> hey, does anyone know why im getting a bunch of 'forever' running children, im doing: pid <- forkProcess $ exitImediately ExitSuccess... and my process keeps forking and remaining in ps... I have a print "EXIT" after getProcessStatus, which is being called.. not sure why my processes keep increasing
21:09:18 <johnw> Platz: you can use them to constrain the set of types possible via a given constructor; so rather than ranging over all Foo a, it's only possible for a given constructor to construct a Foo Int, for example
21:09:27 <augur_> roboguy_: hey speak for yourself, my GADTs arent phantomy!
21:09:31 <jrmithdobbs> Platz: they're very useful for both parsing asts and for defining dsls
21:09:33 <simpson> NemesisD: Oh, you don't want zero? Hm. What are you building?
21:09:57 <qrada> im in a thread when i do the fork/exit.. if that matters
21:10:13 <srhb> qrada: A lightweight thread?
21:10:24 <Platz> does quantification do something similiar?  Does a GADT let me inspect the type after it's constructed?
21:10:46 <qrada> nah, a forkIO thread
21:10:53 <qrada> not forkOS
21:10:57 <c_wraith> Platz: other way around.  matching a GADT constructor tells you more about its type
21:10:57 <qrada> is that the problem ? :f
21:11:06 <NemesisD> simpson: i'm probably doing something dumb: im making a web app that takes params for per-page and page number
21:11:12 <Platz> ahh, thats very nice then
21:11:14 <NemesisD> simpson: both of those numbers must be positive
21:11:26 <Platz> clearly I'll have to do some more reading up
21:11:45 <c_wraith> Platz: the concept is actually pretty simple.  Seeing how to use them effectively is what takes practice. :)
21:11:46 <srhb> qrada: are the children trying to do IO?
21:11:58 <BMeph> Episode I: The Phantom Type Menace
21:11:59 <jrmithdobbs> Platz: eg, a real-world useful thing gadts can do is construct DSL-like apis that use function composition on data constructors to build up a query and then a transform/fold to convert to the necessary form for the protocol (json-rpc,udp,etc)
21:12:04 <qrada> ya... say, executeFile() etc
21:12:07 <NemesisD> simpson: i think i may be able to handle this another way at the parsing layer
21:12:08 <qrada> and exitImmediately
21:12:21 <zRecursive> e
21:12:27 <jrmithdobbs> i've not seen it done much though
21:12:44 <srhb> qrada: executeFile should be OK. Meh, no idea really. Forking processes in threads has always been a complete mystery to me, nothing behaves in a way I can understand :P
21:12:50 <Platz> jrmithdobbs: that sounds pretty awesome.  hope to get there one day
21:12:57 <johnw> c_wraith: know of any good articles that give examples besides ASTs?
21:13:17 <Platz> i need to write more code; too many articles not enough time in the dirt
21:13:22 <c_wraith> johnw: nope. Those are the only examples I ever see
21:13:30 <qrada> srhb cool thanks.. this means i prolly need to do a bit more research.. i bet it has to do with forkIO
21:13:36 <johnw> I see an opportunity here for an aspiring blog author :)
21:13:48 <qrada> ill try forkOS etc see what's going on.. ya i bet that's it..
21:14:45 <johnw> qrada: if you're using forkProcess, don't you need to use getAnyProcessStatus?
21:14:45 <c_wraith> qrada: Are you sure you know what forkOS does?  It doesn't create a new system process - it just ensures that any native calls done by the new thread all come from the same native thread
21:15:01 <roboguy_> it's always seemed like GADTs have a lot of potential, but like you guys, I haven't seen them used all that much
21:15:10 <qrada> ya johnw I am.. im doing getProcessStatus with the returned pid
21:15:15 <Platz> so much haskell blog attrittion; there must be replacements!
21:15:45 <c_wraith> well, GADTs used to cause a bunch of spurious non-exhaustive pattern errors
21:15:47 <qrada> c_wraith: ya c_wraith im looking it up now.. im just trying to 'fork/exec/exit' in a thread, so i may be on the wrong track completely
21:15:50 <johnw> qrada: curious
21:16:01 <johnw> I've never used forkProcess
21:16:12 <c_wraith> And GHC's handling of GADTs is sometimes painful in other ways
21:16:22 <roboguy_> c_wraith: how so?
21:16:23 <c_wraith> It makes using them feel a little bit awkward
21:16:39 <c_wraith> roboguy_: errors about making GHC's brain explode, among other things
21:16:52 <jrmithdobbs> i've seen that one =/
21:17:00 <roboguy_> I've heard of it, but I haven't seen it
21:17:08 <roboguy_> it hasn't been fixed?
21:17:09 <c_wraith> roboguy_: it feels like GHC could use one more pass cleaning up the errors related to GADTs to make them friendlier to use
21:17:26 <c_wraith> roboguy_: the one I'm thinking of can't be fixed.  It's an inherent issue with GADTs
21:18:22 <c_wraith> if you try to use a GADT constructor in an irrefutable pattern match, GHC will tell you its brain exploded
21:18:33 <c_wraith> And there are good theoretical reasons for that
21:18:40 <c_wraith> But the messaging isn't so good. :)
21:19:28 <jrmithdobbs> also, don't act like parsing ASTs isn't a useful case, more things can be solved this way, or a slight variation, than it would seem at first glance
21:20:52 <c_wraith> uu-parsinglib uses GADTs, I know.
21:21:06 <jrmithdobbs> c_wraith: not you
21:21:09 <jrmithdobbs> heh
21:27:44 <roboguy_> wow, the void package is surprisingly popular on hackage
21:28:00 <c_wraith> people like uninhabited types!
21:28:12 <c_wraith> (nearly-uninhabited)
21:28:15 <roboguy_> nearly twice as popular as lens
21:28:45 <c_wraith> lens isn't something libraries need to depend on, though
21:28:57 <roboguy_> true
21:28:57 <c_wraith> In fact, it's explicitly set up so you can be compatible without depending on it
21:29:11 <c_wraith> Whereas void is something libraries will want to depend on
21:29:14 <roboguy_> still, I'm surprised void is the 10th most popular package on hackage
21:29:43 <johnw> roboguy_: oh, that's nothing
21:30:39 <roboguy_> no?
21:30:58 <c_wraith> I suspect that was an attempt at a pun
21:31:00 <johnw> ;)
21:31:14 <jrmithdobbs> c_wraith: unless you need Prism to describe things, anyways :(
21:31:23 <jrmithdobbs> (aeson)
21:31:47 <roboguy_> ahhh, haha
21:33:02 <roboguy_> I was actually researching void yesterday. I'm still not sure I fully grasp the utility. I understand that it can mark certain code paths as being inaccessible but what's a good example of where that would be used over just eliminating that path altogether?
21:33:26 <johnw> roboguy_: you can eliminate possiblities in a type
21:33:35 <johnw> for example, in a Conduit you specify the input and output types
21:33:45 <johnw> so, a Conduit Void output is clearly a conduit that can only produce values, not consume them
21:33:55 <johnw> any attempt to use "await" in such a conduit to consume a value will be a type error
21:34:16 <jrmithdobbs> i want to depend on void just to import Void (absurd)
21:36:19 <roboguy_> hmm, that makes sense
21:37:50 <roboguy_> johnw: what if I use vacuous on the result, will it still be a type error?
21:38:16 <lispy> Seeing parsec so high up the list makes me sad
21:38:26 <jrmithdobbs> why?
21:38:36 <johnw> roboguy_: I don't see why that would help
21:38:49 <lispy> jrmithdobbs: let me see if I wrote down my reasons :)
21:38:50 <roboguy_> well, I don't know much about conduit which is probably part of the problem here
21:38:54 <johnw> you can make an 'a' anyway
21:38:56 <johnw> can't
21:39:30 <jrmithdobbs> lispy: it's a pretty good parsing library no matter the complaints you have about it it's good enough for most cases
21:39:41 <jrmithdobbs> lispy: don't understand why that'd make you sad =/
21:39:56 <lispy> jrmithdobbs: http://www.haskell.org/pipermail/haskell-cafe/2013-August/109557.html
21:40:21 <lispy> jrmithdobbs: It's actually not that great. happy + alex is a lot better.
21:40:29 <lispy> And quite quick to use
21:41:01 <lispy> jrmithdobbs: I keep this example around: https://github.com/dagit/happy-plus-alex/
21:42:25 <lispy> I'm a firm believer in the power of domain specific languages. Parsec embeds in Haskell in such a way that it's really hard to reason about it.
21:43:04 <lispy> The applicative parser combinator libraries are easier to reason about but they could provide ways to actually analyze the grammars.
21:43:20 <lispy> They are reason to reason about because they don't have the full generality of monads
21:43:55 <lispy> (yes, applicatives are more general in the mathematical sense, but monads are more general in a computational sense)
21:44:46 <lispy> as I said in the message I linked, there is a time/place for monadic parsers and parsec is mature.
21:45:09 <lispy> I just wish more folks would try for happy+alex before reaching for parsec
21:45:24 <lispy> Figuring out where to put `try` is a pain :(
21:45:44 <simpson> I don't like Happy because I don't like LALRs, but I also don't like recursive descent.
21:45:52 <ajoox> This is surley the wrong chan, Im just wondering, is there a net-sec chan on frenode?
21:45:52 <simpson> Mostly Happy just makes me feel like I'm in bison-land. :c
21:46:17 <jrmithdobbs> ya reading this example was making me think bison as well
21:46:19 <lispy> simpson: you might prefer peggy?
21:47:03 <roboguy_> so why is it that applicative parsers don't provide a way to analyze grammars?
21:47:08 <simpson> lispy: Yeah, it's closer to what I prefer.
21:47:14 <zRecursive> lispy: what is peggy ?
21:47:31 <lispy> roboguy_: I think it's just a common ommision, I've been told that on a theoretical level it shouldn't be too hard.
21:47:54 <lispy> zRecursive: http://tanakh.github.io/Peggy/
21:48:08 <roboguy_> also what do they mean by "analyze grammars"?
21:48:10 <lispy> zRecursive: it's PEG instead of LALR
21:48:36 <lispy> roboguy_: are you familiar with shift/reduce and shift/shift conflicts in LALR grammars? That's the result of analyzing the rules.
21:48:55 <roboguy_> lispy: it's been a few years, so I don't remember too well
21:49:24 <osa1> do we have a replace function for ByteStrings?
21:49:29 <lispy> roboguy_: reducing means you're at the end of a production and shift means you continue the parse
21:49:43 <roboguy_> alrigh
21:49:45 <roboguy_> t
21:49:45 <maurer> So, I have a monad that for various reasons has two layers of ErrorT
21:49:56 <lispy> roboguy_: The point is, these issues between continuing and keeping going can be detected statically.
21:50:04 <maurer> I can throw from either layer just fine via throwError and lift . throwError
21:50:05 <roboguy_> ahh
21:50:12 <lispy> roboguy_: But with something like parsec you have to really think hard about your grammar or you test it.
21:50:13 <maurer> but I can't seem to figure out how to catch from the inner layer
21:50:24 <roboguy_> hmm
21:51:01 <lispy> roboguy_: The shift/reduce equivalent in parsec is forgetting to put try where you should have it
21:51:18 <roboguy_> ah, I see
21:52:49 <lispy> roboguy_: and I mispoke. It's reduce/reduce and shift/reduce that you have to watchout for
21:53:26 <lispy> happy also supports GLR but it seemed bitrotted when I looked at it
21:53:37 <jrmithdobbs> lispy: what about attoparsec? how do you feel about it's incremental monandic model? you lose the problem of forgetting try and gain the problem of being unable not to use try
21:54:05 <lispy> GLR is a generalization that can handle local ambiguity by efficiently representing all the possibilities and letting you collapse them later.
21:54:48 <lispy> jrmithdobbs: Can you parse something that needs backtracking with it?
21:55:02 <lispy> It's been awhile since I used it.
21:55:20 <lispy> I seem to recall it works well for things that don't need lookahead.
21:55:39 <jrmithdobbs> lispy: with Alternative you can emulate though not the most efficient ever
21:55:44 <roboguy_> happy doesn't use an EDSL, right?
21:55:56 <lispy> roboguy_: it's a dsl, but not an edsl
21:56:08 <roboguy_> yeah that's what I thought. that's unfortunate
21:56:08 <maurer> Anyone know how to catch the inner error i fyou have two ErrorTs stacked on one another?
21:56:24 <jrmithdobbs> lispy: but ya, that's my general impression is backtracking is hard but doable if you squint/think
21:56:25 <lispy> roboguy_: I was cleaning it up for a while and I wanted to do like peggy does and expose it through TH so that you'd have the option of embedding your grammar in a .hs file
21:57:01 <lispy> roboguy_: It's not so bad. if you're using cabal (and why wouldn't you?) then you just throw stuff in a .y file and the rest is taken care of for you.
21:58:13 <lispy> but, I sort of lost my momentum on happy.
21:58:25 <pavonia> maurer: By catch you mean catching IO exceptions?
21:58:28 <lispy> I bit off more than I could chew in one part of the clean up.
21:58:49 <maurer> pavonia: No, I mean ErrorT values
21:59:23 <maurer> pavonia: I am using a library that defines a monad which is an instance of MonadError, but I am combining that with my own monad which has its own ErrorT value
21:59:45 <maurer> pavonia: I can catch the MonadError value from their monad fine, but not from my inner one
21:59:56 <maurer> (though I can throw it fine by doing lift $ throwError foo)
22:00:23 <pavonia> How do you catch the error?
22:01:02 <maurer> Normally I'd do it via "catchError"
22:01:08 <johnw> is this a true statement: all Haskell functions are referentially transparent with respect to sub-expressions that do not involve lazy I/O
22:01:37 <maurer> :t catchError
22:01:38 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
22:01:42 <maurer> Yeah, that
22:01:52 <lispy> johnw: I read that one post on SO about referential transparency and I've lost all sense of it :)
22:01:59 <johnw> haha
22:02:03 <johnw> http://stackoverflow.com/questions/210835/what-is-referential-transparency
22:02:06 <johnw> i read it on a monthly basis, it seems
22:02:06 <maurer> problem is, I've got something the equivalent of ErrorT Foo (ErrorT Bar m)
22:02:14 <maurer> and I need to catch Bars, and can only figure out how to catch Foo
22:02:26 <lispy> johnw: yeah, that's the one
22:02:32 <jrmithdobbs> lispy: looking at the formal definitions it's a lalr but it does use Alternative to simulate backtracking so i dunno what to call it
22:03:03 <lispy> jrmithdobbs: sorry, which?
22:03:09 <jrmithdobbs> lispy: attoparsec
22:03:46 <lispy> jrmithdobbs: ah, so someone should be able to make a rule analyzer---assuming you can somehow reify your productions.
22:04:10 <lispy> You could probably do that if they used a free monad (ha! I don't normally advocate those)
22:04:47 <johnw> I like free monads, because they cost so little to use
22:05:23 <lispy> I like puns because...I got nothing.
22:06:15 <lispy> I should be studying
22:14:55 <pavonia> maurer: I've just tried, you can catch it the same way for either Error type
22:15:39 <jrmithdobbs> lispy: i know that generated lexxers are almost always better performing but how many more arbitrary syntaxes do i need to learn, really? I think that's why things not like yacc/bison are more popular than anything like them ;p
22:16:24 <pavonia> maurer: No wait, I messed it up :p
22:17:48 <lispy> jrmithdobbs: I'd rather learn some syntax than debug a parser :)
22:18:20 <jrmithdobbs> lispy: i'd rather redisgn my project to not have to parse crap
22:18:21 <jrmithdobbs> heh
22:18:47 <startling> free monads are so nice.
22:18:57 <startling> once you stop needing to write instances, you never want to do it again.
22:19:17 <shachaf> Well, you still need to write the equivalent.
22:19:48 <startling> shachaf: what do you mean?
22:19:52 <startling> the "base functor"?
22:20:02 <zRecursive> What does "free" mean in "free monad" ?
22:20:20 <jrmithdobbs> unfortunately it's not a reference to beer, if that's what you were hoping
22:20:24 <jxv> free as in speech?
22:20:28 <shachaf> Or the interpreter.
22:20:31 <Adeon> not in prison
22:20:44 <startling> zRecursive, "free objects" are math things
22:21:11 <zRecursive> startling: how about in haskell ?
22:21:33 <jrmithdobbs> zRecursive: most haskell things are math things
22:21:48 <zRecursive> sure
22:22:06 <dmj`> why do we need pattern synonyms
22:22:09 <startling> zRecursive: I'm not sure how to explain it.
22:22:22 <zRecursive> How does haskell implement free objects of math ?
22:22:48 <startling> zRecursive, Free SomeFunctor a is a Monad.
22:23:26 <zRecursive> then free monad is "subclass" of Monad ?
22:23:29 <kristof> There are also free monoids.
22:23:51 <startling> zRecursive: no. it's a type.
22:24:04 <startling> zRecursive: data Free f a = Pure a | Free (f (Free a))
22:24:05 <kristof> zRecursive: A free monad is the least amount of structure that you need to add to a functor to make it a monad. There are more rigorous mathematical definitions, but that's the gist.
22:24:19 <erisco> zRecursive, "Free f a" is an ADT that has a Monad instance. However, it requires that 'f' is a Functor
22:24:22 <startling> zRecursive: there's an instance Functor f => Monad (Free f)
22:24:27 <shachaf> I'm not sure it's a helpful gist unless you already know what it means.
22:24:51 <kristof> The point of gists is that they're sufficient for rudimentary understanding.
22:24:57 <erisco> zRecursive, so it is roughly said that Free makes any Functor a Monad
22:25:12 <kristof> "Got a functor? Here's a monad... for free!"
22:25:30 <jrmithdobbs> still rather have the beer.
22:25:41 <startling> zRecursive: so you can write e.g. "data Four a = Four a a a a" and a Functor instance for it and then "Free Four a" is a Quadtree and comes with a Monad instance.
22:25:42 <erisco> zRecursive, so it is really just a cute way of wording what is going on
22:25:54 <erisco> after all, you could also say... have a type 'a'? here is a Monad!
22:26:44 <zRecursive> need time to think it, thx
22:27:37 <erisco> the mathy wording of it is arcane, but that is just my understanding
22:28:05 <kristof> I don't think arcane is quite the right way to describe it.
22:28:10 <shachaf> I'd be inclined to ask questions like "what does it mean to 'add structure' to a functor?" and "what does it mean for it to be 'least', especially given that it's usually infinite?" and "what is the functor is already a monad? why do we need to add anything in that case?".
22:28:40 <kristof> shachaf: Then I point them in the direction of SO and various blog posts on the subject.
22:29:42 <erisco> kristof, I was saying that from my perspective the mathy wording is arcane. I am sure it is not for the more inclined :)
22:36:15 * hackagebot cab 0.2.7 - A maintenance command of Haskell cabal packages  http://hackage.haskell.org/package/cab-0.2.7 (KazuYamamoto)
22:43:57 <jle`> am i the only one that feels really weird about everything in this article? http://www.haskell.org/haskellwiki/Existential_type
22:44:09 <jle`> the entire usage feels so...wrong
22:45:21 <notdan> hm
22:45:33 <notdan> idk, you'll get used to it maybe
22:49:14 <erisco> jle`, this emulates what an "interface" is in most oop languages
22:49:23 <erisco> ie it has a runtime component
22:49:29 <jle`> but is it a 'good thing'?
22:49:59 <erisco> I do not know. I have not played with it enough to know whether it is actually necessary
22:50:39 <erisco> for instance, you can also just say   data Shape = Circle | Rectangle | Square  for instance
22:51:01 <erisco> the need for separate data types is unclear to me
22:52:26 <ski> erisco : but that's closed
22:53:12 <ski> (you don't really need separate data types -- you just need them if you're using a type class at the same time)
22:53:18 <erisco> ski, are you suggesting that library users may wish to involve their own types?
22:53:36 <shachaf> The expression problem is probably the important distinction to be made.
22:53:37 <ski> e.g. yes
22:53:40 <erisco> ie someone decides they need a rhombus?
22:53:45 <ski> yes
22:54:33 <ski> anyway, instead of using that `class Shape_ a where perimeter :: a -> Double; area :: a -> Double' together with
22:54:36 <ski>   data Shape = forall a. Shape_ a => Shape a
22:54:43 <ski> you could just as well use directly
22:54:49 <joe9> What is the recommended maximum line size in a haskell program? I am asking from a style perspective. I am used to using 70. but, I have seen stylish-haskell using 80.
22:54:53 <joe9> Just wanted to check.
22:55:05 <ski>   data Shape = forall a. Shape {this :: a,perimeter :: a -> Double,area :: a -> Double}
22:55:54 <ski> however, in this case, since the "methods" only take a single argument of type `a', no other argument involving `a', nor the result, this can be simplified (in this case) to just
22:56:14 <ski>   data Shape = Shape {perimeter :: Double,area :: Double}
22:56:25 <shachaf> ski: An advantage of the existential: If I add more methods to Shape_, each particular Shape doesn't get any bigger, since the "vtable" is shared.
22:56:43 <ski> in either of these cases do you not need any `Circle',`Rectangle',`Square' data types
22:56:55 <shachaf> Of course, you don't need a type class for that -- you can just write data Shape = forall a. Shape a (a -> Double, a -> Double, a -> String, a -> Bool, ...) and then share the "vtable" yourself.
22:57:09 <relrod> I am attempting to use Shelly to do some IO action every time a long-running command outputs a line. I believe runFoldLines gets me somewhat close, as it does line-by-line processing instead of shoving everything into memory. But I'm unable to make this typecheck. http://lpaste.net/594728940430426112
22:57:17 <shachaf> But I don't think I know a nice way of getting that effect without the existential.
22:57:36 <ski> shachaf : how about `data Shape = forall a. Shape {this :: a,dict :: ShapeDict a}' ?
22:57:50 <shachaf> Sure, that was my second suggestion.
22:57:51 <ski> *nod*, what you said
22:57:55 <shachaf> (Using a tuple instead of -- yes.)
22:58:45 <shachaf> But it would be nice to know of an efficient solution that doesn't use existentials.
22:59:04 <shachaf> Since data Shape = Shape Double Double String Bool ... is a nicer data type in the first place.
22:59:28 <ski> erisco,jle` : anyway, you might be interested in taking a look at "On Understanding Data Abstraction, Revisited" by William R. Cook in 2009-10 at <http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf> -- it's about how OO is related to procedural abstract, and how it differs from abstract data types
22:59:35 <erisco> what is wrong with  foo :: (Shape_ s) => Shape s -> ...
22:59:37 <ski> (shachaf : not sure whether you've seen that one)
22:59:53 <ski> erisco : there's not necessarily anything wrong with it
23:00:03 <ski> @where existential-antipattern
23:00:03 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
23:00:11 <ski> see e.g. that ^
23:00:30 <athan> You guys put the Funk in Functor
23:00:31 <erisco> ski, it seems that this constraint is ultimately all that is removed
23:00:34 <erisco> or hidden, rather
23:00:39 <ski> there's not much point with going overkill with existentials, in some misguided attempt to emulate OO
23:00:39 <athan> B)
23:00:48 <ski> however, in some cases, you really want existentials
23:01:14 <ski> erisco : existentials are all about hiding and abstract data types, yes
23:01:26 <ski> anyway, i gotta go atm
23:04:15 <erisco> ugh that article reminded of one of the most annoying things ever
23:04:24 <erisco> toWidget :: Windows -> Widget
23:04:37 <erisco> yeah have fun when you need Widget -> Window
23:05:16 <erisco> this is precisely why the base class of "widgets" or "elements" or whatever in most GUI libraries have a zillion and one methods and properties
23:05:42 <erisco> and is one reason I hate oop
23:08:18 <Platz> erisco: does that mean you don't like the opinion in the article?
23:08:32 <erisco> I am referring to http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
23:08:39 <Platz> yeah
23:09:15 <erisco> well he is pointing out that the existential type is not necessary by giving an alternative
23:09:42 <Platz> i was trying to understand what you mean, did you like the alternative better?
23:09:48 <erisco> and scorns the idea of using an advanced feature such as existential types when functions alone suffice
23:10:35 <jrmithdobbs> that article boils down to: KISS
23:10:38 <erisco> the issue I pointed out is consistent across both solutions
23:10:41 <jrmithdobbs> noone's really going to argue with that.
23:11:44 <erisco> Platz, so to answer your question, I like neither better
23:11:51 <erisco> for the application of GUIs anyways
23:12:25 <Platz> gotcha
23:12:52 <erisco> both are emulating the same oop concept
23:15:38 <erisco> Platz, I would keep the Widget class but just remove the existential type features, so you would have to specify the constraint manually
23:16:15 <erisco> this does not answer how you could have a data structure of many Widget instances, however
23:17:18 <erisco> so that said, I think all the interesting work that needs to be done is how you sensibly manage the Widget -> Window conversion
23:19:54 <erisco> actually a good example is a physics engine doing collision detection, Platz
23:20:38 <erisco> presumably you have some interface Body which gives the engine the information it needs to perform the hit testing and collision resolution
23:21:18 <erisco> and presumably you want to perform particular actions when particular instances of Body collide
23:21:43 <erisco> however, that information is lost
23:22:13 <erisco> so then you have to figure out how to safely down cast the Body objects and invoke the correct code
23:22:46 <Platz> you're referencing the "rendering objects in a raytracer" paragraph from the haskellwiki article i take it
23:23:00 <erisco> no I am referencing my own experience with games programming
23:23:24 <Platz> ahh, even better ;)
23:23:30 <erisco> perhaps not :P
23:23:38 <Platz> but here http://www.haskell.org/haskellwiki/Existential_type#Expanded_example_-_rendering_objects_in_a_raytracer
23:24:20 <erisco> there is no simple solution for the collision example though
23:25:59 <erisco> one idea is to use multiple dispatch, but this either requires some amount of runtime reflection or it requires another gross thing
23:26:15 <lispy> regarding that wiki link. In my raytracer, I use records instead of classes.
23:26:27 <lispy> I found that to be a lot easier to work with.
23:26:31 <lispy> No fancy extensions either.
23:27:34 <lispy> data Shape a = Shape { hit :: Ray a -> a -> a -> a -> Maybe (HitRecord a) }
23:27:48 <Platz> erisco: is the "codata" style relevant? http://www.reddit.com/r/haskell/comments/1quhrl/from_object_oriented_programming_to_functional/cdgplga
23:27:56 <erisco> and again this is why base classes tend to accumulate oodles of methods
23:28:29 <lispy> and then when I create a triangle, I do something like mkTriangle ... = Shape { hit = .... }
23:28:51 <erisco> Platz, I do not know
23:29:24 <lispy> I suppose if I had enough triangle I might want more sharing between their hit functions
23:29:57 <lispy> (actually, they might get shared already, never really bothered to think about it)
23:30:17 <erisco> Platz, the problem with the physics is that you need to act on two different types
23:30:50 <Platz> hence the multiple dipatch
23:31:17 <erisco> let X, Y be instances of Body, then forall X, Y there exists some function f(X x, Y y) that reacts to the collision of the two bodies
23:31:29 <erisco> I have seen no desirable ways to accomplish this
23:32:27 <Platz> i don't know either, this stuff is still beyond me.  still just trying to get comfortable with the basics.
23:33:04 <Platz> in langs it seems the knowledge to be a library designer is several orders harder than kludging together an app
23:37:23 <erisco> lispy, the record should just contain the pointer to the hit function, but each record will contain this pointer
23:38:02 <erisco> which is unlike the existential version in which each record has one pointer that points to a common table
23:39:33 <erisco> lispy, in your version, you can do things like swap out methods at runtime. ie, you can take a triangle object and change its hit function independently of other triangle objects
23:39:57 <erisco> lispy, which is something you can do in a lot of dynamic languages such as JavaScript, but not in a language like C++
23:41:20 <erisco> and you could not do that if it used existential types
23:41:22 <individual> how do I compile GHC with integer-simple? I downloaded the 7.6.3 source package, set INTEGER_LIBRARY=integer-simple in mk/build.mk and git cloned integer-simple into libraries/ but configure says "ghc.mk:672: libraries/integer-simple/ghc.mk: No such file or directory"
23:42:14 <shachaf> I'm not sure you should be git-cloning it yourself.
23:42:25 <erisco> g'night
23:42:42 <shachaf> Anyway, I think ghc.mk files are created by boot
23:42:58 <individual> so the source package doesn't include integer-simple for some reason?
23:43:05 <shachaf> I don't know how it goes with package releases.
23:43:45 <individual> I will attempt building from git then
23:55:52 <individual> I checked out the 7.6.3 tag, ran sync-all get, perl boot, configure (with a prefix flag), make and I get lots of errors like libraries/hpc/ghc.mk:3: libraries/hpc/dist-boot/package-data.mk: No such file or directory
23:56:26 <individual> the same for cabal, binary, bin-package-db, hoopl, utils/haddock
23:56:46 <shachaf> Are all the submodules also checkout out at that tag?
23:57:02 <shachaf> Maybe you need to sync-all checkout or something.
23:57:09 <shachaf> (I don't really remember how this goes.)
23:57:48 <individual> ok I found another article on the trac wiki, I'll try again
23:58:57 <individual> I started from 'building' instead of 'getting the sources'
