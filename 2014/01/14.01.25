00:00:14 <shachaf> You mean individual projects?
00:00:17 <bmuk> yes
00:00:23 <L8D> https://code.google.com/soc/
00:00:24 <shachaf> You can probably find the list of suggestions and projects from last year (and previous years).
00:01:11 <shachaf> https://ghc.haskell.org/trac/summer-of-code/
00:01:14 <shachaf> http://www.google-melange.com/gsoc/org/google/gsoc2013/haskell
00:01:29 <bmuk> shachaf++
00:01:39 <shachaf> http://www.reddit.com/r/haskell_proposals
00:02:18 <shachaf> In addition to running the Summer of Code, Google has a useful website that lets you find these sorts of resources. :-)
00:02:51 <bmuk> lol. I apologize :)
00:08:59 * hackagebot x509-util 1.5.0 - Utility for X509 certificate and chain  http://hackage.haskell.org/package/x509-util-1.5.0 (VincentHanquez)
00:08:59 * hackagebot plot 0.2.2 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.2.2 (VivianMcPhail)
00:19:00 <popl> Is it uncommon to have cabal (and other packages) installed inside of $HOME?
00:19:52 <eazar001> popl: no it's not uncommon, that is the default
00:19:56 <popl> excellent
00:19:59 <popl> thank you eazar001
00:20:03 <eazar001> np
00:20:59 <qrada> hey, im trying to load a bunch of modules in ghci.. but im running into scope issues: :l Id Misc Applicative .. etc.. I can only use what's in the first file listed without having to namespace it.. ie I can use "creds" from Id, but I have to do: Applicative.<$$>
00:21:01 <markovirc> Hello qrada
00:21:03 <qrada> any idea
00:23:06 <ChongLi> try doing :m +Control.Applicative
00:23:11 <ChongLi> :m +Misc
00:23:13 <ChongLi> etc.
00:24:01 <qrada> well, it's "my applicative" .. but ya none of those are loading properly.. I have them namespaced like: module HMisc.Id (...) where ... module HMisc.Applicative (...) where etc
00:24:20 <qrada> ive tried just module Id, module ... that doesn't fix it.
00:24:41 <qrada> but basically im just trying to load a bunch of .hs's in my current directory and have them in the current scope
00:25:18 <shachaf> Instead of using :l, you may just be able to import them.
00:25:31 <joelteon> :l
00:25:51 <danil> Use :m + Module1 Module2 ..., or just import them -- I'm not sure why :l behaves this way, but it only puts the first one in scope
00:26:28 <qrada> ya.. that's what's happening.. ok so I have to figure out how to import them, maybe it's how im defining them that's breaking import: module HMisc.Name
00:26:31 <qrada> thanks folks
00:27:14 <shachaf> HMisc.Name should probably go in the file Name.hs in the directory HMisc/
00:27:18 <qrada> ya
00:32:51 <Morehous1J09> so I finally figured out what was breaking a script
00:33:03 <Morehous1J09> I wasn't using the FlexibleContexts pragma
00:33:18 <Morehous1J09> is there a way / recommended way to enable extensions throughout an entire program
00:33:30 <Morehous1J09> I'm building a few scripts - could I pass this to the ghc compiler somehow?
00:33:38 <Morehous1J09> {-# LANGUAGE FlexibleContexts #-}
00:36:34 <shachaf> -X
00:37:35 <Twey> Morehous1J09: You can tell the compiler -XFlexibleContexts, or you can set default-extensions: FlexibleContexts in your .cabal file
00:38:05 <Twey> … but you might not want to do that one on a whole-program basis
00:39:10 <Kaidelong> why are flexible contexts not the default though?
00:39:13 <Morehous1J09> Twey: cool - yeah I think its probably best on a per file basis then?
00:40:00 <eazar001> Morehous1J09: good stuff -- http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/flag-reference.html
00:40:14 <Morehous1J09> What exactly are flexible contexts? Is this just the ability to check the type class and see if it has an attribute?
00:40:51 <Kaidelong> the ability to put type constructors in the context area, as opposed to just type variables
00:41:22 <Kaidelong> it's hard to see where it would actually be useful but I don't see why it should be forbidden either
00:41:40 <qrada> i cannot load modules using :m or import from ghci, to save my life.. here's what I have: HMisc/Id{hs,hi,o} HMisc/Applicative{hs,hi,o} HMisc/Cat{hs,hi,o} ... in my shell, i am one level above HMisc.. so pwd = ~/ with ~/HMisc inside.. when I do: import HMisc.Id, or :m + HMisc.Id ... nothing gets loaded. Im running ghci with -v and I don't see it doing much of anything. The error I get with :m + is: Could not find module 'HMisc.Cat'
00:41:57 <qrada> sorry to keep asking about this but i have no clue why these modules arent loading from ghci
00:42:01 <qrada> they load from other .hs code
00:42:22 <qrada> inside the cat module: module Cat (...) where
00:42:52 <Kaidelong> essentially if you have an instance for A (B C) you can make your context A (B t) rather than writing a new function for every t other than C
00:43:13 <eazar001> or sorry just change that 7.2.1 to 7.6.3 and that's more up to date
00:43:24 <qrada> sorry for randomly using HMisc.Cat and HMisc.Id in my question eh.. tired ;f
00:43:32 <Kaidelong> if you need a B of t to be in typeclass A but you don't care about the type t itself
00:46:50 <Morehous1J09> Kaidelong: that makes sense - its going to take me some time to wrap my head around but it makes sense
00:47:34 <Kaidelong> with the restriction all contexts have to be in the form of a single class name and a single type variable per entry in the context
00:47:47 <Kaidelong> so you have (A a, B b, C c .. )
00:48:27 <Kaidelong> which most of the time is fine because more of the typeclasses you work with have all the derived instances you need
00:48:32 <Kaidelong> most*
00:48:54 <Morehous1J09> so basically it checks that A is a subclass of B
00:49:23 <Morehous1J09> when you call the function - the context manager checks that. STarting to make more sense
00:49:24 <Kaidelong> that the type built out of (B t) is an instance of typeclass A
00:49:39 <Morehous1J09> ahh ... that is making sense
00:49:47 <Kaidelong> subclassing doesn't really exist in haskell
00:50:40 <Kaidelong> the classes are a different kind of class, but some classes can be subsets of other classes, usually you talk about that as "class A implies class B" rather than "class A is a subclass of class B"
00:51:43 <Kaidelong> IE Enum implies Ord implies Eq, Monad implies Applicative implies Functor
00:52:59 <shachaf> "Enum implies Ord"?
00:53:51 <ion> instance Ord Foo where compare = compare `on` fromEnum
00:53:59 * hackagebot hspec-expectations-lens 0.2.1.0 - Hspec expectations for the lens stuff  http://hackage.haskell.org/package/hspec-expectations-lens-0.2.1.0 (MatveyAksenov)
00:54:04 <ion> is probably what he meant
00:54:27 <Morehous1J09> Kaidelong: this is starting to make perfect sense
00:55:29 <shachaf> > map fromEnum [1.0,1.1,1.5,1.9,2.0]
00:55:31 <lambdabot>  [1,1,1,1,2]
00:55:48 <shachaf> Relying on Enum to be very well-behaved about anything is risky.
01:23:34 <osa1> I'm loading two files in GHCi with :load but I can't call one of the module's functions without using qualified names like ModuleName.fun, why is this?
01:23:55 <osa1> autocomplete also doesn't work in this case, for example ModuleName.<TAB> doesn't show anythimng
01:23:57 <osa1> anything*
01:32:01 <aleksejs_> could anyone help me with one newbie problem? I'm trying to install mysql-simple package, but cabal shows error Missing C library: pcre. What should I do?
01:36:43 <narendraj9> why can't I have something other than an IO action inside a bigger IO action? I mean something like a binding name = "hello".
01:37:09 <shachaf> I do not understand the question.
01:37:37 <narendraj9> I tried to define a variable with name = "myname" inside main and there was an error.
01:37:40 <narendraj9> why so?
01:37:49 <shachaf> What does that mean?
01:37:54 <narendraj9> inside let bindings only, I am able to do this.
01:38:05 <shachaf> "there was an error" doesn't help anyone help you.
01:38:20 <shachaf> When you ask a question, you should say what you did, what you expected would happen, and what actually happened.
01:38:32 <skypers> hi
01:38:34 <markovirc> Hello skypers
01:38:40 <narendraj9> __parse error on input '='
01:38:50 <eazar001> aleksejs_: have you tried installing the package? from your repo?
01:39:04 * hackagebot pcre-utils 0.1.0.2 - Perl-like substitute and split for PCRE regexps.  http://hackage.haskell.org/package/pcre-utils-0.1.0.2 (SimonMarechal)
01:39:06 * hackagebot shellmate 0.1 - Simple interface for shell scripting in Haskell.  http://hackage.haskell.org/package/shellmate-0.1 (AntonEkblad)
01:39:35 <narendraj9> this is what I get when I try to assign a variable to a value inside main. I am still learning haskell. So I was just asking why has this behaviour been implemented in the language?
01:40:00 <skypers> narendraj9: there’s no assignments in haskell
01:40:18 <skypers> you can bind values to aliases if you want
01:40:20 <narendraj9> I mean binding a value to a name
01:40:26 <skypers> but there’re no such variables
01:40:28 <skypers> ok
01:40:46 <skypers> then
01:41:02 <narendraj9> why is it not allowed inside an IO action?
01:41:12 <aleksejs_> I've installed libpcre3 and libpcre3-dev, but now it shows another error:
01:41:12 <skypers> if you want to do that, you have to use the let keyword (if you’re in a monad, and main is in the IO monad, so you can)
01:41:19 <shachaf> OK, then you have a syntax error. It has nothing to do with IO actions.
01:41:26 <skypers> narendraj9: check this
01:41:46 <shachaf> I still don't know what "assign a variable to a value inside main" means, so I still can't help you.
01:41:48 <skypers> > do { let a = "Hello, world!"; putStrLn a }
01:41:49 <lambdabot>  <hint>:1:42: parse error on input `}'
01:42:00 <skypers> hihi
01:42:01 <narendraj9> I know I can do this with the let bindings but why is ths a feature. that's what I am asking.
01:42:01 <aleksejs_> it shows that program mysql_config is missing
01:42:17 <eazar001> program?
01:42:18 <aleksejs_> Configuring mysql-0.1.1.6...
01:42:18 <aleksejs_> setup: The program mysql_config is required but it could not be found
01:42:22 <eazar001> oh
01:42:25 <eazar001> hmmm
01:42:26 <shachaf> When I say that you should say what you did, I mean that you should show your actual code, and actual error, and ideally the actual output you expected.
01:42:35 <eazar001> lemme think
01:42:58 <skypers> narendraj9: well, writing a = "foo" is not allowed, that’s it
01:43:06 <skypers> you have either to use let or where
01:43:20 <skypers> > putStrLn a where a = "foo"
01:43:21 <lambdabot>  <hint>:1:12: parse error on input `where'
01:43:27 <skypers> is lambdabot stupid?
01:43:34 <eazar001> aleksejs_: i'm just stabbing in the dark here, but it seems like you need to install mysql
01:43:42 <eazar001> but i'm guessing you already did
01:44:00 <aleksejs_> maybe some additional pachage for mysql?
01:44:02 <skypers> > let name = "Hello, world!" in putStrLn name
01:44:03 <narendraj9> > putStrLn "Hello"
01:44:04 <lambdabot>  <IO ()>
01:44:04 <lambdabot>  can't find file: L.hs
01:44:11 <aleksejs_> because yes, mysql is installed and works
01:44:19 <eazar001> how did you install it?
01:44:24 <eazar001> compile?
01:44:32 <eazar001> source?
01:45:01 <eazar001> type in : whereis mysql
01:45:04 <eazar001> at your bash prompt
01:45:07 <eazar001> what do you get?
01:45:19 <narendraj9> So, the conclusion is I can't have bindings along with other IO actions inside main if I don't use let.
01:45:33 <aleksejs_> mysql: /usr/bin/mysql /etc/mysql /usr/lib/mysql /usr/bin/X11/mysql /usr/share/mysql /usr/share/man/man1/mysql.1.gz
01:45:38 <eazar001> hmmm
01:46:25 <aleksejs_> ive installed it simply: apt-get install mysql-server mysql-client - if it helps
01:47:22 <eazar001> aleksejs_ now type: whereis mysql_config
01:47:38 <aleksejs_> nothing
01:47:43 <eazar001> that's our problem
01:47:56 <aleksejs_> but how to install it?
01:48:09 <eazar001> lol i have it, but i don't know how, because i use postgresql
01:48:13 <eazar001> lemme check
01:48:36 <aleksejs_> maybe I need a dev version of mysql?
01:48:48 <eazar001> i don't think so, i never needed "dev versions" of anything
01:49:10 <eazar001> what's your distro?
01:50:04 <skypers> narendraj9: well
01:50:08 <skypers> you can still use where
01:50:37 <eazar001> ahhh aleksejs_
01:50:39 <skypers> but yes, if your bindings depend on everything but the function parameters, you’ll have to use let
01:50:40 <eazar001> maybe you do need dev
01:50:50 <eazar001> go here: http://stackoverflow.com/questions/8496660/linux-mysql-server-cant-find-mysql-config
01:51:21 <eazar001> aleksejs_: sorry for the confusion: apt-get install libmysqlclient-dev
01:52:15 <aleksejs_> yes, it seems that everything works now :) Thanks!
01:52:31 <eazar001> no prob
01:52:38 <eazar001> i guess aptitude is different
01:52:48 <eazar001> no offense i never liked debian type management
01:52:50 <eazar001> [=
01:52:54 <eazar001> good luck!
01:54:06 * hackagebot language-puppet 0.10.6 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.10.6 (SimonMarechal)
01:54:07 <merijn> narendraj9: I don't understand what you mean by that? You can use where in main just fine
01:54:46 <narendraj9> skypers: thanks :)
01:55:00 <narendraj9> merijn: sorry. I got it.
02:03:19 <skypers> do you know a function that combines liftM and <=< ?
02:03:32 <skypers> like, reading a file and applying a function on its content?
02:03:46 <skypers> (\c -> return $ f c) <=< readFile
02:04:10 <skypers> liftM f . readFile
02:04:11 <skypers> maybe?
02:04:26 <skypers> :t liftM id . readFile
02:04:27 <lambdabot> FilePath -> IO String
02:04:33 <skypers> oooh
02:05:53 <skypers> last question, is there a parser that returns the unconsumed stream?
02:05:57 <skypers> getInput ?
02:06:42 <skypers> yeah I think it’s that
02:41:25 <skypers> @src (<*)
02:41:25 <lambdabot> (<*) = liftA2 const
02:41:34 <skypers> @src (*>)
02:41:34 <lambdabot> (*>) = liftA2 (const id)
02:41:40 <skypers> woah
02:42:16 <skypers> const id
02:42:24 <skypers> what the…
02:42:29 <skypers> :t const id
02:42:30 <lambdabot> b -> a -> a
02:42:41 <skypers> :t flip const
02:42:42 <lambdabot> b -> c -> c
02:42:55 <skypers> why isn’t it implemented with flip?
02:43:47 <skypers> oh ok, I get it
02:43:56 <skypers> the id is used as the first parameter of const
02:44:04 <skypers> the first value goes in b, so it’s discarded
02:44:10 <skypers> then we just apply id on the last parameter
02:44:16 <skypers> which actually flips const
02:44:54 <Wazhai> Hi guys! I have a short question. I'm on Windows and I can't get a newline in a string to work. Neither "\n" nor "\r\n" work, it just shows up like that with the "\r\n".
02:44:55 <skypers> @src liftA2
02:44:55 <lambdabot> liftA2 f a b = f <$> a <*> b
02:45:05 <skypers> yeah I thought it was implemented that way
02:45:20 <frxx> Wazhai use putStrLn not print
02:45:21 <shachaf> What does "work" mean?
02:45:49 <skypers> Wazhai:
02:45:58 <skypers> > print "hi\nfoo"
02:45:59 <lambdabot>  <IO ()>
02:46:04 <skypers> damn :D
02:46:07 <skypers> but yeah
02:46:17 <skypers> you have to use the putStr or putStrLn function
02:46:24 <skypers> otherwise, you get the Show instance of String
02:46:41 <skypers> > show "hello\nthis\nis\ndawg"
02:46:43 <lambdabot>  "\"hello\\nthis\\nis\\ndawg\""
02:48:02 <skypers> I wrote a parser that parses regular eol Haskell comments
02:48:27 <Wazhai> yeah i got it :) thanks
02:48:29 <skypers> comment = string "--" >> many anyChar >> eol
02:48:46 <skypers> why do people advise to use Applicative instead of Monad here?
02:49:09 <Wazhai> it also works with just "\n"
02:50:32 <Taneb> skypers, it's more general
03:03:19 <jfischoff> I don't get why the cabal sandbox can't uninstall packages when the version change
03:03:29 <jfischoff> I guess I don't see the danger
03:25:31 <ChongLi> ΑαΒβΓγΔδΕεΖζΗηΘθΙιΚκΛλΜμΝνΞξΟοΠπΡρΣσςΤτΥυΦφΧχΨψΩω
03:25:34 <ChongLi> yay!
03:25:50 <ChongLi> just updated my font to Inconsolata Hellenic
03:25:59 <ChongLi> now I can actually see the greek alphabet!
03:29:37 <popl> ChongLi: May I suggest Code2000?
03:29:54 <popl> ChongLi: http://en.wikipedia.org/wiki/Code_2000
03:30:29 <ChongLi> wow
03:31:02 <popl> I use it and Deja Vu Sans
03:31:04 <skypers> isn’t there a combinator that can be used in parsec to establish parsers predicates?
03:31:14 <skypers> like the satisfy function, but for parsers
03:31:48 <ChongLi> skypers: not sure what you mean
03:31:59 <skypers> I’d like to parse a string, verify it equals a constant string, and if so returns (), otherwise emits an error
03:32:08 <skypers> for now I use monads and parseFail
03:32:25 <ChongLi> you can just use an applicative parser for it
03:32:36 <skypers> what do you mean?
03:33:18 <ChongLi> string "foo" *> () <?> "error message"
03:33:38 <skypers> huh
03:33:45 <skypers> it won’t typecheck I guess
03:33:45 <ChongLi> oh, <?> is from attoparsec
03:33:47 <ChongLi> hmm
03:33:50 <skypers> no no
03:33:54 <skypers> we have it in parsec too
03:34:06 <skypers> but string "foo" *> () won’t typecheck
03:34:16 <skypers> maybe
03:34:23 <skypers> string "foo" *> return () <?> "oops"
03:34:28 <ChongLi> yeah that's right
03:34:32 <ChongLi> or pure ()
03:34:34 <supki> () <$ string "foo"
03:34:43 <ChongLi> thank you
03:35:11 <skypers> ok but the thing is
03:35:26 <skypers> yeah nvm
03:35:43 <ChongLi> it works now? :)
03:35:54 <skypers> I don’t know, I have to test
03:36:25 <skypers> I need the end of line
03:36:29 <skypers> then I guess I can just do
03:36:37 <skypers> () <$ string "foo" <* eol
03:36:49 <skypers> that’s very cryptic isn’t it?
03:37:05 <ChongLi> I think it's fine
03:37:38 <skypers> I might need parens
03:43:23 <raymank26> hi all. I'm trying to use gloss text but I get the error "freeglut (Main.hs): stroke font 0x40be6e88 not found" how to fix that?
03:47:36 <Reite> How do I compose two "at" lenses to get a lens for a nested map?
03:50:27 <skypers> isn’t there already an eitherRead function?
03:50:42 <skypers> @hoogle (Read a) => String -> Either String a
03:50:43 <lambdabot> No results found
03:54:49 <skypers> @let eitherRead :: (Read a) => String -> Either String a; eitherRead s = case reads s of { [(v,_)] -> Right v; _ -> Left s}
03:54:51 <lambdabot>  Defined.
03:55:05 <skypers> > eitherRead "3" :: Either String Float
03:55:08 <lambdabot>  Right 3.0
03:55:14 <skypers> > eitherRead "x3" :: Either String Float
03:55:15 <lambdabot>  Left "x3"
03:55:25 <skypers> > eitherRead "3." :: Either String Float
03:55:26 <lambdabot>  Right 3.0
03:55:34 <skypers> that’s just great
03:56:58 <skypers> @let eitherRead :: (Read a) => String -> Either String a; eitherRead s = case reads s of { [(v,[])] -> Right v; _ -> Left s}
03:56:59 <lambdabot>  .L.hs:148:1:
03:56:59 <lambdabot>      Duplicate type signatures for `eitherRead'
03:56:59 <lambdabot>      at .L.hs:146:1-10
03:56:59 <lambdabot>         .L.hs:148:1-10
03:57:03 <curried> eitherRead "5.0"
03:57:06 <skypers> @unlet
03:57:07 <lambdabot>  Define what?
03:57:11 <skypers> @let eitherRead :: (Read a) => String -> Either String a; eitherRead s = case reads s of { [(v,[])] -> Right v; _ -> Left s}
03:57:12 <lambdabot>  .L.hs:148:1:
03:57:12 <lambdabot>      Duplicate type signatures for `eitherRead'
03:57:12 <lambdabot>      at .L.hs:146:1-10
03:57:12 <lambdabot>         .L.hs:148:1-10
03:57:14 <curried> > eitherRead "5.0"
03:57:15 <skypers> aaarh
03:57:15 <lambdabot>  Left "5.0"
03:57:19 <curried> > eitherRead "5"
03:57:20 <lambdabot>  Left "5"
03:57:31 <curried> > eitherRead "h"
03:57:32 <lambdabot>  Left "h"
03:57:38 <skypers> @let eitherRead' :: (Read a) => String -> Either String a; eitherRead s = case reads s of { [(v,[])] -> Right v; _ -> Left s}
03:57:39 <lambdabot>  .L.hs:148:1:
03:57:39 <lambdabot>      The type signature for eitherRead' lacks an accompanying binding
03:57:48 <skypers> @let eitherRead' :: (Read a) => String -> Either String a; eitherRead' s = case reads s of { [(v,[])] -> Right v; _ -> Left s}
03:57:49 <lambdabot>  Defined.
03:58:02 <skypers> > eitherRead' "3.0x" :: Either String Float
03:58:04 <lambdabot>  Left "3.0x"
03:58:08 <skypers> this is better
03:58:27 <skypers> :t eitherRead' "h"
03:58:28 <lambdabot> Read a => Either String a
03:58:39 <skypers> :t eitherRead' "0.0"
03:58:40 <lambdabot> Read a => Either String a
04:14:01 <erry> hi
04:14:01 <markovirc> Hello erry
04:15:16 <Maior> one day people will start including usage documentation in their hackage libs :(
04:15:53 <alpounet> quite a few people do
04:15:56 <alpounet> but not enough yet
04:16:13 <skypers> I sometimes do
04:16:15 <skypers> is that wrong?
04:18:24 <skypers> :t ($>)
04:18:25 <lambdabot>     Not in scope: `$>'
04:18:26 <lambdabot>     Perhaps you meant one of these:
04:18:26 <lambdabot>       `$' (imported from Data.Function),
04:18:29 <skypers> arf
04:23:18 <skypers> @hoogle (Stream s m t) => [ParsecT s u m a] -> ParsecT s u m a
04:23:19 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
04:23:19 <lambdabot> Text.ParserCombinators.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
04:23:19 <lambdabot> Text.Parsec.Prim lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
04:23:21 <skypers> CHOICE
04:23:23 <skypers> yeah
04:23:37 <skypers> thank you lambdabot ;)
04:36:36 <Kaidelong> was there an extension that fully captured and extended the power of functional dependencies?
04:37:52 <hpc> what's missing from -XFunctionalDependencies?
04:42:49 <gabor> Kaidelong: DataKinds, TypeFamilies
04:50:51 <the_berserker> @pl \f g x -> f x (g x)
04:50:52 <lambdabot> ap
04:51:31 <the_berserker> @pl \x -> x (\a b c -> a c (b c)) const
04:51:31 <lambdabot> flip ($ ap) const
04:52:11 <the_berserker> @unpl \x -> x (\a b c -> a c (b c)) const
04:52:11 <lambdabot> \ x -> x (\ a b c -> a c (b c)) (\ d _ -> d)
04:55:12 <SamanthaD> I have a question... given that Haskell support currying, why does the first function definition compile but the second one freak out? http://sprunge.us/DNYe
04:55:34 <the_berserker> @pl (.) (flip (>>=)) ((.) return)
04:55:35 <lambdabot> fmap
04:56:07 <the_berserker> @pl (>>= id)
04:56:07 <lambdabot> join
04:56:22 <the_berserker> @pl flip (>>=) id
04:56:22 <lambdabot> join
04:56:53 <k00mi> SamanthaD: you need two (.)s in the second definition
04:57:22 <SamanthaD> oh, I see...
04:57:35 <SamanthaD> I get so confused when you need a . and when you need a $
04:57:50 <SamanthaD> thank you k00mi
04:58:12 <the_berserker> @pl \x f -> a (b f x)
04:58:12 <lambdabot> (a .) . flip b
04:58:21 <k00mi> ($) would apply "iterate f" to "filter p", but the types don't match
04:58:27 <the_berserker> @pl (join
04:58:27 <lambdabot> (line 1, column 6):
04:58:27 <lambdabot> unexpected end of input
04:58:27 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
04:58:45 <the_berserker> @pl (join .) . flip fmap
04:58:45 <lambdabot> (join .) . flip fmap
04:59:15 <SamanthaD> k00mi: oh, I see, it tries to feed a function where a list is expected.
04:59:29 <k00mi> correct
05:00:15 <SamanthaD> okay, so why doesn't      iterateTo p = head . filter p . iterate     work as expected?
05:00:17 <the_berserker> @pl \a b -> do {x <- a; y <- b; f a b}
05:00:17 <lambdabot> (line 1, column 12):
05:00:17 <lambdabot> unexpected '{'
05:00:17 <lambdabot> expecting variable, "(", operator or end of input
05:01:16 <the_berserker> @pl (ap const ap ap) . (const const ap ap) . (flip flip flip id (.) ap const ap ap)
05:01:16 <lambdabot> ap . const ap
05:01:45 <the_berserker> @unpl ap.const ap
05:01:45 <lambdabot> (\ d -> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ n o -> n >>= \ l -> o >>= \ k -> return (l k)))
05:01:53 <the_berserker> @unpl ap
05:01:53 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
05:02:01 <k00mi> SamanthaD: that's because (.) composes functions of one argument, so as soon as you apply the function to iterate, it would try to feed that to filter
05:02:08 <k00mi> :t (.)
05:02:09 <lambdabot> (b -> c) -> (a -> b) -> a -> c
05:02:23 <the_berserker> :t fix id
05:02:24 <lambdabot> a
05:02:33 <SamanthaD> k00mi: oh, I see. I understand now. Thanks.
05:02:35 <the_berserker> :t fix fix
05:02:36 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
05:02:36 <lambdabot>     Expected type: (a0 -> a0) -> a0 -> a0
05:02:36 <lambdabot>       Actual type: (a0 -> a0) -> a0
05:03:02 <k00mi> glad to help
05:09:46 <mm_freak> in pattern matching, when matching without guards, what's the complexity to identify the outermost constructor?
05:11:44 <mgsloan> O(1)
05:12:35 <mm_freak> thanks
05:12:53 <mgsloan> A constructor can be thought of like a function that accepts a number of callbacks for the different constructors
05:12:56 <mgsloan> welcome!
05:13:03 <mm_freak> yeah, that's what i thought
05:13:08 <mm_freak> since it's STG
05:13:48 <mgsloan> Yup!  Now, it's possible that I'm wrong.  I'm basing this off the 1992 STG paper and other people saying that "a few details have changed, but the operational intuitions are the same".
05:14:48 <mm_freak> hmm…  passing n arguments to that function would still take O(n), but they are probably not procedures in the traditional sense
05:15:56 <mgsloan> pattern matching complexity would scale linearly with the number of arguments, yes
05:16:38 <mgsloan> They aren't procedures in the traditional sense because it's no longer tagless :)
05:16:40 <mm_freak> so it's O(n) after all
05:16:45 <mgsloan> probably among other reasons
05:17:06 <mgsloan> Well, when n is the number of paramters yeah
05:17:18 <mm_freak> the number of constructors
05:17:22 <mgsloan> Nah
05:17:47 <mgsloan> I think the taglessness short circuits the first few constructors
05:17:50 <mgsloan> using pointer flags
05:17:57 <mm_freak> type Either e a = forall r. (e -> r) -> (a -> r) -> r
05:18:00 <mgsloan> s/taglessness/taggedness/
05:18:20 <mgsloan> But after that it's falling back to the vectored return type stuff
05:18:27 <mm_freak> to apply this function you need to pass two continuations
05:19:51 <mm_freak> so you're saying that there is a threshold after which pattern matching becomes O(n)?
05:19:54 <mgsloan> Yup, and I think that's approximately how large-arity datatypes work
05:19:57 <mgsloan> No
05:20:23 <mgsloan> that callback style is O(1)
05:21:12 <mm_freak> how can it be O(1)?  function application isn't free
05:21:33 <mgsloan> it is when you're passing a pointer to an array of function pointers
05:21:52 <mm_freak> is this array calculated at compile time?
05:21:56 <mgsloan> yup
05:22:00 <mm_freak> ah, i see
05:22:15 <mm_freak> similar to C++ vtables
05:22:21 <mgsloan> This was my impression of the 1992 STG paper, though, maybe there's some cleverer stuff going on
05:22:24 <mgsloan> yeah
05:22:46 <mm_freak> well, i've read that paper
05:23:09 <mm_freak> but my impression was that the pattern matching itself is O(1), but there is setup work that is O(n)
05:23:26 <mm_freak> but yeah, you could optimize that setup work away
05:23:31 <mgsloan> right, but compiletime work, yeah
05:24:11 <mgsloan> Now, there is the consideration that this does mean it's O(n) in space
05:24:24 <mgsloan> which could suck if you're just matching on one constructor out of many
05:34:12 <mm_freak> mgsloan: O(n) space is not an issue for me
05:34:51 <mgsloan> Cool! (especially since it's executable space)
05:49:59 <identity> Is there a certain config file library that is the "de-facto" library on hackage?
05:52:40 <mm_freak> identity: not really, but there are good ones
05:52:48 <identity> mm_freak: have any favorites?
05:52:56 <identity> I can see the one by goerzen hasn't been updated since 2010
05:53:28 <mm_freak> just go to the packages list on hackage and search for "configuration" on the page…  there is at least one package that receives frequent updates
06:03:19 <identity> I guess bos's configurator looks good
06:03:43 <hpc> identity: pretty much any serializable data structure will do - perhaps you could use json or sqlite
06:03:53 <hpc> (configuration files being about the only thing sqlite is good for)
06:04:13 <identity> hpc: True. But this is intended to be a format that users edit themselves
06:04:30 <hpc> right
06:04:36 <identity> so some freedom in the format and so on would be nice
06:04:40 <identity> configurator looks really nice tbh.
06:04:48 <identity> even though it hasn't been updated since 2012
06:05:09 <hpc> doesn't seem like something that needs to be updated frequently
06:05:46 <hpc> that's a nice format
06:05:47 <identity> nah, true. but you know, don't want to deal with 'abandonware' etc if I should run into some bugs or some such
06:06:01 <identity> i'll try configurator
06:06:30 <hpc> especially with how $(foo) works
06:06:44 <hpc> looking up a config file value or an env value
06:08:08 <hpc> i need to find an excuse to use that package now
06:08:15 <identity> haha :)
06:08:58 <hpc> perhaps some kind of automake ripoff :D
06:12:06 <blablub> why does this code abort with <<loop>> (GHC):  parPrimes = seqPrimes `using` evalBuffer 10 rseq
06:14:21 <A3mr> hello, just to check my understanding: pure functions are those for which congruence is provable, right?
06:14:22 <markovirc> Hello A3mr
06:14:43 <A3mr> markovirc: hello
06:17:14 <int-e> blablub: I see a bunch of identifiers from the parallel package, and a bunch of unknown ones. how are we supposed to answer that question?
06:18:25 <mm_freak> the first question is whether 'seqPrimes' alone works
06:18:40 <blablub> int-e: seqPrimes is a classical prime sieve:  seqPrimes = 2 : [i | i <- [3..], and [rem i p > 0 | p <- takeWhile ((<=i).(^2)) primes]]
06:18:51 <mm_freak> blablub: that's not a prime sieve
06:18:53 <blablub> seqPrimes alone works, it is infinite
06:19:37 <mm_freak> blablub: anyway, evalBuffer does not parallelize
06:19:57 <mm_freak> parBuffer does
06:19:59 <blablub> mm_freak: i originally wanted to use parBuffer, but not even evalBuffer works
06:20:13 <mm_freak> try parBuffer anyway
06:20:28 <blablub> mm_freak: i have, it also gave me <<loop>>
06:21:15 <blablub> mm_freak: i get <<loop>> when i run it compiled (ghc), when i run it via runghc, it does not terminate
06:21:31 <blablub> (at least it is not responding any more)
06:22:22 <blablub> int-e, mm_freak: oops, sorry
06:22:56 <blablub> i found it, i just failed to rename the "primes" call to "seqPrimes" in "seqPrimes"
06:23:03 <blablub> sorry for bothering you
06:23:28 <mm_freak> hehe
06:23:31 <mm_freak> no worries
06:23:32 <shiona> @hoogle (Num a, Floating b) => a -> b
06:23:33 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
06:23:33 <lambdabot> Foreign.Marshal.Utils toBool :: Num a => a -> Bool
06:23:33 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
06:23:34 <blablub> (i am new to parallelization with haskell, so i did not understand the <<loop>>)
06:23:36 <mm_freak> blablub: but it's still not a sieve
06:23:48 <blablub> mm_freak: ok, why not?
06:23:55 <mm_freak> a real sieve is a bunch of bit operations…  in particular it does not use division
06:24:03 <mm_freak> see the sieve of eratosthenes
06:24:03 <Tekmo> blablub: <<loop>> triggers whenever ghc detects something will not terminate
06:24:32 <mm_freak> Tekmo: guess what, i just received your one-liner =)
06:24:34 <Tekmo> blablub: I believe ghc only does this loop detection when you compile code, which is why you got different behavior when running it in ghci, which is interactively interpreted
06:24:37 <Tekmo> mm_freak: :)
06:24:43 <blablub> mm_freak: well, i can do the sieve on a piece of paper by crossing out diagonals ... there i also do not do bit operations
06:24:54 <mm_freak> lambdabot failed to identify me as mm_freak when my nickname was mm_freak_ =)
06:25:00 <Tekmo> That makes sense
06:25:48 <mm_freak> blablub: yes, you do…  you have a bunch of squares which are set to empty (1), and you cross some of them (set them to 0)
06:26:02 <skypers> what are you talking about?
06:26:04 <skypers> matrix mult?
06:26:14 <mm_freak> it's an array of bits, and you're applying bit operations…  at no point you're using division
06:26:15 <Vince_Juicy> hi, is there a way to catch call to error without being in the IO Monad?
06:26:17 <markovirc> Hello Vince_Juicy
06:26:22 <mm_freak> Vince_Juicy: no
06:26:43 <skypers> Vince_Juicy: depends on the error I guess
06:26:51 <skypers> you can use the EitherT error, or ErrorT
06:26:54 <mm_freak> Vince_Juicy: distinguishing the various flavours of bottom is a side effect
06:27:07 <rawtass> How can I change the data in one member of a data structure and return the whole data structure with the member updated?
06:27:09 <skypers> I personnally use EitherT to handle errors
06:27:11 <Vince_Juicy> well, I'm relying of "fail" of binary, and prior to version 0.6, it's directly calling error
06:27:15 <blablub> mm_freak: does that mean that the sieve can only work on a finite set of numbers?
06:27:17 <skypers> rawtass: lens
06:27:27 <Tekmo> skypers: It's a good practice to not use `error`, ever
06:27:30 <mm_freak> rawtass: if you have defined fields, you can use accessor syntax:  x { field = y }
06:27:45 <int-e> blablub: you can sieve many finite ranges of numbers
06:27:54 <skypers> > (1,("hi",Just 5)) & _1._2 %~ length
06:27:55 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field2
06:27:56 <lambdabot>                      GHC.Integer.Type.Integer t1 [a0] GHC.Types.Int)
06:27:56 <lambdabot>    arising from the ambiguity check for `e_11512'
06:27:56 <lambdabot>  from the context (GHC.Num.Num t,
06:27:56 <lambdabot>                    GHC.Num.Num a,
06:27:59 <skypers> I suck at that…
06:28:01 <Tekmo> skypers: Instead, learn how to use `Maybe`/`MaybeT`/`Either`/`EitherT`
06:28:10 <skypers> Tekmo: that’s what I said…
06:28:18 <mm_freak> blablub: not quite…  you can sieve arbitrary ranges, but the larger the minimum bound gets the longer it will take
06:28:19 <Tekmo> skypers: Oops
06:28:25 <Tekmo> skypers: I thought it was somebody else who said that
06:28:35 <skypers> > (1,("hi",Just 5)) & _1._2 .~ "lolo"
06:28:37 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field2
06:28:37 <lambdabot>                      GHC.Integer.Type.Integer t1 a0 [GHC.Types.Char])
06:28:37 <lambdabot>    arising from the ambiguity check for `e_11512'
06:28:37 <lambdabot>  from the context (GHC.Num.Num t,
06:28:37 <lambdabot>                    GHC.Num.Num a,
06:28:44 <skypers> what the…
06:28:48 <Tekmo> skypers: I confused you with Vince
06:28:51 <skypers> > (1,("hi",Just 5)) & _1 .~ "lolo"
06:28:53 <lambdabot>  ("lolo",("hi",Just 5))
06:28:57 <skypers> rawtass: ^
06:29:19 <nooodl> don't you need _2._1?
06:29:33 <skypers> rawtass: personnally, I don’t use lens, because it’s still overhwelming to me
06:29:34 <Vince_Juicy> Tekmo > the problem is that it's a third party library who call error
06:29:36 <blablub> mm_freak: i see, thanks for clearing that up
06:29:41 <skypers> > (1,("hi",Just 5)) & _2._1 .~ "lolo"
06:29:43 <lambdabot>  (1,("lolo",Just 5))
06:29:46 <skypers> nice nooodl
06:29:52 <mm_freak> Vince_Juicy: then it's probably best to avoid that library =)
06:29:57 <skypers> > (1,("hi",Just 5)) & _2._1 %~ length
06:29:57 <mm_freak> because it seems ill-designed
06:29:58 <lambdabot>  (1,(2,Just 5))
06:30:13 <Vince_Juicy> mm_freak > well, it's "binary" from the haskell platform, hard to avoid
06:30:22 <skypers> oh
06:30:24 <mm_freak> binary calls 'error'?
06:30:28 <Tekmo> Vince_Juicy: See the `spoon` package, which lets you transform it to a `Maybe`-based error
06:30:30 <skypers> yeah well
06:30:30 <Vince_Juicy> (binary < 0.6, version above 0.6 don't call errors)
06:30:35 <Tekmo> @package spoon
06:30:35 <lambdabot> http://hackage.haskell.org/package/spoon
06:30:42 <skypers> you can catch that with Control.Exception.catch
06:30:43 <skypers> or try
06:30:55 <Vince_Juicy> Control.Exception.catch works in IO...
06:31:04 <Vince_Juicy> wich is precisely what I want to avoid
06:31:27 <Tekmo> Vince_Juicy: The `spoon` function from that package has this type:
06:31:36 <Tekmo> spoon :: NFData a => a -> Maybe a
06:31:45 <Tekmo> Vince_Juicy: Any `error` is converted to a `Nothing`
06:31:53 <mm_freak> Vince_Juicy: well, the usual use case for 'error' is checking required invariants, which are not expressed in the type system
06:32:07 <skypers> I dislike the error function
06:32:18 <skypers> everyone should use Maybe, MaybeT, Either and EitherT
06:32:18 <Tekmo> skypers: He says he is using another library which uses `error`
06:32:21 <skypers> and limit exceptions to IO
06:32:24 <rawtass> mm_freak: the thing is that I have alot of members in the data structure and I don't want to type them all out, just the one that I am changing.
06:32:27 <skypers> yes Tekmo
06:32:32 <Tekmo> skypers: He wants to know how to convert it to a typed error
06:32:34 <mm_freak> rawtass: yes
06:32:35 <skypers> and this lib is ill-designed then
06:32:38 <mm_freak> rawtass: x { field = y }
06:32:47 <Tekmo> skypers: You go to war with the libraries you have! :)
06:33:03 <mm_freak> rawtass: where x is the original value, "x { field = y}" is the original value with 'field' set to y
06:33:27 <skypers> Tekmo: well, don’t you agree?
06:33:50 <skypers> error shouldn’t exist
06:33:51 <rawtass> mm_freak: ah, right.. It works ..
06:33:54 <skypers> it’s handy in some cases
06:33:59 <skypers> like tail, head, and so on
06:34:07 <Tekmo> skypers: Yes, I avoid those kinds of libraries like the plague
06:34:08 <skypers> but it conflicts the type system to me
06:34:14 <Tekmo> skypers: I hate `error` with a passion
06:34:20 <skypers> so do I
06:34:42 <rawtass> skypers: thanks, but this seems easier :)
06:34:47 <skypers> whereas dealing with Either and EitherT is just so much GODNESS
06:34:51 <skypers> rawtass: well
06:34:52 <Tekmo> Yes
06:34:59 <skypers> it depends on what you want to do
06:35:02 <Tekmo> skypers: You're talking to the guy who wrote the `errors` package :)
06:35:07 <Tekmo> skypers: You're preaching to the choir
06:35:20 <skypers> if you have two nested values, the record syntax just sucks
06:35:21 <skypers> oh Tekmo
06:35:26 <skypers> you wrote errors?
06:35:29 <Tekmo> Yes :)
06:35:33 <skypers> then I have a question
06:35:38 <skypers> why an Error typeclass?
06:35:42 <skypers> it’s _really_ annoying
06:35:48 <Tekmo> Error type class?
06:35:51 <skypers> yeah
06:35:52 <Tekmo> There are no type classes in that library
06:35:57 <skypers> in ErrorT
06:36:07 <skypers> the Left part should be an Error
06:36:10 <skypers> or something like that
06:36:11 <Tekmo> Oh, you're confusing `errors` with `transformers`
06:36:18 <skypers> and we can’t use String
06:36:20 <Tekmo> I always use `EitherT`, not `ErrorT`
06:36:28 <skypers> huh
06:36:32 <Tekmo> The `errors` package only supports `EitherT`
06:36:34 <skypers> ErrorT is not in transformers is it?
06:36:38 <Tekmo> skypers: It is
06:36:41 <skypers> ah
06:36:42 <skypers> well
06:36:47 <Tekmo> skypers: Control.Monad.Trans.Error is from `transformers`
06:36:47 <skypers> I use data-either
06:36:52 <skypers> or either*
06:36:55 <skypers> I guess it’s either
06:36:58 <skypers> the package name
06:36:59 <Tekmo> skypers: `either` is the blessed one
06:37:10 <Tekmo> skypers: That's also the one that `errors` uses
06:37:11 <skypers> what errors provides?
06:37:24 <Tekmo> skypers: You should read this post: http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
06:37:28 <Tekmo> skypers: It's completely up your alley
06:37:44 <skypers> because EitherT is already a really nice package to handle errors
06:38:05 <Tekmo> skypers: `errors` is basically a large library of utilities for `Maybe`/`Either`/`MaybeT`/`EitherT`/
06:38:08 <Tekmo> skypers: You will love it
06:38:15 <Tekmo> @package errors
06:38:16 <lambdabot> http://hackage.haskell.org/package/errors
06:38:47 <identity> hpc: did you by chance try the library out immediately?
06:38:49 <skypers> oh
06:38:55 <identity> because as far as I can see, it isn't quite working.
06:38:55 <skypers> I know your libraries
06:39:03 <skypers> and errors
06:39:07 <skypers> is it that lib that provides so
06:39:21 <skypers> some function like EitherT e a -> Maybe a
06:39:24 <skypers> or something like that
06:39:32 <Tekmo> hushT is what you are thinking of
06:39:36 <Tekmo> hushT :: Monad m => EitherT a m b -> MaybeT m b
06:39:37 <skypers> hushT
06:39:37 <skypers> yes
06:39:42 <skypers> why hush? :D
06:39:48 <Tekmo> It's like you are silencing the error
06:40:02 <skypers> ok
06:40:03 <skypers> ahah
06:40:06 <skypers> note seems pretty cool!
06:40:37 <skypers> thank you for that share Tekmo
06:40:43 <Tekmo> skypers: You're welcome! :)
06:40:49 <osa1> guys, I want to use some FRP library with hsSDL2 but can't figure out which FRP library to choose, can anyone help me with this? as far as I can see Netwire is popular but also complex, I was wondering maybe I should go with elerea or something else ...
06:40:50 <skypers> I think I’m gonna change my dependency
06:40:52 <magneticduck> kind of annoying how many small interesting packages on haskell seem to be broken (don't compile)
06:41:00 <magneticduck> games for instance =P
06:41:12 <magneticduck> http://hackage.haskell.org/package/dow <-- for instance doesn't compile
06:41:40 <magneticduck> isn't it kind of pointless to upload packages to hackage that simply don't compile?
06:41:44 <Tekmo> magneticduck: My guess is that it is because the author didn't put bounds on its dependencies
06:41:55 <magneticduck> I mean, basic things, not dependencies and such
06:41:58 <Tekmo> magneticduck: It probably compiles with older versions of those packages, but `cabal` will pull in the latest version by default
06:42:04 <magneticduck> oh true
06:42:44 <mm_freak> osa1: the two "big" ones are netwire and reactive-banana
06:42:54 <mm_freak> osa1: it mostly depends on what kind of application you want to write
06:43:18 <Tekmo> mm_freak: Oh, that reminds me
06:43:25 <Tekmo> mm_freak: I wanted you to check out my `mvc` package
06:43:35 <Tekmo> mm_freak: It plays well with both `pipes` and `netwire`
06:43:51 <mm_freak> Tekmo: URL?
06:43:53 <Tekmo> mm_freak: https://github.com/Gabriel439/Haskell-MVC-Library
06:44:11 <Tekmo> mm_freak: It doesn't compile because I made some last minute changes, but just read the documentation
06:44:35 <identity> hpc: disregard my previous statemtn, my understanding of the format was wrong
06:44:53 <Tekmo> mm_freak: The basic idea is that you write applications so all the concurrent logic is separated out from the core model
06:45:06 <skypers> ahah
06:45:10 <skypers> Safe sounds amazing
06:45:18 <Tekmo> mm_freak: The model can be any streaming abstraction.  `mvc` uses a `Pipe` as the model, but it could just as easily be a `Wire`
06:45:22 <Tekmo> skypers: :)
06:45:28 <skypers> huh
06:45:30 <skypers> tailNote
06:45:35 <skypers> it has a pretty weird signature
06:45:47 <skypers> oh noes
06:45:53 <skypers> it might use error as well
06:45:59 <Tekmo> mm_freak: All concurrent inputs are grouped into a single input using the `Monoid` instance for `View`s
06:46:15 <Tekmo> mm_freak: Similarly, all concurrent outputs are grouped into a single output, using the `Monoid` instance for `View`s
06:46:23 <Tekmo> Oops, I misspoke.  Concurrent inputs are `Controller`s, not `View`s
06:46:35 <Tekmo> mm_freak: This lets you distil out all concurrent logic into a single input and a single output
06:46:49 <mm_freak> Tekmo: well, i don't use MVC anywhere
06:46:59 <skypers> :t tailDef
06:47:00 <lambdabot> Not in scope: `tailDef'
06:47:04 <Tekmo> mm_freak: It's mainly a way to structure concurrent applications
06:47:12 <Tekmo> mm_freak: ... so that they don't become channel spaghetti code
06:47:17 <mm_freak> Tekmo: yes, i know what MVC is…  that's why i don't use it =)
06:48:54 <mm_freak> Tekmo: MVC has always lead to abstraction spaghetti over time in the projects i've seen it being used…  spaghetti seems to be a natural feature of MVC
06:49:48 <mm_freak> Tekmo: i have a different idea in mind to manage stateful components…  and i have two libraries in development for it
06:49:58 <mm_freak> reactive-stm and acid-frp
06:50:59 <meretrix> What's the downside to compiling everything with "-threaded"?  Does it make "forkIO" calls more expensive?
06:51:07 <mm_freak> meretrix: yes
06:51:42 <meretrix> mm_freak: By what order of magnitude?
06:51:51 <mm_freak> meretrix: single-threaded applications will run slightly faster, but the difference is small enough
06:51:52 <raymank26> hi all. I'm trying to use gloss text but I get the error "freeglut (Main.hs): stroke font 0x40be6e88 not found" how to fix that?
06:51:57 <skypers> I also have an FRP library in a wiwp
06:51:59 <skypers> wip*
06:52:11 <skypers> but it may suck, so… :D
06:52:25 <mm_freak> skypers: continuous time semantics?
06:52:28 <skypers> https://github.com/skypers/reactant
06:52:32 <skypers> I think so mm_freak
06:53:01 <mm_freak> skypers: ah, you meant to say, "i think it's FRP", then =)
06:53:12 <skypers> huh no it’s FRP for sure
06:53:18 <skypers> but it may be weak FRP :D
06:53:31 <skypers> I designed it while learning reactive-banana
06:53:40 <skypers> I nevere used it though
06:53:42 <skypers> never*
06:53:57 <mm_freak> hmm, you're in fact using Event t a = [(t, a)]
06:54:17 <skypers> yes, so?
06:54:29 <mm_freak> that's FRP, but you will find that switching will be very expensive
06:55:00 <skypers> what is switching?
06:55:58 <mm_freak> skypers: switchB :: Event (Behavior a) -> Behavior a -> Behavior a
06:56:00 <Tekmo> I don't think anybody has clearly stated what the problem is that FRP solves
06:56:16 <magneticduck> raymank26: that means you have openGL font problems!
06:56:18 <magneticduck> have fun
06:56:25 <skypers> mm_freak: ok so you have an event stream of Behavior
06:56:31 <skypers> another behavior
06:56:36 <skypers> and you get a final behavior
06:56:39 <skypers> I don’t get it
06:56:42 <mm_freak> skypers: switchB e b0 acts like b0 until e occurs, at which point it behaves like the behavior the event carries
06:57:01 <mm_freak> "switching" that is
06:57:10 <skypers> hm
06:57:11 <skypers> I see
06:57:21 <mm_freak> Tekmo: the author of sodium has stated it very well in his presentation
06:57:29 <raymank26> magneticduck: I'm trying to compile samlple openGL program with stroke text and I have no problems
06:57:37 <mm_freak> Tekmo: http://www.youtube.com/watch?v=gaG3tIb3Lbk
06:57:38 <Tekmo> mm_freak: Give me a one-line summary
06:58:02 <mm_freak> Tekmo: getting rid of event spaghetti
06:58:08 <skypers> mm_freak: for me, a Behavior is a time-varying value
06:58:09 <mm_freak> removing event handlers
06:58:15 <skypers> then, an Event of Behavior is…
06:58:16 <skypers> what?
06:58:26 <skypers> a Behavior is built from Event
06:58:31 <skypers> like Event a -> Behavior a
06:58:52 <mm_freak> skypers: let me add time to it
06:58:56 <mm_freak> then it may be clearer
06:59:00 <skypers> so an Event of Behavior is quite confusing
06:59:02 <skypers> sure
06:59:40 <mm_freak> switchB :: Event t (forall t'. Behavior t' a) -> Behavior t a -> Behavior t a
06:59:51 <mm_freak> that's basically what AnyMoment is in reactive-banana
06:59:53 <Tekmo> Why would I want switching?
07:00:31 <mm_freak> Tekmo: define a behavior that displays "blah" and "blubb" alternatingly at a rate of one second
07:01:08 <skypers> oh ok
07:01:10 <skypers> then
07:01:16 <skypers> the time is fetched
07:01:27 <skypers> if something occurs in the event stream
07:01:28 <Tekmo> mm_freak: I'd just use a `State` base monad to keep track of which one to output
07:01:34 <skypers> it’s used as the current Behavior
07:01:35 <skypers> if not
07:01:42 <skypers> we use the explicit Behavior?
07:02:01 <mm_freak> Tekmo: FRP gets rid of imperative stuff, including State
07:02:09 <Tekmo> mm_freak: What's wrong with `State`?
07:02:17 <mm_freak> Tekmo: it's imperative
07:02:23 <Tekmo> mm_freak: What's wrong with imperative?
07:02:49 <mm_freak> skypers: no, when an event with behavior b occurs, then switchB switches to that behavior
07:03:01 <mm_freak> until another event occurs, at which point it switches again
07:03:14 <mm_freak> Tekmo: if you don't mind imperative programming, you don't need FRP =)
07:03:16 <Tekmo> mm_freak: do notation is basically imperative programming style, yet we use it pervasively in Haskell all the time
07:03:28 <mm_freak> Tekmo: the purpose of FRP is to make event management fully declarative
07:03:35 <mm_freak> in order to escape from integration hell
07:03:47 <Tekmo> mm_freak: But how does imperative programming cause integration hell?
07:04:07 <skypers> callbacks
07:04:09 <skypers> I guess?
07:04:12 <Tekmo> mm_freak: I have a feeling you don't know how to use `zoom`
07:04:24 <mm_freak> Tekmo: assume that it's not a rate of one second, but at a rate of "some event"
07:04:38 <mm_freak> like when the user clicks
07:04:43 <Tekmo> mm_freak: Right
07:04:47 <mm_freak> skypers: yes, callbacks
07:04:55 <skypers> callbacks are hell
07:05:02 <Tekmo> mm_freak: Do you want me to just write up the equivalent `pipes` program for you?
07:05:18 <mm_freak> Tekmo: i don't really want to repeat here what stephen explains very well at the beginning of his video
07:05:31 <mm_freak> Tekmo: no, because pipes doesn't give you FRP guarantees
07:05:40 <mm_freak> pipes uses discrete time
07:05:46 <Tekmo> mm_freak: What kinds of guarantees?
07:06:01 <mm_freak> Tekmo: i'll stop here…  watch the video, if you're interested =)
07:08:01 <Tekmo> mm_freak: Honest question: are you familiar with `zoom`?
07:11:13 <mm_freak> Tekmo: of course
07:11:50 <Tekmo> mm_freak: `zoom` makes it easy to isolate and decouple states and provides nice guarantees (via the monad morphism laws)
07:12:08 <mm_freak> Tekmo: yes, but it does not solve the same problem
07:12:49 <mm_freak> Tekmo: you're solving large state management, but FRP solves complex event management
07:13:05 <Tekmo> mm_freak: Right, but that's what `mvc` does well
07:13:14 <Tekmo> This is why I combine the two
07:13:54 <mm_freak> Tekmo: yesNo = "yes" . for 1 --> "no" . for 1 --> yesNo
07:14:08 <mm_freak> the per-second switching between "yes" and "no" in netwire
07:14:28 <mm_freak> declarative event management
07:14:32 <meretrix> Why do postgresql-simple database commands not block all threads when compiled without "-threaded"?  I thought all FFI calls block without "-threaded".
07:15:09 <tristan__> why is it an FFI call
07:15:15 <mm_freak> Tekmo: now the killer feature is that you can turn this "for 1" into an argument
07:15:20 <mm_freak> events become first class
07:15:29 <meretrix> tristan__: It links against libpq, doesn't that make it FFI?
07:15:45 <mm_freak> Tekmo: does that make sense?
07:15:57 <yesthisisuser> if it is possible to compile Haskell code to llvm bytecode. and Emscripten can translate that to JavaScript... hmm. I'm sure you see what I'm "drifting at"..
07:16:14 <Tekmo> mm_freak: I'm studying the implementation of `for`
07:16:19 <Tekmo> mm_freak: What is `dtime`?
07:16:20 <tristan__> meretrix: yea, questioning why it does that instead of just talking to postgres
07:16:39 <mm_freak> Tekmo: well, in FRP this would be an implementation detail =)
07:16:57 <mm_freak> Tekmo: netwire uses a framed implementation, and dtime is the time delta to the last frame
07:17:10 <Tekmo> mm_freak: I'm just trying to reason about how `for` behaves in the presence of ocncurrency
07:17:19 <Tekmo> mm_freak: i..e how I would I run two `yesno`s in parallel
07:17:26 <mm_freak> the continuous time guarantees of FRP require me not to expose this discreteness to the user
07:17:32 <mm_freak> that's why there is the FRP.Netwire tree
07:17:38 <mm_freak> (in addition to Control.Wire)
07:18:05 <Tekmo> mm_freak: What's the type signature of tee (roughly)?
07:18:09 <mm_freak> Tekmo: netwire is not concurrent…  it's a computation framework
07:18:17 <mm_freak> tee?
07:18:22 <mm_freak> what does it do?
07:18:25 <Tekmo> mm_freak: Yeah
07:18:32 <Tekmo> Oops
07:18:33 <Tekmo> I misread
07:18:40 <Tekmo> I thought you said `tee` instead of `tree`
07:18:56 <mm_freak> module tree =)
07:19:24 <Tekmo> mm_freak: Okay, so how can you have an FRP framework if you don't handle concurrent inputs?
07:19:51 <skypers> :t between
07:19:52 <lambdabot> Not in scope: `between'
07:20:01 <mm_freak> Tekmo: in netwire the FRP world is left when you start stepping your wire (which is like 'next' for Producer)
07:20:20 <mm_freak> that's where the connection happens between the wire and the real world
07:20:30 <jle`> if i don't export the standard library in Fay, how do i isolate and compile it separately?
07:20:43 <Tekmo> mm_freak: So you thread this wire through various event sources/sinks?
07:21:21 <mm_freak> Tekmo: in most uses cases for netwire you will use whatever event polling method you have available
07:21:32 <Tekmo> mm_freak: I think you should really combine `netwire` with `mvc`, though
07:21:36 <Tekmo> mm_freak: It's a match made in heaven
07:21:43 <mm_freak> Tekmo: sometimes all events are intrinsic to the wire and do not come from the real world, like for simulations
07:21:53 <mm_freak> Tekmo: when writing an SDL/GL game you would use pollEvent
07:21:54 <mm_freak> etc.
07:22:05 <Tekmo> mm_freak: Right, but that assumes you have a single event stream like SDL sets up for you
07:22:10 <Tekmo> mm_freak: A lot of times you don't have that
07:22:18 <Tekmo> mm_freak: That's where having `mvc` comes in handy
07:22:28 <mm_freak> i will combine netwire with pipes some day…  the glue to mvc would then be easy enough
07:22:41 <Tekmo> mm_freak: Well, you can just interface directly with `mvc`
07:23:02 <Tekmo> mm_freak: You don't have to convert to a `Pipe` intermediate
07:23:20 <Tekmo> mm_freak: `mvc` is just a structured way to combine `View`s and `Controller`s
07:23:33 <Tekmo> mm_freak: You can step these `View`s and `Controller`s manually if you don't want to go through the `Pipe` intermediate
07:24:43 <mm_freak> mvc's main strength is also a weakness:  it's concurrent, and for 90% of netwire's use cases this is bad, because it makes stepping at exactly 60 Hz a lot less clean/predictable
07:25:25 <mm_freak> netwire is written such that you can easily get frame rates of millions of FPS
07:25:40 <mm_freak> and still have predictable timings
07:26:09 <mm_freak> you have to realize that netwire is not a GUI abstraction…  in its essence it's a computation framework =)
07:26:37 <Tekmo> So what do you mean when you describe 60 Hz and also millions of FPS?
07:27:13 <skypers> doesn’t parsec already have something to parse identifiers?
07:27:13 <Yaniel> millions of FPS? :D
07:27:26 <skypers> something already like
07:27:27 <mm_freak> for a game you don't want every 30th frame to have a hickup…  for a high-precision simulation you don't want the display to freeze from time to time
07:27:42 <skypers> noneOf "\n\r ',@!;[]{}"
07:27:44 <skypers> and so on
07:27:56 <mm_freak> Tekmo: imagine a simulation that runs at six million FPS and displays every 100000th frame
07:28:21 <Tekmo> mm_freak: So usually what I do in this case is I have one input event that corresponds to the frame rate (i.e. it fires 60 times a second)
07:28:31 <Tekmo> mm_freak: When I detect that event I just flush the current frame
07:29:06 <Tekmo> mm_freak: It won't get blocked by other event streams
07:29:13 <Tekmo> mm_freak: For example, let's say that I also have a user input stream
07:29:32 <Tekmo> mm_freak: If I merge the two streams using the `Monoid` instance for `Controller` it will wait on both simultaneously and react to either one immediately
07:30:06 <mm_freak> Tekmo: i understand it…  if you need that you should just connect it to mvc yourself
07:30:16 <mm_freak> Tekmo: if your wire is sufficiently complicated that will cause hickups, simply because there is thread switching
07:30:23 <mm_freak> especially when you actually use multiple OS threads
07:30:26 <mm_freak> this is unacceptable
07:30:56 <Tekmo> mm_freak: Are you saying that netwire implements some sort of internal high-precision scheduler?
07:31:49 <mm_freak> Tekmo: not by itself, but yes, for some applications you would indeed do that
07:31:52 <Tekmo> mm_freak: Or I guess my more general question is: are you bypassing the threading runtime and using something else?
07:32:08 <mm_freak> Tekmo: no, it's simply not a concurrent abstraction by itself
07:32:13 <mm_freak> once again it's a computation framework
07:32:35 <Tekmo> mm_freak: So then how does netwire guarantee avoiding hiccups if it doesn't do any actual concurrency?
07:32:51 <ChongLi> Tekmo: you do that yourself with threads :)
07:33:37 <Tekmo> I think I'm missing a key concept here
07:34:22 <ChongLi> anything that blocks should run in its own thread
07:34:36 <ChongLi> put stuff into an MVar or IORef
07:34:59 <Tekmo> They already do, though
07:35:14 <Tekmo> Each `Controller` corresponds to a thread + an STM buffer of some sort
07:35:22 <ChongLi> perfect
07:35:35 <ChongLi> then just make wires out of those things and hook it all up
07:35:53 <Tekmo> But mm_freak was cautioning me that this approach is in danger of hiccups
07:37:12 <ChongLi> hmmm
07:41:08 <zcourts> How is the IO isolation achieved in Haskell? i.e. you can't use IO from a pure function (without unsafePerformIO). Is this something enforced by the compiler or is it something about how IO's type is defined and can it be achieved for your own type?
07:41:39 <Tekmo> zcourts: It's enforced by the type, not by the compiler
07:41:54 <ChongLi> and yes, you can achieve it with your own types
07:41:55 <Tekmo> zcourts: THey don't export any function (other than `unsafePerformIO`) that lets you unwrap the type
07:42:15 <Tekmo> zcourts: `IO` also does have some compiler integration, too
07:42:22 <Tekmo> zcourts: But the purity is enforced within the language
07:42:52 <geekosaur> btu you can do this yourself by exporting a type from a module without exporting any constructors or ways to extract values
07:42:57 <poph> How are we talking about it without a single word about seq?
07:43:11 <Tekmo> What does `seq` have to do with `IO`?
07:43:11 <geekosaur> (but you will need some kind of runMyType function)
07:43:18 <lingxiao> hey all, does anyone use Haskell-mode for emacs here?
07:43:38 <zcourts> Tekmo: I see, ok
07:44:06 <zcourts> geekosaur: Thanks, I'll play around with that and see what I come up with.
07:44:44 <geekosaur> there is actually a "framework" for this kind of type already provided; take a look at ST
07:45:00 <zcourts> geekosaur: What's ST?
07:45:45 <ChongLi> state-transformer
07:45:47 <Tekmo> zcourts: It's like a subset of `IO` where you can only manipulate memory references, and you can escape it as long as no references leak
07:46:10 <Tekmo> zcourts: It's basically a way to open up a temporary mutable window and then purify it without letting any mutability leak
07:46:49 <ChongLi> it's sort of based on the principle "if a tree falls in the woods and nobody's around to hear it" sort of thing
07:48:11 <zcourts> Tekmo: ChongLi: Gotcha, I roughly remember seeing it in the real work haskell book. I'll have a re-read of that section. Thanks again
07:48:18 <Tekmo> zcourts: You're welcome
07:49:39 <mm_freak> Tekmo: the key concept is that netwire is simply not a streaming/concurrency abstraction
07:49:53 <mm_freak> netwire gives you only one thing:  fast event-reactive computation
07:51:05 <mm_freak> Tekmo: reactive-banana would benefit from an mvc connection
07:51:14 <ChongLi> what's interesting about netwire is that as an abstraction it's reminiscent of physical circuits
07:51:16 <mm_freak> but then for reactive-banana it's not nearly as simple to do it
07:51:24 <mm_freak> ChongLi: indeed!
07:51:30 <Tekmo> mm_freak: Okay, then let me ask a different question.  `for` uses some sort of notion of `dtime` internally.  How is the wire made aware of time?  I don't see any time input for the `stepWire` function
07:51:37 <mm_freak> you can do physics simulations, etc.
07:51:56 <mm_freak> Tekmo: see stepSession
07:52:05 <mm_freak> and see for example clockSession
07:52:11 <mm_freak> (or clockSession_)
07:52:31 <mm_freak> you would use something like that for a game…  for a simulation you would use counterSession
07:52:32 <Tekmo> mm_freak: So it's passed in through the `s` parameter?
07:52:36 <mm_freak> yes
07:52:39 <Tekmo> Got it
07:52:58 <ChongLi> by the way, I was checking out webwire to see an example of netwire and I got really confused until I found out it's based on a really old version
07:52:58 <Tekmo> Okay, that clears several things up.  I think I get this better now
07:53:23 <mm_freak> ChongLi: webwire was an old proof of concept that you can use the general wire abstraction to write web applications
07:54:09 <ChongLi> yeah but now the actual Wire type is very different
07:54:25 <mm_freak> ChongLi: it's not really much different
07:54:39 <mm_freak> except that Double become 's'
07:55:06 <jle`> why is the Left/inhibition value required to be a monoid?
07:55:16 <jle`> is it mappended during accumulation over time?
07:55:21 <mm_freak> jle`: because of the Alternative/ArrowPlus semantics
07:55:34 <jle`> mm_freak: hm
07:55:37 <Tekmo> mm_freak: So if I understand you correctly, you would consider something like `mvc` to only be FRP if it were to layer some sort of higher-level declarative interface on top
07:55:38 <mm_freak> inhibit x <|> inhibit y = inhibit (x <> y)
07:55:46 <jle`> ah
07:55:51 <mm_freak> jle`: note that s is a monoid for a different reason
07:55:55 <jle`> interesting
07:56:22 <sqrt2> what does runhaskell/runghc do and what does it not do? for my number crunching tasks, runhaskell is often significantly slower than the compiled executable
07:56:30 <mm_freak> Tekmo: mvc is simply not FRP, but you can use it as a glue between an FRP abstraction and the real world
07:56:49 <mm_freak> sqrt2: it interprets, it doesn't compile =)
07:56:50 <ChongLi> Tekmo: in order to be FRP, something has to present a model of functions of time
07:56:56 <Tekmo> mm_freak: Right, I'm just brainstorming how to implement something like `for` using `pipes`
07:56:59 <ChongLi> and time-varying values
07:57:19 <mm_freak> Tekmo: start with semantics
07:57:21 <ChongLi> events and behaviours
07:57:22 <sqrt2> mm_freak: interprets source, or interprets bytecode it generates first?
07:57:42 <Tekmo> mm_freak: That's why I'm studying the implementation of `for`
07:57:45 <mm_freak> Tekmo: whenever you write an FRP implementation you should start with semantics, and you should probably read the original paper
07:57:58 <Tekmo> mm_freak: I read it already, but I didn't understand the motivation when I first read it
07:58:15 <mm_freak> Tekmo: note that FRP does not mean that you get time
07:58:30 <mm_freak> even in netwire time is an addon
07:58:37 <mm_freak> if s = (), you can't use 'for'
07:58:43 <Tekmo> Right, I get that
07:59:17 <mm_freak> in traditional FRP 'for' would be an event
07:59:30 <mm_freak> for :: Time -> Event ()
07:59:45 <osa1> mm_freak: what original paper?
07:59:45 <mm_freak> you would rather call that event 'at'
08:00:05 <mm_freak> osa1: http://conal.net/papers/icfp97/
08:00:38 <osa1> thanks
08:00:39 <mm_freak> Tekmo: Event is a (non-applicative!) functor
08:01:11 <Tekmo> Yes, it corresponds roughly to my `Controller` type.  A discrete stream of events
08:01:26 <mm_freak> pretty much
08:01:38 <Tekmo> Actually, I found a way to make it applicative, but I didn't like it that much
08:01:42 <ChongLi> do not taint your application with discrete time!
08:01:46 <mm_freak> the semantics is:  type Event a = [(Time, a)]
08:02:11 <Tekmo> I don't like that semantics
08:02:22 <Tekmo> It seems like a really crude representation
08:03:27 <osa1> what's wrong with this netwire code http://lpaste.net/99072
08:03:55 <mm_freak> Tekmo: it's just semantics
08:03:56 <Tekmo> I also don't like to think in terms of semantics in general
08:04:07 <Tekmo> I prefer to think in terms of interfaces, preferably category theory interfaces
08:04:16 <Tekmo> Semantics are just an implementation detail
08:04:26 <Tinned_Tuna> Heya, I'm having issues installing haskeline/terminfo http://lpaste.net/1234289737338978304
08:04:33 <mm_freak> osa1: use clockSession_
08:04:48 <mm_freak> Tekmo: no, semantics are semantics =)
08:05:02 <osa1> mm_freak: still getting "no show instance for e0 ..." error
08:05:04 <mm_freak> at the lowest level is implementation, then comes abstraction, then comes semantics
08:05:22 <Tekmo> Then above that are interfaces
08:05:24 <mm_freak> Tekmo: implementation (netwire), abstraction (AFRP), semantics (FRP)
08:05:35 <Tekmo> Like Monoid/Category/Functor/etc.
08:05:39 <mm_freak> you don't /use/ semantics
08:05:40 <Tekmo> Those are what I consider the real meat
08:05:47 <Tinned_Tuna> I'm not sure where to look for "console.log", or how to interpret the ExitFailure statuses...
08:05:50 <Tekmo> Right, which is why I consider them an uninteresting detail
08:05:51 <mm_freak> you just use them to prove that your implementation/interface is correct
08:05:57 <biscarch> Are there any Haskell Solr libraries? I don't see any on Hackage
08:05:58 <simpson> ^^
08:06:15 <mm_freak> Tekmo: for example imagine an event:  changes :: Behavior a -> Event a
08:06:22 <mm_freak> this event occurs when the behavior changes
08:06:31 <mm_freak> this is invalid in FRP
08:06:39 <Tinned_Tuna> biscarch. see chatter, it's not solr, but it provides a set of primitives which you can build a local full-text search on
08:06:46 <mm_freak> osa1: you need to write a type signature for your wire
08:06:46 <jle`> is there a fay type for a POJO?
08:07:01 <Tinned_Tuna> biscarch: currently, it's not got feature parity with lucene or solr, but it's a start.
08:07:04 <lemao> Could someone recommend a good decent priorityqueue in haskell?
08:07:24 <osa1> mm_freak: can you give me an example? I don't understand all that parameters in Wire type
08:07:29 <Tekmo> mm_freak: Let me give an example: STM
08:07:41 <Tekmo> mm_freak: I have no clue what the semantics of STM are, and I don't need one
08:07:52 <mm_freak> osa1: time :: SimpleWire a NominalDiffTime
08:08:14 <Tekmo> mm_freak: All I need to know is that `STM` is a `MonadPlus` that provides some primitive operations and I'm done
08:08:16 <mm_freak> osa1: the problem is that it doesn't know which 'e' you want
08:08:17 <jmcarthur> interfaces are just abstractions over semantics
08:08:24 <biscarch> Tinned_Tuna: Thanks. I'll look into it. Currently I'm trying to query Riak though, and Riak uses Solr.
08:08:38 <Tekmo> mm_freak: All I care about is whether `STM` obeys the relevant `MonadPlus` laws
08:08:52 <mm_freak> Tekmo: i'm not aware of a simple categorical description of FRP
08:09:04 <mm_freak> Tekmo: although netwire itself uses a semantics based on topological spaces
08:09:05 <Tekmo> mm_freak: That's what I want: a categorical description of FRP
08:09:28 <jmcarthur> i think the semantic model drives various type classes in a pretty straightforward way
08:09:52 <jmcarthur> behaviors are functions of time, so they are all the things functions of time can be
08:10:03 <Tekmo> jmcarthur: Right, but I don't need to know that
08:10:11 <jmcarthur> events are collections of occurrences (time value pairs), so they are all the things collections of time value pairs can be
08:10:36 <osa1> is there a currently working Netwire tutorial?
08:10:50 <Tekmo> jmcarthur: As a user, telling me that your Behavior is like a [(Time, a)] is not helpful, because I can't actually manipulate it as if it were [(Time, a)]
08:10:53 <jmcarthur> well, you don't need to know it if you are abstracting over semantics, but there comes a point where you can't always do that
08:11:10 <jmcarthur> otherwise you would never use any concrete instances of all those polymorphic functions you're defining
08:11:24 <Tekmo> jmcarthur: Explaining the behavior in terms of type classes is useful because I actually use the type classes to interface with it
08:11:41 <mm_freak> Tekmo: also you're ignoring the semantics of STM simply because you don't think of them too much anymore
08:11:42 <jmcarthur> there are many other functions provided to you other than Functor/Applicative/Monad
08:11:48 <Tekmo> mm_freak: That might be true :)
08:11:52 <mm_freak> Tekmo: but you do need to know how a TMVar works, don't you?
08:12:04 <mm_freak> the interaction between takeTMVar and putTMVar is semantics
08:12:19 <mm_freak> something the purely categorical description doesn't give you
08:12:30 <Tekmo> mm_freak: Well, just because there is not a categorical semantics doesn't mean there can't be one
08:12:35 <Tekmo> mm_freak: However, I'll still roughly concede that point
08:13:27 <Tekmo> mm_freak: I will refine my argument to be: "I wish more of the semantics would be moved into categorical abstractions"
08:13:38 <Tekmo> mm_freak: ... and less out of ad-hoc abstractions
08:13:49 <jmcarthur> Tekmo: would you disagree with my claim that interfaces are just abstractions over semantics?
08:13:55 <mm_freak> Tekmo: objects and morphisms are opaque in category theory…  this is often desirable, and i too use categorical abstractions (even netwire is fully categorical)
08:14:09 <mm_freak> Tekmo: but for semantics you sometimes need to look through the shell of the objects =)
08:14:36 <Tekmo> jmcarthur: I think that sounds right
08:14:40 <lingxiao> anyone use emacs here and know what good emacs channel is for beginners?
08:14:48 <lingxiao> I tried #emacs, but no one seems to be there
08:15:25 <Tekmo> jmcarthur: Regarding your point about having to instantiate it with a concrete instance, the point of categorical semantics is precisely to make it possible to instantiate it with something in a completely different domain
08:15:32 <mm_freak> Tekmo: and again, semantics is not API…  the API should be fully categorical in my view of the world…  the semantics is there to help you (as the abstraction developer) to figure out what is correct and what is not
08:15:39 <mm_freak> additional laws beyond the categorical ones
08:15:41 <Tinned_Tuna> biscarch: https://github.com/janrain/riak-haskell-client ?
08:15:55 <mm_freak> Tekmo: category theory does not help you figure out that 'changes' does not exist in FRP
08:16:11 <jmcarthur> Tekmo: that's true, but my only point is that the categorical view only helps for a (potentially large) subset of your code. you still have to "drop down" to actual semantics at some point
08:16:18 <Tekmo> jmcarthur: Yeah, I agree with that
08:16:27 <Tekmo> jmcarthur: I guess I should say that I like to "maximize" the categorical view as much as possible
08:16:58 <mm_freak> Tekmo: i can implement 'changes' in netwire…  the implementation is possible and conforms to the categorical model of wires
08:17:05 <mm_freak> FRP forbids it, so i don't
08:17:34 <mm_freak> and as you see Wire is a family of categories and you can apply your entire categorical toolset to it
08:17:43 <mm_freak> including functors, natural transformations, etc.
08:17:56 <Tekmo> I think another thing that bothered me about FRP was that the simple semantics was not the real semantics that libraries used
08:18:05 <Tekmo> I would really like a semantics that was practial and simple
08:18:20 <mm_freak> Tekmo: there is only one semantics…  semantics is a bunch of equations
08:18:49 <Tekmo> I guess what I mean is that the semantics, when roughly translated into Haskell, didn't match the underlying implementation
08:18:56 <mm_freak> Tekmo: in the case of FRP there is no implementation that captures exactly the allowed constructions and nothing more and is efficient at the same time
08:19:03 <mm_freak> that's why semantics is so important for FRP
08:19:21 <mm_freak> for stream processing as in pipes, the categorical model is sufficient as your semantics
08:19:31 <jle`> is there any way to turn an Element into a JQuery in fay-jquery?  al i want to do is get an attribute
08:19:39 <Tekmo> mm_freak: I'm not totally convinced there is no such implementation
08:20:03 <mm_freak> Tekmo: such an implementation would use types that are isomorphic to the following two (roughly):
08:20:05 <Tekmo> mm_freak: Or maybe I should say that perhaps FRP needs to first lay some more groundwork first
08:20:10 <mm_freak> type Behavior a = Time -> a
08:20:17 <mm_freak> type Event a = [(Time, a)]
08:20:23 <mm_freak> where Time is some approximation of ℝ
08:20:35 <biscarch> Tinned_Tuna: Yea, I'm using that for k/v queries but Riak 2.0 adds Solr to replace the old Riak Search. Hence the need for solr queries.
08:20:42 <Tekmo> mm_freak: Rather than saying that the semantics are a pretend [(Time, a)], take some time to make the real implementation more elegant and beautiful
08:21:12 <mm_freak> Tekmo: the semantics /requires/ pretending that Event is just a list of timed occurrences
08:21:26 <mm_freak> Event can be a Producer or anything
08:21:27 <Tinned_Tuna> biscarch: ahh, I'm not all that familiar with Riak is all
08:21:47 <mm_freak> but the interface must not expose a function that would break this model
08:22:02 <mm_freak> and Event is often not the problem
08:22:06 <Tekmo> mm_freak: Well, the semantics that Conal expounded require that, but what if I don't like his semantics?
08:22:17 <mm_freak> Tekmo: then you don't like FRP
08:22:29 <avantimedev> hi all, i would like to convert an algebraic data type to double using :: Double, more here http://lpaste.net/99073, any suggestions?
08:23:06 <jle`> oh, it's `select`
08:23:38 <Tekmo> avantimedev: There's a better way to do this using a `case` statement
08:24:01 <jle`> or even a pattern match on the function arguments
08:24:11 <avantimedev> Tekmo: really? I want to pass it to a function, without modifying the function using case etc
08:24:17 <jle`> freq Anually = 1
08:24:24 <jle`> freq SemiAnnually = 2
08:24:29 <biscarch> Tinned_Tuna: I hear ya. Unfortunately it doesn't look like there's been a ton of dev on that riak lib since it changed maintainers anyway, so I don't have high hopes for compatibility to come out of the woodwork.
08:24:33 <jle`> freq Quarterly = 4
08:24:34 <Tekmo> avantimedev: Let me write it up for you
08:24:35 <jle`> etc.
08:24:39 <jle`> freq (Other d) = d
08:24:53 * hackagebot esqueleto 1.3.4.4 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.4.4 (MichaelSnoyman)
08:25:11 <biscarch> Tinned_Tuna: Just going to have to write my own or use a diff language for that part of my api.
08:25:14 <mm_freak> Tekmo: it's like if you don't like associativity, you don't like monoids =)
08:25:41 <mm_freak> and please don't do what everybody else seems to do:  don't invent "my version of FRP" =)
08:25:48 <Tekmo> avantimedev: Here: http://lpaste.net/99074
08:25:57 <mm_freak> because i don't invent my version of monoids and sell them to you as monoids =)
08:26:01 <Tekmo> mm_freak: Yes, but I like associativity
08:26:23 <mm_freak> Tekmo: that's not the point
08:26:35 <Tekmo> mm_freak: I know.  I get your point
08:26:41 <Tekmo> mm_freak: I've concluded that I don't like FRP :)
08:27:00 <mm_freak> Tekmo: i strongly recommend watching stephen's presentation
08:27:20 <mm_freak> humans often don't like things until they understand them =)
08:27:25 <avantimedev> Tekmo, thanks, that's an alternative to the table for sure. But how is it done, when I want Frequency to be converted using :: Double, can I define some functionality for any type class to support this?
08:27:30 <Tekmo> mm_freak: Alright, I will watch it
08:27:58 <geekosaur> :: Double does no conversion
08:28:05 <geekosaur> :: Double is a *declaration*
08:28:46 <geekosaur> this is not merely semantics; it is a type hint to the compiler, it does not cause the compiler to insert conversion code
08:29:33 <geekosaur> the way you convert is by using a function that does conversion
08:30:18 <geekosaur> (there is a case where it *looks like* the compiler is doing conversion: with numeric literals ONLY, they are treated as function calls.)
08:30:22 <Tekmo> avantimedev: I would also highly recommend avoiding using type classes to do automatic conversion.  It's very unidiomatic
08:31:15 <geekosaur> (and, as it turns out, you *can* abuse that... at a rather high price in terms of code comprensibility AND the possibility the compiler will stab you in the back for it)
08:31:19 <avantimedev> Tekmo, alright, I think I have to modify the function then
08:42:39 <jle`> is there any way to write ffi functions in pointful forms?
08:43:23 <jle`> (for fay)
08:43:31 <jle`> instead of f = ffi "%1,%2,%3"...
08:43:37 <jle`> f arg1 arg2 arg3 = ffi ...
08:46:52 <identity> When using cabal repl, how do I go about making sure that modules loaded by the main module are accessible to me in the repl?
08:47:12 <identity> because I see very little advantage if I don't have access to the whole namespace, so to speak
08:49:56 * hackagebot hit 0.5.3 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.5.3 (VincentHanquez)
08:54:57 * hackagebot stm-conduit 2.2.1.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.2.1.1 (ClarkGaebel)
08:59:29 <gauthier> given two predicates (calling them isEnter and isExit, both of type a -> Bool) how could I do something like this: [a] -> (a -> Bool) -> (a -> Bool) -> [[a]], I'm trying to get small windows of 'a', windows being delimited by my two predicates
09:04:20 <identity> gauthier: groupBy?
09:05:01 <identity> gauthier: Are they mutually exclusive? E.g. if it isn't isEnter then it's isExit?
09:05:37 <identity> > let isEven x = rem x 2 == 0 in groupBy isEven [1,4,6,2,4,6,8,3,4,6,7,9,11]
09:05:39 <lambdabot>  Couldn't match type `GHC.Types.Bool' with `a0 -> GHC.Types.Bool'
09:05:40 <lambdabot>  Expected type: a0 -> a0 -> GHC.Types.Bool
09:05:40 <lambdabot>    Actual type: a0 -> GHC.Types.Bool
09:05:46 <identity> :t groupBy
09:05:47 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
09:06:13 <identity> ah.
09:07:21 <identity> > let isEven x = rem x 2 == 0 in groupBy (\a b -> isEven a && isEven b) [1,4,6,2,4,6,8,3,4,6,7,9,11]
09:07:23 <lambdabot>  [[1],[4,6,2,4,6,8],[3],[4,6],[7],[9],[11]]
09:07:30 <identity> huh.
09:07:59 <identity> > let isEven x = rem x 2 == 0 in groupBy (\a b -> (isEven a && isEven b) || not (isEven a && isEven b)) [1,4,6,2,4,6,8,3,4,6,7,9,11]
09:08:00 <lambdabot>  [[1,4,6,2,4,6,8,3,4,6,7,9,11]]
09:08:04 <identity> derp
09:08:21 <identity> > let isEven x = rem x 2 == 0 in groupBy (\a b -> (isEven a && isEven b) || not (isEven a || isEven b)) [1,4,6,2,4,6,8,3,4,6,7,9,11]
09:08:22 <lambdabot>  [[1],[4,6,2,4,6,8],[3],[4,6],[7,9,11]]
09:08:30 <identity> there we go, thank you demorgan
09:10:06 <Cale> > [x : takeWhile (not . isSpace) xs | (x:xs) <- tails "Hello World! ", isUpper x]
09:10:07 <lambdabot>  ["Hello","World!"]
09:10:23 <Cale> ^^ perhaps something along those lines?
09:10:50 <identity> that looks like that could work as well
09:11:14 <Cale> That kills the ending delimiters though
09:11:19 <Cale> We need takeUntil
09:12:13 <rawtass> I have a case expression with Just a -> a, Nothing -> "bar". I need "a" to be String for this to work. Is this possible?
09:12:31 <identity> rawtass: hmm?
09:12:39 <Cale> @let takeUntil p [] = []; takeUntil p (x:xs) | p x = x : takeUntil p xs | otherwise = [x]
09:12:40 <identity> but that's basically maybe
09:12:41 <lambdabot>  Defined.
09:12:46 <identity> :t maybe
09:12:47 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:13:00 <identity> :maybe "bar" id (Just "a")
09:13:09 <identity> > maybe "bar" id (Just "a")
09:13:10 <lambdabot>  "a"
09:13:12 <Cale> er, that's a terrible name for the function I just wrote :P
09:13:16 <identity> > maybe "bar" id Nothing
09:13:17 <lambdabot>  "bar"
09:13:21 <xxx-man> Cale: hi
09:13:25 <Cale> @undefine
09:13:26 <lambdabot> Undefined.
09:13:41 <rawtass> foo f = "testing: " ++ var where var = case f of Just a -> a; Nothing -> ""
09:13:43 <Cale> @let takeUntil p [] = []; takeUntil p (x:xs) | not (p x) = x : takeUntil p xs | otherwise = [x]
09:13:44 <lambdabot>  Defined.
09:13:49 <Cale> > [x : takeUntil isSpace xs | (x:xs) <- tails "Hello World! ", isUpper x]
09:13:51 <lambdabot>  ["Hello ","World! "]
09:13:58 <rawtass> identity: did that make it cleared what I am trying to do?
09:14:12 <shiona> :t fromMaybe
09:14:14 <lambdabot> a -> Maybe a -> a
09:14:14 <identity> rawtass: yes, it looks like you need maybe
09:14:34 <shiona> > fromMaybe "bar" (Just "a")
09:14:36 <lambdabot>  "a"
09:14:39 <gauthier> identity: isEnter and isExit are mutually exclusive
09:15:05 <identity> gauthier: Cale's solution is probably the most elegant
09:15:14 <Cale> gauthier: ^^ see my solution there with takeUntil and that list comprehension. I used isUpper as isEnter and isSpace as isExit
09:15:26 <Cale> Is that the function you're looking for?
09:15:54 <gauthier> for some context, I'm parsing SAXEvent (interested in start element / end element pairs)
09:16:08 <Cale> If you want to chop off the things which satisfied isEnter and isExit, that's actually easier
09:16:13 <gauthier> great: thanks to both :)
09:16:18 <Cale> > [takeWhile isSpace xs | (x:xs) <- tails "Hello World! ", isUpper x]
09:16:19 <lambdabot>  ["",""]
09:16:22 <Cale> oops!
09:16:29 <Cale> > [takeWhile (not . isSpace) xs | (x:xs) <- tails "Hello World! ", isUpper x]
09:16:30 <lambdabot>  ["ello","orld!"]
09:16:34 <Cale> there we are :)
09:24:43 <the_berserker> @pl \x y -> x y y
09:24:43 <lambdabot> join
09:24:46 <jle`> has anyone ever gotten "unable to resolve qualified names fii" on fay?
09:26:07 <geekosaur> is that a typo?
09:26:15 <the_berserker> @pl \a b c -> (a b) (b c)
09:26:16 <lambdabot> ((.) =<<)
09:26:27 <the_berserker> @unpl (>>=)
09:26:28 <lambdabot> (>>=)
09:26:52 <the_berserker> @pl \a b c -> a c (b c)
09:26:52 <lambdabot> ap
09:27:07 <the_berserker> @pl \x y -> y
09:27:08 <lambdabot> const id
09:29:30 <the_berserker> Is there a typed lambda calculus that accepts non-strongly normalizing terms?
09:30:29 <the_berserker> > putStrLn "Hello world!"
09:30:30 <lambdabot>  <IO ()>
09:30:57 <hpc> the_berserker: none are listed on wikipedia, afaict
09:31:02 <the_berserker> @unpl ap ap
09:31:02 <lambdabot> (\ e d -> (e >>= \ a -> return ((\ j k -> j >>= \ h -> k >>= \ g -> return (h g)) d a)) d)
09:32:02 <jle`>  geekosaur: sorry, meant ffi
09:32:10 <hpc> the_berserker: but you can take any strongly normalizing calculus and postulate fix :: (a -> a) -> a to get what you want
09:32:13 <jle`> it's referring to the method
09:32:35 <jle`> i import FFI
09:33:18 <the_berserker> Why did I get a stack overflow in Python trying to use fix as in the definition fix f = f (fix f) ?
09:33:55 <jle`> the_berserker: do you expect for the recursion to end
09:33:56 <jle`> ?
09:34:16 <the_berserker> jle`: Ah, Python uses eager evaluation.
09:34:17 <magneticduck> the_berserker: uh, yeah, that would make a stack overflow
09:34:22 <magneticduck> oh
09:34:24 <magneticduck> I see
09:34:37 <magneticduck> (what you intended, I think)
09:35:14 <jle`> to be fair, fix usually stack overflows in haskell too
09:35:32 <jle`> well, not stack overflow
09:35:47 <hpc> that particular fix can have problems sometimes
09:36:04 <hpc> fix f = let x = f x in x -- knot tying reduces memory use sometimes
09:39:37 <Fuuzetsu> Is there a Semigroup typeclass somewhere?
09:40:32 <supki> Fuuzetsu: in semigroups
09:41:55 <Fuuzetsu> thanks
09:43:09 <jle`> heh
09:50:32 <jrmithdobbs> can ghc be safely built with -j ?
09:51:14 <td123> jrmithdobbs: I'm not sure, iirc there is a bug report for 7.10 to make -j safe
09:55:26 <Cale> jrmithdobbs: I know I've used make -j4 to build GHC successfully before.
09:56:02 <Cale> Probably if it fails somehow you could just continue from where you left off anyway
09:57:14 <jrmithdobbs> worth a shot!
09:58:24 <quchen> I regularly build it with -j9.
09:58:36 <jrmithdobbs> ya trying -j8 right now
09:59:58 <petrus> 'exit
10:01:29 <td123> here is the bug report I was referring to, https://ghc.haskell.org/trac/ghc/ticket/8102
10:01:40 <td123> I guess building HEAD is broken, but not the releases
10:02:20 <chrisw> I just started to learn about monads a few days ago and tried my hand at the state monad in Project Euler problem #14. Compared to my Java solution, I believe it uses around 4x memory and time. Could anyone help me identify the cause of this? http://lpaste.net/99075
10:02:53 <jrmithdobbs> using integer-simple anyhow
10:03:17 <dennda> Hola! I am writing my first haskell program to teach myself the language, and the program has a core piece that I think could be nicely parallelized, but I think I need some guidance as to how I should do that.
10:03:55 <quchen> chrisw: Have you profiled your program? Do you know where the memory is used?
10:04:26 <dennda> I basically have a function that takes a 2D coordinate and returns a color, and I run that over a lot of coordinates via map. I guess I should split the coordinates into sets of equal sizes and run each set on a core. How would I best do that?
10:04:27 <chrisw> quchen, Yes I have, and if I remember correctly, IntMap was taking up 400m or something
10:04:34 <Cale> dennda: The cheapest thing to try is typically to replace something like map with parMap from Control.Parallel.Strategies
10:04:39 <dennda> The 'parallelism in haskell' chapter from real world haskell isn't all that easy to understand
10:04:58 <chrisw> quchen, my Java solution only uses around 100m IIRC
10:05:00 <Cale> http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html
10:05:05 <bennofs> @google Concurrent and Parallel programming in Haskell
10:05:06 <lambdabot> http://chimera.labs.oreilly.com/books/1230000000929
10:05:07 <lambdabot> Title: Parallel and Concurrent Programming in Haskell
10:05:09 <dennda> Cale: Right, I was thinking about that, but then that book started talking about WHNF and I got a bit lost
10:05:11 <bennofs> chrisw: try that
10:05:20 <bennofs> oh sorry, I meant dennda
10:05:46 <quchen> 100m sounds like a *lot* for this problem, chrisw.
10:06:05 <dennda> Oh nice, I hadn't seen that before bennofs
10:06:10 <dennda> Cale: Let me check that out
10:06:22 <Cale> dennda: Okay, to explain weak head-normal form, it's just the following: A term is in WHNF if it's a lambda, or if it's a constructor applied to some arguments.
10:06:44 <Cale> (which aren't themselves required to be in WHNF)
10:06:52 <quchen> chrisw: It looks like you're inserting each length of the Collatz sequence into a Map, which means you do a lot of modifications on that Map; in addition to that, most of the Map will be unevaluated thunks until you call the maximum function on it.
10:07:14 <dennda> Cale: What does that get me?
10:07:24 <chrisw> quchen, ah, can I make it strict?
10:07:52 <Cale> dennda: If a term is in WHNF, then you can readily pattern match on it (or if it's a function, apply it to some value without reducing it any further)
10:08:42 <Cale> dennda: This is the smallest meaningful amount of evaluation that GHC will let you do to something.
10:08:48 <chrisw> quchen, I don't think I can avoid the modifications on the Map because that's precisely what I'm using to remember past calculations of Collatz lengths
10:08:51 <Cale> (reducing it to WHNF)
10:10:22 <Cale> dennda: However, you may want to do more. You could use parMap rdeepseq f xs  to, in parallel, fully evaluate the elements of the resulting list.
10:11:42 <Cale> Depending on what f is, this might or might not be equivalent to parMap rseq f xs (likely not if f is producing a complicated data structure)
10:11:42 <quchen> chrisw: Try the annotated version: http://lpaste.net/99075
10:12:14 <quchen> Maaybe this helps a bit.
10:12:45 <chrisw> quchen, 5.24 -> 4.46 seconds
10:12:52 <Cale> If you have trouble with granularity, you might want to try switching to using parListChunk (along with ordinary map)
10:13:06 <quchen> chrisw: How about space usage?
10:13:23 <chrisw> quchen, let me check
10:13:28 <Cale> Something like:  withStrategy (parListChunk 100 rseq) (map f xs)
10:14:05 <dennda> Cale: This is the line I want to parallelize: map (colorForPixel s) pixelCoords -- Where pixelCoords::[(Float,Float)] with N elements (N pretty big), that I want to split into N/numCores lists to apply colorForPixel to in parallel. So I guess I have to find the right strategy first?
10:14:06 <Cale> http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html
10:14:25 <chrisw> quchen, +RTS -s says 322 MB total memory in use, 46.4 %GC
10:14:38 <Cale> What type does colorForPixel produce?
10:15:20 <dennda> Cale: a Color, where type Color = [Int] with three elements (r,g,b)
10:15:56 <Cale> ah, okay, so probably use rwhnf, but that's kind of a terrible data structure, and you might want to replace those lists with something more appropriate
10:16:11 <Cale> er, rdeepseq, I meant to say :P
10:16:26 <dennda> Cale: Yeah I figured that would not be the best data structure. I was going to revisit that at some point
10:16:31 <Cale> WHNF won't be enough, because that only tells you if the list is empty or not
10:16:41 <Cale> If you used something like
10:16:57 <dennda> Cale: I'm not quite sure I understand why the resulting type of the function is of importance when it comes to choosing the strategy
10:17:16 <Cale> Because the strategy is going to be forcing the evaluation of values of that type
10:17:28 <Cale> and it will do this by traversing them somehow
10:17:57 <Cale> So it has to know about their structure (unless you're using rseq which is available for every type, but only does a minimal amount of evaluation)
10:18:15 <quchen> chrisw: For what it's worth, you can solve the problem by using only laziness without modifying state. Often when you don't modify (only add) new data to a structure, laziness can replace state.
10:18:20 <Cale> Or r0 I guess, but it does no evaluation, which isn't what you're likely to want
10:18:45 <quchen> chrisw: This is how I did it back when I liked Project Euler: http://lpaste.net/99077
10:19:22 <dennda> Cale: I think I need to read that book. :)
10:19:33 <chrisw> quchen, oh, you're suggesting that I take advantage of the "memoization" of calls to collatz?
10:19:39 <quchen> Yes.
10:20:18 <identity> What is the best way to deal with IO computations that can throw exceptions inside ErrorT? I thought it handled stuff like that for you, but it seems I need to catch them inside the ErrorT computation and throwError?
10:20:45 <quchen> The one I posted needs around 60 megs. You can possibly tune it a lot more, but I stopped optimizing the non-bottleneck problems :-)
10:20:55 <chrisw> quchen, I'll give that a try. BTW Your solution took 4.45s, which is pretty good
10:21:03 <dennda> Cale: I suppose passing -threaded is obligatory when using that module?
10:21:09 <Cale> dennda: But try applying   withStrategy (parListChunk 10 rdeepseq)   to the result of your map
10:21:38 <Cale> dennda: yeah, and you'll also want to run the program with +RTS -N4 or something to tell it to start more capabilities to evaluate expressions on
10:22:11 <dennda> Cale: 10 is the chunk size I suppose?
10:22:23 <Cale> yeah
10:22:31 <Cale> You'll definitely want to play with that number
10:22:53 <dennda> hm. it seems like it would be smart to use a number that depends on the number of cores?
10:23:22 <Cale> yeah, maybe something like the list length divided by the number of cores, but computing the list length in general is going to be a bad idea :)
10:23:32 <Cale> (but if you know it ahead of time)
10:23:40 <dennda> Cale: Why? I do know it ahead of time.
10:24:34 <Cale> Well, yeah, in that case, you can base it off of that. Computing the length of a list in general is O(n)
10:24:52 <Cale> So, if you were doing that just to find out how to parallelise, it might be a waste of time
10:25:07 <Cale> But if you *know* that length, then that's good
10:25:39 <dennda> I think the complexity of colorForPixel thing would outweigh computing the length of the list anyway
10:25:51 <Cale> Quite possibly!
10:26:17 <Cale> (But computing the length of lists is usually a bad thing, and you want to avoid it)
10:26:43 <dennda> Cale: So unless there's no magic way to get the number of cores in there to determine the chunksize, it seems that ideally a binary would be optimized depending on the CPU used to run it?
10:26:55 <Cale> getNumCapabilities :: IO Int
10:26:58 <Cale> setNumCapabilities :: Int -> IO ()
10:27:08 <Cale> From Control.Concurrent
10:27:20 <dennda> ah
10:27:26 <Cale> Determining what number of capabilities to set is another thing though
10:28:13 <Cale> But I've found that it's not so bad just to set a moderate chunk size in general
10:28:31 <Cale> It uses work-stealing queues
10:29:23 <robstewartuk> It'd be nice to have a cabal property "contributors", to list contributors to a package codebase who are neither A) the original author or B) the current maintainer http://www.haskell.org/cabal/users-guide/developing-packages.html#package-properties
10:29:52 <Cale> This kind of parallelism isn't usually *the best* in terms of performance, but it's really easy to try, usually without even restructuring your program.
10:29:53 <robstewartuk> E.g. people who have contributed small code chunks to small corners of a library.
10:30:24 <robstewartuk> Is there a middle ground property?
10:31:18 <Cale> robstewartuk: I've seen people set Author fields with multiple authors.
10:32:29 <dennda> Cale: I'm not seeing much of a difference in performance. I guess I should be profiling this.
10:34:23 <monochrom> "Author: Bourbaki"
10:34:54 <mm_freak> cake is gone!!!!!!!111
10:34:56 <mm_freak> > cake
10:34:57 <lambdabot>  Not in scope: `cake'
10:34:57 <lambdabot>  Perhaps you meant one of these:
10:34:57 <lambdabot>    `take' (imported from Data.List),
10:34:57 <lambdabot>    `Seq.take' (imported from Data.Sequence),
10:34:57 <lambdabot>    `BSLC.take' (imported from Data.ByteString.Lazy.Char8)
10:34:57 <mm_freak> =(
10:35:20 <mm_freak> every bot needs an easter-egg =/
10:35:31 <lingxiao> does anyone use emacs haskell-mode, and know how to turn off the syntax highlighting function?
10:36:48 <Cale> dennda: Are your CPUs lighting up at least?
10:37:29 <Cale> dennda: If you're only seeing 100% CPU usage (one core), then we know something is wrong :)
10:39:41 <FireFly> @let cake = cake
10:39:43 <lambdabot>  Defined.
10:40:09 * hackagebot concurrent-state 0.5.1.4 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.5.1.4 (JoelTaylor)
10:40:10 <Cale> wow, such cake, much recursion, many layer
10:40:12 <Testeree> when i ran ghc-pkg check i got a scary list of *haddock-html file-doesn't exist* warnings. is there any wayt to fix it?
10:41:14 <Cale> Testeree: Make sure that Haddock is properly installed and reinstall things starting with those packages onward down the dependency chains.
10:41:26 <Cale> (but it might not be worth worrying about)
10:41:42 <Testeree> http://lpaste.net/99078
10:41:43 <Anpheus_> I have a problem where I would like to define a type family in terms of a pair of types (a, b) which will then only ever be used in relation to each other in the typeclass. Is this easier with fundeps or type families, or what should I use?
10:42:03 <FireFly> wow, such cale, much meme, many line
10:42:06 <jrmithdobbs> Testeree: if it's stuff you've actually genuinely deleted and it annoys you the "future" answer is pretty much: whack ~/.cabal and your cobal package db, renistall ghc/platform, immediately install cabal 1.18  and remember to use sandbox for everything forever
10:42:07 <Cale> Testeree: it just means that the documentation wasn't installed
10:42:07 <Anpheus_> The two types get used in different places in the code and there are Reasons(tm) why they can't just be unified
10:42:45 <jrmithdobbs> erm and your ghc-pkg*
10:42:50 <Testeree> is it possible to install docs post installation of the pkg?
10:42:56 <monochrom> no
10:42:56 <Cale> FireFly: [[flattery intensifies]]
10:43:37 <Cale> You don't generally have to delete ~/.cabal
10:43:53 <monochrom> I think you should ignore the warning. it is not like you will be stuck with it forever. because next time you upgrade ghc, you have to rebuild everything anyway
10:43:54 <Cale> It's ~/.ghc which contains the important bits if you're blowing things away
10:44:20 <Testeree> monochrom, ok
10:44:42 <Cale> And hopefully that will be soon!
10:45:08 <monochrom> but do read my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml for correct settings for next time you get a new ghc and build things
10:45:40 <Testeree> monochrom, i just use the distro provided ghc and it isn't installing docs by default. is there a flag ? thanks
10:45:52 <Cale> Yeah, in ~/.cabal/config
10:46:16 <Cale> The defaults are kind of dumb in that respect imo
10:46:22 <monochrom> then the distro may have docs in other packages
10:46:35 <tertl3> hello
10:46:36 <markovirc> Hello tertl3
10:46:40 <monochrom> the defaults are a crime
10:46:42 <jrmithdobbs> Cale: not building with split objects by default is dumb too =/
10:46:45 <Cale> I really think profiling and docs ought to be on by default in the cabal config
10:46:48 <tertl3> return $ Ratio ((read x ) % (read y))
10:46:54 <Cale> Split objects I don't really care about
10:47:02 <tertl3> listing3.3.hs:90:43: Not in scope: `%'
10:47:05 <Cale> (and actually kind of prefer that being off)
10:47:07 <monochrom> but the most severe crime is to allow multiple versions to begin with
10:47:41 <tertl3> is '%' a haskell operator?
10:47:52 <monochrom> anyway, soon you will also like to enable shared libs too
10:48:06 <tomejaguar>  :t (%)
10:48:12 <tomejaguar> :t (%)
10:48:12 <geekosaur> @index (%)
10:48:12 <lambdabot> Data.Ratio
10:48:13 <lambdabot> Integral a => a -> a -> Ratio a
10:48:23 <Cale> monochrom: Why is that?
10:48:35 <jrmithdobbs> Cale: the rest of everything defaults to "production" defaults in cabal why not that, noone wants 50M binaries outside of dev environments, especially since dynamic linking isn't on =/
10:48:44 <monochrom> because ghc is moving towards encouraging shared libs
10:48:51 <tertl3> ty tomejaguar and geekosaur
10:48:56 <tertl3> im getting it :)
10:49:06 <Cale> jrmithdobbs: The 50M binaries are easier to deploy?
10:49:29 <jrmithdobbs> Cale: how so?
10:49:46 <Cale> You don't have to make sure the shared libraries are there. You copy the binary over and done.
10:50:18 <Cale> (of course, C library deps need to be there too, but often there aren't many of those)
10:50:43 <jrmithdobbs> but split-objects helps the size without shared libs and you can still just copy it?
10:50:47 <Cale> It's not like 50MB is a significant amount of disk space or bandwidth these days
10:50:51 <quchen> chrisw: Oh, and by the way, other than the performance things your usage of State was correct. :-)
10:51:10 <Cale> That's like 0.04 * my daily bandwidth usage
10:51:20 <jrmithdobbs> and the fact that building that 50M binary by default implicitly makes your code gplv3 if you distribute it without really mentioning it clearly.
10:51:24 <centrinia> > 50/0.04
10:51:25 <lambdabot>  1250.0
10:51:31 <jrmithdobbs> (talking default config after all =/)
10:51:45 <mizu_no_oto> I just upgraded my Mac to Mavericks and installed the latest Haskell Platform.  I haven't upgraded xcode; it's currently v4.5.1.  gcc --version shows that I have 4.2.1 installed.  When I run ghc, I'm getting errors like /Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/lib/ghc-7.6.3/include/Stg.h:65:18: error: math.h: No such file or directory
10:51:50 <Cale> (actually less than that, given centrinia's calculation :)
10:51:55 <mizu_no_oto> Any idea what's up with that?
10:52:00 <chrisw> quchen, great =)
10:52:07 <geekosaur> mizu_no_oto, open Xcode, go into Preferences, install Command Line Tools
10:52:12 <Cale> More like 0.02, I guess.
10:52:17 <geekosaur> (Preferences, Downloads tab)
10:53:17 * Cale looks at statistics
10:53:47 <Cale> lol, I was yet another factor of 2 or so off
10:54:05 <Cale> 10GB/day it looks like
10:54:22 <Cale> Some days are lower and some higher
10:54:32 <jmcarthur> i use split objs because it sounded good at the time and i haven't noticed any actual painful difference in linking time
10:54:51 <dennda> Cale: Thank you
10:54:58 <Cale> dennda: any luck?
10:54:59 <centrinia> Cale: How big is your tube?
10:55:24 <jle`> i give up on fay :'(
10:55:30 <dennda> Cale: Not yet, but I'm reading that book. I'm sure there's a couple other things wrong with my code though. It's way slower than it should be.
10:55:32 <jle`> at least until my SO question is answered
10:55:38 <mizu_no_oto> What is the most recent XCode that works with ghc?
10:55:39 <dennda> But well, I'm glad it works at all. :-)
10:55:46 <mizu_no_oto> Any 4.x?
10:55:58 <geekosaur> mizu_no_oto, please follow the directions I gave you
10:56:22 <Cale> centrinia: about 90 Mbit/s down and 2 up
10:56:25 <geekosaur> or, you can ignore them and have problems with EVERY xcode version, because they are ALWAYS unbundled
10:56:32 <Cale> Stupidly asymmetric
10:56:38 <tertl3> :t (:+)
10:56:39 <lambdabot> a -> a -> Complex a
10:56:46 <mizu_no_oto> geekosaur:  In the components tab, it says "no components are available"
10:56:59 <tertl3> :t (:+)@index (:+)
10:57:00 <lambdabot> parse error on input `@'
10:57:04 <tertl3> @index (:+)
10:57:05 <lambdabot> Data.Complex
10:57:20 <mizu_no_oto> geekosaur: check and install now says "no updates available"
10:57:31 <geekosaur> hm, I wonder if apple removed them from that list then, you will have to either direct download from connect.apple.com (or wherever it got moved this week) or upgrade to xcode 5
10:57:37 <bergmark> jle`: link to your question?
10:57:38 <centrinia> > 90/8*60*60*24
10:57:39 <lambdabot>  972000.0
10:57:49 <centrinia> Almost a terabyte a day.
10:57:49 <geekosaur> apple has zero interest in supporting older versions of xcode
10:57:54 <centrinia> You can do a lot better Cale.
10:57:54 <heatsink> Does cabal-install use the ghc and ghc-pkg that are in the PATH?
10:58:16 <Cale> centrinia: Yeah, but eventually I'll run into my ISP's monthly cap
10:58:20 <geekosaur> heatsink: I believe there are options to change it but that is the default behavior
10:58:38 <Cale> (which is dumb, but they pretty much all do that here)
10:58:44 <jle`> bergmark: well my question just got answered
10:58:49 <jle`> but i am still having problems with jquery
10:58:56 <heatsink> Okay, so I can use an old cabal-install to install packages for a development version of GHC
10:59:02 <jle`> i'm testing out my question's answer now
10:59:13 <jle`> with jquery however all of my selects seem to be returning null
10:59:21 <jle`> using fay-jquery
10:59:50 <geekosaur> there have been rare cases where an old cabal-install can't nderstand the newer ghc version, but it's supposed to work
10:59:54 <bergmark> jle`: ah i found it
11:01:06 <joe9> hello, I need some help, please? This is a haskell(imho) more than an xmonad question. my program: http://codepad.org/FovdcXc8 , error: http://codepad.org/pjjwHuNk . Is there any way to work around this, please?
11:01:07 <markovirc> Hello joe9
11:01:44 <joe9> Is there any function signature or some such that I can add to help the type resolution.
11:02:04 <heatsink> thanks
11:02:57 <bergmark> jle`: are you using fay-jquery 0.6.0.2?
11:03:22 <bitemyapp> jle`: that was probably me.
11:04:00 <jle`> bergmark: yes i am
11:04:29 <bitemyapp> bergmark: added an edit to my answer based on what you said.
11:04:52 <jle`> i'm just doing select "p" >>= addClass "hello"
11:04:53 <bitemyapp> Guess I should upgrade my copy of Fay.
11:04:56 <jle`> but none of the p's get the class
11:04:58 <bitemyapp> time to make cabal angry.
11:05:08 <heatsink> joe9: I would put a type signature on line 67 to indicate what type you expect wsid to have
11:05:10 <jle`> i haven't reproduced on a clean slate yet
11:05:21 <heatsink> joe9: That can produce a more informative error message
11:05:57 <geekosaur> mizu_no_oto, xcode 5.0.1, or a later version and use the wrapper indicated in the /topic, or sign up for the free (not $99) mac developer account, log in to https://developer.apple.com/downloads/index.action, and download the appropriate January 2013 Command Line Tools for your OS (separate packages for Lion and Mountain Lion; currently on page 4 of the downloads list)
11:07:35 <jle`> when i select "p" >>= print, i get something printed out
11:07:39 <jle`> some kind of FayCons object
11:07:57 <bitemyapp> jle`: lpaste?
11:08:00 <jle`> but select "p" >>= addClass "test", nothing
11:08:06 <jle`> hm okay i'll set up a self contained
11:08:11 <bitemyapp> jle`: <3
11:08:23 <enthropy> joe9: do you need a class there? toTaskSpaceAction . workspaceIdToTaskSpace is the same problem as   show . read
11:08:32 <bergmark> jle`: you can try test.hs that comes with fay-jquery too
11:08:48 <bitemyapp> jle`: goddammit upgrading broke my code
11:08:50 <bergmark> i just pushed a fix to it, https://github.com/faylang/fay-jquery
11:08:52 <enthropy> you can add a type annotation to fix the intermediate thing to some particular type
11:09:01 <bitemyapp> bergmark: upgrading broke ffi for me the same way it did for him.
11:09:13 <bitemyapp> oh weird.
11:09:17 <jle`> do you know what jquery fay-jquery requires? is 1.9 okay?
11:09:21 <geekosaur> mizu_no_oto, oh, hm, you are on mavericks, older xcode may fail in odd ways and old command line tools will fail in odd ways, you must install xcode 5
11:09:27 <enthropy> or you can make:    currentWorkspaceAction :: TaskSpace t => t -> X ()
11:09:32 <bitemyapp> that's simply the error you get when there's no type signature. That's not very nice.
11:09:42 <mizu_no_oto> k
11:09:48 <bergmark> jle`: i'm using with 1.10, but 1.9 should be fine afaik
11:09:50 <geekosaur> and pointlessly scream at apple like everyone else
11:10:03 <joe9> heatsink, no luck, error: http://codepad.org/5IfDhn8i , program: http://codepad.org/rsAxjNbP
11:10:05 <bitemyapp> bergmark: Using ffi in a function with no signature returns error: `fay: unable to resolve qualified names ffi` - this is sub-optimal. Should I report to github issues?
11:10:06 <enthropy> and then use the `t' arugment like     toTaskSpaceAction . (`asTypeOf` t) . workspaceIdToTaskSpace
11:10:19 <geekosaur> apple has its own priorities, and does not care about the tiny fraction of its userbase that cares about this
11:10:28 <jle`> bitemyapp: oh, is this a new thing?
11:10:31 <joe9> enthropy: yes, I agree, it is the same problem. But, I would not the type in the type level class.
11:10:32 <jle`> (the ffi error)
11:10:42 <bitemyapp> jle`: it always required the type sig, the error message just sucks nuts.
11:10:43 <enthropy> would not what?
11:10:45 <jle`> maybe that was why i couldn't find anything on it except for an SO question from october
11:10:49 <jle`> ah ok.
11:10:52 <bitemyapp> jle`:
11:10:55 <enthropy> can we take this to #xmonad which is less busy?
11:10:55 <joe9> enthropy: sorry, did not see the rest of your comments.
11:10:58 <joe9> enthropy: thanks.
11:10:58 <bergmark> bitemyapp: please do, it might have appeared after some ffi refactorings
11:10:59 <jle`> i would put the sig except...i had it in a `where` binding
11:11:03 <bitemyapp> er, sorry. upgrading from 18 to 19 made the sucky error.
11:11:14 <jle`> so i naturally left off a type signature
11:12:00 <jle`> how do i `node` while requiring jquery
11:12:16 <bergmark> jle`: nodejs you mean?
11:12:29 <jle`> well...yeah
11:12:43 <jle`> the command to interpret is node
11:12:45 <jle`> but yeah
11:12:52 <jle`> maybe i should be loading it in a page
11:13:06 <bergmark> you can use jsdom
11:13:28 <bitemyapp> bergmark: is there anything like a REPL for Fay?
11:13:40 <bitemyapp> bergmark: I'm presenting on Fay on Monday and I'd very much like to have some kind of story for that.
11:14:05 <bergmark> there used to be a repl, it didn't actually run the code though
11:14:17 <bitemyapp> bergmark: what did it do?
11:14:31 <bergmark> you could give it an expression and it would print the resulting js
11:15:22 <bitemyapp> bergmark: that's still interesting, was the resulting output compact enough to be interesting?
11:15:28 <bitemyapp>  / readable
11:15:29 <heatsink> haha
11:15:48 <bergmark> it was usually pretty okay
11:18:58 <bitemyapp> jle`: lpaste?
11:19:00 <bergmark> mostly the output gets hairy if you do a lot of monadic thingies
11:19:17 <bitemyapp> bergmark: CPS blah.
11:19:17 <jle`> bitemyapp: i'm trying things out in the style of the test.hs provided
11:19:20 <jle`> and seeing if it makes it work
11:19:28 <bitemyapp> jle`: I wanna halp ;_;
11:19:33 <bitemyapp> fine fine, I'll go play hearthstone.
11:21:06 <jle`> haha.
11:21:08 <jle`> well
11:21:10 <jle`> i can paste what i have now
11:21:14 <bitemyapp> bergmark: it is the CPS that makes it fugly right?
11:22:47 <jle`> bitemyapp: here ya go :)
11:22:49 <jle`> http://lpaste.net/99080
11:22:55 <jle`> i pasted the jaavscript i am trying to translate
11:22:59 <jle`> before all of my fay blocks
11:23:29 <jle`> also i couldn't get an ffi to work in a where block, so it took it out
11:23:35 <jle`> s/took/broke
11:23:58 <jle`> so my problem is that my p's aren't getting the class 'yolo' added to them
11:24:02 <bergmark> jle`: they should work in where blocks now too
11:24:20 <jle`> bergmark: should? i'll remind the compiler :)
11:24:30 <bergmark> check tests/DesugarFFI.hs
11:24:30 <jle`> :P
11:24:37 <jle`> mk
11:25:14 <dennda> Cale: Oh, I missed that earlier question. Yes, multiple CPUs are being used
11:25:29 <Cale> dennda: ah, okay
11:26:03 <jle`> bergmark: oh it worked
11:26:05 <jle`> haha
11:26:15 <PTBD> hi, when a function is infix like this http://pastie.org/private/txk0ycbak7yvzpew2nj1a i don't have to use backticks. but when using for example div, I have to
11:26:15 <markovirc> Hello PTBD
11:26:21 <jle`> i think it was before i was trying to fix the type of the IsString to Text or String
11:26:44 <qrada> is there a way to shorten this up, so i don't have to put 'a' everywhere, those should be B a | KB a | ... : data Blocks a = B | K | KB | M | MB | G | GB | T | TB deriving (Show, Read)
11:26:50 <jle`> PTBD: operators (names with only symbols) are infix by default
11:27:09 <bergmark> bitemyapp: main = a >>= b >>= c >> d becomes
11:27:18 <bergmark> Test.main = new Fay$$$(function(){ return Fay$$_(Fay$$_(Fay$$then)(Fay$$_(Fay$$_(Fay$$bind)(Fay$$_(Fay$$_(Fay$$bind)(Test.a))(Test.b)))(Test.c)))(Test.d); });
11:27:25 <PTBD> jle`, so if i called it for example "blah" instead of ! I would have it so set in backticks?
11:27:31 <jrmithdobbs> i think it's time to go outside now:  total alloc =   1,493,984 bytes  (excludes profiling overheads)
11:27:35 <jle`> PTBD: yes
11:27:42 <PTBD> jle`, great, thank you
11:27:43 <jle`> notice that you put parentheses around your !
11:27:49 <jle`> that is because you are making it prefix
11:28:00 <jle`> you can actually define the whole thing "naturally" in infix
11:28:05 <jle`> oh wait nvm
11:28:08 <jle`> you did do that
11:28:18 <jle`> it's just in the type signature that you need the parentheses yeah
11:28:25 <jle`> but
11:28:28 <jle`> you could also define it as
11:28:34 <jle`> (!) (x:xs) 0 = ...
11:28:38 <dennda> Cale: Anyway, there's not much of a difference using different strategies as far as I can tell, so I might need to check where the actual bottleneck is
11:28:52 <PTBD> jle`, thank you
11:28:53 <Cale> yeah
11:29:02 <jle`> operators are naturally infix, non-operators are naturally prefix...you can 'coerce' an operator to prefix with (), you can coerce a non-operator to infix with ``, yeah
11:29:26 <Cale> dennda: It could be that e.g. serialising the resulting image is taking all the time, especially if you're using String or something.
11:29:52 <PTBD> I just though that no matter what it is, you have to write it between backticks
11:29:59 <bergmark> bitemyapp, jle`: https://github.com/faylang/fay/commit/5fbdeb9db52ce1684b00e7e87e7013876517df4f
11:30:13 <dennda> Cale: Yeah I just had that thought as well
11:30:14 * hackagebot courier 0.1.0.8 - A message-passing library for simplifying network applications  http://hackage.haskell.org/package/courier-0.1.0.8 (PhilHargett)
11:30:37 <jle`> bergmark: nice :)
11:31:01 <heatsink> How do I install a package globally, but not as root?
11:31:30 <heatsink> cabal install --global wants my password, presumably for root privileges
11:31:32 <jle`> bitemyapp: the class adding action isn't working with just an empty page either
11:32:25 <geekosaur> heatsink, only root has access to the global registry
11:32:44 <geekosaur> unless you have a private (non-system) ghc installation
11:32:56 <bitemyapp> bergmark: thank you!
11:33:00 <jle`> bitemyapp: do i need to do something special to select "all" of something?
11:33:04 <heatsink> I have a private installation
11:33:13 <heatsink> I installed it as user in my user directory
11:33:24 <bergmark> bitemyapp: i think you accidentally pasted some VLC things when you edited your SO answer :-)
11:34:06 <geekosaur> hm, then it should not really require root unless you're running somehow against the wrong ghc
11:34:07 <jle`> bitemyapp: oh hm.  select "p" >>= addClass "yolo" seems to work on the stripped down example
11:34:09 <jle`> what gives
11:34:15 <geekosaur> but I don't know offhand how cabal determines that
11:34:47 <bitemyapp> bergmark: god dammit, thank you.
11:35:01 <heatsink> Should I be using sandbox software or something?
11:35:10 <dennda> Cale: Hah, that seems to be the case! What the heck. And obviously that part happens after the parallel operations have happened and happens sequentially. So I guess the question is how do I make that more efficient.
11:40:16 * hackagebot rdf4h 1.2.3 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.2.3 (RobStewart)
11:40:22 <Cale> dennda: Try using either ByteString or Text
11:41:31 <dennda> Cale: This is my function: https://gist.github.com/dennda/256fe8be71bbfa4aaf90
11:41:33 <jle`> i cannot get a thing to yolo.
11:41:46 <bitemyapp> jle`: so `select "p" >>= addClass "yolo` worked and what didn't?
11:41:53 <bitemyapp> "yolo"`
11:41:58 <jle`> bitemyapp: it worked in my page with only paragraphs
11:42:02 <jle`> but not in my actual app webpage
11:42:18 <jle`> so...it's a little hard for me to phrase this in a way that you can help ><
11:42:23 <Cale> dennda: how is join defined?
11:42:42 <jle`> if you want i can link to my dev server
11:42:57 <bitemyapp> jle`: I think I can kinda get it but an interactive console would help a lot.
11:43:01 <Cale> dennda: Also, configure your text editor to expand tabs to spaces
11:43:10 <dennda> Cale: reload
11:43:20 <Cale> AHA!
11:43:22 <kristof> I'm not really sure why emacs defaults to tabs instead of spaces
11:43:23 <jle`> the thing is that it works fine in my toy page but not in my actual page.  maybe it has to do with my rendeirng
11:43:31 <jle`> my compile options
11:43:32 <Cale> Replace foldl with foldr
11:43:46 <Cale> and watch your performance improve massively
11:43:47 <kristof> Is foldl ever a good idea instead of foldr or foldl'?
11:43:57 <dennda> Cale: heh, indeed
11:44:22 <dennda> I think I might have read about foldl/foldr performance considerations in some obscure corner somewhere, but I kind of don't remember
11:44:36 <Cale> The problem here is that
11:44:46 <Cale> xs ++ ys takes O(length xs) steps to fully evaluate
11:45:54 <Cale> So if you end up with something like  ((...(([] ++ [a]) ++ [b]) ...) ++ [y]) ++ [z]
11:46:00 <Cale> Then that'll take quadratic time
11:46:16 <kristof> Not to mention, you can blow your stack with really long lists.
11:46:23 <Cale> because the longer lists end up on the left
11:48:02 <Cale> dennda: also, how are you compiling? Are you using -O2 or at least -O?
11:48:22 <dennda> Cale: -O2
11:48:24 <Cale> okay
11:48:27 <jle`> bitemyapp: if it would help. http://blog-dev.jle0.com/entry/pre-processor-tests is a dev server page (it's a bit slow) and http://blog-dev.jle0.com/js/page/entry.js is the pretty-printed compiled js
11:48:31 <Cale> :t intercalate
11:48:32 <lambdabot> [a] -> [[a]] -> [a]
11:49:00 <Cale> > intercalate "-=-" ["here", "are", "some", "strings"]
11:49:01 <lambdabot>  "here-=-are-=-some-=-strings"
11:49:04 <jle`> the code is just teh same as the lpaste earlier, select ("p" :: Text) >>= addClass "yolo"
11:49:20 <jle`> it won't compile without the type annotation
11:49:20 <Cale> @src intercalate
11:49:20 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
11:49:21 <dennda> Cale: Are you saying I should replace my join?
11:49:27 <Cale> yeah, just use that
11:49:40 <Cale> Or define join = intercalate
11:49:56 <Cale> (but join means something else to a Haskell programmer usually)
11:49:59 <Cale> :t join
11:50:00 <lambdabot> Monad m => m (m a) -> m a
11:50:25 <Cale> (which is a generalisation of concat)
11:50:51 <jle`> :t concat
11:50:52 <lambdabot> [[a]] -> [a]
11:52:43 <dennda> Cale: Cool, thanks. I guess I can go back to exploring the parallelization now, then
11:52:46 <athan> Could function composition (.) and the id function be considered a monoid?
11:53:04 <hpc> yes
11:53:06 <nisstyre> athan: they are a monoid
11:53:08 <hpc> @src Endo
11:53:08 <lambdabot> Source not found. Do you think like you type?
11:53:09 <athan> Awesome!!!
11:53:18 <athan> thank you!
11:53:32 <jle`> athan: wellllll
11:53:35 <hpc> specifically, they are mappend and mempty for the (a -> a) monoid
11:53:42 <jle`> kinda
11:53:53 <nisstyre> jle`: how is it "kinda"
11:53:55 <nisstyre> it either is or isn't
11:53:58 <hpc> (newtype Endo a = Endo {appEndo :: a -> a}
11:54:01 <hpc> )
11:54:02 <Cale> athan: When restricted to a specific type, so that composition (.) :: (a -> a) -> (a -> a) -> (a -> a)
11:54:03 <jle`> doesn't the identity have to be unique?
11:54:15 <jle`> there are multiple id's
11:54:22 <nisstyre> jle`: the identity element is id, which is unique afaict
11:54:23 <jle`> and id is different
11:54:25 <hpc> there's exactly one id
11:54:29 <jle`> if you put it before or after
11:54:33 <nisstyre> jle`: you just need at least one
11:54:39 <Qett> are there any good haskell/functional programming forums?
11:54:54 <Cale> nisstyre: It depends on whether you're thinking of id as a single arrow from a specific type to itself, or whether you're thinking of it as all the identity functions at once.
11:54:56 <jle`> like, id . (f :: Int -> String) and (f :: Int -> String) . id
11:54:59 <jle`> the id's are different
11:55:01 <jle`> right?
11:55:04 <jle`> i'm not sure, i don't know anything
11:55:07 <Cale> yes
11:55:08 <athan> ahhhhh
11:55:20 <Cale> There's a *category*, not a monoid of Haskell types and functions.
11:55:24 <nisstyre> Cale: well yeah, a -> a can be instantiated as many "different" functions I guess
11:55:31 <athan> so monoids can be defined concretely in categories, or polymorphically like in haskell... hmm
11:55:47 <Cale> A monoid is pretty much the same thing as a category with only one object
11:55:48 <jle`> id is a polymorphic function that generates an identity...i think...
11:55:57 <jle`> but there are multiple identities
11:56:04 <jle`> an identity for the function and type you need
11:56:07 <athan> ahhhh!!!
11:56:08 <nisstyre> jle`: the code for a -> a is the same no matter what types you instantiate that with
11:56:11 <athan> This is friggin awesome!!!
11:56:11 <Cale> And given any category, and any specific object of it, you can get a monoid of arrows from that object to itself under composition.
11:56:41 <athan> O.o
11:57:12 <nisstyre> jle`: also your examples are wrong
11:57:22 <nisstyre> you can't instantiate a -> a as Int -> String
11:57:45 <ReinH> nisstyre: that's not what he's saying
11:57:49 <jle`> oh i was referring to the question about functions in general
11:57:50 <Cale> nisstyre: You can't, but the point was that composition is more general
11:57:54 <jle`> not about (a -> a)'s
11:58:01 <Cale> also, that id is more general :)
11:58:05 <nisstyre> Cale: yeah I understand
11:58:26 <jle`> if your f :: Int -> String, then the identity arrow id . f is different than the identity arrow in f . id
11:58:28 <ReinH> he's saying Int -> Int and String -> String are different id arrows in Hask
11:58:49 <nisstyre> oh right, I misread that
11:59:39 <lingxiao> what commands do I need to pass during cabal install, so that when it fails a more useful error messsage is output?
12:00:22 <nisstyre> ReinH: I still wouldn't call them "different" since it doesn't require a separate implementation
12:00:33 <nisstyre> but you can use a different definition of difference if you want
12:00:37 <ReinH> nisstyre: if you pick a specific object in Hask, like Int, you get a monoid <Int -> Int, id, (.)>
12:00:48 <jle`> i think a difference between the category laws and the monoid laws is...category laws says that there must exist such an id, and monoid laws says that there is only one such id
12:01:12 <jle`> (an id such that f . id = f, and another id such that id . f = f)
12:01:23 <jle`> but i'm kind of talking out of my ass here
12:01:35 <tomejaguar> A monoid is a category with one object, so the laws ought to be the same.
12:01:45 <nisstyre> jle`: that law doesn't have to hold for a monoid though
12:02:06 <geekosaur> actually "with only one object" sounds liek the difference there?
12:02:20 <twopoint718> Is there a way in a cabal file to require a version from github?
12:02:50 <jle`> bitemyapp: thanks for your help so far; i actually have to go now, but i'm usually idling here 24/7 if you are able to figure something out
12:02:57 <geekosaur> I don't think so, the point of cabal files is using known good releases
12:03:06 <geekosaur> and the registry of such releases is hackage
12:03:48 <twopoint718> Something like: 'mueval git://...,' in the build-depends section?
12:04:11 <supki> cabal files do not care where you get a version of a package actually
12:04:24 <geekosaur> not if it's already installed, no
12:04:30 <geekosaur> but it will only install it for you from hackage
12:04:50 <twopoint718> What does the 'source-repository' section in a cabal file do then?
12:04:58 <supki> for some values of "hackage" :)
12:05:06 <geekosaur> tells you where the source indexed on hackage came from
12:05:27 <jle`> bitemyapp: ah! i got it to work
12:05:34 <jle`> i just needed to add -XRebindableSyntax
12:05:43 <jle`> this i do not understand ( bergmark )
12:06:00 <twopoint718> geekosaur: so it is purely informative. I was hoping there was an "install from source" option somewhere
12:06:21 <jle`> twopoint718: i think the best thing you can do is per-install
12:06:31 <geekosaur> the problem is that it resolves uninstalled dependencies using an index it downloads from hackage (for some value of hackage, but that value must have the same files in the same places)
12:06:34 <geekosaur> github does not export a hackage-like interface
12:06:42 <athan> What's the natural version of >>= in haskell?
12:06:50 <Cale> athan: natural?
12:06:52 <twopoint718> jle`: Sorry, I don't think I understand.
12:06:56 <athan> Like how (.) is <=<
12:07:08 <Cale> athan: function application
12:07:13 <athan> and f ( g x ) is f =<< ( g x )
12:07:27 <athan> is there a reverse function applicator?
12:07:29 <Cale> flip ($) ?
12:07:30 <jle`> (&) :)
12:07:39 <athan> woah!!
12:07:46 <athan> sorry hahaha
12:07:46 <Cale> lens defines (&)
12:07:49 <Cale> but I wouldn't use it
12:07:50 <athan> AWEOSMEOEMEOMEOMEOM
12:07:54 <Cale> That's just terrible
12:07:54 <athan> HOLY CRAP!!!
12:08:01 <athan> me neither
12:08:07 <jle`> twopoint718: you can tell your local installation of cabal to use a local directory for a package...that might not be what you want though
12:08:10 <athan> I'm just getting completeness in my mind finally lol
12:08:12 <jle`> athan: yeah don't use (&) :)
12:08:13 <twopoint718> I can back up a bit. I'm trying to install 'tryhaskell' locally. I've got it working but it looks like there's newer version of mueval out on github and current tryhaskell assumes some command line options that don't exist yet.
12:08:16 <geekosaur> apparently we're supposed to have a rolling release model instead of a known good release model
12:08:20 <jle`> >>= is a little awkward anyway
12:08:24 <jle`> =<< is more natural
12:08:33 <twopoint718> jle`: No, that sounds exactly what my plan B was going to be.
12:08:34 <jle`> if you are thinking of kleisli categories
12:08:45 <athan> yep!
12:08:59 <jle`> @src (&)
12:08:59 <lambdabot> Source not found. Maybe you made a typo?
12:09:03 <jle`> well it was worth a shot
12:09:12 <jle`> and that lambdabot error was uncharacteristically understanding and kind
12:09:17 <jle`> @src (&)
12:09:17 <lambdabot> Source not found. My mind is going. I can feel it.
12:09:31 <Cale> It's only because the right parameter to >>= is likely to be more than one line that it's the more popular variation.
12:09:37 <dennda> Cale: Look what you helped me create: http://the-space-station.com/~dennda/screenshots/screenshot_212B3295-5ECD-4D3F-93AA-668AE7B97D64.png
12:09:54 <jle`> bitemyapp, bergmark: is there a reason why i need RebindableSyntax?
12:09:54 <dennda> It's not quite finished yet as you might be able to tell :)
12:09:58 <Cale> But do-notation exists anyway, and =<< is nicer with that
12:10:03 <Cale> dennda: nice :)
12:10:10 <jle`> f <- g =<< h
12:10:12 <jle`> coo
12:10:21 <twopoint718> jle`: do you know where the docs on how to set that up are?
12:10:25 <Cale> dennda: Are those actually spheres?
12:10:30 <twopoint718> jle`: cabal user manual?
12:11:07 <jle`> twopoint718: i've never done it myself, but i know that when i'm in a sandbox, i can do cabal sandbox add-source /path/to/repo
12:11:21 <jle`> and that is the extent of my knowledge
12:11:29 <PTBD> how would one get all possible insertions of an element into a list
12:11:38 <ReinH> nisstyre: well, the monoids are the same in that they form a category: the category of one-object categories of Hask, whose arrows are functors (monoid homomorphisms)
12:11:40 <jle`> PTBD: ?
12:11:48 <jle`> inserted at every possible location?
12:12:00 <PTBD> yes
12:12:11 <dennda> Cale: Yes. I need to add lighting and things.
12:12:19 <jle`> ins 1 [2,3] == [[1,2,3],[2,1,3],[2,3,1]] ?
12:12:25 <PTBD> ins 1 [2,3,4] should return [[1,2,3,4],[2,1,3,4],[2,3,1,4].....]
12:12:44 <nisstyre> ReinH: I wasn't aware that you needed anything else to prove it's a monoid than the fact that id . f = f and (f . g) . id = f (g . id)
12:12:53 <nisstyre> * f . (g . id)
12:13:22 <PTBD> I don't need a solution, just an idea where to start
12:13:22 <dennda> Cale: These are the very simple beginnings of a very simple raytracer I want to write in order to learn myself some haskell.
12:13:54 <ReinH> nisstyre: right, you just need identity and associativity
12:14:07 <jle`> dennda: pop the source on github if you ever feel like it :)
12:14:08 <Cale> dennda: I highly recommend constructing the scene where the 4 spheres are at alternate corners of a cube (i.e. (0,0,0), (1,1,0), (1,0,1), (0,1,1)), and where their radius is just large enough to make them touch, i.e. 1/sqrt(2).
12:14:11 <nisstyre> ReinH: so a -> a is a function in the set of functions of type a -> b
12:14:26 <shachaf> nisstyre: You need "closure", i.e. for any elements f and g, f . g is also an element.
12:14:27 <nisstyre> and it serves as an identity element
12:14:32 <Cale> dennda: and then point the camera into one of the gaps between 3 of the spheres :)
12:14:42 <bitemyapp> jle`: I haven't used it, but isn't Fay swapping itself in for Prelude stuff?
12:14:50 <Cale> (once you have reflections)
12:15:06 <shachaf> nisstyre: You don't get that with functions because f . g might not type-check.
12:15:14 <Cale> The reflections form a fractal
12:15:14 <dennda> jle`: Ya I was going to do that at some point
12:15:15 <nisstyre> shachaf: fair enough
12:15:20 * hackagebot twiml 0.1.0.0 - TwiML library for Haskell  http://hackage.haskell.org/package/twiml-0.1.0.0 (andrus)
12:15:27 <shachaf> (And that's why you need a different id for each type.)
12:15:29 <jle`> bitemyapp: hm. i guess so.  but then why did it compile just fine without it?
12:15:30 <ReinH> right, we're talking about Endo
12:15:31 <ReinH> :t Endo
12:15:32 <lambdabot> (a -> a) -> Endo a
12:15:41 <dennda> Cale: I'll keep that in mind
12:15:51 <bitemyapp> jle`: you weren't using anything that needed it?
12:15:56 <bitemyapp> jle`: what did you to necessitate it?
12:15:57 <Cale> http://www.miqel.com/images_1/fractal_math_patterns/wada-reflection-basin/redblue.gif -- this is a photograph
12:16:01 <ReinH> nisstyre: each object in Hask (each type) forms a monoid
12:16:13 <klatch> > let x = "foo" in [ splitAt i x | i <- [0..length x] ]
12:16:14 <lambdabot>  [("","foo"),("f","oo"),("fo","o"),("foo","")]
12:16:14 <jle`> bitemyapp: i was doing select "p" >>= addClass "yolo"
12:16:17 <dennda> I didn't know that, that's quite nice
12:16:19 <jle`> but without rebindable syntax
12:16:27 <jle`> i was required to specify an instance for "p"
12:16:28 <klatch> PTBD: see if you can do something with that?
12:16:31 <dennda> I imagine that needs quite a few reflection hops
12:16:35 <shachaf> I'm not sure what ReinH is trying to get at here.
12:16:35 <Cale> yes :)
12:16:37 <jle`> select ("p" :: Text") >>= addClass "yolo"
12:16:47 <jle`> but with RebindableSyntax....i didn't need the :: Text
12:16:47 <nisstyre> ReinH: okay, that makes sense
12:16:54 <jle`> and i could just do select "p" >>= addClass "yolo"
12:16:57 <Cale> (well, the more you give it, the better)
12:17:02 <dennda> sure
12:17:03 <ReinH> shachaf: nisstyre was talking about whether the monoids are "different" because the implementation of id is the same
12:17:06 <PTBD> klatch, thank you
12:17:06 <kristof> dennda: Want a cool project to learn you a haskell? Try "Write Yourself a Scheme". Title is explanatory enough.
12:17:23 <jle`> i wonder why rebindable syntax makes that change. oh well
12:17:33 <jle`> hm.
12:17:40 <nisstyre> ReinH: wikipedia calls it a "Transformation semigroup"
12:17:49 <jle`> i think it was inferring the type of "p" later on, in a do block. er well, probably some mystery.
12:17:52 <shachaf> ReinH: What does it mean when you say that "each type forms a monoid"?
12:17:55 <dennda> I guess at some point the quality of the image will converge to some upper limit defined by the resolution
12:18:04 <jle`> dennda: i ask because i plan on embarking on a ray tracer myself in some amount of time :)
12:18:30 <ReinH> shachaf: it means that for a type `a', <a, (.)> is a monoid
12:18:35 <jle`> bitemyapp: anyways, thanks for the help; gotta go.
12:18:45 <dennda> jle`: Ya. I just use it as a fun learning exercise though. This is not going to be my big commercial breakthrough :)
12:18:59 <jle`> dennda: are you blitting it pixel by pixel?
12:19:05 <shachaf> So for example "<Int, (.)>" is a monoid? (.) :: Int -> Int -> Int?
12:19:23 <dennda> jle`: At the moment, yes, it shoots one ray per pixel. Super primitive.
12:19:26 <ReinH> shachaf: isn't it?
12:19:29 <twopoint718> jle`: okay, yup, 'cabal sandbox add-source PATH' did the trick. Thanks!
12:19:39 <shachaf> ReinH: That is not a valid type for (.), no.
12:19:48 <Cale> shachaf: (.) :: (Int -> Int) -> (Int -> Int) -> (Int -> Int)
12:19:49 <ReinH> shachaf: sorry, <a -> a, (.)>
12:20:08 <jle`> twopoint718: no problem :) if you intend to take it to production i recommend doing more research and finding something more robust
12:20:19 <twopoint718> I'm planning on using tryhaskell for a Haskell workshop I'm giving in April
12:20:19 <ReinH> shachaf: the usual monoid of an object, its arrows, and composition
12:20:20 <shachaf> OK. Yes, you can get a monoid from each type A by taking all the functions :: A -> A as your elements.
12:20:44 <ReinH> which is just another way of saying: take a single object from the category Hask and form an monoid in the obvious way
12:20:49 <twopoint718> jle`: It's good enough if it just "works on my machine" :)
12:20:59 <jle`> twopoint718: haha. welcome to the club :)
12:21:09 <jle`> i'm going to have to tackle this one day or another.
12:21:15 <dennda> Thanks guys. I shall tackle this again tomorrow.
12:21:35 <ReinH> shachaf: my point was that each monoid so formed is distinct, but taken together they form a category
12:22:01 <ReinH> which was an attempt to provide a better answer to "are they the same monoid?" than "yes and no"
12:22:12 <kristof> What's the advantage of having a monoid as opposed to just a semigroup?
12:22:23 <ReinH> kristof: having a unit is nice
12:22:27 <kristof> Hmmmm...
12:22:32 <kristof> That's true
12:22:49 <kristof> I guess I've never worked with any semigroups before that weren't also monoids
12:22:49 <ReinH> kristof: you can form a monoid from any semigroup by adding an unit element
12:22:57 <kristof> ReinH: that's true
12:23:02 <ReinH> kristof: iow Semigroup a => Monoid (Maybe a)
12:23:44 <ReinH> but since the Monoid instance is mimplemented differently, it's actually Monoid (Option (Maybe a))
12:24:05 <kristof> Haskell has option types? lord... I thought Maybe was just a synonym for option in other languages
12:24:21 <ReinH> kristof: Maybe is an "option type" in that it represents 0 or 1 value
12:24:33 <kristof> I'll look up what option is in Haskell later
12:24:38 <nisstyre> kristof: well it's elegant to have an identity element, e.g. so you can define product []
12:24:40 <kristof> Gotta bounce for now, but thank you Reinh
12:24:44 <ReinH> Option is a newtype from the semigroups package that provides the "semigroup + unit" monoid
12:24:57 <kristof> oh ok
12:25:25 <kristof> nisstyre: That's true! I guess that's a good bit of flexbility
12:25:29 <ReinH> which is useful for, e.g., tropical monoids
12:25:38 <joelteon> tropical monoids...
12:25:46 <nisstyre> kristof: yeah the empty sum and product get around for how basic they are
12:25:53 <kristof> I always just think of monoids in the context of parallelism, which is why I think "oh, a semigroup, good enough"
12:25:54 <ReinH> joelteon: a monoid with min and plus
12:25:58 <shiona> I just read about them today. I still don't know how 'Maybe a' and 'Option (Maybe a)' differ in their implementation of monoid
12:26:01 <identity> joelteon: they wear hawaii shirts and drink mojitos all day
12:26:08 <ReinH> kristof: you should read byorgey's functional pearl on monoids
12:26:22 <kristof> ReinH: I'll look it up
12:26:25 <kristof> for now... adios all!
12:27:05 <ReinH> joelteon: where unit is positive infinity
12:27:16 <ReinH> joelteon: or, for bounded types, maxBound
12:27:17 <joelteon> I like identity's explanation better
12:27:19 <joelteon> but ok
12:27:28 <ReinH> also that
12:27:47 <ReinH> fun story: they are called "tropical" because the mathematician who invented/discovered them lived in brazil
12:28:01 <ReinH> (although bounded types are not really closed under addition...)
12:28:29 <ReinH> > foldr min (maxBound :: Int) [1,2,3] -- unit should be +inf but works well enough
12:28:30 <lambdabot>  1
12:32:12 <bitemyapp> jle`: I'm back, figure out your problem?
12:35:12 <ReinH> actually, bounded types form a tropical monoid just fine. They don't form a tropical semiring unless addition is closed.
12:35:16 <ReinH> aanyway
12:39:26 <pavonia> dennda: What library did you use for drawing?
12:40:47 <_davide> Hi -- is there any facility in haskell to do constraint programming? (like curry or prolog do)
12:41:10 <aristid> _davide: only at the type level
12:41:51 <_davide> aristid: it's enough for me. Do you have any reference to it?
12:42:34 <aristid> _davide: http://byorgey.wordpress.com/2010/06/29/typed-type-level-programming-in-haskell-part-i-functional-dependencies/
12:42:46 <_davide> aristid: thanks!
12:42:52 <Cale> If you want to actually do stuff, then ignore that, and use something like http://hackage.haskell.org/package/logict
12:43:17 <_davide> As a toy problem I just wanted to write a sudoku solver
12:43:19 <ReinH> _davide: you can do finite domain solvers, logic solvers with LogicT, etc
12:43:20 <Cale> (or just the list monad)
12:43:36 <aristid> hmm sudoku solver in haskell types... :D
12:43:53 <ReinH> aristid: there are interfaces to various non-Haskell SAT/SMT solvers
12:44:06 <_davide> I will check this library
12:44:40 <aristid> how does logict differ from the (proper, non-mtl) ListT again?
12:44:46 <joelteon> better performance
12:45:29 <MorehouseJ09> starting to get a bit more comfortable with haskell
12:45:41 <MorehouseJ09> anyone know of an hbase library thats decent for use with haskell?
12:45:58 <_davide> are there examples of how to use logict?
12:46:12 <aristid> _davide: the package links a paper
12:46:19 <aristid> http://www.cs.rutgers.edu/~ccshan/logicprog/LogicT-icfp2005.pdf
12:46:37 <aristid> :t foldr
12:46:38 <lambdabot> (a -> b -> b) -> b -> [a] -> b
12:47:08 <nicepaws> Hey friendos. What is the logical progression from LYAH? Real World Haskell? I'm preparing for an intro to Data Structures class at university.
12:48:12 <tabemann> I would typically say yes
12:51:20 <ReinH> nicepaws: RWH is good for people who already know some Haskell
12:51:30 <ReinH> you might like Programming in Haskell
12:52:07 <identity> nicepaws: You get to use haskell for that?
12:52:09 <identity> :(
12:53:32 <nicepaws> What I mean to say is how thorough do I have to be with LYAH? Can I just read through it once and use it as reference or do I really need to sit down and play with all the functions presented in the Modules chapter, etc.
12:54:22 <dwcook> nicepaws, the more you actually do stuff the easier it is to understand, at least in my experience
12:54:36 <identity> programming is definitely learn by doing
12:54:45 <MedDev> agreed
12:54:52 <dennda> pavonia: None, I just write that stuff out as ppm data and then use some external program to open that. Finding a better way to do the drawing is definitely on the list
12:55:57 <MedDev> nicepaws, try to think of a number crunching or data mining application that you want to build and build it in haskell. those tend to be good first projects. I know mine was a text scraper -> csv file dohickey
12:56:22 <dennda> pavonia: http://en.wikipedia.org/wiki/Netpbm_format#PPM_example
12:56:52 <pavonia> dennda: Oh, so you did the rendering yourself?
12:57:32 <dennda> pavonia: Si
12:58:23 <pavonia> Interesting. I'm still looking for a library for doing pixel-based rendering
12:59:14 <jle`> bitemyapp: oh, i had already fixed it. just wondering why it was necessary to rebind syntax, but i'll just leave it in there
12:59:38 <jle`> hm. is there any way to create POJO's in Fay?
12:59:53 <heatsink> Configuring the llvm-general-pure package fails and does not output any error messages.  How can I find out what the problem is?
13:00:09 <dennda> Anyway, I have to attend a birthday party. Thanks for the help gentlemen.
13:00:25 <dhrosa> who was the person doing problem 14 of project euler around here?
13:01:17 <piezoid> heatsink: cabal configure --verbose[=n] ?
13:03:32 <heatsink> Huh
13:03:43 <heatsink> The setup script segfaults
13:05:07 <heatsink> The setup script command is the last command printed in verbose mode
13:06:16 <heatsink> I'll see what I can do about that some other time
13:10:16 <bitemyapp> jle`: link please?
13:10:37 <bitemyapp> jle`: ohhh, I see. you were passing String literals that weren't Text
13:10:44 <tabemann> I should probably go and do project euler or something, as I can't get myself to work on any code lately, despite being mostly sane now...
13:10:55 <bitemyapp> jle`: well. Fay libraries generally try to use Text where they can. You can explicitly unpack it too, if desired.
13:10:56 <jle`> bitemyapp: and that...is fixed by rebindable syntax?
13:11:12 <bitemyapp> jle`: rebindable syntax just lets the string literal mean something else if you're unwilling to call T.unpack
13:11:15 <bitemyapp> er, T.pack
13:11:15 <bitemyapp> sorry.
13:11:38 <bitemyapp> jle`: you should look at the implementation of pack and unpack and ponder why it's the case.
13:11:44 <bitemyapp> I was amused.
13:15:01 <jle`> isn't that what OverloadedStrings is supposed to do?
13:22:57 <HugoDaniel> hi
13:22:58 <markovirc> Hello HugoDaniel
13:24:15 <jmcarthur> i hate it when i have time to work on projects and no idea what I want to work on
13:24:21 <jmcarthur> oh sorry, that was meant for -blah
13:25:27 <kristof> bitemyapp: Oleg agrees with me that dyamically bound / implicit vars are cool. Take that!
13:26:08 <kristof> bitemyapp: Really though, I was reading his paper on DELIMITED dynamic variable binding and I'm surprised that there's no popular language that has such a thing natively :'(
13:27:31 <bitemyapp> kristof: Oleg is a hyper-dimensional all-consuming knowledge demon looking for new material.
13:27:43 <kristof> bitemyapp: That can only be good
13:27:44 <bitemyapp> kristof: anything is cool when you need material :)
13:27:50 <bitemyapp> but yes, Oleg is the bestest.
13:28:13 <bitemyapp> I'm testing memory usage of unpacked arrays at the moment, then when this curiosity/yak-shave is resolved, going back to my Fay.
13:28:15 <kristof> bitemyapp: I'm just still a little surprised you think implicit vars are undiscliplined. Reader monads are a whole lot of song and dance
13:28:35 <kristof> your... fay?
13:29:06 <bitemyapp> kristof: Haskell (subset) -> JS
13:29:09 <bitemyapp> kristof: presenting on Monday.
13:29:39 <Fuuzetsu> Soon all programming will concentrate around writing anything -> JS compilers
13:29:41 <jrmithdobbs> bitemyapp: presenting typeclasses? ;p
13:29:53 <kristof> Fuuzetsu: Well, you Java is a popular target code too.
13:30:04 <Qett> How can i check if a ByteString contains another ByteString?
13:30:05 <Fuuzetsu> I'm not Java ;_;
13:30:15 <kristof> Fuuzetsu: Oh! My mistake
13:30:31 <Fuuzetsu> Qett: Hm? That doesn't make sense…
13:30:38 <kristof> bitemyapp: What do you have to restrict the language too? Out of curiosity.
13:30:49 <kristof> Or I could wait for your talk to be posted somewhere :P will this be in the bay area?
13:30:53 <bitemyapp> jrmithdobbs: I'm not a Fay developer. I *wish* that was the case.
13:30:57 <bitemyapp> kristof: SF
13:31:00 <bitemyapp> kristof: Etsy
13:31:04 <Qett> Fuuzetsu: like substring?
13:31:05 <bitemyapp> kristof: CLJS meetup.
13:31:12 <jle`> is there an easy way to create javascript objects from, say, a list of key value tuples?
13:31:13 <bitemyapp> kristof: lightning talks, mine is one of them.
13:31:15 <Qett> check if 'asdf' contains 'df'
13:31:20 <bitemyapp> kristof: nobody's dumb enough to give me a whole slot.
13:31:20 <kristof> Maybe I should finally attend one of these
13:31:39 <jle`> on Fay
13:31:49 <jle`> (my previous question)
13:31:50 <Fuuzetsu> Qett: AFAIK there's a ByteString ‘isInfixOf’ defined somewhere.
13:31:54 <Fuuzetsu> @hoogle isInfixOf
13:31:54 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
13:31:55 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
13:31:55 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
13:32:01 <Fuuzetsu> there you go
13:32:10 <bitemyapp> kristof: I'd be happy to see you there, but if you're interested you should tell me sooner than later.
13:32:10 <Qett> ah ok
13:32:12 <Qett> thanks
13:32:45 <kristof> bitemyapp: I suppose I'll just go to the next one, then :P
13:32:58 <bitemyapp> kristof: you can't just make a judgment call?
13:32:59 <kristof> bitemyapp: Will these lightning talks find their way to the web?
13:33:10 <bitemyapp> kristof: it's extremely unlikely that that will happen.
13:33:12 <kristof> bitemyapp: Right now? I'm leaning toward "unable to attend"
13:33:41 <bitemyapp> kristof: I am considering options like using my computer to enable a friend in japan to participate.
13:33:47 <bitemyapp> kristof: you could get in on that too possibly.
13:34:20 <bitemyapp> hrm. unpacked, 60 million ints.
13:34:28 <bitemyapp> unboxed, actually, I should say.
13:34:55 <kristof> bitemyapp: Unfortunately, my engagements for tomorrow involve me out and about, so proximity to a computer is a highly unlikely.
13:35:16 <bitemyapp> 20 million with boxed arrays. Damn.
13:35:20 <abstract-alf> So, what's everyone's favorite lens library?
13:35:23 <bitemyapp> value types are apparently important >:)
13:35:25 <Fuuzetsu> lens
13:35:29 <bitemyapp> abstract-alf: lens
13:35:56 <abstract-alf> Thanks
13:36:18 <hpc> heh
13:36:34 <abstract-alf> I think I need lenses to write my Rubiks cube application
13:36:53 <abstract-alf> :-)
13:37:24 <kristof> bitemyapp: We were having a discussion here last night about high performance computing and the primary "tricks" for performant array processing are apparently data locality and memory reuse. So doesn't that mean that packed arrays are preferable?
13:37:32 <bitemyapp> if anyone is wondering, the 60 million / 20 million array-of-ints in GHC compares with a best case 10 million, typically closer to between 1 and 4 million ints in the same amount of memory on the JVM.
13:37:46 <bitemyapp> kristof: I misspoke, that's why I said, "oops, I mean unboxed"
13:37:48 <kristof> carter can pipe in if he feels like it
13:38:03 <bitemyapp> kristof: I'm speaking to linear-in-memory arrays with reference vs. value types.
13:38:03 <kristof> bitemyapp: Oh, I see.
13:38:23 <bitemyapp> value types are vastly superior to reference types in terms of compactness and linear access patterns for cache locality.
13:38:32 <bitemyapp> the CPU understands perfectly what walking an array looks like.
13:38:34 <kristof> but reference types are more flexible
13:38:49 <greg`> is haskell really that much more performant than java? i know is a dodgy question actually
13:38:57 <kristof> depends
13:38:57 <bitemyapp> greg`: you can't ask that generic of a question.
13:39:04 <kristof> really really really depends
13:39:09 <bitemyapp> greg`: I was comparing "how many ints can I fit into an array"
13:39:14 <greg`> ah
13:39:16 <greg`> ok
13:39:18 <kristof> greg`: For very static things, probably
13:39:21 <bitemyapp> greg`: answer to that question is, "Haskell wins, even in the naive case, by a lot"
13:39:33 <jrmithdobbs> "usually"
13:39:48 <bitemyapp> greg`: the fight is closer when their JIT gets to spin up and until 7.8, the IO substructures in the Java ecosystem are more finely tuned.
13:40:10 <bitemyapp> greg`: both ecosystems have their trade-offs, it depends on the sort of work you're doing.
13:40:18 <greg`> yeah im running a rc for 7.8
13:40:24 <bitemyapp> you can easily generate a lot of garbage in Haskell.
13:40:29 <bitemyapp> but you can easily avoid that, too.
13:40:38 <Qett> Hey, im getting this error: ambiguous occurence of hGetContents how do i solve this?
13:40:39 <markovirc> Hello Qett
13:40:40 <kristof> greg`: Tight, repetitive inner loops can be very well optimized by something called meta tracing
13:40:42 <greg`> i work in java mostly and do a little in python, haskell is more my hobby
13:40:43 <jrmithdobbs> they cut an rc?
13:40:51 <kristof> greg`: Which is only possible with JIT compilation.
13:40:55 <Qett> im getting one from Data.ByteString and one from System.IO
13:41:10 <Qett> I'm trying to use the Data.ByteString one
13:41:43 <bitemyapp> greg`: I do a mixture of Python and Clojure in my work, but I'm incorporating Haskell into my side projects and see some numerical and NLP work where Haskell might be nice.
13:41:52 <jrmithdobbs> kristof: i amazed at how much ghc can optimize out even doing dumb things like Text appends in such a loop with -O2
13:42:22 <bitemyapp> kristof: if you want to get more aggressive than simple unboxed ints, you could abuse http://hackage.haskell.org/package/bitwise-0.1/docs/Data-Array-BitArray.html
13:42:32 <greg`> jrmithdobbs what do you do to analyse ghc optimisation
13:42:36 <bitemyapp> kristof: I just wanted a rule-of-thumb for what I could do with 1gb of memory.
13:42:39 <kristof> jrmithdobbs: Sure, but the problem is that there are some things that you simply CAN'T know until runtime because they change, hence you have to "re-optimize" every so often.
13:42:52 <abstract-alf> jrmithdobbs: is there a string buffer type Haskell? You know, a mutable string builder
13:42:59 <jrmithdobbs> greg`: build with profiling
13:43:09 <bitemyapp> kristof: which is true, but when you really care about performance, you introduce invariance everywhere you possibly can.
13:43:09 <jrmithdobbs> abstract-alf: that's what Text is.
13:43:29 <jrmithdobbs> well that's what bytestring is, text is it's encoded cousin
13:43:37 <bitemyapp> kristof: the "shrug and leave-it-to-beaver" culture surrounding JITs is a cop-out and not realistic for when things "really" matter.
13:43:37 <kristof> bitemyapp: That is certainly a true statement. But if you REALLY care about performance, you didn't actually need that variance to begin with.
13:43:45 <abstract-alf> hi Tiffany
13:43:46 <bitemyapp> kristof: which is sorta my point.
13:44:02 <kristof> bitemyapp: Well I think the opposite point is that you DIDN'T really care about the performance.
13:44:37 <bitemyapp> kristof: right.
13:44:39 <kristof> There's a culture of "fast enough" which certainly isn't wrong. ...But the logical extreme of that is Ruby, so maybe you can be wrong about it eventually.
13:44:55 <bitemyapp> kristof: Haskell fits into the "fast enough and high level" bracket for me.
13:45:15 <bitemyapp> kristof: if I want to fiddle more than that, C++ or maybe eventually Rust when it isn't craziness week-in, week-out.
13:45:28 <bitemyapp> getting a Rust project more than 15 days old to compile is an...adventure.
13:45:29 <abstract-alf> bitemyapp: for me too
13:45:50 <kristof> bitemyapp: They're working toward a stable release now, though. So that "eventually" isn't far off.
13:45:56 <bitemyapp> kristof: higher level than Ruby, comparable with Java on some workloads, faster on others. Don't need much else.
13:46:07 <bitemyapp> kristof: hum, I guess, but I see some open questions still though.
13:46:12 <jrmithdobbs> bitemyapp: ya, i know they want input and stuff but i'll wait for them to decide what the language 1.0 spec is first
13:46:17 <kristof> None of them are tremendously language changing
13:46:30 <jrmithdobbs> bitemyapp: i just hope the higher order kind stuff that's been tossed around happens before then :(
13:46:41 <bitemyapp> kristof: yeah, but I'm also not using it a lot right now because I find the language a bit annoying to use when you're used to Haskell.
13:47:02 <abstract-alf> bitemyapp: isn't that most languages?
13:47:10 <abstract-alf> :-)
13:47:12 <bitemyapp> abstract-alf: I'm actually thinking of some specific problems.
13:47:19 <bitemyapp> not a generality.
13:47:24 <kristof> bitemyapp: Still feels too much like C* :P
13:47:27 <bitemyapp> I can read Python and Clojure comfortably, C++ under duress.
13:47:46 <bitemyapp> reading Rust isn't a skill I've fully developed yet so the type sigs still burn my eyes out of their sockets (sigil noise)
13:48:17 <hpc> oddly, coming from perl rust looks like operator noise to me...
13:49:20 <bitemyapp> hpc: how does applicative syntax treat you here?
13:49:49 <hpc> oh i have no problem with haskell; the two languages are sufficiently different ;)
13:50:48 <mjrosenb> @hoogle using
13:50:49 <lambdabot> Control.Parallel.Strategies using :: a -> Strategy a -> a
13:50:49 <lambdabot> Control.Seq using :: a -> Strategy a -> a
13:50:58 <kristof> bitemyapp: I didn't appreciate this until recently, but separating your type signatures from the body of your code is a really awesome thing, for readability and for comprehension
13:51:10 <greg`> really
13:51:39 <Qett> if i do:  word <- (getArgs >>= head)
13:51:43 <bitemyapp> kristof: yeah, that's why I like reading hackage documentation.
13:51:45 <Qett> shouldnt the type of word be string?
13:51:48 <mjrosenb> @hoogle (a->b) -> (b -> b -> c) -> (a -> a -> c)
13:51:48 <bitemyapp> kristof: it also makes refactoring easier.
13:51:48 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:51:49 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
13:51:49 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
13:51:53 <mjrosenb> on.
13:51:54 <hpc> :t getArgs
13:51:55 <lambdabot> Not in scope: `getArgs'
13:51:58 <mjrosenb> that is what I was looking for.
13:52:12 <bitemyapp> kristof: makes it easy to write a macro or just search-replace when swapping types.
13:52:23 <hpc> Qett: that seems a lot like it would be a type error
13:52:31 <hpc> :t (?getArgs >>= head)
13:52:32 <lambdabot> (Monad m, ?getArgs::m [m b]) => m b
13:52:53 <mjrosenb> I want to sort a list based on some mapping.  there is a pretty standard function that does this.
13:53:16 <mjrosenb> like, I have l, and I want to sort it by (map f l)
13:53:28 <Qett> hpc im trying to get the first element of getArgs which is of type IO [String]
13:53:43 <hpc> mjrosenb: sortBy (comparing f)
13:53:44 <Qett> so im trying to get the first argument
13:53:46 <mjrosenb> I know sortBy (X f) does what I want...
13:53:52 <mjrosenb> hpc: danke.
13:54:38 <kristof> bitemyapp: maybe this is my predilection toward lisp, but the type signatures are always secondary to me, which is why I want to be able to just look at some function code and not think types until I want to think about types
13:54:54 <bitemyapp> kristof: it depends on what I'm doing.
13:55:07 <bitemyapp> kristof: I like having them separate so that I can focus on types and code in turn, at different times.
13:55:09 <kristof> I suppose that's true
13:55:18 <jrmithdobbs> kristof: i find it annoying when they're too far away like all type definitions at the top of the file then implementation like you'd see in C
13:55:26 <bitemyapp> kristof: I like to just between type sigs and code when I'm learning other peoples' code, but only after getting a basic overview of the types of the API
13:55:42 <kristof> jrmithdobbs: That's dumb. Declare types, define function, rinse repeat.
13:55:48 <jrmithdobbs> ya
13:56:22 <kristof> bitemyapp: Well, I think seeing the definition of a declarative, high level function is more important than seeing its type signature. That might be preference.
13:56:51 <hpc> kristof: that's sort of like the logical conclusion of using types to guide programming
13:56:55 <mjrosenb> @hoogle comparing
13:56:55 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:57:07 <bitemyapp> kristof: definitely preference.
13:57:12 <hpc> where your types are so well thought out that you can completely forget they are there and go on values alone
13:57:43 <bitemyapp> kristof: you need the forest and the trees, IMHO.
13:57:57 <kristof> Maybe I'll come to that conclusion some day.
13:58:00 <kristof> Just not now :P
13:59:16 <Qett> @hoogle (System.Environment.getArgs >>= head)
13:59:16 <lambdabot> Parse error:
13:59:16 <lambdabot>   (System.Environment.getArgs >>= head)
13:59:16 <lambdabot>           ^
13:59:42 <Qett> wut
13:59:50 <bitemyapp> hum. 32-bit int and I'm getting 66mm in an unboxed array. surely I can do better?
14:00:15 <Qett> 66 millimeters?
14:00:19 <bitemyapp> already stomped aggressively packed JVM libraries. *taps chin*
14:00:45 <bitemyapp> Qett: UArray Int Int -> +RTS -M1g -> length arr -> 66,000,000
14:01:06 <Qett> oh
14:01:10 <Qett> micrometers ok
14:01:21 <hpc> lol
14:02:25 <bitemyapp> okay okay, I'll leave it alone.
14:02:27 <bitemyapp> Good to know though.
14:03:00 <hpc> bitemyapp: i expect you'll be able to allocate 2 (maybe 3?) gigs on a 32-bit system
14:03:32 <hpc> plus or minus stack and other stuff the OS keeps to itself
14:05:48 <Qett> i got it
14:06:06 <bitemyapp> hpc: the point is that given a memory constraint, how many ints can I store in an array
14:06:16 <bitemyapp> hpc: I wanted a rule of thumb measurement on a per gigabyte basis.
14:06:17 <Qett> its (getArgs >>= (return . head))
14:06:30 <Qett> so fuckin smert
14:06:49 <hpc> ah
14:06:51 <bitemyapp> hpc: so now I know that if I have boxed ints, I can store about ~20mm per gigabyte and if I have unboxed it's about ~66mm
14:06:56 <bitemyapp> hpc: er, Data.Array
14:07:01 <bitemyapp> Array and UArray
14:07:25 <hpc> bitemyapp: you should compare between 1g and 2g just to see what effect overhead has
14:07:30 <bitemyapp> I don't *think* it's secretly reboxing because the numbers came out differently, so I didn't force unpack anything.
14:07:35 <hpc> from the RTS, in particular
14:07:35 <bitemyapp> hpc: actually I already constrasted it with 1m
14:07:40 <hpc> oh, neat
14:07:42 <bitemyapp> hpc: but I can do that. Uno momento.
14:08:46 <hpc> i have a feeling the math comes out to a flat 4b/i
14:09:00 <bitemyapp> hpc: not quite, ~132,000,000 when using 2g
14:09:09 <bitemyapp> hpc: so there was a slight decrease in overhead from 1g to 2g
14:09:16 <hpc> heh
14:09:19 <bitemyapp> but this is one big array.
14:09:28 <bitemyapp> obviously the biggest drops in overhead were from 1m to 2g
14:09:41 <bitemyapp> I don't know if subarrays would make much of a difference or not.
14:09:54 <bitemyapp> they ordinarily would be just one pointer apiece.
14:10:03 <bitemyapp> but I can't make those kinds of assumptions about GHC, I'm too ignorant.
14:10:13 <bitemyapp> er, from 1m to 1g
14:10:38 <bitemyapp> hpc: so, since the overhead only improves rather than worsens, I think the 20/60 per 1 gb rule of thumb holds.
14:10:50 <bitemyapp> hpc: for relatively naive Array Int Int and UArray Int Int.
14:14:01 <ij> Are all divide-and-conquer algorithms recursive, but not vice versa?
14:15:22 <zett_zelett> You certainly cannot say that every recursive algorithm is some sort of divide-and-conquer-algorithm.
14:15:30 <nooodl> http://en.wikipedia.org/wiki/Divide_and_conquer_algorithm#Explicit_stack
14:16:20 <nooodl> i guess in haskell you'd end up using recursion, always
14:16:56 <DigitalKiwi> I've also been under the impression you can write any recursive algorithm iteratively and vice versa, but someone correct me if I'm wrong
14:17:58 <DigitalKiwi> actually that is more to say that an algorithm is not recursive or iterative in nature but can be expressed with one of those?
14:18:12 <zett_zelett> By "iteratively" you mean using a "while … do" construct?
14:18:31 <bitemyapp> DigitalKiwi: recursion and iteration can compute the same things.
14:18:33 <alipang> anyone here good w/ iteratees/enumerators?
14:19:03 <zett_zelett> bitemyapp: Absolutely sure?
14:20:13 <bitemyapp> zett_zelett: let me rephrase iteration as "loops"
14:20:28 <bitemyapp> iteration implies a purely collection-centric focus that isn't precisely what I had in mind.
14:21:16 <kristof> Navigating a tree using iteration doesn't sound fun.
14:21:31 <bitemyapp> kristof: you're fucking telling me.
14:21:43 <bitemyapp> kristof: I had to do a bunch of tree-oriented stuff not long ago at work in Python and Clojure
14:21:57 <kristof> bitemyapp: Clojure must have been simple for the task
14:22:07 <bitemyapp> kristof: it wasn't much better than Python.
14:22:19 <glaebhoerl> people, give me some practical things that you can (safely) do/express in a pure language which you couldn't otherwise. three big ones I can think of are lazy evaluation, rewrite rules, and STM. are there others? (I'm already among the faithful, so there's no need to enlighten w.r.t. the benefits of referential transparency, I'm just looking for this kind of specific thing)
14:22:27 <bitemyapp> kristof: loop/recur and reduce are no substitute for a blaster^H^H^H^H^H TCO at your side.
14:22:40 <kristof> bitemyapp: blame Java
14:22:41 <bitemyapp> glaebhoerl: get away from the referential transparency stuff.
14:22:47 <kristof> bitemyapp: I TCO all day in Common Lisp
14:22:48 <bitemyapp> kristof: Frege has TCO. I blame Hickey.
14:23:21 <bitemyapp> glaebhoerl: laziness is nice for its own sake. Reifying impurity to the type system is nice for its own sake. Don't make it into a misinformed pseudo-philosophical crusade.
14:23:47 <bitemyapp> kristof: I understand the tradeoffs he made, but really, there's a litany of annoyances to be found here.
14:23:59 <Platz> theorems for free?
14:24:01 <bitemyapp> kristof: Scala isn't much better. *angrily glares at flatMap*
14:24:23 <bitemyapp> Platz: purity-by-default and rigid polymorphism make that nice, yes.
14:24:50 <kristof> bitemyapp: So loop/recur is babysitting the compiler? I've heard similar complaints.
14:24:52 <bitemyapp> glaebhoerl: have you read Theorems for Free?
14:25:09 <bitemyapp> kristof: loop/recur gets transformed by the compiler, last I heard.
14:25:20 <bitemyapp> kristof: why you have to do that, I don't know. the trampolining was worse.
14:25:24 <glaebhoerl> bitemyapp: huh? what? I think you've managed to interpret what I wrote as something like the direct opposite of what I intended
14:25:37 <glaebhoerl> I'm *not* looking for a discussion about the benefits of purity. I already know them.
14:25:41 <benmachine> glaebhoerl: if it helps I'm also confused about what bitemyapp is saying
14:25:48 <bitemyapp> glaebhoerl: not really, I just don't think "referential transparency" is a good way to put it.
14:25:52 <glaebhoerl> I'm looking for specific things which can be done in pure languages but not (so easily) in impure ones.
14:25:57 <benmachine> however, the advice to read Theorems for Free is good
14:26:03 <bitemyapp> glaebhoerl: the component features of Haskell are nice in their own right, not "because of" a misunderstood subject.
14:26:20 <benmachine> or, well, "free theorems" is a great answer to your question
14:26:26 <benmachine> however you decide to learn about them
14:26:35 <glaebhoerl> I know about free theorems :)
14:26:46 <glaebhoerl> I dunno how to phrase my question properly
14:27:09 <greg`> kinda stuck on exercise 14 for 20 intermediate haskell problems , dont know how to change an [m b] to m [b]
14:27:17 <greg`> any clues, i dont want the answer
14:27:24 <Fuuzetsu> Is there a function ’foo >>= id’ somewhere?
14:27:32 <benmachine> greg`: the empty case is easy enough, right?
14:27:32 <apples> Fuuzetsu, join
14:27:41 <Fuuzetsu> oh, right
14:27:58 <benmachine> greg`: which means you just have to deal with the (x:xs) case
14:28:14 <greg`> hmmm thanks
14:28:15 <yogurt_truck> glaebhoerl: check out the "why FP matters" paper by Hughes
14:28:17 <kristof> glaebhoerl: There are lots of ways of doing things. Only some of those things are well understood, well behaved, etc. Pure functions are some of those well understood things.
14:28:20 <greg`> ill digest
14:28:29 <benmachine> greg`: for which, well, you recurse for the xs and then work out hwo to get the x in there
14:29:04 <greg`> ah  i see
14:29:08 <bernalex> if I have foo = ["1", "2", "lols!"] and bar = [Just 1, Just 2, Nothing] -- how do I get "lols!" from foo based on the fact that the item on its index in bar is Nothing?
14:29:22 <glaebhoerl> like, in a language with unrestricted side effects ("everything is in IO") you can't do STM nicely and you can't do something like RULES because side effects get in the way. I'm wondering if there's any other examples of specific features/constructs along these lines which you can only really do in a pure language.
14:29:23 <greg`> thanks
14:29:37 <bernalex> so I have a [String] and a [Maybe Int], and whenever the latter is a Nothing, I want the item on its index in the former
14:29:39 <benmachine> bernalex: I'm not sure I completely understand, but Data.List.findIndex may help
14:29:42 <benmachine> :t findIndex
14:29:43 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
14:29:47 <glaebhoerl> (yogurt_truck: I've read that too :)
14:29:57 <benmachine> > findIndex isNothing [Just (), Just (), Nothing]
14:29:58 <lambdabot>  Just 2
14:30:08 <bernalex> benmachine: nice! thanks
14:30:10 <benmachine> :t findIndices -- I don't remember if this exists or if I imagined it
14:30:11 <lambdabot> (a -> Bool) -> [a] -> [Int]
14:30:13 <benmachine> oh, cool :)
14:30:21 <bernalex> even neater!
14:30:40 <benmachine> bernalex: also consider: zipWith and filter
14:30:43 <benmachine> or zip and filter
14:30:51 <bernalex> I will. :-) thanks
14:30:59 <benmachine> in fact I think a zip-based solution is better than a findIndex based one
14:31:10 <benmachine> but YMMV
14:31:27 <Fuuzetsu> using hs-boot files feels so dirty, it's like I'm cheating
14:31:36 <yogurt_truck> glaebhoerl: the question is oddly framed though. Because you're asking for "what"s, but purity and FP are a difference in "how" not in "what". You can achieve pretty much anything with any style
14:32:10 <kristof> glaebhoerl: Like bitemyapp said, Theorems for Free is a good read. The very modus operandi of math is 1) establish paremeters and 2) make some statements that are true when those parameters are satisfied. So the skinny is: have pure functions, and then suddenly you can MATH your computer science. omgwut?
14:32:40 <benmachine> yogurt_truck: that's not really true, though
14:32:53 <benmachine> you can compute the same functions, but that's not the only interesting thing
14:33:22 <benmachine> you can get guarantees about pure functions that you can't about non-pure functions, that's a concrete difference
14:33:41 <benmachine> it's not a concrete difference to what you're capable of, but it's still an achievement of sorts
14:33:42 <yogurt_truck> benmachine: yes, I assumed the question was about end results
14:34:04 <Platz> you can code purely in an imperative language, but can't make others do so.  That's basically why microsoft gave up on STM for .net
14:34:29 <yogurt_truck> obviously there's ton of things you just _cannot_ have in your software design process if your tools just don't offer certain things
14:34:44 <yogurt_truck> so.. I don't know. the question should be more specific, maybe.
14:35:06 <benmachine> I think it was a perfectly fine question and "free theorems" was one answer
14:35:23 <benmachine> and a fourth answer to a question that already had three is not bad going :P
14:35:46 <yogurt_truck> fair enough
14:36:02 <benmachine> one might argue that lambdabot-style interactive evaluators of untrusted code is easier in a pure language
14:36:14 <benmachine> but that's a less clear case
14:36:27 <benmachine> glaebhoerl: just in case you're not still paying attention, ^
14:36:43 <glaebhoerl> benmachine: free theorems aren't something you're taking advantage of in the language itself (except perhaps through rewrite rules) though, only when reasoning about it from "outside"
14:36:50 <glaebhoerl> (also I am:)
14:37:14 <bernalex> hm. I probably won't end up with this in the code, but I got kind of curious now. if I have findIndices isNothing xs -- how do I make a list of !!-functions based on that list?
14:37:24 <bernalex> so for
14:37:26 <bernalex> > findIndices isNothing  [Nothing, Just 1, Just 2, Nothing]
14:37:27 <lambdabot>  [0,3]
14:37:39 <bernalex> how do I make [(!! 0), (!! 3)]?
14:37:50 <benmachine> map (\x -> (!! x))
14:37:57 <bernalex> oh wait, !! takes the list first then the number, I forgot
14:38:16 <glaebhoerl> anyway, this makes me reasonably confident I haven't missed some other really obvious thing beyond the ones I listed
14:38:30 <bernalex> benmachine: ah
14:41:27 <ReinH> > (sequence $ fmap (flip (!!)) [0,3]) [1..]
14:41:28 <lambdabot>  [1,4]
14:41:59 <ReinH> er
14:42:27 <ReinH> > mapM (flip (!!)) [0,3] $ [1..]
14:42:28 <lambdabot>  [1,4]
14:42:54 <ReinH> I finally remembered what mapM is
14:43:01 <bernalex> hehe
14:43:27 <HugoDaniel> is unordered-containers "better" than cityhash on a intmap ?
14:43:43 <ReinH> HugoDaniel: "cityhash"?
14:44:00 <ij> > 1 --test
14:44:01 <lambdabot>  1
14:44:11 <HugoDaniel> ReinH: http://hackage.haskell.org/package/cityhash
14:44:22 <ReinH> Ah.
14:44:31 <ReinH> HugoDaniel: if you have an intmap, why don't you use IntMap?
14:44:40 <bitemyapp> kristof: kmett's comments here: http://www.reddit.com/r/haskell/comments/1j9n5y/extensible_effects_an_alternative_to_monad/
14:44:55 <HugoDaniel> cityhash hashes to an int, and then intmap on that int
14:45:30 <ReinH> bitemyapp: damn it edwardk is too smart
14:45:31 <HugoDaniel> actually it hashes to word64, so fromIntegral kills it
14:46:04 <ReinH> HugoDaniel: well, HashMap requires a Hashable
14:46:28 <HugoDaniel> yeah, so the hashing is not even done by hashmap
14:47:05 <Qett> is there a version of filter that takes a function that converts from one type to another?
14:47:19 <HugoDaniel> qett you could do it with a fold
14:47:33 <Qett> oh ok ill look it up
14:47:41 <ReinH> HugoDaniel: well, a Word64 is Hashable
14:47:44 <HugoDaniel> a simple fold(r|l)
14:47:54 <Qett> ty
14:48:04 <HugoDaniel> yes, but intmap takes an int, so fromIntegral would be necessary to get to the values... and fromIntegral is a performance hog
14:48:24 <ReinH> HugoDaniel: I'm saying write your own Hashable using cityhash for use in HashMap
14:49:15 <ReinH> HugoDaniel: you can use one of citymap's salted hash functions a la http://hackage.haskell.org/package/hashable-1.2.1.0/docs/Data-Hashable.html
14:49:25 <ReinH> (the "Writing instances by hand" section)
14:50:07 <ReinH> but you'd be doing two roundtrips: one from your type to Word64, then hashing the Word64 again
14:50:34 <ReinH> which uses a fromIntegral
14:50:39 <ReinH> so no real gain there
14:50:50 <HugoDaniel> yes
14:51:17 <ReinH> HugoDaniel: write or find a Word64Map? :)
14:51:34 <HugoDaniel> :)
14:52:20 <nisstyre> Have there been any attempts at translating Haskell code to Clean? I looked at Clean recently but it seems there's almost no libraries, and it's very hard to google for anything because of the name (and github returns very few)
14:52:50 <nisstyre> kind of unfortunate because the compiler is really cool
14:52:58 <nisstyre> graph reduction, uniqueness types, and so on
14:53:11 <silasm> languages need to start optimizing for google searches. "make" is impossible to google for as well.
14:53:23 <dhrosa> "go"
14:53:27 <ReinH> There's a language called blog.
14:53:33 <silasm> heh
14:53:55 <ReinH> it's a bayesian logic language
14:54:01 <nisstyre> I'd think a Haskell 98 translator to Clean would be fairly easy though
14:54:10 <ReinH> https://sites.google.com/site/bloginference/
14:54:17 <nisstyre> except for IO stuff
14:54:29 <silasm> dhrosa: go is particularly ironic given google made it. Maybe they wanted the additional traffic generated by having to refine your search several times ;)
14:54:41 <bernalex> is there a utility function for surrounding a string with a char?
14:54:43 <ReinH> nisstyre: no need for IO, we just run Clean programs to keep the office warm.
14:55:13 <ReinH> bernalex: there are pretty print libraries that will do that
14:55:13 <nisstyre> ReinH: they're too efficient, Ruby works better for that
14:55:16 <silasm> ReinH: I legitimately do that with some of mine.
14:55:19 <bitemyapp> silasm: the example set by the amount of forethought put into the name was followed very close by the rest of the design process for Golang.
14:55:25 <bernalex> so map (theFunctionImLookingFor 't') ["foo", "bar"] would give ["tfoot", "tbart"]
14:55:28 <ReinH> bernalex: but if you're doing a lot of that then you probably don't want String
14:55:29 <bitemyapp> silasm: so they're at least consistent in that respect.
14:55:35 <bernalex> ReinH: not a lot
14:55:44 <bernalex> perf is not an issue here
14:56:04 <Athas> How does the 'bound' library compare performance-wise to using something like the Rapier method from GHC?
14:56:10 <Kaini> > map ("t" ++) ["foo", "bar"]
14:56:11 <lambdabot>  ["tfoo","tbar"]
14:56:12 <ReinH> you can import an entire pretty print library or just write your surround x xs = (x:xs) ++ [x]
14:56:36 <supki> > ["foo", "bar"] ^.. folded.re (prefixed "t".suffixed "t")
14:56:36 <pavonia> > map ('t' :) ["foo", "bar"]
14:56:37 <lambdabot>  ["tfoo","tbar"]
14:56:37 <lambdabot>  can't find file: L.hs
14:56:48 <ReinH> supki: nice
14:56:57 <ReinH> except for the part where you broke it
14:56:59 <bmuk__> If I was going to make my own instruction set (for an FPGA or physical cpu), how feasible would it be to base it on Core or the lambda calculus?
14:57:00 <bernalex> ReinH: I already have what you wrote. to the letter!
14:57:07 <ReinH> bernalex: well then use it :)
14:57:08 <bergmark> i can't figure out how to write this case statement on one line, any ideas? http://lpaste.net/99084
14:57:13 <bernalex> ReinH: I just thought I'd check if there was some function for this already. :-)
14:57:25 <bergmark> s/statement/expression/ :/
14:57:53 <ReinH> > let f 1 = 2; f 5 = 6 in f 1
14:57:54 <lambdabot>  2
14:58:21 <pavonia> bergmark: which reduces to f = 2
14:58:52 <geekosaur> http://lpaste.net/99085
14:59:08 <geekosaur> (I am assuming it's the structure you care about and not the effects, which are trivial)
14:59:16 <bergmark> aye, thanks geekosaur!
14:59:24 <ReinH> not sure that the one-liner is any better
14:59:28 <geekosaur> it's not
14:59:41 <geekosaur> you can do it, the question is why you'd want to...
15:01:46 <bergmark> heh i'm playing with haskell-src-exts
15:03:17 <bernalex> uhm if I have putStrLn "foo", how do I make a map that maps 'putStrLn "foo" ++' on a list of strings? so if I have ["one", "two", "three"] -- I want to call putStrLn "foo" ++ "one", putStrLn "foo" ++ "two" and putStrLn "foo" ++ "three".
15:03:35 <geekosaur> :t mapM
15:03:35 <prooftechnique> :t mapM_
15:03:36 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
15:03:36 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:03:42 <geekosaur> yeh, mapM_ is better
15:04:27 <prooftechnique> > mapM_ (putStrLn . ("foo" ++)) ["one", "two", "three"]
15:04:28 <lambdabot>  <IO ()>
15:05:30 <bernalex> ahhh you compose it. neat. thanks!
15:06:00 <prooftechnique> There's probably some cute lens thing you can do for the same effect, too
15:06:11 <benmachine> yes but that's true of most things you can do with computers
15:06:16 <prooftechnique> Hahaha
15:06:17 <bernalex> it's great see that I am at least on the right track before I ask questions here. a few days ago I triumphantly converted to and from do-notation, and explained a friend how <=< works. feels good to be getting better.
15:06:21 <bernalex> benmachine: hahaha
15:06:37 <benmachine> bernalex: :)
15:06:57 <silasm> mapM_'s type signature sure highlights the fact that mapM is almost nothing like map. I did a double-take for a second there.
15:07:19 <prooftechnique> :t fmap
15:07:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:08:18 <ij> silasm, I wouldn't say it's nothing like map.
15:08:26 <silasm> with respect to independence of previous/following data and output length, I mean.
15:08:28 <benmachine> it's map but with Kleisli arrows
15:08:30 <benmachine> sorta
15:09:18 <silasm> if you have mapM over the State monad, for example, you have absolutely no guarantees that each element can be calculated in parallel (as you do with map), or that the output will be a list of the same length.
15:09:45 <silasm> "over" was probably the wrong word there, but you get the idea.
15:10:40 <silasm> and you might not have those with other Functors, but mapM only operates on lists, so I think that argument doesn't really apply.
15:10:52 <benmachine> silasm: the output will be a list of the same length!
15:11:10 <benmachine> insofar as the output is a list, anyway :P
15:11:30 <silasm> benmachine: really? I sure was foolish for doing a State mapM for my compression then, wasn't I?
15:12:15 <prooftechnique> @hoogle (Functor f, Monad m) => (a -> m b) -> f a -> m (f b)
15:12:15 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:12:16 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
15:12:16 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:12:21 <prooftechnique> Aha
15:12:40 <benmachine> prooftechnique: see also: traverse
15:12:43 <gangstalang> sup nigs
15:12:47 <prooftechnique> :t traverse
15:12:48 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
15:13:04 <gangstalang> yo whats the word on the streets bout lazy file reading
15:13:07 <silasm> (I really was, because ST was way better, but the point is I was easily able to skip over elements of the input list without adding anything to the output)
15:13:40 <benmachine> silasm: I guess it depends what you mean by output
15:14:13 <prooftechnique> gangstalang: readFile is the word
15:14:26 <S11001001> silasm: in general traversal over t a can't alter the traversed structure t
15:14:27 <gangstalang> that shit good tho rite?
15:14:28 <benmachine> silasm: but if you want to provide me with some f such that length (evalState (mapM f xs)) is different from length xs, then I will be surprised
15:14:50 <S11001001> s,in general,,
15:15:04 <prooftechnique> gangstalang: shitchyeah
15:15:12 <gangstalang> aight ma niga peace
15:15:16 <benmachine> S11001001: by virtue of the law traverse id = id
15:15:20 <silasm> benmachine: actually remembering a little better I'm talking out my ass, sorry. I was mapping to maybes and then using catmaybes. :S
15:15:38 <benmachine> silasm: ah, yeah, that makes more sense :
15:15:39 <benmachine> :)
15:15:45 <sayyid> hi everyone :D
15:15:49 <prooftechnique> hi, sayyid
15:15:53 <benmachine> hi!
15:15:54 <markovirc> Hello prooftechnique
15:15:56 <abstract-alf> ryo
15:15:59 <markovirc> Hello benmachine
15:16:13 <silasm> but there is still the possibility of dependency on previous data, which I always thought was weird. I still feel like mapM behaves more like a fold in that respect.
15:16:19 <roconnor> @botsnack
15:16:19 <lambdabot> :)
15:16:21 <silasm> (with certain monads)
15:17:01 <silasm> maybe if I feel so strongly about it I should just use foldM to build the output list.
15:17:34 <S11001001> silasm: sure, as you take a to f b in t a, the bs in t b can be interdependent; but that can't alter the t structure, still.
15:17:43 <sayyid> just curious, do any of you know a mathematical problems site called project euler?
15:17:52 <prooftechnique> Is 7.8 when all that Traversable/Foldable generalization in the Prelude is happening, or is that 7.10?
15:18:01 <prooftechnique> sayyid: Yup
15:18:14 <sayyid> do you use haskell while solving the problems?
15:18:37 <roboguy_> sayyid: I usually use haskell for project euler
15:18:39 <identity> sayyid: I've solved all of mine in haskell
15:18:45 <bitemyapp> Integer is cheating.
15:18:46 <identity> which is just shy of 60 iirc
15:18:49 <identity> bitemyapp: lol
15:18:55 <roboguy_> in fact, I think I've only used haskell for project euler so far
15:19:04 <sayyid> well done, that's an admirable feat :D
15:19:23 <bitemyapp> Integer is for quiche eaters.
15:19:39 <roboguy_> sayyid: I don't know, I found haskell easier to use for project euler for some of the problems
15:19:42 <bitemyapp> Real programmers solve their problems with pencil, paper, maths, and bitmasking.
15:19:57 <bitemyapp> roboguy_: my complaint with Euler is that it has precious little to do with programming most of the time
15:20:03 <bitemyapp> roboguy_: and more to do with puzzly mathy thingies.
15:20:13 <roboguy_> bitemyapp: yeah, I agree
15:20:16 <bitemyapp> that happen to lend themselves to computational solutions, but aren't necessarily to the point.
15:20:27 <roboguy_> bitemyapp: have you seen HackerRank?
15:20:34 <bitemyapp> roboguy_: yeah, but I'm equally skeptical.
15:20:39 <roboguy_> it's a little more programming focused, I feel
15:20:49 <bitemyapp> it's too bleh.
15:20:59 <bitemyapp> roboguy_: one thing to note is that I come to this subject from the perspective of somebody that wants a reliable way to evaluate programmers for fire.
15:21:02 <bitemyapp> hire*
15:21:04 <bitemyapp> yeesh fingers.
15:21:14 <prooftechnique> Speaking of programming things, does anyone know how long it takes for Matasano to respond about the crypto challenges?
15:21:21 <bitemyapp> roboguy_: so I want a static, reliable set of problems that evaluate different competencies.
15:21:46 <bitemyapp> prooftechnique: I didn't do those ones, I did the first couple problems of the Stripe CTF 3. Didn't like it much. How was Matasano's?
15:21:46 <silasm> bitemyapp: I reread that at least twice before realizing it was a typo.
15:21:50 <roboguy_> bitemyapp: you don't think hackerrank/interviewstreet provides that?
15:22:00 <silasm> I was afraid for my life for a second
15:22:01 <bitemyapp> roboguy_: no, that stuff is garbage.
15:22:03 <prooftechnique> bitemyapp: I dunno, yet. I'm waiting for them to send me the first challenges.
15:22:20 <bitemyapp> roboguy_: those services are liability protection, not a way to evaluate programmer skill.
15:22:40 <bitemyapp> they're a proxy for IQ but companies hiring employees in the US cannot administer IQ tests legally
15:22:51 <bitemyapp> so they abstract it to bullshit like hackerrank/interviewstreet
15:22:53 <Qett> bitemyapp: in person evaluation?
15:22:54 <roboguy_> bitemyapp: hmm, what's the beest way to evaluate programmer skill, would you say?
15:23:10 <bitemyapp> Qett: I do a mix, but I try to nail down a focused and refined set of problems.
15:23:29 <Cr8> I got carried away with gitcoin on stripe ctf
15:23:39 <bitemyapp> roboguy_: structured conversations about problems a long way. Some programmers do very well with short "homework" assignments too.
15:23:39 <Cr8> and didn't go much farther after it wanted me to write node.js
15:23:52 <sayyid> you sound a lot like teachers haha
15:23:59 <bitemyapp> Cr8: yeah I was kinda *sigh* about gitcoin.
15:24:17 <Cr8> I had fun with it until dudes started GPU mining
15:24:21 <bitemyapp> Cr8: I was really hoping for more interesting problems than what they came up with.
15:24:30 <roboguy_> bitemyapp: that makes sense. someday, I'm going to find out what it's like to apply for a programming job...
15:24:34 <Cr8> but I felt the problem set
15:24:38 <Axman6> so, when using monad transformers, is there a preferred package these days?
15:24:38 <bitemyapp> roboguy_: it varies.
15:24:41 <Cr8> wasn't really "distributed systems"
15:24:47 <bitemyapp> Cr8: that's why I was disappointed!
15:24:48 <Axman6> specifically need ContC and StateT
15:24:57 <bitemyapp> Cr8: my god, I was so excited when they announced it. then :(
15:25:01 <Cr8> the whole time I was playing that was in the back of my brain
15:25:04 <roboguy_> I've been programming off and on for almost 10 years, so I probably should apply for a programming job at some point haha
15:25:16 <ij> not so sure about that
15:25:20 <ij> roboguy_, ^
15:25:23 <Cr8> and I'm like "oh man everyone who finishes this is going to think they're a distsys superstar :S"
15:25:24 <roboguy_> ij: why not?
15:25:25 <bitemyapp> roboguy_: I don't think so.
15:25:31 <ij> roboguy_, sucks out joy
15:25:34 <sayyid> quick question about irc: can you tell me how to direct a message toward someone, like "person's_name": ?
15:25:41 <bitemyapp> roboguy_: it's a very different experience working professionally as a programmer and it requires a level of discipline above & beyond playing at home.
15:25:48 <bitemyapp> sayyid: like this.
15:25:48 <roboguy_> sayyid: do just that
15:25:53 <ij> roboguy_, You'll have to abide the bosses.
15:25:53 <bitemyapp> sayyid: see this? that.
15:26:04 <bitemyapp> sayyid: I type say<TAB> to auto-complete your name.
15:26:11 <roboguy_> bitemyapp: oh, I know. I think I'd get used to it
15:26:11 <bitemyapp> it inserts the : and the <SPACE>
15:26:18 <bitemyapp> roboguy_: well. go for it then.
15:26:30 <bitemyapp> roboguy_: how old are you? where are you?
15:26:33 <sayyid> oh, ok
15:26:43 <roboguy_> bitemyapp: I'm 22 and I'm in Kansas
15:26:52 <bitemyapp> Kansas is sub-optimal.
15:27:01 <roboguy_> haha, you're telling me!
15:27:03 <Cr8> I was in Arkansas until a bit over a year ago
15:27:22 <Cr8> it's levenshtein and euclidean close to Kansas
15:27:34 <silasm> roboguy_: you've been programming since you were 12? I'm jealous.
15:27:59 <bitemyapp> silasm: I started around the same ages.
15:28:04 <bitemyapp> silasm: but I was working as a programmer at 18.
15:28:08 <DigitalKiwi> y-combinator material right there
15:28:12 <bitemyapp> DigitalKiwi: ugh.
15:28:14 <bitemyapp> DigitalKiwi: no.
15:28:16 <Cr8> guh
15:28:30 <they> I figure that's the average age for Haskell enthusiests.
15:28:39 <they> They're the same types that would have liked programming since an early age.
15:28:50 <roboguy_> now a Haskell job would be pretty awesome. very unlikely though
15:28:53 <bitemyapp> DigitalKiwi: startups are not isomorphic with working as a programmer. A knack-for and an interest in sales & marketing are often more important to succeed.
15:29:16 <silasm> roboguy_: I'm debating over whether or not I'd even take a haskell job for the aforementioned "kills the magic" reasons.
15:29:17 <bitemyapp> roboguy_: if you *really* want that, you're going to need to 1. get good 2. travel
15:29:27 <Cr8> knack for sales == being a sociopath
15:29:32 <silasm> then again I can't complain about editing makefiles forever, can I?
15:29:32 <bitemyapp> Cr8: hey :(
15:29:37 <DigitalKiwi> I was making a joke about paul graham saying all founders need to be programming since they were 12
15:29:41 <bitemyapp> silasm: I've gotten to use my language of choice at work. I don't think it's a big deal.
15:29:50 <bitemyapp> Cr8: wait a tick, since when have you hung out in this channel?
15:29:56 <roboguy_> silasm: I have thought about that, but I have to wonder if it's as bad as they say
15:30:00 <bitemyapp> DigitalKiwi: that's not really what he said.
15:30:02 <roboguy_> it probably depends
15:30:07 <Cr8> recently
15:30:11 <DigitalKiwi> it isn't but it's what people heard
15:30:45 <Cr8> I've been writing tiny one off programs in Haskell lately, and now grok it enough to know what I'm doing with xmonad, haven't written anything that interesting yet tho
15:30:48 <roboguy_> bitemyapp: yeah. maybe when I get over my fear of flying
15:31:00 <ij> Startups are intersting only for capitalists.
15:31:03 <DigitalKiwi> btw did they ever get a woman speaker at that conference their doing
15:31:20 <DigitalKiwi> last i looked all they had was a single judge if tht
15:32:13 <bitemyapp> hrm. dwarf fortress on Linux with a gaming desktop is muy nice.
15:32:25 <silasm> ij: I'm working at a "startup" right now that's doing fine because we have an actual product the market wants and 60-80 people working there. The 3-5 person startup I briefly worked for was a completely different can of worms, though.
15:32:44 <bitemyapp> silasm: gotta love those perpetual-disaster startups.
15:32:57 <bitemyapp> can't rely on "size" as a heuristic for quality though.
15:33:25 <Cr8> "we burn money fast"
15:33:31 <roboguy_> I've thought about trying to start a company but that seems pretty risky. also, I'd need a decent idae
15:33:32 <bitemyapp> somehow I'm not surprised this game isn't multi-threaded.
15:33:32 <roboguy_> *idea
15:33:46 <bitemyapp> roboguy_: having a decent idea is far, far from being the most important or difficult aspect.
15:33:52 <silasm> bitemyapp: old one mainly had an issue of a) business guy leaving the project for months at a time and b) a GPL library dependency we couldn't deal with.
15:34:22 <bitemyapp> roboguy_: it's a career path that will de-emphasize the utility of your programming skills and make any deficiencies in sales or social skills glaring.
15:34:23 <silasm> my current job can go to market fine with the GPL, so that's nice.
15:34:55 <bitemyapp> silasm: that's a good place to be. I've been open sourcing stuff I do at work lately.
15:35:08 <bitemyapp> silasm: I had a coworker inquiring last night to make *certain* I was open sourcing my work, haha.
15:35:25 <roboguy_> bitemyapp: well, the good thing about that is that my dad knows a lot about sales and I know he'd give me some advice
15:35:27 <bitemyapp> I like the warm fuzzies I get from that.
15:35:40 <bitemyapp> roboguy_: sales is about practice.
15:35:41 <silasm> bitemyapp: yeah it's a great market to be in. I just wish I could work in a different department than the build system, hehe.
15:35:45 <bitemyapp> roboguy_: practice on somebody else's dollar.
15:35:56 <bitemyapp> roboguy_: programming is about practice. Practice on somebody else's dollar.
15:36:06 <bitemyapp> roboguy_: entrepreneurship is about practice. Practice on somebody else's dollar.
15:36:11 <bitemyapp> roboguy_: tl;dr get a fuckin' job.
15:36:18 <roboguy_> haha, yeah
15:36:38 <FUZxxl> Java – the language that lacks so many features that you call the workarounds "design patterns" and declare them to be a major strength of the language.
15:36:43 <FUZxxl> Java, go fuck yourself.
15:37:03 <bitemyapp> FUZxxl: I get your point, but there are "patterns" in FP even if they're more principled and composable.
15:37:21 <bitemyapp> being able to do things in your language without *necessarily* having to reify them to the compiler is valuable.
15:37:23 <silasm> FUZxxl: me throughout all of my OOD class. Had a good laugh.
15:37:25 <identity> DesignPatternFactoryFactoryWorkerFactory
15:37:29 <yogurt_truck> FUZxxl: https://twitter.com/lambdatoast/status/425803352211857408
15:37:37 <bitemyapp> identity: State Monad?
15:37:41 <benmachine> bitemyapp: it's not "patterns" so much as "Java patterns" that are being objected to here, I suspect
15:37:50 <ij> Too bad so little people know that java's a shit language. Announce it at any mediocre programmer bunch and they'll look at you weirdly.
15:37:53 <roboguy_> right now, the most frustrating programming-related thing is that I'm a CS major and they won't let me test out of any programming classes
15:37:54 <bitemyapp> benmachine: prolly, but I wish people wouldn't poison the vocab.
15:37:54 <identity> bitemyapp: Not enterprise enough
15:38:01 * bitemyapp shrugs and rolls eyes
15:38:18 <identity> roboguy_: I hadn't even thought of doing that myself. I, too am doing CS and the programming classes are laughably easy for me
15:38:41 <bitemyapp> roboguy_: they want your munny.
15:38:50 <Cr8> lots of programming classes aren't worth the bother >>
15:38:53 <roboguy_> bitemyapp: I'm well aware, hah
15:38:56 <silasm> roboguy_: what classes are you taking that you'd test out of?
15:38:59 <identity> <- free uni, yay.
15:39:03 <identity> Hurray for socialism!
15:39:05 <they> Java (as a platform) is made so much better with Scala and Clojure, though.
15:39:14 <identity> Free? I'm sorry. I mean I get paid
15:39:33 <ij> Free uni isn't socialism.
15:39:43 <FUZxxl> bitemyapp: There is a difference between a pattern you use because it's the best way to do something and a pattern you use because the best way to do something is impossible because of language restrictions.
15:39:46 <roboguy_> silasm: mainly the C++ class, programming language paradigms (which uses racket) and the programming class I'm in now (software design)
15:39:54 <FUZxxl> The later kind is called "design patterns"
15:39:55 <identity> they: I hate scala because they used to offer a Haskell class at my uni, but then the Haskell guy left and they had to use the Scala guy.
15:39:55 <silasm> identity: where, exactly? (unless you mean PhD, in which case, yeah)
15:39:56 <roboguy_> software design might be a good thing though
15:40:02 <identity> silasm: Denmark.
15:40:04 <Cr8> I'd definitely like to have taken more theory though
15:40:07 <identity> ij: Denmark is pretty much socialism.
15:40:10 <yogurt_truck> free uni is just someone-else-pays uni. there's no free anything.
15:40:11 <Cr8> i had to pay for my own school tho
15:40:11 <roboguy_> I'm going to have to work with other people on projects
15:40:12 <identity> like, everywhere.
15:40:15 <bitemyapp> FUZxxl: I don't think anything people do in Java is very close to the best way to do things in Java.
15:40:21 <identity> luvy-duvy political correctness and backpatting and handholding
15:40:32 <bitemyapp> Cr8: moar category theory >:)
15:40:47 <Cr8> yeah yeah
15:40:59 <bitemyapp> FUZxxl: I know it baffles people but I actually like the style (structure, not syntax) Hickey used in Clojure.
15:41:08 <bitemyapp> of Java, that is.
15:41:10 <roboguy_> I wish my college had a category theory class. although, one of the programming professors is relatively well known in the haskell world!
15:41:41 <bitemyapp> roboguy_: dammit I can't google anything because of: http://en.wikipedia.org/wiki/Haskell_Indian_Nations_University
15:41:59 <FUZxxl> bitemyapp: I wonder how the guys inventing Java ever thought you could write good programs in Java.
15:42:05 <silasm> roboguy_: one of our professors is Cay Horstman (writer of Big Java). Guess what that means the ONLY language we use is?
15:42:10 <bitemyapp> FUZxxl: uh, coming from C++? Are you serious?
15:42:22 <bitemyapp> FUZxxl: all people really had for applications programming back then was turbopascal, C, and C++.
15:42:27 <identity> Examining some other classes I am to take in a couple of years I saw that we may get a taste of haskell in a programming class, "programming languages", but the professor uses hugs for some reason
15:42:28 <roboguy_> bitemyapp: that's practically next door. professor Andy Gill is the guy i'm talking about
15:42:36 <bitemyapp> FUZxxl: Oak/Java was a huge boost to productivity for people unwilling to use ML or Lisp.
15:42:43 <shiona> I wish my university had even something on type theory or even non c++-programming
15:42:54 <FUZxxl> Every Java stuff I see is an artificially bloated clusterfuck because people have to throw in unneeded abstractions beforehand as it is almost impossible to refactor your code if you missed to do one abstraction.
15:43:06 <prooftechnique> We used OCaml in our PL class, but we didn't do much with it
15:43:32 <silasm> FUZxxl: yeah Java was a big thing back then. If you ignore functional languages, Java looks like a shining example of type safety too.
15:43:40 <bitemyapp> shiona: http://i.imgur.com/qTzXuJK.jpg
15:43:42 <yogurt_truck> I heard OCaml is often the choice of (at least introductory) CS education in france
15:43:46 <silasm> (oh and Ada, probably, you'd have to ignore that)
15:43:47 <bitemyapp> silasm: eh, no.
15:43:50 <FUZxxl> I look at Go for something that could be "Java done right"
15:43:54 <shiona> bitemyapp: you scare me
15:43:55 <bitemyapp> silasm: you don't need to know FP to know Java's type system is garbage.
15:43:56 <ij> identity, What do you constitute as socialism?
15:43:58 <bitemyapp> FUZxxl: Go is fucking awful.
15:44:02 <prooftechnique> yogurt_truck: Probably because they invented it :D
15:44:14 <prooftechnique> bitemyapp: Agreed
15:44:17 <bitemyapp> silasm: the subtyping and covariance defaults say it all.
15:44:21 <ij> bitemyapp, It's a better C. It does the job.
15:44:30 <bitemyapp> ij: it's not and no it fucking doesn't.
15:44:33 <yogurt_truck> FUZxxl: Go is 99% shit + CSP.
15:44:34 <FUZxxl> bitemyapp: Well, the language is nowhere close to final. Generics will come sooner or later. BTW, what is it that you hate in Go?
15:44:46 <FUZxxl> yogurt_truck: care to elaborate?
15:44:48 <silasm> bitemyapp: I never said its type /system/ is good. It's awful. The whole design is awful. But compared to the other top 10 on the TIOBE index or whatever (which is saying almost nothing), it's glorious.
15:44:49 <bitemyapp> ij: Go doesn't suffice anywhere people would use C these days and it's a worse applications language than Java or Haskell.
15:44:55 <bitemyapp> silasm: no it's not.
15:45:04 <bitemyapp> silasm: I'd rather use Pascal or OCaml than Go.
15:45:10 <bitemyapp> or C#.
15:45:14 <identity> ij: I am not interested in discussing definitions of political ideologies
15:45:14 <indigo> Go is not a better C, tbh
15:45:16 <yogurt_truck> the "bahh we don't see what's so useful about generics" attitude is enough for me to distrust and discard that language
15:45:17 <bitemyapp> or SML or Common Lisp
15:45:38 <bitemyapp> indigo: it *can't* be with the GC, threading model, and everything else.
15:45:39 <identity> but what I am referring to is basically: high taxes, lots of support, free education, free healthcare, yada yada
15:45:46 <FUZxxl> indigo: Go is better than C in some cases, but it doesn't cut it when you have to do really low level stuff.
15:45:51 <indigo> bitemyapp: Yep
15:45:53 <silasm> bitemyapp: I'm pretty much literally just talking about compile-time errors here. Also, please don't think I enjoy defending Java, I hate it.
15:45:59 <bitemyapp> identity: I wonder how America managed to get the former and none of the latter?
15:46:01 * geekosaur will just note that "better than C++" is a rather low bar
15:46:01 <indigo> I'd honeslty go with Rust if I was going down that path
15:46:04 <ij> identity, Don't call something as socialism, where it's not, then.
15:46:14 <bitemyapp> geekosaur: for applications? yes. for systems? that's a harder question.
15:46:29 <bitemyapp> ij: probably thinking of what is conventionally known as democratic socialism as practiced in Europe.
15:46:39 <identity> ij: Denmark is generally considered a socialist country
15:46:43 <bitemyapp> ij: it's a crude and ill-advised abbreviation but not really that far besides the point.
15:46:43 <identity> we have a socialist government
15:46:47 <identity> it's a socialist state.
15:46:59 <Qett> denmark is not socialist
15:47:00 <Qett> lol
15:47:01 <FUZxxl> yogurt_truck: You got that wrong. It's rather like "We know Generics can be useful, but we aren't quite sure how to do them correctly." I'd love to see generics that work like the type system of Haskell.
15:47:08 <FUZxxl> Which isn't going to happen probably.
15:47:23 <nooodl> meanwhile in #socialism
15:47:27 <identity> yeah
15:47:45 <roboguy_> FUZxxl: I think they're planning on implementing some Haskell-like features in the type system of rust
15:47:46 <ij> *##marxism
15:48:05 <FUZxxl> roboguy_: I've never tried rust.
15:48:10 <Qett> unless you mean 'socialist' as 'murica #1 fuck da commies'
15:48:10 <bjz> roboguy_: they already do
15:48:16 <roboguy_> FUZxxl: neither have I. that's the rumor though
15:48:19 <bjz> roboguy_: not as pretty as haskell
15:48:31 <bitemyapp> It really bothers me that the standard PLT tumblr blog is administrated by somebody that has sat out on the last 20 years of PLT.
15:48:38 <silasm> geekosaur: I love imagining how angry what's said in this channel would make some of my friends, haha.
15:48:47 <roboguy_> bjz: the particular thing I have in mind is higher-kinded polymorphism. unless they implemented that already
15:48:55 <bjz> roboguy_: but the type system is definitely in the lineage of ML and Haskell as opposed to Algol
15:49:02 <FUZxxl> Is there any language that is imperative and uses HM-style type inference?
15:49:06 <bjz> roboguy_: yeah, that is post 1.0
15:49:09 <FUZxxl> Is that even possible?
15:49:11 <bjz> FUZxxl: Rust :P
15:49:14 <roboguy_> FUZxxl: doesn't ML?
15:49:21 <bjz> FUZxxl: it's local HM though
15:49:26 <bitemyapp> I was going to say.
15:49:46 <bitemyapp> silasm: why, are they golang users?
15:49:48 <bjz> FUZxxl: they feel that full HM can get out of hand, which I sort of agree with
15:50:09 <identity> denmark may not be called "a socialist state"(apparently that is a concretely defined term) but denmark, the politics in denmark, are definitely socialist
15:50:19 <silasm> bitemyapp: have a friend that was an avid C++ user (and I think still is), moved to golang, and is now trying out rust.
15:50:27 <bitemyapp> identity: I propose we take any politics/socialism/denmark stuff to #haskell-blah.
15:50:30 <identity> (socialist democracy)
15:50:34 <bitemyapp> identity: and leave it out of this channel.
15:50:34 <Qett> how are the 'politics socialist'?
15:50:48 <identity> bitemyapp: yeah, I don't intend discussing it any further
15:50:48 <bitemyapp> silasm: at least they're trying out Rust.
15:51:01 <silasm> bitemyapp: but I think he'd be blown away by geekosaur's statement lol. Also have a friend that thinks lisp and C are the height of everything, but his reasons for that I can kind of respect.
15:51:02 <yogurt_truck> socialism is the OOP of political theory
15:51:08 <ij> wat
15:51:14 <bjz> silasm: the nice thing is it's introducing C++ programmers to concepts from haskell
15:51:16 <prooftechnique> yogurt_truck: Corporations love it?
15:51:18 <Qett> wat
15:51:27 <bitemyapp> guys
15:51:30 <bjz> silasm: and other functional, statically typed langs
15:51:31 <ij> bitemyapp, You're right about the 'democractic socialism.' Just consulted wikipedia about this.
15:51:32 <bitemyapp> politics. not here. please.
15:51:36 <prooftechnique> ^
15:51:42 <bitemyapp> #haskell-blah if you must.
15:51:54 <bjz> silasm: there have been a few folks who have tried out haskell after doing Rust, and found it easier
15:52:00 <silasm> bjz: definitely; nothing against rust here.
15:52:01 <yogurt_truck> prooftechnique: as a term that is in any way useful to transmit information, I meant
15:52:12 <bjz> silasm: nothing against Haskell either
15:52:42 * bjz love PLs in general, even Go and C++ in some areas
15:52:47 <silasm> bjz: I definitely don't see it doing anything bad to the industry, which is more than can be said for most languages out there.
15:52:53 <bitemyapp> bjz: it's still missing a lot though. It's not yet clear if they'll take the typeclassopedia stuff seriously.
15:53:01 <prooftechnique> bjz: I found Rust reasonably easy to wrap my head around between 0.5 and 0.7 or so. 0.8 and 0.9 have gotten kind of weird and pointer-y for me
15:53:01 <yogurt_truck> bjz: how about COBOL?
15:53:08 <identity> I remember learning C++ after having done a lot of C. I found it so nice.. so .. clean
15:53:09 <bjz> bitemyapp: link?
15:53:18 <identity> little did I know the beast that lurked within it
15:53:19 <bjz> prooftechnique: it has got lots simpler
15:53:28 <bitemyapp> bjz: just pcwalton's dismissal of queries from Haskellers about whether they'll take the traits further.
15:53:47 <bitemyapp> bjz: so the impurity and okay'ish leveraging of traits is about as far as it's likely to go.
15:53:49 <bjz> bitemyapp: any links?
15:53:53 <silasm> identity: that's how I felt moving to Haskell from J.
15:54:03 <bjz> bitemyapp: I'd be interested to read
15:54:04 <identity> silasm: With the beast as well?
15:54:10 <silasm> identity: not as much.
15:54:13 <identity> good.
15:54:24 <identity> because I would vehemently disagree
15:54:30 <silasm> J is still fun as hell to try and puzzle out though. I occasionally try to go back and relearn it.
15:54:30 <bitemyapp> bjz: I get most of my Rust updates from r/rust and the mailing list.
15:54:36 <identity> unless the beast was another beast, like the oh-my-god-what-are-transformers-beast
15:54:45 <bitemyapp> bjz: I'd try googling "typeclass", "monad", and "haskell"
15:54:59 <identity> oh, maybe I misunderstood
15:55:34 <bjz> prooftechnique: if you have a static type system, regions, linear types with destructors, and the ability to do unsafe stuff in a contained way, you basically have the semantics of Rust in a nutshell
15:55:42 * yogurt_truck immediately thinks of Scala whenever he reads the word "beast"
15:55:53 <indigo> Scala is the new C++ :P
15:56:22 <yogurt_truck> I still don't know how I manage to survive my daily adventures with this humongous thing
15:56:30 <bjz> prooftechnique: you can derive tons of stuff out of that - Unique pointers, GC, concurrent runtime etc
15:56:46 <bjz> prooftechnique: which is probably what you have been hearing about the pointer thing
15:56:47 <identity> yogurt_truck: I don't know Scala, but there are entire books on C++'s "best practices" which is just a nicer way of writing "stupid design oversight pitfalls that will break your shit if you don't know these really complex workings of the language and all manner of corner cases"
15:56:50 <FUZxxl> BTW, what actually happened to Ada?
15:56:50 <indigo> yogurt_truck: Doesn't it take ages to compile
15:57:14 <bjz> bitemyapp: I think it might have been just that we're not doing it for 1.0 - there is already too much
15:57:15 <yogurt_truck> 10 minutes of "this is super useful" followed by 10 minutes of "what whyyyyy", repeat. that's my day.
15:57:17 <identity> i don't even remember any of it anymore.
15:57:18 <geekosaur> ada is still used for "trusted apps"
15:57:30 <yogurt_truck> indigo: it is not a fast compiler, no
15:57:34 <geekosaur> it's still alive but very much niche
15:57:49 <identity> I think I might have a nervous breakdown if I got a job writing C++, from the weight of all the possible ways I can blow off my leg
15:57:50 <bjz> bitemyapp: but if he said that I would argue with him
15:57:56 <identity> in wich*
15:57:58 <identity> which*
15:57:59 <identity> gah.
15:58:07 <bjz> bitemyapp: the saddest thing I have is that we're not dependently typed
15:58:08 <bitemyapp> bjz: hum. I don't think anybody wants to dumptruck mtl onto Rust, just be reassured that alternatives to impurity-by-default are at least being considered.
15:58:12 <indigo> identity: I'm sure there will be a subset of C++ that everyone will be forced to use
15:58:23 <bitemyapp> bjz: yeah the absence of dependent types kinda chafes given how new the lang is.
15:58:38 <bitemyapp> bjz: was a reason for that given? you'd think with linear types you might as well.
15:58:42 <indigo> identity: And it'll probably be better than a PHP job ;P
15:58:48 <identity> indigo: possibly, yeah
15:58:51 <identity> indigo: and oh, god, yes
15:59:00 <ReinH> The thing is, Rust isn't about that kind of purity. It's about isolation of a certain kind of effect, not of all effects in general.
15:59:11 <identity> I would rather swallow a thousand white-hot nails than write php for a living
15:59:17 <yogurt_truck> identity: yes. C++ is like that. I do Scala and Javascript full time. So I'm very well used to the "technique" of using a tiny subset of a language in order to keep my sanity
15:59:23 <indigo> identity: Well, I will get out of PHP-land eventually
15:59:24 <ReinH> identity: it would be difficult to swallow a whole thousand though
15:59:29 <bjz> bitemyapp: but it's the most compelling systems lang on the horizon. I suspect an idrisy kind of systems lang to take the crown in 5 or so years, but I could be wrong
15:59:47 <identity> ReinH: If the choice was between writing php for a living and swallowing each and every one of those thousand, I would fine a way.
15:59:50 <identity> find*
16:00:03 <identity> well, .. i wouldn't survive
16:00:20 <identity> so I guess it wouldn't matter either way
16:00:20 <ReinH> yes, that's what would make it difficult
16:00:26 <bjz> bitemyapp: I'm just being pragmatic and saying, "I'm not about to write that next systems lang"
16:00:36 <identity> so I'd just kill myself, basically, if I had to do php for a living.
16:00:59 <indigo> identity: Weak typing makes me sad :(
16:01:03 <bitemyapp> bjz: Sure. I still think Rust is the only real alternative to C++ for the forseeable future for that niche.
16:01:04 <indigo> Among other things
16:01:04 <yogurt_truck> identity: I did, for years
16:01:11 <yogurt_truck> not a healthy thing
16:01:25 <they> I thought that Rust was eventually going to replace C, and that D would replace C++?
16:01:32 <they> Not Rust -> C++
16:01:34 <xpika> for an arithmentic function where f(x)=y is there any software which will give me a concise formula f given sample x and y's
16:01:37 <xpika> ?
16:01:40 <bjz> they: they are aiming more for C++
16:01:48 <bjz> hah, "they"
16:01:57 <bjz> they: doesn't you nick annoy you?
16:02:04 <bjz> *your
16:02:07 <they> No, it's interesting to see how people work highlights into their messages.
16:02:14 <they> I've had 5 highlights in a row in this channel once.
16:02:36 <bjz> they: D is more in league with C#
16:02:59 <identity> yogurt_truck: Which? Kill yourself for years? ;)
16:03:03 <bjz> they: I think they made a mistake going after C++, since they have pervasive GC
16:03:04 <identity> yogurt_truck: But yes, I can imagine
16:03:04 <they> I don't know. D has some C++-ish features, like inline ASM.
16:03:15 <identity> indigo: Weak typing is not even an issue compared to php's other issues
16:03:43 * bjz goes to get the morning coffee
16:03:51 <benmachine> xpika: there are many possible answers
16:04:17 <benmachine> xpika: e.g. f(0) = 0, f(2) = 4 could either be f(x) = 2x or f(x) = x^2
16:04:43 <benmachine> xpika: it's not hard to write an algorithm that given some samples will spit out a polynomial that does the job
16:04:52 <identity> xpika: You need to choose a regression analysis model, basically
16:04:55 <benmachine> but it's only one of many, and maybe you don't want a polynomial
16:05:06 <benmachine> or maybe you want an approximation
16:05:20 <benmachine> or maybe you want a crystal ball :)
16:05:42 <xpika> benmachine: the more values you give it surely the more obvious it becomes
16:05:45 <identity> xpika: But yes, there is software that does that. Mathematica, for example
16:06:08 <benmachine> xpika: there will always be infinitely many possibilities
16:07:13 <xpika> benmachine: ok, more acceptable
16:10:43 <joneshf-laptop> xpika, arithmetic in what sense?
16:11:06 <sayyid> guys help me out with this: imagine i'm running a really cumbersome line of code that requires my computer to perform a long series of arithmetic operations and then display the result when finished
16:11:19 <sayyid> when i do that, my pc freezes
16:11:23 <xpika> joneshf-laptop: lets say compositions of addition subtraction division and multiplication
16:12:08 <sayyid> is it because haskell times out or is my computer genuinely bad? (running core2duo @2.00ghz)
16:12:38 <simpson> sayyid: Windows?
16:13:03 <sayyid> simpson, it's linux mint 16
16:13:09 <roboguy_> sayyid: it depends on how you're doing it
16:13:12 <simpson> sayyid: Hm. Not sure.
16:13:13 <benmachine> what do you mean by "freezes"?
16:13:21 <benmachine> my guess is, you're exhausting your memory
16:13:33 <sayyid> it just chokes. hard. the whole system starts running slow
16:13:43 <benmachine> yeah, sounds like memory exhaustion
16:13:48 <roboguy_> sayyid: maybe something is growing without bound?
16:13:54 <benmachine> when you start running out of memory your computer starts swapping it to disk
16:13:58 <benmachine> but copying stuff to disk is slow
16:14:04 <benmachine> copying it back out when you need it: also slow
16:14:23 <benmachine> doing this for everything that needs to be done: so slow it can even make your mouse input stop being responsive
16:14:31 <sayyid> i also think so. however, it's related to project euler, which you may know by having relatively easy problems
16:14:32 <roboguy_> sayyid: you could paste it on this paste site and we could take a look at it http://lpaste.net/new/haskell
16:15:01 <benmachine> sayyid: project euler has the kind of problems that can easily cause you to use lots of resources if you do them the wrong way
16:15:11 <benmachine> in general it's not that hard to accidentally chew up all your memory
16:15:18 <benmachine> there's a few ways you can stop it from happening though
16:15:19 <sayyid> for example, take problem 12 of PE. i cannot compute the end result, just at all
16:15:54 <sayyid> using a list comprehension, which is a fairly simple way to get the end result
16:16:03 <joneshf-laptop> xpika, just stabbing in the dark here, but if you can restrict the type of functions being produced, you can do that fairly easily depending on the type of func, as benmachine noted
16:16:23 <roboguy_> sayyid: I don't think a brute force method would work on that
16:16:28 <benmachine> sayyid: right, but if you're accidentally introducing an infinite loop that allocates memory, say
16:16:52 <identity> sayyid: You can solve many of the euler problems(theoretically) in a very naive manner, with a program that will arrive at a solution.. sometime after the universe ceases to exist
16:17:04 <sayyid> i'll dig up that code for us to take a look then
16:17:06 <identity> the same problems can be solved within seconds, very often, using a smarter algorithm and some analysis of the problem
16:17:10 <joneshf-laptop> xpika, like if you only want linear functions, you just need two (x, y), quadratic functions three (x, y), cubic four (x, y), etc.
16:18:39 <sayyid> for example, i defined the function that returns the n-th triangular number the following  way: numtrig::Integer->Integer ; numtrig 1 = 1 ; numtrig n = n + (numstrig (n-1))
16:19:03 <benmachine> sayyid: you can do it much faster than that
16:19:05 <identity> sayyid: The nth triangular number can be computed using a closed form expression
16:19:08 <sayyid> i know so
16:19:10 <identity> n(n + 1)/2
16:19:11 <identity> iirc
16:19:13 <identity> yeah
16:19:20 <sayyid> however i preferred not using that one
16:19:30 <benmachine> ok
16:19:35 <sayyid> because my text editor has issues with (fromIntegral)
16:19:39 <joneshf-laptop> xpika, however, i feel like this is something that has been studied and should have information on it
16:19:50 <roboguy_> sayyid: don't use / then
16:20:00 <benmachine> sayyid: issues?
16:20:04 <sayyid> do you think mod would work?
16:20:06 <roboguy_> also what text editor are you using and what issues?
16:20:07 <benmachine> div
16:20:09 <roboguy_> sayyid: no. div
16:20:19 <sayyid> yeah, div, my mistake, yes
16:20:25 <benmachine> div would work
16:20:31 <sayyid> well, indentation is pretty bad
16:20:40 <sayyid> i think i should stop using it. its gedit
16:21:36 <identity> gedit is pretty rudimentary and as such, pretty terrible
16:21:46 <sayyid> if i define the function to output an integer, then i have to use fromInteger, but then it wont work because the function returns a float... :(
16:21:52 <identity> I recommend you spend the next year on learning vim in seclusion in the himalayas. It is the only true way to zen.
16:21:59 <sayyid> which should i use then?
16:22:00 <identity> sayyid: No, div does not
16:22:04 <identity> @ty div
16:22:04 <lambdabot> Integral a => a -> a -> a
16:22:25 <identity> @let nthTrig n = n * (n + 1) `div` 2
16:22:26 <lambdabot>  Defined.
16:22:31 <identity> > nthTrig 123
16:22:33 <lambdabot>  7626
16:22:34 <sayyid> text editor, i meant
16:22:50 <benmachine> sayyid: how do you calculate factors?
16:23:04 <sayyid> factors of an integer?
16:23:07 <identity> sayyid: That's up to you, but something with syntax highlighting, indentation, etc
16:23:12 <sayyid> list comprehension
16:24:26 <sayyid> would sublime be enough?
16:24:43 <identity> sayyid: most definitely
16:24:49 <sayyid> ok, thank you.
16:28:11 <jle`> is there a way to include a function in a json object?
16:28:14 <jle`> in fay?
16:30:51 <sayyid> there it goes again... how would you retrieve a number's divisors?
16:31:05 <sayyid> list comprehension does NOT work cleanly
16:31:18 <tac> You mean like, how do you factor it?
16:31:24 <identity> sayyid: You don't need the divisors, but the count
16:31:52 <sayyid> i know, but to find the length of such a list requires calculating it
16:32:11 <identity> sayyid: you don't have to generate the list of divisors to count them.
16:32:14 <tac> not necessarily, although that is a certain way of doing things :)
16:32:47 <identity> but you only need to check for divisors below and including the square root of the number, FYI.
16:32:48 <theorbtwo> OTOH, why do you want a count of divisors without knowing what they are?
16:32:58 <identity> theorbtwo: it's a euler challenge
16:33:16 <theorbtwo> identity: Ah.
16:33:32 <tac> theorbtwo: If it's people and not factors, no one ever questions that
16:33:46 <tac> 10,000,000,000 views! (But who were those people watching that Cat Video?)
16:33:57 <tac> They have been counted. But no one really knows who they were.
16:34:03 <theorbtwo> tac: That has a certian degree of truth, tis true.
16:34:18 <benmachine> it's true that it has a certain degree of truth?
16:34:25 <theorbtwo> On average, they are pretty average people.
16:34:26 <benmachine> but... is THAT true?
16:34:45 <theorbtwo> benmachine: Tautological thing is tautological.
16:36:29 <theorbtwo> Anyway, yeah.  Factors come in pairs.  One of those pairs is always <= the square root of the number.
16:36:48 <lingxiao> hey all, could someone here who has agda on their machine answer a couple questions for me on #agda? :D
16:42:34 <jle`> is there any fmap in Fay?
16:42:39 <jle`> at laest to map over Fay?
16:42:50 <bergmark> jle`: mapM
16:43:07 <bergmark> oh n/m
16:43:16 <FreeFull> mapM wouldn't be the same thing at all
16:44:35 <bergmark> jle`: f >>= return . g
16:45:31 <bergmark> haven't defined <$>/fmap since its probably just confusing for it to be monomorphic
16:45:47 <fragamus> edwardk: I am initializing my V4 like this: V4 1 2 3 4     can you tell me how to initialize a V5 or the equivalent
16:46:55 <roboguy_> benmachine: that doesn't work for Functors that aren't Monads though
16:47:08 <bergmark> FreeFull: it's kind of the same...
16:47:13 <bergmark> :t [mapM, fmap]
16:47:14 <lambdabot> [(a -> [b]) -> [a] -> [[b]]]
16:47:17 <benmachine> roboguy_: what doesn't?
16:47:47 <jle`> bergmark: been using the return
16:47:57 <jle`> but
16:48:00 <jle`> hlint suggsts liftM
16:48:31 <jle`> oh wait, hlint doesn't know i'm in Fay
16:48:32 <jle`> heh
16:48:37 <bergmark> :-)
16:49:15 <roboguy_> benmachine: mapM and f >>= return . g
16:49:33 <benmachine> roboguy_: are you sure it's me you want to be telling this
16:49:37 <Axman6> hmm, so with Cont, if I want to return a result the result in the middle of the computation, how would I do that?
16:49:43 <roboguy_> benmachine: oh, oops
16:49:46 <Axman6> I can't get my head around how to do early termination
16:50:13 <roboguy_> bergmark is who I meant
16:50:35 <benmachine> Axman6: insert Cont (\ _k -> value) in your do-block
16:50:47 <bergmark> anyway, fay doesn't even have Functor :P
16:50:49 <Axman6> ah ha, that looks perfect
16:50:52 <benmachine> i.e. ignore the continuation
16:51:06 <shachaf> i,i Either
16:51:25 <fragamus> I am initializing my V4 like this: V4 1 2 3 4     can you tell me how to initialize a V5 or the equivalent
16:51:33 <benmachine> shachaf: I feel like I've had i,i explained to me once already but it's gone again if so
16:51:59 <benmachine> it's... a MIT thing? or something?
16:52:08 <benmachine> that means "this isn't necessarily relevant but" owtte?
16:52:13 * benmachine scrapes memory
16:52:24 <shachaf> Something like that, I think.
16:53:07 <geekosaur> Carnegie Mellon thing, although I think we spread it to some parts of MIT. "I have po point here, I just like saying..."
16:53:55 <simpson> Man, I *cannot* unsee the beauty of Either as the early-success Monad. It's ingenious.
16:54:21 <shachaf> Or early failure!
16:54:55 <lpsmith> does anybody happen to know off the top of their heads what exceptions the HTTP package will throw?
16:54:59 <fragamus> oh i never thought of using Either the other way around
16:55:03 <lpsmith> Just IOError or are there others as well?
16:56:00 <ReinH> simpson: EitherR is pretty great :)
16:58:14 <joe9> I am trying to figure out how to use Data.Default defaults. Any links that can help me, please?
16:58:22 <joe9> the docs just say def :: Type
16:58:25 <joe9> and nothing more.
16:58:57 <shachaf> Which documentation? http://hackage.haskell.org/package/data-default-0.5.3/docs/Data-Default.html doesn't even have the string "Type".
16:59:18 <joe9> shachaf: I meant def :: a
16:59:21 <joe9> sorry about that.
17:00:05 <shachaf> OK. And what's the question?
17:00:17 <joe9> shachaf: how do I use it?
17:00:29 <shachaf> For what?
17:00:49 <shachaf> Or, let's say, with which type?
17:01:25 <joe9> shachaf: this is my program: http://codepad.org/CPymvyMx and line 63 is what I am trying to figure out.
17:02:07 <joe9> shachaf: I wantto overwrite that list of taskActions later on in a different config as this is a rudimentary list.
17:02:30 <shachaf> You can only have one Default instance for your type.
17:02:35 <dhrosa> can I make cabal install the profiling-enabled version of all of my programs dependencies in one line?
17:02:38 <shachaf> You can't overwrite things in Haskell.
17:03:36 <joe9> shachaf: How do I use the default? Is there any few lines of code using that, please?
17:04:09 <joe9> i understand about having 1 instance. but, I want to use a different list of actions later when I am doing something using that function.
17:04:46 <shachaf> You defined def = ... for TaskActions
17:04:52 <shachaf> So now def :: TaskActions; def = ...
17:04:56 <shachaf> That's all it is.
17:05:21 <joe9> and to use that defaultConfig, just use def?
17:06:14 <shachaf> It works just like any other type class.
17:06:27 <shachaf> Maybe you would be best served by reading about how type classes work in general.
17:07:55 <jle`> bergmark: is there an easy way to pass in a jquery object with a function/callback as a value to a js function?
17:08:07 <jle`> *javascript object
17:08:28 <jle`> it's a jquery library that needs a configuration object to start up
17:08:40 <jle`> this is the only thing in my small set of scripts that i haven't been able to convert
17:09:53 <jle`> maybe one day i will port the whole library to fay
17:11:15 <joe9> shachaf: got it http://codepad.org/hxLFIpUG
17:14:29 <alskdj> I have a simple TCP server written in haskell that I would like to convert to using pipes-network, but I am kinda lost trying to figure out how to handle responding differently depending on what a client has already done before
17:14:49 <bergmark> jle`: i don't understand
17:15:40 <alskdj> in my notpipes version I have a recursive function handling the reading from the client socket and responding to it, so to "change state" I can just call it with a different state as its argument for the next iteration of the loop
17:16:08 <alskdj> but with pipes, the looping is hidden inside the pipe stuff so I don't know how to deal with it
17:16:28 <mvc`> hey, I was wondering if anyone had any ideas for nice option parsing
17:16:37 <bergmark> jle`: what does the call look like in js?
17:16:51 <mvc`> like $foo option [--option, -o] blah
17:17:28 <bergmark> mvc`: have you looked at existing libraries, such as optparse-applicative?
17:18:24 <mvc`> bergmark: that actually more or less looks like what I want thanks!
17:19:07 <mvc`> bergmark: I saw a big wiki entry with abunch listed and figured I'd ask some people here....wasn't there supposed to be a rating system on hackage soon?
17:20:04 <sayyid> can anyone help me with an efficient factor counting function?
17:20:17 <Tehnix> Hmm, in a bit of a pickle with Aeson. Is it possible with jsons automatic FromJSON creation (via generic) to, instead of having the data structure key name contain the value, then have a value contain a value? It's a bit easier to describe in the two simple JSON outputs at the bottom here -- https://gist.github.com/Tehnix/8626509
17:20:43 <bergmark> mvc`: number of downloads is somewhat indicative of popularity
17:20:50 <Tehnix> My current approach is wrong, but I don't quite see how to get it to my desired point :/
17:21:09 <bergmark> mvc`: but yeah, i think ratings are planned
17:21:18 <mvc`> bergmark: cool well thanks
17:30:55 <sayyid> can anyone help me with an efficient factor counting function?
17:31:43 <roboguy_> sayyid: what do you have so far?
17:31:54 <sayyid> im gonna write it down, sec
17:32:05 <roboguy_> sayyid: if you want to paste it, you should use http://lpaste.net/new/haskell
17:32:42 <sayyid> where do i put the file name?
17:32:51 <roboguy_> sayyid: file name?
17:32:57 <roboguy_> you just paste the code into the box
17:33:04 <sayyid> ok
17:33:10 <roboguy_> you can title it too, if you want
17:33:41 <sayyid> ok
17:34:01 <sayyid> http://lpaste.net/99091
17:34:47 <roboguy_> sayyid: I think you only need to test divisors up to sqrt n
17:36:01 <sayyid> that mean i should add one to the global result to account for the number itself?
17:37:17 <roboguy_> sayyid: not quite. I would start by renaming the "n" in divisord. you're shadowing the original n
17:37:25 <benbangert> any recommendations for haskell irc lib? http://hackage.haskell.org/package/simpleirc-0.3.0 looks pretty good, but I'm not seeing a way to do SSL
17:41:46 <oakwhiz> benbangert: I'm no expert but would you be able to modify the code to use STARTTLS without a ton of effort?
17:43:53 <benbangert> oakwhiz: yea, looking through the code now
17:44:19 <oakwhiz> benbangert: It seems that during the connection process you should ask the server if it supports the "tls" feature. If so, then you are permitted to send STARTTLS. Once it is accepted you may insert a plain old TLS session.
17:44:54 <benbangert> I assume thats during the normal network connect phase, is there an example of doing that?
17:45:11 <oakwhiz> I found this: http://wiki.inspircd.org/STARTTLS_Documentation
17:45:37 <oakwhiz> but I haven't seen any code samples yet...
17:45:42 <roboguy_> sayyid: once you do that, it will be easier to explain
17:46:05 <benbangert> oakwhiz: I just meant any example of ssl in a tcp connection in haskell
17:46:15 <benbangert> I believe the way my irc server is setup, it does the ssl immediately on the same port
17:46:18 <benbangert> without start-tls
17:46:19 <sayyid> once i rename the variable?
17:46:37 <benbangert> oh
17:46:42 <benbangert> Network.SSL
17:46:43 <benbangert> lol
17:47:20 <geekosaur> on the same port? SSL? possible but unlikely considering that plaintext looks like garbage to SSL and SSL looks like garbage to plaintext
17:47:31 <benbangert> geekosaur: its an SSL only port
17:47:39 <geekosaur> ok, then you don't want TLS
17:47:42 <oakwhiz> benbangert: If the server you want to connect to has a plain SSL/TLS port then that would probably be a lot easier to connect to.
17:48:08 <oakwhiz> STARTTLS is a protocol extension to IRC whereas plain TLS is just an intermediate layer.
17:48:13 <benbangert> right
17:49:59 <sayyid> roboguy i've already renamed the variable
17:50:22 <zxq9> How portable is the intermediate C generated by GHC? Is it reasonable to expect to be able to, say, build a program for an embedded device (ARM9, for example)?
17:50:22 <oakwhiz> benbangert: Actually you've reminded me of a simple command line app that I wish existed.
17:51:15 <geekosaur> not very portable at all
17:51:36 <oakwhiz> I often use a Telnet client as network debugging tool... what would be handy is a raw SSL version of telnet.
17:51:41 <geekosaur> if you want to build for embedded, you might want to look at ajhc
17:51:49 <geekosaur> oakwhiz: nc
17:52:06 <oakwhiz> does netcat actually do that?
17:52:08 <geekosaur> possibly stunnel and relatives
17:52:42 <geekosaur> hm, I thought it could be built with ssl support
17:52:54 <geekosaur> people also use openssl s_connect
17:53:25 <oakwhiz> geekosaur: Hey that's really cool. I've set it as an alias in my bash profile.
17:54:13 <joe9> I want to check if a read of a datatype will be successful. for example, (read :: myType) . Any thoughts on how to go about it, please?
17:54:23 <geekosaur> there is a readMaybe
17:54:30 <geekosaur> in recentish ghc at least
17:55:11 <geekosaur> (in Text.Read)
17:55:12 <oakwhiz> zxq9: http://corp.galois.com/copilot/
17:55:34 <geekosaur> also see reads but it's a less convenient interface
17:55:37 <joe9> geekosaur: ok, thanks.
17:56:11 <joe9> geekosaur: thanks for the hint. Safe has a readMay too.
17:58:26 <kristof> Ok, I just typed on a mechanical keyboard for the first time
17:58:27 <kristof> dear god
17:58:40 <dhrosa> kristof: isn't it beautiful?
17:59:08 <kristof> dhrosa: it's a different level of comfort
17:59:33 <kristof> dhrosa: They were blues, so I can't comment on what other switches feel like
18:00:13 <dhrosa>  what do you mean different level of comfort?
18:01:35 <oakwhiz> kristof: Typing on blues makes my code feel more important :-)
18:01:45 <kristof> oakwhiz: do your coworkers complain?
18:01:56 <oakwhiz> yes
18:02:09 <oakwhiz> I only use them at home now
18:09:00 <dsrx> topre or go home
18:09:39 <ChongLi> filco tenkeyless with browns here!
18:09:42 <dsrx> (to be fair, i've never tried cherry blues, just browns and reds)
18:10:27 <pavonia> Say you have a datatype Foo that is basically some other type Bar with extra features. Bar has a huge API and I want others to use large parts of that API for Foo too. Would it be better to write a lot of new wrapper functions for Foo, or to give the user access to the internal representation, so that they can use Bar's API directly?
18:10:36 <roboguy_> sayyid: ok, as I understand it, you don't need to keep testing if m > sqrt n
18:11:13 <dwcook> pavonia, you could make write a function to lift a Bar operation to a Foo one
18:11:15 <roboguy_> oh wait, this might not be just prime divisors
18:11:18 <dwcook> s/make/maybe/
18:11:57 <sayyid> oh. i just realised i posed the question incorrectly
18:12:12 <sayyid> i meant divisors instead of prime factors
18:12:16 <pavonia> dwcook: good idea
18:13:36 <pavonia> dwcook: But I would need different functions for the various number of arguments, no?
18:14:35 <roboguy_> sayyid: hmm, in that case I'm not sure
18:14:45 <dwcook> pavonia, not necessarily. But you might have to provide the actual types to get a good answer.
18:16:04 <roboguy_> sayyid: you might want to look up totient functions though. I'm not sure if that'll help, but it reminds me of those
18:16:11 <sayyid> ok, thanks
18:16:38 <sayyid> the P.E. question could have been better phrased
18:17:14 <pavonia> dwcook: It's "data Foo a = Foo (M.Map Day a)" and/or "data Foo a = Foo (V.Vector (Day, a))"
18:19:09 <dwcook> pavonia, I think it would be easiest if you put together a paste with the Foo and the Bar and the types of various operations you want to upgrade
18:19:57 <dwcook> e.g., you said you were concerned about having to write different functions for differing numbers of parameters. Examples of those would be good
18:20:07 <wafflepi> apples: hiya honeybuns
18:20:31 <apples> hello
18:20:36 <Axman6> :\
18:22:23 <carter> abstract-alf:?
18:22:30 <carter> Axman6:?
18:22:47 <Axman6> just an odd way to enter a channel
18:24:05 <pavonia> dwcook: Hhm, maybe I'm just having a wrong idea of the lift function you mentioned. The ideal would be to allow them to use any function available from the Map/Vector APIs
18:25:25 <dwcook> pavonia, I realize I may not have had a clear formulation of the problem in my head when I suggested that. Say your functions produce Bars – Then you can simply write a Bar → Foo
18:27:11 <dwcook> And then compose or apply that as necessary
18:28:35 <pavonia> But I'd also need a function Foo -> Bar then, not sure this is the right thing to do
18:28:52 <dwcook> Well, a function Foo → Bar sounds like the wrong thing since then you'd be losing information
18:29:04 <pavonia> something like "withFoo (Foo m) f = Foo $ f m"
18:29:36 <dwcook> Perhaps.
18:30:30 <dwcook> Though it might be better to flip the parameters, and then you'd basically get that lift function I was talking about.
18:30:58 <pavonia> The only problem is that there are functions with a different number of parameters :S
18:31:26 <dwcook> Yes, and the way they're structured does matter, which is why I suggested giving examples
18:32:45 <pavonia> e.g. mapAccumWithKey :: (a -> k -> b -> (a, c)) -> a -> Map k b -> (a, Map k c)
18:33:07 <dwcook> And what type do you want to turn that into?
18:33:46 <pavonia> Into the same but "Map k" replaced by "Foo" ideally
18:34:10 <pavonia> Or at least into any format such that this function can be used for Foo
18:34:55 <dwcook> I think it might be easiest to allow unwrapping/rewrapping your type, so your withFoo idea seems reasonable
18:35:31 <Artemiss> apples: so i'm startin up cats again where you at in all that
18:35:41 <ij> Does ghc make my code concurrent, if it can?
18:35:47 <pavonia> dwcook: yeah, that's probably the easiest
18:35:53 <pavonia> thanks!
18:36:10 <Axman6> ij: only if you tell it to
18:36:32 <dwcook> So basically your withFoo will accept a function taking the internal Map onto a new Map, and a Foo, and preserve any other extraneous information while making that replacement
18:36:49 <Axman6> ij: concurrency is achieved using forkIO (parallelism, which is pure, can be achieved using par and others from Control.Parallel)
18:37:03 <pavonia> exactly
18:37:27 <qrada> hey, im defining some 'constants' (unix ownership permissions), ie, S_IRWXU = 448 -- 00700 ... Though, I have to define it s: s_IRWXU because of ghc complaining about it not being a valid data constructor... also, is there a cleaner way for me to specify octal as a number? I'm translating it to decimal in my constants... using read "0o00700" :: Int in one of my functions.. anyone have any tips
18:37:56 <Axman6> qrada: any number starting with 0 is an octal number
18:38:01 <Axman6> > 0700
18:38:02 <lambdabot>  700
18:38:06 <Axman6> hmm, or not
18:38:10 <qrada> hah :F
18:38:14 <qrada> ya.. i struggled with that
18:38:39 <Axman6> > 0o700
18:38:40 <ij> Axman6, If laziness kicks in, then a continuation is made, correct? If so, can't haskell detect them and put them on threads, without explicit directives?
18:38:41 <lambdabot>  448
18:38:49 <qrada> i cant seem to specify octal unless , as a string or char, I do something like: '\o00700' or read "0o00700" :: Int
18:38:54 <qrada> ah!
18:38:54 <qrada> nice
18:39:00 <qrada> thanks!
18:39:14 <ij> That's some weird syntax right there.
18:39:19 <qrada> any advice on defining unix like 'constant' such as 'defines'
18:39:26 <Axman6> ij: it's possible, and usually a bad idea. parallelising everything is almost always a terrible idea
18:39:28 <qrada> S_IRWXU for example
18:39:52 <ij> Axman6, I see. Thank you.
18:40:01 <Axman6> qrada: permIoInt S_IRWUX = 0o&00 ?
18:40:04 <prooftechnique> dlist is difference lists, right?
18:40:17 <qrada> oh, no idea what permToInt is.. ill check
18:40:39 <Axman6> ij: and no, not everything is a continuation. I think you are after the word thunk
18:40:51 <pavonia> qrada: It's not an actual function, you have to write it yourself
18:40:54 <qrada> oh
18:40:58 <Axman6> occamshatchet: it's something you define that turns your datatype into an Int  :P
18:41:09 <Axman6> uh, qrada, sorry occamshatchet
18:41:32 <dwcook> ij, this might be of interest http://www.haskell.org/haskellwiki/Parallelism
18:41:41 <qrada> so you're saying, specify a data type like ; data Ownership = S_IRWXU | S_... then make a function to return based on those types that I pass?
18:42:30 <Axman6> yes
18:43:04 <Axman6> ij: you might also like: http://chimera.labs.oreilly.com/books/1230000000929
18:43:07 <qrada> cool, thanks folks
18:43:19 <Axman6> (it's free online)
18:43:32 <Axman6> http://chimera.labs.oreilly.com/books/1230000000929/index.html better link
18:59:26 <chrisw> How does get (as in the state monad) "know" what state to return? It doesn't take any arguments, so I don't know how it can return something different on each call.
19:01:22 <simpson> chrisw: Well, have you seen the full definition of State's type? It contains many answers.
19:01:30 <joelteon> did you look at the definition of it?
19:01:47 <simpson> @src State
19:01:47 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:02:15 <simpson> data State s a = State { runState :: s -> (s, a) } -- this is the non-MTL version.
19:03:22 <prooftechnique> @mtl runState
19:03:22 <lambdabot> Maybe you meant: url unmtl pl msg
19:03:29 <prooftechnique> Aww, it only does unmtl
19:04:30 <Axman6> chrisw: do you understand how the state monad works?
19:04:32 <roboguy_> chrisw: I'm not sure I understand the question
19:05:23 <chrisw> Sorry if it sounds like a simple question, but I just recently started learning about monads. I must not understand how the state monad works.
19:05:35 <Axman6> chrisw: basically State is chaining together functions which take the same type as their last argument, and which return that same type, and some value in a tuple: st -> (st,a)
19:06:41 <Axman6> chrisw: so, if you want to chain together two such functions, and return both their results, you could use both f g s = let (s',a) = f s; (s'',b) = g s' in (s'',(a,b))
19:06:52 <Axman6> hmm, this is clearer with multiple lines...
19:07:34 <chrisw> I can read that, semicolons just separate bindings in the let
19:08:12 <Axman6> chrisw: the important thing to see there is that a new state value is produced by each function, and passed to the next function, which again makes a new state, which can also be passed on
19:08:24 <startling> chrisw, there's no real state. it just specifies a way to feed outputs of one function to the inputs of another (with an extra "return" value) that acts stately
19:08:52 <chrisw> Axman6, yes I follow that, I'm just wondering how "get" is able to return the correct state despite not taking arguments
19:08:55 <Axman6> chrisw: the definition of get is something lke  get = \s -> (s,s), so it takes the state, and its new state is the old state, and its return value is also the state
19:09:11 <startling> chrisw, get = \s -> (s, ())
19:09:20 <startling> oh, oops
19:09:22 <Axman6> startling: no...
19:09:25 <startling> get = \s -> (s, s), yeah
19:09:49 <Axman6> put s' = \s -> (s',()) is what you were remembering :P
19:09:56 <startling> yeah. :<
19:10:17 <chrisw> I'm confused, because in ghci :t get gives get :: MonadState s m => m s
19:10:39 <chrisw> Oh wait, is MonadState a type synonym perhaps? That would explain it
19:10:43 <Axman6> chrisw: remember, all things of type State s a are really functions that implicitly take in an extra argument of type s, so get takes in the s, doesn't vhange it, and produces the state it got as its return value
19:10:53 <startling> chrisw, it's a typeclass for things that behave like State
19:11:04 <Axman6> chrisw: no it's a type class, and it's there to confuse you sadly
19:11:07 * hackagebot husk-scheme 3.15.2 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.15.2 (JustinEthier)
19:12:05 <Axman6> chrisw: MonadState exist so that you can use monad transformers on any stack on monads which includes State (or StateT)... but you can ignore that for now
19:12:41 <Axman6> chrisw: if you're trying to grok monads, I found this amazingly useful: http://tmorris.net/posts/20-intermediate-haskell-exercises/index.html
19:13:02 <Axman6> I mean, if you're trying to grok Misty's >_>_
19:13:19 <chrisw> Hmm, I'm pretty sure I understand the concept of passing state from function to function, but actually figuring out the types and stuff is really hard for a noob.
19:13:37 <Axman6> yeah, and having get part of a type class doesn't help
19:15:00 <startling> chrisw, I could walk you through deriving it if you'd like
19:15:12 <chrisw> Axman6, thanks for the exercises. I can imagine them being helpful to wrap my mind around the types.
19:15:33 <chrisw> startling, that would be great!
19:15:46 <Axman6> chrisw: they get difficult towards then end, so feel free to ask for assistance
19:15:56 <chrisw> Axman6, cool, thanks
19:16:02 <misterbee__> Types aren't the problem. *Type classes* are the problem, IMO because they look like just a string of variables, without hints like Java's extends/super
19:16:58 <startling> chrisw: hm, have you seen Reader?
19:18:29 <Axman6> hmmmm, now for my own monad problems. how do I run something of type Cont r a? runCont returns (a -> r) -> r, and I need the r so... um
19:18:31 <startling> it might be more instructive to start with that.
19:18:39 <chrisw> startling, I don't think so...
19:18:46 <carter> :)
19:18:53 <startling> Axman6, runCont print or something
19:19:13 <startling> well, not quite.
19:19:17 <Axman6> or runCont cont id?
19:19:32 <startling> chrisw, ok, so Reader is like State but with read-only "state".
19:19:49 <startling> chrisw, it looks like newtype Reader r a = Reader (r -> a). Does that make sense?
19:20:39 <startling> Axman6, it looks like runCont id is common.
19:20:50 <startling> n.b. you want a Cont r r in that case
19:20:57 <chrisw> startling, sort of, give me a second to think
19:21:32 <Axman6> startling: what I actually have is: type PtrParser a = ContT PPResult (StateT PtrState IO) a, I have a PtrParser a, and I want to get the PPResult...
19:21:34 <roboguy_> @src State return
19:21:34 <lambdabot> Source not found. Sorry.
19:21:39 <roboguy_> @src return State
19:21:40 <lambdabot> Source not found. It can only be attributed to human error.
19:22:29 <roboguy_> return a = State $ \s -> return (a, s)
19:24:08 <chrisw> startling, I'm confused already, heh. I don't understand how you can have Reader on both the left and right side of = in newtype
19:25:09 <startling> chrisw: oh, it just defines the constructor
19:25:18 <startling> chrisw, constructors have a different namespace than types
19:25:32 <startling> chrisw: we can say newtype Reader r a = MakeReader (r -> a) instead.
19:25:34 <chrisw> startling, oh, Reader is both a type and a value constructor? So I could write Reader succ?
19:25:42 <startling> chrisw: yep.
19:26:06 <chrisw> startling, awesome, you can keep it as Reader on both sides, that namespace thing slipped my mind
19:26:09 <startling> Reader succ :: Enum a => Reader a a
19:26:40 <startling> chrisw: cool. so, are you familiar with Monad?
19:27:32 <chrisw> startling, hardly, I do have shallow knowledge of >>=, >>, =<<, and do syntax
19:28:19 <startling> chrisw, alright, do you know typeclasses?
19:28:33 <chrisw> startling, fairly well, yes
19:29:16 <startling> chrisw: cool. so, class Monad m where { return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b; }
19:29:29 <startling> there's some "laws" but we don't have to get into them.
19:30:04 <chrisw> startling, ok, so Monad is a typeclass, and all instances of Monad must implement return and (>>=)?
19:30:09 <startling> chrisw: right.
19:30:41 <startling> chrisw, so, return for Reader r has type "a -> Reader r a". do you see how to write it?
19:31:38 <chrisw> startling, so we're making Reader an instance of Monad?
19:31:48 <startling> chrisw: yeah.
19:32:00 <startling> well, instance Monad (Reader r), to be precise.
19:32:34 <chrisw> startling, ok, and the reason for doing so is because we want to pass read-only state from function to function?
19:32:37 <jle`> bergmark: lib.initialize({ id_func: function(a,b,c) { return a+b; }, name_func: function(a,b) { return a/b; } });
19:33:30 <startling> chrisw: something like that, yeah.
19:33:53 <jle`> chrisw: say you have two functions r -> a, r -> b
19:34:08 <jle`> and you want to call both somehow and only provide the r once
19:34:19 <startling> well, let's write return first.
19:35:55 <chrisw> startling, I'm not sure how to write return for Reader r. If r is [], then would it just be return a = [a]?
19:36:57 <startling> chrisw, no, not quite.
19:37:17 <startling> chrisw, remember, newtype Reader r a = Reader (r -> a)
19:37:27 <startling> chrisw, so what we want is essentialy a -> (r -> a)
19:39:55 <startling> in other words, we want to take a value and create the Reader that gives that regardless of the read-only state we feed in
19:40:08 <chrisw> startling, return a = \r -> Reader r a?
19:40:23 <startling> chrisw, not quite, but pretty close
19:40:29 <startling> it's return a = Reader (\r -> a)
19:41:02 <chrisw> startling, oh because Reader here is the value constructor, which only takes one argument
19:41:24 <startling> chrisw: yeah.
19:41:44 <chrisw> startling, ok I'm following, but just barely, heh
19:41:52 <startling> chrisw, heh.
19:42:15 <startling> chrisw: so! now we want to write Reader r a -> (a -> Reader r b) -> Reader r b.
19:42:32 <startling> I'll get you started: Reader f >>= Reader g = Reader _
19:42:43 <qrada> hey, i thought if i did something like: data Permissions = S_IWRXU | ... S_IXOTH deriving (Enum), i would be able to do: [S_IRWXU..S_IXOTH] ? I can use "succ" on any of those types, that works.. any idea how I can use them in a list syntax.. I know i've seen it before, looked through learnyou, cant find it
19:43:08 <startling> chrisw: (er, that's wrong -- that last Reader shouldn't be there.
19:43:20 <startling> chrisw: ok, the whole thing is wrong.
19:43:33 <startling> chrisw, Reader a >>= f = _ -- this one's right
19:44:06 <adek_> I have a function which works on [a], but now I want it to work for Data.Text too. However to work on Text type I need to use functions like map, length etc I need to use version from Data.Text. What is the right design decision in your opinion. Should I unpack text to string to pass it to my function or write another version of the function which will work for Text?
19:44:39 <chrisw> startling, I'm confused about "Reader a", shouldn't that be "Reader (r -> a)" or "Reader r a"?
19:44:52 <startling> chrisw: sorry, Reader a is a value, not a type.
19:45:09 <startling> chrisw, we can say "MakeReader a >>= f = ..." instead
19:45:47 <startling> 'a' here has type "(r -> a)" (which is a different a)
19:45:56 <chrisw> startling, isn't that like pattern matching? oh
19:46:05 <startling> chrisw: yeah, it's exactly pattern-matching
19:46:16 <chrisw> startling, I think I was confused about that a being a type parameter
19:46:43 <startling> chrisw: yeah, it can be confusing at first. unfortunately it's really common in Haskell to have type constructors and value constructors with the same name.
19:47:33 <they> Half of the time with a type like that, it should be handled with a type synonym and an Either.
19:47:42 <startling> eh.
19:48:00 <chrisw> startling, Reader a >>= f = Reader (\r -> f a)?
19:48:12 <tiglionabbit> what's the best place to read about the category theory (monoids, monads, etc)?
19:48:48 <startling> chrisw, not quite.
19:48:57 <startling> chrisw: remember, f :: a -> Reader r b
19:49:17 <kristof> tiglionabbit: category theory as it relates to programming? white papers and blog posts (really). Category theory for the sake of category theory? Pick up an Abstract Algebra textbook, read through that, then pick up an advanced one that covers category theory.
19:49:43 <startling> ^ this is pretty good advice
19:49:45 <chrisw> startling, oh right, I'm losing the definitions in the chat history a bit. Reader a >>= f = f a?
19:49:48 <carter> yup
19:49:48 <tiglionabbit> I want to understand haskell and programming abstractions better
19:49:57 <carter> tiglionabbit: then learn lens :)
19:50:01 <carter> ignore the cat theory
19:50:05 <carter> till you want kittens
19:50:08 <tiglionabbit> lens?
19:50:13 <startling> chrisw: we can switch to #haskell-overflow -- it's less noisy there
19:50:17 <carter> @hackage lens
19:50:17 <lambdabot> http://hackage.haskell.org/package/lens
19:50:27 <carter> its a huge lib
19:50:29 <carter> but very powerful
19:50:31 <carter> and has neat ideas
19:50:36 <edwardk> tiglionabbit: re really learning category theory as it relates to haskell i'd recommend starting from the typeclassopaedia
19:50:45 <haasn> tiglionabbit: have you read the http://www.haskell.org/haskellwiki/Typeclassopedia ?
19:50:58 <haasn> It's not really cat theory but rather Haskell's manifestations of it
19:51:13 <haasn> LYAH also covers that aspect
19:51:50 <augur_> wtf is obt
19:51:54 <augur_> seriously popl people
19:51:59 <carter> augur_: off the beaten track
19:52:06 <carter> its a neat workshop for funky stuff
19:52:10 <carter> why the wtf?
19:52:11 <augur_> i see
19:52:16 <carter> i went 2 years ago
19:52:32 <augur_> carter: wtf cause i keep seeing #obt on twitter and i feel left out!
19:52:40 <kristof> tiglionabbit: In general, if you're using haskell, unless you're a researcher, you don't actually care about category theory per se. You've got these almost-mathy structures for very specific circumstances and someone tells you you should care and you go "Hey! Why should I?" So it's really a case by case thing.
19:52:41 <augur_> its frustrating
19:52:52 <carter> augur_: solution: ASK THEM, dont complain
19:53:04 <carter> google obt popl
19:53:05 <augur_> carter: i just did ask!
19:53:09 <augur_> and i got an answer :)
19:53:22 <csed> Ah yes, the lens package. I have no idea what this is but there's a lot of text and I think my brain stopped working.
19:53:24 <carter> but you needn't have wtfs
19:53:31 <carter> csed: its a neat lib
19:53:33 <kristof> tiglionabbit: For instance, monoids. Hey, you should care about monoids. Why? Because associativite binary functions ROCK. Why? Because now you can trivially parallelize a very large computation across several cores by chunking.
19:53:43 <augur_> carter: neednt, but did
19:53:49 <csed> carter: What sort of magical things does it do?
19:54:07 <carter> csed: imgagine dealing with nested complex nested types
19:54:09 <carter> with no pain
19:54:30 <carter> kristof: parallelism is seldom that simple
19:54:31 <carter> :)
19:54:46 <csed> carter: I imagined a nest of pterodactyls but alright, it'll come to me in time.
19:54:51 <kristof> carter: You're right, it's not, but when we're talking about monoids, it is
19:54:58 <carter> nope
19:55:08 <kristof> carter: And especially when you've got a monoidal homomorphism, then you're rocking
19:55:11 <carter> i mean tuning how you paralllize the monoids
19:55:28 <carter> at some point doing the work on a single core is faste than doing more parallel splitting
19:55:32 <csed> "There is no royal road to Haskell. Euclid" That crazy bastard, he always knows what to say.
19:55:32 <carter> *faster
19:56:06 <kristof> carter: Well tuning is totally different but the point is that you've got this guaranteed no hassle parallelism when you have a monoid structure going on
19:56:13 <cschneid> is there a good rule of thumb on when to use the built-in types versus renaming them via type synonyms? https://gist.github.com/2f4bed73e8e751128e09
19:56:25 <kristof> "Oh, gosh, what if this computation happens before this other one..." Who cares! It's associative! That's all I'm saying.
19:56:36 <carter> cschneid: if they mean different tings, give them different new types
19:56:44 <carter> esp if you'll be sad when you mix them up
19:56:58 <cschneid> carter: would I want to newtype them then?
19:57:01 <carter> sure
19:57:04 <startling> you might make them type parameters instead.
19:57:13 <carter> both !
19:57:20 <carter> erm
19:57:29 <carter> oh yeah
19:57:30 <cschneid> startling: the protocol I'm implementing explicitly says they're strings. So they're not ErrorMessage :: a
19:57:36 <kristof> csed: They're like getters and setters in OO, but they're arbitrarily composable and they play nicely with sum types and product types.
19:57:44 <carter> cschneid: is it an open universe of strings
19:57:51 <carter> or a finite set, but encoded as string
19:58:04 <kristof> csed: Think about being able to reach your hand into the wall of a building and fix a leaky pipe... without rebuilding the building.
19:58:09 <carter> cschneid: i'd use newtype rather than type
19:58:12 <carter> so you don't mix em up
19:58:19 <carter> newtypes are like units in physics :)
19:58:28 <carter> in fact, i've abused em as such!
19:58:49 <cschneid> carter: from my very loose read of the first paragraph or two, it seems an open world of all strings, but I'm unsure so far. :)
19:58:56 <csed> kristof: Now you're speaking my language, simple, simple language.
19:59:25 <kristof> csed: There's an awesome blog post about it floating around on the web, but I don't care to find it for you unless you're really interested, so just let me know
19:59:27 <carter> ok
19:59:31 <carter> then new type em
19:59:34 <carter> and leave em as string internally
20:00:11 <csed> kristof: Nah, I've probably a long way to go before I can comprehend it. Walls and pipes will do for now, thanks.
20:00:14 <qrada> ah.. all I had to do was put spaces between " .. " , ie, [S_IRWXU .. S_IXOTH] , generates my full list
20:00:59 <kristof> the sheer verbosity of the lens library is offputting, to be honest
20:01:26 <kristof> I would commend them for a predictable naming pattern but unfortunately, those names rely on a lot of non-alphanumeric characters! :/
20:01:32 <simpson> Do you mean "depth" or "comprehensiveness?"
20:01:48 <kristof> simpson: Speaking to me?
20:01:50 <simpson> Yes.
20:01:56 <roboguy_> kristof: verbosity?
20:01:57 <simpson> The naming patterns are *very* predictable.
20:02:02 <kristof> simpson: I mean the volume of predefined functions
20:02:09 <kristof> Oh, yeah, they totally are, I agree
20:02:13 <simpson> > (1,2) & _2 +~ 2
20:02:17 <lambdabot>  (1,4)
20:02:46 <kristof> simpson: sure, but it just makes for a steeper learning curve, I think
20:02:49 <Cale> > over _2 (+2) (1,2)
20:02:51 <lambdabot>  (1,4)
20:02:54 <simpson> (+~) means "addition in a basic context", with + meaning "addition" and ~ meaning "in a basic context".
20:03:05 <Cale> My recommendation is to completely avoid the infix operators in lens
20:03:24 <kristof> Cale: Right, it was the infix I was referring to, to be honest
20:03:25 <simpson> kristof: To be honest, I learned lens piecemeal and there are large parts of it that I am only vaguely aware of.
20:03:30 <Cale> --> problem kind of solved (except you probably can't stop other people from using them)
20:03:39 <kristof> simpson: That's also what I'm saying :P
20:03:52 <carter> my main use of lens so far has been "mini lense" when hacking on Setup.hs files!
20:05:46 <edwardk> kristof: my goal with lens was to write something you could grow into. the vocabulary is set up so that a year into it you'll still find it useful, but it does make it quite hard to get started with. not sure how to play off both demands, but i favored too much rather than too little
20:06:59 <carter> edwardk: i may have a go with using machines to show how to write the cache optimal mat mult this week
20:07:04 <carter> mwahahah
20:07:19 <edwardk> carter: i'll be curious to see how it goes
20:07:23 <carter> i am too
20:07:39 <carter> but i think its also exactly the work load that would get hosed by pipes sematnics
20:07:42 <kristof> edwardk: Well, that's fair :)
20:07:50 <carter> i'll sus it out
20:08:36 <carter> i'm now understanding the real reason other people writing the docs is good for your libs,
20:08:45 <carter> it ensures that >1 person is the seed of understanding!
20:08:46 <carter> :)
20:10:29 <kristof> Pair programming libraries is always a good idea (I know you were just talking about docs)
20:10:34 <dsrx> I found SPJ's talk on the lens library to help get over the hump of 'htf do lenses work' at least
20:11:34 <benzrf> guys
20:11:35 <simpson> Intuitively, a lens isn't that hard to grok. I found the sticking points to be: composability, traversals with Applicative, why prisms are useful, and the patterns that some of the combinators follow for (+=) and (.~) and such.
20:11:36 <benzrf> ive figured it out
20:11:48 <benzrf> the universe uses lazy evaluation
20:11:53 <simpson> (.~) still looks like a cultured smiley.
20:12:01 <benzrf> that's why quantum superpositoin occurs
20:12:11 <benzrf> observing something evaluates it
20:12:13 <startling> simpson: haha
20:12:20 <edwardk> simpson: heh. .~  was chosen because .= is the closest i could get to := legally as syntax
20:12:34 <simpson> > 0.~ 8 -- I tip my glass to you, good sir!
20:12:36 <lambdabot>  Could not deduce (GHC.Num.Num
20:12:36 <lambdabot>                      ((a0
20:12:36 <lambdabot>                        -> Control.Lens.Internal.Setter.Mutator GHC.Integer.Ty...
20:12:36 <lambdabot>                       -> s -> Control.Lens.Internal.Setter.Mutator t))
20:12:36 <lambdabot>    arising from the ambiguity check for `e_108'
20:12:49 <simpson> Oh, right. Missing the lens. Hm.
20:13:11 <simpson> edwardk: That's actually really sane. Nice.
20:13:49 <roboguy_> edwardk: what about =:
20:13:52 <edwardk> .= is also is the 'quietest' variant on foo= in terms of syntax and .~ doesn't really call out to be used as . ~
20:14:02 <edwardk> roboguy_: needless inversion relative to all other operators
20:14:29 <roboguy_> yeah, good point
20:14:43 <edwardk> most of the lens operators try very hard for consistency
20:14:58 <edwardk> we actually went through 4-5 variants before we settled on the current approach around lens 2
20:15:00 <csed> benzrf: Brilliant explanation.
20:15:11 <cschneid> sad. My cabal sandbox can't install bytestring. "error: invalid preprocessing directive"
20:16:24 <numberten> anyone know a clean way to turn a bytestring into readable hex?
20:17:35 <cschneid> numberten: yeah, one sec.
20:17:39 <tiglionabbit> is it possible to play with the State monad in ghci?  Can you import things there?
20:17:59 <ion> yes
20:18:21 <roboguy_> tiglionabbit: import imports things. so does :m +ModuleName
20:18:21 <cschneid> numberten: https://gist.github.com/18703b7d08fb50d61b0d
20:18:32 <numberten> cschneid: thanks
20:18:50 <cschneid> numberten: relies on Data.Hex, and BSC == import Data.ByteString.Lazy.Char8 as BSC
20:19:15 <benzrf> csed: entanglement = reference equality
20:19:16 <benzrf> =D
20:19:31 <numberten> k
20:21:08 <cschneid> Any suggestions on fixing sandbox install of bytestring? https://gist.github.com/cschneid/1fb19c8b1b4a532ba920 is what I'm getting. A nondescript error. I do have xcode5 stupidity going on, but I can normally build stuff
20:23:14 <mindleyhilner> what happened to attoparsec's optional?
20:23:17 <mindleyhilner> @hoogle optional
20:23:18 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
20:23:18 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
20:23:19 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
20:23:35 <mindleyhilner> oh wait applicative nvm
20:23:40 <joe9> need some ideas on how to do this, please? I have 2 lists and I want to apply a function for each combination of those 2 values. such as f [0..1] [0..2] => f 0 1, f 0 2 , f 1 1, f 1 2. Any function that can help, please/
20:24:31 <verement> > [ (x, y) | x <- [0..1], y <- [0..2] ]
20:24:33 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
20:24:52 <benzrf> list comps are monad sugar right?
20:25:09 <roboguy_> > do { x <- [0..1]; y <- [0..2]; return (x, y) }
20:25:11 <lambdabot>  [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]
20:25:17 <verement> list monad, yes
20:25:23 <dolio> They are if you turn on a GHC option.
20:25:36 <dolio> And they were back in the day.
20:25:45 <tac> hey benzrf
20:25:47 <benzrf> huh
20:25:49 <benzrf> sup tac
20:25:51 <benzrf> ;p
20:26:09 * tac can never keep Haskell's list comprehension syntax straight
20:26:20 * benzrf never remembers that it exists
20:26:59 <nooodl> liftA2 f?
20:27:55 <benzrf> nooodl: what about it?
20:28:08 <dolio> It's the answer to the question.
20:28:17 <tac> hmm. Does anyone know a handy applicative functor that isn't a monad?
20:28:20 <benzrf> oh i didnt see joe9's chat
20:28:24 <simpson> tac: Const?
20:28:27 <dolio> tac: ZipList.
20:28:36 <tac> tyty
20:28:42 <numberten> cschneid: very clean code, thanks again
20:28:44 <benzrf> dolio: they aren't monads?
20:28:48 <benzrf> oh wait yeah that makes sense
20:28:49 <dolio> They are not.
20:28:53 <benzrf> hunh
20:28:53 <cschneid> numberten: half of it came from this channel a long while ago
20:29:01 <roboguy_> it's not quite the answer
20:29:09 <cschneid> numberten: was working on some encryption puzzles
20:29:10 <benzrf> by that system tuples also could be applicatives but not monads
20:29:16 <benzrf> if you used them like ziplists
20:29:17 <tac> Which is Const again? Does it just map everything to the same object in Hask?
20:29:26 <benzrf> tac: type Const a b = a
20:29:31 <benzrf> or
20:29:37 <benzrf> data Const a b = Const a
20:29:55 <tac> That's not a moand?
20:29:58 <benzrf> newtype would also work i guess
20:29:58 <tac> monad*
20:30:00 <dolio> benzrf: If you take any specific size vector, then zipping/diagonal forms a monad. But if you can form ragged cubes, associativity fails.
20:30:11 <benzrf> ...ragged cubes?
20:30:16 <benzrf> y_y
20:30:48 <dolio> Vec n (Vec n (Vec n a)) is a cube of as with side length n.
20:30:57 <roboguy_> tac: there's no way to "get a b" out of Const
20:31:01 <dolio> But ZipList (ZipList (ZipList a)) isn't necessarily a cube.
20:31:04 <roboguy_> so something like bind wouldn't wor
20:31:05 <roboguy_> work
20:31:14 <tac> ah
20:31:26 <dolio> It can have dents in it and stuff.
20:31:38 <benzrf> argh im too tired for this
20:31:46 <benzrf> im gonna sleep now, thanks
20:34:55 <augur_> man
20:35:04 <augur_> this harper-mcbride tiff on twitter is intense
20:35:50 <tac> link?
20:36:27 <augur_> twitter.com/pigworker
20:36:56 * enthropy didn't know that pseudonym
20:37:17 <augur_> enthropy: pig = epigram
20:37:35 <roboguy_> augur_: I have a feeling that I'm missing lots of context here
20:37:52 <augur_> roboguy_: you have to read back through the last few days of tweets
20:38:05 <roboguy_> is it worth it?
20:38:08 <augur_> no :)
20:38:23 <tac> :X
20:38:24 <augur_> harper is opinionated about extensional vs intensional type theory
20:38:29 <augur_> he really likes ETT
20:38:37 <tac> probably a #h-blah topic
20:38:52 <augur_> but ETT equality isnt decidable in general
20:39:00 <augur_> tac: meh. its quiet in here!
20:39:11 <tac> still, not at all #haskell -related
20:39:20 <augur_> sure it is!
20:39:35 <enthropy> both chanels are off-topic
20:39:41 <augur_> haskell is increasingly dependent, so equality is increasingly important!
20:41:56 <haasn> #haskell is about haskell, and #haskell-blah is about everything that isn't haskell, so it seems to be the union of the two should be about the entire universe
20:42:15 <augur_> haasn: alas, you're thinking constructively!
20:42:38 <augur_> er
20:42:39 <hiptobecubic> haasn, faulty premise.
20:42:40 <augur_> classically
20:42:50 <augur_>  /non-constructively
20:42:54 <hiptobecubic> haasn, #haskell-blah is about *anything* that isn't. not everything
20:43:18 <haasn> hiptobecubic: the topic says “everything except haskell and interval jokes” :)
20:43:35 <augur_> hiptobecubic: oh dear. "anything" vs. "everything"
20:43:36 <hiptobecubic> haasn, well it's clearly lying :)
20:43:45 <augur_> a very tricky distinction
20:44:17 <Tekmo> This sounds like something straight out of meta.stackoverflow.com
20:44:44 <kristof> is that really a ....
20:44:55 <haasn> kristof: sadly
20:45:04 <kristof> Oh, it's just community feedback
20:45:12 <kristof> They didn't need to call it meta SO
20:45:35 <kristof> I prefer meta for really nontrivial self-modification/introspection
20:45:51 <roboguy_> kristof: policy discussions don't count?
20:46:04 <kristof> If it doesn't sound like it should be in Goedel Escher and Bach then it shouldn't be called meta :P
20:46:19 <kristof> roboguy_: meta's just too heavy a word to describe policy discussion
20:46:29 <MorehouseJ09> I'm having trouble compiling with this function signature
20:46:29 <MorehouseJ09> removeNonUppercase :: [Enum a] => [a] -> a
20:46:39 <MorehouseJ09> I want to pass in a char list and return a string
20:46:44 <MorehouseJ09> what would be the best way to do so?
20:46:53 <kristof> MorehouseJ09: takes a list of enumerable things and gives you a single enumerable thing
20:46:58 <Tekmo> First off, constraints are surrounded by parentheses, not brackets
20:47:02 <Tekmo> i.e.: (Enum a) => ...
20:47:04 <kristof> oh, lol, there's that
20:47:16 <Tekmo> If you have only one constraint, you can even remove the parentheses
20:47:18 <roboguy_> meta never really implied deep to me, just working on higher level (it is latin for "beyond" after all)
20:47:21 <Tekmo> Enum a => ...
20:48:09 <MorehouseJ09> removeNonUppercase :: (Enum a) => [a] -> String
20:48:15 <MorehouseJ09> That works - thanks
20:49:23 <kristof> isn't a string a list of chars? Literally a type synonym for [Char]
20:49:48 <pavonia> indeed
20:49:52 <MorehouseJ09> yeah - I'm playing around to see how everything works together. Just want to make sure I understand how all the typeclasses work together
20:49:54 * kristof shrugs
20:50:40 <MorehouseJ09> does haskell allow for variable length of arguments?
20:50:50 <MorehouseJ09> like in some args/kwargs in python and ... in some other languages?
20:51:22 <pavonia> yes, but requires some type class hackery
20:51:45 <Axman6> MorehouseJ09: printf from Text.Printf is an example of varargs in haskell, but as for default arguments like in python, no
20:52:04 <kristof> MorehouseJ09: Oleg has some stuff about that but it's not standard haskell, no
20:52:47 <MorehouseJ09> ok makes sense. I guess default args don't make sense in the essence of functional programming
20:52:48 <kristof> MorehouseJ09: Really, where you wanted a vararg, you can probably make do with passing an explicit list
20:53:27 <MorehouseJ09> how do you differentiate between a list of chars and a string?
20:53:32 <kristof> you don't
20:53:36 <kristof> a list of chars is a string
20:53:42 <MorehouseJ09> ie: I want to pass in a string, and a list of characters to remove
20:53:45 <kristof> you can treat a string like a list of chars or you can take a list of chars and pretend it's a string
20:53:55 <kristof> but you don't have to pretend because it IS a string
20:54:13 <MorehouseJ09> ['e', 't']
20:54:29 <MorehouseJ09> does that not make sense? Compared to "et"
20:54:31 <they> MorehouseJ09: At that point, you can make your function take (Eq a) =? [a] -> [a] -> [a]
20:54:40 <pavonia> @src String
20:54:40 <lambdabot> type String = [Char]
20:55:12 <they> "et" is sugar for ['e','t'], which is sugar for List.
20:55:13 <kristof> MorehouseJ09: treat it like a list, see what happens. You'll be surprised.
20:55:18 <kristof> Or not, if you've been listening :P
20:56:24 <MorehouseJ09> kristof: Yeah I'm starting to understand. Keep screwing up little syntactic bits which are making me question my fundamentals
20:56:30 <MorehouseJ09> thanks for the help btw
20:57:40 <MorehouseJ09> Just to clarify - with this function signature
20:57:40 <MorehouseJ09> (Enum a) => [a] -> [a] -> [Char]
20:57:41 <kristof> MorehouseJ09: LYAH
20:58:09 <MorehouseJ09> if I replace [Char] with [a] then this function will try to return, whatever the calling function is expecting
20:58:23 <td123> I have some functionality in my yesod app that I don't want to run when running the test-suite, anyone have any suggestions on how to achieve this?
20:59:08 <they> MorehouseJ09: It won't really "try to return" it. It will infer the type at the calling location. Whatever type a is.
20:59:52 <MorehouseJ09> they: cool. I didn't word my thoughts well
21:00:33 <MorehouseJ09> hence the reason for context switching - so it works in a polymorphic manner (to use oop terms)
21:00:51 <td123> I could store some kind of value on the foundation, but I'm wondering if there's a cleaner/better way
21:01:21 <they> That, or you can look at it as working on "generics
21:04:05 <zomg> td123: that's an interesting question.. with OOP you'd just replace the object in tests, perhaps you could apply a similar approach by making it possible to replace the function with something else?
21:04:18 <zomg> td123: not really an expert though so don't know what would be the best way in Haskell
21:04:58 <td123> zomg: you could pass functions so I could do that, but I'm not sure how to tell if I'm in a test
21:05:07 <johnw> td123: I would use use cabal flags, and CPP macros to only include the code when building your test
21:05:22 <johnw> in that case, you'll need to include the modules directly into the test, rather than depending on the library
21:05:48 <johnw> you may even be able to get away without using a flag
21:06:10 <jmcarthur> td123: i would treat it as code that i want to interpret two different ways, meaning i'd make a tiny dsl with two interpreters.
21:06:30 <jmcarthur> td123: or at least that's what i say without a whole lot of context
21:07:51 <td123> jmcarthur: I'm writing a custom login system and I need to send out a verification sms message, the problem is every time I run the test to register, it sends me an sms message :)
21:07:52 <alex___> Hi, I'm a student and am becoming acquainted with Haskell. Right now, I need to read a list of values from stdin, sort them lexicographically, and then output them to stdout. Sorting is fine (so elegant!), but reading from stdin is giving me some issues. I've spent several hours looking over how-to's on the internet, but a lot of the example code gets rejected by ghci. Is there a canonical way to read from stdin till EOF?
21:07:57 <markovirc> Hello alex___
21:08:09 <Tekmo> alex___: You can use `getContents`
21:08:15 <Tekmo> alex___: getContents :: IO String
21:08:29 <alex___> hm. let me google that. it wasn't mentioned anywhere
21:08:43 <alex___> is there any way to go from IO String to String, or is that not an issue?
21:09:05 <Tekmo> alex___: You don't need to
21:09:28 <Tekmo> alex___: You do something like this:
21:09:47 <Tekmo> alex___: main = do { str <- getContents; let str' = transform str; putStrLn str' }
21:09:58 <Tekmo> ... where `transform` strings is your pure logic
21:10:29 <they> Remember to flush stdout, too
21:10:32 <alex___>  Tekmo: Cool! let me try that.
21:10:47 <nooodl> alex___: the trick is, you never actually "unpack" "IO a" actions into "a" values in your code, just connect them to other actions
21:10:47 <johnw> alex__: You can also avoid the reading and writing with: interact (unlines . sort . lines)
21:10:51 <Tekmo> they: stdout is line buffered by default, so if he uses `putStrLn` he should be fine
21:11:11 <nooodl> (with do notation, for example)
21:11:19 <alex___> nooodl: that's confusing :P
21:11:48 <Tekmo> alex___: This might help you understand how `IO` works: http://www.haskellforall.com/2013/01/introduction-to-haskell-io.html
21:12:33 <nooodl> where's the shachaf quote about /bin/ls or what was it
21:12:43 <enthropy> @quote contains
21:12:44 <lambdabot> PhilipGreenspun says: Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.
21:12:54 <shachaf> hi nooodl
21:13:00 <nooodl> hichaf
21:13:17 <alex___> Tekmo: I tried `do { str <- getContents; let str' = str; putStrLn str' }` (trying to keep things simple) and got a parse error on input '}'
21:13:24 <alex___> This is in ghci, btw.
21:13:41 <joe9>  Is there a better way of writing this code, please?  http://codepad.org/2IMuHn5n
21:14:16 <alex___> Tekmo: Thanks for the link, by the way. I hadn't come across that one.
21:14:17 <Tekmo> alex___: It's because you probably accidentally copied the newline
21:14:24 <nooodl> joe9: (\f i -> f i) is ($)
21:14:25 <Tekmo> alex___: You need to type it all out on a single line
21:14:37 <alex___> Tekmo: yeah, I did. I'll retype it to make sure.
21:14:38 <Tekmo> alex___: You're welcome
21:15:03 <alex___> Tekmo: Just retyped it. Definitely a parse error.
21:15:06 <nooodl> @quote shachaf.*bin
21:15:07 <lambdabot> No quotes match. There are some things that I just don't know.
21:15:09 <Tekmo> alex___: Yeah, I just tested it, too
21:15:21 <Tekmo> alex___: I found the problem
21:15:35 <alex___> Tekmo: Is there a good way to debug these kinds of errors? I'm always at a bit of a loss.
21:15:39 <haasn> @@ nooodl @quote /bin/ls
21:15:39 <lambdabot>  nooodl shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
21:15:50 <Tekmo> alex___: It should be `...; let { str = str' }; ...`
21:16:06 <Tekmo> alex___: This is easier when it's not in IRC/ghci
21:16:18 <nooodl> "nooodl shachaf" my real name
21:16:20 <alex___> Tekmo: So, nested braces? One for `do` and one for `let`?
21:16:25 <Tekmo> alex___: Right
21:16:30 <shachaf> hi nooodl shachaf
21:17:18 <alex___> Tekmo: Do I need an `in` then? Now ghci is saying '*** Exception: <stdin>: hGetContents: illegal operation (handle is closed)'
21:17:19 <Tekmo> alex___: Here's what it looks like if you don't need to fit it onto one line: http://lpaste.net/9087180913116184576
21:17:46 <Tekmo> alex___: That's because you already read from `stdin` for that `ghci` session, so the handle is now closed
21:17:52 <Tekmo> alex___: You'd have to restart `ghci`
21:18:09 <alex___> Tekmo: Ah! That makes sense. And it's much easier to understand when it's multiple lines.
21:18:25 <Tekmo> alex___: Yeah, do notation is easier when you use multi-line layout
21:18:42 <joe9> nooodl: thanks.
21:18:56 <alex___> Tekmo: Do you have time to answer a few more questions related to that code?
21:19:00 <Tekmo> alex___: Of course
21:20:20 <alex___> Tekmo: Great, thanks! Okay, when I tested it out I noticed two things: 1) typing a character caused it to immediately echo to the screen (e.g. typing 't' gave 'tt'); 2) Ctrl-D (^D) didn't close handle. I had to Ctrl-C (^C)
21:20:46 <Tekmo> That's because of buffering
21:20:52 <tertl3> hello
21:20:52 <markovirc> Hello tertl3
21:20:55 <Tekmo> alex___: ... and also because of lazy IO
21:21:02 <tertl3> hello
21:21:02 <markovirc> Hello tertl3
21:21:08 <Tekmo> alex___: lazy IO is sort of a compromise for beginning haskell programmers
21:21:10 <tertl3> hello
21:21:13 <alex___> Tekmo: Hm...Okay. Can you explain a bit more? I don't quite get it.
21:21:18 <markovirc> Hello tertl3
21:21:25 <alex___> If it's lazy, shouldn't it wait till EOF?
21:21:31 <they> There is a Strict IO package.
21:21:33 <Tekmo> alex___: No, that's why it's called lazy
21:21:48 <Tekmo> alex___: It will help to show you how it behaves without lazy IO
21:21:55 <Tekmo> alex___: You can get the strict equivalent from `System.IO.Strict`
21:22:06 <Tekmo> alex___: That has a `getContents` function which does not return the string until it reads in all input
21:22:18 <Tekmo> alex___: The way you can use this function is something like:
21:22:20 <alex___> Tekmo: Okay, let me try that.
21:22:30 <Tekmo> alex___: I will lpaste an example of how to import it qualified
21:23:15 <Tekmo> alex___: Do you have the Haskell Platform installed?
21:23:22 <Tekmo> alex___: This is a lot easier if you already have the `text` package installed
21:23:33 <Tekmo> alex___: That's usually the recommended way to do strict textual IO
21:23:33 <td123> actually, I can figure out what environment I'm in from the type of config that is stored in the foundation!
21:24:05 <alex___> Tekmo: Nope, I do not. Sorry. The server that will eventually grade this assignment won't have any additional packages.
21:24:15 <Tekmo> alex___: Alright
21:24:15 <tertl3> hola
21:24:25 <Tekmo> alex___: So I will explain roughly what would happen
21:24:33 <Tekmo> alex___: Normally, ordinary Haskell IO is not lazy
21:24:49 <Tekmo> alex___: This means that when you run an IO action it will not complete until the IO action has completed
21:24:57 <td123> might not be the prettiest solution but I think it will work
21:25:06 <Tekmo> alex___: For example, something like `getContents` should wait until it has read in all input before returning the string
21:25:06 <tertl3> may I ask I question that is of topic but not irrelavant
21:25:25 <alex___> Tekmo: I follow.
21:25:36 <Tekmo> alex___: Haskell has this weird lazy backdoor that lets you defer IO actions until you actually need their values.  They will then run in response to demand
21:25:47 <tertl3> do most or all of the code in the US and Europe written in English?
21:26:00 <Tekmo> alex___: So what's happening is that when you are doing `str <- getContents` that `str` is really a lazy "promise" that it will provide the `str` when you actually need it
21:26:21 <Tekmo> alex___: So in the case of your code it doesn't do any reading until you try to print the string
21:26:33 <Tekmo> alex___: That's when you demand the string's value so it stops being lazy and begins to read user input
21:26:53 <Tekmo> alex___: That's why it was printing out characters as you typed them in
21:27:16 <Tekmo> alex___: Lazy IO is convenient for small programs, but it's generally considered back practice for real programs
21:27:20 <Tekmo> *bad practice
21:27:53 <Tekmo> alex___: For your assignment it is probably fine
21:29:03 <alex___> Tekmo: Okay, so `str <- getContents` makes a lazy promise and then `let str' = str` causes it to get the value?
21:29:30 <alex___> Tekmo: And since there's only been a single character typed (you mentioned a buffer?) that's all that goes to str'
21:29:32 <Tekmo> alex___: Actually, `str' = str` does nothing to demand the value
21:29:39 <Tekmo> alex___: `let` declarations are lazy
21:29:45 <Axman6> @hoogle MonadIO
21:29:46 <lambdabot> Network.CGI class Monad m => MonadIO (m :: * -> *)
21:29:46 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
21:29:46 <lambdabot> package monadIO
21:29:46 <Tekmo> alex___: They don't force the right-hand side at all
21:30:06 <Tekmo> alex___: All you're doing with `let str' = str` is just providing a synonym for referring to `str`
21:30:26 <Tekmo> alex___: Now you just have two different names pointing to the same deferred string
21:31:02 <alex___> Tekmo: Okay, I think I understand that part. What about not stopping at Ctrl-D?
21:31:07 <Tekmo> alex___: Actually, I misspoke about the buffer
21:31:22 <Tekmo> alex___: The reason it works on a character-by-character basis is because that's how `putStrLn` demands the result: character-by-character
21:31:33 <Tekmo> alex___: The reason it didn't stop at `Ctrl-D` is just a quirk of ghci
21:31:40 <Tekmo> alex___: If you compile the program and run it then `Ctrl-D` will work
21:31:46 <alex___> Tekmo: Oh, ok. Let me compile
21:33:04 <alex___> Tekmo: Okay, that makes a lot more since. I'll compile for IO stuff from now on.
21:33:25 <Tekmo> alex___: Compilation only really affects buffering and `Ctrl-D`
21:33:56 <alex___> Tekmo: I think that provides a good foundation for me to continue coding. I had everything working with String in ghci, so this should be okay.
21:35:03 <alex___> Tekmo: One last (subjective) question: How long does it take to advance from novice to competent with Haskell programming?
21:35:24 <they> Probably a year. Maybe that and a half.
21:35:35 <Tekmo> alex___: You're taking classes, right?
21:35:38 <alex___> they: Much to learn then!
21:35:55 <alex___> Tekmo: Well, the class is in programming languages. It's not about Haskell, specifically.
21:36:05 <Tekmo> alex___: It's about a year if you don't do it full time
21:36:11 <Tekmo> alex___: Less if you do it full time
21:36:53 <alex___> Tekmo: Alright. I had a choice of doing this in C or learning a bit of Haskell using it. I think I made the right choice.
21:36:56 <MorehouseJ09> I keep getting this around my functions:     Could not deduce (a ~ Char)
21:37:16 <Tekmo> alex___: Awesome :)
21:37:26 <MorehouseJ09> removeCharacters:: (Enum a) => [a] -> [a] -> String 17 removeCharacters [] [] = "Empty list" 18 removeCharacters (x:xs) exclude = 19 20         [ x | x <- (x:xs), x `elem` exclude]
21:37:52 <MorehouseJ09> that didn't copy well - but the list comprehension part keeps saying it can't deduce type from context
21:38:13 <alex___> Tekmo: Thanks for the help! I'm going to go now.
21:38:19 <Tekmo> alex___: You're welcome!  Good luck
21:41:24 * hackagebot esqueleto 1.3.4.5 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-1.3.4.5 (MichaelSnoyman)
21:41:43 <Tekmo> MorehouseJ09: That's because you are working with strings, not arbitrary lists
21:41:50 <Tekmo> MorehouseJ09: A `String` is the same thing as [Char]
21:42:09 <Tekmo> MorehouseJ09: The compiler says that `[a]` is not the same thing as `[Char]`, and it reduces the error message to saying that `a` is not the same thing as `Char`
21:42:44 <Tekmo> MorehouseJ09: Right now your type signature says that your functions works for all possible lists of values that implement `Enum`, but that's not correct
21:42:49 <Tekmo> MorehouseJ09: Your function only works for `String`s
21:43:58 <Tekmo> MorehouseJ09: If you want to format your code, you can use lpaste.net to paste multi-line code
21:45:09 <MorehouseJ09> Tekmo: what would be a good way to iterate through a string then?
21:45:29 <MorehouseJ09> I'm guessing it doesn't iterate like my enum typeclass context check requests?
21:45:46 <Tekmo> MorehouseJ09: So this is just removing uppercase characters ,right?
21:45:53 <Tekmo> MorehouseJ09: Then the function you need is `filter`
21:45:55 <Tekmo> :t filter
21:45:56 <lambdabot> (a -> Bool) -> [a] -> [a]
21:46:10 <Tekmo> If you replace the `a` in that type signature with `Char`, you get:
21:46:18 <Tekmo> (Char -> Bool) -> [Char] -> [Char]
21:46:23 <Tekmo> ... which is the same thing as:
21:46:29 <Tekmo> (Char -> Bool) -> String -> String
21:46:46 <MorehouseJ09> Tekmo: yeah just removing characters
21:46:50 <Axman6> hmm, what difference is ther between State.Strict and State.Lazy? I can't seem to see much difference in their source
21:46:58 <Tekmo> So you basically give it a function that decides on a per-character basis whether or not to keep the character, and then it will transform the string for you
21:47:02 <Tekmo> Here's an example
21:47:08 <agibiansky> Hey there! I'm having an issue with cabal sdist. As long as my build type isn't Simple (its Custom) cabal sdist refuses to make a source distribution, because I have a Paths_foo module that it autogenerates, and it can't find it. I have cabal 1.18.0.2. Does anyone have any ideas?
21:47:10 <Tekmo> > filter (/= ' ') "Hello           World"
21:47:12 <lambdabot>  "HelloWorld"
21:47:33 <Axman6> I san't seem to see anywhere where that things are forced, so i'm not sure how it's strict
21:47:45 <Tekmo> Axman6: The difference is in the bind for the `Monad` instance
21:47:56 <Tekmo> Axman6: You'll see that the lazy one has something like `~(r, s) <- ...`
21:48:04 <Axman6> ah, I see
21:48:09 <MorehouseJ09> Tekmo: gotcha - rewriting it to play with the filter function instead
21:48:36 <Tekmo> MorehouseJ09: Also, `Data.Char` has a useful function for your purpose
21:48:42 <Tekmo> :t isUpper
21:48:43 <lambdabot> Char -> Bool
21:48:46 <Tekmo> :t isLower
21:48:47 <lambdabot> Char -> Bool
21:48:48 <Axman6> I didn't look at the lazy one's sourtce because I assumed I knew it already. should've realised that it wasn't that Strict is explicitly more strict, it's that Lazy is explicitly more lazy =)
21:48:53 <Tekmo> You can pass those to filter
21:48:57 <tertl3> im ready to implement my list parser
21:49:22 <agibiansky> Anyone with ideas for cabal sdist? :(
21:49:28 <Tekmo> Axman6: Right
21:49:36 <tertl3> idk what sdist is
21:50:14 <Tekmo> agibiansky: I don't have any expertise on this.  Sorry :(
21:50:21 <agibiansky> nah, it's fine
21:50:56 <carter> agibiansky: go on #hackage ans ask there
21:51:02 <carter> also there probably a cabal hook
21:51:24 <carter> agibiansky: http://hackage.haskell.org/package/Cabal-1.18.1.2/docs/Distribution-Simple.html yup
21:51:24 <agibiansky> carter: thanks. i don't need a cabal hook, i am using one already and it's breaking everything. will ask there, i think
21:51:32 <carter> how it breaking?
21:51:40 <agibiansky> It can't find Paths_ihaskell
21:51:46 <carter> agibiansky: generate that at configure time
21:51:46 <agibiansky> And freaks out and dies
21:51:47 <carter> and add it
21:51:53 <carter> dont add it at sdist time
21:52:01 <carter> preconfig hook
21:52:04 <agibiansky> erm, but that's supposed to be generated on the user side of things?
21:52:08 <AlbertoAlberto> Hi to everyone. I am creating the .exe file from the (existing) file "MonodyFrèreJacques.hs". However, when i give the command: ghc --make "MonodyFrèreJacques.hs" i get this error message: Linking MonodyFrèreJacques.exe ...
21:52:08 <AlbertoAlberto> C:\Program Files (x86)\Haskell Platform\2013.2.0.0\lib/../mingw/bin/windres.exe
21:52:08 <AlbertoAlberto>  can't open file `MonodyFrÜreJacques.exe.manifest': No such file or directory
21:52:08 <carter> wha tis?
21:52:19 <agibiansky> Paths_ihaskell
21:52:29 <carter> hows it user generated if its in setup.hs
21:52:32 <agibiansky> It's not
21:52:34 <carter> ok
21:52:44 <carter> so the issue is you want to make sure cabal knows about this module
21:52:45 <agibiansky> Paths_foo are modules that cabal automatically generates
21:52:49 <carter> ok
21:52:50 <agibiansky> when you install a module
21:52:52 <carter> always?
21:52:53 <agibiansky> that tell it where your data files are
21:52:54 <agibiansky> yes
21:52:57 <carter> ok
21:53:01 <carter> linke to setup.hs?
21:53:07 <agibiansky> No no no
21:53:15 <agibiansky> the rest of ihaskell uses it
21:53:18 <agibiansky> but setup.hs doesn't care about it
21:53:24 <agibiansky> however, b/c its in exposed-modules
21:53:30 <agibiansky> setup.hs decides it needs to find it
21:53:45 <agibiansky> but it can't, b/c its not a real module, b/c it is a module genreated at cabal configure time when you install
21:53:53 <carter> umm
21:53:58 <agibiansky> custom-generated for everyone to point to their individual data files
21:54:03 <carter> generate ats as a preconfigure hook
21:54:08 <eazar001> tertl3: source distribution
21:54:10 <carter> not as a configure hook
21:54:16 <agibiansky> im not generating it myself
21:54:19 <agibiansky> this is standard cabal functionality
21:54:20 <carter> why not
21:54:21 <carter> ok
21:54:29 <carter> wheres the docs?
21:54:39 <carter> lets look at the docs together
21:54:40 <carter> :)
21:54:55 <carter> agibiansky: also get on #hackage :)
21:54:58 <agibiansky> http://www.haskell.org/cabal/users-guide/developing-packages.html  C-f getDataFileName
21:55:40 <Platz> trying to grok reader monad.  is the last question here correct or have I not interpreted the args correctly ? http://lpaste.net/99099
21:55:55 <joelteon> is there any practical usage for TardisT
21:56:46 <haasn> joelteon: I had one once but turns out programming it with TardisT was more confusing and verbose and difficult than just passing the future/past manually
21:56:58 <haasn> joelteon: it involved parsing sets of matching parens
21:57:08 <joelteon> yeah that's what i thought
21:57:33 <johnw> joelteon: I had one once too, and then realized it could be solved much simpler
21:58:12 <pavonia> Platz: yes
21:58:18 <johnw> Platz: the fact that that questions suggests two different types for "e" makes no sense to me
21:58:27 <johnw> unless he doesn't mean e to be an actual type variable
21:58:54 <jmcarthur> never used TardisT, but I have used ReaderT s (WriterT s) where in the run function i fed the writer result back as the argument to the reader
21:59:26 <johnw> I know, we just need RWTardisT
21:59:39 <Platz> johnw: either could have two different types, but when join is applied to it i believe it constrains the types
21:59:53 <joelteon> RWSTardisT
21:59:58 <jmcarthur> johnw: yeah it could basically be what i just described composed with TardisT
21:59:58 <joelteon> concurrent-tardis is coming next
22:01:04 <johnw> it's cool that TardisT can be written, no doubt; but I would scratch my head to understand the code a year later
22:01:25 <johnw> since it's not something you use often enough for it to reach muscle memory
22:01:53 <Platz> pavonia: thanks, it gets a bit confusing sorting when e represents a function (in join) in, vs when e represents an environment (in reader)
22:02:24 <haasn> Platz: (e -> e -> a) becomes (e -> (e -> a )) so that matches e with (a -> c) and (e -> a) with (b -> c)
22:02:35 <haasn> s/becomes/parses as/
22:03:01 <jmcarthur> i think ReverseT is even cooler than TardisT
22:03:47 <haasn> Platz: also your type signature on line 6 seems off
22:04:27 <jmcarthur> ReverseT reverses the effects of any instance of MonadFix
22:04:37 <haasn> ConTardisT
22:04:47 <Platz> haasn: I may have copied that incorrectly
22:06:27 * hackagebot ihaskell 0.3.0.3 - A Haskell backend kernel for the IPython project.  http://hackage.haskell.org/package/ihaskell-0.3.0.3 (gibiansky)
22:09:20 <jmcarthur> old versions of attoparsec has MonadFix. i wonder what reversing the effects of a parsing monad even means
22:09:59 <jmcarthur> also wonder why that instance was removed
22:11:03 <tabemann> okay, I forget, what is the name of the lambdabot feature that looks up things by type?
22:11:40 <enthropy> @hoogle Int -> Int
22:11:40 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
22:11:41 <lambdabot> Data.Text.Unsafe iter_ :: Text -> Int -> Int
22:11:41 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
22:11:43 <jmcarthur> tabemann: http://www.haskell.org/hoogle/
22:11:59 <jmcarthur> tabemann: it's also a package you can install and use on all your local packages
22:12:06 <jmcarthur> tabemann: via command line
22:13:29 <tabemann> yeah, I just remembered soon thereafter that Hoogle or Hayoo could do it (haven't been programming in a while, so kind of forgot)
22:15:14 <td123> yup, the environment is stored in the foundation so I can just do some optional loading, that works, at least for now
22:20:13 <jfeltz> oh god, I just found out that I've been effectively thinking about p -> q, (implication) backwards all these years :(
22:31:39 <mastensg> `.
23:02:09 <adek> \
23:10:00 <qrada> hey, in ghci i keep getting this error when i load some .hs im working on: GHCi runtime linker: fatal error: I found a duplicate definition for symbol fps_maximum
23:10:03 <qrada> whilst processing object file /usr/lib/ghc/bytestring-0.9.2.1/HSbytestring-0.9.2.1.o
23:10:11 <qrada> anyone ever experience this? keeps crashing ghci
23:13:55 <numberten> is there a way to make getArgs read newline characters?
23:14:14 <DarkFox> What's the fastest current hashtable/map/object in Hackage?
23:14:58 <startling> DarkFox, it depends what you're doing.
23:15:26 <startling> if you're going to be inserting I bet Data.Map in containers is pretty fast. If you don't plan on updating it ever there are some better options iirc.
23:15:40 <DarkFox> startling: Doing lookups against 160-bit keys, for data of variable size.
23:15:40 <Twey> numberten: getArgs does read newline characters
23:15:51 <Twey> numberten: Whether your shell passes them or not is a different matter, of course
23:16:12 <Twey> You might need to quote them or something.  ./foo "bar\nquux"
23:16:50 <numberten> right now i'm passing strings with '\n' from the shell
23:16:58 <numberten> and when I take the length of the string after getArgs
23:17:02 <numberten> it counts \n as 2 characters
23:17:06 <numberten> messing up length count
23:17:32 <DarkFox> startling: Inserting and updating, but through manual process; not automated masses.
23:17:37 <numberten> i'll take a look at things on my shell's end though. thanks
23:17:42 <Qett> is the map function always lazy in haskell?
23:18:12 <Platz> yay typeclassopedia complete
23:18:13 <Twey> Qett: It will always have non-strict semantics, i.e. you can always assume it will be lazy
23:18:40 <Platz> had to skim arrows, getting late
23:18:40 <Qett> Twey: so if i have a function that returns map a b
23:18:47 <Qett> then i use that result in another fuction
23:18:51 <startling> DarkFox: have you seen IntMap?
23:18:56 <Qett> can i assume that the map will happen only when needed?
23:18:57 <Twey> Implementations may not be lazy; GHC does strictness analysis and makes things strict if it can do so safely and in a way that will improve performance, for example
23:19:01 <startling> I guess that won't work.
23:19:02 <Twey> Qett: Yes
23:19:05 <DarkFox> startling: Haven't played with it yet.
23:19:10 <Qett> ok Twey thanks
23:19:11 <startling> DarkFox: I guess Data.Map is probably the best thing
23:19:40 <DarkFox> startling: Okay; how about if I add another factor the the equation.... A distributed hash table? ;)
23:20:07 <Twey> numberten: That's nothing to do with getArgs.  If you pass in a newline, you'll get a newline; if you pass in a backslash followed by an n, you'll get a backslash followed by an n
23:20:18 <numberten> yeah
23:20:28 <Twey> getArgs just does what it says on the tin
23:21:33 <DarkFox> startling: Afaik; there isn't any DHT library?
23:22:07 <startling> DarkFox: I don't know.
23:22:40 * DarkFox thinks it would be better if he explained what he is trying to do exactly.
23:25:07 <DarkFox> I want to have a distributed public database, where the owner of the tiny amount of content is the only who can modify their entry. Each entry has a set expire date and may be revoked by the owner. The content that is to be on this DHT could vary for different uses, while a main purpose would be for storing user keys. These keys can store metadata; I guess the metadata can be Data.Map, not sure for the rest of it.
23:25:13 <DarkFox> startling: ^
23:28:22 <startling> DarkFox: I don't know.
23:28:34 <DarkFox> Okay
23:28:36 <DarkFox> Thanks anyway
23:28:39 <DarkFox> I'll keep looking
23:32:12 <Twey> DarkFox: You might be interested in https://github.com/mwotton/sofadb
23:32:28 <dhrosa> @pl incSP state = setSP ((getSP state) + 1) state
23:32:28 <lambdabot> incSP = setSP =<< (1 +) . getSP
23:32:39 <Twey> (or in speaking to mwotton in general)
23:32:59 <dhrosa> @pl incSP x= setSP ((getSP x) + 1) x
23:32:59 <lambdabot> incSP = setSP =<< (1 +) . getSP
23:33:06 <dhrosa> which monad is that using oO
23:33:12 <Twey> (r →)
23:33:47 <Twey> @src (->) (>>=)
23:33:48 <lambdabot> f >>= k = \ r -> k (f r) r
23:35:59 <dhrosa> hmm, so (1+) . getSP is an State->SP, getSP is a State -> SP, setSP is a SP -> State -> State
23:36:07 <tabemann> anyone have any idea of what I'm doing wrong here?: http://lpaste.net/99104
23:36:32 <DarkFox> Thanks Twey I'll have to check this one out
23:36:46 <tabemann> the thing about this code is that "primes", as defined in it, works perfectly okay in some other code, but fails horribly in this use case
23:37:18 <tabemann> i.e. I pulled it directly out of my (correct) implementation of Project Euler problem 7
23:37:39 <dhrosa> Twey: can you explain succinctly how the monad instance for function application works? bind specifically
23:38:56 <prooftechnique> tabemann: Well, first, you should use print. But also, what problem are you encountering?
23:39:14 <prooftechnique> dhrosa: f >>= k = \ r -> k (f r) r
23:39:20 <prooftechnique> Is that succinct enough? :D
23:39:46 <Twey> dhrosa: I thought I just did :þ
23:40:21 <tabemann> prooftechnique: well, it's just not exiting, even though it seems it *shouldn't* take *that* long to create *that* many prime numbers by the method I'm using
23:40:22 <Twey> The fact that it's a monad isn't all that important here — just know that (>>=) is an operator that does that
23:40:28 <startling> dhrosa, it's just like Reader
23:40:43 <startling> :t (>>=) `asAppliedTo` id
23:40:44 <lambdabot> (a -> a) -> (a -> a -> b) -> a -> b
23:40:59 <startling> :t (>>=) `asAppliedTo` (undefined :: a -> b)
23:41:00 <lambdabot> (a -> b1) -> (b1 -> a -> b) -> a -> b
23:41:29 <tabemann> is there anything obviously wrong with what I'm doing, not just from a correctness standpoint but also from a performance standpoint?
23:41:38 <prooftechnique> tabemann: What is the problem statement?
23:41:42 <qrada> i had to ghc-pkg unregister bytestring-... to fix that weird fps_minimum error where ghci crashes, fyi
23:42:03 <dhrosa> it takes an a->c, and an a->b->c, and returns an d->c?
23:42:08 <dhrosa> wait no
23:42:21 <Twey> tabemann: It's quite a slow method.  For the nth prime number, you're doing n tests — so by the end you're testing every prime nearly two million times
23:42:29 <tabemann> prooftechnique: The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17. Find the sum of all the primes below two million.
23:42:47 <prooftechnique> tabemann: sum (take 1999999 primes)
23:42:58 <startling> prooftechnique: heh, not quite
23:43:04 <startling> "below", not "before the nth prime"
23:43:16 <dhrosa> sum (takeWhile (<2000000) primes)
23:43:17 <prooftechnique> Oh, duh
23:43:19 <prooftechnique> Hahaha
23:43:25 <prooftechnique> takeWhile, then
23:43:39 <tabemann> Twey: I had to write it this way for a previous problem, but in this case I could get better performance out of it by using the sieve of eratosphenes
23:43:56 <startling> tabemann: yeah. you're doing trial division right now?
23:44:07 <Twey> tabemann: The Sieve of Eratosthenes is almost always a better idea when you have a (reasonable) fixed number of primes to generate, or there are weird and wonderful number-theoretic contraptions like the prime wheel
23:44:34 <tabemann> I mostly wrote it this way for this problem because the previous problem required creating an unlimited number of primes, i.e. the sieve of eratosthenes wouldn't've worked
23:44:40 <tabemann> and i was reusing the code
23:45:03 <Twey> tabemann: There's a whole page on primes: http://www.haskell.org/haskellwiki/Prime_numbers
23:45:16 <prooftechnique> There are some very cute algorithms on that page ^
23:45:19 <dhrosa> so >>= for functions takes a function a->b, an b->a->a, and returns an a->a?
23:46:38 <startling> dhrosa, "takes a function a->b, an b->a->c, and returns an a->c"
23:46:53 <Twey> dhrosa: r → a and a → r → b and returns r → b
23:47:11 <Twey> m a → (a → m b) → m b
23:47:15 <dhrosa> I see
23:47:15 <Twey> m = (r →)
23:47:33 <prooftechnique> dhrosa: It may be easier to think of it as (->) r
23:47:42 <tabemann> okay, so I should probably just select one of those algorithms, and probably have better luck than with this code
23:48:04 <numberten> i'm getting a stack space overflow from this loc: head . filter (compareHex d . sha1 s) $ [1..]
23:48:22 <numberten> wouldn't that only ever access one element at a time?
23:48:24 <prooftechnique> tabemann: I think sum (takeWhile (<2000000) primes) should work with just about any sieve
23:48:41 <prooftechnique> I haven't done that problem since 7.4 or so, but I think that's what I did
23:48:42 <numberten> doesn't seem like the sort of thing that would cause stack buildup
23:49:00 <tabemann> prooftechnique: yeah, I implemented that part just because I'd forgotten about takeWhile
23:50:39 <prooftechnique> :t compareHex
23:50:40 <lambdabot>     Not in scope: `compareHex'
23:50:40 <lambdabot>     Perhaps you meant `compare' (imported from Data.Ord)
23:51:04 <prooftechnique> numberten: What are the types of those functions?
23:51:16 <Twey> numberten: You're probably not getting the stack overflow from that, which should be constant-space (modulo integer size)
23:51:43 <Twey> I suspect the problem is elsewhere in your code, perhaps in the definitions of d or s
23:51:56 <dhrosa> how do I properly partially apply a subtraction in haskell?
23:52:02 <dhrosa> it takes (-2) is a literal
23:52:09 <dhrosa> err (-1)
23:52:13 <Twey> Or compareHex or sha1, of course, though sha1 should be constant-space if you've implemented it properly
23:52:22 <mindleyhilner> sheoq (subtract 1)
23:52:25 <mindleyhilner> dhrosa: *
23:52:28 <mindleyhilner> dhrosa: ^
23:52:37 <Twey> dhrosa: There's a special ‘subtract’ function, or you can say ((-) 2)
23:52:54 <Twey> Negation is a mess in Haskell
23:52:59 <prooftechnique> Twey: ((-) 2) does it the other way
23:53:02 <dhrosa> ah
23:53:03 <Twey> Right
23:53:23 <mindleyhilner> :t (flip (-) 2)
23:53:24 <lambdabot> Num c => c -> c
23:53:28 <prooftechnique> subtract is the way to go for that, though I suppose it's not really a "section", at that point
23:53:29 <Twey> subtract = flip (-)
23:53:58 <dhrosa> @pl stackPush val state = incSP $ writeDMem (getSP state) val state
23:53:58 <lambdabot> stackPush = (incSP .) . join . flip (writeDMem . getSP)
23:54:00 <numberten> d and s are both strings from readArgs
23:54:11 <dhrosa> ok that's a bit too obtuse
23:54:13 <prooftechnique> dhrosa: Hahaha, please don't put that in code :D
23:54:32 <prooftechnique> numberten: Can you paste the code?
23:55:45 <numberten> prooftechnique: sha1 :: String -> Integer -> String and compareHex :: String -> String -> Bool. I just changed the Integer to an Int
23:55:50 <numberten> and i stopped getting the overflow
23:55:59 <prooftechnique> That's weird
23:56:02 <numberten> don't really understand why though
23:56:20 <numberten> even if Integer take up more room wouldn't they just be gc'ed?
23:57:19 <prooftechnique> What does sha1 look like? What's the Int for?
23:57:42 <prooftechnique> And I think there are easier ways to compare hex values
23:58:08 <prooftechnique> > compare 0xAA 0xAA
23:58:09 <lambdabot>  EQ
23:58:56 <Twey> dhrosa: Please don't use @pl-generated code in programs :þ
23:59:16 <dhrosa> I'm not going to use that latest @pl
23:59:53 <prooftechnique> @pl \a b c d -> a (b (c d))
23:59:53 <lambdabot> (. (.)) . (.) . (.)
