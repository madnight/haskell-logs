00:00:05 <jle`> ah ok.
00:00:07 <shachaf> OK, I see what you meant now. Yes, like Alternative.
00:00:09 <jle`> wasn't really sure what it really meant.
00:00:23 <Cale> Like if you write x = x + 1
00:00:25 <shachaf> So []/(++) would be an example.
00:00:27 <Cale> That'll cause it
00:00:34 <Cale> shachaf: yep!
00:01:02 <jle`> hm thanks.
00:01:06 <jle`> i wonder where it's coming from.
00:01:07 <shachaf> What about (:+:)/Void1? I bet that ends up being boring, like Either/Void monoids do.
00:01:28 <Cale> jle`: I most often find that it's something stupid, where I've reused a name and ended up producing a recursive definition where I didn't intend to.
00:01:36 <roboguy_> jle`: ghc's the first programming environment I've used that has infinite loop detection (to some extent)
00:01:55 <Cale> shachaf: Yeah
00:02:01 <dleedev> Cale: so is it right to say that return (eta) is the monoid's unit, and that join (mu) is the monoid's binary operator?
00:02:34 <Cale> dleedev: yes, abstractly. I don't think most people would use the word "binary operator", but "multiplication" is common enough.
00:02:54 <shachaf> Right, the laws force it to be mult :: F a :+: F a -> F a; mult (L x) = x; mult (R y) = y
00:03:03 <Cale> dleedev: (but that's just terminology convention, you have the right idea)
00:03:13 <dleedev> Cale: cool
00:03:24 <ratzes> is it possible to use environment variables in a cabal file for something like the include-dirs field?
00:03:39 <dleedev> Cale: for an endofunctor, is a natural transformation the same thing as functor composition?
00:03:45 <Cale> dleedev: People also refer to return as the *monad*'s unit, and join as its multiplication
00:04:00 <Cale> (people who have their category theorist hats on)
00:04:09 <Cale> dleedev: no, it's different
00:04:16 <johnw> dleedev: there are also two kinds of functor composition
00:04:30 <Cale> dleedev: natural transformations F -> G are sort of like polymorphic functions F a -> G a
00:05:19 <Cale> johnw: There's that too, but we don't need horizontal composition here :)
00:05:46 <Cale> Er, you mean natural transformations have two kinds of composition
00:06:24 <dleedev> We we say "Monad m", m is the endofunctor, right?
00:06:28 <Cale> yes
00:06:30 <apples> heh, i was sitting here googling horizontal functor composition and wondering why it looked like what i already had heard about
00:07:07 <roboguy_> Cale: I thought functors have two different kinds of composition. data Product f g a = Product (f a) (g a) and data Compose f g a = Compose (f (g a))
00:07:10 <Cale> dleedev: In this case, an endofunctor on the category of Haskell types. It sends types to other types, and it sends functions (a -> b) to functions (m a -> m b) by way of fmap (or liftM)
00:07:35 <dleedev> Cale: oh yeah, I had a question about the _M function naming convention
00:07:39 <Cale> roboguy_: Well, okay, there's the product, but that's not usually called composition...
00:07:43 <dleedev> what does a function ending with "M" mean?
00:07:58 <Cale> dleedev: That it has something to do with monads?
00:08:04 <Cale> :t map
00:08:05 <lambdabot> (a -> b) -> [a] -> [b]
00:08:07 <Cale> :t mapM
00:08:08 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
00:08:08 <dleedev> Cale: that's it?
00:08:10 <Cale> yep
00:08:14 <roboguy_> Cale: ah, I see. there's an article I read that called it composition. that might not have been totally accurate though
00:08:16 <dleedev> Cale: no stronger convention?
00:08:23 <Cale> It's just to avoid horrible name collisions which would make things pretty unusable
00:08:29 <dleedev> Cale: such as "always returns a monad"
00:08:43 <Cale> dleedev: Functions at the level of values in Haskell never return a monad
00:08:52 <Cale> dleedev: monads live at the type level
00:08:54 <apples> roboguy_, i'd think that if you called products composition, you'd have to call coproducts composition too
00:08:59 <Cale> They're things which send types to other types
00:09:06 <johnw> mposition
00:09:07 <Cale> Maybe is a monad
00:09:11 <Cale> Just 5 is not
00:09:27 <dleedev> Cale: sorry, I meant something wrapped in m
00:09:48 <Cale> dleedev: You can usually guess that it will produce something whose type involves m
00:10:04 <Cale> dleedev: Because Monad only gives you ways to increase the number of m's involved
00:10:10 <Cale> er, not true
00:10:11 <Cale> lol
00:10:14 <dleedev> Cale: but only "involves" m, and not of type m a?
00:10:19 <Cale> But it doesn't give you a way to reduce it to 0
00:10:26 <frx> what is a proper terminology for Just 5? monadic value?
00:10:32 <Cale> frx: That works
00:10:42 <roboguy_> apples: hmm, yeah. the article was basically about how you can derive a lot of Applicative Functors by combining some very basic ones with Product and Compose
00:10:50 <shachaf> Monad lets you get "m a" from "m^n a" for any n.
00:10:56 <Cale> frx: Depending on my mood, I might call it a Maybe value, or a Maybe-computation
00:11:03 <Cale> or a Maybe-action
00:11:06 <shachaf> And similarly Comonad lets you get "w^n a" for any n from "w a"
00:11:14 <Cale> (though Maybe is the worst example ever for why I'd use those words)
00:11:55 <Cale> m-action is usually what I'd say in general
00:11:57 <dleedev> Cale: but in terms of "Monad"
00:12:15 <shachaf> Which is nearly the "monads are just free monad monad monad algebras" thing, except I'm talking about the type "data Froo f a = Pure a | Froo (Froo f (f a))"
00:12:23 <dleedev> Cale: Maybe is a Monad. Just 5 is a __phrase using Monad here___.
00:12:32 <shachaf> Does that type have a name? How is it related to free monads?
00:12:39 <shachaf> (Also I should stop using that confusing phrase.)
00:12:43 <Cale> dleedev: Just 5 doesn't have anything to do with monads in general
00:13:04 <Cale> dleedev: The fact that it happens to belong to a type which is constructed using some monad is... a bit far removed
00:13:11 <dleedev> what about... "a value of a monad instance type"
00:13:21 <Cale> Maybe only just *happens* to be a monad in the first place
00:13:40 <Cale> If all you know about some type constructor is that it's a monad, you don't really know a whole lot.
00:13:46 * hackagebot egison 3.2.5 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.5 (SatoshiEgi)
00:13:46 * hackagebot xml-to-json 0.1.2.0 - Library and command line tool for converting XML files to json  http://hackage.haskell.org/package/xml-to-json-0.1.2.0 (NoamLewis)
00:14:12 <Cale> I would always use the more specific term if it's available
00:14:22 <dleedev> Cale: by "type constructor" you mean "Just"?
00:14:24 <Cale> Or I would name the monad M, and use the word M-action.
00:14:38 <Cale> No
00:14:40 <Cale> I mean Maybe
00:14:52 <Cale> Maybe is a monad, Just is not a monad. Anything which is a value in Haskell is not a monad.
00:14:59 <dleedev> Cale: ah, "Just" is the value constructor.
00:15:05 <Cale> yeah, or data constructor
00:15:22 <Cale> (value constructor is also a fine name for what it is)
00:16:29 <Cale> I might say something like "Suppose M is a monad, and suppose that x is some M action."
00:17:37 <Cale> If it's worth saying that x has something to do with some monad, it's worth giving that monad a name, even if it's just a temporary one.
00:18:13 <Cale> Because if you know that two values have types which are constructed by monads in general, you know absolutely nothing of any use that you can do with both of them.
00:18:35 <Cale> You need to know that they're computations in the same monad
00:18:46 <Cale> before you can put them together in any way
00:19:02 <jle`> my wire is only <<loop>>ing when it is used in an ArrowLoop
00:19:10 <Cale> jle`: oh, fun
00:19:21 <Cale> jle`: ArrowLoop's loop is like fix
00:19:26 <Cale> > fix id
00:19:27 <jle`> this is really beyond my capability v.v
00:19:30 <lambdabot>  mueval-core: Time limit exceeded
00:19:38 <jle`> hm
00:19:42 <jle`> so my wire must have some kind of fixed point?
00:19:50 <Cale> of course, lambdabot's using the threaded runtime, so that doesn't get <<loop>> caught, it's just greyholed and times out
00:19:51 <jle`> or...how do i make it work with ArrowLoop
00:20:09 <Cale> yeah, you need to make sure that you're somehow adding new information
00:20:23 <jle`> to the wire?
00:20:50 <shachaf> The threaded runtime can catch <<loop>>
00:20:51 <Cale> well, usually what you do is you make sure that some signal is being delayed
00:21:02 <Cale> shachaf: Does it in some cases?
00:21:06 <shachaf> But mueval or whatever lambdabot is using probably can't.
00:21:09 <Cale> > let x = x + 1
00:21:10 <lambdabot>  not an expression: `let x = x + 1'
00:21:14 <Cale> > let x = x + 1 in x
00:21:17 <shachaf> Cale: Yes, though probably not immediately, only on GC or something like that.
00:21:18 <lambdabot>  mueval-core: Time limit exceeded
00:21:21 <Cale> ah, okay
00:21:46 <dleedev> Are monad transformers a CT concept too?
00:21:49 <Cale> jle`: I'd have to familiarise myself better with netwire to give you a good answer
00:22:07 <Cale> jle`: But in Yampa and other arrowy FRP libraries with loop
00:22:07 <roboguy_> speaking of Wires, why isn't "Wire s e m" a profunctor instance? to avoid the dependency or is there something preventing it?
00:22:29 <Cale> jle`: The key is that signals which are going out of an arrow which is looped generally need to be delayed
00:22:44 <Cale> jle`: so that you don't have an immediate feedback loop
00:23:27 <Cale> roboguy_: There's nothing preventing it
00:23:48 <Cale> roboguy_: Probably the fact that Profunctor wasn't conveniently defined at the time netwire was written
00:24:07 <jle`> Cale: hm. a delay.
00:24:09 <jle`> gotcha.
00:24:21 <jle`> i guess I could do that by keeping some sort of tuple as the state/return?
00:24:27 <roboguy_> Cale: I think I saw a Profunctor type class in an older version of netwire actually
00:24:33 <jle`> and swapping them out at every step?
00:24:37 <jle`> and then mapping a snd over the wire
00:24:57 <roboguy_> oh it was a re-export
00:24:59 <Cale> jle`: Does netwire have a primitive which delays its output for a given amount of time, or by an infinitesimal amount?
00:25:05 <roboguy_> but it's not an instance now... hmm
00:25:46 <jle`> Cale: oh it does
00:25:49 <Cale> i.e. which produces a constant output for the first frame, and then on each tick thereafter, its output is whatever its input was on the frame before?
00:26:05 <jle`> mhm.
00:26:09 <Cale> jle`: That's the sort of delay I mean
00:26:15 <jle`> delay :: b -> Wire a b
00:26:18 <Cale> It sort of gives you the base case for your recursion here
00:26:31 <jle`> er, delay :: b -> Wire b b, for some reason
00:26:39 <Cale> delay :: a -> Wire s e m a a
00:26:40 <jle`> that's weird.
00:26:49 <jle`> yeah i wonder why the input and the output have to be the same
00:26:55 <Cale> because of what I just said
00:26:59 <jle`> oh
00:27:02 <Cale> It's going to copy the input to the output
00:27:10 <Cale> but delay it by a tiny amount
00:27:20 <jle`> ooh
00:27:22 <jle`> duh.
00:27:24 <jle`> haha
00:27:35 <jle`> okay
00:27:48 <Cale> and it needs the initial value of type a because it won't have a value to output on the first tick otherwise
00:27:53 <jle`> actually this function might let me build my verlet integrator out of primitives
00:28:01 <jle`> hm. in any case
00:28:05 <jle`> where should i throw this delay in?
00:28:08 <jle`> in my ArrowLoop?
00:28:23 <jle`> or in the definition of my wire
00:28:27 <jle`> i guess that doesn't matter
00:28:50 <Cale> inside your application of loop, or if you're using proc/do/rec syntax, it'll be somewhere along the cyclic chain of dependencies
00:29:39 <jle`> oh boy let's hope this works
00:30:10 <jle`> it works
00:30:12 <jle`> :|
00:30:18 <jle`> i am happy.
00:30:19 <jle`> :)
00:30:22 <Cale> hooray
00:30:24 <maxiepoo> so does anyone know of a term for a semiring without identity?
00:30:29 <jle`> (i had to take a moment to decide wether or not i was happy)
00:30:34 <jle`> thank you Cale :)
00:30:37 <shachaf> "rg"?
00:30:50 <jle`> this is still kind of magic to me though.
00:31:00 <jle`> maybe if i use ArrowLoop explicitly instead of proc/do/rec
00:31:08 <jle`> like using >>= explicitly instead of do notation
00:31:14 <jle`> it'll make more sense kinda maybe not really.
00:31:31 <maxiepoo> shachaf, hah maybe
00:31:33 <Cale> jle`: Yeah, loop is the worst primitive when it comes to not writing bugs while doing FRP, but it's also kind of hard to do away with entirely in many cases.
00:31:56 <jle`> wow the verlet integrator literally eliminated all noticeable error
00:32:01 <jle`> compared to the newtonian integrator
00:32:06 <maxiepoo> I think bases that generate the same topology form a "rg"
00:32:11 <jle`> i'm surprised my first compiled version worked
00:32:18 <jle`> maybe this is a case of 'if it compiles it works'
00:32:23 <jle`> but it took several hours to get to compile
00:32:29 <jle`> oh well
00:32:32 <jle`> i'm learning :)
00:32:42 <maxiepoo> but I'm not sure the multiplication is closed
00:32:55 <Cale> jle`: I've had that happen so many times working on FRP stuff :)
00:33:27 <Cale> Also technically your first compiled version looped :(
00:33:40 <Cale> But pretty close! :)
00:33:50 <shachaf> What are addition and multiplication?
00:34:00 <maxiepoo> addition is union of the bases
00:34:03 <shachaf> (Maybe better for #haskell-blah.)
00:34:13 <maxiepoo> yea
00:34:27 <Cale> anyway I should sleep
00:38:47 <Axman6> @hoogle Float -> Double
00:38:48 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:38:48 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
00:38:48 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
00:40:38 <dleedev> why is ghci able to resolve "(+) <$> pure 1 <*> pure 2" but not "((+) . (+)) <$> pure 1 <*> pure 2 <*> pure 3"?
00:40:44 <dleedev> > (+) <$> pure 1 <*> pure 2
00:40:45 <lambdabot>  No instance for (Control.Applicative.Applicative f0)
00:40:45 <lambdabot>    arising from a use of `e_112'
00:40:45 <lambdabot>  The type variable `f0' is ambiguous
00:40:45 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:40:45 <lambdabot>  Note: there are several potential instances:
00:41:01 <dleedev> hmm... I guess lambdabot isn't able to resolve the first one either
00:41:42 <dleedev> in my ghci, I can run "(+) <$> pure 1 <*> pure 2"
00:43:37 <Iceland_jack> dleedev: it defaults to IO
00:43:37 <dleedev> so why doesn't the second one work? ((+) . (+)) <$> pure 1 <*> pure 2 <*> pure 3
00:44:15 <Iceland_jack> :t ((+) . (+))
00:44:15 <lambdabot> (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
00:44:19 <Iceland_jack> dleedev: ↑ look at that type
00:46:05 <dleedev> Iceland_jack: ah, thanks
00:46:45 <Iceland_jack> If you have something like http://hackage.haskell.org/package/vector-space-0.5.9/docs/src/Data-NumInstances.html imported
00:46:50 <Iceland_jack> you can treat functions as numbers
00:46:59 <Iceland_jack> (which is that ((+) . (+)) does)
00:48:43 <Iceland_jack> @unpl ((+) . (+))
00:48:43 <lambdabot> (\ c -> (+) ((+) c))
00:48:43 <jle`> good night Cale
00:48:43 <jle`> everyone behold
00:48:43 <jle`> http://jle0.com/~justin/planets_newton.png vs http://jle0.com/~justin/planets_verlet.png
00:48:43 <jle`> yes i got my frp verlet integrator to work >.>
00:49:22 <Axman6> anyone know a fix for the iconv issues on OS X? I basically can't compile anything more than the most simple code at the moment without getting linker errors
01:02:21 <ratzes> how do i access environment variables from inside a cabal file?
01:16:02 <mello_> :t comp
01:16:03 <lambdabot> Not in scope: `comp'
01:16:12 <jle`> is there a generic Num a, Fractional b :: a -> b
01:16:14 <jle`> ?
01:16:29 <mello_> is there any package with a `comp´ function
01:16:40 <jle`> @hoogle comp
01:16:40 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
01:16:40 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
01:16:40 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
01:16:43 <shachaf> Probably.
01:17:02 <m3ga> @hoogle 'Num a, Fractional b :: a -> b'
01:17:03 <lambdabot> Parse error:
01:17:03 <lambdabot>   'Num a, Fractional b :: a -> b'
01:17:03 <lambdabot>   ^
01:17:11 <m3ga> @hoogle Num a, Fractional b :: a -> b
01:17:11 <lambdabot> Parse error:
01:17:11 <lambdabot>   Num a, Fractional b :: a -> b
01:17:11 <lambdabot>        ^
01:17:21 <m3ga> @hoogle (Num a, Fractional b) :: a -> b
01:17:21 <lambdabot> Parse error:
01:17:21 <lambdabot>   (Num a, Fractional b) :: a -> b
01:17:21 <lambdabot>                           ^
01:18:18 <jle`> m3ga: it's (Num a, Fractional b) => a -> b ... but i already looked
01:18:24 <jle`> thanks though
01:18:55 <m3ga> i was wondering how to do this. its possible on the command line : hoogle  'a -> b' | grep Num | grep Fractional
01:18:57 <mercuryrising> @hoogle catch
01:18:58 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
01:18:58 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
01:18:58 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
01:19:50 <mercuryrising> do i have to do anything more than importing System.IO.Error to use catch? I import that and it says that catch is not in scope
01:20:22 <supki> mercuryrising: old catch is catchIOError now
01:20:44 <mercuryrising> supki, that works! thanks!
01:35:42 <jle`> mm_freak: is there a simple way to fake a fixed-delta real-time framerate by calculating values at fixed delta and returning interpolated values at every frame?
01:35:47 <jle`> (in netwire)
03:52:25 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://hdiff.luite.com | XCode 5 issues? http://is.gd/H4sEub'
03:52:25 --- topic: set by monochrom!monokrom@216.138.220.146 on [Sat Nov 23 20:32:31 2013]
03:52:25 -hobana(freenode.net)- [freenode-info] if you're at a conference and other people are having trouble connecting, please mention it to staff: http://freenode.net/faq.shtml#gettinghelp
03:52:44 <hpc> no, they are on the command-line
03:53:00 <hpc> someone interested in your package would have to do cabal install --binsubdir=.dist
03:53:08 <b80905> given an arbitrary function, is there a way to determine the number of arguments the function takes?
03:53:09 <hpc> er, and libsubdir
03:53:15 <hpc> b80905: no
03:53:25 <hpc> > id 5
03:53:26 <lambdabot>  5
03:53:31 <hpc> > id (+) 5 8
03:53:32 <lambdabot>  13
03:53:32 <srhb> hpc: optionDistPref configDistPref (\d flags -> flags { configDistPref = d }) showOrParseArgs
03:53:34 <b80905> hpc: why not?
03:53:37 <srhb> Is all I get from the source.
03:54:02 <hpc> > id printf "%s %s %s %s" "this" "is" "variadic" "because type classes"
03:54:03 <lambdabot>  No instance for (Text.Printf.PrintfType a0)
03:54:03 <lambdabot>    arising from a use of `e_1'
03:54:03 <lambdabot>  The type variable `a0' is ambiguous
03:54:03 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
03:54:03 <lambdabot>  Note: there are several potential instances:
03:54:07 <hpc> > id printf "%s %s %s %s" "this" "is" "variadic" "because type classes" :: String
03:54:08 <lambdabot>  "this is variadic because type classes"
03:54:33 <hpc> b80905: in a word, polymorphism
03:55:04 <merijn> hpc: I don't care about what happens to others, I just dislike the "dist" directory when developing
03:55:23 <srhb> b80905: You mean programatically, right? You can always look up the type (which may or may not help, depending on, well, typeclasses)
03:55:24 <mm_freak_> b80905: well, in haskell every function takes exactly one argument
03:55:40 <merijn> hpc: i.e. when I run "cabal build" I don't want to have a visible "dist" directory in my working directory
03:56:01 <srhb> merijn: You need to look up the configDistPref flag
03:56:07 <jle`> mm_freak_: sorry, got caught up in something for a bit.  i appreciate your help...i hope it's okay that i ping you like this every once in a while :|  if it's a breach of ettiquette please let me know :)
03:56:29 <maxs`> merijn: why not cabal repl?
03:56:41 <mm_freak_> jle`: no worries, i'm happy to answer your questions =)
03:56:49 <osa1> let's say I'm exporting only a subset of definition in my module. can I reach all definitions in that module if I load it to GHCi using :load ?
03:57:09 <jle`> mm_freak_: okay :) and thank you for the library, it's been a lot of fun to work with.
03:57:15 <merijn> maxs`: I don't see how that relates to my question?
03:57:26 <mm_freak_> jle`: i hope you will find it useful for a real project some day =)
03:57:34 <merijn> osa1: You should be able to, yes
03:57:37 <maxs`> merijn: oh you are right, you still need to configure
03:57:41 <merijn> osa1: But import won't, I think
03:58:05 <merijn> maxs`: No I mean, how does "cabal repl" build my binary?
03:58:24 <jle`> mm_freak_: thanks :) i guess this is "real". i do research in computational physics and i wanted to maybe demonstrate that FRP is a viable candidate for serious computation and simulations.
03:58:36 <b80905> srhb: well, i am trying to write a function :: (Bool -> ... -> Bool) -> Bool that checks whether a given function always returns True
03:58:36 <jle`> so hopefully after all of this i can have some sort of demo/proof of concept to show my peers
03:58:39 <srhb> jle`: Which library?
03:58:45 <jle`> srhb: using netwire atm
03:58:47 <maxs`> merijn: right I missed that part
03:58:58 <srhb> jle`: Aha :) I'm interested in the topic, too. What are you building?
03:59:12 <jle`> srhb: just playing around right now actually...got started a couple days ago :)
03:59:18 <jle`> my first project is a simple n-body
03:59:23 <srhb> jle`: Okay :)
03:59:37 <jle`> srhb: what has been your experience in the area?
03:59:42 <osa1> is there a conventional name given to functions of type (SomeType -> Bool) ? like predicate or something like that? (to be used in functions like filter)
03:59:49 <srhb> b80905: You won't be able to do that without a lot of cheating -- and not sure even then
04:00:20 <srhb> jle`: Currently I'm just thinking about tools for computational physics, I'd like to displace some technologies. :P
04:00:34 <srhb> jle`: But we're talking heavy duty number crunching mostly, although your topic is just as interesting.
04:00:39 <srhb> (Ie. die Fortran, die...)
04:00:46 <mm_freak_> jle`: nice
04:00:53 <jle`> osa1: we call things like (a -> Bool) a predicate yeah
04:01:12 <jle`> srhb: yeah i have had some success with number cruching using mvecs and repa
04:01:27 <jle`> planning on doing some stuff with accelerate when i get the opportunity/a relevant project
04:02:20 <jle`> but FRP is interesting in that it offers a way of composing behaviors that projects that explicitly manipulate state cannot achieve
04:02:49 <jle`> and it kind of structures things interestingly
04:02:54 <jle`> i too am interested in displacing technologies
04:03:04 <jle`> there is a lot of room for improvement in this field
04:03:17 <jle`> (i actually find fortran kind of endearing though ... ;) )
04:04:08 * hackagebot crypto-random-effect 0.1.0 - A random effect using crypto-random  http://hackage.haskell.org/package/crypto-random-effect-0.1.0 (ibotty)
04:04:10 * hackagebot crypto-random-effect 0.1.1 - A random effect using crypto-random  http://hackage.haskell.org/package/crypto-random-effect-0.1.1 (ibotty)
04:04:53 <Iceland_jack> jle`: There are pills for that
04:04:56 <Iceland_jack> :)
04:05:07 <jle`> Iceland_jack: haha
04:07:37 <jle`> for those familar with proc notation
04:07:46 <jle`> is there something i can simplfy with the line
04:07:52 <jle`> x <- arr f -< y
04:07:54 <jle`> ?
04:08:03 <Roklobsta> jle: what is the holdup with functional for numeric processing do you think?
04:08:44 <Tinned_Tuna> Heya, if I run my program on another box (without libgmp installed), I get an error message about it being unable to load said shared library. Is there a way to tell GHC to include the library in the binary?
04:08:50 <jle`> Roklobsta: well there is the common misconception that functional programming has too many layers of abstractions to be useful in high performant applications
04:08:56 <Tinned_Tuna> (I'm driving my build via cabal)
04:09:06 <jle`> but i think mainly it is the lack of people who have tried it
04:09:20 <jle`> esp in physics there isn't much effort to branch out language-wise
04:09:36 <jle`> sometimes we still use fortran libraries written in the 70's
04:10:04 <quicksilver> jle`: there is more collective expertise in the community in understanding and fixing performance problems in imperative style code w/ manual memory management
04:10:06 <jle`> and the only reason there is a slight shift to C now is because C training comes with lots of undergrad programs
04:10:18 <jle`> quicksilver: yes that's def true
04:10:29 <jle`> those people are good at what tehy do
04:10:31 <tomejaguar> jle`: 'let x = f y'?
04:10:32 <jle`> and they do it well
04:10:32 <quicksilver> jle`: we need to learn (and very likely tools need to be written) to analyse and solve performance problems in more abstract settings.
04:11:03 <mm_freak_> jle`: let x = f y
04:11:04 <Tinned_Tuna> jle`: Fortran is common in lots of places where they're doing numerical-heavy simulation. I know one guy simulating the carbon dioxide uptake rate in plants using a big legacy Fortran program in environmental sciences
04:11:12 <mm_freak_> jle`: or just use 'f y' =)
04:11:21 <Roklobsta> jle: and you're all stick in the FEM/FDTD doing things piecewise in time.
04:11:23 <tomejaguar> jle`: What you wrote is analogous to 'x <- fmap f (return y)'
04:11:26 <Tinned_Tuna> the only dept. I know that actively teaches fortran around here (that I know of) is Physics
04:11:33 <jle`> mm_freak_ tomejaguar:: oh that's nice
04:11:42 <merijn> Tinned_Tuna: Totally hip in meteorology too
04:11:43 <jle`> i need to build an intuition for this
04:12:01 <mm_freak_> jle`: in general you probably don't want to use 'arr' at all:  arr f . x = fmap f x
04:12:11 <jle`> yeah using arr seemed out of place
04:12:30 <jle`> maybe the inutition is that
04:12:30 <tomejaguar> jle`: Arrow notation is really neat.  You have to balance it with arrow combinators though, which can often be neater.
04:12:32 <jle`> y is the *value*
04:12:42 <jle`> so i can just apply f y
04:13:11 <mm_freak_> jle`: in netwire every arrow variable that is not an Event is a behavior (in FRP terms)
04:13:37 <mm_freak_> jle`: that is, every variable that is bound either by 'proc' or by '<-'
04:14:34 <jle`> okay i realized why i used arr in the first place
04:14:43 <jle`> i'm using proc y -> do ....
04:14:50 <jle`> and if i don't put y in the right hand side of some -<
04:14:53 <jle`> it says it's not in scope
04:15:09 <mm_freak_> that's right
04:15:33 <tomejaguar> That's something I never understood.
04:15:34 <jle`> so i can't just do let x = f y
04:15:40 <mm_freak_> yes, you can
04:15:52 <jle`> oh
04:15:54 <jle`> it worked
04:15:56 <jle`> ...
04:15:59 <jle`> i could have sworn i just tried it
04:16:02 <jle`> and it didn't work
04:16:04 <jle`> haha
04:16:11 <mm_freak_> =)
04:16:15 <tomejaguar> There are scope rules that I don't understand.
04:16:17 <jle`> this is so weird.
04:16:45 <mm_freak_> tomejaguar: if you can put arrow variables in the action place, then you have a monad
04:16:47 <jle`> this is the kind of disorientation kind of like what i felt when i was first playing around with the list monad
04:17:03 <mm_freak_> for those kinds of arrows (ArrowApply arrows) there is even special notation
04:17:31 <mm_freak_> do x <- blah1 -< (); abc x -<< ()
04:17:41 <jle`> also i'm not sure when to use -<<
04:17:57 <mm_freak_> jle`: with netwire never =)
04:18:09 <jle`> ah okay
04:18:21 <jle`> yeah i saw it while reading through the proc notation specs
04:18:31 <jle`> was wondering.
04:18:52 <tomejaguar> mm_freak_: That part I don't understand.  The scoping of 'let' is strange though.  You can only use it on the next line, or something.
04:18:54 <jle`> is there anywhere i can find out how to manually desugar a rec into what is presumably an ArrowLoop?
04:18:55 <mm_freak_> the reason is that arrows allow composition of "arrows" using a bunch of combinators
04:19:10 <mm_freak_> there is no combinator that actually extracts values, so you can't refer to them
04:19:35 <mm_freak_> tomejaguar: you can use 'let' everywhere
04:19:41 <jle`> so when i do x <- y -< z ....
04:19:49 <jle`> z is a concrete type
04:19:53 <jle`> er
04:19:54 <mm_freak_> jle`: the type of 'loop' should be straightforward enough
04:20:00 <jle`> it's whetever type is proc z -> do
04:20:06 <jle`> umm
04:20:08 <jle`> so what is y?
04:20:10 <jle`> an arrow?
04:20:18 <mm_freak_> a wire
04:20:20 <mm_freak_> an arrow
04:20:22 <jle`> an arrow from the type of z to the type of whatever x is?
04:20:22 <mm_freak_> an action
04:20:25 <mm_freak_> whatever you want to call it =)
04:20:39 <jle`> so if z :: a, x :: b
04:20:46 <mm_freak_> like:  what is a '(Monad m) => m X'?
04:20:58 <jle`> y :: (Arrow r) => r b a
04:21:00 <jle`> ?
04:21:13 <mm_freak_> let Cat be your arrow
04:21:14 <jle`> did i do that backwards
04:21:22 <jle`> y :: (Arrow r) => r a b
04:21:36 <mm_freak_> (y :: b) <- (f :: Cat a b) -< (x :: a)
04:21:44 <jle`> okay
04:21:48 <jle`> Cat is just an instance of Arrow?
04:21:52 <mm_freak_> yeah
04:21:56 <jle`> okay.
04:22:11 <jle`> and like in monadic do blocks ... i can leave off the y <- and just not name it
04:22:19 <mm_freak_> it helps to first understand proc-notation, before you approach do-notation
04:22:43 <jle`> hm what do you mean?
04:22:45 <mm_freak_> proc x -> f -< g x
04:22:48 <jle`> oh
04:22:53 <jle`> yes i didn't even know that there was a difference
04:22:56 <mm_freak_> f :: Cat b c
04:22:59 <mm_freak_> g :: a -> b
04:23:02 <mm_freak_> x :: a
04:23:17 <mm_freak_> proc notation just gives you a nice way to use 'arr'
04:23:22 <mm_freak_> in a sense it gives you "arrow lambdas"
04:23:35 <jle`> (proc x -> (f :: Cat b c) -< (g :: a -> b) (x :: a) ) :: Cat a c
04:23:37 <jle`> ?
04:23:49 <mm_freak_> yeah
04:24:08 <jle`> so ... what does the -< desugar to?
04:24:18 <mm_freak_> it doesn't desugar by itself
04:24:21 <jle`> hm
04:24:34 <mm_freak_> (proc x -> f <- g x) = f . arr g
04:24:48 <mm_freak_> uhm
04:24:53 <mm_freak_> (proc x -> f -< g x) = f . arr g
04:25:00 <tomejaguar> Don't you need a 'do' for that to be well-formed?
04:25:04 <mm_freak_> no
04:25:13 <mm_freak_> do-notation is an extension to the basic proc-notation
04:25:37 <mm_freak_> do-notation in its simplest form gives you a way to compose multiple morphisms
04:25:56 <jle`> (.) is the category composition
04:25:58 <jle`> right?
04:26:01 <mm_freak_> i'm calling "arrows"/"actions"/"computations"/"wires"/… "morphisms"
04:26:01 <mm_freak_> yeah
04:26:01 <osa1> interesting. any ideas why Control.Monad.Reader exports MonadIO definitions and operations?
04:26:23 <jle`> arr g :: Cat a b
04:26:25 <jle`> ?
04:26:26 <osa1> (the one from mtl)
04:26:42 <mm_freak_> (proc x1 -> do x2 <- g -< x1; f -< x2) = f . g
04:26:50 <rtpg> is there an easy way to note Word32s
04:27:03 <rtpg> in a sort of "byte-per-byte" fashion?
04:27:04 <jle`> so you have ( (f :: Cat b c) . (arr g :: Cat a b) ) :: Cat a c
04:27:10 <tomejaguar> So what is proc?
04:27:14 <mm_freak_> the difference is that now the conceptual "variables" are in scope and you can deal with them as they were regular values
04:27:25 <mm_freak_> tomejaguar: it's sugar for what i wrote above
04:27:28 <tomejaguar> Is 'do' inside a proc treated completely differently from 'do' for a monad?
04:27:29 <mm_freak_> sugar for 'arr'
04:27:32 <jle`> that's so weird :|
04:27:38 <jle`> that you can treat these conceptual variables like regular values
04:27:49 <jle`> but i guess that's the same disorientation i felt when i was first learning about monads/do notation
04:28:00 <tomejaguar> mm_freak_: Yeah but what you wrote above doesn't match 'proc -> do ...'
04:28:12 <mm_freak_> jle`: say that you have a morphism of type Cat Int String
04:29:00 <mm_freak_> normally this is really just a categorical arrow…  the Category/Arrow abstraction does not understand "values" at all
04:29:28 <jle`> hm. hey so the only reason I would use returnA is to take a value that i 'bound' in a rec block?
04:29:44 <jle`> or if i wanted to returnA a tuple or something...or a function on what i already bound...
04:29:50 <jle`> kind of the same as for monads then huh.
04:30:02 <mm_freak_> proc-do-notation gives you a way to compose morphisms in terms of thought-of "arguments" and "results" the morphisms take
04:30:20 <jle`> hm yeah by 'values' i guess i mean that i can use unlifted functions on the...parameters? of the Cat a b
04:30:23 <jle`> on the a and b
04:30:42 <mm_freak_> that's already an extension to the basic idea and assumes that you have 'arr'
04:30:44 <jle`> is 'bind' the right word here?
04:30:56 <mm_freak_> well, since you "bind" variables, yes =)
04:31:01 <jle`> haha
04:31:06 <jle`> i mean...is it related to the monadic bind?
04:31:26 <mm_freak_> partly
04:31:44 <mm_freak_> when you use monadic do-notation you get actual values and functions you apply those values to
04:31:53 <mm_freak_> (>>=) :: m a -> (a -> m b) -> m b
04:32:37 <mm_freak_> btw, returnA = arr id = id
04:33:02 <jle`> arr id = id?
04:33:06 <mm_freak_> yes
04:33:07 <jle`> this
04:33:09 <jle`> makes sense
04:33:18 <mm_freak_> (y <- f -< x; returnA -< y) = (f -< x)
04:33:27 <mm_freak_> because id . f = f
04:33:34 <jle`> what is returnA's type?
04:33:37 <jle`> it's a morphism
04:33:39 <jle`> ?
04:33:45 <mm_freak_> yes, it's the identity morphism
04:33:52 <mm_freak_> returnA :: Cat a a
04:33:53 <jle`> it's a morphism that takes something of type y and returns something of type...y
04:33:55 <jle`> oh yeah
04:34:00 <jle`> the type of y
04:34:13 <jle`> so it's a morphism that just spits out the same thing...in the context of that morphism
04:34:27 <mm_freak_> yes, it's simply the identity morphism
04:34:32 <jle`> for the function arrow, it's just id
04:34:33 <mm_freak_> and the usual laws apply
04:34:36 <mm_freak_> f . id = f
04:34:39 <mm_freak_> id . f = f
04:34:42 <jle`> ah
04:35:05 <mm_freak_> when you write 'y <- returnA -< x', then y = x
04:35:17 <jle`> this newly overloaded (.) is taking time to get used to
04:35:34 <jle`> hm okay.
04:35:35 <tomejaguar> jle`: I always use <<<.
04:35:39 <mm_freak_> traditionally it used to be called (<<<)
04:35:43 <mm_freak_> but i prefer the modern (.)
04:35:56 <jle`> hm
04:36:03 <jle`> that's interesting
04:36:04 <mm_freak_> one important thing to note is that returnA is not a language construct
04:36:18 <mm_freak_> it's defined in the base library
04:36:26 <mm_freak_> returnA :: (Arrow a) => a b b
04:36:31 <mm_freak_> returnA = arr id
04:36:45 <mm_freak_> and this definition is really a historical accident
04:36:46 <jle`> hm.
04:36:49 <mm_freak_> it should be:
04:36:56 <mm_freak_> returnA :: (Category cat) => cat a a
04:36:58 <mm_freak_> returnA = id
04:37:02 <jle`> ah
04:37:09 <jle`> you know when i first read arr id
04:37:14 <jle`> i thought it must be different than id somehow
04:37:19 <jle`> hm
04:37:23 <jle`> wait is id overloaded here?
04:37:27 <mm_freak_> it's forced to be equivalent to id
04:37:29 <mm_freak_> yes
04:37:32 <jle`> okay
04:37:37 <mm_freak_> id :: (Category cat) => cat a a
04:37:39 <jle`> that clears things up
04:37:43 <mm_freak_> it's in the Category type class
04:37:47 <jle`> okay.
04:38:00 <jle`> why not Arrow?
04:38:02 <ratzes_> does anybody know how to make an ffi library work with ghci when installed from cabal?
04:38:04 <jle`> less modern?
04:38:15 <mm_freak_> Arrow is to Category what Applicative is to Functor
04:38:15 <tomejaguar> jle`: Because Category is more general than Arrow.
04:38:44 <mm_freak_> class (Category cat) => Arrow cat where …
04:38:48 <jle`> hm
04:38:54 <jle`> what does category offer that arrow doesn't?
04:39:00 <jle`> er
04:39:00 <mm_freak_> nothing
04:39:03 <jle`> the other way around?
04:39:04 <FireFly> No, it's the other way around
04:39:07 <jle`> okay
04:39:13 <jle`> what does arrow offer?
04:39:21 <mm_freak_> jle`: imagine this:  f . g . h
04:39:36 <mm_freak_> you want to make f and h communicate, but the g is in the way
04:39:52 <mm_freak_> this is what Arrow gives you:  "side-stepping channels" in a way
04:40:05 <mm_freak_> it allows you to communicate around g:  f . first g . h
04:40:06 <jle`> oh.
04:40:20 <jle`> but don't all categories have this power anyway?
04:40:25 <mm_freak_> no
04:40:26 <jle`> it's just a matter of defining the methods?
04:40:27 <tomejaguar> I prefer to see it as it allows you to put computations side-by-side.
04:40:28 <jle`> hm
04:40:35 <tomejaguar> i.e. (***)
04:40:43 <mm_freak_> this makes proc-do-notation work
04:40:48 <jle`> how does this side stepping happen in proc-do?
04:40:50 <jle`> oh
04:40:51 <tomejaguar> However it also provides 'arr' which is unrelated.
04:40:57 <jle`> it's essential for all the interleaving and stuff?
04:41:10 <mm_freak_> proc x -> do y1 <- f -< x; y2 <- g -< (x, y1); …
04:41:11 <tomejaguar> mm_freak_: Could you have proc-do without arr?
04:41:24 <mm_freak_> without arrow combinators the last line couldn't refer to 'x'
04:41:38 <mm_freak_> tomejaguar: a constrained form of it
04:41:43 <jle`> ah i see
04:41:54 <jle`> so proc do notation takes care of the side stepping for us
04:42:02 <tomejaguar> mm_freak_: A form where the right hand side has to be a variable, not an expression?
04:42:10 <mm_freak_> yes, it implicitly uses combinators like 'first' and (&&&)
04:42:21 <mm_freak_> tomejaguar: yes, and where 'let' is not allowed
04:42:24 <tomejaguar> Right.
04:42:26 <jle`> that's a relief, i thought that the side stepping stuff seemed tedious when i read tutorials
04:42:39 <jle`> okay...i think i am gaining somewhat of an intuition for this
04:42:44 <jle`> appreciate you guys helping me walk through this
04:42:49 <tomejaguar> mm_freak_: Also you wouldn't be allowed to pattern match on the right hand side.
04:43:15 <mm_freak_> tomejaguar: yeah
04:43:15 <tomejaguar> jle`: Just think, when you understand this, monadic do will seem trivial :)
04:43:32 <jle`> tomejaguar: haha
04:43:39 <jle`> well it already seems kinda trivial
04:43:41 <mm_freak_> and if you ever understood the basics and need more challenges, don't worry…  there is a lot more to come ;)
04:43:50 <jle`> but i want to see the day where proc stuff seems trivial
04:43:54 <mm_freak_> rec-notation, (| banana brackets |), combinator notation, etc.
04:44:14 <jle`> but somehow i feel like this stuff is more esoteric/useful in a narrower domain than monadic do
04:44:24 <jle`> like i'm going...pretty deep
04:44:29 <jle`> and narrow
04:44:33 <mm_freak_> jle`: this stuff is really a workaround
04:45:11 <tomejaguar> mm_freak_: Are banana brackets good for anything?  I grepped the entire hackage codebase once and found only a couple of mentions.  I think they were both comments!
04:45:13 <mm_freak_> you have something that is in many ways pretty much like a monad, but you can't implement (>>=) or you can only provide a very sucky implementation of it (like for Wire)
04:45:28 <mm_freak_> tomejaguar: yes, indeed they are useful
04:45:42 <tomejaguar> mm_freak_: How come they're unused then?
04:45:49 <jle`> if i used proc do with kliesli arrows...would it resemble monadic do?
04:45:51 <tomejaguar> Are you the only person in the world that uses them? :)
04:45:57 <mm_freak_> tomejaguar: because the most common arrow is (->), and they are useless there =)
04:46:18 <tomejaguar> mm_freak_: Hmm well I guess it is true that hardly anyone uses Arrow notation.
04:46:20 <mm_freak_> jle`: yes
04:46:25 <FireFly> What's an arrow that isn't (->) that is good to use to learn Arrow better?
04:46:35 <mm_freak_> FireFly: Mealy
04:46:40 <mm_freak_> FireFly: see the 'machines' library
04:46:52 * FireFly looks
04:46:54 <mm_freak_> and when you understand Mealy you're ready for netwire =)
04:47:10 <tomejaguar> mm_freak_: That's a monad ...
04:47:20 <mm_freak_> yes, Wire is a monad, too
04:47:26 <tomejaguar> Oh
04:47:28 <mm_freak_> but you don't want to use it as a monad
04:47:37 <jle`> Mealy did help me understand arrows
04:47:44 <jle`> it was the first non-trivial and useful arrow i saw
04:47:44 <tomejaguar> Did you give Wire a Monad instance?
04:47:47 <mm_freak_> tomejaguar: no
04:47:49 <jle`> and Auto etc
04:47:51 <tomejaguar> OK
04:48:14 <mm_freak_> tomejaguar: to understand the reason implement this type:  data Stream a = a :> Stream a
04:48:17 <jle`> anyways thanks mm_freak_, tomejaguar ....it's nearing 5am so i should probably be off to bed now
04:48:34 <mm_freak_> tomejaguar: write a zipping Applicative instance, then write a correct Monad instance
04:48:52 <mm_freak_> you will get what is known in the FRP world as a super-duper-huge time leak =)
04:49:08 <mm_freak_> jle`: good night =)
04:49:11 <tomejaguar> jle`: OK good luck with Arrows!
04:49:33 <tomejaguar> mm_freak_: Is the same true of Mealy?
04:49:39 <mm_freak_> yes
04:49:57 <mm_freak_> for every element it has to rerun the entire computation for all past elements
04:50:06 <jle`> ty
04:50:10 <jle`> all
04:50:18 <tomejaguar> The monad instance is "take the diagonal"
04:50:28 <mm_freak_> yes, exactly
04:50:58 <tomejaguar> I don't see how that gives a time leak though.
04:51:03 <tomejaguar> What happens?
04:51:23 <mm_freak_> consider str = str' >>= f
04:51:38 <mm_freak_> for each element of str, this reruns the entire computation up to that element
04:51:59 <mm_freak_> so with each further element you need to perform more computation
04:52:36 <jle`> wait how do i desugar recs again
04:52:46 <tomejaguar> OK so say you want to get the 100th element of str, and the 100th element of str' is x.  You evaluate f x and then walk 100 places.  Is it that walk that is the time leak?
04:52:53 <jle`> (i can't sleep until i figure it out)
04:53:29 <jle`> rec x <- f -< y; y <- g -< x
04:53:47 <jle`> or even rec x <- f -< x
04:53:47 <mm_freak_> that doesn't desugar alone
04:54:02 <jle`> and then returnA x afterwrads
04:54:32 <jle`> say proc y -> do (rec x <- f -< y; y <- g -< x); returnA x
04:56:08 <mm_freak_> (rec { x <- f -< x }; id -< x) = loop (proc (_, x') -> do x <- f -< x'; id -< (x, x))
04:56:28 <mm_freak_> it's really a straightforward application of 'loop'
04:56:41 <skypers_> @hoogle (<?>)
04:56:41 <lambdabot> Text.Parsec.Prim (<?>) :: (ParsecT s u m a) -> String -> (ParsecT s u m a)
04:56:41 <lambdabot> Text.ParserCombinators.Parsec.Prim (<?>) :: (ParsecT s u m a) -> String -> (ParsecT s u m a)
04:56:44 <mm_freak_> in the last 'id':
04:56:47 <mm_freak_> id -< (x, x)
04:56:51 <mm_freak_> the left x is the result
04:56:58 <mm_freak_> the right x is what gets fed back
04:57:06 <jle`> :t loop
04:57:07 <lambdabot> ArrowLoop a => a (b, d) (c, d) -> a b c
04:57:18 <jle`> now i know why it was complaining that loop was shadowing an existing binding
04:57:38 <jle`> okay
04:57:41 <jle`> this makes sense
04:57:42 <tomejaguar> mm_freak_: What do you use netwire for in practice?
04:58:09 <skypers_> :t (<|>)
04:58:09 <jle`> right is fed back, left is result
04:58:10 <lambdabot> Alternative f => f a -> f a -> f a
04:58:29 <skypers_> > Nothing <|> Just 3
04:58:30 <lambdabot>  Just 3
04:58:36 <skypers_> oh
04:58:44 <skypers_> > Nothing <|> Just 3 <|> Just 4
04:58:45 <lambdabot>  Just 3
04:58:50 <skypers_> that’s interesting
04:58:57 <mm_freak_> tomejaguar: simulations, some networking tasks, AI
04:59:23 <tomejaguar> mm_freak_: Do you consider netwire to be "general purpose"?
04:59:29 <mm_freak_> tomejaguar: no
05:00:02 <tomejaguar> mm_freak_: How would you describe its domain?
05:00:05 <skypers_> do you think parsec is the best parsing lib ever?
05:00:16 <mm_freak_> it's for continuously running applications that can be split into "frames" in a sensible way
05:00:24 <mm_freak_> real-time games, simulations, etc.
05:00:29 <mm_freak_> signal processing
05:00:36 <Mait0> Gentlemen, There is QuickCheck2. Should I look into QC2 or just QC? QC2 is superset of QC?
05:00:48 <skypers__> damned timeout
05:00:49 <jle`> as opposed to things like...GUI's and user interactive things that are built off of many single fire events?
05:01:12 <mm_freak_> jle`: yes, those are built on event handlers, and i recommend reactive-banana for those
05:01:19 <jle`> okay
05:01:22 <jle`> well i am off for real now
05:01:25 <jle`> good night all and thanks again
05:01:30 <mm_freak_> go =P
05:01:46 <tomejaguar> Why doesn't reactive-banana use arrows?
05:01:56 <mm_freak_> because it's not AFRP
05:02:52 <mm_freak_> in reactive-banana's FRP behaviors are first-class and are wrapped by the Behavior type
05:03:51 <tomejaguar> mm_freak_: Without knowing anything about it, though, I would hypothesise that it *could* be expressed in terms of Arrow.  For example 'apply :: Behavior t (a -> b) -> Event t a -> Event t b' looks like it should be 'apply :: Behavior t (a -> b) -> EventArr t a b'.
05:04:10 <tomejaguar> And 'Event t a' should be 'EventArr t () a'.
05:04:25 <tomejaguar> Anyway, that's my hypothesis from having done a similar thing in a database library.
05:04:42 <Twey> That's an odd definition of ‘should be’ :þ  What's your justification for that?
05:05:17 <tomejaguar> Twey: 'should be' in the same way that 'putStrLn' "should be" 'String -> IO ()' and not 'IO String -> IO ()'.
05:05:41 <tomejaguar> "There exists an type which is smaller yet captures all the functionality that you actually want"
05:07:28 <Twey> tomejaguar: Is it really smaller?  You're only really factoring out the arrow, and it comes at the cost of making the type of Events quite a bit bigger
05:08:15 <tomejaguar> What do you mean it makes the type of Events quite a bit bigger?
05:08:24 <Twey> 114816 <tomejaguar> And 'Event t a' should be 'EventArr t () a'.
05:08:38 <tomejaguar> I didn't mean syntactically!  I meant denotationally.
05:09:03 <tomejaguar> Anyway, just define 'type Event t a = EventArr t () a' and you have the old syntax.
05:09:08 <Twey> You don't consider ‘() → a’ to be bigger than ‘a’?
05:09:33 <mm_freak_> tomejaguar: sure it can be expressed as an arrow, but generally you want to avoid arrows
05:09:46 <mm_freak_> they are a workaround for a shortcoming of the monadic abstraction
05:10:31 <tomejaguar> Twey: I didn't mean that 'EventArr t a b' is 'Event t a -> Event t b'.  I meant that 'EventArr t a b' should be a type which embeds in 'Event t a -> Event t b'.
05:10:48 <mm_freak_> i'm pretty much using an arrow, because it's my only choice =)
05:11:11 <Twey> tomejaguar: Yes, I got that, but it seems analogous
05:11:14 <tomejaguar> mm_freak_: Right that's what I don't get about reactive-banana.  Why is arrow not the only choice there.
05:11:30 <mm_freak_> tomejaguar: because it has a completely different internal plumbing
05:11:46 <merijn> @tell dcoutts There appears to be a configDistPref option in cabal, but I'm unsure how to specify that so that it uses a different directory then "dist"
05:11:46 <lambdabot> Consider it noted.
05:11:50 <mm_freak_> reactive-banana is based on pushing events, while netwire is based on frames
05:12:06 <tomejaguar> mm_freak_: Ah well if you genuinely can express everything you need without it, fair enough.  I don't know anything about how either of them work :)
05:13:04 <tomejaguar> I fear you'd lose a certain degree of safety though, as if every IO library function 'a -> IO b' were instead implemented as 'IO a -> IO b'.
05:13:20 <mm_freak_> in reactive-banana you always start by creating events:  it assumes to be used with a callback-based framework (say wxHaskell, gtk2hs or even vty-ui)
05:13:40 <mm_freak_> you use the event handler registration functionality of your toolkit to create an event
05:13:46 <mm_freak_> then you construct behaviors out of those events
05:14:21 <mm_freak_> it doesn't have 'frames' and doesn't look at all like automata
05:14:46 <mm_freak_> this allows you to pass events and behaviors around your entire application, which is nice
05:15:05 <mm_freak_> on the other hand it's weak in certain domains like simulations and games, where you really want to have those 'frames'
05:15:17 <tomejaguar> mm_freak_: So is it true that it never needs to compose to things in a category-like way?
05:15:28 <mm_freak_> also reactive-banana is safer in closely following FRP
05:15:47 <mm_freak_> well, Wire corresponds to Moment
05:15:54 <mm_freak_> Moment can be a monad
05:16:04 <mm_freak_> so there is no need for categorical composition
05:16:53 <mm_freak_> reactive-banana is safe and "non-jailed"
05:17:19 <tomejaguar> What's "non-jailed"?
05:17:20 <mm_freak_> netwire is lightweight, and powerful combinators are easy to write, but it's unsafe and "jailed"
05:17:33 <mm_freak_> well, in netwire a behavior/event can never leave Wire
05:17:47 <mm_freak_> you don't get first class behaviors/events
05:18:01 <tomejaguar> Ah right.
05:18:17 <tomejaguar> Everything in netwire is sealed off from the rest of Haskell.
05:18:37 <mm_freak_> it's like IO
05:18:57 <mm_freak_> results of IO actions can never leave IO
05:19:30 <tomejaguar> What did you first make netwire for?
05:19:58 <mm_freak_> it started as an experiment to make a yampa-like abstraction that is more flexible and easier to understand
05:24:02 <quicksilver> mm_freak_: what's a frame
05:24:14 <quicksilver> mm_freak_: (that conversation sounded interesting btu I missed one key piece of vocab)
05:24:25 <mm_freak_> quicksilver: like a frame in a game or a simulation
05:24:26 <mm_freak_> one "step"
05:25:29 <Fuuzetsu> anyone else got an e-mail asking them to review a Haskell book or am I a special snowflake?
05:26:28 <quicksilver> mm_freak_: aha right.
05:26:47 <Fuuzetsu> where's roconnor when you need him…
05:26:58 <mr-> mm_freak_: but can't you model a "clock" in reactive-banana?
05:27:06 <quicksilver> mm_freak_: when using reactive to make games you invariably(?) have to create frames, which requires some work.
05:27:15 <quicksilver> mm_freak_: but it nice that not everything has to be tied to the frame
05:27:36 <quicksilver> I have a toy example where the graphics framerate is entirely indepdent of the simultation frame rate, e.g.
05:27:45 <mm_freak_> mr-: you can, but it's a little awkward
05:27:56 <mm_freak_> quicksilver: not quite
05:28:06 <mm_freak_> a chess game can be centered around events
05:28:08 <Fuuzetsu> @tell roconnor ping me when you're on
05:28:08 <lambdabot> Consider it noted.
05:28:23 <mm_freak_> and reactive-banana would be a better abstraction for the logic of a chess game
05:28:33 <mm_freak_> while netwire would be a good abstraction for its animations, if there are any
05:28:50 <mm_freak_> so for an OpenGL 3D chess game i'd probably use them together
05:31:20 <quicksilver> mm_freak_: the logic of a chess is not suited to FRP at all.
05:31:32 <quicksilver> the logic of a chess game is suited to conventional functional programming.
05:34:13 <mm_freak_> quicksilver: FRP is an extension to conventional functional programming, and it's useful for chess in a number of ways
05:34:23 <mm_freak_> for example the current check state is a behavior
05:34:48 <mm_freak_> and you can respond to a change of the check state
05:35:01 <quicksilver> the logic of chess doesn't respond to anything
05:35:12 <quicksilver> what is respoding? what is reacting?
05:35:17 <quicksilver> a chess analysis program, sure
05:35:19 <quicksilver> or a chess AI
05:38:31 <mm_freak_> quicksilver: the pure logic is conventional functional programming, but as soon as you (well, i) want to apply it, i'd wrap it in FRP
05:38:53 <tomejaguar> How does it help to wrap it in FRP?
05:39:18 <tomejaguar> I know it makes data dependencies more clear.
05:39:36 <tomejaguar> But I wondered what your thoughts were about the benefits of "wrapping in FRP".
05:40:38 <quicksilver> mm_freak_: probably just a slightly different sense of the word 'logic'
05:40:47 <insitu> hello, hope this is the right place for my question: anyone knows how to output text on a Chart graphics
05:40:52 <quicksilver> mm_freak_: if you'd said "the progress of a chess game" or "the evolution of a chess game"
05:40:57 <quicksilver> mm_freak_: then I would have agreed.
05:41:13 <mm_freak_> quicksilver: true
05:41:36 <quicksilver> mm_freak_: I wish I could find some free time to try out netwire :(
05:42:07 <mm_freak_> tomejaguar: well, the benefit of FRP is declarative modelling of time-varying values that respond to events
05:42:37 <mm_freak_> quicksilver: well, the latest tutorial should be easy enough to scan through for an experienced haskell programmer
05:50:16 <eikke> is it possible to update single values (at some given coordinate) in a repa array/matrix somehow?
06:01:59 <killy9999> I need an idea how to elegantly compose (a -> m b) with (b -> c) to get (m c)
06:02:20 <merijn> killy9999: fmap?
06:02:28 * killy9999 thinks
06:02:31 <merijn> :t fmap
06:02:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
06:02:51 <insitu> eikke: according to what I understood from PCPH Repa arrays are "immutable" hence you update a cell with map
06:03:10 <merijn> :t fmap (f :: b -> c) . (g :: a -> m b)
06:03:11 <lambdabot>     Could not deduce (FromExpr c) arising from a use of `f'
06:03:11 <lambdabot>     from the context (Functor f)
06:03:11 <lambdabot>       bound by the inferred type of it :: Functor f => a -> f b
06:03:15 <eikke> insitu: that seems pretty heavy :)
06:03:17 <merijn> :t fmap (f :: b -> c) . (g :: Functor m => a -> m b)
06:03:18 <lambdabot>     Could not deduce (FromExpr c) arising from a use of `f'
06:03:18 <lambdabot>     from the context (Functor f)
06:03:18 <lambdabot>       bound by the inferred type of it :: Functor f => a -> f b
06:03:21 <merijn> hmmm
06:03:59 <merijn> killy9999: Anyhoo "fmap f . g" should work (were f :: b -> c and g :: a -> m b)
06:04:06 <killy9999> I'll try
06:04:07 <killy9999> thanks
06:04:25 <killy9999> my monadic skills got rusty :(
06:05:06 <insitu> eikke: sure. but looking at the doc and the said chapter, I cannot see another way of doing
06:05:15 <mr-> killy9999: Oh, monads? Then you should use liftM ;-)
06:05:19 <insitu> eikke: would love to be enlightened though
06:06:01 <eikke> insitu: I couldnt find any other way myself, hence the question :)
06:11:52 <killy9999> fmap should do (I think)
06:11:53 <insitu> eikke: let's swap our questions then :-)
06:13:34 <eikke> insitu: what's yours?
06:14:00 <insitu> eikke: what's the way to draw a text on a Chart diagram
06:14:02 <eikke> (by the way, 'traverse2' seems to be pretty much what I'm looking for, i.e. overlay a smaller matrix over a bigger one at some specific coord)
06:14:17 <benzrf> :t traverse2
06:14:18 <lambdabot>     Not in scope: `traverse2'
06:14:18 <lambdabot>     Perhaps you meant one of these:
06:14:18 <lambdabot>       `traversed' (imported from Control.Lens),
06:14:23 <benzrf> -.0
06:15:09 <eikke> benzrf: http://hackage.haskell.org/package/repa-3.2.3.3/docs/Data-Array-Repa.html#v:traverse2
06:15:10 <insitu> :t Data.Array.Repa.Operators.traverse2
06:15:11 <lambdabot> Couldn't find qualified module.
06:15:46 <eikke> insitu: no clue, never used Charts
06:25:01 <nstdloop> Is it possible to attach nothing to the head of a list when using (:)? What I mean by this is, is there some value that I can pass as the first argument to (:) such that the returned list remains unchanged.
06:25:37 <nstdloop> (if m is our mystery value, then m : l == l)
06:25:42 <Rembane> nstdloop: id
06:25:55 <Rembane> nstdloop: But then you have to use id instead of :
06:26:04 <nexx> I don't think so
06:26:21 <nstdloop> Rembane: What I really want is to be able to either attach a value or attach nothing
06:26:52 <nexx> That would mean that a natural number would have a successor which is the same number
06:27:05 <nexx> *there is
06:27:18 <nstdloop> nexx: is there no way to "add zero"?
06:27:43 <Kaini> nstdloop, using [] ++ vs [x] ++ will work but thats not (:)
06:27:44 <nexx> err -*there is
06:28:02 <nstdloop> Kalni: That is also O(n)
06:28:09 <Rembane> nstdloop: What about: if bla then x:xs else xs
06:28:58 <nstdloop> Rembane: Interesting.
06:32:24 <merijn> Anyone here using Hakyll with post teasers?
06:32:45 <quchen> nstdloop: No, that's O(1).
06:33:17 <quchen> ([x] ++) is (x:).
06:33:40 <nstdloop> quchen: you're right
06:34:37 <quchen> Anyway, (:) is a data constructor, so when you use it you will construct the data. There are no "identities" for data constructors.
06:35:54 <quchen> :t \p x -> if p then (x:) else id -- Prepend if predicate is true, I guess that'll do.
06:35:55 <lambdabot> Bool -> a -> [a] -> [a]
06:55:37 <Sky7> Hello
06:55:50 <Sky7> Is there anybody who could help me with a little Haskell problem?
06:55:51 <noteventime> 'lo
06:56:03 <Philonous> Sky7, Don't ask to ask, just ask.
06:56:17 <Sky7> I wrote this code:
06:57:07 <noteventime> Sky7: And use a pastebin anything that's more than one or so line (e.g. http://lpaste.net/)  :)
06:57:11 <mr-> Sky7: if it is long, consider lpaste.net
06:57:54 <Philonous> Sky7, Please don't pm, put it into a gist/pastebin and put it in here, so everyone can help
06:58:06 <Philonous> @where hpaste
06:58:07 <lambdabot> http://lpaste.net/new/haskell
07:03:11 <Skypia> Hello
07:03:28 <Philonous> Hi
07:03:29 <noteventime> 'ello
07:03:29 <Skypia> Is there anybody who can help me with a problem?
07:03:43 <noteventime> Skypia: Don't ask to ask, simply ask and see if someone answers
07:03:44 <FreeFull> Sure
07:04:08 <S11001001> Skypia ≡ Sky7
07:04:31 <Skypia> Yes, I had a connection problem
07:04:33 <Skypia> import Data.Char  toDigit (x:xs) = (ord x - ord 'a'):(toDigit xs) toDigit [] = []  code (x:xs) key = code' (x:xs) (toDigit key) 0 code' [] (toDigit key) akku = [] code' (x:xs) [] akku = (x:xs) code' (x:xs) (toDigit key) akku 	|length (x:xs) == 0 = [] 	|otherwise = chr(ord x + (toDigit key)!!akku):(code' xs (toDigit key) ((akku+1)%length(toDigit key)))
07:04:45 <S11001001> @where hpaste
07:04:46 <lambdabot> http://lpaste.net/new/haskell
07:04:48 <Philonous> Skypia, If you have code/error messages, please put it into a gist/pastebin and post the URL in here.
07:04:49 <S11001001> ^^ Skypia
07:05:29 <Skypia> Okay ^^
07:05:34 <Skypia> Here it is: http://lpaste.net/98530
07:05:53 <Skypia> "Parse error in pattern: toDigit"
07:06:26 <noteventime> Skypia: On line 7, you can't match against a function call
07:07:10 <noteventime> Skypia: `code' [] (toDigit key) akku = []` <- toDigit is not a constructor, I think you want something like
07:07:41 <noteventime> code' [] x akku = let key = toDigit x in ...
07:07:59 <noteventime> Skypia: Though I'm not quite sure what it is you're trying to achieve
07:08:29 <S11001001> unless you're trying to invert toDigit by using it in a pattern, which can't happen
07:08:42 <Skypia> It should be an algorithm for decoding a text
07:09:01 <noteventime> Skypia: `code' [] (toDigit key) akku = []` <- What is it you're expecting this to do?
07:09:29 <noteventime> Especially the `toDigit key` part
07:10:45 <noteventime> Skypia: If you simply want to carry over the result of the `toDigit key` call from within `code` there is no need (it is, indeed, invalid) to match on `toDigit key` in `code'`, simply give it a new name (it is a function parameter like any other)
07:11:04 <Skypia> I defined the method in the beginning. I have a word which is used to code a text (secret language) e. g. "hello" and toDigit outputs the distance between the actual letter and the coded letter
07:12:45 <noteventime> Skypia: http://lpaste.net/98530
07:14:15 <noteventime> Skypia: `code'` "knows" nothing of how things look inside `code`, you're simply passing it parameters like any other function. When you did `(toDigit key)` in the definition of `code'` the compiler was expecting to find something called `toDigit` that it could "look inside".
07:14:23 <Skypia> Hm, thanks, but why can't I use a function in another one?
07:14:51 <noteventime> Skypia: You can call a function in another function, what you did was trying to match on a function call
07:15:25 <noteventime> Skypia: When you're defining a function as `foo a b c = ...` whatever is on the left of = are the function arguments
07:16:45 <noteventime> Skypia: To take a simpler example, `sayHello whom = "Hello there " ++ whom` is valid, you're simply binding the first argument to `sayHello` to the name `whom`. You can't do `sayHello (reverse whom) = "Hello there " ++ whom`
07:17:27 <noteventime> Skypia: You can do `sayHello whom = "Hello there " ++ (reverse whom)`
07:17:30 <Skypia> Okay, I'll try to fix that
07:17:41 <Iceland_jack> You can also omit the parentheses
07:18:02 <Iceland_jack> @let sayHello whom = "Hello there " ++ reverse whom
07:18:02 <lambdabot>  Defined.
07:18:09 <Iceland_jack> > sayHello "Sally"
07:18:11 <lambdabot>  "Hello there yllaS"
07:18:34 <noteventime> Skypia: So neither `(toDigit key)` nor `(reverse whom)` are names to which you can bind a value, they are function applications though, so you can use them as values :)
07:18:45 <Iceland_jack> @undef
07:18:45 <lambdabot> Undefined.
07:21:56 <FreeFull> You could do   sayHello (reverse -> whom) = "Hello there " ++ whom    if you use the ViewPatterns extension
07:22:03 <Skypia> Another problem occured ^^
07:22:09 <FreeFull> > let sayHello (reverse -> whom) = "Hello there " ++ whom in sayHello "Ohai"
07:22:10 <lambdabot>  "Hello there iahO"
07:22:25 <Skypia> http://lpaste.net/98530
07:24:22 <noteventime> Skypia: What's the error?
07:25:41 <Skypia> "Couldn't match type 'int' with 'Char'', expected type: [Char], actual type: [Int]..."
07:26:08 <mauke> what's the actual error?
07:26:56 <mm_bureau> Skypia: note that 'int' and 'Int' are different things
07:26:59 <noteventime> Skypia: What line?
07:27:11 <Skypia> 11
07:27:50 <frx> mm_bureau what is int?
07:28:01 <mm_bureau> frx: a type variable
07:28:35 <mm_bureau> > let id :: int -> int; id x = x in id "blah"
07:28:36 <lambdabot>  "blah"
07:28:43 <Skypia> What's the difference between int and Int?
07:29:02 <mm_bureau> Skypia: int is to Int what bool is to Bool
07:29:07 <mm_bureau> it's a variable
07:29:09 <noteventime> Skypia: Int is the type of (machine) integers, int is just a type variable (i.e. it's no specific type)
07:29:22 <noteventime> Skypia: code' xs (toDigit key)
07:29:27 <mm_bureau> > let f bool = bool + 1 in f 15
07:29:28 <lambdabot>  16
07:29:34 <mm_bureau> uhm
07:29:42 <mm_bureau> Skypia: int is to Int what true is to True
07:29:49 <mm_bureau> > let f true = true + 1 in f 15
07:29:51 <lambdabot>  16
07:29:59 <noteventime> Skypia: Wait, never mind
07:30:24 <Skypia> No, you were right
07:30:25 <Skypia> !
07:30:44 <Skypia> It's interpreted :)
07:30:52 <Skypia> Thank you very much :)
07:30:58 <noteventime> Skypia: yes, :P, the second argument is supposed to be [Char]
07:31:07 <noteventime> But you've converted it to [Int]
07:31:15 <noteventime> Skypia: Do you want some additional comments on the code?
07:32:18 <Skypia> No, but you helped me pretty much, thank you :)
07:32:28 <noteventime> np
07:32:45 <simpson> Skypia: Note that there are other ways to improve this code.
07:32:48 <noteventime> Skypia: Just since I can't help myself, line 10 is redunant, length (x:xs) will never be 0 ;)
07:33:10 <simpson> Skypia: lpaste warns "use map" for toDigit, and that wouldn't be hard to do.
07:33:19 <noteventime> Skypia: (x:xs) is by definition a list with at least one element
07:33:43 <simpson> > map (\x -> ord x - ord 'a') "shazam"
07:33:44 <lambdabot>  [18,7,0,25,0,12]
07:34:44 <Skypia> It's working fine, and I'm just a student, so it's okay, I guess ;)
07:34:55 <simpson> There are always ways to improve! :3
07:35:08 <noteventime> > map (subtract (ord 'a')) . map ord $ "shazam"
07:35:09 <lambdabot>  [18,7,0,25,0,12]
07:35:21 <noteventime> Probably less readable :P
07:35:25 <Iceland_jack> ‘Probably’
07:35:37 <Lethalman> that's very readable
07:35:57 <noteventime> Iceland_jack: Surely reducing the number of variables is the most important aspect of readability! :O
07:36:32 <Iceland_jack> Indeed! I consider my Haskell source a failure if it contains more alphanumeric characters than special characters
07:36:52 <Skypia> I'm a happy man :D Think I'm done today, bye everybody :)
07:36:58 <noteventime> Why lambda-calculus when there's combinatory logic
07:37:06 <noteventime> Skypia: bye
07:37:14 <simpson> Skypia: Wait! There's more we could do to your example code! :3
07:37:45 <Skypia> Thanks, but actually I don't need more :)
07:38:03 <simpson> What about the thirst for knowledge?
07:38:08 <simpson> The desire to learn?
07:38:09 <noteventime> Haha
07:38:22 <noteventime> Desire to learn < Desire to chill :D
07:38:25 <simpson> :t mapAccumL -- Skypia, what about how mapAccumL could CHANGE YOUR LIFE!?
07:38:26 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:38:30 <tromp__> lambda calculus is more expressive than combinatory logic
07:38:37 <simpson> Well, maybe not your life, but definitely your code. :3
07:38:42 <Dasuraga> trying to deal with some cabal nonsense, Construct not supported at this position? Is this a common error?
07:38:55 <tromp__> or i should say, more concise
07:39:24 <Skypia> What is mapAccumL?
07:39:38 <Skypia> How do I poke someone? :D
07:39:40 <simpson> Skypia: It maps and accumulates at the same time. See the type above.
07:39:43 <noteventime> Skypia: Do you know map and fold?
07:39:46 <merijn> Dasuraga: Might help to lpaste your cabal file + error
07:40:01 <merijn> Dasuraga: Because half a line out of context is unhelpful for troubleshooting
07:40:11 <simpson> It takes a function which takes an accumulator and some value, and returns a new accumulator and value...
07:40:24 <simpson> ...and uses that to map over a list, left to right, accumulating the changes along the way.
07:40:40 <Skypia> I've never used fold before and map only once
07:40:55 <benzrf> Skypia: ._.
07:40:56 <simpson> Frabjous joy! Today's a wonderful day!
07:41:37 <Dasuraga> merijn: there were some strange characters lying around in the cabal file for some reason.... getting rid of them fixed it
07:41:39 <noteventime> Skypia: a fold consumes a list of values (so folding (+) corresponds to taking the sum of a list)
07:41:55 <noteventime> Skypia: folding (*) gives you a product
07:42:23 <benzrf> Skypia: think of a left fold as
07:42:29 <noteventime> Skypia: mapAccumL is a way to do map and fold simultaneously
07:42:32 <benzrf> Skypia: you have a little machine that crawls over the list
07:42:47 <benzrf> Skypia: and it takes each value and adds it to its accumulator
07:43:22 <simpson> Hmmmm.
07:43:33 <simpson> I think Skypia's cipher doesn't actually need accumulation.
07:43:44 <simpson> It appears to just repeat the key's values one at a time.
07:43:54 <simpson> :t zipWith -- this should suffice?
07:43:55 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
07:44:55 <Skypia> It's very nice that you try to explain it to me, but my brain can't keep pace anymore...
07:45:08 <simpson> > zipWith (+) (map ord "shazam") (cycle (map ord "key"))
07:45:09 <lambdabot>  [222,205,218,229,198,230]
07:45:44 <Skypia> I'll leave it like it is, everything's good, thank you @simpson and @noteventime
07:46:00 <noteventime> Skypia: np, it takes a while getting used to fiddling with higher order functions :)
07:46:21 <noteventime> So it might be best to stick with a more "direct" solution to begin with
07:46:38 <Skypia> Okay, see you :)
07:49:25 <derdon> hello
07:49:51 <noteventime> 'lo
07:49:55 <derdon> how can I declare a new type with data so that it receives a function?
07:50:13 <noteventime> derdon: "receives a function"?
07:50:17 <derdon> ``data Foo = String (a -> b)`` does not work, because a and b are not known
07:50:37 <quicksilver> data Foo a b = MkFoo String (a -> b)
07:50:38 <derdon> I want Foo to be of a type that gets a String and a function from a to b
07:50:50 <derdon> quicksilver: ah, awesome! thanks!
07:50:52 <quicksilver> derdon: you missed the constructor name as well as the type parameters.
07:51:56 <noteventime> derdon: Note that this does not give you *a* type "Foo", but a family of types indexed by any particular values of "a" and "b" (Foo Int Int, Foo Char Int, ...)
07:52:10 <derdon> yes
07:54:17 <goffrie> @djinn ((a -> b) -> b) -> (a -> (c -> b) -> b) -> (c -> b) -> b
07:54:18 <lambdabot> f a b c = a (\ d -> b d c)
07:54:46 <goffrie> @pl \a b c -> a (\ d -> b d c)
07:54:46 <lambdabot> (. flip) . (.)
07:54:49 <GaveUp> there a cheatsheet of sorts for operators?  One of the things I keep getting hung up on reading through code is on things like (<$>, *>, etc.) where searching google doesn't give entirely useful results
07:55:00 <merijn> GaveUp: Have you tried Hoogle?
07:55:03 <goffrie> GaveUp: hoogle may be more useful
07:55:05 <nicoo> earch Hoogle instead
07:55:07 <merijn> @hoogle (<$>)
07:55:08 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
07:55:08 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
07:57:43 <GaveUp> heh ... and first search (*>) -> error ... not a good sign
07:58:46 <simpson> @hoogle (*>)
07:58:46 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
07:58:47 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
07:58:47 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:59:01 <GaveUp> ah ... need the parens?
07:59:39 <noteventime> GaveUp: For operators
07:59:51 <noteventime> (i.e. infix operators)
07:59:52 <tomejaguar> GaveUp: No, but *> was an unlucy first choice!
08:00:07 <GaveUp> noteventime: good tidbit to know :)
08:00:10 <noteventime> I thought you did :o
08:00:14 <quicksilver> noteventime: if you're going to be pedantic like that, it's not just an indexed family of types, but a *natural* family of types
08:00:16 <merijn> GaveUp: Yeah, operators need parentheses on Hoogle
08:00:21 <GaveUp> tomejaguar: if I didn't have bad luck I'd have no luck at all :P
08:00:23 <quicksilver> or parametric
08:00:35 <tomejaguar> merijn: They don't.  It's just that * is a wildcard.
08:00:53 <noteventime> quicksilver: Sure, I was trying to indicate that you couldn't do a list of "Foo", I don't think that's pedantic :)
08:01:26 <noteventime> Not knowing how familiar derdon was with typing
08:01:43 <derdon> noteventime: thanks, it works as expected!
08:02:41 <dcoutts> m3ga: you're right that it needs refactoring. It's not the way I would have written it either. On the other hand, if I'd written it, it probably would not have been released 'til a couple years later.
08:05:06 <quicksilver> noteventime: sure. However there is a commonly accepted sence in which 'Foo' is a type (we say it's a type of kind * -> * -> *); you correctly point out the alternate view that it's not a type (because types are only things which can have values). Both of those are correct, it's just terminology.
08:05:45 <defanor> help
08:05:50 <defanor> wrong channel
08:06:01 <quicksilver> noteventime: haskell quite often uses the first sense of word. "Indexed family of types" carries with it some sense of types which can behave non parametrically, as in the 'TypeFamilies' sense.
08:10:32 <benzrf> hey, does http://lpaste.net/98535 look correct ?
08:17:25 <benzrf> @where hutton
08:17:25 <lambdabot> I know nothing about hutton.
08:17:28 <benzrf> @where hutton variations
08:17:28 <lambdabot> I know nothing about hutton.
08:17:29 <benzrf> bah
08:18:31 <merijn> benzrf: Looks ok, although I personally find the long type variables distracting and hard to read
08:19:55 <benzrf> they helped remind me which was which
08:19:56 <benzrf> :u
08:20:18 <benzrf> once i get >2 vars i start becoming confused
08:21:10 <merijn> benzrf: There's some common mnemonics, though. Like r/e for the first argument to reader (for Reader and Environment) and using f/m for functor/monad type things
08:21:18 <merijn> I guess it's mostly just practice, though
08:22:07 <monochrom> you can use a longer name, you know
08:22:21 <monochrom> oh, you're against it, haha
08:22:30 <merijn> monochrom: I was just pointing out that I actually found his longer names distracting/confusing
08:24:04 <monochrom> I am against any naming scheme that forbids prudent, reasonable discretion
08:28:29 <monochrom> I wrote a Turing machine the other day. I decided to not use the boring names "q0, q1, q2...". besides boring, they also become intractible by the time you have 20 states or something. I used "Start, SeenZero, SeenZeroComma, AnswerOne, GoBack", etc
08:28:33 <merijn> Is there (other than lens) a better way to do the following type of update: "foo { myField = bar (myField foo) }"?
08:29:12 <quicksilver> yes, all the other lens packages
08:29:18 <merijn> monochrom: I'm not saying "never use descriptive names", I just find it harder to see the "shape" of a type when the type variables are long
08:29:34 <c_wraith> also, ghc 7.8 will have lenslike stuff built in
08:29:35 <monochrom> yeah I wouldn't make them too long
08:30:16 <merijn> quicksilver: That'd mean first implementing a lens for the data structure, which sounds like too much work for two "one-off" updates
08:30:36 <monochrom> "id :: t_PAAMAYIM_NEKUDOTAYIM -> t_PAAMAYIM_NEKUDOTAYIM"  not going to happen :)
08:30:57 <quicksilver> merijn: it's one very short TH command.
08:31:16 <quicksilver> merijn: you can use one of the other packages which you perceive as have less overhead
08:31:20 <bennofs> merijn: if your data type has no strict fields, you can use upon
08:31:28 <quicksilver> but really, learn to stop worrying and love the lens :)
08:31:33 <bennofs> > [1,2,3,4] & upon head .~ 3
08:31:35 <lambdabot>  [3,2,3,4]
08:31:44 <merijn> quicksilver: It's not my datatype, else they'd already have a lens
08:32:06 <bennofs> i.e. foo & upon myField %~ bar
08:32:16 <merijn> Trying to add an extension to the pandoc config
08:32:26 <merijn> bennofs: I'm not using lens in this code yet
08:32:41 <quicksilver> bennofs: how does that work? how can it infer the mutator from the accessor?
08:33:08 <merijn> My main objection against the current code isn't even the update like that, but the fact that all the names involved are so long that it doesn't fit nicely on a line or linewrap
08:33:36 <merijn> i.e. "defaultHakyllReaderOptions { readerExtensions = S.insert Ext_literate_haskell (readerExtensions defaultHakyllReaderOptions) }"
08:34:01 <bennofs> quicksilver: it uses exceptions. It puts an exception in all fields that have that type, and then accesses the field using the accessor, checking which exception is thrown
08:34:10 <quicksilver> bennofs: "it uses the Data instance"
08:34:16 <quicksilver> was the part I was missing I think?
08:34:25 <bennofs> @ty upon
08:34:27 <lambdabot> (Data s, Data a, Applicative f, Indexable [Int] p) => (s -> a) -> p a (f a) -> s -> f s
08:34:29 * quicksilver nods
08:34:52 <quicksilver> so it requires that merijn's code did derive Data
08:35:01 <bennofs> yeah, right :)
08:35:09 <quicksilver> it's still clever though
08:35:11 <merijn> I'm assuming the pandoc guys didn't
08:35:18 <quicksilver> Data is something like a universal metaprogramming class
08:35:22 <quicksilver> except it's not universal
08:35:29 <quicksilver> only a bit like it :)
08:39:42 * hackagebot distributive 0.4 - Haskell 98 Distributive functors -- Dual to Traversable  http://hackage.haskell.org/package/distributive-0.4 (EdwardKmett)
08:41:29 <hakujin> I'm using a Free Monad to optimize http traffic to a database server. I want to roll up statements into one request until their result is needed further down the command list, or the function returns. Is there any way to tell if a return value is used as an input to a later function?
08:42:22 <hakujin> e.g do { res1 <- query "example"; res2 <- query "example2"; res3 <- query $ fromExample res1; }
08:43:03 <hakujin> ideally I'd send 2 http requests; one to bundle res1 and res2, and another to find res3
08:43:20 <hakujin> how can I find these dependencies?
08:44:43 * hackagebot wl-pprint-terminfo 3.7.1 - A color pretty printer with terminfo support  http://hackage.haskell.org/package/wl-pprint-terminfo-3.7.1 (EdwardKmett)
08:46:14 <Twey> hakujin: The Monad typeclass lets you define (>>) separately to (>>=); if the user uses (>>) then you can be sure the return value won't be used
08:47:07 <Twey> I'm not sure how evil it is to make a >> b behave differently to a >>= \_ → b, but so long as it's just an optimization and isn't visible I think you're okay
08:47:33 <hakujin> Twey but consider where the results are used only at the end of a do block; e.g do {r1 <- query "example"; .. r10 <- query "example10"; return (r1 .. r10)}
08:47:57 <hakujin> the individual statements have no dependencies so optimally I would roll them all up in to one request
08:48:05 <hakujin> although all the values are used
08:48:29 <hakujin> it's the issue where the output of one query function is used as the input of another query function
08:48:46 <c_wraith> The lack of dependencies mean it can be expressed as an applicative
08:48:59 <c_wraith> and the applicative interface would let you batch them
08:49:12 <c_wraith> This is the same issue facebook has run into
08:49:22 <hakujin> c_wraith would it also work for the case where the statements do have dependencies?
08:49:35 <enthropy> make an interpreter for the data produced by the do block
08:49:53 <c_wraith> You can't express the case with dependencies in the applicative form.
08:49:53 <Twey> Aye, you could look at Simon Marlow's thing
08:50:55 <hakujin> enthropy: I have one right now, that has 2 commands "statement" that returns () and "query" that returns something and I can do a little optimization assuming the user knows how to order them properly
08:51:44 <hakujin> Twey: c_wraith: do either of you guys have a link to Simon's thing?
08:51:53 <quchen> Twey: You can really violate any laws as long as you make sure it's wrapped up appropriately. If >> /= >>= leaks out though you're probably in a world of pain :-þ
08:52:11 <Nik05> how do you know if some function is pure or impure?
08:52:44 <Twey> Nik05: All functions are pure
08:53:12 <Twey> (except maybe ones using unsafePerformIO, but they at least *look* pure so long as the author didn't do something broken)
08:53:27 <Nik05> so getLine is pure?
08:53:32 <Twey> Nik05: getLine isn't a function
08:53:36 <Twey> :t getLine
08:53:37 <lambdabot> IO String
08:53:51 <Nik05> hm
08:53:51 <c_wraith> hakujin: http://www.reddit.com/r/haskell/comments/1le4y5/the_haxl_project_at_facebook_slides_from_my_talk/ is a decent starting point
08:53:52 <quchen> Maybe we should start with defining what a function is and what pure means.
08:53:52 <Twey> (but it's also a pure value)
08:54:01 <hakujin> c_wraith: thanks
08:54:08 <Twey> > getLine
08:54:09 <lambdabot>  <IO [Char]>
08:54:11 <geekosaur> it's a bit more complex than that. getLine is "pure" in the sense that it produces the same thing every time; it just happens that that thing is an instruction to an overarching "I/O interpreter"
08:54:22 <geekosaur> whose actions themselves are impure
08:54:40 <mauke> /bin/ls is an immutable file
08:54:55 <c_wraith> mauke: until I reinstall the Os
08:54:58 <quchen> @quote /bin/ls
08:54:58 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
08:55:03 <Twey> hakujin: Hm, Google ‘haxl’
08:55:29 <Twey> I'm not sure if the code is released yet, but there's at least plenty of information on how he did it
08:55:41 <Nik05> ok now im clueless again :P
08:56:05 <Twey> (basically, he implements a monad for ‘dependent’ things and an applicative for ‘non-dependent’ things)
08:56:34 <quchen> Nik05: You can think of a Haskell program as building up a big chunk of data of type `IO a`. The GHC runtime then executes that IO thing. Before it is executed, everything is pure.
08:56:57 <Twey> Nik05: Functions are things that take a parameter and give you something back based on that parameter.  In Haskell, they're effectively always pure.  getLine is a value, like 5 or "hello, Bob".
08:57:16 <quchen> getLine is the value "when executed, fetch a line".
08:57:27 <quchen> It's always "when executed, fetch a line", hence it's pure.
08:57:28 <Nik05> well i thought a pure (something) would always give you the same result for some input
08:57:36 <Twey> Nik05: When your program is run, the compiler/interpreter/whatever will look for a value called ‘main’ and perform the instructions contained therein
08:57:47 <mauke> Nik05: a pure function, yes. non-functions don't have inputs
08:58:09 <hodapp> why did Lisp get all of the Zen culture associated with it? Haskell probably deserves it more.
08:58:12 <Twey> Nik05: The generation of that value, in Haskell, is completely pure.  What the runtime does with it may not be.
08:58:33 <Twey> hodapp: Lisp beat us to it.  =(
08:58:42 <Lethalman> lisp is a lot older I guess
08:58:46 <Nik05> ok but in haskell you dont know if what the runtime does with it, is pure?
08:58:52 <platz> theres a difference between IO "actions" as a deferred action, and "executing" an IO action
08:58:59 <hodapp> So's Fortran, but nobody tried to describe that with anything from Buddhism :P
08:59:02 <Twey> Nik05: You can generally assume that if it's going to the runtime, it's not pure.
08:59:25 <zett_zelett> What about Ruby Monks?
08:59:30 <Twey> Nik05: But yes, the idea is that there's no way to observe that impurity from Haskell — there's no way ‘out’ of the IO monad
08:59:32 <zett_zelett> Isn’t this Zen Culture, too?
08:59:48 <Twey> zett_zelett: Perlmonks got there first
08:59:50 <hodapp> zett_zelett: Ruby Monks?
08:59:59 <Twey> They're just imitating those guys, in true Ruby fashion ;)
09:00:10 <zett_zelett> https://rubymonk.com/
09:00:31 <hodapp> moar liek hipstermonk.com
09:00:40 <quchen>  /j #rubyhate
09:00:51 <hodapp> oh jesus christ, that's a real URL too
09:01:56 <platz> Nik05: this explains the values vs. execution thing -> http://www.haskell.org/haskellwiki/IO_inside#IO_actions_as_values
09:02:20 <quchen> Nik05: The problem with "pure" is that its meaning depends on the context. When people in here call functions "impure" what they really mean is that somewhere along the lines there's an IO action that is executed (i.e. it is on either side of (>>=)).
09:02:30 <Nik05> hm when i search for things about impure code in haskell i always get information that says something about the IO monad, but arent there other monads that can do this?
09:02:52 <mauke> Nik05: the magic of the IO monad is in IO, not the "monad" part
09:02:53 <merijn> Nik05: It's basically people abusing terminology
09:02:58 <mauke> IO just happens to be a monad
09:03:17 <Nik05> yes thats what i just found out, monads have nothing to do with impurity
09:03:37 <mauke> > "hello" >>= (\x -> [x,x])
09:03:38 <lambdabot>  "hheelllloo"
09:03:44 * mauke is using the List monad
09:04:09 <Nik05> ok but is IO the only thing that can do side effects?
09:04:25 <c_wraith> no
09:04:41 <platz> depends on what you mean by "side effect"
09:04:43 <geekosaur> yes and no. for example, ST can do side effects as long as the result is the same as something that could be done purely
09:04:45 <Nik05> :)
09:04:45 <c_wraith> for any particular definition of "side effects" you come up with
09:05:20 <Lethalman> let's say State, you may have two function f1 and f2 that you call and modify the State, those may be side effects for you if you are not in control of what f1 does and what modifiers in your state
09:05:21 <Nik05> but for example to get a random number, thats probably also done with IO?
09:05:24 <geekosaur> (so, for example, you can use a mutable array in ST as long as it stays in ST)
09:05:42 <c_wraith> Nik05: getting an actual random number is a question for philosophers
09:05:42 <Lethalman> *modifies
09:05:52 <geekosaur> depends. PRNGs are actually quite deterministic, but your initial seed probably comes from IO
09:06:02 <geekosaur> if you mean /dev/random, that is necessarily in IO
09:06:18 <Nik05> hm right ok
09:06:25 * quchen can't help but think about acme-year
09:06:29 <merijn> Is there an appropriate mime type for literate haskell or should I just use text/plain?
09:06:53 <monochrom> I recommend text/plain
09:07:17 <catsup> merijn: even if there is, it will not be generally useful to use it
09:07:42 <platz> Is there any way to know if the monad I have is in a 'minimal default' context e.g. "return () :: IO ()", doesn't actually do IO, but you can't tell from the type.  I'm curious because I wondered if i could `sequence` the result of `sequence`, but I realized the default sequence just wraps the result in a return, so you couldn't do the IO twice.
09:07:43 <catsup> (web browsers will just refuse to display the file)
09:08:00 <d3lxa> this channel is so mind-blowing :) thx guys (sorry for the noise)
09:09:34 <Nik05> hm now i want to know how IO is implemented :P
09:09:45 <geekosaur> @google IO inside
09:09:47 <lambdabot> http://www.haskell.org/haskellwiki/IO_inside
09:09:47 <lambdabot> Title: IO inside - HaskellWiki
09:09:57 <Nik05> thanks
09:10:09 <geekosaur> it is both less and more than it looks like :)
09:10:18 <catsup> any module can call out to C without using IO though right?
09:10:47 <mauke> yes, because it's effectively unsafePerformIO
09:14:14 <Nik05> ah now i also understand do
09:14:24 <joelteon> is it possible to make cabal run forward signals to the process it's running?
09:14:55 <merijn> :t sequence
09:14:56 <lambdabot> Monad m => [m a] -> m [a]
09:15:13 <merijn> platz: What do you mean you can't do the IO twice?
09:15:40 <merijn> platz: "let myIO = sequence foo in myIO >> myIO" <- there, done twice
09:15:59 <merijn> Or, for that matter "sequence foo >> sequence foo"
09:17:20 <edwardk> preflex: xseen hvr
09:17:20 <preflex>  hvr was last seen on freenode/#ghc 1 hour, 40 minutes and 11 seconds ago, saying: or alternatively, did you make progress with win64?
09:18:48 <platz> merijn: well i guess you can throw the result away and use the original value again, but not the output of sequence
09:20:07 <platz> :t sequence [readLn::IO Int]
09:20:08 <lambdabot> IO [Int]
09:20:28 <killy9999> I have module A that declares a type familly and module B that imports A. Now if I mport B I'd like to have access to TF defined in A. How can I do that?
09:20:29 <platz> can i then do IO with the IO [Int] ?
09:20:52 <platz> or is that just a "minimal-default' context e.g. return ()
09:21:01 <platz> or am i just conflating too many issues ;)
09:21:07 <killy9999> Right now I'm getting "Not in scope" error
09:21:07 <scshunt> platz: you are conflating too many issues
09:21:21 <scshunt> platz: one way to think of an IO object is a list of instructions to perform
09:21:35 <scshunt> when you use >> or >>=, you append those lists together
09:22:03 <scshunt> "return" has no instructions, but when you compose it with >> or >>=, it doesn't erase all the actions already present. It just doesn't add anything
09:22:16 <scshunt> sequence concatenates all the IO actions in the list into one big action
09:22:28 <merijn> platz: What output of sequence?
09:22:49 <scshunt> it works exactly like any other action: you can run it multiple times, you can run it zero times, you can loop until it gives a certain value
09:23:00 <merijn> platz: sequence returns an IO action, it doesn't *do* anything with that action, you can run it 0 times or 10 times, whatevr you like
09:23:26 <merijn> platz: Might want to read: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
09:23:58 <platz> yeah, I think I got confused because a lot of acrticles say things like "you need to actually 'sequence' the IO to perform it, but again it's not really performed and just a transformation
09:24:18 <scshunt> the only things that really "perform" IO in the abstract sense are main and unsafePerformIO
09:24:48 * hackagebot yesod-core 1.2.6.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.2.6.5 (MichaelSnoyman)
09:24:49 <platz> yeah that makes the most sense, i'll read the article, thanks
09:24:57 <scshunt> although in practice, it is more accurate to say that IO is always performed when encountered, and that main and unsafePerformIO are the only ways to actually encounter them
09:25:01 <scshunt> due to the type system
09:29:00 <benj_> what does it mean to "encounter" IO?
09:29:51 <zomg> benj_: kinda like when you go to a zoo to have an encounter with your favorite animal
09:30:08 <platz> or aliens in the desert
09:43:34 <craig9> Hi Igloo are you here?
09:44:52 * hackagebot dtd 1.1.0.1 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-1.1.0.1 (MichaelSnoyman)
09:44:54 * hackagebot diagrams-haddock 0.2.1.6 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.1.6 (BrentYorgey)
09:44:56 * hackagebot json2yaml 0.3.2.2 - Utility to convert a file from JSON to YAML format.  http://hackage.haskell.org/package/json2yaml-0.3.2.2 (MichaelSnoyman)
09:49:01 <craig9> Hi - Is there a way to specify that one Int going into a function should be larger than the other?
09:49:46 <Jeanne-Kamikaze> you can always use guards
09:49:52 * hackagebot diagrams-contrib 1.1.0.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.0.1 (BrentYorgey)
09:50:16 <craig9> Jeanne-Kamikaze - thanks that gives me something to look at. Couldn't think what to search for.
09:50:27 <Jeanne-Kamikaze> it's a runtime check though
09:51:11 <Twey> craig9: If you mean at compile-time, then yes, but it'll be a little messy
09:51:11 <Iceland_jack> Just to give an example of guards
09:51:12 <Iceland_jack>     foo a b
09:51:12 <Iceland_jack>       | a > b     = Just ...
09:51:12 <Iceland_jack>       | otherwise = Nothing
09:53:12 <enthropy> foo a b = do guard (a > b); Just ...
09:53:39 <craig9> Twey - I was hoping for a compile time check (that's one of the haskell benefits, right?), but guards are much better than nothing. I'm just learning, so perhaps I'll look at messy things later.. :)
09:54:28 <craig9> Iceland_Jack - thanks, I have just written similar code.
09:54:45 <Iceland_jack> craig9: What problem to you have that requires a compile-time check like that?
09:55:40 <craig9> I'm just making a slice function, which returns a subset of an array. Just playing at the moment.
09:56:21 <craig9> It may not even make sense or be possible to check it at compile time, haven't given that part a lot of thought.
09:56:53 <Iceland_jack> It is possible, you can define vectors in Haskell whose length is statically known
09:57:00 <Iceland_jack> (what you call arrays)
09:57:25 <ParahSailin> @ty guard
09:57:26 <lambdabot> MonadPlus m => Bool -> m ()
09:57:45 <Iceland_jack> > guard True :: [()]
09:57:46 <lambdabot>  [()]
09:57:49 <Iceland_jack> > guard False :: [()]
09:57:50 <lambdabot>  []
09:58:06 <craig9> Okay thank you - I'll keep vectors in mind for later.
10:04:40 <lingxiao> hey all
10:05:00 <lingxiao> I'm a bit confused about how this expression type checks in STLC
10:05:18 <lingxiao> II := (λx. x) (λx. x)
10:05:32 <lingxiao> the above is a legal string in untyped lambda calc
10:05:37 <lingxiao> but in typed:
10:05:47 <lingxiao> II := (λx:T. x) (λx:T. x)
10:06:23 <lingxiao> it's a function of arity one applied to a function of arity one, and should not type check?
10:06:32 <lingxiao> though typing it into ghci sees that it clearly does type check
10:06:58 <lingxiao> but that's because of type variables right? which do not exist in STLC
10:09:55 * hackagebot syntactic 1.10 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.10 (EmilAxelsson)
10:12:08 <Iceland_jack> hey lingxiao, how does that type check in ghci?
10:12:30 <lingxiao> let f x = x
10:12:32 <lingxiao> let g = f f
10:12:34 <lingxiao> :t g
10:12:35 <lambdabot> FromExpr a => a
10:12:42 <lingxiao> uh .. g :: t -> t
10:12:49 <lingxiao> f :: t -> t
10:12:49 <Iceland_jack> (hint, note the type)
10:12:59 <Iceland_jack> one is a type variable, it's concrete in the STLC
10:13:36 <lingxiao> right that's what I'm saying, so my conclusion by deduction is II doesn't type check in STLC
10:13:37 <haskellnoob> How do I read in two integers, separated by space(s), from one line of stdin?
10:13:39 <haskellnoob> This is the code which I now have:
10:13:40 <haskellnoob> main = do
10:13:42 <haskellnoob>   ab <- getLine
10:13:43 <haskellnoob>   let [(a, rest)] = reads ab
10:13:45 <haskellnoob>       [(b, _)] = reads rest
10:13:46 <haskellnoob>   putStrLn (show (a + b))
10:13:47 <Iceland_jack> haskellnoob: don't paste into the channel
10:13:48 <haskellnoob> Is there a "simpler" and/or more idiomatic way of doing this?
10:13:55 <Iceland_jack> @where paste
10:13:55 <lambdabot> http://hpaste.org/new/haskell
10:14:00 <Iceland_jack> lingxiao: That's right
10:14:06 <haskellnoob> Iceland_jack: sorry
10:14:15 <Iceland_jack> haskellnoob: you use words to separeate them by spaces
10:14:16 <lingxiao> oh ok nice! :) I should just follow logic more, and not "wah wah it should work"
10:14:22 <Iceland_jack> then you can map with read
10:14:28 <Iceland_jack> > "24 53"
10:14:29 <lambdabot>  "24 53"
10:14:30 <Iceland_jack> > words "24 53"
10:14:31 <lambdabot>  ["24","53"]
10:14:38 <Iceland_jack> > map read (words "24 53") :: [Int]
10:14:39 <lambdabot>  [24,53]
10:14:48 <Iceland_jack> if you plan on summing them up you do
10:14:50 <startling> is there something in recursion-schemes analogous to Free?
10:14:54 <Iceland_jack> > sum (map read (words "24 53")) :: Int
10:14:55 <lambdabot>  77
10:15:03 <Iceland_jack> so you have
10:15:03 <Iceland_jack> @ty sum . map read . words
10:15:04 <lambdabot> (Num c, Read c) => String -> c
10:15:20 <Iceland_jack> haskellnoob: Does that answer your question?
10:15:20 <startling> Maybe I should just use recursion-schemes Foldable.
10:15:49 <haskellnoob> Iceland_jack: thank you. Let me think for a bit.
10:16:01 <Iceland_jack> Okay
10:16:52 <Iceland_jack> For a complete program it should be something like
10:16:52 <Iceland_jack>     main = do
10:16:52 <Iceland_jack>       line <- getLine
10:16:52 <Iceland_jack>       let [a, b] = map read (words line)
10:16:55 <Iceland_jack>       print (a + b)
10:17:18 <Iceland_jack> but this will fail with a run-time error if ‘line’ does not contain two numbers separated by space
10:17:32 <haskellnoob> Iceland_jack: Thank you. that answers my question. I was not sure that let [a, b] = map read (words line) would pattern-match
10:17:47 <Iceland_jack> > let [a, b] = [24, 53] in a + b -- :)
10:17:48 <lambdabot>  77
10:18:00 <lingxiao> ok so this is a little weird
10:18:16 <startling> > let [a, b] = [1, 2, 3] in a + b
10:18:17 <lambdabot>  *Exception: <interactive>:3:5-22: Irrefutable pattern failed for pattern [a, b]
10:18:41 <Iceland_jack> lingxiao: (are you going through Pierce's Types and Programming Languages)
10:18:43 <lingxiao> something like (λx. x)x would be the normal form in untyped lambda calc, assuming call-by-value
10:18:56 <lingxiao> yes I am, and doing the exercises in haskell
10:19:32 <lingxiao> but (λx:T. x)y wouldn't even type check in STLC, since the type checker wouldn't know what type to assign to y
10:19:53 <lingxiao> is that right?
10:20:09 <Iceland_jack> lingxiao: what do you mean by
10:20:09 <Iceland_jack>     (λx. x) x
10:20:09 <Iceland_jack> ?
10:20:14 <Iceland_jack> is the right-most x unbound?
10:20:31 <lingxiao> yes, it's just a variable
10:21:00 <lingxiao> wait.. is that a legal string in untyped lambda? or should it be λy.(λx. x)y
10:21:13 <Twey> lingxiao: No, it's fine, it just contains a free variable ‘x’
10:21:36 <Twey> lingxiao: That's a valid normal form, yes
10:21:40 <startling> lingxiao: λy.(λx. x)y eta-reduces to (λx. x)
10:21:44 <Twey> Er
10:21:51 <Iceland_jack> Twey: Is it?
10:21:59 <startling> yes.
10:22:02 <Twey> startling: Only under non-strict evaluation; the language lingxiao is studying is strict
10:22:09 <startling> oh. well !
10:22:23 <lingxiao> yeah I got really confused by that too in the beginning..
10:22:25 <Twey> ‘assuming call-by-value’ :þ
10:22:26 <Iceland_jack> Yes, Pierce's book uses call-by-value
10:22:42 <Iceland_jack> where the only value is a lambda abstraction
10:23:03 <lingxiao> but if I wanted to do call-by-name on (λx. x)y
10:23:07 <lingxiao> then it would reduce
10:23:24 <lingxiao> however, in STLC, something like (λx:T. x)y is not even a legal string right?
10:23:40 <lingxiao> so I can't do full-evaluation on it even if I wanted
10:23:51 <Iceland_jack> It is if: y : T ∈ Γ
10:23:54 <Twey> lingxiao: It's better to speak of strict or lazy evaluation rather than call-by-name and call-by-value.  Those have traditional meanings in imperative languages that aren't necessarily germane in other types of languages.
10:24:18 <Iceland_jack> Twey: Those are the terms used in the book for what it's worth
10:24:29 <lingxiao> Twey: oh ok got yah
10:24:32 <Twey> Are they?  I don't remember
10:24:42 <lingxiao> yeah, he uses call-by-name,call-by-value,full
10:24:49 <Twey> That's odd.  Oh well.
10:25:20 <Twey> Anyway, lingxiao: You can have free variables in STLC as much as in ULC; the expression just has to type-check
10:25:24 <lingxiao> Iceland_jack: when you say "It is if: y : T ∈ Γ", isnt that the same as saying "λ:T. (λx: T ->T. x)y"
10:25:37 <Twey> lingxiao: No, it isn't
10:25:45 <lingxiao> so with free variables, my impression is that something has to be stored in the environement
10:25:58 <Twey> The value is an application, not a lambda.  It's just being typechecked with a type for the free variable ‘y’ in context.
10:26:07 <Twey> The context and the environment are separate
10:26:08 <lingxiao> so really (λx.x)y is ( (λx.x)y, env = [y, ..])
10:26:27 <Nik05> can you ask question about ghc here too or?
10:26:43 <Nik05> guess there is a #ghc :)
10:26:46 <Twey> The context stores the types of things, and is used when typechecking.  The environment stores the values of things, and is used when evaluating (though I think Pierce doesn't even use an environment: he just substitutes)
10:27:27 <Twey> There's no environment when typechecking, and no context when evaluating (usually)
10:27:32 <lingxiao> Twey: see this is where I get confused by the difference between lambda calculus in itself, and how it's implemented
10:27:47 <lingxiao> I thought in lambda calculus, there is nothing stored anywhere, no "tape"
10:28:19 <lingxiao> so you can't have something that's really "free" and not stored in the AST itself ..
10:28:20 <Twey> lingxiao: There isn't, necessarily.  The environment is equivalent to substitution.
10:28:38 <lingxiao> Twey: so substitution exists outside of the formal system?
10:28:40 <Twey> Er, that has nothing to do with ‘free’, though
10:29:02 <Twey> No, substitution is part of the system: there's a substitution rule defined as part of the language
10:29:13 <lingxiao> I guess in my mind the y (λx.x)y is not in the AST ...
10:29:33 <Twey> (λx. e) v ⇒ [x/v]e or so
10:29:59 <lingxiao> ohhh . .you're saying when strings get beta reduced, the variable goes from the string to the substution
10:30:12 <lingxiao> oh ok, wow that's nice. thanks for highlighting that fact for me
10:30:20 <Twey> Err
10:30:26 <Twey> I'm not sure what that means, so I might be :þ
10:30:49 <lingxiao> I think we're on the same page haha ..
10:30:53 <lingxiao> or I'm on your page
10:30:58 <lingxiao> while speaking gibberish
10:31:32 <lingxiao> so to the earlier point, (λx:T->T. x)y is fine in STLC
10:32:25 <Twey> lingxiao: There are two obvious ways to implement that substitution: as a literal substitution (you go through the e and replace every instance of x with v until you get to something that shadows x, then evaluate the resulting expression), or with an environment (you record the binding x=v somewhere, then evaluate e, and every time you encounter a variable you look it up in your ‘environment’ [table of
10:32:27 <Twey> bindings]).
10:33:22 <Twey> lingxiao: Yes, that expression will type-check so long as y has the appropriate type (i.e. it's in your context and has a type that matches T→T)
10:33:30 <Twey> It won't evaluate, though, obviously
10:34:08 <lingxiao> Twey: ok now I see, thanks for clearing it up!
10:34:13 <Twey> No problem
10:37:10 <Iceland_jack> <lingxiao> I think we're on the same page haha ..
10:37:11 <Iceland_jack> homopaginality
10:37:27 <Twey> Heh
10:41:10 <lingxiao> Lawl
10:42:02 <lingxiao> heteroexpressionality
10:54:01 <Nik05> does anyone have a nice reference for operator precedency?
10:55:39 <S11001001> Nik05: :info
10:56:22 <kristof> Can someone give me a good example of a useful monoidal homomorphism between two monads? (And is that called a "monadic homomorphism"?)
10:56:24 <Nik05> where?
10:57:28 <Nik05> S11001001 ghci doesnt give precedence with :info
10:57:38 <kristof> Also, would something of that nature be trivially parallelizable because the two monads are still both monoids?
10:58:17 <S11001001> Nik05: > :info * ... infixl 7 *
10:59:10 <darkPassenger> so huh , list generators
10:59:16 <Nik05> S11001001 but it doesnt do that for all operators
10:59:22 <S11001001> Nik05: example?
11:00:06 <conal> kristof: I have one or more useful examples of monad homomorphisms in a paper (http://conal.net/papers/type-class-morphisms/), but I don't know what the monoid/monad connection is that you have in mind.
11:00:41 <Nik05> S11001001 doesnt it only do it for infix functions?
11:01:22 <Nik05> with operator precedence i meant, showing how some code is interpreted
11:01:32 <kristof> conal: well, I figured that one of the best parts of having a monoid is having something that's chunkable across lots of cores because of associativity, and preserving that with a homomorphism is even better.
11:01:54 <S11001001> Nik05: the main thing there seems to be layout, not operators
11:01:58 <conal> kristof: yeah.
11:02:17 <conal> kristof: and how does Monad come in?
11:02:25 <kristof> conal: and so I learned that a monad is also a monoid. Right?
11:02:44 <Nik05> S11001001 i was looking for something like this http://en.cppreference.com/w/cpp/language/operator_precedence
11:03:00 <kristof> conal: well by virtue of that relationship, stringing a bunch of monads together becomes chunkable in itself and I want to see some of that in action.
11:03:27 <conal> kristof: in which sense of monad-as-monoid?
11:04:20 <kristof> conal: in the sense that all monads are monoids and hence have mappend defined on them. Am I missing something?
11:05:01 <conal> kristof: i wonder if you mean applicative-as-monoid with mempty = pure mempty and mappend = liftA2 mappend.
11:05:22 <conal> i.e., f o is a monoid, where f is applicative and o is a monoid.
11:06:03 <conal> hm. does the monoid-ness of f o follow from the monoid laws (for o) and applicative laws (for f)?
11:06:20 <kristof> *shrug*
11:06:34 <S11001001> Nik05: Yeah, that's what I thought you were looking for.  Most of those are just functions in haskell.  You cannot write such a guide for haskell.  You can write such a guide *for the choices made in Prelude*, but those are not only necessarily incomplete, but potentially confusing if someone has made a Prelude-incompatible import of some symbol.
11:06:36 <kristof> conal: I'll go learn more Haskell. :P
11:06:46 <conal> kristof: or do you mean in the sense of http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem ?
11:07:00 <kristof> conal: I mean exactly that
11:07:13 <kristof> conal: I realize the original quote is a joke
11:07:21 <shachaf> Another sense that you can have a "monoid in the category of endofunctors" is the monoidal category with (:*:) as the product and Proxy as the identity.
11:07:59 <shachaf> In which case you get a structure like Alternative -- unit :: f a and mult : f a -> f a -> f a
11:08:07 <conal> kristof: ah. then maybe not relevant to parallelization. don't know. hm.
11:08:21 <kristof> :( that's alright
11:08:23 <shachaf> Which is like Alternative.
11:08:27 <Nik05> hm ok thank you S11001001 but somethings in haskell arent functions. like do, =, let, where, where can i find there precedence?
11:08:45 <S11001001> Nik05: right.  For those you want to look for a guide to layout.
11:08:54 <shachaf> Those things are syntax, and they don't really have precedence as such.
11:09:05 <shachaf> But you can read the Haskell Report for an exact specification.
11:09:38 <shachaf> Why is Alternative a subclass of Applicative?
11:13:15 <partycoder> anyone here using cloud haskell?
11:14:16 <partycoder> if so, very simple question: would you recommend it as a replacement for scala/akka or erlang?
11:14:45 <kristof> I don't know if Haskell has been put to the test in fault tolerant domains.
11:14:55 <kristof> The kind where a machine goes down and that's that.
11:15:24 <kristof> partycoder: But here's a different problem: actors are all about side effects and shared mutable state.
11:15:42 <kristof> They don't compose, they don't scale, etc.
11:16:08 <partycoder> it's not a continuous stream of information
11:16:46 <kristof> http://pchiusano.blogspot.com/2010/01/actors-are-not-good-concurrency-model.html <- partycoder!
11:17:16 <partycoder> i will read it
11:17:26 <partycoder> however, if you had to compare those 2 solutions side to side
11:17:31 <kristof> It's a good read :)
11:17:33 <partycoder> 3*, i say
11:17:40 <partycoder> which one would you prefer
11:18:16 <Nik05> ah ok S11001001 i think i found some info looks like the "syntax operators" have lowest precedence
11:18:20 <kristof> partycoder: Dunno! I think Erlang but I want to be proven wrong and shown large scale, distributed, fault tolerant haskell systems
11:18:57 <kristof> partycoder: Someone might be offended by this statement but the lambda calculus was not designed to model concurrent, separate processes. Erlang is based on the pi calculus.
11:19:14 <darkPassenger> lol
11:19:23 <kristof> Lured one in!
11:20:06 <Taneb> Is Haskell' still happening?
11:20:45 <hodapp> pi calculus?
11:20:50 <darkPassenger> sure is from what I hear around here
11:22:07 <kristof> hodapp: and/or process calculus. I'm not sure of the relation to Hoare's CSP, but I think one exists.
11:22:45 <xrl__> I'm trying to build a ghc cross compiler for linux-x86 -> linux-armv6 and I'm getting errors during ghc build for "configuring ghc-prim"
11:22:46 <xrl__> https://gist.github.com/xrl/5f81b2c975e70112e8b7
11:23:03 <xrl__> it's giving me an error about a file not existing in /tmp
11:23:13 <xrl__> how can I start debugging that configure process?
11:23:15 <hodapp> kristof: interesting!
11:23:20 <conal> one could have a distributed & fault-tolerant implementation (operational notions) of something denotative like haskell. rather than trying to bring the operational notions into the semantic model of the language itself.
11:24:55 <hodapp> kristof: Wikipedia page on CCS (Calculus of Communicating Systems) notes that Hoare's CSP arose at a similar time - but that's all it says
11:25:08 * hackagebot gnuplot 0.5.2 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.5.2 (HenningThielemann)
11:26:06 <Twey> kristof: Hrm.  I don't like that article.  π-calculus achives composability in much the same way as λ-calculus, just with message-passing being the fundamental communication operation instead of function application.  The issues described with the actor model come there not from the model itself but with its combination with side-effects.
11:26:21 <Twey> But maybe that's implicit in the definition of ‘actor model’ being used here
11:27:19 <Nik05> ah we where just talking about "impure" things. And now im looking at Control.Monad.State, which really helps me understanding IO and "impure" "stuff"
11:28:50 <kristof> Twey: I can't think of a way to do actor-model without allowing for the actor to decide whom to send messages to. So yes, I think it's implicit in actor-model; however, I've been contemplating what makes the actor model so cool
11:29:02 <conal> Nik05: warning: there's a popular myth that IO is explainable in terms of State, but it's untrue.
11:29:09 <kristof> Twey: And the real value seems to be in the ability to apply state transformations to something in any order, asynchronously.
11:29:18 <Nik05> ok thanks conal :p
11:29:26 <conal> (*accurately* explainable, that is)
11:29:53 <Nik05> but i think how it works now
11:30:10 <kristof> Twey: So I posed the question in here yesterday: if you knew ahead of time all the possible state transformations that could ever happen on a piece of state (via static analysis), and you could prove that they were all commutative, couldn't you, at compile time, change all synchronous code affecting that state to 'asynchronous' code? Like a transformation.
11:30:18 <conal> Nik05: State does explain a *very* simple notion of purely sequential & non-interactive stateful computation.
11:30:29 <Twey> kristof: Only in the same sense as the λ-calculus, i.e. a lambda can decide on the continuation to call from its lexical environment
11:30:31 <Nik05> i was looking at code that uses State, and there was just a foo <- get, but i had no idea where the info from get would come from
11:30:44 <darkPassenger> does reverse on a list reverse the actual list or returna new list
11:30:54 <Twey> kristof: I think Simon Marlow is doing that at Facebook, with haxl
11:31:14 <Twey> (for a slightly different purpose)
11:31:14 <Nik05> i think i got it ahah
11:31:23 <conal> darkPassenger: are you asking whether the original list is destroyed/mutated?
11:31:51 <darkPassenger> conal yes
11:32:36 <conal> darkPassenger: functions in haskell are like functions in math. they don't mutate anything.
11:32:49 <conal> darkPassenger: i.e., no "side effects".
11:33:01 <darkPassenger> conal so the result has to be affected to a variabl e
11:33:58 <nadirs> conal: maybe darkPassenger meant deconstructed+reconstructed rather than destroyed/mutated?
11:34:10 <kristof> Twey: I'm looking that up right now. Do you see the value in what I'm talking about, though? If you can automatically transform those things, then you have implicit actors, not explicit ones
11:34:17 <Twey> kristof: Oh, I guess haxl is just about *retrieving* data rather than *transforming* it
11:34:23 <Twey> Yes, absolutely
11:34:34 <kristof> And by actor I mean a reduced version that simply means "here lies some state that has things done to it... whenever."
11:34:55 <kristof> But my actors can't launch missles. So they're more like nondeterministic wormholes!
11:35:03 <Twey> But I have a feeling that doesn't cover every use-case for actors
11:35:03 <nadirs> conal, darkPassenger: so a similar question might also be: does `head . reverse . reverse` traverse the list twice?
11:35:09 * hackagebot uuid-aeson 0.1.0.0 - Aeson types for UUID instances.  http://hackage.haskell.org/package/uuid-aeson-0.1.0.0 (KirkPeterson)
11:35:17 <conal> darkPassenger: you'd want to name the result (e.g., "let foo = reverse ... in ...") or apply another function (e.g., "length (reverse ...)").
11:35:19 <kristof> Twey: Chiusano would argue that the use cases for actors aren't useful
11:35:22 <nadirs> conal, darkPassenger: no, nevermind, I totally misread it :P
11:35:47 <kristof> Twey: And I agree with a LOT of what he was saying. Messages between actors really can't be usefully typed, at least not in any implementation I've ever seen
11:36:16 <Twey> kristof: Are you aware of SPJ's (and others') work on session types?
11:37:10 <Twey> (I might be being terribly unfair in crediting that to SPJ; that's just where I saw it first)
11:37:18 <kristof> Twey: I've never ever ever heard of those
11:37:37 <kristof> Apologies to everyone in the channel if this is obnoxious! Twey and I can move to a query if you all would like.
11:38:11 <hakujin> kristof: then others couldn't learn from what you're saying
11:38:15 <Twey> Absolutely, though I think this is fairly par-for-the-course for #haskell!
11:39:01 <kristof> hakujin: I'm nobody to learn from
11:39:27 <Twey> kristof: Session types are where you encode the expected protocol into the channel.  So channels have types like ‘expects an int, then produces an int’, or ‘(expects an int then produces an int OR expects a string then produces a string)’
11:40:28 <Twey> Along with all the usual type-theory questions like recursive types, type functions, &c.
11:42:46 <nadirs> +1 hakujin, conversation between people are very interesting (though I usually understand about 1% of what you guys say :)
11:43:05 <nadirs> *conversations in this channel
11:43:32 <kristof> Twey: Read that 5 times and then suddenly, in my head: "Oh, you mean contracts."
11:43:50 <Twey> Do I?  :þ  I haven't heard them called that
11:44:07 <kristof> Twey: Look it up. I think the first programming language was called "Paris" that included it. Could be wrong?
11:44:10 <kristof> No, Eiffel, lmao
11:44:19 <kristof> Twey: I also think Hoare was responsible for that, too.
11:45:12 <Twey> I don't think contracts are similar
11:46:54 <Twey> AIUI, contracts are pre- and post-conditions checked at runtime?
11:47:03 <weweqwqw> is it possible to label points in easyplot?
11:50:47 <kristof> Twey: Oh, maybe.
11:50:53 <kristof> Twey: I'm confused now. What is... a protocol?
11:51:10 <kristof> Protocol is one of those overloaded words in computer science
11:54:24 <davidfetter_disq> there are two hard problems in computer science: naming things, caching, and off-by-one
11:54:27 <Twey> kristof: What I just described.  :þ  A description of what the channel expects to send and receive
11:54:54 <kristof> Oh so we're specifically talking about CSPs right now, right?
11:55:01 <kristof> I thought we were still on actors or something, but channels are cool, yes
11:56:07 <BassSultan> hey, can any1 explain to me, why (\x y z-> y.x.y) has a type signature of :: (a -> b) -> (b -> a) -> c -> b -> a ? thx
11:56:10 <Twey> kristof: Actors are basically CSPs (well, π-calculus)
11:56:32 <kristof> Twey: No, because the internal state of an actor is not going to be a channel. The QUEUE is, but I think things are organized slightly differently
11:56:46 <Twey> :t (.)
11:56:47 <lambdabot> (b -> c) -> (a -> b) -> a -> c
11:57:54 <enthropy> do you really mean to not use z on the right hand side?
11:58:44 <BassSultan> its a problem from an older exam, the task was to determine the type of given expressions/functions
11:59:18 <Twey> BassSultan: x is a function from (a → b), and y is a function from (b → a), so x . y is a function from (b → b), and then you call y on the result of it again, making y . x . y a function of type (b → a)
12:00:08 <Twey> -> associates to the left, so that type is equivalent to (a → b) → (b → a) → c → (b → a), if that's any easier for you
12:00:29 <Twey> The c is an arbitrary type because you never use the value, so it doesn't matter what type it is
12:00:52 <weweqwqw> hm, it seems easyplot can't do it.  is there a package on hackage that allows to label points?
12:01:03 <Twey> kristof: The internal state of a process doesn't go into a channel in π-calculus, either
12:01:40 <Twey> weweqwqw: I think ‘chart’ does
12:01:54 <weweqwqw> Twey: Thanks, will try in a second.
12:02:07 <BassSultan> Twey: so the left side of this is evaluated like this: (((x) y) z) and the right side like this: (y ( x ( y))); i know this is not proper notation :) just for understanding
12:02:24 <Twey> BassSultan: Eh?  You didn't give a left-hand side
12:03:12 <BassSultan> Twey:  \x y z -> y.x.y ; i thought the part left of the arrow / right of the arrow were sides?
12:03:15 <Twey> The ‘x y z’ there are just the names of the parameters.  x is the one that will be substituted first, i.e. (\ x y z → …) a b c  gets x = a, y = b, z = c
12:03:59 <Twey> Oh, I see.  Sure, I guess.  It's not evaluated anywhere, though.
12:04:11 <BassSultan> Twey:  and what would something like \x \y \z mean? what is the backslash? :)
12:04:18 <monoidal> \x y z -> ... is the same as \x -> \y -> \z -> ...
12:04:19 <Twey> The ‘left-hand side’ (parameter list) isn't an expression, it's just a series of patterns
12:04:30 <kristof> Twey: Haxl is cool.
12:04:37 <Twey> BassSultan: The backslash introduces a lambda, an anonymous function
12:04:42 <monoidal> which is the same as \x -> (\y -> (\z -> ...))
12:04:47 <Twey> BassSultan: I'd recommend reading through Learn You A Haskell, or something
12:05:13 * hackagebot pooled-io 0.0 - Run jobs on a limited number of threads and support data dependencies  http://hackage.haskell.org/package/pooled-io-0.0 (HenningThielemann)
12:05:15 <Rarrikins> They should totally make Learn You A Haskell Or Something.
12:05:23 <Twey> Maybe as a sequel :þ
12:05:27 <Rarrikins> Yees
12:05:30 <Twey> kristof: It is indeed
12:06:17 <kristof> So Template Haskell allows you to type your program, which is an interesting concept. I can't think of any cool examples of dispatching a metaprogram based on the type, though...
12:06:18 <BassSultan> ok now im really confused.. :)
12:06:26 <adelbertc> is parsec the premiere parser combinators library in haskell?
12:06:37 <kristof> adelbertc: Yes.
12:06:42 <kristof> Now go forth and combine parsers.
12:06:51 * adelbertc salutes and departs
12:06:52 <Twey> Heh
12:07:16 <Twey> It's the most established.  There are others that might be nicer, if you're willing to venture onto shakier ground.
12:08:06 <Twey> BassSultan: Really, read the book.  It's very friendly (it has lots of pictures), and it's available online for free.
12:09:43 <conal> adelbertc: Doaitse Swierstra's parser combinators have some strong advantages over parsec.
12:10:13 * hackagebot pdfinfo 1.5.0 - Wrapper around the pdfinfo command.  http://hackage.haskell.org/package/pdfinfo-1.5.0 (ChrisDone)
12:10:27 <conal> adelbertc: in part because they are non-monadic and hence compilable.
12:10:29 <BassSultan> Twey: i would totally do that, but i have only like 16 hours left to understand this :P. if i can ask u one more thing.. if \x -> \y -> \z is the same as \x y z.. why is (\x -> \y -> \z -> (x y, x (x z))) :: (a->a)->a->a->(a,a)?
12:11:05 <Twey> :t \x y z -> (x y, x (x z))
12:11:06 <lambdabot> (t -> t) -> t -> t -> (t, t)
12:11:14 <Twey> :t \x -> \y -> \z -> (x y, x (x z))
12:11:14 <lambdabot> (t -> t) -> t -> t -> (t, t)
12:11:25 <conal> adelbertc: e.g., thanks to using statically computed lookahead sets, which the Monad interface thwarts.
12:11:40 <adelbertc> conal - ah interesting
12:11:45 <adelbertc> will take a look, thanks!
12:11:50 <conal> :)
12:11:51 <Twey> BassSultan: That has nothing to do with lambda notation
12:12:08 <Twey> You changed the body of the lambda, so the lambda's type changed accordingly
12:13:39 <BassSultan> Twey: i mean it looks like x is a function that returns something of type a, which would explain the (a,a) part ? im reading up on the learn u a haskell book, maybe that will actually help
12:14:26 <platz> adelbertc: apparently attoparsec is better for dealing with large amounts of automatically genrerated data, according to SO
12:15:06 <Rarrikins> BassSultan: x (x y) implies that the function is a -> a.
12:15:14 * hackagebot intervals 0.4.1 - Interval Arithmetic  http://hackage.haskell.org/package/intervals-0.4.1 (EdwardKmett)
12:15:16 <platz> http://stackoverflow.com/questions/19208231/attoparsec-or-parsec-in-haskell
12:15:52 <Rarrikins> BassSultan: Since you have two results of x, that means that it's (a, a).
12:16:35 <Twey> BassSultan: The type ‘a’ is the most general type possible — it could be literally anything.  So every function is a function that returns type ‘a’.  :þ  The name ‘a’ is chosen arbitrarily; if you look at lambdabot's output above, you'll see it's decided to call the parameter ‘t’, which is fine too.
12:16:49 <BassSultan> Rarrikins: you mean because x returns something of his own type (a) and then immedeatly takes that a in x(a) ?
12:17:35 <Twey> BassSultan: If x ∷ a, and y ∷ b, then (x, y) ∷ (a, b)
12:17:43 <Rarrikins> BassSultan: Yes, plus the function is the same variable both times. It can't be a -> b one time and b -> c the next time with a polymorphic function, since x is set to only one type.
12:18:29 <Twey> In this case, x y ∷ a (for whatever a x returns) and x (x y) also ∷ a, because again it's the return value of a call to x, so (x y, x (x y)) ∷ (a, a)
12:18:52 <BassSultan> Twey: i think i get it a lil bit now :) i was just confused why x y z weren't replaced with a b c, but now that i see that x(x(z)) implies a->a for x.. i think i understand ..
12:18:56 <BassSultan> thx guys
12:19:06 <BassSultan> this is actually helpful :)
12:19:13 <Twey> BassSultan: a is a type, and x is a value — they live in separate namespaces
12:19:20 <Rarrikins> No problem.
12:19:44 <Twey> In your example, x ∷ a (read ‘x has type a’), but that doesn't make them the same thing.
12:20:15 * hackagebot fay 0.19.0.1 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.19.0.1 (AdamBergmark)
12:22:08 <BassSultan> another thing that i do not quiet get.. what is this point supposed to mean if i have two values in a body: (\x y z -> y.x.y) what does the "
12:22:16 <BassSultan> what does the "." do? :)
12:23:06 <Twey> BassSultan: Function composition
12:23:43 <BassSultan> Twey: (f.g)x == f (g x) ? but i thought x y z were values :)?
12:25:48 <Twey> BassSultan: Yes, they are
12:25:57 <BassSultan> Twey: but the values could be something like x = (f val1) y = (g val2) ? and the results are the values of the type a , b ,. ..
12:26:12 <kristof> What's the prefix version of "<*>"?
12:26:17 <Twey> BassSultan: I don't understand your question
12:26:27 <Twey> Haskell functions are values
12:26:27 <platz> kristof: fmap
12:26:31 <Twey> kristof: ap
12:26:37 <conal> kristof: (<*>)
12:26:39 <Twey> But only for Monads.  ☹
12:26:42 <kristof> wait
12:26:43 <Twey> Hehe
12:26:46 <kristof> I just got three different answers
12:27:09 <Twey> kristof: fmap is wrong, (<*>) is right, and ap is kind-of-right-but-weaker :þ
12:27:11 <kristof> Why do we have functors if we can just use applicatives everywhere?
12:27:23 <kristof> No-context is a context, isn't it?
12:27:24 <conal> kristof: we can't
12:27:25 <Twey> (<*>) is not fmap.
12:27:28 <joelteon> applicatives don't have fmap
12:27:33 <Twey> Not every Functor is an Applicative
12:27:39 <kristof> Oh
12:27:54 <conal> applicatives do have fmap. but some functors don't have pure and/or <*>
12:28:05 <Twey> joelteon: fmap f v = f <*> pure v
12:28:13 <Twey> Er
12:28:14 <joelteon> applicatives do have fmap
12:28:20 <joelteon> pure f <*> v
12:28:21 <Twey> pure f <*> v
12:28:22 <joelteon> yeah
12:28:27 <joelteon> silly me
12:29:56 <kristof> pure f means no context, right?
12:30:09 <joelteon> pure f creates the context
12:30:14 <kristof> Ah, I see
12:30:15 * hackagebot castle 0.1.0.0 - A tool to manage shared cabal-install sandboxes.  http://hackage.haskell.org/package/castle-0.1.0.0 (EricRochester)
12:30:18 <Twey> :t pure
12:30:18 <lambdabot> Applicative f => a -> f a
12:30:51 <Twey> > let f = undefined :: a -> a in pure f
12:30:53 <lambdabot>  No instance for (Control.Applicative.Applicative f0)
12:30:53 <lambdabot>    arising from a use of `e_1'
12:30:53 <lambdabot>  The type variable `f0' is ambiguous
12:30:53 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:30:53 <lambdabot>  Note: there are several potential instances:
12:31:11 <Twey> Damn
12:31:14 <weweqwqw> Twey: It seems that the recent version of chart is broken.
12:31:27 <platz> ah i was wrong, was thinking of <$>
12:31:29 <platz> sorry
12:32:04 <weweqwqw> Twey: http://stackoverflow.com/a/20856226
12:32:31 <BassSultan> Twey: what i should have said.. x takes an argument of type a, y of type b. since we can see that y is called first, then x we can infer that the body takes a b and produces an a, which is taken by x and returns a, which in turn is taken by the 2nd y and returned as a. thus b -> a in the body? and the c is just chilling in the middle somewhere :)
12:32:59 <BassSultan> Twey: sorry for the long, unreadable @#%&/t.. :)
12:34:05 <Twey> BassSultan: I don't know which example you're talking about.  y isn't (necessarily) a function in your most recent example.
12:34:53 <Twey> weweqwqw: That's unfortunate.  You can use an earlier version, though.
12:35:03 <Twey> (or hack around it by writing your own instance)
12:35:16 * hackagebot pandoc-types 1.12.3.1 - Types for representing a structured document  http://hackage.haskell.org/package/pandoc-types-1.12.3.1 (JohnMacFarlane)
12:35:43 <BassSultan> Twey: \x y z -> y.x.y is the one i meant
12:36:36 <weweqwqw> Twey: Yeah, I'll probably try the later first.  0.17 requires some dependencies that will be tedious to install.
12:36:36 <Twey> BassSultan: x has type (b → a)
12:36:43 <Twey> Err
12:36:48 <Twey> BassSultan: y has type (b → a)
12:38:54 <Twey> But more relevantly, x has type (a → b).  So x can only ever return a b.
12:39:04 <BassSultan> Twey: jeah and we get that from the body because the body implies 1) x and y are functions (cause of .) and 2) if x gets type a and y gets type b, then y has to return a, thus y has (b->a) and x has (a->b)?
12:39:16 <Twey> Yes
12:39:19 <kristof> Is there a flipped version of >>= which takes a function and a monadic value instead of a monadic value and a function?
12:39:26 <Twey> kristof: Yes
12:39:33 <Twey> :t (=<<)
12:39:33 <lambdabot> Monad m => (a -> m b) -> m a -> m b
12:39:34 <kristof> Don't tell me it's =<<
12:39:36 <kristof> lol
12:39:41 <Twey> TIAS :þ
12:39:51 <kristof> :th?
12:39:51 <Twey> Sadly, though, no (<<)
12:40:03 <Twey> Don't ask me why
12:40:13 <shachaf> Because it's not obvious what it should be.
12:40:27 <Twey> shachaf: It's not?
12:40:37 <shachaf> Not to me.
12:40:40 <Twey> m a → m b → m a ?
12:40:48 <shachaf> That's the type, yes.
12:40:53 <shachaf> But what should the behavior be?
12:40:54 <monoidal> Twey: whether it should be a <- x; y <- y; return x or return y
12:41:04 <monoidal> I mean, a <- x; b <- y; return a or return b
12:41:12 <monoidal> bleh
12:41:21 <shachaf> The question is whether it should be like (<*) or like flip (>>)
12:41:21 <Twey> :t (>>)
12:41:22 <lambdabot> Monad m => m a -> m b -> m b
12:41:42 <Twey> Surely the only reasonable value for its flip is flip (>>)
12:41:55 <monoidal> (<*) is also reasonable
12:42:05 <Twey> Not with that syntax, I think
12:42:11 <monoidal> considering (>>) = (*>)
12:42:12 <kristof> Twey: Oh, so to remember whether to use >>= or =<<, the arrows point in the direction that the value is going
12:42:36 <Twey> Hrm
12:42:37 <Twey> kristof: Yes
12:42:41 <kristof> Ok.
12:43:37 <monoidal> getLine << putLine "a" - it's not intuitive which one should go first.
12:44:00 <Twey> Okay
12:44:32 <Twey> I'm somewhat convinced, I think… although I still feel that the putLine going first is more intuitive
12:45:04 <shachaf> (<*) is popular for parsers, for instance.
12:45:26 <shachaf> string "blah" <* number
12:47:21 <nicoo> :t (*>)
12:47:21 <lambdabot> Applicative f => f a -> f b -> f b
12:47:26 <nicoo> :t (>>)
12:47:26 <lambdabot> Monad m => m a -> m b -> m b
12:48:52 <kristof> Imagine, for a second, that "." was very, very polymorphic and became "<=<" whenever it was used to compose monadic functions. Would there be an instance where you wanted just normal "." instead of "<=<"?
12:49:36 <jle`> can someone help me with my arrow problem?  I have outside :: Cat () [a], middle :: Cat [a] [a], and inside :: Cat [a] a.  Basically, inside returns an a based on a list of a's.  middle returns a list of a's based on applying `inside` with every a in the input, but only with the a's in the list...and `outside` feeds in an initial list of [a]'s (that come from `inside`) to `middle`.
12:49:39 <jle`> hm this is quite unweildy
12:49:42 <jle`> aybe i should just stackoverflow it
12:49:45 <jle`> and write it out proper
12:54:43 <weweqwqw> is it possible to attach labels to rows and columns in hmatrix, like in R or Octave?
12:56:21 <platz> i.e. dataframes?
12:56:37 <enthropy> weweqwqw: no. You could instead have   data MatrixNamed a = MatrixNamed (Matrix a) (M.Map String Int) (M.Map String Int)
12:57:37 <weweqwqw> enthropy: Thanks for the idea. I hope it will work.
12:57:43 <enthropy> and define some functions to do lookups or slices based on the Int you get from the row or column Map
12:58:45 <weweqwqw> yeah
12:59:29 <weweqwqw> I should probably suggest it to the maintainer.
12:59:44 <Lethalman> > (Identity 2) <> (Identity 3)
12:59:46 <lambdabot>  No instance for (Data.Monoid.Monoid
12:59:46 <lambdabot>                     (Data.Functor.Identity.Identity a0))
12:59:46 <lambdabot>    arising from a use of `e_123'
12:59:46 <lambdabot>  Possible fix:
12:59:46 <lambdabot>    add an instance declaration for
12:59:48 <Lethalman> knew it
13:00:24 * hackagebot type-eq 0.4.1 - Type equality evidence you can carry around  http://hackage.haskell.org/package/type-eq-0.4.1 (GaborLehel)
13:01:23 <platz> there appears to be some debate on whether dataframes are a good idea https://groups.google.com/forum/#!topic/haskell-cafe/_9cWoxWqbzM
13:01:58 <weweqwqw> platz: Do you have a non-Google link?
13:02:47 <Lethalman> what could be a null monoid I can use in RWS? I have no writer
13:02:56 <weweqwqw> platz: Could you please mention the title, so I could find it?
13:02:57 <Lethalman> or should I use ReaderT an StateT manually?
13:03:36 <platz> http://www.haskell.org/pipermail/haskell-cafe/2012-March/100313.html but you have to traverse the thread manually
13:03:52 <weweqwqw> platz: Thank you.
13:05:13 <mastensg> What's the name of that new visual Haskell editor where every word is a block?
13:05:13 <sebastian> Hi, I need an advic regarding this signature: http://hackage.haskell.org/package/scotty-0.6.2/docs/Web-Scotty-Trans.html#v:scottyT
13:05:23 <k00mi> Lethalman: I'd use ReaderT/StateT directly, RWS will be confusing when you don't actually use the Writer
13:05:25 * hackagebot cblrepo 0.10.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.10.1 (MagnusTherning)
13:05:29 <Lethalman> k00mi, ok
13:06:34 <sebastian> ah ok, discovered something.
13:07:49 <darkpassenger> hi all
13:08:13 <mangaba_leitosa> weweqwqw: you don't use google?
13:08:21 <darkpassenger> is the haskell memory model similar to C (stack-heap) or is it like..graph based ?
13:08:35 <darkpassenger> or am I totally nut
13:12:23 <Lethalman> is there any convenient function that runs a function only in the Reader context?
13:12:55 <jle`> Lethalman: hm? do you have an example
13:13:00 <Lethalman> runReaderT maybe
13:13:09 <jle`> a function that is only allowed to run inside a reader?
13:13:17 <ttuegel> darkpassenger: you may be interested in this SO: http://stackoverflow.com/questions/6048194/good-introductory-text-about-ghc-implementation
13:13:18 <kristof> jle`: Don't use it outside of a reader then
13:13:32 <jle`> kristof: :P trying to understand Lethalman's question
13:13:55 <weweqwqw> mangaba_leitosa: The above link requries JavaScript. But I don't use Google in general because it always shows CAPTCHA when I connect over Tor.
13:15:26 * hackagebot git-repair 1.20140115 - repairs a damanged git repisitory  http://hackage.haskell.org/package/git-repair-1.20140115 (JoeyHess)
13:15:56 <adelbertc> anyone play with ghc-ios here?
13:16:08 <mangaba_leitosa> weweqwqw: lately they fixed the site to actually display the search results after entering CAPTCHA. earlier it just used to send you back to the main page :-)
13:16:10 <ZeroGravity> whats ghc-ios?
13:16:28 <adelbertc> ZeroGravity http://www.reddit.com/r/haskell/comments/1lboh4/announcing_ghc_ios
13:16:36 <ZeroGravity> ty
13:16:41 <tippenein> http://lpaste.net/98547 why would fromRow be hidden ?
13:16:57 <tippenein> is it the Generics import? because that seems strange
13:17:48 <kristof> jle`: Sorry, I guess that was for lethalman.
13:17:53 <Lethalman> jle`, \f -> ask >>= runReaderT f
13:17:55 <Lethalman> that was it
13:17:59 <tippenein> nope, not the generics. something else seems to be going on
13:18:04 <angerman> does anyone know of a C# parser for haskell? I need to do some source to source transformation of a relatively simple c# code.
13:18:08 <Lethalman> I'm in an RWS context, and I want to run a function only in the reader context
13:18:14 <Lethalman> (well RS context)
13:18:42 <weweqwqw> mangaba_leitosa: Thanks for letting me know. I've tried a couple of searches right now, and it didn't show up at all.
13:19:17 <Lethalman> is there a function already like this? runR f = ask >>= runReaderT f
13:19:49 <Lethalman> @hoogle ReaderT a m b -> m b
13:19:50 <lambdabot> Control.Monad.Trans.Reader runReaderT :: ReaderT r m a -> r -> m a
13:19:50 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
13:19:50 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
13:19:58 <weweqwqw> pranz: So, I've read the thread, and I'm not convinced at all.
13:22:12 <magicman> @type \f -> ask >>= runReaderT f
13:22:13 <lambdabot> MonadReader a m => ReaderT a m b -> m b
13:23:39 <magicman> Ah. I see. It's the... opposite of lift.
13:23:44 <Lethalman> yes
13:23:46 <Lethalman> unlift :P
13:24:08 <Lethalman> Control.Monad.Run? uhm
13:24:33 <Lethalman> MonadUnTrans, let's see
13:24:51 <Lethalman> I guess the standard Reader has no UnTrans instance
13:25:22 <Lethalman> it's something old apparently
13:26:47 <mangaba_leitosa> weweqwqw: do you use tor all the time? it seems terribly slow
13:27:46 <mangaba_leitosa> somewhat faster lately, though. not sure if this is because of much more exit relays appearing after the news about Snowden & NSA
13:30:44 <weweqwqw> mangaba_leitosa: Yes, nearly all the time.  I try not to download large files over Tor, though.  The speed is fine.
13:31:16 <weweqwqw> mangaba_leitosa: If you have more questions, feel free to /q me or move to #haskell-blah.
13:32:32 <mangaba_leitosa> right. sorry for off-topic
13:35:25 <sebastian> ok, I'm stuck with http://hackage.haskell.org/package/scotty-0.6.2/docs/Web-Scotty-Trans.html#v:scottyT
13:35:43 <Lethalman> ha! ghc: panic! (the 'impossible' happened
13:36:08 <sebastian> especially the second and third parameter
13:36:32 <sebastian> they're killing my monad transformer
13:37:29 <steefh> @version
13:37:29 <lambdabot> lambdabot 5.0-int-e
13:37:29 <lambdabot> git clone git://github.com/int-e/lambdabot.git
13:40:19 <weweqwqw> enthropy: Wait, why did you suggest to us (M.Map String Int)?  I guess it should be the opposite, i.e., (M.Map Int String), no?
13:40:26 <weweqwqw> use*
13:40:46 <enthropy> because you want an entry at ("a","b") more often than the other way around?
13:40:52 <enthropy> maybe you want both
13:41:00 <enthropy> @hackage tables
13:41:00 <lambdabot> http://hackage.haskell.org/package/tables
13:41:07 <enthropy> or maybe ixset
13:42:00 <weweqwqw> enthropy: Ah, I got it.
13:43:54 <tippenein> http://lpaste.net/98547 any hints why fromRow isn't visible ?
13:45:18 <tippenein> http://hackage.haskell.org/package/postgresql-simple-0.1.3/docs/Database-PostgreSQL-Simple-FromRow.html#t:FromRow
13:45:22 <carter> bitemyapp: github.com/wellposed/hopenblas is the work in progress
13:45:29 * hackagebot ig 0.2 - Bindings to Instagram's API.  http://hackage.haskell.org/package/ig-0.2 (JeanPhilippeMoresmau)
13:45:44 <Lethalman> magicman, turns out I don't need any unlift if I put ReaderT as first layer
13:45:52 <Lethalman> cool
13:46:16 <magicman> Provided you don't need any unlift for the other layers :P
13:46:26 <magicman> But that's great!
13:46:41 <bitemyapp> carter: tyvm
13:46:49 <carter> np
13:47:08 <carter> i've a much much fancier api planned for the end users stuff
13:47:41 <carter> but writing the openblas/lapack binding a) to benchmark how slow my own stuff is b) test my own stuff c) when my stuff is slow, have the default ops be the blas ones
13:48:14 <carter> theres a few hand things hmatrix can't express becaues they have a data model that doesn't handle the blas like arrays right
13:48:18 <carter> like matrix slicing
13:50:30 * hackagebot xmlhtml 0.2.3.1 - XML parser and renderer with HTML 5 quirks mode  http://hackage.haskell.org/package/xmlhtml-0.2.3.1 (DougBeardsley)
13:51:52 <cschneid> you can use `MonadReader` and `MonadState` to get rid of lift calls. Why can't you do something similar with `MonadIO`? Why does it only expose the `liftIO` function, which doesn't avoid having to lift.
13:52:15 <carter> bitemyapp: hmatrix does a deep copy each time you do a matrix slice :(
13:52:29 <levi> Woot, byorgey's nyhaskell presentation video is up now.
13:52:37 <byorgey> yay!
13:52:39 <Aetherspawn> cschneid: I suspect because IO isn't a thing that's inside mtl
13:52:47 <Aetherspawn> so it can't do magic to make the functions autolift
13:52:47 <bitemyapp> carter: well that's not okay.
13:52:55 <carter> brb
13:52:55 <carter> yeah
13:52:59 <bitemyapp> yeesh.
13:53:24 <cschneid> Aetherspawn: I figured it might have been that IO doesn't really define an interface the way Reader or State do (get / set / etc...)
13:54:12 <Aetherspawn> that's along the lines of what I was thinking
13:54:41 <Twey> kristof: Sometimes you want to fix the types of things
13:55:02 <kristof> Twey: hmm?
13:55:02 <Twey> Er, but I think those things aren't the same
13:55:30 <kristof> bitemyapp: Why do categorical duals matter to a Haskell programmer?
13:55:30 * hackagebot heist 0.13.0.4 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.0.4 (DougBeardsley)
13:55:31 <Twey> Yes, indeed
13:55:46 <Twey> kristof: (>=>) and (.) are both valid but do different things on, for example, Reader
13:56:52 <Twey> (.) is (>>>) for functions, but (>>>) isn't (>=>) for monads (you have to wrap them in Kleisli, first)
13:56:54 <kristof> Twey: I've been trying to understand the reader monad all day
13:57:12 <kristof> Twey: I'll get it eventually, so don't you worry about that
13:57:32 <Twey> kristof: Reader was just an example of a Monad that is also a function
13:57:39 <bitemyapp> kristof: lenses and prisms are my personal practical examples of why duals can be helpful.
13:58:36 <kristof> bitemyapp: Are monads and comonads categorical duals?
13:59:08 <bitemyapp> kristof: the "co" says yes.
13:59:10 <Twey> kristof: Categories model many aspects of types and programming (… along with everything else :þ), and can be useful to discover new ways of doing things
13:59:23 <mgoszcz2> Hi can someone plase explain to me why some stuff like Functor class is overriden in Data.Functor?
13:59:26 <Twey> Monads and comonads are; I'm not sure whether Monads and Comonads are, strictly speaking
13:59:36 <Twey> But they'd like to be ☺
13:59:43 <kristof> Twey: woah woah woah what was with the case-discrepancy there
13:59:45 <dmwit> mgoszcz2: That doesn't sound right. Maybe you should paste your exact code and error somewhere.
13:59:49 <cads> they're just internal monoids in the category of endofunctors
13:59:50 <kristof> bitemyapp: I'll look more into lenses before I talk to you again
13:59:50 <bitemyapp> kristof: typeclass vs. math.
13:59:55 <cads> ;)
13:59:55 <bitemyapp> kristof: uh, don't.
13:59:56 <Twey> kristof: Haskell Monads aren't quite the same thing as categorical monads
14:00:03 <bitemyapp> kristof: not unless you already know Haskell pretty well.
14:00:13 <kristof> I really don't
14:00:14 <bitemyapp> kristof: or at least understood the typeclassopedia.
14:00:27 <kristof> I'm sure at least the purpose is grokkable?
14:00:35 <cads> it's hard
14:00:38 <bitemyapp> kristof: lenses are eldritch wizardry of the Kmettian Order. Purpose is eminently grokkable.
14:00:38 <Twey> You can probably use Lenses.  There's some nice documentation.
14:00:41 <mgoszcz2> I mean that Functor in Data.Functor has (<$) and not in Prelude
14:00:43 <bitemyapp> kristof: implementation is...aforementioned.
14:00:49 <Twey> Implementation I'm not yet sure about :þ
14:00:55 <bitemyapp> kristof: you can use lenses without really understanding them (I'm an example of this)
14:01:04 <dmwit> mgoszcz2: It's just not exported by Prelude, for historical reasons.
14:01:13 <cads> kristof: I think it's definitely possible to apprehend and use monads without reading and categories
14:01:34 <Twey> mgoszcz2: It's not overridden; there are just more functions on Functors (made up of the existing typeclass and its methods)
14:01:48 <Fernandos> hi
14:01:49 <mescalinum> i have a package ./tests and a package ./foo; why running ./tests/test1.py, which contains 'from foo import *' fails with "No module named 'foo'"? (I have __init__.py both in ./tests, ./foo and .)
14:01:50 <bitemyapp> kristof: best way to learn is to write Haskell code and use typeclasses. Understanding monads in those terms is pretty intuitive.
14:02:00 <cads> it might not even be very helpful to study categories first
14:02:03 <Twey> mescalinum: Wrong channel?
14:02:06 <geekosaur> mescalinum, channel?
14:02:09 <mescalinum> oops sorry wrong window
14:02:16 <bitemyapp> kristof: practically speaking, we're talking about higher order functions and patterns/interfaces that happen to line up with categories in theory.
14:02:17 <kristof> sigh
14:02:19 <Twey> cads: From what I hear, it is somewhat helpful
14:02:24 <kristof> ok
14:02:32 <Twey> Fernandos: Hi
14:02:33 <bitemyapp> kristof: now the cool part is that we can leverage insights from category theory to come up with new ways to combine and compose functions.
14:02:52 <bitemyapp> kristof: you can think of Functor's fmap as a generalization of map from collections to anything that is remotely like a "container"
14:03:06 <mgoszcz2> dmwit: Oh.. Thanks. What are the "Historical reasons" you are speaking about?
14:03:09 <kristof> Right, a computational context
14:03:16 <bitemyapp> kristof: hum, not even that really.
14:03:19 <cads> Twey: I think it is, and probably more so if you're aiming your study towards CS the whole time
14:03:22 <kristof> wuh?
14:03:25 <bitemyapp> kristof: a Functor can be a transparent pass-through container.
14:03:28 <bitemyapp> kristof: of simple data.
14:03:36 <Twey> Aye
14:03:38 <bitemyapp> kristof: fmap is just applying your function to the value (maybe?)
14:03:46 <kristof> right, I understand
14:03:59 <kristof> bitemyapp: By computational context I meant Just a | Nothing
14:04:14 <bitemyapp> kristof: hum. That's Maybe, and that's a Functor but it's also a Monad.
14:04:34 <cads> Twey: maybe a bit harder to get utility from it if you're used to categories as mathematicians use them
14:05:43 <dmwit> mgoszcz2: Haskell98 and Haskell2013 specify exactly what Prelude must export. Perhaps a future specification will include more things.
14:06:02 <dmwit> uh
14:06:06 <dmwit> Haskell2010, not 2013
14:06:12 <dmwit> (Wow, has it been that long?)
14:06:12 <Twey> mgoszcz2: Everything in the Prelude gets automatically imported into new programs, which means we have to be especially careful about breaking compatibility with it.
14:06:22 <Twey> dmwit: Haskell2014 this year, apparently
14:06:48 <dmwit> Twey: I've heard this song before. =)
14:06:57 <Twey> Aye ;)
14:07:44 <b80905> Is there a function in the standard library that computes the largest element of a given list?
14:07:47 <bitemyapp> kristof: I would seriously hesitate to call a sum-type a computational context.
14:07:54 <Twey> b80905: Data.List.maximum
14:07:57 <bitemyapp> kristof: which is what Maybe is, strictly speaking.
14:08:03 <Fernandos> How's the progress on the ghc compiler? Did it switch to LLVM?
14:08:07 <bitemyapp> b80905: Ord a => [a] -> a
14:08:22 <Twey> Data.List.maximumBy for a more flexible concept of ‘largest’
14:08:22 <notdan> Fernandos: progress on what?
14:08:29 <notdan> Fernandos: there is an LLVM backend
14:08:30 <dmwit> Fernandos: GHC has an option to use LLVM on the backend.
14:08:30 <b80905> Twey: thank you
14:08:33 <Twey> Fernandos: We have LLVM support; I think it's not default yet
14:08:37 <mgoszcz2> Thanks dwmit & Twey I was windering why that was.
14:08:55 <Fernandos> dmwit: interesting, last time I checked it wasn't there yet. cool, that's good news.
14:09:02 <Twey> mgoszcz2: If you add a new name that somebody has used in one of their modules, their program breaks, and they get upset.  ☺
14:09:41 <Twey> Whereas if you add a new name to a different module, it only breaks if they've been silly and imported everything unqualified, and we get to laugh at them
14:09:44 <mgoszcz2> Twey: I can use the qualified import thingy right?
14:10:00 <Twey> Yes, or you can use explicit import lists
14:10:18 <Twey> But I'd only worry about it if you're writing a program with a long shelf-life that you don't expect to be maintaining
14:10:27 <Fernandos> notdan: In regards of performance, I mean there are quite a few HPC Companies that use Haskell and I thought that they have given back feedback to the community to help improve the compiler performance.
14:10:32 * hackagebot discrete-space-map 0.0.2 - A discrete space map.  http://hackage.haskell.org/package/discrete-space-map-0.0.2 (SjoerdVisscher)
14:10:35 <Twey> Things don't really change that often any more
14:11:14 <Twey> Fernandos: We now have support for repa and the like, as well as the LLVM backend, which I understand is rather fast
14:11:39 <Fernandos> repa?
14:11:49 <Twey> The async IO subsystem got an overhaul this year, too, making it nice and speedy
14:11:54 <mgoszcz2> Thanks
14:12:33 <bitemyapp> Twey: that's the part I'm particularly looking forward to.
14:14:02 <adelbertc> so i have been told to be wary of "cabal init" not being aware of "cabal sandbox" - looking for more information on this
14:14:09 <Fernandos> Twey: I too believe that async IO is a big thing, basically everything async should be the goal, curious how far the progress is on that, if you know. Async DNS ie. has been a pain in C for a long time and still isn't an easy matter..
14:14:58 <fooz> is there no hashmap mapM?
14:15:14 <fooz> is there some way to lift the existing HashMap.map into a monad?
14:15:33 * hackagebot holy-project 0.1.0.1 - Start your Haskell project with cabal, git and tests.  http://hackage.haskell.org/package/holy-project-0.1.0.1 (yogsototh)
14:15:35 <bitemyapp> kristof: http://jozefg.bitbucket.org/posts/2013-10-14-please-dont-learn-cat-theory.html
14:15:47 <peddie> Fernandos: http://haskell.cs.yale.edu/wp-content/uploads/2013/08/hask035-voellmy.pdf
14:16:20 <bitemyapp> kristof: the category theory is fun, but if you're not writing libraries for other people to use, probably not that big of a deal (and even then)
14:16:49 <Fernandos> peddie: checkin
14:16:56 <pera> This is weird: why running ghci -XNoMonomorphismRestriction works but using :set -XNoMonomorphismRestriction don't? :/
14:17:17 <pera> (in ghci 7.6.3)
14:17:22 <Fernandos> fooz: probably interesting for you to know http://preshing.com/20130107/this-hash-table-is-faster-than-a-judy-array/
14:17:42 <supki> fooz: HashMap is Traversable, so Data.Traversable.mapM should work
14:19:08 <Fernandos> fooz: just in case, A hashmap is slower than a correct array implementation, because a hashmap builds on array, however this is not universally true as you can see.
14:19:09 <bitemyapp> kristof: the real point as a user is that the designers of the libraries and the language are using foundations that are actually consistent and make sense.
14:19:22 <dmwit> pera: WFM
14:19:34 <dmwit> pera: Can you give some more details about how to reproduce whatever problem you're having?
14:20:03 <pera> dmwit: yeah... uhm give me a second
14:20:06 <kristof> bitemyapp: sure, but the category theory stuff is still fun
14:20:07 <fooz> Fernandos: i'm not really concerned about performance at this point.. i'm still very new to haskell
14:20:14 <bitemyapp> kristof: well. it is for me :)
14:20:29 <fooz> Fernandos: i'm just trying to map over the values inside the either monad with a function that might give "Left" ..
14:20:45 <fooz> supki: I'll check that out-- sounds like the right solution! thank you.
14:20:50 <bitemyapp> kristof: just want to reinforce the point that it's okay to just hack around. I tell my students that if it really worries them, they can mentally replace things like Monoid with "Appendable"
14:20:54 <kristof> bitemyapp: I like mathematics! Not afraid of it.
14:21:47 <fooz> supki: is there any difference between Data.Traversable.mapM and Control.Monad.mapM ?
14:21:58 <bitemyapp> kristof: sure, but my goal is to make people aware of their options, proglang wise, so the category theory is interesting but not strictly critical.
14:22:20 <supki> fooz: the latter is only for lists
14:22:30 <Fernandos> fooz: it's not so important that you are concerned about performance, really, it's even contra-productive. But you should definitely be aware of what performance there is to improve or not, even you don't use it today, it'll be useful in the future.
14:22:37 <fooz> supki: ah ah ah! i see
14:22:52 <supki> fooz: Data.Traversable.mapM is the same as Control.Monad.mapM for lists :)
14:23:02 <supki> but also works for a bunch of other things
14:23:07 <fooz> Fernandos: ok, i'll keep judy arrays in mind and look them up in more detail sometime :)
14:23:36 <fooz> supki: right, it's for the instances of the class, versus just lists
14:23:36 <Fernandos> fooz: that's a C library, btw.. not haskell
14:23:43 <bitemyapp> kristof: part of the reason I like the category theory and algebra behind it is that you can reason about and transform functions in terms of the type signatures.
14:23:44 <fooz> supki: totally missed that on first reading; thank you
14:23:49 <fooz> Fernandos: it's the algorithm that counts!
14:23:50 <kristof> bitemyapp: Sometimes I wish things were slightly more conrete in Haskell, though. Combinable instead of Monoid, for instance.
14:25:06 <bitemyapp> kristof: Appendable/Combinable I'd say.
14:25:26 <bitemyapp> kristof: the imprecision is partly why they just use the mathematical terms, combinable could be like 4 or 5 different typeclasses.
14:29:13 <Fernandos> fooz: Totally right! You have only very few ways to actually improve performance, caching in all layers being the most effective one.
14:30:00 <pera> dmwit: ok, sorry for the delay, so if I run ghci with -XNoMonomorphismRestriction I can do something like let f2 = \x -> show x
14:30:31 <pera> But, if I put :set -XNoMonomorphismRestriction in my .ghci it doesn't work
14:30:53 <dmwit> Are you sure your .ghci is being executed?
14:30:57 <kristof> bitemyapp: Right, but it's certainly better than monoid. And anyone want to write papers on the subject of Appendable/Combinable merely needs to show it's a monoid and draw conclusions from that using category theory, and yet actual programmers don't have to parse the word
14:31:08 <pera> dmwit: yes, my prompt is changed correctly
14:31:10 <shiona> is there a more specific function that does the same as "for_ (Maybe 1) print"?
14:31:18 <dmwit> Still WFM
14:31:31 <kristof> Minor complaint, though, nothing serious. Monoids aren't difficult subjects anyway.
14:31:39 <shiona> e.g. one that wouldn't require me to import foldable just for that one thing
14:31:44 <shachaf> monoids are so easy
14:31:45 <dmwit> In fact, let f2 = \x -> show x just WFM even without NoMonomorphismRestriction.
14:31:57 <dmwit> So perhaps you have some other extensions enabled/disabled.
14:32:00 <pera> dmwit: really?
14:32:10 <pera> that's strange
14:32:20 <Fernandos> fooz: You can lookup One-Pass Algorithms, that's what's most effective in trading, because it's the most efficient way to answer a problem withing good time, memory and power contraints.
14:32:26 <bitemyapp> kristof: if you really want to bake your noodle, try your hand at loeb and moeb. (latter being a generalization to Functor) :)
14:33:06 <dmwit> pera: Yes, presumably because of extended defaulting.
14:33:13 <pera> but http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:33:20 <pera> it shouldn't work...
14:33:40 <fooz> Fernandos: you sound like a bot
14:33:59 <fooz> supki: thanks for your help; signing off
14:34:23 <pera> oh.. wait, what version of ghci are you running dmwit ?
14:34:35 * Fernandos hahah I sound like a bot :P
14:35:09 <dmwit> pera: The Glorious Glasgow Haskell Compilation System, version 7.6.3
14:35:11 <shachaf> "works" and "doesn't work" can mean a lot of things
14:35:26 <dmwit> pera: And again: extended defaulting.
14:35:38 <shachaf> For example, "works" can mean "it type-checked, and got the type () -> String"
14:35:51 <pera> brb
14:37:17 <d3lxa> anyone knows more about web-dev continuation-based like in this one? http://arclanguage.org/item?id=8842 any lib, paper I could read?
14:38:02 <apples> you might be interested in "Inverting back the inversion of control", if you haven't read it: http://pagesperso-systeme.lip6.fr/Christian.Queinnec/PDF/www.pdf
14:40:15 <d3lxa> apples: thank you :)
14:41:31 <jle`> oh a stack overflow. time to add seq in random places until it works
14:44:34 <Fernandos> Anyone have experience here with manycore architectures and Haskell?
14:44:44 <Fylwind> what does WDP stand for?
14:45:36 * hackagebot hexpat 0.20.6 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.20.6 (StephenBlackheath)
14:46:15 <Fernandos> Fylwind:  http://www.urbandictionary.com/define.php?term=wdp
14:46:20 <Fernandos> :P
14:50:19 <Fernandos> peddie: hmm.. have checked that paper now. But it appears like it's not suited for manycore architectures that start at >100 cores. Like this or Kalray, Efficieon etc. http://users.crhc.illinois.edu/djohns53/pub/rigel-ieee-micro-2011.pdf
14:51:22 <peddie> Fernandos: I don't really know many details about the I/O manager or those architectures.  does GHC run on those architectures to begin with?  I don't recall seeing any plots with >64 cores in any papers about GHC, so maybe it's just that nobody has the hardware
14:53:08 <dcoutts> Fernandos: some, we had a project a few years ago to port ghc to the sparc manycore arches T1,T2 etc
14:53:58 <dcoutts> Fernandos: the main issue limiting scaling for high core counts is to do with the shared heap + gc
14:54:09 <Fernandos> I don't know the price, but a 1024 core 230 GFLOPS single-chip CPU is available since 2012 and I know of many others with less cores, that were available even much earlier
14:54:11 <jle`> hm. anyone know how i can fix this arrow type error Expected Type [a], Actual Type [Cat b a] ?
14:54:28 <jle`> i tried sequenceA but then i couldn't get it to type check either
14:54:40 <identity> jle`: maybe post code?
14:54:40 <dcoutts> Fernandos: right the sparc T1 & T2 are rather older than 2012
14:55:26 <dcoutts> Fernandos: you'll find some DPH papers with benchmarks on a T2 going up to 32-64 cores
14:55:32 <Fernandos> dcoutts: I had access to a Sun Niagara T1 too, but they switched the architecture to x86, due to cost.
14:55:38 * hackagebot adjunctions 4.0.1 - Adjunctions and representable functors  http://hackage.haskell.org/package/adjunctions-4.0.1 (EdwardKmett)
14:58:26 <Fernandos> dcoutts: yup, the paper peddie has sent was in that range too. Tilera ie. has also much more cores. It's not that exotic, just not known so much. :/
15:00:34 <Fylwind> Fernandos: so is WDP in the GHC manual some kind of in-joke? :)
15:00:38 * hackagebot kan-extensions 4.0.1 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.0.1 (EdwardKmett)
15:01:31 <mdittmer> Anyone know why a "Data.Binary.Get.Get a" invoked within a call to "withBinaryFile" would cause  "hGetBufSome: illegal operation (handle is closed)"?
15:01:31 <Fernandos> Fylwind: hahah :) No, I didn't know what it means, but was sure that there is meaning for every three letter word on urbandictionary
15:02:22 <Fylwind> Fernandos: I assumed WDP is an acronym for one of the GHC devs
15:03:01 <Fernandos> dcoutts: btw. I'm getting this for my 7y old cousin http://www.adapteva.com/ that means, he'll have more cores than the rest of us. As said, even kids have >=64 cores, time to catch up for ghc
15:03:41 <cads> hmm
15:04:10 <Fernandos> crazy... Scalable to 1000’s of cores and TFLOPS of performance on a single chip
15:04:13 <cads> how would you guys model tic-tac-toe's game tree?
15:04:30 <cads> I'd like to output it as a dot and render it with graphvis
15:05:18 <peddie> Fernandos: that parallela board seems like it might be a better fit for something akin to the 'accelerate' library, and run haskell natively on the ARM, rather than trying to rearrange the GHC runtime for many small cores
15:05:40 <cads> oh, hey: http://hackage.haskell.org/package/game-tree
15:06:29 <Fernandos> peddie: Could you please elaborate? Made me curious, what you mean..
15:06:53 <peddie> @hackage accelerate
15:06:53 <lambdabot> http://hackage.haskell.org/package/accelerate
15:07:39 <Fernandos> peddie: that's essentially a DSL, right?
15:08:06 <peddie> I suppose so
15:08:07 <JakeE> accelerate is preety neat. I read a bit about it. I'm preety eager to put it to use
15:08:29 <Fernandos> Array Oriented Language ontop of Haskell, targetting OpenCL, hmm
15:08:41 <benmachine> dleedev: yes
15:08:55 <ReinH> ofc then you're restricted to the problems that accelerate can solve
15:09:02 <JakeE> targets cuda I thought?
15:09:09 <ReinH> which is necessarily a subset of the problems that Haskell can solve
15:09:22 <ReinH> JakeE: originally targetted cuda, there are multiple backends now. Not sure how far opencl suppor tis
15:09:28 <ReinH> iirn
15:09:30 <ReinH> iinm*
15:09:40 <ReinH> my space bar does not cooperate. :(
15:10:19 <Fernandos> CUDA and the StreamSDK are symptoms of the need for homogenous manycore systems in systems where the CPU and GPU are isolated, but are meant to be treated equally..
15:10:32 <JakeE> I'm trying to write a monad (a warpper around a state monad) that has a special fail function but it wont type check for some reason: http://lpaste.net/edit/98549
15:11:04 <JakeE> also it fails within GHCI but lpaste seems to have no issues with it
15:12:36 <jrmithdobbs> JakeE: what is getFailValue's type?
15:12:38 <Fernandos> peddi dcoutts you're right though, unless ghc improves, it looks like there is no other way than using accelerate
15:12:46 <JakeE> String -> a
15:13:17 <JakeE> er... actully ZipperTree a => String -> a
15:13:19 <jrmithdobbs> JakeE: so any more questions?
15:13:31 <jrmithdobbs> :t fail
15:13:32 <lambdabot> Monad m => String -> m a
15:13:36 <jrmithdobbs> fail takes String not a
15:14:03 <peddie> Fernandos: feel free to start making the runtime less centralized
15:14:07 <indomitus> how do you select the 3rd item in a tuple?
15:14:35 <monoidal> JakeE: this is bit subtle. fail needs a function polymorphic in a, with no context, and adding the context to the instance does not help
15:14:40 <JakeE> but so does getFailValue. type of (return . getFailValue) should be Monad m, ZipperTree a => String -> m a
15:15:29 <JakeE> monoidal: is there a way to get the functionality which I desire? that is to have fail simply call a fail function from another type class?
15:15:37 <Fernandos> peddie: I'm evaluating options, but what do you mean by less centralized? Do you mean optimizing the compiler to add linear scaling per CPU? I can't that's a though problem.
15:18:13 <mdittmer> Any ideas on cause of "hGetBufSome: illegal operation (handle is closed)" here? http://lpaste.net/98551
15:18:21 <peddie> Fernandos: I think it is a pretty tough problem
15:19:39 <Fernandos> If you trade, I'd bet on NV and Intel loosing the manycore market. See: Geforce GTX 780 Ti 5.345GFLOPS@250W vs E4KG4 5632@70W
15:19:59 <Fernandos> ^ *5632GFLOPS
15:21:40 <BassSultan> if name = "Some Guy" , can someone pls tell me what (take 3 .(let no name= name; in no))"NO") is? :)
15:21:58 <ReinH> BassSultan: can't you tell yourself?
15:22:09 <weweqwqw> How does hmatrix show the matrix on multiple lines?  I'm looking at the instance and still failing to understand.
15:22:23 <BassSultan> ReinH: i dont know what the "No" in the end is supposed to be/do
15:22:44 <ReinH> BassSultan: well, name in the let would shadow the outer name, so it doesn't matter what name was before
15:23:04 <ReinH> BassSultan: but you can try it in ghci and see what you come up with
15:23:12 <weweqwqw> The instance is defined here: https://github.com/albertoruiz/hmatrix/blob/master/lib/Data/Packed/Matrix.hs
15:23:50 <jrmithdobbs> someone needs to write a document "how to convince your coworkers they really want to use haskell, not go"
15:23:50 <monoidal> JakeE: sorry, got disconnected
15:23:50 <monoidal> JakeE: to see why your instance does not type check, substitute t = (), or any fixed type
15:23:50 <jrmithdobbs> someone needs to write a document "how to convince your coworkers they really want to use haskell, not go" ;p
15:23:50 <monoidal> JakeE: so you have instance Monad (Zipper ()) where fail = return . getFailValue
15:23:51 <JakeE> monoidal: Even though I wouldn't get gracful failiure on pattern matching could I just make a 'tFail' function such that 'tFail = return . getFailValue'? that way the context would be provided in the functions that used tFail?
15:24:05 <BassSultan> ReinH: that doesn't help me because we have to evaluate it on paper for an exam. i get nearly the whole statement but that "No" at the end.. why would it be there? just to confuse ?
15:24:23 <ReinH> BassSultan: what is let no name = name in no?
15:24:25 <ReinH> what is its type?
15:25:12 <ReinH> You can ask ghci for that or lambdabot
15:25:16 <BassSultan> ReinH: a string?
15:25:43 <monoidal> JakeE: yes, you can define tFail that way. in general, Monad's 'fail' is often considered harmful
15:26:02 <JakeE> cool; that will work. Thanks!
15:26:24 <pavonia> BassSultan: Do you know what the "let ... in ..." syntax does?
15:26:48 <BassSultan> pavonia: apparently not, or you wouldn't ask me..?
15:27:24 <monoidal> JakeE: regarding your code, maybe this will clear up: the constraint in ZipperTree t => Monad (Zipper t) limits the state of your monad to zipper trees; it limits 't' in 'State t a'
15:27:57 <monoidal> JakeE: while to use getFailValue, you need to limit 'a', however, this is not allowed by the type signature of fail
15:27:58 <JakeE> well that is actully what I wanted to do. I only what this monad to work on ZipperTree trees
15:28:14 <pavonia> BassSultan: http://learnyouahaskell.com/syntax-in-functions#let-it-be
15:28:28 <monoidal> JakeE: my advice is to ignore fail and write tFail
15:28:30 <ReinH> pavonia: was just looking that up :p
15:29:14 <JakeE> monoidal: cool; that will work just fine I think. I can't think why I would want pattern matching faliure to invoke fail anyhow
15:31:35 <mekeor> just out of curiosity: most programming languages have main-functions of type "main :: [String] -> IO ()" (the argument being the command-line arguments). why is it that haskell has "main :: IO ()" ?
15:32:07 <jrmithdobbs> monoidal: is there a case to use fail other than parsers that you 100% know are expecting it? i've not seen it yet
15:32:13 <weweqwqw> Ah, got it, nevermind.
15:32:19 <ReinH> mekeor: because it doesn't presume that the input is command line args
15:32:19 <pavonia> mekeor: I think it even has main :: IO a
15:32:41 <ReinH> it gives you a way to perform IO to get them if you want
15:32:56 <BassSultan> that still doesn't help me to see why that "No" at the end of (take 3 .(let no name= name; in no))"NO" gets taken but if i change the name = name to name = "some stuff" its not..
15:33:16 <monoidal> jrmithdobbs: I don't see how in parsers fail's behavior (on pattern match failure) could be helpful
15:33:25 <ReinH> BassSultan: again, what is the type of `let no name = name in no'?
15:33:47 <BassSultan> ReinH: i can only say what i said before. string i guess?
15:33:53 <monoidal> jrmithdobbs: (well, ok, there might be, but I always use case in such situations.)
15:33:58 <jrmithdobbs> monoidal: it's not except that that's how they expect you to fail a parse ;p
15:33:59 <ReinH> BassSultan: Nope. Why don't open up ghci and use :t to ask
15:34:35 <mekeor> ReinH: hm, sounds clever
15:34:40 <mekeor> pavonia: oh, right
15:34:40 <monoidal> jrmithdobbs: the function "fail", by itself, is not that bad. What is bad is its placement in the Monad class and its firing during pattern match failure
15:34:57 <mekeor> @type exitWith
15:34:57 <lambdabot> Not in scope: `exitWith'
15:34:58 <BassSultan> ReinH: so it says a -> String
15:35:00 <ReinH> BassSultan: you can also use :t here in chat to ask lambdabot
15:35:09 <ReinH> :t let no name = name in no
15:35:09 <lambdabot> t -> t
15:35:21 <BassSultan> :t let no name = name in no
15:35:22 <lambdabot> t -> t
15:35:25 <ReinH> BassSultan: the fully generalized type is a -> a (or t -> t, it doesn't matter which letter you pick)
15:35:38 <ReinH> BassSultan: what functions do you know of type a -> a?
15:35:56 <BassSultan> infinitely many?
15:35:58 <JakeE> monoidal: should type of tFail be ZipperTree a => String -> Zipper a ()? I was thinking that it should be ZipperTree a => String -> Zipper a b but I can't figure out how to implement it
15:36:02 <ReinH> BassSultan: sure, but maybe we can get one for free
15:36:07 <ReinH> @djinn a -> a
15:36:07 <lambdabot> f a = a
15:36:13 <ReinH> what function does that look like?
15:36:23 <jrmithdobbs> heh
15:36:37 <BassSultan> dunno, surprise me? :)
15:36:54 <jrmithdobbs> :t id
15:36:54 <lambdabot> a -> a
15:36:59 <ReinH> @src id
15:36:59 <lambdabot> id x = x
15:37:03 <ReinH> what about id?
15:37:31 <pavonia> BassSultan: Infinitely many? Please name two different functions of that type
15:37:32 <monoidal> JakeE: you can't create an arbitrary value of type "b" out of thin air (unless you use undefined in some way)
15:37:57 <BassSultan> any function that takes a certain type and gives something back that has the same type would fulfill this criteria right?
15:38:06 <ReinH> BassSultan: right, but you don't know what type it is
15:38:12 <ReinH> so you can't make any assumptions about what possible values it takes
15:38:26 <ReinH> the only value you can guarantee to inhabit that type is the one you're given
15:38:41 <ReinH> so any function a -> a is the same thing as id
15:38:49 <ReinH> more to the point
15:38:55 <ReinH> BassSultan: is there any difference other than names between (let no name = name) and (let id x = x)?
15:38:55 <merijn> ReinH: Or "undefined" or "const undefined"!
15:39:03 <ReinH> merijn: pesky bottom :)
15:39:05 <JakeE> so what should the type be? I want it to have the same type as fail right?
15:39:31 <BassSultan> not really i guess
15:39:42 <ReinH> BassSultan: so the thing inside those parens is id
15:39:42 <monoidal> JakeE: depends on what you want to do with it
15:39:53 <ReinH> (let no name = name) = id
15:40:02 <ReinH> so we have: id "NO"
15:40:10 <ReinH> and what is `id "NO"'?
15:40:15 <ReinH> > id "NO"
15:40:16 <lambdabot>  "NO"
15:40:32 <ReinH> so: (let no name = name in no) "NO" = "NO"
15:40:34 <augur> huh.
15:40:42 <augur> ordinals are not linearly ordered? interesting
15:41:53 <JakeE> monoidal: basiclly this system is for genericly representing trees. the zipper for these trees allow me to move though them and replace parts of them. I want to allow going to a 'fail value' when replacing a part of it dosn't meet some constraint. For instance if you had an expression as an AST and you were preforming crossover in a genetic programing context not all crossovers are valid if the expression is typed. thus we would want to know that a certain c
15:41:53 <JakeE> ross over fails.
15:42:13 <BassSultan> (take 3 .(let no name= "Max Blafoo"; in no))"NO" returns Max for the same reasons u just explained right?
15:42:27 <ReinH> BassSultan: yes
15:42:36 <ReinH> no name = "Max Blafoo"
15:42:37 <pera> dmilith: I think I found the problem, it seems I need to redefine the function after :set -> http://lpaste.net/98553
15:42:37 <ReinH> @src const
15:42:37 <lambdabot> const x _ = x
15:42:40 <monoidal> JakeE: perhaps your monad could be not just State, but State composed with Maybe
15:42:42 <JakeE> monoidal: so tFail should be able to be called anywhere and not effect the return type of the function it is in
15:42:52 <ReinH> BassSultan: that function takes a name and then throws it away and provides "Max Blafoo"
15:43:02 <ReinH> BassSultan: and then you take the first 3 of that string
15:43:12 <pera> sorry, dmwit
15:43:19 <dmilith> ^^
15:43:24 <dmilith> that's good! ;]
15:43:25 <dmilith> i suppose
15:43:27 <monoidal> JakeE: (where Nothing would represent an error)
15:43:27 <ReinH> (or the whole string if less than 3 long)
15:43:29 <JakeE> monoidal: except I want more than 'Nothing' I want a string that tells me what went wrong
15:43:33 <pera> :)
15:43:46 <monoidal> JakeE: well, ErrorT then
15:43:53 <monoidal> (or EitherT? I don't remember)
15:44:11 <BassSultan> ReinH: and since name is defined in my code somewhere with (name = "Max Blafoo") and if i change it back to (take 3 .(let no name= name; in no))"NO", then it provides "No" why is that?
15:44:32 <monoidal> augur: ordinals are linearly ordered (unless you work without AC, then I'm not completely sure)
15:44:53 <JakeE> monoidal: thanks! I'll look into it!
15:45:32 <augur> monoidal: bob harper said they not in his HoTT lectures, but maybe i misunderstood
15:45:35 <monoidal> JakeE: in short, your monad would be Zipper t a = Zipper (t -> Either String (t,a)) or something similar
15:45:52 <monoidal> augur: oh, then almost certainly no AC
15:47:06 <ReinH> BassSultan: because in (let no name = name), `name' is a bound variable.
15:47:44 <ReinH> BassSultan: it takes on the value of the argument passed to `no'
15:47:54 <pavonia> BassSultan: Your definition of name = "Max Blafoo" is never used
15:48:13 <BassSultan> ReinH: and that value (since nothing but name is found for name) should be nothing at all?
15:48:24 <ReinH> BassSultan: that value is what is passed to the function
15:48:29 <ReinH> you do pass something to the function
15:48:32 <JakeE> monoidal: I'd like to do this with ErrorT and StateT. could I make my definition "Zipper t a = Zipper (ErrorT String (StateT t a) a)"? or somthing like that?
15:49:07 <ReinH> > (let f x = x in f) "Foo"
15:49:08 <lambdabot>  "Foo"
15:49:19 <shachaf> @unmtl StateT t (Either String) a
15:49:19 <lambdabot> t -> (Either String) (a, t)
15:49:21 <monoidal> @unmtl ErrorT String (State t a)
15:49:21 <lambdabot> Plugin `unmtl' failed with: `ErrorT String (State t a)' is not applied to enough arguments, giving `/\A. (State t a) (Either String A)'
15:49:28 <BassSultan> ok and that is exactly my question :) why is it "Foo"?
15:49:34 <monoidal> @unmtl ErrorT String (State t a) a
15:49:34 <lambdabot> (State t a) (Either String a)
15:49:40 <mgoszcz2> @run 2 + 2
15:49:41 <lambdabot>  4
15:49:44 <monoidal> @unmtl ErrorT String (State t) a
15:49:44 <lambdabot> (State t) (Either String a)
15:49:49 <shachaf> The type monoidal gave is StateT of Either
15:49:56 <JakeE> so it's the same thing basiclly?
15:50:08 <ReinH> BassSultan: why is this foo?
15:50:09 <ReinH> > let {x = "bar"; f x = x} in f "foo"
15:50:11 <lambdabot>  "foo"
15:50:16 <shachaf> Wjat
15:50:21 <shachaf> What's the same thing?
15:50:46 <JakeE> the type I wanted and the type he recomended; they boil down to the same thing
15:50:59 <BassSultan> i do not have the slightest clue, pls enlighten me
15:51:12 <ReinH> BassSultan: because in f x = x, x takes on the value passed to f
15:51:23 <ReinH> and that is "foo"
15:51:25 <ReinH> not "bar"
15:51:31 <BassSultan> yes, again.. why?
15:51:47 <monoidal> JakeE: StateT s (Either String) a is a type equivalent to s -> Either String (a,s)
15:52:08 <JakeE> monoidal: thanks; hopefully this works!
15:52:33 <monoidal> JakeE: but whether you really need that type, this depends on your application which I don't claim to understand
15:52:45 <ReinH> BassSultan: you have two things named `x'. The `x' bound as a part of the definition of `f' supercedes the `x' in the outer scope.
15:52:57 <JakeE> monidal: if it works and does what I want I'll tell you
15:53:18 <monoidal> good night
15:53:40 <ReinH> BassSultan: this is known as "shadowing" and is warned against because it causes confusions such as there.
15:53:48 <ReinH> *these
15:53:59 <BassSultan> ReinH: and the scope is apparently not all the stuff in let .. in?
15:54:39 <BassSultan> ReinH: thanks for your patience btw :)
15:54:47 <ReinH> BassSultan: there are two scopes
15:54:51 <ReinH> the scope defined by x
15:54:55 <ReinH> and the outer scope defined by the let
15:54:58 <ReinH> er, defined by `f'
15:55:16 <ReinH> BassSultan: when resolving names in an application of `f', the scope of `f' is checked before any outer scopes
15:55:52 <ReinH> so the `x' bound in `f x = x' is used before the x bound in `x = "bar"'
15:56:41 <BassSultan> ok but the x is not foo and bar would still be "nearer" to f x = x than foo is?
15:56:55 <ReinH> BassSultan: x becomes "foo" when you say `f "foo"'
15:57:03 <ReinH> within the scope of that applicatino of `f'
15:58:29 <BassSultan> but there are braces around it, shouldnt that prevent it from directly taking foo? i think thats where my problem in understanding this lies..
15:59:11 <ReinH> Let's look at it again.
15:59:17 <ReinH> > let {x = "bar"; f x = x} in f "foo"
15:59:18 <lambdabot>  "foo"
15:59:22 <ReinH> within the braces we define f
15:59:27 <jle`> BassSultan: you can think of f x = x as syntactic sugar
15:59:28 <ReinH> outside of the braces we apply f
15:59:33 <jle`> BassSultan: for f = \x -> x
15:59:38 <jle`> f = (\x -> x)
15:59:46 <jle`> (\x -> x) is a function that, when called with a value, returns the value
15:59:53 <jle`> so later on you say f "foo"
15:59:55 <jle`> you are really saying
15:59:57 <jle`> (\x -> x) "foo"
16:00:32 <BassSultan> ah ok and why exactly is the bar out of scope? because of the ; ?
16:00:42 <jle`> remember that all avaluation in haskell can be seen as substitution
16:00:45 <ReinH> BassSultan: no, `x = "bar"' is inside the scope of the let
16:00:50 <ReinH> BassSultan: here's how the scope works
16:00:58 <ReinH> (top level scope (let (application of f)))
16:01:03 <jle`> BassSultan: the bar is in scope, but it's not in scope in (\x -> x), because the x refers to the "closest" x
16:01:07 <ReinH> inside the application of f, x is the value applied to f
16:01:20 <jle`> remember that all Haskell code can be seen as substitution...so
16:01:22 <ReinH> BassSultan: we don't look outside the application of f to find the value of `x'
16:01:23 <jle`> (\x -> x) "foo"
16:01:28 <jle`> reduces to
16:01:30 <jle`> "foo"
16:01:33 <BassSultan> weird
16:01:34 <jle`> locally
16:01:34 <ReinH> BassSultan: on the other hand:
16:01:46 <ReinH> > let {x = "bar"; f y = y} in f "foo"
16:01:47 <lambdabot>  "foo"
16:01:54 <jle`> (\x -> x + 1) 2, for example, reduces to 2 + 1
16:01:56 <jle`> right?
16:01:56 <BassSultan> but i think it makes more sense now, though i could never explain that to someone :P
16:02:00 <ReinH> BassSultan: this is how name resolution works in every langauge with similar scoping, which is most of them
16:02:31 <jle`> the x in \x can be anything....actually you can imagine ghc making it any arbitrary name
16:02:36 <ReinH> BassSultan: it's obvious that y is not x right?
16:02:47 <jle`> (\x -> x) is parsed as (\x_1234 -> x_1234)
16:02:56 <BassSultan> yeah
16:02:58 <ReinH> BassSultan: what is less obvious but still true is that the x defined in `f x = x' is not the SAME x as defined in the outer scope of the let
16:03:00 <jle`> this is called...alpha substitution?
16:03:16 <ReinH> BassSultan: they share the same name but refer to different things
16:03:20 <trillioneyes> GHC used to rename literally every variable in every expression it touched, every time it did something
16:03:30 <trillioneyes> (This was like 10 years ago or longer)
16:03:45 <ReinH> BassSultan: so name resolution starts with the innermost scope, the `f x = x' scope
16:03:50 <ReinH> and then proceeds until it finds a matching name
16:04:03 <ReinH> since it finds a matching name in the `f x = x' scope it does not need to check the outer let scope
16:04:11 <ReinH> so it never gets to `x = "bar"'
16:04:48 <jrmithdobbs> so i said it fliappntly earlier, but I'm kind of serious, is there some kind of advocacy draft or something somewhere that could be used to try and convince people we do not want to pursue go for projects but haskell? ;p
16:05:07 <jrmithdobbs> for values of "we" == "coworkers"
16:05:10 <BassSultan> ok thx! i might just remember that tomorrow :)
16:05:19 <ReinH> BassSultan: I can show you similar examples in most langauges. Ruby: x = "bar"; def f(x) = x; end; f "foo" # => "foo"
16:05:52 <apples> jrmithdobbs: if you find one, please let me know -- that would be handy to have
16:05:56 <BassSultan> ReinH: maybe some other time ;) i think im gonna need some sleep soon
16:06:14 <ReinH> BassSultan: I just said that I could, not that I intended to ;)
16:06:50 <dmj`> does haskell have any analytics packages similar to numpy or scipy?
16:06:53 <jrmithdobbs> ReinH: o c'mon at least make the ruby example funny by abusing lambda closures or something
16:07:06 <BassSultan> ReinH: that wouldve been weird.. "Im going to show you some examples, if you want it or not!"
16:07:54 <ReinH> jrmithdobbs: fine. x = "bar"; f = -> x { x }; f "foo" # => "foo"
16:08:17 <ReinH> er
16:08:21 <ReinH> that would need to be f["foo"]
16:08:22 <ReinH> fucking Ruby
16:08:25 <jrmithdobbs> ReinH: i forget about the new lambda syntax half the time
16:08:53 <ReinH> probably for the best
16:09:02 <ReinH> if I'm tempted to use it I smack myself and write Haskell instead. ;)
16:10:37 <jrmithdobbs> ReinH: ya, i had to demo something earlier and the "complete enough to demo" version is ruby and i'd forgotten half the tradeoffs/limitations i'd settled with and started trying to demo the haskell version ;p
16:10:53 <jrmithdobbs> ReinH: whoops.
16:11:04 <jmcarthur> ReinH: Ruby is a fine language for the right use cases... like... umm... when your boss mandates that you use Ruby... or something...
16:11:38 <ReinH> :D
16:11:43 <startling> any f [] = False?? why?
16:11:55 <ReinH> startling: because of the monoid instance
16:12:08 <startling> ReinH, I don't follow.
16:12:12 <alpounet> startling: because no element in the list matched the predicate
16:12:12 <JakeE> startling: it tends to make sense in most contexts
16:12:17 <ReinH> startling: well mayb eyou should look at the monoid instance then
16:12:26 <alpounet> (because there wasn't any element, but that's "a detail")
16:12:36 <startling> JakeE: yeah, I guess so.
16:12:47 <ReinH> startling: any is a boolean monoid under disjunction
16:12:49 <startling> ReinH: I don't see what Any has to do with any other than having the same name.
16:13:09 <ReinH> startling: they are isomorphic.
16:13:15 <ReinH> <[Bool], False, (||)>
16:13:20 <JakeE> startling: 'any' asks "is there anything in this list that is true" which is for sure false if there is nothing in the list sense we can conclude from "there is nothing in this list" that "there is nothing in this list which is true"
16:13:27 <ReinH> > foldMap Any []
16:13:27 <startling> > all (not . const True) []
16:13:28 <lambdabot>  Any {getAny = False}
16:13:28 <lambdabot>  True
16:13:32 <ReinH> > any []
16:13:33 <lambdabot>  Couldn't match expected type `a0 -> GHC.Types.Bool'
16:13:33 <lambdabot>              with actual type `[a1]'
16:13:35 <startling> I guess I should use all . not
16:13:49 <startling> JakeE, I know. it's just a weird edge-case.
16:13:54 <ReinH> > any id []
16:13:55 <lambdabot>  False
16:14:09 <ReinH> startling: False is the unit of the boolean disjunction monoid
16:14:21 <startling> ReinH, OK, I guess that makes sense.
16:14:30 <JakeE> like wise all id [] is true becuase it asks just oppisite "is this list empty of all false values?"
16:14:32 <ReinH> it's the only boolean value such that mempty <> a = a = a <> mempty
16:14:51 <JakeE> or "is there not a false value in this list" better put
16:15:00 <ReinH> The existence proof for this is quite easy given we are talkig about two values ;)
16:15:21 <jrmithdobbs> ReinH: i've never thought of a Bool as a monoid before but i guess it is!
16:15:31 <startling> it's two monoids.
16:15:35 <ReinH> jrmithdobbs: well, it's Bool* actually
16:15:45 <ReinH> and you can pick either conjunction or disjunction
16:16:25 <jrmithdobbs> the "abstract nonsense" or w/e comments make more and more sense every day ;p
16:16:27 <ReinH> there are other monoids
16:16:34 <ReinH> but they are silly
16:16:45 <startling> isn't Bool a Ring?
16:16:46 <ReinH> actually, is that true?
16:16:55 <jrmithdobbs> startling: yes
16:17:11 <ReinH> jrmithdobbs: well, any ring is a monoid if you forget the rest of the ring structure :p
16:17:19 <JakeE> startling: ya I would think so. and is product, or is sum
16:17:41 <jrmithdobbs> ReinH: which is what makes it obvious that my maths background is not formal ;p
16:17:49 <ReinH> jrmithdobbs: :)
16:17:51 <JakeE> inverse is not. additive identity is false, product identity is true
16:17:53 <ReinH> jrmithdobbs: well neither is mine so neener
16:18:27 <jrmithdobbs> but ya, I hadn't made the ring/monoid connection, I honestly don't know how.
16:18:37 <jrmithdobbs> seems obvious
16:20:54 <ReinH> jrmithdobbs: a ring is an abelian group under addition and a monoid under multiplication, where multiplication distributes over addition
16:21:04 <ReinH> jrmithdobbs: forget about everything other than "a monoid under multiplication" ;)
16:22:27 <jrmithdobbs> ReinH: actually, that's probably why, I don't ever think about the mult part of them because the rings i've worked with the whole point is the mult is cheap base2 ;p
16:22:30 <ReinH> this functor Fl : R -> M is a forgetful functor and is right-adjacent to a functor Fr : M -> R called a free functor and so on
16:22:45 <ReinH> this adjacency forms a monad, but probably not a particularly intersting one
16:23:06 <ReinH> yay category theory
16:23:19 <ReinH> I have a cat theory book subtitled "The Joy of Cats". I love this book.
16:23:34 <ReinH> Mostly for that reason.
16:25:48 * hackagebot yamemo 0.4.0.5 - Simple memoisation function  http://hackage.haskell.org/package/yamemo-0.4.0.5 (NobuoYamashita)
16:26:50 <watermind> ReinH: they should make a dark S&M exposition of domain theory in "The joy of Doms"
16:27:03 <ReinH> hah
16:27:18 <ReinH> watermind: "I'm not a sub. I'm a Codom." And so on.
16:27:32 <ReinH> aaanyway
16:28:24 <ReinH> Hmm. shachaf hasn't corrected me yet. That either means that I'm right or he isn't paying attention.
16:32:25 <benzrf> @src Maybe <*>
16:32:25 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
16:32:32 <benzrf> @src Maybe (<*>)
16:32:33 <lambdabot> (<*>) = ap
16:32:38 <benzrf> ...
16:32:45 <benzrf> oh
16:32:50 <benzrf> @src ap
16:32:51 <lambdabot> ap = liftM2 id
16:34:52 <Maior> :t liftM2
16:34:53 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:35:53 <mceier> mdittmer: add "import Control.DeepSeq", and replace all "withBinaryFile name mode f" with "withBinaryFile name mode (((return $!!) =<<) . f)"
16:35:57 <mceier> haskell won't compute the value of f until it needs it - but when it needs it, file handle will be already closed and f won't be able to read anything
16:36:03 <mada> :t (liftM2 id)
16:36:04 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
16:36:51 <Maior> I'm confused - why...oh currying
16:40:49 <benzrf> hey
16:40:50 * hackagebot debian 3.81 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.81 (DavidFox)
16:41:07 <benzrf> is there any expression that you cannot directly put id in front of and have it remain unchanged?
16:41:10 <benzrf> syntactically speaking
16:42:01 <dwcook> benzrf, well, this might seem kind of obvious, but f x is different from f id x
16:42:26 <dwcook> If that's not what you meant, I think your question is unclear.
16:42:49 <benzrf> ah that works
16:42:50 <trillioneyes> > id do return 5
16:42:51 <lambdabot>  <hint>:1:4: parse error on input `do'
16:42:52 <benzrf> OK
16:43:02 <benzrf> > do return 4
16:43:03 <lambdabot>  No instance for (GHC.Show.Show (m0 a0))
16:43:03 <lambdabot>    arising from a use of `M734677480222003273219572.show_M7346774802220032732...
16:43:03 <lambdabot>  The type variables `m0', `a0' are ambiguous
16:43:03 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:43:03 <lambdabot>  Note: there are several potential instances:
16:43:14 <benzrf> wat
16:43:19 <dwcook> You need to choose a Monad
16:43:21 <benzrf> whats that super long name ._.
16:43:23 <benzrf> dwcook: ik
16:43:26 <benzrf> my previous q
16:43:30 <trillioneyes> The syntax of do and \ are weird
16:43:40 <benzrf> the wat was @ 07:36 < lambdabot>    arising from a use of `M734677480222003273219572.show_M7346774802220032732...
16:43:43 <benzrf> ??
16:43:46 <trillioneyes> > fix \_ -> True
16:43:47 <lambdabot>  <hint>:1:5: parse error on input `\'
16:43:54 <trillioneyes> > fix (\_ -> True)
16:43:55 <lambdabot>  True
16:43:59 <benzrf> > fix $ Const True
16:44:00 <lambdabot>  Couldn't match expected type `a0 -> a0'
16:44:00 <lambdabot>              with actual type `Control.Applicative.Const GHC.Types.Bool b0'
16:44:03 <benzrf> > fix $ const True
16:44:04 <lambdabot>  True
16:45:04 <benzrf> :t fix
16:45:05 <lambdabot> (a -> a) -> a
16:45:09 <benzrf> @src fix
16:45:09 <lambdabot> fix f = let x = f x in x
16:45:13 <benzrf> right.
16:46:17 <trillioneyes> You can also do things like
16:46:22 <trillioneyes> > take 20 $ fix show
16:46:23 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
16:46:55 <trillioneyes> Which is amusing, but probably never useful
16:47:11 <trillioneyes> I guess if you wanted to be obtuse you could use it to calculate powers of 2 or something
16:50:10 <benzrf> wait wut
16:50:18 <benzrf> how can you have a fix of show\
16:50:19 <benzrf> .-.
16:50:20 <Iceland_jack> > take 10 (map length (splitOn "\"" (fix show)))
16:50:21 <lambdabot>  [0,1,3,7,15,31,63,127,255,511]
16:50:32 <benzrf> wuh
16:50:42 <Iceland_jack> @src fix
16:50:42 <lambdabot> fix f = let x = f x in x
16:50:44 <benzrf> o-o
16:50:48 <dwcook> benzrf, show outputs a quotation mark without even needing its input
16:50:51 * hackagebot cabal-debian 4.0.5 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.0.5 (DavidFox)
16:50:53 <benzrf> oh right
16:51:20 <dwcook> At least, in the case of strings
16:51:22 <benzrf> *if the input is of type string
16:51:32 <dwcook> @type show
16:51:33 <lambdabot> Show a => a -> String
16:51:42 <dwcook> But you have to choose String if you fix it so the domain and codomain are equal
16:52:02 <Iceland_jack> @ty fix
16:52:03 <lambdabot> (a -> a) -> a
16:52:26 <Iceland_jack> If the output has type String, it must be
16:52:26 <Iceland_jack>     fix ∷ (String → String) → String
16:52:38 <benzrf> mmm right
16:52:40 <Iceland_jack> To put too fine a point on it
16:53:13 <benzrf> you & ur fancy unicode symbols
16:53:20 <benzrf> why cant you use -> and :: like the rest of us
16:53:26 <benzrf> god damn bourgeuoisei
16:53:46 <Iceland_jack> benzrf: Saves typing</lie>
16:54:05 <trillioneyes> ∷ seems especially silly to me
16:54:14 <trillioneyes> It's exactly the same, but smaller
16:54:16 <Iceland_jack> Of course it should be ∶ :)
16:54:18 <dwcook> Yeah, it should be written :
16:54:22 <FreeFull> …
16:54:35 <Iceland_jack> FreeFull: It's exactly the same as “...” but smaller!
16:54:39 <benzrf> screw yall if you cant express yourself in ascii i dont want to hear it
16:54:45 <Iceland_jack> So quaint
16:55:04 <FreeFull> benzrf: Only care about english and latin?
16:55:15 <FreeFull> And Scots, I suppose
16:55:23 <dwcook> I have a tendency to use … and even – and —
16:55:30 <benzrf> i dont know any other languages except like 3 letters of hebrew and a little bit of spanish
16:55:35 <benzrf> and spanish can be expressed fine in ascii
16:55:41 <dwcook> ¿En serio?
16:55:52 * hackagebot buildbox 2.1.2.5 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.2.5 (BenLippmeier)
16:55:55 <benzrf> as if you need your fancy schmancy upside down quotation mark
16:55:57 <Iceland_jack> dwcook: I always hope others distinguish between different dashes and hyphens
16:56:03 <benzrf> THE MEANING IS PERFECTLY CLEAR.
16:57:15 <simpson> benzrf: Pero hay infleciónes para los marques...
16:57:27 <simpson> Spanish is weird like that.
16:57:34 <benzrf> para = ?
16:57:37 <benzrf> for?
16:57:49 <simpson> for/by, depending. Correct usage of para and por is tricky.
16:58:23 <simpson> But yeah. There's inflections on the pre-sentence punctuation which modifies the start of the sentence, so a reader needs to know about them at the beginning of speaking.
16:58:42 <benzrf> bah
16:58:45 <dwcook> Even English suffers sometimes for not having something like that.
16:59:06 <dwcook> You read a long sentence that turned out to be yelled and then you only change inflection at the end. :P
17:00:28 <StoneToad> obviously the problem is that your parser doesnt do look ahead properly :p
17:00:52 * hackagebot discrete-space-map 0.0.3 - A discrete space map.  http://hackage.haskell.org/package/discrete-space-map-0.0.3 (SjoerdVisscher)
17:01:19 <dwcook> Hooray, arbitrary-length lookahead \o/
17:01:21 <benzrf> StoneToad: duh
17:01:40 <Sorella> dwcook, rewrite yourself with a packrat parser combinator with infinite lookahead
17:01:44 <simpson> Clearly, we should all switch to languages that require not inflection.
17:01:55 <simpson> tavla fo la lojban.
17:02:23 <simpson> ..."require not?" Wow, I'm tired.
17:02:35 <dwcook> At first I thought you were trying to make a point by reversing the order
17:02:58 <startling> all my nots are inflected
17:03:20 <JakeE> I was going to mention lojban...but then I realized simpson said somthing about it another language
17:04:24 <erisco> are there any modules for working with up-side-down trees?
17:05:07 <JakeE> We briefly looked at doing semantic mapping of lojban to a modfied montague semantics for sentiment analysis in my research group. That idea kinda fell though however sense we couldn't find as exact a grammar as we had hoped.
17:05:09 <simpson> JakeE: Well, I *think* I said "talking in Lojban", but I'm not sure. Still learning.
17:05:42 <JakeE> there is a BNF grammar but it is freaking HUGE
17:06:36 <JakeE> also it's really hard to see if it is working given that none of us knew lojban lol
17:07:15 <erisco> lojban is a CFL?
17:07:57 <JakeE> not sure, i think it is context senstive but there is an algorithimic means of resolving it
17:08:15 <erisco> what do you mean by "resolving"?
17:08:20 <simpson> It's grammatically a CFG, yes.
17:08:56 <simpson> And membership of a sentence in the language is decideable through the normal parsing techniques.
17:09:06 <JakeE> well there you  go lol. but to awnser erisco: you can parse a CSL but parsing a more general CFL and then determining if it is valid or not by the rules of the CSL
17:10:02 <erisco> JakeE, I see, so it is bandages
17:10:31 <JakeE> for instance haskell is context senstive due to fixity declerations so it might store expressions as lists of symbols with only parens parsed and then work the rest out after in knows all the fixities
17:10:40 <JakeE> erisco: ya; exactly
17:11:23 <JakeE> I doubt it actully does that but it *could* do that
17:11:50 <erisco> JakeE, well that is how I am intending to do it when I read around to it
17:11:54 <erisco> not sure what else one would do
17:12:12 <erisco> when I get around to it, I mean
17:12:28 <erisco> um, so, up-side-down trees. any modules?
17:13:02 <`Jake`> in GHC.Prim (http://www.haskell.org/ghc/docs/7.4.2/html/libraries/ghc-prim-0.2.0.0/src/GHC-Prim.html), every function is defined as "let x = x in x". Where do they define what the function actually does?
17:13:32 <`Jake`> Or what the function calls
17:13:32 <erisco> I am guessing not... I am imagining the representation as being a list of ordered levels where a level is a list of nodes at that level
17:13:55 <ziman> I'd say they are special-cased in the compiler
17:14:05 <JakeE> erisco: I think there are better ways of parsing actully; ways of integrating it into the parser. For instances using GLR parser and dynamiclly eliminating abiguties by the rules of the CSL
17:14:15 <`Jake`> okay, that would make sense
17:15:27 <cmiller_> Evening all. Does anyone know of any through introductions to the FFI?
17:16:17 <erisco> JakeE, well, sure, you can use an ambiguous grammar but you're still doing bandage work afterwards
17:16:22 <erisco> JakeE, I am not sure if that is really better
17:17:37 <erisco> JakeE, I suppose one advantage is that the parse tree is already completed and it is just a matter of selecting the correct one
17:17:57 <JakeE> erisco: I'm not an expert but I'm preety sure there are better solutions that I just don't know about. look at how C++ is parsed by major compilers
17:18:06 <erisco> no thanks :P
17:18:11 <JakeE> lol
17:18:25 <JakeE> look at how haskell handels fixity declerations and expressions then
17:18:28 <peddie> cmiller_: the Haskell Wikibook is pretty good
17:18:31 <JakeE> I bet it does somthing cool
17:18:38 <erisco> a lot of official compilers are ad-hoc recursive descent and regex
17:18:44 <peddie> @where wikibook
17:18:44 <lambdabot> http://en.wikibooks.org/wiki/Haskell
17:18:52 <cmiller_> Ty both.
17:19:35 <erisco> JakeE, now that I know how to use monads I should add memoisation to my general top-down parser and see how that idea works out
17:20:31 <JakeE> also you could look at parsing expression grammars sense they never have ambiguities and can be easially implemented as O(n) parsers in haskell
17:20:53 <erisco> hm, I have not heard of an expression grammar
17:21:11 <simpson> They're called "Parsing Expression Grammers".
17:21:13 <JakeE> the whole thing is called "parsering expression grammar"
17:21:16 <simpson> *Grammar, even.
17:21:29 <JakeE> or PEG for short
17:21:37 <erisco> it looks a lot like ebnf at a glance
17:21:45 <JakeE> parse it as "(parsing expression) grammars"
17:22:00 <JakeE> but it has things like *, +, ? etc...
17:22:18 <JakeE> and | is backtracking so that ambiguitiy dosn't occur
17:23:20 <JakeE> also if lookahead is needed it can be explicitlly requested by '&'
17:23:50 <JakeE> there is also a not operator that says "parse what does not match this"
17:24:10 <erisco> JakeE, well it defeats the purpose of having an ambiguous grammar though
17:24:47 <JakeE> right but it can parse a lot of stuff. also productions can be paramatized to handel ambigiuties at the site
17:24:50 <hape01> When a LANGUAGE pragma is placed accidentally behind the "module..." line, the GHC typechecker does not complain (but Pragma does get silently ignored) (hlint does report a problem instead). Why does GHC ignores this silently?
17:24:58 <JakeE> allowing most context senstive grammars to be produced
17:25:27 <JakeE> not "produced" but "defined"
17:26:31 <foozbazwhp> hello! if i have a long list of things, and i filter them into different slots in a HashMap String [thing] ...
17:26:36 <foozbazwhp> am i duplicating that list many times?
17:26:44 <foozbazwhp> will the data be copied?
17:26:47 <foozbazwhp> or just pointers..
17:27:08 <JakeE> neeed code to see but likely just pointers
17:27:30 <JakeE> as long as the items are not being modified or travarsed in anyway it is just pointers
17:27:47 <erisco> I wonder how much time a Haskell program spends dereferencing
17:27:59 <JakeE> pattern matching only I thikn
17:28:53 <JakeE> er...no if they still return the constructor code after evaluating the thunk. then it is somthing diffrent
17:29:22 <JakeE> maybe just when it can't fit everything in registers and actully has to spill over into the stack
17:29:40 <foozbazwhp> JakeE: :/
17:29:54 <foozbazwhp> JakeE: when it's published I'll ask on the beginners' mailing list
17:29:59 <foozbazwhp> JakeE: thanks! :P
17:55:32 <dmj`> on hackage, a package's download count. How is that calculated?
18:00:41 <hape01> ghci cannot browse any defined symbol (even in imports) - except by use of TAB key. I would love to have :browse all
18:01:57 <pavonia> hape01: ":browse"
18:02:21 <hape01> pavonia: :browse does only show local definied symbols. not those in imports
18:02:52 <hape01> pavonia: You have to use TAB i fear to get the whole list
18:03:14 <tibbe> Do we have a workaround for OS X Mavericks that's better than https://gist.github.com/mzero/7245290 ?
18:03:23 <tibbe> in particular, the above still gives a bunch of warnings
18:03:57 <pavonia> hape01: Huh, it works for me
18:04:30 <hape01> pavonia: when You do :browse You see the symbols in any of the imported modules, too?
18:04:58 <hape01> pavonia: assuming you are in a haskell programm importing different modules
18:05:58 <dleedev> does ghci use readline?
18:06:05 <pavonia> hape01: Oh, you're right, the list was too long, I was confused
18:06:13 <dleedev> ghci is not obeying my .inputrc
18:07:46 <pavonia> hape01: ":browse *Foo" where Foo is your module name seems to work
18:09:54 <dleedev> nm, find my answer here: http://stackoverflow.com/questions/1825547/how-to-customize-the-readline-keybindings-of-ghci
18:11:17 <hape01> pavonia: Hey!! Superb, that works!!!
18:11:30 <hape01> pavonia: That is wonderful
18:12:30 <Platz> has anyone read Origami programming by Jeremy Gibbons?  Hoping this will shed some light on the whole fold/unfold/hylo thing
18:14:20 <dwcook> Platz, I haven't, but is there anything in particular you're wondering?
18:15:49 <Platz> will probably take some time, but the traverse function is really interesting. saw some folks talking about fold.unfold and friends
18:16:20 <Platz> seems like an interesting abstraction, hylomorphisms, might actually be useful
18:16:46 <Platz> I think lens is based on it but want to understand the concept to apply elsewhere
18:17:34 <Platz> not really a small nugget to comprehend in one sitting though i think
18:18:01 <Platz> and theres always a lot of newtype wrapping/unwrapping, want to understand why that is as well
18:19:07 <Platz> e.g. some flavor  of unwrap.fold.map.unfold.wrap
18:19:28 <Platz> hence the similaity to traverse
18:25:55 <Platz> also this: http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/c0uvqqo
18:34:24 <AfC> Anyone off hand know of an example using optparse-applicative 's subparser/command feature?
18:41:04 * hackagebot containers 0.5.4.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.4.0 (JohanTibell)
18:45:38 <Platz> Also I'm pretty sure 90% of everything I assert about haskell is complete gibberish, so I thought I'd pour more fuel on that fire
19:01:59 <startling> AfC, I wrote a thing.
19:02:33 <startling> AfC, https://github.com/startling/partly/blob/master/partly.hs
19:02:56 <startling> AfC, https://github.com/startling/partly/blob/master/Partly/View.hs
19:04:04 <AfC> startling: looking
19:04:38 <AfC> I got part way there, but trying to have different options sets for different subparser commands is stymieing me.
19:05:55 <AfC> startling: oh weird. the sub parsers (sic) are :: ParserInfo ViewCommand
19:06:04 <AfC> startling: rather than :: Parser ViewCommand
19:06:33 <startling> AfC: yeah, I remember being puzzled by that.
19:06:44 <AfC> oh, actually you're doing the whole thing in ParserInfo. hrm
19:07:25 <AfC> ... because that's what execParser takes. hrm
19:08:17 <AfC> [this whole thing seems like it's about one layer of abstraction heavy. I mean it's comprehensive, no doubt, but...]
19:09:27 <AfC> & beats the hell out of <>. I'm going to start using that.
19:10:48 <stephenmac7> How do I fold IO actions?
19:10:48 <startling> AfC, I don't remember writing this code very well. I hope what's there is useful.
19:10:54 <AfC> Well. /me tries again. Thanks for the inspiration startling
19:11:01 <AfC> startling: sure is
19:11:11 <startling> AfC, I think & might get a warning nowadays, haha
19:11:14 <heath> http://www.haskell.org/haskellwiki/Why_Haskell_matters
19:11:21 <stephenmac7> Something like: archive <- foldl addToArchiveIfExists archive ["file1.txt", "file2.txt", "file3.txt"]
19:11:27 <startling> :t foldM
19:11:27 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:11:41 <stephenmac7> startling: Is that a left fold?
19:11:52 <startling> :t foldl
19:11:52 <lambdabot> (a -> b -> a) -> a -> [b] -> a
19:11:55 <startling> I guess so.
19:11:59 <stephenmac7> Yeah
19:11:59 <heath> this wiki article equates purity to no side-effects, is this really accurate?
19:12:00 <stephenmac7> Thanks
19:12:15 * heath is gathering material for a talk
19:12:19 <startling> heath, I guess so.
19:12:53 <heath> my definition seems to imply side effects
19:13:05 <heath> "  - given the same input, functions will always produce the same output (like mathematical functions)"
19:13:16 <heath> of course, taken from previous persons
19:13:25 <erisco> heath, I do not like defintion by negation, so I'd rather give the later definition
19:14:03 <heath> erisco: the definiton I quoted?
19:14:08 <erisco> yes
19:15:29 <erisco> heath, "purity is no side effects" is actually incorrect
19:16:03 <ski> (also please distinguish between "side effects" and "effects")
19:16:06 <erisco> presuming a normal concept of what a "side effect" is
19:17:55 <stephenmac7> startling: Doesn't seem to be working
19:18:13 <ski> roughly speaking, whether something is a side effect or merely an effect isn't about what it can do/represent, but about how you can reason about it (in the language in question)
19:18:20 <stephenmac7> I'm using this: addToArchiveIfExists archive filename = doesFileExist filename >>= (\x -> if x then addFilesToArchive [OptVerbose] archive [filename] else archive)
19:18:25 <stephenmac7> As my binary function
19:18:52 <stephenmac7> But this: archive <- foldM addToArchiveIfExists archive ["file1.txt", "file2.txt"]
19:18:54 <stephenmac7> Isn't working
19:19:08 <stephenmac7> Couldn't match expected type `IO Archive' with actual type `Archive'
19:19:34 <ski> it's a side effect of a function if it's not declared explicitly in the interface (e.g. type signature) of the function. in case it is, then it's an effect
19:19:56 <ski> @type foldM
19:19:57 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
19:20:20 <erisco> ski, how do you declare an effect in the type signature? what do you mean by this?
19:20:28 <stephenmac7> addToArchiveIfExists :: Archive -> FilePath -> IO Archive
19:20:51 <ski> stephenmac7 : possibly you want `else return archive' instead of `else archive' ?
19:21:12 <stephenmac7> ski: Yup
19:21:14 <stephenmac7> Thank you
19:21:26 <stephenmac7> Forgot to make the alternative an IO action
19:22:12 <ski> erisco : saying `foo :: String -> IO String' is a way of explicitly declaring the I/O effects as a part of the return value
19:22:13 <zeest> Cabal questions good here, or purely haskell?
19:23:05 <ski> erisco : if we imagine that we only said `val foo : string -> string' (e.g. in SML), then the I/O happens on the "side", and is not explicitly accounted for in the interface, hence in this case it's a *side*-effect
19:24:12 <heath> I appreciate the input
19:24:30 <heath> The wiki article also mentions "Strongly typed. There can be no dubious use of types. And No Core Dumps!" I don't know if this is accurate either.
19:25:13 <erisco> heath, strongly typed usually means that there is no automatic conversion of types
19:25:40 <beardtree> erisco: no it doesn't
19:25:52 <beardtree> Strongly typed means every value has a type
19:26:01 <ski> erisco : one can also imagine languages with explicit effect tracking systems, where one might perhaps write something like `val foo : string -> string with io', where the `with io' annotation indicates that a call of `foo' has `io' effects (so a call `foo "foo"' will have type `string' and can be passed directly into contexts expecting a `string', but it will also have an indication (in the type system) that evaluating it has `io' effects)
19:26:09 * hackagebot erd 0.1.0.0 - An entity-relationship diagram generator from a plain text description.  http://hackage.haskell.org/package/erd-0.1.0.0 (burntsushi)
19:26:20 <ski> (hm, possibly cut off at "but it will also have an indication (in the type system) that evaluating it has `io' effects)")
19:26:34 <erisco> beardtree, yes it does. there are different definitions of strongly typed, and I merely gave one
19:26:36 <zeest> Why won't Cabal update past version 1.16? I have seen that version 1.18 is available.
19:26:47 <heath> ski: it didn't cut off over here
19:26:54 <ski> beardtree : often one distinguishes between static vs. dynamic and strong vs. weak typing
19:26:57 <erisco> beardtree, but that is another definition, yes
19:27:19 <beardtree> ski: static v dynamic is irrelevant
19:27:59 <erisco> how the terms apply to a particular language is not universally defined. it is meaningless to use the terms alone
19:28:21 <ski> beardtree : i didn't claim otherwise
19:28:52 <ski> (just wanted to note that people sometimes mean different things by these words)
19:29:18 <ski> @where purely-functional
19:29:18 <lambdabot> "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>
19:29:22 <JakeE> weak typing to me means that a type error can occur at runtime; that is an error such as adding an integer and a string could occur. or calling a floating point number, etc...
19:29:25 <ski> heath : ^ might perhaps be interesting to you
19:29:57 <JakeE> strong typing means that this can't happen. only purly runtime errors. In haskell this means inexuastive pattern matching
19:30:04 <heath> definitely, thanks again
19:30:05 <erisco> JakeE, and other people may call that dynamic typing
19:30:20 <ski> erisco : no, that's unrelated
19:30:32 <beardtree> No it's not
19:30:36 <erisco> ski, I disagree
19:30:37 <beardtree> That's dynamic typing
19:31:13 <Ralith> JakeE: you're describing dynamic vs. static, not weak vs. strong
19:31:27 <JakeE> I'm not sure I ever understood "dynamic typeing" as being diffrent from "weak typing" as I view typing to be somthing which is known at compile time not runtime. perhaps if you said "this language is trongly typed it's just that type checking occurs at runtime" I might call that dynamic typing
19:31:44 <Ralith> you can view it however you like, but that is not what those terms mean.
19:31:57 <beardtree> JakeE: for instance, Python is a dynamically, strongly typed language
19:31:59 <ski> neither in Haskell nor in Scheme can the run-time attempt to add an integer and a string. there will be checks that prevent it. in one case a compile-time check, in the other a run-time check. in the sense of "weak vs. strong" that JakeE used above, both these languages have strong typing
19:32:06 <erisco> ski, I disagree in the sense that I have witnessed "runtime type errors" as being stated as a consequence of "dynamic typing", and all I am saying is that some people would say that "runtime type errors" is a consequence of "dynamic typing"
19:32:12 <beardtree> Dynamic just means types are unknown until runtime
19:32:37 <Ralith> for contrast, PHP and JS are dynamically, weakly typed
19:32:41 <JakeE> so what is weak? undefined behavoir if you mess up as in C?
19:33:01 <ski> yes
19:33:20 <erisco> JakeE, one interpretation is that in weak typing means type conversions may happen implicitly
19:33:21 <Ralith> no, that's also more or less orthogonal
19:33:59 <JakeE> fair enoghe I would still call adding adding an integer and a string a type error in C even though it is not cuaght
19:37:08 * ski is using the "static" and "strong" qualifiers in the sense employed by "On Understanding Types, Data Abstraction, and Polymorphism" by Luca Cardelli,Peter Wegner in 1985-12 at <http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf>, section 1.2
19:38:23 <erisco> heath, I am sure this all makes perfect sense now
19:38:31 <heath> Indeed
19:39:04 <ski> erisco : yes, the important point here is whether those "runtime type errors" are caught before attempting to commit the operation in question
19:40:36 <ski> if you say "runtime type errors" is a consequence of dynamic typing, then you're allowing such attempts at performing "runtime type errors" to be caught by the system
19:41:03 <L8D> Is there any convention/style/format for really long mutli-line strings?
19:41:18 <Ralith> "foo" ++\n "bar" ++\n "baz
19:41:19 <Ralith> "
19:41:20 <ski> otoh, in the sense of "runtime type error" i was using, it was understood that (at least some of) those were not caught
19:41:43 <ski>   x = "foo\
19:41:51 <ski>       \bar\
19:41:53 <ski>       \baz"
19:42:00 <ski> L8D ^
19:42:04 <L8D> weird
19:42:16 <ski> > "abc\\def"
19:42:17 <lambdabot>  "abc\\def"
19:42:19 <ski> > "abc\ \def"
19:42:20 <lambdabot>  "abcdef"
19:42:21 <ski> > "abc\  \def"
19:42:22 <lambdabot>  "abcdef"
19:42:55 <ski> a `\' followed by one or more white space followed by `\' will be omitted from the string literal
19:45:50 <JakeE> well I just found somthing my editor dosn't highlight correctly. multiline string literals
19:49:39 <jle`> JakeE: what is your editor? (so we can all laugh at you for using it)
19:49:43 <jle`> :)
19:50:13 <JakeE> um...yikes I feel like this might actully be embarsing and not just vim vs emacs religion
19:50:20 <JakeE> notepad++ (gulp)
19:51:12 * hackagebot erd 0.1.1.0 - An entity-relationship diagram generator from a plain text description.  http://hackage.haskell.org/package/erd-0.1.1.0 (burntsushi)
19:51:23 <dolio> JakeE: Correctly highlighting them is pretty difficult.
19:51:33 <dolio> I worked it out in vim once.
19:51:39 <dolio> At least, I think.
19:51:46 <dolio> It's difficult to be sure.
19:51:51 <JakeE> dolio: why? it should be regular language
19:52:06 <JakeE> the hardest part would be matching the quotes I think
19:52:08 <dolio> Well, I also wanted to highlight invalid strings.
19:52:32 <JakeE> that would make it harder; way harder lol
19:54:32 <JakeE> somthing like: \"([^\"]|\\\.([ \t\n\v]*\\)?)*?\"
19:55:36 <JakeE> as useful as regexs are they do just end up looking like a bunch of gobbledigook at the end lol
19:56:23 <dolio> I don't think that's right, but it's probably close.
19:56:27 <carter> o/
19:57:03 <JakeE> er ya I messed one thing up for sure
19:57:04 <trillioneyes> JakeE: that doesn't handle escaped quotes, does it?
19:57:14 <cmiller_> Is there a standard mechanism to configure include paths, library paths, and link libraries when building with cabal? Something like autotools?
19:57:44 <dolio> Vim's highlighting system complicates it a little, I think.
19:57:54 <dolio> For the case I was trying to do, at least.
19:57:56 <heath> ski, erisco: I'll read through your conversation in the morning
19:58:00 <JakeE> \"([^\"]|\\\(.|[ \t\n\v]*\\))*?\
19:58:01 <heath> I was away preparing this: https://gist.github.com/heath/8449497
19:58:06 <carter> cmiller_: kinda
19:58:09 <JakeE> that should handel escape quotes
19:58:10 <carter> whats your use case?
19:58:20 <JakeE> I havn't tested it however so it likely has an issue
19:58:35 <cmiller_> I'm using the FFI to bring in the BLAS and Lapack.
19:58:38 <carter> cmiller_: ohh
19:58:43 <erisco> heath, interesting that I am trying to implement quicksort myself too :)
19:58:44 <carter> you should help hack on my binding :)
19:58:52 <heath> Tips or suggestions welcome, the audience is going to be mostly web developers with experience in f#, ruby, and a little erlang even
19:58:56 <carter> cmiller_: i've a fancier array lib api i'll be putting on top too
19:59:04 <trillioneyes> I think that fails in the opposite way for quotes followed by escaped backslashes, but I'm not even really sure
19:59:05 <carter> cmiller_: joint #numerical-haskell :)
19:59:12 <carter> *join
19:59:18 <cmiller_> lol I thought I was the only one.
19:59:21 <carter> nope
19:59:31 <carter> i've been working on the fancy api design for the past year
19:59:34 <trillioneyes> *preceded by
19:59:48 <carter> taking the past month to write a simple portable binding that makes it easy to use blas / lapack
20:00:08 <carter> NB: the blas / lapack bind isn't the high level lib, even though i tmay look like it could be
20:00:53 <jrm2k6> Hi guys, how can i achieve/fix this? http://lpaste.net/98556
20:00:56 <cmiller_> Yeah I just started putsing with this language but my work is numerical analysis so I figured if I wanted to do work I'd have to link it somehow. A lot of the bindings on git hub hadn't seen action in a while. I guess I missed yours.
20:01:03 <jrm2k6> I want to return a list from a do stattement
20:01:09 <carter> cmiller_: soke
20:01:09 <jrm2k6> statement*
20:01:17 <carter> cmiller_: what sort of numerical ananlysi?
20:01:19 <JakeE> trillioneyes: if I did what I think I did it should allow ANYTHNIG to come after a backslash OR abitary white space followed by another backslash
20:01:20 <erisco> heath, it is more typical to make the pivot a singleton and to sort <= to the left side, or >= to the right side
20:01:41 <ski> heath : note that that `qsort' is generally agreed to not be a true quicksort (because it doesn't have the right space complexity)
20:01:56 <trillioneyes> JakeE: right, but that means it will think "\\" is an open quote, right?
20:02:57 <JakeE> trillioneyes: no; the first backslash must bind to the next character
20:03:27 <JakeE> o you know what to enforce that I have to say that a backslash can't occur where I say a quote can't occur so that is one more thing wrong with it
20:03:45 <JakeE> \"([^\"\\]|\\\(.|[ \t\n\v]*\\))*?\
20:03:50 <JakeE> there maybe lol
20:03:51 <ski> cmiller_ : numerical analysis is one topic i'd like to know more about ..
20:05:01 <duairc> Is there any way to write a function Parser a -> Parser Bool in attoparsec, that returns whether or not the given parser would succeed, without consuming any input?
20:05:41 <JakeE> you can do that with 'try' for sure
20:06:35 <duairc> Won't 'try' consume the input if the parser succeeds though? How do "put it back"?
20:06:46 <JakeE> you need another try that always fails
20:09:00 <duairc> But then how do I know if the failure is coming from the parser I'm testing or from the try that always fails?
20:09:01 <carter> ski: http://www.amazon.com/Numerical-Linear-Algebra-Lloyd-Trefethen/dp/0898713617/ref=pd_sim_b_4 is the best numerical linear algebra starter i've found
20:09:09 <carter> though for general numerical analysis, theres lots fo stuf
20:10:00 <JakeE> um...ya let me rethink that
20:13:10 <heath> shapr: do you have a link to a discussion on "compile time dynamic typing"?
20:13:31 <dmwit> jrm2k6: Did you get an answer yet?
20:13:34 * heath is looking at the discussion we had a few months ago
20:13:40 <jrm2k6> dmwit: nope
20:13:52 <dmwit> jrm2k6: You need to return a list from your base case.
20:13:56 <dmwit> jrm2k6: () is not a list
20:14:33 <jrm2k6> dmwit: checking
20:14:38 <heath> Hah, I just needed to keep reading the log when I asked then :)
20:14:45 <JakeE> try (retTrue p) <|> retFalse
20:15:02 <jrm2k6> dmwit: can i just do return []?
20:15:12 <JakeE> 'retTrue' takes a production, runs it and returns true. 'retFalse' simply returns false
20:15:30 <dmwit> jrm2k6: Yes, for example.
20:16:03 <duairc> JakeE: But if it p succeeds, then input will be consumed
20:16:06 <dmwit> duairc: can't
20:16:09 <dmwit> AFAIK
20:16:10 <jrm2k6> dmwit: ok thanks, i was expecting something trickier
20:16:18 <dmwit> duairc: Though see http://hackage.haskell.org/package/attoparsec-0.11.1.0/docs/Data-Attoparsec-ByteString.html#g:9
20:16:25 <jrm2k6> as it begins to deal with IO() in the 99haskell problems
20:16:28 <jrm2k6> Thanks :)
20:17:01 <JakeE> duairc: ya; forgot about that
20:17:50 <dmwit> duairc: Can you give us a bit more context about what you're trying to accomplish?
20:18:02 <dmwit> Perhaps you can do it without the combinator you ask for (e.g. by refactoring your grammar).
20:18:16 <JakeE> duairc: getPostion and setPostion
20:19:04 <dmwit> JakeE: You're probably thinking of Parsec, and also those do not change your position in the stream.
20:19:16 <dmwit> They just change the position that is reported, nothing else.
20:19:53 <JakeE> well that's misleading documentation: also I thought we were talking about parsec
20:20:19 <dmwit> No; duairc clearly said attoparsec in his question.
20:20:31 <JakeE> ah
20:20:48 <dmwit> I sort of agree that the documentation is vague here, though.
20:21:14 <JakeE> no clue then
20:21:31 <duairc> Here's a "solution" https://gist.github.com/duairc/8449689
20:21:43 <duairc> But yeah, I'll explain what I'm trying to do
20:22:47 <dmwit> That does not look like a solution to me.
20:23:13 <dmwit> In particular, I doubt it ever returns True; and I doubt it has the "don't consume anything" behavior you wish it has.
20:23:28 <joe9> Is there a package in hackage to replicate the shell command "watch" functionality in Haskell?
20:23:38 <duairc> dmwit: I've tested it using the parse function, it seems to work
20:23:53 <dmwit> Oops, missed the ! in that $.
20:23:57 <joe9> I use the terminal to read changing data. I want the changes to be highlighted as watch --differences does.
20:24:04 <JakeE> is there some way to catch a failiure? so that you could wrap the "always fails" solution in a try and then catch that and return true?
20:24:07 <dmwit> But I still don't believe it reliably backtracks.
20:24:20 <dmwit> I could try to cook up a counterexample if you really think that's a good approach that you plan on using.
20:25:37 <dmwit> (I have posted an example here in IRC several times before showing that the attoparsec documentation lies about always backtracking.)
20:26:16 * hackagebot google-dictionary 0.1.0.0 - Simple interface to the google.com/dictionary API  http://hackage.haskell.org/package/google-dictionary-0.1.0.0 (mitchellwrosen)
20:27:47 <joe9> http://linux.about.com/library/cmd/blcmdl1_watch.htm is what I am trying to replicate in haskell.
20:29:25 <duairc> dmwit: Basically, I'm trying to parse "URIs" that can have colons in the hostname. I know valid URIs don't (except for IPv6 but I'm already handling that case), but I want this parser to "never fail", to always produce a result no matter how ridiculous.
20:29:34 <duairc> So I have a parser, parseHostname, which I want to parse just the hostname part of the URI. I want it to stop before the port (if it exists).
20:29:44 <duairc> So if it gets something like "foo:bar:baz", it should consume that, but if gets "foo:bar:80", it should only consume "foo:bar". So I need to check if parsePort would succeed, and if so, stop there.
20:29:48 <duairc> I know this is kind of ridiculous, it's not really even important, but I'd like to get it to work if I can.
20:30:57 <duairc> Another obvious thing would just be to consume the whole thing and then split the colons when it's done
20:31:16 <duairc> I'm not actually going to use the unsafePerformIO thing really, there are loads of better ways I could do this
20:31:17 * hackagebot buildbox 2.1.3.2 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.3.2 (BenLippmeier)
20:31:36 <duairc> But I'm curious about a counterexample
20:34:16 <dmwit> grepping my logs
20:34:45 <dmwit> duairc: http://lpaste.net/85932
20:35:53 <dmwit> I would propose that parseHostname parse each :-separated chunk as a port number if possible, then turn the port number back into text if it discovers it needs to continue parsing.
20:36:35 <duairc> Yeah, that would work.
20:39:21 <frege> @src take
20:39:22 <lambdabot> take n _      | n <= 0 =  []
20:39:22 <lambdabot> take _ []              =  []
20:39:22 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
20:39:41 <duairc> dmwit: I'm looking at that example now. I wouldn't expect that to work? It would work if you put the *< A.char '!' inside the <|>
20:40:41 <dmwit> duairc: Why shouldn't it work? p2 <* A.char '!' should work, right?
20:41:06 <dmwit> And p2 is one of the choices for parsers to run.
20:42:17 <foozbazzle> what's it called when you have a parameterized datatype containing Either a {x,y,z}, and you pull it out so that the either is on the outside?
20:42:20 <foozbazzle> is that lifting?
20:42:48 <dmwit> I'm not sure I understood the question, but my guess at what you meant is factoring.
20:43:05 <foozbazzle> here's the signature of the function I'm trying to name:
20:43:05 <foozbazzle> :: Tri (Either a x) (Either a y) (Either a z) -> Either a (Tri x y z)
20:43:18 <erisco> I need a zip that crosses the boundary of the list. something like  (a -> b -> c) -> [[a]] -> [b] -> [[c]]
20:43:27 <duairc> dmwit: p2 <* A.char '!' would work, but that's not what's in the example. (Left <$> p1 <* A.char '!' <|> Right <$> p2 <* A.char '!') would work (modulo precedence maybe, might need brackets, haven't tested it)
20:43:35 <erisco> ie I need the structure of [[a]] preserved
20:43:39 <foozbazzle> dmwit: does that help?
20:43:44 <dmwit> foozbazzle: Tri a b c is roughly (a, b, c)? If so, then yes, I would say factoring is sthe right word.
20:43:47 <erisco> if there is nothing standard then I'll just write a definition
20:43:57 <foozbazzle> dmwit: factorEither ?
20:44:27 <foozbazzle> dmwit: something akin to this? http://en.wikipedia.org/wiki/De_Morgan's_laws
20:44:35 <dmwit> duairc: Surely you should believe that if ((a <* c) <|> (b <* c)) works, and you believe <|> backtracks correctly, then you believe (a <|> b) <* c should work.
20:44:56 <dmwit> foozbazzle: It's more like a distributivity law.
20:45:35 <dmwit> erisco: concat, then zip, then chunk 'em back up. nothing standard as far as I know
20:45:43 <foozbazzle> dmwit: distributing would be putting the either inside the tri, and factoring would be pulling it to the outside? .. thanks
20:45:53 <dmwit> uh
20:45:53 <foozbazzle> dmwit: helps to have somebody else to think with :)
20:45:55 <erisco> dmwit, if you concat then you lose the structure
20:46:05 <dmwit> X * (A + B) = X * A + X * B is distributivity.
20:46:14 <dmwit> Not sure it's really directional, though maybe.
20:46:27 <dmwit> erisco: Hence the "chunk 'em back up" stage.
20:46:37 <foozbazzle> dmwit:  true. i guess it's not super important, but it helps to think about it
20:46:40 <foozbazzle> dmwit:  thank you
20:47:15 <erisco> dmwit, well I do not know how you'd reasonably do so after a concat, but anyways I'll write a definition myself
20:49:35 <dmwit> erisco: import Data.List.Split; chunkyZipWith f xs ys = splitPlaces (map length xs) (zipWith f (concat xs) ys)
20:51:02 <dmwit> As proof, in ghci chunkyZipWith (,) ["abc", "def"] "ghijklmnopqrs" evaluates to [[('a','g'),('b','h'),('c','i')],[('d','j'),('e','k'),('f','l')]].
20:51:25 <duairc> dmwit: That isn't obvious to me, I wouldn't necessarily expect that. But in any case, I don't see how to turn your example into a concrete counter-example for my code. But in any case, I'm not actually going to use that in my code, so I don't want to waste your time trying to find one. I know that code is evil.
20:51:46 <dmwit> duairc: Great. I won't spend my time on it, then. =)
20:52:00 <erisco> dmwit, I think that is an example, not proof ;) but yes it seems reasonable
20:52:05 <dmwit> duairc: I would be interested in spending my time convincing you to expect the law I proposed, though.
20:52:14 <dmwit> erisco: Okay, s/proof/evidence/
20:53:53 <dmwit> duairc: In English, compare the following sentences: "A widget is either (the string 'foo' followed by an exclamation mark) or (the string 'bar' followed by an exclamation mark)." vs "A widget is (either the string 'foo' or the string 'bar') followed by an exclamation mark.".
20:54:20 <dmwit> I would want those sentences to mean the same thing.
20:56:20 * hackagebot erd 0.1.2.0 - An entity-relationship diagram generator from a plain text description.  http://hackage.haskell.org/package/erd-0.1.2.0 (burntsushi)
20:58:31 <duairc> dmwit: Attoparsec will do what you expect in that case
20:59:24 <duairc> (Left <$> string "foo" <|> Right <$> string "bar") <* char '!' works
20:59:33 <dmwit> duairc: I know.
20:59:43 <dmwit> duairc: But shouldn't it work regardless of the specific parsers put there?
20:59:54 <duairc> Let's translate it to English and see :)
21:00:01 <dmwit> duairc: Okay! How about this one.
21:02:09 <dmwit> duairc: "Tell me about widgets, wickets, and woozles. Then a blargle is either (a widget followed by a woozle) or (a wicket followed by a woozle)." vs "Tell me about widgets, wickets, and woozles. Then a blargle is (either a widget or a wicket) followed by a woozle."
21:03:11 <erisco> dmwit, this is my direct approach http://lpaste.net/98560
21:03:31 <dmwit> duairc: no, no, I'm drawing the wrong comparison
21:03:42 <dmwit> duairc: Let me try again.
21:04:25 <dmwit> erisco: ugh
21:05:30 <erisco> dmwit, hehe
21:06:16 <dmwit> duairc: No, wait, I did draw the right comparison.
21:06:34 <duairc> dmwit: I don't think you did, because that also works in attoparsec
21:06:47 <dmwit> duairc: What does "also works" mean?
21:08:31 <duairc> dmwit: mean that {A.string "wicket" <* A.string "woozle" <|> A.string "widget" <* A.string "woozle"} and {(A.string "wicket" <|> A.string "widget") <* A.string "woozle"} give the same results
21:08:44 <dmwit> I didn't say anything about strings!
21:08:57 <erisco> dmwit, taking the length is more icky to me
21:08:59 <dmwit> The point is that now my statement is parameterized.
21:09:03 <dmwit> erisco: Why?
21:09:29 <dmwit> duairc: That is, "tell me about widgets, wickets, and woozles" means it should work for any parsers, not just for the A.string "widget" parser.
21:11:23 * hackagebot wl-pprint-text 1.1.0.2 - A Wadler/Leijen Pretty Printer for Text values  http://hackage.haskell.org/package/wl-pprint-text-1.1.0.2 (IvanMiljenovic)
21:12:36 <dmwit> In non-English, I mean that for any parsers widget, wicket, and woozle, (widget <* woozle) <|> (wicket <* woozle) = (widget <|> wicket) <* woozle. But that's not true in attoparsec.
21:16:27 <dmwit> Well. I guess repeating myself isn't very convincing.
21:16:31 <duairc> dmwit: Okay, well I feel that kind of begs the question. Let's take the original example in plain English.
21:16:47 <dmwit> ...as you rightly say moments after I do. =)
21:17:08 <dmwit> The original example, in plain english, is this:
21:17:27 <dmwit> "A widget is either (some letters) or (some letters and numbers) followed by an exclamation mark."
21:17:47 <dmwit> bad parens
21:17:50 <duairc> :)
21:18:01 <dmwit> "A widget is (either some letters or (some letters and numbers)) followed by an exclamation mark"
21:18:25 <dmwit> I wish that was the same as, "A widget is either (some letters followed by an exclamation mark) or (some letters and numbers followed by an exclamation mark)."
21:18:38 <dmwit> Do you also wish those two English sentences were the same?
21:20:06 <duairc> I mean I can understand why you would want them to be the same, but they're not, and if I feel like if they were you would lose the ability to make some distinctions that you might occasionally want to make
21:20:38 <dmwit> For example?
21:20:49 <duairc> I'm trying to think of one :)
21:21:17 <dmwit> (As languages, they are definitely the same.)
21:23:45 <duairc> I feel like the key word in these sentences is "or"
21:24:33 <duairc> I'm not so sure about the English sentences, but when I look at the attoparsec example, it makes complete sense to me why <|> can't "see" the char '!' outside the brackets
21:24:42 <dmwit> There are two key phrases. "or" is one; "followed by" is the other.
21:25:00 <dmwit> duairc: Really? And why is that?
21:25:50 <dmwit> duairc: p2 can surely consume "abc1def", and A.char '!' can clearly consume "!"; so why shouldn't "abc1def!" be a fine input to this parser?
21:26:36 <ski> in DCG, `( some(letter) ; some(letter_or_number) ),exclamation_mark' is the same as `( some(letter),exclamation_mark ; some(letter_or_number),exclamation_mark )'
21:29:08 <duairc> <|> is what does the backtracking. The ((some letters) or (some letters and numbers)) part of the parser succeeds, because the (some letters) part of the parser succeeds, consuming "abc". Then once that's then, <|> is done, so you don't have backtracking anymore. <|> can't see into the "future", it can't know about the char '!' that's about to fail. It can if you put it inside the brackets.
21:30:04 <ski> that's not backtracking. that's backtracking *and* pruning
21:30:59 * ski isn't quite sure what duairc and dmwit are debating, nor who is claiming what
21:31:39 <BlankVerse_> how do I get an old version of ghc and cabal running on my system .. say ghc-6.4?
21:31:41 <dmwit> ski: attoparsec does not do backtracking properly. The result is that (a <* c) <|> (b <* c) and (a <|> b) <* c can behave differently.
21:31:58 <dmwit> ski: I claim this is in contradiction to the documentation, which claims that all attoparsec parsers backtrack.
21:32:57 <ski> i would tend to agree, or at least say that it's a bit misleading
21:33:36 <dmwit> ski: In particular, in attoparsec, try = id.
21:33:39 <dcoutts_> BlankVerse_: grab a ghc binary release from the ghc site, it comes with Cabal lib, then install an older version of cabal-install (actually new ones should still work with old ghc, but only older versions will still compile with old ghc)
21:33:45 <dmwit> Which sucks.
21:34:04 <dcoutts_> BlankVerse_: 6.4.x is more or less the earliest versions of ghc that cabal still works with
21:34:10 * ski isn't too fond of `try' and `<|>' in Parsec either
21:34:30 <dmwit> Me neither. But it's not okay to cripple them if you don't provide an alternative!
21:34:40 <dmwit> Well. It is. But it's not okay to cripple them and claim you didn't!
21:34:51 <ski> (i might prefer a system with a non-commiting `<|>', and an explicit commit construct)
21:34:58 <ski> dmwit : *nod*
21:36:26 * hackagebot crypto-conduit 0.5.2.2 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.5.2.2 (MichaelSnoyman)
21:36:50 <duairc> dmwit: I guess I don't know what "backtracking" actually means, I just assumed it meant what the attoparsec docs seems to imply it means. And this works to my advantage really (in the short term), because I have the "correct" intuition for using attoparsec, I won't make "mistakes" like in the example you sent. I might by misguided but it's useful for now.
21:38:12 <duairc> (what I mean by "what the attoparsec docs seem to imply it means" is: the attoparsec docs say that attoparsec parsers "backtrack" on failure, so I understood "backtracking" to mean "what attoparsec does")
21:38:23 <Redz> backtracking is for people with parsers and logic programming languages. one side hate it, the other side can't without it.
21:40:34 <dmwit> duairc: The lpaste I linked fails, and does not backtrack.
21:40:42 <dmwit> duairc: So how does that fit with your intuition?
21:41:01 <erisco> here is a mini module I wrote up for representing trees as lists. I could not find related work http://lpaste.net/98561
21:41:23 <ski> duairc : when one is discussing backtracking in logic programming, such as Prolog (and perhaps more on-topic, the DCG, Definite Clause Grammar, system that is commonly implemented in Prologs), "backtracking" definitely includes that in `( a or b ) followed_by c', in case `a' succeeds, but `c' then fails, `b' will be tried instead of `a' (and then `c' subsequently)
21:42:28 <dmwit> erisco: What's good about this representation?
21:42:51 <erisco> why this is important to me is that lists are reversable, which means I can construct the tree incrementally (what I mean by "incrementally" takes more words to explain)
21:43:25 <duairc> dmwit: My intuition is that you only get "backtracking" when you use <|> or mplus, and in the lpaste the point at which it fails is A.char '!', and there's no <|> wrapped around that
21:43:56 <erisco> dmwit, and you can see I needed the crossZip function or your chunkyZipWith
21:44:02 <ski> erisco : why not `[[1],[2,5],[3,4,6,7]]' or something similar ?
21:44:21 <erisco> ski, because rose trees do not have a constant branching factor
21:44:21 <dmwit> ski: can't tell where the boundaries are that way
21:45:02 <dmwit> erisco: (I'm hoping you'll spend those few more words to say what "incrementally" means, by the way.)
21:45:19 <ski> oh, right, not necessarily binary
21:46:03 <erisco> so to explain "incrementally", I was in a situation where I could not say  let f ... = Node x (f ...)
21:46:24 <erisco> and by that notation I mean, construct the root and then recurse to construct its children, and so on down to the leaves
21:46:27 * hackagebot conduit 1.0.10 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.10 (MichaelSnoyman)
21:46:29 * hackagebot network-conduit 1.0.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-1.0.1 (MichaelSnoyman)
21:46:31 * hackagebot network-conduit-tls 1.0.3 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-1.0.3 (MichaelSnoyman)
21:46:42 <erisco> rather I need to carry the tree forward
21:46:58 <erisco> let f tree = add stuff to tree ... f tree'
21:47:15 <erisco> well if I used Tree then I'd have to reconstruct the tree at every step, which is not efficient
21:48:22 <erisco> so what I can instead do is build the tree using the list representation, in reverse order, and reverse the list when I am done
21:49:22 <erisco> dmwit, not sure if that made sense
21:50:22 <dmwit> A bit. Still a bit abstract, though.
21:50:24 <erisco> a succinct wording would be "I know what the root is, but I do not immediately know what the children are"
21:51:18 <dmwit> Surely "I know what the root is but the children require computation" is exactly what "Node x {- do some computation -}" says?
21:51:26 <erisco> if you are in the situation "I know what the children are, but I do not know the root" you are fine because you can efficiently construct the root later
21:51:33 <erisco> but you cannot efficiently construct the children after the root
21:51:47 <jle`> if you're storing the tree as a flat list why don't you just use an array/vector for random access?
21:51:58 <erisco> dmwit, but I cannot recurse to compute the children at that time, is the point
21:52:18 <erisco> jle`, random access is not necessary
21:52:20 <dmwit> Okay. I don't get it after all.
21:52:27 <erisco> dmwit, =\
21:53:04 <dmwit> But it's certainly possible to build a Data.Tree.Tree both bottom-up and top-down in an efficient way.
21:53:26 <erisco> dmwit, what is the bottom-up approach?
21:55:09 <erisco> dmwit, sorry, I mean the top-down approach
21:55:49 <dmwit> :t unfoldTree
21:55:50 <lambdabot> (b -> (a, [b])) -> b -> Tree a
21:56:07 <erisco> there is a subtly that I am having a hard time wording
21:56:17 <dmwit> Maybe types can help!
21:56:33 <erisco> but here is another attempt: after constructing the root, the function must return before the children are constructed
21:56:52 <dmwit> That sounds awfully operational. Haskell doesn't do operational.
21:58:19 <erisco> f state tree = let ... in (state', tree')
21:58:22 <erisco> how about that
21:58:35 <erisco> the function has to iteratively construct the tree
21:58:51 <erisco> and it must do so top-down
21:59:10 <dmwit> I don't really understand how "iteratively" and "top-down" combine.
21:59:13 <dmwit> Maybe types can help!
21:59:19 <erisco> no the types will not help
22:00:02 <erisco> dmwit, I am disappointed that I cannot find some way to word the situation correctly but if you are interested then I can demonstrate the use-case in by my other module
22:00:11 <erisco> but I have not done the required work there yet
22:00:31 <dmwit> It's cool. I'm going to bed pretty soon. I'm glad you found something that works for you.
22:01:27 <erisco> I hope it does :) I am working on a qsort implementation and I am hoping this is the missing piece I need
22:01:28 * hackagebot egison 3.2.6 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.6 (SatoshiEgi)
22:01:29 <ski> erisco : perhaps the new leaves added will depend on all the existing nodes in the tree ?
22:02:01 <ski> ("all" as opposed to say "all the parent nodes of the new leaf in question")
22:02:33 <erisco> ski, you mean constructing the Tree with reverse edge direction?
22:02:49 <ski> maybe
22:03:15 <ski> (as in, "maybe it could entail that", not as in "i maybe mean that")
22:03:18 <erisco> that is what I originally considered. it is an acyclic graph, but the fact that nodes are shared makes reasoning about the structure as a tree impractical
22:03:58 <ski> inherently directed or not ?
22:03:58 <erisco> ski, once you remove the sharing (by grouping together nodes) you end up with what I implemented
22:04:41 <erisco> ski, I do not know what "inherently" directed means
22:07:27 <Redz> what does UndecidableInstances actually mean and do?
22:07:33 <ski> just wondering whether you were originally considering a directed acyclic graph (DAG) or undirected acyclic graph
22:08:27 <erisco> ski, directed
22:08:46 <ski> Redz : it means that the implementation will try to deduce instances even in cases where that might lead to it not terminating (at compile-time) -- at least not terminating without the addition of maximum recursion counts
22:10:01 <ski> Redz : there are certain rules, which when followed, the implementation knows that instance resolution will terminate. if you have instance declarations that violate these (more or less ad hoc rules), that might still be ok
22:10:32 <ski> erisco : btw, "grouping together nodes" how ?
22:11:12 <erisco> ski, imagine reversing edge direction on Node 1 [Node 2 [], Node 3 []]
22:12:04 <ski> ok ?
22:12:17 <erisco> ski, then you have node 2 and node 3 both pointing to node 1. By grouping all nodes that directly point to node 1, you remove sharing. The result is that the group [2,3] points to 1
22:12:30 <Redz> thank you, ski . in short, i have no problem when it can compile?
22:13:08 <erisco> ski, when you repeat this grouping process, you end up with a list (or a tree with branching factor 1)
22:13:11 <ski> Redz : yes
22:14:33 <ski> "a list" here being the list representation in your paste ?
22:16:22 <erisco> ski, yes
22:16:34 <erisco> ski, I will illustrate with lpaste ascii
22:21:49 <erisco> ski, for brevity I left out the empty children lists for the leaves
22:21:51 <erisco> ski, http://lpaste.net/98562
22:22:24 <ski> (hm, no annotation on the original paste ?)
22:22:43 <erisco> I guess not :P
22:23:08 <ski> (just a suggestion for later pasting ;)
22:23:49 <ReinH> hai
22:24:15 <erisco> if the branching factor was constant, I would not need the third level of list, but such is not the case for Data.Tree
22:24:22 <sergii> hi everybody. newbie question. I would be glad if somebody could help with simple problem: http://lpaste.net/98563
22:24:33 <erisco> ski, hopefully that explanation for how the representation is derived makes sense
22:25:16 <ReinH> erisco: just got here, but you aren't talking about levels are you?
22:25:37 <ReinH> :t Data.Tree.levels
22:25:38 <lambdabot> Tree a -> [[a]]
22:26:41 <erisco> ReinH, no not quite
22:26:48 <ReinH> erisco: ok then :)
22:27:49 <roboguy_> I installed ghc HEAD earlier and now I'm getting errors with integer-gmp (specifically that the "p_dyn" library isn't installed apparently). anyone know about this?
22:28:29 <ski> erisco : i'm wondering about the structure of  ...  in  let f tree = add stuff to tree ... f tree'  or in  f state tree = let ... in (state', tree')
22:28:33 <erisco> serge, main = ins (1 :: Int) []    -- maybe this
22:28:48 <ski> (iow, what is used to determine the new leaves of the tree, at each generation step ?)
22:28:59 <erisco> :t iterate
22:29:00 <lambdabot> (a -> a) -> a -> [a]
22:29:03 <roboguy_> sergii: the first thing I notice, is that main should be of type IO something
22:29:28 <roboguy_> where something is some kind of type or type expression
22:29:33 <erisco> it is much like this, which is a more trivial version of   (s -> (s, a)) -> s -> [a]
22:29:39 <sergii> roboguy_: I have tried main :: Bag a
22:29:52 <sergii> roboguy_: but it does not help
22:29:58 <roboguy_> sergii: I think main is required to be of type IO something
22:30:20 <roboguy_> sergii: so you could do something like this: print $ ins 1 []
22:30:24 <erisco> ski, so imagine you are constructing the tree as the iteree (the function being iterated)
22:30:26 <ski> sergii : try `ins (1 :: Integer) []'
22:30:58 <ski> (or `Int' or `Double' instead of `Integer', if you prefer)
22:31:39 <erisco> ski, so to answer "how to determine the new leaves of the tree" it is determined by the state
22:31:41 <ski> sergii : `main :: (Eq a,Num a) => Bag a' would probably also work with `main = ins 1 []'
22:31:49 <sergii> roboguy_: main :: IO (); main = print (ins 1 []) works! thanks!
22:32:29 <ski> sergii : note that `main :: Bag a' promises that this `main' will work for *any* type `a', not just "equatable" and numeric types `a' (which is what `ins 1 []' actually can handle)
22:32:29 <ReinH> erisco: oh, you want coiteration I think
22:33:25 <sergii> ski: main :: (Eq a,Num a) => Bag a does not help if I use main = ins 1 []
22:33:42 <ski> erisco : "the state" including what ? presumably some state external to the tree being generated is allowed. but what parts of the tree-to-be-generated may it depend on
22:33:45 <erisco> ReinH, is that  let f = ... g ...; g = ... f...;  roughly?
22:33:47 <sergii> ski: solution by roboguy_ works
22:33:55 <ReinH> erisco: take a look at `coiter` http://hackage.haskell.org/package/free-2.0.2/docs/Control-Comonad-Cofree.html
22:34:10 <ReinH> erisco: Cofree [] a is a tree of a
22:34:25 <ski> @let type Bag a = [(a,Int)]
22:34:27 <lambdabot>  Defined.
22:34:46 <erisco> ReinH, is it related to the Free monad?
22:34:48 <ski> @let ins :: Eq a => a -> Bag a -> Bag a; ins x [] = [(x,1)]; ins x ((b, bn):bs) | (x == b) = (b, succ bn) : bs | otherwise = ins x bs
22:34:49 <lambdabot>  Defined.
22:34:53 <ReinH> erisco: it is cofree, yes
22:34:59 <ReinH> erisco: it is the cofree comonad
22:35:05 <roboguy_> sergii: also, you shouldn't use tabs in haskell. it will cause a lot of problems
22:35:12 <ski> > let  main :: (Eq a,Num a) => Bag a; main = ins 1 []  in  main
22:35:14 <lambdabot>  [(1,1)]
22:35:18 <erisco> okay. I do not know what "co" means
22:35:20 <ski> sergii : seems to work here
22:35:31 <ReinH> erisco: the categorical dual of the free monad, but look at the definition
22:35:35 <ReinH> a :< (f (Cofree f a))
22:35:40 <ReinH> if our functor is []
22:35:47 <ReinH> a :< [Cofree [] a]
22:36:14 <roboguy_> ski: I'm pretty sure lambdabot is different from ghc in this regard. it doesn't work for me. it says it has to be type IO t0
22:36:34 <erisco> ReinH, hm. I am not sure what useful things follow
22:36:38 <ReinH> erisco: the point being, when I need to generate leaves based on the current position in the tree, coiter on the Cofree [] a monad is a good choice
22:36:46 <ReinH> erisco: so for game tree generation for instance
22:36:56 <roboguy_> ski: I think main is a special binding that must be have an IO type
22:37:02 <roboguy_> generally
22:37:59 <ReinH> erisco: something like this https://gist.github.com/reinh/8450668
22:38:33 <ski> sergii,roboguy_ : ok, if you don't explicitly name your module, then `main' must have a type matching `IO a' (for some type `a')
22:38:42 <ReinH> erisco: I'm not exactly sure what you're doing btw
22:38:59 <ReinH> erisco: in this case I'm generating a game tree where nexts is all the possible next moves from a given game state
22:38:59 <erisco> ReinH, are you saying you can roughly write   let f tree = {- add leaves to tree as tree' -}   efficiently? ie O(1) leaf append
22:39:19 <ReinH> erisco: what I'm saying is that gameTree is lazy
22:39:20 <roboguy_> ski: if you name the module anything other than "Main", it doesn't use the "main" function in that module for the main entry point to the program though
22:39:22 <ski> sergii : in any case, if you rename my `main' to `sergeii', i think my solution will work anyway (or you could add `module Sergeii where' as the first line of the module, where `Sergeii.hs' is the name of the file)
22:39:32 <ReinH> erisco: such that when evaluating the game tree, if I decide to prune certain branches
22:39:38 <ReinH> (alpha-beta pruning for instance)
22:39:42 <ski> roboguy_ : *nod'ä
22:39:43 <ReinH> those branches are never generated
22:39:46 <ski> s/'ä/*/
22:39:48 <ReinH> so I never incur any cost for them
22:39:50 <ReinH> that is awesome
22:40:04 <ReinH> I only pay the cost for the parts of the tree I actually evaluate
22:40:04 <erisco> ReinH, lazy is not the feature I am after, but that is a useful feature
22:40:14 <ReinH> erisco: ok :) I don't know what you're doing :)
22:40:16 <sergii> ski: thanks for your help. appreciate it!
22:40:23 <erisco> I'll probably have to look at this very carefully to figure out if it is what I need, but I am not optimistic
22:40:35 <ReinH> erisco: I don't know, but it is quite interesting in its own right :)
22:40:41 <erisco> good news is that I've already programmed what I need
22:40:44 <ReinH> free monads are awesome
22:40:52 <ReinH> cofree comonads are crazy awesome :)
22:41:34 <erisco> ReinH, what useful code can be generalised over the Free monad other than class instances?
22:41:41 <erisco> (and a couple lift helpers)
22:42:00 <ski> erisco : a specific case (for lists) of `coiter' is `unfoldr :: (s -> Maybe (a,s)) -> (s -> [a])' (where `s' represents the "current state")
22:42:06 <ReinH> erisco: to the extent that a monad is an abstraction for sequencing computations, the free monad is the most general possible such abstraction
22:42:31 <ski> sergii : no problem
22:42:31 <ReinH> erisco: so rather than actually performing the sequencing via >>= or join, you are creating a list of computations
22:42:52 <ReinH> this list can then be evaluated JIT style, etc
22:42:59 <ReinH> you can implement models of threading, etc
22:43:10 <erisco> ReinH, what I mean is, what code are you going to write that operates on 'Free a b' for parametric 'a' and 'b'?
22:43:33 <ReinH> erisco: well, if I'm interpreting some langauge and I want runtime access to the evaluation model
22:43:47 <ReinH> I want a free monad for that language's evaluation semantic
22:44:06 <erisco> sorry to be even more clear...
22:44:10 <ReinH> heh ok :)
22:45:12 <ski> erisco : still waiting for details on what parts of the (incomplete) tree that `add leaves to tree as tree' depends on ..
22:45:37 <erisco> data MyType a b = More a (MyType a b) | Last b   -- this has the same pattern as the Free monad, but obviously does not use the Free type
22:45:54 <ReinH> erisco: right, it's isomorphic to the free monad
22:46:02 <erisco> so why would I prefer using the Free type other than for the class instances and the couple lift helpers?
22:46:30 <ReinH> erisco: I'm not sure if you would. The concept for me is more important than the implementation
22:46:36 <ReinH> but the implementation exists so I might as well use it
22:46:38 <simpson> erisco: Multiple ways to fold.
22:47:07 <simpson> erisco: Here's an example I'm working on right now. I have a compiled instruction format which I'm representing using a free monad structure.
22:47:41 <simpson> I can fold over it to evaluate it and print stuff, or to print out a summary of its effects, or to patch up certain instructions, or to check its stack effects for well-typedness...
22:47:44 <simpson> It's like a list.
22:48:06 <ReinH> Right, it's a list of the computations that would have been sequenced by a (non-free) monad
22:48:38 <ReinH> erisco: have you seen Tekmo's posts on free monads? http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
22:49:07 <erisco> ReinH, yeah I understand from an aesthetic level, or if you really really don't want to rewrite the instances, but what I am contending with (for a case in which I have something isomorphic to Free) is nosier pattern matching and needing to lift
22:49:17 <ReinH> ski: (right, unfold is a coiterative :)
22:49:21 <erisco> ReinH, yes I have
22:49:34 <ReinH> erisco: ok :)
22:49:45 <erisco> ski, I am not entirely sure how to answer because I do not entirely understand what you are asking
22:49:54 <ReinH> erisco: I am actually suggesting that for your tree building you might find the cofree [] comonad useful, not free monads per se
22:50:09 <erisco> ski, in my case, the state contains the entire tree that has been constructed thus far
22:50:18 <erisco> ski, and I then need to efficiently add leaves onto that tree
22:50:47 <ReinH> erisco: well, you are restricted to adding leaves as efficiently as you can traverse the tree
22:51:14 <ReinH> if you need the whole tree then your worst case is the worst case for access to any leaf
22:51:19 <erisco> ReinH, if I used something like Data.Tree, yes, but this is precisely why I just made the ListTree module
22:51:33 <ReinH> erisco: what is your ListTree module? I'm late to the party
22:51:36 <erisco> oh
22:51:55 <erisco> http://lpaste.net/98561 is the module and http://lpaste.net/98562 explains the derivation of the representation
22:52:05 <ReinH> Cofree [] a assumes you need access to just the current leaf, so not a fit
22:52:29 <ReinH> erisco: right, so that representation is *not* Data.Tree.levels?
22:52:36 <erisco> using this representation, I do not have to traverse the tree. I can construct the tree in reversed ListTree format. After completion, I reverse the list and then toTree
22:52:58 <ReinH> right, if you can create the list you can create its tree
22:52:59 <ReinH> sure
22:53:04 <erisco> ReinH, it is very close but has an extra nesting because the branching factor is not constant
22:53:05 <ReinH> there is the obvious isomorphism
22:53:13 <ReinH> erisco: ah, sure
22:53:32 <ReinH> erisco: now I am starting to see :)
22:53:36 <erisco> ReinH, well, the advantage is that I do not have to traverse anything to add on the leaves :)
22:53:47 <ReinH> well.......
22:53:56 <erisco> yes the list has to be reversed, granted
22:54:41 <ReinH> erisco: how does the nesting of the list not grow with the growth of the tree? I fail to see how it is always [[[a]]] in your rep
22:54:54 <erisco> though the list to reverse has length equiv to the height of the tree
22:55:16 <ReinH> erisco: (so you have log n there, which is good)
22:55:44 <ReinH> well, roughly log base branching factor
22:56:36 <ReinH> erisco: but how is your list always [[[a]]]? Doesn't the nesting grow logarithmically?
22:56:53 <ReinH> for a binary tree wouldn't your nesting at level n be n?
22:58:49 <erisco> ReinH, no. I will annotate with another level
23:00:32 <erisco> ReinH, http://lpaste.net/98562 I have annotated. note that I have excluded empty children lists for brevity
23:03:52 <erisco> ReinH, it is just like levels but also groups the children. that is all
23:05:22 <jle`> any reason why there isn't an applicative instance for Kleisli?
23:06:11 <erisco> ReinH, and the reason my explanation is a bit roundabout is that I was explaining how if you reverse the edges on a tree, and then remove node sharing by grouping (aggregating) nodes, then you'll end up with a list, as is demonstrated
23:06:33 <ski> erisco : as an example, one way of constructing an infinite (or possibly infinite, if you prefer) list, where the construction of each element (possibly) depends on all the previous elements, is to keep a (reversed, say) accumulator of all the elements created so far
23:07:43 <erisco> ski, yes indeed, and it is similar to how I need to construct the tree, and like for the list it is kept in reverse order for efficiency
23:08:01 <ski> erisco : iow, `type Stream a = [a]; courseOfValuesRecursion :: ([a] -> a) -> Stream a; courseOfValuesRecursion step = loop [] where loop acc = a : loop (a : acc) where a = step acc'
23:08:18 <pavonia> jle`: There isn't even a Functor instance, IIRC
23:08:28 <pavonia> (which is probably why)
23:08:38 <jle`> pavonia: hm yeah there isn't.
23:08:42 <jle`> any reason why there isn't?
23:09:00 <ski> erisco : another way of doing the same thing is to pass the whole final list as input to the computation of each list element, and then only access elements earlier than the current one (or keep an index count and use `take' with it to extract just the previous elements)
23:09:54 <pavonia> jle`: I can't think of a reason
23:10:10 <ski> erisco : for a tree, you could easily keep a list of the parent nodes in an accumulator, or you could pass in the final tree as input (possibly pruned as above) if you also need to look at sibling and other non-parent nodes
23:11:12 <erisco> ski, I had not considered that method. I have to think if it is applicable to me
23:12:58 <erisco> ski, hm, it is not that generating new parts of the tree is dependent on previous parts, it is that at the final stage (the algorithm terminates) it must return the root node
23:13:32 <erisco> ski, so the issue with feeding the result back in, which is clever, is that I am still forced to return the root before recursing
23:13:36 <erisco> which I cannot do in my scenario
23:14:17 <erisco> (I know I contradicted that statement somewhat earlier but, again, it is difficult to word exactly)
23:14:43 <erisco> if I complete the qsort implementation tomorrow I'll just show you what I mean via code
23:18:58 <catsup> i have a problem where my code works in 'runhaskell' but when i use 'cabal build' i get a lot of compilation errors ("Note in scope" and "Empty 'do' block").  these errors are in compilation of a module.  of course, the do blocks are not empty and the vars are in scope...  what's this mean?
23:19:06 <catsup> Not*
23:21:16 <pavonia> catsup: Can you paste an example?
23:22:33 <pavonia> "not in scope" errors can occur if you don't specify all packages in the .cabal file, but the empty do-blocks are weird
23:22:36 <catsup> oh i think it has to do with the NondecreasingIndentation extension...  enabled by default in runhaskell but not in cabal build?
23:23:04 <erisco> ski, actually no I am not "forced to return the root node before recursing"
23:23:05 <catsup> the variables that are not in scope are all variables that i created, but they might have to do with indentation too.  i have nested a lot of stuff without indenting
23:23:19 <erisco> ski, not sure why I thought so :) maybe it will be a viable method as well. I'll check it out too
23:23:21 <erisco> thanks
23:24:08 <erisco> g'night
23:26:07 <pavonia> catsup: Yeah, that seems to be enabled by default in new GHC versions :S
23:26:27 <catsup> GHC   full (-XNondecreasingIndentation; enabled by default)
23:28:22 <pavonia> The only correct solution, IMHO, is to use proper indentation in your code
23:29:26 <catsup> i don't think 'proper' indentation is appropriate to this case
23:30:14 <pavonia> Why not?
23:30:16 <catsup> calling a series of 'withXYZ' initializers that take lambdas
23:30:49 <catsup> anyway i don't think it's the indentation because, as you pointed out, ghc enables that by default
23:31:39 * hackagebot string-conversions 0.3.0.2 - Simplifies dealing with different types for strings  http://hackage.haskell.org/package/string-conversions-0.3.0.2 (SoenkeHahn)
23:32:14 <pavonia> But cabal seems to disable it, you could set the Extensions field
23:35:57 <catsup> oh sweet, that fixed it
23:36:19 <catsup> thanks pavonia
23:36:39 <pavonia> you're welcome
23:36:41 <catsup> incidentally, "Warning: For packages using 'cabal-version: >= 1.10' the 'extensions' field is deprecated. The new 'default-extensions' field lists extensions that are used in all modules in the component, while the 'other-extensions' field lists extensions that are used in some modules"
23:38:18 <catsup> git commit -a -m 'fix cabal build; thanks pavonia'
23:38:30 <pavonia> ;)
23:38:56 <pavonia> Maybe it's even better to use language pragmas only in the modules actually using that extension (if not too many)
23:39:16 <catsup> i actually tried that but i guess my pragma was not properly formatted
23:39:42 <catsup> there's only one module anyway though
23:40:25 <pavonia> {-# LANGUAGE NondecreasingIndentation #-} should do it
23:40:34 <pavonia> Well, I have to go. Bye!
23:44:18 <kraalquid> Which data structure is best fit for storing live cell locations in an automaton like the game of life?
23:50:09 <jle`> kraalquid: hm. depends on your situation. but an Array with a tuple Ix might work well
23:50:16 <jle`> an array of Bools?
23:50:30 <Redz> kraalquid: when you dont need to care about performance, you can use nearly every container.
23:50:51 <jle`> he might be asking for one with a good API
23:50:52 <kraalquid> assuming I do care about performance, would a Set be a good choice?
23:51:08 <Redz> array or repa-array, i think.
23:51:57 <kraalquid> If I store locations as tuples then I don't really need a 2D grid structure, just one capable of fast lookups
23:52:30 <Redz> Set then.
23:56:14 <Redz> but i think, a array is are much faster than a set.
23:56:54 <b80905> how do i load the List.hs file?
23:57:30 <Redz> kraalquid: you could use a hashtable, but i think, building a hashtable for every step is way to slow too.
23:58:56 <Redz> b80905: a file named List.hs must have a module called List in it.
23:59:28 <b80905> Redz: how do i load a module?
23:59:33 <Redz> and if you have not just a local directory, the module name must match them.
23:59:57 <Redz> in ghci? or for compiling?
