00:00:20 <NemesisD> at this point i'm pretty sure the docs for Validation are just incorrect
00:02:12 <NemesisD> whatever. doesn't even look like the instance gives me what i want anyways, which is that if there are any Failures, to concatenate them and have the whole computation be a failure
00:07:17 <NemesisD> i gotta get some sleep.
00:07:27 <NemesisD> thanks for walking me through as far as you did guys
00:13:53 * hackagebot HaskellNet-SSL 0.2 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2 (DanielWright)
00:13:53 * hackagebot libjenkins 0.3.0.0 - Jenkins API interface  http://hackage.haskell.org/package/libjenkins-0.3.0.0 (MatveyAksenov)
00:19:30 <zett_zelett> Why doesn’t yi have C-x 3?
00:26:36 <qrada> a
00:26:38 <qrada> oops
00:53:38 <qrada> if EpochTime is defined as CTime (type EpochTime = CTime) in System/Posix/Types.hs, shouldn't I be able to use CTime and EpochTime interchangably?
00:53:41 <qrada> or no ?
00:53:59 <shachaf> Yes.
00:54:15 <shachaf> Yes as in you should.
00:55:05 <qrada> hm.. that's what im struggling with though.. i can't seem to be able too.. im basically trying to 'compare' a modificationTime (from a FileStatus) with a time I can generate with CTime etc
00:55:16 <qrada> im probably waay off but that sounds like it should work
00:55:18 <qrada> dno
00:56:40 <shachaf> If I say "yep, it should work", will that help?
00:56:59 <qrada> nope
01:24:22 <jtcwang> what's the proper way to write a line like this?
01:24:23 <jtcwang>     putStrLn if betResult br == Win
01:24:24 <jtcwang>                 then "You Won!  Balance: " ++ show $ betBalance br
01:24:24 <jtcwang>                 else "You Lost! Balance: " ++ show $ betBalance br
01:25:07 <jtcwang> do i have to use a let block?
01:25:10 <Eelis> use putStr to print the win/lost part, then another putStrLn for the balance part since it's the same in both cases
01:25:27 <simpson> jtcwang: putStrLn $ if...
01:25:44 <simpson> jtcwang: if/then/else is a single expression; there's no problem doing it this way.
01:26:04 <jtcwang> hmm
01:26:04 <simpson> Also what Eelis said.
01:26:19 <jtcwang> i still got errors though
01:26:24 <jtcwang>     putStrLn $ if betResult br == Win
01:26:25 <jtcwang>                 then "You Won!  Balance: " ++ show $ betBalance br
01:26:25 <jtcwang>                 else "You Lost! Balance: " ++ show $ betBalance br
01:26:25 <jtcwang> for this
01:26:38 <simpson> Well, what are your errors? Also consider a pastebin.
01:27:52 <qrada> ok finally figured it out.. convered the epochTime to ClockTime so I can use diffClockTimes etc.. it's working at least. ok cool goodnight
01:28:03 <qrada> convered/converted
01:29:35 <jtcwang> let me try to debug it first simpson. I'll post my results. probably a silly mistake somewhere..
01:31:47 <jtcwang> ok apparently i need to bracket everything after ++ operator, which makes sense
01:32:07 <jtcwang> but i can't do ... ++ $ show $ betBalance br though, why's that?
01:32:23 <jtcwang> is it because ++ is being used infix?
01:32:39 <Kinnison> Probably
01:32:51 <simpson> jtcwang: You'll need parens
01:33:04 <simpson> ++ (show (betBalance br))
01:33:47 <jtcwang> yeap, but why is that? I thought $ will evaluate everything after it first
01:34:00 <jtcwang> essentially giving us the same expression as with the paren
01:34:08 <simpson> :t ($)
01:34:09 <lambdabot> (a -> b) -> a -> b
01:34:22 <simpson> ($) is just another operator. It's a relatively boring one, too...
01:34:25 <simpson> @src ($)
01:34:25 <lambdabot> f $ x = f x
01:34:36 <ski> saying `... ++ $ ...' is like saying `2 + * 3'
01:34:45 <simpson> It's got a fixity and associativity that cause a grouping-like effect.
01:34:51 <simpson> But it is *not* some primitive part of the language.
01:34:59 <lieven_> ($) is just there to avoid too many parentheses a la lisp :)
01:35:02 <ski> jtcwang : also, you shouldn't overuse `$'
01:35:12 <simpson> Also, your example is...
01:35:21 <ski> (a few brackets aren't scary)
01:35:32 <simpson> :t "a string" ++ show $ 42
01:35:33 <lambdabot>     Couldn't match expected type `a1 -> t0' with actual type `[Char]'
01:35:33 <lambdabot>     The first argument of ($) takes one argument,
01:35:33 <lambdabot>     but its type `[Char]' has none
01:35:53 <ski> @type "a string" ++ show 42
01:35:54 <lambdabot> [Char]
01:35:58 <ski> > "a string" ++ show 42
01:35:59 <lambdabot>  "a string42"
01:36:10 <ski> > "a string" ++ show (3^4)
01:36:11 <lambdabot>  "a string81"
01:36:25 <jtcwang> i see
01:36:30 <jtcwang> makes sense
01:37:32 <jtcwang> so why wouldn't ++ consume show only and give us an error?
01:38:01 <jtcwang> does it got to do with infix precedence?
01:38:21 <jtcwang> why don't we need (show 42)
01:40:14 <simpson> jtcwang: Because of ++ in the middle.
01:40:25 <simpson> jtcwang: Function application binds tighter than anything else.
01:40:33 <simpson> > show 4 ++ show 2
01:40:34 <lambdabot>  "42"
01:40:44 <jtcwang> i see
01:40:54 <jtcwang> gotcha thx
01:41:25 <ski> jtcwang : because application binds tighter than any other operator (well, except the syntactic operators `@',`~',`!' in patterns (and record patterns))
01:42:20 <jtcwang> i've been through half of my first haskell project
01:42:30 <ski> `show 4 ++ show 2' means `(show 4) ++ (show 2)' .. you can think of it as being an invisible application operator inbetween the `show' and the `4'/`2', which binds tighter than the `++' operator
01:42:35 <jtcwang> but i still find my style quite primitive
01:43:07 <jtcwang> yeah ski, i see that if function application binds tighter, then they're like a paren around them
01:43:33 <jtcwang> i'm wondering whether there are any materials
01:43:41 <jtcwang> that can help me expand
01:44:11 <jtcwang> like a list of very cool concepts for functional programming
01:44:14 <t7> instead of passing around dictionaries to dynamic libraries could we rewrite them as we load them based on some index ? (i guess you would need n * types used memory)
01:44:31 <t7> might save a few cycles :P
01:46:31 <aninhumer> Hmm, I thought I understood the ST monad, but now I'm not sure what it actually enforces or does...
01:46:43 <aninhumer> I thought this would be impossible: runST $ do { x <- newSTRef 5; y <- readSTRef x; writeSTRef x 6; z <- readSTRef x; return $ y + z }
01:48:46 <shachaf> For that to type-check or for that to be 11 or what?
01:49:24 <aninhumer> shachaf: I wasn't sure exactly how it would be enforced, but I thought it was impossible to use a read value after a subsequent write
01:51:34 <aninhumer> Because otherwise I'm not sure how that's implemented with mutable state in a way that isn't pointless
01:51:58 <shachaf> Do you know C? You can think of it like a pointer in C.
01:52:23 <ski> > runST $ do { x <- newSTRef 5; y <- readSTRef x; writeSTRef x 6; z <- readSTRef x; return $ y + z }
01:52:25 <lambdabot>  11
01:52:37 <shachaf> { int *x = ...; y = *x; *x = 6; z = *x; return y + z }
01:53:14 <aninhumer> So values are only copied when necessary?
01:53:54 <shachaf> ?
01:53:54 <ski> aninhumer : think of a reference as an index (or a map key), indirectly referring to an element actually being kept inside a list/array/map being passed (threaded) around as a state, under the monad covers (in the usual state monad fashion)
01:54:33 <aninhumer> Sure, but then how is it different from just doing that with State and IntMap or something?
01:54:56 <aninhumer> And a supply monad
01:55:04 <ski> (a) you can dynamically allocate new reference cells whose values can be of types not anticipated by `ST'
01:55:08 <ski> (b) it's more efficient
01:56:08 <aninhumer> Actually, yeah I had noticed (a) before
01:56:24 <aninhumer> I guess I just thought it was incedental, rather than most of the point
01:56:25 <ski> in practice, `newSTRef' will probably call some `malloc'-type of function, and `readSTRef' and `writeSTRef' will just probably just dereference the pointer
01:57:23 <ski> (there's also `unsafeInterleaveST' (which really is unsafe, with regards to purity, unlike `unsafeInterleaveIO'))
01:58:53 <aninhumer> Okay, I guess I already understood it :P
01:59:10 <aninhumer> Thanks
02:00:07 <ski> btw, note that we don't know whether (a) can actually be implemented in Haskell
02:21:20 <silasm> http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html#t:NFData is less helpful than I hoped. How do I make something an instance of NFData?
02:26:55 <notdan> silasm: http://hackage.haskell.org/package/deepseq-1.3.0.2/docs/Control-DeepSeq.html#t:NFData
02:27:30 <silasm> notdan: many thanks
02:33:04 <silasm> hmm, how does one make an instance when rnf is invisible? I'm trying to make a tree structure NFData.
02:33:40 <silasm> but it doesn't let me use rnf recursively.
02:34:01 <ski> hm, can you derive it ?
02:34:12 * ski can't recall
02:35:05 <silasm> ah nevermind, derped on typeclass instance syntax lol.
02:35:14 <silasm> I was wondering why it was calling my data a class.
02:39:21 <jle`> anyone use netwire?
02:39:40 <jle`> anyone know how to .. conditionally pop an event into a wire in the arrow/proc/do/rec notation?
02:39:58 <jle`> listener -< (if x then event else no event) ?
02:40:15 <jle`> x comes from the result of another wire
03:19:02 * hackagebot snaplet-fay 0.3.3.3 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.3 (AdamBergmark)
03:29:03 * hackagebot separated 0.0.5 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.0.5 (TonyMorris)
03:31:12 <t7> haskell type class constraints are not stored per type variable are they? just 1 set of constraint, where constraints on a type variable are filter if freeIn(constraint) ?
03:32:09 <t7> a set of constraints*
03:36:14 <yayutf> I'm playing around with doing some utf-8 text processing in Haskell, and I'm wondering what string and regex libraries people here recommend using, given that there are tons of each. At the moment, I'm using a combination of System.IO.UTF8 to read files, Text.Regexp to manipulate the text, and then using Data.Text.IO to actually produce usable unicode output, but this seems unlikely to be optimal...
03:37:26 <yayutf> Data.Text doesn't seem to have an equivalent of Text.Regexp's splitRegex, and its regex functions all seem to be in IO
03:37:43 <maxs`> How would I implement ResourceT (LoggingT (SqlPersistT IO)) a -> LoggingT (ResourceT IO) a
03:38:04 <maxs`> I have `hoist (flip runSqlPersistM conn) (lift . lift)`, but I get a GHC impossible
03:38:22 <yayutf> Is there *one* combination of string and regex libraries that actually lets me read text in, run it through some pure regular expressions, and print it out as unescaped, readable utf-8?
03:39:05 * hackagebot ghcjs-dom 0.0.3 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.0.3 (HamishMackenzie)
03:39:06 * hackagebot persistent-redis 0.0.4 - Backend for Yesod persistent library using Redis.  http://hackage.haskell.org/package/persistent-redis-0.0.4 (PavelRyzhov)
03:39:07 <Axman6> yayutf: http://hackage.haskell.org/package/text-icu-0.6.3.2/docs/Data-Text-ICU-Regex.html?
03:39:26 <Axman6> yayutf: never used it before, just thought I'd see if there was anything on Hackage
03:39:49 <yayutf> Axman6: a) that's not pure; it uses IO everywhere, and b) it doesn't support split
03:39:57 <Axman6> fair enough
03:40:07 <Axman6> time to start writing then :P
03:40:10 <yayutf> I've used hoogle, and poured a couple hours into this over the last two days
03:40:19 <Axman6> anything that works on ByteString?
03:40:27 <yayutf> Axman6: it would still use IO everywhere
03:40:29 <yayutf> hm
03:41:14 <yayutf> I'm rather reluctant to use ByteString for variable-character-length strings
03:41:26 <yayutf> it's just begging for problems
03:41:38 <Axman6> sure, but someone might have written something that works. sounds unlikely though
03:42:11 <yayutf> Axman6: it's pretty high on the list of "how not to do unicode" to try to use bytestrings and similar and kinda hope that you don't do any operations that break up characters
03:44:16 <Axman6> http://hackage.haskell.org/package/regex-tdfa does appear to support ByteString... >_>
03:44:36 <Axman6> maybe it wouldn't be too hard to make it support Text too
03:46:23 <yayutf> Axman6: it theoretically does - http://hackage.haskell.org/package/regex-tdfa-text
03:46:36 <Axman6> but...?
03:46:40 <yayutf> though the '41 downloads' is a bit scary :-)
03:46:46 * yayutf will mess around with it for a bit
03:47:09 <Axman6> maybe not many people have needed regex's for Text
03:49:04 <yayutf> Axman6: given the number of hits on google for posts by people who simply find haskell's system for it absolutely inscrutable, and given how widely used they are in other languages, I find that rather dubious
03:52:04 <nitwit> Hello, I'm having trouble with type/typeclasses, I have a function that accepts one of 3 types of constructors, and it should behave differently for each other, how do I do a 'Wildcard' for the constructor? http://pastebin.com/J9TiXBaq
03:52:08 <mauke> The paste J9TiXBaq has been copied to http://lpaste.net/98637
03:53:14 <mmmm> nitwit: So what do you want insertPilot to do?
03:54:10 <nitwit> mmmm: to insert a pilot in an name-ordered fashion.
03:55:01 <nitwit> ideally I'd place a '_' where Car/Bike/Truck is, but I don't think I can do that. Nor can I place a Maybe in that spot.
03:55:11 <mmmm> No I don't think you can do that
03:55:24 <gspr> Is vector's  convert :: (Vector v a, Vector w a) => v a -> w a  able to avoid being O(n) if v and w are in fact the same?
03:56:00 <mmmm> Maybe you would be better redefining Pilot
03:56:13 <nitwit> can't do that.
03:56:32 <mmmm> why not?
03:56:53 <nitwit> it's part of the assignment.
03:57:02 <gspr> (I need to pass a pointer to the underlying data of a vector to some FFI call, and I'd like to provide a generic Vector interface where a convert is only done if the vector is not a Storable one)
03:57:19 <nitwit> I'm not trying to get you to do my homework for me, I'm trying to learn how to do that wildcard-thing. I couldn't find it on google.
03:57:28 <Axman6> gspr: since it's just unstream . stream, it's possible it might...
03:57:37 <mmmm> then you need to write a seperate definition for each constructor as far as I'm aware
03:58:09 <gspr> Axman6: Interesting
03:59:05 * hackagebot ghcjs-dom 0.0.4 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.0.4 (HamishMackenzie)
03:59:05 <nitwit> mmmm: that isn't very efficient, I seriously doubt that's the way to proceed in this situation. Like I said I'd have to do 3x3 definitions.
04:00:36 <mmmm> Ok, another way then, write a function which extracts the name from the Pilot type and then you can use that in your definition of insertPilot
04:00:40 <Axman6> gspr: looks like it probably won't unless LLVM is really smart, but it could be written as a rewrite rule
04:01:27 <t7> @type (\x -> x x) (\x -> x x :: forall a. a -> a)
04:01:28 <lambdabot>     Occurs check: cannot construct the infinite type:
04:01:29 <lambdabot>       t0 = t0 -> a0 -> a0
04:01:29 <lambdabot>     In the first argument of `x', namely `x'
04:01:39 <t7> @type (\x -> x x :: forall a. a -> a) (\x -> x x :: forall a. a -> a)
04:01:40 <lambdabot>     Occurs check: cannot construct the infinite type: t0 = t0 -> a -> a
04:01:40 <lambdabot>     Expected type: (t0 -> a0 -> a0) -> a -> a
04:01:40 <lambdabot>       Actual type: t0 -> a0 -> a0
04:01:50 <nitwit> mmmm: so there's no way to use a wildcard constructor?
04:01:57 <t7> @type (\x -> x :: forall a. a -> a) (\x -> x :: forall a. a -> a)
04:01:58 <lambdabot>     Couldn't match type `a1' with `a0 -> a0'
04:01:58 <lambdabot>       `a1' is a rigid type variable bound by
04:01:58 <lambdabot>            an expression type signature: a1 -> a1 at <interactive>:1:8
04:02:16 <t7> its not rigid :O
04:03:16 <mmmm> How do your propose this wildcard would work?
04:04:45 <nitwit> mmmm: well...'_' I suppose. for data constructors that are similar to each other.
04:05:56 <Axman6> gspr: oh actually, there's probably a good reason it won't behave as id, because it's almost certain that if you're using it you want a copy because you intend to modify the first vector. I could be wrong
04:06:05 <mmmm> how do you know they are similar, I guess that's my question
04:06:18 <Axman6> benl23 would know best....
04:06:35 <nitwit> because they derive from the same class?
04:06:50 <Axman6> "class"?
04:06:56 <nitwit> data*
04:07:30 <mmmm> another way out is to use records instead
04:08:03 <Axman6> and risk non total functions
04:08:07 <nitwit> yes I thought of that but like I said I can't make those changes.
04:08:34 <Axman6> I'd personally go with the pattern match, it's clear, and the compiler will tell you when you modify the data type that other things are broken
04:08:55 <t7> @kind Maybe -> a
04:08:56 <lambdabot> Not in scope: type variable `a'
04:09:01 <t7> @kind forall a. Maybe -> a
04:09:02 <lambdabot>     Expecting one more argument to `Maybe'
04:09:02 <lambdabot>     In a type in a GHCi command: forall a. Maybe -> a
04:09:13 <nitwit> Axman6: and make 3x3 cases?
04:09:23 <mmmm> where does the x3 come from?
04:09:47 <nitwit> because in that specific function I take a list of pilots. the first one could be one of 3 types.
04:09:48 <t7> @kind (->)
04:09:49 <lambdabot> * -> * -> *
04:09:58 <nitwit> approaching each case I'd have to make 3x3 definitions.
04:10:07 <nitwit> and for the next data type, n*n
04:11:02 <mmmm> write a function like this http://lpaste.net/98640
04:11:26 <mmmm> then you can use that instead of pattern matching
04:11:28 <gspr> Axman6: I can imagine the following scenario where one would want it: Say you want to *read* the underlying memory in a foreign language. Then you want a storable vector, so it would make sense to desire to expose an interface for generic vectors wherein convert acts as id if the (generic) vector passed is in fact a Storable one
04:11:51 <gspr> (and O(n) copy for boxed and unboxed)
04:13:07 <nitwit> yes that seems to be the only solution. I guess I'm just surprised that this functionality is missing. Isn't haskell all about polymorphism and dealing with problems in the most programatically manner possible?
04:14:35 <nitwit> I mean, ideally and approaching this problem with an optimization mindset one wouldn't even define data types in that manner, with records at the very least, but still. It just seems like a major gap.
04:14:57 <Axman6> it's all about type safety, and what you're asking for is quite hard, especially since the pattern now becomes type dependant.
04:15:11 <Axman6> you're after foof (_ a) = ... right? where you match any constructor?
04:15:25 <nitwit> any constructor deriving of the same data, yes.
04:16:04 <Axman6> right, what happens when you have data Foo = Bar String | Baz Int? how can that be type safe?
04:16:13 <Axman6> a need to be both type String and Int
04:18:01 <nitwit> but that isn't a data type defined correctly.
04:18:11 <mmmm> how so?
04:18:12 <nitwit> I mean it's syntax is valid, but that isn't good practice.
04:18:29 <Axman6> how so?
04:18:36 <Axman6> I use things like that all the time
04:18:51 <nitwit> my understanding is that different constructors for the same data type share most constructor parameters
04:19:06 <Axman6> no...
04:19:07 <Axman6> not at all
04:19:16 <nitwit> I mean, why would you define them as constructors for that data type if they're so different? why not just define them independently
04:19:23 <Axman6> in fact the opposite would be far far more common
04:19:57 <Axman6> because it allows you type safe processing of various data types that are some how related
04:20:47 <Axman6> I'm writing something at the moment that has a data type something like data Region = Circle Radius | Annulus Radius Radius | MovingAt Region Velocity | At Region Position
04:21:16 <Axman6> I'm using it to a) check if a point is inside one of those reagions and b) render them to OpenGL to display the data graphically
04:23:49 <nitwit> So it's mostly for reading comprehension and dealing with list items in a generic fashion
04:24:27 <Axman6> I'm not sure what you mean
04:26:49 <nitwit> you said that data constructors should be some how related, and I see from your Region example one such example, but let's face it, it practically mostly serves reading comprehension, for you Circle/Annulus/etc.. are Regions, but when you're accesing their parameters it doesn't matter much
04:27:04 <alpounet> nitwit: no, types like Axman's Region above are really, really common
04:27:19 <nitwit> and being able to sift through on a high level, like scrolling through list items
04:27:24 <Axman6> they're what we use everyday for everything...
04:27:27 <nitwit> I didn't say they were an exception.
04:28:06 <alpounet> nitwit: they let you consider the different constructors with their fields under a same name, still letting functions behave differently on each through pattern matching
04:28:39 <nitwit> alpounet: through pattern matching, exactly. it doesn't work programatically.
04:28:45 <alpounet> in Java you'd probably have a Region interface and then have Circle, etc classes implement it
04:28:55 <Axman6> ew
04:29:31 <alpounet> Axman6: I'm saying that because that's what I have seen many times, not that I endorse it :p I haven't done much java anyway
04:30:13 <alpounet> nitwit: you are pretty much wanting "first class patterns", might i say
04:30:20 <alpounet> right?
04:30:33 <alpounet> being able to abstract over patterns
04:30:43 <Axman6> nitwit: perhaps you need something like data Named =- Name String a (where a is whatever type you're after)
04:30:52 <nitwit> alpounet: well, yes. it seems pretty useful to me.
04:31:17 <hpc> how would you even express the type of a pattern value?
04:31:19 <alpounet> nitwit: you often need to treat several patterns the same?
04:31:22 <hpc> presumably something like
04:31:37 <alpounet> s/treat/process/
04:31:40 <hpc> (Pattern t) - which could be (Pattern Bool) or (Pattern [])
04:31:45 <hpc> or something
04:32:12 <hpc> or, it would be Pattern [a]
04:32:31 <hpc> which you could construct with some value for (:) _ _ and []
04:32:32 <alpounet> hpc: maybe the data type generic programming frameworks could help
04:32:36 <hpc> but not for say (:) True _
04:33:18 <nitwit> alpounet: well for myself, a bit yes, but take a data type that has several constructors, you'd have to do pattern matching for each and every one of them for simple parameter gets/sets. Supposing you wouldn't use records.
04:33:21 <hpc> extending ghc for first-class patterns would certainly be interesting, given the important place it has in optimization and codegen
04:34:12 <teneen> where are global packages installed on windows?
04:34:12 <teneen> when using cabal
04:34:17 <quicksilver> you never "have" to do pattern matchiing
04:34:24 <hpc> alpounet: possibly; data Pattern p where Pattern :: Data p => i don't even know
04:34:34 <quicksilver> you write appropriate higher level code which matches the access style you need
04:34:42 <quicksilver> and then you use those combinators
04:35:01 <hpc> or Pattern would just be a new primitive like Constraint
04:35:01 <quicksilver> (when you write the combinators the first time you need to pattern match - but that's a one-off job)
04:35:05 <hpc> provided by the compiler
04:35:16 <teneen> cabal install PKG --global ... where is the package installed?
04:35:20 <hpc> with TH-like quotes?
04:35:44 <frxx> Axman6 there are advantages of interace approach, though. 1) you don't have to modify Region to add a new item. 2) there's no risk of a non-total function
04:35:57 <nitwit> quicksilver: I personally don't have that luxury, but that is because I'm on a learning platform. academic.
04:36:13 <Axman6> frxx: assuming you don't cast anything =)
04:36:14 <hpc> the CPS-transform of first-class patterns is kind of neat
04:36:16 <Axman6> but yeah
04:36:33 <Axman6> but for many things, you want a closed type, not allowing others to add to it
04:36:37 <hpc> almost like writing a fold
04:36:39 <quicksilver> nitwit: you mean you're using a set of tools/exercise to learn haskell so you have to program it "their way"
04:36:42 <quicksilver> ?
04:37:33 <nitwit> quicksilver: yes. unfortunately.
04:38:20 <quicksilver> nitwit: that's absolutely fine. But just as a cycling school might require young learners to wear training wheels; it would not then be accurate to criticise the sport of cycling in terms of the training wheels.
04:38:58 <quicksilver> it's quite reasonable as a teaching technique to force people to do things in a certain way - to make sure they understand it - even when that way might not be characteristic of good practice
04:39:11 <Axman6> they're trying to teach you the fundamentals
04:39:24 <Axman6> where're you learning from anyway?
04:39:52 <nitwit> College. And learnyouahaskell.
04:40:27 <Axman6> yeah it's definitely trying to teach you impoeranr and fundamental ideas
04:40:29 <nitwit> quicksilver: I understand that, but the solution was pretty easy, and quite frankly dumb. I was trying to look for an optimized solution and apparently there wasn't one given how the data type was defined.
04:40:33 <Axman6> important even
04:40:43 <nitwit> it just seemed like bad practice.
04:41:07 <Axman6> it's a toy example, it's not supposed to scale. it's not teaching you any more than whatever that part of the chapter is about
04:42:07 <Axman6> the fun will come, we promise!
04:43:42 <nitwit> it's quite frustrating because they sectionize every chapter and they only come together at the end and all at the same time, which could get overwhelming.
04:47:47 <mietek> Is there a simple way to remove a package from cabal sandbox?
04:49:14 <supki> mietek: cabal sandbox hc-pkg unregister $package
04:54:53 <mietek> supki: yeah, this doesn't actually remove any of the package files, right?
04:56:30 <supki> mietek: nope, cabal can't do it
04:56:33 <supki> sandbox or not
04:57:50 <mietek> So I'm confronted with library rot
04:57:57 <mietek> Trying to build https://github.com/thlorenz/WebToInk
04:58:47 <mietek> Just over 2 years old, and fails to build
04:58:50 <nitwit> Axman6: I have to go now, I'd like to thank you and everyone else for all the help.
04:59:24 <Axman6> nitwit: good luck! I feel we were a little more confrontational with you than we usually are with newbies, so sorry for that
05:00:28 <nitwit> well I'm not very haskell friendly, I come from C.
05:01:03 <nitwit> so I wasn't very receptive in the first place, ahah.
05:02:14 <silasm> operational semantics are weird.
05:02:45 <silasm> I'm trying to make a parallel mergesort for trees and I added more parallelism to the merge operation
05:03:00 <silasm> the program runs about 40,000 times faster now, but I'm seeing less parallelism in threadscope.
05:03:21 <silasm> My guess is forcing unevaluated thunks somehow helped (also seeing a lot less memory usage), but I'm still confused by that.
05:05:46 <silasm> ah there's also the fact that my output tree structure seems to have changed; that probably has something to do with it.
05:11:03 <silasm> ohh, random realization: before everything was right spine, now it's all left spine. So the old implementation was actually tail-recursive and took forever to output, whereas the new one output lazily. Neat.
05:11:22 <silasm> anyways maybe I should stop talking to a silent channel and go to bed.
05:14:22 <quicksilver> the silent channel is always listening
05:15:07 <Axman6> we are always judging
05:16:46 <t7> is there a Data.Map like container that preserves some order
05:16:53 <t7> like [(a, b)] but with all the map stuff
05:17:07 <t7> i want fixed order of keys
05:17:20 <bartavelle> insertion order you mean ?
05:17:29 <t7> yes
05:17:40 <warpy> a linked hash map
05:19:40 <quicksilver> you could maintain a separate list/sequence of keys for order purposes
05:19:51 <t7> how is this not a thing
05:20:14 <XniX23> if you need order even when you delete and later insert some element, then my guess is you'd need a tree like structure
05:20:31 <bartavelle> there is an experimental package from kmett that is named something like "table" that, IIRC, allows for "secondary indexes", so that you can efficiently search for insertion order or key
05:20:40 <allsystemsarego> @hoogle runZipList
05:20:40 <lambdabot> No results found
05:20:46 <bartavelle> http://hackage.haskell.org/package/tables-0.3.1/docs/Data-Table.html
05:21:09 <bartavelle> that
05:21:40 <Aetherspawn> @src liftM3
05:21:40 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
05:24:13 <mr-> :t \f x y z -> return f `ap` x `ap` y `ap` z
05:24:14 <lambdabot> Monad m => (a2 -> a1 -> a -> b) -> m a2 -> m a1 -> m a -> m b
05:29:12 * hackagebot exceptions 0.3.3 - Extensible optionally-pure exceptions  http://hackage.haskell.org/package/exceptions-0.3.3 (EdwardKmett)
05:31:13 <Axman6> hmm, anyone else see the InfoQ video on Nimrod? it looks quite powerful
05:31:37 <Aetherspawn> Does anyone know what you call the difference between liftM3 and a regular treefold
05:31:57 <Aetherspawn> liftM3 folds the monad ("data") over each branch keeping the state from the tip of the last branch
05:32:08 <Aetherspawn> what's it called when you branch the state at branches instead?
05:48:41 <JuanDaugherty> gah, die internets sind stumm
05:56:37 <bezirg> hi, using the Haskell record syntax can I name only some of the fields and not all of them? I don't want to generate lookup functions for some of the fields
05:58:09 <t7> @pl return $ foldl (\t (x, y) -> tsub x y t) t (zip (map fst tvs) ts)
05:58:09 <lambdabot> return (foldl ((`ap` snd) . (. fst) . flip (flip . tsub)) t (zip (map fst tvs) ts))
05:58:21 <t7> can i make that nicer ?:3
05:59:15 * hackagebot xsd 0.4.0.1 - XML Schema data structures  http://hackage.haskell.org/package/xsd-0.4.0.1 (StefanWehr)
06:00:43 <t7> is there a foldr 3 or something?
06:01:14 <t7> @hoogle (a -> b -> c -> c) -> c -> [a] -> [b] -> c
06:01:15 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
06:01:15 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
06:01:15 <lambdabot> Control.Applicative liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
06:02:53 <t7> plz halp guiz
06:03:19 <chrra> (uncurry . flip tsub) for (\t (x, y) -> tsub x y t) at least.
06:04:36 <chrra> Or, maybe not.
06:05:45 <shiona> how does this work:
06:05:51 <shiona> :t flip (flip lookup . map swap)
06:05:52 <lambdabot> Eq b => b -> [(b1, b)] -> Maybe b1
06:05:54 <shiona> @pl flip (flip lookup . map swap)
06:05:54 <lambdabot> (. map swap) . lookup
06:06:26 <Axman6> @unpl flip (flip lookup . map swap)
06:06:27 <lambdabot> (\ b c -> lookup b (map swap c))
06:07:20 <shiona> I guess that helps
06:08:11 <bezirg> I am translating a functional language that has non-recursive let to Haskell. What is the best way to project it to Haskell's default letrec ?
06:09:00 <zq> how is State different from Reader if the latter has 'locals' and 'modify'?
06:09:08 <Saizan> bezirg: use case instead, i guess
06:09:28 <Cale> bezirg: Be careful not to reuse the same names
06:09:56 <Saizan> bezirg: if you need generalization you have to use let instead and be careful about name
06:09:59 <Saizan> *names
06:10:26 <ibid> bezirg: chain the lets (let a = ... in let b = ...)
06:11:23 <bezirg> ibid: chaining is not enough, I have to do variable name caretaking and sanitization as Cale says
06:12:07 <bezirg> ty ppl :) I will do some better translation then
06:12:08 <ibid> bezirg: a non-recursive let is usually equivalent to let chaining
06:12:26 <Saizan> ibid: let a = a + 1
06:12:41 <ibid> Saizan: yes, with that exception :)
06:12:49 <ibid> (direct recursion)
06:14:03 <piezoid> bezirg: also, there are techniques to recover implicit sharing
06:15:58 <bezirg> piezoid: I don't understand what implicit sharing is. Can you point me to these techniques?
06:16:47 <piezoid> bezirg: http://arxiv.org/pdf/1109.0784
06:18:42 <piezoid> bezirg: for example, common subexpression elimination, or observable sharing with hacky tricks using unsafePerformIO
06:19:43 <bezirg> piezoid: I will take a look at the article, ty very much
06:19:59 <nick43> .ticker  ppc
06:23:23 <SamanthaD> I have a question about GHC optimization: If I have a list where the value of an element is a function of its index like [x+1 | x <- [1..]] and I, say, index to the 20'th element, is GHC able to optimize my code so that the program doesn't actually iterate over the whole list (up to element 20)?
06:24:14 <Cale> no, not generally
06:24:26 <Cale> You might be able to make that happen with some RULES pragmas
06:24:49 <SamanthaD> I don't know how to use those yet. Thanks, I'll look into it
06:24:54 <Cale> But there are no special optimisations of that sort for !!
06:26:15 <roconnor> I feel like I should write a blog post "Containers are Containers"
06:26:22 <Cale> roconnor: :D
06:26:34 <roconnor> and "Haskell has no computations"
06:27:20 <Feuerbach> roconnor: containers are containers? you're oversimplifying again
06:27:29 <Cale> roconnor: It would be much edgier to name it  "Containers are not Containers"
06:27:45 <roconnor> Feuerbach: :D
06:27:58 <roconnor> Feuerbach: Bad analogy?
06:30:21 <roconnor> Hmm, there ought to be some lens derivitive for A ~ F(B) for a container (not necessarily finitary) F.
06:30:25 <Feuerbach> can one put a burrito into a container? and does that make the container a Put monad? I'm confused
06:30:26 <Cale> roconnor: "If any property of two things differ, they themselves differ: Analogies considered harmful"
06:30:45 <roconnor> "Containers are Analogies"
06:31:15 <warpy> Analogies are Containers
06:31:22 <warpy> of similarity ...
06:31:25 <Cale> Analogies are not not Analogies
06:31:45 <quchen> But not (not not analogies are analogies)
06:32:18 <warpy> not all analogies are analogies
06:32:55 <Feuerbach> warpy: because some of them are containers?
06:33:26 <warpy> maybe. i am not sure.
06:34:12 <quchen> Cale: Analogies can be equivalence classes on a set of different things though. 2 and 7 differ, but if you prefer thinking mod 5 then they share some properties.
06:35:17 <quchen> My Haskell intuition is mostly based on flawed analogies. (Well, wouldn't be much of an intuition otherwise.)
06:35:31 <Tekmo> Analogies are good up to isomorphism
06:39:23 <Cale> "If for all properties C of x, y and an analogy between x and y, we have that for all x, C holds for the reflexive analogy between x and x, then for all x and y, and analogies p between x and y, C holds for x, y and p.
06:39:24 <Cale> "
06:40:15 <roconnor> maybe my second title ought to be "Functions are not Computations"
06:42:30 <Kinnison> roconnor: "Your weak head is my normal form" ?
06:42:43 * Kinnison hides
06:43:48 <Cale> That probably needs parens ;)
06:45:16 <Tekmo> Everything you wanted to know about functors, but were too afraid to ask
06:45:48 <Cale> "If (for all properties C of (x, y and an analogy between x and y), we have that for all x, C holds for x, x, and the reflexive analogy) then for all x and y, and analogies p between x and y, C holds for x, y and p."
06:49:27 <XniX23> Cale: remember the MonadTwo example from yesterday?
06:49:40 <XniX23> http://lpaste.net/98644
06:49:43 <Cale> XniX23: yes
06:50:26 <Cale> You're missing the second = sign in >>== in the last line (I think I made that typo yesterday)
06:50:28 <XniX23> the f function in the bind operation... that has to be the function returnTwo right?
06:50:42 <Cale> No, it doesn't
06:50:50 <Cale> It can be any function
06:51:05 <Cale> x >>== returnTwo = x
06:51:11 <Cale> would be one of the laws for MonadTwo
06:51:19 <Cale> If I'd written those out :)
06:51:37 <Cale> (i.e. that any instance should have to satisfy)
06:51:39 <zq> > (\x -> x) :: a -> b
06:51:41 <lambdabot>  Couldn't match expected type `b1' with actual type `a1'
06:51:41 <lambdabot>    `b1' is a rigid type variable bound by
06:51:41 <lambdabot>         an expression type signature: a1 -> b1 at <interactive>:1:1
06:51:41 <lambdabot>    `a1' is a rigid type variable bound by
06:51:41 <lambdabot>         an expression type signature: a1 -> b1 at <interactive>:1:1
06:52:10 <XniX23> but in order to work, wouldn't it have to have (a -> b -> M c d) ?
06:52:23 <Cale> :t (\x -> x)
06:52:24 <lambdabot> t -> t
06:52:48 <zq> different naming necessitates that two type vars are distinct?
06:52:49 <Cale> XniX23:  f x y = Just (x + y) (x - y)
06:52:50 <Cale> zq: It *allows* that they're distinct
06:53:31 <zq> Cale: the lambdabot error implies that it's necessary and sufficient
06:53:41 <XniX23> yes this one has a type of (a -> b -> M c d), therefore its a valid function for bind
06:53:58 <Cale> zq: If (\x -> x) really could be given type a -> b, then I could use it to break the type system by using it as a function Int -> String
06:54:34 <zq> Cale: so ghc not only allow but requires
06:55:05 <Cale> zq: I could also apply it at type Int -> Int
06:55:33 <Cale> zq: It doesn't *require* that a and b be different, it just says that they're allowed to be different.
06:55:39 <Cale> Each of them could be any type at all
06:55:54 <Cale> For example
06:55:54 <Cale> :t map
06:55:55 <lambdabot> (a -> b) -> [a] -> [b]
06:56:15 <Cale> I can use this with a = Integer, and b = Integer:
06:56:24 <Cale> > map (\x -> x * 10) [1..10]
06:56:26 <lambdabot>  [10,20,30,40,50,60,70,80,90,100]
06:58:13 <Cale> zq: However, the definition of map isn't allowed to make any assumption that a and b are the same type
06:58:31 <Cale> If I use something of type a where I need something of type b, there will be a type error
06:59:10 <Cale> :t let { mymap :: (a -> b) -> [a] -> [b]; mymap f [] = []; mymap f (x:xs) = x : mymap xs } in mymap
06:59:11 <lambdabot>     Couldn't match expected type `[b]' with actual type `[a0] -> [b0]'
06:59:11 <lambdabot>     In the return type of a call of `mymap'
06:59:11 <lambdabot>     Probable cause: `mymap' is applied to too few arguments
06:59:18 <Cale> :t let { mymap :: (a -> b) -> [a] -> [b]; mymap f [] = []; mymap f (x:xs) = x : mymap f xs } in mymap
06:59:19 <lambdabot>     Couldn't match expected type `b1' with actual type `a1'
06:59:19 <lambdabot>       `b1' is a rigid type variable bound by
06:59:19 <lambdabot>            the type signature for mymap :: (a1 -> b1) -> [a1] -> [b1]
06:59:53 <Cale> The type checker catches the fact that I didn't apply the function. x :: a which is allowed to be a different type from f x :: b
07:00:55 <Cale> er, that was an incomplete sentence :)
07:01:03 <Cale> x :: a is allowed to be a different type from f x :: b
07:01:09 <Cale> there, now it's better :)
07:01:25 <zq> you're totally missing my point
07:01:46 <sajt> I have some static structures in my code which would need to be documented in-place. can I do this in a way which can be processed automatically?
07:02:04 <Thooms> haddock ?
07:02:11 <sajt> I'm looking for some form of annotation syntax
07:02:25 <Cale> Okay, while defining map, you may assume that a and b are different, but really it's just that you may not assume that they're the same.
07:02:31 <zq> ugh
07:03:19 <sajt> Thooms: I've looked at it and it's very nice for libs, but I have large tree's in my code and I'd need to document the leaves
07:03:27 <Cale> In defining a function of type a -> b, you're not allowed to assume that b = a, so (\x -> x) doesn't fulfill the requirement that the function produce a value of type b.
07:03:45 <zq> what i asked: given an expression E that haskell infers to have type T0, is it legal to annotate E with a type T1 such that T0 < T1 or is it absolutely required that T0 == T1
07:03:48 <roconnor> Fuuzetsu: ping
07:03:48 <zq> Cale: ^
07:04:06 <zq> Cale: the answer to that is yes
07:04:35 <sajt> the point is: I don't want to make my structures more complex by adding docstrings to the types, but I want to be able to extract the documentation from comments
07:04:36 <Cale> Er, what is meant by < ?
07:04:50 <zq> Cale: all that you've been saying is equivalent to rehashing that if (a -> b) :: T0 and (a -> a) :: T1 then T1 < T0, which is trivial
07:04:53 <XniX23> Cale: is that returnTwo just some sort of constructor for the MonadTwo then?
07:05:26 <Cale> zq: I missed your original question then.
07:05:40 <Cale> zq: I assumed you were asking why (\x -> x) can't be given type a -> b
07:05:41 <zq> Cale: my point was why (\x -> x) :: a -> b yields an error. i was thinking that ghc would be intelligent to infer that a == b
07:06:36 <XniX23> i dont see what would be different if i removed the lines containing returnTwo (in class and instance)
07:06:53 <roconnor> (\x -> x) :: a -> b means (\x -> x) :: forall a b. a -> b
07:07:01 <zq> or to rephrase, in an HM system {is it required}/{can it be the case} that typevars are unified?
07:07:07 <Cale> XniX23: If you want, you can think of it as a field in the dictionary for the MonadTwo instance.
07:08:02 <frohe> hi! why the following program doesn't print the lines? http://lpaste.net/98646
07:08:07 <zq> roconnor: and?
07:08:47 <Cale> XniX23: One of the first things GHC will do to the type classes in your Haskell program is turn each of the class declarations into the definition of a record type, whose fields have the same types as the specified methods.
07:09:27 <Cale> XniX23: Each instance declaration will be converted to a record of that type (or sometimes a function between class dictionary records, if the instance has a class context on it)
07:10:01 <Cale> XniX23: Then types like   foo :: (MonadTwo m) => ...
07:10:11 <roconnor> zq: and hence a and b are independent type variables.
07:10:13 <Cale> XniX23: are converted into  foo :: MonadTwo m -> ...
07:10:20 <roconnor> so yes, different naming necessitates that two type vars are distinct.
07:10:23 <Cale> Where now MonadTwo m is this record type
07:11:14 <Cale> zq: You can do -fdefer-type-errors and it will do what you're suggesting it do everywhere.
07:11:36 <Cale> zq: and then fill in all the type equalities it can't prove with runtime errors.
07:12:54 <zq> Cale: didn't know about this one, thanks
07:13:12 <Cale> Which kind of sort of makes things "dynamically typed" only it's still completely different from that, because the type checker actually ran and did type inference and distributed type class instances around the program and stuff.
07:13:33 <Cale> and there's no runtime type checks
07:14:17 <Thooms> sajt: iirc you can document constructors separately, would that suit your needs ?
07:14:57 <sajt> Thooms: I have lists and tuples :-/
07:15:41 <Thooms> can you paste me a sample code that you would want to document :) ?
07:16:02 <sajt> Thooms: sure, give me a sec
07:18:01 <Cale> zq: Ah, it still seems you can't write "safe unsafeCoerce" this way though. If you write foo :: a -> b; foo x = x then even if you use foo at type String -> String, it fails with an error, which was probably just deferred from the body of foo.
07:18:54 <sajt> Thooms: http://lpaste.net/236724973719257088
07:19:02 <XniX23> Cale: so it's no longer just a typeclass but a type (since its converted to a record) which satisfies the MonadTwo typeclass?
07:19:18 <sajt> Thooms: for example I have some table-like data in the source like in the example
07:19:21 * hackagebot monadiccp-gecode 0.1.2 - Constraint Programming  http://hackage.haskell.org/package/monadiccp-gecode-0.1.2 (JanTikovsky)
07:19:30 <Cale> XniX23: Which carries around the implementation of the type class methods
07:19:34 <sajt> Thooms: and want to document the fields one-by-one
07:20:29 <XniX23> Cale: thank you very much
07:20:32 <Cale> XniX23: For example, sort :: (Ord a) => [a] -> [a] gets turned into a function  sort :: Ord a -> [a] -> [a]
07:20:40 <Thooms> if I understand well what you're trying to do, I don't know any method that can do that
07:20:48 <Thooms> s/can/allow/
07:20:53 <Cale> where Ord a is a record containing, e.g. compare :: a -> a -> Ordering, and (<=) :: a -> a -> Bool
07:20:55 <Cale> and so on
07:21:34 <sajt> Thooms: I think I'll just write some perl to extract the documentation from the comments
07:21:35 <Cale> XniX23: and then anywhere that you used the methods of the type class, it just unpacks them from that record
07:21:40 <Thooms> but if you know a priori the entire thing (I guess so, as you want to document it), just encode it in a datatype
07:22:11 <Thooms> hum, forget that, that won't work
07:22:20 <Cale> XniX23: This is why we're allowed to have things like:
07:22:29 <Thooms> I guess you can extract it with perl then sajt
07:22:34 <Cale> read :: (Read a) => String -> a
07:22:57 <sajt> Thooms: yeah, I don't see any alternative either
07:22:58 <Thooms> but if you find something cleaner, feel free to ping me, I'm curious
07:23:17 <sajt> Thooms: thanks, will do
07:23:46 <Thooms> :)
07:23:54 <Cale> XniX23: which are polymorphic in the type of their *result* in a way which doesn't seem possible from the parameter -- they get compiled to functions which take an extra parameter that specifies how to implement all the operations of the Read typeclass
07:24:52 <Cale> XniX23: You can't do polymorphism like that in most OO languages, because the polymorphism you get there requires you to have an object of the given type in order to get started.
07:31:34 <XniX23> Cale: so (Read a) becomes Read a -> ? and has its implementation of methods of Read?
07:31:54 <Cale> yeah
07:32:34 <XniX23> that means that a must be an instance of Read right?
07:32:36 <b80905> i am trying to do this https://projecteuler.net/problem=4 but i can't figure out why my code isn't working: let palindrome n = reverse s == s where s = show n in maximum [a*b | a <- [100..999], b <- [100..999], palindrome a*b]
07:33:11 <mauke> SPACES AROUND OPERATORS PLZ
07:33:24 <mauke> specifically, palindrome a * b
07:34:45 <b80905> mauke: putting a*b in parentheses solved my problem!
07:36:02 <b80905> mauke:thanks
07:36:27 <Thooms> :D :D
07:40:26 <zq> anyone have an lhs of thih?
07:40:34 <t7> @hoogle find
07:40:34 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
07:40:34 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
07:40:34 <lambdabot> Data.ByteString.Char8 find :: (Char -> Bool) -> ByteString -> Maybe Char
07:40:43 <t7> @hoogle first
07:40:44 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
07:40:44 <lambdabot> Text.PrettyPrint.HughesPJ first :: Doc -> Doc -> Doc
07:40:44 <lambdabot> package first-class-patterns
07:40:59 <t7> @hoogle (a -> Bool) -> [a] -> a
07:41:00 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
07:41:00 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
07:41:00 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
07:41:11 <t7> dagnamit
07:41:37 <shiona> what is it you are actually looking for?
07:41:54 <zq> :t head . filter
07:41:55 <lambdabot>     Couldn't match type `[a0] -> [a0]' with `[c0]'
07:41:55 <lambdabot>     Expected type: (a0 -> Bool) -> [c0]
07:41:55 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> [a0]
07:42:02 <bennofs> :t fmap head . filter
07:42:03 <lambdabot> (a -> Bool) -> [a] -> a
07:42:08 <zq> yeah that
07:42:15 <bennofs> :t fmap fromJust . find
07:42:17 <lambdabot> (a -> Bool) -> [a] -> a
07:42:33 <t7> also
07:42:41 <duairc> Does readsPrec ever return a list whose length is bigger than 1? If so, in what circumstances?
07:42:42 <bennofs> zq: This function is dangerous though. It fails with an error if there is no match
07:43:11 <t7> i have a like like [1, 2, 3] and i wanna generate an infinite list like [1, 2, 3, 11, 12, 13, 111, 112, 113 ...
07:43:19 <t7> ah i know
07:45:12 <bennofs> > let ls = [1,2,3] ++ zipWith (+) (map (10 *) ls) (cycle [1,2,3]) in ls
07:45:13 <lambdabot>  [1,2,3,11,22,33,111,222,333,1111,2222,3333,11111,22222,33333,111111,222222,3...
07:45:56 <bennofs> oh, that's wrong :P
07:49:24 * hackagebot bed-and-breakfast 0.4.3 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.4.3 (JulianFleischer)
07:49:48 <bennofs> t7: You can create that list by adding the lists [1,2,3,1,2,3,1,2,3 ... and [0,0,0,10,10,10,110,110,110,1110,1110,1110 ...
07:53:59 <t7> huh
07:57:51 <aleksejs_> > map (flip replicateM [1..3]) [1..]
07:57:52 <aleksejs_>  t7
07:57:53 <lambdabot>  [[[1],[2],[3]],[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]],[[1,1...
07:58:17 <t7> aha thanks
07:58:19 <t7> list monad
07:58:26 <bennofs> > let xs = [0,0,0] ++ [ 10 * x + 10 | x <- xs ]; ys = cycle [1,2,3] in zipWith (+) xs ys
07:58:27 <lambdabot>  [1,2,3,11,12,13,111,112,113,1111,1112,1113,11111,11112,11113,111111,111112,1...
07:58:43 <t7> i actually meant "12" sorry :P
07:58:50 <t7> not 12
08:00:22 <bennofs> > let xs = ["","",""] ++ [ '1':x | x <- xs ]; ys = cycle ["1","2","3"] in zipWith (++) xs ys
08:00:23 <lambdabot>  ["1","2","3","11","12","13","111","112","113","1111","1112","1113","11111","...
08:01:32 <SamanthaD> does anyone know how to make M-x haskell-indent-align-guards-and-rhs not align the :: in the type signature with the = assignment operators?
08:01:59 <mauke> > iterate (map ('1' : )) ["1", "2", "3"]
08:02:01 <lambdabot>  [["1","2","3"],["11","12","13"],["111","112","113"],["1111","1112","1113"],[...
08:02:06 <mauke> > concat $ iterate (map ('1' : )) ["1", "2", "3"]
08:02:07 <lambdabot>  ["1","2","3","11","12","13","111","112","113","1111","1112","1113","11111","...
08:09:56 <aleksejs_> I have an input 1234 and i need to get [1,12,123,1234,234,34,4]
08:10:46 <frohe> how getContents really works guys? http://lpaste.net/98646
08:12:26 <benj_>  frohe, length will force all the lines to be read, before printing
08:13:25 <frohe> benj_: why the second program reads a line, then prints, reads another line, then prints it, etc ?
08:13:38 <benj_> probably because of the way input and output are buffered
08:14:14 <benj_> getContents >>= putStr (the 2nd program) doesn't require all the contents to be in memory at once
08:14:16 <benj_> so buffering can work
08:15:45 <frohe> benj_: it works like getLine, right?
08:16:36 <benj_> I would guess the input is buffered in fixed-sized chunks rather than lines
08:17:03 <benj_> but you're seeing the output appear line-by-line because of line-mode buffering of your console
08:17:26 <frohe> ah, thanks :)
08:31:03 <stephenmac7> I have filenames like: someName-that_can_have-dashes-2-2.0.344.jar
08:31:09 <halvorg> http://lpaste.net/98653 is there a way to write this cleaner? with a higher order function of some sort
08:31:46 <stephenmac7> How could I get the name (someName-that_can_have-dashes) and the version (2-2.0.344)?
08:33:23 <halvorg> stephenmac7: split the string at every dash and go from there? bit slow probably.
08:33:34 <dgpratt> are you around, Cale?
08:33:50 <stephenmac7> halvorg: But how would I separate the name from the version?
08:34:04 <stephenmac7> If they can both have dashes
08:35:17 <Cale> dgpratt: hi
08:35:26 <stephenmac7> halvorg: Basically, I have a directory full of files then I have an object which has information about possibly updated versions
08:35:32 <dgpratt> are you still lambdabot's benefactor, Cale?
08:35:42 <Cale> dgpratt: nope, I'm not running it now
08:35:44 <Cale> int-e is
08:35:49 <dgpratt> oh, ok
08:35:51 <halvorg> stephenmac7: I understand, I was trying to formulate an answer, but there are some edge cases
08:35:51 <dgpratt> thanks
08:35:57 <stephenmac7> *object: Whatever a data type is called once an instance is made
08:38:03 <stephenmac7> halvorg: I could, of course, keep a file with the information
08:38:09 <stephenmac7> That might be cleaner
08:39:04 <stephenmac7> Just read and show a [(SomeIdentifier, FilePath, CurrentVersion)]
08:39:10 <stephenmac7> type SomeIdentifier = String
08:39:24 <stephenmac7> type CurrentVersion = String
08:39:54 <stephenmac7> halvorg: Would that be better?
08:40:30 <stephenmac7> Or should I do something like [SpecialFile] where data SpecialFile = SpecialFile String String String
08:40:32 <halvorg> stephenmac7: Probably, but I'm no expert
08:40:51 <stephenmac7> Okay, I think I'll do that
08:40:56 <stephenmac7> Thanks
08:41:01 <halvorg> You'd run into quite a few problems if you try to parse filenames like that unless you're very strict on how you name them
08:41:04 <halvorg> thats all I know
08:41:20 <stephenmac7> Okay.
08:45:13 <XniX23> halvorg: you have a simple recursive function, what kind of pattern did you have in mind?
08:45:22 * hackagebot som 7.2.0 - Self-Organising Maps  http://hackage.haskell.org/package/som-7.2.0 (AmyDeBuitleir)
08:46:34 <halvorg> XniX23: I have no idea, that was the thing. I made loads of recursive fold functions before I started using folds
08:46:45 <halvorg> If that makes sense
08:47:43 <XniX23> halvorg: you want to make function gg nicer?
08:47:56 <halvorg> yes
08:49:45 <stephenmac7> If there a better way to write (in an IO do): if someBool then doSomeAction args else return ()
08:49:55 <eikke> stephenmac7: 'when'
08:49:58 <simpson> :t when -- stephenmac7
08:50:00 <lambdabot> Monad m => Bool -> m () -> m ()
08:50:00 <eikke> :t when
08:50:01 <lambdabot> Monad m => Bool -> m () -> m ()
08:50:36 <stephenmac7> Thanks, eikke and simpson
08:50:59 <simpson> stephenmac7: Note, BTW, that `when` is just a combinator for what you wrote.
08:51:01 <simpson> @src when
08:51:01 <lambdabot> when p s = if p then s else return ()
08:51:14 <simpson> But combinators are very useful.
08:51:16 <stephenmac7> simpson: That's fine. It looks nicer
08:51:37 <stephenmac7> I would have made a function like that anyway... if it wasn't already in Control.Monad
08:52:18 <XniX23> halvorg: i dont know of any patterns for this cases, not sure you need let r' = y though
08:53:04 <halvorg> Alright XniX23, thanks. It was a long shot : )
08:53:13 <kstt> hi guys
08:54:49 <kstt> I would like to extract and validate text fields coming from a Gtk form.
08:55:20 <kstt> Ideally I'd make a datatype representing the model the the form mirrors.
08:55:48 <kstt> extraction must happen in IO
08:56:14 <kstt> validation, at the moment, can be as simple as return a (Maybe ModelType)
08:56:38 <kstt> The maybe monad (or applicative) would help a lot
08:57:03 <kstt> Does that sound right to you ?
08:57:07 <ReinH> kstt: maybe digestive functors would be useful
08:57:32 <kstt> isn't digestive a web thing ?
09:03:34 <kstt> well, let's do ReaderT IO this time :)
09:03:36 <kstt> thank you
09:04:29 * hackagebot BlogLiterately 0.7.1.1 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1.1 (BrentYorgey)
09:13:39 <zett_zelett> I’m trying to make something (well the type Read a => Tree a for some type constructor Tree) an instance of Read.
09:14:00 <zett_zelett> But I don’t know what to do and I can’t really figure it out.
09:24:35 * hackagebot sundown 0.6 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.6 (FrancescoMazzoli)
09:26:32 <SamanthaD> is there a way to ask GHCI to pretend that a type declaration doesn't exist and tell me what it thinks the type ought to be?
09:26:52 <quchen> :t
09:27:01 <quchen> :t id -- what's the type of id?
09:27:03 <lambdabot> a -> a
09:27:50 <alireza> hi, can someone please tell me what the meaning of "=<<" is?
09:27:51 <SamanthaD> quchen: yes... but I meant if I specified a type declaration in the source and I want to know if the function could have had a more liberal type than it really does
09:27:57 <Cale> SamanthaD: Not without commenting it out
09:28:01 <eikke> :t (=<<)
09:28:02 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:28:10 <eikke> alireza: if you know (>>=), that should be clear :)
09:28:17 <SamanthaD> Cale: Thanks, I didn't think there was. It would be a really handy thing though
09:28:19 <eikke> (see the type)
09:28:25 <Cale> alireza: It's (>>=) with the arguments flipped
09:29:27 <aggregate> :type (=<<)
09:29:39 <Cale> aggregate: f =<< x is the action which will first execute the action x, getting some result v, and then execute f v, getting some result w which it then produces as its own result.
09:29:50 <alireza> :t (=<<)
09:29:51 <lambdabot> Monad m => (a -> m b) -> m a -> m b
09:29:58 <alireza> I dont know what Monads are
09:30:13 <Cale> alireza: Where is this showing up?
09:30:19 <alireza> just want to know what the operation =<< does
09:30:26 <Cale> You probably don't *have* to know what monads are in general
09:30:39 <alireza> Cale: in this tutorial https://rawgithub.com/ndmitchell/tagsoup/master/tagsoup.htm
09:30:43 <Cale> But we need to know what type of thing x is in f =<< x to tell you what x does
09:30:56 <Cale> er to tell you what (=<<) does rather
09:31:08 <aleksejs_> I don't get it, what's the problem here? http://vpaste.net/HrsiE
09:31:09 <Cale> Right, so this code:
09:31:14 <Cale> openURL x = getResponseBody =<< simpleHTTP (getRequest x)
09:31:16 <Cale> is the same as
09:31:17 <alireza> yes
09:31:35 <Cale> openURL x = do v <- simpleHTTP (getRequest x); getResponseBody v
09:31:52 <Cale> which is the same as
09:31:52 <Cale> openURL x = do v <- simpleHTTP (getRequest x); w <- getResponseBody v; return w
09:32:17 <Cale> clearer?
09:32:35 <alireza> Cale: ok. so <<= means a list of operation which when executed, will return something
09:32:45 <alireza> Cale. yes it is clearer now
09:32:57 <Cale> alireza: er, no... not a list of operations
09:33:00 <aleksejs_> :t fst . properFraction $ logBase 10 1234
09:33:01 <lambdabot> Integral c => c
09:33:14 <aleksejs_> :t fst . properFraction . logBase 10
09:33:15 <lambdabot> (Floating b, Integral c, RealFrac b) => b -> c
09:33:19 <alireza> Cale: but it is basically a do block
09:33:29 <alireza> Cale: isnt it?
09:33:39 <Cale> alireza: Yeah, f =<< x = do v <- x; f v
09:34:10 <alireza> Cale: thanks
09:34:19 <Cale> (Eventually you'll discover that do-notation is actually translated into uses of >>= rather than the other way around)
09:34:42 <Cale> aleksejs_: It's hard to say what's wrong if you don't post the error...
09:35:00 <aleksejs_> Cale, same old ambiguoug
09:35:03 <aleksejs_> s*
09:35:23 <aleksejs_> because I dared to use logBase in acual code
09:35:36 <Cale> aleksejs_: *what's* ambiguous?
09:35:37 <aleksejs_> actual*
09:35:50 <Cale> Could you provide the complete error message?
09:36:11 <Cale> I guess I can take this source and find out on my own...
09:36:27 <zcourts> I'm trying to wrap a C fn, though it compiles my fn causes a segfault. https://gist.github.com/zcourts/8477405 - any pointers on how to do this better?
09:36:36 <Cale> ah!
09:36:38 <monochrom> verbatim code and verbatim outcome. in short, a self-contained experiment that other people can reproduce
09:36:41 <aleksejs_> Cale, here's an error http://vpaste.net/KzDCh
09:37:54 <aleksejs_> I think it's easier to generate a list [10,100,1000..] than try to use logBase
09:37:58 <Cale> aleksejs_: okay, so your problem is that you're both using div and logBase 10 on the same number
09:38:11 <Cale> div only works on integral values
09:38:41 <Cale> (i.e. types like Integer, Int, Word8, etc.)
09:38:53 <Cale> while logBase 10 only works on fractional types, like Double, Float, etc.
09:38:55 <aleksejs_> :t fst . properFraction . logBase 10 1234
09:38:56 <lambdabot> (Floating (a -> b), Integral c, RealFrac b) => a -> c
09:39:19 <aleksejs_> so, in this case, he thinks 1234 is Floating?
09:39:33 <Cale> :t properFraction
09:39:34 <lambdabot> (Integral b, RealFrac a) => a -> (b, a)
09:39:42 <Cale> :t (fst . properFraction . logBase 10) 1234
09:39:43 <lambdabot> Integral c => c
09:39:56 <Cale> :t (fst . properFraction . logBase 10)
09:39:57 <lambdabot> (Floating b, Integral c, RealFrac b) => b -> c
09:40:10 <Cale> So okay, look there ^^
09:40:17 <Cale> b needs to be Floating and RealFrac
09:40:22 <Cale> like Double or Float
09:40:31 <Cale> (those are pretty much your only options)
09:40:41 <Cale> c needs to be Integral
09:40:44 <int-e> zcourts: Check the type of the function, I expect it takes a c string rather than a pointer to one.
09:40:45 <Cale> like Integer
09:40:49 <geekosaur> zcourts: does the C function actualy take (char **)?
09:40:53 <aleksejs_> I've added fromIntegral, now it works
09:40:55 <geekosaur> (CString includesthe Ptr)
09:41:05 <Cale> cool :)
09:41:07 <int-e> zcourts: (note that type CString = Ptr CChar)
09:41:53 <zcourts> geekosaur:  No, its signature is MurmurHash3_x86_32 (const void *key, int len, uint32_t seed, void *out)
09:42:09 <geekosaur> ok, so you wanrt CString, not Ptr CString
09:42:34 <mauke> I'd use Ptr CChar
09:43:08 <zcourts> geekosaur:  Ok
09:43:13 <zcourts> mauke:  why?
09:43:40 <mauke> because this isn't a C string and I don't like the CString alias anyway
09:43:46 <int-e> zcourts: It also seems to return a CInt, though that mismatch is probably not going to cause crashes.
09:45:15 <zcourts> int-e:  I didn't copy that correctly, it returns void so void MurmurHash3_x86_32 (const void *key, int len, uint32_t seed, void *out)
09:45:59 <int-e> zcourts: ah, so it does. ok then, my mistake.
09:46:20 <zcourts> mauke:  fair enough, I'll try your suggestion
09:46:41 <zcourts> int-e: np, was my fault for missing void :)
09:46:55 <zcourts> thanks all, will try your suggestions now
09:49:41 <int-e> zcourts: note also that you will have to allocate the output buffer (of four bytes?) yourself.
09:51:37 <zcourts> int-e:  missed that, thanks
10:04:34 * hackagebot purescript 0.2.15.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.15.2 (PhilFreeman)
10:27:16 <danilo2> Hello! Is there in TH a way to get VarT from TH splice? I mean, If I write "[t| "a" |]" I get "LitT (StrTyLit "a")", but If I write "[t|a|]" I'm getting error, that a is not in scope, but I would love to get "VarT "a" " - is it somehow doable?
10:29:42 <bennofs> danilo2: Maybe [t|forall a. a|] works?
10:30:02 <danilo2> bennofs:  Illegal symbol '.' in type
10:30:13 <danilo2>  bennofs: wait
10:30:54 <danilo2> bennofs: Thank you!
10:31:29 <danilo2> bennofs: but it is not the solution I'm looking for. It gives forallT as a result. It would be great to get simply VarT without the forallT
10:38:54 <enthropy> danilo2: parse it with haskell-src-meta?
10:40:14 <danilo2> enthropy: You are talking about making custom quoter? (http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/template-haskell.html#th-quasiquotation)
10:41:29 <enthropy> there's probably one out there
10:42:41 <enthropy> http://hackage.haskell.org/package/haskell-src-exts-qq
10:43:42 <danilo2> enthropy: Hmm, very interesting! maybe it solves my problems! Thank you, I'm looking into it :)
10:43:48 <enthropy> though that package is slightly broken since knownExtensions enables and then disables all the extensions
10:47:43 <tac> Is it just me, or is Hackage and GHC documentation not properly SEO'd?
10:48:00 <tac> It's something that I've noticed for years. You always get old versions of the docs showing up in google search results.
10:48:08 <Twey> Also zvon.org
10:48:10 <tac> I would think that kind of thing ought to be preventable, right?
10:49:38 * hackagebot unsafely 0.1.0.0 - Flexible access control for unsafe operations and instances  http://hackage.haskell.org/package/unsafely-0.1.0.0 (HiromiIshii)
10:49:40 * hackagebot unsafely 0.1.0.0.1 - Flexible access control for unsafe operations and instances  http://hackage.haskell.org/package/unsafely-0.1.0.0.1 (HiromiIshii)
10:50:18 <Twey> tac: The problem is that they're different pages, so Google doesn't know that one is an older version of the other
10:50:29 <b80905> why does ghc not want to interpret this code: [p | p <- [1..], prime p] !! 10001 where prime n = ldf 2 n == n where ldf k m = if m `mod` k == 0 then k else ldf (k+1) m ? "parse error on input `where'"
10:51:02 <Twey> tac: So $old_version gets a ton of clicks, which bumps its rank, and then $new_version has to catch up, which takes a while (especially because people are still clicking $old_version because it's at the top)
10:51:02 <tac> Twey: Yeah... but I would think since haskell.org seems to own all the pages, it should be able to provide hints as to what is relevant
10:51:17 <Twey> AFAIK Google doesn't support anything like that
10:51:23 <tac> But I'm just speculating based on the fact PHP and Python don't have that problem.
10:51:35 <tac> I should say *even* PHP*
10:51:39 <Twey> What we could do is have a /latest/ URL that always displays the latest version of the page, then bump that
10:51:41 <jle`> b80905: try making it all one where
10:51:51 <tac> But they don't version. Python does version, I suppose, but the problem isn't as bad in my experience
10:51:52 <jle`> where binding semantics are different than lets
10:51:56 <geekosaur> b80905, if it's all glommed together like that then it can't make sense out of what you intended. use indentation/layout, or use braces
10:51:57 <tac> (Although since Python3, it's weird)
10:52:29 <b80905> geekosaur: how does one use braces?
10:52:48 <Twey> That way the /latest/ URL appears at the top and gets all the clicks, and when a new version of the package comes Google sees the /latest/ page change instead of (well, as well as) a new page being added
10:52:59 <danilo2> enthropy: I'm probably missing something simple, but "runQ [t| Int |]" works and "runQ [typ| Int |]" results in  "parse error on input ‛|]’", do you know why? :(
10:53:28 <Twey> Python doesn't version, PHP doesn't version
10:53:44 <c_wraith> danilo2: the former is valid with the TemplateHaskell extension.  The latter requires the QuasiQuotes extension
10:54:03 <geekosaur> b80905, roughly ... where { prime n = ... where { ... }; {- other outer `where` stuff here -} }
10:54:18 <Twey> Well, Python has separate docs for 2 and 3 (and suffers the same problem: the top result is still Python 2)
10:54:19 <geekosaur> it's a pain though, better is to use layout
10:54:28 <Twey> Python libs do the /latest/ thing I just suggested, usually
10:54:32 <tac> Yeah
10:54:39 <tac> pre-Python 3, things weren't bad, though
10:54:45 <jle`> Twey: but isn't Python 2 more popular than Python 3 in general?
10:54:51 <jle`> maybe I'm just in the wrong circles
10:55:09 <danilo2> c_wraith: Ah, I see, thank you
10:55:10 <jle`> so 2 over 3 in google is a good thing
10:55:14 <Twey> PHP just jams everything onto one page and adds notes for where stuff changed (sometimes…)
10:55:30 <tac> The choice to move to Python 3 was really really surprising. Python 2 was just so firmly established, you'd have to uproot half the community in order to transition
10:56:10 <Twey> jle`: To the best of my knowledge, it's currently about 50–50: Py3 is used and recommended for much new stuff, but Py2 is still around for a lot of legacy things because of the massive incompatibility
10:56:14 <geekosaur> the Python 3 thing s pretty much GvR in a nutshell
10:56:55 <b80905> geekosaur: [p | p <- [1..], prime p] !! 10001 where { prime n = ldf 2 n == n where { ldf k m = if m `mod` k == 0 then k else ldf (k+1) m }} ?
10:56:56 <Twey> jle`: But Py3 should be the top result because it should be your ‘default’, especially when presenting to newbies
10:57:25 <geekosaur> oh, wait, is that *all* of it?
10:57:43 <geekosaur> `where` is part of declaration syntax; you have no declaration at the top, just an expression
10:58:29 <b80905> geekosaur: i see.. i have to use let-in
10:58:33 <geekosaur> yes
10:58:44 <jle`> also no need to nest...
10:58:57 <jle`> you can put both prime and ldf on the same level
10:59:13 <jle`> if you did next however
10:59:19 <jle`> you wouldn't need to have m at all
10:59:28 <danilo2> c_wraith, enthropy: Is it possible to convert Language.Haskell.Exts.Syntax to Language.Haskell.TH.Type?
10:59:41 <jle`> you could just do prime n = ldf 2 == n where ldf k = if n `mod` k ... etc
10:59:41 <danilo2> *Language.Haskell.Exts.Syntax.Type
10:59:54 <jle`> *if you did nest
11:02:13 <danilo2> c_wraith, enthropy: Ok, there is toType function :) It works great - Thank you very much enthropy and c_wraith !
11:06:25 <tac> > let m = Data.Map.fromList [(0, "zero"), (1, "one")] in m ! 0
11:06:26 <lambdabot>  Not in scope: `Data.Map.fromList'
11:07:13 <tac> Is Data.Map not availble on lambdabot?
11:07:27 <solarus> :t M.fromList
11:07:28 <lambdabot> Ord k => [(k, a)] -> M.Map k a
11:07:45 <tac> > let m = M.fromList [(0, "zero"), (1, "one")] in m ! 0
11:07:46 <lambdabot>  Couldn't match expected type `GHC.Arr.Array i0 e0'
11:07:46 <lambdabot>              with actual type `Data.Map.Base.Map k0 [GHC.Types.Char]'
11:08:04 <tac> > let m = M.fromList [(0, "zero"), (1, "one")] in m
11:08:05 <lambdabot>  fromList [(0,"zero"),(1,"one")]
11:08:23 <tac> > let m = M.fromList [(0, "zero"), (1, "one")] in M.(!) m 0
11:08:24 <lambdabot>  Not in scope: data constructor `M'
11:08:27 <tac> w/e
11:08:49 <alkabetz> > let m = M.fromList [(0, "zero"), (1, "one")] in (M.!) m 0
11:08:50 <lambdabot>  "zero"
11:09:34 <alkabetz> Or, if you want your code to look really weird
11:09:43 <alkabetz> > let m = M.fromList [(0, "zero"), (1, "one")] in m M.! 0
11:09:44 <lambdabot>  "zero"
11:18:22 <danilo2> Is there a reason why "[ty| _a_ |]" compiles and "[ty| __a__ |] " does not? (using Language.Haskell.Exts.QQ) Is this a bug in Language.Haskell.Exts?
11:18:39 <skuggi> hello. i'm having some trouble trying to make an arbitrary instance: http://lpaste.net/98662
11:18:53 <danilo2> "[ty| __a__ |] " gives " Couldn't match type ‛Language.Haskell.Exts.Syntax.Type’   with ‛[Char]’
11:19:17 <danilo2> where "[ty| _a_|]  " gives "TyVar (Ident "_a_")"
11:19:26 <skuggi> The problem is that it generates completely symmetrical terms
11:20:19 <matheus23> Hello, is anyone familiar with Happstack? I have a function, lets call it 'func' :: ServerPart Response. In that function I have a bit of form-handling code inside a do notation. The problem is, that I want to run simple IO actions in that do notation, but I get the following error:
11:20:26 <enthropy> danilo2: no it's a feature read the 3rd paragraph of http://hackage.haskell.org/package/haskell-src-exts-qq-0.6.1/docs/Language-Haskell-Exts-QQ.html
11:20:42 <matheus23> Couldn't match type `IO' with `ServerPartT IO'
11:20:42 <matheus23>     Expected type: ServerPartT IO (AcidState Database)
11:20:42 <matheus23>       Actual type: IO (AcidState Database)
11:20:49 <skuggi> things like: ((-x1 & -x1) | (-x1 & -x1))
11:21:00 <matheus23> code is: https://github.com/matheus23/SecureShareHappstack/blob/master/Register.hs#L50
11:21:06 <alkabetz> matheus23: You need a 'liftIO'
11:21:18 <matheus23> just in front of the cal?
11:21:19 <alkabetz> Are you familiar with monad transformers?
11:21:23 <matheus23> call*
11:21:27 <matheus23> and no, not really ;)
11:22:00 <alkabetz> So, you probably should go skim https://en.wikibooks.org/wiki/Haskell/Monad_transformers
11:22:16 <danilo2> enthropy: Ah, ok, I didnt notice it earlier, sorry
11:22:19 <matheus23> alkabetz: thanks! :)
11:22:27 <alkabetz> matheus23: You're welcome.  Good luck!
11:24:40 * hackagebot heist 0.13.0.5 - An Haskell template system supporting both HTML5 and XML.  http://hackage.haskell.org/package/heist-0.13.0.5 (DougBeardsley)
11:25:15 <matheus23> alkabetz: thanks a lot, it works :)
11:25:32 <alkabetz> matheus23: You're welcome.
11:49:53 <eikke> anyone familiar with pipes/pipes-binary around?
11:51:42 <c_wraith> eikke: Hmm.  tekmo's here often, but doesn't appear to be at the moment
11:51:48 <eikke> so I noticed :)
11:57:11 <danilo2> Hello! I've got an inference related question. Here is a sample code: http://lpaste.net/98664 . If we look at functions f and g, we can see, they've got typed arguments using some variables.GHC infers all necessary information for these variables and this code works well. Function h does not compile - because Haskell does not infer
11:58:28 <danilo2> automatically necessary relations between these variables. I want to ask you - if can we somehow type the result of a function, like in function g, and ask Haskell to infer all other informations? It seems it works this way for all function arguments, when using ScopedTypeVariables, but not for the result one
12:00:28 <mgoszcz2> Hi. Can someone please explain what (-)<$>(*2) does?
12:01:02 <mgoszcz2> Scratch that. I know what it does. But how it works?
12:01:05 <jrmithdobbs> mgoszcz2: fmap (-) (*2)
12:01:27 <jrmithdobbs> :t <$>
12:01:28 <lambdabot> parse error on input `<$>'
12:01:34 <jrmithdobbs> :t (<$>)
12:01:35 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:01:38 <jrmithdobbs> :t fmap
12:01:39 <lambdabot> Functor f => (a -> b) -> f a -> f b
12:02:05 <quchen> It obfuscates the code, that's what it does.
12:02:16 <jrmithdobbs> ya that's a bad example
12:02:18 <quchen> For functions fmap = (.).
12:02:36 <prinsen> Had limitied success with this question yesterday. How do I generate unique names for data types in template haskell?
12:04:03 <kristof> You can fmap (-) and (*2)?
12:04:24 <quchen> You can (.)  (-) and (*2), yes.
12:04:26 <eikke> :t fmap (-) (* 2)
12:04:27 <lambdabot> Num a => a -> a -> a
12:04:45 <kristof> quchen: so functions are functors where fmap is compose
12:04:51 <kristof> quchen: Oh, I remember reading that, heh
12:05:03 <quchen> Functors don't have "compose". They have fmap.
12:05:34 <quchen> And fmap turns out to be (.) when the Functor is (r ->).
12:05:42 <kristof> ok
12:05:45 <Eduard_Munteanu> kristof: more accurately, '(->) r' is a functor with fmap = (.) for any r.
12:06:20 <kristof> Eduard_Munteanu: Is (->) r the functor or is it just (->) that's the functor?
12:06:36 <Eduard_Munteanu> kristof: the former
12:06:38 <eikke> kristof: think about the kind of a functor
12:06:52 <kristof> eikke: I don't know what order kind a functor is :(
12:07:11 <Eduard_Munteanu> (->) is a profunctor if you ask about it, but that's just a sidenote.
12:07:22 * kristof flips table
12:07:25 <kristof> This will all make sense someday
12:07:38 <ChongLi> :k Maybe
12:07:39 <lambdabot> * -> *
12:07:42 <eikke> kristof: Functor requires * -> *, so (->) wouldnt fit, (->) r does
12:07:43 <ChongLi> :k (->)
12:07:43 <lambdabot> * -> * -> *
12:07:48 <Eduard_Munteanu> kristof: do you know the '(,) r' functor?
12:07:57 <kristof> Eduard_Munteanu: negatory
12:08:18 <kristof> Don't worry about it, I'm a lost cause
12:08:39 <Eduard_Munteanu> kristof: fmap :: (a -> b) -> (r, a) -> (r, b)
12:08:58 <eikke> kristof: nobody's a lost cause in #haskell ;-)
12:09:13 <ChongLi> eikke: as long as they decide to stick around :)
12:09:42 <mgoszcz2> Ok fine. So how does ((-) . (*2)) work?
12:09:43 <tac> The problem is people sometimes throw their hands up and go back to Ruby
12:10:13 <ChongLi> > ((-) . (*2)) 10 1
12:10:15 <lambdabot>  19
12:10:32 <Twey> prinsen: http://hackage.haskell.org/package/template-haskell-2.5.0.0/docs/Language-Haskell-TH-Syntax.html#v:NameU
12:10:44 <Eduard_Munteanu> kristof: basically just mapping over the second component of a pair. Anyway, the point was (,) isn't a Functor, but '(,) r' is.
12:11:01 <eikke> it might be more obvious when 'f' and 'g' in (f . g) would be (b -> c) and (a -> b) instead of (a -> a) and (a -> a)
12:11:09 <kristof> Eduard_Munteanu: I'm not sure what (r, a) means in the context of a type signature, that's all
12:11:16 <nooodl> ((-) . (*2)) 10 1  ===  (-) ((*2) 10) 1  ===  (2 * 10) - 1
12:11:22 <ChongLi> :t ((-) . (*2))
12:11:23 <lambdabot> Num b => b -> b -> b
12:11:29 <jrmithdobbs> kristof: i tuple of r and a types
12:11:31 <Eduard_Munteanu> kristof: oh... They're just pairs.
12:11:32 <kristof> GOt it
12:11:38 <jrmithdobbs> s/i/a/
12:11:39 <kristof> Product type
12:11:43 <kristof> Eduard_Munteanu: ^?
12:11:48 <Eduard_Munteanu> Yeah.
12:11:52 <kristof> :^)
12:12:01 <kristof> But apparently only eager languages have product types
12:12:08 <kristof> I need to reread that article by Brian Harper
12:12:10 <merijn> heh
12:12:18 <merijn> Why would that be?
12:12:22 <ChongLi> no, it's the other way around
12:12:26 <kristof> oh, ok
12:12:27 <Eduard_Munteanu> Well, "product type" is an overloaded name.
12:12:29 <ChongLi> eager languages have sum types, lazy ones have products
12:12:38 <ChongLi> Bob Harper :)
12:12:47 <kristof> Nobody elaborate on this! I'll reread the BOB Harper blog post and figure it out on my own
12:12:57 <merijn> I don't see what sum/product type has to do with strict/lazy?
12:13:16 <merijn> (,) is a product type and Either a sum type...
12:13:21 <kristof> there is nothing quite so satisfying as processing and then understanding information on your own
12:13:23 <mgoszcz2> Thanks nooodl. I tought that (-) is evaluted first with the two argumets and (*) later.
12:13:49 <ciaranm> kristof: what's _|_ x _|_ and _|_ + _|_ ?
12:14:04 <eikke> mgoszcz2: f . g is 'f after g', like the little 'o' in maths
12:14:06 <ChongLi> mgoszcz2: composition proceeds from right to left
12:14:24 * kristof falls out of seat when seeing all the bottoms ciaranm threw in his face
12:14:41 <Twey> prinsen: I.E. use newName
12:14:54 <b80905> how do you extract a few adjacent elements from a list?
12:15:06 <ChongLi> b80905: with take
12:15:24 <mcstar> with drop and take
12:15:26 <geekosaur> but if you are making heavy use of "adjacent" then lists may not be the type you want
12:15:40 <ChongLi> > take 5 . drop 4 $ [1..20]
12:15:41 <lambdabot>  [5,6,7,8,9]
12:15:51 <Eduard_Munteanu> merijn: I don't really get it either, but perhaps it refers to pattern-matching being eager vs passing functions as data
12:15:57 <mcstar> ^ shorthand for [5..9]
12:16:00 <mcstar> XD
12:16:13 <prinsen> Twey: That does'nt work
12:16:40 <danilo2> Hello! I've tried to simplify the example. Could somebody tell me, why haskell allows me to write function h1, but does not compile h2 here? The purpose is to generate a hasell code with typed function output (which is in a monad, but we do not care what monad it is): http://lpaste.net/98667
12:16:52 <Eduard_Munteanu> It's certainly not eager = sums, lazy = products at face value though.
12:17:04 <ChongLi> prinsen: http://hackage.haskell.org/package/template-haskell-2.5.0.0/docs/Language-Haskell-TH-Syntax.html#g:1
12:17:08 <prinsen> Twey: It doesn't generate globally unique name, I have to use unsafePerformIO to create an IORef that I append to the name
12:17:19 <prinsen> ChongLi: See above
12:17:32 <ChongLi> ahh, hmm
12:17:57 <mcstar> @hoogle gensym
12:17:58 <lambdabot> No results found
12:17:59 <prinsen> ChongLi: It works with the IORef, but it's ugly
12:18:26 <jrmithdobbs> danilo2: does it work with FlexibleInstances ?
12:18:32 <ChongLi> prinsen: you need some unique names deep inside an expression?
12:18:33 <Eduard_Munteanu> danilo2: ScopedTypeVariables doesn't work like that, you likely need a toplevel signature to mention forall
12:18:40 <b80905> how do i convert a list to a tuple?
12:18:42 <mcstar> http://hackage.haskell.org/package/template-haskell-2.5.0.0/docs/Language-Haskell-TH-Syntax.html
12:18:49 <mcstar> ^ may be relevant prinsen
12:19:06 <prinsen> ChongLi: I generate data types that are returned and evaluated to top level, and I get multiple declaration errors
12:19:09 <Eduard_Munteanu> b80905: pattern-matching... you can't do that generally.
12:19:17 <Eduard_Munteanu> Not easily anyway.
12:19:39 <ciaranm> you'd need infinite coproducts
12:19:43 <mgoszcz2> Ok ChongLi. Got it. This place really _is_ full of helpfull people.
12:19:47 <Eduard_Munteanu> b80905: besides, lists have the same type for elements
12:19:58 <danilo2> jrmithdobbs: no
12:20:00 <Twey> prinsen: That's not true; newName already uses an IORef internally
12:20:15 <prinsen> ChongLi: I generate the names using newName "Test" which results in "Multiple declarations of 'Test'". For variables it works, as they shadow eachother
12:20:30 <prinsen> Twey: I know, that what's disturbing me
12:20:39 <mcstar> Don Stewart says TH provides uniqe names, per the above documentation
12:20:50 <jrmithdobbs> danilo2: then I, personally, don't understand why it doesn't either, it has to do with being too specific in the type but I don't see why it's not infering correctly
12:20:50 <Eduard_Munteanu> b80905: I mean you can't really hope for something better than   convert [a,b,c] = (a, b, c)
12:20:52 <danilo2> Eduard_Munteanu: Hmm, I try to understand the connection. So there is no way to use "scoped type variables" ' like mechanism to tell haskell what is the result of function?
12:21:02 <prinsen> mcstar: Then why do i get multiple declaration errors ;)
12:21:03 <ChongLi> prinsen: yeah, you need to append to that string a unique part
12:21:18 <ChongLi> generate a random string and append it
12:21:23 <Twey> prinsen: instance Quasi IO where qNewName s = do { n <- readIORef counter; writeIORef counter (n+1); return (mkNameU s n) }
12:21:38 <ChongLi> a counter works too, haha
12:21:38 <Eduard_Munteanu> danilo2: merely turning ScopedTypeVariables on in a Haskell98/2010 program shouldn't change it at all.
12:21:39 <mcstar> prinsen: i havent used TH before, except Yesod, but do you use the NameSpace type?
12:21:54 <Twey> ChongLi: There's already a counter.  That's the instance from the TH source.
12:22:00 <prinsen> mcstar: No
12:22:13 <Eduard_Munteanu> danilo2: what are you trying to accomplish?
12:22:21 <mcstar> mkNameG_v  = mkNameG VarName -- that makes a unique name imho
12:22:37 <danilo2> Eduard_Munteanu: I just wanted to ask you If you understand what I'm trying to do, ok I will explain it better :)
12:22:53 <ChongLi> Twey: ahhh
12:23:45 <Eduard_Munteanu> danilo2: wait, are you trying to make the result type depend on the input type for some function?
12:24:00 <dgpratt> in presentations on DPH I've seen in the past, SPJ seemed to suggest that DPH wasn't quite ready for prime time, yet
12:24:09 <dgpratt> has that situation changed?
12:24:23 <danilo2> Eduard_Munteanu: I'm generating Haskell code. In this code, there are functions, which process some data (like f,g or h). This data is packed in some kind of Monads (like X or Y), but user does not know about these monads and do not touch them. User should be able though, to type THE PARAMS and RESUL of such function, like
12:25:05 <Eduard_Munteanu> danilo2: that might have been cut off at "such function, like"
12:25:21 <danilo2> Eduard_Munteanu: lie say, the apram is Int and the result is Int - I would translate it to something like f (m1 Int) = .... :: m2 Int . And m1 and m2 are connected to each other somehow, but user of this dsl does not know this
12:25:51 <danilo2> Eduard_Munteanu: Sorry, now you should get the end of the sentence
12:26:27 <danilo2> Eduard_Munteanu: Do you see, what I'm trying to do ?
12:26:53 <Eduard_Munteanu> danilo2: if you compile the DSL to Haskell code, why are you exposing m1 and m2 at all?
12:27:18 <Eduard_Munteanu> Is it supposed to be a Haskell-embedded DSL?
12:28:30 <danilo2> Eduard_Munteanu: I want to translate what user tells to haskell code. If he tells, that the parameter is Int, then I translate it to " f (a :: m1 Int) " - so yes, m1 appears in Haskell code, but I do not generate explicit any TypeClass dependencies between m1 or m2  because Haskell is able to infer it
12:29:25 <danilo2> Eduard_Munteanu: It is infering it as far as I'm using ScopedType variables - the problem appears only with results of the function (like in function h2) . The dirty "workaround" I present in function "h1", where it works just like I want it to work (but its ugly)
12:29:56 <ifthenelse> Is there a list of lazy functions that result in stack size overflows when applied to a large dataset? For instance, foldl, foldr, length, etc.
12:30:18 <ifthenelse> I must have some function causing it, but I can't find the culprit.
12:30:39 <ifthenelse> And I didn't realize that length results in it until now, so there are probably more hidden functions that do this.
12:30:53 <mcstar> you need more strictness
12:31:22 <ifthenelse> I do, but where are the lazy functions breaking down.
12:31:25 <mcstar> what do you mean 'length results in it'?
12:31:43 <ChongLi> well, foldl is a sort of worst case for laziness
12:31:46 <ifthenelse> mcstar I was getting stack size overflows with length
12:31:50 <mcstar> haskell is lazy mostly, so haskell results in it, i would say
12:31:55 <Eduard_Munteanu> danilo2: those type signatures are rather meaningless
12:31:55 <ChongLi> when dealing with a list, anyway
12:31:58 <mcstar> no, you dont, with length
12:32:22 <merijn> ifthenelse: foldl is nototirous for stack overflows
12:32:42 <merijn> ifthenelse: Did length result in a stack overflow or an out of memory error?
12:32:46 <ChongLi> foldl' and foldr are the two we generally use
12:33:21 <ifthenelse> merijn: Stack overflow. When I changed it to foldl' (\acc _ -> acc + 1) 0 it worked
12:33:23 <ChongLi> to understand why foldl stack overflows, you need to understand how a list is constructed
12:33:26 <danilo2> Eduard_Munteanu: In this particullar example, you can think they are meaningless, but look, if I'm translating code like " f(a:Int, b) : Int = ..." I want to translate it to such Haskell code, like the one in this example. It would be translated to " f (a :: m1 Int) b = ... :: m3 Int "
12:33:45 <ifthenelse> I understand WHY they stack overflow, I just need a list of lazy functions that might result in that
12:33:52 <ifthenelse> without me checking each one in my program
12:34:11 <ChongLi> well, such a list is basically infinite
12:34:23 <ifthenelse> I converted all folds to their strict versions, sum to foldl' (+) 0, length to the version above, but I still am running into this issue.
12:34:27 <ChongLi> since you can define an infinite number of functions based on foldl :)
12:34:39 <Eduard_Munteanu> danilo2: why not   f :: Int -> b -> Int; f a b = ...  ?
12:35:07 <Eduard_Munteanu> I mean perhaps there's something you haven't mentioned about this.
12:36:00 <danilo2> Eduard_Munteanu: because the user code is translated to MUCH complicated Haskell code and each variable is in some ind of monad. These monads get connected in the body of such function, so I cannot translate it such straightforward way. Do you see what I mean? If not, I'll try to explain it better with example
12:37:20 <ChongLi> ifthenelse: I believe the reason sum and product are defined with foldl is so that you get a stack overflow when you apply them to an infinite data structure
12:37:27 <Eduard_Munteanu> danilo2: monads, not monad? I suspect you're trying to get something like a state monad where the state type can change, but I shouldn't be guessing.
12:37:29 <ChongLi> this is seen as preferable to an infinite loop
12:37:29 <ifthenelse> I even have foldMap changed to F.foldl' (\m -> mappend m . f) mempty, but it still isn't enough
12:37:36 <mcstar> > foldl (+) 0 [1..200000]
12:37:37 <lambdabot>  20000100000
12:37:40 <ChongLi> which would be the case with foldr
12:37:45 <mcstar> > let splus !a !b = a + b in foldl splus 0 [1..200000]
12:37:46 <lambdabot>  *Exception: stack overflow
12:37:53 <mcstar> how about that?
12:38:14 <danilo2> Eduard_Munteanu: Think of it like this: Each user variable can be inside X or Y. if user writes " a = 5 " it is translated to " a = X 5 ". If user writes " c = a + b " it is translaed to " c = a ~+ b ", where "~+" is works on some kind of type classes, knowing what to do in each case - when a and b are either X or Y
12:38:17 <NemesisD> hey guys. i was looking for some help on which typeclasses I could use to achieve what i want from Data.Validation: http://hackage.haskell.org/package/Validation-0.2.0/docs/Data-Validation.html
12:39:49 <Eduard_Munteanu> danilo2: what's the meaning of X and Y?
12:39:56 <NemesisD> actually, with that library how are you supposed to inspect the result of the validation and make decisions if the constructors aren't exported
12:40:06 <danilo2> Eduard_Munteanu: No, its not like state monad. Ok, a simple example. Each value can be " Pure a" or "IO a" (like in the example X a or Y a). If I add pure value to pure value I get pute value. If add add pure to IO I get IO etc. So If user writes "a=5, b=6, c=a+b" it is translated to "a=Pure a, b=Pure 6, c = a~+b"
12:40:22 <danilo2> Eduard_Munteanu: I hope it is clear now with Pure and IO what X and Y could be
12:41:17 <Eduard_Munteanu> danilo2: do you know about the free monad for a functor?
12:41:32 <danilo2> Eduard_Munteanu: Now, if User writes " f(a:Int,b):Int = a + b" I want to trannslate it to "f (a :: m1 Int) b = a ~+ b :: m2 Int "
12:41:46 <zcourts> I have a list of 4, 32 bit Int, is there a way to create a 128 bit Integer from them?
12:42:16 <danilo2> Eduard_Munteanu: (ending my sentence) and it works until I try to type the resulting value - because all such typed arguments work great
12:42:33 <danilo2> Eduard_Munteanu: no, I do not know about the free monad for a functor - what is it ?
12:43:24 <merijn> zcourts: How do you know you have 32bit Int?
12:44:36 <zcourts> merijn: I got the values from calling a C function
12:44:43 <merijn> zcourts: (This is my really subtle way of pointing out that the Haskell Report mandates that Int is *at least* 27bits, so assuming they're 32bit is an error)
12:44:53 <merijn> zcourts: Don't use Int for receiving C ints
12:45:05 <Eduard_Munteanu> danilo2: data Free f a = Pure a | Wrap (f (Free f a)) gives you a monad 'Free f' for any functor 'f', where 'f' can be IO if you like. It lets you unfold a big monadic computation step by step. Maybe your generated code can be typed in terms of that.
12:45:27 <merijn> zcourts: That's what CInt (mimics "int" on the platform) and Word32/Int32 (uint32_t and int32_t respectively) are for
12:46:20 <zcourts> merijn: Sorry I should have been clean they're actually CUInt, 4 of them
12:46:22 <danilo2> Eduard_Munteanu: Hmm, I have to take a look at it. It looks somewhat simmilar to what I did here.
12:47:12 <danilo2> Eduard_Munteanu: I'll look into it, thank you. I'll read about free monads and try to solve my problem with them. After that I'll write back, If you do not mind to? Thank you for todays help!
12:48:11 <Eduard_Munteanu> danilo2: the thing is those type sigs there don't really do anything
12:49:16 <Eduard_Munteanu> danilo2: besides, h1 and h2 aren't at all the same, because MonomorphismRestriction.
12:49:23 <danilo2> Eduard_Munteanu: I understand it. In my example, the Pure was also a newtype, which compined with other Pure gives just a pure computation, so (Pure 6) ~+ (Pure 7) is eual to 6+7
12:49:33 <merijn> zcourts: I guess the "ghetto" solution is to convert the first one to Integer, left-shift it 32 bits (or better yet, use bitSize to figure out how many bits are in the type for portability!) and xor together, repeat
12:50:55 <Eduard_Munteanu> danilo2: an Applicative instance for 'Free f' would give you Pure f <*> Pure a = Pure (f a)
12:50:57 <zcourts> merijn: Cool, thanks
12:51:14 <danilo2> Eduard_Munteanu: hmm, why, where the MonomorphismRestriction is violated?
12:51:15 <danilo2> Eduard_Munteanu:
12:52:02 <danilo2> Eduard_Munteanu: Hmm, ok, I want also Pure f <*> IO a to give me IO (f a) - I think it is possible, but how would it differ from my simply class with functional dependencies?
12:52:28 <Eduard_Munteanu> danilo2: h2 has no type signature and 'h2 x' is a polymorphic value
12:55:18 <danilo2> Eduard_Munteanu: Are you talking about this code?: http://lpaste.net/98667 If yes, I dont get it :( Both h1 and h2 have typed "x" the same way, havent they?
12:55:34 <Eduard_Munteanu> danilo2: well, I'm still not sure what you want to accomplish. Merely typing the generated code properly in Haskell? Or do you want the types to tell you if a value is pure or not?
12:56:28 <Eduard_Munteanu> danilo2: neither h1 or h2 have a type signature. Those (_ :: ...) things are type ascriptions in expressions.
12:58:00 <Eduard_Munteanu> > (5 :: Num a => a) + (2 :: Num b => b)
12:58:02 <lambdabot>  7
12:58:02 <danilo2> Eduard_Munteanu: I want simply to translate the types written by an user, to Haskell code. So If user writes, that there is function f, which results with Int, I want to translate it to Haskell (but all the values are either in Pure or in IO - but the mechanism of automatic combining Pure and IO values I've got done and it is working)
12:58:46 <Eduard_Munteanu> > (?a :: Num a => a) + (?b :: Num b => b)
12:58:47 <lambdabot>  Could not deduce (?a::a1)
12:58:47 <lambdabot>    arising from a use of implicit parameter `?a'
12:58:47 <lambdabot>  from the context (GHC.Num.Num a)
12:58:47 <lambdabot>    bound by the inferred type of it :: GHC.Num.Num a => a at Top level
12:58:47 <lambdabot>  or from (GHC.Num.Num a1)
12:59:06 <danilo2> Eduard_Munteanu: So I just want to tell Haskell "hey, my user told me, that the type of f is Int, so in reality it is some kind of "m3 Int" - please throw error if it is not true"
13:02:18 <Eduard_Munteanu> danilo2: you might need to compile each such expression to a declaration or at least an expression with a type ascription ranging over the entire thing. The "sigs" you provided there don't quite work like you think they do, the m1 and m2's there aren't related at all.
13:03:53 <Eduard_Munteanu> danilo2: if your language boils down to a reasonable set of combinators, you might be able to encode it as a GADT and you get things typed correctly by construction.
13:04:57 <danilo2> Eduard_Munteanu: Hmm, I think, I need to do a better and much clearer example than this one. I will work on it, mayb I will solve it somehow. I feel I did not explained it well enough, I'm sorry
13:05:30 <danilo2> Eduard_Munteanu: Thank you for the help. If I would not oslve it, I'll be back with more clear example :)
13:05:44 <Eduard_Munteanu> danilo2: e.g. data Value a where (~+) :: Num a => a -> a -> Value a
13:06:27 <danilo2> Eduard_Munteanu: But it does not - user can declare custom combinators , they cannot be packed into GADT :(
13:07:14 <Eduard_Munteanu> danilo2: but they are defined in terms of a core syntax, no?
13:07:48 <Eduard_Munteanu> Each time you get a custom combinator you might be able to substitute its definition for it, I mean.
13:09:05 <danilo2> Eduard_Munteanu: Hmmm, I do not know If I get your idea correctly, but users are allowed to declare custom functions (which are translated to haskells functions), custom datatypes etc - and operate on them - they can do pretty much for a DSL
13:09:06 <Eduard_Munteanu> And since you likely track all such declaration you can just refer to it by name,
13:11:25 <Eduard_Munteanu> danilo2: ah, I see... you want freeform Haskell terms intermingled with that. It might still be possible to do it that way, if you treat custom definitions as literals.
13:13:22 <danilo2> Eduard_Munteanu: Hmm, I think I've got the whole system working apart from the little part of typing the results of a function. I've got the translation of datatypes, function etc working so far :) And automatic IO and Pue handling also - It is even more complicated, but it does not matter now. I think I have to sleep with these ideas
13:14:05 <danilo2> Eduard_Munteanu: and try to do something with them. Anyway, htank you very much - If I will not manage to do it, I will prepare a clearer examp,e, which will show, what is working and what is not :)
13:14:49 <Eduard_Munteanu> Alright. Seems to me those type sigs are the most concrete thing that doesn't work right now, I hope you understand why.
13:19:50 <danilo2> Eduard_Munteanu: To be honest - I'm not sure I understand why you think so. Look, here is a code, which is cut out of real one generated by my compiler: http://lpaste.net/98677 . As you can see, Haskell infers a lot of dependencies between m1 and m2 and s1 and s2.
13:20:00 <Fyl> sortByFirst (m, n) = List.unzip . List.sort $ List.zip m n
13:20:20 <Fyl> oops
13:20:28 <danilo2> Eduard_Munteanu: But probably you are talking about something else. I still think, that if it will not work, I will prepare better example, to be able to talk more clear about it
13:21:14 <d3lxa> is there a paper or someone who can explains how John Hughes makes CGI arrows with continuation? I don't understand the free/bound variable problem there with monads (in paper page 35: http://www.haskell.org/arrows/biblio.html#Hug00 )
13:22:03 <Eduard_Munteanu> > (5 :: Num a => a) + (2 :: Num b => b) -- danilo2
13:22:05 <lambdabot>  7
13:22:47 <Eduard_Munteanu> danilo2: your m's are pretty much universally quantified and distinct
13:22:51 <jfischoff> :t (5 :: Num a => a) + (2 :: Num b => b)
13:22:53 <lambdabot> Num a => a
13:23:30 <danilo2> Eduard_Munteanu: Yes, its working the way I want. It is possible, that m1 would be equal m2 - so its cool, that hasell allows it.
13:25:50 <Eduard_Munteanu> danilo2: I'm still not convinced you get my point... things like   \(x :: m Int) (y :: m Int) -> ... :: m Int   end up as different m's.
13:26:33 <Eduard_Munteanu> danilo2: like I said, unless you use foralls in the declaration signature, ScopedTypeVariables have *no* effect.
13:27:15 <Eduard_Munteanu> danilo2: ScopedTypeVariables is supposed to be perfectly compatible with existing H98/2010 code.
13:27:24 <danilo2> Eduard_Munteanu: I get it. And I like this behaviour very much - because during the code generation, I do not know if they are the same or different m's. But ScopedTypeVariables allow Haskell to see, that there is Int inside and ifer other types (not m's) based on that information, am I wrong?
13:28:04 <Eduard_Munteanu> danilo2: no, ScopedTypeVariables has no effect there, it's as if you didn't turn it on.
13:29:23 <Eduard_Munteanu> danilo2: basically x :: m Int is merely asserting x is a 'm applied to Int' and says nothing at all about 'm'. Further occurences of 'm' are distinct too.
13:30:08 <danilo2> Eduard_Munteanu: I do not think you are correct now, look at this code: http://lpaste.net/98678 - If we ask GHCI what is the type of g, it will tell " XC m1 m2 => m1 Int -> m2 Int " - so we can see, the inferred result is Int - based on the ScopedTypeVariable !
13:31:00 <Eduard_Munteanu> danilo2: no, that's a result of (+) forcing arguments to have the same type
13:31:11 <geekosaur> um, I see no foralls there, ScopedTypeVariables is a no-op
13:31:13 <Eduard_Munteanu> Arguments and result.
13:31:18 <Eduard_Munteanu> Yep. ^^
13:33:49 <danilo2> Eduard_Munteanu: Hmm, so you want to tell me, that such ScopedTypeVariable, like (a :: m Int) has no effect on type inference at all ?
13:34:05 <geekosaur> that is not a ScopedTypeVariable
13:34:40 <geekosaur> it is a scoped type variable but it is not subject to ScopedTypeVariables; it is a narrow scope, ScopedTypeVariables is a hack to enable a wider than normal scope
13:34:49 <geekosaur> and it *only* activates with explit foralls
13:34:56 <geekosaur> *explicit
13:34:57 <Eduard_Munteanu> danilo2: no effect as far as STVs are concerned... its only effect is to assert 'a' is the result of a type function application, so it forbids '5' but not 'Just 5'
13:35:17 <geekosaur> if you did not write `forall sometype. ...` then ScopedTypeVariables is not playing any part whatsoever in typing
13:37:02 <pavonia> Can it also have an effect if there aren't at least two variables with the same name?
13:37:22 <danilo2> Eduard_Munteanu: I get it, but again, look at different code: http://lpaste.net/98679 (here Int is Infered the proper way out of definition of type class) - I cannot imagine right now example, where could it not work, the way I want to
13:37:46 <danilo2> Eduard_Munteanu: Maybe I'm missing some simple examples, but so far I think everything I need is infered the way I want to
13:38:29 <Eduard_Munteanu> danilo2: you should get the same effect by merely using 'm Int' in both places instead of distinct 'm'.
13:38:32 <danilo2> geekosaur: I didnt notice, what have you written before. Please look at my lat sentence :)
13:38:33 <zq> > 16*40*12
13:38:34 <lambdabot>  7680
13:39:21 <geekosaur> you keep talking about ScopedTypeVariables and they have exactly zero relevance to anything you have said
13:39:28 <danilo2> Eduard_Munteanu: What do you mean by "both places" ?
13:39:34 <geekosaur> which tells me you don't really know what's going on
13:39:54 <Eduard_Munteanu> danilo2: the two ms in   g (x::m1 Int) = (xc x) -- :: m2 a
13:40:38 <danilo2> Eduard_Munteanu: Ah, right
13:41:17 <danilo2> Eduard_Munteanu: hmm, I have to rething if this breaks something in my assumptions. Thank you for all the informations
13:44:18 <pavonia> danilo2: Btw, was it you who contacted the Parsec maintainer asking for a change in the position counting?
13:45:34 <danilo2> pavonia: Yes, I was contacting him.
13:45:53 <pavonia> And did you get an answer yet?
13:47:34 <danilo2> pavonia: I contacted 2 developers: (both listed as maintainers in Parsec libraries). I get resposnes from both of them - On told me he is not maintainer and the second asked a question, which I forgot to answer - as I see now. I was strongly sick for last week and I've got to process some mails right now
13:48:10 <pavonia> Ah, okay
13:48:28 <danilo2> pavonia: I'll answer the mail today - are you also interested in this topic ?
13:48:47 <pavonia> I am
13:49:20 <jfeltz> is there a: (s -> s') -> State s a -> State s' a function? or is that the wrong mentality?
13:50:06 <simpson> jfeltz: There are several, yes.
13:50:13 <simpson> :t focus -- either focus or zoom from lens?
13:50:15 <lambdabot> (Functor f, Indexable i p) => p a (f a) -> Zipper h i a -> f (Zipper h i a)
13:50:16 <simpson> :t zoom
13:50:18 <lambdabot> Zoom m n s t => LensLike' (Control.Lens.Internal.Zoom.Zoomed m c) t s -> m c -> n c
13:51:03 <jfeltz> lenses, yuck, ok
13:51:04 <Eduard_Munteanu> jfeltz: don't expect to be able to change state types right in the middle of a monadic computation, if that's what you're asking
13:51:25 <simpson> jfeltz: Hey, lens is pretty awesome once you learn it.
13:51:25 <Cale> jfeltz: A value of type State s a is internally a function s -> (s,a)
13:51:26 <cap11235> Probably would want to look up the hint type signatures in the lens documentation
13:51:36 <simpson> jfeltz: Anyway, the answer is no, MonadState doesn't provide this.
13:51:45 <Cale> jfeltz: So your question can be thought of as: is there a function (s -> s') -> (s -> (s,a)) -> (s' -> (s',a))
13:51:53 <danilo2> pavonia: Ok, could you give me your email address? I will send CC to you if you want
13:52:07 <simpson> But you can run the state computation and then map over the resulting state, before feeding it into a new computation.
13:52:18 <aleksejs_> > sqrt (fromInteger (50 `div` 2))
13:52:19 <lambdabot>  5.0
13:52:57 <Eduard_Munteanu> The right "idiom" for that would be an indexed state monad, since as Cale probably notes above, State is invariant in 's'.
13:53:07 <Cale> jfeltz: So suppose you have f :: s -> s', and g :: s -> (s,a), and x :: s', you now need to make an (s',a) pair
13:53:18 <edwardk> > runState (zoom _1 get) (1,2)
13:53:20 <lambdabot>  (1,(1,2))
13:54:22 <edwardk> > execState (zoom _1 (modify (+1))) (1,2)
13:54:24 <lambdabot>  (2,2)
13:54:34 <edwardk> > execState (zoom both (modify (+1))) (1,2)
13:54:36 <lambdabot>  (2,3)
13:55:00 <Cale> You have no value of type s to apply f or g to. While you could construct a function s -> (s',a), by applying f to the first component of the result of g, that wouldn't help you get an s
13:55:01 <edwardk> > execState (zoom traverse (modify (+1))) [1..100]
13:55:03 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
13:55:09 <Cale> and you have nothing to do with this s' that you have
13:55:19 <Cale> So, what you need is a map going also in the other direction
13:55:19 <zq> is there a .lhs of thih?
13:55:28 <identity> lens is too much magic
13:55:36 <Cale> There is a function (s -> s') -> (s' -> s) -> State s a -> State s' a
13:55:40 <jfeltz> simpson: yes, I'll manage with that
13:55:46 <simpson> identity: Actually, Cale's nailing down exactly why lens is awesome right here!
13:55:53 <identity> I know it's awesome
13:56:16 <simpson> A lens can capture, among other things, an isomorphism, and the isomorphism between s and s' is required to fulfill this desired function.
13:56:28 <identity> I just feel it's awesome like I'm a peasant who just witnessed the kingdom's Arch-Wizard perform magic
13:56:39 <danilo2> pavonia: I've got to go now. I'll be back in about 2 hours. You can write here to me, I'll read it when I get back :)
13:56:41 <Cale> what?
13:56:42 <Cale> Well, fine
13:56:42 <Cale> I wasn't really talking about lens
13:56:54 <identity> It's kind of bending my perception of reality
13:56:55 <edwardk> technically just a lens is required there, not a full isomorphism
13:57:05 <Cale> I was the only one actually trying to answer the question of whether a sensible such function can exist
13:57:23 <simpson> Yeah, sorry. I'm just exciteable.
13:57:34 <edwardk> zoom is used to run a calculation designed to run inside a monad with a simpler state inside a larger state, that's it.
13:57:49 <edwardk> Cale: sure. and we appreciate it =)
13:57:53 <silasm> identity: didn't we all feel that way about Monads at one point? ;)
13:58:11 <Cale> But yeah, it comes down to needing a pair of maps in either direction, however you decide to package that up.
13:58:14 <edwardk> cale playing the straight man lets me ramble on in the corner incoherently without consequence ;)
13:58:15 <pavonia> danilo2: Oh, I've send you my address in /query, in case you haven't seen :)
13:58:19 <silasm> (I did, at least; pretty happy with them now).
13:59:14 <identity> silasm: Perhaps
14:00:35 <silasm> but yeah I need to break the ice with lenses too. Looking forward to doing so, but I haven't gotten around to it.
14:01:10 <silasm> any recommendations on tutorials with exercises?
14:01:36 <identity> I know that lenses ease interacting with ADTs and so on, but I know so little about all the other magic lens can do that I don't really realize it when I'm writing code I could simplify with lens
14:01:50 <silasm> same
14:01:56 <ReinH> Guess who has two thumbs and just finished recording a haskellcast episode.
14:02:07 <edwardk> ReinH: yay!
14:02:14 <ReinH> edwardk: yay!
14:02:36 <silasm> ReinH: what is this and where can I watch/listen to/eat it?
14:02:40 <ReinH> silasm: Monads are still pretty magical if you ask me.
14:02:49 <ReinH> silasm: www.haskellcast.com and on itunes
14:03:02 <silasm> awesome.
14:03:09 <ReinH> silasm: currently the most magical monad for me is the free monad.
14:03:30 <silasm> ReinH: oh the magic definitely doesn't die. You just learn how to cast the spells.
14:03:34 <ReinH> exactly
14:03:36 <identity> The Malfoys still hate Harry for freeing their monad, y'know
14:03:40 <identity> lots of drama
14:03:45 <jfeltz> Cale: oops, ya, I think need to switch the second and third types in my original question, and add a (s' -> s) argument
14:03:52 <ReinH> Harry has given monad a sock.
14:04:00 <identity> MONAD IS FREE!
14:04:42 <tac> Free as in beer? Or free as in left adjoint?
14:04:45 <silasm> I used Writer for the first time today and it was so natural. I'd had trouble finding a use for it beforehand.
14:04:56 <ReinH> tac: free as in left adjoint to a forgetful functor
14:05:12 <ReinH> tac: well, in this case the monad so constructed, but yes
14:06:22 <DigitalKiwi> tac: I wish beer was free :<
14:06:38 <ReinH> I wish beer was left-adjoint.
14:06:43 <ReinH> To my face.
14:09:33 <ReinH> And yes, the adjunctions between beer and my face form a monad in the obvious way.
14:09:42 <ReinH> What are we talking about again?
14:10:01 <ReinH> Cale: I name dropped you on the haskell cast today
14:21:25 <bambams_> Well that's awkward... DO NOT go to hoogle.net, especially while at j0rb.
14:21:43 <bambams_> Ah, haskell.org/hoogle... Well then.
14:30:04 <halvorg> If you have lists [a], [b], [c], how would you make a list [f a b c] such that all possible combinations of a b c are in said list.
14:31:08 <shachaf> Which of the things you wrote are types?
14:31:15 <jrmithdobbs> halvorg: zip3 them together and permutate
14:31:24 <sipa> > [f x y z | x <- a, y <- b, z <- c] where {f x y z = x+y*z; a=[1,2,3]; b=[2,4]; c=[3,1]}
14:31:26 <lambdabot>  <hint>:1:36: parse error on input `where'
14:31:44 <sipa> > let {f x y z = x+y*z; a=[1,2,3]; b=[2,4]; c=[3,1]} in [f x y z | x <- a, y <- b, z <- c]
14:31:45 <lambdabot>  [7,3,13,5,8,4,14,6,9,5,15,7]
14:31:46 <jrmithdobbs> halvorg: and change f to take (a,a,a) instead of a -> a -> a
14:31:58 <halvorg> that looks nice sipa
14:32:32 <halvorg> :t permutate
14:32:34 <lambdabot> Not in scope: `permutate'
14:32:53 <pavonia> :t permutations
14:32:56 <lambdabot> [a] -> [[a]]
14:33:01 <jrmithdobbs> actually, your question doesn't make sense if you really meant [a] [b] and [c] and not 3 lists of [a]
14:33:03 <sipa> it's not permutations
14:33:14 <shachaf> I can't imagine an interpretation of your question such that using zip3 makes sense.
14:33:19 <ReinH> Or just use the applicative
14:33:21 <c_wraith> or liftA3 f
14:33:25 <ReinH> f <$> as <*> bs <*> cs
14:33:28 <ReinH> yep
14:35:35 <jle`> that's probably the most proper answer
14:37:22 <ReinH> "all possible combinations" is incompatible with zipping
14:43:10 <avaritia> hey i was toying with designing a monad representing unique computation
14:43:26 <avaritia> is it a good idea to design it this way newtype Uniq a = Uniq ([a],Bool)
14:43:45 <ReinH> avaritia: what does "unique computation" mean?
14:43:47 <jrmithdobbs> ya, hence my second statement, my mind started from [a] [b] [c] and started typing the zip3 comment before i realised what I was saying didn't make sense ;p
14:44:35 <Cale> avaritia: There's not much reason to use a newtype if you're just going to put a pair in there
14:45:14 <Cale> avaritia: Regardless of the question about whether it's a monad,  data Uniq a = Uniq [a] Bool  seems a little nicer
14:45:56 <avaritia> ReinH: if function returns something which has been already returned we drop the result
14:46:05 <avaritia> hmf that bool is unnecessary i think
14:46:28 <Cale> Then you're talking about lists.
14:46:52 <ReinH> or possibly sets?
14:46:57 <halvorg> How would I go about paralellizing function calls on a list? No reduction or anything just [a] -> [a], where every item is independent.
14:47:30 <Cale> Yeah, it sounds like you want sets, but remember that set datastructures require ordering operations, so they don't give an instance of Monad
14:48:07 <ReinH> Cale: what about HashSet?
14:48:10 <L8D> halvorg: if all the items on the list are IOs then you might be able to map and put them all into threads...otherwise, I have no idea what you're talking about
14:48:18 <avaritia> Cale: why something with ordering doesnt give monad instance?
14:48:19 <Cale> ReinH: Then you need a hash function
14:48:25 <ReinH> Cale: well. yes.
14:48:41 <shachaf> @google parMap haskell
14:48:42 <lambdabot> http://stackoverflow.com/questions/5606165/parallel-map-in-haskell
14:48:42 <lambdabot> Title: Parallel map in haskell - Stack Overflow
14:48:50 <Cale> avaritia: Because  (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
14:48:56 <shachaf> halvorg: Try that thing.
14:49:01 <Cale> avaritia: There's nothing about Ord a or Ord b in there
14:49:12 <halvorg> shachaf: that looks like it, thanks.
14:49:19 <shachaf> Codensity to the [non-]rescue!
14:49:22 <Cale> avaritia: But you'll probably need at least Ord b to implement the operation.
14:49:29 <avaritia> Cale: thank you
14:50:34 <Cale> Yeah, there's a thing called Codensity which can turn Set into a monad, but really what happens is what you'd expect from something which doesn't have the instance of Ord handy: none of the sets are collapsed until the very end.
14:50:44 <ReinH> Cale: Hmm, are we restricted to (a -> m a) here?
14:50:56 <Cale> ReinH: Not if we invent a new class.
14:51:00 <Cale> er
14:51:04 <Cale> wait what?
14:51:16 <ReinH> Cale: Never mind.
14:51:46 <Cale> ah, you can try to store a dictionary for Ord in the sets themselves
14:51:51 <Cale> But then return becomes a problem
14:52:32 <Cale> return :: a -> Set a, but if you require the dictionary for Ord, you won't have one handy here
14:53:04 <nifr> hi all, I have a quick question
14:53:14 <nifr> does anyone know when the :kind! command was added to ghci?
14:53:39 <Cale> kind with an exclamation point?
14:53:43 <nifr> the one that shows the results of simplifying the type expression  argument
14:53:43 <nifr> yep
14:54:24 <Cale> Heh, it doesn't appear in ghci's help
14:54:42 <Cale> I have no idea
14:54:43 <nifr> it's unfortunately some secret awesomeness, I think
14:55:01 <Cale> It's *probably* new
14:56:04 <Cale> (There's been a lot of work on kinds lately, especially in 7.6.x)
14:56:30 <nifr> that's what I thought
14:56:37 <nifr> but actually, it works in 7.4!
14:57:23 <nifr> dunno if it works in 6.10, but 7.4 is old enough to satisfy my question
14:57:28 <nifr> thanks Cale
14:57:31 <nifr> have a good one
14:58:27 <skuggi> I've got some problems with an arbitrary instance: http://lpaste.net/98662
14:59:16 <skuggi> It always seems to generate two identical subtrees.
14:59:26 <acowley> Could be a coincidence
14:59:39 <acowley> (sorry)
14:59:43 <skuggi> :)
15:00:13 <skuggi> Anyway, it always produces stuff like this: ((-x0 & -x0) | (-x0 & -x0))
15:02:30 <acowley> So it's like the t bound in the where is constant?
15:04:33 <kristof> I never liked where
15:04:40 <kristof> don't like the scope
15:04:51 <kristof> don't like specifying some bindings AFTER the expression
15:05:09 <skuggi> acowley: pretty much
15:05:20 <acowley> skuggi: You're testing using sample?
15:05:25 <skuggi> yes
15:08:06 <Twey> kristof: You'd rather have them all up front, so anyone reading your code can't get to the meat of what your function actually does until they've waded through five lines of convenience bindings?  :þ
15:09:38 <dwcook> I like where. I also have a tendency to define types following where they're referenced by another type.
15:09:58 <skuggi> Oh, I the problem was that I'm an idiot.
15:10:05 <Twey> Likewise; if your reader needs to know the definition of things before the things that use them make sense, you've chosen bad names
15:10:21 <Twey> skuggi: That's almost always the problem in Haskell :þ
15:10:30 <acowley> skuggi: type checker should have spotted that
15:10:36 <acowley> skuggi: What was wrong?
15:10:41 <skuggi> acowley: the show function :)
15:10:47 <Twey> Haha, oops
15:10:50 <dwcook> A program is ill-typed if it's written by an idiot?
15:10:54 <acowley> hah!
15:10:57 <dwcook> How does it tell?
15:11:00 <Twey> show (TAnd t1 t2) = "(" ++ show t1 ++ " & " ++ show t1 ++ ")"
15:11:10 <acowley> skuggi: You should be using -Wall!
15:11:20 <acowley> or ghc-mod
15:11:26 <acowley> it would bark at you
15:11:57 <Twey> dwcook: We make the type system more and more complex until the desired level of intelligence is required to make programs type-check?  :þ
15:12:11 <dwcook> Sounds legit.
15:12:18 <dwcook> So, are you saying we should all start using Agda?
15:12:21 <dwcook> :P
15:12:26 <Twey> dwcook: Why yes
15:12:45 <Twey> (though Agda's type system is relatively simple compared to Haskell's, I think)
15:13:26 <tac> much simpler
15:13:45 <skuggi> acowley: yeah, i guess i should :)
15:14:04 <dwcook> I was primarily referring to the lack of type inference
15:14:19 <acowley> I actually thought lpaste did -Wall and hlint
15:14:23 <Twey> dwcook: Agda has type inference!
15:15:51 <geekosaur> lpaste doesn't actually compile any code, so can't do -Wall
15:16:04 <geekosaur> hlint is all source heuristics, not compilation
15:16:59 <halvorg> hm, isn't Data.List.nub a bit slow? O(n^2).
15:17:14 <geekosaur> yes, it's the cost we pay for requiring only Eq
15:17:36 <halvorg> I see
15:17:46 <acowley> geekosaur: But I want -Wall
15:17:52 <ChongLi> halvorg: yeah, if that sort of thing is really important to you you may want to look at a Set type
15:17:53 <Twey> If you use Set you get O(n log n) (and an Ord constraint)
15:18:17 <FreeFull> How is Set implemented? A tree?
15:18:17 <Twey> (from a list, that is)
15:18:20 <Twey> Yes
15:18:39 <geekosaur> acowley, chrisdone may well be open to patches, although it would also add to the load on whatever he's running lpaste on
15:18:52 <ChongLi> and depending on your specific workload, HashSet from unordered-containers may be even faster
15:18:59 <ChongLi> it's all about the constant factors :)
15:19:27 <halvorg> Thanks, I'll check out Set.
15:19:28 <ChongLi> the big one being whether computing the Ordering is expensive enough to justify using Hashing
15:19:34 <dmwit> radixSort ;-)
15:19:39 <halvorg> n^2 is a bit much when n is over 1m
15:19:45 <dmwit> countingSort if it's a particularly small type, maybe
15:19:59 * hackagebot base16-bytestring 0.1.1.6 - Fast base16 (hex) encoding and decoding for ByteStrings  http://hackage.haskell.org/package/base16-bytestring-0.1.1.6 (BryanOSullivan)
15:20:15 <ChongLi> yeah Set should work nicely for you
15:21:55 <ChongLi> Set.fromList is O(n * log n)
15:22:07 <ChongLi> so theoretically it should be faster than just using nub?
15:22:42 <janua> Is anyone familiar with Text.JSON? I can't understand how a Result type gets flattened
15:23:06 <bob1> hi I am just wondering if there is any tail recursive version of depth of a binary tree?
15:23:27 <quchen> ChongLi: using `toList . fromList` is less lazy than nub though.
15:23:46 <quchen> What you really want is take the nub source and write it using a Set as a buffer.
15:24:07 <Twey> ChongLi: Yes
15:24:25 <ChongLi> yeah, if you can avoid allocating the giant list in the first place and just stream it into a Set
15:24:30 <ChongLi> you should be golden, right?
15:24:57 <c_wraith> Set.fromList is O(n * log k) where n is the size of the list, and k is the number of unique elements in the list
15:24:58 <ChongLi> allocating giant lists seems to never be what you want to do
15:24:59 * hackagebot Dish 0.0.0.1 - Hash modules (currently Murmur3)  http://hackage.haskell.org/package/Dish-0.0.0.1 (zcourts)
15:25:12 <c_wraith> Be careful about that difference, sometimes it matters
15:25:39 <ChongLi> but if that list is ordered
15:25:47 <ChongLi> it apparently becomes O(n)
15:25:52 <kristof> everyone always wishes every list to be ordered
15:26:14 <quchen> Not really, no.
15:26:15 <kristof> the painful fact about lists is that they're usually not :'(
15:26:21 <quchen> Often "ordered" doesn't even make sense.
15:26:34 <kristof> quchen: If order matters later, then it does
15:26:44 <c_wraith> often times, the list is ordered by meaning
15:26:54 <quchen> Then most likely List is not the right data structure.
15:27:08 <kristof> Why doesn't Haskell have heterogeneous lists?
15:27:13 <shachaf> @let sub :: Ord a => [a] -> [a]; sub = go S.empty where go s [] = []; go s (x:xs) | x `S.member` s = go s xs | otherwise = x : go (S.insert x s) xs
15:27:14 <lambdabot>  Defined.
15:27:21 <simpson> bob1: Yeah, it's possible. Why?
15:27:27 <shachaf> Because heterogeneous lists make no sense.
15:27:31 <Twey> kristof: It does
15:27:42 <kristof> Twey: Not an explictly included datatype, I've seen implementations though
15:27:47 <dwcook> Twey, ah, I must have misremembered. It's been a while since I toyed with Agda
15:28:14 <Twey> kristof: The original H98 type system wasn't powerful enough to express them (though it did have tuples, which are similar)
15:28:27 <kristof> Tuples are too fixed for me!
15:28:38 <quchen> Tuples? For heterogeneous lists?
15:28:39 <kristof> Sometimes you just wanna link a bunch of stuff together and throw it somewhere
15:28:42 <bob1> @simpson I am right now using depth (Branch b l r) = 1 + max (depth l) (depth r) but I am trying to make it faster, is that possible?
15:28:42 <lambdabot> Unknown command, try @list
15:28:43 <quchen> How does that work
15:28:45 <Twey> dwcook: It lacks inference for function types
15:28:47 <kristof> ...Maybe I've been Lisping too much
15:29:19 <arcke> im trying to read in a large list from a file by using eval (http://lpaste.net/98708) - i get the error 'The last statement in a 'do' block must be an expression'
15:29:23 <Twey> kristof: That's what tuples are for :þ  You can use only pairs and unit, and you get basically heterolists (with an ugly syntax).
15:29:43 <quchen> Oooh. That's pretty lispy.
15:29:45 <Twey> quchen: Type-indexed ones, yes, not the existential kind
15:30:13 <Twey> kristof: It's a wart of Haskell's that (a, b, c) is magic and not equivalent to (a, (b, (c, ())))
15:30:19 <simpson> bob1: Well, tail recursion isn't necessary for speed in Haskell, as I understand.
15:30:31 <Twey> Which makes it impossible to define things on tuples by induction
15:30:35 <bob1> @simpson why?
15:30:35 <lambdabot> Unknown command, try @list
15:30:36 <simpson> bob1: I'm not immediately sure how to make your example faster, but I'm sure that there's ways to do it.
15:30:45 <quchen> Twey: Indexing "nested tuple" tuples would be O(n) though, wouldn't it?
15:31:01 <Twey> quchen: For a constant ‘n’, so no :þ
15:31:02 <bob1> @simpson cool thanks, by the way how do you reply to some user?
15:31:03 <lambdabot> Unknown command, try @list
15:31:22 <monoidal> arcke: this is wrong: i <- eval s::String []::(IO Maybe String)
15:31:35 <monoidal> arcke: do you just want i <- eval s :: IO (Maybe String)?
15:31:38 <acowley> How is it constant n?
15:31:59 <monoidal> arcke: or maybe try just i <- eval s
15:32:06 <Twey> acowley: Because a different value of n results in a different type, and that type is known statically
15:32:09 <simpson> bob1: So, is your current depth function too slow?
15:32:14 <arcke> monoidal: in the file there is list encoded like in haskell '["STRING1","STRING2", ... ]'
15:32:21 <bob1> @simpson yes it is
15:32:21 <lambdabot> Unknown command, try @list
15:32:34 <monoidal> arcke: what's the type of eval?
15:32:37 <Twey> bob1: You're confusing lambdabot
15:32:39 <arcke> monoidal: i want to read in this list
15:32:51 <silasm> bob1: I asked this myself: https://stackoverflow.com/questions/13042353/does-haskell-have-tail-recursive-optimization
15:33:00 <silasm> got some good answers
15:33:30 <monoidal> arcke: ah. You probably want eval (read s :: [String])
15:33:58 <Twey> dwcook: s/types/definitions/
15:34:06 <monoidal> arcke: or eval (read s :: [String]) :: IO (Maybe String) - note parens are important
15:34:07 <simpson> bob1: Are you already compiling with -O2?
15:34:12 <dolio> Why do people only ever ask about tail recursion?
15:34:18 <bob1> @simpson yes
15:34:18 <lambdabot> Unknown command, try @list
15:34:39 <shachaf> bob1: lambdabot is asking you not to address people with "@person message". Use "person: message" instead.
15:34:49 <silasm> dolio: because they came from lisp or any other one of the handful of functional languages that use TCO? *shrugs*
15:34:58 <Twey> dwcook: AFAIK it's just recursion that trips it up, so it requires annotations where you could make something recursive
15:35:08 <Twey> silasm: Like C?  :þ
15:35:13 <acowley> Twey: Still sounds O(n)'ish to me
15:35:14 <dolio> No, my point is that they always ask about recursion.
15:35:33 <acowley> Twey: We spend a lot of time wrestling with indexing performance in vinyl
15:35:40 <arcke> monoidal: ok, let me see
15:35:46 <dwcook> Twey, why is that, in brief terms?
15:35:59 <bob1> shachaf:Got that
15:36:10 <dolio> Lots of compilers optimize tail recursion, but not other tail calls, and that still sucks.
15:36:10 <acowley> There are various ways to make GHC unroll things, but it's hard to avoid performance depending on the magnitude of the index
15:36:15 <monoidal> arcke: oh, now I understand
15:36:40 <monoidal> arcke: you wanted eval (s :: String) [] :: IO (Maybe String)
15:37:31 <arcke> monoidal: i actually need [String], i was wrong there
15:37:31 <acowley> dolio: I think it's because of how recursion and iteration are taught using Scheme-y semantics
15:37:43 <acowley> basically what silasm said, actually
15:37:45 <dolio> It'd especially suck in Haskell, because every call is a tail call.
15:37:54 <monoidal> arcke: System.Eval.Haskell.eval takes a String, not a [String]
15:38:33 <monoidal> arcke: Remember the :: operator does not perform 'cast' as in other languages. the only thing it can do is restrict a polymorphic type.
15:38:57 <Twey> dwcook: AIUI, type inference for recursive definitions in Haskell works by assigning the current definition type ‘a’, generating a constraint from how it's used in the definition body, then checking that against the inferred type of the whole definition; you can't do that in Agda because it doesn't have that kind of polymorphism
15:39:16 <monoidal> arcke: e.g. given 'f = id' we have 'f :: a -> a', but if 'f = id :: Int -> Int' then 'f' has more specific type "Int -> Int"
15:39:29 <Twey> s/checking/matching/
15:39:42 <jrmithdobbs> acowley: i don't get why recursion *isn't* taught in terms of fix
15:40:44 <arcke> monoidal: yes, i given string s, i want to evaluate the string and store the result which should be a list of strings in a new variable
15:40:57 <Twey> acowley: I guess you can call it O(n) for an ‘arbitrary tuple’, but that leads to it being constant-time for a given type (in Vinyl too, I'd assume?)
15:41:06 <acowley> I honestly can't imagine what it would be like if you were taught things through fix. I learned iteration, mutation, etc. first. I bet someone who was given only fix would have a differently shaped brain when all is said and done.
15:41:11 <dolio> The variables in type inference are not the same as the variables in polymorphism, in both Agda and Haskell.
15:41:30 <monoidal> arcke: so you need to use :: on the result of "eval", not on "s".
15:41:37 <jrmithdobbs> acowley: by the time i came upon fix i wanted to *murder* someone for all the wasted time
15:41:38 <acowley> Twey: Yeah, but the point is to make a distinction from an array or vector.
15:41:48 <monoidal> arcke: i.e. i <- eval s [] :: IO (Maybe [String])
15:41:49 <jrmithdobbs> acowley: but i couldn't figure out who
15:41:52 <dolio> Agda's type system is just harder to get all cases right than Haskell's.
15:42:10 <acowley> jrmithdobbs: I think it's pretty good to learn them all
15:42:44 <jrmithdobbs> acowley: i agree, just for me, i know it's not true for everyone, fix is what finally made it click what was "really" going on
15:42:48 <dolio> Although maybe not (much) harder than with every GHC extension turned on.
15:43:06 <Twey> dolio: Do you know how the inference works for recursive types in Haskell?
15:43:14 <Twey> s/types/terms/
15:43:16 <dolio> Twey: It works the way you said.
15:43:20 <Twey> Oh, okay.
15:43:32 <arcke> monoidal: ok, got it
15:43:44 <dolio> Make up a metavariable for the definition, infer the body delegating to that variable, then unify the inferred type with that variable.
15:43:49 <dolio> Then generalize.
15:43:54 * Twey nods.
15:46:56 <Twey> jrmithdobbs: Interesting.  I've always found fix less intuitive than direct recursion.
15:49:20 <acowley> Me, too
16:08:24 <guesting> why would "foldl' (+) 0 . union' [1..10000000] $ [1000000..100000000]" result in a stack overflow, where "union'" is the defined as union in Data.List but with foldl' instead of foldl?
16:08:27 <roboguy_> I'm trying to tell the people in the programming language design channel about how cool applicative functors are, but they don't seem to be buying it... oh well
16:09:01 <guesting> That is, unionBy' (==)
16:09:16 <guesting> where unionBy' (==) has foldl' instead of foldl.
16:09:22 <roboguy_> guesting: did you try sum?
16:09:40 <guesting> roboguy_: Sum results in a stack overflow, I know definitely not to use that
16:09:54 <guesting> roboguy_: foldl' (+) 0 always works
16:10:18 <dwcook> roboguy_, I find that trying to use Haskell concepts in other languages is often painful
16:10:46 <roboguy_> dwcook: hmm, yeah, but I feel like idiom brackets or something like that, might be able to transfer
16:10:54 <dwcook> e.g., https://github.com/fantasyland/fantasy-land is pretty good but isn't that pretty overall
16:11:32 <guesting> btw, unionBy' is defined as: unionBy' eq xs ys =  xs ++ foldl' (flip (deleteBy eq)) (nubBy eq ys) xs
16:11:37 <guesting> and that gives a stack size overflow
16:11:57 <guesting> and there is no folding in nubBy or deleteBy
16:12:07 <zomg> dwcook: this is like the third JS library I see that implements those.. :D
16:13:06 <roboguy_> well, ideally they're designing something that has less... quirks than JS
16:13:10 <roboguy_> I hope
16:14:34 <MasseR_> How would I write the following with lenses? map (map _entryName) $ map _categoryEntries $ _searchCategories result
16:14:47 <dwcook> zomg, I was going to say "That's the problem, frac—" then forgot the word I was looking for that began with frac-
16:14:50 <roboguy_> guesting: you could use the closed form for the sum. that would change it quite a bit though
16:15:23 <guesting> roboguy_: I don't think the sum is the issue, foldl' (+) 0 works perfectly on gargantuan lists
16:15:38 <zomg> dwcook: heh
16:15:59 <zomg> dwcook: fracturization or something? :P
16:16:12 <guesting> roboguy_: I just testing the foldl' on the giant list and it works fine, the union is the issue.
16:16:13 <zomg> probably spelled it a bit wrong 'cause it doesn't sound right...
16:16:15 <dwcook> I'm not even convinced the word I wanted began with frac- anymore :P
16:16:21 <zomg> heh
16:16:30 <edwardk> let's fuse that a bit you can go to map (map _entryName . _categoryEntries) $ _searchCategories result      so it'd probably be searchCategories^..traverse.categoryEntries.traverse.entryName
16:16:34 <dwcook> Basically, too many alternatives, none of which has a strong enough following
16:16:40 <shachaf> MasseR_: Perhaps: result ^.. searchCategories . traverse . categoryEntries . traverse
16:16:40 <roboguy_> guesting: the problem is that union probably tests every element in the first list against every element in the second list at least once
16:16:50 <roboguy_> that's a lot of steps
16:16:51 <shachaf> Er, yes, . entryName
16:16:53 <shachaf> What edwardk said.
16:17:03 <edwardk> er
16:17:06 <edwardk> sorry
16:17:13 <guesting> roboguy_: True, but it's all tail recursion, right?
16:17:15 <ocharles> isn't it map (map _entryName . map _categoryEntries) ?
16:17:18 <shachaf> OK, not quite what edwardk said.
16:17:24 <edwardk> result^..searchCategories.traverse.categoryEntries.traverse.entryName
16:17:30 <guesting> roboguy_: It will take a while but it shouldn't stack overflow
16:17:41 <edwardk> result^..searchCategories.each.categoryEntries.each.entryName  'd be more concise
16:17:42 <shachaf> result ^.. searchCategories . traverse . categoryEntries . traverse . entryName
16:17:47 <roboguy_> guesting: the stack works differently in haskell than most language's runtimes
16:17:58 <shachaf> edwardk and I make different mistakes, but in the end we're confluent, so it's OK.
16:17:59 <roboguy_> that's why tail recursion isn't used all that often, actually
16:18:02 <roboguy_> (in Haskell)
16:18:04 <edwardk> =)
16:18:10 <ocharles> > map length ["mapped", "traverse"]
16:18:11 <lambdabot>  [6,8]
16:18:18 <shachaf> ocharles: folded, not mapped
16:18:20 <ocharles> there's some golf oportunity if mapped is sufficient ;)
16:18:24 <ocharles> oh
16:18:26 <guesting> roboguy_: But...
16:18:37 <guesting> foldl' (+) 0 [1..100000]
16:18:46 <shachaf> Of course, this only happens to work because you were using lists.
16:18:49 <guesting> How do you get the lambdabot
16:18:52 <guesting> to do stuff
16:18:53 <triliyn> ocharles: character golf is less fun than token golf anyway
16:18:54 <roboguy_> guesting:  >
16:18:57 <sipa> > 5
16:18:59 <lambdabot>  5
16:19:02 <guesting> > foldl' (+) 0 [1..100000]
16:19:02 * ocharles re-reads what "mapped" is
16:19:03 <lambdabot>  5000050000
16:19:03 <shachaf> lens is fairly list-oriented.
16:19:05 <guesting> cool
16:19:08 <guesting> > foldl' (+) 0 [1..1000000000000]
16:19:12 <lambdabot>  mueval-core: Time limit exceeded
16:19:12 <shachaf> Character golf is great.
16:19:18 <shachaf> @where e_10
16:19:18 <lambdabot> [show(sum$scanl div(100^n)[1..[4..]!!n])!!n|n<-[0..]]
16:19:20 <guesting> > foldl' (+) 0 [1..100000000]
16:19:21 <geekosaur> you can also talk to it in a /query window
16:19:24 <lambdabot>  mueval-core: Time limit exceeded
16:19:26 <guesting> good idea
16:19:31 <shachaf> lambdabot is a very bad environment for testing performance in.
16:19:36 <edwardk> > [show(sum$scanl div(100^n)[1..[4..]!!n])!!n|n<-[0..]]
16:19:38 <lambdabot>  "271828182845904523536028747135266249775724709369995957496696762772407663035...
16:19:38 <guesting> haha I notice
16:20:17 <roboguy_> guesting: I have a feeling that part of the problem is unionBy's lack of strictness in it's arguments
16:20:39 <guesting> roboguy_: But the function itself is not recursive
16:21:03 <roboguy_> oh, right
16:21:26 <MasseR_> shachaf: Magnificent, thanks
16:21:40 <roboguy_> guesting: it's probably just not a very efficient implementation of union. it would probably be a lot faster to use Set
16:21:41 <MasseR_> and edwardk too
16:21:50 <roboguy_> it looks like it deletes stuff at least twice
16:21:59 <guesting> roboguy_: Set? From what?
16:22:01 <b2coutts> is there some nice way to get an infinite decreasing list from a number? I'm currently using map (n-) [0..]
16:22:10 <roboguy_> guesting: Data.Set
16:22:19 <guesting> roboguy_: fascinating, let me try
16:22:44 <knrafto> > [10,9..]
16:22:45 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
16:23:30 <b2coutts> knrafto: the number is a variable, though
16:23:44 <knrafto> > let n = 10 in [10,9..]
16:23:45 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
16:23:45 <triliyn> b2coutts: [n, n-1..]
16:23:49 <knrafto> it still works
16:24:02 <knrafto> oops
16:24:41 <guesting> roboguy_: It works!!
16:24:43 <knrafto> > let n = 10 in [n, n-1 ..]
16:24:44 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
16:24:47 <triliyn> (I think this is slightly inefficient in that it does one or two more subtractions than are necessary; if for some reason subtraction is expensive you could use enumFromTo directly)
16:24:58 <triliyn> er, wait
16:25:05 <geekosaur> you could also write enumFromThen n (n-1) but that's just the long form of [n, n-1 ..]
16:25:06 <guesting> roboguy_: I am learning more and more to avoid lists, which is unfortunate because they are like my favorite thing :/
16:25:06 <triliyn> This would be
16:25:24 <triliyn> Isn't there an enumFromToWithStep or something?
16:25:32 <triliyn> :t enumFromToWithStep
16:25:33 <lambdabot> Not in scope: `enumFromToWithStep'
16:25:41 <triliyn> hmm
16:25:42 <shachaf> enumFromThenTo
16:25:45 <shachaf> @pl [a,b..c]
16:25:46 <lambdabot> [a,b..c]
16:25:55 <triliyn> er, wait, why do I keep thinking "to"
16:25:57 <shachaf> Hmm, maybe not.
16:26:00 <roboguy_> guesting: it depends on what you're doing. they can be thought of as a sort of data representation of a loop, where each element is one iteration
16:26:03 <shachaf> @pl \a b c -> [a,b..c]
16:26:03 <lambdabot> enumFromThenTo
16:26:06 <triliyn> You don't want "to" with an infinite list!
16:26:15 <shachaf> But there's no "step", just a second value.
16:26:24 <triliyn> hmm, okay
16:26:43 <roboguy_> guesting: right now, you're doing something that is inherently more efficient with unordered collections, so Set is better
16:26:56 <knrafto> > unfoldr (\x -> let x' = x - 1 in Just (x', x')) 10
16:26:57 <roboguy_> well, conceptually unordered
16:26:58 <lambdabot>  [9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,...
16:27:03 <knrafto> so close
16:27:20 <rdevilla> why am I getting this when I try to use `cabal repl`? http://bpaste.net/show/169249/
16:27:23 <rdevilla> I am in a sandbox
16:27:25 <guesting> roboguy_: Except I have to convert between a list and a set which takes time
16:28:01 <knrafto> > unfoldr (\x -> Just (x, x - 1)) 10
16:28:02 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
16:28:05 <roboguy_> guesting: yeah that's true. too bad Data.Set doesn't provide an unfold...
16:28:28 <roboguy_> actually, I'm not sure if that would be more efficient. hmm
16:30:40 <roboguy_> I wonder if you could do some kind of stream fusion here
16:33:38 <roboguy_> guesting: this problem kind of reminds me of this article http://donsbot.wordpress.com/2008/06/04/haskell-as-fast-as-c-working-at-a-high-altitude-for-low-level-performance/
16:36:07 <guesting> roboguy_: That is WAY above my level, I'm just trying to figure out where the stack space overflows are happening haha
16:37:25 <roboguy_> ah, hah
16:37:54 <rdevilla> ugg fuck cabal ._.
16:37:55 <roboguy_> guesting: well, as I understand it, Haskell uses a sort of pattern match stack rather than a normal function call stack. that's why you can get stack overflows on tail recursive functions
16:38:35 <guesting> roboguy_: I thought you write tail recursion in order to AVOID stack overflows
16:39:36 <triliyn> guesting: that's true with most evaluation strategies, and sometimes true with haskell, but not always
16:39:37 <roboguy_> guesting: not really in Haskell
16:42:10 <triliyn> (where I suppose by "most evaluation strategies" I mean "the evaluation strategy used by most languages, namely strict evaluation")
16:42:28 <shachaf> "strict" isn't really an evaluation strategy.
16:43:20 <FreeFull> The order in which the arguments to a C function are evaluated is up to the compiler
16:43:38 <triliyn> Then I don't know the correct names for the things I'm talking about
16:44:11 <roboguy_> shachaf: I know wikipedia isn't always right, but I always assumed that was the term: http://en.wikipedia.org/wiki/Strict_evaluation
16:44:36 <roboguy_> unless you mean that it isn't a specific evaluation strategy, I guess
16:44:48 <shachaf> The title of that page isn't "Strict evaluation".
16:44:56 <roboguy_> I know
16:44:59 <FreeFull> Eager
16:45:07 <roboguy_> shachaf: look under "Evaluation Strategies" on the left side-bar
16:45:16 <roboguy_> *right sidebar
16:45:17 <shachaf> Maybe https://en.wikipedia.org/wiki/Evaluation_strategy is more clear.
16:45:26 <guesting> roboguy_: So how come "partition (>300) [1..10000000000000000]" has no stack size overflow, but "foldr (+) 0 [1..100000000000000]" does?
16:45:46 <roboguy_> guesting: because the foldr one builds up a huge thunk
16:45:57 <guesting> roboguy_: partition is defined by "partition p xs = foldr (select p) ([],[]) xs"
16:46:02 <shachaf> "Strict evaluation" isn't an evaluation strategy, just like "Other" isn't an evaluation strategy.
16:46:07 <xxen> foldr isn't even tail recursive you mean foldl
16:46:32 <roboguy_> shachaf: it's a family of evaluation strategies, right?
16:46:37 <shachaf> guesting: Look at a simpler example, like map.
16:47:48 <guesting> shachaf: map is tail recursive, it has no foldr
16:48:01 <shachaf> map is not tail-recursive, and it is a foldr.
16:48:16 <shachaf> Also, forget about tail recursion. It's not important.
16:48:21 <roboguy_> @src map
16:48:21 <lambdabot> map _ []     = []
16:48:21 <lambdabot> map f (x:xs) = f x : map f xs
16:48:28 <guesting> shachaf: Huh? map f (x:xs) = f x : map f xs
16:48:37 <guesting> that's tail recursive
16:48:39 <roboguy_> guesting: map is not the tail call
16:48:43 <roboguy_> guesting: (:) is
16:48:44 <shachaf> That is not tail-recursive.
16:49:06 <guesting> what
16:49:10 <eazar001> it's not
16:49:10 <guesting> you're blowing my mind
16:49:25 <roboguy_> guesting: how about map f (x:xs) = (:) (f x) (map f xs)
16:49:29 <shachaf> > let map f = foldr (\x xs -> f x : xs) [] in map (+1) [1,2,3]
16:49:30 <lambdabot>  [2,3,4]
16:49:31 <roboguy_> that's the same thing written differently
16:50:13 <guesting> so you're saying that map is evaluated like foldr, wow
16:50:16 <shachaf> Tail recursion is not important.
16:50:30 <eazar001> guesting: make an accumulator, that would be one approach, and force strict evluation
16:50:39 <guesting> but how come foldr breaks down on big lists but map doesnt?
16:50:40 <eazar001> but it would be in reverse order
16:50:48 <shachaf> Neither one breaks down on big lists.
16:51:23 <guesting> foldr (+) 0 $ [1..10000000000000000000000] breaks down
16:51:30 <guesting> stack space overflow
16:51:32 <shachaf> Yes.
16:51:53 <guesting> ...
16:52:03 <eazar001> tail recursion can also be less efficient if it has to traverse the entire list
16:52:16 <triliyn> That's not because of foldr, it's because (+) is nonstrict
16:52:39 <shachaf> (+) is strict
16:52:57 <eazar001> foldr is non-strict
16:52:58 <triliyn> er
16:52:59 <eazar001> (+) is strict
16:53:00 <triliyn> right
16:53:12 <guesting> ok, so why does it break down
16:53:21 <guesting> too many thunks, right?
16:53:28 <triliyn> Because the calls to (+) are not reduced
16:53:28 <guesting> I was told because it was not tail recursive
16:53:42 <shachaf> Forget about tail recursion.
16:53:57 <shachaf> And forget about "breaks down on big lists", it's too vague.
16:54:01 <eazar001> you can have memory issues with tail recurison too
16:54:24 <monoidal> perhaps comparing fix (1:) with fix (1+) might help
16:54:38 <guesting> OK, so the thunks build up with + but not select
16:55:16 <guesting> but they both take in 2 arguments
16:55:22 <shachaf> Hmm, I'd even say "forget about thunks".
16:55:27 <guesting> what
16:55:38 <guesting> so what should i not forget
16:56:03 <shachaf> Hmm, what's a good article.
16:56:07 <shachaf> @where lazy
16:56:07 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
16:56:10 <shachaf> Maybe that.
16:57:23 <shachaf> You should evaluate some things by hand. Say, head (map (+1) (repeat 1))
16:57:48 <FreeFull> + can be non-strict on its second argument for certain numeric types
16:58:03 <FreeFull> Usually lazy nats
17:01:13 <guesting> So how is (+) different from (:)?
17:01:40 <guesting> They both take two arguments and combine them
17:02:15 <shachaf> Two-argument functions are too complicated. Use one-argument functions, like (1+) and (1:)
17:02:22 <shachaf> (1+) is strict, (1:) is not strict.
17:02:23 <guesting> but foldr is fine with (:), but not ok with (+)
17:02:32 <verement> (:) is a data constructor
17:02:39 <carter> :t (:)
17:02:40 <lambdabot> a -> [a] -> [a]
17:02:42 <carter> :t (+)
17:02:43 <lambdabot> Num a => a -> a -> a
17:02:54 <carter> you can write a foldr that takes (+)
17:02:56 <guesting> ohhhhhhhh
17:03:00 <guesting> ohhhhhhhhhhhhhhhh
17:03:15 <shachaf> Being a data constructor is not magic.
17:03:29 <guesting> what is another strict function in haskell?
17:03:33 <guesting> for example
17:03:56 <FreeFull> shachaf: (1+) is usually strict
17:04:41 <verement> Haskell can pattern match on (:) but not on (+)
17:04:44 <guesting> so by being lazy, no thunk is built as the "promise" does not occur yet, while with (+) the thunk is built as the next iteration MUST be evaluated?
17:04:47 <guesting> Is that correct?
17:05:01 <nooodl> so hard not to mention n+k patterns
17:05:12 <shachaf> Did you read the article I linked to before?
17:05:20 <guesting> Yeah, I went to the foldr part
17:05:20 <verement> n+k patterns excepted
17:05:25 <shachaf> verement: Yes, but that's not important.
17:05:37 <shachaf> Don't skip to the foldr part. Read the whole thing. foldr isn't important.
17:05:43 <guesting> the counterexample was boolean
17:05:46 <guesting> ok
17:06:24 <shachaf> You should evaluate a bunch of things by hand.
17:11:41 <mm_freak_> if anyone has doubt that GHC produces very fast code…  i'm processing 1 GiB in 1.7 secs using pipes + pipes-parse =)
17:14:40 <roboguy_> mm_freak_: what are you doing to it?
17:15:32 <mm_freak_> roboguy_: i'm splitting the stream into lines using my own version of 'lines' from pipes-bytestring, then counting the number of FreeT layers
17:15:50 <mm_freak_> in other words, i'm counting the number of lines in a non-obvious way =)
17:15:57 <roboguy_> I don't really know enough about free monads to fully understand that, haha
17:16:21 <roboguy_> well, actually it's probably more that I don't know enough about pipe
17:16:23 <roboguy_> *pipes
17:16:46 <mm_freak_> FreeT is used to add delimiters to the stream
17:17:42 <mm_freak_> a 'FreeT (Producer X m) m r' is a producer, that produces a number of X values and at some point stops and returns another producer
17:17:51 <guesting> Where is the definition for (:) located?
17:17:57 <mm_freak_> this has the effect of having delimited producers
17:18:04 <guesting> It's not on hoogle, prelude, or Data.List source
17:18:12 <mm_freak_> guesting: Prelude
17:18:15 <roboguy_> hmm
17:18:18 <shachaf> It is built-in.
17:18:40 <roboguy_> you could probably think of it like data [a] = [] | a : [a]
17:18:45 <roboguy_> ^ guesting
17:18:55 <mm_freak_> guesting: in GHC Prelude imports it from GHC.Types
17:19:32 <roboguy_> which is the same as data List a = Nil | Cons a (List a)
17:19:52 <halvorg> http://lpaste.net/98713, there are no other ways to place non-redundant parens in an expression of that form yes?
17:19:56 <mm_freak_> which is the same as Free Maybe a =)
17:20:02 <guesting> thanks
17:20:11 <roboguy_> mm_freak_: actually, I figured that out myself maybe a week ago!
17:20:14 <roboguy_> progress
17:21:25 <dmwit> halvorg: The fourth Catalan number is 5, and you have 5 expressions. So that's pretty good evidence you got them all.
17:21:29 <m3ga> hvr: while cabal installing hspec and criterion with ghc from git i get : Failed to load interface for ‛GHC.Integer.Type’ Perhaps you haven't installed the "p_dyn" libraries for package ‛integer-gmp’?
17:21:53 <m3ga> wrong channel
17:22:08 <roboguy_> m3ga: I'm having the same problem
17:22:26 <mm_freak_> roboguy_: i was lying…  Free Maybe is not isomorphic to []
17:22:27 <roboguy_> m3ga: are you using ghc head?
17:22:38 <roboguy_> mm_freak_: damn
17:22:40 <halvorg> dmwit: cool
17:22:44 <roboguy_> I guess that makes sense though now that I think about it
17:24:09 <mm_freak_> roboguy_: i think an interesting practical example of Free is Free IO…  a value of type 'Free IO a' is a delimited IO action that eventually results in an 'a'
17:24:17 <shachaf> Free Maybe a is like (Nat, Maybe a)
17:24:29 <roboguy_> shachaf: that makes sense
17:24:29 <m3ga> roboguy_: yes, we should switched this discussion to #ghc
17:24:43 <roboguy_> m3ga: works for me
17:24:47 <mm_freak_> roboguy_: that's the sense in which pipes-parse uses FreeT
17:25:08 * hackagebot HaskellNet-SSL 0.2.1 - Helpers to connect to SSL/TLS mail servers with HaskellNet  http://hackage.haskell.org/package/HaskellNet-SSL-0.2.1 (DanielWright)
17:26:14 <roboguy_> hmm, interesting
17:26:26 <roboguy_> I read an article on FP complete that talked about a very similar concept
17:26:31 <roboguy_> in fact, I think it was isomorphic to Free
17:27:08 <mm_freak_> you could rename Free to Coroutine
17:27:31 <mm_freak_> in fact FreeT is a reinvention of monad-coroutine's Coroutine monad transformer
17:28:03 <roboguy_> yeah it was the coroutine articles
17:28:36 <mm_freak_> and that makes a lot of sense, because coroutines are delimited actions…  actions which can be suspended and resumed
17:29:07 <mm_freak_> or rather:  actions that can suspend themselves and be resumed
17:29:11 <roboguy_> yeah. I still have some trouble picturing coroutines in haskell though. I haven't looked at too many examples though
17:29:24 <roboguy_> the Free representation sort of makes sense
17:29:58 <mm_freak_> you have probably used coroutines =)
17:30:35 <roboguy_> I've explicitly used coroutines in other languages
17:30:40 <roboguy_> so, yep!
17:30:42 <roboguy_> hah
17:30:47 <mm_freak_> in haskell
17:31:06 <mm_freak_> each time you construct a list and then consume it you're using a special case of coroutines
17:31:14 <hpc> i always read coroutine as "dual of routine" instead of "cooperative routines"
17:32:05 <mm_freak_> hpc: you could view coroutines in terms of corecursion and recursion
17:32:13 <iron_houzi> I'm taking a course on functional programming at my uni. It seems like it's a very good course. It's using scheme and I was wondering if anybody knows if there's something equivalent to monads in the Scheme world? My lecturer didn't know any Haskell, so he couldn't really say.
17:32:16 <arcke> how can I lift sum to operate on [Maybe Int]?
17:32:37 <roboguy_> iron_houzi: that's kind of a complex question
17:32:45 <mm_freak_> arcke: depends…  what do you want to do with Nothings?
17:33:11 <arcke> mm_freak_: wont happen, so ill add 0
17:33:15 <jrmithdobbs> mm_freak_: are they really coroutines if they're not explicit?
17:33:24 <mm_freak_> arcke: then apply catMaybes from Data.Maybe first
17:33:35 <roboguy_> iron_houzi: the Monad type class in haskell is uses a certain kind of polymorphism that doesn't exist in scheme. the concept of a monad exists in a lot of languages in disguise (sort of)
17:33:48 <arcke> @src catMaybes
17:33:49 <lambdabot> catMaybes ls = [x | Just x <- ls]
17:33:54 <roboguy_> well let's see is that a good way to put it, hmm...
17:34:01 <mm_freak_> jrmithdobbs: not explicit?
17:34:19 <mm_freak_> iron_houzi: you can use a monadic pattern in scheme, but you don't get monads, because monads are types
17:34:43 <jrmithdobbs> mm_freak_: when I think about coroutines i think of things like ruby's yield, not the implicit behavior of list processing
17:35:13 <arcke> mm_freak_: ok, this works fine
17:35:22 <jrmithdobbs> mm_freak_: i mean it's implemented similarly but is it reallya coroutine if the coordination is done by the compiler
17:35:23 <mm_freak_> jrmithdobbs: constructing a list and then folding it is a special case of the yield/await pattern
17:35:31 <iron_houzi> roboguy_: Polymorphism? I know OOP.. I just hoped I could draw some parallel from what I'd be learning there to learning haskell. I know I'll be using lambda expressions a lot.. and I'm pretty sure we'll be learning to use Scheme in ways that Haskell would normally use monads for, though this is just me guessing/hoping..
17:35:37 <mm_freak_> jrmithdobbs: the coordination is not done by the compiler
17:35:47 <roboguy_> iron_houzi: it's a very, very different kind of polymorphism that OOP
17:36:04 <roboguy_> iron_houzi: in fact "class" in haskell really has no relation to OOP. it's unfortunate that they have the same name
17:36:19 <iron_houzi> roboguy_: Yeah, I was surprised that you drew the link to polymorphism as I know it from OOP.
17:36:34 <mm_freak_> iron_houzi: roboguy_ is referring to parametric polymorphism, which has no scheme counterpart, because scheme is not statically typed
17:36:49 <iron_houzi> I see.
17:36:55 <roboguy_> mm_freak_: well, you *can* have parametric polymorphism (to an extent) in a dynamically typed language)
17:37:05 <roboguy_> mm_freak_: something like return :: a -> m a would be difficult though
17:37:37 <jrmithdobbs> mm_freak_: can you expand on that statement? I guess the coordination is still defined by the constructs of it's defining statements, not by the compiler, that is subtly different
17:37:58 <mm_freak_> roboguy_: a non-static language can be thought of as a static language with a single monomorphic type
17:38:14 <mm_freak_> roboguy_: corresponding to haskell's Dynamic
17:38:32 <roboguy_> mm_freak_: yeah. you can always do dynamic despatch (although, like I said, it's hard when the polymorphism is in the result type like it is in return)
17:38:41 <roboguy_> Common Lisp has a whole library for it
17:39:06 <mm_freak_> jrmithdobbs: whether you 'yield' or (:) is the same thing, and whether you 'await' or 'case' is also the same thing…  in both cases explicit, in both cases computation is performed at some point
17:39:18 <mm_freak_> jrmithdobbs: think of haskell lists of a control structure
17:39:26 <darthdeus> hey guys, when i do cabal update i get "There's a newer version of cabla-install available ... To upgrade, run: cabal install cabal-install" ... but then ido cabal install cabal-install, and after that cabal update shows the same message
17:39:51 <hakujin> darthdeus: you don't have cabal's bin directory in your PATH
17:40:00 <darthdeus> oh
17:40:04 <geekosaur> or you do ut you need to convince your shell to look again (hash -r)
17:40:15 <hakujin> usually ~/.cabal/bin
17:40:18 <mm_freak_> geekosaur: that's only for completion
17:40:23 <jrmithdobbs> mm_freak_: ok, that answers my question :)
17:40:27 <geekosaur> keep telling yourself that
17:40:33 <geekosaur> no, it's not only for completion
17:40:34 <darthdeus> got it, thanks guys :)
17:40:50 <mm_freak_> geekosaur: isn't it?  at least in zsh it is
17:41:00 <darthdeus> i had it in path but too far down
17:41:18 <geekosaur> no, any shell written in the past 15 years does not do a PATH search every time it runs a command, it caches where it found it
17:41:29 <geekosaur> hash -r flushes the cache, as does explicitly setting $PATH
17:41:35 <jrmithdobbs> mm_freak_: nah in sh/bash hash -r isn't just for completion
17:41:44 <mm_freak_> hmm
17:41:52 <geekosaur> (in csh/tcsh it's "rehash")
17:42:08 <jrmithdobbs> it's hard these days (using bash, at least) to *accidentally* fuck things up where you need to hash -r because it's pretty eager about dropping it
17:42:59 <klarh> Is greencard old/unmaintained/superseded by c2hs or is it just just sufficiently mature that development is slow? I don't really see a lot of recent activity for it, which is a little unsettling.
17:43:07 <hakujin> iron_houzi: see typed racket or clojure's core.typed for a bit of haskell bolted on to scheme/lisp
17:43:15 <mm_freak_> i should stop pretending that everything is as elegant as haskell =)
17:44:21 <mm_freak_> iron_houzi: it's difficult to explain /monads/, unless your target audience doesn't mind abstract concepts
17:44:41 <mm_freak_> it's much easier to explain [], IO, Maybe, Writer, …
17:44:54 <klarh> mm_freak_: a monad is just a burrito in the category of mexican foods; what's the problem?
17:45:09 <hpc> strictly speaking, a monad is a type m :: * -> *
17:45:09 <mm_freak_> ;)
17:45:37 <hpc> with operations pure :: a -> m a, fmap :: (a -> b) -> m a -> m b, join :: m (m a) -> m a
17:45:49 <hpc> with some laws
17:45:59 <hpc> and that's it
17:46:14 <mm_freak_> i found it useful to view functors as abstractions to lift functions
17:46:17 <hpc> by sheer coincidence, specific monads happen to be interesting
17:46:20 <jrmithdobbs> or in less words, a monad in haskell is a fancy typeclass to make CPS easier to read
17:46:24 <jrmithdobbs> ;p
17:46:41 <mm_freak_> Functor:  (a -> b) -> (f a -> f b)
17:46:49 <mm_freak_> Applicative:  f (a -> b) -> (f a -> f b)
17:46:56 <mm_freak_> Monad:  (a -> f b) -> (f a -> f b)
17:46:57 <hpc> jrmithdobbs: not really what it is, though; more what it does
17:47:04 <mm_freak_> Comonad:  (f a -> b) -> (f a -> f b)
17:47:23 <hpc> which is the line of thinking that leads to "monads are containers" and such
17:48:00 <jrmithdobbs> hpc: that's an important distinction but more things describing monads should probably start off by mentioning and differentiating exactly that
17:48:16 <jrmithdobbs> at least, in relation to haskell
17:48:28 <hpc> nah; explanations of functor start with the operations
17:48:31 <hpc> or rather, operation
17:48:36 <hpc> same for applicative
17:48:45 <hpc> then they get into applications
17:49:07 <jrmithdobbs> exactly my point? You forgot step one from comp101
17:49:15 <jrmithdobbs> Tell them what you're going to tell them.
17:50:14 <jrmithdobbs> explaining something's construction before knowing it has a, let alone what it's, use is, seems backwards
17:51:34 <mm_freak_> the difference between Functor and Monad is where you put the 'f' =)
17:51:55 <hpc> class Unctorf m where ...
17:54:03 <darthdeus> https://github.com/yi-editor/yi is this actually active? :O
17:54:52 <mm_freak_> darthdeus: apparently yi moved to google code
17:55:25 <mm_freak_> however, the cabal description still links to github
17:55:45 <darthdeus> i can't find it on google code
17:55:54 <darthdeus> there's a bunch of commits from yesterday on github though
17:56:06 <mm_freak_> indeed
17:56:19 <hodapp> I read that as "bunch of commies".
17:56:22 * hodapp rubs eyes
17:56:27 <darthdeus> lol
17:58:39 <Twey> darthdeus, mm_freak_: Fuuzetsu says it moved from Google to GH
17:59:06 <Twey> darthdeus: Yi is definitely active
17:59:34 <Fuuzetsu> no thanks to some naysayers
18:00:23 <mm_freak_> i'm glad =)
18:00:24 <Twey> Fuuzetsu: >.>  I might start using it some day, maybe
18:00:29 <mm_freak_> (that it's still active)
18:00:38 <darthdeus> i just tried it's vim mode, and it's surprisingly good
18:00:41 <Twey> mm_freak_: Activity spiked recently, apparently
18:00:53 <darthdeus> btw if i get a pattern match failure, is there a way to inspect for which values it failed?
18:00:54 <Fuuzetsu> we need devs, please respond
18:01:08 <Fuuzetsu> there's a lot of easy pickings
18:01:42 <mm_freak_> its emacs mode is also good, but it'll take some courage for me to leave emacs behind, which i don't have yet
18:01:52 <darthdeus> i'll definitely look at the source code, but my haskell skillz are uber bad, so not sure if i can help in any way
18:01:59 <darthdeus> mm_freak_: well emacs is more than just an editor :)
18:02:13 <klarh> I don't even use 5% of the magic I could use emacs for but somehow I can't talk myself into leaving it behind
18:03:29 <mm_freak_> well, i use emacs as an editor, and just like i left compiz behind in favor of xmonad some day i'll leave emacs behind as well =)
18:03:37 <darthdeus> i've spent the past week trying to hack on Light Table, and clojurescript is really ... well really not like haskell :D
18:04:19 <darthdeus> i dont think i'll ever leave vim ... it's just way too convenient, fast and ubiquitous, at least for the regular things
18:04:45 <darthdeus> emacs for me is "the thing that can eval haskell in a buffer"
18:06:31 <klarh> at least vim and emacs users can agree to hate on ed
18:07:05 <mm_freak_> i think i'll make myself a yi tonight =)
18:07:17 <Twey> ed is the standard editor!
18:08:01 <darthdeus> ed ftw!
18:08:29 <klarh> my three or so uses of it have left me scared and scarred :>
18:09:14 <dwcook> Familiarity with Vim helps. Slightly.
18:12:44 <geekosaur> I didn't have much trouble with ed, but I'd previous experience with a simplistic text editor for one of the DEC mainframe OSes (all they let us use) that was apparently the model for ed
18:13:26 <geekosaur> as for vi / vim, by that point I had been exposed to TV (visual TECO) and it was pretty much impossible for an editor to scar me :p
18:13:52 <LetterRip> hi all, can someone explain this algorithm to me?  I'm having difficulty undestanding what is going on
18:13:54 <LetterRip> http://pastebin.com/nudfLw7t
18:13:59 <mauke> The paste nudfLw7t has been copied to http://lpaste.net/98714
18:14:36 <LetterRip> I know if is an implementation on nCk mod p
18:14:49 <LetterRip> I know it is an implementation of
18:15:49 <erisco> LetterRip, which part needs explaining? the syntax?
18:15:56 <darthdeus> this is probably a really noob quesiton, but if i compile something on OS X 10.9, and send the binary to someone with 10.8, will it work?
18:16:00 <LetterRip> erisco: yes
18:16:31 <LetterRip> i can see that there are two loops it looks like, and I can understand the divmod
18:16:55 <erisco> darthdeus, presuming they have the same architecture (CPU instruction set) then it is a question about having the same libraries
18:16:59 <LetterRip> is there some commented haskell code somewhere that I could look at?
18:17:00 <geekosaur> darthdeus: generally not
18:17:08 <erisco> darthdeus, but it may work, may not
18:17:11 <LetterRip> doesn't have to be this function commented
18:17:16 <hpc> darthdeus: if your program is sufficiently simple, it could work
18:17:21 <LetterRip> just something that would help me understand what is going on :)
18:17:25 <hpc> it has to have no dependencies that are different between versions
18:17:34 <darthdeus> hmhmm
18:17:38 <geekosaur> Apple adds new loader commands and changes APIs in every release, and the loader commands are often enough to break backward compatibility without heroic measures
18:17:43 <hpc> you can try with somehing like cat
18:17:47 <hpc> main = interact id
18:18:01 <hpc> and see if that behaves on both systems
18:18:06 <darthdeus> so now comes even stupider question ... if someone develops something and sells it on a DVD, how come it works on all versions?
18:18:19 <mm_freak_> LetterRip: haskell is a very different language, and you should read the code more like math than like a procedure
18:18:28 <erisco> LetterRip, are you completely new to Haskell?
18:18:37 <LetterRip> yep
18:18:41 <LetterRip> newb
18:18:50 <hpc> darthdeus: that's going to be out of scope here, since it gets into linker behavior
18:18:56 <geekosaur> darthdeus, there are mechanisms to do backward compatibility. ghc's toolchainw as mostly not developed with them in mind
18:18:58 <erisco> ah, well, I would not start with such a function then LetterRip
18:19:07 <erisco> @lyah
18:19:07 <lambdabot> Unknown command, try @list
18:19:08 <mm_freak_> LetterRip: do you want to learn haskell or just understand what the code does?
18:19:09 <erisco> :(
18:19:13 <darthdeus> ah okay, so it is possible, just not easy by default :)
18:19:15 <hpc> i don't know of any good resources for it
18:19:19 <LetterRip> just understand this code for near term
18:19:28 <LetterRip> haskell is on my todo list
18:19:29 <geekosaur> also, you tend to have to build stuff on Leopard because Apple only ever supports targeting the current and immediate previus release
18:19:30 <erisco> LetterRip, this is the goto resource for beginners http://learnyouahaskell.com/
18:19:52 <pavonia> erisco: it's @where lyah
18:19:54 <LetterRip> but don't have time right this second
18:19:57 <mm_freak_> LetterRip: then read the sections in LYAH (see erisco's link) about guards and list comprehensions
18:19:59 <geekosaur> (thankfully any of the pay developer programs gets you access to leopard server which you can run in a VM)
18:20:22 <LetterRip> mm_frreak_ thanks
18:20:32 <mm_freak_> LetterRip: well, if you want someone to do your homework, you have to pay them =)
18:21:07 <LetterRip> mm_freak_: don't need someone to solve it for me :)
18:21:14 <LetterRip> that pointer should be enough
18:21:27 <LetterRip> had heard of 'gaurds' before but hadn't encounterd them in the wild
18:21:50 <erisco> I was going to critisise the lyah page for being a bit childish
18:21:53 <mm_freak_> LetterRip: this is a guard:  f x | condition = result
18:21:58 <erisco> then I noticed the sun says "Holy shit!"
18:22:00 <mm_freak_> the 'condition' part is a guard
18:22:05 <darthdeus> and one last noob question before i go to sleep :) anyone got an idea why the [] [] isn't being matched? http://i.imgur.com/eeq9Iay.png
18:22:11 <LetterRip> thanks
18:22:38 <ion> And this is a gourd: http://upload.wikimedia.org/wikipedia/commons/2/28/Gourds_-_grown_in_the_garden.JPG
18:22:42 <darthdeus> since "" == []
18:23:04 <darthdeus> oh wait it doesn't for pattern matching
18:23:05 <erisco> darthdeus, those cases are not exhaustive
18:23:14 <mm_freak_> LetterRip: and list comprehensions are inspired by set comprehension syntax you know from math:  M = { 2*x : x ∈ ℕ }
18:23:15 <geekosaur> stringeq vs stringEq
18:23:23 <mm_freak_> evenNumbers = [ 2*x | x <- [0..] ]
18:23:41 <darthdeus> erisco: how come it's not exhaustive?
18:23:44 <LetterRip> mm_freak_: i do python
18:23:50 <geekosaur> darthdeus: stringeq  vs stringEq
18:23:51 <LetterRip> so know list comprehensions
18:23:51 <derdon> mm_freak_: don't you use the | as well in maths?
18:24:08 <darthdeus> ah
18:24:10 <LetterRip> just the syntax was a bit confusing at first
18:24:17 <erisco> darthdeus, well you have a catch-all at the end, but you are missing length xs != length ys otherwise
18:24:24 <mm_freak_> derdon: sometimes, but i found ':' to be more common in the german textbooks i've read
18:24:26 <darthdeus> geekosaur: this happens to me ALL THE TIME :P
18:24:31 <LetterRip> it is making more sense now.. think i just about understand it enough to translate to python
18:24:33 <geekosaur> erisco, think about it, that's correct behavior
18:24:58 <darthdeus> erisco: well if the length isn't the same then it will go to the bottom catchall no?
18:24:58 <ion> darthdeus: -Wall
18:24:58 <geekosaur> if one is empty and the other isn't, result is False as the fallback case specifies
18:25:07 <mm_freak_> derdon: personally i don't like it, because ':' conflicts with type syntax =)
18:25:15 <derdon> mm_freak_: I am German and I learned it with the pipe symbol. and the book "The Haskell Road to Logic, Math and Programming" uses | as well if I remember correctly
18:25:24 <darthdeus> i need to figure out how to use hlint and -Wall in emacs
18:25:30 <geekosaur> and the other failing case is handled by x == y && ...
18:25:48 <mm_freak_> derdon: i know…  we share two channels =)
18:25:57 <Twey> I was taught with | in the UK
18:26:17 <derdon> mm_freak_: oh, that's funny :)
18:26:23 <LetterRip> one last question what does - Int10007 ? mean - is that expressing that the result will be an integer modulus 10007 ?
18:26:54 <mm_freak_> LetterRip: that we can't infer from the code snippet
18:27:06 <erisco> darthdeus, I agree with that reasoning
18:27:10 <LetterRip> ok so is it just a variable name?
18:27:29 <mm_freak_> LetterRip: Int10007 is a type
18:27:40 <LetterRip> ok
18:27:42 <LetterRip> got it
18:27:54 <LetterRip> thanks think that is enough for me to figure out what to do...
18:28:40 <erisco> darthdeus, geekosaur's find of the typo resolved the issue correct?
18:28:49 <darthdeus> erisco: yes
18:29:10 <mm_freak_> LetterRip: Int10007 might do modular arithmetic implicitly
18:29:24 <mm_freak_> probably modulo 10007
18:29:26 <LetterRip> ok
18:29:38 <mm_freak_> but this is just an educated guess
18:29:42 <ion> or 2^10007 ;-)
18:29:54 <mm_freak_> or 10000
18:30:04 <sqrt2_> suppose i have this function
18:30:07 <sqrt2_> divides :: (Integral a) => [a] -> a -> a
18:30:08 <sqrt2_> divides x y = foldl (||) False (map (\z -> y `mod` z == 0) x)
18:30:27 <sqrt2_> does haskell being lazy mean it only tries as many divisors from x as it needs to?
18:30:35 <tertl31> anyone tried running the hircules irc client?
18:30:39 <mm_freak_> sqrt2_: it doesn't mean anything, because that code is a type error
18:31:11 <erisco> darthdeus, you may also be interested in a definition which makes use of higher-order functions
18:31:16 <sqrt2_> mm_freak_: how so
18:31:34 <mm_freak_> sqrt2_: what's the result type?
18:31:34 <geekosaur> foldl produces a Bool there, not an a
18:31:48 <erisco> darthdeus, typically you want to avoid explicit recursion when practical
18:31:51 <sqrt2_> mm_freak_: oh, yeah, it's meant to be Bool
18:32:09 <sqrt2_> anyway, the question remains the same
18:32:32 <sqrt2_> will it compute the entire fold or only try as long until it hits True
18:33:01 <mm_freak_> sqrt2_: foldl will always compute the entire fold…  you probably want to use foldr here
18:33:07 <mm_freak_> @src all
18:33:07 <lambdabot> all p =  and . map p
18:33:13 <mm_freak_> @src and
18:33:14 <lambdabot> and   =  foldr (&&) True
18:33:38 <sqrt2_> @src or
18:33:38 <lambdabot> or    =  foldr (||) False
18:34:07 <mm_freak_> you can use any/all
18:34:45 <sqrt2_> but it won't be any quicker, will it
18:34:58 <mm_freak_> quicker than your foldl
18:35:03 <sqrt2_> why
18:35:10 <mm_freak_> because foldl always computes the entire fold
18:35:15 <mm_freak_> before giving you a result
18:35:39 <mm_freak_> foldl f z (x:xs) = foldl f (f z x) xs
18:35:46 <sqrt2_> but how does haskell know that True || x is always True
18:35:57 <mm_freak_> because (||) knows
18:36:06 <geekosaur> foldr can be lazy, foldl must be strict. (||) is lazy, so foldr can be lazy
18:36:07 <pavonia> @src (||)
18:36:08 <lambdabot> True  || _ =  True
18:36:08 <lambdabot> False || x =  x
18:36:37 <sqrt2_> i see
18:36:41 <sqrt2_> thanks everyone
18:37:26 <mm_freak_> sqrt2_: foldr (||) False (True:xs) = True || foldr (||) False xs
18:37:28 <roboguy_> foldl doesn't work on infinite lists for that reason
18:37:33 <roboguy_> foldr does though
18:37:39 <mm_freak_> and since True || x = True, you get True immediately without considering x
18:37:53 <ion> As a side note, you almost certainly want to use foldl' instead of foldl whereever foldl would work.
18:38:10 <sqrt2_> @src foldl'
18:38:10 <lambdabot> foldl' f a []     = a
18:38:11 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:39:52 <frege> guys I got a high level question
18:40:01 <frege> I've just started studying haskell
18:40:10 <LetterRip> Ok I have the haskel commented out and an approximate python translation below - is my understanding 'close' to correct? http://pastebin.com/Mpce0asU
18:40:14 <mauke> The paste Mpce0asU has been copied to http://lpaste.net/98715
18:40:26 <frege> from what I understood so far it takes a long time to learn haskell
18:40:35 <frege> is it worth it?
18:41:02 <frege> in practice will it pay off?
18:41:18 <erisco> frege, I remember someone with a similar username asking almost the same questions about a week ago
18:41:52 <LetterRip> presumably depends on your use case
18:41:54 <frege> I didn't
18:42:01 <LetterRip> and what your personal programming weaknesses are
18:42:04 <frege> stream processing
18:42:19 <frege> how do I know what are my personal programming weaknesses are
18:43:02 <LetterRip> do you know any other functional programming languages?
18:43:09 <LetterRip> clojure, etc?
18:43:18 <LetterRip> if not - then picking one up is probably useful
18:43:19 <frege> no this is gonna be my first functional programming
18:43:25 <LetterRip> whether haskell or any other
18:43:26 <jgross> Can someone point me to a reference on how haskell (or functional programming languages in general) are related to category theory?  I'm looking for this primarily as a citation in a paper, so I'd prefer academic papers introducting the idea/proposing it, and not textbooks.
18:43:28 <frege> but I use functional features of python a lot
18:43:41 <mm_freak_> frege: haskell is great for all kinds of stream processing, especially when it comes to high performance
18:44:19 <frege> mm_freak_: yeah that's what attracted me to haskell in the first place, but how long will it take until it pays off?
18:44:53 <erisco> jgross, this is not language specific but perhaps ideal for you http://repository.cmu.edu/cgi/viewcontent.cgi?article=2846&context=compsci
18:44:54 <mm_freak_> frege: mainly depends on you…  do you find yourself thinking more in math or more in procedures?
18:44:55 <ion> frege: It takes a long time to learn *any* language, and there are obviously benefits in learning to think in new ways. (Learning, say, Ruby after learning Python is almost like learning a dialect of the same language, i’m not referring to that.)
18:45:14 * hackagebot purescript 0.3.0 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.0 (PhilFreeman)
18:45:52 <frege> mm_freak_: I can think in both; I've studied mathematical logic, natural deduction, HS and I'm familiar with how to prove things
18:46:58 <mm_freak_> frege: as a haskell beginner you will need days or weeks before you can use the more advanced stream processing abstractions (like pipes)
18:47:26 <mm_freak_> how long will mainly depend on how much time you devote to learning it
18:47:45 <frege> mm_freak_: one problem is that I don't do haskell at work so I don't know how to practice and bring myself up in haskell
18:47:57 <mm_freak_> frege: by doing it at home =)
18:47:58 <jgross> erisco: That looks good, thanks!
18:48:00 <LinearInterpol> I'm still trying to work through typeclasses and monads..
18:48:11 <LinearInterpol> workin' through it! :)
18:48:24 <mm_freak_> frege: also you might be able to sneak haskell into your work by writing a bunch of small command line helpers
18:48:35 <mm_freak_> that's what i did years ago =)
18:49:02 <frege> mm_freak_: good idea
18:49:10 <frege> is haskell very different from erlang?
18:49:17 <mm_freak_> frege: but make sure that it doesn't get you into trouble
18:49:28 <ion> frege: There are major similarities and there are major differences.
18:49:29 <mm_freak_> frege: well, not as different as from python, but still very different
18:49:34 <c_wraith> in practice, haskell and erlang are very different
18:49:58 <mm_freak_> frege: the approach to solving problems will be very different between the two, but they share some basic ideas like purity
18:50:04 <LetterRip> mm_freak_: are haskell ranges start at 1 or 0, and end an n-1 or n?
18:50:15 <mm_freak_> LetterRip: neither
18:50:22 <frege> hah
18:50:22 <frege> interesting
18:50:30 <mm_freak_> LetterRip: [0..] is an infinite list beginning at 0
18:50:49 <LetterRip> mm_freak_: i mean      i <- [1..k]
18:50:56 <LetterRip> is the k inclusive?
18:51:00 <mm_freak_> LetterRip: yes
18:51:03 <LetterRip> ok
18:51:09 <c_wraith> > [maxBound - 1 ..] :: [Int]
18:51:10 <lambdabot>  [9223372036854775806,9223372036854775807]
18:51:14 <ion> > [1.5..10]
18:51:16 <lambdabot>  [1.5,2.5,3.5,4.5,5.5,6.5,7.5,8.5,9.5,10.5]
18:51:25 <LetterRip> thanks
18:51:33 <mm_freak_> LetterRip: btw, feel free to use lambdabot =)
18:51:38 <c_wraith> Not so infinite with Int!
18:51:56 <mm_freak_> > last ([0..] :: Int)
18:51:57 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
18:51:57 <lambdabot>              with actual type `[t0]'Couldn't match expected type `[a0]'
18:51:58 <lambdabot>              with actual type `GHC.Types.Int'
18:52:07 <mm_freak_> > last ([0..] :: [Int])
18:52:11 <lambdabot>  mueval-core: Time limit exceeded
18:52:18 <c_wraith> you're using lambdabot for performance testing again
18:52:26 <mm_freak_> =P
18:52:36 <c_wraith> > last ([maxBound - 20 ..] :: [Int])
18:52:38 <kristof> Finding the last element of an infinite list is not performance testing
18:52:38 <lambdabot>  9223372036854775807
18:52:46 <c_wraith> it's not an infinite list
18:52:47 <mm_freak_> kristof: it's not infinite
18:53:01 <tertl3> paste
18:53:01 <mm_freak_> this one is infinite:
18:53:07 <mm_freak_> > [0..] :: [Integer]
18:53:08 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
18:53:09 <kristof> last ([0..] :: [Int]) is not infinite?
18:53:14 <mm_freak_> kristof: no
18:53:17 <c_wraith> kristof: there is a highest Int
18:53:20 <kristof> because Int is bounded
18:53:25 <mm_freak_> it just takes a lot of time
18:53:51 <kristof> c_wraith: Well, won't GHC error when it tries to construct an Int beyond that?
18:53:57 <c_wraith> nope
18:54:03 <kristof> oh
18:54:06 <mm_freak_> kristof: it won't even try to
18:54:06 <kristof> so that's what the type error was
18:54:07 <c_wraith> The list will end
18:54:11 <c_wraith> no, it's not a type error
18:54:13 <c_wraith> the list ends
18:54:15 <kristof> D:
18:54:19 <kristof> incredible
18:54:28 <c_wraith> > [LT ..]
18:54:29 <lambdabot>  [LT,EQ,GT]
18:54:33 <c_wraith> just like that list ends
18:54:37 <kristof> oh
18:54:38 <c_wraith> there's an upper bound.
18:54:39 <mm_freak_> > last ([0..] :: [Word8])
18:54:39 <kristof> that' magic
18:54:40 <lambdabot>  255
18:54:48 <mgsloan> > maxBound :: Bool
18:54:49 <lambdabot>  True
18:55:06 <pavonia> > (maxBound :: Int) + 1
18:55:07 <lambdabot>  -9223372036854775808
18:55:08 <kristof> > last ([A..] :: Char)
18:55:09 <lambdabot>  <hint>:1:11: parse error on input `]'
18:55:16 <triliyn> > if maxBound then 'a' else 'b'
18:55:17 <lambdabot>  'a'
18:55:21 <ion> > maxBound :: Char
18:55:22 <lambdabot>  '\1114111'
18:55:25 <mm_freak_> > last ['a'..]
18:55:26 <lambdabot>  '\1114111'
18:55:27 <erisco> kristof, well if you look at the Enum instance, you will see it is hardly magic :)
18:55:40 <kristof> erisco: Enumerable types, didn't think about that
18:56:07 <c_wraith> kristof: that's what list range literals are defined in terms of
18:56:19 <c_wraith> [a ..] is defined as enumFrom a
18:56:21 <kristof> In fact it didn't occur to me that Haskell was just enumerating through all the Ints in the system, I thought it was simply incrementing everything
18:56:42 <kristof> Well, that was interesting.
18:56:50 <erisco> wow much interest
18:56:59 <ion> such evaluation
18:57:01 <mm_freak_> kristof: this isn't really haskell…  that behavior is defined in the base library in the Enum instance for Int
18:57:02 <kristof> All this syntactic heroin... :P
18:57:27 <kristof> mm_freak_: I realize that now
18:57:27 <mm_freak_> @src enumFrom Int
18:57:27 <lambdabot> Source not found. It can only be attributed to human error.
18:57:32 <mm_freak_> @src Int enumFrom
18:57:32 <lambdabot> Source not found. Just try something else.
19:01:28 <NemesisD> hey guys. was wondering if you guys could help me reason about a library i'm looking at
19:02:12 <NemesisD> http://hackage.haskell.org/package/Validation-0.2.0/docs/Data-Validation.html I'm first trying to figure out how i'd determine if a validation resulted in success or error if no constructors are exported
19:02:29 <NemesisD> is there something in the typeclass instances that makes it possible?
19:02:35 <jle`> kristof: it's useful when you have a data type with many constructors and you want to get a list of all of them
19:03:20 <jle`> like data Animal = Cat | Dog | Cow | Horse | Chicken | Sheep deriving (Enum, Show)
19:03:25 <jle`> allAnimals = [Cat ..]
19:04:18 <NemesisD> the one time i use a dibblego library and he's mia :P
19:05:03 <ion> allAnimals = [minBound..] if you have Bounded, too.
19:07:10 <frege> I haven't got the answer yet, what will haskell offer me in stream processing compare to python?
19:07:20 <c_wraith> principles
19:07:57 <frege> I can bend python with its functional features to do the job with an ugly syntax
19:08:01 <mgsloan> NemesisD: That sucks that it doesn't export constructors.  You could use "bifodMap" to get the values out, though
19:08:06 <frege> and probably lower performance
19:08:06 <mgsloan> err bifoldMap
19:08:32 <mm_freak_> frege: haskell gives you less code, much better performance and correctness
19:08:33 <frege> beside a nice syntax and better performance what will haskell offer me?
19:08:44 <NemesisD> mgsloan: yeah i went to the docs of bifoldMap and got confused. is there some reading i can do on that?
19:08:49 <mm_freak_> frege: although for small things python may give you less code
19:09:01 <mm_freak_> frege: in either case you get speed and correctness
19:09:15 <NemesisD> frege: i dunno, good syntax, correctness and speed are pretty good. you want it to make you coffee? :P
19:09:20 <frege> mm_freak_: what's correctness?
19:09:36 <hodapp> someone say coffee?
19:09:38 <NemesisD> a higher degree of certainty that your code does not contain errors
19:09:40 <hodapp> I'll have some
19:09:44 * hodapp sniffs around
19:09:49 <erisco> hodapp, damn
19:09:51 <mm_freak_> frege: the compiler understands some of the semantics of your program and tells you:  "hey, what you're doing makes no sense!"
19:09:52 <mgsloan> NemesisD: something like (getFirst . bifoldMap (Last . onFailure) (First . onSuccess))
19:09:56 * hodapp sniffs near erisco
19:10:04 <mm_freak_> frege: before you run it, that is
19:10:54 <mgsloan> NemesisD: The way bifoldMap works is that you give functions that convert "a" to some monoid and "b" to some monoid.  Then, it mappends the results together in some order (specific to the instance)
19:11:18 <NemesisD> well thats... an interesting way to do it
19:11:34 <mgsloan> Yeah, it sucks, maybe he didn't mean to hide the constructors
19:11:43 <mgsloan> In general I'm actually pretty against hiding stuff
19:11:58 <mgsloan> IMHO the PVP should be able to be broken for modules marked "Internal"
19:12:05 <frege> mm_freak_: how does it know the semantic?
19:12:09 <mgsloan> And everything should always get exported
19:12:13 <mm_freak_> frege: from the types
19:12:20 <frege> mm_freak_: like race conditions, etc.?
19:12:34 <NemesisD> mgsloan: i've been poring over the typeclasses in this thing. the functionality i'm trying to implement is something like a -> [a -> AccValidation err ()] -> some errors or () if everything went well
19:13:12 <mm_freak_> frege: example: haskell understands the difference between a raw byte stream and a line-delimited text stream
19:13:15 <NemesisD> mgsloan: this code is an enigma to me. i have no idea why i'm trying so hard to use it. i must make it reveal its mysteries to me
19:13:23 <mm_freak_> frege: mixing them up will result in a type error
19:14:24 <frege> mm_freak_: oh wow so the compiler goes that deep to evaluate types
19:14:46 <mm_freak_> frege: it also understands the difference between a raw text stream and a word-delimited text stream…  it will force you think whether you want to count characters or words
19:15:11 <mm_freak_> frege: it goes very deep
19:15:32 <mm_freak_> frege: http://www.haskell.org/haskellwiki/Why_Haskell_just_works
19:16:07 <mgsloan> NemesisD: Ahah, then oddly enough Bifoldable does allow a nice solution!  Something like (\x -> foldMap (bifoldMap (: []) (\_ -> []) . ($ x)))
19:16:13 <silasm> I really hate that phrase... (that article isn't bad though)
19:16:20 <mgsloan> I dunno why I'm feeling so pointfree today sorry about the symbol soup :P
19:16:41 <silasm> "Just works" usually translates to "is impossible to deal with the moment a problem comes up"
19:18:03 <erisco> mgsloan, \_ -> [] == const []
19:18:12 <mgsloan> I know
19:18:15 <mgsloan> I prever \_ -> []
19:18:18 <mgsloan> prefer
19:18:40 <erisco> I may never know why
19:18:47 <mgsloan> It's the same number of characters
19:19:02 <mgsloan> and can more easily be edited once you do need to use the parameter
19:19:06 <mgsloan> or need to add more parameters
19:19:12 <mgsloan> const $ const $ const ....
19:19:18 <mgsloan> is awful compared to \_ _ _ ->
19:19:33 <mgsloan> And now you know why
19:20:01 <mgsloan> These days I only use const when I'm passing it as a parameter, not when I'm applying it to something
19:20:17 <mgsloan> Possibly if I'm trying to avoid parens
19:20:57 <erisco> hm, well I can buy the case for const . const . const
19:23:04 <silasm> :t const $ const $ const
19:23:06 <lambdabot> b -> b1 -> a -> b2 -> a
19:23:13 <silasm> why would you want that in the first place?
19:23:17 <NemesisD> mgsloan: in this case what is x
19:23:53 <mgsloan> NemesisD: x is the value of type a
19:25:03 <erisco> hm, I suppose pure == const for functions, so you can shave off a character :P
19:25:46 <mgsloan> haha, at the cost of possibly getting a little bit more complicated type errors
19:26:28 <mgsloan> (\_->x) is still more compact than (pure x) tho
19:26:32 <mgsloan> not that I'd write it that way
19:27:08 <mgsloan> And also not that characters should be treated in such a stingy way.  This isn't APL after all!
19:27:58 <NemesisD> mgsloan: give me a second, getting it out of point free and into my little test harness
19:28:01 <erisco> a similar note: I do wish that we could use super and sub scripts
19:28:03 <roboguy_> I've used \_->x in code golf before
19:29:09 <zq> is there an browser based ghci?
19:29:48 <frege> what's the newest formal haskell version?
19:29:49 <frege> 98?
19:30:09 <mgsloan> 2010
19:30:58 <frege> what does GHCI version 7.6.3 support?
19:30:59 <frege> 2010?
19:31:01 <mgsloan> I think maybe some of the report was updated, but mostly I think 2010 documents the ghc extensions that have become rather standard
19:31:11 <mgsloan> 2010 + extensions
19:32:10 <mgsloan> 7.6 is the latest stable release, 7.8 will be coming out soon
19:32:22 <frege> so is A gentle intro to haskell  irrelevant since it was for 98 or does it still overlap on main things in the language?
19:32:31 <frege> I guess the core hasn't changed right?
19:32:36 <mgsloan> Right
19:33:19 <geekosaur> the gentle intro isn't really all that gentle, though
19:33:28 <geekosaur> well, it was for its time
19:33:28 <NemesisD> mgsloan: ok this is driving me crazy. i am pretty sure i'm getting gaslighted by ghc packages
19:33:55 <frege> geekosaur: I found it more gentle than LYAH
19:34:46 <mgsloan> NemesisD: Yikes! Feel free to paste errors to lpaste or whatnot
19:34:57 <NemesisD> mgsloan: http://lpaste.net/98716
19:35:40 <mgsloan> Well that's strange
19:35:44 <NemesisD> its really weird, the docs say that AccValidation is an instance of bifoldable, ghc thinks not. i was having the same issue with semigroup yesterday. i feel like its a mismatched dependency or something
19:35:52 <NemesisD> like there's 2 bifunctors packages
19:36:03 <NemesisD> but im using a sandbox, all i did was install Validations
19:36:49 <geekosaur> there are some cases of transitive dependencies where different package version dependencies can lead to that
19:36:59 <geekosaur> (someone managed to trigger it in xmonad-contrib once...)
19:37:01 <byorgey> NemesisD: be sure to look carefully at what packages your sandbox was populated with on init
19:37:20 <byorgey> in particular, it will be populated with everything in your global package DB
19:38:01 <byorgey> yeah, someone just ran into something similar with diagrams the other day
19:38:59 <mgsloan> I'm getting the same error here
19:39:02 <mgsloan> wierd!
19:39:25 <mgsloan> Often when it's a transitive dependency thing, you'll get package qualified identifiers in the error
19:39:52 <byorgey> yeah, but that wasn't the case with this diagrams problem the other day, which surprised me
19:40:03 <NemesisD> wat do?
19:40:23 <mgsloan> Yeah, the package qualified identifier is probably just when it's an error of the form "Expected / Actual"
19:40:28 <byorgey> it wasn't a transitive dependency thing, it was having an older version of a package in the global DB that exported the same class as a newer package that got installed in the sandbox
19:40:38 <byorgey> mgsloan: yes, good point
19:40:49 <NemesisD> does the package updater need to change something?
19:41:18 <mgsloan> Huh, I didn't realize cabal sandboxes worked that way.  It's kinda nice, kinda nasty
19:41:19 <NemesisD> do i need to nuke my user package dir?
19:41:28 <mgsloan> kinda defeats the purpose of sandboxes, while making them more efficient
19:41:40 <mgsloan> Oh, global DB, not user DB?  That's actually nice
19:41:41 <NemesisD> offer the blood sacrifice unto cabal
19:42:09 <geekosaur> mgsloan, what I've found is you get that if ghc is aware of the packages. if the transitive dependency is such that all it knows about is a (global) instance, it can omiit package information
19:42:37 <geekosaur> I do not at this point remember the exact circumstances in the case we ran into...
19:43:03 <geekosaur> oh, hm, I am vaguely recalling it was a package which had imported an instance from a since-removed version of a package
19:43:21 <geekosaur> then later built with a reinstalled-but-different version of that package
19:43:44 <geekosaur> since the original had been removed and all that had originally been imported was global instances, it had no version information to report
19:46:25 <NemesisD> buhhh
19:47:03 <mgsloan> geekosaur: Wow, that's pretty freaky!  Thankfully I don't think that's going on here
19:47:07 <roboguy_> great. there is a huge debate about capitalization rules in Haskell/OCaml/etc in that language design channel. so pointless...
19:47:27 <mgsloan> Unfortunately I'm not sure what's going on here, I'm getting the same issue NemesisD
19:47:52 <mgsloan> If I run ghci on the cabal unpacked Validation package, I see the instance
19:48:15 <mgsloan> but ghci importing Data.Validation does not see the instance, even though Data.Bifoldable is imported
19:48:30 <kristof> You all are lucky you're not using Common Lisp. The reader converts everything to uppercase, so when it prints stuff back to you in the REPL you feel like you're being shouted at.
19:48:34 <NemesisD> all of em? i was having the issue yesterday of it showing Monoid and such but not the kmettian stuff like Semigroup and Bifoldable
19:49:01 <mgsloan> Yeah, it's not showing me any of the kmettian instances
19:49:43 <NemesisD> hmm, maybe i should slowly back away from this
19:49:49 <mgsloan> lol
19:50:33 <NemesisD> i guess at least i learned about semigroups and bifoldable
19:51:01 <NemesisD> seems like bifoldable is for flattening types with 2 type parameters like eithers and tuples into a homogeneous value
19:51:43 <mgsloan> Yup!
19:52:30 <mgsloan> So I'm pretty sure the issue here is that Validation is using == constraints for bifunctors and semigroups
19:52:33 <colDrMcBeardman> is the darcs-patch-watch lambdabot plugin gone forever?
19:52:41 <mgsloan> which is plain irresponsible and bound to reak havoc
19:52:56 <mgsloan> I wouldn't expect this level of havoc, though
19:53:11 <NemesisD> mgsloan: should be using >= you're saying?
19:53:27 <mgsloan> Yeah
19:53:54 <mgsloan> possibly with upper bounds, though I think the jury is out on when to use them
19:54:34 <NemesisD> imo i think use upper bounds if you plan on maintianing your project
19:55:07 <NemesisD> i'd rather get an issue with someone vouching that it works to raise the upper bound than just to have my package break
19:55:14 <mgsloan> Problem is that means that the cost of a major version bump of a dep is linear in the number of downstream dependents
19:55:22 <NemesisD> i usually upper bound on major version
19:55:39 <NemesisD> should be shouldn't it? major versions changes are supposed to be breaking after 1.0
19:55:40 <mgsloan> The way I figure it is that the PVP is too damn strict for a language that's good at checking your work
19:55:57 <NemesisD> pvp?
19:56:20 <mgsloan> package versioning policy - http://www.haskell.org/haskellwiki/Package_versioning_policy
19:56:43 <mgsloan> I mean, the PVP itself is fine, but the "next largest major version" for upper bounds just sucks
19:57:12 <mgsloan> It is very responsible
19:57:43 <NemesisD> im sure i'd feel different if my day job depended on me being productive in haskell
19:58:08 <augur> favonia: why "favonia"?
19:58:33 <mgsloan> If cabal was a bit friendlier I might feel different about upper bounds
19:58:48 <mgsloan> but they tend to mean that you end up using old code
19:59:20 <frege> @srs length
19:59:20 <lambdabot> Source not found. Wrong!  You cheating scum!
19:59:25 <frege> why not?
19:59:32 <frege> length (x:xs)           =  1 + length xs
19:59:37 <simpson> @src length
19:59:37 <lambdabot> Source not found. You untyped fool!
19:59:41 <simpson> Huh.
19:59:44 <simpson> @src genericLength
19:59:44 <lambdabot> genericLength []    = 0
19:59:44 <lambdabot> genericLength (_:l) = 1 + genericLength l
19:59:45 <roboguy_> I guess it's not in the file lambdabot uses for that
19:59:49 <roboguy_> that's weird...
19:59:56 <frege> is it basically a loop over the list and counting each element?
20:00:03 <simpson> ^^^
20:00:38 <frege> a recursion that just increments a value until it reaches to the end of that list?
20:01:13 <NemesisD> frege: you got it
20:01:57 <augur> actually frege's description is of a foldl-based length
20:02:14 <augur> genericLength doesnt increment a value, it builds a big stack of additions
20:03:25 <kristof> Under what circumstances do people find themselves using applicatives?
20:03:33 <favonia> augur: hmm... I don't have an explanation in Haskell :p
20:03:46 <kristof> And specifically applying functions to values with <*>
20:03:48 <augur> favonia: well if you were in blah i'd ask you there!
20:03:52 <jle`> kristof: when all you are doing is sort of...accumulating monadic stuff.
20:03:55 <jle`> hm
20:04:07 <jle`> a big clue is if your entire monad block
20:04:07 <augur> or non-monadic stuff!
20:04:14 <jle`> is just a list of binds
20:04:16 <jle`> and a return at the end
20:04:20 <kristof> oh, does [f1, f2] <*> [val1, val2] do what I think it does?
20:04:22 <jle`> oh yeah...non monadic stuff too :)
20:04:46 <augur> kristof: depends on what you think it does! :)
20:05:02 <jle`> > [(*2), (+2)] <*> [2,3]
20:05:03 <lambdabot>  [4,6,4,5]
20:05:16 <kristof> Ok, I didn't know it threw everything into a new list
20:05:23 <augur> also:
20:05:28 <kristof> Well, I thought it would return a list of two lists
20:05:41 <augur> > ZipList [(*2), (+2)] <*> ZipList [2,3]
20:05:42 <lambdabot>  No instance for (GHC.Show.Show (Control.Applicative.ZipList b0))
20:05:42 <lambdabot>    arising from a use of `M65736926902849141163968.show_M65736926902849141163...
20:05:42 <lambdabot>  Possible fix:
20:05:42 <lambdabot>    add an instance declaration for
20:05:42 <lambdabot>    (GHC.Show.Show (Control.Applicative.ZipList b0))No instance for (GHC.Num.N...
20:05:44 <jle`> here is a common example
20:05:47 <augur> :|
20:05:48 <augur> horrible
20:05:58 <roboguy_> > getZipList $ ZipList [(*2), (+2)] <*> ZipList [2,3]
20:05:59 <lambdabot>  [4,5]
20:06:14 <kristof> Bah, magic
20:06:17 <jle`> if you have something like do { a <- f; b <- g; return (h a b)}
20:06:21 <augur> kristof: nah, not bagix
20:06:23 <augur> .. magic
20:06:24 <jle`> do you see this is kind of a silly-ish monad
20:06:24 <augur> hahaha
20:06:29 <jle`> because there is no logic happening
20:06:33 <jle`> there is no branching
20:06:45 <jle`> monads give you the power of branching...if you have no logic, you only need an applicative
20:06:46 <augur> kristof: the applicative for lists is sort of just cartesian products
20:06:53 <augur> but instead of producting you apply
20:06:55 <jle`> the above do block is the same as h <$> f <*> g
20:07:19 <augur> fs <*> xs = [ f x | f <- fs, x <- xs ]
20:07:21 <dwcook> jle`, could you clarify what you mean by branching?
20:07:44 <kristof> dwcook: Arbitrary control structures
20:07:57 <kristof> I believe Haskell has a continuation monad?
20:08:07 <jle`> dwcook: you decide what to do next based on what you have already bound
20:08:13 <roboguy_> kristof: there's a library that does
20:08:15 <jle`> what to return next
20:08:18 <jle`> choices stuff
20:08:22 <jle`> not sure if that is a good description
20:08:23 <kristof> roboguy_: Ah yes right
20:09:04 <dwcook> Basically, the next action depends on the value of a previous action
20:09:08 <jle`> commonly you have something like do { x <- readLn; y <- readLn; return (x + y) }
20:09:17 <jle`> the "fate" of the block is...pre-determined
20:09:22 <jle`> ther eis no logic happening
20:09:31 <jle`> so you can do (+) <$> readLn <*> readLn
20:10:24 <jle`> this is useful because things like this can be pretty optimized
20:10:31 <jle`> in lots of cases
20:10:51 <jle`> the applicative form is a lot easier to see that there is no funky logic branching stuff
20:10:57 <jle`> the do block...it's less obvious in general
20:11:05 <jle`> so applicative forms tend to be easier to optimize
20:13:06 <jle`> dwcook: ah that's probably a better way to say it
20:13:48 <dwcook> Yeah, I didn't get what you meant at first, but it became clearer to me upon examining the types
20:14:18 <dwcook> @type (<*>)
20:14:19 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
20:14:20 <dwcook> @type (>>=)
20:14:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:16:21 <jle`> yeah you can't "choose" the action you compose next on what you already did
20:18:35 <ion> “Some Functor/Applicative/Monad function type signatures contrasted” https://gist.github.com/ion1/8384983
20:20:33 <dwcook> ion, that's a nice illustration, although I feel that for clarity the return types should be aligned.
20:20:45 <dwcook> (on lines 5 and 6
20:20:46 <dwcook> )
20:21:20 <dwcook> Ah, I see it once was like that.
20:22:08 <ij> Is fmap a lift?
20:22:49 <ion> dwcook: I guess you’re right, updated.
20:23:31 <frege> is it easy to read from a file and print it on the screen line by line?
20:23:31 <dwcook> ij, you can think of it as a way to turn a function into a function that works on functorial values
20:23:50 <dwcook> ij, fmap :: (Functor f) => (a -> b) -> (f a -> f b)
20:24:06 <dwcook> I added parens that are usually redundant but might help you see it more easily
20:24:06 <ion> frege: readFile "foo" >>= putStr
20:24:33 <frege> ion: foo is the path?
20:24:44 <ion> @type readFile
20:24:45 <lambdabot> FilePath -> IO String
20:25:06 <frege> what does >>= do?
20:25:22 * hackagebot gnuidn 0.2.1 - Bindings for GNU IDN  http://hackage.haskell.org/package/gnuidn-0.2.1 (JohnMillikin)
20:25:24 <ion> frege: That expression is the same as: do { contents <- readFile; putStr contents }
20:25:30 <dwcook> frege, loosely speaking, let you determine the next action to take based on the outcome of a previous one
20:25:33 <ij> dwcook, Hmm, that does make a bit more sense.
20:25:43 <ion> frege: I mean, readFile "foo"
20:25:45 <ij> Although is the same.
20:26:15 <frege> shit how do I work with the string I'm reading from that file then?
20:26:24 <frege> how can I pass it to other functions?
20:26:30 <ion> frege: putStr (myFunction contents)
20:26:50 <jle`> frege: so remember that IO a's are basically data structures that *represent* actions
20:26:53 <ion> frege: Or: contents <- fmap myFunction (readFile "foo")
20:27:14 <ion> frege: Or: contents <- myFunction <$> readFile "foo"  -- <$> is infix fmap.
20:27:25 <jle`> if it helps you can think of it as representing/containing little chunks of assembly/c code
20:27:44 <jle`> putStrLn "Hello" represents a command that puts the string "hello" to stdin
20:27:48 <frege> ok
20:27:53 <jle`> but we want to build...bigger programs
20:27:54 <frege> ahhh
20:28:02 <jle`> we want to connect command objects
20:28:09 <jle`> sequence them to make cool programs
20:28:14 <jle`> we can't do much with a program that just puts a string
20:28:19 <frege> right
20:28:27 <jle`> so IO a has an operator >>
20:28:33 <jle`> that takes an IO a on both sides
20:28:36 <jle`> and returns a new IO object
20:28:41 <jle`> that "does both" in sequence
20:28:48 <dwcook> And now you can print *two* strings! \o/
20:28:50 <jle`> so putStrLn "hello" >> putStrLn "world"
20:28:56 <jle`> takes the two IO objects on both sides
20:28:59 <jle`> and returns a new IO object
20:29:04 <augur> > putStrLn "hello" >> putStrLn "world"
20:29:05 <jle`> that represents the idea of printing two strings
20:29:05 <lambdabot>  <IO ()>
20:29:20 <jle`> some people liken >> to semicolons
20:29:23 <augur> damn you lambdabot
20:29:31 <jle`> okay...so >> is kinda useful
20:29:35 <jle`> and we can kinda build useful things maybe
20:29:36 <augur> jle`: well, for good reason:   x >> y   =   do x ; y
20:29:37 <augur> :)
20:29:41 <dwcook> augur, if you were lambdabot, you probably wouldn't want people executing arbitrary IO on you either
20:29:54 <jle`> but you know, lots of commands "return" things
20:29:56 <dwcook> I know I hate it when that happens
20:29:58 <jle`> like the command getLine
20:29:59 <ion> There are plenty of bots that execute arbitrary IO.
20:30:02 <jle`> is a command that returns a string
20:30:04 <ion> On purpose, too!
20:30:10 * augur executes arbitrary IO on dwcook
20:30:11 <frege> I didn't really get the part you said it makes one IO object from two?
20:30:17 * dwcook launches the missiles.
20:30:21 <augur> \o/
20:30:39 <dwcook> Good thing that only happened in IOT with a Maybe at the bottom.
20:30:41 <jle`> frege: so putStrLn "Hello" can be thought of as a chunk of assembly code that prints out the string hello
20:30:41 <dwcook> ;)
20:30:43 <augur> frege: think of IO like a command, and >> for IO just means do the first command, then do the second
20:30:51 <jle`> putStrLn "World" can be thought of as a chunk of assembly code that prints out the string world
20:30:53 <ion> frege: It takes an IO thing that prints "hello" and another that prints "world" and returns a new one that prints "hello" and "world" if you execute it.
20:31:05 <jle`> (putStrLn "Hello" >> putStrLn "World")
20:31:10 <jle`> is a new IO object
20:31:16 <jle`> a  new chunk of assembly/C--/whatever
20:31:20 <frege> gotcha
20:31:29 <jle`> so >> is useful but it's not too useful
20:31:36 <jle`> for example we have the IO object getLine
20:31:43 <jle`> which is a command that gets a line from stdin
20:32:01 <jle`> if we want to getLine and then print it (echo)...>> isn't powerful enough
20:32:08 <frege> I wanna write a little script that reads a csv file and parses each csv row and increments the values by a number
20:32:08 <jle`> getLine >> putStrLn "what?"
20:32:20 <jle`> >>= is an "upgrated" version of >>
20:32:25 <frege> do you think it's difficult as the first haskell program that I'm going to write?
20:32:30 <dwcook> getLine >> putStrLn "Speak up, my hearing's not what it used to be."
20:32:54 <jle`> >>= lets you glue two IO objects together, but lets you "name" the result of the left ahnd side for use in the right ahnd side
20:33:02 <jle`> getLine >>= \x -> putStrLn x
20:33:07 <dwcook> getLine >>= \_ -> putStrLn "No need to shout!"
20:33:08 <jle`> with >> we had to ignore the result
20:33:19 <jle`> with >>= we get to name the result and use it in the right hand side
20:33:25 <augur> well technically >> is a downgraded version of >>= :P
20:33:39 <jle`> haha. yeah
20:33:44 <augur> x >> y = x >>= \_ -> y
20:33:55 <augur> thats why you can use getLine with >>
20:34:19 <augur> because >> is just notation for >>= in the case where you ignore the result of the first computation
20:34:28 <ion> frege: You might benefit from parsing and generating CSV data with http://hackage.haskell.org/package/cassava – although when you have that working, you may want to replace it with your own parser for learning purposes.
20:34:49 <jle`> so in Haskell, if you make a "program"...you basically compose/combine/merge smaller IO objects that Prelude gives you
20:34:51 <jle`> into a big one
20:35:14 <dwcook> Yeah, my hard-of-hearing person metaphor falls apart because I was pretending foo >>= \_ -> bar was so different from foo >> bar :P
20:35:30 <dwcook> Oh good, I have a metaphor I can use to write a monad tutorial
20:35:46 <jle`> don't use the M word!
20:35:48 <jle`> :)
20:35:57 <dwcook> jle`, the M word, you mean "monadtutorial"?
20:36:36 <jle`> :P
20:37:10 <jle`> i think one of the bigger conceptual things for me in sequencing IO
20:37:14 <jle`> is that >> is just like a glue
20:37:26 <jle`> maybe you can write it as putStrLn "hello" ++ putStrLn "world"
20:37:29 <jle`> er
20:37:32 <jle`> let (++) = (>>)
20:37:34 <jle`> :)
20:38:34 <jle`> let (++) = (>>) in putStrLn "hello" ++ putStrLn "world"
20:38:35 <dwcook> That's worse than naming a function parameter (*)
20:38:41 <jle`> naaaaahh
20:38:48 <jle`> considered harmless.
20:38:49 <silasm> I thought of >> as && and >>= as | from bash. Except without the explicit sequencing. Also && is more like >>= for Maybe.
20:38:53 <silasm> soo...
20:39:01 <jle`> oh yeah
20:39:10 <jle`> that's pretty neat
20:39:13 <prooftechnique> Any hakyll wizards around?
20:39:30 <jle`> let (&&) = (>>) in putStrLn "hello" && putStrLn "world"
20:39:33 <jle`> idk though
20:39:39 <jle`> hm
20:39:50 <ion> instance (Monad m, Monoid a) => Monoid (m a) where { mempty = return mempty; mappend = (>>) }
20:40:06 <jle`> nah
20:40:11 <silasm> I always have weird moments when writing bash aliases or piping functions where I decide to use a lambda and realize I can't.
20:40:15 <jle`> can't you just do mempty = return () ?
20:40:25 <ion> for instance Monoid (m ())
20:41:43 <jle`> oh yeah.
20:41:53 <jle`> darn kinds.
20:42:11 <jle`> mconcat [putStrLn "hello", putStrLn "world"]
20:42:19 <silasm> I was raving in my sleep-deprived mind this morning about how awesome () is.
20:42:32 <silasm> It can be almost anything you want it to be, except anything interesting.
20:42:44 <ion> Void is even more awesome.
20:43:29 <guesting> What does "*** Exception (reporting due to +RTS -xc): (THUNK_1_0), stack trace:" mean when I profile with -xc?
20:43:50 <silasm> stack trace?
20:43:55 <silasm> in *my* haskell?
20:43:57 <silasm> where?
20:44:21 <guesting> I am profiling with +RTS -xc
20:44:39 <guesting> In order to find where a stack overflow is ocurring
20:50:21 <pavonia> guesting: "this is a common symptom of insufficient strictness of an accumulator"
20:50:52 <guesting> pavonia: Perfect!! I guess the following functions are where it's occurring...
20:51:18 <guesting> except there is no accumulator
20:51:19 <guesting> uh
20:51:27 <guesting> it's a do block
20:51:38 <pavonia> Well, no idea what's goin on, just quoting http://ircbrowse.net/browse/haskell/?id=14272495&timestamp=1348791780#t1348791780 :p
20:51:49 <guesting> with unsafePerform IO, runCommand, and waitForProcess
20:51:51 <guesting> hmm
20:51:55 <guesting> oh and readFile
20:52:08 <guesting> I don't think those have an accumulator
20:53:06 <jle`> anyone familiar with netwire?
20:53:25 <jle`> i want to make a wire that sort of has a square pulse whenever its income matches a predicate
20:53:46 <jle`> for a predetermined amount of time...or maybe even an amount of time determined by the income
20:54:18 <jle`> so it is normally zero....but is maybe one for two seconds after the incoming signal begins to match a predicate
20:54:27 <pavonia> guesting: As far as I understand the log, the argument to one of these functions seems to be too big to fit on the (RTS?) stack
20:55:04 <guesting> pavonia: Oh, so it isn't because that's where the stack overflow is, it's because of RTS? Darn.
20:55:42 <pavonia> Do you get a stack overflow in your program too?
20:55:48 <guesting> Yeah
20:55:53 <guesting> and I can't find the source
20:56:32 <pavonia> Is it too big to paste?
20:56:48 <guesting> pavonia: Is what too big to paste?
20:57:06 <pavonia> the code of your program
20:57:22 <guesting> What part, the part that is overflowing?
20:57:26 <guesting> in RTS
20:57:27 <kristof> jle`: I don't know how to do what you're asking but perhaps someone out there has written about signal processing in Haskell?
20:57:30 <guesting> not in reality
20:58:10 <jle`> kristof: heh this is an implementation thing specific to netwire i think
20:58:16 <jle`> the library
20:58:39 <pavonia> guesting: No, I mean the code of the program that is causing the stack to overflow. You could paste that if it isn't too long
20:59:25 <guesting> pavonia: I don't know what is causing the stack to overflow, that's what I'm trying to find out haha. The entire code of the program is much too large to paste, and I can't anyway as it's confidential at the moment.
21:00:21 <pavonia> Aha, okay
21:01:06 <guesting> pavonia: So the exception is not telling me anything other than I am reading a big file and writing a big file? Drat.
21:04:14 <pavonia> guesting: To me it seems RTS is just confirming that you have stack overflow problem somewhere in your code :p
21:04:50 <guesting> pavonia: I mean, it gives me the function, but the function just writes and reads a big file, so...
21:05:45 <pavonia> maybe that thunk representing the file contents is too big
21:06:30 <guesting> pavonia: For RTS or for both with and without?
21:07:05 <pavonia> for both
21:07:07 <guesting> pavonia: How can I solve it?
21:07:18 <zq> is there an IntSet for Integer?
21:07:21 <guesting> pavonia: Use a bang pattern on the call to the function?
21:07:42 <pavonia> difficult to say without seeing the code
21:08:14 <kristof> binding a monadic value to a function can also be represented as (f (extract val)), right?
21:08:54 <pavonia> zq: Set Integer?
21:09:46 <guesting> pavonia: So the function calling the problem function is "f m = map (\x -> read x :: Double) . words . last . lines . problemFunction $ m"
21:10:25 <pavonia> What does problemFunction?
21:10:28 <eazar001> @fortune
21:10:28 <lambdabot> No man is an island if he's on at least one mailing list.
21:10:29 <guesting> the problem function takes in m, makes it a string, does an unsafe io to it to write to a file, executes a command, reads a file, then returns that file as a string.
21:10:43 <ij> why not (read :: Double)
21:11:44 <jle`> kristof: what do you mean?
21:12:12 <guesting> pavonia: problemFunction m = unsafePerformIO $ do \n writeFile "file" string \n hCommand <- runCommand "command" \n waitForProcess hCommand \n result <- readFile "result_file" \n return result
21:12:53 <guesting> pavonia: string is the transformation of m to a string, but those functions aren't the issue according to the exception error.
21:12:56 <kristof> jle`: I'm confusing comonads with monads. I made the assumption that there's an "extract" function defined for every monad, but that's not the case.
21:13:26 <pavonia> guesting: How big is that file?
21:13:42 <guesting> huge
21:13:48 <guesting> it's writing a sparse matrix
21:14:03 <guesting> millions of values
21:14:16 <guesting> or hundreds of thousands, depending
21:14:37 <pavonia> I guess the problem is that this file isn't read lazily due to the unsafe thing
21:15:01 <guesting> Interesting...so is there a solution?
21:15:08 <pavonia> Why are you using unsafePerformIO, btw?
21:15:22 <guesting> I have been putting of doing ffi for a while
21:15:32 <guesting> so haskell has terrible sparse matrix support
21:15:35 <guesting> and i need it
21:15:38 <guesting> and sparse svd
21:15:43 <enthropyenthropy> pavonia: why do you say the result gets forced?
21:16:12 <guesting> so I use sparse-lin-alg for the matrices, then write the sparse matrix to a file for use with svdlibc, which spits out a result which i read back in
21:16:20 <guesting> it's horrible, but I'm scared of ffi
21:16:31 <verement> ffi isn't so bad
21:16:35 <pavonia> enthropy: Is has to if it's printed, no?
21:16:36 <guesting> and I'm holding out until a good matrix library comes along
21:16:38 <enthropy> if anything, unsafePerformIO (some strict IO) will be lazy
21:17:00 <guesting> verement: It is when you barely know C
21:17:18 <guesting> enthropy: unsafePerformIO is lazy? So that isn't the issue?
21:18:24 <pavonia> guesting: Well, the question still remains, why unsafe IO and not normal IO?
21:18:52 <guesting> pavonia because then I need to have IO calls all the way back up all through the functions, right?
21:18:54 <enthropy> guesting: (x <- readFile "result_file") will actually get the contents of that file as you try to evaluate them
21:19:04 <enthropy> not when you get to the next IO action
21:19:45 <guesting> enthropy: So that isn't an issue, it would be the writing, yes?
21:19:53 <enthropy> dunno what it has to do with your situation though
21:20:00 <c_wraith> guesting: you mean when you do file IO, you don't want it to count as doing IO?  How very odd.
21:20:09 <pavonia> guesting: you need it in that function and in main, all other function can still be pure
21:20:39 <guesting> pavonia: But that function is nested within many others within a binary recursion call to make a binary tree
21:20:47 <guesting> it's messy but the math forces it
21:20:59 <guesting> except---
21:21:19 <c_wraith> guesting: haskell works better when you don't lie to the type system.
21:22:01 <haasn> now if only haskell's type system wasn't so weak
21:22:15 <enthropy> these lessons have very little to do with solving the stack overflow I think
21:23:05 <guesting> c_wraith: Yes, but every single function would then have to be a monad which would be a catastraphe
21:24:02 <enthropy> that (runCommand "command") is supposedly implementing a pure function?
21:24:25 <guesting> enthropy: No, it's calling svdlibc on the command line on the file I wrote.
21:24:59 <pavonia> enthropy: "if anything, unsafePerformIO (some strict IO) will be lazy" <-- What if you have a lazy inner IO, will that still be lazy?
21:25:00 <enthropy> I mean morally you get the same svd decomposition for the same input matrix?
21:25:42 <guesting> entropy: Yes, you should get the same
21:26:13 <haasn> the laziness (or not) of unsafePerformIO is irrelevant because usage conventions dictate that unsafePerformIO only be used on calculations whose effects don't depend on the time or order of execution
21:27:14 <silasm> I have two modules which import eachother. Is there a way I can make that work, or do I have to combine them?
21:27:30 <haasn> silasm: Haskell technically allows it but GHC's implementation requires some muddling about
21:27:40 <guesting> Is this function a red herring? Is the stack overflow happening elsewhere? (I have no folds that aren't strict, no sums, I even changed union to sets to be strict)
21:27:43 <haasn> the short answer would be yes, move them into the same module
21:28:07 <enthropy> guesting: you could replace it with a dummy?
21:28:12 <silasm> haasn: :/
21:28:19 <silasm> ah well it's not a huge deal.
21:28:49 <guesting> enthropy: I can try, but the code takes 4 hours to run so it will be a while before I can have results haha
21:28:52 <haasn> silasm: http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/separate-compilation.html#mutual-recursion
21:28:53 <pavonia> silasm: or create a third one which both others import the common things from
21:35:09 <guesting> enthropy: Dummy is in place. I'll test it and see what happens! Be back in a few days I guess :P
21:38:14 <inerkick> mm
21:38:58 <guesting> enthropy: That solved the exception! But now lets see if it solves the stack overflow in the end (4 hour run, here we go)
21:43:02 <lovewithacaveat> is there a good pure mathematics freenode irc channel?
21:43:47 <haasn> Have you tried ##math?
21:43:56 <eazar001> lovewithacaveat: unfortunately #math is for homework problems a lot of the time
21:43:59 <haasn> No comment on “good”
21:44:16 <eazar001> lovewithacaveat: however they claim that they are open to "discussions"
21:44:22 <eazar001> so you're free to try that
21:44:26 <lovewithacaveat> eazar001: yeah, no, i don't want to go there
21:44:34 <lovewithacaveat> eazar001: i already know about it
21:45:04 <eazar001> lovewithacaveat: if you do find one, please PM me your discovery [=
21:45:36 <lovewithacaveat> eazar001: sure will :), i think i am just going to head on over to the math stack exchange though, and ask my question there
21:45:57 <eazar001> yea, that works too, math.stackexchange is a great resource
22:21:51 <chrizz_> hi all, what's the lambdabot command to show the true type of a monad transformer stack?
22:22:15 <chrizz_> e.g. MaybeT IO a ~ IO (Maybe a)
22:22:56 <chrizz_> @help
22:22:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:23:00 <chrizz_> list
22:23:03 <triliyn> I think that's @unmtl
22:23:11 <chrizz_> @unmtl MaybeT IO a
22:23:11 <lambdabot> IO (Maybe a)
22:23:17 <chrizz_> thanks
22:23:47 <chrizz_> @unmtl EitherT String (StateT Int IO) a
22:23:48 <lambdabot> EitherT String (StateT Int IO) a
22:24:05 <chrizz_> @unmtl StateT Int (EitherT String IO) a
22:24:05 <lambdabot> Int -> (EitherT String IO) (a, Int)
22:24:51 <triliyn> hmmm, I guess it doesn't do recursive unwrapping
22:25:04 <chrizz_> this output is confusing me, lol
22:25:09 <triliyn> oh wait, maybe it just doesn't know about EitherT
22:25:17 <chrizz_> ah
22:25:22 <triliyn> @unmtl ErrorT String (StateT Int IO) a
22:25:22 <lambdabot> (StateT Int IO) (Either String a)
22:25:27 <chrizz_> @unmtl ErrorT String (StateT Int IO) a
22:25:27 <lambdabot> (StateT Int IO) (Either String a)
22:25:42 <triliyn> Yeah, it looks like it doesn't know EitherT AND it only unwraps one level
22:25:47 <chrizz_> gotcha
22:26:09 <chrizz_> I'm just trying to build in the possibility of failure to a state monad
22:26:12 <triliyn> (But you can pass in the inner levels manually if you need to, I guess)
22:26:31 <chrizz_> trying to decide on which way to order the Either and State
22:26:43 <jle`> is there an eqBy function
22:26:56 <jle`> Eq b => (a -> b) -> b -> b -> Bool
22:27:00 <chrizz_> hoogle it
22:27:06 <jle`> i did but nothing came up...maybe i have things wrong
22:27:09 <jle`> :/
22:27:20 <chrizz_> that type signature doesn't make much sense, what does the first argument do?
22:27:41 <jle`> eqBy p a a = comparing p a a == EQ
22:27:47 <chrizz_> nvm, you probably mean (a -> b) -> a -> a -> Bool
22:27:56 <triliyn> If it's supposed to be b -> a for that first function, there's \f -> (==) `on` f
22:27:57 <jle`> chrizz_: ah yes you're right
22:28:14 <jle`> it's eqBy = (== EQ) . comparing
22:28:28 <triliyn> (which I guess is just on (==))
22:28:28 <jle`> hm that doesn't work
22:28:36 <jle`> :t on
22:28:38 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
22:28:42 <chrizz_> :t on (==)
22:28:43 <lambdabot> Eq b => (a -> b) -> a -> a -> Bool
22:28:47 <jle`> ah
22:28:48 <chrizz_> there ya go
22:28:50 <jle`> ty
22:29:25 <chrizz_> @unmtl ErrorT String (State Int a)
22:29:26 <lambdabot> Plugin `unmtl' failed with: `ErrorT String (State Int a)' is not applied to enough arguments, giving `/\A. (State Int a) (Either String A)'
22:29:33 <chrizz_> @unmtl ErrorT String (State Int) a
22:29:33 <lambdabot> (State Int) (Either String a)
22:30:03 <chrizz_> @unmtl StateT Int (Either String) a
22:30:03 <lambdabot> Int -> (Either String) (a, Int)
22:31:06 <triliyn> chrizz_: if you're going to be doing a lot of that, you might want to move it into a PM
22:31:19 <chrizz_> sorry, but I'm done
22:31:31 <chrizz_> will next time
22:31:39 <triliyn> Okay
22:31:56 <jle`> can i have guards on cases?
22:32:01 <jle`> ...probably could just test this.
22:32:11 <chrizz_> ya
22:34:27 <chrizz_> how do you specify a package to import a module from, if multiple packages export the same module?
22:35:36 <chrizz_> got it -- import "either" Control.Monad.Trans.Either
22:56:35 <jle`> whenever i don't know how to do something with netwire i just write the wires manually >.>
22:56:52 <jle`> in the hopes that one day in the future i will know enough to rewrite them as compositions of simpler wires
22:56:59 <jle`> i guess that's ok
22:57:23 <jle`> i see manual wires a lot in ocharles's examples so i guess that's fine right?
22:59:21 <lightquake> is there a library for parsing an e-mail?
22:59:35 <lightquake> the message itself, not the address
22:59:47 <beardtree> lightquake: what language?
23:00:13 <jle`> lightquake: do you mean the headers...?
23:00:59 <lightquake> not just the headers, ideally something that does all the message body nesting in a nice way too. i'm looking for the haskell analogue of python's email.parser
23:08:41 <b80905> is there a more convenient way to check if a character c is a digit besides c=='0'||c=='1'||...||c=='9'?
23:08:59 <enthropy> b80905: there is a Data.Char.isDigit
23:09:32 <Kaidelong> @hoogle Char -> Bool
23:09:33 <lambdabot> Data.Char isAlpha :: Char -> Bool
23:09:33 <lambdabot> Data.Char isAlphaNum :: Char -> Bool
23:09:33 <lambdabot> Data.Char isAscii :: Char -> Bool
23:09:38 <Kaidelong> and so forth
23:09:52 <jle`> b80905: there's isDigit....but your pattern in general looks a lot like a fold
23:09:56 <jle`> and a map
23:09:57 <Kaidelong> lamdabot can tell you all of it in pm
23:10:13 <Kaidelong> if you invoke @more
23:10:22 <b80905> @more
23:10:27 <jle`> first off, it's a map on (c ==) over ['0'..'9']
23:10:48 <jle`> second off, it's a fold using (||) as the function and False as the initial accumulator
23:11:03 <jle`> (that fold is actually provided in prelude, it's called "or")
23:11:05 <jle`> :t or
23:11:08 <lambdabot> [Bool] -> Bool
23:11:09 <jle`> @src or
23:11:09 <lambdabot> or    =  foldr (||) False
23:11:32 <jle`> so you could do fold (||) False . map (== c) $ ['0'..'9']
23:11:33 <Kaidelong> jle`: aren't you reinventing isDigit here?
23:11:41 <jle`> Kaidelong: yeah, but...this is in general :)
23:11:49 <jle`> so maybe he can spot folds and maps in the wild
23:11:52 <jle`> when he sees them
23:11:55 <jle`> in the future
23:12:15 <lovewithacaveat> can anyone here teach me how to think please?
23:12:19 <jle`> so your function is fold (||) False . map (== c) $ ['0'..'9']
23:12:25 <jle`> foldl or foldr
23:12:38 <jle`> but remember prelude provides that fold for you
23:12:46 <jle`> or (map (== c) ['0'..'9'])
23:12:48 <jle`> there :)
23:12:54 <eazar001> lovewithacaveat: I don't think there is a anything on hackage for that [=
23:13:05 <b80905> jle`: where can i learn more about functions like fold and foldr?
23:13:23 <jle`> b80905: any intro to functional programming/haskell will teach you about fold
23:13:25 <jle`> and map
23:13:26 <Kaidelong> most haskell tutorials go over those functions, same with ones for ML-likes
23:13:28 <jle`> LYAH
23:13:40 <jle`> actually i like to consider map and fold as "primitives"
23:13:43 <lovewithacaveat> b80905: i recommend the book written by graham hutton
23:13:45 <jle`> when approaching functional programming
23:13:57 <lovewithacaveat> eazar001: why?
23:14:34 <jle`> b80905: but also
23:14:36 <jle`> this pattern
23:14:40 <Kaidelong> jle`: that's probably not a good idea in haskell because lists serve as control structures as well as data structures so you want to know how things are expanded
23:14:48 <jle`> or . map (== c) [1..10] etc.
23:14:57 <jle`> is also provided as a higher order function in Prelude
23:14:59 <jle`> @src any
23:14:59 <lambdabot> any p =  or . map p
23:15:02 <Kaidelong> in particular they encode prolog-style nondeterministic values
23:15:06 <b80905> jle`: i think i  wrote a fold function in scheme while reading sicp, but what about reduce?
23:15:19 <jle`> fold and reduce are synonyms
23:15:33 <jle`> (for most definitions of both)
23:15:41 <jle`> so see our function was or . map (== c)
23:15:47 <jle`> and looking at the definition of any
23:15:48 <eazar001> lovewithacaveat: that's a good question, i guess we get caught up in the small things of life sometimes
23:15:51 <Kaidelong> our function was isDigit
23:15:57 <jle`> it is clear that our function is any (== c) ['0'..'9']
23:15:58 <jle`> :)
23:16:23 <jle`> actually
23:16:25 <jle`> @src isDigit
23:16:25 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:16:27 <jle`> aw.
23:16:40 <jle`> well from this we can see that we can implement isDigit as isDigit = any (== c)
23:16:44 <jle`> er
23:16:46 <jle`> no :|
23:16:47 <Kaidelong> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/GHC-Unicode.html#isDigit
23:16:58 <jle`> isDigit c = any (== c) ['0'..'9']
23:17:02 <Kaidelong> isDigit c =  c >= '0' && c <= '9'
23:17:23 <jle`> but we can point-free it
23:17:25 <Kaidelong> spotting folds in the wild
23:17:34 <Kaidelong> but why'd you want to
23:17:35 <jle`> @pl isDigit c = any (== c) l
23:17:36 <lambdabot> isDigit = flip any l . (==)
23:17:42 <jle`> hm yeah that's not very good pointfree'd
23:17:44 <jle`> oh well
23:18:20 <eazar001> lovewithacaveat: we have theorem provers [=
23:18:29 <Kaidelong> @ty (&&) <$> (<= '9') <*> (>= '0')
23:18:29 <lambdabot> Char -> Bool
23:18:44 <Kaidelong> that's longer than the pointy version
23:18:50 <Kaidelong> and less clear
23:18:55 <jle`> haha
23:18:59 <jle`> well...maybe.
23:19:18 <jle`> i've read enough liftM2-type applicative function stuff to see it kinda clearly
23:19:26 <jle`> but the pointy version is def more obvious
23:20:02 <triliyn> :t (All . (<= '9')) <> (All . (>= '0'))
23:20:03 <lambdabot> Char -> All
23:21:05 <Kaidelong> anyway the real lesson here is that the geniuses who wrote the haskell library managed to do only two comparisons instead of nine
23:21:13 <Kaidelong> so you should have used isDigit
23:21:22 <jle`> well yeah, isDigit is the better option here
23:21:30 <jle`> isSomething is actually usually better than manually comparing
23:21:38 <jle`> because i think they do some stuff with i18n
23:22:06 <b80905> jle`: isDigit = flip elem ['0'..'9']
23:22:13 <jle`> but...really if you are writing something like c=='0'||c=='1'||c=='2'||c=='3'
23:22:35 <jle`> then you have bigger problems than picking the right Prelude predicate
23:22:54 <jle`> b80905: great :)
23:23:08 <Kaidelong> @ty (//)
23:23:09 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
23:25:30 <jle`> too bad there is no between :: Ord a => a -> a -> a -> Bool
23:26:05 <jle`> between x min max = x >= min && x <= max
23:26:41 <enthropy> isDigit isn't in the Prelude fyi
23:26:48 <Elision> :t All
23:26:49 <lambdabot> Bool -> All
23:26:53 <Elision> whaaat
23:26:58 <Elision> :i All
23:27:04 <jle`> Elision: it's a monoid wrapper over Bool
23:27:06 <Kaidelong> newtype because Bool is a monoid in two ways
23:27:24 <Elision> never heard of this
23:27:48 <Kaidelong> > mconcat (map Any [True..])
23:27:49 <Elision> where's it live?
23:27:49 <lambdabot>  <hint>:1:25: parse error on input `]'
23:27:55 <roboguy_> Elision: Data.Monoid
23:27:59 <jle`> basically the Bools form a monoid over (||) with False as the identity
23:28:05 <jle`> and (&&) with True as the identity
23:28:16 <Kaidelong> why is that a syntax error
23:28:20 <Elision> hmmm, monoid is group without inverses, right?
23:28:25 <Kaidelong> yes
23:28:28 <Elision> sure
23:28:45 <Kaidelong> it's also what you get when you have a category with only one object in it
23:28:47 <Kaidelong> hence the name
23:28:49 <jle`> > [True .. ]
23:28:50 <lambdabot>  [True]
23:28:54 <jle`> i think you need the space after True
23:28:59 <jle`> or else it treats it like a module name
23:29:07 <Kaidelong> > mconcat (map Any [False ..])
23:29:08 <lambdabot>  Any {getAny = True}
23:29:14 <Kaidelong> > mconcat (map All [False ..])
23:29:15 <lambdabot>  All {getAll = False}
23:29:15 <Elision> huh, really?
23:29:16 <Elision> hmmm
23:29:18 <jle`> > Any False <> Any True
23:29:19 <lambdabot>  Any {getAny = True}
23:29:41 <Elision> oh right, this diagram
23:29:49 <jle`> > getAny $ mconcat (map Any [False, False, False, True, False])
23:29:50 <lambdabot>  True
23:29:56 <jle`> > getAny $ mconcat (map Any [False, False, False, False, False])
23:29:57 <lambdabot>  False
23:30:05 <Kaidelong> sure, because for your category C you have only one object A, all morphisms compose with one another and id serves as zero
23:30:36 <Elision> ahh
23:30:53 <Elision> so the morphisms are the group
23:30:55 <Elision> okay
23:30:59 <Kaidelong> it's exactly church encoding
23:31:01 <Elision> "group"
23:31:17 <roboguy_> well, if all the morphisms are isomorphisms it's a group
23:31:24 <Elision> yeah
23:31:36 <Elision> makes sense now
23:32:15 <Elision> and of course, now I'm bound to investigate that silly monad quote
23:32:27 <Kaidelong> (well, the monoid of natural numbers over addition is exactly church endocing)
23:33:57 <Elision> hm, endofunctors over Hask are essentially ... instances of Data.Functor?
23:34:11 <Kaidelong> yes
23:35:13 <Elision> fancy
23:45:34 <leino> is it possible/easy to make an attoparsec parser which fails as soon as it can realize that it consumes >= some number of bytes? (I'm parsing a format which first tells me the number of bytes of a chunk, L say, and then the elements of the chunk are variably-sized things of a certain format, so for robustness I'd like to keep checking that I'm under L bytes whilst parsing the chunk)
23:55:28 <lightquake> grumble. i think i'm going to have to scrap my plans of writing my notmuch email tagger in haskell because the mime/rfc2822 libraries i can see are pretty spotty.
