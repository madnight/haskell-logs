00:00:46 <shachaf> Yes, the guarantee it provides.
00:02:40 <refcell> shachaf: Ah! ty
00:03:00 <prophile> @check \x -> x == sort x
00:03:01 <lambdabot>  +++ OK, passed 100 tests.
00:03:10 <prophile> take that, computer science as we know it
00:03:43 <johannesbodannes> lol what
00:03:56 <johannesbodannes> how is that possibly right
00:04:07 <prophile> beats me
00:04:08 <johannesbodannes> @check \x -> x == sort x
00:04:09 <lambdabot>  +++ OK, passed 100 tests.
00:04:24 <simpson> Probably generates a hundred singleton lists.
00:04:29 <prophile> I can think of two possibilities: one is that x :: [()] and the other is that it's singleton lists
00:04:32 <prophile> yeah
00:04:33 <Hafydd> @check \x -> x == sort x && False
00:04:33 <shachaf> No, the lists are all different.
00:04:34 <lambdabot>  *** Failed! Falsifiable (after 1 test):
00:04:34 <lambdabot>  []
00:04:46 <Hafydd> @check \x -> x == sort x && x /= []
00:04:47 <lambdabot>  *** Failed! Falsifiable (after 1 test):
00:04:47 <lambdabot>  []
00:04:48 <shachaf> It's that x :: [()]
00:05:05 <Hafydd> I thought so.
00:05:07 <prophile> @check \(x :: Int) -> x == sort x
00:05:07 <lambdabot>  <unknown>.hs: 1: 13:ScopedTypeVariables is not enabled
00:05:24 <prophile> @check \x -> (x :: [Int]) == sort x
00:05:25 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 5 shrinks):
00:05:25 <lambdabot>  [0,-1]
00:05:26 <frxx> @check \x -> x == sort (x :: [Int])
00:05:27 <lambdabot>  *** Failed! Falsifiable (after 3 tests and 1 shrink):
00:05:27 <lambdabot>  [0,-1]
00:05:28 <simpson> @check \x -> x == (sort x :: [Int])
00:05:29 <lambdabot>  *** Failed! Falsifiable (after 7 tests and 7 shrinks):
00:05:29 <lambdabot>  [0,-1]
00:05:32 <Hafydd> Take that QuickCheck Science as we know it.
00:05:37 <simpson> ...Well, we all think alike, at least.
00:05:59 <johannesbodannes> @check \x -> if x /= [] then False else True
00:06:00 <lambdabot>  *** Failed! Falsifiable (after 2 tests):
00:06:00 <lambdabot>  [()]
00:06:28 <johannesbodannes> @check \x -> if x /= [] && x /= [()] then False else True
00:06:29 <lambdabot>  *** Failed! Falsifiable (after 3 tests):
00:06:29 <lambdabot>  [(),()]
00:06:42 <johannesbodannes> oh there you go
00:06:44 <johannesbodannes> so if i'm not mistaken...
00:07:10 <johannesbodannes> @check \x -> if x /= [] && x /= [()] && x /= [(), ()] then False else True
00:07:11 <lambdabot>  *** Failed! Falsifiable (after 5 tests):
00:07:11 <lambdabot>  [(),(),()]
00:07:25 <johannesbodannes> it's just taking lists with identical elements ._.
00:07:35 <Hafydd> Does @check automatically instantiate a concrete type?
00:07:41 * shachaf mentions something about how you can /msg lambdabot
00:10:49 <johannesbodannes> @check \x -> if x /= [] && x /= take (length x) (repeat $ head x) then False else True
00:10:51 <lambdabot>  +++ OK, passed 100 tests.
00:11:01 <johannesbodannes> pfffff so useless
00:20:02 <linduxed> when i do unlines in ghci, is there a way for ghci to actually interpret those newlines?
00:20:20 <linduxed> so that it actually visually splits the string across lines?
00:20:28 <linduxed> like printing it?
00:21:07 <supki> linduxed: putStrLn
00:22:24 <linduxed> supki: thx!
00:30:26 <udevd> hi! do anyone has idea how to 'map function on two consecutive elements of list'? i am trying to do something like this: mapConsecutive f [a,b,c,d,e,f..] = [f a b, f b c, f c d, f d e...]
00:30:50 <udevd> is there any other way than pattern matching :P?
00:31:37 <supki> > map (uncurry f) $ zip <*> tail $ [a,b,c,d,e] :: [Expr]
00:31:38 <lambdabot>  [f a b,f b c,f c d,f d e]
00:31:53 <udevd> well
00:31:56 <udevd> thanks
00:34:19 <udevd> > zip <*> tail $ [a,b,c,d,e] :: [Expr]
00:34:20 <lambdabot>  Couldn't match type `(Debug.SimpleReflect.Expr.Expr,
00:34:20 <lambdabot>                        Debug.SimpleReflect.Expr.Expr)'
00:34:20 <lambdabot>                with `Debug.SimpleReflect.Expr.Expr'
00:34:20 <lambdabot>  Expected type: [Debug.SimpleReflect.Expr.Expr]
00:34:20 <lambdabot>                 -> [Debug.SimpleReflect.Expr.Expr]
00:35:16 <jle`> usually you do drop
00:35:21 <jle`> drop 1
00:35:24 <jle`> instead of tail
00:35:28 <udevd> yeah
00:35:30 <jle`> to be safer
00:35:36 <udevd> i'm trying to figure how it works
00:35:40 <udevd> this zip <*> tail
00:35:43 <jle`> also zipWith
00:36:09 <jle`> oh it's the applicative instance of Function
00:36:18 <jle`> it's the same as liftM2
00:36:32 <simon> why is drop 1 safer than tail?
00:37:05 <eazar001> > drop 1 []
00:37:06 <lambdabot>  []
00:37:12 <simon> ah! :)
00:37:17 <eazar001> > tail []
00:37:18 <lambdabot>  *Exception: Prelude.tail: empty list
00:37:27 <eazar001> yep [=
00:37:48 <jle`> udevd: f <$> g <*> h is the same as \x -> f (g x) (h x)
00:38:16 <jayferd> am i supposed to install cabal dependencies before or after running configure
00:38:19 <udevd> and since you didn't use <$> ...?
00:38:26 <jle`> oh
00:38:34 <jayferd> i just finished cabal install --only-dependencies, and configure tells me i have missing dependencies
00:38:36 <jle`> i misread
00:38:38 <jayferd> *so confused*
00:39:25 <jayferd> and doing anything else tells me to run configure
00:40:00 <jle`> > let xs = [a,b,c,d,e] in zipWith f xs (tail xs)
00:40:01 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr c0)
00:40:02 <lambdabot>    arising from a use of `e_1'
00:40:02 <lambdabot>  The type variable `c0' is ambiguous
00:40:02 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:40:02 <lambdabot>  Note: there are several potential instances:
00:40:07 <jle`> > let xs = [a,b,c,d,e] in zipWith f xs (tail xs) :: [Expr]
00:40:08 <lambdabot>  [f a b,f b c,f c d,f d e]
00:40:14 <udevd> mhm
00:40:26 <udevd> okay i see
00:40:26 <udevd> :3
00:40:31 <jle`> @pl \xs -> zipWith f xs (tail xs)
00:40:31 <lambdabot> ap (zipWith f) tail
00:40:39 <jle`> ah
00:41:09 <jle`> :t zipWith f <*> tail
00:41:09 <lambdabot> (Show b, FromExpr c) => [b] -> [c]
00:41:46 <jle`> > let fAll = zipWith f <*> tail in fAll [a,b,c,d,e] :: [Expr]
00:41:47 <lambdabot>  [f a b,f b c,f c d,f d e]
00:43:58 <jle`> :t (<*>)
00:43:59 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:44:26 <jayferd> oh there we go, i guess --enable-tests has to be passed to install as well as configure
00:44:34 <jle`> zipWith f is [a] -> ([b] -> [c]), and tail is [a] -> ([c])
00:44:47 <jle`> the 'applicative' is ([a] ->)
00:45:13 <jle`> so you have f ([b] -> [c]) and f [b]
00:45:29 <jayferd> i would find it weird to read code like that, though
00:45:30 <jle`> *tail is [a] -> ([b]), sorry
00:45:52 <jayferd> maybe others are more used to seeing (-> a) as Applicative, but it still takes me a while to wrap my head around it
00:46:07 <jle`> so you have f ([b] -> [c]) and f [b].  <*> lets us apply a function in an applicative to value in an applicative
00:46:59 <shachaf> (-> a) is not a thing you can express.
00:47:30 <shachaf> ((->) a) in Haskell, or (a ->) in the common shorthand
00:49:05 <jle`> so it applies our [b] -> [c] function inside the first applicative to the [b] inside the second applicative, to get [c]...so your final result is f [c], or fully expressed, [a] -> [c]
00:50:27 <jle`> similar to Maybe ([b] -> [c]) <*> Maybe ([b]) producing Maybe ([c])
00:51:03 <jle`> f ([b] -> [c]) <*> f ([b]) produces f ([c])
00:51:11 <jle`> our f being ([a] ->)
00:51:58 <jle`> f as an Applicative, not as in function...
00:52:09 <jle`> *in
00:52:55 <udevd> > zipWith f <$> id <*> tail $ [a,b,c,d,e]
00:52:56 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr c0)
00:52:56 <lambdabot>    arising from a use of `e_1'
00:52:56 <lambdabot>  The type variable `c0' is ambiguous
00:52:56 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
00:52:56 <lambdabot>  Note: there are several potential instances:
00:52:58 <udevd> ;_;
00:53:19 <jle`> you need to specify the type [Expr]
00:53:31 <udevd> ah
00:53:37 <udevd> > zipWith f <$> id <*> tail $ [a,b,c,d,e,f] :: [Expr]
00:53:39 <lambdabot>  [f a b,f b c,f c d,f d e,f e f]
00:53:41 <udevd> :3
00:53:46 <jle`> but
00:53:49 <jle`> remember the functor laws
00:54:03 <udevd> hm?
00:54:22 <udevd> what about them
00:54:38 <jle`> actually wait they aren't exactly applicable here
00:56:16 <jle`> i guess is this considered a category law?
00:56:37 <jle`> remember that (<$>) for functions is (.)
00:56:56 <jle`> so f . id = f
00:57:02 <jle`> because id is the identity under function composition
00:57:29 <jle`> > (show . id) $ 5
00:57:30 <lambdabot>  "5"
00:57:59 <jle`> > (show <$> id) $ 5
00:58:00 <lambdabot>  "5"
00:58:09 <jle`> unecessary ($)
00:58:12 <jle`> but yeah.
01:00:57 <dv-> or unnecessary ()'s
01:02:03 <jle`> i think this is a monad law
01:02:07 <jle`> hm.
01:02:17 <jle`> nevermind i'm just talking nonsense now.
01:02:55 <jle`> because i don't think "id" is any special function in relation to the applicative/functor/monad instance of Function
01:04:09 <reirob> Hello Haskellers
01:04:12 <reirob> I am first time here
01:04:34 <reirob> I am trying to build GHC on a Raspberry PI and I fail :(
01:05:01 <reirob> And because building takes so much time, after 3 days I am desperate and need some help
01:05:41 <reirob> Is there somebody who has managed to compigle GHC 7.6.3 on raspberry PI?
01:05:46 <albertid> reirob maybe install a binary package?
01:06:09 <tdammers> reirob: have you tried raspbian? ghc is in debian, so I assume raspbian might have it too
01:06:29 <reirob> There is indeed a binary package that contains 7.4.1 but WITHOUT GHCI. I am on raspbian. And I need to make gitit work on it!
01:06:48 <tdammers> have you tried haskell-platform?
01:06:57 <reirob> And from what I understand gitit need somehow to have GHCi
01:07:40 <Saizan> ghci is not available on every arch
01:07:41 <grohne> reirob: you could try porting the debian jessie/sid ghc package to raspbian. usually there are few changes between debian and raspbian
01:08:50 <reirob> haskell-platform has NO binaries for Raspberry PI as far as I have seen.
01:09:18 <reirob> grohne, what is the jessie/sid ghc package? where can I find it?
01:09:44 <merijn> rasberrypi is ARM, no?
01:09:56 <merijn> ghci isn't supported on ARM yet
01:10:19 <merijn> So the only way to make it work are dirty hacks, hours of blog research and a lot of luck
01:10:22 <grohne> reirob: dget http://http.debian.net/debian/pool/main/g/ghc/ghc_7.6.3-6.dsc
01:11:44 <reirob> yes it is ARM. and there seem to be controversial information of what works and what does not work. I have followed the article http://searchcode.com/codesearch/raw/40330614
01:11:54 <reirob> which gave me some hope on making gitit work on a raspi
01:11:55 <grohne> reirob: but consider that as merijn points out, ghci may be missing from the debian package as well
01:12:41 <grohne> rpi uses an armv7 cpu whereas debian's idea of arm is armv8+
01:13:21 <reirob> grohne, I do not have the dget command?
01:14:15 <grohne> reirob: it is part of the devscripts package
01:14:44 * reirob installing devscripts package on raspbian
01:16:02 <grohne> reirob: note that indeed http://packages.debian.org/sid/armel/ghc/filelist suggests that ghci is missing from the arm build. you may get a ghc 7.6 that way, but likely no ghci.
01:16:08 <reirob> but to come back. so I downloaded all the utilities to build GHC from scratch. I followed the instructions and phase0 and phase1 are finished successfully. My make process stops with:
01:16:11 <reirob> make -r --no-print-directory -f ghc.mk phase=final all_libraries
01:16:11 <reirob>   HC [stage 1] libraries/ghc-prim/dist-install/build/GHC/Types.o
01:16:11 <reirob> Stack dump:
01:16:11 <reirob> 0.	Program arguments: llc -O3 -relocation-model=static /tmp/ghc19901_0/ghc19901_0.bc -o /tmp/ghc19901_0/ghc19901_0.lm_s --enable-tbaa=true
01:16:12 <reirob> 1.	Running pass 'Function Pass Manager' on module '/tmp/ghc19901_0/ghc19901_0.bc'.
01:16:14 <reirob> 2.	Running pass 'ARM Instruction Selection' on function '@ghczmprim_GHCziTypes_Dzh_info'
01:16:16 <reirob> /tmp/ghc19901_0/ghc19901_0.lm_s: openBinaryFile: does not exist (No such file or directory)
01:16:18 <reirob> make[2]: *** [libraries/ghc-prim/dist-install/build/GHC/Types.o] Error 1
01:16:20 <reirob> make[1]: *** [all_libraries] Error 2
01:16:22 <reirob> make[1]: Leaving directory `/home/pi/tmp/haskell_tests/ghc'
01:16:24 <reirob> make: *** [all] Error 2
01:17:03 <reirob> grohne, so then there is no need to try the package that you suggested, right?
01:17:37 <grohne> reirob: depends on whether you want ghc 7.6 in particular or you want ghci. that wasn't clear to me.
01:18:08 <reirob> because the link transscript that I used, was saying that he manages to make it work. I understand that this guy/girl made it work (unfortunately there is no reference who has put this transscript on the web)
01:18:28 <reirob> grohne, I need to make gitit work. And gitit needs ghci.
01:18:52 <reirob> I am fine with whatever ghc version that will work on Raspbian and run on a raspberry pi
01:19:57 <grohne> then likely the debian package is not going to help you, sorry
01:21:15 <reirob> I have the feeling that my environment is missing some tool or configuration. from the error message in the make log. But I am unable to understand what it might be. Googled "openBinaryFile: does not exist (No such file or directory)" but it seems to point out everytime to different problems.
01:21:37 <reirob> no need to be sorry grohne. I am thankful that somebody cares to answer ;)
01:25:31 <zett_zelett> Can someoone help me read code? I’m struggling to understand this: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-List.html#permutations
01:25:49 <zett_zelett> I’ve already read the wiki article on How to read Haskell.
01:29:32 <Enigmagic> reirob: it's failing within LLVM's llc tool, not directly in GHC.
01:30:12 <Enigmagic> reirob: it's possible that GHC's arm support needs a different/newer version of LLVM than what you have installed.
01:31:44 <tdammers> zett_zelett: which part do you have trouble with?
01:32:36 <reirob> @Enigmagic, yes this is what I thought. But I have read somewhere that either llvm 3.0 or >3.2 should be used. I have llvm 3.0
01:32:36 <lambdabot> Unknown command, try @list
01:33:01 <zett_zelett> First of all, I can’t imagine what interleave' does, tdammers
01:33:13 <reirob> I am following the same instructions as http://searchcode.com/codesearch/raw/40330614 but with ghc-7.6.3 instead of 7.6.1
01:34:54 <zett_zelett> I deduced it’s type signature has to be ([a] -> [a]) -> [a] -> [a] -> ([a],[a]), no?
01:34:57 <zett_zelett> its*
01:36:55 <Enigmagic> reirob: was that arm specific instructions for 7.6? i would have guessed 3.2 to be a better fit... but i'm not sure what shape GHC's arm backend is in.
01:41:45 <reirob> @Enigmagic: Do you mean "/tmp/ghc29450_0/ghc29450_0.lm_s: openBinaryFile: does not exist (No such file or directory)" is an error message from llc?
01:41:45 <lambdabot> Unknown command, try @list
01:47:04 * hackagebot blaze-markup 0.5.2.0 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.2.0 (JasperVanDerJeugt)
01:49:57 <Enigmagic> reirob: no, but the "Stack dump:" and following lines are an LLVM assert... then GHC fails to open the output file that llc didn't produce.
01:52:01 <reirob> @Enigmagic: thanks for this hint. Will dig deeper. Trying to find an option to the make command to get more information
01:52:01 <lambdabot> Unknown command, try @list
01:52:05 * hackagebot blaze-markup 0.5.2.1 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.2.1 (JasperVanDerJeugt)
01:54:35 <Enigmagic> reirob: well good luck, i'd try upgrading to llvm 3.2 first though
01:55:32 <jle`> function binding looks weird for things like succ 1**2
01:55:45 <jle`> > succ 1^2
01:55:46 <lambdabot>  4
01:55:49 <jle`> alas.
01:55:57 <reirob> Enigmagic: but if I upgrade to llvm 3.2 do you think I will need to redo the make from start, e.g. make clean && make?
01:56:11 <reirob> Enigmagic: this will take another night :(
01:57:21 <reirob> Enigmagic: I hope that installing llvm 3.2 will be straight forward ;)
01:57:30 <reirob> Enigmagic: never did it.
01:58:39 <reirob> Enigmagic: No there is no llvm 3.2 for raspi. Will not be straight forward :(
02:00:06 <Enigmagic> reirob: well i dunno then, llc asserts usually imply a mismatch between ghc and llvm... ghc usually checks for compatible versions but those are likely to be intel specific.
02:01:06 <reirob> Enigmagic: I will wipe my raspbian and restart from scratch. following letter by letter the instructions in http://searchcode.com/codesearch/raw/40330614
02:01:36 <Enigmagic> reirob: if you do end up building llvm just make sure to pass --targets=host otherwise it'll compile backends for every processor in the world.
02:02:06 * hackagebot egison 3.2.4 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.4 (SatoshiEgi)
02:02:58 <reirob> Enigmagic: Maybe my environment misses something. Who knows. But I would have liked to get a straight clue what I am doing wrong. Will come back and report if I have success.
02:03:50 <reirob> Otherwise I will end up plugging an intel compatible laptop to run around the clock - will waste more energy and make more noise than a raspi though ;(
02:04:21 <reirob> thank you very much for all your hints. Continue the good work Haskellers! You really rock!
02:05:39 <sordina1> Hiya.
02:05:48 <divyansr> > take 5 [1..10]
02:05:50 <lambdabot>  [1,2,3,4,5]
02:05:51 <johnw> sordina1: hello
02:05:53 <Enigmagic> reirob: np, hope you get it buiding
02:06:09 <sordina1> Has anyone used pdf2line package rencently?
02:06:26 <sordina1> I'm trying to parse some pdfs and there seem to be some issues.
02:06:54 <sordina1> Not sure if I should start debugging the Binary instance or not.
02:21:41 <eazar001> @hoogle lambdabot
02:21:42 <lambdabot> package lambdabot
02:21:42 <lambdabot> package lambdabot-utils
02:22:22 <eazar001> @help
02:22:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:22:42 <eazar001> @help list
02:22:42 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
02:22:51 <Iceland_jack> eazar001: You can query lambdabot in PM
02:23:06 <eazar001> Iceland_jack: thanks
02:23:34 <eazar001> I guess I need some private time with lambda-bot [;
02:50:34 <xenocons_> what would you name a function that associates like $ but returns Maybe ?
02:51:08 <Cale> (=<<) ?
02:51:22 <Cale> What type would it have?
02:51:38 <xenocons_> something like (a -> b) -> a -> b maybe
02:51:46 <Cale> That's just ($)
02:51:57 <Axman6> did you mean Maybe b?
02:52:07 <xenocons_> sorry Maybe b
02:52:32 <Axman6> that doesn't make a whole lot of sense though. if you have a -> b, you know you can produce a b from the a, where does Maybe come into it?
02:52:32 <Cale> Well, I guess you could use (Just .) . ($)
02:52:33 <Cale> hah
02:52:35 <Cale> But yeah
02:52:37 <Cale> uhhh
02:52:41 <Cale> What are you trying to do?
02:53:07 <xenocons_> look for a name for my function in F# but asking haskell people because they have a good sense of naming
02:53:09 <Cale> :t Just
02:53:10 <lambdabot> a -> Maybe a
02:53:26 <Cale> Why is there a Maybe involved?
02:53:34 <xenocons_> wrapping exception handler
02:53:42 <xenocons_> f x = try Some (f x) with -> None
02:54:06 <Axman6> try is exception handling?
02:54:16 <Cale> :t try
02:54:17 <lambdabot> Exception e => IO a -> IO (Either e a)
02:54:19 <xenocons_> i called it 'maybe' as a function, but a haskellite pointed out that was an odd function choice name
02:54:27 <xenocons_> Axman6: yeh
02:55:17 <Kinnison> Cale: Isn't (Just .) the same as (Just . ) . ($)
02:55:18 <frege> is pattern matching like if statements on type?
02:55:19 <Kinnison> Cale: ?
02:55:24 <Kinnison> Cale: at least, typewise
02:55:26 <chrra> I'd name it $?, but F# might have a different naming scheme.
02:55:32 <Cale> Kinnison: indeed
02:55:37 <johnw> yeah, $ is also known as id, minus the associativity
02:55:48 <Kinnison> mmm
02:55:53 <johnw> (and only for functions, of course)
02:55:59 <Axman6> frege: pattern matching is like case statements on structs with unions and a tag, but much more powerful and nice
02:56:01 <xenocons_> i can use ?$ i guess
02:56:10 * Axman6 awaits someone to be horrified at that explanation
02:56:16 <sordina1> I'd name it -~=>Mysterio~~!>>>
02:56:18 <Cale> xenocons_: What you're writing is a little bit like what we call try
02:56:31 <xenocons_> or maybe not, unfortunately haskell is nicer that it has $
02:56:33 <xenocons_> Cale: ahh
02:56:36 <Cale> xenocons_: Only our try produces an Either e a
02:56:43 <Cale> (where e is the exception type being caught)
02:56:44 <Axman6> F# has |> no?
02:56:49 <xenocons_> Cale: your try is much nicer then
02:56:53 <Axman6> that's just flip ($) isn't it?
02:56:57 <xenocons_> Axman6: yeah, but i would like the actual operator $
02:57:00 <xenocons_> also has <|
02:57:06 <Cale> :t try
02:57:06 <lambdabot> Exception e => IO a -> IO (Either e a)
02:57:12 <xenocons_> you cant use $ in operators in F# unfortunately!
02:57:33 <xenocons_> Cale: yeah, that definetly makes more sense
02:57:46 <xenocons_> i accidentally started rewriting bits of haskell in F# i guess
02:58:41 <xenocons_> your try is nice sigh
02:58:51 <xenocons_> ill name mine 'tryy' hehe
02:59:45 <xenocons_> at least i can bind >>= ;)
03:00:01 <xenocons_> why is haskell a drug..
03:00:40 <frege> what a nice article http://www.haskell.org/tutorial/patterns.html
03:01:09 <frege> I don't know why most of authors try to be overnice in writing about haskell as if they are writing for kids
03:01:19 <frege> this one is straight forward
03:03:26 <frege> @src head
03:03:26 <lambdabot> head (x:_) = x
03:03:26 <lambdabot> head []    = undefined
03:03:27 <Cale> frege: You think that's written as if aimed at kids?
03:03:32 <Cale> oh
03:03:36 <Cale> Or other things are
03:03:50 <frege> Cale: no other texts, that one is really good imo
03:04:19 <frege> e.g. LYAH or whatever that is
03:04:21 <Cale> It's not bad. It was nearly the only tutorial when I started out :)
03:04:28 <frege> nice
03:04:39 <merijn> frege: I dunno, I liked LYAH, easy reading :)
03:05:20 <frege> yeah I guess it's differenet for everyone
03:05:43 <merijn> frege: Keep in mind that many pre-LYAH texts were...rather intimidating
03:05:51 <merijn> Thus scaring many people away from Haskell
03:06:10 <tdammers> the "Gentle" Introduction?
03:06:13 <frege> good
03:06:18 <merijn> @quote wrestling.bears
03:06:18 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
03:06:29 <Aleksejs> :D
03:06:35 <tdammers> sounds legit
03:06:56 <frege> merijn: people who get scared from texts like this aren't ready yet to learn it
03:07:17 <frege> heh I'm a newbie ..
03:07:23 <frege> I love this "f s@(x:xs)             = x:s"
03:07:24 <Iceland_jack> frege: Is that for you to say?
03:07:28 <merijn> frege: Why? It's not like haskell is some exclusive club for gristled programmers
03:07:56 <frege> I was just joking of course it's not
03:08:21 <tdammers> I think it was kind of a chicken-and-egg problem
03:08:44 <tdammers> nobody writes noob-friendly tutorials of high quality for an "esoteric" language
03:09:03 <tdammers> but in order to become somewhat mainstream, you need good beginner tutorials
03:09:11 <simon> merijn, I also liked LYAH, but then my professor said he really didn't like it, and it occurred to me that I mostly liked it because of the pictures and the light mood, but not necessarily for the order of introducing things and how little some things are touched.
03:10:04 <frege> "Technically speaking, as-patterns always result in a successful match, although the sub-pattern (in this case x:xs) could, of course, fail."
03:10:25 <frege> so does that mean if the sub-pattern fails, it will skip that?
03:10:41 <johnw> no
03:10:42 <Iceland_jack> frege: if the sub-pattern fails it's a run-time error
03:10:53 <frege> oh shit
03:11:02 <Iceland_jack> > let asPattern@[] = "testing" in asPattern
03:11:03 <lambdabot>  "*Exception: <interactive>:3:5-28: Irrefutable pattern failed for pattern as...
03:11:04 <johnw> the pattern is accepted immediately, but when it tries to use the value matched by the sub-pattern, it will die
03:11:33 <Iceland_jack> As johnw says, if you don't use it it won't cause an error
03:11:33 <Iceland_jack> > let asPattern@[] = "testing" in []
03:11:34 <lambdabot>  []
03:11:57 <frege> > let s@String = "test" in String
03:11:58 <lambdabot>  Not in scope: data constructor `String'Not in scope: data constructor `String'
03:12:01 <simon> frege, if there are multiple patterns (e.g. a case-of), one pattern failing will move on to the next.
03:12:10 <Iceland_jack> frege: String is not a constructor
03:12:30 <frege> > let s@[char] = "test" in [char]
03:12:31 <lambdabot>  "*Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern s@...
03:12:33 <Iceland_jack>     "test"
03:12:33 <Iceland_jack>     =
03:12:33 <Iceland_jack>     't':'e':'s':'t':[]
03:12:33 <Iceland_jack>  
03:12:40 <Iceland_jack> frege: You're confused
03:12:45 <frege> yes I am
03:12:56 <frege> a Constructor?
03:13:04 <frege> is that different from a type?
03:13:11 <adnap> > sort ["B", "A", "a"]
03:13:12 <lambdabot>  ["A","B","a"]
03:13:19 <Iceland_jack> > let string@(a:b:c:d:[]) = d:c:b:a:[]
03:13:20 <lambdabot>  not an expression: `let string@(a:b:c:d:[]) = d:c:b:a:[]'
03:13:26 <Iceland_jack> > let string@(a:b:c:d:[]) = "test" in d:c:b:a:[]
03:13:27 <lambdabot>  "tset"
03:13:35 <adnap> I expect ["a", "A", "B"]. Is there a library function that sorts the same way as ls?
03:13:51 <simon> adnap, lexicographically?
03:13:56 <adnap> simon: I guess.
03:13:58 <Iceland_jack> adnap: sortBy
03:14:15 <adnap> Prioritizing capitals isn't lexicographic?
03:14:49 <Iceland_jack> > sortBy (comparing (map toLower)) ["B", "A", "a"] -- not what you asked for but possibly what you wanted
03:14:50 <lambdabot>  ["A","a","B"]
03:14:53 <simon> adnap, good point.
03:14:58 <johnw> you mean, you want a case-insensitive sort, with lowercase before uppercase?
03:15:14 <adnap> johnw: I think so. I want want ls does
03:15:21 <simon> adnap, it seems that it also ignores some characters. e.g. "bla" comes before "#bla#" comes before "Blo"
03:15:28 <frege> how do I pattern match a string?
03:15:39 <Iceland_jack> frege: Ignore strings for now, focus on lists
03:15:59 <Iceland_jack> frege: A list has only two cases:
03:15:59 <Iceland_jack>     empty:     []
03:15:59 <Iceland_jack>     non-empty: x:xs
03:16:02 <adnap> simon: Is "it" ls?
03:16:07 <simon> adnap, it seems that my ls uses capitals as tie-breakers.
03:16:20 <Blkt> what parsec combinators do I have to use to say "none of the following strings"?
03:16:22 <Iceland_jack> > let x:xs = "testing" in xs -- frege
03:16:23 <lambdabot>  "esting"
03:16:28 <frege> let s@[] = "test" in s
03:16:31 <frege> > let s@[] = "test" in s
03:16:32 <lambdabot>  "*Exception: <interactive>:3:5-17: Irrefutable pattern failed for pattern s@[]
03:16:35 <simon> adnap, yup. I just did "ls ~/Downloads" and found a bunch of sorting rules that I hadn't guessed.
03:16:41 <Iceland_jack> frege: That's going to fail because "test" is not an empty list
03:16:51 <adnap> Well, Iceland_jack's is reasonable
03:16:54 <frege> > let s@[] = [] in s
03:16:55 <lambdabot>  []
03:17:05 <frege> > let s@[a] = "test" in s
03:17:06 <lambdabot>  "*Exception: <interactive>:3:5-18: Irrefutable pattern failed for pattern s@[a]
03:17:08 <adnap> I am just presenting files through a web browser like Apache
03:17:14 <frege> > let s@[a] = [1,2,3,4] in s
03:17:15 <lambdabot>  *Exception: <interactive>:3:5-21: Irrefutable pattern failed for pattern s@[a]
03:17:30 <frege> > let s@(x:xs) = [1,2,3,4] in s
03:17:30 <adnap> So, I thought it would be reasonable to mimic ls
03:17:31 <lambdabot>  [1,2,3,4]
03:17:38 <Iceland_jack> frege: [a] is the same as (a:[])
03:17:44 <frege> hmm
03:17:55 <frege> > let s@(xs) = [1,2,3,4] in s
03:17:56 <lambdabot>  [1,2,3,4]
03:18:03 <frege> > let s@x = [1,2,3,4] in s
03:18:04 <lambdabot>  [1,2,3,4]
03:18:17 <Iceland_jack> the as-pattern doesn't do anything there frege
03:18:20 <Axman6> that's just giving two names to the same thing
03:18:26 <Iceland_jack> also you can query lambdabot privately
03:18:42 <frege> > let s@x = [1,2,3,4] in x
03:18:43 <lambdabot>  [1,2,3,4]
03:18:44 <Axman6> > let s@x = [1,2,3,4] in (s,x)
03:18:45 <lambdabot>  ([1,2,3,4],[1,2,3,4])
03:18:47 <adnap> Iceland_jack: That is a sublte way of saying "stop" :P
03:18:54 <frege> hah very interesting
03:18:54 <Iceland_jack> adnap: :) I'm a subtle person
03:19:27 <frege> I'm doing it here b/c I want to get feedback from others :( otherwise I have ghci open infront of me
03:19:35 <adnap> frege: I don't mind. I can filter it
03:19:38 <frege> if it's annoying I will do it privately
03:20:06 <frege> amathew: so if I change x, will the value of s change as well?
03:20:17 <Axman6> better to ask questions here when you have a problem
03:20:19 <Iceland_jack> frege: what do you mena ‘change x’?
03:20:24 <Iceland_jack> *mean
03:20:28 <frege> I meant Axman6 , sorry amathew
03:21:09 <frege> Iceland_jack: are 'x' and 'x' both pointing to the same location in the memory?
03:21:18 <johnw> frege: if s and x were something mutable, then yes
03:21:52 <Iceland_jack> frege: Here it doesn't matter to you
03:21:53 <frege> so lets say if it's an integer
03:22:05 <johnw> integers aren't mutable
03:22:13 <frege> yeah that's why I asked
03:22:20 <frege> so is that a copy?
03:22:24 <frege> not a reference
03:22:28 <johnw> x and s are names for the same value
03:22:53 <johnw> at runtime, they don't have any kind of separateness from each other, only lexically at compile-time do they exist as separate names
03:23:15 <johnw> in other words, it's a mostly meaningless distinction that will disappear when the code is compiled
03:23:17 <frege> ok so it's basically a pointer
03:23:21 <johnw> no, not a pointer
03:23:24 <Iceland_jack> frege: no that's not what it is
03:23:25 <johnw> s and x _are the same thing_
03:23:37 <frege> different tags?
03:23:45 <frege> associated with a value?
03:23:49 <Iceland_jack> frege: You're coming at this from the wrong mindset
03:23:49 <johnw> different lexical names
03:23:59 <tdammers> there is not necessarily a 1:1 relationship between syntax entities and things the compiler outputs
03:24:13 <frege> Iceland_jack: I know, and I'm expecting to fix my mindset in this discussion
03:24:15 <eazar001> frege: I think 'alias' is a better name
03:24:19 <johnw> yeah, I would avoid trying to think about this "operationally"
03:24:28 <tdammers> when you write code, the language definition tells you how the compiled output should behave
03:24:44 <tdammers> but whether the compiler uses pointers or not is an implementation detail
03:24:57 <adnap> :sprint can tell you if something is evaluated
03:25:07 <adnap> So, you can sometimes check "references" this way
03:25:15 <Iceland_jack> frege: Have you looked at LYAH?
03:25:15 <Iceland_jack> @where lyah
03:25:15 <lambdabot> http://www.learnyouahaskell.com/
03:25:16 <frege> hmm
03:25:35 <Iceland_jack> It answers some of the questions you've asked here in the first chapters
03:25:39 <tdammers> e.g., the code `let a = 23 in print a` could compile to (in C) `int a = 23; printf("%s", a);` or it could be `printf("%s", a);`, or even `print("23");`
03:25:45 <frege> Iceland_jack: yeah and I dropped it, I'm reading other texts
03:26:02 <Iceland_jack> Consider undropping it.
03:26:05 <Axman6> %d surely
03:28:40 <eazar001> frege: don't completely `drop` it, read stuff like real world haskell, then jump back to LYAH, and then jump to haskell wiki books
03:28:53 <eazar001> it helps to get multiple perspectives concurrently
03:28:53 <johnw> LYAH is a much better place to start than RWH, in my opinion
03:28:58 <Iceland_jack> I agree
03:29:10 <Iceland_jack> In any case, lists are very simple: [] and (x:xs)
03:29:15 <Iceland_jack> Everything else is just sugar
03:29:38 <Iceland_jack>     [x]     = x:[]
03:29:38 <Iceland_jack>     [x,y]   = x:y:[]
03:29:38 <Iceland_jack>     [x,y,z] = x:y:z:[]
03:29:38 <Iceland_jack>     …
03:30:13 <eazar001> yea RWH is a bit much when starting off ... but it is a good shock to re-learn what it introduces via LYAH
03:30:20 <Iceland_jack> Here's an example of a fairly daft function:
03:30:20 <Iceland_jack>     threeElements :: [a] -> Bool
03:30:20 <Iceland_jack>     threeElements [a,b,c] = True
03:30:20 <Iceland_jack>     threeElements _       = False
03:30:23 <Iceland_jack>     
03:31:19 <frege> @src take
03:31:20 <lambdabot> take n _      | n <= 0 =  []
03:31:20 <lambdabot> take _ []              =  []
03:31:20 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
03:32:17 <frege> the first pattern matching says if n is <= 0 return an empty list
03:32:31 <frege> second one says if the list is empty, return an empty list
03:33:01 <Iceland_jack> frege: yes
03:33:05 <frege> third one says; if there is a number n and a list (x:xs) then return a list
03:33:25 <frege> x : take (n-1) xs
03:33:48 <Iceland_jack> > take (-4) "test"
03:33:49 <lambdabot>  ""
03:33:53 <Iceland_jack> > take 1 "test"
03:33:53 <frege> so it will pass those values recursively until n reaches 0?
03:33:54 <lambdabot>  "t"
03:33:58 <Iceland_jack> frege: Yes
03:34:06 <frege> cool and it matches the first one
03:34:11 <Iceland_jack> yes
03:34:13 <frege> and done
03:36:08 <frege> man I'm not used to seeing this much recursion
03:36:10 <Tinned_Tuna> Heya, I'm having some trouble using ByteString with BloomFilter http://lpaste.net/98470
03:36:18 <frege> trying to wrap my head around it
03:36:20 <Iceland_jack> so what happens when you do
03:36:20 <Iceland_jack>       take 4 "testing"
03:36:21 <Iceland_jack> is
03:36:21 <Iceland_jack>     ↝ take 4 ('t':'e':'s':'t':'i':'n':'g':[])
03:36:24 <Iceland_jack>     ↝ 't' : take 3 ('e':'s':'t':'i':'n':'g':[])
03:36:27 <frege> Tinned_Tuna: what's the problem?
03:36:28 <Iceland_jack>     ↝ 't' : 'e' : take 2 ('s':'t':'i':'n':'g':[])
03:36:29 <Iceland_jack>     ↝ 't' : 'e' : 's' : take 1 ('t':'i':'n':'g':[])
03:36:32 <Iceland_jack>     ↝ 't' : 'e' : 's' : 't' : take 0 ('i':'n':'g':[])
03:36:36 <Tinned_Tuna> tl;dr, I can't seem to convince GHC that there exists an instance of Hashable ByteString
03:36:38 <Iceland_jack>  
03:36:41 <Iceland_jack> and ‘take 0 _’ is always []
03:36:48 <Tinned_Tuna> (I think that's the problem, unless it's a symptom of something else)
03:36:53 <Iceland_jack> so it becomes
03:36:53 <Iceland_jack>     ↝ 't' : 'e' : 's' : 't' : []
03:36:53 <Iceland_jack> or
03:36:53 <Iceland_jack>     "test"
03:36:59 <Iceland_jack> > take 4 "testing"
03:37:00 <lambdabot>  "test"
03:37:19 <Iceland_jack> frege: You'll get used to it in no time
03:37:36 <frege> Iceland_jack: oh shit! that was really cool and visualized the whole thing, thanks!
03:37:48 <frege> Iceland_jack: is there a command to get that?
03:37:48 <zett_zelett> Can someone help me luciding up this code: http://lpaste.net/98456 – I’ve been trying to make it look clearer for hours, but I get nowhere.
03:37:50 <Axman6> Tinned_Tuna: have you imported Data.Hashable?
03:37:55 <supki> Tinned_Tuna: that usually means you have 2 instances of bytestring package installed
03:37:56 <Iceland_jack> frege: Just free time and no friends
03:38:07 <merijn> frege: I'm a big believer of just grabbing a piece of paper/whiteboard and doing the substitution manually
03:38:11 <merijn> frege: You can learn a lot
03:38:11 <zett_zelett> (Intially, I also wanted it to perform better, but this is no longer an issue.)
03:38:17 <merijn> frege: Same goes for matching types
03:38:22 <Tinned_Tuna> supki: is that as a ghc package or cabal? I know that cabal info bytestring only shows the one installed bytestring.
03:38:27 <Tinned_Tuna> Axman6: let us give that a whirl.
03:38:27 <frege> Iceland_jack: hahahahaha ./loneliness "take (4) "testing""
03:38:34 <Iceland_jack> exactly :)
03:38:41 <Mait0> How could I turn off/on ghci's output? I just wanna see ':set +s' result.
03:39:05 <Iceland_jack> frege: Can you now define a function that returns True for lists of length 2 4 or 5 by pattern matching and False otherwise?
03:39:21 <frege> Iceland_jack: let me try
03:39:51 <Tinned_Tuna> Axman6: I didn't have hashable installed at all(!), so now it's cabal install-ing
03:40:58 <Axman6> Tinned_Tuna: odd, it seems like it should be a dep of bloom filter
03:41:16 <Tinned_Tuna> Axman6: yea, but in http://hackage.haskell.org/package/bloomfilter-1.2.6.10/docs/Data-BloomFilter-Hash.html, it seems to have it's own instances of Hashable
03:41:31 <Axman6> urgh... that seems like a bad sign
03:41:49 <Axman6> instance or class definition?
03:42:46 <Tinned_Tuna> Axman6: I checked on what supki said, I do infact have 2 GHC packages for bytestring as well.
03:42:57 <Axman6> :\ not good
03:43:15 <Tinned_Tuna> Axman6: in Data.BloomFilter.Hash: "class Hashable a where..."
03:43:26 <Tinned_Tuna> Axman6: http://hackage.haskell.org/package/bloomfilter-1.2.6.10/docs/src/Data-BloomFilter-Hash.html#Hashable
03:43:54 <frege> Iceland_jack:
03:43:56 <frege> f l@length x | l in (2,4,5) = True | l x not in (2,4,5) = False
03:43:57 <Tinned_Tuna> Axman6: I'm guessing that at this point it's likely to be simple to try to evict one of the bytestring packages and see how that affects the build?
03:44:15 <Axman6> I don't know, this is beyond me
03:44:15 <frege> I don't know if "in", "not in" works in haskell
03:44:23 <Iceland_jack> frege: You don't need as-patterns or guards
03:44:32 <Tinned_Tuna> Axman6: well, I know that it's quite easy to knack-up one's GHC package repo
03:44:40 <frege> Iceland_jack: hmm, let me try again then
03:44:41 <Tinned_Tuna> so I'll make a backup of it (and the cabal package repo)
03:44:41 <Iceland_jack> frege: Did you see my example above: threeElements
03:44:48 <johnw> frege: we use `elem` and `notElem`
03:44:53 <Tinned_Tuna> then see what happens when I clear it out and do a cabal configure ;-)
03:45:10 <frege> johnw: gotcha
03:45:12 <Iceland_jack> johnw: Apart from ‘l `elem` (2,3,5)’ is a double type-error :)
03:45:23 <johnw> oh, that too
03:45:23 <Iceland_jack> *being
03:45:46 <frege> Iceland_jack: I can't find your example
03:45:47 <Tinned_Tuna> Axman6: I'm sure this'll be fun ;-)
03:45:53 <Axman6> it will
03:46:01 <Iceland_jack>     threeElements :: [a] -> Bool
03:46:01 <Iceland_jack>     threeElements [a,b,c] = True
03:46:01 <Iceland_jack>     threeElements _       = False
03:46:01 <Iceland_jack>  
03:46:14 <frege> ahhhh
03:46:17 <Iceland_jack> frege: (recall that [a,b,c] is sugar for (a:b:c:[]))
03:46:40 <frege> right so that says three elements
03:46:43 <Iceland_jack> yes
03:46:54 <frege> what's the first one? threeElements :: [a] -> Bool
03:47:00 <Iceland_jack> that's the type signature
03:47:07 <frege> and this one ignores anything else threeElements _       = False
03:47:24 <Iceland_jack> It says “threeElements takes a list (of anything) and returns a Boolean”
03:47:26 <frege> Iceland_jack: the compiler doesn't care right? it's just for readibility
03:47:33 <Iceland_jack> frege: doesn't care about what?
03:47:33 <Axman6> _ is the pattern that matches anything and assigns no names
03:47:37 <Iceland_jack> the sugar?
03:47:52 <frege> Iceland_jack: no the type signature
03:47:59 <Axman6> it can be used within other patterns too: fst (a,_) = a -- ignore the second element of the tuple
03:48:11 <Iceland_jack> frege: In this case it doesn't matter since the inferred type would be the same
03:48:29 <Iceland_jack> Haskell has implicit typing where you rarely need to provide types
03:48:35 <frege> is there a case that you _have to_ type it?
03:48:38 <Iceland_jack> Yes
03:48:45 <Iceland_jack> > read "5" :: Int
03:48:46 <lambdabot>  5
03:48:50 <Iceland_jack> > read "5" :: Integer
03:48:51 <lambdabot>  5
03:49:02 <tdammers> > read "5" :: Double
03:49:03 <lambdabot>  5.0
03:49:05 <Rembane> read "5" :: Char
03:49:07 <Rembane> > read "5" :: Char
03:49:08 <lambdabot>  *Exception: Prelude.read: no parse
03:49:13 <Iceland_jack> Also polymorphic constants
03:49:13 <Iceland_jack> > minBound :: Char
03:49:14 <lambdabot>  '\NUL'
03:49:15 <Iceland_jack> Also polymorphic constants
03:49:15 <Iceland_jack> > minBound :: Word8
03:49:16 <lambdabot>  0
03:49:17 <frege> > read "5" :: []
03:49:18 <lambdabot>  Expecting one more argument to `[]'
03:49:21 <Axman6> frege: it's often the first thing haskell programmers will write
03:49:23 <Iceland_jack> frege: [] is not a type
03:49:31 <Rembane> > read "5" :: [Char]
03:49:32 <lambdabot>  "*Exception: Prelude.read: no parse
03:49:35 <Rembane> :D
03:49:40 <merijn> frege: You have to type it when the compiler can't infer it, for example due to an ambiguous use (i.e. the compiler can't decide which of two possible options you meant)
03:49:44 <Iceland_jack> > read "\"5\"" :: String
03:49:45 <lambdabot>  "5"
03:49:48 <frege> Iceland_jack: what's the type of a list?
03:49:52 <Iceland_jack> frege: [a]
03:49:56 <merijn> frege: Depends on what's in it
03:50:02 <Iceland_jack> containing any type a
03:50:08 <Iceland_jack> The type of strings is
03:50:08 <Iceland_jack>     [Char]
03:50:10 <Iceland_jack> or
03:50:11 <Iceland_jack>     String
03:50:12 <merijn> frege: [a] is a list of a's, [Int] is a list of Int
03:50:19 <Iceland_jack> A type of Booleans is
03:50:20 <Iceland_jack>     [Bool]
03:50:24 <Iceland_jack> etc.
03:50:30 <frege> > read "5" :: [a]
03:50:31 <lambdabot>  No instance for (GHC.Read.Read a1)
03:50:31 <lambdabot>    arising from a use of `Text.Read.read'
03:50:31 <lambdabot>  Possible fix:
03:50:31 <lambdabot>    add (GHC.Read.Read a1) to the context of
03:50:31 <lambdabot>      an expression type signature: [a1]
03:50:45 <merijn> frege: In addition to the compiler (very infrequently) needing type annotations, they help others understand what you're code is supposed to do
03:50:49 <Iceland_jack> frege: There are two things wrong with that
03:51:01 <frege> right
03:51:11 <frege> > read "56" :: [a]
03:51:12 <Iceland_jack> First of all if you want to read a string you must do
03:51:12 <Iceland_jack>     … ∷ String
03:51:12 <lambdabot>  No instance for (GHC.Read.Read a1)
03:51:12 <lambdabot>    arising from a use of `Text.Read.read'
03:51:13 <lambdabot>  Possible fix:
03:51:13 <lambdabot>    add (GHC.Read.Read a1) to the context of
03:51:13 <lambdabot>      an expression type signature: [a1]
03:51:15 <merijn> frege: (i.e. I usually can't be arsed to help people that paste code without types, since I'm too lazy to figure out what they should be)
03:51:23 <Iceland_jack> Second of all
03:51:23 <Iceland_jack> > show "56"
03:51:24 <lambdabot>  "\"56\""
03:51:29 <merijn> frege: The compiler uses the type to decide which implementation of read to use
03:51:29 <Iceland_jack> you need the quotes
03:51:30 <Tinned_Tuna> Axman6: nuking my ghc packages & cabal packages, the re-doing cabal configure, etc. fixed it :-)
03:51:33 <frege> merijn: gotcha
03:51:37 <Iceland_jack> > read "\"56\"" :: String
03:51:38 <lambdabot>  "56"
03:51:48 <Iceland_jack> > read "\"56\"" :: [Char]
03:51:49 <lambdabot>  "56"
03:51:49 <merijn> frege: If you say [a] then it doesn't know what 'a' is, so it can't decide which read instance to use
03:52:02 <merijn> frege: Addintionally, 'a' could be a type that doesn't have a read instance
03:52:19 <frege> oic
03:52:20 <Iceland_jack> frege: You can safely ignore this for now though while you're focusing on lists and pattern matching
03:52:51 <Iceland_jack> Just keep in mind that types are very important in Haskell and you almost always write explicit type signatures for top-level definitions
03:52:53 <frege> Iceland_jack: how do you match a pattern for a list that has 1000 elements?
03:52:57 <Iceland_jack> even if you don't have to
03:53:03 <Iceland_jack> frege: Then you wouldn't
03:53:10 <frege> why not?
03:53:16 <Iceland_jack> I just suggested it as an exercise
03:53:18 <Iceland_jack> You *can*
03:53:19 <frege> what's the limit for pattern matching of a list?
03:53:35 <Iceland_jack> If you're hitting it you're doing something wrong
03:53:47 <frege> can I use a lambda function for pattern matching?
03:53:59 <Iceland_jack> You can use a function with ViewPatterns
03:54:09 <Iceland_jack> but that may not be what you're asking
03:54:49 <frege> in your example threeElements [a,b,c] = True
03:55:04 <merijn> frege: There's no real limit, you're likely to give up writing matches before you hit any limit :p
03:55:24 <merijn> frege: i.e. I would never write down a 1000 element pattern, that's way too much work
03:55:24 <frege> is there a way to give a number for the length of that list instead of typing a name for each element
03:55:31 <Iceland_jack> frege: I could've written
03:55:31 <Iceland_jack>     threeElements :: [a] -> Bool
03:55:31 <Iceland_jack>     threeElements xs = length xs == 3
03:55:37 <merijn> frege: Yeah, using length
03:55:42 <frege> right
03:56:02 <frege> or
03:56:03 <spz> hi: let's say I have got a list of accounts and I take this list together with a transaction to perform increase and decrease on two of those accounts.. how do I avoid replacing the whole list here? IORefs?
03:56:09 <Iceland_jack> or
03:56:09 <Iceland_jack>     twoFourOrFive :: [a] -> Bool
03:56:09 <Iceland_jack>     twoFourOrFive xs = length xs `elem` [2, 4, 5]
03:56:14 <frege> threeElements xs = length xs `elem` [2,4,5]
03:56:30 <frege> hah
03:56:38 <Iceland_jack> frege: well that would return False for lists of length 3
03:56:59 <Iceland_jack> > length "abc" `elem` [2, 4, 5]
03:57:00 <lambdabot>  False
03:57:04 <Iceland_jack> > length "abcd" `elem` [2, 4, 5]
03:57:05 <lambdabot>  True
03:57:09 <frege> right
03:57:19 <frege> but this isn't pattern matching anymore
03:57:23 <Iceland_jack> That's right
03:57:26 <frege> it happens inside the function
03:58:11 <spz> How can I alter one value of a list without replacing the element?
03:58:31 <Axman6> spz: TVars, gives you atomicity
03:58:45 <frege> what's TVars?
03:59:01 <Axman6> frege: you're a long away from that :P
03:59:05 <spz> Axman6: so, I have to change the elements into TVars?
03:59:07 <frege> hahahaha
03:59:20 <Iceland_jack> We keep it real in #haskell
03:59:49 <Axman6> spz: you don'a have to, it's one way you could do it though
03:59:52 <merijn> spz: If you use a normal haskell list you can't really avoid redoing the entire list
04:00:02 <merijn> spz: Even if you store it inside an IORef/TVar
04:00:16 <merijn> spz: If you use something along the lines of a mutable Array you could
04:00:33 <merijn> spz: Alternately, you could use a Set, which will be far more efficient to update elements in then a list
04:01:01 <frege> I still don't get this (x:xs)
04:01:09 <frege> why is it written as x:xs?
04:01:14 <Axman6> @src []
04:01:14 <lambdabot> data [] a = [] | a : [a]
04:01:16 <frege> why not just x?
04:01:25 <Iceland_jack> frege: The infix operator is confusing you
04:01:26 <frege> ahh
04:01:32 <dv-> > 1:2:[]
04:01:33 <lambdabot>  [1,2]
04:01:33 <Iceland_jack> (:) is a constructor
04:01:42 <Iceland_jack> It could've been called Cons instead
04:01:51 <Axman6> a list is either empty ([]) or a value x of type a cons'd onto the from of a list of a's [a]
04:02:01 <frege> so x is the head and xs is the tail?
04:02:06 <Iceland_jack> frege: Yes
04:02:07 <spz> merjin: in the end, I want some concurrency, so TVar is what I aim at. What do you mean by mutable Array?
04:02:23 <Iceland_jack> frege: Here's a definition of the length function defined using Cons instead of (:)
04:02:23 <Iceland_jack>     length :: [a] -> Int
04:02:23 <Iceland_jack>     length []          = 0
04:02:23 <Iceland_jack>     length (Cons x xs) = 1 + length xs
04:02:33 <spz> merijin ↑
04:02:41 <Iceland_jack> same definition with (:)
04:02:42 <Iceland_jack>     length :: [a] -> Int
04:02:42 <Iceland_jack>     length []     = 0
04:02:42 <Iceland_jack>     length (x:xs) = 1 + length xs
04:02:47 <spz> merijn ↑ sorry
04:03:13 <frege> Iceland_jack: is Cons == :?
04:03:20 <Axman6> yes
04:03:22 <Iceland_jack> frege: yes in my case
04:03:35 <frege> does length ((:) x xs) = 1 + length xs work too?
04:03:44 <Axman6> try it
04:03:45 <frege> > length ((:) x xs) = 1 + length xs
04:03:46 <lambdabot>  <hint>:1:19: parse error on input `='
04:03:52 <Axman6> guess not
04:03:56 <Axman6> oh
04:03:58 <Iceland_jack> frege: ...
04:04:05 <frege> > let length ((:) x xs) = 1 + length xs
04:04:06 <lambdabot>  not an expression: `let length ((:) x xs) = 1 + length xs'
04:04:09 <Iceland_jack> you're writing a definition :) not an expression
04:04:12 <merijn> spz: There are array implementations based on ST which let you do mutable updates
04:04:12 <Axman6> > let len ((:) x xs) = 1 + length xs in len [1,2,3]
04:04:13 <lambdabot>  3
04:04:23 <frege> ah
04:04:25 <Iceland_jack> > let ((:) x xs) = "testing" in (x, xs)
04:04:26 <lambdabot>  ('t',"esting")
04:04:55 <merijn> spz: Having one of those in a TVar would probably be the best approach, you could do in place update on the array and switch the old for the new one in an atomic operation (thanks to the TVar)
04:05:01 <Iceland_jack> frege: You can also think of numeric literals as being constructors
04:05:03 <Iceland_jack> > 5
04:05:04 <lambdabot>  5
04:05:17 <frege> Iceland_jack: how so?
04:05:34 <frege> Iceland_jack: what type of constructors?
04:05:37 <Iceland_jack> And you can think of Integer as being defined as
04:05:37 <Iceland_jack>     data Integer = … | -5 | -4 | -3 | … | 0 | 1 | 2 | …
04:05:48 <Iceland_jack> (it isn't, but you can think of them as being defined as wsuch)
04:05:49 <Iceland_jack> *such
04:05:57 <Hafydd> Numeric literals are unlike constructors in that they can have multiple possible types.
04:06:01 <Iceland_jack> And Booleans as being defined as
04:06:01 <Iceland_jack>     data Bool = True | False
04:06:11 <Iceland_jack> Hafydd: Yes that's a further complication, but for sake of simplicity
04:06:20 <merijn> Note: In reality the definition of Int/Integer is filled with dark voodoo and black magic :p
04:06:29 <Iceland_jack> frege: Do you understand my definition of Bool?
04:06:36 <frege> Iceland_jack: yes I do
04:06:41 <spz> merijn, can you think of a solution where the complete replacement of the array is not necessary? A Transaction only touches two Accounts..
04:06:49 <Iceland_jack> frege: You can then pattern match on True and False
04:07:04 <Iceland_jack> frege: Example
04:07:05 <Iceland_jack>     not :: Bool -> Bool
04:07:05 <Iceland_jack>     not True  = False
04:07:05 <Iceland_jack>     not False = True
04:07:06 <merijn> spz: You'd want to have a complete TVar based implementation for that
04:07:19 <merijn> spz: I'm not sure whether someone already implemented like that
04:07:41 <frege> oh shit that's a nice way of defining 'not'
04:07:46 <Iceland_jack> Isn't it? :)
04:07:51 <Iceland_jack> @src Bool
04:07:51 <lambdabot> data Bool = False | True deriving (Eq, Ord)
04:07:54 <Hafydd> How else would you define it?
04:07:56 <Iceland_jack> That is the actual definition of Bool
04:07:58 <spz> merijn: does [TVar] make any sense?
04:08:15 <Iceland_jack> @src not
04:08:15 <lambdabot> not True   =  False
04:08:15 <lambdabot> not False  =  True
04:08:43 <Hafydd> I suppose not x = if x then False else True would work, too.
04:09:02 <Iceland_jack> Hafydd: Almost no language defines ‘not’ like that
04:09:04 <Axman6> but only because Bool is a little bit special
04:09:10 <Hafydd> Iceland_jack: like what?
04:09:10 <Iceland_jack> using pattern matching
04:09:23 <frege> well in python I know that you can't define it like that
04:09:25 <Iceland_jack> usually it's just built in
04:09:28 <frege> there is more repeatation of syntax
04:09:36 <Hafydd> What is your point?
04:10:08 <Iceland_jack> Hafydd: My point is that it's a nice way of having a user-defined ‘not’ which other languages don't do, that's all.
04:10:41 <quchen> I don't get the difference between the 'if' and 'pattern' definitions.
04:10:59 <quchen> They probably even become the same thing in Core.
04:11:07 <Iceland_jack> quchen: So what?
04:11:08 <frege> quchen: one difference that I found is 'as'
04:11:21 <Axman6> as?
04:11:22 <quchen> Iceland_jack: So I also don't get your point.
04:11:23 <Iceland_jack> ‘it becomes machine code in the end so...’
04:11:53 <frege> so yeah let f s@[a] = ..
04:12:21 <frege> Axman6: using @ to bind a name to the input
04:12:24 <Iceland_jack> quchen: Why do you think I have a point? I'm responding to something Hafydd said where they asked ‘How else would you define it [not]?’
04:12:25 * hackagebot mysql-effect 0.1.0.0 - An extensible mysql effect using extensible-effects and mysql-simple  http://hackage.haskell.org/package/mysql-effect-0.1.0.0 (ibotty)
04:12:28 <Axman6> oh, right
04:13:35 <quchen> I thought "<Iceland_jack> Hafydd: Almost no language defines ‘not’ like that" was trying to say something.
04:13:42 <quchen> Nevermind.
04:13:43 <adnap> What if instead of...
04:13:45 <adnap> :t when
04:13:46 <lambdabot> Monad m => Bool -> m () -> m ()
04:14:04 <adnap> There was Monad m => Bool -> m a -> m (Maybe a)
04:14:43 <frege> what's => ?
04:14:50 <frege> '=>'
04:14:50 <Iceland_jack> frege: Type context
04:14:58 <Axman6> myte constraint
04:15:02 <Axman6> type*
04:15:06 <Iceland_jack> Don't worry about it for now
04:15:09 <frege> ok
04:15:44 <Iceland_jack> or if you *do* want to worry about it now
04:15:44 <Iceland_jack> http://learnyouahaskell.com/types-and-typeclasses
04:15:46 <adnap> Iceland_jack: Why, it's simple to explain
04:16:07 <Iceland_jack> adnap: That hasn't been my experience
04:16:18 <Axman6> mine either
04:16:26 <frege> I'm smart
04:16:29 <Iceland_jack> Most people confuse type classes with types
04:16:31 <frege> if that makes a difference
04:16:34 <adnap> Huh. I'd give it a shot, but I thin LYAH would be better
04:16:44 <adnap> Type classes remind me of interfaces in OOP
04:16:54 <adnap> such as Java
04:16:56 <Axman6> people yell at me when I say that
04:16:59 <Iceland_jack> And wonder why you can't do something like:
04:16:59 <Iceland_jack>     foo :: [Eq Int] -> [Eq Int]
04:19:49 <Iceland_jack> I'm heading out to lunch frege
04:19:49 <Iceland_jack>      
04:19:54 <frege> ok I'm gonna take a nap before going to work
04:20:00 <frege> thanks Iceland_jack :)
04:20:02 <Iceland_jack> Don't give up on your Haskelling
04:20:08 <Iceland_jack> You're welcome
04:20:09 <frege> Iceland_jack: I won't.
04:20:19 <Axman6> frege: I suggest you read more LYAH
04:20:30 <frege> Axman6: I don't like the tone of that book
04:20:41 <frege> I found a gentle ... more interesting
04:20:47 <frege> http://www.haskell.org/tutorial/patterns.html
04:20:53 <Iceland_jack> Be that as it may
04:20:53 <adnap> frege: A type class looks like class Animal a where\n\tage :: Integer. An instance for data Dog = Dog { dogAge :: Integer, breed :: String } looks like instance Animal Dog where\n\tage = dogAge. A type contraint such as Animal a => a -> Integer requires an instance Animal a
04:21:24 <Axman6> I'd still recommend LYAH, it does a very good job explaining the simple topics you're asking questions about
04:21:38 <frege> ok I will read that too :)
04:21:42 <Iceland_jack> adnap: wrong type signature
04:21:47 <Axman6> adnap: that won't work, tage doesn't mention a
04:21:52 <Iceland_jack> ...also why would an Animal type class have age :: a -> Integer
04:21:54 <Iceland_jack> anyway..
04:21:56 <frege> adnap: there is no brain juice left in my head right now but thanks
04:22:11 <adnap> Oops
04:22:20 <Axman6> Iceland_jack: humans are animals, and we have ages, so do cats and snakes
04:22:22 <frege> take care friends
04:22:32 <Iceland_jack> Axman6: :P
04:22:40 <Iceland_jack> It reminds me of the horrible examples for OOP
04:22:48 <Iceland_jack> anyway, gone.
04:22:51 <Axman6> agreed
04:23:04 <adnap> Sorry :/
04:23:15 <Iceland_jack> adnap: sorry, didn't mean to be harsh
04:23:36 <adnap> Maybe I should have just showed Functor
04:23:44 <Iceland_jack> or what about Eq?
04:23:53 <adnap> I don't know that one
04:24:00 <adnap> I use it, but I don't know it
04:24:04 <Axman6> Functor isn't bad
04:24:09 <Axman6> @src Eq
04:24:09 <lambdabot> class  Eq a  where
04:24:09 <lambdabot>     (==), (/=)   :: a -> a -> Bool
04:24:12 <Iceland_jack> Axman6: Functor is also probably unfamiliar
04:24:28 <Iceland_jack> adnap: No offense but maybe you should get more familiar with type classes first
04:24:28 <Axman6> Iceland_jack: that's ok
04:24:28 <adnap> Oh, okay. That's simple
04:24:30 <Iceland_jack> > ':':repeat ')'
04:24:31 <lambdabot>  ":))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))...
04:24:35 <Iceland_jack> mandatory smiley
04:24:42 <adnap> ?
04:25:02 <adnap> I don't really like type classes
04:25:15 <Iceland_jack> Type classes are vital for any advanced Haskelling
04:25:22 <adnap> Monad, Functor, Applicative, etc. are good, but I don't like to make my own
04:25:23 <Iceland_jack> I suppose Eq would be very easy to take as an example, omitting the (/=) definition for simplicity
04:25:30 <quchen> Haha wow: http://lpaste.net/98475
04:25:45 <quchen> Not only are they equal, but GHC recognizes it and makes everything synonyms :-D
04:26:21 <Axman6> quchen: that's... not something I expected
04:26:29 <quchen> It's with -O2 though
04:26:32 <zcourts> I did a release to hackage and no docs are showing up. How do I get cabal to include my docs when i build a package with sdist? cabal 1.6 fyi
04:26:33 <Iceland_jack> quchen: To be fair Bool only has two cases so there are only 4 different total functions from Bool → Bool ;)
04:27:09 <Mait0> frege: You can pattern matching to type constructor. List's constructors are '[]' or 'a : [a]'. 1) 'xs'(anything) match both 2) 'x:xs'(not empty. at least one or more) match 'a:[]' and 'a:[a]' 3) '[]' match only '[]' constructor.
04:27:19 <FireFly> adnap: why?
04:27:47 <merijn> zcourts: Documentation is build locally on the hackage server, there is a few reasons they could not be showing up
04:28:04 <adnap> FireFly: I shouldn't have said "I don't like". I just don't make my own often.
04:28:13 <FireFly> Oh
04:28:33 <merijn> zcourts: Most likely one of these: 1) it's a batch jump and hasn't run yet since you uploaded or 2) your code relies on a C library which is missing on the server or your code fails to build for another reason
04:28:42 <merijn> zcourts: Which package are you talking about?
04:28:47 <quchen> Iceland_jack: But it also takes something to recognize that in the presence of ⊥, which is relevant for the IR
04:28:49 <jmcarthur> it just occurred to me that when somebody says a function in haskell is "total" they are normally assuming that the input to the function is not _|_
04:28:57 <hpc> zcourts: if your package has been built, you can look at the build logs to try and find the problem yourself
04:29:04 <Axman6> merijn: data constructyors, not type constructors
04:29:07 <Axman6> uh, Mait0
04:29:26 <jmcarthur> either that or it doesn't count as partial just because it is strict
04:29:34 <hpc> jmcarthur: usually, yes
04:29:36 <quchen> jmcarthur: Total means that a function maps non-⊥ values to non-⊥ values. No assumptions about what happens on ⊥-valued inputs.
04:29:46 <jmcarthur> quchen: oh it actually *means* that?
04:29:47 <hpc> jmcarthur: otherwise you couldn't reason about total functions in strict languages at all
04:29:59 <jmcarthur> hpc: yes you could, because the inputs could never be _|_
04:30:03 <quchen> jmcarthur: As far as I know it literally means that, yes.
04:30:26 <merijn> jmcarthur: hpc said total functions in a strict language, obviously a strict language can have bottom
04:30:37 <Iceland_jack> quchen: Yes that's right, but still not the most amazing thing about the ghc optimizer :)
04:30:37 <merijn> jmcarthur: You mean total function in a *total* language can't have bottom
04:30:43 <quchen> jmcarthur: Also consider "const", you'd have a hard time finding someone saying const isn't total in here :-)
04:30:54 <quchen> Iceland_jack: Let me be amazed! :-(
04:31:14 <Iceland_jack> quchen: Sorry! I'm not normally the Grinch
04:31:37 <jmcarthur> merijn: in a strict language i can't bind _|_ to a variable or pass it as an argument. i never get that far
04:31:56 <adnap> Iceland_jack: Buzzfeed: 10 Amazing things about the GHC optimizer you never would have guessed!
04:31:58 <hpc> Iceland_jack: that's my favorite childrens book, "how the grinch learned everything there is to know about the ghc optimizer"
04:31:59 <jmcarthur> quchen: i don't know how that const bit contradicts anything i've said
04:32:24 <jmcarthur> oh, since [[const _|_]] = _|_
04:32:39 <Yaniel> > putStrLn (foldl (++) ":" (take 10 $ repeat "-") ++ "D")
04:32:40 <lambdabot>  <IO ()>
04:32:52 <Yaniel> meh
04:32:54 <hpc> or it = \_ -> _|_, depending on what you count as part of the language
04:32:55 <Yaniel> > foldl (++) ":" (take 10 $ repeat "-") ++ "D"
04:32:56 <lambdabot>  ":----------D"
04:33:07 <jmcarthur> sure
04:33:13 <quchen> jmcarthur: No, const ⊥ ≠ ⊥. At least in Haskell.
04:33:35 <jmcarthur> that's because seq is dumb
04:33:35 <quchen> > const undefined `seq` ()
04:33:36 <lambdabot>  ()
04:34:09 <hpc> i didn't think the standard specifies the behavior of seq on lambda expressions
04:34:19 <hpc> (or at all, but i haven't been keeping up)
04:34:26 <Axman6> what's whnf of a function?
04:34:37 <jmcarthur> haskell doesn't even specify whnf, i think
04:35:00 <jmcarthur> it could just as well be hnf, for example
04:36:19 <adnap> > ':' : foldr (:) ['D'] (replicate 10 '-')
04:36:21 <lambdabot>  ":----------D"
04:36:30 <srhb> > ':' : replicate 10 '-' ++ "D"
04:36:31 <lambdabot>  ":----------D"
04:36:42 <quchen> I'm going to pretend the "-" looks like a nose.
04:36:48 <srhb> yes....
04:37:02 <Axman6> quchen: well it definitely doesn't look like a dick
04:37:04 <Axman6> :P
04:37:17 <SaBer> very small balls...
04:38:24 <merijn> Oi!
04:38:36 <adnap> I like
04:38:36 <merijn> HEAD broke something important :(
04:38:41 <adnap> > ':' : foldr (:) ['D'] (repeat '-')
04:38:42 <lambdabot>  ":--------------------------------------------------------------------------...
04:40:27 <quchen> merijn: ?
04:40:50 <quchen> merijn: Did you not clone your copy yesterday after your code didn't compile, and now you can't catch up anymore because of a new commit? :-D
04:41:45 <merijn> quchen: My type families code hasn't worked in a while according to people trying it, but I just tried it myself in HEAD of yesterday and it compiles, but it compiles plain wrong
04:42:04 <randomclown> > "8" : replicate 10 '=' ++ 'D'
04:42:05 <lambdabot>  Couldn't match expected type `[GHC.Types.Char]'
04:42:06 <lambdabot>              with actual type `GHC.Types.Char'Couldn't match expected type `[...
04:42:06 <merijn> It's throwing away a constraint on my functions type signature
04:42:06 <lambdabot>              with actual type `GHC.Types.Char'
04:42:10 <randomclown> > "8" : replicate 10 '=' ++ "D"
04:42:11 <lambdabot>  Couldn't match expected type `[GHC.Types.Char]'
04:42:11 <lambdabot>              with actual type `GHC.Types.Char'Couldn't match type `GHC.Types....
04:42:11 <lambdabot>  Expected type: [[GHC.Types.Char]]
04:42:11 <lambdabot>    Actual type: [GHC.Types.Char]
04:42:22 <randomclown> > "8" : (replicate 10 '=') ++ "D"
04:42:23 <lambdabot>  Couldn't match expected type `[GHC.Types.Char]'
04:42:23 <lambdabot>              with actual type `GHC.Types.Char'Couldn't match type `GHC.Types....
04:42:23 <lambdabot>  Expected type: [[GHC.Types.Char]]
04:42:23 <lambdabot>    Actual type: [GHC.Types.Char]
04:42:34 <randomclown> :t replicate
04:42:35 <lambdabot> Int -> a -> [a]
04:42:46 <randomclown> > '8' : (replicate 10 '=') ++ "D"
04:42:47 <lambdabot>  "8==========D"
04:42:55 <randomclown> keep getting cockblocked
04:43:45 <Yaniel> what have I done o.o
04:44:07 <tdammers> '8' : (repeat '=') ++ "D" -- Mr. Jagger will know what I'm talking about
04:44:35 <jmcarthur> i'm pretty sure there was a time when this would have been considered unacceptable behavior
04:44:37 <quchen> Enough penis jokes, guys.
04:45:13 <Nik05> guys...
04:45:46 <randomclown> Why isn't there any female Haskell programmers
04:46:03 <randomclown> Why is Haskell sexist
04:46:16 <zomg> Aren't you the one for making an assumption like that?
04:46:17 <zomg> ;>
04:46:21 <mindleyhilner> > let { k :: a -> b; k u = 4 :: Int; }
04:46:22 <lambdabot>  not an expression: `let { k :: a -> b; k u = 4 :: Int; }'
04:46:30 <quchen> Feel free to write an Tumblr post about it. It's also OT here.
04:46:38 <quchen> s/n//
04:46:57 <randomclown> OT?
04:47:01 <merijn> off-topic
04:47:01 <jmcarthur> off-topic
04:47:03 <mindleyhilner> > let { k :: a -> b; k u = 4 :: Int; } in k 3
04:47:04 <lambdabot>  Couldn't match expected type `b1' with actual type `GHC.Types.Int'
04:47:04 <lambdabot>    `b1' is a rigid type variable bound by
04:47:04 <lambdabot>         the type signature for k :: a -> b1 at <interactive>:1:12
04:47:07 <xexonixxexillion> To be honest, I've seen more than 10 male haskell programmers for every female haskell programmer. Compare that to ruby or python..
04:47:29 <Axman6> hmm, now that's a familliar name...
04:47:32 <mindleyhilner> shouldn't the typechecker know to unify 'b' with Int?
04:47:44 <Aleksejs> randomclown, I know at least one female Haskell programmer
04:47:45 <xexonixxexillion> Axman6:  long time no see
04:47:51 <merijn> mindleyhilner: You're explicitly stating the return value can be any 'b'
04:47:54 <mauke> mindleyhilner: it tried but it can't
04:48:05 <Axman6> indeed. tutoring 1100 this year?
04:48:06 <randomclown> Aleksejs: your wife doesn't count
04:48:07 <merijn> mindleyhilner: Which means it can't unify with Int, as Int cannot be any 'b'
04:48:10 <zomg> xexonixxexillion: during my 10+ years in writing software I've worked with one female programmer, I think comparisons like that are a bit silly :P
04:48:17 <quchen> randomclown: Please stop trolling.
04:48:18 <Aleksejs> randomclown, not my wife
04:48:32 <jmcarthur> mindleyhilner: haskell assumes an implicit "forall <type variables here>." in front of your type signature
04:48:37 <merijn> randomclown: That's 1) rather sexist for someone complaining about it and 2) off topic
04:49:01 <randomclown> I'm going back to tumblr
04:49:20 <randomclown> (enough OT)
04:49:29 --- mode: ChanServ set +o mauke
04:49:29 --- kick: randomclown was kicked by mauke (agreed)
04:49:33 <jmcarthur> i think it doesn't help that some of us kind of encouraged randomclown to make penis jokes. that should not have happened
04:51:29 --- mode: mauke set -o mauke
04:52:24 <Mait0> What is good API for this case? 'slice :: [a] -> Int -> Int -> [a]' (return slice of [a] from first Int to second Int) When second Int is smaller than first. runtime error? or return orig [a]?
04:52:35 <quchen> mindleyhilner: The problem here is that GHC first infers that 'k' should be able to return *anything*, and in the definition you say it can only result in an `Int`.
04:52:56 <randomclown> Mait0: use Maybe if you want to wrap it up
04:53:01 <randomclown> or []
04:53:08 <randomclown> I think [] is superiour
04:53:52 <quchen> Mait0: Maybe. A slice of length 0 is a valid slice and should result in Just [], a slice of length -30 is arguably invalid and should be Nothing.
04:54:11 <randomclown> slice of -30 is fine being []
04:54:16 <quchen> You could of course swap the limits if the range is negative, reverse the slice, or something else.
04:55:23 <Mait0> Is that possible restrict range of Int at type signature?
04:55:45 <quchen> Mait0: Not easily at least.
04:56:43 <Mait0> randomclown: quchen: Thanks
04:57:02 <quchen> Making the function map to Maybe Int and making out-of-bounds values Nothing would be the easiest way. The next more complicated one would be using a custom type and smart constructors that make sure the values given are always in range.
04:59:06 <quchen> The first one is not type-level at all, the second is somewhat type-level, and a fully type-level solution would be a little over the top I would think.
05:09:54 <randomclown> is there a way to automatically kill the child thread (forkIO) when the parent dies?
05:12:28 <quicksilver> not per se, no
05:12:41 <merijn> Careful installation of exception handlers/brackets to kill the child
05:12:45 <quicksilver> but you should be able to wrap your parent thread in a 'finally' which does that if you want to
05:12:57 <randomclown> bracket = reinvention of RAII
05:13:20 <csed> So. I just built ghc-7.7 from source. Is there any best way to remove the old 7.4 that I have from the Debian repos? I'm worried that apt-get remove ghc will break everything that could be broken.
05:13:28 <randomclown> Stroustrup saved programming as we know it again
05:13:46 <quchen> Using Async you can create basic process hierarchies like that pretty easily:  withAsync outer $ \a1 -> withAsync inner $ \_a2 -> wait a1
05:14:05 <quicksilver> randomclown: try to troll less?
05:14:22 <csed> Not to mention that ghci-7.7 says that stage 2 was booted by 7.4 which just confuses the hell out of me.
05:14:23 <randomclown> Just making a funny observation
05:14:26 <merijn> s/troll less/not troll at all
05:14:43 <merijn> csed: Why? It used 7.4 to compile 7.7
05:14:51 <merijn> csed: How else would you compile 7.7?
05:15:13 <quchen> GHC mentions its bootstrap compiler? Surprising
05:15:16 <csed> Right, but. Does that mean I have to have 7.4 and 7.7?
05:15:22 <quchen> Especially in stage 2, which should be independent of the bootstrapper
05:15:26 <quicksilver> surely you'd compile stage 1 with 7.4
05:15:31 <quicksilver> stage 2 you'd compile with stage 1
05:15:41 <merijn> I guess that's true
05:16:24 <tdammers> randomclown: except that C++ isn't the only language to have this kind of thing
05:16:33 <randomclown> tdammers: it did popularise it
05:17:04 <csed> Basically. ghci tells me that it's running 7.7, while ghc tells me it's running 7.4. Not only that, ghc tells me stage 2 was compiled by 7.4.
05:17:07 <randomclown> and Stroustrup did invent c++ and RAII
05:17:09 <tdammers> popularise /= invent, is all I'm saying
05:17:39 <merijn> csed: Are you sure you're running the right ghc binary?
05:17:47 <randomclown> tdammers: "The technique was invented by Bjarne Stroustrup - wikipedia"
05:18:32 <csed> merijin: If I run ghc-7.4.1 it still tells me stage 2 was booted by 7.4.1.
05:18:33 <tdammers> I'm pretty sure this refers to actual RAII, including the details that are specific to C++
05:18:47 <merijn> csed: Why are you running "ghc-7.4.1"? :)
05:18:56 <randomclown> tdammers: source me
05:18:58 <tdammers> the general notion of attaching cleanup functions to a scope is probably older
05:19:10 <merijn> csed: Also, where does it say "stage 2 booted by 7.4.1"
05:19:46 <csed> In ghc-7.4.1.
05:19:49 <merijn> randomclown, tdammers: This discussion is 1) off-topic and 2) inflammatory, would you mind continuing outside #haskell
05:19:53 <csed> And in ghc-7.7.
05:19:58 <merijn> csed: What does "in ghc-7.4.1" mean?
05:20:04 <tdammers> merijn: aight
05:20:07 <merijn> csed: Which command are you typing
05:20:14 <csed> ghc-7.4.1
05:20:20 <t7> tdammers: i am interested
05:20:29 <t7> i would like to know the history
05:20:54 <merijn> csed: Sounds unlikely... I just get "ghc: no input files" when I do that
05:21:03 <csed> ghc-7.4.1 -v
05:21:05 <csed> My bad.
05:21:48 <csed> Like, it's also weird that ghc is a link to ghc-7.7, but when you run ghc -v it tells you its ghc-7.4.1.
05:21:58 <csed> Which makes -no- sense.
05:22:06 <merijn> csed: Sounds like your path is bollocksed
05:22:12 <merijn> csed: Run "which ghc"
05:22:27 <merijn> quicksilver: FWIW, my 7.7 claims to be stage 2 booted by 7.6.3
05:22:37 <csed>  /usr/local/bin/ghc
05:22:39 <quicksilver> merijn: I think it's just surprising wording.
05:22:50 <merijn> csed: And where did you install ghc 7.7?
05:22:55 <quicksilver> merijn: "this is a stage 2 compiler; it arose out of a series of stages initially booted by 7.6.3"
05:23:06 <merijn> csed: Or where is that ghc symlink you refered too?
05:23:18 <csed>  /usr/local/bin/ghc-7.7
05:23:42 <merijn> csed: And is /usr/local/bin/ghc a symlink to ghc-7.7?
05:23:48 <csed> Yep.
05:23:48 <merijn> csed: If not, I see your problem :p
05:23:55 <merijn> That's weird
05:24:11 <csed> It is. I mean, it says it's linked to 7.7 but it runs 7.4.
05:24:26 <merijn> csed: Can you copy the first two lines of "ghc -v" and "ghc-7.7 -v" to lpaste?
05:24:42 <csed> Sure.
05:27:56 <randomclown> why is =<< right associative?
05:28:19 <merijn> Why not?
05:28:35 <merijn> (Well, mostly because that's the most useful way to associate it...)
05:28:42 <Hafydd> I imagine because >>= is left-associative.
05:28:52 <randomclown> Hmm
05:29:01 <randomclown> I want a fliped >>= that's also left
05:29:41 <randomclown> because I have a forkIO $ do { balh balah massive long chunk }
05:29:49 <csed> merijn: Ok. Now I'm just even more confused. Re-opened my terminal emulator and now ghc -v says the sensible thing. 7.7 booted by 7.4.1. How did that even happen?
05:29:59 <merijn> csed: Broken path
05:30:03 <randomclown> recordTID =<< forkIO $ do { blah blah } ...
05:30:08 <merijn> csed: shell caching executables, etc.
05:30:08 <randomclown> would be really nice left assoc
05:30:22 <merijn> randomclown: That wouldn't work anyway
05:30:29 <csed> Huh, alright. Well, it works now. Thanks for the help, merijn.
05:30:29 <merijn> randomclown: $ has lower fixity than =<<
05:30:44 <quicksilver> left vs right only matters when you have two or more =<<
05:30:54 <quchen> (recordTID =<<) . forkIO $ do …
05:30:59 <quicksilver> with just the one, it's only the precendence between =<< and $ that matters
05:34:26 <randomclown> can killThread fail with exception for any reason?
05:35:44 <randomclown> there needs an exception safety doc in haddoc
05:38:28 <quicksilver> I agree, exceptions are not well documented.
05:38:42 <quicksilver> I don't think killThread can throw any normal exceptions
05:53:49 <merijn> Type wizards! Is anyone aware of a "void" Constraint somewhere in a library (i.e. a never holding Constraint)?
06:13:36 <bmuk> hey everyone, how difficult is haskell development with os x? I've only ever really used linux
06:14:31 <meretrix> Say I have "data X = A | B | C | D | E" and many configuration settings for each value of X, such a "TVar (Map X Timeout)" and "TVar (Map X Size)".  Because the set of keys for the mappings are known at compile time (just the values of X), is there a better data structure to use to avoid the use of Maybes from lookups?
06:15:35 <meretrix> I would just use pattern matching on X, but then I can't update the settings at runtime.
06:15:52 <Iceland_jack> <adnap> Iceland_jack: Buzzfeed: 10 Amazing things about the GHC optimizer you never would have guessed!
06:15:52 <Iceland_jack> <hpc> Iceland_jack: that's my favorite childrens book, "how the grinch learned everything there is to know about the ghc optimizer"
06:15:52 <Iceland_jack> That's it, I'm going to write children's novels about GHC for a living
06:15:52 <Iceland_jack>  
06:15:57 <jonasw> bmuk: Not difficult, in my experience
06:16:33 <bmuk> jonasw: I had heard there were problems because of there being no gcc
06:16:36 <listofoptions> kind mismatch errors :/
06:16:37 <listofoptions> http://lpaste.net/98478
06:16:58 <jonasw> bmuk: There is a GCC in homebrew
06:17:30 <bmuk> ah okay. Thank you jonasw. You have eased my mind
06:17:41 <jonasw> bmuk: By now formulas have been updated to depend on that, if they truly need gcc, or to just use clang
06:22:18 <listofoptions> has anyone really used the bound package much (by EdwardKmett) I cannot seem to get it to cooperate with ast types that have two parameters
06:22:45 <edwardk> listofoptions: that can be a bit of a pain in the neck, yes
06:23:01 <listofoptions> ahh
06:23:06 <edwardk> we do so in the ermine codebase, but by setting up a fair bit of scaffolding ourselves
06:23:27 <edwardk> https://github.com/ermine-language/ermine
06:24:14 <edwardk> e.g. http://ermine-language.github.io/ermine/Ermine-Syntax-Term.html
06:25:33 <edwardk> we usually get by with the combinators in http://ermine-language.github.io/ermine/Ermine-Syntax-Scope.html
06:26:28 <ski> meretrix : i suppose you could perhaps try deriving `Ix', and use arrays
06:27:25 <ski> (and possibly `Bounded' as well)
06:27:26 <ski> > listArray (LT,GT) [-1,0,1] ! LT
06:27:27 <lambdabot>  -1
06:27:37 <ski> > listArray (minBound,maxBound) [-1,0,1] ! LT
06:27:39 <lambdabot>  -1
06:27:49 <ski> > listArray (LT,EQ) [-1,0] ! GT
06:27:50 <lambdabot>  *Exception: Ix{Ordering}.index: Index (GT) out of range ((LT,EQ))
06:28:54 <ski> > M.fromList [(LT,-1),(EQ,0)] M.! GT
06:28:55 <lambdabot>  *Exception: Map.!: given key is not an element in the map
06:34:05 <listofoptions> thanks edwardk
06:35:28 <merijn> bmuk: The first question is, which OSX version are you using
06:35:59 <merijn> bmuk: I've always just used the binary platform install, but I'm not on the latest OSX release yet (I'm waiting for the next platform release to be fixed for 10.9 before switching)
06:37:24 <ehelin> hi all, I just learned about WHNF and the seq function from the book "Parallel and Concurrent Programming in Haskell" by Simon Marlow. However, I don't understand *why* seq evaluates to WHNF and not normal form?
06:40:55 <listofoptions> ehelin: whnf iirc is needed for lazy evaluation
06:41:06 <t7> any vim users know a good way to show spaces and tabs?
06:41:42 <listofoptions> if you outright force normal form on an infinite expression....well you get what you deserve
06:41:48 <merijn> t7: https://github.com/merijn/dotfiles/blob/master/vimrc#L12-L14
06:42:07 <ehelin> listofoptions: ah ok, I understand
06:42:12 <ehelin> thanks!
06:42:27 <merijn> Whoo!
06:42:48 <merijn> My closed type families example has been fixed, after figuring out a hideously obscure kind problem >.>
06:43:11 <t7> merijn: perfect thanks
06:43:14 <ehelin> so then I guess my follow up questions is: why evaluate to WHNF? Why no just reduce the expression one step? (Or do you always get WHNF if you reduce one step?)
06:43:35 <geekosaur> whnf is one step, yes
06:43:40 <geekosaur> one recognizeable step
06:43:52 <ehelin> geekosaur: ok, thanks!
06:44:20 <quicksilver> that's not what step normally means
06:44:26 <quicksilver> WHNF can be many many steps.
06:44:28 <merijn> ehelin: Have you looked at this in-depth explanation: https://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form
06:44:59 <quicksilver> evaluation in haskell is driven by case - driven by inspecting constructors
06:45:03 <geekosaur> well, yes. but those steps can't be observed, which is what I was getting at by "recognizeable" --- the evaluator can really only recognize a step when it has a constructor to look at
06:45:28 <quicksilver> it makes perfect sense for seq to reduce to WHNF because that's the amount required to produce the outermost constructor
06:45:37 <quicksilver> so seq is like a 'universal case' which doesn't require you to list the constructors.
06:46:18 <ehelin> merijn: yes, a very good answer, but it still states that the semantics of seq were choosen such that in seq x y, if y is evaluated to whnf, then x is evaluated to whnf. I wanted to understand why the semantics are this way (just out of curiosity) :)
06:47:05 <quicksilver> ehelin: because WHNF is what you need to identify the outermost constructor, and identifying constructors is how evaluation proceeds.
06:48:23 <ehelin> quicksilver: ah ok, so if Haskell's evaluate has an expression in WHNF, and wants to execute it "one step", then it must "run" the expression to the next WHNF?
06:48:55 <ehelin> sorry for (most likely) not using the correct terms for "one step", "execute" and "run"
06:52:02 <listofoptions> edwardk: I figured out what was going on, I had apparently accidentally swapped two constructors :P
06:52:13 <geekosaur> so, pattern matches are what force evaluation to occur. pattern matches match constructors, so you can only proceed by getting the "next" constructor. (think: if you move one atomic diameter, what notices? if you move to the next identifiable feature, that is noticeable)
06:52:17 <edwardk> ah!
06:52:18 <quicksilver> ehelin: no, there is only one WHNF, there is no "next WHNF"
06:52:35 <listofoptions> your library works wonderfully :D
06:52:48 <quicksilver> ehelin: once you are in WHNF you can then actually 'do' the case statement.
06:53:09 <quicksilver> (or 'do' the hardwired primitive operation, if you're wondering how you ever get to the bottom of the case statements)
06:53:13 <quicksilver> and then move on.
06:53:35 <t7> merijn: now i need a darker colour :( its bright green
06:54:39 <ehelin> geekosaur and quicksilver: thanks, now I understand why it must proceed to the next constructor!
06:54:58 <merijn> t7: I'm just using a custom colour scheme in the same repo, but you might just want to make your own
06:55:41 <ski> hm, i wonder whether whnf makes sense for e.g. interval stuff
06:56:44 <kammerer> how do I get a value "out" of a JSON object (pkg aeson)? v .: "key" is merely an (..)Internal.Parser a
06:56:54 <kammerer> (with v :: Object)
06:57:14 <kammerer> I'd like to process data in my fromJSON instance
06:57:29 <ehelin> so, can one think of the evaluation as an interpreter in a big "case ... of" expression where each clause of the "case ... of" expression does "one step" of the evaluation?
06:57:55 <ski> ehelin : anyway, in `take 3 [0 ..]', you don't want to compute all of `[0 ..]'
06:58:13 <ehelin> ski: thanks! yeah, I understand that know :)
06:58:24 <alpounet> ehelin: http://alpmestan.com/2013/10/02/oh-my-laziness/
06:58:30 <zipper> I can't understand folds is it cool to skip them?
06:58:55 <ski> if you're entering expressions in the interactor, then you can think of it as `show' forcing the evaluation of the expression (and the system forcing the string result of `show')
06:59:28 <merijn> zipper: They're a bit tricky until you get the hang of it, you can skip them for a bit. But you should probably tackle them fairly soon
06:59:35 <ski> > foldr f z [a,b,c,d]
06:59:37 <lambdabot>  f a (f b (f c (f d z)))
06:59:42 <ski> > foldr (+) z [a,b,c,d]
06:59:43 <lambdabot>  a + (b + (c + (d + z)))
07:00:04 <ski> > foldr (+) 0 [2,3,5,7]                     :: Expr
07:00:05 <lambdabot>  2 + (3 + (5 + (7 + 0)))
07:00:07 <merijn> zipper: The most foolproof way to understand them is: 1) Write down fold application, 2) manually substitute the fold function body for the call, 3) repeat until done
07:00:09 <ski> > foldr (+) 0 [2,3,5,7]
07:00:10 <lambdabot>  17
07:00:31 <merijn> zipper: Just grab a piece of paper and start mindlessly substituting by hand
07:00:55 <merijn> zipper: Most people go "Oh!" by the 2nd or 3rd application
07:01:10 <ehelin> alpounet: thanks for the link, reading right now!
07:01:19 <ski> zipper : Cale's pics at <http://en.wikipedia.org/wiki/Fold_%28higher-order_function%29#Folds_as_structural_transformations> might also be interesting
07:01:52 <zipper> I have tried it. For example in:
07:01:55 <zipper> foldl (\acc x -> if x == 3 then True else acc) acc [1,2,3,4,6]
07:02:05 <zipper> where acc = False
07:02:26 <zipper> Does it stop when it get's the first True?
07:02:41 <ski> yes
07:02:51 <ski> well
07:02:55 <ski> actually, no
07:03:03 <ski> if it used `foldr', it would stop
07:03:21 <ski> one easy way to test is to pass an infinite list
07:03:23 <mauke> foldl can't stop; it's tail recursive
07:03:34 <ski> > foldl (\acc x -> if x == 3 then True else acc) acc [0 ..]
07:03:35 <lambdabot>  Not in scope: `acc'
07:03:35 <lambdabot>  Perhaps you meant one of these:
07:03:35 <lambdabot>    `act' (imported from Control.Lens),
07:03:35 <lambdabot>    `bcc' (imported from Data.Graph), `scc' (imported from Data.Graph)
07:04:01 <zipper> > let acc = False
07:04:02 <lambdabot>  not an expression: `let acc = False'
07:04:02 <ski> > foldl (\acc x -> if x == 3 then True else acc) (error "some uninteresting base case") [0 ..]
07:04:07 <lambdabot>  mueval-core: Time limit exceeded
07:04:17 <ski> > foldr (\x acc -> if x == 3 then True else acc) (error "some uninteresting base case") [0 ..]
07:04:18 <lambdabot>  True
07:05:08 <zipper> Ok also is it inside foldl's code to loop throughout the list?
07:05:21 <ski> @src foldl
07:05:21 <lambdabot> foldl f z []     = z
07:05:21 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:05:43 <ski> `foldl' continues calling itself tail-recursively, until it reaches the end of the input list
07:07:45 <zipper> and when we set the lamda to return a Bool why isn't it overwritten by the time the list ends?
07:08:19 <piezoid> hi
07:08:26 <zipper> It's only True at the 2nd element
07:08:27 <merijn> zipper: That'll become obvious once you do it by hand
07:08:51 <piezoid> ghc 7.6 give me a SyntaxError on this file http://git.megacz.com/?p=ghc-base.git;a=blob_plain;f=Control/GArrow.hs;h=7c38a09b3310746a0a50ff02a55eca220103824c;hb=e3eef06878b2b39a95ed3ad8378e8130ebef5570
07:09:22 <zipper> merijn: I am see this.
07:09:25 <ski> piezoid : try indenting `) where' ?
07:09:26 <piezoid> look like functional dependencies syntax has changed since
07:09:48 <ski> hm, no. that can't be it
07:10:13 <ski> (just not used to seeing that)
07:10:30 <zipper> 1 == 3 is False then 2 == 3 is False  then 3 == 3 is True but it is called again and ... 6 == 3 lamda returns False
07:10:56 <mauke> piezoid: (**) used to be a variable
07:11:05 <mauke> now it's uppercase
07:11:11 <piezoid> ski: i tried ')\n  where\n    '
07:11:16 <zipper> merijn: 1 == 3 is False then 2 == 3 is False  then 3 == 3 is True but it is called again and ... 6 == 3 lamda returns False
07:11:55 <zipper> @src foldr
07:11:55 <lambdabot> foldr f z []     = z
07:11:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:11:56 <merijn> zipper: Are you literally substituting the "foldl" call with it's function body on paper/in an editor?
07:11:57 <piezoid> mauke: i was looking this file to understand how (**) can be a type variable
07:12:07 <mauke> what do you mean, "how"?
07:12:14 <mauke> piezoid: how can abc be a type variable?
07:12:26 <piezoid> mauke: TypeOperator is not sufficient
07:12:33 <mauke> wat
07:13:22 <piezoid> mauke: well, i want to define 'class GArrow g (**) u' for example, where (**) is a type variable like g or u
07:13:36 <zipper> merijn: The useful testing equality part, yes.
07:13:44 <mauke> piezoid: you can't
07:14:00 <ski> zipper : care to join #haskell-overflow ?
07:14:20 <mauke> https://ghc.haskell.org/trac/haskell-prime/wiki/InfixTypeConstructors
07:14:21 <zipper> ski: What is that? Something Jeff Atwood made?
07:14:35 <zipper> #haskell-overflow
07:14:43 <ski> it's another IRC channel
07:14:51 <piezoid> mauke: oh ok, so megacz modified ghc in order to this ?
07:15:02 <mauke> piezoid: they probably used an older version
07:15:54 <mauke> this behavior is new in 7.6
07:17:54 <piezoid> mauke: ok, thanks. My class's signatures will look crapy without it...
07:19:47 <zipper> merijn: https://gist.github.com/urbanslug/8419855
07:20:45 <merijn> zipper: That doesn't show you anything
07:21:02 <merijn> zipper: Unless you copy the entire function body it won't make sense
07:21:14 <piezoid> i mean, 'assoc :: (a ** (b ** c)) ~> ((a ** b) ** c)' looks better than 'assoc :: g (t a (t b c)) (t (t a b) c)'
07:21:28 <ski> @type let graph :: Arrow (~>) => (a ~> b) -> (a ~> (a,b)); graph f = arr id &&& f in graph
07:21:28 <lambdabot>     Not in scope: type constructor or class `~>'
07:21:29 <lambdabot>     Perhaps you meant `:>' (imported from Control.Lens)
07:21:29 <lambdabot>     Not in scope: type constructor or class `~>'
07:22:25 <zipper> ski: I am over at haskell-overflow
07:34:13 <mangoMan> EVERYONE SEND A MESSAGE TO THAT FAG METALEER HE IDLES IN ##PHYSICS AND #DEFOCUS HE IS A CANCER ON THIS FUCKING NETWORK fghfg
07:34:14 <mangoMan> EVERYONE SEND A MESSAGE TO THAT FAG METALEER HE IDLES IN ##PHYSICS AND #DEFOCUS HE IS A CANCER ON THIS FUCKING NETWORK srydth
07:34:16 <mangoMan> EVERYONE SEND A MESSAGE TO THAT FAG METALEER HE IDLES IN ##PHYSICS AND #DEFOCUS HE IS A CANCER ON THIS FUCKING NETWORK etuu
07:34:18 <mangoMan> EVERYONE SEND A MESSAGE TO THAT FAG METALEER HE IDLES IN ##PHYSICS AND #DEFOCUS HE IS A CANCER ON THIS FUCKING NETWORK shdh
07:34:22 --- mode: ChanServ set +o geekosaur
07:34:26 --- mode: geekosaur set +b *!*grg@195.128.64.*
07:34:26 --- kick: mangaba_leitosa was kicked by geekosaur (mangaba_leitosa)
07:34:29 <geekosaur> oops
07:34:40 <ChongLi> yikes!
07:34:41 <geekosaur> da,,it
07:34:44 <geekosaur> dammit
07:34:54 --- mode: geekosaur set -b *!*grg@195.128.64.*
07:35:24 * geekosaur is on work call
07:35:28 --- mode: geekosaur set -o geekosaur
07:38:08 <scriptor> that guy's still on freenode if you still want to ban him
07:38:09 <bstrie> is there a list somewhere of classes of errors that haskell is capable of catching with its type system, that most other mainstream languages cannot?
07:38:37 <bstrie> I remember seeing a mention a long time ago of someone saying "haskell's type system is capable of detecting <some ridiculous thing>", but I've forgotten what it was
07:39:05 <Iceland_jack> bstrie: Loneliness
07:39:39 <ChongLi> bstrie: null pointer dereferences, uninitialized variables, race conditions, array bounds overflows
07:39:48 <ChongLi> lots and lots of errors
07:39:57 <c_wraith> ...  there's no bounds-checking in the type system
07:40:10 <ChongLi> c_wraith: no, but it is capable of expressing it
07:40:25 <bstrie> I've heard of type systems catching data races and array bounds overflows in rust and idris, so I don't think that's what I was thinking of
07:40:44 <c_wraith> There's the obvious case that certain infinite loops show up as type errors
07:41:14 <bstrie> hm, infinite loops might be it
07:41:20 <ChongLi> there's actually a lot more we could be doing to prevent errors but we don't in order to keep the standard libraries simpler to understand
07:41:51 <ChongLi> and we pay the price for this with stuff like "Prelude.head: empty list" :)
07:48:10 * hackagebot httpd-shed 0.4.0.1 - A simple web-server with an interact style API  http://hackage.haskell.org/package/httpd-shed-0.4.0.1 (AndyGill)
07:56:00 <srhb> And having to endlessly repeat "don't use head" :-)
07:56:06 * srhb is late to the party
07:57:46 <bmuk> why doesn't Prelude.head [] return [] ? I have seen many people just write their own safeHead. How is the default behaviour easier to understand?
07:58:46 <asmyers> :t head
07:58:47 <lambdabot> [a] -> a
07:59:00 <Saizan> it can't return [] with that type
07:59:01 <bmuk> I suppose so
07:59:04 <companion_cube> safeHead should be  [a] -> a -> a
07:59:10 <bmuk> [a] -> Maybe a
07:59:23 <quicksilver> bmuk: that is in the standard library too
07:59:28 <quicksilver> with the name listToMaybe
07:59:38 <quicksilver> which isn't obviously a replacement for 'head' but, well, it's there.
07:59:56 <ReinH> arguably, it's what head should have been ;)
08:00:01 <bennofs1> @hackage safe <<-- This provides many more safe functions
08:00:02 <lambdabot> http://hackage.haskell.org/package/safe <<-- This provides many more safe functions
08:00:04 <quicksilver> not at all.
08:00:04 <bmuk> ReinH++
08:00:13 <quicksilver> head is precisely the right function
08:00:17 <quicksilver> it matches with 'tail'
08:00:32 <quicksilver> but real haskell programs very rarely use either of them on finite lists
08:00:34 <bmuk> I agree with you as well quicksilver
08:00:42 <quicksilver> they're quite useful on infinite lists.
08:01:02 <bmuk> how does ghc compute the tail of an infinite list?
08:01:16 <ReinH> They're a bit more useful on structures without head:tail pattern matching...
08:01:25 <ReinH> tail (x:xs) = xs
08:01:43 <ReinH> bmuk: the tail is everything that is not the head
08:02:04 <bmuk> oh, right. Brainlapse
08:02:41 <bmuk> I suppose you couldn't ever get the last element in a infinite list
08:03:11 <ReinH> probably not.
08:03:55 <bmuk> what if I have a finite list which is extremely long (too long to store in memory). What is the most efficient way to get the last element?
08:04:17 <ReinH> how do you construct the list?
08:04:53 <bmuk> I'm not sure. Let's say it's a list comprehension
08:05:52 <mm_bureau> bmuk: not of an infinite [] list
08:06:07 <bmuk> no just longer than 8gb
08:06:09 <mm_bureau> but there is a library that implements exhaustively searchable infinite sets
08:06:48 <ReinH> > ala Last foldMap (Just <$> [1,2,3])
08:06:49 <lambdabot>  Just 3
08:06:54 <ReinH> should be sufficiently lazy
08:07:16 <bmuk> :t <$>
08:07:17 <lambdabot> parse error on input `<$>'
08:07:23 <ReinH> <$> is infix fmap
08:07:35 <bmuk> oh okay thank you
08:07:47 <ReinH> I don't know why I didn't just write (fmap Just [1,2,3])
08:08:41 <bmuk> what is the time complexity of that expression?
08:08:47 <ReinH> linear
08:09:07 <lingxiao> hey all
08:09:08 <ReinH> space is constant modulo gc
08:09:09 <bmuk> is there a solution which will work in log or constant time?
08:09:16 <ReinH> bmuk: lists are linked
08:09:20 <ReinH> traversing them is always O(n)
08:09:37 <bmuk> what if I used a different data structure?
08:09:38 <lingxiao> does anyone know of some tutorial for de-brujin's index simply typed lambda calculus?
08:10:00 <ReinH> bmuk: then I don't think you'd be able to avoid keeping it in memory
08:10:34 <lingxiao> specifically, my confusion is this:
08:10:44 <ReinH> you're constructing it with a list comp, which is already O(n)
08:10:49 <lingxiao> if you have some expression with explicit variables λx : T . E
08:11:39 <lingxiao> or sorry I meant: λx : T . x
08:11:41 <quicksilver> what's wrong with just "last" ?
08:11:53 <lingxiao> becomes  `λ.0`
08:11:56 <quicksilver> I don't see how any more complex tricks can expect to do better than "last"
08:11:59 <ReinH> quicksilver: oh, probably nothing if it's lazy enough
08:12:03 <quicksilver> you have to traverse the list...
08:12:05 <lingxiao> but where does the type get stored in? does it get stored in some external context?
08:12:05 <ReinH> @src last
08:12:06 <lambdabot> last [x]    = x
08:12:06 <lambdabot> last (_:xs) = last xs
08:12:06 <lambdabot> last []     = undefined
08:12:11 <ReinH> yeah, duh
08:12:16 <lingxiao> someone please chime in
08:12:17 <ReinH> quicksilver: it's early here :/
08:12:59 <bmuk> ReinH: the list comp was a bad example. I don't have a application for this, it's just a theorectical question. How would I operate on a list/set/whathaveyou of numbers larger than my physical ram
08:13:03 <ReinH> quicksilver: I guess I shouldn't avoid partial functions so assiduously
08:13:24 <ReinH> bmuk: the general solution is a stream
08:14:14 <bmuk> I'll look streams up when I get home
08:14:40 <quicksilver> ReinH: well yes, one reason to avoid 'last' is if you want to cater for zero-element lists I agree :)
08:14:41 <merijn> lingxiao: De Bruijn indexing only eliminates names, in your example you're getting confused because you're taking a syntactical representaiton with type info and remove the type info as well
08:15:14 <merijn> lingxiao: There's no reason you couldn't turn "λx : T . x"  into "λT.0"
08:15:54 <merijn> lingxiao: If you're using De Bruijn-indexing in an AST then all you're doing is replacing a String name with a number, the rest of the AST info (such as types) should remain the same
08:15:57 <ReinH> quicksilver: although lists that are too big to fit into memory are *probably* not empty...
08:16:04 <merijn> ReinH: :D
08:16:17 <ReinH> merijn: :)
08:16:38 <quicksilver> ReinH: generally not, which is what made me overlook that case :)
08:17:03 <merijn> lingxiao: Also, many of these lambda calculus notations are rather "informal" in that they expect readers to "just understand" that typing information can be preserved in some obvious way
08:17:16 <FreeFull> You could have a repeat undefined, and force the structure
08:17:41 <FreeFull> Would undefined count as empty?
08:17:58 <lingxiao> merijn: yeah while reading about this stuff, the transition between informal and intuitive explanation of what's going on to some formal, finicky mechanical representation is really tripping me up
08:18:02 <ReinH> how about iterate concat [] ?
08:18:24 <ReinH> but that's the thunks taking up memory, not the list
08:18:29 <merijn> lingxiao: Join the club ;)
08:18:43 <c_wraith> why is a stricter iterate not in base, again?
08:18:46 <ReinH> lingxiao: I believe they call that "doing math" ;)
08:18:54 <lingxiao> merijn: haha yeah ... that's why this channel is awesome because there's people who's been there. so it's not the case that `λx : T . x` becomes (λ.0, [T])
08:19:15 <merijn> lingxiao: Well, you could do that too
08:19:21 <lingxiao> ReinH: funny part of math is about mechanizing process of logic into  a formal systems, but being human beings, math people can't help but being vauge
08:19:22 <merijn> lingxiao: Lots of ways work
08:19:28 <merijn> Anyhoo, I need to run
08:19:52 <lingxiao> merijn: oh ok, thanks for chiming in and clearing things up
08:21:40 <sss1> any1 here?
08:21:52 <sss1> any1 here to help for my java homework?
08:22:14 <geekosaur> this is the wrong channel for java help
08:22:15 <Kinnison> I fear you're in the wrong place for that m'dear
08:22:34 <c_wraith> we could tell you to do your homework in haskell, instead
08:22:40 <bmuk> scala is okay
08:22:42 <c_wraith> oh, darn
08:22:57 <mm_bureau> scala is ok, if you don't mind giving up functional programming =)
08:23:09 <mm_bureau> FWIW i do mind
08:23:16 <bearclaw_> also from what I understand type inference is much weaker
08:23:21 <c_wraith> *much* weaker
08:23:29 <c_wraith> it's sort of "well, we tried" type inference
08:23:35 <bmuk> mm_bureau: it isn't haskell but it's better than java if you must use the jvm
08:24:08 <ReinH> c_wraith: no wait come back! It's not too late to use Haskell! ;)
08:24:20 <bmuk> To be honest I haven't tried clojure so maybe that's better
08:24:23 <bearclaw_> its feature list is impressive though
08:24:29 <c_wraith> I've never understood why people talk about the jvm like it's an advantage.  It has some good performance stuff, but my experience with java libraries is that they're kludgey and often broken.  I don't see that as an advantage.
08:24:38 <ReinH> If I had to use the JVM I'd probably try to use clojure. At least it doesn't try to be something it isn't.
08:25:19 <bmuk> c_wraith: jvm isn't an advantage, but it is the standard in most workplaces
08:25:19 <bearclaw_> c_wraith: big stdlib that you can assume everyone knows/has access to, portability
08:25:23 <bmuk> unfortunately
08:25:40 <quchen> c_wraith: Good portability (well, actually you don't have to port at all), lots of libraries. When you like Java the JVM gets better. When you don't like Java the JVM seems awkward.
08:25:51 <bmuk> bearclaw_: why couldn't we have something like that with llvm?
08:26:04 <bearclaw_> I've read there is experimental support for that
08:26:04 <c_wraith> quchen: my experience with "lots of libraries" is that it should be "lots of half-broken libraries"
08:26:08 <companion_cube> why not fredge on the jvm ? :)
08:26:09 <bearclaw_> but llvm is quite new
08:26:49 <bmuk> I haven't seen fredge, link?
08:26:54 <c_wraith> frege
08:27:01 <c_wraith> it's a jvm haskell-like language
08:27:02 <bmuk> I apologize
08:27:12 <bearclaw_> (hmm, same year for both according to wikipedia)
08:27:12 <quchen> c_wraith: Half-broken things make people engineer around half-broken things, giving them a feeling of knowing the library well (and all its quirks). I'm not sure you're right about Java's libs in particular, but in general I would say you mass up "educational debt" when working with bad libs for a long time.
08:27:33 <bmuk> how does it get around tail call recursion?
08:27:51 <c_wraith> Huh.  I don't remember.
08:28:12 <quchen> Wasn't there some Haskell-to-JVM project as well at some point?
08:28:15 <companion_cube> c_wraith: right, sorry for the spelling
08:28:37 <geekosaur> there have been several, none of which has really gone anywhere :(
08:28:48 <companion_cube> https://github.com/Frege/frege
08:29:22 <quchen> We need a JS-to-JVM compiler so GHCJS becomes an IR generator for Java code! :-)
08:29:25 <companion_cube> but that was half-joke, the language is very confidential
08:29:51 <bmuk> does java target the llvm as well?
08:30:02 <bmuk> if so you could use java libs that way
08:30:57 <c_wraith> I don't know of any java implementation that uses llvm
08:31:02 <c_wraith> doesn't mean there isn't one
08:31:30 <companion_cube> it would be nice, something like gcc-java (or whatever it was called) but to llvm
08:31:35 <bmuk> side question: why isn't haskell-in-depth more active?
08:31:56 <south> Hi everyone
08:32:13 <quchen> bmuk: I've never heard of that.
08:32:55 <south> Quick question: Does anyone know of a way to lift a (Free f a) to a (FreeT f m a)?
08:33:12 <piezoid> is it possible to translate FD 'ArrowCancel g t e | g t -> e, g e -> t' to TF 'ArrowCancel g t where type Empty g t :: *' ?
08:33:15 <south> It might be really simple but I can't seem to think of a really easy way
08:33:16 <piezoid> I don't know how to get the 'g e -> t' part
08:33:19 <bmuk> it's supposed to be a slower paced channel for discussing theory, but I have lurked there a while and never seen anyone talking. Maybe I'm in the wrong timezone
08:33:48 <quchen> south: liftF?
08:33:56 <quchen> liftF :: (Functor f, MonadFree f m) => f a -> m a
08:34:46 <quicksilver> bmuk: the IRC channel #haskell-in-depth?
08:34:51 <bmuk> yes
08:34:56 <quicksilver> I think it's used on demand
08:35:03 <south> quchen: I think that would lift the wrong thing
08:35:04 <veryrandomname> I've got a package which builds with cabal install, but fails to be used with cabal repl: <command line>: cannot satisfy -package-id webtest-0.1.0.0-4d34bdb3bea7f2f806cf250685e74be8, its a package added to a sandbox with cabal sandbox add-source webtest
08:35:08 <quicksilver> if someone is trying to explain something in detail and this channel is currently being too noisy
08:35:13 <mm_bureau> bmuk: java is not a standard against which i compare =)
08:35:14 <quicksilver> then people suggest it
08:35:17 <bmuk> ah okay
08:35:42 <mm_bureau> it's more like a historical accident
08:35:43 <bennofs1> south: why do you need this? Can't you just use FreeT f Identity instead of Free f?
08:35:49 <bmuk> mm_bureau: I dislike java as well
08:35:57 <c_wraith> quchen: you're describing a kind of library stockholm syndrome?
08:36:06 <bmuk> but some businesses still think it's the answer to everything
08:36:29 <south> bennofs1: Yeah, sure! But then could I easily map from (FreeT f Identity) to (FReeT f IO)?
08:36:51 <quchen> c_wraith: Something of the sorts, yes. I mean it's really hard to tell whether you know useful things about a library or whether you're just very knowledgeable in using it for your purposes (i.e. working around and with the library).
08:36:55 <bennofs> south: yes, use hoistFreeT (lift . runIdentity)
08:37:11 <south> bennofs: Okay, excellent. That was what I was looking for!
08:37:20 <eazar001> anyone know how to hide a package?
08:37:21 <south> Appreciate the help
08:37:29 <bennofs> south: oops, I think it's hoistFreeT (return . runIdentity) actually
08:37:36 <c_wraith> eazar001: permanently, or on a single ghc invocation?
08:37:44 <bennofs> @let import Control.Monad.Trans.Free
08:37:44 <lambdabot>  .L.hs:53:1:
08:37:45 <lambdabot>      Failed to load interface for `Control.Monad.Trans.Free'
08:37:45 <lambdabot>      Perhaps you meant
08:37:45 <lambdabot>        Control.Monad.Trans.Cont (from transformers-0.3.0.0)
08:37:45 <lambdabot>        Control.Monad.Trans.Error (from transformers-0.3.0.0)
08:37:45 <eazar001> permanently?
08:37:48 <eazar001> more or less
08:37:52 <eazar001> so I can unhide it again
08:37:55 <c_wraith> eazar001: ghc-pkg hide packagename
08:37:59 <ski> bmuk : there's also #haskell-overflow which has partly overlapping purpose
08:38:08 <eazar001> c_wraith: thank you very much, that was straight-forward [=
08:38:46 <mm_bureau> bmuk: i don't think any business nowadays does
08:39:13 <mm_bureau> in 2014 employing java is simply a mistake
08:39:20 <bmuk> mm_bureau: I work for a college and most of our software uses the jvm in some fashion
08:39:41 <bmuk> no tech company does, but plenty of businesses still do.
08:40:36 <meretrix> Is it possible to get a list of all possible values of an emuration "data X = A | B | C | D"?
08:41:13 <Iceland_jack> meretrix: if it's a member of Enum and Bounded
08:41:28 <Iceland_jack> then you can do
08:41:28 <Iceland_jack>     [minBound .. maxBound] :: [X]
08:41:35 <Iceland_jack> *and instance
08:41:36 <Iceland_jack> *an
08:41:38 <meretrix> Iceland_jack: But then I have to manually define minBoudn and maxBound..
08:41:41 <Iceland_jack> no
08:41:48 <meretrix> Ah, it's derived?
08:41:49 <Iceland_jack> deriving (Enum, Bounded)
08:41:54 <meretrix> Awesome, thanks.
08:41:55 <Iceland_jack> Já.
08:42:27 <srhb> When do I get deriving (Lenses)? :|
08:42:27 <quchen> > [()..]
08:42:28 <lambdabot>  [()]
08:42:33 <Iceland_jack> notaprompt> data X = A | B | C | D deriving (Bounded, Enum, Show)
08:42:33 <Iceland_jack> notaprompt> [minBound .. maxBound] :: [X]
08:42:33 <Iceland_jack> [A,B,C,D]
08:42:37 <quchen> srhb: makeLenses ''Foo?
08:42:40 <ski> south : something like `forall m n. (Monad m,Monad n) => (forall a. m a -> n a) -> (forall a. t m a -> t n a)' might be useful ..
08:42:57 <srhb> quchen: I just want moar pretty. :3
08:43:03 <quchen> srhb: Lenses aren't typeclasses anyway, so deriving them will take some serious change in everything :-þ
08:43:08 <srhb> Yeah.
08:43:16 * hackagebot terminfo 0.4.0.0 - Haskell bindings to the terminfo library.  http://hackage.haskell.org/package/terminfo-0.4.0.0 (JudahJacobson)
08:43:26 <Iceland_jack> Wasn't there work on adding user-defined derivable instances?
08:43:30 <srhb> Yes.
08:43:50 <quchen> Iceland_jack: Generics kind of do that, don't they?
08:43:54 <south> ski: Yeah it would
08:44:12 <Iceland_jack> quchen: I'm just talking about making it appear built-in
08:44:20 <south> ski: does this exist out in the wild?
08:44:22 <bennofs> ski: that's called hoist, isn't it?
08:44:31 <bennofs> ski: from the mmorph package
08:44:32 <Iceland_jack>     data A = ... deriving (JSON)
08:44:32 <Iceland_jack> or something
08:44:42 <quchen> Iceland_jack: -XDeriveGeneric, deriving (Generic), instance Foo Bar?
08:44:47 <ski> @hackage mmorph
08:44:47 <lambdabot> http://hackage.haskell.org/package/mmorph
08:44:57 <Iceland_jack> quchen: I'm *just* talking about the deriving part
08:44:59 <quchen> Iceland_jack: I mean it's not the shortest way imaginable, but not a lot either
08:45:02 <quchen> Oh, okay.
08:45:10 <Iceland_jack> Should've made that more clear
08:45:18 <ski> bennofs : seems like it
08:45:23 <quchen> -XDeriveEverythingMathematicallyPossible
08:45:24 <quchen> :-)
08:45:31 <mr-> AndMore :-)
08:45:38 <quchen> -XUnsafeDeriveEverythingMathematicallyPossible
08:45:41 <Iceland_jack> mr-: I certainly wouldn't want less..
08:45:59 <srhb> Also known as -XDeriveAllTheThings
08:46:27 * ski . o O ( `-XGeneralizedNewtypeRefuting' )
08:46:31 <quchen> GHC error: cannot derive instance "Duck" for type "Maybe"
08:46:32 <Iceland_jack> I want a
08:46:32 <Iceland_jack>     -XDerivePicture
08:46:43 <Iceland_jack> where you can create a nice picture of the instances
08:47:35 <enthropy> http://hackage.haskell.org/package/SourceGraph
08:47:42 <c_wraith> I wanted -XDeriveAllTheThings recently.
08:47:52 <c_wraith> But edwardk told me it had some coherence issues.
08:48:08 <ChongLi> -XDeriveMyProgram
08:48:08 * ski . o O ( `-XLanguageSynonyms' )
08:48:09 <ChongLi> !
08:48:24 <Iceland_jack> ChongLi: Lazily evaluated of course
08:48:31 <ChongLi> yes, of course
08:48:33 <quchen> ChongLi: Deriving a Haskell program isn't hard: all of them have type IO () anyway, and the proof for that is quite simple. :-þ
08:48:40 <ChongLi> a lazy tree of all possible programs
08:48:57 <c_wraith> quchen: that's actually not true.
08:49:07 <quchen> c_wraith: No?
08:49:09 <c_wraith> quchen: the type of a haskell program is allowed to be anything that unifies with IO a
08:49:33 <quchen> Oh, I was wondering while "main = return 1" compiles a couple of times.
08:52:19 <quchen> c_wraith: Oh, the Report actually says that main is "of type IO τ". So is it () just a default value here if the type is omitted?
08:52:31 <quchen> s/value/type/
08:53:13 <Iceland_jack> Maybe main should be polymorphic in its return type
08:53:13 <Iceland_jack>     main = return 2       ∷ IO Word8  -- program exits with return value 2
08:53:13 <Iceland_jack>     main = return "error" ∷ IO String -- program exits with error message
08:53:13 <Iceland_jack>     main = return pi      ∷ IO Double -- program makes pie
08:53:57 <quchen> main = return id -- Program exits with error message that it knows no error message
08:54:03 <Iceland_jack> heh
08:54:21 <listofoptions> edwardk: is there any way to use Name a () ?
08:55:42 <listofoptions> if I do : Abstraction (Term a) (Scope (Name a ()) Term a) I cannot implement Monad :/
08:56:18 <joelteon> oh god, there's a class called Abstraction?
08:56:27 <listofoptions> no, AHAH
08:56:37 <listofoptions> its a data structure
08:56:46 <listofoptions> sorry it's out of context :D
08:56:50 <joelteon> ok lol
08:57:03 <quchen> joelteon: Someone had to unify all the abstractions!
08:57:32 <listofoptions> joelteon: it's abstraction like lambda abstraction
08:58:00 <joelteon> heh, a multi-ary typeclass that has every possible method
08:58:17 <listofoptions> <vomit-in-mouth>
08:58:48 <monochrom> the semantics of a type is not given by its name, despite popular belief
08:58:53 <listofoptions> no! Object obejct for you
08:59:03 <listofoptions> lol
08:59:09 <zhaobr> lol
08:59:09 <monochrom> if someone calls it "Human" it may not really mean human.
09:01:11 <quchen> It could be a typo for "chair" after all.
09:01:58 <listofoptions> ok here's a snippet: http://lpaste.net/98481
09:02:43 <monochrom> GHC 7.8 is looking more and more like my phd progression. that is, indefinite procrastination :)
09:03:01 <monochrom> (every year, I tell people, "I will finish next year")
09:03:20 <monochrom> well, s/tell/told/, it was finally done a year ago :)
09:03:48 <quchen> Postponing releases is fine as long as there's enough information about why and what's being done.
09:03:55 <quchen> What we have is radio silence.
09:04:00 <saml> is ghc perl?
09:04:12 <saml> it's because ghc devs left for facebook
09:04:21 <monochrom> I certainly gave my supervisor a lot of radio silence, too :)
09:04:27 <saml> and ghc stops and all will use Hack
09:04:57 <quchen> monochrom: Fun fun fun! :-(
09:05:20 <monochrom> did you know: my thesis is on lazy evaluation too :)
09:05:24 <quchen> monochrom: I bet he went on IRC and told others about how monochrom's information policy is like his own PhD ;-)
09:06:31 <danharaj> thoughtpolice: break radio silence pls :p
09:06:55 <Phyx-> *prepares for the static* :)
09:09:05 <thoughtpolice> ohai
09:09:09 <kristof> Hey all! I have a question
09:09:11 <monochrom> \∩/
09:09:27 <kristof> I think it's well known that the actor model of computation is actually a thin veil over shared state and side effecting
09:09:43 <thoughtpolice> also: RC tomorrow hopefully, there's only some tiny ends left to patch up for that.
09:09:46 <monochrom> thoughtpolice: happy new year and season's best wishes for GHC 7.8 :)
09:09:51 <thoughtpolice> i'll let people know when i'm doing builds
09:10:21 <kristof> But let's suppose for a second that the real, true beauty of actors is being able to apply a state transformation asynchronously, at any point of time, regardless of order
09:10:28 <quchen> RC to release is around a month-ish?
09:10:42 <kristof> Sort of like how the beauty of OO is actually just polymorphism, dispatching on type
09:11:14 <kristof> Let's suppose that you new ahead of time ALL the possible state transformations that could be applied to any piece of state, by static analysis or some other method
09:11:14 <thoughtpolice> quchen: I suppose it depends on the influx of bugs. things are actually looking pretty good everywhere (except poor Windows) so we'll see how many roll in
09:11:25 <thoughtpolice> the biggest thing to wait on now, I guess, is the final Pattern Synonyms merge
09:11:39 <danharaj> Saizan: I've had difficulty finding a definition of pattern unification. I haven't read Miller's paper yet.
09:11:46 <kristof> *knew. Now, if you could prove the commutativity of all state transformations acting on that state, then...
09:11:50 <thoughtpolice> (also, Windows is also looking good, we just had to pull some things from the RC, which is pretty unfortunate.)
09:11:59 <kristof> can't you automatically transform, at compile time, any synchronous piece of state into an actor?
09:12:11 <thoughtpolice> (so if anyone out there uses windows and wants to help...)
09:12:37 <kristof> I hope that question makes sense.
09:12:56 <monochrom> every shared mutable variable can be translated to an actor
09:12:59 <thoughtpolice> monochrom: also, thanks. it's been busy.
09:13:10 <ChongLi> can you prove the commutativity of all state transformations?
09:13:20 * hackagebot numerals 0.4 - Convert numbers to number words  http://hackage.haskell.org/package/numerals-0.4 (RoelVanDijk)
09:13:31 <kristof> ChongLi: I said if you could prove the commutativity of a finite set of state transformations
09:13:45 <quchen> thoughtpolice: For what it's worth, those 10 lines were really useful, thanks etc.
09:13:49 <kristof> filtering the odds and then double all the numbers in a list is the same as doubling the numbers of a list and then filtering the odds
09:14:10 <kristof> That isn't a good example of state transformation because you should really just do that immutably, but you get the point
09:14:32 <ChongLi> kristof: what? no
09:14:41 <ChongLi> if you double all the numbers in the list, there are no odds
09:14:46 <kristof> oh, lol
09:14:47 <ChongLi> then your filter doesn't remove anything
09:14:49 <kristof> WELL
09:15:10 <kristof> Looks like I temporarily forgot how to math
09:15:28 <kristof> I'm sure that the typical usecases of asynchronous actors fall under the category of commutative transformations, right?
09:15:44 <ChongLi> yeah, sure
09:15:50 <ChongLi> if you want a mutable counter, for example
09:15:55 <ChongLi> the increment is commutative
09:16:16 <kristof> Right! The example I was thinking of was a logger that accepted messages and created a single log
09:16:31 <kristof> As you parse over a file with multiple threads
09:16:51 <ChongLi> parsing which file? the log file?
09:17:07 <kristof> No no no, parsing a document or something and counting words, or something equally trivial
09:17:12 <ChongLi> ah
09:17:22 <ChongLi> but why use a log as your resultant data structure?
09:17:48 <ChongLi> a log is just another thing to be parsed
09:17:54 <kristof> hmmm, well I said "logger" but I assume the logger would just create a record
09:18:20 * hackagebot roman-numerals 0.5.1.3 - Parsing and pretty printing of Roman numerals  http://hackage.haskell.org/package/roman-numerals-0.5.1.3 (RoelVanDijk)
09:18:49 <kristof> ChongLi: But yes, what do you think?
09:19:05 <ChongLi> of automatic actor transformations?
09:19:17 <kristof> I hesitate to say automatic ACTOR transformation
09:19:34 <kristof> because a key part of the actor model is allowing an actor to block, send other messages, etc.
09:19:42 <kristof> that doesn't jive with functional programming, in my opinion
09:20:04 <ChongLi> why not?
09:20:07 <kristof> There's an excellent article someone wrote about it, I can link it to you if you would like :P
09:20:14 <ChongLi> scheme was invented to explore the actor model
09:20:18 <ChongLi> that was its original purpose
09:20:20 <kristof> ChongLi: Because actors fundamentally smell like missile launching
09:20:26 <kristof> It's ORIGINAL purpose? Hmmm
09:20:35 <kristof> But Scheme is a procedural language, not a fundamentally functional one
09:21:17 <ChongLi> computers don't really work with functions
09:21:20 <kristof> http://pchiusano.blogspot.com/2010/01/actors-are-not-good-concurrency-model.html
09:21:23 <ChongLi> everything is either a procedure or just data
09:22:17 <kristof> Anything I could say to the notion that actors are good functional programming units is probably mentioned in that blog post by chiusano
09:22:33 <kristof> ChongLi: That was another discussion, though. I'm simply talking about "do this thing to that state... whenever ya got the chance"
09:23:08 <kristof> ChongLi: I treat OO the same way. Not as a system of objects that send and receive messages to each other, but "do this thing to that state, using that note I gave you about what to do when you see that kind of state"
09:23:55 <ChongLi> yeah, it's a database model
09:24:03 <ChongLi> "computing at a distance" etc.
09:24:18 <kristof> So I've seen a quite a few articles on the web about unifying actors and objects, because they do a lot of the same
09:24:41 <ChongLi> because combining 2 unsound principles ought to make for a sound one, right?
09:24:48 <kristof> but when you take message passing away from both objects AND actors, and only treat the former as polymorphism and the latter as asynchronous state change, suddenly the two are actually quite orthogonal and easily reconciled!
09:25:02 <kristof> ChongLi: Well, they're not unsound if you do that^^
09:25:07 <merijn> kristof: For the record, smalltalk objects essentially *are* actors
09:25:18 <kristof> merijn: Can I say something about that?
09:25:25 <merijn> kristof: And smalltalk was the first OO language (incidentally also created by the inventor of the term OO)
09:25:49 <kristof> merijn: Alan Kay's original versions of Smalltalk really did have an object table so that there was as much decoupling as possible between messages and the actual methods invoked
09:25:53 <merijn> kristof: In other words, actors are traditional OO and the Java/C++/C# version of OO is a silly misunderstanding
09:26:01 <simpson> ChongLi: Sorry; how are objects unsound? Or actors?
09:26:34 <ChongLi> simpson: because they use a database model of computation rather than a language model
09:26:52 <merijn> ChongLi: That's not a valid argument
09:27:02 <simpson> ChongLi: Okay; what does that have to do with *soundness*? Or did you use "unsound" to mean "I don't like them?"
09:27:05 <kristof> merijn: But due to some prodding from friends (what he would eventually call the greatest mistake of his career, although I think it was okay to do this) he decided to, for performance reasons, remove the object table and now smalltalk just uses traditional transformation of method calls into procedure calls
09:27:49 <kristof> That's why "become", instead of just being cheap, actually has to walk the entire heap and modify every. single. reference. to the the methods and classes
09:27:52 <merijn> Anyway, I walked into the middle of the discussion, so I'm unsure what's being argued
09:28:01 <kristof> simpson: He meant he didn't like them
09:28:42 <kristof> simpson: Although it's not entirely incorrect to say objects are unsound if the original statement is "Object Oriented Programming is the best way to make scalable, performant, reasonable, abstractable, concurrent . . . programs"
09:29:07 <simpson> kristof: Mu; there is no best model of computation.
09:29:17 <ChongLi> simpson: the database model treats memory as an IO device, essentially
09:29:18 <kristof> simpson: ok :)
09:29:25 <ChongLi> it's a black box
09:29:30 <ChongLi> and you can't prove much about it
09:29:36 <kristof> Woah! I really wanted to talk about this asynchronous state change stuff
09:29:40 <edwardk> listofoptions: did you figure it out yet?
09:29:40 <exDM69> hi guys, I'm working on this problem where I would essentially like to do some non-deterministic programming with some internal state. something like a prolog-esque logic programming system where I have variables which may have several values and I need a way to give unique names to things
09:29:41 <edwardk> was afk
09:29:43 <kristof> simpson: you're welcome to pipe in if you like
09:29:52 <exDM69> can I find some nice examples about non-deterministic programming
09:30:02 <ChongLi> and so if you put it at the core of your computing model, you can't talk about values very much
09:30:03 <kristof> exDM69: Every prolog book in existence
09:30:15 <merijn> kristof: I'm pretty sure he meant "in haskell"
09:30:18 <ChongLi> since all your values are on the other side of the fence
09:30:18 <kristof> exDM69: I haven't read it, but The Reasoned Schemer might have some stuff in it too
09:30:20 <exDM69> kristof: I have a few of those, but I'm looking for examples in Haskell
09:30:24 <edwardk> 'a' should be a different type than the argument to your monad.
09:30:25 <ChongLi> that's what I mean by unsound
09:30:25 <kristof> aw :(
09:30:34 <edwardk> e.g. Name String
09:30:40 <exDM69> kristof: I am trying to implement a prolog-like system in Haskell
09:30:53 <listofoptions> edwardk: no I just switched back to using different type parameters for free and bound variables, (even thought in the interpreter they are going to be the same type)
09:31:00 <simpson> ChongLi: Well, yes. In an object-based system, every value is an object. The actual computation happens in the passing of messages. The soundness of an object model comes from the structure of the connections between arguments.
09:31:20 <merijn> kristof, simpson, ChongLi: Can I suggest moving the "programming paradigm" discussion to a different channel? It's sort drowning out the Haskell
09:31:22 <ChongLi> simpson: objects are not *values*
09:31:42 <ChongLi> merijn: alright, I was just leaving anyway
09:31:46 <simpson> ChongLi: IYSS; I don't have time for this. You win; objects are unsound. Whatever.
09:31:52 <listofoptions> simpson: have you read anything on the object calculus?
09:31:56 <kristof> merijn: Yeah, sure
09:35:46 <kristof> merijn: The reason I wanted to talk about it in here was because GHC is the only popular compiler I know of that does really cool stuff with nondeterminism and call graph manipulation.
09:36:10 <merijn> kristof: There's tons of research languages that do neat stuff, though
09:36:27 <kristof> merijn: "Neat stuff" always drifts to Haskell :)
09:36:33 <merijn> kristof: Not always :)
09:36:40 <kristof> merijn: Name some stuff!
09:36:52 <haasn> dependent typing
09:36:53 <merijn> kristof: If you're not easily intimidated you might wanna browse http://lambda-the-ultimate.org/
09:37:04 <kristof> merijn: This idea actually came from reading a thread on there
09:37:06 <merijn> kristof: It's the home of programming language research on the web
09:37:09 <merijn> :)
09:37:14 <kristof> It's a great place!
09:37:27 <merijn> haasn: Dependent typing is different from what kristof wants, though
09:37:50 <merijn> Seems the interest is more into program transformation/optimisation than type theory
09:37:52 <haasn> Sorry, I jumped in on this conversation at “‘Neat stuff’ always drifts to Haskell :)”
09:38:26 <eazar001> @pl not . (\x -> any (==x) $ tail $ subsequences [2,5])
09:38:26 <lambdabot> not . flip any (tail (subsequences [2, 5])) . (==)
09:38:31 <kristof> haasn: I don't mind talking about general neat stuff, too. Never understood the power of dependent types. Always thought "this is a thing, will always be a thing, why change it?"
09:39:04 <haasn> kristof: really short version: more static guarantees than can be had with haskell's type system alone
09:39:22 <kristof> haasn: I'll look into Idris
09:40:57 <merijn> kristof: I have colleagues looking into things like layout typing (i.e. if you write array numeric code the layout of the array can matter a lot for performance, they're trying to infer the optimal layout for the inner loop and then propagate that outwards to force the outer code to use a layout optimised for the inner loop)
09:41:42 <zcourts> merijn + hpc sorry, had to run off to a meeting, missed your responses. The package name is Stasis, it doesn't have any C dependencies. Do you mean the hackage build logs, because it builds fine locally?
09:42:23 <merijn> zcourts: Hackage build logs, yeah
09:42:55 <zcourts> merijn: Where are they located, I don't see a link on the site to get to that
09:42:57 <merijn> zcourts: Got a hackage link? I can't find it
09:43:12 <zcourts> http://hackage.haskell.org/package/Stasis
09:45:07 <merijn> hmm, I don't know where the build log went in Hackage 2.0
09:48:13 <kristof> merijn: I had been thinking about something similar to that and I was wondering if Haskell implemented on top of a JIT could do something like that both faster and flexibly
09:48:17 <kristof> *more flexibly
09:48:44 <zcourts> merijn: hmm, Ok.
09:48:53 <Philonous> haasn, Haskell may not have dependent types, but it's getting pretty close. With the singletons library you can actually write dependently typed programs (according to the author)
09:49:04 <merijn> zcourts: How long ago did you upload it?
09:49:33 <TallerGhostWalt> Is there a way to generate my haskell code with all the curly brackets and parens added in?
09:49:37 <kristof> merijn: i.e. it performs different optimizations by tracing the execution path at runtime and using guard functions to make sure that assumptions remain true
09:49:57 <kristof> TallerGhostWalt: template haskell
09:50:39 <quchen> What's the Haskell way of "logging to stderr", à la C++'s `clog`? Conceptually I could just write to stderr, but that has a different meaning in the source, as well as no buffering by default (as far as I know).
09:51:00 <zcourts> merijn: I got upload access yesterday around midday so somewhere between that and 11pm last night, can't remember exactly
09:51:48 <merijn> zcourts: Anyway, see also: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
09:51:54 <Iceland_jack> quchen: Writing to stderr is generally unbuffered by default
09:52:05 <Iceland_jack> Are you asking for a library solution or do you want to know how to write to stderr?
09:52:08 <merijn> zcourts: And here for details on uploading your own docs: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Hackage-documentation-v2.html
09:52:20 <Iceland_jack> @hoogle stderr
09:52:20 <lambdabot> System.IO stderr :: Handle
09:52:20 <lambdabot> GHC.IO.Handle.FD stderr :: Handle
09:52:20 <lambdabot> System.Posix.IO.ByteString stdError :: Fd
09:52:23 <Iceland_jack> @hoogle hPutStrLn
09:52:23 <lambdabot> System.IO hPutStrLn :: Handle -> String -> IO ()
09:52:24 <lambdabot> Data.ByteString hPutStrLn :: Handle -> ByteString -> IO ()
09:52:26 <lambdabot> Data.ByteString.Char8 hPutStrLn :: Handle -> ByteString -> IO ()
09:52:32 <zcourts> merijn: cool, thanks
09:53:15 <Iceland_jack> Then there is BufferMode and hSetBuffering
09:53:15 <Iceland_jack> @hoogle hSetBuffering
09:53:15 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
09:53:15 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
09:53:31 <quchen> Iceland_jack: Writing to (buffered) STDERR is what I've been doing so far. I was just wondering whether there is a better way of handling "non-error messages not part of the actual output".
09:54:01 <Iceland_jack> Well there are many possibilities really depending on your application
09:54:23 <Iceland_jack> one of them is the Writer monad if you're familiar with that, it may not be what you want though
09:54:53 <haasn> Philonous: except it isn't true dependent typing because you can't actually have values depend on types
09:55:15 <haasn> err, types depend on values
09:55:16 <Iceland_jack> quchen: Did you specify that stderr is buffered? Because it should be unbuffered by default
09:55:17 <Iceland_jack> P> hGetBuffering stderr
09:55:17 <Iceland_jack> NoBuffering
09:55:25 <quchen> Iceland_jack: Yes, I did
09:55:31 <Iceland_jack> Okay
09:55:52 <quchen> In that case I guess I'll stick to stderr. Had there been a canonical solution I overlooked so far I would've used that, that's why I'm asking. (I know Writer) :-)
09:56:02 <lingxiao> hey all, i have a question about language design for a simply typed lambda calculus
09:56:11 <Iceland_jack> There are plenty of logging solutions on Hackage if you're fine with impurity
09:56:17 <Iceland_jack> lingxiao: fire away
09:56:39 <geekosaur> @hackage hlogger
09:56:39 <lambdabot> http://hackage.haskell.org/package/hlogger
09:56:47 <lingxiao> in pierce's book, he extends simply typed lambda-calculus with boolean values, and expreses the universe of types with Bool, and Type -> Type
09:57:11 <lingxiao> so, https://gist.github.com/anonymous/d0ad068c9f25821421fa
09:57:30 <quchen> SPACES use spaces. Arrgh.
09:57:56 <lingxiao> my question is: is it possible to have a language that have boolean *types, but no first class boolean values?
09:58:22 <lingxiao> so boolean values tru = λx:T λy:T . x
09:58:23 <Iceland_jack> lingxiao: You can encode booleans in a language with non-booleans if that's what you're asking
09:58:30 <Iceland_jack> yes
09:58:42 <lingxiao> yes, essentially Pure simply typed lambda calculus
09:59:01 <lingxiao> now the problem is how to type tru: tru = λx:T λy:T . x
09:59:02 <Iceland_jack> https://en.wikipedia.org/wiki/System_F
09:59:14 <Iceland_jack> Search for Boolean on that entry
09:59:39 <Iceland_jack> Bool = ∀a. a → a → a
10:00:13 <lingxiao> Iceland_jack: ahh see that's my question, is it possible to have pure simply typed lambda calculus *without* existential quantification?
10:00:51 <lingxiao> Im guessing the answer is yes right? though you hae have to redefine `tru` for every type of T?
10:01:21 <Iceland_jack> lingxiao: What do you mean, the STLC has neither existential nor universal quantification
10:01:35 <lingxiao> I'm referring to this line: Bool = ∀a. a → a → a
10:01:53 <lingxiao> so right now my language describing types do not have this "ForAll" concept
10:02:59 <lingxiao> so if i can backup for a second, this expression: `tru := λx:T λy:T . x`, could  it be used for all possible values of T?
10:03:46 <lingxiao> here T is a type variable, ranging over the universe of types. Though no where in the language am I saying `∀T => λx:T λy:T . x`
10:03:55 <lingxiao> or however you'd want to express it
10:04:02 <Iceland_jack> Well you kind of can
10:04:21 <Iceland_jack> if you have a single base type O you can define
10:04:22 <Iceland_jack>     Bool = O → O → O
10:04:40 <lingxiao> what does that expression Bool = 0 -> 0 -> 0 mean?
10:04:55 <Iceland_jack> it's not a zero
10:05:07 <Iceland_jack> in the simply typed lambda calculus you need to have some base type
10:05:31 <Iceland_jack> and from that base type you can construct function types
10:05:51 <lingxiao> so are those "O" thing base types?
10:05:58 <Iceland_jack> yeah
10:06:05 <lingxiao> right now my base type is just {Bool}
10:06:19 <Iceland_jack> right but the base type is just abstract
10:06:36 <lingxiao> what do you mean by abstract?
10:07:25 <lingxiao> wait back up one more step, is there a notion of type variable in simply typed lambda calculus?
10:07:26 <Philonous> haasn, With DataKinds you can.
10:07:37 <Iceland_jack> no
10:07:44 <lingxiao> because I don't see it in my current description: `Type = TBool | Type `Arr` Type`
10:08:44 <lingxiao> ahh so when I write: `∀T => λx:T λy:T . x`, T has to be either Bool or T -> T, as suggested by my declaration of Type
10:09:02 <lingxiao> sorry if my questions sound innane ...
10:09:10 <Iceland_jack> it's fine
10:09:26 <lingxiao> still trying to reconcile what I'm actually expressing, vs what i think the system ought to do
10:09:34 <Iceland_jack> Okay so let's make things a bit clearer
10:09:39 <Iceland_jack> You cannot have polymorphism in the STLC
10:09:48 <merijn> Philonous: Eh, no. DataKinds doesn't let you have types depending on values
10:10:10 <Iceland_jack> You can encode Booleans to some extent but you cannot encode something like
10:10:10 <Iceland_jack>     ifThenElse ∶ Bool → a → a → a
10:10:19 <merijn> Philonous: It just lets you use values as types, which is not the same thing as you can convert between the two at runtime
10:10:42 <Philonous> merijn, OK, that's what you need singletons for.
10:10:51 <lingxiao> because `a` ranges over types, and there's no type variables
10:10:55 <Iceland_jack> yes
10:10:55 <Iceland_jack>     
10:11:02 <merijn> Philonous: i.e. you can't have (excuse my made up dependent syntax) "{x : Int} -> Foo x" in haskell
10:11:30 <Iceland_jack> lingxiao: If you just want to encode operations on Booleans you can say
10:11:30 <Iceland_jack>     Boolean = o → o → o      (for some base type o)
10:11:30 <Iceland_jack> and then
10:11:33 <Iceland_jack>     true ∶ Boolean
10:11:36 <Iceland_jack>     true x y = x
10:11:39 <Iceland_jack> and
10:11:43 <Iceland_jack>     false ∶ Boolean
10:11:46 <Iceland_jack>     false x y = y
10:11:48 <Philonous> merijn, In Haskell it's (Sing x -> Foox)
10:11:52 <Philonous> Foo x*
10:11:54 <BassSultan> hi guys, can any1 tell me how i can declare my own class?
10:11:57 <Iceland_jack> and
10:11:58 <Iceland_jack>     not ∶ Boolean
10:11:58 <Iceland_jack>     not a x y = a y x
10:11:58 <Iceland_jack> etc.
10:12:17 <geekosaur> BassSultan: why do you want to do so?
10:12:19 <Iceland_jack> oops. Boolean → Boolean
10:12:27 <lingxiao> Iceland_jack: so the jist here is Boolean is some arity 3 function ranging over base types?
10:12:31 <geekosaur> (typeclasses are not OO classes, if you are looking for OO then you will be very unhappy)
10:12:33 <merijn> Hold on...
10:12:40 <lingxiao> but how do you there does not exist arity 3 functions that are not booleans?
10:12:43 <Iceland_jack> lingxiao: not arity 3
10:12:45 <flebron> Hi. What does Haskell have, instead of dependent typing? Is it called "independent" typing when types only refer to types?
10:12:47 <merijn> Why is Hakyll producing a 78M executable for me? >.>
10:13:04 <flebron> merijn: Static libraries?
10:13:06 <Iceland_jack> lingxiao: I'm just saying that you can *encode* them in the STLC
10:13:06 <Saizan> danharaj: ah, ok, i've found some anyway, in pattern unification you can only have distinct object variables as arguments to metavars so M x x is not valid but neither is M (f x) which could be linear i think
10:13:16 <merijn> flebron: Haskell has a flavour of System F_omega for typing
10:13:27 * hackagebot pandoc 1.12.3.1 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.12.3.1 (JohnMacFarlane)
10:13:33 <flebron> Right, and what is the property of "Not having dependent types"?
10:13:34 <danharaj> Saizan: care to explain pattern fragment to me?
10:13:37 <merijn> flebron: My question is: wtf is it pulling in that's 78MB?
10:13:50 <flebron> merijn: All of GHC, presumably.
10:14:00 <BassSultan> geekosaur: because im preparing for an exam and i dont really get the whole mechanism of classes , deriving and instances etc yet :)
10:14:01 <flebron> (Memory management, thread management, concurrency.)
10:14:07 <kristof> gotta love runtimes
10:14:11 <lingxiao> BassSultan: https://gist.github.com/anonymous/22ecce99405c7928f9b0
10:14:18 <JuanDaugherty> like a regalr pattern only just not a whole one
10:14:32 <Hodapp> BassSultan: An exam on what?
10:14:39 <geekosaur> 78MB is awfully small for all of ghc :p
10:14:53 <BassSultan> Hodapp: surprisingly, functional programming with haskell ;)
10:15:05 <merijn> flebron: My GHC binary is only 1.7MB
10:15:11 <Hodapp> BassSultan: Where do classes fit into this?
10:15:39 <lingxiao> wait but if you write "Boolean = o → o → o", aren't you assigning a name to a specific type?
10:15:50 <kristof> ADTs are the closest you can get to "classes" in Haskell
10:15:50 <Iceland_jack> lingxiao: That's just a ‘meta-level’ name
10:15:57 <Saizan> danharaj: the pattern fragment is made of those unification problems made of terms satisfying the pattern condition, which is that in normal form a metavar occurrence can only have distinct object variables as arguments
10:15:59 <napping> flebron: I've never seen "independent types" used. Syntactically, dependent types mean a normal value expressions can be subterms of type expressions
10:16:10 <lingxiao> or doesn the assignment not preclude other asssignments? like zero and tru are both \x\y -> x
10:16:21 <merijn> Also, why the hell would hakyll need to pull in all of GHC?
10:16:29 <Iceland_jack> lingxiao: Like I said, it depends on what you mean by encoding
10:16:36 <Iceland_jack> you can encode a whole bunch of things as a string
10:16:37 <flebron> merijn: Presumably the ghc binary itself is dynamically linked. See http://stackoverflow.com/questions/7854614/haskell-static-vs-dynamic-linking-in-deployment
10:16:43 <BassSultan> Hodapp: isnt it a concept used by haskell? since we used deriving and instances quiet a bit with ord, eq, etc. but i dont feel like i understand the idea enough, i wanted to create my own class and try a lil bit
10:16:51 <lingxiao> yeah I wasn't sure what you meant origiinal by "not encoding"
10:17:09 <Iceland_jack> and you might ask
10:17:09 <Iceland_jack>     “is "0A" the number 10 or the string "0A"?”
10:17:14 <Saizan> danharaj: if you think of the arguments provided to the metavar as a substitution it saying that they must be injective renamings
10:17:20 <kristof> BassSultan: A typeclass is a kind of thing for which some functions must be defined. If you're familiar with Java or C#, they're like interfaces.
10:17:23 <danharaj> ah
10:17:39 <haasn> kristof: except way more powerful
10:17:43 <Saizan> *an injective renaming, to be precise
10:17:43 <lingxiao> oh ok, so you're saying same formal reprensentation may have many interpretations outside of the formal system?
10:17:50 <haasn> type classes include non-functions
10:18:03 <Iceland_jack> yes basically
10:18:18 <kristof> haasn: I don't know anything about the power of typeclasses, so you'll have to inform me on what they can better than interfaces or multiple inheritance can. Not being combative, just sincerely curious.
10:18:23 <merijn> flebron: I know all of that, 78MB is a ridiculous size for a binary that only compiles a static website
10:18:38 <haasn> kristof: consider class Monoid a where mappend :: a -> a -> a; mempty :: a
10:18:58 <haasn> kristof: interface Monoid<A> { A Mappend (A a); } // is no big deal
10:18:58 <geekosaur> I would not say they are better, just different
10:19:04 <dschoepe> kristof: of the Read class (with read :: String -> a)
10:19:06 <dschoepe> *or
10:19:17 <haasn> but how do you get mempty in there?
10:19:22 <geekosaur> "better" depends on what you'r'e doing with them...
10:19:32 <lingxiao> oh ok, so just be be perfectly clear, it's possible to have a pure STLC where boolean values are represented by lambda abstractions
10:19:43 <lingxiao> but boolean *Types* are first class citizens
10:19:45 <flebron> merijn: Try adding -dynamic when building site.hs
10:19:54 <flebron> (That is, ghc --make -dynamic site.hs)
10:20:00 <geekosaur> (there are arguments to be made about OOP vs. static typing, but typeclasses are somewhat orthogonal to that; it's still comparing apples and oranges)
10:20:15 <BassSultan> geekosaur: ah jeah thats what i had, i deleted some other code and now it works. thx, its a start :)
10:20:58 <kristof> haasn: Easy. mempty is itself a subclass of Monoid, and mappend as a method defined on mempty simply overrides the one inherited from mappend
10:21:13 <lingxiao> which would remove the need to assign "Bool := o -> o -> o", though there's less "symmetry" in this formulation
10:22:19 <kristof> haasn: Is that a bad answer?
10:22:41 <lingxiao> also, arity 2*
10:22:48 <lingxiao> from like 25 lines ago
10:23:04 <haasn> kristof: I don't quite understand; to be more specific, I was referring to C# interfaces so that's probably something we should agree upon first of all
10:23:58 <BassSultan> ok i think i do understand a lil bit more now, thx u guys!
10:24:05 <kristof> haasn: Oh, sorry. I actually don't like interfaces; I think they're just a hack to get multiple inheritance into a language when all you needed were sane disambiguation rules and a way to specify which parent class's method to dispatch on
10:25:20 <lingxiao> Iceland_jack: anyways I think I get it now, thanks for the help! :)
10:25:20 <kristof> haasn: So if Common Lisp had any sort of sane typing, I wouldn't make an interface for Monoid, I'd just make a class for it, and then have a generic function named mappend which dispatches on type Monoid in the way that you want it to, but distpatches on Mempty in a more specific way
10:27:17 <haasn> the technical details are a bit fuzzy because Haskell doesn't have inheritance or object orientation either way; the most sane comparison that can be made between interfaces and type classes is their general purpose - abstracting over a family of a family of similar values
10:28:19 <napping> kristof: Doesn't implementing a generic function in Lisp for a type have very little to do with inherting the representation?
10:28:55 <napping> I thought dispatch in CL was fairly orthogonal to multiple inheritance
10:29:08 <kristof> It is
10:29:11 <haasn> I guess the real difference arises from Haskell's parametric polymorphy - we can have a naked “mempty :: Monoid a => a” lying around because we don't need it to have any concrete type yet; whereas I can't think of a way to express the same in C#
10:29:49 <kristof> Excuse me for a delay in responding to both of you, I have the worst headache and it is hard to think
10:32:13 <bergmark> it's possible to add that to OO languages, but you need type inference i think
10:32:51 <Iceland_jack> lingxiao: With one base type you can define Booleans and their algebra
10:32:58 <Iceland_jack> but you couldn't define something like a product
10:33:08 <lovewithacaveat> memoization.
10:34:20 <lingxiao> why can't you define product?
10:35:05 <kristof> I was confused about what mempty meant
10:35:07 <lingxiao> so for example, pair := λa.λb.λf. f a b
10:35:44 <Iceland_jack> lingxiao: Because it's too specialised
10:36:01 <lingxiao> a:T, b:T, f: T -> T -> T, except now a and b has to be the same type? is that what you mean by specialized?
10:36:11 <Iceland_jack> Basically
10:36:29 <Iceland_jack> You cannot make a product of (T → T) and T using that
10:36:57 <lingxiao> wait, so what would you do so that it's less specialized?
10:37:13 <BassSultan> hi, another question just popped up.. can i instance anything for String?
10:37:23 <Iceland_jack> You can either extend the language with them or move on to a more powerful language
10:37:40 <merijn> BassSultan: Can you be a bit more specific? :)
10:37:44 <lingxiao> in pierce', he extends the type universe with T = .... | T1  x T2
10:37:57 <Iceland_jack> exactly
10:38:27 <lingxiao> not sure how that helps though, since if I express that in haskell I'd just write Type = ... | Prod Type Type
10:38:27 <BassSultan> merijn: ok sry :) i meant something like "instance Eq String where .. bla ..
10:38:29 * hackagebot haskell-packages 0.2.3.2 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.3.2 (RomanCheplyaka)
10:38:49 <lingxiao> would I have to add things to the base types?
10:39:02 <Iceland_jack> lingxiao: isn't that what Type is?
10:39:04 <lingxiao> which currently look like this: https://gist.github.com/anonymous/6f9d2466a5fe4525302d
10:39:20 <triliyn> BassSultan: normally, no, you can't do that
10:39:42 <Iceland_jack> lingxiao: (maybe use something like :→ or :-> for arr) ;)
10:39:43 <lingxiao> oh I currently have them separate, but it's more of a syntax difference I suppose
10:39:56 <Iceland_jack> and :× for product, just my preference
10:40:02 <triliyn> You're not allowed to mention non-variable types in typeclass instances except for constructors
10:40:06 <lingxiao> ha, I have that for substiution, too bad I can't use "+->" for value constructors
10:40:32 <triliyn> Because if you have an instance for both [a] and [Char] (which is what String really is), it's not clear which one should be used
10:40:32 <lingxiao> ohh.. looks like ":" is some distingusihed operator
10:40:37 <Iceland_jack> Yes
10:40:41 <lingxiao> funny and arbitrary
10:40:42 <Iceland_jack> To allow : in []
10:40:47 <lingxiao> oh.. duh haha
10:40:47 <BassSultan> triliyn: ah ok so i should just use [a] instead?
10:41:06 <triliyn> BassSultan: that's one possibility
10:41:08 <Iceland_jack> But then you can define synonyms like
10:41:09 <Iceland_jack> (→) = (:→)
10:41:18 <triliyn> You could also use a specialized type like Text
10:41:22 <Iceland_jack> well, not for (→) but for (-->)
10:41:24 <BassSultan> triliyn: and what is a constructor in that context? :)
10:41:35 <triliyn> Which is like a nicer form of strings; since it's not a type synonym you can declare instances for it
10:42:06 <triliyn> There's also -XOverlappingInstances, but you'd have to ask someone more experienced than me whether that's a good idea
10:42:10 <flebron> Are DataKinds useful without GADTs?
10:42:20 <triliyn> BassSultan: a type constructor is something like [] or Maybe or Either
10:42:20 <lingxiao> word, i really like haskell's syntax because of the ability to use these symbols haha
10:42:32 <lingxiao> ->> is what I'm working wiht
10:42:34 <cschneid> is there a post which runs down the diff between MVar, TVar, and friends?
10:42:43 <cschneid> or should I go dig out concurrent programming book
10:42:59 <Iceland_jack> cschneid: I would recommend Marlow's book
10:43:03 <triliyn> cschneid: MVar is a "Maybe variable"; it can be empty
10:43:09 <triliyn> I don't know about the rest though
10:43:14 <Iceland_jack> irrespective of anything else :)
10:43:16 <cschneid> triliyn: yeah, but it has threading semantics I'm curious about.
10:43:21 <cschneid> Iceland_jack: yeah, I have it and skimmed it
10:43:23 <haasn> Why was : made reserved instead of simply including it in the grammar of user-definable operator names? Sure, we have list sugar, but we also for example have sugar for do-notation without making (>>=) a reserved operator
10:43:26 <cschneid> gotta actually go back and read it
10:43:36 <flebron> triliyn: Isn't it a mutable variable?
10:43:45 <triliyn> cschneid: oh, I don't know anything about that XD
10:43:46 <napping> cschneid: I think there was a nice post introducing concurrency recently somewhere, but I don't remember more
10:43:56 <triliyn> flebron: all the *Var things are mutable, I think
10:44:22 <BassSultan> triliyn: never heard of maybe or either before :) but thx, im gonna go with [a], that kinda makes sense for me
10:44:40 <merijn> triliyn: MVar is mutable variable
10:44:56 <triliyn> oh, is it?
10:45:01 <triliyn> I'm misremembering then
10:45:06 <cschneid> it's a nicely locked variable, suitable for sharing across threads right?
10:45:13 <merijn> cschneid: Yes
10:45:16 <cschneid> TVar is similar, but different semantics I guess?
10:45:30 <exDM69> TVar is for transactional memory
10:45:47 <exDM69> MVar is a nicely behaving concurrent variable, which may be "empty"
10:45:49 <lingxiao> Iceland_jack: so it's still not crystal clear why `Base | Type `Arr` Type | Type `X` Type` is more expressive than just `Base | Type `Arr` Type`
10:45:52 <cschneid> ahh, optimistic vs. pessimistic locking basically?
10:45:56 <merijn> cschneid: TVar is not similar, because you can "lock" an MVar by taking the value out. TVars are always filled
10:46:03 <cschneid> merijn: ah, interesting
10:46:04 <lingxiao> given `Base = ()`
10:46:06 <Hafydd> Aren't MVars are implemented in terms of TVars?
10:46:13 <Hafydd> (in GHC)
10:46:16 <merijn> Hafydd: No
10:46:19 <exDM69> Hafydd: the opposite, I guess
10:46:21 <cschneid> merijn: ok, I'll just go read the book. And stop wasting all your time
10:46:29 <merijn> exDM69: Also no, afaik
10:46:31 <Hafydd> The opposite certainly isn't true.
10:46:31 <BassSultan> triliyn: one more thing, is newtype a constructor?
10:46:44 <napping> Hafydd: no, there's a TMVar which is an STM version of MVar
10:46:44 <merijn> cschneid: I recommend reading the STM paper (linked from Control.Concurrent.STM docs)
10:46:52 <Hafydd> I see.
10:46:58 <lingxiao> all I see is that there's two ways of composing `Type`
10:47:02 <lingxiao> Arr and X
10:47:08 <haasn> TVar is semantically closer to an STRef
10:47:09 <triliyn> BassSultan: oh, right, that's the other option. If you define newtype WrappedString = MkWrapped String, then you can declare instances for Wrapped
10:47:10 <exDM69> cschneid: TVars and software transactional memory are used to do database-like transactions (with rollback, commit, etc) in a multithreaded program
10:47:14 <haasn> IORef*
10:47:14 <Taneb> I've been programming Haskell for two and a half years now I think and I still cannot figure out which way to fold without trying both and seeing which is quicker
10:47:16 <triliyn> *WrappedString
10:47:19 <merijn> Hafydd: You can't (or rather, don't want too) implement MVar using TVar because TVars suffer from thundering herd problem
10:47:28 <cschneid> merijn: which paper? http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/index.htm
10:47:29 <cschneid> there's a bunch
10:47:29 <triliyn> And this is what people usually do to make multiple typeclass instances for a single type
10:47:37 <triliyn> For example, Sum and Product for numeric types
10:47:48 <BassSultan> triliyn: ah sweet understanding :) thx
10:47:50 <exDM69> cschneid: "beautiful concurrency" is rather interesting
10:47:54 <Iceland_jack> lingxiao: The difference is that what inhabits them
10:47:56 <Iceland_jack> -that
10:47:58 <merijn> cschneid: The one linked there: http://hackage.haskell.org/package/stm-2.4.2/docs/Control-Concurrent-STM.html
10:48:12 <cschneid> merijn: which is the link I pasted :)
10:48:13 <jfischoff> If I have a code base that appears to be working and doesn't have tests, is there an easy way to generate test cases automatically by instrumenting the code somehow?
10:48:28 <lingxiao> Iceland_jack: could you expand on that?
10:48:32 <Iceland_jack> for (a × b) you must have two projection functions to retrieve a and b for any possible a and b
10:48:36 <triliyn> BassSultan: and just to be specific, WrappedString there is a type constructor (which happens to be nullary, so it's also a type) and MkWrapped is a value constructor
10:48:44 <merijn> cschneid: It mentions the title "Composable Memory Transactions" in front of the link ;)
10:48:52 <cschneid> oh. lol
10:48:56 <triliyn> (Or I think you call it a data constructor but for some reason I say "value" for "things other than types")
10:49:09 <cschneid> sorry for being obtuse
10:49:17 <kristof> haasn: Sorry I disappeared, I needed some analgesics
10:49:21 <lingxiao> the projection function is expressed in the `Term` universe right?
10:49:28 <lingxiao> which is separate form `Type` universe?
10:49:35 <Iceland_jack> yes
10:49:53 <triliyn> merijn: hearing your explanation for TVars and MVars, I still think it would make more sense if the M stood for Maybe XD
10:50:07 <triliyn> (At least, I think that was your explanation)
10:50:15 <lingxiao> so the Type universe itself hanv't become more expressin with Type X Type and Type -> Type
10:50:27 <lingxiao> expressive*
10:50:36 <Iceland_jack> so by extending the STLC with products you get
10:50:36 <Iceland_jack>     π₁ ∶ A × B → A
10:50:36 <Iceland_jack>     π₂ ∶ A × B → B
10:50:36 <Iceland_jack> which are polymorphic in their arguments
10:50:46 <merijn> triliyn: It's not a completely stupid idea, but the term has been in use for a long time outside Haskell meaning mutable :)
10:51:22 <Iceland_jack> lingxiao: Just because the type constructors are both binary with the same domain doesn't make them equivalent
10:51:26 <flebron> Are DataKinds useful without GADTs?
10:51:26 <lingxiao> oh so it's with the additional functions that inhabits the types, is the STLC actually enriched
10:51:39 <lingxiao> which is what you meant by "inhabit"?
10:52:01 <merijn> flebron: If you use TypeFamilies, maybe
10:52:08 <merijn> flebron: But not very, I'd say
10:52:28 <aristid> datakinds is not yet very useful even with gadts imho:P
10:52:31 <merijn> flebron: GADTs and DataKinds are a match made in statically typed heaven :)
10:52:33 <flebron> I was trying to introduce DataKinds as an extension by itself :) (In a small post I'm writing)
10:52:34 <merijn> aristid: Heretic!
10:52:37 <lingxiao> I think this is the 2nd time I've said this, but you have a sick set of symbols :)
10:52:37 <Iceland_jack> lingxiao: Maybe the confusion arises because your encoding in Haskell is not strict enough
10:53:06 <aristid> merijn: i love me some dependent typing, but singletons and all that machinery to get everything out of datakinds is just meh^3
10:53:13 <lingxiao> hmm.. as in my Type universe doesn't make a distiction between Arr and X?
10:53:21 <merijn> aristid: Oh, I don't really use singletons
10:53:30 <merijn> aristid: I usually just encode variants directly
10:53:30 <aristid> merijn: what do you use datakinds for?
10:53:43 <lingxiao> so if I do "Type = Base | Base -> Base | Pair", "Pair = Type X Type"
10:53:45 <Iceland_jack> yes, since you shouldn't be able to do the same things to a product as you can do to a function
10:53:58 <merijn> aristid: So using DataKinds for phantom types in my data structures to distinguish variants, for example
10:54:04 <merijn> aristid: But I need to run :)
10:54:24 <lingxiao> so that "Type" and "Pair" are distinct types, that would make it different?
10:54:26 <aristid> merijn: ah yeah, so to do things that were possible before but now it's more type-/kind-safe
10:54:35 <lingxiao> or I could say Base = A () | Type X Type"
10:54:42 <merijn> aristid: Kind safe + prettier
10:54:45 <merijn> aristid: But yeah
10:54:47 <lingxiao> thereby, enriching the base, as you said like 100 lines ago
10:55:10 <aristid> merijn: now run like the wind:P
10:55:15 <Iceland_jack> yes something like that
10:55:29 <lingxiao> ahh ok I'm beginning to see the drift now
10:55:36 <lingxiao> thanks! You've been a big help
10:55:39 <Iceland_jack> no problem
10:56:20 <Iceland_jack> lingxiao: https://en.wikipedia.org/wiki/Generalized_algebraic_data_type#Higher-order_abstract_syntax
10:56:52 <Iceland_jack> That's one way of differentiating between products and functions on the type level
10:57:30 <Iceland_jack> STLC + products + fixed point + arbitrarily many base types
10:58:02 <Iceland_jack> It's actually parametric higher-order abstract syntax
10:58:20 <lingxiao> could you accomplish the same thing with GADTs?
10:58:31 <Iceland_jack> That is using GADTs
10:59:10 <lingxiao> ohhh.. I guess it's the kind quantification that confused me
10:59:18 <lingxiao> or explicity kind ..
10:59:21 <Iceland_jack> yeah that's unneccesary
10:59:28 <Iceland_jack> you could have
10:59:28 <Iceland_jack>     data Lam a where
10:59:28 <Iceland_jack>       ...
10:59:51 <Iceland_jack> using that you cannot construct something like
10:59:51 <Iceland_jack>     App (Tup foo bar) (Tup foo bar)
10:59:56 <lingxiao> ok ahh that speaks to me
11:00:21 <lingxiao> because "App  :: Lam (a -> b) -> Lam a -> Lam b"
11:00:26 <Iceland_jack> Also using HOAS you don't need to encode variables which saves a lot of time :) makes certain other things trickier though
11:00:27 <Iceland_jack> yes
11:00:43 <Iceland_jack> that goes for GADT's as well I guess..
11:01:27 <Iceland_jack> lingxiao: Encoding the untyped lambda calculus using HOAS is only two or three lines
11:01:51 <lingxiao> yeah ... for the sake of being masochistic, I did de-brujin's index for untyped, and am doing it for simply typed
11:01:58 <lingxiao> death by 1000 papercuts
11:01:58 <Iceland_jack> yeah
11:02:00 <leino> does anyone know if there is a way to get the number of consumed bytes when using attoparsec? I see that in attoparsec-0.7.2 there was a function Data.Attoparsec.getConsumed :: Parser Int64, but it seems to have been removed
11:02:23 <Iceland_jack>     data Untyped where
11:02:24 <Iceland_jack>       App ∷ Untyped → Untyped → Untyped
11:02:24 <Iceland_jack>       Abs ∷ (Untyped → Untyped) → Untyped
11:02:29 <ParahSailin> leino pipes-attoparsec has that
11:02:38 <Iceland_jack> Then you can define
11:02:39 <Iceland_jack>     λ   = Abs
11:02:39 <Iceland_jack>     (·) = App
11:02:39 <Iceland_jack>  
11:03:09 <leino> ParahSailin: thanks! I'll check it out
11:03:23 <lingxiao> haha yeah, it's funny because the meta language includes all functionalities of the target langauge, so it's like ... making a lever with a crane ... or w/e
11:03:24 <Iceland_jack> And you can encode
11:03:24 <Iceland_jack>     λ x. x x
11:03:24 <Iceland_jack> as
11:03:24 <Iceland_jack>     λ (\x → x · x)
11:03:27 <Iceland_jack>  
11:03:35 <Iceland_jack> which is very nice
11:03:36 <lingxiao> object langauge*
11:03:46 <Iceland_jack> or just
11:03:46 <Iceland_jack>     λ (join (·))
11:03:51 <Iceland_jack> if you're angry inside
11:03:51 <lingxiao> :t join
11:03:52 <lambdabot> Monad m => m (m a) -> m a
11:04:03 <lingxiao> lol angry inside
11:04:05 <Iceland_jack> :t join :: (r -> r -> a) -> r -> a
11:04:06 <lambdabot> (r -> r -> a) -> r -> a
11:04:29 <Iceland_jack> :t map (join replicate) [0..10]
11:04:30 <lambdabot> [[Int]]
11:04:32 <Iceland_jack> > map (join replicate) [0..10]
11:04:34 <lambdabot>  [[],[1],[2,2],[3,3,3],[4,4,4,4],[5,5,5,5,5],[6,6,6,6,6,6],[7,7,7,7,7,7,7],[8...
11:04:44 <lingxiao> funny your join is different than mine
11:04:53 <ParahSailin> leino: oh, you want something within parse monad, nevermind
11:04:54 <Iceland_jack> It is?
11:05:02 <Iceland_jack> (r →) is a monad
11:05:04 <lingxiao> hahah, the kind of code that's bound to confuse newbies, and me :\
11:05:24 <Iceland_jack> It is one of the more confusing Monad instances though
11:05:34 <Iceland_jack> but if you think of the definition as being
11:05:34 <Iceland_jack>     join f x = f x x
11:05:36 <Iceland_jack> it's not so bad
11:05:42 <Iceland_jack> > join (+) 5
11:05:43 <lambdabot>  10
11:05:44 <leino> ParahSailin: yeah, I need it to do the parsing itself in an efficient way (I think)
11:05:52 <Iceland_jack> > (\x -> x + x) 5
11:05:54 <lambdabot>  10
11:06:03 <lingxiao> so apply f onto x x times?
11:06:14 <Iceland_jack> just apply it to x twice, yes
11:06:24 <lingxiao> or apply x onto itself? in the context of f?
11:06:27 <ParahSailin> leino: unfortunately i dont think attoparsec keeps track of that state itself
11:06:31 <Iceland_jack> lingxiao: no no
11:06:36 <Iceland_jack> lingxiao: if you have
11:06:36 <Iceland_jack>     join f x
11:06:42 <Iceland_jack> then you can replace that with
11:06:43 <Iceland_jack>     f x x
11:06:57 <Iceland_jack> > (join (++)) "see? "
11:06:58 <lambdabot>  "see? see? "
11:07:01 <leino> ParahSailin: well it sure seems like it used to do that at some point, so I'm curious why it was removed
11:07:07 <Iceland_jack> > "see? " ++ "see? "
11:07:08 <lambdabot>  "see? see? "
11:07:40 <lingxiao> yeah funny it's hard to guess that from the signature "join :: Monad m => m (m a) -> m a"
11:07:47 <lingxiao> but you said "r ->" is a monad ..
11:07:56 <Iceland_jack> Exactly :) ((->) r) is a tricky instance
11:08:06 <flebron> >((++)<*>show)"((++)<*>show)"
11:08:13 <flebron> > ((++)<*>show)"((++)<*>show)"
11:08:15 <lambdabot>  "((++)<*>show)\"((++)<*>show)\""
11:08:33 <lingxiao> yeah i remember someone mentioned that when I first started haskell, I decided for the sake of sanity/focus to forget haha
11:08:35 <aleksejs_> http://vpaste.net/2BkzV is it possible to get rid of sortBy . group . sort?
11:08:56 <lingxiao> what's return for (->) r?
11:09:03 <Iceland_jack> lingxiao: Let's work it out!
11:09:06 <Iceland_jack> @ty return
11:09:07 <lambdabot> Monad m => a -> m a
11:09:21 <Iceland_jack> so
11:09:21 <Iceland_jack>     return ∷ Monad m ⇒ a → m a
11:09:21 <Iceland_jack>     
11:09:21 <Iceland_jack>  
11:09:32 <Iceland_jack> now let's replace all m's with (r →)'s
11:09:50 <Iceland_jack>     return ∷ a → ((r →) a)
11:10:00 <Iceland_jack>     return ∷ a → (r → a)
11:10:12 <Iceland_jack> @djinn a -> r -> a
11:10:12 <lambdabot> f a _ = a
11:10:21 <Iceland_jack> @src const
11:10:21 <lambdabot> const x _ = x
11:10:22 <Iceland_jack> it's const!
11:11:13 <lingxiao> ahh right it is haha
11:11:38 <Iceland_jack> lingxiao: You can thing of “r” as being an immutable environment
11:11:51 <Iceland_jack> *think
11:12:58 <lingxiao> so.. bind is running a computation in the immmutable env?
11:13:44 <Iceland_jack> yeah, it's the Reader monad basically
11:14:01 <lingxiao> (r -> a) -> (a -> (r -> b)) -> (r -> b)
11:14:02 <ParahSailin> @src (->) return
11:14:02 <lambdabot> return = const
11:14:08 <ParahSailin> @src (->) (>>=)
11:14:08 <lambdabot> f >>= k = \ r -> k (f r) r
11:14:21 <BassSultan> another question: if i do something like "instance Ord [a] where .. foo .. " then i get some error about overlapping instances for class ord. well i mean its likely that there already is some instance of [a] from prelude (or whereever) but shouldnt my own instance kinda override this?
11:14:35 <lingxiao> pretty sweet,
11:14:55 <EddyWestbrook> Hi, I am having trouble using "cabal haddock" in combination with an "Extensions: CPP" line in my cabal file. Is this a known issue?
11:15:13 <tomejaguar> BassSultan: No, there should be only ever be one matching instance in scope.  Use a newtype instead.
11:15:15 <triliyn> BassSultan: overriding instances are not allowed in standard haskell, because there's no way for a compiler to tell which one should take priority
11:15:20 <dcoutts> EddyWestbrook: don't think so, you'll have to explain
11:15:39 <BassSultan> tomejaguar: thx
11:15:48 <triliyn> (And actually I think if you're declaring two instances for the exact same type, even OverlappingInstances doesn't allow that)
11:15:49 <BassSultan> triliyn: thx
11:16:02 <BassSultan> ok ill do that. enough for today i guess
11:16:03 <BassSultan> cya
11:16:06 <EddyWestbrook> If I add "Extensions: CPP" to my cabal file, I get the following error output from "cabal configure; cabal haddock":
11:16:29 <dcoutts> EddyWestbrook: if it's long, use a pastebin
11:16:55 <EddyWestbrook> Running Haddock for hobbits-1.1.1... Preprocessing library hobbits-1.1.1...  <no location info>:     module `hobbits-1.1.1:Main' is defined in multiple files: dist/build/tmp-31502/Data/Type/List.hs                                                               dist/build/tmp-31502/Data/Type/List/List.hs                                                               dist/build/tmp-31502/Data/Type/List/Map.hs ...
11:17:04 <EddyWestbrook> (Sorry for the poor formatting: I'm new to IRC)
11:18:25 <EddyWestbrook> Here is my pastebin: http://pastebin.com/yGdtjabh
11:18:27 <mauke> The paste yGdtjabh has been copied to http://lpaste.net/98487
11:19:24 <dcoutts> EddyWestbrook: what version of cabal and haddock?
11:19:43 <Clint> how do i figure out why cabal --enable-executable-profiling isn't working?
11:19:52 <EddyWestbrook> cabal-install version 1.18.0.2,   Haddock version 2.13.2.1
11:20:02 <lingxiao> Iceland_jack: ok I'm off.Thanks for walking me through STLC and (r->)
11:20:03 <lingxiao> :D
11:20:22 <dcoutts> EddyWestbrook: hmm, well that's fairly normal
11:20:59 <EddyWestbrook> Yeah, and if I just remove "Extensions: CPP" from my cabal file, the haddock builds just fine
11:21:39 <dcoutts> EddyWestbrook: can one reproduce this with the released version of hobbits on hackage?
11:23:40 <EddyWestbrook> dcoutts: No, I didn't want to release this new version until I got the haddock to work. :)  But there is a release candidate at https://hackage.haskell.org/package/hobbits-1.1.1/candidate
11:24:38 <jrmithdobbs> I should be able to add let statements to a .ghci file in a project and have it actually setup that environment right? I'm trying to setup some simple dummy data in .ghci for interactive testing but nothing I set with let x = y in .ghci seems to be getting loaded
11:24:58 <dcoutts> EddyWestbrook: lemme see if I can reproduce...
11:25:12 <EddyWestbrook> dcoutts: ok, thanks so much for looking into this for me!
11:26:04 <jrmithdobbs> or am I missing something obvious?
11:26:04 <eazar001> anybody know why this returns "optimization suspended" in lambdabot local? ....
11:26:14 <eazar001> @pl not . (\x -> any (==x) $ tail $ subsequences [2,5])
11:26:14 <lambdabot> not . flip any (tail (subsequences [2, 5])) . (==)
11:26:22 <eazar001> > @pl not . (\x -> any (==x) $ tail $ subsequences [2,5])
11:26:23 <lambdabot>  <hint>:1:1: parse error on input `@'
11:26:29 <eazar001> oops
11:26:40 <eazar001> pl not . (\x -> any (==x) $ tail $ subsequences [2,5])
11:28:12 <eazar001> @pl not . (\x -> any (==x) $ tail $ subsequences [2,5])
11:28:12 <lambdabot> not . flip any (tail (subsequences [2, 5])) . (==)
11:28:14 <eazar001> yea
11:28:28 <eazar001> anyway why does this do optimization suspended in binary ^ ??
11:28:29 <augur_> sclv: im replied to your comment on reddit about containers. would you mind elaborating on the part i quoted?
11:30:34 <jmct> Does anybody know about the 'detailed' test suite type in cabal?
11:31:04 <jmct> Googling seems to bring up a lot of posts from a few years ago saying that it wasn't implemented yet
11:31:33 <adelbertc> jmct - quickcheck verbose?
11:32:16 <jmct> adelbertc: http://stackoverflow.com/questions/8266938/cabal-test-suite-with-type-detailed-example
11:34:01 <jmct> We were having trouble getting it working on our project, some searching led to that
11:37:13 <kristof> Is a monoid the actual function that is closed, associative, and has an identity, or is it the datatype that has that sort of combining function defined?
11:37:46 <adelbertc> the datatype has a monoid instance
11:37:50 <prooftechnique> A monoid is a structure
11:37:54 <shachaf> You can pick either one or a combination.
11:38:02 <kristof> uhhhh
11:38:02 <benmachine> kristof: it's the combination of the two, typically
11:38:06 <kristof> Ok
11:38:08 <kristof> So it's the whole system
11:38:15 <prooftechnique> Right
11:38:19 <kristof> So an integer with the plus operation and 0 as mempty is a monoid
11:38:29 <kristof> Not the integer, not +, but the combination of the two
11:38:30 <shachaf> If you have a function, you know its codomain, and if you're not being constructive about things, then it's probably enough that an identity exists for it.
11:38:44 <shachaf> Well, at least you know its domain. Which is good enough in this case.
11:39:01 <kristof> Is there something like monoids except relating to commutativity instead?
11:39:20 <shachaf> There's every algebraic structure you can think of.
11:39:27 <kristof> :)
11:39:27 <benmachine> heh
11:39:34 <benmachine> they are different amounts of interesting
11:40:16 <kristof> benmachine: I was talking in here earlier about adding half of an actor system to Haskell (I don't know enough Haskell to know if what I'm about to describe already exists)
11:40:31 <dcoutts> EddyWestbrook: what version of Cabal is cabal-install using? --version says
11:40:34 <shachaf> Associativity is much more popular than commutativity, though.
11:40:57 <kristof> benmachine: I don't really like the whole message-passing and blocking/receiving aspect of actors but I did like the "apply that state operation whenever you have the time" concept. And so I thought, hey, if you have this piece of state
11:41:06 <dcoutts> jmct: it exists but there's not much in the way of libs to support it yet
11:41:09 <EddyWestbrook> dcoutts: This is what "cabal --version" gives me:  cabal-install version 1.18.0.2 using version 1.18.1.2 of the Cabal library
11:41:17 <kristof> benmachine: And you knew EVERY possible state operation that was ever going to be applied to it
11:41:21 <EddyWestbrook> Is there maybe a problem with my cabal installation?
11:41:35 <kristof> benmachine: And you could prove that the aggregate of those operations is actually commutative, then...
11:41:44 <kristof> benmachine: Does it matter when those operations occur?
11:41:44 <dcoutts> Clint: start by looking at the error message you get
11:41:48 <kristof> like a counter, or a logger
11:42:02 <prooftechnique> kristof: Rock-paper-scissors is an example of a non-associative, commutative magma
11:42:25 <dcoutts> EddyWestbrook: just trying to reproduce
11:42:26 <jmct> dcoutts: thanks!
11:42:28 <shachaf> It is Wikipedia's example.
11:42:28 <kristof> benmachine: And so I got to thinking that if you could show the commutativity of all those state operations, then any compiler can actually transform seemingly synchronous code into code that is actually asynchronous in its state operations
11:42:30 <shachaf> https://en.wikipedia.org/wiki/Example_of_a_commutative_non-associative_magma
11:42:49 <benmachine> kristof: you can't inspect the state in between operations?
11:43:07 <Clint> dcoutts: there isn't one.. it just builds without -prof
11:43:12 <kristof> benmachine: Sure you can, if the data structure is a persisten collection
11:43:17 <kristof> benmachine: reading is inherently different from writing
11:43:49 <benmachine> kristof: I think you are expecting me to be better-informed on this than I am :P
11:43:50 <dcoutts> Clint: oh iirc there was some issue like that with an early point release of some Cabal version, fixed with a later point release in the same major version
11:43:53 <benmachine> but nonetheless
11:44:10 <kristof> Oh, sorry! This is an open question to anyone else listening, anyway
11:44:32 <Clint> dcoutts: does 1.16.0.2 sound like the right area?
11:44:37 <benmachine> you can I suppose think of your state and reads/writes over time, and most of these operations it doesn't matter what order they happen in, but it usually matters which writes happen between which reads
11:45:04 <dcoutts> Clint: quite possible, try 1.16.0.3
11:45:17 <Clint> ok, thanks
11:45:49 <kristof> benmachine: Huh? Why?
11:46:11 <benmachine> kristof: well, if you read some count, the amount you read is the number of writes that have happened, right?
11:46:17 <dcoutts> EddyWestbrook: I can't reproduce it yet due to a compile error: Data/Binding/Hobbits/PatternParser.hs Language.Haskell.Exts.Extension does not export KnownExtension(ViewPatterns)
11:46:28 <kristof> benmachine: yes
11:46:30 <benmachine> so whether a write happens before or after this read changes what you get
11:46:41 <kristof> benmachine: Why does that matter?
11:46:41 <EddyWestbrook> Oh, that's the old version of haskell-src-exts
11:46:54 <EddyWestbrook> dcoutts: Are you using GHC 7.6.3, or an older version?
11:46:55 <dcoutts> EddyWestbrook: probably I'm using the wrong haskell-src-exts version, but that's therefore a problem of the constraints in your .cabal file
11:46:59 <benmachine> kristof: well, if it doesn't matter what you get in the reads, why are you doing them? :P
11:47:01 <dcoutts> EddyWestbrook: 7.6.3
11:47:11 <dcoutts> EddyWestbrook: if you tell me the right haskell-src-exts version I can try
11:47:19 <dcoutts> EddyWestbrook: but do also fix the constraint
11:47:39 <kristof> benmachine: It doesn't matter in the sense that if I read 774 counts in one read instead of 775 in a massively parallel and possibly distributed system, I'm not going to lose sleep over it
11:47:42 <dcoutts> EddyWestbrook: I was using 1.13.5
11:47:58 <EddyWestbrook> dcoutts: the candidate version on hackage should have an #if for testing the version
11:48:01 <kristof> benmachine: I think Rich Hickey called this "stop the world mentality". The world moves really fast, and you should get over it!
11:48:07 <EddyWestbrook> (that's why I wanted to handle the CPP extension in the first place)
11:48:18 <EddyWestbrook> dcoutts: let me check...
11:48:52 <benmachine> kristof: hmm. if that's your philosophy, it sounds like your semantics are basically asynchronous
11:49:08 <dcoutts> EddyWestbrook: but the code imports the same thing in both branches of the #if
11:49:24 <benmachine> I don't think you can make this an issue of commutativity, because the answers /are/ different, just not in ways you care about
11:49:34 <benmachine> but perhaps I misunderstand
11:49:54 <EddyWestbrook> dcoutts: Yeah, the new version of haskell-src-exts just changed a type definition
11:50:11 <EddyWestbrook> dcoutts: Hmm, wait a sec, maybe the problem is having an import inside of an #if?
11:50:11 <kristof> benmachine: Not always, just when it counts. I started this thought with the assumption that a piece of state which has nondeterministically ordered state transformations is ISOMORPHIC to an actor (that cannot send messages on its own)
11:50:23 <Thooms> anyone going/talking at FOSDEM this year here :) ?
11:50:31 <EddyWestbrook> dcoutts: No, scratch that, I commented that out in my local copy
11:50:32 <kristof> benmachine: No the answers AREN'T different at the very end! :) The logging counter or whatever will have the same count at the end of ALL operations, no matter what
11:50:38 <kristof> hence commutativity of the aggregate
11:50:49 <dcoutts> EddyWestbrook: trying haskell-src-exts-1.14.0...
11:51:23 <solarus> EddyWestbrook: dcoutts It worked for (I could build the haddock documentation) using the same cabal, cabal-install and haddock versions as Eddy
11:51:39 <kristof> benmachine: Anyway, the point of all this is that instead of having synchronous code, you can let that piece of state and all its operations run in some physical/logical thread all on its own, which the compiler decides to do and the programmer doesn't have to worry about. My next question is: is this even worth the analysis? :P
11:51:44 <solarus> haskell-src-exts is 1.14.0 also
11:52:23 <kristof> I guess you can call this "implicit asynchronous transformation". Or maybe "implicit actor transformation"
11:53:29 <EddyWestbrook> solarus: thanks for trying it out. It really built the haddock just fine?
11:54:39 <EddyWestbrook> Maybe there is something else wrong with my cabal / haddock installation...?
11:54:41 <solarus> EddyWestbrook: yes worked fine
11:55:02 <jrmithdobbs> bleh, it's some cabal repl weirdness
11:55:03 <benmachine> kristof: my answer is I have no idea, I wish you luck finding out
11:55:39 <solarus> EddyWestbrook: I might add that I built it in a sandbox but that shouldn't matter
11:55:46 <dcoutts> solarus: exact same haddock version? I'm actually using a slightly different version 2.13.2, rather than EddyWestbrook's 2.13.2.1
11:56:27 <dcoutts> jrmithdobbs: mm?
11:57:12 <jrmithdobbs> dcoutts: cabal repl is doing something that's un-setting things set with let in .ghci
11:57:29 <solarus> dcoutts: I have 2.13.2 in /usr/bin/haddock but also installed 2.13.2.1 locally with cabal
11:57:45 <dcoutts> jrmithdobbs: I suspect we're ignoring .ghci files because we're producing the exact same env as is used for build
11:57:46 <jrmithdobbs> dcoutts: was just trying to add a let teststring = "something", basically
11:58:19 <jrmithdobbs> dcoutts: no it loads it and respects all the imports and :set -X stuff, i can even get parse errors if i mess up the let statements intentionally
11:58:35 <jrmithdobbs> dcoutts: it then drops the definitions
11:58:40 <dcoutts> jrmithdobbs: hmm, ok. Perhaps I should make it explicitly ignore .ghci files ;-)
11:59:13 <jrmithdobbs> dcoutts: if you do can you read a .cabal-repl file instead for setting up repl env stuff like that?
11:59:43 <jrmithdobbs> dcoutts: i guess you'd have to do .cabal-repl-target or something though
11:59:47 <dcoutts> jrmithdobbs: if you want to try and debug, you can see how cabal is invoking ghci
12:00:09 <listofoptions> edwardk: ok so I don't think I'm using the to/from scope functions properly http://lpaste.net/98481
12:00:18 <dcoutts> jrmithdobbs: I don't think we're doing anything odd and we don't yet use our own extra ghci files to override macros
12:00:36 <listofoptions> the typeOf function doesnt work but the nf function does?
12:01:11 <jrmithdobbs> dcoutts: where is it invoking it?
12:01:32 <dcoutts> jrmithdobbs: oh I just mean run with -v and it'll print the command its invoking
12:02:54 <EddyWestbrook> dcoutts, solarus: should I just try a clean re-install of the Haskell Platform...?
12:03:14 <dcoutts> solarus: ta
12:03:39 * hackagebot sourcemap 0.1.3.0 - Implementation of source maps as proposed by Google and Mozilla.  http://hackage.haskell.org/package/sourcemap-0.1.3.0 (ChrisDone)
12:03:48 <dcoutts> EddyWestbrook: can try. If we cannot reproduce it then it's hard to do much with.
12:04:05 <dcoutts> EddyWestbrook: before you do, make a paste with the output of doing cabal configure -v3; cabal haddock -v3
12:04:14 <chrizz_> hi, is deriving Generic still possible? I'm getting a compiler error with "data Foo = Foo deriving Generic" and -XDeriveGeneric
12:04:22 <dcoutts> EddyWestbrook: plausible we could spot something
12:04:46 <chrizz_> on 7.6.3
12:04:53 <dcoutts> EddyWestbrook: and possibly the content of one of the files it's complaining about, since it seems to think that *all* of them contain Main
12:05:03 <dcoutts> EddyWestbrook: which actually could happen if they were all empty
12:05:54 <EddyWestbrook> dcoutts: ok, working on it...
12:05:55 <c_wraith> dcoutts: what's the cabal-install release schedule like, anyway? (what order of time should I be waiting for a fix to the bug I brought up yesterday? weeks? months?)
12:06:48 <dcoutts> c_wraith: it's a bit variable, we make sure we have releases in time for ghc, and otherwise depends what features/fixes we have
12:06:59 <dcoutts> c_wraith: and of course reporting a bug does not guarantee a fix sadly
12:07:11 <dcoutts> unless you send us a pull req :-)
12:07:30 <EddyWestbrook> dcoutts: Another data point: I am on XCode 5 on mac, and so am using the clang-wrapper-xcode5 script to wrap gcc, which is here: https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=0CCsQFjAA&url=https%3A%2F%2Fgithub.com%2Fghc-ios%2Fghc-ios-scripts%2Fblob%2Fmaster%2Fclang-xcode5-wrapper.hs&ei=TJfVUquMJcrEoATzyYGoCg&usg=AFQjCNHviAhQ33fMylVVezqXYGLVDhSlzQ&sig2=x0c76O3A0BVw58_BlHDW5w&bvm=bv.59378465,d.cGU
12:07:55 <jrmithdobbs> dcoutts: ya I can't see why it's doing that, must be related to how hide packages stuff works
12:07:56 <EddyWestbrook> dcoutts: Oh crap, I just realized: cabal haddock is using /usr/bin/gcc, not the wrapper
12:08:03 <dcoutts> EddyWestbrook: ooooh, then it could well be that it's because Cabal invokes cpp directly, and that's not wrapped
12:08:09 <dcoutts> EddyWestbrook: and cpp is busted
12:08:23 <EddyWestbrook> dcoutts: yeah; is there a way I can tell cabal to use the clang wrapper?
12:08:32 <dcoutts> EddyWestbrook: --with-gcc=
12:08:36 <zackattack> Why am I getting an error for this statement?
12:08:38 <zackattack> not (take 10 (cycle [5])) == (take 10 (repeat 5))
12:08:40 <EddyWestbrook> dcoutts: Ahh, right
12:08:45 <zackattack> Couldn't match expected type `Bool' with actual type `[a0]'
12:09:03 <dcoutts> EddyWestbrook: could you check if invoking the cpp there gives an error or just fails silently?
12:09:16 <jrmithdobbs> dcoutts: i'll just add a dumb .TestData module for now =/
12:09:18 <dcoutts> EddyWestbrook: ideally cabal should have failed at the point where the cpp failed
12:09:47 <geekosaur> not applies to the first parenthesized thing, not the == but the take 10 (cycle [5])
12:10:13 <geekosaur> which is not a Bool but a list
12:10:35 <geekosaur> zackattack, ^^
12:11:07 <zackattack> geekosaur:  got it.. thanks
12:11:32 <EddyWestbrook> dcoutts: I think it probably just failed silently; here is the log output: http://pastebin.com/cYpzmZTY
12:11:36 <mauke> The paste cYpzmZTY has been copied to http://lpaste.net/98489
12:11:44 <c_wraith> dcoutts: good greif, the cabal repo is huge! :P
12:12:26 <dcoutts> EddyWestbrook: could you try one of those cpp commands in the shell and see what exit code it produces
12:13:11 <dcoutts> EddyWestbrook: I would like to know if it's our fault for ignoring an exit code or not
12:13:24 <EddyWestbrook> dcoutts: Do you mean the cpphs, or the ghc commands with option -cpp?
12:13:37 <dcoutts> EddyWestbrook: the latter, it's not using cpphs is it?
12:13:39 <shachaf> c_wraith: Does Gabor have an evil twin?
12:14:15 <EddyWestbrook> dcoutts: no, I guess I only saw the result of it searching for cpphs. Hold on a sec...
12:14:16 <c_wraith> shachaf: doesn't everyone?
12:15:04 <c_wraith> git clone was 21 megs.
12:16:38 <EddyWestbrook> dcoutts: it looks like it succeeds (I did an "|| echo 'Failed'" and did not get Failed on the output)
12:16:53 <dcoutts> EddyWestbrook: ok, that concurs with the code dive I just did
12:17:01 <dcoutts> EddyWestbrook: so there's not a lot better we could have done here
12:17:16 <augur_> what are the options right now for having data-type permeability, as in   repeat :: (n :: Nat) -> a -> Vec a n   ?
12:17:32 <EddyWestbrook> dcoutts: But, wait a sec, I have changed my GHC settings to use the clang-wrapper binary
12:17:47 <augur_> is SHE the only option?
12:17:56 <EddyWestbrook> dcoutts: So the broken version of clang should not matter here... right?
12:18:04 <c_wraith> augur_: you can do that with GHC 7.6
12:18:11 <augur_> oh?
12:18:16 <augur_> with datakinds?
12:18:18 <dcoutts> EddyWestbrook: for cpp or just for cc?
12:18:28 <c_wraith> augur_: and type literals, as in GHC.TypeLits
12:18:41 <dcoutts> EddyWestbrook: can only really answer that by looking at the wrapper script
12:18:41 * hackagebot fay 0.19 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.19 (AdamBergmark)
12:18:43 * hackagebot fay-base 0.19 - The base package for Fay.  http://hackage.haskell.org/package/fay-base-0.19 (AdamBergmark)
12:18:45 * hackagebot fay-text 0.3.0.1 - Fay Text type represented as JavaScript strings  http://hackage.haskell.org/package/fay-text-0.3.0.1 (AdamBergmark)
12:18:57 <dcoutts> EddyWestbrook: erm, your ghc settings
12:19:24 <c_wraith> augur_: except you can't *quite* do that, because n is a type, not a value.  however, you could just have repeat :: a -> Vec a (n :: Nat)
12:19:52 <augur_> c_wraith: how would you match on n tho?
12:20:03 <augur_> you'd need to do   repeat Zero _ = Nil
12:20:09 <augur_> to know when to stop!
12:20:14 <c_wraith> augur_: it's a type. All the normal ways you match on a type.
12:20:22 <c_wraith> augur_: type families, for instance
12:20:28 <augur_> oh, blegh.
12:20:30 <EddyWestbrook> dcoutts: Here is my settings file for GHC, along with a link to the source for clang-wrapper
12:20:40 <augur_> c_wraith: you could do this with SHE :|
12:20:53 <c_wraith> augur_: you can also use the singleton stuff in GHC.TypeLits
12:21:01 <augur_> maybe maybe
12:21:06 <c_wraith> augur_: that will demote the type to a value
12:23:18 <augur_> btw what the hell is aspect oriented programming? i've never understood this. mcbride hints that dependent types might offer a solution to the problem?
12:23:41 <EddyWestbrook> dcoutts: Whoops, forgot to paste the link: http://pastebin.com/iHif58gv
12:23:42 <c_wraith> augur_: aspect-oriented programming is about breaking up your code according to functionality, rather than ordering
12:23:43 <mauke> The paste iHif58gv has been copied to http://lpaste.net/98490
12:24:01 <c_wraith> augur_: and then supplying some additional glue data to connect the bits of functionality in the right order
12:24:02 <augur_> c_wraith: hm. hows that work then
12:24:39 <dcoutts> EddyWestbrook: mm, I don't know if that applies to doing cpp, but you can always check
12:24:53 <c_wraith> augur_: a primitive example is using java annotations to trace call stacks..  All the tracing code goes in one spot.  Then placing the annotation is the indicator "this is where that code is active".
12:25:00 <dcoutts> EddyWestbrook: the example you tried, use -v and see what program ghc invokes
12:25:04 <augur_> c_wraith: i dont know java :D
12:25:07 <EddyWestbrook> dcoutts: I tried moving /usr/bin/cpp to /usr/bin/cpp-clang...
12:25:12 <EddyWestbrook> dcoutts: ok, one sec
12:25:14 <c_wraith> augur_: This isn't a great example, but it's a pretty simple one.
12:25:17 <augur_> :)
12:25:40 <augur_> also just noticed: flipped eval is often a continuationy type. thats very sexy
12:25:57 <dcoutts> EddyWestbrook: oh, or is cabal invoking ghc with one of the -pgm flags?
12:26:32 <dcoutts> mm, from the code looks like not
12:27:14 <dleedev> hi, can a single file host multiple modules in ghc?
12:28:24 <EddyWestbrook> dcoutts: I don't think it is using a -pgm flag
12:29:10 <EddyWestbrook> dcoutts: Not sure if this means anything, but when I do "cabal info cabal-install" it says the version installed is unknown...
12:29:12 <simon> dleedev, https://ghc.haskell.org/trac/ghc/ticket/2551
12:29:31 <simon> dleedev, that is, no and it won't happen.
12:29:32 <dcoutts> EddyWestbrook: no, that's usual
12:30:07 <dleedev> simon: got it, thanks
12:30:24 <simon> dleedev, or rather, when I look at the comments, it seems it hasn't been discussed at length. but my guess is that it won't be added.
12:30:30 <EddyWestbrook> dcoutts: Might it matter that I currently have two versions of the cabal library installed?
12:30:44 <dcoutts> EddyWestbrook: shouldn't do
12:31:15 <dcoutts> EddyWestbrook: did you get the output of running that ghc -E -cpp -v  command?
12:33:33 <kristof> Is it an oversimplication to say that the primary purpose of monads is to extract basic-values from monadic-values?
12:33:41 <kristof> I.e. to get some values of out "contexts"?
12:34:38 <kristof> Am I missing some greater or more powerful use of monads?
12:34:39 <listofoptions> I keep getting: "Could not deduce (a ~ Var (Name a ()) a)" from typeOf, but not nf, and they both use the toScope and fromScope functions similarly :/ http://lpaste.net/98481
12:36:08 <EddyWestbrook> dcoutts: yeah, sorry, here it is: http://pastebin.com/qvXNP74p
12:36:10 <mauke> The paste qvXNP74p has been copied to http://lpaste.net/98493
12:36:34 <Iceland_jack> kristof: How exactly do you extract ‘basic-values’ from monadic ones?
12:36:46 <Iceland_jack> I assume by basic values you mean values not on the form
12:36:47 <Iceland_jack>     Monad m ⇒ m a
12:37:02 <dcoutts> EddyWestbrook: ok, so unclear why we're getting the odd output then. That is clearly invoking the /usr/bin/clang-wrapper
12:37:25 <kristof> Iceland_jack: right
12:37:47 <Iceland_jack> kristof: Monad provide no way of doing that
12:37:49 <kristof> Iceland_jack: [1, 2, 3] could be a monadic value and each basic value is 1, 2, and 3
12:37:57 <Iceland_jack> *provides
12:38:15 <Iceland_jack> There is no function
12:38:15 <Iceland_jack>     Monad m ⇒ m a → a
12:38:19 <EddyWestbrook> dcoutts: Well, I would just ignore it, but it also looks like my candidate build on hackage fails to build documentation...
12:38:20 <kristof> ...ah
12:38:39 <dcoutts> EddyWestbrook: oh that's a different issue most likely
12:38:42 <Iceland_jack> There are such functions for individual monads
12:38:42 <Iceland_jack>     fromJust ∷ Maybe a → a
12:38:42 <listofoptions> kristof: perhaps you want a commonad
12:38:49 <flebron> It sometimes won't even make sense to have such a function.
12:38:56 <dcoutts> EddyWestbrook: I think our doc builder system is currently not working for candidates
12:39:02 <Iceland_jack> listofoptions: They're not looking for something but trying to understand
12:39:07 <brill> I have a really noob question. Why does runhaskell return Not in scope: main?
12:39:08 <listofoptions> *comonad
12:39:31 <Iceland_jack> kristof: Monads provide computational context, that's a nice simplification
12:39:33 <benmachine> brill: it expects there to be a value called main, so it can run it
12:39:37 <flebron> For instance, in the ((->) r) monad, were you to get f :: m a -> a, that would mean you have f :: (r -> a) -> a.
12:39:37 <geekosaur> brill: what are you feeding it?
12:39:39 <shachaf> brill: Because you haven't defined it, probably.
12:39:41 <EddyWestbrook> dcoutts: oh, I see... I figured it was something wrong with my package. I'm going to try uploading it without the CPP extension aanyway, to see if it builds the documentation...
12:39:41 <benmachine> presumably there isn't one
12:39:47 <geekosaur> runhaskell is not just ghci for files; it expects full programs
12:40:01 <brill> No main. Just a .hs file.
12:40:10 <shachaf> What do you expect it to do?
12:40:12 <dcoutts> EddyWestbrook: I'd stick with the CPP, it's only borked OSX where it's an issue
12:40:21 <geekosaur> and, like c / c++ / java, there must be entry point called main
12:40:28 <dcoutts> EddyWestbrook: otherwise it'll break everywhere
12:40:45 <flebron> A .hs is usually just a bunch of definitions. It's not clear how one would run a bunch of definitions.
12:40:52 <geekosaur> it's not a scriping language like ruby / python / perl where it just does stuff
12:40:58 <Iceland_jack> But it is incorrect to say that the purpose of monads is to extract values from monadic values, since that not possible
12:41:22 <Iceland_jack> The reverse is quite possible though
12:41:22 <Iceland_jack> @ty return
12:41:23 <lambdabot> Monad m => a -> m a
12:41:47 <EddyWestbrook> dcoutts: ok, yes, it still doesn't build the documentation. :)
12:42:28 <EddyWestbrook> dcoutts: Alright, since you can't reproduce the problem, I will just assume it is something wrong with my machine, and just let hackage build my documentation for me
12:42:36 <EddyWestbrook> dcoutts: Thanks so much for looking into this for me...
12:42:39 <dcoutts> np
12:46:12 <brewbrew> writeFile "file.txt" "hello" >> readFile "file.txt" >>= \t -> removeFile "file.txt" >> putStrLn t  -- This runs fine on OS X, but not on windows. Anybody knows a way to make it work?
12:48:30 <brewbrew> On windows i get this error message: *** Exception: DeleteFile "file.txt": permission denied (The process cannot access the file because it is being used by another process.)
12:48:43 <dmwit> brewbrew: Yes, use the strict package.
12:48:45 * hackagebot hobbits 1.1.1 - A library for canonically representing terms with binding  http://hackage.haskell.org/package/hobbits-1.1.1 (EddyWestbrook)
12:48:46 <dmwit> ?hackage strict
12:48:46 <lambdabot> http://hackage.haskell.org/package/strict
12:49:20 <dmwit> (for the readFile part)
12:49:55 <dmwit> Alternately, run a real OS in a VM or something. ;-)
12:52:25 <brewbrew> dmwit: Yeah, that'll work too ;)
12:53:12 <brewbrew> dmwit: thanks it worked with a strict read.
12:53:45 * hackagebot BlogLiterately 0.7.1 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.7.1 (BrentYorgey)
12:58:41 <ehelin> hi all, I was wondering if Haskell being pure implies that it must use lazy evaluation? I know that being pure enables lazy evaluation, but does being pure also *require* lazy evaluation?
12:59:11 <flebron> Nope.
12:59:25 <profmakx> idris is pure, is eager too
12:59:46 <shachaf> "pure" is kind of ill-defined anyway.
13:00:13 <shachaf> The Report specifies that Haskell has non-strict semantics, which is usually implemented with lazy evaluation.
13:00:24 <ehelin> thanks for your answers! is there anything else that "forces" Haskell to use lazy evaluation? Or was it considered a very nice feature of Haskell when it was being invented?
13:00:51 <flebron> Other languages have strict evaluation, around Haskell's time there was also ML.
13:01:27 <Iceland_jack> ehelin: Lazy evaluation allows for modularity
13:01:33 <Iceland_jack> @src all
13:01:34 <lambdabot> all p =  and . map p
13:01:34 <shachaf> From what I hear, laziness was a goal, and that kept them honest and forced them to keep purity.
13:02:08 <ehelin> ok, I'm not saying lazy evaluation is a bad thing at all (on the contrary) and I understand the gains, I was merely curious about why the inventors chose it :)
13:02:20 <ehelin> shachaf: ah ok
13:02:32 <ehelin> Iceland_jack: yes, interesting point
13:03:01 <listofoptions> stupid disconects :(
13:03:02 <Iceland_jack> ehelin: Well it's not why they chose it for Haskell, Haskell was invented to explore things such as lazy evaluation
13:06:06 <flebron> SPJ has described Haskell, at least its current state, as a type system laboratory.
13:06:49 <tdammers> I've heard people say that the premise in designing Haskell was to take purity and lazy evaluation and see how far you could take it
13:07:09 <ehelin> ok, well they certainly got quite far :)
13:07:21 <dmwit> ehelin: http://stackoverflow.com/q/7868507/791604 <- "Why laziness?"
13:07:23 <ehelin> thanks for all your comments! I
13:07:48 <ehelin> always think it's fun to learn about the reasons features were added to programming languages
13:08:40 <Iceland_jack> ehelin: indeed :) except it's not really a feature added to the language but rather its raison d'être
13:08:47 * hackagebot haskell-packages 0.2.3.3 - Haskell suite library for package management and integration with Cabal  http://hackage.haskell.org/package/haskell-packages-0.2.3.3 (RomanCheplyaka)
13:09:52 <Iceland_jack> laziness was a hot topic back then
13:11:22 <exDM69> it's probably easier to eagerly evaluate expressions in a lazy programming language than it is to do the opposite
13:11:35 <exDM69> doing lazy evaluation in eager languages is usually quite difficult
13:11:40 <Iceland_jack> oh no doubt
13:12:15 <Iceland_jack> we have seq and NFData
13:12:25 <flebron> Well... doing it prettily perhaps. Doing it uglily is just how Haskell does it internally.
13:12:40 <flebron> i.e. assembly is eager, and Haskell puts thunks on top.
13:12:52 <Iceland_jack> And where laziness is in the way (like in parallelism) you can use NFData to take care of that
13:13:04 <jrmithdobbs> flebron: i dunno, so long as you have lambdas and a contair that can hold them you can even do it semi-pretty
13:13:19 <Iceland_jack> I personally think NFData should be a part of the language :)
13:13:22 <flebron> Sure, with monads :)
13:13:24 <jrmithdobbs> flebron: eg, ruby abuses Proc#call like this ;p
13:17:05 <jrmithdobbs> so, these two statements end up with the same results, but if the list gets bigger is there an advantage to the second form (ignoring tediousness of typing out the || cases):
13:17:08 <jrmithdobbs> (not.(\x -> x=='%'||x=='\\')) = not.or.([(=='%'),(=='\\')] <*>).pure
13:18:14 <listofoptions> jrmithdobbs: gesundheit
13:18:17 <flebron> `notIn` "%\\"
13:18:25 <dmwit> Yeah, use notElem.
13:18:29 <flebron> Err, notElem.
13:18:35 <flebron> Bad LaTeX, bad.
13:18:48 * hackagebot HCodecs 0.3 - A library to read, write and manipulate MIDI, WAVE, and SoundFont2 files.  http://hackage.haskell.org/package/HCodecs-0.3 (DonyaQuick)
13:19:01 <dmwit> Or use a Set if there's a lot of them.
13:19:33 <jrmithdobbs> :src notElem
13:19:42 <dmwit> ?src notElem
13:19:42 <lambdabot> notElem x =  all (/= x)
13:20:14 * flebron wonders why not (not .) . elem
13:20:37 <ion> cringe
13:21:34 <jrmithdobbs> ?src all
13:21:34 <lambdabot> all p =  and . map p
13:22:41 <joelteon> flebron: elem short-cirtuis
13:22:43 <joelteon> circuits*
13:22:54 <dmwit> joelteon: so?
13:23:01 <joelteon> oh wait
13:23:03 <joelteon> that doesn't make sense lol
13:24:11 <exicer> If I want to completely uninstall haskell/cabal etc, prior to a reinstall, on osx, what do I need to do ?
13:25:24 <kristof> I don't use OSX but I believe applications have their own folders
13:26:08 <johnw> kristof: an application is a folder containing special files
13:26:30 <exicer> I think I have worked it out
13:26:32 <kristof> johnw: Well what I meant was literally along the lines of /home/Applications
13:26:39 <johnw> ah
13:26:40 <exicer> Either that or I have completely messed it up :p
13:26:49 <johnw> usually /Applications and $HOME/Applications
13:28:33 <geekosaur> /Library/Haskell, ~/Library/Haskell
13:28:50 * hackagebot Stream 0.4.6.2 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.6.2 (WouterSwierstra)
13:33:10 <dmwit> > inits undefined
13:33:12 <lambdabot>  [[]*Exception: Prelude.undefined
13:33:14 <jrmithdobbs> flebron: so basically from some experimentation,  not.or.([] <*>).pure and flip notElem.pure will most likely get compiled down to equiv code?
13:33:25 <dmwit> Oooo, Wouter is lying in his docs!
13:34:14 <flebron> > :t inits
13:34:15 <lambdabot>  <hint>:1:1: parse error on input `:'
13:34:26 <flebron> What was the command for that?
13:34:26 <Roklobsta> any of you guys do intense numeric computation with haskell?
13:35:36 <johnw> Roklobsta: there are some, but they may not be online just now
13:35:53 <johnw> I think carter does some of that
13:36:06 <Roklobsta> ok i'll ask again later.
13:36:08 <boom583> Are all/most Haskell programs just a series of "imperative" steps within main, which one after another call the pure functions?
13:36:12 <dmwit> ?where justask
13:36:13 <lambdabot> Just ask your question. If somebody knows, they'll answer. If not, they won't, and you'll wait around; it will be no worse than having nobody who wants to claim expertise.
13:38:12 <dmwit> boom583: I wonder: does your plan for the future differ depending on what answer we give?
13:38:20 <johnw> boom583: a lot of programs have a "backbone" in IO, with lots of the real functionality living in pure functions
13:38:39 <boom583> dmwit: no i'm just curious..
13:38:41 <boom583> still learning
13:38:48 <boom583> johnw: ok
13:38:51 * hackagebot Stream 0.4.7 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.7 (WouterSwierstra)
13:39:13 <boom583> i'm wondering if anything else is even possible. can you decide one day to insert IO deep into a pure stuff?
13:39:15 <boom583> sounds hard
13:39:28 <boom583> say you want to output intermediate calculations
13:39:31 <boom583> for debug purposes
13:39:32 <dmwit> No, once you're in IO, you're in IO for the duration.
13:39:33 <boom583> or whatever
13:39:35 <boom583> ok
13:39:50 <johnw> boom583: well, you *can*, but you really should not
13:39:58 <dmwit> There are some tricks people like to pull for debugging, and for FFI interfaces to particularly clean libraries.
13:40:07 <dmwit> But for the nonce, you should proceed as if those tricks did not exist.
13:40:19 <boom583> ok
13:40:28 <johnw> many of my hardest Haskell bugs were due to me calling a function whose name began with "
13:40:30 <johnw> unsafe"
13:40:38 <johnw> and realizing the hard way why it has that prefix
13:41:11 <mello__> why if you 'shadow' (it's probably the wrong word) a type, it's not strict anymore? I.e. data Foo = MkFoo Float
13:41:25 <mello__> i mean that now MkFoo(bottom) != bottom
13:41:27 <mello__> why?
13:41:30 <Iceland_jack> boom583: Wondering about imperativeness may be the wrong way to think about it :) you can be imperative while being pure and functionally code something effectful
13:41:31 <johnw> mello__: because you didn't use newtype
13:41:46 <roboguy_> mello__: data is lazy and newtype is strict
13:41:50 <Iceland_jack> boom583: It's better to realize that Haskell makes a distinction between evaluation and execution
13:42:48 <mello__> roboguy_ ok, i know a bit about haskell's lazyness, but is it then just because a constructor is already in WHNF?
13:42:58 <dmwit> Also: no, not all "main" functions are just a series of imperative steps. Many do some non-trivial computation before evaluating to a series of imperative steps.
13:43:16 <johnw> mello__: if you have data Foo a = Foo a, you can pattern match on Foo without needing to evaluate a
13:43:30 <dmwit> mello__: Yes, precisely.
13:43:33 <roboguy_> mello__: yeah. when you evaluate MkFoo bottom, it goes from _ to MkFoo _ (where _ is a thunk)
13:43:45 <boom583> Iceland_jack: ok..
13:44:08 <boom583> evaluation of pure funcs?
13:44:16 <boom583> execution of steps in main?
13:44:17 <mello__> ooh, okay
13:44:23 <mello__> thanks roboguy_, johnw
13:44:26 <roboguy_> mello__: if you define the type with newtype, it MkFoo bottom == bottom
13:44:45 <Iceland_jack> boom583: You can evaluate an impure action without running it
13:44:57 <mello__> roboguy_:you got any good resources where I can read about the lazyness of haskell & strictness?
13:45:09 <mello__> I understand some of it, but this explains
13:45:48 <roboguy_> mello__: well, I can't think of anything off the top of my head I'm afraid. you could probably find some by searching for whnf and newtype vs data haskell.
13:46:05 <roboguy_> mello__: the reason newtype works this way is because it has no runtime overhead (mostly)
13:46:09 <johnw> mello__: http://www.vex.net/~trebla/haskell/lazy.xhtml
13:46:36 <roboguy_> in ghc 7.8, newtype will fully live up to it's promise of no runtime overhead thankfully
13:46:44 <johnw> ^^ great article by monochrom, everyone should read it at some point
13:46:47 <jrmithdobbs> so it looks like elem/notElem still end up in a foldr (in any/all) is there another set of predicate testing functions that actually stop evaluation on true/false result or am I overthinking?
13:46:52 <mello__> ok :) thanks roboguy_ johnw if i have more questions or uncertainties i will fire away :)
13:47:00 <dmwit> jrmithdobbs: foldr stops early.
13:47:05 <rtpg> what sort of runtime overhead does newtype have for the moment?
13:47:19 <dmwit> > notElem '3' ('4':'3':undefined)
13:47:20 <lambdabot>  False
13:47:24 <mgsloan> Maybe it's just because I like hasse diagrams, but I also found the diagrams here to be pretty informative: http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
13:47:53 <roboguy_> rtpg: basically, when you have something like map SomeNewtype xs
13:48:03 <roboguy_> the map does nothing, but it takes time still
13:48:23 <rtpg> huh, interesting
13:48:24 <johnw> roboguy_: isn't that going to be fixed in 7.8?
13:48:29 <roboguy_> johnw: yep!
13:48:43 <rtpg> so SomeNewtype is basically id ? and it still goes in there?
13:48:52 * hackagebot xturtle 0.1.23 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.23 (YoshikuniJujo)
13:49:15 <mgsloan> rtpg: Its runtime behavior is like id, but to the type system it's not
13:49:28 <rtpg> right
13:49:35 <roboguy_> they're going to have a type class to do conversions between newtype and the type it wraps and it will be optimized out at compile time in ghc 7.8
13:49:56 <roboguy_> I think it's called Coerceable or something like that
13:50:23 <roboguy_> it will be able to do newtype conversions inside containers like list and the compiler will optimize it out
13:53:53 * hackagebot Stream 0.4.7.1 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.7.1 (WouterSwierstra)
13:54:09 <exicer> Hm, I've just installed the haskell-platform using brew on osx, but it doesn't seem to provide a "haskell" command to the commandline
13:54:15 <exicer> Is this supposed to be the case ?
13:54:20 <Rembane> exicer: Try ghc and ghci
13:54:31 <dhrosa> exicer: the language is haskell, the compiler is ghc, the interactive prompt is ghci
13:54:34 <Rembane> exicer: Yes, there's no haskell command
13:54:38 <johnw> or "runhaskell"
13:54:42 <dhrosa> well, one of the compilers is ghc
13:55:09 <exicer> Ah ok
13:55:31 <_2_Angie> hola
13:55:34 <dhrosa> runhaskell will take a haskell source, compile it, and run it, all at once
13:58:25 <Sonarpulse> could IO be made a type synnonym for ST RealWord, or would that mess up instance resolution?
13:58:27 <mercuryrising> does runhaskell compile if the source hasn't changed?
13:59:27 <dmwit> I don't think runhaskell compiles at all.
13:59:33 <dmwit> It's interpreted.
13:59:49 <mercuryrising> ah yeah you're right
14:00:16 <roboguy_> it still runs it even if the source hasn't changed
14:00:41 <roboguy_> that's why you can do things like "runhaskell Setup.hs configure; runhaskell Setup.hs build; runhaskell Setup.hs install"
14:00:48 <geekosaur> it "compiles" but there is currently no mechanism to save / load bytecode
14:01:53 <mercuryrising> so it kinda loads it under ghci, rather than running ghc on it?
14:02:02 <gwern> http://www.reddit.com/r/haskell/comments/1v80ld/summer_of_code_2013_retrospective/ if anyone wants to argue about 2013 results
14:06:55 <rs0> gwern: what do you mean about Cabal & GHC possibly being dangerous?
14:08:10 <aristid> rs0: he left immediately after posting the link.
14:08:22 <rs0> aristid: okay, no wonder tab-completion wasn't working
14:08:52 <c_wraith> knowing what I do about gwern, my guess is that the complaint is that it's a monoculture
14:09:18 <rs0> hmm
14:10:25 <aristid> c_wraith: how so?
14:11:17 <c_wraith> aristid: if you want to use haskell, you tend to use GHC, and you tend to use cabal.  And the more people lean on their specific features, the more lockin there is
14:11:48 <rs0> aristid: there are tons of Glasgow extensions that seem to be de-facto mandatory in real world code, and i don't know how many of those are supported by UHC or Hugs or some other Haskell compiler
14:12:27 <geekosaur> cabal makes some attempt at compatibility with other implementations. the problem being, there aren't many other implementations that are active any more
14:12:46 <Sonarpulse> he would prefer we have more commonly-used compilers?
14:12:47 <c_wraith> jhc/ajhc are more or less the only other active implementation
14:13:08 <Sonarpulse> IMO that is an impossible goal
14:13:23 <geekosaur> hugs is dead, yhc is dead, ajhc is alive but not interested in cabal, uhc is occasionally jerking but we can't tell if it's alive or just acting like a decapitated chicken
14:13:24 <dcoutts> and sadly jhc has always seemed to actively avoid trying to integrate with Cabal
14:13:42 <dcoutts> though there is some code in Cabal for it
14:13:49 <dcoutts> not enough people care
14:14:26 <c_wraith> Sonarpulse: there are 3 commonly-used C compilers
14:14:29 <Sonarpulse> I think braking up ghc into a couple of seperate packages would be more realistic and ineresting
14:14:45 <Sonarpulse> c_wraith: and tonnes of headache because of it
14:15:10 <Sonarpulse> I'd love GHC to share some code with agda or idris implementations
14:15:13 <triliyn> That would be... gcc, clang, and Visual Studio?
14:15:13 <rs0> c_wraith: gcc, clang... icc? msvc?
14:15:19 <greg`> lovely people
14:15:24 <c_wraith> msvc is the third I was thinking of
14:15:31 <mgsloan> Yeah, having a nice libraryized GHC would be cool.  The problem is, it's a ton of work, with no direct payoff
14:15:34 <Lethalman> intel compiler
14:15:44 <badkins> I just read a great article on Warp ( http://aosabook.org/en/posa/warp.html ). They mentioned that the parallel I/O manager will be in ghc 7.8 which would be (according to the article) released in autumn 2013. Does anyone have a rough idea of when 7.8 is supposed to be released?
14:15:55 <Sonarpulse> I'd also like to see ghc upgradable via cabal
14:16:00 <rs0> afaik the Pelles C compiler is the only one that actually implements all the C11 threading stuff
14:16:03 <c_wraith> badkins: pretty soon.  I think I saw this morning that it's feature frozen now
14:16:06 <geekosaur> supposedly it is finally going into RC shortly
14:16:11 <k00mi> doesn't agda compile to haskell, then compile that with GHC?
14:16:13 <badkins> c_wraith: cool - thx
14:16:21 <greg`> badkins: i built it for arm already, well its a rc at present
14:16:22 <Lethalman> badkins, that I know, ghc 7.8 is going to improve things for a lot of cores
14:16:34 <Sonarpulse> k00mi: yes, but that is IMO the wrong way to build on GHC's acheivements
14:16:38 <Lethalman> for normal usage I don't think that would be any impressive boost, am I wrong?
14:16:45 <quchen> geekosaur: The pattern synonyms merge is still ahead I think. But Austin said the RC will be this week.
14:16:55 <greg`> if you re really cant wait, just recompile ghc from source, if your machine has a little woof it should take less than 30 minutes
14:16:57 <WraithM_> Sonarpulse: Doesn't Agda have other backends?
14:17:10 <Sonarpulse> ^ something with idris IIRC
14:17:12 <geekosaur> of course, they told us release would be during ICFP just before ICFP...
14:17:16 <greg`> whats in head at the moment is pretty stable
14:17:19 <k00mi> WraithM_: yes, it can compile to JS
14:17:58 <geekosaur> next time I should ask them which ICFP :p
14:18:06 <Sonarpulse> I'm none to skill full with agda or idris, but when I look at idris I really like what I see. It nicely resolves a lot of type class, records headaches
14:18:08 <greg`> does anyone here use hdevtools, its b0rken for 7.8
14:18:10 <quchen> geekosaur: The one in September of course
14:18:14 <Sonarpulse> *agda
14:18:21 <greg`> ICFP?
14:18:25 <Sonarpulse> idris still has typeclasses for reasons i don't understand
14:18:40 <greg`> international conference in functional programming??
14:18:45 <geekosaur> functional programming conference, yes
14:18:59 <greg`> where is it being held?
14:19:19 <k00mi> Sonarpulse: instance resolution is the primary reason for typeclasses
14:19:28 <greg`> scratch that i gotta link
14:19:33 <Sculptor> is sheldon cooper coming
14:20:00 <Sonarpulse> k00mi want something more powerfull than agda instance arguments then?
14:20:01 <geekosaur> basically ghc 7.8 is ike 4 months late
14:20:39 <roboguy_> the version number of HEAD isn't officially 7.8 yet, right? it's 7.7.something?
14:21:08 <greg`> yeah robo but its whats going to be 7.8 once released
14:21:31 <Sonarpulse> some tactic-like thing to provided your own resolutions strategies for agda instance arguments would solve that problem, and avoid the redundancies that typeclasses add, redundancies that are even more pronounced in a dependantly typed language
14:21:46 <roboguy_> hmm, is there any reason that any important things would break if I install HEAD?
14:22:00 <greg`> feature freeze now, so its just tweaks nothing major is going to change, if you want the goodies early grab head and compile
14:22:20 <Lethalman> roboguy_, many libraries have <VERSION in their dependencies.... not up-to-date libraries may break
14:22:32 <roboguy_> Lethalman: yeah, that's what I was thinking... hmm
14:22:43 <roboguy_> I guess I'll risk it
14:22:53 <greg`> you mean like prelude libraries?
14:23:33 <Lethalman> greg`, not only, there are things that require base<..., then dependency chains broken
14:23:34 <greg`> ghc compiles creates a new version of cabal and other haskell utils
14:24:12 <greg`> ok well i work from an arm laptop so i needed the latest , compiled it all and it works for me
14:24:24 <Lethalman> the problem is that libraries that are still in git are not uploaded to cabal and won't compile
14:24:40 <greg`> though to be fair hdevtools didnt compile for me , because its not 7.8 compatible
14:24:41 <Lethalman> greg`, well certainly depends on the libraries, haven't said ghc won't work
14:25:55 <greg`> disclaimer: i dont use haskell proffessonally, just for my little toy projects and experiements with ai and concurrency/parallism so i dont have huge swathes of "mustnt ever break" code
14:28:22 <Elision> ugh. I'm trying out happstack-server, but every time I try to ghci my code, it ends up importing both text-0.11.3.0 and -1.1.0.0, and implodes
14:28:23 <listofoptions> ok I think I'm done staring at type errors for the day ...
14:28:33 <k00mi> Sonarpulse: I don't have experience with them, but I imagine typeclasses provide quite a bit more comfort
14:28:57 * hackagebot semigroups 0.12.2 - Anything that associates  http://hackage.haskell.org/package/semigroups-0.12.2 (EdwardKmett)
14:28:59 * hackagebot adjunctions 4.0 - Adjunctions and representable functors  http://hackage.haskell.org/package/adjunctions-4.0 (EdwardKmett)
14:30:03 <k00mi> Sonarpulse: and I agree that typeclasses are somewhat redundant in a dependently typed language
14:30:11 <shachaf> edwardk: Does the Adjunction documentation mention that every instance will be isomorphic to (e,) (e ->)?
14:31:43 <Saizan> Elision: try cabal repl
14:33:58 * hackagebot speculation 1.5.0.1 - A framework for safe, programmable, speculative parallelism  http://hackage.haskell.org/package/speculation-1.5.0.1 (EdwardKmett)
14:35:56 <mekeor> isn't it kind of stupid/bad that the non-empty package defines 'head' and 'tail' with these identifiers? i mean, they overlap with the Prelude... (<http://hackage.haskell.org/package/non-empty-0.1.3/docs/Data-NonEmpty.html>)
14:36:35 <greg`> anyone here program haskell for a living?
14:37:15 <roboguy_> mekeor: why is that a problem?
14:37:46 <roboguy_> you can do a qualified import and you can also hide the head and tail from Prelude
14:37:57 <c_wraith> :t T.head
14:37:58 <lambdabot> Couldn't find qualified module.
14:38:03 <c_wraith> :t Text.head
14:38:03 <mekeor> yes but that's not nice
14:38:04 <lambdabot> Couldn't find qualified module.
14:38:07 <c_wraith> blah
14:38:24 <roboguy_> mekeor: but why not? it seems better than having new function names to remember
14:38:26 <greg`> i take that as a no then ,
14:38:44 <roboguy_> greg`: I know there are some people here who do, but they might not be here right now
14:38:48 <mekeor> greg`: there are people her who do haskell for living. not me, but there are
14:39:33 <roboguy_> mekeor: also it's common practice in haskell
14:39:46 <mekeor> roboguy_: well, there are also other identifier-names which make sense and are thus easy to remember imho. – e.g. i'd call them 'hd' and 'tl'... but anyways, it's probably matter of taste ;)
14:40:27 <Sonarpulse> k00mi: I should try more idris just to see what the instance resolution offers
14:40:41 <roboguy_> mekeor: I don't know, I prefer NE.head or NonEmpty.head. Then it's not only easy to remember, but also easy to see what the function does and what structure it uses
14:41:11 <dmj`> what is the benefit of wrapping up a custom monad transformer in a newtype?
14:41:17 <dmj`> if I have type Sig = ErrorT String (ReaderT String (StateT Double IO))
14:41:23 <mekeor> roboguy_: hmm. i see. yeah, actually, yeah. you're right. :)
14:41:27 <dmj`> and I do newtype Sig a = Sig { run :: ErrorT String (ReaderT String (StateT Double IO)) a }
14:41:38 <roboguy_> mekeor: also, every other container library I'm familiar with does the same thing (shadows identifiers from the Prelude)
14:41:45 <dmj`> is the benefit just type safety? It was already a transformer w/ MonadIO and MonadTrans
14:42:20 <roboguy_> dmj`: you can have new type class instances for that newtype if you want
14:42:49 <roboguy_> oh, you mean for monad transformers specifically
14:43:58 <dmj`> roboguy_: I see, that would make sense, not sure what other typeclasses I'd need.
14:43:59 * hackagebot persistent-cereal 0.1.0 - Helper functions for writing Persistent instances  http://hackage.haskell.org/package/persistent-cereal-0.1.0 (DaniilFrumin)
14:44:01 * hackagebot kan-extensions 4.0 - Kan extensions, Kan lifts, various forms of the Yoneda lemma, and (co)density (co)monads  http://hackage.haskell.org/package/kan-extensions-4.0 (EdwardKmett)
14:45:11 <Elision> Saizan: how do I do that? cabal repl what, Happstack.Server?
14:45:15 <edwardk> shachaf: obliquely at least
14:48:11 <listofoptions> edwardk: sorry to keep pestering you :D but -> http://lpaste.net/98481
14:48:34 <dgpratt> I vaguely recall recently seeing a HM type inference algoritm rendered in Haskell (or possibly a similar language). I don't suppose anyone here has a clue what I'm thinking of?
14:48:35 <edwardk> listofoptions: what's the issue?
14:48:37 <listofoptions> I cannot solve that for the life of me! (too much of a noob probably)
14:48:49 <listofoptions> Could not deduce (a ~ Var (Name a ()) a)     from the context (Ord a, Show a)       bound by the type signature for                  typeOf :: (Ord a, Show a) =>                            Map.Map a (Term a a) -> Term a a -> TC (Term a a)
14:49:34 <greg`> i wonder what kind of jobs there are writing haskell  for a living
14:49:54 <listofoptions> what doesn't make sense to me is that nf compiles and uses to/fromScope similarly
14:50:19 <edwardk> listofoptions: if you start throwing around `undefined` in the typeOf body what line do you have to replace to make it typecheck?
14:50:29 <greg`> really loving the fpcomplete.com site
14:51:03 <listofoptions> line 76
14:51:47 <listofoptions> well 75 on lpaste
14:51:53 <Saizan> Elision: more like running "cabal repl" in your current cabal project
14:51:57 <thebnq> greg`: have you seen http://www.haskell.org/haskellwiki/Haskell_in_industry
14:52:30 <Elision> oh
14:52:49 <listofoptions> edwardk: brb gotta move into classroom
14:52:56 <dagano> i read this on wikipedia :
14:52:59 <dagano> The functional language Haskell restricts side effects with a static type system
14:53:07 <dagano> how does the type system restrict side effects?
14:53:33 <edwardk> listofoptions: i was hoping you'd replace something more specific inside of that big definition. not clear where your unification error comes from
14:53:47 <Sagi> I recall talking to the author of rdf4h and hsparql in this channel, but for his nick, does anyone know?
14:53:47 <Iceland_jack> dagano: Conceptually you can think of it as ‘tagging’ effectful functions
14:53:51 <dagano> does it just mean that .. if i don't see some monadic-ish value .. i'll assume it's a pure value?
14:53:56 <edwardk> listofoptions: wait. you're using fromScope/toScope
14:53:57 <Sagi> (Rob Stewart)
14:54:05 <edwardk> you need to change the whole map out
14:54:10 <Sagi> s/for/forgot/
14:54:15 <edwardk> Map.Map a (Term a a) -> Term a a -> TC (Term a a)
14:54:16 <roboguy_> dagano: monad doesn't really mean impure. IO (sort of) means impure
14:54:20 <Iceland_jack> dagano: being monadic has nothing really to do with being an impure value
14:54:35 <roboguy_> dagano: IO just happens to be a monad, but that fact has nothing to do with purity
14:54:44 <Iceland_jack> dagano: Lists are monads and [1,2,3] is thus a monadic value
14:54:47 <edwardk> that needs to be a Map (Var (Name a ()) a) ... not a Map a .... given th way you're doing the call
14:55:02 <greg`> /?
14:55:15 <dagano> Iceland_jack: and lists aren't pure values right?
14:55:16 <greg`> thebnq :  i have now!
14:55:24 <roboguy_> dagano: lists are definitely pure values
14:55:29 <Iceland_jack> dagano: They most certainly are pure values
14:55:29 <nomeata> Hi. Little task about RecursiveDo: "\xs -> mdo {mapM_ act1 res ;  res <- mapM act2 xs; return ()}" does not work. How do I make it work?
14:55:33 <edwardk> in general i'd swap the Map out for a different lookup structure
14:55:53 <dleedev> what's a language besides haskell that has a type system just as robust?
14:56:05 <roboguy_> dagano: impurity has to do with side effects
14:56:31 <dagano> roboguy_: yeah i guess my question has more to do with IO
14:56:39 <dagano> but now i'm confused about lists being pure values
14:56:49 <dagano> is a value of type Maybe a pure value?
14:56:50 <roboguy_> dagano: why are you confused?
14:57:09 <roboguy_> dagano: essentially, anything that isn't of type "IO a" is a pure value
14:57:22 <jmct> dleedev: Look into the "ML family" of languages.
14:57:27 <edwardk> keep in mind you 'expanded the universe' with a new element when you went under the abstraction
14:57:31 <Iceland_jack>     type NotIO a = IO a
14:57:46 <dagano> haha
14:57:56 <roboguy_> dleedev: some languages have even more powerful type systems, like Agda
14:58:07 <zett_zelett> It’s impossible to define liftM in terms of join and return alone, is it?
14:58:21 <zett_zelett> You need to know how a Monad is a Functor, don’t you?
14:58:22 <merijn> roboguy_: That's a rather bad distinction even
14:58:36 <roboguy_> merijn: true, but I didn't want to get overly detailed
14:58:36 <edwardk> so what is happening right now is your map's range isn't big enough
14:58:40 <merijn> roboguy_: Even types "IO a" are pure in haskell, since everything in haskell is pure :)
14:59:01 <roboguy_> merijn: I know, but that might be a confusing way to introduce the concept
14:59:14 <roboguy_> merijn: lying is an important part of good teaching, after all!
14:59:50 <merijn> carter: Ping?
15:00:58 <thebnq> zett_zelett: you can define fmap in terms of return and join
15:01:04 <merijn> dagano: The problem/confusion you're running into is that people mess up terminology a lot
15:01:22 <dleedev> jmct: is ocaml the best representative?
15:01:43 <dagano> merijn: in the nature of terminology .. i am learning so am in a perpetual confusion
15:02:00 <merijn> dagano: People frequently refer to "IO" or monadic values as "impure", but it's all hogwash, Haskell is purely functional precisely because there are no impure values in Haskell, not even IO. It's just terminology abuse because people like to say "impure" instead of "IO"
15:02:04 <dleedev> roboguy_: how is it "more powerful"?
15:02:12 <roboguy_> dleedev: it has dependent types
15:02:13 <jmct> dleedev: I don't like throwing around words like "best" when talking about languages. By all accounts OCaml is a great language to learn
15:02:18 <dleedev> roboguy_: is it because types can be parameterized by values?
15:02:28 <roboguy_> dleedev: yeah pretty much
15:02:42 <dleedev> jmct: what about "most popular" instead of "best"?
15:02:46 <jmct> dleedev: It's often considered one of the more 'practical' functional languages
15:02:46 <skypers> hey
15:02:48 <merijn> Hold on, wait? Were you saying ocaml had dependent types?
15:02:51 <merijn> Because that's not true
15:02:58 <dleedev> merijn: agda
15:03:02 <zett_zelett> thebnq: Okay, don’t tell me. I want to find out myself.
15:03:05 <skypers> when would you increment the super major version number?
15:03:09 <merijn> dleedev: Ah, ok, ignore me then :)
15:03:13 <zett_zelett> thebnq: Although I’m pretty astonished.
15:03:20 <jmct> dleedev: OCaml has a very active community
15:03:22 <skypers> A.B.C.D, I’m talking about the A
15:03:27 <roboguy_> zett_zelett: why? Monad is more powerful than Functor
15:03:28 <jmct> dleedev: and a new book just came out for it
15:03:53 <zett_zelett> roboguy_: Still, return and join represent the natural transformations, not the functorial part.
15:03:57 <merijn> jmct, dleedev: tbh, the haskell community outshines the ocaml one by now. But ocaml is in use, most well known is probably Jane Street
15:03:59 <Sorella> dagano, purity applies to functions. Values are always values. A pure function is one that preserves referential transparency. Such that if you see `a + b` and you know that `a = 6`, and `b = 3`, you can replace all occurrences of `a + b` in your program with `9` and it'll be exactly the same thing.
15:04:02 <skypers> roboguy_: “more powerful doesn’t make sense”
15:04:04 <zett_zelett> I meant: WITHOUT using bind, of course.
15:04:08 <skypers> monads are just abstraction
15:04:12 <skypers> not “more powerful”
15:04:23 <dleedev> merijn: so haskell's more popular than ocaml?
15:04:30 <jmct> merijn: Oh, I agree, but the question was specifically about languages other than haskell
15:04:32 <merijn> dleedev: I'd say so
15:04:33 <zett_zelett> Since, you can define fmap in terms of bind and return.
15:04:34 <roboguy_> skypers: you can fully define a Functor instance in terms of a Monad instance, but not not the other way
15:04:40 <skypers> yes
15:04:42 <roboguy_> skypers: so I would call Monad strictly more powerful than Functor
15:04:48 <skypers> that’s why we call monads abstractions
15:04:55 <m3ga> ok, say i have built a big project using cabal, is there some way cabal can tell me exactly what versions of what packages my project uses?
15:04:56 <merijn> dleedev: F# is very similar to ocaml and other MLs, so that has made them a bit more popular recently
15:05:08 <roboguy_> skypers: what does it have to do with being an abstraction? functor is an abstraction too
15:05:23 <skypers> monads is over functors in terms of abstraction
15:05:24 <skypers> not power
15:05:34 <merijn> roboguy_, dagano: To set the record straight, a function is "pure" if for the same input arguments it always returns the same result
15:05:46 <skypers> functors are a better fit than monads for some cases
15:05:49 <roboguy_> skypers: how do you define power then
15:06:01 <skypers> roboguy_: just like I said earlier :)
15:06:04 <Iceland_jack> also if it doesn't have any observable effects
15:06:04 <roboguy_> I know, I'm not saying monads are *better*, I'm saying they're more powerful
15:06:07 <skypers> 23:57 < skypers> roboguy_: “more powerful doesn’t make sense”
15:06:15 <skypers> power is not a really precise thing
15:06:37 <roboguy_> well, I define power in terms of what you're calling abstraction level I suppose. it's just a matter of semantics
15:06:41 <merijn> roboguy_, dagano: Now, if you wonder "Then how can putStrLn/getLine be pure?", I used to have to give a long lecture, but nowadays there is the following excellent explanation blogpost: http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
15:06:44 <skypers> well, they generalize functors, but I don’t feel them as more powerful
15:07:09 <skypers> furthermore roboguy_
15:07:17 <skypers> if you have a functor
15:07:34 <skypers> it might not be a monad
15:07:42 <skypers> but a lot of things are functors
15:07:43 <roboguy_> merijn: I'm familiar with that, I just thought it would be potentially confusing to introduce the topic in that way. maybe I'm wrong though
15:07:51 <skypers> so you can state functors are more powerful than monads
15:07:59 <skypers> a more useful abstraction
15:08:00 <skypers> and so on
15:08:05 <listofoptions> edwardk: any luck?
15:08:08 <merijn> skypers, roboguy_: Monads are more powerful than functors in a very precise way
15:08:14 <skypers> yeah
15:08:18 <skypers> very precise
15:08:31 <merijn> skypers, roboguy_: I've been meaning to write a post about this, but it's late so I'm going to give the short unargumented version
15:08:33 <skypers> saying “they’re more powerful”, to me, that doesn’t make any sense
15:08:35 <zett_zelett> That’s very vaguely put, though, merijn.
15:08:43 <roboguy_> I've heard a lot of people use "power" in the way that I'm using it and never in the other way
15:08:44 <merijn> zett_zelett: I was still going to define how :p
15:08:50 <zett_zelett> Hehe.
15:08:55 <skypers> roboguy_: I prefer the terme abstraction layer
15:08:57 <skypers> or level
15:08:57 <edwardk> listofoptions: hadn't noticed you left the channel. replied above. basically the problem is the type of your Map isn't changing
15:09:01 <skypers> more precise to me
15:09:02 <merijn> Monads have more power in that they can express more complex computations
15:09:15 <skypers> exactly merijn !
15:09:22 <roboguy_> ^ that's exactly what I mean.
15:09:27 <skypers> then when you want simplicity and straight-forward computations
15:09:32 <skypers> monads are quite a poor weapon
15:09:42 <skypers> and applicative / functors are your friends
15:09:47 <merijn> To be precise, given "f a" if 'f' is a functor, then it is not possible to write a traversal that stops at the first element that returns True, given a function "a -> Bool"
15:09:49 <edwardk> listofoptions: you can change out all the keys in your map to bolt an extra 'F' on the outside before recursing, or you can com up with something better than Map.
15:10:00 <merijn> With Monads it *is* possible to short-circuit a traversal like that
15:10:10 <roboguy_> skypers: well, it depends on the context. sometimes you can express a straightforward simple computation in terms of a monad but not an applicative functor
15:10:15 <edwardk> not even there
15:10:15 <roboguy_> but that's neither here nor there
15:10:21 <edwardk> with Foldable yes
15:10:22 <skypers> sure roboguy_
15:10:22 <zett_zelett> But since Monads are applicative functors, skypers, everything you can do with them you can also do with Monads?
15:10:25 <m3ga> ok, say i have built a big project using cabal, is there some way cabal can tell me exactly what versions of what packages my project uses?
15:10:32 <skypers> zett_zelett: not really
15:10:38 <zett_zelett> skypers: Why?
15:10:39 <zett_zelett> Ah.
15:10:40 <zett_zelett> Yeah.
15:10:41 <edwardk> but you can't enumerate all the inhabitants of (e -> a) even though (->) e is a monad
15:10:44 <skypers> you can still apply applicative functions on them
15:10:45 <zett_zelett> Not everything is a Monad.
15:10:50 <skypers> but it’s applicative stuff, not monad
15:11:09 <merijn> m3ga: If you delete your cabal file (or rename it) and run "cabal init" it will fill the versions you currently have installed for you
15:11:18 <skypers> and yes
15:11:20 <roboguy_> zett_zelett: by the way, liftM f x = x >>= return . f
15:11:22 <zett_zelett> Well, so being a Monad is a stronger condition, which in return allows you to do more.
15:11:23 <zett_zelett> NOOOooooooooooooooooooooooo.
15:11:26 <zett_zelett> Don’t tell me.
15:11:33 <skypers> well
15:11:34 <roboguy_> zett_zelett: I thought you said to tell you...
15:11:37 <skypers> this statement is true
15:11:38 <roboguy_> ignore that then
15:11:41 <skypers> the more you have abstraction
15:11:45 <zett_zelett> Oh, you used bind.
15:11:47 <zett_zelett> Well then.
15:12:01 <zett_zelett> (I didn’t peak, I remembered from the first glance.)
15:12:20 <roboguy_> zett_zelett: it is possible with just join and return as well, but I'll have that as an exercise haha
15:12:23 <zett_zelett> I was wondering if it was possible only in terms of join and return.
15:12:24 <skypers> zett_zelett: I really love functors because 1. they’re easy to instance and 2. they’re really convenient to do a _lot_ of things
15:12:31 <thebnq> zett_zelett: sorry, maybe you can't, i think i combined join and bind in my head
15:12:52 <roboguy_> skypers: I actually completely agree that you should use functor and applicative over moand whenever possible
15:12:53 <roboguy_> *monad
15:12:56 <thebnq> oh
15:12:59 <listofoptions> edwardk: i'm lost
15:13:00 <skypers> I like exploring other abstractions than monads
15:13:03 <skypers> a few weeks ago
15:13:08 <skypers> I discover Bifunctors
15:13:10 <m3ga> thanks merijn, thats far from optimal, but useful nonetheless
15:13:12 <skypers> now I use them a lot
15:13:18 <zett_zelett> I always thought fmap and join are kind of equivalent to bind in terms of minimal definiton of Monad or something like that.
15:13:19 <roboguy_> I'm just saying that Monad is more powerful than Functor in the way that almost everyone uses the word power
15:13:24 <roboguy_> but it doesn't really matter
15:13:30 <merijn> m3ga: True, it's been suggested to have a more direct way of doing that in cabal
15:13:41 <skypers> roboguy_: and I think you should drop it
15:13:50 <roboguy_> the word or the debate?
15:14:03 <skypers> something more powerful / better – this statement sounds weak to me
15:14:04 <skypers> the word roboguy_
15:14:08 <merijn> m3ga: But as of yet cabal is maintained by like 1.5 persons with a fulltime job, so feature requests are slow unless you're willing to donate patches :)
15:14:14 <roboguy_> skypers: wait, I *never* said beter
15:14:15 <zett_zelett> Not better.
15:14:16 <roboguy_> *better
15:14:22 <zett_zelett> More powerful.
15:14:23 <skypers> you said more powerful
15:14:24 <skypers> yes
15:14:26 <zett_zelett> They can do *more*.
15:14:31 <zett_zelett> Which is kinda obvious.
15:14:32 <skypers> I was throwing examples
15:14:35 <roboguy_> skypers: more powerful does *not* mean better
15:14:43 <skypers> I know :)
15:14:46 <skypers> just to be sure ;)
15:14:56 <merijn> It sounds like everyone is in "violent agreement"
15:15:05 <skypers> I think so too
15:15:10 <zett_zelett> Btw.
15:15:10 <roboguy_> yeah, I think the only difference of opinion here is terminology
15:15:17 <zett_zelett> I think Monoids are more powerful than functors!
15:15:24 <skypers> my god
15:15:27 <edwardk> listofoptions: when you call fromScope on Scope b (Term x a), you don't get 'Term x a' you get Term x (Var b a).
15:15:35 <skypers> I also discovered a really nice use of Semigroup a few days ago
15:15:39 <edwardk> The 'a' type doesn't match up with the keys in your map any more!
15:15:40 <m3ga> merijn: i've looked at the cabal codebase. thats what scaring people off. its one of the most inpenentrable chunks of haskell code i've looked at (and i have about a dozen commits to ghc).
15:15:42 <roboguy_> zett_zelett: those are two very separate concepts...
15:15:42 <skypers> they’re so handy for my problem :)
15:15:51 <zett_zelett> roboguy_: I know, it was supposed to be a joke.
15:15:57 <roboguy_> ah, hah I see
15:16:02 <roboguy_> now
15:16:04 <skypers> and this is a part of why I luv Haskell: you have a lot of abstractions you can use as tools
15:16:21 <zett_zelett> Of which some are more powerful than others!
15:16:24 <skypers> ahah
15:16:28 <merijn> m3ga: FWIW, dcoutts is in here a lot and willing to explain stuff when he's got time
15:16:32 <roboguy_> skypers: have you seen that Monoids: Themes and Variations paper?
15:16:40 <ReinH> zett_zelett: All abstractions are equally powerful. Some are just more equal than others.
15:16:44 <skypers> no zett_zelett, for my problem, Semigroup is definitely the “better” match :D
15:16:50 <skypers> roboguy_: nope
15:16:56 <skypers> yeah
15:17:04 <skypers> what ReinH said
15:17:05 <ReinH> roboguy_: that's Byorgey's monoid pearl right? With diagrams?
15:17:11 <roboguy_> ReinH: yep
15:17:12 <skypers> ah
15:17:17 <ReinH> roboguy_: yeah it's great
15:17:18 <skypers> I may have already read it then yeah
15:17:21 <zett_zelett> ReinH: The Eq-Typeclass being the the most equal abstraction.
15:17:21 <listofoptions> ah
15:17:26 <merijn> m3ga: But yes, it's fairly intimidating
15:17:32 <m3ga> i've met dcoutts in IRL.
15:17:32 <roboguy_> skypers: it's pretty cool. they use Monoids and Semigroups as a basic abstraction in making a graph library
15:17:35 <roboguy_> skypers: http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
15:17:35 <ReinH> btw I am totally not allowed to reveal our Haskell Cast guest this week.
15:17:41 <skypers> oh yeah
15:17:44 <ReinH> And this is not relevant to the person we are currently discussing.
15:17:49 <skypers> I remember now :)
15:17:53 <skypers> yeah
15:17:56 <skypers> already read it
15:17:59 <skypers> a year ago
15:18:00 <m3ga> merijn: the thing that amazes me is that cabal is *far* more intimidating thean ghc
15:18:04 <skypers> nice paper
15:18:18 <skypers> monoid are really nice, especially when used with mconcat
15:18:19 <ReinH> m3ga: well, at least I don't have to write hairy parallel C code to work on cabal
15:18:22 <ReinH> as far as I know
15:18:41 <edwardk> listofoptions: so let us deconstruct what it means to be a map. You need lookup :: x -> k -> Maybe v and insert :: x -> k -> v -> x     for something map like. let's try passing both of those arguments to the function and when we go in/out of a scope defining a new lookup/insert that delegates what it can to the previous ones.
15:18:42 <ReinH> skypers: the `ala' newtype/lens plumbing makes it even easier now
15:18:48 <ReinH> > ala Sum foldMap [1,2,3,4]
15:18:50 <lambdabot>  10
15:18:53 <ReinH> so good
15:18:57 <skypers> :t ala
15:18:58 <lambdabot> Wrapped s s a a => (s -> a) -> ((s -> a) -> e -> a) -> e -> s
15:18:59 <m3ga> ReinH: i don't find ghc's RTS all that hairy :-)
15:19:08 <skypers> “easier” is a word dear.
15:19:09 <skypers> :D
15:19:23 <zett_zelett> roboguy_: I don’t seem to get it done: How *can* one define fmap in terms of join and return?
15:19:26 <ReinH> m3ga: it's not hairy to *read*. It's hairier to write *correctly*.
15:19:37 <ReinH> skypers: eh?
15:19:50 <benmachine> zett_zelett: I believe you cannot
15:19:54 <zett_zelett> Ha!
15:19:55 <skypers> ReinH: the Wrapped type sounds… pretty complex
15:20:00 <skypers> :i Wrapped
15:20:09 <skypers> @hoogle Wrapped
15:20:10 <lambdabot> Control.Applicative newtype WrappedArrow a b c
15:20:10 <lambdabot> Control.Applicative newtype WrappedMonad m a
15:20:14 <skypers> hm
15:20:15 <zett_zelett> This is what I was presuming.
15:20:18 <ReinH> skypers: it's just a hand wave hand wave newtype isomorphism
15:20:27 <skypers> ok
15:20:32 <ReinH> skypers: functionally the same as the ala from the newtype package
15:20:39 <skypers> ok
15:20:40 <skypers> thank you
15:20:42 <ReinH> np
15:20:46 <skypers> I’ll figure this out tomorrow
15:20:47 <zett_zelett> benmachine: It makes sense since we have no functorial information given with return and join – they are only the natural transformations.
15:20:50 <skypers> I’m falling asleep
15:20:53 <skypers> good night
15:21:04 <dcoutts> m3ga: I'm a little surprised you find it that intimidating
15:21:05 <edwardk> listofoptions: you get something like: typeOf :: (a -> String) -> (x -> k -> Maybe v) -> (x -> k -> v -> x) -> Term b a -> x -> Either String (Term b a, x)
15:21:15 <edwardk> listofoptions: if we remove the Show constraint as well.
15:21:31 <zett_zelett> (benmachine: Is this your reasoning as well?)
15:21:38 <edwardk> when we add a Var we need to handle the extra bound case, and delegate the other case to the old functions.
15:22:02 <dcoutts> m3ga: and yes, happy to explain things (but not right now). The old source guide is still mostly relevant.
15:22:03 <benmachine> zett_zelett: my reasoning is roughly "I've heard a lot about how bind can be implemented in terms of fmap + join but nothing about how it can be implemented without fmap" :P
15:22:22 <ReinH> heh
15:22:28 <ReinH> benmachine: my reasoning is "I can't make the types work."
15:22:34 <benmachine> ReinH: indeed
15:22:40 <benmachine> that too
15:22:48 <roboguy_> zett_zelett: yeah, actually you can't do that. never mind
15:23:01 <benmachine> I think it would be possible to come up with a construction that "proved" it by somehow obviously not having an fmap
15:23:06 <merijn> m3ga: It kinda is though, I recently patched a bug in the RTS it's event queueing that has been there since the very first implementation of it, due to no one realising that working with C API is in fact really hairy business :p
15:23:19 <benmachine> but having return + join
15:23:24 <ReinH> you need a TxT -> T of some kind
15:23:38 <ReinH> Hmm, can there be more than one join for a monad?
15:23:39 <merijn> m3ga: (Specifically the fact that converting Int to C's int is hard business)
15:23:40 <zett_zelett> benmachine: Or with two different functors satisfying the respective Monad laws.
15:24:08 <benmachine> zett_zelett: unfortunately law-abiding Functor instances are unique
15:24:10 <triliyn> ReinH: I seem to remember hearing somewhere that any type has at most one monad instance
15:24:19 <benmachine> triliyn: not true, but true of Functor
15:24:21 <shachaf> You can define bind with fmap and join, but the definition of a monad using bind as a primitive is a perfectly reasonable one, even categorically.
15:24:23 <m3ga> merijn: yes i think i saw that patch come through and i think i was one of the perpetrators of the broken-ness :-)
15:24:24 <triliyn> oh
15:24:30 <shachaf> triliyn: That's not -- what benmachine said.
15:24:36 <ReinH> triliyn: see above
15:24:37 <ReinH> ;)
15:24:42 <benmachine> triliyn: a possibly-silly example: ((,) w) has a monad instance for every possible monoid on w
15:24:55 <shachaf> You can just ignore me because benmachine will say everything first.
15:24:58 <triliyn> hmmm, right
15:24:59 <merijn> m3ga: It was just Simon, I think. But anyway it was so messy my initial patch actually fixed the bug by introducing a new one >.>
15:25:06 <ReinH> benmachine: we call "possibly-silly" things "trivial" to avoid the impression that we do silly things.
15:25:11 <ReinH> benmachine: ;)
15:25:16 <benmachine> ReinH: I do not avoid that impression
15:25:21 <ReinH> benmachine: heh
15:26:26 <m3ga> dcoutts: when i look at the cabal code base my first thought is that it needs a significant amount of refactoring. that may just be me, but i looked at it and though "this is completely not that way i would have structured this at all". admittedly that was 6+ months ago.
15:28:26 <merijn> dcoutts: Where is this old source guide? I've looked for an "where's what" of the source before, but don't remember finding anything
15:34:27 <snizzo_> can I define a function that does Err() -> IO()?
15:34:55 <snizzo_> or better, how can i define it in order to execute a function that returns Err() without returning it?
15:34:56 <carter> merijn: yes?
15:35:02 <carter> merijn: you rang?
15:36:02 <roboguy_> snizzo_: how about void?
15:36:06 <edwardk> did we lose listofoptions again?
15:36:11 <edwardk> ah there he is
15:36:22 <snizzo_> roboguy_: can you please be a bit more verbose? or point to some documentation? :)
15:36:38 <adelbertc> what is this i hear about cabal sandboxes not being aware of cabal init?
15:36:43 <adelbertc> (or vice versa rather)
15:36:55 <roboguy_> snizzo_: oh, never mind. I thought the argument and the result used the same type constructor
15:37:00 <carter> @tell merijn  when i'm not responsive, use @tell :)
15:37:00 <lambdabot> Consider it noted.
15:37:01 <listofoptions> temporarily
15:37:07 <edwardk> listofoptions: here's a concrete proposal. you can replace the Map with something like
15:37:19 <edwardk> data Context k a where Context :: (k -> x -> Maybe a) -> (k -> a -> x -> x) -> x -> Context k a
15:37:32 <edwardk> we can make an initial context from a Map.
15:37:33 <roboguy_> snizzo_: what's Err?
15:37:45 <edwardk> initial :: Ord k => Map k a -> Context k a; initial = Context M.lookup M.insert
15:37:58 <edwardk> where you have import Data.Map as M
15:38:28 <edwardk> then w can 'grow' a Context. for simplicity, let's just describe it with Either of two contexts.
15:38:44 <edwardk> listofoptions: grow :: Context k1 a -> Context k2 a -> Context (Either k1 k2) a
15:39:14 <snizzo_> roboguy_: don't know if you ever used bnfc, ErrM, http://lpaste.net/98502
15:39:36 <edwardk> that gives you something like: grow (Context l1 i1 s1) (Context l2 i2 s2) = Context l3 i3 (s1,s2) where l3 (Left k1)  (s1,_) = l1 k1 . fst; l3 (Right k2) (_,s2) = l2 k2 . snd; i3 (Left k1)  (s1,s2) = (i1 k1 s1, s2); i3 (Right k2) (s1,s2) = (s1, i1 k2 s2)
15:40:07 <roboguy_> snizzo_: hmm, so it's like "Either String a" basically. what is an example of what you want to do?
15:40:30 <edwardk> now when you go to fromScope something you need to grow the context to handle the extra variables. (replace Either/Left/Right above with Var/B/F in your code
15:40:50 <edwardk> by recursing with a new Context instead of the current one which has the wrong shape.
15:41:04 <ilmig> is there a terse way to create a predicate based on pattern matching?
15:41:27 <edwardk> you'd recurse with grow (initial mempty) oldContext  instead of the oldContext
15:41:53 <roboguy_> ilmig: like this? hasA A = True; hasA _ = False
15:41:59 <ilmig> for simple enum types I can use something like (== Foo), but this doesn't work for types like data Foo = A X | B Y
15:42:10 <ReinH> edwardk: not sure what the context is (ha) but isn't this coiteration and isn't there a cofree something to use?
15:42:26 <roboguy_> ilmig: how about hasA (A _) = True; hasA _ = false?
15:42:33 <roboguy_> oh, you mean inline?
15:42:43 <ilmig> yes
15:42:44 <edwardk> ReinH: well, wen you extend the context it isn't necessarily always being extended the same way each time
15:42:48 <ski> @where boolean-blindness
15:42:49 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
15:42:49 <ReinH> edwardk: ah
15:43:16 <ilmig> roboguy_: I want to give this as a parameter to filter
15:43:28 <edwardk> the construction i gave here doesn't have any extra places so you can't screw up and get the number of 'levels' wrong
15:44:02 <roboguy_> ilmig: I don't think there's a good one liner for that
15:44:11 <ilmig> I refactored my code from a simple sum type, to a mixture of product and sum type (i.e. data Foo = A | B to data Foo = A X | B Y)
15:44:13 <roboguy_> ilmig: although, lens has some stuff that could simplify it (the has function)
15:44:16 <ski> > filter (\case Just _ -> True; _ -> False) [Just 2,Nothing,Just 7]
15:44:17 <lambdabot>  <hint>:1:10: parse error on input `case'
15:44:20 <edwardk> listofoptions: i hope you managed to stay connected through all of that =)
15:44:25 <ilmig> and now my nice terse filter predicates don't work anymore :/
15:44:47 <edwardk> listofoptions: you also need to pass it back out of the output of your type checker, not just in
15:44:57 <ilmig> ski: is \case part of standard haskell?
15:45:03 <roboguy_> snizzo_: if fn is a function that returns Err (), you can return IO () like so: fn errValue >> return ()
15:45:05 <ski> it's an extension
15:45:10 <ilmig> I would like to create a lambda with pattern matching
15:45:14 <roboguy_> snizzo_: which is equivalent to void (fn errValue)
15:45:15 <ski> > [x | x@(Just _) <- [Just 2,Nothing,Just 7]]
15:45:16 <lambdabot>  [Just 2,Just 7]
15:45:20 <ski> > [x | Just x <- [Just 2,Nothing,Just 7]]
15:45:22 <lambdabot>  [2,7]
15:45:22 <ReinH> ilmig: lambda case?
15:45:41 <ski> ilmig : you could try a list comprehension like that ^ if you want to `filter'
15:45:42 <listofoptions> edwardk: yeah, but it's a lot to folllow XD
15:45:59 <ilmig> roboguy_: thanks, I'm still a beginner and haven't looked into lens yet. This may be the reason to look into that now, though ;)
15:45:59 <ski> > [x | x@Just{} <- [Just 2,Nothing,Just 7]]
15:46:00 <lambdabot>  [Just 2,Just 7]
15:46:12 <roboguy_> ilmig: well, that list comprehension is probably the best solution
15:46:20 <roboguy_> for this particular problem
15:46:24 <edwardk> listofoptions: look at the type of 'fromScope', nf and whnf work because they don't care about what 'a' is at all. they recurse _polymorphically_
15:46:26 <mornfall> ski: truth and provability aren't quite the same thing, traditionally :) (re. that boolean blog)
15:46:58 <ilmig> well, unfortunately using "filter" was only half of the truth
15:47:01 <mornfall> (if your theory is consistent, then truth follows from provability; if it's complete, the other way around)
15:47:07 <ilmig> this is an implementation of filter for my own data structure
15:47:26 <ilmig> so using list comprehension doesn't help me here, I need to create a boolean function...
15:48:05 <ReinH> ilmig: you can filter things using a list comp :)
15:48:10 <ReinH> oh not a list
15:48:16 <ilmig> (I thought this was one of the ideas of functional programming: create your own types which are filter- and mappable...)
15:48:21 <ReinH> monad comprehensions... sigh
15:48:29 <ReinH> ilmig: it is.
15:50:05 <ilmig> ok, I think I will just live with my more verbose pattern matching then
15:50:12 <ilmig> thanks!
15:50:16 <roboguy_> ilmig: the LambdaCase extension would probably give you the shortest one liner if you can't use monad comprehensions
15:50:28 <listofoptions> edwardk: ahh that makes sense now
15:51:38 <ilmig> roboguy_: thanks, this comes pretty close to what I want...
15:51:55 <ilmig> although I lose my point-free notation, but I can live with that ;)
15:51:59 <lingxiao> hey all,could some one explain to me why in Simply typed lambda calculus, only the variables in lambda abstractions have type annotation?
15:51:59 <roboguy_> why did they take out monad comprehensions anyway?
15:52:13 <lingxiao> ie, `λx : T . x`
15:52:19 <dmwit> To be friendly to noobs.
15:52:29 <dmwit> Monomorphic type errors are usually easier to read than polymorphic ones.
15:52:35 <roboguy_> dmwit: ahh, right
15:52:35 <lingxiao> why does't the whole abstraction have some annotation as well? `(λx:T . x) : T`
15:52:39 <aleksejs_> > logBase 10 1000
15:52:40 <lambdabot>  2.9999999999999996
15:52:43 <aleksejs_> :(
15:52:47 <roboguy_> lingxiao: wouldn't it be T -> T?
15:53:12 <lingxiao> right sorry, `(λx : T . x) : T -> T`
15:53:22 <lingxiao> or just `(λx.x) : T -> T`
15:53:46 <lingxiao> i mean, i know you can infer the function type by just annotating the variables
15:54:07 <lingxiao> but why not just annotate the whole lambda abstraction?
15:54:25 <listofoptions> lingxiao: because the type checker only needs new variables that are bound in the body to be defined as having a type
15:54:27 <ilmig> well, one lesson learned: going from type Foo = A | B to type Foo = A X | A Y comes with a prize...
15:54:29 <shachaf> There's a simple rule for figuring out its type.
15:55:00 <shachaf> (λ(x : T). e) has type T -> [the type of e]
15:55:05 <listofoptions> it can infer the type of the body and the entire form, from just the bound variables (assuming that there are no free variables in the entire term)
15:55:13 <lingxiao> so the design principle is annotate as little as possible?
15:55:17 <shachaf> Whereas you can't figure out the type of x.
15:55:34 <mornfall> dmwit: I see, that must be the reason that we have the numeric hierarchy.
15:55:39 <lingxiao> minimal viable type annotation
15:55:46 <lingxiao> if you will
15:55:50 <ReinH> aleksejs_: Floating? whyyyyyy
15:56:05 <dmwit> The Numeric hierarchy was a mistake with different motivations.
15:56:44 <dmwit> Or perhaps you are saying we should have had monomorphic numbers to be friendly to noobs?
15:57:09 <pyon> dmwit: Besides the lack of a natural number type, and the inclusion of floating points, what else could be considered a mistake? :-O
15:57:15 <dmwit> If so, perhaps those arguments are analogous. But then if you believe that, and believe monomorphic list comprehensions were a mistake, then you should believe monomorphic literals are a mistake, too.
15:57:21 <mornfall> dmwit: By the same reasoning, I guess. Afterall, comprehensions are slightly more advanced than numeric constants.
15:57:34 <Iceland_jack> pyon: What do you mean ‘inclusion of floating points’?
15:57:47 <dmwit> pyon: Pretty much everything about the Num/Integral/Floating/Fractional class hierarchy is a mistake, from a mathematics point of view.
15:57:52 <aleksejs_> I just tried to make some mathematic solution to get count of digits in Int, and it fails on 1000
15:58:04 <pyon> Iceland_jack: Floating points do not respect any nice laws - they should have separate operators like in OCaml.
15:58:10 <Iceland_jack> pyon: So what?
15:58:13 <aleksejs_> so, will go bacj to length . show :(
15:58:28 <pyon> Iceland_jack: So... they should have separate operators like in OCaml!
15:58:39 <dmwit> ?@ pyon: See the ?hackage numeric-prelude package for one person's idea of how it might look to do it right.
15:58:39 <lambdabot>  pyon: See the http://hackage.haskell.org/package/numeric-prelude package for one person's idea of how it might look to do it right.
15:58:41 * mekeor . o O ( all those different historical "mistakes" should be corrected, imho. (e.g. also the String-issue and the Monad-fail-issue etc...) – i mean, why is there no official, alternative, corrected, better prelude (yet)? ... )
15:58:41 <Sonarpulse> abstract algebra, save us!
15:58:46 <mornfall> dmwit: If I were to name one feature that makes life hard teaching Haskell to freshmen (as in summer-grass freshmen) it must be the numbers.
15:58:51 <pyon> dmwit: Nice. let me see. :-)
15:58:54 <Iceland_jack> How does that help exactly?
15:58:59 <dmwit> mornfall: No problem. Don't teach numbers. ;-)
15:59:11 <ski> mornfall : well, there's different senses of "proof"
15:59:19 <Sonarpulse> mekeor: best idea I saw was no prelude
15:59:34 <Sonarpulse> make teaching preludes, but real code just imports needed stuff manually
15:59:34 <mornfall> ski: defining it as a rational argument hardly helps ;-)
15:59:37 <pyon> Iceland_jack: Then you can write code where, say, "(a + b) * c == a * c + b * c" actually holds.
15:59:41 <Iceland_jack> People who aren't aware of the pitfalls of floating point numbers will just get annoyed by the new operators
15:59:57 <mekeor> Sonarpulse: yeah that'd be cool too
16:00:16 <magicman> "Why can't it be just * and + like with integers, it's just numbers, right?"
16:00:31 <augur_> is there a name for a discontinuous notion of substring? i've seen substring used for the notion, but i'd like to avoid using it
16:00:34 <dmwit> Iceland_jack: I don't think "avoiding annoyance in favor of convenience" has been a strong motivating factor in the design of Haskell.
16:00:47 <augur_> substring/sublist/whatever
16:00:56 <Iceland_jack> dmwit: Indeed, and this is a bridge too far in my opinion.
16:01:01 <mornfall> augur_: subsequence?
16:01:04 <dmwit> augur_: discontinuous?
16:01:17 <Sonarpulse> floats are still ...two magmas
16:01:25 <mornfall> dmwit: he means "abc" is-something-of "axbxc"
16:01:26 <magicman> Yeah, subsequence seems to be the formal term: http://en.wikipedia.org/wiki/Subsequence
16:01:28 <augur_> dmwit: like, in the string "abc", "ac" is a discontinuous substring
16:01:32 <pyon> Sonarpulse: pretty much
16:01:38 <pyon> Sonarpulse: actually, a bunch of magmas
16:01:49 <augur_> mornfall: subsequence has the same feel of it tho to me
16:01:54 <Sonarpulse> true
16:02:19 <mornfall> augur_: subsequence usually means that; substring usually not
16:02:38 <augur_> ok
16:02:39 <dmwit> augur_: Subsequence vs. substring is the correct distinction to draw. See wikipedia for "proof".
16:03:04 <dmwit> 'A substring of a string  is another string  that occurs "in" . For example, "the best of" is a substring of "It was the best of times". This is not to be confused with subsequence, which is a generalization of substring. For example, "Itwastimes" is a subsequence of "It was the best of times", but not a substring.'
16:03:14 <dmwit> From the wikipedia page for substring.
16:03:34 <dmwit> Put an italic S everywhere you see two spaces there. =P
16:04:30 <mornfall> dmwit: you probably want to prime or index those S's, too ;-)
16:04:47 <ski> mornfall : defining what as a rational argument ?
16:05:04 <ski> mornfall : see e.g. "Truth and knowability: on the principles C and K of Michael Dummett" by Per Martin-Löf in 1998 at <https://github.com/michaelt/martin-lof/blob/master/Truth-and-Knowability-On-the-Principles-C-and-K-of-Michael-Dummett-1998.pdf>,<http://www.scribd.com/doc/175208130/Truth-and-Knowability-On-the-Principles-C-and-K-of-Michael-Dummett>
16:05:09 <ski> mornfall : being a chapter in the book "Truth in Mathematics" edited by Harold G. Dales,Gianluigi Oliveri in 1998-10-10
16:05:26 <mornfall> ski: „means that it has a proof; there is a communicable, rational argument for why p is the case“
16:05:27 <dmwit> pfft, only the weak can't figure out where the primes should go
16:06:02 <jrmithdobbs> where is that silly lens game example that's on fpcomplete somewhere
16:06:06 <jrmithdobbs> trying to show it to someone, ha
16:06:38 <jrmithdobbs> oh there it is, right after I ask of course, ha https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
16:07:31 <ski> mornfall : in that article/chapter, Martin-Löf was arguing that there's (at least) two distinct notions of proof in (constructive) logic. one pertaining to propositions, and one pertaining to judgements
16:08:51 <Sonarpulse> ski: which link? that two notions of proof is what I have been wondering about
16:09:38 <ReinH> ski: do they both form categories though?
16:10:09 <mornfall> ski: I am way too sleepy for unraveling that right now. It smells of philosophy.
16:11:02 <mornfall> I will live with my simple and limited notions of truths and proofs.
16:11:08 <mornfall> At least until tomorrow.
16:12:07 <listofoptions> brb
16:12:54 <ski> Sonarpulse : see the two links i suggested to mornfall above ?
16:13:12 <ski> mornfall : indeed :)
16:14:06 <Sonarpulse> took me a while to realize they were the same thing :)
16:14:56 <triliyn> ski: what is a judgement? Propositions are like the things that map to types under Curry-Howard, right?
16:15:13 <mekeor> i wrote a (stack-based) calculator (with reverse prefix notation) and also implemented a possibility to define new function there. i now want to make it possible to add custom data-types, as well. but i'm struggling with the definition of (algebraic(?)) data types in my own kind-of-prog-lang in haskell itself. – do you have any advice or (web-)article/link or so for me?
16:16:11 <lingxiao> hey all
16:16:37 <lingxiao> if I want to represent a STLC AST using debrujin's index, where should the type information get stored?
16:16:46 <lingxiao> or what are some good options from exprience?
16:17:07 <lingxiao> right now I have this: `λx:T.x` --> `(λ.0, [T])`
16:17:29 <lingxiao> so it looks problematic already .. at the very least it might lead to some impl headache later on
16:17:46 <dmwit> Store it in the lambda?
16:17:58 <dmwit> \x:T.x --> \T.x
16:18:00 <dmwit> err
16:18:01 <dmwit> \x:T.x --> \T.0
16:18:17 <ski> Sonarpulse,mornfall,triliyn,ReinH : btw, another interesting book in this regard is (some parts of) "Elements of Intuitionism" by Michael Dummett in 2000-08-17, where he argues that constructive mathematics and logic is just in much need (intuitive) model theory as classical mathematics and logic (iow, proof systems with inference rules isn't enough)
16:18:54 <lingxiao> that makes the most sense I suppose
16:19:01 <Sonarpulse> intuitionist model theory
16:19:03 <Sonarpulse> hmm
16:19:10 * hackagebot xturtle 0.1.24 - turtle like LOGO  http://hackage.haskell.org/package/xturtle-0.1.24 (YoshikuniJujo)
16:19:12 * hackagebot effective-aspects 0.1.0.0 - A monadic embedding of aspect oriented programming  http://hackage.haskell.org/package/effective-aspects-0.1.0.0 (IsmaelFigueroa)
16:19:30 <Sonarpulse> I am part-way through HoTT now.
16:19:38 <ski> triliyn : a proposition (logically speaking) is a possible state-of-affairs, something which might be the case, something which "roughly speaking" has a truth-value (in some sense, at least, though it might be hard to determine)
16:19:41 <mekeor> what are you guys talking about? (Sonarpulse etc..)?
16:20:17 <Sonarpulse> logic/math/type theory
16:20:20 <ski> triliyn : a proposition being true is about what is actually the case
16:20:48 <Sonarpulse> ski: my big question is how does proof-relevence affect the distinction between judgment and proposition
16:20:55 <ski> there can be be many different forms of judgements, but a common important one is one *asserting* that a proposition is true
16:20:57 <Sonarpulse> if it does at all
16:22:02 <triliyn> Interesting
16:22:07 <ski> there's an implicit agent who is *claiming* the verity of the proposition. that is a judgement being expressed (correctly or not) by that agent
16:22:40 <ski> judgements are about what's *known* (or at least what's believed)
16:23:00 <triliyn> hmmm
16:23:07 <ReinH> ski: just asserting that something is true is my favorite form of judgement. :)
16:23:15 <ski> inference rules are about passing from given known judgements to new (then being known) judgements
16:23:59 <ski> understanding the meaning of a proposition means to understand what it would mean for it to be the case
16:24:12 * hackagebot readable 0.2 - Reading from Text and ByteString  http://hackage.haskell.org/package/readable-0.2 (DougBeardsley)
16:25:03 <ski> in terms of Martin-Löf's analysis in that chapter (iirc), this means that you understand the "proof conditions" for the proposition. iow you will recognize a proof (cf. "evidence") of it, when presented with it
16:25:54 <ski> in particular, you can understand a proposition without knowing whether it is true
16:26:13 <dmj`> iteratees are so awesome
16:26:31 <companion_cube> are you still talking about boolean blindness?
16:26:36 <ski> some early discussions in intuitionism questioned how one could grasp propositions that weren't known to be true
16:27:02 <ski> but relatively soon, people showed convincing examples of how this can work
16:27:51 <ski> you can prove that, if there's a contiguous sequence of digits `0123456789' in the decimal expansion of `pi', then there's a contiguous sequence of digits `012345678' in the decimal expansion of `pi'
16:28:13 <ski> and you can prove this without knowing whether the antecedent of this implication is true
16:29:00 <ski> because you know what the antecedent *means*, you understand the proof conditions. and *if* you were to be provided evidence/proof of the antecedent, then you could easily compute corresponding evidence/proof of the consequent
16:29:06 <triliyn> Doesn't that run into Loeb's paradox though?
16:29:20 <triliyn> Or am I misunderstanding something or does Loeb not occur in intuitionistic systems?
16:29:28 <ski> companion_cube : hm, i don't think so. maybe it's related on some level
16:29:34 <companion_cube> ah, ok
16:29:51 <triliyn> oh wait
16:29:54 <triliyn> I misread
16:30:36 <companion_cube> ski: to me a proposition can also be seen as a constraint on the possible models
16:30:43 <companion_cube> it filters out models that do not fit
16:33:40 <ski> now, (iiuc the argument in the chapter correctly) understanding "proof for judgements" otoh is about understanding/recognizing not when we have proof/evidence for a proposition, but understanding/recog. when we are justified in asserting (in the case of assertion) the proposition (the proposition might be true, iow provable (in the proposition sense), without we yet having enough proof/evidence to show it convincingly)
16:34:50 <ski> disclaimer : this is my rough impression of the chapter (i confess having to reread parts to attempt to grasp what the author was getting at), and it was some time ago i looked at it
16:35:48 <ski> btw, the Dummett book i mentioned has (iirc) an interesting discussion about holism contra reductionism
16:36:10 <Sonarpulse> ski do know about effects of proof relevance on this?
16:37:56 <listofoptions> stupid school wifi
16:38:06 <ski> Sonarpulse : not really, no. i can't say i know very much about this topic
16:38:47 <companion_cube> it's closer to philosophy than mathematical logic
16:39:26 <Sonarpulse> well this is the last mathematical discussion i have seen of K
16:39:41 <ski> anyway. in Dummett's argument, holism is about denying that you can understand a restricted topic without understanding other topics where e.g. that topic is used (i don't know how much this corresponds to "traditional senses of holism", in case there's any agreement about such in philosophy (probably not ?))
16:39:44 <mekeor> K?
16:39:57 <Sonarpulse> C and K in martin lof's essay
16:40:30 <mekeor> oic
16:40:48 <ski> e.g. whether mathematical statements (such as axioms about large cardinals, or axiom of choice, or axiom of regularity, &c.) are true isn't solely the business of mathematics
16:41:34 <companion_cube> well axioms are not 'true', they're assumed or not
16:41:45 <listofoptions> companion_cube: well if the axiom of choice is true, I can duplcate anything!
16:41:48 <ski> how useful the various mathematical theories would be in physical, and other natural (and social, i assume) sciences would also affect the truthhood or otherwise of such things, under that view
16:41:51 <companion_cube> whether to choose to include the axiom of choice or not is philosohpy :)
16:42:43 <listofoptions> companion_cube: are you talking about the restricted axiom of choice? or the typical one introduced in most intro to logic and real analysis courses?
16:43:00 <ski> companion_cube : yes, but presumably we assume them because we in some sence believe in them (or at least, many do. i know some view them as purely games with symbols -- but that doesn't explain very clearly how math can be so useful)
16:43:19 <companion_cube> listofoptions: any axiom of choice :p
16:43:31 <listofoptions> http://en.wikipedia.org/wiki/Banach%E2%80%93Tarski_paradox
16:43:42 <companion_cube> ski: I believe in excluded middle, is it a religious claim? ^^
16:44:08 <ski> companion_cube : probably. but it's an interestin question how useful a belief it is
16:44:31 <companion_cube> it's useful for proving things, in this case
16:45:26 <jle`> you don't need to really justify your belief in the excluded middle
16:45:27 <listofoptions> this is true, axioms are only as useful while they aren't dangerous (IMHO)
16:45:36 <jle`> you can just prepend all of your conclusions with
16:45:41 <ski> anyway, opposing this view of irreducible interconnectedness of holism, Dummett phrases reductionism as the belief that various mathematical statements are true or not on their own ("internal", so to speak) merits, without needing to appeal to the natural world
16:45:47 <jle`> mentioning that this conclusion is valid only for the excluded middle
16:45:58 <companion_cube> jle`: well, to some it's a suspicious axiom
16:46:12 <jle`> everything mathematical is made up anyways so you can't really say anything is "truth"
16:46:22 <ski> jle` : yes and no
16:46:24 <jle`> you can only say that it is an implication/conclusion from a set of explicit axioms
16:46:38 <jle`> and the explicit axioms are arbitrary
16:46:54 <ski> certainly the sense of "truth" here is different from "correctness" as corresponding with the present physical world
16:47:16 <ski> jle` : but why should we prefer some axioms over others ?
16:47:23 <jle`> ski: no reason really
16:47:30 <Sonarpulse> http://existentialtype.wordpress.com/2013/07/10/constructive-mathematics-is-not-meta-mathematics/
16:47:36 <Sonarpulse> rereading this again I now get it
16:47:41 <jle`> the choice of axioms is arbitrary
16:47:59 <Sonarpulse> proof-relevance, is not combining thoery with meta theory
16:48:03 <ski> it seems Gödel had the view that we should choose the axiom (among the options offered) that leads to the most rich and interesting mathematical world
16:48:04 <jle`> however if you want to use the mathematics in order to apply to real problems with real solutions, you pick your axioms based on the real problem/real solution at hand
16:48:10 <Sonarpulse> because we still have judgement distinction
16:48:32 <Sonarpulse> *judgement-proposition distinction
16:48:36 <jle`> different sets of axioms lend themselves to different domains of usefulness in applied fields
16:48:42 <companion_cube> jle`: well I think "A => A" is true
16:48:50 <jle`> but perhaps this thinking gives away that i am not a mathemetician
16:48:54 <jle`> companion_cube: well...that's an axium.
16:48:56 <jle`> axiom
16:48:58 <jle`> you can't prove it
16:49:01 <companion_cube> no, that's a deduction rule
16:49:07 <jle`> er, yes
16:49:08 <companion_cube> but to me it's a valid reasoning :p
16:49:08 <jle`> sorry
16:49:15 <jle`> but it's taken as a definition/unproven
16:49:15 <ski> in the cumulative hierarchy in set theory, one build up sets from the empty set (and possibly urelements, primitive non-sets) in generations (ongoing in transfinite stages)
16:49:25 <jle`> but you don't need to say that you believe in it religiously
16:49:31 <jle`> you can include that statement as an explicit assumption
16:49:45 <jle`> or an explicit definition
16:49:51 <jle`> etc
16:50:04 <companion_cube> jle`: nothing is true in absolute anyway, but imho mathematics provide a strong notion of valid reasoning
16:50:06 <jle`> i can keep on going until i pick a better and more precise word but you get the picture
16:50:23 <jle`> companion_cube: reasoning is valid...given your set of assumptions/givens/axioms/definitions
16:50:26 <ski> one way of forming a new set is to take any already constructed set, and form the subset of those elements of that set that satisfy some given property (predicate)
16:50:29 <jle`> and that's not a bad thing.
16:50:43 <jle`> that doesn't bring down the power of math by any stretch
16:50:55 <jle`> in fact it makes it more powerful by saying you can really reason with any arbitrary set of assumptions
16:51:06 <jle`> without worrying about how they correlate to intuition or the real world
16:51:08 <companion_cube> jle`: indeed, but as ski said mathematics are strangely adequate to describe the world
16:51:23 <jle`> that is something that i am not comfortable about! :)
16:51:28 <jle`> and makes me stay up late at night
16:51:33 <ski> if one likes predicative stuff, ior is worried about vicious circles, one could prefer that the properties being used to construct subsets only allow *bounded quantification*, specifically bounded quantification over sets already constructed previously
16:51:43 <companion_cube> things like "and", "or", "imply" and "not" are somehow and adequate way of thinking about the universe
16:51:58 <jle`> well...naturally we would think of things like that because they are useful.
16:52:02 <ski> the whole cumulative hierarchy set universe is called `L'
16:52:04 <jle`> it's like that douglas adams comment
16:52:19 <jle`> a puddle wakes up and thinks that his hole he is in is strangely perfect to hold him
16:52:24 <ski> the universe of sets which can be constructed in the above predicative fashion is called `V'
16:52:32 <ski> `V' is a subcollection of `L'
16:52:42 <jrmithdobbs> *obligatory "Oh no, not again"
16:52:53 <listofoptions> lmao
16:52:55 <companion_cube> flying teapot and whale!
16:53:05 <ski> the axiom of constructibility says that `V' is equal to `L' (iow, every set *can* be predicatively constructed)
16:54:07 <companion_cube> so, in real life I'm in first-order classical proofs, far away from those considerations :p
16:54:16 <ski> Gödel investigated some of the consequences of `V = L' -- but in the end it seemed he preferred the richer system where `V' is a proper subcollection of `L', iow choosing some other axiom that contradicts the axiom of constructibility
16:54:39 <benzrf> hey
16:54:48 <benzrf> whats the purpose of typeclasses like MonadReader
16:54:59 <ski> (btw, afaiu, this "axiom of constructibility" doesn't have very much with constructive logic and math to do -- except that predicativity has some roles in some approaches to the latter as well)
16:55:47 <companion_cube> good night
16:55:52 <ski> so in effect, Gödel here argued that `V /= L' is objectively more interesting than `V = L' (assuming all the other ZF axioms), and so to be preferred
16:56:01 <Sonarpulse> axiom of construtability seems anti-constructivist
16:56:36 <jle`> benzrf: it's so that you can use ask in them
16:56:38 <ski> but that doesn't say what to do when there's alternative (mutually inconsistent) rival axioms that both appear to have interesting or nice consequences
16:56:57 <jle`> for example i have MyTransformer m a
16:57:07 <jle`> and i can use it to transform a Reader monad
16:57:12 <jle`> MyTrasnformer (Reader s) a
16:57:21 <benzrf> oh
16:57:24 <benzrf> :
16:57:25 <benzrf> :S
16:57:25 <jle`> if i instance it as a MonadReader
16:57:29 <jle`> i can use "ask"
16:57:30 <Sonarpulse> have you read any HoTT ski?
16:57:33 <jle`> where ask = lift . ask
16:57:46 <benzrf> my head ;-;
16:57:48 <jle`> as in, if i say 'ask', i lift that ask into the (Reader s) that it contains
16:58:08 <jle`> i am not sure i explained this well enough...
16:58:15 <jle`> have you used monad transformers before?
16:58:29 <jle`> you can use lift to access the monadic stuff of the wrapped transformer
16:59:02 <jle`> so if i was wrapping an IO monad, I can use lift . putStrLn to access putStrLn inside the wrapped IO monad
16:59:11 <benzrf> jle`: no problem on your part :|
16:59:16 <jle`> if i was wrapping a Reader monad, i would use lift . ask
16:59:21 <jle`> to access the "ask" of the wrapped reader monad
16:59:30 <benzrf> the problem here is that i only barely have my head wrapped around MTs
16:59:38 <jle`> do you follow thus far?
16:59:40 <benzrf> i have to manually think through how each bit works with em
16:59:44 <ski> companion_cube : of course, one answer to why "mathematics are strangely adequate to describe the world" is that what (large parts of) math was developed for (even if abstracted more, since) :)
16:59:49 <benzrf> therefore i have to stop to think about each step in explanations of this kind of thing
16:59:50 <listofoptions> benzrf: it's kinda like nesting container types in c+/java but a *_LOT_* more powerful
16:59:50 <ski> Sonarpulse : a little
16:59:53 <benzrf> which makes it impossible to focus
16:59:53 <benzrf> ;-;
17:00:05 <jle`> don't worry haha. let me know what part confuses you
17:00:22 <benzrf> <_<
17:00:29 <benzrf> let me try messing around with ReaderT a tad
17:00:44 <benzrf> first
17:00:50 <jle`> well, just know that if your monad transformer wraps another monad, using lift allows you to "access" the inside monad.
17:00:52 <ski> however, even if we intended math to (partly) model physical things (and patterns in physical things) well, it doesn't follow why this should succeed to such a high degree
17:01:02 <jle`> so if you did ReaderT s IO a
17:01:06 <ski> (and yes, that's a very philosophical question)
17:01:20 <jle`> you can actually 'access' IO by using something like lift . putStrLn
17:02:03 <eazar001> @src (/)
17:02:03 <lambdabot> Source not found. I am sorry.
17:02:03 <jle`> so now you can do all the fun reader stuff like ask etc, but then have access to IO if you feel like it.
17:02:13 <Sonarpulse> stochastic quantum physics...
17:02:53 <benzrf> hm
17:02:57 <benzrf> why does this not work
17:02:58 <benzrf> lift $ Just 3 :: ReaderT Maybe Int
17:03:01 <benzrf>     Expecting one more argument to `Maybe'
17:03:21 <listofoptions> Sonarpulse: isnt that like .... a double dose of WAT?
17:03:29 <jle`> benzrf: remember the type parameters for ReaderT
17:03:34 <jle`> you need to specify the type of the environment
17:03:36 <ski> triliyn : anyway, Gödel-like arguments probably apply to constructive systems as well
17:03:40 <jle`> :t ReaderT
17:03:41 <lambdabot> (r -> m a) -> ReaderT r m a
17:03:49 <benzrf> oh derp
17:03:54 <benzrf> <_>
17:04:02 <ski> one common way of informally stating the incompleteness theorem is that there are true unprovable propositions
17:04:11 <triliyn> ski: when I thought I saw Loeb's paradox I was basically hallucinating, if that's what you're talking about
17:04:11 <Sonarpulse> listofoptions: well I mean it is perhapsa real world example to
17:04:19 <ski> it's important to realize that "provable" here refers to "*formally* provable"
17:04:28 <Sonarpulse> "no reason universe should be deterministic"
17:04:43 <triliyn> I thought I saw a statement of the form "If you can prove that a proof of p implies p, you can prove p"
17:04:47 <mekeor> ski: "formally"?
17:04:48 <triliyn> But what you really said was
17:04:56 <ski> mekeor : in a formal system
17:05:02 <triliyn> "You can prove that blahblahblah contains blahblahbla
17:05:03 <triliyn> "
17:05:17 <triliyn> Which is completely different
17:05:23 <jfischoff> does anyone have a example of project setup where the tests files are discovered automatically with based on a naming convention?
17:05:23 <Sonarpulse> if universe isn't deterministic, why do we even  think it is logical?
17:05:30 <benzrf> @src asAppliedTO
17:05:30 <lambdabot> Source not found. My pet ferret can type better than you!
17:05:33 <benzrf> @src asAppliedTo
17:05:33 <lambdabot> Source not found. Wrong!  You cheating scum!
17:05:38 <benzrf> :t asAppliedTo
17:05:38 <lambdabot> (a -> b) -> a -> a -> b
17:05:39 <mekeor> Sonarpulse: :D
17:05:40 <benzrf> huh
17:05:43 <triliyn> But yeah, I wouldn't be surprised if intuitionistic systems were also vulnerable to goedel
17:05:49 <jfischoff> I was going to write something myself, but was thinking it is already done ..
17:06:41 <mekeor> benzrf: asAppliedTo :: (a -> b) -> a -> a -> b; asAppliedTo f x = f
17:06:48 <jle`> Sonarpulse: nondeterministic systems are just as logical as deterministic systems
17:06:54 <jle`> or they can be
17:06:59 <ski> (btw, another practical argument in favor of reductionism in the sense of Dummett instead of holism (also in his sense) is that, even if it in some sense isn't true, it's a useful and practical working assumption. if you don't expect the world to be understandable ("reducible"), then you probably won't find out how to understand it)
17:07:00 <jle`> given the knowledge of the proper nondeterministic rules
17:07:01 <jrmithdobbs> ?src asAppliedTo
17:07:01 <lambdabot> Source not found.
17:07:12 <benzrf> :t const
17:07:13 <lambdabot> a -> b -> a
17:07:16 <Sonarpulse> can be
17:07:18 <Sonarpulse> AFIAK
17:07:29 <jle`> quantum mechanics is as rigorous a study and framework as any other field in physics...perhaps even more so
17:07:30 <Sonarpulse> deterministic -> logical
17:07:30 <benzrf> @djinn a -> b -> a
17:07:30 <lambdabot> f a _ = a
17:07:37 <jle`> ah okay. came in at the wrong context
17:07:41 <benzrf> @djinn (a -> b) -> a -> a -> b
17:07:41 <lambdabot> f a b _ = a b
17:07:45 <benzrf> huh
17:07:53 <Sonarpulse> nondeterministic & logical is possible
17:08:01 <Sonarpulse> quantum mechanics is certainly logical
17:08:19 <quchen> Haha.
17:08:20 <Cale> I don't really like that "statement which is true but not provable" way of expressing it. Saying that there's a statement for which neither it, nor its negation is provable seems like a better way to put it.
17:08:27 <ski> anyway, iiuc Martin-Löf correctly, the (two) notion(s) of proof isn't (definitely) meant to be interpreted as *formal* proof, but rather as an ideal (and informal, intuitive, and possibly incompletely developed) notion which we're attempting to grasp, flesh out, and capture using formal systems
17:08:43 <benzrf> argh
17:08:46 <benzrf> my brain int up for this
17:09:00 <Cale> (Though it doesn't really mean the same thing precisely.)
17:09:03 <ski> (the two notions of proof he talks about in that chapter, i.e.)
17:09:13 <Sonarpulse> ski: cf hott and bob harper, i think judgement is always formal
17:09:25 <Sonarpulse> proposition-proof can be non formal depending on system
17:09:36 <ski> Sonarpulse : you may be correct
17:09:47 <Sonarpulse> proof-relevance probably relates to admition of non formal proofs
17:09:55 <Cale> What was the overall question here?
17:10:21 <Sonarpulse> also, i think formal proof -> proof (what bob harper says with HoTT), implies
17:10:22 <Cale> proof-relevance refers to the manner in which we care about which term of a given type we have
17:10:42 <zRecursive> Many things are true but not provable :)
17:10:43 <Cale> In classical logic, once someone proves a theorem, that's really all there is to it.
17:10:46 <ski> re semantics (models), as opposed to (formal) proof systems for constructive logic&math, Dummett argues that we need an (informal, intuitive) account of the semantics of constructive logic&math just as much as classical systems need model theory and truth-functional interpretations
17:11:00 <Sonarpulse> my question was how does proof relevance affect judgement vs proposition (and proofs of each) distinction
17:11:16 <ski> otherwise, what's the point of constructive systems, except as a game ?
17:11:17 <Cale> People can try proving it in different ways, but from the point of view of the logic itself, any proof will behave the same way.
17:11:47 <Sonarpulse> Cale: classical logic implies proof <-> formal proof?
17:11:59 <Cale> What's the difference between proof and formal proof?
17:12:13 <Sonarpulse> Cale one second
17:12:39 <Sonarpulse> from reading http://existentialtype.wordpress.com/2013/07/10/constructive-mathematics-is-not-meta-mathematics/ and other HoTT things
17:12:55 <ski> Cale : the idea here is that "proof" is an informal, intuitive, incomplete (and possibly inconsistent ?) notion that we're attempting to graps, flesh out, and capture using a formal system
17:13:04 <Sonarpulse> I gather when bob harper refers to proof in this, he is reference to inhabitence of type/proposition
17:13:11 <ski> s/graps/grasp/
17:13:14 <Cale> In classical logic, once you prove a theorem, you're essentially done with that theorem. Any further proofs of that theorem are just for fun, and the logic itself doesn't do anything to tell them apart.
17:13:17 <Sonarpulse> formal proof refers to judgement
17:13:52 <ski> Sonarpulse : yes, unfortunately the word "proof" has been used for several distinct things here
17:14:04 <Cale> In type theory, you have as part of the system itself, terms of a given type in some sense representing some information about the manner in which the proof was derived.
17:14:44 <Cale> Instead of the classical judgment "A", you have a judgment which looks like "p : A"
17:14:55 <Sonarpulse> but you have notion of judgement vs propisiton
17:15:09 <ski> Cale : hm, how about defining a function to return a value computed from a witness which is known to exist by a theorem, in a classical system ?
17:15:19 <Cale> Okay, if we want to be really clear, I should say the judgment is "A is true"
17:15:32 <Sonarpulse> sure
17:15:36 <ski> Cale : is that, strictly speaking, admissible in a classical system ?
17:15:37 <mekeor> :D
17:15:40 <Cale> though we usually leave off the "is true" bit because it's the only judgment that classical logic cares about
17:15:52 * ski nods
17:15:59 * mekeor listens
17:16:10 <zRecursive> I am curious whether or not prolog fails ?
17:16:22 <ski> (hm, i suppose classical modal logic could possibly entertain other judgement kinds as well)
17:16:23 <zRecursive> If so, why ?
17:16:56 <Cale> ski: I'm not sure exactly what you mean... you mean doing something model theoretical to extract an "actual" function in our classical meta-system from a proof that it exists?
17:17:22 <ski> zRecursive : anyway, one part of the chapter i linked to earlier in the discusssion is about the claim that "true" really (in a certain sense) means "provable" ;)
17:17:58 <zRecursive> heh
17:18:37 <zRecursive> "\+" means not provable
17:18:39 <ski> Cale : yes. istr reading somewhere someone who appeared to think that it was as sign that the mathematician in question was really thinking somewhat more along the lines of type theory than classical logic re that part in the development
17:18:54 <Cale> Okay, so to understand truth vs. provability, you need to grasp the setup that's taking place in model theory and other contexts in formal logic.
17:19:08 <ski> zRecursive : (\+)/1 is unfortunately defective in several situations
17:19:36 <zRecursive> sure
17:19:42 <Cale> We're using one formal system (which I'll call the outer system) to study another one (the inner system), by constructing the inner system as some sort of object of the outer system.
17:19:55 <Sonarpulse> and we do that both in classical logic and type theory
17:20:00 <Cale> yes
17:20:00 <zRecursive> ski: i always regard "\+" as NOT
17:20:22 <ski> (cont. from above) but if the kind of (informal) truth-functional interpretations that are applicable for classical logic can't be applied for constructive logic (because of lack of bivalency), what should we use instead ?
17:20:48 <Sonarpulse> I originally interpreted proof-relevance to mean we didn't need the outer system....somehow. but yes
17:20:51 <Sonarpulse> that is false
17:20:54 <kristof> Can I intersperse a function definition throughout my code?
17:20:57 <kristof> Based on type dispatch
17:20:59 <Sonarpulse> we need "inner and outer" system for both
17:21:08 <kristof> func ConcreteType1 = definition . . .
17:21:19 <Sonarpulse> classical logic and type theory
17:21:20 <kristof> and then later: func ConcreteType2 = definition ...
17:21:45 <Cale> Saying that some proposition of our inner system is "true" usually is taken to mean that under some canonical interpretation of the statements of our inner system as statements about some structure in our outer system, the proposition is provable about that interpretation in our outer system.
17:21:46 <ski> there's stuff like kripke semantics and beth trees for constructive logic (mentioned in that dummet book), but he seems to argue that those don't serve the purpose of initially endowing the formal system with (intuitive, informal) meaning
17:21:50 <mekeor> concrete Q: let's assume ZF. is the axiom of choice "true", "false", "provable",..? – or what is it?
17:22:14 <Cale> mekeor: None of the above.
17:22:21 <mekeor> .. but?
17:22:32 <Sonarpulse> ski: perhaps that relates to differenve between constructivism and intuitionism
17:22:40 <Cale> mekeor: Well, okay, if we're using ZFC to study ZF, then perhaps choice will be true, but not provable.
17:22:40 <ski> (partly because of mismatches between proof system and model, some formulae being equivalent in the model, but not in the proof system (and arguably not in the intended semantics))
17:22:41 <roboguy_> mekeor: it's not possible to prove or disprove it with ZF
17:22:48 <roconnor> mekeor: do you mean ZF is the outer system or inner system.
17:22:52 <mekeor> roboguy_: yeah
17:23:07 <mekeor> uhm. ¯\(°_0)/¯ Dunno
17:23:31 <Cale> If we're using ZF to study ZF, then choice won't be true or false, and neither it nor its negation will be provable
17:23:37 <ski> anyway, he envisages a compositional meaning-asssignment to structured propositions, in terms of the constituent subformulae
17:23:50 <roboguy_> mekeor: you can have ZF (not C), which is ZF with choice assumed to be false.
17:23:57 <Cale> no
17:24:02 <ski> where the meaning of a proposition is it's proof-conditions (in the informal sense)
17:24:14 <augur_> can anyone explain why eta's are supposed to be "weird" compared to beta's?
17:24:15 <Cale> ZF simply *doesn't assume choice*
17:24:21 <Cale> It's consistent with choice
17:24:26 <mekeor> roboguy_: i know
17:24:27 <roconnor> mekeor: okay, If we take ZF as our outer system (our meta logic) and take the formal statement of AoC (our inner logic) then the statement "AoC is true" is some concrete inductively defined statement in ZF that happens to be neither provable nor disprovable.
17:24:33 <Cale> ZF-C is another system altogether
17:24:41 <roboguy_> Cale: that's my point
17:24:41 <mekeor> it's consistent with both not-choice and choice
17:24:52 <ski> however, there's the interesting complication that a proof of `A implies B' can't only make use of the fact that `A' is true (iow provable), when proving `B'
17:24:59 <roboguy_> mekeor: I'm not sure I understand the question then
17:25:02 <Cale> roboguy_: It sounded like you were talking about ZF :)
17:25:02 <Sonarpulse> Cale, what the harper blog is about is that a proofs are relevent, so we have in the case of type theory (proofs of proposition = term inhabiting type) distinct application of imference rules leading to judgement
17:25:16 <roboguy_> Cale: oh, oops, that's not what I meant
17:25:34 <ski> but it can also make essential use of information regarding *how* `A' was proved, which proof was selected
17:25:35 <augur_> choice is constructively true!
17:25:58 <Cale> augur_: but that choice isn't really saying what choice says :)
17:26:06 <augur_> Cale: sure it is
17:26:07 <ski> (this is of course not news for anyone familiar with type theory -- note here that Dummett is talking about a more or less standard first-order predicate logic, though, but with constructive interpretation)
17:26:11 <Cale> It just kind of looks like it
17:26:20 <augur_> why only kind of
17:26:33 <roconnor> To define "Foo is True" we only actually need an "inner language", the inner logic isn't needed.
17:26:42 <Cale> augur_: Because the meaning of "exists" is completely different
17:27:09 <augur_> Cale: its only completely different if your logic is classical
17:27:16 <benzrf> ok im a little confused
17:27:22 <augur_> ZF doesnt doesnt specify a logic, it just specifies axioms
17:27:29 <benzrf> given ReaderT r m a ~ r -> m a instead of being a newtype wrapper...
17:27:30 <mekeor> roconnor: what?
17:27:44 <augur_> you have to choose your logic too, Cale
17:27:44 <mekeor> roconnor: that's contradictionary... :P
17:27:47 <Cale> augur_: Any assumption that something exists will implicitly provide a witness. So the axiom of choice which is true in constructive logic is basically composition with a projection map which picks out the choices that were already made.
17:27:48 <benzrf> >>= on ReaderT String Maybe Int should be
17:27:48 <benzrf> (String -> Maybe Int) -> (Int -> String -> Maybe Int) -> (String -> Maybe Int)
17:27:50 <benzrf> right?
17:27:55 <augur_> so you can choose IL+ZF or CL+ZF
17:28:12 <roconnor> mekeor: The defintion of "_ is True" is carried out by induction on formal sentences.
17:28:12 <augur_> Cale: sort of, yes
17:28:15 <ski> so, at first sight, it appears that any time we discover a new proof of `A', we'd have to *recheck* the proof interpretation of `A implies B', to make sure it still makes sense (compare with predicativity issues)
17:28:25 <augur_> Cale: which is fine and says the same thing
17:28:44 <mekeor> roconnor: you wrote: “<roconnor> To define "Foo is True" we only actually need an "inner language", the inner logic isn't needed.”
17:29:09 <mekeor> oh
17:29:09 <ski> and the problem would seem to be worse, since one might require proving quite complicated formulae as lemmata for the ulterior goal of proving a (relatively) simple formula
17:29:16 <Cale> augur_: I'm saying that the constructive axiom of choice in, say, HoTT has a completely different nature from the axiom of choice in ZFC, and it would be overly naive to expect to translate theorems from one system to the other in that fashion.
17:29:23 <mekeor> roconnor: i see. inner *language* and *logic*... okay :D
17:29:32 <roconnor> right
17:29:35 <benzrf> oooh  wait nvm i think i figured out my issue
17:29:36 <benzrf> phew
17:29:38 <augur_> Cale: ZF and HoTT are not analogistic things.
17:29:45 <augur_> Cale: ZF is a set theory, HoTT is a type theory.
17:29:50 <roboguy_> benbangert: yeah I think so
17:29:56 <roboguy_> I mean benzrf
17:30:05 * roconnor doesn't think I've agreed with Cale so much in a discussion of logic before.
17:30:06 <ski> iow, it would seem that the interpretation (the proof conditions) of simply structured propositions may depend on the interpretation of more complexly structured ones, thwarting composability !
17:30:11 <Cale> augur_: sure, but when you say "the axiom of choice is true!", you're making such an analogy
17:30:11 <benbangert> moar benz!
17:30:12 <augur_> Cale: you can perfectly well have HoTT + ZF
17:30:19 <augur_> or perhaps more usefully, ITT+ZF
17:30:42 <augur_> Cale: ahh but im not, because when you have ITT+ZF, ZF choice is a consequence of ITT choice :)
17:31:06 <Cale> I'm not sure I understand what you mean.
17:31:13 <Cale> In particular about ITT+ZF
17:31:22 <Cale> (which system is that?)
17:31:34 <augur_> Cale: ZF is a set of axioms on top of a logic. ZFC presupposes things like quantification, implication, conjunction, etc.
17:31:52 <augur_> ZF is like Data.List
17:31:56 <ski> however, iirc, Dummett argues that in some sense we only need to know the proof conditions of `A' (in the implication) abstractly, rather than in the sense of already having to understand the meaning of every possibly proposition which might be required in the proof of `A'
17:31:57 <roconnor> augur_: the typical interpreation of the ZFC style AoC into Type theory would double-negate Type Theory's Sigma to get a classical existential operator (and would also use a classical function space).
17:31:58 <augur_> its a package you import into your logic
17:32:16 <Cale> ZF specifically is built on top of classical first order logic with a single binary relation symbol.
17:32:20 <augur_> right
17:32:42 <ski> i suppose this could be comparable to knowing that a natural number can be normalized to a certain form, regardless of the process that could be employed to produce it
17:32:43 <roconnor> augur_: ZFC's axioms effectively presume a classical interpretation of the logical symbols.
17:32:46 <augur_> but ofcourse there's no reason why it should be, since the axioms work just as well in ITT as in CFOL
17:32:55 <roconnor> augur_: which is why IZF needs to rearrange the axioms
17:33:12 <augur_> they dont necessarily give you the same consequences, but the axioms are certainly plausible on different logics
17:33:37 <augur_> roconnor: i have no doubt that they rely on classical interpretations, yes.
17:33:49 <augur_> roconnor: fortunately you can neg-neg embed! :)
17:33:51 <ski> Sonarpulse : heh. in which sense are you differentiating between constructivism and intuitionism here ? (i know some commonly claimed differences, but i'm curious about what you had in mind)
17:34:19 <Sonarpulse> ^ i have read there are differences, I have no idea what they are
17:34:26 <roconnor> augur_: I don't think that thinking of ZFC as a collection of formal sentences is a resonable way to look at it.  ZFC is a theory and is the set of setences provable in FOL from those axioms.
17:34:29 <Cale> If you just try to naively reinterpret the symbols in the axiom of choice from classical first order logic, to the construction of a type, you'll get a type which will be inhabited, but the meaning of that type as a proposition in your type theory will have very little relationship to how the axiom of choice functions in ZF
17:34:47 <Sonarpulse> it sounded like what you were saying some intuitionists disagreed / thought some constructivist thing was not enough
17:34:48 <roconnor> augur_: and if you modfied the axioms of ZFC and got the same deductive closure, people would still consider that ZFC.
17:34:53 <listofoptions> Sonarpulse: AoC, DN, etc
17:34:59 <augur_> roconnor: thats a reasonable view.
17:35:12 <Sonarpulse> intutitionist has axiom of choice?
17:35:31 <Cale> augur_: How much of the HoTT book have you read?
17:35:44 <listofoptions> A form of it, I think, though it's been a while
17:35:48 <augur_> roconnor: but also since the neg-neg embedding exists, the whole theory is also still there, classically.
17:36:04 <Cale> augur_: They actually define an infinite family of variations on the axiom of choice, on top of the silly one which is just true :)
17:36:06 <augur_> Cale: oh gosh none of it. im watching harper's class literally as we speak tho! :)
17:36:20 <roconnor> augur_: the powerset axiom is problematic.
17:36:39 <augur_> roconnor: probably! i mean, ZF isnt computationally friendly, ill say that
17:36:45 <roconnor> augur_: and the DN interpetation of choice a little as well.
17:36:50 <augur_> they break the whole spirit of modern constructivism
17:37:08 <Cale> If you wanted to do functional analysis in HoTT and derive the same sorts of theorems as classically exist there, the AC which is just true in type theory won't get you very far at all.
17:37:19 * roconnor worries that ZF (and Coq) is inconsistent.
17:37:22 <ski> Cale : btw, i don't really like "statement which is true but not provable" way of expressing it either ;)
17:37:27 <Cale> But you still can pose other stronger axioms :)
17:37:27 <ski> (btw, i recall reading in a Smullyan book that some problems regarding having a logical system which can interpret itself (in the sense of a Tarski, truth `T'-predicate (translating between some formula representation, and the represented propositions) seems like they can be avoided if you have an intuitionistic meta system, because you then can't apply double-negation-elimination)
17:37:32 * augur_ doesnt care about ZF
17:37:32 <pyon> Just wondering... is there any data type in actual programming practice that is really a multiplicative group, considering all non-bottom instances of the type? (e.g., numbers are not becuase of zero)
17:37:36 <augur_> honestly, ZF is a waste of time
17:37:55 <augur_> modern intuitionism obviates the need for ZF completely
17:38:07 <Cale> ski: Whether it's true or not isn't the important bit, and the focus on that feels like the subtle influence of mathematical platonism to me.
17:38:09 <pyon> augur_: ++
17:38:19 <augur_> the whole set theoretic foundational stuff was _solely_ to ground arithmetic
17:38:20 <Cale> (which I am extremely opposed to)
17:38:27 <augur_> thats its only purpose
17:38:38 <roconnor> pyon: if you remove general recursion you can get rid of the bottoms and still (mostly) have a programming language.
17:38:39 <augur_> and we've since realized that it makes way more sense to not do that using sets
17:38:41 <Cale> augur_: Perhaps originally
17:38:45 <Cale> augur_: But not today!
17:38:55 <Cale> That would be a totally unrealistic thing to say.
17:39:01 <augur_> Cale: well now im sure ZF is investigated for its own purposes
17:39:19 <augur_> tho i cant imagine why
17:39:35 <Cale> augur_: Not just for its own purposes, but like it or not, ZF has been used as the putative foundations for much of mathematics as it exists today.
17:39:43 <augur_> and i suspect that ZF researchers feel they're doing something important and foundational
17:39:53 <pyon> roconnor: Actually, my problem is that I am bothered by the fact that you can only declare one Monoid instance per type, so I am sketching a type class system that fixes this by allowing "abstract classes".
17:39:59 <augur_> oh yes i know lots of people make gestures in the direction of ZF, Cale
17:40:04 <Cale> and large branches of mathematics owe their very existence to some of the details.
17:40:21 <augur_> which branches are those?
17:40:27 <Cale> Most of functional analysis wouldn't go through without a classically powerful version of the axiom of choice, for instance.
17:40:34 <Cale> Or measure theory
17:40:58 <augur_> there are versions of measure theory which dont depend on ZF
17:41:10 <Cale> and there are large swathes of abstract algebra which also rely on choice in one way or another
17:41:15 <augur_> i suspect most of them only make indirect use of ZF to justify certain things, but who knows
17:41:17 <roconnor> augur_: Set theoriests seem to investigate large cardinals, which may have some merit.
17:41:25 <cmiller_> I like all of my vector spaces to have bases.
17:41:28 <pyon> roconnor: Namely, Monoid is abstract and has two derived concrete classes: AddMonoid and MultMonoid. I just wondered whether it is similarly necessary to define AddGroup and MultGroup, or MultGroup is entirely unnecessary.
17:41:30 <Cale> cmiller_: Indeed!
17:41:50 <augur_> roconnor: you can i think get large cardinals without ZF
17:42:43 <mekeor> cmiller_: and that's only possible with axiom of choice?
17:42:56 <Cale> augur_: The trouble is that you can't just pick theorems up and move them to another system and expect everything to mean what it meant before, even if it's somehow still provable.
17:42:58 <listofoptions> while we're on the subject of logic can someone explain to me the tarski-grothendieck system?
17:43:08 <augur_> also again Cale, regarding functional analysis, the DN embedding obviates the complaint about classical power.
17:43:18 <Cale> augur_: uhhhh
17:43:36 <cmiller_> Yeah the two are equivalant.
17:43:44 <mekeor> oic
17:44:15 <augur_> Cale: all classically valid propositions are intuitionistically valid under the DN embedding
17:44:18 <cmiller_> There's an old joke. The axiom of choice is obviously true, the well ordering principle is obviously false, and who knows about Zorn's lemma.
17:44:39 <Cale> augur_: yes, but ZFC isn't just first order logic?
17:45:04 <augur_> Cale: yes but the complaints about classical power arent relevant to that
17:46:36 <Cale> augur_: I'm not going to say that you can't translate classical mathematics like e.g. the Hahn-Banach theorem into a type theory. I'm just saying that to do it in a way which is faithful to the original result requires more finesse about definitions than you're giving credit here.
17:46:38 <augur_> Cale: this is why ITT is so incredibly powerful: everything that is classically valid is _still there to be used_. you just put it under neg-neg and everything is fine
17:46:53 <augur_> Cale: no, it doesnt. the translation is mechanical.
17:47:45 <Cale> Well, okay, sure you can do that. If you want to formulate the axioms (and axiom schemas) of ZFC, and just use ZFC inside your intuitionist logic under double negation.
17:47:50 <augur_> you can take all of your classical proofs, DN embed them, and they become intuitionistic proofs, modulo the monadic lifting.
17:47:55 <Cale> But that's not really using the intuitionist logic any more
17:48:02 <augur_> Cale: uh.. yes it is
17:48:10 <augur_> thats the POINT of intuitionistic logic, in a way
17:48:14 <Cale> If you're always working under double negation
17:48:28 <augur_> its still intuitionistic logic
17:48:30 <Cale> Then you might as well use a classical logic and save yourself the trouble
17:48:54 <augur_> sure, modulo running your mathematical programs
17:49:04 <Cale> The tricky thing is getting a system in which constructive and classical results can coexist in a non-awkward fashion
17:49:06 <augur_> the power of ITT is the computational interpretation
17:49:10 <augur_> not what is or isnt provable
17:49:18 <Cale> Double negating everything is not something which people are going to put up with.
17:49:32 <augur_> why not? it's pretty cheap to do
17:49:58 <augur_> you just use liftM(n) f in place of f, and your proofs are translated
17:50:02 <Cale> The computational interpetation gets messed up if you're doubly negating everything as well.
17:50:14 <augur_> or if you're clever you use some kind of idiom bracket for monads.
17:50:15 <Cale> Well, it's still there, but it doesn't mean what you want
17:50:29 <augur_> depends on what you want
17:50:50 <Cale> You end up with everything being computationally pretty useless.
17:51:09 <listofoptions> Cale: there is / was see: Coq, AutoMath,
17:51:26 <Cale> listofoptions: I know about these :)
17:51:32 <listofoptions> :D
17:51:46 <augur_> Cale: eh. depends on how you measure uselessness, since the DN embedding is just a CPS computation
17:52:04 <augur_> and those seem to be pretty useful
17:52:09 <Saizan> Cale: i guess the idea would be to do most things "purely", and have a modality where you've access to extra axioms, but i guess one could just work hypothetically instead
17:52:32 <Cale> augur_: Pure CPS into an empty type isn't terribly useful in practice
17:52:33 <augur_> yeah, the other option ofcourse is to work under the LEM monad
17:52:36 <augur_> same thing, ultimately
17:53:40 <augur_> working under LEM is actually probably the easier choice, tbh
17:53:49 <augur_> since you can just parameterize your module by it, and work normally
17:53:49 <Cale> I personally prefer the way that HoTT seems prepared to do things with respect to LEM and AC.
17:53:57 <augur_> module ZF (lem : LEM) where ...
17:54:30 <Cale> of course, you have to be careful in HoTT, because if you're naive about defining LEM, you get something which contradicts univalence
17:54:51 <augur_> HoTT is still quite new. when we've got a nice HoTT based PL ill have more to say about it :P
17:55:21 <Saizan> yeah, that way of defining LEM and AC seems the most useful, but still if you don't keep track of where they are used you lose the computational content of whatever you do
17:56:39 <augur_> LEM isnt computationally nice anyway
17:57:16 <augur_> having it at all ruins your computational interpretation, at least until we invent oracle machines
17:57:25 <augur_> since thats what it's tantamount to.
17:57:52 <Cale> Well, it's an axiom, you can't compute through it
17:58:19 <Cale> (if you could, it probably wouldn't be an axiom!)
17:58:20 <augur_> Cale: yeah, but you also can never write a LEM library to allow computation
17:58:56 <augur_> so it just kills computation forever and ever and there's no point in having it if you want computation
17:59:08 <Cale> Right, but you can write libraries which do classical mathematics, and which rely on LEM and AC and other axioms without spoiling the computational nature everywhere.
17:59:31 <augur_> right, using Reader LEM!
17:59:33 <Cale> You just take LEM as a parameter where you need it.
17:59:41 <augur_> module ThisNeedsLEM (lem : LEM) where ...
17:59:55 <Cale> Why would you export LEM?
18:00:03 <augur_> thats import in agda
18:00:07 <Cale> okay
18:00:10 <augur_> well, not import, parameterization
18:00:25 <Cale> I wouldn't even do that
18:00:26 <augur_> when you want to use your LEM-depending module, you just supply it with LEM
18:00:30 <Cale> Just take explicit function parameters
18:00:42 <augur_> you mean use actual reader monads everywhere?
18:00:44 <augur_> you could do that
18:01:03 <Cale> If you want to call ordinary function parameters "reader monads"
18:01:08 <Cale> then yes
18:01:14 <lingxiao> uh what's the either maond transformer?
18:01:16 <augur_> but why? if you do it on the module, then you get them automatically when you use the module's contents
18:01:25 <lingxiao> like how do i get it?
18:01:25 <lingxiao> http://hackage.haskell.org/package/either
18:01:33 <Cale> augur_: Because you want to be aware of what things in the module actually needed it.
18:01:52 <augur_> Cale: ah yes, i suppose you could do that
18:02:12 <augur_> Cale: you could split your module of course
18:02:15 <lingxiao> I see there is one, but is it in Control.Moand.Either?
18:02:59 <roboguy_> lingxiao: it's in the module that it lists on that page
18:03:18 <augur_> Cale: i guess you could put all of your individual theorems into modules to do this nicer-ish
18:03:30 <Cale> sure, I guess
18:03:44 <augur_> then you can get LEM for just that theorem, and not have to use monadic style, making it even cleaner
18:03:57 <Cale> You don't have to use monadic style in any case
18:04:08 <Cale> I wasn't suggesting the use of a monad
18:04:17 <lingxiao> oops sorry yeah i meant to type Control.Monad.Trans.Either
18:04:18 <Cale> I was talking about passing LEM as a function parameter explicitly
18:04:24 <augur_> Cale: well it'd be nicer than threading that junk through by hand
18:04:32 <Cale> not necessarily :)
18:04:41 <augur_> i guess it depends really
18:04:48 <Cale> We're careful in classical mathematics about which things rely on AC
18:05:07 <Cale> I think people might get used to treating LEM in the same fashion
18:05:14 <roboguy_> lingxiao: if you have that package installed, then is it is in that module
18:05:20 <augur_> well again, i dont think you can avoid AC if you're using ITT
18:05:23 <roboguy_> *yes it is
18:05:32 <Saizan> there's a place for double negated lem as well though, for propositions which are double-negation-stable you get to do classical reasoning without losing anything
18:05:40 <Cale> augur_: AC needs to be added as an axiom if you want it to mean the right thing
18:05:55 <lingxiao> ohh i guess I'm not using it the right way then
18:06:00 <Cale> augur_: naive AC doesn't mean what AC means to ordinary mathematicians
18:06:02 <augur_> Cale: well lets true implementing it in agda to see!
18:06:14 <lingxiao> type Stuff t m a = ReaderT [t] (Either String m) a
18:06:21 <roboguy_> lingxiao: what's the problem?
18:06:59 <Cale> augur_: The whole point of AC in traditional mathematics is that it gives you things which are frequently by their very nature uncomputable
18:07:01 <lingxiao> X( uhh there is not problem... I had a problem... but it went away, prob misplaced the m
18:07:07 <Cale> augur_: Things like the well ordering on the reals
18:07:08 <lingxiao> sorry to clog the channel guys
18:07:22 <ski> augur_ : (re type theory) free choice for all !
18:07:26 <ski> augur_ : hm, doesn't neg-neg embedding only work for propositional logic ?
18:07:30 <Cale> lingxiao: You're actually talking about Haskell, which makes you on-topic
18:07:38 <augur_> Cale: yeah, but trad math is proof ignorant
18:07:50 <Cale> lingxiao: We're the ones who are clogging the channel with off-topic nonsense :)
18:08:08 <ski> (maybe i misremember, but istr needing something amounting to bar induction for embedding peano arithmetic in heyting arithmetic, anyway)
18:08:13 <ski> Cale : (re feeling of platonism), indeed
18:08:16 <Cale> augur_: In order to be faithful in your translation, you have to be aware of that
18:08:20 <ski> augur_ : istr reading that large cardinals (in ZF research) have something to do with "Mahlo universes", which (iiuc) are related to inductive-recursive definitions in e.g. Coq and Agda
18:08:28 <lingxiao> Cale: ha! much more interesting nonsense than my little details :)
18:08:36 <ski> ("w, ww, www. PS: ordinals, mahlo" by Peter Hancock in 1999 at <http://www.dcs.ed.ac.uk/home/pgh/wwwwww.html> mentions Mahlo a little, iirc)
18:08:44 <ski> cmiller_ : even if every vector space in some weak sense have a base, i don't think there's a canonical choice, which is why i'm suspicious of it (a version of it employing a weaker existential might possibly work ?)
18:08:48 <ski> augur_ : well, it appears that a linear version of LEM (possibly improperly called so), can be computed with ..
18:08:49 <cmiller_> Python has modules for all of this stuff. *ducks*
18:08:57 <augur_> Cale: yes but the contribution of proof-relevancy may be very great indeed
18:09:16 <augur_> cmiller_: for what stuff
18:09:39 <ski> btw, another interesting axiom candidate is the axiom of determinacy
18:10:03 <ski> iiuc, it appears like some kind of infinitary version of axiom of choice
18:10:13 <augur_> Cale: anyway, im not really interested in ZF(C) much :p
18:10:14 <cmiller_> The choice can't by definition be cannonical b/c it relies on choice.
18:10:15 <eazar001> anyone have a clue what might cause this lambdabot error: Plugin `sourcePlugin' failed with: state not initialized?
18:10:26 <cmiller_> for a basis that is.
18:10:43 <Cale> augur_: I don't deny that. But when translating what we already know, it's not okay to trivialise things which were done in a proof-irrelevant fashion. If you make the theorem harder to apply because its user needs to supply explicit witnesses where they wouldn't have to in traditional mathematics, you have to be careful about whether you're actually getting the translation right.
18:11:36 <Cale> If you translate the statement of choice in a naive way to type theory, it becomes absolutely trivial.
18:11:46 <Cale> But also almost completely useless.
18:11:48 <augur_> Cale: ZF-C is consistent right?
18:11:50 <Cale> yes
18:12:02 <augur_> so AC is truly an option either way
18:12:07 <Cale> yes it is
18:12:25 <Cale> (but ZF-C behaves really strangely in some ways)
18:12:33 <augur_> then that means that there cannot exist a way to use proof-relevance to get AC
18:12:49 <Cale> hm?
18:12:51 <ski> iirc, axiom of determinacy can be stated as : given `all x0. some y0. all x1. some y1. all x2. some x2. ... R(x0,y0,x1,y1,x2,y2,...)', deduce `some (f0,f1,f2,...). all (x0,x1,x2,...). R(x0,f0(x0),x1,f1(x0,x1),x2,f2(x0,x1,x2),...)'
18:13:13 <augur_> Cale: if there were, then ITT would be inconsistent
18:13:19 <ski> where `R' is an infinitary predicate, and the premise of the axiom has infinitely nested (alternating) quantifiers
18:13:50 <Cale> augur_: When you say that AC is a theorem, you're talking about a version of it where the existential parameter is a constructive one, and already contains the choices that the axiom of choice would normally have made for you.
18:13:55 <ski> game theoretically, it apparently amounts to infinite games being determined
18:14:10 <augur_> if ZF+AC and ZF-AC are both consistent internally, but you can use ITT to get AC, then you could use the -AC part of ZF-AC and ITT to prove false
18:14:12 <Cale> augur_: i.e. the caller of this naive AC has to know how to make the choices to begin with
18:14:27 <Cale> augur_: The real AC is supposed to make them for you
18:14:53 <Cale> (especially in cases where you can't compute them)
18:14:56 <augur_> Cale: thats not entirely true
18:15:16 <ski> (i've looked a little in a book that talks about what's regarded as desired consequences of axiom of choice, and undesired consequences of it (like Banach-Tarski), and also similarly for axiom of determinacy (which i think is inconsisted with axiom of choice))
18:15:46 <augur_> i mean, it depends on how you mean that.
18:15:55 <augur_> on what you mean by make"
18:16:01 <cmiller_> I don't think Banach-Tarski is necessarilly undesired.
18:16:23 <augur_> the whole ITT conceit is that classical notions of "make" are nonsensical
18:17:05 <augur_> but thats not relevant here
18:17:14 <augur_> i mean, it sort of is, but in a different way
18:17:28 <ski> cmiller_ : yeah, it was really talking about what's often regarded as desirable and undesirable consequences
18:17:39 <augur_> because the function space in question is not proof functions, its just ZF sets-as-functions
18:18:14 <Cale> augur_: In any case, one of the really nice things about HoTT (or just MLTT with some definitions stolen from HoTT) is that it has a very nice way to express something which behaves much like a traditional mathematician would expect of the axiom of choice, without awkwardly embedding ZFC as a second class citizen.
18:18:38 <Cale> augur_: You have something called the propositional truncation of a type
18:18:45 <augur_> Cale: er.. ITT = MLTT
18:18:53 <Cale> sure, if you want
18:19:01 <augur_> Cale: not "if you want"
18:19:01 <cmiller_> ski: Honestly I do numerical analysis. So 99.9999% of this is over my head, so I'm out. Have fun with the logic all.
18:19:07 <augur_> ITT is another name for MLTT
18:19:20 <Cale> I would normally take "intuitionistic type theory" to be a general term
18:19:25 <ski> hm, i think the book i was thinking about is "Axiom of Choice" by Horst Herrlich in 2006
18:19:27 <Cale> for a wide class of type theories
18:19:34 <augur_> sure, if you want
18:19:35 <augur_> :)
18:19:41 <augur_> but they're more or less all variations on MLTT
18:19:53 <Cale> anyway
18:20:09 <Cale> are you aware of the version of AC which reads something like:
18:20:13 <augur_> i dont know how you get choice in the way you want from that tho
18:20:27 <augur_> i guess maybe you're using truncation to get types to be ZF-like sets?
18:21:31 <Cale> (forall (x:X), ||exists a:A(x), P(x,a)||) -> ||exists (g : forall (x:X), A(x)), forall (x:X) P(x,g(x))||
18:21:40 <Cale> Where ||A|| is the propositional truncation of A
18:22:24 <Cale> and we assume some things about the free terms there as well
18:23:06 <augur_> Cale: thats the only version of choice i really am familiar with
18:23:07 <Cale> namely that X is a set, that A(x) is a set for all x:X, and that P(x,a) is a mere proposition for all x:X and a:A(x).
18:23:22 <Cale> augur_: Okay, well, that's not a theorem
18:23:30 <augur_> mm
18:23:32 <Cale> You can't compute with this
18:23:34 <augur_> the non-dependent one is
18:23:35 * ski was surprised of an intuitionist (non-type-theory) book claiming that axiom of choice can't hold in full generality because `forall x : |R. exists n : |Z. |x - n| =< 1/2' is true, but we don't believe we can compute the choice
18:23:43 <augur_> ill have to try the dependent one tho.
18:24:40 <ski> (my reaction to that is that because we can't compute the choice, then `forall x : |R. exists n : |Z. |x - n| =< 1/2' can't be constructively true -- though i think it could possibly be true for a weaker (modified) version of `exists' (which AoC doesn't apply to))
18:25:48 <ski> (then there's of course also Diaconescu's proof (in various variants) that AoC implies LEM, which i suspect to be fishy as well ;)
18:26:05 <Cale> There's also: for any set X and any Y: X -> Type, such that each Y(x) is a set, we have (forall (x:X), ||Y(x)||) -> ||forall (x:X), Y(x)||
18:26:23 <Cale> This is analogous to the statement that the Cartesian product of nonempty sets is nonempty
18:26:27 <Cale> and it's also not a theorem
18:27:24 <Cale> (and it's equivalent to the version of choice I gave before)
18:27:33 <ski> augur_ : btw, i assume you've seem "Intensional vs Extensional Choice" by roconnor in 2005-06-04 at <http://r6.ca/blog/20050604T143800Z.html> ?
18:27:42 <augur_> nope
18:28:28 <augur_> Cale: your version of choice is constructively valid
18:28:46 <augur_> at least for agda sets
18:28:52 <Cale> augur_: If by "constructively valid", you mean "is totally not provable at all"
18:29:00 <augur_> uh
18:29:03 <augur_> well i just proved it in agda
18:29:04 <augur_> so
18:29:05 <Cale> and not computable even in principle
18:29:12 <augur_> its completely computable
18:29:21 <Cale> I think you messed up your definition of propositional truncation?
18:29:22 <augur_> maybe you mean something different than what it looks like tho
18:29:28 <augur_> i didnt truncate anything
18:29:37 <Cale> If you remove the propositional truncations, this becomes trivial
18:29:59 <augur_> oh, are the ||'s your truncation notation? ok.
18:30:02 <Cale> yeah
18:30:04 <augur_> i dont know what those do
18:30:13 <ski> (afaiac, AoC is a logical law, a kind of distributivity law, to be specific. (i recall being surprised learning that it one of the forms of Axoim-of-choice, after having proved it Agda1, thinking it only being connected to Skolemization))
18:31:34 <Cale> For any type A, the type ||A|| has two constructors: for any a: A we have |a| : ||A||, and for any x, y: ||A||, we have x = y.
18:31:48 <Cale> Where x = y is Id(||A||,x,y).
18:31:48 <ski> augur_ : turns a type into another type that has at most element, and which is empty exactly when the original is empty, or something along that vein, i suspect
18:32:10 <augur_> Cale: ah
18:32:18 <ski> s/most element/most one element/
18:32:19 <augur_> lemme try to truncate then, thats easy enough to define
18:32:31 <Cale> It's a higher inductive type
18:33:42 <augur_> it also happens to be a type we can encode via proof irrelevance :)
18:33:42 <ndeine> am I the only one who is seeing "Page not found" for every page on http://hackage.haskell.org/package/yi
18:34:06 <augur_> Cale: its the identity type but with an irrelevant argument
18:34:12 <Cale> ndeine: no, you're not :)
18:34:21 <ndeine> Cale: well, Ok then.
18:34:23 <augur_> in agda:   record ||_|| (A : Set) : Set where field .a : A
18:34:35 <Cale> ndeine: I don't know why there's no build log linked there
18:34:53 <Cale> ndeine: But I would guess that either it hasn't been built yet, or doesn't build on the Hackage repo machine.
18:35:12 <ndeine> Cale: thanks for the explanation
18:35:20 <chrisdotcode> can you use a "let ... in " statement inside of a do block?
18:35:44 <Cale> chrisdotcode: It's an expression form, you can use it anywhere you can use an expression
18:35:55 <chrisdotcode> Cale: thought as much. thanks :)
18:35:56 <Cale> and in particular, sure, you can use one as a statement in a do-block
18:36:18 <Cale> chrisdotcode: What's more that you'll probably want to know, is that you can use let *without* in, as a statement in a do block
18:36:34 <Cale> chrisdotcode: and the declarations you make will scope over the rest of the block (including the let itself)
18:36:54 <chrisdotcode> Cale: yeah, I'm familar with let x = y inside of a do. it declares a value that doesn't have a side effect,right?
18:37:11 <Cale> Yeah, it declares some things without executing anything
18:37:40 <Cale> When you write v <- x, it means "execute the action x, and name the result v"
18:38:09 <chrisdotcode> yeah, I know at least *that* much about do :)
18:38:11 <Cale> while if you write  let v = x,  it means "define v to mean the same thing as x"
18:38:44 <Cale> cool, just thought I'd clarify terminology a bit :)
18:39:33 <chrisdotcode> Cale: is there a special name for a let expression inside of a do block?
18:39:47 <Cale> chrisdotcode: You mean the sort without in?
18:39:58 <Cale> You could call *that* a let statement
18:40:16 <chrisdotcode> Cale: no special name besides "let statement"?
18:40:33 <augur_> Cale: ahh interesting, it cant be proven! :)
18:40:35 <Cale> Well let *with* in, is definitely "let expression"
18:40:38 <roboguy_> well, "let statement" as opposed to "let expression"
18:40:43 <augur_> Cale: but for secondary reasons. how interesting.
18:40:56 <augur_> Cale: actually this looks very much like a monad
18:40:58 <Cale> augur_: Yeah, so that thing is actually really strong :)
18:41:30 <Cale> augur_: You can do many of the scary things you can do with the traditional axiom of choice with that (I hope all of them!)
18:41:45 <augur_> Cale: that is to say, you have to have a lemma   lemma :: (a -> || b ||) -> || a -> b ||
18:42:13 <augur_> which looks a lot like   (a -> m b) -> m (a -> b)
18:42:26 <augur_> which isnt true in general for monads. so i bet ||_|| is a monad!
18:43:10 <Cale> It is
18:43:21 <Cale> The join is easy, and the return is a constructor
18:43:32 <augur_> yeah
18:43:35 <augur_> hm!
18:43:39 <augur_> so thats interesting
18:44:02 <augur_> that answers an old question i had about making irrelevancy a thing at the level of types
18:44:08 <augur_> you can do it, and its a monad!
18:44:16 <augur_> that also means there should be a judgment for it
18:44:30 <Cale> In fact, there are many more such operators
18:44:40 <Cale> This is the first rung on an infinite ladder :)
18:45:27 <augur_> hm. the bind for this is trickier than the join
18:46:09 <augur_> oh no, it's not, it's just funny.
18:47:33 <augur_> yeah that makes sense that this should be a modality
18:47:51 <augur_> irrelevancy is like a bubble that cant be pierced by structure
18:48:09 <Cale> The one that's the next level up truncates types into sets
18:48:22 <augur_> whats that then?
18:50:27 <Cale> Hmm, trying to figure out a way to write it without introducing the circle as a type explicitly :)
18:50:49 <augur_> :)
18:51:06 <Cale> oh, well, of course
18:51:21 <Cale> You have a constructor A -> ||A||_0
18:51:42 <Cale> and for each x, y in ||A||_0 and each p,q : x = y, you have p = q
18:52:46 <Cale> (i.e. this is effectively the assertion that ||A||_0 is a set)
18:52:59 <augur_> ah
18:53:13 <augur_> i think agda does this by default, no? since the whole Id hierarchy has unique proofs
18:53:47 <Cale> This might be why we need --without-K
18:53:58 <Cale> (I haven't really looked closely at what K is)
18:54:21 <augur_> maybe. agda uses pattern matching ofcourse so i dont know how this comes through with K
18:57:29 <Cale> Everything should be fine if you restrict yourself to J for induction on identity types
18:58:50 <Cale> (or you can also use a version of J where you fix one endpoint of the path (one side of the equality) first.
18:58:55 <Cale> )
19:00:47 <twiceler> Is anyone here in the DC area? Thought I might mention that a Haskell meetup started in DC recently (http://www.meetup.com/Haskell-DC/)
19:02:46 <ndeine> twiceler: thanks
19:04:40 <twiceler> we could stand to have a few more people who are into Haskell :)
19:05:15 <augur_> twiceler: yep, im in college park
19:05:21 <augur_> well, not literally, but
19:05:30 <augur_> i go to school at umd
19:05:52 <augur_> i know a few people who might be interested in coming
19:05:59 <ndeine> twiceler: I probably won't be able to go (a bit too far from my part of VA)
19:06:22 <augur_> ah, one of them is already attending, twiceler!
19:07:07 <twiceler> Cool! There's a meetup in the works for late January or early February, and if you want to present anything, you definitely should!
19:07:28 <augur_> twiceler: dont know what i'd present :o
19:08:10 <twiceler> augur_: Cool, good stuff. Well, I'm new to this whole meetup stuff, so I don't know what people are looking for, so I don't really know either
19:08:53 <twiceler> augur_: But you certainly seem like you'd have the experience to! A lot of people at the first meetup were pretty new to Haskell
19:09:28 <augur_> well what are topics that people are interested in? also how much time is allotted usually?
19:09:57 <twiceler> I actually have no idea! Probably an hour is a good amount of time, but I'm sure you could do less, and probably more
19:10:28 <twiceler> Like would people want to see some stuff on Curry-Howard correspondence? Or something actually practical like using the parallel library
19:10:51 <augur_> i could do curry-howard, that's not hard at all
19:10:59 <ndeine> Oh, on the topic of parallel programming in Haskell (to all)
19:11:20 <ndeine> I am helping my school's math department build a GPU-heavy computer for parallel calculations
19:11:41 <twiceler> augur_: Haha, I was planning on presenting that if nobody else comes up with anything. You're definitely welcome to, though!
19:11:44 <ndeine> It has a beasty Nvidia card in it - is there any way to use Haskell to code on that thing?
19:12:04 <twiceler> ndeine: Yes, yes, yes (sort of). You can use Accelerate
19:12:35 <twiceler> ndeine: Or you can write a CUDA kernel, a simple C function to call it, and use Haskell's FFI (along with the cuda package)
19:12:35 <ndeine> twiceler: thanks, I was wondering if Accelerate was actually up to the job (or just in sort-of development)
19:13:05 <ndeine> twiceler: what could the benefits be of using Haskell for something like this, as opposed to straight C?
19:13:06 <augur_> twiceler: well, i would sit in the corner and gripe a lot at anyone else's presentation. im very opinionated about how to properly explain CH :)
19:13:15 <twiceler> ndeine: It depends on what you want to do. I've gotten frustrated with Accelerate for doing some things. But for some things, it's very nice
19:13:21 <ski> augur_ : i wonder whether, given `f : A -> B', where `f' is constant in the sense that `all x0,x1. f x0 = f x1', you can prove `|| A || -> B' ?
19:14:21 <augur_> ski: in agda probably not, but it seems like it ought to be true
19:14:28 <ski> augur_ : iow, use a hidden witness for `A' (e.g. essentially) in a computation of a `B', as long as you promise to give the same `B' value, regardless of what `A' value you get (but where you e.g. still need to get an actual `A' value to induct on)
19:14:31 <twiceler> augur_: Well by all means, you present instead of me! I have no shortage of other things to present about I think
19:14:36 <ndeine> twiceler: in particular, what the professor I'm working with is doing is ... uh, currently working with "diffusion of a chemical (or currently a protein) throughout a spatial region"
19:15:04 <twiceler> ndeine: Well, you can write the code that glues it together in Haskell
19:15:13 <ndeine> twiceler: "to preserve the continuum of a fluid or protein requires a very fine mesh -- usually about 512 x 64 grid points"
19:15:29 <augur_> twiceler: it would be a longer presentation tho, i think.
19:15:34 <twiceler> ndeine: Case in point. I use Haskell to make an immutable interface to CUBLAS
19:15:54 <augur_> twiceler: maybe even two parts, depending on how you want to do it.
19:15:58 <ndeine> twiceler: Oh, yeah that sounds right up our alley.
19:16:11 <augur_> twiceler: where are you getting space?
19:16:48 <ski> augur_ : of course, allowing that into the system for a version of `||_||' would mean that we can't have proof irrelevance (code extraction to say Haskell dropping all the passing of proofs of "mere propositions", for efficiency reasons) for that version of `||_||'
19:16:53 <countoren> hello im trying to convert this curl request to HTTP-Conduit :  curl -v https://api.sandbox.paypal.com/v1/identity/openidconnect/userinfo/?schema=openid \ -H "Content-Type:application/json" \ -H "Authorization:Bearer wxW5US2Tg6gFqk7gHXgWYuIVt1yvrhiSQy.Lrerc73Y"
19:17:04 <countoren> any help?
19:17:14 <ski> (possibly we'd want both a variant where we get proof irrelevance, and one where we don't)
19:17:33 <augur_> ski: would it?
19:17:40 <augur_> why would it prevent proving irrelevance?
19:17:53 <twiceler> augur_: I'm not in charge. The guy who is kindly being given the space at UberOffices in Arlington (near the Rosslyn metro)
19:18:29 <ski> because if you need to look at the actual witness for `A', to compute the `B', when proving `|| A || -> B', then surely you can't just drop the passing of the `A' witness in the code extraction
19:18:47 <slack1256> Any place to look for the cost model of haskell?
19:18:52 <slack1256> or that doesn't make sense?
19:18:55 <twiceler> augur_: Yeah, two parts might be cool, too
19:19:32 * hackagebot hosts-server 0.1.1 - An dns server which is extremely easy to config.  http://hackage.haskell.org/package/hosts-server-0.1.1 (YiHuang)
19:20:38 <twiceler> ndeine: So is it a sort of simulation where you iteratively update the mesh?
19:20:52 <ski> augur_ : er, possibly it wouldn't prevent proving (some version of) irrelevance (not sure exactly what you had in mind there). i was thinking of being able to elide passing around large amounts of witnesses for types which have at most one inhabitant anyway, for performance reasons
19:21:25 <slack1256> I have been thinking and the cost model of functions in haskell depends on the caller and the one being called
19:21:37 <slack1256> but can I get a lower bound thinking the function is strict?
19:21:45 <ndeine> twiceler: I believe so. I was not too involved in the actual simulation until now but judging from the professor's previous work on fluid dynamics and his general reserach interests I'm guessing so.
19:21:46 <slack1256> I mean I won't do more work that the strict version right?
19:22:32 <twiceler> ndeine: As far as I know, things of that nature may not be easy to do in Accelerate
19:22:36 <ski> slack1256 : i assume you're familiar with the idea of graph reduction as a way of representing thunks ?
19:23:51 <ndeine> twiceler: dang, we were hoping use of Haskell would actually make things *easier*
19:23:51 <slack1256> ski: No, I am recently learning about cost models, but I am willing to learn
19:23:57 <ski> slack1256 : i think Okasaki presents two alternate ways to account for cost (time and space) in his book, for a language whose implementation supports extensive programming with thunks
19:23:58 <twiceler> ndeine: Though the stencil computations in Accelerate may be what you're looking for
19:24:12 <ski> possibly his thesis mentions it a bit too, as well -- i haven't checked
19:24:15 <ski> @where Okasaki
19:24:15 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
19:24:18 <slack1256> Oh yeah, the banker's and physicist methods
19:24:42 <ndeine> hm, looks like the Stencil page on Hackage is broken just like the Yi one
19:24:43 <slack1256> but aren't those to calculate the credits you have to maintain the invariants?
19:24:43 <ski> slack1256 : the thesis is called "Purely Functional Data Structures", and the book is called the same, but includes more material
19:25:10 <ski> yeah, about amortization and such
19:25:18 <ski> were you thinking about something else ?
19:25:39 <ndeine> twiceler: I'll look into it; once I find some resources besides the broken Hackage page
19:25:45 <slack1256> time analisis of functions for example
19:25:57 <slack1256> but the same principles applies?, but I don't have invariants here.
19:26:41 <twiceler> ndeine: https://github.com/AccelerateHS/accelerate/wiki
19:26:43 <ski> i'd suspect that you can apply similar methods, but i haven't read anything specific on the topic
19:26:56 <ndeine> twiceler: thanks
19:30:15 <ParahSailin> whats the deal with monads-tf
19:30:46 <ParahSailin> kind of annoying having to specify mtl with PackageImports when I have that one installed in cabal at the same time
19:31:25 <ivanm> ParahSailin: they're two different ways of implementing the same functionality (mtl-2 used to be known as monads-fd)
19:31:27 <dcoutts_> ParahSailin: you don't need to do that
19:31:34 <ivanm> using type families and functional dependencies
19:31:42 <dcoutts_> ParahSailin: just ghc-pkg hide monads-tf
19:32:02 <ParahSailin> dcoutts_: if i hide it will things that depend on it still work?
19:32:09 <ivanm> Cale: do you happen to still be round?
19:32:16 <dcoutts_> ParahSailin: yes
19:32:21 <ParahSailin> dcoutts_: ok awesome
19:32:36 <dcoutts_> ParahSailin: hiding doesn't affect what cabal sees, just what you get by default with ghc/ghci
19:33:03 <dcoutts_> ParahSailin: which is also why you don't get that error when you build your code using cabal, only if you're using ghc/ghci directly
19:34:34 * hackagebot haskeline 0.7.1.2 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.7.1.2 (JudahJacobson)
19:35:45 <ajoox> Hello
19:35:52 <ajoox> Im brand spanking new to haskell
19:36:03 <ajoox> What materials would you reccomend I use after lyah
19:36:12 <ndeine> ajoox: real world haskell is always good
19:36:27 <kvda> ajoox: real world haskell
19:36:32 <ajoox> Thanks
19:36:41 <kvda> http://www.haskell.org/haskellwiki/Typeclassopedia
19:36:55 <kvda> and above
19:37:09 <twiceler> ajoox: Depends on what you're interested in. lyah is a great overview, so now if there's a certain direction...
19:37:24 <ajoox> No idea just yet
19:38:15 <kvda> Typeclassopedia… the more you know about types in haskell the less frustration you'll experience
19:40:06 <augur_> ski: ive decided that the One-True-Category for IPL is not CCCs but CCMulticats
19:40:54 <twiceler> ajoox: If you're interested in music, arrows, FRP: http://haskell.cs.yale.edu/?post_type=publication&p=112
19:41:16 <ski> augur_ : "Multicats" ?
19:41:18 <ajoox> Thanks, will look into it
19:41:34 <ski> "morphisms with multiple domains" ?
19:41:58 <augur_> ski: yeah
19:42:22 <ski> why ?
19:42:25 <augur_> ski: basically just instead of Hom : Ob -> Ob -> Set, you have Hom : List Ob -> Ob -> Set
19:42:47 <augur_> ski: why is because CCCs conflate structural and propositional conjunction, while multicats dont
19:43:01 <ski> mhm
19:43:15 <augur_> ski: you cannot, for instance, have implication without product in a CCC, so they cannot model \lambda_{->}
19:43:17 <ski> and structural disjunction in the conclusion of the entailment ?
19:43:24 <augur_> they can only model \lambda_{/\,->}
19:43:29 <ski> i see
19:43:44 <augur_> but \_{->} is perfectly legitimate as a logic
19:44:09 <augur_> multicategories are the general category for intuitionistic logic, i think
19:44:32 * ski . o O ( <http://en.wikipedia.org/wiki/Operad_theory> )
19:44:48 <augur_> operads are multicat monoids!
19:45:07 <augur_> where i mean the multicategory generalization of monoid=1obcat
19:45:16 <augur_> operad=1obmulticat
19:45:34 * ski . o O ( `1o1cat' )
19:45:54 <augur_> also i think we could generalize
19:46:04 <augur_> if a multicat has Hom : List Ob -> Ob -> Set
19:46:25 <augur_> then let an F-cat have Hom : F Ob -> Ob -> Set
19:46:32 <augur_> for F : Set => Set
19:46:53 <mgsloan> Ahah, and the clearly the comulticat category is the general category for ludics!
19:47:17 <mgsloan> (Sorry, carry on, some mighty high fallutin terminology is happening here!)
19:47:22 <beardtree> Someone said "a monad is a triple of (type, function, function)". What do both functions represent?
19:47:30 <mgsloan> (nothing wrong with that :) )
19:47:34 * ski fetches some broccoli for mgsloan
19:47:35 <johnw> beardtree: return and >>=
19:47:35 <augur_> ski: then you can have some notion of structural rule added on to this maybe? probably you want to actually enrich categories in their first hom position really
19:47:50 <johnw> or, depending on the someone, return and join
19:48:00 <startling> n.b. this is not true in Haskell
19:48:21 <Cale> beardtree: A monad consists of a type constructor T (of kind * -> *, i.e. it takes one type parameter and produces a type), together with return :: a -> T a, and (>>=) :: T a -> (a -> T b) -> T b
19:48:38 <Cale> beardtree: and moreover, return and (>>=) need to satisfy some conditions
19:48:57 <ski> augur_ : i'm assuming we probably want some "structural" condition on `F'
19:48:58 <augur_> ski: but i think the multicat route is the right way to go, since it would be nice to properly distinguish structural and propositional connectives
19:49:09 <mgsloan> I guess the comulticat category would have "Hom : Set -> (List Ob, Ob)"
19:49:10 <augur_> ski: yeah probably something like strict positivity
19:49:11 <Cale> beardtree: you might like to read: http://www.haskell.org/haskellwiki/Monads_as_computation
19:49:48 <augur_> ski: if we use lists we actually dont get IPL we get natural language
19:50:31 <ski> augur_ : iirc "Programming Martin-Löf Type Theory" has a section on "arities" in the beginning which might be related
19:50:40 <ski> s/Programming/Programming in/
19:51:19 <augur_> ski: i think you'd want a context category representing the relationship between contexts in the structural sense. eg whether or not you have all morphisms A,A -> A determines whether or not you have contraction
19:51:39 <ski> btw, i've pondered if `Set' in some sense could fit a role like a subobject classifier in `Cat'
19:51:53 <augur_> ski: and i think this would also let you have structural modalities too, because if you only have _some_ A,A -> A it seems like a mode
19:52:33 <ski> "mode" ?
19:52:36 <Cale> beardtree: Typically, T a will be some type of "computations producing results of type a", while return v will produce "the computation which does nothing but results in v", and x >>= f will be a sort of chaining, and will produce "the computation which first runs x, then applies f to its result and runs the resulting computation (producing the result of the second computation as the result of the whole)"
19:53:09 <augur_> ski: yeah, like, if you have propositional modal connectivies, you ought to also have structural modal connectives
19:53:19 <Cale> i.e. we run x first, then allow the function f to decide what to do next based on the result of that
19:54:07 <Cale> beardtree: What "computation" and "does nothing" and "runs" and "then" all mean will depend on context.
19:54:09 <augur_> ski: eg, who says you have to have only one structural connective? why not two? one has exchange, the other doesnt? or whatever
19:54:46 * ski . o O ( "Contextual Modal Type Theory" by Alexandar Nanevski,Frank Pfenning,Brigitte Pientka in 2007 at <http://www.cs.cmu.edu/~./fp/papers/tocl07.pdf> )
19:54:54 <Cale> beardtree: i.e. a monad can be provided by any library which happens to define things of these shapes, so long as they obey some laws which are consistent with the vague interpretation that I gave there
19:55:04 <augur_> ski: ill have to give that a look
19:55:24 <augur_> TLG uses modalities extensively, but i've never liked TLG's approach to structural rules. its all to ad hoc and model theoretic to me
19:55:26 <Cale> beardtree: Does any of that make sense? :)
19:56:24 <Aetherspawn> so, are constraints in the type universe
19:56:24 <beardtree> Cale: I'm piecing it together
19:56:25 * ski . o O ( "a Monad is just a Kleisli Triple, what's the problem ?" )
19:56:41 <Aetherspawn> because I like to think of contraints as how I think of types to values
19:56:55 <augur_> ski: for instance, the explanation of how it all connects up to the proof terms is wonky. the right answer is that the proof terms used in TLG are the denotation of a true proof term, using some interpretation function
19:57:06 <ski> Aetherspawn : with `ConstraintKinds', yes
19:57:19 <augur_> ski: which is fine model theoretically, but is weird if you're into curry-howard
19:57:30 <Cale> beardtree: Are you already familiar with how IO works in Haskell?
19:57:32 <joelteon> is it possible to write an operator that will compose constraints
19:57:33 <ski> `Eq :: * -> Constraint', `Monad :: (* -> *) -> Constraint', &c.
19:57:45 <beardtree> Cale: 'familiar'
19:57:50 <augur_> Constraint :: ???
19:57:51 <beardtree> Reading that link now
19:57:55 <Cale> beardtree: It can be good to know how to use some individual things which happen to be monads before trying to understand the abstraction
19:57:58 <ski> augur_ : "TLG" ?
19:58:21 <augur_> ski: type-logical grammar, the logical children of lambek calculus
19:58:31 <beardtree> Cale: maybe what would be useful is another example of a monad that isn't IO
19:58:40 <joelteon> Maybe
19:58:41 <augur_> ski: you might as well called it modal MBLL
19:58:58 <augur_> multimodal multiplicative bilinear logic
19:59:04 <Cale> beardtree: okay, let's look at lists :)
19:59:11 <Cale> beardtree: So here, T a = [a]
19:59:12 <ski> ok (for a monoidal functor is suppose. presumably not assumed to be braided)
19:59:29 <augur_> ski: ?
19:59:38 <Cale> beardtree: and we have  return :: a -> [a], and it does the obvious thing: return v = [v]
20:00:16 <Cale> beardtree: and for (>>=) :: [a] -> (a -> [b]) -> [b], let's think a bit about what something sensible of this type would be
20:00:26 <ski> augur_ : hm, actually when you said "lambek calculus", i realize i was thinking about Curry-Howard-Lambek
20:00:32 <augur_> ski: ah no
20:00:41 <augur_> ski: lambek calculus = categorial grammar
20:00:45 * ski nods
20:00:47 <Cale> So we have a list of apples, and a function from apples to lists of blueberries, and we need to get a list of blueberries :)
20:01:38 <augur_> ski: which is just IPL but without exchange or contraction or weakening (but retaining monoidality) so you get list contexts and two kinds of implication
20:01:51 <Cale> If we apply the function (a -> [b]) to each of the elements of our list of type [a] we'll get a list of lists, i.e. of type [b]
20:01:54 <L8D> @src putStr
20:01:55 <Cale> er, [[b]]
20:01:55 <lambdabot> putStr s  = hPutStr stdout s
20:02:02 <ski> augur_ : multimodal in which sense ? and why bilinear ? (e.g. why not multilinear ? perhaps i'm misunderstanding)
20:02:02 <Cale> We want something of type [b]
20:02:03 <L8D> @src stdout
20:02:03 <lambdabot> Source not found. That's something I cannot allow to happen.
20:02:16 <L8D> WHERE IS STDOUT DEFINED AND WHAT IS IT'S TYPE???
20:02:17 <Cale> So the natural thing to do then is to concatenate the list of lists
20:02:25 <Cale> L8D: stdout is in System.IO
20:02:29 <Cale> and it is of type Handle
20:02:29 <ski> augur_ : *node*
20:02:32 <augur_> ski: in the sense of having multiple modalities. bilinear because you lack exchange (bilinear means bidirectional implications)
20:02:34 <L8D> Cale: Thank you
20:02:36 <augur_> ski: *.js*
20:02:44 <johnw> at least, stdout is there, if not STDOUT ;)
20:02:46 * ski grains
20:02:52 <shachaf> @hoogle stdout
20:02:52 <lambdabot> System.IO stdout :: Handle
20:02:52 <lambdabot> GHC.IO.Handle.FD stdout :: Handle
20:02:52 <lambdabot> System.Posix.IO.ByteString stdOutput :: Fd
20:02:55 <Cale> beardtree: So, xs >>= f = concat (map f xs)
20:03:40 <Cale> beardtree: Let's have a look at what this gives us... we can write things like:
20:03:46 <L8D> Is there any function in haskell that will allow me to write to a file descriptor?
20:03:53 <augur_> ski: koninkje_away is working on a variant on it that has keyword arg functions
20:03:55 <L8D> an arbitrary file descripter
20:03:59 <johnw> L8D: there are several
20:03:59 <L8D> descriptor*
20:04:02 <Cale> > [1,2,3] >>= (\x -> [4,5] >>= (\y -> return (x,y)))
20:04:04 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
20:04:11 <L8D> johnw: Well, I only need to write one char at a time
20:04:18 <johnw> hPutChar
20:04:31 <L8D> > hPutChar 1 'h'
20:04:32 <lambdabot>  Not in scope: `hPutChar'
20:04:32 <lambdabot>  Perhaps you meant `putChar' (imported from Prelude)
20:04:37 * hackagebot bed-and-breakfast 0.4.2 - Efficient Matrix operations in 100% Haskell.  http://hackage.haskell.org/package/bed-and-breakfast-0.4.2 (JulianFleischer)
20:04:41 <johnw> I don't think System.IO is imported by lambdabot
20:05:02 <L8D> No instance for Num Handle
20:05:05 <startling> :t hPutChar
20:05:06 <lambdabot>     Not in scope: `hPutChar'
20:05:06 <lambdabot>     Perhaps you meant `putChar' (imported from Prelude)
20:05:16 <Cale> beardtree: Under the interpretation that I gave before, "running" a list will have to mean picking an element from it in all possible ways (with the understanding that all of the results of the rest of the computation from that point on will be collected up into a single list)
20:05:28 <hakujin> anyone have experience with Church encoded free monads? or I suppose Operational?
20:05:46 <johnw> L8D: I don't know how to interprert an arbitrary number as a Handle
20:05:53 <johnw> use "stdout"
20:06:03 <L8D> Perhaps there's a wrapper that will call fdopen in C
20:06:24 <Cale> beardtree: There are parsing libraries, which define a type Parser t of parsers which try to consume the beginning of some input string in order to produce a parsed result of type t
20:06:44 <L8D> johnw: Well, I want to write to both files and sockets
20:06:46 <Cale> beardtree: in that case, return v is the parser which accepts without eating any of the input, producing v as its result
20:06:50 <beardtree> A monad is basically a wrapper and unwrapper?
20:06:57 <johnw> L8D: hPutChar should work fine on a socket Handle
20:07:10 <L8D> What exactly is a handle?
20:07:17 <johnw> that would depend on the operating system
20:07:27 <johnw> on Unix it may well be just a number underneath, but it's not that on Windows I don't think
20:07:29 <L8D> Oh, I see. So not just POSIX fds
20:07:41 <ski> Cale : btw, do you know anything about attempting to view `Hom_C : C^op (*) C -> Set' as a kind of (set valued) relation, with `id_A : I -> Hom_C(A,A)' and `comp_{A,B,C} : Hom_C(A,B) (*) Hom_C(B,C) -> Hom_C(A,C)' (being dinatural or something like that in `A' resp `B', iiuc) being interpreted as this relation being reflexive and transitive ?
20:07:44 <Cale> beardtree: and x >>= f constructs the parser which will parse the beginning of its input with x, getting some parsed result v then parse the remainder of its input with the parser (f v)
20:07:53 <L8D> How can I transform a socket into a Handle?
20:08:17 <hakujin> L8D: some of the networking functions take Handles I think
20:08:17 <ski> augur_ : so bags with indices ?
20:08:20 <johnw> L8D: there is a "unix" package, which had an fdWrite function
20:08:36 <L8D> @hoogle fdWrite
20:08:37 <lambdabot> System.Posix.IO.ByteString fdWrite :: Fd -> String -> IO ByteCount
20:08:37 <lambdabot> System.Posix.IO fdWrite :: Fd -> String -> IO ByteCount
20:08:37 <lambdabot> System.Posix.IO.ByteString fdWriteBuf :: Fd -> Ptr Word8 -> ByteCount -> IO ByteCount
20:08:51 <L8D> I'll check out fdWrite
20:08:54 <johnw> you could say: Fd (fromIntegral 1), for example, although I'm not entirely sure that's what you really want to do
20:09:52 <carter> heheeh
20:09:53 <johnw> as for writing to a socket, there are lots of higher-level libraries which can do that job better in so many ways, depending on the problem you want to solve
20:10:06 <Cale> ski: By the first (*) I assume you just mean the product of categories, and the second (*), you mean the Cartesian product of sets
20:10:09 <L8D> fdWrite is exactly what I need, thanks!
20:10:19 <L8D> Though I might just change to passing around a Handle instead.
20:10:38 <Cale> beardtree: (producing the result of this latter parser as its overall result)
20:10:46 <johnw> i'm pretty sure the network package has a function for accepting on a socket and returning a Handle
20:11:18 <L8D> okay
20:12:00 <ski> Cale : hm, iirc, the latter `(*)' could possibly be a tensor product of some sort (so the category is enriched, then)
20:12:05 <Cale> ski: Are you aware that if you have a category which has at most one arrow between any two objects (and is small, so there's only a set of objects), that's the same thing as a preorder?
20:12:18 <ski> yes
20:12:21 <Cale> ski: In that case, it wouldn't likely be landing in Set
20:12:38 <Cale> A reflexive, transitive relation is the same thing as a preorder.
20:12:45 <ski> Cale : hm, possibly
20:13:24 <ski> hm
20:14:00 <Cale> So yeah, categories can be seen as generalisations of orders in that regard.
20:14:20 <ski> the idea was more or less that instead of booleans `false' and `true', we measure the "veracity" of a call to the relation with sets (empty set corresponding to `false', probably)
20:14:32 <Cale> right
20:15:28 <Cale> When you translate a preorder into a category, the notion that a <= b is replaced by the existence of an arrow f: a -> b
20:16:11 <Cale> and of course, one particular type of preorder is the provability relation
20:16:14 <augur_> ski: yeah, basically
20:16:24 <ski> so then i wondered whether it would be possibly to see `Hom_C : C^op * C -> Set' as representing a kind of binary relation in (i think ?) `C -> C', where this is another category than `Cat', where a morphism `A -> B' corresponds to a functor `A^op * B -> Set', or something like that
20:16:31 <Cale> and you can enhance that into a more interesting category of proofs, more often than not
20:16:32 <ski> (not sure about the `^op's)
20:16:32 <augur_> ski: well, sort of
20:16:50 <augur_> ski: contexts in IPL are bags with indexes, fwiw!
20:17:26 <Cale> Where you define some sort of identity derivation that A |- A, and some sort of associative composition of proofs by concatenation
20:18:19 <Cale> ski: I'm not sure about this last bit :)
20:19:11 <ski> (and then one could possibly get something like `id : I -> Hom_C' and `comp : Hom_C . Hom_C -> Hom_C', which looks interesting)
20:20:53 <ski> Cale : *nod*
20:23:24 <Cale> ski: Certainly, you can look at things from the point of view of enriched category theory, and since the category of endofunctors on C is a monoidal category, if we pick V = [C,C], then we'd have for a category E enriched over V,
20:23:33 <Cale> a class Ob(E) of objects
20:23:41 <ajoox> Can someone help me understand something?
20:23:43 <ajoox> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
20:23:49 <ajoox> What is x <-
20:23:52 <ajoox> I dont get that
20:24:05 <Cale> for each X, Y objects of E, a choice of functor E(X,Y) : C -> C
20:24:32 <joelteon> ajoox: choose x from xs
20:24:45 <Cale> for each X an object of E, a natural transformation id_X : I -> E(X,X)
20:24:50 <ajoox> Thanks
20:25:08 <ski> is `[C,C]' here a comma category or something ?
20:25:27 <Cale> [C,C] is the category of endofunctors on C and natural transformations between them
20:25:38 <roboguy_> ajoox: are you familiar with list comprehensions in any other languages (like python for instance)?
20:25:42 <ski> oh, `C^C'
20:25:49 <ajoox> roboguy_: Only in python actually
20:26:04 <Cale> for each X, Y, Z objects of E, a natural transformation E(Y,Z) . E(X,Y) -> E(X,Z), where here . is functor composition
20:26:19 <Cale> (they're endofunctors on C, so must be composable)
20:26:26 <ajoox> list_a = [x: for x in range(1,101) if x % 2 == 0]
20:26:39 <roboguy_> ajoox: the <- is like the for ... in ... part
20:26:44 <roboguy_> more or less
20:27:31 <ajoox> I think I get it
20:27:31 <ajoox> thanks
20:27:32 <roboguy_> it takes a value out of the list and it does this for each value in the list
20:27:44 <Cale> and then we'd have to express some laws regarding the associativity of our composition natural transformation, and the fact that our id_X natural transformations act as identities for that composition
20:27:56 <verement> > [ x | x <- [1..101], even x ]
20:27:57 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
20:27:57 <Cale> The terminology will of course get quite confusing ;)
20:28:35 <dleedev> is MonadPlus simply Monad that can be `msum`ed and has an `mzero`?
20:28:45 <johnw> mplus and mzero
20:28:56 <dleedev> basically a Monad instance that's also monoidal?
20:28:59 <kristof> Is there something fundamentally incompatible between functions of variadic arity and Haskell's type system?
20:29:02 <johnw> pretty much
20:29:23 <Cale> dleedev: basically, a monad which creates a monoid for each type it's applied to
20:29:34 <johnw> kristof: what do you mean?
20:29:39 <dleedev> where does "Plus" come from?
20:29:41 <ski> hm, my `.' above beween two `Hom_C's doesn't correspond to your `.'. since (part of) the point of my was to hide the intermediate `B'/`Y', like `y' can be hidden in `exists y. r(x,y) /\ r(y,z)' in case we can write `r(x,y)' as `f(x) = y', since then the existential thing becomes `f(f(x)) = z'
20:29:58 <johnw> dleedev: a lot of monoids describe their associative operation as addition or multiplication
20:30:11 <Cale> ski: Okay, then I'm not sure what's going on :)
20:30:15 <johnw> so not Plus in the arithmetic sense, but plus in the general monoid sense
20:30:16 <kristof> johnw: You can't define a function in Haskell that takes an arbitrary amount of arguments. Why?
20:30:30 <Cale> kristof: You can, using type classes.
20:30:32 <roboguy_> MonadMonoid doesn't have the same ring to it. also I think a monad is monoidal anyway
20:30:33 <johnw> kristof: well, you can, it's just not trivial
20:30:35 <shachaf> kristof: Sure you can.
20:30:36 <Cale> Or just ordinary polymorphism
20:30:39 <shachaf> id, for instance.
20:30:42 <dleedev> johnw: why don't they standardize on `mappend` or `mplus`?
20:30:42 <ski> one could use nested syntax like `f', even if it's not a function (it's a "nondeterministic function", like with a set monad)
20:30:58 <johnw> dleedev: what do you mean?  Monoid already took mappend
20:31:00 <roboguy_> dleedev: what do you mean or?
20:31:07 <kristof> johnw: It would be better to just pass a list with all the "other junk", then, huh?
20:31:10 <Cale> > foldr (\x s -> x + s) 0 [1,2,3]
20:31:11 <lambdabot>  6
20:31:16 <verement> @hoogle printf
20:31:17 <johnw> kristof: that's the typical approach
20:31:33 <Cale> > foldr (\x s n -> x + s + n) (const 0) [1,2,3] 4
20:31:34 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = a0 -> a0
20:31:36 <roboguy_> dleedev: a type may have Monoid and MonadPlus instances that do different things. Maybe, for example
20:31:36 <dleedev> roboguy_, johnw: why don't they make MonadPlus a Monoid and simply choose to use one of either `mappend` or `mplus`?
20:31:37 <Cale> oops :)
20:31:49 <johnw> dleedev: MonadPlus has a different kind
20:31:57 <roboguy_> ^ that too
20:32:04 <Platz> Is there any way to know if the monad I have is in a 'minimal default' context e.g. "return () :: IO ()", doesn't actually do IO, but you can't tell from the type.  I'm curious because I wondered if i could `sequence` the result of `sequence`, but I realized the default sequence just wraps the result in a return, so you couldn't do the IO twice.
20:32:08 <dleedev> :k MonadPlus
20:32:09 <lambdabot> (* -> *) -> Constraint
20:32:10 <dleedev> :k Monoid
20:32:11 <lambdabot> * -> Constraint
20:32:12 <roboguy_> > Just 1 `mplus` Just 2
20:32:13 <lambdabot>  Just 1
20:32:24 <roboguy_> > Just (Sum 1) `mappend` Just (Sum 2)
20:32:25 <lambdabot>  Just (Sum {getSum = 3})
20:32:42 <ski> and the idea was to attempt to use some similar idea to rewrite `comp_{A,C} : (exists B. Hom(A,B) * Hom(B,C)) -> Hom(A,C)' into `comp_{A,C} : (Fom(Fom(A)) = C) -> (Fom(A) = C)' (or something like that, which we'd then abbreviate as `comp : Fom . Fom -> Fom'
20:32:42 <roboguy_> > Just 1 `mappend` Just 2  -- This won't work
20:32:43 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
20:32:43 <lambdabot>    arising from a use of `e_112'
20:32:43 <lambdabot>  The type variable `a0' is ambiguous
20:32:43 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
20:32:43 <lambdabot>  Note: there are several potential instances:
20:32:44 <Cale> Well... let's do this example:
20:32:55 <Cale> >  foldr (\x f -> f . (x:)) id [1,2,3] []
20:32:56 <lambdabot>  [3,2,1]
20:33:20 <Cale> ^^ foldr can be applied to more than 3 arguments
20:33:24 <ski> Cale : i'm not sure whether it makes any sense, it's a kind of syntactical trick about which i'm wondering whether it has any significance
20:33:58 <stelleg> anyone else have issues with compatibility with newer versions of text?
20:34:13 <roboguy_> dleedev: you can't make a MonadPlus instance of Maybe that behaves in the way that it's Monoid instance does as a result of the kind difference between the two classes
20:34:38 <roboguy_> specifically, because you can't put a constraint on the type argument to Maybe in a MonadPlus instance
20:34:45 <roboguy_> and you can in the Monoid instance
20:35:14 <ski> (another way to ponder it, without introducing the "nondeterministic function" notation, could be to simply define `.' in `Hom . Hom -> Hom' as a kind of relational composition on `Hom : C^op * C -> Set')
20:37:10 <Cale> > foldr (\x s a b -> s b (a+b)) (\x y -> y) [1..11] 0 1
20:37:11 <lambdabot>  144
20:37:18 <dmwit> stelleg: You should probably show off the code you tried, how you compiled/interpreted it, the exact error message... the usual.
20:37:31 <Cale> ^^ fibonacci numbers via foldr with 5 args ;)
20:37:46 <dleedev> roboguy_: so MonadPlus makes a parameterized type a monoid, whereas Monoid makes a concrete type a monoid?
20:37:54 <Cale> kristof: ^^
20:38:03 <jle`> is someone talking about MonadPlus
20:38:15 <stelleg> dmwit: thanks, I unregistered it with ghc-pkg and that worked, but thanks
20:38:25 <roboguy_> dleedev: sort of, yeah. a MonadPlus instance must also be an instance of Monad
20:38:29 <roboguy_> as well
20:38:32 <Cale> dleedev: If m is an instance of MonoidPlus, then m t is a monoid for each type t
20:38:51 <Cale> dleedev: So an instance of MonoidPlus is effectively infinitely many monoids (one for each type)
20:38:55 <dmwit> s/MonoidPlus/MonadPlus/g
20:38:56 <johnw> MonoidPlus = freudian slip?
20:39:00 <Cale> MonadPlus
20:39:10 <Cale> yes
20:39:35 <joelteon> MonoidPlus - a monoid with mappend
20:39:40 <Cale> heh, I'm up a few hours later than I was yesterday at this point ;)
20:39:55 <Cale> MonoidPlus - a ring ;)
20:40:00 <augur_> hm
20:40:05 <joelteon> MonoidMinus
20:40:07 <joelteon> a semigroup
20:40:26 <johnw> I think it would be a group
20:40:47 <dleedev> where do pipes fit in?
20:40:50 <augur_> does anyone know if dependent types without a Type type are capable of doing things that having a Type type makes difficult due to needing a hierarchy?
20:40:53 <johnw> PipesPlus
20:40:54 <Cale> johnw: Well, a ring is exactly a multiplicative monoid, with a + which makes it into a commutative group :)
20:41:05 <augur_> or does this become inconsistent?
20:41:10 <johnw> Cale: I mean, a Monoid which supports minus
20:41:17 <Cale> (together with a distributivity law)
20:41:19 <Cale> ah
20:41:25 <Cale> Yeah
20:41:30 <augur_> oh, its probably ok, but doesnt have proper type-level computation, i bet.
20:41:35 <Cale> If you can take inverses, then it's a group
20:41:56 <augur_> and thats what type families are good for! aha!
20:43:27 <Cale> "Have more models" is probably one of them
20:43:56 <Cale> But I think it'd only be external considerations which would be made easier
20:44:37 <joe9> this is my program: http://codepad.org/h19IFF3J . The parameter can be either "12345" or "1.12345". I want to do different things based on what this parameter is. I presume that there must be a better way of doing lines 29-41 of the program. Any thoughts, please?
20:44:42 * hackagebot hi 0.0.7 - Generate scaffold for cabal project  http://hackage.haskell.org/package/hi-0.0.7 (DaisukeFujimura)
20:45:30 <kmicklas> yeah type theories without universes should be strictly less powerful, but easier to analyze
20:45:35 <Cale> joe9: Why not check for the "1." first?
20:46:23 <augur_> can type families by recursively computed?
20:46:25 <dmwit> > (reads :: ReadS Rational) "1.12345"
20:46:26 <lambdabot>  []
20:46:33 <dmwit> bah, humbug
20:46:51 <dmwit> augur_: With UndecidableInstances anything is possible!
20:47:06 <augur_> dmwit: :)
20:47:07 <joe9> Cale, I tried. but, could not figure out how to.
20:47:44 <Sonarpulse> auger: look up type in type
20:48:05 <roboguy_> joe9: what about a pattern match like you have in checkAgain?
20:48:11 <augur_> Sonarpulse: yes, im aware its problematic
20:48:25 <augur_> Sonarpulse: but system f lack's a type type and so avoids the hierarchy fix
20:48:34 <augur_> its also impredicative, of course, but isn't inconsistent
20:49:30 <ski> > show (1.12345 :: Rational)
20:49:31 <lambdabot>  "22469 % 20000"
20:49:36 <augur_> i dont like the idea of having a Type type, now that i think about it
20:49:45 <augur_> because it lacks an elim
20:49:51 <jle`> does anyone familiar with netwire here know the semantics of the Left/e type of the Either used in the Mealy machine/Wire type?  And why it needs to be a Monoid?
20:49:55 <roboguy_> joe9: also I would suggest (at some point) refactoring a little to avoid using IO so much
20:50:21 <roboguy_> or at least try to separate most of the logic from IO
20:50:24 <joe9> roboguy_: it is a wip. hence, using IO. I have to add IO procedures later.
20:50:26 <joe9> to that code.
20:51:42 <Cale> augur_: Well, what would an elim for it look like?
20:51:49 <jle`> huh i just had a problem where adding scoped typevariables and forall's fixed the entire error
20:51:51 <jle`> magically
20:51:54 <jle`> and i do'nt even know how.
20:51:56 <jle`> this is very unsettling.
20:52:15 <augur_> Cale: well, it couldnt be open ended, firstly
20:52:22 <jle`> does anyone else try to spell out things with there forall a b c d. 's
20:52:23 <jle`> ?
20:52:33 <augur_> Cale: well actually it could be since each time you type check you have different axioms
20:52:53 <augur_> Cale: but it would just allow case on types, which would break parametricity and therefore wouldnt be desirable
20:53:03 <Cale> augur_: There's cumulativity
20:53:08 <augur_> Cale: ey?
20:53:12 <Cale> Which isn't exactly an eliminator
20:53:25 <Cale> But it gets rid of one universe in exchange for the next
20:53:33 <augur_> no thats not how it would have to work
20:53:46 <roboguy_> joe9: isInteger could be isInteger st = not (null st) && all isNumber st
20:53:49 <joe9> http://codepad.org/B4drNbVV this is after incorporating hlint suggestions.
20:54:08 <CupOfLifenoodles> I've started "Parallel and Concurrent Programming in Haskell". In the book's examples he doesn't need to use the -N2 flag for his program to run in parallel, but if I run without the flag all my sparks fizzle/overflow. Is there something wrong with my setup?
20:54:10 <augur_> to behave like a proper elim, it has to interact with the intros in just the right way, and it would end up looking like any other sum type
20:54:55 <ski> jle` ?
20:55:05 <jle`> ski: like forall a b c d .
20:55:06 <pingu_> CupOfLifenoodles: it's probably just omitted in the book, incorrectly. You will need to use -N2 for parallellism
20:55:07 <jle`> like
20:55:08 <shachaf> CupOfLifenoodles: Are you sure about that?
20:55:11 <jle`> i try to rearrange it
20:55:11 <roboguy_> joe9: by the way, lpaste.net does syntax highlighting
20:55:11 <pingu_> CupOfLifenoodles: concurrency is a different thing
20:55:13 <jle`> so that it spells something
20:55:16 <jle`> haha
20:55:27 <jle`> like of i have forall e m t a. i might do forall m e a t.
20:55:35 <jle`> because...i like meat i guess.
20:55:49 <augur_> jle`: two fat ladies's meatloaf is great. just sayin.
20:55:50 <enthropy> forall t a m e.  forall m a t e
20:55:55 <Hafydd> Don't be so selfish. forall t e a m
20:55:57 <ski> augur_ : perhaps one could have it "inside" the entailment, like with typing jumps in continuation calculi
20:56:06 <augur_> ski: ??
20:56:09 <joe9> roboguy_: but, using that version of isInteger means I lose the error messages.
20:56:30 <CupOfLifenoodles> shachaf: I verified by comparing using the -s option to see literally every spark overflowing/fizzling
20:56:31 <jle`> i'm sure it can't be just me
20:56:33 <jle`> ><
20:56:34 <Cale> augur_: I'm not sure what you're proposing. Get rid of dependent types?
20:56:40 <CupOfLifenoodles> pingu: which part of this would be concurrency?
20:56:41 <shachaf> CupOfLifenoodles: I mean, are you sure he's not using -N?
20:56:45 <augur_> Cale: no
20:56:55 <joe9> roboguy_: http://codepad.org/fMnut3ut
20:56:56 <roboguy_> forall m e t a.
20:57:00 <jle`> so meta
20:57:03 <shachaf> Do you have a link to the example?
20:57:17 <Twisol> I've been playing with lens a little bit, and I'm running up against a problem. Suppose I have something that looks like [[String]], and I want to get the i'th element of the outer array, then map (read :: String -> Double) over it, so that the final result is Maybe [Int]. What's the cleanest way to do this?
20:57:37 <augur_> Cale: i was suggesting initially that instead of having a type Type, you just have the _type judgment, but somehow you'd have to be able to define functions that produce types
20:57:59 <enthropy> Twisol: so there's a round in there?
20:58:00 <Cale> Well, you'll still probably need an infinite hierarchy of them
20:58:09 <ski> augur_ : well, you can entailment judgements of at least the three forms `Gamma |- e : tau | Delta', `Gamma | k : tau |- Delta' and `Gamma |-{j}- Delta', where `Gamma' is an environment of value variables, `Delta' an environment of continuation variables, `e' a value expression, `k' a continuation expression, and `j' a jump (typeless)
20:58:10 <augur_> Cale: no, the type judgment has no hierarchies
20:58:14 <Cale> hmm, maybe not
20:58:16 <dleedev> so for Monoid, MonadPlus, and Alternative, is this a right way to think about it:
20:58:16 <Twisol> enthropy: Sorry, I mistyped. I want Maybe [Double]
20:58:18 <ski> (`tau' is of course a particular type)
20:58:21 <augur_> Cale: System F has no hierarchy
20:58:37 <roboguy_> joe9: you could combine checkAgain and process
20:58:39 <augur_> ski: what is this about, now?
20:58:44 <Cale> It also has no dependent sums or products
20:58:50 <augur_> Cale: which?
20:58:54 <Cale> System F
20:59:03 <augur_> Cale: oh, yes, but it has no type functions thats why
20:59:05 <Cale> augur_: You want to avoid something along the lines of the problems that happen with type in type
20:59:08 <ski> (the `|' is to be thought of as `,', except that it serves to separate a special part of that side of the entailment from the other part (the value/continuation environment)
20:59:18 <ski> augur_ : continuation calculi
20:59:19 <augur_> Cale: right.
20:59:27 <augur_> ski: yes but in response to what?
20:59:44 * hackagebot egison 3.2.5 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.5 (SatoshiEgi)
20:59:51 <ski> <augur_> i dont like the idea of having a Type type, now that i think about it
20:59:52 <augur_> Cale: i suspect that this would preclude higher order functions. or maybe not? i dont know
20:59:53 <roboguy_> joe9: in fact, if you combine those two, you can also move the error from isInteger to process
20:59:55 <ski> <augur_> because it lacks an elim
21:00:01 <ski> in response to that
21:00:03 <augur_> ski: ok. i dont think that would work.
21:00:17 <enthropy> > [["1","2"],["2"]] ^. ix 0 & mapM readMaybe :: Maybe [Double]
21:00:18 <lambdabot>  Not in scope: `readMaybe'
21:00:40 <augur_> ski: its clear what the elims should be, it's not a mystery. its just undesirable to have an elim.
21:00:40 <ski> (not really suggesting to mix in continuations, but rather to attempt to type check types in a similar way as jumps `j' above)
21:00:47 <enthropy> dunno how lens is really needed/helpful here
21:00:55 <Cale> augur_: Why do you want an eliminator for universes?
21:01:02 <Twisol> enthropy: It's a simplification of something more complicated, with custom data types.
21:01:10 <Cale> I don't really understand what having such a thing would mean
21:01:13 <augur_> Cale: every type must have an elim, if you want to prove soundness and completeness of the type theory
21:01:25 <augur_> or at least thats the most straight forward way to do it
21:01:36 <Twisol> enthropy: I want to be able to delve into a data type, grab some part of it, and fmap over it, while retaining the fact that it's in a Maybe or [] (via ^? or ^..)
21:01:36 <Cale> Do we really want completeness?
21:01:47 <augur_> Cale: well, you can leave out completeness
21:01:54 <CupOfLifenoodles> shachaf : you're right, the book's perfect, I missed that he switched to using -N2 on the later examples
21:02:00 <roboguy_> joe9: oh, another thing, "runhaskell" uses whatever haskell compiler they have and doesn't necessarily depend on ghc. not a huge difference, since basically everyone uses ghc, but it can't hurt
21:02:07 <joe9> roboguy_: you mean change the otherwise on line 25 to : head mi == 1 && head . tail mi == '.' && isInteger (tail . tail mi)?
21:02:25 <roboguy_> joe9: I'd do pattern matching
21:02:50 <joe9> roboguy_: how can I do pattern matching and guard isInteger?
21:03:04 <joe9> Is that possible?
21:03:42 <roboguy_> joe9: like this process ('1':'.':xs) = isInteger xs; process xs | isInteger xs = ... | otherwise = error ...
21:03:49 <roboguy_> with appropriate new lines
21:03:58 <joe9> roboguy_: cool, thanks.
21:04:01 <augur_> Cale: its just, in general, when you have intros, you also have elims, otherwise you're magicking up some truths. maybe thats what having a Type type really is saying: types _are_ a magicking-up of a truth
21:04:10 <joe9> roboguy_: did not know that it was possible.
21:04:36 <roboguy_> joe9: yep. guards and pattern matching are two mostly separate features
21:04:44 <roboguy_> and can be mixed and matched, generally speaking
21:05:11 <Cale> augur_: Sure, we're assuming the existence of an infinite hierarchy of universe types.
21:05:27 <augur_> Cale: are we? when did that happen?
21:05:39 <Cale> In order to not have Type in Type
21:05:53 <augur_> Cale: oh sure
21:06:14 <augur_> but even so, how does that mean you're justified in magicking up truths? i dont know
21:06:29 <Cale> How are you justified in magicking up product types?
21:06:42 <Cale> They're our rules, we get to decide what they are :)
21:06:48 <augur_> Cale: you can show that they dont give you any more inferential power than you already had
21:07:12 <augur_> whats what beta does: having products doesn't let you prove anything you couldnt already have proven
21:07:13 <Cale> So? Still doesn't mean that product types have to exist.
21:07:21 <augur_> Cale: no, but its a justification
21:07:47 <augur_> its a way of saying, look, im not getting anything new here except presentation of knowledge
21:08:29 <augur_> whereas with a Type type, you're getting a new true proposition (Type) that is true by fiat.
21:08:32 <augur_> i guess maybe thats fine?
21:08:34 <augur_> i dont know
21:08:51 <Cale> I've always been happy to accept an axiom if it seems fun
21:09:04 <joe9> roboguy_: http://codepad.org/f5bFdS7M
21:09:05 <augur_> Cale: yes, because you're not a constructivist. :)
21:09:19 <Cale> I'm a constructivist some of the time
21:09:28 <startling> @remember Cale I've always been happy to accept an axiom if it seems fun
21:09:29 <lambdabot> Good to know.
21:09:29 <augur_> you lack the philosopher's angst
21:09:34 <joe9> roboguy_: thanks for your help.
21:09:37 <startling> oh, that's not the right thing.
21:10:01 <Cale> augur_: Mathematics is fundamentally a game to me
21:10:12 <startling> oh, no, it is. carry on.
21:10:12 <augur_> yes i know
21:10:17 <augur_> we've had this conversation before
21:10:19 <Cale> (or a related collection of games :)
21:10:33 <augur_> i prefer my mathematics to be computable, and philosophically beautiful :P
21:11:45 <augur_> math-as-a-game is just having record types x3
21:11:48 <Cale> But okay, I can accept that the universe types lack some of the symmetry that the other constructions have
21:12:20 <Cale> But if you're going to ruin the game by taking them out, what are you going to put in their place?
21:12:30 <Cale> and will that thing be any more symmetrical?
21:12:54 <augur_> i dont know!
21:13:22 <augur_> i mean, judgments, at least, dont have to be justified in the same way, since the role they play is more fundamental that propositions
21:13:45 <Cale> I can easily imagine sticking in judgments that control the level of types
21:13:54 <augur_> its not the levels that are the problem, Cale
21:14:32 <augur_> the problem is the lack of elims, and the seeming necessity of this
21:14:38 <augur_> in order to preserve parametricity
21:14:54 <augur_> tho i suppose IF you have relevance, you can define a parametric quantifier?
21:14:58 <Cale> I'm talking about the problem that universes *solve*
21:15:04 <augur_> yes but im not :P
21:15:10 <Cale> If you take out the universes, you have to solve that problem some other way
21:15:20 <Cale> and control your type formation rules somehow
21:15:31 <augur_> yes, it usually comes down to universes elsewhere
21:15:40 <Cale> and yeah, you could put in additional universe judgments
21:15:54 <augur_> like, instead of `A type` you have `A type n`
21:15:57 <dleedev> how is Alternative different from a MonadPlus besides the fact that the former must be an Applicative and the latter a Monad?
21:16:07 <Cale> But then you'll still end up assuming universe axioms as explicit parameters in various places
21:16:27 <Cale> I guess if you like that, you can have it!
21:16:32 <augur_> yes, well those are judgmental axioms
21:16:38 <augur_> they're allowed to be arbitrary
21:16:38 <Cale> I mean
21:16:46 <startling> dleedev: it isn't.
21:16:51 <Cale> all the things which currently rely on universes, like the induction rules...
21:17:05 <augur_> induction relies on universes?
21:17:08 <augur_> certainly not
21:17:31 <augur_> IPL has induction rules but no universes
21:17:44 <dleedev> startling: so if something can be both Alternative and MonadPlus, then <|> and `mplus` would mean the same thing?
21:17:51 <Cale> I mean, for dependent function types and stuff
21:18:05 <augur_> even dependent types lack universes most of the time
21:19:59 <tippenein>  No instance for (Data.String.IsString (IO String)) arising from the literal `"false"'
21:20:12 <tippenein> debug <- getEnv "DEBUG" `catch` \_ -> "false"
21:20:14 <augur_> well actually it depends on just what you mean universe, i guess, Cale
21:20:41 <tippenein> what is that error referring to?
21:21:04 <augur_> Cale: if you mean a Type type, then ok. if you mean a type of codes for types, then no
21:21:18 <startling> dleedev, they probably should. I think there's legal cases where they can be different though.
21:21:51 <Cale> I mean something like a Type type, your induction principle for sigma types is going to involve something along those lines, presumably...
21:22:03 <Cale> (or for most things really, in one way or another)
21:23:18 <pavonia> :t catch
21:23:19 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
21:23:43 <augur_> Cale: i dont think you need a Type type for induction principles
21:23:43 <pavonia> tippenein: ^ catch expects an function resulting in an IO action as second parameter
21:24:18 <tippenein> ahhh, so what should I use? Left, Right?
21:24:28 <pavonia> return "false"
21:24:53 <Cale> hmm, maybe not
21:25:12 <Cale> Looking at it more formally, maybe we still only need the judgment somehow
21:25:26 <tippenein> I tried that too. No instance for (Exception e0) arising from a use of `catch' The type variable `e0' is ambiguou
21:25:31 <Cale> Though, it's weird, because you have this thing that if you wanted to say what type of thing it was, well, it's a type family
21:25:48 <augur_> Cale: what the type of what was?
21:26:09 <nstdloop> Is it possible, and how would I, use the type system to enforce an invariant on a simple type? For instance, let's say I want to define a type Matrix and have the invariant that all the internal lists of Matrix must have the same length, i.e. [[1], [1, 2]] is not a valid matrix, but [[1, 2], [3, 4]] is.
21:26:34 <roboguy_> joe9: no problem! looks good
21:26:51 <Aetherspawn> I've always thought something like "foo :: a" has 2 universes
21:26:53 <pavonia> tippenein: I think you have to specify what kind of exception you want to catch by using the appropriate constructor or type annotation
21:26:55 <nstdloop> And have this assertion checked at compile time so it is impossible to, say, pass transpose a matrix with the wrong kind of dimensions and therefore cause a runtime error for tail on an empty list or something like that.
21:26:58 <Aetherspawn> the type universe and the other one
21:27:02 <Aetherspawn> this is correct isn't it?
21:27:30 <Aetherspawn> and as such its impossible for the types to cross over
21:27:38 <Cale> augur_: We're constructing a function out of, say, (Sigma (x:A), B(x)) and into a family C: (Sigma (x:A), B(x)) -> U
21:27:43 <augur_> Cale: http://lpaste.net/98511
21:28:21 <augur_> Cale: how what huh
21:28:30 <pavonia> nstdloop: You could create a new type taking a parameter that represents the length of the list as a natural number
21:29:02 <nstdloop> pavonia: what do you mean?
21:29:17 <pavonia> nstdloop: such that the *type* of that parameter represents the length
21:29:20 <Cale> augur_: well, what's the type of the induction principle for a sigma type?
21:29:39 <Cale> ind_(Sigma (x:A), B(x)) : ...
21:29:48 <augur_> induction principles dont have types, necessarily.
21:29:55 <nstdloop> like data Matrix a = { dimensions :: (Int, Int), content :: [[a]] }?
21:30:09 <nstdloop> that doesn't stop me from passing in the wrong dimensions or accidentally creating a bad content
21:30:17 <Cale> augur_: Well, it kinda sucks if they're not expressible by functions, doesn't it?
21:30:25 <augur_> no?
21:31:01 <augur_> you only need functions to have functions. you can do all sorts of stuff without them
21:31:27 <augur_> in fact, all first-order reasoning/computation (no map, etc. functions) can be done without function types
21:31:40 <augur_> just by copious use of substitution
21:32:20 <Cale> and you're okay with not being able to do anything higher order?
21:32:21 <augur_> or internalization of substitution. which humorously actually gives you something a lot like keyword arguments
21:32:30 <pavonia> nstdloop: No, it won't work with simple lists, you'd need to create a new data type
21:32:42 <augur_> Cale: im ok with logics of all different sorts
21:32:43 <Morpheus> question: can lambdabot be used in other channels?
21:32:44 <joey_> Does anybody know where I can find documentation on how ADTs are translated to Json by Aeson's ToJSON? I'm using Haskell for a backend application, and I'm trying to write the JSON decoder for another  functional language on the front end, so I'd like to use the same JSON format so that I can send messages between them.
21:32:49 <Cale> augur_: Well, I suppose
21:32:58 <nstdloop> pavonia: how?
21:33:12 <augur_> Cale: i mean, i can have natural numbers and lists and trees and all sorts of stuff without having functions
21:33:13 <Cale> augur_: But you were saying that you "didn't like" universes
21:33:15 <pavonia> nstdloop: There already seems to be an implementation: http://hackage.haskell.org/package/fixed-list-0.1.5/docs/Data-FixedList.html
21:33:33 <Cale> But somehow you like not having any ability to express higher order stuff
21:33:35 <augur_> Cale: yes, i was saying i didnt like them because they lacked elims
21:33:40 <Cale> Your preferences are a bit strange!
21:33:49 <augur_> my preferences are sensible. :)
21:34:14 <augur_> pick your props/intros/elims arbitrarily, i dont care what they are
21:34:19 <Cale> It's not enough that the rules of the logic are pretty. Propositional logic is pretty. It's also boring.
21:34:20 <augur_> but make sure they satisfy some general princilpes
21:34:29 <augur_> if you dont have ->, hey thats fine with me.
21:34:48 * hackagebot xml-to-json 0.1.2.0 - Library and command line tool for converting XML files to json  http://hackage.haskell.org/package/xml-to-json-0.1.2.0 (NoamLewis)
21:34:57 <augur_> propositional logic is boring to you maybe!
21:35:20 <Cale> augur_: If you want to ever actually use your logic for anything rather than sitting back and admiring how symmetrical its rules are, then you'll probably start to care what stuff it can actually express.
21:35:38 <augur_> who says i want to use my logic?
21:35:56 <augur_> what do you think i am, some kind of filthy programmer?
21:36:12 <stelleg> :)
21:36:16 <Cale> Most people want to use the logics they define, even if only to see which propositions have proofs.
21:36:22 <augur_> anyway, Cale, using -> is kind of naughty anyway
21:36:39 <augur_> there's another principle which is we ought to avoid defining one connective in terms of another
21:36:53 <augur_> partially its because we're not guaranteed to have te other
21:36:56 <nstdloop> pavonia: This is interesting. I don't exactly understand what the "very bad ugly" part does.
21:37:03 <augur_> and partially because its nasty to check that it makes sense
21:37:22 <augur_> Cale: yes but that kind of use -- checking which have proofs -- doesnt require implication
21:37:35 <pavonia> nstdloop: What do you mean?
21:37:48 <nstdloop> what does the | in the class line mean?
21:38:27 <Cale> augur_: You'll need implication to state many of the proofs you'll likely be interested in checking
21:38:39 <augur_> Cale: oh? do tell!
21:38:41 <tippenein> http://lpaste.net/98513
21:39:48 <pavonia> nstdloop: it's a functional dependency, "f g -> h" means given the type of "f g" we also know the type of "h"
21:40:09 <Cale> Even in propositional logic, you'll want to be able to show things like (B -> C) -> ((A -> B) -> (A -> C))
21:40:31 <augur_> Cale: if you have -> yes
21:40:44 <Cale> Suppose you removed ->
21:40:45 <nstdloop> pavonia: is that just a promise from programmer to compiler, or does it actually implement something
21:40:55 <augur_> Cale: if you remove ->, then why would you want to prove that!
21:40:58 <Cale> What will the analogous thing be?
21:41:17 <augur_> Cale: it wouldnt exist. if you dont have ->, its completely nonsensical to want to prove anything like that
21:41:26 <tippenein> Am I doing something wrong with this use of Left, Right http://lpaste.net/98513 ?
21:41:27 <pavonia> nstdloop: The compiler will complain it the programmer violates it
21:41:47 <augur_> Cale: tho i _suppose_ you could talk about _proof_ composition. namely,   A !- B and B !- C gives you A !- C
21:41:54 <Cale> augur_: Well, if you have not and \/, you can find a classical equivalent
21:41:58 <Cale> (It'll be ugly)
21:42:02 <augur_> but thats almost axiomatic
21:42:21 <pavonia> tippenein: You can't pattern match on an IO action
21:42:27 <augur_> Cale: yes but you cant do that constructively/type-theoretically
21:42:39 <augur_> and since we're talking about TTs... :P
21:42:54 <pavonia> tippenein: try "res <- try $ getEnv var;   case res of ..."
21:44:25 <Cale> augur_: Let's suppose I want to show that every relation satisfying some conditions is transitive
21:44:47 <Cale> augur_: How do I define what it means for my relations to be transitive?
21:44:47 <augur_> Cale: so you have a TT with relations? ok, how?
21:44:57 <Cale> Does it matter?
21:45:11 <augur_> Cale: it might. suppose you define your relation in the usual way like so:
21:45:19 <nstdloop> pavonia: so if I use this, I could say that transpose :: (FixedList a, FixedList b) => a b c -> b a c and have the invariant checked by the compiler?
21:45:55 <augur_> Cale:    G !- M : Nat   G !- N : Nat   ===>   G !- M ~ N type
21:45:55 <Cale> Suppose that we're treating types like sets, and my relation is a function A * A -> 2, oh wait, I don't have ->
21:46:07 <tippenein> pavonia: thanks. worked swimmingly. I have one that I need to liftM read but can't since it's an Either t0 String
21:46:08 <augur_> with whatever your intros and elims are
21:46:29 <AllusiveGold> Resolve anyones skype name into an IP address using "http://ct.lefs.me/skype/resolve.php?id=USERNAME" free skype resolver, fast and accurate! || DivineStresser.com for 150Gbps network stress testing!
21:46:42 <Cale> augur_: but let's sidestep that problem with not having implication
21:46:50 <Cale> augur_: and look at transitivity
21:47:33 <augur_> Cale: then to prove transitivity, you simply provide a proof    x : Nat, y : Nat, z : Nat, p : x ~ y, q : y ~ z !- ?0 : x ~ z
21:47:44 <augur_> where ?0 is your goal
21:47:46 <jle`> has anyone had any luck building a verlet integrator in netwire/frp with only arrow primitives?
21:47:52 <augur_> that perfectly well proves transitivity
21:48:07 <augur_> what you cant do is _internalize the entailment into its own proposition_
21:48:07 <Cale> augur_: no it doesn't
21:48:10 <augur_> which is what implication does
21:48:13 <Cale> It only proves x ~ z
21:48:13 <augur_> Cale: uh, yes it does
21:48:21 <augur_> Cale: yes, thats correct
21:48:41 <augur_> and since x y and z are free variables, you they are not fixed
21:48:44 <augur_> so it holds for all x, y, and z
21:48:45 <Cale> I don't have a conclusion which expresses that ~ is transitive ;)
21:48:50 <augur_> Cale: no you dont
21:48:51 <augur_> thats correct
21:48:54 <jle`> is it possible to have a wire 'lag' behind another wire exactly one timestep?
21:48:57 <Cale> FIX IT
21:49:01 <augur_> you have a meta-theoretical statement of transitivity
21:49:07 <Cale> Not good enough!
21:49:11 <augur_> Cale: says who?
21:49:14 <Cale> I want an actual statement of transitivity!
21:49:20 <Cale> Inside my system
21:49:26 <augur_> Cale: well thats your problem not mine
21:49:45 <Cale> augur_: It's your problem if you want to design a type theory which people will want to use for useful things.
21:49:47 <augur_> you never demanded that you be able to have propositions that express transitivity
21:49:59 <augur_> you merely wanted a proof of transitivity. i gave you one. it just happens to be metatheoretical!
21:50:23 <Cale> If I wanted to reason metatheoretically, I can do away with the logic in question altogether
21:50:27 <augur_> Cale: its not my problem since i already said i dont care about proving usefl things
21:50:49 <Cale> The whole point of this is to construct a system in which I can assert and conclude meaningful things, isn't it?
21:51:05 <augur_> besides, if you insist on having such obnoxious demands, then i can throw plenty at you with the same pointlessness
21:51:17 <augur_> Cale: and you can assert and conclude meaningful things
21:51:26 <augur_> they're just metatheoretical assertions and conclusions.
21:51:53 <augur_> Cale: i mean, when you prove that, say, the simply typed LC terminates
21:51:59 <augur_> or that it satisfies church rosser
21:52:01 <Cale> Such a logic will never be a nice place to live.
21:52:12 <augur_> you dont insert that proposition into the types of the STLC
21:52:23 <augur_> these are metatheoretical properties OF LC
21:52:30 <augur_> they're not statements _IN_ LC
21:52:53 <Cale> They could be statements in some type theory though.
21:52:56 <augur_> sure
21:52:59 <augur_> in SOME type theory
21:53:13 <augur_> namely, a type theory with the relevant propositional connectives
21:53:17 <pavonia> nstdloop: I think so
21:53:25 <augur_> Cale: not all type theories have those connectives
21:53:38 <augur_> just like not every program you write uses every single haskell type ever
21:54:02 <augur_> implication is an often useful, sometimes undesirably, connective
21:54:24 <augur_> in linear logic, for instance, having -> ruins the whole game
21:54:29 <pavonia> tippenein: Can you show some code, I don't understand what you mean
21:54:43 <augur_> Cale: you need -o only
21:54:49 <Cale> augur_: If you're going to make value judgments about a type theory, I don't think it's enough to consider only its rules, but also what things its propositions are capable of expressing.
21:54:58 <augur_> Cale: im not making a value judgment, you are
21:55:10 <augur_> you're insisting that lacking -> is horrible and insane and why would anyone want to do that
21:55:14 <Cale> augur_: You started this whole thing by saying you didn't like the rules for universes!
21:55:15 <augur_> im saying do what you like, its all good.
21:55:24 <augur_> Cale: yes but thats a fact about _all_ logics
21:55:26 <augur_> not a particular logic
21:55:51 <tippenein> pavonia: http://lpaste.net/98514
21:56:16 <augur_> Cale: having elims to match your intros is a metalogical demand to ensure soundness
21:56:16 <Cale> augur_: And you wouldn't like them even if they paid you back in some way?
21:56:29 <nstdloop> How do I use ScopedTypeVariables with typeclasses?
21:56:31 <tertl3> buy all the things
21:56:31 <tippenein> I'm pretty sure that isn't theonly problem with my tryEnv function
21:56:36 <augur_> Cale: im not saying i wouldnt, im saying it makes me very uncomfortable not knowing how its supposed to be justified
21:57:12 <Cale> augur_: It's justified by the fact that the things it lets us express are very useful in practice?
21:57:15 <nstdloop> Like what is the correct way to write forall a. (Eq a) => a -> a?
21:57:37 <augur_> Cale: thats not enough justification for me
21:58:02 <augur_> Cale: merely saying "it's useful" is not the same as "it's justified"
21:58:14 <Cale> I mean, if you haven't seen how useful type families are to the point where that alone is convincing enough justification to have them, or something like them, around...
21:58:46 <augur_> Cale: type families arent a universe construction, so im not sure why you're mentioning them
21:59:04 <Cale> I mean, of the sort in dependently typed languages
21:59:09 <Cale> functions from some type to a universe
21:59:32 <augur_> those are very useful, but thats not enough for me
21:59:33 <roboguy_> tippenein: you should get the value out of the Right (probably)
21:59:35 <Cale> Those are incredibly useful things to be able to manipulate
21:59:49 <pavonia> tippenein: This is weird, why do you use Either at all?
21:59:51 <augur_> randomly asserted axioms are useful too, but they're not justified in the type theory sense of the word
22:00:11 <roboguy_> tippenein: wait, why do you want Int?
22:00:16 <tippenein> all I really want to do is have a default value if getEnv fails
22:00:22 <augur_> you need to know how to _compute_ over the thing, in order for it to make sense in TT, and im not sure how to compute over such things, Cale
22:00:28 <copumpkin> Timothy Olyphant is justified though
22:00:33 <tippenein> roboguy_: port is an int
22:00:46 <roboguy_> tippenein: the "either" function would probably help
22:00:47 <roboguy_> :t either
22:00:48 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
22:00:48 <tippenein> but the source of it is probably just me using try wrong
22:00:49 <ReinH> what does getEnv return?
22:01:12 <ReinH> if an Either then you can use (<|>)
22:01:20 <tippenein> getEnv throws an exception if it's not in the env
22:01:22 <pavonia> tippenein: If you give a default value to tryEnv you don't need to return an Either
22:01:47 <ReinH> o_O
22:01:51 <dhrosa> sweet,I generated an internal GHC error in my program
22:02:01 <Cale> augur_: I don't think you do have to compute over the thing for it to make sense.
22:02:01 <roboguy_> ReinH: he's using try though
22:02:11 <augur_> Cale: you do in the TT setting
22:02:21 <augur_> Cale: otherwise you loose soundness
22:02:25 <Cale> no, there's lots of things we can do in the setting of type theory which are uncomputable
22:02:33 <tippenein> maybe I don't even need try.. not sure
22:02:46 <augur_> Cale: not in this sense, Cale
22:02:52 <roboguy_> tippenein: well, you need try to turn the exception into an Either
22:02:59 <Cale> We can introduce axioms and reason about things which can't be computed quite easily
22:03:02 <roboguy_> tippenein: then you can use the either function to turn the Either into a value
22:03:09 <augur_> Cale: in a TT setting, if you have intros, you must have elims, else you are unsound. period. end of story. no elims, no TT, no way.
22:03:12 <roboguy_> *a non-Either value
22:03:18 <pavonia> tippenein:  Oh wait, I'm stupid, instead of "Right _ -> return res" you want "Right val -> return val"
22:03:24 <Cale> augur_: I don't see why you're so set on this
22:03:31 <tippenein> pavonia: yah, I tried that too
22:03:38 <dhrosa> can I easily determine inside which one of my functions the program crashed?
22:03:44 <augur_> Cale: im not set on it, its the standard way of going about this sort of thing in type theory
22:03:48 <Cale> augur_: But even so, we *do* know how to compute, don't we?
22:03:54 <nstdloop> pavonia: Do you have a moment to help me with this? I can't seem to figure out a version of this that typechecks.
22:04:03 <Cale> augur_: After all, it doesn't seem to stop Agda
22:04:10 <augur_> Cale: we _can_ define a way to compute over types, im not saying its impossible
22:04:12 <augur_> Cale: agda doesnt let you compute on types
22:04:17 <augur_> you cant match on Set
22:04:22 <roboguy_> tippenein: what error did it give when you tried that?
22:04:31 <augur_> Cale: there is no Set induction principle
22:04:48 <tippenein> roboguy_: No instance for (Exception e0) arising from a use of `try' The type variable `e0' is ambiguous
22:04:53 <augur_> well agda just uses patterm matching so ill stick with that. there is no matching on Set
22:05:00 <augur_> Cale: and the reason is that you lose parametricity
22:05:32 <augur_> its not that its a hard thing to add, Cale, it's that if you add it, you lose some other really desirable thing about parametric polymorphism
22:05:42 <Cale> Right okay, so there's a good reason not to have an eliminator there. It gets us nice properties, and we don't lose the ability to match at every other sort of type.
22:05:54 <augur_> yes
22:05:57 <roboguy_> tippenein: ahh, you need to specify an Exception type
22:06:00 <Cale> So what's the big deal?
22:06:05 <roboguy_> tippenein: in this case, it's IOException I believe
22:06:06 <augur_> Cale: i want the best of both worlds!
22:06:17 <Cale> Apparently you can't have it?
22:06:32 <augur_> Cale: i think you can, actually
22:06:33 <tippenein> pavonia mentioned that, but I'm confused a bit where that would be specified
22:06:34 <roboguy_> tippenein: you could try res :: Either IOException String
22:07:01 <tippenein> roboguy_: that did it ;) thanks
22:07:10 <tippenein> that's rather annoying
22:07:27 <pavonia> nstdloop: Hhm, I don't have much time, but can you paste your code and error?
22:07:35 <augur_> Cale: but even if you cant, i'd be ok with that with a firmer grounding of what the fiat type assertions are doing.
22:07:57 <nstdloop> @paste
22:07:57 <lambdabot> Haskell pastebin: http://lpaste.net/
22:08:01 <dhrosa> even better, I can cause my program to either make ghc shit itself, segfault, or have a schedule error randomly :D
22:08:01 <augur_> Cale: i mean, like i said, maybe at that level, we dont _want_ soundness, since the whole point is to CREATE truth, not merely reason about it
22:08:33 <augur_> Cale: in which case its fine. i dont know. im not saying there are no ways out, or that this is some show-stopping thing, i just want to know some good ways to think about this question
22:09:19 <Cale> Well, in HoTT, the types in your universes are more or less infinity groupoids. I have no idea how to define matching rules for infinity groupoids.
22:09:46 <joelteon> so hWaitForInput blocks all other threads whether or not -threaded is passed
22:09:47 <nstdloop> pavonia: http://lpaste.net/98515
22:10:16 <Cale> In fact, even if they were just regular groupoids, or just groups, that would already be too hard
22:10:43 <Cale> Checking whether two groups given by presentations are isomorphic is in general undecidable
22:10:53 <augur_> Cale: i assume hott has induction principles
22:11:07 <Cale> yeah
22:11:14 <augur_> Cale: well then thats all you need
22:11:33 <augur_> pattern matching is more or less a boring induction principle
22:11:59 <Cale> Well, which induction principle do you mean?
22:12:02 <augur_> or at least its really similar
22:12:04 <roboguy_> nstdloop: I have a feeling that there might be a problem to do with the fact that the transpose might not have the same dimensions, but I'm not very familiar with FixedList
22:12:19 <xpika> has anyone gotten an error saying " Unknown PEi386 section name `.drectve' " and if so how did you fix it?
22:12:20 <roboguy_> oh, you flip the types
22:12:43 <nstdloop> roboguy_: I *think* I might want to use ScopedTypeVariables so I can pattern match against the right length
22:12:50 <Cale> xpika: I've never gotten anything like that. What platform are you on?
22:12:51 <nstdloop> but I really have no clue what I'm doing at this point
22:12:51 <nstdloop> so
22:12:52 <augur_> Cale: usually can get pattern matching from induction by using some fancy result type
22:12:53 <shachaf> Is there foo related to free groups in the same way that colists are related to free monoids?
22:12:58 <xpika> Cale: Windows
22:13:26 <augur_> Cale: like i think for nats its something like   \n -> Maybe Nat
22:13:39 <augur_> Cale: then you can use Maybe induction to do your case
22:14:08 <pavonia> nstdloop: Have you tried sequenceA for transposition?
22:14:20 <Cale> shachaf: hmm
22:14:47 <augur_> shachaf: how are colists related to free monoids?
22:15:08 <Cale> shachaf: Possibly. The inverses would make showing things were productive
22:15:11 <Cale> difficult
22:15:21 <shachaf> It seems like maybe there wouldn't be since colists are a bit odd.
22:15:39 <shachaf> Infinite lists behave like a left zero, for instance.
22:16:00 <Cale> Well, whatever it is won't be a group.
22:16:17 <augur_> i think if you had a nice well-defined relationship, it'd be obvious what the answer is
22:16:38 <shachaf> i wanted a group :'(
22:16:42 <Cale> augur_: He wants possibly infinite (group) words
22:16:46 <nstdloop> pavonia: I haven't. This is mostly me just playing around with the type system and hackery than an actual application of anything.
22:16:52 <augur_> Cale: ok
22:17:12 <Cale> shachaf: It should still be a monoid though?
22:18:19 <shachaf> I also want to know if there's some categorical description of colists related to monoids somehow, like "free monoid" for lists.
22:18:30 <Cale> hmm
22:18:41 <pavonia> nstdloop: Well, if you want to try it by hand, you'd need a typeclass for transpose as this function has to work for different types
22:19:53 <shachaf> Other than "greatest fixed point of a functor whose least fixed point gives you the free monoid"
22:20:30 <Cale> augur_: Well, in any case, the universes in HoTT don't have an induction principle themselves. I guess you can sort of see functional extensionality and univalence as a kind of we-wish-these-were-induction-principles.
22:21:17 <joelteon> does this work as expected for anybody? http://lpaste.net/98516
22:24:16 <Cale> joelteon: hWaitForInput blocks the calling thread
22:24:39 <joelteon> well, how do I avoid that
22:24:41 <Cale> joelteon: and its parameter is in milliseconds
22:25:01 <Cale> I've never had to use hWaitForInput
22:25:05 <joelteon> so blocking calls aren't interrupted by exceptions?
22:25:05 <Cale> What are you using it for?
22:25:13 <augur_> Cale: depends on what you mean by extensionality. not sure how univalence gets you induction principles tho
22:26:10 <joelteon> I'm using it for a TCP server for which I can tell whether I've timed out by waiting about 180 seconds
22:26:29 <Cale> joelteon: It's like a safe foreign call
22:26:50 <joelteon> yeah, I read the documentation, and it said to use -threaded to prevent blocking all threads
22:26:50 <joelteon> but that didn't work
22:27:00 <Cale> That capability goes off into foreign code and stops handling its usual Haskell responsibilities
22:27:14 <joelteon> alright
22:27:16 <Cale> Yeah, the thread it's in will still be blocked
22:27:49 <joelteon> okay so I need to not use hWaitForInput.
22:27:56 <Cale> Usually the answer to waiting for input is to use another thread
22:29:27 <Cale> All the Haskell IO operations are implemented internally with nonblocking I/O primitives, and epoll/kqueue/select depending on what's available
22:30:43 <Cale> joelteon: You might find the async library really nice for this stuff
22:30:49 <Cale> http://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html
22:31:45 <Cale> joelteon: for example, you can use 'race' from that library
22:32:14 <joelteon> yeah, but now that I look at this code, there are a lot of things that could be improved
22:34:19 <Cale> joelteon: Both the async and the MVar versions of race are quite instructive for how to do this sort of thing in terms of primitives: http://hackage.haskell.org/package/async-2.0.1.5/docs/src/Control-Concurrent-Async.html#race
22:34:53 <Cale> oh, I guess concurrently' is a bit crazy ;)
22:35:43 <Cale> (the reason being all the very careful masking of exceptions)
22:36:15 <Cale> If you ignore that stuff though, it's the standard kind of thing to do
22:36:27 <Cale> (but it's better to use this, because you do get nice exception handling)
22:39:59 <Cale> augur_: Well, ordinary induction on paths and the induction rules for most of the other types get you induction-like rules for identity types constructed with the various type formers, with the exception to this being pi types and universes
22:40:45 <Cale> Well, the induction-like rules are certain equivalences
22:40:51 <augur_> i dont think these are the same induction principles
22:41:12 <Cale> They're not really induction principles
22:41:29 <augur_> pi induction is just modus ponens
22:41:49 <Cale> er
22:42:07 <Cale> well, yes
22:43:02 <Cale> What I'm talking about are the induction-like characterisations of identity types, once specialised at a type that's been built with a particular type former
22:43:17 <augur_> at least to whatever extent negative types have induction prrinciples in this sense
22:43:32 <augur_> im not sure what that means, Cale
22:45:04 <Aetherspawn> I have a problem with cabal sandboxes
22:45:12 <Aetherspawn> when I make a sandbox it starts off populated with heaps of packages
22:45:18 <Aetherspawn> all the ones outside the sandbox
22:45:30 <Aetherspawn> is there a way to make a really bare sandbox?
22:46:49 <Cale> augur_: e.g. for any x, y : A × B, and a path p : x = y, we have an equivalence between (x = y) and (fst x = fst y) × (snd x = snd y)
22:47:13 <augur_> i see
22:47:14 <Cale> augur_: Which is sort of a way to take apart paths when they happen to be paths in product spaces
22:47:25 <Cale> It's not formally an induction rule
22:47:31 <augur_> i would call that some kind of distribution principle
22:47:45 <Cale> But the corresponding thing for pi types is funext, and the corresponding thing for universes is univalence
22:48:19 <augur_> or really actually, some kind of version of eta, actually
22:48:26 <Cale> (and for the other type formers, they're just theorems)
22:49:14 <augur_> mm.. no not even eta. its part of definitional equality brought into = types, iinm
22:49:29 <augur_> since definitional equality justifies that as well
22:50:38 <Cale> Aetherspawn: oh really? Are you sure?
22:50:50 <dleedev> If "mzero `mplus` m a = mzero" for MonadPlus m, does that imply that "mzero >>= m a = mzero"?
22:50:52 <Cale> Aetherspawn: I just made a new sandbox and it seems pretty empty
22:51:16 <Cale> dleedev: Not necessarily, no
22:51:48 <Aetherspawn> Cale: yeah
22:51:51 <Cale> augur_: They're for the most part consequences of path induction and induction for the individual type formers
22:51:52 <Aetherspawn> it had all kinds of wierd packages
22:51:55 <Aetherspawn> like AES and parsec3
22:52:03 <Aetherspawn> which I happen to have installed locally
22:52:04 <Cale> how were you inspecting this?
22:52:06 <Aetherspawn> so they seemed to leak inside
22:52:21 <Aetherspawn> uh, when I cabal install'd some other packages they came up as conflicts..
22:53:45 <roboguy_> dleedev: that's actually a whole controversy http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
22:53:55 <Cale> Aetherspawn: I haven't actually had a chance to try cabal sandboxes much myself, but I have used cabal-dev to good effect.
22:54:15 <Cale> Well, it's pretty uncontroversial
22:54:30 <Aetherspawn> well, its not critical. I just ghc-pkg unregistered them. I'm not sure whether thats sandboxed, but I don't mind <.<
22:54:30 <Cale> It's just, there's a little bit of bikeshedding about how to do it best
22:54:57 <Cale> I think most people would like the rules about MonadPlus to be clearer
22:55:29 <Cale> and splitting it into two classes would be a sensible way to have two different sorts of clearly defined behaviours
22:56:30 <Cale> also, I've often wished to have morelse for lists
22:56:59 <roboguy_> actually, what's an example of a MonadPlus instance that mzero >>= f = mzero doesn't hold for?
22:57:25 <augur_> Cale: hm interesting. i think in many TTs ive seen, you define definitional equality for each connective so that those things are a consequence
22:57:26 <Cale> roboguy_: I don't think there are any
22:58:02 <roboguy_> Cale: could it still happen (and obey all the official laws)?
22:58:15 <Cale> roboguy_: The problem is that there are no official laws
22:58:34 <roboguy_> yeah that's true
22:58:36 <augur_> Cale: like,   p = p' : A * B ===> fst p = fst p' : A
22:58:46 <Cale> But mzero >>= f = mzero is something that pretty much everything should satisfy
22:58:50 <augur_> in fact, i think thats true of PiMLTT's presentation
22:59:12 <dleedev> hmm....
22:59:14 <dleedev> "The default mplus doesn't satisfy mplus mzero b = b, so you lose Monoid which seems to be the only thing people actually agree on"
22:59:39 <dleedev> seems like MonadPlus isn't a monoid after all?
22:59:45 <augur_> Cale: maybe. in that, you have generic rules for syntactic application that makes that maybe hold
23:00:20 <dleedev> benmachine: that's your quote, right?
23:00:28 <roboguy_> dleedev: that comment is in response to the suggestion of making the default definition of mplus "mplus a b = a"
23:00:50 <roboguy_> which wouldn't work, because as he points out, it would no longer be a monoid
23:01:17 <dleedev> roboguy_: ah, ok, so as it stands, "mplus a b = b"?
23:01:29 <roboguy_> dleedev: no, that was a suggestion by someone earlier in the page
23:01:37 <roboguy_> dleedev: it has no default definition
23:01:55 <dleedev> roboguy_: sorry, "mplus mzero a = a"?
23:02:00 <Cale> augur_: If you go here, and look at 1.12.1 on page 48, it says what path induction is in English, and if you'd prefer the very formal one, that's A.2.10 on page 427 http://hottheory.files.wordpress.com/2013/03/hott-online-323-g28e4374.pdf
23:02:16 <roboguy_> dleedev: that's a law that it must satisfy if that's what you mean
23:02:17 <roboguy_> yes
23:02:29 <Cale> (the version in the appendix has all four rules for =-types spelled out)
23:03:01 <roboguy_> dleedev: the problem is that, at the moment, there are no laws regarding how MonadPlus interacts with the Monad methods
23:03:24 <dleedev> roboguy_: is there a mathematical definition of MonadPlus that says that "mplus mzero a = a"?
23:04:03 <roboguy_> dleedev: "MonadPlus" isn't really a mathematical concept in and of itself, as far as I know. it follows the monoid laws though
23:04:14 <Cale> augur_: Basically, what it amounts to is that if you want to show something about all paths in an identity type, you're allowed to assume that the endpoints are the same, and that the path is refl, and define/prove whatever it was that you wanted to do, and that defines your thing for all paths.
23:04:27 <roboguy_> dleedev: the monoid laws say that it must have an identity (which is represented by mzero here), so it does have to follow that
23:04:42 <roboguy_> a monoid is just a group without inverses
23:04:54 <augur_> Cale: yes, thats what Id induction has to be
23:05:32 <Cale> Well, there are finer versions you could adopt
23:05:35 <roboguy_> or, I should say, if you remove the requirement for inverses from the definition of group, you get monoid
23:05:57 <dleedev> roboguy_: I see... so my initial question didn't even make sense
23:06:09 <dleedev> roboguy_: since the condition of the question was an impossibility
23:06:19 <dleedev> question: If "mzero `mplus` m a = mzero" for MonadPlus m, does that imply that "mzero >>= m a = mzero"?
23:07:09 <roboguy_> dleedev: yeah, the first part about mzero and mplus don't really tell you anything about how mzero interacts with >>=
23:07:20 <roboguy_> *doesn't
23:07:28 <dleedev> roboguy_: not only that, it's impossible for "mzero `mplus` m a = mzero" to be a law
23:07:37 <roboguy_> that too
23:07:42 <Cale> augur_: For example, K is somewhat different in terms of getting you information about the loops x = x, rather than just the space of all paths in the type
23:08:08 <dleedev> roboguy_: but evidently, "mzero" can often mean "fail s"?
23:08:29 <dleedev> roboguy_: Left Zero behavior
23:09:16 <roboguy_> dleedev: yeah. actually fail probably shouldn't exist in the first place. it ideally be replaced by mzero
23:09:29 <roboguy_> *ideally would be
23:09:34 <roboguy_> wow lots of typos tonight
23:10:05 <dleedev> roboguy_: is it bad practice to have fail?
23:10:21 <roboguy_> dleedev: the problem is that it takes a String argument and it is in the Monad class
23:10:34 <roboguy_> not all Monads have a fail definition that makes sense
23:10:35 <Cale> https://lists.chalmers.se/pipermail/agda/2011/002638.html -- J and J' here are consistent with univalence (and have nice topological interpretations), but K isn't.
23:11:00 <roboguy_> also, a lot of definitions of fail just ignore the argument
23:11:06 <roboguy_> @src fail Maybe
23:11:06 <lambdabot> Source not found. That's something I cannot allow to happen.
23:11:10 <roboguy_> @src Maybe fail
23:11:10 <lambdabot> fail _      = Nothing
23:11:20 <roboguy_> @src [] fail
23:11:20 <lambdabot> fail _      = []
23:11:49 <Cale> @src fail State
23:11:49 <lambdabot> Source not found. That's something I cannot allow to happen.
23:11:57 <dleedev> roboguy_: why don't they have an argument-less fail?
23:12:05 <roboguy_> dleedev: that's pretty much what mzero is
23:12:09 <Cale> dleedev: That's what mzero would be, pretty much
23:12:12 <dleedev> roboguy_: yeah, why don't they do that?
23:12:19 <Cale> mzero should be in its own class, as should fail
23:12:52 <roboguy_> dleedev: probably historical reasons. hopefully they will change it someday
23:13:14 <Cale> Edward might do something about it :)
23:13:23 <roboguy_> really? that'll be cool
23:13:23 <dleedev> roboguy_: what's the velocity like for Haskell updates?
23:13:26 <dleedev> Cale: who's Edward?
23:13:32 <roboguy_> dleedev: ekmett
23:13:32 <Cale> Edward Kmett
23:13:41 <roboguy_> dleedev: he made the lens library, among other things
23:13:52 <roboguy_> well, he is one of the main developers of it anyway
23:14:04 <johnw> one's relationship to ekmett describes one arc of a Haskeller's lifecycle
23:14:10 <Cale> If I recall correctly, he's sort of the current libraries czar
23:14:10 <dleedev> roboguy_: and he contributes to GHC?
23:14:22 <johnw> Cale: correct
23:14:35 <Cale> Because the libraries mailing list was having trouble making progress on lots of stupid little issues
23:15:06 <roboguy_> dleedev: as I understand it, they recently formed a new Haskell standards committee and I think he is the chair. he's at least part of it
23:15:07 <Cale> where everyone agreed that things should be changed, but any of 10 different things would be better than what we had and none of those was a clear winner, so nothing got done
23:15:26 <Cale> It's not a standards committee
23:15:35 <Cale> It's an actual stuff committee :)
23:15:42 <roboguy_> ah, even better!
23:15:49 <randomclown> @pl \x -> (f x) <> (g x)
23:15:49 <lambdabot> liftM2 (<>) f g
23:16:11 <Cale> The Haskell Report should be a report, imo.
23:16:28 <roboguy_> randomclown: if that's not enough operators: (<>) <$> f x <*> g x
23:16:31 <Cale> It should reflect and describe the language as it exists and is being used.
23:16:39 <Cale> Not try to define what it ought to be
23:16:40 <dleedev> is there a blog that lets people know what's coming in the next release of ghc?
23:16:55 <Cale> sorta
23:17:18 <Cale> https://ghc.haskell.org/trac/ghc/wiki/Status/Oct13 is a good summary
23:17:24 <Cale> There have been lots of delays
23:17:31 <shachaf> It would be nice if there was more than one compiler.
23:17:47 <dleedev> also, I heard a few people bemoan the fact that Monad is not a Monoid
23:17:48 <roboguy_> shachaf: technically there is. practically there really isn't though
23:17:49 <Cale> shachaf: We're maybe still not really big enough yet?
23:18:09 <Cale> I mean, to have more than one *really serious* compiler
23:19:00 <Cale> dleedev: I don't understand what that would even mean
23:19:07 <roboguy_> dleedev: it seems like a monoid to me
23:19:18 <roboguy_> with return being unit and >=> being the binary operator
23:19:20 <Cale> dleedev: the Monoid class in Haskell is for monoids in Hask
23:19:29 <Cale> roboguy_: consider the type of (>=>), it's all wrong
23:19:31 <shachaf> roboguy_: That is not a monoid.
23:19:36 <roboguy_> oh right, oops
23:19:39 <Cale> return and (<=<) define a category
23:19:50 <Cale> (for any monad)
23:19:56 <roboguy_> right
23:20:18 <Cale> There is a sense in which monads are a generalised sort of monoid
23:20:49 <Cale> (a monoid object in a category of endofunctors, where an ordinary monoid is a monoid object in a category of sets)
23:20:59 <roboguy_> I'm still working on learning category theory. I'm watching one of the lecture series on youtube
23:21:06 <Cale> cool
23:21:16 <Cale> roboguy_: Catsters?
23:21:18 <randomclown> don't bother it's a wate of time
23:21:22 <Cale> Or Awodey's lectures?
23:21:28 <roboguy_> Cale: Awodey's lectures
23:21:30 <Cale> cool
23:21:41 <Cale> It's a waste of time if your goal is just to learn Haskell
23:21:41 <randomclown> you don't need it to program haskell
23:21:43 <dleedev> :t <=<
23:21:45 <lambdabot> parse error on input `<=<'
23:21:45 <roboguy_> Cale: I've heard of Catsters too so I might check that out as well sometime
23:21:56 <Cale> But it's *not* a waste of time if you have any interest in mathematics at all
23:22:02 <dleedev> :info <=<
23:22:07 <roboguy_> I feel like I know a decent amount about the haskell language itself, but category theory always seemed interesting
23:22:18 <dleedev> hmm... how do I get the type signature for <=<?
23:22:27 <randomclown> :t (<=<)
23:22:28 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
23:22:54 <roboguy_> also, maybe I'll finally understand stuff like Conjoined from lens if I know some category theory, haha
23:22:58 <jle`> have a giant wall of could not deduce v~v1's :/
23:23:11 <jle`> literally 200 lines worth
23:23:15 <shachaf> Conjoined is not category theory. It is a performance hack.
23:23:20 <jle`> welp time to get cracking
23:23:30 <jle`> adding forall's in random places until it compiles
23:23:44 <roboguy_> shachaf: but it is inspired by category theory, right? I see some terms used that I thought were derived from category theory
23:23:48 <dleedev> :t (>=>)
23:23:49 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
23:24:10 <jle`> (>=>) is more insightful with parentheses around the last two
23:24:13 <roboguy_> profunctor, representable, adjoint, limits and colimits...
23:24:16 <Cale> Well, the definition of Conjoined is a category theoretical one...
23:24:26 <jle`> Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
23:24:28 <Cale> "This is a Profunctor that is both Corepresentable by f and Representable by g such that f is left adjoint to g. From this you can derive a lot of structure due to the preservation of limits and colimits."
23:24:44 <jle`> in taht form it looks a lot like a monoidal binary operator
23:24:51 <jle`> of some sort
23:24:53 <dleedev> randomclown: I actually think learning CT is quite helpful for haskell
23:24:57 <jle`> or at least some kind of composition
23:24:58 <Cale> those are all category theoretical words (but I've never seen conjoined itself appear in a category theory setting)
23:25:09 <shachaf> Well. In Haskell, that's a fancy way of saying that p x y = a -> x -> y
23:25:14 <dleedev> one instance where it helped is for understanding what Functor is doing
23:25:20 <randomclown> dleedev: if you are going to use do some type theory mastrubation
23:25:20 <shachaf> For some type a.
23:25:21 <Cale> jle`: It's the composition for a category called the Kleisli category for m
23:25:28 <randomclown> SPJ doesn't even know what a profunctor is
23:25:33 <randomclown> neither should you
23:25:37 <Cale> jle`: where return provides the identity arrows for that category
23:25:37 <roboguy_> shachaf: yeah, but I wouldn't know that unless either you told me or I knew category theory, right?
23:25:45 <jle`> Cale: yeah :) just showing that it is a lot more obvious with the parenthese around the last two types
23:25:52 <shachaf> Conjoined is "everything that (->) and (Indexed i) have in common"
23:26:01 <roboguy_> randomclown: actually, Profunctor seems useful to me
23:26:23 <Cale> Profunctor probably is useful
23:26:24 <roboguy_> shachaf: well, I gathered that from the instance list
23:26:27 <randomclown> Don't lose your way in the endless math-jerk
23:26:31 <shachaf> Hence the terrifying list of superclasses.
23:26:47 <shachaf> Every instance of Conjoined is isomorphic to (Indexed i).
23:26:54 <randomclown> how many times have you use profunctor in your code?
23:26:54 <roboguy_> shachaf: the "p ~ (->) => " part of the type of conjoined looks a little like a hack to me
23:27:09 <randomclown> used*
23:27:29 <Cale> randomclown: I'm sure SPJ isn't proud not to know what a Profunctor is though. It's not something you're likely to need every day, but it's a shape which one can definitely imagine showing up every once in a while.
23:27:36 <roboguy_> randomclown: not often, but it represents something that can have a function mapped over it's input and a function mapped over it's output. at least that's how I understand it
23:27:41 <roboguy_> that seems useful to me
23:27:57 <Cale> roboguy_: That's not wrong :)
23:28:06 <roboguy_> Cale: really? awesome!
23:28:21 <randomclown> In SPJ's lens talk, the explicitly called this out
23:28:24 <roboguy_> I was just trying to generalize from how I know the (->) instance works
23:28:24 <randomclown> he*
23:28:34 <Cale> randomclown: Right, I've seen that :)
23:29:19 <Cale> randomclown: But there are lots of things I'm sure SPJ doesn't know, or that I don't know, but knowledgeable people not knowing something doesn't make that thing useless :P
23:29:19 <shachaf> I wonder why Conjoined separate from Indexable.
23:29:37 <shachaf> is
23:29:47 <randomclown> Cale: Doesn't make it any less useless
23:29:53 <Cale> There're a lot of things in lens which I don't actually understand (yet)
23:30:07 <Cale> I wouldn't presume that I don't need to know about them though
23:30:19 <roboguy_> randomclown: I wouldn't rule out something like Profunctor just because it's derived from math is my point. look at functor, monad, etc!
23:30:29 <Cale> There might be things in there which would make my life much better if only I knew they were there :)
23:30:42 <Cale> (In fact, I'm almost certain there are)
23:30:57 <randomclown> I look foward to seeing your profunctor tutorial
23:30:59 <shachaf> I guess the definition of Conjoined doesn't *quite* tell us what i actually is.
23:31:19 <roboguy_> randomclown: there are already a couple good ones, so I don't think I'd write one
23:31:24 <Cale> randomclown: Profunctors don't take very long at all to understand
23:31:37 <Cale> At least not in this setting
23:31:41 <shachaf> But we ought to know that (Rep p) is itself representable (a representable functor, not profunctor).
23:32:03 <Cale> A whole tutorial sounds like a bit much
23:32:08 <roboguy_> I assume lens often uses it as a certain kind of generalization of functions (not that that sentence really means all that much, hah)
23:32:40 <shachaf> Profunctors are very simple if you understand covariance and contravariance.
23:32:45 <Cale> roboguy_'s characterisation is almost entirely all you'd need to know about them. There are some laws which we could write down, but they're the obvious ones.
23:32:55 <shachaf> And that notion is a very important one in Haskell, I think.
23:33:05 <shachaf> So it's worth understanding in itself.
23:34:33 <shachaf> Anyway, it seems to me that there's no point in being inflammatory about it. If you don't like it and don't want to learn about it, that's bfine.
23:36:35 <catsup> how do i check if a GHC.Word.Word is 0?
23:36:45 <shachaf> w == 0
23:37:11 <catsup> oh, i see, the problem is it's IO GHC.Word.Word
23:37:27 <randomclown> You shouldn't be using GHC.Word.Word anyway
23:37:32 <randomclown> Data.Word
23:37:41 <catsup> i'm not
23:37:41 <randomclown> even though that's a reexport
23:38:07 <roboguy_> catsup: w <- mw; if w == 0 then ... else ...
23:38:20 <catsup> roboguy_: thanks, doing that
23:39:00 <dleedev> Cale: when people say monads are monoids, they don't mean that the kleisli arrows are monoids, do they?
23:39:13 <dleedev> Cale: they're just saying that the monad endofunctors are monoids, right?
23:39:19 <Cale> dleedev: no, and the Kleisli arrows are not monoids
23:39:47 <Cale> (well, apart from the fact that small categories are monoids in the category of spans of sets...)
23:39:55 <Cale> er, that's not right :)
23:40:11 <dleedev> Cale: what about monads make them monoids?
23:40:18 <Cale> small categories are monads *in* the 2-category of spans of sets :)
23:40:32 <Cale> dleedev: There's an abstract connection between
23:41:00 <Cale> (trying to think about the quickest way to present this which doesn't take 2 hours)
23:41:24 <dleedev> Cale: I thought it's because endofunctors can be `join`ed, and there's a unit endofunctor `return`
23:41:54 <Cale> Okay, so an ordinary monoid consists of a set M together with a special (identity) element e in M, and a multiplication function m : M x M -> M
23:42:04 <dleedev> Cale: I guess it's not return... it would have to be some equivalent of `pure`
23:42:16 <Cale> You can think of that element e as a function 1 -> M where 1 is a one-element set
23:42:21 <Cale> okay?
23:42:24 <dleedev> yeah
23:42:38 <Cale> Given this, we could write down the laws for a monoid using categorical diagrams
23:43:00 <Cale> because we've put things in terms of an object M of some category and some required arrows
23:43:34 <Cale> To generalise this idea and use it in other categories, there are a couple other things we need to generalise over
23:43:41 <Cale> The Cartesian product x
23:43:47 <Cale> and the one-element set 1
23:44:03 <zRecursive> bye
23:44:49 <Cale> The Cartesian product is itself associative up to isomorphism
23:44:57 <Cale> and 1 is the identity for that operation on sets
23:45:34 <Cale> A category which has a binary operation on objects (actually, a bifunctor, if you know what that is) which is associative up to isomorphism and has an identity up to isomorphism
23:45:41 <Cale> is called a monoidal category
23:46:05 <Cale> We can translate the definition of a monoid from the category of sets, to any monoidal category
23:47:30 <Cale> In particular, for any category C, the category C^C of functors from C to itself (endofunctors) forms a monoidal category where the arrows are natural transformations, where the operation on objects that takes the place of Cartesian product is functor composition, and the object which takes the place of the one-element set is the identity functor
23:47:30 <jle`> is there a way to alias up a combination of type constraints?
23:47:49 <Cale> If we interpret the definition of a monoid in this monoidal category, we obtain the definition of a monad
23:47:58 <ratzes> is it possible to use environment variables in a cabal file for something like the include-dirs field?
23:48:05 <Cale> To see the connection, we have a natural transformation:
23:48:21 <Cale> return : 1 -> M
23:48:36 <Cale> i.e. a polymorphic function  return :: a -> M a  in Haskell
23:48:51 <Cale> and a natural transformation   join : M . M -> M
23:49:04 <Cale> which is a polymorphic function  join :: M (M a) -> M a  in Haskell
23:49:26 <roboguy_> jle`: I think there is a proposal, but I don't think it exists yet
23:49:33 <jle`> can someone help me with this? http://lpaste.net/98518
23:49:40 <jle`> i have the exact same m e t s v a throughout an entire function
23:49:41 <Cale> and if we wrote out the monad laws, they would have the precisely analogous structure to the laws for a monoid in the category of sets
23:49:45 <jle`> and all of its where bindings
23:49:51 <Cale> http://en.wikipedia.org/wiki/Monoidal_category
23:49:55 <jle`> yet i have to explicitly give a type signature
23:49:57 <jle`> for every single one
23:50:00 <Cale> http://en.wikipedia.org/wiki/Monoid_object
23:50:02 <jle`> with the contraints
23:50:09 <jle`> (there are seven of them)
23:50:15 <dleedev> Cale: I think it would be easier if you told me, for a given monad, what the monoid's set, unit, and operator are
23:50:27 <roboguy_> jle`: http://www.haskell.org/haskellwiki/Context_alias
23:50:28 <Cale> dleedev: You no longer have a set at all
23:50:30 <jle`> is there any way to say "okay so all of the m e t s v a in this entire binding are exactly the same" ?
23:50:36 <Cale> dleedev: You have an endofunctor M
23:50:38 <jle`> so i only need to specify constraints once?
23:50:42 <dleedev> Cale: but a monoid requires a set, no?
23:50:50 <Cale> dleedev: Yes, an ordinary monoid does
23:51:01 <Cale> dleedev: We're *generalising* the definition of a monoid
23:51:15 <Cale> dleedev: and transplanting it into another category, from the category of sets and functions
23:51:17 <dleedev> Cale: so when people say monads are monoids, there must be a sense in which something goes inside the monoid set
23:51:24 <Cale> dleedev: No, there isn't
23:51:25 <roboguy_> jle`: what if you take the constraints out of the newtype?
23:51:38 <Cale> What they mean is that monads are monoid objects in the category of endofunctors.
23:52:12 <dleedev> Cale: ooooh
23:52:19 <Cale> dleedev: Monads are *not* ordinary monoids
23:52:24 <jle`> roboguy_: hm the newtype's restraints are actually supposed to be there maybe. i'll try taking it out and seeing if anything breaks
23:52:27 <Cale> dleedev: But they have similar abstract structure
23:52:38 <Cale> Where with an ordinary monoid you have:
23:52:41 <jle`> roboguy_: i have specified other Integrators without even having to supply a type signature
23:52:41 <Cale> 1) A set M
23:52:48 <dleedev> Cale: "category of endofunctors" means the objects are endofunctors?
23:52:58 <Cale> 2) A unit-picking function eta : 1 -> M
23:53:08 <Cale> 3) A multiplication function mu : M x M -> M
23:53:15 <Cale> Satisfying certain laws
23:53:18 <shachaf> The category of endofunctors is also monoidal in other ways, right?
23:53:18 <Cale> dleedev: yes
23:53:25 <Cale> shachaf: In what ways?
23:53:31 <Cale> shachaf: Maybe?
23:53:31 <shachaf> E.g. (:*:)/Proxy, (:+:)/Void1?
23:53:48 <Cale> oh, yeah, if the underlying category has more structure, sure
23:53:54 <shachaf> In Haskell, I mean.
23:53:56 <Cale> yeah
23:54:09 <Cale> So, a monad consists of:
23:54:14 <Cale> 1) An endofunctor M
23:54:29 <dleedev> Cale: so return is unit, and functor composition is the binary operator, right?
23:54:32 <Cale> 2) A unit natural transformation eta : 1 -> M  (now 1 is the identity functor, not the one element set)
23:54:59 <Cale> 3) A multiplication natural transformation mu : M . M -> M  (now composition of functors has replaced the Cartesian product of sets)
23:55:10 <shachaf> What are monoids in those categories like?
23:55:18 <Cale> The "multiplication" is called join in Haskell
23:55:20 <Cale> :t join
23:55:21 <lambdabot> Monad m => m (m a) -> m a
23:55:33 <Cale> See, there are two m's and then there's one
23:55:48 <Cale> So it's somehow "combining" that structure
23:56:08 <dleedev> right, and that's the functor composition, right?
23:56:21 <Cale> shachaf: Well, for (:*:), I would expect that the monoids are functors which make monoids, like MonadPlus and Alternative do.
23:56:36 <jle`> oh i added a forall in the type constructor
23:56:38 <jle`> and evrything worked
23:56:40 <jle`> hah!
23:56:41 <shachaf> Cale: You have Proxy ~> F, i.e. forall a. () -> F a
23:56:45 <jle`> er, in the newtype definition
23:56:46 <shachaf> So it sounds like it wouldn't be very interesting?
23:56:57 <Cale> Oh, maybe I don't know what (:*:) is
23:56:59 <Cale> :)
23:57:08 <Cale> I'm thinking it's the lift of the product?
23:57:13 <shachaf> Yes.
23:57:13 <Cale> to functors?
23:57:24 <shachaf> newtype (f :*: g) a = Times (f a) (g a)
23:57:53 <Cale> shachaf: Right, so for each type F a, you'd get an identified element which was the image of () under that map
23:57:53 <shachaf> Er, data
23:58:26 <Cale> shachaf: and you'd also get a map (F a, F a) -> F a
23:58:35 <shachaf> Oh, maybe it's not as uninteresting as I thought.
23:58:49 <Cale> shachaf: So I'm expecting it's an ordinary monoid for each type a, in a way which is natural in a
23:59:24 <jle`> hm. what causes <<loop>> ?
23:59:30 <jle`> and why is it not catchable at compile time?
23:59:38 <Cale> jle`: Needing to evaluate some expression which you were already evaluating.
23:59:52 <Cale> Halting oracles don't really exist.
