00:00:25 <dottedmag> DigitalKiwi: http://en.wikipedia.org/wiki/MD3 -- pick the one you like
00:02:10 <DigitalKiwi> hmm
00:02:46 <DigitalKiwi> md3 file format is quake 3 which is newer than when md3 would have been created (but apparently wasn't) so I don't know why it wasn't made :<
00:03:05 <DigitalKiwi> http://en.wikipedia.org/wiki/Comparison_of_cryptographic_hash_functions
00:04:43 <DigitalKiwi> not that that would have stopped them
00:12:27 * hackagebot zip-conduit 0.2.2.1 - Working with zip archives via conduits.  http://hackage.haskell.org/package/zip-conduit-0.2.2.1 (TimCherganov)
00:12:27 * hackagebot cryptohash 0.11.2 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.11.2 (VincentHanquez)
00:15:18 <joe9>  Twey, dottedmag : this is how I patched it: updated module: http://codepad.org/I9P5jur8
00:15:24 <joe9> I will paste the diff in a minute
00:15:45 <joe9>  http://codepad.org/k7DMiYN1 diff
00:16:19 <joe9> Any kind comments, please?
00:17:48 <Twey> joe9: Looks good
00:17:53 <joe9> thanks.
00:18:13 <Twey> You messed up the indentation a bit, though
00:18:25 <jle`> does anyone know if Fay/Haste actaully ever intend to be able to compile complete ghc haskell?
00:18:29 <Twey> Did you use tabs or something by mistake?
00:18:53 <joe9> Twey, I am using one of those haskell auto indenters which does that by default when I save the file.
00:19:07 <Twey> jle`: IIRC Faye has no such aspirations; don't know about Haste
00:19:09 <joe9> I think flymake or hsindent.
00:19:18 <Twey> joe9: I suggest not doing that.  ☺
00:19:42 <joe9> Twey, I will send a patch without those first few lines.
00:19:48 <Twey> Okay
00:20:08 <Twey> Still, you should stop your editor messing up your code
00:28:17 <joe9> Twey, I like the way it formats the code.
00:30:52 <Twey> joe9: Haskell code usually tries to line up related points in each line, which your indenter seems to have trouble with
00:32:08 <leino> quick question about typeclasses: why is it not possible to have a class like, say: "class FixedSizeRepresentable a where sizeOf :: Int? (GHC complains that I'm not mentioning 'a' in the sizeOf function, which is correct.
00:33:12 <leino> for example, I'd like to define things like "instance FixedSizeRepresesentable Word8 where sizeOf = 1", or "instance FixedSizeRepresentable Word32 where sizeOf = 4", and so on...
00:33:41 <Twey> leino: The compiler infers which typeclass you meant to use by the type of the term or some term passed in as an argument
00:34:00 <Twey> If you don't mention the type variable in the method at all, there's no way to specify which typeclass should be used
00:34:10 <Fuuzetsu> Is it possible to derive a Monoid given a Monad one? Say, go from Monad [] to Monoid a ⇒ Monoid [a]
00:34:35 <Fuuzetsu> (not particularly in Haskell, just in general)
00:34:47 <Twey> The usual hack is something like: class FixedSizeRepresentable a where sizeOf ∷ a → Int and then instance FixedSizeRepresentable Word8 where sizeOf _ = 1
00:35:12 <leino> Twey: ah, of course! but is there any way to "fake" it?
00:36:21 <pavonia> leino: What would be the result of "sizeOf + sizeOf"?
00:36:54 <Twey> Fuuzetsu: In your specific example, you can define the monoid operation in terms of join, but that's not necessarily the case
00:37:21 <Twey> Hm
00:37:22 <Fuuzetsu> Right, my question is whether it's possible in general.
00:38:09 <leino> pavonia: hmm.. it could be known statically if you knew the intented "type", a
00:38:50 <Twey> Fuuzetsu: No
00:39:22 <pavonia> leino: Where do you take the intended type from?
00:39:38 <Twey> Fuuzetsu: That's why MonadPlus exists
00:40:40 <leino> maybe it's better if I explain what I'm trying to do, I'll make a hpaste.. hold on a sec
00:40:45 <Twey> (well, one of the reasons — thanks mzero)
00:41:06 <Twey> leino: 072013 <Twey> The usual hack is something like: class FixedSizeRepresentable a where sizeOf ∷ a → Int and then instance FixedSizeRepresentable Word8 where sizeOf _ = 1
00:41:37 <Twey> I.E. pass in an argument of the type, but ignore it (the caller can pass undefined if there isn't an instance of the type available)
00:53:11 <leino> here is the code that caused me to ask the above question: http://lpaste.net/98756
00:55:35 <leino> (my question starts at "boilerplate alert", so you can probably ignore the code that comes above that)
00:57:37 <Twey> leino: You have two options here
00:58:10 <Twey> You can use ScopedTypeVariables to refer to the ‘a’ type directly, or you can use a separate function that forces something to be of type a given a type Parser a
00:59:26 <leino> Twey: but GHC still won't allow me to define FixedSizeRepresentable the way I've done here, right?
01:00:31 <keko_> a
01:00:35 <keko_> oops
01:00:45 <Twey> leino: http://lpaste.net/98756
01:02:14 <leino> "sizeOf (undefined :: a)"  :D
01:02:57 <leino> I considered something like this, but the above code was my main stumbling block
01:03:18 <leino> i.e. I was thinking "how to specify the type when I dont have a value of the type..."
01:03:39 <shachaf> sizeOf' :: Storable a => proxy a -> Int would be nice.
01:04:59 <leino> ok so I buy that solution, but I wonder if I should be using template haskell for this instead?
01:07:31 <leino> also, I guess I may as well be using Foreign.Storable (which has a sizeOf :: a -> Int) then?
01:10:11 <spio> leino: Do you want dynamics types (something like Data.Typeable)?
01:11:13 <Twey> leino: No, and yes
01:11:53 <partycoder> from a very high level perspective, how would you model publish subscribe using FP?
01:12:36 <johnw> partycoder: maybe http://lpuppet.banquise.net/blog/2014/01/18/the-stm-firehose-package/?
01:13:00 <partycoder> thanks, reading it now
01:14:52 <leino> Twey: I don't follow. Which types/type variables in my pasted code would you make into a Typable?
01:16:01 <leino> Twey: or if you mean, would I like to parse things of a dynamic type then no, I don't
01:19:07 <Twey> leino: You asked two questions, and I answered them in order… neither was about Typeable :þ
01:19:16 <Twey> 075026 <leino> ok so I buy that solution, but I wonder if I should be using template haskell for this instead?
01:19:18 <Twey> 075259 <leino> also, I guess I may as well be using Foreign.Storable (which has a sizeOf :: a -> Int) then?
01:20:03 <Twey> TH doesn't let you choose functions based on types, so it wouldn't be useful to you.  You may indeed as well be using Foreign.Storable, though, since that's about equivalent.
01:20:25 <leino> < spio> leino: Do you want dynamics types (something like Data.Typeable)?
01:20:34 <leino> oops sorry
01:21:13 <leino> ok so spio asked about Typeable.. sorry about that, my irc client has a screwed up colour scheme where I cannot see who wrote what when they write directly to me :)
01:23:16 <leino> spio: I don't follow. Which types/type variables in my pasted code would you make into a Typeable?
01:23:49 <spio> leino: I am not sure, I was just responding to your question on types without value.
01:24:19 <jle`> is there any easy way to speed up simulation time in netwire?
01:25:06 <jle`> based on clockSession
01:27:31 <leino> Twey: it's funny, GHC doesn't automatically reccomend that I use ScropedTypeVariables (this automatic recommendation is my main source of information language extensions), with the code you posted
01:27:52 <rtpg> is there a good reason why ghc doesn't do proper data dependency checks for profiling libs?
01:34:15 <Twey> leino: It probably recommends RankNTypes
01:35:23 <Twey> leino: ScopedTypeVariables hijacked the RankNTypes syntax to avoid breaking old code
01:38:39 <spio> Twey: Going to sound like a super noob here but can't the commented out code in the lpaste from leino be done with a type family?
01:45:24 <Twey> spio: No
01:45:36 <Twey> I mean, you can use a type family, but it doesn't help
01:47:16 <spio> Twey: I read the documentation a bit more and realised it was not true. I was hoping for something similar to Go where you can have a switch statement on type (a map might also be possible).
01:49:28 <Twey> spio: You effectively can (the typeclass mechanism just requires you to declare your intent to switch, and allows you to add new cases later) but the problem here is that we have no type on which to switch
01:49:35 <Zettablade> Internet explorer represent!
01:52:47 * mekeor wonders what uptime finnrobi has
01:53:06 <spio> Twey: Is there no way for the type to self report its size? The addendum you added still requires manually adding each type size.
01:54:08 <Twey> spio: Types only exist at compile-time: they can't report anything
01:54:53 <Twey> But yes, that's exactly what sizeOf does
01:55:57 <Ralith> Twey: I think he wants the compiler to work out what sizeOf should return for him
01:56:40 <francogrex> Hi guys, a haskell code for this is missing: http://rosettacode.org/wiki/Machine_code ... anyone wants to contribute?
02:01:04 <spio> Ralith: Yes. It seems somewhat odd since Word8 has a size noted somewhere (besides in the name).
02:02:21 <Axman6> francogrex: hmm, there's a package that can do that...
02:02:42 <Axman6> ah, harpy!
02:03:02 <francogrex> Axman6: ok if anyone could contrubite to promote this it would be nice
02:03:21 <shiona> I'm starting a tiny web project to learn some "real life" haskell. At the moment I would be going with happstack, anything I should know?
02:04:42 <Twey> spio: Ehh.  The size is a property not of the type itself but of a storage format — types don't intrinsically have a size, and some effectively can't be stored, so the question of their size is moot
02:04:49 <Twey> Also, some types have variable size, obviously
02:20:09 <spio> Twey: There might be an ugly hack to do so: http://ghcmutterings.wordpress.com/2009/02/12/53/
02:20:57 <jle`> is it still a bad idea to use void instead of >> return () ?
02:21:19 <jle`> for compiler optimization/performance reasons
02:21:27 <Twey> spio: Compiler hacks that happen to give the right result don't count :þ
02:22:19 <spio> Twey: haha fair.
02:30:05 <mus1cb0x> greents! if i'm building a 'filter configurator' for users of my app, what is a good term for the part of the filter which contains a text string of keywords? i was thinking query, but isn't the entire filter the query?
02:30:53 <finnrobi> mekeor: 144 days at the moment
03:13:35 <rajeshsr> sorry, got disconnected
03:14:11 <rajeshsr> fmap (+1) ((Right 1)::Either Int Int) is not working...
03:14:27 <rajeshsr> can anyoine tell me if Either is a functor?
03:14:40 <rajeshsr> i remember something about Either a being one..
03:15:59 <jle`> rajeshsr: you can check on ghci with :info Either
03:16:17 <jle`> and in what way is it not working?
03:16:24 <jle`> do you get a compile error?
03:16:56 <jle`> do you get the wrong number?
03:17:00 <jle`> (Right 4?)
03:17:04 <jle`> do you get a runtime error?
03:17:10 <jle`> does it return a Left somehow?
03:17:16 <timthelion> > fmap (+1) (Left 1)
03:17:17 <lambdabot>  Left 1
03:17:22 <timthelion> > fmap (+1) (Right 1)
03:17:23 <lambdabot>  Right 2
03:17:28 <rajeshsr> >  No instance for (Functor (Either Int))
03:17:29 <rajeshsr>       arising from a use of `fmap'
03:17:29 <lambdabot>  <hint>:1:4: parse error on input `instance'
03:17:31 <timthelion> Well MY ghci doesn't have that instance
03:17:41 <timthelion> I wonder what lambdabot imports for that.
03:17:42 <rajeshsr> jle`, ^
03:18:07 <jle`> ah okay.
03:18:12 <rajeshsr> ha, should i import some module then?
03:18:36 <timthelion> rajeshsr: yes, but I don't know which one...
03:18:40 <jle`> i have a list of imports in my .ghci
03:18:43 <jle`> maybe try some of them
03:18:46 <jle`> Control.Applicative
03:18:49 <jle`> Control.Monad
03:18:57 <jle`> ...it might be Control.Monad
03:19:10 <jle`> i also have Data.Typeable but that's probably not it
03:19:46 <rajeshsr> Applicative it is! :)
03:19:48 <jle`> Data.String, Data.Char, Data.List, Data.Monoid, Control.Monad.IO.Class ... wait why do I even have that
03:19:56 <rajeshsr> thanks! jle`
03:20:00 <rajeshsr> timthelion, ^
03:20:17 <jle`> np, mostly timthelion's help :)
03:20:55 <rajeshsr> timthelion, thanks! :)
03:21:05 <jle`> it's so weird that these instances aren't in Prelude
03:21:10 <timthelion> :) no problem
03:21:12 <rajeshsr> jle`, yep, dint realize he pointed out abt needing module! :)
03:21:21 <jle`> oh
03:21:27 <jle`> according to :info
03:21:30 <rajeshsr> yep
03:21:36 <jle`> this instance lives in Data.Either
03:21:55 <jle`> and i guess it is re-exported by monad/applicative?
03:22:32 <Tekmo> I agree
03:22:54 <Tekmo> So the official import for these instances used to be Control.Monad.Instances
03:22:59 <Tekmo> I don't know what the official source is these days
03:23:35 <jle`> "instance modules" are out of fashion these days right?
03:23:51 <timthelion> The universitality of typeclass instances seems to confuse people quite a lot.  Even people who shouldn't be confused by it.
03:24:07 <Tekmo> jle`: Yeah, pretty much
03:24:19 <Tekmo> What do you mean by universality?
03:24:54 <jle`> Either is basically defined/characterized/useful by its Functor instance anyway
03:25:00 <timthelion> Tekmo: If I undestand correctly, within a single linked object any given data type should have exactly one instance for each typeclass, across all module boundaries.
03:25:07 <jle`> it doesn't really make too much sense to export Either and not a functor instance
03:25:22 <Tekmo> Oh, you mean uniqueness?
03:25:28 <timthelion> Tekmo: yes.
03:25:32 <Tekmo> timthelion: Got it
03:26:10 <jle`> well...it's no different than data Either a b = Left a | Right b being unique/universal
03:26:12 <jle`> right?
03:26:13 <Tekmo> jle`: There are some people who think a `Functor`/`Monad` instance for `Either`/`((->) a)` is a bastardization.  I strongly disagree with those people
03:26:33 <timthelion> Tekmo: anyways, I was just reading a list of GSOC's and I saw someone wanted to allow for multiple package versions in a single project with ghc.  And I was surprised that this got approved given it's seeming lack of usefullness given the constraint of uniquness of instances.
03:26:47 <Tekmo> timthelion: I had never considered that issue
03:26:57 <timthelion> Tekmo: and that is why I said that the issue seems to confuse people who shouldn't be confused by it.
03:28:15 <jle`> Tekmo: i have not heard of that position
03:28:18 <jle`> that's interesting
03:29:51 <jle`> what is this instance [overlap ok] business i see when trying out different :info's in ghci?
03:30:15 <Tekmo> jle`: I'm not sure.  I think it happens if you enable the `OverlappingInstances` extension
03:31:09 <jle`> Tekmo: hm it's not set
03:31:23 <jle`> what does it say when you type :info TypeRep ?
03:31:59 <Tekmo> jle`: I get the [overlap ok], same as you
03:32:18 <jle`> oh well
04:26:16 * benmachine opens a new file, writes the module header, takes deep breath
04:42:42 * hackagebot hakyll 4.4.3.1 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.4.3.1 (JasperVanDerJeugt)
04:46:52 <Aetherspawn> are deadlocks possible with STM?
04:47:08 <Aetherspawn> if there are heaps of threads trying to write/read at the same time
04:51:47 <quchen> Livelocks are, deadlocks aren't.
04:52:11 <quchen> The threads will always continue working, but may make each other retry indefinitely.
05:00:25 <zq> https://github.com/bryant/thih-markdown/blob/master/thih.lhs
05:00:39 <zq> porque i could not find a copy on google
05:01:48 <Aetherspawn> quchen: shoot
05:01:56 <Aetherspawn> that can happen with very high traffic?
05:02:10 <Aetherspawn> does that actually make STM suitable for a server?
05:02:27 <quchen> Oh sure, the thing is just that having large transactions may be a problem.
05:03:00 <quchen> The thing is when you have something huge running that depends on the value of sime tiny TVar, and another small transaction modifies that TVar, then the huge transaction will be restarted.
05:03:23 <Aetherspawn> :(
05:03:24 <quchen> Now suppose the small transaction runs quite often, then the large transaction will keep trying and retrying.
05:04:09 <Aetherspawn> but, in a well designed server, they would perform better than locks?
05:04:24 <Aetherspawn> it certainly sounds more concurrent
05:04:28 <quchen> STM's purpose is not performance, it's the guarantee of atomicity.
05:04:47 <quchen> And also avoiding locks, yes.
05:05:21 <Aetherspawn> Ooh, I'm excited. I'm kvanberendonck on github, so I've been hacking away at the new pipes.concurrent.broadcast stuff
05:05:25 <quchen> Typically I'd say STM is less performant than using IO, but much easier to work with :-)
05:06:04 <quchen> The thing with STM is that usually you don't have to worry without a reason, whereas with MVars you should always be actively worried about potential deadlocks etc.
05:06:05 <Aetherspawn> I think you follow that repo, I noticed you in the tickets?
05:06:26 <quchen> I've been talking with Gabriel in some issues a bit, yes
05:06:55 <Aetherspawn> did gabriel show you the pipes vs conduit performance from a month or two ago?
05:06:59 <Aetherspawn> if you care, I can dig it up
05:07:01 <Aetherspawn> its very impressive.
05:07:29 <quchen> No, I haven't seen that.
05:07:38 <quchen> (I also haven't used Conduit)
05:08:10 <quchen> But I just read his new post and it's (unsurprisingly) great
05:08:19 <quchen> And it shows some benchmarks
05:08:49 <Aetherspawn> oh, new post?
05:08:53 <quchen> http://www.haskellforall.com/2014/01/stream-fusion-for-pipes.html
05:09:04 <quchen> Maybe that includes the benchmarks you mentioned as well
05:09:04 <Aetherspawn> cheers!
05:09:26 <Aetherspawn> well, the ones he took 2 months or so ago for me showed pipes to be 5.5x faster than conduits for pure things
05:09:37 <Aetherspawn> reading~
05:12:00 <Aetherspawn> wow, impressive
05:14:45 <Aetherspawn> Back then pipes was a little bit slower than conduits for IO, but it's great to see he cleared that up
05:17:46 * hackagebot egison 3.2.7 - Programming language with non-linear pattern-matching against unfree data types  http://hackage.haskell.org/package/egison-3.2.7 (SatoshiEgi)
05:22:01 <statusfailed> Is there a generalised suffix tree package (i.e. allowing multiple input strings)? suffixtree seems to allow only one
05:23:51 <Aetherspawn> statusfailed: suffix tree.. is that by any chance the same as a trie?
05:24:31 <quchen> Tries are prefix trees
05:24:33 <statusfailed> Aetherspawn: actually i'm not sure- I thought tries were prefix trees though
05:24:39 <dabd> why do haskellers use so many spaces to align some operators? ex: http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Control-Monad.html#ap
05:25:10 <Aetherspawn> dabd: sometimes it looks better without docs
05:25:16 <Aetherspawn> and then when docs get added nobody puts it back
05:25:46 <dabd> is it bad style to not use this convention?
05:25:57 <dabd> i don't think it increases readability
05:26:00 <quchen> dabd: That piece of code is silly, that's why. They tried to globally align definitions to the n-th column, but added lots of functions that don't work with that convention in between.
05:26:01 <Aetherspawn> its personal preference
05:26:37 <Aetherspawn> I swapped to the coding conventions used to ben lipm at unsw
05:26:42 <Aetherspawn> *used by
05:26:55 <dabd> where can i find those?
05:27:01 <Aetherspawn> its 8 space tabs, alignments on lots of things, breaks on function defs
05:27:05 <Aetherspawn> I feel it makes a lot of sense.
05:27:15 <Aetherspawn> Uhh, they aren't formalized, but you can get the idea by reading the ddc source code
05:27:20 <Aetherspawn> its VERY pretty imo
05:27:29 <Aetherspawn> https://github.com/DDCSF/ddc
05:28:07 <quchen> Exercise 1. Find the source code.
05:28:31 <Aetherspawn> ie
05:28:32 <Aetherspawn> https://github.com/DDCSF/ddc/blob/master/packages/ddc-core-simpl/DDC/Core/Simplifier/Apply.hs
05:28:35 <Aetherspawn> lol quchen
05:28:54 <Twey> *Eight*-space tabs?  Eek.
05:29:02 <quchen> Ewwwwwwww https://github.com/DDCSF/ddc/blob/master/packages/ddc-plate/Main.hs
05:29:17 <Twey> I usually align things that are together in a block (without breaks)
05:29:27 <Twey> File-globally is a bit excessive :þ
05:29:33 <Aetherspawn> ahaha
05:29:54 <dabd> i come from lisp and while learning haskell i sometimes wish the syntax was s-expr based
05:29:57 <dabd> it's much simpler
05:30:23 <quchen> dabd: You can write Haskell in "S-expression" style.
05:30:29 <Twey> (but please don't)
05:30:38 <quchen> I use a mix of infix and S-exprs.
05:30:40 <hodapp> quchen: Whaaaaaa?
05:30:48 <hodapp> sexprs in haskell?
05:30:53 <dabd> quchen: there were 2 projects to bring s-expr syntax but they seem to be dead afaik
05:31:00 <quchen> hodapp: Well, what I really meant was alignment and lots of parentheses with "S-expression style".
05:31:01 <dabd> one was liskell and the other i forgot
05:31:09 <Twey> Lisk
05:31:15 <hodapp> liskell? that just sounds incomprehensible.
05:31:33 <dabd> but i don't think it would be good to use s-expr because probably few people like it in the haskell community
05:32:22 <Twey> Also because most Lisps have various kinds of syntax to work around the problem of having a dozen levels of nesting everywhere, which Haskell lacks
05:32:45 <hodapp> Twey: what kinds of syntax do you mean?
05:32:48 <quchen> (sum . map (^2) . take 10) xs
05:32:49 <dabd> clojure solves the problem of nesting with nice "threading" macros
05:32:55 <hodapp> ah, yeah
05:33:30 <Twey> hodapp: E.G. variadic + instead of (+ (+ (+ 1 2) 3) 4)
05:33:58 <Twey> Or Clojure's ->
05:34:47 <dabd> but i programmed in common lisp and never found nested parenthesis to be a problem
05:35:24 <Twey> dabd: Exactly :þ
05:36:40 <dabd> so anyone knows why the s-expr syntax never picked up in the haskell community?
05:37:30 <hpc> because it would be a fundamental change in syntax
05:37:41 <ceem> 'cause it looks like xml
05:37:58 <hpc> also haskell programmers are allergic to parens
05:38:18 <Twey> dabd: It gets in the way of equational reasoning, it's different, people are used to using infix operators to clarify, it's not as useful because we don't use macros as much
05:38:46 <Twey> Also, Haskell code is not made out of lists
05:38:52 <hpc> https://en.wikipedia.org/wiki/ML_%28programming_language%29 -- where haskell comes from
05:39:16 <dabd> but it would remove several complexities from haskell's syntax, namely fixity. Also you end up using a lot of $ to avoid using parenthesis
05:39:22 <hpc> (inspired by ISWIM which was never implemented, so the whole family of languages with that syntax is called ML-like)
05:39:57 <Twey> dabd: Oh, it also doesn't mesh well with curried functions
05:40:28 <Aetherspawn> my gripes about haskell syntax;
05:40:32 <Aetherspawn> let / in don't line up
05:40:42 <Aetherspawn> where is longer than 3 spaces + 1 for padding
05:41:00 <Aetherspawn> and do-notation feels evil
05:41:02 <dabd> Twey: can you show me an example of how s-expr doesn't work well with curried functions?
05:41:11 <hpc> Aetherspawn: we should solve it the way email did
05:41:13 <Aetherspawn> I'm forever hung between do + newline, or do x <- .... and a newline
05:41:14 <hpc> a la "HELO"
05:41:33 <hpc> let-in becomes asume-whence
05:41:35 <Twey> dabd: foo bar baz quux becomes (((foo bar) baz) quux)
05:41:36 <hpc> where stays the same
05:41:43 <hpc> now they are all five chars
05:41:51 <Aetherspawn> so we have to use 8 tabs?
05:42:14 <Aetherspawn> suddenly, fst/snd are shorter than the sugar that wraps them
05:42:18 <Twey> Aetherspawn: I use the latter when it fits, the former otherwise
05:42:19 <Aetherspawn> shock horror.
05:42:34 <Twey> But eight-tabs makes nothing fit anywhere, so I guess that's a solved problem ;)
05:42:48 <Aetherspawn> eight tabs is fine, but you have to know hwo to use it
05:43:00 <Aetherspawn> like, let ... in .. where fits PERFECTLY in 8 tabs
05:43:02 <Aetherspawn> its almost magical
05:43:12 <Aetherspawn> when you're coding it, every alignment happens as you would dream it
05:43:16 <hpc> Aetherspawn: i always do 2-space indent with do-blocks
05:43:17 <hpc> do
05:43:19 <hpc>   foo ...
05:43:42 <Aetherspawn> it's just, you very quickly, unless you start cheating and doing -> with single spaces and stuff
05:43:49 <Aetherspawn> you hit ruler 80, which is the "evil zone"
05:43:58 <hpc> also, using tabs isn't as simple as "tabs are 8 spaces", haskell uses stops
05:44:13 <hpc> foo^Ibar -- bar is still aligned to column 8
05:45:36 <dabd> Twey: the curried functions example looks like a minor inconvenience :-P
05:45:54 <Aetherspawn> I almost with in was really `for` or something like that
05:46:00 <Aetherspawn> /s/with/wish
05:46:03 <Twey> dabd: Except when you realize you'll be doing this *every time you call a function*
05:46:08 <Aetherspawn> even though that sounds stupid it'd line up a lot nicer
05:46:53 <dabd> Twey: I see. I'm sure the haskell designers considered all options carefully
05:47:00 <Twey> dabd: Also, front-grouped brackets are terrible: back-grouped is fine, because you open them when you need them then just press ) until they're all closed when you're done, but front-grouped means you have to stop before you type any expression and think about how many arguments you're going to pass, and then type that many (s
05:47:39 <Aetherspawn> ooh, varidic operators
05:47:42 <Aetherspawn> that's a really really cool idea
05:47:48 * hackagebot conduit 1.0.10.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-1.0.10.1 (MichaelSnoyman)
05:47:53 <Aetherspawn> (+ foo bar 1 2 3)
05:47:55 <dabd> Twey: there are emacs modes that automate a lot of the parenthesis handling stuff: paredit and the newer smartparens mode
05:47:57 <Aetherspawn> expands to foo + bar + 1 + 2 + 3
05:48:30 <Twey> dabd: Sure, but when you're relying on editor features to make up for your language you've just jumped down the slippery slope that leads to Java :þ
05:48:37 <Aetherspawn> foo <$> (<*> x y z) instead of foo <$> x <*> y <*> z
05:49:20 <Twey> Aetherspawn: Oleg has a thing
05:49:34 <hpc> oh god for a second i thought that was actual haskell
05:49:46 <Cale> (| foo x y z |)
05:49:48 <Twey> Almost
05:49:50 <hpc> :t \foo x y z -> foo <$> (<*> x y z)
05:49:51 <lambdabot> Applicative f => (f b1 -> b) -> (t -> t1 -> f a) -> t -> t1 -> f (a -> b1) -> b
05:49:58 <Twey> (<*> x y z ∷ Build)
05:50:13 <Aetherspawn> aw poo hpc ruined it
05:50:20 <Twey> hpc: You shouldn't be able to do that =(
05:50:22 <Aetherspawn> by showing how currying spoils the broth
05:50:44 <Cale> Variadic operators are overrated when you realise what you give up
05:51:44 <hpc> :t (~=)
05:51:46 <lambdabot>     Not in scope: `~='
05:51:46 <lambdabot>     Perhaps you meant one of these:
05:51:46 <lambdabot>       `/=' (imported from Data.Eq), `<=' (imported from Data.Ord),
05:51:49 <hpc> aw :(
05:52:09 <Aetherspawn> :t L.(~=)
05:52:09 <lambdabot> Not in scope: data constructor `L'
05:52:09 <lambdabot>     Not in scope: `~='
05:52:09 <lambdabot>     Perhaps you meant one of these:
05:52:18 <Aetherspawn> looking for the lens thing?
05:52:23 <hpc> i vaguely remember (~=) being variadic
05:52:28 <hpc> the regex one
05:52:31 <Aetherspawn> oh
05:52:36 <Twey> It wasn't variadic, just terrifying
05:52:56 <Aetherspawn> I think when you import lens
05:53:00 <Twey> Hugely polymorphic in its return type, to a bunch of things you wouldn't really expect
05:53:00 <Aetherspawn> operator realestate becomes hard.
05:53:04 <Twey> Heh
05:53:08 <hpc> i thought there was something to do with setting flags
05:53:26 <hpc> printf is polymorphic though!
05:53:30 <hpc> er, variadic
05:53:53 <Twey> (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
05:53:56 <Twey> Delicious
05:53:57 <hpc> it's less scary, but also has weird type inference problems
05:54:11 <Aetherspawn> I notice some people use => => notation
05:54:15 <Aetherspawn> instead of ( , ) =>
05:54:18 <Aetherspawn> I HATE that.
05:54:22 <Twey> Ooh!
05:54:27 <hpc> oh god, curried contexts
05:54:34 <Twey> I hadn't considered that!  I should take it up.
05:54:37 <hpc> i didn't even know that parsed
05:54:39 <Aetherspawn> NO
05:54:40 <Twey> Save some brackets
05:54:46 <Aetherspawn> It makes reading haddock so much harder
05:54:54 <hpc> ^
05:54:58 <Twey> There is that
05:55:07 <Twey> What does Haddock do to that?
05:55:15 <Aetherspawn> it just displays it as
05:55:35 <dabd> has anyone read Spivak's book "Category Theory for Scientists"?  I'm learning Haskell by reading learn you a haskell and I wonder if the first book would help understand some of the concepts of the language better.
05:55:36 <Aetherspawn> Foo a => Bar a => Derp a => Monad m -> a -> m a
05:55:45 <Aetherspawn> whereas the much more readable is
05:55:51 <hpc> Aetherspawn: that first (->) was deliberate?
05:55:53 <Twey> dabd: Fuuzetsu is reading it at the moment, in theory
05:55:53 <Aetherspawn> (Foo a, Bar a, Derp a, Monad m) => a -> m a
05:55:59 <Aetherspawn> woops
05:56:04 <Aetherspawn> no it wasnt
05:56:09 <Twey> Aetherspawn: Why is that much more readable?  :þ
05:56:10 <Aetherspawn> the -> after monad m should be a =>
05:56:18 <Aetherspawn> because you can skip to the => and start reading
05:56:27 <Aetherspawn> in the top one its just impossible to tell at a glance where the arguments start
05:56:27 <hpc> Twey: try mixing (->) into your context sometime
05:56:34 <Twey> You can still skip to the last ⇒
05:56:36 <Aetherspawn> hpc: ?! you can do that
05:56:47 <hpc> Aetherspawn: i mean like function instances
05:56:54 <Aetherspawn> x -> Foo a => b -> c => Derp b -> b ?!
05:56:55 <Aetherspawn> oh
05:57:00 <dabd> I'm on ch11 of learn you a haskell and here it gets a bit harder to understand when he goes deeper into how functors work
05:57:04 <hpc> instance Enum a, Enum b => Enum (a -> b), etc
05:57:12 <Cale> dabd: Any questions?
05:57:18 <dabd> so i started reading spivak's book at the same time. It's very nice
05:57:21 <hpc> (i don't think that instance exists but still)
05:57:33 <Aetherspawn> if => and -> could be out of order
05:57:41 <Aetherspawn> I'd quit haskell today.
05:57:49 * hackagebot wai-extra 2.0.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.0.3 (MichaelSnoyman)
05:57:51 * hackagebot wai-websockets 2.0.0.1 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-2.0.0.1 (MichaelSnoyman)
05:58:03 <Cale> Aetherspawn: actually it can make sense for the contexts and parameters to be supplied in another order...
05:58:11 <Twey> > let f :: Num a => a => a => a; f = (+) in f 3 5
05:58:13 <lambdabot>  8
05:58:22 <Aetherspawn> lol wat
05:58:24 <Cale> heh, *that* is a bug
05:58:27 <Aetherspawn> Cale: like?
05:58:32 <Twey> :þ
05:58:33 <Cale> It's fixed in 7.8
05:58:53 <Fuuzetsu> Twey: I don't have that one.
05:59:14 <Fuuzetsu> I'm reading Category Theory for Computing Science
05:59:18 <Twey> Oh, pardon
05:59:36 <Twey> Aetherspawn: http://joyoftypes.blogspot.co.uk/2012/02/haskell-supports-first-class-instances.html withDict :: Dict c -> (c => b) -> b
06:00:01 <narendraj9> Twey: What are monads? Where can I learn about them?
06:00:04 <Aetherspawn> well
06:00:09 <dabd> Cale: I had some trouble understanding the Applicative instance implementation of Maybe
06:00:24 <Cale> dabd: Okay, let's have a look at that
06:00:25 <Aetherspawn> what does c => b mean
06:00:29 <Cale> :t pure
06:00:31 <lambdabot> Applicative f => a -> f a
06:00:32 <Twey> narendraj9: Why me specifically?  :þ  You can learn about them from LYAH.
06:00:45 <Cale> So, if f = Maybe, then pure :: a -> Maybe a
06:00:56 <dabd> right
06:01:04 <narendraj9> Twey: Sorry. It was done by mistake.. Thanks anyway..
06:01:05 <narendraj9> :)
06:01:14 <Cale> There's practically only one sensible thing such a function could do, which is  pure x = Just x
06:01:17 <Twey> narendraj9: http://learnyouahaskell.com/a-fistful-of-monads — but I recommend reading at least the typeclass-based chapters leading up to it first
06:01:32 <Cale> (I suppose you could also have pure x = Nothing, but then, you don't use your parameter)
06:01:43 <Cale> and then there's <*>
06:01:49 <Cale> :t (<*>)
06:01:50 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:01:51 <Twey> Aetherspawn: What it looks like — value that has type b given context c
06:02:02 <Twey> s/—/— a/
06:02:03 <Cale> So, this has type  Maybe (a -> b) -> Maybe a -> Maybe b
06:02:27 <Cale> Now, if either of the two parameters is Nothing, we'll not be able to get hold of a value of type b
06:02:28 <Aetherspawn> I dont understand that to make any sense
06:02:36 <Aetherspawn> what effect does it have on the type apart from "being there" ?
06:02:43 <Cale> So:
06:02:57 <Cale> Nothing <*> y = Nothing
06:03:02 <Cale> x <*> Nothing = Nothing
06:03:41 <Cale> and then if both of them are Just, we'll have a function (a -> b) and a value of type a, so the natural thing would be to stick them together, applying the function to the value
06:03:53 <Cale> Just f <*> Just x = Just (f x)
06:05:18 <dabd> in the book it is written: (Just f) <*> something = fmap f something
06:05:51 <dabd> so something is a functor that takes a type 'a' according to the signature
06:06:04 <Cale> something cannot be a functor, because it is a value
06:06:29 <Cale> Maybe is a functor
06:06:32 <Cale> Just 4 is not a functor
06:06:33 <Aetherspawn> > let f :: Num a => a => a => a => a => a => a => a; f = (+) in f 3 5
06:06:34 <lambdabot>  Could not deduce (a ~ (a -> a -> a -> a -> a))
06:06:34 <lambdabot>  from the context (GHC.Num.Num a)
06:06:34 <lambdabot>    bound by the type signature for
06:06:34 <lambdabot>               f :: GHC.Num.Num a => a -> a -> a -> a -> a -> a -> a
06:06:34 <lambdabot>    at <interactive>:1:10-49
06:07:12 <Cale> something is a value of type Maybe a, according to the type signature
06:07:24 <Twey> Aetherspawn: It has the same effect as in a normal function (c → b)
06:07:34 <Cale> Since Maybe is a functor, we have  fmap :: (a -> b) -> (Maybe a -> Maybe b)
06:07:48 <Aetherspawn> (a => b) is the same as (a -> b) ?
06:07:49 * hackagebot yesod-auth 1.2.5.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.2.5.3 (MichaelSnoyman)
06:07:51 * hackagebot yesod-form 1.3.4.3 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.4.3 (MichaelSnoyman)
06:07:52 <Twey> I.E. it's a function that's polymorphic in its context (which here is fixed by the Dict)
06:08:07 <Twey> Aetherspawn: No, that's actually a context, but the analogy works
06:08:56 <Cale> dabd: Since the first parameter to <*> in this case is a value of type Maybe (a -> b), and we've pattern matched Just f, we know that f :: a -> b
06:09:06 <Cale> dabd: and hence that fmap f :: Maybe a -> Maybe b
06:09:49 <Twey> Aetherspawn: In the same way that a function (c → b) has to be applied to a c to produce a b, a function (c ⇒ b) has to be evaluated in a context c to produce a b
06:10:47 <Aetherspawn> what defines a context c alone like that?
06:10:55 <dabd> Cale: the pure signature is pure :: a -> f a and the book says it takes a value of any type and returns an applicative functor with tha value inside. But is 'f a' an applicative functor or a value?
06:10:55 <Aetherspawn> does that just mean it can't be curried or something.. I'm confused
06:11:00 <Twey> Then matching on the Dict brings that context into scope, because the Dict constructor requires a context c, so the value of the b can be talked about in the body of the function
06:11:07 <Aetherspawn> I'm only used to contexts like Num a and the like
06:11:24 <Twey> Aetherspawn: It's the same kind of context, just generalized over
06:11:35 <Twey> You can have c = Num a, for example
06:11:49 <Twey> (well, a isn't in scope there, but maybe Num b)
06:11:50 <Cale> dabd: f is an Applicative functor, f a is some type
06:12:04 <dabd> and what can i call 'f a'?
06:12:08 <Aetherspawn> oh
06:12:09 <Cale> dabd: The book seems to have abused terminology a bit
06:12:15 <dabd> oh a type
06:12:29 <Aetherspawn> and that says that if the Num c => Dict c then the lambda inside has to have that context too?
06:12:55 <Twey> Aetherspawn: It's not a lambda, just a function over a context the same as (+) or 3
06:12:58 <Twey> :t 3
06:12:59 <lambdabot> Num a => a
06:13:13 <Cale> dabd: It's not really appropriate to say that it returns an applicative functor. Ordinary value-level functions can't return functors in Haskell, because functors are very much type-level things.
06:13:18 <dabd> so f a is like a type constructor applied to a and it returns a type
06:13:24 <Cale> yep
06:13:25 <Aetherspawn> lambda is less keystrokes ;(
06:13:38 <Aetherspawn> thanks for explaining, but I have to go. night
06:13:41 <Twey> Aetherspawn: The type itself says it *needs* a context c
06:13:45 <Twey> Aw.  'night!
06:13:53 <Cale> Saying that f is an applicative functor means that there is an instance of the Applicative class for the type constructor f
06:14:53 <dabd> ok thanks. Is there any other book that explains these concepts well?
06:16:47 <mm_freak> Tekmo: hi there…  i processed 1 GiB of data in 1.3 seconds using pipes-parse and pipes-bytestring =)
06:17:03 <mm_freak> but i had to use a custom implementation of 'lines', otherwise it needs 12 seconds
06:18:30 <mm_freak> Tekmo: here is my implementation: http://lpaste.net/98764
06:18:50 <aristid> git-annex is too flexible, i feel confused trying to set it up in a way that suits me
06:19:49 <hpc> that's why i use svn - it's comfortably stultifying
06:19:59 <srhb> hpc: :\
06:20:06 <hpc> :P
06:20:19 <aristid> hpc: haha yeah...
06:29:25 <mm_freak> the more i use pipes, the less often i use (>->) =)
06:29:52 <aristid> mm_freak: instead, you write functions from Producers to Producers or FreeT?
06:30:01 <mm_freak> aristid: yeah
06:30:06 <mm_freak> exactly
06:30:41 <aristid> mm_freak:  i think Tekmo thinks that's just because I (and you apparently) mostly do parsing-type stuff
06:31:54 <aristid> mm_freak: did he tell you about his plans for a more user-friendly variation of FreeT btw?
06:32:10 <mm_freak> aristid: not yet
06:32:27 <mm_freak> well, i'd get rid of FreeF and just use Either
06:32:36 <mm_freak> other than that i'm not sure that you can actually do it
06:32:51 * hackagebot hasktags 0.68.6 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.68.6 (MarcWeber)
06:33:24 <aristid> mm_freak: his current version is  data List f m r = Impure (m (List f m r)) | Cons (f (List f m r)) | Nil r
06:33:54 <aristid> mm_freak: then you can use List Writer m r as a base-case alternative to Producer
06:34:05 <aristid> so it can make nested FreeT/Producer code more uniform
06:34:30 <aristid> i think he wants his own type instead of Writer but i think Writer would work
06:34:57 <mm_freak> hmm
06:35:06 <mm_freak> to be honest i'm not sure i like this idea
06:35:21 <aristid> why?
06:35:27 <mm_freak> the only awkwardness of FreeT is FreeF really
06:35:39 <mm_freak> other than that i find it both user-friendly and easy enough to understand
06:35:59 <aristid> mind if i paste 5 lines from a mail? he listed some advantages
06:36:09 <mm_freak> @where lpaste
06:36:09 <lambdabot> http://lpaste.net/new/haskell
06:36:13 <mm_freak> go ahead =)
06:36:22 <aristid> well then i may as well paste the whole mail i guess
06:36:39 <mm_freak> if Tekmo doesn't mind =)
06:37:16 <aristid> mm_freak: hmm yeah i hope he doesn't mind:D http://lpaste.net/291873376002113536
06:38:27 <aristid> Of is basically Writer
06:38:35 <mm_freak> well, after my little parsing experiment i can actually provide a few numbers
06:38:50 <mm_freak> i did an experiment where i wrote a 'single' combinator
06:39:07 <mm_freak> single :: (Monad m) => Producer a m r -> FreeT (Producer a m) m r
06:39:23 <mm_freak> then i concatenated everything back again
06:39:33 <mm_freak> resulting run-time:  exactly the same
06:39:36 <aristid> mm_freak: the thing that triggered the whole mail chain (i just pasted one of them) - it didn't trigger his thinking, just the mails - was that I complained a bit about FreeT being cumbersome to use
06:40:18 <mm_freak> so FreeT is sufficiently lightweight
06:40:35 <aristid> mm_freak: what's your base monad in the benchamrks? just IO?
06:40:41 <mm_freak> yes
06:40:51 <aristid> i think IO has basically no overhead, right?
06:41:07 <mm_freak> almost no overhead
06:41:15 <mm_freak> the point is that no binding occurs in the base monad unless you do actually choose to bind
06:41:24 <mm_freak> which happens only when 'next'-ing the Producer
06:41:29 <mm_freak> or when doing other stuff
06:41:40 <aristid> which happens only for whole bytestring chunks?
06:41:41 <mm_freak> that's why the FreeT wrapper added no measurable overhead
06:42:14 <mm_freak> in my benchmark yeah, but it was 1 GiB of data, so there were lots and lots of chunks
06:42:30 <mm_freak> the reason i'm saying this is that i made the same mistake in netwire
06:43:02 <mm_freak> i added pure variants just to find that they make no measurable difference, even if the base monad is something more complicated than IO
06:43:07 <mm_freak> and netwire binds a lot more often than pipes
06:43:34 <mm_freak> the small advantage gained was list directly to the additional pattern-matching that now became necessary
06:43:46 <mm_freak> so don't do it for performance…  FreeT is really lightweight
06:43:58 <mm_freak> * It's easier to build and consume `List`s because there is less monadic code
06:44:04 <mm_freak> it's harder to consume, because now you have three cases
06:44:24 <mm_freak> two of them basically the same most of the time
06:44:31 <mm_freak> so either duplicate code or an extra name in scope
06:44:39 <mm_freak> * The type inference is better
06:44:46 <mm_freak> i have yet to find a case where type inference failed
06:44:51 <mm_freak> * The names are better
06:44:59 <mm_freak> are they?  is ICombinable really better than Monoid?
06:45:04 <mm_freak> i totally disagree here!
06:45:18 <mm_freak> and i would expect Tekmo, being a categorically thinking person, to disagree with himself here
06:45:42 <aristid> mm_freak: i like the symmetry of List (List (Of Int))
06:45:49 <mm_freak> if i weren't aware of this, i would have a hard time wrapping my head around List just to find out that oh!  it's just FreeT!
06:46:04 <mm_freak> just like it pisses me off when people invent fancy names, when all they are really saying is "monoid"
06:46:05 <aristid> i suppose you could equally get that by using FreeT throughout instead of Proxy for the non-nested case
06:46:20 <mm_freak> * It doesn't depend on a dozen libraries (like the `free` package does)
06:46:29 <mm_freak> it depends on those libraries for a good reason
06:46:43 <mm_freak> monad-coroutine implements basically the same type as FreeT
06:47:02 <mm_freak> but it misses so many useful instances that every time i used it, i got annoyed and wrote orphan instances
06:47:06 <mm_freak> in other words
06:47:11 <mm_freak> i reject all five points as invalid
06:47:26 <mm_freak> please please please keep using FreeT!
06:47:34 <mm_freak> i really don't want to invent my own pipes-parse ;)
06:47:38 <aristid> hmm the second point you seemed to conditionally agree, so i may have misunderstood you:P
06:47:52 * hackagebot snap 0.13.2.1 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.13.2.1 (DougBeardsley)
06:48:13 <mm_freak> huh?  i think i specifically said that it's harder to consume ;)
06:48:16 <aristid> mm_freak: oh you meant it the otherway around.
06:48:21 <mm_freak> =)
06:48:34 <aristid> well, i just parsed "it" as referring to the other thing than you meant:P
06:49:03 <aristid> mm_freak: when i wrote some code for List, to try it out, i found that i'd usually handle the Immutable case with recursion
06:49:32 <aristid> listIt (Impure m) = Impure (liftM listIt m)
06:50:22 <dabd> the definition of ZipList in lyah reads: ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs). Isn't \f x -> f x just function application '$'?
06:51:06 <dabd> and could be replaced by zipWith $ ...
06:51:32 <dabd> or zip with ($)
06:51:42 <aristid> mm_freak: and i _did_ have less trouble writing code for it than with FreeT, but not sure why
06:52:53 <k00mi> dabd: yes
06:53:21 <dabd> ok ty
06:55:38 <mm_freak> aristid: probably because FreeT just needs some getting used to…  it took a while for me to wrap my head around how to /write/ splitters and joiners (using them was quite straightforward)
06:55:48 <mm_freak> aristid: but it's ultimately the same type
06:56:16 <mm_freak> so you may have just profitted from your FreeT experience there
06:56:56 <mm_freak> it's like:  once you understand list unfolds, you will find that stream unfolds are "easier" to write, simply because you now understand how list unfolds work
06:57:06 <aristid> mm_freak: you mean my struggles with FreeT made me mroe at ease with List?:D
06:57:14 <mm_freak> indeed
06:57:23 <aristid> i can't rule that out entirely
06:57:27 <mm_freak> again, ultimately it's the same type
06:57:42 <aristid> mm_freak: with the FreeF just rolled into it?
06:57:56 <mm_freak> well, as said, i'd get rid of FreeF
06:58:11 <aristid> mm_freak: how would you then end up with a type different than List?
06:58:18 <mm_freak> newtype FreeT f m a = FreeT (m (Either a (f (FreeT f m a))))
06:58:26 <aristid> oh, Either
06:58:38 <mm_freak> List is just this with the Either factored out and the Right case split into two cases
06:58:40 <aristid> mm_freak: what does edwardk think about that? :D
06:58:52 <mm_freak> edwardk thinks that FreeF is better than Either =)
06:59:04 <mm_freak> at least that's what he said
06:59:06 <aristid> how surprising
06:59:17 <mm_freak> and i disagree…  Coroutine was very easy to understand
06:59:32 <mm_freak> FreeT was harder, because i had to mentally parse FreeF and its extra 'f' argument
06:59:52 <aristid> mm_freak: the existence of IterT also confuses me
06:59:55 <mm_freak> newtype Coroutine f m a = Coroutine (m (Either a (f (Coroutine f m a))))
07:00:00 <mm_freak> it's exactly the same type
07:02:44 <aristid> mm_freak: IterT? if so, its existence is even more confusing!
07:03:53 <aristid> i like that it says "this one is a true monad transformer"
07:04:05 <aristid> and then "it's only up to retract"
07:05:14 <mm_freak> aristid: IterT m a ≃ FreeT Identity m a
07:05:52 <aristid> mm_freak: so it's just "
07:06:00 <mm_freak> it basically gives you m-delimiters, as far as i see
07:06:01 <aristid> mm_freak: so it's just "the most boring FreeT possible"?:)
07:06:13 <mm_freak> pretty much
07:06:15 <mm_freak> not useless, just boring =)
07:06:23 <aristid> :D
07:06:38 <mm_freak> newtype IterT m a = IterT (m (Either a (IterT m a)))
07:06:46 <mm_freak> m with delimiters
07:06:56 <aristid> mm_freak: FreeT Writer... is that an equivalent to Producer?
07:07:04 <mm_freak> not quite
07:08:02 <mm_freak> Writer has some additional semantics over Producer
07:08:15 <aristid> mm_freak: namely?
07:08:30 <aristid> note that FreeT just uses it as a functor so there's no Monoid constraint.
07:08:38 <mm_freak> oh, true
07:09:00 <aristid> i guess ((,) a) would work too
07:09:02 <Fatalnix> Release the kraken!
07:09:04 <mm_freak> well, then i suppose that FreeT (Writer L) m a = Producer L m a
07:09:12 <aristid> mm_freak: i like that.
07:09:15 <mm_freak> s/=/≃/
07:09:20 <mm_freak> me, too
07:09:25 <aristid> mm_freak: and FreeT (Reader R) is Consumer
07:09:31 <mm_freak> yeah
07:09:36 <mm_freak> i like the idea
07:09:44 <aristid> mm_freak: and you can make a PipeF and even a ProxyF
07:10:06 <aristid> mm_freak: i made that suggestion in the light of List but tekmo didn't seem enthusiastic:)
07:10:09 <mm_freak> well, with proxies i'm not sure we really need Pipe anymore =)
07:10:34 <aristid> Proxy always leaves me feeling that there's too much woven into it
07:10:45 <aristid> i guess it's necessary for (>->) and stuff
07:10:56 <aristid> :t (>->)
07:10:58 <lambdabot>     Not in scope: `>->'
07:10:58 <lambdabot>     Perhaps you meant one of these:
07:10:58 <lambdabot>       `>>' (imported from Control.Monad.Writer),
07:11:06 <aristid> y u no pipes, lambdabot?!
07:12:55 <mm_freak> well, it's like:  you can use applicative sums and products to gradually build your type, but you do this for research
07:13:06 <mm_freak> when actually writing a library you should probably actually write a complete type
07:13:25 <mm_freak> with the FreeT-based variant you will need those FreeT-layers again
07:13:30 <aristid> mm_freak: well 90% of the time people don't use proxies
07:13:34 <aristid> they just use pipes
07:13:38 <mm_freak> i would note this as an interesting isomorphism
07:13:45 <aristid> so just having those would give a lot of composability already
07:14:12 <aristid> and when you start trying to do really fancy stuff like "i want to have a server-like thing that can have more than one action, with different response types"...
07:14:26 <aristid> then you need to roll your own free functor anyways, or write a functor transformer
07:15:23 <mm_freak> pipes could potentially become a library of predefined FreeT stuff =)
07:15:37 <aristid> it is already:)
07:15:39 <mm_freak> but then remember that we have RWST and people actually use it…
07:15:44 <mm_freak> for a reason even
07:16:03 <aristid> i sometimes wish there was a RWST with only like two of the three letters:D
07:16:37 <epsilonhalbe> hey I am using vim with haskellmode, can someone tell me how I call the documentation with that - :Doc head calls /usr/share/doc/ghc-doc/libraries/base/Prelude.html, but my base directory has a version number like base-4.6.0.1 (btw I am on a debian 7 installation)
07:16:45 <aristid> mm_freak: heh i wonder what happens when you make a FreeT (RWST ...)
07:16:55 <mm_freak> Server x y m a = ReaderT x (WriterT y m) a
07:16:59 <mm_freak> something like that? =)
07:17:26 <mm_freak> a FreeT over RWST would probably be an effectful, stateful pipe
07:17:45 <aristid> mm_freak: no, Server has request and response, so there needs to be some kind of sum in there
07:18:07 <mm_freak> a power
07:18:13 <mm_freak> X -> m (a, Y)
07:19:26 <aristid> mm_freak: oh you're right, Server doesn't use the Sum
07:20:40 <aristid> it only uses Pipes.Internal.Respond b (b' -> Proxy a' a b' b m r)
07:20:52 <aristid> which is like ReaderT . WriterT i suppose
07:20:55 <mm_freak> aristid: i'm not really talking about Server as in pipes
07:21:02 <mm_freak> i just named it Server =)
07:21:10 <mm_freak> because you complained that there are no two-letter RWSTs =P
07:21:16 <aristid> oh
07:21:20 <aristid> heh
07:21:44 <aristid> mm_freak: if you close off one of the components of RWST you get just that i guess:D
07:22:29 <mm_freak> and no, Server in pipes is not like ReaderT . WriterT
07:22:42 <mm_freak> or is it?
07:22:49 <mm_freak> well, i suppose it is
07:22:51 <aristid> maybe the other way around
07:22:53 <aristid> not sure
07:22:57 <mm_freak> doesn't matter
07:23:02 <mm_freak> same result
07:37:56 * hackagebot snaplet-fay 0.3.3.4 - Fay integration for Snap with request- and pre-compilation.  http://hackage.haskell.org/package/snaplet-fay-0.3.3.4 (AdamBergmark)
07:48:03 <Platz> @type isSpace || isPunctuation
07:48:04 <lambdabot>     Couldn't match expected type `Bool' with actual type `Char -> Bool'
07:48:05 <lambdabot>     In the first argument of `(||)', namely `isSpace'
07:48:05 <lambdabot>     In the expression: isSpace || isPunctuation
07:49:14 <Platz> @type liftM2 (||) isSpace isPunctuation
07:49:15 <lambdabot> Char -> Bool
07:50:06 <Flonk> > True <> True
07:50:07 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Bool)
07:50:07 <lambdabot>    arising from a use of `Data.Monoid.<>'
07:50:07 <lambdabot>  Possible fix:
07:50:07 <lambdabot>    add an instance declaration for (Data.Monoid.Monoid GHC.Types.Bool)
07:50:48 <manek> Hello! Does anybody know how we can compile package with --enable-tests if it is added to cabal sandbox using "add-source"?
07:58:53 <lingxiao> does someone know how to change associativeity of value constructor?
07:59:27 <lingxiao> for example Stuff = A | Stuff :-> Stuff forms:  (A :-> A) :-> A
07:59:36 <lingxiao> but I want A :-> (A :-> A)
08:00:34 <mm_freak> lingxiao: infixr
08:01:09 <lingxiao> ahh didn't know you could use that for value constructors as well
08:01:18 <lingxiao> pretty sweet, I guess they are just functions
08:01:24 <mm_freak> they are
08:01:27 <catalyst> :-> seems like quite a happy operator
08:01:43 <mm_freak> (:->) :: Stuff -> Stuff -> Stuff
08:15:39 <lingxiao> haha then its deconstructor twin should be :-<
08:16:12 <lingxiao> uh what's a good function that drops the first elements of a list by another list ?
08:16:21 <lingxiao> so func [1,2,3] [1,2] = [3]
08:16:34 <quchen> zipRest?
08:16:54 <lingxiao> is it in Data.List?
08:16:55 <supki> > stripPrefix [1,2] [1,2,3]
08:16:56 <lambdabot>  Just [3]
08:17:25 <lingxiao> Perfect!
08:27:33 <AncientPC> I realize there's a type signature mismatch, but I'm not sure how to fix this: zip $ unzip $ zip [1,2,3] [4,5,6]
08:28:10 <Maior> :t zip
08:28:11 <lambdabot> [a] -> [b] -> [(a, b)]
08:28:14 <Maior> :t unzio
08:28:15 <lambdabot>     Not in scope: `unzio'
08:28:15 <lambdabot>     Perhaps you meant one of these:
08:28:15 <lambdabot>       `unzip' (imported from Data.List),
08:28:19 <Maior> :t unzip
08:28:19 <lambdabot> [(a, b)] -> ([a], [b])
08:28:32 <Maior> :t uncurry
08:28:32 <lambdabot> (a -> b -> c) -> (a, b) -> c
08:28:34 <Maior> AncientPC: &
08:28:36 <Maior> er, ^
08:28:40 <AncientPC> Maior: right, I know that. How do I convert ([a], [b]) -> [a] -> [b]
08:29:10 <Maior> AncientPC: with uncurry
08:29:36 <Maior> > zip $ uncurry $ unzip $ zip [1,2,3] [4,5,6]
08:29:37 <lambdabot>  Couldn't match expected type `a1 -> b0 -> c0'
08:29:38 <lambdabot>              with actual type `([a2], [b1])'Couldn't match expected type `[a0]'
08:29:38 <lambdabot>              with actual type `(a1, b0) -> c0'
08:29:41 <rtpg> wait does that type even make sense?
08:29:47 <Maior> oops
08:29:53 <rtpg> a pair of lists to a function taking one list and returning another?
08:30:00 <Maior> > unzip $ zip [1,2,3] [4,5,6]
08:30:02 <lambdabot>  ([1,2,3],[4,5,6])
08:30:40 <AncientPC> rtpg: I'm trying to take a tuple of 3 lists and iterate through two of them without affecting the 3rd
08:30:49 <AncientPC> I'm not sure of the best way of doing so
08:30:49 <Maior> > uncurry zip $ unzip $ zip [1,2,3] [4,5,6]
08:30:50 <lambdabot>  [(1,4),(2,5),(3,6)]
08:30:55 <AncientPC> so I'm unzipping and rezipping
08:31:14 <c_wraith> AncientPC: in haskell?  How are you going to affect the 3rd?
08:32:34 <rtpg> wait is this a tuple of lists or a list of tuples?
08:33:33 <AncientPC> An example: (([1,2,3,4],[a,b,c,d]), [2,4]), the first list is key, second is value, third list are keys I want
08:34:15 <rtpg> so you want to get something like [(2,b),(4,d)], right?
08:34:19 <AncientPC> so far I've been using: (zip xs ys) !! head is
08:34:21 <AncientPC> rtpg: yes
08:34:35 <AncientPC> but that gets inefficient since I'm working with infinite lists
08:35:00 <rtpg> are you sure about the third list being sorted?
08:35:00 <AncientPC> do now I'm trying some variation of dropWhile and zip / unzip
08:35:06 <rtpg> or the first one even?
08:35:14 <AncientPC> they're guaranteed sorted
08:35:19 <mm_freak> let xs = zip ks vs in map (\k -> lookup k xs) ks
08:35:51 <mm_freak> if they're guaranteed to be sorted, you may want to use Data.Map with fromAscList
08:36:02 <eikke> Tekmo: you around?
08:36:15 <mm_freak> let xs = M.fromAscList (zip ks vs) in map (\k -> M.lookup k xs) ks
08:37:26 <AncientPC> mm_freak: k thx, lemme do some reading up
08:37:30 <quchen> mm_freak: fromList and fromAscList have almost identical performance I've heard
08:38:01 <mm_freak> quchen: can't confirm that
08:38:48 <mm_freak> it's not like fromAscList is much faster, but it's faster by a log factor
08:39:10 <quchen> Not even that, it seems. Hold on, let me find the chatlog
08:39:23 <c_wraith> mm_freak: if you're using a sufficiently new version, they're identical
08:39:34 <mm_freak> hmm, ok
08:39:39 <Cale> What?
08:39:45 <c_wraith> well, when the input is sorted
08:39:46 <mm_freak> why is that?
08:39:48 <quchen> http://ircbrowse.net/browse/haskell?id=17092710&timestamp=1387753814#t1387753814
08:39:53 <mm_freak> oh
08:40:12 <mm_freak> so it's not like fromAscList is faster, but fromList is just not slower for a sorted list =)
08:40:23 <quchen> Not much, no.
08:40:26 <tpsinnem> is there an explanation of what, in general one should expect to find under 'Control' and what under 'Data' in the standard libraries?
08:40:27 <Cale> If that's the case, then fromAscList should probably be removed.
08:40:33 <Cale> tpsinnem: no
08:40:53 <c_wraith> there is a constant factor difference, in that fromList does need to check for decreasing consecutive elements
08:40:57 <c_wraith> But that's pretty small
08:40:59 <Cale> tpsinnem: They're both big "Miscellaneous" drawers, lol.
08:41:02 <eikke> Tekmo: is there anything like '(s -> a -> (Bool, s)) -> Pipe a [a]' available, which 'combines' values given the predicate & state?
08:41:11 <quchen> c_wraith: That's O(n) difference isn't it
08:41:11 <tpsinnem> Cale: gah :)
08:41:27 <quchen> Oh, as a factor it's constant, sorry.
08:42:05 <Cale> tpsinnem: I have no idea why they were introduced in the first place. When all that stuff was at the top level, it's not like it was doing anyone any harm.
08:48:01 <mm_freak> eikke: not predefined
08:49:40 <mm_freak> eikke: also nowadays you probably want something like this:  (a -> s -> (Bool, s)) -> Producer a m r -> FreeT (Producer a m) m r
08:50:09 <aristid> mm_freak: "nowadays" as opposed to..?
08:50:19 <mm_freak> as opposed to "before pipes-parse" =)
08:50:29 <eikke> mm_freak: yeah, I figured that, but then I push knowledge of FreeT to my user
08:51:06 <mm_freak> reason:  the Pipe variant would interrupt the streaming and cause all effects and only yield when a full list is ready, which it doesn't know in advance, before the first non-matching item is actually available
08:51:18 <aristid> eikke: note that doing that as a Pipe would be impossible
08:51:41 <aristid> i think
08:51:53 <aristid> i'm not sure if i quite understand what the function would do exactly
08:51:56 <eikke> aristid: I fear so to, due to handling the 'last' part
08:52:02 <aristid> yes
08:52:07 <mm_freak> i understand it as a stateful groupBy
08:52:26 <mm_freak> <eikke> aristid: I fear so to, due to handling the 'last' part
08:52:32 <eikke> aristid: basically, given the state and an incoming value, group all values until the predicate returns 'False'
08:52:33 <mm_freak> that's exactly what i'm talking about
08:52:33 <aristid> as soon as you need to handle the "last element" specially in any way, pipe doesn't work :P
08:53:09 <eikke> mm_freak: it's something along the lines of stateful groupBy indeed
08:53:09 <mm_freak> as a FreeT splitter this should be fairly straightforward to write
08:53:52 <aristid> mm_freak: i found that sometimes it is easier to write a splitter as Pipe a (Bool, a) instead
08:54:00 <aristid> where the Bool indicates complete blocks
08:54:00 <mm_freak> when the predicate turns False, which element becomes the first in the second group?  the next True?  or is the next group everything that is False until the first True?
08:54:35 <mm_freak> aristid: that would be easier, but a lot more awkward to work with
08:54:53 <eikke> right, let me see whether I can get such stateful groupBy working
08:54:53 <aristid> mm_freak: i wrote a function to convert from that to a standard FreeT splitter:)
08:55:16 <mm_freak> aristid: ugh…  i'd just write the FreeT variant in the first place =)
08:55:30 <aristid> mm_freak: i'm not sure if you would in my case
08:55:36 <mm_freak> why?
08:55:48 <aristid> hmm i think i'll make the repo public and show you
08:55:58 <aristid> wait a minute, but beware the code is not cleaned up at all
08:56:01 <mm_freak> aristid: just give me the type signature
08:56:24 <aristid> mm_freak: meh it's just a splitter
08:56:33 <mm_freak> like my 'plines' above
08:56:36 <aristid> the type signature ain't telling you anything
08:57:20 <mm_freak> plines :: (Monad m) => Producer ByteString m r -> FreeT (Producer ByteString m) m r
08:57:25 <mm_freak> it's like 'lines', just 10x faster =)
08:58:03 * hackagebot heist-async 0.6.0.0 - Adding support for asynchronous updates ("AJAX") with heist  http://hackage.haskell.org/package/heist-async-0.6.0.0 (DanielPatterson)
08:58:30 <aristid> mm_freak: so this is the code: https://github.com/aristidb/datastorage/blob/master/RollingVector.hs#L91 in the slightly more generic version (which is also less tested)
08:59:46 <aristid> mm_freak: it's looking at the hash over a rolling window of say 256 bytes and takes a hash of that and if it fits a certain bitmask splits up the block... this is useful because this way blocks with the same content tend to persist even if you insert/delete data in the middle
09:00:20 <aristid> mm_freak: now doing this in a non-naive way is not entirely trivial, and i didn't find a good approach yet to doing this purely with FreeT
09:01:11 <eikke> mm_freak: actually, stateful splitOn is more what I want I guess
09:01:43 <mm_freak> eikke: then you could use aristid's freeIt in the code above
09:01:44 <aristid> mm_freak: feel free to believe that this is just because i don't understand FreeT well enough though :P
09:02:25 <aristid> btw. is the code readable at all?:D
09:02:27 <eikke> mm_freak: with a scan?
09:03:03 <mm_freak> aristid: i don't question anyone's abilities…  it may just be that you need to write more FreeT code =)
09:03:08 <mm_freak> at some point it just clicks
09:03:14 <mm_freak> and FreeT feels like []
09:03:29 <mm_freak> and yes, the code is readable
09:03:36 <mm_freak> eikke: something like that
09:03:47 <mm_freak> eikke: put a True everywhere where you want to split
09:03:52 <mm_freak> then freeIt
09:04:27 <eikke> on the other hand, I should be able to hack up stateGroupBy as well, as an exercise ;-)
09:04:39 <mm_freak> eikke: FreeT-based?
09:04:43 <eikke> uhu
09:04:51 <DexterLB> hello.. I want to generate all ascending partitions of a number (e.g. 3 = [[1, 1, 1], [1, 2], [3]])
09:04:52 <mm_freak> do it…  and be brave =)
09:05:04 <DexterLB> I wrote a simple recursive function that does it
09:05:16 <eikke> mm_freak: I'll expect a review later on ;-)
09:05:37 <DexterLB> http://lpaste.net/98768
09:05:38 <aristid> mm_freak: compare freeIt to listIt btw: https://github.com/aristidb/datastorage/blob/master/List.hs#L49
09:05:41 <mm_freak> eikke: if i'm still around, i'll be happy to =)
09:05:59 <DexterLB> any ideas how I can optimise this so it doesn't compute multiple times?
09:06:08 <aristid> well i guess the structure is actually pretty much the same
09:06:17 <nicoo> DexterLB: Data.MemoCombinator ?
09:06:47 <mm_freak> aristid: List's functor argument isn't really a functor there
09:07:10 <mm_freak> aristid: and yes, it's the same thing
09:07:32 <aristid> mm_freak: well it's a functor with a monad argument that can be ignored
09:07:43 <aristid> mm_freak: it's Tekmo's old List
09:07:48 <aristid> he changed it since then:)
09:08:48 <DexterLB> nicoo: how do I use that for a function that's Int -> Int -> [[Int]]? Sorry, I'm a confused
09:12:20 <nicoo> DexterLB: This should do the trick : http://bpaste.net/show/169817/
09:12:36 <nicoo> Basically, you use the memo2 combinator to combine 2 other Memos
09:12:45 <nicoo> (namely, integral and integral)
09:13:05 <nicoo> DexterLB: Didn't test it, though (Data.MemoCombinators isn't installed here)
09:13:16 <DexterLB> nicoo: ahh, I get it! thanks
09:18:00 <zerokarmaleft> fairly new to Haskell here and trying to get a handle on transformers from http://en.wikibooks.org/wiki/Haskell/Monad_transformers...how are you supposed to end up calling askPassword?
09:18:36 <zerokarmaleft> which returns MaybeT IO ()
09:19:47 <hpc> zerokarmaleft: something like
09:19:52 <hpc> doStuff :: IO ()
09:20:00 <hpc> doStuff = runMaybeT $ do
09:20:03 <hpc>   askPassword
09:20:05 <hpc>   otherStuff
09:20:07 <hpc>   ...
09:20:24 <mm_freak> hpc: that's a type error
09:20:33 <hpc> doh, it is
09:20:38 <hpc> doStuff :: IO (Maybe ())
09:20:47 <hpc> zerokarmaleft: ^
09:20:55 <hpc> :t runMaybeT
09:20:56 <lambdabot> Not in scope: `runMaybeT'
09:20:59 <mm_freak> zerokarmaleft: newtype MaybeT m a = MaybeT (m (Maybe a))
09:21:12 <mm_freak> zerokarmaleft: so a MaybeT IO X is really the same as IO (Maybe X)
09:21:20 <mm_freak> and the runMaybeT function gives you exactly that
09:21:37 <mm_freak> runMaybeT :: MaybeT m a -> m (Maybe a)
09:23:56 <mm_freak> @karma zerokarmaleft
09:23:56 <lambdabot> zerokarmaleft has a karma of 0
09:24:00 <mm_freak> hehe
09:24:12 <zerokarmaleft> all is well with the universe :)
09:24:38 <DexterLB> nicoo: but it is slower than the original :D
09:25:05 <zerokarmaleft> hpc, mm_freak: thanks, I was mentally reserving run...T as simply something necessary for implementing >>=
09:25:30 <mm_freak> zerokarmaleft: in fact runMaybeT has nothing to do with (>>=) =)
09:25:45 <mm_freak> runMaybeT is actually just a field accessor
09:25:59 <mm_freak> newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
09:27:37 <mm_freak> you compose MaybeTs until you have built a computation you want to perform (using (>>=), (<|>), etc.), then you just extract the underlying m (Maybe a) by using runMaybeT
09:27:40 <zerokarmaleft> so it unwraps m (Maybe a) from MaybeT m a?
09:27:42 <nicoo> DexterLB: Oops
09:27:46 <mm_freak> zerokarmaleft: exactly
09:28:57 <Eduard_Munteanu> zerokarmaleft: (>>=) takes care of chaining the inner 'm (Maybe a)' computations under MaybeT.
09:29:27 <Eduard_Munteanu> I mean in the Monad instance for MaybeT.
09:29:35 <Eduard_Munteanu> Er, MaybeT m.
09:29:51 <mm_freak> the main difference between MaybeT IO X and IO (Maybe X) is this:  when you write "x <- c" and c :: MaybeT IO X, then x :: X…  when c :: IO (Maybe X), then x :: Maybe X
09:30:10 <mm_freak> so MaybeT handles failure implicitly
09:30:48 <hpc> specifically, it does what (>>=) would do for Maybe as well as IO
09:30:54 <hpc> as opposed to just IO
09:31:37 <Eduard_Munteanu> Also in  x <- MaybeT (c :: IO (Maybe X))  you have   x :: X, IOW you can use MaybeT to convert IO actions returning Maybe values to MaybeT IO actions.
09:32:06 <zerokarmaleft> so what if I want to pattern match on the inner Maybe value after accessing the inner m (Maybe a)?  or is that something I should be doing inside the MaybeTs?
09:32:35 <mm_freak> zerokarmaleft: runMaybeT c >>= maybe n j
09:32:48 <mm_freak> or:  do mx <- runMaybeT c; case mx of …
09:32:53 <nicoo> DexterLB: replacing concat $ map by concatMap is already a win
09:33:17 <hpc> i would rather replace it with join . fmap
09:33:22 <mm_freak> zerokarmaleft: if you want to get out of MaybeT just to return back in, note that there is also (<|>)
09:33:35 <DexterLB> nicoo: :P
09:33:35 <hpc> (but that's just because it's a more natural abstraction for [])
09:33:50 <mm_freak> zerokarmaleft: c1 <|> c2 is the MaybeT computation that either results in c1's result or on failure results in c2's result
09:33:55 <nicoo> DexterLB: Do you actually iterate over all decompositions, or are you looking for one which satisfies some criterion ?
09:34:23 <mm_freak> zerokarmaleft: it forms a monoid with the identity 'empty':  empty = MaybeT (return Nothing)
09:35:00 <b80905> what is wrong with this code let {divisors n = [k | k <- [1..n], n `mod` k == 0]} in [n*(n+1)/2 | n <- [1..], length (divisors (n*(n+1)/2)) > 500] !! 0 ?
09:35:40 <cmiller_> Good afternoon all I have a quick question on testing. I have C code that I'm calling through the FFI that takes a few Ptr's and returns an IO Float. If I want to test that IO Float, i.e. write a prop that given the function's result, returns a Bool, is there a standard way to do that?
09:36:03 <hpc> cmiller_: just Bool, or IO Bool?
09:36:24 <cmiller_> Well the QuickCheck framework (I think) requires Bool.
09:36:24 <Eduard_Munteanu> b80905: I don't know what it's supposed to do and what symptoms it shows, that's what's wrong so far. :)
09:36:51 <cmiller_> The C function is pure in the contents of the Ptr's
09:36:55 <hpc> @check (> 5) . length <$> getLine
09:36:55 <lambdabot> Plugin `check' failed with: Ambiguous infix expression
09:37:01 <b80905> Eduard_Munteanu: the code is supposed to solve https://projecteuler.net/problem=12
09:37:03 <hpc> @check ((> 5) . length) <$> getLine
09:37:04 <lambdabot>  No instance for (Test.QuickCheck.Property.Testable
09:37:05 <lambdabot>  (GHC.Types.IO GHC.Types.Bool)) arising from a use of `Lambdabot.Plugin.Haske...
09:37:06 <cmiller_> Right now I'm doing unsafePerformIO
09:37:11 <hpc> :( it does have to be Bool
09:37:13 <mm_freak> cmiller_: dereferencing is impure
09:37:24 <zerokarmaleft> cool, thanks all...I'll play around with it a bit more
09:37:36 <mm_freak> zerokarmaleft: have fun =)
09:37:59 <hpc> yeah, your function can't be made pure, no quickcheck for you :(
09:38:10 <mm_freak> cmiller_: for testing IO code you can use HUnit
09:38:23 <mm_freak> instead of QuickCheck
09:38:31 <hpc> cmiller_: or you can make the interesting parts of your function pure and check those
09:38:45 <jmcarthur> cmiller_: there's http://hackage.haskell.org/package/QuickCheck-2.6/docs/Test-QuickCheck-Monadic.html , although it looks fishy to me
09:38:55 <hpc> which may or may not be appropriate for the body of your function
09:39:04 <AncientPC> How can I convert a list of indices into a list of their index locations? e.g. [2,4] -> [0,0,2,0,4]
09:39:06 <jmcarthur> cmiller_: i would recommend splitting out the pure stuff you want to check from the IO stuff that is irrelevant, if possible
09:39:17 <Eduard_Munteanu> b80905: you haven't mentioned what the failure mode is... I suspect it's a stack overflow but I shouldn't guess.
09:39:22 <mm_freak> AncientPC: write a recursive function
09:39:30 <jmcarthur> cmiller_: if you're up for it, you could even define your own monad with both pure and IO interpretations, and check your code with the pure interpretation
09:39:44 <mm_freak> AncientPC: you may want to require the argument list to be sorted, otherwise this function is going to be very slow
09:39:49 <cmiller_> yeah that sounds like a lot of effort :)
09:39:51 <mm_freak> AncientPC: ideally however you don't want a list
09:39:58 <AncientPC> mm_freak: it is sorted, but why wouldn't I want a list?
09:40:09 <b80905> Eduard_Munteanu: this is what the error message begins with: "    Ambiguous type variable `a0' in the constraints:..."
09:40:14 <mm_freak> AncientPC: this sounds more like an array operation to me…  i could be wrong =)
09:40:26 <cmiller_> Well thanks all I've got a lot to think about.
09:40:31 <mm_freak> AncientPC: depends on the use case of course
09:40:31 <hpc> AncientPC: this sounds like a much smaller part of a problem that could be solved elegantly in another way
09:40:37 <hpc> AncientPC: or homework :P
09:40:39 <b80905> :t let {divisors n = [k | k <- [1..n], n `mod` k == 0]} in [n*(n+1)/2 | n <- [1..], length (divisors (n*(n+1)/2)) > 500] !! 0
09:40:41 <lambdabot> (Fractional a, Integral a) => a
09:40:44 <nicoo> mm_freak: It is doable with a list. Just not very compact
09:40:52 <jmcarthur> cmiller_: it's not necessarily a lot of effort
09:40:59 <hpc> perhaps you could give us some context, why you need such a function?
09:40:59 <AncientPC> hpc: it's a subset of homework. I solved it using !! to look up indices on an infinite list but want to improve it.
09:41:05 <hpc> ah
09:41:16 <mm_freak> nicoo: it can be compact, but that would be a slow one =)
09:41:17 <jmcarthur> cmiller_: sometimes it's even worth it without the testing. it means you can define a more specialized DSL for your problem anyway
09:41:31 <nicoo> mm_freak: s/slow/slooooooooow/
09:41:34 <Eduard_Munteanu> b80905: pastebin all of it
09:41:51 <mm_freak> > let xs = [2,4] in map (\i -> if elem i xs then i else 0) [0..]
09:41:52 <lambdabot>  [0,0,2,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:41:53 <Eduard_Munteanu> > let {divisors n = [k | k <- [1..n], n `mod` k == 0]} in [n*(n+1)/2 | n <- [1..], length (divisors (n*(n+1)/2)) > 500] !! 0
09:41:55 <lambdabot>  No instance for (GHC.Show.Show a0)
09:41:56 <lambdabot>    arising from a use of `M59328411548002675928105.show_M59328411548002675928...
09:41:56 <lambdabot>  The type variable `a0' is ambiguous
09:41:56 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:41:56 <lambdabot>  Note: there are several potential instances:
09:41:56 <hpc> > (\xs -> map (\x -> if x `elem` xs then x else 0) [0..]) [2, 4]
09:41:57 <lambdabot>  [0,0,2,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:42:00 <cmiller_> Yeah basically this whole thing is just wrappers around a bunch of C functions that are for sure correct. I guess the test is only for my own check that I'm using the FFI Correctly.
09:42:07 <hpc> mm_freak: oh you
09:42:11 <mm_freak> hpc: =P
09:42:12 <AncientPC> lol mm_freak
09:42:17 <b80905> Eduard_Munteanu: http://paste.ubuntu.com/6781226/
09:42:22 <rajeshsr> can anyone recommend a good source to try out group theory with haskell?
09:42:27 <AncientPC> hpc: to do `foo !! 99` and `foo !! 100` I have to generate a lot of redundant computations so I'm trying to avoid that.
09:42:33 <mm_freak> rajeshsr: Data.Monoid =)
09:42:51 <mm_freak> it's in your base library and used almost everywhere
09:43:06 <cmiller_> "Monoids: An algebraic structure only a mother could love"
09:43:19 <rajeshsr> mm_freak, ha, ok! thanks is there some blog or wiki on it?
09:43:28 <mm_freak> rajeshsr: tons
09:43:32 <merijn> Everybody Loves Monoids! (This would be a much more amusing sitcom)
09:43:45 <Eduard_Munteanu> b80905: oh... you shouldn't be using (/) there, use div
09:43:50 <Eduard_Munteanu> :t (/)
09:43:52 <lambdabot> Fractional a => a -> a -> a
09:43:55 <Eduard_Munteanu> :t div
09:44:01 <lambdabot> Integral a => a -> a -> a
09:44:02 <cmiller_> mm_freak: can you clarify what you mean by "try" group theory?
09:44:02 <hpc> > let xs = S.fromList [2, 4] in map (\i -> if S.member i xs then i else 0) [0..] -- AncientPC maybe this? O(nlogn) instead of n**2
09:44:03 <lambdabot>  [0,0,2,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:44:06 <mm_freak> rajeshsr: Monoid is basically a sensible ICombinable =)
09:44:20 <mm_freak> cmiller_: you have to ask rajeshsr there =)
09:44:26 <AncientPC> hpc, mm_freak: that works but [2,4] is a placeholder for yet another infinite list. I'm trying to avoid !! lookups on both sides. xD
09:44:31 <cmiller_> my bad.
09:44:37 <hpc> oh, hmm
09:44:44 <rajeshsr> cmiller_, well, try out == as a proof system?
09:44:48 <AncientPC> I think recursive solution is way to go
09:44:52 <hpc> yeah
09:44:54 <hpc> something like
09:44:55 <merijn> AncientPC: Is the input list sorted?
09:45:00 <AncientPC> it is
09:45:01 <merijn> If so you can get O(n)
09:45:05 <hpc> foo (x:xs) (y:ys) | x < y = ...
09:45:18 <hpc> and then pass [0..] as one of the params
09:45:34 <Eduard_Munteanu> > let {divisors n = [k | k <- [1..n], n `mod` k == 0]} in [n*(n+1) `div` 2 | n <- [1..], length (divisors (n*(n+1) `div` 2)) > 500] !! 0
09:45:38 <lambdabot>  mueval-core: Time limit exceeded
09:45:54 <Eduard_Munteanu> Well, it typechecks. :P
09:46:01 <cmiller_> rajeshsr: Like check that certain identities are valid within a given group?
09:46:05 <merijn> I don't suppose there's a way to have code blocks in a literate haskell file that are ignored by the compiler?
09:46:05 <hpc> AncientPC: since it's homework and this is a pretty good exercise and it's the weekend for me, i won't solve it completely for you ;)
09:46:16 <AncientPC> hpc: thanks for the help. it's enough. :D
09:46:52 <jmcarthur> merijn: you could just indent that code instead of putting > in front of it
09:46:55 <merijn> Or, alternatively, how many bad things will happen if I hide Functor/Monad from prelude?
09:47:20 <rajeshsr> cmiller_, yep! i am trying to start learn computer based proofs and my understanding was haskell enables it, though i have no idea about how to do it. I hav ealso seen coq mentioned predominantly about it. But wanted to explore haskell first..
09:47:26 <Eduard_Munteanu> b80905: you need to rethink it a bit to stop it from blowing the stack
09:47:54 <merijn> jmcarthur: I'm using hakyll to generate HTML from my lhs, it highlights code blocks with syntax highlighting, but I want to include the definitions of Functor/Monad and some other stuff in there
09:47:58 <jmcarthur> rajeshsr: there are many languages that are better for this than haskell, but haskell is a good middle ground between being a practical languages and making code easier to prove correct
09:48:19 <merijn> jmcarthur: So if I don't mark it as code, no highlighting, if I do mark it as code the file itself can't be compiled
09:48:33 <merijn> Unless I hide Functor/Monad from Prelude and define my own, I guess
09:48:53 <rajeshsr> jmcarthur, hmm! What else apart from Haskell and Coq?
09:48:56 <jmcarthur> merijn: ah. with pandoc's markdown+lhs mode, you can distinguish between > haskell code and benign code blocks. not sure if hakyll has something similar. (maybe it even uses pandoc? never looked into it)
09:49:24 <Eduard_Munteanu> rajeshsr: Haskell only lets you get *some* static assurances, it's definitely not as expressive as Coq or Agda.
09:49:26 <rajeshsr> As far Haskell, i am not really finding much interesting things on it when i google about it! :) jmcarthur, cmiller_
09:49:48 <merijn> jmcarthur: I use rST
09:49:50 <jmcarthur> rajeshsr: i really like agda. there's also idris, which i haven't tried yet. the latter is supposedly more practical and haskell-like.
09:49:52 <rajeshsr> Eduard_Munteanu, hmm! so better start with Coq itself?
09:49:52 <hpc> jmcarthur: obviously what you do is you take every combination of haskell and documentation code, and see which ones compile
09:49:53 <Eduard_Munteanu> rajeshsr: look into Agda if you want something inspired from Haskell
09:49:55 <cmiller_> rajeshsr: That sounds interesting but I know nothing about compute assisted proofs except for the popular story on the four color therorem.
09:50:03 <merijn> jmcarthur: (hakyll does use pandoc)
09:50:04 <hpc> sure it takes a few thousand iterations, but ...
09:50:27 <cmiller_> rajeshsr: So.. GOOD LUCK!
09:50:28 <mm_freak> > foldr (zipWith (+)) (repeat 0) . map (\i -> replicate i 0 ++ [i] ++ repeat 0) $ [2,4]
09:50:29 <lambdabot>  [0,0,2,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:50:41 <mm_freak> > foldr (zipWith (+)) (repeat 0) . map (\i -> replicate i 0 ++ [i] ++ repeat 0) $ [3,7..]
09:50:42 <lambdabot>  *Exception: stack overflow
09:50:43 <rajeshsr> cmiller_, thanks! :)
09:50:46 <mm_freak> too bad
09:50:48 <tristan__> copumpkin: https://gist.github.com/tsloughter/8508350
09:51:05 <Eduard_Munteanu> rajeshsr: depends on your background and your goals really, e.g. whether you're comfortable with pure languages, whether you prefer writing code vs proving theorems...
09:51:14 <cmiller_> You should just write a list comprehension that outputs all valid proofs. Eventually you ought to get to group theory.
09:51:19 <tristan__> horrific error: https://gist.github.com/tsloughter/8508187
09:51:21 <jmcarthur> merijn: with the markdown mode i use so-called "fenced" code blocks for the benign code and the usual bird notation for real code
09:51:26 <cmiller_> Might take a million years though.
09:51:39 <copumpkin> tristan__: nothing is constraining the type of exception you get
09:51:44 <rajeshsr> Eduard_Munteanu, well, the goal here is t develop better nsights into the proof itself
09:51:55 <Eduard_Munteanu> cmiller_: some call that "eventually" :P
09:52:12 <hpc> mm_freak: oh god, folding over a list-of-lists - my feeble brain cannot comprehend
09:52:17 <cmiller_> Yeah Mathematicians :)
09:52:26 <Eduard_Munteanu> rajeshsr: what would you like to prove, can you give an example?
09:52:28 <rajeshsr> For instance, trying to prove Langarnge's theorem with a Computer, can help me better appreciate the nuances and assumptions, which i will hav eotherwise missed when proving in natural language..
09:52:32 <copumpkin> tristan__: example in here has an explicit type annotation: http://stackoverflow.com/questions/6009384/exception-handling-in-haskell
09:52:34 <tristan__> copumpkin: oh, shit, I think I know
09:52:46 <Eduard_Munteanu> rajeshsr: which Lagrange theorem?
09:52:49 <copumpkin> as soon as you lock down the type that way it'll be fine
09:52:57 <quchen> That's not even true, because to check whether a proof is in the list you'd have to provide a membership checking function for a proof, which is uncomputable.
09:52:58 <rajeshsr> Eduard_Munteanu, may be my expectation is totally ridiculous! :)
09:52:59 <tristan__> SON OF A
09:53:10 <Eduard_Munteanu> rajeshsr: the calculus one is non-constructive, mind
09:53:21 <tristan__> copumpkin: haha, yup, this is the difference https://github.com/pubnub/haskell/blob/master/src/Network/Pubnub.hs#L96
09:53:23 <rajeshsr> Eduard_Munteanu, http://en.wikipedia.org/wiki/Lagrange's_theorem_(group_theory)
09:53:24 <tristan__> :)
09:53:29 <Eduard_Munteanu> Ah.
09:53:32 <mm_freak> hpc: i didn't really think of it like that =)
09:53:40 <tristan__> so that is why subscirbe' does constrain the type
09:53:57 <tristan__> copumpkin: thanks :)
09:54:11 <mm_freak> hpc: if you look at something as [[[[[[[[X]]]]]]]], your brain will explode
09:54:22 <mm_freak> hpc: but i really looked at it like [F X]
09:54:24 <Eduard_Munteanu> rajeshsr: yeah, that sounds reasonable at first sight.
09:54:35 <mm_freak> and then folding over it makes a lot of sense =)
09:54:59 <rajeshsr> Eduard_Munteanu, hmm!
09:55:18 <magicman> This just in: Data.List.Split is amazing, and I don't know how I ever lived without it.
09:55:20 <hpc> mm_freak: mostly i just don't have the brain for explicit folding
09:55:45 <Eduard_Munteanu> rajeshsr: Coq likely has a lot more math stuff like that. Agda rather aims to be a reasonable programming language as well as a theorem prover.
09:56:15 <cmiller_> quchen: This is far from my area but proof verification is undecidable?
09:56:18 <Eduard_Munteanu> And it's younger and less well known than Coq.
09:56:25 <Eduard_Munteanu> At least in math circles.
09:56:43 <rajeshsr> Eduard_Munteanu, oh, thanks!
09:57:13 <quchen> cmiller_: No, the membership test itself: sure you can write down all well-formed mathematical proofs and aggregate them in a list, but you cannot in general check whether a proof you have is valid by looking at that list: if it's invalid, your lookup won't terminate.
09:57:45 <quchen> Or in other words, Gödel spoils the day once again
09:58:52 <hpc> quchen: you can't order the proofs in such a way that you can say "this proof is at most this far into the list"
09:58:55 <hpc> ?
09:59:08 <cmiller_> Ok that's inline with what I thought. But all of group theory should be in that list at some point.
09:59:25 <cmiller_> But I agree, given a proof and that list you cant check validity.
09:59:36 <hpc> oh no, you can't
09:59:47 <hpc> by the same logic as enumerating the reals
10:00:18 <Eduard_Munteanu> You can order proofs by some notion of size in some language, I think.
10:00:46 <cmiller_> This chat room has been nerd-sniped.
10:00:55 <hpc> well, it also depends on your idea of "well-formed" proofs
10:01:16 <hpc> if you admit only constructive proofs, it is quite trivial to verify the proof by typechecking it or something
10:01:58 <hpc> you have to admit non-constructive proofs for it to be interesting, because then you can't skip the list by just solving the proof twice
10:02:08 <monochrom> "\x y -> does x prove y?" is very different from "\y -> is y provable?"
10:02:09 <Eduard_Munteanu> Also if your theorem is coinductive in the result type, you can probably get "arbitrarily close" to proving it. :P
10:02:14 <copumpkin> tristan__: np :)
10:02:32 <hpc> sigfpe has a neat post on provability
10:02:35 <monochrom> "\x y -> does x prove y?" is clearly decidable in linear time
10:02:40 <quchen> Eduard_Munteanu: I have a nice proof of this theorem, unfortunately this epsilon neighbourhood is too small to contain it
10:02:49 <Eduard_Munteanu> Hehe.
10:03:03 <hpc> well, series of posts
10:04:14 <quchen> monochrom: Yes. But given a predicate, looking up a proof that proves it in the infinite list of well-formed proofs won't necessarily terminate.
10:04:23 <monochrom> that is right
10:04:24 <quchen> I think that's what I meant.
10:04:45 <hpc> cmiller_: i think we got meta-nerd-sniped
10:04:48 <monochrom> but "proof verification" refers to "\x y -> does x prove y?"
10:04:57 * Eduard_Munteanu wonders what theorems are provable in transfinite time :D
10:04:59 <hpc> cmiller_: not just "prove this interesting problem" but "is this interesting problem provable"
10:05:31 * hpc imagines computations performing in multiple dimensions of time
10:05:38 * quchen wants an oracle machine so he can finally prove everything!  (Don't even think about commenting on this.)
10:06:00 <hpc> quchen: i can use your oracle machine to prove that your oracle machine doesn't exist!
10:06:05 <Eduard_Munteanu> Yikes, multidimensional time is really weird.
10:06:12 <monochrom> I have a machine that can prove everything! but it is not very useful.
10:06:26 <quchen> Falso? :-)
10:06:55 <monochrom> even better: http://www.vex.net/~trebla/humour/lmcify.html
10:06:56 <hpc> @faq can haskell prove all theorems?
10:06:57 <lambdabot> The answer is: Yes! Haskell can do that.
10:07:15 <Guest800> I have a recursive function that has an otherwise that wants to call itself twice in recursion, is that possible? myfunction | otherwise = myfunction(); myfunction();
10:07:27 <monochrom> "javascript can prove everything!" :)
10:07:38 <hpc> oh wow, i have been trying to find lmcify again for literally two years
10:08:05 <quchen> monochrom: I know it's a joke, but I wonder how far you can take that. Make a nice UI with JS animations and see how you *own* Reddit afterwards.
10:08:11 <mauke> Guest800: what do you want to do with the results?
10:08:22 <Eduard_Munteanu> monochrom: in addition to a permalink you should make it generate bibtex citations :P
10:08:28 <hpc> Guest800: that looks suspiciously not-haskell
10:08:31 <magicman> Is there a SHA-1 implementation using crypto-api?
10:08:59 <monochrom> the hard part is stuffing the page with fake contents so the page looks more non-trivial
10:09:32 <Guest800> ok :(
10:09:40 <mauke> Guest800: hello?
10:09:45 <Guest800> let met copy the code to lpaste
10:09:49 <Guest800> then ill show u
10:10:14 <monochrom> "| otherwise = myfunction (n-1) + myfunction (n-2)" is certainly pretty common
10:10:25 <Eduard_Munteanu> Perhaps add it as a repository to an eventual Hoogle Scholar page. :P
10:10:28 <AncientPC> hpc: Sorry to bother you, but I've been stuck on this for a while. How do I pad 0's without incrementing counter?
10:10:34 <AncientPC> hpc: let padList (t:ts) | fst t == snd t = t : padList ts | otherwise = (fst t, 0) : padList ts
10:10:56 <mauke> that looks like a type error
10:11:13 <mauke> oh, no
10:11:33 <mauke> just a weird use of fst/snd
10:11:47 <mzero> AncientPC: is that your desired function - or just an intermediate along the way
10:11:53 <AncientPC> mzero: intermediate
10:12:19 <mzero> so, your aim is to prepend zeros to a list of numbers so that the list has n elements total?
10:12:42 <AncientPC> padList [2,4] [0..] would result in [0,0,2,0,4]
10:12:59 <Eduard_Munteanu> AncientPC: map (\x -> if x `elem` ys then x else 0) [0..] ?
10:13:03 <AncientPC> (keeping in mind that [2,4] is another infinite list, hence not using `elem`)
10:13:32 <mzero> I'm sorry, why would padList [2,4] [0..] result in 5 elements of output?
10:13:47 <AncientPC> mzero: It's mapping indices to their appropriate location within a single list
10:14:04 <mmmm> What is the goal of your overall program AncientPC
10:14:05 <mauke> AncientPC: your example is ambiguous
10:14:19 <zett_zelett> With this: http://lpaste.net/98769 I get io.reverseline.hs:8:4: parse error on input `main' – but I don’t understand why.
10:14:22 <Guest800> here it is: http://lpaste.net/98770, im trying to create a remove function for my binary tree
10:14:22 <mzero> now I'm totally confused - that isn't a common definition of "pad"
10:14:24 <erisco> AncientPC, is the list in place of [2,4] always sorted?
10:14:29 <AncientPC> erisco: yes
10:14:51 <AncientPC> I basically want to turn a list of indices into a list where the indices are at their location, and 0 otherwise
10:14:54 <erisco> AncientPC, interesting problem. where are you stuck exactly? (sorry for jumping in late)
10:15:15 <mzero> I see - what you are after is "gournding" a list - that is selecting elements from a list by ordered indicies, but inserting a zero where an index wasn't selected
10:15:17 <AncientPC> so the list of indices comes from a computationally expensive infinite list, hence avoiding `elem`
10:15:24 <mauke> Guest800: first you need to figure out what you want to do
10:15:36 <mzero> er "grounding" as in shorting some elements to zero
10:15:47 <mmmm> How do you use this padded list?
10:15:50 <AncientPC> mzero: yes, sorry never heard of grounding 0 before
10:15:51 <Guest800> mauke: remove a node from my binary tree
10:16:00 <mauke> Guest800: what exactly does that mean, though?
10:16:12 <mzero> well, I just coined the term --- since padding usually means to add elements to fill up to a fixed size
10:16:21 <Guest800> the remove function returns the tree without the value n
10:16:27 <AncientPC> mmmm: I'm then zipping the new indices list with another infinite list and filtering where they match
10:16:33 <mauke> Guest800: e.g. what's remove 2 (Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf))?
10:16:34 <Guest800> if the tree does not contain the value n, then return the original tree
10:16:53 <AncientPC> basically I want a bunch of random indices from another infinite list, but avoiding !!
10:17:07 <mzero> got it
10:17:11 <zett_zelett> Anyone heard me? : – (
10:17:12 <mzero> that now makes sense
10:17:15 <erisco> AncientPC, the indices are ordered as well?
10:17:18 <AncientPC> erisco: yes
10:17:28 <zett_zelett> http://lpaste.net/98769 I get io.reverseline.hs:8:4: parse error on input `main' – why?
10:17:30 <mmmm> So you want to select elements [2,4] from another list? in the final program
10:17:30 <AncientPC> so my idea was to ground a list, use zip3 and compare and filter
10:17:35 <Guest800> i think i figured out most of it, but this is the part where i get stuck -> " | otherwise = (remove n left) (remove n right)" i need to continue to build the tree, skipping the value n
10:17:36 <AncientPC> mmmm: yes
10:17:39 <mauke> zett_zelett: random 'where' in the middle of your code
10:17:47 <mzero> zett_zelett: you can't have a where clause in the middle
10:18:06 <mauke> Guest800: what's the result of 'remove 2 (Node (Node Leaf 1 Leaf) 2 (Node Leaf 3 Leaf))'?
10:18:13 <zett_zelett> Ah!
10:18:13 <mzero> put it after line 8, indent it by 1 or 2 spaces
10:18:24 <Eduard_Munteanu> AncientPC: pad (x:xs) (y:ys) | x == y = y : pad xs ys | otherwise = 0 : pad (x:xs) ys    and figure out the other cases, assuming you use it like  pad [2,4..] [0..]
10:18:32 <mzero> AncientPC: you will ulitmately not be able to use zip -
10:18:40 <zett_zelett> mauke, mzero: Thanks!!
10:18:42 <mzero> because your two inputs aren't "lined up"
10:19:16 <mzero> so you need to "expand" the indicies one out some how - either as you process, or before you zip
10:19:47 <Guest800> the result should be Node Leaf 1 (Node Leaf 3)
10:20:08 <mzero> here's a crazy idea        selectAndGround z idxs xs = zipWith ($) (expand x idxs) xs
10:20:26 <AncientPC> mzero: so [2,4] -> [0,0,2,0,4]; zip3 [0..] ['a','b',...] [0,0,2,0,4] => return where first and third match (i.e. ['c', 'e'])
10:20:33 <mzero> where expand is going to convert      [2,4] into    [const 0, const 0, id, const 0, id]
10:20:36 <mauke> Guest800: what's the result of 'remove 2 (Node (Node Leaf 0 (Node Leaf 1 Leaf)) 2 (Node Leaf 3 Leaf))'?
10:21:33 <mzero> AncientPC: sure, but really it is bad to expand [2,4] -> [0,0,2,0,4]  because you are confusing two uses of Int - one as an index, and one as a indicator of "short to zero"
10:22:08 <AncientPC> mzero: hmm, it's the only idea I could think of. Before this I tried using dropWhile but got lost.
10:22:24 <mmmm> AmbientPC: Why not something like this http://lpaste.net/98771
10:22:25 <mzero> where as in my expand, where everything is converted to a function, there is no confusion
10:23:09 <AncientPC> thanks mzero and mmmm, more stuff to try and read up on. :P
10:23:26 <monochrom> if you use Int but 0 means two things, it's time to use Maybe Int
10:23:48 <mauke> monochrom: no, that's what -1 is for
10:23:59 <quchen> You monster
10:24:09 * mauke <- expert C programmer
10:24:21 <quchen> expert C programmer :: Monad m => m a?
10:24:25 <AncientPC> lol I can't tell if people are giving good advice or bad advice at this point. xD
10:24:26 <pranz> If you have dependent types, can a vector be a monad? I mean, "Vect i a" and "Vect j a" is different types right?
10:24:30 <pranz> so you can't join them?
10:24:43 <copumpkin> it can be a Monad if you hold the index constant
10:24:54 <monochrom> if it's good advice for C, it's bad advice for Haskell. and vice versa.
10:24:55 <mauke> Vect i would be the monad
10:25:04 <copumpkin> it can also be one in a different way if you broaden your definition of a monad
10:25:16 <mauke> but join fucks you up
10:25:23 <Guest800> (Node (Node Leaf 0 Leaf) 1 (Node Leaf 3 Leaf))
10:25:32 <pranz> How would you write general type classes that would broaden the moonad class?
10:25:48 <Guest800> mauke: took me a while :)
10:25:50 <pranz> and join over Vect i becomes Vect i^2
10:25:57 <copumpkin> pranz: you'd want a meaningful operation to perform on the index (like (*)) and a fancy notion of indexed monad
10:26:06 <copumpkin> pranz: not in the sense I'm talking about
10:26:14 <copumpkin> join over Vect i is still Vect i
10:26:21 <copumpkin> it takes the diagonal
10:26:30 <copumpkin> it's like the ZipList applicative if you're used to that
10:26:39 <copumpkin> except it supports a diagonal monad
10:26:47 <mauke> Guest800: could you describe (in english) how to get that result?
10:27:29 <copumpkin> pranz: in the sense that join on [[1,2,3],[4,5,6],[7,8,9]] is [1,5,9]
10:27:53 <pranz> oh
10:27:55 <erisco> AncientPC, sorry, so what is the list [0..] for?
10:28:09 <copumpkin> for what it's worth, you can also construct a Stream monad in the same way
10:28:32 <AncientPC> erisco: it's a list of indices to compare against with the new padded / grounded version
10:28:34 <Guest800> when you remove a node n, you can replace that node n with either its left or right node?
10:28:51 <mauke> Guest800: but that's not what's going on
10:29:03 <erisco> AncientPC, not sure I understand... so what is  padList [2,4] [1,2]  ?
10:29:29 <mauke> Guest800: the result of removing 2 from (Node (Node Leaf 0 (Node Leaf 1 Leaf)) 2 (Node Leaf 3 Leaf)) is neither Node Leaf 0 (Node Leaf 1 Leaf) nor Node Leaf 3 Leaf
10:29:40 <mauke> (those are the left/right subnodes)
10:30:13 <monochrom> this is why I never say "describe in English". they always screw that up.
10:30:32 <AncientPC> erisco: the end goal (in bastardized python): http://lpaste.net/9174023957840396288
10:31:18 <Guest800> when you replace node n with lets say the left node, then that left node should have the right node as well and one leaf
10:31:24 <Guest800> so you dont lose one branch
10:31:40 <mzero> > let expand = go [0..]; go _ [] = []; go (i:is) ks@(k:kt) | i == k = Just k : go is kt | otherwise = Nothing : go is ks in expand [2,4]
10:31:41 <lambdabot>  [Nothing,Nothing,Just 2,Nothing,Just 4]
10:31:50 <mzero> AncientPC: consider something like that
10:31:57 <AncientPC> erisco: Since I can't get O(1) lookup, I'm trying to do better than O(n^2) that I get with !!.
10:32:02 <Eduard_Munteanu> AncientPC: a list isn't proper for that algorithm
10:32:03 <mauke> Guest800: how do you combine the left/right nodes?
10:32:34 <AncientPC> Eduard_Munteanu: It's for a hw assignment that I've finished with !!. I'm trying to do better than O(n^2) as a self-learning exercise.
10:32:38 <mzero> Now each element in the list, corresponding 1:1 with the values you wish to pick, express clearly if you are to use the zero (if Nothing), or use the value)
10:32:39 <Eduard_Munteanu> AncientPC: you can use Set and you get O (log n) per element
10:32:58 <AncientPC> Eduard_Munteanu: I don't think can use set's with infinite lists.
10:33:11 <Eduard_Munteanu> Er, right, the first one is infinite too.
10:33:23 <Eduard_Munteanu> Seq then.
10:33:26 <erisco> AncientPC, okay so... you have a list of indices I, and a list of lists L, you want the list [L!!i | x <- I] ?
10:33:38 <erisco> sorry, [L !! i | i <- I ]
10:33:44 <AncientPC> erisco: yes
10:34:06 <AncientPC> my current implementation is map (\x -> xs || (fromInteger x)) is
10:34:08 <Eduard_Munteanu> Er, wait, Seq is strict too.
10:34:20 <AncientPC> !!, not ||
10:34:25 <erisco> AncientPC, are you unable to use a better structure for L than a list? you can get O(1) lookup in Haskell with a hash table, or a vector, for instance
10:34:57 <AncientPC> erisco: no, I'm being artificially restricted because both indices and values list are infinite.
10:35:01 <Eduard_Munteanu> AncientPC: is there a function that computes the lists?
10:35:15 <AncientPC> yes, they are an infinite list of primes and fibonacci numbers
10:35:15 <mzero> let's not prematurely optomize!
10:36:38 <mzero> The key here is expanding the list of indicies to select out to match 1:1 with the values to select from - hence the expand function above --- then the rest is a simple zip..... Once you wrap your head around the expand above, and get the function needed for the zip.....
10:36:43 <AncientPC> e.g. finding the 1000th and then the 1001th prime is expensive when you're recalculating 1-999th primes.
10:36:51 <mmmm> AncientPC: Is my solution not acceptable?
10:36:52 <mzero> .. there is a way to simplify them both -
10:37:03 <erisco> AncientPC, well, the nth fib number can be computed in logn time, so you might be better using the function directly (rather than a list of fib numbers)
10:37:16 <AncientPC> mmmm: I think it's fine. I'm still trying to understand it but was pinged for clarification.
10:37:30 <mzero> but you have to get a list that expresses, for each element in the list to be selected from, whether to select the element, or use zero
10:37:35 <mzero> oh - silly me
10:37:43 <mzero> just bool will work here too
10:38:10 <mzero> > let expand = go [0..]; go _ [] = []; go (i:is) ks@(k:kt) | i == k = True : go is kt | otherwise = False : go is ks in expand [2,4]
10:38:11 <lambdabot>  [False,False,True,False,True]
10:38:18 <AncientPC> I'm sorry guys, I gotta run and think about this some more. Thanks for the help everyone.
10:38:36 <erisco> AncientPC, you are aware of the closed form formula yes?
10:38:40 <Eduard_Munteanu> AncientPC: how do you compute the primes?
10:38:50 <Guest800> i remember something from theory, when you remove a node n, you take the left (rightmost node) and replace n with that node
10:39:12 <Guest800> or my memory is bad
10:39:49 <Eduard_Munteanu> AncientPC: if it's a straightforward test on [2..] you could generate all numbers and only tag them with False/True depending on their primality, or using Maybe.
10:40:49 <yitz> > let gaps xs@(x:_) = x : (zipWith (subtract . (+1)) <*> tail) xs; select p x = if p then x else 0; padList = zipWith select . (++ repeat False) . concatMap ((++[True]) . flip replicate False) . gaps in padList [2,4,6] [0..10]
10:40:50 <lambdabot>  [0,0,2,0,4,0,6,0,0,0,0]
10:42:08 <erisco> I think the padList function is useless for this problem but here is my explicit recursive version http://lpaste.net/98775
10:42:50 <yitz> > let gaps = (zipWith (subtract . (+1)) <*> tail) . (-1:); select p x = if p then x else 0; padList = zipWith select . (++ repeat False) . concatMap ((++[True]) . flip replicate False) . gaps in padList [2,4,6] [0..10]
10:42:51 <lambdabot>  [0,0,2,0,4,0,6,0,0,0,0]
10:43:02 <mm_freak> > let f i (x:xs) | i == x = x : f (succ i) xs | otherwise = 0 : f (succ i) xs in f [2,4,7]
10:43:03 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
10:43:04 <lambdabot>    arising from a use of `M30547574962076518718693.show_M30547574962076518718...
10:43:04 <lambdabot>  The type variable `t0' is ambiguous
10:43:04 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:43:04 <lambdabot>  Note: there are several potential instances:
10:43:13 <mm_freak> > let f i (x:xs) | i == x = x : f (succ i) xs | otherwise = 0 : f (succ i) xs in f 0 [2,4,7]
10:43:14 <lambdabot>  [0,0,0*Exception: <interactive>:3:5-75: Non-exhaustive patterns in function f
10:43:32 <mm_freak> > let f i (x:xs) | i == x = x : f (succ i) xs | otherwise = 0 : f (succ i) xs; f _ _ = repeat 0 in f 0 [2,4,7]
10:43:33 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
10:43:44 <mm_freak> > let f i (x:xs) | i == x = x : f (succ i) xs | otherwise = 0 : f (succ i) (x:xs); f _ _ = repeat 0 in f 0 [2,4,7]
10:43:45 <lambdabot>  [0,0,2,0,4,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
10:43:49 <mm_freak> finally…
10:44:18 <mzero> > let expand = go [0..]; go _ [] = []; go (i:is) ks@(k:kt) | i == k = id : go is kt | otherwise = const 0 : go is ks; padList is ks = zipWith($) (expand is) ks in padList [2,4,6] [0..10]
10:44:19 <lambdabot>  [0,0,2,0,4,0,6]
10:44:43 <mm_freak> funny how i can write pages of code in my editor and it works on the first try, but lambdabot tricks me even for one-liners
10:44:47 <tertl3_> what is a lense exactly?
10:45:00 <mauke> a misspelled lens?
10:45:06 <tertl3_> yes
10:45:11 <yitz> mm_freak: because you use real types in your editor
10:45:21 <tertl3_> what is it that a lens is?
10:45:26 <mzero> > let expand = go [0..]; go _ [] = []; go (i:is) ks@(k:kt) | i == k = id : go is kt | otherwise = const 0 : go is ks; padList is ks = zipWith($) (expand is) ks in padList [2,3,7,12] [100,200..]
10:45:27 <lambdabot>  [0,0,300,400,0,0,0,800,0,0,0,0,1300]
10:45:27 <mauke> tertl3_: a (functional) record element accessor
10:45:39 <mauke> tertl3_: i.e. it lets you read and write to an element of a bigger structure
10:45:49 <Eduard_Munteanu> Not necessarily element and not just accessor, I'd say.
10:45:57 <mm_freak> tertl3_: the following are equivalent:  an editor combinator, a record/structure accessor, a deep modification function
10:46:02 <Eduard_Munteanu> Er, s/element/record/
10:46:09 <tertl3_> those are words that I am not familiar with
10:46:35 <rtpg> Is there a place that collects all the sort of optimizations that ghc tries to do?
10:46:37 <mm_freak> tertl3_: what mauke said, but in different words
10:46:38 <Eduard_Munteanu> tertl3_: it's sort of a functional equivalent for pointers
10:46:58 <mm_freak> i'd say cursors instead of pointers
10:47:04 <erisco> rtpg, ghc-core will tell you the optimisations the compiler made
10:47:23 <Eduard_Munteanu> But it doesn't just point at memory locations, it targets arbitrary (combinations of) things in a structure.
10:47:28 <mm_freak> a lens is a cursor in a larger data structure, like an individual position in a text string
10:47:44 <mm_freak> or like an individual branch of a tree
10:48:06 <yitz> mm_freak: another trick (which i'm sure you know): lambdabot tricks you less in a pm
10:48:12 <rtpg> erisco, thanks, didn't know about that
10:48:21 <mm_freak> yitz: indeed
10:48:34 <Eduard_Munteanu> tertl3_: for example, given an (a,b,c) tuple, there's a lens that "targets" a and c
10:48:34 <erisco> rtpg, neither did I. I was just reading about it this morning :)
10:48:43 <tertl3_> > let main() = true
10:48:44 <lambdabot>  not an expression: `let main() = true'
10:48:53 <tertl3_> > let main = true
10:48:54 <lambdabot>  not an expression: `let main = true'
10:48:56 <catsup> is there something like forM_ that gives me a count of iterations?
10:49:05 <rtpg> I love how many cool things have been built in haskell (from a language level).... if only amazing applications were written too ^^
10:49:18 <erisco> tertl3, did you mean True?
10:49:25 <tertl3_> > let main = True
10:49:26 <lambdabot>  not an expression: `let main = True'
10:49:29 <Guest800> fixed it, thx for help mauke! :)
10:49:30 <tertl3_> > let main() = True
10:49:31 <lambdabot>  not an expression: `let main() = True'
10:49:39 <tertl3_> idk
10:49:42 <erisco> tertl3, the syntax is "let ... in ..."
10:49:53 <catsup> you can't do that unless you're in a do block
10:49:54 <mm_freak> rtpg: darcs, GHC itself, various web pages, xmonad, yi, …
10:49:55 <aristid> > let main = True in main
10:49:56 <lambdabot>  True
10:50:13 <tertl3_> mm_freak, ive been using yi the last 2 days
10:50:16 <aristid> > runIdentity $ do { let main = True; return main }
10:50:17 <lambdabot>  <hint>:1:49: parse error on input `}'
10:50:26 <aristid> meh
10:50:27 <tertl3_> do you know what the keym aps are for as=vim?
10:50:40 <mauke> aristid: (it was expecting a '=')
10:50:47 <mm_freak> tertl3_: what's your opinion?
10:51:04 <tertl3_> mm_freak, the keymaps are not the same
10:51:25 <mm_freak> tertl3_: hopefully, but that's not what i'm asking =)
10:51:37 <mm_freak> how is the user experience?  does it "make sense"?  can you get stuff done with it?
10:51:40 <mm_freak> as fast as in emacs/vim?
10:52:04 <tertl3_> yes but if I could learn how to copy paste i would be a happy camper
10:52:04 <yitz> > runIdentity $ do { let {main = True}; return main }
10:52:05 <lambdabot>  True
10:52:20 <mm_freak> tertl3_: are you using the emacs or vim keymap?
10:52:45 <tertl3_> mm_freak, i do "yi --as=vim"
10:52:53 <mm_freak> then i can't help you =)
10:53:02 <tertl3_> u use emacs dont you
10:53:10 <mm_freak> yeah
10:53:11 <yitz> tertl3_: "* doesn't work?
10:53:14 <catsup> does yi have infinite persistent undo?
10:53:20 <mauke> in general you use y ("yank") for copy and p ("paste") for paste
10:53:28 <tertl3_> what yitz?
10:53:38 <catsup> s/infinite/arbitrarily large/
10:53:41 <Eduard_Munteanu> tertl3_: I use emacs with a vim emulation mode :)
10:53:45 <mm_freak> funny…  in emacs pasting is called yanking
10:53:48 <mm_freak> killing and yanking
10:53:56 <yitz> tertl3_: in vi "* stands for the clipboard. so "*y copies and "*p pastes
10:53:56 <rtpg> mm_freak, sorry, it's just that the haskell code that impresses me the most usually has to do with doing stuff with the language
10:54:00 <mauke> yes, because that makes sense *rolls eyes*
10:54:15 <rtpg> but considering I use xmonad , I should probably be more grateful haha
10:54:32 <catsup> xmonad kind of sucks though
10:54:44 <mm_freak> catsup: why?
10:54:54 <catsup> has unfixable bugs
10:55:00 <mm_freak> catsup: like what?
10:55:23 <catsup> like, untile a window, then mouse over to a tiled window, change the tiled window, nad move the mouse back to the untiled window
10:55:34 <catsup> the foreground tiled window will then change
10:55:45 <catsup> it's really annoying
10:55:56 <tertl3_> http://www.haskell.org/haskellwiki/Yi#Vim_key_bindings   ?????
10:55:58 <mm_freak> huh?
10:56:01 <Eduard_Munteanu> catsup: change title how?
10:56:04 <catsup> like if you want to look at one window on top of another window
10:56:08 <mauke> Eduard_Munteanu: what?
10:56:08 <catsup> not title, tile
10:56:10 <mm_freak> i never experienced that bug
10:56:13 <Eduard_Munteanu> Er, I misread.
10:56:13 <hattmammerly> I want to split a string at the first occurrence of a character, and only the first occurrence. takeWhile gives me the first half, how might I get the second?
10:56:24 <Eduard_Munteanu> I shouldn't lean back without my glasses :)
10:56:26 <mauke> hattmammerly: span/break
10:56:28 <rtpg> hattmammerly, there's span
10:56:30 <catsup> mm_freak: well, i don't know how you could miss it, if you ever use untiled windows
10:56:31 <rtpg> :t span
10:56:32 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
10:56:44 <catsup> the xmonad developers say it's unfixable
10:56:46 <mm_freak> catsup: but yeah, xmonad doesn't handle non-tiled windows very well, though
10:56:50 <hattmammerly> alright, I'll look at that. thanks!
10:56:52 <catsup> well that's not really the point
10:56:58 <mm_freak> catsup: i generally try to avoid using untiled windows
10:57:04 <catsup> the point is, it _ought_ to be fixable, but something about the design makes it not so
10:57:43 <mm_freak> catsup: it's probably something like:  having associative (.+.) is a bug, but you can't fix it, because you want (.+.) to form a monoid
10:57:43 <rtpg> there are some things I feel are a bit harder to write considering that haskell is functional (I like being able to write quick hacks in my config scripts)
10:57:59 <hattmammerly> catsup: you don't like focus following mouse? isn't that the behavior of every system built on x?
10:58:05 <mm_freak> it's a tradeoff and the xmonad developers have chosen one way
10:58:06 <catsup> hattmammerly: that's not what i'm talking about at all
10:58:13 <hattmammerly> catsup: oh, sorry
10:58:15 <Eduard_Munteanu> hattmammerly: it's not
10:58:20 <catsup> hattmammerly: when you move the mouse onto a window, the window you move it onto disappears, and another reappars in its place
10:58:38 <hattmammerly> oh! that's not good.
10:58:39 <yitz> hattmammerly: catsup says that focus follows point only sometimes when you are dealing with untiled windows.
10:58:49 <mm_freak> catsup: yet i can't reproduce this bug
10:58:51 <catsup> i'm not talking about focus at all
10:58:52 <yitz> ohhh really?
10:59:08 <aristid> i can't reproduce it either, but...
10:59:13 <yitz> i've been using xmonad for years and that never happened to me.
10:59:17 <Eduard_Munteanu> I've only seen xmonad and plain X without a wm doing the focus follows mouse thing.
10:59:18 <aristid> when i try to until one of my smaller windows, it becomes huge
10:59:21 <aristid> no idea why
10:59:23 <aristid> *untile
10:59:25 <catsup> mm_freak: you need multiple tiled windows and at least one untiled window.  it's easily reproduced.  it's in the bug tracker.  it's known to the xmonad developers.
11:00:03 <mauke> are there any xmonad developers?
11:00:04 <catsup> mm_freak: it won't occur if you already have the "right" tiled window in the foreground, so swap which is the foreground tiled window
11:00:10 <yitz> i use multiple tiled windows with untiled windows all the time.
11:00:18 <mm_freak> catsup: i'm not questioning its existence, just that i'm too stupid to reproduce it =)
11:00:21 <yayutf> my pet xmonad issue at the moment is that when I'm using libreoffice and bring up a dialog (like, say, 'save'), sometimes the red border around the window flashes for up to half a minute or so, my cpu gets pegged at 71+/-2%, and xmonad is unresponsive - i can't type in windows, switch virtual desktops, etc
11:00:32 <yayutf> mm_freak: catsup's issue sounds familiar
11:00:38 <Eduard_Munteanu> aristid: when you untile a window, the rest fill up the remaining space
11:00:54 <aristid> Eduard_Munteanu: no, the _untiled_ window becomes huge
11:00:58 <mauke> yayutf: that sounds like libreoffice is fighting the window manager for focus
11:01:06 <yitz> yayutf: yeah i hate that one. i'm not sure if it's an xmonad issue or a libreoffice issue though. openoffice is fine.
11:01:08 <merijn> yayutf: Sounds more like libreoffice too me, as libreoffice has a tendency to bring my OSX system to a crawl too
11:01:22 <merijn> (Without xmonad, that is)
11:01:25 <Eduard_Munteanu> aristid: untile it how? mod+right-click resizes the window too, if you use that
11:01:35 <yayutf> mauke: yep; merijn: yeah, it's horribly slow, yitz: good to know
11:01:44 <aristid> Eduard_Munteanu: mod-left-drag
11:02:05 <Eduard_Munteanu> aristid: hmm.. that works fine here.
11:02:35 <erisco> I don't know all the theoretical conventions but is there a class for antisymmetric structures? such as division and subtraction?
11:02:54 <companion_cube> groups?
11:03:11 <aristid> but i almost never untile windows, so...
11:03:14 <Eduard_Munteanu> yayutf: the flashing often happens with focus following mouse when your pointer is at corners / on the border... I just don't use focusFollowsMouse.
11:03:21 <mm_freak> rtpg: oh, how could i forget to mention pandoc
11:03:27 <aristid> Eduard_Munteanu: one thing that slightly bugs me about xmonad is that every workspace has a flat list of windows
11:03:32 <rtpg> pandoc is pretty cool yeah
11:03:43 <aristid> Eduard_Munteanu: so the layouts that try adding things like Tabs are quite the hacks IMHO
11:03:48 <erisco> companion_cube, well, there are no left-identities in this case
11:03:55 <Eduard_Munteanu> aristid: you can organize them by subgroups using some plugins
11:04:09 <Eduard_Munteanu> WindowNavigation or something.
11:04:25 <aristid> Eduard_Munteanu: yes but that's hacked on top
11:04:45 <aristid> Eduard_Munteanu: i do use xmonad of course, but the i3 logical model seems more interesting to me
11:04:54 <yayutf> Eduard_Munteanu: It's only bugged me with libreoffice, and on the whole I prefer focusFollowsMouse, but that's a personal taste issue :)
11:04:58 <aristid> i guess i'd still want some kind of automatic layout though
11:05:07 <catsup> i'd ditch xmonad in a second if anything else worked similarly
11:05:32 <catsup> but oh well
11:05:52 <Cale> catsup: I'd pick up xmonad in a second if it worked like anything else.
11:05:53 <yitz> Eduard_Munteanu: i get enough of focus not following point when i use mac os x and windows. i'm not willing to give it up in X.
11:05:55 <Eduard_Munteanu> aristid: if you build your own layouts from existing layouts I think you can use them to structure windows, using one of the Window* things. Pretty much you get per sublayout window stacks.
11:06:01 <catsup> Cale: ;)
11:06:37 <Eduard_Munteanu> yitz: perhaps you want to set clickJustFocuses to False
11:07:11 <yitz> Eduard_Munteanu: what would that do for me?
11:07:23 <catsup> i think what he meant to say is, you should quit using osx and windows
11:07:32 <Cale> (I'm actually serious, if there were a decent setup for Xmonad with ordinary-looking non-tiled windows with titlebars and the usual resizing borders etc, I would use it)
11:07:36 <Eduard_Munteanu> yitz: you don't need to click once to focus and another time to press a button etc.
11:07:45 <Cale> I never really want to tile my windows
11:07:47 <mm_freak> Cale: come on, you use arrow transformers…
11:07:59 <Cale> mm_freak: ?
11:08:02 <Cale> I do?
11:08:12 <Hafydd> Why do you need resizing borders?
11:08:14 <catsup> 99% of the time i want one fullscreen window
11:08:19 <mm_freak> i remember your Event type to be an arrow transformer
11:08:19 <Cale> Hafydd: I use them all the time
11:08:29 <mm_freak> Event (~>) a b ~> …
11:08:32 <Cale> mm_freak: oh, it didn't produce an arrow
11:08:33 <yitz> Eduard_Munteanu: sometimes i want to type in a window by moving the mouse over it and just typing.
11:08:33 <Hafydd> Cale: but you can just use meta+drag for the same effect.
11:08:39 <mm_freak> Cale: ah, ok
11:08:40 <Cale> It was just Event (~>) a
11:08:48 <mm_freak> Cale: come on, you use arrows =P
11:08:52 <Cale> hehe
11:08:54 <Eduard_Munteanu> Ah.
11:09:03 <Cale> Hafydd: Yeah, but I don't do that
11:09:13 <Hafydd> Whereas resizing borders are really fiddly and hard to place the cursor on.
11:09:29 <Hafydd> Especially at the corners.
11:09:34 <mm_freak> i think only three people in this channel actually use arrows
11:09:39 <yitz> Cale: the idea is that xmonad reads your mind so that you don't have to drag window borders.
11:09:55 <mm_freak> and one of them just said this:  <Cale> catsup: I'd pick up xmonad in a second if it worked like anything else.
11:09:56 <Cale> yitz: In that case, it's very terrible at reading my mind
11:10:17 <yitz> Cale: i guess you'd have to teach it then, in your case.
11:10:34 <Cale> Yeah, the thing is, what I want it to mostly work like is, say, Metacity.
11:10:48 <erisco> damn mouse stole half a big bag of pretzels
11:10:51 <Cale> and then from there, I could be bothered tweaking it a bit
11:11:32 <mm_freak> i think there was an xmonad-based window manager with fancy widgets and both overlapping and tiling mode or a mix of them
11:11:42 <mm_freak> i can't remember its name
11:11:48 <Clint> bluesomething?
11:12:01 <Eduard_Munteanu> Most commonly I use a custom layout that reserves a column for 80 char terms on the right, and a big window / Tile on the left, usually for a browser.
11:12:18 <Eduard_Munteanu> On a 16:10 screen.
11:15:50 <Cale> One thing might be interesting to experiment with is something which tries to gradually reposition the unfocused windows after a certain amount of time, such that all of them are available to click in.
11:16:08 <Cale> (without changing the z-order)
11:16:24 <nh2> when I don't use ghc -threaded, is it expected that a `sleep` foreign call just returns immediately?
11:16:37 <Cale> no?
11:16:53 <mauke> nh2: how did you import the function?
11:17:42 <nh2> `foreign import ccall safe slow :: CUInt -> IO ()`, where `void slow(unsigned n){ sleep(n) };`
11:18:59 <nh2> mauke: same with `foreign import ccall safe "sleep" sleep_sys :: CUInt -> IO ()`
11:19:05 <merijn> nh2: What are you passing to that function?
11:19:11 <mauke> except sleep returns CUInt
11:20:17 <mm_freak> Clint: indeed, bluetile
11:20:19 <mm_freak> Cale: http://www.bluetile.org/
11:20:32 <mm_freak> it's written using xmonad IIRC
11:20:40 <Cale> mm_freak: That's is exactly the opposite of what I want.
11:20:50 <Cale> I want a *non* tiling window manager based on Xmonad :)
11:21:12 <Cale> Though, oh, it might also contain stacking...
11:21:35 <nh2> mauke: interesting indeed, it returns a number if I don't use -threaded (the number of seconds remaining according to man page, "if the call was interrupted by a signal handler")
11:21:41 <Cale> Basically, I don't want anything to ever tile at any point in time :)
11:21:46 <mauke> nh2: time for strace?
11:21:50 <nh2> so I guess that means that it was immediately interrupted by a signal handler
11:21:51 <aristid> Cale: why?
11:22:13 <nh2> it's probably ghc's signals that it uses all the time, but I thought such things should just work even without 0threaded
11:22:17 <Cale> Because it doesn't fit with how I like to arrange things on my screen
11:22:21 <mm_freak> Cale: it does both
11:22:28 <merijn> nh2: Why are you trying to call C sleep anyway?
11:22:34 <simpson> I'm so disappointed in Cap'n Proto. Does anybody here have opinions on it?
11:22:44 <mm_freak> Cale: the point was to show you that xmonad is flexible =)
11:22:54 <Cale> Yeah, I realise that it is
11:22:55 <aristid> simpson: it looked uninteresting when i looked at it :P
11:22:55 <mm_freak> i think it's really wrong to call it a tiling WM
11:23:10 <nh2> merijn: just extending my FFI+runtime knowledge
11:23:12 <simpson> aristid: It's got at least one feature that protobufs don't have and that I want: Tagged unions.
11:23:14 <Cale> Perhaps this is close enough to what I want that I could manage to like it
11:23:14 <merijn> simpson: My opinion, having only ever heard the name and not even knowing what it does, is that it's one of those newfangled all hype and substance projects
11:23:29 <mm_freak> Cale: and if you don't like it, you can always change it =)
11:23:32 <merijn> simpson: all hype, *no* substance, I meant
11:23:33 <simpson> merijn: Nah, same author as original protobufs, same ideas, similar syntax.
11:23:43 <mm_freak> Cale: bluetile is an xmonad library
11:23:48 <Cale> right
11:23:53 <merijn> simpson: That doesn't change my opinion, protobufs seems all hype and no substance either
11:24:12 <simpson> I'm disappoint because he switched the compiler from Haskell to C++11 and so now it's harder to read, massively complex, and distros don't offer the compilers necessary to build it.
11:24:33 <simpson> merijn: Oh. Uh, Google uses them in production for just about everything; they seem practical, if ugly.
11:24:54 <aristid> merijn: well, protobufs isn't exactly awe-inspiring, but when the previous status quo was handcoded binary serialization in c++, then it really is a huge improvement.
11:25:36 <nh2> mauke: strace says `EINTR (Interrupted system call)` with > 10 SIGVTALRM coming per second
11:26:09 <mauke> ooh, never seen that before
11:26:25 <nh2> mauke: that's "The timer signal" from https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Signals
11:26:52 <mauke> "Here we discuss only the threaded version, since we expect that to become the standard version in due course"
11:27:05 <TovenaarKlus1> mm_freak: Have you yet produced a nice floating layout in xmonad, however? I still fail trying that.
11:29:15 <nh2> mauke: oh, that surprises me, because "RTS Alarm Signals and Foreign Libraries" describes exactly what I'm seeing
11:29:21 <merijn> simpson: Google uses lots of stuff in production, that doesn't give it any more substance
11:29:55 <nh2> mauke: I'll ask in #ghc
11:30:02 <merijn> simpson: Sure, it's convenient, but it's not like they invent something radically new. They just wrote a library for doing something people have been doing for ages and have had libraries for for ages
11:31:40 <aristid> merijn: my personal pet peeve with protobufs is that they are not at all self-describing by default
11:32:16 <merijn> simpson: The internet seems to like to pretend that protobufs is something world altering, while it best it's just "a solid implementation of something obvious"
11:32:35 <mm_freak> TovenaarKlus1: i'm a tiling user
11:32:35 <simpson> merijn: Sure.
11:32:43 <aristid> there is _nothing_ wrong with solid implementations of obvious things.
11:33:18 <merijn> aristid: No, but simpson asked for an opinion and I said "all hype, no substance", which is a bit of hyperbole, but mostly true
11:33:23 <novochar> "Another advantage of wild cards is that a Haskell compiler can warn us if we introduce a variable name in a pattern, but do not use it in a function's body. Defining a variable, but forgetting to use it, can often indicate the presence of a bug, so this is a helpful feature."
11:33:47 <aristid> merijn: a solid implementation can be "substance", too
11:34:28 <hakujin> lots of opinions on serialization formats; if protobuf isn't a good solution what is? the general opinion seems to be JSON but I'm not sure I'd call that an upgrade over something like protobuf
11:34:31 <aristid> now i don't particularly like protobufs either, but if there is a subtext of novelty being of supreme importance, then i would dislike that.
11:34:31 <merijn> aristid: I don't know whether the implementation is solid, though. So I can't judge that :)
11:35:37 <TovenaarKlus1> mm_freak: Same, though on some occations I would like having a nice floating layout handy. I fail to produce one, though.
11:37:20 <mm_freak> TovenaarKlus1: not sure what an automatic floating layout would look like…  i do it manually when i need it
11:37:36 <mm_freak> i have key bindings to send floating windows to various locations on the screen
11:37:55 <mm_freak> and key bindings to float/unfloat a window
11:38:14 <mm_freak> TovenaarKlus1: this is my configuration: http://hub.darcs.net/ertes/config/browse/myxmonad
11:39:43 <bb2> f
11:40:07 <bb2> @pl select k l1 = map (\wyn -> wyn !! (k-1)) l1
11:40:08 <lambdabot> select = map . flip (!!) . subtract 1
11:40:38 <TovenaarKlus1> mm_freak: I will look into it. Thanks!
11:40:59 <aristid> bb2: that's actually a pretty decent result for @pl! normally it gives unreasonable things:D
11:41:37 <brian`> hello
11:42:09 <quchen> aristid: "map ." is pretty unreasonable.
11:42:34 <quchen> This @pl just hides its uselessness well.
11:42:36 <brian`> how can I make this code better? http://lpaste.net/98784
11:42:41 <aristid> quchen: :D
11:43:15 * hackagebot hopenpgp-tools 0.3 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.3 (ClintAdams)
11:43:40 <brian`> there is a lot of duplicate code, but I am having trouble figuring out how to make it 'table-driven'
11:43:53 <quchen> brian`: Give things useful names. "clrwdt" is not one.
11:44:32 * aristid recommends single-letter names.
11:45:36 <quchen> But only if they're not ASCII.
11:46:00 <aristid> kanji names ftw
11:46:26 <c_wraith> brian`: the first 4 definitions there could be made a helper function helper n i = string' n >> Tok.whiteSpace lexer >> return (emptyInst i), then map that over a list containing the name/instruction pairs
11:46:57 <aristid> there are three standard names for helper functions: helper, go and loop
11:47:04 <c_wraith> brian`: and then you could replace the fifth definition with like mappend . map try over that list
11:47:14 <c_wraith> brian`: or move try into the helper
11:47:33 <c_wraith> err, not mappend
11:47:47 <c_wraith> is there a name for foldr1 (<|>)
11:48:01 <aristid> :t msum
11:48:03 <lambdabot> MonadPlus m => [m a] -> m a
11:48:10 <quchen> http://lpaste.net/98784
11:48:10 <aristid> that's the wrong typeclass i guess:)
11:48:12 <quchen> Annotated.
11:48:20 <ion> Hopefully not.
11:48:21 <quchen> I called the new function "frmpft" for clarity.
11:48:39 <c_wraith> aristid: close, though.
11:48:41 <ion> c_wraith: Why not foldr (<|>) empty?
11:48:53 <quchen> That's asum.
11:49:06 <c_wraith> ion: I forgot empty was part of Alternative
11:49:13 <aristid> :t asum
11:49:14 <lambdabot>     Not in scope: `asum'
11:49:14 <lambdabot>     Perhaps you meant one of these:
11:49:14 <lambdabot>       `F.asum' (imported from Data.Foldable),
11:49:19 <aristid> :t F.asum
11:49:19 <lambdabot> (Foldable t, Alternative f) => t (f a) -> f a
11:49:23 <brian`> c_wraith: if I map a helper over a list of pairs.. then I have a list of Parser a's... so would I then map 'try' and then fold <|> across that?
11:49:30 <aristid> ah, good ol' Foldable generalizing all the things
11:49:39 <c_wraith> brian`: yep, that's the basic idea
11:49:46 <catsup> how can i make the haskell compiler tell me the type of something?  not ghci
11:49:54 <c_wraith> brian`: though you could move the try into the helper.. it'd be a bit more succinct
11:49:58 <joelteon> catsup: you can't
11:50:03 <ion> catsup: Add a type error. :-P
11:50:05 <joelteon> well, you could use Typeable
11:50:11 <brian`> c_wraith: ok
11:50:31 <ion> catsup: Or use -XImplicitParams and ?foo, or use TypeHoles when you have GHC 7.8.
11:50:33 <catsup> i don't mean to tell me in the program, i mean like some kind of debug output
11:50:44 <catsup> i mean, i don't need that information available in the program, i want it output to my console
11:50:53 <catsup> when i run the compiler
11:51:19 <c_wraith> catsup: yeah, sounds like you want TypeHoles in ghc 7.8
11:51:24 <catsup> ok
11:51:38 <catsup> hm, seems i have 7.4 tho
11:51:43 <c_wraith> catsup: though you can always throw an annotation on an expression that you know is wrong.
11:51:54 <c_wraith> catsup: and GHC will tell you what it thinks it should be.
11:51:54 <catsup> how do i do that?
11:51:58 <c_wraith> ::()
11:52:10 <catsup> ah, ok
11:52:11 <c_wraith> on the expression you want to know about
11:52:41 <c_wraith> You almost never will have something of the type ().  The only place I can think of where something is exactly that type is when using rnf
11:53:24 <catsup> ah well, ::() didn't work because it just said not enough arguments
11:55:18 <catsup> () -> () -> ... didn't quite work either :/
11:58:04 <c_wraith> catsup: ok, make it ::a
11:59:05 <c_wraith> catsup: it'll give you an error about rigid type variables - but that error should tell you what type it found
11:59:39 <catsup> it's only giving me a bunch of errors from other places in the code
12:00:00 <catsup> oh wait nevermind, it does work
12:00:10 <catsup> i did a->a-> ... but with literally just ::a it works
12:00:11 <catsup> thanks :)
12:01:06 <zett_zelett> Can one say that function application is left associative?
12:01:13 <theorbtwo> Don't forget to think about if the type it gave you actually makes sense.  Especially if you already think your code is buggy.
12:01:17 <catsup> haha, although it seems to be to be the wrong type
12:01:37 <Cale> catsup: If you put your code on lpaste we might be able to help a little better :)
12:01:42 <catsup> when i add the type annotation it no longer compiles
12:02:16 <catsup> well i can figure out what the types are with my brain, but it bothers me to do that when the compiler knows
12:02:28 <catsup> the code isn't buggy at all
12:02:42 <Cale> Oh, in that case, leave off the type signature
12:02:55 <Cale> and open the program in ghci, :t foo will tell you the type of foo
12:02:59 <mauke> zett_zelett: yes
12:03:10 <catsup> how can i open the program in ghci?
12:03:12 <mauke> a b c == (a b) c
12:03:21 <Cale> ghci MyProgram.hs
12:03:29 <catsup> oh shit
12:03:40 <Cale> You should pretty much always have ghci running alongside your text editor
12:03:41 <catsup> i didn't know you could do that
12:03:44 <Cale> in a separate window
12:03:53 <catsup> that's great
12:03:54 <Cale> :r will reload the file whenever you save your changes
12:04:08 <Cale> and you can type expressions to have them evaluated
12:04:55 <catsup> awesome
12:07:35 <kristof> LET US SUPPOSE that we do not have conditionals in our programming language
12:07:45 <kristof> or rather, let us not consider the case of conditionals for a second
12:07:47 <catsup> but if we don't have conditionals, then...
12:07:50 <brian`> ok... now I am at the part where I have a list of Parsers, but I can't seem to fold <|> accross them
12:07:51 <kristof> shhh :P
12:08:00 <ChongLi> conditionals are unnecessary :)
12:08:25 <kristof> Does the lambda calculus support out of order substitution?
12:08:39 <brian`> the error is something like: couldn't match expected type 'Parser a' with actual type '[Parser a]'
12:08:45 <mauke> kristof: what order?
12:09:04 <brian`> and something like "foldr <|> [] [list of Parser a's]" doesn't work
12:09:25 <catsup> %
12:09:30 <mauke> brian`: [] doesn't make sense as a base case
12:09:35 <kristof> mauke: \ x y z . BODY takes the first argument it gets and substitutes that for all occurences of x in BODY
12:09:55 <kristof> mauke: but what about (\ x y z . BODY ) y=arg
12:10:00 <ChongLi> how about something like (pure ())
12:10:01 <ChongLi> ?
12:10:09 <mauke> kristof: oh. no
12:10:11 <kristof> mauke: Where the application of the function yields a new function \ x z . BODY
12:10:23 <kristof> mauke: No, it doesn't? Why not?
12:10:33 <kristof> Substitution, if we consider that a mechanical process, is not really side affecting
12:10:34 <brian`> mauke: is there an empty parser in parsec?
12:10:34 <mauke> kristof: because it's not needed
12:10:45 <kristof> so substitution should be commutative
12:10:51 <kristof> or something
12:10:52 <mauke> brian`: fail "bzzt" ?
12:10:53 <kristof> :P
12:11:15 <kristof> mauke: So how do I get a function \ x z . body using the lambda calculus?
12:11:30 <mauke> kristof: also, in pure lambda calculus you don't have \x y z.
12:11:35 <mauke> kristof: you have \x. \y. \z.
12:12:08 <Cale> kristof: The lambda calculus does not in itself define an order of evaluation
12:12:33 <mauke> kristof: (\y x. (\x y z. ...) x y) arg
12:12:38 <Cale> There are equivalences between terms
12:12:49 <Cale> and they're usually even considered to be bidirectional
12:13:29 <Rarrikins> Where's a good intro to making a library install with cabal?
12:14:10 <Rarrikins> (and automatically get dependencies with Hackage)
12:14:45 <kristof> mauke: So it requires wrapping the old function in a new one
12:15:05 <mauke> two new ones
12:15:10 <mauke> \y ... and \x ...
12:15:14 <kristof> ah, right
12:16:08 <kristof> mauke: Why can't we simply skip that wrapping? :)
12:16:27 <mauke> why do you want to skip it?
12:16:45 <mauke> the lambda calculus is supposed to be simple
12:16:49 <kristof> oh well
12:16:49 <kristof> :P
12:16:50 <mauke> that means more work for the programmer
12:17:12 <brian`> hmm... so even if I fold with a base case of a parser, I still get an error... what I am trying to do is: foldr <|> (string "this should never match") [Parser a, Parser a, Parser a, ...]
12:17:18 <kristof> I'm looking for a good excuse for haskell to not have named arguments
12:17:51 <mauke> brian`: what error?
12:17:56 <ChongLi> brian`: oh, you need to wrap the operator in parens
12:18:04 <ChongLi> foldr (<|>) ...
12:18:50 <brian`> ChongLi: :)
12:19:35 <ChongLi> yeah, otherwise the operator will take precedence over foldr
12:19:41 <ChongLi> which gives you weirdness
12:19:53 <kristof> mauke: So about this. f arg-name:=argvalue should be syntactic sugar for wrapping a function in more functions to reverse order of substitution
12:20:07 <kristof> mauke: Is that well-defined? Legal?
12:21:01 <kristof> Suddenly, you have even more expressive function currying available to you
12:21:14 <mauke> it requires evaluation under lambda
12:21:40 <mauke> consider (\x. f y) z:=a
12:22:02 <brian`> ok great!
12:22:03 <mauke> you have to evaluate f y to see whether any nested lambda has a z
12:22:15 <brian`> the original code: http://lpaste.net/98784
12:22:22 <brian`> and the updated: http://lpaste.net/98788
12:22:28 <mauke> also, what about (\x. f x)
12:22:42 <brian`> but, I feel like the updated one could be better...
12:22:55 <kristof> mauke: So it would force evaluation...
12:23:00 <kristof> hmmm
12:23:25 <brian`> I guess what I am looking for is a base case to the foldr for a parser that will never match
12:23:44 <brian`> but it has to be a 'Parser Instruction' that will never match
12:23:50 <brian`> so it looks weird
12:24:05 <brian`> or... I guess I am looking for a way to fold without a base case
12:24:56 <kristof> mauke: Do you know any nonstrict languages that have keyword/named arguments?
12:25:09 <brian`> foldrl
12:25:12 <brian`> :type foldr
12:25:15 <mauke> kristof: Haskell :-)
12:25:25 <kristof> Haskell does not! No, I will not pass a record!
12:25:48 <brian`> foldr1
12:25:53 <kristof> brian`: foldr1/foldl1 are the folds that assume the first element is the base case, right?
12:26:15 <brian`> kristof: yes, this is exactly what I am looking for
12:26:17 <kristof> ...I don't know why they have a "1" out front
12:26:27 <brian`> woot! much better!
12:27:22 <brian`> is there a strict variant of foldr1 ?  I am looking for foldr1'
12:27:26 <Cale> I guess the 1 is a nod to the fact that they require a list of length at least 1.
12:27:37 <Cale> brian`: That doesn't make sense
12:27:41 <kristof> brian`: ...If Haskell had optional arguments, you need only "foldl/foldr" and simply leave out the last argument! But then your fundamental trade off is that you don't get nice auto-currying, so you'd need a curry keyword. Tradeoffs!
12:27:53 <Cale> brian`: What do you want foldr1' to be?
12:28:04 <manek> Hello! I just came across a very strnge Haskell behaviour. Could anybody tell me why in the following code (http://lpaste.net/98789) the line 19 does not compile, while line 18 works? I would be very thankful for any explaination.
12:28:08 <mauke> kristof: http://okmij.org/ftp/Haskell/polyvariadic.html#keyword-args
12:28:18 <kristof> oooooh, an okmij article
12:28:33 <mauke> kristof: http://hackage.haskell.org/package/HList-0.3.0.1/docs/Data-HList-Keyword.html
12:29:12 <brian`> I guess I don't understand strict vs lazy fold then... meaning I don't understand why there is a lazy and strict version of fold but not of foldl1/foldr1
12:29:17 <cmiller_> Doesn't foldr1 have to start with a reduced normal form anyway, to get the first element?
12:29:23 <Cale> brian`: There's no strict foldr
12:29:43 <brian`> foldr' ?
12:29:48 <Cale> :t foldr'
12:29:50 <lambdabot>     Not in scope: foldr'
12:29:50 <lambdabot>     Perhaps you meant one of these:
12:29:50 <lambdabot>       BS.foldr' (imported from Data.ByteString),
12:29:57 <Cale> Not for lists
12:30:17 <Cale> What would it be?
12:30:25 <ChongLi> strict foldr would only make sense for snoc lists, right?
12:30:29 <quchen> Cale: Funny you say that, what does Foldable's foldr do actually?
12:30:31 <brian`> Data.Foldable.foldr'
12:30:32 <brian`> ?
12:30:35 <quchen> Eh, foldr' I mean
12:30:42 <brian`> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Foldable.html
12:30:56 <brian`> :t Data.Foldable.foldr'
12:30:57 <lambdabot> Foldable t => (a -> b -> b) -> b -> t a -> b
12:30:57 <Cale> Probably something you never want
12:31:27 <mauke> /me ponders foldr' _ z [] = z; foldr' f z (x : xs) = f x $! (foldr' f z xs)
12:31:29 <shachaf> foldr' can make sense for a lot of structures, but not right-biased ones (such as [] in Haskell)
12:31:30 <quchen> Cale: The implementation builds up some EndoDual thing and then does something with that.
12:31:53 <shachaf> mauke: foldr' f z xs = foldr (f $!) z xs?
12:31:56 <ChongLi> brian`: take a look at the instance Foldable []
12:32:02 <shachaf> Er, not (f $!)
12:32:09 <Cale> Well, right, for other structures (like snoc lists), foldr' can be okay
12:32:11 <ChongLi> it doesn't provide a definition for foldr'
12:32:21 <Cale> brian`: What are you computing?
12:32:33 <shachaf> (\x -> (f x $!))
12:32:35 <Cale> brian`: *Usually* you always either want foldl' or foldr
12:32:45 <Cale> brian`: all the other cases are rare
12:32:53 <shachaf> I wish Haskell was less list-biased.
12:33:07 <mauke> :t choice
12:33:08 <lambdabot>     Not in scope: `choice'
12:33:08 <lambdabot>     Perhaps you meant `choose' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
12:33:19 <mauke> I actually meant the parsec one
12:33:37 <ChongLi> shachaf: join the legions of Prelude alternative-seekers :)
12:33:44 <shachaf> No thanks.
12:33:56 <Cale> I think lists are important enough that it's okay to have some bias in their favour.
12:34:35 <ChongLi> they're a nice, simple, persistent data structure that's easy for beginners to understand
12:34:37 <shachaf> Balanced trees are also important.
12:34:45 <Cale> It's not just that
12:34:56 <Cale> It's that they reflect iterative processes
12:34:58 <brian`> I have a list of Parsers that I want to fold with <|>, so I guess left or right doesn't quite matter
12:35:05 <mauke> brian`: choice
12:35:29 <Cale> Lists are popular in Haskell for precisely the same reason that loops are popular in imperative settings.
12:35:32 <mauke> .oO( I wish GC was less memory-biased )
12:36:04 <danilo2> Hi! I'm working with manek and we do not understand one thing in Haskell. Could somebody look please at the 20-line code and tell us, why one line compiles while the other does not? http://lpaste.net/98789 Thank you :)
12:36:07 <brian`> mauke: hah! choice is what I just did.. perfect
12:36:27 <Cale> brian`: also, foldr would be the one you want
12:36:43 <Cale> brian`: and you'd use pzero as the second parameter
12:36:46 <brian`> Cale: why?
12:37:18 <Cale> Because you're trying the parsers in order.
12:37:53 <Cale> It makes sense to pass control to <|> to allow for the first parser to be run and fail before combining the rest of the parsers
12:38:00 <Cale> @src foldr
12:38:00 <lambdabot> foldr f z []     = z
12:38:00 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:38:13 <Cale> ^^ foldr passes control to f in the nonempty list case
12:38:18 <Cale> @src foldl
12:38:18 <lambdabot> foldl f z []     = z
12:38:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:38:34 <Cale> ^^ foldl passes control to itself greedily until it reaches the end of the list
12:38:36 <brian`> Cale: got it
12:38:54 <erisco> is it possible for a type 'f a' to not be a Functor?
12:39:10 <Cale> erisco: sure
12:39:22 <Cale> data Nonfunctor a = NF (a -> a)
12:39:30 <brian`> so... choice = foldr (<|>) mzero ps ... why doesn't it just do: foldr1 (<|>) ps  ?
12:39:46 <Cale> because choice [] makes sense as a parser which always fails
12:39:49 <brian`> is it just to protect against the empty list?
12:40:00 <mauke> "protect"?
12:40:06 <erisco> Cale, ah. are there other examples?
12:40:09 <Cale> rather than just having your whole program die, it would be preferable to have a parse error
12:40:13 <mauke> danilo2: looks like it doesn't know which instance of X to use
12:40:35 <Cale> erisco: Well, any type which involves the type parameter in a negative position anywhere.
12:40:36 <brian`> i see
12:40:50 <erisco> Cale, what qualifies as a negative position?
12:41:07 <Lethalman> what about NF (OtherNonFunctor a)
12:41:26 <danilo2> mauke: I simplified the code, look here: http://lpaste.net/98790 . It does NOT have to know which instance to use - it does not use any of these instances. If you comment the line 12, it works, but why?
12:41:58 <mauke> danilo2: if it doesn't have to know, why does the error message say otherwise?
12:42:13 <Cale> In A -> B, the B is in positive position and the A is in negative position. Positions inside of a negative position are inverted, so in (a -> r) -> r, the a is in positive position,
12:42:52 <erisco> Cale, I see
12:43:09 <danilo2> mauke: This is exactly my question. please look, at this code: http://lpaste.net/98790. You can copy - paste it and run. As you can see, there is no need to know which instance to use, becuase it is discarded by wildcard
12:43:24 * hackagebot JuicyPixels 3.1.3 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.3 (VincentBerthoux)
12:43:26 <Cale> erisco: If you think about it from the perspective of the caller of such a thing, the things in positive position are what it it is providing to you, and the things in negative position are what you provide to it.
12:43:29 <mauke> danilo2: if that is your question ...
12:43:35 <mauke> danilo2: the answer is you're wrong and it does have to know
12:43:42 <Cale> erisco: and from an implementor's perspective, it's the other way around
12:43:46 <Cale> (of course)
12:43:58 <mauke> > (\_ -> ()) show
12:43:59 <lambdabot>  ()
12:44:11 <mauke> is that extended defaulting?
12:44:23 <Cale> erisco: This terminology comes from classical logic, where A -> B (i.e. A implies B) is logically equivalent to B or not A
12:44:33 <Cale> (the A is negated)
12:45:47 <danilo2> mauke: Err, I'm sorry. The question was not precise, because I do not know what to ask about - why it needs to know that? If I use "undefined" instad of "testx" it works, because it gets discarded by wildcard ...
12:46:11 <mauke> danilo2: you can reduce your code to (\_ -> ()) show
12:47:02 <erisco> Cale, okay thanks
12:47:27 <kristof> You can construct a monad transformer out of every comonad. When is this useful?
12:47:29 <mauke> hmm, turns out I don't actually know the typing rules for classes
12:47:45 <Cale> erisco: If the parameter only occurs in negative positions, you can get a contravariant functor
12:47:58 <Cale> i.e. cofmap :: (b -> a) -> f a -> f b
12:48:21 <mauke> Cale: do you happen to know what makes '(\_ -> ()) show' an error?
12:48:44 <kristof> mauke: functions do not participate in the show typeclass
12:48:52 <mauke> kristof: what
12:48:54 <Cale> mauke: Insufficiently aggressive defaulting
12:49:00 <kristof> :(
12:49:03 * kristof scampers away
12:49:10 <Cale> mauke: If you turn on ExtendedDefaultRules, it works
12:49:13 <danilo2> mauke: Ok, I reduced the code (http://lpaste.net/98790). But I still does not know, why the version with undefined works, while with testx does not :(
12:49:14 <mauke> Cale: why does it have to default anything?
12:49:24 <Cale> Because which show instance should be provided?
12:49:39 <mauke> why does it have to select one?
12:50:08 <mauke> under the dictionary interpretation we have show :: Show a -> a -> String
12:50:31 <mauke> if we never apply show, we never need a Show dictionary
12:50:58 <Cale> Yeah, but it's not going to do non-local reasoning to determine that the Show instance isn't *really* required
12:51:19 <Cale> It *could* be required, if you pass show to an arbitrary function
12:51:32 <mauke> yeah, but we know this function is polymorphic in its argument
12:51:43 <mauke> (\_ -> ()) :: a -> ()
12:51:48 <mauke> a should unify with whatever
12:52:47 <Cale> What I'm saying is that it's not looking at all at the (\_ -> ()) when translating show
12:53:02 <Cale> That's off in some other subterm that it's not even examining
12:53:03 <danharaj1> :t ((\_ -> ()) :: (forall t. Show t => t -> String) -> ()) show
12:53:04 <lambdabot> ()
12:53:23 <danharaj1> :t ((\_ -> ()) :: forall a. a -> ()) show
12:53:24 <lambdabot> ()
12:53:35 <Cale> > (\_ -> ()) show
12:53:36 <lambdabot>  ()
12:53:43 <Cale> ^^ lambdabot has extended default rules
12:54:09 <danharaj1> does ghci have extended default rules?
12:54:12 <Cale> yes
12:54:24 <danilo2> Cale, mauke: even with extended default rules, this code does not compile: http://lpaste.net/98790 . Is it possible to make it working? I still does not get, why Haskell cannot see it is not needed here :(
12:54:36 <Cale> ghci> :set -XNoExtendedDefaultRules
12:54:36 <Cale> ghci> (\_ -> ()) show
12:54:36 <Cale> <interactive>:6:12:
12:54:36 <Cale>     No instance for (Show a0) arising from a use of `show'
12:54:40 <mauke> danilo2: you're annoying
12:55:15 <Cale> danilo2: Specify the type of testx
12:55:28 <Cale> danilo2: It doesn't know which instance of the class X you want.
12:56:01 <Cale> danilo2: there's an implicit hidden parameter to testx which the compiler needs to supply everywhere that you use it
12:56:04 <danilo2> mauke: I'm sorry - I was sure, this is  little different case, than you were talking about, because with (\_ -> ()) extended default rules help. Sorry for being annoying, I'll try not to distrub you further
12:56:11 <danharaj> Cale: It works if you give (\_ -> ()) the higher rank type.
12:56:21 * danharaj wonders if it works with impredicative polymorphism
12:56:26 <Cale> danharaj: yeah, it would
12:56:46 <Cale> GHC will typically be unwilling to unify a type variable with a polytype
12:57:01 <danharaj> yeah it seems that's what happens
12:57:30 <danharaj> while extended defaulting rules works, I think it really is the fact that GHC refuses to unify show's polytype.
12:57:31 <Cale> (at least, during inference)
12:57:35 <danharaj> So it looks for a monotype to unifyp.
12:57:39 <danharaj> But then *which* monotype?
12:57:44 <Cale> right
12:58:10 <mauke> 'data Sho a = Sho{ sho :: a -> String }; main = print $ (\_ -> ()) sho' works
12:58:25 <mauke> Cale: that's why I don't understand your "when translating show" comment
12:59:50 <mauke> ghc apparently doesn't blindly desugar show to some dictionary thing
12:59:58 <Cale> yeah
13:00:44 <danilo2> Cale: Ok, so even if it is not needed, like in my example, I have to supply the type to testx? Hmm, this sounds a little strange to me. Could you tell a little more about this hidden parameter please and why it works like this?
13:00:47 <mauke> does the report say what typing rules apply to classes?
13:01:11 <Cale> mauke: Well, I'm thinking it's really more like it translates it to  (sho d), and then gets stuck figuring out what d is
13:01:30 <Cale> mauke: because it doesn't have enough type information to understand which d to supply
13:02:34 <mauke> ooh, it always wants a dictionary to apply right now
13:02:40 <Cale> yes
13:02:50 <erisco> does Haskell have a type like Either but with 3 constructors? I do not think nesting Either types is the best idea
13:03:20 <Cale> and it *may* get that dictionary as a parameter from the definition of the surrounding function, but in any case, it needs to know what type of dictionary it is
13:03:59 <Cale> erisco: Nothing standard
13:04:14 <mauke> what would go wrong if it substituted (\d -> show d)?
13:04:15 <Cale> erisco: Probably you want to define your own datatype
13:04:29 <Cale> mauke: Well, in this case, nothing of course.
13:04:35 <ChongLi> yeah, this is the approach taken with attoparsec
13:04:37 <mauke> yeah, I mean in general
13:05:18 <Cale> That's sort of what it does in the case that danharaj pointed out
13:05:23 <ChongLi> data IResult t r = Fail t [String] String | Partial (t -> IResult t r) | Done t r
13:06:01 <Cale> When you define the function on the left to be a polymorphic one, accepting a polymorphic function which is going to accept a type class dictionary as a parameter
13:06:13 <Cale> When you define the function on the left to be a higher rank one, accepting a polymorphic function which is going to accept a type class dictionary as a parameter
13:06:25 <Cale> (rather)
13:06:52 <henk> Hi, I have a question regarding Data.Map. I have a "Map UTCTime DiddoParsed" where DiddoParsed is my own datatype. I also have a function "UTCTime -> [UTCTime] -> [Integer]" which takes a starting value and a list of UTCTimes and calculates the deltas. My goal is a "Map UTCTime DiddoParsedWithDelta" where UTCTime is the same key as before and the value is constructed using the delta from the function. Any
13:06:54 <henk> advice how to go about that?
13:07:06 <Cale> and it doesn't want to unify the type variable t in  (\_ -> ()) :: t -> () with a polymorphic type while doing inference.
13:07:51 <mauke> what exactly is a polymorphic type?
13:07:58 <Cale> One which has a forall in it
13:08:14 <mauke> like forall a. Sho a -> a -> String?
13:08:18 <Cale> yeah
13:08:26 <mauke> because that one gets accepted
13:08:46 <Cale> This situation is confused by the fact that explicit type signatures that we can give always implicitly get forall'd at the top level if we don't write the forall
13:09:06 <ChongLi> henk: are the deltas relative to each other or just to the first one?
13:09:18 <Cale> If you explicitly tell GHC that you want the function (\_ -> ()) to have type ((Show a) => a -> ())
13:09:22 <Cale> er
13:09:23 <henk> I guess I’m looking for a way to "zip" over a Data.Map, but I’m not sure …
13:09:29 <henk> ChongLi: Each other.
13:09:34 <Cale> If you explicitly tell GHC that you want the function (\_ -> ()) to have type ((Show a) => a -> String) -> ()
13:09:36 <Cale> rather
13:09:39 <Cale> then it will work
13:09:42 <ChongLi> henk: ahh, then that's a fold
13:09:50 <Cale> oops, I still left out a forall
13:09:54 <mauke> Cale: why doesn't '(\_ -> ()) id' fail?
13:10:11 <Cale> Good question :)
13:10:21 <mauke> only classes are affected
13:10:25 <Cale> yeah
13:10:33 <ij> Why should it fail?
13:10:44 <Cale> ij: Because of what I just said :)
13:10:51 <mauke> ij: because (\_ -> ()) show fails
13:10:51 * ij reads
13:11:04 <Cale> about GHC not wanting to unify type variables with polymorphic types while doing inference
13:11:13 <Cale> oh
13:11:16 <Cale> I know why
13:11:38 <Cale> ... I think :)
13:12:05 <Cale> It doesn't have to actually be a polymorphic parameter then
13:12:33 <Cale> It can be monomorphic (with the type variable it was assigned during inference!)
13:12:58 <Cale> i.e.  id :: t -> t  with no implicit forall
13:13:03 <henk> ChongLi: AFAIU a fold reduces the map to just one value, not to a new map, correct?
13:13:22 <ChongLi> henk: that one value can be anything, including a new map
13:13:54 <mauke> Cale: what's different with classes?
13:15:00 <Cale> This is tricky to explain in English :)
13:15:05 <ChongLi> > foldr ((:) . (+1)) [] [1..10]
13:15:06 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:15:43 <Cale> mauke: I think it's where the type variable becomes monomorphic that it decides to add the dictionary parameter
13:16:05 <Cale> and that happens even if the problem of what that variable should be is still underdetermined
13:16:26 <Cale> It's possible that there's some way to do the translation that this doesn't happen
13:16:37 <Cale> But this is a very silly edge case that no real code would need to care about
13:16:39 <koala_man> I'm trying to upload a package on Hackage, but I get "No access for this resource."  Is there a step I missed somewhere?
13:17:09 <Cale> In fact, I think it's probably actually a good thing for this to be an error
13:17:23 <Cale> because if you write code like this, it probably doesn't do what you intended
13:17:35 <Cale> (whatever that might've been)
13:18:02 <henk> ChongLi: oh
13:18:08 <Cale> danilo2: What program are you actually trying to write?
13:18:34 <danilo2> Cale: Hmm, this is a little more complicaed thing - it is generated haskell code
13:18:47 <ChongLi> henk: folds are very powerful :)
13:20:18 <danilo2> Cale: I'm writing aobut it, brb
13:20:59 <henk> ChongLi: haskell generally is much more powerful than my mind is able to cope with …
13:21:10 <shachaf> I still wonder what people mean when they say rank-2 types should be inferrable.
13:21:31 <Cale> mauke, danilo2: anyway, if you want to know the real reason, I suspect you have to read the OutsideIn(X) paper
13:21:57 <StoneToad> hmm why does attoparsec's takeByteString work when I use parseOnly but only gives me Partial results when I use parse
13:21:58 <danilo2> Cale: look here (http://lpaste.net/98789). "bind" is custom do-binding function (used with RebindableSyntax). In this code, I want to be able to keep a function in variable (like "Pure testx") - but when it is passed thru bind, this error occures
13:22:15 <danilo2> Cale: Ok, thank you
13:22:23 <shachaf> Shouldn't the report specify the behavior in this case?
13:23:07 <Cale> danilo2: Why not give an explicit type signature to testx?
13:23:40 <Cale> danilo2: Basically, using this Bind class is going to be a nightmare
13:24:00 <Cale> danilo2: m1 and m2 determine m3, but m3 doesn't determine anything about m1 or m2
13:24:24 <henk> ChongLi: Thanks for the pointer; seems like what I’m looking for but I’ll need a few days to figure out how to (;
13:24:30 <Cale> and I suppose that isn't even the problem here
13:24:42 <Cale> But the fact that this X class doesn't have any fundeps at all
13:24:47 <ChongLi> henk: it's a bit complicated
13:25:04 <ChongLi> henk: what are you trying to accomplish overall?
13:25:10 <Cale> and even if it did, we don't know either of the type variables here
13:25:12 <ChongLi> there may just be a simpler solution
13:25:50 <danilo2> Cale: Why would it be a nightmare? Bind does only one thing - it looks if one of the lines is IO - if it is, then the result of function is IO. If none of the lines is IO, then the result is Pure. so m1 and m2 can be either IO or Pure
13:26:27 <henk> ChongLi: I’m not sure what to do: paste my complete code, try explain what I’m doing, or paste sample in and output to visualize what I’m doing, or even all of that? (:
13:26:29 <danilo2> Cale: m3 can determine something - if m3 is pure, than m1 and m2 is pure. If m3 is IO then either m1 or m2 or both are IO
13:26:35 <Cale> danilo2: because it'll be hard to infer from the type of the result what the types of the arguments are, so you'll find that very often you'll have to specify them explicitly
13:26:37 <danilo2> Cale: is there anything wrong with this ?
13:26:50 <ChongLi> henk: what are you doing with these time deltas?
13:27:42 <danilo2> Cale: Hmm, this is strange, but so far it works good - I've got a generated code, which has got over 1000 lines with lot of functions etc and it works without providing explicite types
13:27:57 <danilo2> Cale: do you have any better idea to do it ?
13:28:26 <Cale> Why not just generate different functions based on whether the arguments are pure or not?
13:29:05 <Cale> Like, if you have x :: a and f :: (a -> IO b), then you can just generate f x
13:29:33 <henk> ChongLi: They are part of the output. My program evaluates files of the form "ISO timestamp;some text" and reports endtime (the ISO timestamp), starttime (the timestamp of the line before), and delta (diff of these timestamps).
13:30:31 <ChongLi> henk: ahhh, to help understand a log file of some kind?
13:30:33 <ChongLi> I get it
13:31:12 <Cale> (That won't actually solve the problem with this X though
13:31:14 <Cale> )
13:31:22 <Cale> danilo2: What is this X class for?
13:32:16 <danilo2> Cale: I do not think generating each possible function would be easy. If a function has got 10 arguments, I would have to generate 10! functions or analyse how data passes inside (I have to rethink it)
13:32:39 <henk> ChongLi: It’s supposed to become a simple (to use) time/task-tracker (maybe usable as a simple diary too), also see https://projects.netwichtig.de/projects/sw-diddohs/wiki/Wiki although there is not much there yet …
13:32:51 <Cale> danilo2: Well, you always have two arguments to an application, I would think
13:33:11 <Cale> (the function, and the argument)
13:33:25 <danilo2> Cale: X is just a class, with no special meaning right now - It happened, that such code was generated - I'm using classes to mimic such behaviour, that I got nmethods bound to datatypes , (like classes in OO language)
13:33:54 <Cale> danilo2: You should translate OO classes into Haskell types, not Haskell classes.
13:34:37 <Cale> danilo2: If you had:
13:34:45 <Cale> data X a b = X (a -> b)
13:34:46 <arcke> how can I take elements from a list until I find a duplicate, for example f [0,1,0] would return [0,1]?
13:34:50 <Cale> or
13:34:54 <Cale> data X a b = X { fx :: a -> b }
13:35:05 <arcke> list can be infinite
13:35:08 <Cale> then I think the problem would go away
13:35:21 <Iceland_jack> arcke: You store the values already found so far
13:35:37 <danilo2> Cale: I'm translating it another way aroun, but I tink you will like it, so
13:35:42 <Iceland_jack> there is a function in Data.List that does this (nub) but don't check it out just yet if you're doing this to learn
13:36:06 <arcke> Iceland_jack: http://lpaste.net/98794
13:36:28 <danilo2> Cale: a "class" is translated just to a data type with fields inside, biut these fields does not encode methods. Then for each method I'm generating a datatype, like for "class Vector" with method "test"
13:36:46 <Cale> danilo2: Why wouldn't you include the methods?
13:36:54 <danilo2> Cale: I'm gneerating "data Handler_Vector_test = Handler_Vector_test".
13:37:32 <danilo2> Cale: because I want to be able to "attach" methods to classes after the definition - something like external defined methods. So I want user to be able to write "def Vector.newmethod: ... "
13:37:53 <Cale> So generate another datatype when they do that?
13:38:06 <Cale> You'll still want to carry methods with the objects
13:38:30 <Cale> The whole point of OO is that different objects of the same type can have different method implementations
13:39:11 <Cale> So it doesn't make so much sense to detach the methods from the objects, especially if you're translating to Haskell.
13:39:24 <arcke> Iceland_jack: takeWhile (\x -> not (x `elem` elements_found_so_far)) list in pseudocode
13:40:00 <arcke> Iceland_jack: just dont know how to store them
13:40:35 <danilo2> Cale: Oh, I see your point. But This is OO-like language. If you've got type of object, it has got just the set of methods.
13:40:47 <Cale> (To put that another way: the whole point of OO is that different objects can respond to the same set of messages in different ways)
13:41:38 <danilo2> Cale: Maybe OO is wrong word here. I just want have datatypes with methods, so we can write "v=Vector 1 2 3; v.test()" or something simmilar
13:41:58 <Cale> Yeah, it makes sense to put the methods in the object in that case.
13:42:48 <danilo2> Cale: maybe you are right, but will it make any difference then ?
13:43:05 <Cale> absolutely
13:43:07 <Cale> try it
13:43:22 <Cale> Just replace that class with a data declaration with a field for fx
13:43:40 <danilo2> Cale: I mean., right now I've got a typeclass "Call", and instances for each handler. If I tell "call Handler_Vector_f" - it results in this method (liberage coverage condition is kept this way)
13:43:58 <danilo2> Cale: But why would it be better?
13:44:34 <danilo2> Cale: Sorry if this is a simple question, but I do not see it yet and all informations you write are very improtant to me! :)
13:44:39 <Cale> danilo2: Well, you won't run into the problem you're having right now
13:45:09 <Cale> and in addition to that, you'll have the option to extend the language you're implementing with some new features easily :)
13:45:32 <wavewave> hi
13:45:43 <Cale> (i.e. because you're carrying around records of the method implementations, you could allow the users of your language to rebind the method implementations the same way they'd rebind any field)
13:46:31 <Cale> but even if you don't do that, it'll produce a much simpler typechecking problem for the Haskell compiler to solve
13:47:00 <Cale> So you'll also probably get faster compile times, and you won't run into this nonsense about difficult to solve typeclass constraints
13:47:02 <danilo2> Cale: the second point is good, but I think I will run in exactly the same problems. Look, If user is writing a lambda (in pseudohaskell - where dot allows for accesing methods): (\v -> v.test) - then it would need to use typeclasses, because I do not knwo what type "v" is. - and it would result in the same problems I have now, I think
13:47:24 <Cale> v could only have one type
13:47:38 <Cale> the type which has a field whose compiled name was test
13:47:49 <Cale> and it would be  (\v -> test v)
13:48:10 <jle`> hi wavewave
13:48:13 <Cale> You can do lots of things to ensure that different types of objects have distinct field names
13:48:30 <Cale> Just attaching sequential numbers to the field names would do
13:48:30 * wavewave waves jle`
13:48:35 <arcke> how can I write a function f that takes an infinte list and returns the part of the list until the first duplicate is found?
13:48:53 <danilo2> Cale: Ok, but what if a user writes "class Vector: def test: ..." and "class Car: def test: ..." - I want to support such situations and allow for writing (v.test) without knwoing if it is Vector or Car :(
13:49:24 <Cale> danilo2: Do you have a subtype relation in your language?
13:49:32 <danilo2> Cale: no
13:49:55 <jle`> arcke: do you want a higher order function?
13:50:00 <Cale> danilo2: Do you have types at all?
13:50:03 <wavewave> preflex: seen byorgey
13:50:03 <preflex>  byorgey was last seen on #haskell 1 day, 9 hours, 33 minutes and 4 seconds ago, saying: zcourts: that is an acceptable use of unsafePerformIO (in fact, that was the original motivation for including it)
13:50:11 <jle`> i assume you can do the explicit recursion version
13:50:52 <danilo2> Cale: yes, but I would love not to force user to use them - of course using allows for making faster / better code - but without them it should work. The types are VERY simmilar to haskells - the map 1:1 I think
13:51:05 <ChongLi> henk: zipWith may actually be more appropriate here
13:51:12 <ChongLi> since it's a bit higher level than fold
13:51:22 <Cale> danilo2: If the types are similar to Haskell's, then what's the type of test? :)
13:51:29 <arcke> jle`: type of function is [Integer]->[Integer], if there is a higher order function which can be used in the ceration, this is allright
13:51:50 <ChongLi> > let lst = [1..20] in zipWith (-) (tail lst) lst
13:51:51 <jle`> arcke: are you interested in the explicit recursion version?
13:51:51 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
13:52:20 <arcke> explicit is fine
13:53:02 <ChongLi> > let lst = randoms (mkStdGen 2303) :: [Int] in zipWith (-) (tail lst) lst
13:53:04 <lambdabot>  [-8508103404177261492,24862714953680259,-3954911353496477291,-15922614777550...
13:53:12 <ChongLi> hmm
13:53:31 <arcke> jle`: http://lpaste.net/98794 <- i want to grab the first part of a repeating string of decimals
13:53:40 <ChongLi> guess that doesn't make much sense :)
13:53:57 <danilo2> Cale: I wantet it to be something like "testx :: X v out => v -> x -> out"
13:56:25 <jle`> > let tilDup = go [] where go xs [] = []; go xs (y:ys) | y `elem` xs = xs | otherwise = go (xs++[y]) ys in tilDup (cycle [1,2,3])
13:56:26 <lambdabot>  [1,2,3]
13:56:45 <Cale> danilo2: The way that the type class machinery works, you'll have to know both the type of your object and the type of the result then. You won't be able to infer anything about the type of test, which will cause problems of exactly the sort that you're seeing.
13:57:06 <arcke> jle`: looks good
13:57:13 <henk> ChongLi: hm, yeah, I thought so too, because I do something similar in my current code, but with lists, but how do that with a Data.Map?
13:57:15 <jle`> you actually only need an Eq constraint
13:57:22 <jle`> so it'd be Eq a => [a] -> [a]
13:57:29 <jle`> actually
13:57:31 <jle`> :t elem
13:57:32 <arcke> yes, most general type
13:57:32 <lambdabot> Eq a => a -> [a] -> Bool
13:57:35 <jle`> yeah
13:57:52 <Guest09238> hi, i am quite new to haskell and i have a question, i tried to implement a function with monads. http://lpaste.net/98795 , anyone can help me out?
13:58:10 <ChongLi> henk: toAscList :)
13:58:35 <danilo2> Cale: If i might, I will tell you shortly how it woks right now - I would be very thankfull If you tell me if it makes sense (wih current assumptions) to tchange it to use datatypes with functions inside, as you told before
13:59:16 <jle`> Guest09238: your rhs of a >>=
13:59:20 <jle`> must return an item in a monad
13:59:26 <jle`> so you have to return a MaybeOne
13:59:43 <jle`> um wait let me read it again
13:59:47 <danilo2> Cale: right now I've got a type class Member, which works as folllows: If I write "member (P::P "test") v" - it gives me handler for a function, like "Handler_Vector_test". Than I can use "call" on it, to get the function and use it
14:00:02 <Guest09238> ok how do i do that?
14:00:14 <jle`> oh
14:00:24 <jle`> what is the type of lefthalf?
14:00:31 <Cale> Guest09238:  lefthalf = xDividedByy // denominator
14:00:39 <jle`> what is the type of righthalf?
14:00:42 <jle`> they are diff.
14:00:50 <Cale> Guest09238: You need to run that.
14:00:59 <Cale> By the way, you really should use do-notation
14:01:09 <danilo2> If I will change the idea to use datatypes instead, like "data Vector test = Vector {test :: test} It will still work, but would require me to make new datatypes, when external method is defined (which now works automatically)
14:01:12 <jle`> he might be trying to get the hang of bind
14:01:14 <jle`> but....
14:01:18 <Guest09238> yeah righthalf is Double i guess
14:01:26 <jle`> your indentation
14:01:34 <jle`> makes this really hard to read and understand at a glance
14:01:42 <Guest09238> ok, sorry for that
14:01:42 <Cale> danilo2: Well, whatever works for you, I guess
14:01:52 <jle`> oh no
14:01:59 <jle`> that's nto a criticism
14:02:07 <jle`> i'm saying that it might make it harder for you to understand it yoursef
14:02:14 <henk> ChongLi: hehe, I actually wanted to avoid that kind of conversions by switching to Data.Map (:
14:02:19 <danilo2> Cale: ok, thank you very much :) I will try both versions. Still I think the problem would be the same, because I have to use typclasses :(
14:02:33 <bb010g> Do notation can never hurt for debugging
14:03:08 <Cale> danilo2: I'd probably not even try for such a shallow translation to Haskell, myself.
14:03:25 <jle`> Guest09238: really your error message should sort of give you a good clue
14:03:31 <Guest09238> what is going wrong in the righthalf there? How did it change type all of a sudden. Isnt there any way to typecast a variable from Double to MaybeOne Double?
14:03:47 <jle`> yes
14:03:52 <jle`> but it's not typecasting
14:03:59 <Cale> Guest09238: no, there isn't, you can apply the return function though
14:03:59 <jle`> you actually...defined the function
14:04:02 <jle`> earlier
14:04:14 <jle`> think...what would the type signature be?
14:04:27 <jle`> turnFromDoubleIntoMaybeOneDouble :: Double -> MaybeOne Double
14:04:30 <bb010g> Guest09238: You just use the MaybeOne function.
14:04:33 <jle`> turnIntoMaybeOne :: a -> MaybeOne a
14:04:54 <Cale> Or yes, you can use Result
14:04:56 <danilo2> Cale: why not? Are you talking about translating just to LLVM or something in between?
14:04:56 <jle`> bb010g: MaybeOne is the type constructor here, not the data constructor
14:04:59 <Guest09238> ok lets try it
14:05:01 <jle`> but yeah
14:05:19 <jle`> you should be using return in this case because that's the semantics/meaning of return
14:05:24 <bb010g> jle`: Oh, sorry. *derp*
14:05:27 <jle`> turnIntoMaybeOne :: a -> MaybeOne a
14:05:32 <jle`> return :: a -> MaybeOne a
14:05:33 <jle`> :)
14:05:45 <jle`> return is supposed to represent a simple promotion
14:05:47 <jle`> of sorts
14:06:23 <jle`> but
14:06:35 <jle`> turning rightHalf into a MaybeOne is probably not the final solution to your problem
14:06:54 <jle`> unless your solution involves writing a Num instance for MaybeOne
14:06:55 <Cale> danilo2: Well, even if I were compiling to Haskell, I would figure out what the semantics of each of the constructions in my language did, and then base the implementation on that. In the end, I probably wouldn't make any use of type classes or even data declarations.
14:06:57 <jle`> (which it hopefully shouldn't)
14:07:25 <jle`> basically, haskell sees the expression "x - y"
14:07:29 <jle`> remember the type of (-)
14:07:31 <jle`> :t (-)
14:07:32 <lambdabot> Num a => a -> a -> a
14:07:38 <jle`> (-) has to take the exact same type on both sides
14:07:45 <Cale> danilo2: and just implement all values in my language as values of a single Haskell type.
14:07:46 <Guest09238> hmm
14:07:49 <jle`> so on the left hand side you have a MaybeOne Double
14:07:55 <jle`> on the right hand side it expects a MaybeOne Double
14:07:59 <jle`> but in the end this doesn't even really matter
14:08:05 <jle`> because you can't subtracct MaybeOne Doubles anyway
14:08:15 <jle`> (at least without a Num instances, but this path is in general not advised)
14:08:21 <Cale> danilo2: and let my type checker ensure that all the operations on that type were going to be sound
14:08:26 <Cale> (not Haskell's type checker)
14:08:29 <jle`> what you should be doing
14:08:37 <jle`> is...instead of making both sides MaybeOne Double's
14:08:38 <bb010g> Isn't this a good place for Functor?
14:08:48 <jle`> making both sides Double's
14:08:52 <bb010g> (fmap (-))
14:09:05 <Cale> Guest09238: can you please type  /nick  followed by some name for yourself?
14:09:10 <jle`> bb010g: hm...a functor can't work here
14:09:20 <jle`> fmap (-) will turn a MaybeOne Double
14:09:29 <jle`> into a MaybeOne (Double -> Double)
14:09:34 <danilo2> Cale: Hmm but is it even possible if I want allow user to create custom datatypes with custom types and custom functions?
14:09:42 <Cale> danilo2: of course
14:09:45 <jle`> :t fmap (-) (Just 1)
14:09:46 <lambdabot> Num a => Maybe (a -> a)
14:09:54 <jle`> and then...what do you do with that?
14:10:00 <bb010g> :t (-) <*> (Just 1)
14:10:01 <lambdabot>     Couldn't match expected type `Maybe (a0 -> b0)'
14:10:01 <lambdabot>                 with actual type `a1 -> a1 -> a1'
14:10:01 <lambdabot>     In the first argument of `(<*>)', namely `(-)'
14:10:19 <Iceland_jack> > fmap negate (Just 1)
14:10:20 <lambdabot>  Just (-1)
14:10:45 <bb010g> :t (<*>) (-)
14:10:45 <lambdabot> Num a => (a -> a) -> a -> a
14:10:48 <danilo2> Cale: Would you be so nice and tell me how would you translate 2 different user data types this way to Haskell? Not exactly - just as idea, because I cannot see it yet
14:10:52 <David001> lol thousand davids in here
14:11:22 <Cale> danilo2: If the language were really dynamic to a fault, then perhaps one of the cases in my Value type would be a mapping from indices of some type (or even strings, lol) to values.
14:11:24 <jle`> haha
14:11:54 <David001> let denominator = zDividedBys - yDividedBys works
14:12:01 <David001> why cant the right and left do the same
14:12:12 <jle`> because the types
14:12:13 <David001> i really dont get it, it all works out, untill the end
14:12:20 <jle`> if you want
14:12:25 <jle`> you can put type signatures on all of your things
14:12:29 <jle`> and you'll see
14:12:29 <David001> in what line is it all turning to doubles then?
14:12:30 <danilo2> Cale: oh I see, but I want to use the Haskell compiler to get fast code - right now I think I can get code as fast as handwritten - then every operation would have an overhead - am I wrong ?
14:12:35 <jle`> zDividedBys :: Double
14:12:38 <jle`> yDividedBys :: Double
14:12:44 <Cale> David001: whenever you use // remember you're creating a new MaybeOne structure that you need to take apart
14:12:46 <jle`> rightHalf :: Double
14:12:52 <jle`> leftHalf :: MaybeOne Double
14:13:17 <Cale> danilo2: Well, you have to pay some price for dynamically runtime-adjustable datatypes.
14:13:31 <jle`> it might be a good exercise to go through and manually specify the types of all your assigments
14:13:33 <Cale> danilo2: If you want to be more efficient, then you have to work out the layout at compile time
14:13:42 <Cale> danilo2: in which case, perhaps an array would be fine
14:13:58 <David001> ah, so i need to get rid of the MaybeOne Double in lefthalf
14:14:06 <jle`> hm
14:14:12 <jle`> 'get rid of' is one way to think of it
14:14:12 <Cale> David001: yeah, you can take it apart using >>=
14:14:13 <David001> instead of trying to fix a MaybeOne Double in the right
14:14:32 <jle`> another way to think of it would be
14:14:39 <jle`> "do something with the Double in lefthalf"
14:14:49 <jle`> just like you did something with the Double in z//s
14:14:56 <danilo2> Cale: I do not want runtime adjustable datatypes! When I was talking about extenral methdos - I was tlaking about methods defined in other files than the class is - so it is almost like type class instances. They are known at compile time - all :)
14:14:59 <jle`> z//s gave you a MaybeOne Double
14:15:05 <jle`> but you had no problem using its Doubl result
14:15:13 <jle`> (zDividedBys)
14:15:19 <danilo2> Cale: If user imports some files, it can use only these datatypes and methods, which get imported
14:15:25 <Cale> danilo2: In that case, you can easily just collect them all up and compile the program all at once.
14:15:55 <Cale> danilo2: But even so, it's probably a good idea to have some representation for the values in your language
14:15:58 <jle`> now xDividedbyy // denominator gives you a MaybeOne Double
14:16:01 <dleedev> hi, what are applicative functors in terms of CT?
14:16:13 <jle`> you can use that Double the same way you used the Double 'inside' z//s
14:16:15 <danilo2> Cale: yes, but then if the program is really big, it would be good to compile some files and just recompile changed files later and link them - just as ghc does with type class instances?
14:16:35 <Cale> dleedev: Lax monoidal functors
14:16:36 <jle`> strong lax monoidal functors or something
14:16:55 <Cale> yeah, perhaps strong is a good thing to include too
14:17:00 <dleedev> what would <*> be?
14:17:18 <Cale> dleedev: The way to see the connection is by considering  liftA2 (,)   as the primitive
14:17:23 <Cale> :t liftA2 (,)
14:17:23 <lambdabot> Applicative f => f a -> f b -> f (a, b)
14:17:25 <jle`> don't really know what it means admittedly but i've read it enough times to be able to recite it by memory
14:17:32 <Cale> or perhaps its uncurrying
14:17:37 <Cale> :t uncurry (liftA2 (,))
14:17:37 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
14:17:49 <Cale> ^^ this will look more like what you see in CT
14:18:00 <Cale> http://en.wikipedia.org/wiki/Monoidal_functor
14:18:06 <Cale> Look at the phi_A,B there
14:18:31 * hackagebot gloss 1.8.1.2 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.8.1.2 (BenLippmeier)
14:18:37 <Cale> and then I would be ()
14:18:55 <Cale> Both the black bullet and the tensor product sign are (,) in Haskell
14:18:59 <dleedev> Cale: so what I read is that monoidal functor is a functor that preserves monoidal structure
14:19:05 <Cale> and I_C and I_D are both ()
14:19:14 <dleedev> does that mean that the things that f wraps must be a Monoid?
14:19:33 <Cale> and so you have phi_A,B : (F A, F B) -> F (A,B)
14:19:35 <dleedev> :t <*>
14:19:35 <Cale> right?
14:19:36 <lambdabot> parse error on input `<*>'
14:19:39 <Cale> :t uncurry (liftA2 (,))
14:19:40 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
14:19:43 <Cale> ^^ look :)
14:19:53 <David001> ok now i've tried most of them, but i still get the error
14:19:59 <Cale> and then you need  phi : () -> F ()
14:20:05 <Cale> :t pure ()
14:20:05 <lambdabot> Applicative f => f ()
14:20:18 <Cale> :t (\() -> pure ())
14:20:18 <lambdabot> Applicative f => () -> f ()
14:20:33 <Cale> So, that makes the definitions line up
14:20:44 <Cale> From liftA2 (,), you can get back <*>
14:21:14 <lllllllllllll> what does "Explicit data flow ensures that the value of an expression depends only on its free variables." mean? i mean \x -> len x depends on x also
14:21:28 <jle`> z // s >>= \zs -> y//s >>= \ys -> x//y >>= \xy -> xy//(xy - ys) >>= \ls -> z//x >>= return (ls - (ys + zx))
14:21:47 <Cale> :t fmap (\(f,x) -> f x) . uncurry (liftA2 (,))
14:21:48 <lambdabot> Applicative f => (f (t -> b), f t) -> f b
14:21:56 <Cale> :t curry (fmap (\(f,x) -> f x) . uncurry (liftA2 (,)))
14:21:57 <lambdabot> Applicative f => f (t -> b) -> f t -> f b
14:21:57 <jle`> er the last >>= should be >>= \zx ->
14:22:06 <jle`> David001: is it the exact same error?
14:22:23 <Cale> and from (\() -> pure ()), you can get back pure
14:22:32 <David001> i got a larger one
14:22:33 <David001> even
14:22:39 <David001> its not eating my code
14:22:41 <dleedev> Cale: hmm... thanks
14:22:47 <dleedev> I think that's way over my head for now
14:23:31 * hackagebot gloss-raster 1.8.1.2 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.8.1.2 (BenLippmeier)
14:23:40 <dleedev> I don't even understand what monoidal category means
14:23:56 <Cale> dleedev: anyway, the connection between the CT and Haskell is kind of especially weak here, because the operations which are actually convenient to use in Haskell look fairly different, even if there's a translation back and forth to the ones which look like the CT
14:24:01 <Cale> oh, in that case, yeah :)
14:24:20 <dleedev> it's a category that's dependent upon a functor... and I don't get how that can be
14:24:25 <Cale> Are you interested in mathematics, or just in learning about Haskell?
14:24:36 <dleedev> Cale: both
14:24:42 <dleedev> Cale: well, more haskell
14:24:48 <jle`> David001: can you paste it?
14:24:48 <dleedev> Cale: but I want to understand the underpinnings
14:24:55 <jle`> is it a syntax error or a type error?
14:25:09 <David001> type error, still
14:25:11 <David001> :(
14:25:47 <jle`> David001: paste it :)
14:25:51 <Cale> The category theory is not going to be super-helpful to you here. It's much easier to understand these things as they apply to Haskell with (,) and () already chosen than to add in all the extra details.
14:26:21 <Iceland_jack> Cale: I've basically told dleedev this before
14:26:34 <Cale> However, if you know stuff about monoidal categories, it's also nice for understanding one particular way of looking at monads.
14:27:01 <Cale> (there's no shortage of equivalent definitions of monad)
14:27:04 <dleedev> Cale: well, I understand how application functors work in Haskell: you can lift a functor with pure, and apply that over the values wrapped in the functor, right?
14:27:07 <jle`> David001: I annotated your original paste with an indentation scheme that makes things a lot simpler to understand
14:27:23 <jle`> your type error will still be there but it might makes things easier to read
14:27:25 <jle`> at least
14:27:37 <Cale> dleedev: I don't understand your use of words there
14:28:07 <dleedev> Cale: basically, you can partially apply a functor over functors
14:28:08 <jle`> and in this indentation case it will be a lot easier to identify and spot type errors
14:28:21 <Cale> dleedev: Remember that the functor is a type-level thing, never a value.
14:28:40 <Cale> dleedev: At least, in Haskell, we don't deal with functors at the value level.
14:28:48 <dleedev> Cale: whoops, I said "lift a functor", when I meant "lift a function"
14:29:06 <dleedev> Cale: and I said "apply a functor" instead of "apply a function"
14:29:09 <jle`> dleedev: in haskell partially apply is the same as applying, isn't it?
14:29:12 <David001> http://lpaste.net/98795
14:29:16 <dleedev> jle`: yeah
14:29:48 <dleedev> > (+) <$> Just 1 <*> Just 2
14:29:50 <lambdabot>  Just 3
14:30:03 <David001> ok i think i like your notation style
14:30:17 <jle`> David001: actually
14:30:21 <jle`> you don't even need the nested parentheses
14:30:25 <jle`> i left them in there for demonstration
14:30:42 <jle`> but you can actually drop all of the parentheses from using >>=
14:30:57 <jle`> if you do though...what's actually going on is a little more obscured
14:31:09 <dleedev> Cale: so what I see is that you can lift a function into a functor's target category and apply it to values in the functor's target category
14:31:14 <jle`> in real life though we would use do notation
14:31:16 <dleedev> Cale: is that a bad understanding?
14:31:17 <Cale> But yes, you have pure :: a -> F a, and (<*>) :: F (a -> b) -> F a -> F b, where pure v will be the computation which does nothing, except to produce v as its result, and running the computation x <*> y will run both x and y (in some order), and apply the function resulting from x to the value resulting from y
14:31:23 <jle`> so it's more or less a moot point
14:31:37 <jle`> David001: also i'm not really sure what you changed?
14:31:46 <Cale> That's the computational interpretation anyway
14:31:58 <dleedev> Cale: but is that a proper computational interpretation?
14:31:59 <David001> (z // x) >>= -> \zx
14:32:09 <Cale> If you want less analogy, then you just write down the laws that pure and (<*>) are required to satisfy
14:32:15 <Cale> dleedev: yes
14:32:19 <jle`> that...doesn't feel like it's proper syntax
14:32:27 <Cale> syntax?
14:32:29 <jle`> do you mean >>= \xz -> ?
14:32:31 <Cale> oh
14:32:38 <Cale> other thread of conversation :)
14:32:39 <jle`> Cale: sorry, referring to David001
14:32:41 <jle`> haha
14:32:42 <Cale> yes
14:32:56 <David001> yea i mean that one
14:33:00 <jle`> okay...so earlier
14:33:05 <jle`> you had z//s
14:33:06 <jle`> right?
14:33:11 <jle`> which returned a MaybeOne Double
14:33:12 <David001> yea
14:33:18 <jle`> but you were able to work with the double "inside" that MaybeOne
14:33:18 <dleedev> Cale: the thing I don't understand is how any of that can be considered "monoidal"... or even more basically, what part of that is considered "applicative"
14:33:20 <Cale> dleedev: Essentially all of the time in Haskell, the computational interpretation will be the right one
14:33:30 <David001> yes
14:33:33 <jle`> now....you have xdivy // den
14:33:38 <jle`> which gives you a MaybeOne Double
14:33:47 <jle`> but you again want to work with the double *inside* that MaybeOne
14:34:02 <Cale> dleedev: The monoidal category structure on the category of Haskell types just takes (,) (at the type level) as the operation on objects, and () as the unit for that operation.
14:34:03 <jle`> you did this exact same thing before, more or less
14:34:08 <jle`> for the z//s
14:34:13 <jle`> now do it for xdivy // den
14:34:32 <jle`> it might be a little more obvious to see the parallel in the re-indented version
14:34:35 <dleedev> Cale: and what's the operation?
14:34:42 <dleedev> Cale: (,) is the operation?
14:34:46 <Cale> i.e. (,) is the bifunctor ⊗ which is required
14:34:57 <Cale> and () is the I, in Wikipedia's description
14:35:01 <Cale> http://en.wikipedia.org/wiki/Monoidal_category
14:35:03 <jle`> remember, you did (z//s) >>= \zdivs -> ........ to "work with" the Double inside the MaybeOne Double and named it zdivs
14:35:05 <David001> k i will try that
14:35:06 <dleedev> Cale: so then building up the monoid value would be nested tuples?
14:35:12 <jle`> so you are going to want to do the exact same thing
14:35:17 <jle`> but with xdivy // den
14:35:24 <Cale> dleedev: There's not actually an ordinary monoid
14:35:27 <jle`> and naming it lefthalf
14:35:42 <Cale> dleedev: But the objects of the category almost become a monoid
14:36:07 <dleedev> Cale: I don't understand what "ordinary monoid" and "almost a monoid" mean
14:36:10 <Cale> dleedev: Instead of associativity and unit equations, you have instead isomorphisms
14:36:37 <Cale> Normally with a monoid, you require that a * (b * c) = (a * b) * c
14:36:42 <dleedev> Cale: yeah
14:36:45 <Cale> but (a,(b,c)) and ((a,b),c) are not the same type
14:36:52 <dleedev> yeah
14:36:59 <Cale> however, there's a canonical natural isomorphism
14:37:22 <Cale> ("natural" being treatable for the most part as "polymorphic" in the context of Haskell)
14:37:43 <Cale> and similarly, ((),a) is not the same type as a
14:37:51 <Cale> but there's an isomorphism
14:39:01 <dleedev> an isomorphism to what?
14:39:12 <Cale> ((),a) -> a
14:39:16 <Cale> and a -> ((),a)
14:39:23 <dleedev> what about ((a,b),c)?
14:39:34 <dleedev> (a,b,c)?
14:39:37 <Cale> ((a,b),c) -> (a,(b,c))
14:39:41 <Cale> and vice versa
14:39:52 <jle`> David001: once you are able to name and work with the double inside (xdivy//den)...you have one more problem, and that is that the right hand side of >>= is supposed to be a MaybeOne Double, and not a Double.  So you can't just say lefthalf - righthalf.  you have to "wrap it" or "put it in" a MaybeOne first.  and we mentioned this earlier, there is a function :: a -> MaybeOne a, that you wrote earlier (it
14:39:54 <jle`> rhymes with beturn) that can do this for you
14:40:21 <Cale> dleedev: We can even make this a symmetric monoidal category by throwing in the isomorphism (a,b) -> (b,a)
14:40:40 <dleedev> what do you call two objects that have an isomorphism?
14:40:44 <dleedev> isomorphic?
14:40:46 <Cale> yes
14:40:48 <dleedev> or is that not even a thing?
14:40:49 <jle`> David001: i have to go now but i hope you can figure it out from here; if not the good peoples of #haskell should be able to help
14:40:59 <Cale> That is a thing
14:41:27 <dleedev> so are you talking about the objects inside a category being isomorphic or two categories being isomorphic?
14:41:37 <Cale> Actually, you have to gloss over some details for the "isomorphisms" to actually work out (if we only talk about fully defined values of the types, then everything is okay)
14:41:45 <Cale> objects
14:42:03 <David001> jle' : thank you so much
14:42:10 <David001> i am trying to work it all out
14:44:32 <Cale> dleedev: so basically, (,) and (), and the associator function ((a,b),c) -> (a,(b,c)) (and its inverse), and the left and right unitors ((),a) -> a (and its inverse) and (a,()) -> a make Hask into a monoidal category
14:46:36 <dleedev> Cale: by (,) do you mean a function or a type?
14:46:51 <Cale> type constructor
14:47:08 <Cale> same with (), I was referring to the type
14:47:53 <dleedev> is unitor a function?
14:47:56 <Cale> It's the category of Haskell types and total Haskell-definable functions between them, in this case.
14:48:13 <Cale> yes, the arrows in this category are functions, the objects are types
14:49:15 <dleedev> a monoid is a triple, of which the first is a set of values, right?
14:49:20 <dleedev> in this case, what goes inside the set?
14:49:38 <Cale> No
14:49:45 <Cale> er
14:49:47 <Cale> yes
14:49:48 <Cale> heh
14:50:03 <Cale> Well, we're in the context of talking about monoidal categories
14:50:15 <Cale> so a monoid object in a monoidal category is an object of that category M
14:50:27 <Cale> together with
14:50:39 <Cale> eta: I -> M
14:50:50 <Cale> mu: M ⊗ M -> M
14:50:54 <Cale> satisfying some laws
14:51:09 <dleedev> all types?
14:51:17 <Cale> What do you mean all types?
14:52:12 <Cale> A monoidal category is a category equipped with some additional stuff which is required in order for us to define what it means to be a monoid in that category.
14:52:16 <dleedev> wait... eta and mu come in for monads, not monoids
14:52:31 <Cale> The similarity is intentional
14:53:09 <Cale> A monad on a category C is a monoid object in the category of endofunctors C -> C, where the ⊗ is composition of functors, and I is the identity functor
14:53:41 <Cale> An ordinary monoid is a monoid object in the category of sets, where the ⊗ is the Cartesian product of sets, and I is some one element set.
14:54:00 <HairyDude>     No instance for (IsString bytestring-0.9.2.1:Data.ByteString.Internal.ByteString)
14:54:02 <dleedev> Identity functor means an object is mapped to itself?
14:54:17 <Cale> yeah, and every arrow is mapped to itself as well
14:54:45 <Cale> HairyDude: Hooray!
14:54:58 <HairyDude> Cale: I take it you hate overloaded strings? :)
14:55:07 <Cale> HairyDude: I do when they're used for ByteString
14:55:11 <HairyDude> ah
14:55:26 <Cale> ByteString is just a string of bytes
14:55:37 <Cale> without a particular choice of text encoding
14:55:41 <dleedev> did you mean "ordinary monoid" as a technical term?
14:55:48 <dleedev> or just any monoid?
14:55:56 <Cale> dleedev: A monoid in the sense of classical mathematics
14:56:36 <HairyDude> I guess I should be using Text, but the data structure I'm working with (Data.Trie) uses ByteString.
14:56:37 <Cale> dleedev: It's common for category theorists to say "monoid" and mean "monoid object in some monoidal category" whenever there's little risk of confusion.
14:56:51 <HairyDude> Is there an efficient Text-indexed map type?
14:57:01 <Cale> HairyDude: You could always use encode and decode :)
14:57:10 <HairyDude> ... yeah, but I don't wanna :)
14:58:02 <HairyDude> I guess I'll just use Map for now
14:58:10 <HairyDude> performance is hardly critical at this point
14:58:16 <Cale> dleedev: Like, if I said "a monoid in the category of endofunctors", then I'd probably mean this generalised notion of monoid object
14:58:33 <Cale> dleedev: But without context, "monoid" usually means a monoid in the category of sets :)
14:58:42 <mzero> and there is always HashMap if you don't need the ordered property of Map
14:59:12 <Cale> mzero: HashMap is only sometimes faster than Map though. I've often been surprised.
14:59:27 <dleedev> Cale: hmm.. when I hear monoid, I picture a category with one object, and one arrow from that object to itself
14:59:37 * HairyDude looks at HashMap
14:59:44 <dleedev> Cale: and the object itself has as an element some unit element
14:59:48 <Cale> dleedev: You should picture many arrows from that object to itself!
14:59:50 <mzero> True - depends pretty heavily on your data characteristics
15:00:00 <Cale> dleedev: What you described would be a trivial monoid
15:00:26 <Cale> dleedev: If the object only has its identity arrow, then composing that with itself will just get you the identity arrow again
15:00:27 <dleedev> Cale: for example, the object will be N, and the arrow would be +, and the unit would be 0 within the object N
15:00:46 <Cale> Okay, you misunderstood how monoids are categories
15:01:23 <Cale> To treat the natural numbers as a one-object category, you would have some single object, let's call it X, the name doesn't matter
15:01:42 <Cale> X has no discernable internal structure, we don't care about that at all, it's just there for us to put arrows on
15:02:09 <Cale> and then we take the set of arrows X -> X to be the natural numbers
15:02:18 <Cale> and composition of those arrows to be addition
15:02:28 <Cale> 0 is then the identity arrow X -> X
15:02:50 <dleedev> Cale: ah, yes, I think I recall this image of monoid
15:02:52 <Cale> and the composition is associative because addition is associative
15:03:12 <dleedev> Cale: so when someone is speaking about monoids in terms of CT, they always have this in mind?
15:03:16 <David001> Cale: im still stuck, can you help me ?
15:03:31 <dleedev> Cale: where the values of the monoid are arrows, and the operator is arrow composition?
15:03:32 <Cale> dleedev: Not always, there's this generalised notion of monoid object
15:03:58 <Cale> this definition corresponds to the ordinary definition of a monoid in the category of sets
15:04:12 <Cale> But we can have monoid objects in other categories
15:04:19 <Cale> David001: sure
15:04:25 <Cale> David001: What's up?
15:04:54 <dleedev> Cale: "category of sets" means that "arrows are elements of sets"?
15:05:12 <Cale> dleedev: hm?
15:05:18 <David001> its still the problem with http://lpaste.net/98795, it should return a value of MaybeOne Double, but i do some math with Double values, but how do i convert the outcome back to MaybeOne Double
15:05:19 <David001> ?
15:05:33 <dleedev> Cale: because before, you said that the arrows are the natural numbers
15:05:35 <Cale> David001: You could apply the Result function
15:05:48 <Cale> David001: or return, which is the same
15:06:05 <David001> can you type an example? like how the syntax would be in my case?
15:06:11 <Cale> dleedev: Yes, in a category, the arrows between any given pair of objects are an arbitrary set
15:06:27 <Cale> dleedev: and so we can take that set to be the set of natural numbers if we please
15:06:44 <Cale> return (lefthalf - righthalf)
15:07:13 <Cale> But in the code you linked, there's still a type error because of lefthalf :: MaybeOne Double
15:07:28 <dleedev> Cale: and so is it common to have sets be represented by a set of arrows, rather than an object representing a set?
15:07:40 <David001> ok and how can i turn that to Double?
15:07:41 <Cale> dleedev: I don't understand that question
15:08:16 <Cale> David001: Well, you already did a similar thing several times in your code
15:08:32 <David001> the lambda notation you mean?
15:08:34 <Cale> Use >>=
15:10:00 <dleedev> Cale: the set of natural numbers can be represented as an object in a category. arrows from that object to itself can be considered functions on natural numbers. but another way to represent natural numbers is to make each number an arrow. and the composition of arrows can be viewed as a binary operator on natural numbers.
15:10:29 <dleedev> boils down to: 1. natural numbers can be an object in a category. 2. natural numbers can be arrows in a category.
15:10:48 <Cale> David001: see my annotation at the end: http://lpaste.net/98795
15:10:49 <dleedev> do CTists usually use 2?
15:11:07 <David001> Cale: omg! Works!!
15:11:17 <David001> Cale: spend nearly one hour at it!
15:11:17 <Cale> dleedev: They do both all the time
15:11:22 <David001> Cale: thanks!
15:11:29 <dleedev> Cale: so how do I know when they're doing what?
15:11:50 <dleedev> Cale: what terminology do they use to indicate "a set is an object" versus "elements of a set are arrows"?
15:11:50 <pingu> Does anyone use the LambdaCase extention?
15:12:19 <pingu> It's kind of neat, but, seems to me that it will confuse people.
15:12:26 <pingu> Have most people even heard of it?
15:13:06 <Cale> dleedev: When you define a category, you say explicitly what the collection of objects of the category is, what the collections of arrows between each pair of objects are, what the rule is for composing any pair of arrows which line up end to end, and you prove the existence of identity arrows, and that the composition of arrows that line up end to end is associative.
15:13:26 <Cale> dleedev: That is, the objects and arrows of a category are *arbitrary mathematical objects of any kind*
15:13:56 <Cale> dleedev: category theory itself will never "look inside" them
15:14:17 <dleedev> Cale: sure, but isn't there a convention?
15:14:30 <Cale> All that matters is how arrows are composed to get other arrows, and which arrows exist and are composable
15:14:33 <dleedev> Cale: for example, "category of endofunctors"... or "category of sets"
15:14:43 <dleedev> Cale: does that mean endofunctors are objects, or arrows?
15:14:47 <Cale> objects
15:15:11 <dleedev> Cale: so the convention is that "category of <a>" means category where <a> is an object?
15:15:30 <Cale> Usually when you say "category of Xs", you mean the category whose objects are Xs.
15:15:41 <dleedev> Cale: OK, and I can rely on that convention, right?
15:15:52 <Cale> and whose arrows are whatever the usual structure-preserving maps between objects of that sort are
15:16:06 <Cale> For the most part, you can rely on it
15:16:12 <dleedev> OK, that's reassuring
15:16:30 <dleedev> I think it's small things like this that help
15:16:39 <Iceland_jack> Normally you'll see something like “Category of <objects> and <arrows>”
15:16:50 <dleedev> especially in CT, where things can quickly go from being objects in one category to arrows in another category
15:16:54 <Cale> Yeah, if you want to be more specific, then that's a good way to do it
15:17:19 <Iceland_jack> It's usually somewhat clear from context
15:17:20 <Cale> Of course, in general, you're going to have to specify all the data I mentioned
15:17:41 <Cale> But usually you can rely on people not to interpret what you said maliciously :)
15:18:10 <Cale> For example, there's a category whose objects are sets, and whose arrows are relations between those sets
15:18:13 <Cale> (not functions)
15:18:26 <Cale> But nobody would guess that's what you meant by "category of sets"
15:18:45 <codesoup> why does "assocs $ runSTArray $ do ..." work but "assocs . runSTArray $ do ..." gives me errors (using ghci)
15:18:51 <Iceland_jack> codesoup: Magic!
15:18:58 <dleedev> and if you say monoid and category within the same sentence, do you usually mean the elements of the monoid are arrows in the category, and the operator of the monoid is arrow composition?
15:19:20 <Iceland_jack> codesoup: http://stackoverflow.com/questions/9468963/runst-and-function-composition
15:19:24 <Cale> codesoup: Just curious, which version of GHC is that?
15:19:30 <dleedev> Cale: are you saying that "category of sets" does not mean "a category whose objects are sets, and whose arrows are relations between those sets"?
15:19:43 <dleedev> Cale: because that's exactly what I thought you meant
15:19:50 <Cale> codesoup: There is an awful awful hack in some versions of GHC where $ gets special treatment
15:19:56 <Iceland_jack> dleedev: There are *many* categories whose objects are sets, this is getting a bit OT though
15:20:12 <codesoup> Cale, latest haskell platform on windows. just wrote a sieve of eratosthenes example
15:20:39 <Cale> dleedev: right, if someone says "the category of sets", you should assume they mean the most common case of the category whose objects are sets and whose arrows are functions.
15:21:20 <dleedev> Cale: ah, are you differentiating between relations and functions?
15:21:33 <Cale> codesoup: when you type ghci, what version number is displayed? 7.6.3?
15:21:36 <Iceland_jack> dleedev: Well they're not the same thing
15:21:48 <Cale> dleedev: yes, those are different things
15:21:50 <scshunt> dleedev: all functions are relations, but some relations are not functions
15:21:56 <codesoup> Cale, yes 7.6.3
15:22:03 <Cale> codesoup: interesting, okay
15:22:29 <Cale> codesoup: Yeah, it's basically that there's a stupid hack. GHC typechecks $ differently from anything else.
15:22:42 <Cale> combined with
15:22:46 <Cale> :t runSTArray
15:22:48 <lambdabot> Not in scope: `runSTArray'
15:22:50 <Cale> :t runST
15:22:50 <lambdabot> (forall s. ST s a) -> a
15:23:00 <Cale> (runSTArray is similar in this regard)
15:23:19 <Iceland_jack> There is also some special magic in [a,b,c,…]
15:23:23 <Cale> The (forall s. ST s a) there means that runST *requires* an explicitly polymorphic parameter
15:23:37 <Iceland_jack> some things type check using the literal notation but not using conses
15:23:46 <dleedev> This was lost in the midst of the questions: if you say monoid and category within the same sentence, do you usually mean the elements of the monoid are arrows in the category, and the operator of the monoid is arrow composition?
15:23:49 <Cale> But GHC won't unify a type variable with one of these "polytypes" while inferring types
15:23:58 <Cale> :t (.)
15:23:59 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:24:17 <Cale> i.e. it won't match "a" with (forall s. ST s a')
15:24:20 <Cale> in that type
15:24:21 <bitemyapp> rtpg: <3
15:24:50 <rtpg> \o
15:24:57 <Iceland_jack> dleedev: Depends
15:25:16 <bitemyapp> rtpg: people that use weak-sauce languages get touchy about how you use their toys :)
15:25:30 <dleedev> Iceland_jack: what about "monoid in the category of endofunctors"?
15:25:50 <dleedev> Iceland_jack: are the monoid values the arrows?
15:25:55 <bitemyapp> dleedev: well if you learn a category, endofunctor, and monoid are - it begins to make a lot more sesne.
15:25:58 <bitemyapp> sense*
15:26:00 <rtpg> slightly, this place has spoiled me
15:26:00 <bitemyapp> what a*
15:26:04 <bitemyapp> okay I can't type.
15:26:15 <dleedev> bitemyapp: I have a basic sense of what those are
15:26:27 <Iceland_jack> dleedev: #haskell is *not* the place to learn category theory
15:26:31 <dleedev> bitemyapp: it's just when they're used together, so that I get certain images mixed up
15:26:43 <bitemyapp> dleedev: one of the tricks to the algebra and category theory is developing a sense of, "given x, and I do y with that x, what do I get?"
15:26:50 <merijn> Iceland_jack: Well, it is a little bit...
15:26:51 <Iceland_jack> You're not going to end up with a good sense of it
15:26:53 <bitemyapp> dleedev: generally if you can't make the leap, you need to firm up the understanding.
15:27:51 <Iceland_jack> merijn: I would recommend a book
15:28:10 <BMeph> Iceland_jack: Which? ;)
15:28:32 <Iceland_jack> BMeph: Category Theory by Steve Awodey
15:28:33 <rtpg> has anyone tried to make an HTML layout renderer in Haskell...
15:28:40 <merijn> BMeph: The usual recommendation is Awodey (forgot the title), but I thought the background/explanation was too mathy
15:28:57 <BMeph> Iceland_jack: Ah, a Disciple of Cale, good, good.... ;)
15:28:57 <merijn> BMeph: I got more mileage from Pierce's Category Theory for the Working Computer Scientist
15:29:16 <Iceland_jack> If you learn CT by going through Haskell concepts and trying to translate them back and forth you're going to end up with a very shallow experience of it
15:29:24 <merijn> Wait
15:29:37 * BMeph waits
15:29:39 <merijn> "Basic Category Theory for Computer Scientists", misremembered the name :)
15:29:52 <Iceland_jack> That one is also good
15:30:09 <johnw> @tell dmj` Please let me know when you're back online, I'd like to talk about your aws problem
15:30:09 <lambdabot> Consider it noted.
15:30:24 <bitemyapp> Iceland_jack: anything specific to Haskell is really about a particular category anyway.
15:30:38 <dleedev> Iceland_jack: I think of it rather as trying to learn Haskell concepts by going through CT
15:30:57 <Iceland_jack> dleedev: I've told you how I feel about that as well :)
15:31:24 <dleedev> Iceland_jack: and I agree up to a certain point
15:31:43 <dleedev> Iceland_jack: but I think there's definitely a benefit of learning a certain amount of CT
15:32:09 <dleedev> Iceland_jack: otherwise, "Functor" and "Monad" are just variables
15:32:17 <Iceland_jack> Variables?
15:32:35 <dleedev> Iceland_jack: they don't mean anything to the programmer beside the behavior attached to them
15:32:47 <dleedev> Iceland_jack: and it's hard to make connections between the variables
15:33:03 <Iceland_jack> dleedev: Do you think the same about numbers?
15:33:22 <dleedev> Iceland_jack: numbers?
15:33:33 <dleedev> Iceland_jack: like "natural" vs "real"?
15:33:34 <Iceland_jack> “I know the behaviour of a + 0 = a, but I need to learn <insert discipline> to *get* numbers.”
15:33:58 <dleedev> Iceland_jack: yes, I think it's beneficial to Haskell
15:34:01 <merijn> dleedev: I don't know the CT behind monads (and only partially that behind functors), you don't need to know it
15:34:13 <merijn> dleedev: The stuff I have learned is utterly useless to learning haskell
15:34:15 <Iceland_jack> dleedev: Not really
15:34:18 <dleedev> Iceland_jack: otherwise, I don't know when to use Real and Integer, etc
15:34:22 <johnw> Iceland_jack: but you do want to learn abstract algebra to go from "a + 0 = a" to "any structure where a + some unitary value = a has certain properties that I can make use of"
15:34:29 <Iceland_jack> dleedev: You missed my point
15:34:40 <dleedev> Iceland_jack: I think you missed mine
15:34:41 <Iceland_jack> johnw: Yes but do doing basic arithmetic it's useless
15:34:51 <yayutf> dleedev: I think the category theory and haskell notions are different enough that the category theory doesn't particularly help with Haskell
15:34:56 <johnw> sure, within a particular field of application, you don't need it at all
15:35:08 <dleedev> Iceland_jack: having a sense of what Real and Integer are is useful in Haskell, because just by reading the name, you get a sense of how they will behave
15:35:17 <johnw> only if you want to work at a level of abstraction above any particular application, like coding to Monad rather than it terms of any particular monads
15:35:50 <Iceland_jack> dleedev: I think you're putting category theory on a pedestal like so many people
15:35:58 <johnw> and you can keep climbing a certain "ladder of hierarchy", from Maybe, to Monad, to adjunctions in CT, to..., etc.
15:36:06 <yayutf> dleedev: Prelude> 23523523905820395823095 ** 2320938205923
15:36:07 <yayutf> Infinity <-- Hm. Maybe my mathematical notions aren't so helpful here....
15:36:28 <dleedev> yayutf: and the same limitations apply to CT in Haskell as well, I know
15:36:47 <dleedev> yayutf: but the limitations shouldn't prevent you from understanding why certain things are named a certain way
15:36:48 <Cale> dleedev: I agree with Iceland_jack here, if you want to learn both, it's probably better to put your focus squarely on one or the other at any point in time, and then worry about how things line up after you understand things independently on both sides.
15:36:58 <johnw> Cale++
15:37:05 <johnw> going back and forth is too distorting
15:37:19 <yayutf> dleedev: I fully support learning category theory, and math in general - but there's a point where they diverge enough from what's implemented that they're actively misleading, and where knowing more about the (math|implemention) doesn't help you more with the other
15:37:36 <johnw> in Haskell, it almost makes no sense at all to think of Functors as "mappings between categories", and yet in CT, it makes equally little sense to think of them as "computational contexts" or "containers"
15:38:04 <yayutf> johnw: yeah, functors are notorious - haskell, category theory, and ocaml have rather different ideas of what they are
15:38:07 <shachaf> "containers" doesn't make sense in Haskell either, of course.
15:38:10 <yayutf> there's -massive- terminology overloading
15:38:16 <shachaf> Anyway, if you know some category theory, maybe that'd make learning Haskell a bit easier. But learning about categories in order to understand Haskell is a lot more work than just learning Haskell.
15:38:18 <ChongLi> well, isn't fmap itself the "mapping between categories"?
15:38:18 <bitemyapp> johnw: I think you get more leverage out of being comfortable with category theory when you spend at least as much time implementing libraries as you do using them.
15:38:21 <dleedev> johnw: but there's a reason why those things were named "Functor", no?
15:38:31 <tristan__> which is why just focus on the one you want to use :)
15:38:38 <bitemyapp> ChongLi: fmap only has meaning in Hask.
15:38:57 <Cale> ChongLi: Every instance of Functor in Haskell is a functor Hask -> Hask, and fmap is the mapping on arrows (the mapping on objects being the type constructor)
15:39:00 <yayutf> dleedev: because they needed a name, and 'Functor' was available, and it vaguely reminded someone of some notion of one, sure
15:39:09 <ChongLi> ahhh
15:39:30 <Cale> yayutf: It's more than that!
15:39:34 <dleedev> yayutf: but then you can build on that
15:39:35 <ChongLi> and it's all just Endofunctors cause everything is in Hask?
15:39:42 <Cale> ChongLi: right
15:39:42 <yayutf> Cale: I'm overstating the case there a little, I admit. :-)
15:40:05 <tristan__> I think it is better to go with yayutf's overstatement usually
15:40:13 <Cale> Instances of Functor *are* functors
15:40:26 <Cale> but they're functors of a very particular sort
15:40:27 <Iceland_jack> dleedev: I can see that you *want* there to be a connection, maybe learning both will work out for you
15:40:58 <yayutf> Iceland_jack: learning both is great, yes
15:41:05 <Iceland_jack> But if you do, pick up a CT book and learn your CT from there. Learn your Haskell from here
15:41:18 <dleedev> Iceland_jack: do you not think that programmers with background in CT have an easier time with Haskell?
15:41:31 <Iceland_jack> Not necessarily
15:41:41 <tristan__> learning both is great for what?
15:41:43 <yayutf> dleedev: mainly culturally, and in reading some of the papers, I'd say; with actually producing working code, not so much
15:41:43 <merijn> dleedev: After spending some time learning CT, I don't really think so
15:41:53 <Cale> dleedev: Barely
15:42:18 <tristan__> I've heard knowing CT can do the opposite
15:42:21 <yayutf> tristan__: they're fun in somewhat similar ways
15:42:33 <Iceland_jack> And if your final goal is using CT to become better at Haskell your time is better suited to learning Haskell
15:42:48 <Cale> dleedev: I had experience with CT before learning Haskell, and it made some of the notation perhaps slightly more comfortable? Not by a whole lot. It still took me two years to really feel comfortable writing programs in Haskell.
15:42:50 <tristan__> yayutf: ah ok, that I agree with
15:43:20 <Cale> Mind you, this was back in 2001/2002 or so, and there weren't nearly so many resources.
15:43:54 <tristan__> trying to think of an analogy to other languages and their mathematical foundations..
15:44:08 <Cale> I think the user list for this channel fit on my screen when I first joined :)
15:44:21 <yayutf> tristan__: lisp, lambda calculus
15:44:22 <dleedev> tridactyla: other languages don't have mathematical foundations :P
15:44:36 <dleedev> tristan__: ^^
15:44:37 <tristan__> lambda calculus is not really the same
15:45:02 <tristan__> it is a more direct correlation
15:45:12 <tristan__> but I guess that make sthe point even more
15:45:16 <tristan__> same with type theory
15:45:18 <merijn> dleedev: I'm willing to say that learning type theory is probably a far mor useful thing to invest time in, in terms of helping you with haskell
15:45:26 <tristan__> my eyes glaze over when I see type theory papers
15:45:32 <tristan__> but I use plenty of types :)
15:45:41 <Iceland_jack> Yes, learning type theory would be a much better idea dleedev
15:45:42 <Cale> I will say one thing, knowing how to prove theorems in mathematics kind of helps on occasion with the kind of reasoning which makes sense to apply in writing functional programs (via Curry-Howard)
15:45:50 <yayutf> higher order kinds is where it's at ;-)
15:45:51 <ij> tristan__, Can you say a bit about why LC isn't the same?
15:46:23 <merijn> tristan__: Are those papers written by Conor McBride, by any chance?
15:46:29 <dleedev> I think I get an urge to learn CT when I come across a situation like this: a Monad instance being used as a Functor. Or a Monad being used as an Applicative.
15:46:29 <merijn> tristan__: 'cos if so, that's natural :p
15:46:30 <tristan__> becuase lambda calculus is directly related to computer science
15:46:43 <ij> Oh.
15:46:47 <yayutf> Cale: math definitely helps with programming, yes; it's just particular branches that aren't necessarily particularly helpful for particular languages
15:46:56 <tristan__> merijn: haha, I just mean type proofs are gibberish to me these days
15:47:07 <dleedev> In such cases, the programmer has an intuition of how a Monad will behave as a Functor, because he understands the connection between the two
15:47:10 <merijn> dleedev: I was actually working on a blog post to explain the link between Monad/Functor/Applicative, zero CT required :)
15:47:32 <merijn> dleedev: Ask me again in a week, because right now I just started writing :p
15:47:40 <Cale> The sorts of things you become acutely aware of while proving theorems, like which of your assumptions you've used so far, and how they individually can be fit together, there's something similar about that kind of thinking and the kind of thinking you do while writing programs.
15:47:41 <Iceland_jack> dleedev: CT will not help you with applicatives
15:47:55 <Iceland_jack> And monads honestly aren't that well known within CT itself
15:48:06 <Cale> Eh?
15:48:06 <enthropy> is there a type-level SVD out there?
15:48:36 <Cale> Monads are pretty well known in CT
15:48:42 <Cale> They're used in a completely different way though
15:48:56 <dleedev> merijn: what's your blog address?
15:48:56 <Cale> They were originally used to study algebraic theories
15:49:33 <carter> in high school i just thought of monads as pieces of data with an algebraic operation that has cooties, "you can look in side, but whatever you do next will have cooties"
15:49:40 <Iceland_jack> Cale: Sure but when you consider what's important in CT it's quite different from what people might know about it from Haskell
15:49:40 <yayutf> dleedev: you can search http://book.realworldhaskell.org/read/code-case-study-parsing-a-binary-data-format.html for functor, then http://book.realworldhaskell.org/read/monads.html for 'monads and functors' for a quick glance; no category theory required either
15:49:41 <carter> im still pretty hapy with that view :)
15:49:45 <merijn> dleedev: Non-existent yet, usually I dump them on github as gists, I'm still procrastinating getting a site finished :p
15:49:55 <Cale> Iceland_jack: yeah, I suppose that's true
15:50:27 <dleedev> yayutf: yeah, I'm pretty familiar with functor and monad in Haskell-land
15:50:28 <Cale> You don't really learn much if anything about universal mapping properties by looking at Haskell, unless you do so very carefully.
15:50:39 <Iceland_jack> Exactly
15:50:44 <Cale> and they're essentially 90% of classical CT
15:50:52 <yayutf> dleedev: most of category-theory land seems to be applying it to topology
15:51:40 <Cale> yayutf: Well, CT grew out of algebraic topology, and a lot of the best motivating examples are still from there
15:52:19 <merijn> Cale: Sometimes I think "maybe I should learn algebraic topology to understand CT", fortunately I quickly think "hmm, better not." :p
15:52:24 <dleedev> I think another part of Haskell that makes me want to learn CT is the Category class
15:52:26 <Cale> (of course, it helps that algebraic topology has a nice geometric quality to it, and you can draw pictures with blobs and paths and stuff)
15:52:27 <yayutf> Cale: i've noticed, but it gives me a "I need a graduate-level knowledge of topology to really grok this" complex :-)
15:53:01 <dleedev> Can you understand the Category class without understanding CT?
15:53:20 <Cale> dleedev: yes
15:53:36 <Cale> dleedev: Moreover, it's in some ways very much unlike the definition of a category in CT.
15:53:54 <dleedev> Cale: I've heard something like that before
15:53:57 <Cale> I actually hated it at first that they called it Category
15:53:58 <dleedev> Cale: it's closer to an Arrow?
15:54:14 <Cale> Arrow is also nothing like the categorical notion of an arrow at all.
15:54:16 <dleedev> Cale: arrow (under case), sorry
15:54:34 <FreeFull> What about Profunctor?
15:55:53 <Cale> It's kind of like a category whose objects are Haskell types and whose composition maps are some sort of natural transformations between profunctors on Hask, but without the actual requirement that those *be* profunctors, so it's kind of tough to formalise at all...
15:55:56 <shachaf> Cale: Is your objection to Category that your objects are always Haskell types?
15:56:04 <shachaf> Ah.
15:56:27 <dleedev> Is Category useful at all?
15:56:31 <Cale> Yes
15:56:36 <Cale> It's definitely a useful class
15:56:43 <dleedev> Cale: is there a better name for it?
15:56:45 <shachaf> So you'd be OK with polykinded Category?
15:56:53 <Cale> shachaf: yeah, probably
15:57:16 <shachaf> Or, for that matter, with http://hackage.haskell.org/package/data-category-0.5.1.1/docs/Data-Category.html ?
15:57:21 <Cale> dleedev: Well, not really. CT doesn't have a name for something like that as far as I know
15:57:47 <shachaf> Cale: Wait, what's not required to be profunctors?
15:57:51 <Cale> Calling it Category is slightly misleading, but at the same time the definition is designed to have strong similarities with the definition of a category.
15:58:10 <Cale> shachaf: An instance of Category is not required to be a Profunctor
15:58:18 <shachaf> Oh, sure.
15:58:22 <shachaf> I thought you were talking about Arrow.
16:00:00 <Cale> Yeah, data-category comes closer
16:00:24 <Cale> It's just not something which is trivial to do in Haskell
16:00:40 <Cale> It's hard enough to formalise categories well in Agda or Coq
16:04:47 <Cale> But don't get me wrong, a simple class along the lines of Category is a nice thing to have around
16:05:53 <Cale> It's just that while it basically defines some sort of category, exactly what sort is not easy to understand due to the interaction of Haskell's polymorphism with the parts of the definition.
16:06:54 <erisco> is there a special reason for conditionally importing Prelude or being selective on the other imports? http://hackage.haskell.org/package/containers-0.3.0.0/docs/src/Data-Tree.html
16:07:46 <geekosaur> because Prelude beings in list versions of things you probably intend to define on your tree?
16:08:22 <Cale> hmm
16:08:32 <Cale> geekosaur: It's something for Haddock
16:08:39 <geekosaur> yeh, I just got it loaded
16:08:45 <Cale> I'm really not sure why
16:08:51 <geekosaur> don't know enough about haddock
16:08:54 <Cale> Maybe because there are links to Prelude names in the comments
16:09:08 <Cale> that they wanted Haddock to be able to resolve
16:09:33 <Cale> Except it doesn't appear that there are
16:10:01 <Cale> (But maybe that was stolen from another module?)
16:10:24 <Cale> You'd have to try running haddock on it without the conditional and see what happens
16:10:29 <Cale> It's quite possibly spurious
16:11:50 <Cale> It's also weird that they derive Data, but use a CPP macro to write the Typeable1 instance.
16:12:39 <geekosaur> I thought that used to be necessary because of some screwiness in older versions of Typeable
16:12:41 <Cale> Data.Tree is silly anyway
16:13:55 <Cale> The fact that it's defined as a record type makes the Show instance nearly unusable
16:14:29 <Cale> (but I guess as a consolation prize, you get draw)
16:15:03 <Cale> But almost any time where you'd want trees for something in Haskell, you'll be defining your own data type anyway
16:15:14 <shachaf> clearly Cofree [] is the true answer
16:15:33 <shachaf> (except half the time you want Free [] instead)
16:20:24 <Rarrikins> Where are installed cabal packages located?
16:20:35 <zq> Rarrikins: ghc-pkg list
16:20:53 <Cale> ~/.cabal/*
16:20:58 <geekosaur> on some platforms
16:21:00 <zq> Cale: not necessarily
16:21:08 <geekosaur> ~/Library/Haskell on OS X. I don't know where Windows puts them
16:21:18 <Rarrikins> zq: Thanks. Looks like ~/.ghc
16:21:19 <geekosaur> (all of these are defaults controllable via ~/.cabal/config)
16:21:21 <zq> not even an issue of platform; hsenv
16:21:23 <geekosaur> yes and no
16:21:35 <geekosaur> the package registry is there, the libraries themselves may be elsewhere
16:21:43 <Cale> Rarrikins: Yeah, the actual list of registered packages is in ~/.ghc
16:21:44 <zq> again, not necessarily
16:21:48 <zq> geekosaur: cf. hsenv
16:21:50 <geekosaur> you can examine the registry to see where things are
16:21:57 <Cale> Rarrikins: You can manipulate that list using the ghc-pkg command
16:22:20 <geekosaur> yes, I heard you the first time, any sandbox mechanism will override the default and there are at least 3 such
16:22:21 <Rarrikins> I want to get rid of everything (except for things like base) and start over.
16:22:36 <Rarrikins> Anything I've cabal installed.
16:22:49 <Cale> Rarrikins: In that case, removing ~/.ghc will do
16:22:54 <bkolera> I have two questions about tweaking ghc warnings to do things that seem pretty natural to me in this gist https://gist.github.com/benkolera/8512776. An answer of "your want for this is misguided because of ..." is a fine answer. :) Couldn't find them in http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/options-sanity.html
16:22:56 <Rarrikins> Oh, OK. Thanks :)
16:22:57 <geekosaur> but if someone doesn;t know they're sandboxing or don't bother to tell us which oen, then they've already lost and so have we
16:23:03 <Cale> and if you want to free up the disk space, you can clean up under ~/.cabal
16:23:13 <zq> the only way to win is not to play
16:23:16 <Cale> But for the most part, it's not an issue
16:24:36 <Cale> bkolera: Not that I know of
16:24:40 <c_wraith> zq: is your nick short for zqfmgb?
16:24:45 <scmaccal`> david, would you look at this mess]
16:25:24 <zq> c_wraith: nope :p
16:25:40 <c_wraith> zq: just checking. :)
16:26:02 <hamster007> can you guys help me build this: http://www.dinkla.net/en/programming/haskell-cglib.html
16:26:12 <hamster007> i just need a little help
16:26:31 <bkolera> Cale: I was thinking as much, but it didn't hurt to ask. Thanks! :)
16:27:14 <zq> what if there was a way to control the gc within the program?
16:27:28 <Cale> hamster007: What trouble are you having?
16:27:50 <hamster007> general ingorance
16:27:59 <hamster007> I unzipped it
16:28:12 <hamster007> i need to build it
16:28:13 <Cale> type  "cabal install"
16:28:24 <lingxiao> is it not possible to export a GADT if it has been promoted by DataKinds ?
16:28:30 <Cale> (while in the directory you unpacked it to)
16:28:32 <lingxiao> https://gist.github.com/anonymous/203556e275104a579626
16:28:38 <lingxiao> pretty sweet error message though ...
16:28:56 <Cale> GADTs don't get promoted, do they?
16:29:03 <hamster007>       it was found in multiple packages: base haskell98-2.0.0.2
16:29:18 <Cale> also, I'm not sure how well DataKinds even work in 7.4.2
16:29:19 <c_wraith> lingxiao: paste the code that was responsible
16:29:33 <lingxiao> https://gist.github.com/anonymous/ef6932b4070510884f0b
16:29:41 <Cale> iirc, they were still somewhat embryonic
16:29:45 <hamster007>     Ambiguous module name `Numeric':
16:29:48 <lingxiao> Cale: sorry... incorrect terminoogly
16:29:51 <lingxiao> terminology*
16:30:03 <lingxiao> is it just me or does ghc have some pretty passive aggressive error messages
16:30:11 <Cale> heh, what?
16:30:11 <lingxiao> like my favorite "my brain just exploded ... "
16:30:20 <Cale> Yeah, that's Simon's brain
16:30:36 <lingxiao> hmm.. when I first read the error message I could literally feel my brain swelling up
16:30:39 <mzero> lingxiao: You call them "error messages"... we call them "crazy moon poetry"
16:31:04 <lingxiao> I mean they def have a more human touch...makes me feel closer to the language creators
16:31:05 <Cale> lingxiao: This is your whole module?
16:31:11 <Cale> what's the error message?
16:31:12 <c_wraith> lingxiao: I don't see any promoted types in there
16:31:15 <lingxiao> oh no.. there's more to it..
16:31:36 <lingxiao> https://gist.github.com/anonymous/2d6f4727cedb16c9dde0
16:31:38 <pavonia> hamster007: Removing the haskel98 dependency should do it
16:31:42 <lingxiao> that's the whole module ...
16:32:30 <Cale> lingxiao: Why GHC 7.4.2? Is it hard to upgrade to 7.6.x?
16:33:17 <lingxiao> uhh ... no I havn't noticed to be honest :-\, I'll upgrade now
16:33:31 <Cale> I'm pretty sure that GADTs don't get promoted
16:33:50 <zq> do Prelude.{map, fold*, iterate, etc} undergo stream fusion?
16:34:08 <NemesisD> any esquelito users?  i'm hitting some really weird errors: http://lpaste.net/98801
16:34:09 <mzero> zq: I'm pretty sure they do
16:34:26 <Cale> zq: no, they undergo foldr/build fusion.
16:34:35 <lingxiao> " while -XDataKinds enables user defined kinds through datatype promotion"
16:34:47 <lingxiao> I guess datatype get promoted? is it different than GADT?
16:34:53 <c_wraith> zq: foldl does *not* fuse.  only foldr
16:34:53 <pavonia> "[x,y,z,f] = Var <$> ["x","y","z", "f"]" <-- Is such a binding at the top-level Haskell 2010?
16:34:55 <Cale> zq: Which is a different technique for the same purpose
16:34:55 <lingxiao> from .. http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/kind-polymorphism-and-promotion.html
16:35:20 <Cale> pavonia: yes
16:35:21 <c_wraith> the fact that foldl (and foldl') doesn't fuse is annoying.
16:35:40 <Cale> pavonia: It's Haskell 98 even
16:35:42 <c_wraith> But it's a consequence of how fusion is implemented for lists
16:35:59 <pavonia> Wow, I've never seen that
16:36:16 <Cale> lingxiao: Not *all* datatypes. GADTs are more tricky
16:36:42 <c_wraith> pavonia: yeah, you can pattern-match in top-level bindings.
16:36:55 <Cale> Though I think Simon said that Stephanie had been trying to convince him to do GADTs as well, and so he'd probably end up doing it.
16:36:57 <c_wraith> pavonia: you can think of everything at the top level as inside an implicit let binding
16:37:04 <zq> Cale: is that (== "shortcut fusion")?
16:37:13 <Cale> (Simon Peyton Jones and Stephanie Weirich)
16:37:14 <mzero> pavonia: My Haskell 6502 emulator in exactly 6502 characters make extensive use of that idiom!
16:37:19 <c_wraith> pavonia: let {bindings} in runTheRTs
16:37:32 <Cale> zq: What's shortcut fusion?
16:37:41 <lingxiao> funny I took a class with Stephanie Weirich's husband a few years back
16:37:58 <lingxiao> whos also a prof ... that was long before I was aware of haskell
16:38:17 <lingxiao> not that it's relevant, just odd to see her name used here
16:38:23 <c_wraith> I'm really impressed by the stuff Stephanie Weirich's group has been producing.
16:38:49 <lingxiao> what is relevant is .. what's a good starter on how promoting datatypes ?
16:38:55 <Cale> lingxiao: Her name is on many Haskell-related papers :)
16:39:27 <Cale> lingxiao: Probably to start with all the simple examples are going to use the promotion of Nat
16:39:40 <lingxiao> yeah I've noticed that ...
16:39:52 <lingxiao> c_wraith: next time I run into her I'll let her know
16:39:56 <lingxiao> :)
16:40:10 <c_wraith> which is a bit annoying, since the same extension also provides type-level natural literals now
16:40:21 <Cale> heh
16:40:30 <c_wraith> Which makes all the examples that do it by hand...  unpleasant
16:40:49 <lingxiao> Cale: ok got it I'll take a look
16:40:52 <Cale> The literals don't stand in for actual Nats?
16:41:39 <lingxiao> uh.. kind of an embarrasing question.. but can you cabal install new version of ghc? if so what's the command?
16:41:45 <c_wraith> no, you can't
16:42:20 <c_wraith> Cale: no, the literals don't stand for anything other than themselves.  1 is just a type.  (With that extension enabled)
16:42:32 <Cale> c_wraith: haha
16:43:09 <lingxiao> ok so I'm a little confused by this ..
16:43:28 <lingxiao> according to the user guide, the data type "data Nat = Ze | Su Nat"
16:43:37 <Cale> lingxiao: anyway, I expect that the stuff you'd want to do in the case of your interpreter will end up probably being a bit rough going (e.g. if you want to follow along with the sort of things Conor McBride does in a dependently typed language)
16:43:50 <lingxiao> give arise to the following kidn and type constructors:
16:43:56 <lingxiao> Nat :: BOX
16:43:56 <lingxiao> Ze :: Nat
16:43:58 <lingxiao> Su :: Nat -> Nat
16:44:12 <lingxiao> what is BOX?
16:44:31 <Cale> The sort of all kinds with types in them
16:44:32 <lingxiao> Cale: what does rough going mean?
16:44:36 <Cale> difficult
16:44:50 <lingxiao> oh noI meant specifcially, what will be difficult
16:45:06 <lingxiao> like cause more troubles later on?
16:45:29 <c_wraith> It's hard to figure out how to express those things, or if it's even possible
16:45:35 <lingxiao> so this word "sort", it's a classification of kinds?
16:45:38 <c_wraith> yep
16:45:45 <c_wraith> like kinds are classifications of types, etc
16:45:54 <enthropy> Cale: there is a sing method to get an Integer that corresponds to the type 1
16:45:55 <Cale> Well, it's not literally dependently typed, so manipulating promoted things at the type level isn't easy.
16:46:34 <enthropy> > sing :: Sing 3
16:46:35 <lambdabot>  <hint>:1:14: Illegal literal in type (use -XDataKinds to enable): 3
16:46:35 <Cale> I don't know why it's called BOX and why * isn't called Type
16:46:50 <c_wraith> Type isn't a good name for *
16:46:56 <c_wraith> Though * could have a better name.
16:47:07 <c_wraith> something like CouldPotentiallyHaveAValue
16:47:25 <c_wraith> Since only types with kind * can have values!
16:47:42 <Cale> Well, it *vaguely* corresponds to what Type is in, say, Coq.
16:47:47 <c_wraith> ah, I see
16:47:55 <c_wraith> * is a really confusing, though
16:48:05 <c_wraith> since people seem to interpret it as polymorphic at first
16:48:10 <c_wraith> and it's actually quite concrete
16:48:13 <shachaf> ski used "inhabitable type"
16:48:33 <c_wraith> that's a much better term
16:48:43 <enthropy> in some sense it is polymorphic?
16:48:54 <c_wraith> It's not.  It means exactly one kind.
16:48:58 <lingxiao> c_wraith: so when you say "Since only types with kind * can have values"
16:49:02 <enthropy> there are lots of types that have :: *
16:49:10 <lingxiao> do you mean a type of kind * -> * is not inhabited?
16:49:19 <c_wraith> enthropy: there are lots of values that have type Int.  That doesn't mean Int is polymorphic
16:49:52 <geekosaur> lingxiao: what values does `Maybe` have?
16:49:52 <lingxiao> do types inhabit kinds?
16:49:55 <c_wraith> lingxiao: Well, it's not inhabited at the value level.
16:50:01 <Cale> * -> * doesn't mean the same thing as forall k. k -> k
16:50:18 <geekosaur> (not `Maybe Int`, not even `Maybe a`)
16:50:21 <shachaf> i,i miranda
16:50:40 <lingxiao> geekosaur: if it has kind *->*, doesn't the function Just inhabit it?
16:50:40 <Cale> Yeah, we took Miranda's mistake at the type level and used it in our kinds.
16:51:03 <Cale> Perhaps we'll just keep pushing the mistake one level up
16:51:12 <geekosaur> lingxiao: no
16:51:25 <c_wraith> the function Just has kind *
16:51:34 <enthropy> c_wraith: ok I think I see what you mean.
16:51:38 <c_wraith> You can tell because it is a value. :)
16:51:41 <bitemyapp> Cale: did Agda or Idris make a mistake of that sort?
16:51:46 <bitemyapp> heheh...sort.
16:51:52 <Cale> bitemyapp: No
16:52:09 <Cale> bitemyapp: Unless you consider Agda's name "Set" a mistake
16:52:29 <Cale> (I kind of do)
16:53:15 <lingxiao> geekosaur: why does Just have kind *? also ... I didn't know a value constructor can have a Kind
16:53:44 <geekosaur> `Just` is a function; as such it is a value, and as such must be kind *
16:53:50 <triliyn> Just :: a -> Maybe a; a -> Maybe a :: *
16:53:52 <geekosaur> you are confusing value and type level
16:54:04 <ChongLi> which is easy to do :)
16:54:08 <geekosaur> `Just` is not a type
16:54:08 <ChongLi> :k Just
16:54:09 <lambdabot>     Not in scope: type constructor or class `Just'
16:54:09 <lambdabot>     A data constructor of that name is in scope; did you mean -XDataKinds?
16:54:12 <ChongLi> :k Maybe
16:54:13 <lambdabot> * -> *
16:54:13 <c_wraith> @kind a -> Maybe a
16:54:14 <lambdabot> Not in scope: type variable `a'
16:54:14 <lambdabot> Not in scope: type variable `a'
16:54:22 <c_wraith> @kind (->)
16:54:23 <lambdabot> * -> * -> *
16:54:30 <Cale> I usually wouldn't refer to type constructors as types
16:54:51 <Cale> But I'll admit that it can occasionally be a bit tiresome
16:56:11 <c_wraith> @kind (->) Int
16:56:12 <lambdabot> * -> *
16:56:16 <c_wraith> @kind (->) Int (Maybe Int)
16:56:16 <lambdabot> *
16:56:35 <erisco> sorry my internets died
16:56:39 <erisco> is there a special reason for conditionally importing Prelude or being selective on the other imports? http://hackage.haskell.org/package/containers-0.3.0.0/docs/src/Data-Tree.html
16:56:47 <lingxiao> so only values inhabit *, and all functions are values so they all reside in *
16:57:13 <enthropy> with type families, is there an equivalent of the value-level error available?
16:57:29 <geekosaur> erisco: I think we concluded it's because haddock needed to see Prelude stuff to provide links to things in its markup
16:57:48 <benzrf> supki:
16:57:49 <c_wraith> geekosaur: is it compiled with NoImplicitPrelude?
16:57:50 <lingxiao> so what resides in *->* ?
16:57:51 <benzrf> *sup
16:58:00 <erisco> what about the selective importing?
16:58:02 <geekosaur> the rest is just because some Haskell programmers prefer explicit imports and others don't
16:58:03 <benzrf> lingxiao: any type constructor that takes 1 arg
16:58:06 <enthropy> erisco: might be that some haddock version needed it?
16:58:08 <triliyn> lingxiao: Maybe, Either String
16:58:08 <lingxiao> type constructors parametrized over a type?
16:58:08 <benzrf> lingxiao: such as Maybe or []
16:58:16 <benzrf> lingxiao: over 1 type
16:58:27 <roboguy_> :k Int
16:58:29 <lambdabot> *
16:58:29 <benzrf> * is inhabited, 'fully applied' types
16:58:32 <lingxiao> so "arity 1" types inhabit * -> *
16:58:35 <benzrf> right
16:58:38 <lingxiao> but Values inhabit *
16:58:45 <benzrf> xactly
16:58:52 <lingxiao> but * -> * and * are ... on the same level kind of?
16:58:56 <benzrf> yeah
16:58:57 <benzrf> they are both kinds
16:59:02 <benzrf> a kind is a type type
16:59:03 <roboguy_> well, values inhabit types. types inhabit kinds
16:59:14 <benzrf> -> is a kind constructor of sorts
16:59:18 <zq> typing-haskell-in-haskell.lhs
16:59:41 <benzrf> same as how -> is a type constructor at the type level
17:00:07 <c_wraith> does GHC still have only 1 sort?
17:00:26 <NemesisD> ugh persistent is ruining my life. now i get why people get so pissed off about the code generation
17:01:10 <lingxiao> and kinds could be drawn from sorts? what are some examples of sorts?
17:01:36 <lingxiao> like .. The sort of all kinds with types in them
17:01:47 <triliyn> lingxiao: I think currently all kinds have sort BOX
17:01:56 <c_wraith> You could create a language that lets you go arbitrarily far up the sacale.  In fact, there are many such languages.
17:01:56 <jle`> i'm doing a whole bunch of magic with typeclasses in my program and i am sure that it is a bad idea in the long run but it's so fun for now
17:02:20 <dmwit> lingxiao: You say, "only values inhabit *". This is not precise. Values inhabit types which inhabit *.
17:02:30 <benzrf> wait are sorts actually a thing
17:02:33 <jle`> NemesisD: yeah the black box kinda thing was frustrating when i was learning things too
17:02:40 <jle`> but you kind of get the hang of it after a while
17:02:43 <benzrf> dmwit: i think lingxiao meant type that are inhabited
17:02:48 <benzrf> by Values
17:02:52 <jle`> i think there's a way to see the code that is generated?
17:02:56 <erisco> what is the motivation of Data.Tree Applicative instance for <*>? particularly, why add the   map (f <$>) txs   term?
17:02:58 <jle`> by examining the core or something i think
17:03:02 <dmwit> benzrf: Yes, sorts are a thing.
17:03:21 <lingxiao> dmwit: ok thanks for clearing that up... that's why I got confused about how values inhabit * but type inhabit * -> *
17:03:48 <benzrf> dmwit: o:
17:03:53 <benzrf> dmwit: is there a notation for them?
17:03:54 <lingxiao> benzrf: that's what I was hoping it meant...except I got confused
17:04:45 <NemesisD> jle`: have you found alternatives? i'm looking to write services that map to existing databases generated by other frameworks (i.e. rails)
17:05:13 <dmwit> benzrf: Sure. What do you mean?
17:06:00 <benzrf> dmwit: wait
17:06:02 <benzrf> what are sorts then?
17:06:18 <erisco> ah I know now... for one it is necessary for the identity law
17:06:29 <benzrf> i thought lingxiao said something about sorts being the next level above kinds
17:06:36 <dmwit> benzrf: Sorts are the next level above kinds, yes.
17:06:43 <dmwit> term, type, kind, sort
17:06:48 <jle`> NemesisD: i think HaskellDB is commonly cited as a solution for that
17:06:52 <jle`> specific case
17:06:55 <benzrf> o:
17:07:03 <dmwit> benzrf: And why shouldn't the type system have a type system? =)
17:07:08 <benzrf> o-o
17:07:29 <roboguy_> Lindrian: values don't inhabit *. types do. values inhabit types
17:07:30 <NemesisD> jle`: are there downsides? like performance?
17:07:33 <dmwit> (Personally, I find it hilarious that people look at GHC and go, "hm, four levels... yeah, four seems like the right number".)
17:07:44 <benzrf> dmwit: i cant find anything referring to sorts
17:07:44 <benzrf> o-o
17:08:01 <roboguy_> I mean lingxiao
17:08:09 <dmwit> benzrf: https://ghc.haskell.org/trac/ghc/wiki/GhcKinds mentions kind BOX.
17:08:10 <benzrf> roboguy_: they left
17:08:17 <dmwit> err, sort BOX
17:08:27 <dmwit> It is currently the only sort GHC has, as far as I know.
17:08:38 <dmwit> But I have no doubt that will change by 21x6. =)
17:08:53 <benzrf> .-.
17:10:39 <NemesisD> jle`: last release for haskelldb is 2012 :(
17:12:45 <dmwit> It's type systems all the way up.
17:13:18 <benzrf> until you reach the turtles
17:13:24 <kristof> I was about to say that :P
17:13:26 <benzrf> oops no thats down
17:13:41 <benzrf> it is ELEPHANTS all the way up
17:19:17 <enthropy> NemesisD: if new is better: http://hackage.haskell.org/package/esqueleto
17:20:50 <NemesisD> enthropy: currently struggling with that. esqueleto seems fine enough but i can't find how i'd tell persistent the names of my tables
17:22:03 <enthropy> sounds like that's something covered in the examples
17:22:15 <enthropy> either for esqueleto or maybe for persistent
17:23:00 <NemesisD> it isn't as far as I can find. i think i'd have to figure out how to get cabal to dump my splices and do it that way
17:23:34 * enthropy would cabal repl\n:set -ddump-splices
17:23:45 <enthropy> then :load themodule.hs
17:24:25 <benzrf> wots cabal repl
17:24:30 <benzrf> it does not work on my computer
17:24:32 <roboguy_> there, I finally got ghc HEAD working with lens and some other things! and all I had to do was reinstall ghc a few times and delete all my cabal packages
17:24:47 <enthropy> benzrf: it starts ghci up
17:25:11 <benzrf> o
17:25:45 <enthropy> you need to upgrate to the latest cabal install to get it
17:29:47 <roboguy_> although it looks like haskell-src-exts isn't compatible yet, hmm
17:31:54 <erisco> I want to prove fmap id == id for my Functor instance, but I am stumped due to recursion http://lpaste.net/98802
17:32:55 <roboguy_> I think you assume that the recursive call is correct
17:33:13 <erisco> roboguy_, then I may as well not bother proving it at all =\
17:33:27 <erisco> ie I cannot assume what I am proving is correct as part of the proof
17:34:49 <Rarrikins> Is it a bad idea to have a github URL for cabal maintainer?
17:35:13 <roboguy_> "s" isn't of type Tree f a though right?
17:35:24 <roboguy_> erisco: so you would need to prove that the Forest Functor instance is correct
17:35:30 <erisco> oh sorry I did not give Forest
17:35:36 <Rarrikins> roboguy_: If you have type s = Tree f a, yes.
17:35:45 <dcoutts_> Rarrikins: you can put the github url for the home page and bug tracker, but for maintainer it's useful to be able to find a real person
17:35:47 <Rarrikins> roboguy_: If you mean the String literal, probably not.
17:35:52 <roboguy_> Rarrikins: I'm talking about the specific code that erisco posted
17:35:54 <erisco> roboguy_, I can assume the Forest functor is correct, but that is not what I am stuck on
17:36:05 <Rarrikins> roboguy_: Oh, sorry.
17:36:10 <erisco> okay I annotated with Forest
17:36:16 <Rarrikins> dcoutts_: Ahh, OK. Thanks.
17:36:17 <dcoutts_> Rarrikins: e.g. consider if you get bored maintaining the package and someone wants to contact you and ask if they can take over and upload to hackage
17:36:32 <Rarrikins> dcoutts_: Ahh, I see
17:36:48 <Rarrikins> Is there a list of cabal file field names?
17:37:16 <dcoutts_> Rarrikins: in the user guide, or if you used cabal init to make your initial .cabal file then it lists the common ones
17:38:05 <roboguy_> erisco: I haven't done many proofs like this, but like I said I'm pretty sure you assume that the recursive call is correct and then see if the result is consistent. I think the keyword for would be coinduction
17:38:15 <roboguy_> *keyword for this
17:38:27 <Platz> Can I use a type State or StateT without using Mvars http://bit.ly/1fOtNq7 such that in this usage resetName will cause the subsequent calls to robotName be different?  http://lpaste.net/98803
17:39:19 <Platz> thought about StateT String IO String, but not sure if that will work
17:39:33 <Rarrikins> dcoutts_: cabal init looks nice. Thanks :)
17:39:49 <erisco> roboguy_, ah perhaps. I have never read on coinduction but as I start to it may hold the answers I need
17:43:23 <roboguy_> erisco: my understanding is that this is how you'd do it: http://lpaste.net/98802
17:43:51 <roboguy_> if we didn't end up with the right answer, that would mean the coinductive hypothesis was false, and hence the whole proof
17:44:31 <erisco> roboguy_, I am trying to locate something practical which explains coinduction
17:44:52 <roboguy_> erisco: I've really only heard it discussed here, which is why I'm not totally sure on this
17:45:10 <roboguy_> it makes sense to me that it's how you'd handle recursion in a proof though
17:46:27 <erisco> I do not see why if the hypothesis is incorrect that we would necessarily arrive at an inconsistent answer
17:47:28 <roboguy_> if the hypothesis is incorrect that means that the law is incorrect, by definition
17:48:05 <erisco> yes, but that is not what I am saying
17:50:59 <oakwhiz> beginner question: How do I use getLine to get an Int from stdin?
17:51:17 <roboguy_> oakwhiz: use readLn for that
17:51:43 <erisco> well, there is this paper here http://www.cs.cornell.edu/~kozen/papers/Structural.pdf and section 4 evidently proves why coinduction is not magical, but I have no idea what they are talking about XD
17:52:23 <Cale> main = do n <- readLn; ... do stuff with n so that it's possible to tell you want to read an Int ...
17:52:27 <roboguy_> erisco: hmm. it makes sense to me, intuitively, but I'm not sure if can actually explain it (which isn't a good sign)
17:53:36 <erisco> roboguy_, the case I am worried about is that the hypothesis is false, and by using the false hypothesis as part of the proof we mistakenly arrive at the target
17:54:20 <erisco> I am not convinced why this can not happen... and after peering over many sources I may never know prior to getting a degree in math =\
17:55:03 <Cale> erisco: Well, you only use coinduction to prove things which are defined coinductively to begin with.
17:55:14 <colDrMcBeardman> is there a good resource on helping cabal resolve a bunch of packages?
17:55:39 <erisco> Cale, and I do not know what that means :(
17:55:54 <erisco> but this is the problem if you can provide some layman insight http://lpaste.net/98802
17:56:02 <erisco> insight for the layman, that is
18:00:10 <Cale> erisco: Well, okay, so the reason that this is a valid place to apply your coinductive hypothesis is because it's inside a constructor of the datatype.
18:00:39 <Cale> erisco: We've already done enough to verify it for the outermost Node constructor
18:02:18 <Cale> erisco: I suppose a good way to think of it is just in terms of corecursion: if you were producing an infinite tree, it would be okay to use the tree you were defining, so long as you used it inside of a constructor, so that you'd know evaluation would make progress.
18:02:23 <Rarrikins> What's a better interface than ListLike for converting things to Strings or ByteStrings of either type?
18:03:20 <Cale> Rarrikins: Well, the fact that everyone ends up defining two separate modules for strict and lazy bytestrings, and another couple for Text and maybe yet another for plain String should tell you something.
18:04:04 <Cale> It kind of sucks, but there isn't really a general abstract interface to that sort of thing at the moment
18:04:15 <Rarrikins> Cale: OK, thanks.
18:04:22 <Cale> Really the right thing would be module parameters
18:04:31 <Cale> (I think)
18:05:12 <Cale> It's really awkward to take everything that the ByteString or Text modules define and package it up into a gigantic class.
18:05:21 <Cale> But that would be a kind of option.
18:06:04 <Rarrikins> I wouldn't mind just a typeclass with conversion.
18:06:12 <Rarrikins> Like toString, fromString.
18:06:27 <danharaj> Cale: why not do it the way Vector does it?
18:06:34 <Rarrikins> With RULES for optimizing fromString . toString
18:08:03 <Rarrikins> Or even a two-parameter typeclass with just convert.
18:08:14 <oakwhiz> what am I doing wrong here? http://ideone.com/z0UsW0
18:08:39 <Cale> Yeah, or if you can decide which operations your program needs, you can always make a type class with just those
18:09:06 <Cale> oakwhiz: result is an Int
18:09:21 <Cale> oakwhiz: You can apply show to it to get a String
18:09:33 <Cale> > show 35
18:09:34 <lambdabot>  "35"
18:09:59 <oakwhiz> Thank you
18:10:11 <Cale> oakwhiz: I think you'll also find that you can just use readLn rather than readLnInt
18:10:31 <Cale> oakwhiz: because it'll be able to tell you want to read an Int from the fact that you're passing the results to thefunc
18:11:09 <Cale> (type inference will determine the type of the result, which will determine at compile time which parser to use)
18:11:14 <roboguy_> oakwhiz: you are trying to append a String to an Int
18:11:17 <oakwhiz> Cale: I did that because I was trying to get rid of some other type error
18:11:41 <oakwhiz> I didn't know about "show"
18:11:57 <Cale> oakwhiz: if you neglected to use those two values in a way which made the type obvious though, it would likely complain that it was ambiguous
18:14:23 <oakwhiz> When I run the compiled executable, everything that was output using print "blah" still contains quotes.
18:14:23 <roboguy_> are there any cabal people here that might know why I'm getting this error when I try to install the new version of cabal-install? http://lpaste.net/98806
18:14:41 <Cale> oakwhiz: use putStrLn
18:14:50 <Cale> oakwhiz: print x = putStrLn (show x)
18:15:02 <Cale> oakwhiz: and showing a String will put the quotes in
18:15:09 <Cale> > "hello"
18:15:10 <lambdabot>  "hello"
18:15:13 <Cale> > show "hello"
18:15:14 <lambdabot>  "\"hello\""
18:15:20 <oakwhiz> ah much better now
18:15:20 <greymalkin> Network.CGI.Monad is failing to build with ghc 7.6.3
18:15:30 <Rarrikins> Can GHC use more than one core at a time?
18:15:45 <roboguy_> Rarrikins: yeah
18:15:50 <bitemyapp> Rarrikins: -threaded
18:15:50 <roboguy_> wait, you mean to compile?
18:15:58 <greymalkin> Yeah.
18:16:01 <greymalkin> sorry...
18:16:15 <greymalkin> Network/CGI/Monad.hs:123:10: Could not deduce (Functor m) arising from a use of `try'
18:16:35 <greymalkin> I'm not having much luck staring at the code yet, I was wondering if this is a known issue.
18:17:13 <Cale> which package is that in?
18:18:06 <Cale> cgi-3001.1.8.4 ?
18:18:45 <Cale> Oh, yeah, I see that too
18:19:51 <greymalkin> yeah.
18:20:25 <Cale> Okay, the *real* problem is that it's using MonadCatchIO-mtl at all
18:20:50 <greymalkin> what does it do?
18:20:58 <Cale> http://hackage.haskell.org/package/MonadCatchIO-mtl
18:21:10 <geekosaur> it does something useful, but in an obsolete way IIRC?
18:21:17 <Cale> It's deprecated in favour of http://hackage.haskell.org/package/exceptions
18:21:43 <dmj`>  greymalkin: if you manually add the Functor m constraint it compiles
18:21:56 <Cale> But yeah, that's the cheap way to fix it
18:22:08 <Cale> Just propagate that Functor constraint along
18:23:34 <erisco> Cale, I added a last annotation proving fmap f . fmap g == fmap (f . g) was my use of coinductive hypothesis valid?
18:24:43 <greymalkin> So... cabal says it's satisfied the dependencies, but runhaskell Setup.hs configure says that the MonadCatchIO-mtl is not installed... I wish I understood cabal setup a bit better.
18:25:17 <dmj`> greymalkin: do ghc-pkg list | grep MonadCatch see if it comes up
18:25:58 <geekosaur> greymalkin, use cabal to install it
18:26:08 <geekosaur> (`cabal install` without a package name)
18:26:13 <erisco> Cale, send me a msg I am gone for ~15 min or so
18:26:27 <geekosaur> the problem is if you had cabal install the dependencies, runhaskell Setup qwon't see them without --user
18:26:40 <geekosaur> and really it's just easier to use cabal to do it anyway
18:32:55 <shachaf> Does @free have some way of specifying contravariance, or anything of kind * -> * that isn't covariant?
18:35:26 <Rarrikins> roboguy_: Yeah, to compile.
18:35:50 <roboguy_> Rarrikins: cabal can use multiple cores
18:36:24 <Rarrikins> roboguy_: Is that done by the user or can it be done in a .cabal file?
18:36:41 <roboguy_> Rarrikins: "cabal build -jN" where N is the number of cores + 1 (or some number like that)
18:36:49 <roboguy_> I'm not sure if it can be done in a .cabal file
18:37:00 <Rarrikins> roboguy_: OK, thanks :)
18:41:50 <startling> Why doesn't Identity have a Show instance?
18:42:23 <c_wraith> No good reason.
18:42:29 <startling> Sigh.
18:43:04 <startling> Is there somewhere I can import one from that everyone else uses?
18:43:28 <hamster007> http://lpaste.net/98808
18:43:48 <c_wraith> startling: doubt it.  submit a bug report
18:44:02 <hamster007> base vs. haskell98 ^^^
18:44:03 <c_wraith> then wait for a new mtl version
18:44:17 <startling> c_wraith, it's in transformers
18:44:27 <c_wraith> ok..  wait for a new release of transformers!
18:44:41 <pavonia> hamster007: Remove haskell98 form the dependency list in the .cabal file
18:44:48 <startling> edwardk maintains mtl. I wonder if I can convince him to add one to mtl.
18:44:57 <startling> transformers doesn't seem to have a bug tracker.
18:46:47 <joelteon> deriving instance Show Identity
18:47:05 <startling> joelteon, that's an orphan instance.
18:47:08 <joelteon> yep
18:47:29 <joelteon> if I'm actually using Show, odds are I don't care about compiler warnings
18:47:29 <startling> well, an orphan instance without any foster parents.
18:48:06 <startling> joelteon, the downside is that I have to expect that no one else will do the same thing and intend to use my library.
18:49:52 <pavonia> I'm wondering if you can use TH to check if such an instance is already present (and define one only if necessary)
18:50:16 <startling> pavonia, that only works if everyone else does it.
18:51:38 <startling> since e.g. your code is loaded before code that imports it is
18:52:10 <startling> and I think it may be loaded before code that doesn't even depend on it.
18:53:25 <pavonia> Yeah, it's not a good idea at all :p
18:53:52 * hackagebot husk-scheme 3.15.1 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.15.1 (JustinEthier)
18:56:59 <pavonia> It wouldn't even work if two modules in different packages would do that, since the instance would be created when the package is built
18:59:54 <dmj`> what's the best way to convince a pkg author to push their changes to hackage
19:00:44 <enthropy> did you ask them?
19:02:02 <dmj`> yes
19:02:06 <johnw> hi dmj`
19:02:13 <dmj`> johnw!!
19:02:34 <erisco> erisco!!
19:03:06 <johnw> haha
19:03:09 <johnw> hey erisco
19:03:17 <Tekmo> mm_freak: Sorry I missed your message earlier.  That's awesome to hear
19:04:02 <enthropy> "I like your package, but unless you update it now I will leave you"
19:04:09 <enthropy> for some other package
19:04:18 <Tekmo> Haha
19:04:21 <qrada> hey, im noobing it up so hard.. can any1 help. I'm trying to catch an exception that getFileStatus is throwing.. it's some throwBlahMinus1 error.. Thing is, I can't return from that (\e lambda..) .. It's saying I have to return a FileStatus, but my type signature is of IO (Maybe FileStatus).. anyone know I can return Nothing/Maybe from this exception handler?
19:04:26 <qrada> statFileContainer :: FilePath -> IO (Maybe FileStatus)
19:04:29 <qrada> statFileContainer s = do
19:04:31 <qrada> ⇥   catch (getFileStatus s)
19:04:34 <qrada> ⇥   ⇥   ⇥   (\e -> return Nothing)
19:04:36 <qrada> ⇥   return Nothing
19:04:39 <qrada> :f
19:05:34 <BMeph_> If you're using tabs, you've already lost. ;þ
19:05:43 <qrada> ;f
19:06:00 <Tekmo> qrada: The problem is that your first `return Nothing` does not necessarily have anything at all to do with your second one
19:06:02 <qrada> you think it's cause of the tabs? obviously haskell says use spaces..
19:06:18 <erisco> I want to show  fmap f empty == empty  but I do not know what laws govern the interaction of Alternative and Functor
19:06:21 <Tekmo> qrada: Basically the first `return Nothing` replaces the return value of `getFileStatus`, not of your `statFileContainer`
19:06:30 <jrmithdobbs> there's got to be a data X a = Y a | Z [X a] ... already and I'm missing it right?
19:06:37 <c_wraith> > return Nothing >> return Nothing >> return Nothing :: [Maybe Int]
19:06:38 <lambdabot>  [Nothing]
19:06:41 <Tekmo> qrada: So the compiler is complaining because `getFileStatus s` does not return a `Maybe`, but `return Nothing` does
19:06:56 <Tekmo> qrada: What you really want is:
19:07:06 <qrada> ya.. im failing to figure out how to overcome that though
19:07:08 <Tekmo> qrada: catch (getFileStatus s >> return Nothing) (\e -> return Nothing)
19:07:16 <qrada> ah
19:07:22 <qrada> let me try, btw thanks alot
19:07:26 <apples> jrmithdobbs, isn't that a rose tree?
19:07:27 <Tekmo> qrada: You're welcome
19:07:35 <qrada> ive tried for 2 hours (sad :) before asking
19:07:46 <Tekmo> qrada: That's okay.  That's the best way to learn sometimes
19:08:07 <jrmithdobbs> apples: I don't know that's what I'm asking, let me look at the definiton and i'll tell you! ;p
19:08:16 <qrada> ive never used >> operator, it compiled now.. so ill go look this up
19:08:18 <qrada> thanks again!
19:08:49 <Tekmo> qrada: You're welcome!
19:08:57 <Tekmo> qrada: Note that m >> n = do { m; n }
19:09:13 <Tekmo> qrada: (>>) is one of the operations that `do` notation desugars to
19:09:21 <Tekmo> qrada: It's a special case of `(>>=)`
19:09:30 <Tekmo> qrada: m >> n = m >>= \_ -> n
19:10:03 <Tekmo> qrada: If you're new to how do notation desugars, I'd recommend reading this: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
19:10:08 <mada> what's the story of ">>=" as bind? who proposed/chose it?
19:10:46 <jrmithdobbs> mada: it makes great sense if you write things without do notation very quickly
19:10:55 <jrmithdobbs> mada: more quickly so if you like = to line up in code.
19:11:29 <qrada> cool will do.. i just tried >>= in there too.. catch (getFileStatus s >>= \x -> return (Just x))
19:11:38 <qrada> going to test both of these now
19:11:48 <mada> jrmithdobbs: bind wasn't always there, was it? did Haskell always have the notion of monad?
19:11:50 <jrmithdobbs> mada: because the = in >>= can be aligned with the = on the first line and so it looks like multiple statments when it's really infix following the haskell indent rules
19:12:07 <jrmithdobbs> mada: so it's pretty
19:12:09 <mada> jrmithdobbs: yeah that makes sense. It does look good
19:12:13 <mada> :D
19:12:21 <Tekmo> qrada: Also, the wikipedia article on monads is really good.  Better than the last time I checked: http://en.wikipedia.org/wiki/Monad_%28functional_programming%29
19:12:24 <jrmithdobbs> at least, I *assume* this was the reasoning
19:12:37 <jrmithdobbs> and if it wasn't it's a good enough justification anyhow ;p
19:12:44 <Tekmo> mada: Haskell didn't always have monads
19:13:07 <c_wraith> Tekmo: be careful! It didn't always have the Monad abstraction. :P
19:13:24 <jrmithdobbs> ya it always hand monads just unimplemented
19:13:32 <mada> Tekmo: maybe people wrote monadic code anyway?
19:13:54 <Tekmo> c_wraith: Oh really?  I didn't know that
19:13:56 <c_wraith> mada: doubtful there - it got the abstraction at just about the same time it was developed
19:13:56 <jrmithdobbs> erm, s/unimplemented/unstandardized/
19:14:04 <Tekmo> c_wraith: Were people using concrete monads unknowingly back then?
19:14:13 <Tekmo> *concrete instances of the Monad abstraction
19:14:15 <c_wraith> Tekmo: I'm sure there were some uses of concatMap
19:14:22 <Tekmo> c_wraith: Yeah, I gathered that much
19:14:27 <Tekmo> c_wraith: What about parsers?
19:14:40 <c_wraith> I doubt parsers were structured that way.
19:15:02 <c_wraith> Possibly there was some manual state-passing, of the sort State does
19:15:10 <Tekmo> Yeah, that makes sense
19:15:37 <mada> I wish there was a blog analog to "history of python", on haskell
19:15:43 <c_wraith> In any case, without the abstraction, it's not that exciting of an idea.
19:15:49 <Tekmo> Yeah
19:15:58 <Tekmo> No abstraction = no do notation and no Control.Monad
19:16:04 <mada> it'd be pretty cool to know how some things came to be, what the motivation behind was, examples of "old code" and how new features made it "better"
19:16:29 <erisco> mada, well you can read about lazy streams, which predated IO
19:16:31 <c_wraith> mada: there is at least one paper on the history of haskell
19:16:51 <c_wraith> mada: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/history.pdf
19:16:57 <c_wraith> (it has a great title, too)
19:17:03 <mada> c_wraith: thanks, let me take a look at that
19:17:04 <c_wraith> well, subtitle
19:17:10 <c_wraith> and SPJ is a great author
19:17:23 <mada> erisco: I'll google lazy streams too, thanks :)
19:17:58 <c_wraith> the paper that introduced the IO type was also a good one
19:18:46 <c_wraith> http://research.microsoft.com/en-us/um/people/simonpj/Papers/lazy-functional-state-threads.ps.Z
19:18:54 <c_wraith> oddly, there isn't a pdf version of that one
19:19:04 <jrmithdobbs> apples: yes that is a rosetree the hardway
19:19:10 <jrmithdobbs> apples: thanks!
19:19:14 <apples> jrmithdobbs, no prob :)
19:20:25 <greymalkin> geekosaur, dmj`: I got cgi to install with both your help.. thank you. Now to play with gitit :)
19:21:33 <jrmithdobbs> apples: i knew that type definition was way to short to be unique ;p
19:21:42 <apples> haha
19:21:42 <jrmithdobbs> s/to/too/
19:23:22 <erisco> hm, I guess fmap f empty == empty is false
19:24:19 <fread2282> why isn't type RWST r w s m = ReaderT r (WriterT w (StateT s m))? I thought that was the point of mtl
19:26:08 <Tekmo> Wow, that history paper is really good
19:26:30 <zRecursive> @unmtl RWST r w s m
19:26:30 <lambdabot> Plugin `unmtl' failed with: `RWST r w s m' is not applied to enough arguments, giving `/\A. r -> s -> m (A, s, w)'
19:26:46 <erisco> I thought I had a counter-case but nevermind... hrm
19:27:17 <fread2282> It's newtype RWST r w s m a = RWST { runRWST :: r -> s -> m (a, s, w) }
19:28:29 <roboguy_> fread2282: it's probably generalized so it can work with any instance of MonadReader, MonadWriter, etc
19:30:04 <roboguy_> fread2282: you'd be wrapping four arbitrary Monads with the other definition you gave
19:30:42 <fread2282> roboguy_: so for efficiency?
19:30:46 <roboguy_> @unmtl RWST r w s m a
19:30:46 <lambdabot> r -> s -> m (a, s, w)
19:30:51 <roboguy_> fread2282: probably for ease of use
19:32:32 <roboguy_> hmm, it looks like the library rarely needs constraints on those type arguments
19:33:16 <roboguy_> @unmtl RWST ReaderT WriterT StateT m a
19:33:16 <lambdabot> Plugin `unmtl' failed with: `ReaderT' is not applied to enough arguments, giving `/\A B C. A -> B C'
19:33:41 <roboguy_> @unmtl RWST (ReaderT r) (WriterT w) (StateT s) m a
19:33:41 <lambdabot> (ReaderT r) -> (StateT s) -> m (a, (StateT s), (WriterT w))
19:33:52 <fread2282> @unmtl ReaderT r (WriterT w (StateT s m))
19:33:52 <lambdabot> Plugin `unmtl' failed with: `ReaderT r (WriterT w (StateT s m))' is not applied to enough arguments, giving `/\A. r -> (WriterT w (StateT s m)) A'
19:34:38 <fread2282> @unmtl ReaderT r (WriterT w (StateT s m)) a
19:34:38 <lambdabot> r -> (WriterT w (StateT s m)) a
19:35:13 <roboguy_> it's probably easier to compose to
19:35:15 <roboguy_> *too
19:36:57 <roboguy_> fread2282: actually, what do you mean you thought that was the point of mtl? the point of mtl is making Monads easier to compose
19:37:13 <fread2282> roboguy_: yeah, making monad stacks easier
19:37:30 <enthropy> would it make sense if asTypeOf had a lower fixity?
19:37:45 * enthropy thinks around -1 would do
19:38:02 <johnw> make it a complex number
19:39:36 <erisco> how could I exhaustively prove that fmap f empty == empty?
19:40:10 <johnw> with fmap, you cannot
19:40:39 <erisco> well, I am trying to come up with counter-examples, but am failing to do so
19:40:43 <johnw> because f :: a -> b, you don't know anything about a or b
19:40:53 <roboguy_> johnw: he means for a specific instance I think
19:40:58 <erisco> no I mean in general
19:41:02 <roboguy_> oh
19:41:06 <roboguy_> then you probably can't
19:41:14 <roboguy_> what does "empty" mean for the Identity functor?
19:41:30 <roboguy_> or Either?
19:41:42 <erisco> for types which are both Monoid and Functor
19:41:46 <erisco> sorry
19:41:52 <erisco> Alternative and Functor
19:42:01 <johnw> if you include the restriction that a and b are both Monoid, then you could prove something about that restricted case
19:42:11 <johnw> although, I still don't think you can
19:42:12 <qrada> hey, im using threadpoolIO frm concurrent.engine.. I don't think it does what I "need". I want to 'block' when I writeChan to the input channel... Anyone know if this is possible with threadpoolIO or should I use a different library?
19:42:21 <fread2282> roboguy_: unrolling that all the way gets r -> s -> m (a, w, s), almost equal to the current RWST (r -> s -> m (a, s, w))
19:42:49 <roboguy_> fread2282: hmm, makes sense. you can avoid a lot of wrapping/unwrapping that way
19:44:23 <erisco> johnw, there has to be limited ways in which to construct an ADT. ie, a limited number of patterns
19:44:34 <erisco> if I could do case analysis and prove all the cases, that could work
19:44:58 <johnw> erisco: then you're not talking about fmap in general anymore, but some particular 'fmap'
19:45:03 <roboguy_> erisco: hmm. consider a Functor instance for Sum
19:46:54 <roboguy_> fmap (+10) (mempty :: Sum Int) == Sum 10
19:47:05 <roboguy_> given an appropriate Functor instance
19:47:15 <roboguy_> or I should say, the appropriate Functor instance
19:47:30 <erisco> hmm
19:48:46 <erisco> why do I have no instances defined for Sum? :s
19:49:06 <erisco> I suppose it only has a Monoid instance
19:49:20 <roboguy_> it has Show, Read, Num, Eq, ...
19:49:28 <erisco> and friends
19:49:41 <roboguy_> ahh, well, I'm saying suppose the Functor instance is defined
19:49:42 <erisco> I think that is a counter example then
19:50:06 <roboguy_> a valid Functor instance could be defined for it
19:51:05 <roboguy_> I'm not sure how much can be said about the interaction between Functor and Monoid now that I think about it...
19:51:22 <erisco> well hang on
19:51:24 <frx> roboguyit would require Monoid constraint, and Functor needs to work for all a
19:51:28 <frx> +it
19:51:31 <erisco> roboguy_, I am not so sure it is a counter example
19:51:40 <erisco> because it has additional constraints
19:52:48 <roboguy_> hmm, if you want something with no constraints I'm not sure
19:52:59 <roboguy_> frx: why would it need a Monoid constraint?
19:53:03 <erisco> I imagine it is   instance (Num a) => Monoid (Sum a) where ...
19:53:09 <roboguy_> yeah
19:53:18 <w00t_> what is the purpose of having both map and fmap?
19:53:23 <erisco> so for the Alternative that could not happen
19:53:27 <roboguy_> w00t_: simpler error messages with map
19:53:32 <w00t_> when fmap works for lists
19:53:52 <geekosaur> w00t_: the keepers of the standard think newcomers would be too terrified by simple list type errors throwing Functor constraint errors
19:53:52 <roboguy_> w00t_: it's just so it's less complicated to understand at first
19:54:12 <geekosaur> the community argues over this somewhat regularly, but it remains
19:54:18 <lllllllllllll> what is |- called in latex?
19:54:25 <w00t_> roboguy_: then why no return for IO and mreturn for Monads?
19:54:39 <roboguy_> w00t_: that would make things *more* complicated
19:54:41 <qrada> ooh control.concurrent.boundedchan, nice
19:54:43 <lllllllllllll> like in \Gamma |- x:A
19:54:52 <w00t_> roboguy_: how?
19:55:12 <ion> Control.Concurrent.4Chan
19:55:28 <shachaf> The English name for it is "turnstile". That might help you. #latex might also know.
19:55:31 <w00t_> roboguy_: you would get errors about IO instead of Monads
19:56:01 <ion> “writeList2Chan” This naming scheme is horrible.
19:56:05 <erisco> so, again, perhaps if there are finite cases for how you can construct an ADT, then there might be a proof
19:56:06 <roboguy_> w00t_: if you're working with IO, you probably already know that it is a Monad at least. that's more common knowledge outside of haskell than list being a Functor
19:56:12 <geekosaur> http://www.artofproblemsolving.com/Wiki/index.php/LaTeX:Symbols
19:56:36 <w00t_> roboguy_: most newbies use IO way before grooking monads
19:56:38 <erisco> augur_, is it Agda that has a finite number of types?
19:56:54 <roboguy_> erisco: what if you define mempty to be something like SomeDataConstructor 1, where SomeDataConstructor :: Int -> SomeDataType a?
19:57:10 <roboguy_> w00t_: well, also return is not a higher order function which makes it easier to understand
19:57:19 <shachaf> w00t_: OK, you win. It makes no sense.
19:57:27 <shachaf> But that's the way it is anyway.
19:57:32 <erisco> roboguy_, write up the complete counter example please
19:57:42 <roboguy_> erisco: alright, let's see here...
19:57:49 <qrada> im thinking I can get rid of my threadpool and just use a bounded channel, any time i receive a message I just create a thread and run my handler? makes sense or.. im just trying to get a behavior of, having only a pool of N threads max capable of running, and, if they reach maximum, to block on new write's to the channel, until it becomes available
19:59:09 <augur_> erisco: no
20:00:11 <erisco> augur_, hm... there was a language I thought you were mentioning that built everything off a few basic types. iirc something like  (,) , Either a b, Void
20:00:40 <augur_> yes, you can do that, but it doesnt mean you have finitely many types
20:01:02 <augur_> you have an infinity of types generated by a finite collection of type formers
20:01:17 <w00t_> roboguy_: that is true. still, I am not sure why would specializing return for IO make things more complex..
20:01:18 <roboguy_> erisco: actually, you might be right. you could do it with a constraint on the Monoid instance but maybe you can't without that
20:01:18 <erisco> oh, maybe I have the incorrect term. finite type system maybe? finite judgements?
20:01:34 <augur_> im not sure what you mean, erisco
20:01:50 <erisco> eh, old conversation I guess
20:02:09 <w00t_> roboguy_: it would eliminate two things newcomers are potentionally unfamiliar with, monads and typeclasses
20:02:35 <erisco> augur_, thanks anyways :)
20:02:40 <roboguy_> w00t_: I'm just not very convinced the error message would be that much clearer. give me a concrete example
20:02:53 <augur_> erisco: well you could elaborate more and i might have an answer! :P
20:03:02 <erisco> augur_, oh, well in that case...
20:03:16 <w00t_> roboguy_: it would say IO in the error message, instead of Monad m
20:03:32 <lllllllllllll> thx geekosaur \vdash was it
20:03:52 <erisco> augur_, I am trying to show that  fmap f empty == empty   in general for Alternative types. (I need this for another proof)
20:04:14 <w00t_> roboguy_: and you argued it would be *less* clear :)
20:04:19 <roboguy_> w00t_: it seems to me the most common error would be to return with an argument of the wrong type, in which case it wouldn't mention Monad
20:04:27 <augur_> erisco: what is the statement you want to prove
20:04:46 <erisco> augur_, fmap f empty == empty
20:05:13 <augur_> erisco: yes but thats not the entire proposition!
20:05:22 <w00t_> anyway, I am a bit annoyed that they made things less elegant just for more newbie friendly error messages
20:05:22 <erisco> augur_, sorry what am I missing?
20:05:24 <roboguy_> w00t_: the Monad thing would mainly come up if they're passing IO to another function or something like that, in which case they should probably already know about Monad because that's a relatively advanced thing to be doing
20:05:30 <augur_> erisco: what types are relevant here?
20:06:16 <roboguy_> w00t_: but something like this wouldn't mention Monad at all : main :: IO (); main = return 1
20:06:18 <erisco> augur_, I want to prove it holds for any valid instance
20:06:40 <Ralith> roboguy_: it also wouldn' ttypecheck
20:06:49 <roboguy_> Ralith: that's part of my point
20:06:54 <Ralith> kay
20:07:05 <augur_> erisco: i think its something like   forall a b. (Alternative a, Alternative b) => forall f :: a -> b. fmap f empty_a = empty_b
20:07:56 <augur_> tho that wont work actually
20:08:08 <augur_> you need something like alternative f or whatever for some f
20:08:16 <w00t_> roboguy_: yeah, neither does toLowerStr :: String -> String.  toLowerStr = fmap toLower mention functors
20:08:19 <augur_> i dont know how alternative works so
20:08:35 <augur_> but erisco, for haskell, i dont think this proof is possible
20:08:52 <roboguy_> w00t_: that does type check though
20:09:25 <w00t_> who knows I did not test. looks fine to me at a glance
20:09:27 <erisco> augur_, well, it may require a few extra assumptions, but I think a compelling case might be made
20:09:42 <w00t_> why wouldnt it?
20:10:09 <w00t_> oh nm, I misread does as doesn't
20:10:17 <w00t_> need more beer
20:10:46 <erisco> augur_, my thought is to show that it holds for any ADT. A start would be assuming that all ADTs are isomorphic to an ADT constructed with (a, b) ; Either a b; Void
20:11:43 <erisco> augur_, or something like such. basically designing a finite set of cases that can be reasonably assumed to account for all cases in Haskell
20:12:05 <w00t_> roboguy_: I see your point now about main. still, you are happy with duplicating functionality just to make things more newbie friendly?
20:12:07 <augur_> erisco: except thats not true.
20:12:28 <augur_> just because some languages restrict their ADTs to that doesnt mean its true for haskell
20:12:44 <erisco> augur_, well, perhaps it is not. I am happy to get some help :)
20:12:51 * geekosaur wonders if it's worth repeating his earlier statement
20:13:00 <augur_> i dont think you can do these kinds of proofs for an open ended language like haskell
20:13:08 <roboguy_> w00t_: I don't really mind with map. in fact sometimes it helps me; if I'm reading something complex, I can immediately tell we are using the [] Functor
20:13:11 <geekosaur> [20 03:49] <geekosaur> the community argues over this somewhat regularly, but it remains
20:14:46 <roboguy_> erisco: let's see. all fields of data constructors that have concrete types must be preserved by fmap right? And to put something into a field that is not concrete in a Monoid instance, you must have a constraint
20:15:05 <augur_> erisco: i think at best you can show preservation properties
20:15:59 <roboguy_> so if you try to make something like Const 3 be mempty, the fmap must preserve that
20:17:06 <roboguy_> but if you have something that has a type variable in it, like HoldingInt Int a, you must have a constraint on the Monoid instance to put something in the a field for mempty
20:18:26 <roboguy_> so if we're not allowed to have a constraint on the Monoid instance, I pretty strongly suspect that fmap f mempty = mempty in all cases
20:18:48 <erisco> I also strongly suspect that
20:18:59 * hackagebot spsa 0.2.0.0 - Simultaneous Perturbation Stochastic Approximation Optimization Algorithm  http://hackage.haskell.org/package/spsa-0.2.0.0 (yanatan16)
20:19:02 <erisco> well, fmap f empty == empty ... I am working with Alternative
20:19:09 <marx2> what html parsing library do you use? HXT does not support Text
20:19:40 <roboguy_> erisco: actually, that might change things
20:19:50 <erisco> nah
20:20:30 <marx2> that can parse malformed html
20:20:31 <danharaj> edwardk: I find it weird that CoT gives you a way to talk about morphisms (forall a. w a -> m a) and how to compose them without requiring a distributive law. That quantifier does a lot of work :p
20:21:20 <L8D> Is there any reasons to use Scheme over Haskell?
20:21:27 <L8D> Besides polymorphism
20:21:34 <erisco> well... I suppose I'll just use it as an unproved assumption and leave it for another time
20:22:03 <roboguy_> L8D: polymorphism is a reason to use Scheme over Haskell?
20:22:21 <L8D> roboguy_: It's a reason to use LISP over ML
20:22:23 <w00t_> map, fmap, <$>, ., liftA, listM  :(
20:22:29 <erisco> thanks for the help augur_ and roboguy_
20:22:36 <w00t_> did I miss one?
20:22:37 <roboguy_> L8D: what do you mean by polymorphism?
20:22:43 <ChongLi> the reason to use scheme is if you like macros but hate types
20:22:45 <roboguy_> erisco: sure! I wish I could have been more help though, haha
20:22:57 <roboguy_> ChongLi: yeah, pretty much
20:23:07 <L8D> roboguy_: being able to create programs with programs
20:23:13 <roboguy_> L8D: that's not polymorphism
20:23:22 <erisco> I forgot a -> b in the set of basic types
20:23:33 <augur_> erisco: i dont think its just unproved, i would bet its false.
20:23:35 <ChongLi> after spending so much time with this stuff, I find it difficult to understand why people hate types
20:23:39 <L8D> then what is it I'm thinking of...
20:23:40 <ChongLi> and yet they do
20:23:44 <marx2> > unsafeCoerce "LOL" :: Int
20:23:46 <lambdabot>  Not in scope: `unsafeCoerce'
20:23:55 <roboguy_> L8D: metaprogramming
20:23:57 <erisco> augur_, yeah and that is what is worrying me the most
20:23:58 <augur_> tho maybe not, who knows
20:24:03 <L8D> roboguy_: yeah, that then
20:24:04 <roboguy_> L8D: polymorphism has to do with type systems
20:24:05 <shachaf> "which is better, language X or Haskell?" almost certainly doesn't belong in this channel.
20:24:16 <ChongLi> Haskell has tons of metaprogramming capability
20:24:18 <erisco> augur_, but I am failing to find a counter case and the only real way to know is to attempt a proof
20:24:22 <ChongLi> and I'm not even referring to TH
20:24:27 <roboguy_> L8D: which is why I was confused. Scheme doesn't have polymorphism and Haskell does
20:24:34 <L8D> Well, I'm really asking for which I should use for a curriculum on functional programming
20:24:51 <roboguy_> L8D: I think you know what answer we'll give you, haha
20:24:51 <marx2> perverse curiosity: why is unsafeCoerce "LOL" :: Int64 sometimes returning negative numbers?
20:24:53 <augur_> erisco: it might help to look at the laws for Alternative as well
20:25:20 <erisco> augur_, they are the same as for Monoid. the only difference is that Alternative is for kinds of * -> *
20:25:31 <erisco> augur_, and it depends on Applicative
20:25:31 <L8D> roboguy_: do you think that Haskell will be easier to understand than Scheme?
20:25:32 <triliyn> marx2: presumably it's an unsigned pointer being coerced to a signed integer
20:25:35 <shachaf> And what answer do you expect to get from this channel? :-)
20:25:41 <Ralith> roboguy_: I'm pretty sure scheme has *some* kind of polymorphism
20:25:44 <ChongLi> L8D: reminds me of the person on hacker news that was talking about that, Nimi
20:25:48 <marx2> triliyn I am on 32 bit system
20:25:55 <ChongLi> wanted SICP for their EE curriculum
20:26:05 <ChongLi> but was fighting the faculty over it
20:26:09 <augur_> erisco you might be able to hook those together to get it to work!
20:26:11 <roboguy_> Ralith: I don't think R5RS or R6RS has any form of multiple dispatch. although you could definitely add it if you wanted to
20:26:20 <geekosaur> then it's getting the pointer as its top half and you're lucky what's after it doesn't cause SIGSEGV
20:26:40 <geekosaur> because you're reading what is probably uninitialized memory (but may possibly belong to something else)
20:26:50 <Ralith> roboguy_: that seems very strange.
20:26:59 <L8D> ChongLi: could you link to the article?
20:27:00 <roboguy_> Ralith: scheme is a very small language
20:27:11 <roboguy_> especially if we only consider the standard
20:27:12 <Ralith> fair enough
20:27:16 <ChongLi> https://news.ycombinator.com/item?id=7080714
20:27:27 <roboguy_> Racket I'm sure has some form of multiple dispatch on the other hand
20:27:29 <Ralith> roboguy_: I'm pretty sure *racket* has some kind of polymorphism
20:27:32 <Ralith> heh
20:27:33 * ChongLi waits to be crucified for recommending a Bob Harper course
20:27:45 <geekosaur> enh
20:28:05 <marx2> I love to annoy python programmers with that link
20:28:06 <c_wraith> Bob Harper is a very smart guy, and a good teacher.  He just hates haskell
20:28:39 <ChongLi> sure, but he hates all other languages (besides ML, Haskell, NuPRL and a few others) even more
20:28:54 <ChongLi> Haskell is in the uncanny valley for him
20:29:03 <marx2> no that wasn't the link.. "dynamic languages are static languages"
20:29:05 <c_wraith> SML is the best programming language of all time.  Since he implemented it.
20:29:08 <danharaj> Are we having a redux of this discussion @_@
20:29:09 <shachaf> statements like "/me waits to be crucified for recommending a Bob Harper course" are far worse than recommending a Bob Harper course
20:29:16 <ChongLi> it's so close to the ideal language but it's got a few compromises that he doesn't want
20:29:20 <erisco> augur_, perhaps. I am looking there too but it is not my strong suit
20:29:22 <ChongLi> and so he hates it
20:29:31 <c_wraith> But honestly, Bob Harper courses are good.
20:29:33 <augur_> erisco: its good to have all these things written out
20:29:42 <shachaf> danharaj: That's all #haskell is.
20:30:03 <erisco> augur_, which things? I have the laws and my proof on screen
20:30:09 <Tekmo> I'm glad that Bob Harper voices his criticisms, even if I don't always agree
20:30:13 <roboguy_> erisco: also, for (->) types, any type argument must be in the covariant position for it to be an instance of Functor, and this means we can't have Alternative at all for those types (I think)
20:30:15 <L8D> Are there any good lazy scheme-like LISPs out there?
20:30:16 <augur_> erisco: the laws. all of them.
20:30:19 <ChongLi> and I think if one were to become an SML expert it'd provide a lot of benefits for working in Haskell too
20:30:35 <ChongLi> Tekmo: hey, I really liked your post about rewrite rules for pipes
20:30:47 <erisco> roboguy_, I do not think that is true
20:30:48 <Tekmo> ChongLi: Thanks! :)
20:30:54 <roboguy_> erisco: no?
20:31:11 <ChongLi> it gave me a crazy idea: would it be possible to automate the search for free theorems for deriving new rewrite rules?
20:31:21 <roboguy_> erisco: the exception would be a -> a, I suppose. other than that though
20:31:22 <w00t_> shachaf: your constant complains about topics at hand are even worse.  get that sand out of your vagina
20:31:33 <Tekmo> ChongLi: I think so, but I'm not sure
20:31:42 <roboguy_> erisco: or, actually, I guess we could have anything that reduces to a -> a. hmm
20:31:45 <geekosaur> w00t_, how about you moderate your comments
20:31:47 <Tekmo> ChongLi: I briefly alluded to the harder part in my post: knowing which side of the equation is more efficient
20:31:48 <erisco> roboguy_, a -> a is not a Functor
20:31:49 <augur_> erisco, roboguy_: you can probably have Alternative f => Alternative (a -> f b)
20:31:51 <augur_> or something like that
20:31:51 <Tekmo> ChongLi: It's not always obvious
20:31:54 <Ralith> shachaf: man, why's everyone hating on you lately
20:31:54 <geekosaur> lest someone else do it for you
20:31:56 <ChongLi> Tekmo: ahhh, yeah
20:32:11 <Tekmo> ChongLi: Or sometimes you have to do a more inefficient substitution to make a more efficient one possible
20:32:13 <ChongLi> so you could generate a big mess of equivalent expressions
20:32:14 <roboguy_> erisco: right, good point
20:32:17 <Tekmo> ChongLi: An example of this is something like:
20:32:26 <Tekmo> ChongLi: forever (lift m >> return r)
20:32:31 <Tekmo> ChongLi: That could be optimized to:
20:32:37 <Tekmo> ChongLi: lift $ forever (m >> return r)
20:32:48 <Tekmo> ChongLi: But in order to do that you'd have to first go through an inefficient substitution
20:32:57 <roboguy_> erisco: I can't think any function type that is a Functor and an Alternative
20:32:59 <Tekmo> ChongLi: You'd have to first substitute `return r` with `lift (return r)`
20:33:03 <ChongLi> ahhhh
20:33:12 <erisco> roboguy_, Foo ((Int -> a) -> Int) Bool  might work
20:33:15 <roboguy_> augur_: that has the wrong kind
20:33:15 <ChongLi> so you get stuck in local minima
20:33:20 <Tekmo> ChongLi: Right
20:33:25 <L8D> :t lift
20:33:26 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
20:33:31 <ChongLi> that seems like a problem with a lot of different sorts of AI
20:33:51 <Tekmo> Yeah
20:34:32 <augur_> roboguy_: abstract over a somehow :)
20:34:36 <augur_> er, over b
20:34:45 <ChongLi> I've actually thought about that a lot and I struggle to imagine a general solution to the problem of local minima
20:34:48 <Tekmo> One solution I've entertained with wild ideas is to design a language where inefficient code is simply unrepresentable
20:34:57 <Tekmo> In other words, everything's normal form is simply the most efficient form
20:34:57 <ChongLi> besides just throwing some randomness
20:35:03 <geekosaur> glwt...
20:35:36 <ChongLi> ahh, so the challenge then becomes to figure out a way to express the idea at all!
20:35:43 <Tekmo> Yeah
20:35:59 <erisco> roboguy_, then again I am not sure what the Applicative instance is
20:36:03 <Tekmo> I haven't put a lot of thought into it, though.  It's just a wild idea
20:36:18 <ChongLi> yeah, tons of those flying around
20:36:24 <Tekmo> :)
20:36:30 <ChongLi> I wish I understood homotopy type theory better
20:36:44 <roboguy_> erisco: does that type have a Functor instance?
20:36:46 <ChongLi> then I'd know if some of my wild ideas around it were plausible
20:37:06 <roboguy_> erisco: it seems like the "a" is in a contravariant position
20:37:06 <erisco> roboguy_, if not then (a -> Int) -> Int  it is one way or the other
20:37:13 <erisco> too tired to think any more :P
20:38:22 <roboguy_> it seems like that would be like ((->) a Int) -> Int and I don't think you can fmap over an argument like that
20:38:39 <roboguy_> I think that would have to be Contravariant instead
20:39:13 <ChongLi> yeah, to the person who was talking about scheme earlier
20:39:18 <ChongLi> learn about Haskell's rewrite rules
20:39:48 <ChongLi> they accomplish one of the big use-cases of macros
20:40:04 <ChongLi> and actually do type checking before and after the transformation
20:40:24 <ChongLi> something I don't think even typed racket does
20:40:43 <ChongLi> I believe it only does type checking after macro expansion
20:44:13 <geekosaur> <pedant> those are ghc rewrite rules, not part of the Haskell standard </pedant>
20:44:41 <ChongLi> yeah I regretted almost immediately after I sent it
20:44:47 <ChongLi> but figured someone would step in :)
20:45:00 <c_wraith> there's a lot of good stuff in GHC that's not in the standard
20:45:11 <ChongLi> but it eventually might be?
20:45:12 <c_wraith> Which is both good and bad, and both in a bunch of different ways
20:45:26 <c_wraith> ehhhh.  Unless the standard starts gaining optional parts, I don't see it
20:45:40 <c_wraith> Things like rewrite rules would just increase the implementation effort by a huge amount
20:45:52 <geekosaur> rewrite rules I am not sure belong in the standard; I would for example expect ajhc to use something different from ghc's rewrite rules
20:46:01 <ChongLi> ahhh
20:46:16 <ChongLi> yeah I don't know much about ajhc
20:46:28 <geekosaur> besides, don't they have some interesting interactions with ghc's pass order that aren't even remotely guaranteed to be similar in other compilers?
20:46:40 <c_wraith> yeah, rewrite rules are kinda fragile
20:47:19 <erisco> augur_, well I unfortunately cannot see how to hook them together. what kind of language is this anyways? :P
20:47:34 <augur_> erisco: what kind of language is what
20:48:34 <erisco> augur_, Haskell
20:48:51 <augur_> erisco: what do you mean what kind of language? :D
20:49:03 <erisco> can't prove basic stuff mang
20:50:02 <augur_> who says this is basic?
20:50:35 <erisco> no one
20:51:51 <erisco> what normally happens in mathematics when a proof requires more than the current framework offers?
20:52:40 <c_wraith> either you adopt a new framework, or you declare yourself done.
20:52:40 <ChongLi> you prove other things and use them as lemmas
20:52:54 <ChongLi> it's just like writing a program
20:53:02 <ChongLi> if you need some function that doesn't exist
20:53:07 <ChongLi> you write that function, then you use it
20:54:32 <mada> I need to select one of many git bindings. I want to reimplement a very simple set of scripts in haskell
20:54:53 <mada> now here http://stackoverflow.com/questions/6609643/haskell-library-to-manipulate-a-git-repo I see many options
20:55:23 <mada> does anybody have experience with any of them, maybe some tips as to which could be good for simple interaction with a repo?
20:55:38 <shachaf> sigh
20:55:50 <mada> all "high level" operations, so I don't think I'll need actual binding with gitlib
20:55:54 <erisco> hmm
20:56:22 <mada> (high level being branching, merging and such)
20:56:27 <erisco> how much help may category theory be here? I still have an intro paper to read on my desktop
20:56:41 <augur_> erisco: it wouldnt be any help
20:57:11 <augur_> erisco: there are two ways this proof could be done, 1) is by analyzing the language like you were asking about, which i think is going to be impossible
20:57:42 <augur_> 2) is going to be if you could prove, or if Alternative demanded, some interaction with functoriality or applicativity in a particular way
20:58:35 <augur_> alternative does have some interactions with applicative, but they're cloaked through aux functions
21:00:18 <erisco> well, in regards to (2), http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html concludes 'fmap f x = pure f <*> x' but the proof is not obvious to me yet
21:01:21 <augur_> ah well, that might be why you cant figure these things out too :)
21:01:25 <augur_> you need to leave how to do proofs!
21:01:41 <erisco> I said it was not one of my strengths
21:02:15 <ChongLi> substitution!
21:02:49 <ChongLi> just substitute each function with its definition and then simplify
21:03:06 <erisco> there are no definitions
21:03:16 <erisco> only the applicative and functor laws
21:03:28 <ChongLi> right, but that is because they are laws
21:03:40 <ChongLi> to prove them you have to use a particular instance
21:03:55 <ChongLi> otherwise you're just proving a tautology
21:04:07 <erisco> that is what I want
21:04:24 <erisco> I want to figure out their proof for  fmap f x = pure f <*> x
21:04:41 <roboguy_> ChongLi: it says that fmap f x = pure f <*> x can be derived from the laws
21:05:40 <ChongLi> no, it says that the Functor instance for f
21:05:58 <ChongLi> but to prove that, you need an instance of that Functor, namely f
21:06:00 <roboguy_> ChongLi: ?
21:06:28 <ChongLi> if you look at the laws alone, they make no mention of fmap
21:06:38 <roboguy_> right
21:06:45 <roboguy_> oh, I see
21:06:46 <shachaf> fmap f x = pure f <*> x can be derived from the Applicative laws.
21:06:47 <augur_> ChongLi: applicatives are functors, preconditionally
21:07:39 <shachaf> (And the Functor laws.)
21:07:46 <ChongLi> yeah, was just going to say that
21:08:03 <augur_> honetly i have no idea how to prove fmap f x = pure f <*> x. im not good at doing these proofs in haskell
21:08:08 <ChongLi> otherwise you'd have no way to eliminate fmap
21:08:22 <shachaf> eliminate?
21:08:43 <ChongLi> yeah, from the left side of the equation
21:09:04 <shachaf> I'm not sure what you're going for, but OK.
21:09:10 <erisco> shachaf, I would like seeing the proof
21:09:32 <shachaf> Clearly if you know nothing at all about what "fmap" is you won't be able to prove very much about it.
21:09:40 <roboguy_> I suspect you turn f into (f . id) and work from there
21:10:41 <augur_> i doubt it
21:10:46 <ChongLi> or if you just take f to mean id
21:11:01 <ChongLi> fmap f x = pure f <*> x
21:11:09 <augur_> you cant take f to mean anything
21:11:13 <ChongLi> fmap f = pure f <*>
21:11:22 <ChongLi> fmap id = pure id <*>
21:11:27 <ChongLi> and so on and soforth
21:11:33 <augur_> that doesnt work ChongLi
21:11:55 <ChongLi> you end up with id = id :)
21:12:03 <enthropy> augur_: they are the same for (f = id), and they have the same type when you pick a more general (f :: a -> b)
21:12:05 <augur_> yes, but now do that for f /= id
21:12:22 <dmj`> pure id <*> v = v
21:12:23 <enthropy> what other function is possible?
21:12:26 <augur_> showing that it holds for id is not the same as showing that it holds for everything.
21:12:39 <augur_> enthropy: any function with the right type
21:12:51 <augur_> the consequence is supposed to hold for _all_ functions f
21:13:13 <augur_> and its not a function with type f :: a -> b
21:13:17 <johnw> all you need to prove is that pure f <*> x follows the two functor laws, no?
21:13:19 <enthropy> it can't just make up a function with type a -> b
21:13:21 <augur_> but a function with type A -> B, for some A, B
21:13:34 <augur_> enthropy: no you're not understanding what its saying
21:13:35 <enthropy> don't you believe in free theorems?
21:13:40 <augur_> ...
21:13:48 <roboguy_> are you saying that because something holds if f = id, it must hold for all possible choices of f?
21:13:50 <augur_> enthropy: you dont know enough about free theorems to even thrown that around
21:13:59 <shachaf> johnw: You also need to prove that Functor instances are unique.
21:14:05 <johnw> ah, good point
21:14:05 <shachaf> Which is rather trickier.
21:14:06 <augur_> the equation has to hold for all choices of f. that is what the equation says.
21:14:31 <roboguy_> enthropy: pure id <*> v = v holds for id, but clearly not for other choices of function
21:15:00 <augur_> these equations on the wiki presuppose you understand where the quantifiers are supposed to do
21:15:02 <augur_> go*
21:15:10 <augur_> fmap f x = pure f <*> x
21:15:14 <augur_> is really shorthand for
21:15:57 <augur_> forall (F :: * -> *) (A B :: *) (f :: A -> B) (x :: F A).   fmap f x = pure f <*> x
21:16:17 <augur_> well, with some constraints thrown in there
21:16:45 <augur_> to get the functor and applicative instances into the proposition as well
21:17:56 <augur_> now, you might pick A = B, and f = id, and then the proof is easy, but then you've ONLY shown it for that one case
21:18:04 <augur_> you have to show that it works for ALL choices of A, B, and f
21:18:40 <augur_> so if you pick A = String, B = Int, f = length, it still has to be true
21:18:52 <augur_> it has to be true for _every choice you could possibly make ever ever ever_
21:19:21 <ChongLi> what if f = _|_
21:19:22 <ChongLi> ?
21:19:38 <augur_> fast and loose blah blah blah
21:19:44 <ChongLi> hahaha :)
21:19:44 <roboguy_> ChongLi: that has more to do with strictness doesn't it?
21:19:57 <augur_> these laws are expected to hold when it makes sense to demand that they hold :)
21:20:04 <ChongLi> I would think it probably works out as long as you don't introduce seq
21:20:21 <ChongLi> or use a strict constructor
21:20:23 <augur_> if you pretend haskell is total, and thus subject to normal equational reasoning, it holds
21:20:57 <augur_> OMG OMG OMG AHHHH
21:21:00 <augur_> NEW CATSTERS VIDEOS
21:21:01 <augur_> AHHHHHHHHHH
21:21:37 <erisco> what is a cat... ster?
21:21:45 <dmj`> http://www.youtube.com/user/TheCatsters
21:21:45 <ChongLi> 4 years ago... 3 years ago... 1 week ago!
21:21:54 <Tekmo> They do a category theory series
21:22:16 <erisco> quite the hiatus
21:22:23 <augur_> its a british series
21:22:28 <augur_> they're known for their long hiatuses
21:25:19 <erisco> well at least we learned lots today
21:29:15 <enthropy> augur_: I think you misunderstand me
21:29:38 <augur_> perhaps i did
21:30:25 <b80905> can takeWhile be defined in terms of foldr or foldl?
21:31:11 <augur_> yes, foldr
21:31:52 <b80905> augur_: how?
21:32:00 <enthropy> augur_: if it has a type  (a -> b) -> f a -> f b, it has to use the first argument on whatever `a` is in the original `f b`, no?
21:32:07 <augur_> b80905: do you want a philosophical answer or some code?
21:32:26 <b80905> augur_: the latter
21:32:26 <augur_> enthropy: i dont know what "it" is here.
21:32:27 <roboguy_> enthropy: what about data Proxy a = Proxy?
21:32:31 <augur_> b80905: dont know :D
21:32:46 <ChongLi> augur_: I think it is f
21:32:49 <apples> it can definitely be defined in terms of unfoldr, can't think of a way to do it with foldr though
21:32:53 <enthropy> it is  fmap :: (a -> b) -> f a -> f b
21:33:00 <haasn> b80905: is fst . foldr f x  acceptable?
21:33:07 <ChongLi> in fmap f x = pure f <*> x
21:33:20 <enthropy> roboguy_: yeah there you have no values to worry about
21:33:39 <enthropy> you could also have some    fmap f _ = Nothing -- going on
21:33:41 <augur_> enthropy: i dont know what you're trying to say. you need to use less pronouns and more specific terms. just say the idea, dont gesture towards it
21:33:48 <roboguy_> enthropy: "data Const a b = Const a" has a value, but I'm not sure where you're going yet
21:33:48 <b80905> haasn: yeah
21:34:02 <ChongLi> fewer pronouns :)
21:34:12 <augur_> ChongLi: less.
21:34:17 <roboguy_> (potentially has a value, anyway)
21:34:24 <erisco> maybe if I keep the pot stirred someone will solve it for me :P
21:34:54 <ChongLi> augur_: pronouns is a count noun, not a mass noun
21:35:13 <jtcwang> how do we achieve "var += 1" in let blocks?
21:35:15 <enthropy> augur_: fmap has to use the first argument given to fmap to make up actual values of type `b' that occur, right?
21:35:20 <augur_> ChongLi: yes, and less is neutral between count and mass terms
21:35:36 <augur_> enthropy: no.
21:35:40 <Tekmo> jtcwang: I think there might be a `+~` operator for lens
21:35:48 <johnw> Tekmo: there is
21:36:01 <Tekmo> jtcwang: Usually lens operators with an `=` sign have a pure analog with the `=` replaced with `~`
21:36:02 <jtcwang> i haven't used lens
21:36:05 <augur_> enthropy: fmap has to satisfy the law fmap id x = x. thats it.
21:36:10 <augur_> oh and composition
21:36:11 <jtcwang> b4
21:36:15 <enthropy> what I mean by "actual values" are things like (5 :: Int) in the case that the `b' type variable ends up specialized to `Int'
21:36:16 <Tekmo> jtcwang: Are you talking specifically about lens then or just how to increment a value?
21:36:17 <roboguy_> enthropy: unless it's a phantom type, then yes
21:36:18 <augur_> fmap (f . g) x = fmap f (fmap g x)
21:36:25 <c_wraith> jtcwang: the answer is "you can't rebind a value"
21:36:28 <jtcwang> Tekmo, how to increment a value
21:36:31 <jtcwang> hm
21:36:35 <Tekmo> jtcwang: Define a new one
21:36:35 <dhrosa> jtcwang: you don't, you make a new value
21:36:36 <ion> bar = foo + 1
21:36:38 <erisco> augur_, fmap f . fmap g == fmap (f . g)   is what the official definition says
21:36:41 <Tekmo> jtcwang: let val' = val + 1
21:36:45 <augur_> erisco: yes yes
21:36:49 <ion> “foo = foo + 1” is a false equality.
21:36:57 <augur_> enthropy: assuming there are values of type b anywhere to be found
21:37:07 <jtcwang> i guess with immutability yeah
21:37:14 <dhrosa> foo = foo + 1 is valid code, it will infinitely loop though :p
21:37:28 <jtcwang> dhrosa, i've experienced that first hand :P
21:37:49 <dhrosa> jtcwang: what are you trying to do? so we can show you the more idiomatic way
21:38:13 <jtcwang> i'm currently trying to implement a state machine
21:38:14 <jtcwang> with newtype Auto a b = Auto { stepAuto :: a -> (b, Auto a b) }
21:38:18 <ChongLi> oh, Haskell plugin for lighttable
21:38:22 <augur_> enthropy: and while it may be true in practice that this ends up being true for haskell types, its an extraordinarilly complicated thing to prove and you cant rely on it here.
21:38:37 <jtcwang> problem is there is no way to extract the state for the current run unless you provide it with some value
21:38:46 <jtcwang> input*
21:38:59 <enthropy> we are reasoning about haskell types here, no?
21:38:59 <jtcwang> you can do a dry run ofc, but i don't think that's too good
21:39:05 <augur_> ChongLi: specifically, less is ambivalent betweeen mass and plural
21:39:08 <jtcwang> espcially for more complicated state machines
21:39:18 <jtcwang> so i'm just wondering what's the best way to approach it?
21:39:20 <augur_> enthropy: about, yes, but the theorem is supposed to be simple enough to leave out.
21:39:35 <ChongLi> augur_: I was always under the impression that less was specific to mass nouns and fewer was specific to counts
21:39:39 <augur_> its no fair using some crazy complex theorem to prove fmap f x = pure f <*> x
21:39:45 <jtcwang> or I could use state monad (which've been adviced against)
21:39:56 <augur_> ChongLi: not in any version of english that is widely spoken
21:39:58 <shachaf> ion: Usually false, but maybe not for infinity (depending on how + is defined)
21:40:07 <Tekmo> jtcwang: That type looks fine.  What problems do you have with it?
21:40:17 <dhrosa> jtcwang: why were you advised against it? also your Auto looks identical to the state monad...
21:40:33 <dhrosa> or very close
21:40:38 <Tekmo> jtcwang: Note that your type is a valid instance of `Category`
21:40:38 <jtcwang> from what i've read, state monad allows you to extract the current state
21:40:41 <ChongLi> augur_: well, any language argument eventually seems to wind up with an appeal to popularity
21:40:42 <jtcwang> without needing to 'step' it
21:40:46 <ChongLi> since usage defines meaning
21:40:57 <jtcwang> Tekmo, can you eleborate a bit on Category?
21:41:14 <Tekmo> jtcwang: Think of a `Category` as generalizing the notion of function
21:41:15 <augur_> ChongLi: its not so much appeal to popularity so much as rejecting the whole argument from the word go as being nonsensical.
21:41:28 <Tekmo> jtcwang: Everything that is a `Category` implements two things: `(.)` and `id`
21:41:35 <erisco> being able to prove these properties is only important so that I can prove the instances of my own type...
21:41:37 <Tekmo> jtcwang: It's easier to see if you study the class definition
21:41:43 <Tekmo> @src Category
21:41:43 <lambdabot> Source not found. My mind is going. I can feel it.
21:41:47 <erisco> without a proof that I satisfy the laws, how do I justify my instance?
21:41:51 <dhrosa> jtcwang: maybe you want to use the get function?
21:42:11 <jtcwang> dhrosa, how would i implement that? doing a dry run?
21:42:28 <roboguy_> I think I see how a proof for "fmap f x = pure f <*> x" could be constructed after shachaf's hint that it depends on the uniqueness of Functor instances
21:42:30 <Tekmo> jtcwang: Here's where the class is defined: file:///usr/share/doc/ghc-doc/html/libraries/base-4.5.0.0/Control-Category.html#t:Category
21:42:47 <Tekmo> jtcwang: Note that Haskell functions are one instance of the `Category` type class, but not the only one
21:43:10 <Tekmo> jtcwang: This is why there is: `instance Category (->)` indicating that functions are one kind of category
21:43:38 <augur_> roboguy_: it cant possible depend on uniqueness of functor instances
21:43:50 <roboguy_> augur_: why not?
21:43:50 <augur_> that would be an insane fact
21:43:52 <Tekmo> jtcwang: So if you were trying to define a `Category` for your `Auto` type, it would look something like this
21:44:20 <augur_> at best it could only depend on you using the same functor in both places
21:44:28 <roboguy_> augur_: if it depends on the uniqueness of Functor instances, all you have to do is prove that "pure f <*> x" obeys the Functor laws
21:44:49 <roboguy_> if Functor instances are unique, that's all you'd need to do
21:44:53 <augur_> no thats absurd, there's no way that's the right answer
21:45:10 <roboguy_> shachaf: What do you say? Am I on the right track?
21:45:13 <Tekmo> jtcwang: instance Category Auto where id = Auto (\a -> (a, id)); (Auto f) . (Auto g) = Auto (\a -> let (b, a1) = f a; (c, a2) = g b in (c, a1 . a2)
21:45:22 <augur_> im not saying you CANT prove it that way, roboguy_
21:45:25 <erisco> well if shachaf actually has the answer he could dispell the mystery for us
21:45:33 <augur_> but it was be nuts if it is
21:45:34 <shachaf> roboguy_: Well, for the easy part of the proof, sure.
21:45:42 <augur_> thats just an absolutely bonkers way to prove this fact
21:46:01 <augur_> i bet copumpkin or Cale or Saizan could put us out of our misery
21:46:04 <augur_> or byorgey!
21:46:15 <augur_> i wonder if byorgey included the proof in the typeclassopedia
21:46:15 <roboguy_> shachaf: that's what I mean. I'm not sure how you prove the Functor uniqueness thing. I know it's true, but I'd have to think about it some
21:46:17 <jtcwang> Tekmo, that's interesting. how does it help me to achive my goal of "extract current state" without doing a dry run?
21:46:17 <shachaf> There's also a thing that says that if F is a functor, and foo :: (a -> b) -> F a -> F b, and foo id = id, then foo (f . g) = foo f . foo g
21:46:23 <byorgey> augur_: which proof?
21:46:29 <augur_> byorgey: fmap f x = pure f <*> x
21:46:31 <Tekmo> jtcwang: What do you mean by dry run?
21:46:31 <roboguy_> augur_: see, there you go haha
21:46:43 <shachaf> So now your life is really easy.
21:47:15 <jtcwang> Tekmo, so currently my function takes an Auto x x. I do some IO stuff (ask for user input, print outputs)
21:47:18 <roboguy_> augur_: I don't really see why it's so crazy...
21:47:27 <augur_> ahha i see how shachaf is doing this
21:47:41 <jtcwang> at first, to print the current state, I need to extract it from the input Auto x x
21:47:47 <byorgey> augur_: no, I don't think that's in the Typeclassopedia.
21:47:57 <augur_> he's using parametricity to argue that the implementation of any such foo _must_ be equivalent to an fmap
21:48:11 <Tekmo> jtcwang: So what is an `Auto` supposed to model exactly?
21:48:17 <roboguy_> augur_: that's what I was saying...
21:48:25 <Tekmo> jtcwang: I know you said "state machine" but that's not obvious from the type
21:48:33 <jtcwang> Tekmo, an automaton. Its a generic type
21:48:39 <erisco> oh
21:48:41 <augur_> thats a little less nuts than i was expecting
21:48:47 <augur_> byorgey: ok, well, how would you prove it! :p
21:49:01 <jtcwang> mm_freak suggested me to use it, and I've played around with it
21:49:02 <Tekmo> jtcwang: So what would the type of your automaton's internal state be?
21:49:03 * shachaf checks the logs
21:49:05 * hackagebot Dish 0.0.0.5 - Hash modules (currently Murmur3)  http://hackage.haskell.org/package/Dish-0.0.0.5 (zcourts)
21:49:14 <BMeph_> Can't you just rewrite 'pure f <*> x' as '(<*>) (pure f) x'?
21:49:29 <jtcwang> ok in my specific case: Auto Double BetRecord
21:49:32 <augur_> BMeph_: yeah but how does that help us
21:49:45 <byorgey> augur_: good question.  I assume you mean we want to prove something like "fmap f x = pure f <*> x must hold for any law-abiding Functor + Applicative instances"?
21:49:47 <Tekmo> jtcwang: That's the type of the automaton, but which part corresponds to the state you want to extract?
21:50:01 <BMeph_> Re-write it again to: '((<*>) . pure) f x'
21:50:05 <jtcwang> so basically the state machine takes in a double (bet amount), and gives you the next state machine
21:50:06 <augur_> if you had a parametricity lemma, then you can apply it to  (<*>) . pure  and you're right
21:50:07 <augur_> byorgey: yeah
21:50:11 <shachaf> augur_: Saying "your way of proving is bonkers, now someone else please come prove it instead" is kind of silly.
21:50:18 <jtcwang> I want to extract BetRecord
21:50:27 <BMeph_> Then, compare fmap to (<*>) . pure
21:50:40 <erisco> is there something a wee bit more formal than roughly "where else would the 'b' value come from?"
21:50:52 <Tekmo> jtcwang: So the simplest solution is to make it `Auto (Maybe Double) BetRecord`
21:50:54 <augur_> shachaf: i was rejecting a proof that sounded rather complex, on the assumption that Conor McBride knows what he's talking about when he says the proof is simple
21:50:54 <ChongLi> :t (<*>) . pure
21:50:55 <lambdabot> Applicative f => (a -> b) -> f a -> f b
21:50:57 <johnw> erisco: parametricity?
21:51:01 <byorgey> you just need to prove that  ((<*>) . pure) id = id
21:51:09 <Tekmo> jtcwang: You feed it a `Just` when you want to supply a new value and a `Nothing` to just get a readout
21:51:23 <augur_> byorgey: yeah this looks like it relies on a parametericity lemma.
21:51:28 <shachaf> byorgey: Assuming that (a) Functor instances are unique and (b) proving the id law is enough
21:51:37 <Tekmo> jtcwang: I'm not entirely sure that's the best solution, but it's the first one that came to my mind
21:51:38 <augur_> shachaf: no you dont need uniqueness
21:51:39 <byorgey> shachaf: they are, and it is
21:51:41 <jtcwang> Tekmo, yes and that's what i call a dry run
21:51:49 <shachaf> byorgey: Right. Which were the two tricky-ish assumptions I said make this easy.
21:51:52 <jtcwang> currently i give it input of 0
21:51:54 <Tekmo> jtcwang: So, the other solution is to define
21:52:03 <augur_> shachaf: you just parameterize everything by your functor instance, which is whats being said under the hood
21:52:03 <erisco> johnw, hm, where do I read about that?
21:52:12 <byorgey> shachaf: ok, well, THOSE tricky-ish assumptions actually *are* in the Typeclassopedia =)
21:52:13 <Tekmo> jtcwang: data Auto a b = Auto { supply :: a -> (b, Auto a b) :: readOut :: (b, Auto a b) }
21:52:24 <Tekmo> jtcwang: However, that type is "isomorphic" to the `Maybe` version I gave you
21:52:28 <ChongLi> what else could a function do with such a type?
21:52:30 <byorgey> at least, there is a link to a proof in an email from roconnor
21:52:31 <johnw> erisco: http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
21:52:31 <Tekmo> jtcwang: Meaning that they are completely interchangeable
21:52:36 <shachaf> Well, it's very easy with those assumptions.
21:52:48 <shachaf> pure id <*> x = x is an Applicative law
21:52:50 <augur_> shachaf: and with parametricity.
21:52:52 <Tekmo> Oops, there was a syntax errror
21:52:59 <johnw> erisco: also see http://stackoverflow.com/questions/12421085/good-introduction-to-free-theorems
21:53:02 <byorgey> there you go then.
21:53:04 <augur_> shachaf: you _need_ a parametricity lemma to make that argument work
21:53:04 <Tekmo> jtcwang: data Auto a b = Auto { supply :: a -> (b, Auto a b), readOut :: (b, Auto a b) }
21:53:11 <jtcwang> Tekmo, I guess so. I'm just hoping that maybe there's something awesome i've missed by implementing it naively
21:53:12 <erisco> johnw, thanks
21:53:12 <shachaf> But you're being called here because assuming these things is bonkers, so I'm told.
21:53:18 <erisco> I do not think this is going to help me on my other problem
21:53:21 <Tekmo> jtcwang: What do you mean natively?
21:53:24 <erisco> but, good to have more tools
21:53:25 <Tekmo> *naively
21:53:30 <jtcwang> naively*
21:53:42 <jtcwang> as in doing a dry run
21:53:48 <Tekmo> jtcwang: They are totally equivalent
21:53:53 <byorgey> I assume lots of bonkers things.  I try to only assume the true ones though.
21:53:56 <jtcwang> i was thinking maybe there's a super smart way to do it :P
21:54:05 <jtcwang> like the recursive typing of auto blew my mind
21:54:19 <Tekmo> jtcwang: More generally, anything of type `(a -> b, b)` is equivalent to `Maybe a -> b`
21:54:30 <shachaf> augur_: I know. What is your point?
21:54:35 <Tekmo> jtcwang: If you want to reassure yourself that this equivalence is "elegant", just think of them as algebraic expressions
21:54:42 <jfischoff> http://imgur.com/qwagWsT
21:54:43 <Tekmo> jtcwang: Do the following conversions
21:54:51 <Tekmo> jtcwang: (a, b) ~ a * b
21:55:00 <augur_> shachaf: _that_ was the point
21:55:01 <Tekmo> jtcwang: a -> b ~ b^a
21:55:04 <roboguy_> how about something like this for a proof? http://lpaste.net/98809
21:55:06 <Tekmo> jtcwang: Either a b ~ a + b
21:55:12 <shachaf> Wait, I don't know which argument you're talking about anymore.
21:55:14 <shachaf> I don't care.
21:55:16 <Tekmo> jtcwang: () ~ 1
21:55:18 <Tekmo> jtcwang: Void ~ 0
21:55:28 <jtcwang> what's this ~ you're talking about?
21:55:28 <Tekmo> jtcwang: Then if you think of `Maybe a` as `Either () a`...
21:55:35 <Tekmo> jtcwang: Maybe a ~ 1 + a
21:55:36 <augur_> shachaf: all the heavy work is done by parametricity, the uniqueness stuff is just to say you're subscripting the fmaps etc with the same F
21:55:39 <Tekmo> jtcwang: So you get
21:56:09 <Tekmo> jtcwang: (a -> b, b) ~ (b^a) * b = b^(a + 1) ~ Maybe a -> b
21:56:40 <augur_> which really isnt terribly important to the theorem, you ought to be able to prove the same thing in a language like ML or Agda where you try to avoid too much (or any) fancy inference stuff
21:56:44 <roboguy_> augur_: I don't really see where parametricity comes into play (except for the Functor laws derived from it)
21:56:47 <prophile> Tekmo: what do foralls map to in that relation?
21:56:53 <Tekmo> prophile: I have no clue
21:57:04 <Tekmo> prophile: I asked this exact same question on Stack Overflow a while ago
21:57:22 <Tekmo> prophile: I wasn't very satisfied with the answers
21:57:29 <prophile> :<
21:57:31 <augur_> roboguy_: well, i guess maybe also you could use extensionality
21:57:37 <jtcwang> thanks Tekmo
21:57:41 <prophile> it'd be interesting, because I think you can build everything else out of -> and forall?
21:57:41 <Tekmo> prophile: http://stackoverflow.com/questions/10453558/algebraically-interpreting-polymorphism
21:57:44 <Tekmo> jtcwang: You're welcome!
21:57:52 <augur_> roboguy_: if you could prove that fmap and (<*>).pure are extensionally equal, you're justified in replacing one for the other
21:57:54 <augur_> thats true
21:58:11 * prophile reads
21:58:13 <augur_> so it depends on what = here is supposed to mean i guess
21:58:23 <roboguy_> augur_: if there is only one Functor instance for a given type, then by definition, a function must be fmap if it satisfies the fmap laws
21:58:25 <jtcwang> Tekmo, (though I'm completely lost at the last part of our conversation) :P But dw I'll sleep on it
21:58:34 <roboguy_> well, not by definition. but it's still true
21:58:35 <erisco> augur_, what does existentially equal mean?
21:58:43 <augur_> roboguy_: false
21:58:47 <roboguy_> erisco: function equality, essentially
21:58:50 <byorgey> roboguy_: the way you prove that there is only one Functor instance for a given type is by parametricity.
21:58:50 <roboguy_> augur_: how so?
21:58:52 <Tekmo> jtcwang: Let me get you a good link
21:58:57 <Tekmo> jtcwang: Then you can read it tomorrow
21:58:59 <augur_> roboguy_: it means you cant declare a second Functor instance
21:59:09 <augur_> it DOESNT mean there cant be functions that have that behavior around
21:59:10 <roboguy_> augur_: but that's what I'm *assuming*
21:59:14 <Tekmo> prophile: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
21:59:15 <augur_> roboguy_: but its false
21:59:24 <Tekmo> Oops
21:59:28 <byorgey> erisco: extensionally equal, not existentially
21:59:28 <Tekmo> That was meant for jtcwang
21:59:30 <Tekmo> jtcwang: http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
21:59:32 <augur_> roboguy_: you can assume false things if you like, but they're still false, and your reasoning is flawed as a consequence
21:59:59 <erisco> byorgey, same diff right? :)
22:00:05 <johnw> augur_: uniquness also means that an instance of (pure f <*>) must relate to an instance of (fmap f), and not that two different Functor instances can rely on the same <*>
22:00:10 <byorgey> erisco: nope =)
22:00:22 <roboguy_> augur_: but given the polymorphism in effect, which I suppose is where the parametricity comes in, then it must be true
22:00:30 <augur_> johnw: yes, ive said that repeatedly
22:00:42 <johnw> augur_: ok, sorry for the over-clarification :)
22:00:55 <roboguy_> augur_: since we have (\f x -> pure f <*> x) :: Applicative f => (a -> b) -> f a -> f b
22:01:18 <augur_> roboguy_: yes, given the polymorphism, you can use parametricity to do some twiddling or something to argue that (<*>).pure must be definitionally equal to some use of fmap
22:01:26 <augur_> roboguy_: the extensionality argument is probably the best one tho
22:01:32 <roboguy_> augur_: right, I see
22:01:42 <shachaf> Maybe you can interpret forall as a product of some sort.
22:01:55 <augur_> forall is an infinite product!
22:01:59 <augur_> or potentially infinite
22:03:09 <roboguy_> augur_: but you agree that if it can be shown that Functor instances are unique and that (<*>).pure obeys the Functor laws, (<*>).pure must be fmap?
22:03:15 <augur_> johnw: the uniqueness just forces   fmap f x = pure f <*> x   to mean   fmap_F f x = pure_F f <*>_F x  thats all it really does
22:03:18 <augur_> which i sort of tangential
22:03:24 <augur_> roboguy_: false.
22:03:35 <roboguy_> augur_: why?
22:03:42 <augur_> roboguy_: Functor instances are unique for a practical reason, NOT for a mathematical reason
22:04:12 <johnw> augur_: ok
22:04:19 <augur_> roboguy_: all type class instances must be unique, otherwise your type class solving becomes potentially undecidable
22:04:20 <roboguy_> augur_: well, it's debatable that it's not for a mathematical reason. I do know that there are more functors for types than haskell allows
22:04:29 <augur_> roboguy_: no, its definitely not for a mathematical reason
22:04:36 <roboguy_> augur_: wait, that's not what I mean by Functor having unique instances
22:04:42 <augur_> roboguy_: its what shachaf means
22:04:49 <enthropy> augur_: can you construct a type in haskell that has different law-abiding Functor instances?
22:05:00 <roboguy_> augur_: I mean that for any given type, there is at most one valid Haskell Functor instance for it
22:05:08 <augur_> roboguy_: that is definitely false
22:05:13 <roboguy_> augur_: give me an example
22:05:13 <enthropy> giving a counterexample is a nice way to prove people wrong
22:05:27 <roboguy_> because it is definitely not false...
22:06:18 <augur_> well, for functors that might actually be true, hmm
22:06:26 <prophile> that's the idea
22:06:31 <augur_> i would be very suspicious if it were actually
22:06:34 <roboguy_> augur_: it is. that's why it works
22:07:09 <shachaf> sigh
22:07:13 <roboguy_> augur_: http://www.haskell.org/haskellwiki/Typeclassopedia#Laws
22:07:24 <shachaf> That is the whole point.
22:07:26 <roboguy_> augur_: "Unlike some other type classes we will encounter, a given type has at most one valid instance of Functor. This can be proven via the free theorem for the type of fmap. In fact, GHC can automatically derive Functor instances for many data types."
22:07:39 <roboguy_> this is why DeriveFunctor works
22:07:39 <augur_> because that would also mean that for a given endomap on sets, there is at most one action on arrows that it could have
22:07:53 <roboguy_> we are talking about Haskell Functors
22:08:05 <augur_> yes but Haskell Functors arent magically disconnected from CT functors
22:08:09 <roboguy_> in particular, Functors that can be instances of the Haskell Functor type class
22:10:53 <augur_> aha, roconnor's email that byorgey linked has convinced me
22:11:08 <erisco> of what?
22:11:23 <prophile> that wadler is our lord and saviour
22:11:37 <augur_> the mathematical uniqueness of haskell functor instances
22:12:19 <roboguy_> see, not so crazy haha
22:12:45 <augur_> roboguy_: i thought he meant accidental uniqueness due to haskell's uniqueness requirements
22:12:50 <mada> ok, apparently several libraries are either incomplete or deprecated in favor of gitlib
22:12:53 <mada> so gitlib it is
22:13:10 <augur_> roboguy_: not, as it were, a more fundamental notion of uniqueness!
22:13:36 <augur_> the fundamental uniqueness isn't bonkers at all, just a think that really needs elaborating on
22:13:51 <roboguy_> yeah, I didn't believe it the first time I heard it
22:14:07 <roboguy_> until I gave it some more thought
22:14:20 <augur_> i think youll agree that if he _had_ meant mere enforced uniqueness that haskell gives, it would indeed be a bonkers way of proving it
22:14:41 <roboguy_> probably. I'm not sure I fully know what you mean though
22:14:46 <augur_> hopefully you're still listening, shachaf
22:15:08 <augur_> roboguy_: well, haskell enforces unique instances. you couldnt define a second Functor [] instance even if you wanted, without turning on a flag.
22:15:23 <roboguy_> augur_: ahhh. yeah that wouldn't make much sense
22:15:46 <augur_> roboguy_: thats why i thought it was just a completely loopy idea to rely on that fact
22:16:01 <roboguy_> yeah, I can understand that
22:26:29 <ChongLi> could you define a Functor [] instance that reverses the list?
22:26:36 <ChongLi> I guess that'd violate the laws
22:26:41 <shachaf> If you didn't care about the laws.
22:26:52 <shachaf> There are more interesting situations, like instance Functor DList
22:26:55 <Tekmo> It would violdate fmap id = id
22:26:59 <Tekmo> *violate
22:27:14 <Axman6> but GHC doesn't know that
22:27:41 <augur_> shachaf: what is DList here?
22:28:07 <zRecursive> glad to use Scheme created by Haskell https://github.com/justinethier/husk-scheme, how can i sort a list ? (sort < '(1 3 2)) doesnot work ?!
22:28:11 <Tekmo> augur_: An alternative implementation of lists as "difference lists"
22:28:19 <Tekmo> augur_: DList a ~ ([a] -> [a])
22:28:25 <augur_> ahh ok
22:28:56 <augur_> what are these difference lists again? are these where you implement a list by its concatenation action?
22:29:18 <augur_> inj :: [a] -> DList a   ;   inj xs = DList (xs ++)   ?
22:29:38 <johnw> a dlist is effectively the monoid Endo (x <>)
22:29:54 <shachaf> fsvo "effectively"
22:29:55 <johnw> the dlist library lets you interact with them similarly to normal lists
22:29:56 <Tekmo> augur_: return a = DList (a:), for example
22:30:07 <shachaf> For example: The Functor instance.
22:30:17 <Tekmo> augur_: DList f ++ DList g = DList (f . g)
22:30:24 <Axman6> hmm, I thought there were issues with Monad DList
22:30:29 <augur_> Tekmo: ok, so more or less what i said :P
22:30:33 <Tekmo> Axman6: Probably
22:30:38 <Tekmo> Axman6: I've never tried to implement it
22:30:48 <Axman6> Tekmo: but you're Tekmo!
22:30:53 <Axman6> D:
22:31:01 <c_wraith> it's a wrapper around [a] -> [a]
22:31:01 <shachaf> Start with Functor DList
22:31:02 <Tekmo> Axman6: :)
22:31:05 <c_wraith> That makes it invariant
22:31:09 <Tekmo> Axman6: I rarely use it
22:31:30 <shachaf> instance Functor DList where fmap f d = fromList . map f . toList
22:31:36 <augur_> c_wraith: "that makes it invariant"?
22:31:47 <Tekmo> Oh yeah, shachaf has a point
22:32:06 <Tekmo> Since there is an isomorphism to ordinary lists you should be able to implement all equivalent operations (although the naive translation may be grossly inefficient)
22:32:10 <Tekmo> So for example:
22:32:15 <shachaf> fsvo "isomorphism"
22:32:27 <ChongLi> isomorphism up to isomorphism :)
22:32:27 <Tekmo> m >>= f = fromList (toList m >>= \r -> toList (f r))
22:32:41 <augur_> shachaf: definitely would want to use extensionality for that
22:32:51 <shachaf> The type [a] -> [a] isn't isomorphic, but DList's API won't let you make any DList which isn't (xs ++) for some list xs
22:33:10 <johnw> actually, in the dlist library, fmap = map
22:33:12 <shachaf> So you can make a Functor instances, and it obeys the Functor laws only if your list is of the form (xs ++)
22:33:12 <Tekmo> It's not isomorphic?
22:33:21 <shachaf> Not isomorphic to [a]
22:33:37 <ChongLi> fromList . toList /= id ?
22:33:50 <c_wraith> ah, I see.  the fact that it's invariant doesn't matter because of the semantic restrictions forcing it to be equivalent to [a]
22:33:51 <shachaf> fromList (toList reverse) /= reverse
22:33:56 <shachaf> c_wraith: Right.
22:34:15 <Tekmo> Oh, I see
22:34:50 <shachaf> Er, for a different value of fromList/toList from what I used before.
22:35:09 <Tekmo> Does `toList . fromList = id` hold?
22:35:17 <shachaf> Sure.
22:35:24 <Tekmo> Because then wouldn't the monad laws still hold?
22:35:31 <shachaf> fromList will only give you functions of the form (xs ++)
22:35:36 <Tekmo> Assuming return a = fromList [a]
22:35:39 <shachaf> And toList assumes that you give it a function of the form (xs ++)
22:35:54 <shachaf> Yes, you can make DList a Monad instance.
22:36:06 <MisterGeppetto> I'd like to try some GUI programming in haskell (just for fun), any suggestions on what library to use?
22:36:06 <shachaf> (If you only use the DList API, and don't use the constructor directly.)
22:36:20 <frege> guys
22:36:25 <shachaf> johnw: Look more closely.
22:36:37 <frege> I wanna write a function that finds the highs and lows in a list
22:36:38 <c_wraith> MisterGeppetto: threepenny-gui might be the easiest to build
22:36:40 <frege> would you help me?
22:36:52 <shachaf> frege: This channel isn't exclusively guys. :-)
22:37:01 <frege> :) sorry
22:37:04 <Tekmo> shachaf: Does `toList . fromList = id` only hold if you use the DList API?
22:37:04 <ChongLi> > (minimum &&& maximum) [1..20]
22:37:06 <lambdabot>  (1,20)
22:37:12 <shachaf> Tekmo: It always holds.
22:37:15 <frege> scshunt: doesn't 'guys' cover all genders?
22:37:19 <Tekmo> shachaf: Then wouldn't the monad laws always hold?
22:37:19 <dhrosa> guys is often used for both genders
22:37:24 <Clint> all seven genders
22:37:39 <ChongLi> species 8472!
22:37:43 <frege> ChongLi: was that for me?
22:37:47 <ChongLi> frege: yeah
22:38:07 <EmilyScott> frege: just jumped in, but yes, guys is commonly used as a gender neutral word nowadays.
22:38:17 <frege> > (minimum &&& maximum) [-3,-2,-1,0,1,2,3,4,3,2,1,0,2,0,-1,-3,5,3,0]
22:38:18 <lambdabot>  (-3,5)
22:38:23 <shachaf> Tekmo: But fmap id = id only holds if you only use the DList API.
22:38:23 <dhrosa> much like the singular "they"
22:38:27 <Tekmo> shachaf: Never mind
22:38:32 <frege> ChongLi: naah; all highs and lows
22:38:32 <Tekmo> shachaf: I caught the mistake in my reasoning
22:38:36 <shachaf> Anyway, you lose all the benefits of DList by doing things like fmap.
22:38:38 <Tekmo> shachaf: Yeah, you're right
22:38:41 <EmilyScott> dhrosa: I like singular they. :)
22:38:42 <ChongLi> frege: ohh
22:38:45 <frege> ChongLi: it shoud return [4, 0, 2, -3, 5]
22:39:00 <frege> but what does &&& do?
22:39:04 <frege> @srs &&&
22:39:05 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
22:39:10 * hackagebot vector-space-points 0.1.3 - A type for points, as distinct from vectors.  http://hackage.haskell.org/package/vector-space-points-0.1.3 (BrentYorgey)
22:39:15 * Clint stares at @srs
22:39:18 <ChongLi> yeah that may not help :)
22:39:18 <erisco> frege, welcome to Arrows
22:39:20 <Tekmo> shachaf: They only hold if you only build `DList`s using `fromList` or something equivalent, like you said
22:39:47 <frege> erisco: I'm way behind arrows
22:39:52 <frege> not there yet
22:39:59 <erisco> yeah there is no problem using a simpler version
22:39:59 <shachaf> But you can use another representation that gives you DListy behavior and also lets you map and so on.
22:40:07 <Tekmo> shachaf: What is it?
22:40:42 <shachaf> newtype List a = List { runList :: forall r. (a -> r -> r) -> r -> r }
22:40:53 <frege> ChongLi: I know the algorithm; I need three elements and then I have to return the element if it's the middle element is higher than neighbours or lower
22:40:58 <shachaf> I.e. the Boehm-Berarducci (or Church or whatever) encoding.
22:41:16 <ChongLi> frege: yeah, local minima and maxima
22:41:26 <frege> ChongLi: yeah it's called that
22:41:26 <shachaf> DList is "a list where you've abstracted over [], taking it as a parameter instead"
22:41:31 <ChongLi> I remember someone asking about this a while back
22:41:32 <shachaf> Here, you abstract over both (:) and []
22:41:41 <erisco> frege, so where did you get stuck on the implementation?
22:41:41 <frege> ChongLi: how do I write a recursive function to do that?
22:41:41 <shachaf> So it's like DList only more so.
22:42:13 <frege> erisco: I don't know how to do it in haskell, I wrote the function in python
22:42:37 <erisco> well you need to at least attempt writing it in Haskell
22:42:38 <ChongLi> frege: the first thing that comes to mind is to split the list into groupings by "direction"
22:42:41 <frege> I think I need three functions
22:42:48 <mzero> frege: I just remember 'em with mnemonics: f &&& g means "do f AND g to the value - return both"
22:43:07 <shachaf> Codensity also uses the DList trick, more or less.
22:43:08 <frege> mzero: so it's like map?
22:43:33 <shachaf> In fact, Codensity (Writer [w]) behaves like Writer (DList w)
22:43:45 <mzero> no - you're over thinking - if f and g are functions, then f &&& g returns the pair of (f x, g x)
22:43:46 <erisco> frege, it is not like map
22:43:46 <ChongLi> (f &&& g) x = (f x, g x)
22:44:19 <shachaf> And f and g are always functions, by the way.
22:44:25 <shachaf> No one ever uses any other Arrow instance.
22:44:41 <ChongLi> I don't know what other arrow instances one might want to use
22:44:42 <mzero> I was going to say something along those lines, but I figured folks would stone me
22:45:38 <erisco> frege, just consider the case analysis
22:46:07 <erisco> frege, empty list, one-element, two-elements, three-elements plus zero or more
22:46:25 <frege> gotcha
22:46:59 <frege> how does indexing a list works in haskell?
22:47:11 <erisco> you do not need to index so don't worry
22:47:22 <frege> ?
22:47:25 <frege> I need
22:47:50 <frege> how do I get pre/next element in the list then?
22:48:08 <erisco> you can deconstruct a list by pattern matching
22:48:12 <shachaf> I would examine your need, because it might turn out that you actually don't.
22:48:22 <erisco> > let (x:xs) = [1,2,3] in (x, xs)
22:48:23 <lambdabot>  (1,[2,3])
22:48:29 <shachaf> But (!!) :: [a] -> Int -> a exists if you really want it.
22:48:36 <shachaf> (It crashes if the index you give it is out of bounds.)
22:48:41 <erisco> > let (x:y:xs) in (x, y, xs)
22:48:42 <lambdabot>  <hint>:1:14: parse error on input `in'
22:48:48 <erisco> > let (x:y:xs) = [1,2,3] in (x, y, xs)
22:48:50 <lambdabot>  (1,2,[3])
22:48:50 <shachaf> Lists are really not made for indexing, though. More than once, anyway.
22:49:06 <erisco> > let (x:y:z:xs) = [1,2,3] in (x, y, z, xs)
22:49:07 <lambdabot>  (1,2,3,[])
22:49:12 <erisco> frege, make some sense?
22:49:22 <ChongLi> > zipWith compare [1..20] [2..20]
22:49:23 <lambdabot>  [LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT,LT]
22:49:30 <frege> how do I get lows and highs in this list? [-3,-2,-1,0,1,2,3,4,3,2,1,0,2,0,-1,-3,5,3,0]
22:49:33 <shachaf> let (x:xs) = l is almost as bad as using (!!) :-(
22:49:48 <shachaf> The point of pattern-matching is that you have to consider every case.
22:49:55 <ChongLi> > let lst = [-3,-2,-1,0,1,2,3,4,3,2,1,0,2,0,-1,-3,5,3,0] in zipWith compare lst (tail lst)
22:49:56 <lambdabot>  [LT,LT,LT,LT,LT,LT,LT,GT,GT,GT,GT,LT,GT,GT,GT,LT,GT,GT]
22:49:56 <erisco> shachaf, yeah we'll get there
22:50:06 <erisco> frege, do you understand the pattern matching examples I showed?
22:50:17 <dhrosa> frege: what do you mean the lows and highs, like the local extrema?
22:50:23 <frege> not xs part
22:50:27 <dhrosa> or just the global min and max?
22:50:28 <frege> dhrosa: yeah
22:50:33 <frege> dhrosa: local
22:50:34 <ChongLi> local extrema
22:50:45 <erisco> frege, [1,2,3] == 1:2:3:[]   do you understand this?
22:50:50 <ChongLi> > let lst = [-3,-2,-1,0,1,2,3,4,3,2,1,0,2,0,-1,-3,5,3,0] in zipWith compare (tail lst) lst
22:50:51 <lambdabot>  [GT,GT,GT,GT,GT,GT,GT,LT,LT,LT,LT,GT,LT,LT,LT,GT,LT,LT]
22:50:53 <frege> yup
22:51:22 <ChongLi> wherever GT changes to LT or vice-versa, you'll find one
22:51:50 <erisco> :t (:)
22:51:51 <lambdabot> a -> [a] -> [a]
22:51:57 <Tekmo> ChongLi: Or you could just apply it a second time :)
22:51:58 <erisco> frege, does that type signature make sense?
22:52:17 <ChongLi> Tekmo: I don't follow
22:52:33 <frege> erisco: yeah; : is a list constructor
22:52:37 <Tekmo> ChongLi: Take that list of `LT`s and `GT`s and apply the same transformation
22:52:44 <frege> > 1:
22:52:45 <lambdabot>  <hint>:1:3:
22:52:45 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:52:46 <Tekmo> ChongLi: zipWith compare it and its tail
22:52:49 <frege> 1:
22:52:52 <frege> > 1:
22:52:53 <lambdabot>  <hint>:1:3:
22:52:53 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
22:52:58 <frege> > 1:[]
22:52:59 <lambdabot>  [1]
22:52:59 <shachaf> frege: You can /msg lambdabot.
22:52:59 <mzero> wait, isn't frege just asking for  minimum and maximum of the whole list?
22:53:10 <frege> mzero: no; local
22:53:12 <dhrosa> mzero: no he's asking for local extrema
22:53:17 <erisco> frege, data [a] = (:) a [a] | []   does this pseudo-code make sense as a definition for lists?
22:53:17 <ChongLi> > let lst = [-3,-2,-1,0,1,2,3,4,3,2,1,0,2,0,-1,-3,5,3,0]; foo = zipWith compare (tail lst) lst in zipWith compare foo (tail foo)
22:53:18 <lambdabot>  [EQ,EQ,EQ,EQ,EQ,EQ,GT,EQ,EQ,EQ,LT,GT,EQ,EQ,LT,GT,EQ]
22:54:16 <frege> erisco: no it doesn't
22:54:29 <frege> (:) a [a] | [] ?
22:54:37 <frege> I gotta go to bed
22:54:39 <Tekmo> ChongLi: Every place you have a `GT` or `LT` is a local minimum or maximum
22:54:41 <frege> thanks friends
22:54:44 <erisco> frege, okay good night
22:54:45 <ChongLi> > let lst = [-3,-2,-1,0,1,2,3,4,3,2,1,0,2,0,-1,-3,5,3,0]; foo = zipWith compare (tail lst) lst in zipWith compare (tail foo) foo
22:54:46 <lambdabot>  [EQ,EQ,EQ,EQ,EQ,EQ,LT,EQ,EQ,EQ,GT,LT,EQ,EQ,GT,LT,EQ]
22:54:50 <frege> good night erisco
22:54:52 <frege> and others
22:54:56 <frege> thanks for the help
22:54:57 <ChongLi> Tekmo: nice :)
22:55:04 <Tekmo> ChongLi: Basically `zipWith compare ...` is like taking the derivative
22:55:09 <ChongLi> yeah
22:55:13 <jle`> friendly reminder here
22:55:19 <jle`> that it is safer to use drop 1
22:55:21 <jle`> than tail
22:55:27 <jle`> for uses like this
22:55:32 <ChongLi> jle`: thank you
22:55:52 <jle`> yup...for some reason this diff list question gets asked about twice a day
22:55:59 <jle`> or questions involving diff lists
22:56:01 <jle`> how odd
22:56:05 <erisco> frege, next time we'll reimplement lists so you can see
22:59:32 <Tekmo> One of the issues is that the discussion forum shapes the discussion
22:59:47 <Tekmo> The things that discussed here are those that lambdabot can support
23:01:12 <Tekmo> This is why discussion tends to gravitate towards simpler things like diff lists
23:01:46 <erisco> ChongLi, hmm... I do not understand your approach
23:02:20 <shachaf> lambdabot wasn't used once in that discussion.
23:02:43 <Tekmo> shachaf: Well, there is also the length limitation, too
23:02:59 <Tekmo> shachaf: It's whatever explanation you can fit in a few lines of IRC before shachaf asks you to take it to #haskell-overflow
23:04:01 <shachaf> "take it to #haskell-overflow" isn't the same as "stop talking about it"
23:04:39 <ChongLi> I'm back
23:04:45 <erisco> ChongLi, ah nevermind I misread
23:05:18 <Tekmo> shachaf: I'm not saying they are the same.  I'm just explaining why #haskell has simpler discussions (as opposed to #haskell-overflow)
23:05:49 <shachaf> I also take conversations to #haskell-overflow, or to Etherpad, or whatever.
23:05:51 <rien> can anyone here edit the haskell wiki?
23:06:41 <ChongLi> there ought to be a browser-based Etherpad with built in Haskell evaluation
23:06:49 <ChongLi> a mix of Etherpad and tryhaskell
23:07:01 <shachaf> A mix of Etherpad and IRC would be more valuable.
23:07:19 <ChongLi> a mix of everything and everything!
23:07:21 <shachaf> I really prefer real-time communication. IRC isn't great but it's OK.
23:07:30 <Clint> why has no one written a haskell irc server yet
23:07:56 <ChongLi> irc seems like a pretty hellish protocol to work with
23:08:05 <ChongLi> but that's just from my limited understanding :)
23:08:48 <Tekmo> Clint: Is there an official IRC specification?
23:09:13 <ChongLi> Tekmo: thinking of writing one? :)
23:09:25 <ChongLi> as a nice example of the power of pipes?
23:09:41 <Clint> Tekmo: rfc 2812?
23:09:43 <EmilyScott> RFC 2812 tekmo
23:09:48 <Tekmo> ChongLi: Maybe ...
23:10:02 <Tekmo> Clint EmilyScott: Thanks
23:10:05 <shachaf> Why would you write an IRC server in Haskell?
23:10:13 <Tekmo> ChongLi: It would have to wait until after I add lens-based parsing to pipes-parse
23:10:16 <EmilyScott> why would anyone log in to IRC for that matter?
23:10:41 <Clint> shachaf: because the 450 existing irc implementations are terrible spaghetti code
23:10:44 <ChongLi> I bet there's a lot of room for improvement in terms of IRC performance
23:10:49 <ChongLi> and code clarity :)
23:10:55 <EmilyScott> or the protocol itself frankly...
23:11:16 <ChongLi> it's a very similar use case to an HTTP server
23:11:23 <ChongLi> and we all know how Haskell shook those things up
23:11:36 <Tekmo> Oh, I think I know the answer to Clint's question, though
23:11:45 <Tekmo> I think Don Stewart's IRC bot tutorial took the wind out of most efforts
23:12:51 <Clint> how's that
23:13:32 <Tekmo> It's just a guess
23:14:13 * hackagebot c2hsc 0.6.4 - Convert C API header files to .hsc and .hsc.helper.c files  http://hackage.haskell.org/package/c2hsc-0.6.4 (JohnWiegley)
23:14:16 <Tekmo> After that tutorial it's pretty much downhill drudgery (i.e. protocol implementation)
23:14:24 <Tekmo> He covered the fun part, leaving the boring stuff as the rest
23:14:41 <Clint> so your answer is "academia"
23:15:13 <Tekmo> I assume that by that you mean that "academia" reflects a tendency to only cover the interesting part
23:15:26 <Clint> fsvo interesting
23:17:18 <Tekmo> To be fair, I understand why academics have to do this (time constraints)
23:17:37 <EmilyScott> and frankly, some times the details do obscure the point someone is trying to demonstrate as well.
23:18:39 <Tekmo> However, sometimes it is a problem when none of the examples have details
23:18:58 <Tekmo> New Haskell programmers often complain that they desire more fully featured examples that work out all the small details
23:20:45 <ChongLi> either that or they come in here with some ugly C algorithm and try to hand-translate it into Haskell :)
23:21:12 <Tekmo> What's nice, though, is that you can hand-translate C if you are familiar with the Foreign.* hierarchy
23:21:24 <ChongLi> right, but it's going to retain all its ugliness
23:21:28 <Tekmo> True :)
23:21:59 <ChongLi> what we need is a general article advising people to search for the original mathematical version of the algorithm
23:22:10 <ChongLi> or something related to it
23:23:13 <enthropy> sometimes the original formulation tends to be imperative
23:23:15 <Tekmo> RTFMathematical algorithm
23:23:32 <ChongLi> enthropy: yeah, that's where the related part comes in
23:23:47 <ChongLi> it simply may not be appropriate
23:24:08 <ChongLi> but the purely functional version should give other nice properties
23:24:18 <enthropy> can you find a "mathematical" definition of the Federov exchange algorithm?
23:25:29 <enthropy> it's pretty much "exchange numbers between one array and the whole range, until a function doesn't improve anymore"
23:26:11 <Tekmo> maximumBy fitnessFunction (exchanges ...) -- I'm making things up
23:26:19 <ChongLi> yeah, and implementing that with persistent data structures would cost you
23:27:14 <ChongLi> or rewrite it as a fixed point
23:27:47 <Tekmo> Fixed point algorithms always seem so inelegant to me
23:28:08 <ChongLi> I thought the square root by newton's method one was pretty nice
23:28:59 <Tekmo> I don't mind if it's used as a successive approximation
23:29:08 <Tekmo> I mean the ones where you stop when it equals the previous iteration
23:29:19 <ChongLi> ahhh
23:36:21 <dleedev> hi, what's the naming convention in Haskell for functions?
23:36:31 <ChongLi> naming convention?
23:36:41 <dleedev> In OO languages, it's usually present-tense verb
23:36:48 <dleedev> that describes what the verb is doing
23:36:55 <ChongLi> ahhh
23:37:20 <ChongLi> show lens to someone who adheres to that convention rigidly :)
23:37:24 <scott_> Is it possible to define f :: Void -> a in Haskell, and not have it complain about the lack of a body?
23:37:30 <dleedev> if you have a function that does something more specific, then you add an adverb to the verb
23:37:49 <ChongLi> lens is all a mishmash of different tenses :)
23:38:00 <dleedev> but what about general haskell programming?
23:38:02 <c_wraith> scott_: sure.  f (Void v) = f v
23:38:05 <shachaf> There are various ways depending on how you define Void.
23:38:10 <c_wraith> scott_: for newtype Void = Void Void
23:38:24 <scott_> I'm using data Void
23:38:28 <shachaf> For "data Void", not really.
23:38:28 <dleedev> ChongLi: are there no obvious conventions?
23:38:33 <scott_> Okay, thanks
23:38:33 <pavonia> scott_: the usual temporary hack is f = undefined
23:38:41 <ChongLi> dleedev: not that I can see
23:38:44 <shachaf> absurd !x = error "absurd" or something
23:39:00 <shachaf> I think the next version of GHC will have empty case expressions.
23:39:15 <c_wraith> Yeah, I seem to recall that was in the list of changes
23:39:16 <dleedev> ChongLi: :(
23:39:43 <shachaf> You can also define newtype Void = Void (forall r. r)
23:39:44 <ChongLi> some examples from lens: folded, folding, bitAt, biplate, catching, catches, getMax, fromWithin, indexed, indexing
23:40:01 <ChongLi> indices!
23:40:17 <shachaf> Yes. They're used in different ways.
23:40:32 <Tekmo> The real reason for their existence is to avoid clashing with existing namespace
23:40:43 <ChongLi> not to mention (%=) (+~) (&) etc.
23:40:43 <Tekmo> At least, that's what Edward said when he gave his lens talk
23:41:13 <shachaf> He said he looked for unused namespace.
23:41:15 <Tekmo> It's easier to maintain naming consistency with lens if you just reserve an entire tense for your own library
23:41:29 <ChongLi> his goal was for lens not to have to be imported qualified
23:41:34 <shachaf> Not that it's just haphazard with no rhyme or reason.
23:41:34 <ChongLi> cause that would really suck
23:41:50 <Tekmo> ChongLi: Not necessarily
23:41:56 <Tekmo> ChongLi: You could put all operators in one module
23:42:01 <Tekmo> ChongLi: Then import everything else qualified
23:42:15 <ChongLi> ahhh, yeah
23:42:15 <shachaf> That's why lens exports .Operators
23:42:21 <shachaf> Peaker does that.
23:42:43 <shachaf> Anyway, the standard library is full of this sort of thing too, if you look.
23:42:46 <ChongLi> I wonder, with a better type system could we do away entirely with the need for importing things qualified?
23:42:50 <shachaf> Why is it "map" and "length"?
23:43:00 <ChongLi> and just infer the correct definition?
23:43:08 <ChongLi> for functions and constructors
23:43:17 <ChongLi> I know Agda infers constructors
23:43:47 <ChongLi> would this sort of "true overloading" have value?
23:44:07 <Tekmo> My rule of thumb is that overloading is only good if it has associated laws
23:44:07 <shachaf> There's a problem with using types to infer values and also using values to infer types.
23:44:09 <Tekmo> Same as type classes
23:44:21 <dleedev> hmm... I guess naming things is indeed one of the two hardest things about programming
23:44:37 <Tekmo> Without laws you can't reason about overloaded code
23:44:43 <ChongLi> shachaf: Agda dispenses with the second one, no?
23:44:55 <ChongLi> by requiring you to specify the types of top-level definitions
23:45:06 <ChongLi> and then everything can be inferred down from those
23:46:26 <shachaf> Agda does a bit of it, with constructors.
23:46:53 <ChongLi> would it harm Haskell's growth with beginners to require type signatures for all top-level definitions?
23:48:18 <Tekmo> So back when I fell in love with Haskell it was a big thing that Haskell had type inference
23:48:27 <Tekmo> People assumed statically typed = Java
23:48:43 <ChongLi> haha, yeah
23:48:44 <Tekmo> These days it seems to be less of a deal to include type signatures
23:48:49 <Tekmo> People are much more open to it now
23:49:27 <ChongLi> and I mentioned this earlier when we were talking about Rust (like 10 hours ago)
23:50:01 <ChongLi> I like the style of having a type signature separate from the definition of formal parameters/pattern matching
23:50:09 <Tekmo> Me, too
23:50:09 <ChongLi> it's much cleaner
23:50:36 <Tekmo> In my case I came from a C background where you had function prototypes, so the idea of separate type signatures was not so weird
23:50:46 <SrPx> Hey I'm just asking please take no offense, but why don't cabal follow npm's philosophy in regards to dependency solving? It works really well.
23:51:05 <ChongLi> right, but even C prototypes mix the names of the formal parameters with their types
23:51:13 <Tekmo> ChongLi: Not necessarily
23:51:18 <Tekmo> ChongLi: You can define them without the names
23:51:30 <ChongLi> Tekmo: I didn't know that!
23:51:38 <Tekmo> Yeah
23:51:40 <ChongLi> SrPx: I'm not familiar with npm
23:51:46 <Tekmo> void f(void, void), for example
23:51:50 <ChongLi> do they allow only exact versions of packages?
23:51:50 <jle`> why does newtype even exist?  why can't the compiler just infer that it can newtype-ize a data with one constructor and one field?
23:52:28 <Tekmo> jle`: You mean having all one-field data types automatically made into newtypes?
23:52:31 <dhrosa> is f(void, void) actually a valid type signature in C?
23:52:34 <jle`> Tekmo: yes
23:52:41 <jle`> is there a situation where you would not want that to happen?
23:52:45 <SrPx> ChongLi: it just copies every dependence of a project for it. So if X depends on A 1.7 and B 1.8, there will be a folder called X, and inside it there will be a perfect copy of A 1.7 and B 1.8. Everything is isolated so things never never break. At cost of some space that never matters anyway
23:52:47 <jle`> one field, one constructor
23:52:48 <shachaf> Alas, C doesn't support void values.
23:52:53 <shachaf> It would be nice if it did.
23:52:59 <Tekmo> Oops
23:53:00 <shachaf> Well, in C++ it would actually be useful.
23:53:03 <Tekmo> I meant (void *)
23:53:06 <dhrosa> ah
23:53:09 <Tekmo> void f (void *, void *)
23:53:10 <dhrosa> f(void) works
23:53:14 <ChongLi> SrPx: so what happens when some of those dependencies are updated?
23:53:27 <ChongLi> do you have to update your package to point to the new versions?
23:53:47 <Tekmo> jle`: The only justification I can think of is just to make it explicit so that you know which constructors are free and which are not
23:53:56 <jle`> free?
23:54:08 <Tekmo> jle`: By "free" I mean no performance cost for wrapping/unwrapping
23:54:24 <SrPx> ChongLi: the project still uses the last dependency. It is free to update manually to a newer version. Doing so automatically is not wise as the author of the dependency could change semantics breaking the project. So if X depends on A 1.7 and A is updated to 3.2, X still uses A 1.7 until the owner manually updates to A 3.2 and checks ieverything works
23:54:33 <jle`> oh
23:54:47 <ChongLi> SrPx: ah, so what about old packages?
23:54:53 <jle`> shouldn't there be some kind of warning then whenever you use data with one constructor and on field?
23:54:54 <ChongLi> ones that are no longer maintained?
23:54:55 <SrPx> chatsiri_: what old packages?
23:55:03 <SrPx> chatsiri_: pardon! ChongLi
23:55:12 <ChongLi> do they just hang around depending on all these old versions of their dependencies forever?
23:55:18 <shachaf> FSVO "no performance cost"
23:55:20 <SrPx> ChongLi: yes
23:55:25 <Tekmo> jle`: Yeah, that would be useful
23:55:31 <mirpa> Can I make ForeignPtr without FinalizerPtr eg. newForeignPtr nullFunPtr ...?
23:55:36 <SrPx> why not? If they work well with them. This way things never break...
23:55:37 <ChongLi> yeah, Haskell tries to avoid that to some extent
23:55:41 <shachaf> If newtype Foo a = Foo a, then Foo behaves like id, so map Foo behaves like map id
23:56:07 <Tekmo> To clarify what shachaf means, something like `map Newtype` is not free
23:56:08 <ChongLi> it's important for users to be able to get security updates
23:56:22 <Tekmo> If I remember correctly, Joachim was working on something to fix this
23:56:37 <ChongLi> map runIdentity [Identity a] = [a] ?
23:57:01 <Tekmo> ChongLi: They are the same, but different performance
23:57:12 <SrPx> ChongLi: then they use libs that are maintained! It seems like trying to get safe forever, but that does not look like it would work anyway. Imagine that a security problem needs a semantic update to be solved. Then Haskell goes bad? You either break said old projects forever, or let it unsafe?
23:57:15 <ChongLi> just stick a rewrite rule in there :)
23:57:23 <c_wraith> Tekmo: there's coerce in GHC 7.8, but...  It's manual.
23:57:31 <ChongLi> SrPx: well, node is also a different environment
23:57:40 <ChongLi> Haskell has a lot of low-level systems stuff
23:57:48 <ChongLi> for which security updates are very important
23:57:57 <SrPx> ChongLi: I'm aware Cabal is pretty much the worse complaint from haskellers, isn't it?
23:58:06 <ChongLi> SrPx: for new Haskellers
23:58:18 <jle`> shachaf, Tekmo: well...is there any reason that ghc/haskell can't auto-free-ize single field (single) constructors?
23:58:22 <ChongLi> and then when you learn to use sandboxes, you are fine
23:58:29 <jle`> can't it just automatically newtype all datas
23:58:35 <SrPx> Hm I don't know...
23:58:36 <jle`> ?
23:58:41 <c_wraith> jle`: no, that changes semantics
23:58:43 <ChongLi> node basically just does the sandboxing for you automatically
23:58:52 <jle`> c_wraith: hm really? how so?
23:59:07 <ChongLi> the ideal way would be to combine both approaches
23:59:09 <c_wraith> jle`: pattern-matching a data constructor causes evaluation of the constructor.  pattern-matching a newtype constructor does nothing at all
23:59:15 <jle`> oh
23:59:21 <jle`> hm
23:59:27 <ChongLi> and use a hash of the cabal file to determine if 2 packages were identical
23:59:30 <SrPx> I still don't see how updating dependencies of old code that works is a good thing... and I've had an horrible experience with Cabal, even when just trying to install a single library ):
23:59:35 <ChongLi> just like NixOS does :)
23:59:46 <jle`> well that's unfortunate
