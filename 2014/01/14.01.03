00:00:46 <Tekmo> Unfolds are a really nice way to encode things because `ghc` optimizes them well
00:01:22 <augur> yeah, ok, so infinite data isnt problematic, but possibly finite data means you need to handle things by continuation or something.. how funky
00:01:43 <Fylwind> if I were to use Text (Strict or Lazy?) instead of String, is there still a reason to use the "difference list" approach rather than simply concatenating the them for a Show-like class?
00:02:03 <Tekmo> I really liked Wadler's treatment of recursive data types: http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
00:03:04 <Tekmo> Fylwind: In theory you should stll use the difference list approach
00:03:28 <Tekmo> At least, you should for lazy text
00:03:50 <Fylwind> hm
00:04:01 <Tekmo> Also, see the `Builder` type, which is basically Text encoded as a difference list
00:04:23 <Tekmo> If you `concat` the `Builder` type it is equivalent to composing difference lists
00:04:44 <Fylwind> oh ok i'll take a look, thanks
00:05:15 <Tekmo> You're welcome
00:05:30 <mgsloan> If you've got a list of strict texts, the most efficient thing is using strict concat
00:06:11 <mgsloan> But yeah, concatenating strict text directly can be inefficient (because it allocated buffers for the intermediate results)
00:06:18 <mgsloan> *allocates
00:06:29 <Fylwind> mgsloan: it's rather hard to do that here since i'm doing it recursively
00:06:30 <Tekmo> The other advantage of using `Builder` is that it avoids unnecessary memory allocations by delaying them as long as possible until you finally materialize the `Builder` into a `Text`
00:06:51 <mgsloan> Fylwind: Sounds like Builder is the ticket then!
00:09:49 <joejev> Why is "iSqrt = round . sqrt . fromIntegral" not (Integral a,Integral b) => a -> b but instead Integer -> Integer?
00:10:35 <Tekmo> joejev: Did you define it in `ghci`?
00:10:38 <srhb> joejev: It is
00:11:07 <joejev> Tekmo: I just defined it in a module that I loaded, I did not use it anywhere
00:11:12 <Fylwind> :t round . sqrt . fromIntegral
00:11:13 <lambdabot> (Integral c, Integral a) => a -> c
00:11:16 <mm_freak_> free groups remind me of abstract-algebraic tetris
00:11:29 <joejev> hmmm, let me see what is restricting this
00:11:36 <Tekmo> joejev: Try giving it an explicit type signature
00:11:42 <Tekmo> joejev: This sounds like a case of type defaulting
00:12:25 <joejev> Tekmo: I just did and it worked, that was odd, I thought that it would make it the most generic it could by default
00:12:39 * hackagebot geodetic 0.1.1 - Geodetic calculations  http://hackage.haskell.org/package/geodetic-0.1.1 (TonyMorris)
00:12:39 * hackagebot modulespection 0.1.0.7 - Template Haskell for introspecting a module's declarations  http://hackage.haskell.org/package/modulespection-0.1.0.7 (JonathanFischoff)
00:12:42 <joejev> Tekmo: I just wanted to see what type it would infer
00:12:52 <srhb> It's the monomorphism restriction, I believe
00:13:56 <srhb> joejev: Try adding {-# LANGUAGE NoMonomorphismRestriction #-} to your module, then see that it infers the more general type
00:14:36 <srhb> joejev: Alternatively, write the function in pointed style; foo x = round . sqrt . fromIntegral $ x
00:14:53 <srhb> That, too, will be inferred as the more general type.
00:15:52 <joejev> I got it working, I was just wondering why that was, but thanks
00:16:15 <srhb> joejev: You'll probably run into the Monomorphism Restriction again later, it is worth checking out what it means. :)
00:17:55 <joejev> srhb: http://www.haskell.org/haskellwiki/Monomorphism_restriction is this a good source>
00:18:19 <srhb> joejev: Yes. :)
00:20:11 <mm_freak_> after the last non-funny FP joke, xkcd already lost some of its coolness
00:20:18 <mm_freak_> but the latest one is just plain stupid
00:21:05 <srhb> mm_freak_: Probably because laziness jokes have lost their appeal to everyone in #haskell :P
00:21:08 <joejev> srhb: so because I wrote that as point free form, the compiler could not infer the type of the parameter through a pattern match and made it more restrictive?
00:21:40 <srhb> joejev: The compiler _could_ but the monomorphism restriction prevents it from doing so, yes.
00:22:29 <mm_freak_> srhb: but the shoot-in-the-foot laziness jokes were great
00:22:47 <srhb> mm_freak_: I must have forgotten those.
00:22:52 <joejev> srhb: seems confusing, eh
00:22:56 <srhb> joejev: Massively.
00:23:02 <srhb> joejev: Hence the controversy.
00:23:36 <srhb> joejev: If you just remember that if you get a less general type than your expected, it's probably the MR -- you'll be fine. :-)
00:24:32 <Tekmo> At least they're fixing `ghci` to have `NoMonomorphismRestriction` enabled by default
00:24:37 <srhb> That's a good idea.
00:25:35 <Tekmo> Regarding xkcd, there is no such thing as bad publicity
00:25:37 <srhb> Is anyone working on porting XMonad to Wayland? I'm considering giving it a stab.
00:25:41 <srhb> Tekmo: Very true.
00:26:13 <zRecursive> srhb: support you
00:26:24 <srhb> Besides, the backend to some of XKCD's more interesting gimmick comics were written in Haskell afair
00:26:29 <Tekmo> Would we have to rename it to WayMonad?
00:26:35 <srhb> WMonad, of course, yes.
00:26:48 <Tekmo> Are there Haskell bindings to wayland?
00:26:52 <srhb> Not yet, I think
00:27:05 <zRecursive> @where wayland
00:27:05 <lambdabot> I know nothing about wayland.
00:27:16 <srhb> Which is partially why I want to give it a shot, I have yet to try writing a bindings library
00:27:19 <mm_freak_> Tekmo: indeed
00:30:09 <Tekmo> Actually, I might try my hand at Wayland bindings
00:33:50 <Fuuzetsu> is there a disadvantage to using records instead of type classes if one doesn't use any exotic type-class features (fundeps, typefams, multiparam, everything really)?
00:36:23 <zRecursive> records and type classes are used for different goal
00:36:41 <Tekmo> Records don't get automatically supplied
00:36:51 <Tekmo> However, I consider that a mostly good thing
00:37:15 <Fuuzetsu> Tekmo: that can be seen as an advantage because you can have multiple records for a type as opposed to a single instance (save for newtype)
00:37:18 <Tekmo> A lot of times where you would consider using records it is because there is not necessarily one correct behavior per type
00:37:23 <Tekmo> Fuuzetsu: I completely agree
00:37:44 <Tekmo> I'm a big fan of records
00:37:46 <Fuuzetsu> I'm asking because in Agda we just use records and it works out, although Agda records are a bit better
00:38:03 <Fuuzetsu> then again it's not really the same programming style
00:38:16 <carter> its more of a first class modules style
00:38:49 <Fuuzetsu> I wish we had Agda's module system. Why don't we? Is there anything stopping us?
00:39:02 <Fuuzetsu> It doesn't seem to do anything impossible in Haskell
00:39:41 <Tekmo> I think the main reason is that Haskell cannot pass around types as a values
00:39:55 <Tekmo> At least for the "module system" part
00:40:25 <zRecursive> Tekmo: maybe TH can do it ?
00:40:29 <Fuuzetsu> It doesn't matter for parametrised modules, does it?
00:40:40 <Tekmo> I don't know.  This is not my area of expertise
00:40:57 <Jookia> Hello! Is there a better way to convert `Either String a' to `ErrorT String IO a'? So far my implementation is `toErrorIO = either throwError return'
00:41:05 <Tekmo> All I know is that every time I discuss this people mention that the two biggest problems are the lack of types as values and also issues with coherent instances
00:41:27 <Fuuzetsu> zRecursive: Perhaps a dirty, dirty hack could be implemented under the hood as a proof of concept but it'd be nice to have official support
00:41:27 <Tekmo> Jookia: You mean `IO (Either String a)`?
00:41:47 <Jookia> Tekmo: Yes
00:41:54 <Tekmo> Jookia: So there are pros and cons to the two approaches
00:42:23 <Tekmo> Jookia: The approach that uses `IO` for all exceptions is faster
00:42:47 <Fuuzetsu> (what I really want is opening of modules inside ‘where’ blocks though, it's pretty damn nice)
00:42:55 <Tekmo> Jookia: However, the exceptions that something can throw don't appear in the type
00:43:16 <Tekmo> Jookia: Putting an `Either` or `EitherT` in the type is a much more visible way to document that something can fail
00:43:35 <Tekmo> Jookia: Also, `Either` and `EitherT` have more powerful tools for handling and manipulating exceptions
00:43:53 <Jookia> Tekmo: Isn't EItherT and ErrorT basically the same thing?
00:43:56 <Tekmo> Jookia: Also, `Either` and `EitherT` are not limited to storing just exceptions
00:43:59 <Tekmo> Jookia: Yeah, basicallly
00:44:35 <Tekmo> Jookia: Also, `EitherT`/`Either` work for pure code, whereas `IO` exceptions do not
00:44:36 <haasn> I wonder how easy it would be to add checked exceptions to IO
00:44:42 <haasn> via DataKinds and stuff
00:44:52 <Tekmo> I think a more pressing issue is establishing an exception-free version of `IO`
00:44:56 <Tekmo> i.e. "SafeIO"
00:45:03 <Tekmo> try :: IO a -> SafeIO (Either SomeException a)
00:45:20 <akegalj> could you tell me which library is good for html parsing?
00:45:22 <Tekmo> Right now we don't have a good way to opt out of exceptions for IO, which is really annoying
00:47:16 <roboguy_> Tekmo: couldn't you do something like that with the existing "try" and a newtype?
00:47:34 <Tekmo> roboguy_: You could
00:47:40 <zRecursive> :t try
00:47:41 <lambdabot> Exception e => IO a -> IO (Either e a)
00:48:19 <Jookia> Tekmo: `type EitherIO a = EitherT String (IO a)' isn't a thing?
00:49:16 <Jookia> Oh, removing the parenthesis fixes it I guess
00:49:29 <Tekmo> Jookia: See my `errors` package
00:49:36 <Tekmo> Jookia: It provides the `Script` type which is exactly what you wrote
00:49:42 <Tekmo> type Script = EitherT String IO
00:50:01 <Tekmo> It also provides lots of tools for working with `EitherT` (and other error-ful types)
00:51:01 <zRecursive> @hoogle EitherT
00:51:01 <lambdabot> package EitherT
00:51:48 <Tekmo> No, use the `either` package
00:51:52 <Tekmo> @package either
00:51:52 <lambdabot> http://hackage.haskell.org/package/either
00:51:57 <Tekmo> That's the official one
00:52:11 <zRecursive> ok
01:09:42 <Jookia> Tekmo: So using EitherT, my toErrorIO function is now `toErrorIO = either left right'. Surely there's a constructor/return to do this?
01:10:13 <Jookia> Oh, EitherT . return
01:10:57 <Tekmo> If your action's type is `IO (Either String a)`, then you just wrap it in `EitherT` alone
01:11:18 <Tekmo> EitherT :: m (Either a b) -> EitherT a m b
01:11:39 <Jookia> Tekmo: It needs the IO so I guess I had to return it
01:12:47 <Tekmo> Jookia: The `errors` library has a `hoistEither` function for this purpose, too
01:12:58 <Tekmo> Jookia: hoistEither :: (Monad m) => Either a b -> EitherT a m b
01:16:35 <jonkri> How can I see which dependency of a Cabal package requires a certain dependency? For example, say that I want to find out why the latest Yesod requires crypto-api ==0.13 without going through its dependencies one by one.
01:18:26 <Tekmo> jonkri: Do you have the error message you got from `cabal`?
01:21:47 <Disgrntld> Hello, I'm trying to understand do notation by converting expressions to bind-style, I'm confused about (>>). What's the correct way to convert this? http://lpaste.net/97919
01:21:51 <jonkri> Tekmo: http://lpaste.net/97887
01:31:59 <lewis1711> say you want to associate each member of an enumerated type to a different integer. is it more efficient to just write a function that pattern matches against all the values, rather than using an actual Map (like Data.Map) ?
01:33:03 <lewis1711> my thought process is that seeing as the functions are pure, it can probably be optimised and not require actual branching against values if you use a function
01:34:10 <Radditz> hello
01:34:20 <Radditz> can someone explain to me in simple terms what a monad is please
01:35:29 <jonkri> Radditz: I doubt it. :)
01:36:10 <Radditz> can someone explain it to me what a monad is in the simplest way possible?
01:36:19 <jonkri> Radditz: Maybe this would help: http://www.haskell.org/haskellwiki/Monad
01:36:42 <Radditz> I want it described in a language agnostic way, I have never actually used haskell before
01:37:36 <popl> Did you check Wikipedia?
01:37:42 <Radditz> yes, it's confusing
01:37:46 <Radditz> and too long
01:37:55 <felixsch> adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html <- maybe this?
01:38:10 <Fylwind> @pl filterWithKey f = filter (f . fst)
01:38:10 <lambdabot> filterWithKey = filter . (. fst)
01:38:48 <Radditz> what makes maybe a monad?
01:38:56 <Radditz> I have used it before in Ocaml but I don't understand what makes it a monad
01:39:05 <Radditz> it's like an excplicit null and non null value
01:39:28 <popl> 'fmap is from the streets'
01:39:35 <companion_cube> :i Monad
01:39:40 <Cale> Radditz: the definitions of return and (>>=)
01:39:48 <Cale> return v = Just v
01:39:55 <Cale> Nothing >>= f = Nothing
01:40:10 <Cale> Just v >>= f = f v
01:40:27 <Cale> Radditz: That's all there is to it
01:40:53 <Radditz> hm
01:40:55 <Cale> From there, you get all the stuff in Control.Monad and various other libraries for free.
01:41:00 <Fylwind> @pl h k v = f k
01:41:01 <lambdabot> h = const . f
01:41:05 <Radditz> what's the interest of a monad?
01:41:07 <Cale> > sequence [Just 1, Just 2, Just 3]
01:41:08 <lambdabot>  Just [1,2,3]
01:41:14 <Cale> > sequence [Just 1, Just 2, Nothing]
01:41:15 <lambdabot>  Nothing
01:42:28 <Cale> > let dict = [(1,4),(2,3),(3,1),(4,4)] in do x <- lookup 3 dict; y <- lookup x dict; return y
01:42:29 <lambdabot>  Just 4
01:42:43 <Cale> > let dict = [(1,4),(2,3),(3,1),(4,4)] in do x <- lookup 5 dict; y <- lookup x dict; return y
01:42:44 <lambdabot>  Nothing
01:42:57 * FliPPeh loves the Maybe Monad
01:43:02 <tpsinnem> does anyone know how costly it might be to maintain a finger tree in a canonical shape for each size, in a setting where you may append from either side?
01:44:04 <tpsinnem> i wonder if it's linear in the worst case? :/
01:44:14 <Cale> tpsinnem: That sounds probable
01:45:48 <Cale> Why do you care about the internal shape of the tree?
01:46:26 <tpsinnem> Cale: i'd like equality for trees with the same elements
01:46:26 <Kaidelong> @hoogle a -> (a -> b, a -> c) -> (b,c)
01:46:26 <lambdabot> No results found
01:47:09 <tpsinnem> i've been pondering on a data structure that'd hopefully do this in logn time, but i don't want to do the effort in case finger trees can already do this
01:47:10 <Cale> tpsinnem: t == t' = toList t == toList t'
01:47:46 <Kaidelong> @ty (***)
01:47:47 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
01:47:51 <tpsinnem> Cale: i want the double-ended append properties of finger trees
01:48:11 <Kaidelong> @ty (&&&)
01:48:12 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
01:48:16 <Kaidelong> oooh
01:48:27 <jonkri> I think that there are a number of primitives you need to learn about before learning about monads, such as type classes, higher order functions, functors, and so on. If you have time and interest, I can recommend this free book: http://learnyouahaskell.com/chapters
01:48:30 <Cale> tpsinnem: I'm just saying that when you compare them for equality, just enumerate the elements and compare those.
01:48:41 <Cale> I don't think it's theoretically possible to do any better than that.
01:49:01 <Cale> (At least as long as we're working with elements that are an arbitrary instance of Eq)
01:49:22 <Cale> Even if we know more about the element type, it's hard to imagine doing all that much better
01:53:29 <Cale> Radditz: http://www.haskell.org/haskellwiki/Monads_as_computation is my little attempt at explaining why we care about monads as programmers
01:53:53 <Cale> Radditz: Really, it's not such a big deal, it's just nice to save writing some code every time we notice that something happens to be a monad.
01:54:03 <Radditz> I see
01:54:49 <Cale> (Like any abstraction, the main benefit is to save typing out similar definitions over and over)
01:56:26 <tpsinnem> Cale: i suppose my goal is to avoid having to do any extra work in order to be able to compare them
01:56:44 <tpsinnem> as in extra code
01:57:00 <Cale> Doesn't FingerTree already have an instance of Eq written?
01:57:17 <Cale> Eq a => Eq (FingerTree v a)
01:57:21 <Cale> It does :)
01:57:37 <Cale> instance Eq a => Eq (FingerTree v a) where
01:57:38 <Cale> 	xs == ys = toList xs == toList ys
01:57:45 <tpsinnem> Cale: the application would ultimately not be in haskell
01:57:48 <zett_zelett> I don’t get it: I wanted to compile b1 (https://sites.google.com/site/btmura/home), but compiling and running Setup.hs, it says that I’m missing some dependencies (FTGL, GLFW, test-framework, test-framework-hunit, test-framework-quickcheck2) which I definitely have installed.
01:57:49 <Cale> haha, it even uses the implementation I suggested
01:58:00 <tpsinnem> but this is where i can expect people to know about finger trees :)
01:58:26 <Cale> tpsinnem: Well, that's a good implementation of equality testing anyway: compare each of the elements in turn
01:59:01 <Cale> tpsinnem: If you consider the case for example where the elements are all Bool values, there's no way you can hope to do better than checking every corresponding pair of elements in general
01:59:46 <Cale> You could do things to try to shortcut, comparing the measure of the trees first
02:00:25 <Cale> (i.e. selling out your worst case slightly in order to improve the average)
02:02:20 <Cale> (But that would also require having an equality test on your monoid of measures, which is why the Haskell implementation doesn't do it -- you kind of want the general test to work even if the monoid is some function type, for instance)
02:03:17 <ivanm> juhp: you around?
02:03:46 <Kaidelong> @hoogle CreateProcess -> IO ProcessHandle
02:03:46 <lambdabot> Control.Exception.Base throwIO :: Exception e => e -> IO a
02:03:46 <lambdabot> Control.Exception throwIO :: Exception e => e -> IO a
02:03:46 <lambdabot> Control.OldException throwIO :: Exception e => e -> IO a
02:05:26 <tpsinnem> Cale: in haskell, would an Eq instance let me do pattern matches like 'foo (sameThing, sameThing) = bar'
02:05:35 <Cale> no
02:05:36 <ivanm> tpsinnem: nope
02:05:44 <ivanm> you'd want a guard or something for that
02:05:50 <Cale> But you could write foo (x,y) | x == y = ...
02:06:03 <zett_zelett> Okay, I can configure and compile with cabal (why didn’t I think of that earlier), but now I get this error message:
02:06:03 <zett_zelett> src/B1/Program/Chart/Config.hs:19:23: Not in scope: `catch'
02:06:08 <zett_zelett> What do I need to install?
02:06:20 <Cale> There are a few reasons why "nonlinear patterns" like that aren't supported.
02:06:43 <ivanm> zett_zelett: probably need to import Control.Exception
02:06:51 <Cale> The semantics seem simple at first, but can get quite confusing, especially if there's more than one test involved at once.
02:07:41 <zett_zelett> ivanm: Shall I change the code or can I do this while compiling or something?
02:07:47 <ivanm> change the code
02:08:21 <zett_zelett> I mean, if the developer has put this up, the code should be somehow self-sufficient, doesn’t it?
02:10:10 <ocharles> AshyIsMe: thanks for pimping 24 DoH :)
02:10:19 <zett_zelett> It doesn’t work – it gives me another bunch of error messages.
02:10:32 <zett_zelett>     No instance for (Exception e0) arising from a use of `catch'
02:11:26 <ivanm> zett_zelett: I don't know what you're compiling, but it's likely that the code is from before the new extensible exception stuff was added
02:11:28 <Cale> That's because catch has changed, I believe
02:11:31 <ivanm> as such it won't compile any more
02:11:41 <ivanm> did catch used to get exported by the Prelude?
02:12:09 <Cale> Yes, but the one exported by the Prelude wasn't as general
02:12:28 <Cale> (It was the one described in Haskell 98)
02:13:22 <ivanm> yeah
02:13:36 <ivanm> so that's why the code used to work: it used catch from the Prelude before extensible-exceptions came out
02:13:47 <zett_zelett> Hm, can I make it compile somehow?
02:13:56 <ivanm> zett_zelett: you'd probably need to do a bit of work on it
02:14:04 <Cale> zett_zelett: I think if you add a type signature to handleError :: IOException -> IO Config
02:14:05 <zett_zelett> Do I need the catch method from OldException?
02:14:10 <Cale> zett_zelett: Then it won't complain
02:14:15 <zett_zelett> I’ll try.
02:14:19 <ivanm> zett_zelett: you could use that, but OldException is going as well
02:14:41 <ivanm> otherwise you can do what Cale suggested, or use the SomeException hack (except you know it's an IOException, so there's not much point)
02:15:32 <zett_zelett> Cale: Where can I put the type signature, though?
02:16:01 <zett_zelett> After each occurence of handleError or something?
02:16:02 <Cale> In the where clause just above the definition of handleError on line 26/27
02:16:18 <Cale> https://github.com/btmura/b1/blob/master/src/B1/Program/Chart/Config.hs <-- I'm looking at this
02:16:29 <tpsinnem> Cale: what i ultimately have in mind is idris where (iirc!) you can do pattern matches like the above if you have an equality proof -- of course that right there is an extra bit of code too :/.
02:17:16 <tpsinnem> but in any case what i would enjoy is the sense of cosmic harmony from not having to deal with two separate notions of equality, if possible :)
02:17:22 <Cale> tpsinnem: Idris is also strict, so some of the difficulties with the semantics of repeated variables would go away
02:17:38 <zett_zelett> Yeah, right.
02:17:41 <zett_zelett> It seems to work.
02:17:45 <Cale> zett_zelett: Cool
02:17:46 <zett_zelett> Many thanks, Cale and ivanm!
02:17:59 <ivanm> np
02:18:51 <tpsinnem> ok, thanks for the replies :)
02:19:05 <Cale> tpsinnem: One example of where it's tricky is the case of something like:
02:19:11 <Cale> f x x True = 1
02:19:14 <Cale> f x y z = 2
02:19:32 <Cale> Consider  f undefined 3 False
02:19:46 <tpsinnem> i do still remain curious on the canonical form issue, on finger trees and on some hypothetical pleasant structure
02:20:30 <Cale> tpsinnem: Well, even if you could get them to be structurally equal, I think you'd still end up traversing them to check that they were
02:20:49 <Cale> So I'm not sure you'd really save time like that
02:21:14 <Cale> Unless your plan is some kind of evil hash-consing scheme :)
02:21:33 <tpsinnem> cosmic harmony, if nothing else! :)
02:22:10 <ocharles> Data.Vector.Storable has 'unsafeFromPtr' and it says that 'The data may not be modified through the ForeignPtr. '
02:22:19 <ocharles> Does this mean if I'm writing bindings to a c library, I should memcopy?
02:22:27 <ocharles> (If I can't trust that the data will be immutable)
02:29:19 <Kaidelong> @ty foldr (<*>)
02:29:20 <lambdabot> Applicative f => f a -> [f (a -> a)] -> f a
02:29:33 <Kaidelong> @ty foldr (<*>) . map pure
02:29:34 <lambdabot> Applicative f => [a] -> [[f a -> f a]] -> [f a]
02:30:34 <ChongLi> ocharles: hey, are you around?
02:30:39 <ChongLi> probably :)
02:31:01 <ChongLi> what's a simple way to deal with callbacks in netwire?
02:31:27 <ChongLi> the GUI lib I'm using (GLFW-b) expects callbacks to return IO ()
02:31:35 <ocharles> ChongLi: I am around
02:31:37 <Kaidelong> I need a function for applicatives that lets me append a bunch of (a -> String)
02:31:52 <ocharles> ChongLi: Got more of an example?
02:32:14 <ChongLi> setKeyCallback :: Window -> Maybe KeyCallback -> IO ()
02:32:23 <ChongLi> type KeyCallback = Window -> Key -> Int -> KeyState -> ModifierKeys -> IO ()
02:32:34 <Kaidelong> @hoogle Applicative f => (a -> a -> a) -> [f a] -> f a
02:32:34 <lambdabot> Data.IntMap.Strict unionsWith :: (a -> a -> a) -> [IntMap a] -> IntMap a
02:32:34 <lambdabot> Data.IntMap.Lazy unionsWith :: (a -> a -> a) -> [IntMap a] -> IntMap a
02:32:34 <lambdabot> Data.Sequence scanl1 :: (a -> a -> a) -> Seq a -> Seq a
02:32:40 <ocharles> ChongLi: ok, so you want to get keypresses into your application?
02:32:49 <nadirs> Kaidelong: what do you mean "append..."? Building a list of functions (a -> String)?
02:32:50 <ChongLi> yeah
02:32:57 <ChongLi> turn them into Events
02:33:10 <Kaidelong> turning a list of functions (a -> String) into a single function (a -> String)
02:33:18 <Kaidelong> ooohg
02:33:24 <Kaidelong> I am barking up the wrong tree
02:33:25 <ChongLi> I've glanced over your asteroids example and I noticed you use polling there
02:33:27 <Kaidelong> I want mconcat
02:33:35 <Kaidelong> @ty mconcat
02:33:36 <lambdabot> Monoid a => [a] -> a
02:33:40 <ocharles> ChongLi: One option is to use an MVar to store the information about which keys are pressed, and then allow querying this MVar from your Wire. For example, you might have 'data GLFWSession s = GLFWSession (MVar KeyPresses) s'
02:33:53 <mm_freak_> ChongLi: first step:  use an IORef/MVar/… and either collect the events for the next frame, or step the wire for each event
02:33:56 <ChongLi> GLFW-b allows polling but it's a real pain since you have to poll for every individual key
02:33:59 <ocharles> ChongLi: so your callback updates the MVar, and your session type can sample that
02:34:07 <mm_freak_> ChongLi: second step:  tell the GLFW devs that their API is crap =)
02:34:18 <ChongLi> mm_freak_: haha
02:34:31 <ocharles> mm_freak_: on that note, did you see my comment about putting event information in the session type? It feels sane...
02:34:35 <ChongLi> that actually sounds really clean
02:34:46 <ocharles> ChongLi: here's my SDL session type:
02:34:53 <mm_freak_> ocharles: depends
02:34:55 <Kaidelong> > mconcat [show, const " boo ", show] $ 5
02:34:57 <lambdabot>  "5 boo 5"
02:35:07 <ocharles> http://lpaste.net/3512689718007431168
02:35:08 <ChongLi> so I can shove all the callbacks into my init function and basically forget about them
02:35:17 <mm_freak_> ocharles: sometimes you want to accumulate events across inhibited time periods, other times you don't
02:35:18 <ocharles> ChongLi: more or less
02:35:24 <ChongLi> and then just treat this one MVar as the source of all that is right and good with the world
02:35:35 <nadirs> Kaidelong: rubber ducking for the win :)
02:35:49 <ocharles> mm_freak_: true, though right now inhibition means "quit" :)
02:35:55 <mm_freak_> ocharles: for example when your game has both an in-game scene wire and a menu wire, you don't want to accumulate all key presses during in-game scenes and pass them to the menu =)
02:36:08 <ocharles> mm_freak_: I thought I would be using 'modes' for that
02:36:16 <mm_freak_> that's the main difference between the session monoid and a separate Reader
02:36:26 <ocharles> ok, gotta get back to work, bbiab
02:36:29 <ChongLi> is it worth-while for me to wrap/abstract over all the GLFW types?
02:36:45 <ChongLi> I may want to be able to switch GLFW out for something else down the road
02:36:54 <mm_freak_> ocharles: i wouldn't count on non-accumulation of session information, because it's the correct behavior
02:37:10 <mm_freak_> either you accumulate or you (forgetfully) switch
02:38:03 <mm_freak_> ChongLi: well, your scene should not be GLFW-specific
02:38:35 <mm_freak_> not because it's wrong, but because it may be inconvenient/unsafe to expose GLFW
02:40:06 <ChongLi> mm_freak_: makes sense
02:40:48 <mm_freak_> ChongLi: also you can introduce more semantically meaningful types
02:41:00 <mm_freak_> data Action = MoveLeft | MoveRight | Jump | …
02:41:09 <mm_freak_> instead of Key = UpArrow | DownArrow | Space | …
02:41:28 <ChongLi> mm_freak_: oh, yeah
02:41:37 <mm_freak_> things like that tend to prove useful when you allow customization later =)
02:42:00 <ChongLi> what I meant was wrapping GLFW.Key with MyModule.Key
02:42:12 <ChongLi> and then doing my own Action data type on type of that
02:42:37 <mm_freak_> Key and Action should be unrelated except for a function that maps from Key to Action
02:42:46 <ChongLi> right
02:43:29 <ChongLi> probably involving a Map from Data.Map, stored among other config data in the monad context?
02:44:22 <mm_freak_> ChongLi: not sure what you mean
02:44:30 <ChongLi> like a Reader monad or something
02:45:00 <ChongLi> there'd be some config file on disk that maps Key -> Action, load that on startup and create a Data.Map from it
02:45:28 <ChongLi> and then include that in the Wire's monad
02:45:35 <mm_freak_> the Map is an implementation detail, but the type would probably look like:  (MonadReader KeyMap m) => Key -> m (Maybe Action)
02:45:42 <ChongLi> right
02:45:57 <mm_freak_> you can then use a lens with 'censoring'
02:47:14 <mm_freak_> waituhm
02:47:18 <mm_freak_> not 'censoring'
02:47:44 <ChongLi> censoring is for the Writer monad
02:48:30 <mm_freak_> yeah…  i forgot what it is for Reader
02:48:56 <mm_freak_> i guess there is none
02:49:19 <mm_freak_> because 'local' is not powerful enough
02:51:51 <mm_freak_> :t \f (ReaderT c) -> ReaderT (c . f)
02:51:52 <lambdabot> (r -> b) -> ReaderT b m a -> ReaderT r m a
02:52:55 * hackagebot hsimport 0.2.4 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.4 (DanielTrstenjak)
02:54:00 <SoleSoul> Hi. Why does "div (-8) 7" equal (-2)? What should I use instead of 'div' if I need (-1) in this case? I want to know how many sevens are between zero and the number.
02:54:39 <sipa> > quot (-8) 7
02:54:40 <lambdabot>  -1
02:54:56 <mm_freak> :t withReaderT
02:54:57 <lambdabot> (r' -> r) -> ReaderT r m a -> ReaderT r' m a
02:55:17 <klrr> anyone know any example code for something like a simple-chat-server using async package?
02:56:04 <SoleSoul> sipa: Thank you!
02:56:56 <SoleSoul> I also picked up 'rem' on the way.
02:57:17 <SoleSoul> Is C's '/' a div or a quot?
02:58:26 <quchen> Neither.
02:59:13 <quchen> "/" is general division of Num types.
02:59:57 <Phlogistique> quchen: you misread the question
03:00:00 <Phlogistique> SoleSoul: a quot
03:00:02 <quchen> Oh.
03:00:18 <ChongLi> cabal run
03:00:22 <ChongLi> woops
03:00:23 <ChongLi> haha
03:00:30 <ChongLi> silly vimux
03:00:40 <SoleSoul> Phlogistique and quchen Thanks
03:01:49 <mm_freak> SoleSoul: yes
03:01:50 <quchen> SoleSoul: mod rounds to -infinity, rem to 0. rem is more C-like, so it's usually more efficient. For positive arguments they're identical.
03:02:17 <quchen> There are some defining equations that I don't remember that implicitly mention the behaviour. Let me see whether I can find them.
03:02:23 <quchen> (They include div/quot)
03:02:52 <ChongLi> mm_freak: alright, so I've got this working a bit, should I use some sort of queue for the MVar?
03:03:00 <quchen> To follow up on the "more efficient part", it's not more efficient because it's like C, it's like it and its C counterpart are closer to the machine instruction.
03:03:13 <ChongLi> like a Data.Sequence
03:03:14 <ChongLi> ?
03:03:39 <ChongLi> right now it works until simultaneous events happen, then it blocks indefinitely in the callback
03:04:12 <mello_> hi all
03:04:18 <ChongLi> hello
03:04:22 <mello_> i have a stupid question, but here it goes:
03:04:30 <ChongLi> no question is stupid here!
03:04:50 <SoleSoul> quchen: thanks
03:04:53 <mello_> how do i sequence monadic operations? what i mean is: I have for instance, something that returns something in IO a, but I want to do something with it before i bind it
03:04:54 <mello_> like
03:05:09 <mello_> foo <- someFunction . returnsIOfun
03:05:14 <quchen> SoleSoul: Ah, it's in the Haskell Report, section 6.4.2, "Arithmetic and Number-Theoretic Operations"
03:05:18 <merijn> mello_: fmap?
03:05:20 <merijn> :t fmap
03:05:21 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:06:19 <ChongLi> foo <- fmap someFunction returnsIOfun
03:06:34 <ChongLi> or
03:06:39 <mello_> merijn: okay let me wrap my brain around the types. I know all this stuff but putting it into practice is another thing
03:06:44 <ChongLi> foo <- someFunction <$> returnsIOfun
03:06:49 <quchen> SoleSoul: Search for "satisfy these laws": http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4
03:06:59 <FliPPeh> When using ErrorT in client facing functions, is it better to internally call runErrorT or is it preferred to let the client call runErrorT?
03:07:04 <FliPPeh> caller*
03:07:18 <ChongLi> mello_: the key thing to realize is that Monads are also Functors
03:07:53 <mello_> they're even applicative functors I know, i just need some playing with them i guess :), just a sec
03:07:57 <ChongLi> so Functor f => (a -> b) -> f a -> f b becomes (a -> b) -> IO a -> IO b
03:08:19 <SoleSoul> quchen: I see. Good to know.
03:09:48 <ChongLi> mello_: try this in GHCI
03:10:00 <ChongLi> :m +Data.Char +Control.Applicative
03:10:07 <ChongLi> map toUpper <$> getLine
03:10:09 <mello_> ah yes, that makes sense
03:10:22 <mello_> :t <$>
03:10:23 <lambdabot> parse error on input `<$>'
03:10:27 <ChongLi> :t (<$>)
03:10:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:10:32 <copumpkin> <$> is also in Data.Functor
03:10:41 <mello_> those are the applicative functors, right
03:10:46 <mello_> with <$> and <*>
03:10:57 <mello_> :t (<*>)
03:10:58 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
03:11:00 <aristid> mello_: <$> only requires Functor, not Applicative
03:11:21 <mello_> aristid, and <*>?
03:11:32 <aristid> mello_: that one also requires Applicative.
03:11:43 <mello_> ok, thanks i didnt know that
03:12:01 <ChongLi> Applicative is just a few extra laws on top of Functor
03:12:11 <aristid> no
03:12:16 <aristid> it also has extra methods.
03:12:28 <ChongLi> well, you need to implement the methods to satisfy the laws
03:12:34 <ChongLi> identity pure id <*> v = v
03:12:34 <ChongLi> composition pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
03:12:34 <ChongLi> homomorphism pure f <*> pure x = pure (f x)
03:12:35 <ChongLi> interchange u <*> pure y = pure ($ y) <*> u
03:12:57 * hackagebot hsimport 0.2.5 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.5 (DanielTrstenjak)
03:13:18 <mello_> guys i've got to go for now, I'll reread and make use of your help
03:13:19 <mello_> thanks
03:13:22 <mello_> see you later perhaps
03:13:27 <ChongLi> mello_: any time!
03:16:37 <FliPPeh> If I have two "IO (Either SomethingBad SomethingGood)", how do I best chain them without fetching the EitherT package?
03:16:54 <FliPPeh> where chain = monadic bind of course
03:17:12 <ion> What’s wrong with using the package?
03:17:38 <FliPPeh> I'm not to keen on fetching half of hackage as dependencies for things that could be done more trivial
03:17:47 <aristid> lol
03:17:53 <aristid> the package exists for a reason
03:18:10 <aristid> FliPPeh: but anyways, if you're fine adding an Error instance for somethingbad, this might work: http://hackage.haskell.org/package/mtl-2.1.2/docs/Control-Monad-Error.html
03:20:19 <ChongLi> anyone use the package dequeue?
03:20:26 <ChongLi> it seems to have what I want
03:20:41 <ChongLi> more than I want, actually
03:20:54 <mauke> I think I've used Seq for that
03:20:58 <ChongLi> I just want a queue I can push stuff into one end and take from the other
03:21:08 <ChongLi> ideally in O(1)
03:21:14 <ChongLi> possibly amortised
03:21:22 <quicksilver> Seq should be fine
03:21:29 <quicksilver> O(1) is a lie.
03:23:52 <remdezx> Hello! Do you know is there any possibility to show a module, where from data was imported? I have `data A = A` in `My.A` module and I want to print this "My".
03:24:06 <Fylwind> "<stdout>: commitBuffer: invalid argument (invalid character)"
03:24:22 <Aetherspawn> > sum . map ord $ "Happy new year to you!"
03:24:24 <lambdabot>  2014
03:24:28 <Aetherspawn> :P
03:24:31 <Fylwind> I'm printing some unicode characters on the console (cygwin terminal) in particular
03:24:32 <quicksilver> remdezx: I don't think so.
03:24:41 <mauke> remdezx: in ghci?
03:25:08 <remdezx> no, in program
03:25:27 <mauke> then no
03:30:18 <nadirs> Aetherspawn: been on codegolf.stackexchange lately, uh? :P
03:30:50 <Aetherspawn> :P
03:31:11 <maxs`> can lambdabot prettyprint haskell expressions in TH.Syntax types?
03:33:38 <nadirs> > ord 'ߞ'
03:33:39 <lambdabot>  2014
03:34:14 <nadirs> shorter, though the "happy new year" one is more impressive
03:34:16 <haasn> > sumOf (folded.from enum) "Happy new year to you!" -- Aetherspawn
03:34:18 <lambdabot>  2014
03:34:28 <mangaba_leitosa> > chr 2013
03:34:29 <lambdabot>  '\2013'
03:34:45 <mauke> map { (0) x ord } split //, "Happy new year to you!"  # perl version
03:34:48 <mangaba_leitosa> 2014 displays an empty box for me
03:34:56 <mauke> mangaba_leitosa: missing font
03:35:16 <mauke> apparently I got it from "Mincho"
03:35:56 <mangaba_leitosa> nko letter ka :-)
03:36:21 <mangaba_leitosa> yes, my fonts are without the Nko alphabet :-)
03:37:06 * ChongLi slaps forehead
03:37:15 <ChongLi> I should be using Control.Concurrent.Chan
03:37:18 <mangaba_leitosa> http://en.wikipedia.org/wiki/%DF%9E
03:37:22 <haasn> I got it from terminus, I think
03:37:23 <ChongLi> so simple and straightforward
03:37:27 <haasn> Which seems really odd
03:40:17 <ChongLi> hmm, no
03:40:21 <ChongLi> I need TChan
03:40:27 <ChongLi> for the non-blocking read
03:43:37 <juhp> ivanm, hi
03:44:30 <juhp> (if it is fedora related you can also use #fedora-haskell - bit quieter there:)
03:51:50 <quicksilver> ChongLi: do you really need non-blocking read? It's often better design to have a thread which just blocks on read.
03:52:35 <FliPPeh> Run blocking read in new thread and call callback on success
03:52:42 <FliPPeh> Or write something into a channel
03:53:06 <Tekmo> Yeah, I agree with quicksilver.  Blocking IO is idiomatic Haskell
03:53:41 <Tekmo> It's always better to sleep rather than poll
03:54:14 <Tekmo> (with the exception for the case where you are doing really high-performance IO)
03:54:15 <FliPPeh> I learned that lesson when I inquired why my process was grinding my machine to a halt a few years ago
03:55:03 <FliPPeh> @hoogle a -> b
03:55:03 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
03:55:03 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
03:55:03 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
03:55:12 <FliPPeh> Okay...
03:56:06 <FliPPeh> @hoogle (Monad m, Monad n) => m (n a) -> m (a -> n b) -> m (n b)
03:56:06 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
03:56:06 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
03:56:06 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
03:56:17 <FliPPeh> Nooo
03:56:49 <quicksilver> FliPPeh: liftM2(>>=)
03:56:56 <quicksilver> @type liftM2 (>>=)
03:56:57 <lambdabot> (Monad m, Monad m1) => m (m1 a) -> m (a -> m1 b) -> m (m1 b)
03:57:27 <FliPPeh> Wish I knew such things from the top of my head :(
03:57:28 <FliPPeh> Thanks
03:57:41 <quicksilver> liftM2 pulls a two-parameter function into a monad
03:57:46 <FliPPeh> Although looking at it it makes complete sense
03:58:11 <zett_zelett1> Can someoone describe to me in words what join :: IO (IO a) -> IO a does?
03:58:21 <zett_zelett1> How can I interpret this?
03:58:26 <mauke> @src join
03:58:27 <lambdabot> join x =  x >>= id
03:58:29 <mauke> like this
03:58:46 <FliPPeh> I could explain what it does in Maybe or Either, but IO?
03:58:47 <remdezx> Do you know any efficient shared memory implementations for Haskell?
03:58:52 <mauke> @unpl \x -> x >>= id
03:58:52 <lambdabot> \ x -> x >>= \ a -> a
03:58:53 <FliPPeh> What DOES joining an IO operation do?
03:58:56 <mauke> @. redo unpl \x -> x >>= id
03:58:56 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
03:58:59 <mauke> @. do unpl \x -> x >>= id
03:59:00 <lambdabot> \ x -> do { a <- x; a}
03:59:07 <quicksilver> zett_zelett1: IO (IO a) is an IO action which, when you run it, produces an IO action.
03:59:16 <quicksilver> zett_zelett1: what can you do with that resulting action?
03:59:20 <quicksilver> well, you could run it immediately.
03:59:24 <quicksilver> that's what join does
03:59:38 <zett_zelett1> That kind of makes sense.
03:59:38 <quicksilver> "run the outer action and then immediately run the inner action which is returned"
04:00:15 <quicksilver> do inner <- outer; inner;
04:00:26 <zett_zelett1> Is a sequence some sort of function IO (IO (IO (IO … (IO a) …))) -> IO a?
04:00:30 <quicksilver> no
04:00:37 <quicksilver> sequence is not nested like that
04:00:44 <quicksilver> it's just [IO a] -> IO [a]
04:00:56 <quicksilver> "given a list of actions, run them all, in that order, and collect the results into a list"
04:01:10 <zett_zelett1> Hm, yeah, I know. I didn’t mean sequence as a function.
04:01:12 <zett_zelett1> I mean.
04:01:18 <zett_zelett1> If you run a code in do notation.
04:01:37 <zett_zelett1> You have a sequence of instructions.
04:01:44 <zett_zelett1> (Or you can interpret it this way, I think.)
04:02:19 <mauke> I prefer to think in terms of >>=
04:02:22 <zett_zelett1> The instructions are somehow bound (well, using bind).
04:02:32 <zett_zelett1> But, can you interpret what you get in terms of join as well?
04:02:39 <mauke> only if you have fmap too
04:02:54 <mauke> m >>= f = join (fmap f m)
04:04:30 <zett_zelett1> How could one describe what a sequence of lines in do notation does in terms of join?
04:05:45 <mauke> desugar do notation, inline >>, inline >>= using my definition above
04:06:39 <zett_zelett1> I can’t interpret this, yet. I was hoping for some sort of shortcut to understanding what the IO Monad does.
04:06:50 <zett_zelett1> I will look at examples and work this through.
04:06:54 <mauke> oh, that's easy
04:06:56 <mauke> just ignore the monad part
04:07:06 <zett_zelett1> That’s what I’m interested in!
04:07:10 <mm_freak> ChongLi: if your events form a monoid, that's probably the best option
04:07:17 <mauke> IO is about attaching callbacks to actions
04:07:20 <mm_freak> ChongLi: of course Data.Sequence is itself a monoid
04:07:23 <mauke> zett_zelett1: do you happen to know javascript?
04:07:28 <zett_zelett1> Nope.
04:07:55 <mauke> ok, so you have values of type IO something. these values are called "actions"
04:08:04 * hackagebot egison 3.2.0 - The world's first language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.2.0 (SatoshiEgi)
04:08:08 <zett_zelett1> Haskell’s kind of my first programming language, (alongside C and Java with which I coded more, but in which I’m less interested).
04:08:10 <mauke> nothing in haskell actually executes actions. they just sit around
04:08:23 <zett_zelett1> C++*
04:08:38 <mauke> the runtime system takes the action bound to the symbol 'main' and executes it
04:08:42 <mauke> that's your "program"
04:08:48 <zett_zelett1> Yeah.
04:09:00 <mauke> everything else hangs off that
04:09:15 <mauke> let's take an example
04:09:20 <mauke> putChar :: Char -> IO ()
04:09:37 <mauke> this is a function that takes a character and returns an IO action that (when executed) outputs that character
04:09:56 <mauke> getChar :: IO Char
04:10:02 <mauke> this is not a function; it's a constant
04:10:19 <mauke> it's an IO action that (when executed) somehow reads a character
04:10:45 <mauke> so now the question is: how do you get your hands on that character?
04:10:49 <zett_zelett1> <-
04:10:51 <mauke> that's where >>= comes in
04:10:58 <zett_zelett1> Okay.
04:11:08 <mauke> (>>=) :: IO a -> (a -> IO b) -> IO b
04:11:36 <mauke> >>= takes an action (returning 'a') and a function (from 'a' to 'IO b') and returns a new action (returning 'b')
04:11:38 <tomejaguar> ocharles: I don't think I posted about (| |).  I ended up finding (| |) not very useful in the end, unfortunately.
04:12:37 <mauke> when m >>= f is executed, it 1) executes m, 2) applies f to the result, and 3) executes the action returned by f
04:13:02 <mauke> or in other words, it attaches the callback f to m, to be executed when the result of m is available
04:13:49 <zett_zelett1> Yeah, this makes sense.
04:13:52 <mauke> main = getChar >>= putChar  -- a complete program that (when executed) 1) runs getChar, 2) applies putChar to the character that was read, 3) executes the action returned by putChar
04:13:55 <zett_zelett1> I can understand how this works.
04:14:01 <Aetherspawn> :t (const id)
04:14:02 <lambdabot> b -> a -> a
04:14:26 <zett_zelett1> Thank you.
04:14:29 <Aetherspawn> :t idM
04:14:29 <lambdabot>     Not in scope: `idM'
04:14:30 <lambdabot>     Perhaps you meant one of these:
04:14:30 <lambdabot>       `id' (imported from Data.Function),
04:14:34 <zett_zelett1> But coming from monads from category theory, …
04:14:40 <Aetherspawn> is there an id for monads?
04:14:44 <mauke> zett_zelett1: I don't know CT
04:14:47 <zett_zelett1> … can I understand what happens there building, ok.
04:14:53 <zett_zelett1> … on join.
04:14:58 <Taneb> Aetherspawn, return?
04:15:02 <ocharles> mm_freak: what do you mean by "not counting on non accumulation?"
04:15:05 <Aetherspawn> :t (const return)
04:15:06 <lambdabot> Monad m => b -> a -> m a
04:15:12 <Aetherspawn> Not quite
04:15:12 <mauke> zett_zelett1: isn't join called η or something?
04:15:18 <Aetherspawn> it should be b -> m a -> m a
04:15:19 <ocharles> tomejaguar: that's a shame, but I also couldn't quite suss it
04:15:28 <Taneb> Aetherspawn, then id
04:15:30 <zett_zelett1> I think η is the unit, i.e. return.
04:15:37 <quchen> µ is join
04:15:41 <zett_zelett1> And join is commonly called μ, for "multiplication".
04:15:42 <mauke> oh, right
04:15:42 <zett_zelett1> Yes.
04:16:02 <zett_zelett1> Since it is somehow multiplicating the results together.
04:16:03 <Aetherspawn> :t (const (id :: m a))
04:16:04 <lambdabot>     Couldn't match type `m1' with `(->) a1'
04:16:04 <lambdabot>       `m1' is a rigid type variable bound by
04:16:04 <lambdabot>            an expression type signature: m1 a1 at <interactive>:1:9
04:16:13 <Aetherspawn> :t (const (id :: Maybe Int))
04:16:13 <lambdabot>     Couldn't match expected type `Maybe Int'
04:16:14 <lambdabot>                 with actual type `a0 -> a0'
04:16:14 <lambdabot>     In the first argument of `const', namely `(id :: Maybe Int)'
04:16:20 <Aetherspawn> oops.
04:16:24 <Aetherspawn> sorry, I'll take it into /msg
04:16:29 <Taneb> @type const (id :: Maybe a -> Maybe a)
04:16:30 <lambdabot> b -> Maybe a -> Maybe a
04:16:37 <zett_zelett1> Anyway, thanks, mauke! The part about what >>= really helped me understanding the IO monad better.
04:16:40 <Aetherspawn> oh yeah, forgot about htat.
04:16:45 <mauke> zett_zelett1: http://mauke.hopto.org/stuff/haskell/how-to-io.html
04:16:49 <Aetherspawn> thanks Taneb
04:17:06 <Taneb> Aetherspawn, no trouble
04:17:11 <zett_zelett1> Hey, I already skimmed over that once.
04:17:16 <Taneb> Although I'm curious why you need it?
04:17:18 <zett_zelett1> Time to take a look at it.
04:18:27 <tomejaguar> ocharles: Were you trying to use it for something?
04:19:18 <ocharles> tomejaguar: ish - just trying to find a nice interation of Applicative and wires
04:19:29 <ocharles> I want to foo <$> bar <*> baz - but bar and baz have different inputs
04:19:43 <ocharles> but I guess that doesn't even type check, now that I think about it :)
04:20:23 <quicksilver> I had similar problems with reactive
04:20:35 <quicksilver> there are some forms of composition which seem obvious but are fiddly to write
04:21:01 <quicksilver> (\x y -> foo x y) <$> behaviour_x <*> behaviour_y
04:21:21 <quicksilver> (where 'foo x y' is a more complicated expression than literally that)
04:21:36 <quicksilver> (\x y -> .. complex expression parametric in x and y ..) <$> behaviour_x <*> behaviour_y
04:21:41 <quicksilver> would have been better pseudo code
04:22:26 <zett_zelett1>  Okay, so do; x <- getChar; y <- getChar; return [x,y] is equivalent to getChar >>= (\x -> (getChar >>= (\y -> return [x,y]))), right?
04:22:53 <mauke> zett_zelett1: yes
04:23:03 <mauke> @undo do x <- getChar; y <- getChar; return [x,y]
04:23:03 <lambdabot> getChar >>= \ x -> getChar >>= \ y -> return [x, y]
04:27:23 <Athas> ...why is Text.Printf not identical to printf() from C?
04:27:26 <remdezx> Do you know any efficient shared memory implementations for Haskell? I would like to transfer big ammounts of data...
04:27:53 <mauke> Athas: because Haskell isn't C
04:28:14 <Athas> mauke: it's still silly to implement the format language with the same syntax but different semantics.
04:28:35 <frx> Athas what difference bothers you?
04:28:39 <Athas> Apparently the number-of-decimals argument to %f is interpreted in different ways.
04:28:48 <sipa> well implement a "better" ine than
04:28:52 <Aetherspawn> remdezx: That's an interesting thought.
04:29:21 <mauke> Athas: different how?
04:29:24 <Aetherspawn> I've done some work with shared memory in C/C++ before and the way we did it over there was using a huge shared buffer where you allocated your own stuff along it
04:29:25 <Athas> No, wait, actually %f in Haskell does not print trailing zeroes, while GNU libc seems to always print six decimals.
04:29:29 <frx> > printf "%.2f" 2.0
04:29:30 <lambdabot>  Could not deduce (Text.Printf.PrintfType t)
04:29:30 <lambdabot>    arising from the ambiguity check for `e_1220'
04:29:30 <lambdabot>  from the context (GHC.Real.Fractional a,
04:29:30 <lambdabot>                    Text.Printf.PrintfType (a -> t))
04:29:30 <lambdabot>    bound by the inferred type for `e_1220':
04:29:36 <Athas> That seems to be the difference.  How odd.
04:29:36 <frx> > printf "%.2f" 2.0 :: String
04:29:38 <lambdabot>  "2.00"
04:29:50 <Athas> > printf "%f" 1.0
04:29:50 <Aetherspawn> That's a cool idea. Someone could write a lib for sharing a mutable vector.
04:29:51 <lambdabot>  Could not deduce (Text.Printf.PrintfType t)
04:29:51 <lambdabot>    arising from the ambiguity check for `e_110'
04:29:51 <lambdabot>  from the context (GHC.Real.Fractional a,
04:29:51 <lambdabot>                    Text.Printf.PrintfType (a -> t))
04:29:51 <lambdabot>    bound by the inferred type for `e_110':
04:29:53 <mauke> Athas: gnu libc isn't C
04:30:05 <Cale> > printf "%f" 1.0 :: String
04:30:06 <lambdabot>  "1.0"
04:30:08 <Athas> mauke: right, I assume that GNU libc does the right thing here, but honestly I do not know.
04:30:17 <Cale> > printf "%4.2f" 1.0 :: String
04:30:18 <lambdabot>  "1.00"
04:30:22 <mauke> depends on your definition of "the right thing"
04:30:23 <Athas> Maybe the C spec doesn't say anything about this.
04:30:25 <Cale> > printf "%4.2f" 100000.0 :: String
04:30:27 <lambdabot>  "100000.00"
04:30:32 <mauke> the C standard says %f is equivalent to %.6f
04:30:42 <sipa> Text.Printf isn't Haskell eithet
04:30:45 <mauke> and that's what Text.Printf.Mauke does
04:30:48 <mauke> but Text.Printf disagrees
04:31:02 <frx> > printf "%10.2f" 1.0 :: String
04:31:04 <lambdabot>  "      1.00"
04:31:30 <mauke> long story short, use Text.Printf.Mauke
04:31:34 <remdezx> Aetherspawn: I tried memcached, but it is designed for small data chunks, less than 10MB. haskell-zeromq doesn't work on Windows and it won't be fixed as I see... Have you any ideas, what could I use?
04:32:05 <maxs`> Text.Printf' module description says "A C printf like formatter.". Note: "like"
04:32:24 <Athas> mauke: sounds good, I probably will.
04:32:29 <osa1> is there an extension for sharing type variables between main declaration and declarations in `where' parts?
04:32:37 <Aetherspawn> Windows doesn't seem too hard.
04:32:52 <maxs`> osa1: scoped type vars
04:32:55 <quicksilver> osa1: ScopedTypeVariables
04:32:55 <Aetherspawn> I'm even tempted to whip one together using MMap and named pipes, but I already have a project :(
04:32:59 <osa1> thank you
04:33:02 <Aetherspawn> No ideas, sorry.
04:33:05 <Aetherspawn> Do you know C?
04:33:15 <Aetherspawn> I can point you in the right direction for writing your own bindings
04:33:46 <Cale> osa1: Note, you'll need to explicitly forall the type variables in your top level type declaration for them to scope over the where clause
04:34:00 <zett_zelett1> :t \doA doA1 doA2 doA3 doA4 doB -> doA >>= \a -> doA1 >>= \a1 -> doA2 >>= \a2 -> doA3 >>= \a3 -> doA4 >>= \a4 -> doB
04:34:01 <lambdabot> Monad m => m a -> m a1 -> m a2 -> m a3 -> m a4 -> m b -> m b
04:34:07 <Cale> (this was presumably to avoid affecting existing code with that extension turned on)
04:34:08 <zett_zelett1> Hm.
04:34:39 <mauke> @do \doA doA1 doA2 doA3 doA4 doB -> doA >>= \a -> doA1 >>= \a1 -> doA2 >>= \a2 -> doA3 >>= \a3 -> doA4 >>= \a4 -> doB
04:34:39 <lambdabot> \ doA doA1 doA2 doA3 doA4 doB -> do { a <- doA; a1 <- doA1; a2 <- doA2; a3 <- doA3; a4 <- doA4; doB}
04:34:53 <mello_> can anyone explain the concept of a Lens?
04:35:03 <mauke> mello_: a getter/setter
04:35:41 <remdezx> Aetherospawn: Yes, I know C. It would be great to fix windows issue in zeromq-haskell, but noone knows how to fix it...
04:36:46 <Cale> mello_: Well, initially, lenses looked something like  data Lens a b = Lens { view :: a -> b ; set :: b -> a -> a }
04:37:09 <FliPPeh> @hoogle (Monad m, Monad m1) => m (m1 a) -> (a -> m (m1 b)) -> m (m1 b)
04:37:09 <lambdabot> No results found
04:37:39 <dario`> FliPPeh: what are you doing?
04:37:45 <quicksilver> an early blog post by twanvl_ is a good intro to the general idea
04:37:46 <FliPPeh> I don't know :(
04:37:49 <Aetherspawn> remdezx: Don't really need to touch zeromq
04:37:58 <mello_> Ah ok, that's odd but makes more sense. I'm trying to use data time calendar lens
04:38:01 <quicksilver> dario`: he's working in a nested monad without defining a monad instance for it.
04:38:07 * hackagebot twitter-types 0.1.20130101 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.1.20130101 (TakahiroHimura)
04:38:11 <quicksilver> dario`: IO (Either Blah a)
04:38:12 <Aetherspawn> Could just do something like here: http://msdn.microsoft.com/en-us/library/windows/desktop/aa366551(v=vs.85).aspx
04:38:16 <mello_> which uses Simple lens
04:38:18 <mello_> :t Simple
04:38:19 <lambdabot> Not in scope: data constructor `Simple'
04:38:35 <Aetherspawn> memory map it, then use Data.Vector.Internal.Mutable.unsafeFromForeignPtr to get a vector of the mmap region
04:38:53 <zett_zelett1> Silly question: Why has the symbol >>= has been chosen for bind? Just to look cool or does it have a meaning?
04:38:55 <Aetherspawn> ofcourse you'd need to throw around some #ifdefs for linux, osx and whatnot
04:38:57 <Aetherspawn> its a bit of a project...
04:39:09 <mello_> Ok, hackage reports: type Simple f a b = f a a b b, how the hell should I interpret that?
04:39:12 <Cale> mello_: Simple lenses are analogous to the sort I just described, in that they don't change the type of the structure by replacing the field with a new value of some different type (which sometimes makes sense)
04:39:13 <zett_zelett1> Maybe take the value of m a and put it into a?
04:39:24 <Aetherspawn> Does anyone know whether a vector made with unsafeFromForeignPtr0 can be resized?
04:39:28 <Aetherspawn> It'd be unsafe if it could be...
04:39:33 <Aetherspawn> Is there a way to freeze the size?
04:40:01 <remdezx> Aetherspawn: there is something like this (http://hackage.haskell.org/package/vector-mmap ), but it's a bit old and looks like no longer supproted
04:40:04 <mello_> Cale, ok makes sense. The calendar thingie seems to just act like a bridge between different date types if im correct
04:40:33 <mm_freak> ocharles: the session state should be accumulated for wires that may be resumed later
04:40:36 <Cale> mello_: The basic usage here is that you use  view l x  to use the lens l to extract a field from the structure x
04:40:44 <quicksilver> zett_zelett1: it's an arrow showing the direction of data flow. (getChar >>= putChar)
04:40:59 <zett_zelett1> Okay, thanks.
04:41:12 <quicksilver> zett_zelett1: I don't think there is any specific reason why >>= and not >>> or >=> or any number of other arrow-ish looking operators
04:41:16 <Cale> mello_: and  set l v x  to use the lens l to set a new value v in the field of x (obtaining a new structure)
04:41:20 <mm_freak> ocharles: otherwise you get some absurd time effects
04:41:32 <frx> there's also =<< that is >>= with flipped arguments.  putChar =<< getChar
04:41:42 <Aetherspawn> that looks like it would still work, but that'd be pretty hacky
04:41:48 <Aetherspawn> You'd need a package for making named pipes too
04:42:01 <mello_> Cale, thanks
04:42:01 <Cale> (Though for dates, I'm not sure it entirely makes sense to set like that, for the most part)
04:44:05 <remdezx> Aetherspawn: you mean named pipes for control? I have rpc already, so I need just some channel to transfer bigger data
04:44:42 <Cale> I would usually give a spiel about time and timezones and stuff, but this guy's thoughtfully put it on YouTube for me: http://www.youtube.com/watch?v=-5wpm-gesOY
04:45:07 <identity> zett_zelett1: It is purely because it is cool.
04:45:12 <Aetherspawn> sorry, I have to go, it's getting late. Your problem is an interesting one
04:45:27 <Aetherspawn> Actually, you're inspiring me to write a solution. Maybe in the morning. Seeya!
04:46:12 <remdezx> Aetherspawn: thanks! have a nice day! ;)
04:47:22 <augur> thank you Cale, and thank you hamid, i have finally got it :D
04:47:42 <augur> you've rubber ducked and pushed me in the right direction for what i wanted. :D
04:48:55 <hamid> augur, hmm me? is this for a week ago?
04:49:05 <augur> hamid: no, this is for your :t unfoldr earlier
04:49:15 <hamid> augur, oh ok then :D
04:49:21 <augur> which happened to end up reminding me of something i was forgetting about codata
04:49:32 <augur> and proved crucial to solving this problem
04:50:17 <hamid> augur, i happen to be an angle then :P
04:50:27 <augur> an angle?
04:50:54 <hamid> augur, yeah the messanger kind :P
04:50:59 <augur> oh, angel
04:51:12 <augur> angles are what triangles have!
04:51:28 <merijn> augur: And squares and any number of geometric shapes...
04:51:29 <identity> angles have radians and angels have radiance
04:51:31 <hamid> augur, lol :))
04:51:49 <identity> or so we're led to believe, anyway
04:52:20 <augur> merijn: triangels and quadrangels and ...
04:52:40 <identity> augur: deformed?
04:52:41 <augur> quadrilateral ~ quadriliturgical?
04:52:59 <hpc> quadrivertical!
04:53:06 <identity> quadriheretical
04:53:22 <zett_zelett1> If I have a monad, can I define its underlying functor by fmap f = \x -> x >>= return . f?
04:53:40 <hpc> online quadriplayer
04:53:45 <merijn> zett_zelett1: Yes
04:53:49 <zett_zelett1> Nice!
04:54:05 <merijn> zett_zelett1: I believe there's even a newtype for that already
04:54:12 <hpc> zett_zelett1: or more briefly, fmap = liftM
04:54:32 <hpc> you can do the same for applicative, pure = return, (<*>) = ap
04:54:49 <zett_zelett1> Okay.
04:54:51 <zett_zelett1> Great, thanks.
04:55:03 <hpc> ooh, there's a newtype for it
04:55:06 <hpc> TMYK
04:55:35 <merijn> WrappedMonad, that's the one I'm thinking of
04:56:39 <augur> Cale: codata motivates a distinction between case and (co)recursion i think, since colists arent strictly infinite, and thus ought to be cased on at times, i think, maybe?
04:57:22 <Cale> They can be, sure
04:57:24 <augur> certainly the functor that the nu type wraps can be cased on, so if you have native, rather than nu-based, codata, you need some kind of casability
04:58:04 <augur> i mean, since    out :: nu a. F -> F[nu a. F / a]
04:58:37 <Cale> augur: For instance, turning a colist into a conat by length will typically be expressed with case
04:58:46 <augur> out m can be cased on, so it ought to be possible to case on colists if they're native, rather than implemented as   nu a. 1 + X * a
04:59:01 <Cale> In Agda, it looks like this: http://www.cse.chalmers.se/~nad/listings/lib-0.7/Data.Colist.html#1994
04:59:06 <augur> yeah
04:59:25 <augur> the trick tho is making sure that the type-theoretic presentation works, if you're avoiding nu
04:59:42 <Cale> There's a cute example there of take
04:59:51 <hpc> . o O (agda missed a perfect opportunity to define codata as "nutype" and confuse everyone)
05:00:12 <augur> hpc: :)
05:00:18 <Cale> take : ∀ {a} {A : Set a} (n : ℕ) → Colist A → BoundedVec A n
05:00:30 <augur> if you pronounce it like a greek, it wont confuse anyone at all!
05:00:34 <augur> nütype
05:01:21 <Cale> It's odd that they don't define iterate in Data.Colist there
05:01:33 <augur> Cale: my aim is to have a general understanding of (co)data types that are primitive, as opposed to derived by fixed point combinators
05:02:28 <augur> Cale: in the same way that you can define Nat native as     ===>  G !- ze : Nat    G !- M : Nat  ===>  G !- suc M : Nat
05:03:16 <augur> with the recursor   G !- M : Nat   G !- Z : X   G, r : X !- S : X   ===>   G !- natrec(M, Z, r.S) : X
05:03:48 <augur> no mu type needed for that, so no uncontrolled explosion of available types
05:04:01 <augur> but how do you define conat? such is the question
05:04:45 <augur> defining strictly infinite data is easy, but potentially finite data is harder.
05:05:20 <augur> solving it tho i think really does require _both_ case and (co)recursors, and also curiously, this means that scott and church encodings are _not_ alternatives
05:06:57 <augur> while you can get nats, say, wit scott + Y-combinator, or something like this, the full picture of finite-possfinite-infinite data requires scott _and_ church (and co-church?) encodings
05:08:00 <augur> which i thing is especially beautiful. i take it to be an indication of the correctness of this route.
05:08:20 <Cale> I'm not sure that's true.
05:08:35 <Cale> But I don't know enough about how the details work
05:08:52 <augur> Cale: im going to write something up eventually. :)
05:08:56 <hpc> i need to read up on scott encodings...
05:09:01 <Cale> It seems like it might be worth looking at how Agda's infinity/sharp/flat things work
05:09:03 <augur> hpc: scott encodings = case
05:09:43 <augur> Cale: i want to avoid adding more judgments just for corecursion. what i want is for the mu architecture to just work right away for its dualization to nu types
05:09:47 <augur> and it does
05:10:01 <Cale> It doesn't look like Agda needs any special catamorphism-like things, only matching and corecursion.
05:10:07 <hpc> augur: yeah, i got that from the wikipedia article; i just need to get in my brain the knowledge of what goes in what lambda, etc
05:10:19 <hpc> examples, as it were
05:10:24 <augur> Cale: indeed, but agda also has general recursion based on variable binding
05:10:33 <augur> Cale: as opposed to recursor-based recursion
05:10:43 <bennofs> Is there a library for searching in strings in haskell?
05:11:01 <hpc> bennofs: a few, depending on what you need
05:11:04 <FreeFull> There is regex
05:11:08 <hpc> for a simple string, isInfixOf will work
05:11:11 <FreeFull> And probably other stuff too
05:11:13 <augur> Cale: it therefore can avoid many tricky problems by just coding all recursion directly in self-referential declarations
05:11:18 <Cale> "ell" `isInfixOf` "Hello"
05:11:22 <Cale> > "ell" `isInfixOf` "Hello"
05:11:23 <lambdabot>  True
05:11:24 <FreeFull> isInfixOf is the simplest option
05:11:24 <augur> hpc: the cases!
05:11:31 <hpc> regex if you actually want regular expressions
05:11:50 <Cale> > findIndex (isPrefixOf "ell") (tails "Hello")
05:11:51 <lambdabot>  Just 1
05:12:00 <bennofs> @index findIndex
05:12:00 <lambdabot> Data.List, Data.Map
05:12:07 <bennofs> @ty findIndex
05:12:07 <lambdabot> (a -> Bool) -> [a] -> Maybe Int
05:12:08 <Komier> Doesn't Data.List have quite a functions for searching strings?
05:12:11 <augur> hpc: consider the total case exp for   data Nat = Zero | Suc Nat   case n of { Z -> z ; Suc n -> s }
05:12:14 <hpc> if you want to search within a levenshtein distance, i /think/ there's one for that too
05:12:27 <hpc> (and if not there should be)
05:12:29 <augur> z has no new variables for it, s has n available for it
05:12:31 <bennofs> is there something simple for Text?
05:12:46 <hpc> bennofs: simple, isInfixOf
05:13:01 <hpc> which does have an implementation for Text
05:13:08 <augur> hpc: so you can define instead:   caseNat Zero z s = z ; caseNat (Suc n) z s = s n
05:13:20 <bennofs> hpc: ok, thanks
05:13:38 <bennofs> when was decodeLatin1 added to text?
05:13:55 <augur> hpc: now you just define your scott encoding of Zero to be   caseNat Zero   and your scott encoding of Suc n to be   caseNat (Suc n)
05:14:27 <augur> hpc: ie:   scottZero = \z s -> z   ;   scottSuc n = \z s -> s n
05:15:36 <hpc> that doesn't seem like it would have trouble with codata, but i am not very smart in that paticular part of theory
05:15:42 <augur> hpc: it doesnt
05:16:03 <mello_> could someone explain this signature?
05:16:03 <augur> scott encodings seem to be useful for both data and codata
05:16:04 <mello_> type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
05:16:20 <mello_> type is a type synonym right, but what's up with the forall f.?
05:16:26 <augur> mello_: oh dear no. you're going to need to read a bunch of stuff to grok that. lemme see if i have a tutorial somewhere
05:16:49 <hpc> church doesn't seem like it would have trouble either, but that might be the lazy evaluator in my brain speaking
05:17:11 <augur> hpc: right, it requires lazy evaluation
05:17:17 <mello_> augur,  that would be very helpful, basically i've read practically the whole learn you a haskell book, but there nothing more than type as in type String = [Char] is explained
05:17:31 <augur> and then everything is codata i think? i dont know
05:17:48 <hpc> anyway, they seem the same to me
05:17:57 <augur> hpc: also, at a type-theory level, you dont use encodings, you use native stuff
05:17:57 <mello_> augur,  I tried reading http://comonad.com/reader/2012/mirrored-lenses/ but I seem to be missing something to get it
05:18:03 <merijn> mello_: The problem is that this uses higher rank polymorphism, which requires a GHC extension. LYAH is really only beginner haskell, this is more heading into intermediate territory
05:18:16 <hpc> in both cases, ω = \f x -> f (f (f (f (f ...
05:18:25 <Cale> mello_: First of all, imagine that f is the identity functor. Then a Lens a b c d is a function which takes some way of turning something of type c into something of type d, and uses that on something of type a to get something of type b
05:18:56 <arach_> is there an extension that declares Show instance for all functions?
05:19:05 <Cale> mello_: i.e. if f = id, then our Lens a b c d specialises to (c -> d) -> a -> b
05:19:09 <hpc> arach_: there's a module that does, but it's not very useful
05:19:21 <hpc> you can't inspect a function, so all it does is print the type
05:19:38 <hpc> which is static, so you should know it at compilation, which means you should know it just reading the code
05:19:39 <arach_> that is what i want it to do
05:19:45 <Cale> mello_: So, that gives us a general way of *replacing* the field of type c with something of type d in a structure of type a to get a structure of type b.
05:19:47 <augur> mello_, Cale, merijn: ok, i found my lens tutorial thing
05:19:52 <hpc> i forget what module it's in
05:19:57 <hpc> > succ :: Int -> Int
05:19:59 <lambdabot>  <Int -> Int>
05:20:06 <hpc> but lambdabot has it
05:20:08 <arach_> hpc knowing it does not let me print it
05:20:09 <augur> that tries to derive lenses from Store. lemme upload it
05:20:21 <Cale> mello_: Secondly, we could try taking f to be a constant functor which always gives (a type isomorphic to) c
05:20:26 <bennofs> about lenses, there is also http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation
05:20:27 <merijn> mello_: (With understanding the source of lens of being more of advanced to really advanced haskell)
05:20:41 <Cale> mello_: then our lens is essentially something of type (c -> c) -> a -> c
05:21:04 <arach_> > foldr
05:21:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
05:21:05 <lambdabot>    arising from a use of `M55188061783391751063694.show_M55188061783391751063...
05:21:05 <lambdabot>  The type variable `b0' is ambiguous
05:21:05 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
05:21:05 <lambdabot>  Note: there are several potential instances:
05:21:11 <Cale> mello_: applying that to the identity function will then do the right thing to extract the field of type c
05:21:23 <augur> mello_, Cale, merijn: http://purelytheoretical.com/programming/Lenses.hs
05:21:33 <Cale> mello_: So there really is a setter and getter in there, it's just a little bit weird :)
05:21:44 <akegalj> i have "<div>a<span>b</span></div>" how can i get "a<span>b</span>" using http-conduit?
05:22:31 <Cale> mello_: But in addition to that, you also get things like (c -> Maybe d) -> a -> Maybe b
05:22:33 <hpc> arach_: i am having trouble finding it, but i know lambdabot has it, so you can try looking through those depends yourself maybe?
05:22:35 <augur> probably i shouldntve used unzipFst and unzipSnd as separate things. oh well.
05:22:41 <Cale> mello_: and  (c -> IO d) -> a -> IO b
05:23:04 <arach_> > foldr :: (b -> a -> a) -> a -> [b] -> a
05:23:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
05:23:05 <lambdabot>    arising from a use of `M56707130577660252343703.show_M56707130577660252343...
05:23:05 <lambdabot>  The type variable `a0' is ambiguous
05:23:05 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
05:23:05 <lambdabot>  Note: there are several potential instances:
05:23:12 <arach_> I will try
05:23:26 <merijn> arach_: It can only print non-polymorphic functions
05:23:28 <hpc> and yeah, a function needs to be monomorphic in order to decide an instance
05:23:36 <hpc> unfortunately
05:23:38 <arach_> oh
05:23:46 <Cale> (as special cases of any lens)
05:23:49 <hpc> if you need polymorphism, try TH maybe?
05:23:54 <arach_> is that implementation issue or?
05:24:02 <augur> Cale, merijn, edwardk: comments on that would be useful. hopefully mello_ can gain some insight from it tho. its just a summary of how i came to understand what little i understand about modern lenses
05:24:07 <hpc> yeah, it's part of how type classes work
05:24:19 <mello_> Cale, that explanation makes sense :), i'll try to make some sense of it
05:24:29 <hpc> with template haskell you would be able to show a polymorphic function, but it would be at the cost of ugly syntax
05:24:29 <mello_> augur, thanks i'll read that material
05:24:39 <hpc> and having to write it yourself, because i don't know of an existing implementation
05:24:49 <augur> mello_: ill probably be awake all day, so feel free to ask questions
05:25:13 <merijn> mello_: If you understand the notion of "Lens a b" then you can suffice with the realisation that "Lens a b c d" has two extra parameters to allow for polymorphic updates and then focus on the "simple" idea of lens
05:25:15 <augur> Cale: we should write a book! :X
05:25:45 <Hodapp> you must first write 10 blog posts that all explain different monad analogies.
05:25:49 * Hodapp laughs maniacally
05:25:49 <augur> Cale: a nice compilation of good tutorials on interesting techniques in haskell. lenses, Fix types, who knows what!
05:25:51 <hpc> anyway good luck; you're getting into a fairly tricky thing to make work
05:25:53 <osa1> duh ... Expected type: [(T.Text, HI.Splice IO)] Actual type: [(T.Text, HC.Splice IO)]
05:26:09 <osa1> sorry, wrong channel
05:26:20 <mello_> what i still dont understand and forgive me my stupidity; is that you have multiparameter types right, like Lens a b, but you don't need a language extension for that? At least, I thought you needed functional dependencies to solve that problem?
05:26:24 <arach_> lambdabot: has so many dependencies
05:26:44 <merijn> mello_: How so?
05:26:53 <merijn> mello_: That's only for multiparameter typeclasses
05:26:55 <bennofs> mello_: type aliases (type A b c = ...) don't need an extension if they have multiple parameters
05:27:06 <Cale> mello_: Haskell has always had types with many parameters
05:27:24 <augur> oh also maybe keep in mind, i dont think i try to run anything i wrote :X
05:27:30 <mello_> okay i guess merijn's pointing at what's confusing me
05:27:31 <augur> lemme do that now :X
05:27:44 <augur> i think i have some typos/type errors
05:27:50 <augur> oh no, i guess i dont. huh!
05:27:57 <Cale> mello_: Another useful thing to stare at is how you might define a lens for a simple datatype like pairs. You might want to define first :: Lens (a,b) (a',b) a a', which means that first :: forall f. (Functor f) => (a -> f a') -> (a,b) -> f (a',b)
05:28:10 <augur> maybe i did run it. hooray!
05:28:17 <merijn> mello_: Typeclasses need those because I can have both an instance "Foo Int a" and "Foo Int Char" and since "Foo Int a" could be "Foo Int Char" the compiler needs to pick which class applies
05:28:22 <Cale> So...
05:28:30 <Cale> first f (x,y) = ...
05:28:43 <merijn> mello_: For concrete datatypes that situation can never occur. A value's type only depends on its definition + what's inside
05:29:14 <ocharles> mm_freak: ok, but I have a vector of events so that should be getting accumulated anyway
05:29:27 <Cale> So, if we apply f to x we'll get some f a'
05:29:28 <merijn> mello_: Consider a tuple "(a, b)" that already has multiple parameters (it's similar too "data Tuple a b = Tuple a b"))
05:29:32 <ocharles> or i'm not following you
05:29:38 <Cale> and we want to turn that into an f (a',b)
05:29:40 <mm_freak> ocharles: not with Reader
05:29:50 <mello_> ok, thanks, both Cale and merijn, sorry if i don't answer to everything you say, it's just slowly percolating into my brain ;)
05:29:52 <Cale> So, we fmap over that a function which rebuilds the rest of the structure around that
05:30:01 <ocharles> mm_freak: right, i'm using a Session not Reader for this
05:30:06 <allsystemsarego> Hi all, can anyone give an example for how to utilize the zoom function (from Lens), that doesn't involve the State monad?
05:30:15 <mm_freak> ocharles: that might lead to surprising results
05:30:22 <Cale> first f (x,y) = fmap (\x' -> (x',y)) (f x)
05:30:30 <ocharles> it's those surprising results that i'm trying to understand :)
05:30:46 <mm_freak> ocharles: in w1 <|> w2, let w1 produce for an hour
05:30:57 <augur> i should really modify that tutorial a bit before i do something with it
05:31:00 <mm_freak> then after an hour, w2 will receive all past events in a single instant
05:31:05 <augur> it has deficiencies that are clear to me now
05:31:18 <Cale> mello_: Abstractly, you can look at (\x' -> (x',y)) as being like the original structure (x,y) with a hole blown out where the first component was
05:31:25 <ocharles> mm_freak: woah, really? but that would mean w2's initial delta was an hour too?
05:31:27 <mm_freak> ocharles: moveover to w2 it will look like all those events were simultaneous
05:31:41 <mm_freak> ocharles: or it never received an initial delta to begin with
05:31:47 <Cale> mello_: and then (f x) as being the changed piece which is going to fill that hole
05:32:20 <mm_freak> ocharles: consider this example:  for 86400 <|> w
05:32:33 <mm_freak> this wire acts like identity for a day, then switches to w
05:32:38 <Cale> mello_: and that gives us a lens  first  which we can use to extract and change the first component of a pair
05:32:46 <mm_freak> at that point w will receive an accumulation of all state deltas
05:32:52 <kuribas> What module has MonadIO?
05:33:08 <ocharles> mm_freak: ok, i had no idea inhibition and sessions worked like that
05:33:12 <merijn> kuribas: Control.Monad.Trans, I believe
05:33:14 <allsystemsarego> @hoogle MonadIO
05:33:14 <lambdabot> Network.CGI class Monad m => MonadIO (m :: * -> *)
05:33:14 <lambdabot> Control.Monad.IO.Class class Monad m => MonadIO m
05:33:14 <lambdabot> package monadIO
05:33:16 <mello_> merijn, see i already confused type classes with data types, so yeah... got a long way to go ;)
05:33:36 <mm_freak> ocharles: to w it will look like the last frame to a whole day, and all the events in that day will look like simultaneous events, because to w that one day is indivisible
05:33:41 <kuribas> ok thanks
05:33:47 <mm_freak> s/to/took/
05:34:15 <arach_> anyone knows what module lambdabot uses to print functions? I tried tracking it down myself but it has like 50 dependencies
05:34:25 <mm_freak> ocharles: that's the motivation for separate state deltas…  without that semantics i could have just used Reader from the beginning =)
05:35:49 <bennofs> @hackage show
05:35:49 <lambdabot> http://hackage.haskell.org/package/show
05:35:50 <ocharles> mm_freak: hmm, i'll have to chew on that then
05:36:01 <bennofs> arach_: ^^
05:36:27 <arach_> ah thanks!
05:36:34 <bennofs> arach_: note that there is also Text.Show.Functions in base
05:36:44 <absence> is there a package with a free monoid class?
05:37:01 <mm_freak> ocharles: in general, use state deltas only for time
05:37:03 <arach_> bennofs: why doesnt lambdabot use that then?
05:37:24 <arach_> does it have less functionality?
05:37:38 <mello_> Cale, thank you! I'm not there yet to fully understanding but you're giving me a head start at the least. I will save your example so i can reread that later
05:37:48 <Cale> mello_: cool
05:37:55 <bennofs> arach_: It only shows <function>, no matter what type the function has
05:38:03 <bennofs> > (+) :: Int -> Int -> Int
05:38:03 <arach_> ah
05:38:04 <lambdabot>  <Int -> Int -> Int>
05:38:24 <augur> Cale: we should totally write something awesome
05:38:28 <mm_freak> ocharles: or for other stuff that should not be missed by suspended wires
05:39:16 <ocharles> mm_freak: alright, so SDL events need to move back to Reader
05:39:19 <arach_> hmm, documentation for ShowFun module is empty http:/​/​hackage.haskell.org/​package/​show-0.6/​docs/​ShowFun.html
05:39:21 <ocharles> (probably)
05:39:31 <mm_freak> ocharles: most likely yeah
05:40:13 <arach_> @hackage show
05:40:13 <lambdabot> http://hackage.haskell.org/package/show
05:41:04 <Cale> Edward and I were going to work on a book, but we never really got much done. For a long time I've felt like the space of introductory books has been missing something.
05:41:20 <ocharles> mm_freak: i'll read the source and try and give you a documentation patch
05:41:39 <ocharles> mm_freak: unless you feel this will change
05:41:46 <arach_> can i get a list of available functions in a module in ghci?
05:41:57 <Cale> :browse
05:42:34 <mm_freak> ocharles: well, without intention netwire became an API experiment as well as an FRP framework =)
05:42:48 <frx> arach_ it probably just defines a Show instance for function
05:42:59 <frx> without exporting anything
05:43:00 <mm_freak> so i'm always open to suggestions, but you could have to wait for another major version for breaking changes =)
05:43:05 <augur> Cale: well, let's fill the missing space!
05:43:42 <arach_> it works, cool!
05:44:06 <augur> i want to write something collecting up a bunch of explanations that i wish i had from the outset, or whatever. thinks like what hpc and i were discussing about how scott/church encodings "make sense", or lenses work, or whatever
05:44:24 <arach_> if only it worked with typeclasses too, it would be perfect
05:45:11 <augur> also probably it'd be good to have something that explains how to formally reason about various things. like, if you wanted to "invent" the Y combinator from first principles, how could you do it and what's the rational behind it, etc.
05:45:15 <ocharles> mm_freak: heh. well i do feel netwire is under documented - so it's up to you if you want to make it more stable with docs
05:45:48 <augur> that would just be an exercise in lambda-calc reasoning, but its something that i think is useful to know how to do
05:46:38 <solarus> arach_: if you do :info Class or :i Class you get all functions and all instances of that typeclass
05:46:59 <mm_freak> ocharles: i agree, the last version was a better example of good docs…  patches always welcome =)
05:47:19 <arach_> solarus: good to know
05:47:52 <ocharles> mm_freak: i'm more saying i don't want to write docs that you expect to be deprecated in a week :)
05:48:03 <mm_freak> ocharles: oh, don't worry about that
05:48:24 <mm_freak> netwire won't change a lot in the near future
05:48:43 <ocharles> ok, great :)
05:54:35 <merijn> arach_, solarus: All functions and instances *in scope*
05:58:16 * hackagebot rascal 1.1.4 - A command-line client for Reddit  http://hackage.haskell.org/package/rascal-1.1.4 (soli)
05:59:46 <iainm> Hello. I have a possibly-ill-formed question.
06:00:55 <iainm> Is there anything that can be expressed with a monad that can't be expressed with a free monad? with a free monad plus a suitable interpreter?
06:02:35 <dwcook> iainm, this might be a kind of vague answer: Types express things, monads as a whole do not.
06:02:55 <dwcook> Monad is an interface for working with several types. But it's the individual type that determines what data is represented.
06:03:10 <dagano> what is a less ugly way to do the following :?
06:03:14 <dagano> > let digits = map (\x -> (fromEnum x) - (fromEnum '0')) . show
06:03:15 <lambdabot>  not an expression: `let digits = map (\x -> (fromEnum x) - (fromEnum '0')) ....
06:03:25 <dagano> @let digits = map (\x -> (fromEnum x) - (fromEnum '0')) . show
06:03:26 <lambdabot>  .L.hs:143:55:
06:03:26 <lambdabot>      No instance for (Show a0) arising from a use of `show'
06:03:26 <lambdabot>      The type variable `a0' is ambiguous
06:03:26 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
06:03:26 <lambdabot>        digits :: a0 -> [Int] (bound at .L.hs:143:1)
06:04:13 <frx> dagano try using let ... in syntax
06:05:04 <iainm> dwcook, I shall mull that over for a while
06:05:06 <augur> i wonder
06:05:30 <augur> does haskell factor out obviously non-effectful constant occurrences?
06:06:03 <dagano> frx: hurhm?
06:06:11 <augur> e.g. would it turn dagano's digits definition into   digits = let aux = fromEnum '0' in map (\x -> fromEnum x - aux) . show
06:06:36 <augur> or does haskell not try to make such optimizations? it seems like its the sane thing to do
06:07:00 <merijn> augur: GHC does sometimes do it, but it's hard to determine
06:07:33 <arach_> i dont get IO :/
06:07:41 <merijn> augur: Various related terms: constant folding, constant elimination, super compilation, etc.
06:07:50 <mauke> arach_: do you know javascript?
06:08:03 <merijn> arach_: Read this explanation? http://blog.jle.im/entry/the-compromiseless-reconciliation-of-i-o-and-purity
06:08:03 <arach_> mauke no
06:08:07 <funfunctor> hi, why would I get a warning from doing 4*10^6 ? "(Integral b0) arising from use of `^'
06:08:15 <augur> merijn: yeah
06:08:20 <mauke> funfunctor: because it doesn't know the type of 6
06:08:46 <arach_> does javascript have something resembling IO?
06:08:48 <funfunctor> Ah, umm why can't it infer it here?
06:08:51 <mauke> arach_: yes
06:08:58 <arach_> what?
06:09:06 <mauke> ajax
06:09:56 <funfunctor> how do I 'fix it' :p ?
06:10:32 <funfunctor> I thought of using 'where' but seems very messy for something so simple
06:14:02 <donri> :t let it = fix it in fix it
06:14:03 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
06:14:03 <lambdabot>     In the first argument of `fix', namely `it'
06:14:03 <lambdabot>     In the expression: fix it
06:15:31 <funfunctor> lol
06:16:25 <donri> funfunctor: are you getting an error or a warning?
06:16:32 <funfunctor> well, to give more constraint, how do I get ghc to shutup about simply doing 4*10^6
06:16:37 <kuribas> What's wrong here? http://lpaste.net/97927
06:16:44 <funfunctor> its a warning, its not fatal however I am interested..
06:16:47 <donri> > 4*10^6
06:16:49 <lambdabot>  4000000
06:17:00 <mauke> > 4 * 10 ^ (6 :: Int)
06:17:01 <lambdabot>  4000000
06:17:03 <donri> funfunctor: is it saying something about defaulting?
06:17:06 <funfunctor> sure, I would like to keep it in the form
06:17:07 <funfunctor> ah ok
06:17:12 <funfunctor> yes donri
06:18:05 <funfunctor> thanks mauke, I forgot that syntax
06:18:30 <kuribas> http://lpaste.net/97927
06:18:38 <funfunctor> Haskell's grammar is so rich for a dyslexic :p
06:18:41 <donri> yes inline type annotation or, i think, default (Int) will silence the warning (not sure)
06:19:10 <donri> i *think* it only warns for implicit defaulting, but i could be wrong
06:19:23 <kuribas> Doesn't modify work through the ErrorT monad?
06:19:50 <donri> kuribas: with mtl yes, not with transformers
06:20:03 <donri> kuribas: with transformers you need to `lift` manually
06:20:03 <kuribas> hm, I see
06:20:10 <kuribas> So mtl is better?
06:20:34 <donri> mtl is different :)
06:20:44 <Taneb> kuribas, mtl builds on transformers with GHC-specific fanciness
06:20:56 <Komier> Anyone else find auto-complete annoying?  Or is it just me? :-/
06:21:09 <bennofs> Komier: what auto-complete? :O
06:21:16 <kuribas> Taneb: Ah, I see.
06:21:26 <Komier> in an editor... autocomplete, intellisense, whatever you want to call it.
06:21:30 * kuribas likes GHC fanciness
06:21:56 <donri> transformers is more portable, less magical, and makes it straight-forward to use the same transformer more than once in a stack. mtl makes code less verbose and often easier to write, reuse and refactor.
06:22:49 <kuribas> Is portability an issue, when GHC is pretty much standard?
06:23:20 <donri> not an issue. fay comes to mind but i don't think it even compiles transformers.
06:23:34 <philed> Fay doesn't support type-classes, does it?
06:23:37 <Taneb> There's Fay, UHC, ajhc...
06:23:53 <Taneb> For most people it's not an issue
06:24:08 <donri> philed: in deed, though transformers doesn't rely on type classes, but monads do, and transformers are monads.
06:24:51 <bennofs> Komier: I don't use any auto-completion, so I don't find it annoying :P
06:24:55 <donri> well, ErrorT relies on a type class
06:25:12 <kuribas> I am making an App, not a library, so portability doesn't matter for me.
06:25:42 <Komier> bennofs : neither do I as of 5 minutes ago :D
06:26:16 <donri> Komier: are autocompletions completions that happen without user input? that'd be annoying yes.
06:26:41 <donri> explicit completions are nice to have when they work properly
06:27:42 <Komier> donri: The ones where you start typing, it gives you options and you have to tab through them before you hit return, or hit space first.  I find myself hitting return at the end of a line and the damn thing completes the wrong word. lol
06:27:56 <funfunctor> :t take
06:27:57 <lambdabot> Int -> [a] -> [a]
06:28:07 <bennofs> Really? I found I rarely use explicit autocompletions, as typing the full name is often faster
06:28:15 <funfunctor> Is there a take that has Integer type?
06:28:25 <donri> explicit autocompletions? wat
06:28:33 <donri> i meant explicit as the opposite of automatic :)
06:28:46 <bennofs> yeah, typo :p
06:28:46 <geekosaur> :t genericTake
06:28:47 <lambdabot> Integral i => i -> [a] -> [a]
06:29:05 <fizbin> :t take
06:29:06 <lambdabot> Int -> [a] -> [a]
06:29:15 <eikke> :t takeThat
06:29:16 <lambdabot> Not in scope: `takeThat'
06:29:21 <donri> Komier: what editor?
06:29:27 <fizbin> :t toInt
06:29:28 <lambdabot> Not in scope: `toInt'
06:29:41 <Komier> donri : sublime text 2, witht he sublime haskell plugin at the moment.
06:29:51 <donri> ok don't know how it works there
06:30:01 <donri> is there no option to have completions only when asked for?
06:30:11 <donri> like if you press tab or ctrl-space or whatever
06:30:19 <philed> What potential autocompletes are in scope in Sublime Text? Just whatever you've imported?
06:30:20 <prasadi> Hi !  I'm getting an error when I try to execute the following piece of code data MyException = FileDownloadException | ThatException deriving (Show, Typeable)  instance Exception MyException  May I know what it is about ?
06:30:52 <fizbin> "an error" - what's the error?
06:30:54 <eikke> prasadi: it helps to say which error you get
06:31:15 <prasadi> It says it cannot create an instance of MyException since MyException is of Typeable
06:31:35 <Komier> I'm not entirely sure, still new at this myself.  Looking through the options now.
06:32:12 <prasadi> It says MyException has to be of  -XDeriveDataTypeable in order for it to create an exception
06:32:53 <Komier> I don't know how to use Emacs or Vim so need to make Sublime comfortable :D
06:33:04 <eikke> prasadi: no, it says you need to enable the DeriveDataTypeable extension. Use "ghc -XDeriveDataTypeable ..." to compile, or put {-# LANGUAGE DeriveDataTypeable #-} on top of your module
06:33:30 <prasadi> I'm doing this on windows
06:33:47 <prasadi> so, ghc -XDeriveDataTypeable is not possib;e
06:33:52 <geekosaur> yes it is
06:34:07 <geekosaur> butthe second one is generally preferred anywya
06:34:15 <prasadi> Is that  a comment ?
06:34:42 <geekosaur> what?
06:34:53 <geekosaur> are you as good at reading IRC as you apparently are at reading error messages?
06:34:56 <prasadi> can you add it here ? http://lpaste.net/2742909253600673792
06:35:16 <fizbin> The line {-# LANGUAGE DeriveDataTypeable irc://irc.freenode.net:6667/#-}  uses the comment syntax, technically, but {-# introduces a compiler direction.
06:35:56 <fizbin> Add the line {-# LANGUAGE DeriveDataTypeable #-}  at the top.
06:36:06 <geekosaur> {-# ... #-} is a pragma. it looks comment-ish so that compilers that use some other pragma mechanism can ignore it
06:36:16 <geekosaur> (or that implement only the standard)
06:36:24 <donri> Komier: i'd strongly suggest investing some time and effort into learning emacs or vim, but of course in the end it's up to you ;)
06:37:28 <prasadi> like this ? http://lpaste.net/2742909253600673792
06:37:46 <geekosaur> it goes at the very top
06:37:56 <fizbin> Usually, pragmas go above even import statements.
06:38:41 <prasadi> Thank you ! it works
06:39:00 <Komier> donri: quite a few people have said that :)
06:40:22 <tero-> donri: but which one has better support for haskell? :)
06:40:36 <donri> tero-: emacs
06:40:57 <lingxiao> could someone familiar with "call by name" evaluation strategy of lambda calculus explain to me what this rule means:
06:41:06 <lingxiao> "The call by name strategy is yet more restrictive, allowing no reductions inside abstractions. "
06:41:19 <ivanm> juhp: still around?
06:41:33 <tero-> donri: I've been using vim so far and wondering whether it pays off to switch to emacs
06:41:35 <lingxiao> I am confused because aren't all terms in simple lambda calculus lambda abstractions?
06:41:49 <mauke> lingxiao: no, some are applications or variables
06:42:20 <donri> tero-: i'm a vimmer too, but i think emacs is the superior technology
06:42:25 <lingxiao> mauke: right so t = x | λx.t | tt
06:43:03 <donri> tero-: and you can reap at least some of the benefits of vim's superior paradigm using evil-mode or god-mode
06:43:08 <lingxiao> the example i'm looking at reduces `id (id (λz. id z))`
06:43:15 <lingxiao> to `id (λz. id z)`
06:43:19 <companion_cube> lingxiao: some terms are variables or applications
06:43:26 <tero-> donri: ok. good to know
06:43:30 <mauke> yeah, that's outermost first reduction
06:43:33 <companion_cube> so you can reduce an application that is not in an abstraction
06:43:38 <mauke> 'id z' is inside an abstraction
06:44:27 <lingxiao> but couldn't `id` be re-expressed as `λx.x`, so `id (id (λz. id z))` becomes `λx .(id (λz. id z))`
06:44:41 <mauke> no
06:44:54 <mauke> it becomes (λx.x) (id (λz. id z))
06:44:57 <lingxiao> or oops, `(λx.x)(id (λz. id z))`
06:45:18 <lingxiao> yeah sorry, typo, ahh and that's of form `tt` so you can reduced it
06:45:20 <mauke> and then you can beta
06:46:08 <lingxiao> now is there a reason one would not want to beta reduce terms inside a lambda abstraction?
06:46:18 <lingxiao> so far in the reading, the book does not provide a reason
06:46:39 <mauke> generally speaking, not all evaluation orders may terminate
06:48:11 <lingxiao> mauke: sorry could you expand on that? is the goal to pick an evaluation strategy that always terminate over the universe of terms?
06:48:14 <companion_cube> lingxiao: when all terms have a normal form, reducing under a abstraction gives you this normal form
06:48:20 <companion_cube> e.g. in coq
06:49:02 <mauke> (λa.λb.a) (λx.x) (λz.(λx.xx) (λx.xx))
06:49:04 <lingxiao> what does "this" refer to when you say "this normal form"
06:49:54 <companion_cube> lingxiao: well, sorry, in coq every term has a unique normal form (confluence + termination), so the reduction strategy is designed to evaluate into this unique normal form
06:50:19 <companion_cube> untyped lambda calculus is confluent, but not terminating, which means that not all terms have a normal form
06:51:38 <lingxiao> mauke: so you're saying there's no point in evaluating the third term (is it called omega?) when `λa.λb.a` is only going to pick out the first term?
06:53:08 <donri> Komier: http://yehudakatz.com/2010/07/29/everyone-who-tried-to-convince-me-to-use-vim-was-wrong/  should be applicable to emacs too
06:53:58 <Komier> lol ty :)
06:54:24 <Komier> Well i have it installed and I think the major haskell mode is working.  That's a start I guess :D
06:55:42 <lingxiao> companion_cube: thanks! I wish I knew more about Coq to fully apreciate your answer but I'll save it for later reference
06:58:02 <allsystemsarego> it seems like http://tunes.org/~nef/logs/haskell/ no longer hosts this channel's logs
06:58:51 <Komier> donri: oki doki I'm starting to see the appeal here.
06:59:15 <ocharles> allsystemsarego: ircbrowse.net is the suggested place to go
06:59:40 <allsystemsarego> ok
06:59:45 <mauke> ocharles: what
07:00:08 <allsystemsarego> however ircbrowse only gives you html
07:01:47 <Clint> edwardk: it's too damn cold outside to not have adjunctions 4.0
07:03:24 * hackagebot mtgoxapi 0.5 - Library to communicate with Mt.Gox  http://hackage.haskell.org/package/mtgoxapi-0.5 (JanVornberger)
07:23:26 * hackagebot mtgoxapi 0.5.0.1 - Library to communicate with Mt.Gox  http://hackage.haskell.org/package/mtgoxapi-0.5.0.1 (JanVornberger)
07:26:33 <hattmammerly> http://bpaste.net/show/164232/ This function throws an exception when there are no more matches for the pattern; how might I rewrite this to fail gracefully? I want a list of all URLs from the input string so it must exhaust the string at some point. Do I just want to use parsec instead?
07:28:10 <hattmammerly> perhaps 'remainder' is a better word than 'after' in that function to give a better idea that it's the string after the match
07:29:48 <jonasw> hattmammerly: Wouldn't it be enough to handle the `Nothing` case of `matchRegexAll`?
07:30:33 <funfunctor> prob should not be asking this but, for Euler problem 3, would a 'good way' to go about it be applying Quadratic Sieve to factor the number and then apply the maximum function to the list of returned primes?
07:31:31 <hattmammerly> jonasw: how might I do that inside a where clause?
07:32:13 <hattmammerly> oh, hm, idea.
07:32:58 <jonasw> hattmammerly: You could add a function definition there. matched : f, where f = case regexstuff of...
07:33:51 <jonasw> And have it return [] is case of nothing
07:36:19 <hattmammerly> jonasw: matched comes from the pattern match as well
07:37:01 <hattmammerly> didn't think to use a function there, but i'll probably be able to think of something now. thank you!
07:40:15 <jonasw> hattmammerly: Oh right, so maybe something like this http://bpaste.net/show/VNgxYFYXYkdZQgDCihkD/
07:42:57 <hattmammerly> jonasw: that's basically what I wrote just now but I'm still getting the exception
07:46:17 <jonasw> hattmammerly: Hmm, appears to work for me. Also -Wall will warn you about non-exhaustive pattrns
07:47:10 <hattmammerly> jonasw: huh, yours works over here too. I guess I messed up. thank you for your help!
07:47:48 <jonasw> hattmammerly: No problem. Try with the warnings, then GHC tells you at compile time instead :)
07:49:26 <hattmammerly> -Wall doesn't tell me of any non-exhaustive patterns
07:49:39 <hattmammerly> http://bpaste.net/show/pAFEpZXRzDBCzGkrPU9e/ and as far as I can tell the logic of mine is the same
07:49:42 <hattmammerly> more or less
07:50:43 <hattmammerly> (err, forgot to add the import Text.Regex to the paste, but it's there.)
07:53:29 * hackagebot hakyll 4.4.3.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-4.4.3.0 (JasperVanDerJeugt)
07:53:40 <jonasw> hackagebot: You seem to be calling the old version in `matched : findURLs remainder`
07:53:45 <jonasw> Oops, hattmammerly ^
07:54:34 <hattmammerly> B) oh. heh. that's what I get for keeping a messy workspace. thank you again haha
07:54:44 <jonasw> :D
08:13:04 <scooty-puff> is it at all possible to have * -> * -> Bool, i.e. (a ~ b) :: Bool?
08:13:15 <scooty-puff> without incoherent or overlapping instances
08:21:32 <donri> scooty-puff: it is in ghc HEAD with type families
08:23:40 <zipper> vim has awesome syntax highlighting for haskell comments. :D
08:24:38 <StahlGrau> quchen: Woooo snowdau
08:24:43 <StahlGrau> whoops
08:28:33 * hackagebot mcpi 0.0.1.1 - Connect to MineCraft running on a Raspberry PI.  http://hackage.haskell.org/package/mcpi-0.0.1.1 (DouglasBurke)
08:28:36 <scooty-puff> donri: via closed type families?
08:29:34 <scooty-puff> i don't recall the syntax exactly, but like type family Same a b :: Bool where type instance Same a a = True; type instance Same a b = False?
08:33:34 * hackagebot haskintex 0.3.1.1 - Haskell Evaluation inside of LaTeX code.  http://hackage.haskell.org/package/haskintex-0.3.1.1 (DanielDiaz)
08:36:27 <shiona> what monads are in play in this, and how (I assume at least (-> a) is)
08:36:30 <shiona> > join (*) 3
08:36:31 <lambdabot>  9
08:36:39 <joelteon> that one
08:37:02 <FireFly> @ty join
08:37:03 <lambdabot> Monad m => m (m a) -> m a
08:37:24 <nizze> Hello! When I import Control.Monad and do (return "fo") ++ (return "bar") I get back ["fo, "bar"] why? Which version of (++) function is being used?
08:37:46 <FireFly> ↑ expand that with ((->) b) for m, and you should see how it works
08:38:06 <shiona> I'm trying to find the source atm
08:38:08 <FireFly> Remember that  ((->) b) a  is  b -> a
08:38:17 <joelteon> nizze: there's only one (++)
08:38:46 <narens> lens question: suppose, instead of defining a lens with a generic Functor f, I define a lens over a fixed functor, why won't the library let me use it?
08:39:11 <donri> scooty-puff: yes
08:39:33 <bennofs> narens: In order to get and set, you need different functors f. You cannot 'get' from a lens that fixes f to a special functor
08:39:45 <donri> narens: the functor is what gives you either get or modify
08:39:46 <nizze> joelteon, Okay, I found that, but how does it know how to concat monadic values?
08:39:52 <FireFly> shiona: well, I'd start with expanding the type. There aren't many useful functions of that type, anyway
08:40:21 <nizze> The source of ++ is quite simple
08:40:28 <bennofs> narens: More detail: Lens uses the 'Const' functor to get and the 'Identity' functor to set. So if you don't define your function for those two functors at least, it won't work with the lens combinators
08:40:30 <shiona> well, I've gotten as far as ((*) >>= id) 3
08:41:13 <mauke> now you need the definition of >>= for (->) e
08:41:18 <donri> @src (->) join
08:41:18 <lambdabot> Source not found. My pet ferret can type better than you!
08:41:22 <narens> bennofs: okay, that's what I suspected. I essentially have a class with a type function that expects a lens but ghc won't let me put a lens in there becuase it has a forall... how can i get around that?
08:41:24 <mauke> donri: not a method
08:41:35 <donri> mauke: @src is hand-written
08:41:42 <mauke> still not a method
08:41:50 <kuribas> Does there exist a writable environment monad?
08:42:03 <fizbin> kuribas: You mean State?
08:42:13 <joelteon> nizze:
08:42:16 <kuribas> yes, but with lexical scope
08:42:16 <joelteon> :t (++)
08:42:17 <lambdabot> [a] -> [a] -> [a]
08:42:25 <shiona> mauke: well, that becomes (*) (id 3) 3, which is obviously 9.. just why is >>= that way for (a ->) is now the question
08:42:38 <shiona> well, I guess I'll learn as I go
08:42:40 <bennofs> narens: So you have a associated type, and you cannot do instance C ... where type SomeType ... = <you want to put a lens here> ?
08:42:40 <dv-> kuribas: ST?
08:42:53 <narens> bennofs: exactly...
08:42:55 <mauke> shiona: well, what else could it be?
08:43:09 <narens> bennofs: I looked at reifedlens but its a pain
08:43:14 <mauke> shiona: (>>=) :: (e -> a) -> (a -> e -> b) -> e -> b
08:43:16 <nizze> joelteon:is [a] instance of a monad?
08:43:17 <narens> bennofs: I just want a fixed functor there
08:43:31 <kuribas> dv-: maybe...
08:43:57 <bennofs> narens: What's the problem with reified lenses?
08:44:11 <nizze> joelteon: I mean that come function with that signature can operat on monads?
08:44:15 <bennofs> narens: an alternative would be to use cloneLens
08:44:18 <bennofs> @ty cloneLens
08:44:18 <lambdabot> Functor f => ALens s t a b -> (a -> f b) -> s -> f t
08:44:19 <quchen> nizze: [] is an instance of Monad.
08:44:33 <nicoo> narens: Yes, [] is an instance of Monad
08:44:37 <nicoo> quchen: Damn :(
08:44:41 <bennofs> narens: ALens doesn't have the forall
08:44:43 <narens> bennofs: well for one thing I need to keep wrapping and unwrapping and i am getting some type errors also (don't want to go into that)
08:45:11 <narens> bennofs: ooo... let me investigate Alens
08:45:29 <bennofs> you still need to use 'cloneLens' to recover the original lens though
08:45:59 <narens> bennofs: that's okay... i just want the construction part to be easy.. using it can have some unwrapping which is fine because it only happens in one place
08:46:20 <nizze> quchen: How did you know it?
08:46:53 <nizze> quchen: or how did you find it out. How can I ask hoogle "show me all type classes which [] is instance of?" ?
08:47:06 <flazz> how can you tell the minimum methods you need to implement for a class?
08:47:17 <quchen> nizze: You can ask GHCi with ":i []"
08:47:18 <mauke> flazz: read the documentation and/or source
08:47:28 <narens> bennofs: i see the doc says its rank-1... i never actually understood this rank business.. so does rank-1 mean no constraints?
08:48:03 <bennofs> narens: rank 1 means that there is no forall on the f.
08:48:17 <narens> bennofs: and rank-n?
08:48:39 <nizze> quicksilver: HEAVEN! THANK YOU!
08:48:48 <nizze> quchen: HEAVEN! THANK YOU!
08:48:49 <nizze> :)
08:49:08 <bennofs> narens: I don't know how this is defined. I only know that rank-2 is for example (forall n. n -> n) -> n  (A function which takes another function that has a forall on it)
08:49:24 <bennofs> @ty runST
08:49:25 <lambdabot> (forall s. ST s a) -> a
08:50:05 <kuribas> In scheme old scope is still mutable in the new scope, how would you implement that in haskell?
08:50:09 <bennofs> narens: http://en.wikibooks.org/wiki/Haskell/Polymorphism#Higher_rank_types seems to explain it
08:50:16 <scooty-puff> forall (m = forall s . ST s a) a . m -> a
08:51:00 <mauke> kuribas: how do you modify scope in scheme?
08:51:09 <kuribas> with set!
08:51:18 <mauke> that doesn't affect scope AFAIK
08:51:53 <narens> bennofs: is an indexedlens a superset of lens?
08:52:18 <kuribas> mauke: The old variables are mutable.
08:52:23 <bennofs> narens: I'd say an indexedlens is a subset of lens. Every indexedlens is also a lens, but no the other way around
08:52:43 <mauke> kuribas: yes, but not the set of bindings
08:53:04 <kuribas> (let ((a 20)) (let ((b 10)) (set! a 10)) a)
08:53:13 <kuribas> mauke: no, not the bindings.
08:53:14 <narens> bennofs: okay, i have another problem then... i'm not sure why i can't store somelens.ix i as an ALens
08:53:29 <bennofs> narens: because it is ATraversal
08:53:32 <kuribas> mauke: Is there a monad for that in haskell?
08:54:06 <stian> This is probably really basic, but is there an easy way of getting values out of a wrapper without pattern matching. Ie. a function does printGen (Dist m) = do something to m... I need that m, but directly in ghci, without writing a function to get at it?
08:54:09 <bennofs> narens: ix is a traversal. somelens is a lens. A lens is also a traversal, so the result will be a traversal
08:54:11 <mauke> kuribas: you could use a Map of IORefs or something
08:54:27 <narens> bennofs: hmm... so there is no way to generically expect either/or
08:54:32 <stian> (I know fromJust can get at a (Just m) value, but is there something more generic?)
08:54:35 <dv-> kuribas: ST works like that
08:54:47 <mauke> stian: use pattern matching
08:54:53 <bennofs> narens: What do you mean? Expect either a traversal or a lens?
08:55:08 <narens> bennofs: yea, i suppose expecting a traversal should be okay.. since a lens will match with it
08:55:10 <stian> mauke: Right, but then I need to write a function right? I just want to write a one-liner in ghci.
08:55:15 <bennofs> narens: exactly
08:55:29 <mauke> stian: no, you don't need a function
08:55:38 <mauke> stian: also, you can write functions in one line in ghci
08:55:53 <stian> mauke: yes I realize that.
08:56:07 <mauke> so what does your question mean?
08:56:21 <kuribas> mauke: I am already in IO, so maybe use IORefs?
08:56:37 <kuribas> A list then.
08:56:48 <narens> bennofs: brilliant work. Thanks. I understand these types a lot better now
08:57:05 <stian> mauke: This: runProb $ (>360) ?? sum (replicate 100 die) - gives me a list of values that I want to plot, wrapped in a Dist. I want to get them out of the Dist and snd them to the plot function with as little ceremony as possible.
08:57:35 <mauke> stian: what's Dist?
08:57:51 <stian> I guess I could write a plotdist (Dist x) = plot x
08:58:02 <stian> mauke: A type from hs-probability.
08:58:12 <mauke> stian: how is it defined?
08:59:04 <stian> newtype Dist p a = Dist { unD :: [(a,p)] } deriving Show
08:59:22 <mauke> oh look, it even provides a function for you
08:59:30 <mauke> unD
09:02:19 <stian> mauke: That's a function? How do I call it? unD b says not in scope.
09:02:34 <mauke> oh, maybe it's not exported?
09:05:31 <flazz> is there a doc somewhere explaining the packaging convention in haskell at large?
09:06:49 <narens> bennofs: At is the Lens while Ix is a traversal?
09:08:19 <haasn> At is a lens to a Maybe, yes
09:10:14 <haasn> Huh, GHC bug? :i Contains in GHCi gives me:
09:10:16 <haasn> class Contains m where
09:10:18 <haasn>   type family Containing m1 f :: Constraint
09:10:20 <haasn> m1 instead of m
09:15:23 <int80_h> @src partitonEithers
09:15:24 <lambdabot> Source not found. I don't think I can be your friend on Facebook anymore.
09:15:28 <int80_h> @src partitonEither
09:15:29 <lambdabot> Source not found. Whoa.
09:17:57 <int80_h> could someone tell me what the ~ mean in this code?
09:18:01 <int80_h> http://lpaste.net/97934
09:18:34 <ion> Irrefutable match, it won’t try to force the tuple.
09:21:33 <int80_h> ion: thanks :)
09:35:25 <bitemyapp> ChongLi: yeah, doing without types sucks.
09:38:24 <fabe> hi, im not sure what im doing wrong. why does this code behave differently if i separate it out into a different function? http://lpaste.net/97935
09:38:46 <Happy0> fabe :o
09:39:24 <fabe> jo Happy0
09:39:47 <benj_> fabe, you are missing a 'return' on line 24
09:40:02 <benj_> fabe, alternatively, don't use do-notation for this, because you only need a Functor here
09:40:03 <quchen> And line 27 should be "test <- makeTest".
09:40:06 <mauke> how is that even the same code?
09:40:53 <benj_> makeTest = fmap Test $ newArray (1,255) 1.0
09:41:32 <kuznero> Hi All!
09:42:19 <haasn> fabe: do { a; let b = c } is nowhere near the same thing as do { let b = do { a; c }}
09:42:36 <haasn> ‘a’ is part of completely different do blocks
09:43:29 <fabe> im just learning and still dont understand haskell very well
09:43:39 <fabe> does anyone have anything that compiles?
09:43:55 <benj_> heh, in general?
09:44:14 <quchen> main = return () -- compiles well
09:44:38 <fabe> are you trying to be unhelpfull?
09:44:41 <tromp> main=main compiles too, but runs not so well
09:44:53 <fabe> i pasted code above
09:44:56 <monochrom> fabe: try my http://lpaste.net/52480
09:45:38 <Happy0> fabe: i think the things quchen and benj_ mentioned should work
09:46:51 <fabe> no Happy0 cant get anything to compile
09:47:51 <Happy0> fabe: what's the error after applying those changes?
09:49:25 <fabe> happy http://lpaste.net/97938
09:49:34 <fabe> Hafydd
09:49:38 <fabe> arg Happy0
09:49:43 <Happy0> lul'z =p
09:50:27 <kuznero> Can anybody help with yesod question? http://lpaste.net/97937 (#yesod people aren't there yet after NY I guess)
09:50:40 <Happy0> fabe: what about test <- makeTest on line 28?
09:51:06 <fabe> src/test.hs:28:12: parse error on input `<-'
09:51:20 <eikke> :t Data.ByteString.length
09:51:21 <lambdabot> BSC.ByteString -> Int
09:51:28 <eikke> :t Data.ByteString.Lazy.length
09:51:28 <lambdabot> BSLC.ByteString -> Int64
09:51:31 <eikke> buh
09:51:52 <bennofs> fabe: O.O are you sure you idented that the same as the line below (b <- ...) ?
09:52:15 <bennofs> s/ident/indent/
09:52:26 <fabe> ah thx benbangert
09:52:27 <Happy0> and (silly question) that you removed the 'let' before replacing '=' with '<-' ;x
09:52:31 <fabe> er bennofs
09:52:43 <benbangert> apparently there's enough ben's here for frequent misfires :)
09:52:59 <Happy0> fabe: oh good :D
09:53:33 <fabe> guess i still have to understand the language better though its all functions
09:53:42 <fabe> and not syntax guessing
09:54:31 <Happy0> fabe: haha yeah.. i was once at the stage you were =p.. frantically trial and erroring until things compiled, rather than understanding what i was doing
09:55:08 <fabe> well all i want is an record with an array
09:55:23 <fabe> how can something so simple be so hard
09:56:10 <bennofs> fabe: in this case, makeTest is of type "IO Test". You want to get a Test 'out' of it, so you use test <- makeTest. Now test is of type 'Test', so you can apply the function something of type 'Test -> IOArray Int FloatÄ to it
09:56:26 <mauke> german keyboard detected
09:56:31 <bennofs> haha
09:56:42 <fabe> sehr schön :D
09:57:04 <mauke> whatß
09:57:58 <fabe> thx bennofs
09:58:20 <fabe> that helps
09:58:53 <Happy0> fabe: if you have any questions, feel free to ask me in the other channel we're in :o
09:59:04 <Happy0> and if i can't help you, everyone here is an awesome help, obviously :P
09:59:13 <fabe> yeah i didn't know you can haskell
09:59:51 <Happy0> fabe: only started playing around with it in the last few weeks
10:00:01 <fabe> well most are awesome some are pretentious dicks, internet ...
10:00:02 <Happy0> although i did do a couple of modules around it at uni
10:00:31 <Happy0> fabe: as far as communities go, the haskell community is generally pleasant and eager to help (if you're polite) - as far as i've seen, anyway
10:00:57 <fabe> ok ill be back in 5 min then with i get stuck again ;r
10:01:02 <Happy0> hahaha
10:03:55 <fabe> oh Happy0 is there a way to add the array size into the type definition so its required?
10:04:38 <fabe> im guessing i have to add a new type for that
10:04:40 <Happy0> fabe: just add a comma at the end of 'something', then on the next line
10:04:45 <Happy0> size :: Int
10:04:58 <mauke> or even on the same line
10:05:04 <Happy0> haha, indeed
10:05:25 <fabe> no i want the array to have a fixed size like in a c struct
10:06:05 <fabe> i c i would write struct { int array[42]; };
10:06:17 <mauke> you can't (easily) do that
10:06:36 <mauke> haskell arrays generally don't put their size in the type
10:06:55 <fabe> the grow?
10:07:00 <mauke> no
10:07:10 <Happy0> fabe: you've already gave your array its size
10:07:16 <Happy0> on line 8
10:07:18 <Happy0> 9* ;x
10:07:38 <fabe> yeah but i just think it belongs to the type if it doesnt grow
10:07:48 <fabe> but whatever im fine for now
10:07:54 <fabe> thank for the help
10:08:39 <Happy0> goo
10:08:45 <Happy0> och. wrong window
10:08:46 * hackagebot hsimport 0.2.6 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.6 (DanielTrstenjak)
10:09:03 <Happy0> wat
10:09:28 <Happy0> what did i say that caused hackagebot to say that? :P
10:09:35 <mauke> nothing
10:09:42 <mauke> correlation doesn't imply causation
10:09:51 <Happy0> lmao. wise words
10:10:03 <shachaf> mauke: there's a correlation between them, though
10:10:06 <shachaf> good enough for me
10:16:56 <zett_zelett> I just now read http://www.haskell.org/haskellwiki/IO_inside#Welcome_to_the_RealWorld.2C_baby. Isn’t (>>) :: IO a -> IO b -> IO b simply definable as action1 >> action2 = action2 . snd . action1?
10:17:43 <shachaf> No, that page is just a lie.
10:18:00 <mauke> there is no RealWorld
10:18:47 * hackagebot hsimport 0.2.6.1 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.6.1 (DanielTrstenjak)
10:19:27 <zett_zelett> Ah, yeah. It says it right there.
10:26:13 <maxiepoo> did that xkcd get modded on /r/haskell? It's not on the front page?
10:29:36 <sfsfdsas> Is hmatrix the best library to find eigenvectors?
10:30:00 <Fuuzetsu> don't know about ‘best’ but if it works for you then sure
10:30:12 <sfsfdsas> Fuuzetsu: Haven't tried it yet.
10:34:56 <mzdravkov> I just started learning haskell with http://learnyouahaskell.com/starting-out and there is "Note: We can use the let keyword to define a name right in GHCI. Doing let a = 1 inside GHCI is the equivalent of writing a = 1 in a script and then loading it. " So, please forgive my maybe stupid question, but... why is there a difference?
10:36:08 <geekosaur> because ghci is not a compiler, it's a bit like a "desk calculator"
10:36:29 <geekosaur> you can't have bare expressions in a haskell source file, but that's how you evaluate things in ghci
10:36:45 <geekosaur> so it needs the `let` keyword to tell it to make a binding instead of just evaluating
10:36:46 <jonasw> mzdravkov: In ghci, it's like when you're in a `do` block in regular source
10:38:07 <orzo> what's the latest recommended way to do popen in haskell?
10:38:56 <orzo> i have the "unix" package installed, but i'm not seeing popen functionality in System.Posix.Process
10:40:30 <geekosaur> orzo: you want System.Process; System.Posix.Process is only low level stuff
10:40:57 <geekosaur> specifically you want http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/process-1.1.0.2/System-Process.html#v:createProcess
10:43:17 <orzo> thanks
10:58:30 <hamid> :t nth
10:58:31 <lambdabot> Not in scope: `nth'
11:00:39 <schell> i'm having trouble transferring C structs to Haskell records using hsc2hs - it seems my alignment is off
11:00:42 <mlen> Is there a way to define a function that takes n arguments without using Either (or similar concept)?
11:01:01 <shachaf> What does that mean?
11:01:18 <cschneid> mlen: take a tuple? a list? a custom data structure with embeded Maybe values?
11:01:20 <schell> http://lpaste.net/97940
11:01:47 <mlen> cschneid: I mean no tuples, lists, etc
11:01:54 <geekosaur> not easily
11:02:00 <solrize> why is quot faster than div?
11:02:05 <geekosaur> see Text.Printf
11:02:12 <cschneid> mlen: what? I'm not sure what you're asking.
11:02:22 <schell> my struct is http://lpaste.net/97941
11:03:06 <mlen> cschneid: sorry, I wasn't clear enough. the idea is to create a function taking variable number of arguments without using lists, tuples or Either or similar stuff
11:03:21 <dv-> > printf "hello %s %d %d" "user" 10 12 :: String
11:03:22 <lambdabot>  "hello user 10 12"
11:03:41 <cschneid> mlen: I don't believe that's possible. The various ways I suggested are how you do it. But I'm not advanced haskeller, so ... maybe?
11:04:07 <saml> how can I reverse a large list?  to traverse the list to the end takes 2000 years.
11:04:23 <sleepynate> list.last
11:04:25 <saml> thanks
11:04:26 <geekosaur> mlen, cshneid: it is doable. it is not particularly friendly. again, see Text.Printf
11:04:27 <sleepynate> np
11:04:33 <cschneid> geekosaur: cool
11:04:40 <saml> > last "a"
11:04:41 <mlen> geekosaur: thx :)
11:04:41 <lambdabot>  'a'
11:04:46 <shachaf> Doable in some cases, but conceptually ugly even in many of those.
11:04:46 <geekosaur> it requires typeclass hackery and the result is somewhat fragile
11:04:57 <saml> > last [1,2 .. 2348570283475238047204827048972034782309478520875029587048957230498753094875028972089472084750234780234785034897055]
11:05:00 <lambdabot>  mueval-core: Time limit exceeded
11:05:05 <saml> it's not fast
11:05:19 <cschneid> saml: yeah, there's no way because lists are linked lists, forcing you to traverse the whole thing to get the last element
11:05:47 <saml> maybe it's a good interview question
11:06:05 <cschneid> saml: I imagine the right answer is: "don't use lists when you want that functionality"
11:09:26 <saml> but list is monad. so you can probably lift it so that getting it to nth reversing natural morphic functor is polynomial time
11:10:54 <carter> you're making that up
11:10:59 <carter> :P
11:11:10 <philed> carter: I understood it.
11:11:28 <carter> it is polynomial time anyways
11:11:38 <carter> just slow polynomial time
11:13:00 <carter> :)
11:19:05 <threestrikes> :q
11:26:50 * flebron had a function for getting a list of elements out of his tree data structure, involving zipping around the entire thing, up and down, finding successors.
11:27:00 * flebron just replaced it by fold . (pure <$>)
11:27:23 <dv-> :t fold . (pure <$>)
11:27:24 <lambdabot> (Functor t, Applicative f, Foldable t, Monoid (f a)) => t a -> f a
11:28:11 <flebron> f = [], t = MyTreeDataStructure
11:28:21 <shachaf> foldMap (:[]) ?
11:28:37 <pranz> :t foldMap
11:28:38 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
11:28:43 <shachaf> :t toList
11:28:44 <lambdabot>     Not in scope: `toList'
11:28:44 <lambdabot>     Perhaps you meant one of these:
11:28:44 <lambdabot>       `F.toList' (imported from Data.Foldable),
11:28:46 <shachaf> :t F.toList
11:28:47 <lambdabot> Foldable t => t a -> [a]
11:28:58 <flebron> Could very well be, I hadn't realized I could write \x -> [x] as :[] :)
11:29:17 <shachaf> Even better (asymptotically, since it does the DList thing rather than the tree thing).
11:31:00 <flebron> Oh cool :) Is it bad form to export a toList, when you also export a Foldable instance? (In my case, toList would be = Foldable.toList :p)
11:31:34 <shachaf> Probably not.
11:31:37 <shachaf> Maybe kind of pointless.
11:32:46 <shachaf> Also, note that until the next version of GHC, Derive{Functor,Foldable,Traversable} has a bug that can make it asymptotically very inefficient.
11:33:26 <flebron> Oh, I'm not automatically deriving those. I didn't even know I could :p
11:33:56 * hackagebot mueval 0.9.1.1 - Safely evaluate pure Haskell expressions  http://hackage.haskell.org/package/mueval-0.9.1.1 (GwernBranwen)
11:44:18 <enthropy> shachaf: in the generated code, or in the compile time?
11:44:28 <mauke> generated code
11:44:47 <shachaf> whauke said.
11:45:07 <enthropy> does this change what fold does if your monoid is not associative?
11:45:34 <shachaf> If your monoid is not associative then anything goes.
11:45:57 <shachaf> Yes, it probably does change it, but that's as a separate improvement that was made at the same time.
11:46:11 <shachaf> Since the old code just defined foldr instead of foldMap (?!).
11:46:14 <shachaf> https://ghc.haskell.org/trac/ghc/ticket/7436
11:46:38 * flebron hopes nobody realizes his structure isn't a Functor unless your function is monotonic...
11:46:55 * flebron sweeps that under the rug and whistles away...
11:48:45 <shachaf> Uh.
11:48:58 * hackagebot archiver 0.6.2.1 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.6.2.1 (GwernBranwen)
11:48:59 <Komier> Anyone use Emacs here? Do you use anything except Haskell-Mode?
11:50:57 <philed> Komier: I once had ghc-mod working.
11:51:11 <philed> It was awesome.
11:51:17 <Komier> once had?
11:51:50 <philed> Yeah, it stopped working about I cleaned up my cabal directories or something.
11:51:59 <Komier> ah fun
11:52:22 <philed> But if you can get it to work, I heartily recommend it.
11:52:49 * flebron is using ghc-mod in vim only a veeeery little bit
11:54:03 <absence> is there a non-emacs non-vim editor that can do clever haskell stuff using ghc-mod or the likes?
11:55:00 <Komier> sublime haskell plugin for sublime text uses it.
11:55:10 <bernalex> since #hakyll is a bit quiet, I thought I'd try here: how do you use partials with md? if I change from pandocCompiler to getResourceBody then my partial shows up, but I want to use md.
11:56:29 <absence> Komier: ah yes, i've had some trouble getting that to work. others?
11:58:25 <epta> Why Enum class has no Eq subclass? When it is usefull to have something Enum and not Eq?
11:58:46 <carter> enthropy: you can enumerate functions.... sometimes
11:58:47 <Komier> absence : I did too, was a pain to get it all sorted.  You have to manually adds the paths of your ghc-mod installation.  Not sure about others.  Maybe Leksah?  or EclipseFP.
12:00:30 <carter> what are some good examples of code using hsc?
12:02:20 <absence> Komier: i've tried those too :) eclipse is just too slow, and leksah was fine at 0.12, but 0.13 has some gtk3 related issues on windows (and some other problems iirc). i've ended up using sublime without the haskell plugin, but for someone used to visual studio it's a bit sad :(
12:04:00 <shachaf> !list
12:04:05 <Komier> absence:  What errors were you getting with your sublime plugin?
12:06:23 <absence> Komier: except for syntax highlighting none of it actually worked. there were no error messages, things just didn't happen when i tried to use any of the sublimehaskell commands. and i did have all the required stuff installed and in path
12:06:50 <Komier> absence: Ah that's annoying :(
12:08:09 <Komier> absence:  I haven't heard of any others though, and most people in here recommend either Vim or Emacs.
12:10:14 <absence> Komier: yeah, i guess that as long as those exist there's not enough incentive to make a great editor for haskell
12:10:21 <jhuk> Hi, does anyone have a few minutes to help me with a complete newbie problem I'm stuck on please?  I think I'm misunderstanding something about case statements but can't figure out what
12:11:01 <Komier> Ask away mate, I'm sure someone will answer.
12:12:47 <jhuk> Thanks.  I have a list of instances of a type called MerchantMapping, and I've written a case statement that tries to take the head of that list using [x:xs] and then treats x as if it was a merchant mapping, but I get an error: 'couldn't match expected type 'MerchantMapping' with actual type [t0]
12:13:20 <mauke> [x:xs] is not a list, it's a list of lists
12:13:25 <simukis_> You should match with (x:xs), not [x:xs].
12:13:58 <startling> > let f [x:xs] = 12 in f [[1, 2, 3]]
12:14:00 <lambdabot>  12
12:14:12 <startling> woah, surprised that works.
12:14:20 <startling> I thought you'd need parens.
12:14:42 <aristid> mauke: a list of lists is a list
12:14:45 <jhuk> ahh, now it all makes sense, I knew it'd be something stupid.  Thanks muake, simukis_
12:15:26 <philed> jhuk: Not stupid. You were obviously just used the Prolog syntax.
12:15:29 <philed> :)
12:15:31 <Komier> absence: You might be right. I'd like to give them a whirl, but learning Vim/Emacs at the same time as trying to learn Haskell is rather daunting.
12:16:05 <mangaba_leitosa> 'let f [x:xs] = 12 in f [[1, 2, 3]]'? It must be a useful function indeed
12:16:10 <philed> Komier: Nah. Emacs is such a stupid learning curve anyway that you might as well compound it any which way you can.
12:16:19 * flebron would like f x:xs to work :(
12:16:44 <flebron> Is there any ambiguous situation with that, given that a function declaration and an expression can't appear in the same places?
12:16:54 <aristid> flebron: f x:xs works, it's just the same as (f x):xs :)
12:17:05 <flebron> Right, but I mean when defining a function f.
12:17:16 <Komier> philed: haha you may be right!
12:17:21 <flebron> Why is it ambiguous if I say f x:xs = 12? What could it possibly mean?
12:17:28 <absence> startling: the parens are just for operator precedence, they'd be superfluous in your example
12:17:31 <mauke> flebron: (f x) : xs = 12
12:17:41 <flebron> mauke: That'd be a syntax error, so discard that
12:17:51 <aristid> mauke: well you need an instance of Num for lists for that i guess
12:17:59 <mauke> flebron: why is that a syntax error?
12:18:10 <startling> absence: I know they're superfluous to humans but I didn't know they were superfluous to Haskell.
12:18:12 <flebron> Oh wait, you're doing a pattern match -_-
12:18:17 <flebron> But... what would f be there?
12:18:24 <flebron> Can you just match on (f x), with f any function??
12:18:29 <mauke> no
12:18:36 <flebron> Then that's the syntax error, isn't it?
12:18:50 <flebron> If f were a ctor, then sure, it's a possible match.
12:18:52 <mauke> > case () of a b -> ()
12:18:53 <lambdabot>  <hint>:1:12: Parse error in pattern: a
12:19:01 * hackagebot happstack-server 7.3.2 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.3.2 (JeremyShaw)
12:19:18 <flebron> But if f is an identifier, it can't possibly match. So how else can you validly interpret f x:xs = 12?
12:19:26 <mauke> flebron: you can't, which is why you get the error
12:19:44 <mauke> flebron: the bigger question is, why do you want F x : xs and f x : xs to mean completely different things?
12:19:51 <absence> Komier: i tried long before starting with haskell, and it felt a lot like swimming up a waterfall :)
12:19:52 <jhuk> philed: that'll do as an excuse! :-)  I thought because I was matching against a list I'd use list syntax, but it makes sense that it's a tuple
12:19:59 <flebron> Because one makes sense as a pattern match, the other doesn't.
12:20:13 <geekosaur> flebron: the question is whether you want patterns to have a different syntax from every other usage of that in the language
12:20:13 <flebron> And the other makes it possibly to not litter our source code with parentheses.
12:20:40 <mauke> flebron: that way lies C++
12:20:53 <mauke> A b(C); // no, thanks
12:20:57 <Komier> absence: Aye for me too, can't even get all the haskell specific stuff installed and working properly, let alone get used to the editor.
12:21:10 * flebron wouldn't really be vexed by f x:xs = 12 :s
12:21:21 <mauke> flebron: just put spaces around your operators
12:21:26 <flebron> But sure, it's a matter of preference I suppose.
12:21:30 <philed> jhuk: It's all consistent with Haskell's notation. If you have the value [x:y], you've actually got a list with exactly one element.
12:22:08 <philed> > let x = 1 in let y = [2,3] in [x:y]
12:22:09 <lambdabot>  [[1,2,3]]
12:22:21 <absence> Komier: have you tried yi? i've only read about it - there are no binaries and i haven't managed to compile it in windows
12:22:30 <philed> That's a list whose only element is *another* list, [1,2,3]
12:23:05 <Komier> absence: no I havent' but a few people were talking about it in here yesterday.  Didn't hear anything majorly negative.
12:23:23 <osa1> how does pattern matching on Text work? does it implicitly call unpack?
12:23:35 <hiptobecubic> my experience with yi was that it was vim without any features and then it segfaulted and i gave up
12:23:38 <hiptobecubic> ymmv
12:24:02 * hackagebot leankit-api 0.3 - LeanKit API  http://hackage.haskell.org/package/leankit-api-0.3 (dtorok)
12:24:17 <jhuk> philed: you mean x would be a single item list in [x:xs]?
12:24:26 <monoidal>  osa1: f "x" = a means f k | k == "x" = a. now if you have overloaded strings, "x" is fromString ("x" :: String)
12:25:07 <absence> Komier: interesting, maybe i'll try it in a linux vm some day
12:25:09 <cschneid> does overloaded strings have any runtime performance hit? or is the `fromstring ("x") :: String` stuff all resolved at compile time
12:25:18 <jhuk> philed: whereas (x:xs) is a tuple of type (a,[a])?
12:25:38 <startling> no
12:25:46 <philed> jhuk: Ah no. (x:xs) is the same as x:xs. You only use the brackets to disambiguate.
12:25:46 <startling> those parens are just for precedence
12:25:48 <pfurla> philed: oh, you here too?
12:26:25 <philed> pfurla: Yeah. Haskell would have been my first choice, had it run nice on the JVM.
12:26:33 <pfurla> hey, can I use haddock to generate a summary of all types in my project in a single page?
12:27:39 <philed> flebron: Okay, how about this: data Foo a = Bar a | Foo :=: Foo.
12:27:45 <philed> What's the parse of: f Bar x :=: Bar
12:27:50 <philed>  f Bar x :=: Bar = ...
12:28:09 <flebron> :=: isn't anything special, = is :p
12:28:10 <philed> No that's not quite right.
12:28:27 <monoidal> philed: that's not valid synta
12:28:38 <jhuk> philed: thanks, I think i'm there now.
12:28:38 <philed> But I'm thinking you could do something peculiar there.
12:29:13 <philed> flebron: :=: is just supposed to be my own infix constructor, like :.
12:29:22 <monoidal> philed: mere "f Bar x :=: Bar" is valid syntax, though. It is the result of :=: operator applied to "f Bar x" and "Bar".
12:30:01 <philed> monoidal: Trying to find a reason why allowing "f x:xs = ..." would cause problems.
12:30:31 <monoidal> philed: it's parsed as (f x):xs) = ..
12:30:41 <monoidal> philed: you probably want f (x:xs) = ...
12:31:04 <philed> monoidal: Yeah, but the argument is that, in a pattern, f would have to be a constructor, so it shouldn't be ambiguous.
12:31:13 <mangaba_leitosa> yes, 'f (x:xs)' is abominable
12:31:26 <aristid> what's abominable about it?
12:31:45 <mangaba_leitosa> aristid: too many chars to type :-)
12:31:48 <aristid> i think it's better to have consistent precedence between patterns and expressions there
12:32:32 <monoidal> philed: it would create ambiguity. consider f x = Just 1. now, is "f" a function that is constantly "Just 1", or is this a definition of both "f" and "x" such that f = Just, x = 1?
12:33:03 <monochrom> you are right about unambiguity given the special context. but I value simple rules more. my "simple" means no shit like "'f x:xs' means one thing, except it means a different thing at a different position". my "simple" means no exceptions.
12:33:20 <mangaba_leitosa> philed: consider 'f hd:tl = f (hd':tl) where hd' = g hd'. Won't it look somewhat assymetic?
12:33:28 <monoidal> philed: plus, different constructors might have different arities. what should "f x y" match if the constructor is three-ary, for exampel?
12:33:31 <philed> flebron: Well something similar. If you do "f G x :=: x", the ambiguity is only resolved by knowing the arity of the G constructor. Whether G is nullary or unary is going to make a difference to what you intend.
12:34:27 <monochrom> I also value reader convenience more than writer convenience. reader convenience means the reader has less to guess. writer convenience means the writer has less to write.
12:35:16 <philed> Err...guys. I don't *want* to drop the parentheses in these patterns. flebron suggested doing so above, and I'm trying to come up with counterexamples.
12:35:28 <monochrom> statistically, simple rules are correlated to reader convenience, a lot of exceptions are correlated to writer convenience.
12:35:52 <mangaba_leitosa> philed: ah, ok :-)
12:36:03 <monoidal> there are two things you can put on the left side of "=". Either a pattern (such as "(a,x:xs) = ...") or an identifier followed by patterns (such as "f Nothing (x,y) = ...")
12:36:27 <mauke> lol `wut` mate =
12:36:36 <monoidal> yeah, disregarding infix
12:36:50 <mauke> infix :=: patterns =
12:38:04 <tinyghost> u `wot` m8
12:38:06 <monoidal> first definition defines "a","x", "xs". second defines "f" only.
12:50:09 <bennofs> Is there a channel where I could ask some questions about store-load reordering done by cpus? I still haven't understand that fully I think, but it seems a bit off-topic for #haskell
12:50:31 <carter> bennofs: some people here may know
12:50:37 <carter> otoh, intel cpus behave nice
12:50:39 <carter> otheres dont'
12:50:50 <carter> well x86 /x86_64 do
12:50:56 <carter> others are a bit more relaxed
12:51:40 <enthropy> carter: use something better than hsc2hs like c2hs or c2hsc
12:51:48 <carter> enthropy: why
12:52:15 <carter> oh
12:52:16 <carter> hrmm
12:52:27 <carter> ooo
12:52:30 <enthropy> because when you mess up a type signature in a hsc2hs file, you get segfaults
12:52:43 <enthropy> but the others are less likely to do that for you
12:52:52 <carter> i'm just doing the raw ffi stuff right now
12:53:19 <bennofs> Well, is the CPU allowed to reorder stores to the same address? I.e. if I have an address A, and I do STORE 3 A, [something not dependend on a], STORE 4 A, STORE 5 A, could it exchange the two stores to A so that another thread sees A go from 4 to 3 to 5?
12:53:19 <carter> https://github.com/wellposed/hOpenBLAS/blob/master/src/Numerical/OpenBLAS/FFI.hs#L372
12:53:25 <carter> though c2hsc looks handy
12:53:34 <carter> bennofs: not on intel stuff
12:53:49 <carter> http://en.wikipedia.org/wiki/Memory_ordering
12:54:05 * hackagebot reform 0.2.2 - reform is an HTML form generation and validation library  http://hackage.haskell.org/package/reform-0.2.2 (JeremyShaw)
12:54:07 * hackagebot reform-blaze 0.2.1 - Add support for using blaze-html with Reform  http://hackage.haskell.org/package/reform-blaze-0.2.1 (JeremyShaw)
12:54:17 * hackagebot reform-hamlet 0.0.1 - Add support for using Hamlet with Reform  http://hackage.haskell.org/package/reform-hamlet-0.0.1 (JeremyShaw)
12:54:19 * hackagebot reform-happstack 0.2.1 - Happstack support for reform.  http://hackage.haskell.org/package/reform-happstack-0.2.1 (JeremyShaw)
12:54:20 * hackagebot reform-hsp 0.2.3 - Add support for using HSP with Reform  http://hackage.haskell.org/package/reform-hsp-0.2.3 (JeremyShaw)
12:54:20 <carter> enthropy: i may give this c2hsc a whorl
12:57:12 <Cale> bennofs: there's a chart here: http://en.wikipedia.org/wiki/Memory_ordering
12:57:30 <Cale> bennofs: (the answer to your question depends on the processor)
12:57:58 <carter> enthropy: i love you
12:58:03 <carter> and owe you a beer
12:58:14 <enthropy> carter: can you fix this up: http://lpaste.net/50837 ?
12:58:49 <carter> woah
12:58:53 <carter> i'm weak at TH
12:59:06 * hackagebot web-plugins 0.2.4 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.4 (JeremyShaw)
12:59:08 * hackagebot happstack-heist 7.2.2 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.2.2 (JeremyShaw)
12:59:10 * hackagebot happstack-hsp 7.2.4 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.2.4 (JeremyShaw)
12:59:12 * hackagebot happstack-jmacro 7.0.7 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.7 (JeremyShaw)
13:01:04 <enthropy> hmm, maybe the solution is to add a -pgmF preprocessor
13:01:32 <enthropy> which changes nothing, but writes out the liba.f90
13:01:42 <carter> enthropy: q: how do i make some of the ccalls unsafe?
13:01:46 <carter> in hsc?
13:02:12 <carter> eh, doesn't matter, i'll leave em all as safe
13:02:25 <enthropy> dunno. eventually it gets to a foreign import, and you can change it there?
13:03:02 <enthropy> after calling the hsc2hs, which is probably to late (for sanity)
13:04:06 * hackagebot hsx-jmacro 7.3.2 - hsp+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.3.2 (JeremyShaw)
13:04:08 <bennofs> Is it guarranted that in [some filesystem operations] >> writeIORef ref True, [some filesystem operations] will actually be performed before the ref is set to True? I guess there is too much going on for the CPU to reorder the store before the filesystem operation, but who guarrantes that?
13:04:08 * hackagebot happstack-authenticate 0.10.8 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.10.8 (JeremyShaw)
13:04:10 * hackagebot happstack-foundation 0.5.3 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.5.3 (JeremyShaw)
13:05:39 <Cale> bennofs: There was a big article about IORef operation reordering on ezyang's blog about this recently http://blog.ezyang.com/
13:05:53 <mello_> how can I get the day of a Day? (in Data.Time.Calendar)
13:06:12 <bennofs> I guess it comes down to "Haskell has no memory model, so you'll just have to assume it" ?
13:06:22 <Cale> bennofs: Basically, GHC reserves the right to move things around. IORefs are not a very reliable way to communicate between threads.
13:06:33 <mello_> e.g. let's say i have a Day that represents 2012-02-01, how do i know whether it is tuesday or monday or sunday?
13:06:58 <Cale> mello_: It might be all of those
13:07:06 <Cale> mello_: What time is it, and in which timezone?
13:07:38 <Cale> Well...
13:07:53 <mello_> dont need timezones, just dates. There are some convenient functions for working with them but I can't find one that lets me get information of the actual day it is
13:08:31 <Cale> http://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Calendar-WeekDate.html
13:08:54 <Cale> I guess once you have a Day, it's enough
13:09:20 <Cale> If you have a particular time, knowing what day it is needs a timezone :)
13:09:21 <mello_> that's it
13:09:26 <mello_> how did you find that so quickly
13:10:09 <Cale> I went to Hackage, found the time package, and then clicked on the WeekDate module
13:10:15 * bennofs goes to replace all uses of IORef in his program by MVar
13:10:22 <carter> enthropy: ok it snot working
13:10:25 <carter> i'll look at this later
13:10:55 <Cale> bennofs: You might also want to know about STM
13:11:00 <carter> enthropy https://gist.github.com/cartazio/8246612
13:11:23 <bennofs> Cale: My transactions do not involve multiple variables at once, so I think I don't need that
13:11:28 <Cale> okay :)
13:11:35 <Cale> (That's correct)
13:11:36 <enthropy> carter: fix the "bindings.dsl.h: No such file or directory" first
13:11:43 <carter> where should that be?
13:11:51 <carter> where would that be
13:12:07 <enthropy> I have one in /home/aavogt/.cabal/lib/x86_64-linux-ghc-7.6.2/bindings-DSL-1.0.17/include/bindings.dsl.h
13:12:32 <carter> ahhh
13:12:42 <carter> c2hsc doesn't have that as a dep
13:13:00 <enthropy> well that's not a standard location to search
13:13:49 <Cale> mello_: Oh, that might not be what you want...
13:14:21 <carter> yeah
13:14:28 <mello_> Cale, why not? It does what I asked you it should do right? It does give the output i need though
13:14:31 <Cale> Well, hmm! It might work if you're ignoring the year :)
13:14:38 <mello_> why?
13:14:47 <Cale> Note that "Week" years are not quite the same as Gregorian years, as the first day of the year is always a Monday. The first week of a year is the first week to contain at least four days in the corresponding Gregorian year
13:15:24 <Cale> I think that's still okay though.
13:15:29 <mello_> Ok, i just want to know what day the first day of each month is so.. well i checked and it seems to work fine for what i need
13:15:36 <mello_> im no specialist in gregorian calendars though
13:15:46 <Cale> Yeah, I think it'll work out.
13:16:01 <Cale> But you might notice that it reports a weird year for the first day of January.
13:16:10 <apples> hi, having a bit of trouble w/ a websockets server i'm writing, but i think the problem may be more general than that. http://lpaste.net/3642897664539885568 -- when i try to handle messages in a forked thread, i get warnings about invalid file descriptors
13:17:25 <carter> enthropy: https://gist.github.com/cartazio/8246701 whats wrong withe the generated code...
13:17:37 <mello_> hmm? toWeekDate $ fromGregorian 2014 1 1 just gives me (2014,1,3)
13:18:19 <monoidal> mello_: that 3 is Wednesday
13:18:58 <mello_> monoidal, yeah i know, the output is correct :) but i was testing what Cale was talking about. However it doesn't really matter since I dont need the year again
13:19:13 <carter> wiat, why does it expect a config file?
13:19:13 <carter> import OpenBLAS.FFI.OpenblasConfig
13:19:21 <enthropy> carter: dunno. I think you should call it a .hsc file. Run the hsc2hs and check out what the macros are expanding to
13:19:47 <enthropy> that's what you're doing, right?
13:21:37 <carter> oooh
13:21:39 <carter> i can't spell
13:21:46 <mello_> monoidal, Cale funny: the output of toWeekDate and WeekDay don't match
13:22:00 <mello_> toWeekDate gives a day that is 1-based (1-7)
13:22:25 <mello_> toEnum $ 1 :: WeekDay
13:22:31 <mello_> -> tuesday
13:22:40 <carter> enthropy: thnks for being patient
13:22:57 <enthropy> no problem. I find this stuff a bit tricky at first too.
13:23:02 <bennofs> Is there a better way to emulate writeIORef with MVars than with modifyMVar_ var (const $ return newVal) ?
13:23:14 <Guest63174> hey guys i wanted to haskell is there any good site where i can beign
13:23:21 <Guest63174> begin
13:23:27 <enthropy> bennofs: that should block if the mvar is empty, no?
13:23:43 <mello_> Guest63174, http://learnyouahaskell.com/chapters
13:23:57 <bennofs> enthropy: Oh right. So is there another way?
13:24:09 * hackagebot clckwrks 0.21.1 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.21.1 (JeremyShaw)
13:24:11 * hackagebot clckwrks-plugin-page 0.3.1 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.3.1 (JeremyShaw)
13:24:14 <enthropy> there are some functions like tryTakeMVar
13:24:39 <Guest63174> mello_ : thanks
13:25:15 <enthropy> bennofs: oh there's a tryPutMVar that seems to be exactly what you want
13:25:40 <bennofs> enthropy: except that it doesn't work when the MVar is full?
13:26:29 <bennofs> I'd like to override any value currently in the MVar
13:29:09 * hackagebot clckwrks-plugin-ircbot 0.6.6 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.6 (JeremyShaw)
13:29:12 * hackagebot clckwrks-plugin-bugs 0.6.6 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.6.6 (JeremyShaw)
13:29:14 * hackagebot clckwrks-plugin-media 0.6.4 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.4 (JeremyShaw)
13:29:18 <enthropy> are you getting problems with:  \v x -> do tryTakeMVar v; tryPutMVar v x
13:30:05 <enthropy> maybe you need to rework things to have two separate mvars (one for input and one for output from this thread)
13:31:31 <bennofs> No, but tryTakeMVar v; tryPutMVar v x; tryPutMVar v y; will block. Is there some way to override the value when there is already some value in the MVar? Hmm, I guess I should use a queue then
13:32:13 <bicgena> http://www.xkcd.com/1312/ was this supposed to be funny :?
13:33:00 <hiptobecubic> bicgena, yes and it's not even his best :)
13:33:19 <bicgena> hiptobecubic: Didja laugh?
13:33:56 <fizbin> I did.
13:34:13 * hackagebot clckwrks-theme-bootstrap 0.3.1 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.3.1 (JeremyShaw)
13:34:13 * hackagebot clckwrks-theme-clckwrks 0.4.1 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-clckwrks-0.4.1 (JeremyShaw)
13:34:16 * hackagebot clckwrks-dot-com 0.3.6 - clckwrks.com  http://hackage.haskell.org/package/clckwrks-dot-com-0.3.6 (JeremyShaw)
13:34:20 <hiptobecubic> bicgena, http://www.explainxkcd.com/wiki/index.php?title=1270:_Functional
13:34:30 <hiptobecubic> ugh, gross link. just read the comic
13:34:37 <hiptobecubic> http://www.xkcd.com/1270/ :)
13:34:47 <fizbin> If you can't laugh at it, you need to reevaluate the place that technological choices have in your life.
13:34:56 <hiptobecubic> the alt-text is what makes it really
13:35:44 <bicgena> fizbin: I do? :p
13:37:27 <k00mi> fizbin: nah, I just don't think it's a good joke
13:39:05 <Tekmo> No such thing as bad publicity
13:39:11 * hackagebot shake 0.11 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.11 (NeilMitchell)
13:39:36 <monoidal> regarding xkcd and haskell, the "umwelt" comic (which changes depending to browser location etc) was written in it.
13:39:44 <monoidal> but I was somewhat disappointed by today's comic.
13:40:10 <rmunroe> monoidal: :(
13:40:27 <rmunroe> monoidal: a number of other things on xkcd.com have haskell backends, too
13:41:56 <Clint> rmunroe: like what?
13:42:30 <simpson> I don't see a problem with it; it's no better or worse than a joke on CCC.
13:42:55 <k00mi> s/haskell/agda/ would have been better
13:46:47 <chrisdone> scotty users -- s'there a way to specify "just serve this as a static directory"?
13:48:36 <chrisdone> seems not. back to snap
13:49:29 <Komier> i am finding it easier to read Haskell now, but thinking in it to come up with my own solutions = aaargh
13:49:46 <mkscrg> I'm playing with ContT and callCC and I'm stuck
13:50:00 <mkscrg> I want to create an early-terminating monad by newtyping callCC. But I can't figure out how to hide the universally quantified return type of the argument function
13:50:05 <startling> Komier: it gets better.
13:50:09 <mkscrg> example: https://gist.github.com/mkscrg/5bd5c0e862542baa66df
13:50:14 <startling> Komier: the learning curve is kind of rough. keep at it!
13:50:16 <mkscrg> Any help is much appreciated
13:50:28 <shachaf> mkscrg: callCC is most likely overkill, for what it's worth.
13:50:41 <mkscrg> Can you elaborate?
13:50:44 <Tekmo> Komier: Is there anything you need help with specifically?  We might be able to help
13:50:52 <Komier> startling: ty, I'm hoping it will kind of "click" eventually like the reading functions did.
13:50:53 <shachaf> Well, you can get "early termination" using just Either, for instance.
13:51:30 <startling> Komier: it does. the big things came to me after learning Reader, State, and the transformer equivalents.
13:51:41 <shachaf> Anyway, why are you using that rank-2 type? That's also probably unnecessary.
13:51:44 <Tekmo> mkscrg: Here's a post about how to break from a loop early using `Either`/`EitherT`: http://www.haskellforall.com/2012/07/breaking-from-loop.html
13:51:57 <startling> then I just look at a problem and think "ok I need MonadState and MonadWriter constraints with MonadError sometimes"
13:52:08 <shachaf> Actually I find it difficult to figure out what you're trying to do. Maybe you should take a step back and explain the goal. :-)
13:52:16 <mkscrg> shachaf ghci suggested RankNTypes
13:52:23 <mkscrg> shachaf sure good idea :)
13:52:28 <Komier> tekmo: Don't think so really.  Just needed to vent a little.  Being new to both programming and to Haskell is interesting. :)
13:52:35 <Tekmo> Komier: Alright :)
13:52:41 <shachaf> Yes, but I mean why are you using that forall.
13:52:56 <chrisdone> i love the smell of haskell newbies in the morning
13:52:57 <Tekmo> Komier: Remember, don't be a perfectionist.  Even if you write "Python in Haskell" it's still a big improvement
13:53:14 <chrisdone> tekmo: a pythectionist
13:53:17 <lispy> > text "Python"
13:53:19 <lambdabot>  Python
13:53:23 <Tekmo> chrisdone: The perfect pythecta
13:53:31 <lispy> Tekmo: it looks like it's still python to me
13:53:43 <lispy> > text "Python in Haskell"
13:53:45 <lambdabot>  Python in Haskell
13:53:53 <Komier> lol
13:54:05 <Taneb> Tekmo, I've been trying to write Haskell in Python and it hasn't gone well
13:54:07 <mkscrg> shachaf the `c` in (a -> Cont a c) is universally quantified, and i'd like to hide it in the newtype
13:54:35 <chrisdone> taneb: did it write back?
13:54:48 <Tekmo> Taneb: About the only thing I can bring to Python from Haskell are sum types, by church-encoding them
13:54:56 <Taneb> chrisdone, it may have done, god knows what side effects happen
13:55:19 <Taneb> Tekmo, the problem is, I saw a problem and thought "The obvious solution involves RWST r w s []!"
13:55:21 <Tekmo> mkscrg: Let me write you a simpler early-termination monad
13:55:37 <Tekmo> mkscrg: I have this code lying around in my projects because it's so small that I never thought it was worth a library
13:56:02 <chrisdone> taneb: now you have three problems?
13:56:23 <Taneb> chrisdone, yeah, it's problematic to say the least
13:56:24 <shachaf> mkscrg: I repeat the thing from before about taking a step back and explaining what your goal is.
13:57:02 <mkscrg> hours ago i was trying to write a handler monad for a web service, in which i could "short circuit" with a fully formed response from anywhere
13:57:51 <chrisdone> mkscrg: that sounds like an excellent way to confuse the hell out of someone trying to read and/or maintain your code. </2cents>
13:58:40 <mkscrg> chrisdone: yeah, no doubt. i got learning about continuations and callCC, and now I'm interested in why it doesn't work
13:59:21 <Tekmo> mkscrg: Did you read my post?
13:59:29 <chrisdone> mkscrg: yup, continuations are like time-travel. really cool and subversive
13:59:55 <chrisdone> but also perverse
14:00:15 <mkscrg> Tekmo yeah, i get that either solves the original problem. i'm now in "why doesn't this work" / learning mode
14:00:29 <shachaf> What's this CA thing supposed to represent?
14:02:09 <egosum> could someone point to some explanation as to why i must do e.g. `dot = (sum .) . zipWith (*)`  and not `dot = sum . zipWith (*)`. I'm not following why the `sum` must be composed with nothing…
14:02:24 <shachaf> egosum: f . g = \x -> f (g x)
14:02:27 <egosum> er, partially applied composition (not even sure what that really means…)
14:02:29 <mkscrg> CA a b   is supposed to be a monad where you can always "short circuit" and return the final result type  a
14:02:39 <shachaf> So sum . zipWith (*) = \x -> sum (zipWith (*) x)
14:02:49 <shachaf> Which is very different from \x y -> sum (zipWith (*) x y)
14:03:02 <shachaf> I recommend not writing things like (f .) . g
14:03:02 <Heffalump> egosum: partially applied composition is like partially applied addition. (5-) is the function that takes x and returns 5-x.
14:03:06 <egosum> shachaf: ah right of course wow
14:03:06 <Tekmo> egosum: The easy to understand these is to just apply both sides to arguments
14:03:12 <Heffalump> IM partially applied subtraction
14:03:15 <egosum> shachaf: just writing it out clears it up hah
14:03:20 <Tekmo> dot x = ((sum .) . zipWith (*) x
14:03:22 <mkscrg> thus why  runCA  requires  CA a a
14:03:27 <shachaf> CA a b = (a -> Cont a Void) -> Cont a b = (a -> (Void -> a) -> a) -> (b -> a) -> a
14:03:45 <Tekmo> dot x = sum . (zipWith (*) x)
14:03:53 <shachaf> If that's a monad it's a very strange one.
14:03:55 <Tekmo> dot x y = (sum . (zipWith (*) x)) y
14:04:03 <Tekmo> dot x y = sum (zipWith (*) x y)
14:04:06 <mkscrg> shachaf ok gotta chew on that...
14:04:18 <mkscrg> maybe it would help if i included the monad instance i had in mind
14:04:30 <shachaf> (I replaced your foralled c with a Void since it's simpler.)
14:04:34 <egosum> Tekmo: got it, thank you!
14:04:45 <Tekmo> egosum: You're welcome!
14:05:32 <Taneb> Wouldn't Either do in this case?
14:05:59 <shachaf> Yes, Either e is a great monad.
14:06:02 <simpson> I don't think that that could be a monad; how would you write the functor instance?
14:06:26 <shachaf> "CA a b" is invariant in a but covariant in b.
14:06:46 <mkscrg> shachaf agreed there
14:07:30 <aleksejs_> Hi, how to avoid stack overflow here http://vpaste.net/jWnZI ?
14:08:05 <pavonia> try foldl'
14:08:43 <Taneb> aleksejs_, try using foldl', like pavonia says, which is in Data.List
14:09:02 <Tekmo> aleksejs_: First, a few tips
14:09:18 <Tekmo> aleksejs_: (\x y -> max x y) == max
14:09:18 * hackagebot hoogle 4.2.28 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.28 (NeilMitchell)
14:09:29 <chrisdone> yay hoogle!
14:09:34 <Tekmo> aleksejs_: Also, Haskell has a `maximum` function
14:09:37 <Tekmo> :t maximum
14:09:37 <lambdabot> Ord a => [a] -> a
14:09:43 <Tekmo> > maximum [1, 2, 3]
14:09:44 <lambdabot>  3
14:09:45 <chrisdone> beware the partiality
14:09:45 <lispy> Tekmo: it's in scope even
14:09:48 <Tekmo> Yeah
14:09:50 <chrisdone> > maximum []
14:09:51 <lambdabot>  *Exception: Prelude.maximum: empty list
14:09:55 <Tekmo> I prefer the safe one from the `safe` package
14:10:04 <chrisdone> ndm++
14:10:44 <aleksejs_> Tekmo, I know, I decided to try max because I thought maximum is the cause of SO
14:10:56 <startling> :t max
14:10:57 <Tekmo> aleksejs_: Also, you can use `iterate` instead of `scanl`
14:10:57 <lambdabot> Ord a => a -> a -> a
14:11:02 <Tekmo> :t iterate
14:11:03 <lambdabot> (a -> a) -> a -> [a]
14:11:04 <startling> oh, I see.
14:11:09 <Tekmo> > iterate (+1) 0
14:11:11 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:11:20 <Tekmo> aleksejs_: In your case you want `iterate next x`
14:11:51 <Tekmo> aleksejs_: Actually, scratch that
14:11:57 <Tekmo> aleksejs_: You want a strict iterate
14:12:10 <Tekmo> aleksejs_: Anyway, first let me explain why your code leaks
14:12:11 <startling> :t next
14:12:12 <lambdabot> RandomGen g => g -> (Int, g)
14:12:16 <startling> :t succ
14:12:16 <lambdabot> Enum a => a -> a
14:12:20 <Tekmo> aleksejs_: So `scanl` is not strict in the accumulator
14:12:28 <monoidal> Tekmo: with foldl' it doesn't leak, no?
14:12:47 <Tekmo> aleksejs_: That means that if you use `scanl` to generate a list of `N` elements the Nth element will have N unevaluted thunks if you never use the values
14:12:51 <aleksejs_> monoidal, yes, foldl' helped
14:12:54 <Tekmo> Oh wait, hold on
14:12:56 <Tekmo> Yeah, I'm wrong
14:13:05 <Tekmo> I just realized the `takeWhile` was evaluating the elements
14:13:19 <mkscrg> shachaf Tekmo updated that gist. laws unproven of course (https://gist.github.com/mkscrg/5bd5c0e862542baa66df)
14:13:33 <nbmnnnm> I'd like to pass the result of 'sizeOf foo :: Int' to a function that accepts 'CSize'. I assume I have to convert 'Int' to 'Word32' since CSize :: Word32 -> CSize. What's the proper way to do so?
14:13:53 <chrisdone> :t fromIntegral
14:13:54 <lambdabot> (Integral a, Num b) => a -> b
14:14:05 <shachaf> mkscrg: I still say the thing about stepping back etc.
14:14:37 <shachaf> That monad instance looks fishy to me. But at any rate I don't even know where this CA type came from or what you're trying to do with it.
14:14:42 <nbmnnnm> chrisdone: Thank you. I checked that but didn't notice Word32 there.
14:15:17 <chrisdone> nbmnnnm: yeah, the instance is likely to be in Data.Word
14:17:13 <mkscrg> shachaf i'm trying to write a monad with a final type a and an intermediate type b, where you can always short circuit and "return" a value of the final type
14:17:17 <roboguy_> the "(forall c. a -> Cont a c)" seems a bit strange to me. what are you doing with c? what *can* you do with c?
14:18:01 <Tekmo> mkscrg: What exactly is the API you want for this monad?
14:18:01 <shachaf> mkscrg: OK. Either does this, right?
14:18:04 <mkscrg> shachaf this monad would basically wrap the     flip runCont id $ \abort -> do …   idiom
14:18:23 <mkscrg> yeah guys i get that either does the job. i'm trying to learn something here :)
14:18:25 <lllllllllllll> how to make f :: x -> y -> z -> r to f :: (x,y) -> z -> r?
14:18:34 <monoidal> lllllllllllll: uncurry f
14:18:41 <Tekmo> mkscrg: Why can't you just define a function: runCA = flip runCont id
14:18:47 <Tekmo> mkscrg: Why do you have to define a new monad?
14:18:53 <chrisdone> lllllllllllll: is that a welsh name?
14:19:15 * hackagebot coordinate 0.0.9 - A representation of latitude and longitude  http://hackage.haskell.org/package/coordinate-0.0.9 (TonyMorris)
14:19:25 <mkscrg> then i have to keep track of that  abort  argument everywhere. pass it to nested values, etc
14:19:51 <lispy> chrisdone: looks swedish to me
14:19:52 <Tekmo> mkscrg: So what you're basically trying to do is reimplement `Either` in terms of `Cont`
14:19:56 <monoidal> forall c. a -> Cont a c == a -> a by Yoneda
14:20:01 <lispy> chrisdone: cf. http://www.youtube.com/watch?v=RqvCNb7fKsg
14:20:01 <monoidal> roboguy_: ^
14:20:23 <Tekmo> mkscrg: Note that all monads can be reimplemented in terms of `Cont`, so you may find this post interesting
14:20:26 <roboguy_> monoidal: that's more or less what I suspected
14:20:30 <Taneb> Tekmo, not all
14:20:36 <Taneb> For instance, IO
14:20:41 <Taneb> But certainly a lot of them
14:20:45 <Tekmo> Well, I mean in the sense that this post describes: http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
14:20:50 <lllllllllllll> thanks monoidal
14:20:53 <link151> what frp library would you guys recommend for an fps
14:20:55 <shachaf> Tekmo: That post is really trying to talk about Codensity, not Cont.
14:21:02 <roboguy_> monoidal: some day, I need to learn Yoneda. I have an idea of the concept, but not the specifics
14:21:10 <Tekmo> link151: It depends.  What is the main reason you wish to use an FRP library?
14:21:18 <monoidal> roboguy_: do you know natural transformations?
14:21:19 <lispy> link151: to be honest, none but frag is quake clone that uses yampa
14:21:21 <Tekmo> shachaf: Correct.  My mistake
14:21:22 <mkscrg> Tekmo I guess? the API i had in mind was   shortCircuit :: a -> CA a b
14:21:30 <henk> Why does hoogle not find the splitOn in Data.List.Split when searching for 'splitOn': http://www.haskell.org/hoogle/?hoogle=splitOn Am I doing it wrong? Does it show up for you?
14:21:35 <roboguy_> monoidal: not really. I know that they are a certain kind of transformation between functors (I think)
14:21:41 <mkscrg> Tekmo which is probably isomorphic to Left :)
14:21:42 <link151> Tekmo: how would you handle input without an frp lib?
14:21:43 <shachaf> henk: Because it's not in base.
14:21:47 <Tekmo> mkscrg: Exactly :)
14:22:04 <monoidal> roboguy_: you've got two functions F, G. a natural transformation is a collection of morphisms F(x) -> G(x) for all x.
14:22:10 <simpson> henk: Hoogle doesn't index all of Hackage, just a small (relatively popular) subset.
14:22:26 <monoidal> roboguy_: those morphisms must "commute" with fmap of F and G
14:22:54 <henk> oh ok … Any similar search engine that does?
14:22:58 <Tekmo> Can I try a layman's description of natural transformations?
14:23:00 <monoidal> roboguy_: now let's suppose you have a natural transformation from Hom(A,-) to some functor F
14:23:04 <Cale> monoidal: functors F and G
14:23:10 <shachaf> henk: Search for "splitOn +split"
14:23:15 <monoidal> Cale: right, sorry
14:23:35 <Tekmo> henk: Hayoo
14:23:39 <roboguy_> monoidal: hmm, alright...
14:23:42 <Tekmo> henk: It indexes all of hackage by default
14:23:45 <Tekmo> henk: I mean
14:23:46 <bennofs> hayoo is down currently :(
14:23:52 <Tekmo> henk: It searches all of hackage by default
14:23:54 <roboguy_> henk: I think the fpcomplete hoogle indexes more than regular hoogle
14:24:02 <Tekmo> henk: Hoogle does index Hackage, but doesn't search all of Hackage by default
14:24:13 <henk> shachaf: Yes, that helps, thank you. But I’d still have to know that package’s name, right?
14:24:15 <monoidal> roboguy_: which means, a collection of morphisms Hom(A,X) -> F(X). if there was no naturality, you could choose arbitrarily each morphism; extremely many possibilities.
14:24:19 <Tekmo> @where hayoo
14:24:20 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html – See also Hoogle: http://haskell.org/hoogle
14:24:57 <Happy0> :o
14:24:59 <shachaf> henk: Hence all the people talking about Hayoo.
14:25:14 <shachaf> henk: You can also set up your own Hoogle which can index whatever you want.
14:25:14 <monoidal> roboguy_: note that if you have such a collection, you can put X = A and you have a morphism Hom(A,A) -> F(A). now look at the image of id under this map.
14:25:17 <henk> Tekmo: ok, thank you, hayoo seems to be down though ):
14:25:24 <monoidal> roboguy_: it is an element of F(A).
14:25:29 <Tekmo> henk: You're right :(
14:26:07 <aleksejs_> thanks for foldl' and iterate, code works now http://vpaste.net/XqiVP and result is correct.But maybe some advices how to make it faster?
14:26:29 <monoidal> roboguy_: the Yoneda lemma states: if you have a collection of morphisms Hom(A,X) -> F(X) which is a natural transformation, *then* it is described uniquely only by that element of F(A). no other degrees of freedom.
14:26:32 <Tekmo> aleksejs_: What's the current speed per element?
14:27:19 <lispy> aleksejs_: First, you should understand why it's slow. That means profiling and studying the code. I can tell you that Integer is slower than Int64 (which is probably large enough?)
14:27:34 <henk> shachaf: hm, sounds good, but also sounds like it might entail wasting a lot of diskspace … does it?
14:28:49 <Tekmo> henk: Let me see if I can get you some sort of estimate.  I install all haddocks by default
14:28:51 <shachaf> Hmm, I don't know. I have infinite disk space.
14:29:18 <lispy> shachaf: you're like google!
14:29:46 <henk> shachaf: Cool, please send me an infinitely large part of that.
14:29:46 <shachaf> lispy: Well, by infinite I mean "hundreds of GB on my laptop's hard drive".
14:29:54 <roboguy_> monoidal: hmm, I'll have to think about that for a bit. Hom(A, X) is all morphisms from A to X right?
14:29:55 <henk> ah /-:
14:30:01 <Tekmo> henk: His disk space is lazily evaluated
14:30:04 <monoidal> roboguy_: Yes. It's a set.
14:30:14 <chrisdone> hoogle's the most underutilized tool in the haskell repertoire
14:30:30 <monoidal> roboguy_: we look at functions from that set to the set F(X).
14:30:32 <shachaf> I don't need Hoogle, anyway. I just remember where everything is.
14:30:40 <startling> ^
14:30:43 <Fylwind> is there a way to print unicode characters to stdout on Windows?
14:30:46 <henk> Tekmo: bah, that’s cheating ):
14:30:58 <chrisdone> 'Never memorize something that you can look up.' — Einstein
14:31:04 <lispy> Fylwind: You have to change the code page.
14:31:14 <Tekmo> I prefer to Google for `hackage <function/package>`
14:31:37 <chrisdone> tekmo: imo that's a symptom of hoogle's underutilization
14:31:40 <Tekmo> Unless the search is by type signature, then I need Hoogle
14:31:45 <startling> I just installed @hackage on my brain.
14:31:47 <Fylwind> lispy: you mean SetConsoleCP?
14:31:50 <lispy> Fylwind: chcp.com 65001
14:31:59 <chrisdone> it should be far easier to use hoogle to search all of my installed packages and to search all of my current project
14:32:05 <chrisdone> but it's not, so nobody does it
14:32:22 <lispy> Fylwind: I'm not sure how it will work if you do it programmatically. I've always used chcp.com first and then run the program
14:32:36 <Tekmo> It needs to be as simple as `aptitude install hoogle`
14:33:00 <startling> chrisdone: yeah, agreed.
14:33:08 <chrisdone> this is needed imo https://github.com/haskell/cabal/issues/395#issuecomment-29363689
14:33:13 <Fylwind> I don't suppose that would work if I called it inside the program?
14:33:40 <lispy> Fylwind: It's worth a try.
14:33:49 <chrisdone> tl;dr: add a hoogle: True setting in your .cabal/config to auto generate hoogle entries into a big hoogle index whenever you cabal install something, just like haddock
14:35:19 <aleksejs_> ok, I see, that my solution is not slowest :)
14:35:45 <aleksejs_> http://projecteuler.net/thread=14
14:36:26 <roboguy_> monoidal: that sort of makes sense. I'm not sure I see the full connection to Haskell types though
14:36:49 <aafdsf> Can I use CString where C uses Ptr CUChar?
14:37:15 <Tekmo> :info CString
14:37:22 <Tekmo> Damn, thought that would work
14:37:30 <aafdsf> type CString = Ptr CChar 	-- Defined in `Foreign.C.String'
14:37:32 <Tekmo> If I remember correctly, CString is `Ptr CChar`
14:37:46 <monoidal> roboguy_: imagine you have a function forall a. (Int -> a) -> [a]
14:37:47 <lispy> :t castPtr
14:37:48 <lambdabot> Not in scope: `castPtr'
14:37:54 <lispy> @hoogle castPtr
14:37:54 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
14:37:54 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
14:37:54 <lambdabot> Foreign.StablePtr castPtrToStablePtr :: Ptr () -> StablePtr a
14:37:54 <monoidal> roboguy_: how could that function work?
14:38:05 <donri> @info CString
14:38:05 <lambdabot> CString
14:38:12 <monoidal> roboguy_: can you give an example of a function of this type?
14:38:43 <Tekmo> roboguy_: You might also want to read this if you haven't already: http://blog.sigfpe.com/2006/11/yoneda-lemma.html
14:38:46 <ashnur> i know i am late for this, but what did you say when you saw today's xkcd? :D
14:38:57 <aafdsf> Tekmo: So can I use withCString to pass String to the function that accepts Ptr CUChar?
14:39:04 <Komier> Hmm.. is my function type definition wrong if the compiler doesn't throw up an error, but it would infer a different type itself? (If I left it undefined)
14:39:07 <chrisdone> ashnur: “…that's it?”
14:39:08 <roboguy_> monoidal: how about: mystery f = map f [0..]
14:39:20 <Tekmo> aafdsf: lispy was trying to point out that yyou can use `castPtr` to case that ptr to the correct type
14:39:21 <monoidal> roboguy_: yes, do you see others?
14:39:23 <henk> Tekmo: Are you doing the estimation on hoogle size?
14:39:40 <Tekmo> aafdsf: Just keep in mind that unsigned chars and signed chars are slightly different for the top 128 values, so that caveat applies
14:39:56 <roboguy_> monoidal: you mean stuff like mystery f = [f 3, f 10]?
14:40:07 <Tekmo> henk: I am.  I'm just trying to figure out where they are installed
14:40:18 <monoidal> roboguy_: Yes. so mystery has to produce "a", and the only way to do it is by calling on int arguments.
14:40:19 <chrisdone> tekmo: extra fun: `char' in c may be unsigned or signed depending on the implementation
14:40:37 <monoidal> roboguy_: But now *I* have mystery. You can call it. now, how would you find its formula?
14:40:38 <roboguy_> monoidal: right
14:40:50 <Tekmo> chrisdone: Yeah, I know
14:40:56 <aafdsf> lispy, Tekmo: Thanks, I'll try 'castPtr'.
14:41:26 <roboguy_> monoidal: how about mystery id?
14:41:31 <ashnur> chrisdone: :-S
14:41:42 <monoidal> roboguy_: good! e.g. you would get [0..] and [3,10] in your examples.
14:42:01 <monoidal> roboguy_: so the type forall a. (Int -> a) -> [a] carries the same data as [Int]
14:42:12 <henk> Tekmo: ah, ok
14:42:24 <roboguy_> monoidal: that makes sense
14:42:30 <monoidal> roboguy_: in symbols from Yoneda lemma, A = Int, F = [] functor, and you saw passing identity to recover what is the mystery.
14:42:37 <Tekmo> henk: So the haddocks I have installed for quite a bit of libraries are about 152 M
14:42:37 <jonasw> At least GCC and Clang have -f(un)signed-char
14:42:49 <Tekmo> henk: I don't know how big the hoogle index files would be in comparison, but that might give you some reference point
14:43:00 <henk> Tekmo: Are you on debian? How did you install those haddocks?
14:43:15 <Tekmo> henk: I just added `enable-documentation: True` to my ~/.cabal/config file
14:43:26 <Tekmo> henk: That generates the haddocks automatically every time I install a package
14:43:49 <startling> funsigned chars are the most fun signed chars
14:43:51 <Tekmo> henk: You can also get haddocks for Haskell platform packages by installed the `haskell-platform-doc` package
14:43:58 <aafdsf> Tekmo: Also, is it OK to import a vararg function via ccall and make it accept a fixed number of arguments?
14:44:12 <henk> oh ok, I don’t even use cabal really yet and install most packages only from the debs …
14:44:37 <boom583> What's the equivalent to OO subclasses in Haskell? Say you have a function boom :: Vehicle -> String but you also have Car which is a Vehicle. Car has its own funcs, but boom works for Car because it's a Vehicle. Is this possible in Haskell?
14:44:44 * enthropy has 715M in ~/.cabal/share/doc
14:44:52 <simpson> boom583: Typeclasses.
14:44:55 <henk> Tekmo: Thank you
14:45:14 <Tekmo> henk: You're welcome
14:45:26 <Tekmo> aafdsf: I'm not sure.  You might want to refer to this: http://stackoverflow.com/questions/5989457/haskell-ffi-support-for-functions-with-variadic-arguments
14:45:40 <boom583> simpson: ok so what's the point of OO? haskell seems to have all the benefits of OO
14:45:44 <enthropy> @where OOHaskell
14:45:44 <lambdabot> http://homepages.cwi.nl/~ralf/OOHaskell/
14:45:46 <aafdsf> Tekmo: OK, will do.
14:45:51 <startling> boom583: exactly. :)
14:45:58 <roboguy_> monoidal: that makes more sense. thanks!
14:46:21 <simpson> boom583: "Objects are bundles of state and behavior." Object-oriented stuff isn't interesting; object-based stuff is interesting.
14:46:30 <Tekmo> boom583: Before lenses I would have said OO's better support for managing shared state, but now that lenses make it easy to manage complex state I wouldn't say that any more
14:46:41 <simpson> boom583: If you've never touched Smalltalk, or E, it's worth taking a look at.
14:47:33 <enthropy> @where+ OOHaskell http://arxiv.org/abs/cs/0509027
14:47:33 <lambdabot> Okay.
14:48:08 <startling> I don't know. OO makes it easier to manage arbitrary hidden state.
14:48:15 <Dullahb> :users
14:48:17 <startling> you need an extension or two to do it with Haskell.
14:48:24 <monoidal> roboguy_: for natural transformations, you might read http://blog.sigfpe.com/2008/05/you-could-have-defined-natural.html
14:48:29 <aafdsf> Tekmo: Currently, I use foreign import ccall "foo" foo :: A -> A -> IO (A).  The C version accepts multiple As.  I've been told that's fine, but now I'm not quite sure.
14:48:30 * yogurt_truck avoids the mad forests of mutability that are smalltalk codebases
14:48:35 <boom583> ok
14:48:40 <Tekmo> aafdsf: Try it and see if it works
14:48:42 <boom583> simpson: I'm a Obj-C coder
14:48:46 <boom583> but that's OO
14:48:55 <simpson> boom583: Ah, so you're acquainted with Smalltalk-like idioms, then.
14:49:21 <boom583> supposedly they got the syntax from smalltalk. not sure about any other "idioms"
14:49:34 <simpson> When you get to systems where *everything* is an object, not just the fancy structs, then something truly magical happens, but I can't really explain it in short manner, and not in this channel. :3
14:49:46 <boom583> ok
14:49:58 <Komier> Anyone mind commenting on my function please?    peri :: Float -> Float -> Float
14:49:58 <Komier> peri n r = n * len
14:49:58 <Komier>     where len = sin(pi / n) * 2 * r
14:49:59 <Tekmo> simpson: Just try.  It might inspire us with neat ideas :)
14:50:17 <philed> boom583: Typeclasses won't give you heterogeneous lists.
14:50:19 <Tekmo> Komier: Why not just inline `len`?
14:50:20 <simpson> Tekmo: Eh, I tend to get into nasty arguments in here on account of not loathing dynamic typing. :c
14:50:25 <simpson> Anyway, E. That is all.
14:50:25 <yogurt_truck> simpson: that magic did not magically come to being in JS apparently
14:50:29 <Tekmo> Komier: per n r = n * sin (pi / n) * 2 * r
14:50:34 <boom583> philed: oh damn really?
14:50:39 <boom583> hmm
14:50:40 <Tekmo> simpson: Oh well :(
14:51:14 <simpson> yogurt_truck: Haha, yeah, prototype-based systems are always kind of iffy 'cause the flexibility causes people to forget to structure stuff.
14:51:24 <simpson> Also wow, JS's types just do *not* make sense. :c
14:51:26 <philed> boom583: Nah. There's no subtyping in Haskell, as you have in OO languages.
14:51:39 <boom583> so what do you do if you want that in haskell
14:51:46 <Tekmo> philed: Well, there is the existential quantification trick
14:51:53 <Fylwind> is there a way do conditionals in the .cabal file to check if Windows is the OS?
14:51:54 <Komier> Tekmo : hah yeh that is a bit easier.  With regard tot he type def..... is that ok?  If I define the function in ghci it comes back with something quite different
14:52:12 <startling> there's sort of subtyping
14:52:26 <startling> there's subclasses, and yeah, the existential type thing.
14:52:27 <philed> boom583: For your strings case, it's not really a big deal.
14:52:30 <Tekmo> Komier: type synonyms do not necessarily "stick"
14:52:42 <simpson> boom583: class Boom t where { boom :: t -> String }; class (Boom t) => Car t where { drive :: t -> String }
14:52:51 <Tekmo> Komier: If you want it to stick you should use a `newtype`
14:52:55 <simpson> boom583: Or something along those lines. I probably flubbed syntax.
14:53:05 <philed> boom583: If you want a list of objects that have a "toString" method, just have a list of strings!
14:53:11 <Fylwind> lispy: didn't check calling chcp.com, but calling SetConsoleCP 65001 via FFI worked
14:53:17 <Fylwind> lispy: thanks for the help
14:53:28 <Tekmo> philed: That's usually the right solution for most problems
14:53:28 <Komier> Tekmo: Ok, but as long as I'm not throwing up any errors, and it works, it's not inherently "wrong"?
14:53:36 <boom583> interesting
14:53:36 <lispy> Fylwind: excellent! Thanks for reporting back.
14:53:38 <Tekmo> philed: However, there are more pathological cases where you need ExistentialQuantification
14:53:42 <yogurt_truck> boom583: beware of approaching haskell with a "what's the haskell equivalent of *another language's semantics*", btw. it's maybe useful when you're _just_ getting started, but then you should just learn the FP/haskell/etc way of solving problems, directly
14:53:56 <boom583> yogurt_truck: good advice
14:53:57 <Tekmo> philed: But yeah, I usually try to see if people can do the obvious trick of just using the final encoding of the type class
14:54:11 <Tekmo> Komier: It's not wrong at all to use type synonyms
14:54:16 <Tekmo> Komier: Think of them as documentation
14:54:39 <Komier> tekmo: Ok thanks.  :)
14:54:55 <Tekmo> Komier: They have no impact on the behavior of the program.  They just change the way the type appears that might be more informative for people studying the API
14:55:16 <Tekmo> You're welcome!
14:56:09 <Tekmo> I agree with `yogurt_truck`.  A better approach to Haskell is to think in terms of how to structure problems along the mathematical type classes like `Monoid`/`Functor`/etc.
14:56:26 <philed> Tekmo: I like the semantics of existential quantification. Abstract types have existential type and all.
14:56:33 <boom583> thanks, back to LYAH
14:56:35 <Tekmo> philed: Yeah, I think it's good
14:56:45 <Tekmo> philed: I wish Haskell had an `exists` keyword, though
14:56:54 <Tekmo> philed: Of course, I have no idea what that would actually entail
14:57:07 <aafdsf> Tekmo: The GHC doesn't complain about that import, but the code that deals with that function segfaults in most cases.  I'm trying to investigate whether the import could be the cause.
14:57:11 <monoidal> Tekmo: fyi UHC has 'exists', though I've never used it.
14:57:23 <Tekmo> monoidal: Oh really?  That's neat!
14:57:41 <philed> But, without some sugar, you're having to upcast explicitly, which you don't do in languages with subtypes (not that I want subtypes)
14:58:12 <shachaf> Figuring out the proper behavior of first-class existentials seems tricky to me.
14:58:24 <shachaf> Even if you don't allow type classes (as UHC doesn't).
14:59:00 <shachaf> Hmm, with ConstraintKinds you can declare data c *> a = c => Foo a
14:59:15 <shachaf> And then you could write (exists a. Show a *> a)!
14:59:18 <S11001001> shachaf: I think the quantifiers can move freely over covariant positions, as with universals
14:59:34 <S11001001> wait, no
14:59:35 <aafdsf> Tekmo: I've read the linked SO page.  Does augustss imply to use what I'm currently using?
14:59:40 <shachaf> S11001001: Maybe it's just inference that's not obvious to me.
15:00:01 <philed> boom583: One reason you want to think carefully about this stuff is because some of the idioms don't translate in a one-one way. OO is often used for writing modular code, and Haskell has its own ways of doing that. A standard way, for instance, to do heterogeneous lists, when you don't expect to be able to extend types across module bonudaries, is just to use an algebraic data type.
15:00:04 <shachaf> But I think the behavior in general is trickier than it seems at first.
15:01:06 <Tekmo> aafdsf: Yeah, that seems like it's the same thing
15:01:15 <startling> you often don't need heterogenous lists in Haskell.
15:01:23 <Tekmo> aafdsf: So my intuition was that giving it a specific number of arguments would have worked
15:01:29 <boom583> philed: ok
15:01:33 <startling> e.g. if you want a list of Showable things, you might as well have a list of Strings.
15:01:37 <philed> startling: I hope not, since they don't exist :)
15:01:42 <Tekmo> aafdsf: From the C side, this should have been okay since C function prototypes are just "recommendations"
15:01:49 <tertl3> i am looking for a yesod framework person
15:01:52 <monoidal> shachaf: UHC has type classes (or at least had in the past); don't how powerful they are though.
15:02:02 <boom583> startling: you mean create a func that returns strings and relies on the laziness?
15:02:07 <philed> tertl3: #yesod?
15:02:07 <shachaf> monoidal: It has type classes but doesn't allow exists with type classes.
15:02:18 <monoidal> shachaf: ah I see.
15:02:19 <Tekmo> aafdsf: However, I'm not sure how C translates vararg function prototypes or if it changes the semantics of function invocation
15:02:22 <startling> philed: sure they do. ExistentialQuantification.
15:02:41 <shachaf> monoidal: But of course that would need something like *> anyway.
15:02:50 <boom583> looking forward to writing actual apps with haskell
15:03:05 <boom583> first gotta read whole LYAH though. at least the IO chapters
15:03:09 <boom583> even the monads too
15:03:16 <philed> startling: Those aren't heterogeneous lists. A list whose type is an existential is still homogeneous.
15:03:38 <startling> philed: that sounds like a useless distinction.
15:04:10 <Tekmo> startling philed: I think the important question is, what would one want to do with heterogeneous lists that cannot be accomplished using existential quantification + homogeneous lists?
15:04:19 <startling> ^ yeah
15:04:47 <philed> startling: A heterogeneous list is one where the values have different types.
15:05:34 <startling> philed, data Heterogenous = Null | Cons (forall a. Show a => a) Heterogenous
15:05:49 <philed> That *is* an important question, and you can generally translate programs that use heterogeneous lists into ones that use existential types. But that doesn't mean they're the same thing.
15:05:52 <startling> this can be nicer with that one extension I can't remember.
15:06:14 <shachaf> startling: "(forall a. Show a => a)" is an even more useless type than "(exists a. Show a *> a)"
15:06:28 <startling> shachaf, maybe I spelled it wrong. I always forget how foralls work.
15:06:50 <monoidal> startling: .. | forall a. Show a => Cons a Heterogenous
15:07:00 <startling> monoidal: ah.
15:07:27 <erisco> Cale, I am quite sad :( I am less confident now that direct graphs make any sense
15:07:35 <boom583> are monads very important for most haskell apps?
15:07:43 <dropdrive> Do people ever use, say, GADTs/typeclasses to prototype some code, and then codegen the functions/types into some over language (say Java) for actual implementation?  (Assuming that translating the implementations is difficult.)  Or is this fundamentally impossible?
15:07:58 <shachaf> boom583: The Haskell FAQ has good answers to your questions.
15:08:00 <shachaf> @where FAQ
15:08:00 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
15:08:06 <erisco> Cale, simple algorithms like depth first search only go from O(nlogn) to O(log(n!))
15:08:19 <erisco> which is typically simplified to O(nlogn) anyways :P
15:08:27 <monoidal> it's the same thing
15:08:31 <ocharles> mm_freak: hey, wanna chat about (dynamic) collections in netwire tonight?
15:08:40 <boom583> ok thanks
15:08:43 <Tekmo> boom583: So it depends on the type of Haskell application
15:08:53 <ocharles> I know you mentioned that netwire has different switches than Yampa, but it'd be nice to expand on why that is/what that implies
15:10:03 <Tekmo> boom583: Remember that `Monad` is an interface for programming generically
15:10:29 <ocharles> shachaf: remind me, what does Cons (forall a. Show a => a) mean?
15:10:52 <Tekmo> boom583: In theory, everything you can do with the `Monad` interface you can do with the equivalent concrete functions specialized to that type.  The exception is the `IO` monad where concrete versions of `return` and `(>>=)` are not exported and the `Monad` interface is the main interface
15:10:56 <erisco> why does everyone not use finger trees instead of lists?
15:10:57 <shachaf> ocharles: Imagine my library exports "foo :: Show a => a"
15:10:59 <philed> ocharles: I believe the forall is in the wrong place for existential datatypes.
15:11:00 <shachaf> ocharles: What does that mean?
15:11:01 <boom583> ok
15:11:15 <shachaf> ocharles: Or, in particular, what can you do with it?
15:11:16 <Tekmo> erisco: Lists are more optimal for the cases where you only operate on the head
15:11:21 <ocharles> shachaf: presumably that you can show it?
15:11:31 <Tekmo> erisco: Also, lists have build/foldr fusion
15:11:32 <ocharles> shachaf: I don't know what "it" is, but whatever you decide to give me, I can show
15:11:39 <croyd> dropdrive: http://smaccmpilot.org/languages/ivory-introduction.html#
15:11:47 <erisco> Tekmo, not by time complexity are they?
15:11:53 <erisco> Tekmo, what does build/foldr fusion mean?
15:11:56 <Tekmo> erisco: No, just constant factors
15:11:57 <shachaf> ocharles: Well, it means that you can pick any type you like, as long as it has a Show instance, and use foo as if it hsa that type.
15:12:09 <Tekmo> erisco: build/foldr fusion is a trick that the list libraries use to eliminate intermediate lists when possible
15:12:23 <shachaf> ocharles: For example, you can define «instance Show Void where show _ = "<Void>"»
15:12:28 <Tekmo> erisco: Haskell has a neat rewrite rule system that lets you transform code, typically to improve its performance
15:12:31 <shachaf> ocharles: And now foo :: Void
15:12:34 <ocharles> shachaf: oh right, the caller decides a
15:12:41 <erisco> Tekmo, you mean reverse . reverse becoming id?
15:12:42 <ocharles> shachaf: not foo itself
15:12:51 <shachaf> This isn't a function, so there's no "caller" exactly, but yes.
15:12:57 <ocharles> right
15:13:08 <shachaf> If I give you "... :: forall a. ...", *you* decide a.
15:13:13 <shachaf> If I give you "... :: exists a. ...", *I* decide a.
15:13:18 * ocharles nods
15:13:27 <Tekmo> erisco: Many list functions are implemented either in terms of `build` (to build lists) or `foldr` (to consume lists), and there's a rewrite rule saying that if something is `build`ing a list and another thing is `foldr`ing that same list you can fuse away the intermediate list, leaving behind a more efficient computation
15:13:30 <shachaf> This means that forall behaves like a function and exists behaves like a tuple.
15:13:49 <shachaf> For example, if I give you "... :: Int -> ...", that means *I* decide the Int.
15:13:53 <erisco> Tekmo, so ghc has optimisations specific to lists
15:14:01 <Tekmo> erisco: Not ghc, but rather `Data.List`
15:14:02 <shachaf> Er, no.
15:14:09 <shachaf> If I give you "... :: Int -> ...", that means *you* decide the Int.
15:14:20 <boom583> this FAQ is a gold mine
15:14:21 <shachaf> Whichever Int you give me, I have to give you a "..."
15:14:22 <erisco> how does one specify these rewrite rules in a library?
15:14:25 <Tekmo> erisco: If you browse through the source of `Data.List` (or maybe it is `GHC.List`) you will see these rewrite rules in the source code
15:14:25 <shachaf> If I give you "... :: (Int, ...)", that means *I* decide the Int.
15:14:26 <ocharles> shachaf: ok, with you there
15:14:38 <Tekmo> erisco: `ghc` proper is not list-aware.  Rather the rewrite rules that libraries provide are how you implement optimizations
15:14:43 <shachaf> So forall is like a function and exists is like a tuple.
15:14:53 <philed> ocharles: Given: data HList = Null | forall a. Show a => Cons a HList
15:14:59 <Tekmo> erisco: You will find these rewrite rules in source code and they will look like this: `{-# RULES ... #-}`
15:15:07 <shachaf> Except it's a special kind of function because the "..." can use "a".
15:15:11 <erisco> Tekmo, so they are compiler directives
15:15:14 <ocharles> shachaf: ok, so if you have cons (forall a. Show a => a), then you can't actually put anything there, because the "caller" can choose what it is?
15:15:15 <philed> ocharles: The type of Cons is Show a => a -> HList -> HList
15:15:21 <Tekmo> erisco: Correct
15:15:31 <philed> ocharles: But there's more magic going on because you need to be able to pattern match.
15:15:38 <Tekmo> erisco: This is a nice trick you can use to speed up a library without making any breaking changes
15:15:51 <shachaf> philed: That's not the type we're talking about.
15:16:12 <shachaf> We're talking about the broken list, data ... = ... | Cons (forall a. Show a => a) ...
15:16:13 <Tekmo> erisco: If you can prove that a certain combination of functions has a more efficient implementation, just add a rewrite rule that transforms them to the more efficient implementation and you automatically speed up all downstream code for free
15:16:25 <shachaf> Where Cons :: (forall a. Show a => a) -> List -> List
15:16:34 <erisco> Tekmo, is it not possible to add these little speedups to fingertree?
15:16:38 <shachaf> But I recommend forgetting about the list. It's just making life complicated.
15:16:40 <philed> Oh.
15:16:44 <dropdrive> croyd: That looks very interesting, thanks.  Any other links appreciated :)
15:16:59 <Tekmo> erisco: Yes, sort of
15:17:01 <ocharles> shachaf: I'm happy to forget that this is a list and consider data Foo = Foo (forall a. Show a => a)
15:17:20 <shachaf> OK.
15:17:27 <ocharles> so that's data Foo = (forall a. Show a => a) -> Foo ?
15:17:31 <shachaf> Or sometimes even forget Foo entirely and just treat the values as first-class. :-)
15:17:36 <shachaf> Or not.
15:17:38 <philed> "undefined" then.
15:17:39 <ocharles> Erm, with a constructor name
15:17:48 <shachaf> ?
15:17:54 <shachaf> Are you trying for GADT syntax?
15:17:54 <ocharles> data Foo where Foo :: (forall a. Show a => a) -> Foo
15:17:57 <ocharles> that's what I was going for
15:18:03 <Tekmo> erisco: However, finger trees would still have slower constant factors for the cases where you don't optimize away the data structure with a rewrite rule
15:18:08 <ocharles> I think I wrote GADT syntax properly there
15:18:09 <croyd> dropdrive: sadly that's the extent of my knowledge in the area. But it is quite interesting
15:18:12 <shachaf> OK. Yes.
15:18:30 <Tekmo> erisco: And it's not trivial to optimize away every possible computation using rewrite rules
15:18:46 <philed> Though (forall a. Num a => a) makes sense.
15:18:47 <shachaf> ocharles: Maybe we should go to #-overflow.
15:19:23 <ocharles> shachaf: sounds good
15:20:14 <erisco> Tekmo, it seems performance is more competitive than I thought in Haskell
15:20:30 <Tekmo> erisco: It is decent
15:21:41 <Tekmo> erisco: For everything other than numerical code it is good enough for most purposes
15:22:04 <Tekmo> erisco: And for the cases where it's not, that's what the FFI is for
15:23:18 <dropdrive> croyd: I probably am looking for something nowhere near as powerful -- I want to write some types and get some boilerplate generated for me :)
15:23:32 <erisco> Tekmo, I am trying to legitimise a graphing approach but the gains on certain algorithms are marginal. A depth first search, for instance, can be done in O(log(n!)) time, which is not much better than the typical O(nlogn)
15:24:05 <erisco> Tekmo, so I am trying to gauge just how valuable these things are. I suppose it comes down to careful benching.
15:24:31 <Tekmo> erisco: log(n!) ~ n log n - n
15:24:55 <Tekmo> I consider those two time complexities identical
15:25:06 <erisco> Tekmo, is it a constant factor difference?
15:25:37 <Tekmo> erisco: It helps to rewrite it as:
15:25:48 <Tekmo> log(n!) ~ n * (log n - 1)
15:25:59 <Tekmo> So I consider it to be essentially the same thing as n * log n
15:26:14 <erisco> yes but is it proportional? I did not think it was
15:26:34 <Tekmo> The proportion is (log n - 1) / log n
15:26:35 <erisco> iirc it is a gross simplification
15:26:46 <Tekmo> It's very accurate for even most N
15:26:48 <Tekmo> *modest N
15:27:03 <Tekmo> Try it for a few values of N to see for yourself
15:28:27 <monoidal> erisco: you don't need values to be proportional to use big O. O(nlogn) is exactly the same thing as O(log(n!))
15:28:52 <Tekmo> Right, O(n log n) outweight O(n)
15:28:55 <erisco> monoidal, not by any definition of big-O I have seen
15:28:56 <Tekmo> *outweighs
15:29:11 <monoidal> erisco: by all definitions I have seen.
15:29:20 <erisco> but I have seen simplification of n! ~ n^n
15:29:31 <monoidal> O(n!) is *not* O(n^n)
15:29:46 <erisco> I did not say it was
15:30:03 <Tekmo> However, O(log (n!)) is equivalent to O(log (n^n))
15:30:28 <monoidal> O(n!) is the same thing as O((n/e)^n sqrt(2pin))
15:30:50 <Tekmo> Anyway, the point is that I doubt the time complexity is different enough for your purposes
15:30:54 <erisco> anyways at one million nlogn is 7.8% larger
15:31:41 <dolio> At all n, 5n is 25% larger than 4n.
15:32:10 <erisco> yes but it is not constant between nlogn and log(n!)
15:32:16 <monoidal> it is!
15:32:18 <erisco> the approximation seems to improve as n grows
15:33:04 <Tekmo> erisco: The diffence between n log n and log (n!) is n, which is outweighed by the n log n
15:33:34 <Tekmo> erisco: Big-O analysis is all about things in the asymptotic limit, which is why we ignore the additional `n` term the differentiates `n log n` from `log (n!)`
15:33:36 <erisco> Tekmo, mm I see. I guess I'd have to look more carefully at the derivation
15:33:54 <monoidal> anyway, the point is that since the algorithms have the same asymptotic complexity, constants matter and then you can look at that 7.8%.
15:34:00 <erisco> Tekmo, yes indeed
15:34:28 <Tekmo> Yes, but 7.8% seems like high-hanging fruit
15:34:43 <erisco> Tekmo, what do you mean by that?
15:34:54 <Tekmo> erisco: There may be easier optimizations than that which give greater gains
15:35:27 <erisco> Tekmo, other than fixed size data structures, no, I do not think there is, but I'd be glad to know otherwise
15:35:33 <Tekmo> erisco: Speaking of which, what exactly is the algorithm we are optimizing?
15:35:49 <erisco> I was looking at depth first search as an example
15:36:30 <Tekmo> That's still a bit broad
15:36:43 <erisco> for cyclic graphs
15:36:52 <Tekmo> How are you encoding the graph?
15:38:23 <erisco> Tekmo, directly (ie tying the knot)
15:38:35 <Tekmo> So that's not actually encoding a cyclic graph
15:38:39 <Tekmo> You're actually encoding a tree
15:38:40 <erisco> yes it is
15:39:12 <Tekmo> Well, let me illustrate the problem
15:39:21 <Tekmo> Here's a simple "cyclic list" encoded using tying the knot
15:39:26 <Tekmo> ones = 1:ones
15:39:50 <Tekmo> However, there is nothing truly cyclic about it
15:40:11 <erisco> I do not understand what you are getting at
15:40:13 <Tekmo> We can't update" the first one and expect to see the change reflected in subsequent ones
15:40:24 <Tekmo> We can't "update" the first one and expect to see the change reflected in subsequent ones, because theres' no concept of updating values in Haskell
15:40:46 <erisco> I still do not know what you mean
15:41:01 <erisco> yes you cannot mutate values in Haskell, but I do not see how it makes it less cyclic
15:41:20 <Tekmo> I guess it's more accurate to say that it's not cyclic for the purpose of updates
15:41:28 <Tekmo> It's cyclic if the only thing you plan on doing is reading
15:41:36 <erisco> *shrug* I really do not know what you mean
15:41:52 <Tekmo> Let me give an example
15:41:59 <nexx> If there is no updating, why are you discussino updating?
15:42:13 <Tekmo> I mean updating in the Haskell sense of creating a new data structure with a new field in its place
15:42:46 <erisco> Tekmo, to update a part of the cyclic structure you'd replace the entire structure
15:42:55 <Tekmo> erisco: Right, but this is very inefficient
15:43:10 <erisco> but you are talking about whether it is cyclic or not
15:43:17 <Tekmo> erisco: Okay, fine
15:43:18 <erisco> replacing the last item of a list is inefficient too
15:43:20 <erisco> but we still use lists
15:43:37 <Tekmo> erisco: But in the case of a cyclic list there is a more efficient representation
15:44:02 <Tekmo> erisco: You just encode the repeating unit and only interact with that, only converting it to a list irreversibly as late as possible
15:44:06 <erisco> yeah quite possibly if you just look at the big-O
15:44:16 <Tekmo> erisco: No, not just big-O
15:44:25 * hackagebot bitcoin-rpc 0.5.0.0 - Library to communicate with the Satoshi Bitcoin daemon  http://hackage.haskell.org/package/bitcoin-rpc-0.5.0.0 (JanVornberger)
15:44:27 * hackagebot mtgoxapi 0.5.0.2 - Library to communicate with Mt.Gox  http://hackage.haskell.org/package/mtgoxapi-0.5.0.2 (JanVornberger)
15:44:36 <Tekmo> erisco: "Updating" a structure built by tying the knot incurs significant constant factors in performance
15:44:38 <erisco> Tekmo, it depends on what operation you are talking about
15:44:47 <Tekmo> erisco: The reason why is that `ghc` is really bad at optimizing recursive code
15:45:06 <erisco> to say representation A is more efficient than representation B without any context of what algorithm we're talking about, then my only assumption is any algorithm
15:45:52 <benmachine> Tekmo: I'd prefer to phrase it as optimising recursive code being pretty hard :P
15:46:08 <Tekmo> benmachine: The issue is that recursive code throws valuable information away
15:46:11 <benmachine> right
15:46:25 <benmachine> sharing is not observable, but has serious operational effects
15:46:39 <benmachine> serious performance implications, I mean
15:47:44 <erisco> anyways it seems the margins are going to be very thin if present at all, so I suppose the only reasonable thing to do is benchmark
15:48:51 <Tekmo> erisco: So anyway, how are the nodes of the graphs encoded?
15:49:11 <erisco> id, data, and outgoing edges
15:49:21 <Tekmo> What's the data structure you use for storing outgoing edges?
15:49:26 * hackagebot cookbook 2.1.0.0 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-2.1.0.0 (NatePisarski)
15:49:28 <aristid> Tekmo: how would you model a file that allows skipping a number of bytes forward, but no backward seeking, using pipes?
15:49:39 <erisco> data, head (the vertex at the head)
15:49:50 <aristid> (the number of bytes can be specified by the user)
15:50:06 <erisco> but my only question in this is whether or not the representation has any tangible improvement in any algorithm at all
15:50:11 <erisco> over an indirect representation
15:50:28 <Tekmo> aristid: type Request = Maybe BytesToSkip, then it would be `Request -> Server Request ByteString IO ()`
15:50:51 <Tekmo> aristid: The idea is that `Nothing` just means draw more bytes, and `Just` means to skip that many bytes and simultaneously draw after that skip
15:50:56 <aristid> Tekmo: and then it would just return the next chunk directly in response to the skip request?
15:51:00 <Tekmo> aristid: Right
15:51:16 <Tekmo> aristid: Alright, I have to head out
15:51:23 <aristid> Tekmo: o, cool thanks
15:51:27 <Tekmo> If you have any more quesitons, feel free to e-mail me
15:51:31 <erisco> and when I look at depth first search, the complexity ends up as log(n!), and I did not recall that being asymptotically the same as nlogn, but I see that you are right
15:52:04 <erisco> so the question for me then is whether or not that difference is significant, which would have to be benched
15:52:54 <erisco> Tekmo, but yes, the representation is poor for piecemeal updating. It is intended for operations which affect the entire graph
15:56:10 <kngghst[ATL]> i heard this channel is kickin
15:57:32 <benmachine> it's rad
15:57:58 <kngghst[ATL]> k bye
15:57:58 <Komier> Aye, tis pretty good.
16:00:15 <arach_> i a
16:02:07 <bernalex> anyone know how to use javascript with hakyll? I have an html site, so I tried just using <script>, but nothing happens. =/
16:03:00 <hpc> bernalex: elaborate on "nothing happens"
16:03:15 <bernalex> hpc: right now I just have an alert("test"); and it doesn't show up.
16:03:16 <hpc> is there a valid script tag on the page which mysteriously doesn't run?
16:03:26 <bernalex> hpc: I am using the site server thing.
16:03:58 <bernalex> hpc: it is in the src for the generated html.
16:04:11 <hpc> i mean like, is it outputting
16:04:17 <hpc> <script>alert("test");</script>
16:04:19 <hpc> or
16:04:37 <bernalex> hpc: in the src, yes.
16:04:40 <hpc> &lt;script&gt;alert(&quot;test&quot;);&lt;/script&gt;
16:04:43 <hpc> the former?
16:04:55 <hpc> oh, i mean in the generated html
16:05:01 <bernalex> hpc: the actual src in the generated html.
16:05:06 <hpc> hmm
16:05:13 <bernalex> i.e. view:source of the generated html.
16:05:16 <hpc> can you paste the html?
16:06:06 <Clint> does the script tag default to javascript?
16:06:23 <bernalex> hpc: errrrrr I just tried putting it on one line in the src, and then it worked
16:06:27 <bernalex> Clint: yes.
16:06:30 <hpc> Clint: yes; <style> also defaults to css
16:06:34 <bernalex> Clint: though I tried with type="javascript" too.
16:06:50 <hpc> bernalex: ... that's odd
16:07:00 <Twisol> should be type="text/javascript"
16:07:08 <bernalex> hpc: erm put it back and now it works on multilines too. wtf.
16:07:09 <Twisol> but it's optional in HTML5
16:07:13 <hpc> i would still be curious to see what's the problem with the original code
16:07:14 <bernalex> hpc: maybe weird indentation or vim doing something odd?
16:08:02 <hpc> maybe; i am more concerned with how it managed to hide from your browser
16:09:43 <Twisol> hpc: maybe your browser cached it?
16:09:46 <bernalex> hpc: odd problem. works now though, I guess.
16:10:01 <bernalex> Twisol: no, I was clearing the cache with each rebuild.
16:10:06 <Twisol> er, meant to @bernalex
16:10:11 <bernalex> s/rebuild/refresh
16:10:22 <hpc> i sometimes get those too
16:10:23 <Twisol> huh, okay. Fair.
16:10:31 <hpc> where i just delete code and then type it back in verbatim
16:10:40 <hpc> and something just clicks to make it work
16:10:59 <bernalex> hpc: I have had that with vim with obscure languages. i.e. obscure as in I don't use them often. javascript is definitely obscure to me.
16:11:07 <hpc> clearly you were using a cyrillic homoglyph keyboard layout ;)
16:12:50 <erider> how is this answer 16 if answer = twice twice twice suc 0 where twice f x = f (f x); suc x = x + 1; I get 12 with the substitution model
16:14:11 <hpc> (((twice twice) twice) succ) 0
16:14:17 <hpc> (((four) twice) succ) 0
16:14:22 <hpc> ((eight) succ) 0
16:14:28 * hackagebot leankit-api 0.4 - LeanKit API  http://hackage.haskell.org/package/leankit-api-0.4 (dtorok)
16:14:41 <hpc> er, something like that
16:15:28 <hpc> each subsequent twice is increasing the twices
16:15:37 <hpc> or the four-timeses
16:15:41 <hpc> or ...
16:15:52 <hpc> erider: if that makes sense
16:16:22 <simpson> > let twice f x = f (f x); suc x = x + 1 in twice twice twice suc 0
16:16:23 <lambdabot>  16
16:16:44 <hpc> > let twice f x = f (f x) in twice twice twice f x
16:16:45 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))))))
16:16:57 <hpc> > let twice f x = f (f x) in twice twice f x
16:16:58 <lambdabot>  f (f (f (f x)))
16:17:41 <hpc> actually, hmm
16:17:54 <erider> ah ok I did it wrong damn
16:17:56 <hpc> it would seem to me like it would be 8 (without stepping through it more carefully)
16:18:56 <hpc> oh no, i am dumb
16:19:06 <Clint> twice (+1) is (+2)
16:19:29 <hpc> > twice twice twice
16:19:29 <erider> hpc in your method it would be 9
16:19:30 <lambdabot>  Not in scope: `twice'Not in scope: `twice'Not in scope: `twice'
16:19:46 <hpc> > let twice f x = f (f x); twice :: Int -> Int in twice twice twice
16:19:47 <lambdabot>  Couldn't match expected type `t3 -> t1'
16:19:47 <lambdabot>              with actual type `GHC.Types.Int'Couldn't match expected type `t2...
16:19:47 <lambdabot>              with actual type `GHC.Types.Int'Couldn't match expected type `t3...
16:19:47 <lambdabot>              with actual type `GHC.Types.Int'Couldn't match expected type `(G...
16:19:47 <lambdabot>                                -> t0'
16:19:57 <hpc> > let twice f x = f (f x); twice :: (Int -> Int) -> Int -> Int in twice twice twice
16:19:58 <lambdabot>  Couldn't match type `GHC.Types.Int -> GHC.Types.Int'
16:19:59 <lambdabot>                with `GHC.Types.Int'
16:19:59 <lambdabot>  Expected type: GHC.Types.Int -> GHC.Types.Int
16:19:59 <lambdabot>    Actual type: (GHC.Types.Int -> GHC.Types.Int)
16:19:59 <lambdabot>                 -> GHC.Types.Int -> GHC.Types.IntCouldn't match expected type...
16:20:09 * hpc queries to stop spamming
16:20:23 <lispy> hpc: stop all the spammers!
16:21:06 <erider> > let twice f x = f (f x); suc x = x + 1 in twice twice twice suc 0
16:21:07 <lambdabot>  16
16:22:27 <Eduard_Munteanu> (***) is to 'alongside' like (&&&) is to ... what in 'lens'?
16:22:34 <simpson> twice's type is (a -> a) -> a -> a; it's polymorphic, so it's got no problem taking twice as its first argument.
16:22:47 <Eduard_Munteanu> :t alongside
16:22:48 <lambdabot> Functor f => ALens s t a b -> ALens s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
16:23:00 <hpc> simpson: yeah, it's just a bit bendy when you get to (twice twice) twice
16:23:12 <edwardk> Eduard_Munteanu: you can use runFold/Fold to apply multiple lenses for reading
16:23:21 <edwardk> at least in HEAD
16:23:25 <simpson> `twice twice` has its first argument's type as that one above, so this expands to the type of ((a -> a) -> a -> a) -> (a -> a) -> a -> a
16:23:28 <edwardk> runFold $ (,) <$> _1 <*> _2
16:23:31 <hpc> i suppose this is where (->) as exponentiation comes in handy
16:23:36 <edwardk> er
16:23:39 <Eduard_Munteanu> edwardk: hm, thanks, I'll have a look, it is for reading from a state monad
16:23:44 <edwardk> runFold $ (,) <$> Fold _1 <*> Fold _2
16:23:45 <erider> hmm still don't get it
16:23:48 <hpc> simpson: in terms of intuition i mean
16:23:59 <simpson> hpc: It's like fold! Or fmap!
16:24:06 <simpson> Er, not fold, flip.
16:24:11 <edwardk> newtype ReifiedFold s t a b = Fold { runFold :: Fold s t a b }
16:24:23 <edwardk> has the instances you'd expect for something isomorphic to s -> [a]
16:24:37 <edwardk> er newtype ReifiedFold s a = Fold { runFold :: Fold s a }
16:24:39 <erider> do I need to substitute from the left to the right
16:24:41 <edwardk> its a monad, etc.
16:24:46 <Eduard_Munteanu> I was expecting to do 'use', hm.
16:25:26 <edwardk> there isn't currently a combinator for it, propose one, make an issue, let folks talk it out
16:25:35 <Eduard_Munteanu> Heh, I see.
16:27:27 <hpc> erider: (twice twice) twice - if we expand (twice twice) here, we get (\f x -> f . f . f . f $ x) twice -- agree?
16:28:13 <hpc> erider: from there, we apply that lambda, which substitutes twice for f
16:28:24 <hpc> \x -> twice . twice . twice . twice $ x
16:28:38 <hpc> substitute in succ for x from that function application
16:29:14 <hpc> twice . twice . twice . twice $ succ => twice . twice . twice $ (+ 2) => twice . twice $ (+ 4) => twice $ (+ 8) => (+ 16)
16:29:21 <hpc> apply to zero for 16
16:30:50 <erider> 1 is apply to 0 16 times?
16:33:15 <hpc> erider: essentially, each twice is a power of two
16:33:21 <hpc> four twices => 2**4
16:33:42 <hpc> > let twice f x = f (f x) in twice twice twice twice twice succ 0 -- 2**5
16:33:43 <lambdabot>  *Exception: stack overflow
16:34:07 <hpc> well that i should have expected
16:34:08 <erisco> your memory sucks lambdabot
16:37:17 <aleksejs_> can anyone remind me the formula how to calculate amount of unique combinations of this list replicate n 0 ++ replicate n 1 ?
16:37:39 <erisco> > length . nub $ repliace n 0 ++ replicate n 1
16:37:40 <lambdabot>  Not in scope: `repliace'
16:37:40 <lambdabot>  Perhaps you meant one of these:
16:37:40 <lambdabot>    `replicate' (imported from Data.List),
16:37:40 <lambdabot>    `BSC.replicate' (imported from Data.ByteString.Char8),
16:37:40 <lambdabot>    `BSLC.replicate' (imported from Data.ByteString.Lazy.Char8)
16:37:52 <erisco> > length . nub $ replicate n 0 ++ replicate n 1
16:37:53 <lambdabot>  Couldn't match expected type `GHC.Types.Int'
16:37:53 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'Couldn't match e...
16:37:53 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
16:37:57 <blaenk> haha
16:38:03 <erisco> :(
16:38:12 <benmachine> erisco: what's n?
16:38:19 <erisco> benmachine, good question
16:38:34 <aleksejs_> erisco, i mean unique permutations
16:38:56 <benmachine> aleksejs_: so you mean the number of ways of arranging n 1s in 2n slots?
16:39:13 <aleksejs_> yes
16:39:22 <erisco> aleksejs_, oh I see :) I was just shooting in the dark
16:39:24 <benmachine> "2n choose n"
16:39:33 <benmachine> there are a few ways to compute it
16:39:33 <Eduard_Munteanu> Do you distinguish the 1s?
16:39:57 <benmachine> see also: binomial coefficient
16:39:59 <aleksejs_> I guess it was n!/k!*(n-k)!
16:40:12 <Eduard_Munteanu> That sounds right.
16:40:20 <erisco> you will nto want to compute that directly
16:41:30 <aleksejs_> then for n 40 it will be 16768354839317854070538240000 ? PE shows me that this answer is wrong
16:41:45 <Eduard_Munteanu> aleksejs_: PE?
16:41:53 <aleksejs_> http://projecteuler.net/problem=15
16:43:30 <arach_> is there a function that will take a subset of a list? say for example take all the elements between position 2 to 5
16:43:37 <erisco> aleksejs_, n!/[2(n/2)!] I think?
16:43:50 <aleksejs_> sorry, I missed ! for k
16:43:59 <aleksejs_> correct answer is 137846528820
16:44:15 <Eduard_Munteanu> arach_: usually you use a combination of drop and take
16:44:31 <aleksejs_> and I reduced formula to product [21..40] `div` product [1..20]
16:44:34 <Eduard_Munteanu> arach_: but if you have to do that, a list might not be appropriate
16:45:10 <arach_> Eduard_Munteanu: efficiency shouldnt be a concern if that is what you meant. I have less than 100 elements
16:45:50 <erisco> aleksejs_, I got that answer too with 40!/(20!20!)
16:46:12 <aleksejs_> erisco, this is the same thing
16:46:19 <erisco> yes :)
16:47:06 <erisco> n!/[k!*(n-k)!] is for choosing k from n though no?
16:47:15 <aleksejs_> my mistake was that i forgot to get factorial of 20, so I tried to calculate product [21..40] `div` 20
16:47:21 <benmachine> erisco: yes?
16:47:47 <Eduard_Munteanu> All paths have the same length, and at each point you take 1 of 2 turns... so it seems to me it should be 2^'manhattan distance'
16:48:04 <erisco> benbangert, how did you determine to choose n/2 items?
16:48:22 <erisco> sorry benmachine
16:48:31 <Eduard_Munteanu> > 2 ** 40
16:48:32 <lambdabot>  1.099511627776e12
16:48:37 <benmachine> erisco: ...set k = n/2?
16:48:53 <Eduard_Munteanu> > 2 ^ 40
16:48:54 <lambdabot>  1099511627776
16:49:42 <erisco> benmachine, I do not follow
16:49:58 <benmachine> erisco: I do not understand the question
16:51:29 <Eduard_Munteanu> Oh, wait, it's not right.
16:51:46 <erisco> oh the list is 2n long
16:51:47 <Eduard_Munteanu> You can't always go right, or down.
16:52:27 <erisco> aleksejs_, then our answers do not agree :(
16:53:04 <erisco> so you have 80 items and you want the number of combinations, but there are 40 1's and 40 0's
16:53:16 <erisco> I believe this is modelled by 80!/(40!40!)
16:53:26 <aleksejs_> ?
16:53:43 <aleksejs_> there can be only moves right and down
16:53:47 <aleksejs_> 0 and 1
16:54:00 <aleksejs_> and path always will be 20*2
16:54:24 <Tekmo> erisco: Yes, that's right
16:54:26 <benmachine> erisco: what are the 80 items?
16:54:27 <erisco> oh so you are choosing 40 frmo the 80?
16:55:09 <kraalquid> 80 Choose 40 = 107507208733336176461620
16:55:21 <benmachine> erisco: try your thinking on the 2x2 example, perhaps
16:55:21 <erisco> kraalquid, yes but there are duplicate items
16:55:21 <aleksejs_> n!/[k!*(n-k)!] with n=40 and k=20 is correct answer
16:55:35 <erisco> no it is not
16:55:41 <benmachine> no it really is
16:55:47 <benmachine> I know, I've done this problem too
16:55:55 <erisco> but that would treat each item as unique
16:56:16 <DMcGill> I'd like to do some .net programming, does anybody have some experience with C# ffi vs working in F#? The latter seems to have polymorphism and currying even if it's not lazy. Has anybody here tried either?
16:56:24 <benmachine> erisco: what, exactly, do you think the problem is, and where does 80 come into it?
16:56:27 <erisco> for example
16:56:29 <DMcGill> I need to work with reasonably complex C# objects if it matters
16:56:50 <erisco> I have a list of 2 items. [1,1]. What are the unique selections of one item?
16:57:03 <benmachine> DMcGill: I think you're looking in the wrong place for C# or F# advice
16:57:30 <benmachine> DMcGill: we mostly know about haskell
16:57:37 <kraalquid> if the list is [1,1] there is only one option
16:57:37 <Tekmo> benmachine: He's asking how to write Haskell bindings to C#
16:57:38 <DMcGill> comments from a haskell programmer about working in either is exactly that I'm looking for
16:58:09 <DMcGill> I suspect that going to #F# or whatever and asking "how similar is this to Haskell" won't get a great response
16:58:17 <erisco> benmachine, because, if I understand correctly, each path is 40 units long, and there are two moves (lets say down and right). You might have 40 down moves, or 40 right moves
16:58:18 <aleksejs_> erisco, if you think that my answer is wrong, then you need to write to projecteuler.net guys, because they showed me that my answer is right
16:58:30 <erisco> benmachine, so this is being represented as a list of 80 movements, where 40 are chosen
16:58:52 <aleksejs_> erisco, you always do precisely 20 moves right and 20 moves down
16:58:58 <erisco> ah
16:59:30 <erisco> well then 40!/(20!20!) it is :)
16:59:31 <erisco> sorry
16:59:36 <erisco> I misunderstood
17:00:22 <aleksejs_> yes :) and here's the code http://vpaste.net/2cZOg
17:00:41 <aleksejs_> works for x*x grid
17:03:45 <erisco> aleksejs_, my understanding of the problem would tell you the number of ways to get to the edge of a quarter diamond, I think
17:04:27 <erisco> with a center to point distance of n
17:05:15 <erisco> not sure why I said quarter diamond and not just right triangle :P
17:05:27 <erisco> equilateral that is
17:09:40 <khyperia> I'm trying to get ghc to dump out the core representation of a data type, but it keeps on optimizing everything away and I can't actually see anything
17:10:02 <Tekmo> khyperia: What do you mean representation of a data type?
17:10:16 <khyperia> the Core of a `data' definition
17:10:26 <khyperia> I dunno how it represents them in Core
17:10:29 <Tekmo> khyperia: I didn't even know core output data definitions
17:10:42 <khyperia> it *has* to, how else would types be represented?
17:10:48 <khyperia> at least that's my theory
17:10:58 <erisco> well what are you looking for in particular?
17:11:29 <hpc> yeah, types don't vanish until quite late in compilation
17:11:30 <khyperia> I'm making my own compiler, and I want to know how ghc represents data things in it's System-F or whatever it's called
17:12:04 <khyperia> I *could* read the papers on that system...
17:12:05 <blaenk> has anyone used wai/scotty/snap for web dev? I'm considering creating an api server in haskell, I'm wondering if any of those has a feature for creating prefixed routes. so say I say my prefix is '/some-mount-point', then later I can define a route as '/login', and it'll actually know I mean '/some-mount-point/login'
17:12:24 <Tekmo> I believe `snap` can do this
17:12:32 <blaenk> thanks Tekmo I'll look into it
17:12:42 <Tekmo> You're welcome
17:14:08 <davidfetter_disq> snap? wasn't that the collective that covered "the power," way back when?"
17:14:34 <davidfetter_disq> https://www.youtube.com/watch?v=z33tH-JdPDg
17:14:35 * hackagebot network-data 0.5.2 - Library for network data structures and their serialization.  http://hackage.haskell.org/package/network-data-0.5.2 (ThomasDuBuisson)
17:19:52 <shachaf> khyperia: You can probably find your way to a lot of things from the CoreSyn definitions.
17:20:06 <shachaf> E.g. maybe you're looking for http://www.haskell.org/platform/doc/2013.2.0.0/ghc-api/DataCon.html#t:DataCon
17:22:19 <khyperia> Ah, it's buried under a couple layers inside a Case expression
17:22:49 <khyperia> wait
17:23:47 <khyperia> the Case/Alt/AltCon/DataAlt/DataCon thing is deconstructing in a pattern expression, not a data definition
17:26:46 <d-snp_> hmm
17:27:10 <d-snp> I get a deprecation warning when using isEmptyChan because of this bug: https://ghc.haskell.org/trac/ghc/ticket/4154
17:27:45 <d-snp> but I think I'm using it safely, I only read after an isEmptyChan has returned false, and my writers are all on different threads
17:28:07 <d-snp> do you guys think I should still use TChan?
17:28:23 <d-snp> is the STM library production ready?
17:28:42 <flebron> Say I'm developing a module M. If I say ghci M.hs, ghci knows about the internal stuff in M. How could I get a view that's external, i.e. like someone who was doing "import M"? (M isn't yet cabal-installed, so ghci doesn't just "find" M when I say import M)
17:29:02 <shachaf> Compile it with ghc.
17:29:38 * hackagebot egison 3.2.1 - The world's first language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.2.1 (SatoshiEgi)
17:32:12 <flebron> Thanks :)
17:33:11 <Kaidelong> does "fromMaybe mzero return" have a name somewhere?
17:33:19 <Kaidelong> @ty fromMaybe mzero return
17:33:20 <lambdabot>     Couldn't match expected type `Maybe (m0 a0)'
17:33:20 <lambdabot>                 with actual type `a1 -> m1 a1'
17:33:20 <lambdabot>     In the second argument of `fromMaybe', namely `return'
17:33:38 <Kaidelong> ugh
17:33:42 <Kaidelong> @ty maybe mzero return
17:33:43 <lambdabot> MonadPlus m => Maybe a -> m a
17:33:49 <Kaidelong> maybe zero return then
17:34:02 <erisco> Tekmo, mm I thought of an idea to bring the depth search to O(n)
17:34:39 * hackagebot plotserver-api 0.22 - Plotserver API  http://hackage.haskell.org/package/plotserver-api-0.22 (dtorok)
17:34:49 <erisco> Tekmo, but it means internally using the ST monad... imperative graphs may have a boolean on every node that the algorithm can use to mark if it has visited there yet
17:35:07 <Kaidelong> @@ hoogle type maybe zero
17:35:07 <lambdabot>  hoogle type maybe zero
17:35:12 <erisco> Tekmo, of course in functional land that does not work without ST, but it is the only way to get O(n)
17:36:14 <erisco> actually if it is strongly connected it is probably worse than O(n) but that would be true in other representations as well
17:36:54 <DMcGill> erisco: I'm not sure if that's what you're talking about but this is what Data.Graph actually does. There's an interesting paper on how only one dfs function needed to use ST and then everything else could be impelemented in terms of that
17:36:55 <erisco> yeah I guess it is O(n^2) in general
17:37:37 <erisco> DMcGill, oh? I will look at the paper
17:38:17 <erisco> DMcGill, wrt the "one function needed to do ST" yes, I observe that as well
17:38:54 <DMcGill> erisco: http://galois.squarespace.com/storage/files/downloads/publications-jl/Structuring%20DFS%20Algorithms.pdf
17:39:36 <aleksejs_> back to that problem with lattice paths: http://i.imgur.com/hGssXeU.png :)
17:40:50 <binroot> @pl \x -> tail $ last x : tail x
17:40:50 <lambdabot> tail . liftM2 (:) last tail
17:40:59 <DMcGill> does "foldl' (*) 1 x" give better performance? Laziness here is a disadvantage I think
17:41:03 <binroot> @pl \x -> tail (last x : tail x)
17:41:04 <lambdabot> tail . liftM2 (:) last tail
17:41:24 <binroot> @pl \x -> init (last x : tail x)
17:41:25 <lambdabot> init . liftM2 (:) last tail
17:43:19 <Elision> having some trouble with parsec... I'd like to match "[thing1 thing2 thing3 ... thingn]" but with optional spaces around the braces, for example
17:44:51 <binroot> @pl \x -> last x : (init.tail) x
17:44:51 <lambdabot> liftM2 (:) last (init . tail)
17:45:24 <DMcGill> binroot: this looks like one of those cases where pointfree becomes pointless I'm afraid
17:45:33 <Elision> I tried do { symbol "["; whiteSpace; ns <- thing `sepBy1` whiteSpace; whiteSpace; symbol "]"; return $ transform ns }, but that doesn't match things like "[ thing1 thing2 ]"
17:45:36 <DMcGill> binroot: sometimes you just need a point
17:46:25 <erisco> DMcGill, ah okay their graphs are static
17:46:53 <koala_man> Elision: "symbol" already skips trailing whitespace
17:46:54 <erisco> DMcGill, or fixed or however you want to say. I was wondering how they avoided the logn for vertex access time. it is because they are backed by arrays
17:46:57 <Elision> hm.
17:47:26 <Elision> how about leading?
17:48:05 <koala_man> Elision: if you make 'thing' skip trailing whitespace as well, you can just do  symbol "["; many1 thing; symbol "]"
17:48:15 <Elision> oh, that would be smart
17:48:24 <DMcGill> erisco: I'm not sure how you'd do a dfs if the graph changed half way through with possibly new nodes, is that what you mean?
17:48:54 <erisco> DMcGill, I mean some representations use a map to store vertices
17:49:07 <athan> Good evening, fellow haskellians.
17:49:19 <erisco> DMcGill, meaning to resolve the vertex an edge is pointing to it costs logn time (where n is the number of vertices in the map)
17:49:38 <koala_man> Elision: obviously, apart from the start of the file, all leading whitespace is some token's trailing whitespace, so if you always skip trailing, it should be fine
17:49:59 <erisco> DMcGill, maps can grow and shrink in size, and have items inserted and removed. arrays cannot, ie arrays are static ie they are not dynamic
17:50:24 <athan> Does anyone here have experience working with UTC and UT1 in Data.Time?
17:50:50 <Aetherspawn> eribeiro: were you the one the other day asking about shared memory?
17:51:25 <Elision> makes sense
17:53:37 <DMcGill> erisco: you could try Data.HashTable.ST if you want a resizable data structure with O(1) indexing
17:54:04 <erisco> DMcGill, I was just explaining what I meant by static. their choice is fine
17:55:23 <erisco> their paper is clear and concise. a nice treat :)
17:58:17 <erisco> lol it is only 10x to 20x slower than in C
17:58:29 <erisco> *sigh* sometimes I hate reality
17:59:44 <DMcGill> I remember being not too impressed with their coding style, I'm sure with vector you could improve on that a little
18:00:24 <Tekmo> erisco: Note that you can greatly improve performance for loop-heavy code by using `ghc`'s llvm backend
18:00:27 <DMcGill> hmm now there seems like a nice little project
18:00:38 <Tekmo> erisco: Also, `vector` is a must
18:01:00 <DMcGill> Tekmo: that seems a little unfair enough, wouldn't the C code also get a large boost from using LLVM?
18:01:05 <erisco> so it might be almost as fast as javascript then?
18:01:09 <Tekmo> DMcGill: Haskell code gets a bigger boost
18:01:41 <Tekmo> DMcGill: The reason is that Haskell's native code generator does not perform aggressive loop optimizations, whereas `gcc` in comparison already does, so there is a bigger gain in performance for the Haskell code
18:01:55 <DMcGill> they over use lists and (++) which is a real red flag to me
18:02:54 <Tekmo> Yes, I would never use lists as a high-performance data structure
18:03:18 <DMcGill> I've already said my piece about lists being the default String type
18:03:27 <Tekmo> For all high-performance code I use `containers`, `unordered-containers`, and `vector`
18:03:55 <aristid> Tekmo: oh you're actually back in irc too:D
18:03:59 <Tekmo> Yeah :)
18:04:04 <aristid> damn >1s lag is painful
18:04:08 <DMcGill> I guess it's more important for beginners but it sure does lead to a lot of "why does my haskell code which uses (!!) lots run so slowly"
18:04:18 <Tekmo> aristid: And the answer to your last e-mail is "yes"
18:04:29 <aristid> Tekmo: the one with the commutative?
18:04:32 <Tekmo> aristid: Yes
18:04:36 <aristid> ah:)
18:05:04 <Tekmo> So it turns out that the current implementation of `pipes` does allow nested pipes to commute
18:05:14 <aristid> Tekmo: so one idea i had there was manually building a free functor that has all the things i need, but i have never actually built a free functor myself
18:05:23 <aristid> it does allow it?
18:05:25 <Tekmo> Yes
18:05:29 <aristid> how?
18:05:31 <c_wraith> If only lists could fuse foldl.  Then you could have lists as a high-performance loop
18:05:32 <Tekmo> You can write a commute function of type:
18:05:54 <erisco> sigh it is really painful to give up but
18:05:55 <aristid> Tekmo: oh you just have to call it explicitly so it may still be somewhat painful, right?
18:06:00 <Tekmo> commute :: Proxy a' a b' b (Proxy a'2 a2 b'2 b2 m) r -> Proxy a'2 a2 b'2 b2 (Proxy a' a b' b m) r
18:06:05 <Tekmo> aristid: Correct
18:07:06 <aristid> Tekmo: and the only way to really get automatic commuting is merging everything into the same free functor, right?
18:07:20 <shachaf> aristid: What's a free functor?
18:07:32 <aristid> shachaf: i probably use the wrong words often:)
18:07:48 <aristid> and don't understand them well
18:08:19 <shachaf> OK, but what do you mean by it?
18:08:21 <erisco> Cale, lol I think you win
18:08:32 <Tekmo> aristid: That's right
18:08:38 <DMcGill> erosco: between vector, text (if applicable) and llvm it's not common to get Haskell code to within 5x of C code which isn't bad considering the dev/testing time is about a tenth of what it'd be in C
18:08:44 <DMcGill> erisco: between vector, text (if applicable) and llvm it's not common to get Haskell code to within 5x of C code which isn't bad considering the dev/testing time is about a tenth of what it'd be in C
18:08:45 <aristid> shachaf: well pipes is built as a free monad i think, and there i mean the functor it's built on
18:08:49 <Tekmo> shachaf: He means the argument functor of a free monad
18:08:56 <Tekmo> i.e. the `f` in `Free f`
18:09:11 <erisco> DMcGill, yeah but javascript is 2x native so what does that say?
18:09:33 <shachaf> Oh. Strange name for it. OK.
18:09:42 <Tekmo> erisco: Correction, `asm.js` is 2x native and that's a very low-level language
18:09:43 * hackagebot hOpenPGP 0.10.2 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.10.2 (ClintAdams)
18:10:04 <aristid> haskell is far more fun to write than asm.js
18:10:23 <erisco> Tekmo, it was a bit of a joke for myself, nevermind :P
18:10:28 <Tekmo> erisco: Oh :)
18:12:06 <jtcwang> I'm trying to use in with if statement. http://lpaste.net/97949
18:12:18 <erisco> so after all this surveying I think there are two general representation types
18:12:22 <jtcwang> its giving me errors parsing
18:12:29 <aristid> Tekmo: btw am i the only one feeling that Producer is the type in pipes that ends up being used the most?
18:12:43 <zRecursive> :t mkStdGen
18:12:43 <lambdabot> Int -> StdGen
18:12:58 <Tekmo> aristid: For parsing it is
18:13:06 <Tekmo> aristid: Parsing is heavily `Producer`-biased
18:13:10 <shachaf> jtcwang: Please always include the errors with your code. Otherwise people can't help you very easily.
18:13:11 <erisco> static graphs and dynamic graphs. with the static graphs you'll lose a logn factor, which is nice, and with the dynamic you can mutate with a logn complexity
18:13:20 <aristid> Tekmo: are there things that are biased to other things?
18:13:22 <Tekmo> aristid: For other things you still get a mix of other abstractoins
18:13:31 <Tekmo> aristid: Yes
18:13:39 <erisco> and so an approximate general solution needs both models
18:13:40 <jtcwang> shachaf, my bad
18:13:48 <aristid> Tekmo: like?
18:14:09 <Tekmo> aristid: A good example is my unpublished `mvc` library
18:14:21 <Tekmo> That uses a mix of `Producer`s, `Pipe`s and `Consumer`s
18:14:25 <aristid> Tekmo: heh sounds like cool sutff, what does it do?
18:14:40 <Tekmo> It's basically a way to factor out concurrency from program logic
18:14:57 <Tekmo> So you have a pure core of your program logic that you can QuickCheck or formally reason about
18:15:23 <Tekmo> The API is still heavily in flux, but it reuses a lot of concepts from `pipes-concurrency`
18:15:34 <DMcGill> jtcwang: turn "x = randomR (1, 10000) g" into "x = fst "randomR (1, 10000) g"
18:15:44 <Tekmo> The difference is that instead of spawning lots of processes and programming in an actor-like style it is much more structured
18:15:51 <DMcGill> whoops I mean "fst (randomR (1,10000) g)"
18:15:54 <jtcwang> DMcGill, thanks. I forgot that it returns a tuple
18:16:05 <shachaf> jtcwang: That doesn't explain parse errors.
18:16:11 <DMcGill> but I suspect that manually passing the generator each time isn't the behaviour you want
18:16:18 <Tekmo> aristid: You basically represent all concurrent inputs to your system as `Input`s and all concurrent outputs from your system as `Output`s
18:16:28 <aristid> Tekmo: does the multiple request/response type pairs problem crop up in there too?
18:16:35 <Tekmo> aristid: No, not at all
18:16:38 <Tekmo> aristid: It works out really nicely
18:16:54 <aristid> Tekmo: i have a hard time imagining this right now
18:16:57 <Tekmo> aristid: It makes it really easy to combine `Input`s and `Output`s that have different types
18:17:04 <jtcwang> shachaf, i am not sure. it seem to alright now. Maybe I mislooked
18:17:05 <Tekmo> I'll use `Input`s as an example
18:17:13 <Tekmo> aristid: Let's say you have two concurrent inputs to your system
18:17:19 <jtcwang> shachaf, i think it was a type error from the start. sry
18:17:19 <Tekmo> aristid: One is mouse events and the other is key presses
18:17:23 <Tekmo> aristid: keys :: Input Key
18:17:30 <Tekmo> aristid: mouse :: Input MouseEvent
18:17:43 <Tekmo> aristid: You can combine those into a single `Input` by using its `Functor` and `Monoid` instances
18:17:56 <Tekmo> aristid: eventsIn :: Input (Either Key MouseEvent)
18:18:04 <Tekmo> aristid: eventIn = fmap Left keys <> fmap Right mouse
18:18:13 <aristid> Tekmo: ooh it works out because there is no type-based relationship between different inputs and outputs, right?
18:18:18 <Tekmo> aristid: Now you have a merged stream of incoming events
18:18:27 <Tekmo> aristid: Right
18:18:39 <Tekmo> aristid: You can do the same trick for outputs, too, using prisms
18:18:43 <Tekmo> If you have two outputs of different types:
18:18:50 <Tekmo> output1 :: Output A
18:18:54 <Tekmo> output2 :: Output B
18:18:59 <Tekmo> You can combine them into a single output using:
18:19:04 <Tekmo> outputTotal :: Output (Either A B)
18:19:09 <aristid> Tekmo: can you show how to detect double-clicks assuming the Mouse only gives you mouse-down / mouse-up? :)
18:19:15 <Tekmo> outputTotal = handling _Left output1 <> handling _Left output2
18:19:21 <Tekmo> *handling _Right output2
18:19:24 <Tekmo> aristid: Yes
18:19:36 <Tekmo> I've done a library that basically implements this for a non-trivial example
18:19:43 <Tekmo> Let me link you to my `rcpl` library
18:19:50 <Tekmo> It does this for handling concurrent input and output to a terminal
18:19:59 <aristid> ok du show:)
18:19:59 <Tekmo> https://github.com/Gabriel439/Haskell-RCPL-Library
18:20:00 <aristid> *do
18:20:11 <Tekmo> aristid: It doesn't use the `mvc` library yet but it's the same basic idea
18:20:19 <Tekmo> It groups all inputs into a single input and all outputs into a single output
18:20:28 <Tekmo> Then the model is a pipe with a pure `State` base monad
18:20:38 <Tekmo> The `State` keeps track of things like the double-click you were asking about
18:21:01 <DMcGill> ah I didn't know you were Gabriel Gonzalez Tekmo
18:21:03 <aristid> Tekmo: i guess this is the first serious example of pipes-frp then?:)
18:21:05 <Tekmo> :)
18:21:05 <DMcGill> should have guessed really
18:21:08 <Tekmo> aristid: Yes
18:21:15 <Tekmo> aristid: This is my take on FRP, except without continuous behaviors
18:21:31 <Tekmo> aristid: I prefer to call it MVC to avoid the FRP terminolog nazis from clubbing me
18:21:38 <aristid> haha
18:22:08 <DMcGill> any reason you wrote the lenses out for Status Tekmo?
18:22:11 <aristid> beware armed conals
18:22:48 <DMcGill> "buffer f (Status p b w h) = fmap (\b' -> Status p b' w h) (f b)" et al.
18:22:57 <Tekmo> Because I don't like Template Haskell
18:23:11 <DMcGill> fair enough
18:23:59 <c_wraith> Tekmo: you can write lenses without TH.  Without any extra imports, even.
18:24:09 <Tekmo> c_wraith: Yes, I do
18:24:13 <aristid> c_wraith: that's what he does, i think
18:24:14 <Tekmo> That's what DMcGill was commenting on
18:24:19 <c_wraith> ah, ok
18:24:32 <Tekmo> That's one of the reasons I love the lens library
18:24:36 <Tekmo> It requires zero buy-in
18:24:45 <Tekmo> I also like the `lens-family` library, which is a light-weight version of `lens`
18:24:59 <pharaun> the lens library by edwardk?
18:25:01 <aristid> lens-family and lens are compatible, right?
18:25:04 <aristid> pharaun: yes.
18:25:04 <Tekmo> pharaun: yes
18:25:07 <Tekmo> aristid: Yes
18:25:43 <Tekmo> aristid: Did you see my latest work on `pipes-parse`?
18:26:07 <aristid> Tekmo: not sure, what changed?
18:26:28 <Tekmo> aristid: Basically I got the old lens-based idea to work really well
18:26:31 <DMcGill> so when is Data.Map going to drop Adjust and Alter and such for the lens interface? :) would they be much use without having the rest of {lens,lens-family} around?
18:26:39 <Tekmo> aristid: The only disadvantage is that these lenses break some laws
18:26:44 <Tekmo> aristid: The same laws we discussed earlier
18:27:04 <aristid> Tekmo: so you jsut have improper lenses now?
18:27:09 <Tekmo> aristid: That's right
18:27:21 <d-snp> how rude :)
18:27:24 <Tekmo> :)
18:27:26 <aristid> Tekmo: ah yeah, that's nice i guess:) i'm not using pipes-parse right now
18:27:29 <Tekmo> But it works out really elegantly
18:27:48 <aristid> pipes-attoparsec is useful
18:28:38 <Tekmo> Yeah, that isn't changed much.  `pipes-parse` has a bigger impact on `pipes-bytestring`
18:28:57 <Tekmo> For example, now you can do things like `over lines (takes 3)` to take just the first three lines of a stream
18:29:46 <Tekmo> You can also easily limit attoparsec parsers
18:29:56 <Tekmo> For example, if you want an attoparsec parser to run on just N bytes of input, you would now write
18:30:01 <aristid> hmm i think i wouldn't think of doing it this way the first way around
18:30:06 <DMcGill> was "takes" intentional?
18:30:09 <Tekmo> result < -zoom (splitAt N) (parse theParser)
18:30:27 <Tekmo> DMcGill: Intentional.  It works on `FreeT`s
18:30:37 <DMcGill> I see
18:30:49 <Tekmo> lines :: Lens' (Producer ByteString m r) (FreeT (Producer ByteString m) r)
18:31:10 <Tekmo> takes :: (Functor f, Monad m) => Int -> FreeT f m () -> FreeT f m ()
18:31:18 <d-snp> Tekmo: I have a simple situation where one thread produces writer sockets, and another produces reader sockets, and a connector thread that reads those from a Chan, and uses pipes to connect them to eachother
18:31:38 <aristid> Tekmo: the review for lines is just concat i assume?
18:31:39 <Tekmo> Actually, `lines` is an `Iso`, not a `Lens'`
18:31:46 <d-snp> do you think I should pipes for producing the sockets as well?
18:31:47 <aristid> an improper Iso
18:31:50 <Tekmo> aristid: That's right
18:31:54 <Tekmo> aristid: Wait, no
18:31:58 <Tekmo> aristid: It also inserts newlines
18:32:11 <aristid> Tekmo: oh right, those arr removed. didn't think of that
18:32:32 <Tekmo> So you can have `unlines = from lines`
18:32:32 <aristid> i'm typing basically blind due to the lag, so please excuse typos
18:33:00 <aristid> heh, unlines = from lines is cute
18:33:03 <Tekmo> d-snp: Neat.  What's the application?
18:33:32 <Tekmo> Another thing that's cool about this parsing stuff is that the basic idea is `pipes`-agnostic
18:33:46 <Tekmo> You can do the exact same thing for ordinary `Text` or apply it to `conduit`, too
18:34:29 <Tekmo> The idea is that you have three abstractions, given some input stream of type `t`
18:34:35 <Tekmo> sources are just values of type `t
18:34:38 <Tekmo> *`t`
18:34:46 * hackagebot hopenpgp-tools 0.0.4 - hOpenPGP-based command-line tools  http://hackage.haskell.org/package/hopenpgp-tools-0.0.4 (ClintAdams)
18:35:08 <Tekmo> Sinks are values of type `StateT t m r`/`State t r` (depending on whether or not `t` has effects)
18:35:09 <shachaf> I wish lens had a way to express "from". :-(
18:35:22 <aristid> :t from
18:35:23 <lambdabot> (Functor f, Profunctor p) => AnIso s t a b -> p t (f s) -> p b (f a)
18:35:31 <aristid> shachaf:  a way different from this?
18:35:36 <d-snp> Tekmo: I'm implementing an e-mail system, this part is a file backed message queue, basically to decouple the accepting of e-mails from the storing/sorting into a database
18:35:39 <shachaf> It only works for Isos. It should work for everything.
18:35:39 <d-snp> https://github.com/iimeru/iiqueue/blob/master/IIQueue.hs#L71
18:36:13 <SLi> Hmm, I cabal installed a newer version of bytestring, and suddenly my bytestrings are not RegexLike?
18:36:31 <Tekmo> Stream transformations are just values of type `Lens' t t`
18:36:41 <Tekmo> To connect a source to a strem transformation, you use `view`
18:36:50 <Tekmo> view :: Lens' t t -> t -> t
18:36:52 <aristid> SLi: your regex package probably still uses the old version. updating bytestring is NOT a good idea in general
18:37:00 <Tekmo> To connect a stream transformation to a sink, you use `zoom`
18:37:11 <Tekmo> zoom :: Lens' t t -> State t r -> State t r
18:37:20 <Tekmo> And connecting stream transformations is function composition like always
18:37:40 <d-snp> can you peek on a producer?
18:37:43 <Tekmo> d-snp: Yes
18:38:01 <Tekmo> Sinks store the producer they read from in `State`
18:38:29 <Tekmo> So undrawing leftovers just prepends them back onto the stored input state
18:38:41 <Tekmo> The definition of `unDraw` for `pipes-parse` is just:
18:38:44 <SLi> aristid: hmm, true. Ok, how do I go back to using the old version of bytestring which is compatible with regex-pcre? :P
18:38:45 <d-snp> cool
18:38:50 <Tekmo> unDraw a = modify (yield a >>)
18:39:18 <d-snp> ah right
18:39:55 <Tekmo> d-snp: Oh that's right.  I think I remember you talking about this file-backed queue before
18:39:57 <d-snp> hmm but that would yield a new producer right?
18:40:04 <aristid> SLi: did you install anything other than bytestring?
18:40:13 <Tekmo> d-snp: It shares the unread values with the old producer
18:40:29 <SLi> aristid: No. Seems ghc-pkg unregister bytestring-$version did the trick (though I'm not sure if it was the correct thing to do :)
18:40:30 <aristid> SLi: ghc-pkg unregister to all packages that are/use the new bytestring :P
18:40:32 <Tekmo> d-snp: Remember that a `Producer` is just an instruction for how to retrieve values
18:40:51 <Tekmo> d-snp: It doesn't contain any actual values inside of it
18:40:52 <d-snp> yeah so the problem, I want the peek to be non blocking, so just to know whether the producer has a next value or not
18:41:07 <aristid> SLi: if you want a new bytestring, install  a newer ghc, basically:)
18:41:32 <Tekmo> d-snp: So you mean you want it to prefetch values?
18:41:43 <SLi> Why are the packages here on the bytestring hackage page corresponding to my ghc's bytestring not links? http://hackage.haskell.org/package/bytestring-0.10.0.2
18:41:48 <Tekmo> d-snp: Otherwise, how can it know whether or not there is more input?
18:42:06 <Tekmo> d-snp: For example, suppose the producer was `Pipes.Prelude.stdinLN`
18:42:15 <d-snp> eh well, the equivalent for Chan would be the isChanEmpty function
18:42:18 <Tekmo> d-snp: How would it know whether I intend to enter another line or hit `Ctrl-D`?
18:42:45 <d-snp> it wouldn't, it would only know if you already have
18:42:51 <chrisdone> just did a wee rewrite and facelift to http://tryhaskell.org/ (using latest mueval, not as fast as my own, but way more stable)
18:42:54 <Tekmo> d-snp: Okay, so what you want is prefetching
18:42:57 <d-snp> ok
18:43:14 <chrisdone> takes better advantage of widescreens now
18:43:21 <Tekmo> d-snp: You'd have to basically use `pipes-concurrency` to insert a buffer in between
18:43:29 <Tekmo> d-snp: Are you familiar with the `pipes-concurrency` library?
18:43:41 <d-snp> no, I just saw it and gonna read up on it now
18:44:16 <Tekmo> d-snp: You'd basically `spawn` a buffer that you can then drain your `Producer` into and then you can read from the buffer contents as a `Producer` of its own
18:44:36 <Tekmo> d-snp: Since the read action is in `STM`, it's easy to implement a non-blocking peek
18:44:41 <Tekmo> d-snp: The read action is:
18:44:48 <Tekmo> d-snp: recv :: Input a -> STM (Maybe a)
18:44:53 <d-snp> ah cool
18:45:02 <Tekmo> d-snp: So `peek` would just be `optional recv :: STM (Maybe (Maybe a))`
18:46:07 <Tekmo> *`optional (recv input)`
18:46:23 <d-snp> is STM contained by IO? as in, can I just unpack things with <- in an IO do block, or is there a function for that? STM is on my to-read list as well :P
18:46:30 <Tekmo> STM is a monad
18:46:39 <Tekmo> There's a really good tutorial for using STM.  Let me link you to it
18:46:51 <Tekmo> d-snp: https://www.fpcomplete.com/school/beautiful-concurrency
18:46:57 <Tekmo> It's based off of a paper by the same name
18:47:12 <d-snp> haha nice title
18:47:21 <Tekmo> @google beautiful concurrency
18:47:24 <lambdabot> http://research.microsoft.com/pubs/74063/beautiful.pdf
18:47:24 <lambdabot> Title: Beautiful concurrency
18:47:29 <Tekmo> That's the one
18:47:50 <Tekmo> STM is the key to concurrent programming in Haskell
18:47:54 <Tekmo> It makes so many things easier
18:48:08 <DMcGill> there's also Parallel and Concurrent Programming, S Marlow's new book which is available for free online
18:48:16 <Tekmo> `pipes-concurrency` just takes it a step further and solves the last remaining issue with STM, which is deadlocks
18:48:58 <DMcGill> which has a chapter on STM but also looks at ST; Repa; PSeq; DeepSeq etc etc
18:52:49 <Tekmo> STM is one of the crown jewels of Haskell
18:54:48 * hackagebot pipes 4.0.2 - Compositional pipelines  http://hackage.haskell.org/package/pipes-4.0.2 (GabrielGonzalez)
18:56:49 <pharaun> Tekmo: deadlocks?
18:57:28 <Tekmo> pharaun: `IndefinitelyBlockedOnSTM` exceptions
18:57:52 <Tekmo> These exceptions arise when the runtime detects you have unrecoverably entered a deadlock
18:58:09 <Tekmo> `pipes-concurrency` solves the problem at the source by making it easy to write deadlock-free code
18:58:29 <pharaun> Tekmo: ahhh, yeah i've ran into those occasionally with conduits
18:58:39 <pharaun> probably my fault really :)
18:58:45 <Tekmo> pharaun: No, not at all
18:58:49 <Tekmo> Writing deadlock-free code is really hard
18:58:57 <Tekmo> In some cases I'm not even sure it is possible
18:59:05 <Tekmo> Well, let me rephrase that
18:59:39 <Tekmo> It is possible, but getting it correct requires instrumenting the garbage collector to detect when the last reference to an STM variable is gone
18:59:45 <Tekmo> This is basically what `pipes-concurrency` does
18:59:48 * hackagebot lifted-async 0.1.1 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.1.1 (MitsutoshiAoe)
19:00:38 <Tekmo> The neat thing is that the core infrastructure for `pipes-concurrency` is actually `pipes`-independent
19:00:45 <Tekmo> So you can very easily upgrade `conduit` to use it as well
19:00:47 <pharaun> Tekmo: oh? hrm, looks like i should dig into pipes-concurrency, been kinda waiting on it for a pipes-http
19:00:47 * chrisdone craves sushi
19:00:55 <Tekmo> pharaun: I'm working on `pipes-http` right now
19:01:07 <Tekmo> pharaun: I'm writing a `pipes` wrapper around the `http-client` library
19:01:20 <pharaun> Tekmo: sweet, i was tempted to try to make my own version but i kept on seeing folks saying no on the mailing list that they were working on it so i refrained.
19:01:21 <Tekmo> pharaun: However, first I need to write a blog post
19:01:39 <Tekmo> pharaun: Well, what happened is that Andrew Cowie volunteered to do it, but then he lost interest
19:01:44 <pharaun> chrisdone: i'm in japan, i can ship you sushi ;p
19:02:04 <Tekmo> pharaun: So that's the reason progress slowed because we didn't want to step on his toes
19:02:08 <pharaun> Tekmo: ahh
19:02:31 <chrisdone> pharaun: can you ship me small boxes of soil and cups of oceaan over a number of years? perhaps i can acquire japan incrementally
19:02:46 <pharaun> anyway good news about the core infrastructure being independent, in the current timeframe i can probably just do that with conduit.
19:02:52 <Tekmo> pharaun: Yeah
19:03:07 <Tekmo> pharaun: Just take the `fromInput` and `toOutput` functions from `pipes-concurrency` and just switch them to use `conduit` operations isntead
19:03:13 <Tekmo> pharaun: It's as simple as that
19:03:18 <pharaun> been wanting to try out pipes just so i can have more experience with the ecosystem between pipes, conduit, etc..
19:03:20 <d-snp> Tekmo: I wondered, a while ago I read this cool paper about the multicore rts, which supposedly will speed up any multithreaded I/O limited application, do pipes and stm benefit from this as well?
19:03:23 <pharaun> Tekmo: sweet sounds good
19:03:55 <chrisdone> d-snp: you meaan the Mio?
19:03:59 <d-snp> yeah
19:04:03 <Tekmo> d-snp: Im not sure
19:04:12 <Tekmo> d-snp: For `pipes`, probably not
19:04:15 <Tekmo> d-snp: For `stm`, maybe
19:04:21 <Tekmo> `pipes` is single-threaded
19:04:27 <Tekmo> It's 100% deterministic
19:04:44 <Tekmo> `pipes-concurrency` is the only part of the `pipes` ecosystem that interacts with concurrency
19:04:46 <pharaun> but you can run multiple instances of a pipe?
19:04:58 <Tekmo> pharaun: Depends on what you mean by that
19:05:10 <Tekmo> pharaun: It's identical to how `conduit` behaves, if that answers your question
19:06:02 <Tekmo> A pipe is just a list of `IO` actions interleaved with await/yield requests
19:06:08 <Tekmo> Re-running a pipe just re-runs those actions
19:06:15 <Tekmo> *assuming the base monad is `IO`
19:06:32 <d-snp> hmm I think it will go fine then
19:07:43 <pharaun> Tekmo: yeah i know, but i was just mulling, ie if you want to have multi-thread such as a http server, have a loop that spawns off new instances of the pipe/connection
19:08:04 <Tekmo> pharaun: I've done this already.  I have a small example you can consult
19:08:20 <d-snp> the kind of things like that mio paper, and the stream merging stuff is what excites me most about haskell, the things that analyze general code and apply big optimizations on it, so cool :)
19:08:20 <Tekmo> pharaun: http://lpaste.net/95782
19:08:40 <Tekmo> That's the post I'm writing up right now
19:08:48 <Tekmo> It's about how I use rewrite rules to speed up pipes (a lot)
19:09:11 <pharaun> Tekmo: ohh, cool, looking
19:09:33 <pharaun> i haven't tried to learn rewrite rules yet, then again for most stuff the performance is being limited by the network mostly so i'm not usually worried.
19:09:38 <Tekmo> pharaun: That uses the `pipes-network` library which in turn uses the `network-simple` library.  The `serveFork` library lets you easily spawn a thread for each new incoming ocnnection
19:09:47 <Tekmo> pharaun: Yeah, typically `IO` overhead dominates
19:09:54 <pharaun> yeah that's what i was pondering, some sort of setup like that.
19:11:23 <xxx-man> can one point me wether there is a chanel where to discus about lambda calculus?
19:14:45 <d-snp> good night people :)
19:15:36 <Tekmo> Good night!
19:16:55 <pharaun> nn
19:17:17 <pavonia> xxx-man: Discussions about that are usually accepted here
19:18:08 <pavonia> xxx-man: or maybe ##logic is more appropriate
19:18:17 <xxx-man> pavonia: I have bit specific question, would be much better there is a chanel about this topic
19:18:37 <xxx-man> pavonia: logic seems to very slow motion chanel
19:18:54 <pharaun> Tekmo: ahh didn't think about the STM reference+hash
19:22:17 <byorgey> xxx-man: well, if you are asking whether there is a lively, active channel specifically for discussing lambda calculus, the answer is no.
19:22:59 <xxx-man> byorgey: thx. that is what I wanted to make sure :)
19:25:22 <erisco> why are vectors preferred over arrays?
19:26:04 <SLi> How do I run a monadic action until a monadic condition is True, gathering the results?
19:27:11 <startling> SLi: I think it's in monad-loops
19:27:15 <startling> @hackage monad-loops
19:27:15 <lambdabot> http://hackage.haskell.org/package/monad-loops
19:27:28 <SLi> Hm, maybe I'm thinking too difficultly. I just want to write a Get [Foo] which reads Foos until it reaches end of file/string.
19:27:32 <SLi> startling: thanks.
19:27:56 <SLi> whileM. Excellent.
19:28:09 <erisco> Tekmo, I believe you were saying to use vectors over arrays
19:28:10 <erisco> why is that?
19:28:19 <startling> SLi: untilM might be what you asked for.
19:28:26 <SLi> Yeah.
19:28:40 <startling> but yeah, handy package to avoid writing glue code.
19:32:19 <Tekmo> erisco: `vector` has lots of optimizations that arrays don't
19:32:37 <Tekmo> erisco: `vector` implements stream fusion just like lists do
19:32:45 <Tekmo> erisco: The difference is that `vector` fusion is even faster
19:33:01 <Tekmo> erisco: Vectors actually have two possible representations
19:33:10 <Tekmo> erisco: One internal representation is the obvious one (backed by an array)
19:33:21 <Tekmo> erisco: The other one is a generator that computes the elements on the fly
19:33:43 <Tekmo> erisco: `vector` tries to use the latter representation which is really efficient as much as possible in order to avoid computing intermediate vectors and also to conserve memory
19:33:52 <Tekmo> erisco: When it's not possible it falls back on the obvious representation
19:33:59 <aristid> Tekmo: are you talking about the STreams?
19:34:04 <Tekmo> aristid: Yeah
19:34:34 <aristid> Tekmo: lists also have that kind of representation then:)
19:34:43 * startling . o O ( ST reams ? )
19:34:44 <Tekmo> aristid: Yeah, I know
19:34:57 <aristid> startling: it's just a shift-key timing error:P
19:35:17 <Tekmo> aristid: So do `pipes`, if you use the `for` loop operations exclusively
19:35:18 <startling> aristid: oh, heh.
19:35:26 <Tekmo> aristid: In fact, this is what `pipes` does to generate really efficient code
19:35:38 <Tekmo> aristid: It rewrite everything as minimal for loops
19:35:40 <erisco> Tekmo, okay interesting
19:35:46 <aristid> Tekmo: oh there's a separate type for that too?
19:35:50 <Tekmo> aristid: Nope
19:35:55 <Tekmo> aristid: You can reuse `Producer` for this purpose
19:36:09 <aristid> Tekmo: ah so it just uses the code structure directly instead?
19:36:19 <Tekmo> aristid: The idea is that it converts something like: `Pipe a b m r` to `a -> Producer b m r` whenever possible
19:36:37 <aristid> ah.
19:37:02 <Tekmo> So like, if you write: p >-> filter predicate
19:37:07 <Tekmo> It will rewrite that to:
19:37:13 <erisco> I really want to contribute meaningfully somewhere :P
19:37:14 <Tekmo> for p (\a -> when predicate (yield a))
19:37:42 <aristid> Tekmo: good stuff:)
19:37:44 <Tekmo> erisco: Haskell needs good GUI bindings.  That's a good place to make an impact
19:37:49 <erisco> Tekmo, gross
19:38:00 <Tekmo> aristid: I have example where `pipes` produces code that's 7x as fast on conduit for pure loops
19:38:10 <erisco> Tekmo, nah my mind is on graphs right now :)
19:38:47 <Tekmo> erisco: You should really study the `containers` and `unordered-containers` libraries
19:39:01 <Tekmo> erisco: They are model libraries for high-performance purely functional data structures in Haskell
19:39:14 <erisco> there is a general divide between graph reps. with static reps, like Data.Graph, you have O(1) vertex access which makes dfs/bfs and a host of other algorithms more efficient
19:39:29 <erisco> however they are prohibitively expensive to modify in part
19:39:39 <Tekmo> erisco: Yeah
19:39:46 <erisco> which is where the map-based reps shine, because you can modify in logn time
19:39:51 <Tekmo> erisco: I also think `Data.Graph` is one of the weaker points of `containers`
19:40:00 <Tekmo> That's the one exception to my general recommendation to study `containers`
19:40:02 <erisco> but then you pay logn on many other algorithsm too
19:40:08 <erisco> Tekmo, why is it weak?
19:40:19 <Tekmo> erisco: It uses `Array` instead of `Vector`, for example
19:40:35 <aristid> grap fusion!
19:40:39 <erisco> well what I am suggesting is a harmony between the two representation types
19:40:40 <aristid> *graph
19:40:49 <Tekmo> erisco: What do you have in mind?
19:42:00 <erisco> well, at present you'd be able to convert between Data.Graph and another graph rep (plenty of other libraries which back with maps)
19:42:35 <erisco> and maybe that is good enough
19:42:48 <erisco> but it does mean duplication of all algorithms
19:43:00 <Tekmo> Well, `Data.Graph` has very algorithms anyway
19:43:03 <Tekmo> *very few
19:43:29 <erisco> granted, but what I mean is that if you want to write dfs, it is clumsy to write it once for vector-based graphs and all over again for map-based graphs
19:44:08 <Tekmo> Well, typically you would write the algorithm to use the `Foldable` instances of `Vector`s and `Map`s
19:44:15 <Polarina> Tekmo, is there any practical difference between Array and Vector?
19:44:16 <Tekmo> Then you can reuse the same algorithm for both
19:44:29 <aristid> Polarina: scroll up a bit:)
19:44:41 <Tekmo> Polarina: Vector has rewrite rules, stream fusion, and optional unboxed representations
19:45:04 <Tekmo> Polarina: I'd always pick `vector` over `Array`
19:45:06 <erisco> Tekmo, yes it would require abstraction to classes or to higher order functions
19:45:24 <Tekmo> erisco: What you can do is just parametrize your graph type on the type that you use for storing neighbors
19:45:27 <Tekmo> i.e.
19:45:31 <Polarina> Tekmo, ah, I see. Thanks.
19:45:56 <Tekmo> data Graph f = Node Id Payload (f Neighbors) -- or something like that
19:46:03 <Tekmo> Then your algorithm would have a signature like:
19:46:10 <Tekmo> dfs :: Foldable f => Graph f -> ...
19:46:21 <erisco> Tekmo, yes that sort of thing
19:46:24 <Tekmo> Polarina: You're welcome!
19:46:37 <erisco> now for a reasonable generic graph you'd want to be able to store data on both nodes and edges
19:46:51 <erisco> which is a weakness of Data.Graph it seems
19:46:56 <Tekmo> erisco: Just parametrize it on both types (or reuse the same container for both)
19:47:11 <Tekmo> erisco: Yes, that's another problem with it
19:47:13 <startling> I wrote a Fold-oriented graph thing once.
19:47:58 <startling> https://github.com/startling/coatl/blob/master/Language/Coatl/Extra/Graph.hs
19:48:02 <L8D> @src (.
19:48:02 <lambdabot> Source not found.
19:48:04 <L8D> @src (.)
19:48:04 <lambdabot> (f . g) x = f (g x)
19:48:04 <lambdabot> NB: In lambdabot,  (.) = fmap
19:48:21 <erisco> Tekmo, I am not sure such work would be useful to Haskellers but
19:48:38 <erisco> I guess I am interested so whatever
19:49:57 <Tekmo> Wait, lambdabot uses `fmap` and not `Control.Category.(.)`?
19:50:27 <startling> :t (.)
19:50:28 <lambdabot> (b -> c) -> (a -> b) -> a -> c
19:50:38 <startling> no, it uses (.).
19:50:42 <Tekmo> Oh
19:50:45 <startling> I think that's an old N.B.
19:52:54 <geekosaur> yeh, lambdabot stopped speaking mutant haskell
19:54:55 * hackagebot dictparser 0.1.0.0 - Parsec parsers for the DICT format produced by dictfmt -t  http://hackage.haskell.org/package/dictparser-0.1.0.0 (MarkWotton)
19:55:24 <maxs`> Can anyone explain why this can't be deduced:
19:55:24 <maxs`> Could not deduce (SingI Nat (l + m)) arising from a use of `sing'
19:55:25 <maxs`> from the context (SingI Nat l, SingI Nat m)
19:58:36 <erisco> Tekmo, what other jobs are there that are not bindings?
19:58:39 <carter> oh yeah, type lits cant math
19:58:44 <carter> maxs`: like not at all
19:58:49 <carter> only on literals can they math
19:58:56 <Tekmo> erisco: Well, first give me some rough idea of what kinds of things you are interested in
19:59:09 <augur> monochrom: hey you
19:59:11 <carter> maxs`: its one of the reasons why i'm meh about 7.8 type lists
19:59:42 <maxs`> arghh
20:00:44 <maxs`> I can do it with FlexibleContexts...
20:00:55 <carter> you mean you can abuse it
20:01:04 <carter> you can't get ghc to deduce that
20:01:04 <maxs`> i mean I can't do it
20:01:05 <carter> you have to prove
20:01:14 <carter> you can't use type lits
20:01:17 <maxs`> yeah
20:01:19 <carter> you need to use your own type nat types
20:01:21 <carter> and prove thigns
20:01:29 <L8D> @src sort
20:01:30 <lambdabot> sort = sortBy compare
20:01:35 <erisco> Tekmo, erm, well graphs atm :P "not bindings" and "not networking" and "not parallelism" might be as accurate as I can get
20:01:37 <L8D> @src sortBy
20:01:37 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:02:24 <Tekmo> erisco: So data structures, more generally?
20:02:41 <Tekmo> erisco: Do you like writing really high-performance code?
20:03:24 <erisco> Tekmo, no. I like languages, interfaces, that sort of thing
20:03:37 <maxs`> carter: does 7.6 not have subtraction?
20:03:44 <carter> maxs`: idk
20:03:46 <Tekmo> erisco: Can you elaborate on that?
20:04:05 <carter> but even type lits in HEAD can only do concrete evaluation, so deduction
20:04:32 <carter> maxs`: if you're trying to do any proofs, i suggest you use your own datakinds type like data Nat = S !Nat | Z
20:05:11 <erisco> Tekmo, erm, kinda hard to. I like things that facilitate human and machine interaction
20:05:55 <Tekmo> erisco: Ha!  Me, too!
20:06:18 <Tekmo> erisco: The term for this is mixed initiative
20:06:38 <erisco> that seems like an dod term
20:06:42 <Tekmo> erisco: Ha
20:07:12 <Tekmo> erisco: Okay, so data visualization is one area that you might potentially like
20:07:43 <erisco> Tekmo, yes sure but how does that relate to Haskell?
20:08:03 <carter> erisco: haveyou played with diagrams lib?
20:08:05 <carter> its amazing
20:08:17 <Tekmo> erisco: For example
20:08:28 <Tekmo> There is somebody on the pipes mailing list that is using pipes for medium-frequency trading
20:08:41 <carter> Tekmo: i don't think they're acutlaly trading yet
20:08:45 <carter> :)
20:08:49 <carter> *actually
20:08:49 <Tekmo> Well, whatever ! :)
20:09:09 <Tekmo> I'm just givine erisco ideas
20:09:12 <carter> the alpha heavy folks may open source their stuff
20:09:18 <carter> erisco: what ideas are you hunting for?
20:10:03 <erisco> carter, I am just curious what Haskellers are crying out for that I might be useful in helping with
20:10:07 <carter> hrmm
20:10:15 <carter> more jobs to write haskell in
20:10:17 <carter> :P
20:10:19 <erisco> (that would be a very small set of possibilities :P)
20:10:28 <erisco> carter, yeah that is true lol
20:10:44 <Tekmo> erisco: So my thesis was all about using Haskell to improve man/machine interactions for protein design
20:11:15 <Tekmo> erisco: This is a brief summary: 2~http://www.haskellforall.com/2013/10/an-all-atom-protein-search-engine.html
20:11:33 <carter> and ive been figuring out a roadmap for building better tools for numerical computing
20:11:43 <Tekmo> erisco: I can also link you a video so that you can see what it looks like
20:11:57 <erisco> Tekmo, sure
20:12:15 <erisco> I do not know what it means to design a protein though
20:12:31 <carter> erisco: "designing how to build big ass molecules"
20:12:38 <Tekmo> erisco: Proteins are like your body's robots
20:12:47 <Tekmo> Protein design is all about programming living beings at the molecular level
20:14:54 <Tekmo> My thesis combines a Haskell search engine for proteins with molecular graphics software to let you incrementally build proteins like legos
20:15:19 <randomclown> How do I add a cabal dependency to my project?
20:15:41 <carter> randomclown: you mean add a lib dep?
20:15:46 <randomclown> am I supposed to manually edit the .cabal file
20:15:50 <carter> sure
20:15:51 <pharaun> yup
20:15:52 <Tekmo> randomclown: Yeah, that's the easiest wa
20:16:06 <randomclown> why can't they make it like npm
20:16:11 <randomclown> npm install blah -save
20:16:13 <Tekmo> cabal init will autogenerate lib dependencies
20:16:21 <carter> wait it can?
20:16:22 <ppppp> hi all
20:16:25 <ppppp> may i ask a question or two?
20:16:25 <Tekmo> I don't know if there is a feature similar to that for after you've already got your project going
20:16:29 <Tekmo> carter: I think so
20:16:34 <carter> randomclown: but custom builds are needed for fancy things
20:16:34 <ppppp> i know python well, php well, and c pretty well
20:16:37 <ppppp> i have a friend
20:16:38 <Tekmo> carter: Never tried it, but that's what I've heard
20:16:42 <ppppp> that doesnt really know ANY language that well
20:16:46 <ppppp> but all he talks about is haskell
20:16:47 <ppppp> i told him
20:16:53 <ppppp> its weird to learn haskell before u even know
20:17:00 <ppppp> html/css even
20:17:01 <ppppp> but he
20:17:04 <ppppp> just is obessed
20:17:06 <Tekmo> Is this a joke?
20:17:06 <ppppp> can someone tell me
20:17:09 <ppppp> what haskell is about
20:17:13 <ppppp> nope im serious man
20:17:16 <randomclown> npm is really miles ahead of cabal
20:17:17 <ppppp> hes a confused kid starting out
20:17:20 <ppppp> and i guess someone said
20:17:24 <ppppp> haskell is cool
20:17:26 <ppppp> and he just
20:17:27 <Tekmo> I mean the HTML/CSS part
20:17:28 <carter> haskell is a great way to learn
20:17:30 <ppppp> all he talks about is that
20:17:35 <ppppp> Tekmo im saying
20:17:39 <ppppp> for someone to wanna learn haskell
20:17:41 <erisco> ah so Haskell is not mainstream thus "cool"
20:17:45 <ppppp> and cant even write a static html site
20:17:49 <ppppp> is weird dont u think?
20:17:56 <ppppp> not comparing them for usuag
20:17:57 <Tekmo> There is more to programming than web development
20:17:59 <erisco> ppppp, can they use a mouse and navigate a file system?
20:18:01 <ppppp> yes there is
20:18:12 <ppppp> so i would love
20:18:14 <ppppp> to learn this lang
20:18:22 <ppppp> because it most be something special
20:18:27 <ppppp> for him to be so obssess
20:18:29 <ppppp> also he loves math
20:18:31 <ppppp> so i think thats why?
20:18:34 <ppppp> but i know nothing about it
20:18:36 <carter> randomclown: its not that simple
20:18:38 <Tekmo> That's probably part of the reason
20:18:38 <carter> i've used both
20:18:40 <ppppp> can someone give me few ideas of it etc
20:18:48 <ppppp> im very good at python
20:18:55 <Tekmo> So you want to know what differentiates it from other languages?
20:18:55 <ppppp> i use twisted library the most <3
20:19:00 <carter> ppppp: read learn you a haskell :)
20:19:06 <ppppp> and like why is it unique for someone to be so obsessed
20:19:13 <Tekmo> So, off of the top of my head, some of the biggest features that are (mostly) unique are:
20:19:14 <ppppp> he is
20:19:17 <ppppp> all he tlaks about
20:19:27 <carter> randomclown: npm "works" for simple stuff, its also scary wrong for complex stuff
20:19:30 <Tekmo> 1. Category theory design patterns (i.e. "monads" and friends)
20:19:33 <Tekmo> 2. Laziness
20:19:36 <Tekmo> 3. Equational reasoning
20:19:45 <Tekmo> 4. Side effects are first-class values within the language
20:19:50 <randomclown> carter: like?
20:19:51 <Tekmo> 5. Really sexy type system
20:19:58 * hackagebot dictparser 0.1.0.1 - Parsec parsers for the DICT format produced by dictfmt -t  http://hackage.haskell.org/package/dictparser-0.1.0.1 (MarkWotton)
20:20:07 <khyperia> Mmm, dat type system
20:20:14 <Tekmo> Basically :)
20:20:14 <khyperia> ... did I really just say that
20:20:20 <carter> randomclown: each lib in npm gets a private copy of its deps
20:20:33 <randomclown> carter: that's the way it's supposed to be done
20:20:38 <carter> nope
20:20:45 <carter> those deps can leak through the api
20:20:51 <pharaun> npm breaks in really weird ways on complicated deps, we run a hubot bot at work, and its a pain in the f'ing ass
20:20:57 <Tekmo> carter is right
20:21:11 <carter> i have a client that has a massive Node code base, and its amazing engineering
20:21:13 <carter> but
20:21:15 <Tekmo> If two libraries depend on a shared library and they each install different versions of that library as a dependency, it will cause problems when they interact
20:21:17 <carter> NPM scares me
20:21:33 <pharaun> some of the problems we have had is what carter said,  some of our issues are interdeps leaking through and going weird
20:21:51 <carter> pharaun: thankee, i'm not super articulate right now :)
20:21:53 <carter> i'm derp in the code ;)
20:22:05 <pharaun> :p
20:22:18 <carter> hacking on the first lib of numerical haskell
20:22:21 <Tekmo> ppppp: Probably the biggest immediate payoff of learning Haskell is the type system
20:22:27 <pharaun> agreed ^
20:22:34 <carter> the type system is a great vocab for engieernign
20:22:39 <ppppp> Tekmo ?
20:22:40 <ppppp> laziness?
20:22:43 <ppppp> its really easy?
20:22:48 <ppppp> give me of an example
20:22:49 <carter> laziness is handy somtimes
20:22:50 <Tekmo> Oh
20:22:54 <carter> but not as important as other things
20:22:56 <ppppp> of a program that would be easier in haskell than python
20:22:57 <ppppp> and why
20:23:02 <Tekmo> Laziness refers to the fact that Haskell only computes as much as you request
20:23:09 <Tekmo> An example is something like this
20:23:13 <pharaun> so for ex, i can generate an infinite list
20:23:16 <ppppp> give me example of something
20:23:17 <Tekmo> > sum (drop [1..])
20:23:18 <lambdabot>  Couldn't match expected type `[a0]' with actual type `[a1] -> [a1]'Couldn't ...
20:23:19 <lambdabot>              with actual type `[t0]'
20:23:20 <pharaun> then lazly take what i need from it
20:23:20 <ppppp> you would use haskell for
20:23:23 <ppppp> over other languages
20:23:24 <Tekmo> > sum (take 10 [1..])
20:23:25 <lambdabot>  55
20:23:26 <ppppp> not because u are best at it
20:23:29 <ppppp> but because its better for it
20:23:40 <carter> pharaun: low latency high throughput computing without crashing
20:23:45 <Tekmo> ppppp: Haskell currently excels at server-side programming
20:23:51 <pharaun> ppppp: for me what makes haskell so powerful is the composibility/type
20:23:52 <Tekmo> ppppp: That's its biggest niche at the moment
20:23:56 <pharaun> carter: that too
20:24:07 <carter> there are people using haskell in problem spaces where otherwise they'd have to use C++ or something that would crash
20:24:08 <mauke> ppppp: a compiler
20:24:13 <carter> oh yeah tha too
20:24:25 <Tekmo> ppppp: Haskell servers are ultra-dependable
20:24:26 <startling> parsing is so nice in Haskell
20:24:29 <pharaun> carter: one issue we've had with nodejs at work is one plugin dying and taking down the entire system
20:24:33 <Tekmo> ppppp: Yes, parsing is great, too
20:24:37 <Tekmo> That's how I got hooked on Haskell
20:24:37 <pharaun> parsing is terrific
20:24:38 <carter> pharaun: egods
20:24:44 <Tekmo> I worked in bioinformatics, so I do a boatload of parsing
20:24:48 <carter> pharaun: what do you work on?
20:24:49 <carter> at
20:24:51 <carter>  or which
20:24:51 <Tekmo> Haskell parsing is so much better than other languages
20:24:58 * hackagebot dictparser 0.1.0.2 - Parsec parsers for the DICT format produced by dictfmt -t  http://hackage.haskell.org/package/dictparser-0.1.0.2 (MarkWotton)
20:25:00 <carter> though theres room for even better parsing tech
20:25:12 <startling> yeah, agreed.
20:25:14 <pharaun> carter: my work is a python shop, but we run an irc-bot in hubot/nodejs and there's some folks trying to pick up nodejs for other work stuff
20:25:23 <carter> gotcha
20:25:35 <carter> python ... hasn't evolved much in the past decade
20:25:38 <carter> at least the core
20:25:42 <carter> theres some amazing stuff in python
20:25:42 <pharaun> py3
20:25:45 <carter> but its despite the core
20:25:55 <pharaun> we're still stuck on py2.6 i'm sad
20:25:59 <startling> carter, eh, it totally has
20:26:10 <pharaun> there's the new tulip and from yield stuff
20:26:15 <pharaun> in python ... 3.4 i think?
20:26:16 <carter> ok, py 3.3 has some cool stuff
20:26:19 <carter> yes that
20:26:21 <carter> tulip?
20:26:26 <pharaun> its what its called
20:26:32 <startling> carter, iterat{or,able}s, unicode support, ...
20:26:35 <pharaun> its async/event framework thing
20:26:35 <carter> ok
20:26:37 <carter> yes
20:26:40 <startling> tulip is guido's event interface
20:26:41 <carter> sure
20:26:57 <Tekmo> For me, the biggest issue with python is the dynamic typing
20:27:03 <carter> i just think that if they had a type checker py3 adoption would have been faster
20:27:09 <Tekmo> And the pervasive use of maps as infinite bags of holding
20:27:10 <carter> :)
20:27:14 <carter> hehe
20:27:16 <pharaun> anyway carter what do you mean by better parsing tech, most of my needs are addressed pretty well with parsec 3
20:27:17 <carter> i want one of those
20:27:21 <pharaun> Tekmo: agreed, egads
20:27:30 <carter> pharaun: a simple GLL parser combinator lib would be magic
20:27:38 <carter> i spent a month or so last winter thinking about it
20:27:39 <pharaun> Tekmo: some of the worst problems at work are the dynamic types and bags of bags of bags of maps
20:27:39 <carter> gave up
20:27:49 <Tekmo> pharaun: Tell me about it
20:27:56 <pharaun> carter: ah, any specific reason that made you give up?
20:27:59 <Tekmo> pharaun: I had to write a plugin for a Python program that was just like that
20:28:01 <carter> give what up?
20:28:04 <Tekmo> pharaun: Everything was in some undocumented map
20:28:13 <pharaun> Tekmo: yup sounds like my work codebase :\
20:28:20 <carter> Tekmo: btw, i hacked out a nice way to handle complex numbers haskell's ffi :)
20:28:25 <pharaun> and you would have lovely patterns like _extend_x_map
20:28:25 <Tekmo> carter: How?
20:28:25 <carter> idk if you care abou that
20:28:32 <erisco> carter, general LL parser?
20:28:39 <pharaun> and you would just pass in random map X, and it would convert/update/extend it with more information
20:28:44 <carter> GLL == fast ambiguous parsers
20:28:50 <pharaun> then you weave it through multiple versions of that :\
20:28:52 <Tekmo> carter: I try to care a little bit about everything
20:29:02 <erisco> carter, for LL gramamrs?
20:29:02 <carter> https://github.com/wellposed/hOpenBLAS/blob/master/src/Numerical/OpenBLAS/UtilsFFI.hs
20:29:05 <carter> sure
20:29:12 <carter> erisco: same as parser combiantors
20:29:16 <pharaun> carter: complex as in  "3+1i" ?
20:29:19 <carter> yes
20:29:22 <pharaun> nice
20:29:25 <Tekmo> pharaun: Yep, I feel like we are code brothers already
20:29:27 <carter> the haskell ffi can't do complex numbers
20:29:42 <carter> so i made a wee way to nicely take any storable value and pointerify it
20:29:50 <erisco> carter, I have combinators for general CFGs but I did not implement the parts necessary for efficient ambiguous parsing
20:30:02 <erisco> carter, however I did start that work
20:30:03 <pharaun> Tekmo: hehe, but yeah that's what drove me into haskell and hence why i do all of my personal projects in haskell to get a break from that... stuff.
20:30:03 <carter> mind you only works for things that take a pointer to their result value
20:30:18 <pharaun> ah
20:30:19 <Tekmo> carter: Doesn't `with` do this already?
20:30:25 <carter> with?
20:30:35 <Tekmo> http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Marshal-Utils.html#v:with
20:30:36 <carter> not quite
20:30:37 <pharaun> carter: is this with just blas? ie library dependent?
20:30:39 <pharaun> i'm looking now
20:30:42 <erisco> carter, I don't know if that interests you. my undergrad paper is on the work I did with it
20:30:56 <carter> Tekmo: doh
20:31:02 <carter> Tekmo: nb: this one works with ST too :)
20:31:08 <Tekmo> carter: That's true :)
20:31:28 <Tekmo> carter: You should definitely study `Foreign.Marshal` heavily if you are going to be working with `Storable` a lot
20:31:39 <Tekmo> `Storable` is the bees knees
20:32:13 <Tekmo> I came to Haskell from C, and every time I use `Storable` I feel like I'm programming in C again, both with the coding style and increased performance
20:32:29 <carter> eh,
20:32:32 <carter> unboxed is better
20:32:34 * enthropy pokes Tekmo
20:32:39 <Tekmo> They give similar performance
20:32:46 <carter> not once we have simd :)
20:32:51 <erisco> carter, no? :(
20:32:52 <Tekmo> That's true
20:33:05 <carter> Unboxed has a memory format thats WAY better for SIMD
20:33:12 <ChongLi> generalised stream fusion?
20:33:17 <carter> ChongLi: not that
20:33:18 <carter> :)
20:33:21 <carter> stream fusion is boring :)
20:33:36 <ChongLi> I thought the generalised stream fusion paper was about SIMD
20:33:40 <carter> it was
20:34:07 <carter> its just stream fusion only is useful for pointwise algs
20:34:11 <carter> those are boring :)
20:34:33 <ChongLi> ahh, where else are we getting SIMD?
20:34:39 <carter> i have plans
20:34:39 <pharaun> carter: oh good to know, i've been wanting to hook up a few home-grown SIMD libraries into haskell
20:34:43 <pharaun> for image crunching
20:34:46 <ChongLi> SIMD primops?
20:34:51 <carter> yes
20:34:52 <carter> those
20:34:57 <ChongLi> very nice
20:34:59 * hackagebot dictparser 0.1.1.0 - Parsec parsers for the DICT format produced by dictfmt -t  http://hackage.haskell.org/package/dictparser-0.1.1.0 (MarkWotton)
20:35:00 <pharaun> i'm going to be looking into unboxed then
20:35:01 <carter> the llvm backend has some boring ones
20:35:11 <carter> pharaun: we shoudl also get a SOA storable too
20:35:29 <Tekmo> If you get a really performant Haskell numerical library going it will definitely make waves
20:35:38 <Tekmo> Just like the MIO paper did for networking
20:35:40 <carter> Tekmo: for the next year it'll have to use C / ffi stuff
20:35:47 <Tekmo> carter: That's 100% okay with me
20:36:30 <carter> the hOpenBLAS stuf fi'm doing this month is to make sure that theres a BSD BLas binding i can fall back on when haskell isn't fast enough
20:36:38 <benbangert> don't suppose anyone knows whether Data.Sequence takes more or less space for a structure than the Data.Vector equivilant?
20:36:46 <Tekmo> Vector is very compact
20:36:57 <carter> sequence is a different thing
20:37:14 <Tekmo> It stores things contiguously and the only overhead is the vector length and a couple of other ints for slicing
20:37:15 <carter> Vector is a verry very clever array lib
20:37:26 <benbangert> carter: yes, that was my understanding
20:37:29 <Tekmo> benbangert: Also, vector sometimes won't even create the vector
20:37:36 <pharaun> carter: SOA?
20:37:40 <carter> Struct of arrays
20:37:44 <Tekmo> benbangert: If you can go over the vector in a single pass it will just stream the contents and run in constant space
20:37:47 <pharaun> yes that would be useful
20:37:49 <carter> Storable ==  Array of Struct
20:38:12 <carter> Tekmo: you're talking about stream fusion
20:38:16 <Tekmo> carter: Right
20:38:24 <ChongLi> array of struct is much nicer for stuff like opengl
20:38:25 <carter> thats not quite how stream fusion works
20:38:29 <carter> agreeed
20:38:30 <randomclown> When building with cabal-dev, is it just cabal-dev build?
20:38:39 <carter> randomclown: use cabal 1.18 :)
20:38:43 <startling> ^
20:39:06 <benbangert> hmmm
20:39:09 <carter> cabal update ; cabal install cabal-install ; mkdir SuchWow ; cd SuchWow ; cabl sandbox init
20:39:14 <carter> *cabal
20:39:16 <Tekmo> lol
20:39:32 <carter> errr *"cabal init ; cabal sandbox init"
20:40:05 <Tekmo> Don't forget that you need to add ~/.cabal/bin/ to your path to get the newly installed cabal
20:40:07 <ChongLi> speaking of sandboxes
20:40:09 <randomclown> hmm I installed cabal through my package manager, 1.18 isn't there yet, not sure what happens if I ask cabal to update itself
20:40:24 <Tekmo> randomclown: It will install the new cabal in ~/.cabal/bin
20:40:24 <ChongLi> hoogle doesn't seem to play very nice with them
20:40:26 <startling> randomclown: it will install the new cabal in ~/.cabal/bin
20:40:28 <startling> yeah
20:40:45 <Tekmo> startling: If only you had capitalized your sentence
20:40:47 <startling> randomclown: (remember not to use sudo with cabal ever)
20:40:48 <SparkySparkyBoom> lambdabot, help
20:40:51 <randomclown> alright cook
20:40:53 <randomclown> cool*
20:41:14 <ChongLi> and when I run hoogle data all I get an annoying runtime error on reactive-glut
20:41:26 <SparkySparkyBoom> ! ("tro" ++ (take 30 (cycle "lo")))
20:41:38 <carter> Tekmo: unless you're on haskell platform
20:41:39 <carter> but yeah
20:41:43 <Tekmo> SparkySparkyBoom: use "> " at the beginning to evaluate code here
20:42:05 <carter> > id "ninja"
20:42:06 <lambdabot>  "ninja"
20:42:10 <SparkySparkyBoom> > ("tro" ++ (take 30 (cycle "lo")))
20:42:11 <lambdabot>  "trolololololololololololololololo"
20:42:13 <SparkySparkyBoom> :D
20:42:16 <SparkySparkyBoom> Tekmo, tyvm
20:42:21 <Tekmo> SparkySparkyBoom: You're welcome
20:43:10 <sebastian_> hey guys, I've a very strange linker error here
20:43:18 <carter> lpaste it!
20:43:37 <sebastian_> https://raw.github.com/sebastian-philipp/hamlet_snappy/master/README.md
20:43:57 <sebastian_> this is the repo with a sample main: https://github.com/sebastian-philipp/hamlet_snappy
20:44:22 <carter> oh
20:44:29 <carter> sebastian_: use ghc 7.7 / HEAD
20:44:33 <carter> snappy uses a C++ code base
20:44:44 <carter> ghci and C++ haven't been friends historically
20:45:21 <sebastian_> carter: ty. do you know why template haskell is triggering linker errors  here?
20:45:23 <carter> that fixed in GHC head
20:45:29 <carter> yes
20:45:31 <carter> TH uses GHCI
20:45:37 <Tekmo> carter: ghc-7.7 supports an FFI for C++?
20:45:43 <carter> Tekmo: nope
20:45:47 <carter> you still have to Extern C
20:45:48 <carter> BUT
20:45:54 <carter> it uses the system linker for GHCI
20:45:56 <carter> so things work
20:46:06 <oleo> THCGI lol
20:46:33 <ChongLi> how'd we end up with our own linker anyway?
20:46:37 <carter> reasons
20:46:40 <carter> like not having dylinking
20:46:45 <carter> so we had to fake dylinking with static objects
20:46:58 <ChongLi> ahhh
20:46:58 <carter> not many languages ever get their own crazy linker
20:47:05 <carter> so its kinda cool
20:47:20 <carter> even though you should be glad its going to not bwe the default going forward
20:47:33 <pharaun> oh i have an question regarding haddock actually. Is there any good way to make haddock link to other libraries haddock docs? i recently tried to enable local haddock docs and it works but often they will only link to their own reference, and not link to *other* libraries
20:47:39 <ChongLi> yeah, there's a lot of crazy stuff lurking around
20:47:40 <pharaun> is there something i am missing here?
20:47:57 <Tekmo> pharaun: No
20:48:07 <Tekmo> pharaun: Haddock always goes for the most local definition
20:48:10 <sebastian_> ok ty carter & ChongLi
20:48:13 <carter> np
20:48:18 <pharaun> Tekmo: then how does hackage do it?
20:48:20 <ChongLi> will we ever reach a stage where linux distros can ship Haskell libraries with dynamic linkin?
20:48:28 <Tekmo> pharaun: Hmm, it should be the same as Hackage
20:48:31 <carter> nope
20:48:33 <carter> thers a difference
20:48:34 <pharaun> ie if i have X library and it depends on some stuff in say Data.Text
20:48:35 <carter> urm
20:48:37 <pharaun> i don't get a link
20:48:45 <pharaun> while on hackage you would
20:48:53 <carter> i've seeen a script for that
20:48:54 <carter> hangon
20:49:13 <pharaun> just would be nice to get a local haddock docs to all link properly for when i'm on the road/no internet
20:49:15 <ChongLi> people on reddit were complaining about the enormous size of the ghc package in some cases
20:49:19 <ChongLi> 700+MB
20:49:22 <Tekmo> Yeah, I saw that
20:49:28 <Tekmo> That's for debian, though
20:49:31 <pharaun> carter: oh? k
20:49:36 <Tekmo> It is probably installing other things
20:49:52 <Tekmo> du -hs /usr/lib/ghc
20:49:54 <Tekmo> Oops
20:49:55 <Tekmo> lol
20:50:35 <ChongLi> yeah mine shows up as 733MB
20:50:38 <maxs`> carter: Illegal type constructor or class name: `<='
20:50:38 <maxs`> huh?
20:50:42 <Tekmo> Yeah, all the memory is being taken up by libraries that come with `ghc` by default
20:50:48 <Tekmo> Mine is 567 MB
20:51:06 * AngryBeers shits inside of tekmo's mouth after eating 40 ears of corn and a bottle of pentalax
20:51:14 <ChongLi> but I hardly have anything listed in /usr/lib/ghc-7.5.3/package.conf.d
20:51:17 <thepreacher> newbie here, I'm on Arch linux and the book Real World Haskell recommends the installation of some packages ghc6-prof and libghc6-mtl-dev. Obviousely its a long time ago since the book was written so the names of packages could have changed. Currently what are the equivalent packages the replaces the recommended once?
20:51:40 * AngryBeers then shoots his hot jizz into chongli's face after masterbating over his ball sack
20:51:44 <geekosaur> those names look debianish, not arch
20:51:48 <Tekmo> thepreacher: You can probably just remove the `6`
20:51:49 <startling> thepreacher, sudo pacman -S ghc
20:52:03 <startling> then you should probably cabal install mtl
20:52:04 <carter> yeah
20:52:05 <Tekmo> thepreacher: On debian, the new names are `ghc-prof` and `libghc-mtl-dev`
20:52:17 <ChongLi> just Cabal, array, base, ibn-package-db, binary, bytestring, containers, deepseq, directory, filepath, ghc, ghc-paths, ghc-prim, haddock, haskell2010, haskell98, hoopl, hpc, integer-gmp, old-locale, old-time, pretty, process, rts, template-haskell, time, unix, xhtml
20:52:23 <ChongLi> I guess that's quite a bit, haha
20:52:35 * AngryBeers loves to cum inside of carter's ass and then slurp out the diarrhea semen mixture with a straw straight from his rectum
20:52:46 <geekosaur> there is a cabal file to automate getting the platform
20:52:58 --- mode: ChanServ set +o geekosaur
20:53:26 <pharaun> mine is ~567mb on my laptop
20:53:37 <Aetherspawn> is someone going to kick and ban AngryBeers or what
20:53:38 <Tekmo> The big offender is the ghc library itself
20:53:43 <Aetherspawn> Cale: pong
20:53:52 <Tekmo> 240 MB for just /usr/lib/ghc/ghc-7.4.1
20:53:54 --- mode: geekosaur set +q *!AngryBeer@200.79.253.35
20:54:01 <AngryBeers> wow
20:54:02 <pharaun> desktop is 665mb, that's not bad at all really
20:54:04 <geekosaur> bah
20:54:08 --- mode: geekosaur set +b *!*AngryBeer@200.79.253.*
20:54:09 --- kick: AngryBeers was kicked by geekosaur (AngryBeers)
20:54:11 <pharaun> and i have profiling, dynlink, static link, etc versions
20:54:12 <thepreacher> thanks all, I've currently just installed ghc and cabal. What about the cabal file to autmate the plat form? Where can I getit
20:54:13 <Tekmo> Followed closely by `base` and `Cabal`
20:54:15 <Aetherspawn> there we go
20:54:16 <Aetherspawn> :P
20:54:22 <geekosaur> not doing well tonight I guess
20:54:23 <startling> geekosaur: thanks!
20:54:26 <carter> heh
20:54:28 --- mode: geekosaur set -q *!AngryBeer@200.79.253.35
20:54:29 <pharaun> geekosaur++ thanks
20:54:32 <ChongLi> hehe
20:54:34 <geekosaur> typo somewhere in there I guess
20:54:40 <startling> geekosaur, forgot the s
20:55:02 * hackagebot dictparser 0.1.1.1 - Parsec parsers for the DICT format produced by dictfmt -t  http://hackage.haskell.org/package/dictparser-0.1.1.1 (MarkWotton)
20:55:02 <geekosaur> no, I starred the nick part and the username part lacks the s
20:55:07 <startling> oh.
20:55:17 <carter> if we get GC-sections and Dylining working better for GHC, object sizes should go down nicely
20:55:28 <carter> *dynlinking
20:56:04 <carter> GC-sections / function sections espectially
20:56:57 <pharaun> dynlinking is neat, i had to really tweak things a bit on gentoo
20:56:58 <ChongLi> GC-sections? for capabilities?
20:57:09 <pharaun> and sometime things goes... weird :\ but still progress
20:57:17 <maxs`> carter: wth, typenats are done after TH?
20:57:25 <carter> maxs`:?
20:57:27 <pharaun> curious how come we can't just use the gold linker for dynlink/linking ?
20:57:52 <startling> gold only supports ELF
20:57:52 <startling> that's at least one limitation.
20:57:52 <Aetherspawn> If you used the gold linker you can get LTO on llvm builds
20:57:52 <geekosaur> we do on some platforms, I think
20:57:53 <geekosaur> althoiugh 7.6.3- has trouble with it sometimes
20:57:59 <maxs`> instance (<=) 1 1 compiles
20:58:06 <geekosaur> and yes, gold is entirely useless on windows or os x
20:58:18 <maxs`> derived instance (<=) 1 1 from TH is not in scope
20:58:59 <geekosaur> biggest problem with gold on linux is that if ghc was built against binutils it includes some options to increase table sizes, which break gold
20:59:21 <geekosaur> s/binutils/ld-bfd/
20:59:26 --- mode: geekosaur set -o geekosaur
21:00:17 <geekosaur> I *think* if you build ghc with gold, it will detect it and leave off the extra options; that might only be in HEAD though
21:00:17 <SparkySparkyBoom> is there any sort of guide on order to start with emacs/haskell-mode?
21:00:42 <SparkySparkyBoom> also, geekosaur is AngryBeer a troll?
21:00:49 <geekosaur> no idea
21:00:53 <SparkySparkyBoom> nvm
21:00:54 <SparkySparkyBoom> scrolled back
21:01:11 <geekosaur> I didn't see the start of it, just noticed the noise later
21:01:36 <SparkySparkyBoom> eh you missed out
21:01:36 <pharaun> probably a troll
21:01:40 <SparkySparkyBoom> it was quite entertaining
21:01:41 <SparkySparkyBoom> :)
21:03:56 <maxs`> carter: found it… https://ghc.haskell.org/trac/ghc/ticket/7667
21:04:21 <carter> maxs`: so fixed in head?
21:04:26 <maxs`> yeah
21:04:46 <geekosaur> so as to emacs haskell-mode, http://haskell.github.io/haskell-mode/manual/latest/ might be helpful
21:04:48 <maxs`> work around:
21:04:48 <maxs`> type Less = (<=)
21:07:22 <maxs`> carter: :P http://i.imgur.com/rxqd7vP.png
21:07:44 <carter> maxs`: eh?
21:07:54 <maxs`> so a vector of 10
21:08:01 <carter> maxs`: now try to write some 2d matrix stuff that way
21:08:03 <carter> i think its too hard
21:08:11 <carter> esp if you're dealing with data dependent stuff
21:08:15 <carter> and recusrive decompostion
21:08:32 <maxs`> yeah, but aren't you curious how 9<=10 and 5<=10 is defined?
21:08:37 <carter> sure
21:08:38 <carter> share
21:10:03 <SrPx> `f . g h` is `(f . g) h` or `f . (g h)` ?
21:10:20 <L8D> Is there a shorter way to write: \(x:xs) -> foldr min x xs
21:10:36 <L8D> oh
21:10:40 <L8D> foldr1 min
21:10:40 <carter> Tekmo: this is what happens when people who write fortran don't have a good type system http://www.netlib.org/lapack/explore-html/d1/dfd/sgesvx_8f.html
21:10:41 <Tekmo> SrPx: The latter
21:10:51 <Tekmo> SrPx: Function application has highest precedence
21:10:51 <SrPx> Thanks Tekmo
21:10:56 <Tekmo> You're welcome
21:11:23 <Tekmo> carter: I know.  I've had to deal with Fortran code
21:11:25 <carter> holy crap LAPACK is begging for a DSL
21:11:31 <Tekmo> carter: Specifically the BLAS/LAPACK code
21:11:55 <carter> Tekmo: any things i've not bound yet from them you'd want?
21:12:12 <carter> i'm only going to do a basic but usable subset to start with
21:12:16 <Tekmo> carter: I was able to shed the bindings
21:12:20 <carter> yay
21:12:31 <carter> but what ops /solvers did you want /use?
21:12:33 <Tekmo> I got a personal confirmation from Richard Stallman that I could license my code under GPLv2
21:12:44 <carter> huh
21:12:55 <Tekmo> So I could use hmatrix
21:12:55 <carter> ok, so what ops from hmatrix did you use?
21:13:03 <Tekmo> svd, mainly
21:13:05 <carter> ok
21:13:11 <carter> i'm adding that next week
21:14:01 <SparkySparkyBoom> oh i found something
21:14:01 <SparkySparkyBoom> http://www.haskell.org/haskellwiki/Emacs/Keybindings_and_simple_usage
21:14:02 <SparkySparkyBoom> :D
21:16:16 <erisco> Tekmo, by using Vector you restrict vertices to being identified by Int
21:16:26 <Tekmo> erisco: That's right
21:16:27 <maxiepoo> is there an automated way of finding out what versions of your dependencies work?
21:16:32 <erisco> Tekmo, that's no good
21:16:42 <Tekmo> erisco: What kind of index did you have in mind?
21:17:03 <erisco> Tekmo, all sorts. I index by 2-tuples of Int for example
21:17:20 <Tekmo> erisco: There are three solutions I know of
21:17:29 <Tekmo> 1. Nest vectors
21:17:44 <Tekmo> 2. Reuse the `Ix` class that Array uses
21:17:50 <BlankVerse_> On running cabal configure --enable-tests on https://github.com/haskell-distributed/distributed-process-platform/blob/master/distributed-process-platform.cabal ,
21:17:54 <Tekmo> 3. Use `repa` which supports multi-dimensional arrays well
21:18:27 <BlankVerse_> I get error : http://lpaste.net/2715074073066471424
21:18:39 <erisco> Tekmo, it is trivial to overflow the Int with Ix
21:18:42 <maxs`> how do you upload to hackage...
21:18:49 <BlankVerse_> Do I need to manually install the test dependencies?
21:18:51 <maxs`> it just gives me unauthorized
21:19:06 <Tekmo> maxs`: You need an account
21:19:15 <erisco> Tekmo, with (Int, Int) you are restricted to sqrt(maxBound :: Int) =\
21:19:37 <Tekmo> maxs`: Back in Hackage 1 the way you got an account was by emailing Ross Paterson asking for one.  I don't know if that is still the way they do it or not
21:19:51 <Tekmo> erisco: That's only for solution #2
21:19:56 <Tekmo> erisco: The other two solutions still work
21:20:13 <maxs`> how do you "log in"?
21:20:33 <Tekmo> maxs`: You don't need to
21:20:44 <Tekmo> maxs`: The simplest way to upload a package is `cabal upload`
21:20:53 <Tekmo> It's a two step process
21:20:53 <L8D> > sqrt (maxBound :: Int)
21:20:54 <lambdabot>  No instance for (GHC.Float.Floating GHC.Types.Int)
21:20:54 <lambdabot>    arising from a use of `GHC.Float.sqrt'
21:20:54 <lambdabot>  Possible fix:
21:20:54 <lambdabot>    add an instance declaration for (GHC.Float.Floating GHC.Types.Int)
21:21:07 <maxs`> ah right! thanks
21:21:07 <solrize> is there some systematic way to turn recursion into a fold?  http://lpaste.net/97950  the two functions are the same (found with a bit of thought), but i'm how to do that in general
21:21:12 <solrize> e.g. in a compiler
21:21:12 <Tekmo> `cabal sdist` will generate the package you need to upload in `dist/yourpackage-X.Y.Z`
21:21:19 <L8D> > maxBound :: Integer
21:21:20 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
21:21:21 <lambdabot>    arising from a use of `GHC.Enum.maxBound'
21:21:21 <lambdabot>  Possible fix:
21:21:21 <lambdabot>    add an instance declaration for
21:21:21 <lambdabot>    (GHC.Enum.Bounded GHC.Integer.Type.Integer)
21:21:25 <solrize> it's like recursion vs induction
21:21:30 <Tekmo> Then `cabal upload dist/yourpackage-X.Y.Z` uploads it after prompting you for your Hackage username and password
21:22:33 <ChongLi> > sqrt . fromIntegral $ (maxBound :: Int)
21:22:35 <lambdabot>  3.03700049997605e9
21:23:04 <erisco> ChongLi, it is 2^16
21:23:13 <Tekmo> erisco: Not necessarily
21:23:20 <ChongLi> erisco: was just helping L8D :)
21:23:21 <Tekmo> erisco: Haskell `Int` type is not necessarily 2^32
21:23:24 <erisco> for 32-bit ints it is
21:23:40 <Tekmo> erisco: Haskell reserves at least one bit
21:23:59 <ChongLi> pointer tagging?
21:24:00 <L8D> What's the max for Integer?
21:24:03 <Tekmo> I think the Haskell report says that Ints only need to be up to 2^30
21:24:29 <L8D> And I thought that Ints were C ints
21:24:36 <pharaun> how do we handle bigger than 2^30 integer? -> gmp right?
21:24:38 <ChongLi> no, that's CInt
21:24:46 <L8D> Oh
21:24:49 <pharaun> so that makes me wonder how FFI handles it, is that automatic?
21:24:53 <lispy> pharaun: or Int64
21:25:06 <ChongLi> > maxBound :: CInt
21:25:07 <lambdabot>  Not in scope: type constructor or class `CInt'
21:25:07 <lambdabot>  Perhaps you meant one of these:
21:25:07 <lambdabot>    `Int' (imported from Data.Int),
21:25:07 <lambdabot>    `Cont' (imported from Control.Monad.Cont)
21:25:07 * hackagebot acme-numbersystem 0.1.0.0 - Define the less than relation for numbers up to a number  http://hackage.haskell.org/package/acme-numbersystem-0.1.0.0 (MaxwellSwadling)
21:25:07 <pharaun> lispy: but isn't int64 also bound by the same thing like 2^60 ?
21:25:13 <lispy> Int != CInt (although, it can be if the implementation chooses to)
21:25:14 <erisco> Tekmo, it would seem more prudent to use a hash
21:25:21 <ChongLi> ahh, no Foreign.C :(
21:25:25 <Tekmo> erisco: For what?
21:25:35 <erisco> Tekmo, a hash table
21:25:55 <Tekmo> erisco: For multidimensional vectors?
21:25:58 <erisco> for example, in subset construction, the keys are lists (or even sets)
21:26:11 <lispy> pharaun: Integer is not automatically handled by the FFI. The FFI works on CInt. Does that help?
21:26:41 <erisco> Tekmo, no for supporting a wider variety of key types
21:26:50 <SparkySparkyBoom> does anyone know how i might get tab completion working in ghci when using emacs?
21:26:55 <pharaun> lispy: digging up the docs on that again, so many int types, so i get it mixed up :)
21:26:59 <ChongLi> using hashmaps is a bit annoying in Haskell since you've got to derive an instance of Hashable
21:27:12 <erisco> tough :P
21:27:26 <ChongLi> that's one area where I envy Clojure
21:27:32 <ChongLi> everything is hashable by default
21:27:41 <pharaun> lispy: ahh yes, makes more sense, nvm :) that was a dumb question
21:27:42 <ChongLi> and thus they use hashmaps everywhere
21:27:47 <erisco> how is that so? there are many hashing strategies
21:28:01 <L8D> Also clojure hashmaps are just more usable since everything is dynamically typed
21:28:01 <Tekmo> Doesn't the JVM have a built-in hasing strategy?
21:28:06 <Tekmo> *hashing
21:28:11 <ChongLi> probably
21:28:26 <pharaun> murmur3 ?
21:28:27 <L8D> jes, the JVM does have a built-in hasing stradegy.
21:28:45 <ChongLi> in Clojure they use hashmaps where we'd use ADTs
21:28:54 <L8D> strategy*
21:29:14 <erisco> Tekmo, so that raises yet another optimisation to worry about
21:29:27 <ChongLi> and so while it's very flexible, it's not type safe or very fast at all
21:29:43 <L8D> fast is a relative term
21:29:43 <monochrom> no, I don't envy clojure, java, or scala for their pervasive Eq and Hashable
21:29:44 <ddellacosta> I'm a relative newb to Haskell, but I've used Clojure a lot, and I can say that what ChongLi is saying is dead on--you don't need hash-maps in Haskell to the same degree as the way hash-maps are used in Clojure is to define a data type, in many many cases.
21:30:03 <L8D> Fast is a VERY relative term
21:30:13 <monochrom> in fact, the speaker of "we're doing it wrong" is not fond of it either
21:30:24 <pharaun> i'm not a fan of maps as data structure
21:30:36 <pharaun> at least clojure got schema for somewhat validating the maps
21:30:36 <Tekmo> monochrom: Yeah, I remember that talk
21:30:55 <Tekmo> monochrom: I had no idea that so few people worked on the Scala compiler
21:31:00 <monochrom> a lot of types are not meant to make sense for "has =" or "has hashing"
21:31:03 <L8D> Fast is an EXTREMELY relative term: http://www.techempower.com/benchmarks/#section=data-r8&hw=i7&test=json
21:31:14 <ChongLi> yeah that's true
21:31:39 <L8D> AndL http://www.techempower.com/benchmarks/#section=data-r7&hw=i7&test=json
21:31:54 <maxiepoo> so is this best Trie implementation: http://hackage.haskell.org/package/bytestring-trie
21:31:59 <monochrom> this is more obvious in Haskell because some types are like X->Y.
21:32:02 <L8D> JVM is in the top 10 besides one C++
21:32:11 <maxiepoo> I couldn't really find any others
21:32:30 <maxiepoo> I'm surprised there isn't a widely used one/1.0 one
21:32:31 <pharaun> jvm is kinda amazing in its own, the whole ability to hotspot and tweak stuff at runtime is powerful
21:32:42 <lispy> pharaun: to be fair, I'm not sure how you get access to the representation of Integer, but doing so could sometimes be useful. If for example you wanted to FFI with something that used GMP.
21:32:55 <monochrom> but it is just as true in Clojure, Java, Scala because you do write up some classes that act as X->Y or X -> IO Y (e.g., the Command pattern)
21:33:09 <erisco> L8D, why are libraries/frameworks listed beside languages?
21:33:35 <L8D> It's a comparison of the frameworks
21:33:40 <dalaing1> the C++ framework in that benchmark is... interesting...
21:33:54 <ChongLi> yeah, it says little about languages
21:33:56 <pharaun> lispy: that's what i was wondering :) but for my purposes most of my stuff is going to be home grown simd/arrays so i should be ok with cints
21:33:58 <L8D> The language is on the right side of the graph
21:34:17 <L8D> As well as a bunch of other information
21:34:35 <L8D> But holy crap
21:34:39 <L8D> openresty bro
21:34:43 <L8D> they have it going
21:34:44 <ChongLi> no, I mean it implies more about languages and community priorities than languages
21:34:51 <dalaing1> the c++ framework is developed here https://github.com/xaxaxa/workspace/
21:34:52 <ChongLi> and it seems like a microbenchmark
21:35:03 <ChongLi> which should always be taken with a grain of salt
21:35:05 <dalaing1> openresty is pretty cool
21:35:25 <L8D> ^
21:35:46 <L8D> They are all peak JSON responses per second
21:35:51 <L8D> the PEAK
21:35:54 <erisco> Hashable has to hash to an Int?
21:36:05 <erisco> I suppose that is reasonable
21:36:27 <pharaun> oh json, looking at this benchmark now
21:36:39 <benbangert> with the profiler, is there a way to scale the chart so I can see the top of the graph?
21:37:07 <erisco> > (maxBound :: Int) + 1
21:37:09 <lambdabot>  -9223372036854775808
21:37:11 <erisco> is that defined?
21:37:13 <lispy> benbangert: I like Iavor's HTML viewer. hp2html
21:37:29 <lispy> benbangert: it has an option to see the graph stacked or not which I think helps.
21:37:31 <benbangert> lispy: oh, is it cause I'm running hp2ps on it and its actually capping it?
21:37:43 <erisco> > (minBound :: Int) - 1
21:37:45 <lambdabot>  9223372036854775807
21:38:24 <monochrom> heh, lambdabot is 64-bit again :)
21:38:27 <lispy> benbangert: I'm not sure. Maybe it's just a really pathological case? You could share it with us here: http://heap.ezyang.com/
21:39:25 <benbangert> oh wow
21:39:31 <benbangert> thats way more useful. http://heap.ezyang.com/view/d4b6eb3a96db12ed43fc01ffa34c9f32ec327d14#form
21:40:46 <lispy> benbangert: Interesting. So I would recommend doing a type based profiling (is that -hy?) to see which data type is hogging all the memories
21:41:15 <lispy> benbangert: if I had to hazard a guess, I would thin that your parser is lazily holding on to part of the input
21:41:34 <benbangert> the top one there is from a deserialization of a file into a large tree structure
21:41:51 <benbangert> the tree structure has all its fields set to be strict
21:42:47 <benbangert> hmm, http://heap.ezyang.com/view/dd8bc904e98188ed720f27e1e172d8c93f1742a1#form with -hy
21:47:31 <lispy> benbangert: Yeah, I'm not sure what to say. Clearly the Tree is holding a lot of the data. Retainer profiling might help, but I suspect you already know what it would tell you because you know where the data is being accumulated and the type of the data.
21:47:47 <benbangert> yea, I got a retainer look too, http://heap.ezyang.com/view/f7a8a38bc05e77e2988986054a70c3b2834235af#form
21:48:10 <benbangert> this is the annotated code, http://paste.ofcode.org/nusnx5BWPLT5cFqrw2BtRN
21:48:35 <xpika> how can i get a file lastmodified in haskell?
21:50:03 <lispy> benbangert: oh fun. You're making a chat bot?
21:50:18 <benbangert> I'm porting megahal from C to haskell, yes :)
21:50:40 <erisco> hm is there a more proper hashmap than Data.HashMap? ie it is backed by IntMap and does not have ideal indexing perf
21:51:10 <benbangert> lispy: I already got it loaded a binary file generated by the C code and interacting properly, was just trying to cut memory usage a bit
21:51:27 <lispy> benbangert: Nice! I started doing that once when I was new to Haskell but put it down for various reasons.
21:52:03 <lispy> benbangert: this line is very lazy: return . Just $ Brain forward backward cookie order dictWords
21:52:23 <lispy> benbangert: even if Brain is a strict type, that "return . Just $" is going to create a thunk.
21:52:45 <lispy> return $! Just $! Brain ... might help
21:53:21 <lispy> benbangert: But I can't tell yet where the real problem is
21:53:33 <lispy> I would expect the print you have in there to evaluate things.
21:53:58 <benbangert> yea, everything gets eval'd, doing $! there like you suggested makes no difference
21:54:02 <erisco> I'd be looking for a hashmap that was backed by a vector (contiguous memory)
21:54:26 <L8D> Would you call something haskellian or haskellien?
21:54:33 <L8D> or haskellish?
21:55:07 <erisco> haskellite
21:55:19 <L8D> Well, I need an adjective
21:55:31 <startling> haskell
21:55:39 <L8D> Something that is close to and inspired by haskell
21:55:45 <lispy> benbangert: if you don't mind showing me more of your code, may I please see your Tree module?
21:55:53 <maxiepoo> I like Haskeletons
21:55:54 <L8D> So: "A Haskell LISP"?
21:56:08 <lispy> Haskellish
21:56:10 <erisco> haskell-like
21:56:10 <maxiepoo> for Haskell programmers
21:56:20 <lispy> Haskelly
21:56:21 <L8D> Okay
21:56:32 <erisco> is there not a standard hashmap backed by a vector or array?
21:56:35 <benbangert> lispy: the tree looks like this, http://paste.ofcode.org/8Xqsit7fSUWkL2eFTGZixK
21:57:34 <L8D> A LISP for Haskell programmers?
21:57:52 <L8D> A lazy LISP
21:58:06 <lispy> benbangert: stylistically, I don't tend to mix ADTs and records. The reason is that the field names become partial functions if you do that.
21:58:11 <L8D> Also, does anyone have a good resource for how to preform lazy evaluation?
21:58:16 <erisco> does this mean we need one?
21:58:17 <maxiepoo> there's a #lang lazy for Racket
21:58:17 <lispy> also, getChildren problem isn't strict the way you'd expect
21:58:28 <ChongLi> L8D: in lisp?
21:58:35 <erisco> is there possibly a hole needing to be filled?
21:58:38 <ChongLi> just write a delay macro
21:58:39 <benbangert> lispy: what do you mean?
21:58:49 <lispy> L8D: the book that SPJ wrote is great. It provides exercises (that you should do!) and builds it up bit by bit. Just a sec and I'll get a link.
21:58:53 <ChongLi> wraps the expression in a lambda of no args
21:58:54 <maxiepoo> L8D, http://docs.racket-lang.org/lazy/
21:58:56 <benbangert> lispy: about getchildren not being strict the way I expect?
21:59:06 <L8D> Well, okay
21:59:07 <L8D> thanks
21:59:08 <maxiepoo> but dynamically typed
21:59:10 <ChongLi> and then all you need is force
21:59:10 <lispy> L8D: http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
21:59:23 <L8D> I am writing the interpreter in JavaScript though
21:59:24 <ChongLi> Haskell-style laziness is much harder though
21:59:38 <ChongLi> since it pervades the entire language
21:59:45 <L8D> I really want haskell-style laziness
21:59:50 <lispy> benbangert: I could be mistaken, but !(Vector Tree) may not be strict. I guess it depends on whether or not Vector Tree is strict in the Tree.
21:59:53 <erisco> edwardk, do you know if there is a vector or array backed hashmap?
21:59:59 <ChongLi> you'll have to write lazy versions of every function you want
22:00:20 <ChongLi> erisco: wouldn't the performance of that suck?
22:00:23 <carter> erisco:  you're watning multi dim arrrays?
22:00:30 <erisco> carter, no
22:00:31 <L8D> Oh don't worry, I won't be using any native representations of data besides numbers
22:00:34 <erisco> ChongLi, why would it?
22:00:38 <lispy> L8D: if you follow that book and implement the chapters (it's really not that long) you'll have a toy lazy language and you'll have a deep understanding of how it works.
22:00:45 <ChongLi> you'd end up copying the entire thing every time you add something to it
22:00:53 <ChongLi> unless you want to make it mutable, I guess
22:00:57 <erisco> ChongLi, like arrays and vectors it would be read-only
22:01:03 <carter> whats readonly?
22:01:17 <carter> ohhh
22:01:29 <carter> erisco: hashmaps can be arrays of buckets
22:01:42 <ChongLi> erisco: if you want a nice hashmap, use unordered-containers
22:01:47 <erisco> carter, yes and is there a standard implementation of that?
22:01:50 <ChongLi> it's not a hash table though
22:01:55 <ChongLi> it's a HAMT
22:01:57 <carter> yeah
22:02:04 <lispy> L8D: the fact that you're writing it in JavaScript won't matter. In that book, he shows you how to implement an abstract machine that does the evaluation. You'd just implement that abstract machine in JS.
22:02:04 <carter> use unordered containers
22:02:23 <L8D> lispy: sweet then
22:02:37 <lispy> L8D: IMO, every Haskell programmer should read that book. It's a great way to deepen your understanding of laziness.
22:02:39 <erisco> carter, that is a package no?
22:02:44 <L8D> but I will still need to implement an FFI at some point
22:02:46 <ChongLi> carter: yeah
22:02:50 <erisco> what ADT/module specifically?
22:02:51 <ChongLi> http://hackage.haskell.org/package/unordered-containers-0.2.3.3
22:03:48 <erisco> yes but I have just looked at that module and only found tree-backed hashmaps
22:03:57 <erisco> it is backed by an IntMap
22:03:57 <lispy> benbangert: You might implement a DeepSeq instance for Tree and `rnf` your tree to see if it makes a difference
22:04:03 <carter> erisco: nope
22:04:05 <carter> you didn't read it then :)
22:04:11 <carter> they use a tree like thing
22:04:11 <erisco> carter, I did... where are you reading?
22:04:13 <lispy> benbangert: other than that, I'm currently out of ideas.
22:04:23 <ChongLi> they use an extremely wide trie
22:04:29 <benbangert> lispy: ah ok, thanks for the thoughts on it
22:04:30 <ChongLi> 16-ary at least
22:04:50 <carter> erisco: https://github.com/tibbe/unordered-containers/blob/master/Data/HashMap/Strict.hs#L92 :)
22:04:55 <carter> https://github.com/tibbe/unordered-containers/blob/master/Data/HashMap/Array.hs
22:05:04 <carter> hash array mapped trie
22:05:08 <carter> not some tree
22:05:10 <lispy> benbangert: Np. I've always wanted a megahal in Haskell so you can say I'm interested in your work :)
22:05:16 <carter> erisco: what work load do you want
22:05:26 <carter> unordered containers is LEGIT
22:05:45 <ChongLi> it's the same technology that Clojure uses
22:05:46 <benbangert> lispy: I've already improved it a lot, it had some weird C bugs before, I can get it to generate more consistently hilarious things now ;)
22:06:21 <ChongLi> it *is* a tree, though :)
22:06:21 <lispy> benbangert: nice!
22:06:25 <ChongLi> just not a binary tree
22:06:47 <ChongLi> http://lampwww.epfl.ch/papers/idealhashtrees.pdf
22:06:48 <carter> true
22:07:02 <carter> otoh, if you want arrays, you're hosed for insertion perf :)
22:07:02 <lispy> benbangert: I ended up making a wrapper (in Common Lisp) around the megahal binary and training it on #gentoo. It was the rudest bot I've ever met :)
22:07:16 <carter> megahal?
22:07:32 <lispy> carter: http://megahal.alioth.debian.org/
22:07:33 <erisco> carter, I was reading http://www.haskell.org/ghc/docs/6.12.1/html/libraries/containers-0.3.0.0/Data-IntMap.html and they state it is O(min(n,W)) where W is the Int width
22:07:37 <erisco> that is not optimal
22:07:46 <Pupnik> ChongLi: clojure uses 32
22:07:47 <carter> erisco: yes, we're not talking about containers
22:07:49 <ChongLi> erisco: that is unrelated
22:07:52 <carter> unorderd containers is a different lib
22:08:17 <ChongLi> Pupnik: yeah, I'm not sure why unordered-containers uses 16
22:08:18 <carter> though structures may work out to be a nice contender
22:08:23 <erisco> oh, Data.HashMap is from hashmap-1.1.0 so that is not the same/
22:08:23 <benbangert> lispy: they do have a tendancy to go downhil quickly... I wanted some nicer tools to work with it so I could load other corpuses of text in quickly and easily and change rules. ie, restrict the output set to < 140 chars so it could ensure output for twitter....
22:08:33 <erisco> ?
22:08:36 <carter> 'cause someone should benchmark both and tell tibbe if he's wrong
22:08:37 <ChongLi> erisco: that's not the same either
22:08:50 <ChongLi> unordered-containers-0.2.3.3 is what you want
22:08:54 <carter> whos on first , whats on second, 7's on 3rd
22:09:59 <ChongLi> I'm guessing 16-ary hashmaps may have better constant factors but weaker asymptotics
22:10:08 <carter> constant factors are kind
22:10:12 <carter> King
22:10:32 <erisco> oh, right, okay
22:10:34 <ChongLi> it also may be a completely different reality on the JVM
22:10:44 <erisco> so I saw that one too and it is O(log n) in base 16
22:11:09 <erisco> I don't see why that makes a vector backed hashmap irrelevent
22:11:30 <ChongLi> > logBase 16 (10^6)
22:11:31 <lambdabot>  4.9828921423310435
22:11:33 <ChongLi> > logBase 16 (10^9)
22:11:34 <lambdabot>  7.474338213496566
22:11:35 <lispy> benbangert: You've probably already seen this, but just in case: http://yes.thatcan.be/my/next/tweet/
22:11:36 <erisco> it is nice that it supports updating but if you don't need it then you don't need it
22:11:47 <carter> erisco: so use an array
22:11:50 <carter> or hashtable
22:11:51 <carter> :)
22:11:56 <erisco> well that was what I was asking
22:12:01 <ChongLi> see, the scaling is very good
22:12:01 <carter> theres hastable
22:12:01 <erisco> if an implementation already exists
22:12:07 <carter> @hackage hashtable
22:12:08 <lambdabot> http://hackage.haskell.org/package/hashtable
22:12:25 <carter> http://hackage.haskell.org/package/hashtables-1.0.1.8
22:13:00 <benbangert> lispy: lol, I think megahal is actually slightly more coherent :)
22:13:04 <ChongLi> ahhh, the ST monad
22:13:05 <ChongLi> very nice
22:13:18 <lispy> benbangert: yeah, megahal is some how really good at what it does.
22:13:20 <carter> st monad: a yummy such monad
22:13:37 <ChongLi> they very much miss that in Clojure
22:13:45 <ChongLi> they have transients
22:13:57 <ChongLi> but those are very limited
22:15:18 <ChongLi> reallyUnsafePtrEquality#
22:15:20 <carter> is there any good online megahal example?
22:15:24 <ChongLi> ahhh, that's a good one :)
22:15:31 <carter> ChongLi: yeah, tibbe does some clever stuff there
22:15:31 <erisco> carter, it looks to be mutable only?
22:15:37 <carter> ST != mutable
22:15:40 <carter> you can use it purely
22:16:02 <pharaun> how is go so fast/on top of that json list :\
22:16:03 <carter> :t runST
22:16:03 <lambdabot> (forall s. ST s a) -> a
22:16:15 <erisco> carter, that's fine but can you use it without ST?
22:16:18 <carter> yes
22:16:24 <carter> by using runST wrappers :)
22:16:31 <ChongLi> or use the IO version
22:16:33 <pharaun> tbh i would have thought wai/warp would have been higher in that list
22:16:43 <ChongLi> erisco: http://mitpress2.mit.edu/books/chapters/0262720221chapm1.pdf
22:16:46 <erisco> carter, well that isn't so convenient
22:16:47 <ChongLi> another great paper
22:16:56 <carter>  erisco  takess 5 minutes to write a pure wrapper
22:16:57 <erisco> carter, but one could write all the wrapping code I suppose
22:17:01 <carter> yeah
22:17:03 <carter> its easy
22:17:06 <ChongLi> erisco: what's so inconvenient about it?
22:17:19 <carter> that it takes 5 min
22:17:19 <ChongLi> it's beautiful, if you ask me
22:17:21 <lispy> ChongLi: John and Simon are both great authors!
22:17:27 <carter> ChongLi: its a nice api
22:17:36 <erisco> ChongLi, because if you do not need mutable then you have extra clutter to declutter
22:17:49 <carter> erisco: write ops that look pure
22:17:50 <carter> :)
22:17:52 <carter> its easy
22:17:53 <ChongLi> erisco: not sure what you mean by that
22:18:10 <narendraj9> Hello everyone! I want to learn Haskell. What book should I start with?
22:18:17 <ChongLi> narendraj9: LYAH
22:18:21 <carter> learn you a haskell
22:18:26 <ChongLi> http://learnyouahaskell.com/chapters
22:18:31 <carter> erisco: do you understadn what runST is?
22:18:36 <erisco> carter, yes
22:18:38 <ChongLi> :t runST
22:18:39 <lambdabot> (forall s. ST s a) -> a
22:18:43 <narendraj9> How much time would it take if I already know SML?
22:18:45 <lispy> narendraj9: how would you describe your background?
22:18:54 <ChongLi> narendraj9: not too long at all!
22:19:01 <carter> erisco: you could write a pure version of http://hackage.haskell.org/package/hashtables-1.0.1.8/docs/Data-HashTable-ST-Basic.html in like 5 minutes
22:19:08 <ChongLi> you should feel pretty comfortable
22:19:13 <lispy> narendraj9: if you already know SML then you would probably like something by Simon Thompson or Bird.
22:19:25 <erisco> carter, yes it would not be that difficult
22:19:29 <narendraj9> I have taken a course on programming languages that used SML.
22:19:32 <lispy> narendraj9: learn you a haskell would likely be a waste of your time.
22:19:35 <carter> trivlal eeven :)
22:19:37 <carter> true
22:19:50 <carter> night all :)
22:19:53 <ChongLi> night
22:19:59 <ChongLi> what about "a gentle introduction"?
22:20:07 <lispy> narendraj9: go to your library and find the craft of functional programming or google for the gentle introduction to haskell.
22:20:07 <ChongLi> http://www.haskell.org/tutorial/
22:20:25 <ChongLi> it's rather infamous for not being gentle to people who have no FP experience
22:20:47 <ChongLi> but it seems pretty readable from the perspective of already knowing Haskell :)
22:21:32 <narendraj9> I have some experience with FP. I know about some of the idioms. okay, so, a gentle introduction is the best choice for me?
22:21:42 <erisco> carter, good night
22:21:48 <ChongLi> narendraj9: I don't know if it's the best choice, but it's decent
22:21:50 <erisco> ChongLi, carter thanks for pointing out these libraries
22:21:54 <lispy> the gentle intro + plus a uni class was how I learned, but I was comming from a common lisp background. I found the gentle intro quite reasonable as a result.
22:22:00 <ChongLi> erisco: glad to help
22:22:34 <lispy> narendraj9: well, books by Thompson or Bird will give you really solid intro. The gentle intro will certainly get you going.
22:22:59 <narendraj9> thanks lispy :)
22:23:15 <narendraj9> thanks everyone :)
22:23:25 <ChongLi> be sure to stick around and ask questions
22:24:25 <narendraj9> surely will :)
22:29:19 <Pupnik> is ther much difference between haskell98 and 10
22:29:28 <lispy> Pupnik: no
22:29:35 <lispy> Pupnik: you can find release notes explaining it
22:29:56 <Pupnik> cheers
22:30:03 <lispy> Pupnik: http://www.haskell.org/haskellwiki/Haskell_2010
22:30:34 <lispy> the biggest thing was the removal of n+k patterns. Pretty much everything else was already an extension.
22:33:16 <stevejb> div n 3
22:33:35 <lispy> > 5 `div` 3
22:33:36 <lambdabot>  1
22:33:55 <dmwit> > div n 3
22:33:56 <lambdabot>  n `div` 3
22:34:00 <dmwit> =)
22:34:10 <stevejb> :) oops wrong buffer
22:34:12 <lispy> Expr?
22:34:18 <dmwit> Expr.
22:34:20 <lispy> :t n `div` 3
22:34:20 <lambdabot> Expr
22:34:25 <lispy> Expr!
22:34:53 <dmwit> Also, "Haskell 2010 is pretty much Haskell 98 because everything was already an extension" seems like a weird answer.
22:35:07 <dmwit> If you need a lot  of expressions, surely it's not pretty much the same.
22:35:09 <dmwit> uh
22:35:14 <dmwit> s/expressions/extensions/
22:35:16 * hackagebot purescript 0.2.3 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.3 (PhilFreeman)
22:35:32 <lispy> dmwit: hm...do you think it was a big change?
22:35:38 <dmwit> no =)
22:35:47 <lispy> Perhaps my justification is flawwed
22:35:51 <dmwit> I just like arguing. =P
22:37:30 <lispy> The thing that is hard to explain to newcommers is that "hey we had this thing called Haskell' and its role was to figure out what extensions to standardize on and it did that. Then we called it Haskell2010."
22:37:50 <lispy> and "Oh, it had to do it pretty conservatively because reasons."
22:38:22 <ChongLi> very good reasons
22:38:33 <ChongLi> you can get a lot of strange stuff if you mix and match too many extensions
22:38:50 <DigitalKiwi> i think they call that scala
22:38:58 <ChongLi> hahaha
22:39:02 <lispy> heh
22:39:42 <frege> is there a python god here?
22:39:47 <frege> I'm banned from python channel
22:39:56 <lispy> frege: unlikely :(
22:39:58 <DigitalKiwi> did you lol
22:40:01 <frege> and I'm trying to sample from an iterator
22:40:20 <randomclown> frege: itertools?
22:40:22 <frege> without consuming its values so I should probably merge a slice back
22:40:28 <frege> doesn't have that functions :(
22:40:44 * lispy wonders if this frege was spewing the hate speech that the real Frega was known for...could be a reason to ban :)
22:41:10 <frege> lispy: I'm not a Nazi
22:41:16 <lispy> That's good!
22:41:38 <ChongLi> Gottlob Frege was a nazi?
22:41:40 <frege> lispy: I used the word fuck a few times to show my frustration with twisted I think and someone was offended
22:41:41 <ChongLi> he died in 1925
22:41:56 <DigitalKiwi> the real question is are you legit banned or are you just not identified to services so think you're banned?
22:41:59 <lispy> ChongLi: anti-semmetic at any rate
22:42:00 <frege> ChongLi: apparently he talked about jews..
22:42:03 <DigitalKiwi> oh
22:42:04 <ChongLi> ahh
22:42:30 <frege> I'm not going back evven if they invite me
22:42:41 <ChongLi> oh well, his contributions are still impressive
22:42:46 <lispy> ChongLi: it's a shame because as an analytic philosopher he did great things for mathematics
22:42:57 <frege> I'm an old user of that channel and if a channel is sensitive to the word 'fuck' then I don't feel like staying there anyway
22:43:15 <frege> ChongLi: like my contributions to #python
22:43:32 <ChongLi> ahh, we're not as sensitive
22:43:36 <frege> lispy: what's a shame?
22:43:47 <ChongLi> people only get banned here for deliberate, repeated trolling
22:44:08 <lispy> frege: I dare say, it's offtopic here, but what is a shame is the real Frege's hateful ramblings. His mathematical work was great.
22:44:16 <frege> I know most of channels in irc aren't sensitive since words don't harm anyone
22:44:41 <ChongLi> ahh, that's not quite true
22:44:47 <ChongLi> words can cause a great deal of harm
22:44:52 <frege> lispy: I haven't actually heard/read his hateful ramblings, I have been exposed only on his work in philosophy and foundation of mathematics
22:45:01 <DigitalKiwi> justine sacco :<
22:45:09 <frege> ChongLi: 'fuck twisted' doesn't harm anyone
22:45:13 <ChongLi> slander and libel, for example
22:45:13 <simpson> frege: So, #python-ops is the place to discuss being banned from #python.
22:45:26 <frege> simpson: yeah the guy kicked me out of there too
22:45:38 <simpson> frege: Also you may want to tone down the language before trying to get your ban removed.
22:45:48 <ChongLi> oh well, look at this as an opportunity
22:45:52 <ChongLi> why not learn Haskell?
22:45:55 <frege> I did and I ssaid I will watch my language
22:46:00 <NemesisD> hey guys. was looking for some advice on writing my first ffi lib
22:46:02 <frege> I'm learning haskell too
22:46:26 <frege> so guys does anyone know what's a good way to sample from a generator
22:46:27 <frege> ?
22:46:30 <ChongLi> that's good
22:46:33 <NemesisD> i want to write bindings to the PHash C api. it obviously isn't in the standard library, it is just a header and c file for the most part
22:46:39 <frege> I guess it's a haskell thing too; since we have lazy evaluation
22:46:49 <lispy> NemesisD: c2hs is fancy and sometimes suffers becaus of it. hsc2hs is more down to earth and works more reliably but sometimes requires more boiler plate.
22:46:53 <frege> I wanna sample copy some data from a stream
22:47:05 <NemesisD> what's the pattern most people follow in this case? do they distribute the header and c file with the haskell code?
22:47:30 <NemesisD> i have not heard of either of those. are they alternatives to FFI
22:47:44 <ChongLi> NemesisD: no, just boilerplate generators
22:47:57 <lispy> NemesisD: well...I highly value being able to type, 'cabal install foo' and having it just work. So I include the C sources to make that happen. Not everyone would agree with me that this is a good idea. Some folks like to reuse their distro libraries.
22:48:26 <NemesisD> this is definitely not a library people will have installed frequently
22:48:42 <ChongLi> lispy: yeah, windows users of Haskell have a very bad time in that regard
22:48:59 <lispy> then if it has the same license as your Haskell code and is not too big or difficult to build then just bundle it
22:49:07 <NemesisD> and actually its api kind of sucks. the gist is that it generates a hash for audio, video and image files. the only apis i can see being exposed in any other ffi libs in onther languages are ones where you pass it a filename
22:49:26 <binroot> what's the shortest piece of code equivalent to (init.tail.tail)?
22:49:32 <ChongLi> NemesisD: how big is it?
22:49:36 <Kaidelong> including the sources is not the best thing for windows users either
22:49:36 <ChongLi> just one h and one c file?
22:49:41 <NemesisD> lispy: is there a good example FFI binding in haskell that includes c sources? i want to paint by numbers a bit with the cabal config
22:50:04 <NemesisD> im a bit worried that most of the resources i'm finding about ffi are at least a few years old
22:50:07 <lispy> NemesisD: I have an example, but it's probably not good :) Just a sec
22:50:20 <ChongLi> NemesisD: you've read this then?
22:50:22 <ChongLi> http://www.haskell.org/haskellwiki/FFI_Introduction
22:50:39 <NemesisD> ChongLi: the library? pretty small, its got like 2 or 3 functions i'm going to bind to
22:50:49 <NemesisD> ChongLi: on that right now
22:50:49 <roboguy_> binroot: that's already pretty short
22:50:49 <lispy> NemesisD: https://github.com/dagit/freetype2/blob/cabalization/freetype2.cabal
22:51:02 <Kaidelong> tail . tail is the same thing as drop 2
22:51:07 <Kaidelong> you could shorten it by that much
22:51:09 <lispy> NemesisD: I added a bunch of Haskell modules to the freetype2 sources so that it could serve as a Haskell library
22:51:21 <ChongLi> NemesisD: is the PHash part of some standard protocol?
22:51:39 <ChongLi> how easy would it be to re-implement in Haskell?
22:51:49 <frege> guys how do you take sample of a generator in haskell?
22:51:55 <NemesisD> ChongLi: way out of my pay grade to reimplement it
22:52:04 <startling> frege: what does that mean?
22:52:05 <ChongLi> NemesisD: ahh, okay
22:52:08 <NemesisD> its doing computer vision stuff
22:52:16 <NemesisD> and the audio/video equivalent i assume
22:52:24 <frege> startling: I'm coming from python; but the concept must be the same
22:52:26 <NemesisD> though im focusing on images first
22:52:47 <startling> frege: well, Haskell doesn't really have generators in the standard library
22:52:49 <frege> startling: you have one iterator with lazy evaluation; you wanna copy 10 elements from it and return the iterator
22:52:50 <ChongLi> have you looked at stuff like HOpenCV?
22:53:07 <ChongLi> or easyVision
22:53:10 <NemesisD> phash lets yo utake a fingerprint of a media file and then easily compare similar images by doing a simple hamming distance on the hash
22:53:21 <ChongLi> I'm not up on computer vision
22:53:28 <dmwit> frege: sample xs = (take 10 xs, xs)
22:53:28 <ChongLi> so I don't know what the state of the art is
22:53:36 <startling> > let myList = [1,2..] = (take 10 myList, drop 10 myList)
22:53:37 <lambdabot>  <hint>:1:22: parse error on input `='
22:53:45 <dmwit> frege: But this approach won't translate to Python, and trying to get it to is off-topic here.
22:53:46 <startling> > let myList = [1,2..] in (take 10 myList, drop 10 myList)
22:53:47 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
22:53:53 <dmwit> It's not our fault you can't follow #python's rules.
22:54:02 <NemesisD> the api it exposes is something like FilePath -> IO Integer
22:54:14 <NemesisD> or whatever the equivalent of ulong64 is
22:54:15 <dmwit> And please watch your language in here, too. This is meant to be a family-friendly channel.
22:54:35 <ChongLi> Integer is bignum
22:55:10 <ChongLi> you probably want Word64
22:55:49 <ChongLi> > [minBound,maxBound] :: [Word64]
22:55:50 <lambdabot>  [0,18446744073709551615]
22:57:32 <NemesisD> yeah so my highlevel api is going to be like newtype PHash = PHash Word64; imagePHash :: FilePath -> IO PHash; hammingDistance :: PHash -> PHash -> Int
22:57:47 <binroot> binroot
22:58:08 <ChongLi> NemesisD: FilePath?
22:58:24 <ChongLi> you don't want to handle in-memory images?
22:59:06 <ChongLi> lots of the image libraries use Storables
22:59:30 <NemesisD> ChongLi: i'd love to but their api doesn't support it
22:59:44 <dmwit> Fix their API!
22:59:47 <NemesisD> ChongLi: int ph_dct_imagehash(const char *file, ulong64 &hash);
22:59:50 <dmwit> The submit a pull request. =)
23:00:06 <NemesisD> just what i want to be doing on my weekend, writing C code :P
23:00:13 <ChongLi> NemesisD: ahh, that's no fun :(
23:00:36 <ChongLi> I wonder if you could just put the file on a posix FIFO
23:01:29 <dmwit> Anyway, I thkn lispy's suggestions were good. If it's small, you can also consider writing FFI code by hand.
23:01:35 <dmwit> It's surprisingly tractable.
23:02:41 <frege> dmwit: okay
23:03:00 <ChongLi> would mkFileHandle be useful in this regard?
23:03:13 <NemesisD> hmm i think phash might be using cimg
23:04:11 <ChongLi> just write the image to the file handle and pass the FilePath to the PHash API
23:04:17 <NemesisD> gah i always do this. better to get something limited working than burn out trying to devise a fancier api
23:05:37 <dmwit> NemesisD: Definitely. My suggestion to fix their API was very tongue-in-cheek.
23:06:38 <maxiepoo> @pl \x -> f x <$> y
23:06:38 <lambdabot> (<$> y) . f
23:10:16 <NemesisD> oh man it has been so long since i did C
23:11:02 <SrPx> Can I get GHC 7.8?
23:11:45 <NemesisD> int ph_dct_imagehash(const char *file, ulong64 &hash), so in haskell i'm going to have to allocate a ulong64 in haskell land and somehow pass a reference to it?
23:12:24 <NemesisD> and then int return type to indicate success/failure because lolC
23:14:00 <ChongLi> :t Foreign.Marshal.Utils.with
23:14:01 <lambdabot> Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
23:14:30 <NemesisD> oh wait a second this is C++ isn't it...
23:14:43 <ChongLi> ahh, now things get *really* interesting
23:15:08 <NemesisD> *jumps out of window*
23:15:29 <ChongLi> you have to create a C header
23:16:01 <popl> "interesting"?
23:16:06 <popl> In the Chinese sense of the word?
23:16:08 <popl> :)
23:16:10 <ChongLi> yeah :)
23:16:12 <NemesisD> prepare yourself for tons of dumb questions
23:16:37 <popl> ##C++-basic exists
23:16:48 <NemesisD> https://github.com/sdepold/pHash/tree/master/src
23:17:01 <popl> NemesisD: What are you doing?
23:17:05 <NemesisD> so there are header files there, the one i need to get at is in pHash.h
23:17:07 <popl> oh
23:17:10 <popl> nevermind, I see
23:17:17 <ChongLi> popl: writing Haskell bindings to pHash
23:17:22 <NemesisD> popl: trying to write my first ffi binding
23:17:29 <popl> neat!
23:17:31 <popl> good luck
23:18:33 <NemesisD> ChongLi: so that header, will that work?
23:19:26 <ChongLi> NemesisD: I'm not sure, but it looks right
23:19:39 <ChongLi> it has the usual
23:19:42 <ChongLi> #ifdef __cplusplus
23:19:42 <ChongLi> extern "C" {
23:19:43 <ChongLi> #endif
23:19:46 <ChongLi> sorts of things
23:21:21 <NemesisD> so now the trick will be pass-by-reference
23:22:08 <ChongLi> NemesisD: doesn't Foreign.Marshal.Utils.with fit the bill?
23:22:48 <ChongLi> hmm, I guess that's not ideal
23:23:40 <ChongLi> ahh
23:24:01 <ChongLi> :t Foreign.C.String.withCString
23:24:02 <lambdabot> String -> (Foreign.C.String.CString -> IO a) -> IO a
23:25:18 <NemesisD> hmm in this case its a ulong64 or i guess CULong
23:25:41 <NemesisD> is there a way i could allocate one of those in haskell and pass a ref to the ffi call?
23:26:11 <NemesisD> does C even have pass by reference. real talk i haven't done C since college
23:27:04 <popl> NemesisD: yes
23:27:23 <popl> foo( &bar ); // bar is passed by reference
23:27:36 <roboguy_> well, it doesn't have pass by reference in the way C++ does, but it does have pointers
23:27:47 <roboguy_> which is close enough
23:27:47 <popl> oh wait, C++
23:27:54 <popl> I am thinking in C++
23:27:59 <popl> sorry
23:28:22 <ChongLi> no, &bar is pass by reference in C too
23:28:36 <popl> is it? I don't know anymore
23:28:51 <popl> I'd forget my name. :P
23:28:57 <NemesisD> my professors would be so disappoint
23:29:23 <popl> Would they?
23:29:49 <popl> Many CS professors I know expect their students to forget things, I think.
23:30:07 <ChongLi> you should try writing a generics library in C
23:30:10 <popl> ChongLi: OH THAT'S RIGHT
23:30:20 <popl> ChongLi: C passes by reference by creating a pointer
23:31:13 <NemesisD> so i found this http://stackoverflow.com/questions/10900354/haskell-ffi-can-you-obtain-a-c-pointer-from-a-haskell-data-structure
23:31:25 <NemesisD> which suggests that i could use mallocForeignPtr
23:32:08 <ChongLi> NemesisD: the with constructs do that for you
23:32:21 <NemesisD> still looking how i could dereference that foreignptr to get the creamy nugat inside
23:32:35 <NemesisD> ChongLi: is there a with for ulongs?
23:32:43 <ChongLi> with is polymorphic
23:32:44 <popl> ChongLi: Thanks for jogging my memory
23:32:51 <ChongLi> anything that implements an instance for Storable
23:32:54 <ChongLi> will work
23:33:27 <NemesisD> what module can i find with in?
23:33:28 <ChongLi> http://hackage.haskell.org/package/base-4.6.0.1/docs/Foreign-Storable.html#t:Storable
23:33:33 <ChongLi> oh
23:33:40 <ChongLi> Foreign.Marshal.Utils
23:33:50 <ChongLi> :t Foreign.Marshal.Utils.with
23:33:51 <lambdabot> Foreign.Storable.Storable a => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
23:34:40 <frx> in C, foo(&x) is passing a pointer (reference) to x by value. slightly different than passing by reference.
23:34:59 <popl> frx: yes, that's right
23:35:03 <NemesisD> ChongLi: ah ok. but in c-land wouldn't that ptr look like a ulong64* foo rather than ulong64 &foo?
23:35:23 * hackagebot webkitgtk3 0.12.5.2 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkitgtk3-0.12.5.2 (HamishMackenzie)
23:35:55 <NemesisD> frx: weird. id' expect to see a * in there somwhere if it was a ptr
23:36:19 <Fuuzetsu> Are all identity morphisms of a category automatically endomorphisms?
23:36:51 <ChongLi> NemesisD: * and & are just operators
23:37:02 <ChongLi> * is deref, & is ref
23:37:20 <roboguy_> NemesisD: yeah, stuff like ulong64 &foo doesn't exist in C, just C++
23:37:32 <NemesisD> so am i hosed then?
23:38:02 <ChongLi> roboguy_: this is a C header file
23:38:43 <NemesisD> the code is C++ though. the code i'm trying to call is: int ph_dct_imagehash(const char* file,ulong64 &hash);
23:38:48 <ChongLi> typedef unsigned long long ulong64;
23:38:49 <ChongLi> typedef signed long long long64;
23:38:53 <ChongLi> right there in the file
23:40:24 * hackagebot webkit 0.12.5.2 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.5.2 (HamishMackenzie)
23:40:40 <roboguy_> ChongLi: the ulong64 part isn't the problem. the problem is that C doesn't have C++ style references (like ulong64 &foo)
23:40:55 <roboguy_> NemesisD: I would imagine that the second argument would map to a GHC.Ptr.Ptr also, but I'm not sure
23:41:06 <roboguy_> I haven't used the Haskell FFI yet
23:41:21 <ChongLi> roboguy_: I'm not sure I follow
23:41:46 <roboguy_> ChongLi: I'm just saying that something like this is valid C++, but not valid C: void function(int& a);
23:41:59 <roboguy_> the rough C equivalent would be void function(int* a);
23:42:08 <ChongLi> ahhh
23:43:09 <ChongLi> roboguy_: not all the functions in the API are like that
23:43:17 <ChongLi> a lot of them just take pointers
23:43:20 <NemesisD> just the one i care about :(
23:43:31 <roboguy_> NemesisD: I think the & reference thing is just basically syntactic sugar though, so it will probably be okay
23:43:56 <roboguy_> I'm pretty sure both kinds of references end up converted to the same kind of thing
23:44:18 <ChongLi> what is the difference anyway? one on the heap and the other on the stack?
23:44:27 <zRecursive> no
23:44:52 <NemesisD> roboguy_: so it seems like the haskell equiv is something like int ph_dct_imagehash(const char *file, ulong64 &hash) becomes c_dct_imagehash :: CString -> Ptr CUInt -> IO CInt
23:44:55 <roboguy_> ChongLi: no difference other than the fact that a C++ reference can't be null and you pass it implicitly (like foo(a) instead of foo(&a))
23:45:17 <ChongLi> roboguy_: ahh
23:45:28 <roboguy_> NemesisD: that's what I would guess, but like I said I've haven't used the haskell FFI
23:45:32 <roboguy_> (yet)
23:45:48 <ChongLi> roboguy_: is it a type error then to do something like this?:
23:45:52 <NemesisD> anticipating some neat segfaults pretty soon here
23:45:55 <ChongLi> int x = 2354;
23:45:59 <ChongLi> foo(&x);
23:46:22 <ChongLi> assuming foo is: void foo(int &x);
23:46:33 <zRecursive> In C++ you can use "." to use struct members. In C you need to use "->" ...
23:47:26 <roboguy_> ChongLi: no, that's just how it works. int& x = 2354; is an error
23:47:31 <popl> The semantics of & in C are defined in §6.5.3.2 of ISO/IEC9899:201x.
23:47:46 <zRecursive> ChongLi: it depends where is the x's address ?
23:47:57 <ChongLi> int x = 2354;
23:48:02 <roboguy_> zRecursive: that's not totally true. -> is for a pointer in both C and C++ and . is for both. "." is also for a reference in C++
23:48:02 <ChongLi> wouldn't that put x on the stack?
23:48:19 <roboguy_> ChongLi: yeah
23:48:29 <NemesisD> welp i guess my high level return type is gonna have to be a Maybe. the docs for the code says 1 is success, -1 failure. gotta love that
23:48:32 <zRecursive> roboguy_: you cannot use "." in C, right ?
23:48:36 <roboguy_> ChongLi: oh wait, I misread, yeah foo(&x) is wrong
23:48:41 <roboguy_> zRecursive: you have to
23:48:47 <roboguy_> unless it's a pointer
23:48:54 <roboguy_> in which case, you have to use ->
23:48:59 <ChongLi> roboguy_: so pointers and references are distinct types
23:49:06 <ChongLi> and C doesn't have references
23:49:27 <roboguy_> ChongLi: more or less. I think they have the same IR though
23:49:39 <Ralith> zRecursive: what are you smoking?
23:49:42 <ChongLi> but the APIs are completely incompatible?
23:49:50 <zRecursive> Both are address
23:49:50 <ChongLi> who thought that was a good idea?
23:50:40 <ChongLi> NemesisD: yeah, maybe is fine
23:51:00 <ChongLi> NemesisD: does the API use some global buffer for error messages or do they just not care?
23:51:42 <NemesisD> not sure
23:51:55 <ChongLi> looks like the answer is no
23:52:04 <ChongLi> so at least you don't have to deal with that sort of nonsense :)
23:52:10 <NemesisD> hehe
23:52:17 <NemesisD> how do i get a value out of a ptr then using with?
23:52:31 <ChongLi> when using with?
23:53:24 <NemesisD> with :: Storable a => a -> (Ptr a -> IO b) -> IO b. it gives me the ptr that i can pass into ffi, but i need to dereference that ptr back in haskell after the ffi call
23:54:04 <NemesisD> oh, duh. peek
23:54:26 <ChongLi> there's also maybePeek
23:55:21 <NemesisD> shouldn't that be unnecessary? because i'm using with, it forces me to allocate it with a value
23:55:32 <ChongLi> yeah, you're right
