00:00:07 <Cale> I've found several occasions to use it
00:00:13 <Iceland_jack> If you do something like
00:00:13 <Iceland_jack>     if pred then [x] else []
00:00:19 <roboguy_> Iceland_jack: really? I guess I've never had something like that
00:00:25 <roboguy_> I use hlint pretty often
00:00:33 <Iceland_jack> You haven't worked with horrible code a lot then :)
00:00:52 <roboguy_> Iceland_jack: haha, well I like to think I don't anyway
00:00:57 <Cale> Of course, you might also have written something like  map fst . filter snd $ ...
00:01:09 <Cale> and I don't think hlint will complain about that
00:01:13 <Iceland_jack> Not that I'm a huge fan of [ x | y ] especially since it's uncommon
00:01:14 <Cale> (it's also not too bad)
00:01:50 <Cale> nstdloop: ^^ you should also be aware of map fst . filter snd ;)
00:01:59 <Iceland_jack> baldur-lappi% hlint =(echo 'main = print (if True then ['5'] else [])')
00:01:59 <Iceland_jack> /tmp/zshvZFL5o:1:15: Warning: Use list comprehension
00:02:09 <Iceland_jack> With
00:02:09 <Iceland_jack> Found:
00:02:09 <Iceland_jack>   if True then [5] else []
00:02:09 <Iceland_jack> Why not:
00:02:12 <Iceland_jack>   [5 | True]
00:02:24 <Cale> Or a comprehension like  [x | (x,c) <- [... list of pairs of elements and conditions...], c]
00:02:33 <nstdloop> Cale: clever
00:02:55 <nstdloop> I think the list is short enough that [x | y] ++ ... is not going to be too confusing
00:03:05 <nstdloop> It's about 3 elements
00:03:05 <Cale> yeah, I rather like that way
00:03:10 <Iceland_jack> Then something like
00:03:10 <Iceland_jack>     mape fst (filter snd list)
00:03:11 <Iceland_jack> would be better
00:03:17 <Iceland_jack> *map
00:03:37 <Fuuzetsu> are there tools that will read the profiling output and present it in a manner nicer than tens of thousands of lines of text?
00:04:35 <roboguy_> Fuuzetsu: ghc has a graph output
00:05:02 <Cale> Fuuzetsu: wow, such profile, much text, very informations [[cost centre stack intensifies]]
00:05:24 <Cale> If you find a really good solution, let me know
00:05:36 <Fuuzetsu> such Cale, wow
00:05:50 <Fuuzetsu> roboguy_: do you mean hp2hs
00:05:51 <Cale> I've found it often happens that the new cost centre stacks make the output impossible to deal with
00:06:18 <roboguy_> Fuuzetsu: I think so. it's been a while since I've used it
00:06:29 <Cale> -rw-r--r-- 1 cale cale 40788019 Mar  7  2012 gameBenchmark.prof
00:06:42 <Cale> ^^ how does that compare with your profile? ;)
00:07:50 <Cale> Really, it's very much less than ideal that the profiling information is dumped out into a text file with truncated information
00:08:15 <Cale> It would be much cooler if you ended up with something that you could load and manipulate using a Haskell library
00:11:52 <nstdloop> does there exist a standard 3-way Either?
00:12:09 <Cale> no
00:12:20 <nstdloop> Am I probably doing something wrong if I need one?
00:12:27 <dv-> Maybe (Either a b) ?
00:12:28 <Cale> Just define your own type :)
00:12:33 <Iceland_jack> nstdloop: You possibly want to define a new type
00:12:38 <scott_> dv-: That's not quite it
00:12:44 <scott_> Either a (Either b c)
00:12:46 <Iceland_jack> Either a (Either b c)
00:12:56 * hackagebot parsec 3.1.5 - Monadic parser combinators  http://hackage.haskell.org/package/parsec-3.1.5 (AntoineLatter)
00:12:56 * hackagebot pipes-attoparsec 0.3.1 - Attoparsec and Pipes integration.  http://hackage.haskell.org/package/pipes-attoparsec-0.3.1 (RenzoCarbonara)
00:13:26 <qrada> that moment where you realize you can use fold/map for so much more
00:13:29 <qrada> okdsfsdgijsd
00:14:20 <Iceland_jack>     foo ∷ Int + String + Bool → String
00:14:21 <Iceland_jack>     foo e = case e of
00:14:21 <Iceland_jack>       inj₁ a → show (a*a)
00:14:21 <Iceland_jack>       inj₂ b → show b
00:14:23 <Iceland_jack>       inj₃ c → c
00:14:32 <Iceland_jack> in a perfect world anyway
00:15:48 <randomclown> is the order of forkIO deterministic
00:16:01 <randomclown> forkIO thread1; forkIO thread2
00:16:01 <Iceland_jack> randomclown: Order of what?
00:16:13 <randomclown> can I guarentee that thread1 will be already running
00:16:33 <shachaf> Guarantee for what?
00:16:48 <randomclown> when the forkIO call to the 2nd thread is executed
00:16:56 <Iceland_jack> randomclown: forkIO returns the threadID
00:17:08 <Iceland_jack> so the thread will have been created
00:17:12 <shachaf> To do what?
00:17:31 <Iceland_jack> but if that matters to you then you may be doing something wrong
00:17:51 <randomclown> forkIO $ putStrLn "hello"; forkIO $ putStrLn "world"
00:18:08 <randomclown> I should always get hellow world as output
00:18:13 <Iceland_jack> You can always use MVar's to synchronize
00:18:19 <Iceland_jack> randomclown: no it doesn't work like that
00:18:47 <Iceland_jack> thread₂ doesn't wait until thread₁ runs to completion, that would defeat the point
00:18:56 <Fuuzetsu> isn't my heap pretty http://fuuzetsu.co.uk/images/1389427975.png ?~~
00:18:56 <shachaf> Oh. No, certainly not.
00:19:27 <randomclown> Alright bad example
00:19:35 <Iceland_jack> Fuuzetsu: Looks like a crocodile with its mouth open
00:19:38 <nstdloop> scott_, Iceland_jack: I did in fact want Either a (Either b c)
00:19:48 <Fuuzetsu> Iceland_jack: that's what it feels like too
00:19:51 <randomclown> what I meant was that the 1st thread should be already created by the time we get to the 2nd forkIO call
00:19:52 <Iceland_jack> hah
00:20:20 <Iceland_jack> randomclown: What do you need that guarantee for?
00:20:46 <shachaf> I still don't understand. What difference does it make for you? What is "created"?
00:20:56 <randomclown> alright when I call pthread_create
00:21:03 <randomclown> the code, whatever it is, is running
00:21:21 <randomclown> when I make a 2nd call to pthread_create
00:21:39 <randomclown> I can always guarentee that the 1st thread is already running
00:21:53 <shachaf> What does that guarantee give you?
00:21:58 <Cale> randomclown: You can't guarantee that the first thread has accomplished any work yet though
00:21:59 <randomclown> so if I had something like kill_thread_1 in my 2nd thread, then it should always work
00:22:09 <shachaf> OK, you want to kill the thread.
00:22:09 <randomclown> I didn't say thing about work
00:22:10 <Cale> sure
00:22:17 <Iceland_jack> randomclown: What Cale said, you may know that it's started but that doesn't tell you much
00:22:31 <shachaf> In that case, you'll get a ThreadId from the first forkIO call, so the second one can probably use it.
00:23:06 <Cale> You can write  do k <- forkIO (forever (putStrLn "hi")); forkIO (killThread k); forever (putStrLn "bye")
00:24:12 <Cale> Note, this does not guarantee that you don't ever see "bye" followed by "hi"
00:24:33 <Cale> because the killThread is something which happens in a new thread which may or may not get a chance to run
00:24:48 <Cale> (before an additional "bye" is printed)
00:25:07 <Cale> In practice, you'd never expect to see too many though :)
00:26:10 <randomclown> Is there a way to get the amount in BoundedChan queue?
00:27:03 <randomclown> Looks like only BTChan has it
00:27:23 <c_wraith> It's deadlock-prone in the other one
00:27:39 <c_wraith> STM prevents that kind of deadlock
00:28:12 <randomclown> c_wraith: I keep saying STM is super slow if the resource is highly contended
00:28:26 <randomclown> I keep hearing people say*
00:28:31 <c_wraith> it is.  It uses optimistic locking.
00:30:12 <c_wraith> if the optimism is unwarranted, that can have bad outcomes.
00:31:11 <Cale> But in exchange for having to worry about that, there are 99 problems you don't have to worry about any more.
00:31:47 <randomclown> performance is the biggest problem
00:32:04 <Cale> Correctness is more important, I'd say
00:32:17 <randomclown> performance is harder than correctness
00:32:18 <Cale> Doing the wrong thing quickly is not better than doing the right thing slowly.
00:33:51 <Cale> The performance of STM could definitely be improved, but it's not terrible.
00:34:02 <Cale> and it makes correct code far easier to write
00:35:35 <c_wraith> queues with a hard upper bound aren't good for performance anyway.
00:35:53 <c_wraith> The hard upper bound implies serializing access to it.
00:36:03 <Cale> Well, they can be important to memory performance
00:36:19 <c_wraith> right - they're not good for massively concurrent performance
00:37:57 <c_wraith> You could do some basic handy things, though, taking lessons from the MIO enhancements to the new IO manager.
00:38:12 <c_wraith> (since it was a serial bottleneck in IO concurrency)
00:38:26 <c_wraith> simple striping does a lot, for instance.
00:39:57 <c_wraith> Though you need a more relaxed set of requirements to stripe a queue..  you can no longer require strict FIFO semantics
00:42:13 <mm_freak> randomclown: STM performs very well, if your transactions are reasonably small
00:42:45 <c_wraith> mm_freak: and if your transactions don't usually contend with each other.
00:42:47 <mm_freak> i don't see a noticable slowdown compared to more traditional primitives
00:43:06 <mm_freak> c_wraith: that works surprisingly well
00:43:10 <mm_freak> at least for me
00:43:18 <c_wraith> mm_freak: the problem is if you have 50 threads doing something with the same TVar simultaneously
00:43:31 <c_wraith> 1 commits, 49 roll back and start over
00:44:03 <c_wraith> that's quite a multiplier on total work done
00:45:16 <mm_freak> c_wraith: as far as i know rollbacks can occur in the middle of the transaction, and STM is even implemented in a way such that rollbacks can practically occur everywhere…  that's why unsafeIOToSTM is such a bad idea
00:45:17 <c_wraith> as long as it can keep the actual contention for the same TVars low, STM works great.  If it starts climbing, though, it gets out of hand rapidly.
00:45:25 <Fuuzetsu> is there a way to heap profile more than one thing at a time? Say, I want to profile by data type (-hy) as well as doing the regular profiling (-h). There doesn't seem to be a way to tell these to go into separate files or anything
00:45:36 <mm_freak> c_wraith: so contention isn't like 50 transactions run through to the end and then restart
00:46:00 <mm_freak> c_wraith: for small transactions it's also unlikely that more threads will actually roll back than you have OS threads available
00:46:19 <jtcwang> I'm looking for some guidance on approaching a problem the haskell way
00:46:35 <jtcwang> i currently have IO setup so it reads a keyboard char
00:46:58 <jtcwang> i also have a 'state machine' which does something when a char is given to it (from keyboard)
00:47:01 <c_wraith> I've seen transactions consisting only of updating a table in a single TVar with a pure function fail in the way I'm describing.
00:47:15 <jtcwang> i'm not too sure how i would approach it. any tips?
00:48:00 <c_wraith> This isn't theoretical - for a while, it holds up fine.  Then something trips it, and there's an explosion of transactions piling up, each using more cpu, each slowing down processing, getting further and further backlogged
00:48:00 <Iceland_jack> jtcwang: Do you want something like this?
00:48:00 <Iceland_jack>     f = do
00:48:00 <Iceland_jack>       ch ← getChar
00:48:00 <Iceland_jack>       stateMachine ch
00:48:03 <Iceland_jack>       …
00:48:07 <Iceland_jack>  
00:48:10 <jtcwang> after receiving an input char, the state machine spits out some string, and waits for the next input
00:48:13 <jtcwang> so its iterative
00:48:39 <Iceland_jack> jtcwang: Are you familiar with the state monad?
00:48:46 <jtcwang> Iceland_jack, that looks like what i'm looking for
00:48:56 <mm_freak> no, State is unlikely to be what you're looking for!
00:49:07 <jtcwang> should i put it in a IO function and use forever on it?
00:49:16 <mm_freak> jtcwang: state machines have a close relationship with streams
00:49:25 <Iceland_jack> mm_freak: How should jtcwang propogate the state changes?
00:49:33 <mm_freak> Iceland_jack: not at all
00:49:49 <mm_freak> jtcwang: do you understand how a stream of values is actually a state machine?
00:49:49 <Iceland_jack> ‘Not to put too fine a point on it’ :)
00:50:08 <jtcwang> mm_freak, not quite
00:50:18 <c_wraith> It's kind of a waste to embed otherwise-pure calculations in IO just because reading input uses IO.
00:50:37 <jtcwang> i'm actually not using state
00:50:44 <jtcwang> atm
00:50:48 <Iceland_jack> c_wraith: Just because IO is at the bottom of the transformer stack doesn't mean the functions needs to be impure
00:50:48 <mm_freak> jtcwang: data Stream a = Stream { current :: a, next :: Stream a }
00:50:50 <jtcwang> sry i simplified it in the wrong way
00:50:56 <mm_freak> jtcwang: do you understand this type?
00:50:59 <c_wraith> Iceland_jack: but it means you lose the guarantees
00:51:06 <jtcwang> previously, i'm just recursively calling the function
00:51:08 <Iceland_jack> c_wraith: You don't have to no
00:51:24 <jtcwang> like executeGame gameParemeter currentState etc etc
00:51:26 <mm_freak> jtcwang: don't worry, there is a better approach =)
00:51:44 <c_wraith> For something like this, I'd probably use something like a Mealy machine
00:51:56 <mm_freak> jtcwang: here is the list type:  data List a = Cons a (List a) | Nil
00:51:57 <jtcwang> mm_freak, hmm not exactly
00:52:03 <jtcwang> but i can see its like a linked list
00:52:11 <jtcwang> but a linked list of state?
00:52:16 <mm_freak> jtcwang: yeah, Stream is like List, except that there is no Nil
00:52:44 <mm_freak> jtcwang: now if you look at a stream that starts at 1 and counts upwards to infinity, there are two interpretations
00:52:49 <mm_freak> 1. it's a stream of increasing values
00:52:56 <mm_freak> 2. it's a state machine that produces increasing values
00:53:02 <mm_freak> they are the same thing
00:53:05 <jtcwang> mhmm
00:53:14 <mm_freak> countFrom x = Stream x (countFrom (x + 1))
00:53:15 <c_wraith> newtype StateMachine s i = StateMachine { runStateMachine :: i -> (s, StateMachine s i) }
00:53:35 <mm_freak> jtcwang: clear so far?
00:53:49 <jtcwang> yes
00:54:05 <jtcwang> i'm thinking about how we'd incorporate unpredictable input
00:54:15 <shachaf> What is multiplication of conaturals like? Is there an obvious thing for it to be?
00:54:17 <mm_freak> jtcwang: now you have a state machine that may act differently depending on some value at a certain point in time
00:54:57 <mm_freak> jtcwang: let me just rewrite Stream a little bit:  newtype Stream a = Stream (a, Stream a)
00:54:59 <jtcwang> c_wraith, your 'i' is the action?
00:55:12 <c_wraith> jtcwang: i is the input, s is the state
00:55:15 <mm_freak> jtcwang: still the same type, but now it will be easier to understand what i'm about to do
00:55:17 <jtcwang> mm_freak, yeap?
00:55:30 <jtcwang> its like IO i guess
00:55:35 <mm_freak> jtcwang: newtype Auto a b = Auto (a -> (b, Auto a b))
00:55:37 <jtcwang> you have (action, world)?
00:55:51 <c_wraith> and mm_freak has just got to the same representation I had.
00:55:56 <mm_freak> well, let's not call it "world", let's just call it "input" =)
00:56:05 <c_wraith> It's a really good representation for this sort of thing.
00:56:08 <mm_freak> c_wraith: except that mine is more Category-friendly =P
00:56:21 <jtcwang> mm_freak, oh sry i was referring to some guides i read regarding what's IO in haskell
00:56:29 <c_wraith> oh, you flipped the type variables.  Sure. :)
00:56:33 <shachaf> Auto, also known as Mealy.
00:56:50 <mm_freak> jtcwang: now let's suppose that you want an automaton that counts upwards, but may change its pace based on input
00:57:09 <mm_freak> sumFrom :: Double -> Auto Double Double
00:57:21 <mm_freak> sumFrom x = Auto (\dx -> (x, sumFrom (x + dx)))
00:57:44 <c_wraith> is Mealy a Profunctor then?
00:57:48 <mm_freak> c_wraith: yes
00:57:53 <shachaf> Yep.
00:57:53 <c_wraith> handy
00:58:18 <shachaf> So is Moore.
00:58:40 <shachaf> Mealy a b = a -> Moore a b; Moore a b = (b, Mealy a b)
00:58:54 <mm_freak> jtcwang: now 'Auto f' is an automaton that does this:  it examines its current input, provides one output as well as a new automaton
00:59:32 <jtcwang> hm
00:59:43 <jtcwang> i'm getting stuck with the recursive definition
00:59:45 <jtcwang> or auto
00:59:57 <jtcwang> give me a moment to digest
01:00:22 <c_wraith> It really is just an infinite stream that needs inputs to step it.
01:01:34 <mm_freak> jtcwang: you can "zip" a Stream with an Auto to get another Stream
01:01:43 <mm_freak> runAuto :: Stream a -> Auto a b -> Stream b
01:01:45 <jtcwang> I still need to get used to these type definition with arbitary types
01:01:59 <jtcwang> cuz when i see Auto a b i keep thinking Auto is a function..
01:02:18 <mm_freak> it looks a lot like a function and has a strong relationship to functions
01:02:52 <c_wraith> But if you try to unwrap it, you end up with an infinite type.
01:02:57 <c_wraith> So don't try that. :)
01:03:20 <jtcwang> typeception
01:03:27 <mm_freak> jtcwang: in many ways it acts like a function…  one that may give you a different result each time you call it =)
01:03:29 <nstdloop> Preferably without using Data.Map, what's the nicest way to find the b that matches a given a in a [(a, b)]
01:03:48 <mm_freak> nstdloop: lookup
01:03:49 <c_wraith> :t lookup
01:03:50 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
01:03:55 <nstdloop> brilliant
01:03:55 <jtcwang> mm_freak, yeah true that's state machine :P
01:04:03 <mm_freak> jtcwang: exactly =)
01:04:05 <jtcwang> i'm not sure whether this suits what i already have
01:04:15 <jtcwang> cuz i've already done the game logic
01:04:21 <jtcwang> (just a simple game)
01:04:56 <jtcwang> i'm using recursion a lot
01:05:10 <mm_freak> jtcwang: Auto has a strong relationship to FRP
01:05:19 <mm_freak> so yes, it's very suitable for game logic
01:05:41 <jtcwang> i want to dabble with FRP when my haskell foundation is stronger
01:05:54 <jtcwang> very interesting concept
01:06:08 <mm_freak> jtcwang: the idea of Auto is that you have locally stateful components and compose them
01:06:25 <jtcwang> a 'pure' state machine :)
01:06:28 <mm_freak> as opposed to state monads, where you get a large global state and access pieces of it
01:07:07 <mm_freak> player :: Auto (World, Enemies, Input) Player
01:07:30 <mm_freak> enemy :: Auto (World, Player) Enemy
01:07:46 <mm_freak> manyEnemies :: [Auto a b] -> Auto a [b]
01:07:55 <mm_freak> =)
01:08:14 <jtcwang> i have to keep looking at Auto's definition haha
01:08:55 <mm_freak> jtcwang: just do something with it:  write an Auto that takes a String at every instant and returns the concatenation of all strings received so far
01:09:32 <jtcwang> Auto a b = Auto (a -> (b, Auto a b))
01:09:43 <mm_freak> jtcwang: Auto/Mealy is best understood by using it
01:09:57 <jtcwang> i'm looking at it atm, aren't we missing a second parameter for Auto?
01:10:03 <mm_freak> nope
01:10:11 <jtcwang> or is it a type constructor
01:10:40 <mm_freak> if the definition confuses you, write it this way:
01:10:41 <trillioneyes> jtcwang: the outer "Auto" on the right hand side is a data constructor I think
01:10:57 <mm_freak> newtype Auto a b = TransitionFunction (a -> (b, Auto a b))
01:11:00 <trillioneyes> data Auto a b = MkAuto (a -> (b, Auto a b))
01:11:41 <mm_freak> an Auto takes an input value and returns two things:  it returns the next stream element as well as the transition function you're supposed to call the next time
01:11:43 <jtcwang> Auto is a function that takes an input (type a) and gives you a state (type b) as well as the "next state machine"
01:11:50 <jtcwang> i've said it!
01:11:58 <mm_freak> pretty much =)
01:12:26 <c_wraith> edwardk: http://hackage.haskell.org/package/semigroups doesn't build with text 1.1.0.0, and I suppose lots more things you maintain won't.  I think it's just an upper bound thing.
01:12:40 <jtcwang> trillioneyes, yeah i just realised that. it trips me up sometimes :)
01:12:52 <mm_freak> jtcwang: now i suggest you implement it and do some experiments
01:13:12 <mm_freak> once you're comfortable you can use the 'machines' library, which defines Mealy (= Auto) for you =)
01:13:23 <trillioneyes> jtcwang: yeah, I prefer to give typethings and valuethings different names when reasonable
01:13:34 <jtcwang> mm_freak, thanks. I will play around with it
01:13:59 <jtcwang> I can see state machine fitting my game better
01:14:09 <jtcwang> than passing records everywhere
01:14:48 <jtcwang> i have to wonder though, what's the cost associated with generating potentially huge state machines
01:14:50 <jtcwang> on every step?
01:15:07 <c_wraith> It's just generating a closure
01:15:25 <c_wraith> that is, storing a few arguments and a pointer the the function
01:15:35 <jtcwang> i'll need to google that :P
01:15:42 <mm_freak> jtcwang: very cheap
01:15:52 <mm_freak> jtcwang: it's a thin layer around regular functions
01:17:06 <mm_freak> also guys, please stop even mentioning state monads for games
01:17:07 <jtcwang> so, at compile time the compiler sees through all our BS and just put them as down as iterative computations?
01:17:19 <mm_freak> there couldn't possibly be a worse way to write a game than using a state monad
01:17:47 <c_wraith> jtcwang: well, the hardware is iterative.  It has to convert it to a language the hardware speaks
01:18:20 <jtcwang> c_wraith, i mean, it just sees it as an iterative function call on some initial variable
01:18:42 <jtcwang> so it doesn't necessary generate a state machine for each state?
01:18:46 <mm_freak> jtcwang: that's what it ends up being
01:19:02 <jtcwang> idk i'm kinda confused about closure and its relevane here
01:19:09 <jtcwang> its a function that uses free variable
01:19:10 <mm_freak> jtcwang: the "current state" will be encoded in the "next state machine"
01:19:22 <jtcwang> but how is it relevant here?
01:20:19 <mm_freak> jtcwang: look at sumFrom
01:20:32 <c_wraith> look at mm_freak's example up above...  It's a lambda (anonymous function) that refers to a free variable in its body
01:20:33 <mm_freak> sumFrom x = Auto (\dx -> (x, sumFrom (x + dx)))
01:20:40 <c_wraith> yeah, that example
01:20:44 <mm_freak> jtcwang: the "current state" is x
01:21:00 <mm_freak> but it's implicitly hidden in the lambda
01:21:13 <mm_freak> all you get is an Auto, which is really just a function
01:21:35 <mm_freak> that function however knows how to construct the "next" function, which in turn knows how to construct the next, and so on
01:21:46 <mm_freak> this is a form of state
01:22:00 <jtcwang> mhmm
01:22:18 <mm_freak> just like Stream has a state notion
01:22:19 <jtcwang> so you can use some function to extract x
01:22:25 <jtcwang> say for recording or displaying
01:22:39 <mm_freak> well, yes
01:22:47 <mm_freak> newtype Auto a b = Auto { stepAuto :: a -> (b, Auto a b) }
01:22:58 <mm_freak> stepAuto :: Auto a b -> a -> (b, Auto a b)
01:23:15 <mm_freak> you give it an input value, it gives you an output value and the next machine
01:23:37 <mm_freak> remember that state has nothing to do with updating a mutable variable =)
01:23:52 <mm_freak> in fact mutable variables are the worst possible way to represent state
01:24:06 <jtcwang> mm_freak, we create parallel universe :)
01:24:09 <jtcwang> even cooler
01:24:15 <mm_freak> =)
01:24:25 <c_wraith> I kinda don't like that definition of sumFrom...  the value of x it returns doesn't include the input, which I find odd.
01:24:45 <jtcwang> ok mm_freak, say if i want to print x
01:24:52 <mm_freak> c_wraith: it's less odd when time and ArrowLoop come in
01:24:53 <jtcwang> how would i define a function to do that
01:25:04 <mm_freak> jtcwang: what's x?
01:25:14 <jtcwang> in sumFrom :: Double -> Auto Double Double
01:25:14 <jtcwang> sumFrom x = Auto (\dx -> (x, sumFrom (x + dx)))
01:25:23 <jtcwang> x is the state
01:25:41 <jtcwang> but our state is wrapped in Auto (a function)
01:25:51 <jtcwang> or is it..?
01:26:17 <mm_freak> gameLoop auto = do dx <- fmap read getLine;  let (x, auto') = stepAuto auto dx;  print x;  gameLoop auto'
01:26:50 <mm_freak> gameLoop :: (Num a) => Auto a a -> IO b
01:27:45 <mm_freak> the side-effecting input machinery is the first part of the loop…  then comes the game logic, which is nothing more than a stepAuto call, then comes the side-effecting output/rendering part
01:27:51 <mm_freak> and then the whole thing repeats
01:28:35 <mm_freak> the game logic itself is pure and does not describe side effects
01:28:41 <jtcwang> right
01:28:53 <jtcwang> that's very cool
01:29:03 <jtcwang> the whole pure state machine thingy
01:29:19 <mm_freak> it's cool, easy to get right and very fast =)
01:29:44 <jtcwang> do u haskell professionally?
01:29:51 <mm_freak> yes
01:30:01 <jtcwang> that's pretty cool
01:30:12 <jtcwang> what industry do you work in?
01:30:20 <mm_freak> web, networking, security
01:30:50 <mekeor> how can you most nicely implement a function of type "(a -> Either b c) -> [a] -> Either b [c]" (without doing recursion myself manually)? – it should return the first occurence of the Left-case if there is one.
01:31:15 <mm_freak> mekeor: what would be the semantics?  when b is received, stop with Left?
01:31:22 <jtcwang> i see. well mm_freak thanks for opening my eyes today :)
01:31:31 <mekeor> mm_freak: exactly
01:31:34 <mm_freak> mekeor: mapM
01:31:41 <mm_freak> jtcwang: my pleasure =)
01:31:54 <mekeor> oh.
01:32:09 <mm_freak> mekeor: it even has exactly that type =)
01:32:14 <mekeor> :D
01:32:18 <mekeor> perfect, thanks :)
01:32:26 <mm_freak> so a hoogle search would have answered your question =P
01:32:37 <mekeor> <.< >.> <.<
01:32:55 <mm_freak> @hoogle (a -> Either b c) -> [a] -> Either b [c]
01:32:55 <lambdabot> No results found
01:32:59 <mm_freak> or not
01:33:20 <mm_freak> @hoogle (a -> m c) -> [a] -> m [c]
01:33:20 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:33:20 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:33:20 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
01:33:26 <mm_freak> well, ok
01:33:36 <mm_freak> hoogle isn't sufficiently polymorphic =)
01:34:05 <Iceland_jack> @hoogle (a -> eitherb c) -> [a] -> eitherb [c]
01:34:05 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:34:05 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:34:06 <Iceland_jack> ;)
01:34:07 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
01:34:19 <aristid> mm_freak: the type of mapM looks like a perfect fit to me?
01:34:40 <mm_freak> aristid: to me, too, but not to hoogle
01:34:52 <mm_freak> it fails to identify 'Either b' with 'm'
01:35:04 <aristid> mm_freak: ah
01:35:52 <aristid> i don't think hoogle has any intelligence, it just tries to match types fuzzily, doesn't it?
01:40:52 <ffoobar> I remember there was a recent book that accumulated knowledge on static single assignment. Anyone rember it's name?
01:41:56 <mm_freak> aristid: i think it does some matching
01:42:08 <mm_freak> @hoogle (a -> Maybe b) -> [a] -> Maybe [b]
01:42:09 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:42:09 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
01:42:09 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
01:42:26 <mm_freak> aristid: but it's probably not mature yet
01:42:28 <aristid> mm_freak: so it just doesn't know about Either?
01:43:43 <osa1> let's say I'm using orElse from arrows, how can I fail in left-hand side of this orElse? I'm looking at ArrowIf typeclass but can't see anything related
01:43:50 <mm_freak> aristid: it does…  i think it fails to identify "A B" with "c" in general
01:43:56 <mm_freak> or does it?
01:44:11 <mm_freak> @hoogle (b -> Maybe Int) -> (a -> b) -> a -> Maybe Int
01:44:11 <lambdabot> No results found
01:44:14 <mm_freak> indeed
01:44:38 <mm_freak> osa1: where is that type class defined?  and what's wrong with ArrowChoice?
01:44:48 <mekeor> osa1: did you mean ArrowChoice?
01:45:07 <osa1> mekeor, no, ArrowIf
01:45:14 <osa1> mm_freak, I don't know and I don't know
01:45:18 <osa1> let me check
01:45:57 <mm_freak> osa1: ArrowChoice allows you to use 'if' and 'case' in arrow notation
01:46:08 <osa1> mm_freak, mekeor it's defined in hxt
01:47:27 <osa1> mm_freak, currently I can't change libraries in use. this library provides XML parser defined as arrows and you can do some cool things using combinators like `orElse` but I can't find how to fail in a parser
01:47:28 <mm_freak> osa1: looks suspiciously like ArrowZero+ArrowPlus to me
01:48:26 <osa1> mm_freak, in that case I could use zeroArrow for that, right?
01:48:55 <mm_freak> osa1: yes, zeroArrow is failure
01:49:04 <osa1> okay thanks. I'll try that
01:49:39 <mm_freak> in fact, ArrowIf looks like ArrowPlus alone, but the hxt types are ArrowZero instances as well
01:50:26 <mm_freak> i wonder why they define their own class
01:51:20 <mm_freak> in fact looking at the type definitions i have to wonder why they're using arrows at all
01:51:27 <mm_freak> those are all monads
01:52:40 <c_wraith> yeah, that's a real design issue in hxt
01:53:14 <mm_freak> ArrowIf even /requires/ ArrowApply
01:53:26 <mm_freak> even though there is nothing in ArrowIf that would actually require ArrowApply
01:56:58 <randomclown> @pl \x -> f a $ g x
01:56:58 <lambdabot> f a . g
01:57:54 <mm_freak> i have to say hxt seems badly designed
01:58:22 <randomclown> does anyone actually use the <- <- arrow notation?
02:00:29 <mm_freak> <- <-?  you mean <- -<?
02:00:43 <randomclown> yes
02:00:51 <mm_freak> randomclown: sure, i use it almost every day
02:05:00 <Kaidelong> so my whole exercise in writing parsers turned out to be useless because I assumed things about xpAttribute that is not true
02:10:13 <osa1> so I have a function with type T1 -> Maybe T2 and I'm using this in some arrow computations, like " ... >>> arr myFun" . Now I want to replace this T1 -> Maybe T2 with T1 -> Arrow ...... T2 which means arrow should fail with zeroArrow when Nothing happens. how can I do that?
02:11:54 <jle`> is ghcjs at the point where i can just cabal install it now or do i still need to build ghc head and all that jazz
02:12:44 <jle`> or do the vagrant dance
02:17:26 <mm_freak> osa1: usually you would use ArrowChoice with ArrowZero
02:18:15 <mm_freak> case mx of Just x -> id -< x; Nothing -> zeroArrow -< ()
02:18:18 <mm_freak> something like that
02:18:34 <osa1> mm_freak, is there a combinator to convert a Maybe to an Arrow type where zeroArrow is used when Nothing happened?
02:18:39 <osa1> hm
02:19:14 <mm_freak> osa1: not predefined, but you can easily write it yourself
02:19:21 <mm_freak> i just gave you the definition =)
02:19:47 <mm_freak> it's even easier for Either, because you can just use (+++) or (|||) directly
02:20:11 <donri_> can't you do it with maybe zeroArrow id
02:20:18 <mm_freak> so first convert to Either:  maybe (Left ()) Right
02:20:22 <mm_freak> donri_: no
02:20:38 <donri_> or you need ArrowApply for that?
02:20:42 <osa1> mm_freak, I just wrapped your code with a function but it failed with syntax error
02:20:46 <mm_freak> donri_: it's 'A X Y', not 'X -> A a Y'
02:20:58 <mm_freak> osa1: it uses arrow notation
02:21:06 <osa1> I know, it's enabled
02:21:20 <mm_freak> osa1: of course you need a 'proc' somewhere =)
02:21:32 <mm_freak> proc mx -> case mx of …
02:22:20 <osa1> mm_freak, No instance for (ArrowZero (->)) arising from a use of `zeroArrow'
02:22:30 <mm_freak> osa1: use returnA instead of id
02:22:48 <mm_freak> or do this:  import Control.Category; import Prelude hiding ((.), id)
02:22:55 <osa1> mm_freak, awesome, thanks.
02:22:58 <osa1> now let's see how can I use it
02:23:02 <mm_freak> for some reason i prefer 'id' over 'returnA' =)
02:23:17 <mm_freak> most notably because returnA = arr id
02:23:19 <mm_freak> which is stupid
02:24:11 <randomclown> is it possible to put a type restriction on a type statement
02:24:11 <timthelion> So I have a library wich has a type "data MountStatus = Success | Error String" and a mount function, and then I have a function(in a different library) that also has a mountGit function which should reasonably return a MountStatus, however, I need to return some extra info when mountGit is successfull
02:24:12 <shachaf> @arr id
02:24:12 <lambdabot> Keelhaul the swabs!
02:24:17 <osa1> mm_freak, it worked, awesome! many thanks
02:24:22 <osa1> need to learn arrows properly sometime
02:24:34 <randomclown> i.e. type (Integral a) => MyType a = etc etc
02:24:38 <timthelion> Right now, I return (MountStatus,Maybe ExtraInfo), but that means that the Maybe is only Just on m
02:24:50 <timthelion> MountSuccess, and only Nothing on Error
02:25:28 <timthelion> Is there a way to do this cleanly without creating a data MountGitStatus = Success ExtraInfo | Error String?
02:25:57 <jle`> ocharles: hi. is there any reason why you decided to use netwire for your asteroids project instead of other frp libraries?
02:26:50 <Twey> randomclown: No
02:27:33 <Twey> Er
02:28:19 <Twey> randomclown: You can with RankNTypes, but it may not have quite the behaviour you expect
02:28:41 <Twey> (there's an implicit forall)
02:29:09 <randomclown> Ok
02:29:16 <randomclown> unrelated: is there an integer type that wraps?
02:30:00 <timthelion> randomclown: http://hackage.haskell.org/package/modular-arithmetic
02:30:02 <timthelion> randomclown: like that?
02:30:20 <randomclown> something like c's unsigned short
02:30:26 <Cale> randomclown: Int, Int8, Int16, Int32, Int64, Word8, Word16, Word32, Word64
02:30:31 <randomclown> Cale: they wrap?
02:30:36 <Cale> yes
02:30:51 <Cale> Oh, and Word as well :)
02:30:55 <timthelion> In C the behavior is "undefined"
02:31:28 <randomclown> timthelion: only for signed integers
02:31:29 <dv-> > maxBound + 10 :: Int
02:31:30 <lambdabot>  -9223372036854775799
02:31:40 <timthelion> randomclown: aha,  sorry
02:31:48 <randomclown> > maxBound + 10 :: Int8
02:31:49 <lambdabot>  -119
02:31:52 <Cale> Int and Word are of a machine-specific size, guaranteed to have at least -2^29 to 2^29 - 1
02:32:53 <frx> > maxBound + 1 :: Int
02:32:54 <shachaf> Is Int overflow behavior defined by the report?
02:32:54 <lambdabot>  -9223372036854775808
02:32:57 <shachaf> I thought it wasn't.
02:33:02 <timthelion> Cale: where do those extra 2 bits get lost? I expected -2^31 to 2^31...
02:33:02 <randomclown> > pred (minBound :: Int8)
02:33:03 <lambdabot>  *Exception: Enum.pred{Int8}: tried to take `pred' of minBound
02:33:12 <frx> > (maxBound + 1 :: Int) == minBound
02:33:12 <randomclown> > pred (minBound :: Int)
02:33:12 <lambdabot>  True
02:33:13 <lambdabot>  can't find file: L.hs
02:33:18 * hackagebot lazyio 0.0.3.3 - Run IO actions lazily while respecting their order  http://hackage.haskell.org/package/lazyio-0.0.3.3 (HenningThielemann)
02:33:44 <randomclown> am I retarded expecting pred to wrap?
02:33:51 <randomclown> > pred (minBound :: Word8)
02:33:52 <lambdabot>  *Exception: Enum.pred{Word8}: tried to take `pred' of minBound
02:34:29 <randomclown> > (minBound :: Word8) - 1
02:34:30 <lambdabot>  255
02:34:48 <Cale> I don't even use succ and pred from Enum, because they don't really belong in that class anyway. Just use arithmetic operations. :)
02:34:53 <jle`> why would pred wrap?
02:35:01 <randomclown> yeah I'm retared
02:35:03 <randomclown> haha
02:35:06 <jle`> what is pred 0, of the natural numbers?
02:35:08 <Cale> jle`: well, because subtraction of 1 does
02:35:17 <timthelion> jle`: infinity!
02:35:24 <Cale> > 0 - 1 :: Word8
02:35:25 <lambdabot>  255
02:35:29 <Cale> > 0 - 1 :: Word64
02:35:30 <lambdabot>  18446744073709551615
02:35:57 <jle`> hm. i guess i mean conceptually
02:36:19 <randomclown> > succ (maxBound :: Word8)
02:36:20 <lambdabot>  *Exception: Enum.succ{Word8}: tried to take `succ' of maxBound
02:36:44 <Cale> Well, conceptually, Word is Z/(2^k Z) for some k :)
02:36:45 <timthelion> randomclown: did you look at the package I linked to?  It seems that would match your expectations better...
02:37:19 <randomclown> timthelion: not really, I'm probablly going to stick with word/ints since I need bitwise stuff
02:37:29 <timthelion> randomclown: ok
02:37:49 <timthelion> Cale: did you just specify the set which k belongs to?
02:38:07 <timthelion> Cale: with the "k Z"
02:39:51 <Cale> timthelion: No, that's the ring of integers modulo the ideal of multiples of 2^k
02:39:57 <Cale> (2^k) Z
02:40:10 <Cale> = { 2^k n | n in Z }
02:41:41 <timthelion> Cale: OK,  I guess I didn't undestand that notation then.  I still am at a total noob level when it comes to abstract mathematics.  So calling something a ring doesn't help me much unfortunately.
02:42:34 <Cale> ah, well, a ring is sort of kind of like "something in the Num class", only without all the cruft :)
02:42:47 <Cale> and there are actual laws which have to be satisfied :P
02:43:05 <Cale> http://en.wikipedia.org/wiki/Ring_(mathematics)#Definition
02:43:27 <lieven_> now you have me imagining a typeclass hierachy with UFD, PID, Artinian etc. the horror, the horror
02:44:28 <Cale> Basically, a set with addition and multiplication that satisfy the rules we'd usually expect of those. You'll note that it's not assumed that multiplication is commutative (i.e. that a*b = b*a), and it's also not assumed that there are inverses for multiplication (i.e. for every nonzero a, there's some a^-1 so that a * a^-1 = a^-1 * a = 1)
02:45:28 <Twey> When compiling Cabal-1.18.1.2 with ghc-7.7, I get an error: ‘Distribution/Version.hs:122:35: No instance for (Data Version)’
02:45:29 <Cale> A ring where multiplication is commutative is called a commutative ring. A ring with inverses for multiplication is called a division ring or a skew field. A ring with both of these, where in addition 0 is not equal to 1, is called a field.
02:46:21 <ocharles> jle`: I chose netwire because it seemed conceptually simple
02:46:25 <Cale> (and as lieven_ points out, there is a large hierarchy of other special sorts of rings which are well-studied)
02:46:27 <ocharles> jle`: so I just ran with that. no real decision
02:46:31 <ocharles> jle`: I suppose it also helped that I knew the author was active here in IRC :)
02:46:40 <randomclown> hmm, I have 65536 slots, each slot is either occupied or it's not. I need a data structure that can efficently find a empty slot. Also need to be able to mark the slot as occupied or not occupied
02:46:55 <Cale> randomclown: Data.Set
02:47:07 <Cale> Or even Data.IntSet
02:47:15 <randomclown> how does that help with finding an empty slot?
02:47:22 <randomclown> I'll still need to O(n) search
02:47:27 <Kaidelong> Philonous_, I have a question about xml-picklers
02:48:11 <Cale> Well, I suppose you might not want to build the set of all available slots :)
02:48:11 <timthelion> Cale: you are a MUCH better teacher than wikipedia.  I had read the article on rings twice and gotten caught up in all the other terms I didn't know.  Thank you!
02:48:17 <jack_rabbit> randomclown, do you need efficient lookup of USED slots?
02:48:20 <jle`> ocharles: ah thanks.
02:48:25 <jle`> ocharles: who is this author? :)
02:48:30 <Cale> timthelion: no problem!
02:48:33 <Kaidelong> I have a situation where I need to build a list out of multiple attribute values, perhaps zero, the closest way to do this I can find is xpAlt but I need something more along the lines of PU a [b] as a return type rather than PU a b
02:48:41 <jack_rabbit> randomclown, If not, any data structure that supports efficient removal will work. :)
02:48:45 <Twey> Oh, I guess Cabal doesn't support GHC 7.7
02:48:55 <randomclown> jack_rabbit: I just need something that can find an empty slot faster than O(n)
02:48:57 <jle`> ocharles: debating between netwire and sodium and just using the classic game loop in state monad
02:50:10 <donri_> randomclown: why can't you have an intset of empty slots?
02:50:19 <jle`> i am inclined to do the latter because i still don't totally see the advantage of frp.
02:50:38 <randomclown> donri_: how is that different to intset used occupied slots?
02:50:51 <randomclown> intset of*
02:51:06 <mm_freak> jle`: the advantage of FRP is that there is no global state
02:51:13 <Kaidelong> oh maybe I can combine xpAlt and xpFindMatches
02:51:42 <jle`> mm_freak: hm
02:51:44 <mm_freak> jle`: in particular no state monad with a giant state record
02:51:53 <jle`> so basically solving problems that oop solved decades ago? :P
02:52:11 <mm_freak> jle`: no, OOP didn't solve it
02:52:25 <jle`> hm
02:52:32 <mm_freak> jle`: FRP gives you precise and sound semantics for time-varying values
02:52:39 <donri_> randomclown: well you can use something like findMin to get an empty slot and then delete it
02:52:53 <donri_> randomclown: deleteFindMin in one go
02:52:56 <jle`> mm_freak: would i encounter this in both netwire and sodium? if i begin picking up one or the other
02:52:57 <ocharles> g'morning mm_freak !
02:53:07 <mm_freak> hi there ocharles =)
02:53:20 <timthelion> jle`: I *personally* recomend that you use MVars rather than a monad game loop.  The reason is, that as state becomes more complex than the monad state will become a mess.  Also, such state monads are inherently non-concurrent.
02:53:20 <mm_freak> jle`: both are FRP libraries, so yes
02:53:35 <mm_freak> timthelion: i recommend neither
02:53:44 <epta> randomclown: IntSet.member is O(min(n, w))
02:53:48 <randomclown> donri_: we'll need to put 65k items in the intset though
02:53:57 <jle`> timthelion: i was thinking about mvar stuff instead becuase i would have to handle asynchronous events somehow.
02:54:06 <epta> randomclown: http://hackage.haskell.org/package/containers-0.5.3.1/docs/Data-IntSet.html
02:54:08 <jle`> hm okay i'll look into this promise that FRP offers mm_freak
02:54:08 <Cale> jle`: You might like this talk as it was aimed at a very general audience and explains how FRP hopes to fit into the solution space of problems http://www.youtube.com/watch?v=gaG3tIb3Lbk
02:54:11 <jle`> thank you for mentioning this
02:54:25 <Cale> (It was also given by the author of Sodium)
02:54:36 <jle`> this is my first hint at what advantages it really offered instead of just a rephrasing
02:54:44 <jle`> Cale: thanks i'll check it out :)
02:54:55 <mm_freak> jle`: sodium is a lot like reactive-banana, and those two are very useful for putting an FRP layer around widget-based UI frameworks
02:55:06 <jle`> i'm building a vidya game
02:55:08 <mm_freak> jle`: for games, especially real-time, i recommend netwire
02:55:15 <donri_> randomclown: only when they're all free (:
02:55:16 <ocharles> jle`: to carry on with the local state thing - I'm building a clone of Super Mario World. I currently have Mario himself working, and now I want to add Goombas. In the traditional big-state idea, I would have to work out what state I need to carry for Goombas, including potentially "private" information such as there AI state
02:55:16 <jle`> hm.
02:55:19 <ocharles> With FRP, I can localise that
02:55:28 <ocharles> Firstly I have less to change - no need to think about how to capture the global state
02:55:37 <ocharles> And secondly, I get guarantees that only the Goombas are in charge of that state
02:55:53 <ocharles> So to change it, I have to inform the Goomba some how - like via an event that Mario has stomped on their head
02:55:57 <jle`> mm_freak: is there a fundamental reason why they differ in thsi way? from a framework design standpoint?
02:56:00 <donri_> randomclown: i was just going for simplicity. if you want compact and performant you could whip something smarter up, i imagine.
02:56:06 <jle`> ocharles: yes that feels all sorts of right.
02:56:11 <Cale> Stephen positions it as a drop in replacement for the Observer pattern which doesn't suck
02:56:21 <mm_freak> jle`: however, you should definitely try all of them, because for some things reactive-banana/sodium work better than netwire, and it's not an exclusive choice…  you can combine them =)
02:56:24 <jle`> having a giant global state feels like going backwards in time.
02:56:37 <jle`> mm_freak: did not know about combining them :)
02:56:44 <ocharles> I think I want to try sodium for when I have a less time bound application, and more an external-IO-pushing-stuff-in model
02:56:49 <mm_freak> jle`: yes, they differ in the way they interact with the real world
02:56:53 <ocharles> netwire tends to suck with that
02:57:01 <mm_freak> jle`: reactive-banana and sodium bind to callbacks
02:57:09 <mm_freak> jle`: netwire binds to frames
02:57:28 <jle`> ah
02:57:45 <jle`> is this fundamentally different than just having a callback for every tick?
02:58:02 <Philonous_> Kaidelong, What's the question?
02:58:02 <mm_freak> jle`: well, there is a fundamental difference
02:58:28 <jle`> wish there was some kind of guide somewhere to lay these out :/
02:58:37 <mm_freak> jle`: reactive-banana and sodium give you 'Behavior a' for a time-varyling value of type 'a'
02:58:41 <jle`> but any such guide would likely be out of date faster than it would be worth maintaining
02:58:48 <Cale> Well, that's the observer pattern, it's something better structured than that. There are many obnoxious properties that callbacks have, not the least of which that the order in which multiple callbacks execute can matter and create bugs.
02:58:49 <mm_freak> jle`: in netwire, because of its AFRP design, it's just 'a'
02:59:03 <mm_freak> jle`: the video Cale linked is fine, you should probably watch it =)
02:59:07 <jle`> AFRP?
02:59:26 <mm_freak> jle`: arrowized FRP
02:59:27 <jle`> animal friends rescue project?
02:59:34 <mm_freak> hehe
02:59:48 <jle`> ah
03:00:05 <jle`> is the 'arrowized' from the haskell arrows in base?
03:00:10 <Cale> yes
03:00:23 <Cale> (or some variation on those -- Control.Arrow sucks in a lot of ways)
03:00:28 <mm_freak> jle`: oh, and to answer your question, i'm the author of netwire =)
03:00:56 <jle`> one thing that turned me off when looking at netwire code vs sodium is that netwire types seemed to have a lot more type variables. but that is probably a superficial thing v.v
03:01:05 <jle`> mm_freak: ah :)
03:01:57 <mm_freak> jle`: as the tutorial states:  "The type signatures in Netwire are known to be scary. =) But like most of the library the underlying meaning is actually very simple."
03:02:44 <jle`> must look into that tutorial apparently then :P
03:02:52 <mm_freak> jle`: i recommend watching the video Cale linked for the How and Why of FRP
03:02:55 <donri> randomclown: couldn't you use the binary search package to efficiently find a non-member in a set of occupied fields?
03:03:01 <donri> @hackage binary-search
03:03:01 <lambdabot> http://hackage.haskell.org/package/binary-search
03:03:16 <mm_freak> jle`: and for a netwire-specific introduction you should read this:  http://hub.darcs.net/ertes/netwire/browse/README.md
03:03:27 <randomclown> donri: no because there is no guarentee that the allocations are contagious
03:03:34 <jle`> mm_freak: thanks, the video apparently holds the answer to many of my questions.
03:03:43 <donri> aha
03:03:51 <mm_freak> jle`: yes
03:04:01 <jle`> does it summarize key fundamental differences in the design decisions of the different frp approaches?
03:04:11 <Guest15819> @pl p x = x `mod` 31 == 0
03:04:11 <lambdabot> p = (0 ==) . (`mod` 31)
03:04:16 <mm_freak> jle`: it's slightly biased to UIs, but the information is sufficiently general to apply to games as well
03:04:25 <mm_freak> jle`: well, there is only one "FRP" =)
03:04:39 <ocharles> jle`: I guess you've seen my asteroids work?
03:04:39 <mm_freak> but there are multiple ways to expose it to users
03:04:55 <jle`> ocharles: yes it's one of my bookmarks for this current state in my haskell learnings
03:05:04 <mm_freak> jle`: the video is sodium-specific, but most of it applies to reactive-banana as well
03:05:13 <jle`> that and that ghcjs/sodium tutorial
03:05:18 <ocharles> jle`: ok, cool :) It's a bit dated now - netwire has evolved a bit more so that code isn't quite idiomatic netwire anymore
03:05:24 <jle`> http://weblog.luite.com/wordpress/?p=127
03:05:24 <ocharles> but a lot of the general concepts are the same
03:05:25 <mm_freak> jle`: once you understand FRP, learning netwire should be a matter of reading the tutorial
03:05:42 <ocharles> I'm here most days - feel free to badger me as much as you want. I'm a big fan of FRP and all for helping people understand it
03:05:53 <jle`> i feel like in haskell everythg becomes out of date in a matter of months
03:05:55 <ocharles> jle`: Add "the Yampa Arcade" to your list of readings
03:06:08 <ocharles> In that they also refer to some of their previous papers - those are worth a read too
03:06:22 <ocharles> Learning more about Yampa helped me improve my FRP understanding, and that carried over to netwire well
03:06:37 <jle`> ocharles: thanks, will keep that handy as well
03:07:01 <ocharles> jle`: Things do move fast, but usually changes are just a logical progression
03:07:46 <Guest15819> @pl p xs = length xs > 5
03:07:46 <lambdabot> p = (> 5) . length
03:08:01 <jle`> mm_freak: that's nice to know. i was sort of under the impression that the different frameworks were fundamentally incompatible at the conceptual level
03:08:27 <mm_freak> jle`: we can move faster than other communities, mainly because we're not working around historical accidents all over the place…  our historical accidents are mostly minor annoyances =)
03:08:35 <mm_freak> like the Applicative-Monad stuff
03:08:58 <mm_freak> jle`: not at all, i've combined reactive-banana with netwire more than once
03:09:10 <jle`> i feel like it is also in part the feeling of experiment-ness around everything
03:09:18 <jle`> everything is always 'under research'
03:09:22 <jle`> 'ongoing research'
03:09:32 <jle`> i have never even heard that phrase thrown around in any other community
03:09:41 <jle`> rails isn't 'ongoing research' on a web framework
03:09:49 <jle`> on how to best build a web framework
03:10:32 <mm_freak> jle`: that's because we're using algebraic notions, which always leave room for further improvement…  OO projects usually hit a wall at some point
03:10:35 <jle`> x library isn't 'ongoing research' on a novel and experimental way of looking at things
03:10:45 <jle`> yeah
03:10:51 <mm_freak> jle`: in fact even netwire, despite its major version, is ongoing research =)
03:10:54 <jle`> i feel like OO stuff usually has limits to what can be done conceptually
03:11:06 <jle`> so much that 'research' doesn't even make sense at a practical level
03:11:22 <jle`> the difference between year 2 and year 3 is optimization with minor api changes
03:11:36 <jle`> or maybe a radical refactoring
03:11:45 <jle`> but nothing really conceptually new
03:12:06 <mm_freak> jle`: this community welcomes ongoing research, because it's safe research and you can employ new experimental results immediately in practical applications
03:12:09 <mm_freak> this is unthinkable in other languages
03:12:28 <jle`> i don't even know how to apply the word research in other languages/oop languages
03:12:57 <jle`> haskell is cool.
03:13:00 <jle`> (conclusion)
03:13:06 <ocharles> The odd thing was Haskell is, we usually hit a basic workable state a lot quicker than other languages (citation needed of course, but that's my experience)
03:13:13 <ocharles> so if you get the useful stuff fast... then what do you do?
03:13:15 <ocharles> you go further, of course :)
03:13:25 <ocharles> so everything turns into a research project for the author, because that's the exiciting stuff
03:13:26 <mm_freak> well, you could start by (consciously) using monoids in other languages =)
03:13:50 <mm_freak> in a certain way we all started with monoids, then we learned about groups, then about homomorphisms, etc.
03:14:05 <mm_freak> today we have a whole categorical framework, on which we build everything
03:14:41 <ocharles> jle`: Brent Yorgey's paper on monoids is a good read for taking a mathematical approach to library design - https://www.youtube.com/watch?v=X-8NCkD2vOw
03:14:46 <jle`> i guess haskell affords us all of the flexibility of mathematics in a compulter language form
03:14:48 <ocharles> You can find a link to the paper from there, if you enjoy the video
03:15:23 <ocharles> oh, i lie. The paper is http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
03:17:01 <jle`> ocharles: thanks :)
03:18:39 <Guest15819> @pl \acc x -> acc + x
03:18:39 <lambdabot> (+)
03:18:59 <jle`> ocharles: is there anywhere i can read more about that sort of state isolation that you observed in your super mario clone?
03:19:27 <ocharles> jle`: hmm, it's not very specific to that - it's the over-archiving idea of (a)frp in general
03:19:49 <mm_freak> jle`: to understand this state isolation look into the Mealy type in the 'machines' library
03:19:49 <ocharles> jle`: say you want to take the integral of a signal - that is, a cummulative sum of signal - over time
03:20:01 <ocharles> to do this you need to keep track of how much you've "seen" so far - and that is local state
03:20:14 <ocharles> so just about everything you use has this
03:20:38 <mm_freak> jle`: Wire is not much different from Mealy
03:21:25 <jle`> mm_freak: thanks, i've pocketed the talk from the hackage page
03:21:52 <jle`> is frp and mealy/machines related?
03:22:17 <mm_freak> jle`: also review the logs of this channel…  i explained Mealy (aka Auto) to someone else just today =)
03:22:17 <jle`> conceptually
03:22:22 <mm_freak> jle`: no
03:22:34 <mm_freak> jle`: but you can build an FRP abstraction on top of Mealy
03:22:41 <jle`> mm_freak: thanks, i'll scan back a bit
03:22:52 <mm_freak> search for Auto
03:23:21 <randomclown> why is there no liftM7
03:23:22 <mm_freak> it was also in the context of a game =)
03:23:25 <randomclown> disappointed
03:23:49 <mrack> is there a package like readline that is written entirely haskell, without having any C library dependencies?
03:23:50 <jle`> mm_freak: oh i found it. just about two or three hours ago
03:23:53 <ocharles> randomclown: you don't want to use `ap` I take it?
03:23:58 <mm_freak> randomclown: liftM7 f a b c d e f g = return f `ap` a `ap` b `ap` c `ap` d `ap` e `ap` f `ap` g
03:24:06 <randomclown> mm_freak: I'll rather die
03:24:18 <jle`> or even applicative style with <$> and <*>'s
03:24:27 <mm_freak> mrack: haskeline
03:24:34 <randomclown> at least <*> look better
03:24:35 <randomclown> than `ap`
03:24:50 <mrack> mm_freak: great
03:24:59 <mrack> mm_freak: does ghci use that?
03:25:04 <ocharles> randomclown: you could always let (!*!) = ap or something
03:25:39 <jle`> or if you want everybody to hate you locally bind ap to (.) :P
03:25:41 <jle`> (don't do this)
03:26:06 <mm_freak> mrack: yes
03:26:08 <Lethalman> isn't there a TH liftMn yet? :)
03:26:28 <Lethalman> that creates a liftM depending on the number of arguments accepted by the function, if that's even possible
03:26:39 <jle`> let (.) = (<*>) in f <$> a . b . c . d . e . f . g
03:26:56 <Guest15819> why is (++) inefficient compared to (:)
03:27:03 <jle`> fixity issues aside
03:27:17 <Axman6> Guest15819: (++) is O(n) where n is the length of the first argument
03:27:21 <Philonous_> Guest15819, It's not.
03:27:22 <Axman6> @src (++)
03:27:22 <lambdabot> []     ++ ys = ys
03:27:22 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
03:27:22 <lambdabot> -- OR
03:27:22 <lambdabot> xs ++ ys = foldr (:) ys xs
03:27:38 <Axman6> whereas (:) is O(1)
03:27:47 <mm_freak> (++) is O(1), too
03:27:58 <mrack> Guest15819: lists in haskell are singly linked lists. appending an element means you have to iterate through all the elements
03:28:19 <jle`> hm. how is (++) O(1) if it has to clone and modify every element of the first list?
03:28:31 <jle`> wlel if you have the same use case as (:) then it's O(1) because you only have one element
03:28:31 <mm_freak> jle`: why does it have to clone?
03:28:38 <Lethalman> for one element, [x] ++ y is the same as x:y
03:28:50 <jle`> mm_freak: well, if you are appending two already made lists
03:29:02 <Philonous_> jle`, To compare it with (:) you have to consider the case where the left list has one element. And that's cheap.
03:29:14 <jle`> conceded
03:29:31 <mm_freak> jle`: try this:  print ([1..100000] ++ [100001..200000])
03:29:37 <mm_freak> compare:  print [1..200000]
03:29:47 <mm_freak> you should find that they perform about equally well
03:29:55 <mm_freak> and this is not an optimization
03:30:06 <jle`> oh
03:30:08 <jle`> i see
03:30:15 <jle`> it's from the implementation of (++)
03:30:23 <jle`> ?
03:30:27 <mm_freak> (++) is implemented straightforwardly
03:30:30 <mrack> fixing the number of elements when talking about big-O notation is kinda weird
03:30:36 <k00mi> mm_freak: that's a rather special case though
03:30:38 <jle`> well
03:30:46 <jle`> if you unfold what's actually happening
03:30:55 <mm_freak> k00mi: the point is that people misunderstand that (++) would be "inefficient"
03:30:57 <jle`> all referential transparency-like
03:31:13 <mm_freak> for example (++) for Text is in fact inefficient and O(n)
03:31:20 <mm_freak> (or rather (<>))
03:31:34 <jle`> then if you just follow (++)'s implementation straightforwardly (along with : and []) then you see why they are identical-ish
03:31:37 <Guest15819> if i implement map with foldl and foldr, is the performance of both the same?
03:31:51 <mm_freak> (++) doesn't do much…  it pretty much only replaces the last link of a list and is only present until you reach it
03:32:04 <mm_freak> from then on it performs like the right list
03:32:07 <jle`> well if you want to use the first part of the list
03:32:10 <jle`> elsewhere
03:32:13 <jle`> and not throw it away
03:32:18 <jle`> you have to have two copies of it in memory
03:32:23 <mm_freak> viewing lists as automata helps understanding why (++) isn't that bad =)
03:32:36 <mm_freak> jle`: no, you don't
03:32:36 <aleksejs_> > (+2) 3
03:32:37 <aleksejs_> > (-2) 3
03:32:38 <lambdabot>  can't find file: L.hs
03:32:38 <lambdabot>  5
03:32:45 <aleksejs_> > (-2) 3
03:32:47 <mm_freak> jle`: you're presupposing a certain application of the result list
03:32:47 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
03:32:47 <lambdabot>    arising from the ambiguity check for `e_123'
03:32:47 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
03:32:47 <lambdabot>    bound by the inferred type for `e_123':
03:32:47 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
03:32:52 <aleksejs_> why?
03:33:16 <jle`> aleksejs_: - is a magic unary operator
03:33:17 <FireFly> >(subtract 2) 3
03:33:20 <FireFly> > (subtract 2) 3
03:33:21 <lambdabot>  1
03:33:27 <jle`> mm_freak: ah
03:33:43 <FireFly> aleksejs_: -2 is parsed as a number literal
03:33:47 <jle`> i guess reasoning about performance in haskell is tricker than a naive analysis admits.
03:33:52 <Axman6> > (- 2) 3
03:33:53 <FireFly> > let x = -2 in x 3  -- same error
03:33:53 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
03:33:53 <lambdabot>    arising from the ambiguity check for `e_123'
03:33:53 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
03:33:53 <lambdabot>    bound by the inferred type for `e_123':
03:33:53 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
03:33:55 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> t))
03:33:57 <lambdabot>    arising from the ambiguity check for `e_123'
03:33:59 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
03:34:01 <lambdabot>    bound by the inferred type for `e_123':
03:34:03 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
03:34:06 <FireFly> >.<
03:34:40 <jle`> FireFly: it's not always parsed as a number literal though
03:34:41 <Guest15819> so is this implementation map f xs = foldr (\x acc -> f x : acc) [] xs more efficient than map f xs = foldl (\acc x -> acc ++ [f x]) [] xs?
03:34:42 <notdan> the unary - is confusing
03:34:45 <mm_freak> jle`: for example this is absolutely fine:  scanl (+) 2 ([1,2,2,4] ++ cycle [2,4])
03:34:47 <jle`> it's kinda weird
03:34:50 <jle`> for example
03:34:52 <notdan> I like the SML's approach better
03:34:54 <FireFly> mm_freak: ++ requires you to go down the whole list though, no?
03:34:55 <mm_freak> jle`: and about as fast as it can get
03:34:55 <jle`> > (+) -2 3
03:34:56 <lambdabot>  Could not deduce (GHC.Num.Num
03:34:56 <lambdabot>                      (GHC.Integer.Type.Integer -> a -> a -> a))
03:34:56 <lambdabot>    arising from the ambiguity check for `e_123'
03:34:56 <lambdabot>  from the context (GHC.Num.Num (a -> a -> a),
03:34:56 <lambdabot>                    GHC.Num.Num a,
03:35:00 <mm_freak> FireFly: sure
03:35:09 <notdan> > (+) (-2) 3
03:35:10 <lambdabot>  1
03:35:11 <FireFly> compared to prepending an element, which wouldn't require that
03:35:17 <mm_freak> FireFly: that's the nature of appending to a list, /if/ you ever actually append
03:35:24 <FireFly> Yeah
03:35:32 <mm_freak> consider this:
03:35:38 <jle`> lazy evaluation is like, crazy though.
03:35:38 <mm_freak> > scanl (+) 2 ([1,2,2,4] ++ cycle [2,4])
03:35:39 <lambdabot>  [2,3,5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,7...
03:35:53 <jle`> now i have to question everything i read from Okasaki
03:35:55 <mm_freak> that's a totally valid way to have a very fast prime-candidate generator
03:36:08 <mrack> Guest15819: it is both more efficient and more correct, because it will handle infinite lists
03:36:10 <FireFly> Guest15819: I'm not sure about efficiency, but consider that the foldl approach would work properly with infinite arrays (like the built-in map does)
03:36:18 <FireFly> er, lists*
03:36:23 <mauke> why the extra 2,4?
03:36:23 <ocharles> oh mm_freak, did you get round to reviewing my patches for netwire btw?
03:36:34 <mm_freak> mauke: historical reasons
03:36:44 <mrack> FireFly: you mean that foldr would work with infinite lists
03:36:49 <FireFly> Oh
03:36:55 <mm_freak> ocharles: gimme a minute, i'll do it now
03:36:55 <FireFly> I always mix them up :(
03:37:06 <mauke> FireFly: foldr is the right one
03:37:06 <ocharles> mm_freak: k, no rush - i'm about to take a shower anyway
03:37:07 <mrack> @src map
03:37:07 <lambdabot> map _ []     = []
03:37:07 <lambdabot> map f (x:xs) = f x : map f xs
03:37:20 <mrack> @src foldr
03:37:20 <lambdabot> foldr f z []     = z
03:37:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:37:52 <mauke> :t \f -> foldr ((:) . f) []
03:37:52 <lambdabot> (a -> b) -> [a] -> [b]
03:38:47 <Guest15819> mrack: if i am working only with finite lists, then are both implementations the same
03:41:07 <mm_freak> ocharles: i've merged your instances
03:41:58 <mm_freak> ocharles: for the other patches i have to make sure that they don't violate FRP
03:42:17 <mm_freak> edge is particularly dangerous, and it's also not the 'edge' i had in mind =)
03:42:45 <mm_freak> ocharles: 'alternate' has a confusing name, because it does not alternate, it restarts
03:43:37 <mm_freak> ocharles: finally integralWith…  i have to think about how to provide a convenience wrapper
03:43:58 <aleksejs_> how to convert string "\"aaa\",\"bbb\"" to ["aaa","bbb"]
03:45:40 <mm_freak_> ocharles: not sure how much you received, so i'll repeat it all in /query again =)
03:45:43 <jeronimo> wha tis the purpose of System.Win32 and Graphics.Win32, internal use for ghc, or it it meant to be used by users as well?
03:47:50 <donri> the Win32 package is meant to be used by users on the windows platform, or for portable libraries with build conditionals
03:48:35 <randomclown> I used to be afraid of IO
03:49:12 <jeronimo> I tried to use two functions, SetForegroundWindow and findWindow. first does not exist, and second one does not provide full functionality of the function it wraps
03:49:25 <jeronimo> s/Set/s
03:49:32 <jeronimo> +et
03:51:19 <jeronimo> FindWindow can accept NULL as either class of text in C, so in haskell it should have been findWindow :: (Maybe String) -> (Maybe String) -> #haskell IO (Maybe HWND)
03:51:54 <randomclown> jeronimo: at this point you curse the library author, and get down dirty with FFI
03:52:06 <randomclown> most API bindings are pretty half-assed
03:52:46 <jeronimo> I guess I will have to
03:53:35 <randomclown> @pl \x -> x + 1
03:53:35 <lambdabot> (1 +)
03:53:39 <randomclown> oh what
03:53:51 <Philonous_> I wonder whether it would be useful to be able to attach an "internal" keyword to a module declaration. A module so annotated could only be imported in the same package or (conveniently) by attaching the same keyword to the import declaration
03:57:30 <Axman6> Philonous_: Cabal sort of lets you do that, you can specify modules that are needed but not exported
03:57:43 <Axman6> often used for .Internal modules
03:57:53 <Philonous_> Axman6, The whole point of the exercise is to be able to import them anyway
03:59:49 <aleksejs_> how to deal with this error? Couldn't match expected type `Data.Text.Internal.Text'
03:59:49 <aleksejs_>                 with actual type `String'
04:00:13 <Philonous_> aleksejs_, import Data.Text and use pack
04:00:40 <Philonous_> aleksejs_, When it's a string literal you can also add {-# LANGUAGE OverloadedStrings #-} to the top of your file
04:00:58 <aleksejs_> I did
04:01:18 <Philonous_> Can you put the code into a gist/pastebin?
04:01:23 <Philonous_> @where hpaste
04:01:24 <lambdabot> http://lpaste.net/new/haskell
04:01:32 <aleksejs_> problem was that I've imported like this "import Data.Text (splitOn)"
04:01:49 <Philonous_> aleksejs_, You need to add pack to the import list and apply it to the string.
04:02:27 <Philonous_> As in "import Data.Text (splitOn, pack)" and "foo (pack mystring)"
04:04:19 <aleksejs_> Philonous_, http://vpaste.net/Y83nk
04:05:35 <Philonous_> aleksejs_, in the last line, replace names with (T.pack names)
04:06:27 <ocharles> mm_freak_: ok, I thought you might have concerns on the actual functions I added :)
04:06:59 <ocharles> integralWith I'm not too bothered about - edge and alternate I do think are useful - though I agree the restarting in alternate is a bit odd
04:07:08 <ocharles> animation in general is tricky in netwire because I always want restarting
04:07:20 <Axman6> are there any parser libraries for bytestrings that are also monad transformers? I need to be able to mutate a vector while parsing the input
04:07:38 <Axman6> and use that vector while parsing (so I want to be able to use ST)
04:08:25 <Axman6> I could probably hack together something using attoparsec, but it would definitely feel like a hack afaict
04:08:57 <Philonous_> Axman6, parsec?
04:09:00 <mm_freak_> ocharles: (-->) is restarting
04:09:04 <mm_freak_> and it's right-associative
04:09:10 <Philonous_> Axman6, It can handle bytestrings AFAIK.
04:09:15 <Axman6> Philonous_: performance is also an issue
04:09:21 <mm_freak_> ocharles: w = w1 . p --> w2
04:09:25 <ocharles> mm_freak_: I know
04:09:33 <ocharles> it's just a bit more fiddly to use with events
04:09:40 <aleksejs_> Philonous_, thanks!
04:09:54 <ocharles> frame <- alternate (pure idleFrame) (cycleFrames running) -< ((), idleStateChange)
04:09:55 <ikv> if i'm getting a segfault from a third-party lib, how do i debug that?
04:09:58 <ocharles> That's what I'm using at the moment
04:10:03 <ocharles> where idleStateChange <- edge (/= 0) -< xVelocity
04:10:30 <mm_freak> ocharles: the problem with edge is that it certainly violates FRP
04:10:40 <mm_freak> see how edge is defined in yampa
04:10:48 <mm_freak> that's the edge i wanted to write =)
04:10:52 <ocharles> ok, let me check that out
04:11:01 <aleksejs_> Philonous_, and how to convert it back to [Char] ?
04:11:17 <Philonous_> aleksejs_, T.unpack
04:11:44 <ocharles> mm_freak: that looks like the edge that only triggers when the predicate becomes true
04:12:31 <ocharles> though I can't easily read the Yampa source - I don't know what sscanprim is
04:13:04 <Philonous_> aleksejs_, Note that there is also the split package that has splitOn for Strings: http://hackage.haskell.org/package/split
04:13:17 <Philonous_> So you don't need to keep converting back and forth
04:13:19 <mm_freak> ocharles: that's correct
04:13:29 <mm_freak> but note that the predicate is a behavior
04:13:36 <mm_freak> it's already continuous-time
04:14:38 <ocharles> ok, I get that... but I don't see how I can then go back to idling when the velocity is 0
04:14:51 <ocharles> unless I write two edges that compliment each other
04:15:06 <skypers> hi
04:15:07 <aleksejs_> Philonous_, yes, I saw that package, but I wanted to make it with internal packages
04:16:20 <skypers> do you know a function (a -> a -> b) -> [a] -> [b] that given a list apply a function to the first and second, then second to third, then…, and yields the corresponding list?
04:16:45 <aleksejs_> scanl ?
04:16:50 <skypers> :t scanl
04:16:51 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
04:16:57 <skypers> nope
04:17:05 <skypers> I don’t want accumulater
04:17:08 <skypers> s/e/o
04:17:19 <skypers> @hoogle (a -> a -> b) -> [a] -> [b]
04:17:19 <lambdabot> Prelude scanl1 :: (a -> a -> a) -> [a] -> [a]
04:17:19 <lambdabot> Data.List scanl1 :: (a -> a -> a) -> [a] -> [a]
04:17:19 <lambdabot> Prelude scanr1 :: (a -> a -> a) -> [a] -> [a]
04:17:27 <skypers> damn
04:17:29 <aleksejs_> :)
04:17:30 <ocharles> :t iterate
04:17:30 <lambdabot> (a -> a) -> a -> [a]
04:17:35 <ocharles> oh, not that
04:17:35 <skypers> it doesn’t exist?
04:18:19 <ocharles> :t \xs -> zipWith (uncurry f) xs (tail xs)
04:18:19 <lambdabot> (Show a, Show b, FromExpr c) => [(a, b)] -> [c]
04:18:34 <ocharles> not quite what I meant :)
04:18:39 <skypers> :D
04:18:44 <skypers> I’m going to write it down
04:18:47 <aleksejs_> scanl head tail
04:18:59 <ocharles> :t \xs -> zipWith f xs (tail xs)
04:19:00 <lambdabot> (Show b, FromExpr c) => [b] -> [c]
04:19:08 <ocharles> :t \f xs -> zipWith f xs (tail xs)
04:19:09 <lambdabot> (b -> b -> c) -> [b] -> [c]
04:19:14 <ocharles> I think that's what you want, skypers
04:19:17 <jle`> yeah it's the same principle as a diff list
04:19:20 <skypers> ok wait
04:19:23 <skypers> oh
04:19:24 <jle`> er
04:19:26 <jle`> list diff
04:19:32 <jle`> except insteadof (-), an arbitrary function
04:19:33 <skypers> zipWith x (tail x)
04:19:36 <skypers> nice idea
04:19:39 <ocharles> :t let thingy f xs = zipWith f xs (tail xs) in thingy (+) [0..5]
04:19:39 <skypers> :)
04:19:40 <lambdabot> (Enum c, Num c) => [c]
04:19:43 <ocharles> argh
04:19:43 <skypers> thank you
04:19:46 <ocharles> > let thingy f xs = zipWith f xs (tail xs) in thingy (+) [0..5]
04:19:47 <lambdabot>  [1,3,5,7,9]
04:20:04 <skypers> :t f
04:20:05 <lambdabot> FromExpr a => a
04:20:10 <skypers> what is that?
04:20:11 <skypers> id?
04:20:58 <ocharles> I think that's lambdabot's expression showing thing
04:21:10 <ocharles> map f [0..5]
04:21:12 <ocharles> > map f [0..5]
04:21:13 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr b0)
04:21:13 <lambdabot>    arising from a use of `e_105'
04:21:13 <lambdabot>  The type variable `b0' is ambiguous
04:21:13 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
04:21:13 <lambdabot>  Note: there are several potential instances:
04:21:18 <ocharles> -_-
04:21:32 <skypers> > let x = [1..5] in all (==zipWith compare x (tail x)
04:21:33 <lambdabot>  <hint>:1:52:
04:21:33 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
04:21:35 <skypers> oops
04:21:55 <skypers> > let x = [1..5] in all (==GT) $ zipWith compare x (tail x)
04:21:56 <lambdabot>  False
04:22:02 <skypers> > let x = [1..5] in all (==LT) $ zipWith compare x (tail x)
04:22:03 <lambdabot>  True
04:22:12 <skypers> > let x = [1,2,5,2] in all (==LT) $ zipWith compare x (tail x)
04:22:13 <lambdabot>  False
04:22:15 <skypers> \m*
04:22:58 <skypers> I wonder how I could stop the computation when it’s done
04:23:08 <skypers> well here laziness is my friend
04:23:58 <Axman6> skypers: and $ zipWith (<) x (tail x) -- how about that?
04:25:11 <skypers> Axman6: even better!
04:25:15 <skypers> and stops?
04:25:21 <skypers> yeah sure it does
04:25:23 <skypers> thank you!
04:26:17 <jeronimo> how does this work? iI can't wrap my head around it.
04:26:31 <jeronimo> > let xs = 1 : map (*2) xs in xs
04:26:32 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:26:46 <skypers> well
04:26:53 <skypers> it’s a recursive definition
04:27:07 <jle`> jeronimo: try expanding it out
04:27:13 <jle`> by substitution
04:27:19 <benmachine> jeronimo: when you want to print out the list, you first need to know the first element of the list, you can easily see that that's 1
04:27:20 <jle`> kind of like in math
04:27:36 <benmachine> the second element of the list is the first element of map (*2) xs
04:27:45 <Philonous_> aleksejs_, Well, Data.Text comes from that text library. So it's not bundled with ghc, either
04:27:47 <skypers> > 1: fix (map (*2))
04:27:51 <lambdabot>  mueval-core: Time limit exceeded
04:28:03 <benmachine> > fix ((1 :) . map (*2))
04:28:04 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
04:28:13 <skypers> ahah
04:28:18 <skypers> I always suck at that…
04:28:22 <benmachine> but we already know that the first element of xs is 1, so the first element of map (*2) xs is 2
04:28:51 <jeronimo> and the 2nd element map uses is 2?
04:28:58 <benmachine> right
04:29:02 <benmachine> it goes something like
04:29:25 <jle`> @src map
04:29:25 <lambdabot> map _ []     = []
04:29:25 <lambdabot> map f (x:xs) = f x : map f xs
04:29:28 <benmachine> xs -> 1 : map (*2) xs -> 1 : map (*2) (1 : map (*2) xs) -> 1 : 2 : map (*2) (map (*2) xs)
04:29:30 <aleksejs_> Philonous_, I mean it comes with default ghc installation
04:30:06 <benmachine> -> 1 : 2 : map (*2) (map (*2) (1 : map (*2) xs)) -> ...
04:31:06 <jeronimo> I see.. I thought it is just one map that always trails one element behind xs.. now I am confused again
04:32:26 <jle`> you can do a lot with just equational reasoning
04:33:16 <jle`> but basically in Haskell
04:33:21 <jle`> it does the expanding as much as it needs to
04:33:59 <jle`> and when you print something out, you only need it one element at a time, so as benmachine demonstrated, you can get the elements one-by-one as you are expanding it out
04:41:17 <pingu> Hey guys, does this thing have a name?
04:41:21 <pingu> :t (.).(.)
04:41:22 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:41:28 <prophile> the owl operator
04:41:57 <Cale> it can be generalised to fmap . fmap
04:41:59 <skypers> :t (.:)
04:42:00 <lambdabot>     Not in scope: `.:'
04:42:00 <lambdabot>     Perhaps you meant one of these:
04:42:00 <lambdabot>       `.' (imported from Data.Function),
04:42:00 <Cale> :t fmap . fmap
04:42:01 <lambdabot> (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:43:16 <pingu> Oh god. Googling the owl operator yields:
04:43:25 <pingu> > ((.)$(.)) (==) 1 (1+) 0
04:43:26 <lambdabot>  True
04:43:53 <pingu> One day, I may find a use for this.
04:44:20 <Twey> :t ((.)$(.))
04:44:21 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
04:44:29 <Twey> What's so scary about it?  :þ
04:46:12 <skypers> @let loeb f = fmap ($ f)
04:46:13 <lambdabot>  Defined.
04:47:19 <skypers> @let
04:47:19 <lambdabot>  Define what?
04:47:24 <skypers> @unlet
04:47:24 <lambdabot>  Define what?
04:47:26 <pingu> I've actually used that one recently.
04:47:27 <skypers> DUH
04:48:11 <pingu> let strings = map ($ repeat 'A') (map (\n -> take n) [1..2048])
04:48:11 <benmachine> that's not loeb
04:48:27 <skypers> @let loeb f = fmap ($f) f
04:48:28 <lambdabot>  .L.hs:161:21:
04:48:28 <lambdabot>      Occurs check: cannot construct the infinite type:
04:48:28 <lambdabot>        a0 = f0 (a0 -> b0) -> a0 -> f0 b0
04:48:28 <lambdabot>      In the second argument of `fmap', namely `f'
04:48:28 <lambdabot>      In the expression: fmap ($ f) f
04:48:41 <skypers> @let loeb f = fmap (f$) f
04:48:42 <lambdabot>  .L.hs:161:21:
04:48:42 <lambdabot>      Occurs check: cannot construct the infinite type:
04:48:42 <lambdabot>        b0 = (f0 b0 -> f0 b0) -> b0
04:48:42 <lambdabot>      Expected type: f0 ((f0 b0 -> f0 b0) -> b0) -> f0 b0
04:48:42 <lambdabot>        Actual type: f0 b0 -> f0 b0
04:48:50 <skypers> hey ho, you annoy me lambdabot
04:48:56 <benmachine> neither are those
04:48:59 <benmachine> why not just look it up?
04:49:00 <mauke> @undefine
04:49:00 <lambdabot> Undefined.
04:49:16 <pingu> could I have used any of these combinators to write that more nicely?
04:49:19 <pingu> That being:
04:49:20 <pingu> let strings = map ($ repeat 'A') (map (\n -> take n) [1..2048])
04:49:55 <mauke> :t \x -> fix (\r -> fmap (\f -> f r) x)
04:49:56 <pingu> > take 4 $ map ($ repeat 'A') (map (\n -> take n) [1..2048])
04:49:56 <lambdabot> Functor f => f (f b -> b) -> f b
04:49:57 <lambdabot>  ["A","AA","AAA","AAAA"]
04:50:26 <mauke> > iterate ('A' :) ""
04:50:27 <lambdabot>  ["","A","AA","AAA","AAAA","AAAAA","AAAAAA","AAAAAAA","AAAAAAAA","AAAAAAAAA",...
04:50:43 <mauke> @pl \x -> fix (\r -> fmap (\f -> f r) x)
04:50:43 <lambdabot> fix . flip (fmap . flip id)
04:50:49 <pingu> ... right. That's a little simpler.
04:54:57 <Hafydd> > inits $ repeat 'A'
04:54:58 <lambdabot>  ["","A","AA","AAA","AAAA","AAAAA","AAAAAA","AAAAAAA","AAAAAAAA","AAAAAAAAA",...
04:55:23 <mauke> that looks less efficient
04:55:51 <Hafydd> Yes, I suppose it is.
04:58:46 <pingu> This leads me to question lots of odd things I've done. For example, I went a bit insane the other day and wanted to place my first arguments at the end.
04:59:00 <pingu> So I invented a flip6, being
04:59:07 <pingu> flip6 :: (a -> b -> c -> d -> e -> f -> g) -> f -> a -> b -> c -> d -> e -> g
04:59:07 <pingu> flip6 = flip . (flip5 .)
04:59:12 <pingu> flip5 = flip . (flip4 .)
04:59:16 <pingu> so on, so forth
04:59:47 <TovenaarKlus> pingu: couldn't that be written as an universal flip?
05:00:02 <pingu> Then I could get the first two arguments to the end, via a (flip6 . flip6)
05:00:29 <pingu> TovenaarKlus: I don't know what that is. It seems a little dumb too me.
05:00:36 <pingu> But it saved me a lot of typing at the time.
05:01:19 <pingu> TovenaarKlus: my flip6 seems a little dumb, that is.
05:01:42 <TovenaarKlus> pingu: something like myFlip 2 = flip, and myFlip n = flip . myFlip (n-1)
05:02:10 <pingu> TovenaarKlus: how would that type check?
05:04:05 <TovenaarKlus> pingu: myFlip :: (Eq a, Num a) => a -> (a1 -> a1 -> c) -> a1 -> a1 -> c
05:04:53 <TovenaarKlus> However I just realize that function works somewhat different from yours. Hold on.
05:05:55 <mekeor> i've once asked this question but i forgot its answer: is there a language extension allowing "case of" to mean "\x -> case x of"?
05:06:57 <mekeor> mekeor: https://ghc.haskell.org/trac/ghc/wiki/LambdasVsPatternMatching#LambdaCase:caseof
05:07:09 <mekeor> mekeor: did you even google it? wtf, dude! be ashamed!
05:08:08 <pingu> mekeor: leave mekor alone
05:08:19 <Node_671> Hi. What CPU Architecture does ghc support.Coudnt find any info on that. Thanks.:)
05:08:20 <Axman6> what's the best choice for a mutable vector of Word8 whose size I know ahead of time, and will need to have ByteStrings written to efficiently? Vector? Perhaps something in ByteString?
05:08:47 <mekeor> mekeor: -XLambdaCase
05:09:21 <Ke> Node_671: https://ghc.haskell.org/trac/ghc/wiki/Platforms
05:09:32 <Axman6> also need to be able to read from the vector to write data to the end of the already written data (for a decompressor for LZ4)
05:09:38 <Ke> assuming someone still updates that
05:09:50 <Node_671> Thanks. Ke:)
05:09:51 <pingu> Axman6: you are writing a decompressor for LZ4?
05:10:08 <pingu> Does this by any chance have anything to do with the new streaming protocol?
05:10:09 <Axman6> yes
05:10:26 <Axman6> nope, but I'll hopefully implement that too
05:10:39 <pingu> Because I was going to work on that but it seemed like a bit too much work to justify.
05:10:41 <Axman6> just trying to figure out how to decode a chunk to begin with
05:10:54 <Axman6> it's help if the docs were better written
05:10:54 <pingu> Axman6: You are obviously aware of lz4hs, yeah?
05:10:58 <Axman6> it'd*
05:11:06 <Axman6> yes, I wanted a haskell implementation
05:11:27 <pingu> Awesome. I just implemented a haskell xxhash in order to get around to a pure lz4 impementation.
05:11:35 <pingu> (xxhash is required for the streaming protocol)
05:11:40 <pingu> Which I would like.
05:12:03 <Axman6> I thought there was already one listed on the xxHash google code page
05:12:22 <pingu> Listed yesterday? I wrote that yesterday.
05:12:32 <Axman6> heh, ok :)
05:13:25 <pingu> Axman6: so to get performance out of bytestrings I've been using inlinepeformIO.
05:13:27 <TovenaarKlus> pingu: Right, I guess we need a clever workaround to get that working with the type system.
05:13:36 <pingu> With unboxed data types.
05:13:55 <pingu> TovenaarKlus: yeah, I was just wondering if that was already defined somewhere. Hoogle wasn't much help.
05:14:18 <pingu> Axman6: um, strict, unpacked data types I mean.
05:14:35 <Axman6> right
05:15:12 <pingu> Axman6: I'm not sure how well stream fusion works on bytestrings, but that might help also. I think that if you get the algorithm and protocol working, we can optimize it just fine.
05:15:39 <Axman6> well I'm just trying to figure out how to copy a ByteString into a MVector MVector Word8 at the moment
05:16:55 <Axman6> ah, vector-bytestring
05:17:09 <Axman6> hmm, maybe...
05:17:33 <pingu> Axman6: maybe...
05:18:17 <aristid> Axman6: if it's a storable vector... http://hackage.haskell.org/package/spool ?
05:18:38 <aristid> i believe vector-bytestring aims to replace bytestring completely
05:18:46 <Axman6> yeah it does
05:19:09 <Axman6> I want to be able to write a ByteString into a mutable Vector Word8
05:19:19 <Axman6> spool looks useful...
05:19:40 <aristid> does vector have functions for directly writing from C pointers?
05:19:43 <pingu> They just pass the foreign ptr around, looks like.
05:21:09 <aristid> Axman6: if you don't want a package dependency, just using this directly might work too: http://hackage.haskell.org/package/vector-0.10.9.1/docs/Data-Vector-Storable-Mutable.html#g:14
05:21:40 <aristid> the non-Mutable API also has those functions
05:22:23 <pingu> Axman6: if you just need to poke at various offsets, you can actually just take the bytestring apart yourself and poke at it like I do here:
05:22:25 <pingu> https://github.com/christian-marie/xxhash/blob/master/src/Data/Digest/XXHash.hs
05:22:44 <Axman6> heh, I happened to already have that page open =)
05:22:44 <pingu> A vector would certainly be safer and nicer though, if you have anything more complex to do.
05:23:51 <pingu> I only used that there because I want a really tight loop with inlinePerformIO updating the hash context. You may or may not be able to get that with a storable vector also.
05:24:42 <aristid> storable vectors and bytestrings are basically implemented the same way
05:25:45 <peteretep> I have some vectors, who are questionably stored as [Bool]. I wish to pack these in to ByteString's
05:26:07 <peteretep> I was going to convert the [Bool] to [Char], and then just use pack
05:26:10 <aristid> peteretep: with one bit per bool, or one byte per bool?
05:26:17 <peteretep> One bit per Bool
05:26:17 <aristid> to Word8 please
05:26:31 <aristid> i think you should also use vector, not bytestring
05:26:36 <aristid> Vector Word64
05:26:41 <peteretep> I need  ByteString for the final plan
05:26:47 <aristid> do you?
05:26:49 <aristid> why?
05:26:55 <peteretep> Because the library I want to use is asking for one
05:27:14 <aristid> we were just talking about converting vectors to bytestrings
05:27:40 <peteretep> Yeah, but I'm not actually going to use the vector at any point, as everywhere else uses [Bool]
05:27:41 <pingu> Axman6: do you have code up anywhere yet?
05:27:42 <aristid> but sure that is a decent reason to use ByteString ;)
05:27:50 <peteretep> Which is a questionable and poor choice, but it is what it is
05:28:03 <aristid> peteretep: it was not your choice to use [Bool]?
05:28:31 <peteretep> I am working through the Matasano crypto challenges, and I thought it would be more fun to test my knowledge of how to convert nicely between encodings
05:28:40 <peteretep> So I chose to build on [Bool] rather than to use any libraries
05:28:47 <peteretep> It was a good choice for a learning experience
05:28:57 <benmachine> there are nice things about [Bool]
05:29:16 <aristid> information density is not one of them
05:29:32 <benmachine> the drawbacks being that it uses an order of magnitude more space than it needs to
05:29:35 <peteretep> Neither is speed, but ...
05:29:42 <benmachine> yeah
05:29:46 <benmachine> oh well!
05:29:50 <aristid> it also doesn't have random access
05:29:55 <peteretep> So I am trying to define: asByteString :: [Bool] -> B.ByteString
05:30:00 <benmachine> anyway, Word8 is a better intermediary than Char
05:30:01 <peteretep> And have: asByteString = B.pack . bool2asc
05:30:21 <benmachine> ByteStrings are not strings of characters, despite what the Char8 modules will try to pretend
05:30:23 <aristid> i think actually Word32/64 is a better intermediary even with ByteString
05:30:32 <aristid> bytestring's Builder should make it easy
05:30:40 <benmachine> aristid: ah, interesting
05:30:42 <peteretep> aristid: Let me take a look at that
05:31:24 <aristid> not that it really matters:D
05:31:35 <peteretep> Really, what I am looking for is [Bool] -> Word8
05:31:45 <peteretep> And I can't find documentation for how to construct Word8's
05:31:53 <aristid> Word8 is just a number
05:31:55 <peteretep> Quite possibly I am looking in the wrong place
05:31:58 <aristid> > (4 :: Word8)
05:31:59 <lambdabot>  4
05:32:01 <peteretep> ah
05:32:02 <peteretep> ah ha
05:32:03 <peteretep> ok
05:32:06 <peteretep> this is easy then
05:32:11 <aristid> yup
05:32:46 <benmachine> Data.Bits may be useful to you
05:32:49 <peteretep> That makes sense too, relooking at the docs
05:32:50 <benmachine> as well
05:33:06 <benmachine> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bits.html
05:34:18 <Axman6> pingu: not yet
05:38:25 <matheus23> > (255 :: Word8)
05:38:26 <lambdabot>  255
05:38:31 <matheus23> > (256 :: Word8)
05:38:32 <lambdabot>  0
05:38:38 <Happy0> :o
05:38:46 <hpc> > 127 :: Int8
05:38:47 <lambdabot>  127
05:38:50 <hpc> > 128 :: Int8
05:38:51 <lambdabot>  -128
05:38:54 <Happy0> o:
05:42:08 <mekeor> i can't write a function "maybeRead :: Read t => String -> Mabye t", right?
05:42:23 <katana-> yes you ca
05:42:27 <mekeor> how?
05:42:35 <hpc> :t reads
05:42:36 <lambdabot> Read a => ReadS a
05:42:42 <hpc> @src ReadS
05:42:42 <lambdabot> Source not found. And you call yourself a Rocket Surgeon!
05:42:45 <hpc> pah
05:42:49 <hpc> :t reads "()"
05:42:50 <lambdabot> Read a => [(a, String)]
05:42:54 <mekeor> i know, there is "any (null . snd) (reads word :: [(Double,String)])"
05:43:27 <mekeor> but there is a type signature. but i can't write "t" instead of "Double" in the type signature.
05:43:34 <hpc> you don't need to
05:43:35 <katana-> yes you can
05:43:38 <mekeor> how?
05:43:39 <mekeor> :O
05:43:51 <hpc> maybeRead :: Read t => String -> Maybe t
05:44:01 <hpc> maybeRead word = any (null . snd) (reads word)
05:44:15 <hpc> :t let maybeRead word = any (null . snd) (reads word) in maybeRead
05:44:16 <lambdabot>     No instance for (Read a0) arising from a use of `reads'
05:44:16 <lambdabot>     The type variable `a0' is ambiguous
05:44:16 <lambdabot>     Possible fix: add a type signature that fixes these type variable(s)
05:44:27 <mekeor> :t any
05:44:27 <lambdabot> (a -> Bool) -> [a] -> Bool
05:44:50 <hpc> er, that "any" there is wrong
05:44:53 <mekeor> yes.
05:44:57 <mekeor> find??
05:45:15 <hpc> :t let maybeRead word = case reads word of [(v, "")] -> Just v; _ -> Nothing
05:45:15 <lambdabot> <no location info>:
05:45:15 <lambdabot>     not an expression: `let maybeRead word = case reads word of [(v, "")] -> Just v; _ -> Nothing'
05:45:26 <hpc> :t let maybeRead word = case reads word of {[(v, "")] -> Just v; _ -> Nothing}
05:45:26 <lambdabot> <no location info>:
05:45:26 <lambdabot>     not an expression: `let maybeRead word = case reads word of {[(v, "")] -> Just v; _ -> Nothing}'
05:45:34 <hpc> :t let maybeRead word = case reads word of {[(v, "")] -> Just v; _ -> Nothing} in maybeRead -- pah
05:45:34 <lambdabot> Read a => String -> Maybe a
05:46:03 <mekeor> coooool! thank you very much!!!! – i was so desperate!! :)
05:48:28 <mekeor> awesome. :)   I ε> Haskel :)
05:48:49 <hpc> epsilon > haskell? that's a little mean ;)
05:48:59 <mekeor> :D
05:49:22 <ion> hpc: No, “I epsilon”
05:49:57 <hpc> I# epsilon?
05:52:58 <frx> mekeor take a look at safe package. http://hackage.haskell.org/package/safe
05:53:08 <mekeor> ('i·ε>haskell' would be invalid because complex numbers are not ordered)
05:54:22 <mekeor> frx: neat
05:56:39 <mm_freak> I ε-relates to Haskel under >
05:56:40 <mm_freak> =)
05:57:26 <mekeor> with the help of my typo "Haskel", i can see that you copied my ε :P
05:57:55 <mm_freak> it's about the only greek character not on my keyboard =P
05:58:42 <hpc> mm_freak: if you are on windows, use http://www.microsoft.com/en-us/download/details.aspx?id=21476
05:59:05 <hpc> you can even bind a key to a sequence of characters
06:00:18 <mekeor> i use emacs-erc as irc-client, and use the TeX-input-method. you can then type \epsilon and such :)
06:00:32 <mekeor> mekeor: → #-blah, please
06:00:50 <mm_freak> hpc: i'm on linux
06:01:09 <mm_freak> in fact the only true distribution for a haskell programmer: NixOS =)
06:01:20 <mekeor> neat :)
06:01:28 <mm_freak> mekeor: nice to know =)
06:01:30 <mm_freak> but i use irssi
06:01:42 <mm_freak> i suppose i could just write the key bindings
06:02:16 <mekeor> maybe they already exists somewhere in the worldwide web?
06:03:06 <mm_freak> since i don't use them that often…
06:03:50 <TovenaarKlus> mm_freak: NixOS actually looks quite nice. I should check it out sometime.
06:04:04 <mm_freak> =)
06:04:39 <mm_freak> mekeor: ∀ (c : Char). i use c often → i have c on my keyboard
06:04:40 <mm_freak> =)
06:04:41 <mekeor> mm_freak: when i tried nixos out, i didn't find it nice, actually. i didn't like to install haskell-packages via nix(-env). i found it quite messy
06:05:02 <mm_freak> mekeor: huh?
06:05:24 <mm_freak> mekeor: there are a number of ways to install haskell packages…  you can just install the haskell-platform and use cabal as you've used to
06:05:35 <mm_freak> but a much better approach is to use nix as your development platform
06:05:37 <mekeor> yeah
06:05:39 <mm_freak> this is what i do today
06:05:53 <mekeor> why is it better to use nix?
06:05:58 <pingu> Axman6: I'm off. I'd be interested in working with you on this over the next week or so if you would like.
06:06:33 <mm_freak> mekeor: because it's almost trivial to test your package against various version of packages, not to miss a distribution dependency, and deployment is a charm
06:06:59 <mm_freak> i'd even do development in other languages using nix
06:07:43 <mekeor> hm. i see.
06:07:57 <mm_freak> mekeor: also it solves dependency hell
06:07:59 <mekeor> you should write an article on how you do your development on nix.
06:08:09 <mm_freak> without making you recompile all dependencies all the time
06:08:20 <mm_freak> yeah
06:08:53 <mm_freak> mekeor: http://hub.darcs.net/ertes/config/skel/
06:09:05 <mm_freak> look into +name+.cabal.bob and Makefile.bob
06:09:11 <mm_freak> and of course default.nix
06:09:47 <mgsloan> Does it allow you to install a version of a package multiple times?  (with different dependency versions)  I think this could be a nice way out of cabal hell, though it's a bit tricky
06:10:39 <mm_freak> mgsloan: yes
06:10:51 <mgsloan> Wow, ok, yeah, nix style is the way to go
06:11:07 <mm_freak> even if i wouldn't use NixOS itself, i would still use nix for development
06:11:11 <mgsloan> RIght
06:11:22 <mm_freak> oh and yeah, you can install nix on other distributions as well
06:11:32 <mgsloan> It always did seem wierd to me that each language ends up creating it's own package manager
06:11:35 <mm_freak> i think arch linux has a package, at least in the AUR
06:11:39 <mgsloan> it's almost like a point of pride for the language
06:11:46 <mekeor> mm_freak: http://hub.darcs.net/ertes/config/browse/skel/+name+.cabal.bob ← 404
06:12:00 <mm_freak> mekeor: oh yeah, darcsden has a bug right now
06:12:11 <mm_freak> darcs get http://hub.darcs.net/ertes/config
06:12:12 <mekeor> darcsHUB :P
06:12:18 <mm_freak> mekeor: the software is darcsden
06:12:25 <mekeor> oh, okay :(
06:12:34 <mm_freak> /called/ darcsden
06:12:51 <mm_freak> http://hub.darcs.net/simon/darcsden/
06:13:02 <mgsloan> Instead of figuring out how to make cabal tell us about the problem (better diagnostics) or find the solution better (better search), the problem should just go away >.<
06:13:37 <mm_freak> mgsloan: nix doesn't actually replace cabal, it works together with cabal
06:13:44 <mm_freak> (for haskell packages, of course)
06:14:04 <mgsloan> Right, I know it's like apt / pacman / whatnot
06:14:22 <mgsloan> So you can actually use nix with cabal and that works?
06:14:52 <mgsloan> That's rather surprising to me - how do you determine which dependencies are used when building a package?
06:16:10 <mm_freak> mgsloan: by cabal's environment
06:16:34 <mm_freak> in nix a package doesn't even see the packages it doesn't have mentioned as its dependency
06:16:38 <mgsloan> Gotcha, which means it's upto you to pick that environment, or initialize a new one for building your package
06:18:46 <mm_freak> mgsloan: http://hub.darcs.net/ertes/netwire/browse/default.nix
06:19:01 <mm_freak> if you don't mention a package in buildDepends, cabal won't see it
06:19:09 <mm_freak> it sees exactly the environment you give it
06:19:50 <mm_freak> in fact you can have other packages in your user environment (where you run e.g. ghci) than in your project's cabal environment
06:20:02 <mm_freak> so they don't interfere
06:20:22 <mm_freak> this is what makes NixOS an amazing development and deployment platform, especially for haskell
06:20:33 <mgsloan> I see! very pretty
06:20:39 <Earnestea> shame about the duplication
06:20:51 <mgsloan> Could probably generate the .nix file from the .cabal
06:20:55 <mm_freak> you can
06:20:58 <mm_freak> cabal2nix =)
06:21:02 <mgsloan> :D
06:21:18 <mm_freak> i prefer to write it by hand though
06:29:10 <bennofs> mm_freak: why do you prefer to write it by hand?
06:32:00 <mm_freak> bennofs: because it's part of the build code and should follow a style i can understand and agree with
06:32:26 <mm_freak> just like i dislike generated makefiles and cabal files, i also dislike generated nix scripts
06:32:28 <bennofs> Ok, I found the files generated by cabal2nix pretty nice :)
06:32:42 <mm_freak> it's just a personal preference with no technical reason =)
06:38:16 <kfiz> :t map
06:38:17 <lambdabot> (a -> b) -> [a] -> [b]
06:40:22 <Twey> Oooh, NixOS looks much more friendly than I remember
06:40:38 <aristid> Twey: how so?
06:42:00 <Twey> aristid: Last I used it, it didn't really have support for package repositories — there was just a big configuration file with all the packages that you pulled from git
06:42:30 <Twey> Also it now has a GUI installation tool, apparently
06:43:07 <aristid> Twey: it has? hmm must be recent
06:43:24 <aristid> Twey: must be a while ago since you last used it, as channels exist for a long time now:)
06:43:36 <Twey> It was at least three years ago
06:43:38 <xcxvc> I'm parsing a 70000 line file. My code looks nearly like this: s <- readFile file, then map words $ lines s. command time reports 80%CPU. I'd like to reduce that. Should I try pipes or something like that?
06:43:57 <aristid> Twey: nixos also notably has pretty reasonable support for haskell stuff :D
06:44:03 <Twey> Indeed
06:44:17 <aristid> mostly thanks to peti
06:44:21 <Twey> I might make it my next distro
06:44:23 <earthy> xcxvc: start using lazy Bytestring rather than String.
06:44:41 <benmachine> Twey: I've been interested in it for ages but never got around to switching
06:44:49 <xcxvc> earthy: OK, will try that in a minute.
06:44:54 <benmachine> 'cause I'd have to delete Ubuntu to make room and I kep worrying I've forgotten something important
06:45:13 <aristid> benmachine: you mean important data?
06:45:23 <Twey> benmachine: I used it for a while in a VM (quite a long time ago), but I had trouble with some things like Unicode support that were blockers for me
06:45:34 <Twey> But it looks like it's much more polished now
06:45:48 <benmachine> aristid: "important" data
06:45:57 <benmachine> it's mostly just my paranoia, nothing I own is actually important :P
06:46:09 <Twey> Heh
06:46:10 <mm_freak> Twey: NixOS never had packages in the traditional sense, and it doesn't have them now
06:46:48 <aristid> benmachine: well, just make a copy of your complete hard drive to an external drive
06:46:54 <Philonous> xcxvc, Unless it's binary data you should probably use text rather than bytestring
06:46:56 <Twey> mm_freak: Expressions look quite a lot like (pure) ebuilds, from where I'm sitting
06:47:16 <Twey> I.E. a set of instructions to build a piece of software
06:47:21 <mm_freak> Twey: pretty much, except that you use a functional language
06:47:24 <Twey> Yeah
06:47:28 <mm_freak> the nix expression language looks a lot like haskell
06:47:30 <Twey> That's all I mean when I say ‘package’
06:47:56 <benmachine> why can't it just be actually-Haskell :P
06:48:21 <Twey> benmachine: IIRC it was considered and rejected
06:48:40 <Twey> The GNU guys are porting it to Guile, as ‘Guix’
06:48:43 <mm_freak> good question, i would have used a language that is closer to haskell
06:48:43 <bennofs> Twey: do you no why?
06:48:50 <Twey> Maybe we should have a similar effort
06:48:51 <bennofs> know*
06:49:04 <Twey> bennofs: I don't remember; it's in the original Nix paper
06:49:08 <nexx> Twey do you remember why?
06:49:09 <mm_freak> but it's fine…  nix works well for its limited use case
06:49:17 <Twey> Yeah
06:49:23 <mm_freak> it doesn't do a lot more than specifying dependencies and build recipes
06:49:41 <dreixel> anyone here with some happstack knowledge? I want to know how to have some sort of background process continuously running in my server, next to serving the HTTP requests.
06:49:51 <mm_freak> dreixel: forkIO
06:50:17 <dreixel> mm_freak: and that's safe even if it is updating the database?
06:50:31 <mm_freak> dreixel: if "the database" is built with acid-state, then yes
06:50:32 <aristid> dreixel: depends on the database
06:50:43 <dreixel> mm_freak: right, it's acid-state. thanks
06:50:54 <dreixel> cool. this is so easy, then :)
06:50:59 <mm_freak> dreixel: otherwise acid-state wouldn't deserve its name, would it? ;)
06:51:26 <dreixel> 8-)
06:51:28 <mm_freak> dreixel: also note that you are already using concurrency…  requests are handled concurrently in happstack
06:51:41 <dreixel> mm_freak: well, yeah, I was hoping there was some easy way to do this
06:51:47 <dreixel> just wasn't sure if forkIO was the right way to do it
06:54:43 <mm_freak> dreixel: forkIO is almost always the right way to do it…  sometimes you need forkOS, but that's only the case when you bind to a badly designed C library
06:55:42 <simon> I've made a couple of state-based simulators that all have [Int] as their memory array. what's a slightly more efficient alternative? read-only arrays?
06:56:10 <mm_freak> simon: Vector Int, if it's fixed
06:56:16 <simon> it is. thanks.
06:56:31 <mm_freak> simon: use the one from Data.Vector.Unboxed then
06:57:42 <simon> they're lazy, right?
06:58:22 <mm_freak> simon: what do you mean?
06:58:37 <mm_freak> simon: unboxed vectors are strict in that evaluating the vector evaluates all its elements
06:59:12 <simon> ah. then I understand the docstring for `indexM`.
06:59:23 <mm_freak> what's a docstring?
06:59:30 <simon> a string from the documentation :)
06:59:42 <mm_freak> ah
06:59:51 <mm_freak> you mean "the documentation" for indexM ;)
06:59:55 <simon> yes!
07:00:09 <xcxvc> bennofs: One of the reasons is that Nixpkgs contains non-free software.  Also, Guile is a general purpose language, so it's possible to reuse its libraries.  (NixOS uses Bash and Nix.)  I guess this talk should provide more information: http://audio-video.gnu.org/video/ghm2013/Ludovic_Courtes-GNU_Guix_the_computing_freedom_deployment_tool_.webm  There is also #guix on freenode.
07:01:20 <mm_freak> i wish GNU would work more closely with other communities
07:01:59 <aristid> is there a way in haskell for functions that take numeric arguments which are usually however compile-time constants, to get ghc to actually specialize the code to those constants?
07:02:54 <xcxvc> mm_freak: What do you mean by "work more closely"?  (Should we move to #haskell-blah?)
07:03:07 <mm_freak> aristid: if they are compile-time known, you could just as well pass them as types
07:03:15 <mm_freak> aristid: then it's possible
07:03:27 <aristid> mm_freak: how do i do that?
07:04:16 <mm_freak> xcxvc: well, the communities behind guix and nix seem separate and not very interested in communication…  but nevermind, i don't really want to join another channel =)
07:04:33 <aristid> civodul used to be a big contributor to nix
07:04:37 <aristid> IMHO it's a shame
07:04:42 * hackagebot bindings-mpdecimal 0.4.0.0 - bindings to mpdecimal library  http://hackage.haskell.org/package/bindings-mpdecimal-0.4.0.0 (OmariNorman)
07:04:59 <mm_freak> aristid: the usual type-level numbers stuff
07:05:06 <aristid> mm_freak: i'm not very solid on the DataKinds stuff
07:05:11 <mm_freak> aristid: ah
07:05:31 <mm_freak> in that case, you should write the function the following way:
07:05:39 <aristid> i just want a template<uint64_t bitMask> :)
07:05:40 <xcxvc> mm_freak: That's because the NixOS people don't care about freedom that much.
07:05:59 <mm_freak> aristid: myFunc n = case n of 1 -> func1; 2 -> func2; 3 -> func3
07:06:11 <mm_freak> aristid: then you can use sharing:  let func5 = myFunc 5 in …
07:06:17 <aristid> xcxvc: you can install nixos with a flag that disables all non-free software.
07:06:39 <aristid> mm_freak: there are 2^64 constants.
07:06:51 <aristid> mm_freak: i don't want to write every one of these functions! :)
07:06:56 <mm_freak> xcxvc: that's a bold and slightly offending statement…  i'm also NixOS people btw
07:07:32 <mm_freak> aristid: the point is that you should construct the function from the numeric argument
07:07:51 <aristid> mm_freak: i'm confused
07:08:13 <mm_freak> aristid: myFunc x = let y = x^30000000 in y `seq` (\z -> …)
07:08:30 <mm_freak> aristid: then you can do this:  let f = myFunc 5 in …
07:08:49 <mm_freak> the function f will then be memoized, including the y it computes
07:09:01 <aristid> mm_freak: but the generated code will not be specialized for the different x values?
07:09:12 <aristid> mm_freak: basically i don't want a memory call for the bitmask
07:09:21 <mm_freak> aristid: what does that even mean?  specialization doesn't make sense without type classes
07:10:06 <aristid> mm_freak: do you know enough c++ to follow this? template<uint32_t bitMask> void foo() { ... int x = y & bitMask; ... }
07:10:08 <mm_freak> aristid: y won't be calculated at compile time
07:10:20 <mm_freak> not sure how much you can control compile time calculation
07:10:28 <mm_freak> yes, i understand the code
07:10:42 <aristid> so this is something that is not easily possible in haskell?
07:10:46 <mm_freak> haskell doesn't use type instantiation, it uses boxing
07:10:52 <aristid> i had feared that, but was hoping i was missing something :)
07:11:11 <aristid> mm_freak: often boxing is better, but sometimes instantiation is :)
07:11:14 <mm_freak> so unless there is another compiler feature (look into the command line flags and pragmas), this is impossible
07:11:21 <aristid> and SPECIALIZE allows you do to the latter
07:11:24 <aristid> but not with numbers
07:11:37 <mm_freak> SPECIALIZE may not do what you think it does
07:12:01 <mm_freak> it's basically preapplying the dictionary implicit argument and runs the optimizations this triggers
07:12:19 <mm_freak> in a sense it removes an implicit lambda abstraction
07:12:40 <mm_freak> in other words, SPECIALIZE is not the same thing as C++ template instantiation
07:12:52 <aristid> mm_freak: but the effect should be pretty similar, no?
07:13:16 <mm_freak> the effect of SPECIALIZE is pre-applied functions and thus faster code
07:13:27 <mm_freak> the effect of template instantiation is to produce code in the first place ;)
07:13:33 <simon> mm_freak, and I need a boxed vector for algebraic types?
07:13:41 <mm_freak> note that one is an optimization, the other is a compilation strategy
07:13:44 <aristid> yes, so the logical thing to do would be to use TH for my purpose, eh? :P
07:13:48 <aristid> or accept slower code
07:14:09 <mm_freak> simon: depends on the algebraic type…  for recursive types you definitely need boxed vectors
07:14:15 <aristid> or hope that GHC inlines everything and is able to see the constants as constant
07:14:45 <mm_freak> simon: for non-recursive types (which you can represent in a fixed-length memory region), you can write the Unbox instance
07:15:08 <mm_freak> aristid: the code doesn't have to be slower
07:15:24 <mm_freak> aristid: generally sharing will make sure that something is computed only once
07:15:44 <mm_freak> for reliable compile time computation you would indeed need TH or QQ
07:16:32 <aristid> mm_freak: so i'm going over this huge vector with that bitmask. i was hoping to have it straight baked into the machine code instruction stream
07:16:51 <xcxvc> aristid: When I discussed that on the nix list a year ago (or so), I was told that there is no reliable way to install only free software.  And it's not just about setting some flag.  The situation is similar to Debian, which provides a repository of non-free software and recommends it on the wiki.
07:16:56 <mm_freak> aristid: since i don't know the application, i can't tell you how i would do it
07:17:00 <xcxvc> mm_freak: I don't want to offend you (or anyone else).  When I said "freedom", I meant the FSF's definition.  I'd like to discuss this if you want, but this channel is not a good place for that.
07:17:11 <Philonous> aristid, You can just tell GHC to inline the function
07:17:21 <Philonous> aristid, Have you checked that GHC won't optimize it anyway?
07:18:01 <aristid> Philonous: well until now my code uses pre-defined constants and i didn't check the generated code for the generic version yet
07:18:23 <mm_freak> xcxvc: i'm not even sure i want to discuss that
07:19:05 <aristid> mm_freak: i'm computing this: http://en.wikipedia.org/wiki/Rolling_hash#Cyclic_polynomial and using a bitmask to split data into blocks. i actually want to parameterize two things: the bitmask and the rolling window size
07:21:57 <mm_freak> aristid: i see…  i can't help you there without essentially solving the problem =)
07:22:37 <aristid> mm_freak: solving which problem? i already have a function that does this, but it's limited to ByteString and a pre-defined mask and window size. :)
07:22:49 <mm_freak> i see
07:24:04 <aristid> xcxvc: did you try setting the config.allowUnfree = false option?
07:25:13 <the_berserker> @pl \x -> x*(x+1)
07:25:14 <lambdabot> ap (*) (1 +)
07:26:18 <Twey> I wonder why @pl prefers ap to (<*>)
07:26:29 <the_berserker> @pl \x y a b -> a*(x+y)+b*(x-y)
07:26:29 <lambdabot> ap (ap . ((flip . (((.) . (+)) .) . (*)) .) . (+)) (((*) .) . (-))
07:26:35 <aristid> mm_freak: i think i'll just accept these parameters being dynamic for now
07:26:40 <Twey> (*) <*> (+ 1) is more general
07:27:37 <the_berserker> @pl \x y -> x y
07:27:37 <lambdabot> id
07:28:18 <Philonous> Twey, How is it more general? The monad/applicative instance is fixed anyway.
07:28:35 <aristid> :t ap
07:28:36 <lambdabot> Monad m => m (a -> b) -> m a -> m b
07:28:40 <_sebastian_> it would be really helpful, if aeson would return something more specific, than just Nohting, if parsing failes
07:28:43 <aristid> unnecessary Monad constraint:)
07:29:25 <Philonous> aristid, Yes, but if you know that m will be (-> r) then what difference does it make whether you use the Monad interface or the Applicative interface?
07:29:28 <aristid> _sebastian_: just use eitherDecode
07:29:41 <the_berserker> @pl \x y -> y x
07:29:41 <lambdabot> flip id
07:29:46 <aristid> Philonous: none
07:30:04 <Philonous> aristid, So it's not more general after all ;)
07:30:20 <Twey> Philonous: True that.  It still doesn't seem right to add a stronger constraint than strictly necessary, though.  :þ
07:30:38 <the_berserker> @pl let x= 1:(map (2*) x) in x
07:30:38 <lambdabot> fix ((1 :) . map (2 *))
07:30:56 <the_berserker> > fix ((1:).map(2*))
07:30:57 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:31:27 <the_berserker> > map (2^) [0..]
07:31:28 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
07:31:33 <aristid> Twey: hmm so we should never use map when we could use fmap, too?:)
07:32:09 <Twey> aristid: I'm one of those people in favour of renaming fmap to map ;)
07:32:19 <the_berserker> > fix ((1:).map(2*)) == map (2^) [0..]
07:32:22 <lambdabot>  mueval-core: Time limit exceeded
07:32:38 <aristid> Twey: i suppose you mostly like Caleskell?:)
07:32:52 <benmachine> the_berserker: it's easy to find out if infinite streams are unequal, not so easy to check they're equal...
07:33:41 <the_berserker> > scanl (*) 1 [1..]
07:33:42 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
07:34:01 <the_berserker> benmachine: The halting problem?
07:34:22 <Twey> aristid: Absolutely!
07:34:24 <benmachine> the_berserker: you could do it if you could solve the halting problem
07:34:25 <aristid> the "you don't have infinite time" problem:)
07:34:29 <benmachine> but they're not really the same thing
07:34:38 <benmachine> there are a lot of things you can do if you can solve the halting problem :P
07:34:48 <benmachine> (e.g. prove false? I guess?)
07:35:02 <the_berserker> benmachine: But you will need a hypercomputer to do so
07:35:04 <benmachine> (no, I suppose not, you just can't using a Turing machine to do so)
07:35:05 <aristid> and once you've proven false, the rest is easy
07:35:05 <Twey> benmachine: It's pretty hard to check whether they're unequal, too.  :þ  (especially when the answer is negative)
07:35:17 <benmachine> aristid: quite
07:35:21 <ion> benmachine: It isn’t that easy to find out if infinite equal streams are inequal.
07:35:47 <ion> Ah, Twey already said that.
07:35:53 <benmachine> I said "it's easy to find out if infinite streams are unequal", OBVIOUSLY what that means is "if infinite streams are unequal, it's easy to find that out"
07:35:58 <benmachine> OBVIOUSLY.
07:36:11 <benmachine> because English is commutative
07:36:27 <Twey> I also wouldn't be surprised if there were two sequences that were equal to any finite approximation but unequal in the limit, because maths likes springing stuff like that on you
07:36:40 <aristid> lisheng
07:36:43 <benmachine> that's fortunately not the case
07:36:49 <benmachine> well
07:36:54 <Twey> Heh
07:37:00 <Twey> It's that ‘well’ I was aiming at :þ
07:37:14 <benmachine> if you interpret the terms in the way that I do, it's not the case
07:37:32 <benmachine> and you have my understanding of mathematics
07:37:38 <Twey> Ahuh
07:38:29 <jedai> If they are unequal, then there is one index on which they differ so ... I really don't see how it would be possible
07:38:46 <Twey> But does it have to be a finite index?
07:38:51 <mm_freak> aristid: "dynamic" doesn't necessarily mean "computed every time"
07:38:57 <Philonous> Twey, If any finite prefix is equal then they are equal
07:39:03 <mm_freak> aristid: the usual haskell sharing should suffice to make this algorithm efficient
07:39:03 <Twey> Ah, okay
07:39:10 <mm_freak> at least with GHC
07:39:28 <benmachine> well, you could consider other contexts with other sequences that had ordinal indexes bigger than ω
07:39:42 <benmachine> but I don't think that's what you were going for
07:39:45 <jedai> Twey : as opposed to an unfinite index ? What would that be ?
07:40:06 <mm_freak> aristid: also for hash functions it's quite common to have three stages:  init, compute, finalize
07:40:07 <benmachine> jedai: the index of an element preceded by infinitely many elements
07:40:33 <benmachine> e.g. you could consider ([a], [a]) as a single sequence of length ω × 2
07:40:44 <jedai> benmachine: that doesn't exist though, not in lists (since they're indexed by integers)
07:40:47 <aristid> mm_freak: i don't mean that it's recomputed everytime
07:41:07 <Twey> jedai: They're not really indexed by integers — they're linked lists
07:41:10 <benmachine> jedai: it's really up to you how you index things
07:41:11 <aristid> mm_freak: but that it's in a register or in memory, where it should be in an immediate in the instruction stream :)
07:41:27 <Twey> Only (!!) and friends like to use Ints
07:41:31 <jedai> benmachine: ok, if you use some other types, you can have such weird indices
07:41:44 <Philonous> Twey, You can show by induction that any element in the list has a finite index.
07:41:48 <aristid> mm_freak: maybe i'm thinking too low-level though:D
07:41:58 <jedai> Twey: I'm sepaking about integers, not Int
07:42:11 <jedai> s/sepaking/speaking
07:42:26 <benmachine> Philonous: certainly for [a] you can, but I think we were talking about more general notions of sequence
07:42:37 <jedai> Philonous: Yep, my point
07:42:53 <jedai> benmachine: Ok, in this case I guess the problem is different
07:43:10 <benmachine> I guess that too
07:43:32 <benmachine> Twey: anyway, I think it's odd to have this idea that maths is constantly trying to screw you over :P
07:43:40 <mm_freak> aristid: not sure whether GHC performs optimization on that level, but you should definitely try LLVM compilation
07:43:44 <benmachine> although, to be fair, I can think of examples
07:44:01 <mm_freak> aristid: -fllvm
07:44:02 <Philonous> benmachine, I think the point is that your intuition is constantly screwing you over. And that's a valid point.
07:44:11 <aristid> mm_freak: my existing code gets ~700 MB/s using -fllvm :)
07:44:21 <benmachine> "surely an open dense set has to be the whole set"
07:44:37 <benmachine> "ok, surely it has to be all but only finitely/countably many points"
07:44:47 <benmachine> "ok, surely it has to at least be pretty big, measure-wise"
07:44:58 <benmachine> (nope)
07:45:23 <aristid> benmachine: the only way out is to become an ultrafinitist
07:45:37 <benmachine> aristid: numbers go up to 100, and then they stop. no more numbers.
07:45:54 <aristid> benmachine: i would use a bigger limit, but sure:)
07:46:17 <benmachine> oblig. http://xkcd.com/1310/ extremely strong goldbach conjecture
07:47:29 <aristid> i like the tautological prime conjecture
07:47:31 <Twey> Haha
07:51:50 <xcxvc> Philonous: I've replaced String with Text.  Now 'command time' reports 99%CPU, but at least iceweasel doesn't crash while the script is processing the file. Should I try the criterion package?
07:55:27 <jmcarthur> i usually say the main weakness of trifecta is the documentation, but i'm considering the size of trifecta's full set of dependencies as even worse.
07:56:30 <BazGee> http://www.genuitec.me/raffle/?XrExcl
07:56:51 <Philonous> xcxvc, Well, criterion is good to check relative improvements while optimizing.
07:57:01 <Philonous> xcxvc, You should profile your program and check where the time is spent
07:58:31 <mm_freak> aristid: nice =)
08:00:00 <aristid> mm_freak: it's much slower on my laptop though. i think i could get it faster, but right now it seems more important to get it more generic
08:00:11 <mm_freak> in my shell i constantly write "take" when i'm supposed to write "head" =/
08:00:31 <aristid> in your shell?
08:00:39 <aristid> oh, the head program
08:00:41 <aristid> lol
08:05:42 <windwarrior> hey, i hoped that you could help me solve a profiling issue I am experiencing. I have a continious running server that I want a heap profile from (lets say the first 3 minutes), but when I use "timeout --signal 15 3m ./actionsDemo +RTS -hc -RTS -K100M ", the output generated is incomplete, is there a way to tell the profiling that it only has to generate heap profiles for some time?
08:08:04 <windwarrior> if I'm wrong here, please say so :)
08:08:28 <jmcarthur> i, too, am interested in the answer to windwarrior's question
08:08:44 <jmcarthur> never looked for the answer, but always wondered
08:09:03 <augur> so, anyone know how @free works?
08:10:04 <Earnestea> mm_freak: alias head='take' ;p
08:10:09 <jmcarthur> augur: http://hackage.haskell.org/package/lambdabot-4.3.0.1/docs/src/Lambdabot-Plugin-Free-Theorem.html
08:10:15 <mm_freak> Earnestea: alias take=head
08:10:16 <mm_freak> ;)
08:10:33 <Earnestea> I like being explicit about it, but yeah that's fine too
08:10:48 <augur> jmcarthur: aww. no clean little tutorial? oh well. thank you, ill give it a look
08:10:52 <Earnestea> Hm
08:10:55 <Earnestea> Right, derp
08:10:57 <mm_freak> Earnestea: yours is wrong…
08:11:13 <jmcarthur> augur: sorry, maybe a better link here at least: https://github.com/mokus0/lambdabot/tree/master/lambdabot-haskell-plugins/src/Lambdabot/Plugin/Haskell/Free
08:11:33 <jmcarthur> augur: that first one was just the first thing i saw on google, but in fact it's probably not the most useful of those modules in the second link
08:11:51 <augur> k
08:13:44 <mello_> can someone help me convert this statement?
08:13:50 <mello_> maybe 1 (read . BT.unpack) <$> getPostParam "month"
08:13:55 <mello_> I want to use readMay instead of read
08:14:31 <mm_freak> mello_: which framework is that?
08:14:52 <mello_> mm_freak, snap, but that's not relevant here i believe, all you need to know is getPostParam gives back a Maybe ByteString
08:15:31 <Cale> You might just prefer to use do-notation here.
08:15:54 <mm_freak> i ask because you would normally use web-routes and not bother with parsing request paths
08:16:05 <bennofs> mello_: I think you want fromMaybe 1 . (>>= readMay . BT.unpack) <$> getPostParam "month"
08:16:26 <mello_> Cale, well sure, I can do just: month <- getPostParam, but I want to convert it before I 'catch' it
08:17:31 <mello_> mm_freak, okay i can understand what you're getting at
08:18:09 <mello_> is it wrong to try and convert params to the correct types and then throw an error if they are not viable input?
08:18:33 <mello_> let's say you have a route called: "/foo/:id", and your id is not a number, then how do you handle it?
08:18:42 <mello_> bennofs, thanks i'll look into that :)
08:18:45 <mello_> :t fromMaybe
08:18:45 <lambdabot> a -> Maybe a -> a
08:18:51 <mm_freak> mello_: it's sort of wrong, but i think it's the way to go in snap
08:19:24 <mello_> mm_freak, you mean normally routes should handle that, correct?
08:19:36 <mm_freak> mello_: in happstack and yesod you use type-safe URLs with boomerangs (parser-printers)
08:20:21 <Cale> augur: see also http://hackage.haskell.org/package/free-theorems-0.3.2.0/docs/Language-Haskell-FreeTheorems.html
08:21:04 <mello_> mm_freak, that sounds pretty cool. I'm not going to switch right now though but, out of curiousity, what is the impact? I mean, how easy is it to define those type-safe URL's?
08:21:26 <augur> Cale: thanks ill give it a look
08:21:42 <mello_> you're making me think on how other languages I know handles that sort of thing.. but I agree with you that it should not belong at the place I'm writing it
08:22:10 <mm_freak> mello_: i'll write a short happstack example
08:22:25 <Cale> augur: That code also looks like it has more comments than the lambdabot code
08:23:01 <Cale> augur: But I'm still pretty sure you'll have to read the papers to figure it out. I don't understand it myself.
08:23:25 <augur> Cale: besides wadler's whats good to read?
08:23:32 <leourbina> I'm having trouble installing IHaskell, I have followed the instructions here http://gibiansky.github.io/IHaskell/ however cabal keeps complaining with the error message Loading package zeromq4-haskell-0.1 ... linking ... ghc: /home/leo/.cabal/lib/zeromq4-haskell-0.1/ghc-7.6.3/HSzeromq4-haskell-0.1.o: unknown symbol `zmq_ctx_new'
08:23:41 <leourbina> I'm running ubuntu 13.10
08:23:47 <leourbina> any ideas what could that be?
08:23:54 <Cale> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.71.1777&rep=rep1&type=pdf is the other citation
08:24:07 <leourbina> I have tried empyting ~/.ghc and ~/.cabal and install it from scratch with no luck so far
08:25:52 <Cale> augur: and then there's http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=E68EFEF9AE1BF169151A36E5917ADC82?doi=10.1.1.59.8232&rep=rep1&type=pdf
08:26:52 <augur> Cale: cool, thank you
08:30:43 <mm_freak> mello_: http://lpaste.net/98327
08:31:19 <mm_freak> mello_: it's a full program, so you can compile and run it to see how it works
08:31:20 <Cale> leourbina: That sounds like you're missing a required C library for a binding
08:31:30 <Cale> (specifically, the binding to zeromq)
08:32:32 <Cale> leourbina: Did you build libzmq from the git repository?
08:34:41 <Cale> leourbina: ah, the git repo linked in those instructions doesn't even work for me
08:35:30 <Cale> leourbina: I'll try this installation myself using the stable 4.0.3 release from http://zeromq.org/intro:get-the-software
08:38:46 <mm_freak> i'll take that as a "thanks" =)
08:42:05 <the_berserker> @unpl flip flip
08:42:05 <lambdabot> (\ b c f -> c f b)
08:42:51 <ion> @unpl flip flip flip
08:42:51 <lambdabot> (\ c f -> c f (\ g h i -> g i h))
08:43:02 <the_berserker> @unpl (.).(.).(.)
08:43:02 <lambdabot> (\ l b c f i -> l (b c f i))
08:44:28 <the_berserker> @pl \a b c d e f -> a (b (c (d (e (f)))))
08:44:28 <lambdabot> (. ((. ((. (.)) . (.) . (.))) . (.) . (.) . (.))) . (.) . (.) . (.) . (.)
08:45:47 <nicoo> @pl \a -> (. ((. ((. (.)) . (.) . (.))) . (.) . a (.) . (.))) . (.) . (.) . (.) . (.)
08:45:48 <lambdabot> (. ((.) . (.) . (.) . (.))) . flip (.) . (((. ((. (.)) . (.) . (.))) . (.)) .) . (. (.)) . ($ (.))
08:47:38 <leourbina> ok
08:50:09 <Cale> leourbina: It worked and installed for me
08:50:15 <leourbina> cool
08:50:16 <leourbina> thanks
08:50:23 <Cale> leourbina: I had to remember to sudo ldconfig after installing the C library
08:52:35 <Philonous> Bah, GHC keeps suggesting impossible pattern match alternatives :(
08:54:56 <timthelion> Philonous: honestly?
08:55:11 <ilmig_> can I somehow create some kind of a sub-type from a given sum type (i.e. create a new type with: type Bar = A | B when I already have type Foo = A | B | C)
08:55:30 <ilmig_> and then I would like to be able to give Bar to a function which expects Foo
08:55:42 <Philonous> timthelion, I don't know whether GHC is being honest about it. Maybe it has a twisted sense of humour.
08:55:51 <joelteon> no ilmig_
08:55:53 <timthelion> Philonous: :D
08:55:59 <timthelion> Philonous: show me?
08:56:37 <ilmig_> joelteon: thank you, what a pity, though :(
08:56:52 <ilmig_> does anybody know if there is a specific reason why haskell doesn't have this feature
08:57:07 <jmcarthur> i have seen ghc do that too
08:57:11 <ilmig_> it would appear useful to me...
08:57:11 <jmcarthur> very annoying
08:57:15 <joelteon> because why would it
08:57:23 <joelteon> it's oddly specific
08:57:40 <mm_freak> mello_: i posted a web-routes example earlier
08:57:53 <mm_freak> mello_: http://lpaste.net/98327
08:58:09 <jmcarthur> ilmig_: you can do it with type classes, which can be about as useful as ADTs for similar things
08:58:17 <Philonous> timthelion, For example, it insists that I should match on SNil :: Sing [] here: https://github.com/Philonous/dbus-ext/blob/master/src/DBus/Marshal.hs#L50-L53
08:58:20 <ilmig_> hm ok, maybe I want to constrain my types too much
08:58:29 <timthelion> joelteon: really? I've run into it in almost every program I've ever written.  I used GADTs sometimes, but I usually just make a type of kind *->* like in data Foo a = A | B | More a
08:58:33 <jmcarthur> ilmig_: class Bar a where a :: a; b :: a    ...   class Bar a => Foo a where c :: a
08:58:37 <timthelion> ilmig_: see my comment to joelteon
08:58:56 <Philonous> timthelion, compare https://github.com/Philonous/dbus-ext/blob/master/src/DBus/Marshal.hs#L50-L53
08:59:01 <ilmig_> timthelion: thanks, I will look into that
08:59:19 <Philonous> timthelion, there's no way to construct a (DBusStruct [] )
08:59:52 <jmcarthur> i find type classes are more than sufficient for this kind of subtyping relationship, in practice
09:00:30 <timthelion> Philonous: but don't you need dependent types for the compiler to know that?
09:01:04 <ilmig_> jmcarthur: thanks, I think this solution works for me :)
09:01:21 <Philonous> timthelion, If I add the suggested match it realized that it's impossible
09:01:37 <timthelion> jmcarthur: I see that from a purely technical standpoint they are sufficient.  But somehow I find your notation to be less transparant than mine.  I just don't see through such type signatures to their meaning.
09:01:53 <Philonous> timthelion, But yes, it's "kinda" dependently typed
09:02:04 <timthelion> Philonous: well then f'k me!  I guess you found a bug!
09:02:30 <jmcarthur> timthelion: note that i can emulate the original Foo type in its full power using my Foo type class:    type FooSyntax = forall a. Foo a => a
09:03:05 <timthelion> jmcarthur: why do you prefer doing it with type classes over using a * -> *?
09:03:31 <timthelion> jmcarthur: Is there a reason you don't like data Foo a = A | B | More a?
09:04:01 <timthelion> jmcarthur: well I guess that the More case could be a pain to deal with when you only want to match A and B...
09:05:03 <jmcarthur> timthelion: yeah, that More constructor really stinks. i would need Foo Void to roughly demonstrate to the compiler that i don't need More, and then i still have to deal with the boilerplate of matching on it and using absurd
09:05:34 <james_h> hi, i am a bit confused on understanding the meaning of ($) function in haskell.
09:05:38 <jmcarthur> timthelion: also, the type class approach is sometimes more efficient, because the compiler might be able to inline your interpreter when it couldn't with the ADT version (especially for recursive ADTs)
09:05:42 <james_h> :t ($)
09:05:42 <lambdabot> (a -> b) -> a -> b
09:05:54 <Philonous> timthelion, Oh, actually, GHC doesn't realize that those cases are impossible.
09:06:08 <james_h> but you can also use ($)  like this:
09:06:17 <james_h> ($) (*) 2 3
09:06:32 <joelteon> james_h: that becomes (($) (*) 2) 3
09:06:32 <jmcarthur> james_h: ==>  ((*) $ 2) 3
09:06:32 <simon> mm_freak, I have the impression that I must create a typeclass instance for Vector MyType (or maybe Unboxed MyType), but do you have an example of this? I've scavenged StackOverflow, but can only find simple examples that use newtype.
09:07:22 <james_h> :t ($) (*) 2
09:07:23 <lambdabot> Num a => a -> a
09:08:15 <james_h> does applying ($) return a function then?
09:08:22 <jmcarthur> timthelion: i sometimes use type classes in place of ADTs even when i don't need subtyping like that (yet). type class instances are often more of a direct style than ADT interpreters
09:08:31 <simon> :t ($)
09:08:32 <lambdabot> (a -> b) -> a -> b
09:08:37 <joelteon> james_h: depends on what you apply it to
09:08:42 <jmcarthur> james_h: ($) :: (a -> b) -> (a -> b)
09:08:42 <skypers> hey
09:08:42 <joelteon> :t ($) `asAppliedTo` (*)
09:08:43 <lambdabot> Num a => (a -> a -> a) -> a -> a -> a
09:08:54 <timthelion> jmcarthur: Can you show me an example?  I'd like to learn to read such code.
09:08:57 <jmcarthur> james_h: ($) always takes a function and returns an example
09:10:10 <jmcarthur> timthelion: i posted part 1 of a series of blog posts which will at some point demonstrate this, but it doesn't have that part yet
09:10:42 <jmcarthur> timthelion: maybe the paper Finally Tagless, Partially Evaluated... although it goes a bit further than it necessary to understand the trick and delves into pretty tricky partial evaluation stuff
09:10:51 <timthelion> jmcarthur: OK.  Well I guess I'll wait.  Do you have an rss or something I could "follow" in the meantime?
09:11:19 <jmcarthur> timthelion: here is my part 1. it's old, which kind of shows how long you might expect to wait for more... http://creativelad.wordpress.com/2013/11/28/final-encodings-part-1-a-quick-demonstration/
09:11:39 <jmcarthur> timthelion: no mention of type classes there, even :)
09:12:04 <mm_freak> simon: read the haddock documentation of Data.Vector.Unbox
09:12:10 <mm_freak> simon: it explains how to create Unbox instances
09:12:24 <mm_freak> Data.Vector.Unboxed
09:13:23 <timthelion> jmcarthur: I like using DSL's for the "core state machine" of my projects.  I like the fact that one has the option to then prove properties of the "behavior" of the program without having to analize all the extra cruft on top...
09:13:49 <jmcarthur> timthelion: yeah, me too
09:14:22 <timthelion> jmcarthur: not that I'm actually cleaver enough to write any proofs ;)
09:14:36 <jmcarthur> proofs or not, it can still be easier to reason about
09:15:09 <james_h> jmcarthur, can you explain a bit more? what do you mean by it returns an example?
09:15:11 <timthelion> It's easier to debug, certainly...
09:15:55 <jmcarthur> timthelion: spoiler:  "In later posts, I will explain how to get more out of a glob pattern than just matching; for example, you might want to pretty print it or perform some static optimizations."  is basically just type classes, although with a trick involving higher rank types to get somethind equivalent to an ADT, too (although that makes it no longer a final encoding)
09:16:20 <jmcarthur> james_h: i don't know where i said anything about returning an example?
09:16:46 <james_h> jmcarthur, above you said:  always takes a function and returns an example
09:17:12 <jmcarthur> james_h: hah! that was a mistake. i meant returns a function
09:17:28 <jmcarthur> james_h: i was reading something timthelion wrote at the same time i was writing that and messed up, i think
09:17:45 <mm_freak> are we back to Auto/Mealy?  would be the third time today =)
09:17:47 <skypers> > do { x <- [1..10]; guard (x < 4); return (x + 1) }
09:17:48 <lambdabot>  [2,3,4]
09:17:56 <jmcarthur> james_h: ($) always takes a function and returns a function
09:18:01 <skypers> hm
09:18:16 <jmcarthur> james_h: in fact, the function it returns is exactly the same function you gave it
09:18:24 <windwarrior> jmcarthur, if you are still interested in my question, you can follow: http://stackoverflow.com/questions/21065280/haskell-profiling-for-a-fixed-amout-of-time :), just posted it there
09:18:24 <jmcarthur> james_h: ($) = id
09:18:32 <jmcarthur> windwarrior: thanks!
09:18:32 <abc22134> @ hoogle guard
09:18:34 <mm_freak> ($) f x = f x
09:18:39 <mm_freak> so: ($) f = f
09:18:42 <mm_freak> so: ($) = id
09:19:05 <james_h> so is ($) it a higher order function?
09:19:11 <james_h> so is ($)  a higher order function?
09:19:38 <mm_freak> james_h: well, most functions in haskell are higher order, but it takes a function as argument
09:19:40 <jmcarthur> james_h: yes, but a very trivial one
09:20:02 <james_h> ok thanks.
09:21:05 <jmcarthur> windwarrior: one dumb way to go is to write the timeout directly into the haskell program so that it can kill itself cleanly, but that's no good if you want the program to continue running without profiling afterward
09:21:37 <mm_freak> am i right that Integer -> Bool is isomorphic to ℝ?
09:21:43 <james_h> if ($) f = f , then ($) is pretty a useless thing. Is there any good use of ($) that you can suggest?
09:21:47 <mm_freak> i mean the real ℝ, not Double
09:21:48 <jmcarthur> timthelion: oh, i forgot about this, too: http://stackoverflow.com/questions/19082560/haskell-pretty-print-binary-tree-not-displaying-properly/19149674#19149674
09:22:01 <benmachine> mm_freak: isomorphic in what category?
09:22:09 <mm_freak> james_h: liftIO $ do …
09:22:18 <benmachine> mm_freak: I mean, ℝ doesn't even really exist as a Haskell type
09:22:19 <mm_freak> james_h: forkIO $ do …
09:22:33 <benmachine> or maybe it does, but then you might well *define* it as Integer -> Bool
09:22:36 <windwarrior> yes, but there should be a neat way of doing this. (Besides, there is a thread clusterf in the code that is not easily terminated :D, #notmycode)
09:22:53 <mm_freak> benmachine: is there a one-to-one correspondence between ℝ elements and Integer -> Bool elements?
09:23:08 <Cale> benmachine: Well, there's CReal
09:23:09 <jmcarthur> timthelion: i'm not entirely happy with that stackoverflow answer though because i changed the type of one of the constructors a bit. i could have avoided that, but i didn't want to clutter the answer more
09:23:23 <Cale> benmachine: But not so much the classical real numbers.
09:23:31 <benmachine> mm_freak: possibly it depends; if you consider Integer -> Bool to contain only the functions that you can define in Haskell then there are only countably many of them
09:23:34 <jmcarthur> or, well, i *think* i could have avoided it. i also would have to think about it more
09:23:57 <mm_freak> benmachine: good point, thanks
09:24:05 <jmcarthur> james_h: ($) exists for its precedence. it allows you to avoid some awkwardly placed parentheses sometimes
09:24:07 <Cale> mm_freak: As sets, yes
09:24:42 <benmachine> mm_freak: if you consider ℝ to contain only the reals you can define in Haskell then there are only countably many of those too :)
09:25:04 <xintron> If I have a record like `data Foo = Foo { lines :: [Int] }` how can I reference that (ambiguous because of lines from Prelude)?
09:25:05 <mm_freak> indeed =)
09:25:26 <timthelion> jmcarthur: thanks for the link
09:25:36 <mm_freak> Cale: so 2^ℕ ≃ ℝ?
09:25:46 <Cale> mm_freak: yes
09:25:52 <arnsholt> xintron: import Prelude hiding (lines)
09:25:56 <mm_freak> ok, great
09:26:18 <jmcarthur> mm_freak: is (<0)==1 ?  ;)
09:26:24 <xintron> arnsholt, That's one way of doing it but can't I reference it somehow?
09:26:40 <arnsholt> Should be available as Prelude.lines I think
09:27:06 <mm_freak> jmcarthur: the only thing i can see there is a weird penis
09:27:06 <arnsholt> Or maybe you also have to import qualified Prelude, I can't remember off-hand
09:27:06 <xintron> arnsholt, I mean my Foo.lines
09:27:13 <xintron> ok
09:28:58 <jmcarthur> mm_freak: i'm just noting that in (Integer -> Bool) there are apparently two distinguishable ways to represent the same real number
09:29:20 <mm_freak> jmcarthur: oh =)
09:29:27 <jmcarthur> unless somebody more knowledgable can set me straight somehow
09:29:36 <mm_freak> jmcarthur: i'm taking it to mean a binary polynomial representation
09:29:47 <Cale> Depends on how you do it, but yes
09:30:07 * hackagebot data-size 0.1.1.7 - Profiling of data structures  http://hackage.haskell.org/package/data-size-0.1.1.7 (UweSchmidt)
09:30:12 <Cale> For certain real numbers (only countably many of them)
09:30:14 <mm_freak> (f 0 = True; f _ = False) would mean x^0 = 1
09:30:32 <fatemeh_> hi
09:31:27 <jmcarthur> mm_freak: i was taking the input to the function to be a bit position
09:31:38 <benmachine> right
09:31:38 <mm_freak> jmcarthur: yeah, same thing
09:31:55 <benmachine> I think jmcarthur was highlighting how 0.1... = 1, and hence the obvious function is not injective
09:32:08 <jmcarthur> yeah, what benmachine said
09:32:18 <mm_freak> ah, well, it's certainly not in one-to-one correspondence
09:32:25 <mm_freak> f = const True
09:32:28 <mm_freak> there is no such real number
09:32:29 <benmachine> it was not necessary for me to explain what jmcarthur was doing because jmcarthur is perfectly capable of that, but now I get to look clever?
09:32:31 <Cale> Usually you'll apply the CSB theorem
09:32:42 <Cale> So you just need to get an injection in each direction
09:32:45 <mm_freak> i was more interested in the size
09:32:51 <jmcarthur> benmachine: there's no telling how capable i am of explaining what i'm doing ;)
09:32:57 <james_h> fatemeh_ hi
09:33:03 <mm_freak> i should have asked this instead:  |2^ℕ| = |ℝ|
09:33:31 <benmachine> that is certainly true in sets
09:33:33 <Cale> mm_freak: Of course, that implies their isomorphism in set theory :)
09:33:49 <mm_freak> Cale: true
09:34:26 <mm_freak> Cale: but if you take every real number to be representable as a polynomial, then you can cover all reals without this function f = const True
09:34:32 <mm_freak> so const True is an extra element
09:34:42 <benmachine> Cale: not so much "implies" as "states", right? :P
09:34:46 <Cale> What do you mean by "representable as a polynomial"?
09:35:07 * hackagebot yaml 0.8.5.3 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.5.3 (MichaelSnoyman)
09:35:14 <Cale> Do you mean "power series"?
09:35:15 <mm_freak> Cale: 0 ~ 0, 1 ~ 1, 2 ~ x, 3 ~ x + 1, 4 ~ x², 5 ~ x² + 1, …
09:35:25 <mm_freak> Cale: the polynomial is just the binary representation
09:35:39 <Cale> What's the polynomial representation of pi?
09:36:00 <mm_freak> Cale: it's an infinitely long polynomial
09:36:06 <benmachine> what do you do with negative numbers?
09:36:13 <Cale> You're not talking about polynomials, you're talking about power series
09:36:28 <mm_freak> am i?
09:36:38 <Cale> (actually, probably Laurent series...)
09:36:44 <jmcarthur> benmachine: designate the input zero to be a sign bit?
09:36:46 <mm_freak> or maybe just both =)
09:36:54 <timthelion> jmcarthur: OK, I read your stackexange post.  If I want to pretty print that bintree and then serialize it to JSON how to I convert between the "prettyprintable" newtyped bintree and the serializable one?
09:37:11 <Cale> Polynomials are power series with only finitely many nonzero coefficients.
09:37:24 <mm_freak> ah, ok
09:37:33 <jmcarthur> timthelion: you can represent a tree compatible with both interpretations as (forall f. BinaryTree f => f a)
09:38:01 <jmcarthur> timthelion: and that is also, of course, an instance of BinaryTree
09:38:02 <mm_freak> well, i'm mostly dealing with discrete stuff…  ℝ scares me =/
09:38:03 <Cale> mm_freak: and you'll probably find it simpler only to approach the problem of representing [0,1], which is easily shown to be in bijection with all of R
09:38:24 <mm_freak> Cale: indeed
09:38:34 <benmachine> Cale: (0,1) might arguably be easier
09:38:37 <Cale> because then you only need to worry about binary expansions of the form 0.b_1 b_2 b_3...
09:38:44 <benmachine> I mean, it's easy but slightly fiddly to go from that to [0,1]
09:38:59 <jmcarthur> timthelion: so i haven't exactly answered your question because there really isn't any conversion to do anyway
09:39:02 <benmachine> oh, you make a good point
09:39:31 <mm_freak> Cale: i'd probably find ℝ+ easier
09:40:09 <mm_freak> because then you can just use Integer -> Bool to directly mean the binary representation
09:40:09 <jmcarthur> timthelion: granted, once you use that representation, you could just use an ADT instead
09:40:34 <jmcarthur> timthelion: although the conversion from that type to the others is trivial, whereas the conversion from the ADT to any other type requires an interpreter
09:40:51 <xintron> What's the difference between Prelude.map and Data.List.map?
09:40:59 <timthelion> jmcarthur: I think I'd have to see something that compiles to understand it.
09:41:00 <mm_freak> Cale: but then there is still this weird extra element 'const True'
09:41:03 <mm_freak> xintron: none
09:41:03 <quchen> xintron: They're identical
09:41:09 <xintron> ah
09:41:21 <Cale> mm_freak: That's the representation of 1
09:41:25 <jmcarthur> timthelion: got a simpler example in mind than JSON serializing? i could tweak this a bit and lpaste it
09:41:25 <mm_freak> xintron: one just reexports the other
09:41:25 <Cale> 0.111111... = 1
09:41:33 <mm_freak> Cale: that's …111111.111111…
09:41:33 <quchen> xintron: As in "they are the same thing", not "they are two different functions doing the same". Prelude re-exports Data.List.map.
09:41:34 <timthelion> jmcarthur: Well, be fair with me, one does not need to convert the ADT in this case, one simply needs to write two interpreters, one that pretty prints and the other that serializes.
09:41:52 <Cale> mm_freak: uh...
09:41:58 <jmcarthur> timthelion: sure
09:42:00 <xintron> Is there anywhere I can see which functions that are re-exports in Prelude?
09:42:15 <quchen> xintron: Look at Prelude's source?
09:42:28 <quchen> Prelude is pretty much only reexports though
09:42:28 <xintron> well, that ofc :)
09:42:29 <timthelion> jmcarthur: OK, what about pretty print with spaces for the indentation and pretty print with periods for the indentation ;)
09:42:42 <Cale> mm_freak: We're sending the real number with binary expansion 0 . b_0 b_1 b_2 ... to the function f: N -> 2, f(n) = b_n
09:42:54 <timthelion> jmcarthur: that should be a minimal case that still shows two behaviors...
09:43:07 <jmcarthur> timthelion: sure, although mostly copy-paste ;)
09:43:08 <Cale> mm_freak: Using the convention that whenever there's a binary expansion which ends in all 1's, we choose that one.
09:43:19 <Cale> (not the one which ends in all 0's)
09:43:29 <mm_freak> Cale: that's your representation
09:43:34 <Cale> mm_freak: This gets us an injection [0,1] -> 2^N
09:43:37 <quchen> xintron: Everything in the export list that is not defined in the source below is a re-export.  http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Prelude.html
09:43:38 <timthelion> jmcarthur: You wanted something easy...
09:43:42 <mm_freak> Cale: i'm asking about a peculiarity in mine
09:43:48 <Cale> mm_freak: Then we just need to worry about forming an injection the other way
09:43:58 <xintron> quchen, ty!
09:44:06 <Cale> (and we'll have shown that a bijection exists, though constructing it is a mess)
09:44:23 <quchen> xintron: `seq` is a compiler primitive, and ($!) is defined in terms of `seq`.
09:44:32 <mm_freak> Cale: the binary representation of every real number has a finite number of ones to the left of the decimal point, correct?
09:44:32 <quchen> xintron: In other words: everything's re-exports.
09:44:38 <quchen> Except those two
09:44:38 <Cale> mm_freak: yes
09:45:07 <Cale> mm_freak: You can split it up into the problem of encoding an integer, and the problem of encoding the tail of the binary expansion if you like
09:45:25 <quchen> xintron: Which is good, because if Prelude defined its own "map" function and you imported Data.List.map, using either of them would create an "ambiguous function 'map'" error.
09:45:42 <Cale> mm_freak: But if you want to do that with bit sequences, you'll probably want to use chunks of 2 bits at a time or something so that you have some room for punctuation in the encoding
09:45:48 <xintron> quchen, true
09:45:50 <mm_freak> Cale: now let ℤ → 2 be the set of all functions that map a digit index to the corresponding binary digit
09:46:06 <mm_freak> Cale: this should, without 'const True', cover all nonnegative real numbers, correct?
09:46:21 <Cale> mm_freak: There are plenty of other problematic cases
09:46:36 <Cale> What about the map which sends every even integer to 0 and every odd integer to 1?
09:47:10 <mm_freak> yeah, but if you disallow this problematic subset, then you get a representation for all nonnegative real numbers, right?
09:47:20 <Cale> Okay
09:47:32 <mm_freak> is this correct or am i making a mistake?
09:47:36 <Cale> Well, every nonnegative real number has a binary expansion, sure
09:47:56 <Cale> and once you've done that encoding correctly, you can certainly represent them as functions of that sort
09:48:09 <NemesisD> hey guys. i'm facing a bit of a challenge with cassava http://hackage.haskell.org/package/cassava-0.3.0.0/docs/Data-Csv.html
09:48:10 <mm_freak> so 2^ℤ can represent all nonnegative real numbers
09:48:21 <mm_freak> but then it still has elements left that don't correspond to real numbers
09:48:36 <mm_freak> doesn't that prove that 2^ℤ is actually larger than ℝ+?
09:48:36 <Cale> mm_freak: What you've sort of done is form an injection R -> 2^Z
09:48:39 <NemesisD> it has a function encodeByName :: ToNamedRecord a => Header -> [a] -> LByteString
09:48:41 <jmcarthur> timthelion: this exercise has made me realize that my ConstraintKinds hack is broken :(
09:48:47 <Cale> er R^+ -> 2^Z, yeah
09:49:04 <jmcarthur> timthelion: i'm going to specialize the type parameter for now, but i'll try to make it general again later
09:49:05 <NemesisD> i tested this and this does work in constant space as expected, the problem though is that the data I need to get is from IO
09:49:43 <timthelion> jmcarthur: um, sorry :/
09:49:44 <Cale> NemesisD: It shouldn't matter where you get the data from, should it?
09:49:52 <mm_freak> Cale: and i'm assuming that ℝ+ ≃ ℝ
09:50:08 <Cale> mm_freak: Yeah, that's an easy bijection to produce.
09:50:09 <mm_freak> so |2^ℤ| > |ℝ|, no?
09:50:22 <NemesisD> Cale: doesn't that mean i kind of need to embed the writing of that lazy bytestring within the io that gets the data and make that io produce one continuous lazy array?
09:50:24 <Cale> yeah
09:50:31 <Cale> Well, not strictly
09:50:32 <Cale> >=
09:50:55 <NemesisD> Cale: the problem is that that function takes a header row and prints it, so it expects the whole document as a list
09:50:57 <Cale> NemesisD: oh, I see what you mean
09:51:04 <NemesisD> s/array/list, been doing too much ruby
09:51:49 <jmcarthur> timthelion: http://lpaste.net/98328
09:51:54 <Cale> NemesisD: Yeah, if you have to do lazy IO to get the input, it can be tricky to make sure everything works correctly (or impossible without unsafeInterleaveIO in some cases)
09:52:58 <jmcarthur> timthelion: really i don't even have to constrain the types of prettyTree and prettyTree2 so much
09:53:01 <NemesisD> Cale: i'll be getting it from mysql-simple, which gives you fold, which is kind of callback based
09:53:39 <NemesisD> Cale: i think i may file an issue and/or pull request for this. i hit this issue literally every single time i use cassava
09:53:42 <jmcarthur> timthelion: i edited it. refresh
09:54:01 <timthelion> jmcarthur: wow, cool!  I never realized that kind of "reverse type inference" was possible(at least not at that level)...
09:54:29 <jmcarthur> timthelion: it's really just parametric polymorphism
09:55:10 * hackagebot pure-io 0.2.0 - Pure IO monad.  http://hackage.haskell.org/package/pure-io-0.2.0 (ChrisDone)
09:55:51 <Cale> NemesisD: Maybe you can just use encodeByName on the first chunk, and use encode on all the others somehow?
09:55:54 <mm_freak> Cale: haven't we just figured out that |2^ℤ| ≠ |ℝ|?
09:56:00 <Cale> NemesisD: and then concatenate them?
09:56:01 <jmcarthur> timthelion: and in fact, if you think about it, it looks exactly like tons of code you've probably seen (and written) already. you're just thinking about it differently this time.
09:56:14 <mekeor> where can i find a list of valid "license types" for the "license" field of cabal-files? – http://www.haskell.org/cabal/users-guide/developing-packages.html#package-properties links to http://www.haskell.org/cabal/libraries/Cabal/Distribution-License.html#t:License which is broken.
09:56:19 <Cale> mm_freak: No, you gave one half of the pair of inequalities we'll use to show they have the same cardinality
09:56:36 <Cale> mm_freak: If you have an injection A -> B, it means that |A| <= |B|
09:56:43 <jmcarthur> timthelion: the only "trick" is that treeB is polymorphic
09:57:04 <mekeor> mekeor: http://www.haskell.org/ghc/docs/7.6.1/html/libraries/Cabal-1.16.0/Distribution-License.html
09:57:10 <Cale> mm_freak: So if you get injections A -> B and B -> A, then you have both |A| <= |B| and |B| <= |A| and can conclude that |A| = |B|
09:57:23 <mm_freak> Cale: for the backwards mapping, which real number corresponds to const True?
09:57:30 <Cale> (this is via the Cantor-Schroeder-Bernstein theorem)
09:58:01 <Cale> Depends on how we choose to make that injection work
09:58:27 <mm_freak> seems to be one of the more counterintuitive cases of infinity =)
09:58:47 <Cale> One easy thing is to send f to 0 . f(0) 0 f(1) 0 f(2) ...
09:58:55 <Cale> i.e. just stick 0's in between
09:59:05 <Cale> That avoids the whole issue with duplicate representations
09:59:15 <Cale> and again gets us an injection
09:59:39 <mm_freak> so far we have only an injection from ℝ+ to 2^ℤ, correct?
10:00:00 <mm_freak> send the real number to its binary representation
10:00:03 <Cale> What I wanted to do was [0,1] to 2^N
10:00:15 <Cale> it's much more straightforward
10:00:29 <Cale> Well...
10:00:30 <mm_freak> yeah, i know…  it avoids this problem, but it's an interesting problem, and i'd like to resolve it
10:00:44 <Cale> Well, it doesn't, we still only get an injection
10:00:48 <jmcarthur> timthelion: here's another way:  http://lpaste.net/98328
10:01:03 <mm_freak> Cale: indeed
10:01:06 <Cale> If you're convinced there's a bijection 2^N ~= 2^Z
10:01:17 <mm_freak> there are now two functions that correspond to 1
10:01:25 <mm_freak> oh, no
10:01:28 <mm_freak> there is only one
10:01:38 <mm_freak> but there are two functions that correspond to 1/2
10:01:41 <Cale> Remember, we don't need the functions to be inverses
10:01:55 <Cale> We're not actually making a bijection, we can let CSB do that for us
10:02:04 <jmcarthur> timthelion: that latter approach allows you to be a bit more lax about type annotations (no need to work with higher rank types directly except in that one type definition) by being a bit more verbose in the implementations (must use convert)
10:02:12 <Cale> (http://en.wikipedia.org/wiki/Cantor%E2%80%93Bernstein%E2%80%93Schroeder_theorem)
10:02:23 <mm_freak> Cale: i'm not sure i'm communicating the problem correctly
10:03:09 <abhinav> /[D/bar default
10:04:08 <benmachine> mm_freak: key fact: you can biject infinite sets with subsets of themselves
10:04:17 <mm_freak> Cale: let's take your 2^ℕ ~ [0;1] approach, with the [0;1] → 2^ℕ sending a real number to its binary representation, so 1/2 becomes f 0 = True, f _ = False
10:04:23 <Cale> (That's actually a common definition of "infinite"
10:04:24 <Cale> )
10:04:35 <benmachine> mm_freak: therefore, the fact that you can biject ℝ with a subset of 2^ℤ does not mean that 2^ℤ is bigger
10:04:37 <Cale> mm_freak: ok
10:04:53 <mm_freak> benmachine: how does that work?
10:05:04 <Cale> Let's think about the naturals for a bit
10:05:26 <Cale> Consider the function from the naturals to the even numbers obtained by multiplying each natural number by 2
10:05:54 <Cale> It has an inverse, which is just to divide by 2.
10:06:10 <Cale> So there's a bijection between the set of naturals and the set of even naturals.
10:06:16 <mm_freak> Cale: i understand that one, but in this case it's ℕ ≃ 2ℕ
10:06:37 <Cale> So, there's also an injection from 2N to N, which is just the inclusion map
10:07:11 <Cale> and that's not a bijection
10:07:24 <mm_freak> huh?  why not?
10:07:44 <mm_freak> there is a one-to-one correspondence between ℕ and 2ℕ
10:07:49 <Cale> Because it's not surjective: 3 isn't in the range of the inclusion
10:08:04 <jmcarthur> timthelion: one more annotation added: http://lpaste.net/98328
10:08:04 <mm_freak> 3 is not an element of 2ℕ
10:08:09 <Cale> correct
10:08:17 <benmachine> there *is* a function which is bijective, but there are also plenty that are not :P
10:08:28 <jmcarthur> timthelion: so you can convert back and forth between the polymphic stuff and the ADT with functions like convert and fromADT
10:08:47 <Cale> (we should probably have this conversation in #haskell-blah or something)
10:08:55 <Cale> well, or I dunno
10:08:58 <jmcarthur> timthelion: note that fromADT is recursive. the only recursive function here!
10:09:08 <timthelion> jmcarthur: oh, interesting...
10:09:10 <mm_freak> Cale: or in ##math
10:09:11 <jmcarthur> timthelion: all the others are more inlinable
10:09:14 <Cale> yeah
10:10:30 <timthelion> jmcarthur: it's only inlinable if the tree is static and known at compile time.  If you were building a tree from file, you would have to recurse no matter what your method.
10:10:50 <jmcarthur> timthelion: but the interpreter could get inlined into the parser
10:12:18 <timthelion> jmcarthur: It is certainly an interesting way of looking at things.  Is it profiled to be faster?  I see the novelty as being a downside, since I like to write code that any old idiot could read.
10:12:18 <jmcarthur> timthelion: assuming there is only one interpretation you intend to do, that is
10:12:32 <jmcarthur> timthelion: if you do the higher rank trick then you lose the inlining, i think
10:12:56 <jmcarthur> timthelion: i have definitely witnessed this approach generating greatly superior core sometimes
10:13:36 <jmcarthur> timthelion: it's similar to fusion in that as soon as you need sharing you need that intermediate representation, whether it be the high rank version or the ADT, and lose the inlining
10:13:43 <jmcarthur> *higher rank
10:14:58 <jmcarthur> timthelion: this is the same property that makes it possible for GHC to compile Generics code so well. no recursion over an ADT.
10:15:10 <timthelion> jmcarthur: I'll have to think about styling to see if I can't write code in that style and still make it newbfriendly.
10:30:40 <copumpkin> new ubuntu install, what's the friendliest/favorite way to get a good Haskell platform setup onto it? apt packages or something else?
10:31:18 <monochrom> my favourite is http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
10:31:48 <geekosaur> ubuntu doesn't have HP last I checked, they broke something and removed it rather than fix it
10:32:21 <monochrom> but that's just my favourite. I don't know about other people.
10:32:22 <timthelion> copumpkin: Well, judging by the scripts on the docker site... https://index.docker.io/search?q=haskell
10:32:41 <monochrom> clearly, what is friendliest depends on whom you're inflicting it on
10:32:53 <monochrom> upload his/her brain for a free analysis!
10:33:15 <timthelion> copumpkin: it seems that most download the platform as a tarball... https://github.com/zsol/docker-haskell-platform/blob/2013.2.0.0/Dockerfile
10:43:09 <BMeph> Is there a set of Monad Transformer Laws written down somewhere?
10:44:29 <srhb> BMeph: At least these: http://hackage.haskell.org/package/transformers-0.1.4.0/docs/Control-Monad-Trans.html
10:45:40 <stephenmac7> Is there a way to get :t during runtime?
10:45:50 <stephenmac7> To check the type of something
10:46:01 <stephenmac7> And, possibly, print it out
10:46:04 <jmcarthur> stephenmac7: don't you know it's type at compile type already?
10:46:08 <jmcarthur> *its
10:46:12 <jmcarthur> *time
10:46:13 <jmcarthur> ugh
10:46:17 <stephenmac7> Yes
10:46:37 <stephenmac7> The compiler knows, but I don't personally know
10:46:37 <jmcarthur> :t typeOf
10:46:38 <lambdabot> Typeable a => a -> TypeRep
10:46:48 <copumpkin> monochrom, timthelion, geekosaur: thanks :)
10:47:28 <jmcarthur> typeOf ()
10:47:29 <jmcarthur> > typeOf ()
10:47:30 <lambdabot>  ()
10:47:35 <jmcarthur> > typeOf (5 :: Double)
10:47:36 <lambdabot>  Double
10:47:40 <stephenmac7> jmcarthur: No show instance?
10:47:46 <jmcarthur> it has a show instance
10:47:52 <jmcarthur> as demonstrated right there :)
10:47:59 <jmcarthur> > show (typeOf (5 :: Double))
10:47:59 <lambdabot>  "Double"
10:48:00 <stephenmac7> Nevermind, there it is
10:48:02 <stephenmac7> Thanks
10:48:57 <mekeor> is "fmap f (mapM g x)" stupid?
10:49:35 <byorgey> no.
10:49:53 <mekeor> reason?
10:49:59 <hpc> i might do sequence (fmap (f . g) x) if it made sense as one line
10:50:08 <hpc> or split it into a few lines or something
10:50:17 <hpc> but ultimately it's all the same thing
10:50:29 <byorgey> hpc: that doesn't type check.
10:50:55 <ponga> Haskell!
10:51:02 <hpc> no?
10:51:03 <byorgey> mapM g (fmap f x) = mapM (g . f) x,  but there's no equally nice way to fuse  fmap f (mapM g x)
10:51:07 <ponga> why would my coder ask me to learn haskell
10:51:17 <hpc> :t \f g x -> fmap f (mapM g x)
10:51:18 <lambdabot> (Monad f, Functor f) => ([b1] -> b) -> (a -> f b1) -> [a] -> f b
10:51:29 <hpc> :t \f g x -> sequence (fmap (f . g) x)
10:51:30 <lambdabot> Monad m => (b -> m a) -> (a1 -> b) -> [a1] -> m [a]
10:51:38 <hpc> doh, you're right
10:52:20 <mekeor> ponga: i might want to take a look at http://www.haskell.org/haskellwiki/Why_Haskell_matters and http://www.haskell.org/haskellwiki/Haskell_in_industry ;) :) :P
10:52:33 <jmcarthur> ponga: why not?
10:53:27 <ponga> Well I'm like all new to programming world, my coder(my pal) wants to make my classic RPG into a computer game
10:53:32 <ponga> and says I should learn Haskell
10:53:42 <ponga> I never heard of Haskell
10:54:13 <ponga> mekeor: thanks I'm readin it now
10:54:25 <mekeor> ponga: haskell is awesome
10:54:39 <danharaj> It is a good language with more modern features than most mainstream languages.
10:55:49 <ponga> mekeor: my coder said so
10:55:56 <ponga> altho he personally hated it
10:56:02 <ponga> and prefer Java
10:57:30 <jmcarthur> ponga: haskell and good haskell style has some neat properties, like capturing states as values so you can control state directly and reason about state more easily. (my impromptu experiment in explaining something which is usually presented a little differently...)
10:57:30 <zomg> What a weird person
10:57:36 <zomg> Why would someone recommend a language they hate
10:57:36 <zomg> :P
10:58:27 <ponga> He said Haskell'd fit my style
10:58:27 <jmcarthur> ponga: not just states in fact but all effects are captured as values
10:58:53 <ponga> he also said only brainiacs could master haskell
10:58:55 <ponga> :/
10:59:01 <danharaj> he is wrong
10:59:04 <jmcarthur> he sounds really weird to me
10:59:13 <hpc> he would fit in here ;)
10:59:20 <mekeor> it's because he's stupid
10:59:25 <danharaj> If you already know a programming language that isn't like Haskell it will be hard because you would have to unlearn what you know. If you don't know programming it will be easy.
10:59:41 <hpc> i wouldn't say it's easy
10:59:42 <danharaj> relatively easy*
10:59:50 <danharaj> compared to, say, learning how to rock climb or play a piano ;)
10:59:59 <hpc> but if you don't know any programming, learning haskell is exactly as hard as learning to program for the first time
11:00:18 <ponga> danharaj: that's what he said
11:00:22 <hpc> if you know other programming languages, learning haskell is still about as hard as learning to program for the first time
11:00:22 <ponga> now i remember
11:00:30 <ponga> he said he is too much of java-man
11:00:32 <hpc> but still worth it
11:00:35 <mgsloan> hpc: I wouldn't go that far, but I'd go as far as saying you need to get past the feelings of "this is odd looking"
11:00:36 <ponga> and cannot stand haskell
11:01:12 <ponga> only language-ish thing I kno is I can use some of HTML codes
11:01:13 <hpc> mgsloan: the way things are evaluated/executed and just how much type-system there is also helps make it harder ;)
11:01:14 <jmcarthur> i was talking about some programming junk with my non-programmer wife when i mentioned "mutability," and she stopped and asked me what it was. I was very careful not to say anything about Haskell (which she knows I like) or my opinions on mutability, just what it actually is. she thought it was totally nuts that somebody would *want* a value to change.
11:01:14 <ponga> that's just it
11:01:16 <ponga> :(
11:01:51 <mgsloan> hpc: Right, I guess I'm rolling those semantic things into being "odd looking" since they affect how you structure your program
11:01:59 <c_wraith> mutability is manual memory management.  People want that, for some reason!
11:02:05 <byorgey> @where lyah
11:02:05 <lambdabot> http://www.learnyouahaskell.com/
11:02:12 <byorgey> ponga: well, you can start there ^^^ =)
11:02:27 <jmcarthur> c_wraith: it's more than that, due to aliasing.
11:02:37 <ponga> byorgey: Can I learn both java and Haskell?
11:02:45 <mgsloan> Yeah, becoming a proficient programmer in imperative languages essentially requires you to become a savant of mutable state
11:02:47 <ponga> cos I need Java to co-work with my friend
11:02:59 <mgsloan> So, when those skills don't quite apply naturally, it can freak you out
11:03:03 <jmcarthur> c_wraith: it's a dangerous kind of memory management since it might seem type safe and yet still make everything really confusing
11:03:10 <hpc> ponga: you should learn both languages
11:03:15 <ponga> oh yes I remember, friend said I would be good on imperative
11:03:25 <ponga> dunno why , cos I got no knowledge on programming
11:03:52 <jmcarthur> ponga: your friend seems to say a lot of contradictory things
11:04:19 <ponga> haha
11:04:26 <ponga> he's a good guy, its OK
11:04:31 <ponga> I still want to learn langauges
11:04:44 <mgsloan> Unless he's aware that haskell is the best imperative language ;)
11:05:02 <hpc> ^ this is true ;)
11:05:07 <lambdaKanha> hi , all
11:05:11 <ponga> he is aware
11:05:18 <hpc> (it's not the best functional language though; that honor goes to perl)
11:05:32 <ponga> that haskell is like one of most popular imperative
11:05:45 <benzrf> hi, how can I search the logs?
11:05:55 <lambdaKanha> is ponga a drug addict ?? hah..
11:06:08 <jmcarthur> ponga: (haskell is not considered imperative from the point of view of mainstream programming languages)
11:06:09 <hpc> benzrf: you must oogle the googles
11:06:21 <hpc> oh, or there's a link in the topic
11:06:31 <jmcarthur> ponga: (in fact, imperative programming is restricted to only a subset of haskell)
11:06:35 <benzrf> w/e ill just recursively wget it
11:06:37 <benzrf> or somethin
11:06:42 <hpc> i keep forgetting this channel even has a topic, it changes so rarely
11:07:08 <jmcarthur> it changes most often in response to hackage outages
11:08:01 <lambdaKanha> Thooms r u frm thor movie ?
11:08:09 <ponga> I'm no drug addict lol
11:08:15 <ponga> just a complete noob to computational world
11:08:31 <Thooms> lambdaKanha: wat
11:08:37 <ponga> I need learn anything to be able to draw UML class diagram, that's it
11:08:37 <jmcarthur> lambdaKanha: please stay on topic. if you continue with random comments and question we will begin to consider you a troll
11:08:51 <jmcarthur> lambdaKanha: not a threat, simply an observation
11:09:37 <jmcarthur> @where lyah
11:09:37 <lambdabot> http://www.learnyouahaskell.com/
11:09:39 <jmcarthur> ponga: ^^^
11:09:57 <ponga> learnyouhaskell...
11:10:02 <ponga> so hakell learns me?
11:10:04 <ponga> scary :/
11:10:11 <jmcarthur> ponga: there is an "a" there
11:10:17 <WarzoneCommand> Does anyone have any experience with vinyl?
11:10:17 <ponga> oh
11:10:20 <ponga> oh lol
11:10:23 <jmcarthur> ponga: that title is intended to be kind of broken english
11:10:42 <WarzoneCommand> I'm trying to do something which is maybe slightly strange
11:10:45 <DigitalKiwi> oh well as long as it was intentional then it's okay!
11:10:49 <ponga> I thought it to be intended joke or sometinh
11:11:07 <HugoDaniel> hi
11:11:09 <ponga> Can I still learn from there and I'm like a newbie to computational world
11:11:11 <lambdaKanha> hola
11:11:13 <jmcarthur> "Learn You a Haskell For Great Good!"
11:11:14 <HugoDaniel> is it ok to always use UNPACK ?
11:11:16 <ponga> does it need any background knowledge
11:11:36 <jmcarthur> ponga: LYAH should be pretty good for newbs. you also have #haskell for specific questions if something confuses you :)
11:11:36 <lambdaKanha> ponga pandit do't overdo this .
11:11:51 <SaBer> ponga: http://learnyouahaskell.com/introduction#about-this-tutorial
11:11:53 <jmcarthur> lambdaKanha: what are you going on about?
11:11:57 <lambdaKanha> go for introduction to haskell
11:12:11 <jmcarthur> oh i see
11:12:14 <jmcarthur> lambdaKanha: nevermind me
11:12:32 <ponga> 'tis site is too cute for me
11:12:37 <ponga> too cute drawings :/
11:13:01 <jmcarthur> ponga: it's not specifically meant for kids, if that's what you're afraid of
11:13:13 <zomg> lol
11:13:17 <zomg> the drawings in LYAH are amazing
11:13:19 <ponga> no this is what I'm finding fun of lol
11:13:26 <jmcarthur> ponga: you could just block images :)
11:13:28 <ponga> yes its amazing lol
11:13:58 <lambdaKanha> learn u a haskell rocks !! but first prog book has to be intro to haskell
11:14:00 <ponga> I sense a lot of comical scent from the website
11:14:18 <jmcarthur> ponga: "This tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java, Python …) but haven't programmed in a functional language before (Haskell, ML, OCaml …). Although I bet that even if you don't have any significant programming experience, a smart person such as yourself will be able to follow along and learn Haskell."
11:14:32 <jmcarthur> ponga: but i honestly think you can get by with that book and #haskell
11:14:37 <ponga> flattering :(
11:14:49 <ponga> but thanks i will try
11:15:10 <ponga> I managed learning two forign languages by my own, should be able to handle one or two of computer's tongue too
11:15:47 <lambdaKanha> ponga jmcarthur : what are u doing now ?? consider u as a threat ... just a suggestion ...
11:15:55 <jmcarthur> ...
11:16:10 <lovewithacaveat> what does "purely functional" mean?
11:16:24 <jmcarthur> can anybody else guess what lambdaKanha is doing, or should i be treating this as a nuisance?
11:16:41 <ponga> lambdaKanha: I'm new to computational world, trying to learn haskell if i can
11:16:48 <jmcarthur> lovewithacaveat: free of side effects
11:16:53 <zomg> lovewithacaveat: it's some kind of an euphemism for some kind of a right-wing software ideology I think
11:16:54 <hpc> ponga: ignore lambdaKanha
11:17:03 <ponga> ok
11:17:10 <hpc> jmcarthur: perhaps a warning kick
11:17:22 <lovewithacaveat> jmcarthur: you mean free of unspecified side effects?
11:17:35 <jmcarthur> lovewithacaveat: for some definition of "unspecified" perhaps
11:17:42 <lambdaKanha> free from side effects ?? so what are i/o ?? means u can't print onto a screen
11:17:47 <lovewithacaveat> ponga: what is lambdakahnha saying?
11:17:49 <jmcarthur> lovewithacaveat: i'd rather distinguish between side effects and effects
11:17:59 <ponga> lovewithacaveat: I dunno, I want to ask too
11:18:01 --- mode: ChanServ set +o jmcarthur
11:18:01 <lovewithacaveat> jmcarthur: right
11:18:04 <ponga> what is lambdaKanha saying
11:18:05 --- kick: lambdaKanha was kicked by jmcarthur (lambdaKanha)
11:18:10 <srhb> ponga: Nothing anymore.
11:18:13 <hpc> nothing anymore!
11:18:14 <hpc> lol
11:18:16 <srhb> :P
11:18:18 <chrisdone> sup
11:18:24 <ponga> nothing anymore
11:18:25 <ponga> wow
11:18:27 <ponga> literally
11:18:32 <ponga> excuted :P
11:18:39 <Thooms> :D
11:19:04 --- mode: jmcarthur set -o jmcarthur
11:19:09 <Thooms> btw, can someone take a look at some code of mine
11:19:11 <Thooms> ?
11:19:28 <jmcarthur> Thooms: just put it on lpaste.org and share the link along with a specific question
11:19:51 <Thooms> hum, I don't have any specific question
11:20:02 <Thooms> that's my first "real" project in Haskell
11:20:04 <hpc> just a peer review?
11:20:06 <lovewithacaveat> jmcarthur: so, an imperative program could be "purely functional", if it only has effects, and no side-effects?
11:20:12 <Thooms> exact hpc
11:20:14 <jmcarthur> lovewithacaveat: side effects are basically effects that happen along with evaluation. absense of side effects doesn't mean you can't do anything with the real world, just that it's not driven by evaluation
11:20:35 <hpc> paste it and somebody with time to read through will say something
11:20:44 <lovewithacaveat> jmcarthur: how can something not be driven by evaluation?
11:20:56 <chrisdone> or someone without time who should go to bed but can't resist reading
11:21:01 <Thooms> :D
11:21:05 <sipa> lovewithacaveat: by separating evaluation and execution
11:21:29 <hpc> evaluation being "compute a value", such as basic math
11:21:31 <lovewithacaveat> sipa: what is the difference between evaluation and execution?
11:21:36 <hpc> execution being "do something", like print to the screen
11:21:37 <Thooms> http://git.dan.tf/thooms/cloud for now there isn't millions of loc, but I wanna know if I'm idiomatic so far
11:21:40 <sipa> your program is something that executes (running side-effectful statements), which can trigger evaluating (pure) expressions
11:21:42 <jmcarthur> lovewithacaveat: so for example, a haskell program is actually just a big expression that evaluates to a value which describes what effects you want to the program to have. the evaluation doesn't directly trigger the execution of effects though. it is, in fact, the other way around. execution drives evaluation.
11:22:48 <Thooms> I don't know if I'm clear in the README though
11:23:05 <lovewithacaveat> jmcarthur: sure, but i don't need any machine-side abstractions to be able to do that. that's purely a mental abstraction. so, an imperative program i write could be such that execution drives evaluation, if i write it with that philosophy in mind.
11:23:22 <jmcarthur> lovewithacaveat: a pure expression has no side effects, so you can do nice things like "equational reasoning" which is really just a way of saying you can treat equals like equal, performing whatever substitutions you want with the expression to make thinking about it easier as long as you substitute equals for equal
11:23:24 <jmcarthur> s
11:23:52 <lovewithacaveat> jmcarthur: yeah, but i can apply leibniz's principle even to imperative programs.
11:24:02 <mauke> lovewithacaveat: yes, you could have a purely functional core
11:24:03 <jmcarthur> lovewithacaveat: not when functions like getLine are involved
11:24:09 <mauke> lovewithacaveat: but some languages make that nearly impossible
11:24:23 <lovewithacaveat> mauke: right, mauke.
11:24:34 <jmcarthur> lovewithacaveat: in haskell, getLine is just an object. you can evaluate it all you want without actually getting any lines, and it always evaluates to the same thing
11:24:52 <jmcarthur> by "object" i don't mean like OO, just that it's a value
11:24:55 <lovewithacaveat> jmcarthur, mauke: so what's the difference between a *well designed* imperative programming language, and a *well designed* functional programming language?
11:25:12 <jmcarthur> lovewithacaveat: an imperative language conflates execution with evaluation
11:25:20 * hackagebot purescript 0.2.11.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.11.1 (PhilFreeman)
11:25:25 <mauke> lovewithacaveat: uh, I guess one of them is imperative and the other is functional
11:25:35 <lovewithacaveat> jmcarthur: i thought we just agreed that that's a mental abstraction, not a machine side abstraction?
11:25:38 <mauke> what do I win?
11:25:42 <jmcarthur> lovewithacaveat: i never agreed to that
11:25:48 <chrisdone> mauke: a cookie!
11:26:00 <mauke> lovewithacaveat: languages aren't in machines
11:26:01 <jmcarthur> lovewithacaveat: it's a meaningful property of a language.
11:26:01 <lovewithacaveat> jmcarthur: so what machine side abstractions does a functional language make, that an imperative language does not?
11:26:12 <mauke> lovewithacaveat: what's a machine?
11:26:33 <lovewithacaveat> mauke: the thing that executes your program
11:26:43 <mauke> that would be me
11:26:43 <jmcarthur> lovewithacaveat: "machine abstractions" is a very strange phrase to me
11:27:02 <lovewithacaveat> never mind. thanks for the conversation everyone.
11:27:07 <mauke> lovewithacaveat: languages exist without programs; programs exist without execution
11:27:49 <jmcarthur> lovewithacaveat: in an imperative language, printf("foo") will actually print out "foo" when you evaluate it. in haskell, putStrLn "foo" is just a value.
11:28:14 <mauke> I think "functional language" also entails functions as first class values
11:28:32 <mauke> and an emphasis on working with functions
11:28:34 <jmcarthur> lovewithacaveat: so i can actually define   x = putStrLn "foo"   and pass x around, compose with other things, etc.  x is a thing which when executed will print "foo"
11:30:05 <jmcarthur> mauke: yeah, "pure" and "functional" make sense to me in isolation, but i never understood why "purely functional" is a thing. the best i can think of is that "functional" in that case means "like functions in math", but then "purely" is redundant.
11:30:42 <zipper> What does one call the "::" and "=>" in a function signature? That's what declaring the function of a type is called right?
11:31:08 <mauke> jmcarthur: "purely" clearly means you don't have procedures
11:31:13 <c_wraith> jmcarthur: "purely" was added post-hoc to distinguish from languages like lisp calling themselves functional
11:31:24 <Thooms> zipper: "::" is the typing operator ("has type") and "=>" introduces constraints on types
11:31:30 <jmcarthur> zipper: "::" means "has type". "=>" means "constrains"
11:31:44 <zipper> What are they called?
11:31:52 <jmcarthur> the symbols?
11:31:57 <zipper> They don't have like haskell jargon words?
11:31:59 <chrisdone> mauke: funny that scheme is the only language that uses the term procedures when it's the most accurate description to me
11:32:01 <jmcarthur> you mean like the syntax?
11:32:03 <zipper> Yes the symbols
11:32:08 <jmcarthur> not really
11:32:23 <jmcarthur> "double colon" and "double-bar arrow" i guess
11:32:25 <c_wraith> yeah, no special terms for them. They're just syntax.
11:32:28 <jmcarthur> or somesuch
11:32:40 <zipper> Thanks
11:32:45 <chrisdone> i pronounce "::"  as "has type"
11:33:00 <zipper> chrisdone: That's what learn you a haskell said.
11:33:04 <jmcarthur> yeah. "has type" and "constrains" is what i normally call them
11:33:04 <SaBer> or "of type"
11:33:46 <jmcarthur> "=>" also has a different meaning when thinking about specific compiler implementations of type classes, like dictionary passing
11:33:57 <zipper> of type is more correct technically because they don't own the type but rather are a subset of it.
11:34:03 <chrisdone> c_wraith: i added files =p http://tryhaskell.org/
11:34:06 <jmcarthur> in that case you can think of "=>" as being like "->" where the left side is a dictionary
11:34:13 <simon> can I overload (*) to work for my very simple type by declaring it an instance of Num?
11:34:15 <zipper> jmcarthur: We have dictionaries in haskell?
11:34:25 <c_wraith> chrisdone: that's pretty impressive
11:34:26 <etrepum> chrisdone: now tryhaskell needs a multi-line input :)
11:34:27 <jmcarthur> zipper: different thing
11:34:35 <jmcarthur> zipper: but we have maps, which is basically what you mean i think
11:34:37 <mauke> zipper: no, in compilers
11:34:46 <jmcarthur> zipper: and hashtables and whatever other container you want
11:34:51 <chrisdone> etrepum: yeah =p
11:35:08 <zipper> Dictionaries map keys to values so maps might be it
11:35:20 <mauke> zipper: these "dictionaries" are vtables
11:35:33 <c_wraith> chrisdone: does that mean the environment also contains a mapping from path -> contents now?
11:35:38 <jmcarthur> s/vtables/records/
11:35:52 <zipper> mauke: lol bro I am confused right now.
11:36:03 <chrisdone> c_wraith: yup. and that map is stored in the browser's localStorage. just 'cause it's nice
11:36:52 <c_wraith> chrisdone: good stuff
11:37:29 <novodinia> I was reading this older article http://blog.samibadawi.com/2013/02/scala-vs-haskell-vs-python.html and it mentions that Haskell is a "very small language." I've heard this before, but it's taken me awhile to wrap my head around all the new concepts introduced by Haskell. Would someone speak on this topic?
11:37:50 <chrisdone> at its core, it is indeed very small
11:38:05 <chrisdone> haskell can be condensed down to System F(c)
11:38:19 <jmcarthur> novodinia: haskell's core is very small and simple, although there are tons of extensions, and even the small core has enough depth that you never really stop learning properties about it
11:38:27 <chrisdone> everything else is really kind of syntactic sugar and analysis
11:39:21 <BMeph> ...and libraries! ;)
11:39:21 <chrisdone> although i suppose being realistic haskell is actually large in the sense of the language space it does cover
11:39:38 <chrisdone> it's just not many languages can claim to boil down to a simple core
11:39:42 <jmcarthur> novodinia: it hits a sweet spot in terms of simplicity and power where it turns out there's actually a *ton* you can express with it
11:39:56 <jmcarthur> novodinia: feasibly, that is
11:41:42 <c_wraith> novodinia: haskell is.. algebraic data types, numeric/character types, pattern matching, type inference, type classes, and a very primitive module system.
11:41:53 <etrepum> novodinia: Python has a lot of stuff built-in to the language that is done in libraries or simply not needed in Haskell (some examples might be __special_methods__, iterators, metaclasses, object protocol, dict/set syntax, separate bytes/text syntax, slice syntax…)
11:42:06 <BMeph> Usually, when some language is called "small," it means that certain facilities are not built in, but the language is powerful enough to "emulate" the ability by writing a library for it.
11:42:26 <BMeph> novodinia: See the above. ^^
11:42:30 <jmcarthur> to be fair, python is largely syntax sugar too
11:42:51 <c_wraith> novodinia: there are a lot of details involved, but nearly everything (before you add extensions) is a combination of those things.
11:42:57 <chrisdone> lisp is similar
11:44:11 <chrisdone> ish
11:44:17 <etrepum> Python's syntax sugar is fixed though, Haskell allows you to define your own (which is a blessing and a curse)
11:44:37 <chrisdone> i suppose there's a difference where a haskell compiler can very reasonably compile everything down to core and do all the optimizations it needs to there
11:44:46 <chrisdone> can python or lisp make the same claim?
11:45:06 <Fuuzetsu> spoiler: no
11:45:15 <jle`> aw you ruined it for me
11:45:38 <Fuuzetsu> jle`: the answer is ‘no’ 95% of the time
11:45:48 <mgsloan> SPJ's spineless tagless g machine paper makes a number of comparisons to lisp
11:45:49 <c_wraith> Hmm.  I guess that inference and type classes both disappear when you go from haskell to core.
11:46:05 <mgsloan> err, hit enter too soon.  I mean to lisp compilation / runtimes
11:46:21 <danharaj> and then even types disappear when you go down to STG
11:46:24 <c_wraith> But the inference and class mechanisms are an important part of how you pick what core to generate
11:46:24 <mgsloan> So I imagine that some lisps have a very lightweight intermediate language
11:46:32 <danharaj> and then the notion of a functional program disappears when you go down to c--
11:46:43 <novodinia> Thank you everyone for the responses. c_wraith What is the difference between haskell and core?
11:46:56 <chrisdone> right. technically all lisp can essentially compile down to COND, IF, LAMBDA, SETQ and some IO built-ins
11:46:58 <novodinia> c--?
11:47:05 <mgsloan> So I guess the distinction would be that lisp isn't usually typed, so you don't get to have a typed core :)
11:47:18 <chrisdone> c_wraith: that's true. type classes have to be dealt with
11:47:21 <Fuuzetsu> chrisdone: I don't think we need IF and COND at the same time
11:47:37 <chrisdone> fuuzetsu: i don't think that was my point
11:47:45 <c_wraith> novodinia: haskell is the language as specified.  core is either a generic concept, or the specific ghc core generated during ghc's compilation. It's a much more verbose language, explicit in everything, with far fewer features than haskell has, but with a straightforward translation from haskell
11:48:38 <chrisdone> i think it's trickier without purity do to such boiling down
11:48:52 <c_wraith> novodinia: in the case of GHC, it does little besides typecheck before converting to core.  core is the level at which it does high-level optimizations
11:49:02 <chrisdone> i'm not aware that SBCL has its own intermediate 'small' language, because it needs to take advantage of seeing the actual concrete syntax used and optimize accordingly
11:49:08 <danharaj> when do rewrite rules fire?
11:49:18 <simpson> chrisdone: Counterexample: E.
11:49:20 <chrisdone> e.g. the LOOP macro *could* compile down to a bunch of nested COND's, but i doubt that it does
11:50:01 <chrisdone> simpson: E. coli?
11:50:05 <mgsloan> danharaj: That's an interesting question.  I'd imagine it's after translation to core, so that they can benefit from inlining, and de-sugaring-equivalent expressions get the same optimizations
11:51:00 <mgsloan> I think this is the way it is, because it's a bit fiddly to get them to fire
11:51:44 <chrisdone> hmm rules can generate bad code, so they're type checked
11:51:46 <chrisdone> probably that's pre-core
11:51:47 <simpson> chrisdone: No, E. The language. Pure but not in the way that you would consider pure. Compiles to a very small core language.
11:52:08 <mgsloan> chrisdone: Hrmm, can't you typecheck the rules themselves?
11:52:22 <mgsloan> I've never seen a type error that happens due to a rewrite rule firing
11:52:40 <chrisdone> i'm just quoting the manual
11:52:45 <mgsloan> Oh, now ay
11:53:16 <mgsloan> Well, I've never used em them myself, just happy to be a consumer of libraries that do
11:53:52 <mgsloan> So maybe never seeing such an error is just a symptom of being a consumer of good, law abiding libraries
11:54:28 <novodinia> Thanks again to everyone!
11:54:56 <chrisdone> the manual isn't really clear on whether rules fire before or after core
11:55:30 <mgsloan> It's probably after desugaring but before core
11:55:34 <chrisdone> ah, in the simplifier perhaps
11:55:46 <mgsloan> Yup!  You even get to specify a phase of the simplifier if you want
11:56:41 <mgsloan> While rules are typechecked, if you mess them up, I imagine you can get a type error in the resulting core
11:58:38 <mgsloan> It'd be kinda neat if ghc allowed "inline core" like having inline asm in C.  Maybe there are no benefits to this, though, and if you want that you should just write corelike haskell
11:58:41 <chrisdone> yeah, brian and dons stole all the easy libraries to write rules for =p
11:58:48 <mgsloan> :D
11:58:49 <chrisdone> we'll have to be more creative to have a use-case for rules
11:59:30 <chrisdone> yeah, niel mitchell's post made me think that would be fun
11:59:53 <levi> chrisdone: Common Lisp already has low-level constructs like tagbody and go, so you don't need a separate low-level language, you just need to pick a core set of special operators to build natively.
12:00:57 <chrisdone> levi: that's not the use-case for a separate low-level language, it's to narrow the scope of what's expressible so you have less concerns to deal with
12:02:22 <chrisdone> levi: so the fact that CL's high-level language has some goto-like procedures is somewhat orthogonal, i think
12:03:49 <levi> What I mean is that every Lisp *has* a core set of operators that form a core-like language and the rest of it is macro-transformed to that core. It's not a *separate* language because the core is still accessible from the high-level language.
12:04:51 <chrisdone> that's true in theory
12:05:42 <levi> I think it's true in practice as well, but the set of primitive operators isn't fixed between implementations.
12:05:59 <chrisdone> ime most things aren't actually implemented in macros
12:06:07 <chrisdone> that'd probably make it slower to compile
12:06:26 <chrisdone> but the spec just names them "special operators" anyway
12:06:26 <chrizz_> hi, I noticed aeson doesn't successfully parse json with hex literals in strings, like "\x3c"
12:06:40 <chrizz_> not sure if this is even technically valid json - anyone know?
12:07:01 <levi> There are some JSON validators you could run your test code through.
12:07:27 <DigitalKiwi> http://json.org/
12:07:27 <levi> http://jsonlint.com/
12:07:35 <chrizz_> thanks
12:07:50 <chrizz_> looks like "\\x3c" is valid json but "\x3c" isn't
12:07:57 <chrizz_> and i'm getting "\x3c" from this api :(
12:08:17 <danharaj> bos is pretty faithful to specs in his parser libraries.
12:08:25 <levi> Ahh, the perils of writing stritcly conforming parsers.
12:08:27 <chrizz_> google.com/dictionary/ api, if anyone was curious
12:09:09 <chrisdone> levi: the main different to sum it up is that e.g. SBCL doesn't generate an intermediate language, so it's hard to make a JS backend. whereas ghcjs…
12:10:11 <augur_> Cale: can i ask you about fast-and-loose?
12:10:13 <chrisdone> levi: but i didn't look much into it, perhaps there's a phase you can hook into to get code that only uses goto and if and primitives
12:10:33 <bennofs> @hoogle modifyM
12:10:33 <lambdabot> Control.Concurrent.MVar modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
12:10:34 <lambdabot> Control.Concurrent.MVar modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
12:10:34 <lambdabot> GHC.Conc.Sync modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
12:10:44 <augur_> or really, anyone who's familiar with the details of how partiality and equational reasoning interact
12:10:50 <bennofs> @hoogle (s -> m s) -> StateT s m a
12:10:50 <lambdabot> No results found
12:10:57 <bennofs> Is there no such function?
12:11:10 <bennofs> @ty state . (,())
12:11:11 <lambdabot>     Couldn't match type `(a0, ())' with `s0 -> (a1, s0)'
12:11:11 <lambdabot>     Expected type: a0 -> s0 -> (a1, s0)
12:11:11 <lambdabot>       Actual type: a0 -> (a0, ())
12:11:14 <bennofs> @ty state . fmap (,())
12:11:15 <lambdabot> MonadState () m => (() -> a) -> m a
12:11:17 <augur_> why is this not the case:   _|_  /=  (fst _|_, snd _|_)
12:11:20 <levi> chrisdone: Yeah, that seems reasonable. Though someone wrote a fay-like CL-to-JS compiler that worked in SBCL very early on in the history of compile-to-javascript days.
12:11:21 <bennofs> @ty state . fmap ((),)
12:11:22 <lambdabot> MonadState a m => (a -> a) -> m ()
12:11:32 <bennofs> @ty state . fmap (fmap ((),))
12:11:33 <lambdabot> MonadState ((), a1) m => (((), a1) -> (a, a1)) -> m a
12:11:39 <augur_> gee thanks bennofs
12:11:40 <augur_> :(
12:11:50 <bennofs> augur_: sorry
12:12:40 <Cale> augur_: You can try
12:12:47 <Cale> oh
12:12:52 <Cale> sure
12:12:56 <bennofs> Ok, so does this function live somewhere? StateT . fmap (fmap ((,) ()))
12:12:58 <trillioneyes> augur_: that's just standard laziness
12:13:11 <trillioneyes> oh wait
12:13:15 <augur_> trillioneyes: i dont see why that is true in a lazy language like haskell tho
12:13:15 <Cale> > case (undefined, undefined) of (x,y) -> 5
12:13:17 <lambdabot>  5
12:13:23 <Cale> > case undefined of (x,y) -> 5
12:13:25 <lambdabot>  *Exception: Prelude.undefined
12:13:26 <hattmammerly> what are the a0s, and m0s and whatnot that I see in ghc error messages sometime?
12:13:31 <BMeph> augur: IANAC (I Am Not A Cale), but I'd say that just looking at it, that (fst _|_, snd _|_) is "more defined" than just _|_ is.
12:13:35 <Cale> ^^ this shows that undefined is not equal to (undefined, undefined)
12:13:35 <trillioneyes> By "not the case", did you mean the equality actually holds?
12:13:39 <augur_> Cale: i see.
12:14:00 <augur_> Cale: so it's not laziness, per se, but how non-termination relates to case analysis
12:14:19 <Cale> Or at least, it serves as an explanation for why we want our semantics to tell between _|_ and (_|_, _|_)
12:14:29 <augur_> Cale: indeed
12:14:45 <chrisdone> levi: interesting
12:14:55 <augur_> ok. so in principle you could modify haskell so that you can indeed case on that without it being problematic
12:14:58 <trillioneyes> augur_: (,) undefined undefined is in WHNF, so it doesn't need to be evaluated any further for case analysis
12:15:08 <Cale> Some people consider this a bit of a mistake in how Haskell works. We don't have an "unlifted" pair type in Haskell
12:15:17 <levi> chrisdone: Parenscript is the name of the project
12:15:19 <Cale> which means that we don't really have honest categorical products
12:15:35 <Cale> But, well, that's what the fast and loose stuff is about :)
12:15:38 <augur_> trillioneyes: right, but eta expansion (if its forced, and not merely an observation) means thats ok
12:15:40 <chrisdone> levi: huh, are you sure? i thought that was a bunch of macros that make javascript parenthesisy
12:15:52 * chrisdone checks
12:16:11 <Cale> augur_: and yeah, that would actually be really sensible, it's just not what we ended up doing
12:16:36 <trillioneyes> Case analysis only forces to WHNF... or do you mean something that I'm missing?
12:16:37 <chrisdone> levi: cool
12:16:37 <augur_> trillioneyes: i mean, if you make it enforcedly true that p == (fst p, snd p) then undefined :: (a,b) is in WHNF too since its enforced to be = to (fst undefined, snd undefined)
12:17:02 <trillioneyes> ah, right
12:17:27 <trillioneyes> Cale, augur_: how would you go about forcing this equality? Would making (,) strict in both arguments work?
12:17:41 <augur_> Cale: aha ok. so the FastAndLoose paper is more to do with the particular choices that motivate the partial orders, rather than any deep facts that force partial orders
12:17:49 <augur_> trillioneyes: no no
12:17:56 <trillioneyes> > case undefined `seq` undefined `seq` (undefined,undefined) of _ -> True
12:17:56 <BMeph> You'd have to have a genuinely uninhabited type in Haskell for that to work.
12:17:57 <lambdabot>  True
12:18:02 <augur_> trillioneyes: your case widget just has to know about eta expansion
12:18:32 <chrisdone> levi: i've a lisper buddy who used that in a web project, but he said it was just a dumb translator. go figure
12:18:52 <augur_> Cale, trillioneyes: tho im not entirely sure its actually possible to do this in practice, now that i think about it
12:19:00 <trillioneyes> hmm
12:19:01 <augur_> undefined is easy enough, but non-termination is not
12:19:02 <chrisdone> levi: at one point i was interested in compiling haskell to lisp =p
12:19:11 <Cale> I think you need to do parallel evaluation
12:19:15 <chrisdone> levi: for dat code reloading
12:19:23 <augur_> (this is another reason why i think we shouldnt conflate undefinedness and non-termination!)
12:19:35 <trillioneyes> Why is undefined `seq` undefined `seq` (undefined,undefined) defined?
12:19:42 <augur_> Cale: maybe you could do some kind of eta-long-ification
12:19:43 <chrisdone> for a community that came from lisp backgrounds, haskell is surprisingly lacking in lisp's coolest parts
12:19:56 <Cale> The idea is you still want (_|_, True) to be distinct from _|_
12:20:03 <Cale> but (_|_, _|_) needs to be _|_
12:20:13 <augur_> Cale: right thats true
12:20:22 * chrisdone goes to watch Aliens
12:20:32 <BMeph> chrisdone: What do you consider lisp's "coolest parts" to be?
12:20:38 <augur_> Cale: that motivates a partial order of some sort
12:20:40 <BMeph> ...never mind.
12:20:42 <jmcarthur> i wonder what the behavior of unboxed typles is with respect to seq
12:20:46 <jmcarthur> *tuples
12:20:53 <Cale> So, when you pattern match on (x,y), the thing that the evaluator probably ought to do is to start evaluating x and y in parallel, and match as soon as either evaluates.
12:21:09 <jmcarthur> if that's even allowed. i always forget the rules
12:21:15 <Cale> (That's a little crazy though ;)
12:21:26 <c_wraith> jmcarthur: an unboxed tuple can't be an argument to a function
12:21:27 <jmcarthur> Cale: unamb!
12:21:38 <jmcarthur> c_wraith: figures
12:21:39 <c_wraith> jmcarthur: the only thing you can do with an unboxed tuple is pattern-match
12:21:54 <jmcarthur> yeah i was thinking it was something like that
12:21:54 <Cale> augur_: There already is a partial order (a directed complete partial order)
12:22:13 <Cale> augur_: It's just that _|_ is currently strictly less than (_|_, _|_), and we want them to be equal
12:22:28 <augur_> Cale: mm. yeah. but better instead to do something like this:   case p :: (a,b) of (x,y) -> z   ~>   z[fst p/x, snd p/y]
12:22:55 <Cale> Oh, I suppose you could just say every match is lazy, yeah
12:22:57 <augur_> Cale: but i think that would require that you actually have basic elims
12:23:05 <Cale> We could do that right away
12:23:08 <augur_> because how is fst/snd defined
12:23:19 <Cale> Just say whenever you match against (x,y) replace the pattern with ~(x,y)
12:23:40 <verement> > case (undefined, undefined) of (_, _) -> 5
12:23:41 <lambdabot>  5
12:24:11 <Cale> That would make the treatment of undefined and (undefined, undefined) the same, but in a different way :)
12:24:17 <Cale> (probably better way!)
12:24:25 <augur_> Cale: we want all non-fringe expansions to be equal, actually
12:24:26 <Cale> > case undefined of ~(x,y) -> 5
12:24:27 <lambdabot>  5
12:24:36 <Cale> > case (undefined, undefined) of ~(x,y) -> 5
12:24:37 <lambdabot>  5
12:25:03 <augur_> Cale: in that, undefinedness should only be visible in the places where the constructor form isn't forced
12:25:13 <Cale> So, yeah, if we had a primitive pair type for which the semantics of matching against (x,y) were the same as matching against ~(x,y), then we'd be good.
12:25:16 <levi> chrisdone: I think that Haskell runtime based on the luajit engine might be interesting for that.
12:25:25 <augur_> in a sense, we lose canonicity for pairs because of this
12:25:48 <Cale> augur_: Well, it would be giving special treatment operationally to types with a single constructor, if we did it universally.
12:25:52 <augur_> i mean, even tho we know we have a pair, and there's only one constructor for pairs, the extra pair value _|_ is naughty
12:26:07 <augur_> Cale: well no, i mean, you can make everything eta long
12:26:09 <augur_> not just pairs
12:27:29 <Cale> This would also effectively do away with newtype
12:27:39 <augur_> oh?
12:27:57 <Cale> The only difference between newtype and data is the semantics of matching in this exact respect
12:28:05 <augur_> how so?
12:29:14 <trillioneyes> But we don't use newtype for the laziness semantics, do we?
12:29:19 <Cale> http://www.haskell.org/onlinereport/decls.html#sect4.2.3
12:29:28 <trillioneyes> It seems like the operational consequences are more practically interesting
12:29:31 <Cale> trillioneyes: The laziness semantics enable the optimisation
12:29:57 <trillioneyes> hmmm, so you would be able to do the newtype optimization with every type that has a single constructor?
12:30:27 <trillioneyes> That seems like it would actually be desirable, though perhaps unavoidable laziness semantics might not be worth it...
12:31:06 <Cale> yeah, we'd probably end up wanting a way to introduce lifting explicitly then
12:32:35 <Cale> and I'm not sure you could really do that optimisation with every single constructor type... nontrivial products would still have to be compiled differently
12:32:53 <trillioneyes> It would be silly if lifting was a typeclass
12:33:10 <trillioneyes> class Lifted a where undefined :: a; undefined = undefined
12:33:14 <Cale> But single constructor single field datatypes would become semantically equivalent to newtypes if we made them unlifted, so might as well apply the optimisation
12:33:15 <trillioneyes> I don't think that really works though
12:33:41 <trillioneyes> Because as someone mentioned, you can still invoke nontermination manually to get phantom values of types that don't implement Lifted
12:33:48 <Cale> Well, by "lifted", I mean that C undefined is different from undefined
12:33:59 <Cale> where C is the data constructor
12:34:00 <trillioneyes> oh
12:34:12 <trillioneyes> I was thinking "lifted" means "contains undefined"
12:34:42 <trillioneyes> Or rather, contains bottom
12:34:43 <Cale> Or more generally, the application of the data constructor to all undefined parameters is something distinct from undefined
12:34:53 <trillioneyes> hmm
12:35:54 <trillioneyes> Anyway, I think I need to go perform banal tasks for a while
12:36:12 <glaebhoerl> question: is there ever a use case for doing `data Foo x a` where `x` is a phantom type whose sole purpose is to have a type class instance associated with it? (i.e. `blah :: SomeClass x => Foo x a -> ...`)
12:36:26 <Cale> glaebhoerl: Yes.
12:36:28 <glaebhoerl> I feel like there must be a better pattern to accomplish the same things, but I don't recall what it is
12:36:53 <glaebhoerl> Cale: hmm, and what is it? :)
12:37:30 <BMeph> Cale: Isn't that kindo-of why ST exists? ;)
12:37:50 <BMeph> (^ glaebhoerl, too)
12:38:02 <glaebhoerl> nah, ST is different, there you're using it for parametricity
12:38:16 <Cale> glaebhoerl: Well, there are a number of places I've seen that used. It's especially a fairly useful technique when you have a bunch of different contexts in which you have the same bunch of functionality, e.g. maybe you want to have things work differently in a "live" environment from an "editor" or something.
12:38:19 <glaebhoerl> not for accessing a type class instance on `s`
12:38:29 <glaebhoerl> hmm
12:39:11 <glaebhoerl> Cale: do the `Live` and `Editor` types have instances with methods in them in these cases?
12:39:13 <Cale> You can even make that a type family or data family perhaps
12:39:39 <Cale> If you want different data structures while working in Live vs. while working in Editor
12:40:01 <Cale> and that lets you write some things which are polymorphic and work equally in both
12:40:14 <Cale> while defining others with classes/instances
12:41:03 <Cale> Repa does some pretty cute things that way
12:41:08 <Cale> http://hackage.haskell.org/package/repa-3.2.3.3/docs/Data-Array-Repa.html
12:41:35 <Cale> all the single-letter types are constructorless
12:41:59 <Cale> They're type level tags for explaining something about what kind of representation your arrays have
12:43:32 <tautologico> so where are the test runners in QuickCheck 2?
12:43:39 <glaebhoerl> basically I'm asking because the Rust folks are planning to do things like `struct Vec<T, A = DefaultAllocator> { ... }`, and adding default type arguments explicitly for this purpose, and it makes me uneasy because (a) I haven't ever wanted default type arguments in Haskell and (b) it's the same solution C++ uses, and C++ doesn't always converge on the best solution
12:43:50 <glaebhoerl> but if there's a better solution, it's not obvious to me what it is
12:43:59 <glaebhoerl> see e.g. http://www.reddit.com/r/rust/comments/1uhq4h/dst_take_5/ceinas9
12:44:38 <Cale> I don't see why you'd want default type parameters over plain type synonyms
12:45:03 <glaebhoerl> hmm, that's a good point
12:45:10 <Cale> I guess *maybe* it could lead to better error messages?
12:45:38 <Cale> But not if you're a little bit smart about trying to find a type synonym which simplifies things.
12:46:15 <jmcarthur> i really like a lot of rust, but they have also done many things i strongly disagree with
12:46:18 <tautologico> there would have to be lots of type synonyms though
12:46:19 <SaBer> glaebhoerl: My only negative experience with default template parameters in C++ is when using template template parameters. I.e. the number or parameters the template takes would be in the above case 2, while it looks like 1 most of the time...
12:46:39 <SaBer> s/number or/number of/
12:46:46 <glaebhoerl> SaBer: yep, that's my main concern as well
12:47:07 <Cale> tautologico: I guess if you plan to have a lot of default parameters which people are frequently specifying only a subset of
12:47:09 <tautologico> jmcarthur: like what?
12:47:11 <glaebhoerl> but I get uneasy whenever they want to take ideas from C++ which Haskell manages to avoid
12:47:16 <Cale> But... who does this?
12:47:37 <jmcarthur> tautologico: e.g. no way to have a mutable field in an *otherwise* immutable structure
12:47:42 <tautologico> glaebhoerl: Rust and Haskell have very different design parameters
12:47:54 <jmcarthur> tautologico: and worse, no way to have it the other way around
12:47:57 <Cale> I don't understand what Rust is meant to be for.
12:48:27 <glaebhoerl> Cale: to not have to use C++
12:48:31 <glaebhoerl> also, type- and memory safe
12:48:42 <tautologico> jmcarthur: in my experience you don't need that... you specify mutability for the whole structure... initially I wanted to have individual mutable fields because of my experience with ML
12:48:43 <Cale> I seem to be doing quite well at that without it ;)
12:48:44 <jmcarthur> Cale: the intent is safe, tight memory control
12:49:18 <glaebhoerl> Cale: ...without having to use a garbage collector.
12:49:48 <tautologico> but I think it makes sense that if you want mutability you have to mark the whole thing as mutable, not hide a mutable field inside a structure
12:49:59 <NemesisD> are there any hashmap implementations in haskell with O(1) lookup?
12:50:07 <jmcarthur> tautologico: there have been many times i wanted it, in precisely the way ML has.
12:50:17 <jmcarthur> tautologico: i understand that it makes the compiler's job harder
12:50:38 <Cale> I don't trust myself to manage memory any better than a GC would in the case of any nontrivial program.
12:50:41 <glaebhoerl> jmcarthur: there's a type for that: http://static.rust-lang.org/doc/master/std/cell/index.html
12:51:00 <glaebhoerl> (or rather two)
12:51:17 <tautologico> I started playing with rust thinking I would use GC all the time, but actually I almost never use it
12:51:23 <Cale> NemesisD: I would say there are no hashmap implementations anywhere with O(1) lookup
12:51:41 <tautologico> unique pointers and regions work quite well for most situations
12:51:47 <levi> Cale: The point of Rust is to tell you when you manage memory wrongly without a GC. And also to allow you to use a GC if you want to.
12:51:53 <Cale> NemesisD: If you somehow end up with O(1) there, you've fucked up your asymptotic analysis somehow with unreasonable assumptions ;)
12:52:02 <jmcarthur> tautologico: one of my first rust projects was implementing a LC interpreter. i definitely wanted GC then ;)
12:52:08 <jmcarthur> tautologico: a lazy one, that is
12:52:08 <Cale> (but it happens often enough)
12:52:20 <NemesisD> Cale: oh i thought most impure languages had O(1) lookup
12:52:31 <Cale> NemesisD: They ignore the cost of computing the hash function
12:52:32 <NemesisD> are they being misleading
12:52:41 <erisco> why does Enum not require Ord?
12:52:45 <jmcarthur> tautologico: also, it was the STLC, and i was trying to use the type system to help me, but due to monomorphization i was unable to define polymorphic recursive functions :(
12:52:56 <NemesisD> Cale: that's dependent on the size of the hashmap?
12:53:01 <Cale> Yes
12:53:02 <tautologico> jmcarthur: the option definitely needs to be there, but overall it seems to be used much less that people anticipate
12:53:20 <tautologico> *than
12:53:20 <jmcarthur> NemesisD: both Cale and impure languages are being misleading here ;)
12:53:25 <Cale> NemesisD: It's a general result that any function whose range has n elements, must take O(log n) time
12:53:32 <Cale> (at least)
12:53:39 <NemesisD> hmm ok
12:53:59 <Cale> Because if you have less than O(log n) time, you can't even look at log_2 n bits of your input
12:54:15 <Cale> and so you can't tell n distinct inputs apart
12:54:18 <NemesisD> my coworker wrote a god awful ugly reporting program in go, so i must now show him up via either clarity or performance (preferably both) with haskell
12:54:21 <jmcarthur> NemesisD: basically, the more bits in the representation the more work it is to do the lookup, but the number of bits is generally a constant anyway. the *real* problem with hash tables is that most implementations are actually O(n)...
12:54:47 <NemesisD> O(n) on what?
12:54:49 <Cale> jmcarthur: Right, well, I was being generous :)
12:54:55 <jmcarthur> NemesisD: number of elements
12:55:03 <NemesisD> erm O(n) on insert and lookup?
12:55:09 <jmcarthur> yes and yes
12:55:18 <NemesisD> yikes
12:55:25 <jmcarthur> but with very low probability of hitting that case
12:55:47 <jmcarthur> this is mainly because most implementations have linked lists in the buckets
12:55:47 <Cale> NemesisD: They do something silly and assume that you'll never have more than M elements. Well, every operation on anything is O(1) if you bound the size of memory :)
12:55:49 <NemesisD> so average case O(1) worst case O(n)?
12:56:06 <NemesisD> i've been evaluating using http://hackage.haskell.org/package/quickset-0.1.0/docs/Data-QuickMap.html on this
12:56:17 <jmcarthur> you could put something more intelligent in the buckets instead to get a better worst case running time
12:56:18 <NemesisD> they are query only which is fine in my case
12:56:36 <jmcarthur> but you would lose some constant time efficiency (on current hardware, at least)
12:56:43 <Cale> small case O(log(n)) worst O(n), with naive hashtables
12:57:05 <Cale> Assuming your hash takes O(log n) time, which is reasonable
12:57:07 <jmcarthur> i think the average case O(log n) is a pretty sneaky argument, really
12:57:08 <NemesisD> quickmap has some scary code
12:57:18 <jmcarthur> it conflates two different machine models
12:57:20 <NemesisD> lots of unsafeThaw and undefineds :P
12:57:57 <Cale> Okay, so suppose you have a hash function which separates items into B possible buckets
12:58:01 <jmcarthur> in one model (the one we normally incorrectly use), memory dereferencing takes constant time. in another, it takes logarithmic time
12:58:19 <jmcarthur> but to compare, say, hash tables with maps, you have to penalize maps in the same way
12:58:20 <Cale> Then it takes O(log B) time at least to execute
12:58:32 <Cale> I'm not even talking about dereferencing pointers
12:58:38 <Cale> I'm talking about the cost of computing the hash
12:58:42 <jmcarthur> you mean the hash function
12:58:44 <jmcarthur> right
12:58:45 <Cale> yeah
12:58:48 <verement> http://hackage.haskell.org/package/unordered-containers-0.2.3.3/docs/Data-HashMap-Strict.html
12:59:23 <levi> The real problem is that asymptotic analysis is a bit disconnected from real-world usage, and it's easy to believe it means something different than it does if you don't think carefully about it.
12:59:30 <jmcarthur> but a comparison based map might have to traverse the whole key (of size at log n) log n *times*
12:59:32 <Cale> and if you want to have at most O(1) collisions, so that on average the number of items in each bucket is bounded by a constant
12:59:41 <jmcarthur> a trie is similar to a hash table here, at least
12:59:59 <Cale> then your number of buckets had better be a constant multiple (fraction) of the number of entries total
13:00:32 <Cale> i.e. B had better be a*n
13:00:57 <Cale> So computing the hash, which is O(log B) is also O(log n)
13:01:59 <Cale> That's assuming that your hash is particularly fast. I don't even know if it's very realistic for good hashes.
13:02:00 <jmcarthur> (it is also true the deferencing a pointer is also O(log n) in the size of the addessable space)
13:02:05 <Cale> yes
13:02:09 <Cale> That's also true
13:03:03 <jmcarthur> fuzzy details like these tend to lead me toward the incorrect but practical assumption that O(log n)=O(1)
13:03:10 <Cale> yeah
13:03:18 <Cale> There actually is an appropriate O for that
13:03:26 <Cale> which is Õ
13:03:39 <Cale> (don't know if you can see that, it's O with tilde over it)
13:03:51 <levi> Huh, I see an A with a tilde over it.
13:03:56 <Cale> which basically means "ignore log factors"
13:04:02 <jmcarthur> cool!
13:04:16 <geekosaur> levi: your IR client isn't using UTF8
13:04:18 <geekosaur> *IRC
13:04:22 <jmcarthur> is there a pronouncable name for it?
13:04:34 <Cale> soft-O
13:04:48 <glaebhoerl> is that like "uh" without the h?
13:04:57 <jmcarthur> cool thanks. i must look for some literature (since it kind of changes things a lot)
13:05:13 <Cale> I don't know what language the character is actually used in, or how it's pronounced
13:05:45 <Cale> http://en.wikipedia.org/wiki/Big_O_notation#Extensions_to_the_Bachmann.E2.80.93Landau_notations
13:06:46 <levi> geekosaur: It is, actually, but it may not be set up very well. Many non-ASCII codepoints show up correctly, but some don't, and I haven't taken the time to dig up the misconfiguration.
13:08:09 <geekosaur> decoding UTF8 with stray A-hat or A-tilde is a classic symptom of mis-decoding as iso8859-N
13:09:13 <hattmammerly> I'm fighting with the type system again. Could somebody help me understand my irc bot better? Error message at the bottom, questions at the top: http://bpaste.net/show/eqGHJWia1darrsVvzez8/
13:10:58 <geekosaur> you're having a general problem with monads
13:11:07 <hattmammerly> doesn't show me, haha
13:11:12 <hattmammerly> shock*
13:11:14 <geekosaur> in particular, asks is a monadic calculation, you cannot use it directly
13:11:26 <hattmammerly> oh, that makes sense
13:11:27 <geekosaur> x <- asks game; if x == ...
13:13:41 <hattmammerly> okay, actually, that clears a lot up for me, haha. The movement of the bot state is the former case, then. okay.
13:13:44 <hattmammerly> geekosaur: thank you!
13:14:05 <hakujin> any eta on 7.8.1?
13:14:40 <levi> geekosaur: I'm using erc, and the emacs buffer is in some sort of unicode mode.
13:15:11 <geekosaur> as for your question at the top: you can use <- to get at the Bot in an IO Bot (as long as the final result is in IO); Net is a different wrapper around Bot (which also includes IO)
13:15:48 <levi> utf-8-unix is the current coding system for new files, keyboard input, and terminal output.
13:16:24 <geekosaur> and one of the reasons for these wrappers is they get passed around implicitly for you, just because you used the wrapper type (and this is also why you need to use <- to get at stuff and why the final result has to go back into the wrapper.)
13:17:07 <geekosaur> (Note also that by wrapper here I mean that the type is wrapped around something else; it's not actually a container, and <- is actually syntactic sugar for a callback, not a container-fetch of some kind.)
13:17:14 <levi> Might be a problem with my putty configuration.
13:19:31 <levi> Ah yeah, that was it. Shows up as O-tilde now.
13:19:45 <hattmammerly> geekosaur: I think I get it. thanks!
13:21:29 <levi> geekosaur: Thanks for the tip about A-tilde, that was helpful in figuring it out. I've been trying to get a sane unicode environment going for a while.
13:22:18 <geekosaur> I know your pain. My IRC client tries to autoadapt to iso8859 vs. utf8 and occasionally gets it wrong
13:22:26 <hattmammerly> geekosaur: hm, if I were to want to make a change to game, how would I return the full new state of things in a Net ()?
13:23:49 <geekosaur> I don't think you do. Your Net is a ReaderT, which is appropriate for the socket but not for the Game
13:24:08 <geekosaur> (the environment of a Reader / ReaderT is read only)
13:25:15 <erisco> Cale, you said the other day that BiTree was a Monad, but that does not seem to work because only BiReturn holds a value of type 'r'. What happens with BiBranch?
13:26:07 <hattmammerly> oh, but that's not a huge deal, because there's a Writer monad detailed in LYAH, so I think I'm set
13:26:12 <Cale> erisco: recursion
13:26:26 <erisco> Cale, ah of course
13:26:40 <geekosaur> State might be more appropriate than Writer
13:27:09 <Cale> erisco: The idea is that you're making substitutions at the leaves for new trees according to the function that you're binding with
13:27:10 <geekosaur> then you can use get/gets, put, and modify
13:27:22 <Cale> erisco: and the top of the tree stays the same
13:28:05 <hattmammerly> geekosaur: oh of course. thank you
13:28:21 <erisco> Cale, what do I do with the value of type 'a' on the branch?
13:28:45 <geekosaur> tbh I'd be using StateT Game (ReaderT Socket IO), but then you get into rather more complex stuff (notably, it's much easier with a newtype and newtype deriving)
13:29:55 <hattmammerly> geekosaur: noted. Generally, if a module doesn't export constructors can I still use them in type synonyms?
13:30:14 <c_wraith> hattmammerly: type synonyms don't use constructors, so...
13:30:22 <hattmammerly> c_wraith: haha oh, alright
13:30:36 <zett_zelett> I wonder if the following is possible: I have data Tree a = Empty | Node a (Tree a) (Tree a). I want to define a function (-<) such that 2-<(1,3) yields the tree Node 2 (Node 1 Empty Empty) (Node 3 Empty Empty), i.e. the tree with root 2 and children 1, 3.
13:30:40 <geekosaur> depends on how you're using them. (For example, your current one has IO in it which has no constructors you can get at)
13:31:00 <zett_zelett> But I also want it to be able to understand 2-<(1-<(4,5),3).
13:31:20 <hattmammerly> (if it wasn't clear I didn't write the base bot, I'm extending one from the haskellwiki)
13:31:21 <zett_zelett> Which would yield the tree with root 2 and children 1 and 3, where 1 has two children: 4 and 5.
13:31:34 <geekosaur> (but you can get *values* that are in IO, by using it in something in IO, so it is usable)
13:32:23 <zett_zelett> So the function I want is neither (-<) :: a -> (a, a) -> Tree a, nor (-<) :: a -> (Tree a, Tree a) -> Tree a, but somehow both – all four combinations.
13:33:54 <zett_zelett> I tried to define a class 'Treeable' for this, but it seems to be impossible to make every type an instance of it and also, I woudn’t know how to type-signature (-<) even then. Treeable a, Treeable b => a -> (Treeable a, Treeable b) -> Tree a won’t work, of course.
13:34:01 <erisco> Cale, ah I think I know
13:34:06 <zett_zelett> Can anyone tell me whether this is possible or not?
13:34:15 <qsdqdw> Is it possible to specify that one executable depends on another one in a cabal file?
13:35:08 <chrisdone> qsdqdw: they're all installed together. why do you need to specify that?
13:35:35 * hackagebot purescript 0.2.13 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.13 (PhilFreeman)
13:36:35 <Cale> erisco: The only obvious thing you can do :)
13:36:44 <Cale> (which isn't obviously silly ;)
13:37:29 <erisco> Cale, well what I was doing was extending the tree. That is, for every leaf in A, I would make that the root of B (resulting in a copy of B for every leaf in A)
13:37:36 <erisco> so that should work fine
13:37:39 <Cale> yes
13:38:00 <erisco> Cale, thanks for helping me remember :)
13:38:11 <qsdqdw> chrisdone: The second executable is for tests. It provides its own modules but also depends on some that are used by the first executable (let's call them Foo). Currently, I have to specify the Foo modules in the other-modules field of the second executable (as well as their extensions), which is very inconvenient. Otherwise, the second executable fails to find one of the Foo modules, which is a .hsc file. (I hope this description is
13:38:12 <qsdqdw> not too hard to follow.)
13:39:19 <Cale> erisco: Well, given the leaf x, the tree you put there should be f x, right?
13:39:44 <Cale> (it'll be a copy of the same tree when f is a constant function, or all the leaves have the same value)
13:40:00 <nstdloop> What's the best way to solve this issue. I have two files, Game.hs and Player.hs, Game imports Player because Player contains the Player type and each Game contains a Player. However, Player also implements a method that takes a Game so would have to import Game, obviously that causes a loop, so how should I solve this?
13:40:22 <nstdloop> The two types have clashing record fields and each have other utility functions that might have conflicts, so I'd much rather keep them in two separate modules
13:40:25 <Cale> nstdloop: A frequent solution is to move the declarations of types out into their own module
13:40:37 <qsdqdw> chrisdone: I could post a simpified .cabal file if you want.
13:40:57 <nstdloop> Cale: But the reason they are in their own modules to begin with is that they have clashing record fields
13:41:04 <Cale> Oh, well, fix that :)
13:41:21 <nstdloop> They have fields like "name" and "description"
13:41:26 <nstdloop> for prompting to the user
13:41:29 <Cale> playerName
13:41:32 <nstdloop> and I'd rather not have that
13:41:33 <Cale> playerDescription
13:41:42 <nstdloop> because it's soo verbose
13:41:47 <Cale> pName
13:43:05 <nstdloop> I initially considered making a typeclass that has name and description fields
13:43:08 <nstdloop> and then implement those
13:43:21 <nstdloop> so I can use name and description on all the types that have that field
13:43:28 <nstdloop> does that seem reasonable?
13:43:30 <levi> Records have a number of warts; unfortunately, there's no consensus on how to fix them.
13:44:01 <nstdloop> I don't get why ghc can't infer which one to use based on the type
13:44:19 <nstdloop> Like if I call name on a Player, you know I mean the name field of Players, not Games
13:44:55 <donri> nstdloop: what about polymorphism
13:45:42 <Cale> nstdloop: Suppose I write  f x = reverse (name x)
13:45:48 <Cale> nstdloop: what type does f have?
13:45:48 <Saizan> levi: there is going to be a big revamp of record fields in the next gh
13:45:49 <donri> what's the type of fullName r = firstName r ++ " " ++ lastName r
13:45:53 <Saizan> *ghc
13:46:18 <nstdloop> Cale: I see, you'd have to give ghc the hint anyway
13:46:23 <nstdloop> and then you lose type inference
13:46:26 <nstdloop> which would be bad
13:46:30 <levi> Saizan: In 7.8?
13:46:31 <qsdqdw> chrisdone: Here's the structure of the file: http://dpaste.com/1547067/plain/
13:47:07 <Saizan> levi: i think so
13:47:20 <Cale> nstdloop: There are ways to solve this problem, but it's not trivial
13:48:12 <Cale> (and there are enough ways to do it with minor differences, and enough of a hill to climb after you pick one, that it's easy to argue endlessly between them without implementing anything)
13:48:16 <nstdloop> My gut instinct was to say something like (implements name which has type (a -> [b]) c) => c -> [b]
13:48:26 <nstdloop> which is basically saying you need to define a typeclass
13:48:30 <nstdloop> which has name as a required function
13:48:36 <Cale> Well, yeah, we can already do that :)
13:48:41 <nstdloop> Yes
13:48:45 <Cale> (Manually though)
13:48:50 <levi> Saizan: Ahh, http://www.well-typed.com/blog/84 suggests it's going into (or has gone into by now, perhaps) HEAD rather than the 7.8 release branch.
13:49:47 <levi> Is that the same thing that you were referring to?
13:50:07 <alyssaphacker> Hi, I am having some troubles installing ghc in OSX Maverick...
13:50:28 <Cale> alyssaphacker: have you seen http://is.gd/H4sEub ?
13:50:41 <alyssaphacker> I did run the script, but I'm still getting errors at linking time
13:50:47 <mekeor> alyssaphacker: what's the problem, what's the error message?
13:50:52 <mekeor> hm.
13:50:53 <alyssaphacker> Cale: yup
13:51:01 <nstdloop> alyssaphacker: See http://www.haskell.org/platform/mac.html, specifically the "Xcode 5 & OS X 10.9" tab
13:51:05 <nstdloop> that's probably the problem
13:51:05 <Saizan> levi: yeah, so i guess 7.10 then
13:51:10 <alyssaphacker> things like /Library/Frameworks/GHC.framework/Versions/7.6.3-x86_64/usr/lib/ghc-7.6.3/include/Stg.h:65:18:
13:51:11 <alyssaphacker>      error: math.h: No such file or directory
13:52:01 <alyssaphacker> nstdloop: I downloaded and executed the script
13:52:04 <geekosaur> alyssaphacker, xcode-select --install
13:52:28 <nstdloop> geekosaur: good call
13:52:29 <geekosaur> you have xcode but not the command line tools (which includes the "public" system headers)
13:52:48 <alyssaphacker> geekosaur: hum let me see
13:53:27 <Cale> geekosaur: It seems quite odd that they'd let you install Xcode but not the commandline utilities.
13:53:39 <geekosaur> Cale: the Xcode 5 setup *is* quite odd
13:53:44 <alyssaphacker> (I think the std headers are in /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk/usr )
13:54:01 <geekosaur> those are the private ones, and you can't use them directly
13:54:05 <geekosaur> except in Xcode projects
13:54:16 <alyssaphacker> oh I see... :)
13:54:21 <geekosaur> it's rather messed up
13:54:27 <danharaj> edwardk: halp
13:54:44 <danharaj> http://lpaste.net/98335
13:55:24 <geekosaur> Cale: the most fun part is that if you run clang after installing Xcode 5, it will *sometimes* (not consistently!) offer to install the command line tools for you
13:55:56 <joelteon> :t fmap join . sequence
13:55:57 <lambdabot> (Monad f, Functor f) => [f [a]] -> f [a]
13:56:01 <geekosaur> in theory you can use the command line tools without xcode, and it's likely that for the purposes of ghc it would work
13:56:09 <Cale> wow, such design, so think, very different
13:56:38 <geekosaur> and yes, those of us who have to keep track of this are often quite befuddled by "wtf was Apple thinking *this* time?!
13:56:39 <geekosaur> "
13:57:24 <NemesisD> any pipes users here. i'm trying to gather what pipes libs ill need for this task
13:57:32 <nstdloop> I know brew sucks for ghc, but one of the things I like about it for other things is that it downloads all the right xcode things for you as part of the installation
13:58:33 <NemesisD> the problem has 2 producers, each reading from a database concurrently, one performing a pure map over the data and one another database query, then both converge in on a pipe that sinks the data to a csv
13:58:42 <jgross> Is there a way to install darcs-fastconvert?  cabal install darcs-fastconvert tells me that I have inconsistent dependencies, and if I give it --force-reinstalls, I get "unix-2.3.2.0 failed during the building phase. The exception was: ExitFailure 1"
13:58:56 <alyssaphacker> geekosaur: thank you, that worked
13:59:31 <NemesisD> db ==[row]==> transform ==transformedRow==> csv
13:59:51 <Cale> jgross: Well, that package demands darcs 2.5.*
13:59:58 <NemesisD> is this a job for pipes-concurrency or can you compose to concurrent producers into 1 producer
14:01:09 <Cale> jgross: as well as a somewhat old version of attoparsec
14:01:45 <Cale> jgross: Maybe you could try relaxing those constraints and see if it still builds with newer versions of things, as a half-assed way to maybe solve the problem :)
14:02:21 <Cale> i.e. cabal unpack darcs-fastconvert and then just hack the .cabal file and remove the version constraints, and cabal install from that directory to try installing it
14:03:16 <Cale> It might totally fail, but it's worth a shot. It looks like the package hasn't been maintained in a while.
14:03:55 <Martingale> if I write " (iterate f x) !! 100" say, is the ghc compiler smart enough to throw away intermediate results, i.e. release element n after computing element n+1
14:04:56 <Cale> Martingale: well, I think the problem you'll have is that it won't compute any of the results until you get to the 100th element, and then it'll start computing that one, and if f is strict, you might get a stack overflow as each f puts another pattern match on the stack.
14:05:05 <Cale> (well, not with 100, but in general)
14:05:27 <BMeph> Is it supposed to also be a "law," that: (MonadTrans t, Monad m) => Monad (t m)?
14:05:51 <Cale> BMeph: generally
14:06:08 <Martingale> cale: so is there a more efficient way to calculate the 100th element?
14:06:18 <BMeph> Cale: (Thus, the "supposed to be" part)...thanks! :)
14:07:06 <danharaj> edwardk: nevermind, my env was fucked in inscrutable ways
14:07:23 <Martingale> Cale maybe i should use a strict left fold?
14:08:12 <Cale> Martingale: That could work
14:08:24 <Cale> You could apply something like strictList [] = []; strictList (x:xs) = x `seq` (x : strictList xs) to the list generated by iterate
14:08:35 <Cale> and then using !! on that would ensure that the elements were computed in sequence
14:08:55 <Martingale> Cale thanks, that's helpful
14:09:24 <Cale> You don't have to worry so much about the garbage collector doing its job. So long as the elements go out of scope and your program doesn't have a way to access them again, they ought to be collected.
14:09:59 <Cale> If you're holding on to a reference to the whole list somewhere else, then that could be a problem
14:10:35 <Martingale> nope, i throw it away, just want to make sure i don't blow the stack
14:10:59 <Cale> It's actually a little annoying that there isn't an iterate' which automatically sequences a bit like that.
14:11:35 <Cale> iterate' f x = x : (x `seq` iterate' f (f x))
14:11:40 <Cale> something like that perhaps
14:12:12 <Cale> Just to ensure that as you walk down the list, the function gets a chance to evaluate
14:12:12 <zett_zelett> https://stackoverflow.com/questions/21068479/pattern-matching-against-value-constructors-in-type-variables-some-sort-of-fle
14:12:44 <Martingale> Cale I'll try a few things and profile the memory usage
14:13:20 <Cale> zett_zelett: It is impossible, as you stated it
14:13:35 <zett_zelett> : - /
14:13:57 <zett_zelett> I think this is the second time, I’m a bit disappointed by Haskell.
14:14:00 <Cale> also, I don't think you mean undefined, but Empty
14:14:13 <Cale> Well...
14:14:14 <Cale> hmm
14:14:14 <zett_zelett> Well, undefined.
14:14:19 <zett_zelett> You can take that, too.
14:14:28 <Cale> undefined terminates your program immediately if evaluated
14:14:36 <zett_zelett> Oh.
14:14:36 <Cale> It's an error
14:14:52 <Cale> It's meant to behave like an infinite loop which ends quickly
14:14:54 <zett_zelett> Yeah, I edited it.
14:15:27 <zett_zelett> Anyway, thank for the answer.
14:15:48 <Cale> We might be able to fix your operation so that it makes more sense
14:16:09 <Cale> You certainly can define an operation  (-<) :: a -> (Tree a, Tree a) -> Tree a
14:16:22 <zett_zelett> Yeah, I already did.
14:16:32 <zett_zelett> But then I need to write "Leaf x" everytime.
14:16:44 <Cale> and you can also define an operation  leaf :: a -> Tree a
14:16:51 <zett_zelett> Or "Node x Empty Empty" everytime.
14:16:55 <Cale> right
14:17:02 <zett_zelett> Yeah, and define leaf as leaf x = Node x Empty Empty.
14:17:05 <zett_zelett> Anyway.
14:17:30 <zett_zelett> If there are a lot of leaves, this still yields a merely messy way to create trees.
14:17:41 <Cale> You have the other problem that 2 and 3 are polymorphic
14:18:06 <Cale> and it's difficult to say that you didn't mean to use a Num instance for Tree
14:18:25 <zett_zelett> What do you mean by that?
14:18:28 <Cale> If you try to make (-<) into a type class method
14:19:21 <stephenmac7> What is OverloadedStrings ?
14:19:39 <maurer> stephenmac7: It allows you to use string literals for things that are a member of the "IsString" typeclass
14:19:50 <maurer> stephenmac7: So for example, say that you are using Text pervasively throughout your code
14:20:04 <zett_zelett> Why does ghc forbid to pattern match against non-obligatory value constructors?
14:20:06 <maurer> stephenmac7: but you don't want to call Text.pack "foo" every time
14:20:09 <zett_zelett> Like what I did with f?
14:20:21 <zett_zelett> f :: a -> Int; f (Just _) = 1; f x = 0
14:20:27 <maurer> stephenmac7: Enabling this extension allows you to just say "foo", and the IsString instance for Text will convert the string literal for you
14:21:13 <Cale> zett_zelett: The implementation you wrote clearly pattern matches against a value of type Maybe t, but you said that it would work for all types a
14:21:22 <Cale> zett_zelett: But it doesn't.
14:21:28 <Cale> It only works on Maybe values
14:21:39 <Cale> So, GHC caught your lie. :)
14:22:10 <Cale> f :: a -> Int doesn't mean that there is some type a such that f will accept a value of type a and produce an Int
14:22:16 <chrizz_> hi all, according to https://hackage.haskell.org/package/time-1.4.1/docs/Data-Time-Clock.html UTCTime has a Show instance, but the source code (and ghc) say otherwise
14:22:31 <chrizz_> i'm wondering how the instance shows up in the haddocks, then?
14:22:32 <Cale> It means that for every type a, (any type the user of f decides on), f will accept a value of type a and produce an Int
14:22:43 <zett_zelett> Yeah.
14:22:46 <zett_zelett> I see.
14:23:02 <zett_zelett> It’s nothing like a "Everything-type".
14:23:10 <Cale> zett_zelett: and that means that f cannot observe the value it receives, it may only discard it, or pass it along in some way unchanged to its result
14:23:19 <zett_zelett> But why isn’t there an everything-type?
14:23:36 <stephenmac7> maurer: So, that works for bytestrings too?
14:23:43 <geekosaur> because in Haskell you would not be able to do anything with it, because you know nothing about it
14:23:49 <geekosaur> if it can be anything
14:23:54 <maurer> stephenmac7: I think that was the reason it was invented, but be aware, bytestrings should not be used unless you are literally doing a string of bytes
14:24:05 <Cale> zett_zelett: the parameter to f might be a function or an IO action or... well, anything
14:24:12 <maurer> stephenmac7: Bytestrings lack proper unicode/etc support and should not be used as strings
14:24:12 <Cale> zett_zelett: and f doesn't know
14:24:28 <Cale> zett_zelett: because types are a compile time construct, they don't exist at runtime
14:24:29 <stephenmac7> maurer: I'm actually just following this: https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/attoparsec
14:24:31 <maurer> zett_zelett: Say you had something of type Everything-type
14:24:37 <geekosaur> stephenmac7: there is also Data.Text which is appropriate for unicode strings
14:24:37 <maurer> zett_zelett: What would you think you could legally do with it?
14:24:43 <stephenmac7> They used overloaded strings and so, was just asking about it
14:24:49 <zett_zelett> mapping them constantly to something.
14:24:50 <jmcarthur> ByteStrings are great if you are wanting a byte string, but not great if you are wanting a character string
14:24:51 <BMeph> zett_zelett: Imagine writing this function - f :: a -> Int; f (^2) = 2; f x = 0.
14:24:52 <Cale> zett_zelett: So, the compiled version of f (of which there will be only one), will get a pointer to *something*
14:25:04 <stephenmac7> geekosaur: Why use Data.Text instead of normal strings?
14:25:17 <geekosaur> normal strings are very convenient but very inefficient
14:25:17 <maurer> zett_zelett: Ah, it is fine for them there because they are using attoparsec
14:25:21 <maurer> err, sorry
14:25:24 <zett_zelett> Pattern match it against value constructors so I can use the internal structure of the value.
14:25:25 <geekosaur> overhead of something around 64 bytes per character
14:25:26 <maurer> stephenmac7: Ah, it is fine for them there because they are using  attoparsec
14:25:27 <jmcarthur> stephenmac7: speed, and the api also has some functions not found in the standard library for strings
14:25:30 <Cale> zett_zelett: but it doesn't know what sort of thing that pointer points to (we technically know that it's a pointer to code, but beyond that, we have no idea what that code returns)
14:25:46 <maurer> stephenmac7: You'll note that attoparsec is a byte-oriented parsing library, so using a byte oriented string is fine
14:26:06 <geekosaur> (String is a linked list of Char; each Char comes with a constructor ID and an indirection to the actual value, plus a link to either [] or the next character)
14:26:24 <maurer> stephenmac7: People use Text because it has improved performance. The short version is that String is literally a list of codepoints, and Text is a fancy data structure representing some text, set up to be faster than a literal list
14:26:29 <jmcarthur> (plus the constructor for the (:))
14:26:30 <Cale> zett_zelett: and when it returns, yeah, sure, it might return something which looks like the runtime representation of Just x, in that it has the integer tag 1, together with some pointer to code
14:26:32 <stephenmac7> geekosaur: I didn't know normal lists were linked lists
14:26:48 <Cale> zett_zelett: But there's no way to tell that's not Right x
14:26:48 <jmcarthur> (unless you didn't mean the Char constructor like i thought you did)
14:26:50 <geekosaur> yes. a normal list is a linked list because that's more or less how you represent a loop in Haskell
14:26:59 <Cale> zett_zelett: Because the type has been erased
14:27:00 <stephenmac7> maurer: Okay, thanks
14:27:00 <geekosaur> it's best to think of Haskell lists as loops, not as data
14:27:16 <Kaidelong> @ty fromMaybe id
14:27:17 <lambdabot> Maybe (a -> a) -> a -> a
14:27:20 <jmcarthur> well... it's often good to think of them that way, but i don't think *always*
14:27:23 <zett_zelett> Cale: I’m not sure I follow: Which type has been erased?
14:27:36 <stephenmac7> Well, thanks
14:27:49 <stephenmac7> All of this attoparsec stuff just to parse http headers...
14:28:10 <Cale> zett_zelett: At runtime, none of the types exist in memory. Data constructors get compiled to structures which look like an integer tag together with some pointers to code for the arguments
14:28:13 <jmcarthur> stephenmac7: surely you could just use an http library...
14:28:27 <stephenmac7> I am using an http library
14:28:28 <Cale> zett_zelett: and the integer tags are reused between types
14:28:31 <augur_> @free f :: Maybe (a -> a) -> a -> a
14:28:31 <lambdabot> (forall h. (forall k p. g . k = p . g                        =>                         h k = p)           =>            $map_Maybe h x = y) => g . f x = f y . g
14:28:37 <jmcarthur> stephenmac7: then why deal with attoparsec?
14:28:40 <stephenmac7> It just decides to give me the header as a bytestring
14:28:48 <stephenmac7> Rather than parsing it
14:29:03 <stephenmac7> (I'm trying to use the content-disposition header)
14:29:08 <jmcarthur> stephenmac7: you are talking about all headers or some specific header you are wanting to parse further?
14:29:10 <jmcarthur> ah
14:29:36 <stephenmac7> Look like: attachment; filename="something.zip"
14:29:46 <stephenmac7> However, it might have no filename
14:29:52 <stephenmac7> Or, it might have other information
14:30:21 <jmcarthur> stephenmac7: http://hackage.haskell.org/package/mime-string-0.4/docs/Codec-MIME-String-ContentDisposition.html
14:30:22 <maurer> stephenmac7: Are you doing this as a learning project or because you actually want to get parsed html headers?
14:30:37 <Cale> zett_zelett: So when this function f gets the pointer to code representing the expression it has been applied to, sure, perhaps it could enter that code, but then that code is potentially going to return a pointer to one of these data constructor things, or a function, or something. Even if we were to assume that it's a pointer to a data constructor, we wouldn't really be able to make sense of the integer tag even.
14:30:40 <jmcarthur> stephenmac7: that's just the first thing i found. i bet there are others too
14:30:42 <stephenmac7> maurer: Both
14:30:59 <stephenmac7> I don't want to use a library to do it, because I wouldn't learn the content
14:31:02 <Cale> zett_zelett: I'm giving a very low-level answer here. There are also high-level reasons not to try to support this operations.
14:31:04 <Cale> -s
14:31:26 <Cale> zett_zelett: For one... consider something like the type of the map function:
14:31:32 <Cale> map :: (a -> b) -> [a] -> [b]
14:31:34 <jmcarthur> stephenmac7: if you are wanting to implement it yourself then i don't know why you are complaining about having to write the parser
14:31:59 <stephenmac7> jmcarthur: I was just thinking that it was a bit complicated
14:32:04 <stephenmac7> Still want to learn it though.
14:32:13 <stephenmac7> I should be more careful about what I write :D
14:32:15 <Cale> If we try to go ahead and implement this, then no matter how we do it, all the elements of the list we produce will *have* to consist of elements of the input list which have had the given function applied to them.
14:32:18 <jmcarthur> stephenmac7: if it's about attoparsec, you aren't required to use it just to parse something
14:32:27 <Cale> (and that function could only have been applied exactly once)
14:32:42 <Cale> So while we can fail to write a correct map function, we almost have to try to get it wrong
14:32:47 <Cale> If we wrote:
14:32:48 <jmcarthur> (although i would use some parser combinator library, for sure)
14:32:50 <zett_zelett> Cale: It is hard for me to imagine what goes on from what you say. I have no experience in low level computer science or what compilers do, but I’ll try to follow.
14:32:58 <Cale> map [] = []
14:33:04 <Cale> oops
14:33:06 <Cale> map f [] = []
14:33:10 <jmcarthur> (i'd probably use the parsers library, since it is a bit more generic, unless i needed some specific features)
14:33:12 <Cale> map f (x:xs) = x : map f xs
14:33:15 <Cale> this is a type error
14:33:23 <zett_zelett> Cale: Or have tried, for that manner and will try to understand that as well. Now I follow the high-level-argumentation, of course. :)
14:33:28 <Cale> We forgot to apply f to the element of the list we produced
14:34:10 <Cale> whoops :)
14:34:11 <zett_zelett> Yeah.
14:34:25 <Cale> What else can't we do?
14:34:29 <Cale> I can't write something like:
14:34:43 <stephenmac7_> My power always goes out...
14:34:49 <Cale> map f (0 : xs) = 5 : map f xs
14:35:19 <Cale> We can't suddenly decide to make map do something different when it knows that the type is Integer
14:35:34 <Cale> This makes the type of map have a much stronger meaning
14:35:42 <NemesisD> has anyone else been getting cabal errors where an install fails and it tries to show a log but the log isn't there?
14:35:47 <Cale> I have some guarantees about what kind of thing map is doing for me
14:35:59 <Cale> Sure, it might still just always produce an empty list
14:36:33 <Cale> But I know that *every* element of the list that map f xs gives me back will consist of f applied to x where x was an element of the list xs that I gave it.
14:36:42 <Cale> Just from the type alone
14:37:15 <Cale> map :: (a -> b) -> [a] -> [b] -- let's look at that again
14:37:24 <Cale> There's only one way to get values of type b
14:37:45 <Cale> Take the elements of the list of values of type a (which is the only source of values of type a here)
14:37:52 <Cale> and apply the function (a -> b) to them
14:38:18 <zett_zelett> Cale: I know this.
14:38:44 <Cale> zett_zelett: If we let implementations of functions inspect which type their type variables are, we lose this guarantee completely.
14:39:40 <Cale> zett_zelett: As it happens, we do have a way to accomplish this anyway, through the Typeable class
14:40:15 <zett_zelett> Cale: What if there was something like an everything-type or a polymorphic type, accompanied by a special keyword?
14:40:21 <Cale> But that shows up as an explicit constraint
14:40:34 <Cale> f :: (Typeable a) => a -> Int
14:40:34 <zett_zelett> Or, like using greek lower case letters for polymorphic types or something like that?
14:41:34 <Cale> f x | Just (Just v) <- cast x = 1
14:41:44 <Cale>     | otherwise = 0
14:42:00 <zett_zelett> Wait a second.
14:42:17 <zett_zelett> Does f do what I think it does?
14:42:23 <Cale> kind of
14:42:33 <zett_zelett> What’s the difference to what I wanted?
14:42:35 <Cale> You can't apply it to just anything.
14:42:51 <zett_zelett> Only to instances of the typeable class?
14:43:00 <Cale> What you apply it to must be of a monomorphic type, and that type must be an instance of the Typeable class.
14:43:18 <zett_zelett> What’s a monomorphic type?
14:43:21 <Cale> which will mean that applying f will probably require an explicit type signature
14:43:52 <Cale> i.e. something not polymorphic
14:44:05 <Cale> Writing f length will fail
14:44:12 <zett_zelett> Yeah, I thought so. But I also thought all types in Haskell are monomorphic?
14:44:18 <Cale> f (length :: [Integer] -> Int) will work
14:44:32 <zett_zelett> Ah, yeah.
14:45:12 <zett_zelett> Only "concrete types" are or something like that.
14:45:18 <Cale> yeah
14:45:41 <Cale> f (Just 4) will also be a problem, because what type of number is that?
14:45:51 <zett_zelett> Anyway, many thanks for your explanation.
14:45:52 <Cale> (Numeric defaulting won't apply)
14:46:03 <Cale> f (Just (4 :: Integer)) will work
14:46:18 <zett_zelett> f (Just 'a') should work, though.
14:46:21 <Cale> yes
14:46:31 <zett_zelett> Okay.
14:47:53 <Cale> So, while we could build something using Typeable to do what you want, it'll require lots of explicit type annotations.
14:48:01 <snizzo> is parsec shipped with base libraries?
14:48:31 <Cale> It's not part of the base package, and it's not shipped with GHC, but it's probably part of the Haskell Platform?
14:48:57 <snizzo> ohh ok, thank you
14:48:58 <Cale> Yes, it is.
14:50:44 * hackagebot http-attoparsec 0.1.1 - Attoparsec parsers for http-types.  http://hackage.haskell.org/package/http-attoparsec-0.1.1 (TeroLaitinen)
14:58:51 <NemesisD> depr. no wonder i was having so much trouble with cabal, i had been using the luite mirror
14:58:53 <aleksejs_> is there an easy way for ghc to turn off debug info and other unnecessafy stuff
15:04:23 <jle`> does core reflect all fusions done by ghc?  as in, if it doesn't fuse in core, i wouldn't expect it to fuse between core and c--?
15:04:36 <jle`> core output
15:08:52 <nh2> where does cabal install Data-Files?
15:10:33 <pavonia> Is that supposed to be a module name?
15:11:01 <nh2> pavonia: no, the data-files feature http://neilmitchell.blogspot.de/2008/02/adding-data-files-using-cabal.html
15:13:02 <jmcarthur> nh2: i'm going to guess somewhere in .cabal/share
15:13:14 <pavonia> Hhm, I've read that somewhere recently
15:15:13 <danharaj> I have -with-rtsopts='-N' in my .cabal GHC-Options block. Why do I get this when I run my executable? unexpected RTS argument: '-N'
15:16:56 <verement> not compiled with -threaded ?
15:17:01 <danharaj> no, that's not it.
15:17:08 <danharaj> http://stackoverflow.com/questions/6505648/building-with-runtime-flags-using-cabal-and-ghc
15:17:11 <danharaj> looks to be cabal being bad.
15:20:54 <Aetherspawn> I need to generate unique names from numbers for SSA nodes
15:21:13 <Aetherspawn> like 1 -> a, 2 -> b ... 26+1 -> aa, 26+2 -> ab .. etc
15:21:35 <Aetherspawn> I think I need to split a number like 28 into a list like [26,2] then fold a helper function for converting to a letter over it
15:21:49 <Aetherspawn> not sure the best way to do the splitting pat.
15:23:31 <solrize> > let f n = 'a':show n  in  f  37
15:23:33 <lambdabot>  "a37"
15:23:42 <jmcarthur> > (chr . (+48) . ord . show) 12345
15:23:43 <lambdabot>  Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'
15:23:43 <lambdabot>  Expected type: a0 -> GHC.Types.Char
15:23:43 <lambdabot>    Actual type: a0 -> GHC.Base.String
15:24:02 <jmcarthur> > map (chr . (+48) . ord) $ show 12345
15:24:03 <lambdabot>  "abcde"
15:24:14 <jmcarthur> not sure what i was thinking that first time
15:24:33 <Aetherspawn> I have an idea
15:24:40 <Aetherspawn> I'm going to use unfoldr and mod/rem
15:24:45 <copumpkin> jmcarthur: (.) as fmap?
15:26:14 <nh2> danharaj: what's your problem? I answered in that stackoverflow
15:26:18 <nh2> in the comments
15:26:49 <jmcarthur> > showIntAtBase 26 (chr . (+97)) 12345 ""
15:26:50 <lambdabot>  "sgv"
15:26:54 <jmcarthur> Aetherspawn: ^^
15:26:54 <jle`> > let split x | x <= 26 = x | otherwise = x `mod` 26 : split (x `div` 26) in split <$> [7834,5237846,23,57]
15:26:56 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = [a0]
15:27:07 <danharaj> nh2: cabal botches quotes in -with-rtsopts
15:27:16 <Aetherspawn> cool
15:27:19 <jle`> > let split x | x <= 26 = x | otherwise = split (x `div` 26) ++ [x `mod` 26] in split <$> [7834,5237846,23,57]
15:27:20 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = [a0]
15:27:27 <danharaj> it's alright now though, that overflow question gave me the solution.
15:27:30 <jle`> hm
15:27:34 <jle`> oh
15:27:41 <jle`> > let split x | x <= 26 = [x] | otherwise = split (x `div` 26) ++ [x `mod` 26] in split <$> [7834,5237846,23,57]
15:27:42 <lambdabot>  [[11,15,8],[11,12,0,7,16],[23],[2,5]]
15:27:46 <jmcarthur> > map (\str -> showIntAtBase 26 (chr . (+97)) str "") [0..]
15:27:47 <lambdabot>  ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s"...
15:27:48 <jle`> that's what you wanted earlier
15:27:54 <jmcarthur> > map (\str -> showIntAtBase 26 (chr . (+97)) str "") [100..]
15:27:55 <lambdabot>  ["dw","dx","dy","dz","ea","eb","ec","ed","ee","ef","eg","eh","ei","ej","ek",...
15:28:41 <Aetherspawn> thanks guys
15:28:54 <jmcarthur> Aetherspawn: showIntAtBase is in the Numeric module, btw
15:29:05 <Aetherspawn> yeah I was just looking for it :P
15:30:12 <verement> > let { f n | n > 0 = Just $ let (q,r) = n `quotRem` 26 in (r, q); f n | n == 0 = Nothing } in unfoldr f 1000
15:30:13 <lambdabot>  [12,12,1]
15:30:50 <jle`> > let split x | x <= 26 = [x] | otherwise = split (x `div` 26) ++ [x `mod` 26] in (map (chr . (+97))) split <$> [7834,5237846,23,57]
15:30:51 <lambdabot>  Couldn't match expected type `a0 -> b0'
15:30:52 <lambdabot>              with actual type `[GHC.Types.Char]'Couldn't match expected type ...
15:30:52 <lambdabot>              with actual type `t0 -> [t0]'
15:32:38 <pavonia> > map (\str -> showIntAtBase 26 (chr . (+97)) str "") [24..]
15:32:39 <lambdabot>  ["y","z","ba","bb","bc","bd","be","bf","bg","bh","bi","bj","bk","bl","bm","b...
15:35:14 <hattmammerly> Changing a ReaderT to a StateT isn't going to be a quick replacement, right? I'll have to rethink the whole implementation?
15:36:32 <Saizan> well, you can change each "ask" to "get"
15:39:13 <jle`> i'm sure there is a way to translate tell too.
15:40:02 <NemesisD> anyone know of any th/qq wizardry available for feeding an N-length tuple into an N-arity constructor?
15:40:10 <hattmammerly> Saizan: yeah, but in this case a quick swap didn't work
15:40:56 <NemesisD> actually, nm this isn't going to work anyways
15:42:24 <ikv> forkProcess and ForeignPtr finalizers would not play nice together, would they?
15:42:25 <chrisdone> lol, i just noticed in the logs someone sent some lisp code to tryhaskell
15:42:34 <chrisdone> "am i doin it rite"
15:43:03 <Axman6> heh
15:43:04 <ikv> i beleive that's the reason why i'm getting segfaults of (i believe) xfork (xmonad) childs after calling alsa-mixer
15:46:36 <Sonderblade> does haskell have a function for doing the same functionality as sql "group by"?
15:46:48 <Sonderblade> so over haskell lists instead of sql tables
15:46:49 <sipa> :t groupBy
15:46:49 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
15:47:44 <sipa> :t groupBy (\x y -> x `mod` 5 == y `mod` 5) [1,2,3,4,10,20,30,40]
15:47:45 <lambdabot> Integral a => [[a]]
15:47:50 <sipa> > groupBy (\x y -> x `mod` 5 == y `mod` 5) [1,2,3,4,10,20,30,40]
15:47:52 <lambdabot>  [[1],[2],[3],[4],[10,20,30,40]]
15:48:16 <Axman6> technically it'd be groupBy foo . sort I think
15:48:30 <Sonderblade> thanks, you need to sort the list by the same function as you're grouping with too?
15:48:40 <Axman6> hmmm, wasn't there a special syntax for that?
15:48:44 <sipa> > groupBy (\x y -> x `mod` 5 == y `mod` 5) [1,2,30,3,10,4,20,40]
15:48:45 <lambdabot>  [[1],[2],[30],[3],[10],[4],[20,40]]
15:48:52 <sipa> right, needs to be sorted
15:50:33 <Axman6> sipa: see also Generalised list comprehensions here: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/syntax-extns.html
15:50:44 <Axman6> uh, Sonderblade
15:51:02 <sipa> @let sqlGroupBy f = groupBy (\x y -> f x == f y) . sortBy (comparing f)
15:51:04 <lambdabot>  Defined.
15:51:21 <sipa> sqlGroupBy (`mod` 5) [1,2,30,3,10,4,20,40]
15:51:24 <sipa> > sqlGroupBy (`mod` 5) [1,2,30,3,10,4,20,40]
15:51:26 <lambdabot>  [[30,10,20,40],[1],[2],[3],[4]]
15:51:28 <Axman6> :t sqlGroupBy
15:51:29 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [[a]]
15:52:13 <Axman6> :t equating
15:52:14 <lambdabot> Not in scope: `equating'
15:52:18 <Axman6> bleh
15:52:21 <sipa> :t equalling
15:52:22 <lambdabot> Not in scope: `equalling'
15:52:33 <Axman6> equating f x y = f x == f y -- that should be defined somewhere
15:52:45 <Axman6> (==) `on` f also works
15:56:28 <aleksejs_> I've installed ghc-dynamic, but now I have problem with importing Data.Text: ghc says it can't find that module
16:04:40 <augur_> Axman6: apparently `equating f` is more or less why partial equivalence relations are so important for FP semantics
16:05:08 <benzrf> > (*) <$> reader (+1) <*> reader (+2)
16:05:09 <lambdabot>  No instance for (Control.Monad.Reader.Class.MonadReader b0 f0)
16:05:09 <lambdabot>    arising from a use of `e_112'
16:05:10 <lambdabot>  The type variables `f0', `b0' are ambiguous
16:05:10 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
16:05:10 <lambdabot>  Note: there are several potential instances:
16:05:12 <Axman6> hmm?
16:05:19 <benzrf> :t (*) <$> reader (+1) <*> reader (+2)
16:05:20 <lambdabot> (Num b, Applicative f, MonadReader b f) => f b
16:05:40 <benzrf> > let apr = (*) <$> reader (+1) <*> reader (+2) in runReader apr 3
16:05:42 <lambdabot>  20
16:05:44 <benzrf> NeatBasis_:
16:05:45 <benzrf> *neat
16:05:50 <augur_> lol
16:06:16 <benzrf> i think i got a handle on applicatives
16:06:27 <benzrf> also Reader
16:07:36 <augur_> benzrf: you should do the Hutton Variations
16:08:24 <benzrf> bah
16:08:40 <augur_> or maybe they should be called the Razor Variations
16:09:27 <augur_> implement an evaluator for hutton's razor (of different complexities), using different variations of monad/applicative
16:09:49 <augur_> it'll give you an appreciation for having applicative/monad as a type class, too
16:09:58 <benzrf> i already have that ;)
16:10:02 <augur_> oh?
16:10:31 <benzrf> just look at liftM2
16:10:38 <benzrf> or mapM
16:10:53 <benzrf> they are both useful for many kinds of monads, if not all
16:11:12 <augur_> no no what i mean is
16:11:32 <augur_> the typeclass nature of monads makes the hutton variations so clean and modular
16:11:39 <benzrf> hm?
16:11:45 <benzrf> btw, what is huttons razor anyway
16:12:03 <augur_> hutton's razor is a toy language that is used as a sort of basic adequacy test
16:12:14 <benzrf> hmm
16:12:17 <augur_> if you cant implement huttons razor, then you know something is very wrong
16:12:32 <benzrf> with you, or with the language?
16:12:32 <benzrf> :)
16:12:48 <augur_> the language/toolkit you're using
16:12:55 <augur_> typically it takes the form of something like
16:13:11 <augur_> data Expr = Lit Int | Expr :+: Expr
16:13:19 <augur_> a trivial little mathematical expression language
16:13:25 <augur_> you write an evaluator for that
16:13:28 <augur_> hooray it works
16:13:36 <augur_> now maybe you want to add booleans
16:13:43 <augur_> so you extend it to add booleans
16:13:54 <augur_> but now you want it to be type checked
16:14:12 <augur_> and indeed you want to _force_ well-typed-ness
16:14:13 <Axman6> True + 1, oops!
16:14:13 <benzrf> hmm perhaps i should do this ._.
16:14:18 <augur_> so you write
16:15:09 <augur_> data Expr a where  Lit :: a -> Expr a  ;  (:+:) :: Expr Int -> Expr Int -> Expr Int  ;  If :: Expr Bool -> Expr a -> Expr a -> Expr a
16:15:52 <augur_> or maybe you want to add variables so instead of using GADTs and type families
16:16:01 <augur_> you instead extend by adding a Let construction
16:16:07 <augur_> and you stick it in the reader monad
16:16:31 <augur_> or maybe you want statefulness so you add a set construction and use State
16:16:57 <augur_> or maybe you want non-determinism so you add a choice construction and use list
16:16:58 <augur_> or...
16:17:34 <benzrf> >_<
16:17:46 <augur_> by the end of it, youve got a sense of how these different monads work, and also an appreciation for type classes like never before
16:18:04 <augur_> because these extensions end up being very simple, modular changes to your eval code
16:20:17 <augur_> ive done one or two hutton variation comments on reddit
16:20:24 <augur_> partiality is a nice use
16:25:56 <Tehnix> Am I correct in the understanding that Network.HTTP doesn't support https? :/
16:26:42 <maurer> Tehnix: I believe so
16:26:46 <maurer> Tehnix: I would reccomend http://hackage.haskell.org/package/http-conduit
16:26:51 <maurer> This is what I have used for https in the past
16:27:13 <tristan_1> yea, that one definitely supports https, using it myself right now
16:27:27 <aristid> in case you're afraid of the conduit dependency, there is this one now: http://hackage.haskell.org/package/http-client
16:27:28 <Lethalman> Tehnix, isn't https just http over ssl? I guess you could simply take something like tls and attach it to the underlying socket, or something like that (at least in non-haskell)
16:28:20 <aristid> Lethalman: sure, and http-conduit takes care of all that jazz
16:28:26 <Lethalman> ah nice
16:28:44 <Tehnix> which one is the simplest? I just managed to implement my thing with Network.HTTP only then to realize no https, so am looking for the least painful transition
16:28:56 <aristid> or without conduit for ssl/tls it would be http-client-tls
16:28:58 <Tehnix> and I'm rather novice in haksell
16:29:16 <tristan_1> Tehnix: it is just as simple
16:29:26 <Tehnix> k, conduit it is then, thanks! :)
16:29:56 <tristan_1> I don't use the conduit stuff (yet) https://github.com/pubnub/haskell/blob/master/src/Network/Pubnub.hs
16:29:56 <aristid> it can be as easy as simpleHttp "http://www.haskell.org/"
16:30:08 <tristan_1> some examples more comlicated than the simpleHttp request
16:30:26 <aristid> sure
16:31:16 <NemesisD> anyone know of an existing pipes function that chunks input
16:31:43 <aristid> NemesisD: chunksOf in pipes-parse
16:31:59 <aristid> gives you a FreeT though:)
16:32:22 <NemesisD> hmm thats a strangely specific place to put such a general function
16:32:34 <NemesisD> i'd think it would be core, seems like a pretty common combinator
16:32:37 <aristid> it's not general.
16:32:44 <aristid> it splits only at fixed sizes
16:33:39 <aristid> i agree that tekmo should rolle the whole pipes-parse package into pipes
16:33:53 <aristid> i believe him not wanting to do that has something to do with lens dependencies
16:34:01 <NemesisD> hmm. im not sure how i can use this FreeT version. basically it should take up to the given count unless upstream is closed, then take the remaining
16:34:32 <aristid> NemesisD: maybe you want the pipes-bytestring version?
16:34:35 <NemesisD> wait could replicateM from Pipes.Preule apply here?
16:34:50 <aristid> not really
16:35:21 <aristid> NemesisD: http://hackage.haskell.org/package/pipes-bytestring-1.0.2/docs/Pipes-ByteString.html#g:6
16:35:24 <NemesisD> aristid: i guess except i'm not dealing with bytestrings :P
16:35:41 <aristid> NemesisD: huh, sounded like you're doing network stuff
16:36:34 <NemesisD> aristid: i think what i'm after is just: Int -> Pipe a [a] m r
16:36:42 <aristid> that can't work
16:37:07 <aristid> because there's no way for the pipe to know that upstream closed
16:37:08 <NemesisD> why not
16:37:18 <hattmammerly> check out line 87: http://bpaste.net/show/r86Mj8QNZ2BgkK476kSM/ How might I access socket properly? this worked fine with asks when I used ReaderT instead of StateT; could someone explain what I'm missing here?
16:37:38 <NemesisD> so i need to work the chunking into the original producer somehow? D:
16:38:15 <aristid> NemesisD: a function Int -> Producer a m r -> Producer [a] m r is possible, yes:)
16:38:15 <hattmammerly> err, what's the difference between get and gets, ask and asks?
16:38:28 <Saizan> hattmammerly: use "gets"
16:38:33 <aristid> NemesisD: you can even get that from the FreeT version
16:38:47 <aristid> with some confusing effort
16:39:02 <NemesisD> that sounds like another yak shave. i'm not familiar with FreeT
16:39:05 <Saizan> hattmammerly: gets f = fmap f get
16:39:10 <NemesisD> would it be easier to roll my own?
16:39:12 <Saizan> hattmammerly: same for asks/ask
16:39:35 <hattmammerly> Saizan: oh, okay. thank you
16:40:10 <Axman6> HugoDaniel: it's often used when your state is a record. data Foo = Foo {bar :: String, baz :: Int}; gets bar will get the String value
16:41:04 <Axman6> uh, hattmammerly
16:41:08 <NemesisD> damn, nothing existing in hayoo
16:41:37 <aristid> NemesisD: rolling your own Int -> Producer a m r -> Producer [a] m r? yeah that shouldn't be too hard
16:41:58 <pingu> Axman6: morning!
16:42:25 <Axman6> o/
16:43:07 <pingu> Axman6: So, I go to work tomorrow. I should be able to get a day or two to work full time on a pure haskell lz4 implementation.
16:43:42 <pingu> Is there anything you'd like a hand with? If you're not up to cutting code yet, that's fine too.
16:43:52 <Axman6> that's what I'm up to at the moment. rethinking my design
16:44:29 <pingu> Axman6: vectors were no good?
16:44:31 <Axman6> I think I'm just going to end up with a lot of pointer manipulation
16:45:09 <pingu> Which is kind of what we're trying to avoid, yeah.
16:45:38 <Axman6> nah, it's too annoying. Also I've decided to try decoding each chunk in a block first, then using that to build a block afterwards (so, a list of (offset, matchlen, literals) roughly)
16:46:18 <pingu> Axman6: is this going to be parallelizable? That's another consideration.
16:46:28 <Axman6> probably not very efficient but i'll allow me to figure out the mutation part of it, then rework it
16:46:51 <Axman6> Can't see why not, it should be able to decode the stream in parallel hopefully
16:46:52 <aristid> this whole FreeT bullshit leads me to think that pipes is not actually the future:(
16:47:09 <Hodapp> FreeT bullshit?
16:47:14 <aristid> yes
16:47:17 <Axman6> I've never thought it was, it seemed far too general and confusing
16:47:25 <Hodapp> I don't know what 'FreeT bullshit' refers to...
16:47:29 <aristid> Axman6: well it got better to some degree
16:47:33 <aristid> Hodapp: pipes-parse
16:47:36 * chrisdone closes all his tvtropes tabs and gets back to work
16:47:39 <NemesisD> aristid: so i couldn't just replicateM await, because it will drop my last page?
16:48:01 <aristid> NemesisD: wait, what would replicateM await even do?
16:48:05 <aristid> i thought you want to split
16:48:41 <Fylwind> What's FreeT?
16:48:42 <NemesisD> i guess split is one way to put it
16:49:20 <aristid> Fylwind: it's a not-really-MonadTransformer for getting higher-level free monad like things
16:49:35 <aristid> and it got only like 3 functions for working with it
16:51:02 <aristid> so a lot of the time, maybe there's something better but this is how i did it so far, is you just write a recursive function directly or maybe unwrap it with runFreeT if necessary
16:51:07 <pingu> Axman6: Okay, I shall poke you tomorrow then around this time and see if you'd like a hand?
16:51:57 <aristid> FreeT is Tekmo's solution to the problem of "how can i get a producer that produces producers, without allowing the reader to skip the contents of one"
16:51:58 <Axman6> pingu: I'll be at work
16:52:15 <pingu> Axman6: Okay, so this is not work related for you then I take it
16:54:09 <NemesisD> aristid: seems like my solution could use next but it would be a bit of a beast
16:54:16 <Axman6> pingu: nope, just fun
16:54:37 <NemesisD> next seems to give you a continuation producer in the slot that monadstate could use
16:54:42 <Axman6> pingu: I'm a patent examiner, there's no programming for me (which is why I'm almost vertainly leaving)
16:54:49 <Axman6> certainly*
16:55:20 <pingu> Axman6: ouch :D
16:55:25 <NemesisD> where's tekmo when you need him :P
16:57:01 <pingu> Axman6: okay, I might take a look at the format and come up with a design myself. Then maybe we can compare notes. Worst case, I run away and hide.
16:57:11 <pingu> (It's not that bad, is it?)
16:57:49 <Axman6> nah, it could be worse. the spec docs are a little ambiguous though, and no one seems to have implemented LZ4 in their own language, everyone has just bound to the C library
16:59:18 <aristid> NemesisD: lol i managed to write a function in ghci that gets from FreeT (Producer ...) to Producer [a]
16:59:52 <aristid> NemesisD: and yes, next is basically the way to manually recurse on producers
17:01:11 <aristid> NemesisD: wanna see me very unpolished ghci code?:P
17:02:00 <NemesisD> aristid: sure. all this much smoke coming off my brain for this task is bumming me out, considering i'm doing this as a cross-language code golf
17:02:16 <aristid> let f p xs = do { x <- next p; case x of Left r -> return (xs, r); Right (v, p') -> f p' (v:xs) }
17:02:25 <aristid> let q = \p -> do (xs,r) <- lift (f p []); yield xs; return r
17:02:33 <aristid> and then just transFreeT q
17:02:50 <aristid> NemesisD: i hopes it makes a non-negative amount of sense!
17:09:09 <aristid> NemesisD: well with the only drawback that it reverses each list:D
17:10:09 <NemesisD> aristid: no offense to you but this just seems like a hell of a lot of work for something simple. maybe i need to change my approach/libs
17:11:07 <aristid> NemesisD: why would i be offended? i'm not happy with the situation either, and i'm not Tekmo :P
17:14:47 <NemesisD> aristid: just because you're trying to help and i'm winging. its just that my alarms are going off that it is this difficult
17:19:12 <ByteEater> how to find out in which module an operator is defined? (I'm trying to nail down ?? specifically at the moment, but a general answer would be better)
17:19:36 <Cale> ByteEater: Is it in scope in ghci?
17:19:39 <Axman6> :info (??) -- in ghci
17:19:41 <Cale> You could use :info (??)
17:19:42 <Cale> yeah
17:20:14 <NemesisD> Pipes.Core is a scary place
17:20:28 <aristid> NemesisD: you don't need Pipes.Core.
17:20:35 <aristid> NemesisD: just "next" should be enough.
17:22:54 <ByteEater> Axman6 & Cale, it's not in scope, but I can use anything, including Hoogle (which oddly doesn't find ??) and Lambdabot
17:23:18 <Cale> ByteEater: Which modules are imported?
17:23:27 <jmcarthur> i liked pipes there for a while, but i'm back to feeling like all the streaming IO libraries are missing something fundamental. it's all just so awkward and verbose.
17:24:27 <aristid> and machines is not the answer either:P
17:24:46 <ByteEater> Cale, Data.Functor and Control.Applicative, but it doesn't matter, I haven't got it in scope, I'm trying to find the module I need to load to bring it into scope
17:24:49 <NemesisD> aristid: hmm here's a thought, if i don't want to have to be so clever, couldn't i do something like chunk :: Int -> Producer (Maybe a) m r -> Producer [a] m r  and have an easier time?
17:25:06 <Cale> ByteEater: What code are you looking at?
17:25:24 <Cale> ByteEater: anyone can define an operator called ?? if they want to
17:25:26 <aristid> NemesisD: you can easily transform a Producer a m r into that Producer (Maybe a m r), sure
17:25:27 <Cale> (including you)
17:25:44 <Cale> ByteEater: So, we kind of need to know more about the context here :)
17:25:45 <aristid> :t yield
17:25:47 <lambdabot> Not in scope: `yield'
17:26:03 <ByteEater> I know, I have the one loaded in Lambdabot by default
17:26:09 <ByteEater> in mind
17:26:15 <Cale> :t (??)
17:26:16 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:26:21 <Cale> huh
17:26:28 <jmcarthur> :t fmap . id
17:26:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:26:33 <jmcarthur> not quite
17:26:38 <NemesisD> aristid: couldn't i just sequence a: yield Nothing at the end of my producer?
17:26:44 <c_wraith> ...  did you seriously just say (. id) ?
17:26:47 <aristid> NemesisD: something like this: \p -> (p >-> P.map Just) >> forever (yield Nothing)
17:26:50 <jmcarthur> i did
17:26:52 <joelteon> :t fmap ($)
17:26:53 <lambdabot> Functor f => f (a -> b) -> f (a -> b)
17:27:00 <Cale> hehe, that's fmap id
17:27:02 <jmcarthur> hah, not much better there
17:27:06 <jmcarthur> i feel better now
17:27:07 <Cale> (which is id)
17:27:20 <joelteon> :t (>>= id)
17:27:21 <lambdabot> Monad m => m (m b) -> m b
17:27:26 <jmcarthur> i believe this means i should go watch star trek instead of coding
17:27:29 <c_wraith> joelteon: you found join
17:27:40 <Cale> :t (\u x -> fmap ($ x) u)
17:27:41 <lambdabot> Functor f => f (a -> b) -> a -> f b
17:27:48 <joelteon> @pl \u x -> fmap ($ x) u
17:27:49 <lambdabot> flip (fmap . flip id)
17:28:33 <chrisdone> has anyone experimented with a simple language that compiles all function application f x y to join (f <$> pure x <*> pure y)?
17:28:37 <jmcarthur> :t \x -> flip . fmap . flip id
17:28:38 <lambdabot> t -> a -> b -> (b -> a -> b1) -> b1
17:28:40 <jmcarthur> ugh
17:28:48 <jmcarthur> yeah. star trek. gbye! :)
17:29:07 <joelteon> :t flip id
17:29:08 <lambdabot> b -> (b -> c) -> c
17:29:13 <chrisdone> so e.g. all functions would return `Applicative f => f a'
17:29:20 <Cale> aha, it's from lens
17:29:28 <Cale> Control.Lens.Combinators
17:29:41 <shachaf> f <$> pure x <*> pure y = pure (f x y)
17:29:42 <stephenmac7> Any way to get the last redirected url from http-conduit?
17:29:43 <Cale> figures
17:29:51 <joelteon> > let f = (+) in (f ?? 3) 4
17:29:51 <Cale> ByteEater: ^^
17:29:53 <lambdabot>  7
17:29:59 <NemesisD> aristid: i've got to step away from the computer for a bit, my eyes are crossing :P
17:30:19 <ByteEater> indeed, thx, Cale
17:30:21 <ByteEater> :-)
17:30:42 <ByteEater> btw, I've always found flip id (which is flip ($)) the most striking example of a missing operator in Prelude
17:31:08 <Cale> lens has that too, it calls it (&)
17:31:13 <Cale> But I hate it :P
17:31:24 <chrisdone> "f (g x) (p x)" would be "join (f <$> join (g <$> pure x) <*> join (p <$> pure x))"
17:31:28 <ByteEater> why? to F#-ish?
17:31:44 <shachaf> ($) is overrated
17:31:47 <Cale> I would rather people just put things in the right order
17:32:38 <chrisdone> i prefer to type "view thing" than "(.~ thing)" (or w/e the operator is)
17:32:40 <zRecursive> :t join
17:32:41 <lambdabot> Monad m => m (m a) -> m a
17:32:45 <ByteEater> I do, but sometimes a the bare function (&) is needed as an argument for something
17:33:20 <Cale> I suppose
17:33:39 <Cale> I'd probably just write the lambda in that case, or possibly flip ($)
17:33:44 <nisstyre> Cale: flip ($) is sort of like RPN
17:33:54 <shachaf> Doing join (liftA2 f x y) rather than x >>= \vx -> y >>= \vy -> f x y is only an optimization, of course.
17:34:35 <shachaf> I mean f vx vy
17:35:30 <chrisdone> someone was talking about applying haskell's type system to an 'imperative' language. seems like converting all function application to applicative style is one way
17:35:50 <joelteon> flip id is one less character
17:36:08 <shachaf> @google monad-embed
17:36:09 <lambdabot> http://timmaxwell.org/pages/monad-embed/
17:36:09 <lambdabot> Title: monad-embed
17:36:31 <hattmammerly> http://bpaste.net/show/r86Mj8QNZ2BgkK476kSM/ So working with this (%s/get/gets/g and a few other changes, not important) how might I make a function that will return a Net () with modified Game? Am I wrong to include game inside of Bot? geekosaur told me that a Net () is implicitly passed around, could anybody explain that a bit more for me?
17:36:38 <shachaf> Anyway, no.
17:36:39 <chrisdone> exactly!
17:37:05 <chrisdone> hm, not quite, that page adds to the type system which is not part of the game
17:37:09 <aristid> chrisdone: someone being liam o'connor aka kamatsu?
17:37:52 <chrisdone> aristid: you also use google+ (゜。゜)
17:38:00 <aristid> chrisdone: ya
17:38:38 <aristid> chrisdone: mostly for the inane popular topics from random people i don't follow, of course
17:40:47 <L8D> RPN is: flip . flip ($)
17:43:51 <jmct> Could any of you point me to any web API wrappers that you consider to be idiomatic haskell?
17:44:35 <jmct> I see a lot that just call curl directly and have everything in the IO monad, which I think is ugly
17:45:12 <Rembane> jmct: http-conduit is said to be good. I haven't done anything real in it yet?
17:45:15 <Rembane> ?=.
17:45:15 <lambdabot> Not enough arguments to @.
17:45:19 <Rembane> :D:D:D
17:45:32 <hattmammerly> I've been pointed towards http-conduit and html-conduit as well
17:45:54 <L8D> What about hquest?
17:47:03 <jmct> Rembane + hattmemmerly: I'll definitely look into http-conduit, thanks!
17:48:49 <jmct> L8D: I hadn't heard of hquest, a quick google search only points to numeric-quest
17:54:53 <frege> do you guys know a good lecture on haskell?
17:55:00 <frege> how to get up and running the basics
17:55:27 <simpson> frege: Weren't you talking earlier this week about how you had to learn Haskell in six hours for some purpose?
17:55:35 <Maior> frege: lecture, pass, but learnyouahaskell.com
17:55:49 <frege> simpson: yeah
17:56:06 <simpson> frege: How'd you do?
17:56:37 <jmct> frege: these lectures slides were pretty popular a while back -> http://shuklan.com/haskell/
17:56:41 <frege> simpson: I'm reading http://www.cs.yale.edu/homes/hudak/Papers/HSoM.pdf riight now but I have a bad cold so I can't concentrate on reading so I was wondering if there is a lecture
17:57:44 <jmct> frege: In that case -> http://www.youtube.com/watch?v=I1zhPHBiVBk&list=PL395B50FC04752DA8&index=2
17:59:33 <benedikt> As someone who hasn't wrapper their head around monads, what does Control.Monad.Fix do? Particularily in the context of the first answer here: https://stackoverflow.com/questions/13300533/haskell-prime-number-generator-according-to-bits-for-very-large-numbers
18:00:04 <ReinH> byorgey: ping
18:00:30 <jmct> benedikt: Do you know what a fixpoint is?
18:01:15 <benedikt> jmct: in math, yes
18:01:25 <benedikt> so probably in haskell too
18:01:40 * hackagebot fast-logger 2.1.3 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.1.3 (KazuYamamoto)
18:02:01 <augur_> ahhhhh! i now understand what PERs are!
18:03:00 <frege> jmct: bullshit course horse shit info :)
18:03:06 <Axman6> pingu: still around?
18:03:31 <jmct> benedikt: So in short, it finds the least fixed point of a monadic computation
18:04:06 <jmct> but not every monadic computation has a fixed point, so you have to show that the  monad in question has one
18:04:09 <ReinH> Well, mfix does
18:04:15 <ReinH> but the answer in question just uses fix iinm
18:04:36 <ReinH> which is just fix f = let x = f x in x
18:04:41 <benedikt> jmct: how is a least fixed point defined? where f x /= y and and their differense is the largest?
18:05:12 <jmct> benedikt: ReinH just defined it
18:05:38 <ReinH> Yeah, mfix doesn't appear anywhere in that SO page ;)
18:05:50 <ReinH> I think they imported Control.Monad.Fix just for easy access to fix
18:06:09 <ReinH> which is kinda weird since it's quite easy to define and doesn't require an import but w/e
18:06:31 <Maior> so um, I want something doing `(a->b) -> [a] -> [(a, b)]` (i.e. "map but keeping original around") - do I just faff with zip and map or does something exist?
18:06:49 <joneshf-laptop> if the derivative of a regular type is its one hole context, what is the second derivative of a type?
18:06:49 <ReinH> fmap (id &&& f)
18:06:52 <ReinH> Maior: ^
18:07:08 <Maior> ReinH: oooh
18:07:10 <ReinH> > fmap (id &&& succ) [1,2,3]
18:07:11 <lambdabot>  [(1,2),(2,3),(3,4)]
18:07:24 <Maior> thanks!
18:07:44 <ReinH> np
18:08:25 <ReinH> so fmap . (id &&&)
18:08:32 <Maior> has anyone built anything like "so here's a type I want, here's a bunch of stuff of existing types, gogo" automagic derivation thing?
18:08:57 <ReinH> Well, there exists a "here's a type signature I want, give me a function"
18:09:07 <Maior> sure
18:09:17 <Maior> (Hoogle right?)
18:09:28 <ReinH> No, free theorems
18:09:29 <ReinH> @djinn (r -> a -> b) -> (r -> a) -> (r -> b)
18:09:29 <lambdabot> f a b c = a c (b c)
18:09:33 <nuttycom1> hey all... I'm a complete Haskell novice and need help. I have a newtype MyType = MyType { unMyType :: Data.Text.Text } and I'm trying to figure out how to create an instance of Database.PostgreSQL.Simple.FromField MyType. This looks like it should be utterly trivial, since the type of fromField is Field -> Maybe ByteString -> Ok a , and Ok has a Functor. Through some trial and error I've found that fromField f m = fmap MyType 
18:09:52 <ReinH> I just asked djinn for <*> on (r ->) ;)
18:10:05 * Maior reads Wadler
18:10:49 <ReinH> nuttycom1: the GeneralizedNewtypeDeriving extension would probably help :)
18:10:50 <Cale> @free ap :: (r -> a -> b) -> (r -> a) -> (r -> b)
18:10:50 <lambdabot> (forall x. h . k x = p (f x) . g) => g . q = f1 . f => h . ap k q = ap p f1 . f
18:11:12 <Cale> nuttycom1: Did you have a question?
18:11:32 <Cale> nuttycom1: your message ended at "Through some trial and error I've found that fromField f m = fmap MyType"
18:11:33 <nuttycom1> The question was the bit at the end - "is there a way to do this point-free"?
18:11:43 * hackagebot fast-logger 2.1.4 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.1.4 (KazuYamamoto)
18:11:44 <Axman6> nuttycom1: it got cut off for being too long
18:11:50 <ReinH> nuttycom1: "point-free"? Don't know, but you could just ask GHC to derive it.
18:12:10 <nuttycom1> Ah. "fromField f m = fmap MyType $ fromField f m works, but is there a way to do this point-free?"
18:12:14 <ReinH> Cale: what did that @free just show me?
18:12:24 <Cale> ReinH: The free theorem for ap
18:12:28 <Cale> (for the function type)
18:12:30 <nuttycom1> ReinH: cool, I'll look into that, thanks.
18:12:52 <ReinH> Cale: My brain isn't turning that into meaningful words though. What is that free theorem?
18:12:54 <Cale> fmap (fmap MyType) . fromField
18:13:11 <ReinH> nuttycom1: I don't think point-free is any better for that case
18:13:12 <Cale> Well, that's a ludicrous example
18:13:37 <Cale> @free length :: [a] -> Integer
18:13:38 <lambdabot> length = length . $map f
18:13:50 <ReinH> sure
18:13:56 <Cale> @free map :: (a -> b) -> [a] -> [b]
18:13:56 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
18:13:59 <nuttycom1> ReinH: fair enough, I'm just learning and was just curious
18:14:00 <MedDev> frege, The Haskell School of Expression by Hudak is very good (got me started) and includes a bit of content from HSoM, plus it has a lot less domain specific knowledge (of music) than HSoM
18:14:09 <ReinH> Cale: Well those make sense ;)
18:14:29 <Cale> ReinH: These theorems are automatic from the nature of the polymorphism in the type
18:14:44 <Cale> ReinH: and there's an algorithm for constructing them :)
18:14:57 <ReinH> Cale: yes, I do sort of understand "free theorems" enough to be familiar with that ;)
18:16:44 * hackagebot wai-logger 2.1.1 - A logging system for WAI  http://hackage.haskell.org/package/wai-logger-2.1.1 (KazuYamamoto)
18:17:07 <ReinH> Cale: I know that fmap f . fmap g = fmap f . g is free given the identity law due to parametricity, for instance.
18:17:28 <ReinH> I missed a paren there ofc
18:17:32 <Cale> ah, yeah
18:17:36 <ReinH> fmap (f . g)
18:22:24 <ReinH> Cale: I have read Wadler's paper multiple times in an attempt to get the ideas to sink in and they are sort of starting to :)
18:22:34 <ReinH> I'm frustratingly slow about some things
18:23:57 <Cale> I think it's a lot easier to get an intuition for what free theorems are about than to get the details about computing them.
18:25:26 <ByteEater> can Djinn be instructed to recognize list types?
18:25:37 <augur_> so Cale: reading the FastAndLoose paper has forced me to twiddle with PERs enough that i get them intuitively now
18:25:56 <augur_> and i wish someone had described them the way i now get them
18:26:07 <benedikt> ghci can't import Math. found math-functions in cabal but that doesn't help
18:26:10 <ReinH> augur_: please do so for me then :D
18:26:17 <geekosaur> I think djinn (as is at least) cannot deal with recursive types?
18:26:20 <ReinH> augur_: pay it forward or something ;)
18:26:20 <augur_> ReinH: so you know what an equivalence relation is
18:26:21 <augur_> ?
18:26:32 <Cale> benedikt: What are you trying to do?
18:26:37 <geekosaur> benedikt, I doubt that Math is a module as such. ^
18:26:46 <benedikt> Cale: import Math :)
18:26:48 <Cale> benedikt: There is no base package module called Math
18:26:49 <ReinH> augur_: a way of partitioning a set such that blah blah, yes
18:26:58 <Cale> benedikt: Which Math are you talking about?
18:27:08 <benedikt> Cale: there are many?
18:27:12 <ReinH> augur_: reflexive, symmetric, transitive
18:27:21 <augur_> ReinH: right
18:27:22 <benedikt> I'm currently looking for Math.NumberTheory.Primes
18:27:22 <ReinH> augur_: that good enough? :)
18:27:24 <Cale> Potentially? Well, I know of 0 of them.
18:27:43 <Cale> oh, in that case, that exists
18:27:47 <Cale> In arithmoi
18:27:51 <Cale> cabal install arithmoi
18:27:57 <augur_> ReinH: so basically, take an equivalence relation R, and throw into its domain a bunch of elements that arent related to anything at all (not even themselves)
18:28:00 <Cale> (but "Math" doesn't)
18:28:04 <augur_> and now you have a PER.
18:28:21 <ReinH> What does PER stand for?
18:28:27 <augur_> partial equivalence relation
18:28:28 <Cale> partial equivalence relation
18:28:30 <ReinH> oh hhe
18:28:32 <ReinH> sure
18:28:36 <benedikt> Cale: ah, i see. There isn't a "Math" module, but it is sort of like a namespace that math-modules use?
18:28:50 <ReinH> augur_: gotcha
18:28:54 <augur_> thats it
18:28:54 <Cale> benedikt: Yeah, it's all arbitrary. Dots are allowed in module names.
18:28:56 <augur_> thats a PER
18:29:05 <benedikt> Cale: thanks
18:29:08 <ReinH> augur_: oh ok
18:29:08 <Cale> benedikt: and when they occur, ghc will look in directories correspondingly
18:29:11 <augur_> an ER + some random points that arent related to anything at all
18:29:24 <ReinH> augur_: and where do these come in handy?
18:29:40 <augur_> well apparently _|_ is one such random point
18:29:59 <augur_> so handling partiality and non-termination requires PERs
18:30:38 <ReinH> augur_: oh yeah that's obvious enough now
18:38:04 <Maior> @pl bfs pred tree = head $ takeWhile pred $ concat $ levels tree
18:38:04 <lambdabot> bfs = (head .) . (. (join . levels)) . takeWhile
18:50:25 <ReinH> Maior: you can easily remove the `tree' point
18:50:30 <ReinH> Not very easy to remove the `pred' point
18:50:43 <ReinH> bfs pred = head . takeWhile pred . concat . levels
18:50:49 <ReinH> I wouldn't be tempted to go further personally
18:51:52 <ReinH> Maior: also I would prefer listToMaybe to head since a search can fail
18:52:06 <ReinH> and Nothing is probably better than error "head - empty list"
18:53:23 <Maior> ReinH: yeah was just looking at the tree
18:53:37 <Maior> and gp re listToMaybe, thanks - figured I'd look at the "error handling" later
18:53:50 <Maior> (turns out writing a solitaire solver is more fun than playing it)
18:53:55 <ReinH> heh :)
18:59:15 <ChongLi> does an mvar use compare-and-swap semantics?
19:00:01 <ChongLi> with modifyMVar, for example
19:01:17 <ChongLi> I guess if all threads use modifyMVar, then blocking will protect us?
19:01:58 <Rarrikins> Yes.
19:02:33 <Rarrikins> It will take, blocking other threads, and put, unblocking other threads, both operations atomic.
19:02:42 <ChongLi> okay great
19:02:55 <ChongLi> if I want some sort of optimistic strategy, I guess I should use a TVar?
19:03:03 <chrisdone> reinh: see! =p
19:03:09 <Axman6> that's not CAS though...
19:03:10 <Rarrikins> I'm not sure about that. I've only used MVars.
19:03:13 <chrisdone> writing games is more fun than playing games
19:03:14 <Rarrikins> What is the T for?
19:03:16 <Axman6> the whole operation isn't atomic
19:03:25 <stephenmac7> How do I ignore case when using the read function?
19:03:27 <stephenmac7> :t read
19:03:28 <Rarrikins> Yeah, it's two atomic parts.
19:03:28 <lambdabot> Read a => String -> a
19:03:39 <Axman6> someone might put between the the take and the attempted put
19:03:47 <Rarrikins> But not atomic together.
19:04:06 <Rarrikins> Two atoms, so to speak.
19:04:09 <Axman6> ChongLi: if you want CAS, IORef is better, though doesn't provide blocking
19:04:19 <ChongLi> IORef is CAS?
19:04:41 <randomclown> compare & swap
19:04:47 <Axman6> with atomicModifyIORef it is
19:04:56 <hdevalence> under what circumstances is map f . map g converted to map (f . g) ? always? sometimes?
19:05:02 <Axman6> @hoogle atomicModifyIORef
19:05:03 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
19:05:11 <ReinH> chrisdone: eh?
19:05:22 <Rarrikins> hdevalence: Whenever the RULES optimization fires. For that, probably always.
19:05:26 <hdevalence> if I write code, is it better to do map f . map g . map h or map (f . g . h) ?
19:05:37 <Rarrikins> hdevalence: Whichever is clearer.
19:05:40 <stephenmac7> Or rather, how do I implement the Read typeclass?
19:05:40 <hdevalence> or is that just a style item
19:05:41 <hdevalence> ah
19:05:43 <ReinH> chrisdone: what am I seeing? ;)
19:05:45 <hdevalence> thanks
19:05:47 <ChongLi> I've asked this before but I feel like I should ask again
19:05:51 <Rarrikins> hdevalence: No problem.
19:05:51 <Axman6> hdevalence: what ever's more readable. it should always get fused with optimisations turned on
19:05:56 <ChongLi> what's a good queue structure?
19:06:06 <ChongLi> I was thinking of just rolling my own by using a pair of lists
19:06:09 <stephenmac7> Assuming something like data SomeType = ThisType | ThatType
19:06:18 <ChongLi> ins and outs
19:06:18 <chrisdone> reinh: http://ircbrowse.net/day/haskell/today?id=17233383&timestamp=1389494882#t1389494882
19:06:18 <ReinH> ChongLi: do you need priority?
19:06:25 <ChongLi> no
19:06:29 <ChongLi> just a straight queue
19:06:32 <stephenmac7> But reading "thistype" and "thattype"
19:06:50 <ReinH> chrisdone: oh I missed that line somehow
19:06:52 <Rarrikins> @type <|
19:06:52 <Axman6> ChongLi: Okasaki has a nice implementation using three lists that gives O(1) append and read
19:06:53 <lambdabot> parse error on input `<|'
19:06:55 <Rarrikins> @type (<|)
19:06:56 <lambdabot> Cons Control.Lens.Internal.Review.Reviewed Identity s s a a => a -> s -> s
19:06:58 <ReinH> chrisdone:  and yes, it is :)
19:07:12 <ChongLi> Axman6: that's amortized right?
19:07:19 <ChongLi> eventually a list is going to get reversed?
19:07:21 <Axman6> I don't think so
19:07:23 <ReinH> ChongLi: would Data.Sequence be enough?
19:07:25 <Rarrikins> @hoogle (<|)
19:07:26 <lambdabot> Data.Sequence (<|) :: a -> Seq a -> Seq a
19:07:26 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
19:07:26 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
19:07:34 <Axman6> it does the reversals when you append or read one item at a time
19:07:37 <chrisdone> perhaps it's implemented like
19:07:53 <ReinH> Sequence uses a finger tree implementation iirc, not sure how it compares to Okasaki's
19:08:05 <ChongLi> Data.Sequence seems rather heavy
19:08:10 <ReinH> ChongLi: why?
19:08:19 <ChongLi> well
19:08:22 <ChongLi> heavy is the wrong word
19:08:29 <ChongLi> the API is big and general
19:08:41 <ChongLi> I just need the ability to put things in one end and take em from the other :)
19:08:54 <Rarrikins> ChongLi: Yeah, but you can restrict yourself to a few of those functions.
19:09:06 <jfischoff> ChongLi: I think it is mostly just the Foldable API
19:09:10 <ChongLi> and to compose that with an MVar or something
19:09:19 * jfischoff looks
19:09:32 <ReinH> ChongLi: ok, newtype MyQueue a = MyQueue (Seq a) and implement whatever you want ;)
19:09:37 <Axman6> ChongLi: http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf page 43 I think
19:09:49 <ReinH> it has the structure you need with the asymptotics you want :p
19:09:51 <ChongLi> the basic idea is to create a queue for gathering up events produced by callbacks
19:10:08 <ChongLi> so that I can sample them for Wires
19:10:11 <ReinH> ChongLi: you sure you don't want a channel?
19:10:28 <ChongLi> I was using a TChan
19:10:36 <ChongLi> but that's a bit heavy, no?
19:11:01 <zacts> haskell syntax is so beautiful
19:11:19 <jfischoff> if you need concurrency no, otherwise yes
19:11:30 <jfischoff> ChongLi: ^
19:11:33 <ChongLi> ReinH: the Control.Current.Chan blocks if you read when it's empty
19:11:35 <ReinH> zacts: confirm
19:11:48 <ChongLi> which is no good in a single-threaded context :)
19:12:11 <jfischoff> it sounds like you really do want Data.Sequence
19:12:32 <ReinH> Ok, Data.Sequence it is ;)
19:12:45 <Rarrikins> It having a lot of operations isn't necessarily a sign of it being inefficient at all.
19:12:46 <Axman6> ChongLi: http://lpaste.net/98337
19:12:50 <ChongLi> and it's better than okasaki's triple list?
19:12:59 <ReinH> ChongLi: it has the essential quality of existing.
19:13:02 <ReinH> So in that way it is better.
19:13:03 <Axman6> something I wrote a while ago after reading okasaki
19:13:04 <ChongLi> I really should buy okasaki's book
19:13:04 <chrisdone> rarrikins: how about http://lpaste.net/63372
19:13:05 <zacts> ReinH: I just like the look of it, sometimes it's like heiroglyphs. various operators too..
19:13:31 <ChongLi> Axman6: this is nice, it should be on hackage :)
19:13:40 <ReinH> ChongLi: Data.Sequence is the standard "I need a list with better asymptotics for more operations" structure
19:13:49 <ReinH> It's implemented efficiently using finger trees
19:13:58 <ReinH> So not the Okasaki impl but a perfectly serviceable one
19:13:58 <ChongLi> I don't know what finger trees are :)
19:14:10 <ReinH> ChongLi: and you don't need to to use Seq ;)
19:14:16 <Rarrikins> chrisdone: That looks concurrenty.
19:15:00 <Axman6> ChongLi: eh, there's a lot of stuff missing from it really. I think I wrote it for use in the Par monad's scheduler but it turned out to have rubbish performance compared to what they were already using
19:15:02 <chrisdone> rarrikins: it's intended for that use-case, yeah
19:15:09 <ReinH> chrisdone: it's also implemented as MVar [a], so O(n) for one end right?
19:16:08 <ReinH> Taking away all the concurrency you're left with [a] which isn't a particularly efficient struture for a queue...
19:16:13 <chrisdone> reinh: yea, performance wasn't a concern, i just wanted a Chan whose list i could look inside of
19:16:15 <Rarrikins> I wish the compiler could optimize that away.
19:16:18 <ReinH> chrisdone: sure :)
19:16:26 <Axman6> ChongLi: the nice thing about my code is that it makes reading and writing concurrently really nice using atomicModifyIORef
19:16:29 <ReinH> Rarrikins: optimize which away?
19:16:49 <Rarrikins> Just keep a pointer to the end of the list, set the next pointer to null to cut the item off the end.
19:17:00 <Rarrikins> Assuming you don't need the rest of the list somewhere else.
19:17:03 <ChongLi> Axman6: oh yeah?
19:17:27 <Rarrikins> You'd need a doubly-linked list.
19:17:31 <ReinH> Rarrikins: I don't think that's compatible with non-strictness
19:17:47 <ChongLi> I'm trying to get a picture of the behaviour of this
19:17:48 <Rarrikins> Can you do doubly-linked lists nonstrictly?
19:17:50 <ReinH> but that's a hunch, not a well founded statement
19:18:02 <ChongLi> so atomicModifyIORef uses CAS semantics with retrying?
19:18:03 <Rarrikins> I've never tried, so I'm not sure either way.
19:18:23 <chrisdone> i don't think you can construct a proper doubly linked list without non-first-class support
19:18:33 <ReinH> doubly linked lists require tying the knot
19:18:43 <Rarrikins> Yeah, tying the knot is what it was.
19:18:52 <c_wraith> it makes them not very useful
19:19:09 <ChongLi> what are the common uses for doubly-linked lists anyway?
19:19:13 <ReinH> and you need to construct it all at once
19:19:15 <c_wraith> Might as well use an array, if any modification will have to create a whole new one, anyway
19:19:16 <Rarrikins> Queues, for one.
19:19:22 <pingu> Axman6: I am still around.
19:19:23 <chrisdone> going back and forwards with O(1)
19:19:27 <Axman6> ChongLi: IQ a = IVar (Q a); deIQ :: IQ a -> IO (Maybe a); deIQ ref = atomicModifyIORef deQ; enIQ :: IQ a -> a -> IO (); enIQ ref x = atomicModifyIORef (\q -> (enQ q a, ())
19:19:36 <ChongLi> why not use a zipper?
19:19:37 <Rarrikins> Yeah, neighbor traversal.
19:19:47 <ReinH> ChongLi: you can, but it's a lot of trouble to go to
19:19:57 <Rarrikins> ChongLi: That's essentially a doubly-linked list right there.
19:20:05 <ReinH> if you want something like that you probably want ... Data.Sequence ;)
19:20:11 <ChongLi> ReinH: hahaha
19:20:20 <Axman6> pingu: I think I figured out my issue. I found it odd that you had to have a match length of 4 or more, ratherallowing 0 length matches, but it makes sense now
19:20:24 <ReinH> it is literally designed for those use cases
19:20:28 <ReinH> fast insertion, deletion, etc
19:20:36 <ReinH> that you might use a doubly-linked list for
19:20:45 <chrisdone> i wonder
19:20:45 <pingu> Axman6: Yeah, I don't understand the rationale behind those parsing restrictions
19:21:02 <chrisdone> could you have a queue built up like a list data structure, but from two sides?
19:21:03 <chrisdone> e.g.
19:21:10 <pingu> Axman6: I think I'd find the code easier to read than his writeup. More precice, at least.
19:21:25 <chrisdone> data Queue a = Queue a (Maybe (Queue a)) a | Singleton a
19:21:25 <ReinH> chrisdone: I assume you don't mean a deque?
19:21:27 <Axman6> pingu: it sort of makes sense, you output literals until you have a match of at least 4 bytes within those literals for the first sequence
19:21:27 <ChongLi> chrisdone: the one Axman pasted uses 3 lists
19:21:34 <ReinH> ChongLi: hmm
19:21:45 <ReinH> er chrisdone: hmm
19:22:03 <ChongLi> now here's the other question
19:22:04 <chrisdone> so you can always get the start and end in O(1), and always append or prepend in O(1)
19:22:08 <ChongLi> what about strictness?
19:22:08 <Axman6> pingu: the code is pretty painful to read imo. I was really hoping that there'd be a pure Go implementation somewhere, but there's only bindings
19:22:14 <chrisdone> (but traversal would be O(n))
19:22:24 <ReinH> My tab-complete is set to most-recent first. ChongLi committed a timing attack against me. :(
19:22:28 <ChongLi> it's no good if there's a big thunk sitting there on one end
19:22:30 <chrisdone> hm. i'll try this
19:22:36 <Axman6> actually, I think there is a Go imeplementation, but i fount it pretty confusing
19:22:43 <ChongLi> ReinH: I don't mind your hmm
19:22:51 <ReinH> ChongLi: heh
19:23:15 <ChongLi> I guess I should just try it and worry about strictness later
19:23:29 <Axman6> pingu: on a brighter node, I now have a decoder for blocks in the streaming format =)
19:26:54 <ChongLi> anyone else here watch some of Bob Harper's HoTT lectures?
19:32:54 <Axman6> pingu: I can currently decode [runPut (putWord32le 8), makeSequence "1234" 2 4, "xxxx"] into the output and checksum ("12343434", "xxxx"). no checksum support yet obviously
19:33:49 <jmcarthur> chrisdone: finger trees are actually structured similarly to that, but with properties that give better running times for many operations
19:33:51 <ReinH> ChongLi: watch? where?
19:34:10 <ReinH> chrisdone: yeah so you basically implemented shitty finger trees! *ducks*
19:34:14 <ChongLi> ReinH: http://scs.hosted.panopto.com/Panopto/Pages/Sessions/List.aspx#folderID=%2207756bb0-b872-4a4a-95b1-b77ad206dab3%22&sortColumn=1&sortAscending=true
19:34:32 <ReinH> ChongLi: woah amazing thanks!
19:34:44 <ChongLi> if the lectures seem low framerate
19:34:48 <ChongLi> that's because they are
19:34:50 <ReinH> haha that's ok
19:34:59 <jmcarthur> chrisdone: i think cons/snoc for your type might be O(n), for example
19:35:01 <ChongLi> the bottom right window is to show the lecturer moving around
19:35:12 <ReinH> ChongLi: by way of repayment here's a youtube channel on cat theory https://www.youtube.com/user/TheCatsters
19:35:13 <ChongLi> the main window is designed to let you read the blackboard easily
19:35:18 <ReinH> ChongLi: perfect :)
19:35:25 <ChongLi> ReinH: haha, I've actually already watched those
19:35:28 <jmcarthur> chrisdone: hmm... maybe not
19:35:28 <ReinH> ChongLi: oh ha :)
19:35:35 <ChongLi> a year ago or so
19:35:44 <jmcarthur> oh, yeah, they must be i think. maybe i should just try to implement them to be sure
19:35:46 <ReinH> I picked up a couple algebra and cat theory books from Powell's Technical Bookstore today, yay!
19:36:02 <ChongLi> http://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
19:36:09 <ChongLi> this is another fantastic set of lectures
19:36:16 <ChongLi> including Bob Harper
19:36:17 <ReinH> ChongLi: oh great thanks :)
19:36:25 <ReinH> ChongLi: please keep 'em coming if you have more :)
19:36:28 <jmcarthur> chrisdone: in any case, the way finger trees work is really cool and worth learning
19:36:43 <joelteon> how do I shut down a warp server?
19:36:47 <joelteon> like, within code
19:36:51 <ChongLi> Bob Harper, Steve Awodey and Frank Pfenning have a sort of trinity of lectures
19:37:13 <ChongLi> attacking computer science from three angles: type theory, proof theory and category theory
19:37:19 <ReinH> ChongLi: I tend to be a better auditory learner so these lectures are great for me
19:37:31 <ReinH> ChongLi: SEEMS GOOD
19:37:48 <joelteon> like, I need to run a server as part of my app and then shut it down after I receive a certain request
19:37:50 <ChongLi> ReinH: to get the most out of you need to watch them in chronological order
19:37:50 <ReinH> ChongLi: yeah cat theory and lambda calc are two greatly complimentary approaches
19:38:05 <joelteon> is there a better library for that than warp?
19:38:08 <ChongLi> this page does not list them that way
19:38:24 <ChongLi> watch Lecture 1 (parts 1-3) from Bob Harper first
19:38:31 <ChongLi> he sets the basic outline
19:38:35 <ReinH> ChongLi: thanks :)
19:39:07 <ChongLi> by the way, I think it's funny how he loves to knock Haskell around
19:39:16 <ChongLi> people seem to get really upset when he does it
19:39:27 <ChongLi> but he's right for the most part
19:39:50 <ChongLi> he's also said he thinks Haskell's the second best language in the world (behind SML) so it's not like he hates it
19:39:58 <joelteon> like, did someone write a quick and dirty library for serving 1 webpage
19:40:43 <jmcarthur> ChongLi: his technical critiques of haskell are totally correct, but his subjective remarks on their significance are kind of overblown, IMO
19:41:01 <ChongLi> jmcarthur: well, his priorities are different
19:41:08 <jmcarthur> right
19:41:12 <ChongLi> he likes sum types
19:41:12 <jmcarthur> and that's fine
19:41:33 <ChongLi> and induction
19:41:36 <jmcarthur> i think he just doesn't make his priorities explicit enough for everybody to understand what he's going on about
19:42:05 <jmcarthur> and so they think he's just kind of lashing out and trying to destroy anything that isn't SML
19:42:06 <ChongLi> he is jealous of the composability of Haskell's combinators (thanks to laziness)
19:43:02 <ChongLi> and he's totally right about anti-modularity vis-a-vis imperative programming and inheritance
19:43:37 <chrisdone> http://lpaste.net/98338 something vaguely like that but something to rebalance the middle bit to not
19:43:52 <ChongLi> plus he's just one of those people that comes off as way more aggressive and blunt in writing than he does in person
19:43:54 <chrisdone> to not have the empty slots
19:44:06 <ChongLi> he's a charming and skilled lecturer
19:45:17 <jmcarthur> chrisdone: ah, cool. your functions for accessing the ends are not recursive at all. good sign.
19:45:52 <chrisdone> if i take the time to re-balance the middle bit, the end should always be one or two steps away… i think
19:46:00 * chrisdone looks up finger trees
19:49:02 <jfischoff> what are some good resources for learning to read the asm from -ddump-asm?
19:49:21 <tswett> I'm wondering if, if x and y are finite floating point numbers such that x ≥ y ≥ 0, it is necessarily the case that the expression (x - y) + (x - (x - y)) == x evaluates to True.
19:49:27 <tswett> Not that it matters much; I'm just curious.
19:49:40 <lispy> jfischoff: I doubt there is any. You could look in the ghc source and wiki for 'commentary' about the asm
19:49:44 <jmcarthur> chrisdone: your start and end functions are broken. e.g   end (prepend empty ())
19:49:54 <jfischoff> lispy: good point
19:49:58 <geekosaur> tswett: with IEEE floating point, quite possibly not the case
19:50:34 <lispy> jfischoff: and don stewart's blog has some output from dump-asm that he talks about. I just don't think it will provide much insight.
19:50:35 <chrisdone> jmcarthur: what are you expecting there? you're prepending to the start and then asking for the end?
19:50:38 <Axman6> jfischoff: ghc-core is a great tool to help, it shows you the core  too so you know what names to look for in the ASM
19:50:47 <lispy> jfischoff: the articles are more like, "look how much better the llvm asm is!"
19:50:54 <chrisdone> jmcarthur: oh, i guess one would expect it to act like one data structure. sure
19:50:56 <tswett> geekosaur: yeah, I'm not sure how to go about figuring it out. But I tested it with QuickCheck, and it checked out.
19:51:05 <Axman6> yeah LLVM is a hell of a lot easier to read
19:51:05 <jmcarthur> chrisdone: i would expect a queue to act like a queue? ;)
19:51:06 <jfischoff> Axman6: yeah that's what I am looking at.
19:51:07 <chrisdone> jmcarthur: i guess that's easy to fix
19:51:29 <jfischoff> I don't really understand the calling convention
19:51:39 <kristof> Oh
19:51:59 <kristof> Is C-- still the predominant language used to implement GHC?
19:52:00 <geekosaur> well, it depends on a bunch of things, such as whether things get kept in floating point registers or not --- on Intel at least, as long as it stays in the CPU it has more bits than it has if spilled to memory
19:52:10 <kristof> Or did they move to LLVM?
19:52:20 <Axman6> kristof: they convert Cmm into LLVM
19:52:27 <chrisdone> jmcarthur: http://lpaste.net/98338
19:52:33 <Axman6> Cmm is used for both the NCG and LLVM
19:52:36 <kristof> Axman6: ...Why not just write directly in LLVM?
19:52:47 <Axman6> see above
19:53:00 <geekosaur> it is quite complex and whether you use ghci, compile without optimization, or compile with optimization matters. also probably whether it's on x86ish or ARM or <other arch here>
19:53:08 <chrisdone> jmcarthur: i'm thrilled i implemented an off-the-cuff data structure that you're taking seriously =p
19:53:10 <jmcarthur> chrisdone: hmm... there must be some invariant you're using that i don't see
19:53:22 <chrisdone> jmcarthur: hm?
19:53:41 <jmcarthur> chrisdone: i don't see why start and end don't have to be recursive
19:53:43 <geekosaur> also probably, with ghc, some differences between -fasm and -fllvm (and hey I just tied into the other in-channel discussion :p )
19:53:54 <Axman6> kristof: LLVM is too low level for a lot of the optimisation GHC needs to do afaict
19:54:16 <lispy> and LLVM isn't always available (not sure if that would affect using it as an IR)
19:54:16 <chrisdone> jmcarthur: ah, because every time you append it grabs the current end and brings it up a level, making the new middle child's empty
19:54:21 <chrisdone> jmcarthur: and the same for the other side
19:55:27 <chrisdone> λ> (prepend (prepend (append empty "old-end") "old-start") "new-start")
19:55:27 <chrisdone> Q (Just "new-start") (Just (Q (Just "old-start") Nothing Nothing)) (Just "old-end")
19:55:28 <jmcarthur> chrisdone: indeed it is still broken...   end (prepend (prepend empty 2) 1)
19:55:34 <kristof> Axman6: Hmmm, I thought Cmm and LLVM targeted the exact same problem domain
19:55:54 <geekosaur> I always understood LLVM to be a lower level
19:55:57 <Axman6> no
19:56:08 <kristof> Someone misinformed me, then
19:56:28 <Axman6> kristof: Cmm has much higher order primitives like loops and such
19:56:30 <Axman6> I think
19:56:41 <geekosaur> my understanding: Cmm is kinda a semi-portable layer above the asm layer; LLVM is a replacement of the adm layer
19:56:47 <geekosaur> *asm layer
19:56:57 <kristof> Ok, Axman6 and geekosaur, that makes sense.
19:57:10 <geekosaur> actually I see Cmm as being on approximately the same level as languages like BLISS
19:57:25 <kristof> Been a while since I've heard someone talk about BLISS
19:57:28 <chrisdone> jmcarthur: ah, yeah, there's the fatal flaw. i was making a dumb assumption
19:57:29 <geekosaur> compiler intermediate languages
19:58:04 <Axman6> kristof: https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CmmType gives you some info
19:58:33 <kristof> Axman6: thanks for the link
19:59:13 <kristof> Ah, it's a "high level assembler"
20:00:26 <Axman6> and llvm is a pretty low level assembler
20:00:51 <jmcarthur> i've never quite taken the time to fully absorb okasaki style data structures. i think i'm going to try to reinvent persistent real time queues.
20:00:54 <ChongLi> Cmm is one of those things that had to be invented because LLVM didn't exist yet
20:00:58 <augur_> kristof: you wouldnt happen to be krismicinski on twitter would you
20:01:06 <kristof> augur_: negatory
20:01:11 <augur_> darn!
20:01:15 <kristof> sorry :(
20:01:30 <kristof> I'm not a regular Haskeller either, I usually lisp :)
20:01:42 * chrisdone knows krystof from #lisp =p
20:01:55 <kristof> ah yes he's a smart guy :)
20:02:00 <ChongLi> but, but, but... types!
20:02:05 <ChongLi> haha
20:02:17 <jmcarthur> ah, hmm. i see that dequeues are going to be tougher. will stick to queues first
20:02:21 <kristof> ChongLi: types are the most simultaneously overrated and underrated concept
20:02:24 <tswett> I think nowadays I spend less time writing LISP than I do actually lisping.
20:02:32 <ChongLi> I've been watching a bit too much Bob Harper
20:02:37 <djahandarie> jmcarthur, I recently bought a copy. It's currently just sitting on my shelf at work though.
20:02:40 <ChongLi> he's a type zealot!
20:02:57 <tswett> Seems like pretty much every high-level programming language nowadays has types. It's just, y'know, are they static?
20:03:28 <ChongLi> a dynamically typed language is just a unityped language
20:03:40 <djahandarie> jmcarthur, (of his book, if that wasn't clear.)
20:03:44 <kristof> All static typing gives you is small proofs of your program. Good, useful, and neat, but not the most glorious programming construct in existence.
20:03:50 <chrisdone> sbcl has a sophisticated static analyser, it knows a fair bit about numbers
20:04:03 <jmcarthur> djahandarie: is the book different from the stuff available online?
20:04:04 <kristof> chrisdone: Also has nice type propagation
20:04:09 <ChongLi> kristof: no, they let you do a lot of inference
20:04:16 <kristof> ChongLi: Inference to...
20:04:22 <kristof> Prove your program.
20:04:33 <ChongLi> no, inference *of* your program from the types
20:04:34 <chrisdone> one of my favourite things about types is that it's a language for talking about programs
20:04:37 <tswett> Dynamically typed languages still have multiple different types. They're just all interchangeable.
20:04:40 <sm> aside: is there a flag to make ghci not shout about .ghci being owned by someone else ?
20:04:45 <djahandarie> jmcarthur, yes, it's more in-depth than his dissertation.
20:04:59 <ChongLi> and with HoTT we may see things even crazier than that
20:05:08 <chrisdone> it's much easier to just say (a -> b) -> [a] -> [b] than "take a function that applies it to every… snore"
20:05:09 <jmcarthur> djahandarie: well i guess it's going on my books-to-get list then
20:05:17 <chrisdone> that part of types doesn't get much attention
20:05:21 <ChongLi> since HoTT has some incredibly powerful notions of equality
20:05:32 <chrisdone> (in type-advocacy, anyway)
20:05:50 <ChongLi> I shudder to think of the sorts of transformations a compiler could perform with HoTT
20:05:55 <djahandarie> jmcarthur, :). Unfortunately the Haskell code is banished to an appendix.
20:06:01 <djahandarie> (ML is used inline.)
20:06:08 <kristof> ChongLi: You're going to have to be more specific than that. I'm not sure what you're referring to; I've always treated type inference as a blessing to have statically typed programs, where I don't necessarily have to type everything manually.
20:06:19 <ChongLi> kristof: HoTT is homotopy type theory
20:06:25 <kristof> ChongLi: No, I know what that is
20:06:32 <ChongLi> it's newly-discovered
20:06:38 <ChongLi> and not yet implemented in any language
20:06:45 <kristof> I meant the phrase "inference *of* your program from the types"
20:06:52 <tswett> Is there any sort of "gentle introduction to HoTT for Haskell programmers who happen to know a little bit about category theory and topology"?
20:07:01 <kristof> tswett: The book.
20:07:02 <ChongLi> but it has the potential for letting you prove the equality of functions in a mechanical way
20:07:07 <tswett> Ah yes, reverse type inference.
20:07:08 <chrisdone> jmcarthur: so i'm not a data structure genius after all. but it was fun =p i can tell if i sit here for long enough i'll be tempted by its elusive prizes and waste many-a-howa
20:07:16 <ChongLi> and in general
20:07:24 <kristof> ChongLi: ...why do I need that?
20:07:27 <ChongLi> proving the equality of large paths through your program
20:07:33 <kristof> Oh, hmm
20:07:35 <kristof> So graph reduction
20:07:38 <ChongLi> yes
20:07:43 <chrisdone> it's surprising how fun it is to trry to come up with efficient data structures for no reason other than their inherent efficiency :>
20:07:47 <jmcarthur> chrisdone: i do this all the time. i usually fail.
20:07:52 <chrisdone> :D
20:08:01 <ChongLi> it may give us the holy grail of supercompilation
20:08:32 <ChongLi> or whatever you want to call it
20:08:34 <chrisdone> chongli: now that's how to keep a level head :3
20:08:46 <kristof> chrisdone: He did include the word "may"
20:08:57 <chrisdone> 'holy grail' negates any qualifiers =p
20:09:22 <Rarrikins> 'It's only a model' negates any castles.
20:09:28 <Axman6> chrisdone: I do it all the time (or used to, when I had time :(
20:09:33 <tswett> chrisdone: come up with an efficient data structure representing context-free languages!
20:09:36 <chrisdone> axman6: <3
20:09:37 <tswett> And I said languages, not grammars.
20:09:46 <ChongLi> well, I'm really optimistic but I don't fully understand the implications
20:10:03 <chrisdone> tswett: what's the diff. between language and grammar in your sentence?
20:10:13 <ion> ‘holy crap’ negates any qualifiers
20:10:22 <ChongLi> I'm hoping more people will watch the lectures or read the books and explain some more stuff to me
20:10:24 <chrisdone> lol
20:10:51 <kristof> ChongLi: I'm sorry, but graph reduction is really the only benefit I can see from this, which goes back to efficiency and correctness proving. Which are both good, but like I said, types are not the most awe-deserving concepts in computer science.
20:11:10 <tswett> chrisdone: a context-free grammar determines a set of strings. A context-free language is just the set of strings; multiple grammars can describe the same language.
20:11:10 <dolio> I don't see how homotopy type theory makes supercompilation easier.
20:11:11 <chrisdone> ‘unsafePerformYouWereOnlySupposedToBlowTheBloodyDoorsOff’ negates any qualifiers
20:11:21 <ChongLi> dolio: how well versed in it are you?
20:11:23 <intrados> kristof: Also things like typeclasses
20:11:29 <dolio> Which?
20:11:33 <ChongLi> HoTT
20:11:35 <kristof> intrados: Typeclasses are just OO interfaces.
20:11:35 <jmcarthur> ah nope that is enough of that. i will not reinvent persistent real time queues tonight
20:11:39 <kristof> And I don't like interfaces, either.
20:12:01 <tswett> S -> aS | epsilon is a context-free grammar; {epsilon, a, aa, aaa, aaaa, ...} is a context-free language.
20:12:18 <dolio> Passably.
20:12:39 <Axman6> chrisdone: www.youtube.com/watch?v=elJwuD7pfmc
20:13:13 <jmcarthur> tswett: so you mean basically the same as a CFG, but normalized in some way?
20:13:20 <Rarrikins> In what level language does it become impossible to equality check languages in general?
20:13:27 <Rarrikins> Or grammars, rather.
20:13:37 <tswett> jmcarthur: pretty much.
20:13:43 <tswett> Rarrikins: I'm pretty sure equivalence of CFGs is undecidable.
20:13:51 <Rarrikins> Ahh, OK.
20:13:59 <tswett> And I'm pretty sure equivalence of regular expression is decidable. So... that one.
20:15:09 <Rarrikins> tswett: You're right: https://en.wikipedia.org/wiki/Context-free_grammar#Language_equality
20:15:23 <Rarrikins> tswett: Thanks.
20:16:00 <tswett> I wonder, what is the closure of the set of all CFLs under union and complementation?
20:16:20 <chrisdone> kristof: i'd say type-classes are more like collections of defgeneric's, because implementation of the methods is decoupled from the definition of the data type
20:17:19 <tswett> Shucks, is the intersection of infinitely many regular languages necessarily regular? If so, then the complements of regular languages form a topology on the set of all strings.
20:17:20 <kristof> chrisdone: I think interfaces are like DEFGENERICs, when you haven't specified any DEFMETHODs.
20:17:32 <tswett> But my guess is the intersection of infinitely many regular languages is not necessarily regular.
20:17:55 <kristof> tswett: Why not?
20:18:11 <Rarrikins> tswett: What does complement closure mean?
20:18:12 <kristof> tswett: the intersection of infinitely many subspaces is itself a subspace
20:18:26 <kristof> I know that's not quite the same thing but the proof might be similar
20:18:41 <tswett> No, that's obvious. Every language S can also be written as the intersection of all the languages "all strings except x", for all strings not in x.
20:18:43 <chrisdone> kristof: right. main difference with generics is you just have one function, not a collection. which is what i like about generic functions
20:19:04 <tswett> Rarrikins: "closed under complementation" would mean that if S is in the set, then the complement of S is also in the set.
20:19:18 <tswett> All right, I'd better go to bed.
20:19:23 <tswett> Night, everyone.
20:19:26 <ChongLi> good night
20:19:50 <kristof> chrisdone: I suppose. Anyway, typeclasses are not special in my opinion :P They're just interfaces in the presence of a superior type system like Haskell's. But that's... really it.
20:20:12 <Rarrikins> I wish they were used more.
20:20:22 <stephenmac7> How do I parse a nested object in json?
20:20:25 <stephenmac7> With aeson
20:20:28 <ChongLi> Rarrikins: why?
20:20:46 <Rarrikins> For example, gcd should be a typeclass function with a default implementation.
20:20:50 <chrisdone> obviously type-classes are a lot more expressive than C#/Java interfaces (even with generics it's hard to express even e.g. t -> t -> t), but the general concepts are pretty similar
20:21:02 <ChongLi> Rarrikins: or maybe generalize that further
20:21:02 <jmcarthur> Rarrikins: so do i, but they are already misused so much... http://hackage.haskell.org/package/ListLike-4.0.2/docs/Data-ListLike.html#t:ListLike
20:21:05 <Rarrikins> That way, you can make symbolic algebra with Num and so on.
20:21:10 <ChongLi> to meets and joins
20:21:15 <Axman6> stephenmac7: what do you mean by nested?
20:21:34 <Rarrikins> jmcarthur: Why do you dislike ListLike?
20:21:38 <ChongLi> just have a preorder type class
20:21:59 <stephenmac7> Axman6: {"coords": [{"x": 5, "y": 6}]}
20:22:02 <Rarrikins> What's a preorder type class?
20:22:17 <ChongLi> a type class for preorders
20:22:24 <jmcarthur> Rarrikins: way too many functions and a total absense of laws makes it basically useless
20:22:33 <Rarrikins> jmcarthur: Ahh, I see.
20:22:39 <ChongLi> a preorder is just a degenerate partial order
20:22:53 <jmcarthur> Rarrikins: the documentation even warns about how silly some of the instances are!
20:23:08 <Rarrikins> I wish they'd gone with something like make map work for all functors rather than having things like Listlike. Listlike feels as bad as utility classes in Java.
20:23:12 <intrados> kristof: http://c2.com/cgi/wiki?TypefulProgramming
20:23:12 <stephenmac7> Axman6: Is there any way to handle that?
20:23:30 <ChongLi> Rarrikins: yeah it's a frequent complaint about the map vs fmap thing
20:23:33 <chrisdone> ew, ListLike
20:23:34 <jmcarthur> Rarrikins: Foldable and Traversable cover the most commonly wanted functions from ListLike anyway
20:23:36 <Axman6> stephenmac7: of course, that's what it's designed for. just trying to find you a good example
20:23:47 <stephenmac7> Okay, thanks
20:23:52 <ChongLi> the common refrain is that type classes lead to more complicated type errors
20:23:53 <chrisdone> ListLike and StringLike classes are icky
20:23:56 <Axman6> stephenmac7: read the docs in http://hackage.haskell.org/package/aeson-0.7.0.0/docs/Data-Aeson.html
20:23:57 <ChongLi> and that's bad for beginners
20:23:59 <Rarrikins> jmcarthur: I'll have to check those out.
20:24:01 <jmcarthur> Rarrikins: and Foldable and Traversable have lovely laws :)
20:24:17 <Rarrikins> ChongLi: Yeah, but you're a beginner for the least amount of time.
20:24:20 <ChongLi> hmm, what about SML-modules
20:24:23 <chrisdone> those kind of classes are trying to solve namespacing problems
20:24:35 <ChongLi> Rarrikins: beginners are the most important class of people for growing the language
20:24:47 <jmcarthur> actually... do they? or do they just rely on Functor and parametricity? (deja vu question)
20:24:47 <stephenmac7> Axman6: Don't see anything on nested json though
20:25:18 <ChongLi> would SML modules make sense instead of type classes for a Haskell-like language?
20:25:23 <Rarrikins> ChongLi: I wonder if the error messages could be improved.
20:25:24 <dolio> Traversable has rules.
20:25:48 <ChongLi> Rarrikins: the quality of error messages is bound by the amount of information available to the compiler
20:25:51 <chrisdone> dolio: There are RULES, damn it! This isn't ‘nam, Smokey.
20:26:01 <ChongLi> the more polymorphic the function, the less information available
20:26:37 <Rarrikins> ChongLi: I bet there are still stylistic improvements possible.
20:26:46 <jmcarthur> i think i prefer to design interfaces/languages for experts. beginners are only beginners temporarily. experts benefit or suffer from design decisions for the rest of their lives.
20:26:53 <ChongLi> of course, nothing is as crazy as some of the errors you can get with scala or C++ templates
20:27:13 <dolio> SML modules require you to design things in significantly different ways than type classes.
20:27:15 <lispy> jmcarthur: as long as you still have a way for folks to bootstrap into expert :)
20:27:37 <jmcarthur> lispy: sure, but i am unwilling to make experts suffer, if it comes down to that tradeoff
20:28:14 <ChongLi> people have written powerful tools just to decipher C++ template error messages
20:28:22 <lispy> jmcarthur: TBH, I mostly agree with your point.
20:28:37 <chrisdone> certainly it's a balance
20:28:40 <chrisdone> public class HelloWorld {public static void main(String[] args) {System.out.println("Hello, World");}}
20:28:47 <chrisdone> ^ this is all meaningful to experts
20:28:54 <chrisdone> but it makes newbies want to hang themselves
20:28:56 <jmcarthur> chrisdone: no, that is painful to everybody ;)
20:29:03 <stephenmac7> Axman6: No, still can't find anything on it
20:29:06 <Axman6> stephenmac7: hmmm, finding examples is harder than I'd thought it would be. https://www.fpcomplete.com/school/starting-with-haskell/libraries-and-frameworks/text-manipulation/json might be useful, but doesn't seem to explain anything more detailed. I have a feeling you can chain .: though, so v .: "foo" .: "bar"
20:29:16 <ChongLi> newbies often just repeat what they're told
20:29:17 <chrisdone> painful, but at some point experts decided it made sense
20:29:28 <ChongLi> whereas experts get annoyed at all the redundant noise
20:29:29 <chrisdone> at the cost of newbie comprehension
20:29:41 <stephenmac7> Axman6: I've got everything but the nest set up
20:29:46 <ChongLi> I know I do
20:30:00 <chrisdone> i like optionality
20:30:00 <stephenmac7> Closest thing I've gotten is decode (v .: "coords")
20:30:07 <chrisdone> main = print "sup" -- great for newbies and experts
20:30:09 <ChongLi> Haskell is one of the best languages for reducing noise
20:30:10 <jmcarthur> i'm advocating designing for the benefit of experts, not making excuses for poor design decisions just because experts are able to deal with it.
20:30:14 <stephenmac7> But it doesn't match types (so decode might not be a good idea)
20:30:29 <Rarrikins> ChongLi: For example: You used "map (+2) 1". map's second argument is supposed to be of type Functor f => f a, but you used an argument of type Num a => a. None of the Num a => a types is also a Functor f => f a, so you can't use "1" as the second argument to "map".
20:30:33 <chrisdone> -- | Go go jonny go go go go.
20:30:34 <chrisdone> main :: IO ()
20:30:34 <chrisdone> main = print "sup" -- good for serious bidniss code
20:30:49 <Axman6> stephenmac7: yeah I'm not particularly familliar with the library. someone else might have better suggestions
20:30:57 <ChongLi> Rarrikins: newbies just see "Functor" and their eyes glaze over
20:31:04 <stephenmac7> Who knew this would be so complicated?
20:31:26 <Rarrikins> stephenmac7: What are you doing? Something like JSON lists?
20:31:32 <pxqr> i'm searching for something like Control.Concurrent.Async.Lifted.mapConcurrently but with limited number of threads;
20:31:34 <stephenmac7> Rarrikins: Yes
20:31:38 <pxqr> any ideas?
20:31:45 <stephenmac7> A list of json objects
20:31:48 <stephenmac7> [{}]
20:31:52 <pxqr> the limit should be configurable
20:31:53 <Rarrikins> stephenmac7: You can decode it to an [a] or something.
20:31:53 <ChongLi> Rarrikins: but also, your example error message is assuming that which may not be true
20:32:09 <Rarrikins> ChongLi: What is it assuming?
20:32:14 <stephenmac7> Rarrikins: I have the outer type and the inner type set up
20:32:18 <stephenmac7> Just parsing it is the issue
20:32:21 <chrisdone> i rest on the map :: Functor f => (a -> b) -> f a -> f b side
20:32:25 <BMeph> jmcarthur: While you're designing for the experts, why on't you have a go at solving "the Haskell records problem," eh? ;)
20:32:26 <ChongLi> that none of the types that belong to Num are Functors
20:32:31 <stephenmac7> Or, implementing fromjson
20:32:40 <ChongLi> Rarrikins: the compiler can't know that
20:32:47 <ChongLi> because Num is "open"
20:32:49 <chrisdone> while my eyes did glaze over at Functor as a newbie, they also glazed over return :: Monad m => a -> m a
20:32:50 <Rarrikins> stephenmac7: Let me take a look at what I did for that.
20:33:04 <stephenmac7> Just the line that connects the outer to the inner
20:33:07 <Rarrikins> ChongLi: Yeah, that's more a whole-program optimizer type thing.
20:33:26 <ChongLi> Rarrikins: to truly answer that question, it'd have to query hoogle or something
20:35:25 <jmcarthur> BMeph: i don't actually feel like that problem exists in the first place, personally.
20:36:32 <chrisdone> jmcarthur: you feel like the lispers do?
20:36:50 <jmcarthur> chrisdone: not sure i understand that question
20:36:50 <chrisdone> "(person-name person) is just fine i don't need no stinkin (name person)"
20:36:56 <jmcarthur> ah
20:37:05 <jmcarthur> we have type classes for overloading
20:37:21 <jmcarthur> if it's really necessary to overload at all
20:37:26 <jfischoff> oh accurate is Criterion?
20:37:30 <chrisdone> i don't think it's an overloading problem
20:37:37 <jfischoff> oh would one measure the accuracy?
20:37:54 <chrisdone> type-classes are for modeling a common pattern with (hopefully) some laws, right?
20:38:00 <jmcarthur> jfischoff: i don't trust criterion with very high confidence
20:38:21 <chrisdone> whereas a "name" is just anything, it could be whatever. you don't care what it does, you just want the identifier "name". it's a namespace problem
20:38:21 <jfischoff> yeah
20:38:22 <jmcarthur> chrisdone: type classes can also be used pretty effectively for lawless syntax
20:38:27 <stephenmac7> Rarrikins: Any luck?
20:38:36 <jmcarthur> chrisdone: and it's not always even a terrible idea, for a small core of operations
20:38:42 <Rarrikins> stephenmac7: Sorry, computer died and I just plugged in.
20:38:48 <jfischoff> jmcarthur: do you have alternative suggestion?
20:39:09 <jmcarthur> jfischoff: no. i like criterion. i'm just saying you shouldn't stake your life on it or anything.
20:39:12 <Gx10> c/lose
20:39:21 <Gx10> ops
20:39:35 <jfischoff> jmcarthur: pretty much how I feel
20:39:44 <frege> rev [] = []
20:39:45 <frege> rev xs = last xs : rev (init xs)
20:39:53 <frege> how does that work?
20:39:59 <jmcarthur> jfischoff: i don't trust myself to construct good benchmarks, regardless of the library i'm using to do it
20:40:00 <frege> is it recursive?
20:40:18 <jmcarthur> frege: it works inefficiently
20:40:33 <jmcarthur> frege: yes, it's recursive
20:40:41 <stephenmac7> Rarrikins: I understand.
20:40:41 <frege> how does that work? can you break it down?
20:40:55 <lispy> :t last
20:40:57 <lambdabot> [a] -> a
20:41:01 <lispy> > last [1,2,3]
20:41:02 <lambdabot>  3
20:41:08 <lispy> :t init
20:41:08 <lambdabot> [a] -> [a]
20:41:09 <lispy> > init [1,2,3]
20:41:11 <lambdabot>  [1,2]
20:41:17 <chrisdone> frege: try running it step by step
20:41:25 <jmcarthur> frege: it's pretty broken down already. if the list is empty, then you're done. if not, take the last element and put it at the front, and take everything else, reverse it, and put it at the end
20:41:42 <lispy> rev [1,2,3] = last [1,2,3] : rev (init [1,2,3])
20:42:04 <lispy> last [1,2,3] : rev (init [1,2,3]) = 3 : rev ([1,2])
20:42:11 <ChongLi> yeah that's really inefficent
20:42:11 <ChongLi> haha
20:42:12 <frege> what's an efficient way of doing it?
20:42:21 <jmcarthur> ChongLi: pretty lazy at least :)
20:42:40 <jmcarthur> @src reverse
20:42:40 <lambdabot> reverse = foldl (flip (:)) []
20:42:49 <jmcarthur> @src foldl
20:42:49 <lambdabot> foldl f z []     = z
20:42:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:42:57 <ChongLi> that's the report prelude version
20:43:11 <chrisdone> rev [1,2]
20:43:11 <chrisdone> = last [1,2] : rev (init [1,2])
20:43:11 <chrisdone> = 2 : rev [1]
20:43:13 <chrisdone> = 2 : last [1] : rev (init [1])
20:43:16 <chrisdone> = 2 : last [1] : rev []
20:43:17 <jmcarthur> less lazy, but much better running time overall
20:43:18 <chrisdone> = 2 : 1 : []
20:43:32 <frege> ok I'm still in the easy stuff
20:43:34 <ChongLi> the proper one is done with manual recursion
20:43:41 <ChongLi> reverse l =  rev l []
20:43:42 <ChongLi>   where
20:43:42 <ChongLi>     rev []     a = a
20:43:43 <ChongLi>     rev (x:xs) a = rev xs (x:a)
20:44:06 <jmcarthur> ChongLi: it's actually implemented that way instead of with foldl' or something? shame.
20:44:14 <jmcarthur> s/shame/lame/
20:44:34 <ChongLi> yeah
20:44:55 <lispy> looks like they wanted to force a worker-wrapper?
20:45:00 <chrisdone> i'd've let frege implement reverse themselves, but showing them the answer also works
20:45:10 <lispy> I wonder if that version is still faster with modern ghcs
20:45:16 <ChongLi> though a lazy reverse just means you're going to force the whole thing as soon as someone tries to take the head anyway, right?
20:45:29 <lispy> ChongLi: yeah
20:45:40 <jmcarthur> ChongLi: only if the head is even needed. what if they end up skipping most of them?
20:45:41 <lispy> reverse can't really be all that lazy
20:45:50 <stephenmac7> Rarrikins: Nevermind, it was as simple as it could get
20:45:58 <stephenmac7> Don't do anything to it :P
20:46:01 <chrisdone> yeah, you have to walk the whole list just to get the head, so ja
20:46:03 <Rarrikins> stephenmac7: Oh, cool.
20:46:04 <jmcarthur> i implemented a lazier foldl once that should be a bit more efficient than all this
20:46:09 <jmcarthur> wonder if i can dig that up
20:46:12 <stephenmac7> (v .: "coords")
20:46:29 <frege> I'm not used to one line recursion that's why I couldn't break it down in my head
20:46:32 <jmcarthur> yeah, here it is: http://lpaste.net/91109
20:46:35 <frege> but now I see
20:46:40 <danharaj> edwardk: Trying to come up with laws for `t :: forall a. w a -> w a`  where w is a comonad and t is 'compatible' with the comonad structure. Any ideas?
20:46:41 <jmcarthur> err
20:46:51 <jmcarthur> oh i used reverse. interesting. i forgot about this
20:46:55 <chrisdone> frege: here's a challenge, write a function to split a list in twine
20:47:00 <Rarrikins> frege: You need to fix that.
20:47:06 <ChongLi> jmcarthur: hahaha
20:47:06 <Rarrikins> @src fix
20:47:06 <lambdabot> fix f = let x = f x in x
20:47:22 <ChongLi> yeah, the manually recursive reverse seems lazy enough
20:47:28 <frege> chrisdone: ok
20:47:28 <jmcarthur> ah, right, i used reverse, but i only evaluate it if needed
20:47:59 <frege> chrisdone: how can I get the length of a list?
20:48:09 <jmcarthur> the "spine" of calls to the function can be constructed separately from the evaluation of the fs second arguments
20:48:12 <lispy> @hoogle [a] -> Int -- frege
20:48:13 <lambdabot> Parse error:
20:48:13 <lambdabot>   [a] -> Int -- frege
20:48:13 <lambdabot>                ^
20:48:18 <lispy> @hoogle [a] -> Int
20:48:18 <lambdabot> Prelude length :: [a] -> Int
20:48:18 <lambdabot> Data.List length :: [a] -> Int
20:48:18 <lambdabot> Prelude head :: [a] -> a
20:48:34 <frege> what?
20:48:43 <chrisdone> > length [1,2,3]
20:48:45 <lambdabot>  3
20:48:48 <lispy> frege: it's a search that uses haskell types :)
20:49:09 <ChongLi> is there any efficiency to be gained by using head and catching the exception vs using a safe head?
20:49:16 <Rarrikins> frege: Use if null or case.
20:49:18 <ChongLi> it seems like the answer would be no
20:49:42 <lispy> ChongLi: Maybe can change the laziness of a program
20:49:46 <jmcarthur> ChongLi: perhaps if you don't expect it to be empty often/ever?
20:49:46 <chrisdone> probably catching the exception is a bigger performance hit
20:49:56 <ChongLi> also, Bob Harper seems to prefer SML's exceptions vs Haskell's Maybes and Eithers
20:50:09 <chrisdone> he would
20:50:18 <ChongLi> I don't know enough about SML exceptions either way
20:50:21 <chrisdone> let's just take that as read
20:50:36 <chrisdone> “Bob Harper seems to prefer SML's <insert thing here> vs Haskell's <insert thing here>”
20:50:43 <ChongLi> hahaha
20:50:59 <frege> chrisdone: the right way is consuming the iterator right?
20:51:06 <frege> if you want to make it memory efficient for spliting
20:51:16 <frege> but I don't know how to do it in haskell
20:51:31 <ChongLi> chrisdone: it's understandable that he would think that way if he'd become highly accustomed to it
20:51:36 <chrisdone> frege: consuming the iterator?
20:51:43 <ChongLi> that's pretty much the case with so many things
20:51:58 <frege> chrisdone: in python language that's how we call it
20:52:05 <chrisdone> what does it mean?
20:52:07 <bitemyapp> ChongLi: I wouldn't assume it had anything to do with being accustomed to things.
20:52:16 <ChongLi> bitemyapp: why not?
20:52:32 <ChongLi> people naturally have a status quo bias
20:52:43 <bitemyapp> ChongLi: hum. "accustomed" implies the act of writing code to my mind.
20:52:55 <chrisdone> BURN
20:53:05 <ChongLi> you don't think Bob Harper writes any code?
20:53:10 <chrisdone> you think he does?
20:53:12 <bitemyapp> I don't think that's what I said.
20:53:19 <ChongLi> he's a researcher
20:53:37 <chrisdone> that's evidence against writing any code
20:53:46 <bitemyapp> ChongLi: what I do know is this, he says things about Haskell that anybody that has written Haskell would never say.
20:53:48 <lispy> I had a pretty low opinion of Bob Harper from his blog. Looking at his other work, I know have a high opinion of him. Ignore his anti-haskell stuff and you'll be fine.
20:53:51 <chrisdone> researchers write either no code, or crappy half-assed code
20:54:01 <bitemyapp> ChongLi: his work also has a lot to do with things like HoTT, not with practicalities.
20:54:26 <bitemyapp> ChongLi: given that I've seen him say many things discordant with an accurate understanding of what writing Haskell is actually like, I am given two possible options.
20:54:29 <jmcarthur> lispy: don't even ignore it. there is technical fact there, despite the tone.
20:54:46 <ChongLi> bitemyapp: well, I didn't say he was accustomed to writing Haskell
20:55:02 <ChongLi> I figure he's accustomed to SML and tried Haskell a few times and didn't like it
20:55:10 <bitemyapp> ChongLi: 1. That he knows Haskell and has written enough to know better, but is lying/propagandizing on purpose    2. That he is a theoretician allowing his abstract bikeshed quibbles to fuel him into making assertions he doesn't have the grounds to assert.
20:55:24 <bitemyapp> ChongLi: he speaks as if he's done a lot more than "tried a Haskell a few times"
20:55:45 <bitemyapp> if you're working from an epistemically weak position, you should be caveating what you say. He doesn't.
20:55:51 <ChongLi> we also don't know exactly *when* he tried it
20:55:53 <chrisdone> i get the sense that harper is disingenuous a lot of the time, it's hard to ignore that
20:56:01 <bitemyapp> chrisdone: that's my main complaint.
20:56:13 <ChongLi> for all we know, he tried it back in the early 90s
20:56:13 <bitemyapp> chrisdone: I cannot trust or respect people that are disingenuous.
20:56:19 <chrisdone> despite the technically interesting points. reading his blog is like eating a nice dessert with a fly in it
20:56:38 <ChongLi> wasn't Haskell basically a joke for a long time?
20:56:41 <chrisdone> i go away feeling full but like i could've done without the fly
20:56:45 <bitemyapp> ChongLi: er, no.
20:56:57 <bitemyapp> ChongLi: there were practical projects that were wildly successful in Haskell dating back to the early/mid 90s.
20:57:11 <chrisdone> no, he looks into haskell enough to make technical points
20:57:12 <ChongLi> main :: String -> String and ghc deleting your source code on a type error :)
20:57:14 <bitemyapp> ChongLi: it wasn't as nice or practical as a language in some domains at that time, but the competition wasn't very strong either.
20:57:35 <chrisdone> and then makes innocent sounding leading questions like "is this true about haskell?" so that he can say "HA! I *told* you haskell was bull!"
20:58:09 <ChongLi> chrisdone: do you have a reference for that?
20:58:10 <Axman6> who
20:58:15 <ChongLi> Bob Harper
20:58:16 <Axman6> who's "he"?*
20:58:18 <Axman6> oh
20:58:33 <chrisdone> hmm. i'll pick a blog post
20:58:46 <Axman6> better than harrop...
20:59:02 <bitemyapp> ChongLi: worth mentioning that I am learning Harper's work in type theory and find it interesting, but I'm a practical work-a-day programmer and don't give a damn what he thinks about PLT or Haskell.
20:59:06 <bitemyapp> they're different domains.
20:59:10 <chrisdone> mm, i dunno. harrop's not got technical chops enough to be worth listening to
20:59:18 <chrisdone> harper is actually worth reading, it just leaves a bad taste in your mouth
20:59:24 <bitemyapp> ^^ yep.
20:59:35 <ChongLi> chrisdone: what leaves a bad taste? his blog?
20:59:41 <ChongLi> you should try reading his books
20:59:43 <bitemyapp> ChongLi: primarily. His twitter feed is worse.
20:59:52 <ChongLi> they're way more professional
20:59:54 <bitemyapp> the pithy he has to be, the more useless and offensive he gets.
21:00:23 <ChongLi> and, as I've said before, he's much nicer as a lecturer
21:00:30 <Hodapp> "Well, it's not MY fault the truth feels insulting."
21:00:40 <ChongLi> he's self-deprecating and very much like a bumbling professor type
21:00:43 <chrisdone> hodapp: lol
21:00:55 <bitemyapp> ChongLi: that doesn't really change much though.
21:01:04 <ChongLi> bitemyapp: why doesn't it?
21:01:05 <chrisdone> well, yeah, everyone's more pithy and bitter online
21:01:16 <bitemyapp> ChongLi: disagreeing with somebody is different than somebody engaging in a disingenous scorched-earth campaign over a narcissism of small differences type deal.
21:01:34 <ChongLi> bitemyapp: that's a huge exaggeration
21:01:39 <bitemyapp> I don't think so.
21:01:47 <bitemyapp> I've interacted with him on Twitter, it's not at all.
21:01:48 <chrisdone> i bet axman6 is a nice person in real life
21:01:53 <chrisdone> here he's horrible =p
21:02:03 * chrisdone runs
21:02:16 <ChongLi> twitter is a level of discourse similar to yelling at people from your car as you drive past
21:02:23 <Axman6> D:
21:02:48 <bitemyapp> ChongLi: er, okay? Except I know plenty of people that are capable of an entertaining and constructive conversation on Twitter.
21:03:08 <bitemyapp> ChongLi: and Harper's Twitter is basically just the dessert/fly situation without the dessert.
21:03:28 <ChongLi> bitemyapp: wouldn't know, I haven't read it
21:03:29 <bitemyapp> He's hostile and constantly attacking Haskell of all things in a world where we still haven't gotten most programmers to understand that there
21:03:40 <bitemyapp> isn't a particularly good reason to be using unityped-by-default languages.
21:04:11 <ChongLi> I think he'd agree that people would be better off using Haskell than a unityped language
21:04:12 <bitemyapp> the universal language for scripting the most common mode of software interaction in the world is JavaScript and an ML nut is whining about Haskell. Nuts.
21:04:40 <bitemyapp> ChongLi: you're welcome to attempt that on Twitter.
21:04:49 <stephenmac7> Is there a way to unzip an incoming file from http-conduit
21:04:52 <ChongLi> I don't have a twitter account
21:04:55 <ChongLi> and likely never will
21:05:05 <danharaj> You are being extremely uninformed if you're going to call Bob an ML nut who whines about Haskell.
21:05:28 <bitemyapp> even more bizarre, he'll slur the use of things like monads when one of the better async libraries for OCaml is structured around monads.
21:05:29 <Hodapp> Yeah, he whines about a whole lot else.
21:05:47 <ChongLi> it's hard not to whine in 140 characters, IMO
21:05:49 <BMeph> That sounds like some funny parody of some war movie's dialogue translated into PL issues. Sadly, though, it is silly, but it's all-too real.
21:06:06 <ChongLi> generally, the longer the format, the higher the degree of professionalism
21:06:10 <chrisdone> danharaj: that's what his blog and twitter consist of
21:06:31 <chrisdone> "of course ML as monads!"
21:06:34 <chrisdone> “There is a particular reason why monads had to arise in Haskell, though, which is to defeat the scourge of laziness.”
21:06:40 <chrisdone> had to throw that in there, of course
21:06:54 <Hodapp> chrisdone: On the other hand, longer formats can grant a person a canvas to paint a more potent display of unprofessionalism than a shorter one could even allow.
21:06:57 <ChongLi> okay
21:06:58 <bitemyapp> danharaj: I just checked Harper's twitter, and every single day of the last 4 or 5 days of twitter activity I checked included a slur against Haskell.
21:07:01 <chrisdone> and the subsequent sentences taking haskell apart, which he does throughout. all the time
21:07:06 <ChongLi> well, laziness is a huge problem without monads
21:07:08 <ChongLi> is it not?
21:07:08 <bitemyapp> danharaj: so, empirically, I'm not uninformed.
21:07:27 <bitemyapp> danharaj: more likely, you're scope-blind or don't follow him on Twitter.
21:07:33 <chrisdone> chongli: laziness, IO and monads are orthogonal concepts…
21:07:34 <danharaj> chrisdone: His blogtrolling has resulted in positive improvements to Haskell, and his blog/twitter isn't very significant compared to his total contributions to Haskell as an accomplished PL theorist.
21:07:53 <ChongLi> chrisdone: yeah, I understand that
21:07:59 <jmcarthur> ChongLi: umm... laziness is *not* a huge problem, monads or not, and laziness has nothing to do with monads.
21:08:10 <augur_> bitemyapp: harper is intentionally controversial i think
21:08:12 <bitemyapp> danharaj: the problem is I'll discuss Haskell with people using uni-typed FP languages and they'll use Harper's screeds as an excuse to not learn anything new.
21:08:22 <ChongLi> so what's the solution to controlling effects without monads?
21:08:32 <ChongLi> (in a lazy setting)
21:08:41 <augur_> bitemyapp: if for no other reason than to make people talk
21:08:52 <jmcarthur> ChongLi: haskell would still be pure and safe and reasonable without Monad
21:08:56 <bitemyapp> ChongLi: https://www.google.com/search?q=functional+pearls+effects&oq=functional+pearls+effects&aqs=chrome..69i57.3553j0j1&client=ubuntu-browser&sourceid=chrome&ie=UTF-8
21:08:58 <chrisdone> danharaj: i'm sure he also donates to charities. yes, we're judging based on what we see
21:08:59 <jmcarthur> ChongLi: there is no "solution" necessary
21:09:13 <danharaj> bitemyapp: that's a legitimate complaint, but then you can turn it around on them and start pushing ML which is a fine family of languages.
21:09:32 <danharaj> chrisdone: if you're judging him on what you see, then look at his CV.
21:09:32 <ChongLi> bitemyapp: I don't see how you can blame Bob Harper for ignorant people's arguments
21:09:32 <augur_> bitemyapp: thats not an answer...
21:09:35 <bitemyapp> augur_: usually after firing off an initial salvo, it will be followed up by Minsky going, "hyuk, hyuk, yup yup yup!"
21:09:35 <danharaj> or his lectures.
21:09:37 <danharaj> or his books.
21:09:54 <chrisdone> danharaj: and ignore all the other stuff?
21:09:55 <augur_> bitemyapp: applicative programming with effects _is_ monads. or, well, applicatives.
21:09:56 <bitemyapp> I wish I could wave around my CV whenever I was being an intolerable asshole.
21:10:07 <bitemyapp> does that actually work? is that a thing?
21:10:11 <chrisdone> danharaj: does technical accomplishment excuse anything else you do?
21:10:13 <ChongLi> bitemyapp: that's a huge exaggeration
21:10:14 <jmcarthur> bitemyapp: Minsky is also very smart and reasonable. That is misrepresenting him a lot.
21:10:14 <danharaj> chrisdone: roll your eyes at the other stuff.
21:10:29 <ChongLi> bitemyapp: you're injecting your own bias into what you're reading
21:10:37 <chrisdone> Linus wrote Linux and contributed a lot. he's still douchey to people
21:10:37 <bitemyapp> jmcarthur: he's also more practical but that doesn't stop the ridiculousness.
21:10:53 <ChongLi> a blog, in a lot of ways, is like a comedy club
21:11:01 <ChongLi> people show up just to try and heckle you
21:11:04 <danharaj> chrisdone: I have never seen Bob personally attack someone, which is something Linus does that is completely unacceptable.
21:11:22 <danharaj> So does he actually personally attack people on Twitter?
21:11:33 <ChongLi> Bob is opinionated about languages but he doesn't attack people
21:11:44 <ChongLi> and he's all-too-happy to explain things to people that ask
21:11:51 <jmcarthur> bitemyapp: You may have seen my recent arguments with Minksy about purity on Twitter. I also work with him. I very much respect his opinion, totally see where he is coming from, and despite that I disagree with him a lot, I like working with him and see him as a reasonable person.
21:12:17 <bitemyapp> quoting from Harper's Twitter, "haskell IS algol"
21:12:20 <chrisdone> danharaj: i didn't say bob personally attacks people, it was an analogy. writing a douchey blog is not something we're going to exclude from our judgments because he wrote a bunch of good books
21:12:32 <bitemyapp> there is no way in which calling Haskell "algol" is constructive or stimulating meaningful conversation.
21:12:36 <jmcarthur> bitemyapp: (we continued the debate IRL and, sadly, still didn't come to much of an agreement, but it was all terminology anyway)
21:12:51 <bitemyapp> here's another one, "GOP = party of stupid" from Harper's twitter.
21:12:51 <ChongLi> bitemyapp: and that's not a reply to anyone?
21:13:15 <bitemyapp> ChongLi: part of a conversation, that mentioned soemthing about Algol, he injected the Haskell == algol bit.
21:13:35 <ChongLi> bitemyapp: ahh
21:13:44 <danharaj> chrisdone: I simply don't believe it is comparable that Bob says things you disagree with in a confrontational way and Linus personally attacks people for making mistakes. Bob's opinions aren't necessarily wrong or offensive, they are communicated in a provocative way. Linus has acted reprehensibly towards others.
21:13:47 <ChongLi> well, he's said numerous times that Haskell is the world's greatest imperative language
21:13:53 <bitemyapp> "@jcreed he's totally clueless.", "@jcreed he so desperately wants to make a point it's kind of pathetic."
21:13:55 <ChongLi> so it's probably a reference to that
21:13:59 <danharaj> The operational difference is that Bob doesn't make people feel unwelcome or stupid.
21:14:09 <chrisdone> danharaj: forget about linus
21:14:10 <bitemyapp> "don't overestimate the source." said of Bracha.
21:14:10 <danharaj> And if he's not doing that, then what is the harm in his banter?
21:14:41 <augur_> bitemyapp: link to the haskell = algol thing?
21:14:47 <chrisdone> danharaj: what is the harm in constantly berating a language and its community? i can't be bothered explaining, but it doesn't matter much
21:14:49 <augur_> im curious what the context is
21:14:56 <bitemyapp> "@aaron_turon @ezyang ("algebraic" is pretentious terminology introduced by haskell)" - contributing to the common slur against Haskell that it's somehow being pointlessly pretentious to build up abstractions like that in the typeclassopedia.
21:14:58 <ChongLi> chrisdone: woah, woah
21:15:05 <ChongLi> chrisdone: where has he berated the community?
21:15:07 <bitemyapp> Harper is helping to give people an excuse to ignore Haskell.
21:15:08 <danharaj> Calling me wrong is not berating me.
21:15:40 <augur_> thats an exageration, bitemyapp
21:15:42 <jmcarthur> i'm tempted to say this conversation should move to -blah
21:15:51 <augur_> anyone who follows or even knows about bob harper is probably a fan of haskell anyway
21:16:07 <ChongLi> either that or they were one of his students
21:16:24 <chrisdone> okay, umm. maybe not berate
21:16:27 <bitemyapp> augur_: except for all the lisp, ocaml, and scala people, sure.
21:16:36 <bitemyapp> augur_: who will then convince themselves they're not missing out on anything.
21:16:50 <augur_> do those people even really get harper at all?
21:17:01 <chrisdone> talk down to? patronize? mock? meh
21:17:03 <BMeph> chrisdone: Belittle, but not berate, perhaps? ;p
21:17:06 <ChongLi> chrisdone: all I've seen from him are well-reasoned arguments about flaws in Haskell's design and good-natured jabs referencing popular memes about Haskell
21:17:18 <jmcarthur> i will share this observation... a lot of his students like SML and don't like Haskell. to some extent that is to be expected, though.
21:17:27 <danharaj> chrisdone: I've seen people who *clearly* misinformed try to refute his blog posts and he often patiently engages them.
21:17:36 <danharaj> s/are clearly/clearly
21:17:45 <chrisdone> danharaj: uh huh?
21:18:03 <danharaj> i.e. he argues in good faith.
21:18:17 <chrisdone> i disagree
21:18:28 <danharaj> shrug, fair enough.
21:18:49 <ChongLi> https://existentialtype.wordpress.com/2012/08/14/haskell-is-exceptionally-unsafe/#comment-992
21:18:58 <chrisdone> shrug indeed. the fact he's got #haskell riled up at present is evidence enough
21:19:12 <chrisdone> i don't need to argue at length against all your apologetics
21:19:12 <ChongLi> chrisdone: that's my fault as much as anything
21:19:24 <bitemyapp> abaranosky: howdy!
21:19:38 <ChongLi> I just don't think he's the terrible person everyone's making him out to be
21:19:52 <ChongLi> watch 5 minutes of one his lectures and see
21:20:19 <ChongLi> many of these same things are said about technology writer John C Dvorak as well
21:20:20 <augur_> ChongLi: getting #haskell riled up isnt hard
21:20:27 <bitemyapp> I don't think he needs to be a terrible person to be doing terrible things.
21:20:29 <chrisdone> i don't think anyone thinks he's a terrible person
21:20:29 <ChongLi> and the same thing is true if you see him in video
21:20:45 <augur_> er, not ChongLi, ChongLi^
21:20:58 <ChongLi> some people are just blunt in writing
21:21:12 <ChongLi> and bluntness is often mistaken for mean-spiritedness
21:21:23 <bitemyapp> ChongLi: propagandized lies aren't problematic because they can be blunt.
21:21:28 <chrisdone> Cool! Why not reboot Haskell exceptions to work this way, and avoid the messiness of Typeable?
21:21:28 <chrisdone> (This is also a good example of a situation where unsafePerformIO is necessary to get something useful done.)
21:21:32 <chrisdone> ^ perfect example
21:21:41 <chrisdone> "Hey, sincere comment!"
21:21:42 <chrisdone> "By the way, Haskell still sucks."
21:21:45 <jmcarthur> okay, i'm going to make this a formal complaint. this conversation is becoming not about haskell at all
21:22:04 <jmcarthur> i request that this move to -blah
21:22:24 <augur_> chrisdone: are you saying its NOT a case where unsafePerformIO is necessary?
21:22:25 <chrisdone> the conversation killer has been fired
21:22:29 <ReinH> I second this motion.
21:22:32 <danharaj> I think exceptions suck in Haskell.
21:22:38 <ReinH> Motion carried.
21:22:49 <jmcarthur> danharaj: i think exceptions suck
21:22:49 <ReinH> That's how it works right?
21:22:59 <ChongLi> chrisdone: and you?
21:23:13 <chrisdone> chongli: huh?
21:23:24 <ChongLi> what do you think of exceptions in haskell?
21:23:45 <chrisdone> nothing interesting
21:24:17 <ChongLi> okay then
21:25:35 <ChongLi> does anyone know why exceptions are implemented this way?
21:25:45 <jmcarthur> i think the vast majority of the time exceptions should not be inspected and therefore i care very little about what i can do with one once i have it in hand. i do care a lot about whether i can catch one at all and where i can throw one, and i don't really have a problem with the way i can do that in haskell.
21:25:45 <chrisdone> augur_: no, the code directly above what i pasted contains "unsafePerformIO"
21:26:01 <augur_> chrisdone: >> -blah!
21:26:13 <chrisdone> meh, -blah is where conversation goes to die
21:26:15 <ChongLi> could Haskell have done with not having exceptions at all?
21:26:40 <ChongLi> I guess that'd require totality; hmmm
21:26:54 <bitemyapp> just so we're clear, all I've seen of exceptions has been the relatively simple monads built on top of ADTs.
21:27:00 <augur_> chrisdone: ok fine
21:27:04 <bitemyapp> WHen we say exception in this conversation, do we mean Control.Monad.Exception or error?
21:27:09 <augur_> chrisdone: what is wrong about harper's second comment
21:27:14 <Axman6> ChongLi: i think the a;ternative is 'terminate'
21:27:30 * chrisdone going to read Snow Crash in bed
21:27:34 <augur_> i mean, whats factually wrong about it, and what's spiritually wrong about it
21:27:37 <ChongLi> bitemyapp: Control.Exception
21:31:04 <bitemyapp> augur_: you could procedurally generate Harper's trolling.
21:31:18 <bitemyapp> augur_: find a Haskell library that uses Typeable. Boom.
21:31:19 <augur_> lol
21:31:40 <augur_> ive never really come across typeable in anything i do
21:31:44 <augur_> so i cant really say
21:31:52 <ChongLi> I guess I have more sympathy because I've done some trolling in my past
21:32:13 <ChongLi> but I also feel no cognitive dissonance using Haskell while agreeing with what Harper says
21:32:36 <ChongLi> except in the one area where he agrees that it's a tradeoff: strictness vs totality
21:32:41 <augur_> i see harper's point about type classes on the one hand, but i also see the benefits of type classes on the other
21:33:00 <ChongLi> what are the benefits for type classes over ML's modules?
21:33:05 <augur_> type classes as they currently are make things wonderfully elegant
21:33:09 <augur_> ChongLi: two things, afaict
21:33:14 <augur_> silence and generativity
21:33:36 <ChongLi> you'll have to elaborate a bit more than that
21:33:40 <augur_> afaik in ML you have to explicitly pass the modules, and explicitly pull out their contained objects
21:33:47 <augur_> eg instead of writing just x == y
21:33:50 <augur_> you'd have to do something like
21:33:55 <augur_> Foo.eq x y
21:34:01 <augur_> if x, y :: Foo
21:34:05 <augur_> or whatever
21:34:22 <augur_> or rather if Foo is the equality instance
21:34:30 <augur_> you have to be super explicit about which equality you want, etc etc
21:34:36 <ChongLi> you can't just bring eq into the current namespace?
21:34:55 <augur_> you probably can
21:35:00 <augur_> but thats still noise
21:35:12 <augur_> uniqueness in haskell ensures that this is unnecessary
21:35:32 <augur_> also, generativity means that you can derive new instances from old instances mechanically
21:35:37 <augur_> eg Eq a => Eq [a]
21:35:49 <augur_> which generates an infinite collection of eq instances
21:36:00 <augur_> i dont know if ML does this at all
21:36:11 <ChongLi> well, what about something like Monoid?
21:36:43 <augur_> what about it?
21:37:13 <ChongLi> you need separate instances for sums and products
21:37:20 <ChongLi> it's rather inelegant
21:37:43 <jmcarthur> ChongLi: try porting Data.Traversable to an ML. it's not fun.
21:38:02 <jmcarthur> and traverse is *so* useful
21:38:08 <augur_> ChongLi: for int monoids? sure
21:38:14 <augur_> ChongLi: you use newtypes for that typically
21:38:23 <Fuuzetsu> ChongLi: What other solution do you suggest? Some languages (Agda for example) simply pass records around for instances so you can pick whichever one you want but I think a newtype is more convenient for simple things.
21:38:33 <augur_> the problem is that we have this tension, right
21:38:55 <augur_> on the one hand, we have "canonical" ways that something can be viewed as an instance of X
21:39:01 <jmcarthur> ChongLi: basically all that Sum and Product thing means is that even type classes don't get away from explicitly qualifying which instance you mean *all* the time
21:39:06 <augur_> the way that is incredibly common and found all over the place
21:39:10 <ChongLi> augur_: yeah, speaking of which
21:39:16 <augur_> and this motivates having type classes
21:39:24 <augur_> on the other hand you have cases where there just is no choice
21:39:24 <ChongLi> Ord is a rather silly class
21:39:31 <jmcarthur> why?
21:39:35 <augur_> and that motivates _against_ type classes
21:39:39 <ChongLi> since there are so many ways to order things
21:39:42 <frege> how does this work? [(a,b,c) | c<-[1..10], b<-[1..c], a<-[1..b] , a^2 + b^2 == c^2]
21:39:52 <frege> I don't get this part  b<-[1..c]
21:39:59 <frege> what's gonna be in 'b'
21:40:15 <ChongLi> having a canonical way just feels... odd
21:40:16 <jmcarthur> ChongLi: Ord is quite convenient as it is. i only wish the standard library had some more convenient ways of using it, like    sortOn :: Ord b => (a -> b) -> [a] -> [a]
21:40:17 <augur_> frege: an element in [1..c]!
21:40:36 <augur_> ChongLi: the standard successor ordering is fairly canonical
21:40:41 <frege> augur_: is it like [1..[1..10]]?
21:40:45 <augur_> frege: no no
21:41:00 <augur_> c <- [1..10] means that c gets the values in the list [1..10]
21:41:11 <augur_> so for each iteration you get c = 1, then c = 2, then ...
21:41:11 <ChongLi> augur_: what about sorting a product type?
21:41:24 <augur_> ChongLi: what baout it?
21:41:26 <ChongLi> which field ought to be canonical?
21:41:33 <augur_> fst obviously!
21:41:35 <augur_> since its first!
21:41:40 <frege> augur_: oh gotcha
21:42:00 <augur_> ChongLi: we already have these conventions external to haskell
21:42:10 <augur_> they're just conventions, thats all, but they do exist
21:42:11 <jmcarthur> ChongLi: lexicographic ordering is a fine default, and if you want anything else just use either a newtype or your own product type.
21:42:29 <ChongLi> jmcarthur: yeah, I suppose
21:42:31 <jmcarthur> ChongLi: and if you want some different behavior, it wouldn't be hard to just say   sortOn snd   or something
21:42:39 <augur_> the tension is between easy use of convention vs easy use of diversity
21:42:52 <ChongLi> so if I had a type that represented database rows
21:43:01 <jmcarthur> ChongLi: it is, in fact, easier to do that than to write some ordering function inline
21:43:06 <ChongLi> I'd wrap it in a different newtype for sorting on each row?
21:43:22 <frege> augur_: the first iteration for [(a,b,c) | c<-[1..10], b<-[1..c], a<-[1..b] , a^2 + b^2 == c^2] is [(a,b,c) | c = 1, b = 1, a = 1 , 1^2 + 1^2 == 1^2]
21:43:38 <frege> which doesn't yield any results because of the guard
21:43:38 <augur_> frege: sort of, sure
21:43:44 <jmcarthur> ChongLi: for something that ad hoc you could just use sortBy (comparing $ project &&& fields &&& you &&& want &&& to &&& sort &&& by)
21:43:45 <augur_> frege: right
21:44:10 <ChongLi> ahh, yeah
21:44:24 <frege> the second is [(a,b,c) | c = 2, b = 2, a = 2, 4 + 4 == 4] ?
21:44:31 <jmcarthur> ChongLi: oops, forgot about my sortOn function
21:44:41 <jmcarthur> ChongLi:    sortOn (fields &&& i &&& want)
21:44:48 <augur_> ChongLi: the point of newtypes is to encapsulate the atypical cases as "perspectives"
21:44:52 <augur_> frege: no noo
21:45:00 <frege> or does b and c stay on the first element forever?
21:45:13 <ChongLi> yeah, newtypes seem pretty elegant
21:45:13 <jmcarthur> :t sortBy.comparing
21:45:14 <lambdabot> Ord a1 => (a -> a1) -> [a] -> [a]
21:45:18 <augur_> frege: think of how a for loop works, thats a good analogy right now
21:45:43 <ChongLi> anyone use IxSets?
21:45:49 <augur_> frege:   for (i = 0; i < 10; i++) {  for (j = 0; j < i; j++) {  ...  }  }
21:45:58 <stephenmac7> How do I use external libraries from fp complete?
21:46:10 <bitemyapp> :t sortWith
21:46:11 <lambdabot> Not in scope: `sortWith'
21:46:13 <jmcarthur> :t \f -> map snd . sortBy (comparing fst) . map (f &&& id)
21:46:13 <lambdabot> Ord c => (a -> c) -> [a] -> [a]
21:46:18 <bitemyapp> sigh, nuts.
21:46:26 <augur_> frege: so it might be useful to see this:
21:46:29 <jmcarthur> ^^^ that one is sometimes more efficient than  sortBy.comparing
21:46:43 <augur_> > [(a,b) | a <- [1..3], b <- [1..a] ]
21:46:44 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
21:46:54 <augur_> frege: does that make things a little clearer?
21:47:20 <zRecursive> @undo [(a,b) | a <- [1..3], b <- [1..a] ]
21:47:20 <lambdabot> concatMap (\ a -> concatMap (\ b -> [(a, b)]) [1 .. a]) [1 .. 3]
21:48:13 <frege> augur_: I don't get the second iteration
21:48:36 <frege> I was expecting to see 2, 2
21:48:40 <jmcarthur> > [1..3] >>= \a -> [1..a] >>= \b -> return (a,b)
21:48:41 <augur_> frege: ok, so a gets values in [1..3] == [1,2,3]
21:48:41 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
21:48:58 <frege> right
21:49:01 <frege> and what's b
21:49:03 <augur_> frege: so we expect to have tuples (1,...) (2,...) and (3,...)
21:49:09 <frege> exactly
21:49:16 <augur_> frege: and for each choice of a, b is drawn from [1..a]
21:49:21 <jmcarthur> > do { a <- [1..3]; b <- [1..a], return (a,b) }
21:49:22 <lambdabot>  <hint>:1:30: parse error on input `,'
21:49:26 <jmcarthur> > do { a <- [1..3]; b <- [1..a]; return (a,b) }
21:49:27 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
21:49:32 <augur_> frege: so when a == 1, then b is drawn from [1..1] == [1]
21:49:36 <augur_> frege: so we only get (1,1)
21:49:41 <lispy> stephenmac7: I think you can only use the libraries in stackage
21:49:44 <augur_> frege: when a == 2, b is drawn from [1..2] == [1,2]
21:49:49 <augur_> frege: so we get (2,1) and (2,2)
21:49:51 <lispy> stephenmac7: not 100% sure about that
21:49:53 <stephenmac7> lispy: Okay
21:50:09 <augur_> frege: when a == 3, b is drawn from [1..3] == [1,2,3] so we get (3,1) (3,2) (3,3)
21:50:13 <augur_> frege: make sense?
21:50:13 <lispy> You might ask johnw if he's around
21:50:14 <stephenmac7> I'm finally kind of understanding haskell
21:50:26 <johnw> I am here
21:50:37 <stephenmac7> johnw: Any way to use zip-archive on fpcomplete?
21:50:42 <johnw> yes, you can use external libraries
21:50:51 <johnw> as long as it's on Hackage, or you have a Git-accesible URI
21:50:57 <stephenmac7> How?
21:51:02 <frege> augur_: ah right everytime we do a full iteration on the whole list
21:51:06 <augur_> right
21:51:08 <frege> I see what's happening
21:51:11 <augur_> frege: it might also help to think about    map (\x -> [1..x]) [1,2,3]
21:51:12 <augur_> > map (\x -> [1..x]) [1,2,3]
21:51:13 <lambdabot>  [[1],[1,2],[1,2,3]]
21:51:19 <johnw> go to the project settings, to "Extra Hackage Packages"
21:51:21 <frege> I tought we pick one from each and then reset
21:51:30 <johnw> then click on the documentation link
21:51:36 <frege> right right
21:51:49 <augur_> frege: also then:
21:51:54 <augur_> map (\x -> (x,[1..x])) [1,2,3]
21:51:58 <augur_> > map (\x -> (x,[1..x])) [1,2,3]
21:51:59 <lambdabot>  [(1,[1]),(2,[1,2]),(3,[1,2,3])]
21:51:59 <stephenmac7> johnw: Thanks
21:52:07 <stephenmac7> Good night!
21:52:08 <augur_> also then
21:52:10 <stephenmac7> I'll try tomorrow
21:52:12 <frege> what's \x?
21:52:32 <tertl3> lamda x
21:52:33 <augur_> > map (\x -> map (\y -> (x,y)) [1..x]) [1,2,3]
21:52:34 <lambdabot>  [[(1,1)],[(2,1),(2,2)],[(3,1),(3,2),(3,3)]]
21:52:39 <frege> oh gotcha
21:53:14 <augur_> i wonder if lambdabot has tuple sections
21:53:15 <frege> the pythonic way of this is map(lambda x:[x,xrange(1,x)], [1,2,3])
21:53:18 <augur_> > (3,) 4
21:53:20 <lambdabot>  (3,4)
21:53:21 <augur_> \o/
21:53:29 <augur_> > map (\x -> map (x,) [1..x]) [1,2,3]
21:53:30 <lambdabot>  [[(1,1)],[(2,1),(2,2)],[(3,1),(3,2),(3,3)]]
21:53:54 <augur_> frege: actually i think the pythonic way of doing it is
21:54:20 <augur_> [ (a,b,c) for a in range(0,10), b in range(0,a), ... ]
21:54:24 <augur_> or something like that
21:54:53 <frege> yeah it needs to be iterated
21:54:58 <augur_> fwiw, pythonic list comprehensions were lifted from haskell iinm
21:55:12 <Fuuzetsu> ``pythonic''
21:55:48 <Fuuzetsu> what's pythonic today, might not be pythonic tomorrow when Guido wakes up and has a whim
21:55:57 <Fuuzetsu> s/,//
21:55:58 <augur_> :)
21:56:36 <bitemyapp> Fuuzetsu: what, did you expect a principled or informed approach?
21:57:22 <thirsteh> how do I tell cabal to use a local, modified version of a package instead of the real one from hackage? I know there is a simple flag, but my memory fails me
21:57:56 <Fuuzetsu> bitemyapp: From the benevolent dictator? Nah.
21:58:06 <thirsteh> ...and I just remembered: cabal sandbox add-source :)
22:10:08 <ChongLi> augur_: which were lifted from set-builder notation
22:10:55 <augur_> ChongLi: no no, set builder notation stole it from haskell after a time travelling haskeller got stuck in the past
22:10:56 <augur_> :x
22:11:05 <augur_> i wonder where set builder notation originates tho
22:11:21 <erisco> I am looking for something a bit odd... I have a general pattern where two types work with each other
22:11:42 <erisco> classes only allow specialisation on one type. I am looking to instance for specific pairs
22:11:43 <ChongLi> augur_: possibly Cantor
22:11:50 <bitemyapp> augur_: ...math.
22:12:20 <johnw> erisco: there are multi-parameter type classes
22:12:45 <augur_> ChongLi: hm maybe
22:12:48 <the_berserker> @pl let factorial 0 = 1; factorial n = n* factorial (n-1) in factorial
22:12:48 <lambdabot> ap (*) (ap id (subtract 1))
22:12:50 <augur_> maybe also frege
22:13:17 <frege> what's this let fact n = [ a * (head (tail [a..n])) | a<-[1..n]
22:13:24 <frege> the problem here?
22:13:32 <erisco> johnw, I think I would need a fun dep pointing each way?
22:13:38 <augur_> frege: ??
22:13:50 <the_berserker> > (ap (*) (ap id (subtract 1))) 6
22:13:51 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = a0 -> a0
22:13:51 <lambdabot>  Expected type: a0 -> a0 -> a0
22:13:51 <lambdabot>    Actual type: a0 -> a0
22:13:59 <frege> I'm trying to write a factorial function
22:14:11 <augur_> frege: yes, but what is that thing you just wrote
22:14:52 <johnw> erisco: you could, if you have functions that only deal with one of the parameters
22:15:30 <erisco> johnw, well I will have concrete types A and B, and I want the instance to be particular to  A and B
22:15:33 <frege> garbage I guess
22:15:43 <the_berserker> @pl \fuck you -> fuck (fuck you)
22:15:43 <lambdabot> join (.)
22:15:54 <erisco> johnw, perhaps fun deps are not related... I guess that only matters on the parametric types
22:15:56 <johnw> the instance will be.  with fun deps, you're saying that a given A can only be paired with exactly one B
22:15:59 <erisco> I am a bit foggy on it
22:16:23 <erisco> johnw, yes but also given the B it is only paired with one A
22:16:32 <johnw> sure, if you have fun deps in both directions
22:16:35 <the_berserker> The pointfree-ifier is broken
22:16:40 <erisco> right, okay I'll try that
22:17:00 <augur_> the_berserker: you mean because of the ap thing above?
22:17:53 <augur_> the_berserker: its not broken so much as it doesnt grok case terribly well.
22:18:06 <the_berserker> augur_: Yes. Will it work in Scheme?
22:18:07 <augur_> the_berserker: you'll observe that what it gave you was just for the second case of factorial
22:18:49 <augur_> :t ap
22:18:50 <lambdabot> Monad m => m (a -> b) -> m a -> m b
22:18:55 <augur_> :t ap (*)
22:18:55 <lambdabot> Num a => (a -> a) -> a -> a
22:19:23 <augur_> :t ap id
22:19:24 <lambdabot> ((a -> b) -> a) -> (a -> b) -> b
22:19:40 <augur_> :t ap id (subtract 1)
22:19:41 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> b0
22:19:41 <lambdabot>     Expected type: (a0 -> b0) -> a0
22:19:41 <lambdabot>       Actual type: (a0 -> b0) -> a0 -> b0
22:20:02 <augur_> hm!
22:21:55 <ddellacosta> Hi, über newb here.  Trying to figure out the semantics of this statement: bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs) (from this monad tutorial: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html).
22:22:32 <ddellacosta> I'm having trouble understand where fx, fs are coming from.
22:22:48 <mikeplus64> http://lpaste.net/98346 <- sneak peak at some dreadful matrix stuff i'm working on
22:23:23 <erisco> > let (a, b) = (1, 2) in a + b -- ddellacosta it is pat matching the returned tuple
22:23:24 <lambdabot>  3
22:24:52 <ddellacosta> erisco: okay, that helps, I'll have to think on that for a minute.  Thanks!
22:26:44 <roboguy_> I don't think point free does any type checking
22:27:41 <bitemyapp> roboguy_: ...I beg your pardon?
22:27:48 <roboguy_> bitemyapp: @pl
22:27:55 <roboguy_> I don't think @pl does any type checking
22:28:50 <lispy> roboguy_: right
22:28:59 <lispy> roboguy_: and it gets really confused about some symbols
22:29:08 <lispy> @pl a >>= b
22:29:08 <lambdabot> b =<< a
22:29:14 <lispy> hmm
22:29:17 <lispy> I forgot a good example
22:29:36 <roboguy_> @pl let x = f x in x
22:29:36 <lambdabot> fix f
22:29:39 <roboguy_> aw
22:30:13 <roboguy_> I've seen it say "join id" before
22:30:18 <roboguy_> with something...
22:30:19 <shachaf> Is there an obvious nicest way of writing add/mul :: Nu Maybe -> Nu Maybe -> Nu Maybe, where data Nu f = forall x. Nu x (x -> f x)?
22:35:30 <psii_> 3/quit
22:48:49 <the_berserker> let 2+2=5 in 2+2
22:49:05 <Tekmo> > let 2+2=5 in 2+2
22:49:06 <lambdabot>  5
22:49:13 <the_berserker> > let 2+2=5 in 2+2
22:49:14 <lambdabot>  5
22:50:02 <the_berserker> You can bind a value to an expression without variables!?
22:50:21 <Tekmo> the_berserker: (+) is what you are defining
22:50:28 <Tekmo> the_berserker: You're shadowing the definition of `(+)`
22:50:37 <dv-> > let 2+2 = 5 in 2+3
22:50:37 <lambdabot>  *Exception: <interactive>:3:5-11: Non-exhaustive patterns in function +
22:54:49 <pavonia> > let 2+2 = 5; x+y = x Prelude.+ y in map (2 +) [1,2,3]
22:54:50 <lambdabot>  [3,5,5]
22:56:06 <lispy> @src
22:56:06 <lambdabot> src <id>. Display the implementation of a standard function
22:56:11 <lispy> @version
22:56:11 <lambdabot> lambdabot 5.0-int-e
22:56:11 <lambdabot> git clone git://github.com/int-e/lambdabot.git
23:04:25 <jle`> is there a commonly used mathematical analog of Maybe
23:04:38 <Tekmo> jle`: What do you mean by mathematical analog?
23:04:47 <jle`> like...a commonly used math object
23:04:54 <jle`> that is Maybe
23:05:04 <jle`> or math concept
23:05:04 <lispy> jle`: I don't think so. Mathematicians tend to have total definitions and a sort of "you can apply this or not" heuristic
23:05:21 <Tekmo> I guess `_|_` from denotational semantics would be the closest thing I can think of
23:05:42 <lispy> when I was taught calculus there was a lot of "DNE" answers for when the limit (or derivative) didn't exist
23:05:46 <Tekmo> It sort of plays the role of `Nothing` if you assume that everything else is wrapped in `Just`
23:05:55 <jle`> i feel like math is more like null /null pointer kinda stuff
23:05:57 <jle`> yeah
23:05:57 <lispy> jle`: in some ways, you can think of classical mathematics as untyped
23:06:05 <jle`> like how java etc. handle it
23:06:36 <Tekmo> Yeah, in that case you can consider any partial mathematical definition to be implicitly a `Maybe`
23:07:18 <lambdaKanha> hola
23:07:22 <Tekmo> Hi!
23:07:23 <jle`> i mean technically in java, every type is really a union type between that type and null
23:07:25 <lispy> lambdaKanha: welcome
23:07:42 <jle`> so maybe it is the same in math...if it even makes sense to apply type stuff to classical maths
23:07:46 <lispy> jle`: For user defined types. The builtins are exceptions.
23:07:57 <jle`> ofc
23:08:10 <Tekmo> jle`: Are you Justin Le?
23:08:16 <jle`> Tekmo: yes i am
23:08:20 <Tekmo> I like your blog! :)
23:08:28 <jle`> haha
23:08:30 <jle`> thanks :)
23:08:46 <lispy> jle`: classical mathematics is more like python or lisp in terms of types because there is a sort of understanding that you do things that make sense.
23:08:48 <lambdaKanha> wanted to know what is best tutorial / article to get complete feel of monads .??
23:08:49 <jle`> don't praise me too much or i might start thinking that the stuff i right is correct
23:08:56 <jle`> *write
23:09:02 <Tekmo> lambdaKanha: This is the best: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
23:09:03 <lispy> lambdaKanha: Probably something by Brent Yorgey
23:09:13 <Tekmo> jle`: Haha :)
23:09:19 <lispy> lambdaKanha: http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
23:09:19 <jle`> lambdaKanha: hm. many people recommend not to study monads as a distinct concept
23:09:33 <jle`> because really monads do not offer much in terms of semantic meaning
23:09:34 <Tekmo> Dan Piponi's blog article is THE article on monads
23:09:34 <lispy> Tekmo, jle`: link to blog please :)
23:10:03 <jle`> if you try to understand monads as a concept AND how they are used, you will likely come out empty handed
23:10:06 <lambdaKanha> txs
23:10:08 <jle`> lispy: http://blog.jle.im
23:10:14 <lispy> jle`: thanks
23:10:18 <jle`> np :)
23:12:16 <lambdaKanha> i took intro to haskell as a course book and took beckman video on monad from channel 9 . Understand quite bit but not in complete control
23:12:23 <jle`> lambdaKanha: monads don't 'mean' anything...they just offer bind and join, two somewhat meaningless operations that follow certain laws.  it is more useful to look into using things that happen to be monads.
23:12:32 <jle`> there is no real semantic link between different monads besides superficial and coincidental ones
23:12:49 <lambdaKanha> is category theory required to completely understand that ?
23:12:50 <jle`> it's like saying that you want to understand how to program
23:12:56 <jle`> and studying text editors
23:12:57 <lambdaKanha> i understd that
23:12:59 <Tekmo> I would say that there is one link, which is that monads lend themselves well to imperative notation (i.e. `do` notation)
23:13:29 <lambdaKanha> got u
23:13:32 <jle`> lambdaKanha: category theory is "necessary" to understand the mathematics behind monads.  but that's like saying that you need to know compiler theory to use Haskell.  you don't have to write ghc.
23:13:47 <jle`> i am flying a bit loose with my analogies at this point now though.
23:13:53 <jle`> heh.
23:14:16 <jle`> it might be like saying that you are trying to understand parentheses
23:14:17 <lambdaKanha> ahhah
23:14:21 <jle`> how to type them
23:14:26 <jle`> their etymology
23:14:32 <jle`> how to make your text editor highlight paired parentheses
23:14:36 <jle`> but really it's kind of pointless
23:14:45 <Tekmo> For me, the big revelation was that anything that implemented the `Monad` type class could be used with `do` notation
23:14:46 <ReinH> jle`: "no real semantic link"?
23:14:46 <jle`> because parentheses are used in different contexts
23:14:48 <jle`> to do different things
23:15:01 <jle`> and understaind parentheses in one case won't help you understand them in another
23:15:19 <lambdaKanha> i know only function composition and bind , return is required .
23:15:20 <jle`> in a function call, or in a tuple, or in an order of operations kinda thing
23:15:26 <lambdaKanha> but i want complete feeling
23:15:55 <lambdaKanha> i got the basis of monad and how it works . i want to get deep down into it
23:15:58 <ReinH> lambdaKanha: It is sufficient for using the Monad typeclass in Haskell to understand the types of (>>=), return, and join and the laws that they (are expected to) obey.
23:16:10 <lambdaKanha> ty
23:16:12 <ReinH> lambdaKanha: That is a complete and accurate definition of what a monad is in Haskell.
23:16:12 <jle`> if i want to learn how to write a tuple, i don't need to 'understand parentheses' as a general concept.  parentheses are a useful thing invented to aid in many different diverse situations and contexts...writing tuples being one of them
23:16:32 <lambdaKanha> jle' understand ur pt .
23:16:38 <jle`> ah
23:16:39 <johnw> lambdaKanha: if you want to go deep, I'd suggest learning how monads are monoids in the category of endofunctors.  It wasn't until then that the concept really sank in for me
23:16:42 <jle`> i apologize for belaboring
23:16:47 <ReinH> lambdaKanha: it will also help to understand do notation at to gain some experience with specific, common monad instances
23:17:01 <jle`> lambdaKanha: yes if you want a real theoretical underpinning, understand them as monoids
23:17:33 <lambdaKanha> i understand them as monoids ?? clock eg by beckman was a class eg
23:17:53 <ReinH> jle`: it is difficult to understand haskell monads as monoids since we don't have direct access to the an expression of their relevant category
23:17:53 <lambdaKanha> thanks for the links / blogs
23:18:44 <jle`> lambdaKanha: are you new to Haskell?
23:18:48 <lambdaKanha> no
23:18:51 <jle`> okay
23:19:03 <jle`> was making sure i didn't run too far with bad assumptions
23:19:16 <brokenzebra> i can't stop writing haskell when i should be job-huntin
23:19:16 <lambdaKanha> happens
23:19:25 <jle`> here are my faves on the subject
23:19:27 <jle`> http://www.stephendiehl.com/posts/monads.html
23:19:33 <brokenzebra> avoiding success at all costs
23:19:44 <jle`> http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
23:20:14 <lambdaKanha> txs again for the links
23:20:14 <Tekmo> brokenzebra: There are Haskell jobs available
23:20:34 <erisco> with multi param type classes, how do you disambiguate args to the type class from type args? ie  instace Class Foo Bar Blah   for class Class a b is this Foo (Bar Blah) or (Foo Bar) Blah?
23:21:36 <johnw> erisco: how could you even pass 3 args to a two parameter type class instance?
23:21:37 <lambdaKanha> nd brokenZebra u may find some jobs in the zoo??
23:21:47 <Tekmo> lambdaKanha: You're welcome
23:21:47 <erisco> johnw, I am not
23:21:55 <brokenzebra> Tekmo: isn't haskell notorious for being constrained to academia?
23:21:58 <jle`> it helps more to view monads as monoids if we consider arrows, (a -> m b), and a monoidal binary function (associative with an identity) (>=>) ::  (a -> m b) -> (b -> m c) -> (a -> m c).  the identity is return :: (a -> m a).  there, monoid :)
23:22:11 <Tekmo> brokenzebra: There are fewer jobs, but they definitely exist
23:22:22 <Tekmo> brokenzebra: You just have to know how to network
23:22:38 <ReinH> jle`: that is not why monads are "monoids in the category of endofunctors"
23:22:40 <johnw> brokenzebra: most of the Haskellers I know work in finance
23:22:42 <Tekmo> brokenzebra: You won't find them on careers.com
23:22:58 <ReinH> That is just composition in the kleisli category
23:23:09 <johnw> yeah, that's just a MonadPlus style of monoid
23:23:18 <jle`> ReinH: but this monoid over monads is enough to give yield the monad laws, right?
23:23:25 <Tekmo> I honestly prefer the Kleisli category explanation of the theory behind monads
23:23:29 <jle`> it might not demonstrate that tehy are monoids in the category of endofunctors
23:23:35 <jle`> but it demonstrates that they are monoids of some sort
23:23:38 <Tekmo> It's equivalent to the monoid explanation, but more useful to Haskell programmers
23:23:40 <jle`> and that the monoid laws yield the monad laws
23:23:40 <johnw> but it won't indicate what the "monadness" is about
23:23:41 <brokenzebra> johnw: how is that possible? aren't most shops doing cpp/java/c#?
23:23:42 <jle`> ?
23:23:49 <jle`> johnw: ah ok
23:23:54 <ReinH> brokenzebra: most people are not programmers. And yet some are.
23:23:56 <johnw> brokenzebra: our shop is 100% Haskell
23:24:01 <Tekmo> johnw: You can derive either explanation from each other, so I consider it an equally "monadness" explanation
23:24:07 <lambdaKanha> jle'  's arguments look more right
23:24:22 <jle`> no if i have learned anything from my time here it is that i'm usually wrong >.>
23:24:22 <lispy> ReinH: fun
23:24:23 <lambdaKanha> it gives easy platform to go that way
23:24:28 <johnw> Tekmo: but doesn't the MonadPlus style monoid require an assumption of what >=> means to make sense of it?
23:24:36 <lispy> ReinH: where do you work?
23:24:39 <Tekmo> johnw: Oh yeah, you're right
23:24:43 <ReinH> lispy: AT&T but I don't do Haskell :/
23:24:48 <lambdaKanha> >> muat make sense
23:24:52 <Tekmo> johnw: The monoid one doesn't require functions
23:25:18 <erisco> johnw, param 1 is * -> * -> * and param 2 is * -> *. it seems the compiler is reading instance Foo A B as instance Foo (A B)
23:25:21 <ReinH> with "monads are monoids in the category of endofunctors", the monad laws are the obvious ones
23:25:24 <Tekmo> brokenzebra: Remember, you don't need 99 haskell jobs.  You only need one
23:25:34 <lispy> ReinH: oh, maybe I misread.
23:25:41 <lispy> ReinH: Still, AT&T should be a fun place to work
23:25:44 <johnw> erisco: can you paste your code, is it small enough?
23:25:48 <ReinH> lispy: some times yes.
23:26:13 <erisco> johnw, http://lpaste.net/98353
23:26:15 <nisstyre> Is evaluating a thunk a form of mutation? I'm reading "Compiling with Continuations" and he says that evaluating a thunk is a kind of mutation in the implementation(s) of Haskell since it really mutates the value of something.
23:26:22 <ReinH> The T^2 -> T and 1 -> T form of "monads are monoids" is the compelling one for me.
23:26:39 <jle`> i like to think of it as...an implementation detail
23:26:44 <jle`> ( nisstyre )
23:26:48 <nisstyre> jle`: fair enough
23:26:52 <lispy> nisstyre: Not at the level of the Haskell programmer, but yes at the level of the run-time system.
23:26:58 <nisstyre> jle`: does it impact the possible optimizations one can do?
23:27:24 <Tekmo> nisstyre: What optimizations do you have in mind?
23:27:27 <lambdaKanha> best book / link for category theory .
23:27:34 <nisstyre> Tekmo: register allocation?
23:27:35 <ReinH> Although kleisli composition of monads is certainly useful
23:27:45 <Tekmo> nisstyre: Are you implementing a Haskell compiler?
23:27:49 <johnw> erisco: try using "class Scalable (t :: * -> * -> *) (v :: * -> *)
23:27:52 <johnw> see if that makes things clearer
23:27:59 <nisstyre> Tekmo: I'm implementing a compiler for a language much like ML or Haskell
23:28:21 <Tekmo> nisstyre: Have you read the paper on the STG machine?
23:28:30 <nisstyre> Tekmo: no but I've come across it
23:28:31 <ReinH> jle`: also that more traditional way of explaining monads leads into T-algebras nicely
23:28:31 <erisco> johnw, seems that is a parse error
23:28:34 <Tekmo> nisstyre: It's worth reading
23:28:40 <shachaf> ReinH: Is there any other form?
23:28:41 <nisstyre> okay, I'll make a mental note of it
23:28:54 <johnw> erisco: really?  what is theerror?
23:28:54 <erisco> johnw, sorry my mistake
23:29:09 <ReinH> shachaf: I suspect it isn't correct, but the suggestion was to use the kleisli category
23:29:09 <jle`> ReinH: thanks :)
23:29:11 <hdevalence> is there a nice way to generate all k-element subsets of a list/set?
23:29:11 <intrados> lambdaKanha: I'm working through http://www.cs.man.ac.uk/~david/categories/ and finding it better than some other things I looked at
23:29:33 <erisco> johnw, mkay I have the same error as before. it is looking for a type arg on H2Tuple
23:29:37 <ReinH> shachaf: and a "monads are monoids" explanation, although that isn't the "monads are monoids in the category of endofunctors"
23:29:43 <lispy> lambdaKanha: awodey has a very good book on it. Book: http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf Lectures: http://www.youtube.com/watch?v=ZKmodCApZwk
23:29:46 <shachaf> "(>=>) is associative" isn't the kind of monoid we're talking about when we say that monads are monoids in any sort of sense.
23:29:46 <intrados> lambdaKanha: It actually implements the constructions in SML
23:29:52 <Tekmo> hdevalence: Kind of.  You can reduce it to a simpler problem
23:30:19 <ReinH> jle`: shachaf is who I go to when I want my false preconceptions about math to be ruthlessly and efficiently dismantled ;)
23:30:25 <Tekmo> hdevalence: If you have a function `pick` of type: [a] -> [(a, [a])]
23:30:25 <johnw> erisco: oh, because H2Tuple is a type synonym
23:30:31 <ReinH> jle`: which I do. And he does.
23:30:36 <jle`> i could use a good dismantling :)
23:30:38 <Tekmo> hdevalence: that function represents all ways you can take one element from the underlying list and the remainder
23:30:42 <jle`> i see the flaw now
23:30:43 <lambdaKanha> txs too much helpers here
23:30:45 <erisco> johnw, is there another reasonable way I can get a homogenous tuple?
23:30:46 <johnw> erisco: make it a newtype and it should work
23:30:48 <jle`> or at least have a good peek at it
23:30:53 <lispy> lambdaKanha: haha! We do try :)
23:30:57 <jle`> although i am sure i could see more of it with time
23:30:58 <shachaf> (>=>) gives you a category, not a monoid (well, it also gives you a bunch of monoids, one per type).
23:30:59 <Tekmo> hdevalence: If you have that function, then the implementation is really simple
23:31:06 <ReinH> jle`: I'd like to know if it's irght because I can't explain it so I don't understand it either.
23:31:09 <johnw> you should use a newtype and call it Pair, so that at the type level the homogeneity is expressed
23:31:15 <hdevalence> Tekmo: thanks!
23:31:31 <Tekmo> hdevalence: Once you have that function, you can wrap it in `StateT`, to get:
23:31:42 <Tekmo> hdevalence: StateT pick :: StateT [a] [] a
23:31:47 <erisco> johnw, okay thanks
23:31:51 <Tekmo> hdevalence: Then picking `k` values is as simple as:
23:32:03 <Tekmo> hdevalence: replicateM n (StateT pick) :: StateT [a] [] [a]
23:32:10 <Tekmo> Oops, that should be `k` instead of `n`
23:32:20 <Tekmo> hdevalence: Then you `runStateT` to get the equivalent list transformation
23:32:47 <Tekmo> hdevalence: runStateT $ replicateM n $ StateT pick :: [a] -> [([a], [a])]
23:32:58 <Tekmo> hdevalence: That gives you all k subsets plus their complement
23:33:05 <Tekmo> hdevalence: If you don't care about the complement, just use `evalStateT` instead
23:33:06 <ReinH> shachaf: I'm starting to understand cat theory a bit more but it's taking 5 different books and a bunch of lectures. I am slow.
23:33:16 <Tekmo> hdevalence: evalStateT $ replicateM n $ StateT pick :: [a] -> [[a]]
23:33:24 <hdevalence> oh, I see. I was thinking that you'd do something with the list monad
23:33:31 <jle`> is it only me that get some kind of neat/perverse thrill out of using monads (and monad transformers) like state and reader ad-hoc like that?
23:33:35 <ReinH> shachaf: Which book did you mention before that gives defines cats in terms of just their arrows?
23:33:37 <jle`> *gets
23:33:49 <ReinH> jle`: nope, it's totally perverse-seeming.
23:33:50 <Tekmo> hdevalence: In this case you want to combine `StateT` on top of the list monad so you can keep track of what list elements remain (to avoid duplicates)
23:33:58 <jle`> at that level it's like using them the same way you'd use fold or something
23:34:02 <ReinH> jle`: StateT a IO b stacks are magic
23:34:07 <hdevalence> ah, ok
23:34:07 <shachaf> Maybe it was _Categories, Allegories_.
23:34:14 <jle`> 'dropped a fold, no big deal.'  'unrolled a monad transformer, no big deal'
23:34:18 <shachaf> But I haven't read that book beyond the first few pages on the Amazon preview.
23:34:26 <ReinH> jle`: it feels like I'm cheating the type system and working totally imperatively even while I know I'm not.
23:34:37 <ReinH> shachaf: yeah it was.
23:34:42 <ReinH> shachaf: but I really liked those first few pages ;)
23:34:52 <shachaf> But you can find that definition anywhere, such as nlab.
23:35:04 <jle`> i use it a lot when i am building Maps. kind of like a more general foldl.
23:35:06 <ReinH> shachaf: yes, but I enjoyed the exposition
23:35:09 <shachaf> http://ncatlab.org/nlab/show/single-sorted+definition+of+a+category
23:35:11 <ReinH> the writing style and pacing
23:35:23 <Tekmo> ReinH: The nice thing about `StateT a IO` is that you can still define pure sections and merge them in with impure sections using `hoist generalize`
23:35:33 <shachaf> If you like squares, you can read that book (or a book about modal logic).
23:35:39 <Tekmo> ReinH: That way you can have the compiler check that certain sections don't use any `Io`
23:36:03 <ReinH> Tekmo: orly
23:36:06 <Tekmo> ReinH: Yes
23:36:19 <Tekmo> ReinH: I use monad morphisms all the time to limit computation permissions
23:36:21 <ReinH> Tekmo: how can I learn about this?
23:36:28 <Tekmo> From the blog post that I'm writing up on this
23:36:29 <Tekmo> :)
23:36:33 <jle`> haha
23:36:33 <ReinH> Tekmo: ha!
23:36:37 <Tekmo> Monad morphisms are an excellent way to restrict permissions
23:36:39 <ReinH> Tekmo: well hurry up pls
23:36:43 <jle`> Tekmo: link please?
23:36:45 <Tekmo> Here is a simple function I like to keep around, for example
23:36:57 <Tekmo> readOnly :: (Monad m) => ReaderT s m a -> StateT s m a
23:36:59 <copumpkin> moanad moarphisms
23:37:02 <zRecursive> @unmtl StateT a IO
23:37:02 <lambdabot> Plugin `unmtl' failed with: `StateT a IO' is not applied to enough arguments, giving `/\A. a -> IO (A, a)'
23:37:03 <Tekmo> `readOnly` is a monad morphism
23:37:10 <shachaf> hi copumpkin
23:37:14 <copumpkin> hi shachaf
23:37:16 <ReinH> @unmtl StateT a IO b
23:37:16 <lambdabot> a -> IO (b, a)
23:37:17 <Tekmo> It delimits a computation to view a `StateT` through a read-only API (i.e. `ReaderT`
23:37:21 <jle`> Tekmo: huh that's pretty cool
23:37:33 <shachaf> i bet you can answer my question
23:37:38 <Tekmo> jle`: So you can statically check that a certain computation doesn't modify state, but then merge it with other computations that do modify state
23:37:39 <ReinH> Tekmo: wait, that isn't StateT s m a -> ReaderT s m a ?
23:37:42 <Tekmo> Nope
23:37:44 <copumpkin> shachaf: I doubt it!
23:37:44 <Tekmo> Other way around
23:37:50 <Tekmo> It's supposed to work like this:
23:37:51 <ReinH> Tekmo: Why is it the other way around?
23:38:00 <jle`> you do like readOnly $ do ..
23:38:04 <Tekmo> Like this:
23:38:07 <ReinH> ahh
23:38:07 <Tekmo> readOnly m1 >> m2
23:38:08 <shachaf> oh well :'(
23:38:11 <ReinH> you write your monadic action
23:38:12 <jle`> and inside the do block you only have access to ask
23:38:14 <Tekmo> `m1` is not allowed to mutate state
23:38:16 <ReinH> against ReaderT
23:38:17 <Tekmo> but `m2` is
23:38:19 <copumpkin> shachaf: might as well try though
23:38:22 <ReinH> and it is morphed into StateT
23:38:23 <ReinH> ofc
23:38:31 <erisco> johnw, any idea how I might make line 6 work? http://lpaste.net/98354 Monad (t a) is an invalid restriction because 'a' is not in scope
23:38:36 <Tekmo> Another one I like is this:
23:38:40 <shachaf> i don't even remember what my question was
23:38:46 <copumpkin> :(
23:38:49 <shachaf> oh
23:38:49 <ReinH> readOnly $ do {- stuff with ReaderT interface -}
23:38:49 <shachaf> <shachaf> Is there an obvious nicest way of writing add/mul :: Nu Maybe -> Nu Maybe -> Nu Maybe, where data Nu f = forall x. Nu x (x -> f x)?
23:38:50 <ReinH> got it
23:38:54 <Tekmo> pure :: (MFunctor t, Monad m) => t Identity r -> t m r
23:38:57 <Tekmo> pure = hoist generalize
23:39:08 <ReinH> Tekmo: oh nice, enforced purity
23:39:11 <Tekmo> Exactly
23:39:15 <ReinH> awesome
23:39:17 <Tekmo> You run a subset without access to `IO`
23:39:19 <ReinH> Tekmo: you are le smart
23:39:30 <ReinH> Tekmo: I wish to subscribe to your newsletter
23:39:33 <Tekmo> Haha
23:39:37 <Tekmo> I will blog about this very soon
23:39:40 <jle`> i asked first :|
23:39:40 <ReinH> pls do
23:39:48 <ReinH> Tekmo: I can tech review if you want
23:40:04 <intrados> Is there a way to do a similar sort of thing with IO? I have often wished to express that an IO function is only reading or only writing
23:40:16 <Tekmo> intrados: You can use a free monad for this purpose
23:40:26 <Tekmo> intrados: Then prove that the interpreter is a monad morphism
23:40:33 <Tekmo> intrados: See: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
23:40:53 <Tekmo> So you would have something like:
23:41:14 <Tekmo> data CommandF x = Write String x | Read (String -> x)
23:41:18 <Tekmo> type Command = Free CommandF
23:41:27 <Tekmo> readLine :: Command String
23:41:35 <Tekmo> readLine = liftF (Read id)
23:41:41 <Tekmo> writeLine :: String -> Command ()
23:41:46 <erisco> johnw, seems that I can put the constraints on the methods instead of the class
23:41:48 <Tekmo> writeLine str = liftF (Write str)
23:41:58 <Tekmo> Then you just need an interpreter
23:42:03 <Tekmo> interpret :: Command r -> IO r
23:42:07 <jle`> Tekmo: oh forgot that you are gabriel gonzalez. i asked you this same question a week and a half ago.
23:42:09 <Tekmo> interpret (Pure r) = return r
23:42:30 <Tekmo> interpret (Free (Read k)) = getLine >>= \str -> interpret (k str)
23:42:46 <Tekmo> interpret (Free (Write str x)) = putStrLn str >> interpret x
23:42:52 <Tekmo> Then you just prove that `interpret` is a monad morphism
23:43:40 <intrados> Ah, that's nifty. Thanks
23:43:44 <Tekmo> intrados: You're welcome!
23:45:01 <Tekmo> Oh, you'd also need to define a `Functor` instance for `Command`
23:45:08 <ReinH> Tekmo: So I read a bunch of definitions of free monads but it only clicked when I realized what it would mean for "join" to be derived "for free".
23:45:09 <Tekmo> *`CommandF`
23:45:10 <ReinH> I am slow sometimes.
23:45:30 <Tekmo> Yeah, `join` just eliminates the first `Pure` constructor
23:46:30 <Tekmo> For me, I prefer to reinvent everything because I learn better that way
23:46:36 <shachaf> I'm not sure that "for free" is the right thing to look for with free objects.
23:46:57 <jle`> oh i always thought it was free because you can do whatever you want and defer defining how to join etc. until later
23:47:07 <ReinH> jle`: yes, you can
23:47:21 <jle`> so like more like 'free' as in 'free variable'
23:47:24 <ReinH> jle`: let me ask you this
23:47:25 <Tekmo> You also defer how to write `return`, too
23:47:29 <jle`> not free as in free beer
23:47:35 <ReinH> if I want to combine two monoidal values together
23:47:45 <ReinH> jle`: but I want to defer the definition of <> until later
23:47:47 <ReinH> what do I do now?
23:47:52 <Tekmo> `return` just introduces a `Pure` and `join` eliminates the first `Pure`
23:47:53 <jle`> isn't that what a free monoid is?
23:47:58 <Tekmo> ReinH: Free monoid
23:48:00 <Tekmo> ReinH: a list
23:48:02 <ReinH> exactly
23:48:08 <ReinH> the free monad is exactly that
23:48:15 <ReinH> but for monads, not monoids
23:48:19 <Tekmo> Yeah.  It is like a linked list of functors
23:48:36 <Tekmo> The `Free` constructor is like "cons" and the `Pure` constructor is like "nil"
23:48:38 <shachaf> Hence class Functor m => Monad m where retract :: Free m a -> m a
23:48:39 <jle`> so free in the same usage as free variable...it's left open until later?
23:48:44 <ReinH> jle`: no
23:48:46 <jle`> aw
23:48:48 <jle`> :'(
23:48:54 <jle`> oh wait
23:48:56 <jle`> that's a bound variable
23:48:58 <ReinH> jle`: the free here doesn't refer to free variables
23:49:08 <ReinH> jle`: it refers to "http://en.wikipedia.org/wiki/Free_object"
23:49:12 <ReinH> I don't know why I quoted that
23:49:18 <jle`> ah
23:49:20 <Tekmo> I like the definition of being a limit in some category
23:49:35 <shachaf> A limit?
23:49:47 <Tekmo> Give me a second to remember the exact definition
23:49:48 <ReinH> jle`: informaly it means that you get the struture "for free"
23:49:52 <ReinH> *structure
23:50:03 <jle`> hm
23:50:05 <shachaf> The usual categorical definition is as a left adjoint.
23:50:05 <jle`> oh
23:50:07 <jle`> you get it
23:50:13 <jle`> without having to define join, etc.
23:50:14 <jle`> ?
23:50:19 <jle`> you get it without having to define <>?
23:50:32 <jle`> it's just...there?
23:50:33 <ReinH> jle`: i.e. the only equations that hold between the elements of the free object are those that follow from the defining axioms of the structure
23:51:02 <ReinH> it doesn't require any extra assumptions
23:51:12 <jle`> ic
23:52:26 <Tekmo> shachaf: No, but there is another one
23:52:33 <Tekmo> shachaf: It's an equivalent definition, but it helped me more
23:53:38 <ReinH> jle`: the free monoid is a pretty good example because in general for associative structures you start by considering words
23:53:44 <ReinH> and for the free monoid that's all you have to consider
23:54:28 <shachaf> Tekmo: Well, a limit functor is adjoint too, but that's probably not what you're getting at.
23:54:46 <Tekmo> shachaf: What's the name of that notation with the down arrow?
23:54:58 <Tekmo> shachaf: i.e. x \|/ y, where that is supposed to be a down arrow
23:55:10 <shachaf> Are you looking for the thing in this page? https://en.wikipedia.org/wiki/Universal_morphism
23:55:12 <ReinH> jle`: i.e. if you want to turn a set into a monoid without knowing anything at all about the set or its functions, how do you do it?
23:55:26 <Tekmo> shachaf: Yes!
23:55:28 <ReinH> jle`: you consider words formed from the alphabet composed of elements of that set
23:55:29 <jle`> welp i have to sort my laundry. anyone have a good talk they recently saw that they can recommend?
23:55:29 <Tekmo> shachaf: That was it
23:55:42 <copumpkin> Tekmo: http://en.wikipedia.org/wiki/Comma_category?
23:55:45 <Tekmo> copumpkin: Yeah
23:55:56 <Tekmo> copumpkin: Shachaf's link was more direct for what I was looking for
23:56:09 <ReinH> jle`: have you seen https://www.youtube.com/user/TheCatsters ?
23:56:22 <jle`> ReinH: i have seen them linked here but i ahven't watched any yet.
23:56:26 <jle`> i guess now is a good time :)
23:56:36 <ReinH> jle`: the introduction to monads there is quite nice and goes immediately into T-algebras in a pretty straightforward manner
23:56:53 <ReinH> jle`: you go straight into "monoids are free monoid monad monad-algebras" for instance
23:57:11 <jle`> oh i did not even notice that it was spelled Catsters
23:57:13 <jle`> how cute
23:57:13 <shachaf> The Catsters videos talk about that?
23:57:21 <carter> Tekmo: to clarify: are you aiming for Base or haskell platform inclusion?
23:57:22 <ReinH> shachaf: not in those terms but yes
23:57:30 <carter> o/ copumpkin
23:57:32 <ReinH> shachaf: it isn't given much significance but they show it
23:57:33 <jle`> here i was wondering how they had grabbed the name TheCasters
23:57:48 <Tekmo> carter: For `void` or `pipes`?
23:57:51 <carter> latter
23:57:56 <Tekmo> carter: Haskell platform
23:57:58 <carter> ok
23:58:23 <Tekmo> The reason I liked the universal morphism interpretation was that it clearly showed that you can factor every design through the free object
23:58:36 <Tekmo> Not that you necessarily want to, but it's always an option
23:59:18 <ReinH> Tekmo: transportability is pretty sweet
