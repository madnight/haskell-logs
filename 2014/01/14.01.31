00:03:43 <watermind> are there some haskell resources about combining monads and comonads?  as in the case where one has    m (cm a)
00:05:15 <watermind> or more precisely...  arrows of the form      cm a -> m a
00:05:57 <watermind> where cm is a comonad and m a monad
00:07:10 <bitemyapp> watermind: you can go cm -> mt but not the other way around
00:08:03 <watermind> bitemyapp: wait I was rather unclear with what I meant
00:08:46 <fragamus> let chopper = nub . (tails <=< inits)
00:09:00 <fragamus> why doesnt that work in ghci
00:09:00 <watermind> much like we have kliseli arrows    a -> m b    and co-kliseli arrows   cm a -> b     I was wondering if there was some theory of arrows   cm a -> m b
00:09:18 <watermind> which is pretty much functions with effects and context
00:09:19 <fragamus> when I say chopper "hello" it gives an error
00:09:54 * hackagebot packer 0.1.3 - Fast byte serializer and unserializer  http://hackage.haskell.org/package/packer-0.1.3 (VincentHanquez)
00:09:54 * hackagebot cmaes 0.2.2 - CMA-ES wrapper in Haskell  http://hackage.haskell.org/package/cmaes-0.2.2 (TakayukiMuranushi)
00:10:01 <bitemyapp> watermind: I don't see how that changes what I said.
00:10:03 <fragamus> Couldn't match expected type `()' with actual type `Char'
00:10:06 <fragamus> I can't gtok that
00:10:16 <bitemyapp> watermind: your intuition seems more or less right, Reader and Writer are the best places to experiment here
00:10:38 <watermind> bitemyapp: maybe it doesn't... I was not sure what you meant though so thought maybe I hadn't exlpained well
00:10:42 <bitemyapp> watermind: but it's uni-directional unless you want to explore a bialgebra or something. You'd need to plan ahead. I don't think you can do an arbitrary isomorphism.
00:11:13 <bitemyapp> comonad to monad transformer is all that's possible AFAIK
00:11:53 <watermind> right
00:13:14 <watermind> not sure if I understand why that's needed though
00:13:47 <watermind> cm a -> b   lives in the co-kliseli,   so lets name these arrows   a :->  b
00:13:53 <fragamus> @pl let chopper = nub . (tails <=< inits::[Char] -> [[Char]])
00:13:53 <lambdabot> (line 1, column 48):
00:13:53 <lambdabot> unexpected '>'
00:13:53 <lambdabot> expecting operator
00:13:53 <watermind> we have the arrows and the composition
00:14:14 <watermind> so then we could take that category and build a kliseli with a monad m
00:14:22 <fragamus> @pl let chopper = nub . (tails <=< (inits::[Char] -> [[Char]]))
00:14:22 <lambdabot> (line 1, column 49):
00:14:22 <lambdabot> unexpected '>'
00:14:22 <lambdabot> expecting operator
00:14:33 <watermind> so we get   arrows   a :-> m b
00:14:45 <watermind> and their kleisli composition
00:15:01 <watermind> so we have composition of cm a -> m b
00:15:32 <watermind> it appears to me that everything just works
00:16:01 <watermind> I was just wondering if in these cases there were some known simplifications and shortcuts or interesting results in general
00:16:14 <watermind> maybe laws mixing both
00:17:02 <bitemyapp> I'm not a good person to query here, my understanding and intuition is limited. I'm just a coder :)
00:18:08 <watermind> I'm somewhere in between :/
00:19:29 <watermind> I can digest quite a bit of category theory, but the only paper I found on this subject was one by Power, and it's a bit difficult to decode :/
00:19:54 <bitemyapp> watermind: http://comonad.com/reader/2011/monads-from-comonads/ is this article too easy?
00:25:09 <codygman> Can anyone help me figure out why this is running slowly: http://lpaste.net/99294 I have profiled it and see that it's allocating a lot of bytestrings. Should I use a csv stream and accumulate the count of the rows that way? I remember in the RWH chapter on profiling foldl' was used, but never really understood it fully.
00:25:45 <watermind> bitemyapp: thanks, I'll give it a look
00:27:22 <bitemyapp> codygman: if you don't actually need to retain the data in memory then a stream would make a lot more sense.
00:28:02 <codygman> bitemyapp: Ok, I thought that might be what the issue is. I'll work on converting it to use streams, shouldn't be too difficult.
00:28:48 <bitemyapp> codygman: I don't even necessarily mean that out of a sense of "OPTIMIZE MOAR", it just fits the semantics of what you're doing to do a lot better.
00:45:47 <MorehouseJ09> when I want to call a function with n+1 how do I avoid putting the parentheses?
00:46:09 <MorehouseJ09> `test (n+1)` -- how do i avoid those parentheses?
00:47:22 <pavonia> test $ n + 1
00:47:50 <pavonia> but that only works if there's no more code after n+1
00:47:56 <MorehouseJ09> what if I was using test (n+1) (n+2)
00:48:11 <pavonia> you have to use parentheses then
00:48:12 <MorehouseJ09> no other way around it i guess then eh?
00:48:17 <MorehouseJ09> pavonia: cool cool thanks
00:48:58 <pavonia> Are these difficult to type on your keyboard or why do you want to avoid them?
00:49:33 <supki> > let n = 4; test = (+) in n + 1 & test $ n + 2
00:49:34 <lambdabot>  11
00:49:58 <pavonia> :t (6)
00:49:58 <lambdabot> Num a => a
00:50:01 <pavonia> :t (&)
00:50:02 <lambdabot> a -> (a -> b) -> b
00:50:20 <pavonia> lenses again, I guess?
00:54:53 <Aetherspawn> lens 4 came out!
00:55:51 <bitemyapp> Aetherspawn: yep! give it a year and nobody will actually write Haskell anymore, too low-level. :)
00:59:27 <Aetherspawn> heh
01:06:50 <johannesbodannes> AUGH everyone using lens
01:06:51 <johannesbodannes> this is madness
01:08:45 <Cale> johannesbodannes: ?
01:09:17 <johannesbodannes> i scroll up and #haskell is full of lens-related questions
01:10:06 <makalu> yesterday there was a period when people argued about Mercury which has nothing to do with Haskell :)
01:10:09 <Cale> I don't see too many, but it's a popular library
01:10:31 <makalu> discussed rather than argued
01:11:02 <dpwright> I'm trying to get to grips with parsec and I think I'm doing it wrong...
01:11:11 <Aetherspawn> does lens do anything to performance
01:11:16 <Aetherspawn> either positively or negatively?
01:11:31 <dpwright> there are "try"s all over the place and I'm running out of memory trying to parse simple input
01:11:36 <Aetherspawn> ie, does it produce a situation where types start carrying around extra information or have more indirection or something
01:12:10 <MorehouseJ09> hmm ... I'm trying to wrap my head around lazy evaluation in haskell
01:12:14 <Cale> Aetherspawn: Depends on how you use it, but pretty much no
01:12:27 <MorehouseJ09> say I wrote a function to list every single file on my computer
01:13:02 <Cale> MorehouseJ09: The execution of I/O actions is separate from evaluation.
01:13:03 <MorehouseJ09> when I first access the list will it load the entire thing into memory, or would it continually keep seeking on the disk to fill it as I iterate through?
01:13:32 <Cale> MorehouseJ09: Though, there are some magic I/O actions which confuse that
01:13:55 <MorehouseJ09> Cale: ok, so I was thinking right. There really is no way to avoid getting the entire list in memory
01:13:58 <Aetherspawn> lazy IO is confusing
01:14:15 <Aetherspawn> I once wrote a server wrongly
01:14:22 <MorehouseJ09> Lets say I created a list ["~/Documents", "~/Programs", "~/Whatever"]
01:14:27 <Aetherspawn> and the behaviour seemed VERY random
01:14:45 <Cale> Aetherspawn: Yeah, for something like that, it's best to avoid it
01:15:31 <MorehouseJ09> If I loop through and listed the contents of each, would there be an efficient way to remove each of those lists from memory as soon as I'm finished before grabbing the next one?
01:15:32 <Cale> Lazy IO is pretty much good for the cases where you're processing one big file, or standard input.
01:15:54 <Cale> MorehouseJ09: Just make sure you're not carrying it around anymore
01:16:18 <Aetherspawn> well, for laziness sake, to avoid laziness (hehe)
01:16:19 <MorehouseJ09> Cale: say I'm using lazy io on a big long file
01:16:23 <Aetherspawn> I now just use pipes everywhere
01:16:37 <MorehouseJ09> it will only actually read the file as I get to the line right? Like line 5 won't be in memory until I am on the 5th iteration
01:16:43 <johannesbodannes> .MorehouseJ09: Yep!
01:17:01 <johannesbodannes> MorehouseJ09: this DOES cause a complication however
01:17:23 <Cale> MorehouseJ09: yeah, if you're using lazy IO, then the file gets read as you evaluate the resulting string
01:17:33 <MorehouseJ09> thanks
01:17:37 <MorehouseJ09> johannesbodannes: what complication?
01:17:41 <johannesbodannes> MorehouseJ09: since Haskell isn't done with the file in lazy IO until you've done going through everything -
01:17:57 <johannesbodannes> MorehouseJ09: the file remains "open" until you have "looked" at all of it
01:17:57 <Cale> johannesbodannes: Or it gets GCed.
01:18:08 <MorehouseJ09> johannesbodannes: everything will still be in memory at the end - yeah thats what I was thinking
01:18:15 <Cale> If the contents are GCed, the filehandle will also close
01:18:44 <Cale> MorehouseJ09: and no, the string may be garbage collected as soon as you're done processing each piece of it
01:19:06 <Cale> MorehouseJ09: If you're using String, that's a lazy linked list of 32 bit unicode Char values
01:19:33 <syllogismos> can someone explain the monad instance of ((->) r)
01:19:39 <johannesbodannes> MorehouseJ09: which is actually used less and less in favour of Text and Bytestring for obvious reasons ._.
01:19:41 <syllogismos> :k (->)
01:19:41 <lambdabot> * -> * -> *
01:19:51 <syllogismos> :k (->) r
01:19:51 <lambdabot> Not in scope: type variable `r'
01:20:01 <Cale> syllogismos: So, you have  return :: a -> (r -> a)
01:20:16 <Cale> which is just const
01:20:35 <MorehouseJ09> Cale: johannesbodannes makes sense. Though I need to read up a bit more on Text / Bytestring vs String later
01:20:36 <Cale> syllogismos: and  (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
01:20:46 <MorehouseJ09> thanks for the help tho
01:20:53 <codygman> I am unsure what instance the Csv.Streaming library is looking for. I'm also unsure how I would use 'parsedCsv' in a way that would allow ghc to infer its type: http://lpaste.net/99279
01:21:51 <Cale> or s/e/r/
01:22:15 <Cale> syllogismos: So, the idea is that "running" a function means applying it to the parameter of type r to which the whole function has been applied
01:22:18 <syllogismos> what is s/e/r
01:22:38 <Cale> oh, I mean substitute e for r in the previous
01:22:57 <syllogismos> ohh.. yeah i understood the type signature..
01:23:00 <Cale> (It's the same thing, I was just a little inconsistent)
01:23:40 <syllogismos> i m not moving forward from writing the type signature..
01:24:06 <Cale> So, (x >>= f) e = let v = x e in (f v) e
01:24:19 <Cale> Or equivalently,
01:24:33 <Cale> (x >>= f) e = f (x e) e
01:25:36 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
01:25:37 <lambdabot>  ("hello","olleh","HELLO")
01:25:48 <Cale> syllogismos: ^^ should give you an idea for what it does :)
01:26:14 <pavonia> codygman: 'a' is the type of your specific record in the CSV data
01:26:18 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
01:26:19 <lambdabot>  [5,7,10,25,32]
01:26:27 <syllogismos> is it called function application? ((->) r) if not what is it called
01:27:14 <Cale> Is what?
01:27:20 <Cale> The function monad?
01:27:25 <syllogismos> (->)
01:27:34 <Cale> That's the type constructor for functions
01:27:45 <Cale> (->) e  is usually called the reader monad or the function monad
01:28:05 <Cale> (if you're talking about the fact that it's a monad)
01:28:20 <syllogismos> its kind is * -> * right?
01:28:24 <codygman> pavonia: What if I don't care about the types? My end goal is just to lazily count the number of rows.
01:28:24 <Cale> Or if you're fancy, it's the covariant hom functor.
01:28:31 <Cale> yes
01:28:36 <Cale> :k (->)
01:28:37 <lambdabot> * -> * -> *
01:28:40 <Cale> :k (->) Integer
01:28:41 <lambdabot> * -> *
01:28:49 <Cale> The kind of every monad is * -> *
01:28:53 <Cale> :k Monad
01:28:54 <lambdabot> (* -> *) -> Constraint
01:28:57 <syllogismos> i dont fancy.. lol.. let me note your explanation in my notes.. its going upp
01:30:11 <pavonia> codygman: But you need to give a specific type so that the appropriate type instance can be selected. There's an instance [a] for FromRecord, maybe that will work
01:31:00 <codygman> pavonia: Oh! That's because of typeclasses right? I think I need to read up on them some more and implement some of my own...
01:32:02 <pavonia> codygman: yeah, they are used quite frequently
02:11:50 <merijn> Quick functor law question, doesn't "fmap (p . q) = (fmap p) . (fmap q)" follow automatically from "fmap id = id"?
02:13:03 <ivanm> maybe it's just to make it explicit?
02:13:32 <merijn> ivanm: Yes, that's what I was thinking, but I just wanted to confirm that suspicion before I sound like an idiot :)
02:14:09 <benj_> I'm willing to sound like an idiot, and I can blame it on not having finished my morning coffee yet. I can see how the latter follows from the former, but how does the former follow from the latter?
02:15:10 <lieven_> is there a handy shortcut for record a == record b disregarding field c?
02:15:55 <merijn> benj_: "fmap id = id" implies that fmap doesn't modify the structure
02:16:32 <merijn> benj_: The parametricity of fmap lets us see that if 'p' change the type inside the functor, so the function *has* to be applied to type check
02:16:56 <merijn> benj_: If structure is preserved and the function *is* applied, then clearly fmapping two functions in a row must have the same result as fmapping in one go
02:17:22 <merijn> As the only way "fmap (p.q)" could differ from "fmap p . fmap q" is if more fmaps results in a change of structure
02:17:29 <merijn> Which is explicitly disallowed by "fmap id = id"
02:17:43 <tdammers> it's not immediately obvious though that fmap id = id implies fmap (p . q) = (fmap p) . (fmap q)
02:18:27 <merijn> tdammers: Sure, I can understand it is a clarification. But I'm trying to be technically correct in some text I'm writing
02:18:43 <merijn> tdammers: So I just wanna make sure I separate "clarification" from "actual required law"
02:18:52 <tdammers> of course
02:19:16 <tdammers> I'd actually think they're equivalent
02:20:11 <tdammers> because if you substitute id for q, you get fmap (p . id) = fmap p . fmap id <=> fmap p = fmap p . fmap id
02:20:26 <tdammers> <=> id = fmap id
02:20:28 <tdammers> qed
02:21:09 <jle`> would you not lose generality
02:21:13 <merijn> btw, do the laws have actual names?
02:21:18 <jle`> by subsituting id for q
02:22:00 <merijn> jle`: No, because of parametricity fmap can't special case id to be different from an arbitrary q
02:22:23 <jle`> ah.
02:22:52 <merijn> hmm, the wikibook explicitly lists the composition as "the second law", so now I'm filled with doubt :(
02:23:17 <Hafydd> It's an appealing intuitive explanation, but I'd like to see a formal proof.
02:24:53 <Hafydd> Maybe there's a setting more general than Haskell programs in which it doesn't hold.
02:25:30 <merijn> Hafydd: Me too, hence the question :)
02:30:25 <xy124> hi guys i have a short question: why this(http://lpaste.net/99298) function does not compile in ghci.
02:31:31 <jle`> xy124: you might need parentheses around (a,b):(c,d):xs
02:31:40 <ivanm> that'd be it
02:31:57 <ivanm> and around ((a,b):xs)
02:32:01 <ivanm> and similarly for the next line
02:32:11 <ivanm> and the next, or you could just use [(a,b)]
02:32:29 <merijn> The correct parentheses would be: ((a,b):(c,d):xs)
02:32:32 <jle`> it is an exceptionally unhelpful error message
02:32:41 <ivanm> jle`: not particularly
02:32:58 <ivanm> maxPairs = fst . maximumBy (compare `on` snd) . map (\pair@(a,b) -> (pair,a+b))
02:33:19 <merijn> xy124: Like in function bodies it treats the ':' as infix operators, causing "foo x:xs" to parse as "(foo x):xs", hence why you need to write "foo (x:xs)"
02:33:33 <ivanm> though that error looks like it isn't for that version of code... note line 16 has square brackets...
02:33:48 <ivanm> jle`: so the error message doesn't help as much because it's for different code :p
02:34:07 <jle`> that might explain a lot heh.
02:34:09 <bernalex> so everyone keeps saying that doing if then else is not idiomatic. but what if you have e.g. foo <$> (expression) >>= mapM_ putStrLn? is case still preferable to if-then-else?
02:34:13 <jle`> i thought ghc was adding implicit brackets or something
02:34:32 <ivanm> bernalex: if-then-else shouldn't be nested, but for short things (especially in a do block) it's fine
02:34:50 <jle`> expression >>= mapM_ (putStrLn . f)
02:34:52 <bernalex> ivanm: OK
02:35:06 <jle`> does that work? maybe not.
02:35:12 <ivanm> jle`: yeah, that's a bit nicer
02:35:39 <ivanm> jle`: actually, maybe it needs to be expression >>= mapM_ putStrLn . foo
02:35:44 <jle`> yeah
02:35:48 <jle`> was thinking that
02:36:01 <jle`> it might make more sense as
02:36:09 <jle`> mapM_ putStrLn . foo =<< expression
02:36:16 <jle`> so your eyes don't jump back and forth so much
02:38:11 <jle`> or expression >>= foo & mapM_ putStrLn ?
02:39:47 <ivanm> jle`: I'm not sure of the fixity of &
02:39:57 <xy124> still not working: http://lpaste.net/99298 the numbers 30 to 34 are the linenumbers from vi the errormessage beneath belongs to
02:41:02 <jle`> xy124: lines 32 and 33
02:41:07 <FireFly> maxpairs (a,b):xs   is   (maxpairs (a,b)):xs
02:41:18 <jle`> remember that function application always binds tighter than any operator
02:41:20 <jle`> ever
02:41:23 <jle`> forever
02:41:32 <FireFly> It takes a bit to get used to :)
02:41:40 <xy124> ahhh ok got it
02:41:47 <jle`> i still get tripped up by things like sin (0.5)**2
02:41:50 <jle`> heh
02:41:56 <merijn> The rules of precedence are: operators follow fixity (precedence 0-9), function application has precedence 10, record syntax has precedence 11
02:42:29 <merijn> (high == binds tighter)
02:43:06 <jle`> pemdasbcfgh
02:43:14 <jle`> i
02:43:58 <jle`> i wonder if there are commonly used operators of every fixity
02:44:04 <tdammers> 10 has always struck me as a remarkably arbitrary number of precedence levels...
02:44:11 <jle`> so we can make a pemdas-like mnemonic
02:44:50 <jle`> i don't think you can decide on anything that isn't particularly arbitrary
02:44:57 <b_jonas> merijn: how about the @ sign in patterns?
02:45:18 <merijn> b_jonas: Good question, I dunno, but they don't seem to need parenthesis usually
02:45:29 <tdammers> apparently not, but most other things in Haskell aren't arbitrary
02:45:56 <tdammers> operator precedence just seems somewhat sloppy in comparison
02:45:58 <b_jonas> tdammers: it's 10 because all 10 levels are used by operators in the haskell standard and they didn't add any more levels for users
02:46:26 <tdammers> it's not really an elegant solution IMO
02:46:41 <jle`> i...don't think we can compare patterns to operator/function application
02:46:51 <Aetherspawn> So
02:47:00 <Aetherspawn> atomicModifyIORef is fast and lockless?
02:47:22 <merijn> Aetherspawn: It's not lockless
02:47:38 <tdammers> I don't think it can be, really
02:47:53 <Aetherspawn> okay
02:47:57 <Aetherspawn> what about just modifyIORef' ?
02:48:01 <merijn> tdammers: Well, if you do atomic swap then it'd be lockless (or rather have locking in hardware)
02:48:08 <b_jonas> jle`: we sure can. the pattern (A b@(C d) e) means ((A (b@(C d))) e) as opposed to (A (b@((C d) e))) because the at sign has higher precedence than function application
02:48:17 <Aetherspawn> GHC doesn't do that, though, does it?
02:48:17 <tdammers> merijn: but that won't work for arbitrary update functions
02:48:54 <tdammers> merijn: not without risking race conditions anyway
02:49:03 <merijn> tdammers: Probably? Hard to say
02:49:15 <bernalex> is there a neat way to call a function "bar foo" instead of "foo bar", where foo is the function and bar is the ragument
02:49:46 <tdammers> merijn: well, either locking, or merging with reject-and-retry on conflict
02:49:58 <jle`> bernalex: there's the (&) operator from lens...but...
02:50:10 <bernalex> ah
02:50:58 <tdammers> :t flip ($)
02:50:59 <lambdabot> b -> (b -> c) -> c
02:51:23 <t7> @djinn a -> (a -> b) -> b
02:51:23 <lambdabot> f a b = b a
02:51:23 <bernalex> tdammers: that's true
02:51:41 <t7> @pl f a b = b a
02:51:41 <lambdabot> f = flip id
02:51:56 <bernalex> tdammers: isn't that exactly what & does?
02:52:10 <tdammers> idk, haven't used (&) before
02:52:21 <tdammers> need didn't arise
02:52:22 <jle`> > flip ($) 4 (*2)
02:52:23 <lambdabot>  8
02:52:38 <bernalex> > & 4 (*2)
02:52:39 <jle`> > (flip ($)) 4 (*2)
02:52:40 <lambdabot>  <hint>:1:1: parse error on input `&'
02:52:40 <lambdabot>  can't find file: L.hs
02:52:44 <t7> if you use flip id you save a character !
02:52:56 <jle`> > flip id 4 (*2)
02:52:58 <lambdabot>  8
02:53:00 <jle`> > 4 & (*2)
02:53:02 <lambdabot>  8
02:53:24 <t7> @src (&)
02:53:24 <lambdabot> Source not found. Where did you learn to type?
02:53:34 <jle`> if only you can use partially applied functions as infix
02:53:37 <t7> fu lambdabot
02:53:47 <jle`> 4 `flip id` (*2)
02:53:52 <tdammers> let ($-) = flip ($) in 3 $- (+1)
02:53:53 <bernalex> & = flip $
02:54:03 <tdammers> > let ($-) = flip ($) in 3 $- (+1)
02:54:04 <lambdabot>  4
02:54:33 <t7> bernalex: if & is a lens thing its probably a bit more involved
02:55:16 <FireFly> No, that's the definition IIRC
02:55:31 <jle`> http://hackage.haskell.org/package/lens-4.0/docs/src/Control-Lens-Lens.html#%26
02:55:40 <jle`> a & f = f a
02:56:00 <tdammers> my guess would be that the type signature is mind blowing, but the definition is utterly simple
02:56:02 <bernalex> https://twitter.com/HaskellTips/status/428908883722006528
02:56:20 <jle`> (&) :: a -> (a -> b) -> b
02:56:24 <bernalex> t7: ^ is what I'm basing my assumption on
02:56:44 <ivanm> FireFly: with the same fixity?
02:56:53 <ivanm> there's also # from diagrams IIRC
02:57:17 <t7> oh wow
02:58:39 <Aetherspawn> The thing I find appealing about STM is it can get really busy, but it won't spin forever.
02:58:51 <ivanm> Aetherspawn: it _can_...
02:58:59 <Aetherspawn> stack overflow says this
02:59:03 <ivanm> but it's generally harder to get it to do so
02:59:06 <Aetherspawn> "he STM implementation is guaranteed to make progress. One specific transaction can get stuck, not all transactions simultaneously. Somebody has to be making progress."
02:59:06 <FireFly> ivanm: I think so, yes
02:59:24 <ivanm> simon marlow had an example in his new-ish book IIRC
03:33:45 <kqr> i have a more general question about designing good haskell code. it's a little longer so i've posted it here: http://www.reddit.com/r/haskell/comments/1wliai/reading_about_haskell_design_patterns/
03:33:49 <kqr> thankful for any thoughts
03:39:39 <blueonyx> @where typeclassopedio
03:39:39 <lambdabot> I know nothing about typeclassopedio.
03:39:43 <blueonyx> @where typeclassopedia
03:39:43 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
03:39:48 <blueonyx> kqr: ^
03:41:27 <danilo2> Hello! Does anybody know where can I find 7.8 release logs? They were available on track some time ago but I cannot find them now - this is the file with listoof new things
03:42:39 <kqr> blueonyx, i'm working my way through it! but it's not all that much about examples of real world usage and more an explanation of how they work
03:45:17 * hackagebot linux-inotify 0.2.0.0 - Thinner binding to the Linux Kernel's inotify interface  http://hackage.haskell.org/package/linux-inotify-0.2.0.0 (LeonSmith)
03:46:05 <supki> danilo2: http://jsfiddle.net/zmV9D/embedded/result/ this?
03:46:44 <danilo2> supki: yes! Thank you. How can I find this in trac? (not to ask again in future?)
03:47:19 <supki> no idea, I've consulted web browser's history to find the link
03:47:24 <danilo2> supki: it seems it is removed from track
03:47:47 <danilo2> supki: thank you very very much!
03:49:08 <syllogismos> :i do
03:49:19 <syllogismos> :i (<-)
03:49:29 <syllogismos> :t (<-)
03:49:30 <lambdabot> parse error on input `<-'
03:50:41 <kqr> syllogismos, do and <- is special syntax that gets desugared to >>=
03:51:07 <syllogismos> okay..
03:51:31 <Aetherspawn> wow thats not intuitive at all..
03:51:31 <danilo2> By the way - is it a way to write in haskell such instances: "instance X a a" and "instance X a b" - the first one will be used for the same typesd and the second for distinct. I remember maybe it oculd be written using type families - am I right?
03:51:53 <Aetherspawn> things like Data.Set at first seem to be missing different directional folds and such like foldl, foldr, foldl1, foldMap etc
03:52:08 <Aetherspawn> they actually are implemented in the instance of Data.Foldable, but not in Data.Set
03:52:27 <Aetherspawn> so you have to import Data.Foldable to use them and use a different qualified import ...
03:53:03 <Aetherspawn> That would make a whole lot more sense if the Prelude folds were imported from Data.Foldable, but they aren't.
03:53:38 <syllogismos> do a <- am; f <- fm; return f a
03:54:30 <syllogismos> how i write the above statement using >>=
03:54:40 <syllogismos> and return
03:55:47 <syllogismos> i know its an applicative.. but im trying to implement it using bind and return..
03:55:50 <kqr> syllogismos, am >>= (\a -> fm >>= (\f -> return f a))
03:56:10 <kqr> syllogismos, whenever you have a <- am you can replace it with am >>= (\a -> ...)
03:56:13 <Axman6> well, it doesn't type check, but ma >>= \a -> mf >>= \f -> return (f a) would work
03:56:59 <kqr> Aetherspawn, just as (.) and map from the prelude should be implemented in terms of fmap? ;)
03:57:08 <syllogismos> thank you. i rememeber reading it.. i forgot..
03:57:23 <Aetherspawn> well, I certainly don't disagree! :)
03:57:36 <Aetherspawn> this is all sparked by the thing on reddit to do with qualified regions by the wya
03:57:39 <Aetherspawn> *way
04:00:04 <kqr> Aetherspawn, as you probably know, (.), map and the folds are specialised in the prelude because it gives newbies nicer error messages
04:00:19 * hackagebot filecache 0.2.4 - A Linux-only cache system associating values to files.  http://hackage.haskell.org/package/filecache-0.2.4 (SimonMarechal)
04:00:29 <kqr> Aetherspawn, if you want to, you can always import Prelude hiding (foldr, foldl); import Foldable (foldr, foldl)
04:00:40 <kqr> Aetherspawn, or use one of the preludes that already do that
04:01:08 <Aetherspawn> heh
04:01:11 <Aetherspawn> that's why we can't have nice things
04:01:12 <Aetherspawn> qq
04:01:43 <supki> I think 7.10 is going to have Foldable in Prelude?
04:01:45 <supki> (finally)
04:01:55 <Aetherspawn> really?
04:02:21 <Aetherspawn> I'm unsure if foldM and all that are automatically implemented in terms of foldables
04:02:22 <supki> yeah, there is a thread in libraries@
04:02:25 <Aetherspawn> but that'd be nice too
04:02:34 <Aetherspawn> because LOTS of devs NEVER implement *M variants of functions
04:02:40 <Aetherspawn> and its really quite inconvenient.
04:03:05 <Aetherspawn> I always have to break out Control.Monad.Loops ;)
04:03:22 <Aetherspawn> or sequence
04:03:56 <randomclown> just maybet?
04:04:04 <Aetherspawn> Ah, yes, *M are implemented in Data.Foldable automatically. Great success!
04:05:19 * hackagebot arb-fft 0.2.0.1 - Pure Haskell arbitrary length FFT library  http://hackage.haskell.org/package/arb-fft-0.2.0.1 (IanRoss)
04:05:21 * hackagebot language-puppet 0.11.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.11.1 (SimonMarechal)
04:38:39 <Aetherspawn> supki: wheres that thread?
04:38:41 <Aetherspawn> I couldn't find it.
04:41:55 <supki> I think it started as 2137th thread about adding whenJust somewhere
04:41:57 <supki> let me find it
04:43:01 <supki> that's it: http://www.haskell.org/pipermail/libraries/2013-May/019902.html
04:49:27 <Aetherspawn> "On more than one occasion I've explained to a beginner confused by the
04:49:28 <Aetherspawn> difference between map and fmap that the sole reason they differ is to
04:49:29 <Aetherspawn> avoid confusing beginners. Doubleplus ungood, my friends."
04:49:42 <Aetherspawn> I feel like an idiot, but I didn't know these were the same thing until today
04:49:50 <Aetherspawn> and I've been using haskell for about a year.
04:50:31 <bennofs> Aetherspawn: map is more specific than fmap
04:50:39 <bennofs> :t map `asTypeOf` fmap
04:50:40 <lambdabot> (a -> b) -> [a] -> [b]
04:51:02 <Aetherspawn> :t map
04:51:03 <Aetherspawn> :t fmap
04:51:03 <lambdabot> (a -> b) -> [a] -> [b]
04:51:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:51:09 <bennofs> [] is a functor
04:51:37 <Aetherspawn> The proposed change for pulling in Data.Functor and Data.Foldable into Prelude instead of map/foldl/foldr etc
04:51:45 <Aetherspawn> is a really good one imo
04:59:33 <AshyIsMe> woo!
04:59:40 <AshyIsMe> got some code to turn the vindinium board into a graph
04:59:55 <AshyIsMe> next up some actual shortest path finding code
05:00:01 <dv-> Aetherspawn: wouldn't it make warnings/errors much uglier?
05:02:27 <Aetherspawn> dv-: the point being argued is that the current Prelude is like training wheels
05:02:50 <Aetherspawn> and it could be more powerful by throwing away the pretty types factor
05:09:26 <blueonyx> can someone help me with http://lpaste.net/99303?
05:12:27 <int-e> blueonyx: there is an instance, MonadResourceBase m => MonadHandler (HandlerT site m) (and a similar one for WidgetT), and MonadResourceBase m includes MonadBaseControl IO m. So it looks like ghc knows it's one of those and then simplifies the constraints.
05:14:27 <int-e> @type \a b -> (a,b) == (a,b) -- a very simple example of the same phenomenon: Note that the context is not Eq (t,t1).
05:14:28 <lambdabot> (Eq t, Eq t1) => t -> t1 -> Bool
05:15:32 <int-e> Instead the context is simplified using the (Eq a, Eq b) => Eq (a,b) instance of the Eq class.
05:19:10 <blueonyx> int-e: so i should add MonadBaseControl IO m and use FlexibleContexts?
05:20:27 <int-e> blueonyx: I guess you should add MonadResourceBase m.
05:21:35 <blueonyx> this gives:  Illegal tuple constraint: MonadResourceBase m
05:21:35 <blueonyx>       (Use -XConstraintKinds to permit this)
05:22:12 <int-e> hmm, right. type MonadResourceBase m = (MonadBaseControl IO m, MonadThrow m, MonadUnsafeIO m, MonadIO m, Applicative m)
05:22:20 <benzrf> i think I get the basics of lenses/prisms/traversables
05:22:27 <benzrf> dang this is pretty sweet
05:22:32 <benzrf> @src view
05:22:33 <lambdabot> Source not found.
05:22:39 <benzrf> screw you too
05:22:44 <benzrf> @src set
05:22:44 <lambdabot> Source not found. stty: unknown mode: doofus
05:22:51 <int-e> blueonyx: I'm just afraid that once you add  MonadBaseControl IO m  it'll complain about missing MonadThrow m, and so on.
05:23:14 <t7> lenses: because i think haskell needs more scala size type signatures
05:23:23 <blueonyx> int-e: it doesnt
05:23:29 <int-e> Meh. I should remove those insults from @src.
05:23:44 <int-e> blueonyx: ok.
05:24:37 <blueonyx> int-e: with (MonadBaseControl IO m, MonadHandler m) that is
05:25:38 <int-e> blueonyx: ah. MonadHandler implies all the rest. Nice!
05:25:55 <int-e> (I'm not familiar with yesod, I'm merely browsing the haddocks.)
05:29:42 <benzrf> if yesod is the Rails of haskell
05:29:45 <benzrf> what's sinatra?
05:31:21 <blueonyx> benzrf: http://www.haskell.org/haskellwiki/Web/Frameworks miku & scotty
05:33:17 <blueonyx> int-e: but MonadHandler doesnt help, bc IO has no MonadHandler instance xD
05:34:03 <benzrf> thanks blueonyx
05:34:26 <AshyIsMe> so i have a Tree of Ints, how do i "map" show across each node so that it becomes a Tree String ?
05:34:29 <AshyIsMe> http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-Tree.html#t:Tree
05:34:35 <AshyIsMe> using that Tree
05:34:58 <bennofs> AshyIsMe: use fmap from the Functor class (Tree is an instance of Functor)
05:35:12 <bennofs> @ty fmap :: (a -> b) -> Tree a -> Tree b
05:35:13 <lambdabot> (a -> b) -> Tree a -> Tree b
05:36:21 <AshyIsMe> ah sweet, cheers
05:36:51 <AshyIsMe> also, drawTree now is just outputting a string on one line with \n visible within it
05:36:57 <AshyIsMe> instead of splitting across lines
05:37:16 <bennofs> AshyIsMe: are you using it from GHCi? If yes, try putStrLn . drawTree $ yourTree
05:38:24 <AshyIsMe> ah putStrLn fixed that, cheers
05:47:52 <vikraman> >>> forall $ \tuple -> view _1 tuple == fst tuple
05:47:57 <vikraman> what is forall here ^^ ?
05:48:15 <AshyIsMe> :t forall
05:48:16 <lambdabot>     Not in scope: `forall'
05:48:16 <lambdabot>     Perhaps you meant `forAll' (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
05:48:26 <AshyIsMe> :t forAll
05:48:27 <lambdabot> (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
05:48:48 <AshyIsMe> that's probably not it haha
05:48:50 <vikraman> >>> forall $ \tuple -> view _1 tuple == fst tuple
05:48:51 <vikraman> True
05:48:52 <enthropy> vikraman: probably it's defined locally?
05:49:01 <vikraman> it's in the tutorial: https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
05:49:18 <vikraman> I know I could write quickCheck $ \tuple -> view _1 tuple == fst tuple
05:50:44 <vikraman> but forall returns True, which is curious
05:51:06 <enthropy> it's a bad function name to use, since it gets stolen when you enable some extensions
05:51:43 <vikraman> yes, but is it even possible to write such a function?
05:52:01 <exicer> Any suggestions on when to use exceptions vs using Maybe/something ?
05:52:42 <AshyIsMe> so i've got a graph of vertices and i'd like to find the shortest path between 2 vertices
05:52:46 <AshyIsMe> im looking here: http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-Graph.html#g:5
05:52:47 <supki> vikraman: it seems  forall = forAll arbitrary
05:52:58 <blueonyx> exicer: http://www.haskell.org/haskellwiki/Error_vs._Exception
05:53:23 <AshyIsMe> dfs g [myStartVert]  -- that seems to give me a forest of all the verts i can reach from myStartVert
05:53:56 <AshyIsMe> i guess i need to figure out how to traverse a forest
05:54:48 <dareTake> Hi, I have a doubt abt Writer. What does (<-) give out as a result, for a Writer w a. Is it a or (a ,w)?
05:55:04 <enthropy> anybody know if there's some TH for pattern matching on JSON and/or aeson's Object = HashMap Text Value? http://hackage.haskell.org/package/dead-simple-json-0.1.2 is kind of close, but there are no patterns there
05:55:18 <int-e> exicer: Perhaps a good guideline is "if the question arises, use Maybe". Slightly more formally, if a function has a precondition that is hard to verify statically, then it should return Maybe or something; that leaves partial functions like 'head' which people disagree about quite a lot.
05:56:11 <heatsink> dareTake, if foo has type Writer w a, then do {x <- foo; ...} will put the result of type 'a' into x
05:56:14 <vikraman> > forAll arbitrary $ \x -> id x == x
05:56:15 <lambdabot>  No instance for (GHC.Show.Show Test.QuickCheck.Property.Property)
05:56:16 <lambdabot>    arising from a use of `M397710695148349401032725.show_M3977106951483494010...
05:56:16 <lambdabot>  Possible fix:
05:56:16 <lambdabot>    add an instance declaration for
05:56:16 <lambdabot>    (GHC.Show.Show Test.QuickCheck.Property.Property)
05:56:28 <exicer> int-e: Hm. So in my specific case it is for parsing POST data on a server. If it is malformed, I can either raise an exception or think of it as Maybe Data.
05:56:46 <dareTake> ah k, how is it implemented? I browsed through the source but could not find out how.
05:57:10 <exicer> I guess I feel that using Maybe is more explicit in what I'm doing, but conversly using an exception would require me to write less :p
05:57:12 <heatsink> dareTake, the implementation is in the return and (>>=) methods of writer
05:57:16 <heatsink> @src Writer
05:57:17 <lambdabot> Source not found. That's something I cannot allow to happen.
05:58:01 <dareTake> instance (Monoid w, Monad m) => Monad (WriterT w m) where
05:58:02 <dareTake>     return a = writer (a, mempty)
05:58:02 <dareTake>     m >>= k  = WriterT $ do
05:58:02 <dareTake>         ~(a, w)  <- runWriterT m
05:58:02 <dareTake>         ~(b, w') <- runWriterT (k a)
05:58:02 <dareTake>         return (b, w `mappend` w')
05:58:07 <dareTake>     fail msg = WriterT $ fail msg
05:58:20 <heatsink> http://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-Writer-Lazy.html
05:58:31 <dareTake> type Writer w = WriterT w Identity
05:58:51 <heatsink> Don't paste large pieces of code into the chat.
05:59:01 <dareTake> Seeing the source it seems to me that it return a tuple
05:59:06 <int-e> exicer: Well, since you ask, you shouldn't use exceptions for that.
05:59:08 <dareTake> oh sorry
05:59:33 <exicer> int-e: That was my feeling. Thanks!
05:59:35 <enthropy> vikraman: probably something like: fmap (\x -> case x of Success {} -> True; _ -> False) $ quickCheckWithResult stdArgs{chatty=False} $ \x -> x == not x
05:59:39 <heatsink> You can see how monad <- works for Writer in the definition of m >>= k
05:59:54 <heatsink> First it runs m and binds the result to (a, w)
06:00:10 <heatsink> That's the result value, a, and the things that were written, w
06:00:22 <heatsink> Then it passes a to k
06:00:41 <vikraman> enthropy: yes, I agree that would be one way to do it ;p
06:01:22 <dareTake> but doesn't the return statement return a tuple?
06:01:56 <dareTake> and (<-) takes it out of the context?
06:02:55 <heatsink> Remember, this monad instance is defining the behavior of WriterT w m in terms of m
06:03:15 <heatsink> The do notation here is computing things in the monad m
06:03:20 <heatsink> not in the monad WriterT w m
06:04:02 <heatsink> so you need to keep track of what belongs to the lower layer of abstraction, m, and the higher layer, WriterT w m
06:05:15 <dareTake> ok, so when we run the code, it is in the context of Writer.
06:05:29 <heatsink> yes
06:05:41 <heatsink> When you do return () in WriterT w m, you see the return value () in the writer monad.  Internally, it returns ((), mempty) in the monad m.
06:06:01 <dareTake> yep but it's a tuple
06:07:17 <dareTake> > (return 4) :: Writer String Int
06:07:18 <heatsink> What does it being a tuple tell you?
06:07:18 <lambdabot>  No instance for (GHC.Show.Show
06:07:18 <lambdabot>                     (Control.Monad.Trans.Writer.Lazy.Writer
06:07:18 <lambdabot>                        GHC.Base.String GHC.Types.Int))
06:07:18 <lambdabot>    arising from a use of `M6141615773136150986640.show_M6141615773136150986640'
06:07:18 <lambdabot>  Possible fix:
06:07:43 <heatsink> It's not a showable value
06:08:09 <heatsink> > runWriter (return 4) :: (Int, String)
06:08:10 <lambdabot>  (4,"")
06:08:46 <heatsink> > runWriter (do {x <- return "hello"; return (x ++ " world")} :: (String, String)
06:08:48 <lambdabot>  <hint>:1:80:
06:08:50 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
06:08:55 <heatsink> > runWriter (do {x <- return "hello"; return (x ++ " world")}) :: (String, String)
06:08:56 <lambdabot>  ("hello world","")
06:09:08 <dareTake> that it has two values, an a and a monoid value
06:09:33 <heatsink> What specifically has two values?
06:09:45 <dareTake> the writer monad
06:09:53 <heatsink> Note in the example above, x gets the value "hello", which is not a tuple
06:09:57 <dareTake> i mean the value returned by return
06:10:49 <dareTake> heatsink, I understand it, but my question is where is it specifically
06:11:10 <dareTake> the code that ignores value in the second part of the tuple
06:11:28 <heatsink> That's in the definition of (>>=)
06:11:52 <t7> i didnt know it was hoare who invented null references :O
06:12:24 <dareTake> the code, return (b, w `mappend` w') in the definition of (>>=) doesn't it run return on a tuple?
06:13:32 <heatsink> When you write do {x <- foo; bar}, it desugars into foo >>= (\x -> bar)
06:13:41 <dareTake> and when you take out using (x <- Writer Tuple), how do you get a but not  just Tuple
06:14:01 <dareTake> er just /= Just :)
06:14:21 <heatsink> So when you want to figure out what value x gets, what part of (>>=) should you look at?
06:14:26 <piezoid> dareTake: return a = Writer (a, mempty) ; (Writer (a, m)) >>= f = let (b, m') = runWriter (f a) in (Writer (b, m `mappend` m'))
06:16:40 <dareTake> (b, v `mappend` v')
06:17:12 <heatsink> That's not the relevant part.  That part is combining the results from both statements.
06:17:28 <heatsink> You want to figure out what value x gets in the lambda expression (\x -> bar), so you need to look at what argument is passed to that lambda expression.
06:17:51 <heatsink> So we can look at the definition of m >>= k, and see what argument is passed to k
06:17:54 <heatsink> Are you with me?
06:17:59 <dareTake> wait WriterT definition?
06:18:03 <heatsink> yes
06:18:59 <dareTake> newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }
06:19:26 <heatsink> I mean the definition of >>= for WriterT
06:19:38 <piezoid> WriterT is a little bit more complex, because it have to chain the effects of the inner monad
06:19:42 <heatsink> in the Monad instance you were looking at
06:20:21 <constantius> ?src fromJust
06:20:21 <lambdabot> fromJust Nothing  = undefined
06:20:21 <lambdabot> fromJust (Just x) = x
06:21:19 <dareTake> I probably should try more code. I'm confused atm though.
06:21:38 <heatsink> It's okay, monad transformers take a while to get used to
06:21:39 <dareTake> because we are in the definition of (>>=) of WriterT
06:21:45 <heatsink> yes
06:21:48 <dareTake> wait transformers?
06:21:59 <dareTake> ok new concept :D
06:22:10 <heatsink> WriterT is a monad transformer.  Writer is a monad, and its definition uses WriterT.
06:22:27 <heatsink> Rather, WriterT w is a monad transformer, and Writer w is a monad
06:22:39 <dareTake> kk, I was just working through the example of Wrtier in LYAH
06:22:57 <dareTake> I'd probably understand it later. Thnx for sticking with me
06:23:08 <piezoid> ma >>= f : first unwrap with runWriterT on ma, "bind" ma to get (a, w), runWriterT and bind (f a) to get (b, w'), then combine and rewrap to get WriterT m (v, w `mappend` w')
06:23:37 <heatsink> Writer was originally defined separately.  It was later refactored to use WriterT.
06:24:15 <piezoid> but it's a good exercice to write your own simple Writer monad
06:24:43 <dareTake> k will do, once I get a good grasps of all the common abstractions.
06:24:44 <heatsink> Feel free to ask more questions
06:30:33 <piezoid> i can see how Cartesian Categories are related to Arrows
06:30:53 <piezoid> but i guess i have to remove some laws to allow proper sequencing of effects ?
06:32:20 <Cheery> hi haskell troopers
06:32:51 <Cheery> is anyone of you able to prove that static typing improves maintainability in a project.
06:33:03 <Cheery> ?
06:33:18 <Cheery> compared to no type labels at all.
06:33:19 <heatsink> Is anyone able to prove that static typing harms maintainability in a project?
06:33:57 <heatsink> There have been a few studies, but it's hard to make controlled, repeatable experiments at the scope of a large-scale project
06:34:10 <heatsink> And it doesn't matter very much on toy projects
06:35:06 <Cheery> heatsink: it also doesn't matter if the study data is pure fiction made by the studying group.
06:35:26 <Cheery> http://pleiad.dcc.uchile.cl/papers/2012/kleinschmagerAl-icpc2012.pdf
06:35:31 <Cheery> as it was there
06:36:59 <Cheery> heatsink: I think there's several reasons to avoid type labels in code, when they are not needed.
06:37:43 <Cheery> if they are stating the obvious, you should avoid them.
06:37:54 <Cheery> similar how you do not describe what code does with the comments.
06:38:07 <Cheery> it's just ugly and wrong.
06:38:18 <Cheery>  /* read from file descriptor */
06:38:21 <lilred> I'm tired of being in school :(
06:38:21 <Cheery> read(fd, buf, count)
06:39:42 <Cheery> heatsink: if for all programs this is true, then static typing is excessive
06:39:49 <Cheery> if it is excessive, it doesn't belong there.
06:40:43 <Cheery> also nonexisting type labels do not need to be updated, when type changes for some reason.
06:40:45 <akegalj> Cheery: thnx for the paper
06:40:57 <heatsink> It's called type inference when code is written, but not types.
06:41:09 <heatsink> There is also proof search, where you write the types but not the code.  Some programming languages do that.
06:41:14 <bartavelle> "when types change for some reason" breaks your program :)
06:41:37 <bartavelle> so it's pretty nice to have to pay attention
06:43:47 <Cheery> also, even in haskell type checking is just an error filter of sort.
06:43:56 <piezoid> static constrained polymorphism let you specify and the range of types, and check at compile time if they matches
06:43:59 <Cheery> it filters out certain classes of errors
06:44:03 <Cheery> not all of them
06:44:09 <bartavelle> Cheery, yes, and it's pretty nice
06:44:26 <bartavelle> it filters a *large* number of errors in my case
06:44:50 <piezoid> python's issubclass style makes me sick
06:44:58 <bartavelle> Also type signature are not like useless comments. They are unambiguous and true.
06:45:14 <piezoid> it's hard to recover type safety from dynamic typing
06:45:18 <bartavelle> comments can be outdated, can have no meaning, or be plain malicious
06:45:36 <Cheery> bartavelle: once you get the errors filtered out, do you repeat them? That is does haskell detect tons of errors in code you create fresh out?
06:45:55 <heatsink> Formal methods are the only programming technique for filtering out all errors, and it's extremely expensive to develop that way
06:46:51 <Cheery> bartavelle: if you eventually drop the error count detected at runtime to nil, it means that the whole error checking worked as a helping wheels for you.
06:47:21 <Cheery> it means that you learned to avoid type errors yourself
06:47:27 <bartavelle> well, I am just human
06:47:37 <bartavelle> also what about code I don't write ?
06:47:41 <bartavelle> when a library API changes
06:48:03 <Cheery> semantic version number increases, depending on the nature of the API change.
06:48:08 <bartavelle> yes
06:48:13 <bartavelle> now how do you know what broke ?
06:48:15 <Cheery> if it doesn't, the library API has a bug.
06:48:23 <bartavelle> how do you know you didn't miss anything ?
06:48:27 <Cheery> and the author shouldn't be designing APIs in the first place if that happens.
06:48:32 <bartavelle> how do you know you can trust the versionning policy ?
06:48:45 <bartavelle> with static typing I don't have to trust the library author to do the right thing
06:48:57 <bartavelle> I can just rely on the type system. this is nice.
06:49:17 <Cheery> is that a truth, or your belief?
06:49:23 <bartavelle> obviously if the API was "String -> IO String" to begin with, that doesn't help much
06:49:39 <bartavelle> this is obviously true
06:49:49 <bartavelle> if someone changes its API, my compilation with break
06:50:09 <Cheery> and if someone changes the API wrong, he shouldn't be doing API. funny.
06:50:21 <bartavelle> yeah, tell that to all the gem writers
06:50:51 <Cheery> actually not that many people need to write APIs at all.
06:50:56 <Cheery> they are sort of special situation
06:51:06 <bartavelle> not at all ??
06:51:16 <bartavelle> where does that come from ?
06:51:24 <AshyIsMe> in cabal repl is there a way to get access to functions that arent exported in a module?
06:51:29 <heatsink> When you design a program modularly, you are writing APIs
06:51:37 <AshyIsMe> rather than having to temporarily add exports for them while testing?
06:51:53 <heatsink> me doesn't know what cabal repl is
06:51:59 * heatsink doesn't know what cabal repl is
06:52:05 <bartavelle> heatsink, type "cabal repl" :)
06:52:11 <Cheery> most of the time you could just include the stuff your code relies on, if the author breaks the API later, it doesn't break your software before you update the software yourself.
06:52:15 <bartavelle> AshyIsMe, I don't think you can, but you can still run plain old ghci and import your module
06:52:24 <heatsink> Must be a new feature, I don't have it.
06:52:35 <bartavelle> yes it's fairly recent
06:52:44 <Cheery> but there are sort of APIs that are sensitive to change.
06:52:52 <Cheery> such as media APIs in all desktops.
06:52:58 <Cheery> if they change, they break lots of software.
06:53:13 <Cheery> oh and haskell doesn't help that. :)
06:53:29 <Cheery> the user sees that the software suddenly breaks.
06:53:32 <AshyIsMe> bartavelle: ah ok that's good enough
06:53:44 <Cheery> for random reason if they don't see that it was updated.
06:54:44 <Vq> AshyIsMe: I believe the .Internal module convention is used for exporting normaly hidden stuff.
06:54:47 <bartavelle> what's a "media API" ? I don't think they change that often, on windows you have backward compatibility down do 16 bit windows
06:54:58 <bartavelle> anyway I don't see how this is relevant to #haskell
06:55:10 <Cheery> bartavelle: stuff such as OpenGL, alsa, etc. I did not meant for a specific API.
06:55:24 <Vq> AshyIsMe: Not all packages does that though.
06:55:59 <Cheery> bartavelle: and true, it's not relevant, you drove the question of type labels or not into API maintainability question that doesn't make sense in that context.
06:56:12 <Cheery> then went to state your beliefs as facts.
06:56:33 <bartavelle> :)
06:57:23 <bartavelle> you certainly swayed hearts here
06:57:52 <Cheery> but to be straight. I'm not asking about this because I have something against haskell.
06:58:11 <Cheery> or type inference overall
06:58:17 <Cheery> or you people personally
06:58:40 <Cheery> http://www.typescriptlang.org/ I'm bothered about this.
06:58:57 <Cheery> https://www.dartlang.org/ and about this, but slightly less.
06:59:05 <heatsink> Isn't that an extension that adds types to Javascript?
06:59:20 <Cheery> yup. *optional* static typing
06:59:40 <Cheery> then they go and add it everywhere in their examples, even when it doesn't make sense.
07:00:01 <Cheery> I see optional static typing as a potential optimization
07:00:09 <Cheery> this looks like premature optimization to me.
07:00:32 <Cheery> also it's otherwise looking like horrible.
07:00:40 <heatsink> Maybe this should go in #haskell-blah
07:00:42 <homam> hey, in the first snippet in this page, how is he using forall function? https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial
07:00:44 <joneshf-laptop> when you come across a new data type, how do you figure out what its instances do, functor, applicative, monad, etc?
07:01:00 <joneshf-laptop> just reading the source?
07:01:09 <joneshf-laptop> or is there some way to intuit it ?
07:01:50 <heatsink> I think it's mainly done from experience and by analogy to known examples, joneshf-laptop
07:02:05 <vikraman> homam: https://twitter.com/sdbo/status/429266647627882496
07:02:14 <heatsink> Then read the source when you're in an unfamiliar situation
07:03:03 <homam> @vikraman :) thanks. i was getting excited
07:03:03 <lambdabot> Unknown command, try @list
07:03:05 <joneshf-laptop> hmm
07:03:52 <joneshf-laptop> that seems like something is missing, but i don't know what
07:04:06 <joneshf-laptop> although, this doesn't feel like a haskell only problem
07:04:11 <joneshf-laptop> but thats another subject
07:05:38 <heatsink> Cheery, Javascript's typing is exceptionally bad, even for people who are used to dynamic typing.  Many things should be a run-time error, but return a useless value instead.  This tends to hide programming errors during testing.
07:05:47 <heatsink> Cheery: https://www.destroyallsoftware.com/talks/wat
07:06:33 <Cheery> heatsink: yeah, but that's not my point here.
07:07:08 <Cheery> they give you *optional* static typing, then they propose that you *always* use it.
07:07:23 <heatsink> When you're in that kind of environment, using too many type annotations is defensive programming.
07:07:35 <AshyIsMe> https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/Simple%20examples
07:07:42 <AshyIsMe> that's a nice page of simple examples
07:07:48 * AshyIsMe says at noone in particular
07:08:20 <Cheery> heatsink: yeah, but is it correct kind of "defensive"
07:09:14 <Cheery> heatsink: stuff such as in java seem like cancerous tissue
07:09:32 <heatsink> Java and Javascript aren't really related
07:09:33 <Cheery> it kills maintainability. doesn't enchance it.
07:09:39 <piezoid> joneshf-laptop: by thinking about properties and laws of a datatype, it should (theoretically) be only one possible typeclass instance
07:10:19 <Cheery> heatsink: it doesn't matter that bad coding practises are optional, if you use them anyway.
07:10:36 <lostman> for anyone familiar with yesod clientsession... how can I get the contents of the session map outside of the yesod stack? essentially I want to grab the Cookie ByteString straight from the HTTP request, pull out _SESSION cookie, which should be just a serialised SessionMap, and turn it into that map
07:11:32 <Cheery> heatsink: that's why I'm worried. I'm worried that this will set back computing. That companies settle to stupid practises
07:12:25 <Cheery> heatsink: you yourself know that there's no supportive or defensive evidence towards defensive programming with static type checking.
07:12:26 <piezoid> lostman: you need run your code in HandlerT monad, I think
07:12:36 <heatsink> I would think of Typescript's page as marketing.  Marketing a product is done most effectively by convincing users that the product does what they want.  You don't try to persuade programmers to change their habits, except the few who are already on the fence.
07:12:46 <heatsink> in marketing
07:14:07 <bergmark> this talk is also good https://www.destroyallsoftware.com/talks/useing-youre-types-good
07:14:19 <lostman> piezoid: I can't do that. but once I get the bytestring, it should be a pure function to deserialise it. isn't it a just a map from bytestring to bytestring anyway?
07:16:12 <piezoid> lostman: ok, i didnt' understood your question...
07:16:37 <piezoid> lostman: i guess you have to read the code and figure out how it's done
07:16:45 <heatsink> Also, companies settle for stupid practices all the time.  Because it's virtually impossible to measure how good a programming practice is.
07:17:00 <heatsink> So companies tend to do the thing that seems safest, rather than best.
07:17:16 <piezoid> lostman: http://hackage.haskell.org/package/yesod-core-1.2.6.5/docs/src/Yesod-Core-Types.html#SessionBackend so there is mutiple session backends
07:22:40 <piezoid> lostman: use makeSessionBackend or defaultClientSessionBackend, then SessionBackend give you a function to extract session from Request and reserialise it.
07:26:15 <kstt> hi. I want to implement a 'transaction :: Connection -> IO a -> IO a' combinator. It will wrap the db action in transactions directives.
07:26:40 <lostman> piezoid: yeah, but that's in yesod stack. I can get the _SESSION cookie manually and then decrypt it using the same key yesod uses; and I see what I want in the ByteString but it's full of \NUL\NUL\NUL and so on. I'd rather not dig into it by myself
07:27:06 <kstt> If the action succeed (no exception), it must commit. If it fails, it must rollback. Is a standard combinator designed for that please ?
07:27:28 <kstt> I'm looking at Control.Exception at the moment.
07:27:37 <Tekmo> kstt: What database library are you using?
07:27:47 <kstt> sqlite-simple
07:27:54 <Tekmo> kstt: For example, `postgresql-simple` already has this function
07:28:02 <Tekmo> kstt: withTransaction :: Connection -> IO a -> IO a
07:28:15 <kstt> Ah, I'll look at how it does that.
07:28:20 <kstt> Thank you Tekmo
07:28:49 <Tekmo> kstt: Youre welcome
07:29:36 <piezoid> lostman: it's using Data.Serialize at some point : http://hackage.haskell.org/package/yesod-core-1.2.6/docs/src/Yesod-Core-Internal-Session.html#decodeClientSession
07:29:37 <joneshf-laptop> piezoid, that doesn't seem like an absolute thing though.I mean we have to wrap Num into SUm and Product for Monoid because both are valid monoids
07:33:25 <piezoid> joneshf-laptop: yes that's the point, newtype wrapper allow to select the behavior. Num can't be a monoid because it have multiple monoid interpretations.
07:34:50 <joneshf-laptop> so Num is too general?
07:37:05 <joneshf-laptop> hmm, does that mean in general, if you have some data type with multiple valid instances, you can split off to more data types?
07:37:36 <piezoid> joneshf-laptop: for a monoid yes
07:38:34 <lostman> piezoid: good find. a bit unsanctioned way it seems but I try to use Data.Serialize directly
07:38:39 <piezoid> joneshf-laptop: i don't know but you should not define instances without newtype wrappers
07:40:37 <kstt> Tekmo : I found the pg-simple implementation but it looks a bit low-level for my tastes (direct use of mask). I'd like something higher level, a bit like bracket, but with differenciated 'closing' action, depending on the completion status of the bracketed action. 1 closing action for the no-exception case, and 1 other closing action for the exception case. Do you know if that pattern is generic enough to be found in a lib ?
07:40:47 * hackagebot reactive-banana-sdl 0.2.0 - Reactive Banana bindings for SDL  http://hackage.haskell.org/package/reactive-banana-sdl-0.2.0 (JeanPhilippeMoresmau)
07:40:49 * hackagebot TypeClass 0.2.1 - Typing speed game  http://hackage.haskell.org/package/TypeClass-0.2.1 (JeanPhilippeMoresmau)
07:41:44 <piezoid> joneshf-laptop: but it's a metter of style. Maybe the instance is obvious but not unique, and sometimes you want different behavior with a wrapper
07:45:39 <lostman> piezoid: it works ;-) good find!
08:02:23 <xy124> is it posible to have more than one function definition after the let ... in statement like i did it here: http://lpaste.net/99307 ? (compiler complains...)
08:03:15 <Hafydd> xy124: is it because of the - character in "let-has"?
08:03:19 <Feuerbach> xy124: sure, just remove the dash
08:03:46 <xy124> oops that came from copying
08:04:02 <Feuerbach> xy124: also, it looks like that let is at the top-level? it shouldn't be
08:04:12 <Feuerbach> it's an expression
08:05:08 <Hafydd> xy124: that's still invalid, though, I now note: if you want one binding to affect many top-level declarations, you'll need to make it also a top-level declaration itself.
08:05:30 <Hafydd> If you want to hide it, you could isolate them all in one module, and import only the ones you want.
08:06:01 <xy124> ok
08:06:43 <xy124> but normally i can use let defined things in more than one thing by listing them like this? (refreshed http://lpaste.net/99307)
08:08:40 <Hafydd> xy124: no. As Feuerbach said, "let" can be used to make local declarations in the context of an expression, but a top-level declaration is not an expression.
08:09:19 <xy124> ah ok that i didnt got from the above text
08:09:24 <xy124> thanks a lot :)
08:09:54 <Hafydd> (Nor is any other kind of declaration)
08:12:47 <xy124> an other question: is there an opensource project written in haskell, where one could learn a bit from reading? I'm completely unsure about good haskell coding style..
08:13:16 <Hafydd> There's always GHC.
08:13:30 <Hafydd> (But there might be better example)
08:13:31 <k00mi> xmonad, pandoc
08:14:07 <xy124> ah great! its even written in haskell i thought it is completely c++ thanks! :)
08:14:25 <Hafydd> You thought GHC was written in C++?
08:14:26 <bergmark> ghc is probably not the best in that regard :-)
08:14:35 <Hafydd> GHC++
08:15:24 <bergmark> xy124: i'd recommend some of the popular but smaller libraries, aeson perhaps
08:15:34 <xy124> ah ok thats what the c stands for :D
08:15:46 <Hafydd> bergmark: is that because GHC is hard to understamd, or because it uses bad coding style?
08:15:51 * hackagebot attoparsec-expr 0.1.1 - Port of parsec's expression parser to attoparsec.  http://hackage.haskell.org/package/attoparsec-expr-0.1.1 (SebastiaanVisser)
08:17:11 <albertid> xy124, also, try a search on github, maybe its easier to learn from smaller projects
08:17:13 <bergmark> Hafydd: it is big, so it's probably hard to understand because of that, and i'd guess they don't use a lot of the features of haskell
08:17:16 <int-e> Hafydd: A bit of both. It also mixes styles; some of the code seems to predate the invention of monads (grep for `thenM` ...)
08:17:32 <albertid> xy124, and check this "code deconstructed" series on youtube
08:17:39 <Hafydd> I see.
08:17:59 <k00mi> I once looked at the GHC source and it was rather weird
08:18:05 <bob1> hi here is some brain teaser if you like http://codegolf.stackexchange.com/questions/19748/minimum-number-used-for-having-a-unique-element-in-all-subsequence-in-a-list
08:18:13 <k00mi> probably because of how old it is compared to most other haskell code
08:18:18 <int-e> (personally I also find literate haskell weird)
08:18:30 <Hafydd> I prefer illiterate Haskell.
08:21:02 <Hafydd> bob1: f(4)->[1,2,1,3] has subsequences [2,1,3] and [1,2,3] which both have the same elements.
08:22:05 <bob1> here unique means that inside a subsequence there is an element different to all others
08:22:13 <bartavelle> Hafydd, I believe it means that both subsequences have at least a single element
08:22:26 <bartavelle> but it seems that you can't reuse any element except the first or the last
08:22:38 <bartavelle> so i'd guess the problem is trivial, unless I missed something ?
08:23:30 <Hafydd> bob1: in that case, the subsequence [1,1] violates it.
08:24:15 <benzrf> hello!
08:24:16 <bob1> but [1,1] is not subsequence is it? subsequence means it have to be continous
08:24:18 <bartavelle> Hafydd, I suppose this is a list, not a set, so you have to cut at one (or two) places, you can't reorder the elements
08:24:27 <bob1> @bartavelle
08:24:27 <lambdabot> Unknown command, try @list
08:24:33 <benzrf> If i compose a traversal with another one, then use toListOf , will I get nested lists?
08:24:35 <bob1> @batavalle yes exactly
08:24:35 <lambdabot> Unknown command, try @list
08:24:49 <magneticduck> hmm, what I would like would be to be able to have an overview of the current module in some sort of sidebar
08:24:54 <magneticduck> using vim
08:24:58 <zrho> bob1: No need for the @
08:25:02 <magneticduck> like, the list of definitions essentially
08:25:06 <benzrf> magneticduck: theres almost certainly a plugin for that
08:25:08 <magneticduck> that you could nagivate through
08:25:09 <Hafydd> bob1: I see. The mathematical definition of a subsequence that I've heard doesn't require them to be contiguous.
08:25:12 <magneticduck> yeah, but not sure what is it
08:25:15 <magneticduck> or what to search for
08:25:17 <benzrf> magneticduck: you could even write your own, if you have access to a static analysis program
08:25:26 <bartavelle> ah yes I missed something
08:25:29 <magneticduck> static analysis?
08:25:39 <benzrf> analysis of a program without running it
08:25:49 <benzrf> just run a filter over the current file that spits out a list of definitions
08:25:54 <benzrf> then pipe it into a vim buffer
08:25:56 <benzrf> simples
08:26:10 <magneticduck> yeah
08:26:30 <zrho> Does anyone have a neat idea for Haskell related bachelor thesis?
08:26:34 <Hafydd> bartavelle: I'd suggest writing a program that checks the winning criteria, as one of the comments on that post also said.
08:26:45 <Hafydd> To clarify its meaning beyond a doubt.
08:28:59 <benzrf> > [1, 2, 3] ^.. traverse
08:29:00 <lambdabot>  [1,2,3]
08:29:09 <benzrf> > [1, 2, 3] ^.. traverse . traverse
08:29:10 <lambdabot>  Could not deduce (Data.Traversable.Traversable t0)
08:29:11 <lambdabot>    arising from the ambiguity check for `e_1123'
08:29:11 <lambdabot>  from the context (GHC.Num.Num (t a),
08:29:11 <lambdabot>                    Data.Traversable.Traversable t)
08:29:11 <lambdabot>    bound by the inferred type for `e_1123':
08:29:14 <benzrf> wha
08:29:16 <benzrf> > [1, 2, 3] ^.. (traverse . traverse)
08:29:18 <lambdabot>  Could not deduce (Data.Traversable.Traversable t0)
08:29:18 <lambdabot>    arising from the ambiguity check for `e_1123'
08:29:18 <lambdabot>  from the context (GHC.Num.Num (t a),
08:29:18 <lambdabot>                    Data.Traversable.Traversable t)
08:29:20 <lambdabot>    bound by the inferred type for `e_1123':
08:29:21 <benzrf> dang
08:29:27 <benzrf> oh wait i see
08:29:27 <benzrf> alright
08:29:39 <benzrf> > [[1, 2, 3], [4, 5, 6]] ^.. (traverse . traverse)
08:29:40 <lambdabot>  [1,2,3,4,5,6]
08:29:43 <benzrf> neat
08:29:43 <Hafydd> bartavelle: sorry, I meant bob1.
08:29:52 <bob1> I have updated it, hope it makes it more clear
08:29:53 <bob1> http://codegolf.stackexchange.com/questions/19748/minimum-number-used-for-having-a-unique-element-in-all-subsequence-in-a-list
08:29:58 <zrho> :t Traversal
08:29:58 <lambdabot> Not in scope: data constructor `Traversal'
08:30:06 <zrho> :t (^..)
08:30:06 <lambdabot> s -> Getting (Endo [a]) s a -> [a]
08:30:23 <zrho> :i Endo
08:30:27 <benzrf> :t ix
08:30:28 <lambdabot> (Indexable (Index m) p, Ixed f m) => Index m -> p (IxValue m) (f (IxValue m)) -> m -> f m
08:30:36 <benzrf> wut
08:31:16 <zrho> The second part looks like a lens: p (IxValue m) (f (IxValue m)) -> m -> f m
08:31:22 <benzrf> > "[1, {thing: 2}, 3]" ^? JSON
08:31:23 <lambdabot>  Not in scope: data constructor `JSON'
08:31:24 <benzrf> > "[1, {thing: 2}, 3]" ^? _JSON
08:31:24 <lambdabot>  Not in scope: `_JSON'
08:31:28 <benzrf> foo
08:31:29 <zrho> Specialize to (IxValue m -> f (IxValue m)) -> (m -> f m)
08:31:48 <benzrf> h i see i think
08:32:08 <benzrf> > [('a', 1), ('b', 2)] ^.. ix 'a'
08:32:09 <lambdabot>  Couldn't match type `GHC.Types.Int' with `GHC.Types.Char'
08:32:09 <lambdabot>  Expected type: Control.Lens.Each.Index [(GHC.Types.Char, t0)]
08:32:09 <lambdabot>    Actual type: GHC.Types.Char
08:32:12 <benzrf> fft
08:32:42 <benzrf> > [('a', 1), ('b', 2)] ^.. (ix 'a')
08:32:44 <lambdabot>  Couldn't match type `GHC.Types.Int' with `GHC.Types.Char'
08:32:44 <lambdabot>  Expected type: Control.Lens.Each.Index [(GHC.Types.Char, t0)]
08:32:44 <lambdabot>    Actual type: GHC.Types.Char
08:32:47 <benzrf> :\
08:32:57 <zrho> But Indexable is a Conjoined, which has the most absurd context I have ever seen in my life.
08:33:09 <zrho> (Choice p, Corepresentable p, Comonad (Corep p), Traversable (Corep p), Strong p, Representable p, Monad (Rep p), MonadFix (Rep p), Distributive (Rep p), ArrowLoop p, ArrowApply p, ArrowChoice p)
08:33:10 <benzrf> :t (^?)
08:33:11 <lambdabot> s -> Getting (First a) s a -> Maybe a
08:33:13 <benzrf> :t (^.)
08:33:13 <lambdabot> s -> Getting a s a -> a
08:33:14 <zrho> I mean, what the hell.
08:33:31 <benzrf> > view _Just (Just 3)
08:33:32 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
08:33:32 <lambdabot>    arising from a use of `e_13'
08:33:32 <lambdabot>  The type variable `a0' is ambiguous
08:33:32 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
08:33:32 <lambdabot>  Note: there are several potential instances:
08:33:37 <benzrf> u wot
08:33:47 <benzrf> o
08:33:50 <benzrf> > preview _Just (Just 3)
08:33:52 <lambdabot>  Just 3
08:33:55 <benzrf> alright
08:36:23 <bartavelle> > [(['a'],[1]),(['b'],[2])] ^. ix 0
08:36:25 <lambdabot>  ("a",[1])
08:36:31 <bartavelle> you need monoid instances
08:36:36 <bartavelle> > [(['a'],[1]),(['b'],[2])] ^. ix 2
08:36:37 <lambdabot>  ("",[])
08:37:24 <bartavelle> I don't know why it outputs this particular error message though
08:37:58 <benzrf> monoid instances?
08:38:06 <benzrf> why do I need monoids for ix?
08:38:16 <bartavelle> ix always returns something, not it needs 'mempty' when the search fails
08:38:22 <benzrf> ahf:
08:38:24 <benzrf> *ah
08:38:32 <benzrf> but, can't a traversal be empty?
08:39:01 <bartavelle> I am still fuzzy on what a traversal actually is :)
08:39:17 <supki> benzrf: Traversal can return from 0 to +Inf targets, Monoid instance is used to combine them
08:39:18 <benzrf> it is like a lens but with n targets
08:39:22 <benzrf> supki: ah yes
08:39:24 <enthropy> > [(['a'],[1]),(['b'],[2])] ^? ix 2
08:39:26 <lambdabot>  Nothing
08:39:27 <supki> benzrf: because ^. returns a single answer
08:39:42 <benzrf> > [('a', 1), ('b', 2)] ^.. (ix 'a')
08:39:43 <lambdabot>  Couldn't match type `GHC.Types.Int' with `GHC.Types.Char'
08:39:43 <lambdabot>  Expected type: Control.Lens.Each.Index [(GHC.Types.Char, t0)]
08:39:43 <lambdabot>    Actual type: GHC.Types.Char
08:39:48 <benzrf> ^but shouldnt that give me a list?
08:39:52 <benzrf> that's ^.. not ^.
08:40:33 <supki> > M.fromList [('a', 1), ('b', 2)] ^.. ix 'a'
08:40:34 <lambdabot>  [1]
08:40:38 <supki> it does
08:41:20 <supki> [(a, b)] does not have an Ixed instance, so you can't use  ix  on it directly
08:41:23 <benzrf> what is M in this context?
08:41:28 <benzrf> oh map
08:41:34 <benzrf> o: ok
08:41:37 <supki> > [('a', 1), ('b', 2)] ^.. wrapping M.fromList .ix 'a'
08:41:38 <lambdabot>  [1]
08:41:44 <benzrf> what's wrapping?
08:42:07 <c_wraith> :t wrapping
08:42:08 <lambdabot> (Functor f, Profunctor p, Wrapped s s a a) => (s -> a) -> p a (f a) -> p s (f s)
08:42:54 <benzrf> im sorry i have problems with type sigs containing more than 2 constraint type vars
08:43:27 <c_wraith> if I read p as (->), it reads more like  (s -> a) -> (a -> f a) -> (s -> f s)
08:43:40 <c_wraith> which makes it look like it converts a function into a lens
08:43:57 <c_wraith> With some constraints
08:44:01 <supki> wrapping does not use its argument actually
08:44:04 <benzrf> profunctor is not exactly -> tho is it?
08:44:18 <c_wraith> benzrf: (->) is an instance of Profunctor
08:44:22 <benzrf> true
08:44:28 <benzrf> :t dimap
08:44:29 <lambdabot> Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
08:44:43 <benzrf> neat
08:44:54 <c_wraith> supki: is the argument just used to determine the instance of Wrapped to use?
08:44:57 <benzrf> > (1, 2) ^. wrapping fst
08:44:58 <supki> yeah
08:44:58 <lambdabot>  No instance for (Control.Lens.Wrapped.Wrapped
08:44:58 <lambdabot>                     (a0, b0) (a0, b0) a0 a0)
08:44:58 <lambdabot>    arising from a use of `e_112'
08:44:58 <lambdabot>  Possible fix:
08:44:58 <lambdabot>    add an instance declaration for
08:45:03 <benzrf> :[
08:46:28 <c_wraith> supki: can I say I dislike that signature then? :)
08:47:04 <benzrf> so dumb
08:47:57 <supki> c_wraith: sure, noone likes Wrapped anyway
08:48:04 <colDrMcBeardman> is there something high-level for rewriting lines in a file?
08:48:04 <c_wraith> oh good. :)
08:49:19 <colDrMcBeardman> or is the best thing just readFile and writeFile?
08:49:34 <c_wraith> colDrMcBeardman: not really, but there are pieces to construct similar stuff, *if* you know what properties you want.
08:49:54 <colDrMcBeardman> c_wraith: ok, I'm looking to just replace certain lines that match a regex.
08:49:57 <c_wraith> colDrMcBeardman: for instance, combining readFile and writeFile on the same file is likely to erase the contents of the file, and nothing more.
08:50:23 <colDrMcBeardman> c_wraith, heh, yeah, i knew that from cat and redirection :P
08:50:46 <c_wraith> If the input and output are different files, though, they'll work fine
08:51:09 <colDrMcBeardman> c_wraith, that's just the thing, i want to do it in-place
08:51:51 <benzrf> so why is ix a traversal anyway?
08:51:54 <c_wraith> In that case, your options are pretty limited.  You pretty much have to start by reading the whole file into memory, processing it, then writing it out.
08:52:04 <benzrf> why not a prism or something
08:52:16 <magneticduck> I wonder if making a dlint type tool that also did automatic corrections would be cool
08:52:17 <c_wraith> and sadly, readFile doesn't actually read the whole thing into memory
08:52:21 <benzrf> hmm prisms have to be two-way don't they...
08:52:22 <magneticduck> at least something interactive
08:52:30 <magneticduck> working with dlint is nice for learning style
08:52:36 <benzrf> @src _1
08:52:37 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:52:37 <colDrMcBeardman> c_wraith, i thought there was a System.IO.Strict i could use
08:52:40 <benzrf> so dumbhat
08:52:41 <benzrf> *dumb
08:52:44 <bartavelle> benzrf, at works more like a prism
08:52:44 <benzrf> :t _1
08:52:45 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
08:52:58 <benzrf> bartavelle: how does it differ from ix
08:53:13 <colDrMcBeardman> i'm ok with reading in a 2MB file, it's not that much, but i still held out hope of being able to write into a file with some kind of line offset.
08:53:23 <colDrMcBeardman> that would be a cool library.
08:53:39 <c_wraith> colDrMcBeardman: The problem is, it's ridiculously hard, unless your lines are fixed-length
08:54:03 <bartavelle> benzrf, the type signature has a maybe in it ;)
08:54:22 <bartavelle> I believe ix is 'at . _Just'
08:54:46 <bartavelle> except not ...
08:54:49 <benzrf> lol
08:54:51 <bartavelle> the instances are different
08:54:51 <benzrf> thats a nop
08:54:52 <c_wraith> colDrMcBeardman: because the on-disk format is a linked list of 4kb (usually) blocks.  change a line length, and you have to change the contents of all following blocks.
08:54:53 <colDrMcBeardman> c_wraith, i was also thinking of a character offset, but then mixing that with regex sounds like a herculean task of getting the high level to work with the low level
08:55:00 <bartavelle> well just ask ski ;)
08:55:04 <benzrf> bartavelle: prism . _Just is always a nop
08:55:24 <bartavelle> at isn't a prism at all then
08:55:52 <bartavelle> I don't really know what I am talking about, this should make me feel bad because I use lens all over the place
08:56:00 <benzrf> > preview (at 'a') (M.fromList [('a', 1), ('b', 2)]
08:56:01 <lambdabot>  <hint>:1:50:
08:56:01 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
08:56:02 <benzrf> > preview (at 'a') (M.fromList [('a', 1), ('b', 2)])
08:56:03 <lambdabot>  Just (Just 1)
08:56:08 <benzrf> hmmm
08:56:13 <bartavelle> just view
08:56:21 <benzrf> > view (at 'a') (M.fromList [('a', 1), ('b', 2)])
08:56:22 <lambdabot>  Just 1
08:56:23 <benzrf> so it is a lens
08:56:29 <benzrf> that acts like a prism?!
08:56:36 <benzrf> what is the purpose of this?
08:56:50 <maurer> ls
08:56:54 <maurer> oops, sorry
08:56:58 <benzrf> maurer: wrong window ;0
08:56:59 <dgpratt> invalid command
08:57:11 <c_wraith> colDrMcBeardman: It always ends up being simplest to just read the whole file, modify it, then write it.  Sometimes you can be more efficient by being very clever - but it's *hard* to get right.  To the point where I'm not sure a library could be written that would be reasonable for all the use cases people would try to throw at it.
08:57:22 <supki> benzrf: ix is a Traversal because whatever indexed container you look into may not have a value at a given key
08:57:24 <benzrf> > review (at 'a') 2
08:57:26 <lambdabot>  Couldn't match type `m0 -> Data.Functor.Identity.Identity m0'
08:57:26 <lambdabot>                with `Control.Lens.Internal.Review.Reviewed
08:57:26 <lambdabot>                        s0 (Data.Functor.Identity.Identity t0)'
08:57:26 <lambdabot>  Expected type: Control.Lens.Review.AReview
08:57:26 <lambdabot>                   s0
08:57:31 <benzrf> supki: so why not a prism
08:57:53 <supki> benzrf: because you can't construct the whole container from just a value at a single key
08:57:57 <benzrf> supki: ah
08:58:16 <benzrf> so lenses are always-working but not reversible, while prisms can fail and are reversible
08:58:49 <benzrf> :t review
08:58:50 <lambdabot> MonadReader b m => AReview s t a b -> m t
08:58:51 <supki> yes, prisms are 0-or-1 target traversal that you can turn around to construct the original structure
08:59:32 <benzrf> so both lenses and prisms are special cases of traversals?
08:59:54 <supki> yep
08:59:58 <benzrf> and view/preview can be treated as wrappers around toListOf?
09:00:12 <supki> ?
09:00:24 <benzrf> > toListOf _1 (1, 2)
09:00:26 <lambdabot>  [1]
09:00:38 <benzrf> > toListOf _Right (Left 3)
09:00:40 <lambdabot>  []
09:00:50 <benzrf> for lenses, [a] -> a
09:00:59 <benzrf> for prisms, [] -> Nothing, [a] -> Just a
09:01:43 <benzrf> > view _Right (Right 3)
09:01:45 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
09:01:45 <lambdabot>    arising from a use of `e_13'
09:01:45 <lambdabot>  The type variable `a0' is ambiguous
09:01:45 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:01:45 <lambdabot>  Note: there are several potential instances:
09:01:54 <benzrf> > view _Right (Right "wat")
09:01:55 <lambdabot>  "wat"
09:02:03 <benzrf> mconcat instead for prisms i guess
09:02:04 <benzrf> or something
09:02:05 <benzrf> o_o
09:02:31 <benzrf> > preview _1 (1, 2)
09:02:33 <lambdabot>  Just 1
09:09:43 <triliyn> > view _Right (Left "hmm")
09:09:45 <lambdabot>  ()
09:09:56 <triliyn> :t view _Right
09:09:57 <lambdabot> (Monoid b, MonadReader (Either c b) m) => m b
09:11:07 <supki> benzrf: well, no. [a] -> a is a lie anyway
09:11:18 <benzrf> oh hmm thatst rue
09:11:21 <benzrf> *thats true
09:11:36 <benzrf> > view _Right (Right "hmm")
09:11:37 <lambdabot>  "hmm"
09:11:42 <benzrf> iiinteresting
09:11:46 <benzrf> > mempty
09:11:47 <lambdabot>  ()
09:11:52 <benzrf> without context??
09:11:58 <notdan> > view _Left (Right "huh")
09:11:59 <lambdabot>  ()
09:12:04 <benzrf> > view _Right (Right "hmm") :: String
09:12:05 <lambdabot>  "hmm"
09:12:09 <benzrf> > view _Right (Left "hmm") :: String
09:12:10 <lambdabot>  ""
09:12:13 <benzrf> memtpy
09:12:16 <benzrf> *empty
09:12:20 <notdan> :t _Right
09:12:21 <lambdabot> (Applicative f, Choice p) => p a (f b) -> p (Either c a) (f (Either c b))
09:12:44 <benzrf> 1. i like haskell for its helpful, informative types
09:13:00 <benzrf> 2. lens has ridiculous unreadable types that do not seem apropos to what they are used for
09:13:01 <supki> blame GHC
09:13:04 <benzrf> 3. lens is dum
09:13:39 <mornfall> supki: the problem is more fundamental in the language
09:13:55 <notdan> I blame the lack of subtyping
09:14:14 <notdan> because that's what all the hundreds of typeclasses in lens emulate
09:14:15 <triliyn> I wonder what other types have MonadReader instances than (r ->)
09:14:17 <platz> lens is just highly polymorphic is all
09:14:31 <notdan> triliyn: ReaderT m
09:14:47 <triliyn> hmmm, yeah, that's an obvious one
09:14:49 <benzrf> triliyn: do you mean ((->) r)
09:15:00 <benzrf> on account of there are no type sections
09:15:00 <triliyn> benzrf: yeah
09:15:12 <benzrf> silly language
09:15:14 <triliyn> Lots of people seem to like to pretend there are type sections when talking about it
09:15:21 <notdan> platz: IMO, the problem is not in polymophism, as it can still be preserved by switching to newtypes instead of type synonyms
09:15:26 <notdan> the real problem is in subtyping
09:15:33 <edwardk> notdan: lens is pretty light on typeclasses. it mostly uses what already exists in very weird ways
09:15:39 <benzrf> no fuckin shit
09:15:56 <supki> mornfall: in general, probably, but :t _Right ?
09:16:19 <supki> it could at least try to preserve synonyms
09:16:22 <notdan> edwardk: yes, you are right. But still I have the impression that the only valid reason for using type synonyms is to support subtyping
09:16:24 <edwardk> triliyn: the reason for using MonadReader there is that while most users don't need it, if you want to work with the environment of a transformer stack, having view be overloaded means you can use it like 'use'
09:16:25 <mornfall> supki: what would you like it to print?
09:16:27 <notdan> (and typeclasses help with this)
09:16:39 <supki> mornfall: Prism (Either c a) (Either c b) a b
09:16:42 <benzrf> so do view, preview, etc all inject different kinds of functors to accomplish different things from the same lens
09:16:45 <mornfall> well, synonyms are a two-edged sword
09:16:50 <triliyn> edwardk: hmmm, right
09:16:51 <edwardk> benzrf: yes
09:16:51 <benzrf> i.e. toListOf passes a list?
09:16:55 <benzrf> ok thats clever o:
09:17:21 <notdan> that's the beautiful trick of the lenses
09:17:23 <edwardk> triliyn: you can use    foo = do x <- view _1; ... and it just does the right thing in a monad transformer stack
09:17:38 <mornfall> supki: preserving synonyms can have very surprising side-effects when multiple modules are involved in an error
09:18:15 <edwardk> we used to have a separate combinator for that, named query, but it was redundant as view was just a type restricted for of it, and so we eliminated it and generalized view
09:18:18 <triliyn> I think Idris has a way to mark synonyms as "reversable" so that it tries to  preserve them in error messages
09:18:25 <edwardk> which reduced pressure on the namespace
09:18:28 <notdan> I don't know in detail how GHC handles type errors that involve synonyms, but I am pretty sure it preserves *some* type synonyms
09:18:34 <triliyn> (Very recently, actually)
09:18:50 <edwardk> notdan: :t drops the synonyms on the floor quickly.
09:19:09 <edwardk> :info at least shows them
09:19:29 <triliyn> edwardk: are these "Getting" and "Setting" things that I have seen not synonyms?
09:20:01 <mornfall> well, you could say lens has become the boost of haskell :)
09:20:13 <benzrf> oh gosh
09:20:17 <edwardk> type Getting r s a = (a -> Const r a) -> s -> Const r s -- is a synonym
09:20:42 <edwardk> if you do anything that unifies with the types in the synonym i mean
09:21:23 <edwardk> in any event they crack open and disgorge their contents whether you want them to or not in unexpected ways ;)
09:21:36 <triliyn> edwardk: well I mean, I've seen those in type signatures, so clearly there is SOME preservation of synonyms
09:22:14 <triliyn> I guess maybe if you say ":t x" where x is a term that has been given an explicit type declaration, it just spits out what you gave it
09:22:27 <edwardk> triliyn: yes, what i said was a bit of a gross oversimplification
09:22:42 <triliyn> But if it has to infer the type because of partial application or something, it breaks all the synonyms down?
09:23:00 <edwardk> :t flip view ()
09:23:01 <lambdabot> Getting a () a -> a
09:23:10 <edwardk> it'll occasionally preserve them
09:23:14 <triliyn> :t view
09:23:15 <lambdabot> MonadReader s m => Getting a s a -> m a
09:23:17 <triliyn> hmmm
09:23:19 <edwardk> :t _1
09:23:20 <lambdabot> (Functor f, Field1 s t a b, Indexable Int p) => p a (f b) -> s -> f t
09:23:30 <edwardk> t'll also occasionally drop them on the floor
09:24:04 <edwardk> _1 :: FIeld1 s t a b => IndexedLens Int s t a b
09:24:43 <triliyn> How strange and inconvenient
09:30:49 <narendraj9> what project should I be looking at now if I want to be a part of GSoC 2014 and want to work in Haskell? Please help.
09:38:50 <Heffalump> narendraj9: look at the wiki pages, and find one or more that interest you, that you think you could do well, and where you can do things between now and application time to make a good proposal
09:39:14 <enthropy> http://www.haskell.org/haskellwiki/Haskell_Communities_and_Activities_Report
09:39:24 <narendraj9> Do you know what projects use haskell?
09:43:18 <matessim> exit
09:43:41 <piezoid> what is the name of a quiver (Category without id and (.)) indexed over a Category ? (something having the kind (*->*->*)->*->*->* )
09:43:58 <joelteon> Category without id and (.)?
09:44:26 <platz> anyone ever dabble with F#? I've heard of things like 'active patterns and 'type providers' which seem interesting
09:44:39 <piezoid> joelteon: yes, a collection of arrows
09:45:10 <enthropy> what can you do with them?
09:46:06 <piezoid> but them back in a free Category to compose them :)
09:47:00 <jfischoff> is there a way to get GHC to implicitly import other modules besides Prelude?
09:47:27 <jfischoff> for some reason I thought there was, but that doesn't appear to be the case
09:47:29 <piezoid> for example the data type CC with constructor Prod :: cat a b -> cat a c -> CC cat (b, c)
09:47:50 <piezoid> it add cartesian product to the free category
09:48:17 <piezoid> sorry its Prod :: cat a b -> cat a c -> CC cat a (b, c)
09:49:18 <piezoid> i'm playing with cartesian categories, but maybe i'm doing it wrong...
10:09:10 <cschneid> Is there any good article about what kinds are, why I would care about them, how to use them to solve actual problems, etc?
10:09:43 <alcabrera> jfischoff: I don't know about GHC, but for GHCi, you can add import statements to your ~/.ghci file
10:11:08 <jfischoff> alcabrera: doesn't seem to be anything for ghc
10:11:16 <jfischoff> how old is haskell?
10:11:24 <enthropy> cschneid: are you convinced types are useful
10:11:35 <jfischoff> Cale: when did Haskell version 0.* come out?
10:11:49 <enthropy> @google a history of haskell
10:11:50 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/
10:11:50 <lambdabot> Title: A History of Haskell
10:11:58 <jfischoff> thanks
10:12:56 <cschneid> enthropy: sure - I just know less about Kinds, and how the knowledge of them gets applied in the course of writing programs
10:14:01 <cschneid> enthropy: mostly asking in the sense of "ok, that's cool. How does it affect me while writing programs"
10:14:06 <enthropy> well it's the same thing: kinds stop you from doing things to types for the same purpose as types do for terms
10:14:16 <geekosaur> if you're not doing type level hackery, you can mostly ignore kinds
10:14:33 <tertl3> does anyone use or hack on the yi editor?
10:14:39 <enthropy> :k RWST
10:14:39 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
10:14:59 <tertl3> oh its a video
10:15:13 * tertl3 grabs the snacks and hits the lights
10:17:26 <pranz> :k MonadTransformer
10:17:26 <lambdabot>     Not in scope: type constructor or class `MonadTransformer'
10:17:47 <enthropy> :k MonadTrans
10:17:47 <lambdabot> ((* -> *) -> * -> *) -> Constraint
10:19:08 <cschneid> enthropy: that's the reader-writer-state monad, yes? So that kind tells you what you need to plug into the type structure to get a final useful type, yes?
10:20:26 <enthropy> yeah. Seems pretty anticlimactic?
10:22:12 <matessim> exit
10:28:59 <dart> hi
10:29:53 <dart> how can modify a Map inside a Map with lenses
10:30:08 <dart> because at returns a (Just ...)
10:31:07 * hackagebot language-puppet 0.11.1.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.11.1.1 (SimonMarechal)
10:32:33 <simpson> dart: _Just might help.
10:32:42 <simpson> dart: Or non, perhaps.
10:32:51 <simpson> :t non
10:32:51 <lambdabot> (Eq a, Functor f, Profunctor p) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
10:33:25 <Tehnix> hmm, in a record syntax, is it possible to do something like `, result :: Text | CloudFlareTrafficBreakdown` ?
10:34:05 <opqdonut> Tehnix: how about result :: Either Text CloudFlareTrafficBreakdown`?
10:34:06 <benzrf> Tehnix: Either
10:34:15 <Tehnix> ah, of course, thanks!
10:34:17 <dart> simpson: thanks, i feel stupid
10:34:20 <benzrf> :)
10:34:31 <simpson> dart: Don't worry about it. This stuff's tricky the first time.
10:34:31 <benzrf> how do use non
10:34:36 <benzrf> :t non
10:34:37 <lambdabot> (Eq a, Functor f, Profunctor p) => a -> p a (f a) -> p (Maybe a) (f (Maybe a))
10:34:43 <benzrf> :t view non
10:34:44 <lambdabot>     Couldn't match type `Maybe' with `Accessor (a0 -> Accessor a0 a0)'
10:34:44 <lambdabot>     Expected type: Getting
10:34:44 <lambdabot>                      a0
10:34:48 <benzrf> :t preview non
10:34:49 <lambdabot>     Couldn't match type `Maybe (a0 -> Accessor (First a0) a0)'
10:34:49 <lambdabot>                   with `First a0'
10:34:49 <lambdabot>     Expected type: Getting
10:34:52 <benzrf> meh
10:35:04 <benzrf> :t preview (non 3)
10:35:05 <lambdabot> (Eq a, Num a, MonadReader (Maybe a) m) => m (Maybe a)
10:35:12 <benzrf> > preview (non 3) 4
10:35:13 <lambdabot>  No instance for (GHC.Show.Show a0)
10:35:14 <lambdabot>    arising from a use of `M12593042817804849224223.show_M12593042817804849224...
10:35:14 <lambdabot>  The type variable `a0' is ambiguous
10:35:14 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
10:35:14 <lambdabot>  Note: there are several potential instances:
10:35:17 <benzrf> hmmm?
10:35:34 <benzrf> > preview (non "wat") "what
10:35:34 <lambdabot>  <hint>:1:26:
10:35:35 <lambdabot>      lexical error in string/character literal at end of input
10:35:38 <benzrf> > preview (non "wat") "what"
10:35:39 <lambdabot>  Couldn't match type `[GHC.Types.Char]'
10:35:39 <lambdabot>                with `Data.Maybe.Maybe [GHC.Types.Char]'
10:35:42 <benzrf> fft
10:35:48 <benzrf> > preview (non "wat") (Just "what")
10:35:49 <lambdabot>  Just "what"
10:35:51 <benzrf> > preview (non "what") (Just "what")
10:35:53 <lambdabot>  Just "what"
10:35:55 <benzrf> ?
10:36:22 <rien__> where do I read the reason why the names "bind" and "return" (and not any of the other countless alternatives) were chosen for Haskell? is there even a good reason? Should I keep using "return" and "bind" in another language where I'm also working with monads?
10:36:48 <tac> rien__: They are just what we're stuck with. They are not really good names.
10:37:12 <klrr_> is there a splitable class? if not, why? =o seem like some that should be put to one http://www.haskell.org/hoogle/?hoogle=split
10:37:17 <tac> bind is fine, IMO. But return really should be renamed, because it is confusing to programmers coming from imperative backgrouns (that is, it's confusing to everyone the first time they see it)
10:37:29 <rien__> tac: that's sort of what I wanted to hear. should I call them wrap and chain where I'm using them? :) or are their proper mathematical names?
10:37:32 <tac> rien__: return is also the exact same as Applicative's pure
10:37:35 <tac> @type pure
10:37:35 <lambdabot> Applicative f => a -> f a
10:37:36 <tac> @type return
10:37:37 <lambdabot> Monad m => a -> m a
10:37:48 <klrr_> lift seem to make most sense imo
10:37:49 <jfischoff> rien_: bind introduces new names
10:38:03 <tac> The mathematical version of monads uses return and a library function called join instead
10:38:04 <tac> @type join
10:38:05 <lambdabot> Monad m => m (m a) -> m a
10:38:15 <klrr_> pure seem fine too, although lift is more explational
10:38:22 <monochrom> you should keep using ">>=" in other languages
10:38:51 <matessim> hey guys, i'm just getting started with haskell and i'm doing the 99 questions thing, i'm having a weird type issue when i'm trying to flatten a datatype i just created
10:38:55 <klrr_> tac: well that explains it
10:38:57 <matessim> https://gist.github.com/8739410
10:39:01 <tac> in math, we call those  (eta) and  (mu) respectively
10:39:18 <matessim> can someone please take a look and see if something wrong pops to their head with what i did there?
10:39:35 <tac> >>= is useful for programmers, for sure.
10:39:37 <rien__> tac: so what would you call them if you could pick the names? in a programming language.
10:39:50 <tac> You would never want to _program_ using , , and fmap
10:40:01 <tac> pure and bind, probably
10:40:07 <tac> But I would define monad in terms of join, personally
10:40:11 <matessim> data NestedList a = Elem a | NestedList [NestedList a]
10:40:11 <matessim> flatten :: NestedList a -> [a]
10:40:11 <matessim> flatten (Elem x) = [x]
10:40:12 <matessim> flatten (NestedList x) = [flatten el | el <- x]
10:40:24 <matessim> can anyone chip in?
10:40:25 <Cale> matessim: flatten el has which type?
10:40:33 <Cale> matessim: It must be a list, right?
10:40:34 <matessim> el is a NestedList
10:40:34 <rien__> tac: that depends on the monad. or are you saying every monad is easier to define through join? I just defined a either
10:40:48 <rien__> tac: ... I just defined a either+writer with bind and return
10:41:00 <Cale> So the elements of [flatten el | el <- x] must be lists, and hence it must be a list of lists
10:41:19 <matessim> Yes but NestedList is defined as being either a NestedList or a Elem
10:41:22 <Cale> However, the type signature of flatten doesn't say that it produces a list of lists
10:41:40 <matessim> So everything should fall to the (Elem x) pattern right?
10:41:45 <Cale> It says it produces a list of values of an arbitrary (unknown) type
10:42:09 <Cale> (You're missing a step in flattening here :)
10:42:22 <tac> rien__: I think it's more natural to think about join, rather than bind. But that's just my feelings, and others are free to feel otherwise
10:42:41 <tac> But yeah, join let's you "crush" a pair of type constructors into one
10:42:47 <tac> Maybe (Maybe a) -> Maybe a
10:42:54 <tac> Nothing could be more obvious
10:43:06 <matessim> Cale: I'm still missing the point of why this is a compiliation error, since i 'loosely' defined the return type of flatten shouldn't it work?.
10:43:11 <monochrom> if flatten el :: [X], then [flatten el | el<-x] :: [[X]], then flatten (NestedList x) :: [[X]], but you also want flatten (NestedList x) :: [X]. contradiction
10:43:20 <tac> (And if you disagree, maybe you feel Nothing :: Maybe (Maybe a) isn't so obvious :)
10:43:25 <Cale> matessim: You completely specified the return type of flatten
10:43:32 <benzrf> :t (&)
10:43:32 <lambdabot> a -> (a -> b) -> b
10:43:36 <benzrf> :t ($)
10:43:37 <lambdabot> (a -> b) -> a -> b
10:43:42 <benzrf> & is flip $?
10:44:05 <benzrf> > 23 & sqrt
10:44:06 <lambdabot>  4.795831523312719
10:44:10 <benzrf> neato
10:44:13 <Cale> matessim: You said that when given a value of type NestedList a, flatten will produce a result of type [a], that is a list of values of type a
10:44:39 <maxiepoo_> yep
10:44:39 <Cale> matessim: So for example, if given something of type NestedList Integer, flatten must produce a list of Integer values.
10:44:44 <matessim> Cale: when i just write -> [a], doesn't it mean it can be of any type?.
10:44:53 <dart> (quit
10:44:54 <matessim> my bad.. i thought it meant it's a list of any type
10:45:01 <matessim> didn't realize a was actually a type
10:45:10 <dooozbfaz> what is the term to describe the practice of hiding a datatype's constructor while exposing a "smart" constructor?
10:45:13 <Cale> It not only means it can be of any type, but the *same* type as the elements in the input NestedList.
10:45:40 <Cale> a can indeed be instantiated to any type whatsoever
10:45:55 <matessim> i see
10:46:03 <maxiepoo_> benzrf: it's given slightly higher precedence so you can mix it with $
10:46:10 <Cale> (but you have to do it consistently)
10:46:24 <matessim> Cale:  what do you mean by consistently?
10:46:33 <maxiepoo_> > tail $ 1 & show
10:46:34 <matessim> The problem is that i'm handing off a different type in the recursive call?.
10:46:35 <lambdabot>  ""
10:46:38 <monochrom> matessim: perhaps you should read my http://www.vex.net/~trebla/haskell/prerequisite.xhtml
10:46:40 <Cale> I mean that when you plug in some type for a, you have to plug in that type for all the a's
10:46:49 <matessim> monochrom: I will look at that, thank you.
10:47:05 <Cale> matessim: The problem is that you're not producing a plain list
10:47:10 <Cale> matessim: but a list of lists
10:47:22 <Cale> matessim: and you don't know that 'a' is some list type
10:47:25 <benzrf> maxiepoo_: cool
10:47:37 <Cale> matessim: For example, a might be Integer
10:47:46 <matessim> Cale: But that is also what i receive initially, my input is a list of lists anyway, i'm just breaking it into steps
10:47:57 <Cale> In that case, the result of flatten (NestedList x) had better be a list of Integer values
10:48:01 <Cale> not a list of lists
10:48:45 <Cale> matessim: The code you have here is nearly correct, you're just missing a step
10:48:48 <matessim> I see, so by the time flatten returns i need to have completely flattened the list already.. but doesn't that prevent me from using recursion? since i can't play with that.
10:48:54 <jfischoff> monochrom: nice link
10:48:56 <matessim> I'll read what monochrom sent me also
10:49:17 <rien__> tac: I'll try and write the join for mine to see if I think it's simple :)
10:49:34 <Cale> matessim: well, el :: NestedList a here, and so flatten el :: [a]
10:49:50 <Cale> matessim: So the right hand side of that equation currently has type [[a]]
10:49:58 <Cale> But it's supposed to have type [a]
10:50:11 <Cale> So do you know any functions of type [[a]] -> [a]?
10:50:25 <matessim> Oh, its a list of lists and not using my NestedList type anymore
10:50:32 <matessim> so i need to handle the case of [[X]]
10:50:43 <matessim> Cale: that's what you mean?
10:50:53 <Cale> Well, you just need to do something with the  [flatten el | el <- x] :: [[a]]
10:51:11 <Cale> So as to turn it into a value of type [a] so that it'll typecheck
10:51:22 <matessim> Cale: what do you mean by the ::?
10:51:32 <matessim> after the list comprehension
10:51:37 <Cale> x :: t  means "x has type t"
10:51:44 <monochrom> exactly the same as in haskell
10:52:00 <monochrom> exactly the same as when you wrote "flatten :: NestedList a -> [a]"
10:52:02 <Cale> I'm being explicit about what the type of that expression is
10:52:06 <matessim> Oh!, i get it.
10:52:14 <Cale> so that you can understand what the problem is :)
10:52:16 <matessim> Cheers :)
10:58:02 <x77686d> Newbie question: If I say 'let f = \x -> show x' why does ':t f' show f :: () -> String ?
10:59:04 <tac> x77686d: because of the type of show
10:59:06 <tac> @type show
10:59:07 <lambdabot> Show a => a -> String
10:59:09 <tac> oh
10:59:15 <tac> You're asking why it defaults to ()
10:59:19 <x77686d> yes
10:59:22 <tac> That's probably the monomorphism restriction
10:59:40 <tac> (You'll probably want to turn that off literally for every program)
10:59:55 <tac> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:00:07 <tac> It was a feature added to make type signatures more friendly to beginners
11:00:24 <tac> But as soon as you've been working with Haskell for a week and a half, it starts getting in your way.
11:00:29 <x77686d> I see
11:00:40 <x77686d> So the common wisdom is turn it off?
11:00:50 <enthropy> it's not useless
11:01:11 * hackagebot clafer 0.3.5.1 - clafer compiles Clafer models to other formats, such as Alloy, XML, HTML, Dot.  http://hackage.haskell.org/package/clafer-0.3.5.1 (mantkiew)
11:01:13 * hackagebot claferIG 0.3.5.1 - claferIG is an interactive tool that generates instances of Clafer models.  http://hackage.haskell.org/package/claferIG-0.3.5.1 (mantkiew)
11:01:15 * hackagebot claferwiki 0.3.5.1 - A wiki-based IDE for literate modeling with Clafer  http://hackage.haskell.org/package/claferwiki-0.3.5.1 (mantkiew)
11:01:17 <tac> x77686d: Yeah.
11:01:47 <x77686d> I'm in the position of learning and teaching Haskell ... :)
11:03:13 <pavonia> x77686d: I think the recommended solution is to give explicit type signatures to top-level definitions
11:04:22 <jle`> monomorphism restriction is off by default in ghci starting with ghc 7.8
11:04:32 <jle`> but most people already have it turned off anyway
11:04:50 <jle`> just add :set -XNoMonomorphismRestriction to your ~/.ghci
11:05:12 <jle`> if you turn it off in your programs though then you might end up having unexpected reevaluations
11:05:19 <FreeFull> Monomorphism restriction is one of the worst misfeatures
11:05:24 <jle`> so it's a lot of times better to just leave it on by default
11:05:35 <FreeFull> jle`: Or change your expectations
11:05:36 <jle`> once you know what kind of errors it causes
11:06:17 <x77686d> The :set works!  Thanks!  Thanks to tac for the link, too!
11:06:24 <matessim> Cale: Not sure what i'm still missing, how come i is not a but [a] after the list comprehension? it was in a list before -- flatten (NestedList (x:xs)) = x : [flatten i | i <- xs]
11:07:14 <Cale> matessim: Okay, if you have something like [x + x | x <- [1..10]]
11:07:23 <Cale> matessim: That has type [Integer], right?
11:07:35 <matessim> [1..10] is [Integer]
11:07:40 <Cale> (or really (Num a) => [a], but let's not worry about type classes)
11:07:54 <matessim> Cale: Okay
11:08:00 <Cale> So x :: Integer
11:08:05 <Cale> and then x + x :: Integer
11:08:18 <Cale> and that's a generic element of the list being constructed by the comprehension
11:08:30 <Cale> So the whole list comprehension has type [Integer]
11:08:51 <matessim> Cale: Right.
11:09:00 <Cale> btw, you were closer with your old version of flatten
11:09:21 <Cale> Pattern matching on the list of NestedLists isn't something you need to do.
11:09:42 <Cale> Let's go back to  flatten (NestedList xs)
11:09:48 <matessim> Alright.
11:09:52 <Cale> and examine  [flatten i | i <- xs]
11:10:05 <Cale> Here,  xs :: [NestedList a]
11:10:13 <Cale> So  i :: NestedList a
11:10:30 <matessim> ah
11:10:31 <matessim> yeah
11:10:35 <matessim> and flatten i :: [a]
11:10:38 <Cale> and so   flatten i :: [a]   (according to the type signature for flatten)
11:10:39 <matessim> so [[a]]
11:10:40 <Cale> yep
11:10:42 <Cale> right
11:10:52 <Cale> So we have a list of lists of the elements that we want
11:11:04 <Cale> We just need to make it into a single list by concatenating them
11:11:30 <Cale> Or, we could use another step in the list comprehension to iterate over the elements of  flatten i
11:11:53 <Cale> concat [flatten i | i <- xs] -- this would work
11:12:14 <Cale> [e | i <- xs, e <- flatten i] -- and this would too
11:12:30 <matessim> Cale:  i see, but isn't using concat in flatten sort of like using flatten in flatten?
11:12:39 <Cale> no
11:12:46 <Cale> concat :: [[a]] -> [a]
11:12:51 <Cale> it has nothing to do with NestedList
11:13:16 <matessim> I see.. Thanks alot Cale!.
11:13:26 <Cale> no problem :)
11:14:59 <kristof> Cale: Is there really much of a difference between contract-style assertions and making assertions using dependent-type systems?
11:15:30 <Cale> kristof: They can do similar things, but the way they do them is completely different
11:15:53 <Cale> kristof: In dependent type systems, the proofs themselves are terms and they compute something.
11:16:17 <Cale> kristof: i.e. there's no hard distinction between what is a proof of some property of a program and what is a program or what is data
11:16:38 <edwardk> > M.fromList [(1,M.fromList [(2,2)])] & at 1 . non mempty . at 2 +~ 1
11:16:39 <lambdabot>  No instance for (GHC.Show.Show a0)
11:16:40 <lambdabot>    arising from a use of `M21027034271744840954338.show_M21027034271744840954...
11:16:40 <lambdabot>  The type variable `a0' is ambiguous
11:16:40 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
11:16:40 <lambdabot>  Note: there are several potential instances:
11:16:44 <Cale> and you can prove more things by doing induction (or recursion) over the structure of another proof
11:16:52 <edwardk> > M.fromList [(1,M.fromList [(2,2)])] & at 1 . non mempty . at 2 . non 0 +~ 1
11:16:53 <lambdabot>  fromList [(1,fromList [(2,3)])]
11:16:57 <Cale> Or compute things by doing induction over the structure of a proof
11:17:13 <edwardk> dart: ^- that is how you use non
11:17:27 <edwardk> > M.fromList [(1,M.fromList [(2,2)])] & at 100 . non mempty . at 200 . non 0 +~ 1
11:17:28 <lambdabot>  fromList [(1,fromList [(2,2)]),(100,fromList [(200,1)])]
11:17:29 <Cale> kristof: For example, I might have a type of proofs that some natural number is even.
11:18:39 <Cale> data Even :: Nat -> Type where ZEven :: Even 0 ; SSEven :: forall n, Even n -> Even (S (S n))
11:19:48 <Cale> kristof: and then, to give a simple example, I could define a function to divide the even number by 2 by induction on the structure of this proof
11:20:18 <kristof> Cale: So the real problem with contracts is that they're not nearly as composable or useful as proofs?
11:20:52 <Cale> Generally speaking, I think so.
11:21:14 * hackagebot hsimport 0.2.7 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.7 (DanielTrstenjak)
11:21:20 <kristof> Is there any place, in your opinion, where Hoare style contracts are either more tractable or more powerful than dependent types?
11:21:22 <kristof> Cale: ^
11:22:25 <Cale> Well, I must admit I don't have *that* much experience working with Hoare-style contracts
11:23:39 <Cale> There was an article not long ago from someone who had lots of experience with both styles and came out strongly in favour of dependent types
11:23:44 <Cale> Let me see if I can dig that up
11:24:48 <kristof> Cale: Please do
11:24:52 <kristof> I would really appreciate that.
11:30:18 <darthdeus> hey guys, anyone got tips for learning category theory or algebra in general? i just started watching this http://www.youtube.com/watch?v=ZKmodCApZwk but not sure if i'm not skipping anything
11:30:47 <darthdeus> i'll be starting theoretical CS next semester, but i really dont wanna wait until i get to this stuff :P
11:31:12 <kristof> darthdeus: M. Artin's "Modern Algebra" is where you want to start for Abstract Algebra
11:31:52 <kristof> darthdeus: You don't actually need a tremendous amount of Abstract Algebra to learn Category Theory but it's not entirely obvious why people use category theory unless you have that foundation.
11:32:17 <darthdeus> kristof: is that a book or something? i can't seem to google it
11:32:24 <kristof> In much the same way that people would not really understand the use of abstract algebra unless there were concrete examples with... matricies for instance
11:32:37 <kristof> darthdeus: "Modern Algebra" is the title of the book, Michael Artin is the author.
11:32:46 <Cale> I think it's quite possible to learn category theory before other areas of abstract algebra
11:33:00 <Cale> eventually you might want to broaden your picture of things surely
11:33:03 <kristof> It is, but like I said, it's not obvious why you would want it
11:33:03 <darthdeus> kristof: this one? http://www.amazon.com/Algebra-Edition-Featured-Titles-Abstract/dp/0132413779
11:33:09 <Cale> I disagree
11:33:10 <darthdeus> haven't found "modern algebra"
11:33:14 <darthdeus> or my google is weird
11:33:35 <Cale> At least to the extent that you could say the same thing about group theory or ring theory
11:33:39 <kristof> Is it really just "Algebra"? Jeepers.
11:34:00 <darthdeus> well eventually i want to learn everything :P i'm just looking for the best approach since this is way more complicated than just learning a new language
11:34:34 <kristof> that really is the book, I apologize
11:34:58 <kristof> darthdeus: What's your intention of learning it, for?
11:35:50 <darthdeus> well ... i've quit a univeristy twice, with the intent to work in a real job, and after about 5-6 years of working for real job and trying out a bunch of stuff i feel that i just wanna go back and learn the whole theory behind everything
11:36:00 <darthdeus> just "programming" doesn't satisfy me
11:36:17 * hackagebot damnpacket 0.3.0 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.3.0 (JoelTaylor)
11:36:31 <darthdeus> so i decided to learn this shit once and for all and enrolled on a theoretical CS program once again :P
11:36:58 <ystael> darthdeus: The title of Artin's introductory text is simply "Algebra"; the Amazon link you posted is correct
11:37:34 <darthdeus> and ever since i started digging into haskell i kinda feel that this is something i should really understand deeply
11:37:37 <darthdeus> ystael: thanks :)
11:38:25 <ystael> You might consider Pierce, Basic category theory for computer scientists, http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing/dp/0262660717
11:40:25 <kristof> darthdeus: real programming is not structured by any theory (unless you're using Haskell). The "theory" behind programming that you might be thinking of is probably the field of computability (which covers things like state machines and turing-completeness).
11:40:51 <kristof> darthdeus: I wasn't aware of the book that ystael recommended so I might pick that up myself
11:41:05 <Cale> Real programming is structured by type theory ;)
11:41:12 <darthdeus> hm it's only 70 pages, i'll pick that one up as well :D
11:41:31 <darthdeus> well i'd say real programming is completely unstructured by anything and depressing and ugly :P
11:41:48 <kristof> Cale: I wouldn't say that that structures the actual programming itself, on the same way that you'd model a program with monoids to trivially parallelize something.
11:41:57 <erisco> darthdeus, that is hardly true
11:42:25 <erisco> even reckless code is still structured by the language it is written in
11:42:57 <ystael> kristof: If you already know some category theory it may be too basic
11:42:58 <mm_freak> darthdeus: that applies to most existing projects, but not all
11:43:00 <Hafydd> Real reckless programs don't even compile/interpret.
11:43:12 <kristof> ystael: Lame. :/
11:43:43 <darthdeus> erisco: yeah but many dynamic langauges give you so much power that the structure is more-less free form
11:43:59 <mm_freak> they give you freedom, not power
11:44:04 <mm_freak> freedom to make mistakes
11:44:23 <mm_freak> since humans love freedom, they love non-static languages
11:44:26 <platz> but there's also the danger of the perfectionist who never gets anything *done*, while the hacker's code looks terrible but they've already moved on to the next problem
11:44:54 <kristof> darthdeus: Free-form is the antithesis to structure. Free-form structure is an oxymoron. And as a huge fan of Common Lisp, I've thought very hard about the "power" that dynamic languages give, and the only idea that has every persisted is... hotloading code. But Haskell can do that now, too.
11:45:16 <sam__> Hello I was wondering if someone could give me an example to the following statement "Num is not a subclass of Ord. That means that what constitutes for a number doesn't really have to adhere to an ordering. So that's why we have to specify both the Num and Ord class constraints when doing addition or subtraction and also comparison."
11:45:35 <Hafydd> sam__: complex numbers.
11:45:45 <zipper> Anyone know of an online class teaching haskell?
11:45:57 <kristof> zipper: Learn You a Haskell
11:46:18 * hackagebot d-bus 0.0.1 - Permissively licensed D-Bus client library  http://hackage.haskell.org/package/d-bus-0.0.1 (PhilippBalzarek)
11:46:19 <zipper> For some reason they often teach scheme
11:46:20 <zipper> kristof: Class like udacity, coursera etc
11:46:20 <kristof> zipper: If you tried learning Haskell without starting there, *or* Real World Haskell, you did something wrong
11:46:35 <kristof> zipper: No, I can't think of anything. But classes are lame compared to structured textbooks.
11:46:53 <darthdeus> kristof: yeah being a long time ruby person i've also come to the conclusion that most of the dynamic features aren't that dynamic when you think about the problem in abstract way, they're just using the dynamic features of the language to make things a bit simpler
11:47:15 <zipper> kristof: I am having some trouble with higher order functions section in learn you a haskell or even folds :(
11:47:23 <sm> zipper: tryhaskell.org, fpcomplete.com, eric meijer's channel 9 lectures
11:47:25 <platz> This should be interesting if it ever happens https://twitter.com/headinthebox/status/425952535124250624
11:47:30 <sam__> Hafydd: thought about it , then realised you have to take out the modulus of it , ..makes snese makes sense
11:47:30 <zipper> kristof: So I thought a class might br good.
11:47:33 <kristof> zipper: What's so hard about 'em?
11:47:43 <kristof> zipper: #Haskell shall be your class, so ask away, friend.
11:47:57 <darthdeus> platz: yeah i'm looking forward to that
11:48:14 <zipper> kristof: Well I am really sleepy right now. So I shall ask tomorrow.
11:48:19 <zipper> Goodnight
11:48:21 <kristof> zipper: please do!
11:48:23 <kristof> goodnight!
11:48:31 <kristof> darthdeus: Can you give me an example?
11:48:31 <zipper> kristof: I sure will
11:49:14 <kristof> darthdeus: Much of the "dynamic" stuff that happens in CL or Ruby OO is run-time method redefinition... but that only matters in the context of mutable data structures, which we all know are bad anyway.
11:49:18 <zett_zelett> Will `(*2) 3` be *reduced* to `3 * 2` or is it the other way around or is it just equivalent code in some other non-reduction-context-sense?
11:49:40 <platz> darthdeus: me too, although I think he has some controversial views in comparison with the 'haskell mainstream'.  Also I took the Courera class on reactive programming he guest lecutred in, and a lot of people had problems following the way the content was presented
11:50:22 <sam__> Hafydd: actually , why would complex nos belong to Num but not Ord  ?
11:50:26 <platz> this stuff is tricky to get the right level of detail on in lecture format
11:50:41 <kristof> sam__: Evaluate this statement: 3 + 2i < 5 - 2i
11:50:57 <platz> too low and you turn people away, too high and you get too many questions and are accused of glossing over the details
11:51:21 <Hafydd> sam__: the problem with comparing complex numbers on their abs is that `compare z w' might give EQ, when z == w does not hold.
11:51:28 <gspr> platz: The other way around, no? :)
11:51:33 <Hafydd> sam__: since Ord is for totally ordered data types.
11:51:36 <sam__> kristof : wouldn't you take the modulus of each side and compare?
11:52:01 <kristof> sam__: Because of what Hafydd said.
11:52:22 <platz> gspr: well either way it's a dilemma
11:52:29 <jrmithdobbs> @pl \x y z -> x == y || x == z
11:52:30 <lambdabot> ap (flip . (((.) . (||)) .) . (==)) (==)
11:52:31 <jrmithdobbs> heh
11:52:36 <kristof> sam__: If you take the modulus of each side and compare, then... suddenly you're actually comparing the REAL NUMBERS represented by the modulus function.
11:52:43 <darthdeus> kristof: or for example how ActiveRecord loads database schema automatically from the database when you connect, so that you don't have to define it in the model directly ... which can totally be done in a static way too, because you can pull out a map with the same values and use that ...
11:52:54 <kristof> sam__: And real numbers are oderable. So you never actually compared two complex numbers anyway.
11:52:59 <gspr> sam__: By the same reasoning, one would order the reals by absolute value. But nobody wants -2 > -1, right? :)
11:53:32 <hopf> sam__: The correct solution is to find a space filling curve and define the ordering based on that =D
11:53:43 <kqr> jrmithdobbs, any (x==) [y, z]
11:53:46 <kqr> jrmithdobbs, perhaps?
11:53:48 <athan> Does anyone know of a good, cross platform ui framework? Is gtk2hs easy to port to windows?
11:53:53 <sam__> gspr: why wouldn't anyone want that?
11:53:58 <kristof> darthdeus: that.
11:54:05 <sam__> hopf : space filling curve?
11:54:19 <kristof> hopf: I laughed
11:54:20 <gspr> sam__: For the same reason anybody would want to order complex numbers by absolute value :)
11:54:25 <Hafydd> I'm not sure ordering based on a space-filling curve would be computable.
11:54:41 <Hafydd> But if you're using two finite-precision floats, you could just use some countable ordering of them.
11:54:43 <gspr> sam__: Oh, sorry, read "would"
11:54:49 <darthdeus> athan: i was told http://www.haskell.org/haskellwiki/Threepenny-gui is good
11:54:58 <gspr> sam__: You really want -2 to be greater than -1?
11:55:00 <kristof> sam__: If something is distinctly orderable, you should be able to take two distinct elements and define one as being greater than the other. If you can't, because they're of the same "greatness", then you HAVE to have two elements that are equivalent.
11:55:32 <athan> darthdeus: Thanks! I'll check it out and let you know next time I see you haha
11:55:35 <sam__> gspr: my bad , shoould have thought about that more
11:55:40 <kristof> sam__: That's the rough definition of well ordered. Being well ordered yields nice properties.
11:55:41 <gspr> sam__: :)
11:55:54 <darthdeus> athan: last time i wanted to do GUI i quickly gave up and decided to pursue other things instead :D
11:56:08 <Hafydd> gspr: that's total-ordering, not well-ordering.
11:56:16 <Hafydd> Er... kristof: ^
11:56:19 <kristof> sam__: Complex numbers organized by moduli would form a lattice structure instead. *shrug* Anyway, that's the point
11:56:20 * hackagebot d-bus 0.0.1.1 - Permissively licensed D-Bus client library  http://hackage.haskell.org/package/d-bus-0.0.1.1 (PhilippBalzarek)
11:56:23 <sam__> kristof : em could you recommend any online reads on that?
11:56:25 <kristof> Hafydd: oh, heh, you're right
11:56:40 <kristof> sam__: Online reads on what? Ordering? Maybe you want an introduction to Real Analysis
11:57:04 <athan> darthdeus: I know, right? I really want to check out Fay + Elm
11:57:15 <sam__> kristof :  :( I never make it past the set and logic intro ;
11:57:32 <kristof> sam__: Both are the absolute foundations necessary for any of this to make sense (or at least be provable)
11:57:37 <darthdeus> athan: elm is cool :)
11:57:39 <Hafydd> sam__: http://en.wikipedia.org/wiki/Ordered_set
11:57:56 <sam__> kristof : understood
11:58:06 <athan> darthdeus: I really want to make web-based ui's practical. Have you seen tideSDK?
11:58:11 <platz> I found partially ordered sets on wikipedia the other day... looked interesting but for another day
11:58:31 <darthdeus> athan: is taht like node-webkit?
11:58:59 <sam__> Hafydd : thanks for the link
11:59:02 <athan> darthdeus: Pretty much, but it does packaging + generation of an executable, too
11:59:18 <athan> darthdeus: at least I think so
12:00:41 <darthdeus> athan: hmm i should give that a try, what's the downside? :)
12:01:14 <athan> darthdeus: good question haha. I haven't tried it yet, it's on my list though
12:02:08 <mmmm> Are there any self-balancing binary trees which are nice to implement in functional languages?
12:03:27 <darthdeus> athan: the repo seems dead https://github.com/tidesdk
12:05:01 <athan> darthdeus: :/
12:05:07 <athan> darthdeus: Nvm then ><
12:15:34 <joe9>   Any haskell related comments on this functionality, please? https://github.com/joe9/xmonad-task/blob/master/XMonad/Actions/Task.hs .
12:16:04 <joe9> btw, I have a bunch of modules. I like how some authors identify the functions that they are importing from every import statement.
12:16:23 <platz> mmmm: this video explains how to implement b-tree's instead of self-balancing trees, but some of the techniques may still apply https://www.youtube.com/watch?v=VQIeBp-HXuM
12:16:28 <joe9> Is there anyway to figure out automatically all the functions used from an imported module?
12:16:54 <platz> they do a neat trick with gadt's to encode the tree height in the type to prevent errors
12:19:26 <magicman> joe9: GHC has a -ddump-minimal-imports flag, maybe play around with that.
12:20:54 <nexx> What does the ~ infront of (x,y) do? https://twitter.com/HaskellTips/status/429008096292110338
12:21:44 <platz> http://www.haskell.org/haskellwiki/Lazy_pattern_match
12:21:50 <magneticduck> nexx: http://www.haskell.org/haskellwiki/Keywords#.7E
12:22:04 <nexx> thanks
12:22:07 <magneticduck> two links are usually better than one
12:22:11 <magneticduck> if you have the time
12:28:43 <zett_zelett> (20:46:29) zett_zelett: Will `(*2) 3` be *reduced* to `3 * 2` or is it the other way around or is it just equivalent code in some other non-reduction-context-sense?  anyone?
12:29:13 <platz> just going to leave this here because it's friday (how programmers see other programmers: http://i.imgur.com/RacplFa.png)
12:29:15 <ReinH> Cale: I'm pitching a talk about math at a Ruby conference right now :)
12:29:21 <zett_zelett> Also, in the same manner, will `1:[]` be *reduced to `[1]` or is it the other way around or ?
12:29:36 <gspr> zett_zelett: I
12:29:46 <gspr> zett_zelett: I *think* the latter is sugar for the former
12:30:02 <zett_zelett> Yeah, me, too. Does anyone know for sure?
12:30:23 <gspr> zett_zelett: http://en.wikibooks.org/wiki/Haskell/Syntactic_sugar
12:30:34 <dmj`> is there a bytestring combinator library? Like a type-safe way to construct bytestrings
12:30:36 <gspr> (see Lists)
12:31:32 <ReinH> tl;dr [1,2,3] is sugar for (1 : (2 : (3:[])))
12:32:58 <dmj`> Something like "http://google" <.> "com" <?> "q" <=> "cats" <&> "q" <=> "dogs"
12:33:11 <dmj`> which would give, https://www.google.com/?q=cats&q=dogs
12:33:46 <ReinH> dmj`: you probaly want a serialization library like binary
12:34:01 <ReinH> dmj`: and whaty you'd probably want to do is write a data type that models that structure
12:34:10 <ReinH> but there is probably already a URI data type somewhere
12:34:17 <ReinH> and a way to serialize it
12:36:45 <mm_freak> dmj`: for URLs specifically with parsing and printing, you could use boomerang
12:37:08 <mm_freak> for general fast string concatenation you may want to check out Data.ByteString.Lazy.Builder
12:37:14 <mm_freak> or the more general blaze-builder package
12:37:41 <mm_freak> dmj`: btw, using ByteString for URLs is generally wrong
12:37:55 <athan> why is that?
12:38:03 <mm_freak> because URLs are text
12:38:09 <mm_freak> so you should use Text
12:38:17 <athan> ahh okay
12:38:25 <mm_freak> and there is Data.Text.Lazy.Builder, too
12:38:26 <athan> I thought it was some utf8 issue or something
12:38:31 <mm_freak> athan: it is =)
12:38:37 <athan> oh!
12:38:41 <joe9>  magicman, thanks.
12:39:57 <dmj`> mm_freak: http headers can be ascii, so bytestring.char8 might be ok too right?
12:40:14 <athan> I thought blaze-builder was just for html
12:40:24 <mm_freak> athan: no, that's blaze-html =)
12:40:51 <mm_freak> dmj`: for the raw protocol (which is defined in terms of octets) ByteString works
12:41:02 <athan> oh right on! What kind of pattern does blaze implement?
12:41:03 <mm_freak> but for anything higher-level ByteString is a dangerous choice
12:41:11 <mm_freak> athan: string concatenation
12:41:22 <mm_freak> and blockwise output
12:41:36 <athan> what makes it so fast?
12:42:05 <mm_freak> athan: it keeps the structure of the concatenation, instead of actually performing the allocations and concatenations directly
12:42:13 <mm_freak> it's in a sense a reverse parser =)
12:42:38 <dmj`> ReinH: thanks, I'll look into binary
12:42:52 <athan> Oh woah! So it's more of a concatenator generator?
12:42:56 <dmj`> mm_freak: I'll look at blaze-builder too
12:43:13 <mm_freak> when you write 'byteString "abc" <> byteString "def"', then Builder keeps it exactly like that, instead of performing the operations
12:43:30 <mm_freak> then when you output, a single string will be allocated and the builder will write the component strings into it
12:43:34 <mm_freak> this makes it very fast
12:44:05 <athan> hmm this is interesting
12:44:21 <mm_freak> dmj`: try Data.ByteString.Lazy.Builder or Data.Text.Lazy.Builder first
12:44:25 <athan> so the subroutine becomes it's own separate share of memory?
12:44:33 <mm_freak> dmj`: i think blaze-builder will be obsoleted by those
12:44:59 <zett_zelett> Exam tomorrow, part Java, part Haskell.
12:45:35 <mm_freak> athan: Builder is probably close to this:  data Builder = Builder { chunkLength :: Int, chunkString :: ByteString, chunkNext :: Builder }
12:45:52 <mm_freak> zett_zelett: good luck on the java part
12:46:01 <zett_zelett> Thanks.
12:46:43 <zett_zelett> While its great that we did Haskell at university, Im still uncomfortable with the fact that we have to do Java, well Im still uncomfortable with Java.
12:47:11 <zett_zelett> Also, its sad that we wont do Haskell anymore. :  /
12:47:30 <kristof> Java is terribad
12:47:43 <kristof> So much song and dance for simple things, so much shoe-horned into objects...
12:47:55 <zett_zelett> The guys in ##java beg to differ.
12:48:01 <kristof> "Which incantation was that for the println spell, again?"
12:48:14 <dhrosa> "AbstractSingletonProxyFactoryBean"
12:48:24 <zett_zelett> "object1.equals(object2);"
12:48:27 <levi> Java is not a great language, but it's got a really nice runtime implementation.
12:48:36 <kristof> sure
12:48:47 <kristof> millions of man hours pumped into state of the art JIT compilation. It's gold.
12:49:11 <mm_freak> s/gold/such a waste of time/
12:49:16 <kristof> But ask the Clojure, Jython, and Scala guys what they think of living on the JVM, and there will be grumbles in the corner of the room.
12:49:35 <sm> levi: speaking of gitit plugins... today's claferwiki (and clafer) look quite interesting
12:49:48 <levi> Well, it's lacking some things, but the things it has work really well.
12:49:54 <platz> dhrosa: OO is a dead end - https://jira.springsource.org/browse/SPR-8680
12:50:35 <mm_freak> https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition
12:50:40 <zett_zelett> What is this, platz?
12:50:53 <levi> sm: Hey, I was looking for something like that a few months ago...
12:50:57 <ReinH> dmj`: confirm blaze-builder is nice
12:51:01 <platz> java spring framework issue tracker
12:51:26 * hackagebot universe 0.5 - Classes for types where we know all the values  http://hackage.haskell.org/package/universe-0.5 (DanielWagner)
12:51:39 <levi> platz: Didn't you read the notes? The deprecation was deprecated.
12:52:06 <sm> levi: I'm finding dokuwiki+plantuml+markdowku really useful, but I've quickly run into the limits of a hacky markdown implementation
12:52:22 <platz> levi: hah, i didn't see that
12:52:40 <zett_zelett> I dont understand a word theyre saying there.
12:52:49 <zett_zelett> In the link you have given, platz, that is.
12:52:53 <joe9> Is it a good idea to have minimal exports in haskell files? It does not help when debugging and you want to use other functions without having to list each one.
12:53:06 <mm_freak> that's fizzbuzz in java
12:53:29 <levi> sm: Yeah, I used pandoc+plantuml for project documentation a year or two ago. I'm trying to get our department wiki switched over to gitit from an old install of mediawiki.
12:54:30 <mm_freak> oh, if you have trouble finding what this package actually implements, start here:
12:54:33 <mm_freak> https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition/blob/master/src/main/java/com/seriouscompany/business/java/fizzbuzz/packagenamingpackage/impl/FizzBuzz.java
12:55:01 <zett_zelett> Haha.
12:55:12 <sm> levi: do you do much modelling in the context of haskell code ? I haven't seen it discussed in FP circles nearly as much as in OO
12:55:34 <sm> aside from "get the types right, the rest will follow"
12:55:40 <Cale> sm: We do modelling with types
12:55:52 <Cale> Types are our UML :)
12:56:05 <sm> Cale: so you just write them down ? do you ever need a graphical diagram ?
12:56:18 <Cale> Rarely
12:56:41 <Cale> Of course, it depends on what you're doing, but generally you don't need a graphical diagram to explain your types
12:57:02 <sm> it does seem like it must depend somewhat on the complexity of what you're modelling
12:57:05 <Cale> You might want graphical diagrams of some sort to explain the concepts in your code.
12:57:34 <Cale> Like, for instance, there are graphical diagrams related to Hughes' Arrows
12:57:45 <mada> is the Reader monad implemented as the reader monad transformer over the Identity monad?
12:58:11 <mada> (not sure if "over" is the correct term here)
12:58:27 <mmmm> yes
12:58:44 <carter> HugoDaniel: my irc client auto shows picture
12:58:45 <carter> s
12:58:51 <ReinH> I mean, drawing boxes and saying "This is the X" is useful
12:59:03 <ReinH> to keep a 30k view of your system
12:59:06 <HugoDaniel> ouch! sorry carter :/
12:59:12 <mada> can't every other monad be implemented as a monad transformer over the identity monad?
12:59:14 <carter> HugoDaniel: AND i'm at work
12:59:19 <mmmm> no mada
12:59:24 <mmmm> Monads are not closed under composition
12:59:24 <sm> ReinH: right
12:59:27 <carter> HugoDaniel: could you post some emergency kittens links please ? https://twitter.com/EmrgencyKittens
12:59:33 <carter> so i can get back on channel
12:59:39 <HugoDaniel> yes
12:59:40 <HugoDaniel> sorry
12:59:45 <carter> .html pages don't render
12:59:48 <mada> hm
12:59:50 <carter> but .png etc does
12:59:51 <mada> thanks mmmm
13:00:04 <carter> https://pbs.twimg.com/media/BfVcbjoCAAAR1x8.jpg:large
13:00:07 <carter> https://pbs.twimg.com/media/BfVcbjoCAAAR1x8.jpg
13:00:14 <carter> for example
13:00:28 <carter> HugoDaniel: needs to be 2-3 such pictures for it to be safe
13:00:31 <dhrosa> hey carter, where are you from?
13:00:36 <carter> dhrosa: nyc
13:00:47 <dhrosa> okay you're someone else then
13:00:59 <carter> dhrosa: where are you thinking
13:01:13 <dhrosa> I have a classmate here named carter who's obsessed with kittens
13:01:18 <mm_freak> mmmm: what do you mean?
13:01:19 <dhrosa> at MIT
13:01:27 * hackagebot happstack-foundation 0.5.4 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.5.4 (JeremyShaw)
13:01:44 <carter> dhrosa: i really should have done MIT for undergrad, would have been happier there, its not perfect, but it'd have been a good place for me for undergrad
13:01:45 <mm_freak> <mmmm> Monads are not closed under composition
13:01:57 <carter> dhrosa: i'm the carter who's writing #numerical-haskell stuff :)
13:02:02 <mmmm> when you combine two monads, you don't always get a monad
13:02:03 <sm> I have an OO app with about 200 models, aka "types", whose meaning/existence has been lost in many cases. Boxes-and-arrows diagrams are useful for comprehension / communication
13:02:39 <mm_freak> mmmm: example?
13:03:01 <mmmm> http://stackoverflow.com/questions/13034229/concrete-example-showing-that-monads-are-not-closed-under-composition-with-proo
13:03:23 <carter> dhrosa: i'm slightly meh about the mit numerical folks using julia for their courses now, but julia is better than matlab
13:03:26 <carter> but tis a weak thing
13:03:29 <carter> dhrosa: what are you studying
13:04:14 <mada> mmmm: that's precisely what I was trying to read
13:06:09 <syllogismos> whats literate haskell?
13:06:11 <platz> I've heard a lot of data science folks are switching to python just to cut out the impedance mismatch of using different tools for data loading, munging and analysis.  not sure julia solves that
13:06:25 <carter> syllogismos: > code
13:06:28 * hackagebot web-plugins 0.2.5 - dynamic plugin system for web applications  http://hackage.haskell.org/package/web-plugins-0.2.5 (JeremyShaw)
13:06:33 <carter> or \begin{code}
13:06:36 <exicer> platz: Most people I know are using a mixture of python/r/matlab
13:06:40 <carter> bird track or latex .lhs files
13:06:52 <syllogismos> whats the point of it?
13:07:02 <byorgey> syllogismos: it's a format where everything is a comment by default, and you have to explicitly mark code
13:07:11 <k00mi> syllogismos: http://en.wikipedia.org/wiki/Literate_programming
13:07:17 <mgoszcz2> Why would anyone use (isNothing) over (==Nothing)?
13:07:20 <platz> exicer: yeah there's stuff in r and matlab python may never get to, but the common stuff is covered
13:07:52 <platz> carter: do you find the combinators in 'linear' nicer than what you get with hmatrix?
13:07:53 <carter> mgoszcz2: because isNothing won't be accidentaly monomorphic
13:08:04 <carter> platz: they're not comparable
13:08:21 <platz> ahh, well thats embarassing
13:08:23 <mgoszcz2> carter: accidentaly monomorphic?
13:08:34 <pavonia> :t (isNothing, (== Nothing))
13:08:35 <lambdabot> Eq a1 => (Maybe a -> Bool, Maybe a1 -> Bool)
13:08:35 <byorgey> mgoszcz2: because isNothing doesn't require an Eq instance for the underlying type
13:08:38 <FireFly> syllogismos: it's sometimes used for blog-posts e.g.
13:08:40 <magicman> mgoszcz2: Because (==Nothing) requires the 'a' in 'Maybe a' to be an instance of Eq.
13:08:42 <tac> mgoszcz2: why would anyone use (==Nothing) over a pattern match?
13:08:46 <allsystemsarego> > forall $ \tuple -> view _1 tuple == fst tuple
13:08:47 <lambdabot>  Not in scope: `forall'
13:08:48 <lambdabot>  Perhaps you meant `forAll' (imported from Lambdabot.Plugin.Haskell.Eval.Trus...
13:09:01 <carter> platz: linear is a dsl for graphics programmign that can be used as a model for a SIMD DSL
13:09:04 <carter> hmatrix has a lot of problems
13:09:15 <magicman> Darnit, ninja'd.
13:09:20 <carter> platz: i've a hmatrix level thing thats semi pbulic
13:10:02 <syllogismos> r is mainly used for data visualization from my understanding ggplot2
13:10:04 <tertl3> what are the good, up to date plugins for vim?
13:11:50 <exicer> syllogismos: There are some nice libraries in r that are not avaliable (at least, not to the same standard) in python
13:12:05 <platz> well, at first glance linear looks like it supports some basic matrix mult ops, but i guess not as varied as hmatrix
13:12:25 <carter> platz: hmatrix ins't very good ...
13:12:46 <platz> good to know, will attempt to stay away
13:12:52 <mm_freak> mgoszcz2_: isNothing and (== Nothing) are both bad
13:13:00 <mm_freak> mgoszcz2_: reason: http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
13:13:11 <peddie> platz: hmatrix works great for a lot of us and binds to most of the GSL, if the GPL license isn't a problem for you
13:13:45 <haasn> isNothing is bad but (== Nothing) is far worse
13:13:56 <haasn> oh, this was mentioned
13:14:15 <magicman> mm_freak: I was just reading that. Have you just been browsing through the HaskellTips twitter, too?
13:14:17 <carter> platz: depends on the use case
13:14:23 <mm_freak> magicman: no
13:14:33 <platz> yeah fair enough
13:14:35 <mm_freak> never even heard of it
13:14:58 <erisco> :t (liftA, fmap)
13:14:59 <lambdabot> (Functor f1, Applicative f) => ((a -> b) -> f a -> f b, (a1 -> b1) -> f1 a1 -> f1 b1)
13:15:19 <mm_freak> twitter requires me to make javascript exceptions all the time, which makes it unenjoyable
13:15:28 <magicman> Fair enough.
13:15:28 <erisco> any big reason to have liftA when it is equiv to fmap? just for completeness sake? ie in the series liftA*?
13:15:33 <syllogismos> tertl3: http://www.youtube.com/watch?v=ScS8Q32lMxA his setup in this video looked nice.. and its description is here http://haskelllive.com/
13:15:53 <pavonia> What's so bad about isNothing?
13:16:07 <mm_freak> erisco: there is reason to prefer fmap, because it's more common
13:16:16 <erisco> pavonia, why not use cases? it does not make much sense to convert a Maybe type to a boolean (in most cases)
13:16:20 <haasn> it's also in the Prelude
13:16:22 <mm_freak> erisco: some people might have to look up what liftA does
13:16:24 <kazagistar_> hey, I am trying to write a toy virtual machine with random indexed access... is there any way to to get something like a lazy infinte MVector?
13:16:27 <byorgey> erisco: yes, mostly for completeness I think
13:16:28 <syllogismos> i havent installed any plugins as such but set nn and mm as abbrevations to -> and >>= respectively in vimrc
13:16:29 * hackagebot clckwrks 0.22.0 - A secure, reliable content management system (CMS) and blogging platform  http://hackage.haskell.org/package/clckwrks-0.22.0 (JeremyShaw)
13:16:31 <mm_freak> pavonia: see the link
13:16:31 * hackagebot clckwrks-plugin-page 0.3.3 - support for CMS/Blogging in clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-page-0.3.3 (JeremyShaw)
13:16:38 <mm_freak> pavonia: http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
13:16:38 <erisco> mm_freak, yes but I am asking "why bother defining liftA at all"
13:16:48 <haasn> liftA mainly exists to be a default for fmap
13:16:50 <mm_freak> erisco: oh, good question =)
13:16:55 <haasn> It's implemented in terms of pure and <*>
13:16:56 <mm_freak> :t liftA
13:16:57 <lambdabot> Applicative f => (a -> b) -> f a -> f b
13:17:00 <mm_freak> oh, ok
13:17:02 <haasn> It might be less efficient than fmap.
13:17:09 <mm_freak> i always assumed that it has a Functor constraint
13:17:10 <pavonia> erisco: because it blows up code
13:17:46 <mm_freak> i'd prefer DeriveFunctor over liftA =)
13:17:56 <erisco> pavonia, in some cases it may make sense, but in general case analysis is more powerful and direct
13:18:03 <haasn> mm_freak: fair enough :)
13:18:31 <pavonia> mm_freak: Too long to read, can you give the essence in one sentence?
13:18:38 <carter> platz: whats the math stuff you do?
13:18:39 <erisco> pavonia, if isNothing m then a else b  is better as  case m of Nothing -> a; _ -> b
13:18:48 <mm_freak> pavonia: at the time you hold the True or False in your hand you have already forgotten what it means
13:19:10 <mm_freak> pavonia: example:  if not (null xs) then  head xs  else 
13:19:15 <haasn> I think I would use isNothing eg. for something like lengthOf (foo.bar.filtered isNothing)
13:19:22 <haasn> (as preferable to .only Nothing)
13:19:29 <mm_freak> at the time you branched on the True you've already lost track of why you are in the 'then' branch
13:19:36 <mm_freak> that's why you need 'head', another unsafe function
13:19:45 <mm_freak> it builds up into unnecessary complexity
13:19:48 <erisco> pavonia, and if you find yourself doing   if isNothing m then a else fromJust m    then case analysis is definitely superior
13:19:52 <mm_freak> that's the essence of "boolean blindness"
13:20:34 <haasn> mm_freak: wasn't it also about Bool not representing any form of actual truth value
13:20:54 <mgoszcz2_> What's the point of 'if' expressions at all then?
13:20:55 <mm_freak> haasn: sure, i just wanted to give a practical example =)
13:21:03 <pavonia> mm_freak: That's weird, you need booleans for conditions at some point
13:21:14 <haasn> but do you need conditions
13:21:36 <mm_freak> mgoszcz2_: sometimes boolean-blind branching is your only choice, for example when you use doesFileExist
13:21:52 <haasn> isn't doesFileExist bad
13:21:58 <mm_freak> it is
13:21:59 <napping> why would you use doesFileExist?
13:22:24 <haasn> I think half the arguments against doesFileExist are directly analogous - the Bool you get at some point holds no meaning
13:22:25 <mm_freak> it was just an example
13:22:28 <haasn> especially at later points in time
13:22:51 <mm_freak> operating systems have a sufficiently broken design such that you sometimes need boolean-blind branching
13:22:52 <levi> sm: I haven't made any haskell programs big enough to warrant OO-style models. But really, I mostly use sequence charts from UML.
13:22:53 <napping> pavonia: the point is that you need conditions, but not necessarily booleans
13:23:18 <napping> pavonia: if you have a Maybe a, it's better to pattern match on it rather than going through any intermediate boolean conditional
13:23:20 <mm_freak> it would be interesting to see where haskell would have gone when it had never introduced 'if'
13:23:23 <mm_freak> or Bool
13:23:24 <mgoszcz2_> mr_freak: Why can you do case doesFileExist of True -> False ->
13:23:29 <haasn> I wouldn't call pattern matching conditions, personally
13:23:35 <platz> carter: I was into a bit of machine learning after taking a class on it.  Then there was a data science into and they had us do the Kaggle intro.  very interesting - I like the classification/prediction type stuff
13:23:41 <mm_freak> mgoszcz2_: that's not the point
13:23:51 <carter> platz: lurk on #numerical-haskell
13:23:53 <haasn> mm_freak: not sure how you would do something like  filter isPrime though
13:23:59 <carter> i've been slowly working on building numerical hasklel tooling
13:24:05 <carter> and a bunch is starting to get ready for release
13:24:10 <carter> its still just the foundational tools
13:24:13 <carter> but tis what you need to build on top
13:24:21 <napping> haasn: It makes more sense comparing to dependently typed languages
13:24:30 <mm_freak> haasn: i guess to really get rid of Bool you need dependent types
13:24:53 <napping> then you can make your basic choice type something like Agda, along the lines of data Dec (A : Prop) where yes : A -> Dec A; no : not A -> Dec A
13:25:06 <platz> carter: cool, good luck on the release.. I'll drop by the chan from time to time
13:25:11 <carter> np
13:25:13 <mm_freak> napping: btw, Prop = Set
13:25:14 <carter> ttyl
13:25:17 <haasn> I guess the basic approach would be to have something like http://hackage.haskell.org/package/arithmoi-0.4.0.3/docs/Math-NumberTheory-Primes-Testing-Certificates.html 's Certificate?
13:25:23 <mm_freak> in recent agdas
13:25:34 <napping> mm_freak: sure, but I think calling it Prop here is more understandable
13:26:06 <mm_freak> i agree  and you can still define Prop yourself, if you really want to =)
13:26:06 <napping> haasn: then filter can have a type something like ((a : A) -> Dec (P a)) -> List A -> List A, and a proof the returned list only contains things satisfying P
13:26:41 <napping> So your predicate doesn't just return bool, but a more informative value saying what property actually holds or fails
13:27:05 <napping> and filter in turn can get a fancier type that manifestly promises to only return things that satisfy the predicate
13:27:07 <haasn> interesting
13:27:36 <napping> and getting down to convenience, if you accidentally swap the "then" and "else" cases of a branch, you'll get a type error
13:28:08 <mgoszcz2_> Why don't we just make data types to describe what something means like 'Fileexists' and 'Filedoesntexist'
13:28:22 <mm_freak> mgoszcz2_: that's also not the point
13:28:36 <mgoszcz2_> mr_freak: So what's the point?
13:28:42 <mm_freak> data ListEmpty = Empty | NonEmpty
13:28:43 <haasn> data Bool = True | False | FileNotFound
13:28:57 <mm_freak> null :: [a] -> Empty
13:29:28 <napping> mgoszcz2_: that's nice and all, but it doesn't give the compiler enough hints to let it warn you when you've switched the branches
13:29:37 <mm_freak> case not (null xs) of NonEmpty ->  head xs 
13:29:53 <haasn> not
13:29:54 <mm_freak> mgoszcz2_: as you see, it doesn't magically fix your boolean blindness
13:30:00 <mm_freak> oh
13:30:09 <mm_freak> case null xs of NonEmpty ->  head xs 
13:30:24 <napping> you mean case null xs of Empty -> ... head xs ...
13:30:38 <mm_freak> napping: no, that would be a bug
13:30:57 <haasn> that would be an example of broken but valid program
13:31:01 <haasn> which is what we're trying to avoid
13:31:01 <napping> I thought that was exactly the point, that just using suggestively named constructors doesn't prevent that sort of bug
13:31:01 <mm_freak> what i'm showing is a correct program with an unsafe application
13:31:19 <mgoszcz2_> So how do we solve boolean blindness?
13:31:20 <mm_freak> the more boolean-blind your program gets, the more such applications you will have
13:31:24 <haasn> they're both points against boolean blindness
13:31:33 <mm_freak> mgoszcz2_: in this case by pattern-matching
13:31:33 <haasn> mgoszcz2_: case xs of [] -> ...; (x:xs) -> ... x ...
13:31:39 <mm_freak> case xs of x:xs ->  x 
13:32:04 <mgoszcz2_> Yes. I understood that. What if we are dealing with doesFileExist?
13:32:16 <mm_freak> mgoszcz2_: open the file and catch exceptions
13:32:33 <mm_freak> there should be no gap between checking whether the file exists and using the file
13:33:02 <mm_freak> likewise there should be no gap between checking whether the list is non-empty and using its head
13:33:11 <zebr> hi all. if i have a list comprehension [f x : ys | x <- xs], where f used to be of type (a -> b) but is now (a -> IO b), can i fix it without losing the comprehension?
13:33:39 <mm_freak> zebr: no, but you can use mapM
13:34:05 <mgoszcz2_> mm_freak: Almost like Python: Easier to ask forgiveness than permission
13:34:05 <mm_freak> [ f x : ys | x <- xs ] = map (\x -> f x : ys) xs
13:34:26 <mm_freak> with the changed type:  mapM (fmap (: ys) . f) xs
13:34:32 <zebr> mm_freak: ah yes, that'd work great. thanks.
13:34:42 <napping> mgoszcz2_: filesystems and IO and interaction with outside systems in general is a lot harder to guarantee stuff about anyway
13:35:08 <mm_freak> mgoszcz2_: there is nothing we can do about that in this particular case
13:35:08 <mgoszcz2_> Yup. Just because a file exists doesn't mean you can read it etc.
13:35:14 <mm_freak> operating systems are designed that way
13:35:25 <napping> Unless your filesystem gives you cheap read-only snapshots, there's really no way to check now that you'll be able to read a file later
13:35:39 <mm_freak> mgoszcz2_: and just because a file exists right now, it's not guaranteed that exists a microsecond later
13:35:49 <mm_freak> that problem of course you don't have with null/head
13:36:24 <mm_freak> but it's still a bad idea to blind yourself =)
13:36:31 * hackagebot clckwrks-plugin-media 0.6.6 - media plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-media-0.6.6 (JeremyShaw)
13:36:33 * hackagebot clckwrks-plugin-bugs 0.6.7 - bug tracking plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-bugs-0.6.7 (JeremyShaw)
13:36:35 <mm_freak> so think twice before producing booleans
13:36:36 * hackagebot ircbot 0.5.4 - A library for writing irc bots  http://hackage.haskell.org/package/ircbot-0.5.4 (JeremyShaw)
13:36:56 <mm_freak> you may have to use them =)
13:37:12 <mgoszcz2_> Ok. Thanks. So for my first question (isNothing) you recommend I use (case a of Nothing ->)
13:37:40 <napping> There was a question like this? I thought someone read Harper's article
13:38:13 <napping> what are you doing with the Maybe? I think I generally use maybe or fromMaybe or something like that
13:38:22 <napping> unless I'm putting do-blocks in the case alternatives
13:40:40 <mgoszcz2_> napping: Yes. So do I, bot for this particular case it would look ugly to have a huge lambda and I felt like just using if/else to branch out.
13:41:02 <mgoszcz2_> Anyway thanks for all the help. It's nice to learn new programming concepts.
13:41:14 <napping> then a case sounds reasonable - do you really not need the value from the Maybe?
13:41:32 * hackagebot clckwrks-plugin-ircbot 0.6.7 - ircbot plugin for clckwrks  http://hackage.haskell.org/package/clckwrks-plugin-ircbot-0.6.7 (JeremyShaw)
13:41:34 * hackagebot clckwrks-theme-clckwrks 0.4.3 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-clckwrks-0.4.3 (JeremyShaw)
13:41:36 * hackagebot clckwrks-dot-com 0.3.7 - clckwrks.com  http://hackage.haskell.org/package/clckwrks-dot-com-0.3.7 (JeremyShaw)
13:41:38 * hackagebot clckwrks-theme-bootstrap 0.3.2 - simple bootstrap based template for clckwrks  http://hackage.haskell.org/package/clckwrks-theme-bootstrap-0.3.2 (JeremyShaw)
13:42:18 <mgoszcz2_> napping: I do need it. I'm using findIndex and I handle not fiding something as a speciall case.
13:42:43 <napping> ok, then case _ of Just found -> ... found ... ; Nothing -> ... -- not found
13:42:52 <napping> sounds perfectly reasonable, if you're doing lots of stuff in the actions
13:44:04 <mgoszcz2_> Yes. I did that now after following mm_freak's advice.
14:01:34 * hackagebot groundhog 0.4.1 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.4.1 (BorisLykah)
14:01:36 * hackagebot groundhog-sqlite 0.4.1 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.4.1 (BorisLykah)
14:01:38 * hackagebot groundhog-postgresql 0.4.1 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.4.1 (BorisLykah)
14:01:40 * hackagebot groundhog-mysql 0.4.1 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.4.1 (BorisLykah)
14:11:49 <mm_freak> is there a special name for a natural transformation that maps a monad to a monad?
14:12:05 <mm_freak> monad morphism?
14:12:40 <bitemyapp> mm_freak: perhaps you could say it transforms a monad into a monad?
14:12:45 <napping> That's probably what you want, if it should also preserve the monad structure
14:12:51 <Cale> mm_freak: Yeah, if it preserves the return and join in the obvious sense
14:12:58 <mm_freak> thanks
14:13:28 <Cale> mm_freak: Of course, monad transformers are a special case of this :)
14:14:02 <mm_freak> i know, but this is in the categorical sense =)
14:14:21 <bitemyapp> sorry for being a smart ass :)
14:15:00 <mm_freak> as far as i see monads and monad morphisms form a category  or am i overlooking something?
14:15:22 <napping> They really ought to
14:15:33 <napping> something is wrong if your collection of Xs and X-morphisms don't form a category
14:16:07 <mm_freak> i'm just making sure
14:16:11 <ReinH> mm_freak: right, where the arrows are natural transformations. Monads are functors, right? So this is just a subcategory of the category of functors?
14:16:25 <napping> well, maybe with some extra restrictions on the objects, like all the monads being monads on the same base category
14:16:52 <mm_freak> ReinH: i know, but i'm making sure that the monads (of all endofunctors) and monad morphisms do form a proper subcategory
14:17:14 <ReinH> sure, a properly restricted subcategory of endofunctors.
14:18:09 <ReinH> napping: the base category being the category of monoids?
14:18:12 <stolaruk> I am using Data.Text. I have Text fields in some of my data types. How can I decide whether or not I should use ! to make the text fields strict?
14:18:13 <benmachine> napping: well, a collection of types where the morphisms were monads between types would not be a category
14:18:19 <benmachine> it's not a completely trivial thing
14:18:37 <mm_freak> i have never proved that natural transformations have an associative composition operator  i just assumed that they do
14:18:38 <benmachine> stolaruk: I've been told that the answer is "usually yes"
14:18:41 <ReinH> stolaruk: tl;dr you probably should
14:18:45 <benmachine> mm_freak: fun fact: they have two
14:18:47 <stolaruk> ok cool
14:18:59 <mm_freak> benmachine: how?
14:19:08 <ReinH> stolaruk: unless your type is some form of higher order combiner of texts
14:19:30 <stolaruk> ReinH: I don't think so :)
14:20:17 <mm_freak> stolaruk: in general you don't have to
14:20:20 <napping> benmachine: I mean if you have some kind of Foos, and you want to call some things Foo-morphisms, they darn well ought to form a category
14:20:33 <mm_freak> stolaruk: it's better to make your functions strict enough
14:20:44 <napping> benmachine: that would be a reason not to call monads "type morphisms", for example
14:21:01 <benmachine> mm_freak: given F, G : C  D and H, K : B  C, you can compose  : F  G with  : H  K to get  : FH  GK
14:21:55 <benmachine> mm_freak: this is called "horizontal composition" vs. "vertical composition" which is the more obvious one
14:22:21 <benmachine> mm_freak: try working out how to define it without looking it up thought
14:22:23 <benmachine> *though
14:22:49 <ReinH> napping: we have type morphisms. They're called functions. ;)
14:23:05 <benmachine> ReinH: those aren't type morphisms
14:23:19 <benmachine> well, I guess they are
14:23:25 <ReinH> they are in Hask
14:23:26 <benmachine> but that's not what I meant :P
14:23:28 <ReinH> ok :p
14:23:45 <ReinH> I guess I should find out what category you're talking about first :D
14:23:54 <lispy> @seen ddarius
14:23:54 <lambdabot> ddArIu5
14:24:01 <lispy> oh right
14:24:12 <benmachine> preflex: seen ddarius
14:24:18 <benmachine> is that not still a thing
14:24:26 <benmachine> I guess preflex is not currently a thing
14:24:29 <lispy> So much for stalking people!
14:24:45 <lispy> @leet So much for stalking people!
14:24:45 <lambdabot> sO /\/\uC|-| 4 s7A1KING Pe0p|e!
14:27:24 <mm_freak> benmachine: interesting  so if i have Maybe -> Either () and Reader s -> State s, it gives me a MaybeT (Reader s) -> EitherT () (State s)?
14:28:02 <benmachine> mm_freak: sounds plausible
14:28:20 <benmachine> after I mentally adjusted for MaybeT m = m . Maybe
14:28:34 <mm_freak> yeah =)
14:28:44 <benmachine> and EitherT () m = m . Either ()
14:28:46 <benmachine> yeah
14:29:04 <mm_freak> or use the monad composition operator of your choice
14:29:41 <mm_freak> but i find those suspicious
14:29:52 <benmachine> mm
14:32:13 <jle`> mm_freak: are you ertes? is ertes.de still up anywhere?
14:36:02 <piezoid> is it possible to express with typeclasses or type families that a functor applied two times is the identity at the type level ?
14:36:38 <mm_freak> jle`: i'm ertes, and ertes.de is down right now
14:36:56 <ReinH> piezoid: er. "a functor applied two times"?
14:37:17 <piezoid> ReinH: f (f a) = a
14:37:21 <mm_freak> piezoid: like Maybe (Maybe a)  a?
14:37:29 <ReinH> mm_freak: but it isn't
14:37:33 <mm_freak> except for something other than Maybe =)
14:37:33 <mmmm> Can anyone tell me which extension he says here? https://www.youtube.com/watch?v=VQIeBp-HXuM#t=440
14:37:38 <Cale> piezoid: I suppose you could define a class which gave maps in both directions between those
14:37:49 <Cale> piezoid: and assert that it's an isomorphism
14:38:17 <Philonous> mmmm, DataKinds and GADTs
14:38:20 <ReinH> Maybe (Maybe a) ~= data DoubleMaybe a = JustJust a | JustNothing | Nothing
14:38:36 <mm_freak> Maybe (Maybe a)  Either Bool a
14:38:49 <IRCChatInfo> Info about irc please read it http://p.pw/DLV
14:39:06 <benmachine> 1 + (1 + a) = 2 + a
14:39:06 <piezoid> i have newtype Reverse cat a b = Reverse cat b a
14:39:24 <ReinH> piezoid: is that true for anything other than Identity?
14:39:31 <piezoid> so Reverse (Reverse cat) ? cat
14:39:48 <benmachine> piezoid: just guessing, I think you want Reverse (cat b a) on the RHS
14:40:03 <byorgey> piezoid: it is not possible in Haskell to literally have  Reverse (Reverse cat) a b ~ cat a b
14:40:03 <piezoid> benmachine: oh yes, sorry
14:40:10 <byorgey> you will have to do something like what Cale suggests
14:40:15 <Philonous> mmmm, Sorry, he _says_ "DataKinds"
14:40:47 <mmmm> yes I got it thanks
14:41:04 <benmachine> Maybe (Maybe [()]) ~= [()]
14:41:18 <benmachine> just sayin'
14:42:21 <piezoid> byorgey: ok, I'll try that
14:42:58 <ReinH> benmachine: how so?
14:43:33 <benmachine> ReinH: Nothing <-> []; Just Nothing <-> [()]; Just (Just xs) <-> () : () : xs
14:44:24 <ReinH> benmachine: so 1 + 1 + 1* = 1*?
14:44:36 <benmachine> yeah
14:44:44 <benmachine> I guess
14:44:45 <ReinH> makes sense
14:44:49 <benmachine> depending on what you mean by *
14:47:28 <byorgey> a* = 1 + a*
14:47:40 <apples`> sounds tropical!
14:47:46 <byorgey> i.e. Kleene star, i.e. lists
14:47:52 <ReinH> yes, Kleene star
14:47:54 <ReinH> sorry, disconnected
14:48:12 <ReinH> specifically the free monoid with one generator
14:49:02 <augur> byorgey: what does this mean a* = 1 + a*
14:49:18 <byorgey> augur: that is the definition of *
14:49:25 <augur> er..
14:49:27 <augur> in what sense
14:49:40 <byorgey> oh, sorry, should be  a* = 1 + a.a*
14:50:05 <augur> in what system?
14:50:45 <byorgey> + and . are the operations of a semiring
14:50:52 <augur> aha ok
14:52:29 <jle`> mmmm: temporily, or indefinitely? :'(
14:52:38 <jle`> * mm_freak
15:11:56 <randomclown> if I write into a Chan and there's nobody to read it
15:12:00 <randomclown> does it get queued?
15:12:53 <bitemyapp> randomclown: what's a chan?
15:13:09 <bitemyapp> randomclown: what does queued mean?
15:13:09 <randomclown> Control.Concurrent.Chan
15:13:09 <apples`> writes are non-blocking, iirc
15:13:27 <bitemyapp> randomclown: it seems like you're assuming a chan is a memory-reified collection of some kind.
15:13:43 <bitemyapp> randomclown: it could just be a state machine.
15:14:03 <bitemyapp> randomclown: in this case, they are mvars, but still.
15:14:32 <bitemyapp> randomclown: if you're not using Synchronous, apples` is right.
15:15:14 <randomclown> if I dupChan a channel
15:15:42 <randomclown> and some things are written to the original one
15:15:51 <randomclown> but not read, are they held in memory?
15:17:39 <StoneCypher> apples` is never right
15:20:13 <Cale> randomclown: If you write to a Chan, and keep a reference to the Chan, but don't read from it, then its contents will remain in memory.
15:20:47 <Cale> You can write an arbitrarily large amount of data to a Chan and fill up all the space on your machine if you like.
15:21:47 <jle`> if a tree falls in a forest and nobody is around to hear it, does it make a sound?
15:22:13 <randomclown> still leave a space leak apparently jle`
15:22:44 <blaenk> how can I read a specific amount of bytes from a file (pipe in this case)? the only function I've found is ByteString's hGet and hGetSome, are these the only ones for this?
15:23:43 <randomclown> blaenk: probably don't even need pipe for that
15:23:50 <blaenk> what
15:24:10 <jmcarthur_mobile> randomclown: I don't think blaenk is talking about the library
15:24:15 <blaenk> the file is a pipe, not the haskell pipe library
15:24:45 <randomclown> you can use the binary parsing monad Data.Binary.Get?
15:25:03 <jmcarthur_mobile> Not for IO
15:25:11 <randomclown> but you'll probably still need to read into a buffer first
15:25:14 <jmcarthur_mobile> Unless using lazy IO, but...
15:25:19 <blaenk> I'll use ByteString's, I'm just wondering if that's the preferred way to do it
15:27:23 <levi> ByteStrings are a common choice for holding chunks of arbitrary data.
15:27:34 <blaenk> thanks levi
15:27:52 <blaenk> I saw this on hGetContent's documentation: " As with hGet, the string representation in the file is assumed to be ISO-8859-1. "
15:28:25 <blaenk> eh, nvm, just wondering how that works out if I wanted utf8 instead
15:28:31 <levi> They come in two varieties; strict bytestrings and lazy bytestrings.
15:28:49 <levi> If you want to interpret the bytestring as text, you may want to use Data.Text
15:29:18 <levi> There is also Data.ByteString.UTF8, though
15:30:39 <blaenk> yeah unfortunately neither seem to have an hGet or hGetSome-like function. hmmm
15:30:49 <blaenk> I'll give this a try
15:31:45 <levi> You typically get a chunk of data as a bytestring, then decode it into text depending on the character encoding.
15:31:54 <blaenk> ahh okay that's what I was wondering, thanks levi!
15:32:37 <joelteon> yeah, you can't read Text bytewise from a socket
15:32:45 <blaenk> :/
15:33:00 <levi> http://hackage.haskell.org/package/text-1.1.0.0/docs/Data-Text.html
15:33:26 <joelteon> just philosophically speaking, blaenk
15:33:32 <joelteon> one Char can be represented by multiple bytes
15:33:38 <blaenk> yeah I was thinking about that too
15:33:41 <blaenk> wouldn't make sense I guess
15:34:20 <levi> See the note on Fusion in that page, if you are worried about performance.
15:34:28 <blaenk> yeah I know, thanks :D
15:34:34 <mm_freak> jle`: temporarily  but i don't know how long
15:35:02 <[PaddleGoats]u_> hello
15:35:21 <[PaddleGoats]u_> i have some source code with lots of constant declarations
15:35:35 <[PaddleGoats]u_> what's the easiest way to edit those?
15:35:46 <[PaddleGoats]u_> automatically, saving the file
15:35:54 <levi> ... with an editor?
15:36:01 <simpson> [PaddleGoats]u_: Could you give an example?
15:36:05 <levi> I'm not sure what you're asking.
15:36:36 <[PaddleGoats]u_> simpson: i have a file with "static final PARAMETER = 4;" and i want to write a script that changes this to 5,6 etc. and tests it out
15:37:00 <[PaddleGoats]u_> last time i used the basic file IO stuff and put a $ next to it
15:37:04 <[PaddleGoats]u_> but it was kinda clunky
15:37:15 <[PaddleGoats]u_> ie reads until it sees the $ and then replaces
15:37:21 <simpson> [PaddleGoats]u_: Uh, this is #haskell.
15:37:34 <[PaddleGoats]u_> simpson: i'm editing a java file but i know haskell better
15:37:38 <jle`> i think he wants a preprocessor
15:37:45 <[PaddleGoats]u_> yeah and i don't wanna mess around with the build system
15:37:51 <levi> Well, you could use haskell, or you could use sed.
15:37:53 <[PaddleGoats]u_> just parse and change the file
15:37:58 <[PaddleGoats]u_> sed?
15:38:05 <[PaddleGoats]u_> thirst
15:38:06 <jle`> yeah this sounds liek a good job for the unix/bash family of tools
15:38:12 <jle`> @google sed
15:38:12 <[PaddleGoats]u_> ok ill check that out
15:38:13 <lambdabot> http://www.grymoire.com/unix/sed.html
15:38:13 <lambdabot> Title: Sed - An Introduction and Tutorial
15:38:14 <[PaddleGoats]u_> thanks
15:38:14 <levi> It's a unix command line tool, a 'stream editor'
15:38:35 <jle`> mm_freak: ah thanks
15:38:46 <peddie> [PaddleGoats]u_: I've used the 'language-c' package to do automatic structured editing of C programs before; maybe there's a similar one for Java
15:39:08 <[PaddleGoats]u_> http://hackage.haskell.org/package/language-java yup
15:39:13 <[PaddleGoats]u_> this could also be useful, thanks
15:39:36 <levi> I'm guessing that attempting to do structured editing in a programmatic way would be a bit overkill in this situation.
15:41:45 <[PaddleGoats]u_> levi there's actually other stuff like inlining i would want to do to the file if i had time
15:42:55 <blaenk> hey, if I want to use ByteString.Char8's Show/Read instances, do I have to specify anythign in my qualified import parentheses?
15:43:45 <Fuuzetsu> @. pl undo f (x, y) = do { x' <- x; y' <- y; return (x', y') }
15:43:45 <lambdabot> (line 1, column 55):
15:43:45 <lambdabot> unexpected ';'
15:43:45 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
15:43:50 <Fuuzetsu> @undo f (x, y) = do { x' <- x; y' <- y; return (x', y') }
15:43:50 <lambdabot> f (x, y) = x >>= \ x' -> y >>= \ y' -> return (x', y');
15:43:52 <blaenk> I'm trying to use read for example and I'm getting an error that it expected a String not a C.ByteString
15:44:01 <Fuuzetsu> @pl f (x, y) = x >>= \ x' -> y >>= \ y' -> return (x', y');
15:44:01 <lambdabot> (line 1, column 55):
15:44:01 <lambdabot> unexpected ';'
15:44:01 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
15:44:11 <Fuuzetsu> @pl f (x, y) = x >>= \ x' -> y >>= \ y' -> return (x', y')
15:44:12 <lambdabot> f = uncurry (liftM2 (,))
15:44:17 <blaenk> am I supposed to also add show/read to the imported names within the parentheses?
15:44:39 <blaenk> nah that didn't work
15:46:19 <Cale> blaenk: What are you trying to do?
15:46:33 <Cale> blaenk: That sounds like you tried to supply aByteString to read
15:46:51 <blaenk> I'm using Data.ByteString.Char8, imported qualified and specific names (hGet, etc.) and I want to use the read and show functions
15:46:53 <blaenk> on them
15:47:04 <Cale> On what?
15:47:09 <Cale> :t read
15:47:09 <lambdabot> Read a => String -> a
15:47:12 <blaenk> on a ByteString
15:47:14 <geekosaur> blaenk: Read and Show depend on String, ByteString would have to implement every type's Read and Show itself
15:47:17 <Cale> ^^ read specifically takes a String argument
15:47:25 <Cale> But it can *produce* a ByteString
15:47:36 <blaenk> eh, sorry then I was confused, since I saw that it implemented Read and Show instances, I guess I should've looked at the source
15:47:38 <gspr> Does one need pipes-safe to do cleanups etc if a pipe terminates, or am I just confused? Say I have a p :: Producer a IO () and that I need to run a certain cleanup :: IO () when the pipe p feeds terminates. How do I do that?
15:47:58 <Cale> blaenk: It doesn't really require looking at the source. It's just how read and show work :)
15:48:09 <blaenk> thanks, for making me feel more dumb, then
15:48:13 <geekosaur> blaenk: you'll want to use pack and unpack with Read and Show
15:48:19 <blaenk> cool thanks geekosaur
15:49:01 <Cale> blaenk: Sorry, I just wanted to make that clear -- in order to use read given input of type ByteString you must convert to a String first
15:49:02 <gspr> *"the pipe THAT p feeds"
15:49:12 <blaenk> Cale: I understand, thanks though, it's much appreciated
15:49:49 <blaenk> I guess I'm still confused though, what advantage is there in it declaring Show/Read instances then?
15:50:15 <Cale> blaenk: Read instances specify how to turn String values into values of the type you write the instance for.
15:50:28 <geekosaur> those instances say how to encode a ByteString value to a String, and how to get the ByteString back from such an encoded value
15:50:30 <Cale> Show instances specify how to turn values of the type you write the instance for into String values.
15:50:47 <geekosaur> think of them as serialization/deserialization, but the serialized form is *always* String
15:50:49 <Cale> > show (BS.pack "hello")
15:50:50 <lambdabot>  Couldn't match type `GHC.Types.Char' with `GHC.Word.Word8'
15:50:50 <lambdabot>  Expected type: [GHC.Word.Word8]
15:50:50 <lambdabot>    Actual type: [GHC.Types.Char]
15:50:53 <blaenk> so in the case of show, I can just do show bytestring?
15:50:54 <Cale> > show (BSC.pack "hello")
15:50:55 <lambdabot>  "\"hello\""
15:51:03 <blaenk> ahh okay
15:51:08 <blaenk> it's read that needs unpack
15:51:39 <geekosaur> (and this is one of the reasons that show/read are not really recommended for serialization...)
15:51:52 <geekosaur> (more for debugging and quick prototyping/proof of concept)
15:53:00 <StoneCypher> so how many lines could i get into trying to convince people that visual basic is the future before i got banned for trolling
15:53:03 <blaenk> I just need to parse a ByteString into an Int
15:53:21 <blaenk> StoneCypher: you're getting banned for stating the obvious, we're past that here
15:53:35 <StoneCypher> oh you're no fun
16:01:45 <tertl3> hello
16:03:04 <tertl3> lets have a discussion
16:03:20 <tertl3> with passionate debates
16:03:54 <levi> As long as it's about Haskell
16:04:28 <tertl3> im looking for cool videos at programing language conferences
16:04:42 <tertl3> or LUGS
16:04:48 <tertl3> or anything
16:05:09 <levi> Youtube and Vimeo have a number of Haskell-related videos.
16:05:27 <peddie> tertl3: https://skillsmatter.com/conferences/1549-haskell-exchange
16:06:50 <mm_freak> ok, let me spark a passionate debate:  it came a long way, but i started hating the word "user"
16:06:54 <fragamus> ugh cat somebody remind me what the logical not operator is
16:06:55 <fragamus> can*
16:07:04 <mm_freak> fragamus: not
16:07:11 <fragamus> doh!
16:09:11 <FireFly> mm_freak: why?
16:09:27 <mm_freak> FireFly: what's the first thing you think of when you hear the word "user"?
16:10:18 <FireFly> mm_freak: someone who makes use of some service or thing, I guess
16:10:46 <FireFly> or maybe I thought for too long. It's hard to capture first thoughts
16:11:07 <Eduard_Munteanu> What's a nice lib to do SSL client/server stuff? Linux-only is fine.
16:11:28 <mm_freak> FireFly: the problem i have with "user" is that especially in commercial settings there are so many bad pre- and misconceptions  and software is designed with those in mind
16:11:36 <mm_freak> Eduard_Munteanu: tls
16:11:40 <levi> I think there's a Haskell-only TLS implementation, and at least one binding to OpenSSL.
16:12:18 <mm_freak> yes, tls is pure haskell
16:12:33 <benmachine> mm_freak: do you really hate "user", or do you hate commercial settings
16:12:40 <Eduard_Munteanu> mm_freak: hm... should I be concerned about it being a native implementation vs using a popular lib?
16:12:53 <mm_freak> benmachine: i can't hate commercial settings, because then i'd hate myself, which i don't =)
16:13:08 <benmachine> you're a commercial setting?
16:13:20 <mm_freak> benmachine: no, but i create commercial settings
16:13:37 <benmachine> oh, well, hating things you create isn't hating yourself
16:13:44 <benmachine> and in any case plenty of people do either/both
16:13:50 <mm_freak> Eduard_Munteanu: no, vincent does good work
16:14:15 <benmachine> Eduard_Munteanu: it depends on your application, would be my guess
16:14:25 <benmachine> but I find all security software innately terrifying, so.
16:14:37 <mm_freak> Eduard_Munteanu: right now in pure haskell implementations i'd be a bit wary, because i think that not every single function is hardened against side channel attacks
16:14:59 <mm_freak> but other than that, it's probably fine
16:15:02 <Eduard_Munteanu> Heh, I was just thinking about that... well, timing attacks in particular.
16:15:08 <benmachine> "probably" :P
16:15:33 <benmachine> my instinct would be that things like OpenSSL have had more eyes on them for longer
16:15:47 <benmachine> but hey, maybe tls is niche enough that the NSA haven't tried to sabotage it yet
16:15:48 <Eduard_Munteanu> What's the openssl-based alternative?
16:15:50 <mm_freak> Eduard_Munteanu: at least vincent is very aware that these things exist  but ultimately you'll have to read the source code (at least the comments)
16:16:02 <djahandarie> benmachine, OpenSSL has had more eyes on it for longer, but it's also a terrible codebase.
16:16:19 <benmachine> djahandarie: so I've heard
16:16:27 <benmachine> these things are hard to quantify
16:16:41 <Eduard_Munteanu> mm_freak: alright, thanks
16:16:44 <mm_freak> benmachine: well, then let me answer more simply:  no, i don't hate commercial settings, but i hate it when people design software with preconceptions about "users"
16:17:10 <benmachine> but how about this as a perspective: if anyone finds a fault in OpenSSL, they'll have much more interesting things to do than whatever it is you're doing :P
16:17:11 <djahandarie> Isn't designing software with preconceptions of users the cornerstone of good design of software?
16:17:22 <Eduard_Munteanu> openssl made one terrible decision IMO when they decided it should sneakingly use /dev/urandom no matter what for long-term key generation. I'm rather disappointed. :(
16:17:33 <mm_freak> Eduard_Munteanu: at least tls is used in practice
16:17:37 <benmachine> yeah, I've gotta say, people with preconceptions don't annoy me as much as people with no conceptions at all
16:18:03 <Eduard_Munteanu> mm_freak: oh? I guess Yesod stuff?
16:18:09 <djahandarie> (My statement coming from the perspective of user interface design.)
16:18:23 <djahandarie> ("Knowing your audience" is pretty critically important.)
16:18:26 <orion> Hi. How do you differentiate between ()'s used to make a tuple, and ()'s used for grouping?
16:18:31 <mm_freak> Eduard_Munteanu: i think all haskell web frameworks use it
16:18:47 <benmachine> orion: by the presence or absence of commas
16:19:03 <benmachine> orion: note that there is no one-element tuple
16:19:08 <orion> ahh, true
16:19:11 <orion> thank you
16:19:33 <mm_freak> benmachine: every time i have to touch my colleague's windows computer i'm reminded how stupid i must be in the view of software developers
16:19:36 <tertl3> I live in a small hut in the mountains of Kumano Kod on Kii Hant and would not like to be contacted.
16:19:52 <mornfall> mm_freak: what'd ya mean?
16:20:22 <mm_freak> mornfall: tertl3 asked us to have a passionate debate =)
16:21:00 <mornfall> about windows and software developers? :-)
16:21:23 <tertl3> haskell for .NET
16:21:25 <derekv> http://lpaste.net/99321
16:21:55 <tertl3> GHC is becomming so big that its almost as big as .NET and JVM
16:22:03 <derekv> Simple type error, but I don't get it, can anyone see what I'm missing?
16:22:29 <Eduard_Munteanu> Hm, I guess I can also pipe stuff to gnutls-cli or some such.
16:22:32 <mm_freak> mornfall: no, my original statement was:  it came a long way, but i started hating the word "user"
16:22:53 <tertl3> someone rewrote Unix toolset in Haskell?
16:23:14 <tertl3> re write GCC in Haskell
16:23:38 <benmachine> derekv: the entire error message would be helpful
16:26:36 <derekv> benmachine: edited http://lpaste.net/99321
16:26:49 <levi> derekv: Well, you are saying that function takes a list of lists of Position, while the compiler disagrees. You might try commenting out the type declaration and asking in ghci what it thinks the type is then. Then see if it does what you expect.
16:26:51 <platz> platz: I've had this nick for a few years
16:26:54 <nisstyre> tertl3-laptop: rewriting gcc in haskell would be feasible
16:27:18 <derekv> levi: good idea
16:28:49 <benmachine> derekv: fwiw I don't see any obvious error in the code
16:28:56 <levi> derekv: Alternatively, ask ghci what the types of MS.unions, MS.fromList, and map are.
16:29:01 <benmachine> might be worth double-checking that you're trying to compile the correct version, etc.
16:29:20 <levi> Then you can put them together and decide whether you got the type or the implementation wrong. :)
16:29:37 <derekv> countAllTheThings :: Ord a => [[a]] -> MS.MultiSet a
16:30:12 <derekv> all good ideas.. need a minute to apply them ;)
16:30:59 <derekv> actually might as well go with the more general definition
16:31:17 <benmachine> sure, why not
16:34:28 <Fuuzetsu> I wish one could do sections like [`this` foo bar, `that` baz qux]
16:36:22 <levi> derekv: BTW, it compiled for me as-is.
16:36:34 <benmachine> :t [`elem` words "x y"]
16:36:35 <lambdabot>     A section must be enclosed in parentheses
16:36:35 <lambdabot>       thus: (`elem` words "x y")
16:36:43 <benmachine> hm, I see
16:36:50 <jmcarthur> how about an operator for flip then?
16:37:28 <jmcarthur> :t let (><) = flip in [words >< "x y"]
16:37:28 <lambdabot>     Couldn't match type `[String]' with `[Char] -> c0'
16:37:29 <lambdabot>     Expected type: String -> [Char] -> c0
16:37:29 <lambdabot>       Actual type: String -> [String]
16:37:35 <benmachine> I used to like the idea of operators for flip but it only really works when you only have one more argument
16:37:43 <jmcarthur> derp, words isn't binary
16:37:50 <derekv> benmachine: levi: suddenly it works... not sure it wasn't something goofy with cabal or my environment
16:37:58 <benmachine> derekv: mm, that can happen
16:38:01 <levi> derekv: You didn't have a function that called countAllTheThings before, did you?
16:38:27 <derekv> levi: maybe ... I probably changed its definition
16:38:49 <levi> Hmm. Weird. Glad you got it working, though!
16:39:16 <ReinH> jmcarthur: ?? is flip in lens
16:39:42 <derekv> maybe just needed a cabal clean ...
16:39:47 <derekv> levi: thanks
16:40:27 <derekv> actually get to the business of seeing if this approach to doing the life game works
16:41:30 <ReinH> jmcarthur: except it works over functors generally, not just (r->)
16:42:24 <tertl3> thnks for the links
16:42:26 <tertl3> bro
16:43:14 <benmachine> derekv: it's not usually necessary to clean things, GHC is good at detecting when they need to be done
16:43:27 <benmachine> derekv: it's more usually a case of accidentally not saving a file, or reading the wrong version, or something
16:44:36 <derekv> benmachine: could be that it wasn't saved ... usually emacs will ask me if I run the compile without a file being saved but maybe something was out of whack
16:48:02 <levi> derekv: Once you finish, you might try looking around at other implementations. There are some interesting comonadic ones.
16:51:54 * hackagebot shelly 1.4.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.2 (GregWeber)
16:52:09 <derekv> levi: Not sure I'm ready, I'm still slackjawed about the different approaches fibonacci
16:53:18 <levi> Heh. The wiki page on different approaches to prime number generation is pretty interesting, too.
16:53:28 <levi> And there's always "The Evolution of a Haskell Programmer"
16:55:09 <tertl3> clear
16:55:19 <tertl3> hi
16:55:21 <tertl3> thnks for the links
16:57:11 <levi> http://www.willamette.edu/~fruehr/haskell/evolution.html
16:58:03 <levi> Wow, I haven't looked at that in a while. Most of it actually makes some sense now. :P
16:58:08 <orion> I am reading Real World Haskell and came across this statement: customerID :: Customer -> Int
16:58:16 <orion> What does this line mean?
16:58:22 <orion> Why is it necessary?
16:58:30 <geekosaur> it's a type signature for a function
16:58:36 <nisstyre> orion: it's an accessor function
16:58:44 <Tekmo> orion: What language are you most familiar with?
16:59:05 <joelteon> is it possible to use a profiling report to track down a stack overflow?
16:59:18 <nisstyre> orion: if you're familiar with object oriented languages, it's analogous to a customerID property of a Customer object
16:59:25 <nisstyre> except...not, here
16:59:34 <nisstyre> in this case Customer is a type
16:59:41 <bitemyapp> a product type, to be specific.
16:59:52 <Tekmo> orion: IT means that `cusomterID` is a function that takes a `Customer` as input and returns an `Int` as output
17:00:40 <bitemyapp> Tekmo: you failed the turing test modulo spelling error with that answer, but it's gloriously correct.
17:01:07 <levi> joelteon: I would guess that it could help. There's an option to include stack info in the memory profile output, at least.
17:01:16 <joelteon> which option is that?
17:01:16 <Tekmo> bitemyapp: :)
17:01:52 <Tekmo> bitemyapp: Maybe I'm from the deep south in the US or something
17:01:54 <bitemyapp> Tekmo: I try to answer in a way that optimizes compact-ness and googleability.
17:02:03 <bitemyapp> Tekmo: aren't you in the Yay like me?
17:02:21 <Tekmo> bitemyapp: I currently live in San Francisco, but I'm originally from Texas
17:02:25 <bitemyapp> bad news? requires that people google.
17:02:37 <bitemyapp> Tekmo: I'm currently in SF, considering fucking off to Austin or Seattle.
17:02:44 <Tekmo> bitemyapp: Neat!
17:02:53 <bitemyapp> Tekmo: work in SOMA at the moment.
17:02:55 <Tekmo> bitemyapp: I actually plan to go to Austin in a few years
17:03:05 <levi> joelteon: I don't remember, I was looking in the ghc manual and playing with profiling a bit earlier this week.
17:03:12 <Tekmo> bitemyapp: We need to hang out soon
17:03:21 <joelteon> okay
17:03:31 <Tekmo> bitemyapp: I'm currently in Vietnam on vacation, but I'll be back in mid-February
17:03:32 <orion> Tekmo: I am most familiar with C.
17:03:42 <bitemyapp> Tekmo: I'm trying to get jfischoff to organize a Haskell hacking thingy sometime. He might be trying to sync it up with you.
17:03:46 <Tekmo> orion: Think of that line as analogous to a C function prototype
17:03:58 <orion> Why is the prototype necessary?
17:04:04 <bitemyapp> so, it looks like I have a reason to stay in the area at least until then.
17:04:08 <Tekmo> orion: In C the equivalent code would be: int customerID(struct customer);
17:04:21 <Tekmo> orion: It's not necessary
17:04:23 <Tekmo> orion: You can omit it
17:04:32 <Tekmo> bitemyapp: :)
17:04:39 <levi> orion: It's not usually *necessary* to write type declarations like that, but it's common practice to do it for top-level definitions.
17:04:41 <Tekmo> bitemyapp: Yeah, I meet up with Jonathan all the time, too
17:04:48 <Tekmo> bitemyapp: We definitely should organize something
17:05:08 <bitemyapp> I'll be the newbie. This'll be great.
17:05:12 <Tekmo> bitemyapp: :)
17:05:22 <orion> http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
17:05:27 <orion> -- file: ch03/AltCustomer.hs
17:06:00 <orion> In the "Record Syntax" section.
17:06:12 <orion> "This is almost exactly identical in meaning to the following, more familiar form."
17:06:25 <orion> So, in other words they put in more code than they needed to, just because they felt like it.
17:06:38 <Tekmo> orion: Yes
17:06:53 <Tekmo> orion: Type signatures are for the benefit of people reading the code
17:07:02 <feldaur> Hey guys. I'm trying to generate a list of length-30 strings containing all possible combinations of "0" and "1". My instinct says replicate is what I want to use, but I can't get a good algorithm out of my head. Any ideas?
17:07:03 <orion> So why not make them comments?
17:07:03 <Tekmo> orion: Many times the compiler does not need them
17:07:05 <levi> But not *just* because they felt like it. Because it's standard practice to annotate the types of the top level definitions in your program.
17:07:08 <bitemyapp> I only elide type sigs in scripts.
17:07:14 <Tekmo> orion: Why would you want to make them comments?
17:07:16 <bitemyapp> anything I'm "keeping" gets explicit types otherwise.
17:07:32 <Tekmo> orion: The benefit of not making the comments is that the compiler can check them to make sure they are correct
17:07:35 <orion> It seems like type sigs are for documentation.
17:07:43 <Tekmo> orion: If you make it a comment it could be incorrect, and therefore be a misleading comment
17:07:49 <orion> ok
17:07:49 <Rflax40> Hey, when I try to build haskell with GHC out of sublime2 it gives me parsing errors. I am new to haskell any help?
17:07:55 <Eduard_Munteanu> orion: type sigs are for correctness too, they are checked unlike comments
17:07:56 <levi> orion: Sometimes, specifying the type gives it a more specific one than the compiler would infer. This can help with error messages.
17:08:10 <orion> That makes sense.
17:08:24 <jedai> feldaur: that will be a big list... 2^30 ~ 10^9 * 30
17:08:35 <feldaur> Rflax40: Are you using tabs?
17:08:58 <Eduard_Munteanu> orion: also certain type system extensions make it impossible to infer all types
17:09:05 <nisstyre> orion: also if you give something a type right away then even if it would type check without the explicit type you will get an error showing that you did something wrong
17:09:05 <Rflax40> Ah no, should I tab the functions off the same line as the module?
17:09:11 <Tekmo> orion: Also, like levi said, you can give a function a narrower type than its most general type
17:09:17 <Tekmo> orion: This sometimes help when debugging type errors
17:09:38 <jedai> feldaur: though if you consume it at the same time that should be ok (investigate replicateM)
17:09:41 <Eduard_Munteanu> Also the inferred type may be too general or too specific, depending on context.
17:09:52 <derekv> ho man thats awesome... it does work
17:09:52 <Tekmo> orion: When you have type error problems it very frequently helps to give the function the type that you think it should have and then the compiler can point out where your type signature does not match the function
17:09:54 <feldaur> jedai: I'm aware. If it were smaller, I wouldn't bother trying to be clever about it. Come to think of it, this wouldn't be an issue if I were clever to begin with.
17:10:02 <Eduard_Munteanu> Generally you know the type ahead of time and the implementation is stuff you "figure out".
17:10:55 <orion> ok
17:11:16 <orion> New question: Is Prelude basically libc++ for Haskell?
17:11:33 <bitemyapp> derferk.
17:11:57 <jedai> feldaur: replicateM seems to do ok, though it's probably not the best solution
17:11:57 <bitemyapp> orion: http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html just look at what it implements
17:12:04 <Tekmo> orion: Yeah, it's very similar
17:12:05 <orion> ok
17:12:18 <feldaur> orion: I think of it more as Java's java.lang
17:12:37 <bitemyapp> orion: Try using this to learn Haskell - https://github.com/NICTA/course
17:12:40 <feldaur> orion: There's more in the lib, but Prelude is what you get right away
17:12:44 <Tekmo> orion: It's basically a starter pack to get you going, but you'll frequently find you want to switch from the defaults
17:12:49 <Eduard_Munteanu> orion: it's more like the stdlib for C, although it's not quite comparable because higher-level languages give more functionality via the stdlib.
17:12:52 <orion> bitemyapp: Real World Haskell is no good?
17:13:08 <bitemyapp> orion: RWH is a good resource but I do not think it's a good way to learn Haskell.
17:13:16 <bitemyapp> I use it as more of a reference/guide to specific topics.
17:13:18 <Tekmo> orion: The most common place where you want to deviate from the Prelude is to use Text instead of String
17:13:39 <Eduard_Munteanu> Actually it's a selection of stuff from standard libraries, in Haskell.
17:14:07 <Tekmo> orion: Unlike libc/libc++ you don't have to import it
17:14:17 <Tekmo> Oops, sorry
17:14:18 <orion> Tekmo: If I am deviating *from* Prelude, where am I deviating *to*?
17:14:21 <Tekmo> I was confusing it with stdlib
17:15:01 <Tekmo> orion: Mainly use Text instead of String and learn how to use data types other than lists
17:15:22 <Eduard_Munteanu> orion: depends... you may be using more of the standard libs, or you might go for an external library, or one of the alternate Preludes out there.
17:15:22 <Tekmo> orion: Some really good data type libraries to use are `containers`, `unordered-containers`, and `vector`
17:15:24 <orion> Tekmo: What provides Text?
17:15:28 <Tekmo> orion: The `text` package
17:15:34 <Tekmo> orion: It comes with the Haskell Platform
17:15:34 <orion> 3rd party?
17:15:50 <orion> ok
17:15:57 <Tekmo> orion: All Haskell packages are available on Hackage
17:15:59 <mmmm> Programming traditional data structures in haskell is very frustrating
17:16:07 <Tekmo> orion: You install them using `cabal install <package_name>`
17:16:17 <Kaidelong> "traditional data structures?"
17:16:28 <Eduard_Munteanu> orion: depends what you're asking about... Text isn't *standard* Haskell, yet it's a base library in HP.
17:16:39 <Tekmo> mmmm: Functional data structures are a pleasure to use.  You should try them
17:16:41 <Kaidelong> most of the data structures you learn about in university these days aren't that hard to do in ML-likes
17:16:57 * hackagebot damnpacket 0.3.1 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.3.1 (JoelTaylor)
17:16:58 <maxiepoo> my grandfather's hash tables
17:17:06 <Kaidelong> I don't know how much the old C-style of building them out of pointers still persists
17:17:18 <Kaidelong> (in pedagogy anyway)
17:18:00 <orion> bitemyapp: How do I run the course? The README seems lacking (I have ghci loaded).
17:18:02 <Eduard_Munteanu> Kaidelong: most programming is taught using rather low-level languages these days, AFAICT
17:18:06 <bitemyapp> orion: cabal repl
17:18:21 <bitemyapp> orion: cabal sandbox init && cabal install && cabal repl
17:18:25 <Eduard_Munteanu> Perhaps except the advent of Java and C#.
17:18:34 <Rflax40> Where can I find an example fo formatting for haskell programs?
17:18:37 <Kaidelong> Eduard_Munteanu: exactly, Java and C# seem to be the favorites now
17:18:48 <Eduard_Munteanu> But thinking about it, we were taught C in highschool! :)
17:18:58 <maxiepoo> At my uni it's C for all the systems courses but C# for the data structures course
17:19:08 <maxiepoo> and racket for the pl stuff
17:19:25 <orion> bitemyapp: ? The README doesn't say anything about cabal.
17:19:30 <Tekmo> orion: Just to clarify, `cabal sandbox` sets up a local package sandbox.  You don't necessarily need to sandbox your programs but it will help if you are not familiar with how to resolve package conflicts
17:19:45 <orion> Except for tests
17:19:54 <Tekmo> orion: The main downside is that it increases installation times because you need to reinstall many packages for each sandbox you set up
17:20:00 <Kaidelong> I guess haskell does have the issue that a pure hash table doesn't make a lot of sense
17:20:07 <Kaidelong> but it wouldn't be too hard to implement
17:20:23 <Kaidelong> just horrendously inefficient
17:20:39 <Tekmo> So zippers are basically the functional analog of pointers
17:20:41 <orion> I don't understand why I need to use cabal. I already loaded all the modules in ghci.
17:20:51 <Tekmo> The main difference is that it is painful to manage multiple zippers currently
17:20:52 <maxiepoo> well you can just use a trie where the key is some hash, right?
17:21:14 <Tekmo> However, they have the same performance properties as pointers: O(1) lookup and O(1) local motions
17:21:14 <maxiepoo> that would be the pure functional version of a hash table
17:21:28 <maxiepoo> but O(logn) instead of O(1)
17:21:33 <Tekmo> I wish somebody would basically come up with a way to convert pointer-based code to type-checked zipper-based code
17:21:49 <maxiepoo> Tekmo, from what language?
17:21:58 <Kaidelong> maxiepoo: Right, you trade increased lookup times for getting sharing back without mutation
17:22:12 <maxiepoo> that might be fun to try
17:22:19 <mmmm> guess I'll try again tomorrow
17:22:21 <Tekmo> maxiepoo: Any language.  I'm not really interested in the syntax so much as how to model multiple pointers without insanely huge types
17:22:57 <Kaidelong> maxiepoo: I guess you could use hash tables for memoization in a pure way
17:22:58 <platz> Do pointers imply a data structure like zippers do?
17:23:10 <platz> i thought all they had was a width
17:23:12 <Kaidelong> but you would need unsafePerformIO
17:23:12 <Eduard_Munteanu> Tekmo: well, how do you get a zipper for an array without some notion of indexing? :)
17:23:26 <Tekmo> platz: I'm referring to zippers modeling pointers only in their capacity for implementing data structures
17:23:53 <Tekmo> Eduard_Munteanu: Yeah, that's the part where I hand-wave a lot
17:23:57 <bitemyapp> hash table log(constant) isn't as compelling or reliable as people think
17:24:04 <Tekmo> Eduard_Munteanu: This is why I want somebody else to do it :)
17:24:10 <Eduard_Munteanu> Heh.
17:24:21 <orion> This course is confusing.
17:24:34 <orion> I have no idea what to do. Do I edit files? do I type something on command line?
17:24:39 <Tekmo> Eduard_Munteanu: I'm pretty sure Edward has some ideas for how to do this
17:24:40 <Eduard_Munteanu> I guess you could trivially implement any pointer-y structure using indices.
17:24:46 <maxiepoo> well the other advantage of tries versus impure hash tables is the impure version can regress to linear time
17:24:52 <bitemyapp> orion: Do this first if you can't figure it out initially: http://yannesposito.com/Scratch/en/blog/Haskell-the-Hard-Way/
17:24:59 <Eduard_Munteanu> Then you can pretend "oh, it's a store comonad, not pointers". :P
17:25:04 <mmmm> For things like RB trees or splay trees though, I don't see any other way but horrdendous nested pattern matches
17:25:16 <orion> bitemyapp: Directions unclear.
17:25:37 <Tekmo> orion: what OS are you using?
17:25:41 <bitemyapp> orion: directions unclear, I am now a potted plant? :)
17:25:46 <Saizan> orion: definitions in files, the use ghci to load them and test in the repl
17:25:56 <bitemyapp> orion: I'm saying you can do the esposito tutorial to learn basic Haskell semantics and then go back to the course.
17:26:15 <Eduard_Munteanu> Tekmo: I've seen some papers on n-hole contexts / higher derivatives if you need to keep multiple "pointers".
17:26:28 <maxiepoo> mmm, have you seen purely functional red-black trees in Okasaki's "Purely Functional Data Structures"?
17:26:42 <orion> Tekmo: FreeBSD. I already loaded the course in ghci.
17:26:54 <mmmm> yes I've read his work
17:26:55 <maxiepoo> they are a lot simpler than the impure version
17:26:58 * hackagebot damnpacket 0.3.2 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.3.2 (JoelTaylor)
17:27:00 * hackagebot damnpacket 0.4.0 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.4.0 (JoelTaylor)
17:27:02 * hackagebot damnpacket 0.4.1 - Parsing dAmn packets  http://hackage.haskell.org/package/damnpacket-0.4.1 (JoelTaylor)
17:27:03 <Tekmo> Eduard_Munteanu: Is it easy to vary `n` (i.e. to add or delete a pointer from an existing structure)?
17:27:15 <joelteon> I wish you could delete packages
17:27:23 <orion> "The first recommend exercise is Course.List." <-- README
17:27:27 <bitemyapp> starting to think I should do a "learn Haskell!" video demonstrating how to use NICTA/course
17:27:34 <Tekmo> orion: You can interactively run files using `ghci` or you can compile them using `ghc`
17:27:36 <bitemyapp> orion: yeap, that's a great place to start!
17:27:39 <orion> Ok, I get that that's the first recommended course.
17:27:43 <orion> But how do I "use" it?
17:27:46 <orion> Do I execute something?
17:27:52 <bitemyapp> orion: seems like a reasonable idea.
17:28:09 <Kaidelong> is there anything out there that provides "yield" in do syntax for MonadPlus? Can it be implemented?
17:28:16 <Kaidelong> as in, without extending the language
17:28:17 <Eduard_Munteanu> Tekmo: no. Another problem I encountered while trying to make zippers for imperative structures is you can't really update the structure without tearing down all references and recreating them, even if there are multiple such refs.
17:28:29 <Tekmo> orion: There's an interactive web page for the same course.  Hold on one second
17:28:39 <Kaidelong> the fact that, by default sequencing is interpreted as >> indicates to me no
17:28:44 <bitemyapp> Tekmo: oh wow, really? I didn't know that.
17:28:48 <Tekmo> orion: https://www.fpcomplete.com/school/starting-with-haskell/haskell-fast-hard
17:29:04 <Tekmo> orion: Here is the first one: https://www.fpcomplete.com/school/starting-with-haskell/haskell-fast-hard/haskell-fast-hard-part-1
17:29:10 <Tekmo> orion: You can run the examples in your browser
17:29:20 <orion> I just don't understand how to start with Course.List. There's no indication to me what command within ghci I should execute to begin the course.
17:29:24 <Eduard_Munteanu> Tekmo: e.g. try keeping "pointers" to leaves in a tree for fast access
17:29:51 <Tekmo> Eduard_Munteanu: Hmmm.  You're right
17:30:00 <Eduard_Munteanu> Any such zipper in isolation is fine, but you can't actually keep more of them around.
17:30:13 <Kaidelong> IE being able to do { yield x; yield y } instead of { x' <- x; y' <- y; mplus (return x') (return y') }
17:30:47 <Kaidelong> err
17:30:50 <Kaidelong> I meant
17:31:01 <orion> Tekmo, bitemyapp?
17:31:22 <Kaidelong> well I guess that's not entirely correct but it kind of illustrates the idea
17:31:39 <bitemyapp> orion: :l innit?
17:32:25 <orion> target `innit' is not a module name or a source file
17:32:47 <Tekmo> Kaidelong: You mean like the `pipes` yield?
17:32:51 <benmachine> Kaidelong: I don't understand your idea
17:33:04 <benmachine> what is it meant to do?
17:33:24 <Tekmo> Kaidelong: So the neat thing about `pipes` is that there is an exact analog to what you just described
17:33:31 <orion> bitemyapp: target `innit' is not a module name or a source file
17:33:35 <Tekmo> Kaidelong: Check this out
17:33:36 <bitemyapp> orion: http://www.urbandictionary.com/define.php?term=innit
17:33:55 <Tekmo> Kaidelong: Select (yield x >> yield y) = mplus (return x) (return y)
17:33:55 <bitemyapp> orion: but now you know how to load modules, so s'all good.
17:34:31 <Tekmo> Kaidelong: This is because the `MonadPlus` instance for `ListT` uses `(>>)` for `Producer`s to implement `mplus`
17:35:24 <Tekmo> Kaidelong: Here's the relevant code (for (<|>), same as `mplus`): https://www.fpcomplete.com/school/starting-with-haskell/haskell-fast-hard/haskell-fast-hard-part-1
17:35:27 <Tekmo> Oops, wrong link
17:35:29 <Tekmo> https://github.com/Gabriel439/Haskell-Pipes-Library/blob/master/src/Pipes.hs#L346
17:35:39 <orion> bitemyapp: I don't understand -- when I ran ghci, all the courses were loaded all at once.
17:35:45 <orion> There is nothing more to load.
17:37:18 <Tekmo> orion: What are you trying to run?
17:40:46 <orion> Tekmo: Course.List
17:41:09 <Tekmo> orion: What is that from?
17:42:22 <orion> Tekmo: The github repository bitemyapp told me about.
17:42:43 <orion> I cloned the repository, changed directory to it, and ran ghci, like the README told me to.
17:43:00 <orion> Now I am at a loss for what specific thing to do to launch the course.
17:43:29 <Tekmo> orion: Can you link the repository?
17:44:20 <jfischoff> is there a description of how to write blog posts for FPComplete?
17:44:27 <jfischoff> how does one get inline code?
17:44:28 <Tekmo> jfischoff: It's pretty easy
17:44:56 <Tekmo> jfischoff: Oh, you have to surround it with something like "```activehaskel ... ```".  Let me find the instructions
17:44:57 <orion> Tekmo: < bitemyapp> orion: Try using this to learn Haskell - https://github.com/NICTA/course
17:45:29 <Tekmo> jfischoff: https://www.fpcomplete.com/school/using-fphc/how-to-use-the-school-of-haskell/soh-markdown
17:45:45 <jfischoff> thanks
17:46:17 <levi> orion: I don't think it's an "interactive" course. I.e., it's not going to ask you questions.
17:46:27 <AshyIsMe> i think im starting to understand the power of haskell a tiny bit
17:46:46 <jfischoff> oh awesome
17:46:47 <AshyIsMe> working on a vindinium bot and it's amazing how much the compiler knows before i even get to run
17:46:53 <Tekmo> orion: You're supposed to edit the source files, load them into ghci, and then use ghci to confirm that your solution worked
17:46:57 <Tekmo> jfischoff: You're welcome
17:47:04 <jfischoff> :)
17:47:18 <AshyIsMe> the type system is just like "bugs, bugs everywhere young padawan"
17:47:25 <Tekmo> orion: The exercises are in the source code
17:47:29 <orion> oh
17:47:40 <orion> That was very much unclear to me.
17:48:49 <levi> orion: Look at the files in the src/Course directory. Each one covers the topic it's named after, and will have a bunch of functions that have 'error "todo"' as their implemenation.
17:49:39 <levi> Because the return value of the error function typechecks for any type, you can load the tutorial just fine, but attempting to run any functions will throw an error.
17:49:56 <orion> ok
17:50:00 <orion> thank you
17:50:33 <levi> When a module is named 'Course.List', you will find it in src/Course/List.hs
17:52:30 <levi> Some of the files include doctests in the comments. The readme talks about how to run the tests for individual files, or you can do 'cabal test' to run all the tests.
17:54:37 <orion> ok
18:20:26 <sm> AshyIsMe: that looks fun
18:22:44 * sm watches the latest game in progress: http://vindinium.org/x5wbxd2f
18:29:24 <udoprog> Using a Data.Map.Strict, what would be the most convenient way for me to map over all it's elements and apply a monadic function to them?
18:29:34 <Guest12943> does anyone know if there is a channel for Happy (the parser) specific discussions?
18:30:23 <Feuerbach> Guest12943: there probably isn't. Feel free to ask here
18:30:32 <Taneb> udoprog, Data.Traversable.traverse/mapM
18:30:35 <levi> Guest12943: I don't think so. This would be a fine place to ask, though I'm not sure how much Happy expertise there is among the channel members active at the moment.
18:32:01 <udoprog> Taneb: neat, thanks!
18:32:34 <Taneb> :)
18:36:57 * bristlesquirrel finally got logged init's been awhile since IRC.
18:38:13 <pranz> welcome back
18:38:31 <bristlesquirrel> Okay, so I have Happy grammer here: http://pastie.org/8687376. It's parsing just fine until it hits methods and vars. it seems to never get out of varlist
18:38:41 <hiptobecubic> indeed. somehow i never time to idle anymore :(
18:39:06 <bristlesquirrel> I have no shift/reduce conflicts at the moment. give me a second pull up some sample code.
18:39:36 <chaoslynx> hi, i am trying to figure out how to parse a layout sensitive language with trifecta. It seemed to have support for that, but it was later dropped
18:39:58 <cswords> Is it possible to convince the haskell's show *not* to evaluate its arguments?
18:40:52 <Feuerbach> instance Show MyType where show _ = "foo"
18:41:10 <cswords> My type is integers...
18:41:13 <cswords> I meant in general.
18:41:22 <cswords> I want to get back (2 + 4)
18:41:24 <cswords> Instead of 6
18:41:28 <Feuerbach> no
18:41:42 <Feuerbach> only by defining your own type
18:41:48 <Saizan> > 2 + 4 :: Expr
18:41:48 <Feuerbach> which could be an arithmetic AST
18:41:49 <lambdabot>  2 + 4
18:42:01 <Saizan> someone done that for you, btw :)
18:42:09 <cswords> That's not really going to work...
18:42:29 <cswords> I'm going to have to rewrite half this paper with small-step semantics now...
18:42:30 <bristlesquirrel> sample code: http://pastie.org/8687385. the parse fails at the ( of start()
18:44:56 <Saizan> bristlesquirrel: i think you are on the wrong channel, this one is about haskell
18:45:22 <bristlesquirrel> Saizan: I'm asking about Happy, the complier-compiler for Haskell.
18:45:22 <Feuerbach> Saizan: his parser is in Haskell and uses happy
18:45:35 <Feuerbach> (or her)
18:46:04 <Saizan> oh, sorry
18:46:23 <bristlesquirrel> Saizan: np
18:47:42 <tertl3> so Ive learned monad appicative conduit
18:47:50 <tertl3> im doing good
18:48:23 <tertl3> right?
18:48:27 <tertl3> i need reassurance
18:49:36 <bristlesquirrel> tertl3: learning monad anything could be considered success. :)
18:58:09 <chaoslynx> has anyone implemented layout sensitive parsing with trifecta >= 1.0
18:58:11 <chaoslynx> ?
19:00:25 <pavonia> bristlesquirrel: The problem seems VarList and MethodList start with the same non-terminal
19:01:55 <bristlesquirrel> pavonia: correct. in the grammer I'm parsing, they both start with an Id. is there another way to accomplish this I'm missing?
19:07:27 <pavonia> Hhm, I can't think of one :S
19:07:59 <augur> pavonia: are you favonia
19:08:08 <pavonia> no
19:08:17 <augur> how confusing!
19:08:29 <pavonia> indeed!
19:08:57 <bristlesquirrel> pavonia: so you're saying there's no way to have two non-terminals that start with the same non-terminal? :_/
19:09:05 <levi> Hmm, does Happy care about the ordering of productions?
19:09:28 <bristlesquirrel> levi: it doesn't seem to...what are you thinking?
19:10:41 <pavonia> bristlesquirrel: I'm not sure
19:12:30 <japesinator> I'm trying to write a function that takes a list, an index, and a value and returns another list equal to the first except for the given index, which is changed to the given value
19:13:41 <japesinator> hoogle turns up http://hackage.haskell.org/package/cgi-3001.1.8.4/docs/Network-CGI-Protocol.html#v:replace, but that isn't really what I'm looking for (takes a value, not an index) and is in network.cgi.protocol
19:14:19 <levi> bristlesquirrel: Well, you have VarList as VarList Var | {- Empty -}. The similar example in the manual lists the empty production first. I don't imagine that makes a difference, but I'm not very familiar with Happy.
19:14:25 <Eduard_Munteanu> japesinator: a list isn't quite appropriate if you need to do that often
19:14:27 <Tehnix> what is the standard procedure for deprecating a package version of a library that has a bug? (or do we even though that?)
19:14:41 <Tehnix> s/though/do .. wow
19:15:00 <bristlesquirrel> japesinator: so you want signature of f :: [a0] -> Int -> a0 -> [a0]?
19:15:21 <japesinator> Edward_Munt:  What would you reccomend?
19:15:42 <japesinator> brittlesquirrel:  yes
19:16:08 <bristlesquirrel> levi: ahhI'll try it. I'm pretty sure it doesn't matter. there aren't too many people around that 1) know Haskell and 2) have written a complier in it. it's really hard to find help.
19:16:08 <Eduard_Munteanu> japesinator: Data.Map would be fine. Also Data.Sequence.
19:16:14 <heatsink> Idk.  Is Hackage an immutable data structure?
19:16:27 <heatsink> You can insert packages, but not delete them
19:17:24 <Tehnix> heatsink: pretty sure you can deprecate them -- https://hackage.haskell.org/packages/deprecated
19:17:43 <Tehnix> in this case, it's just a specific version
19:17:45 <Eduard_Munteanu> Once in a while someone forgets to make backups (who needs them in a pure world?) and the occasional disaster cleans up the leftovers. :P
19:18:24 <levi> bristlesquirrel: Well, a lot of people use combinator-based parsers.
19:18:37 <heatsink> So... everything's a weak reference, Eduard_Munteanu?
19:19:12 <Tehnix> heatsink: though it seems deletion is not a thing -- https://github.com/haskell/hackage-server/issues/112
19:19:52 <dr0b3rts> japesinator: You can use splitAt like this:
19:19:54 <dr0b3rts> > let (h,t)=splitAt 5 [0..10] in h++99:tail t
19:19:55 <lambdabot>  [0,1,2,3,4,99,6,7,8,9,10]
19:20:01 <Eduard_Munteanu> heatsink: assuming the occasional disaster cares :P
19:20:13 <bristlesquirrel> levi: oh? like Parsec or ?
19:20:32 <japesinator> dr0berts: Thanks, I think I'll try that
19:22:05 <levi> bristlesquirrel: Parsec, Attoparsec, Trifecta, uu-parsinglib, etc.
19:22:27 <bristlesquirrel> levi: thanks!
19:23:18 <levi> bristlesquirrel: I don't think having two productions starting with id should be a problem, though, as long as the next token disambiguates things.
19:24:34 <bristlesquirrel> levi: right. that's the idea of a lookahead. that's my biggest confusion as to why it's not working. one id is followed by ( and one by something else
19:26:33 <pavonia> I think the problem is that this is an LR(2) grammar
19:27:12 * hackagebot shelly 1.4.3 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.3 (GregWeber)
19:27:14 * hackagebot shelly-extra 0.3 - shelly features that require extra dependencies  http://hackage.haskell.org/package/shelly-extra-0.3 (GregWeber)
19:29:33 <bristlesquirrel> pavonia: that would be problematic. it's supposed to be only LALR(1). the rest of my classmates are implementing their parsers in sablecc which is LALR(1)
19:30:56 <simpson> IIRC it's always possible to convert LL(k) to LL(1) by table expansion...
19:31:00 <bristlesquirrel> pavonia: but I do see what you meanI think Var is definitely requiring more than (1)
19:32:52 <levi> You could try running Happy in GLR mode.
19:43:20 <levi> Hmm, I'm not seeing where the second lookahead token is needed. What am I missing?
19:48:10 <levi> bristlesquirrel: I think the problem may be in the definition of MethodList.
19:48:27 <levi> You say MethodList is MethodList Method | end
19:51:43 <levi>  There doesn't seem to be any way to parse a method definition followed by an end token with that production, although I think you could parse just an end token or an end token followed by a single method definition.
19:53:25 <scshunt> Can anyone offer any good advice on when a datatype should be concrete (say, as a record) with various fields that are filled in, versus when it should be a typeclass?
19:55:13 <heatsink> Type classes are for describing ways that some data types behave similarly to one another
19:55:27 <heatsink> so that functions can generalize over them
19:55:39 <levi> So when you hit the ( in the parse, it fails the possibility of a var, but it also fails the possibility of a method, because you didn't have an end token before.
19:55:51 <heatsink> So if you want to define a new data type, that's just a data type
19:56:39 <heatsink> If several data types exhibit the same properties, that's a type class
19:56:59 <bristlesquirrel> levi: ahhyes.
19:57:48 <bristlesquirrel> levi: you, sir. are a genius! thank you. I just had to flip MethodList & Method and it parsed happily.
19:58:19 <levi> Just a sucker for a puzzle. :)
19:59:58 <bristlesquirrel> levi: :) I know the feeling. I definitely bit off more than I could chew on this project, but that's the way I roll. (I'm 1) learning haskell and 2) studying compilers for the first time beyond cursory introductions, and 3) writing a compiler in haskell.)
20:00:22 <levi> I did the same thing in my compiler class.
20:00:30 <carter> o/ heatsink
20:00:42 <bristlesquirrel> levi: you passed, I take it? :)
20:00:43 <heatsink> Hi carter
20:01:00 <carter> heatsink: guess what: in ghci in 7.8, you can use llvm-general!
20:01:10 <carter> i'm still getting started playing with ith
20:01:13 <carter> but i'm excited!
20:01:18 <levi> bristlesquirrel: Yup. I definitely had some moments of anxiety, though.
20:01:40 <MorehouseJ09> -- run our worker series start, end, prev1 prev2
20:01:40 <heatsink> Sounds good
20:01:42 <MorehouseJ09> tailRecursionSeries n = go 0 n 0 []
20:01:45 <MorehouseJ09> 	where go current n a
20:01:47 <MorehouseJ09> 		| current == n = a -- return the accumulation set
20:01:48 <bristlesquirrel> levi: what was the "standard" toolset for your project?
20:01:50 <MorehouseJ09> 		| current == 0 = go (current + 2) n [1]
20:01:52 <MorehouseJ09> 		| current == 1 = go (current + 1) n  1 : a
20:01:55 <MorehouseJ09> 		| otherwise = go (current + 1) n n : a
20:01:55 <levi> bristlesquirrel: I wasn't allowed to use a parser generator, so I re-implemented some basic monadic parsing combinators.
20:02:01 <MorehouseJ09> copy doesn't look good, but I'm trying to debug this - can't compile
20:02:06 <scshunt> heatsink: ok, so how do I know when something is represented by a single versus many data types?
20:02:11 <heatsink> I tried to install llvm-general-pure, but ran into a bug that was fixed 2 weeks ago
20:02:11 <levi> Most people used C# or Java, I think. And hand-wrote a recursive-descent parser.
20:03:01 <heatsink> scshunt, you want to represent each thing by one data type.  Some numbers have type Integer.  Some numbers have type Complex Float.  No number has both types.
20:03:20 <bristlesquirrel> levi: ouch. everybody but me is using Java + SableCC. thankfully my professor is understanding and quite willing to help.
20:03:36 <levi> My compiler's haskell ended up *very* imperative in structure due to the way in which we were asked to code it.
20:03:53 <heatsink> What are you going to do with llvm, carter?
20:04:32 <levi> I was hoping to parse to an AST and do tree transformations, but that was highly discouraged.
20:04:43 <levi> And I didn't want to go *too* much off on my own.
20:04:45 <scshunt> heatsink: thanks
20:05:23 <bristlesquirrel> levi: that's sad. my professor did his compiler in Clojure, so I'm assuming he'll be a bit more flexible in regards to how we do the various parts. was your output assembly?
20:06:00 <levi> bristlesquirrel: It was assembly for a simulated CPU architecture we'd created the simulator for in a computer architecture class.
20:06:17 <levi> bristlesquirrel: I wrote the simulator in Scheme. :)
20:07:00 <bristlesquirrel> levi: we did a simulator for ARM. I wrote mine in Go (to learn it, as well). :) our compilers will output x86 ASM, I think.
20:08:19 <levi> This particular professor preferred to build compilers in Prolog, actually, and used Prolog in his data structures class. Which seems like an odd choice for a data structures class, but he was a bit of an odd guy. But I guess he figured compilers were hard enough without trying to teach Prolog at the same time.
20:08:51 <levi> Which ARM instruction set did you simulate, though? ;)
20:09:08 <bristlesquirrel> levi: ha! we did an interpreter in Prolog. quite the experience.
20:09:50 <levi> Haskell's type class resolution is somewhat akin to prolog, actually.
20:10:25 <bristlesquirrel> levi: https://github.com/lseelenbinder/armsim <- it was the subset of instructions defined there. nothing super bad, but basic math and IO was definitely feasible.
20:10:44 <carter> heatsink: having not hosed simd pre 7.10 :)
20:10:54 <bristlesquirrel> levi: the subset is defined thereof the arm instructions*
20:10:57 <heatsink> What?
20:11:28 <carter> heatsink: i hoping to hackout at a wee dsl that i then compile at runtime via llvm
20:11:35 <carter> that vectorizes array arith into simd ops
20:11:40 <heatsink> Ooh
20:11:48 <heatsink> That would be nice
20:11:50 <carter> yeah
20:12:03 <carter> with 7.8 having a better linker for ghci
20:12:07 <jmcarthur> Level 1: Use type classes like you would use object-oriented classes. Level 2: Use type classes like you would use Java interfaces. Level 3: Use type classes like they were intended. Level 4: Use type classes in ways the designers did not foresee.
20:12:17 * hackagebot mighttpd2 3.0.3 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-3.0.3 (KazuYamamoto)
20:12:21 <carter> level 5: you are now oleg
20:12:40 <carter> o/ jmcarthur
20:12:46 <jmcarthur> \o
20:12:58 <bristlesquirrel> level 6: prove turing completeness in typeclasses
20:13:12 <carter> bristlesquirrel: eh, thaats easy
20:13:22 <jmcarthur> I think stopping at Level 4 is enough. :)
20:13:46 <heatsink> level 7: Add type class extensions to GHC
20:13:49 <levi> bristlesquirrel: Ah, that's a nice little subset.
20:13:49 <carter> jmcarthur: the freaky friday sequel where you're now oleg would be a good gag movie
20:13:55 <carter> heatsink: easier than you think
20:13:58 <jmcarthur> heatsink: okay, I'll give you that one
20:14:06 <jmcarthur> but maybe not a Level 7 thing, as carter hints
20:14:09 <carter> yeah
20:14:22 <jmcarthur> I'd put that at Level 5.
20:14:31 <bristlesquirrel> levi: he wrote a really simple OS for us in C to allow for IO and stuff. pretty cool experience.
20:14:31 <carter> i'd say 3.5
20:14:42 <jmcarthur> you have to reach Level 4 just to know the pain points
20:14:59 <jmcarthur> and beyond to know how to fix them
20:15:06 <levi> bristlesquirrel: Sounds like a fun class.
20:15:17 <carter> fair
20:15:33 <carter> didn't say any level 3.5 type class patched would get merged in :P
20:15:39 <jmcarthur> heh
20:16:04 <jmcarthur> IO in C would be awesome, but sadly most people mean I/O when they say stuff like that. :(
20:16:05 <carter> jmcarthur: did i tell you about the time i built ghc with a patched numerical prelude?
20:16:18 <jmcarthur> nope
20:16:23 <carter> it actually built
20:16:34 <carter> only 3 test cases in the fast test suite failed afaict
20:17:10 <levi> Standard haskell uses type classes for more than they were originally intended now, i.e. constructor classes. Thank goodness those got included in Haskell proper.
20:17:28 <jmcarthur> "constructor classes?
20:17:42 <levi> Type classes of kind * -> *
20:17:54 <carter> you mean like functor?
20:17:59 <levi> Yeah, and Monad.
20:17:59 <carter> that was in th eoriginal design
20:18:08 <jmcarthur> oh, they originally all had kind   * -> Constraint?
20:18:11 <levi> No, they were not in the original type classes.
20:18:15 <carter> which ones?
20:18:21 <carter> they' in  h98...
20:18:21 <levi> They originated in gofer.
20:18:26 <carter> ok
20:18:30 <levi> h98 was not the original haskell.
20:18:39 <carter> H 1.3 / 1.4 had em
20:18:52 <levi> Go back further.
20:19:10 <jmcarthur> in some ways i kind of liked the old uses of type classes, such as for seq
20:19:32 <carter> when did the seq type class get phased out?
20:19:37 <carter> i remember use it
20:19:48 <jmcarthur> you do?
20:19:53 <carter> i think so
20:19:55 <jmcarthur> how long have you been haskelling?
20:20:01 <carter> 2004ish?
20:20:08 <jmcarthur> no, i don't think you remember it :)
20:20:11 <carter> mebe 2003ish?
20:20:20 <jmcarthur> h98 didn't have it
20:20:41 <carter> didn't hugs or ghc at the time hae the seq type class?
20:21:25 <jmcarthur> when did they become h98 (i assume not just at the same time the h98 spec was finalized)
20:21:27 <jmcarthur> ?
20:23:39 <carter> hrm
20:26:23 <jmcarthur> huh, i actually didn't realize that functions were an instance of Eval in Haskell 1.4
20:27:09 <jmcarthur> knowing that, i totally understand why they were okay with dropping the type class altogether. it was really just boilerplate
20:27:21 <carter> her,?
20:27:28 <jmcarthur> instances were also autogenerated for new data types. no opt out
20:27:46 <carter> oh yeah
20:27:49 <carter> everything got it
20:27:54 <carter> so it didn't really buy you much
20:27:56 <jmcarthur> kind of like Typeable now
20:28:20 <enthropy> wouldn't it have bought you "I know this function seq's that argument"
20:28:42 <jmcarthur> enthropy: but you could also presumably add the constraint even if it's not used
20:29:08 <jmcarthur> enthropy: also, looking for the constraint isn't enough to tell whether a function is strict or not, regardless
20:29:20 <jmcarthur> i can still be strict or non-strict, regardless
20:29:23 <enthropy> right, but ghc wouldn't have added a constraint all by itself
20:29:52 <jmcarthur> enthropy: it could even be *inferred* without actually being strict in that argument
20:30:14 <jmcarthur> enthropy: consider    foo x y = let _ = x `seq` y in y
20:30:43 * enthropy wonders if constraints could get dropped in cases like that
20:30:49 <joelteon> is there a library that can parse a ByteString into a wai Request?
20:31:11 <carter> probably
20:31:13 <jmcarthur> enthropy: there are less simple ways to do it, too
20:31:33 <jmcarthur> enthropy: foo x y = repeat y ++ (x `seq` [])
20:31:38 <joelteon> carter which one
20:31:47 <carter> the one you write
20:31:58 <levi> Haskell 1.3 introduced constructor classes, and also monadic IO with do notation.
20:32:11 <carter> http://hackage.haskell.org/package/wai-2.0.0/docs/src/Network-Wai-Internal.html#Request
20:32:18 <carter> levi: link?
20:32:33 <carter> 1.3 and 1.4 also called fmap map!
20:32:50 <jmcarthur> yeah there were (IMO) a lot of regressions in the transition to H98
20:33:29 <levi> carter: http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf
20:34:32 <joelteon> yeah...but warp has functions that take Requests
20:35:00 <carter> yes
20:35:08 <carter> you wanted to turn a bytestring into a requst
20:35:28 <joelteon> yeah
20:35:39 <joelteon> ok, warp is heavily involved with Conduit
20:36:31 <carter> joelteon: http://hackage.haskell.org/package/warp-2.0.2/docs/Network-Wai-Handler-Warp.html#g:12
20:36:48 <carter> recvRequest
20:37:03 <joelteon> oh, interesting
20:37:17 <joelteon> maybe I'll write my own
20:37:18 <joelteon> it can't be that hard
20:37:30 <carter> only one way t find out
20:42:24 <zipper> Kikoo
20:46:44 <Aetherspawn> > called fmap map
20:46:45 <lambdabot>  Not in scope: `called'
20:46:45 <lambdabot>  Perhaps you meant one of these:
20:46:45 <lambdabot>    `cycled' (imported from Control.Lens),
20:46:45 <lambdabot>    `callCC' (imported from Control.Monad.Cont)
20:46:45 <Aetherspawn> yes!
20:46:50 <Aetherspawn> boo, lambdabot.
20:52:25 <zipper{-_-}>  In the case of f(fx). If f is (+3) and x is 10. Is the following correct?
20:52:43 <zipper{-_-}> (+3) ((+3) 10)
20:52:50 <zipper{-_-}> (+3) (13)
20:52:57 <zipper{-_-}> 16
20:53:14 <joelteon> network doesn't provide query string parsing??
20:53:52 <zipper{-_-}> So we get the value of whatever is in the left-most parenthesis first.
20:54:46 <derekv> Style question... data vs tuple, eg "Position 0 0" vs just "(0 0)" https://github.com/DerekV/ConwaysLife1/blob/master/ConwaysLife.hs
20:55:57 <nisstyre> derekv: you should probably make an actual Position type
20:56:16 <nisstyre> that way you can't possibly confuse a tuple for a position
20:57:57 <derekv> nisstyre: I thought so... But its extra noise when I'm making a bunch of them
20:58:11 <levi> derekv: Not necessarily!
20:58:14 <nisstyre> derekv: data Position = Pos Int Int
20:58:24 <nisstyre> or even just P
20:58:49 <subleq_> i'm trying to trying to write a function like concat, [[a]] -> [a], but that works on infinite lists of infinite lists. concat' [
20:58:51 <derekv> nisstyre: oh yea, I keep forgetting constructor can be named differently
20:59:06 <nisstyre> subleq_: you mean you want it to work on an infinite type?
20:59:07 <zipper{-_-}> Silence should be interpreted as acceptance.
20:59:12 <zipper{-_-}> *?
20:59:18 <nisstyre> subleq_: use a tree type
20:59:27 <levi> derekv: You can also make a function that builds positions from pairs, and map it over a list of pairs to get a list of positions.
20:59:51 <derekv> subleq_: how would you address an element of your new infinate list that used to be in any of the oritinal infinate lists other than the first one?
21:00:34 <subleq_> concat' ['a', 'b', 'c',...] ['1', '2', '3',...] ['A', 'B', C'] == "a1b2c3Ad2Be3C..."
21:01:24 <derekv> :t zipWIth (++)
21:01:24 <lambdabot>     Not in scope: `zipWIth'
21:01:24 <lambdabot>     Perhaps you meant one of these:
21:01:24 <lambdabot>       `zipWith' (imported from Data.List),
21:01:50 <derekv> :t zipWith (++)
21:01:51 <lambdabot> [[a]] -> [[a]] -> [[a]]
21:01:54 <subleq_> or "ab1c2Ad3Be4C"?
21:02:58 <derekv> whats the rule for interleaving
21:03:41 <subleq_> something like interleaving the inits, but with no duplicates
21:05:22 <derekv> you lost me.
21:05:29 <subleq_> yeah. i don't quite understand it myself
21:06:25 <derekv> subleq_: is there something algorithm to generate this new list or no?
21:06:58 <subleq_> i have a loose idea of what the algorithm is
21:07:47 <subleq_> consume an element of the first list on step 1, 2, 4, 7, 10
21:08:02 <subleq_> second list on 3, 5, 8, 11
21:08:12 <subleq_> third list on 6, 9, 12
21:08:24 <subleq_> (assuming 3 lists)
21:09:10 <derekv> starting at 4 it just alternates through the lists normally?
21:09:36 <subleq_> no
21:11:03 <subleq_> i promise there's a pattern here
21:11:09 <dr0b3rts> > take 12 [ (i,s-i) | s <- [0..], i<-[0..min 2 s] ]
21:11:10 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(0,4),(1,3),(2,2)]
21:12:24 <subleq_> number the lists starting at 1, you take an element from list 1, 1, 2, 1, 2, 3, 1, 2, 3, 4, 1, 2, 3, 4, 5,...
21:14:21 <derekv> subleq_: ok I get it
21:14:35 <subleq_> concat $ inits [1,2..] gives the list indexes
21:14:39 <piezoid> > concat . transpose $ [['1','2','3'], ['a','b','c','d']]
21:14:40 <lambdabot>  "1a2b3cd"
21:15:45 <derekv> dr0b3rts gave the answer I think
21:16:49 <subleq_> i don't understand
21:16:52 <dr0b3rts> > let x=['a'..]; y=['1'..]; z=['A'..] in take 12 [ [x,y,z] !! i !! (s-i) | s <- [0..], i<-[0..min 2 s] ]
21:16:53 <lambdabot>  "ab1c2Ad3Be4C"
21:17:47 <subleq_> dr0b3rts: i don't see how to generalize that for more lists
21:20:47 <derekv> subleq_: like this? take 22 [ (i,s-i) | s <- [0..], i<-[0.. s] ]
21:20:56 <derekv> > take 22 [ (i,s-i) | s <- [0..], i<-[0.. s] ]
21:20:57 <lambdabot>  [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2,...
21:21:58 <subleq_> oh, and use !! ?
21:22:05 <levi> > take 24 $ concat [ take n [1..] | n <- [1..] ]
21:22:06 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3]
21:22:17 <levi> If you just want the pattern.
21:22:52 <dr0b3rts> i've seen another solution... (i'm looking for it)
21:25:08 <copumpkin> > take 24 . concat . tails $ [1..]
21:25:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]
21:25:13 <copumpkin> whoops :)
21:25:19 <copumpkin> > take 24 . concat . inits $ [1..]
21:25:20 <lambdabot>  [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3]
21:25:40 <pavonia> > let concat' = catMaybes . concat . transpose . zipWith (\i c -> replicate i Nothing ++ map Just c) [0..] in concat' ["abcde", "1234", "ABC", "+-"]
21:25:41 <lambdabot>  "ab1c2Ad3B+e4C-"
21:27:26 <magicman> Doesn't work for infinite lists of infinite lists, though.
21:27:33 <magicman> *an infinite list of
21:27:49 <subleq_> right, that's the hard part
21:28:04 <magicman> It'll have to skip an infinite amount of Nothing before it can get to the second Just.
21:29:20 <copumpkin> what are you trying to do?
21:29:54 <subleq_> copumpkin: given a regex, generate all the strings it will match
21:30:00 <copumpkin> oh
21:30:11 <copumpkin> for a traditional regex, that doesn't seem too hard
21:30:18 <copumpkin> in the CS sense, not the perl sense
21:30:22 <subleq_> yeah, a regex in the CS sense
21:30:31 <copumpkin> you're going to want something like control-monad-omega
21:31:16 <subleq_> i need a way to to interleave an infinite list of infinite lists to implmenent "((a*)b)*"
21:31:17 <magicman> Ooh, yeah. That diagonal function looks like it's exactly what you want.
21:31:49 <shachaf> Oh, now I see why the diagonal functor is called that.
21:32:38 <magicman> take 15 (diagonal (map (\n -> [100*n..]) [0..])) == [0,1,100,2,101,200,3,102,201,300,4,103,202,301,400]
21:32:53 <maxiepoo> shachaf, is diagonal functor like the diagonal map? So Delta : C -> CxC ?
21:33:15 <shachaf> maxiepoo: Yep. Well, usually people use it in a more general sense, but that's the simple version.
21:33:35 <maxiepoo> what's the more general sense?
21:34:14 <shachaf> CxC is isomorphic to C^2, i.e. the category of functors : 2 -> C
21:34:39 <shachaf> (Where 2 is the category with two objects and only identity arrows.)
21:34:53 <maxiepoo> k sure
21:35:10 <shachaf> So the diagonal functor is : C -> C^K
21:35:29 <shachaf> It's the functor version of const.
21:35:32 <maxiepoo> oh ok so just generalizing to n-ary
21:35:44 <shachaf> Well, not just n-ary -- you can also have arrows in K.
21:35:56 <maxiepoo> oh K is a category!
21:36:04 <maxiepoo> any category
21:36:13 <shachaf> Yep.
21:36:35 <shachaf> maxiepoo: I can relate this to the thing we talked about before, but maybe in #-blah rather than here.
21:36:35 <subleq_> now you guys have totally lost me
21:37:14 <maxiepoo> which thing?
21:39:10 <shachaf> Limits and adjunctions, I think.
21:39:13 <shachaf> I guess that was a while ago.
21:39:37 <maxiepoo> well doesn't everything in category theory relate to limits and adjunctions? :)
21:40:46 <shachaf> I suppose so.
21:41:11 <dolio> shachaf: That category isn't the one called 2, though.
21:41:33 <shachaf> dolio: I asked about this before.
21:41:56 <dr0b3rts> http://stackoverflow.com/questions/7141287/haskell-cartesian-product-of-infinite-lists
21:42:09 <shachaf> Someone said that 2 was the one I described and fancy blackboard-bold 2 was the one with an arrow between the objects.
21:42:21 <dolio> Oh, okay.
21:42:37 <shachaf> But I don't really know.
21:42:41 <shachaf> Maybe I should say 1+1.
21:42:41 <dr0b3rts> the last answer's diagonal function looks like it should work
22:14:14 <MedDev> is there any built in folds that allow me to use 2 lists for input? kind of like a zipWith, but with an accumulator so the output can have a different length than the input?
22:15:33 <Cyd> Feel free to come check out RazerChat..a new and growing IRC network. - irc.RazerChat.com - /server -m irc.razerchat.com | http://www.razerchatirc.com/
22:20:20 <Rflax40> Hey guys, can someone help me with this error for sublime haskell? SublimeHaskell: Failed to compile ModuleInspector   C:\Users\ros.flaxman\AppData\Roaming\Sublime Text 2\Packages\SublimeHaskell\ModuleInspector.hs:25:18:      Could not find module `Documentation.Haddock'      Use -v to see a list of the files searched for.
22:23:34 <AshyIsMe> is anyone familiar with the fgl library?
22:23:59 <AshyIsMe> ive made a Graph with mkGraph which needs LNodes and LEdges and now i'd like to find the shortest path between two nodes
22:24:15 <AshyIsMe> but sp takes Nodes and Edges and doesn't seem to have an LNode version
22:24:21 <AshyIsMe> http://hackage.haskell.org/package/fgl-5.4.2.4/docs/Data-Graph-Inductive-Graph.html#g:4
22:24:27 <AshyIsMe> mkGraph is there, and sp is here:
22:24:34 <AshyIsMe> http://hackage.haskell.org/package/fgl-5.4.2.4/docs/Data-Graph-Inductive-Query-SP.html
22:25:31 <adelbertc> AshyIsMe - if you're doing graph-wide traversals (e.g. shortest path) i'd check out graphs
22:25:42 <adelbertc> i don't have much experience with fgl though
22:29:13 <AshyIsMe> https://github.com/AshyIsMe/vindinium-starter-haskell/blob/master/src/GraphTest.hs
22:29:19 <AshyIsMe> that's my example
22:29:42 <AshyIsMe> yeah Data.Graph didnt seem to have any built in shortest path functions
22:29:47 <pavonia> Rflax40: Do you have the haddock package installed?
22:29:47 <AshyIsMe> unless i was looking in the wrong place
22:35:11 <Platz> AshyIsMe: that ai contest looks neat.  have you done other like that before?
22:35:28 <AshyIsMe> this is my first one
22:35:36 <AshyIsMe> i started from the haskell template project
22:36:00 <AshyIsMe> just trying to add a shortest path algorithm so i can actually make the bot slightly smart
22:36:16 <Platz> oh nice, I saw that too.  There was also http://robotgame.net/ i saw a while back .  If I had more time it would be interesting
22:36:30 <Platz> (actually I think that's only in python)
22:36:47 <Platz> good idea
22:37:26 <AshyIsMe> yeah that's part of the attraction of vindinium, they have about 20 language packs so far
22:38:24 <Rflax40> pavonia: Yeah I got the package through the repository and nothing changed
22:39:40 <pavonia> Rflax40: How do you build SublimeHaskell, via cabal?
22:39:53 <Rflax40> Yeah
22:40:16 <Rflax40> pavonia: Yeah, cabal build
22:40:45 <pavonia> And is haddock mentioned in the dependency list in that .cabal file?
22:41:26 <Rflax40> Which .cabal file?
22:41:57 <pavonia> From that Sublime package
22:43:00 <orion> Hi. What does the :. operator do?
22:43:40 <joelteon> :t succ :. (+)
22:43:41 <lambdabot>     Not in scope: data constructor `:.'
22:43:41 <lambdabot>     Perhaps you meant one of these:
22:43:41 <lambdabot>       `Seq.:>' (imported from Data.Sequence),
22:44:12 <pavonia> orion: Where have you seen this?
22:44:55 <Rflax40> pavonia: can't find its dependency list
22:45:52 <pavonia> Rflax40: It's called build-depends
22:46:43 <dr0b3rts> I've seen .: which is defined as (.).(.)
22:47:13 <Platz> orion: If you're referring to the NICTA course, the :. operator in List.hs is just intended to do the same thing as : (i.e. cons), but they had to provide a different name from the real cons operator
22:47:36 <Platz> because they are implementing List from scratch instead of using the built-in list
22:48:18 <orion> oh ok
22:48:32 <Rflax40> pavonia: They can be found here https://github.com/SublimeHaskell/SublimeHaskell/blob/master/README.md
22:51:12 <pavonia> Rflax40: So you've run "cabal install aeson haskell-src-exts haddock"?
22:51:53 <Rflax40> In my command line correct?
22:52:08 <pavonia> yes
22:52:30 <Rflax40> Ahhhh theres my issue, need to get the rights from my school to use it, thank you
22:56:05 <Rflax40> pavonia: The cabal install commands come with the haskell platform correct?
22:56:34 <pavonia> I think so
23:03:09 <tlevine> I want to read a HTML file from disk, query it with XPath and get [String] back. Can someone link me to a snippet that will get me started on that? Thanks
23:04:18 <carter> have you tried looing at tagsoup?
23:04:28 <tlevine> Well it doesn't need to do exactly that, but all of the things I find by searching are more complicated than I need
23:04:53 <carter> tlevine: OHHHHHHHHH hey thomas
23:04:56 <tlevine> Does it do xpath?
23:04:57 <tlevine> hi
23:05:20 <carter> tlevine: didn't recognize you
23:05:37 <carter> strata trip still go?
23:05:42 <tlevine> hmm i guess xpath is maybe a bit unhaskell
23:06:08 <tlevine> strata trip is go, semi-reluctantly
23:06:09 <carter> http://hackage.haskell.org/packages/#cat:XML
23:06:36 <carter>  http://hackage.haskell.org/package/fast-tagsoup and  http://hackage.haskell.org/package/tagsoup and  http://hackage.haskell.org/package/xml
23:06:37 <carter> are things
23:07:23 <tlevine> yeah but all of the documentation is about composing xml and stuff
23:07:26 <tlevine> this should be so simple
23:07:37 <carter> well yeah
23:07:40 * hackagebot protobuf 0.1.3 - Google Protocol Buffers via GHC.Generics  http://hackage.haskell.org/package/protobuf-0.1.3 (NathanHowell)
23:08:00 <carter> 1) use the Text package to read it in as text
23:08:51 <carter> 2) use eg http://hackage.haskell.org/package/xml-1.3.13/docs/Text-XML-Light-Input.html
23:09:09 <carter> 3) then you have an AST
23:09:54 <carter> http://hackage.haskell.org/package/text-1.1.0.0/docs/Data-Text-IO.html
23:09:58 <tlevine> oh found it http://hackage.haskell.org/package/hxt-xpath-9.1.2.1/docs/Text-XML-HXT-XPath-XPathEval.html
23:10:13 <carter> hxt may be over kill
23:10:32 <carter> tlevine: one of the other libs may be simpler
23:10:44 <tlevine> now i just need to see...
23:10:45 <carter> if you find hxt overkill later, i warned yah :)
23:11:03 <Enigmagic> tlevine: if you just want xpath to string... https://github.com/alphaHeavy/xpathparser
23:12:25 <tlevine> Enigmagic that looks kind of perfect
23:13:40 <carter> tlevine: will you make it to sf at all?
23:13:44 <carter> o/ Enigmagic
23:14:11 <tlevine> but while i'm on HXT, how do i parse HTML to an XmlTree?
23:14:40 <tlevine> carter yeah but probably oakland really though
23:14:51 <carter> well i'll be in berkeley area
23:14:55 <carter> i hear those are nearby
23:15:18 <tlevine> current thinking is i'll stay until the 24th, when i might go to austin
23:15:23 <tlevine> i should figure this out....
23:15:58 <carter> yeah
23:23:26 <tlevine> Enigmagic in xpathparsers, what's the uri, and what's the input?
23:23:28 <levi> Whee, a made a monad on a newtype for list that uses diagonal as its join.
23:25:14 <Enigmagic> tlevine: uri is just whatever the url was.. not sure what it's used for, libxml2's documentation doesn't really say eiter.
23:25:24 <Enigmagic> tlevine: the input is a bytestring of the html document
23:26:31 <carter> Enigmagic: sooo, it looks like CAS has potentially been wrong for YEARS
23:26:32 <carter> mebe
23:27:15 <Enigmagic> carter: might be?
23:27:39 <carter> well
23:28:04 <carter> https://github.com/cartazio/ghc/compare/ghc:ghc-7.8...fix_64bit_intel_cas
23:28:22 <carter> doesn't gcc asm need to you specify the word size?
23:28:28 <carter> cmpxchg would be double word
23:28:36 <carter> cmpxchgq is the quadword / 64bit one right?
23:28:46 <carter> or does it default to the target word size?
23:29:11 <tlevine> oh wow ye
23:30:24 <carter> tlevine:?
23:31:00 <Enigmagic> i don't know much about gcc's inline asm
23:31:24 <carter> well
23:31:29 <carter> i'm cargo culting :)
23:32:49 <carter> ok
23:34:58 <carter> ok, gcc does the right thing
23:36:12 <Enigmagic> so why not just say :  :"=a"(o), "+m" (*(volatile StgWord*)p)
23:36:21 <carter> good point
23:36:25 <fragamus> hey Im using linear and I have a V3    I want to append something to make it a V4    how can I construct a V4 from a V3
23:36:52 <carter> append (V3 a b c) d = V4 a b c d ?
23:37:26 <Enigmagic> carter: seems like xchg is the same for x86/x86_64 and if using StgWord* works then cas would be the same as well..
23:37:38 <carter> yeah
23:37:43 <carter> i'm realizing my patch is pointless
23:37:50 <Enigmagic> oh
23:37:50 <Enigmagic> :)
23:38:47 <fragamus> > append (V3 1 2 3) 4
23:38:49 <lambdabot>  Not in scope: `append'
23:38:49 <lambdabot>  Perhaps you meant one of these:
23:38:49 <lambdabot>    `BSC.append' (imported from Data.ByteString.Char8),
23:38:49 <lambdabot>    `BSLC.append' (imported from Data.ByteString.Lazy.Char8),
23:38:49 <lambdabot>    `mappend' (imported from Data.Monoid)Not in scope: data constructor `V3'
23:39:33 <carter> fragamus: i made it up
23:39:36 <carter> myAppened
23:39:42 <carter> *myAppend :)
23:41:10 <fragamus> i did this:
23:41:11 <fragamus>     base = (V4 raybase^._x raybase^._y raybase^._z 1.0) !*! tran
23:41:28 <fragamus> The relevant bit is in the parens
23:50:26 <carter> cool'
