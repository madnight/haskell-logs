00:00:22 <shachaf> Well, there are lots of different properties/definitions of adjoints. That's one of them.
00:00:34 <Tekmo> Right
00:01:01 <shachaf> It's pretty close to the other ones, though.
00:01:28 <ReinH> shachaf: which is to say, they show the free-monoid monad monad-algebra commutativity diagram but don't talk about the fact that monoids are free-monoid monad monad-algebras. In fact I'm not even sure if they use the term "free monoid" at any point.
00:01:52 <ReinH> they just talk about lists of words
00:01:56 <shachaf> "A* is free monoid on A" means "for any monoid M, monoid homomorphisms : A* -> M are in natural bijection [in M] with functions : A -> M"
00:01:58 <Tekmo> The thing I think is really neat about category theory is that you can prove that some abstractions are "best" in a rigorous sense by showing that they are initial or terminal objects in some category
00:02:24 <shachaf> That also says roughly the same thing, in a different way.
00:02:50 <ReinH> shachaf: hmm I think I see that
00:02:52 <Tekmo> shachaf: Doesn't the latter function have to forget the structure of `M`
00:02:57 <Tekmo> Or wait
00:03:00 <Tekmo> Maybe it was the former one
00:03:12 <shachaf> Yes, I'm cheating with my notation here by using M both as a set and as a monoid.
00:03:23 <ReinH> shachaf: I'm going to have to go through the videos on adjoints because I still don't grok their formal properties
00:03:26 <jle`> well before i get lost in my laundry thanks ReinH for the suggestion and clearing some things up
00:03:28 <Tekmo> Yeah, it was the latter one.  Now I remember
00:03:32 <ReinH> jle`: np :)
00:03:46 <shachaf> It's functions : A -> U M, because M isn't even an object in Set. Talking about a function : A -> M doesn't even make sense.
00:03:49 <Tekmo> Because you have (A* -> M) ~ (A -> Forget(M))
00:03:50 <ReinH> jle`: mostly I just regurgitate corrections shachaf has already made for me ;)
00:05:39 <shachaf> Anyway you can take the same definition and s/monoid/monad/g s/function/natural transformation/g to get the definition of a free monad, of course.
00:06:49 <shachaf> But in particular you can let M = A*, in which case you get inj : A -> U A*
00:07:48 <ReinH> shachaf: is it common to use * for any free object? So T* is a free monad?
00:08:22 <randomclown> ReinH: that's the math notation anyway
00:08:23 <shachaf> Not really. https://en.wikipedia.org/wiki/Kleene_star
00:08:33 <randomclown> well FSA
00:08:53 <ReinH> shachaf: Yeah, I'm familiar with the Kleene star. But it's used that way by TheCatsters
00:08:54 <shachaf> It means "zero or more", same as in regexps.
00:08:58 <ReinH> shachaf: yep
00:09:09 <shachaf> OK, maybe it is common, I don't know.
00:09:25 * ReinH shrugs
00:09:29 <shachaf> I use it that way sometimes. But make sure to clarify what you mean when you say it.
00:09:29 <ReinH> fair enough
00:09:33 <ReinH> alrighty
00:11:19 <shachaf> Anyway, none of these definitions tell you very concretely what a free object might be, just what it would be like.
00:11:27 <ReinH> shachaf: also any idea why the letter T is used?
00:11:33 <ReinH> I always wondered that
00:11:33 <shachaf> "triple"?
00:11:50 <ReinH> Sorry, why "triple"?
00:12:07 <Tekmo> Kleisli triple
00:12:12 <ReinH> ah
00:12:27 <shachaf> No, (M,join,return)
00:12:56 <shachaf> Well, maybe a Kleisli triple too, I don't know.
00:13:06 <Tekmo> That's the Kleisli triple
00:13:25 <ReinH> Heh. But monoids are triples too. Why don't they get to be T?
00:13:36 <Tekmo> Because mathematicians are terrible at naming things
00:13:39 <ReinH> haha
00:13:45 <shachaf> No, the Kleisli triple is closer to what we have in Haskell.
00:13:49 <ReinH> well to be fair, monads start with M too
00:14:02 <shachaf> In fact it's really close -- it even does the "no Functor superclass" thing.
00:14:09 <Tekmo> shachaf: Oh, you're right
00:14:15 <Tekmo> The third element is `bind`, not `join`
00:14:30 <shachaf> Maybe I should've said ((M,fmap),join,return)
00:14:43 <shachaf> Whereas the Kleisli triple is just (M,(>>=),return)
00:14:45 <Tekmo> Yeah, the kleisli triple is actually `(M, return, (=<<))`
00:14:55 <shachaf> Yes, (=<<).
00:15:18 <shachaf> (>>=) doesn't quite make sense.
00:15:31 <Tekmo> Yeah, it requires a notion of function
00:15:34 <Tekmo> Or something similar
00:15:40 <Tekmo> It's not as general as (=<<)
00:15:52 <shachaf> Anyway, the usual definition of "free object" for e.g. universal algebra is much more concrete (but less general). It's more or less "equivalence classes [by the laws] of ASTs [made from the generating set and the operations]".
00:16:13 <abstract-alf> so, http://i.imgur.com/ymXHli2.jpg
00:16:23 <ReinH> Tekmo: M is the endofunctor, a.k.a. T, a.k.a. F, right? ;)
00:16:36 <Tekmo> ReinH: Right
00:16:45 <ReinH> Tekmo: also mathematicians are no worse at naming things than programmers ;)
00:16:49 <shachaf> You have to be careful because there are three different concepts floating around here.
00:16:53 <Tekmo> ReinH: True
00:17:02 <Tekmo> ReinH: At least we have namespaces, though
00:17:09 <ReinH> Tekmo: and more than 26 names for algebraic objects
00:17:17 <shachaf> There's the object mapping, which maps objects to objects.
00:17:42 <shachaf> There's the endofunctor, which is an object mapping (this is optional) and also an arrow mapping with the functor laws.
00:17:56 <shachaf> And there's the monad, which is one of a few equivalent definitions.
00:18:07 <Tekmo> So is "arrow mapping" the common term for that?  I've always wondered what to call that
00:18:23 <shachaf> I don't know if it's common.
00:18:31 <shachaf> The common term is probably "functor".
00:18:36 <ReinH> hah
00:18:37 <Tekmo> Yeah, but that's always ambiguous
00:18:42 <shachaf> Eh.
00:18:56 <shachaf> If you define a functor to map just arrows, and forget about objects entirely, you end up with the same thing.
00:19:05 <shachaf> Since you can recover the object mapping from the identity arrows.
00:19:29 <shachaf> So the important part of a functor is the arrow mapping, just like the important part of a category is the arrows, not the objects.
00:19:46 <shachaf> (You can do something similar to define a natural transformation without talking about objects.)
00:20:02 <Tekmo> The reason I ask is because whenever I have something like: `length (xs ++ ys) = length xs ++ length ys`, I want a name to explain how `length` behaves like an arrow mapping
00:20:16 <Tekmo> Oops
00:20:19 <shachaf> Just say "monoid homomorphism". :-(
00:20:20 <Tekmo> *length xs + length ys
00:20:27 <ReinH> monoid morphi... yes
00:20:37 <Tekmo> Well, some of the things I'm interested are not monoid homomorphisms, though
00:20:56 <Tekmo> For example: `fromListT :: (a -> ListT m b) -> Pipe a b m r`
00:21:05 <shachaf> The object mapping between one-object categories is *particularly* boring.
00:21:06 <Tekmo> fromListT (f >=> g) = fromListT f >-> fromListT g
00:21:21 <Tekmo> fromListT return = cat
00:21:25 <shachaf> Anyway, the Kleisli triple definition just uses the object mapping, not the whole endofunctor.
00:21:29 <Tekmo> I'd like a name to describe that phenomenon
00:22:01 <shachaf> Whereas the normal "triple" uses an endofunctor along with join/return.
00:22:35 <ReinH> Tekmo: well generally it's composition of morphisms?
00:22:52 <Tekmo> ReinH: I want a name to say "fromListT distributes in a way similar to `fmap`"
00:23:15 <Tekmo> ReinH: And it has to be precise enough so that Chris Gershom doesn't cry foul on my terminology
00:23:29 <ReinH> haha I can't help you there
00:23:56 <ReinH> Tekmo: but isn't that a functor?
00:24:06 <Tekmo> ReinH: `fromList` is the arrow mapping part
00:24:18 <Tekmo> ReinH: That's why I was asking if that's the common name for it
00:24:53 <Tekmo> ReinH: In this particular case the object mapping is just Id
00:25:21 <ReinH> Tekmo: the object mapping is boring
00:25:23 <shachaf> I don't know who Chris Gershom is but I doubt they'd object that much if you used that phrase.
00:25:33 <Tekmo> Alright
00:26:03 <shachaf> But maybe I shouldn't speak for them.
00:27:03 <shachaf> Anyway, I'd like to come up with a better way of figuring out free objects in various categories.
00:28:18 <shachaf> A free topological space is just discrete, for example. But can I come up with a rationale for that that's related to the "equivalence classes of expressions" version?
00:28:34 <shachaf> maybe chu spaces hold the answer!!
00:30:09 <shachaf> What's a free Chu space like? Also discrete, I guess?
00:31:29 <ReinH> shachaf: chu spaces blow my mind
00:31:41 <ReinH> I should probably stop thinking about them for a while
00:32:33 * hackagebot strict-identity 0.1.0.0 - Strict Identity Monad, handy for writing fast code!  http://hackage.haskell.org/package/strict-identity-0.1.0.0 (CarterSchonwald)
00:33:06 <carter> mwhahaha
00:33:07 <carter> :)
00:33:16 <carter> speaking of category theory :)
00:33:45 <carter> actually put it on hackage 'cause m3ga asked really nicely
00:34:02 <shachaf> I'm not sure I understand this package.
00:34:13 <lambdaKanha> ??
00:34:17 <shachaf> newtype StrictIdentity a =  StrictIdentity {runStrictIdentity_ :: a }
00:34:24 <carter> shachaf: read the monad isntnace
00:34:29 <carter> instance
00:34:33 <ReinH> carter: oh nice
00:34:33 <shachaf> runStrictIdentity :: StrictIdentity a -> a; runStrictIdentity !ma = case runStrictIdentity_ $! ma of !res -> res
00:34:43 <carter> read the bind defn
00:34:57 <shachaf> Is this a case of "putting !s everywhere because why not" or am I missing something?
00:35:12 <carter> the style coud clean up
00:35:21 <carter> but the main point is do notation as a strict let
00:35:28 <carter> the defn of bind is the only bit that matters
00:35:28 <shachaf> Is runStrictIdentity different from runStrictIdentity_?
00:35:36 <carter> only look at bind
00:35:44 <carter> unless you want to talk about style at 3am :)
00:35:47 <carter> i dont' :)
00:35:55 <carter> i'm open to PRs to clean up style
00:36:49 <carter> reid gave some good suggestions i may do tomorrow
00:37:18 <ReinH> carter: I think there are a few more opportunities for bangs
00:37:27 <carter> now yah troll
00:37:38 <carter> :p
00:37:43 <ReinH> :D
00:37:53 <shachaf> sigh
00:38:08 <carter> shachaf: i agree i can clean it up a wee bit
00:38:20 <carter> the main point is to be able to use do notation as a strict nested let
00:38:26 <carter> instead of having to write lots of nested cases
00:38:58 <carter> and its main use case is when m3ga or someone else is writing a low level fiddly alg in hs and it needs to be strict
00:39:06 <carter> hence the example is a bit shuffle
00:39:37 <carter> theres def room for cleaning up the bang pattern style, i just hackagified some code that i've been showing people since last spring
00:40:06 <carter> if you have a concrete suggestion, throw a ticket on github and i'll do it
00:40:22 <shachaf> OK, for your example, why write do { x <- return $! ...; ... } instead of do { let !x = ...; ... }?
00:40:38 <carter> derp
00:40:40 <shachaf> return $! x should be the same return x here, anyway
00:40:53 <carter> thats a very very good point
00:40:55 <ReinH> also I just realized that Control.Monad.Free.Improve is (analogous to) a difference list for the free monoid. Smart.
00:41:22 <shachaf> What, Codensity?
00:41:27 <shachaf> Yes, it's similar.
00:41:29 <ReinH> er
00:41:31 <ReinH> free monad sorry
00:41:36 <carter> shachaf: wait, is the let in do syntax nested let or mutually recursive let?
00:42:24 <shachaf> Of course, no reason to specialize that to free monads.
00:42:40 <carter> i thought it was mutually recursive for some reason
00:42:43 <shachaf> In fact, e.g. Codensity (Writer w) behaves like Writer (DList w)
00:43:06 <ReinH> ahh
00:43:08 <shachaf> I don't know what the question is.
00:43:30 <carter> ?
00:43:41 <ReinH> That's not it.
00:44:21 <dleedev> hi, when we say monads are a way of encapsulating computations, where do the computations actually lie?
00:44:37 <shachaf> carter: I don't understand your question.
00:45:03 <dleedev> do the computations lie in the body of the kliesli arrows?
00:45:48 <ReinH> dleedev: they lie in the implementation of the monad
00:46:15 <shachaf> They lie in your head.
00:46:35 <shachaf> "computation" is a human concept
00:46:55 <Twey> carter: Sequential lets are nested, but you can define multiple names in one let and they'll be mutually recursive in the usual way
00:47:01 <carter> ok
00:47:04 <carter> yeah
00:47:05 <dleedev> shachaf: sure, but they are implemented into the monad, right?
00:47:06 <ReinH> dleedev: which is to say, some specific monads might be considered to "encapsulate computation" based on their implementation.
00:47:25 <carter> and the only difference with do notation is you dont need the in keyword
00:47:30 <Twey> Yes
00:47:36 <Twey> It saves you a level of indentation
00:47:39 <carter> BUT the result still has to bein *some* monad
00:47:42 <dleedev> ReinH: and the ones that do, where does the implementation of the computation lie?
00:47:46 <carter> ok
00:47:49 <Twey> Not necessarily
00:47:51 <ReinH> dleedev: but you'd be hard-pressed to find any computation being encapsulated by Identity
00:47:57 <Twey> > do let x = 5; x
00:47:58 <lambdabot>  <hint>:1:16:
00:47:59 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
00:48:02 <shachaf> > do { let { x = 5 }; let { y = 6 }; x + y }
00:48:03 <lambdabot>  11
00:48:09 <Twey> > do { let { x = 5 }; x }
00:48:10 <lambdabot>  5
00:48:16 <carter> wait
00:48:22 <carter> do notation can work sans monad?!
00:48:23 <ReinH> dleedev: I'm not sure how to answer that question.
00:48:24 <Twey> We're not sure whether this ought to be an error or not, but it isn't
00:48:35 <Twey> carter: Do-notation is a simple, mechanical translation
00:48:36 <carter> this is news to me
00:48:40 <carter> yes
00:48:44 <carter> ohhh
00:48:52 <Twey> In this case it happens to translate to something that uses neither >> nor >>=, so yes, it doesn't have to involve a monad
00:48:53 <carter> so no binds == this is valid internally
00:48:58 <Fuuzetsu> What's the binary monoid operation that Haskell/GHC derives on ‘deriving Monoid’ with such a simple type as ‘newtype Foo τ = Foo τ’?
00:49:05 <carter> woahhhh
00:49:07 <carter> mind blown
00:49:12 <ReinH> Fuuzetsu: the monoid of the underlying type
00:49:14 <Fuuzetsu> Does it enforce that ‘Monoid τ’ and then wrap around it?
00:49:15 <Fuuzetsu> right
00:49:41 <Twey> Fuuzetsu: That's GeneralizedNewtypeDeriving, so you get the instance of whatever the type of the argument to the newtype is
00:49:48 <shachaf> :i tells you that.
00:50:13 <dleedev> ReinH: when you implement "x >>= f", does f represent the computation that's being encapsulated?
00:50:26 <Fuuzetsu> shachaf: so it does
00:50:32 <dleedev> ReinH: or does >>= represent the computation?
00:50:41 <Twey> The Monoid constraint on τ comes from the same place as the String constraint if you ‘deriving String’ on a parametric type
00:50:56 <Twey> Uh
00:50:59 <Twey> s/String/Show/
00:51:01 <Twey> g
00:51:13 <carter> ok
00:51:14 <carter> well
00:51:15 <carter> thanks
00:51:19 <carter> I have stuff to think about
00:51:22 <carter> night all
00:51:25 <Twey> 'night
00:51:47 <ReinH> dleedev: The idea that monads are a way to "encapsulate computation" is a hasty analogy. That being said, a monoidal action is vaguely like a computation and join is vaguely like sequencing of computations.
00:51:53 <ReinH> er monad action
00:51:59 <ReinH> Monad m => m a
00:52:14 <dleedev> ReinH: so m is the computation?
00:52:19 <ReinH> dleedev: no.
00:52:26 <shachaf> Something :: forall m. Monad m => m A is like something :: A
00:52:33 <ReinH> dleedev: don't try to make this analogy work out
00:52:42 <ReinH> Just consider it a vague and hand-wavey description
00:52:53 <shachaf> carter: At any rate, that file is a bit ridiculous.
00:53:35 <shachaf> If there's anywhere where I'd hope to see a reasonable reflection of how strictness works, it's in a file defining a type specifically for strictness.
00:53:41 <dleedev> ReinH: what do you mean by "monodial actions"
00:53:48 <ReinH> dleedev: mistake. I meant "monad actions"
00:54:09 <dleedev> ReinH: what are "monad actions"?
00:54:27 <shachaf> Sprinkling !s and $!s everywhere does the opposite of good in most cases.
00:54:51 <dleedev> ReinH: is it not f in x >>= f?
00:54:52 <ReinH> A monad action (some value of type Monad m => m a) is vaguely like a computation. >>=, >> and  join are vaguely sort of like ways to sequence computation. But you wouldn't believe how fast I'm waving my hands right now.
00:55:21 <dleedev> ReinH: haha, ok
00:55:34 <shachaf> How does join "sequence" computation?
00:56:11 <ReinH> shachaf: I'm not sure how much harder I can wave my hands
00:56:44 <ReinH> shachaf: In the same sort of sense that a word is a sequence of symbols, joining two monad actions sequences the actions.
00:56:52 <Twey> join (putStrLn "A" >> return (putStrLn "B"))
00:57:20 <jle`> we sort of use the term monad action loosely to refer to a specific value of that monad that represents an action, semantically.  as in, the value is just the value.  and as far as the type/compiler knows, it's just a value.  but we as humans give it a meaning as representing an action.  like how strings are identical to lists of chars, but 'string' is a human term taht has nothing to do with how the
00:57:22 <jle`> compiler computer etc. see it
00:57:32 <jle`> putStrLn "hello" is just a value, same as any other value
00:57:36 * hackagebot json-rpc-server 0.1.1.0 - JSON RPC 2.0 on the server side.  http://hackage.haskell.org/package/json-rpc-server-0.1.1.0 (grayjay)
00:57:43 <dleedev> ReinH: is the only monad that can be explained as an "encapsulation of computations" the IO monad?
00:57:50 <jle`> but the value represents, as we have designed base/Prelude, an action
00:57:50 <ReinH> shachaf: I don't expect these explanations to stand up to any kind of scrutiny. I thought I made that clear.
00:58:01 <jle`> it represents to us humans.
00:58:13 <Twey> ReinH: Ehh.  ‘join’ is more like ‘flatten’ than ‘join’ in that sense.
00:58:57 <jle`> dleedev: i think the state monad might be able to fit into that sort of description kinda maybe but not really because the descirption isn't even too meaningful
00:59:00 <ReinH> Twey: what do we call join for the list monad? ;)
00:59:06 <ReinH> some might call it flatten.
00:59:18 <ReinH> Twey: I'm not saying you're wrong because I'm not saying I'm right.
01:00:06 <Twey> Sequence of sequences of ut that only applies because the outer monad is [], and that's what [] does
01:00:09 <ReinH> dleedev: is writing a series of log messages a kind of computation?
01:00:28 <Twey> s/Sequence of sequences of /B/
01:00:52 <ReinH> Twey: right, but I was drawing a comparison to the free monoid
01:01:00 <shachaf> why
01:01:06 <dleedev> ReinH: hmm... I guess
01:01:31 <ReinH> shachaf: because people keep getting told that monads are for encapsulating computation?
01:01:54 <dleedev> ReinH: but that's not what the monad value in State represent
01:02:04 <ReinH> dleedev: Writer
01:02:16 <dleedev> ReinH: even Writier
01:02:33 <ReinH> dleedev: You don't think writer is like appending log messages to a log?
01:02:34 <dleedev> ReinH: the monad value in Writer encapsulates the total accumulation of the logs, right?
01:03:36 <dleedev> ReinH: the tell function is doing the actual appending
01:04:48 <dleedev> ReinH: so in that sense, given x >>= f, f is the computation, not the monad value
01:04:52 <dleedev> ReinH: but IO is different
01:04:59 <ReinH> dleedev: that might be true
01:05:14 <ReinH> I don't think monads are really very much like "encapsulating computation" so I can't really argue
01:05:23 <carter> shachaf: constructive expositions of a better way for low level strict things welcome
01:06:33 <dleedev> ReinH: given "x >=> y", are x and y called kleisli arrows, or is ">=>" called the kleisli arrow?
01:06:40 <ReinH> dleedev: maybe some k :: a -> m b is sort of like a computation and some m a is sort of like a context. Not really though.
01:08:08 <Tekmo> dleedev: x and y are the kleisli arrows
01:08:16 <Tekmo> dleedev: (>=>) is composition of kleisli arrows
01:08:16 <carter> shachaf: i'll add the let !x = blah alternative
01:08:24 <dleedev> ReinH: for IO m, I like to understand k :: a -> m b as a "control function" (somewhat like a switch or case statement), and m b as the "data function"
01:08:31 <dleedev> Tekmo: thanks
01:08:31 <jle`> (a -> m b) is the arrow
01:08:35 <ReinH> dleedev: the kleisli arrow is a -> m b
01:08:37 <carter> soo that anyone who discovers this package learns the better way immediate
01:08:51 <carter> ly
01:09:05 <dleedev> ReinH: but then my arms are just as tired as yours :)
01:09:14 <jle`> data function?
01:09:19 <shachaf> Is there an interpretation of "constructive" that doesn't involve going through the file and fixing it line-by-line?
01:09:50 <carter> yes
01:10:01 <dleedev> jle`: data functions: functions that actually do something with the data. control functions: functions that control the data functions.
01:10:01 <carter> showing the let !x alternative next to the monad hack :)
01:10:24 <Tekmo> dleedev: What if `a = ()` and `b = `()`?
01:11:10 <jle`> dleedev: well your control functions are just normal functions that return "data functions" :P
01:11:15 <shachaf> Almost all of those !s and $!s are gratuitous. A few are probably bad. One or maybe a few are necessary.
01:11:26 <Tekmo> Can I see this strict code?
01:11:27 <dleedev> jle`: yeah... is that too transparent?
01:11:32 <jle`> does putStrLn count?
01:11:33 <shachaf> https://github.com/cartazio/strict-identity/blob/master/src/Control/Monad/StrictIdentity.hs
01:11:50 <ReinH> carter: fuzz your program by removing !'s and running a benchmark to figure out which ones are necessary ;)
01:11:59 <Tekmo> carter: Oh, strict identity
01:12:00 <carter> i had shared this code months ago
01:12:03 <Tekmo> carter: I would toss that code away
01:12:20 <carter> Tekmo: well, respectuflly,  showed ya'll this code as a snippet months ago
01:12:27 <carter> and i got no feedbackthen
01:12:27 <dleedev> jle`: putStrLn would be what I call a control function
01:12:47 <carter> i showed it to m3ga last week and he asked me to put i on hackage
01:12:47 <carter> so respectuflly
01:12:55 <jle`> sounds like something waiting for an argument to be a 'data function' -- putStrLn "hello" is your data function yes?
01:12:58 <carter> please be constructive rather than "zomg, my eyes"
01:13:00 <ReinH> dleedev: I'm not sure in what sense putStrLn is controlling anything
01:13:06 <Tekmo> carter: :)
01:13:10 <Tekmo> carter: THE GOGGLES THEY DO NOTHING
01:13:13 <Tekmo> carter: Just kidding
01:13:24 <dleedev> jle`: the monad value returned by putStrLn would be the "data function"... but I guess I can't say "function" in the strict sense
01:13:31 <dleedev> jle`: "computation" :)
01:13:42 <carter> PRs to fix up the faux monad are welcome
01:13:50 <ReinH> carter: fauxnad?
01:13:58 <ReinH> Yep that is now a thing.
01:13:58 <carter> i'm about to push a minior version bump that shows the let !x do notation hack
01:14:01 <carter> because thats even nicer
01:14:04 <carter> and i didn't know about htat
01:14:15 <Tekmo> carter: I would not use the monad.  Use `seq` or `$!` in `let` blocks
01:14:19 <carter> nope
01:14:20 <dleedev> jle`: putStrLn would be a control function with no control logic. It just passes the argument straight into the "data function"
01:14:25 <Twey> carter: What is it supposed to do, exactly?
01:14:33 <carter> Twey: look at the bit fiddling code
01:14:40 <carter> actually
01:14:42 <carter> wait 5 min
01:14:49 <ReinH> dleedev: That explanation doesn't work for me, but don't let that stop you :)
01:14:57 <carter> then you'll see the version with the nicer appraoch that obsolets the package
01:15:04 <dleedev> ReinH: yeah, I told you that my arms were tired :)
01:15:18 <jle`> well your definition of 'data function' actually has some sort of meaning maybe in the context of the State monad
01:15:51 <ReinH> dleedev: the "data function" given by putStrLn "foo" is an m ()
01:15:56 <Tekmo> carter: By the way, that code looks like an unrolled morton encoding
01:16:00 <jle`> because m = State s, m a is a function that manipulates a state of type s and returns a value of type a
01:16:00 <Twey> carter: The thing is, as far as I can tell, all the work there is done by the $!'s on runStrictIdentity &c.
01:16:01 <carter> it is
01:16:02 <dleedev> ReinH: that's exactly what I'm saying
01:16:11 <jle`> so your m a is a function/computation on a state s
01:16:14 <Twey> carter: I.E. the monad does nothing
01:16:15 <ReinH> the computation of "putting a string", if it can be said to be encapsulated anywhere, is "in" the m ()
01:16:16 <carter> Tekmo: thats EXACTLY what it is
01:16:17 <carter> https://github.com/cartazio/strict-identity/blob/master/src/Control/Monad/StrictIdentity.hs#L69-L81
01:16:28 <shachaf> Twey: runStrictIdentity = runStrictIdentity_
01:16:29 <ReinH> Ok my hands are going to fall off. I give up.
01:16:59 <carter> when writing a primop i may be calling 1 million times a second, i want to make sure no thunks happen
01:17:00 <Twey> Right
01:17:05 <ReinH> shachaf: but with "more" strictness?
01:17:08 <dleedev> jle`: hmm... that won't work, though, since this was all meant to be for the IO monad only
01:17:13 <ReinH> runReallyStrictIdentity
01:17:13 <shachaf> No, no more strictness. Same function.
01:17:23 <donri> it's the thunk that matters
01:17:40 <Twey> carter: The only thing the strictness on your monad stuff is doing is making sure the inner value of the newtype is evaluated when the newtype is… which is redundant, because newtypes don't have a runtime representation anyway
01:18:00 <dleedev> jle`: for State, m a would represent the state of the State value, not a computation on the State value
01:18:03 <carter> Twey: it gives me good assembly
01:18:06 <jle`> dleedev: it does not
01:18:07 <shachaf> Twey: No, the monad is not the same as Identity.
01:18:08 <carter> and thats all i care about
01:18:11 <carter> yeah
01:18:15 <carter> agreed
01:18:18 <ReinH> dleedev: do you know what the type of State is?
01:18:26 <shachaf> In paticular do { x <- return undefined; return 5 } is undefined.
01:18:28 <dleedev> jle`: I mean, State m a
01:18:31 <shachaf> I don't mind the existence of that monad all that much, just the implementation.
01:18:34 <carter> https://github.com/cartazio/strict-identity/blob/master/src/Control/Monad/StrictIdentity.hs#L113
01:18:43 <carter> shachaf: i'm happy to make any changes you suggest
01:18:54 <Twey> Oh, I guess the function application is made strict via bind
01:18:59 <carter> yup
01:19:03 <ReinH> dleedev: the state monad isn't built off of a state value. It's built off of a state transformation.
01:19:12 <jle`> dleedev: m = State s, m a is a value of type s -> (a, s)
01:19:12 <carter> bind is the only interesting line in the file
01:19:21 <jle`> so m a is literally a function
01:19:24 <shachaf> But if being constructive means fixing the code then I'll just not look at the code instead.
01:19:45 <carter> shachaf: if you tell me what changes to make, i'll consider em
01:19:52 <carter> lets start with bind
01:19:57 <carter> and ingore every other line
01:20:14 <carter>     (!m) >>= (!k)  = k $! runStrictIdentity  m
01:20:17 <carter> what would you do instaled?
01:20:34 <ReinH> dleedev: the State monad is perhaps the one for which the interpretation "m a is a computation" is the most meaningful ;)
01:20:35 <carter> *insead
01:20:36 <shachaf> But the other lines are the crazy ones.
01:20:42 <ReinH> Also Learn You a Haskell is down? o_O
01:20:44 <shachaf> But anyway.
01:20:53 <shachaf> k should probably not be strict.
01:21:12 <shachaf> There's no reason to use $! there
01:21:31 <shachaf> And runStrictIdentity = runStrictIdentity_, so maybe there's no reason to use that either, I don't know.
01:21:43 <carter> ok
01:21:55 <shachaf> So how about StrictIdentity !m >>= k = k m -- does that come out the same?
01:22:23 <carter> could be!
01:22:55 <carter> i'll compile the bit fiddling function with each of those variants on O0 through O3 on -fasm and -fllvm tomorrow
01:22:57 <ReinH> since "a function from a state to a value and a new state" is a somewhat reasonable interpretation of "computation"
01:22:57 <dleedev> jle`, ReinH: I'm going to read the docs for State, and be right back :)
01:23:29 <carter> if theres no differences, i'll gladly use your version
01:23:40 <shachaf> You don't need O0 through O3 and fasm and fllvm. You just need Core.
01:23:51 <carter> no i do
01:24:00 <dleedev> newtype State s a = State { runState :: s -> (a, s) }
01:24:20 <dleedev> yup, so runState would represent the computation
01:24:24 <carter> for bit fiddling stuff, llvm does some magic to the asm ghc cant
01:24:46 <ReinH> dleedev: runState is just a field for accessing the state value
01:24:47 <carter> like when i compose outer shuffle and its inverse, -fasm gives 80 asm instructions
01:24:52 <carter> -fllvm makes it a noop
01:25:23 <ReinH> (it's a projection)
01:25:52 <jle`> it's the same as newtype State s a = State (s -> (a,s))
01:26:07 <Tekmo> carter: The thing is that your code is not really stricter
01:26:14 <Tekmo> carter: For the same reason that `id $! x` does nothing
01:26:19 <dleedev> hmm... then the argument to the function state
01:26:36 <carter> Tekmo: i will compare the asm tomorrow to arbitrrate that opinion
01:26:47 <carter> anything else doesn't matter
01:27:03 <ReinH> sometimes it's nice to work in a world where there are facts
01:27:12 <ReinH> I miss that in my actual work.
01:27:16 <Tekmo> Ha
01:28:18 <shachaf> sigh
01:28:27 <jle`> Tekmo: do you have a twitter?
01:28:31 <carter> nope
01:28:34 <Tekmo> jle`: I have an empty twitter account
01:28:35 <carter> i do sadly
01:28:58 <napping> using shake, getDirectoryFiles seems to find what I want, but using removeFiles or removeFilesAfter with the same pattern does nothing
01:29:01 <carter> https://github.com/cartazio/strict-identity/blob/master/src/Control/Monad/StrictIdentity.hs#L69-L81 not how on the github version i have code that obsoletes the lib
01:29:05 <carter> *note
01:29:05 <carter> :)
01:29:34 <Tekmo> I could never get a Morton code in Haskell that beat the C version, though
01:29:52 <carter> Tekmo: i got vvery nice asm
01:30:03 <carter> a *real* C version would use SIMD
01:30:06 <jle`> Tekmo: ah ty
01:30:16 <Tekmo> My code looked exactly like the one you wrote (except using `let` and `seq`)
01:30:20 <carter> oh
01:31:05 <carter> i got ASM that matches what i'd expect the c code to generate
01:31:59 <Tekmo> Hmmm.  Maybe I forgot the `seq`s, then
01:32:05 <Tekmo> It was over a year ago
01:32:26 <qrada> hey, im writing some tests using hunit (learning haskell).. I can't use assertEqual on something that is returning IO [a].. i'm doing problem 23 of 99 problems, so im using System.Random to return a list (IO [a]), but my hunit test keeps complaining about expecting [a], actual IO [a].. assertEqual "blah" [] (getRand "blah") .. i imagine it's my use of [], maybe it should be [] :: IO () or something?
01:32:59 <Tekmo> What is the type of `assertEqual`?
01:34:32 <qrada> i can't seem to :t it, but i don't recall it 'deriving' IO () or anything in the hunit docs.
01:34:35 <qrada> sec
01:34:57 <qrada>  assertEqual :: (Eq a, Show a) => String -> a -> a -> Assertion
01:35:00 <qrada> from hunit docs
01:35:33 <qrada>  type Assertion = IO ()
01:35:58 <Tekmo> qrada: So you want to replace `[]` with `(return [])`
01:36:02 <Tekmo> Oh wait
01:36:03 <qrada> oskgoisgjsdiogjsiodjgsido
01:36:04 <qrada> oh
01:36:05 <Twey> qrada: IO () has instances for neither Eq nor Show
01:36:06 <Tekmo> No, that will not work either
01:36:10 <qrada> ah
01:36:20 <Tekmo> What you want to do is something like:
01:36:26 <Twey> qrada: You need to wait until it's been evaluated to get the value it will produce, then perform your assertion on that
01:36:36 <Tekmo> do { x <- getRange "blah"; assertEqual "blah" x [] }
01:36:45 <Twey> s/evaluated/executed/
01:36:54 <Tekmo> *getRand "blah"
01:36:59 <qrada> hmm... thanks, let me try
01:38:17 <qrada> ok that clears up alot... compiles now
01:38:49 <carter> ok, i can't get the let !x = blah approach to parse
01:38:49 <qrada> thanks alot folks
01:39:02 <Tekmo> qrada: You're welcome
01:39:21 <Tekmo> carter: Did you turn on the BangPatterns extension?
01:39:41 <carter> like it was a late night edgey tv show
01:39:57 <Tekmo> Are you using tabs? :) j/k
01:40:22 <carter> ohh, indentation woes
01:40:23 <carter> gotiti
01:41:06 <kraalquid> question about GHCi on Acid (GOA): I followed the instructions on this page (http://www.haskell.org/haskellwiki/GHC/GHCi) to get GOA to work but the :src command is not working. The error is "Plugin `sourcePlugin' failed with: state not initialized"
01:41:35 <carter> NOOOOOOOO
01:41:41 <carter> recursive bang patterns aren't alllowed
01:41:56 <Twey> …?
01:42:09 <carter> do { let !x = blah ; let !x = bladkdjd ; x} is considered recursive
01:42:31 <shachaf> > do { let { !x = 5 }; let { !x = 6 }; x }
01:42:32 <lambdabot>  6
01:42:43 <Twey> ^
01:42:56 <Twey> It's not.  What's telling you it's recursive
01:42:57 <carter> do { let { !x = 5 }; let { !x =  x+6 }; x }
01:42:59 <Twey> ?
01:43:02 <shachaf> Recursive bang-patterns aren't allowed because they don't make sense.
01:43:05 <Twey> That's recursive
01:43:07 <shachaf> Ah, that.
01:43:08 <carter> yes
01:43:11 <carter> thats why i like do notation
01:43:18 <carter> i want not recursive let
01:43:19 <Twey> What?
01:43:26 <Twey> No, let is still recursive
01:43:29 <carter> yes
01:43:30 <shachaf> carter wants to pretend he's using C.
01:43:33 <carter> yes
01:43:40 <shachaf> let doesn't work for that. Yep.
01:43:45 <Twey> I see
01:43:45 <carter> ok
01:43:51 <carter> so my do notation hack still stands
01:44:17 <carter> 'cause it makes it much easier to port algs
01:44:22 <carter> for primops
01:44:25 <Twey> What happened to that C DSL?
01:44:31 <carter> what C DSL?
01:44:32 <carter> C?
01:44:39 <shachaf> > do { !x <- return undefined; return 5 }
01:44:40 <lambdabot>  No instance for (GHC.Show.Show (m0 b0))
01:44:40 <lambdabot>    arising from a use of `M66954357358583732054145.show_M66954357358583732054...
01:44:40 <lambdabot>  The type variables `m0', `b0' are ambiguous
01:44:40 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
01:44:41 <lambdabot>  Note: there are several potential instances:
01:44:43 <shachaf> > do { !x <- return undefined; return 5 } :: [INt]
01:44:44 <lambdabot>  Not in scope: type constructor or class `INt'
01:44:45 <lambdabot>  Perhaps you meant `Int' (imported from Data.Int)
01:44:49 <shachaf> > do { !x <- return undefined; return 5 } :: [Int]
01:44:50 <Twey> Someone wrote a Haskell DSL that looked like C.
01:44:50 <lambdabot>  *Exception: Prelude.undefined
01:44:52 <shachaf> That thing.
01:44:55 <Twey> A while ago
01:45:06 <Twey> Unfortunately, it's difficult to Google.
01:45:12 <shachaf> Probably augustss.
01:45:19 <carter> language c quote?
01:45:21 <shachaf> It is not for serious use.
01:45:43 <Twey> Ah yes
01:45:49 <Twey> carter: http://augustss.blogspot.co.uk/2007/08/programming-in-c-ummm-haskell-heres.html
01:46:06 <carter> hehe
01:46:16 <shachaf> Anyway, you get strict bindings with regular Identity if you write !
01:46:21 <shachaf> As shown above.
01:46:35 <carter> ok
01:46:37 <carter> cool
01:46:51 <shachaf> But I'd rather not think about that file any more.
01:47:39 <shachaf> Do what you will with it. If you provide a library intended to work with strictness, it's probably a good idea to put a bit of thought into how strictness works while writing it.
01:48:03 <carter> yeah
01:48:14 <carter> well, im happy to take the time to clean it up
01:48:25 <carter> i agree about the semantics of strictness
01:48:42 <_2_nataly> hello
01:48:42 <carter> i will figure out whether that exactly matches the threshold the impacts opimtizations
01:49:53 <_2_nataly> ?
01:50:00 <shachaf> Also, GHC is a compiler that has multiple intermediate languages.
01:50:03 <jle`> anyone know how i can view the raw markdown on a darcs web interface
01:50:05 <jle`> like http://hub.darcs.net/ertes/netwire/browse
01:50:15 <carter> yes
01:50:17 <shachaf> Haskell is turned into Core which is turned into STG and Cmm and so on.
01:50:22 <carter> yes
01:50:32 <carter> i'll look at the core too
01:50:33 <shachaf> If two programs turn into the same Core, you don't need to worry about the rest of the stages.
01:50:39 <carter> fact
01:50:40 <carter> ok
01:50:50 <carter> i'll look into it tomorrow
01:50:58 <carter> shachaf: you make great points
01:51:27 <carter> i will investigate after  some sleep
01:51:38 <shachaf> Yep, I do. I'm like Cassandra.
01:52:18 <carter> the multi data center db, or the greek one?
01:52:27 <shachaf> The Greek one.
01:52:27 <carter> i hear the db is a pain to deal with
01:52:31 <carter> k
01:52:34 <carter> :p
01:52:35 <carter> night!
02:02:11 <aleksejs_> Hi, I have a problem after installing ghc-dynamic: it doesn't see Data.Text anymore
02:06:00 <ReinH> carter: so was the greek one
02:07:50 * hackagebot blaze-markup 0.5.1.7 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.1.7 (JasperVanDerJeugt)
02:07:52 * hackagebot blaze-html 0.6.1.3 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.6.1.3 (JasperVanDerJeugt)
02:11:10 <Psycho_pr> Why does succ 1 % 2 given 1 % 1 yet succ 0.5 give 1.5? How to predict this?
02:12:55 <supki> > (succ 1 % 2, succ (1 % 2))
02:12:56 <lambdabot>  (1 % 1,3 % 2)
02:13:01 <Aetherspawn> > succ 0.1
02:13:02 <lambdabot>  1.1
02:13:06 <Aetherspawn> thats wrong
02:13:13 <Aetherspawn> it should be like 1.1000000000002 or something IMO
02:13:29 <supki> Psycho_pr: succ 1 % 2  is parsed as  (succ 1) % 2
02:13:30 <Aetherspawn> well, not wrong
02:13:35 <Aetherspawn> just a different POV
02:14:05 <supki> Psycho_pr: function application always binds tighter than any infix operator
02:14:15 <Psycho_pr> I see
02:14:54 <Psycho_pr> And what's the rationale behind having 1.5 be the successor of 0.5? Is it always going to be 1 no matter what?
02:15:24 <exicer> Are many people using haskell on the server side, and some js frontend framework on the client ?
02:15:42 <exicer> If so, what are people using on the server side ?
02:15:42 <jle`> exicer: many people use haskell for the full stack
02:16:14 <Psycho_pr> jle`: Is there a framework?
02:16:17 <jle`> if you're asking on #haskell what do you expect other tahn server side haskell? :P
02:16:28 <exicer> Hah, yeah true  :p
02:16:37 <exicer> personally I have been using it for data processing though
02:16:51 <jle`> Psycho_pr: there are many ways to write front end code in haskell that compiles to javascript
02:16:51 <exicer> So perhaps it wasn't that common to use as a rest-server type thing
02:17:07 <jle`> exicer: haskell is a pretty good rest server type kinda thing
02:17:20 <exicer> I had guessed this was the case :)
02:17:35 <exicer> Which package would you reccomend I look at ?
02:17:55 * hackagebot stylish-haskell 0.5.9.1 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.9.1 (JasperVanDerJeugt)
02:18:05 <jle`> exicer: have you done anything in web before?
02:18:10 <exicer> Yeah, in python
02:18:18 <exicer> I've messed around with httpconduit in haskell too
02:18:22 <jle`> what frameworks have you used?
02:18:26 <exicer> flask mostly
02:18:44 <jle`> the most yesod is commonly cited as the haskell analog of django/rails
02:19:09 <jle`> er
02:19:10 <exicer> Yeah, I have looked at yesod - it seems a bit heavy weight for what I want
02:19:11 <jle`> grammar.
02:19:14 <exicer> :p
02:19:24 <jle`> my favorite light weight one is Scotty
02:19:28 <exicer> although it would be nice to have stuff like user authentication built in
02:19:29 <jle`> if you've used sinatra in ruby, it's similar
02:19:34 <exicer> I've not
02:19:35 <jle`> a good balance is Snap
02:19:41 <toki78> Hi, I'm familiar with haskell, but I would be greatful, if someone could point me to excercises in the web
02:19:43 <jle`> which is light weight yet has a lot of good extensibility
02:19:46 <jle`> for things like auth
02:19:49 <jle`> snaplets
02:20:04 <exicer> I think I heard someone say something about using just the server part of yesod ?
02:20:07 <Guest79725> do you mean a textbook or some sort of problem solving?
02:20:10 <exicer> something like warp perhaps ?
02:20:20 <jle`> toki78: http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
02:20:33 <jle`> don't use vitrhualenv
02:20:37 <toki78> Guest79725, problem solving
02:21:42 <toki78> jle`, thanks !
02:22:08 <zomg> Warp is alright for quick and simple web stuff I think
02:22:25 <zomg> but I think there's a slight lack of useful middlewares for all common tasks you might want to do
02:22:44 <exicer> I will only want to do some very standard tasks, I think
02:22:46 <zomg> so you might end up having to do some extra work vs using something else
02:22:55 <exicer> eg create/authenticate users, db queries
02:23:13 <exicer> then most of the logic will take place on the frontend, with it all being linked up with some restish thing
02:25:08 <maxs`> What's a good gopher server for Haskell?
02:31:00 <aleksejs_> what type should I add here to avoid "ambiguous error"? http://vpaste.net/5xdom
02:32:06 <zomg> maxs`: ...people still user gopher?
02:32:42 <maxs`> *shrug* it's quicker to use from telnet than http
02:33:06 <zomg> lol
02:33:53 <maxs`> aleksejs_: your bug is a number cant be an integer and a fraction
02:34:16 <maxs`> it is just haskell can't tell you that because such a number may exist
02:35:20 <aleksejs_> maxs`, so, do I need to add strict typing?
02:35:54 <maxs`> no, you just need to go `fromIntegral` somewhere to go from a "Floating" to and "Integer"
02:36:00 <mello_> whilst being in Handler App App  monad i've got a function like so: foo <- liftM (fun  . otherfun . ...) $ liftIO somethingThatReturnsIO
02:36:10 <aleksejs_> maxs`, I tried
02:36:27 <mello_> how do I put it in a regular function
02:36:27 <maxs`> yeah im trying right now too
02:36:39 <mello_> i guess you can't move it out of do notation?
02:36:50 <passiveobserver> Hi All. can someone please help me sort out this basics' 101 question: this works: https://gist.github.com/ac12012014/8382944 this doesn't https://gist.github.com/ac12012014/8382996 why?
02:37:26 <mello_> passiveobserver, you are not in IO monad, so you can't get something out either.
02:37:44 <mello_> im not a haskell expert by any means so correct me here if im wrong, but the way I've learnt it
02:38:00 <mello_> IO is like a cage, so If you've got something in IO, then you can use do notation
02:38:04 <Saizan> passiveobserver: <- is not the way you bind a value to a name
02:38:08 <mello_> but [2] is not in IO
02:38:40 <mello_> print, on the other hand is a function that returns an IO (), so then all is good
02:38:42 <Saizan> passiveobserver: it's the way to bind the result of an IO (or other monads) actions to a name
02:38:45 <mello_> :t print
02:38:46 <lambdabot> Show a => a -> IO ()
02:38:46 <Cale> v <- x means "execute the action x, and call its result v"
02:39:04 <Cale> let v = x  means "define v to be the same thing as x"
02:39:09 <maxs`> aleksejs_: you just need to add "fromIntegral x" to the right side of logBase 10
02:39:11 <Cale> inside a do-block
02:39:32 <maxs`> logbase takes a floating number, while you use x as an integral number everywhere else
02:39:44 <mello_> passiveobserver, I advice you to learn how (>>=) works exactly, else you wont really get what <- does anyway
02:39:44 <Cale> passiveobserver: So you could write
02:39:53 <Cale> do let arr = [1,2,3]
02:39:53 <mello_> :t (>>=)
02:39:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:39:56 <Cale>    print arr
02:40:07 <jle`> basically you use <- to get the Int out of IO Int
02:40:29 <jle`> but if you alreay have an Int, you can just do let .. =
02:40:33 <Cale> Well, I don't like to say "get the Int out of IO Int" like there's nothing to it :)
02:40:53 <Cale> An IO Int is a description of some action you could perform which would result in an Int at the end
02:41:03 <Cale> and you use <- to carry out that action
02:41:14 <mello_> Ok, what you're actually doing is: [1] >>= (\arr-> print arr)
02:41:17 <Cale> and at the same time, give a name to the resulting Int
02:41:22 <mello_> but [1] is not a monadic value
02:41:27 <mello_> well it is! but yeah
02:41:31 <mello_> hard to explain --'
02:41:50 <jle`> it's not an IO monad value
02:41:52 <jle`> :p
02:41:57 <mello_> what jle` said
02:41:57 <Cale> It's best just to worry about IO, let's not bother with monads in general here
02:42:25 <Cale> We could explain how all this do-notation generalises to other monads, but that's a big diversion at this point :)
02:42:54 <jle`> Cale: just a handwavey way to answer the inevitable question "i have a function that needs an Int but i hav ean IO Int, what do I do?"
02:42:56 <jle`> :)
02:43:06 <jle`> but perhaps it might do more harm than good
02:43:40 <eazar001> print 3 >> print 4 >> return 5
02:43:44 <eazar001> > print 3 >> print 4 >> return 5
02:43:45 <lambdabot>  <IO Integer>
02:43:48 <Cale> The nice thing about the do-notation is that for a while, you can pretend that it just means what I explained, and you're not even wrong in thinking like that :)
02:43:58 <FreeFull> Is there a foldM somewhere?
02:43:59 <passiveobserver> Cale: thanks
02:44:13 <nadirs> jle`: is answering to that question with "just run the function inside the IO context" correct?
02:44:25 <jle`> nadirs: answering when to use <- instead of let .. =
02:44:30 <jle`> oh
02:44:34 <jle`> did not see the colon
02:44:47 <jle`> um
02:44:55 <Cale> nadirs: v <- x means "execute the action x, and call its result v", the do-block as a whole will itself define another IO action
02:44:58 <jle`> no i don't feel that it's correct.
02:45:10 <jle`> but i might be misunderstanding you\
02:45:22 <Cale> actions are not the same thing as functions
02:45:32 <Cale> Functions have a parameter
02:45:45 <Cale> i.e. functions f are the things for which it makes sense to write f x
02:45:48 <FreeFull> It's like building an AST that later gets executed by the runtime
02:46:21 <Cale> (Or another way to put it, functions are things of type A -> B for some types A and B)
02:46:38 <nadirs> but actually `v <- x` is simply `x (\v -> ...)`, isn't it?
02:46:46 <Cale> x >>= \v -> ...
02:46:53 <nadirs> yes, sorry :P
02:46:56 <Cale> Here are the rules:
02:47:03 <Cale> do { x } = x  -- base case
02:47:14 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
02:47:31 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
02:47:52 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
02:48:01 <jle`> i like to demonstrate that >> is just sequencing: do { putStrLn "hello"; putStrLn "world" } combines the two into one.  using x <- m allows you to name the (future) result of that m computation so you can use it in a later statement.
02:48:24 <jle`> but in the end it's all sequencing
02:48:39 <nadirs> "v <- x; y v" is some kind of a hanging lambda (definition borrowed from RWH), reversed. Or maybe not?
02:48:42 <jle`> it's the same as >> or ;, except we get to refer to the reuslt by name
02:48:48 <Cale> Right, you should think of do-notation as a way of gluing IO actions together into larger IO actions (or of course, more generally, you can think of it as doing this for actions in any monad)
02:48:49 <nadirs> (inside do notation, I mean)
02:49:22 <Cale> do { v <- x; y v } --> x >>= \v -> do { y v } --> x >>= \v -> y v
02:49:46 <Cale> which is equal to x >>= y
02:50:16 <jle`> or maybe it helps to see that every line is implicity _ <- x, _ <- y, _ <- z, etc.  but if we don't need it, we can drop it and leave it off.  we only use it if we want to refer to that result later on
02:50:38 <jle`> so really you can say do { _ <- putStrLn "hello"; putStrLn "world" } etc.
02:50:43 <jle`> and imagine it's there implicitly
02:51:07 <jle`> i am not sure what i am trying to answer anymore
02:51:08 <Cale> Or you can just define >> in terms of >>=
02:51:17 <jle`> oh yeah, what <- means.
02:51:22 <nadirs> jle`: after all, isn't (>>) implemented in terms of (>>=) but with `(\_ -> f)` instead of just `f`?
02:51:33 <Cale> yes
02:51:39 <jle`> @src (>>)
02:51:39 <lambdabot> m >> k      = m >>= \_ -> k
02:51:40 <Cale> That's correct nadirs
02:51:45 <jle`> ta da
02:51:51 <nadirs> Cale: RWH docet :)
02:53:39 <jle`> but still i get many questions of people trying to do things like ("hello, " ++ getLine) that to a new person it might help to explain that you need to use <- to extract the result; do { v <- getLine; return ("hello, " ++ v) }
02:54:22 <jle`> and that's really all you 'need to know'
02:54:34 <jle`> to actually do useful work
02:54:39 <zomg> jle`: agreed
02:54:46 <nadirs> jle`: I find somehow useful starting from a simpler monad like Maybe
02:55:07 <jle`> nadirs: not when you just want to tell someone who to do make "hello, " ++ getLine work
02:55:08 <jle`> :P
02:55:30 <nadirs> jle`: makes sense :)
02:55:30 <jle`> honestly sometimes i wish that people stopped mentioning/caring that IO was a monad >.>
02:56:12 <nadirs> jle`: like, "just use the damn (<-)"
02:56:18 <aleksejs_> maxs`, I had DC. Ha e you figured out how to fix that code?
02:56:38 <maxs`> aleksejs_: you just need to add "fromIntegral x" to the right side of logBase 10
02:56:41 <donri> (| ~ "hello" ++ getLine |) canhas idiom brackets?
02:56:44 <maxs`> logbase takes a floating number, while you use x as an integral number everywhere else
02:57:04 <jle`> like, knowing that IO is a monad gives you no insight at all into how to use IO or how IO works. even if you know what a monad is
02:57:16 <nadirs> donri: is that the famous Template Haskell?
02:57:25 <jle`> that's like saying that knowing you write Haskell in a text editor gives you insight into the Haskell language
02:57:26 <donri> nope it's the syntax in SHE
02:57:49 <donri> should desugar to pure (++) <*> pure "hello" <*> getLine
02:58:02 <donri> :t  pure (++) <*> pure "hello" <*> getLine
02:58:03 <lambdabot> IO [Char]
02:58:18 <nadirs> jle`: interesting comparison
02:59:01 <nadirs> donri: SHE? Is it this -> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/?
02:59:02 <Tehnix> hmm, does anyone know how to add a custom header to a network.http.conduit request without overriding the default headers? Atm `HTTP.requestHeaders = [("x-oauth-basic", "value")]` means that there is no user-agent header for example :/
02:59:07 <donri> yes
02:59:15 <donri> https://personal.cis.strath.ac.uk/conor.mcbride/pub/she/idiom.html
02:59:35 <donri> rumored to be coming to a future ghc, but probably not 7.8 or maybe even not 7.10
03:00:24 <zomg> Tehnix: I don't think there is a default user-agent which is why you're not getting one
03:00:29 <jle`> i do wish there was a way to do something like (++) <$> getLine <*> getLine but with (++) in the middle/infixy somehow.
03:00:50 <jle`> forcing it to be used prefix is the most awkward part about applicative style.
03:00:56 <Tehnix> zomg: oh :/ hmm, do you know what is a good default to set or smth like that?
03:01:36 <zomg> Tehnix: if you want to avoid any special cases people put into their bad web apps, check what user-agent Chrome or such sends and use that
03:01:57 <zomg> although the "proper way" would be to send a UA name that identifies your program uniquely
03:02:05 <zomg> eg myprogram 1.0
03:02:07 <zomg> or whatever
03:02:14 <maxs`> or send the mobile UA so youtube works without flash
03:02:15 <Tehnix> ah, kk :)
03:02:22 <maxs`> :P
03:02:22 <zomg> but some web apps may handle unusual UA names differently so just something to keep in mind
03:02:37 <Tehnix> it's just for an API though, so I don't think a browser specific one is needed
03:58:03 --- mode: hubbard.freenode.net set +o ChanServ
03:58:28 <Aetherspawn> raises some interesting points about $!
03:58:29 <Aetherspawn> im a little confused why f x $! .. is strict when x isn't, or something
03:58:43 <eazar001> yea
03:58:59 <eazar001> oh you mean in the tail recursive version?
03:59:03 <Aetherspawn> yeah
03:59:12 <Aetherspawn> why doesn't just just make the firs tparam lazy
03:59:15 <Aetherspawn> and the last strict
03:59:23 <eazar001> in the tail recursive version apparently it is not completely strict
04:00:31 <eazar001> something to do with haskell compiler and laziness, but to tell you the truth i'm not completely sure
04:00:47 <eazar001> short answer is that just making something tail recursive, i.e. using an accumulator alone ....
04:00:53 <Aetherspawn> pfft, maybe its just easier to -O11 everything
04:00:56 <eazar001> is not sufficient to optimize out thunks
04:01:27 <eazar001> well you can profile your code if you want to experiment with it
04:02:04 <eazar001> sometimes when looking at answers/documentation, i still feel vague about certain ideas ...
04:02:12 <Cale> Expressions are evaluated outermost-first, that's half of what lazy evaluation is.
04:02:15 <eazar001> so i guess the best i can recommend to you is to do some demo code to test it out
04:02:22 <aristid> i'm excited, Tekmo created a new easier-to-use replacement for FreeT in pipes-parse and i'm test-driving it :)
04:02:57 <eazar001> Aetherspawn: what Cale said [=
04:03:03 <Cale> (the other half being that when you have a bound variable, any work done to evaluate the thing it's bound to is shared amongst the occurrences of that variable
04:03:06 <Cale> )
04:03:35 <Cale> Tail recursion optimisation refers to a very specific sort of evaluator for strict languages
04:03:50 <eazar001> i.e. SML
04:04:36 <Cale> i.e. one where you have a call stack
04:04:52 <Cale> Lazy evaluators tend not to have anything which you'd refer to as a call stack
04:05:06 <Aetherspawn> hm
04:05:08 <Cale> So there's nothing to apply tail recursion optimisation *to*
04:05:58 <Cale> The stack you'll see GHC refer to (which at some lower level could be thought of as a call stack, but not from the level of Haskell), is perhaps better referred to as a pattern match stack
04:06:23 <Cale> i.e. it more or less consists of case expressions who are waiting for their scrutinee to be sufficiently evaluated to match a pattern
04:06:44 <Cale> (so we remember which case expression to come back to once that expression is evaluted)
04:07:02 <eazar001> thanks Calehmmm
04:07:04 <Cale> When you have something like
04:07:07 <Cale> @src foldl
04:07:07 <lambdabot> foldl f z []     = z
04:07:07 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:07:13 <Cale> foldl (+) 0 [1,2,3]
04:07:20 <Cale> --> foldl (+) (0 + 1) [2,3]
04:07:26 <Cale> --> foldl (+) ((0 + 1) + 2) [3]
04:07:33 <Cale> --> foldl (+) (((0 + 1) + 2) + 3) []
04:07:41 <Cale> --> (((0 + 1) + 2) + 3)
04:07:58 <Cale> Up to this point, we'll only have used at most one stack entry, for pattern matching against the list
04:08:29 <Cale> But the list is already evaluated, so we never had to wait very long before the stack was cleared again
04:08:41 <Cale> However, at this point, we have a problem
04:08:50 <Cale> The outermost (+) gets to evaluate
04:08:55 <Cale> (...) + 3
04:09:14 <Cale> and as it happens, it is going to pattern match on both its arguments
04:10:08 <Cale> (this is sort of a poor example, because we normally don't think about the data constructor for Integer, but it's in there somewhere)
04:10:31 <ReinH> Cale: I have variously heard that stack referred to as a pattern match stack or an "evaluation stack".
04:10:40 <Cale> and so the pattern match done by (+) goes on the stack, and we start evaluating ((0 + 1) + 2)
04:10:45 <ReinH> Cale: but I think pattern match is more clear
04:11:20 <Walther> What's the difference between foldl and foldl1 (and foldr, foldr1 respectively)
04:11:33 <ReinH> Walther: the 1 versions assume a non-empty list
04:11:39 <ReinH> @src foldr1
04:11:39 <lambdabot> foldr1 _ [x]    = x
04:11:39 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
04:11:39 <lambdabot> foldr1 _ []     = undefined
04:11:49 <eazar001> Cale, side question: have you examined the lower level code before?
04:11:52 <Cale> There actually is one other case where this stack is applied which I'm ignoring. It's when you have an expression like f y and f is not a lambda, but instead some other expression like g x, then there will be an entry on the stack while the function is evaluated.
04:11:54 <Cale> eazar001: yes
04:12:03 <eazar001> i see
04:12:18 <Cale> eazar001: I'm giving a very high-level account of what's going on
04:12:31 <eazar001> so you have seen the case expressions in the assembly then?
04:12:46 <eazar001> sorry go on with you explanation
04:12:47 <Cale> Well, there's a bunch of translations which take place :)
04:13:03 <eazar001> k, no worries
04:13:06 <Cale> Evaluating an expression becomes jumping along a code pointer
04:13:29 <eazar001> i see
04:13:42 <eazar001> how did you debug it?
04:14:13 <eazar001> did you just simply drop the executable into something like ollydbg?
04:14:38 <Cale> If you use the --ddump-simpl flag, you can see a useful intermediate language representation called Core
04:14:49 <Cale> If you use --ddump-asm you'll get assembly as well
04:15:04 <eazar001> hmmmm, pretty sweet
04:15:22 <Cale> I recommend using the ghc-core program from hackage, which will syntax colour everything for you
04:15:47 <ReinH> reading core without ghc-core is... not advised.
04:15:48 <eazar001> awesome, taking notes [=
04:15:49 <Cale> also, there are some flags to reduce the noise in the Core output, because it's heavily annotated, type applications are explicit
04:16:29 <Cale> -dsuppress-idinfo
04:16:35 <Cale> -dsuppress-type-applications
04:16:40 <Cale> -dsuppress-coercions
04:16:50 <shachaf> -dsuppress-all
04:17:11 <Cale> yeah
04:17:31 <shachaf> (That suppresses a bit too much. A reasonable default would suppress a bit less than -all but a lot more than nothing.)
04:17:38 <eazar001> cool, it's about time i give haskell a lower level run through, thanks for the info guys
04:17:51 <Cale> http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/options-debugging.html#idp39327824
04:18:02 <Cale> If you want to have a better sense of what's going on
04:18:05 <Cale> there's a nice paper
04:18:23 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
04:18:43 <Cale> This isn't *quite* accurate to how GHC does things today, but it's still very close
04:18:52 <eazar001> Have you ever done anything with it non-pedantic? i.e. optimizations?
04:18:58 <eazar001> or was it just never necessary?
04:19:30 <Cale> I've used Core to do optimisations before. It's usually not necessary, but if you're trying to compete with some C program, it might be very useful.
04:19:37 <ReinH> -dsuppress-stuff-i-dont-care-about pls
04:19:49 <eazar001> right, makes sense
04:20:06 <ReinH> Or trying to figure out why your Vector code isn't fusing
04:20:25 <eazar001> alright, well at any rate i must call it a night (or morning, for that matter) [=
04:20:28 <Cale> There was a guy on here just the other day, who was trying to optimise the computation of a hash function, and he was seeing using the profiler that it was doing about 4 times the amount of allocation as the input, and the garbage collector was cutting into the time
04:20:29 <ReinH> ofc then you have to try to understanad the rules o_O
04:21:02 <Cale> and so I went and had a look at the Core, and figured out a way to used unboxed data structures to avoid allocating a bunch of intermediate Word32 values
04:21:04 <eazar001> wow!!!!
04:21:25 <Cale> and that made GHC compile the thing into a non-allocating loop
04:21:33 <Cale> which kept everything in registers
04:21:44 <Cale> apparently it ran faster than some C implementation he had :)
04:22:03 <eazar001> interesting you bourght that up ...
04:22:03 <Aetherspawn> Cale: cool!
04:22:12 <ReinH> o_O
04:22:16 <ReinH> Cale: nice
04:22:22 <eazar001> i had agressive GC problems with SML before too
04:22:26 <eazar001> so this applies specifically to me
04:22:28 <Cale> (I actually just copied the Core back out and tweaked it back into compiling Haskell code, sans some data constructors)
04:22:50 <eazar001> that is awesome
04:23:35 <eazar001> alright, night guys
04:23:38 <Cale> g'night!
04:23:45 <eazar001> thanks schachaf, Cale
04:23:48 <ReinH> Cale: do you sleep?
04:23:53 <eazar001> good luck Aetherspawn
04:23:55 <Cale> I slept early
04:24:02 <Cale> Woke up at 6
04:24:03 <ReinH> because I don't
04:24:05 <ReinH> unfortunately
04:24:20 <Cale> My sleep schedule is very very inconsistent
04:24:39 <Cale> http://ircbrowse.net/nick/Cale?recent=false -- as you might be able to guess from here
04:25:17 <Cale> I don't really sleep, I just become a bit less active for certain hours :)
04:25:37 <Cale> Hours which happen to be in the daytime, for the most part :)
04:26:01 <Cale> oh, I guess that's UTC
04:26:22 <Cale> I'm in -5
04:26:40 <zipper> http://www.youtube.com/watch?v=xM6Bhy0Xy6E
04:26:40 <zipper> hilarious ^^
04:28:01 --- mode: ChanServ set +o shachaf
04:28:15 --- mode: shachaf set +b *!*zipper@unaffiliated/zipper
04:28:15 --- kick: zipper was kicked by shachaf (spam)
04:28:20 --- mode: shachaf set -o shachaf
04:28:30 <Cale> Not sure that required a ban
04:29:09 <ReinH> Cale: <3 http://ircbrowse.net/browse/haskell?id=14210622&timestamp=1347921950#t1347921950
04:30:03 <Cale> ReinH: Did you see the code I was referring to?
04:30:24 <ReinH> Cale: lol no o_O
04:30:37 <Cale> oh, you have to see it, it's remarkable
04:30:48 <Cale> Let me get a link
04:31:37 <Cale> https://github.com/gpc/grails-searchable/tree/master/src/java/grails/plugin/searchable/internal/compass/mapping
04:31:48 <Cale> https://github.com/gpc/grails-searchable/blob/master/src/java/grails/plugin/searchable/internal/compass/mapping/AbstractSearchableGrailsDomainClassCompassClassMapper.java -- look at this stuff :)
04:32:06 <ion> :-)
04:32:13 <Cale> https://github.com/gpc/grails-searchable/blob/master/src/java/grails/plugin/searchable/internal/compass/mapping/SearchableGrailsDomainClassCompassClassMapperFactory.java
04:32:20 <Cale> BRILLANT
04:32:22 <ReinH> yeah that's brilliant
04:32:24 <ReinH> heh
04:33:11 <ion> I love the documentation comment.
04:35:08 <aristid> i've seen the future of generic I/O, and it is: data List f m r = Cons (f m (List f m r)) | Impure (m (List f m r)) | Nil r
04:35:58 <ion> f m l
04:37:13 <ReinH> aristid: that looks suspiciously like a free monad with some extra dangly bits...
04:37:35 <Aetherspawn> oh lawd Cale
04:37:40 <Aetherspawn> I dont want to go to sleep anymore
04:37:43 <Aetherspawn> I might get nightmares
04:37:47 <Cale> hahaha
04:38:09 <ReinH> aristid: "extra dangly bits" is of course a category theoretical term you may not be familiar with yet
04:38:11 <Aetherspawn> I'll sleep and I'll dream they deleted ADTs from haskell
04:38:14 <Aetherspawn> and factory became idiom
04:38:20 <Aetherspawn> ;_;
04:38:58 <Aetherspawn> It's a pity the Immix garbage collector guy left
04:39:05 <Aetherspawn> it looked like it had potential
04:39:27 <aristid> ReinH: well it's supposed to be easier to use than FreeT, and so far it seems to achieve that goal
04:39:47 <Cale> The context of where I ran into this was trying to sort out a performance problem in this terrible Groovy/Grails backend for skedge.me. It was using this searchable plugin, which turns out to be a binding to this thing called Compass, which is itself a wrapper around Lucene which is a tool for doing full text search in databases. The code in question was using it to do something that could be done by a single SQL query.
04:39:51 <ReinH> aristid: makes sense
04:39:53 <aristid> it only gives up on being a MonadTrans instance, as you need a "weird" Functor f m constraint
04:40:12 <Cale> We ended up replacing that backend with one in Haskell :)
04:40:48 <ion> cale: Oh, you have actually had to work with that code? I’m sorry for you.
04:40:57 <Cale> I didn't in the end
04:41:10 <ion> Someone should send a pull request for SearchableGrailsDomainClassCompassClassMapperFactoryFactory
04:41:10 <Cale> I just removed it as a dependency of our codebase, after laughing at it.
04:42:41 <SimonJF> Cale: it's actual code? When you linked it, I thought it was satire
04:44:05 <Cale> SimonJF: It's actual code
04:44:11 <benmachine> yeah I had trouble with that distinction
04:44:19 <benmachine> I think if it was satire it would be more subtle :P
04:44:28 <SimonJF> oh dear.
04:44:28 <ion> Poe’s law
04:45:41 <ReinH> Poe's... yeah
04:49:35 <aristid> ReinH: i've been tempted to think about it as a free monad over a functor transformer. makes any sense? :)
04:54:57 <ReinH> aristid: it makes *some* sense.
04:55:10 <ReinH> it parses as an English sentence, for starters.
04:55:30 <ReinH> Mostly.
04:55:31 <maxs`> zomg: it works https://pbs.twimg.com/media/Bdx8iYtCYAAmbxt.jpg
04:55:42 <aristid> ReinH: is that the extent of it tho?
04:56:00 <ReinH> aristid: no I think it makes sense
04:56:11 <ReinH> fsvo functor transformer
04:57:13 <aristid> so if you also have the type data Of a (m :: * -> *) r = a `Onto` r, then you can do things like List (List (Of a)) IO ()
04:57:40 <ReinH> hmm
04:58:23 <ReinH> aristid: sorry I was looking at some commutativity diagrams and I went all crosseyed for a second
04:58:27 <aristid> so you have nesting but the type enforces sequential traversal
04:58:54 <ReinH> I swear cat theory is just an excuse for grown men to draw boxes and triangles and random letters.
04:59:14 <ReinH> aristid: right hmm
04:59:35 <aristid> we should invent something more practical than category theory. how about "haskell streaming I/O theory"?
04:59:43 <aristid> it's a booming field
05:00:31 <aristid> ReinH: the only problem is i haven't tried to prove yet that it's actually a valid Monad:)
05:00:37 <aristid> waiting for Tekmo to do that.
05:00:40 <Cale> I'd really like to see how something along the lines of Pipes turns out in a dependently typed language.
05:00:50 <Cale> I bet you could make it much prettier.
05:01:27 <aristid> List has only three parameters, that's very little by pipes-standards
05:06:37 <Twey> Cale: That's very Java
05:07:28 <Twey> I don't think I've seen code that was more Java since the Enterprise FizzBuzz.
05:07:54 <Cale> haha
05:08:36 * hackagebot hgopher 0.1.0.0 - Gopher server  http://hackage.haskell.org/package/hgopher-0.1.0.0 (MaxwellSwadling)
05:13:19 --- mode: ChanServ set +o Cale
05:13:24 --- mode: Cale set -b *!*zipper@unaffiliated/zipper
05:13:30 --- mode: Cale set -o Cale
05:19:02 <Walther> Okay, interesting question (at least for me, it is interesting!)
05:19:13 <Walther> cell = choice $ ['A'..'Z'] ++ [' ']
05:19:38 <Walther> Why can't I spawn = take len (repeat (runRVar cell StdRandom))
05:19:56 <Walther> "    No instance for (MonadRandom m0) arising from a use of `runRVar'
05:20:07 <Cale> What's the type of choice?
05:20:41 <Walther> choice :: [a] -> RVar a
05:20:54 <Cale> okay, and what's the type of runRVar?
05:21:10 <Walther> runRVar :: RandomSource m s => RVar a -> s -> m a
05:21:35 <kenkku> Walther: still trying to randomize? :P
05:22:01 <Walther> kenkku: re-writing my dawkins' weasel from scratch, trying to make it more reasonable this time. And no, still not quite grokking Random in haskell
05:22:16 <Cale> Walther: okay, could you put your module on lpaste?
05:22:17 <kenkku> fun, fun
05:22:30 <klrr> anyone got chrisdone's Lisk source code somewhere? apperantly he deleted the repo
05:22:46 <Cale> I think it's likely that the type of spawn isn't the type you expected.
05:23:49 <Walther> Cale: There's not much in my current rewrite. http://lpaste.net/3589027989985165312
05:24:04 <Cale> (I hadn't seen any earlier code you pasted)
05:24:26 <Walther> (which is probably good, to avoid just gluing code from there)
05:24:59 <Walther> it compiles if you comment out "spawn" function
05:25:06 <Walther> well, :loads
05:25:44 <Walther> and all the individual functions there work, but trying to take len (repeat (runRVar cell StdRandom)) results in funky monad errors
05:27:32 <Cale> What happens if you write   spawn :: (RandomSource m StdRandom) => [m Char]
05:28:21 <Cale> Or even perhaps:  spawn :: (MonadRandom m) => [m Char]
05:28:24 <Walther> non-type variable arguments
05:28:29 <Cale> what?
05:28:34 <Cale> oh
05:28:35 <Cale> hah
05:28:45 <Cale> Yeah, that would require FlexibleContexts to write
05:28:48 <Cale> try the second one
05:29:01 <Cale> (FlexibleContexts is a harmless extension to enable though)
05:29:58 <Cale> I believe your problem is that the monomorphism restriction is applying to the definition of spawn, since it's a pattern binding with no explicit type signature
05:30:04 <Walther> now it :loads, but trying to call spawn results in     No instance for (MonadRandom m0) arising from a use of `spawn'
05:30:08 <Twey> donri: Agda's fixed your issue: it now complains about pattern variables with the same names as constructors
05:30:09 <Walther>     The type variable `m0' is ambiguous
05:30:13 <Cale> yep, because the type is ambiguous
05:30:22 <Cale> Do you want spawn to be a list of IO actions?
05:30:23 <Walther> which one where ._.
05:30:32 <Cale> Or a list of actions of some other monad?
05:30:47 <ChongLi> hey
05:30:53 <Cale> You could also write:  spawn :: [IO Char]
05:30:53 <Walther> spawn needs to be a single IO of a list (i.e. it spits out a sentence)
05:31:03 <Cale> ah, in that case, you'll need to apply sequence
05:31:07 <Cale> :t sequence
05:31:08 <lambdabot> Monad m => [m a] -> m [a]
05:31:14 <ChongLi> still working on Dawkins' Weasel, I see
05:31:22 <Cale> sequence takes a list of actions, and glues them together into an action that produces a list
05:31:29 <Walther> ChongLi: Nod, making a rewrite, trying to make it more reasonable :)
05:31:33 <Cale> Also, take n . repeat
05:31:37 <Cale> is the same as replicate n
05:31:43 <Cale> and  sequence . replicate n
05:31:48 <Cale> is the same as  replicateM n
05:32:19 <Cale> So you could write  spawn :: IO String
05:32:25 <Walther> with spawn :: IO [Char], Couldn't match expected type `IO [Char]'with actual type `[m0 Char]'
05:32:32 <Cale> spawn = replicateM len (runRVar cell StdRandom)
05:33:05 <Cale> Walther: The code you've provided has a type like [IO Char], not IO [Char]
05:33:07 <Walther> agh, replicateM, how do monads work :|
05:33:14 <Cale> Let's take a look at sequence
05:33:15 <Walther> Cale: do elaborate
05:33:35 <Walther> I don't have sequence there.
05:33:49 <Cale> sequence's job is to take a list of actions, and produce an action which will run each of them in turn, returning a list of the results
05:34:04 <Cale> Let's suppose we wanted to write sequence ourselves
05:34:13 <Cale> sequence :: (Monad m) => [m a] -> m [a]
05:34:21 <Cale> sequence [] = ...
05:34:39 <Cale> in the case of an empty list of actions, we want the resulting action to do nothing, and produce an empty list of results
05:34:40 <Cale> so
05:34:43 <Cale> sequence [] = return []
05:34:47 <Walther> ah, so so a sequence is sort of a pseudo-threader or something- in the end returns all tasks' return values
05:34:49 <Cale> that's what return is for
05:34:54 <Cale> sequence (x:xs) = ...
05:34:56 <aristid> ReinH: amazingly, if instead of "Of" you use ReaderT, what you get looks quite like a Consumer
05:35:07 <Cale> if the list of actions is nonempty, starting with x, and continuing with xs
05:35:18 <Cale> then we first want to run x to get some result v...
05:35:22 <ChongLi> Walther: it doesn't do threading, per se; it literally sequences the actions
05:35:23 <Cale> sequence (x:xs) = do v <- x; ...
05:35:45 <ChongLi> Walther: if you think of a list of actions like a shell script
05:35:47 <Cale> and then we want to run the rest of the actions in the list. Thankfully, we have a function to do that, it's the function we're writing!
05:35:54 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
05:35:56 <Walther> ChongLi: nod, hence the "pseudo" there... I'm not sure I'm able to put my thoughts into words correctly right now, but anyway
05:35:58 <ChongLi> then sequence is the command that executes the shell script (i.e. bash)
05:36:04 <Walther> I think I got the idea of sequence now.
05:36:12 <lycantrophe> Hullo. In order to practice Haskell I have this small issue: I have a (binary) tree that I want to enumerate in order to print a graphviz representation of the structure to verify that it is built correctly.
05:36:16 <Cale> and then we just need to stick the initial result onto the list of the rest of the results and return that:
05:36:18 <Walther> Now; why does that spawn function need sequence instead of just replicate?
05:36:20 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:36:38 <Cale> Well, what type is runRVar cell StdRandom?
05:36:39 <lycantrophe> The real issue is unique node names.
05:36:49 <Cale> It's an IO Char, right?
05:36:59 <Cale> (actually it has a more general type, but let's pretend)
05:37:14 <Cale> :t repeat
05:37:15 <lambdabot> a -> [a]
05:37:19 <lycantrophe> ... I just think I realized how to do it.
05:37:26 <Cale> So repeat (runRVar cell StdRandom) :: [IO Char]
05:37:29 <Cale> agree?
05:37:35 <Walther> lycantrophe: the magic of publicly asking something and just then realizing the solution
05:37:38 <Cale> We have a list of IO actions
05:37:41 <Walther> Cale: hmmm
05:37:43 <ChongLi> I noticed we're still on Data.Random and not using System.Random :(
05:37:51 <lycantrophe> Walther: I've been experimenting with various techniques for half a day or so
05:38:01 <Cale> > repeat 1
05:38:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
05:38:03 <lycantrophe> Walther: the "problem" is that foldr always take -the same- function
05:38:07 <Cale> > repeat "hello"
05:38:08 <Walther> ChongLi: shush, it works wonders for having a choice of ['A'..'Z'] ++ " "
05:38:08 <lambdabot>  ["hello","hello","hello","hello","hello","hello","hello","hello","hello","he...
05:38:13 <Cale> > repeat getLine
05:38:14 <lycantrophe> Walther: but I can just use the state monad inside the -accumulated- value
05:38:14 <lambdabot>  [<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO [Char]>,<IO...
05:38:22 <ChongLi> Walther: so does System.Random
05:38:44 <Cale> Walther: Does that make sense?
05:38:46 <Walther> ChongLi: I still haven't figured how to *easily* include that space char in the list of possible chars.
05:38:56 <lycantrophe> Might not even need the monad
05:39:14 <Walther> Cale: and how does sequence make sure we have actual chars instead of IO chars?
05:39:28 <Walther> > :t sequence
05:39:29 <lambdabot>  <hint>:1:1: parse error on input `:'
05:39:39 <Walther> :t sequence
05:39:40 <lambdabot> Monad m => [m a] -> m [a]
05:39:49 <ChongLi> > ord ' '
05:39:50 <lambdabot>  32
05:39:51 <Walther> right, back to the Monad business.
05:39:57 <ChongLi> > ord 'Z'
05:39:58 <lambdabot>  90
05:40:09 <Cale> Walther: It is important to realise that a value of type IO Char is absolutely nothing like a Char at all
05:40:15 <Walther> Cale: Nod.
05:40:30 <Walther> But how does sequence magically transform IO Chars to Chars?
05:40:33 <Cale> Walther: It's a description of some stuff which could be done which would produce a Char result at the end
05:40:49 <Walther> nod
05:40:55 <Cale> The action produced by sequence executes each of the IO Char actions in turn
05:40:59 <ChongLi> Walther: sequence transforms [IO Char] -> IO String
05:41:00 <Cale> collecting their results into a list
05:41:08 <Walther> Ahhh
05:41:10 <Walther> Thanks.
05:41:12 <Cale> I think there were some people being distracting as I went over the code for it
05:41:19 <Cale> So I'll do it again
05:41:27 <ChongLi> Cale: sorry
05:41:38 <Walther> I got it now :)
05:41:53 <ChongLi> Walther: it's just like shell scripts
05:42:00 <ChongLi> well, not *just* like them
05:42:08 <Cale> sequence [] = return [] -- if we're given the empty list of actions, we want the resulting action to do nothing, and produce an empty list of results, which is what the action (return []) does.
05:42:08 <ChongLi> but the idea of computation as a value
05:42:19 <Cale> sequence (x:xs) = ...
05:42:25 <Cale> if we're given a nonempty list of actions
05:42:41 <dreixel> I want to implement a monitor which forks out up to N worker threads to perform tasks. when N workers are active, the monitor should wait until one finishes, and only then create a new worker. is it a bad idea to use threadDelay and loop for this "wait till there's room" behaviour?
05:42:42 <Cale> then we first want to run the action x, which will get us some result v
05:42:49 <Cale> i.e. if x :: IO Char, then v :: Char
05:42:56 <Cale> sequence (x:xs) = do v <- x; ...
05:43:14 <Walther> AHA!, sequence has a do-block in it
05:43:21 <Walther> :src sequence
05:43:24 <Cale> and then we want to run the rest of the list of actions in turn, getting some list of results, so we apply the sequence function recursively
05:43:34 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
05:43:46 <Cale> and now we have that first result v, and the rest of the results vs
05:43:47 <Walther> @src sequence
05:43:47 <lambdabot> sequence []     = return []
05:43:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:43:47 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
05:43:58 <Cale> and so we glue those together into a final list
05:44:04 <Walther> right, there is nothing more than your explanations :P
05:44:04 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:44:24 <ChongLi> Walther: there is no magic here :)
05:44:35 <Walther> ^^,
05:44:45 <ChongLi> just plain old recursion on lists
05:44:50 <Walther> :t replicateM
05:44:51 <lambdabot> Monad m => Int -> m a -> m [a]
05:45:00 <Walther> right-o. Let's see
05:45:53 <Cale> If you want to write replicateM, you can either use sequence, or do it directly using recursion.
05:47:13 <PTBD> hello. can somebody explain me why this works: any' p = or . map p     but         any' = or . map         does not.
05:47:41 <Cale> Because if you apply map to some value f
05:47:46 <Cale> you get another function
05:47:55 <Cale> If f :: (a -> b)
05:48:02 <Cale> then map f :: [a] -> [b]
05:48:10 <Cale> and then applying or to that function is a type error
05:48:13 <Cale> because it's not a list
05:48:23 <ChongLi> Couldn't match type `[a0] -> [b0]' with `[Bool]'
05:48:51 <benedikt> http://lpaste.net/7443974288782131200
05:49:03 <Cale> PTBD: You could write any' = (or .) . map
05:49:16 <Cale> PTBD: i.e. compose or with the resulting function
05:49:32 <benedikt> how do i "access" p of RSAPrimes (line 17) ? I just get an error about not eing able to match the expected type (without IO) with the actual type (with IO)
05:49:35 <ChongLi> but it's less clear
05:49:47 <PTBD> Cale, is there a name for this syntax, So I can read little bit more?
05:49:55 <Cale> That's an operator section
05:50:00 <ChongLi> having a variable p makes the code a little clearer
05:50:04 <PTBD> I mean not writing the parameters
05:50:06 <Cale> (x *) means (\v -> x * v)
05:50:14 <Cale> Or (*) x rather
05:50:15 <ChongLi> since p is assumed to be a predicate
05:50:27 <Cale> (there's not much difference between those)
05:51:05 <Cale> PTBD: It works with any infix operator whatsoever
05:51:16 <Cale> > map (1 +) [10,20,30]
05:51:17 <lambdabot>  [11,21,31]
05:51:38 <Cale> and it also works on both sides: (* x) means (\v -> v * x)
05:51:57 <FreeFull> Operator sections are awesome
05:51:59 <Cale> > map (/ 2) [10,20,30]
05:52:00 <lambdabot>  [5.0,10.0,15.0]
05:52:41 <Cale> You have to be a little careful about -, which is a special case, since (- x) means the negation of x, rather than the function which subtracts x
05:53:14 <Cale> As a consolation, the Prelude has a function subtract x = (\v -> v - x)
05:53:45 * hackagebot NoTrace 0.2.0.1 - Remove all the functions come from Debug.Trace after debugging  http://hackage.haskell.org/package/NoTrace-0.2.0.1 (CindyLinz)
05:54:29 <Cale> (Or of course, you could write something like (+(-1)) in place of subtract 1
05:54:31 <Cale> )
05:55:09 <ChongLi> No instance for (Num (a0 -> b0)) arising from a use of syntactic negation
05:55:17 <ChongLi> this is the sort of error you get
05:55:30 <ChongLi> the key words to look for are "syntactic negation"
05:55:51 <ChongLi> that's letting you know that the compiler is inferring negation when you mean a function
05:56:16 <ChongLi> > map (- 3) [1,2,3]
05:56:17 <lambdabot>  Could not deduce (GHC.Num.Num (GHC.Integer.Type.Integer -> b))
05:56:18 <lambdabot>    arising from the ambiguity check for `e_13123'
05:56:18 <lambdabot>  from the context (GHC.Num.Num (a -> b), GHC.Num.Num a)
05:56:18 <lambdabot>    bound by the inferred type for `e_13123':
05:56:18 <lambdabot>               (GHC.Num.Num (a -> b), GHC.Num.Num a) => [b]
05:56:25 <ChongLi> oh, thanks lambdabot :)
05:56:37 <Cale> tee hee
05:57:06 <Cale> I wonder which version of GHC lambdabot is using
05:57:49 <Walther> I find myself typing "runRVar something StdRandom" quite a lot - there probably is an easy way to create a functionfunction that takes function "something" and runs the wrapper
05:57:52 <aristid> > map (subtract 3) [1,2,3]
05:57:53 <lambdabot>  [-2,-1,0]
05:58:17 <Cale> Walther: Of course, "something" there had better not be a function.
05:58:26 <Cale> Because it needs to be an RVar :)
05:58:44 <Walther> ermmm, a function that returns a RVar ;)
05:58:47 <Cale> You absolutely can write
05:58:58 <Cale> run r = runRVar r StdRandom
05:59:07 <Walther> thanks!
05:59:58 <Cale> Walther: Well, it can't be a function which returns an RVar either, it must be exactly something of type RVar a for some type a.
06:00:38 <Cale> Walther: I'm just being picky though
06:00:42 <Walther> heh
06:00:47 <Cale> Walther: Functions are values of type A -> B for some types A and B
06:00:50 <Cale> and nothing else
06:02:00 <Walther> Why is run :: MonadRandom m => RVar a -> m a
06:02:08 <ChongLi> the key insight here is that even functions of type a -> b -> c are also of type a -> b
06:02:16 <Cale> Walther: What type did you expect?
06:02:16 <Walther> i.e., why did Monad appear there again
06:02:25 <Cale> runRVar :: RandomSource m s => RVar a -> s -> m a
06:02:26 <Walther> I'm trying to "get" what a Monad is
06:02:39 <Cale> There is an instance:
06:02:42 <ChongLi> :t map
06:02:43 <lambdabot> (a -> b) -> [a] -> [b]
06:02:44 <Cale> (Monad m, MonadRandom m) => RandomSource m StdRandom
06:02:50 <ChongLi> :t map (+) [1,2,3]
06:02:50 <lambdabot> Num a => [a -> a]
06:03:30 <Cale> So it saw that the 's' in the type of runRVar was StdRandom
06:03:36 <Walther> my brain hurts from trying to understand based on pure type declaration alone
06:03:43 <Walther> so please do try to explain in words
06:03:44 <Cale> (StdRandom is a type with one value which is also called StdRandom)
06:04:03 <ChongLi> > map (+) [1,2,3] <*> [4,5,6]
06:04:04 <lambdabot>  [5,6,7,6,7,8,7,8,9]
06:04:15 <Cale> and so the 's' in the constraint RandomSource m s has to be StdRandom
06:05:42 <Walther> Cale: from where is <*>?
06:05:46 <ChongLi> > map (,) [1,2,3] <*> "abc"
06:05:47 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
06:06:04 <ChongLi> @src (<*>)
06:06:04 <lambdabot> Source not found. That's something I cannot allow to happen.
06:06:06 <FreeFull> <*> is from Control.Applicative
06:06:06 <Walther> erm, wrong highlight
06:06:15 <Cale> So it says "oh, I can deal with this RandomSource m s constraint using the instance (Monad m, MonadRandom m) => RandomSource m StdRandom
06:06:30 <Cale> but now I need an instance Monad m and MonadRandom m
06:06:56 <Cale> as it happens, MonadRandom m is a subclass of Monad m, so the Monad m constraint is redundant, and it removes that
06:06:57 <Walther> so you can get all possible combinations of two dice with... let me see
06:07:01 <Walther> > map (,) [1..6] <*> [1..6]
06:07:02 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
06:07:05 <Walther> HA
06:07:22 <Cale> > (,) <$> [1..6] <*> [1..6]
06:07:22 <ChongLi> Walther: pretty nice huh
06:07:23 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(2,1),(2,2),(2,3),(2,4),(2,5),(2,6),(3,...
06:07:40 <ChongLi> the beauty of cartesian products
06:07:43 <Cale> Sometimes it's nice when you're using <*> to also use <$> which is a synonym for fmap
06:08:00 <ChongLi> this is why pairs are sometimes called product types
06:08:12 <Cale> Uh, kinda :)
06:08:22 <ChongLi> and for lots of other reasons :)
06:08:59 <Cale> I suppose the analogy is that if A is a type with n values, and B is a type with m values, then (A,B) is a type with n*m values (not quite really true in Haskell)
06:09:21 <ChongLi> yeah, you have to add bottom to each :)
06:09:45 <Cale> But if we're talking about fully-defined values, it's true :)
06:10:11 <Cale> and we have that paper to tell us that fast and loose reasoning of this sort is morally correct :)
06:11:35 <Walther> But yeah. I still need to figure out what exactly is a Monad. It is some sort of a meta-function, that I've figured.
06:11:43 <Cale> ok
06:11:48 <Cale> Let's go over it
06:12:10 <Walther> a monad can be something similar to map or fmap, but not quite
06:12:11 <Cale> Are you already familiar with type classes?
06:12:18 <Cale> I suppose you must be at least a little :)
06:12:21 <Walther> taken a peek at those, not familiar.
06:12:47 <Cale> A monad refers to a certain sort of type constructor, one which comes equipped with a suitable definition of return and (>>=)
06:13:01 <Walther> "A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes. A lot of people coming from OOP get confused by typeclasses because they think they are like classes in object oriented languages. Well, they're not. You can think of them kind of as Java interfaces, only better."
06:13:19 <Cale> okay
06:13:23 <Walther> :t (>>=)
06:13:23 <lambdabot> Monad m => m a -> (a -> m b) -> m b
06:13:35 <Cale> So, let's step back a moment and go over type classes a little
06:13:40 <exicer> I have a datatype, data QueryString = QueryString [ (Name, Parameter) ], that I want to be able to concatenate. What do I do?
06:13:44 <Cale> Consider the problem of writing a function to sort a list
06:13:48 <Walther> (also, huge thanks for being supportive again <3)
06:13:54 <Cale> What type should our sorting function have?
06:14:00 <ChongLi> :t (getLine)
06:14:01 <lambdabot> IO String
06:14:03 <ChongLi> :t (getLine >>=)
06:14:04 <lambdabot> (String -> IO b) -> IO b
06:14:08 <Cale> Knowing about type variables, we might hope that it could have type [a] -> [a]
06:14:15 <ChongLi> :t putStrLn
06:14:15 <lambdabot> String -> IO ()
06:14:21 <Cale> But there are various types a for which that doesn't quite work
06:14:24 <Walther> sort :: IO String -> IO String ?
06:14:32 <ChongLi> :t sortM
06:14:33 <lambdabot>     Not in scope: `sortM'
06:14:33 <lambdabot>     Perhaps you meant one of these:
06:14:33 <lambdabot>       `BSC.sort' (imported from Data.ByteString.Char8),
06:14:37 <Lethalman> so, I'd like to rewrite this program of mine in haskell for exercise: http://lethalman.hostei.com/rubik.html
06:14:37 <Cale> I'm just talking about plain ol' list sorting
06:14:40 <Cale> nothing about IO
06:14:41 <ChongLi> oh jeez
06:14:43 <Lethalman> I've used the clutter library
06:14:53 <Lethalman> it's a very simple 2d canvas library (with slight support for 3d)
06:14:54 <Cale> Actually, let's go to #haskell-overflow for this tutorial
06:15:05 <Cale> because there're a bunch of other discussions going on here
06:15:05 <Lethalman> what library would you recommend for me?
06:15:13 <Lethalman> I wouldn't use opengl directly
06:15:31 <ChongLi> Lethalman: gloss?
06:15:54 <ChongLi> @hackage gloss
06:15:54 <lambdabot> http://hackage.haskell.org/package/gloss
06:16:21 <Lethalman> let's see, thanks
06:16:47 <Lethalman> docs are broken :(
06:16:55 <ChongLi> Lethalman: click on an earlier version
06:16:59 <Lethalman> yes
06:17:15 <ChongLi> that broken docs thing is a real pain :(
06:17:44 <Lethalman> so, I would use Picture with Polygon constructor to create the small faces of the cube
06:17:52 <Lethalman> with Rotate + Translate
06:17:55 <Lethalman> seems nice
06:18:04 <ChongLi> yeah, it's very high-level
06:18:48 * hackagebot yesod-bin 1.2.5.6 - The yesod helper executable.  http://hackage.haskell.org/package/yesod-bin-1.2.5.6 (MichaelSnoyman)
06:18:50 * hackagebot yesod-routes 1.2.0.6 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.2.0.6 (MichaelSnoyman)
06:20:15 <vu3rdd> hello haskell hackers..
06:20:20 <ChongLi> hi
06:20:42 <vu3rdd> trying to play with bytestrings. Have to admit that I am a noob.
06:20:55 <vu3rdd> I have a question on bytestrings.
06:20:59 <ChongLi> okay
06:21:12 <vu3rdd> I have two bytestrings, I want to xor them.
06:21:43 <vu3rdd> let me paste the code somewhere.
06:21:47 <JuanDaugherty> that's not what haskell considers fun
06:22:00 <JuanDaugherty> that would be fun in c or machine lang
06:22:27 <JuanDaugherty> in haskell, lisp usw, tedious
06:22:57 <JuanDaugherty> but show be easy after you do the research
06:23:03 <JuanDaugherty> *should be
06:23:50 <vu3rdd> http://lpaste.net/98360
06:25:00 <vu3rdd> When I try to do B.zipWith xor pth1 ciphertext, I am getting some bytes in a list.
06:25:18 <vu3rdd> but if I do xor manually byte by byte, I think I am seeing a different result.
06:25:26 <vu3rdd> wondering what is happening here.
06:26:39 <ChongLi> vu3rdd: hmmm, well I do know that OverloadedStrings is not recommended for bytestrings
06:26:57 <merijn> ChongLi: It depends
06:27:26 <ChongLi> merijn: I was yelled at :)
06:27:45 <merijn> ChongLi, vu3rdd: OverloadedStrings for bytestrings assumes straight ascii and should *only* be used if you're writing ascii literals for a network/file protocol into your code
06:28:49 <merijn> If you're trying to convert String with unicode characters to ByteString using OverloadedStrings you'll get garbage
06:28:53 <vu3rdd> merijn: ChongLi: I mostly followed this page. I am very new to bytestrings https://www.fpcomplete.com/user/tekul/bytestring-bits-and-pieces
06:29:30 <ChongLi> merijn: but it won't destroy any data, right?
06:29:40 <ChongLi> so if you convert it later to Text
06:29:41 <merijn> ChongLi: Depends how you define destroy
06:29:50 <vu3rdd> if I xor 0x61 and 0x6c, I get 13
06:29:54 <merijn> ChongLi: The original String is immutable
06:30:10 <ChongLi> merijn: by destroy I mean mask the high bits
06:30:29 <ChongLi> which would change the meaning of the characters in the resulting Text
06:30:38 <vu3rdd> but if I do B.zipWith xor pth1 ciphertext, I see the first byte as 0.
06:30:43 <vu3rdd> Wondering why it is so.
06:31:01 <merijn> vu3rdd: I'm very displeased that tutorial mentions Data.ByteString.Char8 :\
06:31:17 <vu3rdd> merijn: hmm..
06:31:31 <mm_freak> vu3rdd: admittedly ByteString's zipWith is kind of stupid…  but you can always use Vector
06:31:37 <mm_freak> Vector Char or Vector Word8
06:32:09 <ChongLi> mm_freak: what is going on with ByteString's zipWith?
06:32:12 <mm_freak> in fact, when you use Vector Word8 from Data.Vector.Storable, then you pretty much get ByteString, except more efficient =)
06:32:18 <mm_freak> ChongLi: it results in a list
06:32:25 <merijn> vu3rdd: Char8 assumes ascii only, so (like I said) should only be used for converting ascii literals into ByteString for things like network protocols
06:32:26 <ChongLi> ahh
06:32:45 <mm_freak> in 99% of the cases when you want to zip two bytestrings, you want a bytestring back
06:32:56 <ChongLi> mm_freak: so weird, why is it written like that?
06:33:06 <mm_freak> dunno…  historical reasons i guess
06:33:08 <merijn> vu3rdd: If you want to have textual data you'll probably want to use Text and then encode that to ByteString
06:34:06 <merijn> vu3rdd: Data.Text.Encoding has functions to encode and decode Text to ByteString using utf-8, utf-16 and utf-32 (Text also has an OverloadedStrings instance)
06:34:32 <vu3rdd> merijn: thanks. I will play with it.
06:34:43 <ChongLi> merijn: well, in this case vu3rdd is xoring
06:34:48 <merijn> vu3rdd: Which is not really your initial question, but fairly important to realise :)
06:34:49 <mm_freak> i wonder what happened to vector-bytestring
06:34:50 <ChongLi> so that result shouldn't be textual
06:35:06 <klrr> using GHC api is it possible to import global variable bindings at runtime?
06:35:16 <mm_freak> i hope some day ByteString will be Vector Word8
06:35:42 <merijn> vu3rdd: Can you pastebin the output of manually xor'ing the text and the output of B.zipWith xor?
06:35:47 <ChongLi> merijn: what about using Data.Binary?
06:35:53 <vu3rdd> yes, one sec.
06:36:02 <exicer> I want to make "data QueryString = QueryString [ (Name, Parameter) ]" an instance of Functor, but I keep getting an error about kind mismatch. What is that  ?
06:36:20 <ChongLi> merijn: keep your text as Text and use Data.Binary to make your ByteString, xor that
06:36:22 <prophile> functors have a parameter
06:36:24 <prophile> that does not
06:36:29 <prophile> essentially
06:36:39 <ChongLi> of course, by "your" I mean vu3rdd's :)
06:36:43 <vu3rdd> merijn: http://lpaste.net/98362
06:36:50 <prophile> did you mean something like data QueryString a = QueryString [(Name, a)]?
06:37:05 <vu3rdd> mm_freak: I haven't looked at Vector yet. I will look at it. Thanks.
06:37:12 <merijn> vu3rdd: o!
06:37:13 <exicer> prophile: Ah, yes
06:37:40 <merijn> vu3rdd: The ByteString instance of String treats "6c" as [0x6, 0xc]" and xor's that
06:37:57 <merijn> vu3rdd: It's not xor'ing 0x6c and 0x61
06:38:08 <ChongLi> merijn: that's not good at all!
06:38:17 <merijn> vu3rdd: and "xor 6 6" is obviously 0
06:38:17 <mm_freak> vu3rdd: Vector is for generic arrays
06:39:00 <merijn> ChongLi: What else would it possibly do?
06:39:48 <ChongLi> merijn: no idea, but it just doesn't work for this purpose :)
06:40:07 <ChongLi> so does my idea make sense?
06:40:10 <vu3rdd> merijn: Ah. Is there a way to take 61 and 6c instead of the way it is doing currently?
06:40:22 <ChongLi> store the strings as Data.Text
06:40:26 <merijn> ChongLi: No
06:40:28 <FreeFull> merijn: xor is bitwise anyway though
06:40:30 <ChongLi> and then use Data.Binary to convert
06:40:35 <ChongLi> do the xor
06:40:43 <merijn> That doesn't work either, because he wants something completely different :)
06:41:09 <ChongLi> I thought he's whipping up a simple encryption tool with a one-time pad?
06:41:14 <vu3rdd> basically, "6" should be treated as a nibble rather than a byte.
06:41:33 <vu3rdd> ChongLi: yes.
06:42:00 <ChongLi> so why wouldn't Data.Text and Data.Binary work?
06:42:02 <merijn> vu3rdd: THe problem is that "map showHex" turns [Char] into [[Char]] and the concat then turns them into a [Char]
06:42:08 <merijn> Actually, yes it would
06:42:17 <henk> What exactly does cabal complain about in http://lpaste.net/98363 ? It says, I’m shadowing an existing binding, but I don’t understand what exactly it refers to. Probably because I don’t fully understand my own code yet. Could anyone point me to relevant docs or give me some keywords for a websearch?
06:42:58 <merijn> vu3rdd: The problem is that you're converting bytes to String representations of those bytes and than converting the String representation into actual bytes
06:43:04 <ChongLi> and you could actually just generalize your encryption function to work on any data that has an instance of Binary
06:43:25 <ChongLi> brb
06:43:49 <merijn> henk: "shadowing an existing binding" means "you're using a name that already exists (thus hiding that original value)"
06:44:14 <vu3rdd> merijn: I was very confused how to go about it. And then I saw that fpcomplete post, so I got hooked into it.
06:44:20 <merijn> henk: i.e. it's warning you that the 'start' variable on line 16 is hiding the 'start' field selector from line 9
06:44:29 <vu3rdd> I will look at Data.Text and Data.Binary
06:45:41 <merijn> henk: It's not an actual bug/problem, just a warning so you can check that's actually what you wanted
06:48:52 * hackagebot persistent 1.3.0.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.3.0.2 (MichaelSnoyman)
07:01:16 <martinga_> anyone know why pqueue was not adding to the haskell platform
07:02:35 <geekosaur> nobody argued for it?
07:02:45 <klrr> if you load a function at runtime using http://hackage.haskell.org/package/hotswap-0.1.9.13/docs/System-Plugins-Hotswap.html how would i pass arguments to it?
07:03:05 <martinga_> geekosaur:  so is it dead or still being considered?
07:04:05 <henk> merijn: Yes, I added -Wall to the compiler options hoping to get some more advice how to make my code better. I understand what the message means, but I’m not sure how to handle the message. Is there any cleaner, less confusing, more straightforward way of writing it?
07:04:08 <geekosaur> neither. I don't recall it ever being mentioned, so it's still open for consideration. make a formal proposal to the libraries list.
07:04:34 <ChongLi> pqueue was last uploaded 8 Dec 2012
07:04:43 <ChongLi> and the source repository is a 404
07:05:06 <martinga_> yeah i noticed the 404
07:05:12 <geekosaur> hm, that would not help. but there's a couple other priority queues in hackage...
07:06:09 <martinga_> I need something in the platform, I'm adding palette creatiion to Juicy pixels and we only want to use things in the platform
07:07:11 <ChongLi> martinga_: game devs eh?
07:07:28 <martinga_> ChongLi:  GIFs
07:07:35 <ChongLi> ahh
07:08:04 <martinga_> I don't need the pq its a samll but noticeable performance boost
07:08:23 <ChongLi> how does Juicy Pixels compare to repa-devIL?
07:09:01 <ChongLi> perf-wise
07:09:06 <martinga_> I'm not really sure, I mostly work on diagrams, but i'm helping with juicy so we can make animated gifs with diagrams
07:09:06 <mangaba_leitosa> is there an equivalent of Data.Ord.comparing for sorting by more than one property? That is if 'comparing f' results in EQ, do 'comparing g', and failing that, 'comparing h'?
07:09:27 <ChongLi> martinga_: ahhh
07:09:39 <ChongLi> cause repa is in general very fast
07:09:44 <ChongLi> due to parallelism
07:10:43 <geekosaur> martinga_, then you need to pick a priority queue package that isn't a 404 and make a formal proposal to the libraries@haskell.org list. stuff doesn't just magically show up in the platform
07:11:07 <merijn> henk: Well, you can either explicitly disable that warning *OR* rename the variable so it doesn't have the same name as the field
07:11:18 <martinga_> What's the ettiquete on including some other package source in your pacakage = i.e. copying it instead of a dependency, I assume this is bad form?
07:11:21 <ChongLi> martinga_: why are you averse to using non-platform packages? developing on windows?
07:11:50 <martinga_> Vincent (author of juicy pixels) hopes for inclusion into the platform in the future
07:12:00 <martinga_> I'm fine with it
07:12:13 <ChongLi> ahh, okay
07:15:13 <Clint> mangaba_leitosa: Ordering is a Monoid, so you could do something like sortBy (comparing f <> comparing g)
07:15:48 <mangaba_leitosa> Clint: thanks, will try that!
07:16:38 <henk> merijn: ok, thank you very much. I "solved" it by not using record syntax for that constructor. Don’t know what I gain from that ATM anyway …
07:17:02 <ChongLi> > sortBy (comparing (sn
07:17:03 <lambdabot>  <hint>:1:22:
07:17:03 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
07:17:06 <ChongLi> gah
07:17:32 <ChongLi> > sortBy (comparing (snd &&& fst)) [(1,2),(412,12),(56,100)]
07:17:33 <lambdabot>  [(1,2),(412,12),(56,100)]
07:17:40 <ChongLi> > sortBy (comparing (snd &&& fst)) [(2000,2),(412,12),(56,100)]
07:17:41 <lambdabot>  [(2000,2),(412,12),(56,100)]
07:17:49 <ChongLi> > sortBy (comparing (fst &&& snd)) [(2000,2),(412,12),(56,100)]
07:17:50 <lambdabot>  [(56,100),(412,12),(2000,2)]
07:19:36 <Peaker> > sortBy (comparing fst <> comparing snd) [(2000,2),(412,12),(56,100)]
07:19:37 <lambdabot>  [(56,100),(412,12),(2000,2)]
07:20:01 <mangaba_leitosa> cool
07:21:25 <ChongLi> my method will stop working after 15ary tuples :)
07:21:49 <ChongLi> since Ord is only defined up to those
07:22:54 <exicer> What does it mean for a data definition to have an ! in it ?
07:22:57 <mangaba_leitosa> Clint: but 'fst' is only defined for binary tuple anyway?
07:24:59 <Clint> mangaba_leitosa: i never said anything about fst
07:25:12 <mangaba_leitosa> oops, I meant ChongLi :-)
07:25:31 <ChongLi> mangaba_leitosa: fst could be any function to get an element from a data type
07:25:40 <ChongLi> such as a field accessor
07:25:44 <mangaba_leitosa> but now I got it... &&& creates a tuple, right?
07:25:55 <ChongLi> :t (&&&)
07:25:55 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:26:05 <ChongLi> it's a bit confusing
07:26:20 <ChongLi> but (foo &&& bar) creates a function that returns a tuple of the results
07:26:27 <mangaba_leitosa> I see :-)
07:26:42 <ChongLi> > (head &&& last) [1..10]
07:26:43 <lambdabot>  (1,10)
07:27:08 <ChongLi> > (head &&& tail &&& init &&& last) [1..10]
07:27:09 <lambdabot>  (1,([2,3,4,5,6,7,8,9,10],([1,2,3,4,5,6,7,8,9],10)))
07:27:16 <mangaba_leitosa> so basically we are creating a tuple of all properties and compare them all at once
07:27:21 <ChongLi> yeah
07:27:56 <ChongLi> but the tuple's structure is determiend by the ordering of the functions supplied to &&&
07:28:13 <quchen> exicer: It makes the data constructors strict. When you write "data Foo a = Foo a", you get a function "Foo :: a -> Foo a" for free. An exclamation mark à la "data Foo a = Foo !a" makes this function strict in its argument as if you invoked Foo with an additional `seq` on the data.
07:28:16 <ChongLi> > (last &&& head) [1..10]
07:28:17 <mangaba_leitosa> yes, I got it. thanks
07:28:18 <lambdabot>  (10,1)
07:28:24 <lingxiao> hey all
07:28:42 <lingxiao> could somone explain the "Preservation of types under substitution" lemma for simply typed pure lambda calculus to me?
07:29:07 <lingxiao> I'm working through the cases and but mine proof just do not correspond to the book proof at all
07:29:14 <mangaba_leitosa> > (last &&& head &&& (!! 5)) [1..10]
07:29:15 <lambdabot>  (10,(1,6))
07:29:45 <ChongLi> mangaba_leitosa: oh, right
07:29:47 <lingxiao> the lemma states" If Γ , x:S ⊢ t : T and Γ ⊢s:S, then Γ ⊢ [x +-> s]t:T. "
07:29:55 <ChongLi> &&& bypasses the arity issues with Ord
07:30:00 <ChongLi> since the tuples are nested
07:30:05 <ChongLi> it's always 2-ary
07:30:52 <mangaba_leitosa> ChongLi: :-)
07:37:37 <Twey> lingxiao: It says that the type of a term will never change by replacing a subterm with a different subterm of a different type
07:37:46 <Twey> Er, of the same type**
07:39:26 <Twey> lingxiao: Literally, if t has type T under an environment in which x has type S, and s also has type S, then the result of replacing x with s in t still has type T
07:41:35 <Lethalman> are there classy functions for tuples anywhere?
07:41:47 <Lethalman> like fst that applies to (x,y) but also (x,y,z) ?
07:42:22 <Twey> Lethalman: There's a package called ‘tuple’ that has them, IIRC
07:42:58 <Twey> But you can also use recursive tuples indexed by a list, like HList, and get them for free
07:43:02 <Cale> There's lens
07:43:05 <Cale> :)
07:43:08 <Lethalman> huh?
07:43:26 <Cale> > view _1 (1,2,3)
07:43:30 <lambdabot>  1
07:43:31 <ChongLi> lens can do wondrous things with tuples
07:43:33 <Cale> > view _1 (1,2,3,4)
07:43:34 <lambdabot>  1
07:43:43 <Cale> > view _3 (1,2,3,4)
07:43:45 <lambdabot>  3
07:43:48 <Cale> > view _3 (1,2)
07:43:49 <lambdabot>  Could not deduce (Control.Lens.Tuple.Field3
07:43:49 <lambdabot>                      (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
07:43:49 <lambdabot>                      (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
07:43:49 <lambdabot>                      b
07:43:49 <lambdabot>                      b)
07:43:50 <Twey> Lens has up to _9
07:44:01 <Lethalman> mh that's fine, I only need for 2 and 3
07:44:17 <Cale> Honestly, if you're using anything too much larger than pairs, you have to start wondering what you're doing. :)
07:44:25 <Lethalman> I thought there was an hackage replacing fst and snd though :(
07:44:32 <hakujin> ^ agree with Cale
07:44:32 <Twey> Indeed
07:44:37 <Cale> Well, Twey gave that
07:44:37 <Lethalman> Cale, newtype Row = (Color, Color, Color)
07:44:46 <Lethalman> Row = Row (Color, Color, Color)
07:44:53 <Lethalman> is it that bad?
07:44:58 <Twey> Lethalman: Better with accessors
07:45:03 <Cale> http://hackage.haskell.org/package/tuple-0.2.0.1/docs/Data-Tuple-Select.html
07:45:06 <Lethalman> Twey, how should i call them
07:45:33 <Cale> Lethalman: Why not  data Row = Row Color Color Color
07:45:37 <Twey> Lethalman: I'd probably newtype Row = Row { _red, _green, _blue ∷ Color }
07:45:48 <Lethalman> no they don't have name
07:45:51 <Twey> Oh
07:45:54 <Twey> Sorry, not like that
07:45:54 <Lethalman> Cale, and how do I access the third color
07:46:01 <Cale> pattern matching
07:46:04 <Lethalman> too long
07:46:11 <Cale> Well, you can write:
07:46:11 <Lethalman> I have a trd3 (_,_,x) = x
07:46:33 <Cale> c1 (Row v _ _) = v
07:46:36 <Twey> Vec is nice here
07:46:38 <Cale> c2 (Row _ v _) = v
07:46:43 <Cale> c3 (Row _ _ v) = v
07:46:53 <Twey> newtype Row = Row (Vec 3 Color)
07:47:04 <Cale> Or of course, you can use record syntax to define those:
07:47:06 <Lethalman> Cale, alright, then I can't use c1 for the same
07:47:17 <Cale> data Row = Row { c1, c2, c3 :: Color }
07:47:30 <Lethalman> let me explain better
07:47:50 <Lethalman> well yes need a name for every of them
07:47:52 <Lethalman> mh
07:48:05 <Twey> Lethalman: If you use Vec you don't have to name them
07:48:21 <Cale> Vec is fancy though :)
07:48:28 <Lethalman> Vec has type level nat?
07:48:31 <Cale> yeah
07:48:33 <Lethalman> cool
07:48:35 <Twey> But a three-tuple doesn't really save you names, it just predefines two of them for you, and you still need something to remove the outer Row constructor :þ
07:48:51 <lingxiao> Twey: yeah see that's intuitively true, but I guess I just got caught up in the mechanical aspect of the proof
07:48:51 <Lethalman> I can try the c1, c2, c3 thing
07:49:25 <lingxiao> for example, if x : S, and s : S, and t = x
07:49:50 <lingxiao> then t : T, and t : S, with S = T
07:49:54 <Lethalman> the fact is that with a tuple I can define a map3
07:49:58 <Twey> lingxiao: Yep
07:50:10 <lingxiao> that's the part that tripped me up the most, since I thought T /= S
07:50:11 <Lethalman> while for different types I need a map for every type
07:50:26 <Twey> Lethalman: You can map over a Vec
07:50:27 <lingxiao> but instead T is some variable over types? though it's represented by a capitalized english letter like S
07:50:29 * Cale tries to figure out if lingxiao is figuring out ordinary unification or path induction.
07:50:34 <Lethalman> Twey,
07:50:35 <Twey> And you don't even have to define it ☺
07:50:42 <Lethalman> right, unless I define a Triple a functor
07:51:08 <Twey> lingxiao: They're both variables over types
07:51:11 <Lethalman> but Vec seems nice
07:51:14 <Cale> Lethalman: Well, the Functor instance will map over the last component only
07:51:27 <Cale> instance Functor ((,,) a b) where
07:51:34 <Lethalman> Cale, not if Triple a
07:51:34 <Cale>   fmap f (x,y,z) = (x,y,f z)
07:51:41 <Lethalman> never said (,,) :)
07:51:43 <Cale> yeah, if you define a newtype
07:51:45 <Twey> Lethalman: Triple is not a Functor in the way you're thinking of, since a Functor is only allowed to mess with the type of its (single) parameter
07:51:53 <Cale> or a new data declaration altogether
07:51:54 <lingxiao> Twey: oohh, ok thanks
07:51:56 <Lethalman> Twey, Triple a
07:52:13 <Twey> Lethalman: That's not really a triple any more
07:52:17 <Lethalman> newtype Triple a = Triple (a,a,a)
07:52:17 <Cale> yeah, if you define data Triple a = T a a a
07:52:26 <Twey> Though it is a Functor
07:52:36 <Lethalman> whatever, it's triple in my universe :P
07:52:40 <Cale> then you can write  instance Functor Triple where fmap f (T x y z) = T (f x) (f y) (f z)
07:52:41 <Lethalman> anyway, let's give Vec a shot
07:52:43 <Twey> But at that point you might as well define your own type with a semantic name
07:52:52 <Lethalman> type Triple a = Vec 3 a
07:52:55 <Lethalman> might do it :)
07:53:04 <Lethalman> thanks for the hint
07:53:08 <Cale> I'm with Lethalman on that, it's still worthy of being called a triple of some sort :)
07:53:08 <Twey> Lethalman: But there's no point in defining that, because that's what Vec 3 means anyway
07:53:24 <Twey> Lethalman: Also, you save a character :þ
07:53:29 <Lethalman> ah one thing
07:53:35 <Lethalman> is it possible to parametrize that 3?
07:53:39 <Cale> yes
07:53:40 <Twey> Lethalman: Yes
07:53:52 <Lethalman> so I could change my whole model at the type level? :O
07:53:53 <Cale> (that's the fancy bit)
07:53:56 <Twey> Yes
07:54:04 <Twey> Though it will take a bit of type-hackery if you want to make it fully generic
07:54:09 <Lethalman> well.... awesome, let me read the docs :) thanks
07:54:42 <Twey> Cale: IMO it's a defining feature of tuples that they're heterogeneous
07:54:52 <Cale> Lethalman: complicated operations on Vecs might need to do arithmetic at the type level
07:55:14 <Cale> Lethalman: and depending on how much arithmetic, you might end up with problems :)
07:55:16 <Lethalman> I might need a rotation
07:55:34 <Twey> If they're not, they're not significantly different from lists in mathematics, or Vec in these here dark backwoods ;)
07:55:37 <Lethalman> like (a,b,c) (d,e,f) into (b,c,d) (e,f,a)
07:56:12 <Cale> Twey: Well, I'd still call the elements of A^3 "triples" in mathematics
07:56:16 <Twey> Lethalman: I'd probably just define that for 3
07:56:25 <Lethalman> Twey, why?
07:56:29 <Twey> Cale: Sure, but they're only triples because they *could* have been heterogeneous
07:56:37 <Lethalman> Twey, I don't need (b,c,a), that's different
07:56:37 <Cale> Twey: So long as they're elements of *some* Cartesian product, they're tuples. In type theory, we even generalise that a bit more
07:56:38 <Twey> (Int, Int) is still a pair
07:57:16 <Twey> Lethalman: Because otherwise you'll have to prove to GHC that the length stays the same, which could be a pain
07:57:27 <Lethalman> Twey, it would be an append+drop
07:57:28 <Twey> I don't know, feel free to make it generic if you want to
07:57:29 <Cale> You start calling elements of type exists (x : A), P(x) "pairs" and stuff :)
07:57:37 <Lethalman> at least for 3
07:57:51 <Lethalman> I'm certainly going for 3 only now :)
07:58:23 <Twey> Cale: Because a dependent pair is a superset of pairs, but a heterogeneous pair is a limited subset
07:58:34 <Twey> But I guess that's maybe backwards from the mathematician's instinct
07:58:35 <Cale> sure, but (1,2) is a pair
07:58:46 <Cale> regardless of which type we view it as belonging to?
07:59:06 <Twey> Cale: So your definition of ‘pair’ is purely syntactic?
07:59:16 <Cale> Almost
07:59:31 <Twey> ‘It's got brackets and a comma, therefore it's a pair’ :þ
07:59:36 <Cale> I mean, I'll call the elements of any product type whatsoever tuples
08:00:00 <Cale> If there's a way to see the type as a product of some other types, and I want to emphasise that view
08:00:22 <Cale> (as a categorical product, or something close enough to it)
08:00:52 <Cale> Pretty much every object in Set is a product if you define the projections appropriately.
08:01:07 <Cale> So you can always look at the elements of any set as tuples if you think about them the right way :)
08:01:16 <Twey> I don't think I like that.  It's okay so long as the multiplicands are parameterized by a type.
08:01:47 <Twey> But data Foo = Foo a a a isn't even isomorphic to data Foo a b c = Foo a b c
08:02:03 <prophile> data Foo = Foo a a a doesn't even make sense
08:02:30 <Twey> prophile: Thank you, I knew someone would point that out ;)  Feel free to insert an ‘a’ or change the capitalization
08:03:04 <Cale> When you use the term "triple" or "pair" you're emphasising the fact that there exists some projections in the context which express the sense in which the type of the values in question is a categorical product.
08:03:23 <Cale> For something like data Foo a = F a a a
08:03:37 <Cale> those projections are p1 (F x y z) = x, etc.
08:04:25 <m1dnight> guys, quick question, 'elem = y ys = foldl (\acc x -> if x == y then True else acc) False ys', will this evaluate the entire solution ? (i think so yeS.. because of the IF, instead of an OR)
08:04:29 <Cale> (or more generally, you can take that to be a Sigma type, I guess)
08:05:12 <Cale> m1dnight: That doesn't quite parse, I think there's an extra = sign?
08:05:23 <Cale> foldl always goes through the entire list it's given
08:05:38 <Cale> and only stops to produce a result once it reaches the end
08:05:41 <Cale> @src foldl
08:05:41 <lambdabot> foldl f z []     = z
08:05:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:05:50 <m1dnight> oh yeah, my bad (typed it over from course)
08:05:52 <Cale> ^^ you can see that it just greedily applies itself to new parameters
08:05:59 <Cale> @src foldl
08:05:59 <lambdabot> foldl f z []     = z
08:06:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:06:02 <Cale> oops
08:06:03 <Cale> @src foldr
08:06:03 <lambdabot> foldr f z []     = z
08:06:03 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:06:17 <Cale> You can see that foldr by contrast gives control to f
08:06:23 <m1dnight> oh okay :) but if I were to use an OR, wouldn't it return true from the point it sees a True value?
08:06:27 <Cale> (remember, lazy evaluation is outermost-first)
08:06:52 <Cale> if/then/else is exactly as lazy as using (||)
08:06:57 <m1dnight> oh okay
08:07:03 <m1dnight> well, thanks! :)
08:07:06 <m1dnight> i was just wondering baout that
08:07:18 <Cale> But any time that you have an if/then/else where one of the branches is boolean, you should consider rewriting it
08:07:35 <Cale> (there's always some more concise way)
08:08:43 <Cale> > foldl (\b x -> x == 0 || b) False [0..]
08:08:48 <lambdabot>  mueval: ExitFailure 1
08:08:48 <lambdabot>  mueval: Prelude.undefined
08:08:48 <Cale> ^^ takes forever
08:08:57 <Cale> > foldr (\x b -> x == 0 || b) False [0..]
08:08:58 <lambdabot>  True
08:09:03 <Cale> ^^ finishes immediately
08:11:21 <FreeFull> Bool has a Num instance?
08:11:26 <FreeFull> > 0 :: Bool
08:11:27 <lambdabot>  No instance for (GHC.Num.Num GHC.Types.Bool)
08:11:27 <lambdabot>    arising from the literal `0'
08:11:27 <lambdabot>  Possible fix:
08:11:27 <lambdabot>    add an instance declaration for (GHC.Num.Num GHC.Types.Bool)
08:11:27 <Cale> nope
08:11:39 <FreeFull> :t (||)
08:11:40 <lambdabot> Bool -> Bool -> Bool
08:11:45 <prophile> no, but it could easily be made to have a num instance
08:11:50 <FreeFull> Oh, nevermind
08:11:51 <Cale> That expression is (x == 0) || b
08:11:55 <FreeFull> Didn't notice the ==
08:12:05 <FreeFull> Tiredness
08:19:11 * hackagebot AC-Colour 1.1.5 - Efficient RGB colour types.  http://hackage.haskell.org/package/AC-Colour-1.1.5 (AndrewCoppin)
08:21:06 <m1dnight> @src scanl
08:21:06 <lambdabot> scanl f q ls = q : case ls of
08:21:06 <lambdabot>     []   -> []
08:21:06 <lambdabot>     x:xs -> scanl f (f q x) xs
08:25:02 <Mathnerd314> why do (id,id) and (\x -> (x,x)) id have different types?
08:26:24 <Hafydd> Mathnerd314: (id,id) is not a function, for example.
08:26:40 <ChongLi> :t (id &&& id)
08:26:41 <lambdabot> a -> (a, a)
08:26:46 <ChongLi> is what you want
08:26:52 <Mathnerd314> :t (id,id)
08:26:53 <lambdabot> (a -> a, a1 -> a1)
08:27:01 <simukis_> Hafydd: It is if you have -XTupleSections enabled.
08:27:02 <Mathnerd314> :t (\x -> (x,x)) id
08:27:02 <ion> id = \x -> x
08:27:03 <lambdabot> (a -> a, a -> a)
08:27:08 <ion> (id,id) = (\x -> x, \x -> x)
08:27:19 <simukis_> oh wait.
08:27:29 <simukis_> I retract it :(
08:27:34 <ion> Oh, sorry. I missed the last “id” in your question.
08:28:03 <ion> @type let x = id in (x,x)
08:28:03 <lambdabot> (a -> a, a1 -> a1)
08:29:37 <ion> (\x -> (x,x)) :: x -> (x,x). Note how each x in the type is the same.
08:30:05 <ion> If you let x = a -> a in the type, (x,x) will be (a -> a, a -> a)
08:30:58 <Mathnerd314> :t (\(x :: forall a. a -> a) -> (x, x)) id
08:30:59 <lambdabot> (a -> a, a1 -> a1)
08:32:15 <Twey> Functions are not as polymorphic as they can be by default, unfortunately.  Haskell values have a ‘principle type’, the construction of which does not take RankNTypes into consideration.
08:35:57 <Cale> Well, it's not that unfortunate. There are in general many incompatible rank n types which a given term might have.
08:37:18 <ion> Inferring an arbitrary rank-n type for everything by default would probably result in pain.
08:37:50 <Twey> Like a non-terminating type-checker.  :þ  Still, it would be hypothetically nice to have.
08:39:14 * hackagebot AC-Colour 1.1.6 - Efficient RGB colour types.  http://hackage.haskell.org/package/AC-Colour-1.1.6 (AndrewCoppin)
08:39:41 <ion> I mean, i think it’s good that (\x -> (x,x) :: x -> (x,x) by default, not (forall a. a -> a) -> (b -> b, c -> c). The latter would prevent e.g. a `asTypeIn` f = a where { _ = f a } from DTRT.
08:41:28 <Twey> Hm, true that
08:43:48 <joneshf-laptop> i feel like the last one to the party, fpcomplete lets you publish blogs just for being a user?
08:44:15 * hackagebot shelly 1.4.0.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-1.4.0.2 (GregWeber)
08:44:17 * hackagebot hasktags 0.68.3 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.68.3 (MarcWeber)
08:46:51 <Mathnerd314> ion: I think it's just a rank-2 type, which has decidable inference
08:47:27 <Cale> joneshf-laptop: Wow! We can write content for them for free?! :D
08:47:42 <danharaj> Cale++
08:48:23 <Cale> Or is it $9.99/mo to write content for them?
08:48:29 <Cale> :)
08:51:05 <joneshf-laptop> heh
08:51:24 <joneshf-laptop> i'm less concerned with where it's stored and more with just having a medium for it
09:01:12 <Walther> Hmmm. Is there a nice way to have a line in main that essentially does something until a condition is met, and keeps a counter for each repetition?
09:01:46 <johnw> Walther: you can use whileM from monad-loops, and StateT to maintain the counter...
09:05:51 <luca> should this snippet work as expected executing one line after an other? http://lpaste.net/98367
09:06:12 <luca> is there something I'm missing maybe regarding the use of "do" statement?
09:06:52 <Tekmo> luca: It depends on which monad you are using
09:07:06 <Tekmo> luca: I'm assuming the IO monad?
09:07:31 <Tekmo> So the general answer to your question is that it depends on how `(>>=)` is defined
09:07:41 <Tekmo> luca: It's totally possible to define a monad that executes things backwards
09:08:26 <zipper> I have take and repeat functions. repeat creates an infinite list while take takes an int and returns the first int x numbers from that list as a list.
09:08:47 <zipper> However when I call take with an infinite list it also works.
09:09:48 <zipper> If recursion works right it should keep waiting for the function that creates an infinite list to return a list but that doesn't happen
09:10:00 <zipper> Could someone please explain this to me.
09:10:03 <snizzo_> Tekmo: mm I don't actually know, things should be executing right. If I do like this: http://lpaste.net/98369 it works. The problem seems http://lpaste.net/98367 breaks execution of addVar
09:10:07 <zipper> https://gist.github.com/urbanslug/8387367
09:10:16 <snizzo_> Tekmo: I'm a luca's teammate :)
09:10:52 <snizzo_> Tekmo: mmm it seems you were right
09:11:00 <snizzo_> do executes things backward
09:11:04 <snizzo_> thank you for your help :)
09:11:30 <quchen> zipper: Laziness! `repeat x` is only evaluated as much as needed. When `take 10` demands 10 elements, only those are ever created.
09:11:52 <Tekmo> snizzo_: You're welcome!
09:12:15 <Tekmo> zipper: Laziness means that the recursive function is only evaluated as much as necessary
09:12:41 <Tekmo> zipper: In fact, this is how `replicate` is defined
09:12:48 <Tekmo> zipper: replicate n x = take n (repeat x)
09:13:11 <Twey> > repeat 'x'
09:13:12 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
09:14:02 <FreeFull> repeat x = let xs = x:xs in xs
09:14:06 <augur_> is there a notion of finitely representable real number?
09:14:30 <augur_> like, pi is finitely representable because there's an algorithm for computing it to arbitrary precision
09:15:01 <Twey> augur_: ‘Computable’, I guess?
09:15:01 <hpc> augur_: there is, but hell if i can remember what it's called
09:15:02 <roconnor> augur_: yes
09:15:35 <roconnor> augur_: there probably are a few variations
09:16:51 <FreeFull> augur_: That's probably equivalent to computable
09:16:58 <augur_> following on that, is bisimulation always decidable?
09:17:46 <Walther> Almost done with my Dawkins' weasel, just a bit of a problem with the main function http://lpaste.net/3435573713351737344
09:17:59 <roconnor> augur_: bisimulation is almost never decidable.
09:18:04 <augur_> oh :(
09:19:43 <Walther> I don't really want a straight-out solution, but some tips on how to get about implementing those two rows in the main
09:21:48 <roconnor> @hoogle untilM
09:21:48 <lambdabot> No results found
09:22:08 <roconnor> @type until
09:22:09 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
09:22:42 <Tekmo> Walther: A good starting point would be to study how `until` is written and generalize it to use effects
09:22:45 <Tekmo> @src until
09:22:46 <lambdabot> until p f x | p x       = x
09:22:46 <lambdabot>             | otherwise = until p f (f x)
09:23:37 <augur_> roconnor: thats an interesting fact, because it means that equality of reals isnt reducible to the fact that reals are infinite
09:23:42 <Walther> Tekmo: I am probably going to need something like untilM_ anyway; that comment is mostly pseudocode
09:23:51 <augur_> since some are finitely presentable, and that doesnt suffice to guarantee checking equality
09:24:12 <Walther> the core problem however is mostly in the incorporation of the counter in order to prettyprint correctly
09:24:25 <augur_> i guess in some sense bisimulation is an equality on infinite things tho, so hm
09:24:36 <roconnor> augur_: one big problem with finitely representable is that all finitely representable numbers have multible equivalent representations
09:24:49 <augur_> true
09:25:02 <roconnor> augur_: so the finiteness doesn't buy you very much.
09:25:26 <augur_> ok im heading out for a bit. see ya
09:25:44 <zipper> quchen: Well when the recursive function starts to evaluate how does it know how much is enough?
09:26:05 <zipper> Tekmo: but I don't see how it will know how much is necessary
09:26:07 <fabe> hi could someone help me with this? line 9 fails http://lpaste.net/98370
09:26:14 <fabe> how do i change it correctly?
09:26:33 <quchen> zipper: Try evaluating `take 3 (repeat 1)` by hand!
09:27:21 <Tekmo> Walther: So you could implement this pretty straightforwardly using `pipes`
09:27:23 <zipper> quchen: When I start on  repeat 1 part I see no end to that list to be honest
09:27:48 <zipper> Because repeat 1 should return AFTER it is done running
09:27:50 <zipper> no?
09:28:06 <Tekmo> Walther: The idea is that you convert your evolution function to a `Producer` (sort of like an effectful list) like this:
09:28:10 <quchen> zipper: You have to evaluate this from the outside: `take` comes first!
09:28:20 <joneshf-laptop> zipper, you're evaluating backwards
09:28:36 <Tekmo> Walther: Wait, one second while I study `RVar` because I haven't used that library in a while
09:28:57 <quchen> take 3 (repeat 1)  -- take needs a list to take from, so it has to evaluate `repeat 1` until it can take something
09:29:04 <quchen> = take 3 (1 : repeat 1)
09:29:04 <joneshf-laptop> @src take
09:29:04 <lambdabot> take n _      | n <= 0 =  []
09:29:04 <lambdabot> take _ []              =  []
09:29:04 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
09:29:12 <zipper> take takes two params in which one of the params is a function that needs to return so that take can run, no?
09:29:16 <Tekmo> Walther: Yeah, okay, so I see the issue you have
09:29:25 <Tekmo> Walther: So before I discuss `pipes`, let me first discuss `RVar`
09:29:49 <Tekmo> Walther: Your `RVar` type as is does not let you do `IO` in between `RVar` computation steps
09:29:51 <joneshf-laptop> zipper, no
09:29:53 <joneshf-laptop> :t take
09:29:54 <lambdabot> Int -> [a] -> [a]
09:29:59 <Tekmo> Walther: The way you fix that is to generalize it to `RVarT IO`
09:30:13 <Tekmo> Walther: Then you will be able to interleave `IO` with random number computations like `evolve`
09:30:41 <Walther> Tekmo: That shouldn't be an issue here. I have the helper function "run" there exactly for that reason
09:31:03 <zipper> joneshf-laptop: In this case the second list is returned by a function.
09:31:17 <joneshf-laptop> zipper, that's irrelavent to the type of take
09:31:18 <zipper> I will read on lazy evaluation and get back to you
09:31:29 <zipper> joneshf-laptop: Ok go on
09:31:39 <frxx> zipper nothing is evaluated until it is needed.
09:31:42 <Tekmo> Walther: That's a little bit wonky because you are excessively using your entropy source
09:32:25 <Walther> Tekmo: I don't mind excessively using the entropy source, this is just a tiny genetics simulation that I'm writing mainly to learn Haskell :)
09:32:29 <Tekmo> Walther: But anyway, let's say you use that and convert all your `RVar` computations to `Io`
09:32:40 <Tekmo> Walther: So if you convert `evolve` to `IO`, you get:
09:32:50 <joneshf-laptop> zipper, i didn't have much else to say ;)
09:32:53 <Tekmo> Walther: run . evolve :: String -> IO String
09:33:05 <zipper> frxx: So it won't get the fourth element of the list unless it has tried executing the function and realised that it can't do without it?
09:33:19 <Walther> I want to convert them to IO in the main though, not touch the original helper functions much
09:33:20 <joneshf-laptop> zipper, but it really helps to write it out as someone said,
09:33:32 <zipper> joneshf-laptop: https://gist.github.com/urbanslug/8387367
09:33:35 <quchen> <quchen> zipper: Try evaluating `take 3 (repeat 1)` by hand!
09:33:42 <zipper> I already did thise
09:34:21 <zipper> quchen: When I do it by hand I never actually run take because I get fixated on the repeat.
09:34:23 <Tekmo> Walther: Give me a second to complete your code using the `pipes`-based solution.  I think it will be simpler to explain if you have something to look at
09:34:37 <snizzo_> anyone knows bnfc? I'm using it with haskell
09:34:43 <Walther> Tekmo: beep, I would much prefer not to get a spoon-fed solution
09:34:57 <Tekmo> Walther: Alright, so this solution has basically three parts
09:35:05 <quchen> zipper: You're starting evaluation on the innermost function (repeat), but in Haskell you start evaluating on the outside. In other words, you have to insert `take`s definition first.
09:35:08 <Tekmo> Walther: First you create a `Producer` that is a stream of evolved strings
09:35:26 <Tekmo> Walther: i.e. "evolved :: String -> Producer String IO ()"
09:36:30 <Twey> @src take
09:36:30 <lambdabot> take n _      | n <= 0 =  []
09:36:30 <lambdabot> take _ []              =  []
09:36:30 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
09:36:48 <Tekmo> Walther: The next step is to filter that through a `Pipe` that takes elements until one matches the target
09:36:52 <quchen> zipper: So it goes something like this: `take 3 (something)` evaluates to "<first element of (something)> : take 2 <something with first element removed>"
09:36:54 <Tekmo> Walther: You can use the `takeWhile` pipe for this purpose
09:36:59 <zipper> quchen: Oh I thought take runs only after it has all the params
09:37:08 <Tekmo> Walther: takeWhile :: (Monad m) => (a -> Bool) -> Pipe a a m ()
09:37:18 <quchen> zipper: No, that would be how a strict language works.
09:37:20 <Tekmo> Walther: The last step is to just print all elements using your pretty print function
09:37:22 <zipper> quchen: Go on please
09:37:33 <Tekmo> Walther: That would be a `Consumer` of type
09:37:41 <zipper> quchen: Well I have only programmed in strict languages it seems
09:37:43 <Tekmo> Walther: prettyPrint :: Consumer String IO r
09:37:51 <Tekmo> Walther: Once you define all three of those, you connect them like this:
09:37:57 <Walther> Tekmo: Looks like you didn't read the evolve function properly
09:38:09 <quchen> zipper:  take 3 (repeat 1) = take 3 (1 : repeat 1) = 1 : take 2 (repeat 1) = … (your turn)
09:38:12 <Walther> I don't need to store the individual childs apart from printing; see "offspring"
09:39:01 <Tekmo> Walther: I never said you would
09:39:12 <aleksejs_> Hi, who could help me with my code? http://vpaste.net/vQx2T it always returns empty array, can't figure why
09:39:16 <Tekmo> Walther: The output of the `Producer` is the fittest `String` from each generation, not every `String`
09:39:21 * hackagebot flamethrower 0.0.1.0 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.1.0 (charmander)
09:39:30 <Tekmo> Walther: It represents the result of repeatedly applying `evolve` over and over again
09:39:31 <sm> now you're talking
09:39:58 <zipper> quchen: Give me a second to do that on paper and get back to you
09:40:11 <quchen> Sure :-)
09:40:13 <Tekmo> Walther: It would help to clarify if I just showed you the code
09:40:37 <quchen> zipper: The crucial thing is that "repeat" gets looked at only when "take" has to decide whether repeat is empty or has elements left.
09:40:44 <Tekmo> Walther: evolver str = do { str' <- lift (evolve str); yield str'; evolver str' }
09:41:46 <aleksejs_> anyone?
09:41:51 <Tekmo> zipper: You may also find this useful.  It contains an example very similar to the one you are studying: http://www.haskellforall.com/2013/12/equational-reasoning.html
09:42:28 <Twey> zipper: take 2 (repeat 'x') {- matches on the list, so evaluate one step -} = 'x' : take (2 - 1) (repeat "x") {- <= 0 condition evaluates n -} = 'x' : (take 1 (repeat 'x')) = 'x' : (take 1 ('x' : repeat 'x')) = 'x' : ('x' : (take (1 - 1) (repeat 'x'))) = 'x' : ('x' : (take 0 (repeat 'x'))) = 'x' : ('x' : [])
09:43:00 <Twey> Oh, crap, sorry quchen
09:43:58 <quchen> <chrisdone> 	it's actually impossible to employ the socratic method in here. ask a newbie a question and it *will* be answered by someone else
09:44:00 <quchen> :-\
09:44:01 <roconnor> aleksejs_: in order for anything to be outputed it must be the case that every element of rs in in xs.
09:44:12 <roconnor> aleksejs_: and this never happens
09:44:15 <zipper> quchen: take 3 (repeat 1) = take 2 (1: repeat 1) = take 1 (repeat 1:1 repeat 1) = take 0 (1:1:1 repeat 1) = []
09:44:22 * hackagebot quickcheck-instances 0.3.6 - Common quickcheck instances  http://hackage.haskell.org/package/quickcheck-instances-0.3.6 (AntoineLatter)
09:44:25 <Twey> quchen: I was focused on my buffer and didn't realize you'd posed almost the same example as a question :þ
09:44:25 <aleksejs_> roconnor, but why?
09:44:49 <quchen> zipper: How did you get from the first to the second expression (i.e. explain the first "=")?
09:45:24 <augur_> !
09:45:30 <quchen> (Spoiler: `take 3 (repeat 1)` is not [].)
09:45:35 <augur_> the statement of the disjunction principle using dependent types
09:45:39 <aleksejs_> roconnor, it should be at least 13 results for primes to 10^2, but not empty list
09:45:45 <augur_> is just the eta-long expansion of a disjunction :o
09:45:58 <aleksejs_> there's some problem with logic, but I can't see it
09:46:13 <roconnor> aleksejs_: becasue rs always contains x and x is never in xs.
09:46:57 <aleksejs_> (headbang) you're right thanks!
09:48:45 <zipper> quchen: not sure how I ended up with the first =
09:48:49 <zipper> :/
09:49:14 <zipper> quchen: it's [1,1,1]
09:49:24 <quchen> > take 3 (repeat 1) -- correct.
09:49:26 <lambdabot>  [1,1,1]
09:49:59 <Hafydd> beacuase
09:50:07 <hakujin> Thinking about using laziness to automatically pipeline requests into 1 http statement when a result is evaluated. e.g. do { req1; req2; res <- req3; print res; req4; } would batch the first 3 reqs into 1 http request and block. Ideas on how to make this happen?
09:51:03 <zipper> quchen: As far as I can see we got to a point where we needed to get the value of repeat 1 when we got it's head we just went on with the take function ignoring the tail.
09:51:29 <zipper> *we needed to get the value of the head of return 1
09:51:50 <ImUrBreda> cant install my own package: cabal: can't find source for XYZ in src, dist/build/autogen
09:52:15 <ImUrBreda> on my other machine it works
09:52:40 <joneshf-laptop> zipper, look at the last clause of `take`
09:52:58 <quchen> I don't know what you mean with "return 1". Anyway, "take n" looks at its argument, and evaluates it until it can decide whether it's an empty list, or a non-empty list.
09:53:24 <quchen> If it's non-empty, then the result is `<head of list> : take (n-1) <tail of list>`.
09:53:53 <quchen> So when you start with `take 3 (repeat 1)`, take will have to evaluate `repeat 1` enough to find out whether it's empty, or whether something can be taken from it.
09:54:05 <quchen> So at this point, (repeat 1) has to be evaluated a bit.
09:54:24 <quchen> By your definition of (repeat 1), it evaluates to `1 : repeat 1`.
09:54:33 <quchen> This is non-empty, so `take` can take an element off.
09:57:22 <zipper> quchen: I meant return
09:57:50 <quchen> I don't know what you mean with "return". It's certainly not Haskell's "return" function.
09:58:32 <zipper> quchen: Ok the result a function gives back after it runs.
09:58:47 <quchen> Let's call that the "resulting value" or something.
09:58:56 <zipper> quchen: Ok
10:00:00 <zipper> quchen: This is fascinating
10:00:37 <sauravtom> testing
10:00:44 <zipper> The fact that repeat 1 is evaluated just a bit instead of it runnning infinitely
10:01:08 <zipper> Also it didn't cause me a stack overflow at any point when I ran an infinite list
10:01:12 <zipper> I wonder why
10:01:26 <zipper> Maybe I did not wait long enough
10:01:35 <quchen> It's all on the heap.
10:01:52 <quchen> The only things on the stack are single applications of `take` and `repeat` here.
10:02:04 <zipper> quchen: So I would run out of memory sooner or later.
10:02:05 <quchen> Single as in "only one at a time".
10:02:52 <quchen> Sure, if you try to put an entire infinite list entirely in your finite memory something is going to crash at some point.
10:03:16 <quchen> (Well, for non-cyclic infinite lists at least.)
10:03:18 <c_wraith> however, something like "print [1..]" will stream the list, garbage collecting it as fast as it's generated
10:03:49 <zipper> Man haskell is just so darn different
10:04:12 <c_wraith> whereas something like "do let x = [1..] ; print x ; print x"
10:04:18 <c_wraith> *that* will run out of memory
10:04:30 <zipper> I wonder what I'll do when I need to program quantum computers if function is so different.
10:04:42 <zipper> *functional
10:05:08 <zipper> c_wraith: Because of the let
10:05:28 <newsham> > let x = [1..] in (x,x)
10:05:30 <lambdabot>  ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:05:30 <c_wraith> zipper: not exactly..  because the value bound in the let is used twice
10:05:40 <zett_zelett> How DOES one program quantum computers?
10:05:51 <Twey> zett_zelett: With difficulty
10:05:58 <danharaj> linear logic
10:06:00 <zipper> zett_zelett: I have no idea but I know it will be different
10:06:09 <zipper> danharaj: Please explain
10:06:11 <quchen> That's mutually exclusive.
10:06:17 <Twey> zett_zelett: There are a few quantum programming languages around, though, like QPL or Valiron's quantum lambda calculus (that one's pretty cool)
10:06:40 <Twey> Not sure if they'll end up being the Right Way to Do It
10:06:49 <zipper> Twey: and people use them to write programs for silicon chips?
10:06:51 <quchen> Step 1: build a quantum computer.
10:07:05 <Twey> zipper: Nope, just as thought experiments currently
10:07:12 <danharaj> http://ncatlab.org/nlab/show/quantum+computation
10:07:44 <Twey> The only quantum computer that's useful so far is D-Wave's thing, and that doesn't lend itself well to traditional programming
10:08:05 <zipper> Twey: If I went back to school and studied math would that put me in a better position to be able to program quantum computers?
10:08:12 <zipper> or which skills will I need
10:08:13 <danharaj> D-Wave's computer doesn't compute BQP any more efficiently than classical computers.
10:08:15 <quchen> Twey: Is it even established whether that thing exists at all?
10:08:32 <danharaj> zipper: Learn how to do fourier transforms like you know how to add and multiply.
10:08:40 <zipper> and will these computers ever be for personal use (PCs) or will they ve for data centers?
10:08:42 <Twey> zipper, zett_zelett: We have http://hackage.haskell.org/package/QIO too
10:09:06 <Twey> quchen: Yeah, it was verified (but it's not a ‘full’ quantum computer, it can only run one algorithm, albeit a rather useful one)
10:09:11 <quchen> zipper: Quantum computing is not general purpose. You could imagine having a "quantum card" like you have a graphics card right now. Anyway, OT.
10:09:30 * monochrom learned fourier transforms to convolve and multiply :)
10:09:37 <zett_zelett> https://en.wikipedia.org/wiki/Quipper : – /
10:09:38 <copumpkin> wtf
10:09:46 <copumpkin> factor :: Int -> QIO (Int, Int)
10:09:54 <Twey> Haha
10:09:54 <copumpkin> not Integer!??!
10:10:06 <monochrom> it's easier to factor Int :)
10:10:19 <quchen> O(1) :-D
10:10:19 <monochrom> "O(1) algorithms exist" :)
10:10:29 <Twey> When you only have five bits to work with, I don't think it makes a difference :þ
10:10:33 <Twey> monochrom: For what?
10:10:48 <monochrom> to factor Int :)
10:10:51 <FireFly> Factoring a 2^w integer, where w ∈ {32,64}
10:10:59 <Twey> monochrom: Ah, for a large enough constant :þ
10:11:26 <FreeFull> I can factorise a 1-bit integer really easily
10:11:44 * monochrom can factor prime numbers!
10:12:16 * quchen can only factor the even primes, the rest is always so confusing
10:12:22 <c_wraith> you can factor prime numbers in O(1) time.  The algorithm is impressive, though the preconditions are onerous
10:12:36 <copumpkin> :)
10:12:42 <zett_zelett> Oh boy.
10:13:04 <monochrom> I like how 31337 is prime. it's so 31337
10:13:18 <zett_zelett> I like how 137 is prime.
10:13:28 <companion_cube> I like how 1 is prime
10:13:29 <copumpkin> I like prime beef
10:13:31 <danharaj> I like how 20 is a prime.
10:13:49 <FreeFull> I like how ' is a prime
10:13:58 <monochrom> haha, you win
10:14:08 <copumpkin> I like how http://i213.photobucket.com/albums/cc153/backroadbob1/img10591545353.jpg is prime
10:14:11 <newsham> i like how 57 is prime
10:14:20 <c_wraith> 57 will always be the best prime
10:14:52 <newsham> in base 8
10:17:42 <Walther> So, could someone offer a bit of help in getting my main right, there's pseudocode as comments in main http://lpaste.net/3435573713351737344
10:17:47 <Walther> all the other parts work fine
10:18:09 <Walther> I just don't know how to easily incorporate a counter + "until" in Haskell
10:18:28 <Walther> due immutables
10:19:26 * hackagebot avl-static 0.1.0.0 - A compile-time balanced AVL tree.  http://hackage.haskell.org/package/avl-static-0.1.0.0 (FedericoLebron)
10:19:37 <ChongLi> Walther: what is the counter supposed to be counting?
10:19:40 <scshunt> ^
10:19:51 <kammerer> Anyone knows why SublimeHaskell is not in Package Manager's repos, anymore (is anyone using it)?
10:19:52 <scshunt> And what is the thing you want to do "until". Is it an IO action?
10:19:59 <Walther> number of generations / basically prettyprinted lines
10:20:46 <Walther> scshunt: it's in the comment; i want to run evolve, and prettyprint "child" after running it. Notice how prettyprint requires a number though
10:20:54 <ChongLi> Walther: ahh, so target is a number of generations?
10:21:02 <scshunt> Walther: the "simple" implementation is to do something recursive
10:21:04 <Walther> No, target is the target sentence
10:21:15 <Walther> see http://en.wikipedia.org/wiki/File:Dawkins-Weasel.png
10:21:31 <ChongLi> Walther: so the number of generations is unbounded?
10:21:39 <Walther> Nod.
10:21:55 <Hafydd> Walther: http://lpaste.net/98374
10:22:04 <Walther> It stops when child == target; i.e. when the genetic algorithm has succeeded
10:22:30 <Walther> Hafydd: I thought you can't have mutables; does that counter = counter + 1 work in Haskell?
10:22:32 <ChongLi> it seems to me the most straightforward way to do this is to have a data type
10:22:53 <Walther> I mean, that does seem like a great, simple way to do this, but I thought you can't redefine vars
10:22:56 <Hafydd> Walther: that's rebinding counter as a new value, not mutating it.
10:23:00 <ChongLi> Walther: he's not doing mutation, he's shadowing it
10:23:05 <ChongLi> it's frowned upon :)
10:23:13 <Hafydd> You can call it counter' if you prefer.
10:23:26 <Walther> ah, so this is a case of something I haven't been told about "pssst it still can be done if necessary" :P
10:23:37 <Hafydd> No, it really isn't mutation.
10:23:53 <Walther> Hmm?
10:24:05 <ChongLi> Walther: the old value of counter will still be there outside the scope of the loop
10:24:29 <ChongLi> mutation is a machine concept of poking data into memory
10:24:39 <ChongLi> this is just reusing an old name for a new thing
10:25:47 <Walther> ChongLi: I'm afraid I still don't quite follow
10:26:12 <ChongLi> Walther: http://lpaste.net/98374
10:26:18 <ChongLi> that's another way to do it
10:26:28 <Twey> Unless that's a lazy numeral, I'm pretty sure that ‘let’ doesn't do what you think it does
10:26:31 <ChongLi> though the counter will be off by one :)
10:26:43 <ChongLi> since it's postincrement now instead of preincrement
10:27:09 <Twey> > do let {x = 5}; let {x = x + 1}; x
10:27:13 <lambdabot>  mueval-core: Time limit exceeded
10:27:15 <Walther> Hafydd: weasel2.hs:24:44: Not in scope: `count'
10:27:30 <Walther> also     The last statement in a 'do' block must be an expression
10:27:30 <Walther>       count <- let loop counter child = do { ... } in loop child 0
10:27:33 <ChongLi> Walther: oh, that should be counter
10:27:39 <Twey> Hafydd: It's a recursive binding
10:27:54 <Walther> http://lpaste.net/98374
10:28:24 <Walther> right; still getting "last statement in a do block should be a statement"
10:28:31 <Walther> erm, "must be an expression"
10:28:32 <ChongLi> Walther: yeah, you need return count after all that
10:28:43 <Walther> i need to be more careful when typing stuff into window instaed of pasting
10:29:39 <Walther> ChongLi: Hm?
10:29:44 <Hafydd> My mistake. The second variable should be counter'.
10:29:59 <Walther> Fixed that
10:30:55 <Walther> ChongLi: where do I need to add the return / how?
10:31:38 <ChongLi> Walther: just a sec
10:32:02 <ChongLi> http://lpaste.net/98374
10:32:06 <ChongLi> this should make a bit more sense
10:32:12 <ChongLi> I did not test it, however
10:33:07 <ChongLi> it's probably still going to fail because "return count" is not of type IO ()
10:35:10 <ChongLi> err
10:35:14 <ChongLi> no that's not what I want
10:35:16 <ChongLi> damn pasting
10:35:27 <c_wraith> The type of this is kinda ugly.
10:35:47 <ChongLi> well, the whole algorithm is too imperative
10:36:09 <ChongLi> it really ought to be set up in terms of iterate
10:36:18 <Walther> pasted the errors there
10:36:28 <c_wraith> well, he refused to accept my advice on how to write it sanely, and it's just getting worse.
10:36:48 <ChongLi> c_wraith: well, to be fair
10:36:52 <ChongLi> you just wrote it for him
10:36:59 <Walther> c_wraith: hey now, this time it *is* a bit more sane now, and it is *really* close to being finished
10:38:02 <c_wraith> Though now I am interested in how you'd put together a type for this, totally independent of the underlying problem.
10:38:04 <ChongLi> Walther: after we get it working, do you promise to try and implement it a sane way?
10:38:54 <Walther> Sure, I can try to do so, but I'm probably going to need as much if not more help in that :P (for instance, to know what is that "saner way")
10:39:09 <ChongLi> Walther: the sane way is with iterate
10:39:15 <ChongLi> @src iterate
10:39:15 <lambdabot> iterate f x =  x : iterate f (f x)
10:39:23 <ChongLi> that's all you need, seriously
10:39:50 <ChongLi> so how do you write the 2 arguments to iterate?
10:40:00 <ChongLi> well, x is a data type that contains all the information you need
10:40:21 <ChongLi> current generation, generation count, score, etc.
10:40:40 <Walther> hmm
10:40:51 <ChongLi> and f is a function that takes all of those things and returns a new value of the same type
10:41:01 <c_wraith> countStepsUntil :: Monad m => (a -> m Bool) -> (a -> m a) -> a -> m (a, Integer) -- eww, and it's not even good enough if you want to write the logic cleanly.  Solving it with this would require an IORef in the test code.
10:41:52 <ChongLi> Walther: so shall we start by writing such a data type?
10:42:03 <Walther> c_wraith: that looks like shooting a pineapple with a cannon, solving a minor problem with way too much effort
10:42:19 <Walther> c_wraith: the current implementation *really* isn't too far from working, even if far from optimal or purest/cleanest
10:42:20 <c_wraith> Walther: it is. :)
10:42:39 <Walther> ChongLi: Hmm. Let's see.
10:42:58 <monochrom> poor pineapple
10:43:21 <c_wraith> also, I shot a pineapple out of the cannon at the other pineapple.  poor pineapple*s*
10:44:08 <monochrom> translating imperative programs to haskell is too much effort
10:44:31 <Walther> data Child = Child { sentence :: String, score :: Int, generation :: Int } deriving (Show)?
10:44:44 <monochrom> then again, learning haskell properly is also too much effort
10:45:00 <monochrom> you're between a wok and a frying pan
10:45:17 <ChongLi> Walther: looks good so far, but I'd call it something else :)
10:45:18 <Walther> monochrom: :)
10:45:27 <ChongLi> Child seems an odd name
10:45:55 <Hafydd> I'm going to call my next child Child.
10:45:56 <Walther> better ideas? It's for a silly genetic algorithm :P
10:46:53 <c_wraith> I'm still trying to figure out if I think using a Rand monad makes code cleaner.
10:47:22 <ChongLi> data Weasel = Child { sentence :: String, score :: Int, generation :: Int, randGen :: StdGen } | Parent [Child]
10:47:26 <ChongLi> how about something like this?
10:47:36 <Walther> c_wraith: and I'm still trying to figure out if there is a sane way to cleanly operate randoms in Haskell :|
10:47:59 <Walther> what does that Parent [Child] do in the end?
10:48:01 <c_wraith> Walther: I think the explicit state-passing option is pretty clean.
10:48:04 <ChongLi> err
10:48:16 <ChongLi> it should be Parent [Weasel]
10:48:28 <ChongLi> making it a tree
10:49:17 <Walther> Hmm?
10:50:12 <Walther> should it though, as you have data Weasel = Child ...
10:51:12 <Walther> Also, I'm terribly sorry for all this time-wasting for you guys :)
10:51:14 <SaBer> Walther: Weasel is the type, Child is one of its constructors
10:51:14 <ChongLi> Walther: hmm, now that I think of it
10:51:32 <ChongLi> children have children as well
10:51:42 <ChongLi> so it makes no sense to distinguish between parents and children
10:51:45 <Walther> SaBer: Nod, hence why should the end of the data definition point to the data type and not its definition
10:51:46 <ChongLi> they're all just nodes
10:52:12 <Walther> There's also no reason to ever store more than the most optimal child sentence
10:52:21 <Walther> of a generation
10:52:29 <ChongLi> Walther: ahh, okay
10:52:37 <ChongLi> so forget about the tree structure
10:53:06 <Walther> it's essentially one-originating "breeding"; create offspring, continue breeding with best offspring
10:53:18 <ChongLi> data Gen = Gen { sentence :: String, score :: Int, generation :: Int }
10:53:19 <Walther> dropping all the rest
10:53:37 <ChongLi> oh, and the StdGen of course
10:53:58 <ChongLi> data Gen = Gen { sentence :: String, score :: Int, generation :: Int, randGen :: StdGen }
10:54:37 <ChongLi> alright, so you've got that?
10:54:53 <Walther> heh, obviously
10:54:58 <Walther> simple enough
10:55:13 <ChongLi> now we need a function which takes that data structure and computes a new one of those
10:55:26 <ChongLi> all of the information to compute the new one is in there
10:55:35 <ChongLi> and we can extract it by pattern matching
10:55:37 <Walther> well, I need to steal the hamming function though
10:55:45 <Walther> from the previous versions
10:55:51 <ChongLi> Walther: oh, leave all that stuff in there
10:55:54 <ChongLi> we can use it
10:56:08 <Walther> All of it?
10:56:23 <Walther> or was this intended as a rewrite
10:56:41 <ChongLi> well, everything but the functions that return IO or RVar
10:57:08 <ChongLi> those are impure functions which we do not need
10:57:43 <Walther> ...well, then it's just the hamming function :P
10:58:00 <Walther> all others involve either IO or RVar
10:58:07 <ChongLi> Walther: okay
10:58:39 <ChongLi> so let me see here
10:59:27 <ChongLi> we're rolling a d100 and then comparing it against chance and then returning cell which comes from nowhere
10:59:30 <ChongLi> haha
10:59:40 <ChongLi> oh I see, it's bound at the top level
11:00:04 <Walther> returning either a random "mutated" cell or the original cell
11:00:33 <SaBer> Walther: sorry, I got sidetracked when looking into the [Child] vs. [Weasel]. You can't do that with standard haskell, but I found out that with -XDataKinds in ghc you can do it
11:00:55 <Walther> SaBer: it was found out that it's not necessary anyway :)
11:01:23 <SaBer> Walther: just saying that it's not even valid without extensions
11:01:25 <ChongLi> SaBer: don't worry, we're not dealing with that anymore
11:01:27 <Walther> nod
11:01:33 <ChongLi> we're just using a straight record type
11:02:31 <WraithM> Say I want to make several HTTP GET requests concurrently. What would be an efficient way to do that? I'm polling a REST api. I'm using mapConcurrently right now (from Control.Concurrent.Async). Is that the right direction?
11:03:06 <ChongLi> WraithM: yep
11:03:07 <WraithM> Also, all of those GET requests are to the same URL, with maybe some different parameters.
11:03:54 <ChongLi> WraithM: http://chimera.labs.oreilly.com/books/1230000000929/index.html
11:04:02 <ChongLi> here's a great book on the whole subject
11:04:19 <WraithM> I have the book right next to me :)
11:04:23 <ChongLi> ahh :)
11:04:38 <WraithM> It actually doesn't have mapConcurrently in there. It has a whole bunch on Control.Concurrent.Async.
11:05:06 <WraithM> At least, as far as I can see
11:05:51 <Walther> ChongLi: the cell and mutate functions are going to be bitches to re-implement without using RVars though
11:05:59 <ChongLi> Walther: no, not really :)
11:06:12 <intrados> WraithM: I have pretty much the same use case and mapConcurrently seems to be working reasonably well for me
11:06:25 <hamid> guys where's evaluate? :/
11:06:40 <WraithM> Okay :) thanks!
11:06:51 <benmachine> :t Control.Exception.evaluate
11:06:51 <lambdabot> a -> IO a
11:06:57 <benmachine> because that totally makes sense.
11:07:11 <hamid> benmachine, yeah! ofcourse :P thanks
11:07:31 <dv-> :t return :: a -> IO a
11:07:32 <lambdabot> a -> IO a
11:08:15 <hamid> @src evaluate
11:08:15 <lambdabot> Source not found. There are some things that I just don't know.
11:09:57 <hamid> There's definitly `seq` used in `evaluate` right?
11:10:32 <ilmig_> @pl \x y -> x ++ g y
11:10:33 <lambdabot> (. g) . (++)
11:11:36 <NemesisD> is there a generic typeclass in base somewhere for listlike things that can be cons'd to?
11:12:35 <ilmig_> @pl \x y -> x ++ (g y)
11:12:35 <lambdabot> (. g) . (++)
11:14:33 * hackagebot postgresql-simple 0.4.0.2 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.4.0.2 (LeonSmith)
11:14:35 * hackagebot flamethrower 0.0.1.1 - A template engine for HTML  http://hackage.haskell.org/package/flamethrower-0.0.1.1 (charmander)
11:17:09 <simpson> NemesisD: Not Monoid?
11:18:10 <Walther> ...why doesn't prettyprint Gen = generation ++ ": " ++ sentence ++ " -- score: " ++ score work though?
11:18:27 <Walther> "Constructor Gen should have four arguments"
11:18:46 <ChongLi> Walther: because you're not pattern matching correctly
11:18:48 <ChongLi> hold on
11:18:57 <ChongLi> http://lpaste.net/98379
11:19:00 <sipa> prettyprint (Gen generwtion sentence score work) = ... ?
11:19:02 <ChongLi> so here's a pure mutate function
11:19:59 <WraithM> Another question, I'm downloading a whole bunch of JSON data (related to my question above). The JSON data is an array of objects, where I only care about certain fields in those objects, and the objects are quite large. I've defined a record and FromJSON instance (using aeson). What would be a good way to go about structuring how the http request and the JSON parsing connect? What I mean is, should I use http-conduit and attoparsec-condu
11:19:59 <intrados> NemesisD: It's not in base and I think it's a bit unpopular but http://hackage.haskell.org/package/ListLike
11:20:00 <Walther> ChongLi: errrr
11:20:05 <ChongLi> Walther: what?
11:20:06 <WraithM> Long question...
11:20:51 <Walther> I'm not sure if that is the same as my current mutate function; that takes a String and changes each letter with a random chance
11:21:10 <ChongLi> Walther: my mutate function provides a separation of concerns
11:21:32 <Walther> it should input a String and output a (potentially different, or not) String
11:21:38 <Walther> hmm
11:21:39 <ChongLi> making it perfect for zipWith
11:22:14 <Walther> a) i'm not sure I'm following b) this is starting to look like written by you :P
11:22:20 <ChongLi> Walther: so you're generating 100 children
11:22:32 <ChongLi> and then mutating 5 percent of them, on average?
11:22:36 <Walther> No.
11:22:51 <pingu> Anyone know how it usually takes to get upload rights to hackage?
11:22:52 <ChongLi> oh, each character has a 5% chance to change?
11:23:04 <Walther> Genetic algorithm: mutation happens at cellular stage at birth :P Yes, exactly
11:23:11 <hakujin> WraithM: use http-conduit's httpLbs and pass the response to aeson's decode
11:23:12 <ChongLi> I get it now
11:23:19 <hpc> pingu: it varies depending on how often that inbox gets checked
11:23:22 <Walther> that's the reason I had to have the cell-level trickery
11:23:37 <Walther> and mind you, even "correct" letters can change again
11:23:53 <WraithM> hakujin: Cool, that's what I'm doing now, but I didn't know if I was missing something.
11:23:56 <WraithM> Thanks
11:24:05 <Walther> you just always continue with the best offspring of the generation
11:24:16 <Walther> (so yes, you can have occasional devolution)
11:24:19 <hakujin> decode lazily parses so you're fine with only using a few fields
11:24:34 * hackagebot purescript 0.2.13.1 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.13.1 (PhilFreeman)
11:24:35 <WraithM> :)
11:24:40 <WraithM> which is excellent
11:24:42 <ilmig_> @pl \x y -> f x $ g y
11:24:42 <lambdabot> (. g) . f
11:30:47 <hakujin> Thinking about using laziness to automatically pipeline requests into 1 http statement when a result is evaluated. e.g. do { req1; req2; res <- req3; print res; req4; } would batch the first 3 reqs into 1 http request and block. Ideas on how to make this happen?
11:32:33 <intrados> hakujin: Free monad?
11:32:48 <benmachine> hakujin: implicit batching sounds like a bad idea to me
11:32:58 <hakujin> intrados: I no experience with free monads. Will you elaborate a little?
11:33:35 <johnw> another possibility to use MonadPlus: res <- req1 `mplus` req2 `mplus` req3
11:33:39 <hakujin> benmachine: why? HTTP is chatty and batched transfers should reduce total latency yeah?
11:33:44 <benmachine> why not just do res <- batch $ do req1; req2; req3
11:35:07 <benmachine> hakujin: batching's great in principle, but it would be nice if it was predictable whether or not it happened
11:35:36 <intrados> hakujin: I know very little about them, but, from what I've seen, it seems like you could use one here. http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
11:36:02 <FreeFull>   build-depends:       base >=4.6 && <4.7, text >= 0.11 && < 0.12, websockets == 0.8.1.1, mtl == 2.1.2, json >= 0.7 && json < 0.8, HTTP == 4000.2.8
11:36:12 <FreeFull> What's wrong with this build-depends line? Cabal just says parse failed
11:36:23 <hakujin> benmachine: okay I'm listening. What is a circumstance where implicit batching would be bad in the case of a database library? Assuming it "just worked"
11:36:31 <hakujin> intrados: thanks!
11:37:04 <quchen> FreeFull: It mentions JSON twice, could that be a problem?
11:37:16 <FreeFull> Could be
11:37:19 <FreeFull> Let me try changing that
11:37:21 <pingu> FreeFull: the Cabal parser is very fragile, have you tried it with a space after base >= and then after < and before 4.7?
11:37:35 <pingu> I wouldn't think that mentioning json twice would be a parse error
11:37:42 <johnw> quchen is right
11:37:50 <FreeFull> quchen: That was it
11:38:13 <pingu> I don't think I want to look at cabal's parsing code.
11:38:51 <Thooms> :d
11:38:58 <benmachine> hakujin: perhaps it wouldn't. I think it more worries me that you mentioned laziness, and I don't think batching should depend on strictness properties
11:39:17 <benmachine> because then you can do refactorings that seem innocuous but actually change the behviour of something
11:39:21 <benmachine> *behaviour
11:39:36 <johnw> benmachine: I think he more meant that the actions wouldn't take place immediately, but would be lazy in that they would wait until the whole do block had been expressed so that some of them could be magically glommed together
11:39:37 <__sebastian__> hi, I'm searching for a mapM or traverse like function with this siganture: (a -> m1 b) -> [m2 a] -> m1 [m2 b]
11:39:50 <hakujin> johnw is correct
11:39:51 <__sebastian__> anyone has a guess?
11:40:01 <benmachine> hmm
11:40:16 <johnw> hakujin: which exactly expresses what Free monads are for, btw; although there could be other ways to solve your problem too
11:40:19 <benmachine> ok, so I'm going to say that implementation-wise, explicit batching would be way easier :)
11:40:20 <__sebastian__> or (a -> f b) -> [m2 a] -> m1 [f b]
11:40:27 <hakujin> johnw: thanks!
11:40:30 <benmachine> but I don't actually have strong opinions on how it's done
11:40:45 <__sebastian__> or (a -> m1 b) -> [f a] -> m1 [f b]
11:40:48 <hakujin> benmachine: agreed haha
11:41:08 <benmachine> johnw: your idea is to build a syntax tree of sorts so you can see what's going on and then do the glomming and then run it?
11:41:08 <johnw> __sebastian__: you can do that if you have a "distribute" operation
11:41:18 <johnw> benmachine: yes
11:41:45 <johnw> __sebastian__: where distribute :: f (m a) -> m (f a)
11:41:57 <johnw> aka "sequence" in some contexts
11:42:05 <johnw> err, sequenceA
11:42:14 <FreeFull> :t sequence
11:42:15 <lambdabot> Monad m => [m a] -> m [a]
11:42:18 <FreeFull> :t sequence . map
11:42:19 <lambdabot>     Couldn't match type `[a1] -> [b0]' with `[m0 a0]'
11:42:19 <lambdabot>     Expected type: (a1 -> b0) -> [m0 a0]
11:42:19 <lambdabot>       Actual type: (a1 -> b0) -> [a1] -> [b0]
11:42:33 <FreeFull> :t \f -> sequence . map f
11:42:34 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
11:42:35 <__sebastian__> :t mapM . fmap
11:42:36 <johnw> :t (sequenceA .) . map
11:42:36 <lambdabot> (Monad m, Functor m) => (a -> b) -> [m a] -> m [b]
11:42:36 <lambdabot>     Not in scope: `sequenceA'
11:42:37 <lambdabot>     Perhaps you meant one of these:
11:42:37 <lambdabot>       `T.sequenceA' (imported from Data.Traversable),
11:42:40 <benmachine> :t \f -> mapM (mapM f)
11:42:41 <lambdabot> Monad m => (a -> m b) -> [[a]] -> m [[b]]
11:42:41 <johnw> :t (T.sequenceA .) . map
11:42:42 <lambdabot> Applicative f => (a1 -> f a) -> [a1] -> f [a]
11:42:57 <Walther> Hrmph. There's still two problems with http://lpaste.net/98374 and the third new rewrite is not progressing as I have no idea how to do this the other way without RVars and using a data type http://lpaste.net/141025925474025472
11:42:57 <benmachine> :t \f -> traverse (traverse f)
11:42:58 <lambdabot> (Applicative f, Traversable t, Traversable t1) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
11:44:54 <benmachine> __sebastian__: do you have more information on what m2 is?
11:45:16 <benmachine> oh, you changed your letters
11:45:40 <__sebastian__> benmachine: I think I've found it:
11:45:41 <__sebastian__> :t mapM . traverse
11:45:42 <lambdabot> (Monad m, Applicative m, Traversable t) => (a -> m b) -> [t a] -> m [t b]
11:45:51 <benmachine> right
11:46:15 <benmachine> mapM is roughly the same as traverse
11:46:26 <quchen> roughly?
11:46:53 <johnw> the mapM from Data.Traversable is pretty much identical to it :)
11:47:05 <benmachine> yeah, only the contexts are different
11:47:17 <johnw> oh, Applicative vs. Monad, right
11:47:28 <quchen> LALALA DREAM WORLD I CAN'T HEAR YOU JOHNW
11:47:45 <monochrom> I can
11:48:02 <johnw> quchen: thankfully, it's a distinction that's on its last legs :)
11:48:10 <benmachine> soon Applicative will be a superclass of Monad and Traversable.mapM will be truly redundant (and ordinary-mapM will be almost completely so)
11:48:23 <ChongLi> Walther: http://lpaste.net/98380
11:48:24 <ChongLi> okay
11:48:51 <ChongLi> so that gives you an infinite string of random characters A to Z and ' '
11:49:37 * hackagebot parsers 0.10.2 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.10.2 (EdwardKmett)
11:49:59 <qrada> hey, anyone have any idea about this.. ghc 7.4 on this box. I'm just seeing how long it takes to obtain fibonacci(40) using the 'traditional' fib definition: fib 0 = 0; fib 1 = 1; fib n = fib (n - 2) + fib (n - 1)... No matter what I do, it takes ~40 seconds to find fib(40). I've added 'strict' and i've tried different -O flags to ghc.. any idea why it's 'taking so long'? doesn't seem to be TCO'n but i dont know how to verify, yet
11:50:05 <Walther> ChongLi: this seems, yet again, to be way out of my league ._.
11:50:14 <ChongLi> Walther: why? what's wrong with it?
11:50:56 <Walther> I don't understand it; e.g. why does the random need to be done in a difficult fashion with splitting and snd'ing and having a weird tuple there storing some seed information
11:50:57 <ChongLi> Walther: you did pick a very hard algorithm for a beginner to implement :)
11:51:08 <quchen> qrada: Your algorithm has to calculate a *load* of recursion; it scales exponentially.
11:51:24 <quchen> I'm surprised fibo(40) terminates at all and doesn't blow up something.
11:51:26 <ChongLi> Walther: because you can't generate information out of thin air in a pure function
11:51:31 <Walther> The algorithm wouldn't be that bad, I'd have written the entire thing in less than two hours in Python, and apart from the random stuff, probably in Haskell too
11:51:43 <ChongLi> Walther: that's the problem
11:51:48 <ChongLi> you can't separate out the random stuff
11:51:56 <johnw> ChongLi: sure you can, just accept ThinAir as an argument :)
11:51:57 <ChongLi> it's intertwined with the rest of the code
11:52:07 <ChongLi> it's an ugly, imperative algorithm
11:52:13 <qrada> damn.. is there any way to improve that? or is this just how things work.. i thought ghc would tail call optimize and i'd see some decent performance on that
11:52:18 <Walther> :F why can't I just take StdRandom or /dev/random as a source
11:52:29 <qrada> like maybe if i used a strict foldl or something instead?
11:52:30 <ChongLi> Walther: because that's doing IO
11:52:30 <qrada> i dno
11:52:38 <ChongLi> and IO is not allowed in pure functions
11:52:46 <Walther> well why not make it a IO function then?
11:52:57 <Walther> because I don't really *need* a pure function just here
11:53:01 <quchen> qrada: Your algorithm is not tail recursive sou you can't do TCO on it. It's simply an inefficient algorithm and GHC can't do much about that.
11:53:11 <qrada> ah
11:53:22 <ChongLi> Walther: cause that's ugly
11:53:27 <ChongLi> admittedly, this is pretty ugly too
11:53:28 <quchen> > let fibo = 0 : 1 : zipWith (+) fibo (tail fibo) in fibo !! 41   -- qrada
11:53:29 <lambdabot>  165580141
11:53:32 <qrada> cool thanks
11:53:41 <qrada> let me try that
11:53:45 <Walther> ChongLi: exactly; I don't see how doing stuff ugly in a different way is any better
11:53:47 <quchen> That one is linear.
11:54:04 <qrada> guh, that's insane fast
11:54:17 <quchen> O(n) vs O(e^n)
11:54:19 <Walther> that being said, I'm sure I'm not the only person who has tried to write functions with Random and IO in them in Haskell
11:54:24 <Walther> it *can* be done
11:54:46 <ChongLi> Walther: there's a difference between writing something like that and trying to transcribe an existing algorithm into Haskell
11:54:48 <qrada> thanks alot man! helps
11:54:55 <Walther> ChongLi: Nod.
11:55:43 <ChongLi> hmmm, now that I think about it
11:55:55 <Walther> this being said, I'd be glad to punch in the couple needed fixes to the weasel2.hs / http://lpaste.net/98374 and after getting that version working move on to a completely new problem that doesn't include that much random :F
11:56:27 <roconnor> using the Random monad would be be a resonable compormise between pure functions and full IO monad.
11:56:45 <ChongLi> roconnor: yeah, but it's a separate package
11:56:55 <roconnor> is that bad?
11:56:56 <monochrom> and the Random applicative, even better :)
11:57:03 <Cale> Walther: Well, the first one is easy, just remove the 'len' in spawn len there
11:57:05 <ChongLi> roconnor: I don't know, Walther is a beginner
11:57:08 <roconnor> monochrom: good point.
11:57:15 <Cale> Walther: since you didn't actually make spawn a function of the length
11:57:32 <Lethalman> mh Vec3 and Vec4 have no Show instance :-(
11:57:33 <Walther> right
11:57:41 <Lethalman> so I can't do type Foo = Vec3 Bar
11:57:43 <Lethalman> I guess...
11:57:49 <Walther> the latter looks weirder though
11:58:28 <Cale> Walther: The next one has to do with the fact that you're running the action  evolve child  in this do-block, and evolve child :: RVar String
11:58:38 <Cale> Walther: So the whole do-block is an RVar
11:58:41 <Lethalman> ops my bad
11:58:50 <Walther> ah, I have to stab in a "run" call somewhere
11:58:53 <Cale> yeah
11:58:54 <Walther> ...but where
11:59:03 <Cale> Probably around evolve
11:59:31 <Cale> child <- runRVar (evolve child) StdRandom  -- perhaps
11:59:39 <Cale> or
11:59:46 <Cale> child <- run (evolve child)
12:00:07 <Walther>     No instance for (Num String) arising from a use of `loop'
12:00:23 <tomberek> how does one write something like: type L a = Int -> [a]  with just type L = ?
12:00:27 <Cale> You appear to have the parameters to loop swapped when you call it
12:00:55 <Cale> tomberek: One doesn't
12:01:28 <Cale> You can write it in prefix form as  type L a = (->) Int ([] a)
12:01:33 <Cale> but that doesn't help you
12:01:38 <Walther> *blink* swapping the parameters, now it :loads but gets caught in an infinite loop / "*** Exception: <<loop>>
12:01:48 <tomberek> Cale: ok, though so... (it would be nice for type families)
12:02:24 <intrados> tomberek: You're not looking for existential types?
12:02:37 <Cale> Walther: Perhaps you should avoid the excessive name shadowing :)
12:02:43 <Cale> Walther: It's a little confusing
12:02:53 <tomberek> intrados: no, i have a type family that is of kind *->*
12:03:04 <Cale> We should write child' <- run (evolve child)  at least (though that's not the problem)
12:03:05 <Walther> do define shadowing, so that I can understand what I should avoid :P
12:03:10 <FreeFull> Should I use http-conduit to send a simple POST request from my program, since it already depends on a library that depends on http-conduit?
12:03:12 <Cale> and then use child' instead of child
12:03:25 <Cale> Walther: shadowing means binding a variable which is already in scope
12:03:36 <Cale> Walther: making it impossible to refer to the outer variable
12:03:37 <tomberek> Cale: what about being able epress something like (Num a || Show a) => blah..blah   to say one of the contraints are met
12:03:44 <Walther> hmm
12:03:55 <Cale> tomberek: Nope, there's nothing you could do with such knowledge
12:03:59 <FreeFull> tomberek: What would the implementation be?
12:04:00 <Twey> tomberek: type (:.:) a b c = a (b c); L = (->) Int :.: [] -- maybe this works?
12:04:04 <Cale> tomberek: You have to know *which* is met
12:04:08 <Walther> we're getting really close with this though! and this is the version I can honestly call at least *mostly* written by me, haha
12:04:39 <ChongLi> http://lpaste.net/98381
12:04:42 <ChongLi> what about something like this?
12:04:44 <Cale> Walther: oh
12:04:50 <Cale> Walther: let counter = counter + 1
12:04:50 <Twey> Oh, not for a type synonym, mind
12:04:52 <Walther> newest iteration at http://lpaste.net/98374
12:04:55 <tomberek> Cale: I am looking at doing this (HasNext a, Next (Next a) ~ a OR Next a ~ a)
12:04:56 <Cale> There's your infinite loop right there!
12:05:10 <Cale> You defined counter to be equal to itself + 1
12:05:16 <Twey> I wonder why there's no Random instance for tuples
12:05:17 <tomberek> Twey, i'll try, thanks for the suggestion
12:05:22 <Twey> tomberek: No, it won't work
12:05:27 <tomberek> erg
12:05:31 <Cale> which isn't a property satisfied by many integers :)
12:05:35 <Twey> You can define a type like that, but not a type synonym
12:05:40 <ChongLi> this is an infinite list of Bools, with a 5% rate of Trues
12:05:41 <Twey> Type synonyms have to be fully applied
12:06:19 <tomberek> Cale: remember when i was trying to express:  (Next (Next (Next .... Next a) ~ a
12:06:36 <Cale> tomberek: I might've missed that
12:06:45 <tomberek> I couldn't figure it out.  So I thought I'd go the route of zip2,zip3,zip4 etc...
12:06:51 <Walther> ChongLi: hmmmm wouldn't still help as you'd need a random character selected then though. Also, we're *really really* close to having the mostly-written-by-me version running with Cale
12:07:01 <tomberek> and have type Next2 = (Next (Next a) ~ a)
12:07:11 <ChongLi> Walther: yeah, that's in another function
12:07:20 <Cale> Walther: Who suggested you use random-fu and random-extras?
12:07:38 <ChongLi> http://lpaste.net/98383
12:07:39 <Cale> Walther: They're fine, it's just an interesting choice
12:07:47 <ChongLi> Cale: he found them on his own
12:07:50 <tomberek> Cale: so I can get close with (HasNext a, Next2 || Next3 || Next4)
12:07:56 <Walther> Cale: Google; I was looking for a neat way to have random Chars from a custom list, involving out of range stuff (I need the space character in addition to a..z)
12:08:10 <tomberek> Cale: the function will know I can call next at least once
12:08:19 <Walther> and in that, other random ways seemed a bit tricky
12:08:50 <Cale> tomberek: What are the methods of Next2 etc.?
12:08:57 <aleksejs_> > 1.0 == floor 1.0
12:08:58 <lambdabot>  No instance for (GHC.Real.Integral a0)
12:08:58 <lambdabot>    arising from a use of `GHC.Real.floor'
12:08:58 <lambdabot>  The type variable `a0' is ambiguous
12:08:58 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
12:08:58 <lambdabot>  Note: there are several potential instances:
12:09:01 <aleksejs_> why?
12:09:04 <Lethalman> hi, so I've used Vec for this, looks good to me, what do you think? it's a model for rubik cube: http://paste.debian.net/75815/
12:09:11 <tomberek> Cale: HasNext has just a next method
12:09:16 <Cale> aleksejs_: because floor never produces a result of the same type as its argument
12:09:27 <Cale> :t floor
12:09:28 <lambdabot> (Integral b, RealFrac a) => a -> b
12:09:37 <tomberek> type Next2 = (Next (Next a) ~ a)   ensures that there is a loop in the Next chain
12:09:40 * hackagebot linear 1.4 - Linear Algebra  http://hackage.haskell.org/package/linear-1.4 (EdwardKmett)
12:09:42 <Cale> It takes a real fractional argument, and produces an integral result
12:09:50 <Cale> There are no types which are instances of both of those classes
12:09:58 <tomberek> but the function may never use it
12:10:02 <Cale> For example, it might take a Double and produce an Integer
12:10:22 <tomberek> it only needs one invocation of the method "next"
12:10:29 <Cale> tomberek: Oh...
12:10:44 <Cale> Okay, so you have the same problem, this just makes it harder for me to explain why :)
12:11:03 <tomberek> Cale: If there's some type trickery to get the infinite chain working, that would be great. But I'm doubtful.
12:11:04 <aleksejs_> Cale, then what would be the way to check if fractional part of number is 0?
12:11:21 <Cale> (because type equality witnesses and coercions are invisible)
12:11:33 <Cale> tomberek: I don't really understand what you're trying to do
12:11:42 <Cale> tomberek: Maybe we should take a step back and look at it
12:11:55 <Cale> aleksejs_: Its type is such that it has to be.
12:12:18 <Cale> aleksejs_: Like, if you turn a Double into an Integer, then what do you mean "fractional part"?
12:12:22 <aleksejs_> > 1.0 == fromInteger (floor 1.0)
12:12:23 <lambdabot>  True
12:12:31 <aleksejs_> > 1.5 == fromInteger (floor 1.5)
12:12:32 <lambdabot>  False
12:12:35 <Cale> yeah, you can do that
12:13:14 <tomberek> Cale: sure...  I want to say that there are several sets. Each set has a function that takes an element in one set, produces one in the "next" set. Applied enough times, it should loop back and produce an element (maybe not the same one) from the original set.
12:13:18 <Walther> !!!
12:13:23 <Walther> I got it working! http://lpaste.net/98374
12:13:26 <Cale> > properFraction pi
12:13:27 <lambdabot>  (3,0.14159265358979312)
12:13:35 <Cale> aleksejs_: ^^
12:13:39 <Walther> Huge thanks to all you guys, this has been a fantastic learning experience
12:13:41 <Twey> tomberek: Are you trying to manipulate a Rubik's cube in the type system?  =)
12:13:42 <ChongLi> haha
12:13:51 <ChongLi> Walther: a very frustrating one
12:13:53 <cdk> I have 3 data types, A, X, Y. The constructor for A takes an instance of X and Y, and I can only create an X and Y from an already created A. I have a cyclical dependency here, is it possible to boostrap this with Control.Monad.Fix?
12:13:57 <Walther> ChongLi: that too!
12:14:11 <tomberek> Twey: no, but that's an interesting idea.
12:14:11 <Walther> But hey, it *works*!
12:14:19 <Cale> cdk: You don't need Control.Monad.Fix
12:14:19 <ChongLi> people usually pick much easier problems as beginners
12:14:26 <Twey> cdk: You don't need it; you can just make a recursive definition (it'll be infinite, though!)
12:14:27 <Cale> cdk: You just need ordinary recursion
12:14:37 <Walther> ChongLi: feel free to suggest appropriate next ones :P
12:14:41 <Twey> cdk: Unless you're producing the values to go inside by execution of a monad action
12:14:51 <simpson> cdk: What do these values represent, BTW?
12:15:20 <Cale> tomberek: Can we step back a bit farther? What problem are you trying to solve?
12:15:20 <tomberek> Twey: so, as an example:   next True = Just 1    next (Just 1) = False     would be a chain of two types using these type families:  Next Bool = Maybe Int   and Next (Maybe Int) = Bool
12:15:30 <cdk> Twey: X and Y are created by a function f :: A -> IO X
12:15:53 <aleksejs_> Cale, thanks!
12:16:16 <Twey> tomberek: I get what you're doing, I'm just not sure why you're doing it
12:16:23 <cdk> I'm trying to implement actors in haskell. My A is an actor system, and it has two child actors, a usr and sys guardian (like Akka). I can only create those usr and sys guardians from an already available actorsystem
12:16:32 <Twey> cdk: Then you do need MonadFix, yes
12:16:45 <Cale> cdk: Just use rec notation
12:17:33 <quidnunc> Why can I build lib+patchedsublib in a sandbox but not exec+lib+patchedsublib?
12:17:33 <tomberek> Cale: this structure could abstract many structures.  So a standard List would have a chain of 1. A simple graph would have a chain of 2 (nodes edges). etc.
12:17:43 <Cale> cdk: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#recursive-do-notation
12:18:05 <Cale> tomberek: ?????
12:18:14 <tomberek> Cale: yes, some handwaving going on
12:19:21 <edwardk> Cale: 5 question marks? congratulations on finding a symbol that isn't a lens operator!
12:19:29 <Cale> edwardk: lol
12:19:47 <Twey> Haha
12:19:53 <Twey> ‘Yet’
12:20:08 <edwardk> We'll have to fix that in the next release
12:20:20 <ChongLi> edwardk: I've been thoroughly enjoying those Bob Harper lectures
12:20:27 <edwardk> i'm glad.
12:20:31 <Twey> ChongLi: The HoTT ones?
12:20:32 <ChongLi> though I've struggled to follow at times
12:20:38 <ChongLi> Twey: yeah
12:20:46 <edwardk> despite his opinion on haskell he really does have a lot of good stuff to say
12:20:55 <tomberek> Cale: edwardk: As you traverse a list, the element type remains the same. As you traverse a graph with edges, the types alternate. You can imagine some other structures where there are more types that cycle through. So I wanted to try to express that there is a cycle in a sequence of applications of a type family.
12:20:55 <Twey> He doesn't like Haskell?
12:20:57 <aleksejs_> http://vpaste.net/br04E what should I add, to make this work?
12:21:07 <ChongLi> haha, we had a big argument last night about Bob's opinion of Haskell
12:21:36 <ChongLi> Twey: he's an SML guy
12:21:59 <edwardk> Twey: http://existentialtype.wordpress.com/2011/04/24/the-real-point-of-laziness/
12:22:04 <Cale> tomberek: That sounds like something which is better left to a dependently typed language.
12:22:10 <tomberek> Cale: agreed
12:22:17 <Cale> tomberek: I'm not even sure how you'd really use that information
12:22:20 <tomberek> Cale: I'm not sure if Haskell is dependy enough yet
12:22:37 <exicer> I'm trying to use Aeson to parse some json returned by a REST interface, where the json keys are upper case. I tried to solve this problem like so: http://lpaste.net/98384 but it does not work.
12:22:44 <exicer> Can anyone point me in the right direction ?
12:22:52 <tomberek> Cale: to make it arbitrarily long, but perhaps I can say chains of length 1,2 or 3.
12:22:57 <Cale> tomberek: To be honest, I could probably find a way to express it using type level naturals
12:23:02 <Cale> But meh, why?
12:23:08 <ChongLi> edwardk: he also doesn't like how Haskell does exceptions
12:23:22 <edwardk> that is fixed in 7.8
12:23:24 <Cale> Even once you define this, how the heck are you even going to put it to use?
12:23:26 <tomberek> Cale: I don't have an application, curiosity right now.
12:23:50 <Cale> I don't see a case where it would ever make your life any easier
12:24:04 <Cale> than just substituting out the definitions at each point in the cycle
12:24:08 <ChongLi> edwardk: also, what's Bob's deal with the "paucity of types" thing?
12:24:13 <edwardk> which, fwiw, caused lens no end of trouble.
12:24:26 <ChongLi> is it about bottom inhabiting your Nat type?
12:24:34 <tomberek> Cale: so you'd use a type-level iterateN? type Iter f n a = Iter f (Decc n) (f a)  or something?
12:24:52 <edwardk> ChongLi: he has a case about how bottoms "dont inhabit your types in ML" which I personally find less than satisfying
12:25:04 <Cale> lol
12:25:11 <Cale> edwardk: Of course they still do
12:25:23 <Cale> It's just that your constructors are all strict
12:25:25 <edwardk> Cale: hence less than satisfying ;)
12:25:40 <Cale> They don't inhabit your types in Coq
12:25:43 <ChongLi> edwardk: can't you claim some nonterminating expression is a Nat in ML?
12:25:44 <dolio> I realized a while back that ML needs two semantics for types.
12:25:45 <aleksejs_> anyone?
12:25:46 <tomberek> exicer: what problems do you get?
12:25:51 <dolio> One for values and one for expressions.
12:26:05 <exicer> tomberek: I posted the output at the bottom of the paste
12:26:18 <dolio> Which kind of makes things complicated.
12:26:19 <ChongLi> or is it that such an expression would cause an infinite loop immediately when the program starts?
12:26:26 <ChongLi> (assuming it's at the top level)
12:26:36 <Cale> aleksejs_: It might help if you would explain what the problem is?
12:27:07 <Lethalman> mh but gloss is not 3d
12:27:10 <Lethalman> it's a 2d canvas :(
12:27:14 <Lethalman> I need the depth also
12:27:20 <Lethalman> is there something as simple as gloss with depth?
12:27:27 <exicer> tomberek: Admitedly I have never used aeson before, so I could be doing something really stupid
12:27:27 <dolio> Of course, Bob doesn't care about denotational semantics at all.
12:27:36 <joejev> why does (<.>) a b = sum $ zipWith (*) a b work; however (<.>) = sum . zipWith (*)  does not
12:27:46 <aleksejs_> it shows Ambiguous type variable: http://vpaste.net/CiCMR
12:27:59 <ChongLi> dolio: no? what's the basis for his book PFPL then?
12:28:12 <Lethalman> not-gloss maybe
12:28:19 <tomberek> exicer: did you try without the space and uppercase first?
12:28:19 <dolio> I haven't read it. Probably operational semantics, though.
12:28:27 <Cale> aleksejs_: btw, that isPent looks really flaky
12:28:31 <ChongLi> dolio: http://www.cs.cmu.edu/~rwh/plbook/book.pdf
12:28:33 <joejev> it is typed (<.>) :: [Int] -> [Int] -> Int
12:28:42 <dolio> I still haven't read it.
12:28:44 <Cale> aleksejs_: Testing whether a floating point number is 0 is almost meaningless.
12:29:03 <Cale> aleksejs_: Though I guess you could use Rational
12:29:07 <bennofs> In conduit, awaitForever yield =$= b should be equal to b, right?
12:29:11 <exicer> tomberek: Yeah, that works fine
12:29:30 <johnw> bennofs: I believe so, yes
12:29:37 <aleksejs_> Cale, I need to check there that result of equation is integer
12:29:50 <Cale> aleksejs_: Okay, your problem is that no numeric type is both Floating and Integral
12:30:04 <Cale> You've left out some numeric conversions
12:30:16 <Cale> You're using div, which is an operation only for Integral numeric types
12:30:27 <Cale> But you're also using / and 0.5 and such
12:30:37 <Cale> which are things only available for fractional types
12:31:08 <quidnunc> Are cabal questions okay here?
12:31:14 <Cale> yes
12:31:40 <aleksejs_> Cale, so, do I need to convert n to fractional in isPent?
12:31:55 <Cale> aleksejs_: oh, and you're using sqrt, which is only for Floating types, which means you can't use Rational
12:32:02 <Cale> What are you trying to do?
12:32:55 <aleksejs_> Cale, http://projecteuler.net/problem=44 isPent is the opposite to n(3n-1)/2
12:33:51 <Cale> Well, first of all, I think you solved for n incorrectly.
12:34:03 <quidnunc> Cale: I'm trying to compile a program that uses a lib which depends on another patched lib. I can compile lib+patchedsublib using a sandbox but cabal install doesn't seem to want to use the patched lib when compiling prog+lib+patchedsublib. Is there something special I need to do in the latter case?
12:34:31 <aleksejs_> Cale, I've checked it on 145, it returned True
12:34:44 <Cale> oh, no
12:35:03 <Cale> You're okay, it's equivalent :)
12:35:26 <tomberek> exicer: i think fieldLabelModifer works the other way around
12:36:05 <tomberek> yeah
12:36:13 <Cale> okay, so let's start with another form of the solution, if p = n(3n - 1)/2, then n = 1/6 (1 + sqrt(1 + 24 p))
12:36:23 <exicer> tomberek: How do you mean?
12:36:47 <Cale> aleksejs_: So, in particular, in order for this to be the case, 1 + 24 p had better be a perfect square
12:36:57 <tomberek> exicer: try something like data Test = Test { _StatusCode :: Int} and then fieldLabelModifier = drop 1
12:37:17 <Cale> and in addition to that, the square root (after having checked that it's a perfect square), must be congruent to 5 modulo 6
12:37:23 <tomberek> the function translates the record name, not the ByteString
12:37:31 <Cale> (because when we add 1 to it, we'd better get something divisible by 6
12:37:33 <Cale> )
12:37:35 <exicer> tomberek: Ohhhh
12:37:49 <tomberek> that should help ya out
12:37:50 <exicer> tomberek: That actually makes way more sense, will give it a go
12:37:58 <tomberek> exicer: just tested it
12:39:03 <Cale> aleksejs_: You shouldn't bother computing an approximation of (1 + sqrt(1 + 24 p)) / 6, rather, you should test these number theoretical properties
12:39:22 <exicer> tomberek: It works for capitalisation.. I'm not sure how to deal with spaces, though
12:40:00 <tomberek> exicer: use a replace function
12:40:22 <Cale> aleksejs_: If you want to make your life easy, you might find it nice to use the exactSquareRoot function in the arithmoi package:  exactSquareRoot :: Integral a => a -> Maybe a
12:40:32 <tomberek> exicer: actually, look at constructorTagModifier
12:41:03 <Cale> exactSquareRoot n produces Just r when r*r = n, and Nothing, if no such r exists.
12:41:22 <tomberek> use your original functions, but use constructorTagModifier instead of fieldlabel
12:41:47 <exicer> tomberek: I had actually tried that :s
12:41:56 <exicer> tomberek: I'll give it another go, perhaps I changed something
12:43:54 <Twey> edwardk: Looks like he ultimately agreed with Lennart on that one.  He doesn't seem to have much else positive to say about Haskell, though.
12:43:58 <tomberek> that might be for encoding
12:44:13 <exicer> tomberek: Yeah, it doesn't seem to work even if there is no space
12:44:20 <exicer> Hmm
12:44:28 <ChongLi> Twey: he agreed, but not on his blog
12:44:32 <ChongLi> it was on Lennart's :)
12:44:34 <edwardk> Twey: I think it was more that he evoked a stronger reaction than he expected and decided to pick a fight another day. ;)
12:45:01 <tomberek> exicer: then use __ for space and run a replacement funciton
12:45:09 <ChongLi> I wonder *why* he feels that way?
12:45:14 <tomberek> _Status__Code
12:45:24 <ChongLi> is it because Haskell's more popular than SML and he thinks it's an injustice?
12:46:12 <exicer> tomberek: Yeah, I suppose that will work. It is a bit frustraiting though, there must be a way to do it the other way around!
12:46:28 <kristof> ChongLi: Are you still talking about Harper? :P
12:46:52 <SwineFlu> Anyone here built a web application in Haskell?
12:47:15 <ChongLi> kristof: hahaha yeah
12:47:35 <kristof> SwineFlu: No, but please look up Mighty. The magic of functional programming and immutable structures led to the development of a web server that scales like nobody's business
12:48:46 <tomberek> exicer: It's the space that's messing it up to be ugly
12:48:46 <tippenein> kristof: link? I only see Warp server
12:49:05 <kristof> tippenein: Warp/Mighty I don't know the difference
12:49:19 <exicer> tomberek: Yeah.. sadly I have no control over this JSON :(
12:49:22 <tippenein> oh, they're the same?
12:49:44 <pfurla> any ideas how I make unicode symbols work with Sublime Haskell?
12:50:42 <ChongLi> kristof: mighty's a bit of a generic word
12:50:44 <ChongLi> do you have a link?
12:51:17 <tippenein> ChongLi: I think Mighty == Warp ?
12:51:34 <tippenein> mighttpd perhaps
12:52:26 <kristof> http://www.yesodweb.com/blog/2012/10/measuring-warp ChongLi, second graphic is what I'm referring to
12:52:33 <kristof> Look at that sucker beat Nginx! SUCK IT!
12:52:53 <tomberek> exicer: use _Status'Code?
12:53:02 <tomberek> ugly as well
12:53:31 <roconnor> why have exceptions been fixed in 7.8?
12:54:06 <Twey> ChongLi: I agree with most of his points; lazy evaluation certainly has its issues.  But in my experience people (especially mathematical types) tend to value the code reuse and equational reasoning over all else, so I'm a bit surprised by it.
12:54:14 <bennofs> roconnor: Typeable is no more user-definable, so nobody can lie
12:54:32 <ChongLi> Twey: yeah, I would've thought so too
12:54:38 <ChongLi> but he hates equational reasoning
12:54:41 <ChongLi> and prefers proofs
12:55:36 <kristof> So much REASONING in this channel
12:55:50 <ChongLi> kristof: isn't that a microbenchmark?
12:55:50 <tomberek> Cale: (I know this is probably for no end-result, it's more of an exercise for me) what's a good way to start to encode my "chain of types" idea?
12:56:08 <ChongLi> 100k req/s
12:56:09 <kristof> ChongLi: 100,000 concurrent connections is not a microbenchmark.
12:56:16 <kristof> concurrent requests I mean
12:56:25 <ChongLi> no, what I mean by micro is this
12:56:33 <ChongLi> what exactly are those requests doing?
12:56:41 <bennofs> Why does this let go = await >>= maybe (leftover 4) (\x -> yield x >> go) in CL.sourceList [1,2,3] $= go $$ awaitForever (liftIO . print)
12:56:49 <bennofs> only print the numbers [1,2,3] ?
12:57:05 <Cale> tomberek: Figure out how to compute mod with type level nats.
12:57:08 <ChongLi> it looks to me like it's just a ping-pong type of thing
12:57:47 <bennofs> Oh, I never yield the 4 downstream ... :P
12:57:49 <ChongLi> which doesn't bear any resemblence to a real server, IMO
12:57:49 <kristof> ChongLi: It doesn't matter whatever the requests are doing, they're still requests and they all have to be processed by request handeling code. This is the standard way to do this sort of thing
12:58:32 <ChongLi> yeah, I get that the application side of things is outside the scope of the web server
12:59:03 <ChongLi> it's just that I'd like to know what overall factor this has on a big application that does a lot of IO and database work etc.
12:59:14 <ChongLi> is it even the bottleneck?
12:59:30 <Twey> What happened to Parallel Haskell, by the way?
12:59:35 <exicer> tomberek: Yeah :(. I'm diving into the docs. This must be a commonish thing for people to do!
12:59:37 <ChongLi> DPH?
12:59:51 <ChongLi> http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell
12:59:53 <Twey> No, pH — leniently-evaluated Haskell
12:59:59 <ChongLi> oh, hmm
13:00:02 <ChongLi> never heard of it
13:00:30 <Twey> At least, I think it was a separate project from DPH
13:00:35 <ChongLi> I'd guess that the problem with doing implicit parallelism all over the place would have major granularity issues
13:00:43 <ChongLi> would be, rather
13:03:26 <Walther> For the fun part, here's a version of the Dawkins' weasel that someone has cooked together in Haskell in mere 420 characters http://codegolf.stackexchange.com/a/18245
13:05:05 <Clint> is there any easy way to do substring matches with Data.CaseInsensitive?
13:05:11 <jfischoff> I just realized that the -ddump-core gcc asm syntax goes src, dst, unlike nasm :(
13:06:32 <augur_> hmm
13:06:44 <augur_> beta and eta are awfully adjuncty
13:07:20 <augur_> beta saying Elim.Intro => 1 and eta saying 1 => Intro.Elim
13:07:28 <augur_> roughly speaking
13:07:32 <augur_> i wonder if there's something deep here
13:09:41 <JuanDaugherty> deep as dodo or deep as in thought
13:15:01 <Lethalman> is there any gloss-like lib but for guis?
13:15:14 <Lethalman> that is, with a world -> GUI function which is computed at each step
13:15:44 <Lethalman> I like that style
13:18:03 <Twey> Lethalman: I don't think that's a great fit for a traditional GUI
13:18:34 <Twey> (I don't think it's great for drawing, either, actually: I'd much rather wrap it up in FRP)
13:20:43 <joelteon> So cabal run doesn't send the signals it receives to the process it's running
13:23:46 <aleksejs_> Cale, I've found a simple solution: http://vpaste.net/FoZzB
13:24:27 <Cale> aleksejs_: If that works, it's kind of a coincidence
13:24:45 <aleksejs_> it works, and is pretty fast
13:24:50 <aleksejs_> and answer is correct
13:24:57 <Cale> aleksejs_: (It'll sort of work, but eventually rounding errors will mean that isPent gives wrong answers)
13:24:58 <jfischoff> what assembler can compile the -ddump-asm dump?
13:27:06 <Cale> jfischoff: I'm not certain that the stuff that -ddump-asm prints is meant to be directly consumed by an assembler on its own.
13:27:24 <jfischoff> no I don't think it is
13:27:42 <Cale> jfischoff: You'd probably be better off using -keep-s-files
13:27:54 <jfischoff> ah
13:28:46 <Twey> jfischoff: Looks like gas to me
13:29:03 <jfischoff> the names are invalid though
13:29:13 <jfischoff> gcc barfs on ':'
13:29:46 <Twey> Ah
13:30:16 <jfischoff> Cale: do you know where the temp files go when you invoke the keep options?
13:30:46 <Cale> uh, I'm not sure, probably /tmp/ if not the current directory
13:30:54 <schell> i wrote a little writeup about rendering text in OpenGL using lispy's freetype2 bindings, if anyone is interested -> http://wiki.zyghost.com/Haskell%20font%20rendering%20with%20freetype2%20and%20opengl
13:31:08 <schell> very drafty at the moment
13:32:19 <ChongLi> schell: very nice, thanks
13:32:26 <schell> :)
13:33:21 <ChongLi> schell: might also want a string version of loadCharacter
13:33:43 <schell> ChongLi: that's the next step
13:33:54 <schell> ChongLi: or to build an entire font atlas
13:34:06 <ChongLi> doing kerning and all that jazz is not a good idea for OpenGL
13:34:17 <schell> no? why is that?
13:34:25 <ChongLi> because it's very complicated
13:34:26 <schell> (i don't know exactly what kerning is)
13:34:30 <jfischoff> Cale: I'm an idiot, it was in the same directory :p
13:34:37 <ChongLi> kerning is the inter-character spacing
13:34:46 <schell> ah - right
13:34:52 <ChongLi> there's also tracking, baseline shift and a bunch of other stuff
13:35:00 <ChongLi> left, right and justify
13:35:02 <schell> freetype has metrics for each glyph you can use for that
13:35:03 <ChongLi> tons of stuff
13:35:16 <schell> I'm not sure how complete it is though
13:35:23 <ChongLi> better to just get freetype to give you a big texture of your paragraph of text
13:36:42 <schell> what if it's 1000 loc you'd like to render?
13:37:09 <ChongLi> schell: it can be split into tiles
13:37:19 <Yaniel> or render N lines at a time
13:38:00 <schell> lots of things to think about
13:38:58 <ChongLi> it'd be a lot of work to implement your own WYSIWYG word processor with freetype and opengl
13:39:36 <ChongLi> freetype2 seems to be very low level
13:40:23 <Yaniel> yep
13:40:28 <ChongLi> hmm, and it looks like it doesn't do subpixel anti-aliasing
13:40:36 <Yaniel> it does IIRC
13:40:39 <Yaniel> optionally
13:40:59 <schell> it does anti-aliasing, but I don't know about sub-pixel...
13:41:01 <Yaniel> anyway I wouldn't want to make a word processor with opengl
13:41:29 <schell> it is however the standard for iOS and Android font rendering according to their site...
13:41:31 <ChongLi> Yaniel: well, imagine making a whole GUI framework on top of opengl
13:42:13 <WraithM> Is the KDE plot removed from criterion?
13:42:24 <qrada> Criterion.Main is dope
13:42:24 <WraithM> (version 0.8)
13:42:30 <schell> ChongLi: I'd like to do both of those things, but that's a pipe dream
13:42:49 <ChongLi> schell: with FRP!
13:42:51 <ChongLi> of course
13:43:03 <schell> ChongLi: I haven't gotten that far, yet
13:43:11 <schell> FRP is a little daunting to me atm
13:43:26 <ChongLi> schell: ahhh
13:43:36 <ChongLi> I think a bunch of the FRP libs are too complicated
13:43:46 <ChongLi> NetWire is much simpler
13:44:05 <ChongLi> http://hub.darcs.net/ertes/netwire
13:44:09 <schell> ChongLi: I've heard that's the one to start with for games
13:44:29 <ChongLi> schell: yeah, definitely
13:44:41 <ChongLi> it's what I'm working with
13:45:00 <ChongLi> I plan to build a nice wrapper around GLFW
13:45:12 <ChongLi> to make it easy to work with netwire
13:45:16 <joneshf-laptop> what is :< ?
13:45:24 <ChongLi> :t (:<)
13:45:25 <lambdabot>     Not in scope: data constructor `:<'
13:45:25 <lambdabot>     Perhaps you meant one of these:
13:45:25 <lambdabot>       `Seq.:<' (imported from Data.Sequence),
13:45:35 <ChongLi> :t (Seq.:<)
13:45:35 <lambdabot> a -> Seq.Seq a -> Seq.ViewL a
13:45:57 <qrada> someone on 'haskellcast' was mentioning reading the 'asm' to really learn haskell.. anyone do anything like that, or know what he's referring too.. i don't really see my 'funcs' when i objdump -D, so maybe people look at intermediary llvm code or something?
13:46:15 <ChongLi> > let foo = Seq.fromList [1..10] in Seq.viewl foo
13:46:17 <lambdabot>  1 :< fromList [2,3,4,5,6,7,8,9,10]
13:46:23 <joneshf-laptop> ah
13:46:26 <joneshf-laptop> ChongLi, thanks
13:46:34 <ChongLi> joneshf-laptop: no prob
13:47:01 <mekeor> is it possible that a program "foo" opens a REPL when i type some "pipe | foo" ?
13:47:17 <jfischoff> qrada: looking at the asm ghc generates will not help you learn Haskell
13:47:42 <ChongLi> Haskell has a language model of computation
13:47:46 <qrada> ya i dno what he was talking about, but he seemed very skilled
13:47:48 <jfischoff> he probably meant Core, but I would still not recommend it
13:47:56 <qrada> ah
13:47:59 <qrada> ya, core
13:48:04 <qrada> that's what he was talking about
13:48:55 <Aetherspawn> qrada: I dont recommend looking at that
13:49:19 <Aetherspawn> I'm a reverse engineer of about 2 years and I have a hard time reading the nonsense GHC generates
13:49:21 <Aetherspawn> ;__;
13:49:37 <qrada> ha, cool thanks
13:49:43 <jfischoff> You look at core and asm if you are writing a high performance library and you like pain
13:49:51 <Aetherspawn> You'd look at the core
13:49:59 <Aetherspawn> and rarely, if you're working on GHC, the asm
13:50:04 <Aetherspawn> although the LLIR might be easier to read
13:50:34 <jfischoff> i'm looking at asm no but just out of curiosity
13:50:54 <Aetherspawn> If your core is up to scratch, and its generated "bad" ASM, thats probably worth reporting as a bug
13:51:00 <qrada> i like teh gcc -S
13:51:13 <qrada> so maybe id enjoy it.. but ya ill check into core then
13:52:31 <jfischoff> the asm that is generated is not like the asm from c
13:53:40 <qrada> ya that's what i was wondering
13:53:55 <qrada> imagine it's much more 'obfuscated' , dno tho, was just wondering
13:58:30 <kammerer> I want to parse x86 asm using Parsec. I'm a beginner and not very sure how to lay out my data types
13:59:57 <c_wraith> That's not going to handle self-modifying code
14:00:34 <Aetherspawn> qrada: its just hard to follow because of PAPs, laziness, majority of tailcalls etc
14:00:54 <Aetherspawn> and lots of calls into the runtime, which, if you don't know much about, can almost be magical.
14:00:55 <qrada> ive just started adding criterion.main benchmarking to my haskell exercises.. would it make any sense that my foldl performs better than 'last', for example: last [1..10000] vs last_fold lst@(l:ls) = foldl (\a b -> b) l lst, for the same sized list
14:01:10 <qrada> it outperforms by only a small amount, but every time it does
14:01:44 <qrada> Aetherspawn: ya i was hoping to really see how it gets laid out in machine code, so i can understand it even better.. but i dno.. ill trust you guys for now and stick with the code
14:02:00 <qrada> lazyness/strict/tailcalls in asm
14:02:14 <Aetherspawn> qrada: are you running the list one second?
14:02:28 <Aetherspawn> If you're running it second, it could be perfoming better because it's in the CPU cache.
14:02:34 <qrada> for example, i can write some recursive func in C, gcc -S it, then.. I can run gcc -O2 -S and see exactly how they differ.. which reveals alot
14:02:43 <qrada> Aetherspawn: nah, foldl one is after
14:03:20 <qrada> ill check data.list source maybe itll reveal something
14:03:23 <Aetherspawn> Well, here's a good exercise
14:03:27 <Aetherspawn> why not look at the core
14:03:39 <qrada> ya i dont know how to do that yet im going to look it up in a sec
14:03:50 <Aetherspawn> You may just discover some kind of fusion or eta reduction or something being performed.
14:03:52 <qrada> i still dont know how to 'look at the core', i imagine it's some intermediary file?
14:03:56 <qrada> ya
14:04:04 <Aetherspawn> -ddump-simpl
14:04:31 <qrada> :F thanks!
14:06:15 <TallerGhostWalt> I am feeling cabal hell a little more accutely lately.  Distributed-Process using the latest version of Text, and Attoparsec seemed a little premature!
14:07:03 <Aetherspawn> I dont have problems with cabal usually
14:07:15 <Aetherspawn> but when I started installing crypto packages I got thrown in hell almost immediately
14:07:30 <Aetherspawn> theres quite a few different "streams" of crypto packages on hackage
14:07:38 <Aetherspawn> and if you install more than 1 at the same time, it turns into a mess
14:07:51 <TallerGhostWalt> I am fighting a Data.Binary loop
14:08:32 <Aetherspawn> I would have thought cabal hell would be avoidable if cabal didn't delete each version of a package after installing it, if that makes sense
14:08:42 <Aetherspawn> not sure what it does at the moment, but I would have thought it's a problem easily solved.
14:09:08 <TallerGhostWalt> It is just so strange in a language dedicated to avoiding side effects to have so many in the package installer
14:09:31 <luca> ciaooo
14:09:36 <luca> !list
14:10:01 <Aetherspawn> haha
14:10:34 <TallerGhostWalt> I guess I will just install source for EVERY package I use.  geeze
14:11:07 <lllllllllllll> TallerGhostWalt, would cabal sandbox help?
14:12:05 <TallerGhostWalt> yeah it does, I mean I use it.  I have a prog I am trying to put into a distributed-process framework but it uses cassava for CSV. and MongoDB which means BSON.
14:12:26 <TallerGhostWalt> that means I need Binary 0.5.3 for dist-proc and 0.7+ for Bson
14:12:55 <TallerGhostWalt> so I got the dev version of dist-proc which uses binary 0.7+ but then bumped the text and attoparsec deps
14:13:00 <TallerGhostWalt> killing cassava!
14:14:04 <TallerGhostWalt> installing cassava source now to see if I can just update the deps and have it work.
14:15:33 <Ankhers> Can someone please explain how I can successfully install HP on OSX 10.9?
14:15:49 <Aetherspawn> Ankhers: use brew
14:16:01 <Aetherspawn> https://github.com/darinmorrison/homebrew-haskell
14:18:10 <qrada> Aetherspawn: ghc-core helps too.. nice
14:18:32 <bergmark> You may be able to get the normal HP to work if you configure GHC to always use cpphs as the preprocessor
14:18:33 <Aetherspawn> qrada: what did you find out?
14:18:45 <Aetherspawn> its easier to just use homebrew-haskell
14:18:48 <Aetherspawn> works out of the box for me
14:18:51 <Aetherspawn> I'm on mavericks
14:19:14 <qrada> nothing yet, :f im looking at List.lhs though.. last has a pattern match for [], so im thinking maybe that's what's doing it
14:19:19 <qrada> but im a noob so not sure
14:19:25 <qrada> my fold has no check for empty list etc
14:19:29 <qrada> (fold version, even)
14:20:15 <geekosaur> Ankhers: either homebrew or macports will work without extra silliness. macports doesn't even require you to grab a recipe from somewhere else
14:20:17 <qrada> i did a bunch of variations, the worst by far is last_nat_3 l = head $ reverse l
14:20:20 <qrada> lolol
14:21:16 <Ankhers> I'm not a fan of macports. I'm currently installing things via brew. Hopefully that works.
14:22:18 <qrada> win 2
14:33:08 <pingu> I'm writing a small library of inverters and flippers for arguments of functions, this isn't duplicated work is it?
14:33:10 <pingu> Basically:
14:33:15 <pingu> invert3 :: (a -> b -> c -> d) -> c -> b -> a -> d
14:33:24 <pingu> flip3 :: (a -> b -> c -> d) -> c -> a -> b -> d
14:33:54 <pingu> I've found it useful a few times to do this specifically and I've never found a library to do it.
14:33:58 <monochrom> if there are 3 arguments, then there are 6 permutations. will you cover them all?
14:34:16 <pingu> monochrom: god no, you can compose to get what you like usually
14:34:31 <pingu> so, flip3 . flip3 gets you b -> a -> c -> d
14:34:32 <pingu> I think
14:34:44 <pingu> ad you can mix flip2s and flip4s in there too to put stuff where you like
14:35:16 <monochrom> yes, group theory tells you whether what you provide compose to cover all. do you already know group theory?
14:35:17 <pingu> It's actually pretty intuitive once you get it. I've found it very useful for writing FFI bindings
14:35:23 <pingu> monochrom: no
14:35:34 <monochrom> then learn group theory first.
14:36:05 <pingu> uh, no.
14:36:32 <enthropy> at some point writing out the lambda seems easier
14:37:48 <pingu> This maybe is a good example
14:37:50 <pingu> http://hackage.haskell.org/package/jack-bindings-0.1/docs/src/Sound-Jack-JackMonad.html
14:38:05 <pingu> if you search for flip
14:39:58 * hackagebot copr 1.0.0 - Haskell interface to the Fedora Copr system  http://hackage.haskell.org/package/copr-1.0.0 (RickyElrod)
14:42:45 <monochrom> you have seen a glimpse of group theory from sorting algorithms based on swapping two arbitrary positions at a time. it is true that by chaining a lot of those swaps, you can achieve any permutation you want.
14:44:03 <pingu> monochrom: Okay, thanks. That's useful to know.
14:44:06 <monochrom> it is also true that if you can only swap two adjacent positions, not two arbitrary positions, you can still achieve any permutation you want, but perhaps needing more swaps.
14:45:10 <dleedev> Hi, I just got around to getting a good grasp of Monads in haskell. Now I want to learn about Arrows. What's a good next step?
14:45:26 <monochrom> there are other funny schemes. one scheme says "reverse a segment of your choice at a time". for example "abcdefg -> abedcfg", I choose to reverse the "cde" segment this time.
14:46:02 <hpc> isn't there a sorting algorithm that does that?
14:46:17 <hpc> (or some famous problem about making such an algorithm fast or something)
14:47:08 <monochrom> yeah. it is a favourite programming contest question or computer science challenge question "what is the minimum number of segment-reverses to sort the following sequence"
14:48:44 <monochrom> another scheme similarly favourite in the same contests is "reverse a suffix of your choice at a time". it is usually depicted as "you have a stack of pancakes, you can reverse a top portion of the stack at a time"
14:49:48 <hpc> pancake sort is what i was remembering
14:50:27 <Mokosha> hi, I'm having a hard time figuring out how to initialize an RWS value
14:50:53 <monochrom> isn't combinatoric group theory exciting! :)
14:51:27 <hpc> i almost came up with a way of implementing the stack flipping operation in constant time
14:51:37 <monochrom> the type of runRWS informs you
14:51:44 <monochrom> @type runRWS
14:51:44 <lambdabot> RWS r w s a -> r -> s -> (a, s, w)
14:51:47 <hpc> could never figure out how to make seeking to the bottom of the stack work though
14:52:16 <monochrom> therefore, it is like: runRWS (your RWS program) (initial for the reader) (initial for the state)
14:52:46 <Mokosha> ah, ok I had that backwards in my head
14:52:47 <Mokosha> thanks
14:52:58 <maxiepoo> I never understood why they're in that order
14:53:26 <monochrom> you can use a pancake sorting combinator to obtain the order you want :)
14:53:29 <Cale> maxiepoo: It's because of the implementation. Also because of how you'd often end up using it.
14:54:00 <maxiepoo> Cale, wouldn't it be better for composition to have it be `r -> s -> RWS r w s a -> (a, s, w)`
14:54:17 <monochrom> oh, sometimes I like that order too
14:54:34 <hpc> with-monad instead of run-monad
14:54:35 <Cale> Occasionally, yeah
14:54:35 <monochrom> I like different orders on different days. it is impossible to please me
14:55:25 <Cale> maxiepoo: But often you want to use runRWS (sounds a bit funny because how often does anyone use RWS?), to implement some function and hide the fact that you're actually using it.
14:55:49 <copumpkin> what's a minimalist way to say "download this URL to this file" in Haskell?
14:55:53 <Cale> and the r and s would then perhaps be parameters of that function
14:56:14 <copumpkin> I guess I could run curl -O as a subprocess :P
14:56:19 <Cale> copumpkin: Use the download or download-curl package?
14:56:38 <Cale> (they're drop-in replacements for each other)
14:57:07 <copumpkin> hmm
14:57:10 <copumpkin> @hackage download
14:57:10 <lambdabot> http://hackage.haskell.org/package/download
14:57:12 <Cale> Er, I guess that doesn't save it as a file, I guess you'd use writeFile with that
14:57:20 <hpc> or something like simpleHTTP url >>= writeFile f
14:58:34 <hpc> there's always the question of how to deal with 404, 401, etc
14:59:08 <copumpkin> what's the advantage of download-curl over download?
14:59:10 <copumpkin> or vice versa?
14:59:13 <copumpkin> just pure haskell vs. binding?
14:59:23 <roconnor> is gcast safe?
14:59:30 <copumpkin> I assume -curl supports https
14:59:59 <roconnor> what if c is contravariant?
15:01:42 <monochrom> gcast is a downcast, when c is covariant, is that right?
15:02:05 <monochrom> and therefore an upcast, when c is contravariant, is that right? and therefore automatically safe, is that right?
15:04:43 <roconnor> hmm
15:04:57 * roconnor goes back to ignoring Typable for a while longer.
15:05:14 <ion> Typoable
15:05:28 <monochrom> there is some chance I am considering from a wrong angle altogether, so do be critical :)
15:05:54 <roconnor> no no
15:06:04 <roconnor> what you said kinda makes sense.
15:06:08 <monochrom> hehe
15:06:16 <roconnor> except I didn't think we had subtyping
15:06:27 <roconnor> and then I didn't understand cast
15:06:33 <roconnor> and then I didn't want to understand case
15:06:35 <roconnor> *cast
15:08:14 <dwcook> I want to implement this EDSL, but am unsure of the best way. https://gist.github.com/dwcook/8391901 I was thinking a transformer stack including StateT, ReaderT, and IO, but that seems like it might be overly complicated. Any suggestions?
15:08:50 <dwcook> hpc, thanks for your suggestion earlier.
15:11:08 <bergmark> dwcook: have you seen RWS?
15:11:30 <dwcook> Only glanced at it. You think that'd be helpful?
15:12:08 <bergmark> generally i find it useful to start out with it when i suspect i want different kinds of state, makes it easy to stick something in a Reader if you figure out you can
15:13:30 <dwcook> I already have a good idea of what should be mutable and what shouldn't though.
15:13:45 <dwcook> Oh, woops.
15:13:49 <dwcook> runAction has the wrong type, I think.
15:14:32 <bergmark> even if you're not using the writer i think RWS is nice
15:15:14 <dwcook> Okay. I'll give it a shot. Thanks.
15:15:18 <brokenzebra> crap
15:15:21 <brokenzebra> does,
15:15:39 <brokenzebra> \x -> \y -> \z -> x + y + z :: Float
15:15:48 <brokenzebra> isn't that an ambiguous parse?
15:16:06 <dwcook> Looks fine to me.
15:16:11 <dwcook> @type \x -> \y -> \z -> x + y + z :: Float
15:16:12 <lambdabot> Float -> Float -> Float -> Float
15:16:13 <brokenzebra> where does the :: get applied?
15:16:22 <alan1> hey, haskell beginner here, is there a function that can take a function and that functions output, and return that functions input?
15:16:30 <brokenzebra> :t \x -> \y -> \z -> (x + y + z :: Float)
15:16:31 <lambdabot> Float -> Float -> Float -> Float
15:16:39 <brokenzebra> :t \x -> \y -> (\z -> x + y + z :: Float)
15:16:41 <lambdabot> Float -> Float -> Float -> Float
15:16:45 <jle`> mm_freak: so i read over your Auto/Stream stuff from the other night and it seems pretty powerful. is it proper to say that netwire is just a fleshed out library dealing with machines and stuff like that? would i basically be doing the same "thing" if i wrote my entire program from scratch with Auto's?
15:16:52 <d3lxa> how can I override a lambda inside a field record and keeping the same restrictions of types? I only need to override fieldView of hiddenField in Yesod.Form.Fields, GHC complains about "HandlerSite m0 ~ HandlerSite m", any idea? thx
15:16:52 <jle`> alan1: hm that doesn't sound computable in general
15:17:02 <brokenzebra> christ nvm
15:17:34 <jle`> alan1: closest thing would be that if your input is finite you can check all possible inputs and stop when one matches...but that would require an Eq constraint on the output
15:17:54 <jle`> so in general no
15:20:03 * hackagebot hOpenPGP 0.11.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.11.1 (ClintAdams)
15:20:50 <tippenein> I'm having some problems with this HandsomeSoup example; specifically runX isn't found. cabal build complains about it missing, and doesn't like my import of Text.XML.HXT.Arrow
15:21:06 <Twisol> alan1: So, like, given a function that takes a key and a plaintext, and returns a ciphertext, you want something that will give you the key and the plaintext? ;)
15:21:14 <snizzo> Prog[SDecl (Id "i") (TArray (EInt 6) TInt)]  how can I access TInt from having a 't' variable containint TArray object?
15:21:25 <jle`> Twisol: well...he didn't say it had to be computable in reasonable time :P
15:21:36 <jle`> maybe millions or so years is ok for him
15:21:37 <Twisol> Heh, fair.
15:22:22 <jle`> if there was a fast one then he could jump into the bitcoin mining industry pretty handily
15:22:39 <jle`> also he could probably solve the collatz conjecture
15:22:44 <Twisol> probably.
15:23:19 <jle`> collatzTerminates :: Integer -> Bool
15:23:32 <jle`> find the result where it returns false
15:23:33 <jle`> :)
15:23:36 <jle`> *input
15:23:42 <Twisol> Well, that isn't even an invertible function
15:23:48 <Twisol> it isn't injective :)
15:23:59 <jle`> magic function is magic
15:24:08 <Twisol> I suppose, if the input space is enumerable, you could return a lazy list of matching inputs.
15:24:24 <jle`> oh yeah.
15:24:52 <jle`> in that case a proof of the collatz conjecture would be saying that his function returns an empty list
15:25:02 <jle`> brb going to win a millenium prize.
15:25:04 <Twisol> Which is the whole issue about the collatz conjecture in the first place.
15:26:21 <Cale> d3lxa: could you perhaps give a little more context? You should in general be able to replace a field with another value of the same type without any problems. Perhaps the type isn't actually the same?
15:27:56 <tippenein> "Could not find module `Text.XML.HXT.Core' It is a member of the hidden package `hxt-9.3.1.3'"
15:28:12 <d3lxa> Cale: I define a new field which has some constraint on a Monad m, but the lambda in the record has too, and GHC cannot prove that they are the same Monad
15:30:06 <Twey> tippenein: Sounds like you're using Cabal and didn't put hxt in your .cabal file
15:30:33 <nstdloop> I want my foldr helper function to have access to the index of the item in the list I'm working on
15:30:41 <nstdloop> how?
15:31:04 <Twey> nstdloop: Zip it with a list of indices first
15:31:14 <nstdloop> Twey: brilliant
15:31:41 <nstdloop> Just like (zip [1..] list)?
15:32:00 <Twey> I'd prefer zero-based indices, but sure
15:32:18 <nstdloop> Ah, I'm just printing a prompt to the user
15:32:27 <Twey> Okay
15:33:01 <jle`> is it safe to say that all fusion that will ever be done in the compilation process is reflected in the core output?
15:33:07 <jle`> and all inlining stuff etc.
15:33:24 <tippenein> Twey: hmm, I do have hxt under build-depends, but perhaps it's something else
15:33:51 <monochrom> yes, jle`
15:34:42 <jle`> if i wanted to say write a custom backend for haskell using haskell-src-exts or stuff like that, would it be a good idea to work from core? or should i work from the c--
15:34:52 <jle`> probably too vague of a question to have a helpful answer though
15:35:38 <jle`> i just thought it'd be easier to get the AST of core than of c--. but there are probably parsers out there.
15:36:16 <timmy_tofu> I want to take a UTF8 string, trim it down to a max number of bytes but also only trim it at a character boundary
15:36:44 <timmy_tofu> can anyone suggest a nicer way than this:
15:36:51 <timmy_tofu> (filter (/= UTF8.replacement_char)) . UTF8.toString . (BS.take count) . UTF8.fromString . (filter isPrint)
15:37:31 <geekosaur> define character boundary. do you care about combining chars?
15:37:53 <joelteon> well, that's an interesting problem
15:38:08 <timmy_tofu> character boundary meaning if I have 你好
15:38:14 <timmy_tofu> that's two characters and six bytes
15:38:21 <joelteon> sure
15:38:23 <timmy_tofu> if I wanted a maximum of five bytes
15:38:26 <joelteon> but what about combining characters
15:38:30 <joelteon> neither of those are
15:38:32 <timmy_tofu> I'd like just 妳 in the end
15:39:07 <joelteon> what if you have a ̀
15:39:18 <Twisol> Would a combining character be something like ¨ (alt-u on Mac) ?
15:39:22 <joelteon> my mistake
15:39:25 <joelteon> right, Twisol
15:39:29 <joelteon> as a separate character
15:39:33 <timmy_tofu> hmmm
15:39:39 <timmy_tofu> i'm not sure really
15:39:42 <Twisol> ¨ followed by o gives ö
15:39:51 <joelteon> why are you trimming it to a byte limit?
15:40:01 <Ralith> combining characters: ȭ
15:40:17 <timmy_tofu> i believe if i get a ¨ followed by an o, I'd like to leave it like that
15:40:28 <monochrom> I do not understand by what criterion 你好 is "trimmed" to 妳
15:40:31 <timmy_tofu> but, if the boundary happens to be between those two
15:40:36 <timmy_tofu> i think it's fine
15:40:55 <timmy_tofu> 你好 is trimmed to 你
15:41:03 <nooodl> monochrom: five byte maximum
15:41:03 <timmy_tofu> forgive the misgendered character
15:41:08 <monochrom> do you also "trim" 門口 to 問 ？
15:41:11 <nooodl> oh wait. hah
15:41:14 <geekosaur> also, how many characters is בְּּ?
15:41:30 <geekosaur> (mm, my client mangled that badly)
15:41:34 <joelteon> UTF-8: never as easy as you thought™
15:41:52 <geekosaur> two combiners, one is a modifier and another is a following vowel
15:41:54 <joelteon> s/UTF-8/Unicode/
15:42:13 <enthropy> dleedev: http://i.imgur.com/DqDIYkH.png
15:43:22 <timmy_tofu> i'm trimming it to a byte limit because it will be a bucket name on s3 eventually
15:43:45 <timmy_tofu> which allegedly can handle any unicode character in a bucket name, but the total bucket name limit is 1024 bytes
15:43:58 <joelteon> oh
15:44:01 <timmy_tofu> I could just hash it or something
15:44:05 <monochrom> ok, I don't know what to do with combining characters (combining code points?), but suppose they don't appear, then: decode utf-8 to Text. for i from length of Text downto 0 { decode Text[0..i] back to utf-8, if short enough, done }
15:44:06 <shachaf> geekosaur: The thing you wrote is four code points.
15:44:10 <timmy_tofu> but, I feel like thi sis doable
15:44:12 <shachaf> It has two U+05BCs.
15:44:41 <mm_freak> jle`: not quite the same thing…  there is one important difference between Auto and Wire, which makes the latter a lot more expressive
15:44:41 <geekosaur> interesting
15:45:02 <mm_freak> jle`: newtype Wire a b = Wire (a -> (Maybe b, Wire a b))
15:45:16 <mm_freak> jle`: notice the Maybe
15:45:29 <simukis_> monochrom: I'd probably s/i from length/i from min(length, 1024)/
15:46:08 <monochrom> micro-optimizations...
15:46:37 <monochrom> if you optimize, first optimize the dumbest point of my dumb algorithm first
15:46:43 <mm_freak> jle`: this allows you all kinds of new combinators and also makes an Alternative instance possible
15:47:01 <mm_freak> jle`: see for example the (-->) combinator
15:47:35 <mm_freak> jle`: another difference is that using the FRP.* subtree you get proper FRP, while the Control.* tree gives you the full abstraction
15:47:41 <Fuuzetsu> Where's that ‘ls contains a list files’ quote? I can't get lambdabot to spew it out.
15:47:51 <joelteon> @quote /bin/ls
15:47:51 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:48:22 <Fuuzetsu> oh, finally found it after trying ‘files’ like a billion times
15:48:26 <Fuuzetsu> thanks joelteon
15:48:34 <mm_freak> @quote files
15:48:35 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
15:48:35 <joelteon> sure
15:48:40 <joelteon> heh
15:48:46 <monochrom> lucky one, mm_freak :)
15:48:48 <mm_freak> ;)
15:48:52 <joelteon> ;)
15:49:35 <mm_freak> that wasn't luck…  i just deleted all the other quotes with 'files'
15:50:03 <joelteon> "so if I apply getLine to something, I get a String out?"
15:50:06 * hackagebot hOpenPGP 0.11.2 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.11.2 (ClintAdams)
15:50:31 <nstdloop> How does @quote work?
15:51:32 <mm_freak> @remember nstdloop How does @quote work?
15:51:32 <lambdabot> Done.
15:51:36 <mm_freak> @quote @quote
15:51:36 <lambdabot> monochrom says: * monochrom rubs @quote, and shachaf appears! he says, "what is your wish?"
15:51:37 <quidnunc> Anyone here use Docker?
15:51:49 <mm_freak> @quote nstdloop @quote
15:51:49 <lambdabot> nstdloop says: How does @quote work?
15:51:55 <nstdloop> gotcha
15:52:51 <shachaf> @forget nstdloop How does @quote work?
15:52:51 <lambdabot> Done.
15:53:59 <ion> @quote @quote
15:53:59 <lambdabot> Taral says: How do you add an @quote?
15:55:07 * hackagebot time-exts 1.1.3 - Efficient Timestamps  http://hackage.haskell.org/package/time-exts-1.1.3 (EnzoHaussecker)
16:12:29 <jle`> mm_freak: thanks :)
16:13:14 <jle`> mm_freak: so if i had the wire type from scratch and derived my own combinators for working with them, that would basically be re-implementing netwire?
16:13:19 <jle`> mm_freak: or is there more to the library fundamentally
16:13:30 <jle`> mm_freak: (just wondering what kind of concepts are included in the library)
16:16:06 <brokenzebra> recursion depth as a measure of intellect yeah
16:17:00 <Hafydd> What?
16:17:56 <mm_freak> jle`: you would be reimplementing netwire pretty much
16:18:02 <mm_freak> most likely a special case of it
16:18:13 <mm_freak> because the full Wire type does a bunch of other things as well
16:18:29 <mm_freak> like accumulation of time
16:21:26 <Twey> tippenein: Do you have the right version of hxt?
16:29:33 <ilmig_> @pl \x -> f x == 1
16:29:33 <lambdabot> (1 ==) . f
16:32:30 <kammerer> How do I fix this?     Ambiguous module name `Control.Monad.Trans':
16:32:30 <kammerer>       it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.1.2
16:32:39 <shachaf> Uninstall monads-tf.
16:32:58 <shachaf> Or hide it, or specify that you want to use mtl some other way.
16:33:20 <johnw> shachaf: How do you hide it?
16:33:25 <kammerer> I already read about ghc-pkg hide, is that the "recommended" way?
16:33:36 <shachaf> johnw: ghc-pkg hide monads-tf
16:33:40 <kammerer> I feel like this shouldn't happen at all
16:33:41 <shachaf> The recommendation depends on what you want.
16:33:41 <johnw> excellent, thanks
16:34:01 <shachaf> For example, why do you have monads-tf installed?
16:34:02 <kammerer> shachaf, not that I use Haskell excessively but I would like to break as few things as possible.
16:36:23 <sm> hiding is a good safe option that won't break installed things. If you really need both monads-tf and mtl exposed for new projects, you can use a cabal sandbox
16:37:16 <sm> these two are competing for the same namespace, relatively unusual in the haskell world
16:37:25 <kammerer> Thanks. I'll see if I ever need monads-tf
16:37:27 <dcoutts_> sm: that only really helps if you're using cabal to build your package, and if you're doing that then it wouldn't be a problem in the first place
16:38:05 <haasn> Can you still use PackageImports with hidden packages?
16:38:37 <sm> hmm, ok dcoutts. I had to do it the other day but I guess I wasn't building with cabal
16:39:04 <johnw> dcoutts_: I run into that error from hdevtools or using ghc to check syntax
16:39:08 <johnw> but never from cabal
16:39:23 <dcoutts_> because cabal only exposes the direct deps
16:39:42 <dcoutts_> so you'd never have the problem unless you depended directly on both
16:39:48 <dcoutts_> which you wouldn't
16:39:54 <dcoutts_> as they're alternatives
16:41:49 <kammerer> I'm trying to use msgpack in Haskell. Does anyone know why the (un)pack(to/from)String functions are not in scope? (sample: https://github.com/msgpack/msgpack-haskell/blob/master/msgpack/test/Monad.hs)
16:43:20 <lightquake> kammerer: it doesn't look like those functions exist in the latest version of msgpack
16:43:36 <kammerer> I see. I'll check the docs
16:43:37 <lightquake> you have pack :: Packable a => a -> ByteString and unpack :: (Unpackable a, IsByteString s) => s -> a
16:44:21 <haasn> I checked, you cannot
16:44:40 <haasn> (re: hidden packages)
16:46:17 <kammerer> lightquake, thanks. These work like a charm
16:46:51 <joelteon> what's the syntax of an unboxed word literal?
16:47:00 <pingu> Word#
16:47:35 <pingu> http://www.haskell.org/ghc/docs/6.6/html/libraries/base/GHC-Prim.html
16:47:49 <joelteon> that still doesn't tell me what the syntax is
16:48:25 <pingu> What do you mean by 'syntax'? You want to create an unboxed word?
16:48:31 <joelteon> oh, it's ##
16:48:38 <joelteon> yes
16:48:39 <pingu> With MagicHash, yes.
16:49:47 <pingu> Uh, here:
16:49:49 <pingu> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/syntax-extns.html#magic-hash
16:51:02 <monochrom> 7.0.1 is really old. we're at 7.6.3
16:51:40 <monochrom> 6.6 is, like, when I was a kid
16:52:18 <pingu> ## Is not likely to change
16:52:38 <monochrom> you never know
16:53:49 <kazagistar> am I not allowed to use guards and pattern matching at the same time or something? I'm not sure what I am doing exactly http://lpaste.net/98389
16:54:36 <erisco> is there a function to left or right pad strings?
16:54:40 <monochrom> picker (target:targets) ((index, value):enumerated)  you need those parentheses
16:55:18 <monochrom> | otherwise       = picker (target:targets) enumerated
16:55:52 <kammerer> msgpack once more: "unpack/tryUnpack x" (with x :: ByteString) always returns the same result for subsequent calls, how would I make it "seek forward" to return the next type? there's the type class Unpackable with function get but I'm not quite sure how to use it.
16:55:56 <Rarrikins> erisco: take
16:56:35 <Rarrikins> erisco: Never mind, that will truncate.
16:56:37 <erisco> Rarrikins, well that may be part but not a complete definition
16:56:43 <kazagistar> monochrom: right, thanks, still getting the hang of the syntax and such
16:56:55 <pingu> kammerer: might need a code example there, your question kind of fails to parse
16:57:03 <verement> :t justifyLeft
16:57:04 <lambdabot> Not in scope: `justifyLeft'
16:57:07 <pingu> unpack should be idempotent
16:57:11 <verement> :t Data.Text.justifyLeft
16:57:11 <lambdabot> Int -> Char -> Data.Text.Internal.Text -> Data.Text.Internal.Text
16:57:55 <Rarrikins> > let rightJust n "" = repeat n ' '; rightJust n (x:xs) = x:rightJust (n - 1) xs in rightJust 20 "Hello!"
16:57:56 <lambdabot>  Couldn't match expected type `GHC.Types.Char -> [GHC.Types.Char]'
16:57:56 <lambdabot>              with actual type `[a0]'
16:58:33 <Rarrikins> > let rightJust n "" = replicate n ' '; rightJust n (x:xs) = x:rightJust (n - 1) xs in rightJust 20 "Hello!"
16:58:33 <lambdabot>  "Hello!              "
16:58:50 <verement> > Data.Text.justifyRight 20 ' ' "Hello"
16:58:50 <lambdabot>  Not in scope: `Data.Text.justifyRight'
16:59:47 <kammerer> pingu, http://lpaste.net/6836169857289945088
17:00:12 <kammerer> also: http://hackage.haskell.org/package/msgpack-0.7.2.5/docs/Data-MessagePack-Unpack.html the type class I talked about
17:01:09 <Rarrikins> > let leftJust n xs = f (length xs - n) xs where f n xs = if n <= 0 then xs else ' ':f (n - 1) xs in leftJust 20 "Hello!"
17:01:10 <lambdabot>  "Hello!"
17:01:13 <Rarrikins> Bleh
17:01:23 <erisco> I can define the function myself I was just wondering if there was an already made definition
17:01:35 <erisco> padRight n s = s ++ replicate (n - length s) ' ' -- this is fine
17:01:37 <pingu> kammerer: that looks like it behaves exactly as it should, and the only way that it could.
17:01:49 <Rarrikins> > let leftJust n xs = f (n - length xs) xs where f n xs = if n <= 0 then xs else ' ':f (n - 1) xs in leftJust 20 "Hello!"
17:01:50 <lambdabot>  "              Hello!"
17:01:52 <Rarrikins> Yay
17:02:13 <pingu> kammerer: You are unpacking one serialized (Int, Int), from one ByteString
17:02:17 <erisco> > let padRight n s = s ++ replicate (n - length s) ' ' in padRight 10 "hello"
17:02:18 <lambdabot>  "hello     "
17:02:20 <pingu> you can only do that once for each given serialized object
17:02:37 <pingu> if you want multiple, you want to serialize as [(Int, Int)], then deserialize the whole lot.
17:03:38 <johnw> > let n = 20; xs = "John" in under reversed (take n) $ replicate n ' ' ++ xs
17:03:40 <lambdabot>  "                John"
17:03:45 <kammerer> how would I handle run-length encoding? the ByteString later contains something like: NumberOfStructs | Struct1 | Struct2 | ... with StructN being a more or less complex object
17:04:08 <pingu> kammerer: you want to have msgpack handle that for you.
17:05:30 <pingu> kammerer: It kind of sounds like you're asking too much of msgpack though, It won't serialize your complex haskell objects without much hackery.
17:05:41 <pingu> Is there any reason you can't use Data.Serialize?
17:07:06 <Fuuzetsu> Hey, I just tried updating the Haddock docs on http://www.haskell.org/haddock/ but it seems that the documentation link points to a whole different place instead inside the Haddock directory which I do have access to, what gives?
17:07:16 <pingu> kammerer: Though I'm not sure even that will help you. Basically, if you want to serialize your own custom objects, I'm pretty sure you are going to need to tell whatever library exactly how.
17:08:18 <Fuuzetsu> I would have imagined it'd be pointing to http://www.haskell.org/haddock/doc/html/index.html and not http://lambda.haskell.org/platform/doc/current/ghc-doc/haddock/index.html
17:08:51 <kammerer> pingu: I'm serializing data from Python
17:09:03 <kammerer> thus no Data.Serialize
17:09:19 <pingu> kammerer: Right, and that data is list of int tuples? like [(Int, Int)]
17:09:54 <kammerer> not everything is. there's binary data in between (in the RLE encoded blocks)
17:10:36 <pingu> kammerer: so what's the actual type inside the bytestring you're trying to decode?
17:10:48 <pingu> Because msgpack only has so many avaliable data types
17:11:58 <pingu> kammerer: perhaps if you could show me the python code that generates the binary blob I will be more helpful
17:12:00 <kammerer> I'm not sure how msgpack encodes it but I guess it's a tuple. like (Int, Int, ByteString, Int, ByteString, ...) where ByteString is used for binary data and the number of (Int, ByteString) elements is dynamic and depends on the value of the first iinteger parsed
17:13:01 <pingu> kammerer: oh, ouch :\
17:13:08 <kammerer> pingu, basically it's something like "data = packb(numberOfItems); for i in items: data += packb(i)".
17:13:15 <pingu> kammerer: So it's a non-homogeneous array
17:13:39 <kammerer> it's late, excuse the lack of concise problem descriptions :)
17:13:46 <kammerer> yes, that's the correct word
17:13:49 <pingu> kammerer: can you chance that code generating it? 'cause that's a little bit crack.
17:14:04 <pingu> it'd be a lot easier if you could
17:14:38 <pingu> Otherwise, if it's fixed length, you'll have to split the string up at regular intervals.
17:14:38 <kammerer> yes I can
17:14:52 <pingu> but if the msgpack format ever changes you're screwed.
17:15:04 <kammerer> it's not fixed, but I could try serializing it as a list in python
17:15:13 <pingu> kammerer: yes, that's what you want.
17:15:26 <pingu> Otherwise you don't know how long each tuple is.
17:15:31 <kammerer> well thanks so far. I'll try that tomorrow :)
17:15:59 <pingu> kammerer: cool, for future reference, you can't just append serialized objects (as a general rule)
17:16:07 <pingu> as in, data += packb(i)
17:16:39 <pingu> you're basically generating your own format by doing that, your own format that has no way of knowing how long each element is.
17:17:16 <kammerer> thanks. this makes perfectly sense now
17:17:24 <kammerer> pingu++
17:38:01 <joelteon> haskell-src-exts supports XML element patterns. does anybody know what that's about?
17:42:14 <bambams> Haskell is cool. >:)
17:44:56 <bambams> *hits curried functions* *head explodes*
17:46:56 <mkscrg> banging my head against transformers: if you have a ReaderT somewhere in the stack, how do you lift a function over ReaderT to the top-level monad?
17:47:15 <mkscrg> e.g. local :: (r -> r) -> ReaderT r m a -> ReaderT r m a
17:47:48 <geekosaur> lift
17:47:53 <lightquake> lift local
17:47:53 <geekosaur> :t lift
17:47:53 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
17:48:39 <pavonia> joelteon: details here http://www.haskell.org/haskellwiki/HSP
17:48:49 <mkscrg> the signature i want is   local' :: (r -> r) -> TopLevel a -> TopLevel a
17:49:05 <mkscrg> lift still leaves the second arg as a ReaderT r m a
17:49:55 <NemesisD> Tekmo: hey tekmo, you around? i've got hopefully a simple pipes problem
17:51:12 <mkscrg> is  there a transformers analogy to liftM?
17:51:13 <lightquake> NemesisD: i know some pipes
17:51:18 <pavonia> mkscrg: There should be a MonadReader version of local in the mtl package
17:52:19 <mkscrg> pavonia thanks i'll take a look there. i'd also like to grok how to do it with just transformers, for my own edification
17:53:22 <NemesisD> lightquake: i'm trying to write a buffering producer, the innter producer produces 1 element at a time, and then i need to wrap it and keep a buffer before yielding it
17:53:35 <joelteon> pavonia: no syntax examples to be seen
17:53:37 <joelteon> ):
17:53:53 <pavonia> joelteon: Not even in the linked thesis?
17:54:02 <NemesisD> lightquake: Tekmo http://lpaste.net/98391
17:54:03 <joelteon> oh, I missed it
17:54:24 <NemesisD> lightquake: it type checks but for some reason it stops after the first batch
17:54:32 <pavonia> Hhm, access forbidden :S
17:54:34 <joelteon> pavonia: do you have access to the thesis? I don't
17:58:00 <Tekmo> NemesisD: I'm here
17:58:04 <Tekmo> NemesisD: Sorry for the delay
17:58:28 <NemesisD> no worries, thanks for being here :)
17:58:57 <bitemyapp> Tekmo: I laughed at your comment on that Try Haskell Pure IO Reddit post.
17:59:01 <bitemyapp> thanks for that :)
17:59:14 <jrmithdobbs> i wish Text was named something else so I'd stop creating functionT short names and confusing the fuck out of my self ;p
17:59:44 <Tekmo> bitemyapp: :)
17:59:51 <pavonia> joelteon: There's also a paper about it called "Haskell Server Pages through Dynamic Loading"
18:01:07 <lightquake> NemesisD: why not chunk n p = p >-> (forever (replicateM n await >>= yield))
18:01:18 <Tekmo> lightquake: That doesn't intercept EOF
18:01:37 <Tekmo> lightquake: So the idiomatic way to do this is to use `FreeT` to split up the `Producer` into sub-`Producer`s
18:01:39 <lightquake> oh, you're right, it won't spit out the final chunk
18:01:50 <Tekmo> There's a more nicely typed alternative to `FreeT` coming up that would simplify it
18:02:16 <NemesisD> Tekmo: yeah someone was helping me with this earlier and showed me some similar functions in pipes bytestring but it lost me at FreeT
18:02:16 <Tekmo> The slight disadvantage of the version NemesisD linked is that it loads each sublist entirely into memory
18:02:23 <Tekmo> NemesisD: Yeah, I understand
18:02:46 <NemesisD> Tekmo: loading the sublist into memory is fine here, because the next phase folds it into a strict hashmap
18:02:50 <Tekmo> NemesisD: Right now I'm working on making `pipes-parse` using a simpler type specialized to its purpose so you get nicer code and better type inference
18:02:54 <NemesisD> i'm streaming records from a db
18:03:01 <Tekmo> NemesisD: Yeah, in that case your solution is good enough for your purposes
18:03:16 <NemesisD> Tekmo: awesome! i'd love some way to subscribe to that. that sounds handy
18:03:23 <mkscrg> ok, my transformers problem boils down to: how do i lift   m a -> m a    to     t m a  -> t m a?
18:03:30 <Tekmo> NemesisD: I can show you the lpaste of what it would look like
18:03:36 <NemesisD> Tekmo: what about lightquake's, is it equivalent?
18:03:45 <Tekmo> NemesisD: http://lpaste.net/98351
18:03:46 <NemesisD> Tekmo: also my solution for some reason halts after the first chunk
18:04:01 <Tekmo> NemesisD: It's not equivalent because if the source runs out of input you will drop the last chunk prematurey
18:04:10 <Tekmo> *prematurely
18:04:36 <lightquake> Tekmo: that seems kind of messy
18:04:36 <NemesisD> Tekmo: ah ok. well can you see a reason why chunk would not continue? i suppose i should isolate it and play around with it in ghci
18:05:00 <Tekmo> lightquake: It's almost identical to the equivalent list code, if you ignore `Impure`
18:05:31 <Tekmo> NemesisD: Let me check.  I only superficially scanned it
18:05:59 <Tekmo> NemesisD: Also, you don't need the `RevList` type
18:06:03 <Tekmo> NemesisD: You can just use a list directly
18:07:08 <mkscrg> is that even possible w/ transformers?
18:09:32 <NemesisD> Tekmo: wait won't that yield elements in the wrong order?
18:09:41 <NemesisD> Tekmo: i'm intending this to be FIFO
18:10:04 <Tekmo> NemesisD: You just call `reverse` right before you yield it
18:10:17 <NemesisD> i'm just taking the long way to that i suppose
18:10:30 <Tekmo> NemesisD: Right
18:11:10 <pavonia> mkscrg: I don't think this can be done for all transformers t because you would need a function to "lift down"
18:11:13 <Tekmo> NemesisD: So did you say that there was a problem with this code?
18:11:41 <Tekmo> mkscrg: You want `hoist`
18:11:46 <NemesisD> Tekmo: it appears to only yield the first batch and the nstops
18:12:00 <Tekmo> mkscrg: `local` creates a monad morphism, so you can `hoist` it to modify a deeply nested `ReaderT`
18:12:25 <Tekmo> mkscrg: In other words, if your stack is something like `StateT s (WriterT w (ReaderT i m)) r`, then you would do `hoist (hoist (local f))`
18:12:28 <NemesisD> Tekmo: i'm in the process of wiring just chunk to a main so i can make sure its chunk that has the bug, but it sure does seem like it, my program always produces the number of elements in a batch
18:13:19 <jle`> mm_freak: thanks, just wanted to verify that i got the basics/fundamental parts of things
18:13:27 <jle`> and there wasn't anything huge i am missing
18:13:48 <mkscrg> Tekmo: ah, got it! looks like MFunctor is the supporting type class here
18:14:19 <NemesisD> Tekmo: shoot :( chunk works when isolated
18:14:54 <Tekmo> NemesisD: I just tested it
18:15:07 <Tekmo> NemesisD: Yeah, it works just fine
18:15:07 <Tekmo> mkscrg: That's right
18:15:12 <Tekmo> mkscrg: It's from `mmorph`
18:16:09 <mkscrg> Tekmo: cool. i have a custom transformer in the stack, as well as one that doesn't have an mfunctor instance
18:16:18 <NemesisD> Tekmo: i think i may have implemented my intermediate Pipes wrong, they don't recurse, i think i need to wrap them in a "for"?
18:16:47 <Tekmo> NemesisD: Probably.  Can I see the code?
18:17:15 <Tekmo> mkscrg: I can help you implement an `MFunctor` instance if you show me the code for your custom monad transformer
18:17:37 <mm_freak> jle`: if you're interested in AFRP (as implemented by netwire), you should read both the original formulation <http://conal.net/papers/icfp97/> and yampa's paper
18:18:27 <jle`> mm_freak: thanks :)
18:18:28 <mm_freak> jle`: this is useful not only in haskell, but also at least in javascript (where you can do FRP using bacon.js)
18:18:40 <jle`> what yampa paper are you referring to?
18:18:53 <jle`> is it the one with space invaders
18:20:05 <mm_freak> jle`: not sure, it's been a while
18:20:05 <NemesisD> Tekmo: http://lpaste.net/98392
18:20:13 <NemesisD> i think thats the problem code
18:20:23 <mm_freak> jle`: although the netwire tutorial should suffice
18:22:07 <jle`> mm_freak: the netwire tutorial; do you mean the README in the darcs repo?
18:22:13 <mm_freak> yeah
18:22:28 <jle`> mhm thanks, i read through it today, it was nice
18:23:12 <jle`> i feel like things are starting to fit together
18:23:31 <jle`> it clicked when i sort of figured out how to implement my entire program from scratch by composing auto's
18:23:59 <jle`> most other tutorials i read used too many primitives for me to really see what was going on
18:24:10 <jle`> or not primitives but pre built combinators and stuff
18:24:22 <jle`> sort of like how i never really knew how to use parser combinators until i built a lib from scratch
18:25:39 <NemesisD> Tekmo: it works with a "forever"
18:26:16 <Tekmo> NemesisD: Yeah, any time you see a `forever`, that's a sign that you can simplify it using a `for` or feed loop
18:27:33 <Tekmo> For example, if you want to repeat the same action for every chunk, you would write:
18:27:49 <Tekmo> NemesisD: for (chunk n p) (\theChunk -> someActionOn theChunk)
18:30:00 <NemesisD> Tekmo: well in this case i'm wrapping a producer to produce one that chunks
18:30:42 <Tekmo> NemesisD: Right.  `chunk n p` is the already-chunked producer
18:30:57 <Tekmo> NemesisD: I'm showing one way to consume the chunks it generates
18:32:00 <NemesisD> Tekmo: but if i'm trying to write chunk :: Int -> Producer a m r -> Producer -> Producer [a] m r, then it seems like forever is the simplest it gets, no?
18:32:56 <mkscrg> Tekmo: no problem i think, it's just an unwrap -> apply -> rewrap. (right?)
18:34:16 <Platz> for the >>= implementation of StateT in the tutorial (http://www.haskell.org/haskellwiki/All_About_Monads#Combined_monad_definition), it notes to use return for the expr (StateT x') <- return $ f v , wrapping it in an extra 'm'.  However, the src at https://hackage.haskell.org/package/transformers-0.3.0.0/docs/src/Control-Monad-Trans-State-Lazy.html#State doesn't use return and just unwraps the bound function with a runStateT.    Is the return ...
18:34:22 <Platz> ... really necessary?
18:36:04 <Tekmo> mkscrg: That's right
18:36:37 <Tekmo> NemesisD: Wait, are we talking about a different `chunk` function?
18:37:36 <Tekmo> Platz: Yeah, the second one is the cleaner way to do it
18:37:49 <mkscrg> semi-related: is there a reason the MonadBase/MonadBaseControl instances for (EitherT e) require Error e?
18:37:50 <Tekmo> Platz: They are both identical, but the former one is kind of silly
18:38:01 <Tekmo> mkscrg: This was just fied
18:38:04 <Tekmo> mkscrg: *fixed
18:38:18 <Tekmo> mkscrg: https://github.com/ekmett/either/pull/13
18:38:20 <mkscrg> Tekmo not on hackage yet?
18:38:23 <mkscrg> ah great, thanks
18:38:26 <Tekmo> mkscrg: Probably soon
18:38:37 <Platz> Tekmo: thanks, makes sense!
18:38:52 <mkscrg> Tekmo great to hear. my custom transformer is a newtype'd EitherT that drops the Error context
18:38:54 <Tekmo> Platz: The easy thing to remember is that `x <- return y` is the same thing a `let x = y`
18:38:59 <jle`> mm_freak: is there an academic term for such an Auto w/ a Maybe?  Mealy + Maybe?
18:39:18 <jle`> mealabye
18:39:36 <Tekmo> Platz: So that line is equivalent to: `let StateT x' = f v`, which is the same thng as `let x' = runStateT (f v)`
18:39:44 <Platz> yeah I knew a Let would produce the same type, but just wanted to make sure I wasn't missing something by requiring it to go through a bind
18:40:11 <Tekmo> Platz: Yeah, it's just a gratuitous use of bind.  It has no effect on the behavior.
18:40:22 <Platz> i assume because of the law, (return x) >>= f == f x
18:40:27 <Tekmo> Platz: That's right
18:40:32 <Platz> great
18:43:40 <erisco> with a binary tree of n nodes, if the cost of moving to a child is the number of nodes in the sub-tree under it, then moving from root to leaf is O(n)
18:43:48 <erisco> I think. useful conclusion
18:44:10 <erisco> the specific cost is 2n
18:44:26 <Tekmo> jle`: What is an `Auto`?
18:45:23 <jle`> Tekmo: um as i understand it, in the context of a conversation late one night a couple of days ago, it is a mealy machine as implemented in http://hackage.haskell.org/package/machines-0.2.3.1/docs/Data-Machine-Mealy.html
18:46:06 <jle`> newtype Auto a b = Auto { stepAuto :: a -> (b, Auto a b) }
18:46:36 <Tekmo> jle`: The wire type from netwire is pretty similar to a Mealy machine extended with `Maybe`, except newtire uses `Either`
18:46:54 <jle`> so...is there a name for this extended machine?
18:47:03 <jle`> in combinatorics
18:47:04 <nstdloop> How is b <- a different than let b = unsafePerformIO a? I know it is, but what is the most important separation?
18:47:14 <Tekmo> jle`: I feel like asking if something has a name is the wrong question
18:47:22 <maxiepoo> hey I'm having a problem with emacs flycheck and cabal sandboxes
18:47:22 <jle`> nstdloop: it might have to do with evaluation order and sematics and stuff
18:47:44 <jle`> Tekmo: hm...just wondering if it existed as an independently studied thing outside of wires/frp
18:47:46 <Tekmo> jle`: Everything can be given a name.  The important question is: is it worth getting a lot of people to spend mindshare on learning it?
18:47:53 <maxiepoo> it can't find my dependencies that are in the sandbox
18:47:55 <jle`> so i can read up on more of it
18:48:22 <Tekmo> jle`: What kind of things do you want to learn about it?
18:48:23 <jle`> like i read Auto/Mealy and i could read on a wide body of literature on it if i wanted to
18:48:24 <erisco> nstdloop, are you asking the difference inside the IO monad implementation or the difference from the outside?
18:48:25 <triliyn> nstdloop: b <- a is syntactic sugar for an incomplete expression that can only be used within the IO monad to construct a value of type IO a
18:49:00 <nstdloop> Inside of a do block
18:49:07 <nstdloop> trillyn: what do you mean?
18:49:08 <jle`> Tekmo: good point :) just maybe googling around and reading interesting things about it
18:49:26 <Tekmo> jle`: It's actually not even clear to me what you'd gain from reading the papers on Auto/Mealy
18:49:30 <maxiepoo> it's really just a ghc issue I suppose. How do I tell ghc to look in a sandbox?
18:49:43 <jle`> Tekmo: kind of wanted to find different perspectives and applications
18:49:53 <erisco> nstdloop, well with unsafePerformIO it is not sequenced with the other operations
18:50:04 <triliyn> nstdloop: b <- a eventually is desugared to something involving >>=
18:50:24 <nstdloop> ahh
18:50:26 <nstdloop> right
18:50:27 <jle`> maybe people have written on where it has been used and stuff
18:50:35 <triliyn> unsafePerformIO involves compiler magic and is unsafe unless stringent precautions are taken
18:50:58 <triliyn> and it only works in the IO monad, whereas do notation can be used in any monad
18:51:12 <triliyn> (I erroneously said it was IO only earlier; I just wasn't thinking)
18:51:35 <Tekmo> jle`: So I can tell you some of its applications because it is pretty similar to a pipes category
18:52:31 <Tekmo> jle`: So before you extended it with `Maybe` a mealy machine is basically a repeating series of `a -> m b` actions
18:52:44 <Tekmo> jle`: that means you have exactly one `b` for every `a`
18:52:56 <Tekmo> jle`: When you extend with `Maybe` you then have 0 or 1 `b`s for every `a`
18:53:10 <shachaf> a -> m b?
18:53:21 <shachaf> What's m?
18:53:38 <Tekmo> Oops, I missed that
18:53:44 <Tekmo> I thought Mealy was effectful
18:53:52 <Tekmo> I could have sworn machines had an effectful variation on this
18:54:04 <Tekmo> Anyway, the netwire version of this is effectful
18:54:14 <ReinH> hai
18:54:34 <jle`> mk
18:54:59 <pingu> Does anyone know if it's safe these days to use -funbox-strict-fields as opposed to specifying UNPACK everywhere?
18:55:01 <Tekmo> jle`: So let's deal with the case where it is pure for simplicity
18:55:16 <pingu> In terms of portability
18:55:20 <Tekmo> jle`: `Maybe` is the 0 or 1 `b`s for each `a`
18:55:36 <Tekmo> jle`: You can also use list for an arbitrary number of `b`s for each `a`
18:55:55 <Tekmo> jle`: i.e. Something a b = (a -> [b], Something a b)
18:56:29 <jle`> mhm
18:56:32 <Tekmo> jle`: Then you get an abstraction whose composition operator is "similar" to (>=>) for the list monad
18:56:42 <Tekmo> jle`: So everything you learned about the list monad applies
18:56:51 <jle`> ah
18:56:52 <Tekmo> jle`: Even if you restrict yourself to the `Maybe` case you get a similar insight
18:56:59 <jle`> yeah i can see that
18:57:05 <Tekmo> jle`: i.e. MealyMaybe a b = (a -> Maybe b, MealyMaybe a b)
18:57:15 <Tekmo> The composition operator for that is similar to kleisli composition for the `Maybe` monad
18:57:15 <jle`> fair warning though, i'm not too familiar with pipes, in case you are trying to build to a connection
18:57:26 <Tekmo> Actually, I was going to build a connection to io-streams
18:57:37 <jle`> okay
18:57:56 <jle`> do you mean a -> (Maybe b, MealyMaybe a b) ?
18:57:58 <Tekmo> `pipes` was just an intermediate bridge for that
18:58:08 <Tekmo> Oops
18:58:10 <Tekmo> Wrong type
18:58:19 <Tekmo> Should have been MealyMaybe a b = a -> (Maybe b, MealyMaybe a b)
18:58:25 <Tekmo> Same thing for the list version
18:58:27 <jle`> yeah
18:58:31 <jle`> hm.
18:58:51 <jle`> what exactly does monadic/kleisli composition look like for this?
18:58:59 <jle`> would it be like StateT s Maybe ?
18:59:12 <jle`> um.
18:59:14 <jle`> MaybeT State
18:59:22 <Tekmo> jle`: It's a category, not a monad
18:59:35 <jle`> okay
18:59:37 <Tekmo> jle`: Are you asking what the category instance looks like?
18:59:44 <jle`> so it's "similar" to >=> for list, maybe
18:59:46 <jle`> but not actually >=>
18:59:49 <c_wraith> I went and implemented Category and Profunctor for Mealy after the last discussion
19:00:04 <jle`> yeah, i'm wondering what the composition would look like
19:00:07 <Tekmo> jle`: I believe it's something like:
19:00:29 <c_wraith> jle`: it's stepping both machines in sync, looking at composed outputs
19:00:59 <Tekmo> jle`: (Mealy k1) >>> (Mealy k2) = Mealy (\a -> let (b, k1') = k1 a; (c, k2') = k2 b in (c, k1' >>> k2')
19:01:33 <Tekmo> jle`: If you extend with `Maybe`, there would be a `Nothing` check in between, just like the way bind for `Maybe` works
19:02:02 <jle`> ah
19:03:24 <Tekmo> However, my experience is that when people think they want the `Arrow` instance for `Mealy`, they usually want the `Monad` instance for `ListT` (or the equivalent Kleisli `Arrow` instance)
19:04:24 <jle`> could you express the above in terms of >=> if you had MealyMonad m a b = (Monad m) => a -> (m a, MealyMonad a b) ?
19:04:29 <c_wraith> Give 'em the Profunctor instance, tell 'em to work from there.
19:04:31 <jle`> i guess it would be pretty straightforward
19:04:43 <Tekmo> jle`: Yes
19:05:22 <jle`> hm
19:06:10 <c_wraith> what does Profunctor + Category give you?
19:06:13 <Tekmo> jle`: A key thing to keep in mind that the only advantage of using `Mealy` is if you want to perform a different action every time a value passes through
19:06:31 <Tekmo> jle`: If all you want to do is repeat the same transformation over and over, just use an ordinary function (or an ordinary Kleisli arrrow: a -> m b)
19:06:53 <c_wraith> well.  "every time" is too demanding
19:07:01 <Tekmo> c_wraith: Yeah, I misspoke
19:07:12 <Tekmo> c_wraith: I should say "if you want to not always do the same thing"
19:07:41 <c_wraith> that is, if you want to build a state machine with occasional transitions
19:08:09 <jle`> this makes sense
19:08:28 <Tekmo> A general principle of functional design is that each component of your architecture is built using the smallest functionality possible and then you promote them all to agree on the lowest common denominator
19:08:49 <Tekmo> For example, you could model a data processing pipeline using three pieces, each of which requires different features
19:08:58 <Tekmo> The first piece might be an ordinary function
19:09:01 <Tekmo> f :: a -> b
19:09:06 <Tekmo> The second piece might be a monadic function
19:09:09 <Tekmo> g :: b -> m c
19:09:15 <Tekmo> The third piece might be a netwire
19:09:32 <Tekmo> h :: Wire ... m c d (I forget the exact parameters)
19:09:53 <Tekmo> To connect all three of them, they must agree on the minimum feature set that supports all three, which is in this case the netwire
19:10:03 <Tekmo> So you owuld define the promotion functions:
19:10:15 <Tekmo> promoteToMonad :: (Monad m) => (a -> b) -> (a -> m b)
19:10:20 <Tekmo> promoteToMonad = (return .)
19:10:33 <Tekmo> That downgrades a pure function to an impure function
19:10:41 <Tekmo> Hmm, I'm mixing terms
19:10:53 <jle`> i always have trouble with the terms up, down, etc.
19:11:05 <Tekmo> I'll try to be consistent about calling this a downgrade if you contaminate it with extra features it doesn't need
19:11:16 <Tekmo> Then you need another downgrade from monadic functions to netwires
19:11:16 <jle`> i feel like in some way they are meaningless without further qualification
19:11:22 <mhitza> how can I have ghc interact nicely with cabal sandboxes? (as in see the packages installed in the sandbox)
19:11:40 <Tekmo> monadicToNetwire :: (Monad m) => (a -> m b) -> (Wire ... m a b)
19:11:56 <Tekmo> I'd have to study netwire to see how exactly to implement that, but I'm pretty sure it exists
19:12:05 <jle`> this is sort of along the lines of what is mentioned in your functor design pattern article?
19:12:08 <Tekmo> The key is that all these "downgrade" functions must have one consistent property
19:12:17 <Tekmo> They must all be arrow mappings for some functor
19:12:26 <Tekmo> For example, the `promoteToMonad` function has this property:
19:12:39 <Tekmo> promoteToMonad (f . g) = promoteToMonad f <=< promoteToMonad g
19:12:44 <Tekmo> promoteToMonad id = return
19:12:49 <Tekmo> Notice how that resembles the functor laws
19:12:56 <Tekmo> Similarly, we'd expect that:
19:13:18 <Tekmo> monadicToNetwire (f <=< g) = monadicToNetwire f . monadicToNetwire g  -- The (.) is the composition operator for netwires
19:13:27 <Tekmo> monadicToNetwire return = id  -- The id for newtires
19:13:38 <Tekmo> *netwires
19:14:09 <Tekmo> So then if we wanted to connect our three components we would write:
19:14:29 <Tekmo> (monadicToNetwire (promotetoMonad f)) . monadicToNetwire g . h
19:14:33 <Tekmo> :: Wire ... m a c
19:14:37 <Tekmo> *Wire ... m a d
19:14:52 <Tekmo> The nice thing about functor laws, is that we can group these downgrade functions if they are adjacent
19:14:59 <Tekmo> For example, we could simplify that, too:
19:15:07 <Tekmo> monadicToNetwire (promoteToMonad f <=< g) . h
19:15:14 <Tekmo> The functor laws say that reorganization is safe
19:15:36 <Tekmo> Or vice versa, we can split things if we want to split them off into separate black boxes
19:16:00 <Tekmo> This is similar in principle to the monad morphism trick I discussed yesterday
19:16:12 <Tekmo> You have some global feature set that basically operates with maximum privilege
19:16:12 <jle`> ah yes
19:16:21 <Tekmo> Then you have sub-computatoins that operate with a subset of that privilege
19:16:34 <Tekmo> You then promote them all to agree on the global feature set at the last moment
19:16:41 <Tekmo> *or downgrade
19:17:04 <Tekmo> Anyway, this process of gettings things to agree on a common feature set will almost always involve a functor of some sort
19:17:11 <Tekmo> In fact, monad morphisms are another kind of functor
19:17:26 <Tekmo> Given a monad morphism of type:  (Monad m, Monad n) => m a -> n a
19:17:31 <Tekmo> Let's call it `morph`
19:17:37 <Tekmo> You get the following functor laws for `morph`
19:17:52 <Tekmo> (morph .) (f >=> g) = (morph .) f >=> (morph .) g
19:18:01 <Tekmo> And you can get rid of the parentheses to get:
19:18:09 <Tekmo> morph . (f >=> g) = morph . f >=> morph . g
19:18:26 <Tekmo> So that basically says that monad morphisms are a principle way to get subcomputations to agree on a common feature set
19:18:33 <Tekmo> *monadic subcompuations
19:20:25 <hakujin> mhitza: runghc -- -package-db --ghc-arg=.cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d program.hs
19:20:29 <Tekmo> So for me, the ideal Haskell program is a bunch of isolated morphisms in various categories, and then a bunch of functors to unify them to agree on the same category
19:20:35 * hackagebot identifiers 0.2.1.0 - Numeric identifiers for values.  http://hackage.haskell.org/package/identifiers-0.2.1.0 (awagner83)
19:20:39 <jle`> Tekmo: that's a really neat picture
19:20:39 <hakujin> assuming OSX. linux will have a slightly different path
19:20:57 <jle`> Tekmo: I can sort of see things i have written in the past being restructured to sort of fit this ideal
19:21:11 <jle`> all you need is a couple of ugly-ish abstraction functions
19:21:14 <jle`> hidden away
19:21:20 <Platz> haskell is below "Ladder Logic" on Tiobe index... wtf is Ladder Logic?
19:21:21 <Tekmo> jle`: So I wouldn't get caught up on finding one abstraction to rule them all
19:21:47 <Tekmo> jle`: Instead, just find the right abstraction for each individual component and then learn how to convert morphisms of each abstraction to agree using functors
19:22:24 <jle`> Tekmo: yeah, that's pretty great
19:22:28 <jle`> i wonder why i don't hear about this that much
19:22:47 <mhitza> hakujin, thank you, I will try that
19:22:48 <jle`> or maybe i do but i don't recognize it
19:23:39 <hakujin> mhitza: cabal build, cabal repl, cabal run all work too
19:24:08 <mhitza> hakujin, I know but I'm trying to get haskellmode-vim setup
19:24:18 <jle`> Tekmo: appreciate you taking the time to explain :)
19:24:30 <Guest80155> hi, is there anyone who can help a haskell newby out ? I just started programming in haskell today and im stuck allready :(
19:24:34 <randomclown> is it worth it IORefing an IntSet?
19:25:25 <Tekmo> jle`: You're welcome
19:25:31 <c_wraith> Guest80155: lots of people here will help.  Just ask your questions. And please put code you want to ask about on lpaste.org
19:25:48 <Tekmo> jle`: The reason you don't hear about is that people spend too much time regurgitating what they read in papers
19:25:56 <Tekmo> jle`: Instead of trying to apply what they learn in new ways
19:26:35 <jle`> Tekmo: but that's the whole advantage about using Haskell :o
19:26:44 <Tekmo> jle`: I agree
19:26:48 <Tekmo> Haskell makes the theory real
19:27:38 <Tekmo> For me, something doesn't seem real until it's manifested as code that runs and does something
19:27:38 <jle`> i wonder if you were present for this discussion the other day
19:28:02 <jle`> but i was talking about how it's interseting that we use the wor d'resaerch' for haskell
19:28:05 <jle`> but not for other languages
19:28:13 <jle`> but i think there might be other languages where research is a relevant word
19:28:17 <jle`> so maybe i was a bit hasty
19:28:25 <hakujin> mhitza: I recommend ghc-mod.vim, neco-ghc, and YouCompleteMe instead of haskellmode-vim. A lot more features and works with sandboxes by default.
19:28:29 <roboguy_> Guest80155: what's the problem?
19:28:30 <Tekmo> That's because Haskell originated primarily as a research language
19:28:39 <jle`> but i think Haskell yeah, research is in the culture
19:28:41 <jle`> everyone researches.
19:29:00 <erisco> Cale, after some work and iterations I have generalised the code for arbitrary types (though some algorithms require Enum and Bounded)
19:29:15 <jle`> in other languages research is done by the privileged few
19:29:15 <Tekmo> If I remember correctly, Haskell was created as a lingua franca for computer science research
19:29:20 <hakujin> mhitza: hasksyn is a better haskell syntax file as well
19:29:32 <mhitza> hakujin, thanks, I already started pondering how I would make vim susbstitute the parameter --ghc-arg for each project I use :)
19:29:50 <erisco> Cale, though Traversable is still stumping me
19:30:52 <Guest80155> can someone help me with this ? lpaste.net/98393
19:31:00 <Platz> "So the monad laws can be summarised in convenient Haiku form" - haskellwiki
19:31:15 <Platz> take that msdn
19:31:18 <blackdog> anyone understand how hinotify is going to work? I can't seem to get it to fire: https://gist.github.com/mwotton/5b6d821a7bcf19c3646b
19:31:23 <blackdog> *meant to work, rather
19:31:25 <jle`> Guest80155: what's wrong with it?
19:32:12 <Guest80155> i am trying to use my own version of joining 2 lists in a function reverse
19:32:31 <jle`> Guest80155: nothing wrong with that :)
19:32:51 <Guest80155> the reverse works when i use ++, but it wont when i use my own function that does the same as the ++ operator
19:33:18 <jle`> can you post the latter version?
19:33:46 <Guest80155> yes
19:33:59 <jle`> it might be a problem with parantheses
19:34:29 <jle`> parentheses
19:34:42 <erisco> I am working on a new module that refactors higher order recursive functions in an interesting way. Inquiry and comment is welcome https://github.com/erisco/haskell-decision/blob/master/src/nary.hs
19:34:55 <Elision> .... okay, I install an interrupthandler in main, then enter a REPL I wrote
19:34:57 <erisco> also if anyone knows Traversable better and can fix my instance that'd be grand
19:35:08 <Elision> but then the ^C handler no longer seems to run? what could be causing this
19:35:34 <Elision> it runs if the evaluation part of the REPL is not currently evaluating
19:36:06 <enthropy> is there an equivalent of http://journal.r-project.org/archive/2012-2/RJournal_2012-2_Baaaath.pdf but looking at hackage?
19:36:14 <Tekmo> erisco: So this is basically `Free (a, b ->)`
19:36:26 <erisco> Tekmo, I do not know what that is
19:36:27 <c_wraith> Elision: are you using the ghc api anywhere? it clobbers several signal handlers unnecessarily
19:36:32 <Guest80155> lpaste.net/98394
19:36:47 <Guest80155> that is the latter version :)
19:36:51 <erisco> Tekmo, but it is possible that pre-existing work has been done. I did not run across it however
19:36:55 <enthropy> in terms of different LANGUAGE, variable naming conventions, module arrangements
19:37:11 <Elision> c_wraith: hmmm, don't think so? what modules does that live in, I can at least check if I've imported them
19:37:22 <Tekmo> erisco: Read the concurrency article of this issue: https://themonadreader.wordpress.com/2011/10/26/issue-19/
19:37:38 <jle`> Guest80155: what's wrong with it?
19:37:40 <jle`> does it compile?
19:37:40 <Tekmo> erisco: It will give you a lot of ideas if this area interests you
19:37:47 <Guest80155> yes it does compile
19:37:48 <Elision> c_wraith: I've had my fair share of issues with the ^C^C thing the RTS does, so I'm doing my own signal handler through System.Posix.Signals
19:38:03 <c_wraith> Elision: it's in the ghc package..  if you don't depend on that, it's not the source
19:38:04 <erisco> Tekmo, well my work has nothing to do with concurrency (ie I do not have concurrency in mind)
19:38:05 <Guest80155> when i run myreverse [1,2,3]. it starts an infinite loop
19:38:11 <roboguy_> Guest80155: Note the first version works like: (x : myreverse xs) ++ [x]
19:38:13 <Guest80155> my terminal freezes
19:38:14 <Tekmo> erisco: I know that, but still read it
19:38:15 <jle`> that makes sense.
19:38:19 <Tekmo> erisco: The article is about more than just ocncurrency
19:38:32 <jle`> Guest80155: look at roboguy_ 's comment
19:38:35 <jle`> also
19:38:37 <jle`> try this
19:38:42 <jle`> this is something neat that you can do in Haskell
19:38:44 <roboguy_> or, actually I think this specifically x : (myreverse xs ++ [x])
19:38:53 <Tekmo> erisco: To illustrate how it works, I will implement your `Decision` type using a free monad
19:38:54 <jle`> expand out your function calls in-place one-by-one
19:39:15 <jle`> for example, expand out your myappend [2,3] [1]
19:39:22 <erisco> Tekmo, okay sure I'd be happy to see it
19:39:26 <jle`> and then expand out your myreverse (myappend [2,3] [1])
19:39:31 <jle`> you will soon see why you have an infinite loop
19:39:34 <Elision> c_wraith: hm, okay, then I'm not doing anything with GHC
19:39:46 <Guest80155> thanks for the advice!
19:39:51 <jle`> well first expand out the entire myappend
19:39:56 <Tekmo> erisco: The free monad is one of the most reinvented things in Haskell programming
19:39:57 <Guest80155> okay!
19:40:02 <Tekmo> erisco: Once you know the pattern you will see it everywhere
19:40:28 <jle`> myappend [2,3] [1] = 2 : myappend [3] [1] = 2 : 3 : myappend [] [1] = 2:3:1
19:40:36 <jle`> :[]
19:40:56 <jle`> but i'll let you do it yourself haha.
19:41:27 <jle`> after you see why it loops infinitely, try expanding your original definition in terms of the definiton if (++)
19:41:31 <jle`> @src (++)
19:41:32 <lambdabot> []     ++ ys = ys
19:41:32 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
19:41:32 <lambdabot> -- OR
19:41:32 <lambdabot> xs ++ ys = foldr (:) ys xs
19:41:41 <jle`> and see why it does not loop infinitely
19:41:54 <jle`> actually your implementation and the implementation with (++) should expand exactly the same.
19:42:09 <jle`> so as soon as you see something different, that's where your mistake is
19:42:52 <Guest80155> haha, i will try.. i cannot get my head around it, im used to imperative programming languages
19:42:59 <erisco> Tekmo, I have been teasing out and refining this idea starting from a refactoring idea I had
19:43:15 <jle`> Guest80155: do you understnad how i expanded out myappend [2,3] [1] to 2:3:1:[] ?
19:43:21 <erisco> Tekmo, the more I work on it the more general it becomes, so this conclusion would not be too surprising
19:43:42 <jle`> and then when you myreverse ([2,3,1]), you get myreverse (myappend [3,1] [2])
19:43:49 <Guest80155> yeah, ive been reading a book on learnyouahaskell.com
19:43:53 <jle`> which is myreverse [3,1,2]
19:44:08 <jle`> which is myreverse (myappend [1,2] [3])
19:44:15 <jle`> which is myreverse [1,2,3]
19:44:18 <jle`> which is your original call
19:44:20 <jle`> infinite loop.
19:44:32 <Tekmo> erisco: http://lpaste.net/98395
19:44:44 <Tekmo> erisco: You also want to read this: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
19:44:49 <jle`> so let's try doing this expansion/equational reasoning with your original (++)
19:45:03 <Tekmo> erisco: This will teach you how to spot the free monad pattern and use it in your own code
19:45:09 <jle`> it might help to write it in prefix to show the parallel
19:45:28 <Guest80155> yeah, but when i do the following [1,2,3] ++ [4,5,6] = [1,2,3,4,5,6] and when i do myappend [1,2,3] [4,5,6] = [1,2,3,4,5,6]
19:45:38 <Guest80155> thats driving me nuts :P
19:45:43 <jle`> yeah, that's correct
19:45:48 <jle`> that means your ++ is correct :)
19:45:50 <jle`> er
19:45:52 <jle`> your myappend is correct
19:46:11 <jle`> try expanding out your myreverse with ++
19:46:12 <Guest80155> its all in the notation in myreverse
19:46:29 <erisco> Tekmo, what module has liftF?
19:46:35 <Tekmo> erisco: Control.Monad.Fre
19:46:40 <Tekmo> erisco: Everything in there is from that module
19:46:49 <erisco> Tekmo, hm, mine does not seem to have it
19:46:58 <Tekmo> erisco: what version of `free` do you have installed?
19:47:28 <erisco> Tekmo, none I downloaded a different module
19:47:29 <erisco> damn
19:47:33 <erisco> now there will be conflicts
19:47:48 <Tekmo> erisco: Just do `ghc-pkg unregister <the wrong package`
19:48:05 <Tekmo> erisco: The correct package to install is the `free` package
19:48:36 <erisco> Tekmo, so how do I use interact and dfilter?
19:48:48 <jle`> Guest80155: your myreverse with the (++) is more or less completely different than your myreverse with myappend
19:48:53 <Tekmo> erisco: dfilter is an example of how to reimplement your `dfilter` using `interact`
19:49:02 <Tekmo> erisco: It's a drop-in replacement for the one you wrote
19:49:07 <Guest80155> yeah, i noticed, the first version was not correct
19:49:08 <roboguy_> Guest80155: here's another hint: this is your first function fully parathensized: x : ((myreverse xs) ++ [x])
19:49:09 <Tekmo> erisco: Let me also write hte `decide` funciton, too
19:49:17 <Elision> hmm, it seems that the interrupt handler is not running when the runtime is ... busy
19:49:27 <Elision> i.e. in this case, running an infinite recursion
19:49:40 <roboguy_> *parenthesized
19:49:43 <Elision> which is...... pretty much the exact use case I want
19:50:11 <Guest80155> the first version should have been myreverse (x:xs) = myreverse xs ++ [x]
19:50:17 <randomclown> how do you make ghic automatically print the type instead of printing "no Show instance for (a->a) etc etc"
19:50:24 <randomclown> ghci*
19:50:28 <jle`> Guest80155: instead of using (++), try setting append = (++), so you can use it prefix, the same way you use myappend
19:50:43 <Tekmo> erisco: There, I annotated it with the `decide` function
19:50:47 <Tekmo> erisco: http://lpaste.net/98395
19:50:48 <Guest80155> and the new one is myreverse (x:xs) = myreverse (myappend xs [x])
19:50:58 <frege> hah http://willamette.edu/~fruehr/haskell/evolution.html
19:51:43 <jle`> Guest80155: so in the first version, you are appending the result of myreverse xs with [x]
19:51:57 <jle`> you are appending the reverse of xs with x
19:52:00 <jle`> [x]
19:52:08 <jle`> in the second version, you are reverseing the result of appending xs with [x]
19:52:09 <frege> is foldr == reduce?
19:52:11 <jle`> they are...different
19:52:31 <Tekmo> erisco: Also, note that `pipes` already implements something identical to `Decision`
19:52:41 <Tekmo> erisco: This is what a `Client` does
19:52:53 <jle`> Guest80155: this is the equivalent of your second version: myreverse (xs ++ [x])
19:52:58 <erisco> Tekmo, interesting
19:53:00 <pavonia> randomclown: :type shows you the type of an expression
19:53:00 <Guest80155> wait i will repost the code
19:53:02 <roboguy_> frege: it depends on what you mean by reduce
19:53:10 <Tekmo> erisco: Decision a b r = Client a b r
19:53:13 <Tekmo> erisco: interact = request
19:53:26 <Tekmo> *(Monad m) => Client a b m r
19:53:58 <frege> roboguy_: python reduce
19:53:58 <randomclown> pavonia: yeah but it would be nice if it'd just do that by itself
19:54:05 <randomclown> on things that doesn't have a show instance
19:54:19 <roboguy_> frege: python reduce is foldl technically
19:54:23 <erisco> Tekmo, well I will have to do some reading then. Thanks for guiding me to this
19:54:33 <Tekmo> erisco: And `decide f d = runEffect (return . f +>> d)`
19:54:47 <frege> roboguy_: so map/reduce in haskell is map/foldl
19:54:57 <pavonia> randomclown: You mean only show the type if the expression is ill-typed?
19:55:07 <erisco> Tekmo, I was not even sure this idea had any applicability :P
19:55:08 <roboguy_> frege: well... it depends on which direction you want the associativity of the fold to be: left or right
19:55:14 <Tekmo> erisco: It does!
19:55:20 <roboguy_> frege: python's reduce is a left fold
19:55:29 <Tekmo> erisco: Let me just write up the pipes version into a program you can compile and test
19:55:33 <randomclown> pavonia: print the type if the result doesn't have a 'Show' instance
19:55:43 <erisco> Tekmo, I do not know pipes whatsoever so I do not think that would help
19:55:48 <randomclown> > print
19:55:49 <lambdabot>  <() -> IO ()>
19:55:56 <randomclown> something like that's fine
19:55:57 <roboguy_> personally, I think right fold is generally more intuitive
19:56:04 <Tekmo> erisco: pipes will simplify a lot of what you are doing
19:56:10 <Tekmo> erisco: It also has a super thorough tutorial
19:56:25 <Tekmo> erisco: http://hackage.haskell.org/package/pipes-4.0.2/docs/Pipes-Tutorial.html
19:56:27 <Guest80155> lpaste.net/98397
19:56:46 <pavonia> randomclown: Well, in lamdabot has loaded a Show instance for functions, it's in Data.Function, IIRC
19:56:52 <pavonia> -in
19:56:55 <jle`> i think it uses typeOf
19:57:09 <jle`> but he probably wants to be able to override the default behavior of ghci
19:57:15 <geekosaur> randomclown, that is actually available (I think in Data.Function?) but one thing you cannot do easily is declare a Show instance for things that do not have a Show instance
19:57:41 <geekosaur> and I suspect if you are looking to change ghci's behavior, you are looking at hacking the source to ghci itself
19:57:44 <jle`> Guest80155: your non-working version is the equivalent of myreverse (xs ++ [x])
19:58:01 <jle`> geekosaur: maybe he can add in a show instance for (->) that uses typeOf
19:58:10 <jle`> is that possible?
19:58:16 <erisco> Tekmo, the odd thing is that I came to this idea when I was working on a graph library... so it will be interesting to see the graph algorithms expressed in a similar way
19:58:55 <ChongLi> hmmm
19:58:56 <geekosaur> actually, from what I looked at Data.Function does not have such a Show instance (and I was dubious about it being there, since having it appear just because you want to use Data.Function.on seems bad)
19:59:12 <ChongLi> so we were talking earlier about rendering glyphs to opengl textures
19:59:33 <ChongLi> what about just rendering a web page to a texture?
19:59:39 <ChongLi> can the webkit bindings do that?
19:59:48 <Guest80155> ok but it is still not working :(
19:59:49 <geekosaur> jle`: it's sort of possible. one problem with Show instances and the current Data.Typeable is that things must be monomorphic
19:59:55 <geekosaur> > map
19:59:56 <Tekmo> erisco: Here's the equivalent code using `pipes`: http://lpaste.net/98398
19:59:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
19:59:56 <lambdabot>    arising from a use of `M50146622646445402366651.show_M50146622646445402366...
19:59:56 <lambdabot>  The type variable `b0' is ambiguous
19:59:56 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:59:56 <lambdabot>  Note: there are several potential instances:
20:00:29 <geekosaur> `print` worked earlier because of extended defaulting
20:00:49 <roboguy_> Guest80155: the working version is the same as this "(myreverse xs) ++ [x]"
20:01:10 <geekosaur> I *think* there is a new Typeable mechanism in the works that would make this doable.. but last I heard, it did not make it *easy*
20:01:12 <roboguy_> the parentheses make a big difference
20:01:23 <Guest80155> so that is the only problem ?
20:01:26 <Guest80155> the parentheses?
20:01:30 <jle`> geekosaur, randomclown got something working-ish with this: instance (Typeable a, Typeable b) => Show ((->) a b) where show = show . typeOf
20:01:36 <geekosaur> yes
20:01:37 <tomberek> does anyone use hdevtools? It seems that .hi files (notably those that come with Control.Lens) are not processed, so I get "Could not find module" errors
20:01:52 <geekosaur> again, only for monomorphic types (or what can be forced monomorphic)
20:02:00 <jle`> geekosaur: but you are right, it turns them monomorphicy
20:02:07 <jle`> (+) comes out as Integer -> Integer -> Integer
20:02:09 <jle`> alas.
20:02:11 <geekosaur> a polymorphic type is *not* currently Typeable
20:02:39 <Guest80155> i've tried the infix notation
20:02:41 <roboguy_> Guest80155: see how they do two different things? "myreverse (xs ++ [x])" tries to call myreverse with "xs ++ [x]" and "(myreverse xs) ++ [x]" calls myreverse with xs and then appends [x] to the result of that call
20:02:43 <Guest80155> but won't work either
20:03:01 <tippenein> if Codec.Compression.GZip.decompress takes a lazy bytestring, do I have to work all my strings into LBs?
20:03:15 <jle`> geekosaur: is there anything being done on this front?
20:03:24 <jle`> i guess i don't even see how it is conceptually possible
20:03:28 <geekosaur> [13 03:55] <geekosaur> I *think* there is a new Typeable mechanism in the works that would make this doable.. but last I heard, it did not make it *easy*
20:03:43 <jle`> ah
20:04:08 <geekosaur> I also don't know how far along it is; I think the start of it was supposed to be in the long-delayed 7.8, but it was only the start of it
20:04:09 <johnw> tippenein: or convert at the last moment
20:04:17 <johnw> a lazy bytestring is just a list of strict bytestrings, really
20:04:26 <jle`> still it might be still might be worth popping into your ~/.ghci
20:04:37 <geekosaur> they were still working issues out with the rest
20:04:38 <johnw> so just do: B.fromChunks [xs], where xs is your strict bytestring
20:04:50 <jle`> if only to be able to use things like "it"
20:05:03 <geekosaur> if you really want to know, better probably to ask in #ghc or haskell-cafe@
20:05:23 <geekosaur> or possibly glasgow-haskell-users@
20:05:33 <tomberek> no? nobody uses hdevtools?
20:05:42 <Tekmo> johnw: Later versions of bytestring have a dedicated conversion function
20:05:45 <tippenein> johnw: I'll give that a shot, thanks
20:06:11 <johnw> Tekmo: ah, yeah, I think I've noticed fromStrict in 0.10
20:06:18 <Tekmo> johnw tippenein: See `fromStrict` in `Data.ByteString.Lazy
20:06:30 * johnw is stuck in 7.4.2 world, still
20:06:43 <Tekmo> johnw: So am I
20:06:56 <ChongLi> damn these browser frameworks are enormous
20:10:28 <erisco> Tekmo, ah interesting. so the pattern of Decision is equivalent to Free but my application is different
20:11:30 <Tekmo> erisco: Free has no particular application
20:11:39 <erisco> Tekmo, yes
20:11:41 <Tekmo> erisco: It's just a reusable pattern
20:12:07 <Tekmo> erisco: Even if you don't use `Free`, you can use knowledge about it to inform the design of your library
20:12:18 <Tekmo> erisco: For example, that's how I was able to figure out that the `interact` function would be useful
20:12:27 <Guest80155> jle', i cannot figure out what i did wrong, it should have been equal right?
20:12:52 <jle`> your first one is (myreverse xs) ++ [x]
20:12:59 <jle`> your second one is myreverse (xs ++ [x])
20:14:34 <Tekmo> erisco: However, I recommend you still check `pipes`.  A lot of the functions you are implementing are greatly simplified by using `pipes` as the internal representation
20:15:03 <Tekmo> erisco: For example `desArg f = (request . f \>>)`
20:15:12 <roboguy_> Guest80155: if you set "append = (++)" for clarity, the nonworking version is this "myreverse (append xs [x])"
20:15:31 <Tekmo> erisco: Oops: `desArg f = (request . f >\\)`
20:15:55 <Tekmo> erisco: And `desType f = (fmap f . request >\\)`
20:15:58 <roboguy_> Guest80155: you sort of have the calls to myreverse and append flipped around from where the should be
20:16:39 <jle`> is there any way to have ghc build with the packages in the cabal sandbox?
20:17:15 <roboguy_> Guest80155: you are appending inside the recursive call. you should be appending *outside* the recursive call
20:18:36 <Guest80155> omg!
20:18:48 <hakujin> jle`: cabal build (or cabal run) with cabal-install >= 1.18
20:18:49 <Guest80155> thanks! it worked!
20:18:54 <mjo> Is it possible that I have hit this legitimately, or do I just need to go drink myself to sleep and hope it's better in the morning? http://bpaste.net/show/TFFltEeR5wO1KjB2Hd3I/
20:19:15 <Guest80155> thanks jle and roboguy!
20:19:24 <mjo> `ghc-pkg check` is totally clean, and that's after reinstalling every haskell package on the system
20:19:24 <jle`> hakujin: i want to do just do it for a one-off script without having to make a full on .cabal file
20:19:26 <jle`> :|
20:19:57 <hakujin> runghc -- -package-db --ghc-arg=.cabal-sandbox/x86_64-osx-ghc-7.6.3-packages.conf.d program.hs
20:20:03 <hakujin> assuming OSX
20:20:15 <Tekmo> jle`: If you need to generate a cabal file in a hurry, use `cabal init`
20:21:00 <hakujin> Tekmo: reading your articles on free monads. Thanks for the writeups.
20:21:09 <Tekmo> hakujin: You're welcome!
20:21:18 <jle`> Tekmo: :'( yeah ended up doing that.
20:21:41 <jle`> does not feel very clean but i guess that is the consequence.
20:21:58 <hakujin> jle`: see the runghc line above ^
20:22:02 <hakujin> for one offs
20:23:26 <Elision> okay, can *anyone* explain why ^C does absolutely nothing to http://lpaste.net/98400 ?
20:23:51 <jle`> hakujin: thanks :) hm. maybe just using a cabal file is better haha. but nice to know the alternative
20:24:05 <erisco> Tekmo, do you think there is use in the way I am applying Free?
20:25:00 <Tekmo> erisco: You mean for the decision type in general?
20:25:13 <jle`> oh my goodness, SDL has a terminal backend?
20:25:16 <jle`> that's amazing.
20:25:53 <erisco> Tekmo, well, you can see my intent with functions such as dfilter and dgroupBy
20:27:51 <Tekmo> erisco: Yeah, I get the basic idea
20:28:01 <Tekmo> erisco: Hold on a second
20:28:06 <Tekmo> erisco: My daughter needs help
20:28:15 <erisco> Tekmo, is she a Haskeller too? :)
20:28:50 <Tekmo> erisco: She's 2 years old :)
20:29:01 <erisco> can't start too early
20:29:18 <Tekmo> You're right
20:30:21 <Tekmo> So the basic idea is that for a `Decision a b r`, you are outsourcing the implementation of a function of type `a -> b` that is only supplied at the last moment using `decide`
20:30:29 <shachaf> Elision: Probably because your infinite loop doesn't give it a chance to.
20:30:54 <Tekmo> erisco: So my question is, do you plan on using a function other than `decide` to evaluate `Decision`s?
20:31:02 <shachaf> Try e.g. print $ result (0 :: Integer) where result :: Integer -> Integer; result i = result (i + 1) or something.
20:31:33 <erisco> Tekmo, well, not just outsourcing, but also deferring
20:31:35 <shachaf> (Why are you killThreading the main thread? And from the main thread?)
20:31:43 <Tekmo> erisco: It's the same thing
20:31:58 <erisco> Tekmo, okay. I was not sure what you meant by outsource
20:32:07 <Elision> shachaf: reducing some issues I've been having with threading to minimal problems
20:32:13 <erisco> Tekmo, and no, I have no other plans on how to evaluate
20:32:17 <Tekmo> erisco: The reason I ask is that if you only use `decide` to evaluate `Decision`s then you can simplify the decision type to just `(a -> b) -> r`
20:32:22 <erisco> however I do have functions to manipulate the tree
20:32:25 <Tekmo> erisco: Then `decide` would just be `id`
20:32:36 <Elision> it seems .... annoying that tight loops hog the runtime *that* strongly
20:32:41 <Tekmo> erisco: Oh yeha, that's right
20:32:45 <Tekmo> erisco: I missed that
20:32:58 <erisco> Tekmo, yes that is the point :)
20:33:01 <Elision> shachaf: yeah, that's interruptible .... hmph.
20:33:47 <erisco> Tekmo, if the tree is not manipulated then filter is the same as decide + dfilter
20:34:12 <erisco> Tekmo, but for the functions I am worried about it is useful to manipulate the tree before deciding
20:34:26 <Tekmo> erisco: I don't understand how the manipulation functions are supposed to work
20:34:44 <erisco> Tekmo, the function 'down' trickles information from the top of the tree downwards. 'up' does this from the bottom to top, and 'look' is the same idea as 'up' but does lookahead
20:34:48 <shachaf> Yes, there's some flag in current or upcoming GHC to make such loops impossible, I think.
20:34:58 <shachaf> At a performance cost, of course.
20:35:26 <erisco> Tekmo, the result is that you can make more powerful decisions without complicating the function
20:35:26 <shachaf> Most real long-running loops tend to allocate, though.
20:35:28 <Tekmo> erisco: What's the tree you are referring to?
20:35:45 <erisco> Tekmo, try printing "dgroupBy [1,2,3]" and you will see
20:35:55 <Platz> tomberek: I'm only using hdevtools with vim
20:36:41 <roboguy_> shachaf: I was pretty surprised the first time I saw <<loop>>
20:37:11 <Tekmo> erisco: Oh, okay
20:37:14 <Tekmo> erisco: I recognize this
20:37:38 <erisco> Tekmo, for example, some functions may be of the form  (Monad m) => (a -> m b) -> t a -> m b  with the intent typically being to use State as the monad
20:37:50 <erisco> which allows you to carry information forward during the traversal of 't a', or what have you
20:37:55 <erisco> well this is what 'down' does
20:37:57 <Aetherspawn> Tekmo: hi
20:38:02 <Tekmo> Aetherspawn: Hey
20:38:02 <shachaf> roboguy_: <<loop>> is a completely different thing
20:38:20 <Aetherspawn> are you going to go ahead with the Broadcast thing
20:38:25 <Aetherspawn> or would you accept a pull request?
20:38:27 <Tekmo> erisco: Okay, so by analogy to pipes there is another function that should be useful to you
20:38:32 <Tekmo> Aetherspawn: I will write it up
20:38:33 <roboguy_> shachaf: oh, I thought you were talking about an extension to the infinite loop detection. sorry I wasn't fully paying attention
20:38:34 <shachaf> Elision: Anyway, you can get ^C as a regular exception from GHC, no need for the POSIX things.
20:38:46 <Tekmo> Aetherspawn: Just give me some time
20:39:06 <Aetherspawn> I'm doing nothing right now, I can do a pull request if you want
20:39:18 <Tekmo> Aetherspawn: Alright.  That works! :)
20:39:25 <Aetherspawn> ok
20:39:31 <erisco> Tekmo, there are some other interesting facts such as "range filter x" is all sub sets of x
20:40:02 <Elision> shachaf: every attempt to do that ran into the runtime's insistence on catching the second ^C and quitting
20:40:15 <Tekmo> erisco: Pipes has a useful function that you can translate to your `Decision` type.  Its type when converted to `Decision`s is: `(a -> Decision c d b) -> Decision a b r -> Decision c d r
20:40:18 <shachaf> Ah. I don't know.
20:40:20 <erisco> Tekmo, you can apply the technique to a sort function and get all permutations
20:40:29 <Tekmo> erisco: This basically lets you "defer" a decision to yet another decision
20:40:36 <Elision> yeah, there seems to be no way to disable that behaviour, which is incredibly frustrating for a repl
20:40:40 <Tekmo> erisco: In fact, you can show that this funciton forms a category
20:40:52 <Tekmo> erisco: Where the identity is the `interact` function
20:41:22 <Tekmo> erisco: Let's call this function `defer`
20:41:23 <erisco> Tekmo, that is a curious signature. it is almost like >>= but not quite
20:41:34 <Tekmo> erisco: It is very analogous to (>>=)
20:41:41 <Tekmo> erisco: and `interact` is analogous to `return`
20:41:48 <Tekmo> erisco: That's why they form the category
20:41:54 <Tekmo> erisco: It's analogous to a Kleisli category
20:42:17 <Tekmo> erisco: So if you define the `defer` and `interact` funciton, you get the following "monad laws"
20:42:24 <Tekmo> erisco: defer interact = id
20:43:08 <Tekmo> erisco: defer f (interact a) = f a
20:43:49 <Tekmo> erisco: defer g (defer f d) = defer (\a -> defer g (fa)) d
20:44:17 <Tekmo> If you were using `pipes`, the analogous functions would be
20:44:19 <Tekmo> defer = request
20:44:21 <Tekmo> Oops
20:44:23 <Tekmo> Sorry,
20:44:27 <Tekmo> interact = request
20:44:36 <Tekmo> defer = (\\>)
20:44:52 <Tekmo> And the composition operator would be (\>\), analogous to (>=>)
20:45:03 <erisco> lovely operator names
20:45:21 <erisco> I'll have to spend more time on this because those definitions are beyond my knowledge
20:45:22 <Tekmo> erisco: `pipes` has 5 categories, so it's hard to come up with beautiful operator names for each one
20:45:31 <Tekmo> erisco: Just focus on understanding `defer` and `interact`
20:45:42 <Tekmo> erisco: Those functions will be really useful for yu
20:45:54 <Tekmo> erisco: You don't have to use `pipes`.  Just define it in terms of your implementation
20:45:59 <Tekmo> erisco: You'll still find it useful
20:46:37 <Tekmo> erisco: To give you a bit more theoretical background, what you are defining is basically "CoListT"
20:46:43 <Tekmo> Well, sort of
20:47:52 <Tekmo> erisco: And `defer`/`interact` are like the monadic operations for this "CoListT"-like abstraction
20:47:59 <Tekmo> erisco: That's why I recommended them
20:48:20 <ChongLi> wow
20:48:33 <ChongLi> it takes like 6 lines of code to create a webview and load a web page
20:49:32 <tippenein> "Setup.hs: You need to re-run the 'configure' command. The version of Cabal
20:49:32 <tippenein> being used has changed (was Cabal-1.14.0, now Cabal-1.16.0). Additionally the
20:49:32 <tippenein> compiler is different (was ghc-7.4, now ghc-7.6) which is probably the cause
20:49:32 <tippenein> of the problem.
20:49:34 <Tekmo> erisco: So the reason you are using this decision type is so that you can preserve the structure of the decisions so that you can print/manipulate it
20:49:51 <Tekmo> erisco: This is structure that would be lost if you did the simple (a -> b) -> r representation
20:49:52 <tippenein> sorry, didn't think that paste would be multiline
20:49:55 <Tekmo> erisco: I get it now
20:50:14 <erisco> Tekmo, yes, so that is why I am using functions like filter and groupBy as examples, as they fit that profile
20:51:12 <Tekmo> erisco: So I think this is useful for the same reason I think my own `Client` type is useful, if that answers your question :)
20:51:17 <erisco> Tekmo, for example, imagine you wanted a filter that worked with the State monad so that you could remember elements already visited
20:51:40 <erisco> Tekmo, it would necessarily complicate the definition of filter to support this
20:51:57 <erisco> and in general, there may be many ways in which you want to work with something filter-like
20:52:19 <erisco> so this is that. instead, I write dfilter and the result it returns can be used in any way you wish
20:52:37 <erisco> you can perform look-ahead and look-behind on the information, if you wish, or just do the normal thing
20:53:01 <Tekmo> erisco: One thing I want to point out is that free objects (including free monads) typically arise when you want to preserve the original structure of a computation as much as possible
20:53:19 <Tekmo> erisco: So it makes sense that you would have reinvented a free monad for this purpose
20:53:55 <Tekmo> erisco: So what you are doing is trying to capture as much of the original filter logic as possible in a data structure so that you can transform the logic later on
20:54:21 <Tekmo> erisco: Same thing for your other decision functions
20:54:57 <carter> DSP filters or FP filters?
20:55:04 <Tekmo> erisco: I want to point out that you can actually even make your Decision type a monad transformer, but I don't know if you would be interested in that or not
20:55:14 <Tekmo> erisco: You could actually optionally enrich it with effects from some base monad
20:55:40 <erisco> Tekmo, well I can look into that at a later time
20:56:12 <frege> the answer two doesn't make sense http://shuklan.com/haskell/lec03.html#/0/20
20:56:13 <erisco> but yes, that is what I am trying to do. it is a refactoring strategy mainly
20:56:32 <frege> this part--> zipTogether (x:xs) (y:ys)
20:57:22 <Tekmo> erisco: However, you gave me a cool idea for how I could add a `Show` instance for `pipes`.  Thanks for the idea
20:57:39 <erisco> Tekmo, oh, you're welcome :)
20:57:53 <erisco> is it related to the 'dom' function?
20:58:12 <erisco> I noticed that it is a bit inaccurate...
20:58:36 <Tekmo> erisco: Well, I just like the idea of printing a client as a decision tree if it is pure
20:58:40 <erisco> well, I don't know if there are any types which do not play nice with both Bounded and Enum restrictions
20:59:00 <erisco> > [1.0..10.0] -- but this is certainly not what I want from Enum
20:59:01 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
20:59:43 <Tekmo> erisco: Well, I think it does that since the alternative is useless
20:59:59 <erisco> indeed I was hoping for a type error :P
21:00:04 <Tekmo> erisco: Do you really want [1.0, 1.0+e, 1.0+2e, ...]?
21:00:08 <Tekmo> erisco: Oh
21:00:12 <enthropy> > [ 1 .. 2.5 ]
21:00:13 <lambdabot>  [1.0,2.0,3.0]
21:00:22 <Tekmo> Yeah, I think you will just have to live with that
21:00:25 <enthropy> that's the confusing part
21:00:31 <enthropy> it should stop at 2.0
21:00:45 <Tekmo> I remember there was a discussion on libraries a few months ago about fixing that
21:00:59 <Tekmo> I don't remember what came of it
21:01:25 <Tekmo> You can always ask them to remove the `Enum` instance for `Double`.  It would be no great loss
21:01:33 <Tekmo> And any program that relied on it would probably be broken anyway
21:02:04 * enthropy disagrees
21:05:46 <shachaf> > [1,3..4]
21:05:47 <lambdabot>  [1,3]
21:05:49 <shachaf> > [1,3..4]::[Double]
21:05:50 <lambdabot>  [1.0,3.0,5.0]
21:05:53 * hackagebot sizes 2.3.0 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.3.0 (JohnWiegley)
21:05:55 * hackagebot sizes 2.3.1 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.3.1 (JohnWiegley)
21:05:57 * hackagebot hasktags 0.68.4 - Produces ctags "tags" and etags "TAGS" files for Haskell programs  http://hackage.haskell.org/package/hasktags-0.68.4 (MarcWeber)
21:06:07 <johnw> shachaf: that's unfortunate
21:06:12 <ChongLi> Tekmo: make it an error to define orphan instances?
21:06:42 <ChongLi> err, I should pay better attention
21:07:01 <ChongLi> I'm just a bit flabberghasted at how easy it is to use gtk2hs and webkit
21:10:52 <erisco> Tekmo, well thank-you for the help. I'll take a good look at the Free pattern and see what I can learn from it and investigate pipes
21:12:31 <erisco> Tekmo, however, I do not think using the Free type directly makes much sense. it saves code in some spots but in most other places I have to deal with Decision being inside Free
21:12:45 <erisco> oh he is gone :(
21:13:40 <erisco> point is, it is nice that you can fix a pre-existing type, but if you're designing a new type and its only usage is when it is fixed
21:14:01 <erisco> then it seems simpler to make itself fixed
21:15:37 <eazar001> tippenein: it seems like you just need to simlink your cabal to your $HOME/.cabal/bin/cabal
21:16:06 <tippenein> eazar001: this is within an HSENV
21:16:16 <eazar001> hmmm
21:17:08 <tippenein> I worked around it with runhaskell
21:17:30 <eazar001> okay
21:18:19 <tippenein> my hlint vim plugin is kinda buggy. I have to try compiling if I think the warnings it gives are wrong
21:18:35 <tippenein> I think it only happens when I'm using hsenv though
21:18:39 <tippenein> *shrugs*
21:18:58 <johnw> you have to build your hlint within the hsenv
21:19:19 <tippenein> :(
21:19:41 <tippenein> does cabal-dev do the same?
21:19:48 <johnw> yep
21:20:05 <johnw> hlint needs to be built with the same package database that you're doing your checking against
21:20:25 <johnw> err, sorry
21:20:29 <johnw> i thought we were talking about hdevtools
21:20:30 <johnw> ignore me
21:20:44 <tippenein> gladly! that would've been tedious
21:22:40 <RichieGoldstein_> hi _1126 hi __class__ hi __mkrull hi _br_ hi _d3f hi _flow_ hi _janne hi `0660 hi `bps hi `rawr hi
21:22:41 <RichieGoldstein_> hi `^_^v hi a11235 hi A1kmm hi absence hi acfoltzer hi acharles hi acomar hi adelbertc hi ademidov hi Adeon hi
21:22:41 <RichieGoldstein_> hi adimit hi adinapoli hi Adios hi adlan hi adnap hi adnauseam hi adsmac hi aegray_ hi Aetherspawn hi AfC hi
21:22:41 <RichieGoldstein_> hi aford hi agjacome hi ahf hi ahihi hi aji hi akiress_ hi akraut hi akurilin hi AlainODea_ hi alang hi
21:22:41 <RichieGoldstein_> hi alderz_ hi Aleksejs hi aleksejs_ hi alexdoom hi AleXoundOS hi alexsdut1on hi alexsdutton hi alios hi aloiscochard|off hi Amadiro hi
21:25:40 <geekosaur> o.O
21:26:02 <eazar001> hahha auto-hi script
21:26:16 <geekosaur> in a channel with close to 1200 users
21:26:24 <eazar001> lol
21:26:33 <eazar001> it better be written in haskell [=
21:26:49 <geekosaur> some lessons must be learned the hard way :p
21:28:57 <roboguy_> I would think that you'd have a automatic limit in an auto hi script, although this is the first time I've heard of such a thing...
21:30:20 <eazar001> excess friendliness is not tolerated
21:30:55 <roboguy_> eazar001: have you ever looked at intercal? the compiler rejects any code that is too friendly because it thinks you might be up to something
21:31:11 <roboguy_> but if you're not polite enough, it also rejects it for being too rude
21:31:52 <eazar001> roboguy_: hehe, what is friendly code?
21:31:55 <roboguy_> and that's the sole purpose of the "PLEASE" operator haha
21:32:25 <roboguy_> there's a "PLEASE" keyword whose only purpose is to add polietness. you must use it some, but not too much
21:32:28 <roboguy_> *politeness
21:32:44 <roboguy_> "DO ...; PLEASE DO ..."
21:32:47 <eazar001> no kidding, is it one of those turing tarpit languages?
21:33:33 <geekosaur> very
21:33:51 <geekosaur> well, joke language that someone actually implemented as a turing tarpit language
21:33:53 <geekosaur> COME FROM and all that
21:34:02 <johnw> geekosaur: we're up to 1200 now?
21:34:04 <roboguy_> yeah. they tried to make it as strange as possible basically. it doesn't have a "goto" (I don't think) but it has a "come from"
21:34:17 <geekosaur> I show 1185 currently
21:34:22 <geekosaur> @users
21:34:22 <lambdabot> Unknown command, try @list
21:34:25 <eazar001> haahah, you shoudl check out leetspeak
21:34:33 <geekosaur> bah, think that plugin got removed
21:34:43 <geekosaur> lb used to track the max occupancy
21:35:17 <eazar001> haskell is a pretty damn big channel
21:35:37 <eazar001> most are lurkers like me it seems
21:35:41 <geekosaur> also I'm pretty sure I've seen over 1300 in here
21:35:58 <roboguy_> it's one of the biggest channels on this network isn't it?
21:36:27 <roboguy_> looks like the only language channel that has more users is #python
21:36:27 <jrmithdobbs> oh that's nifty, I think you can build a Cont monad (and a functor/applicative functor/alternative/monad) with rust's diverging functions, I don't think that's an intended use ;p
21:36:58 <eazar001> how do you get a head-count?
21:37:30 <eazar001> the last time i checked #python it was really "un-involved"
21:37:32 <geekosaur> my client shows the current channel occupancy above the user list, and the channel list dialog lets me see (and sort by) number of users
21:37:38 <jrmithdobbs> http://static.rust-lang.org/doc/0.9/rust.html#diverging-functions
21:37:49 <geekosaur> this will vary by client, and probably nonexistent for webchat
21:38:04 <eazar001> geekosaur: okay mine says 1179
21:38:18 <eazar001> 1220 for python
21:38:34 <geekosaur> yes, it fluctuates a bit. mine says 1180 now but someone joined right after you said that
21:38:37 <geekosaur> and now someone has left
21:39:27 <eazar001> #haskell seems to be pretty active though, because it does have a comparatively steep learning curve compared to most languags i've encountered
21:39:48 <eazar001> functional or not
21:41:30 <dareTake> Hi, I wish to ask a newb question :)
21:41:58 <dareTake> I wish to check a password for it's strength
21:42:23 <dareTake> my code atm is,
21:42:48 <jrmithdobbs> dareTake: define strength
21:43:11 <dareTake> let strong s = length s && any isDigit s && any isLower s && any isUpper s
21:43:33 <derdon> length doesn't return a Bool
21:43:37 <jrmithdobbs> :t length
21:43:37 <lambdabot> [a] -> Int
21:43:49 <dareTake> well if its more than 15 chars, has a digit, a lowercase letter and an uppercase letter
21:44:00 <dareTake> sry, (length s > 15)
21:44:06 <eazar001> yea you need something like (>5) . length
21:44:10 <dareTake> can this code be more elegant?
21:44:38 <eazar001> > (>15) . length
21:44:39 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
21:44:39 <lambdabot>    arising from a use of `M22382818988411655226930.show_M22382818988411655226...
21:44:39 <lambdabot>  The type variable `a0' is ambiguous
21:44:39 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
21:44:39 <lambdabot>  Note: there are several potential instances:
21:44:39 <tippenein> fold it maybe?
21:45:15 <derdon> using a fold sounds good
21:45:32 <jrmithdobbs> > (>15) .length [0..20]
21:45:33 <lambdabot>  Couldn't match expected type `a0 -> b0'
21:45:33 <lambdabot>              with actual type `GHC.Types.Int'
21:45:38 <dareTake> yea sure, that works , but doesn't that make the code more complicated?
21:45:43 <jle`> :t all --daretake
21:45:44 <lambdabot> (a -> Bool) -> [a] -> Bool
21:46:21 <derdon> dareTake: your code iterates very often over s. this can be reduced with folds
21:46:28 <jle`> :t \s -> all [length s, any isDigit s, any isLower s, any isUpper s]
21:46:29 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `[Int]'
21:46:29 <lambdabot>     In the first argument of `all', namely
21:46:29 <lambdabot>       `[length s, any isDigit s, any isLower s, any isUpper s]'
21:46:36 <derdon> I'm not sure whether GHC optimizes this anyway
21:46:36 <dareTake> i mean like (\x -> isDigit x &&  isLower x && isUpper x) ?
21:46:36 <jle`> oh
21:46:52 <jle`> :t \s -> all [length s > 15, any isDigit s, any isLower s, any isUpper s]
21:46:53 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `[Bool]'
21:46:53 <lambdabot>     In the first argument of `all', namely
21:46:53 <lambdabot>       `[length s > 15, any isDigit s, any isLower s, any isUpper s]'
21:46:55 <ademidov> :t and
21:46:55 <lambdabot> [Bool] -> Bool
21:47:00 <jle`> oh yeah.
21:47:07 <dareTake> um && -> ||
21:47:09 <jle`> i was going to lead up into all ($ s)
21:48:25 <dareTake> k thnx, let me try the fold option
21:48:33 <jle`> :t > \s -> and $ [any isDigit, any isLower, any isUpper] <*> pure s
21:48:33 <lambdabot> parse error on input `>'
21:49:10 <jle`> :t \s -> and $ [any isDigit, any isLower, any isUpper] <*> pure s
21:49:10 <lambdabot> [Char] -> Bool
21:49:37 <tippenein> nice
21:49:46 * shachaf mentions something about how you can try these things in /msg
21:49:47 <dareTake> that looks good
21:50:07 <dareTake> just need to learn <*> and pure :)
21:50:43 <shachaf> a <*> pure b = fmap ($ b) a
21:50:54 <shachaf> all = and . map f
21:51:12 <shachaf> and $ [f,g,h] <*> pure x = all ($ x) [f,g,h]
21:51:15 <shachaf> magic
21:51:17 <eazar001> dareTake: did you get that code from the Haskell Wiki?
21:51:24 <jle`> > \s -> all ($ s) [any isDigit, any isLower, any isUpper]
21:51:25 <lambdabot>  <[Char] -> Bool>
21:51:29 <jle`> there
21:51:32 <jle`> idk why it didn't work before
21:52:31 <eazar001> jle`: that looks pretty neat
21:52:35 <dareTake> no, was the result of hw from this --> http://shuklan.com/haskell/lec06.html#/0/20
21:52:59 <jle`> let strong s = all ($ s) [(> 15) . length, any isDigit, any isLower, any isUpper] in strong <$> ["hello","password","u3894yf9t8wwuerut3tkHZJWTUE"]
21:53:11 <jle`> > let strong s = all ($ s) [(> 15) . length, any isDigit, any isLower, any isUpper] in strong <$> ["hello","password","u3894yf9t8wwuerut3tkHZJWTUE"]
21:53:12 <lambdabot>  [False,False,True]
21:53:23 <jle`> oops that's actually my bank password
21:53:26 <jle`> nobody write it down please.
21:53:31 <eazar001> lol
21:53:47 <dareTake> nice, thnx :)
21:54:04 <jle`> one of the few alternative uses of ($)
21:54:50 <jrmithdobbs> jle`: that's a pretty fun use of ($)
21:56:05 <jle`> dareTake: that's a fancy course website
21:56:44 <jle`> oh it's just a lecture presentation
21:57:10 <dareTake> jle`: yea just found out about it, looks cool though
21:57:12 <jrmithdobbs> > let strong s = all (s &) [(> 15).length,any isDigit,any isLower,any isUpper] in strong <$> ["Aaaaaaaaaaaaaaaaaaaaaaaa1"]
21:57:13 <lambdabot>  [True]
21:57:21 <jrmithdobbs> may want to rethink your definition ;p
21:57:44 <jrmithdobbs> jle`: not you, the definition of what he thinks is a strong password ;p
21:58:19 <eazar001> if you think that's bad, check out: http://en.wikibooks.org/wiki/Haskell/Monad_transformers
21:58:48 <eazar001> knew i recognized that pattern from somewhere
21:59:00 <eazar001> my useless form of memory, jeez
22:01:02 <jrmithdobbs> @pl \s -> all ($ s) [any isDigit, any isLower, any isUpper]
22:01:02 <lambdabot> flip all [any isDigit, any isLower, any isUpper] . flip id
22:02:23 <eazar001> [(any)] <*> [isDigit,isLower,isUpper]
22:02:29 <eazar001> > [(any)] <*> [isDigit,isLower,isUpper]
22:02:30 <lambdabot>  [<[Char] -> Bool>,<[Char] -> Bool>,<[Char] -> Bool>]
22:03:22 <eazar001> > flip all [(any)] <*> [isDigit,isLower,isUpper] . flip id
22:03:23 <lambdabot>  Couldn't match expected type `(((((a0 -> GHC.Types.Bool)
22:03:23 <lambdabot>                                    -> [a0] -> GHC.Types.Bool)
22:03:23 <lambdabot>                                   -> GHC.Types.Bool)
22:03:23 <lambdabot>                                  -> c1)
22:03:23 <lambdabot>                                 -> c1)
22:03:36 <roboguy_> :t fmap any [isDigit, isLower, isUpper]
22:03:37 <lambdabot> [[Char] -> Bool]
22:05:13 <roboguy_> ^ that's equivalent to [(any)] <*> [isDigit, isLower, isUpper]
22:05:36 <eazar001> > flip all ([(any)] <*> [isDigit,isLower,isUpper]) . flip id
22:05:37 <lambdabot>  <[Char] -> Bool>
22:05:47 <eazar001> roboguy_: oh yea doh!
22:05:55 <eazar001> roboguy_: oh yea doh!
22:06:00 <eazar001> oops how'd that happen?
22:06:02 <eazar001> deja vu
22:06:22 <eazar001> > flip all (any <$> [isDigit,isLower,isUpper]) . flip id
22:06:23 <lambdabot>  <[Char] -> Bool>
22:06:54 <roboguy_> in my opinion, flip id is a bit of a confusing way to say flip ($)
22:08:12 <roboguy_> so I think I'd stick with \s -> all ($ s) (any <$> [isDigit, isLower, isUpper])
22:08:34 <eazar001> yea, just goofin
22:08:45 <roboguy_> ZipList might help with pointless-ness
22:08:46 <copumpkin> :t and . sequence
22:08:46 <lambdabot>     Couldn't match type `[a0]' with `Bool'
22:08:46 <lambdabot>     Expected type: [[a0]] -> [Bool]
22:08:46 <lambdabot>       Actual type: [[a0]] -> [[a0]]
22:09:05 <eazar001> to be honest it already looks "elegant" enough to me
22:09:15 <eazar001> i would only re-examine it if performance was poor
22:09:20 <copumpkin> :t (and .) . sequence
22:09:21 <lambdabot> [a -> Bool] -> a -> Bool
22:09:23 <eazar001> but for a use case like that it doesn't seem likely
22:09:39 <jrmithdobbs> roboguy_: i like:
22:09:42 <jrmithdobbs> :t flip all [(>15).length,any isDigit,any isLower,any isUpper] . (&)
22:09:43 <lambdabot> [Char] -> Bool
22:13:21 <ademidov> :t and . sequence [(>15).length,any isDigit,any isLower,any isUpper]
22:13:22 <lambdabot> [Char] -> Bool
22:14:16 <kleptine> Anyone have a second to explain something?
22:14:58 <eazar001> kleptine: ask and maybe someone can help you
22:15:19 <roboguy_> :t \s -> and . getZipList $ fmap any (ZipList [isDigit, isLower, isUpper]) <*> pure s
22:15:20 <lambdabot> [Char] -> Bool
22:16:02 <kleptine> Why if in GHCi I do "let show1 = (\x -> show x)"  and then ":t show1"  is the type equal to "show1 :: () -> String"
22:16:12 <mauke> monomorphism restriction
22:16:32 <jrmithdobbs> :t flip all ([(>15).length] <> (any <$> [isDigit,isLower,isUpper])) . (&)
22:16:32 <lambdabot> [Char] -> Bool
22:17:03 <kleptine> where "let show1 x = show x" has the type "a -> String" as I might expect
22:17:23 <kleptine> oh just saw @mauke
22:17:42 <c_wraith> has anyone ever ended up in the bad case the monomorphism restriction is supposed to prevent?
22:18:29 <Ralith> well, I imagine if they would, the monomorphism restriction usually prevents it...
22:19:12 <c_wraith> I mean, I guess it happens occasionally.
22:19:19 <roboguy_> I still don't fully understand what it is supposed to prevent
22:19:27 <copumpkin> things that look like values that are secretly functions
22:19:38 <copumpkin> and not behaving the way people expect
22:19:50 <c_wraith> except that still happens, thanks to type classes
22:20:03 <copumpkin> well, it's preventing one case of it
22:20:09 <roboguy_> copumpkin: what would be a specific example?
22:20:11 <copumpkin> from happening unless you annotate it otherwise
22:20:23 <copumpkin> foo :: Num a => a
22:20:38 <c_wraith> fibs :: Num a => [a] ; fibs = 0 : zipWith (+) fibs (drop 1 fibs)
22:20:39 <copumpkin> foo looks like a value but is actually a function
22:20:54 <c_wraith> that particular definition of fibs has a severe performance problem
22:20:58 <shachaf> "actually" meaning "implemented as, in ghc"
22:20:59 <roboguy_> copumpkin: how so? you mean the context passing that ghc does internally?
22:21:22 <copumpkin> well, it's a different foo for each type it can be instantiated with
22:21:31 <c_wraith> because the compiler implements it as a function, rather than a constant, so there's no sharing.
22:21:34 <copumpkin> typically if you write foo : Int and evaluate it, it'll remember that
22:21:41 <copumpkin> foo might take a while
22:21:45 <dolio> c_wraith: It's surprisingly hard to demonstrate that problem.
22:21:50 <roboguy_> ahh, okay that makes sense
22:21:51 <dolio> GHC is too smart.
22:21:56 <c_wraith> dolio: you'd need to load it from another file
22:22:09 <roboguy_> that seems like a way easier explanation than what I remember from the wiki
22:23:43 <quchen> c_wraith: … explain?
22:23:58 <quchen> I don't see why sharing would be a problem here.
22:24:08 <quchen> Or no sharing. Or no problem.
22:25:34 <roboguy_> quchen: if I understand, it has to re-evaluated foo every time it is used, because ghc internally represents constraints like "Num a =>" as a function argument
22:25:41 <roboguy_> *to be
22:26:09 <c_wraith> Right.  Except as dolio points out, GHC is too smart to get tripped up by that case.  Need something more complex.
22:26:21 <roboguy_> oh really? that's pretty cool actually
22:26:37 <quchen> Interesting.
22:26:59 <roboguy_> c_wraith: fibs would be an example, though?
22:27:28 <dolio> If you turn off optimizations, that fibs will take exponential time instead of linear time.
22:27:49 <dolio> But with optimizations GHC will usually figure out how to specialize each case to not do that.
22:28:09 <c_wraith> I guess it's actually part of the worker/wrapper transform it does
22:28:20 <c_wraith> the class dictionary is a constant argument
22:28:46 <c_wraith> so it rewrites the definition to not pass that co-recursively
22:29:21 <roboguy_> the ghc developers have put some serious work into making it smart, huh?
22:30:05 <roboguy_> how difficult is the ghc source to read? I've thought about looking through it, but I always want to just view it on github and their haskell source viewer doesn't work right
22:30:26 <quchen> "The GHC source" is a pretty big thing.
22:30:48 <quchen> You can't read it as one giant monolithic thing, and code styles vary quite a bit between files.
22:31:02 <quchen> Or comment styles, anyway.
22:31:56 <roboguy_> I can imagine. there's a guide to it somewhere, isn't there?
22:33:14 <roboguy_> yeah, here we go: https://ghc.haskell.org/trac/ghc/wiki/Commentary
22:35:50 <roboguy_> I don't think I've ever seen a compiler that has such a detailed commentary. not that I've looked too hard, but still
22:39:39 <c_wraith> roboguy_: remember that GHC has been a research project as much as anything else for more than 20 years.  Of course it's got some decent commentary.  The problem is making sure it's not out of date.
22:42:09 <derdon> wow, didn't know that ghc is that old. it's even older than me!
22:42:40 <c_wraith> one of the main authors of GHC, Simon Peyton Jones, has made jokes that it's his oldest child.
22:43:25 <derdon> hehe
22:44:12 <Aetherspawn> Tekmo: hi again
22:44:16 <Aetherspawn> the pull request is through
22:51:49 <dleedev> Hi, I'm trying to use Control.Monad.Reader, and I'm getting an error saying "Ambiguous module name"
22:51:59 <dleedev> apparently this module is provided in both monads-td and mtl
22:52:13 <Tekmo> Aetherspawn: Alright, I will check it out
22:52:38 <kleptine> Found a good beginner's explanation to monomorphic restriction if anyone's interested. http://lambda.jstolarek.com/2012/05/towards-understanding-haskells-monomorphism-restriction/
22:52:48 <kleptine> Thanks for the help
22:52:51 <dleedev> what's the difference, between monads-td and mtl, and which should I use?
22:52:55 <roboguy_> dleedev: mtl
22:53:23 <dleedev> roboguy_: how do I tell ghc to prefer mtl over monads-td without uninstalling monads-td?
22:53:27 <Tekmo> Aetherspawn: Yeah, so what I had in mind was something similar to the rest of `pipes-concurrency`, where the spawn function would prevent deadlocks through garbage collection
22:53:31 <jle`> so...what happens if i actually want to use prelude's (.) while using netwire?
22:54:03 <Tekmo> jle`: Just use `import Prelude hiding (id, (.))
22:54:04 <Aetherspawn> oh, did I do it differently?
22:54:09 <Tekmo> jle`: Then `import Control.Category`
22:54:26 <Tekmo> Aetherspawn: Study how `spawn` is implemented to see what I mean
22:55:15 <roboguy_> dleedev: you can use the PackageImports extension
22:56:10 <dleedev> roboguy_: what's the difference between the two packages?
22:56:22 <jle`> Tekmo: so Control.Category's (.) works the same as prelude's (.)? (and id too i'd imagine)
22:56:28 <jle`> like a generalized (.)?
22:56:41 <Aetherspawn> Tekmo: righto, I'll implement the sealer
22:56:45 <Tekmo> jle`: Right
22:57:34 <Aetherspawn> Tekmo: I dont think your test suite works on Windows
22:57:39 <Aetherspawn> for me all the tests fail
22:57:45 <Tekmo> jle`: There is an `instance Category (->)`
22:57:45 <Aetherspawn> except the first 4 or so
22:57:48 <roboguy_> dleedev: I'm not fully sure, but I know I've heard people suggest mtl over monads-tf before and I think it's more widely used
22:57:52 <jle`> ah i see it.
22:57:58 <jle`> oh there is a Kleisli newtype
22:58:00 <jle`> that's interesting.
22:58:04 <Tekmo> Aetherspawn: Interesting.  I didn't know that
22:58:36 <Aetherspawn> I'll make this change and then it'd be helpful if you could see if my test works for yo
22:58:40 <Tekmo> Aetherspawn: Create an issue for it so that I remember to fix it
22:59:13 <Aetherspawn> ok
22:59:27 <Tekmo> jle`: Yeah, and there's an `instance (Monad m) => Category (Kleisli m)`
22:59:47 <Tekmo> jle`: There's also an `Arrow` instance for `Kleisli m`
23:00:40 <flebron> Woah. My totally-unknown, today-uploaded, first-ever Hackage package has 15 downloads O.o
23:03:56 <Tekmo> What is it?
23:04:05 <derdon> flebron: how many of these are from bots?
23:04:13 <Aetherspawn> Why would it deadlock if its collected?
23:04:41 <Tekmo> An easy way to find out is to compare it to an `acme-*` package which would only be downloaded by bots
23:04:45 <flebron> derdon: 1) How can I know that? 2) ... do I want to know that? :(
23:05:00 <flebron> (It's http://hackage.haskell.org/package/avl-static-0.1.0.0 )
23:05:03 <Tekmo> It looks like about 20-30 downloads are bot-related
23:05:40 <Tekmo> But I'll download it so that you know that at least one download is real
23:05:42 <shachaf> Why would only bots download an acme- package?
23:05:50 <Tekmo> Do people really use those?
23:06:07 <Tekmo> I think the burden of proof is on you to show they are used
23:06:36 <flebron> Tekmo: Thank you haha :)
23:07:19 <derdon> flebron: nice error message "The impossible has happened" ;)
23:07:32 <Tekmo> flebron: I couldnt download because it depends on base >= 4.6
23:07:42 <quchen> Tekmo: What kinds of bots download Hackage packages though? "Compile all of Hackage to test a compiler" ones?
23:07:43 <flebron> Curiously, the impossible did happen once.
23:07:58 <enthropy> @where revdeps
23:07:58 <lambdabot> http://packdeps.haskellers.com/reverse
23:07:58 <Tekmo> quchen: For example: hdiff
23:08:11 <flebron> Tekmo: Hrm, I'm new at making package dependencies, how can I know the least version that the package would compile under? Is that automagically-doable?
23:08:23 <enthropy> quchen: distro packagers too?
23:08:27 <Tekmo> quchen: Also when people download Hackage to test dependencies
23:08:38 <Tekmo> Oh yeah, distros is a good point
23:08:49 <Tekmo> I also know that people sometimes download all of Hackage to do analyltics
23:08:57 <Tekmo> LIke when Edward tried to see what namespace was free for `lens`
23:09:01 <enthropy> where are those analytics?
23:09:16 <Sonarpulse> can anybody reccomend me a disassembler in haskell?
23:09:28 <Sonarpulse> doing x86-32
23:09:34 <Tekmo> I have no idea, it was purely hypothetical, except for the Edward example
23:09:44 <Tekmo> And maybe one other example where somebody published LOC counts for packages
23:09:45 <shachaf> kmc made bindings for udis86
23:09:56 <shachaf> I never used them but I saw his talk on them. Looked nice.
23:11:08 <Tekmo> flebron: You can pretty safely assume your package will compile under `base-4.5`, too
23:11:42 <Tekmo> flebron: Figuring out dependencies is not automatic, but after a while developing packages you ge better at remembering good package ranges
23:12:52 <enthropy> there is supposedly some tooling to help with figuring out dependency ranges?
23:13:25 <Tekmo> Well, I think it's a bit difficult problem in general once you have many dependencies because you have to test all possible permutations to get it exactly correct
23:13:28 <flebron> Tekmo: To change the package dependencies, should I upload a new version?
23:13:34 <Tekmo> However, there may be an efficient approximate solution
23:13:55 <Tekmo> flebron: I think currently you have to upload a new version, but it's not urgent
23:14:16 <Tekmo> flebron: My rule of thumb is to buffer a month between releases unless it's an urgent fix
23:15:18 <flebron> Fair enough :)
23:16:22 <Tekmo> flebron: However, it looks like a nice library
23:16:45 <flebron> Thanks :) I posted a request for comments in /r/haskell but it languished for a day and disappeared haha
23:17:48 <Tekmo> flebron: Yeah, the perennial problem of library design is that by the time people comment on it too late in the development process
23:18:12 <Tekmo> *on it, it is too late
23:19:49 <Tekmo> flebron: It helps if you have a blog.  Blog posts are a much better way to solicit feedback than links to github repositories
23:20:14 <Tekmo> flebron: Think of it as an exchane
23:20:20 <flebron> I was just writing up a post on it, in my yet-invisible blog :) http://fedelebron.com:8000/compile-time-invariants-in-haskell (In all its unfinished glory)
23:20:29 <Tekmo> flebron: You give them something interesting to read about in exchange for them taking time to review your library
23:20:45 <Tekmo> flebron: If you just link to your Github repo then it's a one-sided exchange
23:21:03 <flebron> Ah, makes sense. I need to put some effort in the presentation, basically.
23:21:07 <Tekmo> flebron: Right
23:21:14 <Tekmo> flebron: Presentation is the price of feedback
23:22:08 <flebron> Thanks! :))
23:22:13 <Tekmo> flebron: You're welcome! :)
23:22:37 <Tekmo> flebron: Also, blog posts are a great way to improve your general programming skills
23:22:55 <Tekmo> flebron: Teaching others about a topic forces you to understand it well and clearly articulate your thoughts
23:23:43 <flebron> Yeah :) I've a few other posts at http://fedelebron.com:8000/ (redesigning it, hence the weird port), basically when I learn something cool, I try to write a bit about it.
23:24:17 <Tekmo> flebron: Yeah, that's a good approach
23:27:43 <Aetherspawn> Tekmo: okay, how
23:27:47 <Aetherspawn> *how about this.
23:27:56 <Aetherspawn> New commit should be on the pull
23:29:02 <Aetherspawn> I wasn't sure whether dupBroadcast needs an IORef
23:29:12 <Aetherspawn> I don't think it does.
23:41:00 <dleedev> roboguy_: is there anyway to declare in the file itself what package should be used to resolve Control.Monad.Reader?
23:41:23 <roboguy_> dleedev: PackageImports
23:43:44 <dleedev> roboguy_: ah, found it, thanks
23:44:08 <dleedev> roboguy_: the docs for PackageImports is hard to find, but I found something helpful here: https://www.fpcomplete.com/user/PthariensFlame/guide-to-ghc-extensions/basic-syntax-extensions#packageimports
