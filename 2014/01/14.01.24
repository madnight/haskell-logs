00:00:33 <hamid> :t (->)
00:00:35 <lambdabot> parse error on input `->'
00:00:38 <hamid> I still don't get the part about (->) being a real function! that's kinda creepy!
00:00:47 <shachaf> It's type-level, not value-level.
00:01:05 <shachaf> 2 + 3 is an Int. (+) :: Int -> Int -> Int
00:01:32 <shachaf> Char -> Bool is a type. (->) is not a type*.
00:01:50 <shachaf> * or you can say that (->) is a type too, and that's fine, I don't care which definition of "type" you use.
00:02:01 <johnw> haha
00:02:04 <johnw> i like the asterix
00:02:19 <johnw> I was recently wondering whether that sort of thing should be called a type
00:02:31 <Anpheus_> johnw: The answer is yes.
00:02:48 <johnw> with kind * being distinguished as what, a concrete type?
00:02:57 <shachaf> That's the worst thing to care about, other than editors and operating systems and keyboard layouts and programming languages and so on.
00:03:17 <shachaf> Just define what you mean at the top of your paper or whatever and it'll be fine.
00:03:36 <johnw> I define containers to be the things that functors are.
00:04:35 <shachaf> hilarious
00:06:23 <kosmikus> johnw: I typically say "types of kind *" to refer to types of kind * :)
00:07:02 <Twey> I like ‘inhabitable type’
00:07:24 <shachaf> That's a great convention.
00:07:43 <kosmikus> Twey: yes, I sometimes do that too, although I then typically say "potentially inhabited type"
00:10:39 <kosmikus> keep_learning: in your question about TypedExpr. if a forall occurs in that particular position in a "data" declaration, it's actually introducing what's called an "existential" type.
00:10:52 <kosmikus> keep_learning: so when calling the constructor, you can choose a type in Eq to apply it to
00:11:46 <shachaf> kosmikus: How's your book going?
00:12:06 <udevd> hi! i have quick question to which answer i, like, need now: how do I use liftIO? I have list [(filename,a,b)] and want to tranform it to sth like [(readFile filename,a,b)]
00:12:36 <johnw> the answer to your question has nothing to do with liftIO
00:12:48 <udevd> probably ;)
00:13:12 <johnw> map (\(fn,a,b) -> (readFile filename, a b))
00:13:17 <johnw> though I must say, it sounds like an odd thing to want
00:13:30 <udevd> well, i don't think it would work...
00:14:33 <udevd> bbb.hs:4:11: No instance for (Show (IO [Char]))
00:17:11 <notdan> udevd: try mapM (\(fn,a,b) -> readFile filename >>= \c -> (c,a,b))
00:17:20 <keep_learning> kosmikus: So can I write the above statement as this ? data ( Eq t ) => TypeExpr t =  Expr t ::: Type t
00:17:35 <rawtass> Is it possible to iterate across all members of a data structure the same way as I would do a list?
00:17:59 <notdan> rawtass: check out Traversable
00:18:09 <notdan> http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Traversable.html
00:18:12 <kosmikus> keep_learning: no. that'd be a datatype context, which is different. plus, these are in the process of being removed from the language.
00:18:39 <shachaf> They are already removed.
00:18:58 <kosmikus> keep_learning: you could write it in GADT syntax: data TypeExpr :: * -> * where (:::) :: Eq t => Expr t -> Type t -> TypeExpr t
00:19:00 <shachaf> They're gone from Haskell 2010 and they're turned off by default in GHC. That's as removed as they'll reasonably get.
00:19:22 <kosmikus> shachaf: yes, I wasn't completely precise. they're still supported by GHC if you want to.
00:19:25 <notdan> Why were they removed, again? because they were confusing?
00:19:31 <kosmikus> notdan: yes
00:19:32 <shachaf> Because they were useless.
00:19:40 <kosmikus> both
00:19:44 <kosmikus> useless and confusing
00:20:11 <shachaf> On the other hand data TypeExpr t = Eq t => Expr t ::: Type t is perfectly valid (with ExistentialQuantification) and does the same thing as kosmikus's GADT
00:22:22 <keep_learning> In  data TypeExpr :: * -> * where (:::) :: Eq t => Expr t -> Type t -> TypeExpr t Now t will take only those instances which are member of Eq class ?
00:22:53 <keep_learning> kosmikus: am I correct ?
00:23:01 <shachaf> You'll only be able to make (... ::: ...) when t is Eq, yes.
00:23:14 <shachaf> And in addition, when you pattern-match on (... ::: ...) you'll get an Eq constraint for t.
00:23:18 <kosmikus> keep_learning: both your original TypeExpr and my version are completely equivalent
00:23:30 <shachaf> But this is pretty likely not to actually be what you want.
00:23:31 <kosmikus> keep_learning: just different syntax for the same thing
00:24:01 <kosmikus> shachaf: if I understand correctly, this type comes from lecture notes
00:24:17 <shachaf> Oh. In that case.
00:24:27 <shachaf> I missed the beginning.
00:25:54 <shachaf> Oh, the type in the lecture notes is data TypedExpr = forall t. Eq t =>   Expr t ::: Type t
00:26:05 <shachaf> Which is an existential, rather different.
00:26:14 <kosmikus> shachaf: huh?
00:26:48 <shachaf> kosmikus: TypedExpr in http://www.cse.chalmers.se/edu/course/afp/lectures/lecture11/Typed.hs.html isn't parameterized. The t is existential.
00:27:01 <kosmikus> grr
00:27:03 <kosmikus> sorry
00:27:05 <kosmikus> typo
00:27:11 <kosmikus> I never meant it to be parameterized
00:27:18 <kosmikus> thanks for pointing that out
00:27:24 <kosmikus> alright, sorry, keep_learning
00:27:40 <kosmikus> what I meant it that "data TypedExpr where (:::) :: Eq t => Expr t -> Type t -> TypedExpr" is equivalent
00:28:04 <keep_learning> kosmikus: No problem :)
00:28:35 <kosmikus> the Eq constraint seems to be there, because   (:==) :: Eq t => Expr t   -> Expr t    -> Expr Bool
00:28:52 <kosmikus> is a constructor of their expression language (and requires the Eq constraint, too)
00:29:10 <keep_learning> what is the difference between parameterized and existential ( sorry if this question is very silly ) ?
00:29:33 <kosmikus> if you have a "Tree Int", you know the parameter, namely Int
00:29:45 <kosmikus> if you have a "TypedExpr", you only know there's some type "t" being used inside
00:29:52 <kosmikus> and you know it must be an Eq type in this case
00:29:56 <kosmikus> but you don't know which one it is
00:30:06 <kosmikus> so existential hide information
00:32:04 <keep_learning> kosmikus: Thank you :) Now it's bit clear to me.  He used existential to hide this information. Say if I am not tryting to hide the information so I can write it TypedExpr t = Expr t ::: Type t
00:32:22 <keep_learning> and will put the Eq t constraint in the function
00:32:59 <kosmikus> keep_learning: the point is that in order to write a function like infer further down
00:33:09 <kosmikus> keep_learning: you more or less need the existential
00:33:22 <kosmikus> keep_learning: infer :: E.Expr -> Maybe ...
00:33:30 <kosmikus> so it returns a Maybe because inference can fail
00:33:44 <kosmikus> but if it succeed, well, then it returns a Type, but you don't know which one
00:34:02 <kosmikus> but all types have different Haskell types
00:34:24 <kosmikus> if you'd write something like "infer :: E.Expr -> Maybe (Type t)"
00:34:28 <kosmikus> that wouldn't work
00:34:50 <kosmikus> because it would say that if inference succeeds, the expression must have all possible types
00:35:06 <kosmikus> you want a way to express that it must have *some* type
00:41:58 <keep_learning> kosmikus: Thank you
00:45:48 <Axman6> is there a good template for starting out a Cabal project? specifically a library?
00:45:59 <shachaf> cabal init
00:46:09 <Axman6> That'll do
00:49:58 <Axman6> shachaf: thanks, that's a welcome addition to cabal I hadn't seen before
00:50:28 <shachaf> It's an addition?
00:50:41 <Axman6> well, I don't remember it being around when I last played with Cabal
00:50:50 <shachaf> I don't remember it ever not existing. Not that I remember much.
00:50:53 <merijn> Axman6: You mean you used to create cabal files manualy? xD
00:51:03 <Axman6> possibly
00:51:09 <Axman6> I don't remember, it's been a while
00:54:13 <cin> cabal init was added in about 2010
00:54:35 <cin> before that people would make files by hand, yes, or more commonly: copy/paste from a project by dons
00:54:57 <Axman6> that sounds about right
00:56:28 * hackagebot ghc-imported-from 0.1.0.1 - Find the Haddock documentation for a symbol.  http://hackage.haskell.org/package/ghc-imported-from-0.1.0.1 (CarloHamalainen)
01:11:09 <lieven_> is there a way to turn a conduit Source into a pipe Producer? the pipes-conduit package in hackage seems to be old and wants to reinstall older versions of some stuff.
01:13:10 <Aetherspawn> lieven_: thats probably a bad idea.
01:13:43 <Aetherspawn> it might be easier to choose one or the other
01:13:57 <Aetherspawn> and write your own wrappers around whatever library they wrap
01:14:12 <lieven_> that makes sense
01:15:45 <Aetherspawn> I personally suggest pipes
01:16:18 <Aetherspawn> Gabriel is a wonderful maintainer and he actively maintains pipes as a main project whereas conduit feels kind of neglected under the yesod blanket imo
01:16:33 <Aetherspawn> there are more libraries available for conduit though
01:16:34 <johnw> conduit is in no way neglected
01:16:36 <johnw> are you kidding me?
01:16:37 <Axman6> Conduit has some pretty cool stuff though...
01:16:40 <lieven_> yeah I started with pipes put the persist library returns Sources
01:16:42 <johnw> it just got several major updates in the last 3 days
01:17:40 <johnw> <-- heavy conduit user
01:18:07 <rtpg> I've tried using conduit, I am still confused about some notions though
01:18:13 <johnw> like what?
01:18:15 <Aetherspawn> heavy pipes user here
01:18:19 <Aetherspawn> so its kind of stalemate.
01:18:21 <rtpg> the whole maybe wrapping of the yield value
01:18:29 <johnw> ?
01:18:31 <Aetherspawn> pipes does perform 5x better under purity than conduits though
01:18:32 <johnw> you mean, the await value?
01:18:33 <Axman6> eh?
01:18:36 <rtpg> await rather
01:18:49 <rtpg> When it returns Nothing, does it mean the entire system is about to shutdown?
01:18:50 <johnw> await returns a Maybe so that you know if upstream is done or not
01:18:50 <lieven_> I'm not experienced enough to have an opinion so enjoy yourself with the discussion :)
01:18:51 <Axman6> Aetherspawn: I wouldn't want to use either for pure computations though...
01:19:05 <johnw> it means the producer finished
01:19:39 <johnw> Aetherspawn: conduit just got a huge speed boost on pure computations
01:27:31 <the_berserker> @help
01:27:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:27:42 <the_berserker> @help list
01:27:42 <lambdabot> list [module|command]. Show commands for [module] or the module providing [command].
01:27:56 <Aetherspawn> ./msg lambdabot
01:28:03 <shachaf> /msg lambdabot @list
01:28:29 <Aetherspawn> I use @botsnack to initialize a conversation
01:28:44 <the_berserker> @unpl fmap map
01:28:44 <lambdabot> fmap map
01:29:30 <the_berserker> @unpl (.) (.) (.)
01:29:30 <lambdabot> (\ c e f i -> c (e f i))
01:30:09 <udevd> hi! is there better way to cast Double onto Complex Double other than (\x->x :+ 0) ? I have tried to search > a -> Complex a on hoogle, but with no results
01:30:41 <the_berserker> @unpl (.) ((.).(.).(.).(.)) ap
01:30:41 <lambdabot> (\ c e f i l o -> c >>= \ z -> (e f i l o) >>= \ y -> return (z y))
01:30:54 <shachaf> the_berserker: You can /msg lambdabot with these things. :-)
01:31:12 <verement> :t (:+ 0)
01:31:13 <lambdabot> Num a => a -> Complex a
01:31:23 <udevd> noep, it does x-> ix
01:31:25 <udevd> ;)
01:31:55 <blockman> :t [(:+ 0), realToFrac]
01:31:57 <lambdabot> RealFloat a => [a -> Complex a]
01:31:59 <the_berserker> @unpl \x -> x const ap const
01:31:59 <lambdabot> \ x -> x (\ a _ -> a) (\ f g -> f >>= \ d -> g >>= \ c -> return (d c)) (\ b _ -> b)
01:32:25 <the_berserker> Where did all the monadic chaning come from?
01:32:59 <Kaidelong> oh yeah of course
01:33:29 <the_berserker> @pl \x y z -> x z (y z)
01:33:29 <lambdabot> ap
01:33:43 <Kaidelong> oh blockman beat me to it
01:33:48 <the_berserker> @pl \f g x -> f (g x)
01:33:48 <lambdabot> (.)
01:34:53 <Kaidelong> @type fromDouble
01:34:54 <lambdabot> Not in scope: `fromDouble'
01:35:05 <Kaidelong> oh that's only for Hugs
01:35:07 <blockman> @src realToFrac
01:35:07 <lambdabot> realToFrac = fromRational . toRational
01:35:33 <blockman> udevd: (:+ 0) is the best way
01:37:09 <the_berserker> @pl \f -> f ap (\x y z -> x)
01:37:10 <lambdabot> flip ($ ap) (const . const)
01:37:18 <udevd> blockman: except it does not work
01:37:23 <udevd> > (:+ 0) 1
01:37:25 <lambdabot>  1 :+ 0
01:37:29 <udevd> oh wait it does xD
01:37:32 <udevd> thanks
01:37:54 <the_berserker> @pl \x -> x ap const
01:37:55 <lambdabot> flip ($ ap) const
01:38:17 <Kaidelong> so what's the internal representation of Complex numbers?
01:38:23 <shachaf> the_berserker: You should experiment with lambdabot using private messages unless you have something in particular you're demonstrating
01:38:25 <Kaidelong> powers of i as multiples of pi/2?
01:38:28 <shachaf> Kaidelong: :+ is a constructor.
01:38:34 <shachaf> @src Complex
01:38:34 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
01:38:35 <udevd> blockman: i just think GHC evaluates this 0 every time and (:+ 0) may be slow...
01:38:39 <the_berserker> @pl \x y z a b c -> (x a) (y b) (z c)
01:38:40 <lambdabot> ((flip . ((flip . ((.) .)) .)) .) . flip . ((.) .)
01:38:43 <Kaidelong> shachaf: I understand that part
01:38:58 <blockman> udevd: huh?
01:39:05 <udevd> oh, nevermind
01:39:12 <udevd> i just realized what i wrote
01:39:27 <shachaf> Kaidelong: Then which internal representation do you mean?
01:40:00 <Kaidelong> how is the complex part represented is what I was wondering
01:40:24 <blockman> Kaidelong: huh?
01:40:32 <Kaidelong> I know it literally is a floating point number but
01:40:45 <mr-> Kaidelong: data (RealFloat a) => Complex a = !a :+ !a, so just a tuple of something floatish
01:40:49 <Kaidelong> I more mean what values encode i, -i, -1
01:40:51 <shachaf> (a :+ b) is just (a + bi)
01:41:01 <Kaidelong> oh okay
01:41:04 <Kaidelong> I guess that makes sense
01:41:26 <blockman> > sqrt (-1) :: Complex Double
01:41:28 <lambdabot>  (-0.0) :+ 1.0
01:41:29 <Kaidelong> that's the obvious way
01:41:50 <Kaidelong> I guess I just can't get out of thinking of complex numbers as vectors because it's the only way I can really understand them
01:42:13 <mr-> Kaidelong: the tuple is a "vector", though
01:42:39 <Kaidelong> yeah but it's not stored in the form of magnitude + angle
01:43:11 <blockman> inb4 cartesian bear
01:43:41 <mr-> Kaidelong: that would be a bit annoying anyway, because of that angle = angle + 2pi property
01:44:52 <blockman> @let deriving instance (Ord a) => Ord (Complex a)
01:44:52 <lambdabot>  Parse failed: StandaloneDeriving is not enabled
01:47:29 <Kaidelong> mr-: Yes, that's exactly what I was wondering about
01:47:38 <Kaidelong> the obvious solution doesn't have that problem
01:47:45 <Kaidelong> for some reason it wasn't obvious to me
01:48:00 <Kaidelong> some kind of mental block I guess
01:48:25 <rawtass> I need some help with a small example I am working on: https://raw.github.com/Toeplitz/haskell/master/test.hs How to I traverse the Data structure and print the values for this example?
01:51:50 <Kaidelong> well first you need to implement Foldable and Functor
01:52:15 <Kaidelong> and both Test and Data have the wrong kinds to be Foldable, Functor, or Traversable
01:52:42 <ion> FWIW, s/first/also/
01:52:44 <Kaidelong> Data and Test have kinds * but you need the kind * -> *
01:55:14 <Kaidelong> rawtass: the best way to do it would just be to make a function \a -> [foo a, bar a], since both of them are of type Test
01:55:47 <rawtass> hm.. Ok. I may have to step back a bit. I don't know how to implement those.
01:57:07 <rawtass> Kaidelong: this is just a small example, I will have a huge data structure in my application with many more members. But I see that is a "quickfix" :)
02:01:41 * hackagebot websockets 0.8.1.2 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.8.1.2 (JasperVanDerJeugt)
02:03:46 <mr-> Kaidelong: of course you could either make your addition be aware of that property, or write your own Eq-instance
02:04:39 <Kaidelong> mr-: that would be one example of why not storing it in polar form is the superior thing to do
02:05:20 <Kaidelong> I am still a little perturbed that my intuition was to use the polar form when there was something better and more obvious
02:11:33 <MorehouseJ09> I'm very interested in haskell - but need to find a good place to write something to go to production
02:11:43 <MorehouseJ09> what are some good use cases / problems to solve with haskell?
02:12:12 <blockman> fibonacci numbers
02:12:44 <Axman6> MorehouseJ09: what takes your fancy? what've you written in the past?
02:12:56 <MorehouseJ09> blockman: already wrote that - I'm working in the live video space. Lots of encoding videos / rtmp and s3 interaction
02:13:13 <MorehouseJ09> how can I convince my investors to let me spend a month writing haskell code lol
02:14:10 <Kaidelong> the industrial applications as far as I can tell seem to be basically research, websites, and sometimes mission-critical software so long as it isn't real-time
02:14:12 <merijn> MorehouseJ09: I would say Haskell is excellent for networking/servers
02:14:28 <merijn> MorehouseJ09: Especially with the new 7.8 IO manager coming out
02:14:38 <MorehouseJ09> thats what I'm thinking - I'm writing a go rtmp server to process rtmp input streams
02:14:39 <Kaidelong> both of the last two suggest that people like haskell for robustness
02:15:02 <MorehouseJ09> I think haskell could be a great tool to use to write the outgoing rtmp server (ie: streaming a video to a bunch of clients)
02:15:12 <Kaidelong> so a bit like Ada or Eiffel except not nearly as awful as Ada
02:15:13 <merijn> MorehouseJ09: It's really nice to develop a server using lightweight threading :)
02:15:26 <Axman6> MorehouseJ09: you could learn a lot by implementing rtmp
02:15:38 <Axman6> Kaidelong: you take that back, Ada is an amazing language
02:15:45 <merijn> MorehouseJ09: If you plan to do streaming IO, look into pipes/conduits
02:15:47 <MorehouseJ09> how would the memory overhead be? I was originally going to use node to shoot out rtmp streams to clients
02:15:52 * Axman6 is actually a somewhat offended by that
02:16:07 <Kaidelong> I haven't had to touch it in a long time so I will do that for you, can't be bothered to defend not defending Ada
02:16:15 <merijn> MorehouseJ09: Those are libraries for deterministic resource usage in streaming IO
02:16:19 <MorehouseJ09> Axman6: indeed I could - would you recommend trying to swig wrap a c rtmp lib or doing it myself?
02:16:45 <Axman6> MorehouseJ09: where's the fun in bindings? do it yourself, much more fun!
02:16:47 <Kaidelong> oh
02:16:54 <merijn> MorehouseJ09: Depends, if you already know a C RTMP lib and need to be done fast, probably that. If you just wanna learn and already know RTMP, do it yourself :p
02:17:02 <MorehouseJ09> axman6 - agreed
02:17:12 <blockman> real haskellers use hsc2hs
02:17:12 <Kaidelong> I know haskell gets used for scripting and prototyping as well
02:17:18 <merijn> MorehouseJ09: Unlike node GHC will scale to multiple cores for your threading :)
02:17:26 <Kaidelong> so I guess you could also use it where you'd use something like Perl or Python
02:17:32 <MorehouseJ09> merijn: yes - I'm thinking of hacking something up by wrapping and then building my own rtmp when I have the time
02:17:34 <merijn> Kaidelong: I write my shell script drop-ins in haskell :p
02:17:36 <MorehouseJ09> I use a lot of python :)
02:17:58 <merijn> Instead of writing a one-off python script I just use haskell nowadays :)
02:18:10 <Kaidelong> Personally, I use haskell mostly for scripting and prototyping myself
02:18:15 <MorehouseJ09> so I'm pretty tdd driven - should i have that same mindset in the haskell community?
02:18:23 <MorehouseJ09> any must know tools / libs to work with?
02:18:38 <MorehouseJ09> I like to think i at least try to things the right way
02:18:40 <Kaidelong> the mainstream haskell style is very close to test driven development
02:19:00 <Kaidelong> you generally write your types first and use quickcheck to verify properties
02:19:22 <MorehouseJ09> Kaidelong: thanks - I'll be sure to check into them
02:19:26 <Kaidelong> not sure what people do for unit testing in IO heavy stuff - there is HUnit
02:20:25 <MorehouseJ09> nice this is awesome - I have a lot of googling to do tonight
02:20:45 <Kaidelong> unfortunately I don't think haskell has anything like System.Diagnostics from .NET but the type system gives a lot of the same functionality, somewhat counterintuitively
02:20:47 <MorehouseJ09> thanks for the quick chat - I'm sure I'll be on here with a few stupid questions (and hopefully a few smart ones)
02:20:59 <Axman6> @src State (>>=)
02:20:59 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
02:21:02 <Axman6> -_-
02:23:44 <dmj`> so, when one forks a thread in a web handler, the thread is terminated upon completion of the handler
02:24:12 <startling> hspec is nice for glueing a bunch of quickcheck properties together to make a test suite
02:24:40 <startling> it does HUnit stuff too, I believe, but I barely use that.
02:24:51 <johnw> yes, it does
02:24:56 <johnw> that's mainly how I use it (for HUnit)
02:26:25 <tero-> is there a way to get an email notification when a newer version of a package that my package is depending on is released?
02:26:49 <tero-> particularly when the version bounds are exceeded
02:27:34 <merijn> tero-: Not at the moment, but that sounds like a brilliant feature
02:27:39 <tero-> of course I will get one eventually from someone frustrated enough :)
02:27:48 <tero-> but I was thinking to provide a bit better service
02:28:46 <merijn> tero-: I think everyone would be in favour of this feature, it's just a matter who has the time and when to implement it :)
02:29:22 <merijn> If you're volunteering, I'd <3 you forever ;)
02:29:28 <tero-> heh
02:29:45 <mornfall> merijn: forever is a long time :-)
02:29:59 <merijn> mornfall: Well, it'd be a pretty cool feature :p
02:30:13 <startling> that sounds very handy.
02:30:25 <tero-> ideally it
02:30:30 <tero-> ideally it should be part of hackage
02:30:32 <mornfall> merijn: it'd also be handy to get an email when hackage finds out your package doesn't built with latest GHC/HP
02:30:55 <startling> mornfall: I don't think hackage does any building
02:30:59 <mornfall> (even better, it'd send you a patch :D)
02:31:13 <merijn> It doesn't need to build anything to detect exceeding version bounds
02:31:20 <merijn> Additionally, Hackage *does* building
02:31:29 <mornfall> hm, it used to, at least
02:31:45 <startling> is that just for haddock or something else?
02:31:48 <merijn> Hackage2.0 is open source, so patches for this feature would be more than welcome
02:32:03 <merijn> startling: Haddock requires the code builds succesfully, yes
02:32:10 <startling> that's kind of gross.
02:32:35 <mornfall> it used to show which GHC versions worked and which failed, but I can't see that anymore
02:32:36 <Kaidelong> It's terrible
02:32:48 <merijn> startling: There was a technical reason for that
02:32:58 <Kaidelong> it's still terrible
02:33:00 <merijn> mornfall: The build logs are hidden away in a different spot now
02:33:26 <tero-> it'd be nice to implement it and it doesn't seem too difficult but I'm choked with different chores for a while now until the second baby is born and the phd is submitted for review
02:33:34 <merijn> Kaidelong: Yes, if you have potential solutions, feel free to bring them up :)
02:33:40 <startling> merijn: what's that?
02:33:43 <mornfall> tero-: haha :-)
02:33:54 <jeronimo> is it considered ok to stop a thread by throwing exception in it with throwTo?
02:33:56 <mornfall> tero-: best excuse ever
02:33:59 <merijn> tero-: That sorta thing is mainly why we don't have these features (yet) ;)
02:34:03 <merijn> jeronimo: Sure
02:34:19 <merijn> jeronimo: If you keep in mind in the threads code that it can get interrupted
02:34:26 <jeronimo> yeah
02:34:30 <johnw> jeronimo: that's what async does with cancel, but it does let you recover that exception when you later 'wait'
02:34:46 <jeronimo> I see
02:35:01 <merijn> jeronimo: Basically, other than polling and MVar/TVar/whatever that's the only way to stop a thread :)
02:35:01 <johnw> in fact, I recommend using async whenever you can; I very rarely use forkIO
02:35:31 <merijn> jeronimo: And it's exactly what the exceptions are there for. Just be careful and use things like bracket for allocating resources
02:36:03 <blockman> @src exitSuccess
02:36:03 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:36:05 <jle`> why isn't there a `many` (as opposed to `many1`) in parsec?
02:36:09 <jeronimo> I've been joggling between plain threads and async actually. I like wait function in async, there doesn't seem to be a built in equivalent for Thread
02:36:18 <mornfall> jle`: coz it's dangerous
02:36:19 <johnw> jle`: because it's already in Alternative
02:36:33 <jle`> johnw: oh
02:36:38 <johnw> and it works with Parsec, so there is no need to duplicate; although, I do agree it should be re-exported perhaps
02:36:43 <merijn> jeronimo: Usually you implement that by passing an MVar/TVar to the thread and writing to it when it's done
02:36:43 <jle`> oh yeah.
02:36:48 <Kaidelong> If I remember right the technical reason was because documentation gets re-exported when you make modules that do nothing but export other modules
02:37:12 <johnw> jeronimo: what is Thread?
02:37:12 <Kaidelong> also because the web pages made have type annotations
02:37:24 <jeronimo> merijn ok. btw what did you mean by this? "use things like bracket for allocating resources"
02:37:31 <blockman> @hoogle bracket
02:37:32 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:37:32 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:37:32 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:37:49 <jeronimo> johwn I meant ThreadId. buit in threads
02:37:59 <jle`> oh wait
02:38:02 <jle`> it is in Parsec
02:38:08 <jle`> in Text.Parsec.Prim
02:38:16 <johnw> jeronimo: asyncThreadId?
02:38:37 <jle`> and it *does* trigger an ambiguity in ghc
02:39:04 <jle`> oh well
02:39:12 <merijn> jeronimo: The bracket function from Control.Exception
02:39:25 <jeronimo> johwn I don't know what that is. by `Thread' I meant `ThreadId', which is what forkIO creates
02:39:41 <merijn> jeronimo: It installs a free "handler" which will always run even if you run into an exception
02:40:01 <mornfall> jle`: doesn't world end when you nest two parsers that can both succeed with no input?
02:40:27 <merijn> jeronimo: i.e. "bracket (openFile "foo") hClose (\hnd -> doStuffWith hnd)" will run doStuffWith and will always run hClose even if an exception is raised
02:40:33 <jeronimo> merijn looks like it does the same job as finally?
02:40:45 <merijn> jeronimo: finally has a race condition
02:41:09 <johnw> jeronimo: you can call asyncThreadId on an Async a to get a ThreadId
02:41:11 <jeronimo> so bracket should always be used instead?
02:41:25 <Tekmo> jeronimo: That's right
02:41:40 <merijn> jeronimo: If you do "do { hnd <- openFile "foo"; (doStuffWith hnd) `finally` hClose hnd }" <- what if an exception is raised in between openFile and the "finally"?
02:42:01 <merijn> jeronimo: You won't clean up the file handle causing a resource leak
02:42:33 <merijn> i.e. if the exception happens at the ";" in that code
02:42:57 <mornfall> sometimes you wish you could do RAII in Haskell's IO
02:43:01 <jeronimo> merijn in other words if we call throwTo or similar from another thread in between openFile and doStuffWith ?
02:43:56 <Tekmo> mornfall: That's basicaly why Rust exists
02:44:18 <merijn> jeronimo: Yeah
02:44:18 <mornfall> Tekmo: is there a Rust monad in Haskell or what? :P
02:44:42 <Tekmo> mornfall: No, I mean Rust the language
02:44:50 <mornfall> Tekmo: looks like Algol to me
02:44:58 <merijn> jeronimo: bracket prevents that by blocking exceptions until the handler has been installed and only unblocking them when that's done
02:44:59 <jeronimo> are there plans to remove finally because of this?
02:45:10 <jeronimo> merijn yeah, got it
02:45:13 <merijn> jeronimo: No, because finally is useful for non-asynchronous exception
02:45:25 <merijn> jeronimo: i.e. if you only use throw instead of throwTo
02:45:57 <Tekmo> Finally is also useful if you have no initial acquisition step
02:45:59 <mgsloan> reader-update-state-transformer seems plausible
02:46:14 <mgsloan> dunno what update would be tho
02:46:18 <Tekmo> Producer
02:46:23 <Tekmo> Producer is basically Writer done right
02:46:34 <jeronimo> merijn yeah but code that currently catches throw could easily become code that also has to catch throwTo one day
02:47:03 <Tekmo> mgsloan: To be more precise, it's "Writer [a] done right"
02:47:25 <mgsloan> Tekmo: Ah, it avoids the list concatenation slowdown?
02:47:29 <jeronimo> and then you have a hard to replicate bug that appears to work most of the time.. the worst kind of bug
02:47:36 <Tekmo> mgsloan: It streams the results immediately, too
02:47:45 <Tekmo> mgsloan: You don't have to wait for the computation to finish to begin processing updates
02:47:50 <Kaidelong> wasn't writer a very simple monad over the covariant functor on functions?
02:47:52 <mgsloan> Nice!
02:48:30 <Tekmo> mgsloan: You can also always translate it to the equivalent `Writer` computation using `Pipes.Prelude.toList/toListM`, but usually it's better to stream the results
02:48:50 <Kaidelong> and reader a bit stranger because it's on the contravariant input although it still behaves covariantly because it represents a shared argument
02:49:14 <Kaidelong> feed-in composition
02:49:50 <randomclown> @pl \(x,y) -> f x y
02:49:51 <lambdabot> uncurry f
02:50:05 <merijn> jeronimo: finally is rather a bit of a low level primitive, i.e. bracket is implemented using finally
02:50:19 <Tekmo> @source bracket
02:50:20 <lambdabot> Unknown command, try @list
02:50:22 <Tekmo> @src bracket
02:50:23 <lambdabot> bracket before after thing = block $ do
02:50:23 <lambdabot>     a <- before
02:50:23 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
02:50:23 <lambdabot>     after a
02:50:23 <lambdabot>     return r
02:50:34 <Tekmo> Hmm.
02:50:36 <Tekmo> That code is old
02:50:48 <danr> Is there a dual to newtype Fix f = Roll (f (Fix f)) ?
02:50:49 <Tekmo> `bracket` has used `mask` instead of `block` for a while now
02:50:53 <danr> some kind of cofix
02:50:54 <danr> :P
02:51:19 <mornfall> do you mean data?
02:51:45 <Tekmo> So my limited understanding is that there are two duals: least fixed points and greatest fixed points, but in Haskell you can't distinguish them, so you have just one type of `Fix`
02:51:59 <danr> Tekmo: right, I guess
02:52:31 <Tekmo> danr: This might interest you, maybe: http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
02:53:31 <danr> Tekmo: thanks
02:53:41 <Tekmo> danr: You're welcome
02:54:19 <Twey> Tekmo: I don't understand the difference between a least fixed point of a type and a greatest fixed point
02:54:45 <danr> Tekmo: this is very helpful, I think this will lead me forward. Thanks again :)
02:54:54 <Tekmo> danr: No problem at all :)
02:55:04 <johnw> Twey: "Technically, whether the least or greatest fixed point is used depends on the construction (e.g. catamorphisms use least, anamorphisms use greatest)."  Although in Haskell the definition of the fixed points will coincide
02:55:11 <johnw> from http://osdir.com/ml/haskell-cafe@haskell.org/2009-10/msg02718.html
02:55:17 <Twey> Oh, right.
02:55:22 <Twey> Thanks!
02:56:02 <Tekmo> Twey: So, I might get this wrong, but let me give it a shot, roughly cribbing from that Wadler post
02:57:37 <Tekmo> Twey: So let's say that `LFix F` is the least-fixed point of the functor `F`
02:57:55 <Tekmo> Twey: Similarly, let's call `GFix F` the greatest fixed point of the functor `F`
02:58:10 <Tekmo> Least fixed points are defined by how you consume them
02:58:29 <Tekmo> Basically, if you have a function of type (F X -> X), you can then convert that to a function of type `(LFix F X -> X)`
02:58:32 <Tekmo> Or in other words:
02:58:40 <Tekmo> (F X -> X) -> (LFix F X -> X)
02:58:51 <Tekmo> With greatest fixed points, you have the dual scenario
02:58:56 <Tekmo> If you have a function of type (X -> FX)
02:59:06 <Tekmo> You can transform that into a function of type (X -> GFix F X)
02:59:09 <Tekmo> Or in other words:
02:59:16 <Twey> I see
02:59:17 <Tekmo> (X -> F X) -> (X -> GFix F X)
02:59:26 <Twey> And they coïncide in Haskell because of laziness?
02:59:29 <Tekmo> I think I'm missing a forall in there somewhere
02:59:46 <mr-> (Is the point that one gives rise to initial algebras and the other to final coalgebras?)
02:59:48 <Tekmo> Twey: I think so
02:59:55 <Twey> Neat, thanks
03:00:00 <Tekmo> Twey: You're welcome
03:00:24 <Twey> mr-: I think so
03:00:30 <Tekmo> mr-: I don't remember.  It's been a long time since I read the Wadler post and I didn't get it completely the first time
03:01:04 <Tekmo> mr-: But I'm pretty sure the answer to your question is in that link
03:01:31 <mr-> Ok, thanks
03:01:54 <Tekmo> You're welcome
03:02:09 <johnw> mr-: I think that if you have a least fixed point of a functor, you can transform an initial algebra in the manner Tekmo described, aka catamorphically
03:08:51 <mmmm> I have a Card datatype, which has fields name, cost etc.. some cards though, depend on the context when they are played so it seems natural to define these cards as functions from State -> Card, but I can't do this as then you're unable to access the name/cost of an unplayed card, how is best to proceed?
03:10:45 <DarkFox> Can anyone here point me to some documentation for 'update Constructor {..} = ...' ?
03:11:09 <DarkFox> (Literal "{..}" which ghci tells me I need -XRecordWildCards)
03:12:20 <DarkFox> Seeming as if it's importing all of the construcutors' components while appearing to be two arguments.... Why is this? Why "Record {..}" and not (Record {..}) ?
03:12:32 <Axman6> DarkFox: if you have data Foo = Foo {bar :: X, baz :: Y}, then update Foo {..} gives you values you can use inside the body of update named foo with type X and and baz with yupe Y
03:12:36 <Axman6> type*
03:12:56 <DarkFox> Axman6: I understand what it's doing; I don't see any documentation for the feature however.
03:12:59 <Axman6> DarkFox: yeah, I just asked myself the same question, it seems really odd to me too
03:13:05 <mgsloan> DarkFox: http://www.haskell.org/ghc/docs/7.6.2/html/users_guide/syntax-extns.html#record-wildcards
03:13:36 <DarkFox> Thanks mgsloan, I was about to search for that term; was looking at the source code I found it in because it didn't have that LANGUAGE flag
03:13:51 <DarkFox> Seems very interesting
03:13:58 <DarkFox> Axman6: Very very odd
03:14:23 <lars2> jhf
03:14:30 <mgsloan> Yeah, it's really convenient!  The unfortunate thing about it is that without this extension it'd be possible to reliably reason about scope shadowing without global knowledge
03:15:18 <Aetherspawn> Say I need to use an IntSet, but inside a monad
03:15:22 <DarkFox> mgsloan: After finding this; I'm thinking about all the code where x@(a b c d e f _ _ _ z) is used ;)
03:15:23 <Aetherspawn> with a definition like this :
03:15:24 <Aetherspawn> foldr' :: (Int -> b -> b) -> b -> IntSet -> b
03:15:36 <Aetherspawn> how do I use a monad with it in the function (Int -> b -> b ) ?
03:16:39 <DarkFox> x@(T a b c d _ _ g) *
03:17:08 <vlatkoB> Is there a way to define a synonym for data constructor? For example, something in the form of: type None = Nothing
03:18:05 <danr> vlatkoB: in development, yes: https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
03:19:44 <Aetherspawn> :k IO Int
03:19:44 <lambdabot> *
03:19:48 <Aetherspawn> :k b
03:19:49 <lambdabot> Not in scope: type variable `b'
03:19:51 <mgsloan> DarkFox: Yup!  Especially because it can be used for construction too.  A common pattern is to use a wildcard to deconstruct, and then reconstruct with one thing changed
03:20:07 <mgsloan> (well, if you're not using lens and such :) )
03:20:11 <vlatkoB> danr: Thanks, I'll take a look at it
03:20:20 <DarkFox> mgsloan: Indeed
03:20:34 <DarkFox> mgsloan: I lack the ... patience for lenses ;)
03:20:47 <jeronimo> Aetherspawn I don't know what you're trying to do, but foldr (and probably your version of it) will happily use IO if the types match.. here's sequence_ implementation with foldr:
03:20:55 <jeronimo> :t foldr (>>) (return ()) [print "hi", print "there"]
03:20:56 <lambdabot> IO ()
03:21:10 <Aetherspawn> jeronimo: I just realised that the kinds work out :)
03:21:17 <Aetherspawn> I wonder then
03:21:17 <DarkFox> jeronimo: Did you expect anything else?
03:21:24 <Aetherspawn> why mapM and map ?
03:21:29 <mgsloan> DarkFox: You might like data-lens - much of the power of lens - with minimal fuss
03:21:34 <jeronimo> DarkFox I was answering Aetherspawn's question
03:21:38 <Aetherspawn> whats the difference, is it just mapM unpacks the IO ?
03:21:40 <DarkFox> jeronimo: I just nocied
03:21:42 <DarkFox> Sorry
03:21:45 <mgsloan> lens-family-core is good too, for ignoring the massiveness of lens proper
03:21:47 <DarkFox> mgsloan: I might...
03:21:49 <jeronimo> no problem
03:22:00 <DarkFox> mgsloan: I'll check the former
03:22:06 <DarkFox> data-lens that is
03:22:18 <jeronimo> @src mapM
03:22:18 <lambdabot> mapM f as = sequence (map f as)
03:22:28 <jeronimo> Aetherspawn yes
03:23:02 * DarkFox notes to use sequence with care
03:23:06 <DarkFox> @src replicateM
03:23:06 <lambdabot> replicateM n x = sequence (replicate n x)
03:23:09 <Aetherspawn> hmm, okay, I think I can make this work.
03:23:11 <DarkFox> That a lot more :D
03:24:31 <DarkFox> (+=), (!+=), (-=), (!-=), (*=), (!*=) :: (Functor m, Monad m, Num b) => Lens a b -> b -> StateT a m ()
03:24:40 <DarkFox> Nice addition to the syntax :P
03:25:29 <mr-> DarkFox: why is there care to be taken when using sequence? ;-)
03:26:13 * DarkFox rusty and forgot where it is...
03:26:16 <DarkFox> @hoogle replicatem
03:26:17 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
03:26:17 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
03:26:17 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
03:26:19 <DarkFox> ty
03:26:20 <DarkFox> lol
03:26:45 <Tekmo> mr-: Because `sequence` loads all results into memory before returning them
03:27:03 <Tekmo> mr-: It's better to use `pipes` if you want to stream the results
03:27:12 <DarkFox> replicateM 2 "abc"
03:27:22 <DarkFox> Tekmo: Answer it before me :(
03:28:08 <mr-> Tekmo: Ah, so using sequence to get the "cartesian" product of lists may not be a good idea. That's actually a problem I am having at the moment :-)
03:28:13 <Aetherspawn> pipes is great :)
03:28:14 <Tekmo> mr-: You can convert `ios :: [IO a]` to `p :: Producer a IO ()` using `forM_ ios $ \io -> lift io >>= yield`
03:28:26 <Tekmo> mr-: For pure computations it's fine
03:28:34 <Tekmo> mr-: usually
03:28:56 <Tekmo> mr-: Usually when people advise against `sequence` it's because of things like this: `sequence :: [IO a] -> IO [a]`
03:29:02 <simpson> @src sequence
03:29:02 <lambdabot> sequence []     = return []
03:29:03 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:29:03 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
03:29:41 <DarkFox> What's pipes?
03:29:47 <Tekmo> My streaming library
03:29:54 <Aetherspawn> @where pipes
03:29:55 <mr-> Tekmo: So something like filter .. $ sequence [[1..n],[1..m],[1..o]] should be fine?
03:29:55 <lambdabot> http://hackage.haskell.org/package/pipes
03:29:57 <DarkFox> Interesting
03:30:09 <Tekmo> DarkFox: Here's the tutorial: http://hackage.haskell.org/package/pipes-4.0.2/docs/Pipes-Tutorial.html
03:30:31 <Tekmo> DarkFox: The tutorial pretty much begins with "Use pipes instead of `mapM`/`forM`/`sequence`"
03:30:53 <DarkFox> Ha
03:30:54 <Tekmo> DarkFox: It also provides the correct `ListT` that streams
03:30:55 <DarkFox> Nice
03:31:07 <DarkFox> Tekmo: I'll have to play with this now :)
03:31:10 <Tekmo> DarkFox: :)
03:31:20 <Aetherspawn> thanks for answering my email Tekmo, I think I'll be able to nail this now
03:31:25 <DarkFox> Nice work
03:31:52 <Aetherspawn> my only concern is the memory usage when I put everything in a data structure and I haven't figured out a good way of handling that yet.
03:31:53 <Tekmo> Thanks :)
03:32:30 <Tekmo> Aetherspawn: Yeah, the only way you can fix that is to incorporate `IO` actions or `Producer`s into it to defer doing the computation until you need it
03:33:03 * DarkFox wonders how a distributed hash table will work in Haskell...
03:33:23 * DarkFox wants to create one for key management (similar to; more of an alternate to; gpg)
03:33:36 <Aetherspawn> make redis in haskell
03:33:51 <randomclown> DarkFox: surely there's a haskell torrent app
03:33:57 <DarkFox> randomclown: There are
03:34:15 <randomclown> that has to have a DHT in it
03:34:22 <mr-> aww... length $ filter (even.sum) $ sequence [[1..100000], [1..100000],[1..100000]] eats all my memory
03:35:05 <Aetherspawn> mr-: memory leak
03:35:06 <DarkFox> randomclown: I've checked them a little, but yet to understand how they are working exactly :P
03:35:11 <DarkFox> Aetherspawn: Indeed
03:35:16 <DarkFox> mr-: Too much in ram!
03:35:25 <Aetherspawn> because it looks something like this:
03:35:46 <Aetherspawn> vs <- sequence xs
03:36:01 <Aetherspawn> return (v:vs)
03:36:22 <Aetherspawn> the sequence there is recursive and each one holds another v/vs
03:36:25 <Aetherspawn> eventually you run out of memory
03:36:50 <Aetherspawn> I think its the same difference between foldl/foldr
03:36:52 * hackagebot pcre-utils 0.1.0.1 - Perl-like substitute and split for PCRE regexps.  http://hackage.haskell.org/package/pcre-utils-0.1.0.1 (SimonMarechal)
03:37:34 <Aetherspawn> night
03:37:43 <mr-> Aetherspawn: thanks
03:38:32 <Tekmo> mr-: This will not leak if you use `pipes`
03:38:36 <Tekmo> mr-: Let me write it up for you
03:40:02 <mr-> Finally, a reason to look at pipes :-)
03:45:51 <Tekmo> mr-: Here you go: http://lpaste.net/99034
03:45:58 <Tekmo> mr-: Runs in constant space, but takes a very long time
03:46:02 <Tekmo> mr-: Modify it as you need to
03:46:36 <mr-> Great, thanks :-)
03:46:44 <Tekmo> You're welcome! :)
03:54:45 <udevd> is >x `seq` x equal to simple x? hlint is saying that it is reduntant...
03:55:14 <DarkFox> @src seq
03:55:14 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
03:55:21 <supki> udevd: it is
03:55:22 <DarkFox> @hoogle seq
03:55:22 <lambdabot> Prelude seq :: a -> b -> b
03:55:22 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:55:22 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
03:55:48 <supki> udevd: x `seq` x means "evaluate x when you evaluate x"
03:55:56 <supki> which is obviously redundant :)
03:56:02 <udevd> then what shall i do when i want my x evalueated once for whole program run :P?
03:56:08 <udevd> evalueated*
03:56:15 <DarkFox> supki: What if IO ?
03:56:25 <DarkFox> :P
03:56:29 <supki> DarkFox: ?
03:56:47 <DarkFox> Nvm
03:57:08 <supki> you can evaluate IO things all day long without any I/O to happen
03:57:36 <supki> udevd: not sure I understand, can you paste your code?
03:58:04 <DarkFox> udevd: Evaluated *
03:58:13 <supki> udevd: general pattern is  x `seq` f x  where  f  is some function that does something with  x
03:58:34 <supki> so x gets evaluated when you call f
03:58:55 <merijn> supki: Rather, to be more precise
03:59:05 <udevd> http://lpaste.net/99035 you see, i'm using vecdPauli very often
03:59:18 <udevd> so i want to make sure that >base
03:59:25 <udevd> is computed only once
03:59:35 <merijn> "x `seq` f x" means IFF both 'x' and 'f x' are NOT bottom, then after evaluating "x `seq` f x" both 'x' and 'f x' will have been evaluated
03:59:39 <udevd> rather than reevaluated whenever i call vecdPauli
04:00:07 <merijn> The order of evaluation is undefined, so if either is a bottom you will not be sure which bottom you get
04:01:41 <udevd> hm?
04:01:49 <DarkFox> seq _ y = y
04:01:52 <DarkFox> Hmm
04:02:10 <DarkFox> Why pre-evaluate x in the first place?
04:02:38 <DarkFox> Is it so that the f doesn't just evaluate parts of x?
04:03:05 <DarkFox> In such case; how would _ mean to acturally evaluate it?
04:03:07 <DarkFox> O_O
04:03:18 <danr> no
04:03:28 <danr> seq is built-in
04:03:42 <DarkFox> danr: It's in Prelude.hs
04:03:56 <danr> yes
04:04:00 <supki> udevd: you can pass base a parameter to vecdPauli
04:04:04 <DarkFox> Prelude ≠ built in
04:04:09 <supki> DarkFox: seq is a compiler primitive
04:04:14 <supki> it's not definable in Haskell
04:04:19 <ReinH> Any given x will be evaluated exactly zero or one times per program run
04:04:23 <DarkFox> O_O
04:04:25 <ReinH> seq won't change that
04:04:31 <DarkFox> supki: Then why is it defined in haskell?
04:04:36 <notdan> The version in Prelude is given for compatibility I assume
04:04:43 <DarkFox> For compat with other compilers?
04:04:46 <supki> DarkFox: it's not, it's ghc magic
04:04:54 <notdan> in case you are running a compiler that does not support 'seq' as a primitive
04:05:04 <DarkFox> supki: Then shouldn't have seq be defined with if not ghc?
04:05:41 <notdan> and btw on my system it's in GHC.Prim
04:05:52 <udevd> supki: that's not really helpful
04:06:04 <udevd> :P
04:06:44 <mr-> still, if you hide the Prelude, seq is gone too
04:06:45 <udevd> really there is not way to tell compiler 'this does not even depend on value passed to function, store it for later use'?
04:07:12 <ReinH> udevd: I'm not sure what you're asking
04:07:29 <simpson> udevd: What are you building?
04:07:40 <udevd> ReinH: consider f x = let a=2*2 in a*x
04:07:59 <udevd> i want a to not be evaluated from scratch every time i call f
04:08:13 <Tekmo> udevd: Then just partially apply it to `f`
04:08:20 <ReinH> udevd: that has nothing to do with seq
04:08:20 <Tekmo> Oh wait
04:08:27 <Tekmo> I thought the name of the function was `consider`.  Never mind
04:08:30 <ReinH> it has to do with sharing
04:08:31 <udevd> then how do i do it?
04:08:55 <Tekmo> udevd: ghc takes care of that for you
04:09:00 <udevd> simpson: random walk in multidimensional body of quantum states :P
04:09:03 <Tekmo> udevd: ghc will float `a` to a top-level shared value
04:09:09 <udevd> oh, okay
04:09:14 <udevd> so it is done automatically?
04:09:16 <Tekmo> Yes
04:09:18 <DarkFox> rtyuiop
04:09:19 <udevd> that reassures me somehow
04:09:21 <DarkFox> Erm
04:09:26 <notdan> mr-: well yeah
04:09:30 <Tekmo> udevd: Just make sure you compile with `-O2`
04:09:32 <notdan> mr-: you can import GHC.Prim alternatively
04:10:53 <Tekmo> udevd: `ghc` can do a lot of nice optimizations because of all the purity restrictions
04:14:57 <ReinH> Tekmo: well, if f is polymorphic the DMR might kick in and prevent sharing
04:16:23 <Tekmo> ReinH: Yes
04:16:38 <Tekmo> Fortunately, that is pretty rare
04:16:53 <ReinH> well, f could be Num a => a -> a :p
04:18:08 <Tekmo> Yes, the the monomorphism restriction is on by default, so it's hard to create an internal polymorphic function by accident
04:20:47 <ReinH> Tekmo: well, let doesn't generalize so never mind
04:31:58 * hackagebot egison-tutorial 3.2.3 - A tutorial program for the programming language Egison  http://hackage.haskell.org/package/egison-tutorial-3.2.3 (SatoshiEgi)
04:42:39 <HugoDaniel> so i went all smart ass and tried to use a mutable vector to keep some data, i just unsafeThawed and unsafeFreezed it in and did the changes in between
04:42:47 <HugoDaniel> criterion reported that the thing was running fast
04:43:43 <HugoDaniel> i was happy, until the day i tried to compare it with intmap, intmap was slower in creterion for the operations i was trying to do, but in practice it was *much* faster
04:44:04 <HugoDaniel> because of some reason GC was going nuts with the unsafeThaw's and unsafeFreeze's
04:44:29 <danr> unsafe as in unsafe... :)
04:44:30 <Tekmo> Did you try safe versions?
04:44:53 <HugoDaniel> Tekmo: no, but i assume those are slower for vectors because they are O(n) and not O(1)
04:45:33 <HugoDaniel> i can try it :)
04:45:36 <HugoDaniel> let me see heheh
04:47:18 <Tekmo> You should always approach optimization and debugging scientifically.  There is no question too dumb to ask or a test too dumb to run
04:47:54 <HugoDaniel> yes, but my scientific approach to optimization in this case optimized itself to just use an intmap
04:48:11 <HugoDaniel> but let me exaustive :)
04:48:25 <Axman6> HugoDaniel: unboxed or boxed arrays?
04:48:55 <HugoDaniel> well its a boxed vector of (unboxed vector, int)
04:49:59 <HugoDaniel> perhaps i could use unboxed vector of (unboxed vector, int) since they are all unboxed, but in my mind using unboxed is always bad in haskell because sooner or later things will get boxed and you pay the price twice
04:50:19 <HugoDaniel> but im stupid
04:50:20 <Axman6> Vector (UVector a, Int)?
04:50:28 <HugoDaniel> yes
04:51:05 <HugoDaniel> the insert is just a unsafeThaw, grow, write, unsafeFreeze
04:51:34 <HugoDaniel> i was just testing insertion
04:52:18 <rawtass> Kaidelong: this is just a small example, I will have a huge data structure in my application with many more members. But I see that is a "quickfix" :)
04:52:21 <HugoDaniel> i was trying to do an alternative to IntSet
04:52:44 <HugoDaniel> but IntSet inserts much faster, occupies lesser memory, and doesn't spend 80% of the time in GC
04:53:00 <Axman6> tried unordered-containers?
04:53:04 <HugoDaniel> oh
04:53:08 <HugoDaniel> no
04:53:10 <Axman6> curious which would be faster
04:53:19 <Axman6> it's got a HashSet
04:53:24 <HugoDaniel> in criterion my approach kicks the arse out of intset
04:53:28 <Axman6> and hash for Int is id I think
04:53:31 <HugoDaniel> ...in practice GC says no
04:54:48 <HugoDaniel> i guess haskell gc must be optimized for immutable data types
04:54:53 <Tekmo> HugoDaniel: You're appending to a vector?
04:54:58 <HugoDaniel> Tekmo: yes
04:55:04 <Tekmo> Yeah, that's your problem
04:55:04 <Fuuzetsu> Is there a way to define ‘some’ and ‘many’ from Alternative in Agda so that it likes it and doesn't complain about non-termination?
04:55:49 <Tekmo> HugoDaniel: Have you considered what happens if there is something residing in memory past your vector?
04:55:58 <HugoDaniel> my next approach will be to append a bunch of empty data, keep the free available size, and then only append when that size reaches zero
04:56:02 <HugoDaniel> Tekmo: i haven't :D
04:56:07 <Axman6> Tekmo: Vectors can be safely resized
04:56:08 <Tekmo> HugoDaniel: It has to be relocated
04:56:18 <Axman6>  /grown
04:56:26 <HugoDaniel> Tekmo: im doing it in ST monad
04:56:33 <Axman6> (it should be a simple realloc)
04:56:46 <Tekmo> It's a simpel realloc if there is free memory past the end of the vector
04:57:06 <Axman6> and if there isn't, realloc copies the contents of the array and frees the old pointer
04:57:14 <Tekmo> Right, but he's trying to avoid copies
04:57:42 <Axman6> well, calling grow, which he said he was, should just be doing that
04:58:04 <HugoDaniel> unsafeGrow :)
04:58:13 <Axman6> HugoDaniel: that doesn't sound particularly pure to me, if two functions grow the same value, they're probably going to clobber each other
04:58:18 <Tekmo> Right, but I think his issue is that his vector is being stored in compacted memory, so every time he appends it is being copied, killing performance
04:59:37 <HugoDaniel> anyway, IntSet is great
05:00:17 <Tekmo> IntMap is great, too
05:00:23 <HugoDaniel> yes
05:00:45 <Axman6> HugoDaniel: mind benchmarking HashSet too?
05:01:00 <HugoDaniel> hashset ? ok, no problem
05:01:11 <Axman6> thanks =)
05:01:14 <Axman6> just curious
05:01:26 <Axman6> and if it turns out to be harder than expected, don't bother
05:02:11 <HugoDaniel> in criterion my approach with the vector with thaw/freeze is much faster than intset, but when i profile both of them in other code i see that it is about 3x slower
05:02:34 <HugoDaniel> perhaps criterion only allows GC to act between benchmarks or something like that
05:02:47 <HugoDaniel> Axman6: let me do it, ill paste the results
05:02:51 <HugoDaniel> hashset here i go
05:03:31 <Tekmo> HugoDaniel: I believe criterion runs the garbage collector in between benchmarks
05:03:43 <Tekmo> HugoDaniel: It has an option to explicitly set or disable this.  I don't remember what the default is, though
05:07:53 <honza> is there a way to force an io action?  i'd like to execute something before the io action and immediately after but it seems that laziness kicks in and things get out of order --- i tried using `seq` and `deepseq` to no avail
05:08:21 <Tekmo> honza: Are you using a lazy IO action?
05:09:12 <honza> Tekmo: it's a glorified System.Cmd.system call
05:11:20 <Tekmo> So unless lazy IO is being used, `IO` actions will always run in order
05:13:03 <honza> and i assume in the default case that means within a single thread
05:15:24 <narendraj9> hi everyone! I was just wondering if there is a gsoc project that uses haskell as its language?
05:15:28 <HugoDaniel> honza: did you try the deepseq force ?
05:15:58 <Axman6> narendraj9: there were about 12 or so in the last GSoC
05:16:11 <honza> HugoDaniel: yes but didn't end up getting it to work, a huge rabbit hole
05:16:17 <Axman6> @google haskell reddit GSoC review
05:16:18 <lambdabot> http://www.reddit.com/r/haskell/comments/1f6ve7/haskellorg_google_summer_of_code_2013_approved/
05:16:18 <lambdabot> Title: [haskell.org Google Summer of Code 2013] Approved Projects : haskell
05:16:27 <mr-> narendraj9: haskell.org itself has been participating
05:16:28 <Axman6> hmm, that's not what I wanted
05:18:06 <narendraj9> Is anyone who has worked on them here?
05:18:38 <Tekmo> http://www.reddit.com/r/haskell/comments/1v80ld/summer_of_code_2013_retrospective/
05:19:03 <o1iver> Hey. I am looking to build a web-dashboard that monitors git repositories and displays real-time information about commits, as well as statistics. I have been looking at the gitlib library to interface with git, but it seems very complex. Does anybody know of any example applications and/or tutorials?
05:19:29 <Axman6> narendraj9: http://www.gwern.net/Haskell%20Summer%20of%20Code#section-7 for some details of the most recent one
05:19:31 <danilo2> Hello All! :) I would like to ask you if is it possible to write the following code in better way (more clear and increase overall beauty :) ). I'm using lenses, but I do not a lens-master yet and there is probably a way to do it much simplier, than this. This is just updating some values : (http://lpaste.net/99037)
05:19:41 <HugoDaniel> Axman6 et al: here are the results of the benchmarks: http://lpaste.net/99038
05:21:18 <Tekmo> o1iver: There is a Git.Tutorial module: http://hackage.haskell.org/package/gitlib-2.2.0.0/docs/Git-Tutorial.html
05:21:40 <honza> basically, executing a "sleep 2" bash command wrapped by two getCPUTime calls should result into two times being off by roughly 2s - haskell however reports something like 5-10ms
05:22:13 <Tekmo> honza: Oh
05:22:28 <Tekmo> honza: `sleep` is probably screwing with CPU time because it sleeps the process
05:22:32 <Tekmo> honza: You want wall time, not CPU time
05:22:49 <Axman6> that doesn't sound right...
05:23:17 <Axman6> CPU time is the number of cycles executed since boot
05:23:21 <Axman6> (roughly)
05:23:34 <Axman6> HugoDaniel: so, based on that, what're you going to use? =)
05:23:39 <Tekmo> I thought if a process slept it didn't count towards it's CPU time
05:23:49 <HugoDaniel> intset :)
05:24:01 <Axman6> that shouldn't be what getCPUTime is doing though
05:24:04 <HugoDaniel> its much faster than hashset, specially in membership test
05:24:07 <Axman6> s/doing/using/
05:24:26 <HugoDaniel> for huge values it pays off very well
05:24:30 <Axman6> HugoDaniel: excellent, sounds like it's doing what at's designed to do then :P
05:24:44 * Axman6 goes back ot pointer arithmetic
05:24:45 <Tekmo> So maybe what is happening is that `system` is forking a thread
05:25:01 <jfischoff> o1iver: johnw is the author, he is very active here. If you have questions and he isn't here you can leave messages for him with lambdabot
05:25:02 <Tekmo> That might explain why it returns immediately
05:25:25 <Axman6> Tekmo: I'd be really surprised if it were
05:25:47 <Axman6> HugoDaniel: what happens when you execute threadDelay 2000000 instead of calling sleep?
05:25:48 <jfischoff> Tekmo: I haven't had time to look at the code you sent me more closely, but I don't think they are the same
05:25:50 <Axman6> uh, H1FuelCell_
05:25:51 <Tekmo> Or maybe there is a typo in his function and it's not actually calling sleep and is instead erroring out immediately
05:25:51 <Axman6> rstklhaesfkjghadf
05:25:55 <supki> danilo2: I've annotated your paste
05:25:56 <Axman6> honza even!
05:25:58 <Tekmo> jfischoff: They totally are
05:26:01 <Tekmo> jfischoff: I even gave you core!
05:26:10 <jfischoff> which looks different
05:26:16 <H1FuelCell_> Axman6... yes ?
05:26:24 <Axman6> H1FuelCell_: wrong person, sorry =)
05:26:27 <jfischoff> mine is going to be slower
05:26:41 <Tekmo> jfischoff: What's the difference?
05:26:52 <danilo2> supki: Thank you! seems a lot nicer than the original one! :) Can we do even better? Or this is he best we can achive?
05:27:26 <Tekmo> jfischoff: Oh
05:27:29 <Tekmo> jfischoff: I see what you mean
05:27:35 <Tekmo> jfischoff: Yours is a numerically stable average
05:27:41 <jfischoff> yeah
05:28:34 <jfischoff> can Fold accommodate that?
05:28:55 <danilo2> supki: Thank you very much for this! I've got now to read what does these function mean, but it is cool :) thanks!
05:29:45 <supki> danilo2: what part of it you think could be better?
05:30:49 <supki> danilo2: you can use  use  instead of  ^.  to get things from state
05:31:33 <supki> (also  .=  instead of  .~)
05:31:35 <o1iver> Tekmo: thanks for that link, but the tutorials seem outdated (at least I can't get them to work).
05:32:08 <danilo2> supki: Oh .= instead of .~ is nice! What do you mean by this "use"? I do not see it yet
05:32:25 <Tekmo> @tell jfischoff Yes, but you can't built it from simpler folds.  You'd just replace `foldl'` with the `Fold` constructor
05:32:25 <lambdabot> Consider it noted.
05:32:56 <danilo2> supki: I do not think it is not nice now - I just love nice and clean code and I'm always asking mysefl "Can we do it better?" :)
05:38:27 <supki> danilo2: use l = gets (view l)
05:38:39 <supki> danilo2: first two definition in the let block look like this
05:39:02 <DarkFox> How should one store a 160-bit number? No Word160 :( Lol
05:39:05 <supki> danilo2: and I didn't mean to imply you think code is awful, just was curious :)
05:39:48 <supki> actually first three definitions
05:42:05 <merijn> DarkFox: (Word64, Word64, Word32)?
05:42:13 <merijn> DarkFox: That or use Integer?
05:42:20 <DarkFox> Heh
05:42:28 <c_wraith> Integer seems easiest.
05:42:30 <DarkFox> I think I'll be using the former
05:42:59 <DarkFox> c_wraith: But that would waste ram :P
05:43:02 <c_wraith> 160...  doing SHA?
05:43:36 <DarkFox> c_wraith: Using it as a baseline for key fingerprints. GPG, GNUnet, bitcoin etc etc all use 160-bit identifiers.
05:44:03 <danilo2> supki: heh :) Thank you very much!
05:44:18 <merijn> There should be a library for arbitrary fixed size integers...
05:44:43 <merijn> If anyone's looking for a nice learning project ;)
05:45:24 <darthdeus> hey guys, could someone please help me out a bit with this error message? http://lpaste.net/99040 I'm still pretty confused between ByteString and String :| and why it prints such a long name
05:45:44 <darthdeus> i mean why is it bytestring-0.10.0.2:Data.ByteString.Lazy.Internal.ByteString and not just ByteString?
05:46:01 <c_wraith> darthdeus: usually it shows a very long name like that if you don't have the type imported
05:46:31 <c_wraith> darthdeus: and ByteString is a packed sequence of bytes.  Whereas String is a linked list of unicode characters.  Very different.
05:47:17 <darthdeus> that makes sense, thanks :)
05:47:23 <darthdeus> but i'm passing in a String
05:47:35 <darthdeus> is it getting converted somewhere inside?
05:47:36 <c_wraith> darthdeus: though lazy ByteString, which is mentioned there, is a bit special - it's actually a linked list of packed byte sequences.  Somewhere in between
05:48:06 <darthdeus> i'm mostly confused because i've added http-conduit to my build-depends, so i thought it would require all the dependencies
05:48:34 <Axman6> darthdeus: what's the type of simpleHttp?
05:49:11 <darthdeus> simpleHttp
05:49:11 <darthdeus>   :: Control.Monad.IO.Class.MonadIO m =>
05:49:11 <darthdeus>      String -> m Data.ByteString.Lazy.Internal.ByteString
05:50:00 <Axman6> darthdeus: it seems that it returns  ByteString, which you can'r print using putStrLn, which requires a String. you either need to use one of the ByteString printing functions from Data.ByteStrin.Lazy or convert the bytestring into a String (I'd recommend the former)
05:50:48 <c_wraith> ... really bizarre. I can't load lpaste.net
05:51:03 <dhrosa> me either
05:51:07 <HugoDaniel> darthdeus: sit back, use show, and enjoy the melody of thrash :)
05:51:19 <Axman6> darthdeus: add this to the top of your file: import qualified Data.ByteString.Lazy as BSL, and then replace putStrLn with BSL.putStrLn
05:52:17 <honza> just tried using getCurrentTime instead of getCPUTime and getting the same thing
05:52:32 <Axman6> honza: did you try using threadDelay?
05:53:14 <honza> Axman6: that doesn't do what i want :
05:53:37 <darthdeus> oh i didn't notice the error was on the line below :)
05:53:40 <darthdeus> thanks guys
05:53:48 <Axman6> honza: right, but I'm trying to help you figure out why your code isn't working
05:54:22 <honza> Axman6: sorry - i'm not sure how that fits into my problem
05:54:40 <honza> put that in the middle and see if the time increases?
05:54:41 <Axman6> honza: because it lets us figure out why it's returning such short times
05:54:45 <Axman6> yes
05:54:49 <honza> kk
05:55:09 <Axman6> I think the problem ias that system doesn't wait for the command to finish before returning
05:55:19 <Axman6> there are other functions that let you wait though
05:57:30 <honza> Axman6: threadDelay seems to have no effect
05:57:42 <merijn> honza: What value are you passing it?
05:57:54 <Axman6> you need to pass it 2000000 for a 2 second sleep
05:57:56 <merijn> honza: Keep in mind threadDelay expects micro or nano seconds (I forgot which)
05:58:07 <honza> micro, dammit
05:58:08 <Axman6> micro I believe
05:58:38 <merijn> honza: Common mistake :)
05:58:50 <Axman6> honza: I'd try using runProcess and then waiting on its ProcessHandle with waitForProcess
05:59:00 <honza> alright, threadDelay of 1s doubles the time
05:59:10 <honza> from 6ms to 13ms
05:59:31 <honza> Axman6: k
05:59:38 <quicksilver> strange decision really
05:59:49 <quicksilver> why go for Integer microseconds and not just use Rational
06:00:11 <quicksilver> oh it's not Integer, it's Int
06:00:13 <Axman6> who knows man, none of it really makes much sense
06:00:19 <Axman6> yeah
06:00:20 <quicksilver> that's probably why, but that's a strange place to optimise
06:00:52 <quicksilver> there is an advantage to using Int if you think it might be called in a tight loop but that's not really likely with threadDelay
06:01:55 <Axman6> quicksilver: I'd guess that's what the epoll stuff underlying it expects
06:02:17 <quicksilver> it didn't used to be epoll, Axman6
06:02:36 <Axman6> right, but whatever it was using would have been a C interface expecting an int
06:02:40 <quicksilver> it used to be a select loop
06:03:02 <c_wraith> actually, last I checked, threadDelay of very large numbers doesn't work on OS X
06:03:12 <c_wraith> You get some very strange errors out of it
06:03:15 <honza> lol
06:03:18 <quicksilver> select() takes a struct timeval
06:04:41 <Axman6> maybe it's using usleep... no
06:05:49 <merijn> Fun fact, sufficiently large threadDelay arguments will crash your code on OSX and result in infinite delay on linux :)
06:06:03 <merijn> At least, I'm pretty sure that wasn't fixed before 7.6.3 was released
06:06:13 <merijn> Axman6: It's using epoll
06:06:16 <merijn> And/or select
06:06:33 <Axman6> quicksilver: i'd be really surprised if select was used for delays in the past, it doesn't make much sense. the timeval for select is the maximum wait time for any of the fds to produce an event
06:06:41 <merijn> Thread delay is handled by the runtime's alarm scheduler which is in the select/epoll looop
06:07:00 <honza> i have 7.6.3 is that old?
06:07:10 <Axman6> honza: no, it's the most recent release
06:07:11 <merijn> honza: Yes and no
06:07:16 <honza> :)
06:07:20 <honza> make up your mind
06:07:21 <Axman6> 7.8 is in the works, but not released yet
06:07:22 <Tekmo> honza: I use 7.4.
06:07:24 <merijn> honza: It's the most recent stable release, but by now it's 1.5 years old
06:07:33 <honza> lol i see
06:07:44 <Axman6> Tekmo: dinosaur
06:07:49 <merijn> honza: 7.8 should be getting release Any Moment Now (TM)
06:07:49 <Tekmo> :)
06:07:52 <Axman6> merijn: shit, really?
06:08:09 <merijn> Axman6: That's what I saw in the discussion of the new HP release
06:08:21 <honza> should i try a more cutting edge version of ghc?
06:08:28 <merijn> honza: Not as a beginner
06:08:36 <honza> sounds good
06:09:11 <merijn> honza: There's lots of new cool features in there, but most of the are more advanced/experimental things. Not something you should be concerned about as a beginner
06:09:21 <Axman6> I've been using haskell for 6 yearts and won't use unreleased version og GHC, too scary (and crap breaks enough with each new stable release)
06:09:38 <merijn> Axman6: It's not *that* scary
06:09:48 <Tekmo> Axman6 has the scars to prove it
06:10:17 <merijn> honza: But basically, it's a trade-off of cool new extensions (and in 7.8 the new IO manager) vs non of the libraries being tested for the new release
06:10:38 <merijn> honza: So it tends to be inadvisable unless you're at least a bit comfortable troubleshooting breaking things :)
06:11:18 <honza> merijn: lol, the entire haskell thing is rather uncomfortable and full of troubleshooting
06:12:32 <Axman6> it's 1:10AM and my code keeps compiling, what's going on
06:13:11 <merijn> Axman6: :)
06:14:02 <Axman6> at some point I'll have to test it...
06:27:12 * hackagebot fixed-vector 0.6.1.0 - Generic vectors with statically known size.  http://hackage.haskell.org/package/fixed-vector-0.6.1.0 (AlexeyKhudyakov)
06:30:26 <bernalex> how do you do "return true" in haskell? i.e. how do you give an exit status/int?
06:30:48 <Jeanne-Kamikaze> exit ?
06:31:06 <bennofs> bernalex: for main? Use System.Exit.exitFailure or System.Exit.exitSuccess
06:31:07 <bernalex> ah. System.Exit. thanks!
06:31:09 <Jeanne-Kamikaze> exitWith
06:31:14 <bernalex> bennofs: yes, found it. thanks.
06:31:52 <Iceland_jack> bernalex: ‘return’ in Haskell is very different from ‘return’ in C
06:32:02 <bernalex> Iceland_jack: I know.
06:36:34 <dzianis> http://lpaste.net/99042 this code consume a lot of memory. When I use ($!!) in reqAndProcess it crashes with "user error (openTCPConnection: host lookup failure for "foobar.com")" or "socket: resource exhausted (Too many open files)". What am i doing wrong?
06:39:41 <c_wraith> I've got this terrible idea that I should write a monad tutorial.  Someone, please stop me.
06:39:47 <jonkri> Is there some way aeson can produce (non-string) error messages when parsing JSON?
06:39:58 <jonkri> s/messages/types
06:40:58 <Iceland_jack> c_wraith: You probably shouldn't write a monad tutorial.
06:41:22 <dhrosa> it is possible not advisiable for you  to write a  monad tutorial
06:41:23 <Iceland_jack> Burrito tutorials on the other hand
06:41:26 <dhrosa> possibly*
06:41:35 <c_wraith> Good thing I don't know enough category theory to write the tutorial I have in mind.
06:41:53 <Yaniel> Yes a burrito tutorial. We need that.
06:42:22 <dhrosa> but seriously, knowing that IO is a monad when learning about monads just m akes everything confusing :(
06:42:29 <c_wraith> I know less about burritos than I do about monads.  Well.  That's mostly because burritos are way more complicated than monads.
06:42:56 <Iceland_jack> Take some time off Haskell hacking then, start making food :)
06:43:14 <merijn> c_wraith: I *am* writing a monad tutorial :<
06:43:30 <merijn> c_wraith: In my defense, it involves functors, applicatives, laws and not a single analogy!
06:44:02 <Yaniel> ls
06:44:06 <zerokarmaleft> bonus points for writing in LaTeX
06:44:11 <c_wraith> merijn: what approach are you taking?  The thing I have in mind is actually a Category tutorial that kind of throws in Kleisli categories
06:44:36 <merijn> c_wraith: Well, it's not so much a tutorial as it is an explanation of the functor/applicative/monad hierarchy
06:45:07 <merijn> c_wraith: Since I spend 5 times writing an elaborate answer to the question "Why are monads more powerful than functors?" in here I figured I might as well write it up well once and for all :p
06:45:16 <merijn> So that I can just link it :p
06:45:50 <c_wraith> Ooh.  I answered "Why is monad more powerful than applicative" in a particularly good way on SO
06:46:06 <merijn> c_wraith: Maybe I saw your answer
06:46:11 <dhrosa> link it?
06:46:14 <c_wraith> merijn: http://stackoverflow.com/questions/17409260/what-advantage-does-monad-give-us-over-an-applicative/17412969#17412969
06:46:23 <c_wraith> that's apparently my highest-rated SO answer ever
06:47:22 <merijn> c_wraith: Right, but I wanna start from Functor and discuss laws and then show several datatypes and how trying to make them lawful applicative/monad succeeds/fails and how that results what you can do
06:47:32 <merijn> c_wraith: So a more elaborate constructive version of that answer
06:47:38 <zerokarmaleft> that isn't in the typeclassopedia?
06:47:52 <c_wraith> typeclassopedia is sort of brief
06:47:56 <c_wraith> I think he wants a lot more depth
06:48:06 <zerokarmaleft> fair enough
06:48:20 <merijn> zerokarmaleft: Typeclassopedia covers that in theory, but newbies gloss over the implications due to the brevity in typeclassopedia
06:50:38 <HugoDaniel> ahah didn't knew about Typeclassopedia
06:50:39 <HugoDaniel> :D
06:50:58 <HugoDaniel> amazing, whole family entertainment
06:51:30 <zerokarmaleft> HugoDaniel: yea, it's a good resource, with a lot of rabbit holes to go more in-depth
06:51:49 <c_wraith> But ultimately, I feel like the Kleisli category thing is the best way to explain what a monad is.  This is probably a totally unfounded thing. :)
06:52:25 <HugoDaniel> i should learn about type theory
06:52:44 <c_wraith> I've never learned formal type theory.  All those greek letters scare me.
06:52:50 <HugoDaniel> here is my monad tutorial: deriving (Monad)
06:52:57 <HugoDaniel> two words monad tutorial
06:56:13 <asmyers> Anyone know why I would get an empty string with ByteString.readFile but not with prelude.readFile?
06:56:32 <c_wraith> asmyers: If that's the only difference, I can't see a reason
06:56:35 <asmyers> Prelude.readFile "/proc/3437/statm" gives me the content of the file
06:56:54 <asmyers> B.readFile "/proc/3437/statm" gives me ""
06:57:18 <HugoDaniel> define "gives me" ?
06:57:20 <asmyers> where B => Data.ByteString
06:57:34 <asmyers> HugoDaniel: is the result in ghci
06:57:38 <c_wraith> I bet it has to do with it being /proc somehow
06:57:58 <c_wraith> Can you read anything out of /proc with bytestring's readFile?
06:58:34 <asmyers> c_wraith: everything I've tried gives the empty bytestring
06:59:04 <honza> Axman6: merijn: HugoDaniel: here is a paste of the "system" and getCPUTime weirdness if you're interested http://lpaste.net/99047
06:59:36 <c_wraith> asmyers: a quick check of the source for readFile shows that it starts with hFileSize.  I bet that's returning 0 for things in proc
07:00:10 <dhrosa> yeah I think proc returns 0 size files
07:00:20 <c_wraith> asmyers: This is worthy of a bug report for the bytestring lib
07:02:19 <piezoid> hi
07:02:21 <piezoid> why hoogle have two database (default and platform) ? which one is used ?
07:02:55 <HugoDaniel> honza: can you try printing the value right after the first getCPUTime ?
07:03:04 <HugoDaniel> thats my usual (lame) approach :)
07:03:39 <honza> HugoDaniel: what does that do?
07:04:24 <merijn> honza: Eh, getCPUtime doesn't return real time at all
07:04:25 <HugoDaniel> dont know, also system spans a new thread
07:04:32 <asmyers> c_wraith: Okay, thanks for looking.  I was wondering if there was some known gotcha with /proc
07:04:40 <HugoDaniel> honza: use threadDelay instead of system
07:04:43 <merijn> HugoDaniel: There is a far more fundamental problem
07:05:17 <merijn> HugoDaniel, honza: getCPUtime docs: "Computation getCPUTime returns the number of picoseconds CPU time used by the current program."
07:05:25 <HugoDaniel> ah
07:05:30 <HugoDaniel> :D
07:05:36 <merijn> HugoDaniel, honza: "CPU time used" == "time actually spent running on the CPU"
07:05:59 <merijn> HugoDaniel, honza: Time spent blocking on another process is not calculated
07:06:12 <merijn> Because blocked processes don't use CPU time
07:06:12 <HugoDaniel> yes exactly
07:06:30 <HugoDaniel> use getCurrentTime instead of CPUTime
07:06:46 <HugoDaniel> i think its on Data.Time.Clock or something
07:07:07 <HugoDaniel> honza: if you are planing to do something serious consider using criterion instead
07:08:46 <honza> dammit, that works
07:09:04 <honza> merijn: HugoDaniel: thanks guys, problem solved
07:09:12 <merijn> honza: :)
07:09:34 <honza> such n00b, very dumb, wow
07:09:35 <HugoDaniel> np
07:10:09 <HugoDaniel> merijn was the one who hunt the bug with a headshot
07:10:28 <merijn> Mad skillz :p
07:10:34 <HugoDaniel> ahah
07:10:49 <merijn> Where "Mad skillz" == "read docs of things I don't know" :p
07:15:32 <the_berserker> @version
07:15:32 <lambdabot> lambdabot 5.0-int-e
07:15:32 <lambdabot> git clone git://github.com/int-e/lambdabot.git
07:17:16 <the_berserker> @unpl flip flio
07:17:17 <lambdabot> (\ b c -> flio c b)
07:17:40 <the_berserker> @unpl flip (flip ap) const
07:17:40 <lambdabot> (\ c b -> (c >>= \ h -> return ((\ g _ -> g) b h)) b)
07:18:10 <the_berserker> @pl \x -> x ap const
07:18:11 <lambdabot> flip ($ ap) const
07:18:38 <the_berserker> @unpl flip (.)
07:18:38 <lambdabot> (\ b c f -> c (b f))
07:19:05 <the_berserker> @pl flip id
07:19:05 <lambdabot> flip id
07:19:17 <the_berserker> @pl flip <$>
07:19:17 <lambdabot> (line 1, column 9):
07:19:17 <lambdabot> unexpected end of input
07:19:17 <lambdabot> expecting white space or simple term
07:19:21 <HugoDaniel> flipping the lambdabot :)
07:20:02 <the_berserker> @unpl ap const ap ap const id id (.) flip flip
07:20:03 <lambdabot> (\ q -> return ((\ a _ -> a) q ((\ w x -> w >>= \ u -> x >>= \ t -> return (u t)) q)) q) (\ ac ad -> ac >>= \ aa -> ad >>= \ z -> return (aa z)) (\ b _ -> b) (\ c -> c) (\ d -> d) (\ e f g -> e (f g)) (\ h i j -> h j i) (\ k l m -> k m l)
07:21:35 <the_berserker> @unpl (ap . ap . const) (id . fmap) ((>>=) . (return . flip))
07:21:35 <lambdabot> (\ f -> return ((\ v b -> (v >>= \ r -> return ((\ _ -> fmap) b r)) b) f ((\ ac -> (>>=) (return (\ d e -> ac e d))) f)) f)
07:22:36 <the_berserker> @unpl fix ap
07:22:37 <lambdabot> fix (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
07:22:46 <the_berserker> > fix ap
07:22:48 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = a0 -> a0
07:22:48 <lambdabot>  Expected type: (a0 -> a0 -> b0) -> a0 -> a0 -> b0
07:22:48 <lambdabot>    Actual type: (a0 -> a0 -> b0) -> (a0 -> a0) -> a0 -> b0
07:23:14 <the_berserker> > fix const
07:23:15 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = b0 -> a0
07:23:15 <lambdabot>  Expected type: a0 -> a0
07:23:15 <lambdabot>    Actual type: a0 -> b0 -> a0
07:23:34 <merijn_> the_berserker: You can't print functions
07:24:08 <the_berserker> merijn_: I was trying to blow up lambdabot
07:24:33 <the_berserker> Can you use explicit infinite types in Haskell?
07:24:50 <the_berserker> > fix fix
07:24:51 <lambdabot>  Occurs check: cannot construct the infinite type: a0 = a0 -> a0
07:24:51 <lambdabot>  Expected type: (a0 -> a0) -> a0 -> a0
07:24:51 <lambdabot>    Actual type: (a0 -> a0) -> a0
07:24:57 <geekosaur> nope
07:25:31 <c_wraith> was fix broken?
07:25:44 <the_berserker> > fix id
07:25:48 <lambdabot>  mueval-core: Time limit exceeded
07:25:49 <c_wraith> :t fix const fix
07:25:50 <lambdabot>     Occurs check: cannot construct the infinite type:
07:25:50 <lambdabot>       t0 = ((a0 -> a0) -> a0) -> t0
07:25:50 <lambdabot>     Expected type: (((a0 -> a0) -> a0) -> t0)
07:26:11 <c_wraith> err.
07:26:13 <c_wraith> :t fix const
07:26:14 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = b0 -> a0
07:26:14 <lambdabot>     Expected type: a0 -> a0
07:26:14 <lambdabot>       Actual type: a0 -> b0 -> a0
07:26:20 <c_wraith> oh, right
07:26:26 <c_wraith> :t fix $ const fix
07:26:26 <lambdabot> (a -> a) -> a
07:26:37 <c_wraith> if you're constantly fixing money, it's fixed.
07:27:32 <the_berserker> > x where x=5
07:27:33 <lambdabot>  <hint>:1:3: parse error on input `where'
07:27:47 <the_berserker> > let x=5 in x
07:27:48 <Tekmo> > let x = 5 in x
07:27:49 <lambdabot>  5
07:27:49 <lambdabot>  5
07:28:38 <mr-> :t const (fix id) -- unsafePerformEverything :-)
07:28:39 <lambdabot> b -> a
07:29:13 <c_wraith> mr-: nah, that one's safe.  It hangs before it does anything not typesafe. :)
07:29:31 <the_berserker> > scanl (+) 0 [0..]
07:29:32 <lambdabot>  [0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253...
07:30:01 <mr-> c_wraith: spoilsport :-)
07:30:28 <c_wraith> hey Tekmo, you like categories a lot.  Is there a resource somewhere that gives a simple summary of provable properties about categories?
07:30:50 <the_berserker> > let x = 1 : 2 : 5 : scanl (+) 0 x in x
07:30:51 <lambdabot>  [1,2,5,0,1,3,8,8,9,12,20,28,37,49,69,97,134,183,252,349,483,666,918,1267,175...
07:30:54 <c_wraith> > scanl (+) 0 [1..] -- the_berserker, is this what you were looking for?
07:30:55 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
07:31:18 <c_wraith> It's only slightly different. :)
07:31:41 <the_berserker> What is unsafePerformEverything?
07:31:50 <Tekmo> the_berserker: You probably wanted something like `scanl (+) 0 (drop 3 x)
07:32:01 <saml> :t unsafePerformEverything
07:32:02 <lambdabot> Not in scope: `unsafePerformEverything'
07:32:24 <mm_freak_> Tekmo: hi there =)
07:32:25 <saml> you see how expressive that is?
07:32:35 <saml> > scanl (+) 0 (drop 3 x)
07:32:36 <lambdabot>  Couldn't match expected type `[b0]'
07:32:36 <lambdabot>              with actual type `Debug.SimpleReflect.Expr.Expr'
07:32:51 <Tekmo> mm_freak_: Hi!
07:32:59 <mm_freak_> Tekmo: i believe i could contribute a lot to pipes-bytestring and pipes-text
07:32:59 <Tekmo> mm_freak_: Did you get to see my example?
07:33:06 <Tekmo> mm_freak_: I think so, too! :)
07:33:09 <the_berserker> > let x = 0 : 1 : scanl (*) 1 x in drop 2 x
07:33:10 <mm_freak_> Tekmo: gimme some context
07:33:10 <lambdabot>  [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
07:33:47 <the_berserker> > let x = 1 : 2 : scanl (*) 1 x in drop 2 x
07:33:49 <lambdabot>  [1,1,2,2,2,4,8,16,64,512,8192,524288,268435456,2199023255552,115292150460684...
07:33:51 <Tekmo> mm_freak_: `pipes-bytestring` is pretty much feature-complete at this point
07:33:58 <Tekmo> mm_freak_: `pipes-text` is where active development is
07:34:00 <saml> that's fibonacci
07:34:22 <Tekmo> mm_freak_: That involves mainly porting `pipes-bytestring` functionality to `text` equivalents and also providing decoding/encoding lenses
07:34:29 <c_wraith> > let fibs = 0 : scanl (+) 1 fibs in fibs
07:34:30 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:34:52 <the_berserker> let x = 0 : 1 : scanl (+) 0 x in drop 2 x
07:35:03 <mm_freak_> Tekmo: yes, but it could use some more speed…  i have more efficient versions of some of the proxies, some of them begin faster by a factor of 10
07:35:03 <Tekmo> mm_freak_: Michael Thompson has been leading that effort, although I told him to wait until the new `pipes-parse` came out before doing more work
07:35:10 <Tekmo> mm_freak_: Great!
07:35:13 <Tekmo> mm_freak_: Let me check them out
07:35:24 <the_berserker> > let x = 0 : 1 : scanl (+) 0 x in drop 2 x
07:35:25 <lambdabot>  [0,0,1,1,1,2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872,1278,1873,274...
07:35:50 <mm_freak_> Tekmo: alright…  i will just paste my versions somewhere later
07:36:33 <Tekmo> > let x = 0 : 1 : zipWith (+) x (drop 2 x)
07:36:34 <lambdabot>  not an expression: `let x = 0 : 1 : zipWith (+) x (drop 2 x)'
07:36:40 <Tekmo> > let x = 0 : 1 : zipWith (+) x (drop 2 x) in x
07:36:43 <lambdabot>  mueval-core: Time limit exceeded
07:36:48 <Tekmo> > let x = 0 : 1 : 1: zipWith (+) x (drop 2 x) in x
07:36:49 <lambdabot>  [0,1,1,1,2,3,4,6,9,13,19,28,41,60,88,129,189,277,406,595,872,1278,1873,2745,...
07:37:10 <Tekmo> mm_freak_: How did you optimize them?
07:37:36 <mm_freak_> Tekmo: by using different APIs, by working chunkwise (instead of bytewise), etc.
07:37:45 <mm_freak_> by removing unnecessary indirections
07:37:46 <mm_freak_> etc.
07:38:40 <mm_freak_> sometimes even by using 'copy' at the right place =)
07:39:53 <Tekmo> mm_freak_: Interesting
07:42:19 <Tekmo> mm_freak_: Also, are you developing against `pipes-bytestring` HEAD?
07:42:37 <Tekmo> mm_freak_: It shouldn't change much, but the main differences are the addition of lenses
07:42:49 <mm_freak_> Tekmo: right now i'm simply ignoring pipes-bytestring and doing my own stuff
07:43:09 <mm_freak_> except for the file readers and writers
07:44:01 <mm_freak_> i have a few terabytes to process, so even minor speed improvements can have a big impact
07:44:28 <Tekmo> mm_freak_: I don't know how much this relates, but I remember I once was trying to optimize serialization speed
07:44:44 <Tekmo> mm_freak_: I got 5x performance improvements by not using bytestrings at all and directly reading/writing to handles
07:44:57 <Tekmo> mm_freak_: I just used `Storable` to access buffers and did copies directly to handle buffers
07:45:27 <Tekmo> mm_freak_: This is basically what I did: https://github.com/Gabriel439/suns-search/blob/master/src/HSerialize/Core.hs
07:48:12 <fragamus> edwardk: I want to use linear for a V5 but there is no V5
07:53:07 <mm_freak_> Tekmo: yeah, i had a similar idea, but instead of using Storable directly it could be beneficial to use 'vector' with Data.Vector.Storable
07:53:28 <mm_freak_> Tekmo: fusion alone should provide major speed improvements
07:53:35 <Tekmo> mm_freak_: I'm way ahead of you: https://github.com/Gabriel439/suns-search/blob/master/src/HSerialize/Vector.hs
07:55:25 <mm_freak_> Tekmo: i mean as a replacement for bytestring in stream handling
07:57:36 <Tekmo> mm_freak_: Ooooh
08:04:35 <Tekmo> mm_freak_: Did you see the line counting example I sent you?
08:04:56 <mm_freak_> Tekmo: i think no, could you resend it?
08:06:31 <kallisti> trying to convert a ByteString representing a zip archive into a Text value is probably going to break right?
08:07:04 <geekosaur> I would expect so
08:07:14 <robstewartuk> pwd
08:07:30 <kallisti> /irc/freenode/haskell
08:07:39 <Tekmo> mm_freak_: http://lpaste.net/99030
08:08:01 <geekosaur> irc://freenode.net/#haskell :p
08:08:09 <robstewartuk> kallisti geekosaur: :-)
08:08:21 <mm_freak_> Tekmo: looks lensy =)
08:08:31 <kallisti> geekosaur: oh wait it's actually a base64 encoded zip archive
08:08:36 <kallisti> so that should be fine
08:08:40 <Tekmo> mm_freak_: That's because it is using lenses
08:08:58 <Tekmo> mm_freak_: You can also do cool things like
08:09:05 <merijn_> kallisti: Depends on: 1) What you mean by fine and 2) which encoding you use for the decoding
08:09:10 <robstewartuk> Looking at GHC.Conc, is there a function that returns a Bool indicating whether or not +RTS -Nn was actually specified?
08:09:13 <Tekmo> mm_freak_: over lines (takes 10) stdin
08:09:15 <robstewartuk> http://hackage.haskell.org/package/base-4.6.0.1/docs/GHC-Conc.html
08:09:21 <Tekmo> mm_freak_: That takes the first 10 lines of standard input
08:09:32 <Tekmo> mm_freak_: Also, `unlines = from lines`
08:09:59 <mm_freak_> Tekmo: i don't have much lens experience
08:10:17 <mm_freak_> but yeah, it looks elegant
08:11:12 <robstewartuk> Presumably `numCapabilities` returns 1 as a default if +RTS -Nn is not specified.
08:11:42 <robstewartuk> I'm looking for a function that returns Nothing, or Bool, in the case where +RTS -Nn has not been specified a the commmand line.
08:11:43 <robstewartuk> ?
08:12:39 <mm_freak_> robstewartuk: it returns whatever the default is
08:12:50 <mm_freak_> you can preset RTS options when compiling
08:13:14 <mm_freak_> robstewartuk: if you want different handling, you can always provide your own command line interface
08:14:14 <robstewartuk> My use case is: If a user has not specified with -Nn, then I will use getNumProcessor with setNumCapabilities to use all processors.
08:14:34 <robstewartuk> But, if -Nn is set, then just let the use decide.
08:14:51 <mm_freak_> robstewartuk: just use -N
08:14:53 <mm_freak_> no argument
08:15:20 <robstewartuk> (and if they want to use one core, let them).
08:15:25 <danilo2> Hello! When using lenses we could write (m & (at 1) ?~ 2) to set a value in map, is there any way to lookup a value using only lenses?
08:16:36 <Tekmo> Maybe: m ^? at 1
08:16:52 <robstewartuk> mm_freak_: I don't follow... again, if nothing is set with -Nn, then I will setNumCapabilities. If the user has used -Nn, then I will let them use the number of cores they have asked for in n.
08:16:55 <supki> or m ^, at 1
08:17:23 <robstewartuk> But If the default is 1, and they have asked for 1, then the GHC.Conc API gives me no way of knowing if they used -Nn or not.
08:17:25 * hackagebot nerf 0.5.2 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.5.2 (JakubWaszczuk)
08:17:33 <supki> err, ^.
08:18:00 <danilo2> Tekmo: It gives double packed value - like Just(Just 1))
08:18:06 <mm_freak_> robstewartuk: you can pass "-N" with no argument to use all available CPUs
08:18:13 <Tekmo> Then it's probably (^.), like supki suggested
08:18:15 <ion> “m ^. at 1” or “m ^? ix 1”
08:18:27 <danilo2> Tekmo, ion: ahhh ^. works, ok thanks!
08:18:59 <danilo2> Tekmo, ion: I'm falling in love with lenses :D
08:19:09 <danilo2> supki: Thanks!
08:19:13 <ion> “at” lets you delete by setting something to Nothing, “ix” is a direct traversal to the values.
08:19:42 <danilo2> ion: I know about the at and deletion, ix is still a bit magical to me, but I have to read about it more
08:20:03 <ion> Thus m ^? at 1 also returns a Maybe (because of “at”) inside a Maybe (because of (^?)).
08:21:20 <Tekmo> ion: So `ix n = at n . traverse`? (more or less)
08:21:44 <danilo2> Tekmo: yes - I get it more or less. I feel whats going on under the hood :)
08:22:15 <merijn_> mm_freak_: The point robstewartuk is making that that requires explicit user interaction
08:22:23 <supki> Tekmo: yes, this law should hold for all well-behaving instances
08:22:26 <merijn_> mm_freak_: He wants to default to all cores if the user makes no choice
08:22:34 <mm_freak_> merijn_: it doesn't…  you can make -N the default using a GHC flag
08:22:55 <merijn_> mm_freak_: Ah, right
08:22:56 <ion> tekmo: The definition of ix in terms of at is essentially that: http://hackage.haskell.org/package/lens-3.10.1/docs/src/Control-Lens-At.html#ixAt
08:22:57 <mm_freak_> something along the lines of "default RTS options"
08:23:05 <mm_freak_> robstewartuk: look into the manual
08:23:09 <mm_freak_> for that flag
08:23:43 <robstewartuk> mm_freak_: but how does that allow me to utilise all cores on a per-machine basis?
08:23:58 <robstewartuk> Surely I have to set a static constant for this flag?
08:24:11 <robstewartuk> This is no good in my use case.
08:24:15 <mm_freak_> robstewartuk: no, again, you set "-N", not "-N3" or "-N4", but just "-N"
08:24:27 <robstewartuk> Doh, ah.
08:24:36 <Maior> anyone got a favourite library for dealing with git repos?
08:24:50 <mm_freak_> Maior: for simple uses use whatever gitit uses
08:24:53 <Maior> gitlib's documentation leaves a bit to be desired
08:24:54 <robstewartuk> mm_freak_: thanks ;-)
08:25:00 <Maior> mm_freak_: cheers
08:25:01 <mm_freak_> robstewartuk: you're welcome ;)
08:25:54 <merijn_> My favorite library for dealing with git repos is Mercurial :D </troll>
08:26:20 <HugoDaniel> ahah rly ?
08:26:21 <HugoDaniel> why ?
08:26:28 <HugoDaniel> ah </troll> :D
08:26:32 <Maior> merijn_: can't find it on hackage :(
08:26:55 <danilo2> Ok, one more question :) If I can access values by (m ^. (at 1)), what if I get the key in Maybe? how can I combine it with fmap or something simmilar?
08:27:07 <mm_freak_> Maior: http://hackage.haskell.org/package/filestore
08:27:21 <mm_freak_> merijn_: and yes, that one supports darcs and mercurial as wel =)
08:27:30 <robstewartuk> merijn_: are you back in the Netherlands now?
08:27:54 <Maior> mm_freak_: mmm, I need to actually generate commit objects
08:28:03 <merijn_> HugoDaniel: Only partial troll, I *do* in fact use Mercurial for all my interaction with git :)
08:28:06 <merijn_> robstewartuk: Yup
08:28:13 <mm_freak_> Maior: that's fine…  don't let the name confuse you =)
08:28:21 <merijn_> Maior: Mercurial isn't a haskell library, it's a competing VCS :)
08:29:12 <mm_freak_> Maior: merijn_ is giving to understand that git sucks, and i agree =)
08:30:24 <HugoDaniel> why ? i kinda like git
08:30:36 <merijn> HugoDaniel: Better continue in -blah :)
08:30:45 <HugoDaniel> yes
08:30:47 <mm_freak_> HugoDaniel: in comparison to SVN sure =)
08:30:53 <mm_freak_> and yes
08:31:13 <Maior> ugh http://hackage.haskell.org/package/gitlib-2.2.0.0/docs/Git-Tutorial.html seems to be half broken links, half outdated
08:31:49 <danilo2> Tekmo: Would you be so nice and tell me one more thing? How can I access with lenses element of map, when the key is inside of Maybe? If its not, I can do as you suggested: (m ^. (at k))
08:32:09 <bartavelle> I hate it when "+RTS -N" doesn't give any boost (while increasing CPU usage), while it should work well, and profiling is just not cutting it
08:32:27 * hackagebot webdriver 0.5.3.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.5.3.1 (AdamCurtis)
08:33:54 <mm_freak_> bartavelle: if you don't use parallelism, all -N does is put the garbage collector in a different thread, which increases CPU usage =)
08:34:08 <bartavelle> my program is design for parallism
08:34:11 <bartavelle> designed
08:34:19 <mm_freak_> bartavelle: apparently not =P
08:34:20 <bartavelle> badly, obviously
08:34:32 <bartavelle> well, -N does increase CPU usage linearly
08:34:33 <mm_freak_> which abstraction are you using for parallelism?
08:34:38 <bartavelle> it just doesn't decrease running time :)
08:34:52 <bartavelle> forkIO, Chan for communication
08:35:07 <mm_freak_> what does your program do?
08:35:19 <bartavelle> computes puppet catalogs for several nodes at once
08:35:33 <mm_freak_> so pure?
08:35:35 <bgamari> Is Scotty single-threaded?
08:35:42 <mm_freak_> bgamari: no
08:35:48 <bartavelle> almost everything is IO
08:35:57 <ReinH> Cale: ping
08:36:01 <bgamari> mm_burea1, So in order to keep state I'll need to use STM?
08:36:12 <Cale> pong
08:36:17 <bgamari> mm_freak_, rather
08:36:29 <mm_freak_> bgamari: you can use whathever concurrent state/messaging abstraction you like
08:36:34 <mm_freak_> bgamari: including acid-state
08:36:39 <bgamari> mm_freak_, right
08:36:54 <bartavelle> mm_freak_, I only use strict structures, to prevent the problem where everything is evaluated in the main thread when the results are displayed
08:37:17 <mm_freak_> bartavelle: strict structures are almost always a bad idea
08:37:27 * hackagebot ShellCheck 0.3.0 - Shell script analysis tool  http://hackage.haskell.org/package/ShellCheck-0.3.0 (koala_man)
08:37:30 <ReinH> Cale: so I've been thinking more about this "Cat Theory for Haskellers" thing and I thought I'd start writing some School of Haskell posts, starting with abstract algebra and then moving on to CT.
08:37:30 <bartavelle> it *should* scale (except it spends half its time running a slow ruby interpreter, that can only run on a single thread, so there will be amdhal's law issues)
08:37:41 <Cale> cool
08:37:47 <mm_freak_> bartavelle: in particular you take yourself the opportunity to use data parallelism (see parallel strategies)
08:37:49 <ReinH> Cale: was wondering if you'd be interested in (informally) reviewing them for me
08:37:56 <ReinH> Cale: if nothing else it'll help me learn this stuff better
08:38:11 <bartavelle> mm_freak_, I am ok with a bigger granularity
08:38:11 <ReinH> Cale: time and interest permitting, not any sort of commitment
08:38:16 <Cale> Yeah, there's no better way to learn something than to attempt to explain it to others
08:38:22 <ReinH> Cale: absolutely
08:38:24 <mm_freak_> bartavelle: at this point i can only recommend reading The Book
08:38:27 <mm_freak_> bartavelle: http://chimera.labs.oreilly.com/books/1230000000929
08:38:29 <bartavelle> and those structures are all going to be fully evaluated eventually
08:38:39 <bartavelle> already read it :(
08:38:47 <ReinH> Tekmo: ping
08:38:50 <bartavelle> (and they stay in memory for a while)
08:39:14 <mm_freak_> bartavelle: and you skipped over the parallelism part to the concurrency part? =P
08:39:28 <bartavelle> on the paper the paralelism is really simple, it's just threads that work on their own, there must be something that I am overlooking :(
08:39:41 <mm_freak_> forkIO is never a good way to do parallelism…  in some (rare) cases it's the only way, but it's never a good way
08:39:59 <bartavelle> oh I might use the wrong words, I'd like to do concurrency
08:40:06 <bartavelle> all "work items" are independent
08:40:15 <mm_freak_> concurrency probably works
08:40:24 <danilo2> I'm sorry for asking the same question once more - maybe I'm trying to do it wrong way, but I cannot find a working solution :( How can I access member of map using key inside of Maybe using lenses?
08:40:40 <bartavelle> well, it should, I don't know how to debug from here
08:40:43 <Cale> danilo2: What's the type of the operation you want?
08:40:56 <ReinH> Cale: I kind of started already. I wrote this yesterday https://gist.github.com/reinh/8587382
08:41:02 <bartavelle> there are strange patterns in threadscope, but it's not obvious what they mean
08:41:10 <bartavelle> I'll just stare at it again
08:41:34 <danilo2> Cale:  (m ^. at 1) <- this access element with key "1". I want to write equivalent code, but working with keys insidfe of Maybe, so instead of 1 we get (Just 1)
08:42:02 <Cale> ReinH: cool :)
08:42:23 <ReinH> Cale: do I say anything obviously stupid or wrong? :)
08:43:18 <Cale> ReinH: Well, Average is really a monoid :)
08:43:33 <ReinH> Cale: what is the unit?
08:43:42 <Cale> (Sum 0, Sum 0)
08:43:52 <Cale> Though I guess in that case, getAverage is worse
08:44:07 <ReinH> Cale: getAverage violates the expected newtype field isomorphism anyway
08:44:27 <ReinH> i.e. Average . getAverage = id; getAverage . Average = id
08:44:55 <ReinH> Cale: I was planning on making Max, Min and Average into Option monoids
08:45:40 <int80_h> is it a code small to have parameters that are there just to pass to another function that your function will call. The function being called is the same every time.
08:45:48 <int80_h> /s/small/smell
08:46:05 <tristan__> hm, just read in a blog post that fpcomplete is also like heroku for haskell..
08:46:06 <ReinH> so arctic and tropical and whatever that makes Average, probably not something named
08:46:21 <Cale> danilo2: Perhaps you just want to use the Maybe monad?
08:46:30 <tristan__> can you push deployto fpcomplete projects? doesn't seem likeit
08:46:50 <ReinH> tristan__: heroku is also like heroku for haskell...
08:47:05 <Cale> danilo2: I don't really understand what type of thing you're after.  Maybe k -> Map k a -> Maybe a?
08:47:07 <tristan__> ReinH: hehe, sure, just not supported
08:47:10 <ReinH> int80_h: can you give an option?
08:47:12 <Maior> tristan__: lol
08:47:14 <ReinH> tristan__: sure it is :)
08:47:30 <tristan__> ReinH: by supported I mean we don't provide support, it is all up to you
08:47:37 <tristan__> (I work at heroku)
08:47:42 <danilo2> Cale: Hmm, it would solve this, but it could be an overkill - this is the only line with such problem - I'm simply getting this key out of other map and because of that I want such functionality.
08:47:43 <ReinH> Cale: although Option is a bit annoying to work with in practice.
08:47:49 <ReinH> tristan__: ah :)
08:48:28 <int80_h> ReinH, what do you mean by option? I'll post an example of what I mean.
08:48:31 <ReinH> Cale: but I wanted to explore the "any semigroup can be made a monoid by adding an extra element and calling it unit" concept
08:48:39 <danilo2> Cale: But I would prefer not to use Maybe monad - the function works inside State monad at changes this state - this is the only such operation, so maybe is it somehow easly doable?
08:48:41 <ReinH> int80_h: that wasn't for you :)
08:49:01 <int80_h> ReinH: heh okay
08:49:35 <danilo2> Cale: Ah I didnt saw your question. Yes, I'm looking for Maybe k -> Map k a -> Maybe a
08:49:37 <Cale> danilo2: I mean, write something like  (do i <- mi; view (at i) m) :: Maybe v
08:49:58 <Cale> Though using view/at for this also seems like overkill to me :P
08:50:05 <tristan__> oh, fpcomplete looks a lot less like heroku and more like some automation for setting up an EC2 instance
08:50:33 <ReinH> danilo2: fmap it?
08:50:42 <Cale> Or yes, use fmap :)
08:50:43 <danilo2> Cale: Oh! this is very nice solution! Cale: even without using view etc I would get the same problem with the same solution :) Thnak you!
08:51:13 <ReinH> danilo2: lens provides <&> (flip fmap) if that helps keep your operator/identifier ratio up ;)
08:51:24 <danilo2> ReinH: It cannot be fmapped as far as I know. Look (m ^. at 1) is equivalent to (m ^. (at 1)) - how would you fmap it?
08:51:49 <Cale> I hate almost all of the infix operators provided by lens and do not recommend anyone use them :)
08:51:54 <danilo2> ReinH: Of course to use Just 1 instead of 1
08:51:56 <ReinH> \k -> fmap (m ^. at k) ?
08:51:57 <rawtass> Anyone have time to look at my small example: https://raw.github.com/Toeplitz/haskell/master/test.hs ? I am trying to use Data.Traversable and Show to print my data structure, but I don't understnad how to use Traversable.
08:52:26 <danilo2> Cale: Why? its matter of personal taste of the code or there is something beroken with them ?
08:52:35 <Cale> It's mostly personal taste
08:52:46 <Cale> I think it makes code harder to read unnecessarily.
08:52:59 <Cale> Even if you're accustomed to their meanings.
08:53:19 <Cale> and many of the operators are needlessly specific
08:53:25 <danilo2> Cale: Do you talking about ^. also ? Is it better to read (view f m), than (m .^ f) ?
08:53:35 <Cale> I think so
08:53:37 <ReinH> danilo2: btw Cale's solution is just an fmap in do notation :p
08:53:38 <Cale> But that's me
08:53:43 <Cale> Yes, it is :)
08:53:46 <danilo2> Cale: You might be right :)
08:54:04 <Cale> fmap (\i -> view (at i) m) mi
08:54:15 <ReinH> Cale: I was just responding to "It cannot be fmapped" :)
08:54:19 <danilo2> Cale, ReinH : hmm, so how to do Cale's solution without do notation?
08:54:25 <Cale> ^^ like that
08:54:36 <Cale> oh, actually, it's not fmap
08:54:38 <Cale> it's bind
08:54:47 <Cale> lol, because that'll have type Maybe (Maybe v)
08:54:49 <danilo2> Cale: Ahh, of course! heh stupid me:P
08:54:54 <danilo2> Cale, ReinH: thanks! :)
08:54:55 <ReinH> Cale: oh of course
08:55:03 <ReinH> well you can just join that :p
08:55:05 <Cale> mi >>= \i -> view (at i) m
08:55:17 <Cale> But then, why not use do-notation if you're using bind anyway :)
08:55:38 <danilo2> Cale: Right, do notation is clearer than, but I prefer fmap one - its even more clear to me
08:55:39 <danilo2> :)
08:55:53 <Cale> The fmap one doesn't collapse the Maybe's together
08:55:59 <ReinH> Hmm, not so bad: (m ^.) . at =<< mi
08:56:09 <Cale> jaja
08:56:12 <Cale> er, haha
08:56:42 <ReinH> Cale: yes I know that bind is join and fmap :p
08:57:04 <ReinH> ah
08:57:16 <ReinH> danilo2: you probably prefer the bind one
08:57:19 <Cale> (Spanish made easy: just get your hands out of alignment on your keyboard)
08:57:24 <danilo2> ReinH, Cale: right
08:57:34 <ReinH> off by one errors!
08:57:35 <danilo2> ReinH, Cale: thank you very much! :)
09:01:32 <Raydiation> looking at the functional programming with erik meijer vids on youtube, haskell seems to make so much sense and seems to have all the sexyness of python
09:01:36 <colDrMcBeardman> Cale: relevant: http://bash.org/?5300=
09:01:51 <Raydiation> how does it feel to program in haskell vs python for instance?
09:02:02 <Maior> "nicer"
09:02:02 <Raydiation> more work, more thinking, etc?
09:02:05 <Cale> Raydiation: much better
09:02:12 <Maior> I actually have faith in things working
09:02:25 <Raydiation> because of the type system?
09:02:27 <Maior> yep
09:02:34 <Cale> Raydiation: You can refactor things without having to be able to fit the entirety of the program into your head at once.
09:02:56 <Cale> e.g. change the type of something, steamroll the compiler over it and have it tell you where you need to fix stuff
09:03:07 <Raydiation> i see
09:03:26 <Cale> I've done this with libraries which were ~8000 lines of code, and where I had to make hundreds of changes, and then at the end, once it compiled, it worked
09:03:37 <colDrMcBeardman> Maior: duck typing is one thing i hated about python. you download something that's missing deps and you get a fun stack trace :(
09:04:23 <Raydiation> as for optimization, thats mostly up to the compiler right?
09:04:41 <mm_freak_> Raydiation: the five stages of learning haskell
09:04:56 <Cale> Mostly, but if you're a bit more of an advanced user, you can fiddle with lower level stuff just fine.
09:05:22 <Cale> and you can add rewrite rules to your library which the compiler will use to optimise client code.
09:05:32 <Raydiation> oh cool :)
09:05:43 <mm_freak_> 1. fight the type system, 2. understand the type system, 3. use the type system, 4. learn better abstractions, some of them you would never have thought were possible, 5. (you never reach this stage)
09:06:12 <Raydiation> btw, how do pure functions work? lets say i pass in a huge datastructure and the function uses recursion. wouldnt that be a huge copy effort?
09:06:23 <Raydiation> or is it copy on write
09:06:26 <Raydiation> behind the scenes
09:06:26 <Cale> Raydiation: There's nothing more frustrating as a Haskell programmer to spend hours in a debugger tracking down some fiddly bug in a language with less expressive types, or a dynamically typed language, only to realise that it would have been a type error in Haskell.
09:06:31 <mzarella> didn't the the |> syntax come from Haskell users?
09:06:43 <mzarella> I can't find an example to prove this, but I thought this was the case
09:07:11 <mm_freak_> Raydiation: haskell data structures are immutable…  you never copy
09:07:27 <Cale> Raydiation: Usually you just build new structures, but because everything is immutable, you can safely reuse parts of your old structure in the new ones.
09:07:36 <Cale> (you don't have to worry about aliasing)
09:07:52 <FireFly> mzarella: I think it comes from F#, at least that's the only place I've heard about it
09:08:08 <int80_h> mm_freak_ : Unless your name is Simon :)
09:08:24 <Raydiation> ok so for instance if i have a person record and i change the name, a new structure will be created and the rest is aliased by default?
09:08:24 <Cale> So, for instance, the Map datatype (key/value mapping) is internally a balanced binary tree, and when you adjust the value at some key, it only has to rebuild a path from the root to the altered leaf
09:08:34 <Cale> yes
09:08:37 <Raydiation> cool :D
09:09:07 <Cale> and the really cool thing is that this means you get to keep the old structure for free
09:09:23 <Cale> Which is really useful if you're doing some kind of recursive backtracking thing
09:09:39 <Cale> You don't need to worry about carefully putting things back the way they were before
09:09:55 <Raydiation> is there dynamically allocated memory?
09:10:19 <Cale> Typically, you don't manage memory yourself
09:10:37 <mm_freak_> Raydiation: there is an infinite stream of reasons why haskell is better than python, but i suggest that you just try it out =)
09:10:37 <Raydiation> i mean what if i have a daemon with input, do i ever have to worry about memleaks?
09:10:47 <Cale> No.
09:10:59 <Cale> Well, heh, you might have to worry about using too much memory!
09:11:11 <Cale> But that's a problem you'd have in any language.
09:11:17 <Raydiation> sure
09:11:17 <Maior> leaks no, "jeaks" yes ("Java leaks" -> "My code uses more memory than I expected")
09:11:25 <Raydiation> i mean if the old strucutre is kept around
09:11:32 <Raydiation> and its not needed anymore
09:11:36 <Cale> The garbage collector is pretty good
09:11:44 <Cale> (in GHC)
09:12:00 <joelteon> yeah and you can make it beep when the garbage collector runs
09:12:02 <joelteon> that's pretty cool
09:12:08 <RevJohnnyHealey> Memory leaks are certainly possible in garbage collected languages.
09:12:20 <Cale> But I'm not going to lie, you absolutely can screw up and keep references to things which result in wasting memory
09:12:31 * hackagebot env-parser 0.0.2 - Pull configuration information from the ENV  http://hackage.haskell.org/package/env-parser-0.0.2 (JosephAbrahamson)
09:13:00 <tristan__> memory leak in haskell? impossible
09:13:01 <Cale> But so long as you're careful to make sure there's no way to access the old versions of things, they'll be discarded.
09:13:04 * tristan__ runs, print [1..]
09:13:22 <Cale> tristan__: That shouldn't leak.
09:13:27 <tristan__> acutall yea
09:13:29 <tristan__> just realized that
09:13:29 <tristan__> haha
09:13:31 <tristan__> dammit!
09:14:44 <Cale> Well, unless you count the fact that the numbers are getting larger
09:14:57 <mm_freak_> it's noteworthy that the errors we get are usually memory leaks
09:15:00 <Cale> But it will take a long time indeed for them to become large enough that you'll care :)
09:15:08 <mm_freak_> it's seldomly wrong program behavior or a crash
09:15:18 <tristan__> the worst is when the memory leak is because of the way the garbage collector works
09:15:31 <Cale> Well, if it's wrong program behaviour, it's usually *interesting* wrong program behaviour :)
09:15:46 <mm_freak_> indeed =)
09:15:46 <joelteon> so I have an executable in my package that depends on network, but it's buildable: False by default
09:15:58 <joelteon> but cabal install --only-dependencies still installs network, even if the executable isn't buildable
09:16:25 <mm_freak_> joelteon: it somehow infers that both ways are possible and selects heuristically
09:16:29 <joelteon> I see
09:16:31 <Cale> tristan__: Well, that's unlikely given GHC's collector
09:16:35 <mm_freak_> joelteon: probably as a result of some other dependency
09:16:44 <joelteon> mm_freak_: here's the cabal file https://github.com/joelteon/concurrent-state/blob/master/concurrent-state.cabal
09:16:50 <Cale> tristan__: It will eventually collect anything which your program doesn't have a way to access.
09:16:54 <mm_freak_> joelteon: if you want your flag to be strictly manual, you have to say so explicitly
09:16:55 <joelteon> I'm sure nothing else depends on network
09:16:55 <tristan__> Cale: yea, I odn'tknow much about ghc's, but we've run into some crazy ones with Erlang's
09:17:02 <joelteon> yeah, I did say so explicitly
09:17:14 <mm_freak_> oh
09:17:28 <Cale> The interaction with lazy evaluation can take some getting used to though.
09:17:32 * hackagebot env-parser 0.0.2.1 - Pull configuration information from the ENV  http://hackage.haskell.org/package/env-parser-0.0.2.1 (JosephAbrahamson)
09:17:38 <tristan__> turned into this https://blog.heroku.com/archives/2013/11/7/logplex-down-the-rabbit-hole
09:17:39 <Cale> You can be hanging on to pointers to things inside unevaluated expressions.
09:19:15 <Cale> (But it's a mistake to just make everything strict on the first sign of space usage you don't like, usually it just requires one carefully-placed strictness annotation or something like that)
09:20:21 <darthdeus> how can i inspect from which package a module originates in ghci?
09:20:25 <mm_freak_> joelteon: do Setup.hs and cabal-install agree?
09:20:35 <darthdeus> i've found the right module of a function via :info, but :info doesn't work on a module name
09:21:01 <joelteon> mm_freak_: it's the standard two-line Setup.hs
09:21:05 <geekosaur> I don't think you can from ghci. see "ghc-pkg find-module"
09:21:20 <mm_freak_> joelteon: sure
09:21:26 <mm_freak_> that doesn't answer my question though =)
09:21:37 <joelteon> oh, right
09:21:39 <joelteon> whoops
09:21:45 <mm_freak_> cabal-install doesn't use Setup.hs/.lhs
09:21:54 <mm_freak_> unless you tell it to
09:22:09 <joelteon> mm_freak_: yes, they agree
09:22:24 <Raydiation> btw, how good are the libs that are available through cabal? do they somewhat compare to ruby and python libs?
09:22:45 <joelteon> yeah, there's just fewer of them
09:22:46 <ChristianS> is the conduit package a good alternative to lazy I/O or should i rather look at one of the many alternatives (iteratee, enumerator, pipes...)?
09:24:40 <joelteon> mm_freak_: I'll just add network to the build-depends separately in a conditional
09:25:32 <cin> Is there a way to tell hoogle to use only one specific database by filepath (and not your default global database)?
09:30:48 <allsystemsarego> > ($ . $) <$> [(+2),(*3),(^2)] <*> [(*5),(+7),(*4),(subtract 10)] <*> [1]
09:30:49 <lambdabot>  <hint>:1:4: parse error on input `.'
09:31:05 <allsystemsarego> why does this ^ not work?
09:31:18 <joelteon> it's (($) . ($))
09:31:43 <allsystemsarego> I want the cartesian product of those function lists applied to that one value
09:31:47 <allsystemsarego> oh
09:32:08 <allsystemsarego> > (($) . ($)) <$> [(+2),(*3),(^2)] <*> [(*5),(+7),(*4),(subtract 10)] <*> [1]
09:32:09 <lambdabot>  No instance for (GHC.Show.Show b0)
09:32:09 <lambdabot>    arising from a use of `M16067044840930701227674.show_M16067044840930701227...
09:32:09 <lambdabot>  The type variable `b0' is ambiguous
09:32:09 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
09:32:09 <lambdabot>  Note: there are several potential instances:
09:32:11 <cin> hoogle's commandline is crap
09:32:18 <joelteon> hoogle itself isn't great
09:32:44 <Raydiation> whats also fascinating is that most functions are defined in haskell itself
09:32:54 <Raydiation> == or + for instance
09:33:20 <Cale> Raydiation: Yeah, well, for many of the basic types, the implementation of (+) defers to something lower-level
09:33:37 <Cale> Raydiation: But the interface is available so that you can define those things on your own data types.
09:35:28 <mm_freak_> joelteon: did that solve it?
09:35:37 <joelteon> yeah it did
09:35:42 <joelteon> I just put all the build-depends in the conditional
09:35:48 <joelteon> since you can't build it if the conditional is false
09:35:49 <mm_freak_> ok, good to know
09:37:34 * hackagebot concurrent-state 0.5.1.2 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.5.1.2 (JoelTaylor)
09:38:53 <allsystemsarego> > (($) . ($)) <$> [succ] <*> [succ] <*> [1 :: Int]
09:38:54 <lambdabot>  No instance for (GHC.Enum.Enum (GHC.Types.Int -> GHC.Types.Int))
09:38:54 <lambdabot>    arising from a use of `GHC.Enum.succ'
09:38:54 <lambdabot>  Possible fix:
09:38:54 <lambdabot>    add an instance declaration for
09:38:54 <lambdabot>    (GHC.Enum.Enum (GHC.Types.Int -> GHC.Types.Int))
09:39:06 <allsystemsarego> I don't get applicatives
09:39:29 <cin> $ hoogle search --databases=/nonsense -n 1 X
09:39:29 <cin> XMonad.Core data X a
09:39:36 <cin> It's like it just ignores whatever you give it.
09:45:12 <allsystemsarego> > (.) <$> [(+2),(*3),(^2)] <*> [(*5),(+7),(*4),(subtract 10)] <*> [1]
09:45:14 <lambdabot>  [7,10,6,-7,15,24,12,-27,25,64,16,81]
09:51:15 <monoidal> > liftM3 (.) [(+2),(*3),(^2)] [(*5),(+7),(*4),(subtract 10)] [1]
09:51:16 <lambdabot>  [7,10,6,-7,15,24,12,-27,25,64,16,81]
09:52:10 <rien_> I need some monadic advice
09:52:17 <monoidal> [(.) f g x|  f <- [(+2),(*3),(^2)], y <- [(*5),(+7),(*4),(subtract 10)], z <- [1]]
09:52:28 <monoidal> > [(.) f g x|  f <- [(+2),(*3),(^2)], g <- [(*5),(+7),(*4),(subtract 10)], x <- [1]]
09:52:29 <lambdabot>  [7,10,6,-7,15,24,12,-27,25,64,16,81]
09:53:33 <rien_> I'm not using Haskell, but Racket. It's a scheme. I'm coding a CRUD app. I have a bunch of function that return some info from the DB, or return false if the info couldn't be found.
09:53:43 <rien_> functions*
09:57:36 * hackagebot digestive-functors-aeson 1.1.4 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.4 (OliverCharles)
09:57:38 * hackagebot concurrent-state 0.5.1.3 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.5.1.3 (JoelTaylor)
09:58:25 <rien_> My question is, how should I handle that? Should I use Maybe? Or step up a bit and use Either? (I heard in Haskell people prefer ErrorT ?) Or should I use a logger monad like the Writer?
09:59:33 <mm_freak_> rien_: is it a typed racket?
10:07:38 * hackagebot hit 0.5.1 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.5.1 (VincentHanquez)
10:07:40 * hackagebot hit 0.5.2 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.5.2 (VincentHanquez)
10:09:30 <mm_freak_> Maior: see hackagebot's notices above…  that's what i call timing =)
10:10:17 <davidfetter_disq> what's 3 seconds among friends?
10:21:10 <asmyers> Can anyone suggest a nice way to write this line in applicative form?  right now I have:
10:21:36 <asmyers> (,) <$> (x :: IO (Maybe a)) <*> (y :: IO (Maybe b))
10:21:49 <asmyers> but that fails because it's going to IO (Maybe a, Maybe b)
10:21:55 <mzarella> Which database does the hoogle package utilize? http://github.com/ndmitchell/hoogle/blob/master/hoogle.cabal
10:22:10 <asmyers> but I have the function type (and want) IO (Maybe (a, b))
10:22:28 <asmyers> I could just write it in do notation but it seems like there should be a way to write that in applicative form
10:22:45 <supki> :t (liftA2.liftA2) (,)
10:22:46 <lambdabot> (Applicative f, Applicative f1) => f (f1 a) -> f (f1 b) -> f (f1 (a, b))
10:23:21 <Iceland_jack> @ty liftA2 (,) <$> (undefined :: IO (Maybe a)) <*> (undefined :: IO (Maybe b))
10:23:22 <lambdabot> IO (Maybe (a, b))
10:24:20 <monoidal> note that the IO (Maybe b) action might not be executed if the first returns Nothing
10:24:23 <simukis_> Am I only one who sees some potential in `(,) :: (Num a, Fractional b) ⇒ a → a → b`?
10:24:26 <mm_freak_> asmyers: liftA2 (liftA2 (,))
10:24:48 <mm_freak_> asmyers: in other words, just replace your (,) by liftA2 (,)
10:24:57 <asmyers> monoidal: That's fine
10:25:18 <asmyers> mm_freak_: liftA2 (,) type checks, what did you mean with the duplicate liftA2 (lifeA2 (,))?
10:25:30 <mm_freak_> asmyers: liftA2 f x y = f <$> x <*> y
10:25:43 <Iceland_jack> asmyers: that's for omitting the applicative syntax (<$>, <
10:25:47 <Iceland_jack> <*>) *
10:25:48 <asmyers> oh I see
10:25:52 <mm_freak_> asmyers: liftA2 often looks nicer for one-liners
10:26:12 <mm_freak_> > liftA2 (+) sin cos 15
10:26:13 <lambdabot>  -0.10940007270170449
10:26:15 <mm_freak_> compare
10:26:22 <mm_freak_> > (+) <$> sin <*> cos $ 15
10:26:23 <lambdabot>  -0.10940007270170449
10:26:53 <Iceland_jack> compare
10:26:53 <Iceland_jack> $ ⟦ sin + cos ⟧ 15 -- ;)
10:27:04 <asmyers> haha
10:28:51 <mm_freak_> monoidal: btw, both actions are executed
10:29:00 <mm_freak_> by liftA2 (liftA2 (,))
10:29:15 <joelteon> :t liftA2 (liftA2 .)
10:29:16 <lambdabot> (Applicative f, Applicative f1) => f (b -> a -> b1 -> c) -> f b -> f (f1 a -> f1 b1 -> f1 c)
10:29:39 <mm_freak_> if you want execution to stop early, you need to use MaybeT IO
10:29:44 <Delta|laptop> ugh...haskell
10:29:53 <mm_freak_> and then it's really just liftA2 (,) x y
10:30:00 <mm_freak_> instead of liftA2 (liftA2 (,)) x y
10:31:28 <monoidal> mm_freak_: oh, that's right. bad mistake.
10:31:41 <asmyers> ah, good to know
10:31:46 <asmyers> doesn't matter in this case
10:32:04 <mm_freak_> asmyers: then you probably want MaybeT, because it saves a bunch of clock cycles =)
10:32:30 <mm_freak_> MaybeT does the decision whether the result is Nothing earlier, before the second action is started
10:32:35 <Iceland_jack> asmyers: Out of curiosity, what IO action do you have that you don't care if it gets executed or not?
10:32:46 <asmyers> Iceland_jack: It's reading /proc nodes
10:32:54 <Iceland_jack> Right
10:33:04 <asmyers> it's Maybe since it will fail if you give it a bad pid
10:33:11 <asmyers> so they'll both fail for the same reason
10:33:18 <asmyers> well, I guess the process could die
10:33:20 <asmyers> between reads
10:33:26 <asmyers> so yeah, they may not both fail
10:33:49 <asmyers> but in any case, if either one does then the whole thing should fail
10:34:11 <mm_freak_> asmyers: if it's only two actions, it's probably not too bad to execute them both
10:34:32 <asmyers> mm_freak_: Yeah, I'll probably just leave it as is
10:34:38 <mm_freak_> but really this is a MaybeT problem, or perhaps you want to use IO's builtin EitherT and let the program die with an exception =)
10:35:21 <mm_freak_> asmyers: btw, you don't need to change the types of x and y to use MaybeT
10:35:31 <mm_freak_> runMaybeT (liftA2 (,) (MaybeT x) (MaybeT y))
10:35:37 --- mode: ChanServ set +o Cale
10:35:40 <mm_freak_> that gives you an IO (Maybe (a, b))
10:35:42 --- mode: Cale set +b *!*@83.247.106.212.dynamic.jazztel.es
10:35:52 --- mode: Cale set -o Cale
10:36:08 <asmyers> mm_freak_: I understand teh code, but don't think I understand what you mean by change the types
10:36:17 <Iceland_jack> It would also make more sense if asmyers is processing a list of files etc.
10:36:23 <Iceland_jack> using mapM or sequence
10:36:26 <mm_freak_> asmyers: you have x :: IO (Maybe a)
10:36:28 <mm_freak_> and you want MaybeT IO a
10:36:59 <mm_freak_> that's a matter of applying MaybeT =)
10:37:22 <asmyers> mm_freak_: ah, I see what you mean
10:37:44 <asmyers> Just about everything I've done in haskell is either pure or in IO, I don't have a very good handle on stacking monads
10:38:12 <mm_freak_> asmyers: newtype MaybeIO a = MaybeIO { runMaybeIO :: IO (Maybe a) }
10:38:17 <mm_freak_> asmyers: do you understand this type?
10:38:23 <asmyers> yep
10:38:33 <mm_freak_> MaybeT just makes the IO polymorphic
10:38:49 <mm_freak_> asmyers: newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
10:38:58 <asmyers> mm_freak_: In theory I understand the concept, in practice .... :p
10:39:09 <mm_freak_> asmyers: there isn't more to it
10:39:17 <asmyers> What you just said makes complete sense
10:39:21 <mm_freak_> MaybeT adds early termination to its argument monad
10:40:51 <asmyers> So, in the applicative version
10:41:10 <asmyers> you don't get early termination because applicative doesn't impose a dependency right?
10:41:27 <asmyers> but doing it monadically introduces an ordering => introduces a dependency
10:41:33 <asmyers> so we get early termination
10:41:45 <asmyers> is that an accurate description of the difference?
10:41:58 <mm_freak_> asmyers: liftA2 (liftA2 (,)) c1 c2 = do x1 <- c1; x2 <- c2; return (liftA2 (,) x1 x2)
10:42:16 <mm_freak_> as you can see the decision whether to have Just or Nothing is at the end, when the two actions were already used
10:42:23 <asmyers> I see
10:42:46 <mm_freak_> now MaybeT:  liftA2 (,) c1 c2 = do x1 <- c1; x2 <- c2; return (x1, x2)
10:43:05 <asmyers> ah, that makse sense
10:43:05 <mm_freak_> MaybeT makes the decision to continue or not to continue after c1, depending on whether it produced a Just or a Nothing
10:43:11 <mm_freak_> it's Maybe-aware binding
10:43:15 <asmyers> right
10:43:44 <asmyers> haha this is my problem, while I'm reading or having someone explain it it all makes complete sense :)
10:43:46 <mm_freak_> in fact it wouldn't even make sense to continue after c1, if it gave a Nothing, because there would be no value you could bind as x1
10:44:06 <mm_freak_> well, i would suggest you implement MaybeT yourself =)
10:44:16 <asmyers> mm_freak_: That's probably a good idea
10:44:17 <mm_freak_> writing Functor and Applicative will be enough to solve your problem
10:44:32 <mm_freak_> but it could pay off to write Monad as well =)
10:44:45 <asmyers> I'll try that, thanks :)
10:46:58 <berdario> I'm trying to follow a yesod tutorial but I have a problem with the dependencies
10:47:00 <berdario> yesod devel says that persistent-sqlite ==1.3.* is missing
10:47:08 <berdario> but cabal list persistent-sqlite says Installed versions: 1.3.0.1
10:47:40 <berdario> I'm using cabal 1.18 and ghc 7.6 (I installed cabal-1.18 separatedly from the haskell platform)
10:47:42 * hackagebot purescript 0.3.2 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.3.2 (PhilFreeman)
10:49:07 <asmyers> berdario: Are you using cabal sandbox?
10:49:19 <berdario> asmyers yes
10:49:56 <asmyers> Do you have persistent-sqlite installed in the sandbox?  I've accidently checked my user installation and not had the package installed in the sandbox :p
10:50:20 <berdario> asmyers I think I do... does "cabal list persistent-sqlite" not checks inside the sandbox?
10:50:38 <asmyers> berdario: Yeah, if you're in the directory with the sandbox
10:50:42 <berdario> I am
10:51:31 <berdario> if I try to install it manually in fact I'm told that it's already installed
10:51:33 <rien_> mm_freak_: yes typed racket,
10:52:10 <mm_freak_> rien_: well, in haskell it would depend on how you want to use the result, but in principle you can always use Maybe and then convert to richer abstractions
10:52:28 <mm_freak_> rien_: in particular there is a natural transformation from Maybe to Either e for some e
10:54:06 <matt3> what's the best way to write a function that needs to keep track of a value as it recurses?
10:54:16 <zett_zelett> How does lambdabot look to you?
10:54:17 <zett_zelett> http://boegel.kejo.be/ELIS/haskell-blah_lambdabotContest_results.html
10:54:22 <zett_zelett> Just stumbled upon this.
10:54:41 <defanor> i'm solving "20 intermediate exercises" now, but either i can't see right solutions for some of them or it's required to add some additional imports to make solutions nicer (and "nontrivial", if i understand it right). is it the latter or the former?
10:54:42 <matt3> i'm new so currently I'm writing a driver function that just calls the real function with an extra value passed to it
10:54:53 <rien_> mm_freak_: so this is some boring database webapp. I just want to be able to do auditing (I want the program to always log its attempts and failures) so we can know what went wrong with a request, and I also want to tell the user what went wrong
10:54:57 <matt3> that seems a little stupid though
10:55:10 <rien_> mm_freak_: I can't start with Maybe if I want error messages
10:55:39 <matt3> i can show an example if needed
10:55:41 <yayutf> rien: Either is nice
10:55:51 <valdyn> matt3: thats the standard pattern used usually
10:55:56 <valdyn> matt3: nothing wrong with it
10:56:06 <matt3> ok, just thought it looked a little weird
10:56:08 <rien_> I guess I'm hoping that someone does a lot of boring DB work and they can tell me which monad is best to handle and report these errors that DB always throw into the mix (missing rows, missing field, sql-null, etc)
10:56:09 <matt3> thanks
10:56:33 <rien_> yayutf: but is there advice to help decide between Either and Writer?
10:56:38 <valdyn> matt3: f x = f' x acc for example
10:56:39 <rien_> Maybe I need both?
10:56:50 <rien_> I understand monads but I'm not sure I understand transformers
10:58:26 <matt3> valdyn: yep that's pretty much exactly what i did
10:59:41 <dwcook> rien_, Writer would be useful if you wanted to log things along the way but not necessarily stop. Either would let you stop with an error value.
11:01:09 <dwcook> rien_, and if you're in IO anyway, you can use exceptions, so WriterT Foo IO might be want you want for some Foo
11:02:40 <mm_freak_> rien_: the idea is that logging is just an addon and you implement both separately
11:02:55 <mm_freak_> rien_: in other words, start with Maybe, then turn the Maybe action into a logging action
11:03:11 <mm_freak_> rien_: or start with Either String, such that you can actually select the log message
11:03:59 <mm_freak_> rien_: withLog :: IO (Either String a) -> IO (Either String a)
11:04:12 <mm_freak_> and it's up to you how to map that to racket
11:08:30 <c_my_nick> if i have `Maybe (Maybe a, Maybe a)`, i could write `fst =<< foo` and `snd =<< foo` to get `Maybe a` for each item in the tuple ... how might i go about doing it for a triple?
11:08:55 <valdyn> c_my_nick: you write new fun
11:09:03 <valdyn> c_my_nick: you write new accessor functions using pattern matching
11:10:13 <c_my_nick> hm, ok, thanks
11:10:45 <supki> > Just (Just 4, Just 7) ^? traverse._2.traverse
11:10:47 <lambdabot>  Just 7
11:10:51 <supki> > Just (Just 4, Just 7, Just 11) ^? traverse._2.traverse
11:10:53 <lambdabot>  Just 7
11:11:01 <supki> > Just (Just 4, Just 7, Just 11) ^? traverse._3.traverse
11:11:03 <lambdabot>  Just 11
11:11:55 <defanor> same question (request for a hint), but from a different point, about "20 intermediate exercises" (https://www.fpcomplete.com/user/DanBurton/20-intermediate-exercises): how should i deal with those Either wrappers? there are straightforward solutions for them, involving pattern matching, but it does not seem right to solve them that way
11:15:30 <rien_> mm_freak_, dwcook : I do want to log things along, and I do want to stop at the earliest failure. I'm just not sure if I can do both these things with just one monad.
11:16:09 <mm_freak_> rien_: you seldomly use a single monad in haskell
11:16:20 <dwcook> rien_, well, you'll end up with "one" monad. But you might need to compose some things together to get what you want, yeah
11:16:43 <dwcook> Looking at these types could help
11:16:46 <dwcook> @type runWriterT
11:16:47 <rien_> dwcook: I'm trying to do this whole thing without exceptions, because it seems to me if I can have both Nothing and logging, I wouldn't need exceptions
11:16:47 <lambdabot> WriterT w m a -> m (a, w)
11:16:49 <dwcook> @type runEitherT
11:16:50 <lambdabot>     Not in scope: `runEitherT'
11:16:50 <lambdabot>     Perhaps you meant `runWriterT' (imported from Control.Monad.Writer)
11:16:52 <mm_freak_> rien_: in haskell you would do most things by transforming between monads…  this can be in the form of actual monad transformers, but often a nicer approach is to use natural transformations between monads
11:17:02 <dwcook> Erm, I thought that was a thing
11:17:17 <mm_freak_> dwcook: EitherT is in a separate package
11:17:20 <pavonia> @hackage either
11:17:20 <lambdabot> http://hackage.haskell.org/package/either
11:17:29 <mm_freak_> mainly because there are two possible semantics
11:17:53 <mm_freak_> (at least, but two really useful ones)
11:18:06 <rien_> mm_freak_: let me show you an excerpt, hold on
11:18:13 <dwcook> rien_, fair enough. The difference would be that, with Either, your program flow would be more explicit than with exceptions. It's up to you whether that's what you want
11:18:34 <rien_> dwcook: yes, I'm going for explicitness :)
11:20:34 <mm_freak_> rien_: i hope i haven't lost my racket parser =)
11:20:51 <mm_freak_> @where lpaste
11:20:51 <lambdabot> http://lpaste.net/new/haskell
11:21:40 <rien_> mm_freak_: https://gist.github.com/peternmr/3d23fab987475160a267
11:21:49 <rien_> mm_freak_: it's rather straightforward code :)
11:22:27 <rien_> mm_freak_: so as you can see I came up with this macro called let-if* (line 19) that is like the Either monad (I didn't check the laws, hah, but the computational context is similar)
11:22:40 <rien_> but now I'm in a bind as explained in the comment on line 17
11:22:46 <rien_> that's why I need real monads now
11:23:31 <rien_> so in a situation like that, would you choose Either to return the results, and a writer monad to log them? So one side of Either would always have the result, the other always the log?
11:26:33 <mm_freak_> rien_: gimme a moment to examine this pizza i have in front of me =)
11:26:43 <rien_> np!
11:27:40 <levi> Heh, in a bind. So you need a monad. :)
11:28:03 <rien_> levi: the pun was accidental, I swear!
11:28:38 <rien_> it's important to notice the function query-maybe-value has a behavior such that it either returns the value, or #f (false) if the value doesn't exist. so I'd make that function be native in my monadic context
11:28:53 <jle`> @src undefined
11:28:53 <lambdabot> undefined =  error "Prelude.undefined"
11:29:06 <rien_> I just recently grokked monads so I apologize that my terminology is wonky
11:33:33 <dwcook> rien_, make sure you compose the transformers in the correct order, as it's not commutative. So for example, EitherT (WriterT a IO) gives you either a success value and a log, or a failure value; WriterT a (EitherT IO) gives you the log as well as either a success value or a failure value.
11:34:39 <rien_> dwcook: I definitely want WriterT a (EitherT IO) as I always want to log regardless of success
11:34:51 <dwcook> Okay, figured
11:35:43 <rien_> in Racket we don't have the IO type, there's no barrier between pure and effectful
11:36:22 <dwcook> And for your a (your log type), something simple to use would be [String]
11:37:34 <rien_> dwcook: agreed
11:37:56 <rien_> dwcook: I'm trying to write the code I wish I could, to show what I'm trying to do
11:38:05 <dwcook> Okay
11:38:12 <rien_> it's still confusing in my mind to think about two contexts (the left/right, and the logging)
11:38:41 <dwcook> Hmm, well you might find it advantageous to write a newtype that has a MonadWriter and MonadIO instance, for example
11:39:44 <dwcook> rien_, this might be of help: http://book.realworldhaskell.org/read/monad-transformers.html
11:40:11 <rien_> what I was thinking is because I'm a rookie with monads, maybe it's easier to write one that does everything I want, than to write two and combine them
11:40:14 <rien_> I'll check the link
11:40:36 <dwcook> Well composing existing ones practically is writing one that does what you want
11:40:45 <dwcook> You just need to learn how to compose them
11:41:25 <rien_> ah I didn't know that
11:42:22 <rien_> I'm excited to write my first good-sized monad to be used in production :)
11:43:41 <mm_freak_> rien_: interestingly the more experienced you get with haskell, the more lightweight your monads get =)
11:44:11 <dwcook> Though, if you want to learn something from re-implementing existing monads or monad transformers, don't let me stop you
11:44:48 <dobias> @pl \a b c -> [a,b,c]
11:44:49 <lambdabot> (. ((. return) . (:))) . (.) . (:)
11:45:35 <Cale> mm_freak_: Yeah, eventually you realise that things like ReaderT are a little bit silly in most of the cases where you might use them.
11:45:37 <dwcook> When pl attacks
11:45:59 <rien_> dwcook: I need to re-implemente them regardless as I'm coding in Racket :) I don't think it has transformers even
11:45:59 <mm_freak_> exactly
11:46:16 <dwcook> rien_, oh, I thought you were interfacing some Haskell code with some Racket code :)
11:46:16 <mm_freak_> rien_: if it has type constructors, you can make it have monad transformers =)
11:46:32 <mm_freak_> rien_: a monad is of kind * -> *, so a monad transformer is of kind (* -> *) -> (* -> *)
11:46:39 <dwcook> Racket doesn't even have more than one type, which makes Haskell's concept of monads difficult to implement
11:46:43 <rien_> dwcook: that would be too radical, hah
11:46:51 <mm_freak_> dwcook: rien_ is using a typed racket
11:46:54 <dwcook> Oh, okay
11:47:14 <rien_> dwcook: monads area already implemented there, on top of structs. also I'm using Typed Racket. however it lacks "higher kinded types" whatever that means, and supposedly that's a problem
11:47:16 <[swift]> Cale: i haven't reached that point of enlightenment =) what's silly about ReaderT?
11:47:37 <rien_> I just need the intuitive notion of the context to be there.
11:47:57 <rien_> isn't ReaderT just (let (()) ... ) ?
11:48:01 <mm_freak_> rien_: a "higher-kinded type" (it's actually a misnomer) is a type that takes a type constructor as argument
11:48:09 <Cale> [swift]: You end up using lift to execute actions in the original monad, and the cost of doing that usually outweighs the cost of passing parameters explicitly.
11:48:10 <dwcook> rien_, ah, I see. If you need an example: String has kind *, while Maybe has kind * -> *, which makes it higher-kinded
11:48:12 <rien_> mm_freak_: Ah then we definitely don't have that.
11:48:25 <dwcook> rien_, since Maybe can be applied to a concrete type to make a concrete type
11:48:42 <dwcook> mm_freak_, really? I thought it was anything not *
11:48:47 <rien_> well as far as I know I can simulate all that with just lambdas :P
11:48:50 <rien_> so I'm not concerned
11:49:05 <mm_freak_> dwcook: it's polymorphism over something that isn't * that you need for functors (and thus monads)
11:49:19 <mm_freak_> so you need a non-* as argument
11:49:32 <dwcook> mm_freak_, so, e.g., monad transformers?
11:49:38 <Cale> [swift]: ReaderT e m a is the same thing as e -> m a, right?
11:49:48 <mm_freak_> dwcook: yes
11:50:01 <mm_freak_> dwcook: even monads are limited in a language, where you can't be polymorphic over * -> *
11:50:10 <mm_freak_> dwcook: because in those languages you can't implement mapM
11:50:23 <mm_freak_> you have to implement maybeMapM, stateMapM, ioMapM, etc.
11:50:54 <Cale> If you can't write code once and have it work in any monad, then you're not "using monads".
11:51:03 <dwcook> mm_freak_, I don't think I can absorb what you mean just now, but I might ask you later.
11:51:16 <mm_freak_> dwcook: just try to write mapM in C#
11:51:21 <dwcook> I'm unfamiliar with C#.
11:51:30 <mm_freak_> mapM<F> …
11:51:37 <mm_freak_> C# will reject that, because F is not a concrete type
11:51:41 <rien_> Cale: I can't possibly strictly "use monads" in Racket because it lacks higher kinded types. So instead I'll code the context and the operations to lift things to it and to compose them.
11:51:42 <dwcook> Ah, I see.
11:52:12 <Cale> rien_: You *can* do it, by explicitly passing dictionaries around everywhere, but it probably isn't worth the trouble most of the time.
11:52:41 <mm_freak_> so you can use categorical patterns in these languages for the guarantees they serve, but you can't benefit from the DRY as you can in haskell
11:53:04 <mm_freak_> and yeah, what Cale said
11:53:18 <mm_freak_> wait…  you can't pass dictionaries around
11:53:24 <Cale> What do you mean?
11:53:30 <mm_freak_> data Monad f = Monad …
11:53:31 <dwcook> rien_, Reader a b is a -> b, Writer a b is (a, b) (or (b, a)). One reason you might use them as monads is for the pretty syntax
11:53:38 <mm_freak_> Cale: that requires f :: * -> *
11:53:45 <mm_freak_> which will be rejected
11:53:49 <Cale> mm_freak_: Racket is dynamically typed isn't it?
11:53:58 <mm_freak_> Cale: rien_ is using a statically typed dialect
11:54:01 <Cale> oh
11:54:02 <rien_> Cale: I don't know about passing dictionaries around. What I mean is, for what I want to do I know what the "return" and "bind" are and I know other functions I want to work inside the context with the shape a -> M a, so that seems to be all I need (and can hope for outside Haskell)
11:54:02 <Cale> hmm
11:54:16 <dwcook> Also Writer is slightly more than that, since it comes equipped with the ability to accumulate a Monoid, but you can do that yourself too
11:54:18 <Cale> In that case, you're probably out of luck
11:54:20 <rien_> dwcook: I can concoct any syntax I want in Racket :)
11:54:41 <Cale> rien_: The idea is that you take the implementations of return and bind as a parameter
11:54:48 <Twey> Doesn't Typed Racket at least have functors?
11:55:04 <rien_> functors are the things that can be fmapped over?
11:55:18 <Cale> yes
11:55:18 <mm_freak_> rien_: yes, practically
11:55:18 <mm_freak_> Twey: every language has functors
11:55:26 <Cale> "every"
11:55:27 <rien_> I can simulate functors with lambdas
11:55:28 <Cale> lol
11:55:34 <Cale> If only
11:55:37 <dwcook> mm_freak_, but do they let you at them? :P
11:56:07 <Cale> Similar to my comment about using monads, you're not really using functors until you can write code which works with an arbitrary functor.
11:56:23 <dwcook> I could point you to several languages that have a 'map' method on arrays, but not many that generalize that to other structures
11:56:39 <rien_> Cale: I understand the rigor but I'm simply looking to benefit from the abstraction that computational contexts afford me
11:56:48 <rien_> that was the big epiphany I had with monads
11:57:22 <Cale> rien_: You can of course write combinator libraries in scheme/racket with operations which look like this, and people have been doing so for years and years before anyone realised that it corresponded with monads from category theory.
11:57:28 <bambams_> Does the pastebin bot choose whether it wants to post, or is it just busy/AFK? ::)
11:57:35 <Cale> (There are even examples in SICP)
11:57:38 <dwcook> bambams_, mauke is not here right now
11:57:48 <dwcook> mauke is also not entirely a bot, just has a script running that does that
11:57:55 <bambams_> Ah, OK.
11:58:05 <bambams_> Well, this: http://lpaste.net/5005886131263242240 >:)
11:58:26 <dwcook> Oh, *that* bot
11:58:35 <rien_> Cale: exactly, that :) I just recently understood the concept of computational contexts with return and bind. I understand the important of the mathematical laws but I can't guarantee them with the tools I have, so at least I can code in that style and reap some of the advantages
11:58:36 <Cale> rien_: But I would never try to *force* something to be a monad, if it wasn't already. I suppose if you realise that your thing happens to be a monad, then you know that you can write all the Control.Monad stuff for it by hand, which is something.
11:58:38 <dwcook> When you said pastebin I thought you literally meant pastebin
11:59:00 <dwcook> bambams_, so I don't know what's up then
11:59:01 <rien_> Cale: I do believe this is a cogent computation context: https://gist.github.com/peternmr/3d23fab987475160a267
11:59:42 <bambams_> dwcook: The service detected imperfections that it warned about. I wouldn't be surprised if the bot doesn't publish to the channel until those are fixed.
11:59:50 <Cale> rien_: What is this U?
11:59:58 <Cale> rien_: Is that a plain union?
12:00:01 <rien_> Cale: Union
12:00:10 <Cale> Do you have a disjoint union?
12:00:27 <rien_> I believe that one is disjoint. it's either/or.
12:00:29 <dwcook> rien_, you can accomplish what Haskell does using tagged unions
12:00:46 <Cale> U String String  needs to be different from  String
12:00:46 <rien_> so the three first functions either return an integer, or false
12:00:58 <mm_freak_> Cale: well, there are two aspects:  you are using a categorical abstraction, if: 1. you use them for reasoning, 2. you use them for generic functions
12:00:59 <rien_> Cale: right, that's the function that is tipping me over to actually having to write a monad
12:01:00 <Cale> So, you'd want an explicit Left/Right tag
12:01:05 <rien_> Cale: instead of my let-if* hack
12:01:10 <rien_> Cale: precisely! :)
12:01:14 <rien_> you're right with me
12:01:17 <mm_freak_> Cale: most languages won't permit 2., but it's still worthwhile to benefit from 1.
12:01:33 <Cale> mm_freak_: Yeah, I suppose. :)
12:01:38 <rien_> dwcook: for tagged unions, they can't be disjoint unions, right? I admit this is barely over my head now.
12:01:48 <dwcook> rien_, I mean essentially what Cale just said
12:02:13 <Cale> rien_: Either is an example of a disjoint union type in Haskell
12:02:19 <Cale> data Either a b = Left a | Right b
12:02:20 <rien_> mm_freak_: I agree with your breakdown into 1 and 2, good point, and yes I need 1 to manage my code :)
12:02:32 <Cale> and for every type e, we have that (Either e) is a monad
12:02:42 <Cale> With  return = Right
12:02:50 <Cale> and  Left e >>= f = Left e
12:02:55 <Cale> and Right x >>= f = f x
12:03:59 <rien_> Cale: right, I need a monad/context where returning x means making a structure around x such that that structure is either x and a log of actions, or Nothing and a log of actions. and bind will short-circuit to Nothing if x is Nothing, and keep going otherwise; and if it keeps going, it concats the logs
12:04:21 <rien_> log of actions = [String]  (not to confuse with IO actions)
12:06:04 <dwcook> rien_, it looks like your language doesn't even indicate IO in the type, does it?
12:06:12 <rien_> dwcook: it does not :/
12:09:21 <bambams_> Basically I just have a rudimentary binary search tree and I'm trying to make it a self-balancing one...
12:09:57 <bambams_> Unfortunately, the balancing function doesn't scale at all. I'm trying to figure out if it's entirely because of the algorithm or if it's due to Haskell's lazy nature.
12:10:21 <Twey> rien_: data Foo a r = Foo a (Maybe r); instance Monoid a ⇒ Monad (Foo a) where Foo rs (Just x) >>= f = let Foo rs' x' = f x in Foo (rs <> rs') x'; Foo rs Nothing >>= _ = Foo rs Nothing -- does this obey the monad laws?
12:11:45 <rien_> Twey: I couldn't possibly tell you, I'm not good with proofs :)
12:12:05 <dwcook> Twey, aren't you missing return?
12:12:24 <Twey> Oh, and return = Foo mempty . Just, of course
12:12:35 <Twey> return is boring ;)
12:12:35 <novochar> I'm trying to install some dependencies for a package, and cabal is producing an error "could not resolve dependencies", tips on getting around this error? https://gist.github.com/novodinia/97802929aa33d3deeaf3
12:13:39 <geekosaur> the package claims to be for an older ghc than you have (base is tied to the compiler)
12:14:24 <geekosaur> you might see if it will build if you 'cabal unpack todo' and edit its todo.cabal to specify base == 4.6.*.* then 'cabal install'
12:16:56 <novochar> Thanks geekosaur, is there a way to install packages and save them as dependencies to the existing project?
12:17:06 <geekosaur> what?
12:17:59 <novochar> cabal install wai --save # this would ideally install the package and append it to the list of build-depends in the cabal file
12:18:10 <geekosaur> do you mean you want this to be installed into a particular sandbox (just make that sandbox current before installing) or are you imagining some weirdness where it needs to update some other project's .cabal
12:18:16 <geekosaur> oh, you are imagining weirdness. no
12:18:26 <ParahSailin> it is exciting to successively compile each version of ghc starting from 6.12.1 to current stable on system with prehistoric version of libc
12:18:54 <novochar> I'm reading http://adit.io/posts/2013-04-15-making-a-website-with-haskell.html
12:19:38 <novochar> Now I'm wondering how the author knew the exact version of the file, and if she/he manually typed that information into the file
12:20:01 <levi> The cabal file?
12:20:16 <geekosaur> um, if you're just editing the entry for that file and not bumping its version, why does the other one need to be updated?
12:20:18 <novochar> When you cabal init, cabal creates a file yourProject.cabal
12:20:24 <novochar> That's the file I'm referring to
12:21:05 <geekosaur> there are some tools which will determine versions (and I think cabal init will try to do so if run on an existing project? but you may need to adjust the versions)
12:24:10 <levi> If I were you, I'd just delete all the version constraints in your .cabal and see if it works then. If it does, then possibly add some back in based on what got installed.
12:27:25 <levi> novochar: I'm guessing the author was working with an older haskell-platform and used the base version that shipped with that haskell-platform version.
12:28:16 <geekosaur> that it hasn't been updated since is not the greatest of signs, though
12:29:16 <levi> geekosaur: I *think* that novochar copied the stuff from the website he's reading and didn't grab it from hackage.
12:29:49 <levi> It's not terribly surprising that code from a random blog entry is not maintained.
12:30:16 <levi> novochar: Also, you might want to check out the cabal sandbox feature as an alternative to hsenv.
12:30:51 <monochrom> blogs are not meant to be maintained :)
12:31:44 <levi> It's a bit of a different approach than hsenv, but as long as you don't need multiple versions of the entire haskell toolchain installed, it might work better for you.
12:33:19 <novochar> levi: Is cabal sandbox ready yet? I didn't think it had been included in the latest cabal
12:33:45 <novochar> Or maybe there was something missing that hsenv provided when I was looking at it, I forget why I haven't been using it now.
12:34:23 <bitemyapp> novochar: it's perfectly ready and part of 1.18
12:34:34 <bitemyapp> novochar: cabal sandbox has worked flawlessly for me.
12:34:40 <bitemyapp> couldn't live without it.
12:39:11 <novochar> bbl
12:47:15 <haasn> @hoogle (a -> m b) -> [a] -> m b
12:47:16 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
12:47:17 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
12:47:17 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
12:47:44 <S11001001> haasn: traverse
12:48:06 <S11001001> maybe with a _
12:48:17 <haasn> S11001001: the full signature should be Monoid b => (a -> m b) -> [a] -> m b
12:48:40 <haasn> fmap concat . traverse f -- definitely works
12:50:15 <catsup>         Something is amiss; requested module  template-haskell-2.7.0.0:Language.Haskell.TH.Lib differs from name found in the interface file template-haskell:Language.Haskell.TH.Lib
12:50:24 <S11001001> I feel like there's a newtype NT f a = NT (f a) somewhere such that Applicative f, Monoid a => Monoid (NT f a) is defined.
12:50:33 <S11001001> haasn: if that helps
12:51:12 <catsup> seems i have two versions of template-haskell, 2.7 and 2.8.  i need 2.8 for some stuff, but i can't build this program
12:51:25 <geekosaur> um
12:51:36 <geekosaur> you do know you can't just install a newer template-haskell?
12:51:48 <catsup> i tried some stuff, like --constraint='template-haskell==2.7.0.0' but it gives the same error
12:52:01 <catsup> geekosaur: well, cabal apparently installed it as a dependency
12:52:08 <geekosaur> that's a bug of sorts
12:52:21 <catsup> it says stuff will break if i unregister it
12:52:32 <geekosaur> template-haskell mostly lives inside the compiler, just upgrading its support library will accomplish nothing but to confuse the compiler
12:52:51 <catsup> i guess i'll go ahead and unregister it
12:53:00 <geekosaur> find out what thinks it is using what
12:53:07 <catsup> ghc-pkg: unregistering template-haskell-2.8.0.0 would break the following packages: haskore-0.2.0.3 midi-0.2.1 event-list-0.1.0.2 non-negative-0.1 QuickCheck-2.6 (use --force to override)
12:53:08 <geekosaur> and what version of ghc are you using anyway?
12:53:20 <catsup> The Glorious Glasgow Haskell Compilation System, version 7.4.1
12:54:06 <geekosaur> I am a little surprised those managed to install at all, although I suppose there weren't that many changes between 2.7 and 2.8
12:54:39 <geekosaur> unfortunately such changes are likely to show as strange runtime behavior if they don't break TH completely
12:55:05 <catsup> is there any way to find out what depends on event-list
12:55:24 <catsup> etc
13:03:07 <shackleford> So I was bored in class today, and decided to try making an interpreter for a simple numeric instruction set in Haskell, the incomplete rules of which  you can see http://lpaste.net/99058 <- here. My problem is that I can't conceive a way of representing registers in Haskell. I did this months ago in C, using arrays. Any ideas?
13:03:30 <dhrosa> what's wrong with a list of registers?
13:04:06 <shackleford> Lists being immutable. Ideally, the registers should be rewritable
13:04:08 <Urchin[emacs]> I found AWK again, it's actually pretty sweet
13:04:41 <kristof> represent every register in the virtual computer as a giant state monad
13:04:44 * kristof chuckles
13:04:55 <tomejaguar> shackleford: Simulate mutability by returning the updated state.
13:04:56 <Twey> shackleford: Haskell has arrays too — looks like an STArray would give you a pretty straightforward translation here
13:05:01 <dhrosa> shackleford: any user input you do will be in the IO monad anyway, you can maintain the list of regs in a state m onad o r something
13:05:15 <dmj`> what's that lens that applies a function to both elements of a tuple?
13:05:32 <shachaf> both
13:05:40 <mm_freak_> shackleford: you can write an interpreter that uses actual mutable variables by writing an ST action
13:06:05 <mm_freak_> shackleford: however, if you want your interpreter to be purely implemented, you can use Data.Map
13:06:21 <Urchin[emacs]> wait, wrong channel, sorry
13:06:26 <shackleford> mm_freak_ Would using State be impure?
13:06:39 <mm_freak_> shackleford: no
13:06:44 <dwcook> mm_freak_, isn't ST technically pure?
13:06:53 <mm_freak_> dwcook: like ByteString
13:07:18 <dwcook> mm_freak_, I don't understand the comparison.
13:07:29 <mm_freak_> dwcook: ST is, you could say, observably pure
13:07:38 <mm_freak_> but the implementation you write using ST is not pure
13:07:55 <mm_freak_> you can't observe its side effects from outside of ST
13:07:55 <dwcook> mm_freak_, isn't that about as good as you can get? Computing values causes your computer to heat up. :P
13:08:01 <shackleford> I'll try using State (which I just learned about right now). Thanks guys, I'l check back in a bit.
13:08:29 <dwcook> mm_freak_, I'm wondering in what other sense that you think matters it isn't pure
13:08:31 <mm_freak_> dwcook: it's not pure as long as you are /in/ ST…  you can't make the same assumptions while writing ST code
13:08:53 <dwcook> Hmm, okay
13:09:11 <oisin> I have functions in a graphics engine that take a Renderer type as a parameter (as well as other parameters). My question is: as I pass around this Renderer type to more and more drawing functions (since they all depend on it), should I convert it to a Monad? Or am I misunderstanding the purpose of Monads (encapsulating state)?
13:09:50 <mm_freak_> oisin: you could find ReaderT interesting
13:10:02 <tomejaguar> I don't know that there's a particularly good definition of pure.  It seems to me that the best you can get is that something is pure or not *with respect to* something else.
13:10:33 <dhrosa> oisin: do you modify and return a new Renderer? in that  case State would be  useful, if you just have a bunch of functions that all n eed a Renderer, Reader/ReaderT would be useful
13:11:07 <oisin> mm_freak_: dhrosa: Thanks - the Renderer, once generated, stays the same. I will take a look at ReaderT, thank you!
13:11:41 <mm_freak_> tomejaguar: you can define it in terms of the assumptions you make
13:12:04 <mm_freak_> \var b -> a >> b >> c
13:12:29 <mm_freak_> 'c' cannot assume that the effects 'a' had on 'var' are still in effect, because 'b' could have had side effects
13:12:38 <mm_freak_> this is true for ST as well as IO
13:12:53 <NuKeeSiMo> ciao
13:12:56 <NuKeeSiMo> !list
13:12:57 <monochrom> NuKeeSiMo: http://hackage.haskell.org/packages/archive/pkg-list.html
13:18:13 <stulli> Hi, is there a function which converts Int directly to Text? Currently i use "foo" <> (Data.Text.pack $ show 4). Didn't find anything on hoogle.
13:21:47 <dwcook> stulli, so you're basically looking for a version of Show that could produce a Text instead of a String? I'm not sure such a thing has been made
13:22:17 <mm_freak_> stulli: it's unlikely to be faster, so 'show' should work fine
13:22:51 <stulli> dwcook: exactly. It's only a minor nitpick, just wondering
13:23:36 <dmj`> stulli: you could make your own, class ShowText a where showText :: a -> Text
13:23:44 <dwcook> Better, leverage IsString
13:23:56 <dwcook> better = more abstract :D
13:25:20 <mm_freak_> dwcook: IsString does String -> X
13:25:35 <dmj`> class Show a => ShowText a where showText :: a -> Text; showText = T.pack . show
13:25:37 <dmj`> there
13:25:51 <tomejaguar> stulli: shortest: http://hackage.haskell.org/package/text-format-0.3.1.0/docs/Data-Text-Format.html
13:26:08 <bernalex> I have a data type that I want to make an instance of Monoid, and then ghc-mod and my program whines about not explicitly defining mappend and mempty. do I need to? can I make this shut up without doing it? I am using mconcat, and don't really need those
13:26:09 <tomejaguar> (Though then you have to convert your builder to a Text!)
13:26:17 <dwcook> mm_freak_, right, which can be used to make show :: (Show' a, IsString b) => a -> b
13:26:44 <dmj`> bernalex: w/o definied mappend and mempty you probably don't have a valid monoid instance
13:26:53 <dmj`> mconcat is defined in terms of mappend and mempty
13:27:03 <dmj`> mconcat = foldr mappend mempty
13:27:20 <bernalex> dmj`: aren't those defined implicitly?
13:27:35 <bernalex> dmj`: when I run my program without defining mempty and mappend, mconcat works fine
13:27:40 <tomejaguar> Yeah by 'mappend x y = mconcat [x, y]' and 'mempty = mconcat []', but Data.Monoid doesn't give default definitions.  Don't know why.
13:27:41 <dwcook> mm_freak_, sorry, I meant Show, you don't need to make a new Show' for that
13:27:45 <dmj`> if you're making an instance of a Monoid you have to define them explicitly
13:27:59 <bernalex> dmj`: why does my program work without doing that then?
13:28:02 * hackagebot apotiki 0.5.1 - a faster debian repository  http://hackage.haskell.org/package/apotiki-0.5.1 (pyr)
13:28:08 <tomejaguar> bernalex: If I were you I'd just write those to method implementations to shut GHC up.
13:28:08 <dwcook> Although then calling it show would be confusing… but hopefully the rest makes sense :P
13:28:12 <dmj`> bernalex: you're probably using mconcat on a list or something where the definition is defined implicitly
13:28:24 <dmj`> for lists mconcat = concat
13:28:34 <bernalex> dmj`: I'm using it on a list of my data type
13:28:39 <tomejaguar> dmj`: Looks like bernalex has actually implemented mconcat.
13:28:43 <timthelion> Is there a newtype ReversedList a = ReversedList [a]\n unreverse :: ReversedList a -> [a] with the appropriate cons and concatination functions prebuilt?
13:29:02 <bernalex> tomejaguar: lol no just instance Monoid MyType and that's it and the program works
13:29:04 <dmj`> bernalex: can you show me your code
13:29:13 <bernalex> tomejaguar: I have, now.
13:29:19 <bernalex> dmj`: I'll just push it, hold on.
13:29:23 <tomejaguar> bernalex: What!!
13:29:29 <tomejaguar> Sounds impossible.
13:29:42 <monoidal> timthelion: Dual [a] with mappend and mempty?
13:29:49 <dmj`> bernalex: instance Monoid [a] where mempty = []; mappend = (++)
13:30:05 <monoidal> > Dial [2,3] `mappend` Dual [0,6]
13:30:06 <lambdabot>  Not in scope: data constructor `Dial'
13:30:06 <lambdabot>  Perhaps you meant `Dual' (imported from Data.Monoid)
13:30:09 <monoidal> > Dual [2,3] `mappend` Dual [0,6]
13:30:10 <lambdabot>  Dual {getDual = [0,6,2,3]}
13:30:18 <dmj`> mconcat is defined as foldr mappend mempty, concat is foldr [] (++)
13:30:57 <shachaf> tomejaguar: Maybe now with #7633 they can do it!
13:31:16 <dwcook> data Soap = Dial
13:31:28 <dmj`> shachaf: I'm trying to lensify this. let [userLogin, msg] = map decodeUtf8 [l,m]. I don't know the right function to use from lens tho: let (userLogin, msg) = both decodeUtf8 (l,m).
13:31:29 <haasn> come to think of it, why doesn't the Monoid class include default definitions for mempty/mappend in terms of mconcat?
13:31:42 <bernalex> tomejaguar: dmj`: https://github.com/alexander-b/coreutilhs -- in wc, if I remove my definitions of mempty and mappend as well as the "where" on the instance line of course, it just works fine without it.
13:31:45 <dmj`> haasn: it doesn't?
13:31:50 <haasn> dmj`: apparently not
13:31:53 <haasn> http://hackage.haskell.org/package/base-4.6.0.1/docs/src/Data-Monoid.html#Monoid
13:31:57 <tomejaguar> bernalex: Ah your doing the coreutils.  Nice.
13:32:07 <tomejaguar> *you're
13:32:13 <edwardk> let (userLogin, msg) = over both decodeUTF8 (l,m)
13:32:34 <bernalex> might it be of consequence that I am using runhaskell to do this?
13:32:46 <edwardk> or = (l,m) & both %~ decodeUTF8
13:32:59 <edwardk> over mapped = fmap
13:33:08 <tomejaguar> bernalex: You *do* have an implementation of mempty and mappend there!
13:33:17 <bernalex> tomejaguar: reread what I said
13:33:22 <haasn> bernalex: I get an exception
13:33:24 <haasn> wc.hs: wc.hs:39:10-23: No instance nor default method for class operation Data.Monoid.mappend
13:33:27 <bernalex> bernalex | tomejaguar: dmj`: https://github.com/alexander-b/coreutilhs -- in wc, if I remove my definitions of mempty and mappend as well as the "where" on the instance line of course, it just works fine without it.
13:33:29 <edwardk> haasn: interesting option
13:33:37 <bernalex> haasn: try it with runhaskell
13:33:44 <monoidal> I think it makes sense to add mempty = mconcat [] and same with mappend
13:33:46 <dmj`> edwardk: thank you!
13:33:54 <haasn> bernalex: I am; that's a runtime exception - remember the mconcat is only used for the “total” line
13:33:55 <monoidal> create a thread on libraries@?
13:34:04 <bernalex> haasn: uhm it just works here
13:34:11 <bernalex> haasn: ohhhh
13:34:13 <haasn> “runhaskell wc.hs wc.hs” is what I ran
13:34:25 <tomejaguar> Haha
13:34:34 <shachaf> haasn: Maybe now with #7633 they can do it!
13:34:44 <bernalex> haasn: yes I'm being silly, sorry =)
13:35:14 <tomejaguar> shachaf: Do what?
13:35:16 <haasn> shachaf: that is actually pretty awesome
13:36:56 <monoidal> haasn: I think it would be nice to add this; would you be willing to create a thread on libraries@...?
13:37:25 <haasn> monoidal: sure
13:37:30 <shachaf> tomejaguar: Defaults for mempty/mappend.
13:37:39 <tomejaguar> shachaf: Oh are you saying that #7633 now makes that sensible?
13:38:17 <shachaf> Well, the main argument that I can think of against it is lack of warnings.
13:38:20 <monoidal> so the definition would have {-# MINIMAL (mempty, mappend) | mconcat #-}
13:38:20 <shachaf> Not that that stopped Eq.
13:38:59 <shachaf> Is | stickier than , ?
13:39:02 <dmj`> bernalex: I get warnings when I run your code w/o mappend and mempty defined explicitly from ghci. and a runtine error *** Exception: /..../wc.hs:32:10-23: No instance nor default method for class operation Data.Monoid.mappend
13:39:06 <shachaf> Or is , special syntax or something?
13:39:22 <shachaf> Anyway, if you allow people to define mconcat, you have to specify the mconcat Monoid law.
13:39:32 <bernalex> dmj`: yes, I found out I was being stupid
13:39:43 <bernalex> or, haasn did, rather
13:39:54 <bernalex> I merely chose to acknowledge this
13:40:59 <tomejaguar> shachaf: Surely the law is implied by the default implementation/
13:40:59 <shachaf> I guess the laws would be: mconcat . map mconcat = mconcat . concat; mconcat [x] = x
13:41:52 <shachaf> Eh, I guess so.
13:42:20 <monoidal> shachaf: yes, it can be written as {-# MINIMAL memp, mapp | mcon #-}
13:42:29 <identity> how do you define mempty and mappend in terms of mconcat?
13:42:44 <shachaf> Using an empty list and a two-element list.
13:42:44 <monoidal> mconcat [], \x y -> mconcat [x,y]
13:42:55 <identity> oh, duh @ the first I ugess
13:43:23 <identity> and yes, of course
13:43:25 <identity> i get it
13:43:26 <identity> thanks
13:43:34 <dgpratt> int-e, you around?
13:43:42 <bernalex> is there a way to sleep like BASH/GNU/Linux/etc sleep?
13:43:52 <dmj`> threadDelay
13:43:54 <identity> @hoogle threadDelay
13:43:54 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
13:43:55 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
13:43:55 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
13:43:55 <bernalex> using threadDelay was... suboptimal
13:44:00 <identity> oh.
13:44:37 <dmj`> bernalex: why
13:44:44 <bernalex> actually, compiling it with ghc made it a lot more precise
13:44:55 <enthropy> hmm, ghc-7.7 has gone to unicode quotes
13:45:01 <enthropy> no more `x'
13:45:06 <enthropy> ‛a’
13:45:08 <bernalex> using runhaskell sleep.hs 5 was more "5-ish" than 5
13:45:15 <haasn> bernalex: remember to mentally subtract the overhead of parsing, type checking and code gen ;)
13:45:50 <bernalex> haasn: it's minimal when compiling it, but with runhaskell it's quite a lot
13:45:52 <haasn> also the overhead of starting up the binary (including the GHC compiler) in the first place
13:46:05 <dgpratt> does anyone besides int-e have the ability to tell lambdabot to join a channel?
13:46:09 <bernalex> >0.2 seconds all the time
13:46:24 <bernalex> with the compiled version it's 0.001-ish
13:46:55 <haasn> shachaf: Monoid's laws include “mconcat = foldr mappend mempty”; shouldn't that be enough to uniquely determine mconcat's behavior?
13:47:09 <haasn> for that monoid instance, at least
13:47:35 <shachaf> haasn: Yep, as above.
13:47:54 <haasn> foldr mappend mempty [a, b] = a `mappend` b `mappend` mempty which due to the other stated laws boils down to a `mappend` b
13:47:56 <haasn> Ah, okay
13:49:41 <noctux> hello. I've got a question to lazy-IO. I'm trying to parse a binary file with the following code: https://paste.xinu.at/aO9/ (when testing, ajust the filepath from /tmp/a.out). My hope was, that this will actually do lazy IO, so it would basically parse the first pair of Word16s and then output those, so that I would in theory be able to point it to something like /dev/zero. If I try large files, the code
13:49:42 <noctux> run into an out-of-memory instead. Is there something I'm obviously doing wrong?
13:49:57 <bernalex> uhm is there no way to do
13:50:05 <bernalex> > map read ["1", "2"]
13:50:06 <lambdabot>  [*Exception: Prelude.read: no parse
13:50:10 <bernalex> without pragmas?
13:50:20 <bernalex> > map read :: Int ["1", "2"]
13:50:21 <lambdabot>  <hint>:1:18:
13:50:21 <lambdabot>      Illegal literal in type (use -XDataKinds to enable): "1"
13:50:22 <bernalex> to be more specific
13:50:33 <identity> > map read ["1", "2"] :: [Int]
13:50:34 <lambdabot>  [1,2]
13:50:38 <bernalex> oh of course
13:50:50 <bernalex> I have done the same blunder sometime previously, thanks identity
13:50:57 <identity> yw
13:51:59 <ReinH> noctux: what you actually want is strict IO :)
13:52:25 <ReinH> noctux: for example, http://www.haskellforall.com/2013/09/perfect-streaming-using-pipes-bytestring.html
13:52:28 <bernalex> hm how do I map sum to that?
13:52:42 <ReinH> :t sum
13:52:43 <lambdabot> Num a => [a] -> a
13:52:47 <ReinH> you don't.
13:52:50 <timthelion> monoidal: Thankyou.  Do you have any idea if Dual has the efficiency benefits of working with a reversed list(you can add items to the end really easilly)?
13:52:53 <dhrosa> map (sum . read) ["1", "2"]
13:52:55 <monoidal> > sum $ map read ["1","2"]
13:52:56 <lambdabot>  3
13:52:59 <dhrosa> < map (sum . read) ["1", "2"]
13:53:04 <dhrosa> derp
13:53:05 <bernalex> omg I was stupid again
13:53:12 <dhrosa> wait that don't work
13:53:28 <haasn> > map (sum . read) ["[1,2]", "[3,4,5]"]
13:53:29 <lambdabot>  [3,12]
13:53:34 <monoidal> timthelion: Dual is essentially the same as [a], only the order of arguments to ++ changes
13:53:47 <ReinH> timthelion: yes, Dual is basically a difference list iinm
13:54:01 <monoidal> is it?
13:54:16 <timthelion> monoidal: hrm, ok, that's not what I wanted.  I want to use a reversed list for efficency reasons, but make it clear at the type level, that the list is reversed.
13:54:27 <shachaf> ReinH: ?
13:54:39 <noctux> ReinH: looks good, thanks
13:54:49 <monoidal> timthelion: perhaps http://hackage.haskell.org/package/dlist-0.3/docs/Data-DList.html?
13:55:04 <ReinH> shachaf: not Dual per se, sorry. But I thought the dual of a list was a difference list.
13:55:41 <bernalex> dhrosa: sum $ map read ["1", "2"] was what I was aiming for
13:55:44 <ReinH> e.g. Dual [a]
13:55:46 <dhrosa> yeah
13:56:05 <bernalex> so now I have threadDelay $ (*1000000) . sum $ map read seconds
13:56:20 <ReinH> wait, no, Dual [a] is just reverse list concatenation?
13:56:25 <monoidal> ReinH: that's right
13:56:44 <ReinH> :/ there was something dual-like about diff lists I thought
13:56:58 <monoidal> Dual is just Dual x `mappend` Dual y = Dual (y `mappend` x)
13:57:10 <bernalex> oh wait, read just dies with bad input? no exception? right, then I need to use something else
13:57:12 <monoidal> hm. a difference list is [a] -> [a], but this trick can be done with any monoid
13:57:26 <bernalex> oh OK it's an exception. nvm.
13:57:38 <identity> @hoogle reads
13:57:38 <lambdabot> Prelude reads :: Read a => ReadS a
13:57:38 <lambdabot> Text.Read reads :: Read a => ReadS a
13:57:38 <lambdabot> Prelude readsPrec :: Read a => Int -> ReadS a
13:57:46 <identity> bernalex: reads may be sufficient
13:57:54 <identity> @ty ReadS
13:57:55 <lambdabot> Not in scope: data constructor `ReadS'
13:57:56 <monoidal> bernalex: readMabe in Text.Read if you have recent GHC
13:57:57 <identity> eh
13:57:59 <identity> @info ReadS
13:57:59 <lambdabot> ReadS
13:58:10 <bernalex> monoidal: oooh that's neat
13:58:23 <identity> that's even better
13:58:45 <shachaf> I,I newtype D k a b = D { unD :: forall r. (b -> r) -> a -> r }
13:59:03 <shachaf> Er...
13:59:17 <shachaf> I,I newtype D k a b = D { unD :: forall r. k b r -> k a r }
13:59:48 <timthelion> Wait, how is it possible that both cons and snoc are both O(1). /me looks at code.  Woow :) :D
14:02:37 <ReinH> er,  in toList      = ($[]) . unDL, what is ($[])?
14:02:44 <timthelion> monoidal: DList is exactly what I want thanks :D
14:03:01 <stulli> dmj`: thanks, the ShowText class worked for me (my first type class, yay!)
14:03:06 <ReinH> timthelion: because function composition is O(1) :)
14:03:34 <timthelion> ReinH: yes, I see that.  Dons is a sneeky little bastard if you ask me!
14:03:59 <bernalex> erm how do I putStrLn "foo " ++ getContents?
14:04:23 <shachaf> everything is O(1) if you don't evaluate it
14:04:25 <haasn> putStrLn (mappend "foo " <$> getContents)
14:04:29 <ReinH> timthelion: diff lists are a neat structure but implementing them as lazy function compositions is quite clever
14:04:39 <haasn> or putStr "foo " >> getContents >>= putStrLn
14:04:51 <bernalex> haasn: oh. I almost had the latter, heh
14:04:56 <shachaf> DList works fine in a strict language.
14:04:58 <pavonia> :t putStrLn (mappend "foo " <$> getContents)
14:04:59 <lambdabot>     Couldn't match expected type `Char' with actual type `[Char]'
14:05:00 <lambdabot>     In the first argument of `mappend', namely `"foo "'
14:05:00 <lambdabot>     In the first argument of `(<$>)', namely `mappend "foo "'
14:05:36 <ReinH> shachaf: how are snoc and cons O(1) in a strict language? Doesn't that involve evaluating the result of the composition?
14:05:45 <haasn> oh
14:05:50 <haasn> putStrLn =<< ...
14:06:55 <ReinH> @do getContents >>= \contents -> putStrLn "foo " ++ contents
14:06:55 <lambdabot> do { contents <- getContents; putStrLn "foo " ++ contents}
14:07:20 <ReinH> woops
14:07:25 <ReinH> @do getContents >>= \contents -> putStrLn ("foo " ++ contents)
14:07:26 <lambdabot> do { contents <- getContents; putStrLn ("foo " ++ contents)}
14:07:51 * haasn .oO(  (| pure "foo " ++ getContents |)   )
14:07:52 <shachaf> Challenge: Understand how DList works.
14:08:45 <tomejaguar> Can't you do a kmett-inspired right kan extension rather than a DList, to reduce or eliminated the invalid values?
14:09:08 <shachaf> Codensity also gives you "invalid values" (i.e. a type that's too big)
14:09:09 <haasn> How do lambda abstractions behave in strict languages? Say, (\f g x -> f (g x)) foo bar -- with foo and bar being complicated expressions
14:09:20 <ReinH> haasn: stahp
14:09:21 <shachaf> Or how do you mean?
14:09:47 <ReinH> shachaf: I thought I did and that it requires laziness. If I am wrong I fail to see how.
14:09:50 <Cale> haasn: In a strict language, you evaluate foo and bar first.
14:09:51 <bernalex> haasn: hm. how does that look with <>?
14:10:10 <haasn> bernalex: fmap ("foo " <>) getContents
14:10:14 <haasn> something like that?
14:10:20 <Cale> (and the lambda, but it already counts as evaluated)
14:10:25 <identity> god, I can never remember the format of the build-depends field. library ==1.2.* isn't working
14:10:32 <identity> someone feel like providing a refresher?
14:10:34 <haasn> Cale: so if “bar” is another lambda, does it also count as evaluated?
14:10:37 <ReinH> (x:) . unDL xs <-- why doesn't that evaluate xs in a strict language?
14:10:38 <Cale> yes
14:11:02 <shachaf> Forget about the newtype.
14:11:03 <Cale> haasn: It's very unusual not to regard lambdas as being fully evaluated and to attempt to do reductions inside of them
14:11:08 <haasn> Cale: so DList is essentially “lazy” in strict languages? mappending together what-would-be-infinite-lists-if-evaluated should work fine, provided you don't actually run “fromDL” at the end?
14:11:28 <haasn> Wait, no
14:11:34 <Cale> haasn: DList will work just fine in strict languages
14:11:34 <shachaf> It's not really lazy.
14:11:54 <Cale> But infinite lists won't work
14:12:01 <shachaf> Well, they don't work anyway.
14:12:09 <tomejaguar> Strictness is basically just syntactic.  You can get non-strictness in strict languages just by hiding behind a lambda.  (It may not be *efficient* non-strictness, however)
14:12:16 <haasn> you'd evaluate the sublists you're mappending when applying “toDL = \xs x -> xs ++ x”
14:12:45 <shachaf> tomejaguar: "you can compile a non-strict language into a strict language" doesn't really mean "strictness is just syntactic"
14:13:00 <shachaf> Just about anything is "just syntactic" that way.
14:13:34 <tomejaguar> Well, there's a trivial syntactic transformation between strict and non-strict.
14:13:47 <shachaf> Anyway, the main point of DList is this: "(as ++ bs) ++ cs" is a problem because you have to iterate over "as" twice.
14:13:59 <bennofs> For an AI player, I want to fork off a thread to calculate the best next move. I have to respond in 2 seconds. I'd like to return the best move that has been found so far, how can I implement this? Should I use an IORef, MVar or TVar or something else?
14:14:08 <shachaf> ((as ++) . (bs ++) . (cs ++)) [] is as ++ (bs ++ (cs ++ []))
14:14:15 <shachaf> No matter how you associate the function composition.
14:14:25 <Cale> bennofs: You could use any of those
14:14:41 <bennofs> Cale: well, that's why I'm asking, what would you recommend?
14:16:01 <tomejaguar> shachaf: You still might need O(n) work to reassociate the function compositions (if they're associated to the left) before it can start producing values, but I guess it's a much smaller O.
14:16:01 <Cale> I recommend abstracting over that decision. You're going to create the IORef or MVar or whatever in the main thread. Immediately after that point, define a way to write a potentially-improved solution to it, and then pass *that* to the AI thread
14:16:19 <Cale> So, you'll be passing some  Solution -> IO ()  thing
14:17:27 <vijaykiran> Hi, anyone using shm-mode in Emacs ? I'm getting an error symbol-def void for haskell-session-maybe
14:17:28 <ReinH> Cale: wouldn't you pass the ref/var as well?
14:17:41 <Cale> ReinH: The reference will be inside that function
14:17:46 <ReinH> ah
14:17:50 <ReinH> duh
14:17:54 <acowley> There's also the reference package
14:17:58 <acowley> @hackage reference
14:17:58 <lambdabot> http://hackage.haskell.org/package/reference
14:18:10 <bernalex> uhm how do you check if something is a number
14:18:15 <ReinH> Cale: I think I used to know what a closure was at some point
14:18:21 <Cale> But any of those abstractions will likely work as well for a simple case like this. You can probably get by with an IORef, because you don't likely need any kind of thread synchronisation.
14:18:21 <identity> bernalex: try to read it to an int. if it fails it isn't
14:18:24 <ReinH> bernalex: define "number"
14:18:28 <identity> if that's the kind of number you need
14:18:34 <acowley> I kind of wish things like reference were more common
14:18:42 <bernalex> identity: I want something that returns true/false, not something that fails
14:18:44 <acowley> But I don't even use it myself
14:18:45 <bennofs> Cale: Even if I abstract over that, I still have to chose one of these in the end? Is there a difference in semantics between them?
14:19:01 <Cale> bennofs: Yes, there are differences
14:19:07 <ReinH> bernalex: (isJust . readMaybe) with an appropriate type signature
14:19:09 <bernalex> ReinH: usable as int somehow that kind of makes some form of sense. I'm not picky.
14:19:12 <identity> bernalex: case readMaybe "asd" of { Just _ -> True; _ -> False; }
14:19:19 <bernalex> oh
14:19:20 <identity> ReinH: or better yes
14:19:22 <bernalex> well that's an idea
14:19:40 <Cale> bennofs: MVars can be full or empty. Reading from an empty MVar or writing to a full one will block your thread until the condition changes
14:19:40 <ReinH> bernalex: but that's boolean blindness
14:19:49 <identity> why doesn't the bot paste my lpaste pastes? :(
14:20:09 <ReinH> Maybe Int is a nice way of saying "did I read an int?" that has the advantage of telling you which int you maybe parsed.
14:20:10 <shachaf> Maybe they're private.
14:20:28 <Cale> bennofs: The idea being that if you need to use the previous value of the MVar to be able to update it, you can take the MVar (which empties it at the same time), compute the new value, and then write that.
14:20:35 <identity> http://lpaste.net/7185974490914881536
14:20:41 <identity> cabal sandbox issue stuff
14:20:43 <identity> anyone?
14:20:45 <Cale> and if multiple threads are doing that, you won't get lost updates
14:20:48 <haasn> bernalex: instead of “if isNumber s then foo else bar” write “case readMaybe s :: Maybe Int of Just _ -> foo; Nothing -> bar”
14:21:04 <bernalex> well that was the plan
14:21:10 <ReinH> case readMaybe str of Just _ -> do success; Nothing -> do failure
14:21:20 <bernalex> but I'm trying to find something that makes me reasonably satisfied with the succinctness
14:21:29 <ReinH> bernalex: ^
14:21:29 <bernalex> I have threadDelay $ (*1000000) . sum $ map read seconds
14:21:50 <bernalex> so what I want to do is "if any of read seconds fails, putStrLn "omg u so rong input" or something
14:22:01 <Cale> bennofs: IORefs and TVars will always have some value, and TVars can only be accessed inside of STM transactions which by definition occur as-if-atomically with respect to the other threads in the system.
14:22:01 <ReinH> bernalex: sum (mapMaybe readMaybe seconds)
14:22:11 <ReinH> ah
14:22:14 <ReinH> that's not what that does
14:22:41 <identity> bernalex: where is seconds from? is it from the command line?
14:23:00 <haasn> case sequence $ map readMaybe seconds of Just ts -> threadDelay (1000000 * sum ts); Nothing -> ...
14:23:01 <ReinH> bernalex: you have options
14:23:02 <identity> If so, process it accordingly in main before threadDelay and then tell the user off if he can't type
14:23:10 <ReinH> haasn: argh you beat me to that option
14:23:12 <bernalex> identity: case input of [] -> ....; seconds -> ...
14:24:14 <ReinH> I'd use sequence
14:24:27 <haasn> uh
14:24:32 <haasn> mapM readMaybe seconds
14:24:45 <ReinH> haasn: I always forget that equality :/ :/
14:25:53 <identity> yeah, sequence is nice here.
14:25:56 <acowley> maybe failure success $ foldMap (fmap Sum . readMaybe) seconds
14:25:59 <acowley> something like that
14:26:12 <acowley> Hm
14:26:13 <acowley> maybe not
14:26:33 <identity> http://lpaste.net/7185974490914881536 Anyone care to take a look at some issues with cabal repl?
14:26:37 <ReinH> @src mapM
14:26:38 <lambdabot> mapM f as = sequence (map f as)
14:26:39 <haasn> :t _Show
14:26:39 <acowley> Seemed a nice way to sum Justs
14:26:40 <lambdabot> Not in scope: `_Show'
14:26:42 <ReinH> I need to burn ^ into my brain
14:27:01 <haasn> over _Sum foldMapOf (re _Show) -- ?
14:27:06 <acowley> ReinH: That seems excessive :(
14:27:20 <identity> ReinH: Yeah, same. I was thinking something with listToMaybe and join and something but i forgot sequence entirely
14:27:27 <haasn> other way round
14:27:42 <ReinH> identity: I knew sequence. I forgot that sequence (map f as) = mapM f as.
14:28:03 <acowley> ooh, haasn, that's nice! Except it would take me a while to get the types lined up :/
14:28:09 * hackagebot monadcryptorandom 0.6 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.6 (ThomasDuBuisson)
14:28:21 <ReinH> haasn: oooh re _Show is nice
14:28:23 <identity> I also knew that sequence :: [m a] -> m [a], but it just didn't register as a candidate for a solution is what I meant
14:28:42 <haasn> ReinH: and the other way round, _Show is the “read” behavior, re _Show is the “show” behavior
14:28:53 <haasn> foldMapOf (folded._Show) I think
14:29:07 <acowley> I can never get uses of folded right on the first (or second) try
14:29:41 <haasn> and it's not over either, it's au
14:30:38 <ReinH> haasn: yes I know what a prism is :D :D
14:32:08 <Cale> If you use au in a program, you are obligated to add a comment:  -- excuse my French
14:33:01 <acowley> Code review: ಠ_ಠ
14:33:31 <haasn> -- excusez mon francais
14:34:00 <ReinH> Cale: hahaha
14:34:09 <companion_cube> goldName = "au" -- pardon my French
14:34:26 <identity> am I the only one who constantly runs into problems with cabal repl and cabal sandboxes in general with 1.18.1.1?
14:34:44 <identity> or 1.18.0.2, whichever is applicable
14:35:08 <ReinH> acowley: stolen and tweeted. :D
14:35:15 <jle`> anyone know why i am getting, with ghc-mod, 'you can't use Template Haskell with a profiled compiler'?
14:35:29 <jle`> i disabled all profiling flag in boht my global cabal config and my sandbox cabal config
14:35:42 <acowley> identity: What kind of problems?
14:35:58 <ReinH> jle`: something something https://github.com/haskell/cabal/issues/83 ?
14:36:12 <ReinH> jle`: oh. weird. stale build artifacts?
14:36:19 <identity> http://lpaste.net/7185974490914881536 @ acowley
14:36:34 <jle`> i cleared my sandbox re-installed it all
14:36:37 <jle`> hm
14:36:42 <jle`> also for some reason i can't install ghc-mod in my sandbox
14:37:07 <jle`> maynbe i should nuke my entire global packages too
14:37:18 <identity> also, removing the cabal sandbox, recreating it, adding those build-depends and then trying to cabal install --only-dependencies --dry-run complains about an exhausted dep search tree for juicypixels
14:37:45 <acowley> identity: Can I see the .cabal file?
14:37:55 <identity> sure, sec
14:38:52 <fragamus> edwardk: I want to use linear for a V5 but there is no V5
14:39:03 <acowley> I have a V6
14:39:06 <ReinH> fragamus: make one :D
14:39:11 <acowley> I don't think I put it into linear, though
14:39:57 <identity> acowley: sent via pm
14:40:10 <ReinH> identity: such secrecy
14:40:18 <peddie> fragamus: can you just use V?
14:40:22 <dmwit> ?hpaste
14:40:22 <lambdabot> Haskell pastebin: http://lpaste.net/
14:40:27 <acowley> I also have a V type thing for Storable vectors
14:40:29 <fragamus> ah i never used that
14:40:35 <identity> ReinH: meh, it's just that it contains my name, email, so on
14:40:50 <identity> couldn't quite be arsed to remove them
14:40:59 <identity> as this will most likely not be uploaded on hackage
14:41:03 <bernalex> haasn: uhm for putStrLn =<< (mappend "blah" <$> getContents -- what do I need to change to make it work with getArgs instead?
14:41:30 <haasn> not sure what you mean
14:41:43 <bernalex> haasn: putStrLn "blah" ++ unwords getArgs, really
14:41:44 <ReinH> identity: :p
14:42:04 <haasn> mappend "blah" . unwords <$> getArgs -- ? :P
14:42:04 <fragamus> how do I construct a V
14:42:07 <jle`> what does it even mean "the following packages are likely to be broken: ghc-7.6.3
14:42:08 <acowley> identity: Okay, I see the same error
14:42:12 <acowley> identity: We can debug this!
14:42:19 <ReinH> bernalex: try with do notation
14:42:36 <identity> acowley: yay!
14:42:38 <bernalex> ReinH: no, then I'll never learn this plumbing lol
14:42:48 <haasn> bernalex: then try converting it to do notation
14:42:54 <identity> acowley: using the same build deps?
14:42:56 <dmwit> jle`: You are re-installing a version of a package you already have, that the ghc-7.6.3 package depends on, but with different dependencies than ghc-7.6.3 expects.
14:43:06 <haasn> the plumbing, that is
14:43:23 <asmyers> Can anyone help me with this?  http://lpaste.net/99060
14:43:28 <jle`> dmwit: the only thing that has a flag of sorts is template-haskell..which is apparently upgrading from containers-5.0 to containers-5.3
14:43:32 <ReinH> bernalex: write it in do notation and then undo it
14:43:34 <asmyers> I have been trying to get something like this but can't make it type check
14:43:50 <identity> oh my god
14:43:52 <jle`> i guess because it's using the 'global' template-haskell?...and that was built with containers-5.0 ?
14:44:05 <haasn> ReinH: but then he won't have written anything at all
14:44:05 <identity> acowley: ...
14:44:11 <identity> acowley: JuicyPixels /= juicypixels
14:44:29 <jle`> should i re-build ghc or something
14:44:31 <jle`> :|
14:44:46 <dmwit> jle`: I don't know why you're talking about flags. I didn't mention flags at all.
14:44:51 <jle`> i meant like red flag
14:44:52 <bernalex> haasn: haasn I didn't quite get that. putStrLn (mappend "blah" . unwords <$> getArgs)? that won't work, right?
14:44:55 <jle`> on the list of installs/reinstalls
14:44:58 <jle`> the only thing that isn't 'normal'
14:45:01 <haasn> bernalex: putStrLn =<< (...)
14:45:10 <dmwit> :t lift
14:45:10 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
14:45:16 <bernalex> oh yes you bind it
14:45:18 <haasn> bernalex: the right hand is IO String, not String
14:45:19 <bernalex> haasn: thanks!
14:45:19 <dmwit> :t MaybeT
14:45:20 <identity> I guess this must be the reason I ran into this issue before as well.
14:45:21 <lambdabot> Not in scope: data constructor `MaybeT'
14:45:31 <jle`> is template-haskell-2.8.0.0 (reinstall ... containers-5.0 to containers-5.3 ... osmething like that)
14:45:49 <bernalex> haasn: I figured it out & sent you my "a-ha!" msg before you replied, but my SSH connection is very lulz atm.
14:45:54 <dmwit> asmyers: I guess you're wishing for something of type IO (Maybe a) -> MaybeT IO a -- ?
14:46:05 <acowley> identity: Hooray!
14:46:08 <asmyers> dmwit: It does seem like what I need
14:46:12 <dmwit> :t maybeT
14:46:13 <lambdabot>     Not in scope: `maybeT'
14:46:13 <lambdabot>     Perhaps you meant `maybe' (imported from Data.Maybe)
14:46:15 <identity> maybe I'll try submitting a patch to cabal to point out that it's case sensitive
14:46:16 <dmwit> blah
14:46:21 <identity> woe and plague upon such silliness
14:46:23 <acowley> Sometimes cabal is case sensitive, sometimes it isn't
14:46:31 <identity> acowley: what.. really?
14:46:33 <jle`> asmyers: what are you trying to do?
14:46:42 <identity> that sounds terrible
14:46:45 <acowley> identity: You can change the case of the field names
14:46:45 <dmwit> ?hoogle m (Maybe a) -> MaybeT m a
14:46:46 <lambdabot> Control.Monad.Trans.Maybe MaybeT :: m (Maybe a) -> MaybeT m a
14:46:46 <lambdabot> Control.Monad.Trans.Class lift :: (MonadTrans t, Monad m) => m a -> t m a
14:46:46 <lambdabot> Graphics.Rendering.OpenGL.GL.Evaluators newMap1 :: (Map1 m, ControlPoint c, Domain d) => (d, d) -> [c d] -> IO (m c d)
14:46:51 <dmwit> asmyers: =)
14:46:59 <identity> acowley: oh, i see
14:47:00 <acowley> identity: And, at the command line, cabal install juicypixels is fine
14:47:07 <identity> oh..
14:47:17 <acowley> It's been brought up before
14:47:26 <acowley> but I don't know if there's an open issue anywhere
14:47:30 <dmwit> Hackage is case-sensitive.
14:47:32 <identity> okay, so that must mean that hackage does not allow duplicates even if the case varies, I assume?
14:47:34 <asmyers> jle`: Trying to make a function which takes a path and a (ByteString -> Maybe a) and returns MaybeT IO a
14:47:39 <identity> dmwit: is it?
14:47:39 <dmwit> cabal attempts to present a case-insensitive UI whenever possible.
14:47:45 <identity> so cabal is doing case insensitive comparisons?
14:47:52 <dmwit> The result is confusion when cabal and Hackage have to mix, obviously.
14:47:58 <asmyers> jle`: By reading the file and processing it through the input function
14:47:59 <jle`> asmyers: is readTing not compiling?
14:48:11 <identity> dmwit: the result is confusion when cabal isn't being consistent in the cabal file and the command line interface
14:48:19 <asmyers> jle`: Right, sorry forgot the compiler error
14:48:51 * dmwit nods agreeably towards identity
14:48:57 <dmwit> That is an acceptable refinement of my claim.
14:49:05 <jrmithdobbs> bleh, why doesn't Data.Tree have a Hashable instance?
14:49:08 <acowley> Luckily cabal and hackage rarely have anything to do with each other!
14:49:45 <identity> well, I think it's a pretty silly oversight, to be honest
14:50:05 <dmwit> Oversight is the wrong term. It suggests it's a problem because somebody didn't think about the behavior.
14:50:16 <dmwit> In reality, somebody thought about the behavior, and consciously chose what we have today. =)
14:50:36 <dmwit> That choice might have been a mistake. I'm not sure.
14:50:45 <dmwit> It's a darn convenient mistake if you understand it.
14:50:49 <identity> if cabal can unambiguously determine which package to install despite hackage's case sensitivity when it gets fed a name with bad case, then so should it when it gets fed such a name in the cabal file.
14:51:00 <dmwit> I disagree.
14:51:06 <dmwit> Cabal files are much more archival than command lines.
14:51:53 <dmwit> I'm okay with having to type a different command a year down the line to get a specific package. I'm not as okay with my cabal file breaking a year down the line.
14:51:53 <asmyers> dmwit: hmm, that works if I use fail in the else branch.  I'm missing what I would return instead of Nothing? :p
14:52:23 <dmwit> asmyers: Hm? What else branch?
14:52:53 <identity> naturally, yes, but I don't see *why* it should be case sensitive in one place but not another. And, when it has the capability of selecting the right package despite incorrect case, why isn't it telling the user "package abc doesn't exist, but Abc does. is that what you need?"
14:52:54 <acowley> dmwit: The answer is probably for cabal install to offer more help when given a a .cabal file
14:52:57 <Twey> Going by past experience, your project probably won't compile a year down the line anyway
14:53:14 <identity> acowley: yeah, I guess
14:53:23 <acowley> But I'd be just as happy if it was case sensitive at the command line
14:53:47 <dmwit> identity: Yes, that kind of error "maybe you meant Abc" error would be nice, I agree.
14:54:21 <jrmithdobbs> (because it's * -> * to answer myself from a min ago, derr)
14:54:29 <asmyers> dmwit: shoot, my cut down example doesn't have it, I Updated the example:
14:54:32 <asmyers> http://lpaste.net/99061
14:55:31 <dmwit> asmyers: Yes, fail, or mzero, or MaybeT (return Nothing).
14:55:42 <asmyers> ah, I see
14:55:48 <asmyers> dmwit: Thanks for the help
14:55:57 <dmwit> asmyers: Can I point out that this is a race condition?
14:56:08 <dmwit> You should just read the file instead, and catch the exception if that doesn't work.
14:56:21 <asmyers> dmwit: Ah, good point
14:56:25 <asmyers> dmwit: Hadn't thought of that
14:56:28 <dmwit> Though perhaps for a toy that kind of consideration doesn't matter.
14:56:43 <asmyers> dmwit: Well, the example was cut down from something else
14:56:47 <asmyers> dmwit: That I want to work :p
14:57:02 <jle`> is there any way to rebuild my entire cabal library?
14:57:11 <startling> jle`, rm dist
14:57:16 <startling> rm -r I guess
14:57:28 <jle`> rm -r ~/.cabal ?
14:57:35 <startling> jle`, no?
14:57:44 <shlevy> Is it possible to express a function (IO a, IO b) -> IO (a, b) such that the implementation is free to perform thea ctions in any order, including (but not requiring) concurrently, without manually using threads?
14:57:56 <startling> jle`: do you mean "rebuild my cabal library" or "rebuild everything I have installed via cabal"?
14:58:05 <jle`> startling: hm probably the latter
14:58:12 * hackagebot apotiki 0.5.2 - a faster debian repository  http://hackage.haskell.org/package/apotiki-0.5.2 (pyr)
14:58:14 <shlevy> I want to express the idea that these two actions are independent so do the most efficient thing here
14:58:37 <jle`> is there anything that i need to also delete in .ghc ?
14:58:40 <startling> jle`, you can rm -r ~/.ghc
14:58:44 <dwcook> shlevy, that is indeed permitted by that signature
14:58:47 <startling> jle`: ~/.cabal isn't important to delete
14:58:56 <shlevy> dwcook: How would I write the function I mean :D
14:59:16 <startling> jle`: (N.B. this won't magically reinstall everything)
14:59:33 <startling> shlevy, haskell threads aren't OS threads
14:59:42 <dwcook> shlevy, I would recommend looking at the async package
14:59:49 <jle`> startling: will it at least let me start over?
15:00:04 <startling> jle`: yeah.
15:00:17 <jle`> thanks
15:00:26 <dwcook> @hoogle async
15:00:27 <lambdabot> package async
15:00:27 <lambdabot> Control.OldException asyncExceptions :: Exception -> Maybe AsyncException
15:00:27 <lambdabot> Control.OldException AsyncException :: AsyncException -> Exception
15:00:38 <dwcook> Hrm, hoped it'd give a link
15:00:45 <bennofs> @hackage async
15:00:45 <lambdabot> http://hackage.haskell.org/package/async
15:00:51 <dwcook> http://hackage.haskell.org/package/async
15:00:52 <shlevy> startling: Ah are they purely green threads or does the implementation decide if it wants to run on top of a real thread or do interleaving or sequenced or whatever?
15:00:53 <dwcook> Oh good
15:00:53 <startling> shlevy, so you can forkIO or whatever and it won't necessarily use another OS thread (but it might) depending on how the program is compiled
15:01:21 <startling> shlevy: yeah.
15:01:24 <shlevy> Cool
15:01:25 <dwcook> shlevy, waitBoth looks to be exactly what you want
15:01:56 <startling> yeah, it looks like async does this in a nicer way
15:03:13 * hackagebot samtools-iteratee 0.2.2.1 - Iteratee interface to SamTools library  http://hackage.haskell.org/package/samtools-iteratee-0.2.2.1 (NicholasIngolia)
15:03:27 <shlevy> ah async looks great, thanks dwcook !
15:04:10 <jle`> startling: i removed .ghc and i think i lost my cabal binary
15:04:12 <jle`> oops
15:04:26 <jle`> was it supposed to be in there?
15:04:35 <peddie> fragamus: oh, sorry -- you can use fromVector, but it's not exactly an easy process
15:04:37 <startling> jle`, haha, oops
15:04:50 <jle`> probably should have mv'd it instead
15:04:52 <jle`> hm.
15:04:56 <jle`> i guess i can reinstall the platform
15:04:57 <startling> jle`: it should be in ~/.cabal/bin and there should be a globally-installed one, too
15:05:09 <jle`> my .cabal/bin is missing it for some reason...have no idea why
15:05:16 <fragamus> peddie i want it to be easy
15:05:25 <jle`> well i found the global one
15:05:29 <startling> jle`: weird. if you installed the platform before, there's almost definitely a globally-installed one somewhere
15:05:29 <peddie> fragamus: sorry then :(
15:05:32 <startling> jle`: aha
15:05:36 <startling> jle`: so cabal install cabal-install
15:05:40 <startling> to get the latest.
15:05:53 <peddie> it's easier with HEAD than with 7.6.3, but it's still not quite the same story as V{0-4}
15:05:57 <jle`> yeah, thanks :)
15:07:03 <jle`> what is in ~/.ghc anyway?
15:07:43 <startling> jle`: compiled libraries
15:07:52 <startling> oh, no
15:08:03 <startling> a database with pointers to compiled libraries
15:09:28 <startling> I'm getting "Overlapping instances for Magma (Cantor Integer) arising from the superclasses of an instance declaration. Matching instances "instance Whole a => Magma (Cantor a)", "instance Magma (Cantor Integer)" in the instance declaration for `Discern (Cantor Integer)`.
15:09:35 <startling> but, Integer is not a Whole.
15:09:45 <startling> What's going on?
15:10:04 <monoidal> unfortunately, GHC does not know that Integer is not a Whole. you could define an instance somewhere else
15:10:24 <monoidal> in short, overlapping instance error does not look at LHS of => at all
15:10:25 <startling> monoidal: ah.
15:10:40 <startling> monoidal: so, is there a flag that I can
15:10:48 <startling> use to surpress the error? :)
15:11:32 <monoidal> -XOverlappingInstances ought to work
15:11:46 <monoidal> or -XIncoherentInstances
15:11:50 <startling> oh, that's an obvious name for it.
15:12:00 <monoidal> the error should point that pragma
15:12:08 <startling> It doesn't.
15:12:20 <colDrMcBeardman> compiler flags involving "Incoherent" and "Undecidable" kinda scare me.
15:13:03 <shachaf> {-# LANGUAGE SpookyInstances #-}
15:13:09 <startling> haha
15:13:13 <noctux> ReinH: Ok, implemented it, works like a charm
15:13:16 <colDrMcBeardman> shachaf no way.
15:13:18 <noctux> ReinH: thanks once more
15:13:24 <ReinH> noctux: :) np
15:13:42 <shachaf> colDrMcBeardman: That's not a real extension (yet!).
15:13:51 <joelteon> Will it be
15:14:11 <monoidal> I hope one day we will be able to define the constraint solver in programs
15:14:16 <ReinH> noctux: did you use pipes-attoparsec?
15:14:34 <monoidal> i.e. you want instance resolution to use backtracking, write a backtracking function and tell GHC to use it
15:15:15 <monoidal> you want special behavior for Typeable, write it and tell GHC to automatically create instances
15:15:15 <noctux> ReinH: no, pipes-binary
15:15:21 <ReinH> noctux: ah nice :)
15:15:31 <noctux> ReinH: and created a datatype that intanciates binary
15:15:33 <colDrMcBeardman> monoidal: is the constraint solver something that can be talked to via compiler plugin?
15:15:39 <ReinH> noctux: seems good :)
15:15:51 <noctux> now the complete code is:  withBinaryFile (optCDev mainOpts) ReadMode $ \handle -> runEffect $
15:15:54 <noctux>   (decodeHandle handle :: Producer Sample IO()) >-> P.map toString >-> P.print
15:16:13 <monoidal> colDrMcBeardman: not sure if it's expressive enough.
15:16:19 <noctux> *instanciates
15:16:54 <jle`> is it "okay" to re-install template-haskell in sandbox?
15:17:07 <monoidal> jle`: doubtful
15:17:42 <jle`> for some reason i have a TH that is installed using containers-0.5.0
15:17:49 <jle`> but my package uses containers-0.5.3
15:18:07 <geekosaur> um. containers is another of those libraries that is risky to replace
15:18:11 <jle`> should i rebuild ghc...? or...try to downgrade containers?
15:18:18 <ReinH> byorgey: btw http://www.reddit.com/r/haskell/comments/1vxmn4/the_haskell_cast_5_brent_yorgey_on_diagrams_and/cexljmm
15:18:24 <jle`> is my best bet to try to get my package to work with 0.5.0
15:18:35 <acowley> jle`: You should use the containers your GHC (and TH) came with
15:18:50 <geekosaur> if a package comes with the compiler, your safest assumption is that it should not be touched
15:19:12 <acowley> Or even looked at in a funny way
15:19:25 <colDrMcBeardman> jle`: what platform are you on?
15:20:38 <jle`> colDrMcBeardman: i'm on ubuntu?  or do you mean what haskell platform
15:21:19 <colDrMcBeardman> jle`, i am also on ubuntu and the best thing i can tell you is spend a couple hours just reinstalling haskell from the website and don't use the debian package.
15:21:26 <jle`> well luckily all i had to do was change an ==0.5.3.1 to =0.5.0.0
15:21:33 <jle`> colDrMcBeardman: oh yeah, i never used the debiant package
15:21:51 <jle`> i always built everything from scratch...although...i think i'm supposed to use the binaries from the haskell platform website
15:22:05 <colDrMcBeardman> oh, just a package with unnecessary constraints in the .cabal file, eh?
15:22:21 <jle`> yeah...i guess it was.  it was making TH reinstall
15:22:53 <colDrMcBeardman> poor cabal. we ask it to do so much and all people do is complain on the interweb.
15:23:21 <Clint> and ignore the .debs that just work
15:23:37 <jle`> :P
15:23:43 <jle`> i'll fix it some day
15:24:20 <colDrMcBeardman> Clint: they're great when they do and everything you need is compatible with them. if you need to be ahead of them, though, they're no good.
15:24:36 <Clint> that's true
15:24:40 <Clint> i rarely need to be ahead of them
15:25:06 <colDrMcBeardman> Clint: honestly, they do a decent job, but hackage is a huge and fast-moving target.
15:25:08 <yayutf> and the debs don't always just work
15:27:53 <Twey> I like the gentoo-haskell stuff.  It's pretty up-to-date and the devs have done a good job of making the task of updating/adding a package minimal (assuming you're already set up for ebuild development).
15:28:44 <colDrMcBeardman> Twey: i loved the ability to hack away at ebuilds, but gentoo became too much of a maintenance drain for me.
15:29:32 <colDrMcBeardman> Twey: ebuilds or ports are probably the best package manager to interface to cabal with.
15:30:00 <Twey> mm_freak_ tells me NixOS is really good with it; I'm going that way next time I feel like switching operating systems
15:31:09 <Earnestly> How does NixOS deal with all the duplication?
15:31:24 <mm_freak_> nix is much easier to combine with cabal than portage
15:31:24 <Clint> hacky weirdness
15:31:32 <mm_freak_> i can't speak for ports
15:31:39 <mm_freak_> Earnestly: what duplication?
15:31:39 <Twey> Earnestly: Nix does duplication natively: every version of a package gets its own little sandbox
15:31:58 <tristan__> Cale: around?
15:32:01 <Earnestly> Twey: Yes, so you have multiples of the same libraries installed and more
15:32:07 <colDrMcBeardman> mm_freak_, no doubt it works better
15:32:09 <tristan__> or anyone who has used haskell on heroku
15:32:17 <Earnestly> If you're using btrfs, that might be somewhat acceptable
15:32:19 <mm_freak_> ah, nix doesn't expose cabal dependency hell unless the package dependency graph forcibly requires multiple versions
15:32:32 <jle`> tristan__: i have...but i can't really be considered an expert
15:32:37 <Cale> tristan__: hello?
15:32:52 <tristan__> jle`: did you build on heroku or push a binary?
15:32:57 <tristan__> Cale: have you run haskell on heroku?
15:33:08 <colDrMcBeardman> i wonder if something like venti would be a good storage backend for that. it doesn't store duplicate blocks.
15:33:10 <jle`> tristan__: i pushed, but i think i talked to you specifically about this before
15:33:15 <jle`> my build takes much longer than 15 minutes
15:33:21 <jle`> and i never got around to asking for an extension
15:33:36 <Cale> What's heroku?
15:33:41 <jrmithdobbs> awesomesauce
15:33:44 <Twey> Earnestly: Right.  It's pretty acceptable anyway — libraries don't take up much space by today's standards
15:33:44 <Earnestly> Twey: (I failed in my attempts to try and see how nix deals with the lib/data/etc duplication, if each package gets its owned hashed directory)
15:33:54 <Earnestly> Twey: :I
15:33:59 <tristan__> Cale: oh, my bad, I must be remembering wrong who I was tlaking to earlier today, haha
15:34:02 <platz> it looks like theres a third party buildpack for haskell on heroku
15:34:18 <tristan__> jle`: oh, haha. I remember that now :)
15:34:22 <tristan__> platz: right
15:34:30 <mm_freak_> Earnestly: http://hub.darcs.net/ertes/netwire
15:34:33 <mm_freak_> look into default.nix
15:34:35 <tristan__> but I belive memory and cpu is an issue for building
15:34:45 <mm_freak_> that's what a nixed cabalized project looks like
15:34:46 <Earnestly> mm_freak_: Hm yes?
15:34:47 <tristan__> because of the size of the build tools
15:34:49 <jle`> tristan__: i have used the third party buildpacks to success
15:34:52 <tristan__> and then the time to build
15:34:55 <jle`> on some of my smaller heroku apps
15:35:01 <tristan__> ah ok
15:35:07 <jle`> but smaller as in...
15:35:15 <mm_freak_> Earnestly: that's what a nixed cabalized project looks like (see default.nix)
15:35:20 <Earnestly> mm_freak_, Twey: I like the idea though, I just hate the duplication
15:35:31 <mm_freak_> Earnestly: what duplication?
15:35:38 <bitemyapp> what's the story on haskell-suite?
15:35:52 <bitemyapp> I want to know when Fay can have typeclasses :(
15:35:55 <Earnestly> mm_freak_: How does NixOS deal with it?
15:36:06 <Earnestly> mm_freak_: (I assume they just don't)
15:36:38 <mm_freak_> Earnestly: derivations ("packages") have a pure dependency on the source code, configuration and dependencies…  if none of them changed, there is no reason to rebuild a derivation
15:36:41 <jrmithdobbs> bitemyapp: does it have an IO monad at least?
15:36:46 <mm_freak_> Earnestly: and if multiple projects depend on the same derivation, they can share it
15:36:52 <bitemyapp> jrmithdobbs: does what?
15:36:52 <jrmithdobbs> bitemyapp: i haven't played with it much
15:36:55 <mm_freak_> Earnestly: it's like haskell immutability and sharing
15:36:55 <Earnestly> mm_freak_: So you can share libs?
15:36:56 <jrmithdobbs> bitemyapp: fay
15:36:56 <xil> hello ^_^. I was just wondering, has anyone tried to build hpaste? And if so, did you run into linker problems? I'm getting this http://lpaste.net/99062. I'm just sort of throwing a wide net with this question, since my Google-fu is failing me at the moment =(
15:37:00 <mm_freak_> Earnestly: of course
15:37:06 <Earnestly> mm_freak_: Oh, that is clever then
15:37:07 <bitemyapp> jrmithdobbs: it has something analogous...called Fay.
15:37:28 <jrmithdobbs> bitemyapp: i dunno then, for it's intended use living without typeclasses isn't that bad
15:37:34 <bitemyapp> jrmithdobbs: no.
15:37:37 <bitemyapp> jrmithdobbs: it's *not* okay.
15:37:41 <mm_freak_> Earnestly: that's what "purely functional" means in the context of nix…  it's like when you M.insert into a Map, only the changed parts get rebuilt
15:37:49 <bitemyapp> jrmithdobbs: frontend needs polymorphic collections and niceness too!
15:37:51 <jrmithdobbs> bitemyapp: but it's not awful while they're working with it
15:37:52 <jle`> tristan__: 88 libraries
15:38:03 * bitemyapp grumbles violently
15:38:03 <jle`> although i guess just a number isn' very helpful
15:38:10 <Earnestly> mm_freak_: The website doesn't mention this clearly and I struggled to find any information about how it deals with either sharing libraries or if it simply didn't and you had dozens of duplicate libraries installed for each package (e.g. hundreds of libgmps ;p)
15:38:15 <jrmithdobbs> s/with/on/
15:38:25 <tristan__> oh, Susan made the buildpack for haskell! I can just bother her
15:38:43 <jrmithdobbs> tristan__: which there's a couple floating about
15:39:06 <jle`> tristan__: http://jle0.com/~justin/small_app_deps.txt
15:39:12 <startling> xil, how are you building it?
15:39:26 <xil> startling: cabal configure && cabal build
15:39:31 <startling> xil, weird.
15:40:11 <startling> xil, someone else had a similar problem the other day.
15:40:17 <jle`> tristan__: as a comparison, my large-ish app is http://jle0.com/~justin/large_app_deps.txt
15:40:33 <startling> it's something to do with the 'text' library (multiple versions are getting linked in?) but I'm not sure why cabal allows that.
15:40:46 <tristan__> jle`: hm, ok
15:40:48 <jle`> actually it's not a significantly longer list...just the extra things take a lot longer to build for some reason
15:41:16 <mm_freak_> Earnestly: well, it does mention it somewhere, but yes, it could be emphasized better =)
15:41:24 <startling> xil, you might try ghc-pkg unregistering your older version(s) of text or try building in a sandbox
15:41:27 <xil> startling: oh is it like a global vs user thing? Perhaps if I remove the HStest library and reinstall?
15:41:27 <tristan__> they should then be cached after the first build, if the buildpack is done right
15:41:31 <startling> xil, but I'm just guessing at this point.
15:41:35 <tristan__> so just have to get passed the first run, hehe
15:41:46 <Earnestly> mm_freak_: So to my understanding, it will share any library until something pulls in a different version, and that gets shared with other packages which depend on it thus only two libraries (version 1 and version 2) exist?
15:41:51 <xil> startling: that sounds like a great place for me to start, thanks ^_^
15:42:00 <mm_freak_> Earnestly: exactly
15:42:05 <dwcook> shlevy, you might have noticed this already, but I took another look at async and noticed a function even more like the one you mentioned – concurrently.
15:42:15 <mm_freak_> Earnestly: otherwise the nix store would pretty much blow up =)
15:42:19 <jle`> tristan__: well the entire thing doesn't work without all of them installed togehter
15:42:21 <dwcook> In fact the function you described seems to be uncurry concurrently
15:42:41 <Earnestly> mm_freak_: Indeed, I do think that should be emphasised in bold, flashing (okay you can't use flashing anymore with CSS) text
15:42:48 <Earnestly> mm_freak_: Everyone I speak to has the same concern
15:42:48 <jle`> so the best i could probably do is...commit versions with smaller lists of dependencies that will fail when building
15:42:57 <jle`> and then uncomment until it works
15:43:02 <Earnestly> without*
15:43:08 <jle`> but at that point it would be easier to just push a binary
15:44:06 <mm_freak_> Earnestly: i welcome you to join #nixos and propose this as a non-nixer =)
15:44:24 <Earnestly> Aw, but that requires effort.  Maybe one day
15:44:45 <tristan__> jle`: na, I meant that for the first push you'd need to have te increased build timeout, but after that it'd be fast
15:45:05 <mm_freak_> Earnestly: i'm sad now =(
15:45:18 <Earnestly> :<
15:45:57 <Earnestly> Mainly because it's late, related: nn o/  (thanks though.  I may mention it, but I thought to gain at least some experience with it.)
15:46:31 <jle`> tristan__: ah. yeah, of course :)
15:47:17 <jle`> is there any way to specify record labels on only some fields in a data?
15:47:17 <mm_freak_> Earnestly: no worries, i just tried to social-engineer you into the channel =)
15:47:37 <Earnestly> mm_freak_: I do sometimes do that though
15:47:45 <acowley> Longshot: Does anyone have a nice indentation style for relatively long function types underneath a type constructor?
15:47:53 <acowley> e.g. m (a -> b -> c .... -> z)
15:48:12 <Earnestly> (It's what makes open source so much fun, you can actually speak with people who are directly involved with any requests or issues you have.)
15:48:44 <Earnestly> s/any/and
15:48:47 <mm_freak_> =)
15:49:36 <thoughtpolice> acowley: http://lpaste.net/99063 ?
15:49:59 <thoughtpolice> i'm not sure if that's ugly. i think it's OK. maybe i have bad taste. :P
15:50:09 <acowley> thoughtpolice: Yeah, I do something like that, but I don't really like it
15:50:29 <thoughtpolice> there's nothing to really visually align -> with, yeah
15:50:30 <acowley> The -> don't line up with the ( very well, which can make it a bit hard to tell if their in or out
15:50:34 <acowley> right
15:50:42 <acowley> s/their/they're
15:54:14 <colDrMcBeardman> you could leave the "m (" alone on the line and align the -> with the =>
15:54:27 <colDrMcBeardman> or perhaps with the m would be better.
15:56:22 <acowley> I align -> with the => if they're at the same level, like thoughtpolice did in his example. The nested ones are the problem as they don't fit nicely underneath anything
15:57:06 <ReinH> acowley: type synonym?
15:57:32 <catsup> ReinH: yes
15:57:34 <ReinH> thoughtpolice: can't say I like that lpaste much
15:57:49 <catsup> ReinH: people should do that more
15:57:56 <Twey> thoughtpolice: It's less ugly if you use the proper arrow symbol →
15:57:57 <thoughtpolice> well, i would probably use a type alias if it involved so many parameters it couldn't fit on one line
15:58:02 <ReinH> acowley: GHC suggestion: type-level let bindings
15:58:13 <acowley> ReinH: How would a type synonym help?
15:58:18 <thoughtpolice> if it was just '=> m (a -> b)' or even 'a -> b -> c' it would be fine it would be
15:58:19 <acowley> Just for the function type you mean?
15:58:29 <acowley> thoughtpolice: right
15:58:30 <silasm> ReinH: you can do that?
15:58:34 <ReinH> acowley: yes
15:58:36 <ReinH> silasm: you can?
15:58:37 <thoughtpolice> bleh, didn't ^K
15:58:49 <ReinH> something like: let MyShittyType :: a -> b -> c -> d in m MyShittyType
15:58:52 <acowley> ReinH: Yeah, I have some misgivings about that, but I have done it at times
15:59:07 <acowley> ReinH: Yeah, that kind of local scoping would be nice as I don't like throwing a new name out there
15:59:18 <ReinH> acowley: well you don't have to export it :p
15:59:25 <acowley> ReinH: Yeah, but it's always a crappy name
15:59:39 <ReinH> acowley: I'm sort of ok with messy internal namespaces if the exports are clean
15:59:50 <Twey> thoughtpolice: You could also consider putting all those parameters into a record
15:59:55 <acowley> ReinH: I am too, in general, but types are where I want clarity
16:00:07 <acowley> ReinH: I'm used to crappy value names that are made sensible by their types
16:00:16 <Twey> Er, also acowley
16:00:21 <acowley> ReinH: I'm being fussy
16:00:36 <ReinH> acowley: well if your a -> b -> c -> d doesn't have a meaningful name... maybe it is bad? :p
16:00:59 <acowley> ReinH: It deserves basically the same name as whatever your defining that has type m (a -> b -> c ...)
16:01:28 <acowley> ReinH: So you end up using the same name, or a suffix or something
16:01:42 <acowley> e.g. foo :: m (Foo)
16:03:06 <ReinH> acowley: maybe you suck at naming things. Just like everyone else.
16:03:33 <acowley> ReinH: I absolutely do, which is why I'm resisting it!
16:11:24 <startling> With data Cardinal = N | E | S | W, should I do data Four a = Four a a a a or data Four a = Four (Cardinal -> a)?
16:12:00 <shachaf> If you do the latter it should probably be newtype.
16:12:05 <startling> that's true.
16:12:20 <shachaf> Anyway, it's up to you.
16:12:26 <shachaf> Note that e.g. laziness behavior will be different.
16:12:30 <startling> yeah.
16:13:02 <startling> Maybe I should go with newtype Cardinal = Cardinal (forall a. Lens' (Four a) a)
16:13:56 <prooftechnique> wow, such generality
16:13:59 <edwardk> startling: you can always just use linear's V4, and use incore
16:14:17 <startling> edwardk, incore?
16:14:48 <edwardk> core :: Core f => ((forall g x. Functor g => (x -> g x) -> f x -> g (f x)) -> a) -> f a
16:14:59 <startling> profmakx: yeah, my ultimate goal is to generalize this for n-dimensionality. 8)
16:15:02 <edwardk> incore was renamed to column recently, but i meant core. sorry
16:15:55 <edwardk> core :: Core f => ((forall x. Lens (f x) x) -> a) -> f a
16:16:21 <edwardk> old lens used to provide a newtype that held forall x. Lens' (f x) x
16:16:46 <edwardk> but Control.Lens.Representable was killed
16:17:24 <startling> where is Core?
16:17:32 <edwardk> Linear.Core in linear
16:17:48 <startling> edwardk: while I've got you on the line, could you explain how Linear.V is supposed to be used? :)
16:17:59 <edwardk> V 4 Int    is a vector of 4 ints ;)
16:18:13 <edwardk> you can add them etc.
16:18:26 <shachaf> type a `Of` b = a b
16:18:26 <edwardk> V 4 (V 100 Double) is a 4x100 matrix
16:18:38 <startling> edwardk: it doesn't have to be V $(int 4) Int or anything?
16:18:56 <edwardk> startling: using the numeric literals directly works on 7.6+
16:19:02 <startling> edwardk: oh, nice
16:19:21 <startling> edwardk: so how is fromVector supposed to be used?
16:19:45 <edwardk> with reflection if you want to be compatible with older GHCs you can use V $(4) Int
16:20:01 <startling> I don't care about older GHCs.
16:20:08 <edwardk> Sadly, V $4 In doesn't pass syntax
16:21:09 <edwardk> well, you can avoid fromVector and just use Core most of the time.
16:21:27 <edwardk> pure 0 gives a vector of 0's, etc.
16:21:48 <edwardk> I should probably add a fromList or something as well
16:21:48 <startling> Core looks like exactly what I want. hmm, interesting.
16:23:53 <jowens> hey, i have a functional programming pattern that I was hoping to identify in terms of haskell idioms. Lemme describe a simple use case: factoring a large integer. I can write a function that has three arguments: a seed, a list-so-far, and a list of primes. I initialize it as "factor seed [] primes". Then every iteration, I see if the head prime divides into the seed; if so, I put it into the list-so-far and recurse, if not, I 
16:23:53 <jowens> the head of the primes list and recurse. Base case is seed == 1. Is there a nice functional pattern with a Haskell construct that matches this?
16:24:49 <startling> jowens, fold
16:24:55 <startling> sorry, mis-return
16:25:03 <jowens> see, i've always thought fold was more of a 2-argument thing.
16:25:10 <startling> foldM on a Writer might be the right thing
16:25:24 <startling> jowens, well, you can use a tuple for the "state"
16:25:43 <jowens> ok. i think i can hang with that.
16:25:50 <startling> :t foldM
16:25:51 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
16:26:14 <jowens> haven't got to monads yet, can i do this with plain old fold?
16:26:31 <bitemyapp> :t foldr
16:26:32 <lambdabot> (a -> b -> b) -> b -> [a] -> b
16:26:41 <bitemyapp> looks different to me.
16:26:45 <hpc> jowens: if you could, it wouldn't be worth it for the mental effort to read
16:26:56 <hpc> i personally wouldn't even use foldM
16:27:39 <edwardk> hrmm, i just realized it is a bit of a pain in the ass to make a unit vector for linear.
16:27:49 <hpc> it seems to me, the clearest definition would be the explicit recursive
16:28:08 <startling> edwardk, pure 1?
16:28:17 <edwardk> unit :: (Applicative a, Num a) => Lens' (t a) a -> t a
16:28:21 <edwardk> er
16:28:23 <edwardk> Applicative t
16:28:42 <edwardk> is what i want
16:28:50 <jowens> hpc: i've now written it twice in the first 5 problems of Project Euler so figure i ought to figure out how to abstract it :)
16:28:52 <adrian_berg> What is the difference between class and type, are they not both used for creating type classes?
16:28:57 <edwardk> you can make pure 1, but it is a linear combination of all the basis vectors.
16:29:10 <adrian_berg> I've noticed that class and instance seem to go together as well.
16:29:22 <hpc> jowens: exactly the same, or variations?
16:29:24 <startling> adrian_berg: a "typeclass" in haskell is like an interface in OO languages. certain types implement certain typeclasses.
16:29:30 <startling> adrian_berg: they're very different.
16:29:33 <hpc> also, today in hilarious problems: https://github.com/vincenthz/hs-tls/issues/48
16:29:45 <hpc> services that may or may not be encrypted
16:30:03 <bitemyapp> adrian_berg: class is the interface spec, instance is the implementation.
16:30:06 <jowens> hpc: fairly close, actually. one was for factoring a prime number. the other was taking a big prime number and eliminating some of its factors.
16:30:16 <hpc> hmm
16:30:53 <hpc> jowens: perhaps take the parts that are the same and make those a function with extra parameters
16:31:12 <ReinH> jowens: if you don't want to deal with monads, try folding up into a tuple instead
16:31:12 <hpc> not an existing abstraction per-se, but just a higher-order version of what you already have
16:31:15 <jowens> hpc: fold is close and perhaps with a tuple as the accumulator I can make it work.
16:31:37 <adrian_berg> It isn't clear to me how when you would use the data/val constructors versus when you would want to use type class constructors.
16:31:42 <hpc> probably
16:31:48 <jowens> issue is that the "list" is infinite, so I need a way to end it.
16:32:02 <hpc> anyway, do what you can most easily maintain is my advice ;)
16:32:06 <jowens> (in the case of prime number factorization, list == list of primes)
16:32:08 <ReinH> jowens: the list you're folding over?
16:32:11 <ReinH> right
16:32:31 <hpc> adrian_berg: type classes don't have constructors
16:32:37 <silasm> adrian_berg: typeclasses specify traits that types can have (e.g. Eq specifies types can be compared for equality). Types specify concrete types you can work with.
16:32:54 <heatsink> Is there a way to cast CFloat to Float that is a no-op at runtime?
16:33:01 <heatsink> realToFrac calls toRational and fromRational
16:33:15 <ReinH> jowens: then you don't want a fold to begin with unless you can do it productively
16:33:23 <bitemyapp> adrian_berg: there's usually some laws associated.
16:33:28 <hpc> also, "type classes are like interfaces" is a bit misleading, because you can do weird OO things with interfaces that you can't necessarily do with type classes
16:33:48 <hpc> a better description would be that a type class is a set of functions/values that many types might have in common
16:33:59 <jowens> ReinH: sensible. the recursion isn't that hard to write. I was just trying to understand Haskell's idioms.
16:34:10 <heatsink> What can you do with interfaces that you can't with type classes?
16:34:22 <hpc> for instance, lots of types can have all of their values listed
16:34:22 <roboguy_> adrian_berg: "type" just specifies a type synonym. This is sort of like a typedef from C
16:34:27 <hpc> the type class for that is Enum
16:34:30 <hpc> @src Enum
16:34:30 <lambdabot> class  Enum a   where
16:34:30 <lambdabot>     succ                     :: a -> a
16:34:30 <lambdabot>     pred                     :: a -> a
16:34:30 <lambdabot>     toEnum                   :: Int -> a
16:34:30 <lambdabot>     fromEnum                 :: a -> Int
16:34:32 <lambdabot> [3 @more lines]
16:34:37 <acowley> It's more the identifiers and types are in common, not the values
16:34:38 <ReinH> jowens: you can write an idiom that folds up into a Maybe and stops at a Nothing if you want. I'm not sure if that exists already off hand.
16:34:44 <bitemyapp> ReinH: productively?
16:34:56 <hpc> lots of types are finite too, which is Bounded
16:34:57 <bitemyapp> ReinH: I work at a genetics company, "productively folding" holds a different definition :)
16:34:59 <hpc> @src Bounded
16:35:00 <lambdabot> class  Bounded a  where
16:35:00 <lambdabot>     minBound, maxBound :: a
16:35:08 <ReinH> bitemyapp: i.e. can it produce values before consuming the entire list, I think I mean guarded recursion
16:35:24 <ReinH> > foldr (&&) True (repeat False) -- bitemyapp
16:35:25 <lambdabot>  False
16:35:32 <hpc> so for instance, Bool can be listed in order, and it has a min/max element
16:35:39 <bitemyapp> ReinH: gatcha.
16:35:49 <ReinH> bitemyapp: I've also heard it called "productive" I thin
16:35:51 <ReinH> think
16:36:03 <hpc> instance Bounded Bool where minBound = False; maxBound = True
16:36:17 <jowens> thanks team. appreciate the guidance!
16:36:32 <prooftechnique> jowens: Do you need the entire list of primes? Or just a part of it?
16:36:44 <hpc> ^ says that when you use minBound or maxBound in a place where 'a' in their type is 'Bool', those are their definitions
16:36:49 <hpc> > minBound :: Bool
16:36:50 <lambdabot>  False
16:37:19 <jowens> prooftechnique: well, i'd like something that factored a large integer to potentially work with *any* integer, so unbounded is preferable
16:37:25 <ReinH> jowens: the Last monoid might be useful
16:37:29 <hpc> > [minBound, True, length "type inference at work!" > 5]
16:37:30 <lambdabot>  [False,True,True]
16:37:51 <hpc> adrian_berg: hope that helps
16:38:12 <ReinH> jowens: for guarded recursion on maybe values
16:38:46 <jowens> ReinH: looks interesting (once I learn monoids ;) ) - thanks. (IRC client correcting "monoids"  to "mono ids")
16:38:52 <ReinH> heh
16:40:44 <roboguy_> jowens: I bet you already know a lot of monoids: addition over integers, multiplication over integers, string concatenation, composition of functions of the type a -> a. The main thing to learn is what those things (and things like them) have in common
16:40:59 <heatsink> Is it portable to assume that CFloat is a newtype of Float?
16:41:08 <roboguy_> well, addition over integers with 0 and multiplication over integers wiht 1
16:41:09 <roboguy_> *with
16:41:44 <jowens> roboguy_: I'm conversant with monoids in the context of a scan primitive, but not in the Haskell context (yet)
16:42:08 <roboguy_> jowens: scan primitive?
16:42:17 <heatsink> as in scanl
16:42:18 <ReinH> @src Monoid
16:42:18 <lambdabot> class Monoid a where
16:42:18 <lambdabot>     mempty  :: a
16:42:18 <lambdabot>     mappend :: a -> a -> a
16:42:19 <lambdabot>     mconcat :: [a] -> a
16:42:25 <ReinH> jowens: there you go :)
16:43:19 <jowens> scanl looks like the haskell equivalent, yah
16:43:27 <dmwit> heatsink: I don't think you're guaranteed that by anything, but I don't know of any architectures where it isn't true.
16:43:43 <heatsink> ok dmwit
16:43:48 <dmwit> heatsink: But the usual conversion functions have rewrite rules to id, so why make that assumption?
16:44:20 <roboguy_> jowens: I'm not sure I understand what scan has to do with monoids, other than the fact that [a] is a monoid. I guess you could generalize it...
16:44:33 <jowens> scan takes (AFAIK) a monoid as its "operator"
16:44:35 <jowens> does that make sense?
16:44:46 <heatsink> dmwit, I am getting massive speedup on converting an array of CFloat to a vector of Float if I use newtype conversion instead of realToFrac
16:44:47 <jowens> i.e., operators that are not monoids don't work with scan
16:44:55 <heatsink> It seems that toRational and fromRational are called at run time
16:44:57 <prooftechnique> Operators are not monoids
16:45:02 <dmwit> heatsink: Ah, right. That's a pretty good reason, yeah.
16:45:09 <jowens> i'm definitely playing fast and loose with terminology
16:45:13 <roboguy_> jowens: that doesn't really make sense to me
16:45:14 <prooftechnique> An operator is a component of a monoid
16:45:24 <jowens> scan works with, say, the addition and multiplication "operators"
16:45:29 <jowens> or string concatenation
16:45:31 <heatsink> jowens, A monoid consists of a type, a binary operator like +, and a neutral element like 0
16:45:32 <dmwit> heatsink: Well, you should be able to get GHC to not call toRational and fromRational.
16:45:39 <dmwit> heatsink: But you'll still get a map-like operation.
16:45:40 <roboguy_> jowens: does scan work with subtraction?
16:45:44 <jowens> heatsink: yeah, that operator.
16:45:48 <dmwit> heatsink: Have you tried making realToFrac monomorphic at its call site?
16:45:50 <jowens> roboguy_: no. since it's not associative.
16:46:02 <dmwit> heatsink: (And be sure to have optimizations on, of course.)
16:46:11 <shachaf> If you want to call (A,(*),1) a monoid but not call (*) a monoid, I guess you can do that. But the other parts are uniquely determined by the operator.
16:46:21 <roboguy_> > scanl (-) 0 [1..10]
16:46:22 <lambdabot>  [0,-1,-3,-6,-10,-15,-21,-28,-36,-45,-55]
16:46:24 <silasm> jowens: scan doesn't have to operate on a monoid, though. You have more options for how you compute it if you are using a monoid though (which comes from the associativity law Monoids require).
16:46:37 <ReinH> roboguy_: what about class Scan f where scanl, scanr :: Monoid m => f m -> (m, f m)
16:46:37 <roboguy_> seems to work with subtraction to me...
16:46:38 <jowens> i'm not trying to redefine any terminology, since i don't know Haskell monoids *at all*
16:46:40 <dmwit> heatsink: Also, note that having "foo = realToFrac" and then calling "foo" instead of "realToFrac" is already enough to break this optimization. That was a subtle performance bug in gtk2hs for a while.
16:47:05 <jowens> i'm just saying that in my world, the class of operators that work with scan appear to be called "monoids", where "monoid" vaguely means "associative binary operators"
16:47:06 <shachaf> dmwit: GHC doesn't inline foo?
16:47:09 <FreeFull> shachaf: Aren't there operators with multiple identities?
16:47:16 <shachaf> Or inlines it too late or something?
16:47:26 <dmwit> I don't recall exactly what dies.
16:47:34 <dmwit> Possibly it had to do with module/package boundaries as well.
16:47:46 <jowens> this is the "scan" of which I speak: http://en.wikipedia.org/wiki/Prefix_sum
16:47:47 <heatsink> dmwit, I just now tried giving the calling function a monomorphic type signature, and it became as fast as newtype conversion
16:47:48 <shachaf> Of course, f = id is just a local thing.
16:47:50 <prooftechnique> FreeFull: You can set whatever you like as an identity, but your results are not guaranteed to be sensible. :D
16:48:08 <dmwit> heatsink: Great!
16:48:08 <shachaf> E.g. if f = id then map f = map id which might be different from id.
16:48:11 <roboguy_> jowens: but why does that require a monoid?
16:48:25 <FreeFull> prooftechnique: I mean, that would make a valid monoid
16:48:28 <jowens> again, i am using "monoid" to refer to "binary associative operator"
16:48:40 <roboguy_> jowens: why does it need to be associative?
16:48:52 <jowens> when i teach it, i teach "binary associative operator", but I have been told mathematically, that means "monoid"
16:48:54 <heatsink> Efficient parallel scan is fast with an associative operator
16:49:01 <jowens> it needs to be associative to run in parallel
16:49:06 <jowens> thx heatsink
16:49:07 <silasm> jowens: there's no need for scanl to be associative unless you want to evaluate it efficiently in parallel.
16:49:11 <haasn> (monoids have an identity too)
16:49:13 <roboguy_> ahh
16:49:15 <jowens> silasm: that is probably true
16:49:30 <FreeFull> I still want scanl' to exist
16:50:00 <silasm> (even then it need only be a semigroup, but having the identity is really useful if your data structure allows for empty values)
16:51:46 <ReinH> silasm: scan : scanl :: fold :: foldl
16:52:14 <silasm> ReinH: ...what am I looking at?
16:52:35 <ReinH> silasm: scanning a monoid is to scanl like folding a monoid is to foldl
16:52:37 * heatsink hasn't seen that notation since taking SATs
16:53:12 <heatsink> argmin is an example of a semigroup operation.  Argmin can be parallelized similarly to scan, but you can't supply a "default value" for argmin of an empty array.
16:53:15 <shachaf> scan?
16:53:19 <silasm> ReinH: heatsink: yeah, the usage of colons confused me lol. You should know better than to use them that way in this channel
16:53:23 <ReinH> silasm: you could use a unital magma since you don't need associativity but who uses magmas?
16:53:27 <ReinH> silasm: yeah whoops
16:53:35 <shachaf> :t scan
16:53:35 <lambdabot>     Not in scope: `scan'
16:53:36 <lambdabot>     Perhaps you meant one of these:
16:53:36 <lambdabot>       `scanl' (imported from Data.List),
16:58:10 <ReinH> shachaf: I'm thinking of scan :: Monoid m => [m] -> [m]; scan = scanl mappend mempty, which doesn't exist but could
16:58:14 <silasm> @src magma
16:58:14 <lambdabot> Source not found. Maybe if you used more than just two fingers...
16:58:20 <silasm> @src Magma
16:58:20 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:58:28 <silasm> :S
16:58:28 <ReinH> silasm: a magma is a set with a binary operator
16:58:38 <ReinH> no one cares about magmas
16:58:40 <silasm> ReinH: figured, but I'd never heard of it.
16:58:41 <shachaf> Lots of things could exist but shouldn't.
16:58:53 <ReinH> shachaf: noted
16:59:03 <ReinH> The point being, scanning a monoid makes sense
16:59:43 <ReinH> silasm: iirc it used to be called a groupoid until cat theory stole that term
17:00:26 <silasm> shame, we need more 'oids'. Those don't tend to overlap with normal english as often.
17:00:28 <dmwit> Does scanning a monoid make sense?
17:00:39 <silasm> dmwit: why not?
17:00:46 <ReinH> dmwit: doesn't it? scanl mappend mempty
17:00:59 <dmwit> The 'l' in scanl is about more than just associativity.
17:01:02 <silasm> scan $ map Sum [1..100]
17:01:06 <ReinH> silasm: iirc magma is actually french
17:01:12 <dmwit> It also tells which chunks of the list are involved in a particular output element.
17:01:30 <ReinH> dmwit: that's true, you can have a number of different monoidal scans
17:01:35 <ReinH> left-scans, right-scans, tree-scans
17:01:36 <ReinH> whatever you want
17:01:49 <dmwit> no
17:02:00 <dmwit> I don't think I'm making my point clear.
17:02:05 <dmwit> fold makes sense. It has a single output.
17:02:10 <dmwit> scan doesn't make sense. It has many outputs.
17:02:32 <ReinH> Ok...
17:02:39 <dmwit> Associativity doesn't help with picking which elements should participate in the outputs.
17:03:05 <ReinH> dmwit: like I said, you only need a unital magma, the choice is determined by the way scan is implemented
17:03:08 <dmwit> (With a fold there's no such choice: all elements participate in the output.)
17:03:08 <ReinH> has nothing to do with associativity
17:03:09 <jmcarthur> jowens: btw, unless you also have an identity, the thing you described (binary associative (closed, i assume) operator) is a semigroup, not necessarily a monoid
17:03:21 <jowens> jmcarthur: entirely possible.
17:03:26 <jowens> er
17:03:29 <jowens> yes, you need an identity
17:03:38 <silasm> (mildly related link drop): http://vimeo.com/6624203
17:03:46 <dmwit> So why are we talking about monoids, then?
17:03:50 <jmcarthur> for the nice parallelism properties, you don't always need an identity
17:03:54 <heatsink> ReinH, I think dmwit is saying that "scanning a monoid" is underspecified
17:04:19 <silasm> point about how monoids help with scan doesn't come up till later in that video, but yeah
17:04:28 <ReinH> dmwit: because jowens said he was familiar with monoids in the context of a "scan primitive"
17:04:29 <jowens> for the "exclusive scan", the first element of the output is the identity
17:04:32 <ReinH> dmwit: I was thinking about what that could be
17:04:34 <silasm> that's with reference to parallel scanl though ofc
17:04:44 <dmwit> You can't go "let's get rid of the 'l' in scanl by using a monoid operation" because the 'l' in "scanl" is about telling which parts of the input list participate in the output!
17:05:00 <ReinH> silasm: it was a poor name choice then. I'm not trying to get rid of the 'l'.
17:05:07 <ReinH> call it scanlMonoidal
17:05:18 <dmwit> ooookay
17:05:20 <dmwit> sure, why not
17:05:23 <silasm> scanlDefault
17:05:36 <silasm> and have it use magma just because
17:05:40 <heatsink> scanl is usually what people mean when they say scan.
17:05:41 <roboguy_> dmwit: wait, if it's monoidal wouldn't scanr = scanl?
17:05:47 <dmwit> roboguy_: Definitely not.
17:05:55 <ReinH> no
17:06:03 <dmwit> > scanr (+) [1..5]
17:06:05 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable t0)
17:06:05 <lambdabot>    arising from a use of `M389023421496188964429099.show_M3890234214961889644...
17:06:05 <lambdabot>  The type variable `t0' is ambiguous
17:06:05 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
17:06:05 <lambdabot>  Note: there are several potential instances:
17:06:12 <dmwit> derp
17:06:16 <dmwit> > scanr (+) 0 [1..5]
17:06:17 <lambdabot>  [15,14,12,9,5,0]
17:06:21 <dmwit> > scanl (+) 0 [1..5]
17:06:23 <lambdabot>  [0,1,3,6,10,15]
17:06:30 <ReinH> heh scanrMap Sum [1..5] :p
17:07:12 <jowens> scanl there is what i call "exclusive scan"
17:07:29 <ReinH> a.k.a. a prefix scan?
17:07:47 <silasm> ReinH: yeah scanlMap and scanrMap, sure.
17:07:51 <roboguy_> ah
17:07:58 <silasm> so it'd be like foldMap but still with l and r
17:08:21 <ReinH> ala Sum scanrMap [1..5] wouldn't be that bad at all
17:09:34 <ReinH> also any foldable is scannable right, so we can do scanrMap :: Foldable f, Monoid m => f m -> [m]
17:09:35 <jowens> ReinH: Yea!
17:09:45 <jowens> prefix sum, parallel prefix operation, etc.
17:09:54 <roboguy_> > scanr (+) 0 [1..5]
17:09:55 <lambdabot>  [15,14,12,9,5,0]
17:09:57 <ReinH> yeah Conal did a thing http://conal.net/blog/posts/composable-parallel-scanning
17:10:05 <ReinH> jowens: ^
17:10:06 <roboguy_> > reverse $ scanl (+) 0 $ reverse [1..5]
17:10:07 <lambdabot>  [15,14,12,9,5,0]
17:10:12 <roboguy_> hm
17:10:16 <ReinH> jowens: might be interesting to you given your background
17:10:34 <silasm> ReinH: why not scanrMap :: (Foldable f, Monoid m, Sequence c) => f m -> c m ?
17:10:36 <jowens> ReinH: Yeah, he's come to visit us before, a good guy!
17:10:47 <silasm> if we really want to generalize like crazy here
17:10:49 <ReinH> jowens: nice!
17:10:55 <ReinH> silasm: which of course we do
17:11:46 <silasm> or rather I did that wrong, Sequence is a little weird
17:12:00 <silasm> ReinH: scanrMap :: (Foldable f, Monoid m, Sequence c m) => f m -> c
17:12:27 <silasm> if I'm remembering right.
17:12:36 <silasm> :i Sequence
17:12:49 <silasm> lambdabot doesn't :i?
17:13:04 <dmwit> no
17:13:23 <silasm> @faq why don't you :i?
17:13:23 <lambdabot> The answer is: Yes! Haskell can do that.
17:13:30 <dmwit> Believe it or not, \bot is not ghci. =P
17:18:27 <ReinH> there has to be some sort of algebra of scans right?
17:18:38 <ReinH> Haha thanks google http://www.cs.ox.ac.uk/ralf.hinze/publications/MPC04.pdf
17:19:20 <ReinH> .oO(Is there an algebra of scans?) Google: "An Algebra of Scans" [PDF]
17:20:26 <jowens> thx to all for illuminating discussion
17:20:27 <Cale> ReinH: also check out the quote there after the abstract!
17:20:31 <jowens> over and out
17:20:50 <ReinH> Cale: Oscar Wilde, nice, but why?
17:22:02 <ReinH> Huh, the paper includes the following sentence: "The binary operation underlying a scan must be associative."
17:22:40 <ReinH> Cale: oh fans, right
17:22:43 <Cale> Fans, yeah
17:23:10 <ReinH> This is a surprisingly interesting paper for something I searched for at random at the tail end of a random haskell discussion
17:27:37 <path[l]> @faq I would do anything for love, but I wont do that
17:27:37 <lambdabot> The answer is: Yes! Haskell can do that.
17:28:41 <adrian_berg> are type classes themselves types?
17:29:09 <adrian_berg> class Enum a where <-- Enum here is a type
17:29:14 <heatsink> No
17:29:16 <adrian_berg> Is it also a a data type?
17:30:06 <adrian_berg> Thanks to whoever maintains the logs, sorry for the sporadic conversation
17:30:41 <heatsink> "class Enum a" says that 'a' stands for a type that is an Enum
17:30:56 <heatsink> A type class is actually a set of types
17:31:18 <heatsink> @instances Enum
17:31:18 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
17:31:29 <heatsink> Enum contains all those types
17:32:08 <dwcook> With multi-parameter type classes, they're relations
17:36:16 <Cale> adrian_berg: You can imagine implementing type classes by compiling them into data types though, consisting of record types with fields for each of the methods, and compiling instances into specific record values (or functions on those, for instances which depend on others)
17:37:12 <Cale> (But that's just one possible implementation, and the language doesn't let you actually access those record types.)
17:37:21 <dleedev> what does "boxed" and "unboxed" mean in haskell?
17:37:37 <heatsink> A boxed value is stored in a piece of dynamically allocated memory
17:37:48 <Cale> um
17:37:50 <dwcook> data MonadType m = MonadType { return :: a -> m a, (>>=) :: m a -> (a -> m b) -> m b } -- You need to supply the "instance" manually
17:38:17 <heatsink> An unboxed value is not dynamically allocated, but may be stored in registers or inside another object
17:38:18 <Cale> dleedev: In GHC, boxing refers to the manner in which values are represented by pointers to code
17:38:46 <dwcook> Oh woops
17:39:02 <dwcook> I didn't provide an a
17:39:08 <dwcook> or a b for that matter
17:39:12 <dwcook> Hmm…
17:39:26 <dleedev> do haskell programmers need to understand the concerted of boxing?
17:39:36 <dwcook> Oh, it needs a local type variable
17:39:36 <dleedev> or is it a compiler-level issue?
17:39:49 <roboguy_> dleedev: it is possible to work with unboxed types directly, so yes
17:39:53 <dleedev> s/concerted/concept (bad autocorrect)
17:39:55 <dwcook> data MonadType m = MonadType { return :: forall a. a -> m a, (>>=) :: forall a b. m a -> (a -> m b) -> m b } -- You need to supply the "instance" manually
17:39:59 <heatsink> For some kinds of performance optimization, it is important to understand how boxing works
17:40:09 <heatsink> It is not necessary for expressing algorithms
17:40:13 <jle`> dleedev: it's usually mostly important in the context of performance
17:40:20 <dleedev> where can I read up on that?
17:40:23 <jle`> compare Data.Vector.Boxed and Data.Vector.Unboxed
17:40:27 <Cale> dleedev: There are two things which boxing enables: laziness, and polymorphism
17:40:59 <Cale> Because all values have a uniform representation and size in memory, functions like map :: (a -> b) -> [a] -> [b] need only be compiled once
17:41:29 <heatsink> dleedev: This reference describes technically how unboxing interacts with optimizations.  It assumes familiarity with GHC's internal representation. http://www.google.com/url?sa=t&rct=j&q=unboxed+values+as+first+class+citizens&source=web&cd=2&cad=rja&ved=0CC4QFjAB&url=http%3A%2F%2Fciteseerx.ist.psu.edu%2Fviewdoc%2Fsummary%3Fdoi%3D10.1.1.50.231&ei=sxXjUsqtD8S2qgHVmYH4DA&usg=AFQjCNHSBqh5uYCu4DM_HM_K0yEh_NSEeA
17:41:35 <heatsink> Sorry, let me fix that link
17:41:35 <Cale> The reason that one compiled version of map can operate on any types of values is because all values (code pointers) take the same amount of space
17:41:42 <heatsink> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.231
17:41:55 <dleedev> heatsink: I'm not familiar with GHC's internal representation... newbie here
17:42:20 <jle`> is there a way to only define record labels for some of your fields?
17:42:38 <heatsink> Cale, I don't think that boxing has to do with laziness.  Strict languages have the same boxed/unboxed distinction that Haskell does.
17:42:41 <jle`> hlint is complaining to me about unused record labels but i use other ones >.
17:42:43 <jle`> >.>
17:42:45 <dwcook> jle`, don't think so, but you don't have to export them all.
17:42:45 <Cale> heatsink: sure
17:42:53 <Cale> heatsink: But we use it for both.
17:43:00 <heatsink> sure
17:43:01 <jle`> dwcook: i just don't want the blue arrows on my syntastic margins
17:43:09 <jle`> i want a clean ghc-mod output :'(
17:43:16 <Cale> With lazy evaluation, we need some way to represent not-yet-evaluated expressions at runtime.
17:43:35 <jle`> a clean hlint
17:43:38 <Cale> So, by representing all variables and constructor fields as pointers to code
17:43:43 <Saizan> jle`: start the name with _
17:43:48 <dwcook> jle`, sounds like more a problem with that program, maybe something that should be configurable but isn't
17:43:57 <jle`> oh
17:44:02 <Cale> we can have that code compute the value the first time it is entered
17:44:09 <jle`> Saizan: i just tried that on a whim right before you said it
17:44:11 <jle`> and it worked
17:44:20 <Saizan> cheers :)
17:44:26 <Cale> and rewrite the pointer to point at a shorter piece of code which returns the value immediately on subsequent entries
17:44:38 <jle`> dwcook: i would want hlint to notify me of record fields i was defining and not using though in the general case
17:44:41 <Cale> dleedev: make sense?
17:44:45 <jle`> Saizan: thanks :)
17:44:51 <dwcook> Oh I see
17:45:27 <Cale> dleedev: Are you generally familiar with what lazy evaluation is? (i.e. that it's innermost first evaluation with sharing?)
17:45:29 <dleedev> Cale: so boxed values are thunks?
17:46:07 <Cale> Yeah
17:46:12 <dleedev> Cale: I'm generally familiar, but I don't grok "innermost first evaluation with sharing"
17:46:23 <Cale> Okay, so let's do this little demo :)
17:46:34 <Cale> Imagine we have the program double x = x + x
17:46:44 <tristan__> I don't know what I've done but I can't get cabal 1.18 to work again.. I installed haskel-platform from ubuntu repos, then do 'cabal install cabal' to install 1.18.x
17:46:46 <Cale> and we want to evaluate  double (double 5)
17:47:00 <Cale> er, sorry, *outermost-first*
17:47:12 <Cale> I just realised that I derped out there :)
17:47:25 <Cale> Under strict evaluation, which *is* innermost-first:
17:47:29 <Cale> double (double 5)
17:47:33 <Cale> -> double (5 + 5)
17:47:36 <Cale> -> double 10
17:47:39 <Cale> -> 10 + 10
17:47:41 <Cale> -> 20
17:47:59 <Cale> If we do outermost-first evaluation in a naive way, we instead get this:
17:48:04 <Cale> double (double 5)
17:48:05 <dwcook> So when it's said that Haskell has non-strict semantics, does that really mean "not necessarily strict"?
17:48:10 <Cale> -> (double 5) + (double 5)
17:48:19 <Cale> -> (5 + 5) + (double 5)
17:48:23 <Cale> -> 10 + (double 5)
17:48:27 <Cale> -> 10 + (5 + 5)
17:48:29 <Cale> -> 10 + 10
17:48:31 <Cale> -> 20
17:48:57 <dleedev> yeah, I get that
17:48:59 <tristan__> doh, cabal-install
17:49:07 <Cale> dwcook: It means roughly that the termination behaviour and results have to be the same as with outermost-first evaluation
17:49:16 <Cale> dleedev: Okay, so we duplicated work there
17:49:26 <jle`> tristan__: cabal update should give you a friendly reminder :)
17:49:29 <Cale> because the parameter x to double occurs twice in the body of the function
17:49:38 <heatsink> What doesn't work, tristan__?
17:50:13 <Cale> dleedev: So we might endeavour to do something a little more clever, and say that whenever a variable occurs more than once in its scope, any computation done to it should be shared between the copies
17:50:24 <Cale> We can represent that sharing with let/in syntax
17:50:30 <Cale> double (double 5)
17:50:43 <Cale> -> let x = double 5 in x + x -- note that this is still outermost-first
17:50:50 <tristan__> jle`: ah :)
17:50:51 <Cale> -> let x = 5 + 5 in x + x
17:50:55 <Cale> -> let x = 10 in x + x
17:51:00 <Cale> -> 10 + 10
17:51:01 <Cale> -> 20
17:51:42 <dleedev> got it
17:51:59 <Cale> Of course, in the real implementation, that sharing is done with pointers to the same thing
17:52:19 * flebron might give Elm a try simply because now finally n * fac (n - 1) types, without extra parenthesis :)
17:53:17 * flebron checks that the same is true in haskell, and promptly erases the last sentence rom everyone's memory. Nothing to see here, move along...
17:53:26 <Cale> Also, in the real implementation, GHC won't *always* evaluate things outermost-first. It will be stricter in many cases where it can discover it can do so without adversely affecting termination behaviour.
17:54:10 <Cale> flebron: I was wondering which extra parentheses you meant.
17:54:34 <flebron> (For some reason I had it ingrained in me that I needed to write n * (fac (n - 1))...)
17:54:38 <Cale> ah
17:54:45 <dleedev> Cale: so the pointer is only useful if a variable is used twice in your code?
17:55:02 <jle`> sometimes the tightness of function binding trips me up still
17:55:10 <Cale> dleedev: Well, as I mentioned before, it's also useful that things are uniformly recorded this way for polymorphism
17:55:23 <jle`> like sin 0.5**2
17:55:54 <Cale> dleedev: Functions which take a value of an arbitrary type don't have to be compiled multiple times for different sizes of argument
17:57:00 <Cale> dleedev: So, when you look at the boxed array types versus the unboxed ones, these are the two differences you see: boxed arrays can have elements which are computed lazily, and their elements can be of any type whatsoever
17:57:45 <Cale> while unboxed arrays can only hold elements of specific types of fixed sizes, and they must be computed all at once
17:58:23 <Cale> (because they lack the machinery for both polymorphism and laziness)
18:00:42 <Cale> (What's the quote? "Every problem in computer science can be solved with one more level of indirection.")
18:01:05 <jle`> how do i use the putStrLn from fay-base's Prelude instead of ghc's prelude?
18:01:40 <Tekmo> jle`: I think you can use {-# LANGUAGE NoImplicitPrelude #-} and then import fay's prelude
18:01:53 <Cale> jle`: I doubt you can depend on both base and fay-base, can you?
18:02:06 <jle`> i tried depending on fay-base
18:02:07 <Tekmo> Alternatively, if it's just one function, you can do `import Prelude hiding (putStrLn)` and then import `putStrLn` from the fay prelude
18:02:09 <jle`> but
18:02:19 <jle`> not none of my normal ghc things compile
18:02:21 <ReinH> Tekmo: hi
18:02:23 <jle`> because there are two preluds
18:02:24 <ReinH> Tekmo: mind if I pm?
18:02:25 <Tekmo> ReinH: Hi!
18:02:26 <jle`> preludes :|
18:02:29 <ChongLi> oooh
18:02:34 <Tekmo> ReinH: I don't mind at all
18:02:37 <ChongLi> gonna get Tekmo on the haskell cast?!
18:02:53 <ChongLi> please do, if you can :)
18:03:06 <Cale> oh, base is a dependency of fay-base, nevermind me :)
18:03:33 <randomclown> why is it when I put my own module as a dependency for a test-suite, it says "cannot satisify -package-id blahblah-ver-inplace"?
18:03:40 <randomclown> this is cabal btw
18:03:43 <Cale> I suppose the only way is PackageImports?
18:03:47 <jle`> i would only be adding fay-base to my deps but now nothing compiles
18:04:30 <briennetheblue> has anyone been through Conceptual Mathematics recently?  I'm stuck on one of the exercises :(
18:04:40 <jle`> i guess the solution is to just leave the type signature off of main
18:04:43 <Cale> jle`: try  import "fay-base" Prelude
18:05:53 <begriffs> I'm getting a weird behavior from cabal run. It insists on re-linking my binary even when the binary exists in dist/build/my-app/my-app. Anyone know how it decides when to link?
18:06:03 <Cale> jle`: Or wait, isn't your main supposed to have type Fay () anyway?
18:06:48 <jle`> Cale: main is supposed to have Fay ()...but i'm trying to get the source to typecheck under both GHC and Fay
18:06:59 <jle`> that's apparently like...a big selling out of fay
18:07:18 <jle`> but i can only get it to type check if i add fay-base to my cabal file
18:07:30 <Cale> Well, your main probably shouldn't... should it? I don't know a whole lot about Fay.
18:07:55 <jle`> the whole thing is supposed to typecheck like normal
18:08:02 <jle`> i think
18:08:57 <dleedev> Cale: so laziness and polymorphism are why haskell needs boxed values?
18:09:08 <dleedev> when can we use unboxed values, then?
18:09:15 <Tekmo> dleedev: When things are strict and non-polymorphic
18:09:25 <Tekmo> dleedev: Here's an example
18:09:28 <Cale> When we're willing to give both of those up for a little extra performance.
18:09:51 <Tekmo> dleedev: data Point = Point { x :: {-# UNPACK #-} !Double, y :: {-# UNPACK #-} !Double }
18:10:00 <Tekmo> dleedev: That's a `Point` with two strict and unboxed fields
18:10:16 <dleedev> Tekmo: is {-# UNPACK #-} a special construct?
18:10:20 <Tekmo> dleedev: Yes
18:10:26 <Tekmo> dleedev: It's a language pragma from ghc
18:10:32 <dleedev> Tekmo: means unboxed?
18:10:36 <Tekmo> dleedev: Yes
18:10:56 <dleedev> Tekmo: can we put a {-# UNPACK #-} at the way front, in front of Point?
18:10:57 <Tekmo> dleedev: I use this all the time in my code to remove unnecessary laziness or indirection
18:11:00 <Cale> Note that the Point values themselves will still be boxed
18:11:08 <Tekmo> dleedev: Yes, if it's within another type
18:11:09 <Cale> It's just that the fields inside them will be unboxed
18:11:11 <Tekmo> dleedev: Here's an example
18:11:29 <dleedev> are boxes pointers?
18:11:29 <Tekmo> dleedev: data Atom = Atom { p :: {-# UNPACK #_} !Point, element :: String }
18:11:52 <Tekmo> dleedev: That will similarly unbox `Point` within `Atom`
18:11:56 <Cale> dleedev: In GHC, yeah, they're simple pointers to code
18:12:09 <Tekmo> dleedev: You want to read this: http://www.slideshare.net/tibbe/highperformance-haskell
18:12:18 <dleedev> so conceptually, it's like a struct with embedded values vs struct with pointers?
18:12:34 <Cale> http://www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf <-- or this ;)
18:12:45 <dleedev> and getting rid of the pointer redirection is what gives you the extra performance boost
18:13:29 <Cale> That paper is old, and some of what it describes has changed in GHC, but it's still close enough to give a decent idea.
18:13:50 <Cale> It also discusses some alternate implementations of lazy evaluation
18:14:01 <Cale> To give some other ideas of how boxes might work
18:14:53 <augur_> carter: no twitter huh
18:15:26 <dleedev> does ghc ever do automatic unboxing?
18:15:29 <dleedev> for optimization?
18:15:30 <Cale> yes
18:15:42 <Cale> after strictness analysis determines that things can be strict
18:16:01 <Tekmo> dleedev: See the `-funbox-strict-fields` flag
18:16:06 <Cale> it will often unbox things on its own and they might even just end up in registers
18:16:13 <Cale> This doesn't just happen with data structures
18:16:17 <Cale> but also with variables
18:16:22 <dgpratt> @tell int-e thanks! :)
18:16:22 <lambdabot> Consider it noted.
18:16:28 <jfischof1>  It is pretty conservative without annotations, from what I can tell
18:16:56 <Tekmo> It's also very satisfying to add `UNPACK` annotations.  I don't know why
18:16:57 <dleedev> does -funbox-strict-fields usually result in faster runtime?
18:17:06 <Tekmo> dleedev: Not necessarily
18:17:16 <Cale> I wouldn't turn that flag on normally myself
18:17:29 <Cale> and I wouldn't unbox strict fields by hand unless I saw a need for it
18:17:35 <Cale> It can hurt performance too
18:17:56 <Tekmo> Whenever you mandate that things are strict you tie GHC's hands
18:18:06 <Tekmo> It has much less freedom to optimize
18:18:22 <jfischof1> Tekmo: in terms of deforestation
18:18:32 <jfischof1> but you make unboxing easier
18:18:33 <roboguy_> Tekmo: so you are not of the school that says to make all fields strict?
18:18:38 <jfischof1> its a trade off
18:18:48 <Tekmo> roboguy_: Usually it's obvious which types need strict fields
18:18:56 <Cale> Really, it's something that you start doing after looking at the core normally (or at least I think so)
18:19:09 <Cale> and only when you've decided that performance of that code is a problem
18:19:31 <Tekmo> roboguy_: My rule of thumb is that data structures should be strict, but control structures should be lazy
18:19:47 <Cale> You can do amazing things by passing from working with Int or Word32 values to unboxed arithmetic
18:19:48 <jfischof1> I think the best advice is learn how both strict and lazy evaluation affect the core, but that is something very few have mastered
18:19:52 <Tekmo> roboguy_: However, even that rule of thumb is rough
18:20:06 <Cale> But it's not something you're going to want to do everywhere
18:20:10 <Cale> or casually
18:20:25 <dleedev> so no silver bullet :(
18:20:31 <Cale> There was someone in here a while ago who was writing a hash function
18:20:35 <jfischof1> yeah the old maxim still applies
18:20:37 <dleedev> there's never a silver bullet
18:20:42 <jfischof1> premature optimization ...
18:20:46 <Tekmo> Total/cototal programming might eventually be the silver bullet
18:20:52 <Cale> and it was wasting a lot of time doing about 4 times as much allocation as the input
18:21:02 <ChongLi> cototal? haha
18:21:05 <Tekmo> :)
18:21:13 <ChongLi> coalgebraic?
18:21:20 <Cale> because for each Word32 in the input, he was allocating 4 Word32 values as part of the operation of this hash
18:21:23 <Tekmo> I'm just playing fast and loose with terminology
18:21:45 <briennetheblue> can anyone give me a hint on http://lpaste.net/2059571796369211392 i'm pretty lost
18:22:30 <Cale> and while GHC had removed a lot of the unboxing and reboxing on its own, it was still allocating W32 boxes on every iteration
18:22:41 <cdk> How does Data.Vector grow as elements are added? Does it do something as simple as double storage space every time the available buffer becomes full?
18:22:56 <luite> it doesn't grow
18:23:10 <ChongLi> luite: hey!
18:23:12 <tristan__> google tells me others here have had problems installing postgresql-libpq-0.8.2.6 recently
18:23:16 <tristan__> anyone know whats up?
18:23:23 <Cale> I rewrote the inner loop of the hash to work on unboxed Word32# values, and that turned the whole hash computation into a nonallocating loop working entirely in registers
18:23:24 <dleedev> can unboxed values be non-strict?
18:23:25 <luite> cdk: mutable vectors have a fixed size
18:23:33 <luite> ChongLi: hello :)
18:23:43 <ChongLi> first time I've seen you in quite a while
18:23:50 <ChongLi> saw your talk on ghcjs
18:23:52 <joelteon> how do you convert Word32# to Word32?
18:23:52 <Cale> apparently that was faster than some C implementations he was comparing it to :)
18:23:52 <tristan__> ah nm
18:23:54 <ChongLi> shame about the audio
18:24:06 <joejev> Cale: What is the difference in the two types?
18:24:11 <tristan__> installing it on itsown shows the actual error
18:24:20 <Tekmo> joelteon: `Word32` probably is defined like this:
18:24:20 <Cale> data Word32 = GHC.Word.W32# GHC.Prim.Word#
18:24:24 <Tekmo> ^
18:24:26 <Cale> Ah, Word#
18:24:26 <Cale> right
18:24:28 <luite> ChongLi: i hope to talk in wellington in about a month, perhaps the talk can be better with better audio :)
18:24:41 <joelteon> oh cool
18:24:41 <ChongLi> yeah, hopefully
18:24:48 <Cale> So, W32# is a data constructor which boxes the unboxed Word# value
18:24:58 <ChongLi> just make sure whoever's recording takes the line directly from the microphone
18:25:02 <joelteon> How do you add Word#s?
18:25:14 <Tekmo> There's probably a primop for that
18:25:21 <dleedev> does the # mean something?
18:25:25 <joelteon> unboxed
18:25:32 <Tekmo> dleedev: It means a primitive type or operation
18:25:33 <joelteon> Word# -> Word# -> Word# on hoogle returns nothing useful
18:25:41 <Cale> plusWord# :: Word# -> Word# -> Word#
18:25:47 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html
18:26:02 <enthropy> @let pi# = 3
18:26:02 <lambdabot>  Parse failed: Parse error: =
18:26:02 <joejev> if I make an IOUArray of Int32 will it be represented as Inte2#'s then?
18:26:04 <Cale> It's a pain in the ass to do anything, basically.
18:26:24 <Tekmo> Just like C! :)
18:26:29 <Cale> But I just grabbed the Core that GHC constructed and translated it back into Haskell
18:26:40 <Cale> sans the W32# constructors
18:26:45 <Cale> and the allocation went away
18:26:49 <luite> ChongLi: hopefully everything can be on hackage then as well
18:26:52 <dleedev> so types ending with # are unboxed regardless of the presence of {-# UNPACK #-}
18:26:56 <ChongLi> luite: yes
18:27:04 <ChongLi> and hopefully GHC 7.8 can come out
18:27:07 <Cale> dleedev: yeah, by convention
18:27:23 <Cale> dleedev: also their kind is different
18:27:50 <joelteon> :k Int#
18:27:51 <lambdabot>     Not in scope: type constructor or class `Int#'
18:27:51 <lambdabot>     Perhaps you meant one of these:
18:27:51 <lambdabot>       `Int' (imported from Data.Int), `Int8' (imported from Data.Int)
18:27:52 <joelteon> Int# :: #
18:27:56 <Cale> ghci> :k Word#
18:27:56 <Cale> Word# :: #
18:28:06 <ChongLi> and then we can start working on tools for building and deploying combined Haskell server ghcjs client applications
18:28:15 <ChongLi> all written in one language
18:28:21 <ChongLi> all using a common set of libraries
18:28:39 <Cale> This prevents you from instantiating type variables with unboxed types (which would crash and burn horribly)
18:29:00 <dleedev> ghci> :k Word
18:29:14 <Cale> ghci> :k Word
18:29:15 <Cale> Word :: *
18:29:30 <dleedev> interesting
18:29:32 <ChongLi> I want to use a data structure on the server and on the client with one common library and have automatic serialization, transfer and all taht
18:29:38 <dleedev> is that a ghc-specific thing?
18:29:39 <Cale> :k Maybe
18:29:40 <lambdabot> * -> *
18:29:48 <Cale> Well, the # kind is
18:29:49 <ChongLi> is that too ambitious a goal?
18:29:54 <Cale> Other kinds are not GHC-specific
18:30:12 <Cale> In Haskell 98, the only kinds are * and k1 -> k2 where k1 and k2 are kinds.
18:31:46 <begriffs> Any cabal experts care to look at this issue? https://github.com/begriffs/heroku-buildpack-ghc/issues/12
18:35:09 <Cale> ChongLi: I think that's a perfectly reasonable goal
18:37:19 <ChongLi> Cale: it's always been a straightforward thing to do when both client and server are just native applications in Haskell
18:37:49 <ChongLi> it's just crazy to me that we put up with not being able to do this in the browser
18:38:03 <ChongLi> and end up stuck with things like JSON
18:39:17 <uberjar> hey could one of yall write me a much faster scrypt in Haskell ?  I put an ad up on rentacoder but nobody has taken the job yet.  It needs to be like 20% faster than whats out there.  kthnx
18:40:15 <verement> faster than what?
18:40:30 <ChongLi> verement: I think it's a troll
18:40:47 <uberjar> any exististing scrypt implementation on the NVIDIA chipset
18:41:13 <Cale> uberjar: Why do you think it's possible to compute it any faster?
18:41:54 <uberjar> I strongly suspect that there are private groups of bitcoin miners who have a custom implementation that's 20% faster than what's in the public domain
18:42:07 <uberjar> amazon ec2 bid pricing over a long period of time is one data-point
18:42:59 <ReinH> byorgey:
18:43:04 <ReinH> woops
18:44:52 <briennetheblue> maths is hard :(
18:45:27 <ChongLi> briennetheblue: just keep working at it :)
18:45:42 <uberjar> http://da-data.blogspot.com/2013/12/briefly-profitable-alt-coin-mining-on.html
18:45:53 <briennetheblue> i'll try :p
18:45:56 <ReinH> byorgey: Idea: a library for automatically converting equations (e.g., "fmap id = id", "fmap f . fmap g = fmap (f . g)") into commutativity diagrams using diagrams and some layout rules.
18:46:16 <dgpratt> so there are a lot of Haskell tools around these days of various sorts...
18:47:00 <dgpratt> ...but I am not aware of any that can do (what I imagine to be) a very useful and simple thing: interactively 'evaluate' a Haskell expression
18:47:14 <roboguy_> ReinH: that'd be cool
18:47:16 <dgpratt> I should say "relatively simple"
18:47:40 <dgpratt> have I overlooked something?
18:47:43 <ReinH> roboguy_: especially now that diagrams 1.0 has arrows (of the "pointy line" variety)
18:48:01 <ReinH> dgpratt: as in take an expression on the command line?
18:48:09 <briennetheblue> it always feels like when i'm working through a textbook that there's a huge wall between 'i can do this, this is easy' then suddenly 'i have no idea how to solve this question'
18:48:24 <dgpratt> no, sorry, that's not what I mean, ReinH
18:48:44 <roboguy_> ReinH: I'm a little surprised it didn't have those sooner, especially with the whole Haskell-category theory connection
18:48:51 <ChongLi> > foldr (+) 0 [1..10] :: Expr
18:48:52 <lambdabot>  1 + (2 + (3 + (4 + (5 + (6 + (7 + (8 + (9 + (10 + 0)))))))))
18:48:57 <ChongLi> dgpratt: that sort of thing?
18:49:10 <ReinH> roboguy_: yeah.
18:49:12 <Cale> briennetheblue: What are you working on?
18:49:30 <dgpratt> more or less, ChongLi, but something that would allow it to proceed one step at a time
18:49:36 <ReinH> ChongLi: simple reflect is amazing :)
18:49:47 <briennetheblue> Cale: this question from conceptual mathematics http://lpaste.net/2059571796369211392
18:50:01 <uberjar>  /j #racket
18:50:03 <uberjar> err
18:50:04 <ChongLi> dgpratt: hmmm
18:50:51 <ReinH> briennetheblue: Ok, maps, categories, directed... and I've gone all crosseyed
18:50:56 <Cale> briennetheblue: Nice problem :)
18:51:59 <Cale> Start by just writing out the product diagram for each of X = A and X = D and seeing what this implies about pi_1 and pi_2
18:52:01 <briennetheblue> i think it shouldn't be that difficult but i've spent the whole day thinking about it :(
18:53:14 <Cale> Let's look at D first
18:54:04 <Cale> Maps D -> X are essentially the same thing as vertices of X
18:54:21 <briennetheblue> yeah, the dots in X
18:54:35 <ReinH> briennetheblue: basically Cale is a mathemagician.
18:55:29 <Cale> So, for every pair of maps p: D -> B_1 and q: D -> B_2, which we can think of as vertices of B_1 and B_2 respectively, there is a unique map <p,q> : D -> P (i.e. a unique vertex in P) such that pi_1 . <p,q> = p and pi_2 . <p,q> = q
18:56:23 <Cale> and of course, maps A -> X are synonymous with arcs or arrows in X
18:57:13 <briennetheblue> Cale: i don't understand how to show that though
18:57:25 <Cale> this here? This is part of our assumption.
18:57:56 <Cale> I'm unpacking the fact that P is supposed to satisfy the definition of a product when X = D.
18:58:11 <briennetheblue> Cale: how about something simpler like sets but with 1 instead of A and D
18:58:26 <briennetheblue> Cale: i know that's true too but I don't know how to prove it
18:58:29 <ReinH> Cale: aaaand ##categorytheory :)
18:58:45 <Cale> Yeah, we should probably move this discussion to ##categorytheory :)
18:59:09 <Cale> (though things are pretty quiet right now)
18:59:21 <shachaf> briennetheblue: Well, in Set, a function : 1 -> A is the same thing as an element of A.
18:59:56 <briennetheblue> yeah that's why I know that it's true
19:00:30 <briennetheblue> i was trying to look for a proof that would help me with the graph case
19:00:49 <ReinH> Cale: sure, but then other catsters would be able to listen :)
19:01:10 <Cale> ReinH: I don't know if there are any people in there who aren't also in here
19:01:14 <jmcarthur> i think #haskell is a fine place for category theory when there is nothing else going on
19:01:22 <ReinH> Cale: haha I think there might be a few?
19:01:29 <ReinH> jmcarthur: sure, not trying to kick Cale out or anything
19:01:40 <jmcarthur> i, for one, am not in ##categorytheory. i tend to take it in small doses. the amount the happens here is about right for me.
19:01:44 <ReinH> Cale: but, you know, get out. ;)
19:01:48 <Cale> haha
19:01:53 <briennetheblue> i appreciate the help guys, this is really confusing for me :s
19:02:14 <ReinH> briennetheblue: if it makes you feel any better, I don't even know what all of those words mean when put together.
19:02:28 <Cale> briennetheblue: Okay, so let's look at the case of sets and functions, named similarly to your graphs
19:02:39 <Cale> (after all, sets are just graphs without the arcs ;)
19:04:21 <briennetheblue> right, i got my pen and paper ready!
19:04:25 <Cale> So, suppose we pick some arbitrary set X and maps f: X -> B_1 and g: X -> B_2. We want to show there's a unique map X -> P making the diagram commute. In order to define that function, we only need to specify what it does to each element x of X
19:05:15 <Cale> Identify x with the appropriate function 1 -> X
19:05:34 <Cale> By composition with f and g, we obtain elements of B_1 and B_2 respectively
19:05:44 <roboguy_> huh, I didn't even know ##categorytheory existed until now
19:05:59 <Cale> i.e. f . x : 1 -> B_1, and g . x : 1 -> B_2
19:06:45 <briennetheblue> so the appropriate theorem here is that if for all x:1 -> X: f x = g x then f = g?
19:06:49 <Cale> But then, by our assumption, there is a unique map <f . x, g . x> : 1 -> P
19:07:17 <Cale> such that pi_1 . <f . x, g . x> = f . x and pi_2 . <f . x, g . x> = g . x
19:07:24 <Cale> briennetheblue: yes
19:08:26 <briennetheblue> ok i follow
19:08:38 <Cale> and that means there's a unique element p in P such that pi_1(p) = f(x), and pi_2(p) = g(x), and that's what <f,g>(x) ought to be.
19:09:50 <Cale> (it *has* to be that, if the product diagram is going to commute, and the uniqueness comes from the fact that the definition of the product held for X = 1)
19:12:04 <Cale> So yeah, for your directed irreflexive multigraphs, we'll have to pick apart the definition of a mapping between them, but given that it consists of some mapping between the vertex sets together with a mapping on the sets of arcs, then determining what the map does on both vertices and arcs should be enough to determine it uniquely
19:12:04 <briennetheblue> ack
19:12:32 <briennetheblue> sorry i'm having difficulty understanding where the morphism X -> P comes from
19:13:10 <Cale> Well, we can define a function A -> B in general by saying for each a in A, which point b in B the function sends a to.
19:14:08 <Cale> Typically, when A and B are sets, then a function f: A -> B is defined as a triple (A,B,G) where G is a set of pairs (a,b) with a in A and b in B, such that for each a in A, there is exactly one b in B for which (a,b) is in G.
19:14:16 <Cale> When (a,b) is in G, we write f(a) = b
19:14:34 <Cale> A is called the domain of f
19:14:37 <Cale> B is called the codomain of f
19:14:43 <Cale> G is called the graph of f
19:15:15 <dario|> @pl \x -> if x then return True else return False
19:15:15 <lambdabot> flip (flip if' (return True)) (return False)
19:15:23 <dario|> hm..
19:15:39 <ReinH> dario|: uh, isn't that return x?
19:15:43 <Cale> (This is fairly different in nature from the sort of definition of function that you'd get in type theory or lambda calculus)
19:16:41 <Cale> briennetheblue: Is that all familiar?
19:17:07 <briennetheblue> yes i know what a function is
19:17:18 <Cale> briennetheblue: So, in order to specify a function X -> P, it suffices to say for an arbitrary x in X, which p in P we're going to send that to.
19:17:45 <Cale> and I worked out that there's a unique p we *have* to send x to.
19:18:11 <dario|> ReinH: hm, maybe.. but it's more complicated where i'm actually using it
19:18:13 <Cale> So that defines a function.
19:20:02 <briennetheblue> ok i think i'm starting to get it now
19:20:12 <ReinH> dario|: I don't see how it could possibly be more comfortable
19:20:23 <Cale> briennetheblue: It helps if you actually draw the diagrams, but I'm not going to attempt the ascii art here :)
19:20:35 <ReinH> \x -> if x then return True else return False = return x
19:20:53 <shachaf> It's actually return $! x
19:21:00 <ReinH> shachaf: ahhh
19:21:47 <ReinH> up to evaluation of x, they are the same, so I don't see why you can't replace one with the other
19:21:51 <Cale> Fast and loose yadda yadda
19:22:13 <ReinH> Cale: I believe this is a good time to say "in the obvious way".
19:22:22 <ReinH> Cale: I learned that from the catsters ;)
19:22:34 <LamdaFan> w00t
19:22:35 <ReinH> (and if evaluation matters, use the $! version)
19:22:39 <ReinH> LamdaFan: hi :)
19:40:27 <briennetheblue> Cale: ok i'm still finding this hard to understand but for a given X, f_1:X->B_1, f_2:X->B_2 for each point of X (AKA each x:1->X) there's a unique g:1->P such that f_1.x = p_1.g and f_2.x = p_2.g
19:40:34 <briennetheblue> ?
19:41:24 <mm_freak_> wow, that could really use some extra space
19:41:52 <Cale> briennetheblue: yes
19:42:47 <Cale> briennetheblue: and so the point in P that g picks out will be where we want our function X -> P to send the point x
19:43:48 * hackagebot http2 0.1.2 - HTTP/2.0 library including HPACK  http://hackage.haskell.org/package/http2-0.1.2 (KazuYamamoto)
19:55:46 <bobajett> how can I write this function: foo ["apple","orange","pear"] -> ["1 apple", "2 orange", "3 pear"]? :-) my initial guess was something like zipWith (++) [1..] ["apple","orange","pear"] but I don't know how to do the int to string within a zipwith?
19:56:28 <startling> > zipWith (++) (map show [1..]) ["apple", "orange"]
19:56:30 <lambdabot>  ["1apple","2orange"]
19:56:53 <bobajett> startling: thanks!
19:56:54 <ReinH> zipWith (\x s - >show x ++ " " ++ s)
19:57:18 <startling> > zipWith (printf "%d %s") [1..] ["apple", "orange"]
19:57:19 <lambdabot>  No instance for (Text.Printf.PrintfType c0)
19:57:20 <lambdabot>    arising from a use of `e_11'
19:57:20 <lambdabot>  The type variable `c0' is ambiguous
19:57:20 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
19:57:20 <lambdabot>  Note: there are several potential instances:
19:57:33 <ReinH> startling: printf scares me
19:57:41 <startling> > zipWith (printf "%d %s" :: Int -> String -> String) [1..] ["apple", "orange"]
19:57:42 <lambdabot>  ["1 apple","2 orange"]
19:57:52 <startling> ReinH: it's pretty handy when you're doing string formatting.
19:57:55 <startling> it is kinda gross though.
19:57:58 <ReinH> startling: yes but that typeclass o_O
19:58:10 <bobajett> awesome! thanks guys!
19:58:13 <startling> the typeclass is just for varargs.
19:58:19 <ReinH> n-ary functions are an evil hack
19:58:22 <startling> the real gross thing is type-safety.
19:58:23 <ReinH> startling: yes :p
19:58:29 <startling> > printf "%d" "oops" :: String
19:58:30 <lambdabot>  "*Exception: Printf.printf: bad argument
19:58:40 <ReinH> startling: like I was saying...
19:58:45 <startling> heh
20:00:02 <startling> A printf that just uses show would be nice, alas.
20:00:25 <ReinH> but that wouldn't be printf :p
20:00:40 <startling> and (printf "%s" :: String) = "%s" is reasonable I think
20:03:24 <briennetheblue> Cale: ok i'm guessing that i use the f x = g x => f = g theorem to show that f_1.x=pi_1.g.x => f=pi_1.g (g:X->P)
20:03:32 <ion> startling: That doesn’t use show.
20:03:43 <startling> ion, I know printf doesn't.
20:03:57 <startling> I'm talking about some hypothetical alternative printf
20:04:21 <Cale> briennetheblue: yes, that's essentially it
20:04:29 <ion> I mean, (printf "%s" :: String) = "\"%s\"" would use show.
20:04:56 <ReinH> yes let's please argue about the semantics of printf
20:05:02 <ReinH> which is an abomination that should not be
20:05:04 <ReinH> :p
20:06:48 <startling> ion, oh.
20:06:49 <ion> This is pretty nice. http://hackage.haskell.org/package/th-printf-0.2.0.1/docs/Text-Printf-TH.html
20:07:07 <startling> > printf "%d %s" 1 :: String
20:07:08 <lambdabot>  "1 *Exception: Printf.printf: argument list ended prematurely
20:07:16 <startling> ion: ^ I mean as an alternative to that error
20:07:36 <startling> just outputting the format sequence instead is sane I think
20:08:13 <derekv> thinking about creating a detroit area haskell newbies meetup
20:08:22 <startling> ion: yeah, that does look nice. thanks!
20:08:22 <ion> λ> [s|shown: %?|] (Just 42)
20:08:24 <ion> "shown: Just 42"
20:09:09 <codygman> How can I use an unnamed command line argument with GetOpt?
20:09:38 <ReinH> ion: whaaaaat?
20:09:50 <ReinH> ion: that is cool.
20:10:24 <ReinH> :t getOpt
20:10:25 <lambdabot> Not in scope: `getOpt'
20:10:28 <ReinH> :(
20:10:47 <ReinH> getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
20:11:09 <ReinH> codygman: from the docs: getOpt returns a tuple of option arguments, *a list of non-options* and a list of error messages.
20:13:50 <ion> λ> [s|%20s: %-20?|] "shown" (Just 42)
20:13:51 <codygman> ReinH: Alright, I think I can figure it out from there.
20:13:52 <ion> "               shown: Just 42             "
20:14:48 <ReinH> codygman: seems good :)
20:14:55 <briennetheblue> Cale: thanks for the help :)  i'll sleep on it and see if i can write up a coherent solution tomorrow...
20:15:19 <Cale> briennetheblue: no problem :)
20:17:05 <joelteon> ion: is the left-justifying what %-s does?
20:18:36 <ReinH> ion: a TH solution makes a lot more sense than printf typeclass insanity
20:19:41 <enthropy> @hackage xformat
20:19:41 <lambdabot> http://hackage.haskell.org/package/xformat
20:20:24 <enthropy> http://hackage.haskell.org/package/formatting
20:26:48 <ReinH> enthropy: wait which one should I use
20:27:18 <enthropy> I've only used xformat
20:27:21 <ReinH> oh formatting is chrisdone ok
20:27:29 <enthropy> the other one looks ok too
20:28:05 <enthropy> there's also a printf-mauke that has some TH
20:28:32 <ReinH> hmm
20:28:33 <enthropy> if you like to use libraries by people you've talked to
20:28:40 <ReinH> heh
20:28:47 <ReinH> well I can just yell at Chris if I need to :p
20:28:58 <ion> joelteon: yes
20:29:05 <joelteon> that makes sense
20:29:12 <joelteon> for a second I thought there was a bug in it I'd never noticed
20:29:19 <derekv> I'm thinking, should I call it "Haskell Newbies Meetup" or "Haskell Learners Club" ...
20:29:32 <derekv> or "Haskel vs Lisp Deathmatch Fight!"
20:29:45 <ReinH> derekv: heh what's this
20:29:52 <ReinH> (++ "?")
20:30:30 <derekv> ReinH: Considering starting a meetup for detroit area
20:30:49 <derekv> Learn-by-teaching
20:33:32 <ReinH> derekv: awesome :)
20:34:52 <derekv> It might be the beer, but I'm strongly leaning towards the last one at the moment
20:34:59 <lightquake> so if you dynamically link a binary, where does it look for the libraries?
20:35:05 <derekv> I may or may not fix the typo
20:36:04 <lightquake> ptracing it makes it look like it checks some places in ~/.cabal, then /usr/lib/ghc
20:38:22 <prooftechnique> derekv: Lisp will win the fight to the death unless you allow unsafePerformIO
20:38:50 <Ralith> unsafePerformIO . shoot . foot $ self
20:39:11 <shackleford> Does anyone know roughly how long it takes to build ghc and the haskell platform from source? I'm going to have a lot of down time at work tomorrow and I kind of want to. You know, just because.
20:39:13 <prooftechnique> Newest post on Reddit: C implemented in one line of Haskell
20:39:55 <prooftechnique> shackleford: What are the specs on your machine?
20:40:05 <prooftechnique> And do you already have a ghc installed?
20:40:31 <derekv> not sure C requires newlines for anything so, technically...
20:40:47 <enthropy> it goes much faster if you don't want profiling libaries or to have the compiler optimized
20:40:59 <shackleford> 8gb RAM, Intel i7 2.7 GHz, running Ubuntu 13.04.
20:41:09 <roboguy_> derekv: the preprocessor definitely does. maybe not other than that, though
20:41:59 <prooftechnique> shackleford: I think default build is something like 30-45 for me, but that's HEAD and I haven't actually done it lately, so that's probably a lie.
20:42:01 <chirpsalot> roboguy_: beat me to it :P.
20:42:52 <shackleford> prooftechnique: Sounds good enough to me. Thanks!
20:42:53 <roboguy_> shackleford: remember to do -jN if you have multiple cores
20:43:06 <roboguy_> (where N is the number of processes you want)
20:43:32 <prooftechnique> roboguy_: Can't you do -j without a number and it'll just figure it out?
20:43:34 <chirpsalot> roboguy_: I mean, if you want C99 has // comments which kind of require newlines?
20:44:16 <roboguy_> prooftechnique: huh, maybe. I didn't know that
20:44:42 <prooftechnique> roboguy_: It might just be when using ghc or cabal. The actual build process might not do that
20:44:44 <prooftechnique> I dunno
20:44:52 <roboguy_> cabal-install doesn't have a man page, so that makes it a little hard for me to figure out some of the options
20:45:11 <derekv> prooftechnique: anyways I wasn't being litteral, just thinking of creating a meetup with a sort of hands-on learning/teaching focus on haskell.  But in addition to being a haskell NOOOB i'm a newb in many other things as well (eg, Lisp), so maybe it needn't be strictly constrained to one language.
20:45:38 <prooftechnique> derekv: We have a similar thing where I live, but it seems to mostly be Scala
20:45:50 <prooftechnique> I've been meaning to do a talk about lens and pipes or something, but effort
20:46:03 <derekv> prooftechnique: right... effort
20:46:19 <derekv> its easy to creat the meetup, tweet about it etc
20:46:29 <derekv> then hard to actually get all the crap going
20:46:34 <derekv> same with giving a talk
20:46:48 <roboguy_> looks like llvm doesn't build on ghc HEAD because it depends on type-level which doesn't compile on ghc HEAD. that's a shame
20:54:12 <dleedev> hi, what's the difference between Int# and {-# UNPACK #-} !Int
20:54:18 <markovirc> Hello dleedev
20:54:30 <hattmammerly> given [a] I want to supply a predicate and get ([a], [a]) with fst being true elements and snd being false - is foldl the way to approach this?
20:54:31 <dleedev> markovirc: hi
20:55:38 <testeree> how would i create a vector of (second column -ByteString ) indexed by (first column - Int) where column data is from a file?
20:55:41 <lightquake> @hoogle (a -> Bool) -> [a] -> ([a], [a])
20:55:42 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
20:55:42 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
20:55:42 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
20:55:54 <lightquake> oh huh, weird
20:56:01 <lightquake> hattmammerly: look at partition in Data.List
20:56:32 <hattmammerly> lightquake: gaaaah I use that elsewhere in this program too >.>
20:56:35 <hattmammerly> thank you ahaha
20:57:24 <shackleford> A bit of an off-beat prompt here, but do you ever kind of... brag, for lack of a better word, about using haskell?
20:57:44 <lightquake> testeree: what do you mean?
20:58:03 <hattmammerly> shackleford: yes, despite being awful at it
20:58:31 <hattmammerly> i jumped into the ocean because it was there. but I'm learning! and I'm excited about it
20:59:01 <shackleford> testeree: Might have something to do with me being youngish, but the programmers I know are all imperative/OOP guys, and always complain about bugs I don't come across when I use Haskell.
20:59:13 <testeree> i mean. do i need a mutable vector to fill in a vector at index read from file with data from  the same file
20:59:35 <shackleford> testeree: And I make it abundantly clear that I don't get those. Despite not really knowing the language
21:09:40 <Platz> shackleford: what kind of bugs?
21:11:43 <Platz> caching bugs tend to drive me the most nuts
21:14:28 <Twey> Along with naming things and off-by-one errors?
21:16:07 <pavonia> Caching bugs for efficient later use?
21:16:23 <Platz> Twey: yes, those are more horrid.  w/ co-workers is a lost cause
21:16:38 <dwcook> I think part of it has to do with the level of abstraction – If you're not manually indexing arrays yourself all the time, you're less likely to get off-by-one errors.
21:16:41 <Platz> co-workers [naming] is
21:17:59 <dwcook> Even when I'm using JavaScript, I seldom get off-by-one errors because I use the Array iteration methods (map, filter, occasionally forEach)
21:18:06 <mm_freak_> testeree: lots of data?
21:18:27 <mahefa> anybody?
21:18:48 <dwcook> mahefa, I didn't see you say anything.
21:19:01 <dwcook> I doubt anyone else did.
21:19:13 <dwcook> (I used my client's scrollback search)
21:19:16 <Platz> every time I try to implement an algorithm, off-by-one
21:19:51 <Platz> where its not as easy as "do everything to this list"
21:20:14 <testeree> mm_freak_. yup
21:20:32 <mm_freak_> testeree: are you applying an algorithm that actually requires all of this data in memory at once?
21:22:09 <testeree> actually it is a gui program using gtk , i want some things to be looked up from the file data.
21:22:13 <dwcook> mahefa, oh, did you mean something like "Is anyone here?"? I thought you meant "Can anyone answer my question?".
21:22:39 <testeree> when i click aa button / on some other signal.
21:22:53 <mahefa> yes, that's what I meant. Sorry for the confusion. First time in here
21:23:58 <dwcook> mahefa, no worries. If you did have a question, feel free to ask.
21:28:07 <jle`> has anyone ever used fay with ghc-mod?
21:29:01 <jle`> also, is there a way to specify hackage/cabal dependencies while not putting them on any build-depends?
21:36:54 <carter> augur_: i'm distractable
21:37:00 <chirpsalot> Am I just stupid, because I have never had a good experience with cabal :(. Somehow I always seem to get into some dependency hell.
21:37:05 * carter augur_: didn't wanna get into a pattern matching battle. :)
21:37:15 <mm_freak_> testeree: well, there are many approaches to that…  do you want to load the entire file into memory?
21:37:19 <chirpsalot> I feel like I am missing something...
21:37:34 <augur_> carter: which side are you on again?
21:37:58 <carter> augur_: whatever gives the best human friendly tools, which is blend
21:38:07 <augur_> :p
21:38:17 <testeree> mm_freak_, i don't think memory is a bottleneck so yes.
21:38:39 <carter> testeree: whats the cod?
21:38:39 <augur_> carter: well, all i was saying is that we can derive case from elim in general
21:38:43 <carter> yes
21:39:03 <testeree> carter: cod?
21:39:06 <carter> coe
21:39:09 <carter> *code
21:39:16 <carter> when i hear "memory locality"
21:39:26 <carter> i suddley get interseted :)
21:40:28 <testeree> carter, you can refer to my previous messages for what my requirement is.
21:40:36 <carter> which ones?
21:40:38 <carter> i just ocnnected/
21:41:26 <testeree> carter, from [10:24] and [10:27]
21:41:44 <carter> ok
21:41:59 <testeree> carter , how would i create a vector of (second column -ByteString ) indexed by (first column - Int) where column data is from a file?
21:42:28 <carter> you mean (Vector Bytestring)
21:42:37 <testeree> carter, yes
21:42:38 <carter> or you want something like a packed unboxed bytestring array?
21:42:50 <carter> honestly you could do both!
21:43:10 <carter> split a bytestring into the value chunks via a none copying slice
21:43:15 <carter> and put each entry in a boxed vector
21:43:18 <testeree> carter, i mean. if i need a mutable vector to fill in a vector at index read from file with data from  the same file?
21:43:32 <carter> testeree: whats the goal?
21:43:36 <carter> forget how you do it
21:43:38 <carter> what do you want
21:43:53 <carter> whats the actually problem you want ot solve
21:43:56 <carter> leave the abstraction to me
21:43:57 <carter> :)
21:44:22 <testeree> carter, actually it is a gui program using gtk , i want some things to be looked up from the file data, when a signal is received.
21:44:30 <carter> ok
21:44:39 <carter> ok
21:44:48 <carter> what do the bytestrings means
21:44:52 <carter> whatss the file formatS?
21:45:10 <testeree> the file contains the (index\tvalue\n)
21:45:21 <carter> ok
21:45:26 <carter> whats value?
21:45:28 <testeree>  carter, where index is int and value is bytestring
21:45:30 <carter> ok
21:45:32 <carter> no
21:45:48 <carter> so its a TSV file
21:45:52 <carter> with a specific schema1
21:45:54 <carter> !
21:45:56 <carter> right?
21:45:57 <testeree> carter, and index is not sorted
21:46:03 <carter> doesn't amtter
21:46:12 <testeree> yup
21:46:12 <carter> now we're getting somewhere
21:46:29 <carter> ok
21:46:55 <carter> also
21:47:02 <carter> i'm guessing its actually utf8 text
21:47:02 <carter> right?
21:47:06 <carter> or is it actually binary data?
21:47:13 <testeree> i am reading the data using pcre regex matches
21:47:20 <carter> i on't care
21:47:27 <testeree> utf8
21:47:29 <carter> we're focusing on the problem description
21:47:35 <carter> not the solution method you're stuck on :)
21:47:36 <carter> ok
21:47:37 <mm_freak_> testeree: first find a data structure that fits your data, then decide whether you need serialization or parsing
21:47:38 <carter> utf8
21:47:46 <carter> so
21:47:49 <carter> its a TSV file
21:47:52 <carter> first column an int
21:47:56 <carter> second some utf8 string
21:48:00 <testeree> yup
21:48:03 <carter> you then want to sort on the values in the first column
21:48:14 <carter> and get a fast lookup structure at the end
21:48:22 <testeree> yup
21:48:25 <carter> and i'm assuing the ints may not be contiguous
21:48:35 <testeree> yup
21:48:55 <carter> so the end result will be more like a binary search / int map / hashmap like thing
21:49:07 <testeree> int map yes.
21:49:16 <carter> ok
21:49:19 <mm_freak_> in other words:  first find a data structure that fits your data, then decide whether you need serialization or parsing =)
21:49:38 <mm_freak_> int-indexed stuff screams for IntMap
21:49:43 <carter> yup
21:49:45 <carter> he should do that
21:49:46 <jfeltz> OT: are there any books worth reading that touch on pitfalls best-practices in writing declarative DSL(s), or it just basically the same discipline as writing PL compilers? I'd like to for example write a language that describes dimensions for object comparision, E.g: "4 cm vs 3 inches" would evaluate to applicable constructs
21:49:54 <testeree> mm_freak_, i expected vector should do it?
21:50:03 <mm_freak_> testeree: vector of what?
21:50:19 <kristof> jfeltz: Since what you're doing is literally language design, it falls in the same category as PL theory/design.
21:50:24 <testeree> vecor of bytestrings
21:50:30 <carter> testeree: NOT BYTESTRINGS
21:50:34 <carter> and not VECTOR
21:50:38 <carter> you said the ints aren't contiguous
21:50:39 <mm_freak_> testeree: why vector?  why bytestrings?
21:50:47 <carter> :)
21:50:49 <kristof> carter: so a sparse vector, then
21:50:53 <carter> yes
21:50:54 <carter> but
21:50:54 <kristof> Oh, an int map is a sparse vector
21:50:57 <carter> yup
21:51:01 <testeree> yup
21:51:13 <jfeltz> kristof, thanks
21:51:25 <mm_freak_> testeree: it would be really helpful if you could reveal the semantics of the data you need to look up
21:51:25 <carter> testeree: i understand you came to describe it one way
21:51:31 <carter> but think about how confused we were then
21:51:33 <carter> and now we're less confused
21:51:34 <mm_freak_> in other words, don't tell us your solution, tell us your problem =)
21:51:36 <carter> by describing the problem
21:52:20 <kristof> jfeltz: You know, it's not hard coming up with declarative DSLs ("I want to say THIS THAT THE OTHER THING"); the problem really lies in implementing them, 99% of the time
21:53:16 <carter> sooo much buggy code is from poorly specifying what the problem is :)
21:53:52 <testeree> carter, the vector can have empty bytestrings for indices not found in file
21:54:05 <danil> testeree: is there some reason IntMap Text wouldn't be appropriate?
21:54:06 <carter> why
21:54:14 <carter> yeah, i agree with danil  :)
21:54:22 <jfeltz> kristof: thanks, google calendar has been inspirational to me, I really like the fact that I can sort of describe the event using english/text message expressions, and it will pin it to the right date/time, it seems that there are lots of applications for knowing how to do that
21:54:23 <kristof> isn't there a haskell library out there? Where you just plug in a schema or something for some binary type, and poof, easy manipulation functions pop out?
21:54:53 <mm_freak_> empty bytestrings represent absence?  this almost sounds like something you would do in PHP =)
21:54:55 <kristof> jfeltz: Oh, well, Google uses the magic of interpreting human language as well
21:55:10 <Platz> I think it's odd that I've never heard the concept of "cartesian product"/"nested for loops" expressed as "nondeterminism" in other languages, but it's mentioned in every haskell article
21:55:12 <kristof> jfeltz: But I agree that a good DSL is a lovely thing
21:55:17 <Cale> kristof: What do you mean by "some binary type"?
21:55:42 <kristof> Cale: I'm sorry, I meant some binary data format
21:55:45 <dsrx> like a struct?
21:55:56 <testeree> danil , will i get constant time lookup with vector but log(n) with intmaps right.
21:56:08 <Cale> Platz: Well, had you ever heard of nondeterministic Turing machines?
21:56:23 <Cale> (Or other finite automata?)
21:56:32 <mm_freak_> testeree: IntMap lookup is O(1)
21:56:47 <carter> yup
21:56:50 <Platz> I suppose NFA's they are mentioned a lot, yes
21:56:50 <mm_freak_> and it's a brilliant proof why big-O notation often tells you nothing about the algorithm's running time =)
21:56:55 <prooftechnique> Sparse vectors ftw
21:56:58 <carter> yup
21:57:25 <Cale> Platz: It's exactly that sort of nondeterminism :)
21:57:45 <kristof> I don't think people actually use Haskell for really, really intense array computation, though
21:57:47 <testeree> mm_freak_, sorry i meant insert.
21:57:51 <kristof> ...unless you wrap everything in ST
21:58:12 <prooftechnique> Well, once carter's done, that may not be the case, kristof :D
21:58:24 <carter> yes
21:58:25 <Platz> nested loops are common in things like dynamic programming though
21:58:43 <kristof> carter: Care sharing some of the implmentation details of whatever you're working on?
21:59:08 <carter> kristof: whats your background wrt modern numerical computing tools / libs?
21:59:14 <mm_freak_> testeree: O(1)
21:59:16 <carter> heres a fun fact:
21:59:25 <carter> the "obvious way" to write matrix mult in C,
21:59:26 <kristof> carter: diddly squat but hit me with all you've got
21:59:37 <carter> is 1000x slower than the "right/fast" way to write it
22:00:01 <carter> over every possible input size range i hve the patience to compare them on
22:00:07 <kazagistar> the obvious way to write a matrix in any language is to use the old fortran libraries or whatever
22:00:12 <kristof> carter: Well the right/fast way is to use a parallel reduce because matrices are monoids :P
22:00:13 <Cale> testeree: It's O(1) assuming that the size of Int doesn't change.
22:00:15 <carter> nope
22:00:21 <carter> kazagistar: nope
22:00:31 <carter> the old fortran libs had to get updated for modern hardware
22:00:39 <carter> the the most modenr lib isn't in fortran
22:00:51 <kristof> nobody mention APL
22:00:53 <kazagistar> carter: fair enough, you are indeed right
22:00:54 <carter> yup
22:00:56 <prooftechnique> Trying to use those fortran libs was a nightmare
22:01:09 <kristof> I have a friend who was an old Cobol programmer
22:01:15 <Cale> But of course, putting upper bounds on things ahead of time makes asymptotic analysis pretty trivial.
22:01:20 <kristof> She actually liked her job. Go figure!
22:01:32 <carter> debugging is a great sort of puzzle soving
22:01:43 <carter> the reason why "fortran is fast"
22:01:51 <carter> is because people keep on whacking on that code
22:01:59 <kristof> Sounds horrifying
22:02:01 <testeree> mm_freak_, why is there vector if IntMap should do it?
22:02:10 <carter> they're different data structures
22:02:53 <carter> so yeah
22:02:55 <carter> as i was saying
22:03:04 <carter> the reason for the 1000x slower C
22:03:05 <Cale> IntMap is a mapping from Int keys to values of some arbitrary type. Vectors are contiguous sequences of values of some type.
22:03:08 <carter> is memory lcoality is a thing
22:03:27 <kristof> There's a good Erik Naggum quote about C only *feeling* fast, in the same way that launching yourself from a catapult in a bathtub feels fast, while flying an airplane doesn't.
22:03:33 <carter> nah
22:03:46 <carter> C is fast if your hardware is like a overclocked pdp11
22:03:49 <carter> with no SIMD
22:03:55 <testeree> Cale, i have continuous sets of value but possible discontinues should have empty bytestring
22:03:58 <kristof> do they still make pdps?
22:03:59 <carter> not l1 ll2 l3 aches
22:04:04 <carter> nope
22:04:08 <carter> but i'm being pedantic
22:04:16 <kristof> carter: So it's cache-misses that kill C code
22:04:21 <prooftechnique> testeree: Stop saying bytestring
22:04:21 <carter> no
22:04:22 <codygman> Hey guys, I wrote correct code for lvl 1 of stripes ctf, but it's apparently not fast enough: http://lpaste.net/99064 What am I doing wrong? I tried using Data.HashSet but that made it slower. Am I looking for Data.HashSet.Hashmap perhaps?
22:04:26 <prooftechnique> You don't want bytestrings
22:04:28 <carter> its the lack of cache USE :)
22:04:33 <kristof> carter: Oh I see.
22:04:44 <carter> lets switch to #numerical-haskell
22:04:52 <carter> don't wanna spam the learning convos going on in parallel
22:05:07 <carter> ping when switched an ready :)
22:05:21 <testeree> prooftechnique, what do i want then?
22:05:24 <Cale> codygman: Not too surprising given that your keys are strings
22:05:39 <prooftechnique> testeree: Judging by your description of the file, Text
22:06:18 <Cale> codygman: Computing a hash function for each string to check is often going to be slower than comparing the first character of it against a few values in a Set
22:06:43 <Cale> (likely only the first character or two until you've found the element)
22:07:33 <Cale> However, you might want to try using Text instead of String
22:08:25 <codygman> Cale: I'm not sure what you are recommending. Are you saying I shouldn't use a Set at all, and should instead compare the Strings (or Text)?
22:08:35 <prooftechnique> testeree: Unless you're working with binary data, you want Text, basically
22:08:41 <Cale> No, I'm explaining why Set does better than HashSet
22:08:58 <Cale> and then saying that maybe replacing String with Text might be a better thing to try
22:09:30 <testeree> carter, i chose vector because my index starts at zero and continuous (inserted with empty text for index not in file) until the last index.
22:09:39 <carter> no
22:09:43 <carter> bad design
22:09:48 <carter> :)
22:11:13 <Cale> Despite what some references will tell you, computing hashes isn't free. It's not even cheap a lot of the time, (and that's especially true when the thing you're hashing is a linked list of 32 bit unicode characters)
22:11:29 <testeree>  carter, and sometimes i do lookup from a splice of the vector too
22:11:48 <carter> you should talk wiht Cale  and prooftechnique , i'm a terrible teacher :)
22:14:05 * hackagebot x509-validation 1.5.0 - X.509 Certificate and CRL validation  http://hackage.haskell.org/package/x509-validation-1.5.0 (VincentHanquez)
22:14:07 * hackagebot x509-util 1.5.0 - Utility for X509 certificate and chain  http://hackage.haskell.org/package/x509-util-1.5.0 (VincentHanquez)
22:25:03 <testeree> is it efficient to read data from a (range of indices) with intmap?
22:28:33 <ChongLi> testeree: how efficient do you need it to be?
22:29:52 <ChongLi> you could do a couple splits
22:30:12 <jmcarthur> testeree: asymptotically you can do it quite efficiently, but that may not be the answer you are looking for
22:30:27 <jmcarthur> right, but splitting out the range you want and then folding or whatever
22:30:32 <jmcarthur> s/but/by/
22:31:19 <roboguy_> testeree: what are you doing with the data when you read it?
22:31:20 <jmcarthur> IntMap is really, really efficient, for a purely functional map
22:31:21 <testeree> ChongLi, say from a intmap with 10000 i would like to lookup about a range of 100 values from it?
22:31:35 <jmcarthur> testeree: how fast do you need that to be?
22:31:54 <testeree> jmcarthur, it should come up on a click of a button :P
22:32:05 <jmcarthur> oh you're fine even with a linked list
22:32:12 <jmcarthur> intmap is plenty for that
22:32:21 <ChongLi> yeah
22:32:27 <rola> @pl \h -> h `mod` 5 < 1
22:32:27 <lambdabot> (< 1) . (`mod` 5)
22:32:47 <ChongLi> switching to a vector for constant time slicing would be overkill
22:32:47 <testeree> so vector are reserved for really low level computations?
22:33:03 <jmcarthur> testeree: you are greatly overoptimizing
22:33:15 <jmcarthur> testeree: i wouldn't call vector for low level stuff. just not what you are doing
22:33:23 <testeree> ok
22:33:41 <prooftechnique> testeree: Don't worry about how the data structure performs. Worry about how it represents your problem.
22:33:43 <ChongLi> it all depends on how you are using it
22:33:56 <roboguy_> it says IntMap lookup is O(min(n, W)) where W is the word size. that sounds pretty fast to me
22:33:57 <jmcarthur> the best reason to use any particular type is for its interface. the second best reason is for its efficiency.
22:33:58 <prooftechnique> IntMap exactly describes your data
22:34:02 <ChongLi> are you doing a lot of insertions and deletions in a very sparse IntMap?
22:34:18 <ChongLi> because Vector is very bad at that
22:34:45 <jmcarthur> (actually IntMap does better for dense keys than sparse keys, too, although it degrades much better)
22:35:09 <testeree> ChongLi,  it is not really sparse at all (very rarely some indeces won't be there).
22:35:20 <prooftechnique> ChongLi: The data is a TSV of the form "(number)\t(sometext)\n"
22:35:20 <testeree> ok
22:35:47 <ChongLi> but are you inserting and deleting a lot?
22:36:05 <ChongLi> or just making one big structure and then mapping, folding, filtering etc. over it?
22:36:07 <testeree> ChongLi,  only intial read
22:36:51 <testeree> ChongLi, only reading  no editing
22:37:13 <codygman> Cale: using Data.Text has it passing :) Though, I'll have to post my git commit making the changes as I'm sure I made some mistakes which you guys could turn into learning opportunities ;)
22:37:14 <ChongLi> and then viewing ranges of the data?
22:37:23 <ChongLi> like a ascrolling window?
22:37:38 <testeree> ChongLi, yes you could say that.
22:37:56 <ChongLi> then Vector may be fine for you
22:38:01 <intrados> Is it correct that typeclass instances are resolved from the context of function application rather than the context of function definition? Is there any way to do this: http://lpaste.net/99067
22:38:19 <ChongLi> is the TSV in sorted order?
22:38:42 <Cale> intrados: Why are you trying to write two instances of Foo for Int?
22:38:59 <ChongLi> intrados: type classes are global and canonical
22:39:03 <jmcarthur> Cale: i think he is hoping they will be scoped
22:39:15 <prooftechnique> intrados: Orphan instances are a Bad Thing™
22:39:18 <Cale> intrados: If you ever have to write two instances of a type class for the same type, then type classes are not the solution you're looking for.
22:39:19 <testeree> ChongLi, reading an unsorted TSV into a sorted vector was my original question. ( or so i thought until i got suggested to use intmaps instead)
22:39:21 <ChongLi> if you want a different instance, wrap your type in a newtype
22:39:28 <jmcarthur> intrados: instances are global
22:39:51 <Cale> intrados: Or, if you end up in that situation but only rarely, then newtype
22:40:13 <testeree> Chongli, not sorted Vector but inserted into proper index
22:40:42 <ChongLi> testeree: so the numbers are nominal, not ordinal?
22:40:52 <prooftechnique> testeree: You don't have to sort an IntMap
22:41:42 <ChongLi> like student IDs or telephone numbers?
22:42:22 <intrados> Cale: Well, I'm interacting with multiple APIs (each API in its own module) and dispatching on type within each module. How ought I to do that?
22:42:58 <testeree> ChongLi, Student IDs . but it starts with [0..n] but not in order in file
22:43:20 <Cale> intrados: Can you perhaps be more specific?
22:43:21 <intrados> Cale: A way that works but feels pretty silly is to define the class locally within each module and add repeated constraints in the common module like `(Foo.Class a, Bar.Class a) =>`
22:43:24 <ChongLi> testeree: yeah, so student IDs should not really be treated as ordinal or cardinal numbers
22:43:28 <ChongLi> they are nominal
22:43:52 <roboguy_> you should probably not be indexing a vector with student IDs
22:44:10 <Cale> intrados: It's really hard for me to suggest something without knowing more about what problem you're trying to solve
22:44:23 <Cale> intrados: But very likely the solution is not to use type classes at all
22:44:57 <testeree> roboguy_, it is just an integer not a (student id)
22:45:32 <roboguy_> testeree: what does the integer represent?
22:45:58 <ChongLi> as a student ID, the integer is naming something
22:46:15 <ChongLi> this means it's not appropriate to do math with it or something like that
22:46:24 <testeree> ChongLi, yes
22:46:25 <ChongLi> it should be treated as a unique data type
22:46:38 <testeree> ok
22:47:07 <Cale> intrados: Could you perhaps paste some/all of your actual code?
22:47:30 <Cale> Or at least explain somehow what your program does?
22:47:43 <intrados> Cale: Yeah. I'm working on an explanation now
22:48:49 <testeree> I wanted to try it with Vectors as an exercise.
22:49:09 * hackagebot plot 0.2.2 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.2.2 (VivianMcPhail)
22:49:10 <CaptainK> why does show 5 work but read "5" not...understanding  read seems to want to infer the type, but how come show does not suffer from the same?
22:49:40 <Twey> Heh, the two methods of problem-solving in Haskell: 1) more type classes; 2) fewer type classes
22:49:44 <testeree> CaptainK, show always returns strings
22:50:05 <dwcook> CaptainK, based on the literal 5, the compiler can choose a sane default lacking any further type information
22:50:22 <dwcook> CaptainK, in the latter case it could be literally any type in Read, and it doesn't have a sane default
22:50:33 <Cale> CaptainK: Because of numeric defaulting applying to the integer literal. The result of Read needn't be an instance of Num, so numeric defaulting doesn't apply
22:50:58 <Cale> The result of read rather
22:51:34 <CaptainK> ok, now that makes sense
22:52:05 <Cale> Numeric defaulting only applies to disambiguate type variables which are ambiguous, constrained by Num, and not constrained by classes other than those in the Prelude..
22:52:06 * dwcook actually wasn't aware that defaulting was numeric-specific
22:52:39 <CaptainK> thought it had something to do with that, LYAH doesn't explain that very well...at least in the beginning...maybe more later on in the book
22:53:13 <Cale> Yeah, it specifically exists because numeric literals are polymorphic and thus inherently ambiguous, which is obnoxious when you're trying to use a repl
22:53:26 <dwcook> CaptainK, often, in practice, the context in which you use show/read will determine a specific type. Although, read isn't very good since it crashes on most user input.
22:53:44 <dwcook> most possible*
22:53:52 <CaptainK> those damn users!
22:53:53 <dwcook> @type readMaybe
22:53:54 <lambdabot> Not in scope: `readMaybe'
22:54:26 <dwcook> @type maybeRead
22:54:26 <lambdabot> Not in scope: `maybeRead'
22:54:34 <dwcook> Hrm
22:54:44 <CaptainK> I see the impportance of mastering type interface of haskell here early on
22:55:11 <danil> CaptainK: note that defaulting is the reason `show 5` works, not the reason `read "5"` doesn't.  If you look at `show 'c'` vs. `read "'c'"` you still have the problem that without any context it tells you it doesn't know what you want read to return
22:55:24 <dwcook> Anyone remember where that function is that has type (Read a) => String -> Maybe a?
22:55:35 <cin> Text.Read.readMaybe
22:55:48 <dwcook> Yeah, that's the one
22:57:21 <CaptainK> is readMaybe in Prelude?
22:57:33 <dwcook> Nope, it's in Text.Read
22:57:44 <Cale> There's reads
22:57:46 <Cale> :t reads
22:57:47 <lambdabot> Read a => ReadS a
22:57:55 <Cale> Stupid type synonym
22:58:03 <CaptainK> lol
22:58:04 <Cale> type ReadS a = String -> [(a, String)]
22:58:23 <Cale> If the list is empty, then it failed to parse
22:59:04 <Cale> Most instances of Read will produce at most one element lists (I believe all the instances in the base library do anyway)
22:59:39 <Cale> The String in the result is the remainder of the input, and you may also want to check that it's empty
23:00:03 <dwcook> readMaybe does those checks for you though, I believe
23:00:17 <dwcook> @src readMaybe
23:00:18 <lambdabot> Source not found. Just what do you think you're doing Dave?
23:00:23 <dwcook> @src Text.Read.readMaybe
23:00:23 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:00:27 <dwcook> Silliness
23:00:51 <dwcook> Was lambdabot compiled with an older version of GHC?
23:00:56 <dwcook> @version
23:00:56 <lambdabot> lambdabot 5.0-int-e
23:00:57 <lambdabot> git clone git://github.com/int-e/lambdabot.git
23:01:12 <Cale> Probably not
23:01:33 <Cale> The @src command just looks the source up in a small text database though
23:01:53 <Cale> which was handcrafted and mostly contains stuff from the Prelude and a few other libraries
23:01:54 <dwcook> Ahh
23:01:59 <intrados> Cale: Does this make any more sense? module Base where
23:01:59 <intrados> data OrderType = Buy | Sell
23:02:00 <intrados> data API = API1 | API2
23:02:00 <intrados> data Order (a :: OrderType) = Order
23:02:02 <intrados>   { price :: Double
23:02:05 <intrados>   , quantity :: Double
23:02:08 <intrados>   , api :: API
23:02:11 <intrados>   }
23:02:15 <intrados> class FromOrder a where
23:02:18 <intrados>   fromOrder :: a -> String
23:02:21 <intrados> module API1 where
23:02:26 <intrados> import Base
23:02:30 <intrados> instance FromOrder (Order Buy) where
23:02:30 <Cale> That data declaration already doesn't make sense to me.
23:02:35 <intrados>   fromOrder (Order p q _) = "Buy" ++ show p ++ show q
23:02:38 <intrados> instance FromOrder (Order Sell) where
23:02:38 <intrados>   fromOrder (Order p q _) = "Sell" ++ show p ++ show q
23:02:41 <intrados> module API2 where
23:02:44 <Cale> Also, you should use lpaste.net
23:02:44 <intrados> import Base
23:02:48 <intrados> instance FromOrder (Order Buy) where
23:02:51 <intrados>   fromOrder (Order p q _) = "Buying" ++ show p ++ show q
23:02:54 <intrados> instance FromOrder (Order Sell) where
23:02:57 <intrados>   fromOrder (Order p q _) = "Selling" ++ show p ++ show q
23:03:00 <intrados> module Main where
23:03:05 <intrados> import qualified API1
23:03:08 <intrados> import qualified API2
23:03:08 <intrados> stringify :: FromOrder (Order o) => Order o -> String
23:03:11 <intrados> stringify o@(Order p q API1) = API1.fromOrder o
23:03:14 <intrados> Sorry everyone
23:03:18 <intrados> I meant to do this: http://lpaste.net/99068
23:04:39 <Cale> I don't understand why you're ignoring the API field in the FromOrder instances
23:05:24 <Cale> Why not write a single FromOrder instance which pattern matches that and does the right thing accordingly?
23:05:30 <danil> intrados: if you ever feel like you need two instances for the same type, you probably actually want two different types
23:05:51 <intrados> Cale: That seems sort of anti-modular though?
23:07:11 <Cale> Either that, or you just want two completely separate typeclasses
23:08:25 <Cale> But I don't *really* understand why you have this phantom OrderType parameter. I guess it could be good to check some things at compile time, but it seems just as likely a candidate to be an ordinary field of the record type
23:09:52 <Cale> But yeah, the easy solution here is just to put the FromOrder instances into the module which defines the Order type
23:10:32 <Cale> You generally don't want to have instances which are in a module which is not the module in which either the datatype or the class was defined in.
23:10:40 <Cale> It's allowed, as a means of last resort
23:11:11 <danil> Possibly you want a GADT "data Order a where BuyOrder :: Stuff -> Order Buy; SellOrder :: Stuff -> Order Sell", and then you can pattern match on it instead of writing pairs of typeclass instances
23:11:18 <Cale> But it's not considered a good idea, precisely because it allows problems to occur where modules can't be used together
23:11:31 <Cale> Because they both define instances of the same class for the same type
23:11:52 <Cale> Indeed, that's another good idea
23:12:28 <Cale> Also you could define then:
23:12:46 <Cale> data API = API { fromOrder :: Order a -> String }
23:13:27 <Cale> (in the case that Order was a GADT)
23:13:54 <Cale> Then all your classes are gone
23:14:21 <roboguy_> is there a way to relax the liberal coverage condition thing in ghc head so that I can compile an old library?
23:14:28 <jle`> fay is complaining that it can't find module Fay...so it isn't loading the fay package...what sort of compiler flags to the fay executable should i be throwing in to make this work?
23:15:20 <intrados> Hm, thanks. The GADT idea is appealing
23:20:54 <bitemyapp> jle`: is fay-base installed?
23:21:05 <jle`> bitemyapp: it is
23:21:09 <jle`> i got this to work actually
23:21:13 <jle`> i was using the global binary
23:21:15 <jle`> well
23:21:17 <jle`> what i had to do
23:21:26 <jle`> was explicitly put the package in the import statement
23:21:29 <jle`> import "fay" Fay
23:21:31 <jle`> for some reason
23:22:36 <jle`> but now i am getting "unable to resolve qualified names putStrLn", even though i import "fay-base" Prelude
23:23:14 <bitemyapp> the package qualification is awful suspicious.
23:23:18 <bitemyapp> I didn't need to do that at all.
23:23:44 <bitemyapp> generally my imports look like: import Prelude import FFI import Fay.Text
23:23:47 <bitemyapp> stuff like that.
23:24:08 <dhrosa> is there a way to "map" a function onto both elements of a tuple without repeating the function?
23:24:13 <dhrosa> a pair*
23:24:51 <jle`> bitemyapp: i do it because if i don't, ghc-mod tells me that there is an ambiguous Prelude because it thinks I'm using it with the rest of ghc
23:25:08 <jle`> so i thought it'd be harmless-ish
23:25:11 <jle`> i'll take them out and see what happens
23:25:50 <jle`> oh hey it works
23:26:19 <intrados> dhrosa: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:(a -> b) -> (a, a) -> (b, b)
23:26:34 <prooftechnique> dhrosa: In general, no, but for pairs you can use over both from Lens
23:27:06 <jle`> is there a cpp flag that checks if i'm in ghc or fay?
23:27:07 <bitemyapp> jle`: bwahahahaha
23:27:18 <bitemyapp> jle`: #ifdef FAY
23:27:25 <prooftechnique> Or the more general mapNTuple f = traverseOf each (return . f)
23:27:34 <edwardk> > over each length ("hello","to","everyone")
23:27:36 <bitemyapp> The only thing I enjoy more than being useful, is being right.
23:27:37 <lambdabot>  (5,2,8)
23:27:55 <prooftechnique> Oh, neat, that's much simpler
23:28:34 <jle`> bitemyapp: thanks :)
23:28:54 <bitemyapp> edwardk: where are over and each coming from?
23:29:00 <edwardk> lens
23:29:08 <bitemyapp> oh, dammit hoogle.
23:29:30 <edwardk> over l f = Identity . l (runIdentity . f)
23:29:32 <jle`> is there any way to specify in a cabal file that a package needs to be installed, but not 'depended on' by any of the source files?
23:29:48 <edwardk> each f (a,b,c) = (,) <$> f a <*> f b <*> f c  -- for this instance
23:30:03 <bitemyapp> under what conditions will a ghci session choke on the amount of code it had to link or interpret?
23:30:54 <prooftechnique> bitemyapp: That depends, under what conditions is that happening for you right now? :D
23:32:06 <bitemyapp> prooftechnique: oh not right now, I just noticed how much faster ghci is than my Clojure REPLs usually are and was wondering if it even really ever happened to anybody.
23:32:22 <bitemyapp> loading any sizable amount of code in a Clojure REPL gets tedious in a hurry.
23:33:03 <prooftechnique> I dunno. Whenever I load one of edwardk's libraries, ghci links a pile of libraries (also mostly edwardk's :D) and doesn't skip a beat
23:33:49 <bitemyapp> prooftechnique: that's what I was impressed by!
23:33:57 <qrada> is there any way to tell ghci to not output anything when it loads etc, not seeing many options in ghci manpage
23:34:07 <bitemyapp> I think edwardk's libraries are proof that Haskell code is composable :)
23:41:48 <edwardk> bitemyapp: i regularly load a a couple 20+ thousand line packages in at ghci alone, and bring up 100k+ lines of precompiled code without any noticeable delay
23:42:20 <bitemyapp> edwardk: I'd love to know how a language that doesn't even do much that is useful at compile-time have such a slow compiler, resident or otherwise.
23:42:24 <bitemyapp> (clj)
23:42:58 <bitemyapp> layering type-checking on top of that is actually agonizing if you're in a quick turn-around iteration mode.
23:43:08 <bitemyapp> ghci <3
23:46:28 <qrada> somehow need to unset +t i think, in ghci
23:46:40 <qrada> :unset +t or any variation, doesnt work heh
23:52:56 <bmuk> when monads require applicative, will liftM go away?
23:53:09 <bmuk> what about return/pure?
23:53:13 <shachaf> Probably not.
23:53:24 <shachaf> liftA exists even though Functor is a superclass of Applicative.
23:54:47 <Twey> But you can just ignore the less general ones.
23:55:31 <fragamus>  hey does anyone know of adaptation of graphics gems to haskell
23:55:31 <shachaf> Or use them: instance Functor Foo where fmap = liftA
23:55:37 <fragamus> like FFI
23:56:23 <bmuk> does anyone here know what haskell.org's plans are for google summer of code this year?
23:56:43 <L8D> someone please answer bmuk's question
23:57:19 <shachaf> What sort of answer does bmuk want?
23:57:28 <shachaf> The plans probably include participating.
23:57:30 <L8D> what the plans are
23:57:35 <fragamus> lol
23:57:56 <shachaf> I don't understand the question.
23:58:12 <L8D> I don't completely know what google SOC really is...It just sounds cool
23:58:18 <L8D> and haskell should participate in it
23:58:28 <fragamus> a plan like with maps and stuff
23:58:40 <shachaf> Haskell.org has participated in it since 2006.
23:58:42 <bmuk> I was given to understand that haskell has participated in the past
23:59:08 <bmuk> oh, my question seems naive now. lol.
23:59:27 <shachaf> If you don't know what it is you should probably read the general Summer of Code website.
23:59:56 <bmuk> Do you know what kind of work needs to be done the most?
