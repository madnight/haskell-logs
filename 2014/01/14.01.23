00:09:33 * hackagebot JuicyPixels 3.1.3.1 - Picture loading/serialization (in png, jpeg, bitmap, gif, tiff and radiance)  http://hackage.haskell.org/package/JuicyPixels-3.1.3.1 (VincentBerthoux)
00:09:33 * hackagebot google-dictionary 0.1.0.2 - Simple interface to the google.com/dictionary API  http://hackage.haskell.org/package/google-dictionary-0.1.0.2 (mitchellwrosen)
00:11:57 <carlo_au> Is there an expected release date for a stable ghc 7.7.x release?
00:12:51 <carlo_au> or 7.8.x, rather
00:13:04 <johnw> carol_au: often asked, never answered :)
00:14:01 <tdammers> "when it's done" :D
00:14:06 <carlo_au> bah :)
00:14:28 <carlo_au> I'd like to use some of Cabal-1.18's API but ghc-7.6.3 seems to force Cabal-1.16.0.0
00:15:22 <ChongLi> I'm using cabal 1.18
00:15:43 <ChongLi> on ghc-7.6.3 that is
00:16:17 <carlo_au> ChongLi: the API or the command line thing?
00:16:51 <ChongLi> carlo_au: doesn't matter, it's just a matter of getting the right package
00:18:08 <ChongLi> is the project that's using the Cabal library sandboxed?
00:18:14 <carlo_au> ChongLi: https://gist.github.com/carlohamalainen/8574816
00:18:16 <carlo_au> yes, sandboxed
00:18:49 <ChongLi> could you do a ghc-pkg list ?
00:19:13 <carlo_au> $ ghc-pkg list | grep -i cabal
00:19:13 <carlo_au>     Cabal-1.16.0
00:19:13 <carlo_au>     Cabal-1.18.1.2
00:19:32 <ChongLi> hmmm
00:19:45 <carlo_au> the ghc-7.6.3 package depends on Cabal-1.16; my cabal file asks for Cabal >= 1.18, and this clashes
00:20:47 * kusut is also interested in the solution, since he wants to install cabal in user space
00:21:13 <carlo_au> kusut: what do you mean by 'user space'?
00:22:00 <ChongLi> carlo_au: I'm doing an example project myself
00:22:02 <kusut> carlo_au: not globally? idk, I just started learning haskell and read http://www.vex.net/~trebla/haskell/sicp.xhtml
00:22:08 <ChongLi> and it seems to be working just fine
00:22:36 <carlo_au> ChongLi: can I see the .cabal file for the project?
00:23:26 <ChongLi> http://lpaste.net/98980
00:28:48 <carlo_au> ChongLi: that works, it's building.
00:29:43 <carlo_au> ChongLi: but if I add "ghc >= 7.6.3" then it gets stuck.
00:29:43 <ChongLi> carlo_au: yay!
00:29:49 <ChongLi> ohhh
00:29:53 <carlo_au> (I'm using the GHCI API too.)
00:30:04 <ChongLi> yeah, I didn't realize
00:30:25 <ChongLi> that's a problem :(
00:30:54 <carlo_au> hmm
00:33:02 <ChongLi> it's a bit frustrating that ghc 7.8 is taking so long
00:33:29 <ChongLi> but this is what happens when one of the main developers leaves for Facebook (or so I hear)
00:35:01 <carlo_au> ChongLi: who was that?
01:10:24 <merijn> ChongLi: That's not the problem
01:10:32 <merijn> carlo_au: Simon Marlow now works for Facebook
01:10:58 <carlo_au> merijn: ah
01:12:25 <carlo_au> I built ghc 7.7 from the git repo, but ghc-mod-3.0.5 doesn't built, so I'm a bit stuck. Will have to leave this for a bit.
01:13:40 <merijn> carlo_au: Many tools like ghc-mod haven't been updated with changes in HEAD, you might want to try versions from their respective repos
01:13:57 <carlo_au> merijn: will do.
01:14:56 <merijn> carlo_au: As for having 7.6 depend on Cabal-1.16, I have three versions of Cabal installed with 7.6 and it works fine that way
01:15:19 <merijn> carlo_au: Most likely you forgot to update cabal-install?
01:15:47 <carlo_au> merijn: I have Cabal-1.16 and Cabal-1.18 installed with 7.6.3, the problem is the ghc-7.6.3 package (for the GHC API) that forces 1.16
01:16:04 <merijn> oh, wait I missed the using of ghc-7.6.3
01:16:43 <piezoid> hi
01:16:56 <piezoid> is there an equivalent of Foldable/Traversable for Profunctors ?
01:17:01 <remdezx> hello! I need to make something similiar to ghci, I mean compile JIT haskell functions and modules in my own application. Do you know where can I find something about it?
01:17:32 <merijn> kusut: In short, the answer is that it's only a problem if you want use the GHC library, just using cabal should be fine installing in user space
01:17:43 <merijn> remdezx: Check out mueval
01:19:30 <piezoid> remdezx: I discovered how relatively easy it is with the Hell code : https://github.com/chrisdone/hell/blob/7a96/src/Hell.hs
01:21:53 <remdezx> merijn: why mueval? ghci isn't better?
01:22:20 <merijn> remdezx: mueval is an existing library, I don't think ghci is available as a library
01:23:19 <kusut> merijn: is this okay? ghc from OS, build compile cabal from source, sudo install cabal (Setup.hs), run bootstrap.sh
01:23:25 <remdezx> merijn: ok, but I though I can see how ghci does JIT and do this same way
01:24:06 <danilo2> merijn: Dont you think ghci is much more mature than mueval? Taking some code out of it and patching as a library should not be a big deal, am I wrong?
01:24:20 <merijn> danilo2: I'm not sure
01:24:36 <merijn> danilo2: mueval is not that immature either
01:24:46 <merijn> danilo2: It's what lambdabot uses
01:25:00 <danilo2> merijn: Additional, if this interpreter involves jit compilation or runtime libraries loading / unloading - ghci has these features imlemented (especially the ghci in 7.7) - so maybe it is better to base on it?
01:25:25 <merijn> kusut: I dunno, tbh. Usually I don't bother building from scratch and just install the platform
01:25:29 <danilo2> merijn: Hmm, interesting. I didnt realized that lambdadot uses something other than ghci related project
01:25:50 <merijn> kusut: Although your mileage with that may vary on linux
01:25:54 <danilo2> merijn: btw. Why there exist 2 separate projects for the same task? It looks like a lot of duplicated work to me
01:25:56 <kusut> merijn: and then you update cabal to newer version, then cabal install things?
01:26:14 <merijn> danilo2: Welcome to the real world :p
01:26:25 <merijn> danilo2: There's only like 15 billion web stacks
01:26:26 <danilo2> merijn: Hi! :D
01:26:37 <merijn> kusut: Then I just do "cabal install cabal-install" to install the latest cabal version
01:27:13 <kusut> merijn: okay. thanks. I was just afraid polluting my global/system
01:27:28 <piezoid> i think neither ghci nor mueval is doing jit compilation, they are interpreters interfacing with binary code
01:27:57 <danilo2> merijn: Ok :) Do you know about the features of mouveral? We (with remdezx) would love to be able to jit compile haskell code, load and unload libraries and execute it in interprter - these features are crutial for us
01:28:14 <merijn> danilo2: I don't think it does JIT, but then neither does ghci
01:28:52 <danilo2> merijn: And las one question, if I might :) I havee heard about hermit - I do not know exactly what it is (I've read some documentation, but I do not know what is the target of this tool) - do you think it could be related and helpfull for writing such interpreter?
01:29:25 <danilo2> merijn: Maybe JIT is wrong word for it - ghci is able to compile a code and load it - if it is not JIT, than I do not know what it is, because its damn fast
01:29:36 <piezoid> danilo2: it's a GHC plugin for custom optimisation passes
01:30:07 <merijn> @hackage mueval
01:30:07 <lambdabot> http://hackage.haskell.org/package/mueval
01:30:34 <piezoid> danilo2: i think it allow to inspect the code while running transformations in a interactive process
01:32:13 <merijn> kusut: There's a 1 simple step to avoid cabal polluting the global install
01:32:30 <merijn> kusut: Never sudo or use --global when using cabal
01:32:44 <merijn> kusut: For non-super users cabal always defaults to local install
01:33:03 <danilo2> piezoid: ahh it is for writing ghc optimization passes? Hmm interesting. So I think we will not use it to write our interpreter.
01:33:42 <kusut> merijn: my understanding was if I install the platform or setup cabal-install with sudo, then Im already polluting the global. my understanding was wrong, wasnt it?
01:35:11 <timthelion> kusut: That may just install a broken version of the libs in your home dir.
01:39:33 <kusut> alex and happy are part of the platform. if I do cabal-install sandbox libs that require them, do they get copied to my sandbox? or just the references?
01:40:56 <danilo2> piezoid: You'vl inked us to the Hell code. As I see it uses GHC API - not mouveal - could you tell me why? Was the mouveal not enough?
01:43:49 <piezoid> danilo2: i have no idea. Maybe because it's doing simple things. Mueval use GHC API too.
01:44:08 <danilo2> piezoid: Ahh, I was thinking you're the author of it :) Ok, thanks :)
01:44:18 <piezoid> danilo2: Mueval bring safety and simpler context management i think
01:45:07 <merijn> kusut: The way most linux distros install GHC already pollutes global, it's a problem with linux distros wanting everything to go their way
01:46:51 <tdammers> well... "wanting" probably less than "having to"
01:48:39 <kusut> so the common practice is just install platform on global then install everything else sandboxed via cabal, right?
01:49:09 <tdammers> sandboxed or locally, depends on your preference
01:49:25 <tdammers> some people prefer installing libraries from their distro though
01:49:37 <bezirg> question: right now I am using haskell-src-exts to generate some top-level function declarations with: `FunBind [Match]` . The Match is `Match SrcLoc Name [Pat] (Maybe Type) Rhs Binds` . What is the purpose of `Maybe Type` there? Can I combine a type signature of a function together with the function definition? With this, I can generate for example `f x :: a -> a = x` but it doesn't want to compile
01:49:47 <tdammers> also, installing common packages outside the sandbox can be a time saver
01:49:57 <tdammers> especially for stuff that takes long to compile
01:50:07 <kusut> I see
01:53:37 <kusut> thank you everyone
02:15:42 <honza> Inside a do block in the IO monad, how can I bind (what i usually do with <-) [IO a] to [a]?
02:16:04 <tdammers> mapM?
02:16:07 <tdammers> :t mapM
02:16:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
02:16:21 <tdammers> no wait... hmm
02:17:27 <mbrock> :t sequence
02:17:28 <tdammers> ah right
02:17:28 <lambdabot> Monad m => [m a] -> m [a]
02:17:30 <tdammers> :t sequence
02:17:31 <lambdabot> Monad m => [m a] -> m [a]
02:17:34 <mbrock> :)
02:21:23 <honza> tdammers: mbrock: excellent, thanks!
02:25:34 <tdammers> honza: also, hoogle ;)
02:25:58 <honza> tdammers: i tried but was going about it the wrong way
02:26:24 <tdammers> heh
02:27:21 <tdammers> @hoogle [IO a] -> IO [a]
02:27:21 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
02:27:22 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
02:27:22 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
02:28:01 <tdammers> @hoogle [IO a] -> [a]
02:28:01 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
02:28:01 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
02:28:01 <lambdabot> Foreign unsafePerformIO :: IO a -> a
02:28:12 <tdammers> I can see how the latter would be somewhat confusing
02:31:43 <danilo2> Hello! :) I'm creating some code, which uses existential types. I would like to ask you why the following code does not compile (http://lpaste.net/98982) ? The problem is with the "forall a b. Show (a b)" predicate - is in tos supposed to work that way? (it works if we replace b by Int)
02:33:48 <bezirg> hi, let's say I have this function f :: (Num a) => a -> b -> a  and its definition `f x y = let z = x + 1 in z`  . How can I explicitly annotate/fill the type of the let-bound z to point to (Num a) => a?
02:34:22 <bezirg> When I try to annotate it in the let binding, it introduces a new a, so it cannot match the typevariable a with another a1
02:34:44 <Axman6> you need ScopedTypeVariables, but why do you need to do that? it's a;lready going to be that
02:36:55 <bezirg> I tried with ScopedTypeVariables but still no luck, check http://lpaste.net/98983
02:37:29 <mgsloan> You need "f :: forall a. (Num a) ...." for your top level type sig
02:37:55 <ChongLi> and also, what is the deal with this?
02:37:56 <mgsloan> actually, forall a b.
02:37:58 <ChongLi> y isn't even used
02:38:20 <bezirg> ty mgsloan
02:38:24 <mgsloan> welcome!
02:38:49 <mgsloan> The forall calls out that you're explicitly bringing a and b into scope
02:39:22 <bezirg> y I already knew that, but I thought this was implicit somehow
02:39:46 <mgsloan> It is!  The top level forall is usually implicit
02:39:47 <bezirg> for the rank-1 types at least
02:39:56 <mgsloan> but for the purpose of scoped type variables it isn't
02:40:02 <bezirg> good to know!
02:40:11 <mgsloan> it's a bit of a wierd thing, there's a long discussion earlier today in the logs about it
02:41:53 <augur_> http://permalink.gmane.org/gmane.comp.lang.haskell.cafe/109208
02:42:24 <augur_> regarding this, i think the right perspective is that its not the language that affects your thinking, but the concepts that the language is used to convey
02:43:31 <augur_> for PLs we often pretend like these are tightly linked, but you can communicate good ideas with general languages. the problem is mostly that we teach particular perspectives that are more or less well-supported
02:43:44 <tdammers> do I smell sapir-whorf again?
02:44:40 * hackagebot copr 1.1.0 - Haskell interface to the Fedora Copr system  http://hackage.haskell.org/package/copr-1.1.0 (RickyElrod)
02:44:56 <augur_> tdammers: its hard not to, since its about Sapir-Whorf :P
02:45:31 <tdammers> did not read linked article :x
02:45:40 <augur_> shame on you!
02:45:50 <augur_> (i didnt either, i skimmed for a few pars)
02:46:31 <mgsloan> Thing is, some languages will make it more convenient to convey some particular concept
02:46:33 <tdammers> anyway... sapir-whorf applied to programming languages looks even more compelling than sapir-whorf on natural languages at first sight
02:47:09 <tdammers> I've had quite a few programming epiphanies caused by using a particular language
02:47:13 <augur_> mgsloan: yes, thats precisely it
02:47:30 <augur_> the sapir whorf hypothesis is not what people think it is
02:47:44 <tdammers> what do you think people think it is?
02:47:49 <mgsloan> Yeah, the weak form is quite reasonable
02:48:01 <mgsloan> the strong form of sapir whorf is absurd, imho
02:48:02 <augur_> the loose version people are using isnt it, and the loose version is also so loose that its not really about the language in any real sense
02:48:26 <augur_> tdammers: people think sapir-whorf is something like "the language you use affects how you think", for a very loose usage of "language"
02:48:37 <augur_> that looseness is important
02:49:10 <augur_> people somehow conflate language with concepts a _lot_
02:49:29 <augur_> and what they mean is language+concepts
02:49:47 <augur_> which is obviously true. the concepts you have constrain your thoughts, so ...
02:50:27 <tdammers> I think people use the term to mean anything between "we can only think what our language can express" and "language influences our thinking"
02:50:53 <augur_> also crucially, while proglangs can speed or slow certain lines of reasoning, generally people can still think the same ideas if the ideas are expressible at all
02:51:12 <augur_> tdammers: people do that too. the first one i mean
02:51:32 <augur_> and ofcourse its demonstrable nonsense, but
02:51:38 <mgsloan> When someone says "Well, I could do that Haskelley thing in X, so why would I use Haskell?", I usually respond "Sure, but is it convenient?  Is it so convenient that the writers of the libraries are also likely to have done that thing?"
02:51:54 <tdammers> mgsloan: that's kind of a strawman
02:52:08 <augur_> mgsloan: right. the point there being, the _thought_ isnt impossible, obviously
02:52:14 <augur_> if it were, you couldnt have the conversation
02:52:20 <augur_> its just harder to deploy
02:52:23 <mgsloan> tdammers: I'm not exactly on topic here :)
02:52:29 <tdammers> mgsloan: yeah
02:52:30 <augur_> and thats a trivial language thing
02:52:43 <augur_> everyone knows if you cant express something concisely, it ... is harder to express
02:52:50 <augur_> i mean thats tautological
02:52:58 <mgsloan> right
02:53:07 <tdammers> ah, but having the means at hand to express something conveniently also makes it easier to grasp the very concept
02:53:15 <augur_> yes thats true
02:53:16 <danilo2> Hello! :) I'm creating some code, which uses existential types. I would like to ask you why the following code does not compile (http://lpaste.net/98982) ? The problem is with the "forall a b. Show (a b)" predicate - is in tos supposed to work that way? (it works if we replace b by Int)
02:53:23 <augur_> so these things are indeed relevant in a sort of practical sense
02:53:25 <tdammers> things like partial application and closures only *really* clicked after I started using Haskell
02:53:27 <augur_> which is what i was saying
02:53:40 <tdammers> monads, too
02:53:46 <augur_> its harder to teach these concepts using language X, so we wont teach them cause we're using language X
02:53:58 <danilo2> mgsloan: Ah , I didnt notice you answered me
02:54:04 <tdammers> look at all those "here's how you use Monads in JavaScript" tutorials
02:54:13 <augur_> but now what you're seeing is not anything like linguistic relativism
02:54:19 <augur_> now what you're seeing is something completely different
02:54:49 <augur_> because its not the language determining the thought so much as the language giving rise to _choices about what ideas to teach_
02:55:04 <augur_> and thats a very different thing
02:55:18 <danilo2> mgsloan: or not me, you've answered other question I think :)
02:55:34 <mgsloan> danilo2: indeed, I was answering bezirg
02:56:23 <tdammers> augur_: interesting thought
02:56:32 <mgsloan> danilo2: So, in your datatype, why is there an existential "b" type?
02:56:36 <mgsloan> variable
02:57:03 <danilo2> mgsloan: I was sure, the type signature just means - forall a and b - so even if b is Int it should work, shouldnt it ?
02:58:26 <augur_> tdammers: but thats what happens. i mean, thats _why_ people like Crockford make these monad tutorials
02:58:55 <augur_> because they CAN have the ideas, they CAN (sort of) express them, but the shittiness of the language prevents adoption of the idea
02:59:27 <tdammers> I think the thing with Crock is that he's this friendly guy who bangs his head against things until he understands them, and when he does, he's so excited about it that he wants to tell everyone
02:59:33 <tdammers> which is nice
02:59:55 <tdammers> but still, he's not making a convincing argument there
03:00:18 <tdammers> because a) Javascript doesn't *need* monads, and b) monads don't make Javascript code any better
03:00:37 <augur_> tdammers: no of course, but thats precisely because the language cant even begin to support them
03:00:54 <augur_> every language "needs" monads, in the sense that it would be better with them
03:01:04 <augur_> haskell was like this back in the day
03:01:14 <augur_> now haskell needs monads or else it wont function
03:01:21 <tdammers> the need for monads is more pressing when you won't accept impure constructs though
03:01:30 <tdammers> exactly
03:02:21 <augur_> i mean, you could go the ML route and just wrap everything in a monad
03:02:29 <augur_> which is i think why harper prefers ML
03:02:43 <augur_> its convenient and subject to denotational reasoning
03:02:51 <augur_> im not sure i buy the argument tho
03:03:09 <tdammers> I think I lack the ML skills to comment on that one
03:03:28 <augur_> the launch-the-missiles rhetoric is good, i think
03:03:43 <augur_> purity isnt just about having a semantics, its about enforcement
03:04:39 <skypers_> @let changeIf :: a -> (a -> Bool) -> a -> a; changeIf x p x' | p x = x' | otherwise = x
03:04:42 <lambdabot>  Defined.
03:04:48 <skypers_> does this function already exist?
03:05:23 <skypers_> map (\c -> c `changeIf` (=='/') '.') "Control/Monad/Trans/Either/Lazy.hs"
03:05:29 <skypers_> > map (\c -> c `changeIf` (=='/') '.') "Control/Monad/Trans/Either/Lazy.hs"
03:05:31 <lambdabot>  Couldn't match expected type `GHC.Types.Char -> GHC.Types.Bool'
03:05:31 <lambdabot>              with actual type `GHC.Types.Bool'
03:05:47 <skypers_> le what
03:05:53 <mgsloan> danilo2: Sorry, pinged out!  I'm not sure why it doesn't know that a is []
03:06:00 <tdammers> augur_: for me, it's mostly about making things explicit at all times while at the same time maintaining compact and readable abstractions
03:06:41 <skypers_> > map (\c -> changeIf c (=='/') '.') "Control/Monad/Trans/Either/Lazy.hs"
03:06:44 <lambdabot>  "Control.Monad.Trans.Either.Lazy.hs"
03:06:48 <skypers_> that’s better :)
03:07:04 <danilo2> mgsloan: It doesnt know that b is Int. This is the problem. If you replace b by Int it works. It just should work with b also (acoding to my internal feelings) :)
03:07:13 <skypers_> :t replaceBy
03:07:14 <lambdabot> Not in scope: `replaceBy'
03:07:26 <skypers_> yeah, it’s surprising it doesn’t exist yet
03:09:00 <skypers_> vs. the if else version
03:09:08 <skypers_> we gain a few characters
03:09:26 <skypers_> it might not worth it
03:21:14 <Edootjuh> @pl map (\x -> x 1)
03:21:15 <lambdabot> map ($ 1)
03:31:43 <BoR0> :t (\x -> x * x) says Num a => a -> a. :t f says Num a => a -> a (for f x = x*x). but, why does :t g says Integer -> Integer for f = \x -> x*x ?
03:31:44 <lambdabot> parse error on input `=>'
03:32:46 <BoR0> I meant for g = \x -> x*x
03:34:22 <supki> BoR0: monomorphism restriction
03:35:48 <supki> well, and defaulting rules
03:35:58 <BoR0> I see. what are the defaulting rules?
03:37:30 <supki> they help ghc to choose monomorphic type to default to
03:37:50 <supki> in this case it's Integer
03:41:47 <supki> if ghc can't find a suitable monomorphic type it will error
03:42:00 <supki> @let h = \x -> show x
03:42:01 <lambdabot>  .L.hs:147:12:
03:42:02 <lambdabot>      No instance for (Show a0) arising from a use of `show'
03:42:02 <lambdabot>      The type variable `a0' is ambiguous
03:42:02 <lambdabot>      Possible cause: the monomorphism restriction applied to the following:
03:42:02 <lambdabot>        L.h :: a0 -> String (bound at .L.hs:147:1)
03:42:46 <rtpg> wait where does the monomorphism restriction apply?
03:43:04 <supki> ghci, though, has extended set of defaulting rules, so  h  will have   () -> String  type
03:43:09 <supki> which is also confusing :)
03:43:25 <rtpg> http://www.haskell.org/haskellwiki/Monomorphism_restriction
03:44:17 <rtpg> you can turn it off with "No Monomorphism restriction"
03:49:55 <merijn> rtpg: let, where and top level
03:50:27 <rtpg> so on bindings ?
03:50:32 <merijn> rtpg: Yes
03:51:10 <merijn> rtpg: Explicit type signatures solve monomorphism too
03:51:28 <rtpg> oh, I write type signatures a lot so that's probably why I don't run into it a lot
03:51:28 <merijn> rtpg: i.e. "let h :: Show a => a -> String; h = \x -> show x" should work
03:52:02 <merijn> rtpg: The monomorphism tries to avoid "unintentional" polymorphism, but type signatures already tell GHC explicitly to be polymorphic
04:19:45 <qwertol> hello?
04:19:56 <ChongLi> hi
04:19:57 <thomassgn> hello
04:20:16 <jmcarthur> yo
04:20:38 <qwertol> how does haskell splitAt manages to be O(1)?
04:20:44 <jmcarthur> it doesn't
04:20:56 <jmcarthur> it's O(n)
04:21:01 <qwertol> oh
04:21:17 <ChongLi> unless you're referring to some other splitAt, such as the one for ByteStrings
04:21:39 <jmcarthur> right, for ByteStrings it's O(1)
04:21:58 <jmcarthur> because a ByteString is just an offset, length, and pointer. it just have to change the offset and length
04:22:04 <jmcarthur> s/have/has/
04:22:11 <Fuuzetsu> cue the ‘ByteStrings are not Strings’ issue
04:22:34 <jmcarthur> if you need something list-like in that cons is O(1) but also need fast splitAt, maybe consider Data.Sequence, which has O(log n) splitAt
04:22:48 <qwertol> well it could be in imperative languages, so I thought haskell does some magic (checks if you are loosing reference, if yes just replace data in nodes)
04:22:49 <ChongLi> yeah, Text.splitAt is O(n)
04:23:14 <ChongLi> because to properly split UTF8 you have to traverse it to make sure you're not splitting in the middle of a character
04:24:19 <ziman> rather, to count characters correctly
04:24:24 <ChongLi> yeah
04:25:12 <ziman> (and Data.Text is utf-16, iirc, but this does not affect the point)
04:25:31 <ChongLi> ohhhhhhhh
04:25:35 <ChongLi> I didn't know that
04:25:38 <jmcarthur> Text doesn't store as UTF-8, i thought. I thought the reason was just that some unicode code points have multiple characters (or somesuch terminology)
04:25:57 <jmcarthur> s/have/are made up of/
04:26:09 <qwertol> so removal from list in O(1) is impossible even if there are no references to former list?
04:26:23 <ChongLi> you can remove the first element of a list in O(1)
04:26:26 <ChongLi> :)
04:26:44 <jmcarthur> qwertol: you can always remove the head in O(1). you can't remove arbitrary nodes in O(1).
04:27:24 <jmcarthur> qwertol: for a reference into the list to help you, you would need to be able to mutate it.
04:27:56 <qwertol> I'm just learning about FP, so how do functional programming languages efficiently deal with changing sets of data?
04:28:09 <jmcarthur> by using more appropriate data structures
04:28:19 <ziman> you generally use the right structure for the set of operations you need to perform on it
04:28:28 <ChongLi> qwertol: changing data is just a special case of creating new data :)
04:28:29 <jmcarthur> for example, the other recommendations we made, such as ByteString or Data.Sequence
04:28:45 <ChongLi> you're creating it and writing it over the old data instead of into a new location
04:29:00 <ChongLi> in FP, writing into the new location is the default
04:29:24 <ChongLi> this gives you the ability to treat data as a value, rather than a location :)
04:35:28 <qwertol> ok, thanks
04:35:33 <qwertol> bye
04:36:56 <tdammers> jmcarthur: utf-16 has multi-word code points as well
04:37:09 <tdammers> jmcarthur: I thought Data.Text and String were utf-32
04:37:25 <tdammers> jmcarthur: or rather, encoding-agnostic containers of Int
04:37:54 <tdammers> jmcarthur: or, actually correct, containers of Char, which is just a transparent 32-bit character
04:38:37 <jmcarthur> tdammers: String is a list of Char. Char is a unicode codepoint (whatever size it needs to be)
04:38:43 <gspr> Does anybody know of a lock-free, single-producer-single-consumer ring buffer implementation where the buffer memory is contiguous and available as a Ptr? lockfree-queue on Hackage seems close, but AFAIK does not fulfil the last part
04:38:52 <jmcarthur> tdammers: Text is not a container of Char, though.
04:38:58 <tdammers> hmm
04:39:01 <tdammers> ok
04:39:16 <jmcarthur> > ord maxBound
04:39:20 <lambdabot>  1114111
04:40:24 <tdammers> ah, checked the source
04:40:37 <tdammers> apparently Data.Text only supports the 16-bit subset of UTF-16
04:40:58 <tdammers> I am slightly disappointed now
04:41:52 <jmcarthur> that's not right either
04:42:09 <jmcarthur> Text just uses UTF-16 as its internal representation
04:42:19 <jmcarthur> that doesn't mean you can't import/export other encodings
04:42:33 <jmcarthur> ah wait
04:42:47 <tdammers> it uses UTF-16 internally, but converting between Text and String fails (albeit gracefully) for multi-word code points
04:43:00 <jmcarthur> i don't actually know the relationship between UTF16 and UTF32
04:43:07 <jmcarthur> is 32-16 lossy?
04:43:11 <tdammers> no
04:43:14 <jmcarthur> 32->16
04:43:15 <jmcarthur> ah
04:43:18 <jmcarthur> okay then
04:43:21 <tdammers> utf32 is fixed-width
04:43:29 <tdammers> utf16 is 16-bit variable-width
04:43:43 <jmcarthur> i think the problem with String is String, not Text
04:43:44 <tdammers> most codepoints however fit in one 16-bit word
04:44:01 <tdammers> I don't think there is a perfect solution
04:44:56 <tdammers> Text could use 32-bit representations internally
04:45:18 <tdammers> but then, about 99% of all unicode data in the world can probably be expressed in 16-bit chars
04:45:32 <tdammers> which would make 32-bit wasteful
04:46:01 <tdammers> supporting variable-width encodings, however, makes things like substrings and such a lot more complicated, and prone to Shlemiel-the-painter traps
04:46:39 <tdammers> String can get away with it, because it's Shlemiel-vulnerable anyway by virtue of being a linked list
04:47:15 <tdammers> Text, by contrast, is giving up on the last 1% to get massively better performance
04:47:28 <tdammers> which, I'd argue, is probably as good as it gets
04:56:16 <mm_freak_> tdammers: i can't confirm
04:56:38 <mm_freak_> > T.unpack (T.singleton '\118840')
04:56:38 <mm_freak_> "\118840"
04:56:41 <lambdabot>  Not in scope: `T.unpack'
04:56:42 <lambdabot>  Perhaps you meant `BS.unpack' (imported from Data.ByteString)Not in scope: `...
04:56:42 <lambdabot>  Perhaps you meant one of these:
04:56:42 <lambdabot>    `M.singleton' (imported from Data.Map),
04:56:42 <lambdabot>    `S.singleton' (imported from Data.Set),
04:56:59 <mm_freak_> multi-word text seems to work fine here
04:57:27 <mm_freak_> it's text 0.11.3.1
04:57:51 <the_berserker> @pl \f m -> m >>= (ret. f)
04:57:51 <lambdabot> (=<<) . (ret .)
04:58:27 <the_berserker> @pl (=<<) . (return .)
04:58:27 <lambdabot> fmap
04:58:46 <mm_freak_> tdammers: also if text were really single-word only, then some of the function complexities were different
04:58:54 <mm_freak_> in particular many O(n) would become O(1)
05:00:19 <the_berserker> @pl (>>= id)
05:00:19 <lambdabot> join
05:04:32 <the_berserker> @pl (flip (>>=)) . (return .)
05:04:32 <lambdabot> fmap
05:04:33 <Fuuzetsu> is there a way to tell cabal to do deep reinstall? I'm missing some profiling libs for package A which relies on package B which relies on C… At the moment it seems that I need to try to install A, see what fails, try to install that, see what fails etc. etc. all the way to the bottom
05:04:33 <jmcarthur> tdammers: i think the only problem with converting from Char is that Char can express invalid scalars
05:04:35 <rawtass> How do I map over runGet :: Get a -> ByteString -> a? I have a list of ByteStrings and a foo :: Get a function.
05:04:51 * hackagebot Chart 1.2 - A library for generating 2D Charts and Plots  http://hackage.haskell.org/package/Chart-1.2 (TimDocker)
05:05:16 <c_wraith> Fuuzetsu: there's always the world metatarget.
05:05:28 <Kaidelong> isn't Text what you use if you want a string with underlying bytestring representation?
05:05:36 <jmcarthur> Fuuzetsu: i usually turn profiling builds on in the config file before installing any packages, and if i forgot i just start over :\
05:05:48 <jmcarthur> Kaidelong: yes
05:06:20 <Fuuzetsu> jmcarthur: fortunately this is in a sandbox but I switched off profiling while working on something and just now tried running ‘cabal test’ which needs profiling ;/
05:06:38 <c_wraith> Fuuzetsu: just use the world metatarget.
05:07:03 <Fuuzetsu> c_wraith: I'd rather avoid reinstalling everything in the sandbox… I only need the test-related stuff reinstallde
05:07:17 <bennofs> cabal test needs profiling? :O
05:07:19 <the_berserker> @pl (>>= id)
05:07:20 <lambdabot> join
05:07:52 <Fuuzetsu> bennofs: I think it's just the package I'm working on that has it on.
05:08:08 <the_berserker> @pf (>>= (.))
05:08:08 <lambdabot> Maybe you meant: pl bf
05:08:27 <the_berserker> @bf (>>= (.))
05:08:28 <lambdabot>  Done.
05:08:32 <c_wraith> Fuuzetsu: the alternative is doing the traversal yourself.  You know you can have multiple targets listed on the cabal command line?
05:08:37 <Fuuzetsu> c_wraith: Oh, huh, cabal install -ftest world --enable-executable-profiling --enable-library-profiling --reinstall is only doing what I wanted! Great.
05:08:47 <the_berserker> How to convert to pointful style with lambdabot?
05:09:03 <Fuuzetsu> oh, or so I thought
05:09:09 <Kaidelong> oh I misread the question
05:09:32 <shiona> @unpl (>>= (.))
05:09:33 <lambdabot> (\ d e -> (\ a b c -> a (b c)) (d e) e)
05:09:52 * hackagebot Chart-cairo 1.2 - Cairo backend for Charts.  http://hackage.haskell.org/package/Chart-cairo-1.2 (TimDocker)
05:09:54 * hackagebot Chart-diagrams 1.2 - Diagrams backend for Charts.  http://hackage.haskell.org/package/Chart-diagrams-1.2 (TimDocker)
05:09:56 * hackagebot Chart-gtk 1.2 - Utility functions for using the chart library with GTK  http://hackage.haskell.org/package/Chart-gtk-1.2 (TimDocker)
05:10:22 <Fuuzetsu> GAH
05:10:29 <Kaidelong> rawtass: runGet foo would have type "Bytestring -> a" so you could just map that over your [ByteString]
05:10:36 <Fuuzetsu> I had my symlink pointed at unprofiled GHC libs, no wonder it didn't work!
05:10:38 <Kaidelong> and get a [a]
05:10:46 <the_berserker> > (fmap :: (a -> b) -> (Maybe a -> Maybe b)) (+) (Just 6) (Nothing)
05:10:49 <lambdabot>  Couldn't match expected type `Data.Maybe.Maybe a1 -> t0'
05:10:49 <lambdabot>              with actual type `Data.Maybe.Maybe (a0 -> a0)'
05:11:22 <the_berserker> Stupid Haskell compiler
05:11:42 <tdammers> ahme
05:11:44 <tdammers> ahem
05:11:55 <tdammers> don't you mean "insufficiently smart compiler"?
05:13:08 <Kaidelong> the_berserker: (fmap :: (a -> b) -> (Maybe a -> Maybe b)) (+) (Just 6) cannot be applied again, it becomes a Maybe (Num a => a -> a)
05:13:19 <Kaidelong> you could, however, use <*>
05:13:32 <Kaidelong> @type <*>
05:13:33 <lambdabot> parse error on input `<*>'
05:13:37 <Kaidelong> @type (<*>)
05:13:38 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:13:39 <killown> is there a good haskell book or tutorial for beginners?
05:13:55 <c_wraith> Kaidelong: move that constraint outside the Maybe, unless you really want to be implying impredicative types.
05:14:09 <Kaidelong> c_wraith: yes, my bad
05:14:15 <ChongLi> @lyah
05:14:15 <lambdabot> Unknown command, try @list
05:14:18 <ChongLi> hmm
05:14:21 <tdammers> @where lyah
05:14:21 <lambdabot> http://www.learnyouahaskell.com/
05:14:22 <Kaidelong> Num a => Maybe (a -> a)
05:14:25 <ChongLi> there we go :)
05:14:26 <tdammers> @where rwh
05:14:27 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:14:37 <killown> thank you
05:14:39 <ChongLi> killown: you probably want to start with lyah
05:14:43 <ChongLi> and then go to rwh
05:14:52 * hackagebot Chart-simple 1.2 - A wrapper for the chart library to assist with basic plots  http://hackage.haskell.org/package/Chart-simple-1.2 (TimDocker)
05:15:04 <rawtass> Kaidelong: let x = runGet foo list ?
05:15:07 <Kaidelong> theberserker: canonical style for doing that is actually (+) <$> Just 6 <*> Nothing
05:15:08 <tdammers> rwh worked better for me, but I had considerable programming background already
05:15:15 <rawtass> Kaidelong: sorry, let x = map runGet foo list ?
05:15:29 <Kaidelong> map (runGet foo) list
05:15:44 <mr-> > (ap.fmap (+)) (Just 4) (Just 4) -- pretty :->
05:15:46 <lambdabot>  Just 8
05:15:52 <killown> ChongLi ok I will try lyah firstly, thank you
05:16:02 <ChongLi> killown: have fun! :)
05:17:19 <Kaidelong> rawtass: map (runGet foo) list  still gives you an [a], is that the return type you are after? If you're looking for a then there exists a (Monoid a) => [a] -> a called mconcat
05:18:29 <bernalex> I have a program that does forever $ putStrLn "foo". what's the fastest type to use for this? I assume String is one of the slowest.
05:20:29 <tdammers> bernalex: not really - as long as you're just streaming strings linearly, String is OK
05:20:30 <timthelion> bernalex: wee if it literally does forever $ putStrLn "foo" then the type of string you are outputting likely has no effect on the speed whatsoever, because the entire thing will be bounded by text drawing.
05:20:37 <Fuuzetsu> bernalex: I don't thing the fact that "foo" is the String will change anything here.
05:20:47 <timthelion> s/wee/well
05:21:09 <bernalex> timthelion: I am literally doing that. but it shouldn't be limited by text drawing. I want to replicate the coreutils program yes.
05:21:32 <rawtass> Kaidelong: yes, worked.. thanks
05:21:50 <timthelion> bernalex: I think that using a different data type in this case would be premature optimization.
05:21:51 <tdammers> String has some massive memory overhead (more than 100%), but it's also lazy on a per-character basis
05:21:54 <bernalex> GNU coreutils yes is 15x faster than my program lol.
05:22:18 <bernalex> timthelion: premature? I literally want the program to just output "y\n" all the time, as fast as possibel.
05:22:24 <bernalex> s/possibel/possible
05:22:36 <timthelion> bernalex: how are you testing this?
05:23:08 <bernalex> timthelion: with the admittedly imprecise "[program] & sleep 5 && killall [program]".
05:23:28 <timthelion> bernalex: so you are seeing how long the output is?
05:23:30 <bernalex> timthelion: considering GNU's yes is 15x faster, the imprecision of the method isn't really relevant atm, heh.
05:23:44 <bernalex> timthelion: oh, no I'm doing [program]>afile, and then using wc -l file.
05:24:31 <tdammers> well, for starters, GNU yes is written in C, so there is a significantly smaller runtime to drag around
05:25:00 <tdammers> then, your code is Unicode-correct, which GNU yes is not (not that it matters, but it still impacts performance)
05:25:28 <kalloc_> hi
05:25:46 <kalloc_> what is the best web framework?
05:25:52 <bernalex> tdammers: OK. I'm just looking if there are some super cheap ways of optimising it. I'm writing the coreutils as illustrations of real-world-ish haskell programs, so I want the source to be readable for newbies. i.e. readability > optimisation.
05:25:52 <tdammers> for kicks, see if bytestrings buy you anything
05:25:58 <bernalex> tdammers: I thought about that
05:26:03 <kalloc_> yesod?
05:26:30 <bernalex> kalloc_: there is no "best" framework. there might be a framework that best suits your needs though. however, we do not know what your needs are.
05:26:31 <tdammers> kalloc_: yesod, snap, happstack, or rigging up your own things based on various libraries
05:26:44 <kalloc_> tdammers: good answer
05:26:49 <tdammers> those are the viable mature options
05:26:59 <tdammers> (as far as Haskell is concerned)
05:27:05 <Kaidelong> Just don't buy the book "Developing Web Applications for Haskell and Yesod"
05:27:11 <sleepynate> kalloc_: if you're asking that question, you might want to start with snap because it's got a rather low learning curve
05:27:13 <Maior> Kaidelong: orly?
05:27:13 <Kaidelong> You will regret it
05:27:20 <bernalex> there's hakyll if you don't need anything more than sattic Web sites
05:27:34 <Kaidelong> (I did)
05:27:39 <Fuuzetsu> Kaidelong: What's wrong with that book?
05:27:44 <d3lxa> Kaidelong: why not?
05:27:52 <sleepynate> Kaidelong: aside from being rather boring, it's not a bad book
05:27:58 <sleepynate> (imho)
05:28:21 <kalloc_> sleepynate: yes, i'm going to start :)
05:28:26 <Kaidelong> doesn't motivate its examples, doesn't introduce its concepts, doesn't devote enough time before moving on
05:28:32 <timthelion> It seems that the gnu folks didn't even bother optimizing out the extra alocation: http://git.savannah.gnu.org/cgit/coreutils.git/tree/src/yes.c
05:28:41 <kalloc_> snap is better for newbie ?
05:28:58 <bernalex> timthelion: well, their version is so fast that you can't possibly need it to go faster given its purpose
05:29:39 <sleepynate> Kaidelong: it's true – it's very much an overview of the architecture of the framework. it's not exactly "haskell web dev for new haskellers"
05:29:54 <timthelion> For whatever reason, when I write in C I allways put my allocations outside the loop. and when I write in haskell, I don't give a fuck about performance and use String.
05:30:03 <Kaidelong> I actually wouldn't have minded its style if it was a complete reference
05:30:06 <Kaidelong> but it isn't that either
05:30:13 <d3lxa> Kaidelong: the book is available on the website, anyone can try it to see
05:30:15 <bernalex> timthelion: me too, really
05:30:24 <d3lxa> you paid for what you see, that's all transparency
05:41:30 <randomclown> @pl \acc x -> f . f $ acc <> x
05:41:30 <lambdabot> ((f . f) .) . (<>)
05:42:55 <quchen> Weeee new Haskell Cast
05:44:26 <Fuuzetsu> who's on it?
05:46:05 <bennofs> Fuuzetsu: Brent Yorgey
05:46:45 <quchen> Fuuzetsu: http://www.haskellcast.com/episode/005-brent-yorgey-on-diagrams-and-the-typeclassopedia/
05:46:55 <quchen> "on Diagrams and Typeclassopedia"
05:47:01 <quchen> With video! :-)
05:47:26 <allsystemsarego> @src unfoldr
05:47:27 <lambdabot> unfoldr f b  = case f b of
05:47:27 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
05:47:27 <lambdabot>    Nothing        -> []
05:47:47 <Fuuzetsu> ah, byorgey
05:50:08 <sdegutis> Just wrote my first function this morning.
05:50:16 <sdegutis> doubleMe x = x * x
05:50:25 <sdegutis> It wasn't the correct algorithm, but that's okay.
05:50:44 <mr-> Yeah.. that's quite misleading :-)
05:51:57 <quchen> Depending on what (*) is in scope. import Prelude hiding ((*)); import Prelude as P; (*) = Prelude.(+)
05:52:13 <quchen> <evil laughter>
05:52:42 <rawtass> Kaidelong: yes, worked.. thanks
05:52:48 <sdegutis> quchen: I now hate Haskell.
05:52:49 <rawtass> sorry.. :)
05:54:49 <Kaidelong> sdegutis: at least that gets confined to a single module, in ancient LISP variants you could often actually redefine it for all the code currently loaded
05:55:04 <sdegutis> Kaidelong: and in current Ruby :'(
05:56:32 <quchen> sdegutis: It's a good thing you can generally do this, but it's a very bad thing to do it without good reason.
05:56:54 <keep_learning> Hello All
05:56:56 <quchen> If you want to hate some more though, https://github.com/quchen/articles/blob/master/unmaintainable_haskell.md
05:57:36 <keep_learning> I am reading monadic parsing ( http://www.cs.nott.ac.uk/~gmh/pearl.pdf  ) and tried the initial code
05:57:43 <keep_learning> but getting some error
05:57:53 <keep_learning> http://lpaste.net/98986
05:58:58 <quchen> keep_learning: `c :: cs` looks wrong. You probably mean `c : cs`.
05:59:12 <quchen> :: is "as type". : is "prepend to list".
05:59:15 <quchen> aka "cons"
05:59:30 <keep_learning> quchen: Oh
05:59:38 <quchen> Coming from Elm? :-)
06:00:04 <keep_learning> looks like  I need some rest
06:00:20 <keep_learning> quchen: Probably because of Idris
06:00:32 <quchen> It even tells you "Actual type: cs", which is precisely because you said "c as type cs"
06:01:26 <bezirg> how can I use qualified infix operators? Probably with some language extension?
06:01:44 <keep_learning> quchen: yeah Now it's very clear   Actual type: cs
06:01:50 <quchen> bezirg: Prelude.(+)
06:02:01 <quchen> Or is it (Prelude.+)
06:02:04 <quchen> One of those.
06:02:14 <quchen> (No extension necessary)
06:02:17 <bezirg> I am using generated haskell-src-exts code
06:02:30 <bezirg> and it generated x `Prelude.+` 4
06:02:37 <bezirg> which is not allowed
06:02:41 <quchen> That is correct.
06:02:44 <bezirg> and I thought I need an extension to enable it
06:03:03 <quchen> I don't think there is one that makes that legal syntax.
06:03:18 <quchen> Looks more like a bug.
06:03:40 <bezirg> according to haskell-src-exts this is ok syntax (maybe after enabling an extension?)
06:04:42 <bezirg> I am using http://hackage.haskell.org/package/haskell-src-exts-1.14.0/docs/Language-Haskell-Exts-Syntax.html#t:QOp
06:05:01 <bezirg> data QOp Source : Possibly qualified infix operators (qop), appearing in expressions.
06:08:13 <quchen> Hmm, qop should include all qualified operators, i.e. `infix` and (+).
06:09:46 <bennofs> Can hoogle be configured to link to the local docs when using hoogle server?
06:10:20 <bezirg> quchen: so should I file it as a bug to haskell-src-exts?
06:10:35 <timthelion> Does anyone know of any good resources on testing IO?  I've found pleanty of stuff about testing pure code :) but IO seems to evade my google-fu
06:10:57 <quchen> bezirg: Maybe I'm overlooking something. But right now I'd say it's a bug.
06:11:09 <bezirg> quchen: ok thx!
06:11:45 <randomclown> how do I run multiple test suites?
06:11:58 <quchen> randomclown: Have a look at Tasty
06:12:00 <randomclown> in the .cabal file should I include more test suit blocks?
06:12:04 <quchen> @hackage tasty
06:12:05 <lambdabot> http://hackage.haskell.org/package/tasty
06:12:47 <quchen> Well those docs are useless. Maybe the Github readme is better. https://github.com/feuerbach/tasty
06:13:09 <quchen> The bottom lists a couple of related blog posts that should get you started.
06:13:26 <bernalex> what's a lazy/efficient way of reading the N last lines of a big file?
06:13:38 <randomclown> quchen: cool, thanks
06:13:40 <quchen> timthelion: You might also want to have a look at the Tasty blog posts mentioned in the readme :-)
06:14:10 <quchen> I've recently seen one in /r/haskell that deals specifically with ressource-allocating tests
06:16:04 <timthelion> quchen: I've read a few posts on the topic already.  But the solutions I have seen are all horribly ugly!
06:17:42 <bezirg> quchen: I was actually wrong. I used (Ident "+") instead of (Symbol "+"). Now it works, generating x Prelude.+ 4
06:18:39 <quchen> :-)
06:20:29 <quchen> But still, the module should never create `Foo.(+)`. It's incorrect, and could probably be avoided (smart constructors for example)
06:21:05 <bernalex> hm. what's a neat way to get last N lines of a String?
06:21:43 <quchen> I don't know of a neat way.
06:22:36 <quchen> Split in lines, take the last N.
06:22:49 <bernalex> my current solution is not very "neat". I do (reverse . unlines . take 5) $ lines (reverse a)
06:23:22 <bernalex> taken from ghci, hence the inconsistency and bad name for the string :-P
06:25:16 <mr-> reverse is "bad". But doing the extra-work of reversing the list of characters is extrabad
06:25:36 <bernalex> ya
06:26:08 <companion_cube> you should reverse after you apply "lines"
06:26:24 <bernalex> my other "solution" is let f xs = if length xs > 5 then f (init xs) else x
06:26:37 <bernalex> where 5 could be an arg, of course
06:26:47 <bernalex> but that's badddd too
06:26:58 <bernalex> because if my string is 10K lines... yeah.
06:27:05 <companion_cube> unlines . reverse . take 5 . lines $ a
06:27:18 <companion_cube> I forgot a "reverse"
06:27:32 <bernalex> ya
06:27:52 <bernalex> unlines . reverse . take 5 . reverse . lines $ a
06:27:52 <companion_cube> unlines . (\l -> drop (length l - 5)) . lines $ a
06:27:56 <companion_cube> that looks less stupid
06:28:06 <bernalex> but is any of this not horribly inefficient?
06:28:15 <bernalex> imagine the string is /var/log/messages
06:28:20 <companion_cube> you traverse the list twice, once to compute its length, then once to drop almost all lines but the last five
06:28:47 <companion_cube> > unlines . (\l -> drop (length l - 2) l) . lines $ "a\nb\nc\nd\ne\nf"
06:28:48 <lambdabot>  "e\nf\n"
06:29:44 <bernalex> and how does that fare on a 10K lines string?
06:30:00 <bernalex> well, not maybe string as in String, but... text of some sort.
06:30:19 <companion_cube> I don't know, you have to benchmark
06:30:36 <companion_cube> the first thing is not to use String, but ByteString or something like this
06:30:48 <bernalex> yeh
06:30:52 <companion_cube> but notice the solution only allocates one list
06:31:06 <bernalex> actually, I am reading this from file, so I need to figure out a smart way to read the file contents without blomwing up stuff as well.
06:32:45 <quchen> > let zipOverflow (x:xs) (y:ys) = zipOverflow xs ys; zipOverflow [] ys = ys; zipOverflow xs [] = xs; lastN n xs = zipOverflow xs (drop n xs) in lastN 5 [1..1000] -- bernalex: look mom, one traversal
06:32:47 <lambdabot>  [996,997,998,999,1000]
06:33:10 <bernalex> quchen: my head hurts from the lack of \ns
06:33:37 <quchen> bernalex: http://lpaste.net/98988
06:33:39 <bernalex> quchen: that's actually basically my initial hunch. I find that elegant, but was unsure about the efficiency. thanks.
06:34:03 <bernalex> maybe I'll just go with it, and try to benchmark it. it looks nice, and look is my primary concern atm.
06:34:27 <quchen> Performance should be better than the other version.
06:34:30 <randomclown> quchen: with tasty, how come I can't get colourful console output
06:34:35 <randomclown> with cabal test
06:34:44 <quchen> No idea.
06:34:56 <quchen> Maybe Tasty needs a special flag for colour output.
06:36:05 <bernalex> quchen: why the name zipOverflow? is this a common naming?
06:36:32 <quchen> zipOverflow is the part of the list that is ignored when zipping finishes.
06:36:54 <quchen> zip [1,2,3] [1..10] discards the [4..10] part of the second list.
06:36:59 <quchen> That's what zipOverflow gives you.
06:37:35 <quchen> And I just made the name up, I don't know of a standard function that does this
06:38:54 <bernalex> quchen: yes, I did the function in my head and then on paper, so I understand what it does. thanks.
06:39:09 <bernalex> quchen: why the third line though? why not zipOverflow xs [] = []?
06:39:28 <bernalex> oh right, never mind
06:39:29 <quchen> zipOverflow [1] [] = ?
06:39:40 <bernalex> I forgot to brain. :-P
06:41:36 <int-e> L8D: Sorry, but "fix it!" is not helpful.
06:45:42 <int-e> L8D: In any case, as far as I can see, there was nothing wrong. 'f' in lambdabot is polymorphic. The usual trick to get '> f a' to work is to provide a type: '> f a :: Expr'
06:46:30 <qrada> is it possible to rename >>= to | .. can't get it to work
06:46:46 <qrada> or would i have to define it for all 'instance types'
06:46:59 <Kaidelong> you could just define
06:47:09 <qrada> hm.. im in ghci, it keeps barking
06:47:26 <quchen> qrada: You can do that renaming, but you should definitely not do that.
06:47:37 <quchen> It's equivalent to renaming (+) to (*..+).
06:48:11 <Kaidelong> (|) = (>>=), in GHCi it might be harder, mm
06:48:11 <quchen> Oh, and if you want to rename to "|" you actually can't do that because | is reseved.
06:48:13 <qrada> i did , cat = readFile, now i want to do >>= = | so i can do: cat "bleh" | return . reverse
06:48:16 <qrada> etc
06:48:17 <Kaidelong> oh?
06:48:19 <qrada> :F
06:48:22 <Kaidelong> nm then
06:48:22 <qrada> ah
06:48:46 <qrada> if i hid | from prelude, then maybe i could do it?
06:49:07 <qrada> ya iguess not
06:49:20 <bergmark> | is not an identifier
06:49:26 <joeyh> wonder if rebindable syntax could be extended to allow |
06:49:33 <quchen> reservedop = .. | : | :: | = | \ | | | <- | -> | @ |  ̃ | =>
06:49:43 <qrada> oo
06:49:53 <quchen> No, RebindableSyntax allows you to rebind syntax. You can't make non-syntax syntax with it.
06:51:54 <quchen> You can use CPP to translate >>= to |.
06:52:02 <quchen> Which is as awful of an idea as it sounds.
06:53:29 <qrada> cpp, c preprocessor? ya it's an awful idea but fun while im in ghci playing around.
06:56:37 <quchen> It's an awful idea in general to rename >>=.
07:00:37 <Cale> The problem with using | is what to do with the syntax in the language where | appears (guards, list comprehensions)
07:02:07 <qrada>         cat "/etc/motd" >>= (>) "/tmp/oogg"
07:02:07 <qrada>         cat "/etc/motd" >>= (>>) "/tmp/oogg"
07:02:13 <qrada> let (>) = writeFile
07:02:29 <qrada> so ya im just wondering how i can make my 'syntax' look even MORE unixlike
07:02:35 <qrada> that's why i was wondering about
07:02:36 <qrada> |
07:05:09 <d3lxa> what's the difference between Void and () ?
07:06:21 <t7> () has a value
07:06:27 <t7> there is no value of the type Void
07:06:41 <t7> its like false
07:07:02 <sdegutis> What is ()?
07:07:02 <d3lxa> so Void is like Bottom for subtyping system?
07:07:14 <t7> @type ()
07:07:18 <lambdabot> ()
07:07:21 <t7> () :: ()
07:07:26 <sdegutis> Uhh
07:07:31 <sdegutis> Okay.
07:07:40 <t7> a 'unit type'
07:07:42 <simpson> sdegutis: It's a tuple with zero items.
07:07:44 <t7> has a single value
07:07:45 <sdegutis> Oh.
07:08:49 <t7> @type undefined :: Void
07:08:50 <lambdabot> Not in scope: type constructor or class `Void'
07:09:01 <d3lxa> t7: is my statement true? thank you :)
07:09:42 <t7> i think bottom is a non terminating value, so it can have any type
07:15:02 * hackagebot webdriver 0.5.3 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.5.3 (AdamCurtis)
07:25:02 * hackagebot atomic-primops 0.5 - A safe approach to CAS and other atomic ops in Haskell.  http://hackage.haskell.org/package/atomic-primops-0.5 (RyanNewton)
07:27:07 <zipper> @seen ski
07:27:08 <lambdabot> $KI
07:27:20 <zipper> !seen ski
07:27:26 <quchen> preflex: seen ski
07:27:32 <merijn> lambdabot doesn't have a seen command, it just autocorrects to @leet :p
07:27:41 <merijn> Preflex is not online
07:27:42 <quchen> And Preflex isn't here.
07:27:47 <zipper> :(
07:32:45 <keep_learning> Hello all
07:33:03 <keep_learning> I am trying to make the parser as instance of Monad ( http://lpaste.net/98990 )
07:33:09 <keep_learning> but getting error.
07:33:34 <keep_learning> Could some one please  tell me what is wrong with this code
07:34:05 <Iceland_jack> keep_learning: cs is not in scope
07:34:29 <Iceland_jack> You should use a let
07:40:10 <keep_learning> Iceland_jack: thank you
07:40:37 <ski> @unseen ski
07:40:37 <lambdabot> Unknown command, try @list
07:41:01 <quchen> ski was last seen on #haskell 1 minute ago, producing a syntax error
07:41:02 * ski zips the zipper
07:42:13 <klrr_> i get a really strange syntax error , anyone can help me out find the cause? http://lpaste.net/98991 the error is "src/Tob/Network.hs:29:9: parse error on input `t'
07:42:16 <klrr_> "
07:43:34 <ski> klrr_ : indent that block three or more spaces ?
07:43:36 <quchen> klrr_: Try indenting the block a bit more
07:43:54 <quchen> Also,  unless p x = if p then return () else x
07:43:55 <ski> (or break the line after the `where')
07:44:15 <geekosaur> ghc relaxes indentation a bit after "do", but not *that* much; your "t" doesn't clear the "where" and therefore terminates it
07:44:33 <klrr_> ski quchen thanks!
07:49:21 <tdammers> and that's why I think syntax is one of the uglier parts of Haskell
07:50:23 <ski> klrr_ : are you missing a `h' `Handler' argument to `connHandler' ?
07:51:42 <klrr_> aa its in the reader monad just forgot to ask for it xD thanks for poitning out!
07:52:03 <ski> so should the recursive call `connHandler h f' really be `connHandler f' ?
07:52:13 <skypers> something I don’t understand
07:52:28 <skypers> why isn’t unlines implemented with intercalate newline?
07:52:39 <skypers> it’s so annoying it adds an extra \n at the end of the list
07:53:01 <klrr_> ski: yes
07:53:42 <ski> i think often it's considered that the last line should be "proper", meaning ending with a newline as well
07:53:57 <skypers> ?
07:53:59 <geekosaur> (a) intercalate didn't exist back then (b) unix tends to assume that all lines END with a newline, not that lines are SEPARATED BY newlines
07:54:03 <skypers> I don’t think so
07:54:09 <skypers> yeah
07:54:10 <skypers> unix.
07:54:16 <ski> klrr_ : should it ask for `h' once, or reask on each recursive call ?
07:54:19 <skypers> since when do we code for only one platform?
07:54:36 <geekosaur> (GNU stuff will usually do something vaguely sensible with the latter, but it's not something you should rely on. also this gets into how tty drivers and prompts behave...)
07:54:36 <klrr_> it will re-ask on each call
07:54:56 <skypers> I see geekosaur
07:54:57 <klrr_> will it be more optimazed to have it pass as an arg in a recursive sub-function instead?
07:55:02 <skypers> @index newline
07:55:02 <lambdabot> Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec
07:55:06 <skypers> dammit
07:55:19 <klrr_> (sry for saying sub-function but i mean a "where function"
07:55:34 <geekosaur> in particular zsh will detect that output ended in the middle of the line and drop a turd and go to the next line, but most other shells will just drop the prompt right there
07:55:48 <ski> klrr_ : well, .. i suppose it can't change between recursive calls
07:56:01 <lingxiao> hey guys
07:56:04 <ski> (since the recursive calls aren't wrapped in anything which might contain `local')
07:56:17 <skypers> yeah geekosaur
07:56:19 <klrr_> ski: you mean it's better or OK to re-ask?
07:56:20 <skypers> I know that
07:56:31 <skypers> the fact is I don’t expect unlines to follow that
07:57:03 <lingxiao> I  hate to ask these kind of questions on this channel, but how did you guys install agda?
07:57:12 <merijn> klrr_: A more common term would be a "local function", as in a function definition that is "local" to another function definition
07:57:16 <lingxiao> I just did "cabal install agda" and am getting ExitFailure 11
07:57:50 <merijn> lingxiao: Try again with -v3 for better error reporting
07:58:14 <klrr_> merijn: aa that it is, thanks
07:58:38 <ski>   connHandler :: (Message -> BotM ()) -> BotM ()
07:58:47 <ski>   connHandler f = do
07:58:59 <ski>     h <- asks socket
07:59:15 <ski>     unless (liftIO (isEOF h)) $ do
07:59:24 <ski>       t <- T.hGetLine h
07:59:36 <ski>       mapM_ f (parseIRC t)
07:59:41 <ski>       connHandler f
07:59:47 <ski> klrr_ : something like that ^ ?
08:00:05 * hackagebot fpco-api 1.1.0 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.1.0 (ChrisDone)
08:00:13 <ski> btw, note
08:00:23 <ski> @type Data.Traversable.mapM :: (a -> IO b) -> (Maybe a -> IO (Maybe b))
08:00:26 <Cale> lingxiao: You might also try to get help in #agda, but it's hard to know what's going wrong from just that...
08:00:27 <lambdabot> (a -> IO b) -> Maybe a -> IO (Maybe b)
08:00:28 <ski> @type Data.Foldable.mapM_ :: (a -> IO b) -> (Maybe a -> IO ())
08:00:29 <lambdabot> (a -> IO b) -> Maybe a -> IO ()
08:01:04 <ski> klrr_ : the `mapM_' above is from `Data.Foldable', and either calls `f' once or not at all, on the possible contents of the `Maybe'
08:01:44 <lingxiao> ok thanks merijn and Cale
08:02:10 <klrr_> ski: that's actually almost axectly how i rewrote it before when suggesting unless :p except mapM_, thanks!
08:02:27 <remdezx> merijn: I tried mueval due as you suggested and hint (mueval is based on hint), but I can't find a way to construct a module. I mean add / remove functions and classes. Is it possible with hint?
08:03:00 <ski> if you prefer, you could use `forM_' instead
08:04:07 <ocharles> How can I supply a test option in cabal for a single test suite?
08:04:09 <ocharles> Can that be done?
08:04:24 <ocharles> cabal test --test-option='--xml=junit.xml' passes that to my hlint test suite, which isn't what I want
08:04:40 <dcoutts> ocharles: you can name the target on the command line
08:04:44 <dcoutts> ie the testsuite name
08:05:29 <ocharles> dcoutts: ok, so I should run each test suite independently then I think
08:05:34 <ocharles> (I'm setting up a script for jenkins to run
08:05:55 <dcoutts> ocharles: yes, there isn't a system to pass different options to different testsuites all in one batch
08:06:05 <ocharles> ok, no problem
08:06:06 <ocharles> thanks!
08:12:33 <remdezx> Is there anyone good at ghci related topics? I would like to build something similiar to ghci, is there any good librarary to do this? (except ghc api) I tried with mueval and hint, but there (as far as I know) is no possibility to add interactively new functions etc.
08:17:44 <merijn> remdezx: It depends what you want to do, there's not really a simple way to do this
08:19:07 <remdezx> merijn: I want to create modules, update them and execute them
08:20:02 <remdezx> I assume there is no better way than with GHC API, am I right?
08:21:20 <merijn> remdezx: Probably, and even then it might be tricky
08:21:27 <merijn> remdezx: What do you plan to use this for?
08:21:31 <kallisti> are there currently any XPath parse tree / ADT data types out there?
08:23:05 <remdezx> merijn: I'm working on a DSL which compiles to haskell. And I need to create an interpreter for it.
08:23:44 <merijn> remdezx: That's going to require a fair bit of work, tbh
08:24:08 <remdezx> merijn: I know
08:25:41 <remdezx> merijn: I found something like this, http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/InteractiveEval.html maybe it will be good point to start
08:29:48 <ocharles> Any idea what would cause: hlint: src/Metronome/SocketIO.hs: hGetContents: invalid argument (invalid byte sequence) ?
08:29:52 <ocharles> If I run in a slightly different environment the test passes
08:29:58 <ocharles> Comparing `locale` output between sessions they seem to be the same (at least when I run with LANG=en_GB.UTF-8)
08:30:01 <ocharles> The broken environment does normally report LANG=POSIX for `locale`
08:30:48 <danilo2> merijn: But GHCi allows for something like that - you can for example write "let f x = x" and this f would be available for later use - remdezx is talking about simmilar functionality as far as I know
08:31:04 <remdezx> right
08:31:17 <sdegutis> How does GHCi manage to be an interpreter and a compiler at the same time?
08:31:26 <merijn> sdegutis: ghci isn't a compiler
08:31:28 <sdegutis> Is it just compiling code to native and then running it in-process?
08:31:29 <sdegutis> Oh.
08:31:39 <merijn> sdegutis: Or maybe it is, depending on your point of view
08:31:49 <merijn> sdegutis: ghci compiles to bytecode and then runs a bytecode interpreter
08:31:52 <sdegutis> I'm asking about the implementation. :)
08:31:55 <sdegutis> Oh.
08:31:55 <merijn> Same goes for runhaskell
08:32:02 <sdegutis> Neat.
08:32:16 <sdegutis> I assume it omits optimizations that GHC does?
08:32:23 <merijn> sdegutis: Yeah
08:32:40 <qrada> i just find this so much fun: tail -n 2 /etc/hosts -> cat "/etc/hosts" >>= return . unlines . take 2 . reverse . lines >>= (>) "/tmp/poop"
08:32:42 <merijn> Not sure whether those can be turned on when you use commandline flags
08:32:43 <qrada> euuugh!@#@
08:32:49 <danilo2> sdegutis, merijn: Ghci is able to keep the state - between different user inputs (like function definitions or classes ) - how is this implemented? Can we achive simmilar resutls with any library or there is some fancy functions in GHC PAI somwhere and we cannot find them ? :)
08:33:19 <merijn> qrada: Since (.) composes the other direction from >>= you may wanna use =<< ?
08:33:30 <qrada> ya i hae some =<< variations too
08:33:58 <qrada> but i had to define =<< .. let f =<< x = x >>= f... why did i have to define it? thought it was apart of control.monad etc?
08:33:59 <merijn> danilo2: I'm not too familiar with ghci internals, so it's hard to say how easy that will be too mimic for you
08:34:14 <merijn> It is part of Control.Monad ...
08:34:18 <merijn> :t (=<<)
08:34:19 <lambdabot> Monad m => (a -> m b) -> m a -> m b
08:34:32 <merijn> It should "Just Work"
08:34:42 <qrada> ya it didnt though.. odd.. let me restart ghci
08:34:48 <danilo2> merijn: Thank you. Could you maybe recommand anyone here I can "catch and ask about it" ? :) We would be very thankful! :)
08:34:49 <merijn> qrada: Did you import Control.Monad?
08:34:55 <merijn> qrada: It may not be in Prelude?
08:35:14 <merijn> qrada: Nope, it's even in Prelude for me
08:35:34 <qrada> ok i guess it did... odd
08:35:41 <qrada> obviously something i did
08:35:42 <qrada> hehe
08:35:43 <merijn> danilo2: tbh, best approach might be studying the ghci source and if you have questions ask here
08:38:00 <ckoch786> what is the : operator in the sum' function here http://learnyouahaskell.com/syntax-in-functions
08:38:29 <ckoch786> can someone explain how they are using it to separate the head from the tail of a list
08:38:31 <ckoch786> ?
08:38:45 <merijn> ckoch786: It's not an operator
08:38:54 <merijn> ckoch786: : is one of the list constructors
08:39:01 <merijn> ckoch786: So they are pattern matching on it
08:39:20 <ski> well, it is an operator
08:39:28 <ski> it just happens to also be a data constructor
08:39:37 <merijn> ski: Pfft :p
08:39:38 <ckoch786> merijn, right it is cons but I do not understand how they are using it to perform the match
08:39:58 <Flonk> lahwran: Oh hey, you're hanging out in #haskell aswell?
08:39:59 <ski> ckoch786 : did you follow `tell' ?
08:40:31 <merijn> ckoch786: Better yet, did you understand the very first function where it matched different numbers?
08:40:39 <merijn> i.e. "sayMe"
08:40:43 <ckoch786> ski, yes but it is just as confusing... one sec I am going to cook up another example I think I understand itnow
08:40:54 <ckoch786> merijn, yes
08:41:07 <qrada> i guess to add to ckoch786's question.. why is it (x:xs) and not [x:xs] etc
08:41:07 <merijn> ckoch786: Haskell can match not only numbers, but arbitrary data constructors
08:41:21 <qrada> i just blindly use (x:xs) but i dont understand the parens vs brackets
08:41:22 <ckoch786> merijn, but that example was using , to seperate the params
08:41:33 <qrada> intuitively i'd imagine [x:xs]..
08:41:43 <ski> well, first you should know that e.g. the list `[2,3,5]' is really syntactic sugar for `2:3:5:[]' (meaning `2:(3:(5:[]))')
08:41:46 <qrada> or is that just ghc internals
08:42:04 <qrada> ah..
08:42:11 <merijn> ckoch786: What is a bit confusing is that there are 2 notations for lists
08:42:13 <ski> qrada : `x:xs' is the list that has `x' as first element, and where all the rest of the elements are the elements of the list `xs'
08:42:22 <qrada> right but now it makes more sense
08:42:24 <ckoch786> ski, looking at tell again now it makes since
08:42:26 <ski> in short, `x:xs' is "adding `x' in front of `xs'
08:42:29 <merijn> qrada: The [a,b,c] notation is just to read nicer than that "a:b:c:[]" notation
08:42:36 <ktos> Hi
08:42:42 <qrada> x:(y:(z:[])))
08:43:08 <ckoch786> s/since/sense
08:43:27 <merijn> qrada: Right
08:43:47 <danilo2> merijn: Ok, thank you :) We will do it as you tell - learning GHC API will be fun :D
08:44:00 <qrada> is there a way to pattern match using x:(xs:([])) etc ? crious
08:44:01 <ski> qrada : the brackets aren't really related to the list. they're just needed because otherwise `foo x:xs = ..x..xs..' will be read as `(foo x):xs = ..x..xs..', which is not what you intended
08:44:12 <qrada> let f x:(xs:([])) = do print x
08:44:15 <qrada> or something
08:44:23 <merijn> qrada: The pattern will work, but 'xs' is just a single item there
08:44:23 <qrada> thanks ski
08:44:26 <ktos> tell me please, what is the name haskell's feature where I can define for example my USD type as for example Double
08:44:29 <ski> qrada : yes, that's the same as pattern-matching on `x:xs:[]' (note that both `x' and `xs' will be elements of the same list)
08:44:45 <ski> qrada : `f (x:(xs:([]))) = do print x'
08:44:47 <merijn> > let f (x:(xs:[])) = show x in f [1,2]
08:44:49 <lambdabot>  "1"
08:44:52 <merijn> > let f (x:(xs:[])) = show x in f [1,2,3]
08:44:53 <lambdabot>  "*Exception: <interactive>:3:5-26: Non-exhaustive patterns in function f
08:45:00 <merijn> > let f (x:(xs:[])) = show xs in f [1,2]
08:45:01 <lambdabot>  "2"
08:45:39 <merijn> qrada: Each : only removes one item, so "x:(xs:[])" is an item 'x' followed by a list consisting of an item 'xs' and the empty list
08:45:50 <ski> ckoch786 : `x' and `xs' will be matched on the actual first element, and list of rest of the elements that are passed in
08:45:53 <qrada> ya, i was getting non exhaustive.. playing with it
08:45:59 <merijn> qrada: Which can also be written as 'x:xs:[]'
08:46:21 <ski> > let x:xs:[] = [220,284] in (x,xs)
08:46:22 <lambdabot>  (220,284)
08:46:24 <merijn> qrada: Which is a bit evil, as xs usually refers to a list (i.e. the tail bit) instead of a single element
08:46:49 <merijn> qrada: Since one item, multiple itemS -> one x, multiple xS
08:47:34 <ski> `banana:bananas'
08:47:57 <Cale> (banana for scale)
08:48:20 <qrada> i keep getting non exhaustive.. shouldn't this work: let f (x:(xs:[])) = x
08:48:22 <merijn> Anyone here know of a Hakyll library to generate a page from a BibTeX file?
08:48:44 <merijn> qrada: non-exhaustive means "there are possible patterns that can't be matched"
08:48:55 <ski> qrada : that only works for input lists which have exactly two elements (here named `x' and `xs')
08:49:01 <merijn> qrada: In your case the empty list, 1 element list and lists of more than 2 elements can't be matched
08:49:02 <qrada> ahh
08:49:23 <ski> qrada : if you also want to handle other lists, add additionally defining equations for `f', matching those cases
08:49:40 <merijn> ktos: Defining any sort of money as Double is a crime that makes baby jesus cry
08:49:46 <qrada> gotcha, thanks
08:50:04 <merijn> ktos: Please don't *ever* even consider doing that or I will hunt you down and make you maintain PHP code for life
08:50:28 <merijn> ktos: Instead look at Data.Fixed
08:50:33 <qrada> ooooh php code, that 1min 30sec recursive fib of 40
08:51:08 <kdridi> hello
08:51:26 <merijn> @quote quicksilver mantissa
08:51:26 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he will stab you in the back with a mantissa
08:51:45 <Flonk> merijn: shh, don't talk about php. If we don't talk about it, maybe it will go away.
08:51:49 <qrada> ok so i basically should have been doing: let f (x:(xs)) = x ... to match x on lists of 'any size' other than empty list []
08:51:52 <qrada> cool
08:52:09 <ktos> merijn: I just gave an example, I don't want to do this
08:52:11 <ski> qrada : yes, or more simply `f (x:xs) = ...'
08:52:14 <ktos> merijn: I want to read about the feature
08:52:26 <ktos> merijn: my friend told me about and want to check it
08:52:28 <qrada> someone i work with, i was showing haskell to.. and he asked me why it's (x:xs) and not [x:xs], and i didnt have an answer.. now i do tho
08:52:29 <merijn> qrada: It will match one : plus an arbitrary list, where the arbitrary list 'xs' can be either empty or another longer list
08:52:31 <qrada> bang
08:52:33 * ski stares at kdridi
08:52:36 <merijn> ktos: type and/or newtype
08:52:53 <merijn> ktos: type defines a synonym (i.e. String vs [Char]) and you can pass one to the other
08:53:01 <bennofs> Is there a way to take the first n elements from a Set?
08:53:07 <kdridi> i'm trying to use hoauth2 in an yesod project. However the hell dependencies make it impossible. Is there any way to configure a git submodule project in cabal?
08:53:11 <merijn> ktos: newtype creates a "fake" type, which means that passing Int to Dollar would be a type error
08:53:20 <ski> bennofs : sets have no inherent ordering of elements
08:53:20 <bennofs> Or at least only get the 2 elements from a Set (without traversing the whole Set) ?
08:53:28 <ktos> merijn: is it different from C typedef?
08:53:30 <bennofs> ski: I don't care which elements I get
08:53:34 <simpson> bennofs: WRT the Ord instance on the type, right?
08:53:37 <ski> @type S.toList
08:53:37 <merijn> ktos: type is like a C typedef
08:53:38 <lambdabot> S.Set a -> [a]
08:53:39 <bennofs> ski: I only need 2
08:53:41 <merijn> ktos: newtype is not
08:53:46 <bennofs> ski: won't that traverse the whole Set?
08:53:46 <ski> @type take 2 . S.toList
08:53:47 <lambdabot> S.Set a -> [a]
08:53:59 <qrada> i work with primarily php and nodejs devs.. 2 out of ~20 are interested in haskell now
08:54:05 <simpson> bennofs: No, it'll only traverse the left-most branches.
08:54:13 <qrada> the qsort one liner, and then the par version of qsort did it
08:54:17 <ktos> merijn: http://www.haskell.org/haskellwiki/Newtype is it that? :)
08:54:21 <ski> bennofs : probably not with `toList' (as opposed to `toAscList' or `toDescList')
08:54:34 <bennofs> ski: toList = toAscList :O
08:54:38 <ski> bennofs : however, you should only use `toList' if you don't care about the order you get the elements in
08:54:40 <merijn> ktos: You can use both the typedef name and the original type with a typedef, with newtype you can only use the new one and need to explicitly "convert" to the new type (which is a no-op at runtime, it only is for typechecking)
08:54:50 <ski> bennofs : that's an implementation detail which you shouldn't rely on
08:54:59 <merijn> ktos: Yes
08:54:59 <simpson> bennofs: What are you building, BTW?
08:55:26 <merijn> qrada: I dislike the qsort one line, it's pretty bad performance wise
08:55:35 <merijn> qrada: Merge sort is a much nicer functional sort
08:55:39 <ktos> merijn: great, thank you for comprehensive explanation, maybe I will learn haskell because of that feature :)
08:56:15 <bennofs> simpson: It's for an AI for a game. There a rows of stones, either of the same color or the same symbol. To get the possible stones, I need to get two stones (or less, if there aren't two stones) and check what they have in common
08:56:30 <qrada> merijn: ya it's bad performance but it's sexy
08:58:47 <merijn> qrada: For node.js devs a better argument would be "No more silly callback spaghetti!"
08:59:23 <ski> composable continuations ftw ?
09:01:04 <qrada> merijn: that's why i stopped coding in node.. i loved it for a while.. but i had a few debugging sessions that were absolute hell
09:01:31 <qrada> i like compiled and functional langs better anyway.. so i go "from" C -> node -> go -> haskell
09:01:57 <qrada> interested in rust and erlang too but once i started learning haskell i havnt coded in anything else
09:02:00 <qrada> hehe
09:03:28 <bjz> qrada: only so much you can do at once
09:04:05 <Flonk> merijn, qrada: There's plenty of little librarys around that implement promises, which reduce the callback nesting madness down to a minimum
09:04:09 <Flonk> which is really nice
09:05:27 <qrada> ya flonk
09:05:42 <qrada> promises and async library helped me alot
09:08:59 <bernalex> quchen: so with zipOverflow -- what exactly is evaluated? is xs traversed only one time? i.e. what are the implications of drop n xs?
09:09:28 <merijn> Flonk: Or I could just keep writing/using nice synchronous threaded code :)
09:09:51 <qrada> ya that's why i liked go's approach
09:09:55 <qrada> go routines
09:11:08 <qrada> haskell is similar no, just thread $ body ... use MVar's/Chan's to communicate
09:11:09 <qrada> ?
09:11:19 <bernalex> quchen: i.e. recursing zipOverflow xs ys, is ys traversed as well? so for a 10M element list, where you want the last 10 elements, will this traverse a 10M list, and a 999990 long list?
09:11:23 <Flonk> merijn: Well, Haskell code is above everything else of course.
09:11:25 <qrada> pike references haskell/erlang in talks..
09:11:38 <bernalex> uhm 9999990 long
09:23:48 <merijn> qrada: Yeah, but Haskell also has STM :)
09:24:48 <qrada> ya ive yet to mess with stm in haskell
09:25:28 <merijn> qrada: The paper linked at the top of the Control.Concurrent.STM docs is a good intro, and of course Simon's book
09:26:54 <qrada> cool thanks
09:33:19 <Cale> qrada: Yeah, forkIO :: IO () -> IO ThreadId, is a function which is approximately equivalent to the 'go' keyword.
09:36:20 <qrada> cool
09:40:13 * hackagebot lvish 1.1.1.1 - Parallel scheduler, LVar data structures, and infrastructure to build more.  http://hackage.haskell.org/package/lvish-1.1.1.1 (RyanNewton)
09:41:17 <spintronic> wow so many haskell people!
09:41:27 <companion_cube> such crowd
09:41:55 <Redz> much people
09:42:12 <spintronic> haskell vs. j...go!
09:42:24 <companion_cube> amazing
09:42:43 <Redz> many haskell
09:42:53 <companion_cube> very typed
09:43:02 <jrmithdobbs> edwardk: where were you when i was looking for Functor f => (a, f b) -> f (a, b)
09:43:12 <jrmithdobbs> edwardk: lol, sequenceAOf _2
09:43:14 <Redz> so lazy
09:43:31 <jrmithdobbs> :t sequenceAOf _2
09:43:33 <lambdabot> (Functor f, Field2 s t (f b) b) => s -> f t
09:44:07 <jrmithdobbs> i knew there had to be a not ugly way of saying that!
09:44:09 <Redz> very save
09:44:23 <Redz> wow
09:44:41 <jovan> what's the topic?
09:45:13 * hackagebot lvish 1.1.1.2 - Parallel scheduler, LVar data structures, and infrastructure to build more.  http://hackage.haskell.org/package/lvish-1.1.1.2 (RyanNewton)
09:45:19 <supki> :t _2 id
09:45:20 <lambdabot> (Functor f, Field2 s t (f b) b) => s -> f t
09:45:22 <edwardk> :t _2 id
09:45:23 <lambdabot> (Functor f, Field2 s t (f b) b) => s -> f t
09:45:25 <edwardk> heh
09:45:27 <edwardk> supki++
09:45:36 <jrmithdobbs> even better, heh
09:45:56 <Redz> talking in doge slang is difficult.
09:46:23 <edwardk> wow. such slang. much hard
09:46:59 <jrmithdobbs> supki: you may have just made my head explode with that
09:47:00 <Redz> but maybe "many hard" sounds more like doge.
09:47:01 <edwardk> someone tweeted to remind me about http://cokmett.github.io/cokmett/ the other day
09:47:09 <jrmithdobbs> supki: but I see why it works
09:48:07 <merijn> edwardk: I love that site :)
09:48:49 <merijn> I liked Semirepresentableoid
09:49:30 <edwardk> merijn: it appears to be generated by some kind of markov chain
09:49:39 <merijn> ha
09:49:46 <merijn> I just saw Coarrowoid :p
09:51:36 <jrm2k6> Hi guys, newbie question http://lpaste.net/98993 how can i use it as an infix operator like True or' False
09:51:50 <Cale> `or'`
09:51:51 <edwardk> jrm2k6: True `or'` False
09:52:02 <jrm2k6> oh ok
09:52:09 <jrm2k6>  knew it was stupid :)
09:52:22 <edwardk> > True || False
09:52:23 <lambdabot>  True
09:52:49 <edwardk> it also comes baked in =)
09:53:04 <Redz> :t or
09:53:05 <lambdabot> [Bool] -> Bool
09:53:15 <Redz> :t (||)
09:53:16 <lambdabot> Bool -> Bool -> Bool
09:53:18 <Cale> fsvo baked -- it's a definition in the Prelude module.
09:57:11 <spintronic> so why are you guys into haskell?
09:57:46 <Maior> spintronic: I'm too dim for other languages
09:57:55 <spintronic> ha ha
09:57:58 <Maior> ?\
09:57:58 <lambdabot> Maybe you meant: v @ ? .
09:58:20 <hallettj> spintronic: I was telling someone yesterday that functional code is safer to refactor/maintain, and that Haskell's types add a layer of quality assurance.
09:58:46 <schell> spintronic: i feel that haskell's type system makes projects pretty rock solid
09:58:53 <Maior> spintronic: what they said
09:59:23 <Maior> pure functions and immutable objects mean I have to waste less time thinking hard about stuff
09:59:40 <schell> refactoring is easy and you can usually just start hacking, moving and changing things without having to load the whole system into your head
09:59:40 <Cale> spintronic: There are a lot of reasons, really, but yeah, like the others here, I'd say the type system is a big one. Spending a couple hours in a debugger tracking down a bug in another language which would have been a type error in Haskell is pretty frustrating.
09:59:49 <Cale> Being able to equationally reason about code.
09:59:57 <Maior> when a colleague tweaks the API on an internal library, I know about it
10:00:00 <Cale> That's pretty huge for being able to understand things.
10:00:00 <Maior> straight away
10:00:09 <schell> what they said
10:00:12 <Maior> because they've suddenly started returning a Maybe String instead of a String
10:00:25 <Cale> Knowing that when I test something in isolation, I have some amount of guarantee that it will work the same way in the real program.
10:00:28 <Maior> which we catch at compile time
10:01:03 <Maior> rather than "oh hey dude your code's spitting out NullPointerExceptions / NilErrors / etc. in production"
10:01:08 <Maior> ooh Red Gate
10:01:21 <oio_> how can i get editable input fields on the console?
10:01:38 <Cale> Being able to make a change to a basic data structure in a multi-thousand-line library and then run the compiler over things, fixing up hundreds of little things where it tells me to until the thing compiles again and then having it all work immediately once it compiles.
10:02:32 <Cale> Having a reasonably good story regarding both concurrency and parallelism.
10:02:37 <schell> hey guys, i'm thinking about a dream project (written in haskell) and in this project i'd like people to be able to write plugins in haskell. how can this be accomplished? is there a way to do that without having to recompile the project with every plugin?
10:03:04 <Cale> schell: Well, have a look at hint, which is a wrapper around the GHC API
10:03:36 <bennofs> schell: Why do you not want to recompile to project? You could provide it as a library, like xmonad and yi do
10:04:27 <schell> bennofs: i'd like to be able to ship binaries to people who don't want or have the ability or time to compile it
10:04:38 <schell> but who can still write plugins, ha
10:05:16 * hackagebot fpco-api 1.1.1 - Simple interface to the FP Complete IDE API.  http://hackage.haskell.org/package/fpco-api-1.1.1 (ChrisDone)
10:05:27 <sdegutis> I was excited to learn Haskell the other night. I don't know what happened to that excitement, but now I'm not sure it'll happen.
10:05:34 <bennofs> schell: you only ship the library and a default config, which recompiles the `runner` when the plugins changed? You won't need to recompile the library when plugins changed, only the small wrapper
10:06:27 <schell> ah - so it's a shared lib? or everything gets re-linked when plugins change?
10:07:35 <oio_> is there any way to get editable input fields on console?]
10:07:49 <oio_> wherever i hit delete it puts undesired symbols
10:07:51 <levi> sdegutis: Excitement is fleeting. Anything worth doing takes more than excitement to get you through it.
10:08:31 <ski> sdegutis : GHCi is also an interactor, which is different from being an interpreter
10:08:59 <sdegutis> Oh?
10:08:59 <ski> (interactor is also sometimes known as REPL, "Read-Eval-Print-Loop")
10:09:28 <sdegutis> Sometimes? REPL is practically the only term I've heard for it (until now).
10:09:31 <sdegutis> :P
10:09:52 <ski> it means that you interact with it, querying expressions and defining things, and getting responses back
10:09:56 <sdegutis> skypers: but it's also an interpreter
10:10:17 <lingxiao> does anyone know of some college course that uses Agda?
10:10:20 <ski> there are non-interactive (iow batch) interpreters, and interactive compilers
10:10:37 <sdegutis> I meant ski not skypers sorry.
10:10:40 <sdegutis> ski: Okay.
10:10:42 <sdegutis> Thanks.
10:10:57 <lingxiao> for example this course uses Coq:
10:10:58 <lingxiao> http://www.seas.upenn.edu/~cis500/current/index.html
10:11:06 <lingxiao> but someting that uses Agda would be ideal
10:11:58 <jrmithdobbs> how is this true? Could not deduce (Functor m) arising from a use of `_2' from the context (Monad m) bound by the type signature for <whatever> :: Monad m => (Text -> m Text) -> [Text] -> m [(Text,Text)]
10:12:12 <magneticduck> I need glut help guys, how do I get the size in pixels of the current window?
10:12:15 <levi> lingxiao: Ideal for what? Is your goal to learn Agda or to learn some other concept with Agda as a tool for doing it?
10:12:15 <jrmithdobbs> i mean obviously adding the Functor constraint fixes it but it should be able to deduce that shouldn't it?
10:12:44 <levi> jrmithdobbs: How would it deduce that?
10:13:16 <levi> Monad would have to imply Functor, and it does not (yet).
10:13:19 <magneticduck> any ideas guys?
10:13:27 <jrmithdobbs> i guess since monad doesn't have a functor constraint
10:13:28 <magneticduck> I'm stumped. No idea how I can get the current size
10:13:29 <schell> magneticduck: i'm not sure how to do it in glut but in glfw you register a callback
10:13:39 <schell> i recommend glfw-b
10:13:40 <jrmithdobbs> ya ok, nm, it should if the world were perfect but in the current world it doesn't ;p
10:13:51 <schell> magneticduck: you could also ask in #haskell-game
10:13:53 <magneticduck> shelf: yes I could always make callbacks, but isn't there a way of getting the current size without that stuff?
10:14:11 <jrmithdobbs> levi: it is so confusing that it doesn't
10:14:14 <jcristovao> jrmithdobbs: yep... histerical raisins
10:14:24 <schell> magneticduck: there is in glfw-b but i don't know about glut :(
10:14:55 <magneticduck> glfw-b eh
10:15:03 <syllogismos> diff :: Num a => (forall s. Mode s => AD s a -> AD s a) -> a -> a
10:15:06 <jcristovao> jrmithdobbs: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
10:15:14 <syllogismos> can some one explain this type signature?
10:15:31 <ski> edwardk perhaps ?
10:15:48 <edwardk> :t Numeric.AD.diff
10:15:51 <lambdabot> Couldn't find qualified module.
10:15:51 <ski> it's surely based on automatic differentiation
10:15:58 <edwardk> shucks its not imported any more
10:16:00 <syllogismos> yes it is
10:16:04 <edwardk> :t diff
10:16:05 <lambdabot>     Not in scope: `diff'
10:16:05 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
10:16:09 <edwardk> :t AD.diff
10:16:10 <lambdabot> Couldn't find qualified module.
10:16:19 <edwardk> oh you were replying to ski =)
10:16:30 <syllogismos> http://lpaste.net/98938
10:16:38 <syllogismos> can you help me with this edwardk
10:16:39 <levi> jrmithdobbs: I can see it being a little confusing if you're very familiar with the abstract concepts on their own, but it doesn't seem like it would be *so* confusing to a lot of people.
10:16:55 <InstaGrams5> Anybody like to play poker online? TRying to get players to sign up.100% match . i won 2,000 msg
10:17:05 <edwardk> anyways, my 'ad' package uses the 'Mode' parameter to both avoid 'infinitesimal confusion', and to quantify over if something is being computed in forward mode, reverse mode, a composition of modes, etc.
10:17:23 <edwardk> it provides a place i can hang all the metadata about the derivatives involved
10:17:26 <jrmithdobbs> levi: it is the moment you throw lens into the mix seeing as the rest of the error after that is type jargon not involving any of my code
10:17:49 <syllogismos> what are the requirements for the function.. im just not able to get my head around it..
10:17:51 <edwardk> diff says if you give it a function that can work for any AD variables, regardless of mode, I can tell you the derivative of the function
10:17:58 <edwardk> diff sin gives cos, etc.
10:18:03 <Maior> I feel like I'm a bit too map-heavy: `mapM putStrLn $ map unwords $ map (map $ fn dict) $ map words $ lines text`
10:18:09 <ski> syllogismos : there's a nice article by Jerzy Karczmarczuk, "Functional Differentiation of Computer Programs" in 2001 at <https://karczmarczuk.users.greyc.fr/arpap/>, that explains (simple) automatic differentiation
10:18:20 <levi> jrmithdobbs: Ah, I guess that makes sense.
10:18:21 <edwardk> if you need to use an existing Double or something you have in scope you can use 'auto' to turn it into a constant AD variable
10:18:38 <edwardk> auto :: Mode s => a -> AD s a
10:19:05 <edwardk> diff (\x -> x * sin x + 100)   also works
10:19:31 <jrmithdobbs> levi: tbqh, I should really just remove the generality and use IO in this *specific* instance (replacing tokens in a tree from an external db) since in reality that (Text -> m Text) is probably always going to be (Text -> IO Text)
10:19:40 <jcristovao> does anyone know if it is possible to use the template haskell ''Type with partial types (without defining a newtype)? for example ''(EitherT String) does not work
10:19:41 <edwardk> diff is the simplest combinator for interacting with AD provided by that package
10:20:10 <edwardk> others like diffs return a lazy list of all the derivatives, or grad provides derivatives of a function that takes a vector or list of inputs.
10:20:24 <edwardk> e.g.    grad (\[x,y,z] -> x * y + z) [1,2,3]
10:20:57 <jcristovao> Maior: map (unwords . (map $ fn dict) . words) $ lines text
10:21:23 <Maior> jcristovao: ...oooh thanks
10:21:24 <jrmithdobbs> :t sequence (fmap (_2 id) (zip xs (fmap f xs)))
10:21:25 <lambdabot>     Not in scope: `xs'
10:21:25 <lambdabot>     Perhaps you meant one of these:
10:21:25 <lambdabot>       `x' (imported from Debug.SimpleReflect),
10:21:28 <tertl3> in college we were using mathematica
10:21:41 <jrmithdobbs> :t \f xs -> sequence (fmap (_2 id) (zip xs (fmap f xs)))
10:21:42 <lambdabot> (Monad m, Functor m) => (a -> m b) -> [a] -> m [(a, b)]
10:21:51 <levi> jrmithdobbs: That often makes dealing with the types a *lot* easier, and is probably a better approach in an application unless you really need the abstraction.
10:22:17 <jrmithdobbs> levi: right problem is this is something to be shared between a couple projects :(
10:22:20 <jrmithdobbs> heh
10:22:29 <syllogismos> http://lpaste.net/98938 in this im trying to do gradient descent of a simple linear regression problem..
10:22:41 <jrmithdobbs> levi: and the generality makes fuzzing test data easier
10:22:48 <syllogismos> im having problem with this line specifically partdiffs t0 t1 r = grad (\[x, y] -> errorTotal x y r) [t0, t1]
10:23:02 <syllogismos> that caliculates partialdiff wrt x and y
10:23:11 <edwardk> syllogismos: have you seen the existing gradientDescent methods in AD?
10:23:14 <jrmithdobbs> levi: how dare lens give me so much flexibility as to give me too many options! ;p
10:23:15 <levi> Maybe I will think differently when selecting abstractions that are nice to work with in Haskell becomes more natural to me, but at the moment I tend to do things that are particularly hard to type well when I try to abstract too far.
10:23:29 <syllogismos> no i haven't.. i am aware of it..
10:23:46 <edwardk> http://hackage.haskell.org/package/ad-3.4/docs/src/Numeric-AD-Newton.html#gradientDescent
10:24:01 <syllogismos> i wanted to see if im using the library correct and check my other implementations in other langauges
10:24:05 <jrmithdobbs> for hilarity
10:24:12 <jrmithdobbs> @pl \f xs -> sequence (fmap (_2 id) (zip xs (fmap f xs)))
10:24:12 <lambdabot> (line 1, column 27):
10:24:13 <lambdabot> unexpected '_'
10:24:13 <lambdabot> expecting expression
10:24:45 <jrmithdobbs> what
10:24:53 <joelteon> it doesn't like that identifier
10:25:05 <joelteon> @pl \f xs -> sequence (fmap (two id) (zip xs (fmap f xs)))
10:25:05 <lambdabot> ((sequence . fmap (two id)) .) . ap zip . fmap
10:25:07 <edwardk> well, seeing the lists of doubles floating around without uses of 'auto' usually indicates something bad will happen
10:25:17 <syllogismos> i will try fiddling with auto and get back to doubts..
10:25:54 <edwardk> syllogismos: you can remove the signatures on xxx and yyy and take the inferred ones if you turn on NoMonomorphismRestriction
10:26:05 <syllogismos> but its not having a problem when i give inputs with a type of just Floating a => a
10:26:22 <edwardk> yes, the issue is Double isn't AD s Double
10:26:30 <edwardk> auto will 'upgrade' it to be one.
10:26:42 <edwardk> Floating a => a   can be instantiated as Double or as AD s Double
10:26:49 <edwardk> that is why that works then
10:27:01 <edwardk> but when its just a constant with the wrong type, that is why you're having pains
10:27:02 <syllogismos> but i dont know how to read from file and have those numbers have type AD s Double
10:27:19 <edwardk> read Doubles, then use auto to upgrade them to constants inside th function as needed
10:27:20 <syllogismos> im converting String -> Double using read
10:27:35 <syllogismos> ohh okay
10:27:42 <ski> perhaps use `readIO' instead ?
10:29:19 <edwardk> i need to work on shipping a new version of ad
10:31:19 <syllogismos> where can i read up on AD so i can help.. i'm the guy the sent you the two recent pull requests.. i was soo giddy :D
10:31:30 <ReinH> edwardk: :)
10:31:50 <edwardk> syllogismos: mostly by lurking on #haskell-lens =)
10:32:09 <ReinH> edwardk: btw lenses and zoom are amazing for state monad stuff
10:32:51 <edwardk> ReinH: twas kind of the idea =)
10:35:18 <ReinH> edwardk: do you have any good examples of dealing with error handling in the Maybe monad? I've got code right now that branches down a lot of case thing of; Nothing -> error stuff; Just x -> case (anotherPartOf x) of; Nothing -> error stuff; Just y -> ...
10:35:35 <ReinH> edwardk: I'm trying to figure out if I should use Either or EitherT or ErrorT or...
10:35:59 <athan> Hello everyone!
10:36:10 <athan> Could someone answer a CT question for me?
10:36:12 <ReinH> and I want to provide meaningful errors for each possible failure without a huge ugly mess of stairstep code
10:36:22 <Iceland_jack> athan: don't ask to ask etc
10:36:56 <ReinH> edwardk: does lens provide anything to make this easier? How about `exceptions'?
10:37:01 <prinsen> Learning pipes, and I want advice on how to decompose the following program: I got a dataype that is converted to a string, posted as a HTTP POST request, awaits the resonse JSON, and converts the JSON to a data-type again
10:38:25 <athan> Iceland_jack: Sorry man. Can morphisms in CT be considered objects themselves? After reading about CT functors, they claim to map both objects and morphisms between categories. How can this be possible without treating morphisms as objects, as well? Could you make two different categories within the functor, one acting upon the objects, the other acting upon the morphisms?
10:39:02 <bennofs> ReinH: something that worked for me is using errors and EitherT, and a big sum type of possible errors, and then have a function showError :: Error -> Text to pretty-print your error
10:39:04 <Iceland_jack> athan: arrows are objects in other categories (e.g. the arrow category or the slice categories)
10:39:12 <Iceland_jack> but that's not what you're asking
10:39:32 <Iceland_jack> athan: You should look at the Cat category
10:39:42 <athan> Thank you!!!!!!
10:39:45 <Iceland_jack> :)
10:40:04 <athan> :DDDDD
10:40:10 <athan> :(_______________)
10:40:12 <ReinH> bennofs: sure, I guess that's the usual method, but I can't quite see how to make it work
10:40:21 <Iceland_jack> Cat is a category of small categories (objects) and functors between them (arrows)
10:40:37 <athan> ahhh that makes sense
10:40:43 <athan> and this category is a large one, correct?
10:40:49 <athan> Because it could have infinite contents?
10:40:59 <Iceland_jack> yes
10:41:04 <Iceland_jack> or well, not infinite
10:41:11 <Iceland_jack> http://ncatlab.org/nlab/show/Cat
10:41:34 <Iceland_jack> There is a section there about Size Issues
10:42:14 <athan> holy cow!!! Thank you!
10:42:19 <ReinH> bennofs: specifically there are places where it'd be super nice to just use a pattern match like `Just x <- findX xs' but then I can't annotate the failure with a useful message / type
10:42:36 <bennofs> ReinH: you can write findX xs ?! Your error message
10:42:40 <Iceland_jack> athan: I'm glad to see that kind of reaction :) you're welcome
10:42:48 <ReinH> bennofs: orly?
10:42:54 <bennofs> ReinH: look at the errors package
10:43:04 <ReinH> bennofs: cool
10:43:47 <athan> :) It's people like you that make joy possible!
10:44:00 <ReinH> bennofs: ooooooooh
10:44:04 <ReinH> bennofs: <3
10:44:42 <ReinH> bennofs: I thought it was a lens operator but it's an errors operator. So many operators. ;)
10:45:08 <bennofs> ReinH: Yeah, I'm not sure if I got the order of ? and ! right :P (Even lens has ^?! and ^?1 :|)
10:45:19 <joelteon> :t (?!)
10:45:22 <ReinH> bennofs: yeah it's ?? and !?
10:45:22 <lambdabot>     Not in scope: `?!'
10:45:23 <lambdabot>     Perhaps you meant one of these:
10:45:23 <lambdabot>       `$!' (imported from Prelude), `!!' (imported from Data.List),
10:45:28 <bennofs> :t (^?!)
10:45:30 <lambdabot> s -> Getting (Endo a) s a -> a
10:45:30 <joelteon> :t (!?)
10:45:31 <lambdabot>     Not in scope: `!?'
10:45:32 <lambdabot>     Perhaps you meant one of these:
10:45:32 <lambdabot>       `!!' (imported from Data.List), `!' (imported from Data.Array),
10:45:32 <ReinH> bennofs: !? is for m (Maybe a)
10:45:32 <bennofs> :t (^!?)
10:45:33 <lambdabot> Monad m => s -> Acting m (Leftmost a) s t a b -> m (Maybe a)
10:45:45 <ReinH> bennofs: but these are super useful thanks :)
10:45:48 <awestroke> :t (2 :+ 1)
10:45:49 <lambdabot> Num a => Complex a
10:46:03 <awestroke> how can complex be defined as an application of an infix function
10:46:18 <Iceland_jack> athan: glad to be of help!
10:46:22 <dwcook> awestroke, it's an infix data constructor
10:46:31 <dwcook> As indicated by the leading :
10:46:40 <awestroke> dwcook: aaah. thanks
10:46:44 <bernalex> if I have main = do input <- getArgs; putStrLn $ unwords input; -- how would this look without do-notation?
10:46:48 <Iceland_jack> You may want to check out categories such as the comma/slice category etc
10:46:48 <ReinH> bennofs: thanks <3
10:46:54 <bernalex> I'm having a hard trouble translating between the two.
10:46:56 <awestroke> dwcook: why does : indicate that?
10:47:24 <dwcook> awestroke, for the same reason a capital letter indicates a data constructor – It's just a means of distinguishing
10:47:57 <ReinH> athan: remember that you don't really need objects: they can be recovered from identity arrows
10:47:58 <awestroke> dwcook: ah. is there any other infix data constructor except for the list constructor?
10:48:09 <oio_> how can i get editable input on the common line?????
10:48:12 <Iceland_jack> @let data Foo = Int :* Double deriving Show
10:48:14 <lambdabot>  Defined.
10:48:14 <oio_> command*
10:48:17 <Iceland_jack> > 535 :* pi
10:48:18 <lambdabot>  535 :* 3.141592653589793
10:48:21 <Iceland_jack> @undef
10:48:22 <lambdabot> Undefined.
10:48:23 <dwcook> awestroke, anyone is free to make their own. I can't think of any off the top of my head, but I'm sure they're out there
10:48:31 <bennofs> oio_: what do you mean by editable input? Just a line of text?
10:48:53 <Iceland_jack> awestroke: They're nice for defining expression languages
10:49:06 <Iceland_jack>     data Expr = Expr :* Expr | Expr :+ Expr | …
10:49:16 <bernalex> oh. I figured it out by myself. that must mean I'm getting better.
10:49:20 <Iceland_jack> Rather than
10:49:20 <Iceland_jack>     data Expr = Mult Expr Expr | Add Expr Expr | …
10:49:54 <oio_> bennofs: when you use get line if you try yo delete whatever you typed already it will not delete it but put ^? symbols
10:50:12 <Iceland_jack> Then you can pattern match in a ‘nicer’ way
10:50:12 <Iceland_jack>     eval (e₁ :* e₂) = eval e₁ * eval e₂
10:50:12 <Iceland_jack>     eval (e₁ :+ e₂) = eval e₁ + eval e₂
10:50:19 <bennofs> oio_: try putting hSetBuffering stdin LineBuffering at the beginning of your main
10:50:19 * hackagebot hjsmin 0.1.4.5 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.4.5 (AlanZimmerman)
10:50:32 <bennofs> oio_: you need to import System.IO for that
10:50:34 <Iceland_jack> of course with the new pattern extension it's not quite as important
10:51:44 <dwcook> Iceland_jack, which?
10:51:45 <oio_> bennofs: thanks man
10:52:04 <Iceland_jack> dwcook: http://www.reddit.com/r/haskell/comments/1vpaey/pattern_synonyms_merged_into_ghchead/
10:52:39 <jrmithdobbs> what's the less obtuse way to to do flip curry . zip ?
10:52:45 <dwcook> Neat
10:53:02 <dwcook> jrmithdobbs, I mean, you could unpl it if that's what you mean
10:53:04 <Iceland_jack> @unpl flip curry . zip
10:53:05 <lambdabot> (\ f c -> curry c (zip f))
10:53:05 <Iceland_jack> ;)
10:53:06 <dwcook> @unpl flip curry . zip
10:53:06 <lambdabot> (\ f c -> curry c (zip f))
10:53:07 <bennofs> @ty flip curry . zip
10:53:08 <lambdabot> [a] -> (([b1] -> [(a, b1)], b) -> c) -> b -> c
10:53:14 <bennofs> wait, what?
10:53:22 <Iceland_jack> jrmithdobbs: Quite possibly a list comprehension
10:53:25 <bennofs> you're sure you need that?
10:54:58 <Iceland_jack> jrmithdobbs: [ a • b | a ←     permalink
10:54:58 <Iceland_jack>     parent
10:54:58 <Iceland_jack>     kvarta
10:54:58 <Iceland_jack>     give gold
10:55:01 <Iceland_jack>     reply
10:55:04 <Iceland_jack> [–]tomejaguar 1 stig 13 klukkutímum síðan*
10:55:09 <Iceland_jack> When you say "of course" do you mean there's a theory, or that it's been successfully implemented in practice? I would like to see a language where it works.
10:55:12 <Iceland_jack>     permalink
10:55:13 <dwcook> Oh dear
10:55:15 <Iceland_jack>     parent
10:55:15 <Iceland_jack>     kvarta
10:55:18 <Iceland_jack>     give gold
10:55:25 <Iceland_jack> oops, I apologize
10:55:34 <ReinH> jrmithdobbs: are you sure you don't just want zipWith?
10:55:49 <jrmithdobbs> no there's what I want
10:56:11 <bennofs> @ty zip
10:56:12 <lambdabot> [a] -> [b] -> [(a, b)]
10:56:19 <Iceland_jack> @ty zipWith
10:56:20 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
10:56:27 <dhrosa> what's ty vs :t?
10:56:41 <jrmithdobbs> :t \xs ys -> sequence $ xs <*> ys
10:56:42 <lambdabot> Monad m => [a1 -> m a] -> [a1] -> m [a]
10:56:47 <Iceland_jack> > zipWith (\a b -> a ++ " " ++ show b) (repeat "foo") [1..10]
10:56:49 <lambdabot>  ["foo 1","foo 2","foo 3","foo 4","foo 5","foo 6","foo 7","foo 8","foo 9","fo...
10:56:57 <bennofs> dhrosa: @ty used to be the only thing that works in /query lambdabot, so some people are still used to it
10:57:13 <dhrosa> ah
10:57:43 <jrmithdobbs> ReinH: and that misconception is exactly why I was like "flip curry oh noes there's got to be a better way"
10:58:18 <bennofs> jrmithdobbs: How do you use flip curry . zip ?
10:58:53 <ReinH> jrmithdobbs: heh ok :)
10:58:58 <jrmithdobbs> bennofs: give it two lists? first with partially/un applied function second with their argument
10:59:07 <edwardk> :t flip curry . zip
10:59:09 <lambdabot> [a] -> (([b1] -> [(a, b1)], b) -> c) -> b -> c
10:59:17 <bennofs> :t zipWith id
10:59:18 <lambdabot> [b -> c] -> [b] -> [c]
10:59:23 <bennofs> jrmithdobbs: maybe you want that?
10:59:41 <edwardk> :t fmap (curry ??) zip
10:59:43 <lambdabot> [a] -> (([b1] -> [(a, b1)], b) -> c) -> b -> c
10:59:52 <jrmithdobbs> :t \xs ys -> sequence $ xs <*> ys
10:59:53 <lambdabot> Monad m => [a1 -> m a] -> [a1] -> m [a]
10:59:55 <athan> ReinH: WOAH That's good to know!!!
11:00:05 <jrmithdobbs> is what I want, p sure
11:00:34 <ReinH> athan: Categories are often more about the arrows than the objects :)
11:00:45 <jrmithdobbs> @pl \xs ys -> sequence $ xs <*> ys
11:00:46 <lambdabot> (sequence .) . (<*>)
11:01:24 <bennofs> jrmithdobbs: note that that won't have zippy behaviour. Each function will be applied to each argument, the length of the resulting list will be length xs * length ys
11:01:47 <jrmithdobbs> :t sequence . ($ (<*>))
11:01:48 <lambdabot> (Monad m, Applicative f) => ((f (a1 -> b) -> f a1 -> f b) -> [m a]) -> m [a]
11:01:49 <jrmithdobbs> perty
11:02:02 <fragamus> edwardk thanks for helping me via email with Linear
11:02:09 <edwardk> fragamus: np
11:02:30 <edwardk> i had originally written the package for me as part of a toy game physics engine
11:02:51 <edwardk> then acowley browbeat me into releasing it so he could use parts of it =)
11:03:17 <edwardk> it seems to have slowly infected a lot of the game development ecosystem in haskell
11:03:28 <edwardk> now i just need to win over byorgey and the diagrams crowd ;)
11:04:10 <ReinH> edwardk: heh I talked to byorgey about linear briefly ;)
11:04:13 <edwardk> now that they are already using lens, maybe the lure of ^._x and ^._y for field access may help =)
11:04:18 <ReinH> edwardk: primed the pump, if you will
11:04:45 <ReinH> edwardk: and you already capture affine spaces, which they use
11:04:46 <ReinH> seems good
11:04:58 <edwardk> ReinH: just listened to that part, then had to go in to work, but the podcast wasn't ready, so i didn't get much farther in the episode. went back and listened to the tail of the SPJ one i'd skipped before instead
11:05:11 <ReinH> edwardk: cool :)
11:05:17 <edwardk> ReinH: IIRC we added rudimentary affine support explicitly for them
11:05:23 <ReinH> edwardk: I loved the SPJ one. I just want to talk to him for hours.
11:05:39 <Spacer> We made a program that uses strict functional haskell code. Now we have to load the content of a text file and let our old funcions parse it. But all we can find is, that there is no possibility to leave the IO world. Is that the final answer or did we just use the wrong search keywords?
11:05:47 <edwardk> then i dropped the ball on following up
11:06:05 <ReinH> Spacer: It isn't a question of getting out of IO. It's a question of getting everything else *into* IO.
11:06:28 <geekosaur> Spacer: you lift pure code into IO
11:06:44 <ReinH> geekosaur: :p
11:06:50 <Spacer> ReinH: Translating our old code into IO enabled code would take ages. What can we do?
11:06:59 <geekosaur> the IO is going to be there ultimately no matter what; a hermetically sealed program is useless
11:07:01 <edwardk> Spacer: what you can do is map pure functions over values you've built in IO. The IO program remains n control but delegates some parts to pure code
11:07:11 <dhrosa> Spacer: you don't have to convert your program
11:07:17 <geekosaur> Spacer: yoru code takes something pure and returns something pure. You can invoke this, unchanged, *from* IO
11:07:18 <edwardk> Spacer: nono. say do x <- readFile; return $ somePureFunctionalCode x
11:07:30 <geekosaur> Indeed, you must, because without that IO you can't get stuff in or out...
11:07:44 <geekosaur> what edwardk said
11:07:45 <edwardk> Spacer: readFile gave back an IO String, but smePureFunctionalCode can be :: String -> Bool or something
11:07:57 <ReinH> :t \f -> fmap f getLine
11:07:58 <lambdabot> (String -> b) -> IO b
11:08:01 <bennofs> @ty interact
11:08:02 <lambdabot> (String -> String) -> IO ()
11:08:04 <edwardk> that pattern lifted the pure result that expected a pure argument _into IO.
11:08:21 <edwardk> er pure function that expcted a pure argumnt and gave back a pure result
11:09:07 <edwardk> fmap does this for this particular case, but the eturn pattern above extends when you have several such monadic effects you need to get parts for your existng functional code.
11:09:19 <ReinH> (which is just a round-about way of writing fmap somePureFunctionCode readFile) ;)
11:09:23 <ReinH> edwardk: ok fine
11:09:47 <edwardk> do x <- monadicThing1, y <- monadicThing2; z <- monadicThing3thatNeeds x; return $ somethingPureInvolving x y z
11:10:00 <edwardk> er that , should be a ;
11:11:27 <jrmithdobbs> bennofs: yes I know, that's acceptable .. maybe the name of the function in context will help justify: runFuzzTests
11:11:30 <jrmithdobbs> bennofs: ;p
11:12:25 <jrmithdobbs> bennofs: it's a very small number of functions and very small chunk of data containing a bunch of edge cases ;p
11:12:30 <bennofs> jrmithdobbs: ok then, I just fall into that trap myself quite often, and because you mentioned zip, I thought I better ask if that's intented :)
11:14:23 <Spacer> thanks..... testing it right now :)
11:26:57 <hattmammerly> if I declare a function with guards and after all the guards include a where clause, would that associate with the last guard only or would that declaration be available in all of them?
11:27:18 <Cale> all of them
11:28:32 <Cale> (Apart from putting definitions after the point where they're used, that's sort of the point of 'where' relative to 'let', that because it's part of the declaration and not an expression form, it can scope over multiple guards)
11:30:22 * hackagebot lvish 1.1.1.3 - Parallel scheduler, LVar data structures, and infrastructure to build more.  http://hackage.haskell.org/package/lvish-1.1.1.3 (RyanNewton)
11:30:43 <magneticduck> few quick questions about printing numbers... is there a nice easy way in prelude to print numbers without scientific notation?
11:31:03 <magneticduck> and fewer digits?
11:31:11 <geekosaur> not in Prelude, but in Numeric
11:31:12 <magneticduck> kind of hard to debug with these huge numbers
11:31:15 <magneticduck> they tkaea few seconds to read
11:31:33 <magneticduck> alright cool
11:31:51 <geekosaur> there's also Text.Printf
11:32:42 <hattmammerly> Cale: wonderful, thank you!
11:33:45 <mkscrg> how reasonable is it these days to run a private hackage server?
11:35:08 <ReinH> bennofs: well EitherT and `errors' are amazing :)
11:36:53 <ReinH> bennofs: before and after :) https://gist.github.com/reinh/de19c6ee46dae3c49933
11:37:21 <bennofs> ReinH: looks better :)
11:37:40 <ReinH> bennofs: confirm
11:37:44 <levi> ReinH: Very nice.
11:37:49 <mm_freak_> @quote /bin/ls
11:37:50 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
11:37:58 <ReinH> bennofs: I was hating ErrorT :(
11:38:08 <ReinH> errors is a very nice package
11:38:49 <zett_zelett> > let x = (==)
11:38:50 <lambdabot>  not an expression: `let x = (==)'
11:39:16 <acowley> > let x = (==) in 2 `x` 3
11:39:18 <lambdabot>  False
11:39:23 <zett_zelett>  > let x = (==)
11:39:23 <zett_zelett> Prelude Data.List> :t x
11:39:23 <zett_zelett> x :: () -> () -> Bool
11:39:31 <zett_zelett> Why is that?
11:39:37 <dwcook> zett_zelett, that syntax is only for do notation
11:39:38 <mkscrg> ReinH bennofs EitherT is a huge improvement. i'm currently waiting for the version without Error constraint to hit hackage
11:39:43 <dwcook> You need an in to make it an expression
11:40:09 <zett_zelett> > x = (==)
11:40:10 <lambdabot>  <hint>:1:3: parse error on input `='
11:40:16 <zett_zelett> That won’t work either.
11:40:24 <k00mi> :t let x = (==) in x
11:40:25 <lambdabot> Eq a => a -> a -> Bool
11:40:32 <geekosaur> zett_zelett, that's the monomorphism restriction
11:40:32 <zett_zelett> Anyway.
11:40:38 <geekosaur> @where dmr
11:40:38 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:40:52 <bennofs> Why is that @where called dmr?
11:40:53 <geekosaur> combined with extended defaulting, so it monomorphizes to ()
11:41:05 <geekosaur> "dreaded monomorphism restriction"
11:41:21 <bennofs> ha
11:42:32 <zett_zelett> Thanks, geekosaur.
11:42:40 <path[l]> ehah ReinH, text adventure game?
11:44:04 <magneticduck> guys, question about GLUT
11:44:17 <magneticduck> I've noticed that when I hold down a key, I start getting a lot of key up key down events
11:44:20 <magneticduck> any way of supressing that?
11:45:23 <ReinH> path[l]: yep :)
11:47:46 <magneticduck> yo anybody?
11:50:58 <mornfall> mm_freak_: ok, whatever :-)
11:51:19 <mm_freak_> (continuation of a discussion elsewhere about IO being impure)
11:51:32 <mm_freak_> mornfall: non-deterministically?
11:51:51 <gilligan_> anyone here from .ch and planning to go to that hackathon in june ? or maybe been last year?
11:52:24 <mornfall> mm_freak_: well, the output has some effect on the outside world, and that changes future input
11:52:25 <danil> magneticduck: glutIgnoreKeyRepeat
11:52:48 <bos> i let hpaste.org expire yesterday
11:52:54 <magneticduck> danil: thanks
11:53:15 <magneticduck> danil: uh.. not on hoogle
11:53:17 <mornfall> mm_freak_: as far as the program is concerned, there's no way to predict what particular output means for future input
11:53:24 <magneticduck> danil: just trying to guess or something? =P
11:53:39 <shachaf> bos: Can you still recover it?
11:53:50 <enthropy> edwardk: could you release a new trifecta? The fingertree < 0.1 causes problems (since reducers needs 0.1)
11:53:56 <bos> shachaf: i don't plan to
11:54:12 <bos> shachaf: i might be able to unlock it if someone else wants the domain
11:54:23 <danil> magneticduck: I don't know if it's in the Haskell bindings, it's in the actual C api though
11:54:29 <nh2> bos: I'm quite sure there were some people who would love to recover it to keep old links working
11:54:35 <shachaf> It would be nice if hpaste.org continued to exist.
11:54:39 <magneticduck> danil: mm
11:55:27 <magneticduck> danil: I can always use Graphics.UI.GLUT.Raw.Functions though
11:55:29 <magneticduck> yay
11:55:47 <shachaf> Probably the haskell.org people should have it... Or I can register it if no one else does.
11:56:18 <magneticduck> not sure why it's not in hoogle though!
11:56:35 <nh2> shachaf: hmm, bos quit - we better get the domain safe before its lost forever
11:56:38 <magneticduck> oh, because that package isn't documented
11:58:02 <shachaf> lispy: Aren't you involved in this somehow?
11:59:05 <mindleyhilner> :t {{0, "stuff"}};
11:59:06 <lambdabot> parse error on input `{'
11:59:10 <danil> magneticduck: it appears to be called perWindowKeyRepeat in Graphics.UI.GLUT.DeviceControl
11:59:53 <magneticduck> danil: I got it working
11:59:59 <magneticduck> from Graphics.UI.GLUT.Raw.Functions
12:00:02 <magneticduck> wonderful
12:00:04 <magneticduck> tanks
12:20:45 <ski> mornfall : are you using "pure" in the sense of "What is a Purely Functional Language?" by Amr Sabry in 1993-01 at <https://www.cs.indiana.edu/~sabry/papers/purelyFunctional.ps>, or in some other sense ?
12:25:40 <airini> Good evening. I have been trying to solve an issue I have with an installation via cabal for a bit now and haven't managed yet, despite searching for some solution. And I haven't found some other suitable channel where to get some help. I wondered if someone on the haskell channel could give me a hand. Thanks in advance!
12:26:32 <alpounet> airini: paste the error log on http://lpaste.net and we'll see what we can do
12:28:15 <airini> alpounet: thanks. Here it is http://lpaste.net/98998 (using -v3)
12:30:10 <airini> So I see ffihugs is missing apparently. And I've been reading up on what I should do to get hugs98 (could be the case ffihugs would be included too?). I apologise for the question if it happens to be a bit plain. Not too used to the whole haskell environment and cabal, so I've become a bit weary of doing things of my own accord.
12:30:42 <airini> On the other hand, I used to work mainly on Linux systems, been working lately in Mac OS X.
12:31:27 <greg`> serious fpcomplete is really cool
12:31:54 <greg`> if i had internet on the move i would seriously consider it for my default ide
12:32:02 <greg`> ....for haskell
12:33:11 <ReinH> bennofs: seriously errors is so good <3
12:33:23 <bitemyapp> ReinH: hum?
12:34:28 <rawtass> what's the fastest way to get min,max and average of a long list?
12:34:33 <ReinH> @hackage errors
12:34:33 <lambdabot> http://hackage.haskell.org/package/errors
12:34:36 <ReinH> bitemyapp: the errors package
12:35:09 <bitemyapp> ReinH: tekmo-ware. Free Monads?
12:35:30 <ReinH> bitemyapp: mostly just EitherT and some nice utilities to make it easier to use
12:35:31 <intrados> Is there a way a way to hide something from hlint? (It keeps throwing a parse error. I tried #ifndef HLINT)
12:35:34 <bennofs> bitemyapp: no, just combinators for EitherT/MaybeT
12:35:39 <bitemyapp> this is cool.
12:35:41 <rawtass> I would run the functions on the list one by one, byt this would not be the most effective?
12:35:42 <bennofs> s/combinators/nice functions/
12:35:45 <bitemyapp> thanks for making me aware of this :)
12:35:49 <ReinH> bitemyapp: indeed :)
12:36:15 <greg`> rawtass is always going to be o(n)
12:36:16 <ReinH> bennofs: I've been writing a bunch of "assertions" on top of EitherT and it's a really nice way to write this logic
12:36:29 <bitemyapp> why is it that every time I clone a repo of Scala code it takes ages?
12:36:38 <bitemyapp> are they checking uberjars into git or what? Yeesh.
12:36:44 <ReinH> bennofs: assertIsOpen item, etc
12:36:46 <greg`> to compile or to clone?
12:37:02 <alpounet> airini: not sure HGL is supported on mac os x. have you read about people successfully installing it? I don't like that it looks for a hugs related package
12:37:11 <rawtass> greg`: but if I run the one by one I will traverse the list 3 times when I if I prgrammed it myself could find all the values by traversing the list 1 time?
12:37:17 <alpounet> OTOH, the last upload is quite recent so i'm a bit puzzled
12:37:31 <ReinH> bennofs: now I need to lift EitherT into my monad stack rather than just using it ad hoc
12:37:33 <rawtass> greg`: if I run min list, max list, average list that is
12:37:46 <greg`> rawtass cant you just write a fold that does it
12:38:01 <moofy> :|
12:38:12 <moofy> Why is it that all channels can't be as nice as #haskell
12:38:16 <rawtass> greg`: ok
12:38:45 <airini> alpounet: it seems like it might be a bit of an issue: http://www.haskell.org/pipermail/beginners/2010-February/003535.html (even though it's a bit old)
12:39:06 <bitemyapp> greg`: both take ages everytime Scala is involved.
12:39:07 <airini> alpounet: Also, I had no problems installing on a linux machine, without a need for hugs.
12:39:16 <ReinH> greg`: should be able to use a nice applicative for that right?
12:39:38 <greg`> i dont know enough about scala
12:39:49 <bitemyapp> greg`: you're not missing much.
12:39:54 <greg`> could use an applicative but i would just use a fold
12:39:55 <alpounet> airini: alright wait a min
12:40:10 <airini> alpounet: ok, thank you
12:40:35 <alpounet> airini: i'm on os x too, i've just launched 'cabal install HGL'
12:41:10 <dcoutts> oh did HGL get fixed?
12:41:23 <edwardk> HGL lives?
12:41:24 <airini> alpounet: Oh, thanks. I'll wait and read.
12:41:31 <alpounet> dcoutts: very recent upload (january 2014)
12:41:37 <edwardk> nifty
12:41:39 <dcoutts> heh
12:41:48 <dcoutts> alpounet: complete reimpl? :-)
12:41:51 <alpounet> i'm trying to install it right now but airini has some troubles
12:42:01 <alpounet> I have no idea
12:42:07 <alpounet> never paid attention to it before
12:42:32 <alpounet> dcoutts: will you be at zurihac btw?
12:42:44 <dcoutts> alpounet: probably
12:42:48 <lispy> shachaf: what is this?
12:43:14 <alpounet> airini: the build just completed just fine here - os x 10.8.4
12:44:20 <airini> alpounet: I'm running 10.8.5, shouldn't be much different. Did it require hugs?
12:44:42 <alpounet> dcoutts: i'll most likely be there too, will be cool to finally meet i
12:44:49 <dcoutts> :-)
12:44:58 <alpounet> airini: nope
12:45:16 <alpounet> i just installed it in a sandbox without any issue
12:45:22 <airini> On the other hand, strangely enough, it required c2hs and I had to install it manually/individually
12:45:27 <airini> hmm, ok
12:45:32 <alpounet> just issued "cabal install HGL"
12:46:05 <greg`> HGL?
12:46:27 <alpounet> greg`: https://groups.google.com/forum/#!topic/fa.haskell/cIz7ZgWXVmI
12:46:29 <alpounet> err
12:46:35 <alpounet> http://hackage.haskell.org/package/HGL
12:48:21 <airini> alpounet: in reality my failure is (for the time being) due to X11
12:48:40 <alpounet> airini: have you installed the X11 port on mac ?
12:48:49 <alpounet> the xquartz thingy
12:48:51 <airini> I installed XQuartz
12:48:52 <airini> yes
12:49:06 <alpounet> that's odd then, our configurations are quite similar
12:49:17 <geekosaur> it's under /opt/X11, you may need to point stuff at it explicitly
12:49:25 <airini> And apparently it got to be default without issues. Tested an X11 application too, in case.
12:49:27 <geekosaur> and if it uses pkg-config, you'll need to getthat from somewhere
12:49:32 <airini> aha, I'll try
12:49:38 <alpounet> airini: maybe email the author and see if he can help you, I don't see what's different compared to my env
12:49:41 <airini> thanks, geekosaur and alpounet
12:49:51 <airini> I'll try those
12:49:52 <greg`> ooooh
12:49:59 <greg`> that looks nice
12:55:18 <ReinH> rawtass: you can take advantage of the product semigroup/monoid here
12:56:31 <ReinH> foldr1 (<>) . fmap ((,) <$> Max <*> Min) $ [1,2,3,4,5] --> (Max {getMax = 5},Min {getMin = 1})
12:58:16 <pyr> evening haskellers !
12:58:51 <pyr> so I think I graduated in my evolution as a HS developer since I hit what I think is commonly referred to as "cabal hell"
12:59:04 <startling> pyr: haha
12:59:19 <pyr> ``GHCi runtime linker: fatal error: I found a duplicate definition for symbol _hs_text_memcpy''
12:59:27 <startling> it naturally happens once you've got ~1/3 of hackage in ~/.ghc
12:59:35 <pyr> that's about it
12:59:48 <startling> pyr, that's really odd.
13:00:07 <pyr> text-1.0.0.1 and text-0.11.2.3 seem to be the culprits
13:00:07 <dcoutts> you're probably depending on two versions of the text package
13:00:24 <enthropy> text is a troublemaker
13:00:27 <dcoutts> pyr: wouldn't happen if you were using cabal :-)
13:00:28 <startling> oh, I see. shouldn't cabal just reject that outright, though?
13:00:31 <geekosaur> ...although IIRC that can happen with dynamic linking on (Windows? one of our platforms)
13:00:32 <pyr> dcoutts: I am
13:00:38 <erisco> has anyone looked at ✂✁☎✄✝✆✟✞✡✠☞☛✌✠✎✍✏✞✡✠✒✑✔✓✖✕✟✗✙✘✚✁✜✛✢✕✖✣✥✤✦✛✢✕✏✣✧✁✜✍✏✞★✠✧✞★✍✪✩✫✕✏✕✟✞★✗✡✞✬✣✭✣✙✮✯✠✱✰?
13:00:39 <pyr> dcoutts: this is cabal build acting up
13:00:39 <startling> pyr, you might try a cabal sandbox.
13:00:40 <dcoutts> pyr: to build said thing?
13:00:42 <erisco> uh...
13:00:46 <pyr> hmm
13:00:47 <geekosaur> wat
13:00:49 <mjrosenb> I love it when the simple solution to a problem is actually an infinite loop.
13:00:52 <pyr> no that's in emacs actually
13:01:00 <erisco> clearly the encodings are different
13:01:01 <pyr> ah ok
13:01:05 <pyr> so emacs fails
13:01:09 <pyr> not cabal
13:01:16 <pyr> meh, too  bad
13:01:20 <pyr> ok
13:01:26 <pyr> so no cabal hell, sorry
13:01:31 <startling> pyr, maybe try deleting dist?
13:01:36 <dcoutts> cabal hell, solved by using... cabal
13:01:45 <startling> pyr: oh, heh
13:01:50 <erisco> has anyone looked at Higher Order Functions Considered Unnecessary for Higher Order Programming?
13:01:55 <startling> cabal purgatory
13:02:02 <mjrosenb> erisco: no, link?
13:02:18 <roconnor> what's higher-order programming?
13:02:21 <startling> pyr: oh, I see what's happening
13:02:36 <erisco> I dunno I had it emailed to me. maybe this works https://www.google.ca/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&ved=0CCkQFjAA&url=http%3A%2F%2Fcseweb.ucsd.edu%2F~goguen%2Fpps%2Futyop.ps&ei=4ILhUqXUIO-E2wXVvYD4Cw&usg=AFQjCNEG-eJifhdTgZn8jCWfPl2u3AMpnA&sig2=eNhSANHMIxejaL7Fo_gnJA&bvm=bv.59930103,d.b2I
13:02:47 <erisco> damn google redirects... sorry lol
13:02:53 <startling> pyr, you might try ghc-pkg unregister'ing the old version if you don't need it.
13:03:21 <drewr> pyr: before sandbox I found a regular dose of `rm -rf ~/.cabal ~/.ghc&& cabal update` to work quite well
13:03:25 <erisco> roconnor, in the paper, higher order programming is using higher order functions
13:03:34 <pyr> startling: i can't tried already and it lists package that would break if I tried to
13:03:37 <pyr> ok
13:03:39 <pyr> I'll try that, thanks
13:03:39 <startling> drewr, deleting ~/.cabal ins unnecessary
13:03:46 <startling> pyr, do you care about those packages? :)
13:03:48 <pyr> then I'll go read about sandboxes
13:04:10 <erisco> roconnor, well, sorry I guess that is circular
13:04:37 <erisco> roconnor, by "higher order programming" then he is referring to the ability to specialise functions in some manner
13:04:56 <mornfall> ski: seems to be pretty tailor-made (the definition of purity) :-)
13:04:56 <roconnor> I was about to say: "God, what year is this paper"
13:05:00 <roconnor> answer: 1987
13:05:04 <roconnor> it certainly shows
13:05:14 <erisco> yes but Haskell is mentioned in it :)
13:06:49 <erisco> he constructs (or at least explains) a system where functions are templated (to use a modern term) somewhat like type classes in Haskell (but more flexible) and much like traits in C++ (but less obtuse)
13:07:12 * roconnor tries to recall my thoughts on Burstall and Goguen.
13:07:51 <erisco> so instead of foldl (+) 0, you program foldl to use a monoid operator named * (to give it a name)
13:07:56 <roconnor> erisco: I mean, I was working at McMaster on a system that was inspired by this OBJ parameterized module stuff.
13:08:28 <erisco> then you roughly say  * is +, empty is 0 in foldl
13:08:31 <mgaogw> Does anyone know of a good library to clean csv data? For example, one that comes with functions to ignore punctuation, implement frequency tables, or compute Manhattan distances?
13:08:57 <erisco> roconnor, yeah? how did that work out?
13:12:15 <roconnor> MMT by Rabe and Kohlhase would be a modern version of OBJ.
13:13:13 <maxiepoo_> why is there no `xor : Bool -> Bool -> Bool` in prelude?
13:13:14 <roconnor> erisco: The short answer was that I felt that the OBJ modules were trying to be contexts in the category of contexts, and you should just use the category of contexts for whatever type system you care about.
13:13:15 <joelteon> are people eventually going to migrate to monads-tf over mtl?
13:13:25 <roconnor> maxiepoo_: (/=) is xor
13:13:36 <maxiepoo_> ahhhhhhh
13:13:42 <maxiepoo_> duh
13:14:38 <roconnor> erisco: for example http://kwarc.info/frabe/Research/mmt.pdf might be a good start.
13:15:01 <erisco> roconnor, okay neat I'll take a look
13:15:05 <roconnor> erisco: er I guess that is pretty big
13:15:34 <Linuxgirl> hola
13:15:37 <roconnor> erisco: really I suggest Bart Jacob's book which is awesome!
13:15:49 <roconnor> but 10x bigger.
13:16:06 <Cale> @let myfoldl :: (?combine :: a -> b -> a, ?empty :: a) => [b] -> a; myfoldl = foldl ?combine ?empty
13:16:07 <lambdabot>  Parse failed: Parse error: combine
13:16:20 <roconnor> erisco: anything by Rabe is probably good.
13:16:21 <Cale> aw, can't show off ImplicitParams
13:16:30 <ReinH> rawtass: ping
13:16:47 <erisco> roconnor, what is your opinion on higher order functions? from my understanding, the only loss is the capability of storing functions in data
13:16:54 <joelteon> or is there an advantage of using monads-tf over mtl
13:17:00 <erisco> and I do not know how limiting that actually may be
13:17:05 <maxiepoo_> hm so I'm getting a weird lens error
13:17:23 <maxiepoo_> I wrote a Fold for the free variables of an AST
13:17:35 <edwardk> maxiepoo_: i don't think there is any other kind of lens error ;)
13:17:51 <maxiepoo_> and then I wanted to generalize it to be either the free variables or the bound variables based on a Bool
13:17:55 <Cale> :t let { myfoldl :: (?combine :: a -> b -> a, ?empty :: a) => [b] -> a; myfoldl = foldl ?combine ?empty } in let ?combine = (+); ?empty = 0 in myfoldl [1..10]
13:17:56 <lambdabot> (Enum a, Num a) => a
13:18:07 <edwardk> maxiepoo_: do the free and bound variables look the same type wise?
13:18:09 <roconnor> erisco: I think that functions are a fine datatype that is underutilized.
13:18:16 <maxiepoo_> edwardk: yea
13:18:23 <roconnor> erisco: of course, sum types are also a fine datatype that is way underutilized.
13:18:29 <maxiepoo_> I just took the old :: Fold Expr Id
13:18:36 <maxiepoo_> and made it a :: Bool -> Fold Expr Id
13:18:45 <edwardk> so far so good
13:18:53 <roconnor> erisco: that said, I have the understanding that HOF can be compiled away.
13:19:00 <maxiepoo_> but then when I actually called `makeFold False`
13:19:06 <ReinH> greg`: ping
13:19:16 <roconnor> erisco: and if my compiler wants to do that, then I'm okay with that.  As long as I don't have to know about it.
13:19:25 <edwardk> did you make sure to pass along your parameter whenever recursing?
13:19:41 <erisco> roconnor, the compilation process is much less relevant to me. What I am more concerned with is what is simpler
13:19:43 <maxiepoo_> I don't recur on the variable I have an inner loop closed over the parameter
13:19:47 <maxiepoo_> but I get the error
13:19:52 <erisco> roconnor, simpler to use as a programmer, that is
13:19:58 <erisco> roconnor, and to reason about, of course
13:20:06 <maxiepoo_> Illegal polymorphic or qualified type: Fold Expr Id
13:20:08 <edwardk> maxiepoo_: can you lpaste the code and error?
13:20:23 <edwardk> maxiepoo_: also can you turn on RankNTypes in the module first?
13:20:29 <edwardk> and see if that fixes it?
13:20:32 * hackagebot concurrent-state 0.4.2.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.4.2.0 (JoelTaylor)
13:20:42 <maxiepoo_> edwardk: I'm asking why I need RankNTypes
13:21:05 <roconnor> erisco: as long as functions are actually functions and not closures, then reasoning about functions as values isn't that hard.
13:21:06 <maxiepoo_> RankNTypes does fix it
13:21:07 <edwardk> type Fold s a = forall f. (Applicative f, Contravariant f) => (a -> f a) -> s -> f s
13:21:19 <Cale> erisco: My take on higher order functions is that there's no reasonable excuse for a new programming language not to support them at this point, unless it's something incredibly different from everything.
13:21:21 <edwardk> see the forall in the type alias you are using?
13:21:26 <maxiepoo_> yea
13:21:36 <edwardk> maxiepoo_: that is the rank-2 type involved here
13:21:36 <roconnor> erisco: I was reviewing the sematics of SML
13:21:44 <maxiepoo_> so why do I need RankNTypes for Bool -> Fold Expr Id, but not plain Fold Expr Id
13:21:46 <maxiepoo_> ?
13:21:58 <roconnor> erisco: the values of function types in SML are literally bits of SML syntax.
13:22:14 <dhrosa> but but but, languages have to be modeled after C !
13:22:14 <roconnor> erisco: if I thought that was what HOFs were, I wouldn't want them either.
13:22:22 <dhrosa> actually C kind-of has first class functions
13:22:23 <erisco> Cale, I am holding this in contrast to languages which provide alternative means of function specialisation. In particular, OBJ
13:22:27 <edwardk> you could instead write out that signature by hand. and it'd be fine. (Contravariant f, Applicative f) => Bool -> (Id -> f Id) -> Expr -> f Expr  -- but right now ts getting a more explicit type
13:23:10 <edwardk> Bool -> forall f. (Contravariant f, Applicative f) => (Id -> f Id) -> Expr -> f Expr  -- which is still really rank-1 but has an explicit forall buried in it.
13:23:14 <shachaf> lispy: bos let hpaste.org expire and doesn't plan to renew it. See a few lines above.
13:23:55 <maxiepoo_> edwardk: ah that explains it, thanks
13:24:09 <edwardk> it is harmless here, and you'll wind up needing to turn on Rank-2 on some versions of the compiler for what you already have, anyways, so it is sane to turn it on regardless the moment you use a type alias from lens.
13:24:32 <Cale> erisco: I don't think there's a reasonable excuse for a language like OBJ not to include higher order functions. :)
13:24:55 <tromp__> what's OBJ?
13:24:57 <Cale> erisco: Just because you *can* parameterise things in other ways doesn't mean it's always the most convenient way to go about things.
13:25:06 <maxiepoo_> edwardk: so basically there's a special case when using a type alias with an explicit forall
13:25:38 <maxiepoo_> if you have the alias type T = forall f. (...) => t
13:25:40 <edwardk> maxiepoo_: yeah, the 'type alias' is higher rank, because it doesn't prejudge where it'll be used.
13:25:55 <ReinH> edwardk: is it possible to write a "count monoid" or "length monoid" at the type level? i.e. a monoid isomorphic to [()]?
13:26:01 <edwardk> er the scare quotes should have been around 'higher rank' ;)
13:26:03 <maxiepoo_> and you define `x :: t`
13:26:17 <maxiepoo_> it expands to `x :: (..) => t`
13:26:25 <StoneToad> ReinH: you mean like type level arithmetic?
13:26:31 <edwardk> ReinH: well, type nats are currently gimped
13:26:31 <maxiepoo_> instead of `x :: forall f (...) = t
13:26:38 <maxiepoo_> er
13:26:44 <maxiepoo_> `x :: forall f (...) => t`
13:26:45 <edwardk> ReinH: but using a working type nat library, sure.
13:27:10 <edwardk> maxiepoo_: what version of ghc are you on?
13:27:18 <bernalex> what's a concise and short way to just print the contents of all files in arg? right now I have: "forM_ input $ \paths -> do contents <- readFile paths; printf contents". that's admittedly quite concise, but I wanted to hear if there's an even nicer way.
13:27:21 <Cale> "Yeah", the "type alias" is "higher rank", because it doesn't "prejudge" where it'll be "used".
13:27:32 <maxiepoo_> edwardk : 6.3
13:27:36 <maxiepoo_> woops
13:27:37 <ski> roconnor : "the values of function types in SML are literally bits of SML syntax." ?
13:27:39 <maxiepoo_> 7.6.3
13:27:45 <geekosaur> printf???
13:27:59 <geekosaur> readFile paths >>= putStr
13:28:13 <edwardk> maxiepoo_: IIRC one of 7.4 or 7.6 wants Rank2Types turned on whenever you use a type alias with a forall in it at all.
13:28:16 <ReinH> edwardk: for example, if I have newtype Average a = Average (Sum a, Sum Int) deriving (Semigroup, Eq, Ord); avg n = Average (Sum n, Sum 1)
13:28:30 <geekosaur> or, putStr =<< readFile and you can leave off the lambda
13:28:35 <ReinH> edwardk: can I encode the "counting" property at the type level rather than with my own constructor?
13:28:42 <maxiepoo_> it must be 7.4 because I had already defined a Traversal and a Fold before running into that
13:28:43 <erisco> roconnor, this is not the same language is it? http://eprints.mdx.ac.uk/6280/1/ProgrammersGuideToMMT.pdf
13:28:45 <edwardk> so the fact that it was working at all for you without the Rank(2|N)Types was an anomaly =)
13:28:53 <Cale> or putStrLn <=< readFile you mean
13:28:58 <geekosaur> hm, yeh
13:29:27 <maxiepoo_> hm, maybe Lens should say in the documentation what extensions you'll probably need?
13:29:51 <edwardk> ReinH: well, counting and sum are the same monoid, just using different embeddings
13:29:58 <bernalex> geekosaur: Cale: oh, right, so forM_ input $ putStr <=< readFile
13:30:03 <Cale> yeah
13:30:11 <bernalex> geekosaur: I enjoy printf. lol.
13:30:28 <geekosaur> until there's a % in the input and you get a bizarre runtime error
13:30:58 <ReinH> edwardk: well yes :) I'm just trying to figure out if I can embed the "always sum with 1" at the type level
13:31:03 <edwardk> you can make a 'type level monoid' where you make a type family of some sort for how to put them together, define a unit, manually check the laws. you can make a monoid for values that provides hints at the type level that it does certain things, there are lots of ways to interpret what you are asking for =)
13:31:04 <bernalex> geekosaur: didn't consider that
13:31:06 <ReinH> edwardk: but this is rather nice:
13:31:19 <bernalex> geekosaur: no printfs for input. duly noted.
13:31:20 <ReinH> foldr1 (<>) (fmap ((,,) <$> Min <*> Max <*> avg) [1,2,3,1,2,3]) --> (Min {getMin = 1},Max {getMax = 3},(Average 2 % 1))
13:31:32 <geekosaur> at least format string attacks are not a thing (aside from denial of service as the program crashes)
13:31:42 <ski> roconnor : "MMT" standing for ?
13:31:49 <edwardk> ReinH: you should look at multipass ;)
13:31:50 <erisco> roconnor, I have only found highly technical papers without practical examples of MMT
13:32:07 <erisco> which, for me, is not useful =\
13:32:29 <ReinH> edwardk: multipass?
13:32:42 <ReinH> edwardk: ah
13:32:47 <ski> mornfall : possibly. i was mainly wondering in which sense you used "pure" (and "impure")
13:32:58 <edwardk> >>> sequence [count, absdev median, var, q3, q3 `by` HD] @! [1..100]
13:32:58 <edwardk> [100.0,25.0,833.25,75.5,75.49999999999999]
13:33:10 <ReinH> edwardk: well that's rather nice.
13:33:11 * bitemyapp holds up id card in front of ReinH's face and through a thick accent says, "multipass!"
13:33:18 <ReinH> bitemyapp: :)
13:33:27 <edwardk> that merges all the calculations into one pass as it can
13:33:28 <bitemyapp> one of my favorite movies of all time.
13:33:31 <ReinH> edwardk: uh. wow.
13:33:32 <edwardk> using multiple passes as forced
13:33:39 <bernalex> geekosaur: so %s aren't escaped or anything?
13:33:44 <edwardk> it also deduplicates intermediate calculations
13:33:51 <edwardk> github.com/ekmett/multipass
13:33:58 <geekosaur> bernalex, why would they be? you're delivering the file contents as the format string
13:33:58 <ReinH> wait, what is @!?
13:34:03 <bitemyapp> edwardk: *_* so cool
13:34:04 <bernalex> geekosaur: I use printf for my wc program, and doing wc test%file works fine at least
13:34:07 <roconnor> ski: modular mathematical theories??
13:34:07 <edwardk> install it and load examples/Pass.hs and that code works
13:34:13 <ReinH> edwardk: awesome :D
13:34:20 <geekosaur> if you insist on using printf, at least pass a "%s" format
13:34:23 <ion> edwardk: neat
13:34:23 <bernalex> geekosaur: oh right
13:34:24 <roconnor> erisco: there is very little pratical about MMT.
13:34:26 <edwardk> @! applies a Pass to a data set as a list
13:34:27 <lambdabot> Maybe you meant: v @ ? .
13:34:27 <roconnor> YET!
13:34:31 <geekosaur> but really there's no point to using printf there
13:34:43 <erisco> well the OBJ paper I found had practical examples. why can't there be some of that?
13:34:46 <edwardk> you can also do things like compute what the coefficients are for l-estimators, data-free, as well.
13:34:54 <Cale> wow, such cond, many case, very isKindOf
13:34:55 <erisco> they don't even write a *single* line of sample syntax
13:35:01 <ReinH> edwardk: I just wanted to demonstrate an on-line average semigroup for "how do I get min, max, average in a single pass"? But of course you have written the most ridiculously powerful library already as an answer to that question.
13:35:06 <ReinH> sigh
13:35:14 <ReinH> why do I even bother
13:35:17 <ski> roconnor : and erisco's link is for something else ?
13:35:22 <bitemyapp> ReinH: we have the best toys. :)
13:35:25 <roconnor> erisco: that programmer's guide seems to be unrelated.
13:35:33 <ReinH> bitemyapp: well, edwardk does. I'm just happy he shares.
13:35:34 <bitemyapp> ReinH: maybe read the code and learn? :)
13:35:42 <ReinH> bitemyapp: oh I plan on it. Just... you know.
13:35:44 <mjrosenb> ReinH: I think average and standard deviation is a more fun problem :-)
13:35:55 <edwardk> >>> q3 @# 10
13:35:56 <edwardk> [0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0]
13:35:59 <edwardk> >>> q3 `by` HD @# 10
13:36:01 <edwardk> [1.559173091388409e-7,3.9489624615920713e-5,8.806002716352414e-4,6.960055996907882e-3,3.046734916870108e-2,8.924269464590073e-2,0.1892865835181109,0.29155222347002663,0.2901733665440773,0.10139748084271516]
13:36:01 <ReinH> mjrosenb: for sure :) it was a beginner question so I was trying to provide a beginner-ish level answer
13:36:11 <ReinH> mjrosenb: with the goal of introducing semigroups/monoids and folding :)
13:36:31 <ReinH> mjrosenb: so just saying "Here's multipass" would not have acheived my pedagogical goal. But still. Ridiculous.
13:36:40 <mjrosenb> anyhow, I cannot think of a simple solution to this problem (e.g. a solution that doesn't involve manually incrementally computing the answer)
13:36:54 <roconnor> ski: have you looked at the SML spec?  When listing the values of the function data type, it like literally gives <match clause> as one of the possibilities.
13:37:04 <ReinH> edwardk: you sure do love your operators :p
13:37:17 <roconnor> ski: I looked around the semantics trying to find this match thing
13:37:21 <roconnor> ski: I couldn't find it
13:37:24 <ReinH> roconnor: hi :)
13:37:32 <roconnor> ski: because it was in the Syntax part of the book.
13:37:36 <ski> roconnor : it's the same `<match clause>' that is used in `case' expressions
13:37:41 <edwardk> >>> iqr @# 10     ==>  [0.0,0.0,-1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0]   shows what the coefficients would be to compute interquartile range on 10 arguments with the default mode
13:37:44 <mjrosenb> I have a list of all prime numbers, and I want to compute all right truncatable primes (e.g. p is prime, and p `div` 10 is a right truncatable prime.)
13:38:08 <roconnor> ski: case or function declairations or both.
13:38:12 <edwardk> well, it only really adds @!  and @#. the former works on passes and calculations, and the latter works only for those few calculations that can be expressed as L-estimators
13:38:17 <ReinH> edwardk: wait, why @! = @@? Why not just @@?
13:38:23 <ski> roconnor : iow lambda in SML is already a lambda-case
13:38:25 <edwardk> the L-estimators are really nice though
13:38:39 <roconnor> ski: I forget such details.
13:38:41 <edwardk> i think i wanted to force the type to match, when it is ambiguously a Pass or a Calc
13:38:48 <ReinH> ahh
13:38:50 <edwardk> sumSq :: Step t => t Test Double Double
13:38:54 <edwardk> that doesn't choose
13:39:00 <edwardk> (@@) :: (Foldable f, Eval k) => k a b -> f a -> b
13:39:04 <edwardk> that doesn't either.
13:39:06 <ReinH> edwardk: this library is amazing.
13:39:27 <ski> roconnor : `fn NONE => 0 | SOME x => x' vs. `case foo y of NONE => 0 | SOME x => x'
13:39:27 <edwardk> it was a thought experiment i never did anything with
13:39:39 <edwardk> the L-estimators were nice though
13:39:48 <ski> `case <expr> of <match>' is syntactic sugar for `(fn <match>) <expr>'
13:39:56 <roconnor> ski: ah
13:40:02 <edwardk> being able to say things like >>> jackknifed iqm @# 10     ==> [0.0,0.0,0.10500000000000002,0.185,0.21000000000000002,0.21000000000000002,0.185,0.10500000000000002,0.0,0.0]
13:40:06 <edwardk> is really nifty
13:40:28 <ReinH> jackknifed...
13:40:37 <ReinH> also fuck yeah floating point math
13:40:40 <mjrosenb> edwardk: what is this library called?
13:40:46 <edwardk> and having jackknifing on L-estimators basically be free rather than blow you up to n^2 is also nice
13:40:47 <ReinH> @hoogle multipass
13:40:48 <lambdabot> package multipass
13:40:48 <lambdabot> package Control-Monad-MultiPass
13:40:50 <mjrosenb> ski: yeah, I love that about sml, and still miss it in haskell.
13:40:52 <edwardk> github.com/ekmett/multipass
13:40:55 <ski> roconnor : it's a nice generalization of the usual (monomorphic) `let x = M in N' being sugar for `(\x. N) M'
13:40:58 <ReinH> er no
13:41:00 <ReinH> @hackage multipass
13:41:01 <lambdabot> http://hackage.haskell.org/package/multipass
13:41:01 <ReinH> my bad
13:41:17 <edwardk> oh i guess i did throw it on hackage
13:41:22 <ski> mjrosenb : it's quite nice
13:41:27 <ReinH> edwardk: I know what some of those words mean.
13:41:35 <mjrosenb> ski: and local, afiact, haskell doesn't have an equivalent to local?
13:41:38 * ski also misses SML's `local'-`in'-`end' in Haskell
13:41:48 * ski grins
13:42:00 <skypers> end?
13:42:05 <mjrosenb> ski: good to know I'm not the only one
13:42:06 <skypers> SML?
13:42:10 <edwardk> jackknifing is the process of computing a statistic several times, just each time with a differnt element removed from the datast, then averaging the answers.
13:42:16 <ski> skypers : syntactic noise. the important part is the construct
13:42:19 <ski> Standard ML
13:42:20 <mjrosenb> ski: sml isn't indentation sensitive, so everything needs to be explicitly closed.
13:42:23 <skypers> oh
13:42:25 <ski> Standard Meta-Language
13:42:28 <skypers> begin / end ?
13:42:30 <ski> mjrosenb : i know
13:42:33 <edwardk> normally this takes O(n^2) if it takes O(n) to compute the statistic, as you repeat th caculation n times
13:42:34 <companion_cube> not everything, but some things
13:42:35 <ski> skypers : no
13:42:37 <skypers> this just sucks.
13:42:38 <skypers> oh ok
13:42:39 <mjrosenb> skypers: ^
13:42:44 <jfischoff> is there a hackage package that just re-exports a large swath of Hackage in one module?
13:42:55 <mjrosenb> ski: eant that to go to skypers, forgot you both begin with sk.
13:42:56 <geekosaur> [ lens?    :p ]
13:43:15 <ski> mjrosenb : resend it ? :)
13:43:16 <jfischoff> still have to import different modules
13:43:17 <companion_cube> begin/end or () mostly needed for sequences of side effects separated by ";"
13:43:33 <ski> companion_cube : isn't that O'Caml ?
13:43:42 <edwardk> with an L-estimator the statistic is a a linear combination of the 'order statistics' of your data set. the order statistics are just what you get when you sort your data points. if you have 2n+1 data points, the median is equal to the nth order statistic, hence it is a linear combination of orderstatistics.
13:43:45 <companion_cube> well I guess you have the same problem in SML?
13:43:48 <skypers> yeah
13:43:52 <skypers> fun ... end
13:43:53 <geekosaur> where do you think OCaml got it?
13:43:56 <skypers> I don’t like that
13:44:07 <ski> skypers : there's no `fun ... end'
13:44:28 <bernalex> is there a writeFile that doesn't take a string? or some other way to just make a file
13:44:30 <edwardk> jackknifing L-estimators can be calculated by taking the L-estimator for a dataset one size smaller and applying a funny blur kernel to it to get a L-estimator for a dataset of the desired size
13:44:36 <edwardk> but this is O(n)
13:44:40 <edwardk> not O(n^2)
13:44:56 <ski> geekosaur : afaik, SML has never had `begin'
13:45:04 <edwardk> you just apply the blurred L-estimator once to the data, not the individual statistic calculations n times.
13:45:12 <bernalex> oh, there's touchFile
13:45:15 <ski> (i suspect the same for the original ML, but i don't know)
13:45:15 <skypers> ski: well, it’s the idea
13:45:23 <skypers> local ... in .. end
13:45:29 <skypers> just like if .. fi
13:45:33 <skypers> or case .. esac
13:45:46 <edwardk> jackknifing is one technique for discounting exotic data points, other techniques include bootstrapping, etc.
13:45:52 <skypers> those constructions are awful to me
13:46:04 <bernalex> on a different note: is there a way to do hoogle "FilePath -> IO ()", that doesn't require me to pipe it to grep "FilePath -> IO ()" afterwards to actually get relevant results?
13:46:06 <ski> skypers : the two latter aren't in SML (not even with another keyword at the end)
13:46:20 <edwardk> and in general L-estimators can be used as a form of robust statistic, as you can easily trim them or winsorize thm to remove outliers.
13:46:49 <skypers> ski: my point is: I don’t like having to close statement / expressions
13:46:51 <geekosaur> bernalex: try hayoo instead
13:46:51 <ski> skypers : anyway, as mjrosenb said, there's no nesting structure inferred from indentation, so you sometimes have to know when things end
13:46:56 <skypers> it should be natural in the syntax
13:47:08 <edwardk> multipass includes them as a special case and lets you add together L-estimators as such before upgrading them to a Pass or a full fledged multipass calculation
13:47:12 <bernalex> also touchFile didn't do what I thought it did, so I still need a function that makes a file
13:47:18 <geekosaur> although you should be aware that touchFile doesn't do what you think/hope
13:47:26 <skypers> ski: well, the where keyword does exactally the same thing to me
13:47:32 <mjrosenb> skypers: meh, minor annoyance at best.
13:47:41 <skypers> declaring a local scope is just a toy here
13:47:47 <edwardk> Another benefit to L-estimation is that I can give you the coefficient #'s i need as an IntMap and you can partially sort just to put those elements in the right place
13:47:49 <bernalex> geekosaur: yes, I figured that out soon enough.
13:47:58 <ski> skypers : i don't see how `where' serves to end a construct
13:48:07 <mjrosenb> skypers: but the local scope in sml can be for several top level declarations.
13:48:08 <geekosaur> most of the OSes targeted by GHC do not have a "just make an empty file" primitive, so you're expected to do the open/[write/]close thing
13:48:22 <edwardk> This means you don't have to reorder the entire dataset to compute interquartile mean, you just need to find a couple of elements via quickselect
13:48:22 <skypers> mjrosenb: yeah I understand that
13:48:27 <skypers> and that’s quite a toy.
13:48:31 <skypers> just write a function
13:48:36 <skypers> and don’t put it in the export list.
13:48:40 <ski> skypers : consider `foo x = y where {y = g x}', there is an ending delimiter `}' here in Haskell as well, it's just that it's usually invisible, due to being inferred from indentation
13:48:48 <edwardk> ReinH: i'll let you catch up =)
13:48:56 <bernalex> geekosaur: I see. thanks.
13:49:06 <skypers> ski: yes, and I think indentation is the way to do it
13:49:13 <skypers> not ugly keywords like end
13:49:17 <skypers> or } in C
13:49:20 <ski> SML is older than Haskell
13:49:22 <skypers> C-like*
13:49:28 <skypers> yes I know
13:49:34 <ski> as mjrosenb said, "minor annoyance at best"
13:49:36 <skypers> but you seem to be missed that
13:49:58 <skypers> missing*
13:50:02 <ski> (missing what ?)
13:50:20 <maxiepoo_> is there a decent way to compose a monad transformer with an applicative
13:50:29 <maxiepoo_> lift is too restricted
13:50:35 <companion_cube> agreed, this is a detail of the syntax in ML
13:51:12 <maxiepoo_> and Data.Functor.Compose involves a lot of wrapping/unwrapping in order to use the monad operation
13:51:14 <maxiepoo_> s
13:51:20 <skypers> ski: the local in end construction
13:51:36 <ski> i don't understand. what was i missing about it ?
13:51:39 <edwardk> maxiepoo_: you can WrapMonad the monad to get an Applicative then Compose works with applicatives to make a new applicative
13:51:51 <skypers> the idea of a local in end construction in Haskell
13:51:56 <skypers> you’d like it
13:51:57 <skypers> right?
13:52:10 <ski> oh .. i misunderstood the sense of "missing" you used :)
13:52:11 <edwardk> Compose (WrapMonad m) f       and Compose f (WrapMonad m)   are both Applicatives
13:52:13 <ski> skypers : yes
13:52:35 <maxiepoo_> edwardk: sorry, that's not the problem, the monad I'm using is also applicative
13:52:35 <ski> (i was taking "missing that" as "missing to understand that" ;)
13:52:55 <edwardk> maxiepoo_: then Compose m f ;)
13:52:56 <skypers> sorry for the misunderstanding ski
13:53:00 <ski> no worry
13:53:11 <skypers> I seriously don’t want any “end” keyword in Haskell
13:53:16 <skypers> an “end” function, ok.
13:53:23 <skypers> but a syntactic end, no way
13:53:26 <ski> skypers : i wasn't suggesting any `end' keyword in Haskell
13:53:27 <skypers> I’d open up my veins.
13:53:31 <edwardk> :t Data.Functor.Compose.Compose
13:53:33 <lambdabot> f (g a) -> Data.Functor.Compose.Compose f g a
13:53:43 <ski> skypers : i was missing the *construct*, not it's particular concrete syntax
13:53:44 <maxiepoo_> edwardk: right but then Compose (Reader r) f
13:53:48 <maxiepoo_> isn't a MonadReader
13:53:53 <skypers> I see ski
13:53:56 <skypers> but as I said
13:53:59 <maxiepoo_> or a monad afaik
13:54:03 <edwardk> maxiepoo_: and it can't be. it isnt a monad
13:54:04 <ski> skypers : do you know what `local' in SML does ?
13:54:06 <skypers> you can just write a function
13:54:10 <skypers> use it in the module
13:54:12 <skypers> and never export it
13:54:24 <skypers> ski: it seems to create a local scope
13:54:30 <maxiepoo_> ok that makes sense
13:54:37 <skypers> just like let in in Haskell
13:54:41 <ski> skypers : i can't write a module inside another module in Haskell, so that's not good enough for me
13:55:01 <skypers> writing a module in a module, wait what?
13:55:03 <edwardk> maxiepoo_: you can't write a bind that can see 'through' an arbitrary applicative. as there may not even be values in there. Consider (Const x) for some Monoid x
13:55:12 <maxiepoo_> but I don't need  bind
13:55:14 <maxiepoo_> I need
13:55:15 <maxiepoo_> local
13:55:26 <skypers> local is in Reader
13:55:27 <ski> skypers : also, one should be able to write `local' inside a `let' or `where' (e.g. inside a function) -- and even with nested modules, this probably wouldn't be allowed
13:55:49 <edwardk> maxilocal f (Compose r) = Compose (local f r)
13:56:03 <ski> skypers : re your suggestion "you can just write a function","use it in the module","and never export it"
13:56:06 <edwardk> maxilocal f = Compose . local f . getCompose
13:56:14 <maxiepoo_> yeah exactly
13:56:27 <maxiepoo_> I was wondering if there were a nicer solution possible
13:56:46 <edwardk> well, you can use lens to get under and apply the function if you really wanted to ;)
13:56:49 <mornfall> ski: I probably mean pure as in free of side-effects
13:57:04 <ski> skypers : the point of `local' is to be able to declare a bunch of value (and function) definitions (and preferably also other stuff, like types), that are *local* over another bunch of declarations
13:57:05 <mornfall> ski: (I would have probably thought that is the common understanding of pure)
13:57:12 <maxiepoo_> edwardk: a lens already defined in Control.Lens?
13:57:17 <edwardk> unwrapped %~ local f    =)
13:57:24 <ski> skypers : so that the first set is only visible in the second set, not in the rest of the module
13:57:33 <edwardk> there is a Wrapped instance for Compose
13:57:51 <skypers> yes ski
13:57:55 <skypers> I got it well then
13:58:00 <ski> mornfall : ok. i'd claim `IO' is free of side-effects (but not free of effects)
13:58:03 <edwardk> :t \f -> unwrapped %~ local f
13:58:03 <skypers> and I don’t feel a need for that
13:58:04 <lambdabot> (MonadReader r m, Wrapped (m a1) (m a1) b a) => (r -> r) -> a -> b
13:58:15 <edwardk> :t \f -> unwrapping Compose %~ local f
13:58:16 <skypers> omg edwardk
13:58:17 <lambdabot> Not in scope: data constructor `Compose'
13:58:22 <edwardk> :t \f -> unwrapping Data.Functor.Compose.Compose %~ local f
13:58:24 <lambdabot> MonadReader r m => (r -> r) -> Data.Functor.Compose.Compose m g a -> Data.Functor.Compose.Compose m g a
13:58:29 <skypers> lens is really everwhere… :D
13:58:55 <ski> skypers : i admit it's not *very* common that i want this, but when i do, it's ugly to rewrite into returning a tuple of all the things defined in the second set, to be able to use `where' to locally introduce the first set
13:58:56 <edwardk> :t under wrapped (local f)
13:58:57 <lambdabot> (Show r, MonadReader r m, Wrapped (m a1) (m a1) a b, FromExpr r) => b -> a
13:59:02 <edwardk> will also do it
13:59:08 <companion_cube> skypers: what's wrong with modules in modules? :p
13:59:21 <mornfall> skypers: what's wrong with an 'end' keyword? :)
13:59:23 <skypers> companion_cube: it’s too sophisticated
13:59:24 <edwardk> :t under (wrapping Data.Functor.Compose.Compose) (local f)
13:59:26 <lambdabot> (Show r, MonadReader r f, FromExpr r) => Data.Functor.Compose.Compose f g a -> Data.Functor.Compose.Compose f g a
13:59:27 <skypers> going on that way
13:59:27 <companion_cube> skypers: oh come on
13:59:32 <maxiepoo_> edwardk: !!!
13:59:34 <skypers> we’ll end up with a Java-like language.
13:59:36 <edwardk> but the under wrapped (local f) will work for your case
13:59:42 <companion_cube> it's not more sophisticated than "a function in a function"
13:59:51 <mornfall> skypers: you surely mean ruby? :)
14:00:05 <skypers> companion_cube: find me five really and convenient uses of nested modules
14:00:05 <companion_cube> there's not much in common between java and ML
14:00:09 <skypers> you have 30 seconds.
14:00:29 <companion_cube> skypers: functors, namespacing
14:00:47 <companion_cube> (find me 30 convenient uses of typeclasses in 10s please)
14:00:59 <skypers> functors?
14:01:00 <skypers> whaaat?
14:01:09 <skypers> namespacing is not a use
14:01:11 <maxiepoo_> edwardk: ok that worked, I'll look more into wrapped in order to see the nicest way to use it here
14:01:15 <maxiepoo_> thanks
14:01:19 <skypers> it’s the idea behind nested modules
14:01:36 <untrothy> Im new at haskell I can't seem to understand this error: LINE 15: Illegal literal in type (use -XDataKinds to enable): 1
14:01:38 <companion_cube> skypers: nested modules allow very good namespacing
14:01:45 <untrothy> code is here: http://bpaste.net/show/171457/
14:01:46 <companion_cube> functors as in functions from modules to modules
14:01:49 <gabor> SML functors /= Haskell Functor
14:01:50 <bernalex> uhm OK so it's not h <- openFile path WriteMode; writeFile "" path;hClose h; -- what am I missing?
14:01:58 <skypers> companion_cube: yeah
14:02:04 <edwardk> untrothy: switch to data Turn = One | Two
14:02:06 <skypers> it’s like C++ namespaces
14:02:08 <companion_cube> it's really important in ML
14:02:10 <skypers> I prefer using packages
14:02:11 <edwardk> yu can't use 1 or 2 as constructor names
14:02:13 <bernalex> this is in a forM_, and it makes the *first* file, but not the rest in the args list.
14:02:19 <shachaf> hi gabor
14:02:23 <companion_cube> skypers: please try writing some ML first
14:02:23 <edwardk> er you
14:02:24 <shachaf> So *that's* what your nick is.
14:02:36 <gabor> moin shachaf !
14:03:01 <ski> @where on-functors
14:03:01 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by James Coplien in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
14:03:08 <ski> skypers ^
14:03:11 <edwardk> skypers: they are actually quite useful
14:03:32 <untrothy> edwardk, ok the error changed, let me try and see if i can fix it alone, thank you!
14:03:59 <edwardk> skypers: ML Functors make it a lot easier to make API decisions like that affect an entire API like the choice of a random number generator or parsing combinator library.
14:04:07 <bernalex> oh, writeFile args the wrong way around.
14:04:15 <edwardk> in haskell we often spackle over this by adding parameters and using more type classes
14:04:24 <skypers> I see
14:04:26 <edwardk> but as you add too many parameters it becomes unwieldy
14:04:29 <skypers> sounds weird
14:04:35 <skypers> a functor that takes a module
14:04:37 <companion_cube> a good example of functor-heavy ML is ocamlgraph
14:04:38 <edwardk> and parameterizing over more stuff makes your whole API hav to change
14:04:38 <skypers> and outputs a module
14:04:41 <bernalex> but when I fix that it only makes the first file, and then whines about "resource busy" for the same file, instead of moving to the next file. =/
14:05:05 <ski> skypers : it's not really related to haskell Functors
14:05:06 <edwardk> skypers: yes. so you can make a module that is parameterized on another module that provides some functionality it needs
14:05:23 <skypers> edwardk: it’s… an import!
14:05:25 <skypers> no?
14:05:25 <edwardk> skypers: functor is a sort of accidental terminological collision
14:05:34 <ski> skypers : it's a *parameterized* import
14:05:35 <skypers> ah
14:05:37 <skypers> I see
14:05:38 <edwardk> skypers: no, its making a module that takes module paameters
14:05:44 <edwardk> parameters
14:05:46 <skypers> oooh
14:05:49 <skypers> so you import like
14:05:56 <skypers> import Foo[Bar]
14:06:01 <skypers> that’s weird
14:06:02 <edwardk> yes
14:06:04 <shachaf> ski: What is the link between that article and James Coplien?
14:06:07 <companion_cube> no no, you create a module:     module Foo = MakeFoo(Bar)
14:06:13 <ski> skypers : the abstraction principle states that for any syntactic class that expresses a kind of "computation", there should be an abstraction (and corresponding application) form
14:06:14 <companion_cube> and that gives you a nested module ;)
14:06:22 <jfischoff> what's the address for monochrom's cabal write up?
14:06:25 <ski> shachaf : which article ?
14:06:37 <edwardk> you can fake it with whole program transformation in haskell, but it is a lot less invasive to parameterize a module when you realize you needed to make something more flexible than it is to add a parameter to every instance
14:06:38 <shachaf> @where on-functors
14:06:38 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by James Coplien in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
14:06:40 <ski> ok
14:06:41 <ski> oh
14:06:44 <bernalex> so here's my current code in a nicer to read format: http://lpaste.net/6853594655573934080 -- I assume I'm doing something horribly wrong with regards to handles?
14:06:45 <dcoutts> @which sicp
14:06:45 <lambdabot> Unknown command, try @list
14:06:48 <acowley> jfischoff: http://www.vex.net/~trebla/haskell/sicp.xhtml
14:06:52 <jfischoff> thanks
14:07:05 <skypers> edwardk: you talked about choosing a parsing lib
14:07:07 <skypers> or whatever
14:07:15 <skypers> I don’t get it with parameterized module
14:07:15 <ski> shachaf : good question
14:07:19 <edwardk> backpack is trying to offer this functionality for haskell, but has some huge gaping holes where typeclasses are concerned.
14:07:51 <companion_cube> edwardk: is there a theoretical concern about mixing ML modules and typeclasses ?
14:07:54 <ski> @where+ on-functors "On Functors" (in C++,Standard ML,Haskell,Prolog) by Peteris Krumins in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
14:07:54 <lambdabot> Nice!
14:08:03 <skypers> where do the parameters go?
14:08:13 <companion_cube> skypers: in a module
14:08:14 <dhrosa> fmap for functions is the same thing as composition, right?
14:08:17 <skypers> I think that you create a parameterized module like
14:08:18 <companion_cube> (possibly anonymous module)
14:08:19 <ski> (must have mixed up names somehow when i added it, some years ago)
14:08:31 <skypers> module My.Module [ a, b] ( … ) where
14:08:33 <skypers> and then?
14:08:39 <edwardk> skypers: what you can do is make a signature for a module that describes what a parsing combinator should supply, some Parser type that takes an argument a, maybe which is an instance of Monad, or in a more MLish fashion provides a monad module for the Parser, it should also provide a satisfy method, try, and some boilerplate combinators
14:08:45 <ski> @where SICP
14:08:45 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
14:09:01 <edwardk> skypers: then you can have other modules that satsfy the signature, so you can instantiate your module with any of them as arguments
14:09:15 <skypers> I see edwardk
14:09:18 <mornfall> skypers: I have a simple practical problem -- take the "htune" program on hackage; it's a quick and dirty hack for sure, but I'd love to be able to parametrize the whole thing with the frequency of a'
14:09:23 <skypers> that just sounds… brain masturbation to me
14:09:44 <edwardk> companion_cube: the issue is you can't just say we're not going to export some instances or you break coherence of instance resolution
14:09:47 <mornfall> skypers: without shoving everything into IO of course
14:09:59 <kqr> is there a neater way to write \x -> g >> return x ? pointless doesn't give anything really helpful, but it feels like something that should be easier to say
14:10:03 <levi> ML modules/functors are pretty cool. They don't seem particularly more esoteric than type classes, just *different*.
14:10:12 <maxiepoo_> ML functors could clean up the GenTokenParser stuff in parsec right: http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Token.html
14:10:14 <acowley> skypers: What edwardk described isn't that different from how we often use type classes today.
14:10:16 <companion_cube> edwardk: couldn't functor explicitely require typeclass instances?
14:10:26 <edwardk> skypers: you have 10,000 lines of code and now you realize you need to allow users to swap out the random number generator. in haskell you can do that. just add a parameter to every data type, affecting every signature.
14:10:26 <skypers> kqr: try with Arrow
14:10:42 <shachaf> kqr: x <$ g
14:10:46 <edwardk> skypers: in ML you can do it by modifying the module in one place to depend on a RNG module
14:10:54 <edwardk> skypers: which would you prefer?
14:11:03 <ski> skypers : something like `module My.Module [ A where (…), B where (…)] ( … ) where blah :: A.Element -> ...; blah a_el ... = B.foo (A.bar a_el) ...'
14:11:06 <acowley> edwardk: Do I get paid by LoC?
14:11:07 <skypers> edwardk: depends
14:11:14 <skypers> the second option
14:11:19 <skypers> when do you make such a decision?
14:11:29 <edwardk> skypers: it is a useful point in the design space in that it makes your code less brittle.
14:11:32 <skypers> after you’ve discovered the need?
14:11:35 <acowley> skypers: Whenever you'd like to!
14:12:00 <shachaf> kqr: I mean (<$ g)
14:12:04 <companion_cube> skypers: so, an api where that works well, is if you want to write graph algorithms that are generic in 1/ the type of edge,vertex 2/ the representation of the graph 3/ some other parameters
14:12:05 <edwardk> skypers: haskell deliberately eschewed adding ML's module system to it when it was starting out because it didn't know if it was going to need it, and the module system is _very_ complicated and handles a lot of cases
14:12:10 <ski> levi : indeed
14:12:12 <edwardk> it wasn't clear how to incorporate it at the time
14:12:19 <mornfall> I actually find lack of parametric modules a serious showstopper in Haskell...
14:12:24 <acowley> Why don't we have a preprocessor that munges import statements to make it look like we have parameterized modules?
14:12:31 <startling> acowley: we do!
14:12:33 <startling> acowley: CPP
14:12:37 <acowley> oh, duh
14:12:41 <acowley> good, we're done here
14:12:47 <skypers> edwardk: I quite see the need now
14:12:57 <skypers> but I don’t understand the ski’s example
14:12:59 <edwardk> skypers: i often find myself going back and changing huge swathes of code after the fact. this is one reason why i try to find the kind of code i won't have to do that to, and just write it once.
14:13:00 <kqr> shachaf, not quite what i expected, but very neat regardless and by all means good enough!
14:13:08 <acowley> CPP is the alcohol of PL design
14:13:10 <levi> CPP is evil enough in C... it makes me sad that it's in Haskell.
14:13:26 <mceier> bernalex: change writeFile path "" to hPutStr h ""
14:13:30 <edwardk> skypers: i'm more or less forced to limit my focus to that kind of code in haskell though, because of the lack of a decent module system
14:13:31 <mornfall> acowley: more like benzo
14:13:48 <bernalex> mceier: that's just the function I've been looking for. can't believe I didn't find it. =/ thanks!
14:13:54 <skypers> edwardk: you think Haskell’s module system is bad?
14:13:56 <mceier> bernalex: yw ;)
14:13:59 <skypers> which one is good then?
14:14:03 <skypers> ocaml’s one?
14:14:07 <mornfall> SML, I guess
14:14:32 <hodapp> acowley: the alcohol of it?
14:14:40 <edwardk> backpack adds signatures to modules, but has some unfortunate syntactic collisions with empty data decls, and doesn't consider instances at all. extending it to _correctly_ deal with instances takes a non-trivial specification and makes it even more complicated
14:14:41 <bernalex> mceier: ah, missed it because I was looking for Handle -> String and Handle -> IO, not Char.
14:14:51 <edwardk> skypers: SML is sort of the gold standard
14:15:14 <ski> skypers : `A' and `B' would be the local names of modules that will eventually be passed as parameters to `My.Module'. `A' and `B' are required to match certain module signatures (hopefully involving types (and kinds) of exported operations (and types), and not just the names of them as current export lists only specify)
14:15:21 <enthropy> acowley: do you have an example of contours working with HOpenCV?
14:15:30 * enthropy gets segfaults
14:15:33 <edwardk> F# is what you get when you take a language with a wonderful module system and drop the module system on the floor to shoehorn it into an existing runtime system.
14:15:57 <ski> skypers : then we can use the type `A.Element' inside the module, and the operations `A.bar' and `B.foo' (since all these have been specified in the provided signatures (think "module types") for `A' and `B')
14:15:58 <skypers> F# sounded great at first
14:16:17 <edwardk> I can't abstract over anything I want to abstract over in F#.
14:16:18 <skypers> ski: ok, I see
14:16:24 <ski> skypers : then, a use like this would be `import My.Module [My.A,My.B]'
14:16:26 <skypers> so MyModule requires two other modules to work?
14:16:33 <ski> s/like this/of this/
14:16:36 <mornfall> edwardk: I suppose not having both a SML-style module system and typeclasses could be considered a feature in certain light, though.
14:16:55 <skypers> it sounds actually really great indeed
14:17:04 <edwardk> mornfall: well, there is some redundancy between them, but we've always had surface complexity
14:17:10 <bernalex> mceier: uhm how can I make a file of size 0 with hPutChar?
14:17:17 <skypers> I like Haskell’s module system
14:17:24 <skypers> just something I really don’t like
14:17:27 <levi> There has been some research in the direction of adding type classes to SML, but as far as I've heard it's only at the research paper level.
14:17:30 <skypers> modules exports.
14:17:36 <bernalex> even hPutChar '\0' will make a file that's 1 byte
14:17:37 <geekosaur> wut
14:17:39 <skypers> I use the aliased modules exports idiom
14:17:45 <edwardk> I prefer the kind of code that emerges from typeclasses to the kind of code that emerges from good module systems, but that doesn't mean I don't appreciate a good module system.
14:17:48 <ski> skypers : yes
14:17:49 <geekosaur> bernalex, why do you want to use hPutChar?
14:17:52 <skypers> but it’s still stupid
14:17:58 <companion_cube> edwardk: I believe that now OCaml's module system is more powerful than SML's
14:17:59 <bernalex> geekosaur: I don't, I want to use whatever
14:18:01 <ski> skypers : edwardk's RNG example is good
14:18:04 <acowley> hodapp: http://www.youtube.com/watch?v=hUVwR0rw5fk
14:18:05 <companion_cube> there are first-class modules :)
14:18:05 <mceier> bernalex: you can't ... if you want to make empty file, just open it with WriteMode only and close it
14:18:18 <acowley> enthropy: No, I don't think I've used it
14:18:20 <edwardk> companion_cube: sure. and there are better module systems than SMLs in other ML variants as well.
14:18:25 <companion_cube> probably
14:18:27 <geekosaur> you can hPutStr "" or just open and close
14:18:38 <bernalex> mceier: oh, right. openFile by itself will make it. gotcha.
14:18:44 <acowley> enthropy: That's where I ran out of steam/patience wrapping things
14:18:45 <edwardk> MixML and the like take  lot of pan out
14:18:47 <edwardk> er pain
14:18:52 <skypers> ski: what if you write a parameterized module over an IO function.
14:18:59 <mornfall> edwardk: I sort of suspect the clash is that typeclasses create a very global namespace that has to flow across module boundaries...
14:19:01 <skypers> it’d be a backdoor into your own lib!
14:19:02 <edwardk> backpack draws a lot from that culture
14:19:04 <ski> skypers : what about it ?
14:19:08 <bernalex> mceier: geekosaur "h <- openFile path WriteMode; hClose h" did what I wanted thanks!
14:19:19 <mceier> ok ;)
14:19:33 <edwardk> mornfall: well, the clash is more that it wasn't obvious to the folks working on backpack that it wasn't sound to just hide instances.
14:19:39 <enthropy> acowley: thanks. What about using OpenCL on images loaded by opencv?
14:19:55 <ski> enthropy : "backpack" ?
14:19:55 <ion> bernalex: You’ll want to use bracket whenever you see “openFile … hClose”.
14:20:02 <edwardk> mornfall: now you _can_ hide instances, if you go back to why it isn't sound, but if you allow that you have to give up something else... orphans
14:20:03 <ski> oh right, your package
14:20:04 <acowley> enthropy: That I can do
14:20:13 <enthropy> there is C++ stuff in opencv to do that... but nobody has ffi'd to that
14:20:22 <skypers> I got to go
14:20:27 <bitemyapp> edwardk: do you think typeclasses are valuable worth the trouble with module parameterization?
14:20:35 <edwardk> without orphans you can make module signatures that talk about instances so long as the data type or the class was defined in the module in question
14:20:35 <skypers> it was an interesting talk about parameterized modules
14:20:36 <bitemyapp> valuable enough to be worth the trouble*
14:20:38 <acowley> enthropy: It's not hard!
14:20:39 <ski> hm, or maybe not
14:20:39 <skypers> thanks guys!
14:20:48 <edwardk> bitemyapp: if it costs me typeclasses? fuck modules
14:20:49 <skypers> see you tomorrow
14:21:01 <bitemyapp> edwardk: yeah, that's where I was too.
14:21:04 <thoughtpolice> IMO, type class instances being global and resolution being sensible is a very useful property, and i'm willing to give up modules for that, i think
14:21:08 <bitemyapp> edwardk: I've written enough OCaml to know that I'd rather not.
14:21:15 <ReinH> edwardk: So I've started writing records using __foo for fields so I can derive lenses like _foo. I've found that _foo => foo causes too many namespace collisions when I try to use simple names for things.
14:21:20 <bitemyapp> good to know at least one smart person agrees.
14:21:20 <bernalex> ion: noted.
14:21:32 <ReinH> edwardk: also having lenses prepended with _ is a nice visual indicator
14:21:34 <ReinH> edwardk: thoughts?
14:21:34 <philed> ,
14:21:38 <philed> Sorry.
14:21:41 <edwardk> thoughtpolice: ultimately i don't think we'd have to give them up, it'd just make backpack much more invasive if you had to start talking about mixin packages providing instances to avoid orphans
14:21:42 <ion> bernalex: bracket (openFile path WriteMode) hClose $ \_ -> return ()
14:21:46 <mornfall> edwardk: I think that the problem is inherent in a way, instances vs. strict import control always gives rise to confusion
14:21:55 <mornfall> edwardk: happens with the current module system sometimes, too
14:22:09 <acowley> enthropy: Using code from my libs, it looks like: writeImage clImg (packPixels cvImg)
14:22:13 <ski> "Backpack: Retrofitting Haskell with Interfaces" by Scott Kilpatrick,Derek Dreyer,Simon Peyton Jones,Simon Marlow in 2014 at <http://www.mpi-sws.org/~skilpat/papers/backpack-paper.pdf>,<http://lambda-the-ultimate.org/node/4868>
14:22:17 <ski> there
14:22:19 <mornfall> edwardk: making it coherent/correct doesn't make it usable
14:22:24 <edwardk> ReinH: i personally take the lenses without _'s but your mileage may vary. i'v written them your way when forced.
14:22:26 <bernalex> ion: yes, I looked it up in LYAH. thanks though. :-)
14:22:33 <ion> bernalex: It doesn’t really matter that much in this specific case, but you might want to add something between the open and the close in the future, and that something may have an exception.
14:22:58 <bernalex> ion: yep
14:23:11 <edwardk> mornfall: well, f you just replace instance 'infection' with the fact that an instance can only be supplied by the module defining the class or the module defining the data type then you get the same confluence guarantees, but lose orphans
14:23:22 <ReinH> edwardk: the biggest annoyance is things like do { foo' <- use foo } vs do { foo <- use _foo }
14:23:31 <ReinH> edwardk: i.e. places where I want a temp variable with the same name as the lens
14:23:37 <edwardk> this has knock-on effects for the cabal ecosystem, as you'd need some way to avoid making every package defined later than a previous package have to supply all the nstances for everything that went before
14:24:01 <mornfall> edwardk: not only cabal, any big system will suffer
14:24:05 <enthropy> ReinH: what's your opinion on `foo?
14:24:07 <edwardk> this means you need to change the package resolution system a lot. there is a language design you could derive that has all these properties. i don't know that haskell could be that language.
14:24:11 <enthropy> acowley: thanks
14:24:27 <ReinH> enthropy: 'foo? Hmm. I might like that.
14:24:40 <acowley> enthropy: Let me know if you need more detail, as that was admittedly vague. But that stuff's all on github if you're adventurous
14:25:07 <ReinH> enthropy: you mean prepending lenses with ' right?
14:25:22 <enthropy> I mean having a preprocessor/changing ghc to do that
14:25:28 <enthropy> http://code.haskell.org/~aavogt/recordlabel-preprocessor/perf.html
14:25:43 <edwardk> mornfall: well, the trick is to make it so you can make some kind of mixin package such that whenever you depend on, say, parsers and parsec the parsec-parsers instances come into scope, if the LUB of functionality of two packages isn't their join, but can include extra mixin packages you can solve the 'onion layering' problem
14:25:44 <mornfall> edwardk: there may be other type-class-like approaches that combine better with modules (or namespacing in general)
14:25:51 <edwardk> but it is a HUGE ecosystem shift
14:26:14 <edwardk> mornfall: implicits overlap with typeclasses, but fall short in many ways
14:26:16 <ReinH> enthropy: hmmm
14:26:38 <edwardk> mornfall: they interact better with module systems, but i would never trade in typeclasses for them, given my experiences with both
14:26:47 <bernalex> ion: I think "forM_ paths $ \path -> bracket (openFile path WriteMode) hClose $ \_ -> return ()" looks incredibly ugly no matter how I space it -- ideas for making it more pretty?
14:26:48 <edwardk> they lead to hell in scala
14:27:11 <bitemyapp> ugh implicits.
14:27:13 <mornfall> edwardk: any reference on implicits that's not too scala-heavy?
14:27:48 <edwardk> mornfall: implicits are just arguments that are passed ... implicitly if there is a vaguely defined most specific match in scope, but which can be passed by hand otherwise
14:27:53 <edwardk> this means you lose coherence though
14:28:00 <bitemyapp> mornfall: they're not complicated, just misconceived.
14:28:11 <bitemyapp> mornfall: http://www.scala-lang.org/old/node/114
14:28:17 <edwardk> with Haskell any two Set Int's will be sorted the same way as they use the same Ord instance by coherence.
14:28:26 <edwardk> this means you can do things like hedge unions.
14:28:37 <edwardk> because you know they were sorted the same
14:28:43 <ski> implicits aka dynamic scoping
14:29:01 <mornfall> was about to invoke dynamic scope
14:29:04 <ion> bernalex: forM_ paths touch; … touch f = openFile path WriteMode >>= hClose  -- I might actually use this form because the lack of a named “h” doesn’t encourage to directly use the handle while forgetting to add “bracket”.
14:29:09 <ion> bernalex: touch path = … that is
14:29:09 <mornfall> ski beat me to it...
14:29:12 <edwardk> we don't put constraints on the agumnts to dumb data types, because you can move them to the use site. the _soundness_ of this transformation derives from coherence.
14:29:25 <bitemyapp> ski: to be fair, you can have implicit parameters in Haskell, they're just an equally bad idea :)
14:29:48 <mornfall> bitemyapp: I don't think I have ever seen those in the wild.
14:29:50 <edwardk> the alternative requires less generic data types that require more boilerplate to use and which hold their dictionaries close. it destroys the utility of the system of typeclasses we know and love as Functors, tc.
14:30:06 <edwardk> it isn't a pretty picture when you stare at it long enough
14:30:16 <bitemyapp> mornfall: that's because it's a wiser community.
14:30:22 <edwardk> :t ?x + 1
14:30:23 <bitemyapp> mornfall: the problem here is misguided incrementalism.
14:30:25 <lambdabot> (Num a, ?x::a) => a
14:30:33 <bitemyapp> mornfall: they want to learn easy/familiar things instead of sound, coherent abstractions.
14:30:37 <bitemyapp> mornfall: thus, Scala was born.
14:30:45 <mornfall> yes, I have seen a description of implicit parameters in Haskell
14:30:51 <edwardk> > let y = ?x in let ?x = 1 in y
14:30:54 <lambdabot>  1
14:30:54 <companion_cube> edwardk: do you know about unification hints?
14:31:04 <mornfall> I even discussed its merits/drawbacks at some point with someone
14:31:09 <edwardk> companion_cube: what about them?
14:31:12 <mornfall> I vaguely recall...
14:31:14 <thoughtpolice> well, certain kind of implicit parameters work well (like what reflection offers,) but ImplicitParams is just weirdly designed, has optimization impacts, and isn't really implicit anyway
14:31:16 <companion_cube> as a generalization of typeclasses
14:31:20 <bernalex> ion: oooh. I like! thanks.
14:31:22 <hpc> > let y = ?x in (let ?x = 1 in y, let ?x = 2 in y)
14:31:23 <lambdabot>  (1,2)
14:31:26 <companion_cube> (well, as a mechanism that can emulates TC°
14:31:41 <edwardk> companion_cube: the problem is they don't handle MPTCs as i recall
14:31:52 <companion_cube> MPTCs?
14:31:58 <edwardk> multiparameter typeclasses
14:31:58 * roconnor wants edwardk to write a blog post about the global typeclass issue.
14:32:00 <acowley> thoughtpolice: It's good to be explicit when you're being implicit.
14:32:12 <edwardk> roconnor: perhaps i will =)
14:32:13 <companion_cube> oh, really?
14:32:19 <mornfall> Yeah, MPTCs are tricky.
14:32:31 <roconnor> How to handle typeclasses is kinda the one issue that pervents me from thinking that I know how to design a programming language.
14:32:44 <edwardk> with the yu indicate something like x : Ord, no?
14:32:46 <edwardk> er you
14:32:51 <roconnor> (though I've recently got excited about ultra-lazy languages)
14:33:40 <mornfall> I guess the problem with typeclasses (especially when multiparam are included) is that they do way too many things in a fashion that's hard to pull apart
14:33:48 <mornfall> (from language design point of view)
14:34:03 <ChongLi> roconnor: ultra-lazy languages?
14:34:10 <thoughtpolice> acowley: what about being implicitly explicit?
14:34:18 <companion_cube> edwardk: you infer arguments (as for TC) driven by what they are going to be applied to, iirc
14:34:39 <companion_cube> I don't see why the missing arguments couldnt depend on more than one variable
14:34:49 <companion_cube> but I'm no expert on this, I just read through the paper
14:34:49 <edwardk> companion_cube: link to a paper on the particular approach you are advocating?
14:34:50 <ChongLi> you start the program with any argument and it just exits immediately, printing a description of a thunk to stdout?
14:34:55 <acowley> thoughtpolice: like when someone you know swears a lot visibly bites their tongue?
14:35:35 <roconnor> ChongLi: I guess I don't know the proper term, but in a "ultra-lazy" language the branches of a case statement begin evaluation in parallel with the value being analyzed.  If all branches of a case statement return the same constructor, then that constructor is ... uh ... "returned" and case analysis may be suspended.
14:35:36 <companion_cube> http://www.cs.unibo.it/~asperti/PAPERS/tphol09.pdf
14:35:51 <acowley> ultra-lazy language is just a pipe to /dev/null
14:36:14 <acowley> sounds more like ultra-eager in some respects
14:36:15 <companion_cube> a lazy pipe
14:36:17 <roconnor> I need to learn how to express this more clearly.
14:36:21 <ChongLi> roconnor: ahhh, that sounds pretty cool
14:36:43 <companion_cube> waits for input, reads the input, then blocks forever before it writes to /dev/null
14:37:01 <roconnor> ChongLi: anyhow, it gives you parallel or and friends.
14:37:10 <thoughtpolice> acowley: yeah. but then it's slightly awkward because you know what they want to say, etc.
14:37:13 <roconnor> I actually don't know too much about it.
14:37:15 <ChongLi> is there any hope of a lazy language that doesn't need seq or any sort of strictness annotations?
14:37:25 <ChongLi> being efficient, I mean
14:37:36 <Maior> reading through http://hackage.haskell.org/package/bloomfilter-1.2.6.10/docs/Data-BloomFilter.html I've found bitArrayB, but how do I _deserialise_ it?
14:37:42 * roconnor doesn't know anything about efficency.
14:37:45 <companion_cube> ChongLi: only if you believe in the Sufficiently Smart Compiler? :)
14:38:04 <ChongLi> well, I believe a compiler is as smart as its types allow
14:38:25 <ChongLi> and so, for that you just need sufficiently rich types
14:38:30 <edwardk> ChongLi: go read rob ennals' dissertation
14:38:58 <ChongLi> Rob Ennals @ Intel Research Berkeley?
14:39:02 <roconnor> ChongLi: consider x `or` y = case x of { True -> True; False -> y }
14:39:16 <edwardk> ChongLi: he was there, not sure if he's there now
14:39:22 <roconnor> ChongLi: and consider undefined `or` True
14:39:30 <ChongLi> Adaptive Evaluation of Non-Strict Programs
14:39:53 <edwardk> yep. read that ,particularly the part about how well it works on naive code like foldl (+) 0
14:39:57 <roconnor> ChongLi: in an ultra-lazy lanuage the two branches of case undefined of { True -> True; False -> True } are evaluated along with undefined.
14:39:58 <ChongLi> http://ennals.org/rob/archive/intel/pubs/thesis.pdf
14:40:11 <ReinH> edwardk: Pretty sure I'm missing a lot of prereqs to understand how multipass words :) But it's super interesting.
14:40:11 <ski> edwardk : related to adaptive/incremental computation, as in Acar,Blelloch,Harper paper (SML), and a Magnus Carlsson one (Haskell) ?
14:40:25 <roconnor> ChongLi: but since both branches return the same constructor, the value of the case statement is True, even without undefined being evaluated.
14:40:31 <thoughtpolice> edwardk: jhc works pretty well on foldl (+) 0 too, when it works :P
14:40:33 <prinsen> I cant get the Network.HTTP library to do post requests, as soon as I set rqBody to none-empty it throws an error!
14:40:33 <ChongLi> roconnor: ahhhh
14:40:36 <ChongLi> that's pretty nice
14:40:57 <roconnor> ChongLi: and True `or` undefined is trivially True.
14:41:05 <ski> roconnor : so you can express parallel-or, iiuc
14:41:05 <thoughtpolice> edwardk: is this same thing you want to use for TurboHaskell or whatnot btw?
14:41:12 <edwardk> ski: his was on 'optimistic evaluation' which wuld dive in and speculatively evaluate thunks until it realized it was too lost in the woods.
14:41:15 <edwardk> thoughtpolice: yep
14:41:20 <ski> roconnor : Barry's majority and Gustave ?
14:41:32 <roconnor> ski:  I don't even know what those are.
14:41:33 <ChongLi> yeah, so we get a little bit closer to the properties of intuitionistic logic
14:41:38 <roconnor> ski: but it sounds interesting.
14:41:51 <edwardk> ski: not quite the same way as Eager Haskell did, because it doesn't give up n regular intervals, but rather tracks blame by let binding
14:42:36 <ski> roconnor : `majority True  True  _     = True; majority True  _     True  = True; majority _     True  True  = True; majority False False False = False'
14:42:37 <roconnor> ski: I don't even know where to find literature on this topic.
14:43:01 <edwardk> gotta go
14:43:13 <edwardk> ReinH: happy to answer questions ;)
14:43:20 <edwardk> ReinH: well, when i'm at a computer
14:43:23 <ReinH> heh
14:43:27 <roconnor> ski: I would try the naive definition and I suspect it will work.
14:44:44 <ski> roconnor : sorry, s/Barry/Berry/. <http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.PatternMatching>
14:46:25 <roconnor> ski: I gotta go.
14:46:47 <mornfall> companion_cube: that's mostly about second-order unification :-) (re. unification hints)
14:47:18 <ski> roconnor : i'll @tell you the rest
14:47:31 <mornfall> companion_cube: (which is of course undecidable, and usually also incomprehensible to humans)
14:47:32 <companion_cube> mornfall: but controlled unification
14:47:39 <Maior> is there a generic/common way to do serialisation in Haskell?
14:47:51 <geekosaur> binary or cereal packages
14:47:58 <zett_zelett> while :: Monad m => m Bool -> m a -> m a; while cond action = do; x <- action; b <- cond; if b then while cond action else return x;
14:48:02 <zett_zelett> -- does this make sense?
14:48:06 <geekosaur> (which are slowly converging, I think)
14:49:11 <merijn> zett_zelett: Sounds like you're reinventing monad-loops
14:49:17 <merijn> @hackage monad-loops
14:49:18 <lambdabot> http://hackage.haskell.org/package/monad-loops
14:50:00 <mornfall> companion_cube: I'm pretty sure we aren't going to evolve brains to make second-order thinking feasible for everyday activities anytime soon :-)
14:50:52 <sdegutis> Are there any reasons to use Haskell rather than Julia?
14:51:15 <bitemyapp> sdegutis: nope.
14:51:20 <mornfall> companion_cube: I'm also not entirely convinced that the typeclasses in the paper are a 100% match to Haskell's typeclasses (even if we omit all the associated type complexity).
14:51:28 <zett_zelett> sdegutis: For what?
14:51:45 <sdegutis> The thing I'm most interested about Haskell is the strong typing.
14:51:49 <companion_cube> mornfall: ah, I don't know
14:52:07 <sdegutis> bitemyapp: still doing Clojure?
14:52:08 <ski> Eduard_Munteanu : ok (blame tracking sounds interesting)
14:52:24 <companion_cube> (I have to admit that higher order unification or proving is pretty hard to understand)
14:52:30 <Eduard_Munteanu> ski: er, um?
14:52:38 <ski> er
14:52:55 <Eduard_Munteanu> Wrong ed<TAB>? :)
14:52:56 <ski> @tell edwardk ok (blame tracking sounds interesting)
14:52:56 <lambdabot> Consider it noted.
14:53:03 <Eduard_Munteanu> I see.
14:53:12 <ski> well, dangling pointer
14:54:43 <mornfall> sdegutis: https://www.destroyallsoftware.com/talks/useing-youre-types-good
14:55:28 <sdegutis> I recognize that announcer's voice.
14:55:47 <Bor0> @src last
14:55:48 <lambdabot> last [x]    = x
14:55:48 <lambdabot> last (_:xs) = last xs
14:55:48 <lambdabot> last []     = undefined
14:56:30 <Twey> sdegutis: Good — that is the most interesting thing about Haskell
14:56:40 <sdegutis> mornfall: Best talk.
14:59:56 <joelteon> The typing is very strong
15:01:12 <bitemyapp> sdegutis: at work? Sure. At home? Less so these days.
15:01:29 <bitemyapp> sdegutis: Work involves mostly Python and Clojure atm, home is mostly Haskell and Fay.
15:01:38 <sdegutis> hmm never heard of Fay
15:01:43 <bitemyapp> I need to write a nice Datomic client for Haskell.
15:01:57 <sdegutis> Be sure to put it on github and HN.
15:02:38 <bitemyapp> sdegutis: no :)
15:02:42 <mornfall> sdegutis: @shit_hn_says :D
15:04:00 <Maior> there seem to be many different kinds of ByteString :(
15:04:32 <mornfall> Maior: where?
15:05:07 <Maior> mornfall: well http://hackage.haskell.org/package/mmap-0.2/docs/System-IO-MMap.html apparently returns Data.ByteString.Lazy.ByteString
15:05:21 <sdegutis> mornfall: wow, I never knew about this account, thanks!
15:05:51 <mornfall> Maior: lazy and non-lazy
15:06:04 <mornfall> Maior: lazy is chunked, the other is a single block
15:06:35 <mornfall> Maior: unless you are on a 32b machine, you probably don't need lazy mmap
15:06:55 <Maior> mornfall: hm ok
15:07:22 <mornfall> Maior: lazy mmap basically exists (IIRC) to circumvent the address-space limitation with big files
15:07:40 <Clint> Heffalump: might i suggest that SPI handle hpaste.org on behalf of haskell.org?
15:07:42 <Clint> lispy: ^
15:07:44 <mornfall> Maior: as long as you process them in-order and the older chunks are finalized/gced often enough
15:07:48 <Maior> so, I'm reading in a file, cutting it into lines, and putting them in a set; this currently takes up 99% of my execution time, and I'm trying to speed it up
15:08:11 <mornfall> Maior: what you want is attoparsec not mmap :-)
15:08:17 <mornfall> Maior: also, set...
15:08:19 <Maior> mornfall: ahh ok, cheers
15:08:22 <mornfall> Maior: is slow
15:08:39 <Maior> mornfall: sorry yes, I've moved to a bloom filter
15:08:56 <mornfall> Maior: that's kinda inaccurate
15:09:06 <flazz> is there a way to determine if a funciton is is a TCO-able?
15:09:33 <Zettablade> Haskell is kinda cool
15:09:40 <Maior> mornfall: I only need to be mostly-accurate
15:09:46 <flazz> foldr is not TCO right?
15:10:08 <dwcook> flazz, non-strict semantics make tail calls less important than you might think
15:10:12 <shachaf> Every call in Haskell is a tail call.
15:10:32 <BullSherd> Wow, what a things of google. http://goo.gl/pF3kWN
15:10:33 <BullSherd> Google is funny haha
15:10:49 <mornfall> Maior: might work then; using a set with 64b hashes would be much more accurate, but also slower (than a bloom filter)
15:11:09 <nicoo> shachaf: Because everything is rewritten by GHC into CPS, right ?
15:11:33 <shachaf> I would say that it doesn't make sense to talk about whether GHC supports TCO.
15:11:56 <mornfall> First of all, it's not a "call" in the C sense.
15:12:21 <flazz> please enlighten me
15:12:24 <flazz> how should i think of it?
15:13:09 <flazz> this was brought about by foldr (+) 0 (10 ^ 7) causing stack space overflow
15:13:17 <jle`> flazz: you can think of it as a lexical expansion almost
15:13:28 <jle`> (if that was what mornfall was going for)
15:13:30 <mornfall> flazz: that's because it accumulates thunks
15:13:35 <shachaf> Stack space overflow, not type error?
15:13:38 <joelteon> does doctest support examples in IO
15:13:43 <Maior> mornfall: speed is the issue
15:13:50 <jle`> ah yeah, stack overflow isn't a TCO/recursion problem
15:13:52 <jle`> in Haskell
15:13:55 <jle`> most of the time
15:13:55 <Maior> will look at attoparsec - cheers
15:14:13 <mornfall> shachaf: you can probably imagine a version that is type correct ;-)
15:14:14 <ChongLi> > foldr (+) 0 [0..10 ^ 7]
15:14:17 <lambdabot>  *Exception: stack overflow
15:14:20 <ChongLi> lol
15:14:33 <jle`> heh
15:14:42 <jle`> yeah i guess it's a bit counterintuitive coming from another language
15:14:42 <shachaf> map (+1) [1..] causes no stack overflow even though its argument is an infinite list.
15:14:56 <ChongLi> works fine in ghci; lambdabot must have some tight limits
15:15:12 <mornfall> ChongLi: obviously, owner doesn't want to fry the machine
15:15:18 <ChongLi> yeah
15:15:21 <flazz> it does work fine in ghci, but compiled with the defaults it stack overflows
15:15:21 <mornfall> ChongLi: also, "fine"
15:15:39 <jle`> flazz: anyways one useful way to look at evaluation (for the purposes of seeing how evaluation works) is that evaluation in Haskell is like mathematical subsitution
15:15:42 <jle`> @src foldr
15:15:43 <lambdabot> foldr f z []     = z
15:15:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:15:44 <mornfall> flazz: try foldl :)
15:16:09 <flazz> foldl blew up too
15:16:28 <jle`> basically foldr (+) 0 [0..10^7] is "expanded" into (+) 0 (foldr (+) 0 [1..10^7])
15:16:37 <mornfall> took a gigabyte of RAM
15:16:37 <jle`> which is then expanded into
15:16:39 <jle`> etc. etc.
15:16:46 <jle`> thinking of things like stack frames are less useful
15:16:53 <jle`> than in languages with function "calls"
15:17:06 <dwcook> > foldl' (+) 0 [0..10^7]
15:17:10 <lambdabot>  50000005000000
15:17:20 <syllogismos> im finding haskell to be too strict for my tastes.. i'm new to it.. when im using a new library.. im thinking more in terms of types.. it gets better right?
15:17:36 <joelteon> that's funny, because usually laziness is the problem ):
15:17:42 <ChongLi> hahaha
15:17:46 <dwcook> syllogismos, thinking in terms of types is a good thing to be doing in Haskell. What is the problem, specifically?
15:17:46 <ChongLi> was just going to say the same thing
15:17:55 <shachaf> If thinking in terms of types is bad, then it'll only get worse.
15:18:05 <mornfall> :-)
15:19:03 <flazz> dwcook: why is the strict one way faster?
15:19:04 <mornfall> @src foldl'
15:19:05 <lambdabot> foldl' f a []     = a
15:19:05 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:19:45 <mornfall> flazz: because keeping an accumulator is way cheaper than keeping a gigabyte worth of thunks
15:19:49 <dwcook> flazz, I don't know why it's faster, but I can tell you it doesn't build up thunks arbitrarily
15:20:07 <dwcook> arbitrarily many thunks*
15:20:18 <shachaf> @where lazy
15:20:18 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
15:20:21 <ski> @tell roconnor one variation of it is `gustave True  False _     = True; gustave _     True  False = True; gustave False _     True  = True; gustave True  True  True  = False; gustave False False False = False'
15:20:21 <lambdabot> Consider it noted.
15:20:23 <shachaf> Read the above article.
15:20:49 <flazz> this seems to be written for me http://www.haskell.org/haskellwiki/Stack_overflow
15:21:05 <syllogismos> everytime im falling back on the type signature of a function.. and trying to make things fit accordingly..
15:21:24 <syllogismos> maybe ill come across problems with lazyness a little later..
15:21:41 <dwcook> syllogismos, yes, understanding types is vital to success in Haskell and, arguably, in any other language.
15:21:55 <dwcook> (For some value of "types")
15:22:42 <dwcook> In Haskell, the compiler doesn't let you get away with being as sloppy with how you put your logic together as some other languages might allow.
15:22:58 <jle`> flazz: if you manually expand foldr, you'll see that it can't actaully ever 'evaluate' anything until the very last expansion of foldr.  it's (+) ((+) (((+) ... ))), etc. if you manually expand foldl, you'll see that it's possible to evaluate things at everyr step
15:23:09 <jle`> however, recall that saying something like foo = 1 + 2
15:23:19 <jle`> doesn't actually cause the run time system to evaluate 1 + 2 and store it in foo
15:23:31 <jle`> it treats 1 + 2 as a "recipe" to generate a foo, when you need a foo
15:23:40 <jle`> and when you need it, it'll evaluate it
15:23:53 <ChongLi> jle`: isn't that only the case because (+) is strict?
15:24:06 <jle`> so your giant foldl comes out as 0 + 1 + 2 + 3 + 4 + 5 ... + 10^7
15:24:15 <jle`> ChongLi: (+) is not strict
15:24:19 <jle`> right?
15:24:36 <jle`> anyways, your giant foldl comes out to 0 + 1 + 2 + 3 + 4 + 5 ... + 10^7 etc.
15:24:38 <ChongLi> in order to get anything useful out of (+) you need both sides
15:24:42 <jle`> and that's a data structure
15:24:44 <dwcook> In this example it's irrelevant whether (+) is strict
15:24:47 <jle`> a data structure storing a list of additions
15:24:55 <ChongLi> whereas with something like (:) you can get the head without touching the tail
15:25:10 <syllogismos> :t (^)
15:25:10 <jle`> ChongLi: yes i think dwcook is right in saying that this is slightly irrelevant
15:25:11 <lambdabot> (Integral b, Num a) => a -> b -> a
15:25:16 <jle`> because that's only when you actually want to evaluate the +
15:25:18 <syllogismos> :t (**)
15:25:19 <lambdabot> Floating a => a -> a -> a
15:25:28 <syllogismos> :t (^^)
15:25:29 <lambdabot> (Fractional a, Integral b) => a -> b -> a
15:25:38 <jle`> flazz: so...if you manually expand out foldl, you will get that giant list of additions
15:25:48 <jle`> Haskell sees that as a giant nested data structure of future additions
15:25:53 <jle`> that will be evaluated/collapsed when you lose it
15:25:55 <jle`> *need it
15:26:22 <jle`> what foldl' does it that it adds a sort of 'runtime flag' of sorts to say "i want this now...not later"
15:26:38 <ChongLi> > take 1 $ foldr ((:) . (*2)) [0] [10..10 ^ 100]
15:26:39 <jle`> so it won't build up the nested (+) data structure
15:26:39 <lambdabot>  [20]
15:26:49 <jle`> it'll just evaluate it as you go along
15:27:15 <jle`> it's a kind of Haskellism
15:27:17 <jle`> "What is 1 + 1?"
15:27:21 <jle`> "well.. 1+1 :)"
15:27:23 <dwcook> I think it actually uses seq
15:27:26 <dwcook> @source foldl'
15:27:27 <lambdabot> Unknown command, try @list
15:27:31 <dwcook> @src foldl'
15:27:32 <lambdabot> foldl' f a []     = a
15:27:32 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:27:33 <jle`> dwcook: yeah, seq is the runtime flag i am talking about
15:27:42 <jle`> because it's magic
15:27:50 <dwcook> Fair enough
15:28:17 <jle`> i was going to say compiler flag too
15:28:24 <jle`> but either one is a bit of a stretch
15:28:24 <ski> @tell roconnor "Locus Solum" p. 121 <http://iml.univ-mrs.fr/~girard/0.pdf>,"On the meaning of logical rules I : syntax vs. semantics" p. 16 <http://iml.univ-mrs.fr/~girard/meaning1.pdf.gz> (<http://iml.univ-mrs.fr/~girard/Articles.html>),"Gustave, ses pompes et ses œuvres" p.12 <http://pauillac.inria.fr/~huet/PUBLIC/GGJJ.pdf>
15:28:25 <lambdabot> Consider it noted.
15:28:38 <dwcook> Completely off-topic, I find it silly that @src exists but @source, the word it derives from, does not.
15:28:57 <jle`> syllogismos: actaully i think laziness and types are different issues altogether
15:29:09 <flazz> is there a way to have @source or @src in ghci or a tool like hlint?
15:29:13 <ski> @tell roconnor those all seem to mention it, though i can't seem to find the paper i was thinking of. then there's of course also parallel or `por True  _     = True; por _     True  = True; por False False = False'
15:29:13 <lambdabot> Consider it noted.
15:29:23 <shachaf> That's because @source used to exist but was removed.
15:29:23 <flazz> btw thanks all for the schooling
15:29:24 <dhrosa> flazz: yes, look at the lambdabot package and ghci on acid
15:29:25 <jle`> flazz: hmm i don't think there is an easy way
15:29:30 <jle`> oh nevermind
15:29:36 <jle`> yeah i was going to say look at the lambdabot source
15:29:39 <jle`> and then pull it into yours
15:29:47 <jle`> but i didn't knwo about ghci on acid
15:29:53 <dhrosa> ghci on acid integrates lambdabot and some other cool things
15:29:59 <Rarrikins> How do I download a hackage package so that I can examine the files in it?
15:30:04 <syllogismos> 3 different functions doing the same thing but with different type signature.. ^ ^^ ** i got annoyed when i first learned it the hard way.. but i guess i see the point of it..
15:30:20 <Rarrikins> (instead of installing it)
15:30:23 <ChongLi> Rarrikins: cabal unpack
15:30:29 <Rarrikins> ChongLi: Thanks
15:30:43 * hackagebot language-bash 0.6.0 - Parsing and pretty-printing Bash shell scripts  http://hackage.haskell.org/package/language-bash-0.6.0 (KyleRaftogianis)
15:30:49 <hpc> there's also a .tar.gz of each package version on the website
15:30:59 <jle`> syllogismos: looking at the source is interesting :)  they don't exactly do the same thing either
15:31:03 <jle`> @src (^)
15:31:03 <lambdabot> x ^ 0            =  1
15:31:03 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
15:31:03 <lambdabot>   where f _ 0 y = y
15:31:03 <lambdabot>         f x n y = g x n
15:31:03 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
15:31:05 <lambdabot>                       | otherwise = f x (n-1) (x*y)
15:31:06 <hpc> linked at the bottom of the package index, in case that's ever useful
15:31:06 <jle`> @src (^^)
15:31:07 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
15:31:08 <jle`> @src (**)
15:31:09 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
15:31:11 <lambdabot> Source not found. My mind is going. I can feel it.
15:33:24 <jle`> i don't think there is a default implementation of (**)
15:37:15 <dwcook> Reminds me of how many distinct ways to turn a non-integer into an integer exist
15:37:22 <dwcook> floor, ceiling, round, truncate, possibly others
15:38:37 <dhrosa> a constant function  :p
15:38:52 <dwcook> Heh, indeed
15:39:28 * ski . o O ( "Proposal for Division Operators in Scheme" by Riastradh at <http://mumble.net/~campbell/tmp/division.txt> )
15:41:39 <mornfall> ski: what's the language without multiplication? :)
15:41:47 <ski> i don't know
15:41:51 <ski> ask Riastradh ?
15:42:22 <mornfall> @seen Riastradh
15:42:23 <lambdabot> rIAs7RAd|-|
15:42:32 <mornfall> what? :D
15:42:41 <ski> there is no lambdabot `seen' command
15:42:58 <mornfall> obviously it does something funny instead
15:43:11 <mornfall> I haven't seen him for a while, anyway.
15:43:39 <ski> Riastradh is a regular in #scheme (was in there some hours ago)
15:43:42 <nisstyre> lambdabot: how's things?
15:43:42 <mornfall> I also think I haven't been to #scheme for years.
15:44:01 <nisstyre> mornfall: /j #racket #scheme
15:44:14 <ski> (in older days, he also frequented #haskell)
15:44:23 <mornfall> ski: I remember that. :)
15:44:57 <mornfall> (that's why I tried to extract the info from lambdabot...)
15:45:20 <ski> i'd ask preflex, except preflex's not here either ..
15:45:27 <nisstyre> <rudybot> Riastradh was seen quitting six hours ago, saying "Ping timeout: 240 seconds", and then Riastradh was seen joining in #scheme forty-eight seconds ago
15:45:30 <mornfall> something is amiss
15:45:33 <ski> preflex: xseen preflex
15:45:59 <nisstyre> i.e. he just joined #scheme
15:46:01 <nisstyre> go talk to him now
15:46:49 <LQWEQWEIK> is lambdabot open-source?
15:47:21 <nisstyre> yeah
15:47:23 <ski> @version
15:47:23 <lambdabot> lambdabot 5.0-int-e
15:47:23 <lambdabot> git clone git://github.com/int-e/lambdabot.git
15:47:38 <LQWEQWEIK> thank you
15:47:44 <Heffalump> Clint: definitely ping lispy or someone on the committee, I'm not any more.
15:53:39 <maxiepoo_> how can I get all of the targets of a Traversal in a list?
15:53:57 <maxiepoo_> for Traversal' you can use toListOf
15:54:08 <maxiepoo_> but that doesn't work for a Traversal that changes type
15:55:45 * hackagebot concurrent-state 0.5.0.1 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.5.0.1 (JoelTaylor)
15:55:57 <clemux> ou produce a strange whistling sound.
15:56:00 <clemux> the rng does love me.
15:56:06 <ChongLi> nethack!
15:56:33 <Clint> lispy: might i suggest that SPI handle hpaste.org on behalf of haskell.org?
15:56:38 <Clint> byorgey: ^
15:56:52 <Clint> Heffalump: thanks
15:59:40 <maxiepoo_> oh wait you can't!
16:00:43 <lispy> Clint: We use SPI for handling money/donations.
16:00:45 * hackagebot concurrent-state 0.5.0.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.5.0.0 (JoelTaylor)
16:00:50 <jle`> is it a common idiom when i want to use a do block `p` in the middle of a call (runP p a b c)
16:00:57 <lispy> Clint: You're wanting them to handle domain names too?
16:00:59 <jle`> to do (\p -> runP p a b c) $ do ...
16:01:01 <jle`> ?
16:01:16 <jle`> instead of doing the anonying point-free-version with three flips
16:01:20 <jle`> idk i think it's kinda cute
16:01:51 <jle`> kind of like how people normally do flip runState initial $ do ...
16:02:06 <jle`> (\p -> runState p initial) $ do ...
16:02:25 <jle`> in this case it's harder to point-free-ize the lambda
16:03:16 <Clint> lispy: why not?
16:03:46 <clemux> You have a little trouble lifting n - a stethoscope.
16:03:58 <clemux> uh
16:04:01 <clemux> wrong chan.
16:04:11 <clemux> oh, and already wrong chan above
16:04:18 <clemux> I'm sorry. :/
16:04:25 <ChongLi> clemux: it's okay :)
16:04:44 <mornfall> that's some weird d&d :-]
16:04:49 <clemux> now I understand 00:54:19 < ChongLi> nethack!
16:04:57 <ChongLi> mornfall: it's nethack
16:05:09 <geekosaur> sounds like nethack and I haven't played it in years
16:06:04 <mornfall> ChongLi: I kinda thought he was a master and typing into a wrong window. :\
16:06:32 <roconnor> @botsnack
16:06:32 <lambdabot> :)
16:06:37 <ReinH> jle`: well, it's not particularly better but: runP ?? a ?? b ?? c $ do
16:06:49 <lispy> Clint: I'm trying to understand the request.
16:06:57 <jle`> (??) ?
16:07:01 <ReinH> from lens
16:07:05 <ReinH> :t (??)
16:07:05 <jle`> ah
16:07:06 <lambdabot> Functor f => f (a -> b) -> a -> f b
16:07:12 <lispy> Clint: is the request, "Someone official (in haskell.org land) should hold hpaste.org"?
16:07:13 <jle`> that seems...even less readable
16:07:17 <jle`> but it might just be me
16:07:26 <ReinH> so (r -> a - >b) -> a -> (r -> b)
16:07:47 <jle`> thanks though :)
16:07:51 <ReinH> lets you put a hole where the `a' is that you can fill in later
16:08:00 <jle`> oh hm that's interesting
16:08:02 <ReinH> jle`: it's not particularly readable in this case, no
16:08:09 <Clint> lispy: well, assuming that hpaste.org is going to be something useful to the community, then yes, that would have seemed like a better situation than the previous dysfunction
16:08:18 <jle`> i guess the ideal case would just be to pull out p and name it
16:08:33 <jle`> but it feels a little overkill in this case cause it's kinda throwaway
16:08:46 <Clint> lispy: but if not then i withdraw the suggestion
16:08:57 <ReinH> jle`: just write your own runningP a b c p = runP p a b c or so
16:09:04 <lispy> Clint: okay. We'll see what we can do. I think it makes more sense to have the haskell-infrastructure hold it instead of SPI.
16:09:11 <geekosaur> if we just want to keep hpaste.org alive and pointing to the right place I could probably do it ... but I think it would be more appropriate if someone official (and officially tracking it) did it
16:09:14 <geekosaur> rather than random people
16:09:31 <acowley> jle`: I'd bind it to a name like ReinH says, too
16:09:41 <jle`> bind the lambda, or bind the p?
16:09:49 <acowley> Either
16:10:05 <acowley> Whichever seem to look prettier
16:10:14 <jle`> both are kinda throwaway but i guess it is for the better.
16:10:18 <ReinH> jle`: it's a rather silly example of ?? but:
16:10:33 <ReinH> > fmap ?? [1,2,3] $ succ
16:10:35 <lambdabot>  [2,3,4]
16:10:39 <ReinH> jle`: see how the ?? looks like a placeholder?
16:10:40 <acowley> jle`: So you give it a crappy name indicating that it's a throwaway
16:11:04 <acowley> throwawaySeriouslyThisIsInsignificant a b c p = runP p a b c
16:11:05 <Clint> lispy: fair enough. spi used to get free domain registrations but that's no longer a factor.
16:11:06 <jle`> i just feel like giving it a name takes up some cognitive effort to see what's going on
16:11:15 <lispy> Clint: ah, cool
16:11:23 <jle`> ReinH: ah that's actually kinda neat
16:11:34 <jle`> sort of like an...inline continuation?
16:11:46 <ReinH> not really, just a clever name for a combinator
16:12:14 <ski> > (fmap `flip` [0,1,2]) succ
16:12:17 <lambdabot>  [1,2,3]
16:12:21 <ski> > (`fmap` [0,1,2]) succ
16:12:24 <lambdabot>  [1,2,3]
16:12:40 <acowley> I don't find multiple uses of ?? to be very readable, though
16:12:52 <shachaf> ski: The usual use case has an expression there.
16:12:59 <acowley> It is cute for a single use
16:13:06 <shachaf> "combinator" is a word people in #haskell use when they mean "function" or "thing"
16:13:11 <jle`> hahaha
16:13:14 * Clint chuckles.
16:13:30 <ReinH> ski: right, it's flip generalized to Functor :)
16:13:35 <ReinH> acowley: me neither
16:14:30 <ReinH> shachaf: I mean combinator in the sense of http://www.haskell.org/haskellwiki/Combinator_pattern
16:14:43 <mornfall> shachaf: they only call it that when it's written infix
16:14:53 <mornfall> or when it's used for parsing
16:14:56 <ReinH> although it also happens to be a combinator in the other sense of a function with no free variables
16:15:25 <shachaf> Small things that you put together to make big things?
16:15:33 <mornfall> :-)
16:15:39 <mornfall> ingenious
16:15:48 * ReinH shrugs
16:15:49 <shachaf> Well, what you wrote wasn't a big thing, so I guess it wasn't a combinator.
16:16:02 <ReinH> shachaf: ?
16:16:12 <mornfall> ReinH: he's making fun of you
16:16:20 <ski> > [succ,pred] `flip_` 6
16:16:22 <ReinH> mornfall: I'm familiar with this.
16:16:22 <shachaf> Not exactly.
16:16:22 <lambdabot>  [7,5]
16:16:44 <shachaf> ReinH: Can you name a function that isn't a combinator?
16:17:00 <ski> shachaf : `\y -> x' in `\x -> \y -> x' ?
16:17:16 <ReinH> shachaf: You realize that not every word has as precise a definition as the ones you find in math, right?
16:17:26 <ReinH> that doesn't mean that these words are meaningless either
16:17:44 <shachaf> ski: OK, so is every function every Haskell module exports a combinator?
16:17:47 <nisstyre> > sequence [succ,pred] 6
16:17:48 <lambdabot>  [7,5]
16:18:08 <ReinH> And flip is definitely one of the named combinators, although I can't remember which off hand
16:18:39 <mornfall> ReinH: ask ski :D
16:18:45 <ski> shachaf : obviously yes :)
16:19:08 <ski> (also non-functions, since obviously `empty :: Doc' is also a combinator)
16:19:34 <Zettablade> what's the best frp gui library for haskell?
16:19:35 <shachaf> ReinH said "function", so I went with that.
16:19:41 <shachaf> Anyway I'm not making fun of ReinH..
16:19:43 <shachaf> s/.$//
16:19:55 <jle`> my loose definition of combinator is basically some sort of h.o.f. with certain semantics
16:20:35 <ReinH> shachaf: I meant a combinator in both senses used by http://www.haskell.org/haskellwiki/Combinator and also in the sense used in combinatory logic, i.e. To Mock a Mockingbird
16:20:41 <ski> mornfall : hm, Cardinal, i think
16:21:16 <dgpratt> occasionally the term for a thing depends on the context
16:21:29 <mornfall> we already had functor in here today
16:21:31 <ReinH> I feel like that's a pretty valid basis for calling (??) a combinator
16:21:56 <ski> (m, yes. "To Dissect a Mockingbird: A Graphical Notation for the Lambda Calculus with Animated Reduction" by David C. Keenan in 1996-08-27 - 2012-12-30 at <http://dkeenan.com/Lambda/>)
16:21:57 <jle`> do you guys always put the ($) as far to the right as possible
16:22:09 <johnw> jle`: it depends on what's needed
16:22:15 <jle`> sometimes i put it to the second to right most spot if it is possible
16:22:19 <jle`> johnw: "if possible"
16:22:29 <jle`> maybe i should say unless needed otherwise
16:22:39 <johnw> i mean, when replacing parens with $, there is always a correct place
16:22:40 <acowley> No not every function you export is a combinator. They will often refer to imported identifiers.
16:22:47 <johnw> foo bar (baz foo) -> foo bar $ baz foo
16:23:00 <jle`> not foo bar . baz $ foo ?
16:23:09 <johnw> oh, I see what you mean
16:23:13 <johnw> in that case, probably not
16:23:13 * ski 'd probably prefer `foo bar (baz foo)'
16:23:54 <clemux> damn
16:23:55 <jle`> right now i have return (unpack (unlines t))
16:23:55 <Cale> It depends on my mood. I don't mind just leaving parens if there's just one and the ( isn't too far from the )
16:23:56 <ski> (or maybe `(foo bar . baz) foo')
16:23:58 <jle`> but you could imagine something deeper
16:23:59 <clemux> soldier ants and mumak in minetown
16:24:06 <jle`> should i do return . unpack . unlines $ t ?
16:24:10 <jle`> or return . unpack $ unlines t ?
16:24:10 <clemux> I have the choice between apron and cloak of displacement
16:24:10 <clemux> mhh
16:24:24 <jle`> or return $ unpack (unlines t)
16:24:26 <jle`> heh
16:24:26 <Cale> In that case, I'd probably write the former even, but the latter is good too
16:24:29 <clemux> damn!
16:24:33 <clemux> again wrong chan
16:24:34 <geekosaur> clemux, you are srtill in the wrong channel
16:24:35 <geekosaur> geg
16:24:36 <clemux> I'm really sorry
16:24:37 <geekosaur> heh
16:24:37 <jle`> the former as in the fully parenthesized version?
16:24:41 <acowley> hahaha
16:24:43 <ski> jle` : `return (unpack (unlines t))' is fine, imo
16:24:45 <clemux> cya :p
16:24:46 <mornfall> acowley: you can substitute those things in
16:24:57 <jle`> what about something...deeper
16:24:57 <Cale> I mean  return . unpack . unlines $ t
16:25:00 <acowley> I keep trying to parse clemux's remarks into Haskell
16:25:01 <mornfall> acowley: those variables aren't "free"
16:25:09 <jle`> yeah i like r . u . u $ t
16:25:11 <jle`> because it feels like
16:25:13 <jle`> a composition
16:25:16 <jle`> of r, u, and u
16:25:22 <acowley> mornfall: I suppose it depends on what you consider the expression to be
16:25:30 <jle`> and i feel more functional/haskelly
16:25:33 <acowley> mornfall: If I show you the expression, \x -> foo x
16:25:36 <geekosaur> I am occaisonally surprised that we don't see more leakage from ##crawl in here, considering the overlap :p
16:25:36 <acowley> Is foo free?
16:25:37 <jle`> cause i'm using function compositions, i'm so cool
16:25:44 <ski>   (r . u . u . \() -> t) ()
16:25:57 <Cale> ski: hehe
16:26:07 <mornfall> acowley: yes, but you can't export that
16:26:15 * ski sometimes likes to put a lambda on the right of a `.'
16:26:49 <johnw> jle`: personally, I like: return $ unpack (unlines t)
16:26:53 <Cale> jle`: Well, there are lots of good things about function compositions
16:27:06 <johnw> I like to use $ as a "transition barrier" between monadic and non-monadic code when I can
16:27:12 <jle`> johnw: that's interesting
16:27:22 <Cale> It's an associative operation, so it's easy to chop up any way that you like
16:27:33 <johnw> I tend to use "return $" very often
16:27:33 <Cale> (when you have a chain of them)
16:27:34 <jle`> woo hoo category laws
16:28:01 <jle`> put to good use
16:28:02 <acowley> mornfall: Ah! Good point. But then we just need a different word to mean what combinator already means without the baggage of module imports/exports.
16:28:21 <mornfall> application isn't associative, let's ban it
16:28:39 <ReinH> oh, flip is the C combinator. Cfxy.fyx. Duh.
16:28:41 <jle`> i guess the answer is use $ at mental barriers?
16:28:51 <Cale> jle`: Well, that's johnw's answer
16:28:55 <Cale> I don't do that myself
16:28:59 <jle`> well
16:29:03 <jle`> when you do r . u . u $ t
16:29:07 <jle`> you are sort of mental barrier-ing
16:29:15 <jle`> the value, and the functions that are being composed
16:29:19 <shachaf> This meaning of "combinator" is pretty useless in this context because every value is a "combinator".
16:29:26 <ReinH> I know some people prefer (r . u . u) t for that
16:29:27 <shachaf> It's something that applies to expressions, not values.
16:29:29 <ReinH> like chrisdone
16:29:50 <mjrosenb> does lambdabot have a primes value defined?
16:29:56 <ReinH> I like that (f . g . h) x is a hint that maybe I should extract f . g . h and give it a meaningful name
16:30:00 <Cale> mjrosenb: No, but I can make one for you
16:30:03 <Cale> > primes
16:30:04 <shachaf> @where primes
16:30:04 <lambdabot> let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p^2 <= n) primes) in primes
16:30:06 <lambdabot>  Not in scope: `primes'
16:30:07 <mgsloan> I think chrisdone mostly prefers (r (u (u t))), but not 100% sure
16:30:17 <shachaf> @@ @let primes = @where primes
16:30:18 <Cale> ah, cute, it's the one I like to type :)
16:30:19 <lambdabot>  Defined.
16:30:26 <jle`> ReinH: i feel like that's the kind of thing that r.u.u$t sort of implies too
16:30:35 <mjrosenb> > take 10 primes
16:30:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29]
16:30:42 <ski> ReinH : and me
16:30:42 <Cale> > primes
16:30:45 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
16:30:55 <jle`> > last primes
16:30:58 <ReinH> mgsloan: https://github.com/chrisdone/haskell-style-guide#operators
16:30:59 <lambdabot>  mueval-core: Time limit exceeded
16:31:01 <Cale> > drop 1000 primes
16:31:02 <jle`> aw
16:31:03 <lambdabot>  [7927,7933,7937,7949,7951,7963,7993,8009,8011,8017,8039,8053,8059,8069,8081,...
16:31:08 <ReinH> he's one of those "never use $" extremists ;)
16:31:11 <Cale> > drop 10000 primes
16:31:14 <lambdabot>  [104743,104759,104761,104773,104779,104789,104801,104803,104827,104831,10484...
16:31:28 <jle`> does he ever use forM_ then?
16:31:33 <mornfall> ReinH: not using $ goes with teaching Haskell to freshmen
16:31:35 <hpc> haha, was just about to ask that
16:31:35 <dgpratt> not that anyone should care, but I too have decided I dislike using $ to elide parentheses
16:31:39 <johnw> ReinH: it's more like structured-haskell-mode is more friendly with parens
16:31:52 <ReinH> johnw: heh also that
16:32:02 <ReinH> johnw: well it is a bastardisation of paredit, so... ;)
16:32:12 <hpc> dgpratt: yeah, there's a sort of zen to proper use of ($) and parens
16:32:15 <ReinH> (I pretty awesome bastardisation, at that)
16:32:27 <ski> ideally, `foo \x -> ...',`foo do ...',`foo if ... then ... else ...',`foo let ... in ...',`foo case ... of ...' should all be valid
16:32:28 <Twey> chrisdone wishes Haskell were a Lisp, though
16:32:35 <johnw> i really like $ with lambdas too
16:32:37 <Cale> The keys are all so strange ;__;
16:32:38 <ReinH> hpc: yeah, I'm finding myself approaching Bird's style more and more
16:32:43 <johnw> forM_ xs $ \x -> ...
16:32:44 <ReinH> less (but not no) use of $
16:32:50 <ski> though the first two are the ones what'd see most use
16:32:53 <hpc> i find myself using parens more and more, but i am due for cycling back to ($) any day now
16:32:57 <ski> s/what/that/
16:33:00 <Cale> At some point I might try remapping all the keys in his structured-haskell-mode and see if I can make it usable
16:33:05 <mgsloan> Yeah, I remember when I was poking chrisdone about not having spaces after his commas, and he said "it's in the style guide!".  I'm like "No it's not!", and he's like "Sure it is!".  Sure enough, he'd made a style guide 5 hrs earlier >.<
16:33:14 <ReinH> mgsloan: haha
16:33:14 <Cale> There's no way I can be convinced that C-j is easier to type than Enter
16:33:16 <jle`> mgsloan: hahaha
16:33:18 <johnw> is there any way to make use of any lazy I/O a compile-time error?
16:33:27 <johnw> Cale: SAME
16:33:33 <ReinH> mgsloan: I can't deal with the no spaces after commas thing.
16:33:38 <mjrosenb> > let rtrunc x = x `div` 10; allRTruncs = filter (\p -> p < 10 || (rtrunc p) `elem` (takeWhile (<= rtrunc p) allRTruncs)) primes in allRTruncs
16:33:42 <lambdabot>  mueval-core: Time limit exceeded
16:33:44 <johnw> Cale: I always bind Ret to mean what chrisdone uses C-j for
16:33:53 <mgsloan> ReinH: Yeah, I have trouble reading it, and I still haven't gotten a reason for it
16:33:57 <jle`> well i mean...the default Show instance for lists
16:34:00 <jle`> doesn't have spaces
16:34:12 <hpc> > "yes it does" -- ;)
16:34:14 <lambdabot>  "yes it does"
16:34:15 <mjrosenb> Cale: but I really wish the ghci repl supported C-o :-(
16:34:20 <ReinH> I think C-j is for people who have been using emacs for at least 2 decades
16:34:20 <maxiepoo_> hey is there a function in lens like :: Traversal s t a a -> [a]
16:34:24 <jle`> > [1, 2, 3]
16:34:25 <lambdabot>  [1,2,3]
16:34:30 <Cale> The other thing I need to try is to see if I can disable all the features of structured-haskell-mode *except* for the auto-reindenting
16:34:35 <shachaf> maxiepoo_: Do you mean with an s argument?
16:34:36 <jle`> Cale: haha
16:34:40 <johnw> ReinH: I've been using it a fair bit longer than that
16:34:42 <Cale> and then just set my tab key to insert two spaces
16:34:46 <mornfall> Cale: you have ctrl in the wrong place
16:34:54 <maxiepoo_> shachaf: yes
16:34:56 <shachaf> maxiepoo_: toListOf or (^..)
16:34:57 <ski> mgsloan : i don't (generally) write spaces after commas, either
16:34:58 <mjrosenb> > let rtrunc x = x `div` 10; allRTruncs = filter (\p -> p < 10 || (rtrunc p) `elem` (takeWhile (<= rtrunc p) allRTruncs)) (take 1000 primes) in allRTruncs
16:35:00 <lambdabot>  [2,3,5,7,23,29,31,37,53,59,71,73,79,233,239,293,311,313,317,373,379,593,599,...
16:35:06 <mirpa> If 'cabal install PKG' in sandbox fails, can I open source code, correct error and recompile PKG with my changes?
16:35:09 <ReinH> johnw: fair enough
16:35:10 <mgsloan> ski: What's that come from?
16:35:17 <maxiepoo_> shachaf: I mean with an s and a t
16:35:19 <ski> (in fact, i probably more commonly write it *before* spaces (for alignment purposes))
16:35:19 <maxiepoo_> different
16:35:22 <mornfall> Cale: everyone knows that the correct place for C- is capslock
16:35:25 <Cale> mornfall: I realise that it should probably be on a foot pedal
16:35:39 <ReinH> Yeah, I map capslock to ctrl
16:35:40 <Cale> Caps Lock is compose for me
16:35:41 <mornfall> Cale: no that's for super and hyper
16:35:42 <shachaf> maxiepoo_: Hmm?
16:35:44 <geekosaur> mirpa: cabal unpack PKG; cd PKG; fix; cabal install
16:35:45 <ReinH> and then SUFFER on machines that don't
16:35:46 <mjrosenb> so, is there any way of fixing this to not require (take 1000 primes), *and* the takeWhile?
16:35:47 <mgsloan> ski: Gotcha, yeah, sometimes I will put spaces before for alignment, fair 'nough
16:35:50 <ski> mgsloan : i don't know where the custom of writing a space after a comma comes from
16:35:58 <mirpa> geekosaur: thanks :-)
16:36:00 <hpc> mirpa: sure; you generally want to offer a patch to the maintainer too, so you don't have to keep your own branch and so others can benefit from your work
16:36:00 <mornfall> ReinH: just don't use others' puny machines
16:36:00 <Twey> I don't understand the prefix-comma thing.  I remember someone once said it was technically superior because it let you cut-and-paste lines around more easily, but that doesn't seem to be the case: people always write things like [ foo (or [foo in chrisdone's case) on the first line, so you still have a ‘special’ line that can't be moved around just like with the more natural end-of-line comma
16:36:02 <ReinH> but at least I don't have RSI
16:36:07 <Maior> I have an Array of Strings, is there a nice function for doing fast "is this String in here"?
16:36:13 <shachaf> maxiepoo_: The s and the t should always unify.
16:36:13 <ReinH> mornfall: believe me I try not to
16:36:33 <Cale> Twey: I agree. I tend to put commas at end of line
16:36:46 <mirpa> hpc: there doesn't seems to be public repo...
16:36:55 <Cale> Unless someone else is already doing it the other way
16:36:59 <ski> (the proper place for the left control is at the leftmost position of the homerow)
16:37:05 <hpc> what package is it?
16:37:05 <mornfall> ReinH: I type dvorak anyway, with custom national hacks; no way I can use Someone Else's Keyboard
16:37:09 <Twey> It would be nice if we could allow a leading/trailing comma; then we could really make all the lines uniform
16:37:14 <Twey> Even C has this :þ
16:37:24 <maxiepoo_> shachaf: ?
16:37:31 <mirpa> hpc: elerea-examples
16:37:36 <shachaf> maxiepoo_: I might say the same thing.
16:37:47 <mgsloan> Twey: Agreed!  Tubad about tuple sections
16:38:01 <ski> Cale,Twey : it looks prettier to line the commas up (with `[',`(',`{', say), rather than having them at the end of the lines
16:38:02 <shachaf> maxiepoo_: Is there a concrete case where toListOf doesn't do what you want?
16:38:07 <Cale> I don't really like my Ctrl key to be there. I prefer to have it in the corner, but Caps Lock is pretty useless, so I remap that to X's Compose.
16:38:12 <Twey> mgsloan: Tuple sections require round brackets, so I don't think it's a concern
16:38:26 <ski> Twey,Cale : also, it's more work to maintain alignment with commas at the end of the lines
16:38:26 <yayutf> ski: i've always found that incredibly ugly; aesthetics are odd
16:38:37 <Cale> ski: huh?
16:38:40 <mornfall> Cale: capslock is the only homerow modifier... it's PRECIOUS
16:38:44 <mgsloan> Twey: Well, it'd be kinda non-uniform to allow leading/trailing commas in some places and not others
16:38:45 <maxiepoo_> I was trying to define a traversal that would mark identifiers in an ast as a binding occurrence vs a bound occurrence
16:38:57 <Twey> ski: How so?  You just line up the beginnings of the lines normally
16:39:07 <mornfall> Cale: alt and altgr, you can easily reach with thumbs, but not ctrl
16:39:16 <mgsloan> maxiepoo_: Ooh, that's cool!  Would be nice for refactorings if you had a good pretty printer
16:39:18 <hpc> mirpa: https://github.com/cobbpg/elerea - that's just the code though; you can use the maintainer email to contact him - MaintainerPatai Gergely (patai@iit.bme.hu)
16:39:20 <shachaf> maxiepoo_: (Maybe better to talk in #-lens? I've already lost your question.)
16:39:24 <mornfall> Cale: (and meta if you map it on the windows key)
16:39:26 <Twey> mgsloan: Oh, right, for multi-line tuples.  Hrmph.
16:39:28 <ski>   (blah  ,
16:39:31 <ski>    foobar,
16:39:32 <ski>    baz   )
16:39:41 <Twey> ski: Ick, why?
16:39:46 <ski> Twey : exactly, why ?
16:39:48 <hpc> (foo,
16:39:51 <hpc>  bar,
16:39:52 <hpc>  baz,
16:39:53 <hpc> )
16:40:01 <mirpa> hpc: I'll see what can I do...
16:40:02 <Twey> (foo,
16:40:05 <Twey>  bar,
16:40:05 <mgsloan> so many styles to choose from
16:40:07 <Twey>  baz)
16:40:08 <begriffs> Question about cabal build: why is it generating binaries in two places? Check out the resulting directory structure after I run a build. https://gist.github.com/begriffs/8589856
16:40:09 <ski>   (blah
16:40:12 <ski>   ,foobar
16:40:15 <ski>   ,baz
16:40:16 <ski>   )
16:40:17 <ReinH> maxiepoo_: I don't think you can do much better than Data.Foldable.any (==e)
16:40:18 <ski> is much better
16:40:22 <ReinH> woops
16:40:27 <ion> ( foo
16:40:28 <mornfall> ski: ugly!
16:40:29 <Twey> ski: That just looks like you're trying to unquote a macro :þ
16:40:29 <ion> , bar
16:40:29 <yayutf> ski: i wince, looking at that
16:40:30 <mornfall> burn
16:40:33 <ion> )
16:40:43 * mgsloan likes the ion style
16:40:49 <Twey> ski: *And* you have that ) sitting on its own, taking up a whole line to no good purpose
16:40:50 <ski> ion : also ok
16:40:50 <Cale> mornfall: I don't use a lot of key combinations involving Ctrl apart from Ctrl-X/C/V for clipboard stuff, and I guess Ctrl-space for switching SCIM modes.
16:40:56 <mornfall> nonono, no trailing ) on its own line!
16:41:10 <ReinH> Maior: I don't think you can do much better than \a -> Data.Foldable.any (==a)
16:41:18 <hpc> )))))))))))) ;; i love lisp!
16:41:24 <mornfall> Cale: I see... I use ^h instead of backspace all the time
16:41:30 <ReinH> Maior: if you need to check for inclusion a lot, maybe you want a data structure optimized for doing so?
16:41:34 <mornfall> Cale: and ^w for back-word
16:41:38 <Twey> This is one of the things I hate most about the C/Java style: half the code file is made up of single } characters on lines of their own (and { characters too, in the GNU style)
16:41:51 <ski> Twey : if there's only a couple of components, i often place the `)' at the end of the last line (indented properly). for many, it goes on a line of its own
16:41:58 <mornfall> Cale: (also, h is in the homeliest of home positions on dvorak)
16:42:05 <ski>   (blah
16:42:09 <ski>   ,foobar
16:42:10 <ski>   ,baz   )
16:42:17 <Maior> ReinH: ooh that looks interesting
16:42:21 <hpc> Twey: it helps when you get saddled with one of those codebases where a function is 3 screens tall and halfway through the indentation goes 4 levels to the left
16:42:28 <ReinH> Maior: it's just any . (==)
16:42:37 <ion>   (blah  ,
16:42:37 <hpc> (ahem, mailman, ahem)
16:42:39 <ion>   ,foobar,
16:42:41 <Maior> ReinH: ah, mm
16:42:42 <ion>   ,baz   )
16:42:44 <ion> ;-)
16:42:49 <Twey> hpc: No, C-x h C-M-\ helps with that :þ
16:43:02 <Maior> ReinH: I need a fast-to-build datastructure with fast search - fortunately my data is pre-sorted
16:43:09 <Twey> ski: Doesn't starting the line with a comma make you cringe?  >.<  Commas don't go at the beginning of things.  It's just not natural.
16:43:10 <ski> Cale : M-b,M-f,M-d,M-DEL is quite useful
16:43:20 <ReinH> Maior: then you can binary search, but why not use a Map or similar?
16:43:22 <hpc> <Twey> hpc: No, ℵλj∇hℵi∩Ωi∈iΩ∩ helps with that" -- what i read
16:43:26 <Twey> They just sort of trail at the ends of words.
16:43:28 <Maior> ReinH: hence was thinking binary search on Data.Array
16:43:28 <Cale> ski: I don't know what any of that is
16:43:40 <Maior> ReinH: the map takes too long to build
16:43:44 <Twey> hpc: ‘Select all, reindent region’
16:43:50 <ski> Cale : move by word backward and forward, delete word forward and backward
16:43:53 <kazagistar> if everyone isn't using autoformatting in your java code base, you have a seriously crazy team
16:43:59 <mornfall> Maior: it is sorted?
16:44:00 <hpc> Twey: oh, i just meant for reading
16:44:05 <mornfall> Maior: why would you need a set for sorted lines?
16:44:06 <Maior> mornfall: yep
16:44:06 <Twey> hpc: So did I :þ
16:44:08 <hpc> (also mailman is python so no auto indentation for you)
16:44:12 <Cale> ah, I don't bother with that. Backspace and delete and arrow keys are good enough for me :)
16:44:19 <mornfall> Maior: all dups are going to be consecutive in a sorted file
16:44:22 <Maior> mornfall: because elem existed and was convenient
16:44:28 <Cale> If I have to delete something larger, I'll just select it with the mouse.
16:44:32 <qrada> hey, going to add some getopt style flags to my code.. is there anything recommended over System.Console.GetOpt? just wondering before i implement
16:44:40 <Twey> Cale: Moving by words really speeds up your editing IME
16:44:52 <Twey> It's very worthwhile to get used to it
16:44:55 <mornfall> Twey: immensely...
16:44:58 <Maior> mornfall: and I wanted a constant/log search
16:45:00 <ski> Twey : "Doesn't starting the line with a comma make you cringe?" not at all ; "Commas don't go at the beginning of things.  It's just not natural." -- feels perfectly natural to me
16:45:00 <mornfall> Twey: also, lines (dd)
16:45:14 <hpc> qrada: i remember asking something similar and getting an answer for one that's better
16:45:15 <Twey> ski: Doesn't really feel all that natural ,to me ;)
16:45:25 <hpc> qrada: but i also remember not caring because that was in base and did what i needed, so eh
16:45:31 <Twey> mornfall: Well, I presume Cale does that
16:45:36 <qrada> ya
16:45:41 <qrada> that's what im thinking to
16:45:42 <qrada> too
16:45:44 <yayutf> Twey: plenty of non-native english speakers use commas that way; some languages do. it's all bikeshedding by now, anyhow
16:45:48 <begriffs> Oh I answered my own question. cabal install creates the dist-sandbox-xxxx folders, whereas cabal build uses plain old dist
16:45:51 <mornfall> Cale: when I land in an editor that I can't use, I drop to half-speed ... cursor keys are extremely awkward
16:45:56 <qrada> cool thanks.. i remember seeing something in some code called "Flag" i think.. dno tho
16:45:56 <ReinH> Maior: you can binary search an Array in log n
16:46:01 <Twey> yayutf: Wha'?  I don't know of any language that puts the comma before a word
16:46:12 <mornfall> Cale: not being able to move around quickly makes me cry
16:46:29 <Maior> ReinH: exactly
16:46:30 <Twey> I guess German has those ‚quotes‘
16:46:37 <Twey> But that's not really the same thing
16:46:37 <hpc> yayutf: interrobang is the one true record separator
16:46:40 <Maior> ReinH: I wondered if I'd have to write it myself though
16:46:45 <mornfall> Twey: and we have „quotes“ like this :-)
16:46:55 <Twey> Yeah
16:47:00 <Twey> That's okay though
16:47:15 <Cale> If it wasn't code that I was editing all the time, I might bother to learn to use my text editors better.
16:47:20 <ReinH> Maior: you might also try vector
16:47:33 <mornfall> Cale: it makes more sense in code than anywhere else
16:47:36 <yayutf> Twey: rtl languages, in particular; some people carry the comma position over into ltr ones
16:47:55 <mornfall> Cale: it's a well-known fact that when you program you spend more time moving around than typing
16:47:55 <Maior> ReinH: cheers
16:48:03 <yayutf> it's not technically 'before' in an rtl language, but it visually looks that way, and in english it then is before
16:48:15 <ski> mornfall : i always thought such quotes looked perverse (like an attempted mix with an open-unquote with a close-quote)
16:48:16 <hpc> mornfall: and vastly more time thinking than doing either of those two things
16:48:25 <Twey> mornfall: ”Finnish” is the one that bugs me.  It's *almost* the same as English, but the quotes don't balance.  -.-
16:48:26 <pranz> in languages with dependent types like Idris, can you "prove" that normal functins behave in such a way?
16:48:34 <Twey> yayutf: Ah, interesting
16:48:35 <ReinH> Maior: it's a pretty direct translation of your standard binary search algo
16:48:37 <Cale> mornfall: I usually spend at least a factor of 10 more time thinking about what I'm going to do than actually doing it, so there's plenty of time there to move around.
16:48:39 <hpc> (except in java ofc - there you spend most of your time in the refactor gui lol)
16:48:40 <shachaf> ski: Naturality is certainly related to comma categories.
16:48:44 <mornfall> hpc: I often intersperse thinking with moving... or with showering :-)
16:48:47 * ski nods gravely
16:48:53 <mornfall> hpc: (moving around code to find definitions, etc.)
16:48:54 <pranz> for example if I wanted to make a functor typeclass, but where you also needed to provide proof that fmap followed functor laws
16:48:59 <Twey> pranz: Yes: usually you can prove things by the definition of the term
16:49:21 <Maior> ReinH: I suspect I'll then get hit at creation time
16:49:52 <mornfall> Cale: well, your working memory is like a CPU cache... small and fast
16:49:54 <ReinH> Maior: well, how often are you creating these structures vs searching them?
16:50:05 <ReinH> you probably want a heap or tree if you can get away with it
16:50:10 <mornfall> Cale: a fast interface to external storage (text editor) makes you more efficient, IMHO
16:50:13 <ReinH> and constructing same from sorted data can be faster
16:50:35 <mornfall> Cale: (if you didn't need external storage you'd never move around in a program, you'd make it in your head and type it out linearly)
16:50:44 <Cale> The way I see it, it's kind of like an Amdahl's law of writing code. Sure you can speed up the time that it takes you to type the code in, but that was never the part which took any time anyway.
16:51:12 <Cale> and in parallel with that, you're still thinking about the problem you're faced with and how to solve it
16:51:45 <intrados> Did http-conduit (which apparently changed to http-client) lose TLS support or am I missing something? http://hackage.haskell.org/package/http-client-0.2.1/docs/Network-HTTP-Client.html#v:managerTlsConnection
16:51:50 <Cale> (unless you're worrying about how best to use your text editor to make the changes, in which case, that's helping even less)
16:51:54 <ReinH> Maior: you might try a HashSet too
16:51:54 <mornfall> Cale: also, mechanisation of that movement is maybe even more important, because it enables the parallelism you mention
16:52:00 <Twey> pranz: Effectively, you have access to the equations that make up the definition.  So if you have fmap = map for lists, and you want to prove that fmap id ≡ id, fmap id reduces to map id reduces to (\ y → case x of [] → []; (x : xs) → id x : map id xs) and then you get to prove that for each branch
16:52:01 <hattmammerly> so I have a type here. data T = A Int | B Int - might I ignore the type constructor in a function somehow? let f (_ i) = yadda yadda
16:52:14 <Twey> Er, case y of …
16:52:21 <Cale> What I'm saying is, focusing on the text editing is pointless because it's not the slow part.
16:52:32 <mornfall> Cale: but if you need to start using eyes to find cursor pad, that takes away precious resources from problem solving
16:52:41 <Cale> ?
16:53:05 <mornfall> eyes takes a lot of bandwidth :D
16:53:07 <mornfall> take*
16:53:08 <Cale> I can find my cursor keys and mouse by feel pretty well, and I actually usually remove my hands from the keyboard altogether quite often while programming.
16:53:28 <mornfall> hm, I often remove myself from the computer
16:53:35 <Cale> yes
16:53:38 <Cale> me too
16:53:49 <ReinH> hattmammerly: pedantic note: A and B are data constructors, not type constructors :)
16:53:55 <mornfall> depends on what you are doing though
16:54:03 <hattmammerly> ReinH: yes, pardon me haha
16:54:07 <Cale> Making changes to the text file a little bit faster isn't really going to serve much purpose.
16:54:07 <mornfall> debugging C++ can be pretty demanding on the computer<->human interface
16:54:41 <Cale> (It'll just clutter my head with arbitrary facts about how to manipulate text which I'd rather not be bothered with)
16:54:50 * dcoutts_ imagines mornfall smashing the keyboard with a brick
16:55:08 <hattmammerly> ReinH: do you know if it's something that can be done cleanly? pattern matching didn't seem to do it
16:55:13 <mornfall> Cale: well, I think the point of using an editor efficiently is to *not* think about it
16:55:22 <mornfall> dcoutts_: a brick?
16:55:25 <dcoutts_> mornfall: or is that not what you meant? :-)
16:55:26 <Cale> Yeah, maybe in C++ or something where the concrete language syntax is garbage, but I don't program in C++ :)
16:55:26 <yayutf> mornfall: but you -do-, just not as consciously
16:55:28 <Maior> ReinH: tried HashSet already; trying Vector now, cheers :)
16:55:53 <dcoutts_> mornfall: brick, hammer, tea cup, whatever comes to hand in a moment of frustration :-)
16:56:04 <ReinH> hattmammerly: I guess you could make your T a Bifunctor
16:56:06 <mornfall> dcoutts_: I'm pretty calm when debugging :D usually
16:56:12 <mornfall> even C++ :P
16:56:17 <dcoutts_> mornfall: even C++, wow
16:56:35 <mornfall> yayutf: there's a huge difference between declarative and procedural "thinking"
16:56:44 <acowley> I find that hitting the keyboard with a mornfall is pretty productive
16:57:20 <ReinH> > join bimap succ (Left 1) -- hattmammerly
16:57:22 <lambdabot>  Left 2
16:58:05 <mornfall> yayutf: imagine explicitly, declaratively thinking about how to twist your tongue to make every phoneme in English
16:58:31 <mornfall> yayutf: you wouldn't get anywhere
16:59:21 <yayutf> mornfall: I came across a study a few months ago which basically said that keyboard shortcuts had more cognitive overload than people tend to think, but unfortunately I can't find it
16:59:27 <ReinH> hattmammerly: but probably you are better off just writing your f (A x) and f (B x) cases
16:59:58 <ReinH> I wonder if there's something from lens
17:00:08 <yayutf> mornfall: I've declaratively tried that; it is indeed awful. I'm not arguing that internalizing actions into muscle memory isn't a win compared to declaratively doing them
17:00:09 <mornfall> yayutf: that very much depends on what you mean with a shortcut
17:00:33 <hpc> and it depends on what the shortcuts do
17:01:12 <yayutf> mornfall: iirc, it was unix-text-editor keybindings, but I could well be wrong
17:01:29 <hattmammerly> well shoot, I don't erally know much about category theory haha. ReinH I suppose I'll do that. thanks!
17:02:23 <mornfall> yayutf: so was the argument it's more efficient to use a mouse?
17:02:40 <mornfall> yayutf: what is the alternative to keybindings?
17:02:45 <mornfall> different keybindings?
17:02:48 <ReinH> hattmammerly: oh, how about...
17:02:50 <ReinH> > join either succ (Left 1)
17:02:51 <lambdabot>  2
17:03:19 <acowley> mornfall: Use a Wiimote
17:03:32 <mornfall> acowley: shoot that function out of the sky, now!
17:03:45 <mornfall> oops, not that one
17:04:06 <ReinH> hattmammerly: you'll have to write your own version of either for T but it'll be a nice way to abstract "apply f to either A or B"
17:04:23 <acowley> I don't understand the argument against being efficient with your editor
17:05:07 <Cale> acowley: It just doesn't seem like it's something worth spending time on to me.
17:05:13 <yayutf> mornfall: I've failed to recall that bit as well, unfortunately
17:05:34 <merijn> yayutf: That study sounds dubious
17:05:51 <Cale> If it's a choice between learning something about my text editor and learning something about pretty much anything else, I'll take the anything else :P
17:05:52 <merijn> yayutf: Given how subconcious most vim movements have become to me
17:05:53 <yayutf> merijn: I doubt I've said enough about it for that to be a reasonable conclusion, though it might be :-)
17:06:08 <acowley> Cale: It's far from the most dominant factor to your productivity, but it's still a factor
17:06:33 <acowley> Cale: Go watch people who program by typing into Notepad, then email themselves source to move it to a server or something
17:06:33 <joneshf-laptop> hattmammerly, ReinH i could've sworn this was discussed a few days ago, i'll try to check
17:06:41 <mornfall> Cale: yeah, bent functions!
17:06:44 <acowley> Cale: All these little parts of a workflow add up
17:06:56 <Cale> acowley: The only problem I have with Notepad is that it doesn't expand tabs
17:06:59 <joneshf-laptop> byorgey, so yeah, your point about inverses not existing often is something i've been wondering about more lately
17:07:20 <yayutf> acowley: yes, but there's certainly a point of diminishing returns, where you're getting distracted from an algorithm trying to remember a 5-key sequence you use 3 times a year
17:07:31 <Twey> Cale: You're okay with it randomly corrupting your files and not understanding \n linebreaks?  :þ
17:07:33 <merijn> yayutf: It was more that cognitive overload suggests thinking about shortcuts, but in vim most have become so basic I basically never think about actual keys anymore
17:07:38 <joneshf-laptop> byorgey, it makes me wonder if we'r enot missing out on a whole bunch of constructs because of our lack of inverses
17:07:41 <acowley> Cale: You don't find syntax highlighting helpful either?
17:07:48 <mornfall> Cale: your heroes must be Dijkstra and Pike ;-)
17:07:55 <merijn> yayutf: When people ask me "how did you do that?" I have to rewind and slowly repeat my keys to figure out what I did
17:08:01 <Cale> acowley: Well, syntax highlighting is nice, but I don't think it's *essential*
17:08:18 <acowley> yayutf: That's like learning anything. I could take the short term win and do something dumb, or I could learn a better way of working and increase my efficiency 2x
17:08:20 <yayutf> merijn: yes; that's the sensation people have
17:08:24 <byorgey> joneshf-laptop: I wouldn't put it that way.  That makes it sound like it's a "problem" that we don't have inverses, and we ought to "fix" it.
17:08:30 <Twey> I find it kind of silly that we're still editing code as text in 2014
17:08:33 <byorgey> joneshf-laptop: I'm saying it's just *the way things are*
17:08:45 <merijn> Twey: Go contribute to lamdu! ;)
17:08:54 <ReinH> joneshf-laptop: hmmm :)
17:08:54 <hattmammerly> ReinH: huh, that's interesting. I'll give that a shot!
17:08:58 <Twey> I would, if I knew what needed contributing to
17:09:00 <yayutf> acowley: erm... if it's something you'll use 3 times a year, you're unlikely to double your productivity by optimizing it
17:09:04 <Twey> Peaker: Do you have anything you need done?
17:09:28 <merijn> Twey: I thought there was a wishlist somewhere, but I forgot
17:09:35 <joneshf-laptop> byorgey, i didn't mean to say that there's anything wrong with the structures we have now
17:09:37 <acowley> yayutf: I don't know any 5-key sequences I use 3 times a year.
17:09:41 <Twey> The GH issue tracker is empt
17:09:43 <Twey> y
17:10:16 <joneshf-laptop> byorgey, sort of like how the natruals don't have inverses. I wouldn't suggest there was something bad about that, just that there's only so much you can do with just naturals
17:10:33 <mornfall> joneshf-laptop: inverses where (I must have missed the start)?
17:10:34 <joneshf-laptop> byorgey, bearing in mind that you can do A LOT with just naturals
17:10:48 <joneshf-laptop> mornfall, the latest haskellcast
17:10:50 <yayutf> acowley: I use vim, dvorak, etc. knowing how to use classical unix utilities is a huge productivity boost; details of my text editor aren't, past a certain point
17:11:00 <joneshf-laptop> mornfall, it was more a passing comment than the subject of debate
17:11:02 <Cale> acowley: I don't think there's much which can be accomplished by knowing text editor shortcuts which over the course of a year would make up for the time spent on this conversation already.
17:12:49 <yayutf> mornfall: one of my best friends intentionally disables syntax highlighting in his preferred variant of vi before programming in it
17:12:57 <joneshf-laptop> byorgey, but then once you add in inverses to the naturals, you all of a sudden can think about a larger set of problems, some things become easier, maybe?
17:13:16 <acowley> Cale: That's a fairly baseless assertion, so I won't argue it
17:13:19 <Peaker> Twey: sure we do :)  Improving the performance of our type inference/checking algorithm (or rewriting it into something better, or integrating an existing DT-capable type system)
17:13:20 <mornfall> joneshf-laptop: and other stop making sense or become harder
17:13:30 <joneshf-laptop> also true
17:13:31 <joneshf-laptop> :)
17:13:37 <acowley> yayutf: Well sure, there's a "certain point". Mine comes well before dvorak, Cale's comes shortly after Notepad
17:14:15 <Peaker> Twey: we don't re-use an existing type system because we want to do a few things a bit differently than conventional type systems -- but we're starting to see that it's more difficult than we've thought
17:14:37 <joneshf-laptop> I don't think that adding inverses would solve all of the expressive problems in CS
17:14:55 <joneshf-laptop> but i think it might be a rabbit hole we should explore more
17:14:58 <yayutf> acowley: i wouldn't say "well before dvorak", as you obviously like vim keybindings a lot more than I do :-) ; they're somewhat orthogonal
17:15:30 <acowley> The only vim I know is :wq
17:15:37 <acowley> and I'm not entirely sure what that does
17:15:42 <Peaker> Twey: we're currently both busy with spikes in non-lamdu related work so will take us a few more months before we can go back to concentrated lamdu work
17:15:47 <Cale> joneshf-laptop: What are you and byorgey talking about?
17:15:57 <yayutf> acowley: ah, s/vim/your editor of choice/, of course
17:16:24 <acowley> yayutf: It's rather hard to argue with both you and Cale as you seem to be at fairly different points on the spectrum that we're all pretending is binary
17:17:02 <Cale> I think it probably does depend a lot on what sort of things you find yourself editing by hand.
17:17:11 * acowley goes back to shaking a wiimote at his editor
17:17:19 <yayutf> Cale: fairly little, because sed
17:17:27 <joneshf-laptop> Cale, it's mostly me thinking aloud, but in the latest haskellcast byorgey mentioned that groups aren't as prevalent as semigroups and monoids
17:17:39 <Cale> joneshf-laptop: HoTT will fix that :)
17:17:48 <joneshf-laptop> Cale, how's that?
17:17:49 <yayutf> Cale: how/why? :)
17:18:06 <byorgey> I was just going to say something about HoTT.  But I'm not sure it contradicts my statement.
17:18:19 <Cale> Because every type is a groupoid (actually an infinity groupoid) in HoTT
17:18:31 <Cale> So, groups become really natural to work with
17:19:28 <Cale> You can define a group as a higher inductive type with a single value constructor, say base, and then loops on that, i.e. constructors of type base = base, and then you can quotient that by relations by sticking in paths between the paths.
17:19:30 <joneshf-laptop> groupoid eh?
17:19:33 * joneshf-laptop googles
17:19:45 <Cale> A groupoid is a category where every arrow has an inverse
17:20:09 <Cale> A group is essentially the same thing as a groupoid with one object.
17:21:03 <mjrosenb> Cale: can you give an example of a groupoid that isn't a group?
17:21:26 <Cale> mjrosenb: Sure, the category with two objects and just their identity arrows
17:21:43 <edwardk> byorgey: I mentioned to Jacques earlier, but I really loved the use of HoTT in the paper.
17:22:01 <ReinH> Some people also use groupoid to refer to a magma. We shun these people.
17:22:05 <Twey> Peaker: DT?  Dependent typing?
17:22:33 <edwardk> byorgey: by far the most compelling case I've seen for HoTT for programming, rather than just abstracting over classical mathematical nonsense.
17:22:37 <Peaker> Twey: yeah, we didn't want GHC's type system because we might as well go with something like Idris or such with DT which is much simpler yet more powerful
17:23:05 <ChongLi> edwardk: ohhh, which paper?
17:23:11 <jrmithdobbs> Peaker: more powerful is a pretty strong claim.
17:23:19 <Twey> Peaker: I can write you a DT checker, or would you prefer Idris integration?
17:23:20 <mjrosenb> Cale: that is already assuming more category theory than I know.
17:23:27 <Cale> mjrosenb: ah, okay
17:23:40 <edwardk> byorgey: now that i've built you up, i'll let you fend off the hordes ;)
17:23:59 <Peaker> Twey: well, we want something that can be extended to DT later -- but gives good inference for now (we hope to preserve *some* inference for common cases even as DT is added)
17:24:00 <acowley> Yeah, what paper is this?
17:24:07 <acowley> Can I join the horde?
17:24:26 <edwardk> acowley: he talked about it a bit at the end of his Haskell Cast.
17:24:34 <Twey> Peaker: I feel like it would be easier to start with a dependent pure type system and disallow the things that break inference
17:25:06 <Peaker> Twey: possibly! we have a few more ideas we felt were important and make integration with existing type systems more difficult
17:25:09 <triliyn> Peaker: for Lamdu?
17:25:12 <acowley> edwardk: This is like a commercial for the local news.
17:25:14 <jrmithdobbs> acowley: what you said, sounds interesting
17:25:15 <Peaker> triliyn: yeah
17:25:23 <Cale> mjrosenb: So, you're unfamiliar with the definition of a category?
17:25:25 <edwardk> acowley: exactly
17:25:40 <edwardk> acowley: coming up at MSFP 2014...
17:25:48 <Peaker> Twey: for example, we want explicit type variable lambdas/applications, and hide them in the UI
17:25:52 <edwardk> well, possibly i guess
17:25:56 <acowley> jrmithdobbs: I think all I've said tonight is petty word arguments with shachaf and incredulity at editor apathy. I'm glad something was interesting!
17:26:12 <jrmithdobbs> acowley: no the paper not you ;p
17:26:16 <Peaker> Twey: because we believe the type system is simpler and more elegant that way (no "forall" as magic)
17:26:18 <shachaf> help
17:26:19 <acowley> dammit!
17:26:25 <Twey> Peaker: Absolutely agreed
17:26:25 <jrmithdobbs> acowley: bad use of tab complete ;p
17:26:27 <mjrosenb> Cale: uhh, it is a set of mathematical objects with functions that map between them, the functions may or may not need to be one-to-one?
17:26:34 <shachaf> Oh, "combinator".
17:26:40 <ReinH> acowley: oh no you've awoken the shachaf
17:26:48 <acowley> dammit! x2
17:26:54 <shachaf> sigh
17:27:12 <shachaf> hilarious
17:27:21 <Cale> mjrosenb: A category C consists of: 1) a collection Ob(C) of "objects" -- these can be anything we want them to be, and more or less just serve as labels
17:27:31 <Peaker> Twey: Also, we want more precise types for subexpressions -- which we believe will be more attainable with more structural typing than Haskell has (structural records, perhaps row polymorphism, and shared data constructors for sum types, anonymous sum subtypes, etc)
17:27:32 <ReinH> unsure if actually hilarious or sarcastically hilarious
17:27:39 <shachaf> not actually hilarious
17:27:42 <ReinH> I suspected.
17:28:05 <acowley> Well, it will be nice to see people not in the HoTT inner circle applying HoTT
17:28:18 <Cale> mjrosenb: 2) For each (ordered) pair of objects X and Y in Ob(C), a collection C(X,Y) of "arrows from X to Y". These again can be anything we like. When f is an arrow from X to Y, we write f: X -> Y.
17:28:27 <Peaker> Twey: i.e: the ceremony around defining ADTs in Haskell discourages precise types because you don't want to define a new ADT for every subexpression -- so people tend to use ad-hoc tuples/eithers, where nice field/data-cons names would have been helpful
17:29:34 <Peaker> Twey: so a type system with a clear "upgrade" path to DT, explicit type-var lambdas/applications, structural typing (products and sums!) and fast, incremental type inference --  we couldn't find anything like this, which is why we decided to implement our own (also pedagogical)
17:29:34 <Twey> Peaker: Types can be implemented as dependent sums, à la ‘Gentle Art of Levitation’
17:29:44 <Peaker> Twey: we are not experts, and having a lot of difficulty implementing that!
17:29:55 <Cale> mjrosenb: 3) For each three objects X, Y, Z and arrows f: X -> Y and g: Y -> Z, we have an arrow (g . f) : X -> Z, called the composite of g and f
17:30:20 <Peaker> Twey: dependent sum aka sigma types?
17:30:25 <Twey> Peaker: Yes
17:30:29 <Cale> (i.e. composition is an operation on arrows which line up to give an arrow from the source of one to the target of the other)
17:31:15 <Peaker> Twey: we're entertaining the notion of having all sums/products be scott-encoded behind the scenes, and have UI magic show them as products/sums,  my codeveloper really likes this, but it makes me nervous :)
17:31:29 <Cale> mjrosenb: 4) For every object X, there is an arrow id_X: X -> X such that id_X . f = f and g . id_X = g for any f and g where the composites make sense.
17:31:46 <Twey> Peaker: Unfortunately that's type-theoretically awkward
17:32:13 <Peaker> Twey: what timezone are you in?  It's 3:30 am here :)
17:32:16 <Cale> mjrosenb: and 5) for any three arrows which line up so the composites make sense, we have (f . g) . h = f . (g . h)
17:32:19 <Twey> Peaker: UTC
17:32:22 <ReinH> mjrosenb: aaaand now you know category theory
17:32:26 <Twey> (0120)
17:32:36 <Cale> mjrosenb: So sets and functions provide an *example* of such a thing :)
17:32:47 <Cale> (perhaps the original example)
17:32:55 <Peaker> Twey: what times are you available for chat? we'd love help, you sound like you could help a lot :)
17:33:05 <jle`> ta da!
17:33:13 <ReinH> But so do (small) categories and functors.
17:33:33 <joneshf-laptop> Peaker, what are you speaking of when you say "we"?
17:33:44 <Cale> Or Haskell types and Haskell-definable functions
17:33:46 <Peaker> joneshf-laptop: I have a codeveloper I work on Lamdu with
17:33:52 <mjrosenb> ReinH: if only.
17:33:56 <Peaker> joneshf-laptop: it's just the 2 of us atm
17:34:11 <ReinH> Or matrices and matrix multiplication
17:34:18 <Peaker> and we really want contributors (especially tt/type system experts) to help
17:34:43 <Twey> Peaker: My sleep schedule is unpredictable :þ  I'm just an amateur, but I've been studying type theory for a bit and I'd like to help out if possible
17:34:45 <Cale> mjrosenb: If we restrict the definition of a category so that we only have one object, and a bunch of arrows from that object to itself, then the fact that the composition must have an identity element and be associative means that we essentially have the definition of a monoid.
17:35:23 <ReinH> Actually, that's an even more interesting category where matrixes are *arrows* and composition is matrix multiplication
17:35:30 <Twey> Peaker: But I'll be around for at least the next twelve hours or so if that fits your windows
17:35:35 <joneshf-laptop> Peaker, ah, yeah that's a very interesting project
17:35:43 <Cale> mjrosenb: A groupoid is a category such that for any f: X -> Y, there is some g: Y -> X such that g . f = id_X and f . g = id_Y
17:36:14 <Peaker> Twey: mind if I privmsg?
17:36:19 <Twey> Go ahead
17:36:21 <Cale> ReinH: and the objects are natural numbers :)
17:36:26 <ReinH> Cale: indeed :)
17:36:51 <ReinH> Cale: shachaf showed me that category and it was a eureka moment for me :)
17:36:59 <Aetherspawn> if I need to marshall between a C struct and a haskell data structure really quickly (preferrably zero-cost) what should I use?
17:37:09 <Cale> mjrosenb: A groupoid with one object is essentially the same thing as a group, in the same way that a category with one object is a monoid.
17:37:35 <Aetherspawn> I have a C array of a C struct, it'd be nice if I could use Haskells UArray with it
17:37:44 <haasn> ReinH: also known as the category of linear maps between vector spaces over ℝ
17:37:54 <bitemyapp> are dependent product types and dependent sum types duals of each other?
17:37:54 <Cale> Aetherspawn: Well, if you can use Ptr values, then you don't need to marshal anything
17:38:00 <mjrosenb> Cale: while I've understood everything thusfar, I usually like to have concrete examples :-/
17:38:09 <Aetherspawn> yes, I can use pointers, but then how do the accessors work?
17:38:10 <haasn> with composition as.. composition
17:38:12 <Aetherspawn> do I have to manually write them?
17:38:18 <Cale> mjrosenb: Okay, yeah, actually, we should probably do this in ##categorytheory
17:38:36 <Cale> Aetherspawn: yeah, and they'll have to be in IO then
17:38:44 <edwardk> haasn: covectors make a pretty monad, their kleisli arrows in hask make a nice description of that category to program with
17:38:54 <Cale> Aetherspawn: The usual thing to do is to write a Storable instance
17:39:28 <joneshf-laptop> Cale, that channel exists!?!
17:39:36 <Cale> yes!
17:39:43 <ReinH> joneshf-laptop: yes, and guess who's in it
17:39:52 <Aetherspawn> a storable instance is probably more copying than I want. I guess I can wrap everything in unsafePerformIO
17:39:56 <Cale> There's also ##hott if you're interested in that :)
17:39:58 <joneshf-laptop> ReinH, me...now
17:39:59 <bitemyapp> ReinH: angry functional programmers?
17:40:02 <Aetherspawn> thats safe as long as it only performs reads?
17:40:06 <ReinH> haha, lots of #haskell-ers
17:40:15 <bitemyapp> ReinH: redundant.
17:40:20 <ReinH> fair enough
17:40:21 <bitemyapp> ;)
17:40:21 <Aetherspawn> any performance concerns I should know about w.r.t unsafePerfomIO?
17:40:32 <SamanthaD> I have a question about best practice: Is it generally discouraged to use data structures such as evenNumbers = [ x*2 | x <- [1..] ] given that getting any particular number operates in O(n) time and space instead of O(1) time and space?
17:40:36 <bitemyapp> Aetherspawn: you're using unsafePerformIO and you're worried about speed?
17:40:39 <joneshf-laptop> Cale, thanks
17:40:41 <acowley> Aetherspawn: You don't need to do much copying at all if you have an array (or Vector) of Storable things.
17:40:41 * bitemyapp high fives Aetherspawn 
17:40:56 <acowley> Aetherspawn: Why are you using unsafePerformIO?
17:40:56 <ReinH> Aetherspawn: well, is segfaulting a performance concern?
17:41:07 <Aetherspawn> because when I memory map the file which has the structure in it
17:41:07 <SamanthaD> or is there a way to hint the compiler into handling the list in O(1) time?
17:41:11 <bitemyapp> ReinH was thinking the same thing I was.
17:41:14 <Aetherspawn> my things will be pointers
17:41:24 <Aetherspawn> and the accessors will need to be in IO
17:41:51 <Aetherspawn> storable wouldn't be necessary, everything is immutable
17:41:52 <ReinH> SamanthaD: lists are not very good data structures if you need random access, no.
17:42:02 <bitemyapp> SamanthaD: but Data.Vector is a thing.
17:42:07 <idnar> if I want to write a special-purposes IRC bot, should I start with lambdabot, or just roll my own thing?
17:42:10 <bitemyapp> SamanthaD: there are also arrays if you're feeling masochistic.
17:42:35 <ReinH> SamanthaD: but if you need random access to structure full of even numbers, what's wrong with evenAt x = x+x?
17:42:49 <acowley> Aetherspawn: Can you give us an idea how you plan on using the array of structures from C?
17:43:00 <Aetherspawn> readonly lookups
17:43:05 <bitemyapp> acowley: bit masking and the power of prayer?
17:43:08 * idnar eyes http://hackage.haskell.org/package/fastirc
17:43:10 <SamanthaD> ReinH: it was an example program :3
17:43:11 <Aetherspawn> Oh, well, not quite
17:43:24 <Aetherspawn> the file is kind of like a memory dump from a C application
17:43:34 <ReinH> SamanthaD: just saying, (a -> b) is a perfectly serviceable "random access collection of b's"
17:43:36 <bitemyapp> Aetherspawn: are you loading an ancient file format that dumped structs?
17:43:53 <Aetherspawn> nah, its a modern format thats designed to be memory mapped straight into a C application
17:44:03 <Aetherspawn> but if I serialize it into haskell it'll be really quite large
17:44:08 <bitemyapp> ReinH: that's a really good point.
17:44:09 <Aetherspawn> last time I tried the memory usage tripled
17:44:20 <acowley> Sounds like a job for Storable to me
17:44:29 <bitemyapp> Aetherspawn: that is horrific. I am so so sorry.
17:44:33 <acowley> Storable doesn't mean you will be mutating the data
17:44:45 <haasn> edwardk: how do covectors form a monad?
17:44:49 <SamanthaD> Thanks ReinH and bitemyapp
17:44:59 <dhrosa> @pl `take` xs
17:45:00 <lambdabot> (line 1, column 1):
17:45:00 <lambdabot> unexpected "`"
17:45:00 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:45:08 <dhrosa> @pl (`take` xs)
17:45:08 <lambdabot> (`take` xs)
17:45:19 <SamanthaD> it's too bad, that kind of optimization would allow some really exciting abstraction
17:45:19 <ReinH> dhrosa: there are no points there. :)
17:45:28 <bitemyapp> SamanthaD: Data.Vector is good for conventional sequential collections but if you need to map an "infinite" space cleverness like ReinH's is better.
17:45:40 <acowley> Aetherspawn: Can you load the whole file into memory if you don't have extra overhead?
17:45:46 <bitemyapp> SamanthaD: wuh?
17:45:46 <ReinH> and if you need a partial map there's always a -> Maybe b :D
17:46:01 <bitemyapp> ReinH: oh you're just being cute now.
17:46:10 <Aetherspawn> what do you mean by extra overhead?
17:46:13 <ReinH> :t lookup
17:46:14 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
17:46:17 <ReinH> :p
17:46:29 <Aetherspawn> do you mean could i serialize it into Haskell if I figured out how to do it cheap?
17:47:39 <Aetherspawn> thats actually a good point. Maybe if I scatter a lot of {-# UNPACK #-} around I can match the size of the original C structure
17:47:48 <Aetherspawn> and then i can just serialize it into Haskell with hopefully minimal overhead
17:47:55 <SamanthaD> bitemyapp: I suppose from an engineering standpoint it's not that exciting but it's kind of conceptually satisfying to state "the seventh even number" by coding `evenNumbers !! 7` rather than `evenNumbers 7`
17:48:54 <dwcook> I was just stumped on the stupidest error. My type was inferred as [(Foo, Bar)] instead of as Map Foo Bar and I could not figure out why. Then I realized I forgot to import lookup from Data.Map and that I was in fact using Prelude's. >_<
17:49:12 <bitemyapp> SamanthaD: from an engineering standpoint, ReinH's (a -> b) is much more elegant in a way that takes advantage of the problem being solved.
17:49:33 <bitemyapp> SamanthaD: that's where you get your big wins, not from fiddling with tuning misconceived code.
17:49:46 <bitemyapp> techically (a -> a) for your specific example, but whatever.
17:50:11 <SamanthaD> thanks for the advice
17:50:18 <shachaf> hi SamanthaD
17:50:24 <SamanthaD> shachaf!
17:50:37 <bitemyapp> idnar: people *need* a fast IRC parser?
17:50:43 <bitemyapp> I'm actually somewhat surprised.
17:50:49 <acowley> Aetherspawn: No, I mean is the file on disk small enough to fit in memory?
17:50:50 <SamanthaD> shachaf: I've decided to give Haskell another run!
17:51:03 <acowley> Aetherspawn: There's no need for any fancy stuff on the Haskell side
17:51:18 <ReinH> bitemyapp: (a -> a) is just an (a -> b) where b = a :p
17:51:21 <acowley> Aetherspawn: If the file is too big to fit in memory, then one has to take a little more care
17:51:43 <bitemyapp> ReinH: I know but allowing the types to vary is unnecessary.
17:51:49 * haasn .oO( map f [0..] !! x = f x )
17:52:04 <haasn> I wonder if that's a sensible RULE
17:52:06 <ReinH> bitemyapp: so is restricting them :p
17:52:11 <bitemyapp> either way, a function that can simply return answers for queries efficiently and be memoized is probably more ideal than fiddling around with collections.
17:52:18 <bitemyapp> ReinH: I'm all about the types BDSM.
17:52:19 <haasn> Hmm, breaks for x < 0
17:53:06 <Aetherspawn> acowley: yes its big enough
17:53:29 <Aetherspawn> its about 400mb though
17:54:11 <acowley> Aetherspawn: The point in the Storable approach is that you just load the bytes as a big blob, and the Storable instance tells the Haskell side how to index into that blob
17:55:22 <Aetherspawn> is the idea that you use peek to load things out of it?
17:57:21 <qrada> erm, say someone wanted you to parse the output of "w" and get all of the users.. would these 2 lines be acceptable or is there a cleaner way to do it.. imo i prefer these lines:
17:57:29 <acowley> Aetherspawn: Yes, but not directly
17:57:35 <qrada> readProcess "w" [] [] >>= return . map head . drop 2 . map words . lines
17:57:35 <qrada> (return . map head . drop 2 . map words . lines) =<< readProcess "w" [] []
17:57:44 <acowley> Aetherspawn: You use Data.Vector.Storable to provide you a reasonable API
17:57:50 <acowley> Aetherspawn: Under the hood, it's using peek
17:58:00 <Aetherspawn> ah
17:58:39 <acowley> That is enough data, though, that you will have to be careful
17:58:47 <acowley> that you don't accidentally copy it
18:03:55 <ReinH> haasn: works for Nat :p
18:04:40 <ReinH> qrada: whenever I see partial functions (like head) I start to wonder how it might fail
18:05:55 * hackagebot cassava 0.3.0.1 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.3.0.1 (JohanTibell)
18:06:07 <ReinH> you might want mapMaybe listToMaybe instead
18:06:37 <dwcook> I have a runServer :: (Integral port) => port -> world -> ServerAction world Unique result -> IO (). But I don't want the user to be able to use the fact that a Unique is involved. Is there some way to hide it?
18:07:02 <qrada> ReinH: so you mean, in case im handling data that returns Just a | Nothing ? which is common?
18:07:15 <ReinH> qrada: in case you're handling an empty list
18:07:17 <Peaker> or (^.. traversed . ix 0)
18:07:19 <qrada> ooh
18:07:20 <ReinH> so you just get the heads that exist
18:07:22 <qrada> right
18:07:39 <ReinH> and you don't get a runtime error when they don't
18:07:43 <qrada> thanks, god point
18:07:44 <qrada> good
18:07:46 <qrada> ;f
18:07:53 <ReinH> I like the first one
18:08:06 <qrada> ya, i figured.. hah
18:08:13 <jle`> when you have partial functions
18:08:18 <jle`> you don't let the compiler do the job
18:08:20 <jle`> that it is best at
18:08:35 <ReinH> well, to be fair, the compiler isn't very good at totality checks either :p
18:08:41 <jle`> haha
18:08:50 <jle`> maybe fairer to say that it's the job that haskell is best at :P
18:08:56 <ReinH> certainly better than you are
18:09:08 <ReinH> (the general you, not jle`)
18:09:20 <jle`> well...either case is true :)
18:09:36 <shachaf> I'm sure I'm better than GHC at totality checks.
18:10:04 <jle`> well in any case static type checking is a major advantage of using haskell so if you want to throw away the compiler's ability to do so, you should not do it without a second thought
18:10:08 <shachaf> Certainly in all the interesting cases (i.e. the ones I don't know how to make a computer program check for me).
18:10:38 <intrados> Can anyone reproduce/make sense of lens's problem with vector? http://lpaste.net/99020
18:11:21 <qrada> another q maybe someone knows.. im in ghci messing around, and im trying to read a "infinite" output stream from a process: (_, Just hout, _, _) <- createProcess (proc "yes" []) { std_out = CreatePipe } ... then I do this on the hout handle: hGetContets hout >>= return . take 2 ... it's giving me one line then ghci says illegal operation: handle closed.
18:11:29 <qrada> It seems the handle closes once my hGetContents "returns"
18:11:50 <edwardk> intrados: is that lens 3.10?
18:12:25 <intrados> edwardk: 3.10.1
18:12:26 <qrada> ah
18:12:30 <qrada> i guess it closes it i think
18:12:32 <qrada> hGetContents
18:13:24 <qrada> ok hGetLine is what I needed.. ;f
18:13:26 <edwardk> intrados: checking into it for a sec.
18:15:20 <edwardk> intrados: >>> Data.Vector.fromList [1,2,3] ^? ix 0     ==> Just 1   -- works for me
18:15:42 <edwardk> intrados: do you have multiple versions of vector installed when you look with ghc-pkg list ?
18:16:32 <intrados> edwardk: only vector-0.10.9.1
18:16:56 <enthropy> edwardk: could you bump the fingertree version in http://hackage.haskell.org/package/trifecta ? Cabal isn't smart enough to see that it would need reducers == 3.0.2.1 to make both packages use the same fingertree
18:17:23 <edwardk> and ghc-pkg describe lens shows vector-0.10.9.1 in the dependency list?
18:17:23 <enthropy> with whatever the default constraint solver settings are
18:17:38 <edwardk> enthropy: toss a patch my way and no problem
18:17:44 <enthropy> it's done in the repo
18:17:55 <enthropy> I think all that's needed is a cabal upload?
18:18:03 <edwardk> oh, do i just need to upload? k
18:18:05 <enthropy> unless you have other questionable changes in the git repo
18:18:19 <edwardk> let me check the status of it
18:18:24 <intrados> edwardk: Ah, it does not. It has `vector-0.10.0.1`
18:18:33 <edwardk> intrados: figured as much =)
18:19:26 <intrados> edwardk: I don't quite know what's happening then. `ghc-pkg check` doesn't show any problems
18:21:11 <edwardk>  intrados you probably have one in global and one in local, and its taking your higher version number one when you load that .hs file in ghci, but the instances are built against the old one, just reinstall lens with --force for the easiest fix
18:21:37 <edwardk> you may have a few knock-on --force's to do afterwards, but it'll get you going again
18:22:41 <jle`> i wish there was a way to find where instances are delcared
18:22:56 <jle`> in the docs
18:24:23 <intrados> edwardk: Thanks, that makes sense.
18:29:02 <lovewithacaveat> if i write my own compiler for haskell, will everyone think i am cool?
18:29:47 <lovewithacaveat> would i be on the right path to win a turing award that way?
18:30:01 <lovewithacaveat> jdubs, because i really want to make my mom and dad proud
18:33:24 <lovewithacaveat> hello, turing award committee? can you hear my dreams?
18:35:45 <simpson> lovewithacaveat: Why would you want to write a compiler?
18:36:26 <lovewithacaveat> simpson: to win the adoration of the human race. especially female humans.
18:36:53 <simpson> lovewithacaveat: I don't know if it actually works that way.
18:37:09 <lovewithacaveat> simpson: why not?
18:37:10 --- mode: ChanServ set +o shachaf
18:37:24 <lovewithacaveat> don't female humans love "smartness"?
18:37:43 <simpson> lovewithacaveat: I think that we should all just calm down a bit.
18:37:45 --- mode: shachaf set +b *!*6cb45e02@*.108.180.94.2
18:37:45 --- kick: lovewithacaveat was kicked by shachaf (lovewithacaveat)
18:37:55 --- mode: shachaf set -o shachaf
18:38:21 <ReinH> simpson: hey leave me out of this :p
18:45:14 <edwardk> lambdabot: seen mokus
18:45:31 * edwardk pokes mokus =)
19:00:59 * hackagebot stm-conduit 2.2.1 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-2.2.1 (ClarkGaebel)
19:01:01 * hackagebot concurrent-state 0.5.1.0 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.5.1.0 (JoelTaylor)
19:05:02 <scott_> "[...] the Conservative party of Canada [...] Or as it would be known in America, the extremely extremely extremely far left party."
19:05:50 <scott_> Err. This is entirely not the channel I thought it was.
19:05:55 <scott_> Sorry about that!
19:06:50 <Rarrikins> How can I provide an IO interface to a ResourceT? I have an idea to use something like MVars or a queue to pass data to and from the ResourceT 'backend', but I'm wondering if there's a simpler way.
19:07:38 <Rarrikins> (this is for making web requests via HTTP Conduit)
19:13:12 <mzarella> Has there been much work around haskell and robotics software?
19:13:44 <mzarella> At a lot of language conferences, there's always someone showing off how they can control a robot using their favorite language
19:13:56 <mzarella> I havent seen much of this in Haskell land, but maybe I'm looking at the wrong places
19:14:54 <ReinH> mzarella: well, I've thought a bit about writing a Haskell version of http://artoo.io/
19:15:02 <ReinH> mzarella: don't have any robots lying around though :/
19:15:25 <mzarella> this is neat: https://www.youtube.com/watch?v=bKp-FC0aeFE
19:15:30 <mzarella> https://github.com/ajhc/demo-cortex-m3
19:16:01 * hackagebot Graphalyze 0.14.0.2 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.14.0.2 (IvanMiljenovic)
19:16:13 <peddie> mzarella: https://github.com/acowley/roshask
19:16:47 <peddie> @hackage hopencv
19:16:47 <lambdabot> http://hackage.haskell.org/package/hopencv
19:20:14 <mzarella> http://leepike.wordpress.com/2010/12/18/haskell-and-hardware-for-the-holidays/
19:21:01 * hackagebot BigPixel 1.3.0 - Image editor for pixel art  http://hackage.haskell.org/package/BigPixel-1.3.0 (ManuelChakravarty)
19:31:05 <DarkFox> Is there any Distributed Hash Table written in Haskell? I can't seem to find any of such.
19:33:26 <johnw> if I'm using a Writer w, can I peek at the value of w?
19:33:28 <ReinH> DarkFox: I don't know of any.
19:33:49 <DarkFox> Searching predictable filenames \o/ https://github.com/l29ah/9ptorrent/blob/master/DHT.hs
19:33:52 <DarkFox> Lol
19:34:18 <DarkFox> I doubt that code will be of much use to me however :P
19:35:29 <darthdeus> can i somehow do cabal install while in a cabal package so that it adds the installed thing into it's dependencies?
19:35:55 <DarkFox> ReinH: I might have to write my own \o/
19:36:24 <DarkFox> https://github.com/search?l=haskell&q=dht&type=Code
19:36:30 <DarkFox> Maybe not; I'll keep hunting lol
19:39:29 <ReinH> DarkFox: distributed haskell is a relatively recent thing. Cloud Haskell is very interesting but still young.
19:39:47 <DarkFox> I'll have to check that out
19:39:50 <DarkFox> Thanks
19:43:54 <dolio> Recent? http://citeseer.uark.edu:8080/citeseerx/viewdoc/summary?doi=10.1.1.20.3631
19:46:03 * hackagebot concurrent-state 0.5.1.1 - MTL-like library using TVars  http://hackage.haskell.org/package/concurrent-state-0.5.1.1 (JoelTaylor)
20:02:23 <Aetherspawn> should I {-# UNPACK -#} a strict Bool ?
20:02:37 <Aetherspawn> I guess it probably wouldn't hurt, eh?
20:09:35 <jfischoff> @lpaste
20:09:35 <lambdabot> Haskell pastebin: http://lpaste.net/
20:09:36 <jfischoff> @hpaste
20:09:36 <lambdabot> Haskell pastebin: http://lpaste.net/
20:12:43 <ReinH> dolio: What can I build with GdH? How do I get it?
20:17:42 <jfischoff> what is going on here http://lpaste.net/99024
20:18:00 <jfischoff> I dumped the core of: test :: Text; test = "h"
20:18:19 <jfischoff> and it is like pages and pages worth of core
20:20:19 <ReinH> jfischoff: you probably want to pass in a bunch of command line flags I don't know off hand to make it output simper core
20:20:28 <ReinH> shachaf would know
20:21:05 <jfischoff> you mean like more optimization flags?
20:21:43 <shachaf> shachaf knows all
20:21:51 <jfischoff> :)
20:21:58 <shachaf> jfischoff: cannot reproduce
20:22:03 <shachaf> What version of GHC are you using?
20:22:07 <ReinH> you might just want -dsuppress-all
20:22:14 <shachaf> Something fishy is going on here because you're not even turning on OverloadedStrings
20:22:27 <jfischoff> 7.6.3
20:22:49 <shachaf> And what version of text?
20:23:45 <jfischoff> 1.0.0.0
20:24:09 <lispy> jfischoff: Is it possible that ghc has inlined a ton of stuff and we're seeing the core for all of it?
20:24:36 <lispy> (I had to restart my client, not sure what I missed)
20:25:03 <jfischoff> I'm surprised by the amount of output for: test :: Text; test = "h"
20:25:06 <shachaf> Lots of things are possible.
20:25:12 <jfischoff> http://lpaste.net/99024
20:25:13 <shachaf> Why isn't it asking you to turn on OverloadedStrings?
20:25:22 <jfischoff> bad copy
20:25:52 <shachaf> You mean it's a LANGUAGE karma at the top of the file?
20:26:05 <jfischoff> there is
20:26:15 <shachaf> And that's the entire file?
20:26:20 <jfischoff> yes
20:26:33 <shachaf> Using text 0.11.3.1 I can't reproduce it.
20:27:20 <jfischoff> I will try that version
20:27:46 <shachaf> In particular I just get unpackCString#
20:28:34 <jfischoff> that's what I looking for
20:29:57 <dolio> ReinH: Dunno. It's an old defunct project.
20:31:57 <L8D> guys
20:32:06 <L8D> there mother fucking snow in Austin
20:32:26 <L8D> I'm so happy
20:33:25 <enthropy> is there a pretty-printing library that does tables nicely?
20:35:09 <lispy> jfischoff: the definitions of pack/unpack/unpackCString# (and their pragmas) don't seem to have changed.
20:35:13 <lispy> So, I dunno.
20:35:25 <lispy> But, I'm pretty sure you were seeing the inlined code.
20:35:37 <lispy> I just can't figure what else it would be.
20:36:29 <shachaf> What I cannot reproduce, I cannot debug.
20:36:46 <shachaf> (Well. That's not completely true.)
20:40:25 <td123> does anyone know how to install a cabal package from source into a sandbox? It isn't on hackage
20:41:06 <lispy> td123: cabal sandbox add-source
20:41:43 <td123> lispy: thank you
20:41:47 <lispy> yw!
20:51:38 <jfischoff> I think I see what is going on, but I can't say why it is different for you shachaf
20:51:58 <acowley> jfischoff: I get the same output as you
20:52:06 <jfischoff> okay cool
20:52:33 <jfischoff> I think there is a case statement that ultimately leads to C# 'h'
20:52:34 <shachaf> Do you get the same result if you compile with $ ghc -O2 -fforce-recomp -dsuppress-all -ddump-simpl yourfile.hs ?
20:52:46 <shachaf> Oh, hmm.
20:53:10 <shachaf> OK, it is my fault. I tested with a longer string.
20:53:21 <jfischoff> interesting
20:53:44 <jfischoff> haha
20:53:49 <shachaf> So it only happens with strings shorter than two characters.
20:54:08 <jfischoff> bos: you might find this interesting: http://lpaste.net/99024
20:54:30 <jfischoff> I forgot to add the {-# LANGUAGE OverloadedStrings #-} at the top though
20:54:34 <lispy> Is it possible to see which RULES fired?
20:54:42 <shachaf> -ddump-rule-firings
20:54:46 <shachaf> Also -ddump-rule-rewrites
20:54:55 <lispy> I wonder if ghc does something different with short lists  (like, maybe doesn't build the list)
20:54:55 <jfischoff> with "he" it becomes just Data.Text.unpackCString# "he"
20:55:02 <acowley> Wow
20:55:09 <randomclown> -funbox-strict-fields
20:55:12 <randomclown> >funbox
20:55:17 <jfischoff> acowley: isn't that crazy?
20:55:28 <acowley> jfischoff: Yeah, it really is
20:55:49 <acowley> It seems bad how string handling is hacked in
20:55:58 <shachaf> I see what's going on.
20:56:09 <jfischoff> let's hear it
20:56:34 <acowley> It's treating a single character Text as a single character
20:56:38 <shachaf> GHC doesn't make string literals for strings of length 0 or 1.
20:57:09 <shachaf> So the rule that involves GHC.CString.unpackCString# never fires.
20:57:10 <lispy> That's clever but doesn't surprise me much in terms of optimizing
20:57:11 <acowley> That TestText.test2 = C# 'h' line is problematic
20:57:57 <shachaf> In particular a rule that turns Data.Text.pack (GHC.CString.unpackString# x) into Data.Text.unpackCString# x, I imagine.
20:59:49 <shachaf> I imagine an easy fix in text would be to add two special-case rules, one for an empty list and one for a one-character list.
21:00:51 <jfischoff> can you add rules any where? Do they need be in the Text source?
21:00:53 <jfischoff> brb
21:01:52 <shachaf> You can add orphan RULES, which is similar to adding orphan instances.
21:02:10 * shachaf back later
21:05:16 <jfischoff> ah cool, I'm going to mess with that later
21:07:58 <spintronic> jasdf;lkj
21:08:09 <spintronic> sorry I sneezed
21:36:33 <shachaf> bos: Did you see the conversation above about text's RULES?
21:38:10 <shachaf> text has a rule for pack (GHC.unpackCString# x) = Text.unpackCString# x, but empty and singleton strings don't get turned into GHC.unpackCString#, so a huge amount of code gets inlined for (pack "") and (pack "h").
21:39:11 <shachaf> A simple solution would be to add two special-case RULES for those cases, to match GHC's special cases.
21:40:55 <shachaf> {-# RULES "TEXT empty literal" unstream (S.map safe (S.streamList [])) = empty #-}
21:40:58 <shachaf> {-# RULES "TEXT singleton literal" forall c. unstream (S.map safe (S.streamList (c : []))) = singleton c #-}
21:41:06 <shachaf> Seems to work, at least.
21:42:50 <bos> shachaf: it's safe to assume i never see anything in IRC
21:43:00 <bos> shachaf: please email me if there's something i should react to
21:43:29 <shachaf> bos: I was just writing an email.
21:43:41 <shachaf> (But now that you're here, should I still write it?)
21:45:24 <shachaf> I guess that's a yes.
21:57:11 <covi> Why is 'sum . map digitToInt . show $ 2^1002210' so fast?
21:57:42 <startling> > length $ show 2^1002210
21:57:44 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
21:57:44 <lambdabot>    arising from a use of `GHC.Real.^'
21:57:44 <lambdabot>  Possible fix:
21:57:44 <lambdabot>    add an instance declaration for (GHC.Num.Num [GHC.Types.Char])
21:57:52 <startling> > length $ show (2^1002210 :: Int)
21:57:53 <lambdabot>  1
21:58:10 <startling> > show (2^1002210 :: Int)
21:58:12 <lambdabot>  "0"
21:58:14 <startling> uh
21:58:17 <startling> > show (2^1002210 :: Integer)
21:58:18 <lambdabot>  "187048572696075587694068882429438039567759068851640800427709669980530659694...
21:58:23 <startling> > length $ show (2^1002210 :: Integer)
21:58:24 <lambdabot>  301696
21:58:42 <covi> startling: why is show on Integer so fast?
21:58:50 <startling> covi, it probably uses a GMP thing
21:59:04 <covi> GMP?
22:00:15 <dleedev> hi, what's everyone's second and third favorite languages? (first being haskell, of course)
22:00:54 <startling> covi, the Gnu Multi Precision arithmetic library. it's what Integer is behind-the-scenes in GHC
22:01:41 <joelteon> dleedev: STG and C--
22:01:49 <covi> startling: thanks
22:02:01 <covi> dleedev: Scala
22:02:12 <dleedev> joelteon: what's stg?
22:02:13 <joelteon> nah i'm kidding
22:02:19 <joelteon> I like ruby
22:02:24 <jle`> dleedev: hmmm. ruby and fortran
22:02:45 <startling> covi: no, turns out it doesn't.
22:02:59 <startling> http://hackage.haskell.org/package/base-4.5.0.0/docs/src/GHC-Show.html ctrl-f "instance Show Integer"
22:03:08 <startling> covi: not sure what else to tell you. Haskell is fast? :)
22:03:36 <startling> n.b. show (2^1002210 :: Integer) does not compute the whole string
22:03:40 <startling> (in lambdabot)
22:03:46 <joelteon> > show (2^10000)
22:03:48 <lambdabot>  "199506311688075838488374216268358508382349683188619245485200894985294388302...
22:04:04 <dleedev> I heard fortran's the favorite among astrophysicists
22:04:33 <covi> startling: yeah, but it's curious it could give the first X digits instead of the last?
22:04:42 <covi> startling: but I guess that depends on algod
22:04:44 <covi> *algos
22:05:21 <jle`> dleedev: as a physicist i can sorta confirm
22:05:26 <jle`> well
22:05:34 <jle`> student of physics :P
22:05:52 <shachaf> You can see the algorithm. It's the last function on the page startling linked to.
22:05:57 <startling> ^
22:06:18 <jle`> a lot of new people come in with only C training.  but it's hard to get over the massive amounts of libaries written in fortran
22:06:42 <startling> jle`: libraries for what kinds of things?
22:06:49 <jle`> computational physics
22:07:00 <jle`> things from the 70's
22:07:02 <jle`> that still work well
22:07:09 <dleedev> jle`: so you're saying it's the library support rather than the language that draws the physicists?
22:07:19 <jle`> dleedev: it's not just that but the huge cultural momentum
22:07:42 <shachaf> if you write the string literal "foo\0bar" in a haskell program, ghc will generate the code unpackCStringUtf8# x, where x is the c string "foo\192\128bar"
22:07:44 <jle`> but the cultural momentum is weaking, at least from my perspective where i am
22:08:14 <jle`> but
22:08:19 <jle`> most physicists think in Fortran still
22:08:26 <jle`> when describing expressing their algorithms
22:08:36 <jle`> it's very close to what physicists understand
22:08:56 <dleedev> I read python is wiping out every other language in academia, though
22:08:58 <jle`> it's sort of one of my goals to make Haskell a contender in HPC for computational physics usage
22:09:17 <jle`> python and its c bindings are there...but...physics is a bit more entrenched than most other fields
22:09:17 <L8D> Python, NumPy, and Julia man
22:09:46 <dleedev> jle`: what's hpc?
22:09:50 <jle`> high performance computing
22:09:56 <jle`> not really a word worth using an acronym for
22:10:00 <jle`> heh
22:11:10 <Platz> In the expression `join either succ (Left 1)`, what is being joined? I'm confused because type of `either` seems to be expecting two functions, but it seems like there is only one expression supplied to either
22:11:34 <startling> :t join
22:11:35 <lambdabot> Monad m => m (m a) -> m a
22:11:41 <startling> :t join `asAppliedTo` either
22:11:42 <lambdabot> ((a -> c) -> (a -> c) -> Either a a -> c) -> (a -> c) -> Either a a -> c
22:12:00 <startling> > join f a
22:12:01 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr a0)
22:12:02 <lambdabot>    arising from a use of `e_1'
22:12:02 <lambdabot>  The type variable `a0' is ambiguous
22:12:02 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
22:12:02 <lambdabot>  Note: there are several potential instances:
22:12:05 <startling> > join f a :: Expr
22:12:06 <lambdabot>  f a a
22:12:26 <shachaf> Platz: You can write (a -> b) as ((->) a b), just like value-level infix functions.
22:12:30 <startling> :t either succ succ
22:12:31 <lambdabot> Enum c => Either c c -> c
22:12:41 <shachaf> So in this case the m in m (m a) -> m a is ((->) e)
22:12:56 <shachaf> So ((->) e) ((->) e a) -> (->) e a
22:13:04 <shachaf> I.e. (e -> e -> a) -> e -> a
22:13:37 <Platz> ok so the join is operating on the (->) monad not Either
22:13:42 <startling> yeah, exactly.
22:13:47 <Platz> thanks
22:14:36 <Aetherspawn> has anyone used reverse states befoer?
22:14:55 <Aetherspawn> I'd like to use a reverse state when parsing a file with offset references
22:15:24 <Aetherspawn> this is going to mess up my parser, is it? Reverse state doesn't do IO in reverse?..
22:16:16 <Aetherspawn> /s/this is/this isn't/
22:17:19 <startling> Aetherspawn: you could try it.
22:18:06 <Aetherspawn> ow
22:19:48 <startling> runReverseWhatever (lift (print "a") >> lift (print "b")) ()
22:20:57 <startling> hm, yeah, I guess it would have to.
22:21:09 <Aetherspawn> hmm, let's try
22:21:13 <startling> not sure why your parser would do IO, though.
22:22:01 <Aetherspawn> it does in a different way
22:22:10 <startling> um, ok
22:22:15 <Aetherspawn> I'm using pipes to feed in bytestring as the parser continues
22:22:21 <Aetherspawn> *bytestrings
22:22:49 <Aetherspawn> so theres a possibility that the reverse state monad could cause the streaming to disappear
22:23:02 <structuralist> can someone explain how normalization by evaluation works?
22:23:19 <startling> structuralist, well, what's your question?
22:23:20 <structuralist> or point to a good reference
22:23:35 <structuralist> I just can't make sense of how you get a lambda term from a function
22:23:46 <structuralist> the reify part I guess
22:24:14 <startling> I don't follow.
22:25:15 <structuralist> my understanding so far is, you have a lambda-calculus-like object language, and those evaluate to values in the metalanguage
22:25:35 <structuralist> and you somehow invert that, so that functions in the metalanguage become object-level lambda expressions
22:26:38 <structuralist> the notation in http://www.mathematik.uni-muenchen.de/~schwicht/papers/lics91/paper.pdf is confusing me
22:28:19 <structuralist> and in here http://www2.tcs.ifi.lmu.de/~abel/habil.pdf
22:30:00 <structuralist> I'm trying to do this for the presentation of Godel's T in PFPL (Bob Harper's textbook)
22:33:10 <Anpheus_> I have a question related to Haskell performance issues
22:33:21 <Anpheus_> Well, not issues, I just don't know the right thing to do in a situation
22:34:26 <Anpheus_> Here is a paste: http://lpaste.net/99026
22:36:17 * hackagebot instrument-chord 0.1.0.4 - Render Instrument Chords  http://hackage.haskell.org/package/instrument-chord-0.1.0.4 (AlanHawkins)
22:36:19 <Anpheus_> 'conn' is an opaque data type from FFI
22:37:17 <startling> structuralist: sorry, I can't answer your question. It's a bit over my head.
22:39:20 <Aetherspawn> Anpheus_: you could always make a new data and UNPACK+bang their fields then put that in your MVar
22:39:32 <chrizz> im getting a "Couldn't match ByteString with bytestring-0.10.0.2:Data.ByteString.Internal.Bytestring" - anyone know why?
22:39:51 <Aetherspawn> I was actually thinking about exactly the same thing only half an hour ago
22:39:51 <startling> chrizz, you have multiple versions of bytestring imported. use cabal.
22:40:18 <chrizz> startling: oh... I'm in a sandbox though
22:40:21 <c_wraith> chrizz: it could also be a lazy/strict mismatch.
22:40:26 <chrizz> nope, both strict
22:40:37 <c_wraith> then something built against the wrong version
22:40:41 <startling> chrizz, what are you running?
22:40:53 <chrizz> what do you mean? what ver. of cabal?
22:40:54 <startling> is it "cabal repl" or "ghci -whatever""?
22:40:58 <chrizz> oh
22:41:30 <startling> oh, I guess sandboxes disallow multiple versions. I'm guessing you're not actually in the sandbox, though.
22:41:35 <chrizz> ah, i realize the problem, it's only syntastic that's complaining because it's just compiling the file
22:41:45 <chrizz> i can build with cabal just fine
22:41:51 <startling> chrizz: yeah.
22:42:13 <chrizz> bummer. I thought hdevtools is just sort of magically aware of cabal
22:43:05 <Anpheus_> Aetherspawn: Thanks, I'll do that.
22:43:56 <startling> chrizz: nope, cabal sandboxes are pretty new.
22:44:10 <startling> I don't think any of the emacs tools know about them yet.
22:45:10 <chrizz> startling: just to clarify - if I try to cabal install something (say a personal project) and get a "the following packages are likely to be broken by the reinstalls" warning, the only sensible thing to do is build it in a sandbox, right?
22:45:43 <startling> chrizz: you can ghc-pkg unregister the old versions or remove all of ~/.ghc
22:46:04 <Rylee> @hoogle [[Char]] -> [Char]
22:46:05 <lambdabot> Prelude unlines :: [String] -> String
22:46:05 <lambdabot> Data.List unlines :: [String] -> String
22:46:05 <lambdabot> Data.String unlines :: [String] -> String
22:46:23 <chrizz> but other libraries were linked against the old versions, that's why the packages are likely to break
22:47:07 <startling> chrizz: yes. uninstall those too, is the idea.
22:47:12 <chrizz> oh
22:47:13 <startling> or --force-reinstalls
22:48:59 <dzianis> @help
22:48:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:51:19 <chrizz> hmm, seems like a --force-reinstalls for this particular package wouldn't really break anything... a lot of packages will re-link against containers (from 0.5.0.0 to 0.5.3.1) which seems fine, since they probably just put as dependencies "containers ==0.5.*" or just "containers"
22:51:34 <chrizz> even though I have heard --force-reinstalls is usually a bad idea
22:51:49 <startling> "usually a bad idea"
22:51:52 <chrizz> so unless the containers api changed it shouldn't be a problem
22:51:57 <startling> isn't really a bad idea.
22:52:17 <chrizz> hmm?
22:52:21 <startling> you can always delete all of ~/.ghc, after all.
22:52:25 <chrizz> right, haha
22:52:29 <startling> it's not going to burn your house down.
22:52:48 <chrizz> that's true, thanks
22:53:06 <chrizz> if my house burns down it's your fault though
22:53:52 <startling> :x
22:55:36 <Aetherspawn> cabal install does take ages though
22:56:02 <Aetherspawn> so it's useful to try and avoid destroying your .cabal :)
22:56:44 <carter> thankfully cabal 1.18 has parallel builds :)
22:58:06 <ChongLi> carter: how do you turn those on?
23:03:14 <Aetherspawn> it works on osx but not on windows for me
23:03:52 <Aetherspawn> maybe I have to configure it to work, or something, but cabal install cabal-install and making sure the latest is on path doesn't give me para even after I delete .cabal
23:26:31 <rajeshsr> hi
23:26:38 <rajeshsr> when i define let b = b
23:26:40 <rajeshsr> :t b
23:26:42 <lambdabot> Expr
23:26:42 <rajeshsr> says it is t
23:26:57 <rajeshsr> what does that mean?
23:27:08 <rajeshsr> i thought the type will be inferred as "a", as any type..
23:27:17 <ChongLi> a, t, b, t1, c
23:27:27 <ChongLi> these are all just symbols
23:27:43 <rajeshsr> ChongLi, well, yep! But i thought the interpreter starts naming from a
23:27:43 <ChongLi> they only have meaning relative to one another
23:27:56 <rajeshsr> so, was wonderinfg if t has any reserved meaning...
23:28:07 <ChongLi> I'm not sure how the naming works
23:28:14 <ChongLi> it's strange
23:28:15 <rajeshsr> ChongLi, hmm, thanks!
23:33:27 <jle`> rajeshsr: technically on lambdabot you can think of "a" as an assigned/named variable in some cases
23:33:50 <jle`> it's special to lambdabot
23:34:02 <rajeshsr> jle`, it's a type variable, right?
23:34:06 <jle`> no
23:34:09 <jle`> b is a value
23:34:11 <jle`> like x
23:34:13 <jle`> or foo
23:34:15 <jle`> or bar
23:34:17 <jle`> of type Expr
23:34:22 <jle`> like "hello" is of type String
23:34:27 <shachaf> 'a' is a human convention
23:34:27 <startling> > map f [a, b, c] :: [Expr]
23:34:29 <jle`> it's a part of the Reflections package
23:34:30 <lambdabot>  [f a,f b,f c]
23:34:34 <jle`> just mostly for debugging
23:34:40 <jle`> and cool stuff like what startling typed.
23:34:44 <startling> mostly for showing off stuff on lambdabot.
23:34:45 <shachaf> GHC tries to reuse variable names.
23:34:48 <shachaf> For example
23:34:52 <startling> > foldr f a [b, c, d] :: Expr
23:34:53 <shachaf> :t let b = b in b
23:34:54 <lambdabot>  f b (f c (f d a))
23:34:54 <lambdabot> t
23:34:55 <shachaf> :t let b = id b in b
23:34:56 <lambdabot> a
23:35:00 <shachaf> Since id :: a -> a
23:35:20 <shachaf> But if it has nothing to use, it'll usually just pick t (presumably for "type").
23:35:29 <rajeshsr> wait! I am confused
23:35:37 <rajeshsr> > :t let b = b in b
23:35:38 <lambdabot>  <hint>:1:1: parse error on input `:'
23:35:47 <rajeshsr> > :t let b = b in b :: Expr
23:35:49 <lambdabot>  <hint>:1:1: parse error on input `:'
23:35:56 <jle`> rajeshsr: don't be too confused, think of it as someone somewhere in Lambdabot's source code
23:36:03 <jle`> defined a variable b
23:36:09 <jle`> for us
23:36:13 <jle`> kinda
23:36:30 <jle`> so when you say let b = b, you're setting b to that already defined b
23:36:41 <startling> jle`: I think you're confusing things.
23:36:48 <startling> rajeshsr, what was your question?
23:36:52 <rajeshsr> hey, wait! i am not talking about lambdabot. I am talking about ghci
23:37:02 <rajeshsr> in ghc
23:37:03 <jle`> oh yeah i'm probably confusing things more
23:37:05 <jle`> i'll back out now
23:37:05 <rajeshsr> if i do let b = b
23:37:09 <rajeshsr> and say :t b
23:37:18 <startling> @let b = b
23:37:18 <lambdabot>  .L.hs:156:5:
23:37:18 <rajeshsr> i get "t"
23:37:18 <lambdabot>      Ambiguous occurrence `b'
23:37:18 <lambdabot>      It could refer to either `L.b', defined at .L.hs:156:1
23:37:18 <lambdabot>                            or `Debug.SimpleReflect.b',
23:37:18 <lambdabot>                               imported from `Debug.SimpleReflect' at .L.hs:11...
23:37:27 <startling> rajeshsr, yeah.
23:37:29 <shachaf> rajeshsr: That happens here too.
23:37:32 <shachaf> :t let b = b in b
23:37:33 <lambdabot> t
23:37:36 <jle`> rajeshsr: yeah it uses t by default kinda
23:37:37 <rajeshsr> as opposed to "a". I understand t is any other type variable..
23:37:38 <startling> rajeshsr, it's just a free type variable.
23:37:42 <shachaf> :t let b = id b in b
23:37:43 <lambdabot> a
23:37:52 <rajeshsr> but i would expect it to start with "a"
23:37:57 <startling> rajeshsr, you can think of it as forall t. t.
23:38:05 <rajeshsr> like it does when you do, :t let b = []
23:38:06 <shachaf> Well, your expectation turned out to be wrong.
23:38:16 <jle`> are you asking why it arbitrarily chose t instead of arbitrarily choosing a?
23:38:24 <rajeshsr> jle`, exactly! :)
23:38:25 <jle`> i think someone made an arbitrary choice somewhere down the line
23:38:28 <jle`> :|
23:38:32 <rajeshsr> is there some special semantics you attach to "t"...
23:38:33 <ChongLi> it's useful
23:38:42 <jle`> there are no special semantics to any type variable
23:38:47 <shachaf> @let data FakeList q = FakeNil | FakeCons q (FakeList q)
23:38:48 <lambdabot>  Defined.
23:38:50 <shachaf> :t FakeNil
23:38:51 <lambdabot> FakeList q
23:38:52 <jle`> however if the type variable is used in the definition of a thing
23:38:54 <jle`> like that
23:38:58 <jle`> or like in a typeclass
23:39:01 <jle`> it'll show up
23:39:02 <ChongLi> there is one thing I know from type variables is that they prefer not to change their names
23:39:09 <ChongLi> :t id
23:39:09 <jle`> but otherwise if there is no preference then it uses something arbitrary
23:39:10 <lambdabot> a -> a
23:39:13 <jle`> i don't think it's in the report
23:39:14 <shachaf> No special semantics. All type variables are equal.
23:39:39 <shachaf> The reason it happens with [] is probably that the type is defined as data [] a = [] | a : [] a
23:40:00 <rajeshsr> shachaf, ha, makes sense
23:40:18 <ChongLi> so the result of id is always going to be type "a" unless something else gives it a reason to change its name
23:40:22 <rajeshsr> > :t let myid x = x in myid
23:40:23 <lambdabot>  <hint>:1:1: parse error on input `:'
23:40:34 <rajeshsr> why lambdabot hates me? ;)
23:40:42 <ChongLi> you're trying to mix 2 different commands
23:40:43 <ChongLi> >
23:40:44 <shachaf> You should look more carefully at what other people are typing.
23:40:46 <ChongLi> and :t
23:40:49 <shachaf> lambdabot isn't ghci.
23:40:56 <shachaf> (It's like a puzzle.)
23:41:22 <rajeshsr> shachaf, you are right indeed! :)
23:41:27 <rajeshsr> myid is returning t->t
23:41:28 <rajeshsr> in ghci
23:41:39 <rajeshsr> > :t (let myid x = x in myid)
23:41:40 <lambdabot>  <hint>:1:1: parse error on input `:'
23:41:45 <rajeshsr> ok, i giv eup! :)
23:41:50 <rajeshsr> ghci works fine
23:41:55 <ChongLi> :t let myid x = x in myid
23:41:56 <lambdabot> t -> t
23:42:04 <shachaf> rajeshsr: Look carefully at what I typed and at what you typed.
23:42:12 <shachaf> lambdabot isn't ghci
23:42:36 <rajeshsr> :t (let myid x = x in myid)
23:42:37 <lambdabot> t -> t
23:42:40 <rajeshsr> ha! :)
23:42:52 <rajeshsr> : and > are 2 commands lambdabot understands?
23:42:54 <rajeshsr> got it!
23:43:05 <rajeshsr> thanks everyone! :)
23:43:26 <startling> :t let myconst a b = b
23:43:27 <lambdabot> <no location info>: not an expression: `let myconst a b = b'
23:43:32 <startling> :t let myconst a b = b in myconst
23:43:33 <lambdabot> t -> t1 -> t1
23:43:47 <rajeshsr> BTW, shachaf what sort of sorcery were you doing with Expr? It looks like it was doing some syntcatic computation..
23:43:56 <rajeshsr> i will like to know more about it! :)
23:44:20 <shachaf> I wasn't doing anything with Expr.
23:44:29 <shachaf> That was all other people.
23:44:29 <ChongLi> > foldl (+) 0 [1..10] :: Expr
23:44:30 <lambdabot>  0 + 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 + 10
23:44:38 <shachaf> Look up "simplereflect"
23:44:53 <startling> rajeshsr, it's just a cute library that breaks a lot of laws but lets you show off things in lambdabot
23:45:11 <rajeshsr> startling, it doesn't seem to be part of Prelude..
23:45:16 <rajeshsr> is part of standard gch?
23:45:19 <shachaf> It isn't.
23:45:24 <startling> rajeshsr, http://hackage.haskell.org/package/simple-reflect
23:45:25 <shachaf> Look up "simplereflect".
23:45:27 <startling> it's a library
23:45:27 <rajeshsr> *ghc
23:45:34 <rajeshsr> ha, ok!
23:45:37 <rajeshsr> thanks!
23:45:44 <startling> > mapM f [a, b, c]
23:45:45 <lambdabot>  No instance for (Debug.SimpleReflect.Expr.FromExpr (m0 b0))
23:45:45 <lambdabot>    arising from a use of `e_1'
23:45:45 <lambdabot>  The type variables `m0', `b0' are ambiguous
23:45:45 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
23:45:45 <lambdabot>  Note: there is a potential instance available:
23:45:48 <startling> > mapM f [a, b, c] :: Expr
23:45:50 <lambdabot>  Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
23:45:50 <lambdabot>              with actual type `m0 [b0]'
23:46:08 <startling> I thought there was an evil Monad instance at one point.
23:46:24 <startling> I guess it doesn't have the right kind.
23:50:12 <keep_learning> Hello All
23:51:03 <keep_learning> I am goint through this code http://www.cse.chalmers.se/edu/course/afp/lectures/lecture11/Typed.hs.html
23:51:23 <keep_learning> In this code data TypedExpr = forall t. Eq t =>   Expr t ::: Type t
23:51:55 <keep_learning> I am wondering t will take all the values which is defined for Eq class
23:51:57 <Anpheus_> Another question: suppose I have a foreign library I am binding against and I want to bubble up errors/exceptions. Many of these are transient, resolvable errors (the foreign library is exceptionally well written and largely safe). Do I use ErrorT or Exception?
23:52:05 <keep_learning> Int, Integer
23:52:22 <keep_learning> Float, Double, Bool
23:52:27 <keep_learning> @Eq
23:52:28 <lambdabot> Maybe you meant: wn v rc pl id faq do bf @ ? .
