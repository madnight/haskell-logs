00:08:44 <bernalex> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot none of these work, pls halp?
00:08:55 <bernalex> first example gives me "getAddrInfo: does not exist (Name or service not known)", second one gives me nothing.
00:09:31 <haasn> what a silly example
00:09:55 <haasn> as for why it doesn't work, no idea; but: use pipes!
00:11:55 <bernalex> haasn: is there a tutorial for that which happens to be an irc bot?
00:12:04 <frxx> first example worked fine for me
00:12:05 * hackagebot separated 0.0.3 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.0.3 (TonyMorris)
00:12:05 * hackagebot fast-logger 2.1.1 - A fast logging system  http://hackage.haskell.org/package/fast-logger-2.1.1 (KazuYamamoto)
00:13:03 <bernalex> frxx: hmmm... maybe I need to update some packages.
00:13:04 <frxx> try using a different server name, sometimes I have trouble connecting to irc.freenode.org with my regular client
00:13:54 <bernalex> frxx: I use .net
00:14:12 <frxx> code used org.
00:15:07 <bernalex> frxx: I modified the code.
00:15:37 <frxx> no clue then.
00:16:49 <discus> how does haskell compare to ocaml? ate they similar?
00:17:00 <bernalex> discus: haskell is purely functional
00:17:18 <bernalex> discus: ocaml says "omg side-effects are so neat!", haskell says "nope."
00:17:23 <mauke> discus: depends on how hard you squint
00:17:39 <bernalex> to someone who doesn't know functional programming, they are quite obviously similar, I guess.
00:17:44 <mauke> if you come from other languages, they're pretty similar
00:17:58 <mauke> type system, type inference, pattern matching
00:18:13 <mauke> first class functions, algebraic data types, ...
00:18:24 <mauke> oh, and user defined operators
00:18:32 <merijn> discus: Haskell should be fairly simple to pick up if you know ocaml
00:18:38 <bernalex> spj identified that ocaml code tended to be in a expression style (like lisp) rather than a declaration style, which haskell commonly use. haskell support both though.
00:18:43 <mauke> merijn: should, but isn't :-/
00:18:48 <Malar> why is the output in wrong order? http://lpaste.net/98084 , it is waiting for my input before printing "prompt>" in the example. is it right behaviour?
00:18:57 <Kaidelong> why does HXT have no pure function for turning an XmlTree into some kind of text type?
00:19:02 <mauke> Malar: you're suffering from buffering
00:19:10 <merijn> mauke: Really? The other way around (i.e. ocaml from haskell) is pretty trivial
00:19:12 <Kaidelong> everything seems to have something wrapped in IOStateArrow
00:19:19 <mauke> Malar: add 'hFlush stdout' after putStr
00:19:30 <Malar> ok thanks, mauke
00:19:41 <mauke> merijn: heh, I found both surprisingly hard
00:19:43 <discus> I dont know ocaml, I was recommended both haskell and ocaml as my first functional programming language.
00:20:13 <mauke> if you want to full-ass functional programming, you should go with haskell
00:20:16 <discus> I am familiar with C, python, ruby, java
00:20:23 <merijn> discus: I think haskell will teach you better habits than ocaml
00:20:54 <mauke> merijn: ocaml was reasonably easy to learn after perl, but then haskell was rather frustrating
00:21:07 <mauke> I couldn't get my head around laziness, and there was no good explanation of IO
00:21:10 <Kaidelong> I think the IO trap actually backfires on that, you end up sticking to writing imperative haskell rather than mixing them freely
00:21:19 <merijn> discus: Also, haskell's laziness makes it "more different" and thus more interesting than ocaml
00:21:37 <mauke> I learned haskell at my second attempt
00:21:50 <mauke> but now I can't go back to ocaml because it's so irregular and ugly
00:22:53 <merijn> discus: Oh, another reason for haskell is that ocaml syntax is an eyesore :p
00:23:18 <discus> thanks for all the feedback. what book is usually recommended for a programmer who is a haskell/functional newbie?
00:23:28 <discus> but not a programming newbie
00:23:29 <mauke> the weird thing is that I was and still am comfortable with Perl, but ocaml is just ... ew
00:23:46 <dv-> @where gentle
00:23:46 <lambdabot> http://www.haskell.org/tutorial/
00:23:48 <merijn> discus: Learn You a Haskell is good
00:23:52 <mauke> @where lyah
00:23:53 <lambdabot> http://www.learnyouahaskell.com/
00:24:16 <mauke> discus: you might as well be a programming newbie
00:24:18 <merijn> discus: The Gentle Intro...could be gentler...
00:24:23 <Kaidelong> I'm going to try xml-conduit
00:24:24 <mauke> even the order in which you learn stuff is different
00:24:34 <mauke> (I think that tripped me up initially)
00:24:48 <Kaidelong> HXT is opaque, xml-conduit seems relatively clear via the haddocks, even if the Yesod website's description of it isn't
00:25:06 <merijn> Step 1 of learning haskell as an existing programmer is: Everything you know is wrong :p
00:25:07 <discus> mauke: what order do you mean?
00:25:18 <discus> :)
00:25:22 <dleedev> discus: I agree with mauke "you might as well be a programming newbie"
00:25:31 <mauke> I mean, defining a tree structure and operations on it: trivial
00:25:37 <mauke> doing I/O: no, that's more advanced
00:25:51 <mauke> that's pretty much the opposite of how you do things in e.g. C
00:26:31 <dleedev> what's the best way to do multi-line REPL with ghci?
00:26:47 <merijn> dleedev: :{ and :}
00:27:02 <merijn> dleedev: But I would recommend just opening a file in a text editor and loading/reloading that in ghci
00:27:03 <mauke> data Tree a = Empty | Node a (Tree a) (Tree a)   -- there, a polymorphic tree type
00:27:22 <dleedev> merijn: how do you make that a tight loop?
00:27:48 <dleedev> merijn: I don't want to keep closing ghci and starting a new session
00:28:08 <merijn> dleedev: You can ":l file.hs" to load and ":r" to reload a changed file
00:28:23 <dleedev> ":r file.hs" or just ":r"?
00:28:31 <merijn> dleedev: Just :r
00:28:44 <dleedev> and what happens to the code that was loaded from the old version?
00:29:06 <mauke> thrown away
00:29:10 <quicksil1er> ...or use an editor with ghci integration and just hit some keystroke to send the file to ghci
00:29:33 <dleedev> mauke: what about code that you typed into ghci that depends on modules from the thrown away code?
00:29:50 <dleedev> quicksil1er: a good ghci integration for vim?
00:30:10 <mauke> dleedev: huh?
00:30:20 <mauke> don't define stuff in ghci
00:31:36 <quicksilver> dleedev: possibly this - http://www.vim.org/scripts/script.php?script_id=2356 - but I have no personal experience of it
00:31:39 <helmut> is there a way to ask ghci for all (known) instances of a particular type (subject to the already imported modules)?
00:32:18 <quicksilver> see also https://github.com/eagletmt/ghcmod-vim
00:32:25 <quicksilver> helmut: do you mean instances of a class?
00:32:30 <helmut> quicksilver: yes
00:32:39 <quicksilver> :i
00:32:44 <quicksilver> for example, :i Show
00:33:02 <quicksilver> (possibly not the best example since that class has LOTS of instances!)
00:33:30 <helmut> quicksilver: ah wait, no I do mean the other way round. I want to learn about all classes that have instances for a particular type
00:33:33 <mauke> :i Functor is shorter
00:33:39 <helmut> of course that list is necessarily incomplete
00:33:42 <mauke> helmut: :i []
00:33:45 <mauke> it works both ways
00:33:49 <quicksilver> helmut: :i Typename works too
00:34:25 <helmut> it appears not to work with polymorphic types (or there are no known instances ;-)
00:35:06 <quicksilver> :i [] works for me, and shows the polymorphic instances of that
00:35:35 <quicksilver> but the syntax only accepts type constructors, not arbitrary type expressions
00:35:44 <helmut> yes, I figured that
00:36:00 <helmut> in any case, thanks, :i is useful to me already
00:37:26 <dleedev> quicksilver: just tried out SHIM.vim and it's a no go
00:37:48 <dleedev> quicksilver: trying out ghcmod...
00:38:25 <ChongLi> ghc-mod is great!
00:40:40 <helmut> why does hoogle have no "I'm feeling lucky" button? %-)
00:41:17 <helmut> that'd be damn useful, since often enough the first hit is the right one.
00:44:07 <Kaidelong> apparently to get a FilePath that works with xml-conduit I need to do "fromText . pack" unless I use OverloadedStrings and start writing manifest types
00:44:26 <Kaidelong> overengineering seems to be a problem with a lot of haskell libraries
00:44:39 <Kaidelong> I'm guessing it's because haskell's core libraries perform too poorly
00:45:24 <Kaidelong> (what's stranger is why Filesystem.Path.CurrentOS doesn't provide a constructor for a FilePath that uses a String)
00:46:06 <ChongLi> Kaidelong: yeah, there are some library authors who absolutely despise String
00:46:17 <ChongLi> with good reason
00:46:43 <ChongLi> storing a couple of machine word length pointers for every character is not exactly efficient
00:47:53 <Kaidelong> it is a real shame because haskell at its core is so pleasant to work with but then the libraries try really hard to be very performant and generic and end up becoming opaque and mysterious, it actually reminds me a bit of using C and having to be aware of the different kinds of conventions different programmers use
00:48:44 <ChongLi> Kaidelong: well, if we had Text all along instead of String we'd not have this problem
00:49:18 <Kaidelong> it's not just text vs string, there are other examples too
00:49:36 <Kaidelong> Time vs Thyme, random-fu vs System.Random, vector vs array
00:49:50 <Kaidelong> people keep reinventing the core libraries of haskell
00:49:53 <helmut> essentially you are arguing about a lack of uniformity
00:50:10 <zRecursive> sometimes it it
00:50:14 <zRecursive> it is
00:50:32 <ChongLi> Kaidelong: all of those examples you mentioned have very good reasons for existing
00:50:54 <Kaidelong> I am not denying that
00:51:20 <zRecursive> Maybe we need a list of canonical libraries
00:51:27 <Kaidelong> but the whole mess does seem to violate KISS
00:51:33 <dleedev> quicksilver: unfortunately, ghcmod-vim only provides code introspection/lint and not REPL
00:51:34 <ChongLi> zRecursive: yeah
00:51:42 <eazar001> kaidelong: i don't think haskell is about KISS
00:51:46 <ChongLi> we could call it... hmmm, how about Haskell Platform?
00:51:49 <Kaidelong> especially when you end up with stuff like "I really want to use a vector here but this library expects an array"
00:51:51 <eazar001> I always thought that was a pythonic thing
00:52:11 <eazar001> as a haskell newb, i'm under the impression that haskell was about inventiveness
00:52:15 <Kaidelong> eazar001: the haskell language itself is really generally very consistent and unsurprising in my experience
00:52:29 <ChongLi> Kaidelong: which library expects an array?
00:52:44 <eazar001> strange you and i have very different perspectives
00:52:44 <Kaidelong> lemme see if I can find it, hang on
00:52:54 <eazar001> but i kind of am new to it i suppose
00:53:24 <eazar001> monads, arrows, non-determinism, pure functionality, laziness ....
00:53:31 <eazar001> these things don't strike me as very traditional
00:53:55 <Kaidelong> maybe not but traditional programming is not simple at all
00:54:10 <eazar001> i agree
00:54:12 <helmut> eazar001: it's not about being non-traditional, but having multiple ways to express all that kind of stuff
00:54:15 <Kaidelong> trying to ensure that = actually means what you think it does really simplifies things a lot
00:54:27 <eazar001> helmust: i agree as well
00:54:38 <eazar001> is that looked down upon?
00:54:52 <eazar001> pythonistas philsophy: there should be one way to do it
00:55:01 <eazar001> nice for some cases
00:55:12 <eazar001> but boring and restrictive at times
00:55:13 <Kaidelong> helmut: I'm not sure if that's a good thing or is a concious design, after all the commitee gave people arbitration powers exactly to avoid this
00:55:13 <helmut> for instance, I am still confused about error, fail, throwError, dynError
00:55:18 <eazar001> and i'm not bashing python
00:55:22 <ChongLi> but not so nice when the *one way* is the wrong way
00:55:33 <eazar001> chongli: good point
00:56:28 <mauke> 'error' is for internal errors in your code where you want to abort the program
00:56:35 <ChongLi> it seems there's a big difference between BDFL and non-BDFL languages
00:56:37 <Kaidelong> ChongLi: I can't remember when I ran into that but my specific gripe was needing to marshal inbetween types to make libraries work together
00:56:39 <tdammers> "import this" is a lie anyway
00:56:39 <mauke> 'fail' is (sadly) a method of Monad
00:56:55 <Kaidelong> it's somewhat sad because it's that situation that typeclasses are supposed to help with
00:57:03 <mauke> I don't know what dynError is
00:57:06 <eazar001> yep
00:57:27 <eazar001> i personally don't mind the chaos that eminates from haskell
00:57:29 <ChongLi> Kaidelong: type classes are supposed to handle automatic marshaling?
00:57:35 <eazar001> a little entropy is good, just as long as its under control
00:57:50 <Kaidelong> ChongLi: type classes are supposed to let you write polymorphic functions so that you don't need to do the marshalling at all
00:58:21 <ChongLi> Kaidelong: right, but that comes at the cost of efficiency sometimes
00:58:29 <tdammers> type classes are a bit like templates in C++, but explicit
00:59:38 <Kaidelong> I think the state of the haskell library ecosystem is kind of sad, but it is possible I'm just spoiled by .NET
00:59:54 <tdammers> so just like you can write template<typename T> T add(const T& a, const T& b) { return a + b; }
01:00:15 <ChongLi> Kaidelong: not if you look at per-capita library quality :)
01:00:37 <tdammers> you can write class Addable a where add :: a -> a -> a; instance (Num a) => Addable a where add = (+)
01:00:53 <Kaidelong> ChongLi: how do you mean? Libraries are most useful when you can cleanly use them together
01:01:17 <tdammers> come to think of it, it's not quite the same
01:01:18 <ChongLi> Kaidelong: I mean that Haskell's community is orders of magnitude smaller than .NET
01:01:34 <Kaidelong> ChongLi: shouldn't that, if anything, help here?
01:01:57 <Kaidelong> less library authors, easier to harmonize haskell code
01:02:01 <Kaidelong> fewer*
01:02:04 <tdammers> Haskell's community is also orders of magnitude more open than .NET's
01:02:09 <ChongLi> Kaidelong: well, what's working against us is that old libraries don't get deleted
01:02:16 <Kaidelong> tdammers: how so?
01:02:16 <ChongLi> they just hang around
01:02:25 <ChongLi> and Haskell is a much older language than C#
01:02:37 <tdammers> Kaidelong: well, my experience with .NET so far is very much a closed-source proprietary one
01:03:00 <Kaidelong> ChongLi: I admit I forget that sometimes
01:03:04 <ChongLi> whew, -25C here
01:03:23 <Kaidelong> tdammers: there are a lot of closed source tools but there is plenty of C# on git and codeplex
01:03:27 <tdammers> Kaidelong: and the part of the community that I experienced was pretty much in line with that - lots of Q&A forum activity and such, but not a lot of source code sharing and collaborative work on the libraries and things
01:03:27 <Kaidelong> github*
01:03:53 <tdammers> just one example
01:03:55 <Kaidelong> tdammers: I suppose there is more commercial, propietary stuff for C# because there is a larger marketplace
01:04:00 <tdammers> LINQ vs. Lenses
01:04:07 <randomclown> if a thread (forkIO) encounters an exception
01:04:14 <randomclown> that's not handled
01:04:16 <randomclown> does it die?
01:04:21 <randomclown> will it affect any other threads?
01:04:40 <mauke> randomclown: I think it will take down that thread (only)
01:04:42 * FiLoSsOfIe hello
01:04:43 <Kaidelong> tdammers: which part of LINQ are you talking about? The language extensions or the database backends?
01:05:10 <tdammers> Kaidelong: the language extensions and collection backends, mainly
01:05:26 <tdammers> last time I used them, the source code to these was not freely available
01:05:37 <tdammers> they worked exceptionally well, but they were mostly a black box
01:05:56 <tdammers> a well documented black box, mind you
01:06:06 <tdammers> but a black box still
01:06:55 <Lethalman> so many SO haskell unanswered questions :S
01:07:09 <helmut> is it technically possible to generate an error, that can be handled with catchError, in an expression of type MonadError e m => m ()? Note the lack of an Error e instance requirement.
01:07:10 <Kaidelong> tdammers: mono has support for the language extensions and the documentation has to be pretty complete because it's possible to write your own backends that work with linq syntax
01:07:22 <Lethalman> ah, I was on the unanswered tab sorry lol
01:07:42 <tdammers> Kaidelong: sure sure... still, the mainstream C# culture is not an open-source one
01:07:56 <tdammers> Kaidelong: and that's fine, I guess
01:08:47 <Kaidelong> tdammers: there is enthusiasm for it at the community level because of the whole phenomenon of social coding but not among people who make commercial products
01:08:59 <eazar001> yea you just kind of get an idea of what are the "open source languages" by looking at the job postings lol
01:09:20 <eazar001> should be uncorrelated, but they are
01:09:27 <eazar001> aren't*
01:10:18 <tdammers> eazar001: I don't really think so
01:10:22 <lieven_> I'm getting an error I don't understand. I have a typeclass with a function foo in it and I can implement foo for Enum's in terms of toEnum. but instance Enum a => Foo a gets refused and the error refers me to FlexibleInstances. Should I enable this?
01:10:26 <Kaidelong> there is the perception, probably correct, that it is difficult to sell open source software
01:10:35 <tdammers> eazar001: top 3 are probably still C#, Java, PHP
01:10:55 <eazar001> okay Java is pretty open source
01:11:00 <eazar001> you got me there
01:11:05 <mauke> lieven_: you don't want that instance
01:11:18 <tdammers> eazar001: not really... IIRC, the "standard" implementation is in fact *not* free software
01:11:32 <eazar001> yes ....
01:11:35 <Kaidelong> Java and Solaris mainly got opened up because Sun was on its last legs
01:11:37 <eazar001> but i'm looking at android
01:11:44 <Kaidelong> and now Oracle has taken them behind lock and key again
01:11:47 <lieven_> mauke: what's the alternative?
01:12:14 <mauke> ...
01:12:16 <helmut> @djinn Monad m => m ()
01:12:16 <lambdabot> -- f cannot be realized.
01:12:28 <helmut> why is f = return () no realization?
01:12:42 <mauke> djinn doesn't believe in parameterized types
01:13:05 <helmut> ok
01:13:09 <eazar001> tdammers: so are you trying to say that C# fits under the open source category for you?
01:13:17 <ChongLi> randomclown: sorry, I'm back
01:13:30 <helmut> so my attempt to @djinn MonadError e m => m () is foiled.
01:13:41 <Kaidelong> @djinn (a -> m a) -> m ()
01:13:41 <lambdabot> -- f cannot be realized.
01:13:53 <Kaidelong> oh right
01:14:09 <Kaidelong> @djinn (() -> m ()) -> m ()
01:14:09 <lambdabot> f a = a ()
01:14:27 <ChongLi> randomclown: the answer is that your other threads are unaffected
01:15:22 <Kaidelong> does djinn support  impredicative types?
01:15:23 <Kaidelong> I doubt it
01:15:37 <Kaidelong> @djinn (forall a. a -> m a) -> m ()
01:15:37 <lambdabot> -- f cannot be realized.
01:16:14 <enthropy> that isn't impredicative anyways
01:16:48 <tdammers> eazar001: no
01:16:55 <tdammers> eazar001: PHP does
01:17:08 <enthropy> or whatever the classification, you're allowed such a thing with just -XRank2Types
01:17:11 <eazar001> tdammers: I think you and I were talking about slightly different things, i'm sorry
01:17:36 <Kaidelong> tdammers: facebook keeps use chunks of their PHP implementation closed and secret
01:17:59 <Kaidelong> I think they either reimplemented it or the stuff wasn't liscensed AGPL
01:18:00 <tdammers> eazar001: well, you said there was a correlation between a language's open-sourced-ness and the number of job openings for it
01:18:04 <eazar001> kaidelong: we are all using "open source" in different ways
01:18:25 <zomg> Kaidelong: well didn't they opensource the HHVM so what would be the point of hiding parts of it?
01:18:25 <eazar001> tdammers, you, and i are mixing the "open source spirit" with actual literal interpretation of "open source"
01:18:46 <tdammers> we should clear that up, yes
01:18:47 <zomg> I mean it's clearly beneficial for them to drive higher adoption for HHVM
01:19:11 <tdammers> language specs, standard implementation, culture, and products built with it are separate things
01:19:17 <eazar001> i would say java for example is not open source
01:19:20 <eazar001> obviously
01:19:25 <tdammers> indeed it is not
01:19:31 <eazar001> but their attitude has become increasingly open source
01:19:37 <tdammers> well
01:19:41 <eazar001> but still not in the lisp, haskellish sense
01:19:45 <eazar001> just relatively
01:20:38 <tdammers> the specs are open (I think), the standard implementation is not, the culture is mostly about proprietary development these days, but there used to be a fairly strong open-source subculture, and products built with it are very diverse in licensing
01:20:50 <eazar001> SML, i see as a very open source language for exmaple, but it is now frozen and static, so not as much
01:21:08 <eazar001> tdammers: for java?
01:21:14 <tdammers> yes
01:21:26 <eazar001> yea, they are still very business-oriented
01:21:36 <Kaidelong> zomg: probably for the parts of their PHP infrastructure that have no relationship to HHVM
01:21:47 <Kaidelong> tdammers: C#'s specs are open
01:21:51 <eazar001> in terms of the spirit i just saw some flashes, for xample with the whole android-google craze, etc.
01:22:11 <zomg> Kaidelong: ah yeah could be
01:22:16 <tdammers> Kaidelong: yes, but the standard implementation, culture, and products are not
01:22:19 <tdammers> not very much, anyway
01:22:30 <Kaidelong> microsoft also provided technical assistance to the mono project, so they clearly weren't opposed to open source reimplementations
01:22:45 <tdammers> I know
01:22:50 <Kaidelong> if you count "the developers were allowed to respond to emails in a helpful way" as technical assistance anyway
01:23:12 <tdammers> still, most of the C# community embraces proprietary development
01:23:30 <Kaidelong> I think it's more  open-ness to propietary development
01:24:04 <Kaidelong> so permissive liscenses like LGPL or Ms-PL rather than a full viral GPL
01:24:04 <tdammers> idk... I think it's more a matter of defaulting to proprietary
01:24:32 <Kaidelong> the Ms-PL is actually a very nice liscense
01:24:40 <tdammers> as in, build a product, see if it's marketable, and if it's not, open-source it
01:24:49 <Kaidelong> it's like a BSD liscence but it gets revoked if you sue the author for infringing on your patents
01:24:56 <tdammers> (the usage of "open-source" as a verb is speaking in this context...)
01:25:45 <zomg> MSFT seems to be somewhat pushing towards more open and "modern" practices
01:25:53 <zomg> Like with all this NuGet stuff lately etc.
01:26:01 <Kaidelong> NuGet is third party
01:26:14 <Kaidelong> not sure if it is blessed
01:26:17 <tdammers> oh, and anyway, I've left the MS ecosystem behind a while ago, so things may have changed somewhat
01:26:23 <eazar001> tough call some argue that the closed source and controlled is better, due to incentive
01:26:43 <tdammers> eazar001: I'm pretty much with Stallman on this one
01:26:47 <eazar001> people like paul graham would argue that core technology leads to clear advantages for programmers
01:27:06 <donri> i don't want progress at any cost, i want the right kind of progress :P
01:27:12 <Kaidelong> tdammers: a fair amount of microsoft products are open source and now living on codeplex, and microsoft lawyers wrote some GPL-like liscenses
01:27:23 <donri> (right meaning left in this case ;))
01:27:33 <eazar001> tdammers: me too
01:27:41 <Kaidelong> codeplex being microsoft's take on sourceforge
01:28:05 <tdammers> for me, the question is not "which licensing model leads to the best possible software"
01:28:30 <donri> that can be the question, FSVO "best software"
01:28:46 <tdammers> it's not why I'm a free software kind of guy though
01:29:02 <tdammers> I prefer free software even when the proprietary alternatives are technically better
01:29:18 <tdammers> it's a matter of trust
01:29:21 <eazar001> hmmm
01:29:23 <donri> for me closed means i'll be *very* reluctant to use the software at all
01:29:31 <tdammers> yes
01:29:35 <eazar001> admittedly .... i don't find too many cases like that
01:29:47 <eazar001> but i happen to be the same way
01:29:58 <tdammers> sometimes, you don't have much of a choice
01:30:00 <Kaidelong> http://www.codeplex.com/site/users/view/MSOpenTech
01:30:03 <eazar001> it's kind of counter-productive when observed from the outside ... but
01:30:09 <eazar001> it has a lot to do with your personal philosophy
01:30:17 <donri> yeah, i'm not fanatic about it
01:30:32 <tdammers> e.g., when you travel, you have to trust *some* transportation system with your life, basically
01:30:43 <eazar001> but personal philosophy can have long reaching goals not readily observable, it's difficult to describe
01:30:46 <tdammers> and you don't get to pick the software that runs those transportation systems
01:30:52 <donri> eazar001: it's not counter-productive to the long-term betterment of society ;)
01:30:57 <zomg> Kaidelong: from the few microsoftie blogs I've followed they seem to like NuGet (Phil Haack, Scott Hanselman etc.)
01:31:02 <tdammers> hint: most cars, trains, airplanes etc. run on proprietary software
01:31:03 <eazar001> donri: very true
01:31:17 <eazar001> short-term expedients always take a backseat in my book
01:31:43 <Kaidelong> zomg: nuget was pretty much exactly what microsoft wanted to happen with their open-ness initiative so I guess it's a vindication for the people who had to argue for it to management
01:31:44 <donri> short-term can take a frontseat in the short-term for me ;)
01:31:49 <eazar001> tdammers: yep
01:31:57 <Kaidelong> we shouldn't be talking about this in #haskell
01:32:00 <eazar001> hahaha
01:32:04 <tdammers> true that
01:32:08 <tdammers> off to -blah we go
01:32:16 <donri> that won't happen
01:33:52 <Kaidelong> anyway on xml-conduit vs hxt
01:34:02 <Kaidelong> I'm finally getting stuff done now that I ditched hxt
01:34:10 <Kaidelong> that's my endorsement for xml-conduit
01:35:52 <donri> xml-picklers is nice too (works with xml-conduit)
01:36:08 <donri> picklers are a bit messy but that's the nicest one
01:36:20 <donri> Philonous++
01:37:15 * hackagebot time-patterns 0.1.2.0 - Patterns for reccurring events.  http://hackage.haskell.org/package/time-patterns-0.1.2.0 (jfmueller)
01:38:08 <Kaidelong> xml-picklers is a serialization library though, isn't it?
01:38:48 <donri> that's one use of it
01:38:55 <Kaidelong> I kind of had trouble finding tutorials and examples because the most common use cases of XML libraries seem to be for parsing or for serialization and I actually just needed rendering
01:39:19 <donri> it lets you write an xml parser and printer from one specification
01:39:34 <donri> with control over the xml format
01:39:41 <bergmark> we use regular-xmlpickler
01:40:05 <bergmark> http://engineering.silk.co/post/31922245822/writing-a-generic-xml-pickler
01:40:26 <Kaidelong> oh, if you can control the way the xml is formatted, xml-picklers might actually provide a more elegant solution than what I was going to do
01:40:50 <donri> yeah there's also hexpat-pickle-generic if all you want is xml serialization without caring about the structure
01:41:08 <donri> but xml-picklers actually let you care about that
01:42:30 <defanor> how could i define an instance of Read for a [custom] type? getting this when trying to do it: `read' is not a (visible) method of class `Read'.
01:42:31 <Kaidelong> 'This module was "inspired" by hexpat-pickle.' <- was xml-picklers motivated by shortcomings in hexpat?
01:43:04 <donri> it's a bit trickier than just parsing or printing directly, but once you have something working it's pretty much guaranteed to work the same both ways and be easier to refactor etc
01:43:12 <shachaf> defanor: Define one of the methods in the type class Read.
01:43:13 <Kaidelong> if so, I'm curious as to what exactly hexpat did wrong that xml-picklers set out to rectify
01:43:34 <donri> hexpat doesn't use xml-types
01:43:44 <donri> xml-picklers also has more useful combinators than hexpat-pickle
01:43:50 <donri> like xpEither
01:43:52 <shachaf> You can ask ghci what methods there are with :i, and you can look at the documentation or at the Haskell Report to read more about them.
01:44:05 <shachaf> read is (thankfully) not one of those methods.
01:44:19 <defanor> shachaf: um, where could i check those methods then?
01:45:26 <donri> defanor: you can compile with -ddump-deriv with a normal deriving (Read) and work from that
01:45:34 <donri> it'll show you the code ghc generates for the derivation
01:45:57 <defanor> donri: thanks, will try
01:46:03 <osa1> is there a way to load multiple modules in ghci?
01:46:24 <shachaf> Yes, or you can read the documentation or the Report, which specify what the behavior should be.
01:47:13 <Kaidelong> isn't implementing read and show considered bad practice?
01:47:24 <defanor> shachaf: what you'd recommend to use as a reference?
01:47:33 <Kaidelong> I thought you were supposed to derive those and write parse and pretty print functions instead
01:47:53 <defanor> Kaidelong: i'm very new to haskell and just learning it, trying features and all that. it's not for real programs anyway
01:47:56 <shachaf> The documentation (on Hackage, found via Hoogle, say) and the Haskell Report.
01:48:28 <defanor> shachaf: thanks
01:48:28 <Kaidelong> defanor: have you tried "deriving (Show, Read)"
01:48:48 <defanor> Kaidelong: yes
01:49:00 <defanor> Kaidelong: i just want to try custom read
01:49:09 <Kaidelong> okay
01:50:46 <Kaidelong> donri: xml-picklers looks like it'll be more marginally more work but also totally worth the effort, thank you
01:51:15 <Kaidelong> when I saw the example for xpOption I realized I was doing that same thing by hand
01:56:26 <donri> \o/
01:59:58 <randomclown> :t fst
01:59:58 <lambdabot> (a, b) -> a
02:00:00 <defanor> when i'm defining "Test" as a word to indicate some type, it works fine, but when i'm doing same with "0" (string) - getting "Exception: Prelude.read: no parse". why is that, are there some restrictions?
02:00:10 <randomclown> is there one for a three tuple?
02:00:13 <randomclown> fst
02:00:33 <merijn> randomclown: No, unless you use lens
02:00:39 <randomclown> noooooooo
02:00:42 <merijn> > view _1 (1,2,3)
02:00:44 <lambdabot>  1
02:00:48 <merijn> > view _1 (1,2,3,4)
02:00:49 <lambdabot>  1
02:01:53 <eazar001> merijn: what did you jsut do?
02:02:10 <eazar001> view _1 (1,2,3,4)
02:02:20 <eazar001> > view _1 (1,2,3)
02:02:22 <lambdabot>  1
02:02:26 <eazar001> > view _2 (1,2,3)
02:02:27 <lambdabot>  2
02:02:36 <eazar001> hmmm, nice
02:02:46 <eazar001> thanks for that exposition
02:02:48 <merijn> eazar001: view, _1 and _2 are from the lens library
02:03:01 <randomclown> eazar001: watch SPJ's lens talk
02:03:07 <eazar001> limitless?
02:03:10 <randomclown> trying to read the docs will get you lost in a maze
02:03:24 <merijn> eazar001: _1 and _2 are lenses that access the 1st/2nd elements of a tuple, "view" displays the value the lens looks at
02:03:36 <eazar001> oh yea i just inferred now ....
02:03:40 <eazar001> but it's infinite right?
02:03:56 <eazar001> lol, maybe i should read the docs and get "lost in that maze then"
02:04:01 <eazar001> thanks guys
02:04:32 <merijn> > (1,2,3) & _1 .~ 'a' -- you can also use them to update
02:04:33 <lambdabot>  ('a',2,3)
02:04:53 <merijn> > (_1 .~ 'a') (1,2,3)
02:04:54 <lambdabot>  ('a',2,3)
02:05:01 <eazar001> sweet
02:05:35 <eazar001> > (_2.~"test") (4,'f',2,12)
02:05:35 <merijn> But yeah, SPJ had a good intro talk on lens
02:05:36 <lambdabot>  (4,"test",2,12)
02:06:02 <randomclown> it's much better than edward dropping his spaghetti
02:06:05 <Kaidelong> @ty (&)
02:06:05 <Kaidelong> @botsnack
02:06:05 <lambdabot> a -> (a -> b) -> b
02:06:06 <lambdabot> :)
02:06:07 <eazar001> lol
02:06:18 <eazar001> why does everyone pick on edwardk?
02:06:34 <merijn> eazar001: http://skillsmatter.com/podcast/scala/lenses-compositional-data-access-and-manipulation
02:07:16 <Kaidelong> @vixen what does merijn have over me?
02:07:16 <lambdabot> I'm glad I'm not Brezhnev. Being the Russian leader in the Kremlin. You never know if someone's tape recording what you say.
02:07:18 <merijn> (&) is just reversed ($)
02:07:36 <merijn> Kaidelong: vixen autocompletes to @nixon
02:08:05 <merijn> Kaidelong: Vixen was dropped due to PC complaints (ironically, @nixon was not). Anyway that's an off-topic discussion
02:11:05 <Philonous> Kaidelong, I wrote xml-picklers because I ran into a memory barrier with String-based xml libraries and there wasn't a pickler library for xml-types
02:13:56 <donri> hexpat can work with text can't it?
02:16:50 <Philonous> donri, Right, I even used it for a while. I actually don't remember why I ditched it
02:22:59 <donri> hexpat is nice but it does require external deps and i find the way it handles string types a bit odd. plus i like the idea of xml-types :)
02:23:15 <donri> e.g. your xml-picklers will probably work with pipes-xml once that's out
02:26:56 <Philonous> There'Until then there's xml-conduit.
02:27:08 <Philonous> -there
02:27:10 <donri> yep
02:27:30 * hackagebot hxt 9.3.1.3 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.3 (UweSchmidt)
02:27:32 * hackagebot hxt-tagsoup 9.1.2 - TagSoup parser for HXT  http://hackage.haskell.org/package/hxt-tagsoup-9.1.2 (UweSchmidt)
02:27:45 <Malar> donri: http://ro-che.info/ccc/15 have they decided yet? is it gonna be pipes?
02:28:03 <donri> Malar: machines!
02:28:06 <donri> Malar: netwire!
02:30:00 <merijn> pipes is pretty nicely designed
02:30:04 <merijn> Very elegant
02:33:15 <merijn> argh
02:33:25 <merijn> Hackage needs some other way to authenticate than password
02:33:58 <merijn> Typing my password to curl to upload docs is 1) not very secure and 2) a pain, considering I need to do all sorts of shell quoting
02:38:04 <Malar> only pipes seems to active?
02:39:18 <merijn> Malar: conduits is fairly active too, but I prefer the design of pipes
02:41:15 <shachaf> As things stand right now I certainly hope that pipes does not become standard.
02:41:20 <shachaf> But there is no great urgency.
02:41:48 <merijn> shachaf: Do you have a preferred solution? Or is it just unclear what's best?
02:44:02 <donri> merijn: netrc?
02:44:48 <shachaf> I would say no to the first question.
02:44:50 <merijn> donri: Is that in relation to my curl/hackage complaint?
02:44:58 <donri> merijn: yeah, curl -n
02:46:36 <merijn> donri: But that mean storing my password in plain text, no?
02:46:54 <donri> merijn: yes, if your .netrc is unencrypted
02:46:57 <merijn> I should check if curl can get passwords from OSX keychain
02:49:55 <Philonous> merijn, You could use a password safe and either copy/paste the password or set it up to auto-type it for you
02:50:26 <merijn> Philonous: That's what I'm doing now, but pasting a password into the shell is still a security (not to mention laziness) issue
02:51:44 <tdammers> merijn: I'd say the issue is copying the password into the clipboard, not so much the pasting
02:52:08 <merijn> tdammers: pasting stores it in shell history, unless I specifically disable that everytime
02:52:29 <donri> maybe you can use --netrc-file with stdin or a pipe and a generated netrc from the keychain + some shell scripting :P (at this point it might be easier to not use curl)
02:53:05 <merijn> donri: To avoid yak shaving
02:53:07 <donri> is there no way to have curl prompt for password? with echo disabled?
02:53:18 <merijn> donri: My problem is: Want to upload non-building docs to hackage
02:53:33 <donri> btw in fish you can skip history by starting the command line with a space. might work in other shells too
02:54:11 <merijn> donri: So to do that I use the shell script that was sent to the mailing list, which uses curl as hackage has no webinterface for uploading documentation
02:54:28 <donri> (perhaps in the future cabal upload will support things like docs?)
02:54:29 <merijn> But Hackage wants my password (obviously), so I need to pass that to curl
02:55:43 <merijn> donri: And no curl doesn't query for password
02:56:11 <donri> "If you just give the user name (without entering a  colon)  curl will prompt for a password."
02:56:29 <donri> that's for -u
03:02:08 <tdammers> merijn: if you paste into a prompt, it doesn't end up in the history
03:02:16 <tdammers> merijn: just don't paste into a command
03:02:44 <tdammers> merijn: at least that's how it works on every *nix terminal emulator and shell I've ever used
03:03:11 <tdammers> mysql -uroot -phunter2 # is not a good idea obviously
03:03:27 <tdammers> mysql -uroot -p # and then paste at the prompt, should be fine
03:03:58 <tdammers> s/mysql/curl/ or whatever
03:07:11 <donri> tdammers: problem is he wasn't having a prompt, he needed to pass it as an argument to curl
03:07:28 <donri> but -u without a colon should do it according to man page
03:21:36 <tdammers> yeah, I understand
03:23:17 <merijn> tdammers: There is no password prompt for curl
03:23:37 <merijn> I'll try again in a bit
03:26:37 <bernalex> https://www.haskell.org/haskellwiki/Haskell is the logo trademarked? does anyone know anyone that knows if the logo is trademarked?
03:28:52 <Fuuzetsu> bernalex: Public domain I think. http://www.haskell.org/haskellwiki/Haskell_logos
03:28:52 <merijn> bernalex: "is it trademarked" is a nonsensical question
03:29:12 <bernalex> merijn: "is it a trademark" then
03:29:20 <bernalex> Fuuzetsu: that's copyright not trademark law.
03:29:22 <merijn> bernalex: The answer is almost certainly *yes*
03:29:40 <merijn> bernalex: You have registered trademarks and unregistered trademarks
03:29:58 <Fuuzetsu> *shrug*
03:30:03 <merijn> bernalex: The only requirement for the latter is a clear and consistent use of the mark for your product
03:30:05 <Fuuzetsu> pretty sure you can use it for whatever it is you're doing
03:30:08 <Axman6> I'd disagree that it's a trademark. a trademark is a word or symbol (or ...) used in business to identify a company or product
03:30:30 <bernalex> merijn: depends on the jurisdiction. that sounds like some anglo-american thing.
03:30:34 <Axman6> well, broader than business
03:30:42 <merijn> bernalex: No, that's international law
03:31:24 * Axman6 is currently a patent examiner, but was also offered the job of a trademark examiner too
03:31:35 <Axman6> that said, they're not something I know a whole lot about
03:32:20 <merijn> The biggest problem with the haskell logo as trademark or not question is the lack of entity to make trademark claims
03:33:05 <merijn> It'd be a much stronger trademark than many others I've seen, if there was such a central entity (well, maybe the comittee qualifies?)
03:33:09 <Fuuzetsu> merijn: I'm sure we could get Simon's cat to show up in court
03:33:19 <bernalex> merijn: can't really imagine someone fighting us for using it as part of a logo we have. but maybe it's safest to not do it.
03:34:37 <tdammers> http://www.simonscat.com/
03:35:03 <Fuuzetsu> wrong simon and wrong cat!
03:43:01 <tdammers> I kwow
03:43:05 <tdammers> took me a while though
03:44:25 <killy9999> http://lpaste.net/98087
03:44:33 <killy9999> I get error when compiling this file
03:45:04 <killy9999> I don't know if this is caused by TH problems or singleton library problems
03:45:12 <killy9999> but the file loads without problems into GHCi
03:45:14 <namor> hi! is there a way to pass a VALUE (like, 3 or 7) to an instance declaration? I need something like this:
03:45:14 <namor> class (Int m, Serialize args, Serialize ret) => RPC m args ret where
03:45:14 <namor> (it's for an RPC system where m shall be the "magic" for the call, so that the receiver known which rpc he got)
03:45:16 <shiona> oh god, found a 10 credit (a bachelors is 180 and masters is 300 credits) course on haskell
03:45:52 <shiona> the lecturer thinks "if" is a function and couldn't remember you need let to assign a name
03:45:56 <shiona> in ghci
03:46:23 <namor> hmm, if kind of behaves like a function, doesn't it?
03:46:29 <namor> at least in a lazy language
03:46:56 <merijn> namor: You probably *can* do something like that, but it requires some more advanced haskell hackery
03:47:09 <merijn> namor: So whether that's worth it is up to you
03:47:09 <Philonous> namor, Actually, yes. With DataKinds and singletons.
03:47:29 <merijn> namor: You probably want to look into: GADTs, DataKinds and TypeFamilies
03:47:32 <Philonous> namor, It's not, strictly speaking, haskell, though
03:47:33 <Kaidelong> if is just weird and confusing syntax for pattern matching over a boolean
03:47:38 <namor> thanks, merijn and Philonous, i'll read about them
03:48:00 <merijn> namor: Useful references, the wikibook has a good GADTs chapter and the paper "Fun with Type Functions" is a good type families intro
03:48:25 <merijn> namor: DataKinds I don't know a good intro for, but if you understand Haskell's kinds it should be fairly trivial
03:48:57 <Philonous> I guess a book on programming with a dependently typed language would help
03:49:11 <namor> Philonous, i already read about those
03:49:42 <namor> but it just doesnt occur to me, what extension exactly allows mixing in values into types with classes
03:49:52 <namor> like its allowed in dependently typed languages anyways
03:49:56 <merijn> namor: Basically, do "Maybe :: * -> *", "Either :: * -> * -> *" and "Foo :: (* -> *) -> *" make sense to you?
03:50:23 <Philonous> namor, DataKinds is what lifts values into the type level (and types into the kind level)
03:51:10 <namor> merijn, just so much "Maybe is a type which takes a type and returns a type.." and so on
03:51:37 <merijn> namor: Right, so "Maybe" is a type and it has kind "* -> *" and * is the kind of fully applied types
03:52:34 <merijn> namor: DataKinds lets you lift values to types, so the *type* "Just Int" has the *kind* "Maybe *" (i.e. you lifted Just from the value to type level and Maybe from the type to kind level)
03:53:08 <merijn> namor: DataKinds also introduces the Nat kind which lets you use type level numbers. However, converting from values to types requires you use something like the singletons library
03:53:18 <merijn> Since haskell isn't dependently typed and can't normally do that
03:53:39 <mello_> anyone here with Snap knowledge?
03:53:54 <namor> merijn, okay, that actually made a lot of sense to me. :-)
03:54:25 <namor> thanks again merijn and Philonous, i know what to read now to carry on and got an idea.
03:54:30 <merijn> namor: If that made a lot of sense, the GADTs and TypeFamilies intros should be easy to follow and help you use things more concretely
04:00:06 <mello_> I'm trying to define the simplest compiled splice following a tutorial. However nothing happens which of course means I'm doing something wrong: https://gist.github.com/anonymous/b3325642b062c8bd9343
04:00:24 <mello_> Am I adding the configuration in a wrong way?
04:17:43 * hackagebot hserv 0.1.0.1 - Simple http server in haskell, similar to as provided by `python -m SimpleHTTPServer`.  http://hackage.haskell.org/package/hserv-0.1.0.1 (rejuvyesh)
04:22:01 <prophile> what are the conditions on f under which a (f b) (f c) is itself an arrow?
04:22:45 <prophile> the arrows package has CoState, State and Stream which correspond to f = (s ->), f = (s, ) and f = Stream respectively
04:22:53 <prophile> and it's trivially true for Identity
04:32:44 <randomclown> @pl \x -> return 1
04:32:44 <lambdabot> const (return 1)
04:33:02 <mello_> does anyone have some good resources for interpreted splices? I don't seem to find any
04:34:29 <ChongLi> why does Haskell use :: for hastype and : for cons?
04:34:42 <ChongLi> I read this somewhere and I've forgotten
04:35:11 <merijn> ChongLi: Because people figured you'd use cons more than type annotation and thus did the reverse of what ML did
04:35:24 <merijn> ML using :: for cons and : for type
04:35:40 <ChongLi> merijn: yeah, but I think that turns out not to be true
04:35:42 <hpc> i like :: for type annotations better, even though i use it more
04:35:47 <hpc> it's bigger and more visible
04:35:52 <merijn> hpc: True
04:36:03 <ChongLi> what I like about : for type annotations is that it aligns with =
04:36:24 <merijn> ChongLi: Well, that's what Lennart said in his history of haskell talk
04:36:28 <klrr> hpc: i agree
04:37:09 <ChongLi> merijn: where might I find this talk?
04:37:25 <ChongLi> the results from Google are not all that promising
04:37:27 <merijn> ChongLi: I don't think it was recorded
04:37:36 <ChongLi> a shame
04:38:09 <merijn> ChongLi: He gave a keynote at IFL last year about that
04:52:55 <Athas> http://lpaste.net/98110 <- Surely this Monad must already exist with a common name?
04:52:59 <Athas> It seems like a useful thing.
04:53:11 <Athas> Sort of a stream reader.
04:53:42 <merijn> Athas: Looks like you're reinventing pipes/conduits :)
04:53:59 <merijn> Athas: oh, actually
04:54:05 <Athas> merijn: yes, indeed, but I'd rather not pull in that entire library.
04:54:07 <merijn> Athas: That looks kinda similar to the Supply monad
04:54:19 <Philonous> Athas, A mealy automaton?
04:54:23 <merijn> Athas: http://hackage.haskell.org/package/transformers-supply
04:54:27 <bennofs> Athas: pipes is pretty small: http://hackage.haskell.org/package/pipes
04:54:31 <Athas> merijn: thank you!  That does look familiar.
04:54:45 <Athas> bennofs: it is conceptually big.
04:55:05 <Athas> I'm trying to keep this codebase as simple as possible.
04:55:52 <merijn> Athas: That or the Supply applicative in the same package, it depends what you want :p
05:10:39 <allsystemsarego> Hi all, does anyone know the meaning of the :+ operator in Haskell?
05:11:41 <frxx> it's a complex number constructor
05:11:44 <benj_> @hoogle :+
05:11:45 <lambdabot> Data.Complex (:+) :: a -> a -> Complex a
05:11:51 <allsystemsarego> thanks
05:11:57 <frxx> > 1 :+ 2
05:11:58 <lambdabot>  1 :+ 2
05:13:06 <fikusz> anyone here tried setting up flycheck-haskell (emacs) with cabal-dev?
05:13:32 <allsystemsarego> ok, so why does :t (:+) not work in GHCi?
05:13:46 <allsystemsarego> wait
05:14:06 <allsystemsarego> nvm
05:14:16 <allsystemsarego> I take back the question
05:15:18 <merijn> > (1 :+ 2) + (4 :+ 5)
05:15:19 <lambdabot>  5.0 :+ 7.0
05:18:28 <isomorphic> Should the linked Functor instance work?  I'm trying to add an extra variable to the wrapper type, but can't quite figure out why it breaks.
05:18:30 <isomorphic> http://lpaste.net/5095115738989985792
05:18:35 <isomorphic> Any thoughts?
05:20:07 <merijn> isomorphic: Your datatype says that both arguments have the same type
05:20:21 <merijn> isomorphic: In your fmap implementation you apply 'f' to the first, but not the second
05:20:40 <merijn> isomorphic: So now both arguments can have different types, which your datatype does not allow
05:20:41 <isomorphic> Ah! :)
05:20:45 <isomorphic> Thanks!
05:29:56 <osa1> how can I use Debug.Trace.trace while using arrow do notation?
05:31:45 <Drezil> is there a cabal-package for a simple wiki written in haskell? searching for "wiki" and "haskell" just yields install-tutorials for haskell itself -.-
05:32:24 <isomorphic> Drezil:  gitit?
05:32:46 <Drezil> ah! thanks. that looks good
05:34:58 <ocharles> osa1: arr traceShow, for example
05:36:36 <osa1> ocharles: I'm don't understand arrows very well -- arr (traceString str) fails with "... was found where an arrow command was expected"
05:36:55 <benj_> Drezil, fwiw, gitit was the first search result for 'wiki' on hackage.haskell.org
05:38:14 <Drezil> benj_: ye .. i was googling -.- next time i look on hackage directly ..
05:38:35 <Drezil> because google also yields github/sf and other providers ..
05:40:23 <ownclo> Good day, gentlemen! I have to deal with FFI calls from the ST monad. Will 'unsafeIOToST mallocForeignPtr' let the finalizer screw up?
05:40:26 <ocharles> osa1: arr traceString -< str
05:43:45 <randomclown> how do you break from a loop using continutations
05:43:47 <benj_> Drezil, I have hackage as a custom search engine in Chrome :)
05:44:19 <Drezil> hmm .. how do i do that? :p
05:44:23 <benj_> I had to configure that myself, though. There is an opensearch XML link in the page source, but Chrome seems to ignore that
05:44:24 <Philonous> randomclown, callCC $ \break -> loop ,,, break
05:44:52 <tdammers> duckduckgo ftw
05:44:58 <tdammers> !hayoo, !hoogle...
05:45:13 <benj_> Drezil, right-click in omni-box, "Edit Search Engines...", then scroll right to the bottom. The URL format is http://hackage.haskell.org/packages/search?terms=%s
05:45:30 <Drezil> thanks!
05:45:38 <benj_> you're welcome!
05:46:57 <Philonous> randomclown, Where the (loop ... break) part is supposed to mean that you run your loop and invoke break (or however you named the function) to return to the point where you called callCC
05:48:44 <benj_> Drezil, in case you weren't aware, the 'keyword' is what you enter in the omni-bar, then hit tab, to activate that search engine
05:49:21 <randomclown> Philonous: I'm so lost right now
05:51:45 <isomorphic> So, I take it from the ghc extension InstanceSigs that it's not normal to have type signatures within instances… ?
05:52:01 <randomclown> isomorphic: now it is
05:52:13 <isomorphic> 7.8.1?
05:52:14 <Philonous> randomclown, Do you know how ContT works?
05:53:08 <randomclown> Philonous: Sort of
05:53:32 <randomclown> isomorphic: works in 7.6.1
05:53:36 <randomclown> isomorphic: works in 7.6.3*
05:58:22 <isomorphic> Ok.  I'm writing a Functor instance - given that the type variable (say 'a') doesn't occur in the instance head (ie: it's instance Functor (W) where … ) - should I really be adding constraints?
05:59:05 <isomorphic> eg: " instance (Eq a) => Functor W where" looks wrong since the 'a' doesn't occur on the RHS of the =>
05:59:27 <isomorphic> I figure I must be asking the wrong question
06:00:40 <xnyhps> You can't do that with instances. A Functor can't restrict the type it may contain.
06:02:50 <Philonous> randomclown, ContT gives the left hand side of (>>=) access to the right hand side. Often called "the rest of the computation". So you can invoke it however you like. (You "return" from a procedure by calling the "rest of the computation").
06:03:04 <isomorphic> xnyhps  that too broad?  Why not "instance (Num a, Ord a) => Num (W a) where"
06:03:58 <xnyhps> That's a different situation. Num takes a type of kind *. Functor a type of kind * -> *.
06:04:14 <Philonous> randomclown, As an example, the simple computation that returns the value 7 would be (\c -> c 7) (Ignoring the newtype)
06:06:45 <Philonous> randomclown, With this, you can invoke the rest of the computation even in a deeply nested expression.
06:07:14 <Philonous> randomclown, The only problem is, that (c 7) will actually return once it's done.
06:08:21 <randomclown> I get that part, how does callCC work
06:09:09 <Philonous> randomclown, To avoid that, callCC gives you a function that captures the rest of the computation, throws it away and calls the rest of the computation that callCC captured
06:09:29 <isomorphic> xnyhps:  that's unfortunate.  Would that stop me from having an fmap implementation that requires a constraint like Ord or Eq?
06:09:58 <merijn> isomorphic: Yes
06:10:06 <xnyhps> Yes. You can't define an fmap with extra constraints on a or b.
06:11:47 <randomclown> Philonous: so the "break" is actually the rest of the computation
06:11:59 <isomorphic> Ouch.  Is there a workaround, or is it for a good reason?
06:12:13 <Philonous> randomclown, From callCC's point of view, yes
06:12:49 <Philonous> randomclown, It throws away the current continuation and replaces it with the one that callCC saw
06:12:52 <randomclown> So callCC lets me capture the context whenever it's called
06:13:01 * hackagebot haskell-awk 1.0 - Transform text from the command-line using Haskell expressions.  http://hackage.haskell.org/package/haskell-awk-1.0 (MarioPastorelli)
06:13:08 <randomclown> How is this not the biggest space/memory leak in the whole world?
06:13:18 <Philonous> randomclown, shift let's you do that, callCC also ensures that the function it gives you doesn't return
06:14:54 <Philonous> randomclown, In haskell, callCC is just an ordinary function.
06:15:24 <ocharles> Does anyone know why hsc2hs translates #{type Uint32} Int32?
06:15:37 <ocharles> Why not Word32 or (perhaps better) CUInt?
06:16:43 <isomorphic> ocharles:  bounded type?
06:17:24 <Philonous> randomclown, In Haskell all continuations are delimited. So you can't actually grab the rest of the whole program, only the rest of your ContT computation. And if you peel away the newtype it will just shuffle around functions.
06:18:01 * hackagebot midisurface 0.1.0.0 - A control midi surface  http://hackage.haskell.org/package/midisurface-0.1.0.0 (PaoloVeronelli)
06:18:28 <ocharles> isomorphic: hm?
06:18:37 <randomclown> The continutation will still have some space requirements though
06:18:56 <randomclown> I suppose GC is smart enough to clean that up
06:19:54 <xnyhps> isomorphic: Not without rewriting the definition of Functor. I remember a blog post about type classes (like Functor) with an associated type family which could express extra constraints - but I can't seem to find it.
06:20:53 <Philonous> randomclown, Yes, it really all boils down to mundane high-order functions.
06:20:55 <bennofs> @hoogle mono
06:20:55 <lambdabot> Test.QuickCheck.All mono :: Name -> ExpQ
06:20:55 <lambdabot> package mono-foldable
06:20:55 <lambdabot> package mono-traversable
06:21:17 <Philonous> randomclown, Btw. if all you want is an escape mechanism then MaybeT or EitherT are much better choices.
06:21:19 <bennofs> @hackage mono-traversable
06:21:20 <lambdabot> http://hackage.haskell.org/package/mono-traversable
06:22:38 <randomclown> Philonous: They aren't bundled with mtl though
06:22:57 <bennofs> MaybeT is in transformers, and therefore in mtl
06:23:01 <Philonous> randomclown, ErrorT does the trick
06:23:19 <randomclown> bennofs: how so?
06:23:37 <xnyhps> isomorphic: Ah, see https://stackoverflow.com/questions/12697348/is-there-a-library-that-uses-constraintkinds-to-generalize-all-the-base-type-cla and the linked blog posts.
06:23:38 <bennofs> @let import Control.Monad.Trans.MaybeT
06:23:38 <lambdabot>  .L.hs:53:1:
06:23:38 <lambdabot>      Failed to load interface for `Control.Monad.Trans.MaybeT'
06:23:38 <lambdabot>      Perhaps you meant
06:23:38 <lambdabot>        Control.Monad.Trans.Maybe (from transformers-0.3.0.0)
06:23:38 <lambdabot>        Control.Monad.Trans.Reader (from transformers-0.3.0.0)
06:23:40 <bennofs> @let import Control.Monad.Trans.Maybe
06:23:42 <lambdabot>  Defined.
06:23:55 <randomclown> that's transformers though, not mtl
06:24:02 <bennofs> randomclown: transformers is a dependency of mtl anyway
06:24:05 <Philonous> randomclown, mtl depends on transformers
06:24:18 <randomclown> Oh ok
06:24:45 <Philonous> randomclown, You'll stil have to mention it in the cabal file, but it won't need to install anything
06:25:04 <isomorphic> ocharles:   Sorry, I think I misread the question.
06:27:06 <randomclown> Philonous: I see I see
06:27:25 <isomorphic> xnyhps:   Thanks!   Oddly, I think I might be trying to do the same thing - I want to sanity check an fmap as it occurs
06:39:15 <hhhhhhhh> what is the function that takes an Either and lets you take the Right or a default value :D
06:39:32 <hhhhhhhh> i forgot the name and now i cant find it on hoogle
06:39:34 <randomclown> :t either
06:39:35 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
06:40:03 <hhhhhhhh> ......thanks
06:41:27 <hhhhhhhh> how do i stop try from complaining about type errors in its exception type
06:41:49 <hhhhhhhh> "No instance for (Exception e0) arising from a use of `try'" "The type variable `e0' is ambiguous"
06:42:36 <isomorphic> Thanks xnyhps - that gives me plenty to read :)
06:42:44 <Cale> hhhhhhhh: Match the result against  Left (SomeException e)
06:42:50 <xnyhps> You're welcome
06:43:14 <Cale> Or otherwise do anything to specify the type of exception you're trying to catch
06:45:10 <isomorphic> Is there a generic  preference toward returning Nothing / Either, throwing and Exception?   I've seen references to Exceptions being associated with IO
06:46:35 <Cale> isomorphic: You can only catch exceptions from IO
06:46:57 <bennofs> isomorphic: you should only use Exception's in IO (throwing exceptions from pure code is evil, because you cannot catch them in pure code, as Cale said)
06:47:05 <Cale> isomorphic: and catching the ones thrown by evaluation of expressions (rather than execution of IO actions) is rather tricky
06:47:08 <hhhhhhhh> Cale thanks
06:47:26 <defanor> http://learnyouahaskell.com/making-our-own-types-and-typeclasses -- why is it tofu x = Frank x and not tofu = Frank? and i also don't get that "if we replace Frank with j" thing
06:47:29 <isomorphic> Cale, bennofs : Thanks :)
06:48:13 <Cale> defanor: You certainly could write  tofu = Frank, and have it mean the same thing
06:48:51 <defanor> Cale: got it, thanks
06:49:33 <hhhhhhhh> Cale is there any way to make it catch all exceptions
06:49:56 <hhhhhhhh> or am i approaching this the wrong way? i want to do some IO but if it fails print the error, return some default and move on
06:50:56 <Cale> hhhhhhhh: Use the SomeException type.
06:51:32 <hhhhhhhh> Cale that works, cheers
06:52:24 <Cale> Yeah, that's probably okay. It would probably be better to be more precise about which failure conditions you consider acceptable in general, but if you catch SomeException, it'll work.
06:58:13 <hhhhhhhh> ok i've written 2 functions that catch exceptions and they both look kinda crappy. can it be done more neatly? http://lpaste.net/2575326780831301632
07:03:06 <Kaidelong> @ty bracket
07:03:07 <lambdabot> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
07:03:42 <merijn> hhhhhhhh: You can easily split the handler functions of into their own function definition rather than using a lambda
07:04:25 <Kaidelong> Control.Exception had a bunch of combinators
07:04:51 <Lethalman> Kaidelong, isn't bracket for resource cleanup rather than exception handling?
07:05:09 <merijn> Lethalman: It's resource cleanup in the presence of exception handling
07:05:13 <saml> yes
07:05:39 <hhhhhhhh> merijn: true
07:05:42 <merijn> If you don't intend to actually handle an exception (i.e. just let the IO action die) you'll still want to handle it in terms of cleaning up resources
07:06:08 <sw17ch> I'm having a hard time figuring out how to use the detailes-1.0 test interface with Cabal. Are there guidelines or an example project for this using HUnit or QuickCheck anywhere?
07:06:20 <Kaidelong> trying to see if one of them matches the example
07:06:20 <Kaidelong> Lethalman: yes
07:06:20 <Kaidelong> although the reason you need it is to prevent exceptions from preventing you from cleaning up
07:06:20 <Kaidelong> also a bunch of the stuff in the exception library are variations of bracket
07:06:39 <hhhhhhhh> but now another problem. what on earth do you call a function that does that
07:07:31 <Kaidelong> hhhhhhhh: I think your functions are pretty neat looking as they are
07:07:59 <merijn> hhhhhhhh: Yeah, the functions don't look that bad
07:08:03 <merijn> maybe infix catch will help
07:08:06 <Kaidelong> one thing, print instead of putStrLn . show
07:09:21 <merijn> hhhhhhhh: like this: http://lpaste.net/2575326780831301632
07:10:06 <hhhhhhhh> yea that looks better
07:10:08 <hhhhhhhh> thanks guys
07:10:28 <covi> Why is  "take 3 . sort" (or replace 3 with a constant) a linear time algorithm?
07:11:06 <covi>  let xs = [3, 1, y + 1, y + 2] where y = 2 * 4
07:11:09 <covi> followed by:
07:11:16 <covi> (take 1 . sort) xs
07:11:19 <Lethalman> covi, you take the min of the list, then the min of the remaining list, etc. 3 times
07:11:21 <covi> seems to evaluate y too
07:11:52 <hhhhhhhh> covi: it needs to evaluate y so it can compare 3 with them
07:12:04 <merijn> I don't think that's linear time, but I'm not sure
07:12:05 <covi> Lethalman: I am looking for a detailed explanation of how things are evaluated and in what order in this case.
07:12:14 <merijn> covi: Who claims it's linear time?
07:12:17 <covi> hhhhhhhh: but then I don't see how it can be linear time
07:12:32 <covi> merijn: saw it on quora, hold on
07:12:40 <merijn> covi: Well, whether it's linear time will certainly depend on the implementation of sort
07:12:43 <Lethalman> you aren't sorting all the list
07:12:56 <lieven_> covi: assume quicksort. it's going to do a first partition but then it needs only concern itself with the left part of the list
07:13:21 <merijn> lieven_: Except that that's not linear
07:13:35 <tdammers> no... more like O(lon n)
07:13:41 <tdammers> *log
07:13:49 <Lethalman> it's at least n
07:13:50 <merijn> lieven_: quicksort needs to view both parts of the list to determine what the left side is
07:13:55 <lieven_> tdammers: partition is already O(n)
07:14:01 <merijn> tdammers: Definitely not log n
07:14:24 <merijn> Without a specific implementation of sort it's hard to reason whether it can fuse to linear time instead of n*log n time
07:14:39 <covi> If we assume quicksort, O(n) seems to make sense. However in Data.List I think sort is implemented using a mergesort?
07:14:57 <Lethalman> let's say it's an insertion sort, that's clearly linear time as I said above, find the min etc.
07:15:01 <merijn> The default sort in haskell is mergesort
07:15:04 <mirpa> Does anybody know module to convert nested pairs with arbitrary depth to a list? eg. (a,(b,(c,d))) == [a,b,c,d] for compositions of functions like a -> (a, a) using (>>> second)
07:15:09 <Lethalman> no wait
07:15:12 <Lethalman> selection sort
07:15:13 <merijn> Well, optimised merge sort, since it skips already sorted sequences
07:15:16 <covi> ok here: http://www.quora.com/Programming-Languages/When-did-you-realize-the-power-of-lazy-evaluation-in-terms-of-performance
07:16:00 <merijn> covi: Which answer?
07:16:07 <covi> "...The real nail in the coffin for me was realizing that things like take 10 . sort get better asymptotics than its constituent parts due to laziness..."
07:16:13 <covi> Edward's
07:16:23 <merijn> covi: Better asymptotics, yes
07:16:26 <jonasw> But you're saying it's worse
07:16:29 <Earnestly> Another "You can't view anything until you login" website.  expertexchange clone?
07:16:32 <merijn> covi: He doesn't claim it's linear anywhere there
07:16:40 <merijn> Earnestly: You can click outside that window to see things
07:16:55 <hhhhhhhh> covi: i think he means the constant overhead will be lower than if it were strict because it can skip SOME of the sorting
07:17:02 <covi> merijn: what's the better asymptotic complexity here?
07:17:03 <Earnestly> merijn: Only the first answer though
07:17:05 <hhhhhhhh> but in general the complexity will be unchanged
07:17:14 <covi> oh
07:17:22 <merijn> covi: asymptotically better == same complexity order, but smaller constant
07:17:30 <covi> what
07:17:39 <covi> that blows my mind
07:17:56 <merijn> covi: If I have to do 3n operations for implementation A, that's complexity O(n)
07:17:57 <hhhhhhhh> if you think about for `take 1` and mergesort, it's going to have to merge all the way back up the tree because the smallest element can lie in any of the sublists
07:18:05 <covi> in algo class, i learned that asymptotically better == better order, so O(2.5 n) is not better than O(3n)
07:18:11 <merijn> covi: If implementation B does 2n operations it's O(n) too
07:18:24 <Lethalman> mirpa, absolutely not sure, because I never used TH, but maybe something like uniplate
07:18:43 <merijn> covi: But B is clearly better than A
07:19:06 <Lethalman> the point is that is not O(nlogn) anymore, it's something different
07:19:52 <covi> merijn: but you can't claim it's *asymptotically* better, it's just better in practice
07:19:53 <Lethalman> e.g. for selection sort it's O(3n)
07:20:05 <covi> Lethalman: yeah, in that case, I'd like to know that's the better asymptotic order
07:20:10 <mirpa> Lethalman: thanks, I'll have a look
07:20:36 <Kaidelong> covi: you hopefully also learned that in specific cases algorithms with worse order can still be better
07:20:41 <merijn> covi: "The asymptotic behavior of a function f(n) (such as f(n)=c*n or f(n)=c*n2, etc.) refers to the growth of f(n) as n gets large."
07:21:01 <merijn> covi: asymptotically better == "as N gets large, this always performs better"
07:21:25 <merijn> covi: Clearly O(n) is asymptotically better than O(n^2)
07:21:33 <covi> merijn: well, ok, that makes sense then. my understanding of asymptotically better was flawed then ;)
07:21:38 <covi> Kaidelong: yeah, such as simplex ;)
07:21:43 <Kaidelong> merijn: and an algorithm which performs better may have other tradeoffs like needing more memory
07:22:00 <merijn> covi: My earlier example where both A and B are O(n) but B has a better constant, then B is asymptotically better than A too
07:22:25 <merijn> covi: Because as n becomes larger B will always outperform A
07:22:44 <ReinH> Lethalman: O(3n) is just O(n)
07:22:58 <Lethalman> ReinH, just to point it out more clearly
07:22:59 <merijn> covi: (By constant factor I mean 2n vs 3n, not an actual "n + c", because for small c that might be worthless)
07:23:09 * hackagebot hserv 0.1.0.2 - Simple http server in haskell.  http://hackage.haskell.org/package/hserv-0.1.0.2 (rejuvyesh)
07:23:14 <covi> merijn: of course, thanks
07:23:33 <Lethalman> ReinH, since I could not say it's exactly 3n :) it would be n+(n-1)+(n-2)
07:23:46 <merijn> covi: Anyway, to get back to edward's point, it's certainly easy to see that not having to sort the entire list (due to laziness) is asymptotically better than having to sort the entire thing due to being strict
07:24:02 <hhhhhhhh> ok i have another function which i think could be made neater but i don't see it: http://lpaste.net/9176443557731368960
07:24:06 <merijn> covi: However, that doesn't mean it results in linear time (obviously it can't)
07:24:16 <Lethalman> covi, but... maybe you are missing the point of laziness here? no right?
07:25:00 <merijn> covi: Since even if I do more than O(n) operations with mergesort, as soon as I can skip even one merge due to laziness, I win in performance
07:25:22 <merijn> And most likely you can skip much more than one merge when doing "take 3 . sort"
07:25:40 <hhhhhhhh> i guess in english that function is doing: if we can find an "rss" child element then we call `parseRSS url <that element>`, otherwise we look for a "feed" element and call `parseAtom url <that element>`, otherwise we do nothing
07:26:16 <merijn> hhhhhhhh: I'd separate the nested case, it's rather ugly
07:26:45 <hhhhhhhh> merijn: it is but i dont know how to do it any better :p
07:27:26 <merijn> hhhhhhhh: btw, the let on line 7 is redundant
07:27:50 <merijn> you can have multiple definitions in one let (just make sure rssParsed starts on the same column as rss in the line above)
07:28:01 <Lethalman> mirpa, also let me know :-)
07:28:02 <mr-> and 4 and 6
07:28:10 * hackagebot haskell-awk 1.0.1 - Transform text from the command-line using Haskell expressions.  http://hackage.haskell.org/package/haskell-awk-1.0.1 (MarioPastorelli)
07:28:40 <Lethalman> eek what's this haskell-awk :P
07:28:56 <hhhhhhhh> merijn: having the lets means i can pretend i am still using an imperative language
07:29:13 <Rembane> Haskell-eek 1.1.1 - Like haskell-awk but better.
07:29:33 <Lethalman> cool
07:29:43 * Lethalman installs hawk
07:29:58 <merijn> hhhhhhhh: Sure, but you can do them in a single let
07:30:23 <merijn> hhhhhhhh: Something like: http://lpaste.net/9176443557731368960
07:31:04 <ReinH> hhhhhhhh: also the sooner you drop that notion, the better ;)
07:31:36 <hhhhhhhh> merijn i am still wearing my haskell floaties
07:32:10 <hhhhhhhh> merijn oh yeah laziness. thanks
07:32:38 <merijn> hhhhhhhh: Actually, might even be better using where
07:33:40 <merijn> hhhhhhhh: Like so: http://lpaste.net/9176443557731368960
07:34:23 <hhhhhhhh> yeah that is nicer
07:34:26 <merijn> hhhhhhhh: Actually, what's the type of parseAtom/parseFeed?
07:34:49 <hhhhhhhh> parseAtom :: String -> Element -> Maybe Feed, parseFeed :: Connection -> ( String, String ) -> IO ()
07:35:41 <mr-> it's a bit weird that parseFeed is IO ()
07:36:00 <merijn> hhhhhhhh: You only really need let if you want to use values bound using monadic actions, e.g. "do { x <- foo; let bar = x; xyzzy bar }"
07:36:07 <hhhhhhhh> yeah i don't actually know what i am doing
07:36:35 <merijn> hhhhhhhh: Because 'where' can't refer to the 'x' that's bound monadically, where should be preferred in almost all other scenarios
07:37:58 <hhhhhhhh> alright
07:40:49 <mr-> Wouldn't something like that work too, http://lpaste.net/98130 , and do the IO stuff later?
07:40:52 <quchen> merijn: Why is 'where' different from 'let..in' anyway? So it can span multiple guards etc?
07:41:39 <hhhhhhhh> :t <|>
07:41:40 <lambdabot> parse error on input `<|>'
07:41:43 <hhhhhhhh> :t (<|>)
07:41:44 <lambdabot> Alternative f => f a -> f a -> f a
07:41:59 <hhhhhhhh> what do i import for this :D
07:42:00 <mr-> > (Just "left") <|> (Just "right")
07:42:01 <lambdabot>  Just "left"
07:42:08 <mr-> Control.Applicative, I think
07:42:12 <mr-> err
07:42:17 <saml> @hoogle <|>
07:42:18 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
07:42:18 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
07:42:18 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
07:42:46 <hhhhhhhh> neat
07:42:50 <saml> import Control.Applicative (<|>)  as or
07:43:37 <mr-> will that clash with prelude or something?
07:43:53 <quchen> You can't import a function under another name.
07:44:03 <mr-> bummer ;-)
07:45:31 <bennofs> WOw, haddock is taking 1G memory ...
07:45:47 <saml> mongodb is taking 1TB memory
07:46:01 <quchen> I doubt that.
07:46:09 <bennofs> haha. But I don't run mongodb on my personal computer
07:48:05 <bennofs> I don't get why haddock needs so much memory. Does it load all the modules (GHCi-like) when generating documentation?
07:49:34 <geekosaur> yes. specifically it needs to run the whole thing through at least the typechecker
07:49:53 <geekosaur> so that it can get types whether an explicit type signature exists or not
07:50:15 <bennofs> Well, it might not be such a good idea to load all 276 modules of yi at once ...
07:50:46 <bennofs> I think TH is really complicating all those utils. You need to execute code, even if you only want to typecheck modules :/
07:52:46 <mgsloan> As much as I like TH, it does cause lots of problems for tools
07:53:30 <mgsloan> Since it causes renaming to be mixed up with typechecking, you can't easily use GHC for scope info in the presence of type errors
07:53:55 <bennofs> Maybe we could somehow "tag" modules that are allowed to define functions usable in TH? So we could at least skip generating code for the other modules
07:54:48 <hhhhhhhh> is there a way to make ghci not show every loaded module on the prompt
07:54:52 <bennofs> The much bigger issue is that I need to load all dependencies and packages in the presence of TH (because splices could use just any function from the imported packages), which makes memory usage of tools blow up
07:55:03 <bennofs> hhhhhhhh: you can use :set prompt "your fancy prompt "
07:55:08 <klrr> i got some problems with attoparsec, i dont get the wanted behaviour with a Parser, https://gist.github.com/klrr/8301310 anyone know what is wrong?
07:55:20 <hhhhhhhh> bennofs thanks
07:55:58 <bennofs> Using pipes, is there a way to feed a producer producing "Either a b" into a different consumer for each side of the Either?
07:59:57 <tomejaguar> Off Topic: Are there "standard" hosts for mailing lists for open source projects, especially Haskell ones.  Sourceforge used to be one such standard, but it seems they're dying out.  Github *would* be the standard if they supported mailing lists, but they don't.  Any other ideas?
08:00:15 <bennofs> Google Groups?
08:00:23 <tomejaguar> I was worried that would be the answer :)
08:00:31 <klrr> tomejaguar: haskell.org offer free mailing list hosting for haskell projects
08:00:33 <klrr> iirc
08:00:34 <scriptor> I think zed shaw set up a mailing list thing once
08:00:36 * Kinnison runs his own hosting ISP for this very reason :-)
08:00:40 <scriptor> http://librelist.com/
08:01:22 <donri> bennofs: i imagine you can do it with await, either and yield, but i guess you're looking for an idiomatic combinator or something?
08:02:54 <donri> await >>= either (\a -> yield a >-> c1) (\b -> yield b >-> c2)
08:03:17 <klrr> i got some problems with attoparsec, i dont get the wanted behaviour with a Parser, https://gist.github.com/klrr/8301310 anyone know what is wrong?
08:06:04 <danharaj> edwardk: What do you think of mtl modules not reexporting Control.Monad.
08:06:21 <danharaj> Because I hate having to hide mapM because it is subsumed by a more general version elsewhere.
08:06:28 <edwardk> i'd favor it, but the pain of changing would be very high
08:06:44 <danharaj> would it? It seems almost a mechanical source change for most people.
08:06:45 <edwardk> perhaps as part of the big changeover in 7.10?
08:07:21 <edwardk> when the better mapM, etc. move into the prelude it becomes a much easier sell
08:07:21 <danharaj> that would be a nice improvement. where can I submit this proposal?
08:07:29 <danharaj> oh, those are moving in?
08:07:34 <danharaj> I think that removes most of the pain.
08:07:38 <edwardk> put it on mtl with a suggestion to wait until 7.10
08:07:47 <edwardk> github.com/ekmett/mtl
08:08:13 <bennofs> edwardk: What is currently blocking lens 4.0 release?
08:08:40 <scshunt> edwardk: what's happening in 7.10?
08:08:49 <danharaj> The cold snap that is ravaging North America.
08:08:58 <edwardk> bennofs: good question. we need to get zippers packaged up properly for hackage, need to nsur the thing builds correctly against GHC HEAD with all the template haskell working.
08:09:03 <edwardk> insure
08:09:20 <edwardk> er ensure those were both e's
08:09:34 <edwardk> otherwise? hrmm. not much
08:09:56 <edwardk> i was originally planning on shipping 4.0 basically a day or two after 7.8 came out
08:10:06 <edwardk> the delay has been a bit longer than expected ;)
08:10:23 <Clint> i hear that 7.8 is coming out in december
08:10:59 <edwardk> Clint: at this rate it might ;)
08:11:13 <bennofs> edwardk: ok, thanks. I really want the new Getter type along with it's Applicative instance! :)
08:11:54 <donri> i hear 7.8 will include a preview of pattern synonyms because it was delayed :P
08:12:13 <donri> which would be fun to play with, so yay!
08:12:18 <edwardk> donri: that is possible, yes
08:12:19 <hhhhhhhh> i'm writing a server which needs to let people requeset authentication tokens and i would like valid tokens to be stored in memory. how would i go about this in haskell?
08:12:27 <hhhhhhhh> i am using scotty for the server if that helps
08:13:13 <donri> well there's a thread about it on the ghc-devs list
08:13:39 <donri> hhhhhhhh: do you need the tokens to be persistent?
08:13:44 <donri> if not, stm, if yes, acid-state
08:14:17 <tomejaguar> klrr: Thanks, librelist looks nice
08:14:18 <donri> meh persistent is such an overloaded term here
08:14:21 <donri> "durable"?
08:15:00 <hhhhhhhh> i don't care about losing it between restarts
08:15:03 <hhhhhhhh> if that's what you mean
08:15:09 <donri> then i'd go with stm
08:15:12 <ReinH> so the opposite of durable
08:15:12 <hhhhhhhh> like in an imperative language i would just keep a global array
08:15:45 <donri> assuming your request handlers are threaded and you want to share mutable state
08:16:30 <hhhhhhhh> ok cool. thanks
08:16:53 <donri> @where stm
08:16:53 <lambdabot> http://haskell.org/haskellwiki/Software_transactional_memory
08:17:50 <donri> @where+ stm http://haskell.org/haskellwiki/Software_transactional_memory | http://book.realworldhaskell.org/read/software-transactional-memory.html | http://chimera.labs.oreilly.com/books/1230000000929/ch10.html
08:17:50 <lambdabot> It is stored.
08:18:27 <hhhhhhhh> that page implies it's built in but i'm guessing i need to cabal install stm?
08:19:12 <donri> hhhhhhhh: stm comes with platform, probably even with ghc, but yes it's a library (supported by the rts)
08:19:57 <donri> i'd highly recommend using cabal to build your package, and then you need to list stm in build-depends even if it's already installed
08:21:17 <hhhhhhhh> donri wait what am i doing wrong
08:21:22 <hhhhhhhh> Could not find module `Control.Concurrent.STM'
08:21:28 <hhhhhhhh> even after cabal install stm
08:21:28 <donri> btw stm is transactional and transactions need to be pure, but i'm assuming you want to generate random tokens. you can do this elegantly and correctly by storing a random generator or seed in a tvar and update that as you generate new tokens
08:22:09 <donri> hhhhhhhh: how are you compiling the code that returns that error?
08:22:18 <hhhhhhhh> runghc
08:22:48 <ReinH> hhhhhhhh: what is the full error?
08:23:16 <donri> (oh look stm isn't actually a ghc core lib)
08:23:29 <donri> i guess only libs ghc itself uses are
08:23:46 <hhhhhhhh> ReinH: "Could not find module `Control.Concurrent.STM'" followed by ghc suggesting things which are obviously not it
08:24:07 <donri> hhhhhhhh: ghc-pkg list stm says what?
08:24:23 <hhhhhhhh> /usr/lib/ghc-7.6.3/package.conf.d
08:24:27 <hhhhhhhh> /home/mike/.ghc/x86_64-linux-7.6.3/package.conf.d
08:24:45 <hhhhhhhh> i got rid of the cabal stm package
08:24:50 <donri> (:
08:25:11 <hhhhhhhh> but it didn't provide conto GOD YES IT DID
08:25:27 <donri> wha?
08:25:36 <hhhhhhhh> cabal install stm fixed it.
08:25:53 <hhhhhhhh> i was trying it from a ghci without restarting it
08:26:07 <hhhhhhhh> sry :p
08:26:12 <donri> yes i was going to suggest that if you answered ghci, but you answered runghc ;)
08:32:27 <hhhhhhhh> donri: can i use getStdRandom or is it not threadsafe
08:35:23 <klrr> i got some problems with attoparsec, i dont get the wanted behaviour with a Parser, https://gist.github.com/klrr/8301310 anyone know what is wrong?
08:35:48 <snizzo> does anybody has a working C implementation built with alex/happy?
08:36:08 <snizzo> I just need the parser lexer :)
08:38:19 * hackagebot bitcoin-rpc 0.5.0.1 - Library to communicate with the Satoshi Bitcoin daemon  http://hackage.haskell.org/package/bitcoin-rpc-0.5.0.1 (JanVornberger)
08:51:12 <hhhhhhhh> ok i am having trouble putting rng state in stm and using it in a scotty handler. the only thing i can think of is unsafePerformIO but that is heresy so can someone take a look: http://lpaste.net/3152250367400476672
08:53:15 <fryguybob> hhhhhhhh: You can put more of that into a single transaction.
08:53:16 <c_wraith> hhhhhhhh: does newTVarIO solve your problem?
08:53:46 <c_wraith> and also, yes.  there's no point in using STM like that.
08:54:01 <c_wraith> if you don't have reads and writes in the same transaction, you might as well be using an IORef
08:54:33 <bennofs> hhhhhhhh: What's your problem?
08:54:42 <c_wraith> hhhhhhhh: But I think the real issue is that there's no Random instance for String
08:54:43 <fryguybob> hhhhhhhh: I annotated your paste: http://lpaste.net/3152250367400476672
08:55:02 <fryguybob> hhhhhhhh: And what c_wraith said.
08:55:04 <c_wraith> hhhhhhhh: You're going to have to actually write how to generate a string randomly
08:56:50 <hhhhhhhh> :DD i mean Int not String
08:57:28 <c_wraith> hhhhhhhh: there's nothing there that even comes close to suggesting that you need unsafePerformIO
08:58:33 <c_wraith> hhhhhhhh: oh, I see.  You don't know about liftIO
08:58:50 <hhhhhhhh> fryguybob: i think it's unhappy about using IO() when it wants one of scotty's types
08:58:55 <c_wraith> hhhhhhhh: ActionM is an isntance of MonadIO
08:59:03 <c_wraith> :t liftIO
08:59:04 <lambdabot> MonadIO m => IO a -> m a
08:59:34 <c_wraith> *instance.  I always typo it that way...
09:00:19 <hhhhhhhh> c_wraith got it, thanks
09:01:30 <c_wraith> hhhhhhhh: always be sure to check the instance list for a type, when you're trying to figure out how to do something with it. Lots of important stuff is hidden in there
09:02:54 <hhhhhhhh> c_wraith: by instance list do you mean open the code and ctrl+f for instance
09:03:29 <c_wraith> hhhhhhhh: I actually mean in the haddock docs
09:04:23 <c_wraith> hhhhhhhh: I went to http://hackage.haskell.org/package/scotty-0.6.2/docs/Web-Scotty.html found get, clicked on ActionM, then clicked on ActionT, since ActionM is just a type alias.
09:05:28 <c_wraith> hhhhhhhh: and under the haddock intry for ActionT, it lists 5 instances. there's the FAM stuff, and the two instances related to transformers.
09:05:37 <c_wraith> *entry.  It's clearly too early for me to spell
09:05:56 <hhhhhhhh> oh and that's where you get MonadIO from
09:07:37 <hhhhhhhh> so then somewhere in the scotty codebase they defined liftIO for ActionM?
09:07:44 <c_wraith> hhhhhhhh: correct
09:08:47 <hhhhhhhh> c_wraith ok. thanks
09:18:23 * hackagebot creatur 4.1.6 - Framework for artificial life experiments.  http://hackage.haskell.org/package/creatur-4.1.6 (AmyDeBuitleir)
09:19:56 <donri> hhhhhhhh: i was away, did you figure it out?
09:20:14 <hhhhhhhh> donri: first google result :p
09:21:01 <donri> hhhhhhhh: i don't know if getStdGen is thread-safe but the idea is to call it once before all the threads and then put it in a tvar which will be thread-safe
09:21:35 <hhhhhhhh> donri: i did that with newStdGen and it is working nicely
09:22:30 <donri> \o/
09:39:18 <binroot> @pl (\p -> domain p == val)
09:39:18 <lambdabot> (val ==) . domain
09:48:26 * hackagebot simple-index 0.1.0.1 - Allows simple indexation on any data type  http://hackage.haskell.org/package/simple-index-0.1.0.1 (HugoGomes)
09:50:58 <ocharles> Writing some FFI bindings and I need to turn (Word8, Word8, Word8, Word8) into an int (32). I'm half tempted to just alloca and poke the pointer 4 times
09:51:08 <ocharles> Have I lost my mind, or does that sound sensible?
09:57:13 <tomejaguar> ocharles: I can't think of anything obviously wrong with it.
09:58:28 * hackagebot typescript-docs 0.0.3 - A documentation generator for TypeScript Definition files  http://hackage.haskell.org/package/typescript-docs-0.0.3 (PhilFreeman)
09:58:30 * hackagebot git-annex 5.20140107 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-5.20140107 (JoeyHess)
09:58:32 * hackagebot language-typescript 0.0.3 - A library for working with TypeScript Definition files  http://hackage.haskell.org/package/language-typescript-0.0.3 (PhilFreeman)
09:58:43 <ocharles> tomejaguar: it just feels a bit weird to do "poke colorPtr color >> peek colorPtr >>= ..."
10:02:02 <klrr> https://gist.github.com/klrr/8301310
10:07:53 <c_wraith> klrr: well, I can tell you that the 4th one doesn't fails because there's an extra \r that the parser doesn't consume
10:08:45 <c_wraith> klrr: err.  with no separator before it.
10:09:44 <klrr> c_wraith: how you mean? i thought notInClass meant roughy "not any of these chars"
10:10:17 <c_wraith> klrr: does space match \r ?
10:11:29 <klrr> im not really sure what you mean
10:13:09 <c_wraith> well, it's looking for things that aren't : or \r, followed by either what space matches, or end of input
10:13:21 <klrr> the equaliant in parsec look like this "many1 (noneOf ":\r") `sepBy` space" and work exactly as i want, im not really sure why this attoparsec one dont
10:13:58 <c_wraith> if space doesn't match \r, then the 4th one clearly cannot match
10:14:22 <klrr> i dont get it, if space doesnt match then the parser is done right?
10:14:49 <c_wraith> it has leftover input, which is an error
10:15:56 <tippenein> I have src/Main.hs and src/Data/Config.hs, why would it complain about "import Data.Config" in src/Main?
10:16:46 <tippenein> could not find module Data.Config
10:16:50 <c_wraith> klrr: oh.  clearly space *does* match \r, because that's the only difference between the two succeeding cases and the two failing cases
10:17:03 <merijn> tippenein: How are you compiling it? What's the exact error message, etc.
10:17:19 <klrr> c_wraith: wait i think i get it, i need to add something more to the right side of the sepBy so it doesnt crash if it hits something else than space?
10:17:48 <klrr> i thought sepBy automatically stopped and considered itself done after it start hitting non-spaces
10:18:02 <c_wraith> klrr: I'd certainly throw in a dummy that matches "everything else until end of input" after the sepBy, and see what that changes
10:18:47 <tippenein> merijn: hlint is giving me the error, but upon trying 'ghc Main.hs' it complains about some errors in Data.Config .. So, maybe it can't import it because it has errors
10:19:12 <tippenein> hlint gives "Could not find module `Data.Config' Perhaps you meant Data.Conduit"
10:20:06 <klrr> in attoparsec how do i check explicitly if a parser fail? is it possible to catch in a case expression?
10:20:19 <klrr> im not really sure what type to pattern match though
10:21:46 <merijn> tippenein: That could very well be it
10:21:58 <merijn> tippenein: Might wanna fix the errors in Data.Config first?
10:22:49 <merijn> klrr: The Result type, most likely?
10:23:04 <lingxiao> hey could someone encode this expression using de-brjuin's index for me?
10:23:26 <lingxiao> (λx.xy)(λa.ab)
10:23:32 * hackagebot highlighting-kate 0.5.6 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.6 (JohnMacFarlane)
10:23:40 <tippenein> merijn: i guess my issue was with hlint, not module imports ;)
10:23:47 <lingxiao> the point here is that there's a free variable in both expressions: `y` and `b`
10:24:11 <lingxiao> now should this be: (λ.01)(λ.02), or (λ.01)(λ.01)
10:24:16 <klrr> merijn: ive not run the parser with parse ive just ran it inside the Parser monad
10:24:50 <lingxiao> in the first case, there's only one variable env storing free variables: {y,b}
10:25:00 <shachaf> lingxiao: That depends on what b and y are, of course.
10:25:17 <lingxiao> oh how so?
10:25:26 <klrr> the thing i really want to know is though: how do i parse a unkown amount of strings seperated with spaces that end with either ':' or '\r' in attoparsec?
10:25:31 <shachaf> But the second one doesn't seem very likely.
10:25:53 <klrr> because what i do currently does not work and i cant think of any other solution (especially since same solution works in parsec -.-)
10:25:59 <shachaf> The same notion of "free variable" and "environment" doesn't exist, exactly.
10:26:09 <lingxiao> shachaf: does the second one suggest a and b are refering to the same variable?
10:26:21 <shachaf> (A different one does, but you can't just take a fragment and expect to translate it directly.)
10:26:28 <lingxiao> what do you mean by same notion
10:26:29 <shachaf> No, y and b.
10:27:19 <lingxiao> oh oops that's what I meant..
10:27:47 <lingxiao> ahh so the way free variables is encoded is assuming there's a "global" context where all free varaibles are pushed into?
10:27:53 <lingxiao> for the entire expression
10:28:47 <brokenzebra> is there a shortcut to (\_ -> f)?
10:29:01 <shachaf> const f
10:29:02 <ziman> :t const
10:29:03 <lambdabot> a -> b -> a
10:29:14 <shachaf> @where hoogle can help with things like that.
10:29:14 <lambdabot> http://haskell.org/hoogle – See also Hayoo, which searches more packages: http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:29:31 <shachaf> Anyway, I don't quite understand what you mean.
10:29:54 <c_wraith> I like zipWith const
10:30:16 <shachaf> Let's say you have λa.λb.λc.a(bc). You can translate that to λ.λ.λ.2(10).
10:30:16 <lingxiao> so for the expression: (λx.xy)(λa.ab)
10:30:45 <lingxiao> but there's no free variables in the expression above
10:30:49 <shachaf> But translating λc.a(bc) to λ.2(10) doesn't make any sense, unless you know exactly how a and b are being bound.
10:31:23 <lingxiao> I thought some function would traverse the AST, and push each free variable into some context.. s
10:31:27 <shachaf> Maybe it's λa.λb. ...λ... ...λ... λc.a(bc) in which case they would be something else.
10:31:59 <lingxiao> but you would only know it's "λa.λb. ...λ... ...λ... λc.a(bc)" after you bind the expression to some a and b
10:32:08 <lingxiao> meanwhile, you'd still have to encode the expression right?
10:32:23 <brokenzebra> ohai thanks
10:32:27 <brokenzebra> :t const
10:32:28 <lambdabot> a -> b -> a
10:32:36 <lingxiao> so my understanding of de-brujin's index is that as you traverse the tree, you push free varialbles into some context, so in the end you'd get:
10:33:08 <lingxiao> env = {b,a} for λc.a(bc)
10:33:13 <shachaf> The question "what does λa.ab correspond to" doesn't make sense without more information.
10:33:41 <shachaf> Sure, you can write a program to turn one into the other using additional information.
10:33:48 <brokenzebra> :t forM
10:33:49 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
10:33:51 <klrr> how do i parse a unkown amount of strings seperated with spaces that end with either ':' or '\r' in attoparsec?
10:33:59 <brokenzebra> @hoogle forM
10:34:00 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
10:34:00 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
10:34:00 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
10:34:08 <lingxiao> does this question make sense: "what does λa.ab correspond to in the context env = {a,b}"
10:34:10 <shachaf> brokenzebra: You can also /msg lambdabot with your queries.
10:34:27 <shachaf> lingxiao: Does {} mean an ordered sequence here?
10:34:27 <lingxiao> where the location of variable in the set correspond to index, then the encoding is λ.01
10:34:31 <lingxiao> yes
10:34:53 <shachaf> OK, then it probably makes sense, except you're shadowing that a.
10:35:10 <lingxiao> how am i shadowing it?
10:35:23 <shachaf> You have an a inside the lambda and also in your environment.
10:35:27 <merijn> lingxiao: the \a.ab introduces a new a binding that hides the existing one
10:35:32 <shachaf> λa. ... λa.ab
10:36:04 <lingxiao> ahh ok I see now
10:36:05 <merijn> lingxiao: "\a. ... \a.ab" is equivalent to "\a. ... \x.xb"
10:36:33 <lingxiao> so you got there by alpha conversion correct?
10:37:13 <lingxiao> so in summary, if I have some expression "\a.ab", there's no way to index it without additional informtion
10:37:21 <shachaf> You might say that you got there by common sense and then used "alpha conversion" retroäctively to justify it.
10:37:51 <lingxiao> woa never knoew the a in retroactive has dots on it
10:38:19 <lingxiao> but yes, I'm trying to get comfortable with the terminology, thus using it anywhere I can
10:39:04 <lingxiao> ok so in Pierce's book he gives this example:
10:39:12 <lingxiao> env = {b,a,z,y,x}
10:39:22 <lingxiao> and this expression: "λw.λa.x"
10:39:48 <brokenzebra> how do you even type /\ that quickly?
10:39:58 <tomejaguar> shachaf likes using dots.
10:40:06 <shachaf> If you used [] brackets for env it would be less confusing.
10:40:20 <shachaf> tomejaguar: I was copying lingxiao's notation.
10:40:20 <lingxiao> now he encodes it as "λ.λ.6", because presumably he pushes both "w" and "a" into the env
10:40:25 <lingxiao> env = [b,a,z,y,x]
10:40:51 <lingxiao> brokenzebra: I'd like to say I have my own keymap, but really I just copy and pasted it :)
10:42:01 <lingxiao> so env = [w,a, b,a,z,y,x], where index x = 6 ?
10:42:43 <hhhhhhhh> is it possible to define 2 records that have the same member
10:42:51 <lingxiao> but I don't think that's right, so question: what does the environment look like after some function traverses the expression: "λw.λa.x" and converts it to "λ.λ.6."
10:42:52 <hhhhhhhh> or a member with the same name
10:43:35 <lingxiao> assuming env0 = [b,a,z,y,x]
10:44:10 <shachaf> "after"?
10:44:29 <shachaf> It looks the same, when you're done. If saying such a thing makes any sense.
10:44:38 <lingxiao> my current understanding is some function crawls the AST and modifies the environment
10:44:46 <lingxiao> but I guess now you're saying it doesn't
10:45:06 <lingxiao> so why does "λw.λa.x" become "λ.λ.6."
10:45:19 <merijn> lingxiao: Because that's how you encode things
10:45:20 <klrr> how do i parse a unkown amount of strings seperated with spaces that end with either ':' or '\r' in attoparsec?
10:45:33 <merijn> lingxiao: The 6 reverse to the value bound 6 lambdas "up"
10:45:38 <shachaf> Well, if you want to think of it that way, you can say: When you go into a lambda, you add something to your environment.
10:45:41 <merijn> lingxiao: s/reverse/refers
10:45:44 <lingxiao> why is the index of x = 6 when in the index of x in env is 4
10:45:50 <shachaf> When you leave, you go back to the old environment.
10:46:13 <lingxiao> shachaf: the first sentence you said,yes that's exactly how I think about it
10:46:30 <merijn> "\x. \a . \b . x" -> "\.\.\.3" (or 2, depending how you count)
10:46:54 <merijn> lingxiao: Because the x is bound the first of 3 lambdas
10:47:19 <merijn> "\a.\x.\b.x" -> "\.\.\.2", because x is bound the 2nd of 2 lambda's
10:47:51 <merijn> "\a.\x.\b.\a.a" -> "\.\.\.\.1", because the 'a' refers to the one bound 1 level up
10:48:55 <tomejaguar> shachaf: I mean ä
10:48:58 <lingxiao> merijin: so in my mind I cannot resolve the difference of how index is bound in the case of free variables vs bound variables
10:49:12 <lingxiao> in all your example sabove, x is bound in the expression
10:49:32 <lingxiao> but in here "λw.λa.x", x is not bound
10:49:53 <lingxiao> but it's found in the env = [b,a,z,y,x]
10:50:03 <lingxiao> which currently has index 4
10:50:15 <hhhhhhhh> newbie question: what is the correct syntax to make http://lpaste.net/6408795666167889920 work
10:50:47 <lingxiao> now are you saying "λw.λa.x" in then env [b,a,z,y,x] is the same as:
10:51:10 <lingxiao> λx.λy.λz.λa.λb. λw.λa.x
10:51:24 <jfischoff> h's I annotated your paste
10:51:25 <lingxiao> in the env*
10:52:22 <lingxiao> in that case I can see how x has index 6, if you count from 0, or index if you count from 1
10:52:42 <lingxiao> index 7*
10:53:38 <merijn> hhhhhhhh: The correct approach is "Don't add an constraint on your datatype"
10:54:01 <hhhhhhhh> jfischoff: i annotated it again with the error message i get for that
10:54:05 <merijn> hhhhhhhh: Ignore what it says about ExistentialQuantification, that's a filthy lie and doesn't help you
10:54:21 <monochrom> hhhhhhhh: I recommend http://lpaste.net/98137
10:54:59 <hhhhhhhh> monochrom: that works and saves me a bunch of typing :)
10:55:16 <monochrom> the power of KISS
10:55:26 <jfischoff> hhhhhhhhh: you need to enable that language extension or better listen to monochrom
10:55:52 <lingxiao> merijn: actually now everything makes sense, thanks for walking me through it!
11:16:27 <hhhhhhhh> ok i need to decode json structures which look like { "op": blah, ... } where the ... depends on the value of blah
11:16:56 <hhhhhhhh> i'd rather keep using aeson because scotty includes it already and its less confusing but i have no clue how to do this
11:19:04 <c_wraith> hhhhhhhh: It's not that hard to do, but you'll need to implement fromJSON by hand, with an appropriate data structure - presumably a sum type that has constructors for each possible value of blah
11:19:30 <c_wraith> hhhhhhhh: and then if you want toJSON to work sanely, you'll have to do that by hand as well
11:20:05 <hhhhhhhh> c_wraith: so i need to make toJSON for something like "Op String [ ( String, String ) ]"
11:21:02 <c_wraith> hhhhhhhh: what do these structures actually represent?
11:21:20 <c_wraith> hhhhhhhh: I ask only because I want to name my example better
11:21:25 <hhhhhhhh> c_wraith: http://tt-rss.org/redmine/projects/tt-rss/wiki/JsonApiReference
11:24:57 <c_wraith> hhhhhhhh: something like..  data Operation = GetApiLevel | GetVersion | Login ByteString ByteString | ...
11:26:36 <hhhhhhhh> c_wraith alright
11:26:48 <c_wraith> hhhhhhhh: then write a custom FromJSON instance for it that first checks the op field, then branches on it to parse each case into its appropriate constructor
11:27:42 <hhhhhhhh> is that going to be as tedious as it sounds
11:28:01 <monochrom> it sounds not tedious to me
11:29:12 <c_wraith> It's as tedious as it needs to be.  You have to handle all those different cases.
11:29:24 <c_wraith> That means yes, you have to write code for all those different cases.
11:29:52 <hhhhhhhh> doh :p
11:30:31 <c_wraith> No programming language is ever going to free you from having to describe what you want to do in each special case you run into in the real world.  Sucks, doesn't it? :)
11:31:30 <hhhhhhhh> :D
11:32:09 <c_wraith> hhhhhhhh: you could (though I highly recomend against it) just use Aeson to parse out a Value, and skip parsing into your own type - but you'll lose a lot of good guarantees if you do so.
11:32:41 <c_wraith> hhhhhhhh: If you're going to maintain this for long, using a custom type is almost certainly better than hacking on Value
11:35:31 <hhhhhhhh> c_wraith yeah i almost did that but i am here to learn haskell and that would be cheating
11:38:45 * hackagebot hsimport 0.2.6.5 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.2.6.5 (DanielTrstenjak)
11:51:54 <hattmammerly> > liftM (shuffle' [1..10] 6) $ getStdGen
11:51:55 <lambdabot>  Not in scope: shuffle'
11:52:05 <hattmammerly> > liftM (System.Random.Shuffle.shuffle' [1..10] 6) $ getStdGen
11:52:07 <lambdabot>  Not in scope: System.Random.Shuffle.shuffle'
11:52:48 <ReinH> hattmammerly: System.Random.Extras perhaps?
11:53:09 <hattmammerly> > liftM (System.Random.Extras.shuffle' [1..10] 6) $ getStdGen
11:53:10 <lambdabot>  Not in scope: System.Random.Extras.shuffle'
11:53:13 <ReinH> nope
11:53:21 <ReinH> oh there is random-shuffle
11:53:27 <ReinH> but lambdabot doesn't import it
11:53:37 <hattmammerly> well shoot. anyway, when I run this I'm getting exceptions partway through the evaluation ([2,3,4,5,1*** Exception: [shuffle] called with lists of different lengths)
11:53:48 * hackagebot pretty-show 1.6.5 - Tools for working with derived `Show` instances and generic  inspection of values.  http://hackage.haskell.org/package/pretty-show-1.6.5 (IavorDiatchki)
11:55:00 <hattmammerly> any ideas why? never woulda guessed shuffling a list would be so complicated
11:55:36 <mello_> how can I do something if two Maybe values both exist?
11:55:40 <mello_> sorry, stupid question
11:55:46 <Clint> both exist?
11:55:54 <troydm> two Maybe values
11:55:56 <mello_> if both are not nothing
11:55:58 <ReinH> are both Just values, presumably
11:56:04 <ReinH> mello_: what something do you want to do?
11:56:32 <ReinH> doSomething (Just a) (Just b) = doSomethingWith a b; doSomething _ _ = doSomethingElse
11:56:46 <dv-> > (+) <$> Just 1 <*> Just 2
11:56:47 <lambdabot>  Just 3
11:57:04 <mello_> ReinH, if they are both something, call a function with them, else call them with default params
11:57:06 <byorgey> hattmammerly: uh, well, the docs for shuffle' say "given a sequence to shuffle, its length, and..."
11:57:14 <byorgey> hattmammerly: 6 is definitely not the length of [1..10]
11:57:29 <ReinH> byorgey: kind of weird that you need to provide the sequence length when you already provided the sequence
11:57:32 <ReinH> but yes
11:57:57 <ReinH> mello_: so pattern matching seems fine
11:58:03 <byorgey> it is very weird.  maybe it's because shuffle' doesn't want to have to force the spine of the list to discover its length
11:58:18 <byorgey> but it needs to know the length to compute probabilities
11:58:25 <ReinH> byorgey: but it would force it anyway when shuffling
11:58:29 <mello_> well im not sure how to since Im in a monad (snap)
11:58:36 <byorgey> ReinH: yes, but laziness
11:58:50 <ReinH> mello_: no differently than anywhere else. You're always in a monad.
11:58:55 <hattmammerly> byorgey: ahaha oh I misunderstood a description of it and believed that argument to be the element in a list of permutations and i chose 6 arbitrarily
11:59:03 <byorgey> hattmammerly: hehehe
11:59:04 <ReinH> byorgey: eh. I guess.
11:59:10 <mello_> ReinH,  ok let me try :)
11:59:18 <byorgey> ReinH: I don't know, this is complete speculation on my part
11:59:32 <byorgey> it was written by Oleg! it must be right!
11:59:37 <ReinH> byorgey: yeah, it's plausible
11:59:39 <ReinH> but still strange
11:59:57 <ReinH> byorgey: like, what scenarious would that be called with a list whose spine wasn't already forced to determine its length?
12:00:14 <ReinH> seems like the most common use would just be shuffle' list (length list)
12:00:33 <ReinH> which is just annoying
12:00:42 <byorgey> agreed
12:01:04 <ReinH> byorgey: oh Oleg wrote it
12:01:06 <ReinH> it is of course correct
12:01:10 <ReinH> I withdraw my remarks
12:01:24 <byorgey> that's better
12:01:28 <byorgey> ;-)
12:01:44 <byorgey> proof by Oleg
12:03:37 <erisco> deleteBy has the oddest design
12:03:42 <erisco> :t deleteBy
12:03:43 <lambdabot> (a -> a -> Bool) -> a -> [a] -> [a]
12:03:55 <erisco> no reason it cannot be (a -> Bool) -> [a] -> [a]
12:05:07 <byorgey> erisco: I guess it is just to make it fit better with all the other *By functions
12:05:23 <byorgey> but I agree
12:06:06 <mr-> Oh.. that one again :-)
12:07:19 <bennofs> Can I use xml-conduit to skip over tags that I didn't parse?
12:08:49 * hackagebot Condor 0.2 - Information retrieval library  http://hackage.haskell.org/package/Condor-0.2 (klangner)
12:09:29 <ParahSailin> bennofs: sax or dom functions?
12:09:52 <Clint> should be doable with Text.XML.Stream.Parse
12:14:49 <bennofs> Clint: how? I have a document like <proctocol>some xml ...</protocol>. If I just do tagNoAttr "protocol" $ return (), it fails
12:15:04 <bennofs> Clint: (because it expects a close tag, but gets an opening tag)
12:19:53 <Clint> bennofs: maybe something like tagNoAttr "protocol" $ (many (tagPredicate (const True) ignoreAttrs $ content) >> return ()) ?
12:21:04 <bennofs> Clint: now it's missing the end tag for protocol
12:22:33 <Clint> bennofs: ah, maybe you should return False if it's "protocol"
12:29:35 <erisco> oops I guess you're not supposed to submit the private key to github
12:29:35 <erisco> :P
12:30:03 <c_wraith> no, that's usually a bad thing.  Time to burn that key!
12:30:24 <dv-> well for singing the private keys are made public
12:31:06 <Clint> in the key choir
12:32:24 <erisco> um oops
12:32:42 <erisco> just did a rm -rf *.... damn my unix is rusty
12:32:57 <geekosaur> (but the choir is singing out of key!)
12:36:43 <erisco> mkay I have the initial commit for my strange new module up :)
12:36:58 <erisco> comments and inquiry are welcomed https://github.com/erisco/haskell-decision
12:37:24 <erisco> only file is here https://github.com/erisco/haskell-decision/blob/master/src/decision.hs
12:38:33 <jfischoff> is it tracing the different code paths?
12:38:51 <erisco> jfischoff, you could say that, yes
12:41:29 <pavonia> Using cabal, how do you process a file using an external tool and link the resulting .o file into the executable being built by cabal?
12:43:33 <erisco> \d f -> biDecide f . d :: (a -> BiDecision a1 b i c) -> (a1 -> b) -> a -> c
12:43:43 <erisco> that is the conversion back to the normal function
12:44:30 <bennofs> Clint: Ok, I solved my issue. I had to use consumeChildren n = void $ many $ orE (fmap (() <$) contentMaybe) $ tag (mfilter (/= n) . return) (<$ ignoreAttrs) $ \t -> consumeChildren t
12:44:53 <Clint> wow
12:45:49 <c_wraith> bennofs: I'm very amused you have both void and (() <$) in there
12:46:00 <c_wraith> bennofs: since those two do exactly the same thing
12:46:01 <bennofs> c_wraith: oh right :P
12:46:17 <bennofs> c_wraith: I can also eta-reduce the last lambda
12:47:35 <erisco> jfischoff, also if you can think of any way it is useful I'd also like to hear :P
12:48:20 <jfischoff> I think it could be useful or something like it
12:48:55 * jfischoff keeps thinking
12:48:59 * hackagebot vect-floating 0.1.0.0 - A low-dimensional linear algebra library, operating on the Floating typeclass  http://hackage.haskell.org/package/vect-floating-0.1.0.0 (cdurham)
12:50:12 <erisco> I came up with the idea initially as a refactoring of my code. I was dealing with recursion that could only be terminated by the decision function
12:50:26 <erisco> (I am calling the function you pass in the "decision function")
12:51:14 <erisco> I could instead express it as an infinite tree and worry about how to find the correct result later
12:53:55 <erisco> jfischoff, I have not added it in yet (still reworking from the initial code) but you can also make more informed decisions than normal
12:53:59 * hackagebot vect-floating 0.1.0.1 - A low-dimensional linear algebra library, operating on the Floating typeclass  http://hackage.haskell.org/package/vect-floating-0.1.0.1 (cdurham)
12:54:03 <erisco> for instance, you can perform lookahead or lookbehind
12:54:30 <erisco> whereas you cannot normally do that without this factoring
12:59:17 <erisco> a more complicated model, which I am not implementing, would reveal partial information at each decision point
12:59:53 <erisco> this partial information would reflect constraint on the possible return values at that point
13:00:36 <erisco> which is valuable when the tree is infinite. it could allow you to exhaustively look for something
13:06:48 <erisco> has Eq instances for functions been considered that have Bounded and Enumerable domains and Eq codomains?
13:07:08 <prophile> that still sounds like a bad idea
13:07:30 <erisco> prophile, for what reason?
13:08:01 <prophile> erisco: Int is both, I believe?
13:08:23 <prophile> it is
13:08:26 <erisco> yes, it should be. but why is such an instance a bad idea?
13:08:57 <prophile> because evaluating a function 2^30 times for an equality check which is probably not the programmer's intention anyway sounds like an extremely iffy proposition
13:09:01 <mello_> is there a way to have optional parameters in Snap routes?
13:09:08 <prophile> hiding it inside a newtype might be saner
13:09:58 <dsfdsf> Is the libraries list a proper place to discuss issues with non-HP libraries?
13:10:44 <prophile> erisco: I don't know if it's necessarily true that enumFrom minBound gives the entire range of the type either
13:11:04 <erisco> I would just call 'enumerate'
13:11:34 <prophile> 'enumerate'?
13:11:37 <prophile> @hoogle enumerate
13:11:37 <lambdabot> No results found
13:12:23 <erisco> yes, it is supposed to return a list of all values. the reason for Bounded, of course, is that I don't think Enumerable requires the list to be finite
13:12:38 <erisco> but Bounded together with Enumerable would, I think
13:12:50 <prophile> you'd need a starting point for the list
13:13:00 <erisco> does not matter what it is
13:13:05 <prophile> no, but you'd need to get one
13:13:13 <erisco> 'enumerate' is a list
13:13:24 <prophile> where is enumerate defined?
13:13:24 <erisco> just go in whatever order it uses
13:13:32 <erisco> in the Enumerable class
13:13:52 <prophile> from the 'enumerable' package?
13:13:55 <erisco> mmhmm
13:14:05 <prophile> I'd never come across it before
13:14:14 <erisco> > enumerate :: [Word8]
13:14:15 <lambdabot>  Not in scope: `enumerate'
13:14:25 <prophile> that's an obsure package
13:14:30 <prophile> another reason why that instance isn't defined
13:14:35 <erisco> yeah it is not listed on Hoogle and lambdabot does not seem to import it
13:15:38 <novochar> why is `do { putStrLn "hello"; return "yes" }` valid within ghci, and `putStrLn "hello"; return "yes"` not valid? also, how is it possible that you perform a do block within ghci, isn't ghci one large do block?
13:16:03 <prophile> novochar: there is no reason that a do block cannot contain another
13:16:21 <jrmithdobbs> why wouldn't you be able to manipulate one monad inside another that knows about it?
13:16:26 <geekosaur> ghci pretends to be a do block. it is not actually one, and its syntax is fairly limited
13:16:32 <erisco> prophile, maybe it is a bit obscure, I don't know. It has instances for many common types, but is missing some obvious stuff like (Enumerable a) => Maybe a
13:16:44 <JakeE> novochar: your second example isn't syntactilly correct
13:16:49 <prophile> erisco: that instance looks to be there to me
13:16:59 <erisco> oh you're right :)
13:17:14 <JakeE> > test = putStrLn "hello"; return "yes"
13:17:15 <lambdabot>  <hint>:1:6: parse error on input `='
13:17:35 <novochar> let test = putStrLn "hello"; return "yes"
13:17:36 <JakeE> well can't do defnitions on lambdabot but the point is that that is invalid syntax
13:17:36 <geekosaur> (you can't do an import in a do block, yet ghci has allowed that since 7.2 or thenabouts)
13:17:51 <erisco> I notice they also have a FinitelyEnumerable class... wonder what was wrong with Bounded
13:18:04 <roboguy_> JakeE: you can do definitions
13:18:06 * prophile evaporates
13:18:36 <JakeE> > myAdd = (+)
13:18:37 <lambdabot>  <hint>:1:7: parse error on input `='
13:18:41 <JakeE> > let myAdd = (+)
13:18:42 <lambdabot>  not an expression: `let myAdd = (+)'
13:18:45 <novochar> also what's the difference in `let x = 42` and `x <- return 42` within ghci?
13:18:46 <roboguy_> @let myAdd = (+)
13:18:48 <lambdabot>  Defined.
13:19:01 <JakeE> @let myAdd = (+)
13:19:01 <lambdabot>  .L.hs:167:1:
13:19:01 <lambdabot>      Multiple declarations of `myAdd'
13:19:01 <lambdabot>      Declared at: .L.hs:166:1
13:19:01 <lambdabot>                   .L.hs:167:1
13:19:03 <erisco> novochar, check the types
13:19:10 <novochar> erisco: they have the same type
13:19:17 <roboguy_> there's a way to remove a definition too, but I don't remember how
13:19:18 <JakeE> o cool! do they flush the defnitions every now and again?
13:19:26 <roboguy_> JakeE: I think so
13:19:35 <JakeE> thanks for showing me that
13:19:41 <jrmithdobbs> novochar: well x <- return y; is redundant to begin with ...
13:19:48 <cdk> does anyone know if there's a seminal paper on the actor model?
13:20:01 <erisco> novochar, I am not sure how you are comparing the types
13:20:22 <raphie> is there a way to pass in a type to a function?
13:20:32 <erisco> novochar, x <- return 42 is return 42 >>= \x -> ... which is not a complete function
13:20:57 <novochar> erisco: by typing `:t` within ghci, like this: `let x = 42`; `y <- return 42`; :t x; :t y -- not all on a single line
13:21:01 <erisco> raphie, types cannot be used at the value level, no
13:21:14 <raphie> erisco: so is there a way to make this work? https://gist.github.com/RaphiePS/0b0e472d0b21441cf796
13:21:17 <JakeE> raphie: well sorta, look at how 'read' is implemented in the type class (read someString :: MyType) is an example of "passing" 'MyType' to read
13:21:49 <erisco> novochar, that is interesting
13:21:51 <raphie> er I misordered the type signature, but yeah, any way to do that?
13:22:09 <erisco> anyone know why 'y <- return 42' is a valid statement in ghci? is it inlined into a do block?
13:22:41 <erisco> novochar, in any case that is a bit irregular
13:22:45 <roboguy_> raphie: asTypeOf might help
13:22:53 <ion> It interprets it like the equivalent line in a do block in IO.
13:23:23 <erisco> ion, ah
13:23:28 <roboguy_> raphie: actually, did you try it without any type annotation?
13:23:39 <jrmithdobbs> that moment where you're staring at something trying to think of how to re-implement it elsewhere and realise that what you thought you were trying to implement is actually 100x more complicated (and correct :() than what you're trying to be compatible with
13:23:43 <jrmithdobbs> ya
13:23:51 <jrmithdobbs> is it too early to be drinking today? ;p
13:24:10 <novochar> is this correct: the only difference is that one is a non-io binding operation and the other is an io operation whose result is bound to a variable?
13:24:18 <JakeE> the semantics of 'y <- return' appears to be that it inlines it into ghcs "do block"
13:24:54 <erisco> novochar, I do not know what you mean by "IO binding" but neither are IO operations
13:24:54 <roboguy_> erisco: there is an implicit do block in ghci
13:25:29 <erisco> novochar, the fact that "y <- return 42" even works is a happenstance of how ghci interprets the code
13:25:45 <novochar> from the ghc documentation on ghci: The statement x <- return 42 means “execute return 42 in the IO monad, and bind the result to x”.
13:25:48 <erisco> novochar, "y <- return 42" is not the same as "let y = 42"
13:26:22 <jrmithdobbs> :t (<-)
13:26:23 <lambdabot> parse error on input `<-'
13:26:24 <roboguy_> erisco: in that particular case, don't both ultimately have the same effect?
13:26:25 <jrmithdobbs> I wish that actually worked
13:26:37 <jrmithdobbs> because it makes this so much easier to explain ;p
13:26:39 <roboguy_> jrmithdobbs: that would be like asking for the type of \ from the lambda synta
13:26:41 <roboguy_> *syntax
13:26:42 <JakeE> what would the type of (<-) be?
13:26:45 <jrmithdobbs> roboguy_: aware
13:27:05 <erisco> roboguy_, novachar, well yes, but where you can use "let y = 42" you cannot necessarily use "y <- return 42"
13:27:19 <erisco> JakeE, it is sort of an alias for >>=
13:27:26 <erisco> :t (>>=)
13:27:27 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:27:43 <ion> What’s the type of (::)? How about (|), as in [ … | … ]? ;-)
13:27:51 <novochar> oh, the monadic binding (p <- e) is evaluated immediately within ghci whereas the let x = y binding isn't evaluated immediately
13:27:51 <roboguy_> JakeE: it's not a function or a binding so it doesn't have a type. it's syntax in the way "=" or "\" is
13:27:56 <JakeE> but why does it make sense that <- would have a type? it's first argument is an id...that is just strange
13:28:13 <shachaf> novochar: No, neither is evaluated immediately.
13:28:17 <ion> (<-) is not an operator, it’s syntax.
13:28:25 <roboguy_> JakeE: it doesn't make sense for it to have a type, so it doesn't have one
13:28:28 <JakeE> ya, agree with that
13:28:28 <shachaf> e is executed immediately, but that's a different deal.
13:28:43 <novochar> shachaf: that's from the ghc documentation, http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/interactive-evaluation.html
13:28:44 <shachaf> "x <- return y" is very similar to "let x = y"
13:28:45 <pavonia> erisco: In a monad context they are equivalent (provided the monad laws are satisfied)
13:28:47 <novochar> is it outdated?
13:28:55 <erisco> pavonia, indeed
13:29:13 <shachaf> Oh, *e* is evaluated immediately, sure.
13:29:22 <shachaf> I don't know what "the monadic binding" means.
13:29:36 <shachaf> But if you mean the variable that's being bound, that's not evaluated immediately.
13:29:43 <jrmithdobbs> shachaf: (>>=) == bind
13:29:45 <erisco> novachar, the notation "a <- b" is specific to do-blocks which is specific to Monads. In contrast, "let" can be used just about anywhere
13:29:54 <shachaf> jrmithdobbs: Thanks.
13:30:14 <ion> “let { … }” without “in” can not be used just about anywhere.
13:30:21 <erisco> novachar, and if your goal is to assign a variable to something not in a Monad (such as the plain number 42), then always use a "let"
13:30:50 <pavonia> or "where"
13:31:31 <erisco> ion, nova, yes when using "let" outside of do-blocks you need to follow with the "in" keyword
13:31:55 <erisco> > let x = 1; y = 2 in x + y -- example
13:31:57 <lambdabot>  3
13:32:19 <joelteon> where's chrisdone
13:32:21 <joelteon> D:
13:33:04 <erisco> novachar, sorry the above was for you. Also, sorry that this is so confusing. I am sure the difference between the two is hard to see
13:34:24 <joelteon> does anybody here use hell and have any idea how to use it?
13:34:55 <erisco> joelteon, do you still have a soul to sell?
13:34:59 <joelteon> I do
13:35:18 <JakeE> no but I just sawl that it is a haskell shell and that I am now getting rid of bash :p
13:35:32 <JakeE> *saw
13:35:44 <joelteon> don't be so fast
13:35:49 <joelteon> as far as I can tell, it doesn't do anything
13:36:34 <novochar> this is from a ghci session: https://gist.github.com/novodinia/8307223 ; why is z failing to act like head, is pattern matching allowed in a let block?
13:36:48 <JakeE> oh...meh. it's not really a shell
13:37:23 <joelteon> well, I can't tell
13:37:25 <joelteon> it doesn't do anything
13:37:43 <joelteon> it throws an error if I input expressions of type IO a, and complains about a profiled compiler otherwise
13:37:45 <JakeE> I'm just looking at the documentation on github and it dosn't look like much
13:37:49 <erisco> novochar, your 'z' function has type [[a]] -> [a]
13:38:11 <erisco> novochar, and the type of ['a', 'b'] is [Char], so it is a type error
13:38:22 <roboguy_> > head []
13:38:24 <lambdabot>  *Exception: Prelude.head: empty list
13:38:28 <ion> novochar: “z [] = []” constrains the type of the return value to be a list. Therefore in “z (x:xs) = x”, x must be a list. Therefore (x:xs) must be a list of lists.
13:38:30 <roboguy_> ^ novochar
13:43:38 <novochar> thank you
13:45:29 <raphie> how would I get these Eithers to "cascade" so that something will only run if all are Right? https://gist.github.com/RaphiePS/f83eb4217a88f13b66f6
13:47:09 <jfischoff> you need a monad instance for Either
13:47:10 <erisco> prophile, ohhhh the standard one is Enum
13:48:07 <raphie> jfischoff: how would I do that?
13:48:20 <jfischoff> what version of GHC are you using?
13:48:44 <jfischoff> you could import Control.Monad.Instancesb
13:48:44 <raphie> I actually want to "bail out" from any of these early
13:48:49 <jfischoff> Control.Monad.Instances
13:48:55 <erisco> there is already an instance for Either
13:49:48 <jfischoff> I thought it was removed or something
13:49:50 <roboguy_> raphie: it will loop indefinitely iff all of the are Right. is that what you want?
13:49:51 <jfischoff> oh well
13:50:07 <roboguy_> erisco: I'm pretty sure it's not in base for some reason
13:50:14 <|TheWolf|> hi
13:50:16 <raphie> roboguy_: sequence is actually what I'm going for, but the problem is that these are returning *different* kinds of eithers
13:50:20 <erisco> I imported Control.Monad and it seemed to be there
13:50:21 <raphie> so really I need some sort of tuple
13:50:30 <roboguy_> erisco: huh, maybe I'm thinking of something else
13:50:33 * bearclaw_ is doing the first problems of project euler using haskell, it's pleasant how many of them are basically pretty readable one-liners
13:50:49 <ReinH> bennofs: it is! :)
13:50:51 <roboguy_> I know the Monad instance for Monoid a => ((,) a) isn't in base for some reason
13:51:28 <quchen> There's Writer for that.
13:51:40 <roboguy_> quchen: yeah, but sometimes I just want to work with a tuple
13:51:59 <roboguy_> also, Writer isn't in base either is it?
13:52:06 <geekosaur> yes?
13:52:22 <roboguy_> I thought Writer was in mtl
13:52:32 <geekosaur> oh, hm, not absolutely sure of that, mtl feels like it should be in there
13:52:55 <benmachine> Writer is in mtl and transformers
13:52:56 <geekosaur> that said, base is going for minimal and perhaps should not be the target for user programs
13:53:03 <benmachine> well, it's in transformers, and mtl re-exports it
13:53:18 <benmachine> the instance for Either *is* in base, but only relatively recently
13:53:21 <roboguy_> it just seems like the monoid tuple instance of Monad should be in base. Monad ((->) r) is in base
13:53:24 <|TheWolf|> I've got a noob question about polymorphism in Haskell: I have a tree data structure defined as data Tree a = Leaf a | Branch a (Tree a) (Tree a) and need to implement a function working such a tree. What I'd like to is something like foo: Tree a -> [a], but that does not seem to work :-/ sorry if that's too noobie, but I didn't find anything on the web
13:53:54 <quchen> roboguy_: It's regularly discussed on the mailing lists, until people get tired of the discussion.
13:53:57 <jfischoff> why does it now work?
13:54:06 <benmachine> |TheWolf|: perhaps you mean foo :: Tree a -> [a]?
13:54:12 <roboguy_> quchen: that really, really doesn't surprise me
13:54:17 <Twey> raphie: As in, they all have different Left types?
13:54:24 <benmachine> then foo (Leaf x) = [x]; foo (Branch x xs ys) = something else
13:54:51 <erisco> raphie, is your left type always the same?
13:54:54 <|TheWolf|> benmachine : sorry, my fault. in my script, I have foo :: Tree a -> [a]
13:54:55 <roboguy_> |TheWolf|: why doesn't it work?
13:55:35 <|TheWolf|> roboguy_ : when I load the script into WinHugs it tells me "Missing binding for variable "foo" in type signature"
13:55:46 <roboguy_> |TheWolf|: you need a definition to go with the declaration
13:56:09 * |TheWolf| bangs his head to the desk
13:56:15 <Twey> |TheWolf|: You might also want to consider switching to GHC.  Hugs is unmaintained.
13:56:23 <roboguy_> ^ definitely agreed
13:56:40 <|TheWolf|> Twey : yeah, our Professor forces us to use it *rolleyes*
13:56:48 <Twey> Ah
13:56:53 <roboguy_> I've heard they still use it at some universities which boggles my mind
13:57:17 <Twey> They still teach Pascal at some universities; my mind is not significantly more boggled by finding out that Hugs is still around
13:57:17 <bearclaw_> you might consider switching him too then, he's probably unmaintained as well :p
13:57:17 <roboguy_> all the new, cool stuff (some of it derived from academic work) is in ghc
13:57:58 <Twey> Actually, I think we were recommended (but thankfully not forced) to use Hugs, too
13:58:09 <|TheWolf|> bearclaw_ : unfortunately, there's no way to do that anytime soon. However, you're right in general :-D
13:58:27 <WraithM_> Other than Ajhc, GHC, and the various JS-backend haskell compilers, are there other maintained haskell compilers?
13:58:41 <erisco> and our school uses Miranda instead of Haskell, so, meh
13:58:51 <Twey> WraithM_: I think UHC and YHC are still around
13:59:08 <roboguy_> I wonder why they would even recommend hugs...
13:59:13 <geekosaur> I thought yhc was dead. uhc is at least pretending to be around
13:59:20 <Twey> There are quite a few about, they just don't get used much outside research
13:59:30 <Twey> UHC has the supercompilation work in it, right?
13:59:31 <WraithM_> I guess there's also that Intel one
13:59:33 <WraithM_> too
13:59:44 <novochar> wy is the first binding within the multi-line mode invalid? http://gist.github.com/novodinia/8307571 x and y are aribtrary examples, i'm thinking it might be useful later to define a couple of functions within this mode
13:59:49 <roboguy_> WraithM_: there's an Intel haskell compiler?
14:00:01 <WraithM_> roboguy_: I remember seeing a paper about it or something a while ago.
14:00:21 <WraithM_> roboguy_: http://www.leafpetersen.com/leaf/publications/hs2013/hrc-paper.pdf
14:00:25 * flebron wonders if he could ask for style/idiom usage comments on his first package-to-be, at https://github.com/fedelebron/AVL
14:00:33 <roboguy_> WraithM_: huh, interesting
14:00:56 <Twey> novochar: Because there's no GHCi magic going on in there, so that's equivalent to the expression ‘let { x = 42 }; let { y = 43 }’ which isn't valid Haskell
14:01:00 <WraithM_> roboguy_: It still uses GHC's frontend though
14:01:19 <roboguy_> WraithM_: that makes sense
14:01:25 <Twey> novochar: (it would be valid inside a do-block, but you'd need to follow it with an expression)
14:03:19 <novochar> thanks, hopefully this is the last problem i run into: http://gist.github.com/novodinia/8307624 i'm not sure why bindings within the do block are invalid
14:05:00 <c_wraith> novochar: when you use braces, you also need to use semicolons.
14:05:25 <c_wraith> novochar: the whitespace layout stuff actually decodes to braces and semicolons inside the parser.
14:08:58 <raphie> Twey / erisco: yeah, the Left type is always the same (sorry for the delay)
14:09:07 <raphie> the Right type changes
14:09:13 * hackagebot cpsa 2.3.2 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.3.2 (JohnRamsdell)
14:09:44 <erisco> raphie, then I think you are in luck because the Either monad instance should work for that. However, I do not know how to use the Either monad within IO
14:10:12 <adnap> How can I see the value constructors for a type in GHCI?
14:10:13 <raphie> here's a more specific question: say I have a single IO action that returns an Either
14:10:33 <raphie> I want to retry it continually if it's Left, then continue once it's Right
14:10:41 <c_wraith> adnap: does :info show them?
14:11:26 <S11001001> raphie: assuming eithert gives rise to monadplus, sounds like msum . repeat to me
14:11:36 <adnap> c_wraith: Yes
14:11:38 <erisco> c_wraith, adnap :info shows them for me
14:12:23 <ParahSailin> wouldnt monadplus for either always give mzero if the first one is mzero?
14:12:32 <adnap> Why does Hackage documentation sometimes go missing for a newer version of a package? Sometimes hyperlinks go away even if the API didn't change.
14:12:43 <S11001001> ParahSailin: mzero is left identity for monadplus
14:12:56 <hpc> adnap: space gremlins
14:12:57 <ParahSailin> @src MonadPlus
14:12:57 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:13:16 <ParahSailin> @src Either mplus
14:13:16 <lambdabot> Left _ `mplus` n = n
14:13:16 <lambdabot> m      `mplus` _ = m
14:13:21 <hpc> adnap: or more likely, build failures or recent uploads
14:13:22 <ParahSailin> ah
14:13:23 <c_wraith> adnap: I have a suspicion that it's related to safehaskell, somehow.
14:13:34 <hpc> haddock is generated in a batch, and it happens after compilation for reasons
14:14:16 <adnap> c_wraith: It occurred before safehaskell
14:14:26 <roboguy_> wait, Either isn't MonadPlus is it? what's mzero?
14:14:27 <adnap> I have been dealing with this issue for years
14:14:38 <eazar001> either can be monadplus
14:14:42 <adnap> I usually go to an older version of a package until the hyperlinks appear
14:14:45 <eazar001> import Control.Monad.Error
14:14:49 <eazar001> it makes it an instance
14:14:58 <ParahSailin> @src Either mzero
14:14:58 <lambdabot> mzero            = Left noMsg
14:14:58 <roboguy_> eazar001: you need either error or undefined to define it though, don't you?
14:15:02 <c_wraith> This suspicion is based on a lot of modules not showing up in hackage haddock that contain incredibly unsafe functions, while the rest of the package is marked trustworthy
14:15:10 <hpc> @src noMsg
14:15:10 <lambdabot> Source not found. Whoa.
14:15:14 <raphie> S11001001: doesn't seem to work. if the Either is Left, it immediately returns the Left rather than retrying
14:15:23 <eazar001> roboguy_:simply importing Control.Monad.Error does it for me
14:15:27 <eazar001> so yes
14:15:32 <c_wraith> adnap: oh, if you just mean the delay between a package being published and the haddocks being generated - yeah, it's because haddocks are generated a few times a day in a batch job
14:15:43 <roboguy_> eazar001: well, I mean lowercase error (the error function)
14:15:47 <eazar001> roboguy_: but you don't have to manually declare the instance yourself
14:15:59 <eazar001> roboguy_: I never had to use it no
14:16:04 <roboguy_> never mind
14:16:11 <eazar001> roboguy_: I used string before
14:16:13 <S11001001> raphie: what's mzero give for your type?
14:16:26 <eazar001> roboguy_all: no "string" flame-war [=
14:16:36 <adnap> c_wraith: No, sometimes the package is published months ago and there are still no hyperlinks that existed in haddocks for previous versions
14:17:00 <c_wraith> adnap: possibly because the thing they target doesn't have docs at the moment?
14:17:09 <jrmithdobbs> so I have a (Text -> Text) function and want a function: (Text -> Text) -> Text -> Text; such that the second arg is the original data, the string will be formatted like "stuff %{var%{var2}val} more stuff %{var3} ..." and I want to end up with something like ["stuff ", "%{var%{var2}val}", "more stuff", "%{var3}", " ..."] (aka, tokenize it) so that I can then easily pass it to the function in the first arg ... is attoparsec/parsec what I'm after? 
14:17:11 <hpc> adnap: can you find an example maybe, and check the build log?
14:17:22 <raphie> S11001001: no instance for MonadPlus
14:17:37 <raphie> specifically No instance for (MonadPlus ((->) (IO (Either InterpreterError (Float, Float)))))
14:17:39 <S11001001> raphie: how did you call msum?
14:18:03 <intrados> Is there a good way to splice a PredQ into a pre-existing type?
14:18:20 <S11001001> raphie: and you need to use the transformer, not just IO of Either
14:18:35 <hpc> intrados: type PredQ = Q Pred
14:18:49 <hpc> intrados: Pred exports constructors, and conveniently Q is a monad
14:19:00 <raphie> S11001001: https://gist.github.com/RaphiePS/b23e7c4e6ae0984a6d4f
14:19:03 <roboguy_> raphie: if you're working with the code you showed us earlier, I think you just need a Monad instance for Either
14:19:11 <jrmithdobbs> hrm, actually just asking that made me think about how to do it correctly with attoparsec, nevermind, ha
14:19:16 <c_wraith> Q...  Must be TH.  Why does TH have all those FooQ type aliases?  What do they make clearer?
14:19:21 <raphie> roboguy_: how would I use that?
14:19:23 <hpc> intrados: so you should be able to do something like p <- predQ; case p of ...
14:19:31 <raphie> or the transformer
14:19:50 <roboguy_> raphie: actually, I think you need EitherT e IO
14:20:07 <hpc> intrados: there should also be some ability to operate directly on the Pred type without pattern matching, which you should use instead
14:20:09 <ParahSailin> @src EitherT mzero
14:20:09 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:20:23 <roboguy_> or, more specifically EitherT InterpreterError IO
14:20:34 <eazar001> roboguy_: sorry for the sidetrack but you're right "(Error e) =>" is in the instance
14:21:16 <roboguy_> eazar001: yeah, it's not possible to define mempty for Either without either a constraint on the instance or undefined (or something similar)
14:21:24 <hpc> intrados: i might be misunderstanding your question though, i don't TH very much
14:21:34 <c_wraith> roboguy_: I think that's correct
14:21:49 <Jeanne-Kamikaze> is there a (writeable) path where cabal will look for libraries ?
14:22:05 <c_wraith> Jeanne-Kamikaze: cabal uses ghc-pkg to look for libraries
14:22:17 <raphie> roboguy_: how would I integrate that into my code?
14:22:30 <S11001001> raphie: indeed, EitherT has the correct instance, though you must have Monoid InterpreterError to use it.
14:22:39 <hpc> to expand, ghc-pkg has a global database which is somewhere scary, and a user database in ~/.ghc
14:22:57 <S11001001> (EitherT being an ErrorT alternative with different choices, that may or may not be better for you.)
14:22:59 <c_wraith> Jeanne-Kamikaze: if you run "ghc-pkg list" at the command line, it'll tell you where your package databases are.  One of them should be user-local,
14:22:59 <Jeanne-Kamikaze> c_wraith, I mean static C libraries
14:23:00 <hpc> (%appdata%/ghc on windows)
14:23:12 <Jeanne-Kamikaze> oh
14:23:32 <c_wraith> Jeanne-Kamikaze: oh.  It just uses the system linker and whatever library names the cabal file lists
14:24:03 <intrados> hpc: Or perhaps I'm not understanding your question. I want to do something like `$predSplice => Foo -> Bar`, but you can't splice predQs directly, just typeQs
14:24:06 <c_wraith> Jeanne-Kamikaze: if your system linker will find libraries installed someplace user-local, then cabal will find them
14:24:09 <Jeanne-Kamikaze> would you know how to access a package's directory from a build hook ?
14:24:19 <hpc> intrados: oh, hmm
14:24:23 <Jeanne-Kamikaze> the problem is that I need to place the libraries somewhere where cabal will find them
14:24:23 <benmachine> raphie: what's the type of parsePrompt?
14:24:39 <raphie> well here's exactly what I want to do: I have an IO routine which spits back an Either. if it's a Left, print the error using this function (https://gist.github.com/RaphiePS/6c33ba714f2580d9578a) and keep trying the IO until you get a Right, then continue
14:24:42 <raphie> benmachine: lemme check
14:25:13 <c_wraith> Jeanne-Kamikaze: are you packaging the compiled libraries with it? If you're packaging C code instead of object files, you should just be able to tell cabal where the C sources are, and let it take care of the rest
14:25:20 <benmachine> raphie: can't you just do it... without magic
14:25:27 <benmachine> just with recursion and pattern matching
14:25:31 <Jeanne-Kamikaze> unfortunately it's not C code, but C++
14:25:32 <raphie> benmachine: parsePrompt :: Typeable a => a -> String -> (String -> String) -> IO (Either InterpreterError a)
14:25:48 <Jeanne-Kamikaze> c_wraith, I am compiling the C++ code with cmake using a custom Setup.hs
14:26:05 <c_wraith> Jeanne-Kamikaze: oh.  Then yeah, that's kinda ugly. There are lots of tools available at within Setup.hs, but I'm not too aware of what they are.
14:26:07 <eazar001> you don't need msum and repeat to do that
14:26:22 <eazar001> you can do that the "goon way"
14:26:27 <hpc> intrados: not seeing a way to do it the gross way and turn the Pred into a Type
14:26:28 <raphie> goon way?
14:26:36 <roboguy_> raphie: use hoistEither to make an Either into an EitherT and lift to turn an IO into an EitherT e IO
14:26:37 <eazar001> like ben said with recursion
14:26:41 <eazar001> using a conditional or something
14:26:54 <benmachine> monad transformers are often overkill
14:26:54 <hpc> top result for Pred -> Type on hoogle is unsafeCoerce :(
14:26:57 <eazar001> i'd have to look at your link
14:27:32 <hpc> this seems to be beyond me :(
14:28:02 <intrados> hpc: Hm. Thanks for the help
14:28:12 <roboguy_> raphie: something like: runEitherT yourEitherExpression >>= (putStrLn . report)
14:28:34 <eazar001> raphie: are you doing all this as some sort of practice excercise?
14:29:09 <benmachine> intrados: one way to do it would be to do something like $(predSplice [t| Foo -> Bar |])
14:29:27 <benmachine> predSplice being a TypeQ -> TypeQ that adds the context
14:29:32 <raphie> eazar001: writing a little command-line client to play with the runge-kutta algorithm. it requires you to input a tuple of starting coordinates, an integer for number of steps, and a function. if the user enters in an incorrectly-typed input, I'd like to give them more chances
14:30:04 <eazar001> i see
14:30:20 <c_wraith> raphie: so if they enter something that doesn't parse, you'd like to give them more chances.  Think of it as a parsing problem, not a typing problem
14:30:40 <benmachine> raphie: isn't what you want just this http://lpaste.net/98145
14:30:57 <benmachine> well actually no
14:31:05 <benmachine> you only want to loop in the error case
14:31:16 <raphie> yes
14:31:25 <raphie> it should move on to the next input once correct
14:31:49 <benmachine> ah, I see
14:31:50 <benmachine> sec
14:32:49 <intrados> raphie: foo in parse next = either (\x -> print x >> foo readLn parse next) next $ parse in
14:33:34 <eazar001> i mean im working on intution here but something like : unless isLeft $ do etc. etc
14:33:48 <eazar001> or is that an oversimplification of yoru idea?
14:33:56 <roboguy_> I would break it into separate functions for each input, each one looping until it's valid
14:34:06 <raphie> lemme try something and I'll let you guys know!
14:34:11 <intrados> raphie: That's obviously only an approximation but I have something like that working for me
14:34:16 * hackagebot vect-floating-accelerate 0.1.0.1 - Accelerate instances for vect-floating types  http://hackage.haskell.org/package/vect-floating-accelerate-0.1.0.1 (cdurham)
14:35:37 <benmachine> raphie: http://lpaste.net/98145 does this help
14:36:07 <raphie> benmachine: funny, I had basically the same thing in my own code :) yes
14:36:07 <benmachine> intrados: btw you can't call variables "in", it's a keyword
14:37:09 <bezirg> hi guys, so I am translating a kind-of-limited OO language to Haskell with source-to-source translation
14:37:11 * benmachine edits slightly
14:37:28 <eazar001> you might be able to simplify that with the import Control.Monad (unless)
14:37:46 <merijn> What's up with the new fad of calling things "source-to-source translation"? Don't we just call that "compiling" anymore nowadays?
14:37:59 <benmachine> eazar001: nah, there are no booleans here
14:38:09 <eazar001> isLeft?
14:38:20 <bezirg> this language allows expressions like `let y = this.x + 4 in ..`
14:38:24 <eazar001> that might be overkill with all the imports though
14:38:40 <benmachine> eazar001: pattern matching is usually better than is* functions
14:39:08 <eazar001> i've been warned of this many times before hehe
14:39:14 <eazar001> i suppose one day i shall learn my lesson
14:39:56 <bezirg> which is ok to overcome by translating it into this piece of Haskell code: `let y = (unsafePerformIO (readIORef x)) + 4`, since it is guaranteed by the language that object attrs can be accessed only by 1 thread at a time
14:40:07 <ReinH> @hackage monad-loops
14:40:07 <lambdabot> http://hackage.haskell.org/package/monad-loops
14:40:13 <ReinH> eazar001: ^ has some nice helpers
14:40:41 <benmachine> bezirg: unsafePerformIO is still scary without threads
14:40:42 <ReinH> None for Either though.
14:40:43 <merijn> bezirg: ಠ_ಠ ಠ_ಠ ಠ_ಠ
14:41:03 <merijn> bezirg: You do realise that due to laziness you have absolutely no idea when that code is actually executed, right?
14:41:10 <bezirg> merijn: that's look of disapproval or I cannot read your chars?
14:41:19 <ReinH> three of them
14:41:23 <ReinH> when is an understatement
14:41:23 <bezirg> merijn: what if I force it?
14:41:25 <quchen> That's an armada of disapproval.
14:41:31 <ReinH> bezirg: what if you couldn't use unsafePerformIO?
14:41:52 <merijn> bezirg: That was a look of disapproval, yes
14:42:00 <ReinH> s/when/which
14:42:00 <bezirg> ReinH: you r right, but it makes things easier for now
14:42:02 <benmachine> I don't have those characters either
14:42:09 <ReinH> bezirg: I don't think it does.
14:42:13 <merijn> benmachine: Get a better terminal font!
14:42:19 <ReinH> bezirg: I think it makes things *appear* easier while actually making them significantly harder.
14:42:28 <merijn> @quote Lemmih not.a.bug
14:42:29 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
14:42:36 <eazar001> ReinH: thanks
14:42:38 * flebron wonders if he could ask for style/idiom usage comments on his first package-to-be, at https://github.com/fedelebron/AVL
14:42:42 <quchen> It makes things easier just like alcohol makes break ups easier. Good for the moment, not so good when you realize you shouldn't have done it.
14:42:55 <ReinH> new quchen quote ^
14:42:55 <benmachine> bezirg hasn't finished their story yet, let's not jump on them too much yet
14:43:08 <merijn> flebron: FYI, r/haskell seems to get good responses for code reviews
14:43:12 <bezirg> well It gets even uglier later, so I am hesitated to even continue :D
14:43:14 <quchen> I have quotes?
14:43:22 <geekosaur> unsafePerformIO is a lie to the compiler. the compiler generally makes you pay for that lie, because it will make assumptions based on it that will break your code
14:43:24 <eazar001> quchen just triggered a million bad memories ]=
14:43:25 <flebron> merijn: Oh really? Cool, always wanted to do more than lurk there haha. Thanks :)
14:43:26 <merijn> flebron: I might look at it in a bit if I don't lose my interest before I get around to it :)
14:43:47 <merijn> flebron: Over the past months I've seen several in-depth critiques there, so
14:43:47 <quchen> eazar001: Yeah sorry, I hope you'll be able to forget about unsafePerformIO again soon!
14:44:16 <ReinH> bezirg: if I were you I would take advantage of the power Haskell gives you in building your own pure runtimes
14:44:22 <eazar001> quchen: me too quechen, i guess i'll have to "man" up
14:44:33 <eazar001> lol
14:44:34 <benmachine> person up
14:44:37 <quchen> Pure up, you mean
14:44:38 <ReinH> heh
14:44:44 <ReinH> pure pure
14:44:56 <eazar001> bot up
14:45:11 <roboguy_> bezirg: why do you need to use IORefs anyway?
14:45:30 <benmachine> geekosaur: unsafePerformIO is not always a lie
14:45:32 <bezirg> roboguy_: this are object attrs that change over time
14:45:40 <roboguy_> that implies to me that the value can change, which is exactly when you should avoid unsafePerformIO
14:45:46 <geekosaur> no, not always, but uses like that are
14:45:49 <merijn> bezirg: Why do you think that just because your original language has mutable objects you can't implement them purely?
14:45:55 <ReinH> Haskell's runtime is an excellent place to build imperative runtimes that are easy to reason about. It's a shame to waste that.
14:46:03 <merijn> bezirg: Additionally, why not just compile to IO code if you do mutation
14:46:27 <benmachine> compiling to IO sounds like the right thing to do with side-effectful code
14:47:01 <quchen> geekosaur: Making unsafePerformIO safe in that piece of code would be a challenge.
14:47:01 <ReinH> values that change over time aren't side-effects though, they are state.
14:47:45 <bezirg> guys u r right I may have to rethink about ti
14:47:46 <bezirg> it
14:49:48 <roboguy_> hey, what would you guys name a file that contains a module for basic miscellaneous stuff like Point, Speed and Dimensions for a small 2D game?
14:50:11 <ReinH> I've seen Foo.Bar.Types but I've never liked it
14:50:13 <flebron> Basic? Model?
14:50:16 <erisco> roboguy_, Math, Linear, Physics
14:50:24 <monochrom> I may call it Physics or Mechanics
14:50:30 <koala_man> utils/util2.hs
14:50:40 <S11001001> merijn: no, gotta be "transpiling", it's more modern.  compiling is for dragons
14:50:46 <monochrom> or Space
14:50:52 <ReinH> S11001001: trans-crosspiling
14:51:02 <flebron> lgbt-piling
14:51:06 <ReinH> hah
14:51:12 <erisco> flebron, we were thinking the same thing :P
14:51:27 <quchen> So we don't insult bipilers?
14:51:33 <monochrom> please don't use lgbt for jokes
14:52:25 <pantsman> let me nodesplain js transpiling to you
14:53:00 <ReinH> nodesplain is my new favorite term
14:53:24 <pantsman> ;D
14:54:18 * hackagebot bustle 0.4.3 - Draw pretty sequence diagrams of D-Bus traffic  http://hackage.haskell.org/package/bustle-0.4.3 (pwithnall)
14:54:30 <roboguy_> Physics works for me, thanks
14:57:49 <dibblego> http://lpaste.net/98149 How to write this with a type-family?
14:57:51 <hhhhhhhh> i need to implement parseJSON (aeson) manually for one of my types and i can convince myself the example they have on hackage is ok (parseJSON (Object v) = Coord <$> v .: "x" <*> v .: "y") but i am struggling to actually implement anything of my own
14:58:46 <hhhhhhhh> the code i have at the moment is http://lpaste.net/4013826807047389184
14:59:18 <monochrom> I know how to do "f -> g" alone or "g -> f" alone. I don't know how to do both at once
15:00:07 <epta> Why ByteString is not a Functor?
15:00:35 <shachaf> It would be a kind error.
15:00:50 <Cale> epta: ByteString doesn't take a type parameter
15:00:51 <dibblego> monochrom: I hit the same problem, cheers
15:01:10 <monochrom> hhhhhhhh: since op has type Text not String, pattern-matching against strings is not going to fly, despite OverloadedStrings. (OverloadedStrings does very little. very, very little.)
15:01:22 <dibblego> actually, how did you do, say f -> g ?
15:02:18 <monochrom> you should instead use "==", plus a lot of "if"s or guards
15:03:22 <shachaf> monochrom: OverloadedStrings allows pattern-matching against string literals.
15:03:26 <shachaf> It uses (==) and fromString.
15:03:41 <monochrom> oh! then I don't know what's wrong. looks right.
15:03:47 <shachaf> Oh, I'm wrong.
15:03:52 <monochrom> haha ok
15:03:54 <shachaf> I was almost sure I was right.
15:04:16 <shachaf> Oh, no, I was right.
15:04:19 * hackagebot vect-floating-accelerate 0.1.0.2 - Accelerate instances for vect-floating types  http://hackage.haskell.org/package/vect-floating-accelerate-0.1.0.2 (cdurham)
15:04:20 <shachaf> I just forgot to turn on OverloadedStrings.
15:04:21 * hackagebot sha-streams 0.1.0 - SHA hashes for io-streams.  http://hackage.haskell.org/package/sha-streams-0.1.0 (VoMinhThu)
15:05:05 <shachaf> Yes, it uses fromString and Eq.
15:05:06 <hhhhhhhh> yeah i am getting the same errors if i try to use ifs
15:05:39 <dibblego> you should instead use "==" [I started looking for some "f == g" fundeps syntax]
15:06:35 <hhhhhhhh> i annotated it with the errors i am getting
15:08:13 <hhhhhhhh> ok i fixed it
15:08:15 <hhhhhhhh> import Data.Text
15:08:17 <hhhhhhhh> :<
15:08:36 <Twey> dibblego: http://www.haskell.org/haskellwiki/Functional_dependencies_vs._type_families#Redundant_instance_arguments
15:08:47 <hhhhhhhh> and also "( op :: Text.Text ) <- v .: "op""
15:09:16 <dibblego> Twey: ah so it looks possible, thanks
15:10:53 <roboguy_> is there already something in lens like wrapLens :: Wrapped s s a a => Lens' s b -> Lens' a b
15:13:36 <Twey> dibblego: http://lpaste.net/98151
15:13:53 <dibblego> Twey: thanks I just finished too :)
15:14:21 * hackagebot purescript 0.2.4 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.4 (PhilFreeman)
15:14:36 <mekeor> i've got a cabal-project. i've got (amongst others) the files src/Console/Garepinoh/Elem.hs and src/Console/Garepinoh/Defaults.hs. Console.Garepinoh.Defaults imports Console.Garepinoh.Elem. this causes "Could not find module `Console.Garepinoh.Elem" when i type "ghci Defaults.hs". – why? – what the duck is going wrong?
15:15:25 <mekeor> something is going totally wrong here, imo..
15:15:37 <pavonia> mekeor: You're probably in the wrong directory
15:16:02 <Twey> mekeor: You need to be in the ‘src’ directory.
15:16:14 <mekeor> ooohhhh
15:16:37 <Twey> mekeor: Or you'll be looking for src/Console/Garepinoh/Console/Garepinoh/Elem.hs
15:16:45 <mekeor> i seee... okay. ah, okay. aah, oh, okay, i see. :) – so, i've gotta cd .../src and type "ghci Console/Garepinoh/Defaults.hs" :)
15:16:56 <mekeor> Twey: yeah :)
15:17:01 <mekeor> thanks guys :*
15:17:26 <mekeor> same in haskell-mode/emacs then, i guess?
15:18:13 <Twey> mekeor: GHCi has a :cd command you can use to change directory from within GHC; it might be possible to put that in a .ghci file or something in your project
15:19:06 <dibblego> Twey: what is the difference here? http://lpaste.net/98151
15:19:24 <mekeor> oh, i didn't know about .ghci-files. hm, but i guess their not that helpful...
15:19:49 <mekeor> anyways; next Q: – does hackage/hoogle have a new layout/design/style/look?
15:20:24 <Swineflu> I have a degree exam for my haskell class in a weeks time, I'm pretty sure i'll pass but im looking for exercises to do for practice
15:20:46 <dibblego> Swineflu: https://github.com/NICTA/course
15:21:07 <ricky_clarkson> Project Euler can be fun for that (assuming you won't be examined on things like IO).
15:21:20 <eazar001> I second project Euler
15:21:29 <eazar001> excellent resource for any language practice
15:21:37 <mekeor> Swineflu: if you are german, take a look at the haskell-course at our university ;) : https://www21.in.tum.de/teaching/info2/WS1314/uebungen.html
15:22:11 <monochrom> dibblego: you absolutely want at least "type F g", you have to write "g" there. it is the only way to say "this g refers to the g in 'D f g'". similarly for "type G f"
15:22:36 <aleksejs_> just found out that for 2nd problem on Project Euler it's possible to make generator that generates only even fibs
15:22:40 <wXeno> hi, any tip on any "cheat sheet" or formal specifications of the syntax of denotational and operational semantics (and other related notations)?
15:23:03 <monochrom> now, you do have a choice between "type F g", "type F g a", and "type F g a b". it affects the syntax when you write instances.
15:23:06 <aleksejs_> http://vpaste.net/hqDSO
15:23:29 <dibblego> monochrom: ok, I will figure that out by trying to write the instances, thanks
15:25:06 <monochrom> suppose you go with "type F g". then in an instance, you must write "instance D Pair Either where type F Either = Pair". you cannot write "type F Either a b = Pair a b"
15:25:25 <Twey> And we have no type-lambdas >.<
15:25:37 <monochrom> conversely, if you go with "type F g a b", then in an instance you must write "type F Either a b = Pair a b"
15:25:44 <Swineflu> mekeor: not german sadly ;(
15:25:47 <Swineflu> dibblego: thanks
15:27:16 <dibblego> http://lpaste.net/98151#line6 where ma I going wrong?
15:27:41 <monochrom> eh? circular logic?
15:28:15 <monochrom> why not simply "instance D FlipEither Either where ..."
15:28:34 <monochrom> why make the computer chase circles for you? :)
15:29:12 <monochrom> ho hum, your code means something else. but then I don't understand what it means. and so shouldn't the computer.
15:29:34 <monochrom> what is G Either?
15:29:48 <dibblego> I think I might have it
15:30:26 <dibblego> http://lpaste.net/98151#line6
15:31:31 <monochrom> what is FlipEither? why is "FlipEither e" a valid pattern? what is the type of e?
15:32:02 <dibblego> sorry I added it
15:34:06 <monochrom> no error here
15:34:20 <dibblego> yeah I think that is right
15:34:23 <dibblego> thanks heaps for the help
15:34:26 <monochrom> yeah ok
15:34:28 * hackagebot scp-streams 0.1.0 - An SCP protocol implementation.  http://hackage.haskell.org/package/scp-streams-0.1.0 (VoMinhThu)
15:34:31 <monochrom> you're welcome
15:40:43 <silasm> hello #haskell, finally working on a compression algorithm I've been meaning to make for a while. Is there a way to read a file Word8 by Word8 (as opposed to bytestring which reads Char by Char and then truncates to Word8)?
15:41:16 <jfischoff> @hoogle readFile
15:41:17 <lambdabot> Prelude readFile :: FilePath -> IO String
15:41:17 <lambdabot> System.IO readFile :: FilePath -> IO String
15:41:17 <lambdabot> Data.ByteString.Lazy.Char8 readFile :: FilePath -> IO ByteString
15:41:26 <jfischoff> heh
15:41:43 <jfischoff> silasm: yes Data.ByteString.readFile and the lazy one do that
15:41:58 <silasm> well see that's the issue. I want ByteString performance but doesn't that truncate UTF-8?
15:42:28 <silasm> as in UTF-8 that isn't basically Ascii anyways
15:42:34 <Twey> silasm: No
15:42:49 <jfischoff> ByteString knows nothing about UTF-8
15:42:52 <roboguy_> silasm: I would think that Data.ByteString.Lazy.Char8 would read it in one 8-bit byte at a time
15:43:13 <Twey> silasm: There are different ByteString modules for different encodings; the .Char8 modules will read an octet at a time and give you a ByteString containing those octets
15:43:21 <silasm> > Data.ByteString.Char8.unpack . Data.ByteString.Char8.pack $ "合気道"
15:43:22 <lambdabot>  Not in scope: `Data.ByteString.Char8.unpack'Not in scope: `Data.ByteString.C...
15:43:30 <silasm> :|
15:43:46 <silasm> anyways that shows truncation when I put it in ghci; how is readFile different?
15:44:08 <Twey> silasm: That's from a String, that's already in Unicode
15:44:15 <silasm> Twey: ohh
15:44:17 <Twey> readFile will never go through Char
15:44:36 <silasm> kk, wish I'd asked this when I was working on my lz78; would have saved a lot of headache :S
15:44:50 <Twey> Char in Haskell represents a Unicode codepoint, but ByteString is encoding-agnostic: it just cares about bytes
15:44:59 <silasm> neat
15:46:05 <silasm> thanks a bunch
15:46:21 <raphie> the Runge-Kutta program I was working on is finally done! thanks to all of you that helped. this is the code: https://gist.github.com/RaphiePS/192802b4d3e53bb4b125
15:47:31 <merijn> silasm: Also, mostly you don't want String for textual data, but Text (which is densely packed, decoded unicode). It's similar to ByteString in terms of memory and performance (but obviously properly unicode aware)
15:48:15 <silasm> merijn: yeah I used Text for lz78, but when I tried to output into unicode that had weird implications for compression, lol.
15:48:20 <merijn> silasm: String can on some architectures take 20+ bytes per codepoint, Text is more like 2-3 per codepoint and maybe some overhead every kilobyte
15:48:44 <Hodapp> U T F - 1 6 ! W O O !
15:48:50 <silasm> awesome, I'd always thought it was just String array-ified
15:49:07 <merijn> silasm: No, Text is *a lot* more efficient than String
15:49:28 <benmachine> in fairness, String array-ified would be a lot more efficient than String
15:49:35 <merijn> silasm: I've seen beginners here shrink memory usage from >2Gb to 200 mb just by replacing String with Text
15:49:43 <benmachine> Text is more efficient even than that but the arrayification is probably most of the saving
15:49:56 <jfischoff> Text also correctly performs toUpper
15:50:10 <merijn> Hodapp: to be fair, there is a utf-8 Text implementation that was made for Google Summer of Code, but it performed significantly worse in most benchmarks
15:50:21 <jfischoff> or something like that, the unicode edge cases I know very little of
15:50:24 <benmachine> merijn: oh, I thought it was pretty similar
15:50:41 <benmachine> jfischoff: yeah, because toUpper :: Char -> Char is a lie
15:50:43 <merijn> silasm, jfischoff: In fact, Text will even properly expand lowercase ligatures (like the one character ffl symbol) into 3 separate uppercase letters
15:50:56 <benmachine> maddeningly, some strings change length when you upcase them ._.
15:51:04 <jfischoff> right
15:52:01 <silasm> merijn: just to be clear though, for something like compression I would want ByteString, right? My limited experience with Text tells me that's the case, but someone here might know it better.
15:52:33 <jfischoff> if you want bytes you want ByteString
15:52:37 <roboguy_> is there a way to see the arguments that cabal is giving to ghc?
15:52:46 <roboguy_> sort of like you can with a makefile?
15:52:48 <jfischoff> perhaps Vector
15:52:52 <merijn> silasm: Maybe, I'm not sure
15:52:57 <silasm> Text is more for if you actually care about the string vs. the raw data if I understand correctly, right?
15:53:23 <merijn> > Data.Text.toUpper (Data.Text.pack "ﬄ")
15:53:24 <jfischoff> roboguy_: probably -v3 will show them and a bunch of other crap
15:53:24 <lambdabot>  Not in scope: `Data.Text.toUpper'
15:53:24 <lambdabot>  Perhaps you meant `Data.Char.toUpper' (imported from Data.Char)Not in scope:...
15:53:32 <benmachine> silasm: that really depends on what your compression algorithm is
15:53:52 <benmachine> silasm: many compression algorithms work on bytes but in principle they could work on any kind of data
15:54:03 <silasm> jfischoff: still haven't messed with Vector. I want to make a parallel lz77 (hopefully with some of the extra stuff gzip does).
15:54:04 <benmachine> well, different algorithms can work on different kinds of data
15:54:13 <merijn> > T.toUpper (T.pack "ﬄ")
15:54:14 <lambdabot>  Not in scope: `T.toUpper'Not in scope: `T.pack'
15:54:14 <lambdabot>  Perhaps you meant `BS.pack' (imported from Data.ByteString)
15:54:16 <merijn> aww
15:54:50 <merijn> Not sure why that doesn't work
15:54:56 <lispy> > BS.pack "ﬄ"
15:54:58 <lambdabot>  Couldn't match type `GHC.Types.Char' with `GHC.Word.Word8'
15:54:58 <lambdabot>  Expected type: [GHC.Word.Word8]
15:54:58 <lambdabot>    Actual type: [GHC.Types.Char]
15:55:01 <merijn> At least it works correctly in GHCI
15:56:43 <jfischoff> > BSC.pack "just guessing"
15:56:45 <lambdabot>  "just guessing"
15:56:51 <jfischoff> \o/
15:58:08 <monochrom> > BSC.pack "\3bb"
15:58:09 <lambdabot>  "\ETXbb"
15:58:16 <monochrom> oh!
15:58:18 <monochrom> > BSC.pack "\x3bb"
15:58:19 <lambdabot>  "\187"
15:59:08 <Twey> > Data.Text.pack "h"
15:59:09 <lambdabot>  Not in scope: `Data.Text.pack'
15:59:20 <Twey> Does λb not have Data.Text at all?
15:59:51 <geekosaur> :t T.pack
15:59:52 <lambdabot> Couldn't find qualified module.
15:59:55 <geekosaur> bah
15:59:58 <monochrom> it may have, but under an unknown name
16:00:18 <monochrom> there is no algorithm mapping official module names to lambdabot names
16:00:52 <Twey> Ha
16:01:13 <jfischoff> :t Text.pack
16:01:14 <lambdabot> Couldn't find qualified module.
16:01:24 <merijn> :t Data.Text.pack
16:01:24 <lambdabot> String -> Data.Text.Internal.Text
16:01:25 <jfischoff> 1 for 2
16:01:27 <monochrom> the mapping is a State Secret
16:01:28 <merijn> It does
16:01:35 <roboguy_> how do you convince cabal to give a flag to the linker? ld-options doesn't seem to be doing it for me
16:01:45 <roboguy_> I'm trying to link against SDL
16:02:08 <monochrom> extra-libs may be relevant. or is it called extra-libraries?
16:02:18 <dcoutts_> roboguy_: ld-options does work. What are you trying to do exactly.
16:02:20 <|TheWolf|> hi again
16:02:33 <benmachine> @let import qualified Data.Text as T
16:02:34 <lambdabot>  .L.hs:104:1:
16:02:34 <lambdabot>      Data.Text: Can't be safely imported!
16:02:34 <lambdabot>      The package (text-0.11.3.1) the module resides in isn't trusted.
16:02:36 <monochrom> anyway read the cabal user guide fully, http://www.haskell.org/cabal/users-guide/developing-packages.html
16:02:37 <benmachine> :(
16:02:52 <benmachine> > "has that broken everything"
16:02:53 <beardtree> Is it just me or does Cabal suck?
16:02:53 <lambdabot>  "has that broken everything"
16:02:56 <benmachine> oh good
16:02:59 <roboguy_> dcoutts_: I'm trying to use SDL, but I'm getting linker errors. if I was using C or C++, I would put `sdl-config --libs` in the linker flags
16:03:05 <benmachine> beardtree: only insofar as everything does
16:03:05 <monochrom> it is just you
16:03:06 <merijn> beardtree: In what way? I find it pretty awesome
16:03:16 <beardtree> Well you can't uninstall stuff
16:03:22 <merijn> beardtree: People who think cabal sucks haven't used dependency solver in other languages
16:03:23 <|TheWolf|> maybe you can help me out again. I got http://pastebin.com/9D0RG3RN to finally work with some help from google, but I have no idea why I need to specify the type of the first argument (Branch a), but not of the following (Tree left Tree right)...?!
16:03:24 <roboguy_> beardtree: you sort of can with ghc-pkg
16:03:25 <mauke> The paste 9D0RG3RN has been copied to http://lpaste.net/98159
16:03:29 <merijn> beardtree: cabal isn't a package manager
16:03:47 <dcoutts_> roboguy_: you can do that in a Setup.hs script
16:03:53 <monochrom> well, I wouldn't deal out judgments of "sucks" so easily
16:03:55 <beardtree> merijn: what is it?
16:04:22 <merijn> beardtree: A dependency solver/build system
16:04:28 <dcoutts_> roboguy_: or if sdl supports pkg-config these days then there's direct support and you don't need to write any code
16:04:33 <jfischoff> beardtree: ghc-pkg unregister PACKAGE_NAME
16:04:43 <beardtree> jfischoff: nice thanks
16:04:49 <monochrom> it is not like I am Beavis and Butthead who say "____ sucks" like it's a tautology
16:05:03 <merijn> dcoutts_: I'm interested in adding a manual documentation uploading command to cabal, like https://gist.github.com/Fuuzetsu/8276421
16:05:06 <jfischoff> beardtree: listen to the warnings, don't just force
16:05:06 <dcoutts_> roboguy_: but that's the right instinct and that will work
16:05:27 <merijn> dcoutts_: I'm unsure what module commands should go in or where to start exploring the cabal code, though
16:05:29 <beardtree> jfischoff: right on
16:05:32 <roboguy_> dcoutts_: where's the documentation on Setup.hs scripts?
16:06:47 <dcoutts_> roboguy_: Cabal package API docs. The Distribution.Simple module
16:07:02 <merijn> |TheWolf|: Are you referring to only have a single line "preorder :: Tree a -> [a]"?
16:07:31 <dcoutts_> roboguy_: but simplest is usually to look at an existing package that does something similar. In your case that'd be one of the db libs that have to call pg-config --cflags --libs
16:07:47 <dcoutts_> or indeed one of the SDL packages
16:07:53 <dcoutts_> I presume they must do that
16:07:59 <|TheWolf|> merijn : rather to the last line "(Branch a left right)" - why do I need to specify Branch but not Tree?
16:08:01 <Fuuzetsu> merijn: https://gist.github.com/stbuehler/7068764 is probably the better script to base it on
16:08:12 <merijn> Fuuzetsu: Yeah, I saw that too
16:08:19 <roboguy_> dcoutts_: I'm looking at a small game I found, but the Setup.lhs file is just main = defaultMain and it seems to work...
16:08:25 <roboguy_> (and it uses SDL)
16:08:30 <merijn> Fuuzetsu: I was more unsure where to start in the cabal code
16:08:35 <merijn> |TheWolf|: Ah
16:08:45 <Fuuzetsu> No idea~
16:09:08 <roboguy_> |TheWolf|: Branch is the data constructor and Tree a is the type
16:09:12 <merijn> |TheWolf|: "data Tree a = Leaf a | Branch a (Tree a) (Tree a)", this defines a datatype tree and two constructors (Leaf and Branch)
16:09:20 <dcoutts_> roboguy_: wait, are you just using sdl or hacking on an sdl binding lib?
16:09:29 <roboguy_> dcoutts_: I'm just using sdl
16:09:32 <roboguy_> with the SDL package
16:09:36 <merijn> |TheWolf|: The types after said constructors specify 1) how many arguments each constructor takes and 2) what types those arguments have
16:09:40 <dcoutts_> roboguy_: but it fails to build?
16:10:03 <roboguy_> dcoutts_: yeah, it says "/Users/davidyoung/.cabal/lib/x86_64-osx-ghc-7.6.3/SDL-0.6.5/libHSSDL-0.6.5.a: unknown symbol `_SDL_JoystickGetBall'"
16:10:21 <roboguy_> that's actually the only error too, which is weird. I'm not even using SDL in the code yet, other than importing it
16:10:27 <merijn> |TheWolf|: When you define preorder you are pattern matching (i.e. matching on constructors), you need to include the constructor so GHC can see which constructor you are matching and whether you are matching the right number of arguments
16:10:49 <merijn> |TheWolf|: You don't need to specify a type as you've already told GHC which types the arguments have inside your datatype definition
16:10:58 <geekosaur> do you have the C SDL libraries installed?
16:10:59 <merijn> |TheWolf|: So writing them down again is pointless.
16:11:17 <roboguy_> geekosaur: yeah. In fact, I can get another Haskell SDL game to build just fine
16:11:25 <geekosaur> odd
16:11:31 <|TheWolf|> merijn : hmm ok...I'll try to wrap my head around it. Thanks so far!
16:11:41 <merijn> |TheWolf|: In a pattern match you're allowed to either match a constructor directly (like Leaf and Branch) or assign the value to a variable (what you are doing with "preorder (Leaf a) = [a]"
16:11:52 <dcoutts_> roboguy_: so the SDL package is already using sdl-config to work out the cc & ld flags
16:11:55 <dcoutts_> see http://hackage.haskell.org/package/SDL/src/configure.ac
16:12:23 <merijn> |TheWolf|: Your saying "I want to match the Leaf constructor and assign the name 'a' to whatever it had as argument", which then lets you use the 'a' name to refer to the argument of the Leaf constructor
16:12:28 <|TheWolf|> merijn : ok, so 'preorder Leaf = []' would be valid, too?
16:12:39 <roboguy_> dcoutts_: that makes sense. it doesn't make sense that this isn't linking properly though...
16:12:45 <merijn> |TheWolf|: No, that would complain you're not matching all fields of "Leaf"
16:12:57 <dcoutts_> roboguy_: right
16:13:11 <jayferd> |TheWolf|: your 'Leaf' always contains something
16:13:14 <|TheWolf|> merijn : ok, so how would I match a constructor directly?
16:13:21 <jayferd> if you want to ignore it, you need to use an _
16:13:24 <dcoutts_> roboguy_: you can see what linker flags ghc will use when you use the SDL package
16:13:28 <merijn> |TheWolf|: But keep in mind that in the datatype declaration (line 1) the 'a' in "Leaf a" is a *type*, in the pattern match (line 7) 'a' is a variable name
16:13:35 <dcoutts_> roboguy_: use ghc-pkg describe SDL and look for the ld options
16:13:41 <jayferd> |TheWolf|: generally, you don't
16:13:51 <merijn> |TheWolf|: You can use _ to throwaway a fields value i.e. "preorder (Leaf _) = []"
16:13:54 <|TheWolf|> merijn : yeah, it took me some time, but I understood that some while ago ;)
16:14:03 <roboguy_> dcoutts_: one thing I noticed is that the game that works has "--framework SDL" when I do cabal -v3 build but mine doesn't have anything like that
16:14:04 <|TheWolf|> jayferd : ok ;)
16:14:06 <dcoutts_> merijn: mm
16:14:11 <merijn> |TheWolf|: There's a record syntax trick for matching constructor regardless of the number of fields
16:14:13 <jayferd> unless what you're asking is
16:14:21 <jayferd> how to bind the whole structure to a variable
16:14:24 <merijn> |TheWolf|: "preorder (Leaf {}) = []"
16:14:25 <jayferd> in which case you can use @
16:14:48 <jayferd> preorder theLeaf@(Leaf _) = ...
16:14:57 <roboguy_> dcoutts_: in fact, it has lots of linker options and mine doesn't really have very many
16:14:57 <merijn> |TheWolf|: {} is record syntax (which I'm not gonna bother trying to explain right now), but it'll let you match any number of fields
16:15:09 <merijn> |TheWolf|: Although obviously you can't then use said fields
16:15:32 <|TheWolf|> roboguy_ : jayferd : wow, now it's getting tricky ;-)
16:15:53 <roboguy_> dcoutts_: oh wait, that's not exactly the flag but it does look like it links with sdl in a way mine doesn't
16:16:18 <dcoutts_> roboguy_: and see what your sdl-config --libs reports
16:16:40 <dcoutts_> roboguy_: and note that the SDL package's configure.ac does some extra stuff for Darwin
16:17:31 <|TheWolf|> merijn : jayferd : : thanks a lot!
16:17:41 <roboguy_> dcoutts_: hmm the ghc-pkg describe SDL flags and sdl-config --libs seem similar. ghc-pkg has the full path, but it should be the exact same
16:17:44 <jayferd> :)
16:18:36 <roboguy_> dcoutts_: I notice the working game has a file with a ton of options in it called "setup-config", which has a comment that implies it was created by cabal
16:19:07 <dcoutts_> roboguy_: that file is just the saved info created by cabal configure
16:19:22 <dcoutts_> ignore it
16:19:23 <roboguy_> ah
16:20:25 <roboguy_> dcoutts_: the other weird thing is that if I just do ghc Main, it compiles and links fine
16:20:47 <dcoutts_> vs what?
16:21:32 <roboguy_> dcoutts_: vs cabal configure; cabal build
16:22:42 <dcoutts_> roboguy_: using different version/instance of SDL package? got more than one?
16:23:09 <roboguy_> dcoutts_: nope, just the one
16:25:02 <dcoutts_> roboguy_: if you want to look into the details you can see how ghc is being called, or how ghc is calling gcc to link
16:25:11 <dcoutts_> with -v3 for cabal, or -v for ghc
16:27:09 <roboguy_> dcoutts_: it appears to be linking with my C linker and not giving it the SDL flags. I think when I did the same for the other game, it was also linking with the C linker but giving it the appropriate SDL library options
16:27:59 <roboguy_> dcoutts_: this is what it's doing for my project: '/usr/bin/ghc-clang-wrapper' '-m64' '-fno-stack-protector' '-m64' '-L/usr/local/Cellar/ghc/7.6.3/lib/ghc-7.6.3/base-4.6.0.1' '--print-file-name' 'libiconv.dylib'
16:31:21 <dcoutts_> roboguy_: you'd need to paste the whole thing, probably use a pastebin of some sort
16:32:35 <pavonia> In cabal, how do you process a file using an external tool and link the resulting .o file into the executable being built?
16:33:30 <c_wraith> pavonia: you're the second person to ask that today.  huh.
16:33:59 <pavonia> I've asked that question earlier
16:34:14 <dcoutts_> pavonia: you'd have to write custom code in the Setup.hs
16:34:19 <c_wraith> Oh, was that you?  My memory's slipping at this ancient age.
16:34:23 <dcoutts_> there's no direct support
16:35:46 <pavonia> dcoutts_: Do you have a simple example? Executing the tool seems easy but how do I link the object file in?
16:36:20 <dcoutts_> pavonia: no, I don't have any example. I'm not aware of any package that does that.
16:37:03 <roboguy_> dcoutts_: hmm, it looks related to template haskell
16:37:09 <dcoutts_> pavonia: if it can go via C then that might be easier
16:37:46 <pavonia> No, it's processing of an .rc file via windres
16:38:47 <roboguy_> dcoutts_: this looks like it's causing the problem, strangely http://lpaste.net/98161
16:38:59 <roboguy_> if I comment out some of the template haskell stuff, then it looks like it works
16:40:51 <dcoutts_> roboguy_: oooh, try this: ghci -package SDL
16:40:58 <dcoutts_> does that load ok or fail in the same way?
16:41:07 <roboguy_> dcoutts_: fails with the same error
16:41:38 <dcoutts_> so the problem is that when Cabal calls ghc to compile, it tells it all the packages to use, and ghc pre-emptively loads them if it has to do any TH stuff at all
16:41:48 <dcoutts_> so it tries to load SDL
16:41:51 <dcoutts_> and that fails
16:42:20 <dcoutts_> where as when you compile Main directly, ghc figures out the packages it needs on its own and only loads those ones when it does the TH stuff
16:42:27 <dcoutts_> and so avoids loading SDL
16:42:57 <dcoutts_> so one way to fix it is to fix ghci loading of the SDL package
16:43:58 <roboguy_> dcoutts_: how would I do that?
16:44:49 <dcoutts_> roboguy_: depends what's going wrong exactly. Google might help
16:45:05 <dleedev> where can I read up on Alternatives?
16:45:10 <dcoutts_> other workaround of course is not using TH here
16:45:34 <dleedev> I just found some code that uses <|>, and I saw that they belong to Alternative, but I don't know much more about Alternatives
16:45:36 <erisco> dleedev, http://www.haskell.org/haskellwiki/Typeclassopedia
16:45:37 <dcoutts_> roboguy_: using dynamic libs for your Haskell packages may also work here
16:45:43 <roboguy_> dcoutts_: there doesn't seem to be anything for that specific error. think reinstalling SDL could help?
16:46:28 <dcoutts_> roboguy_: plausible. Got the detail of the link error?
16:47:02 <erisco> dleedev, section 9.4
16:47:13 <dleedev> erisco: just found it, thanks
16:47:24 <roboguy_> dcoutts_: these are the important lines (line 1) lookupSymbol failed in relocateSection (relocate external)      (line 2) /Users/davidyoung/.cabal/lib/x86_64-osx-ghc-7.6.3/SDL-0.6.5/libHSSDL-0.6.5.a: unknown symbol `_SDL_JoystickGetBall'
16:47:48 <roboguy_> when I do :m +Graphics.UI.SDL it seems to be okay
16:48:32 <dcoutts_> roboguy_: and can you paste the content of ghc-pkg describe SDL
16:48:46 * dcoutts_ suspects something
16:49:13 <roboguy_> dcoutts_: http://lpaste.net/98163
16:49:54 <jayferd> is there a common cause of ld failures when installing cabal packages?
16:50:06 <dcoutts_> roboguy_: ok so the problem is with the way the SDL package puts the info from sdl-config info the package description
16:50:10 <roboguy_> dleedev: the basic Alternative laws are basically just the monoid laws
16:50:20 <jayferd> i'm using cabal 1.16.0 and i'm unable to upgrade
16:50:20 <dcoutts_> roboguy_: it's stuffing it all into ld-options, and not using extra-libraries
16:50:32 <Fuuzetsu> jayferd: Missing modules in the cabal file; all used modules have to be listed somewhere, either exposed-modules or other-modules
16:50:35 <dleedev> so are alternatives basically applicatives whose values are monoids?
16:51:01 <jayferd> hm, so you're saying cabal has missing modules in its own cabal file?
16:51:05 <roboguy_> dleedev: I'm not sure what you mean. (<|>) and empty form a monoid
16:51:07 <jayferd> i can't install cabal-install
16:51:11 <dcoutts_> roboguy_: when ghci loads packages it is not using the system linker and so does not use the ld-options, but it does load the extra-libraries
16:51:15 <jayferd> lemme gist it real quick
16:51:19 <roboguy_> dcoutts_: hmm, so should I edit the cabal file for the SDL package?
16:51:22 <roboguy_> and reinstall?
16:51:28 <Fuuzetsu> jayferd: not really, that was just a guess, seems to happen to me when I forget things
16:51:50 <dcoutts_> roboguy_: a quick hack would be to edit the ghc-pkg registration for SDL, then the proper fix would be to fix the SDL package to do the right thing
16:52:25 <roboguy_> dcoutts_: how do I edit the ghc-pkg registration?
16:52:25 <dcoutts_> roboguy_: instead of using ld-options: /usr/local/lib/libSDLmain.a /usr/local/lib/libSDL.dylib "-Wl,-framework,Cocoa" it should probably be doing...
16:52:38 <jayferd> https://gist.github.com/jayferd/bf5a518c99501c1d7827
16:52:51 <dcoutts_> roboguy_: ghc-pkg describe SDL > sdl.pkg; ....; ghc-pkg update < sdl.pkg
16:52:52 <jayferd> and i just nuked my whole cabal setup
16:53:07 <jfischoff> when I `cabal update` I get Downloading the latest package list from hackage.haskell.org
16:53:08 <jfischoff> cabal: invalid argument
16:53:16 <jfischoff> any ideas?
16:53:58 <dcoutts_> roboguy_: extra-libraries: SDL; frameworks: AppKit Cocoa
16:54:01 <jayferd> oh yeah, and my cabal update exited normally
16:54:27 <dleedev> are alternatives applicatives where the composition <*> is associative?
16:54:28 <dcoutts_> roboguy_: actually may want to keep /usr/local/lib/libSDLmain.a in the ld-options as that probably only makes sense for exes, not other cases
16:54:59 <jayferd> Fuuzetsu: i would think Distribution.Version would be in the dependencies for cabal-install
16:55:07 <jayferd> but it seems not to want to install dependencies in general
16:55:29 <jayferd> i get similar errors on other packages that have dependencies
16:55:30 <jfischoff> dleedev: no. The are applicatives that can be combined together moniodially
16:55:32 <roboguy_> dcoutts_: when I do ghc-pkg update, I don't need to give it any more arguments? just pipe in the sdl.pkg file?
16:55:32 <Fuuzetsu> jayferd: dcoutts_ is the guy to pester about cabal
16:55:37 <monochrom> jfischoff: does it look like https://github.com/haskell/cabal/issues/650 ?
16:55:42 <randomclown> how do I convert a strict bytestring to a lazy one?
16:55:54 <dleedev> jfischoff: what's a popular example of alternatives?
16:55:54 <Fuuzetsu> randomclown: fromStrict IIRC
16:55:59 <jayferd> kk
16:56:17 <jfischoff> dleedev: Parsec's parsing monad
16:56:25 <monochrom> Maybe is an Alternative. and MonadPlus. and Monoid.
16:56:27 <roboguy_> dleedev: Maybe is always a popular one
16:56:34 <roboguy_> > Just 1 <|> Just 2
16:56:35 <lambdabot>  Just 1
16:56:35 <monochrom> see how popular it is :)
16:56:37 <jfischoff> yeah maybe
16:56:38 <dcoutts_> jayferd: looks like you deleted the files for the Cabal package but that it's still registered
16:56:39 <roboguy_> > Nothing <|> Just 2
16:56:40 <lambdabot>  Just 2
16:56:55 <dleedev> dleedev: The problem with Maybe is that it's also a Monad and a bunch of other stuff
16:56:59 <randomclown> Fuuzetsu: where is it declared?
16:57:04 <dleedev> monochrom: ^
16:57:05 <roboguy_> dleedev: why's that a problem?
16:57:18 <monochrom> [] is also an Alternative. and MonadPlus. and Monoid
16:57:21 <dcoutts_> jayferd: that's why it says "There are files missing in the `Cabal-1.18.1.2' package". Probably because you deleted them all.
16:57:21 <randomclown> Fuuzetsu: found it
16:57:23 <dleedev> monochrom: it's hard to gain an intuition for just what about Maybe makes it an Alternative
16:57:25 <jayferd> ah
16:57:26 <monochrom> and Traversable. etc etc
16:57:29 <Fuuzetsu> randomclown: http://www.haskell.org/hoogle/?hoogle=fromStrict
16:57:31 <jayferd> where is that configuration stored?
16:57:38 <dcoutts_> jayferd: with ghc-pkg
16:57:42 <dleedev> monochrom: basically, I can't distinguish which behavior of Maybe is Alternative-specific
16:57:48 <dcoutts_> see ghc-pkg list and/or ghc-pkg check
16:57:55 <jayferd> got it
16:58:04 <roboguy_> dcoutts_: the ghc-pkg update thing doesn't seem to be working
16:58:04 <jfischoff> monochrom: not sure. Not on windows haven't changed my user name
16:58:19 <monochrom> jayferd, perhaps it's time you read my http://www.vex.net/~trebla/haskell/sicp.xhtml
16:58:22 <dleedev> monochrom: and in trying to understand Alternative from Maybe, I might starting thinking Monads are Alternatives, or MonadPluses are Alternatives, because Maybe is all of those
16:58:26 <roboguy_> dleedev: well, it's Alternative specific when it uses only the methods from Alternative
16:58:31 <dcoutts_> roboguy_: oh may have to give it the file name rather than stdin
16:58:37 <monochrom> jfischoff: I see, then it's something else
16:58:57 <roboguy_> dleedev: an Alternative is required to Applicative because of "class Applicative f => Alternative f where ..." but ignore the other stuff like Monads for now
16:59:01 <jfischoff> dleedev: do you understand Monoid?
16:59:08 <dleedev> jfischoff: yes
16:59:09 <monochrom> dleedev: I propose that there is no answer to your question, it's unanswerable.
17:00:03 <roboguy_> dcoutts_: I gave it the file, but when I describe it it looks like it appended the old one with the new oen
17:00:05 <roboguy_> *one
17:00:06 <jfischoff> dleedev: do you see how <|> and empty and like mappend and mempty?
17:00:11 <dleedev> monochrom: this question ?"what's a popular example of alternatives?"
17:00:22 <dleedev> jfischoff: I see that
17:00:44 <monochrom> no, the question "which behaviour of Maybe is Alternative-specific"
17:01:08 <dcoutts_> roboguy_: oh, was the old one registered globally?
17:01:17 <roboguy_> dcoutts_: I'm not sure what you mean
17:01:28 <dleedev> monochrom: are there examples where something is an Alternative, but not a Monad?
17:01:29 <roboguy_> oh, you mean as opposed to using a sandbox? yeah
17:01:41 <roboguy_> I've never really used the cabal-dev sandbox thing
17:01:42 <dcoutts_> roboguy_: e.g. in the global package db rather than user, see ghc-pkg list SDL, it'll say
17:02:16 <roboguy_> dcoutts_: that lists two
17:02:21 <monochrom> yes, some parsers are Alternatives and non-Monads. I'm too lazy to name one now.
17:02:33 <erisco> my parser is an Alternative and not a Monad :)
17:02:45 <erisco> dleedev, are you familiar with the Monoid laws?
17:02:50 <JackDowland> hi Haskellers
17:02:50 <dleedev> erisco: yes
17:02:56 <JackDowland> is that the correct term?
17:02:58 <dwcook> erisco, what languages does it parse?
17:03:02 <dcoutts_> roboguy_: ok, delete the extra one, we want to re-register in the same DB as the original or it'll all go squiffy
17:03:14 <erisco> dleedev, mkay so what is your question about Alternative? it has the same laws
17:03:20 <dleedev> erisco: I guess I understand that alternatives are monoids, in the sense that alternatives follow the laws of monoids
17:03:30 <erisco> that is the only sense
17:03:45 <roboguy_> dcoutts_: how do I delete that? they have the same version number
17:04:03 <dcoutts_> roboguy_: select the right db, --user or --global
17:04:36 <jrmithdobbs> :r
17:04:37 <roboguy_> dcoutts_: so I want to delete the global one?
17:04:41 <erisco> dleedev, the only difference between the Monoid type class and the Alternative type class is that Alternative instances must also follow Applicative laws, and Functor laws
17:04:57 <dcoutts_> roboguy_: no, that was almost certainly the original one
17:04:58 <dleedev> erisco: I guess I just don't see how that could be
17:04:59 <jrmithdobbs> wrong window ;p
17:05:10 <dcoutts_> roboguy_: no, you want to delete the user one and then re-register the global one
17:05:17 <erisco> dleedev, how what could be?
17:05:24 <jayferd> there we go, got it, thanks dcoutts_
17:05:24 <monochrom> beware of this bug: https://ghc.haskell.org/trac/ghc/ticket/5442
17:05:30 <dleedev> erisco: how an applicative can `mappend` to itself
17:05:37 <dcoutts_> roboguy_: e.g. ghc-pkg unregister --user SDL; sudo ghc-pkg update --global sdl.pkg
17:05:39 <dleedev> erisco: that's why I think an example would help
17:05:41 <erisco> dleedev, an Applicative does not mappend to itself
17:05:47 <monochrom> it means that for example "ghc-pkg unregister --user" is not idempotent
17:06:26 <erisco> dleedev, mappend is a function from Monoid, and the dual in Alternative is <|>. Applicatives are not necessarily monoids. Alternatives are.
17:07:02 <dleedev> erisco: an Alternative is an Applicative that can <|> itself, where <|> is conceptually the same as mappend, right?
17:07:31 <erisco> dleedev, yes
17:07:52 <roboguy_> dcoutts_: hey it works. wow, thanks!
17:07:57 <dleedev> erisco: from all Applicatives, there are certain Applicatives that can be "mappend"ed, and we designate those as Alternatives
17:08:08 <roboguy_> maybe I should submit a bug report
17:08:12 <dleedev> erisco: (with an additional empty, of course)
17:08:14 <dcoutts_> roboguy_: yes
17:08:35 <dcoutts_> roboguy_: so the SDL could do this right if it used Setup.hs and used this handy helper... (lemme find it)
17:08:37 <dleedev> erisco: I just don't see how there can be an Applicative that can be "mappend"ed
17:08:53 <erisco> dleedev, did you understand the Maybe example?
17:09:02 <monochrom> or []
17:09:12 <dleedev> erisco: no, is there a write-up about Maybe being an Alternative?
17:09:19 <dcoutts_> roboguy_: http://hackage.haskell.org/package/Cabal-1.18.1.2/docs/Distribution-Simple-Configure.html#v:ccLdOptionsBuildInfo
17:09:26 <roboguy_> dleedev: it might help if you stop thinking of it as "an Applicative" and start thinking of it as "something that is an instance of the Applicative type class"
17:09:39 * hackagebot cipher-aes128 0.6.1 - AES and common modes using AES-NI when available.  http://hackage.haskell.org/package/cipher-aes128-0.6.1 (ThomasDuBuisson)
17:09:41 * hackagebot commsec 0.3.4 - Provide communications security using symmetric ephemeral keys  http://hackage.haskell.org/package/commsec-0.3.4 (ThomasDuBuisson)
17:10:01 <dleedev> roboguy_: those are the same in my mind... can you elaborate?
17:10:04 <erisco> dleedev, the Applicative is not what is being "mappended"... it is the Alternative that is being mappended. The Applicative instance has nothing to do with the Alternative instance (other than it must be there). The laws the Alternative instance has to follow has nothing to do with the Applicative instance (other than it must also follow those laws)
17:10:27 <monochrom> Nothing <|> rhs = rhs.  Just x <|> rhs = Just x.
17:10:44 <dcoutts_> roboguy_: that function attempts to take the output of progs like sdl-config and put it into the right fields rather than just dumping it all into ld-options
17:10:45 <roboguy_> dleedev: it isn't an Applicative, it has an Applicative instance. in the same way that integers aren't monoids, but they have instances of monoid (for example, addition and multiplication)
17:12:05 <erisco> > (Nothing `mappend` Just 1, Just 1 `mappend` Nothing, Just 1 `mappend` Just 2)
17:12:06 <lambdabot>  No instance for (Data.Monoid.Monoid a2)
17:12:07 <lambdabot>    arising from a use of `e_11112'
17:12:07 <lambdabot>  The type variable `a2' is ambiguous
17:12:07 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
17:12:07 <lambdabot>  Note: there are several potential instances:
17:12:16 <erisco> -.-
17:12:36 <monochrom> > Nothing `mappend` Just 1
17:12:38 <lambdabot>  No instance for (Data.Monoid.Monoid a0)
17:12:38 <lambdabot>    arising from a use of `e_11'
17:12:38 <lambdabot>  The type variable `a0' is ambiguous
17:12:38 <lambdabot>  Possible fix: add a type signature that fixes these type variable(s)
17:12:38 <lambdabot>  Note: there are several potential instances:
17:12:41 <erisco> > (Nothing `mappend` Just 'a', Just 'a' `mappend` Nothing, Just 'a' `mappend` Just 'b')
17:12:42 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Char)
17:12:42 <lambdabot>    arising from a use of `Data.Monoid.mappend'
17:12:43 <lambdabot>  Possible fix:
17:12:45 <lambdabot>    add an instance declaration for (Data.Monoid.Monoid GHC.Types.Char)
17:12:47 <erisco> oh come off it
17:13:12 <monochrom> ah, it's doing "instance Monoid a => Monoid (Maybe a)"
17:13:13 <ReinH> well, you need a monoid
17:13:16 <ReinH> > Nothing <> Just "a"
17:13:18 <lambdabot>  Just "a"
17:13:30 <roboguy_> > Just (Sum 1) <> Just (Sum 1)
17:13:31 <lambdabot>  Just (Sum {getSum = 2})
17:13:36 <jayferd> okay so next problem is that readline won't run
17:13:37 <erisco> ReinH, ah so it constrains the inner type too. okay
17:13:52 <ReinH> the Monoid instance for Maybe a constraints a, yes
17:13:56 <dleedev> what's <> ?
17:14:00 <roboguy_> that is how the Monoid instance for Maybe differs from the Alternative instance
17:14:03 <monochrom> <> is mappend
17:14:05 <roboguy_> > Just 1 <|> Just 2
17:14:06 <ReinH> (<>) = mappend
17:14:06 <lambdabot>  Just 1
17:14:10 <jayferd> it installs and compiles just fine, but when i try to run `readline "> "` from ghci it fails to dlopen ncurses (?)
17:14:15 <ReinH> I just don't like writing out mappend
17:14:39 * hackagebot purescript 0.2.6 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.6 (PhilFreeman)
17:14:45 <jayferd> despite the presence of /usr/lib/readline.so
17:15:02 <erisco> > ("" <> Just "a", "a" <> "", "a" <> "b")
17:15:03 <lambdabot>  Couldn't match expected type `[GHC.Types.Char]'
17:15:04 <lambdabot>              with actual type `Data.Maybe.Maybe [GHC.Types.Char]'
17:15:07 <dleedev> ReinH: is there a place where I can find all the shortcuts?
17:15:19 <SrPx> What is the best way to program Haskell for people who like lisp-like syntax?
17:15:25 <erisco> > ("" <> "a", "a" <> "", "a" <> "b") -- ffs
17:15:26 <lambdabot>  ("a","a","ab")
17:15:32 <AshyIsMe> oh cool, hawk exists
17:15:36 <ReinH> SrPx: train yourself to prefer writing Haskell with Haskell syntax.
17:15:43 <erisco> mkay do you know which Monoid instance I used dleedev?
17:15:49 <dleedev> erisco, roboguy_: I'm still trying to digest how "being an Applicative" is different from "being an Applicative instance"
17:15:50 <SrPx> ReinH: seriously? Why that?
17:16:01 <ReinH> SrPx: because you are writing Haskell, not Lisp.
17:16:07 <jayferd> SrPx: you might try shen
17:16:21 <SrPx> ReinH: it is just a matter of syntax. jayferd no thanks :/
17:16:29 <dleedev> erisco: Sum Int
17:16:33 <ReinH> SrPx: right, and Haskell has a different syntax.
17:16:34 <SrPx> I don't like Shen, great work though, but I honestly don't like it
17:16:35 <jrmithdobbs> dleedev: the former is missing a word (functor at the end) and the latter is referencing the type class in haskell?
17:16:40 <byorgey> there used to be Liskell but I don't think it's been maintained in a long time
17:16:48 <roboguy_> dleedev: well, for example, both Alternative and Monoid are monoids it's just that one of them happens to be called "monoid". you can have a type that has several possible monoid instances. in my mind, that is how it "has a monoid" (sometimes several) rather than "is a monoid"
17:16:56 <erisco> dleedev, why do you think that? the type of mappend is a -> a -> a, and (<>) = mappend
17:17:15 <roboguy_> dleedev: for instance, numbers are monoids over both multiplication and addition
17:17:29 <jrmithdobbs> erisco: look at Integer, it has two different monoids
17:17:37 <jrmithdobbs> erisco: Sum and Product
17:17:44 <Twey> SrPx: The Haskell syntax is tied non-trivially to the semantics of the language
17:17:49 <erisco> jrmithdobbs, yes it does but why are you telling me? :)
17:17:59 <shachaf> edwardk: good reddit post
17:18:01 <dleedev> so are Sum and Product Monoids or Monoid instances?
17:18:01 <jrmithdobbs> erisco: because i read the wrong line ;p
17:18:02 <SrPx> Twey: hmm . :/ okay.
17:18:11 <edwardk> oh the f-algebra one?
17:18:21 <edwardk> yeah i wonder who pointed that one out to me ;)
17:18:22 <roboguy_> dleedev: I would say they happen to *have* Monoid instances
17:18:23 <Cale> Twey: Well, the abstract syntax is... the concrete syntax, maybe not quite as much
17:18:29 <ReinH> SrPx: If you prefer lisp syntax, might I suggest... lisp? Or clojure?
17:18:44 <Cale> There was a project called liskell
17:18:45 <Twey> Absolutely, but I feel sexpr syntax doesn't mesh well with currying, for example
17:18:51 <dleedev> so Sum *has* a Monoid instance?
17:18:59 <jayferd> anybody know why readline has a dependency on ncursesw?
17:19:00 <Twey> chrisdone's Lisk is a more recent equivalent of Liskell
17:19:04 <Cale> which was basically a lisp-ish concrete syntax skin for Haskell
17:19:12 <jayferd> is that a fallback or something?
17:19:25 <erisco> dleedev, yes. now do you know which Monoid instance is being used here?  "a" <> "b"
17:19:53 <jayferd> i'm getting this error when i try to compile something that calls readline: https://gist.github.com/jayferd/3163052a1dcf52dd6733
17:19:56 <dleedev> roboguy_: you said "numbers are monoids over both multiplication and addition". So Num is a Monoid and Sum has a Monoid instance?
17:20:11 <Cale> Yeah, I suppose that is true, from a lisper's point of view, identifying ((f x) y) with (f x y) would be kind of wonky.
17:20:12 <jayferd> (that file totally exists fwiw)
17:20:13 <dleedev> erisco: String?
17:20:31 <ReinH> dleedev: Sum is an instance of Monoid, as is Product. Num is not.
17:20:36 <ReinH> Num is not a type.
17:20:40 <jrmithdobbs> erisco: with or without OverloadedStrings ;p
17:20:57 <dleedev> ReinH: what about Int instead of Num?
17:21:00 <SrPx> ReinH: I can't stand Common Lisp... Scheme/Racket is really great but has a lot of problems too... including speed, among other important things. And I want to learn how to use a proper statically typed language, I've been for years in the dynamic world already... and well, many reasons...
17:21:02 <erisco> dleedev, close, it is more generic. it is the [] Monoid
17:21:12 <Twey> dleedev: Sum and Product are types, but they're redundant types that exist only to have Monoid instances.  Informally, it's common to also therefore refer to their Monoid instances as Sum and Product.
17:21:21 <ReinH> Int is not an instance of Monoid either, but Sum Int (wrapping an Int with the Sum newtype) is.
17:21:22 <SrPx> ReinH: if I came here asking for a way to program in Haskell it is because I learn Haskell, it is not very nice to call me out
17:21:23 <erisco> dleedev, now what are the definitions of mempty and mappend for the [] Monoid?
17:21:24 <rose_> When I add this newtype: newtype HexByte = HexByte String   how do I go about implementing show? That is, instance Show HexByte where show x = ?
17:21:41 <dleedev> Twey: so Sum has a Monoid instance called Sum?
17:21:43 <roboguy_> dleedev: not exactly. Num is itself a type class
17:21:48 <roboguy_> (like Monoid)
17:21:51 <ReinH> SrPx: I apologize, but I genuinely think it is not a good idea to try to write Haskell programs using Lisp-like syntax.
17:21:59 <Twey> dleedev: If you like.  Instances don't actually have names in Haskell, of course.
17:22:11 <erisco> dleedev, and when I say [] Monoid, I specifically mean the instance of Monoid for []. That is, the bit of code that reads "instance Monoid [a] where ..."
17:22:22 <dleedev> erisco: mempty = []; mappend x y = x ++ y,... i think
17:23:14 <ReinH> SrPx: I think your efforts to learn Haskell would be improved by adopting Haskell's syntax. When in rome, etc.
17:23:37 <erisco> dleedev, yes, correct. Now what Monoid instance is this and what is the definition of mempty and mappend? Just "a" <> Just "b"
17:24:35 <Cale> SrPx: I do think that Haskell's concrete syntax is something that grows on you. There's a lot which is quite nice about it. It might not have the same sort of uniformity that S-expressions have, but it's visually quite clean, and if laid out in the manner that's intended, it's easy to find your way around the structure of it while reading.
17:24:43 <dleedev> erisco: Maybe, mempty = Nothing; mappend Nothing y = y; mappend x Nothing = x
17:24:46 <SrPx> ReinH: that is ok... I just wrote an awesome editor for lisp like syntax. Seriously awesome, maybe even if just for me, I've never been so productive. And I'm a VIM user so I was already pretty productive. I love it so much I've been trying to create a language for it. And I did. But now I have to write an optimizer. And libraries. And so on. :( I don't want it anymore /sighs
17:25:01 <rose_> When I add this newtype: newtype HexByte = HexByte String   how do I go about implementing show? That is, instance Show HexByte where show x = ?
17:25:20 <ReinH> SrPx: well, you should write a Haskell structured editing plugin for vim :)
17:25:46 <Cale> rose_: Depends on how you want the values to be shown. You can get a default Show instance just by adding  deriving (Show) to the end of your newtype declaration.
17:25:50 <monochrom> rose_: that depends on what you want show to do
17:25:51 <ReinH> SrPx: you can even use some of the work chrisdone has already done for his emacs mode https://github.com/chrisdone/structured-haskell-mode
17:25:59 <lispy> I just realized that Text.Printf doesn't support Data.Text or ByteString. Is there a package that adds the necessary instances?
17:26:04 <erisco> dleedev, that is a valid instance but not the standard one. Do you know what I mean by this?
17:26:11 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #5
17:26:13 <ReinH> rose_: are you aware that you can derive Show?
17:26:15 <SrPx> ReinH: that would not work, it is really S-Expression based. There is a great structured editor for Haskell, I saw it on Reddit other day! Not for me, but seemed cool. What do you guys think?
17:26:30 <rose_> monochrom and Cale: I want the show to work just like the String show. E.g. "a4".
17:26:32 <roboguy_> you guys wouldn't happen to know if any of the SublimeHaskell maintainers hang out in this channel, would you?
17:26:34 <ReinH> SrPx: to which are you referring?
17:26:46 <monochrom> show (HexByte s) = show s
17:26:47 <SrPx> I don't remember the name, sorry :/
17:26:59 <Cale> rose_: Then you could write  instance Show HexByte where show (HexByte s) = show s
17:27:00 <mgsloan> Probably chris's, I don't think I've seen any other haskell structure editors
17:27:07 <dleedev> erisco: no... and I think I left out part of the mappend where both x and y are Just []...
17:27:16 <ReinH> mgsloan: chris's is the one I just linked :)
17:27:18 <AshyIsMe> paredit for haskell in vim would be great!
17:27:21 <Cale> https://github.com/chrisdone/structured-haskell-mode
17:27:22 <mgsloan> Yup :D
17:27:23 <lispy> ah, text-format is what I want
17:27:24 <erisco> dleedev, you did. What would you do in that case?
17:27:24 <ReinH> AshyIsMe: right, exactly
17:27:28 <AshyIsMe> can someone implement that kthx bi
17:27:33 <ReinH> structured-haskell-mode is based on paredit
17:27:41 <ReinH> there is a paredit for vim
17:27:42 <Cale> More and more of those gifs seem to be dying.
17:27:47 <ReinH> someone just needs to write some more vimscript
17:27:50 <ReinH> but I really hate vimscript
17:27:50 <rose_> Cale: thanks
17:28:02 <monochrom> http://www.vex.net/~trebla/humour/tautologies.html #2
17:28:16 <SrPx> that editor is another level compared to paredit
17:28:20 <mgsloan> Hmm, wierd must be a github bug
17:28:31 <dleedev> erisco: mappend (Just a) (Just b) = Just (a <> b)
17:28:35 <Twey> I hear Yi is up-and-coming now.
17:28:47 <ReinH> monochrom: #1
17:28:51 <Cale> It bothers me that Yi doesn't get the auto-reindenting quite right
17:28:59 <erisco> dleedev, yes indeed. that is what the standard instance is too.
17:29:01 <Cale> Or at least, didn't when I last tried it
17:29:03 <monochrom> yeah, I like #1 too
17:29:14 <Fuuzetsu> Cale: file a bug
17:29:15 <ReinH> monochrom: was referring specifically to you, right now. ;)
17:29:21 <erisco> dleedev, for example, you could have also said, mappend (Just a) <> (Just b) = Just a
17:29:42 <monochrom> I am the main cause of my problems? ok, but I don't have any problems
17:29:43 <mgsloan> Hmm, yeah, looks like Yi has some commit activity
17:29:45 <dleedev> erisco: did you mean to have the <> in there?
17:29:59 <ReinH> erisco: see also, First
17:30:03 <erisco> dleedev, oh sorry my bad. I meant   mappend (Just a) (Just b) = Just a
17:30:25 <erisco> dleedev, do you know why that is also valid?
17:30:36 <dleedev> erisco: because it satisfies Monoid laws
17:30:43 <erisco> dleedev, yes!
17:31:09 <erisco> dleedev, so that means, for any given type, such as (Maybe a), there can be many valid Monoid instances
17:31:42 <erisco> dleedev, so (Maybe a) is a monoid, and because of how Haskell is designed, we can only pick one instance for the Monoid type class. make sense?
17:31:42 <rose_> \msg Cale Do you know why I'm seeing "_\"c\"" rather than "_c"? I only ever call show on a HexByte
17:31:50 <ReinH> Well, there can be many valid monoids. There can only be one valid Monoid instance.
17:31:57 <ReinH> That is why we need newtype wrappers for the rest
17:31:59 <Cale> rose_: Because showing a String quotes it
17:32:27 <dleedev> erisco: makes sense
17:32:40 <dleedev> erisco: so Monoid instance is default and comes with Haskell?
17:32:49 <dleedev> erisco: for (Maybe a), at least
17:32:50 <erisco> dleedev, okay, now for Alternative. What Alternative instance is this and what is the definition of empty and <|>? "a" <|> "b"
17:32:50 <monochrom> show (HexByte "_c") should give you exactly "_c"
17:33:00 <Cale> rose_: The idea of show is that it produces something which is as useful as possible for debugging, which means that if there's a way to emit something which is valid source code for the thing, that's usually what it'll be defined to do.
17:33:06 <AshyIsMe> someone convince tim pope to start using haskell and vim's support for it will suddenly get ten times better :P
17:33:07 <monochrom> show (HexByte "_c") should give you exactly "_c"
17:33:20 <erisco> dleedev, the standard libraries include the instance (Monoid a) => Monoid (Maybe a)
17:33:53 <monochrom> show (HexByte "_\"c\"") will give you "_\"c\"", but that's just being fair, you input "_\"c\"" in the first place
17:34:08 <Cale> rose_: For Strings, that means that the quotes are actually included in the resulting String value. When you write something which is a String at the ghci prompt, of course, like anything else, ghci will apply show *again*.
17:34:22 <rose_> thanks
17:35:12 <Cale> If you were to use putStrLn (show myHexByte) or equivalently print myHexByte, then you shouldn't see the extra escapes, it'll only be quoted once.
17:35:21 <dleedev> erisco: borrowing your terminology, (Maybe a) is a Monoid, and it comes with a standard instance where Just a <> Just b = Just (a <> b), right?
17:35:52 <Cale> rose_: Or indeed, you should be able to just write  myHexByte  at the ghci prompt and see the value, because it will use the Show instance you provide.
17:35:56 <erisco> dleedev, yup
17:36:25 <monochrom> String is awful to begin with
17:36:28 <erisco> and also mempty = Nothing; Nothing <> x = x; x <> Nothing = x;
17:36:45 <Cale> monochrom: I think that problem is orthogonal to this issue though :)
17:37:20 <rose_> Cale: I'm actually trying to convert the HexByte to a String so I can concatenate them into a String. What's a good way to do that?
17:37:40 <danl-ndi> I have a package that requires OpenGL>=2.9.2.0, but the latest available on cabal is 2.9.1.0
17:37:57 <monochrom> interesting
17:37:58 <Cale> rose_: Pattern match
17:38:00 <hpc> metaphorically, the two (Maybe a) Monoids are a lot like Sum/Product
17:38:00 <dleedev> erisco: so in "a" <> "b", [Char] is a Monoid, and the standard monoid instance is where a <> b = a ++ b, is that right?
17:38:02 <asdafdf> Could anyone explain the rationale behind Henning's 'data T' stuff?  How is this benificial?
17:38:15 <Cale> asdafdf: It's not, he's a dick
17:38:36 <ReinH> o_O
17:38:47 <hpc> Cale: whatis?
17:38:58 <Cale> He actively sabotages projects by doing this to them
17:39:04 <Cale> Replacing all the type names with T
17:39:05 <dcoutts_> Cale: not really necessary, though you're right about the .T thing
17:39:07 <erisco> dleedev, forall types 'a', [a] is a Monoid, so that automatically includes [Char]
17:39:08 <Cale> and all the classes with C
17:39:19 <dcoutts_> it's an MLism I think
17:39:36 <dcoutts_> or at least I've seen ML code do that quite a bit
17:39:38 <asdafdf> dcoutts_: I've heard that it's an MLism, but why is this allowed on Hackage?
17:39:41 <erisco> dleedev, but yes, the standard instance is mempty = []; mappend = (++);
17:39:49 <roboguy_> Cale: wow
17:39:50 <dleedev> erisco: and like maybe, we could also have a Monoid instance for [a] where x <> y = y, although that's just not the standard Monoid instance?
17:39:51 <monochrom> perhaps I should replace all the value names with v, too
17:39:55 <Cale> asdafdf: Because there aren't really any solid rules for what goes on Hackage.
17:40:05 <monochrom> oh! that's a nice April 1st idea!
17:40:05 <asdafdf> I was able to avoid Henning's libraries, and now I have to use gnuplot...
17:40:12 <dcoutts_> asdafdf: allowed? hackage is a free for all! :-)
17:40:28 <dwcook> I'm curious now – What is a project that has been so sabotaged?
17:40:31 <roboguy_> I always wondered how hackage works as well as it does, considering...
17:40:32 <erisco> dleedev, correct
17:40:34 <Cale> dwcook: Haskore
17:40:40 <dcoutts_> asdafdf: it's only social mechanism, we don't enforce all that much
17:40:51 <dleedev> erisco: OK, I think I'm starting to be a bit more comfortable with the terminology
17:41:02 <erisco> dleedev, well hang on one sec I think that violates a rule
17:41:07 <Cale> Granted, he's done a lot of other things with it, but it used to be pretty nice, and now all the types are called T.
17:41:09 <ReinH> dleedev: Does x <> y = y follow the laws when y is the identity?
17:41:11 <monochrom> intead of "module Mono(x, y) where x=False; y=()", we will have: "module Mono.X(v) where v=False", "module Mono.Y(v) where v=()"
17:41:12 <hpc> oh god what
17:41:24 <dwcook> type T = Dur in one module, type T = Rational in another. o_0
17:41:28 <Cale> Also, a pretty significant library of algebra stuff.
17:41:31 <erisco> dleedev, x <> [] = x  is a rule, but x <> y = y  violates that when y = []
17:41:42 <Cale> http://hackage.haskell.org/package/numeric-prelude
17:41:50 <dleedev> ReinH, erisco: ah, got it.
17:41:53 <asdafdf> dcoutts_: What about the Haskell committee?
17:42:01 <roboguy_> erisco, dleedev: you could have x <> [] = x; x <> y = y though, I think
17:42:04 <erisco> dleedev, but you could do  x <> [] = x; _ <> y = y;
17:42:09 <asdafdf> dcoutts_: Do people like it?
17:42:13 <Cale> http://hackage.haskell.org/package/numeric-prelude-0.4.0.3/docs/Algebra-Differential.html -- nice list of instances there
17:42:19 <dcoutts_> asdafdf: that's just for the language
17:42:25 <Cale> http://hackage.haskell.org/package/numeric-prelude-0.4.0.3/docs/Algebra-Module.html -- better still
17:42:33 <asdafdf> dcoutts_: I meant the Haskell.org one.
17:42:39 <dleedev> ok, so x <> y = y unless x = [] or y = []
17:42:42 <dwcook> >_<
17:42:46 <Twey> asdafdf: The idea is that you're supposed to use it qualified.  So you write things like ‘import qualified Number.DimensionTerm’ and ‘Number.DimensionTerm.T u t’, so you can rename things as you like using the qualified imports system and don't get name conflicts
17:42:50 <dcoutts_> asdafdf: there are other people that look after core libs, platform etc, but for the rest of hackage the maintainer of the package can do what they like (more or less)
17:42:51 <dleedev> erisco: does that work?
17:42:54 <mgsloan> Yeah, naming all your types T is just not compatible with how ghci or haddocks work
17:42:56 <triliyn> dwcook: that Dur is also an alias for Rational
17:43:00 <Cale> asdafdf: Do not emulate Henning Thielemann
17:43:07 <erisco> :t unless
17:43:08 <lambdabot> Monad m => Bool -> m () -> m ()
17:43:08 <Twey> asdafdf: Unfortunately it doesn't always play well with tools ☺
17:43:15 <mgsloan> I can see why he might thing that's a good idea, but it's a terrible idea
17:43:18 <roboguy_> dleedev: x <> y is fine if x == []
17:43:18 <dcoutts_> asdafdf: in fact it's a fairly strong principle of hackage that the author/owner has a great deal of control over their package
17:43:28 <dleedev> roboguy_: ah, right
17:43:35 <dcoutts_> or people would not use it to publish, if the barriers were too high
17:43:36 <Twey> (Thielemann's Haddock can be, er, a little confusing)
17:43:37 <Cale> asdafdf: I've actually thought about writing a tool to try to automatically undo the damage he's done to some of these packages.
17:43:48 <Cale> But it's unfortunately pretty hard.
17:43:50 <hpc> Twey: or vacuous, as is mercifully the case for haskore
17:43:57 <erisco> dleedev, ready for Alternative now?
17:44:00 <Twey> Aye
17:44:03 <Cale> (Once you get down to trying to deal with qualified imports)
17:44:15 <dibblego> is it a good idea to use "type Id a = a" so that you can define type-classes instances on Id to kind-check?
17:44:29 <Cale> dibblego: You can't do that
17:44:33 <dcoutts_> asdafdf: not sure what you mean about haskell.org
17:44:34 <dleedev> erisco: so... for "a" <|> "b", [a] is an Alternative, and the standard Alternative instance for [a] is (<|>) = (++)?
17:44:35 <Fuuzetsu> dibblego: use newtypes
17:44:42 <dibblego> newtypes mootypes
17:44:47 <Twey> I'm using numeric-prelude at the moment; it's a fun experience.  The .T and .C are kind of annoying, but only the Haddock really seems to suffer.
17:44:47 <Cale> dibblego: But you can write newtype Identity a = Identity a, and such a thing exists.
17:44:48 <mgsloan> Maybe if enough people can convince him that he's fouling the community pool, while not doing it in such a way that drives him away from contributing anything
17:44:54 <dibblego> Cale: ok cheers
17:44:56 <asdafdf> dcoutts_: Still, I've heard lots of complaints regarding the T stuff.  Perhaps, there should be a policy.
17:44:56 <erisco> dleedev, yup and empty = []
17:45:07 <erisco> dleedev, exactly the same as Monoid [a] right?
17:45:15 <dleedev> erisco: yes
17:45:33 <Cale> asdafdf: I'm not sure it makes so much sense for there to be a policy at the level of Hackage.
17:45:39 <dcoutts_> asdafdf: best we can do is have socially accepted code standards guides, but we cannot enforce it at all
17:45:55 <erisco> dleedev, and for   Just "a" <|> Just "b"   ?
17:46:01 <Cale> asdafdf: But if anyone's up for repairing his packages and re-releasing them, I'm all in support for it.
17:46:01 <monochrom> nu cow: https://www.dropbox.com/s/4sferqlnqmfhg7g/nu.txt
17:46:16 <hpc> fun game, see how long you can spend clicking nothing but "T" in haskore docs
17:46:22 <Twey> Oh, although the fact that the numeric ‘Prelude’ requires importing a bunch of packages to get classes and types isn't particularly enjoyable.
17:46:25 <hpc> before running out of T or looping around
17:46:34 <Fuuzetsu> hpc: do you eventually end up on ‘Philosophy’?
17:46:45 <hpc> i hope so
17:47:00 <Cale> I would be more okay with Henning doing what he does if he didn't *take maintainership* of other packages which didn't use that convention before and then change all the types like that.
17:47:02 <dleedev> erisco: isn't the same as the monoid? empty = mempty; <|> = <>
17:47:03 * monochrom has a cunning plan!
17:47:30 <monochrom> change Prelude.head to Prelude.Head.v, Prelude.map to Prelude.Map.v, etc
17:47:36 <merijn> Cale: So he breakingly updates the API for something dumb?
17:47:40 <Cale> Yep
17:47:45 <merijn> ...
17:47:46 <erisco> dleedev, it could be! however the standard definition has  Nothing <|> y = y; x <|> y = x;
17:47:46 <Twey> monochrom: Heh
17:47:48 <monochrom> the package can be called prelude-henning or something
17:47:58 <hpc> this is the kind of shit people make fun of haskell for
17:48:02 <Cale> I don't know how much he's done it recently
17:48:08 <erisco> dleedev, which is the "choose the non-empty left argument" version we already discussed
17:48:16 <erisco> > Just "a" <|> Just "b"
17:48:17 <lambdabot>  Just "a"
17:48:21 <Cale> But he basically ruined a bunch of packages that I actually kind of liked.
17:48:34 <dleedev> erisco: OK, got it
17:48:45 <asdafdf> dcoutts_: "not sure what you mean about haskell.org".  I was talking about the Haskell.org committee.  However, I've just read that it's not their business to deal with such things.
17:49:01 <Fuuzetsu> I wonder what the comment messages are like for those. “Change everything to ‘T’ just because”?
17:49:21 <erisco> dleedev, cool. so hopefully this demonstrates that alternatives are monoids
17:49:30 <dleedev> erisco: yes, that makes sense
17:49:31 <monochrom> commit message: "alpha conversion"
17:49:40 <merijn> monochrom++
17:49:44 <dleedev> erisco: but why two names for the same thing?
17:49:54 <dleedev> erisco: how is Alternative different from Monoid?
17:50:13 <erisco> dleedev, because Alternative instances must also have Applicative instances (it is a dependency) whereas Monoid does not require that
17:50:15 <merijn> dleedev: Monoid has kind *, Alternative has kind * -> *
17:50:15 <pyon> dleedev: Not even the same kind?
17:50:18 <dibblego> dleedev: it subclasses Applicative and it uses the type-constructor not the raw value
17:51:44 <dleedev> erisco: so it's an Applicative that's also a Monoid?
17:51:44 <asdafdf> Cale: I've already seen people complaining here (as I do now), but I actually want to change this.  What should I do?
17:51:52 <erisco> dleedev, also as people are pointing out, the types are different. empty :: a -> f a; (<|>) :: f (a -> b) -> f a -> f b
17:52:00 <erisco> dleedev, no
17:52:29 <AshyIsMe> so it looks like shm.el just needs to be ported to vimscript for structured-haskell-mode to work in vim
17:52:41 <dleedev> erisco: how did "a" <|> "b" satisfy the signature f (a -> b) -> f a -> f b
17:52:41 <Cale> asdafdf: Well, you can grab the source code, and try to rename the types. Probably if some module X.Y.Z defines a type T, a good name for the type would be Z, but you have to use some rational judgment to be sure.
17:52:53 <Cale> asdafdf: There are also lots of classes, and they'll all be called C
17:52:56 <erisco> dleedev, oh sorry lol I gave <*>
17:53:08 <erisco> (<|>) :: f a -> f a -> f a
17:53:15 <ReinH> :t (<|>)
17:53:16 <lambdabot> Alternative f => f a -> f a -> f a
17:53:21 <Cale> asdafdf: The way he uses them is that he imports the modules qualified and then uses ModuleName.T
17:53:23 <ReinH> erisco: you gave <$>
17:53:23 <erisco> yes or that works too :)
17:53:25 <dwcook> dleedev, one consequence of them having different kinds is that, whereas Monoid requires you to choose a concrete "empty" value, Alternative requires you to choose one that's polymorphic in the type argument.
17:53:42 <ReinH> and Empty is just Alternative f => f a
17:53:43 <dleedev> :t (<>)
17:53:44 <lambdabot> Monoid m => m -> m -> m
17:53:46 <ReinH> not a -> f a
17:53:56 <erisco> yes I gave pure
17:54:01 <erisco> for some reason, Applicative entered my mind
17:54:04 <erisco> sorry dleedev
17:54:15 <dibblego> fwiw, Scala programmers are undergoing a similar phenomena, where they are convinced that ML modules are useful and so they obsessively go around "fixing" code.
17:54:34 <erisco> ReinH, and no I did give <*>
17:54:41 <Cale> asdafdf: You may or may not have much luck removing the module qualification altogether, but it would be worth striving at least to do it to the point where you don't have to import the types and classes qualified.
17:54:46 <ReinH> erisco: oh yes
17:55:15 <asdafdf> Cale: I guess I could also "roll-back" to the older versions, but I was asking a different question.
17:55:27 <Cale> asdafdf: Oh, sorry, what were you really asking?
17:55:33 <jfischoff> dleedev: you might find http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html interesting
17:55:55 <jfischoff> lots of things are monoids, just not everything can be a Monoid
17:55:56 <dleedev> jfischoff: I don't see Alternatives in there
17:56:04 <jfischoff> they're not
17:56:05 <monochrom> even in the practical ML code I use, one module may provide several types, therefore "modulename.t" does not fly
17:56:08 <Twey> ML modules are useful; Haskell just doesn't have them and replacing all typenames with T and classnames with C doesn't make it have them :þ
17:56:22 <erisco> dleedev, so does that make some sense given ReinH's corrections?
17:56:35 <dleedev> erisco: so Alternatives are polymorphic Monoids?
17:56:43 <monochrom> I am referring to HOL4. for example, a type provided by module Term is called term, not t.
17:57:10 <monochrom> and a type provided by module Thm is called thm, still not t
17:57:47 <asdafdf> Cale: I want to be able to install the packages from Hackage.  I guess someone may not like if we end up with gnuplot-modified, etc.
17:57:59 <erisco> dleedev, no, they are the same thing, it is just that the kinds are different
17:58:19 <Cale> asdafdf: Maybe, but for now, probably just naming the package whatever-sane would be fine.
17:58:32 <erisco> dleedev, class Monoid a where mempty :: a; mappend :: a -> a -> a;  we say that 'a' is of kind *
17:58:34 <monochrom> the convention "modulename.t" is really a religious dogma of "one module per type" rather than anything to do with ML or language design or module systems, really.
17:58:48 <Cale> asdafdf: If you're willing to be even more cheeky, you can just push a new version
17:58:58 <erisco> dleedev, class Alternative f where empty :: f a; (<|>) :: f a -> f a -> f a;   here we say 'f' is of kind * -> *
17:59:41 <dleedev> erisco: OK, I'm starting to get it a little, but I have to catch a train right now. I'll try connecting inside the train.
17:59:48 <dleedev> erisco: thanks a bunch!
17:59:56 <Cale> asdafdf: Actually, scratch that, you can't now. You used to be able to.
17:59:57 <monochrom> and to see how ridiculous this religious dogma is, just look at its logical conclusion "one module per value"
17:59:59 <erisco> dleedev, see ya, good luck
18:00:00 <asdafdf> Cale: Just for the record, I have nothing against Henning, I simply don't like the types.
18:00:32 <Cale> asdafdf: Right, to be honest, as a person, I'm sure he's fine. It's just the stuff that he's done sometimes makes me upset :)
18:01:19 <monochrom> indeed, with GHC's notion of unexposed modules, "one module per value" can actually be done conveniently. this is something you can't even boast about for ML
18:01:45 <asdafdf> Cale: So I wouldn't upload the new version because it's unethical.
18:02:17 <Cale> asdafdf: You can't anyway now, since if you're not on the maintainer list, you can't upload a new version for a package which is already there
18:03:32 <Cale> (Though I don't know what the policy is on packages which aren't being actively maintained any longer)
18:03:47 <hpc> there was something about this on -cafe
18:04:05 <hpc> policy is that you ask the current maintainer, and if they aren't responsive you contact hackage admins
18:04:16 <Cale> Right, that's sort of what I'd expect
18:05:09 <Cale> asdafdf: Note that it's perfectly okay for different packages to expose modules with the same names.
18:05:19 <asdafdf> Cale: I'm still uneasy about the "package-modified" idea.  Should I ask on the haskell-cafe list?  Or would it cause a flamewar?
18:05:45 <Cale> asdafdf: You don't have to ask. Forking things is perfectly all right, I'd say, especially if you're making a large API change like that.
18:05:51 <mgsloan> Cale: I dunno about "perfectly".  Ideally they'd export similar functionality.  Otherwise this breaks ghci ":m + "
18:06:07 <Cale> mgsloan: Well, yes
18:06:08 <mgsloan> What I mean is, it should be a situation where you either install one package or the other
18:06:15 <asdafdf> Cale: Perhaps, I should talk to haskell-pkg-janitors.  What do you think?
18:06:40 <hpc> mgsloan: aw man, does that mean i can't put my awesome web framework in module Data.Function?
18:06:42 <Cale> asdafdf: Write the thing first, then figure out what to call it :)
18:07:29 <mgsloan> hpc: go for it.  You can call it the "functional" package
18:08:15 <hpc> heh, on a related note i am curious what would happen if i uploaded a package named --global
18:08:17 <Cale> asdafdf: You probably won't be able to take over Henning's packages since he's still around, but I'm sure people would get some use out of versions with sane naming that were uploaded alongside them.
18:09:11 <mgsloan> You can make a new hackage category "Dehenninged packages"
18:09:17 <Cale> hpc: Try it for science
18:09:34 <asdafdf> Cale: OK.  But I want to hear other opinions.  monochrom, WDYT?
18:09:39 <hpc> too lazy to run a hackage instance ;)
18:09:44 <pharaun> has anyone managed to get cgi to compile on haskell platform, i have had nothing but endless trouble :\
18:09:49 <Cale> hpc: Do it live!
18:09:59 <hpc> Cale: you do it :P
18:10:01 <Cale> Peer pressure! Do it!
18:10:04 <Cale> lol
18:10:41 <hpc> Cale: i did enough damage adding the "Ntrol" category ;)
18:10:54 <Cale> It would be funny to come up with an excuse for why it's reasonable for your package to be named like that.
18:11:29 <hpc> global is a fairly reasonable package name, but i have no idea how you would justify the double dash
18:11:29 <asdafdf> Cale: By the way, has anyone actually tried to discuss this with Henning?
18:11:52 <dibblego> can f and g easily be generalised without too much penalty? f :: T x y -> x; g :: U x y -> y ?
18:12:19 <hpc> dibblego: isn't that the extensional definition of a tuple?
18:12:57 <roboguy_> what's the general feeling on doing pointless stuff like (f .) . g? too pointless and cryptic?
18:12:57 <hpc> oh, this is the F/G thing from the other day
18:13:02 <dibblego> well I could return Either x y
18:13:22 <dibblego> hpc: similar, I'm writing the zipper now
18:13:25 <hpc> roboguy_: better written as f .: g, though there are mixed feelings about that operator apparently
18:13:45 <hpc> it's fairly pointless in any event, sections of (.) are eeeeeevil
18:14:05 <roboguy_> hpc: well, this particular instance isn't *too* bad with only two .s
18:14:25 <hpc> roboguy_: implies that it is in fact, a little bad ;)
18:14:36 <roboguy_> hpc: haha yeah, probably...
18:15:06 <hpc> a newer programmer without all the combinatorial sense of one more experienced
18:15:11 <hpc> is going to wtf at reading that line
18:15:37 <hpc> then spend an hour figuring out what it expands to and using that instead
18:15:40 <dibblego> I read it straight away as "that is (fmap fmap fmap) and it should be written differently"
18:15:45 <roboguy_> hpc: I guess this is sort of the old debate about whether to make something simple or nice. in this case, the pointed style is probably both though...
18:15:58 <hpc> simple is nice
18:16:12 <chrisdotcode> guys, does  (liftIO . liftIO) m == liftIO m, where m is a member of MonadIO?
18:16:16 <hpc> but often simple/nice is not short
18:16:22 <hpc> chrisdotcode: yes
18:16:31 <roboguy_> hpc: well, I mean, I would consider some lens stuff to be non-intuitive and not necessarily simple (the first time you see it anyway) but it can be nice
18:16:33 <chrisdotcode> hpc: and does any number of liftIOs == one liftIO?
18:16:40 <hpc> chrisdotcode: yes
18:16:45 <chrisdotcode> hpc: thought so. thanks! :)
18:16:46 <hpc> chrisdotcode: you'll hate the reason though
18:16:50 <chrisdotcode> hpc: what's the reason?
18:16:53 <hpc> :t liftIO
18:16:54 <lambdabot> MonadIO m => IO a -> m a
18:16:59 <hpc> all the liftIOs except one are = id
18:17:21 <chrisdotcode> oh, since it's already in a monadicIO context, it doesn't need to do anything more?
18:17:26 <edwardk> hpc: i tend to avoid .: simply because i find that it raises more questions than the expansion
18:17:48 <hpc> edwardk: that makes sense
18:18:29 <hpc> chrisdotcode: less that and more that you aren't lifting through multiple layers of transformers with liftIO repeated
18:18:33 <roboguy_> edwardk: yeah, that's true
18:18:33 <edwardk> my usual rule of thumb is to wonder whether adding an alias for something will make the user have to go somewhere else to unravel the definition for purely code-organizational reasons
18:18:41 <hpc> liftIO /always/ takes a flat IO action as a parameter
18:18:50 <edwardk> if it sends them off on a longer side-quest than the value of the name i don't make the name
18:19:19 <hpc> > 5 * 0 * 0 * 0 * 0 + 1 -- it's a little like this
18:19:20 <lambdabot>  1
18:19:56 <chrisdotcode> oh, sort of like Maybe, stopping computations if the value is a just?
18:20:07 <chrisdotcode> only instead of stopping, it just makes them flat?
18:20:32 <BMeph> edwardk: Good call - if you're gonna raise question with what you write, make sure the question are about Your stuff, not others' stuff! ;)
18:20:42 <hpc> chrisdotcode: look at the type of liftIO
18:20:44 <hpc> :t liftIO
18:20:45 <lambdabot> MonadIO m => IO a -> m a
18:20:51 <hpc> it always takes an (IO a)
18:21:05 <hpc> IO is an instance of MonadIO where liftIO = id
18:21:21 <hpc> if we take a chain of (liftIO . liftIO), and do some type inference
18:21:26 <hpc> it becomes
18:21:37 <hpc> liftIO_m . liftIO_IO
18:21:41 <chrisdotcode> ohh, okay
18:21:42 <hpc> which is liftIO_m . id
18:21:48 <chrisdotcode> I didn't know that IO was an instance of MonadIO
18:21:59 <hpc> yeah
18:22:06 <chrisdotcode> so instance MonadIO IO where liftIO = id ?
18:22:07 <hpc> so every lift but the last one is doing nothing ;)
18:22:09 <hpc> yep
18:22:17 <chrisdotcode> sweet! that makes a lot of sense
18:22:20 <chrisdotcode> thanks, hpc :)
18:22:25 <hpc> TMYK
18:22:41 <hpc> chrisdotcode: your name is confusingly similar to chrisdone
18:23:05 <chrisdotcode> hpc: yeah, I actually have to change it when he's active, so people don't accidentally keep pinging me...
18:24:19 <chrisdotcode> hpc: ideally, I'd like to have one consistent handle, but I might need to make an exception for #haskell, sadly
18:24:52 * hackagebot purescript 0.2.7 - PureScript Programming Language Compiler  http://hackage.haskell.org/package/purescript-0.2.7 (PhilFreeman)
18:25:54 <hpc> chrisdotcode: as a more interesting side note, lift . lift = lift -- this is true for less trivial reasons
18:26:14 <chrisdotcode> hpc: isn't lift == fmap?
18:26:24 <hpc> no, lift is more subtle
18:26:46 <hpc> and i am too sleepy to give a good description
18:27:07 <chrisdotcode> well that's fine for now :)
18:29:04 <shachaf> Er, lift . lift = lift?
18:29:38 <shachaf> > runIdentity $ (`runStateT` 10) $ (`runStateT` 20) $ (`runStateT` 30) $ do { (lift . lift) (modify succ) }
18:29:40 <lambdabot>  ((((),30),20),11)
18:29:41 <shachaf> > runIdentity $ (`runStateT` 10) $ (`runStateT` 20) $ (`runStateT` 30) $ do { lift (modify succ) }
18:29:42 <lambdabot>  ((((),30),21),10)
18:29:56 <hpc> doh
18:30:10 <hpc> i am far too sleepy to say things
18:30:44 <hpc> it's "usually" true though, when you aren't nesting the same kind of transformers
18:30:52 <hpc> or something
18:31:41 <shachaf> That seems like a very misleading way to explain the way mtl classes work.
18:32:16 <pharaun> hello - http://lpaste.net/98167 - i'm having a hell of a time getting cgi-3001.1.8.4 to even build
18:32:49 <pharaun> i've tried a few version, tried rebuilding the whole haskell world/cabal/package and the platform
18:32:52 <pharaun> still can't get cgi to build
18:33:55 <hpc> pharaun: is that the latest version
18:33:57 <hpc> ?
18:34:01 <pharaun> believe so
18:34:15 <pharaun> http://hackage.haskell.org/package/cgi - 3001.1.8.4
18:34:29 <Twey> hpc: If you aren't nesting the same kind of transformers, it might not even type-check :þ
18:35:05 <hpc> the github code doesn't appear to be any newer either
18:35:09 <hpc> you should let the maintainer know
18:35:35 <hpc> maybe write a patch
18:35:48 <pharaun> not sure i can but i'll try and sure
18:35:56 <pharaun> just wanted to see if anyone had ran into this one yet
18:36:24 <hpc> it should be simple, just changing a class constraint or two
18:36:52 <Hafydd> Why does mtl contain the word "Library" in its name?
18:37:03 <hpc> Hafydd: so people know it's a library
18:37:29 <Hafydd> What doesn't every other library end with "Library"?
18:37:33 <tnks> a coworker was showing me some Haskell code that have a ton of lift calls on the right side of some do-blocks with ReaderTs; we were wondering whether  1) this is common and okay, perhaps with a little refactoring away the lifts  2) it's a smell that we're using the wrong combinators.
18:37:51 <pharaun> hpc: sure :) i'm just not always confident in my ability but yeah
18:37:58 <pharaun> should be able to mange it :D
18:38:25 <lispy> tnks: You usually want to hide that
18:38:57 <lispy> One simple ways is to provide a wrapper function that does the lifts
18:39:14 <lispy> But given the vague description I'm not sure what else to suggest
18:39:20 <pharaun> yeah the git version fails too, i'm going to try to create a patch then submit it
18:40:03 <tnks> lispy: sorry about the vagueness. . . it's a recollection of someone else's code.
18:40:19 <tnks> I mentioned he could ask #haskell. . . but it got stuck on my mind. . . so I chose to ask on his behalf.
18:40:37 <tnks> but we had the idea to just wrap away the calls too.
18:42:44 <lispy> tnks: are you familiar with this: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
18:43:04 <lispy> It's probably slightly out of date, but most of the content should work
18:43:42 <tnks> lispy: let me read that. . . I haven't yet, though I've read other stuff on transformers.
18:44:23 <lispy> tnks: and this: http://book.realworldhaskell.org/read/monad-transformers.html
18:46:52 <tnks> lispy: yeah, thanks for the reminder of that the book.
18:47:08 <tnks> there's a lot of content there. . . haven't gotten through a lot of it.
18:48:18 <lispy> tnks: once you've studied all that and figured out how to do what you want with mtl, then I'll let you in on the secret that many people prefer transformers and monadLib because they solve some of the more subtle issues of mtl :)
18:48:40 <lispy> and by "many people" I really mean "a few experts I know"
18:48:42 <tnks> lispy: I didn't know that.
18:49:07 <tnks> lispy: so "transformers" and "monadLib" are just packages in Hackage?
18:49:13 <lispy> mtl is far more common/popular, so it's good to understand it. BTW.
18:49:15 <tnks> I'd been focusing on mtl.
18:49:22 <lispy> yeah, all there are on hackage
18:49:25 <lispy> three*
18:49:37 <tnks> okay, good to know about the other two.
18:49:54 <tnks> feel free to drop some indication here of why people prefer transformers and monadLib.
18:49:54 * hackagebot dtd-text 0.1.2.0 - Parse and render XML DTDs  http://hackage.haskell.org/package/dtd-text-0.1.2.0 (M15K)
18:50:14 <tnks> or even what the difference is between the two alternatives.
18:51:11 <novochar> Real World Haskell: "Additionally, although the focus of the language is squarely on writing statically typed programs, it is possible (though rarely seen) to write Haskell code in a dynamically typed manner."
18:51:25 <novochar> How do you write Haskell code in a dynamically typed manner?
18:51:30 <lispy> tnks: I don't know transformers at all (but I think it's the basis for mtl these days?). monadLib tries to make lifting more principled and sane. Again, I don't really know the details.
18:51:33 <Fuuzetsu> @package dynamic
18:51:33 <lambdabot> http://hackage.haskell.org/package/dynamic
18:51:47 <Fuuzetsu> oops, Data.Dynamic
18:52:42 <tnks> lispy: okay, thanks for the heads-up.
18:54:41 <silasm> is there an "indexable" typeclass? I'm trying to generalize something to all data structures that have a sense of adjacency.
18:54:50 <erisco> silasm, Ix
18:54:58 <silasm> e.g. lists/arrays/ maybe trees, but not maps
18:55:09 <silasm> isn't Ix for types that can act as an index?
18:55:14 <Twey> Yes
18:55:23 <erisco> silasm, yeah =\ I guess that is not what you want
18:55:32 <Twey> But being indexable doesn't imply adjacency
18:55:54 <silasm> how so?
18:56:19 <Twey> Because you can have an index without a norm
18:56:49 <silasm> '@src norm :|
18:56:56 <silasm> what do you mean by that
18:57:27 <Twey> That is, you can have a container that's indexed by a type that doesn't have a concept of ‘near’, let alone ‘adjacent’
18:57:32 <silasm> at any rate if there's something for data structures with a sense of adjacency already, that's even better.
18:58:02 <silasm> Twey: yeah I guess maps are indexable.
18:58:50 <Twey> ‘Adjacent’ in the sense you want requires that you have an ordered domain that is discrete
18:59:01 <silasm> yeah
18:59:30 <Twey> s/ordered/measured/ I guess
18:59:53 <erisco> silasm, Sequence may interest you from http://hackage.haskell.org/package/container-classes-0.0.0.0/docs/Data-Containers.html
19:00:15 <silasm> trying to write a substring search as a monoidal combine operation. I should honestly try getting it working on strings before I try to generalize it.
19:00:33 <Twey> silasm: For example, does your concept generalize to two-dimensional arrays?  Five-dimensional?
19:00:57 <silasm> Twey: eh, possibly, but preferably not since that wouldn't be easy.
19:01:06 <silasm> It'd certainly be interesting though.
19:01:59 <roboguy_> I think there's an indexable type class in lens
19:03:10 <silasm> erisco: sequence does seem to be what I want.
19:03:21 <DarthArachides> anyone here work through bpierce's TAPL in haskell recently? I'm stuck at a point and I believe that's entirely due to a bug in haskell type system or my inability to wield it well.
19:03:54 <Hodapp> TAPL? same bpierce as Software Foundations?
19:04:00 <DarthArachides> Hodapp: exactly.
19:04:09 <DarthArachides> "Types and Programming Languages"
19:04:27 <silasm> need to start reading that...
19:04:30 <erisco> must be a lengthy book
19:04:39 <Hodapp> dang, it's not available free like his other!
19:04:47 <silasm> Hodapp: libgen.org
19:05:16 <silasm> just use it to determine whether or not it's worth a buy, though I suspect it will be.
19:05:22 <silasm> I just haven't looked at it yet.
19:06:02 <Twey> silasm: It's a very good book
19:06:17 <DarthArachides> I like it so far, mainly using it to get acquainted with type systems.
19:06:19 <Twey> DarthArachides: I've read it, though I did the exercises in Agda rather than Haskell
19:06:31 <Twey> (well, some of them ☺)
19:06:41 <silasm> Twey: yeah, but I'm reading through Categories for the Working Mathematician and Parallel and Concurrent Programming in Haskell as it is.
19:06:46 <Twey> Aha
19:06:47 <silasm> so I'll get to it when I get to it :/
19:07:34 <Hodapp> silasm: in an instance like this, where I'm already working through SF which he released for free, I'd be inclined to just buy a legit copy.
19:08:12 <silasm> Hodapp: yeah I probably will. I took it with that premise before I realized it was the same bpierce as SF, otherwise I would have just bought it.
19:08:21 <DarthArachides> Twey: aha, then you might be able to help! I cannot get something to typecheck even though it's happens to match with bpierce's solution
19:08:33 <silasm> but I may never get to it, in which case I'm not going to spend money to put it on my shelf, sadly.
19:08:37 <DarthArachides> care to look through some sourcecode? the problematic function is _minus in http://lpaste.net/98170
19:09:24 <novochar> thanks Fuuzetsu, is that the only way to write in a dynamic manner with Haskell?
19:10:02 <erisco> novochar, no but it is probably the most sane thing
19:10:14 <Twey> DarthArachides: This type-checks for me
19:10:28 <DarthArachides> Twey: _minus _two _two doesn't, for some reason.
19:10:30 <mgsloan> novochar: While not exactly dynamic typing persay, "-fdefer-type-errors" allows you to turn type errors into runtime exceptions
19:10:34 <Twey> Ah, right
19:11:02 <erisco> novochar, you can, for instance, make a variant of all types you want to work with. For example, data DynVar = DynInt Int | DynChar Char | DynString String ... and so on
19:11:05 <Twey> DarthArachides: You won't always be able to directly implement untyped lambda-calculus functions in Haskell
19:11:44 <erisco> mgsloan, so that's how you get your program to compile in a pinch!
19:11:58 <Twey> DarthArachides: The untyped λ-calc can have expressions with types that are infinite in Haskell, which isn't allowed.  To embed them, you'd need to assign some kind of type based on e.g. newtype Mu f = Mu (f (Mu f))
19:13:06 <mgsloan> erisco: I've never actually used that flag in a real situation, to be honest :)
19:13:20 <mgsloan> Just to give it a spin and say "oh, that's nifty"
19:13:22 <DarthArachides> Twey: ah. is there a place I can read about fixpoints (and not somewhere in the same book :-) )
19:13:23 <erisco> novochar, you can also serialise everything to one type, such as String, and then only work with String (unix does this)
19:13:33 <DarthArachides> (I'm guessing, what you wrote is a fixed point combinator/operator?)
19:14:20 <erisco> or you can be hardcore and serialise to a bit string :)
19:14:27 <Twey> DarthArachides: What I wrote is a newtype wrapper for an infinite type
19:15:42 <Twey> (a fixed point of the type function f)
19:16:27 <novochar> erisco: thanks for th feedback
19:16:28 <Twey> DarthArachides: The book covers fixed points pretty well, but I think you'd be jumping ahead of yourself if you dived into them now; you might want to *implement* the lambda-calculus described there, instead
19:16:29 <silasm> Twey: does haskell let you do that?
19:16:34 <Twey> silasm: Yes
19:16:35 <novochar> mgsloan: thanks for your feedback as well!
19:16:47 <mgsloan> welcome!
19:17:06 <silasm> Twey: ooh. I just gave up when trying to use iota for anything when (iota iota) gave me an infinite type. I'll have to look back at that sometime.
19:17:14 <DarthArachides> Twey: ah, I see and probably run all the examples in _that_ calculus rather than in haskell.
19:17:20 <Twey> DarthArachides: Right
19:18:32 <DarthArachides> makes sense - I was just very happy that I could see the proofs of all my definitions by just looking at types. that was very cool, ":t _iszero _zero" has the same type as true, and hence what I wrote must be true. :-)
19:19:49 <DarthArachides> (and correspondingly, _iszero _one has same type has '_false', etc.)
19:19:58 * hackagebot krpc 0.6.0.0 - KRPC protocol implementation  http://hackage.haskell.org/package/krpc-0.6.0.0 (SamTruzjan)
19:20:08 <Twey> DarthArachides: Indeed
19:20:49 <Twey> DarthArachides: But that only works for things with finite, decidable types, which is a subset of the untyped λ-calculus
19:24:22 <DarthArachides> I must confess, I can't even begin to see why that should be true/false. :/ But hopefully, by the end of the book, I will!
19:24:46 <DarthArachides> Twey: what would you suggest after TAPL if one were interested in learning about types? (My eventual goal is to understand dependent types.)
19:25:40 <Twey> DarthArachides: There's a sequel ‘Advanced Topics in Types and Programming Languages’ that covers dependent type systems, amongst other things
19:26:03 <DarthArachides> perfect.
19:26:38 <Twey> DarthArachides: But I should warn you that if that's your *only* goal, you're going about it a very roundabout way: (ATI)TAPL is about *implementing* type systems, and isn't necessarily the best introduction to actually programming in them
19:28:47 <Twey> DarthArachides: The Church encoding of a data-type is its eliminator — a function with one branch for each constructor that takes a function that gets all the information in the constructor and knows how to transform it into the desired result type
19:29:45 <DarthArachides> Twey: ah, it's not really the _only_ goal. This is just a hobby, and I would like to be really comfortable with the basics given that I haven't had any formal exposure to logic/types/etc.
19:30:27 <Twey> So the Church encoding of a boolean is a function that takes one value (or function of (), no information, if you like) and evaluates to either the true or the false branch, depending on which boolean it is
19:30:52 <DarthArachides> oh yeah, I just discovered that today, that was very cool when I realized where all these arbitrary encodings for numbers / lists /etc. came from - they were not artificially constructed - just transferred over from the constructors.
19:31:01 <Twey> The fact that the branches are inferred to have different types in Haskell is a happy accident of polymorphism :þ
19:31:49 <Twey> s/and evaluates/for each boolean and evaluates/
19:32:06 <DarthArachides> oh, disappointing that it's just an accident - thought I could extend this to even a larger subset..
19:33:58 <Twey> DarthArachides: Strictly speaking, the Church encodings for true and for false should have the same type: that's what it means to be a boolean
19:35:19 <Twey> I think it should extend to other constructs too, but only when you're viewing the functions on their own: if you were to use them in a larger expression the branches would be forced to have the same type, since the expression can only have one return value
19:35:32 <Twey> Er, one return type
19:36:48 <DarthArachides> ah, that's correct. I guess what happens now (in my lucky examples) is that this "one type" is some sum type (True || False) and only luckily do some expressions end up being evaluated as either True or False.
19:37:00 <DarthArachides> (does that sound right?)
19:37:22 <Twey> DarthArachides: No :þ  Haskell doesn't infer sum types
19:37:32 <DarthArachides> (in general, could the type checker assign sum types whenever it could and specialize them whenever possible)
19:37:36 <DarthArachides> oh
19:38:03 <Twey> DarthArachides: What will happen is that the branch that isn't returned will be forced to have the same type as the branch that does, and it will have just happened to be an expression that could have that type
19:38:05 <DarthArachides> I guess, that's Hindley-Milner, isn't it?
19:38:09 <Twey> Yes
19:38:25 <DarthArachides> ah, I see.
19:39:06 <DarthArachides> does this ability to infer "sum types" have some name that you know of (or know some languages that implement such type systems) so that I can read more about it?
19:39:26 <Twey> Erm, I did read a paper on such a language a while back; let me see if I can find it
19:40:01 <DarthArachides> cool, thanks!
19:46:12 <Twey> DarthArachides: I think it was this paper: http://www.cs.cmu.edu/~joshuad/papers/tridirectional-typechecking/
19:47:17 <DarthArachides> Twey: thanks much, sir!
19:49:36 <Twey> DarthArachides: No problem
19:57:01 <shlevy> Recommendations for argv parsing utilities?
19:57:16 <johnw> shlevy: I like optparse-applicative
19:58:32 <ParahSailin> shlevy: ltns
19:58:55 <shlevy> ParahSailin: Hey :)
20:04:20 <lispy> shlevy: getopt is my go-to for commandline parsing
20:04:33 <shlevy> Ah should've known there'd be a getopt
20:05:07 <lispy> shlevy: http://www.haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
20:05:18 <lispy> shlevy: that article explains a nice way of using it
20:05:24 <shlevy> thanks
20:05:31 <lispy> all the magic is in options :: [ OptDescr (Options -> IO Options) ]
20:06:09 <ParahSailin> that one looks pretty verbose compared to optparse-applicative
20:08:04 <silasm> I can't seem to find the Sequence typeclass. What module is it in?
20:08:43 <lispy> @hoogle Sequence
20:08:44 <lambdabot> Data.Sequence module Data.Sequence
20:08:44 <lambdabot> Text.Regex.Posix.Sequence module Text.Regex.Posix.Sequence
20:08:44 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
20:09:44 <silasm> Data.Sequence is a data Seq a, I'm looking for the typeclass Seq a v found here: http://hackage.haskell.org/package/container-classes-0.0.0.0/docs/Data-Containers.html#t:Sequence
20:11:46 <cmr> I'm working through Haskell Fast and Hard, and one of the solutions to an exercise (eta-reduce evenSum) is https://gist.github.com/cmr/a3616902880a57086f22. I'm a bit confused on how to read it. `where` creates some bindings, and the pattern matches declare functions?
20:11:51 <Twey> silasm: Well, it's there :þ
20:11:54 <Twey> Data.Containers
20:12:01 <Twey> You'll need the container-classes package
20:12:13 <silasm> not seeing that in Cabal though.
20:12:23 <silasm> ohh
20:12:30 <silasm> container-classes
20:12:44 <silasm> dangit, I was looking for container*s*
20:12:46 <silasm> thanks
20:12:48 <Twey> Heh
20:12:53 <Twey> No problem
20:14:24 <pavonia> cmr: The pattern matches are part of the function definion for accumSum
20:15:23 * hackagebot separated 0.0.4 - A data type with elements separated by values  http://hackage.haskell.org/package/separated-0.0.4 (TonyMorris)
20:15:41 <pavonia> cmr: It's just like a top-level function definition but the "where" makes it local to evenSum
20:16:43 <cmr> pavonia: so the inferred signature here is going to be accumSum :: Integral a => a -> [a] -> a ?
20:16:59 <cmr> oh I suppose I could have figured that out with ghci
20:17:30 <pavonia> cmr: I think so
20:30:24 * hackagebot egison 3.2.3 - The programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.2.3 (SatoshiEgi)
20:46:15 <pingu> I'm trying to optimize a checksumming algorithm I'm writing and have finally run out of ideas
20:46:18 <pingu> https://github.com/christian-marie/xxhash/blob/master/src/Data/Digest/XXHash.hs
20:47:02 <pingu> Most of the time is spent in allocation in between stageOne and processBody
20:47:07 <divyansr> > take 5 [1..100]
20:47:09 <lambdabot>  [1,2,3,4,5]
20:47:36 <pingu> I've tried returning unboxed tuples and using an IOref, is haskell just bad at quickly modifying state?
20:50:09 <Cale> pingu: I don't know what the problem is yet, but the bang patterns in stageOne are redundant
20:50:23 <Cale> (all of them are)
20:51:56 <Cale> First of all, matching against a constructor of anything which isn't a newtype forces the evaluation of that value already, secondly, any constructor application whose constructor has strict fields is translated into an expression which seq's the values of those fields.
20:53:09 <Cale> (this guarantees that vx v i will be evaluated for each of the ak ik pairs, and since it's a strict arithmetical expression in terms of those, we know in particular that the ik will be evaluated.)
20:53:35 <pingu> Cale: Right, so it has no effect on unboxing of the Word32
20:56:09 <Cale> In processBody, the bang pattern on ptr is similarly pretty redundant, since the first thing evaluation of this is going to do is to evaluate the guard "ptr <= ...", and the first thing that <= will do is evaluate its first argument.
20:57:13 <pingu> Cale: you're right, I may have just been paranoid with these bangs as I don't see a cost to them? I'll remove those that seem redundant now...
20:57:30 <Cale> Well, it's okay, but they can be distracting
20:58:03 <Cale> (Usually I try to use the smallest number of strictness annotations required, which makes for less reasoning about why they need to be there)
20:58:38 <Cale> How often do you expect this first conditional in processBody to be true?
20:59:38 <pingu> Cale: almost always
20:59:43 <Cale> oh, right, yes
21:00:25 <pingu> Cale: the actual slowness seems to be time spent in alloc going between stageOne and processBody, I'm not sure if I actually *can* improve upon it
21:01:13 <pingu> as the C implementation simply updates in place, whereas we seem to need to allocate a new Acc (accumulator) on the heap and thus clean up the old one?
21:01:14 <Cale> Well, we could probably eliminate the use of the Acc type altogether.
21:01:23 <Cale> yes
21:02:00 <Cale> Though GHC tends to be really pretty good at cleaning up lots of short-lived garbage quickly, the allocation definitely has a time cost
21:02:20 <pingu> right. This seems to be a major time cost for me unfortunately.
21:03:15 <pingu> Cale: I tried removing the Acc type alltogether by returning a (#,,,#) unboxed tuple and simply sending in a1 a2 a3 a4 accumulator values individually
21:03:26 <pingu> which improved performance by 5-10% but wasn't worth the readability at all
21:03:41 <Cale> You might've also just tried more function parameters
21:03:57 <Cale> hmm
21:04:18 <pingu> Cale: so was this approach flawed? https://github.com/christian-marie/xxhash/blob/80a8d719b697c259a2f1ef98cabb182379bc20d2/src/Data/Digest/XXHash.hs
21:05:31 <pingu> Cale: I figured none of the approaches I'm used to would work as I'm always allocating a new object
21:05:53 <pingu> So I tried an IORef, but I dont really get those. And that didn't seem to work either. Though it wasn't terribly slower.
21:06:06 <Cale> You should note that of course, Word32 values, even if you stick them in an unboxed tuple, are pointers to code which returns a Word32 on the stack when entered.
21:06:43 <Cale> If you really want to go crazy, you could use unboxed arithmetic :P
21:08:13 <Cale> Hey, also, did you try your original code without unbox-strict-fields?
21:08:33 <pingu> Cale: yes I did, it's considerably faster with them
21:08:38 <pingu> around 30%
21:08:48 <Cale> okay, cool
21:09:41 <pingu> How much is your suggestion of unboxed arithmetic a joke?
21:09:47 <pingu> Because I've not looked into it.
21:09:58 <pingu> Will it allow me to update word32s inplace?
21:10:04 <Cale> Well, if you're serious about making this run as fast as C, you'll probably need to do that.
21:10:13 <Cale> It won't update in-place
21:10:25 <Cale> (at least, not as far as I know)
21:10:34 <silasm> pingu: is there a reason you're not using ST? (why IORefs?)
21:10:34 <pingu> So I'll still have the allocation problem won't I?
21:11:05 <Cale> silasm: Well, that's orthogonal to the performance thing :)
21:11:06 <pingu> silasm: I'd touched IORefs before, never used ST. That's the only reason.
21:11:45 <pingu> But IORefs weren't gonna work it seems as the modification of one still allocates a new object on the heap
21:11:48 <silasm> Cale: how is it orthagonal to performance? When he says "update in place" I think ST.
21:12:01 <Cale> silasm: updating IORefs in place is also in place
21:12:13 <Cale> (though he could be doing that here more than he is)
21:12:32 <flebron> merijn: Posted 5 hours ago, 0 votes, 0 comments haha
21:13:46 <Cale> I should actually be a little smarter about my approach here. It's not really safe to try to guess how GHC is going to handle everything at such a low-level, we should be looking at the core at least.
21:14:25 <Cale> Let me just grab this module and try compiling it and see what I get
21:14:29 <pingu> Cale: I had a look at the core, I'm not particularly experienced with them though.
21:14:38 <pingu> It appears to be inlining just fine.
21:15:04 <pingu> But most of my time is spent in allocation :(
21:15:05 <pingu>      hashByteString.\.processBody Data.Digest.XXHash         118    14548993   99.8   80.0    99.8   80.0    629 931135512
21:15:13 <pingu> 80% being allocation
21:15:45 <pingu> Oh, wait. I'm totally reading that wrong. It's 80% of all allocation.
21:16:08 <Cale> right
21:16:19 <pingu> So what it's saying is that for every byte of input it's allocating an extra four bytes just to process it.
21:16:45 <pingu> It doesn't blow out memory as it's garbage collected immediately. Just slow.
21:16:49 <Cale> seems reasonable
21:16:50 <Cale> yeah
21:18:17 <pingu> So. Maybe this is just ... as fast as haskell will get. It's faster than zlib's crc32 (c code). The algorithm itself though is meant to be *much* faster than crc32 though.
21:21:23 <Cale> pingu: http://lpaste.net/98174
21:22:33 <Cale> This is without Acc
21:22:51 <pingu> Cale: so, what instead of Acc?
21:23:05 <Cale> This is the version you posted with the unboxed tuple
21:23:12 <pingu> Ah. right.
21:23:33 <pingu> Cale: that was the fastest, but only marginally.
21:24:21 <Cale> So yeah, you can see the four Word32 objects being built here with the W32# data constructor
21:24:52 <pingu> I can.
21:25:01 <pingu> I've not seen enough cores to know if that's bad though.
21:25:14 <Cale> It might not be bad, but it's allocation
21:25:33 <pingu> Cale: right. Is there any reason those can't be unboxed?
21:25:41 <Cale> nope, we could do that
21:27:39 <Cale> Let's try using Word# directly. You'll notice that the code also has lots of narrow32Word# operations, which will presumably compile to some appropriate masking on 64 bit architectures
21:28:15 <pingu> Cale: Yeah, I figured those looked pretty good.
21:28:39 <joelteon> is there a capistrano-y tool written in Haskell?
21:28:47 <joelteon> I like capistrano but I also would like to keep this project to one language
21:30:04 <pingu> Cale: I'm not quite sure how to drive this MagicHash thing. What am I looking for as a type?
21:30:28 <melonmechanic> anybody interested in critiquing my first decent haskell program? http://lpaste.net/98173
21:30:40 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html#t:Word-35-
21:31:02 <Cale> (this is going to be at least mildly painful)
21:31:12 <dibblego> melonmechanic: did you run hlint on it?
21:31:18 <melonmechanic> dibblego yup
21:31:19 <pingu> Cale: That's fine. Um. I *need* 32 bits though.
21:31:35 <pingu> so this won't work on 64 bit hardware?
21:31:37 <Cale> Well, that's what the narrowing is for.
21:32:44 <pingu> Cale: Ah. Right. Okay. Give me a second to try to get these imported...
21:32:45 <Cale> To be honest, I don't know how the compiler backends treat the narrowing primops. Maybe they're smart enough to use half-registers and stuff in the presence of them.
21:33:15 <Cale> (I don't actually mess around at this level much, I've basically just watched other people do it)
21:34:16 <Cale> (Where is Don Stewart when we need him? :)
21:34:40 <pingu> You've been most helpful so far.
21:35:13 <Cale> I guess what we could do it just grab this core and splice it back in, lol.
21:35:32 * hackagebot glapp 0.1.0.0 - An OpenGL micro framework.  http://hackage.haskell.org/package/glapp-0.1.0.0 (SchellScivally)
21:37:04 <pingu> Cale: Well it's already starting to look like a core :P
21:38:46 <Cale> Oh, cute, I see what it's doing now
21:39:09 <Cale> At first, I wondered why it split up the computation into two parts, binding a let-bound Word# and then doing more stuff with that
21:39:27 <Cale> It's because in order to rotate, it's doing two shifts and gluing them together
21:39:58 <Cale> So that's easy at least
21:40:23 <pingu> Cale: something like... #define rotl32(x,r) ((x << r) | (x >> (32 - r))) ?
21:41:35 <pingu> So there's a timesWord
21:41:38 <pingu> and a timesWord2
21:41:53 <pingu> one which returns a tuple of two words. I presume one is overflow?
21:42:24 <Cale> yeah
21:44:24 <Cale> (Just a moment, let me see if I can get this to compile... just adapting things a bit)
21:45:05 <AfC> pingu: hey
21:45:19 <pingu> AfC: hey
21:45:46 <pingu> Cale: Oh. I was too. I would like to see yours.
21:46:12 <pingu> I am wishing there was a rotatelword primitive
21:47:45 <zRecursive> Is the unboxed vector "(# ... #)"  same as C's array ?
21:48:27 <Cale> zRecursive: kind of sort of
21:48:57 <pingu> zRecursive: I get the impression ghc tries to keep the elements in registers
21:49:07 <Cale> You can sort of think of it like a C struct, but I'm not sure that's really a reliable way to think about it. I think GHC may still registerise the components
21:49:18 <Cale> (If it can)
21:49:26 <Cale> yeah
21:50:27 <Cale> wow kind errors such fun
21:50:34 * hackagebot glapp 0.1.0.1 - An OpenGL micro framework.  http://hackage.haskell.org/package/glapp-0.1.0.1 (SchellScivally)
21:50:38 <zRecursive> pingu: registers enough ?
21:50:46 <pingu> Cale: do you know how to write a literal word32#? Is there a constructor?
21:50:58 <pingu> zRecursive: not sure what you mean by that?
21:51:14 <Cale> GHC.Word exposes W32#
21:51:21 <pingu> Cale: thanks
21:51:25 <zRecursive> pingu: maybe using heap
21:51:37 <zRecursive> sometimes
21:52:45 <pingu> Cale: yeah I'm getting some awesome type errors too :D
21:57:04 <Cale> pingu: http://lpaste.net/98176
21:57:13 <Cale> Try that, tell me if it's any better :)
21:57:24 <Cale> It looks like maybe it'll do less allocation?
21:58:06 <pingu> Cale: that's what I was trying to write then.
21:58:37 <pingu> Cale: Awesome :D Looks good. I'll give it a run.
21:59:24 <AshyIsMe> schell: did you just upload glapp?  cos your github project seems to be still private
21:59:36 <pingu> Cale: I like your rot32 implementation there ;)
21:59:43 <schell> AshyIsMe: shoot - yeah
21:59:47 <schell> thanks
22:00:07 <Cale> pingu: It's not mine, it's GHC's
22:00:22 <Cale> pingu: I ripped that code out of the core, and stuffed it back into the source :)
22:00:25 <pingu> Oh. Well GHC is clever also then
22:00:40 <pingu> Cale: It's certainly faster.
22:00:47 <Cale> (with a few tweaks to actually make it compile)
22:00:55 <pingu> the fastest one yet, actually.
22:01:11 <pingu> still spends the same ratio of time in allocation though :(
22:01:14 <carter> cmr:did you get your answer?
22:01:37 <schell> AshyIsMe: publicized!
22:01:56 <cmr> carter: yes
22:02:02 <cmr> carter: thanks :)
22:02:13 <AshyIsMe> schell: cool
22:02:14 <pingu> Cale: thanks for that, it's certainly an improvement
22:02:15 <Cale> pingu: this is what stageOne looks like at a lower level still: http://lpaste.net/98178
22:03:38 <Cale> I'm going to take the fact that there are no instructions in that which start with l as some kind of a win
22:04:16 <Cale> Did the allocation move?
22:04:28 <pingu> Cale: it certainly looks awesome. I'll stick some cost centers around to check.
22:04:28 <Cale> (You'll have to rerun the profiler)
22:04:45 <Cale> btw, you are compiling with -O2 and profiling off when testing raw performance, yeah?
22:05:00 <pingu> Cale: negative, all relative to profiling on.
22:05:05 <Cale> ah, okay
22:05:10 <Cale> well, -O2 at least?
22:05:25 <pingu> Cale: nope, I'll see what that does for me
22:05:28 <Cale> oh
22:05:29 <Cale> haha
22:05:36 <Cale> It may do a good deal
22:05:43 <astropirate> Hello all
22:06:16 <astropirate> newb question:
22:06:24 <astropirate> is haskell a high level enough of a language for web developement?
22:06:28 <pingu> Cale: didn't do anything
22:06:32 <Cale> astropirate: yes
22:06:34 <cmr> astropirate: sure, see yesod
22:06:38 <pingu> astropirate: sure, there's a few frameworks out there
22:06:45 <astropirate> right
22:06:49 <Cale> astropirate: There are multiple well-developed and maintained web frameworks
22:06:50 <tippenein> snap, scotty, yesod, happstack
22:06:51 <astropirate> but what i mean is
22:06:58 <astropirate> even C++ has web frameworks
22:07:03 <astropirate> but that would be a very bad choice
22:07:23 <Cale> astropirate: Haskell is a very good choice for web backends in practice
22:07:25 <jfischoff> astropirate: we use yesod at work. It works great
22:07:26 <astropirate> what i mean is does it allow for fast develoement
22:07:34 <jfischoff> yes
22:07:36 <astropirate> hmm
22:07:37 <astropirate> alright
22:07:41 <astropirate> will take a look at frameworks
22:07:42 <astropirate> thanks guys
22:07:45 <Cale> I say this having worked professionally on at least one web application backend in Haskell :)
22:07:48 <jfischoff> if you know how to use
22:07:50 <jfischoff> it
22:08:11 <astropirate> another newbie question:
22:08:19 <Cale> astropirate: The main three in no particular order are Happstack, Snap, and Yesod
22:08:41 <astropirate> how is the learning curve... Ihave been doing the learn you a haskell book.. just got to monads chapter.
22:08:45 <johnw> that's in alphabetical order
22:08:59 <astropirate> with c++ even if yhou develope for 10 years, you don't know all the gotchyas
22:09:18 <carter> astropirate: in haskell its "you don't know all the amazing tricks"
22:09:24 <tippenein> astropirate: for me it's more like learning plateus
22:09:41 <carter> i've been using haskell since like 2004
22:09:46 <carter> and i'm still learning new great ways to enginer
22:10:14 <astropirate> but the applications will be fine - mintainable even if you don't know all the "cool tricks"?
22:10:15 <Cale> astropirate: You'll know all the gotchas inside of a couple years. You'll be learning new things about how to use the language in a decade.
22:10:26 <carter> yup
22:10:35 <astropirate> sweet
22:10:36 * hackagebot texmath 0.6.6 - Conversion of LaTeX math formulas to MathML or OMML.  http://hackage.haskell.org/package/texmath-0.6.6 (JohnMacFarlane)
22:10:54 <carter> the gotchas are managable inside the first year of heavy use
22:11:12 <carter> in a decade you'll keep on learning about great new abstractions that help even more
22:11:12 <Cale> astropirate: As to whether other people's code will be easy to understand, it generally depends on a lot :)
22:11:12 <tippenein> badly written haskell is about as concise as really well written python as far as I've seen
22:11:23 <carter> true, as Cale  says
22:11:26 <carter> otoh, types are a thing
22:11:33 <carter> which helps
22:11:42 <carter> learning edwardk's stuff has been a huge learning experience
22:11:45 <Cale> tippenein: Maybe on average, but badly written Haskell can be *really* bad :)
22:11:58 <tippenein> fair enough. perhaps I haven't seen that yet
22:12:15 <Cale> Though at least you can still kind of reason about it, as long as it doesn't use too much low-level hacks
22:12:44 <astropirate> Whats the market like? for finding developers that are proficient with haskell?
22:13:08 <astropirate> sorry for all the interview like questions :p
22:13:11 <carter> astropirate: any company that is actually hiring gets too many qualified candidates
22:13:12 <Cale> astropirate: Kind of small, but also there's no shortage of high quality people looking.
22:13:14 <nstdloop3> What's an easy way to drop the last number from an int? Right now I'm using read . init . show
22:13:29 <nstdloop3> which is not happy with some numbers or repeated application
22:13:35 <pingu> Cale: the allocation certainly has moved. Not sure where yet.
22:13:35 <johnw> nstdloop3: `div` 10?
22:13:38 <Cale> nstdloop3: n `div` 10?
22:13:40 <carter> digit?
22:13:52 <pingu> Cale: there is none left in stageOne, which is good :D
22:13:56 <nstdloop3> *facepalm*
22:15:43 <Cale> Wait, what the heck...
22:16:11 <Cale> The definition of stageOne in the core isn't being referenced from anywhere else... perhaps it was inlined.
22:16:25 <pingu> Cale: it was inlined
22:16:42 <Cale> yeah
22:16:44 <pingu> Cale: I'm pretty sure of that as I removed the exports earlier to get a cleaner core
22:16:51 <Cale> cool
22:17:02 <pingu> I still can't find the fscking allocations though
22:17:47 <pingu> I'm resorting to sticking cost centres in the guards
22:18:08 <Cale> We should probably finish unboxing everything
22:19:12 <pingu> Cale: There's not that much to gain from unboxing the rest of the functions
22:19:19 <pingu> and a lot of readability to lose
22:19:55 <Cale> Well, processBody specifically
22:20:06 <pingu> Cale: ah. Right.
22:20:19 <Cale> Well, actually
22:20:53 <Cale> The peekLE32's will allocate, we might be able to do something about that
22:21:17 <Cale> But I think the rest of the allocation is just constructing the XXHash (Word32) at the end
22:21:52 <pingu> Cale: 1gb allocation for a 200mb input?
22:22:07 <pingu> Cale: I think it's more than that. I just can't find it.
22:22:27 <Cale> pingu: That's totally reasonable if they're allocating boxed Word32's
22:22:38 <Cale> But I think that's being eliminated actually
22:22:39 <dleedev> hi, where can I get a list of short alternatives to common functions? like <>, <$>, etc.
22:23:13 <jle`> dleedev: shorter than <> ?
22:23:24 <Cale> jle`: I think he means in general
22:23:31 <pingu> dleedev: Control.Applicative on hackage has a few like that
22:23:32 <jle`> oh you mean things like <>, <$>
22:23:59 <Cale> Yeah, have a look at Control.Applicative and Control.Arrow (keeping in mind that (->) is an instance of Arrow)
22:24:01 <jle`> goodbye
22:24:12 <Cale> That's pretty much most of what's actually tasteful to use
22:24:17 <jle`> he left :/
22:24:20 <Cale> oh
22:24:22 <jle`> oh he's back
22:24:38 <Cale> dleedev: Yeah, have a look at Control.Applicative and Control.Arrow (keeping in mind that (->) is an instance of Arrow). That's pretty much most of what's actually tasteful to use.
22:25:20 <dleedev> Cale: is (->) a function?
22:25:38 <Cale> at the type level
22:25:43 <Cale> (->) a b = a -> b
22:25:43 <pingu> Cale: found it! :D
22:25:47 <Cale> pingu: where?
22:25:52 <pingu> Cale: *all* of the extra allocation is being done in peek32
22:26:01 <dleedev> Cale: so there are functions specifically for the type level?
22:26:03 <pingu> well, peekLE32
22:26:12 <dleedev> Cale: what other functions are there for the type level? Is => one of them?
22:26:23 <pingu> Cale: so, I'll try to unbox that
22:26:25 <Cale> pingu: That makes sense, but I'm not sure I see where it is in the core that I'm staring at
22:27:08 <jle`> dleedev: there are a lot of type leve functions
22:27:12 <jle`> dleedev: Maybe is one
22:27:15 <Cale> Here they're all turning into applications of readWord32OffAddr# and the unboxed results are being used directly
22:27:26 <pingu> Cale: Hmmn :\
22:27:33 <pingu> Maybe our compilers are doing different things.
22:27:34 <dleedev> jle`: Maybe is a function?
22:27:37 <jle`> dleedev: Maybe turns a type like Int
22:27:42 <pingu> Cale: I'll try turning all profiling off
22:27:42 <jle`> and turns it into a Maybe Int
22:27:53 <jle`> just like how Just takes a 5 and turns it into Just 5
22:27:53 <dleedev> jle`: then wouldn't all types be functions?
22:28:00 <jle`> Int is not a type function
22:28:05 <jle`> it has kind *
22:28:18 <jle`> Maybe has kind * -> *
22:28:19 <dleedev> jle`: what about all parameterized types?
22:28:29 <Cale> dleedev: Yeah, those are type-level functions
22:28:39 <dleedev> jle`: IO, [], etc are all functions?
22:28:46 <Cale> yeah, at the type level
22:28:59 <jle`> (->) is an infix type function
22:29:04 <Cale> Which is just another way of saying that they're parameterised
22:29:24 <Cale> IO takes the type Integer to the type IO Integer
22:29:28 <jle`> like (->) is a type function that takes two types a and b and returns a new type (->) a b, or a -> b
22:29:46 <Cale> They all act pretty straightforwardly (though with extensions, you can have type-level functions which do more interesting things)
22:30:00 <dleedev> what does type (a -> b) mean?
22:30:02 <zRecursive> a bit like Template in C++ ?
22:30:25 <dleedev> zRecursive: that's kind of how I understood parameterized types
22:30:32 <Cale> dleedev: (a -> b) is the type of (value-level) functions which take an argument of type a, and produce a result of type b
22:30:45 <zRecursive> dleedev: me too
22:30:48 <Cale> Like Integer -> String
22:31:06 <Cale> f :: Integer -> String, means that f accepts an argument of type Integer, and produces a result of type String
22:31:14 <Cale> We can also write  f :: (->) Integer String
22:31:34 <zRecursive> beautiful
22:31:45 <dleedev> Cale: so does the (->) always return a type that can only be applied to functions?
22:31:46 <Cale> But usually that's a bit ugly, so we'll avoid it (there are some good examples where it's nice though)
22:32:13 <Cale> dleedev: Well, it takes two types, and produces the type of functions between them
22:32:21 <Cale> :k (->)
22:32:22 <lambdabot> * -> * -> *
22:32:24 <Cale> :k (->) Integer
22:32:25 <lambdabot> * -> *
22:32:27 <Cale> :k (->) Integer String
22:32:28 <lambdabot> *
22:32:40 <Cale> * is the kind of types which have values in them
22:33:01 <Cale> * -> * is the kind of type-level functions which take a type and produce another
22:33:06 <dleedev> Cale: so all parameterized types (IO, [], Maybe, etc.) are of type (a ->), right?
22:33:20 <Cale> They're of kind * -> *
22:33:29 <Cale> :k []
22:33:30 <lambdabot> * -> *
22:33:32 <Cale> :k IO
22:33:32 <cmr> dibblego: types have kinds, in the way that functions have types
22:33:32 <lambdabot> * -> *
22:33:35 <Cale> :k Maybe
22:33:36 <lambdabot> * -> *
22:33:46 <dleedev> cmr: ah, thanks
22:33:49 <dibblego> cmr: yes I know, thanks
22:33:53 <cmr> oops
22:33:58 <dibblego> oh I see, sorry
22:34:25 <Cale> dleedev: Unlike C++, we can have higher-kinded types as well... I wonder if I can demonstrate this with the bot :)
22:35:09 <Cale> @let data GenTree f a = GT a (f (GenTree f a))
22:35:11 <lambdabot>  Defined.
22:35:15 <Cale> :k GenTree
22:35:16 <lambdabot> (* -> *) -> * -> *
22:35:18 <Cale> :k GenTree []
22:35:19 <lambdabot> * -> *
22:35:22 <dleedev> are all values a function in haskell?
22:35:27 <Cale> No
22:35:37 <dleedev> for example, is 1 :: () -> Int
22:35:38 <dolio> You can do higher-kinded types in C++. It's just really terrible.
22:35:41 <dibblego> higher-kinds can be done in C++ https://gist.github.com/maxpow4h/7466974
22:35:42 <Cale> Only values whose type is (a -> b) for some types a and b are called functions.
22:35:55 <Cale> 1 :: Int isn't a function
22:35:56 <dleedev> because you need the domain?
22:35:58 <zRecursive> there are primitive value , arenot there ?
22:36:03 <Cale> but  const 1 :: () -> Int  is a function
22:36:35 <zRecursive> :t ()
22:36:36 <lambdabot> ()
22:36:55 <Cale> If we were willing to call 1 :: Int a function, then we'd call anything a function, and so the word would lose any distinction from the word 'value'
22:36:57 <zRecursive> :t void
22:36:58 <lambdabot> Functor f => f a -> f ()
22:37:24 <Cale> So in order for "function" to mean something different from "value", we only call values functions when their type is A -> B for some types A and B
22:37:37 <Cale> (i.e. when it's valid to apply them to an argument)
22:38:09 <Cale> (Note that B might itself be a function type, as is the case for multi-parameter functions)
22:38:20 <dleedev> but there's no different word for functions in the value/function realm and functions in the type realm?
22:38:33 <dleedev> :t ->
22:38:34 <lambdabot> parse error on input `->'
22:38:34 <haasn> dleedev: http://conal.net/blog/posts/everything-is-a-function-in-haskell
22:38:38 <dleedev> :t (->)
22:38:39 <Cale> :k (->)
22:38:39 <lambdabot> parse error on input `->'
22:38:39 <lambdabot> * -> * -> *
22:38:53 <Cale> The :k command looks up kinds of type-level things
22:38:54 <dibblego> dleedev: (->) is not a type, it is a type constructor that you pass types value to
22:39:07 <dibblego> dleedev: if you pass two type values to (->) you will have a type
22:39:10 <dleedev> dibblego: is a type constructor a function as well?
22:39:14 <jle`> dleedev: values have types, types have kinds
22:39:19 <dibblego> dleedev: yes, it is a function that takes types as arguments
22:39:28 <Cale> Some people would still refer to (->) as a "type", but I tend to avoid that whenever possible.
22:39:29 <dibblego> (->) Int String -- is a type
22:39:40 <dibblego> also written as Int -> Stringf
22:39:44 <dibblego> s/f//
22:39:45 <dleedev> jle`: values have types, but functions aren't values. do functions have types?
22:39:46 <zRecursive> type's type  is kind
22:39:57 <Cale> dleedev: Functions *are* values
22:39:57 <haasn> functions *are* values
22:40:02 <haasn> :)
22:40:04 <Cale> dleedev: But not all values are functions.
22:40:06 <jle`> functions are values, of type a -> b etc.
22:40:10 <dleedev> Cale: got it
22:40:39 <zRecursive> "function is value" is key of FP :)
22:40:51 <Cale> Oh, I suppose it's worth taking care that there are two ->'s in the notations we've been throwing around
22:40:58 <Cale> There's (->) at the type level
22:41:01 <dleedev> dibblego: so there's no different terminology for functions in the type level?
22:41:02 <Cale> and there's (->) at the kind level
22:41:16 <Cale> dleedev: "type level functions" or "type constructors"
22:41:17 <dleedev> Cale: what's the difference?
22:41:20 <dibblego> dleedev: sure, there is a type constructor, which is a function that accepts types and returns types
22:41:38 <dleedev> dibblego: but in the end, they are still "functions"?
22:41:41 <dolio> I don't think that's a good definition for 'type constructor'.
22:41:42 <Cale> dleedev: Well, (->) at the type level has kind * -> * -> *
22:42:04 <Cale> i.e. it takes two ordinary types, and produces another ordinary type
22:42:22 <dibblego> dleedev: Either is a type constructor, Either Int String is a type
22:42:29 <Cale> :k Either
22:42:30 <lambdabot> * -> * -> *
22:42:34 <Cale> :k Either Int
22:42:34 <lambdabot> * -> *
22:42:36 <Cale> :k Either Int String
22:42:37 <lambdabot> *
22:42:49 <dleedev> :k Maybe
22:42:49 <lambdabot> * -> *
22:42:53 <Cale> We can also ask for the kinds of type classes
22:42:56 <Cale> :k Show
22:42:57 <lambdabot> * -> Constraint
22:43:02 <Cale> :k Functor
22:43:03 <lambdabot> (* -> *) -> Constraint
22:43:04 <jle`> think of Maybe as type function...a function that takes a type and returns a new type.  Maybe applied to Int (as Maybe Int) returns a new type, written as Maybe Int
22:43:15 <dleedev> :k Monad
22:43:16 <lambdabot> (* -> *) -> Constraint
22:43:40 <Cale> Constraint is the kind of things which can occur to the left of an => in types
22:43:40 <jle`> that's why things like, say, Int can't be monads
22:43:49 <pavonia> :k (=>)
22:43:50 <lambdabot> parse error on input `=>'
22:44:09 <jle`> only things of kind (* -> *) can be monads
22:44:18 <jle`> also a common miscomprehension
22:44:19 <pingu> Cale: My core looks very well inlined and unboxed also. I think it's profiling being stupid.
22:44:21 <jle`> Maybe Int is not a monad
22:44:35 <Cale> pingu: How is the performance when you turn off profiling?
22:44:45 <pingu> Cale: it is in fact, faster than zlib's adler32 and crc32
22:44:53 <Cale> That sounds pretty cool
22:45:16 <pingu> which are both implemented in c, adler32 designed for speed
22:45:23 <dleedev> Cale: so what's (->) in the value level?
22:45:37 <Cale> dleedev: Well, it's part of a bunch of syntaxes
22:45:50 <jle`> yeah it's not really a first-class citizen of value land
22:45:52 <dleedev> Cale: you mean it has an overloaded meaning?
22:46:01 <jle`> no, it's used as syntax
22:46:06 <jle`> \x -> f x
22:46:12 <jle`> case x of y -> z
22:46:22 <jle`> the same way case, \, if, ::, etc.
22:46:25 <dleedev> jle`: ah, OK, so it's part of the language syntax
22:46:33 <jle`> yeah
22:46:37 <jle`> you can think of it like a keyword kinda
22:46:40 <Cale> yeah, it's a bit of punctuation in the value-level syntax
22:46:58 <dleedev> OK, so I kind of get what -> in type-land
22:47:01 <Cale> But \x -> y :: A -> B
22:47:08 <Cale> So, there's at least that :)
22:47:18 <dleedev> so is the difference between Alternative and Monoid simply a difference in type?
22:47:27 <jle`> well
22:47:30 <jle`> they are different things...
22:47:31 <Cale> :k Alternative
22:47:32 <lambdabot> (* -> *) -> Constraint
22:47:33 <dleedev> Alternative works on * -> *, while monoid works on *?
22:47:37 <Cale> :k Monoid
22:47:38 <lambdabot> * -> Constraint
22:47:43 <jle`> you mean kind, not type
22:47:44 <Cale> yes, that's a major distinction
22:47:52 <dleedev> jle`: yes, kind, not type
22:48:08 <dleedev> but is kind the only difference between Alternative and Monoid?
22:48:17 <dleedev> or is there an additional concept?
22:48:20 <jle`> well...they are conceptually different things
22:48:25 <Cale> But also Alternative is a subclass of Applicative
22:48:28 <jle`> like apples are different than cars
22:48:33 <dleedev> jle`: please explain
22:48:35 <Cale> and Applicative defines a whole bunch of other stuff
22:48:41 <apples> maybe i want to be a car :(
22:48:48 <Cale> :D
22:48:48 <jle`> apples: haha
22:48:49 <dleedev> :k Applicative
22:48:50 <lambdabot> (* -> *) -> Constraint
22:49:05 <haasn> is Alternative f  functionally distinct from (Applicative f, Monoid (f a)), for all the ‘a’s you need it to be a monoid with?
22:49:06 <jle`> there is a difference between the mathematical notion of a monoid
22:49:11 <jle`> and the haskell Monoid typeclass
22:49:42 <jle`> whenever you have something with a binary operator and an identity for that operator, you have a monoid
22:49:52 <jle`> for example, the integers under addition form a monoid
22:49:55 <jle`> but they are not a Monoid
22:50:06 <Cale> Well, the laws for Alternative f ought to say that empty and <|> define a monoid structure on f a for every a
22:50:08 <jle`> Alternative provides a binary operator on Monads
22:50:16 <jle`> and it also provides an identity for that operator
22:50:21 <jle`> so it forms a monoid over Monads
22:50:27 <jle`> but it is not a haskell Monoid
22:50:29 <Cale> On Applicative functors, more generally
22:50:33 <jle`> oh yes
22:50:35 <jle`> sorry
22:50:37 <silasm> jle`: Sum is not a Monoid?
22:50:45 <jle`> Sum is a Monoid, but Int is not
22:50:54 <silasm> eh...
22:50:56 <Cale> jle`: Sum Int is a monoid, if we're being picky
22:50:56 <dleedev> jle`: it is not a Haskell Monoid, but it is conceptually a monoid, no?
22:51:04 <jle`> dleedev: yes, that's what i'm trying to get at
22:51:10 <Cale> sorry, I meant silasm there
22:51:14 <jle`> there is a difference between mathematical monoids
22:51:15 <dleedev> jle`: I mean Alternative, not Sum Int
22:51:19 <jle`> and haksell Monoids
22:51:23 <jle`> yeah
22:51:29 <jle`> Alternative is a monoid over Applicatives
22:51:36 <jle`> because it provides a binary operator between two Applicatives
22:51:36 <Cale> jle`: It's not a big one, unless you mean the fact that Haskell doesn't *force* you to check the laws
22:51:38 <jle`> and an identity
22:51:45 <jle`> so it's a monoid, but not a Monoid
22:51:50 <dleedev> jle`: so Alternative is a monoid for types of kind * -> *, and Monoid is a monoid for types of kind *
22:51:53 <silasm> jle`: there isn't one if you don't define fail and actually follow the monoid laws, though, right?
22:51:58 <Cale> jle`: The Haskell Monoid class is meant to be used for types which are canonically mathematical monoids.
22:52:10 <silasm> well if you disregard fail, rather.
22:52:14 <jle`> Cale: I mean that there are things that are monoids but are not instances of Monoid
22:52:26 <Cale> Oh, okay, I suppose there are
22:52:40 <jle`> Applicative is a monoid, but not a Monoid
22:52:41 <dleedev> Cale: for instance, Alternative?
22:52:44 <jle`> er
22:52:45 <Cale> I guess that starts to become a philosophical question :)
22:52:46 <jle`> sorry
22:52:48 <jle`> Alternative
22:52:56 <jle`> Alternative is a monoid, but don't expect to find a Monoid instance
22:53:01 <Cale> Er
22:53:03 <dleedev> jle`: yes, I understand that
22:53:12 <Cale> Alternative functors *create* monoids
22:53:32 <dleedev> Cale: can you explain what you mean by *create*?
22:54:00 <Cale> When f is Alternative, and a is any type, then (f a) is a (mathematical) monoid with the unit being empty and operation being (<|>)
22:54:14 <jle`> ah, yes, sorry
22:54:35 <jle`> but you can't do things like <>, mconcat, mempty, etc, because it's not a Monoid
22:54:46 <Cale> So an Alternative functor produces infinitely many monoids, one for every type.
22:55:02 <shachaf> The relationship between Applicative and Alternative is interesting.
22:55:21 <Cale> Yeah, I'm not sure what laws ought to hold there, apart from monoid-ness.
22:55:34 <jle`> i asked earlier about why Applicative is required for Alternative
22:55:35 <shachaf> You have one thing with a type-varying operator -- f a -> f b -> f (a,b) -- and one with a non-varying operator -- f a -> f a -> f a
22:55:41 <dleedev> are there distinct terms for types of kind (* -> *) and types of kind (*)?
22:55:56 <shachaf> That reminds me of e.g. matrices, where you have multiplication (which is a category) and addition (which is a monoid) which behave sort of in this way.
22:55:57 <dleedev> for instance, concrete type vs abstract type
22:56:00 <jle`> type constructor, concrete type?
22:56:08 <shachaf> So maybe this could be related to abelian categories somehow?
22:56:10 <silasm> on the subject of monoids, they keep coming up in talks about parallelism, but isn't the only thing we really care about there associativity? (though identity is useful for folding).
22:56:23 <silasm> or is there something magical about the identity that I'm missing?
22:56:30 <Cale> dleedev: Usually type-level things whose kind is of the form k -> * for some kind k are called "type constructors", while things of kind * are called "types"
22:56:47 <jle`> silasm: we just don't care too much about semigroups i guess
22:56:57 <dleedev> Cale: what about * -> * -> *?
22:57:02 <silasm> jle`: heh, poor semigroups.
22:57:03 <dleedev> Cale: Either, for example
22:57:07 <Cale> That's also a type constructor (of two parameters)
22:57:24 <shachaf> And I'd expect these to interact a bit like a semiring or something.
22:57:34 <silasm> I guess it's easy enough to find an identity in most cases.
22:57:45 <shachaf> Is some sort of distributivity a law? Should it be?
22:57:47 <Cale> and my funny GenTree thing would also be called a type constructor, even though its parameter isn't of kind *
22:57:50 <Cale> :k GenTree
22:57:51 <lambdabot> (* -> *) -> * -> *
22:58:06 <Cale> :k GenTree IO
22:58:06 <lambdabot> * -> *
22:58:09 <Cale> :k GenTree IO Integer
22:58:10 <lambdabot> *
22:58:12 <shachaf> GenTree being Cofree?
22:58:17 <Cale> yeah
22:58:23 <dleedev> how is * -> * -> * -> * different from (* -> *) -> * -> * /
22:58:25 <dleedev> ?
22:58:33 <jle`> same way as for types
22:58:41 <jle`> :t map
22:58:42 <lambdabot> (a -> b) -> [a] -> [b]
22:58:59 <Cale> dleedev: -> associates to the right
22:59:11 <dleedev> Cale: ah, thanks
22:59:14 <Cale> dleedev: So * -> * -> * -> * means * -> (* -> (* -> *))
22:59:30 <Cale> while (* -> *) -> * -> * means (* -> *) -> (* -> *)
22:59:36 <jle`> isn't it cute that we have currying for types
22:59:44 <jle`> if it could be called currying
22:59:51 <Cale> It's amazing that we have kinds
23:00:21 <dleedev> Cale: that association is kind of confusing, no?
23:00:26 <Cale> and in the 20 some odd years that Haskell has had all these kinds, Java and C# and all the other languages which added systems for generics completely neglected them
23:00:32 <jle`> dleedev: it's the same as for normal functions, so you kind of get used to it
23:00:41 <dleedev> Cale: since *during* construction, the association is to the left: Either Int String is (Either Int) String
23:00:44 <jle`> :t (+)
23:00:45 <lambdabot> Num a => a -> a -> a
23:00:49 <shachaf> Haskell doesn't actually have kinds explicitly, does it?
23:00:52 <Cale> dleedev: Well, that's the corresponding things
23:01:01 <jle`> function application associates to the left
23:01:11 <Cale> dleedev: because the arrows are pointing in the direction that they are :)
23:01:15 <jle`> but function type declarations associate to the right
23:01:28 <shachaf> Use <- instead of -> and it'll be left-associative.
23:01:29 <shachaf> Magic!
23:01:45 <dleedev> jle`: actually, you're right, I guess in type declaration it's right associative as well
23:01:54 <Cale> yes
23:02:01 <jle`> yes it's the whole basis of currying
23:02:07 <dleedev> hmm... we just get used to it
23:02:08 <Cale> f :: A -> (B -> (C -> D))
23:02:15 <shachaf> [b] <- [a] <- (b <- a)
23:02:18 <Cale> ((f x) y) z
23:02:29 <dleedev> btw, is partial application considered "currying" in haskell?
23:02:38 <Cale> (where x :: A, y :: B, z :: C)
23:02:49 <Cale> dleedev: The currying has already happened
23:03:04 <dleedev> i recently read some code where "currying" applied to filling in the fst of a tuple
23:03:16 <Cale> Currying is the process of taking a function which operates on pairs (or other tuples), and turning it into a function of the first component which produces another function
23:03:25 <Cale> :t curry
23:03:25 <jle`> currying is the process of turning a function of type (a,b) -> c into a function of type a -> (b -> c)
23:03:25 <lambdabot> ((a, b) -> c) -> a -> b -> c
23:03:34 <jle`> thank you mr cale
23:03:37 <shachaf> Most people misuse the word "currying" (and, in Haskell, "partial application", to the extent that it makes sense to talk about it).
23:03:42 <Cale> i.e.  ((a, b) -> c) -> (a -> (b -> c))
23:04:00 <shachaf> My recommendation is not to use it at all.
23:04:01 <dleedev> jle`: but when you said "yes it's the whole basis of currying", you weren't referring to this tuple-based currying, right?
23:04:20 <jle`> heh
23:04:23 <Cale> dleedev: He was referring to the fact that functions are all already in curried form
23:04:37 <dleedev> Cale: but not "curried" in the tuple-sense of the word
23:04:42 <shachaf> Before figuring out the technical meaning, anyway.
23:04:42 <Cale> i.e. we don't tend to write multiparameter functions as functions on pairs, but instead as functions which produce other functions
23:04:57 <dleedev> Cale: right, so are both called "currying"?
23:05:06 <Cale> dleedev: Well, currying vs. curried
23:05:12 <jle`> a -> b -> c doesn't 'curry' anything
23:05:16 <jle`> but
23:05:32 <jle`> we have curried functions a -> (b -> c), from functions (a,b) -> c
23:05:32 <Cale> currying is the process of taking functions on pairs and turning them into ... curried functions :)
23:05:36 <dleedev> Is (Either Int) a curried type?
23:05:39 <shachaf> Currying is a transformation you can do to turn a function into another function.
23:05:40 <Cale> (which are functions that produce other functions)
23:05:48 <dleedev> ... or curried kind?
23:05:53 <Cale> dleedev: No, but it's a partially applied type constructor.
23:05:57 <shachaf> "curried" as an adjective means that you used this transformation.
23:06:12 <Cale> dleedev: Application is what you do with a function and its argument
23:06:20 <shachaf> So maybe "in f x y = ..., f is curried" doesn't even make sense to say.
23:06:34 <dleedev> shachaf: but f x is curried
23:06:36 <Cale> Partially applying a function means applying it to some parameters in such a way that the result is still a function.
23:06:45 <shachaf> dleedev: No, f x is just a function.
23:06:48 <dleedev> Cale: and is that the same thing as currying?
23:06:51 <Cale> no
23:06:55 <shachaf> sigh
23:07:00 <haasn> there's no technical way to “partially apply” a function
23:07:04 <haasn> in haskell
23:07:11 <dleedev> sorry, what's the difference between partially apply and curry?
23:07:29 <silasm> dleedev: curried functions allow easy partial application
23:07:33 <Cale> dleedev: Currying we said was turning functions of type (a,b) -> c into functions of type a -> (b -> c)
23:07:40 <jle`> curry transforms the type of a function
23:07:46 <jle`> partially apply...partially applies a function
23:07:54 <jle`> you can see that they are somewhat distinct things
23:07:54 <bitemyapp> Having problems with Fay IDE (fay-server), any ideas? Google isn't helping much: http://i.imgur.com/uogmE0Y.png
23:07:58 <Cale> dleedev: Partial application is taking a function, say of type a -> (b -> c), and applying it to some value of type a to get a function b -> c
23:08:06 <silasm> dleedev: because applying the first argument results in a function which consumes the rest, you can simply give a function fewer arguments than it requires and it's partially applied.
23:08:31 <dleedev> jle`: OK, so those two are separate things in Haskell
23:08:32 <Cale> (i.e. we're not done applying it, there's at least one other argument we eventually have to supply before we get something which isn't a function)
23:08:41 <Cale> dleedev: Does that make sense?
23:08:48 <dleedev> Cale: yes, I do
23:08:54 <jle`> my 'whole basis of currying' comment was a bit unhelpful i'll admit. i meant that right associativity makes it less painful to write the types of curried functions
23:09:01 <dleedev> Cale: it's just that jle` said "yes it's the whole basis of currying"
23:09:27 <Cale> jle`: Well, if we have already-curried functions, it would be really obnoxious if function application associated to the right
23:09:29 <jle`> if ->'s associated to the left, writing the type signatures of curried functions would be a lot more annoying
23:09:34 <Cale> er, dleedev rather
23:09:38 <jle`> so it's not really the 'basis'
23:09:38 <Cale> and that
23:09:39 <jle`> my bad
23:10:10 <jle`> in haskell we have very few non-curried functions, so right associativity of -> reflects the more useful associativity
23:10:18 <Cale> dleedev: Applying a function to a bunch of parameters would require lots of parens if function application associated to the right instead of the left
23:10:31 <Cale> i.e. you'd have to write ((f x) y) z every time, explicitly
23:10:44 <jle`> ...are there even any non-curried functions in prelude?
23:10:45 <Cale> and yeah, at the type level, it's similar
23:10:48 <dolio> Now you're programming in Roy. :)
23:10:56 <dleedev> Cale: but you also wouldn't have to write f ( g ( h x ) )
23:10:58 <jle`> (fst doesn't count)
23:11:06 <Cale> jle`: tee hee
23:11:13 <silasm> one of the main things keeping me from trying scheme/lisp and such is the difficulty of partially applying functions.
23:11:17 <Cale> dleedev: That's true
23:11:24 <jle`> dleedev: that case is a lot less common than the other case
23:11:25 <dleedev> Cale: I guess that's why there's f . g . h x
23:11:36 <Cale> Or f . g . h $ x rather
23:11:43 <Cale> (Or  f . g $ h x )
23:11:44 <dleedev> Cale: ah, yes
23:11:47 <jle`> unless h :: a -> b -> c
23:11:55 <jle`> but
23:11:58 <jle`> that's probably not what you meant
23:12:06 <jle`> given your previous example that i missed :P
23:12:20 <dleedev> thanks all, gotta got for a bit, but I'll be back in a few minutes
23:14:29 <mada>  /quit
23:14:45 <bitemyapp> silasm: that never stops getting annoying. The lack of currying. Partial application gets worse in the absence of types because you can end up not applying something to enough arguments or trying to apply a value the f already returned.
23:15:43 <jle`> well curry-by-default closes the door on things like default arguments or polymorphism on arity
23:16:03 <Cale> pingu: I'm glad we got your code running fast. It's good to know that I can emulate Don Stewart from time to time when necessary :)  (He's the guy responsible for ByteString in the first place, and did a lot of the language shootout benchmarks back around 2004-2005 or so)
23:16:05 <jle`> but i guess you can have partial application on a non-curried function too
23:16:25 <rose_> I'm pretty stumped on a few failing tests on some decryption code. Testing on some substrings works, but testing on some concatenations of these substrings fails (noted in my tests). This is a pretty vague question, but I'd love to talk about it more in chat! http://lpaste.net/98179
23:16:25 <apples> ocaml curries by default, and it has default arguments
23:16:40 <bitemyapp> jle`: I don't know about that.
23:17:20 <bitemyapp> jle`: you can definitely do those things, it comes down to having a principled/nice way of doing it. I would not willingly give up currying for either of those things, if I'm forced to pick.
23:17:59 <jle`> apples: i'll have to look into that, i always glossed over it and pretended it didn't exist :P
23:18:40 <Cale> rose_: What does the one which fails produce as a result?
23:18:54 <bitemyapp> jle`: you can pretend implicit arguments don't exist in Glasgow Haskell but it does :P
23:18:54 <rose_> I included the test results at the bottom of the code
23:18:56 <rose_> Do you see it?
23:19:18 <Cale> oh, you did, I just had to refresh
23:20:05 <JakeE> eh...I think I just wrote one of the ugliest functions I've every written #refactoringTime
23:22:21 <dleedev> back
23:22:58 <dleedev> with more questions about Alternatives :)
23:23:37 <dleedev> it seems like the semantics of an Alternative's <|> is different from Monoid's <>
23:24:18 <johnw> dleedev: how so?
23:24:55 <dleedev> johnw: Monoid's <> feels more like "building up", whereas Alternative's <|> feel more left-catch..
23:25:29 <rose_> \msg Cale Do you have any questions about the code?
23:25:50 <johnw> dleedev: I guess that's going to depend on the instance
23:25:53 <johnw> > [1] <|> [2]
23:25:54 <lambdabot>  [1,2]
23:26:02 <jle`> dleedev: it doesn't really matter what they 'do'
23:26:11 <jle`> you just need a binary operation
23:26:17 <jle`> there are left-catch monoids as well
23:26:40 <jle`> > mconcat [First Nothing, First (Just 1), First (Just 2)]
23:26:41 <lambdabot>  First {getFirst = Just 1}
23:26:51 <dleedev> jle`: sure, but is it appropriate to expect the Alternative instances provided by standard library to be left-catchy?
23:26:56 <jle`> > First (Just 1) <> First Nothing
23:26:57 <lambdabot>  First {getFirst = Just 1}
23:27:00 <jle`> dleedev: ah
23:27:02 <Cale> rose_: Nope, just trying to figure out where it goes wrong by hand-evaluating subexpressions of things
23:27:06 <jle`> that is the golden question isn't it
23:27:20 <jle`> there actually aren't any alternative laws that people have agreed upon
23:27:26 <dleedev> > Just "1" <> Just "2"
23:27:27 <lambdabot>  Just "12"
23:27:31 <dleedev> > Just "1" <|> Just "2"
23:27:33 <lambdabot>  Just "1"
23:27:47 <jle`> dleedev: yes, those are two different monoids on Maybe String's
23:27:50 <dleedev> jle`: but is there a Haskell's tradition?
23:28:19 <jle`> dleedev: the only real answer is ehhhh yeaaa i guess >.>
23:28:34 <jle`> <.<
23:28:39 <dleedev> jle`: so not really
23:28:55 <jle`> you can look more into this debate by looking into MonadPlus
23:29:06 <jle`> whose mplus function is the same thing as <|> for the most part
23:29:17 <jle`> sort of like >> and *>
23:29:28 <jle`> and there is a lot of debate around what mplus laws should be
23:29:41 <dleedev> jle`: ok, so it's not settled
23:29:42 <jle`> those debates should apply also to the laws of Alternative
23:30:03 <jle`> yes
23:30:14 <jle`> Alternative, by name, does sort of imply some sort of semantic meaning to its binary operator
23:30:26 <jle`> but there aren't any laws at the moment and people haven't really agreed on what it should be
23:30:36 <jle`> exactly
23:30:43 <Cale> rose_: Oh! rest = truncate $ fromIntegral (n - (n `mod` 16)) / 16
23:30:46 <dleedev> jle`: I guess it would be overkill to have different types based on different ways to combine
23:31:00 <dleedev> jle`: although some, like Sum Int and Product Int, are provided
23:31:00 <Cale> rose_: Don't use floating point arithmetic, it rounds things off
23:31:15 <jle`> dleedev: also First, Last, Any, All
23:31:24 <jle`> :P
23:31:50 <Cale> rose_: You just want n `div` 16
23:31:58 <jle`> but most useful instances of Alternative are some sort of 'here are possibilities and alternatives, do with it what you wish'
23:32:01 <dleedev> :k First
23:32:02 <lambdabot> * -> *
23:32:03 <Cale> rose_: div and mod form a pair
23:32:06 <jle`> for example <|> on the list monad is not left-catch
23:32:08 <jle`> er
23:32:10 <jle`> list applicative
23:32:12 <glaebhoerl> yo. is there any way to make ghci output :t with the foralls explicit?
23:32:35 <jle`> > "hello" <|> "wold"
23:32:37 <lambdabot>  "hellowold"
23:32:39 <jle`> oops
23:32:39 <dleedev> > [1] <|> [2]
23:32:41 <lambdabot>  [1,2]
23:32:51 <dleedev> First [1] <|> First [2]
23:33:00 <dleedev> > First [1] <|> First [2]
23:33:02 <lambdabot>  Couldn't match expected type `Data.Maybe.Maybe a0'
23:33:02 <lambdabot>              with actual type `[t0]'Couldn't match expected type `Data.Maybe....
23:33:02 <lambdabot>              with actual type `[t1]'
23:33:03 <jle`> First takes a Maybe
23:33:04 <rose_> Cale: (n - (n `mod` 16)) is always a multiple of 16, right? so that value / 16 would always be a round number anyway, yeah?
23:33:24 <Cale> rose_: Floating point values are of limited precision
23:33:30 <rose_> aha!
23:33:31 <rose_> thanks
23:33:35 <jle`> however the Alternative instance for list makes sense given the semantics/meaning of the default list monad/applicative instance
23:34:03 <Cale> rose_: So that was kind of true until the numbers got large enough that they didn't fit in the mantissa anymore
23:34:06 <jle`> so you see that it is hard to pin down specific enough laws to say meaningful things yet have them be general enough to cover all use cases of 'alternativey' stuff
23:34:54 <dleedev> :c []
23:36:24 <dleedev> so generally I hear Functors < Applicatives < Monads
23:36:26 <rose_> Cale: It all works, thanks!
23:36:27 <dleedev> what's after Monads?
23:36:44 <dleedev> Monad transformers?
23:36:45 <dleedev> pipes?
23:37:06 <johnw> MonadPlus?
23:37:50 <dleedev> MonadPlus is to Monads what Alternatives are to Applicatives, right?
23:37:54 <shachaf> There is nothing after or before monads.
23:38:09 <johnw> I think he means in order of specialization
23:38:10 <shachaf> This is not a class and there won't be a quiz at the end.
23:38:20 <dleedev> shachaf: whew
23:39:05 <johnw> dleedev: and yes to your last question
23:40:13 <Cale> rose_: No problem, and glad to hear it!
23:41:06 * hackagebot EtaMOO 0.1.0.0 - A new implementation of the LambdaMOO server  http://hackage.haskell.org/package/EtaMOO-0.1.0.0 (RobLeslie)
23:42:17 <dleedev> is it possible to have multiple type constructed instances? For example, multiple Alternative Maybe, where one's <|> means left-catch, and another's <|> means append?
23:42:47 <johnw> you'd need to use newtype wrappers for that
23:42:58 <johnw> and then wrap/unwrap to temporarily get the variant behavior
23:43:06 <Cale> EtaMOO is perhaps an even more clever choice of name than LambdaMOO was :)
23:43:23 <dleedev> so you would newtype a Maybe to AppendMaybe, and do Applicative AppendMaybe?
23:43:31 <johnw> sure
23:44:04 <dleedev> so newtype works on non-types? i.e. type constructors?
23:44:13 <johnw> Cale: How about MuMOO
23:44:32 <merijn> dleedev: No, you'd just write "newtype AppendMaybe a = Append (Maybe a)"
23:44:55 <Cale> johnw: eta and mu are the usual names of the natural transformations involved in a monad :)
23:45:02 <Cale> (return and join)
23:45:04 <johnw> ah
23:45:21 <dleedev> merijn: and Alternative Append?
23:45:23 <johnw> I always pronounce the latter "myu" in my head, so I missed that
23:45:37 <merijn> dleedev: No "instance Alternative AppendMaybe where ..."
23:45:47 <dleedev> merijn: how would you define Append?
23:45:57 <merijn> johnw: Same here, MOO doesn't sound remotely like mu >.<
23:46:09 <merijn> dleedev: What do you mean? Append is just the newtype constructor
23:46:28 <dleedev> merijn: where did it come from?
23:46:34 <dleedev> merijn: or is it like a value constructor?
23:47:23 <dleedev> merijn: btw, would "instance Alternative AppendMaybe where ..." work? doesn't Alternative require its argument to be * -> *?
23:47:57 <merijn> dleedev: the newtype line defines both the newtype and that constructor
23:48:08 <merijn> dleedev: Also, AppendMaybe has kind * -> *
23:48:26 <merijn> Because I defined "newtype AppendMaybe a = ..." <- a is a type argument here
23:48:28 <dleedev> merijn: ah, yes, I see
23:48:36 <dleedev> merijn: thanks
23:49:15 <JakeE> if all haskell code were translated to contunuation passing style would it be impossible to get a stack overflow?
23:50:11 <dleedev> I want to practice writing haskell by writing a web server. Which framework should I use? Happstack, yesod, Snap...
23:50:12 <merijn> JakeE: function calls in haskell don't cause stack overflows because haskell doesn't have a function call stack
23:50:27 <JakeE> not a call stack but it has a pattern matching stack
23:50:39 <JakeE> and this stack can still overflow http://www.haskell.org/haskellwiki/Stack_overflow
23:50:44 <merijn> JakeE: Sure, but continuation passing style doesn't eliminate that :)
23:50:51 <JakeE> that's what I was wondering
23:51:02 <JakeE> thanks; I didn't think so but wasn't really sure
23:51:04 <haasn> unless you use continuations to encode your pattern matching? :)
23:51:30 <JakeE> ya not quite what I was thinking lol
23:51:31 <BlankVerse_> is the type of main constrained by the compiler to be IO () ?
23:51:32 <merijn> JakeE: Continuation passing style + tail call elimination means you don't push a new stack frame at every call
23:51:45 <merijn> BlankVerse_: The report constrains main to "IO a"
23:51:46 <BlankVerse_> can it be something else? like [String] -> IO ()
23:52:02 <JakeE> merijn: thanks; that seems to awnser my question
23:52:46 <merijn> BlankVerse_: The runtime can only run IO actions, so what would it do with a "[String] -> IO ()"?
23:53:08 <BlankVerse_> merijn: ok , makes sense!
23:53:32 <BlankVerse_> merijn: but I need to create a module without main and generate its .o file
23:53:56 <BlankVerse_> but ghc -c is also asking that there be a main function
23:54:17 <merijn> BlankVerse_: It only asks that if you don't define a module other than Main at the start of your file
23:54:36 <merijn> BlankVerse_: i.e. just add "module Foo where" as the first line of your file (where the filename is Foo.hs)
23:55:41 <merijn> BlankVerse_: The rule ghc follows is "no module name" -> "module name Main" -> "complain about missing 'main'"
