00:00:12 <benzrf> if u want an operator-named function as an expression you need parens around it
00:00:24 <benzrf> non-paren'd operators will always be interpreted as being applied
00:00:57 <theme2> Arunabha: If you read about currying, you might understand what is going on
00:01:07 <benzrf> i dont think thats the problem here
00:01:22 <benzrf> the problem is that `f . g' is calling (.) with f and g
00:01:28 <benzrf> not calling f with (.) and g
00:01:38 <benzrf> thats just how it parses
00:01:38 <theme2> benzrf: Arunabha thinks that foldr requires 3 arguments to properly parse
00:01:52 <benzrf> theme2: i think i cleared that one up
00:01:59 <benzrf> christ i need sleep, ttyl gl
00:02:32 <Arunabha> Yes I know what the part before the . is doing (partial application of foldr), I was just confused as to why the . is not considered a parameter
00:03:04 <theme2> Arunabha: an operator is made up out of symbols
00:03:07 <combifez> because it looks like an operator, not a word
00:03:37 <theme2> Arunabha: other stuff are made out of letters, numbers and underscores (am I missing something?)
00:03:51 <combifez> yes'
00:03:56 <theme2> whoops
00:04:19 <theme2> letters, numbers, underscores and backticks
00:04:57 <theme2> wait a sec, does that mean that "()()" is a valid operator?
00:05:19 <combifez> no, you can't have ( or ) in operators
00:05:50 <combifez> --- isn't an operator either
00:06:14 <merijn> But --> is :)
00:06:57 <theme2> combifez: why is --- illegal?
00:06:58 <merijn> theme2: And anything that unicode considers a letter/underscore (well, not exactly if you want to be pedantic, but...)
00:07:12 <merijn> theme2: Because any number of - in a row is not a valid operator
00:07:25 <merijn> Which allows you to use ----------------- as comment line separator :)
00:07:27 <combifez> > 'x' --- comment ça va
00:07:29 <lambdabot>  'x'
00:07:33 <Arunabha> Ok, so anything not composed of letters, numbers, underscores and backticks is an operator and its presence without an enveloping () means its being applied  ?
00:07:56 <combifez> yes, to a first approximation
00:08:01 <merijn> For precise details, see: https://www.haskell.org/onlinereport/haskell2010/haskellch10.html
00:08:13 <merijn> Arunabha: Roughly, yeah
00:08:18 * hackagebot hspec2 0.4.2 - Alpha version of Hspec 2.0  http://hackage.haskell.org/package/hspec2-0.4.2 (SimonHengel)
00:08:18 * hackagebot egison 3.3.11 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.11 (SatoshiEgi)
00:08:28 <merijn> The link I posted specifies the valid characters for operators
00:08:54 <merijn> > let (☃) x y = x + y in 3 ☃ 5 -- :D
00:08:56 <lambdabot>  8
00:09:08 <theme2> seriously lol for defining "whitestuff" :O
00:11:10 <Arunabha> Thanks folks, this has been very helpful
00:12:06 <combifez> > 2 Prelude.+ 2
00:12:07 <lambdabot>  4
00:12:24 <combifez> (this is what trips people up)
00:12:26 <theme2> combifez: I thought that addition was built-in
00:12:38 <combifez> no, (+) is a library function
00:12:51 <combifez> method
00:12:53 <combifez> thing
00:12:55 <theme2> > id Prelude.. 2
00:12:56 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
00:12:57 <merijn> theme2: + is just a typeclass function
00:12:57 <lambdabot>    arising from a use of ‘M867557355888638564518841.show_M8675573558886385645...
00:12:57 <lambdabot>  The type variable ‘a0’ is ambiguous
00:12:57 <lambdabot>  Note: there are several potential instances:
00:12:57 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
00:13:02 <theme2> wtf
00:13:15 <combifez> you're trying to print a function
00:13:22 <theme2> whoops
00:13:25 <merijn> theme2: The instance for Int, etc. is built-in, for some value of built-in
00:13:30 <theme2> I was trying to do " id . 2 "
00:13:34 <combifez> yes
00:13:38 <combifez> that's a function
00:13:41 <merijn> theme2: Which will give you a very confusing type error :)
00:13:43 <combifez> (.) returns a function
00:13:58 <theme2> > ( id Prelude.. id ) Prelude.$ 2
00:14:00 <lambdabot>  2
00:14:05 <merijn> theme2: . wants two functions, so it'll complain that there's no Num instance for functions :)
00:14:06 <theme2> ok now :)
00:14:06 <combifez> it will also treat 2 as a function, which may or may not work
00:14:30 <combifez> except in this case it seems to have been tripped up by the Show instance for functions, which requires Typeable
00:15:00 <combifez> and now we've got something polymorphic in Num and Typeable and lambdabot has no idea what type to use
00:15:10 <combifez> > ord
00:15:11 <lambdabot>  <Char -> Int>
00:15:21 <theme2> lol
00:15:22 <combifez> (a monomorphic function)
00:15:29 <combifez> > id
00:15:31 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
00:15:31 <lambdabot>    arising from a use of ‘M438832648874007550918908.show_M4388326488740075509...
00:15:31 <lambdabot>  The type variable ‘a0’ is ambiguous
00:15:31 <lambdabot>  Note: there are several potential instances:
00:15:31 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
00:15:36 <combifez> ambiguous type
00:15:42 <combifez> > id :: Int -> Int
00:15:42 <theme2> id::Integer
00:15:43 <lambdabot>  <Int -> Int>
00:15:50 <theme2> whoops
00:16:22 <combifez> lambdabot has something like instance (Typeable a, Typeable b) => Show (a -> b)
00:29:18 <nilg> is there a version of 'when' that takes a monad Bool instead of Bool as condition?
00:30:02 <jle`> @hoogle Monad m => m Bool -> m () -> m ()
00:30:05 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
00:30:05 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
00:30:05 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
00:30:28 <jle`> welp
00:30:38 <tac> bah. If i'm using parsec with a token stream that isn't a String, but rather [Token] for some type I invened named Token...
00:30:51 <tac> how do I match against a parcular Token or class of Token's?
00:32:13 <nilg> I did use Hoogle before asking and got the same thing, but that doesn't matches what I would like
00:32:22 <tac> something like satisfy is what I want
00:32:24 <nshepperd> @pl \b x -> (b >>= flip when x)
00:32:24 <lambdabot> (. flip when) . (>>=)
00:32:25 <tac> but for not Char
00:33:41 <jle`> tac: is satisfy relaly monomorphic for Char?
00:33:43 <jle`> that's unfortunate
00:33:49 <tac> :X yeah
00:34:09 <tac> maybe I'm looking at an old set of docs?
00:36:49 <jle`> it's still Char for the most recent version
00:36:54 <jle`> you might have to hack it with tokenPrim, but that's weird
00:38:10 <zcd> what's the easiest way to upgrade haskell platform?
00:38:16 * hackagebot egison 3.3.12 - Programming language with non-linear pattern-matching against unfree data  http://hackage.haskell.org/package/egison-3.3.12 (SatoshiEgi)
00:38:39 <MP2E> uninstall it completely and install a clean haskell platform
00:38:58 <MP2E> upgrading will only lead to trouble, trust me, ghc compiled stuff isn't compatible across versions
00:39:00 <tac> ugg
00:39:04 <zcd> it's unfortunate that a rip up and rewire is still the easiest way :(
00:39:30 <zcd> also unfortunate that debian packages advance at grandma pace
00:39:51 <tac> yeah. looking at some old code, I ran into this problem a few years ago
00:39:54 <tac> and solved it that way
00:40:47 <solidus-river> wow, hlint just gave me the most ridiculous looking suggestion ever
00:40:56 <solidus-river> why does it not want me to use zipWith
00:41:01 <solidus-river> using map is incredibly awkword
00:41:55 <tac> lambdacase is a thing now, right?
00:43:49 <jle`> solidus-river: what is the offending code?
00:46:47 <solidus-river> jle`: http://lpaste.net/110167
00:46:53 <solidus-river> hlints desired version wont even compile
00:48:26 <jle`> ...what's the name of the suggestion?
00:48:49 <trap_exit> is there a way to tell haskell : when you see "foobar" and am not sure if it's String, LazyText, or StrictText -- just default to StrictText .
00:49:54 <solidus-river> jle`: 'Use map' i updated the pastebin with formatted output of hlint http://lpaste.net/110167
00:50:00 <solidus-river> jle`: also, good evenin'
00:50:12 <jle`> how bizarre
00:50:21 <jle`> does it still do it if you replace the ($) with parentheses usage?
00:50:30 <jle`> thank :) you too :) (for the corresponding time)
00:50:43 <solidus-river> jle`: yeah, it does
00:52:23 <solidus-river> jle`: ah, it gave a bad suggestion but it was saying something usefull
00:52:37 <solidus-river> jle`: it wants me to use `map (dt *) [1..]
00:52:39 <solidus-river> 1
00:53:00 <jle`> heh
00:58:18 * hackagebot Agda 2.4.2 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.4.2 (UlfNorell)
01:00:21 <solidus-river> i've been talking with mm_freak about my problems with netwire, he has me going through excersize and i think i'm almost there
01:00:34 <solidus-river> http://lpaste.net/110167
01:23:00 <jle`> solidus-river: that's encouraging to hear :)
01:31:37 <nshepperd> zZZZZza00/AAAAAAAAA*
01:45:54 <trap_exit_> https://gist.github.com/anonymous/821b39bd515411e77f68 <-- why do I need UndecidableInstances to make this code to compile?
01:47:12 <mroman> how good is happstacks webserver that it has somehow built-in?
01:47:12 <mroman> i.e. can one use happstack websites in a productive environment using the simpleHTTP thingy?
01:47:12 <mroman> and by can I mean "safely"
01:47:12 <mroman> i.e. if it's just some medium performance issue then it's still safe
01:48:24 * hackagebot simple-pipe 0.0.0.28 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.28 (YoshikuniJujo)
01:49:17 <mroman> trap_exit_: I thought that's because of the =>
01:49:28 <trap_exit_> mroman: it is
01:49:29 <trap_exit_> why though?
01:49:32 <trap_exit_> I don't understand why
01:50:08 <mroman> I'm not 100% sure
01:50:25 <mroman> but I remember something that instance declarations with type restrictions require an extension
01:50:38 <mroman> much like Instance with Lists require FlexibleInstances I think
01:51:14 <mroman> i.e. instances for Strings
01:51:27 <jkarni> trap_exit_: it violates the Paterson condition, I believe
01:51:41 <trap_exit_> jkarni: ELI%
01:51:44 <trap_exit_> *ELI5*
01:52:48 <mroman> hm. k. nvm
01:52:48 <jkarni> trap_exit_: http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/type-class-extensions.html#undecidable-instances
01:52:48 <jkarni> trap_exit_: in essence, you could have a loop with the contexts (LHS of =>)
01:53:10 <trap_exit_> yeah, was trying to rea section 6.3.4 of the 7.8.3 manual
01:53:11 <trap_exit_> did not understand it
01:53:17 <mroman> instances usually require a specific type, right?
01:53:19 <trap_exit_> beisdes the part which is like "YOU CAN INFINITE LOOP COMPILER"
01:53:27 <trap_exit_> and then I was like "hmm, maybe I should not touch this"
01:53:41 <trap_exit_> so here's the sitaution
01:53:50 <trap_exit_> I want to be able to use format "{}" on my own data types
01:53:53 <trap_exit_> to do that, they need to inherit Buildable
01:53:57 <trap_exit_> now, all I want to say is:
01:54:05 <trap_exit_> anything that I can convert to LazyText, I can convert to Buidlable
01:54:16 <trap_exit_> with the folloining method: convert to lazytext, then convert the lazy text to Buidlable
01:54:17 <mroman> jkarni: what's exactly the difference between Flexible and Undecidable?
01:54:27 <trap_exit_> and GHC is like : FUCK YOU, go read up on category theory
01:54:52 <trap_exit_> oh, I already have FlexibleInstances and FlexibleContexts
01:54:52 <mroman> instance Num a => Foo a doesn't automatically require UndecidableInstances
01:54:52 <jkarni> trap_exit_: what happens if you have instance C a => C a where {...}?
01:54:52 <mroman> but only FlexibleInstances
01:55:17 <trap_exit_> jkarni: that looks like an infinite loop
01:55:24 <jkarni> trap_exit_: you have to prove C a, for which you have to prove C a, for which ...
01:56:19 <jkarni> trap_exit_: exactly
01:57:43 <trap_exit_> jkarni: I believe only an idiot would write that type of code in real life
01:57:58 <trap_exit_> however, I do see myself writing A a => B a , B a => C a, C a => D a, D a => A a
01:58:05 <trap_exit_> which would have the same problem
01:59:30 <jkarni> trap_exit_: so GHC has mechanisms to prevent these, but they also prevent some non-loops
01:59:31 <jkarni> trap_exit_: so you can lift the restriction with UndecidableInstances
02:01:17 <NeverW8> I'm in it for ze ca$h
02:02:38 <jkarni> trap_exit_: yeah, exactly
02:02:57 <jkarni> trap_exit_: it was just the shortest example ;-)
02:02:58 <dcoutts> mroman: re happstack's http, yes that's what people use. They sometimes put it behind a proxy, e.g. apache or nginx
02:03:30 * hackagebot IntervalMap 0.4.0.0 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.4.0.0 (ChristophBreitkopf)
02:03:31 <mroman> What's the main reason for such proxies?
02:03:49 <dcoutts> mroman: for example hackage.haskell.org uses that approach, it uses happstack using simpleHTTP serving on an internal port, and nginx proxies
02:04:19 <trap_exit_> jkarni: alright, I'm happy with this; thanks for your time + this discussion
02:04:32 <dcoutts> mroman: honestly I'm not the person to ask, I've not seen a very clear explanation of what problem it's addressing
02:04:40 <jkarni> trap_exit_: glad to help!
02:04:49 <mroman> Caching for static content?
02:04:53 <barrucadu> mroman: Lets you have multiple web things on the same port, but bound to different URLs.
02:04:57 <dcoutts> mroman: not in this case
02:05:01 <mroman> but you could deliver that through a webserver optimized for static content
02:05:04 <mroman> (or a cdn)
02:05:13 <mroman> ah
02:05:19 <dcoutts> mroman: obviously if you want to integrate it as a sub-site then you need a proxy like that, e.g. to host it at some url other than / on the domain
02:05:46 <mroman> yeah
02:06:03 <dcoutts> mroman: but we don't use either of these things for hackage. You'd have to ask our infrastructure people why they use this architecture.
02:06:07 <mroman> can't host multiple sites through the same port otherwise
02:07:14 <dcoutts> mroman: anyway, you always use simpleHTTP, it's just a question of whether you use an extra intermediate proxy or not
02:07:36 <mroman> makes sense to have a proxy to route things to different internal happstack-server applications
02:08:05 <dcoutts> if you have multiple, sure
02:10:02 <mroman> dcoutts: I'd have to check out how thoroughly I can configure simpleHTTP
02:10:10 <yeboot> is dynamic linking for haskell (in debian) only available on x86 and x86_64 systems?  I mean, to do dynamic/shared linking one would need the ghc-dynamic package; which, according to https://packages.debian.org/search?keywords=ghc-dynamic is not available outside of x86/x86_64
02:10:23 <mroman> i.e. in terms of how much time it's allowed to consume for a single request
02:10:23 <mroman> stuff like that
02:10:27 <mroman> *e.g.
02:10:36 <mroman> *for example
02:10:48 <yeboot> or would it be possible using hugs or some other haskell compiler
02:10:55 <mroman> I have very strict memory and CPU limitations
02:11:02 <SPLOOCH> if you want to serialize data how do you deal with references to other objects in that data?
02:11:10 <mroman> so I need to be able to configure how much it is allowed to consume for processing a single request ;)
02:12:12 <mroman> and it shouldn't crash if it hasn't enough memory left to process a further request
02:12:12 <SPLOOCH> < to avoid storing duplicate/inconsistent data.
02:12:12 <mroman> it should just reject the request and continue
02:12:52 <mroman> mainly I have no swap
02:12:52 <mroman> so there's zero tolerance on memory consumption
02:13:27 * hackagebot hspec-wai 0.3.0.2 - Experimental Hspec support for testing WAI applications (depends on hspec2!)  http://hackage.haskell.org/package/hspec-wai-0.3.0.2 (SimonHengel)
02:15:24 <mroman> there's Conf { timeout :: Int} at least
02:15:25 <mroman> but no memory bounds :(
02:24:04 <mikusp> Hi. Is there any alternative to using EqualityT from Language.Haskell.TH.Syntax 2.10 in earlier 2.9 version? I want to make some code work with GHC 7.8.3
02:27:53 <amosr> so, I uploaded a package to hackage yesterday, and it doesn’t have haddock documentation. does it take a while to be generated, or did I do something wrong?
02:28:00 <amosr> (locally, cabal haddock generates stuff)
02:28:58 <ChristianS> amosr: it can take a few days, i think
02:29:07 <amosr> ChristianS: ok, cool :-)
02:31:07 <halvorg> :t maybe
02:31:09 <lambdabot> b -> (a -> b) -> Maybe a -> b
02:31:38 <halvorg> how do I use maybe as b -> Maybe a -> (a -> b) -> b
02:31:51 <halvorg> (swapping the second and third arguments)
02:32:03 <halvorg> my a -> b function is a quite lengthy one
02:33:11 <mr-> halvorg: give it a name and use where?
02:33:25 <halvorg> That's the only way?
02:33:59 <slomo_> halvorg: maybeFlipped a = flip (maybe a)
02:34:11 <barrucadu> @pl \a -> flip (maybe a)
02:34:11 <lambdabot> flip . maybe
02:34:16 <mr-> halvorg: no, but I think it's clearer than a flipped version :-)
02:34:59 <halvorg> thanks
02:37:22 <hexagoxel> can somebody confirm that haskell-src can not parse .lhs ? (trying to parse GHC/base.lhs, "parse error")
02:40:47 <wz1000> Is there any way of having type checked lists with a given length? I want to have a type level check on whether two lists are the same lenght. I got as far as defining a type 'data Zero', and 'data Succ a', but I don't know how to write the actual list type. I want List Zero to be the unit type, and List (Succ a) to be a*(List a)
02:41:04 <hexagoxel> let me guess, "Common uses of this package are to parse or generate Haskell 98 code.", and .lhs is not 98?
02:41:30 <prophile> wz1000: data List n a where Nil :: List Zero a; Cons :: a -> List n a -> List (Succ n) a
02:42:24 <prophile> hexagoxel: the documentation on ParseMode says "more to come later, e.g. literate mode"
02:42:49 <wz1000> prophile: Are there any extensions required to run that?
02:42:52 <prophile> GADTs
02:44:01 <hexagoxel> prophile: yeah; i hoped it currently inferred that from the filename
02:46:26 <ben____> hello
02:48:58 <ben____> do you guys like dogs
02:51:06 <bjornars> is the dog typesafe?
02:51:32 <MP2E> is the dog composed purely?
02:52:29 <pavonia> And is there a monad for the dog?
02:53:52 <MorpheusBeing> ?nixon
02:53:52 <lambdabot> It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
02:57:12 <MorpheusBeing> ?fortune
02:57:12 <lambdabot> Youth doesn't excuse everything.
02:57:12 <lambdabot>                -- Dr. Janice Lester (in Kirk's body), "Turnabout Intruder",
02:57:12 <lambdabot>               stardate 5928.5.
02:58:33 * hackagebot idris 0.9.14.2 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.14.2 (EdwinBrady)
03:14:17 <pertl> I am trying to understand "(+) <$> Right 4 <*> Right 3 ===> Right 7". The type of <$> is "(<$>) :: Functor f => (a -> b) -> f a -> f b". Since evaluation order is left to right I assume that infix operator <$> is evaluated before <*>. Due to <$> 's definition (+) should be of type "(a -> b)" ? Actually it is of type "(+) :: Num a => a -> a -> a". I just can't make up the connection. could someone explain how evaluation actually works?
03:15:22 <prophile> pertl: yes, b = (a -> a)
03:15:43 <pertl> aahhhh :-)
03:15:55 <pertl> wow, tricky indee
03:15:57 <pertl> d
03:16:10 <prophile> (+) <$> Right 4 is Right (4 +)
03:18:18 <pertl> prophile: thanks - again haskell blows my mind :-)
03:20:02 <prophile> pertl: hooray for types :)
03:20:52 <pertl> yep, actually I find it quite intriguing ... just takes some time to unlearn bad imperative habits
03:20:55 <pertl> and such
03:21:32 <prophile> yeah, the gear shift takes a while
03:24:14 <pertl> prophile: got it! actually everything is damn logical and straightforward. thanks :-)
03:24:27 <prophile> no worries
03:36:00 <pjdelport> prophile: Remember that "f <$> x" is just short for "pure f <*> x" too
03:38:39 * hackagebot IntervalMap 0.4.0.1 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.4.0.1 (ChristophBreitkopf)
03:39:10 <prophile> pjdelport: actually it's not - it's short for fmap f x
03:39:35 <prophile> the difference being the lack of an Applicative constraint
03:48:40 <hyPiRion> yeah, <$> is just another way of writing `fmap`
04:10:15 <slomo_> when using parsec in applicative style, is there a way to let a parser fail if a specific character is found? in monadic style one could just peek a word8, check it and fail
04:13:26 <pjdelport> prophile: Sorry, that was aimed at pertl; and I just meant in terms of its relation to the rest of Applicative.
04:13:55 <pjdelport> pertl: So in other words:
04:13:55 <pjdelport> > Right (+) <*> Right 4 <*> Right 3
04:13:57 <lambdabot>  Right 7
04:15:11 <pjdelport> Or generically:
04:15:11 <pjdelport> > pure (+) <*> pure 4 <*> pure 3 :: Either a Integer
04:15:13 <lambdabot>  Right 7
04:15:37 <pertl> applicative vs. functor :-)
04:24:11 <pertl> when using let inside do, e.g. "do let myvar = 1 + 2", is myvar supposed to be of type "Num a => IO a" ?
04:24:11 <Cale> no
04:24:11 <pertl> oops, I mean "Monad a"
04:24:11 <Cale> Still no
04:24:11 <pertl> hrmpf
04:24:11 <pertl> :-P
04:24:11 <Cale> myvar :: Num a => a
04:24:12 <pertl> so desugaring the "do" will mean "myvar" is bound inside lambda?
04:24:13 * hackagebot antisplice 0.17.0.0 - An engine for text-based dungeons.  http://hackage.haskell.org/package/antisplice-0.17.0.0 (implementation)
04:24:13 <Cale> do { let { <decls> } ; <stmts> } = let { <decls> } in do { <stmts> }
04:24:21 <pertl> Cale: oh cool thanks
04:24:31 <Cale> do { v <- x ; <stmts> } = x >>= \v -> do { <stmts> }
04:24:38 <Cale> do { x ; <stmts> } = x >> do { <stmts> }
04:24:49 <Cale> do { x } = x -- base case
04:26:42 <pertl> Cale: makes sense, thanks a lot :-)
05:27:56 --- topic: 'http://www.haskell.org/ | Paste code/errors: http://lpaste.net/new/haskell | Logs: http://tunes.org/~nef/logs/haskell/?C=M;O=D http://ircbrowse.net/day/haskell/today?mode=recent | Administrative issues: #haskell-ops | Hackage down? http://is.gd/xJt4FF'
05:27:56 --- topic: set by glguy on [Fri Aug 15 13:29:35 2014]
05:27:56 --- names: list (clog ddrone araujo Oxyd edon mgsloan rrmckinley_ ompaul Tuplanolla lenstr KorriX absence Jyppe [swift] LuxuryMode milos_cohagen Nizumzen mcveat cody__ lw xinming Cryovat tomejaguar_away davidthomas statusfailed Dashkal iota_ Preyer XMunkki heyj Watcher7 OMN0M saml_ SPLOOCH systemfault_ wchun nulpunkt_ tomboy64 mattp_ moop dgpratt_ r444 astrofog calumet john_not_jenny xenog DanielDiaz waldohatesyou LeoTal rtpg phischu Javran mixi vramana codygman Pad^)
05:27:56 --- names: list (mokkake Takle Enigmagic vpetro dfrey no_name ndrei trap_exit zwer bennofs copumpkin kmspriyatham tb01110100 kawachi hesselink etabot notori0us jkarni ian_mi j0ni maurer mjrosenb kakos SHODAN pp^ raek iron_houzi d-snp yesco wombawomba dabradley perspectival1 milessabin prophile rylev lebek epta g00ey amf jacobw Guest87340 MichaelBurge dh andreypopp_ osa1 bydo simukis_ RchrdB bjoernlenz humkubum marienz dju paper tac-tics C4Cypher mrowe_away waterlaz vladan)
05:27:56 --- names: list (gridaphobe antoniy slasktask cowtown lahwran autochthon _|d0m|_ kmicu lambdabot vincom2 zcourts Guest1800 amiller_ sajith_ krakrjak_ elij tippenei1 sindresorhus fall` tlevine_ numberte1 Phlogistique qrada__ kaol_ Saizan Laquendi Gowilla JPohlman1 OrangeDuck adnap prinsen_ keaml_ kloeri_ Cheery papna_ Bwild nik_89_ shachaf_ popl_ finnrobi_ poucet frsilent_ Kithulhu_ tumdedum AlephNull heaumer dowski_ pingu hc aoh ananna Talryn mgomezch_ stvc_ Guest88154)
05:27:56 --- names: list (alinab ValicekB noplamodo RevJohnnyHealey alpounet simec PragCypher plutoniix erkin d_k s_e mgaare pdxleif harski kloplop321 hebz0rl iross JZTech101 amontez mami honkfestival liyang Guest80098 eagleflo pieter `bps cynick ZsoL Arnar benbangert notdan_ chit bahamas nullbyte jameseb peder jlouis Drezil shiona wormphlegm earldouglas mrd tpsinnem dan64 Maerten_ cjheath canta1 splintax1 gseitz_ bergmark_ fabe sixthgea1 cryon_ lulf julmac luzie ropav_ quaestor)
05:27:56 --- names: list (thomassgn TheDerpSquad Kobata__ cwraith OscarZ_ jesse__ Sorella foxnorth mindfreak RayNbow`TU qxjit saikrishna FireFly mawuli_ tov `^_^ charlie betawaffle divyanshu_ joshsz_ aztek thamz tromp_ DenSchub jophish__ cin greymalkin felixsch_ Nshag Sgeo_ anachron_ ThatOtherPerson_ Edoxile sprang ForNeVeR nisstyre alang dogmaT obiwahn rom1504_ bitraten mendez identity yacks hpd xelxebar zph_ jhigdon zymurgy pygospa honza dagle IanKelling klugez danneu2 silver)
05:27:56 --- names: list (etrepum biscarch SequenceK si14 Adeon franckverrot alorente Someguy123 ReinH linduxed kardboardb kalloc eevar_ friden kuyatzu ew0000 int-e sodaplayer geal bjornars Nickeeh raid descender RaceCondition fergusnoble nitrix- Svedrin u_____ anildigital Jello_Raptor codehero robbert` Boreeas_ schlumpi edwardk Yogsothon whaletechno _ikke_ infinity0 martinga_ stew dgvncsz0` vmesons takuan josephcs_ thorstadt Jaxan rabisg Zekka_ froztbyte imanc_ michaelpj_)
05:27:56 --- names: list (koninkje_away tismith_ KitD_ sw1nn_ flori_ ft rudi_s nesqi Martty_ qrada_ companion_square Tene_ ckey` theDon Chousuke_ dilinger_ vhz strmpnk__ idnar dsirenko_ himikov R2ZER0_ dstockwell _tca posco aristid__ sclv serjeem__ cstrahan LaC_OS_X Blkt MrGwen1 TititaTitutu_ asfp` the_dude kayloos dixie_ ique stevely_ gauthier_ tusj t7 greeny jedavis Sagi redeemed GothAlice ibid Shogun _flow_ Internet13 isomorphic palf eazar001 kqr hyPiRion lpsmith cepheus Twey)
05:27:56 --- names: list (ClarusCogitatio_ CosmicRay DarkFox simcity3000 SIGKILLer NDJ eriksensei tekacs squimmy_ Nik05 gandr Palmik_ mikrofusion mathu_ Ke Jonno_FT1 kav_ roo eddd_ BMeph_ Vbitz mickk caumeslasal deni magicman bjobjo armyriad ddere amosr seangrov` ernst paullik nkoep Philonous uu1101 ivan` mjo Arne jnott vukcrni ortmage connerb Klumben phaskell ajcoppa stalintrotsky mrb_bk billyiii_ jo__ pm5 alphonse23_ Karethoth_ PatrickRobotham petantik tazjin mbrcknl fractalcat)
05:27:56 --- names: list (SethTisue_______ coeus jodaro sofancy_ Guest35706 bounb artyomkazak callumacrae kr4sh Spacegoat andyland machrider_ cschneid_ lfox Tiktailk vikraman BrianHV_ cjwelborn_ Walther_ charliekilo_ mrkishi- marsam mikeizbicki Guest91365 rschulman_ skarn mikeym_ agrif MiracleBlue wizonesolutions Jeanne-Kamikaze diginet_ Crate_ MarcWebe1 wjm Raynos mroman_ CARAM ircbrows- DustyDingo shouya_ David prasm caasih_ Rutger`_ tomku arnihr_ d3lxa panda_man xcv kshannon_)
05:27:56 --- names: list (Xorlev_ mxf leifw Spockz_ abc56889_ andreasrx helgar krkini elgot_ Bigcheese_ Tordek_ staffehn_ zerokarm1left feltnerm ffledgli1g cow-orke1 werdna_ japesina- igorii_ taruti_ wjt jlyndon_ c74d acfoltzer_ s3mi0 tv gereedy_ ttuegel nkpart jroesch_ hkon__ AntiSpamMeta mavam_ otulp nw Guest93696 arrdem monochrom therealklanni jpierre03 l3kn indiv0 spion_ mgregson mbrock_ dkua protein-jesus parallel21 Soft nick1234abcd Starfire ljhms abh jin_jin SaBer coppro)
05:27:56 --- names: list (natte KaneTW mindos_cloud____ jlamothe_ hinidu seanparsons beanmachine rs0_ alcabrera cpa_ jcsims brackets semberal- ezrios1 korpse________ joshc_ mno2 hpc_ ehamberg dutchie superjudge__ knyppeld1nan nyuszika7h Cathy ryanakca lokydor Slowpoke_Man lieven_ tarcwynne_ AshyIsMe geekosaur jennmoneydollars adm davorak asjo ixian8 lacrosse jonsterling fling peltchu mandu bergey` jungnam` sdx32 flux hsc_ blast_hardcheese jomg Transfusion oish McManiaC thevishy)
05:27:56 --- names: list (Intensity kragniz danvet Lethalman davean chirpsalot thorkilnaur_ djahandarie gbarboza BeLeKy carter Belgarion0 jayne FragByte liuw rieper MediumDivision bbastian jle` alvdav sarlalian GGMethos user__ simpson lamilami \u blenny_ nwf d3f yeltzooo Taneb JPuff brixen elfenlaid inuoppai chrisdotcode jordanl Sht0 ZioCrocifisso defanor benma cmn funfunctor JorDunn Paks jlewis_ djapo repnop pablo| jrslepak b_jonas Dtgr Igloo AncientPC Freundlich predator117 obcode)
05:27:56 --- names: list (aninhumer savanni luite gsilvis aegray m4farrel Kneiva redtricycle phaazon tstc Tehnix case39 Razz glaebhoer1 Kabaka mikusp xahry StoneToad __jrp__ empyreal_ Gracenotes_ Bootvis Tritlo lusory mountaingoat SolitaryCipher tm512 tsou WraithM koi AleXoundOS TheMue zorg24 BitPuffin blakehaswell rblackwe nominolo pks chad danten tremon AdopsMonkey Beetny jedai jrp6 terlar o0oo0o haskoiner tech2 slomo_ nschoe tomaw- studybot_ jesyspa Wizek_ inad922 joerisamson LnL)
05:27:56 --- names: list (hexagoxel gfixler hellangel7 dlnx` sopvop Quashie_ djcoin lep-delete unK_ ivan\ xificurC edwtjo free_beard ventonegro amatsu raichoo cellopropane Wertax Cale purefn1 ion neptunepink jml everett tnks glguy AiiR zz_LoRdToLsToI Mon_Ouie LordDeath peddie edk fall_ Paprikachu mimi_vx SuperTux88 mirsal sea-gull ps-auxw Diskord thirsteh dlackty_ Polarina Reiser tobyp dukedave nifty sohum pnielsen henrikhodne preyalone javex shennyg_ manfoo7` zling____ ioanel)
05:27:56 --- names: list (nakal1 saep aaron891_ sakirious nilg jack_rabbit acharles zanchoPansa l4u- dreixel_ castor1 drbean FreeFull [mth] jasonjckn tanath vili saurik mikecaruso1 amiri_ shanse Church- bmuk spopejoy _ashbreeze_ koz apaku m00nlight tertl3 bam365 Ralith bgyss termos nymacro Swizec kmels_ ninedotnine earthy cap3lla yrdz cespinoza exio4 dsfox1 bbloom nemesit|znc nil- pyon Will| Rylee orion DrCode mgomes omefire1 taktoa dud`` shelling Mokosha Boney codeburg Guest40803)
05:27:56 --- names: list (dolio Nanar hiredman coconnor shintahW helpta negatratoron_ effy User932 doneata mceier Eagle_Erwin dmwit vpm marekw2143 bmcorser dcoutts_ OlegYch _TAS fikusz jorj kerrick_ bgamari integral Nahra mmmm dv- statusbot dmilith manfoo7`` lpvb M-ou-se kfish wollw tassmjau brisbin mmaruseacph2 goorrff falafel dyreshark aford chaptastic unloading_offlin rodlogic Tesseraction LandenAuer jj2baile Denommus guampa tuxit plucas dsfox Excureo TheFuzzball bjorkintosh)
05:27:56 --- names: list (flebron xpika joelteon milli bbee sh1ken execut3 ckw Th0mas kjanosz noam_ afleck BeardedCoder helgikrs2 vsayer_ oconnore zq Khisanth solirc Baughn nshepperd eyck mephx yorick tamiko_ deavidsedice solarus adlan bsmt cow_2001 Lindrian ski MitchW Lacriatch SparkySparkyBoom bjz ninegrid Plasmastar cyanoacry capisce Yep so zorzar relrod theorbtwo plhk twopoint718 melter akurilin saml Draconx tomprince tg cjay isomorphismes dqd anders^^ TallerGhostWalt_ indigo)
05:27:56 --- names: list (yusukesuzuki_ Athas karls ThePhoeron adamse_ stepcut arch__ saiam gallais kongo bcoppens petercommand thebnq Na6hu7Ud ousado_ MasseR Desoxy_ Derander_ comboy Lefeni eamelink trez ChristianS yam jrw eyenx ephemeron humppa noidi xplat cyphase mayski annulus eL_Bart0 stass jakutis janne filinep Brando753 teeteewhy mlen sivoais srhb zebr joneshf teehemkay owlglass ghorn_ lolocaust jmcc__ zenzike emmanueloga tero- Imdsm paperManu levi bra MMuse__ oldmanstanley__)
05:27:56 --- names: list (lfp jchee_ kmapped pharaun cdk tridactyla ephess irssi_ xaimus_ shelf ggherdov joefiorini ocharles c-rog mornfall `micro_ wting_ ParahSailin_ frms_ eyem hamishmack bd___ jaspervdj CindyLinz mechairoi qz_ unsymbol_ HugoDani1l johnw sleepynate ahf tmct jophish_ Guest80710 RoxRacoon Hafydd chasecaleb henk chas dlundy_ seagreen- boegel_ hanDerPeder periodic_ bvad mrshoe qtplatypus Kinnison DigitalKiwi phadej jglukasi1 Guest41571 ClaudiusMaximus pranz)
05:27:56 --- names: list (SwashBuckla gargawel_ xelk choosegoose estewei_off onielfa oubiwann horlicks_ thetallguy Aune GaveUp mangaba_1eitosa NeverW8 MK_FG mike4 ilmig Nivim Phillemann opto ninzine cmccann slth Wamanuz2 stelleg carlosgaldino hbar go|dfish Aeriff troydm wrmsr|somewhere Urchin mazelrella dp_wiz Kruppe funrep pyrtsa averell bartavelle Bane^ ij cursork heikkih hegge majoh nathanic opqdonut ens jasu0 cmears radix PixelCru- mnemon stoned dario joeyh SegFaultAX nikolah)
05:27:56 --- names: list (yaopo inr kandinski bwe itsmonkt1stic Ezku_ rtl mokus_ scopedTV_ zomg Liskni_si greghale heath Guest89739 aprescott Ornedan_ mads- T_X_ n00dle petterw Wayneoween jackhill ggreg_ ChewieBeardy raphie qwandor jabbslad___ c9sould avdi kirjs___ AlainODea blindscreen Scorchin adrienneleigh srbaker_ DanZimm Axman6 mak` comma8 Fusxfaranto machineslearn paz cods spaceships albel727 ziman puzza007_ avocado benzrf|offline sunfun wei2912 deevus valdyn WarzoneCommand)
05:27:56 --- names: list (syunull Hodapp Biohazard demolithion electrogeek TakSuyu TheMoonMaster clementd Plastefuchs lispy oberstein bernalex iXeno_ sm purefn rejuvyesh[away] Maxdamantus cross fryguybob danking CaveJohnson aloiscochard NickHu alvelcom td123 mrmonday yukko ciaranm sokoll nicoo thoughtpolice supki maoe tych0 joachifm ivoscc pikhq agatam mkrtem mr- Haskellfant npcomp kaiza devn Floyd_ kgadek reggie1 otterdam Sornaensis __main__ pjdelport elnaeth tessier jonathanj wtw)
05:27:56 --- names: list (steshaw yrashk metadave asabil yeshuah_ cloudhead_ zpconn__________ mortberg SenorSenpai macron hmax Raynes seliopou jix Licenser Natch jrib mikeplus64 Nimatek phaer lyxia_ curlywurly jzelinskie Vq DasIch jnoah perrier_ Fubar^ Gothmog_ akahn wagle stiell brandonw dcoutts mrpantoufle Ulrar rhodesd Artpicre anthraxx42 catsup hvr haroldwu bitemyapp mononofu ktosiek Eliel adimit yano cmsd2 shapr mero Laney @ChanServ tomaw iulian sgronblo osnr elfangor tromp__)
05:27:56 --- names: list (gdsx_ aupo _1126 SLi zeiris fyolnish `0660 kosmikus PHO_ katis ByronJohnson sipa Clint k00mi ChongLi banyan jlewis somenick- felipe_ Harbinger ahihi pfoetchen knyon Hardolaf xnyhps gidogeek Fuuzetsu sordina2 barrucadu monsieurp sellout JustAPerson joe_k z0d kipras`away noddy waynr qr42 yan_ evax_ cwc Draggor jmct sunnavy asm89 pi8028 bstrie claudiyoh noctux burp xintron mietek ndeine Okasu stbuehler spacebug osfameron Rembane Deewiant slobo s4msung kennyp)
05:27:56 --- names: list (kittenso1p jdiez edran sveit jcurbo zeroskillor bens kalz m_george haasn naudiz frontendloader Jaak xrz Yawgmoth iteratee mankyKitty Dodek felixn myme shmookey andrewsw gws ido)
05:27:56 -sinisalo(freenode.net)- [freenode-info] why register and identify? your IRC nick is how people know you. http://freenode.net/faq.shtml#nicksetup
05:28:04 <haasn> Which includes “blocks of data being read”
05:28:53 <haasn> By limiting yourself to function composition you're essentially also limiting yourself to processing the entire input at once
05:31:03 <McManiaC> hmhm
05:31:32 <haasn> In general, these libraries work by splitting up conceptual “streams” into concrete “chunks”; for example something like a TCP stream transmits data in concrete chunks under the hood; say you're writing a “ping server” using function composition, an API for that would look something like (Lazy.ByteString -> Lazy.ByteString); the implementation of which being ‘id’
05:32:09 <haasn> How is the underlying TCP implementation supposed to know where the “borders” are, ie. when it should stop collecting your response and start sending a packet?
05:32:35 <haasn> With pipes/conduits/etc.; it's made explicit when side effects like sending a packet are actually performed
05:32:57 <haasn> The pipe is no longer “id” but rather something like forever (await >>= respond)
05:33:27 <haasn> Which the underlying implementation can clearly work with because it knows exactly when to feed in more data and when to process more output
05:36:04 <haasn> Of course, there are more differences - as you mentioned, you can await or respond multiple times (ie. break free from the 1 request = 1 response pattern); you can feed from different input streams at the same time (eg. in machines); you can send data backwards as well as forwards; you can perform arbitrary effects alongside your data processing; you can acquire and release resources (eg. using ResourceT)
05:36:07 <haasn> that live as long as the pipe is processing data
05:38:22 <marek__> Hi I'm trying to compile GHC 7.8.3 on Windows using the instructions from your wiki. I have encountered errors as reported at https://ghc.haskell.org/trac/ghc/ticket/9513  has anybody succeeded to build GHC on Windows and is willing to share his experience?
05:53:39 <bgamari> marek__, Can you not use the bindist?
05:57:04 <mads-> I'm not a big fan of `-notation. How would I rewrite filter (`elem` ['a'..'z']) "Howdy YOU" to not use it?
05:58:10 <bennofs> > filter (flip elem ['a'..'z']) "Howdy YOU" -- mads-
05:58:11 <lambdabot>  "owdy"
05:58:37 <bennofs> > filter (\c -> elem c ['a'..'z']) "Howdy YOU" -- with lambda
05:58:39 <lambdabot>  "owdy"
05:59:00 <marek__> @bgamari Thanks for answer, unfortunately I have to get it from sources, because I have an path an I need to apply it. I have made it working on linux but I can't build it on Windows
05:59:01 <lambdabot> Unknown command, try @list
05:59:37 <mads-> bennofs: in the first example, why do we need the flip?
06:00:28 <exio4> `elem` [...] is the same as "\x -> elem x [...]"
06:00:30 <barrucadu> mads-: (foo operator) = \x -> foo operator x; (operator foo) = \x -> x operator foo
06:00:47 <bgamari> marek__, If I were you I'd just try to hack the value of INSTALL
06:00:48 <marek__> @list
06:00:48 <lambdabot> What module?  Try @listmodules for some ideas.
06:01:25 <marek__> @listmodules
06:01:25 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime metar more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
06:01:30 <haasn> > filter (inRange ('a','z')) "Howdy YOU"
06:01:31 <lambdabot>  can't find file: L.hs
06:01:33 <haasn> > filter (inRange ('a','z')) "Howdy YOU"
06:01:35 <lambdabot>  "owdy"
06:01:57 <exio4> @hoogle inRange
06:01:59 <lambdabot> Data.Ix inRange :: Ix a => (a, a) -> a -> Bool
06:02:19 <haasn> More efficient too
06:02:20 <bennofs> haasn: wow, thanks for showing me inRange :) That seems like a very useful function
06:02:55 <McManiaC> haasn: i see, thx
06:03:13 <haasn> > inRange ((0,0), (10,10)) <$> [ (1,1), (-5,3), (7,8), (9,11) ]
06:03:15 <lambdabot>  [True,False,True,False]
06:04:10 <haasn> > filter (>'a') . filter (<'z') $ "Howdy YOU"
06:04:11 <lambdabot>  "owdy"
06:04:25 <haasn> More than one way to get rid of ` :)
06:07:40 <marek__> bgamari, The INSTALL value seems reasonable to I am not sure how I should change it. Moreover before the INSTALL-related error there is quite a bunch error about missing files that causes automake to skip GHC compilation.
06:09:55 <makalu> I have C objects A and B. A needs B to work so I use "withForeignPtr B" to keep B alive when working with A but B also has to be freed after A. How do I ensure that?
06:13:31 <makalu> looking at the documentation of touchForeignPtr it seems reference counting is the only way :(
06:29:05 <Twey> makalu: Have you considered referencing B from A?
06:29:34 <Twey> makalu: Wait, is your problem that you want to ensure that B won't be destroyed before A, or that B will be destroyed immediately after A?
06:29:53 <catsup> is it possible to read a file at compile time to create a pure function that contains the contents of the file?  i'm currently doing this by embedding a giant string in a module, which isn't how i'd like my code repo layed out, ideally
06:30:01 <makalu> Twey: that B won't be destroyed before A
06:30:36 <makalu> A already has a field with the ForeignPtr of B but it still happens that B is destroyed first :(
06:30:48 <Twey> makalu: But A exists only in the withForeignPtr action, yes?
06:31:07 <makalu> Twey: not sure what you are asking
06:31:46 <makalu> every time I do an operation with A, I use withForeignPtr for both A's and B's ForeignPtr
06:32:23 <Twey> makalu: withForeignPtr b' $ \b → withForeignPtr a' $ \a → doSomethingWith a
06:33:22 <SwashBuckla> let computations = [Just (Sum 2), Just (Sum 5), Nothing]
06:33:27 <SwashBuckla> > let computations = [Just (Sum 2), Just (Sum 5), Nothing]
06:33:29 <lambdabot>  not an expression: ‘let computations = [Just (Sum 2), Just (Sum 5), Nothing]’
06:33:30 <makalu> Twey: the order is important?
06:33:59 <SwashBuckla> > let computations = [Just (Sum 2), Just (Sum 5), Nothing] in mconcat computations
06:34:01 <lambdabot>  Just (Sum {getSum = 7})
06:34:05 <SwashBuckla> cool
06:34:30 <Twey> makalu: Or rather, withForeignPtr b' $ \b → do a' ← makeAForeignPtr b; withForeignPtr a' $ \a → doSomethingWith a
06:34:36 <SwashBuckla> I like that you can use the Maybe Monoid for computations that may have failed
06:34:36 <Twey> makalu: Yes, very
06:35:15 <Twey> SwashBuckla: Indeed.  But the monad is more commonly useful, I think
06:35:35 <SwashBuckla> Twey: do you have a use-case?
06:35:44 <SwashBuckla> (and example)
06:35:53 <makalu> Twey: another question, if I ignore the result of withForeignPtr (using '_' pattern), does that create problems?
06:36:13 <Twey> makalu: No
06:37:17 <Twey> SwashBuckla: It's used when you want to compute with the value, but any stage may fail.  E.G. on a JSON object: Just obj >>= getAuthor >>= getAddress >>= getStreet
06:38:00 <Twey> SwashBuckla: Where you don't know for sure that obj has an Author, or that the Author has an Address, or that the Address has a Street… if any one of them doesn't exist, you get Nothing for the whole computation
06:38:31 <Twey> (i.e. getAuthor ∷ Object → Maybe Author, getAddress ∷ Author → Maybe Address, …)
06:39:40 <Twey> (alternatively, getAuthor >=> getAddress >=> getStreet ∷ Object → Maybe Street)
06:41:56 <makalu> Twey: if an object X has a ForeignPtr field with object Y, then Y should exist as long as X exists?
06:42:13 <xpika> is there a category theory name for an (a -> a -> a) ?
06:42:17 <Twey> makalu: Nope
06:42:51 <makalu> ok, I've always understood that I have to touch ForeignPtrs to keep things alive
06:43:30 <stew> xpika: semigroup, if the operation is associative
06:43:30 <funfunctor> hi
06:44:18 <xpika> stew: what if the (a -> a -> a) is not associative such as (^)
06:44:22 <prophile> xpika: magma
06:44:24 * hackagebot ironforge 0.1.0.32 - A technical demo for Antisplice.  http://hackage.haskell.org/package/ironforge-0.1.0.32 (implementation)
06:44:24 * hackagebot fay 0.20.1.3 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.20.1.3 (AdamBergmark)
06:44:42 <makalu> but anyway, changing the ordering of withForeignPtrs didn't help
06:44:43 <Sornaensis> haskell subset that compiles to javascript
06:44:48 <Twey> xpika: A set a with an operation a×a → a is a magma
06:45:05 <Twey> But that's not a cat-theory definition, I guess…
06:45:26 <xpika> prophile: Twey: sweet
06:45:31 <prophile> a cat-theoretical magma is presumably just an object a and a morphism a x a -> a
06:45:41 <funfunctor> what are you guys talking about? apart from algebraic structures.. in reference to?
06:46:25 <prophile> funfunctor: <xpika> is there a category theory name for an (a -> a -> a) ?
06:47:00 <funfunctor> its a bit of a loose question
06:47:11 <prophile> indeed
06:47:34 <Twey> makalu: withForeignPtr is supposed to keep the ForeignPtr alive for the duration of the action you give it
06:47:34 <prophile> http://cokmett.github.io/cokmett/
06:47:52 <xpika> so i can say foldl1 takes a magma as an argument ?
06:48:07 <funfunctor> monoids can be thought of as a category with one object if that is helpful
06:49:13 <funfunctor> monoidal category
06:49:26 <prophile> xpika: you could, though you could just say that it takes an (a -> a -> a) and it would be much less confusing
06:49:37 <Twey> xpika: Wellll… I guess so.  That's kind of weird, though — the magma would be the type *and* the operation on it, which are both passed in some sense, but it seems odd to group them like that
06:50:01 <{AS}> Isn't a -> a -> a usually Semigroup (given associativity)
06:50:04 <funfunctor> xpika: so you could define a tensor product M x M -> M
06:50:17 <makalu> Twey: how is it supposed to affect the ordering of finalizers then? Aren't the finalizers run at an arbitrary time?
06:50:21 <prophile> {AS}: <xpika> what if the (a -> a -> a) is not associative such as (^)
06:50:33 <{AS}> prophile: Ah thanks
06:50:38 <Twey> makalu: Yes, but they're guaranteed to not be run within the withForeignPtr block
06:50:46 <Twey> (for that pointer)
06:51:56 <xpika> prophile: the term magma is two syllables. provided someone knows the definition its more efficient.
06:52:32 <prophile> xpika: efficiency doesn't work like that
06:52:46 <prophile> if you really want a way of expressing a -> a -> a that isn't symbolic call it a binary operation on a
06:52:53 <Twey> makalu: So if you have withForeignPtr b' $ \_ → withForeignPtr a' $ \_ → {- both a' and b' are alive here -}
06:53:00 <makalu> but that wasn't my issue. Doing things with foreign objects has worked so far using withForeignPtr. The issue is that A's finalizer must not run before B's finalizer.
06:53:36 <Twey> Ah, sorry
06:53:55 <makalu> when I'm not using a foreign call at all, GHC deletes B, then A and that segfaults because the poopy C++ library requires B to exist in A's destructor
06:54:14 <xpika> prophile: (a -> b -> a) is also a binary operation. im trying to differentiate it.
06:54:38 <funfunctor> prophile: maybe just call it a cross product?
06:54:46 <prophile> xpika: I don't believe it is?
06:55:08 <makalu> Twey: thanks for trying to help anyway
06:55:12 <xpika> prophile: doesn't binary just mean two?
06:55:12 <prophile> if the arguments have disparate types it's not a binary operation
06:55:22 <Twey> makalu: How about keeping just one ForeignPtr to the A, then freeing B in A's finalizer?
06:55:46 <Twey> Oh, no, that's terrible, isn't it
06:55:50 <prophile> xpika: yes, but "binary operation" and "binary function" aren't the same
06:56:17 <funfunctor> actually don't call it a cross product :)
06:56:22 <Twey> makalu: Wait, no, it isn't — just the usual withForeignPtr caveat about returning the pointer out of the action applies
06:57:22 <makalu> Twey: can I write a finalizer in Haskell?
06:57:27 <xpika> prophile: ah thanks. my bad.
06:57:33 <Twey> makalu: Yes, of course — that's what ForeignPtrs are for
06:57:37 <xpika> prophile: subtle
06:58:01 <funfunctor> :t max
06:58:03 <lambdabot> Ord a => a -> a -> a
06:58:33 <funfunctor> :t (^)
06:58:34 <lambdabot> (Num a, Integral b) => a -> b -> a
07:00:59 <xpika> :t foldl1
07:01:00 <lambdabot> (a -> a -> a) -> [a] -> a
07:01:19 <funfunctor> xpika: hope this is useful to you http://math.stackexchange.com/questions/366251/is-it-useful-to-view-magmas-as-diagrams
07:02:09 <makalu> Twey: I have to create that FunPtr to a haskell function and then use addForeignPtrFinalizer?
07:03:35 <Twey> makalu: Right
07:03:53 <makalu> that's weird. I guess it's because the runtime is written in C?
07:04:10 <xpika> prophile: so what's could i call an (a -> b -> b) ?
07:04:46 <Twey> makalu: It's because usually finalizers are foreign functions, from the same codebase that created the pointer in the first place
07:05:05 <prophile> that's an F-coalgebra on the (Const (Endo b)) functor
07:05:06 <Twey> (I think)
07:05:10 <prophile> (don't actually call it that)
07:08:48 <Twey> makalu: There's some stuff about it in the docs: https://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-ForeignPtr.html
07:09:15 <makalu> yes I tried reading it but it was confusing. Fortunately I found some information elsewhere.
07:10:38 <xpika> so the function "take" is an F-coalgebra on the (Const (Endo b)) functor ?
07:14:35 <makalu> Twey: the runtime gave me an error and referred me to this nice thing instead http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-Concurrent.html
07:15:40 <makalu> the error was about a finalizer not being allowed to call back into haskell
07:15:45 <Twey> makalu: Oh, that's nice
07:15:47 <Twey> Right
07:16:04 <Twey> Because Haskell is stopped for GC at that point, I think
07:16:40 <flergs> What is haskell's performance compared to OCaml?
07:17:44 <flergs> Some say that it is much faster and some say much slower
07:17:50 <flergs> whats the deal?
07:19:51 <Twey> flergs: That's a really big question
07:20:03 <Twey> Even if you're talking about implementations, such as GHC vs. ocamlopt
07:20:52 <flergs> Twey: so neither is faster overall?
07:21:08 <Twey> My general impression is that OCaml's sometimes faster for single-threaded computation, but doesn't have a concurrency substrate nearly as advanced as GHC's
07:21:08 <ChristianS> flergs: it probably depends on your use case, but both tend to be pretty fast
07:21:27 <Twey> (but I'm not really an OCaml person)
07:21:42 <phaazon> hey
07:21:53 <phaazon> what is the best library for parallel arrays?
07:21:54 <phaazon> repa?
07:22:07 <Twey> But yes, it's going to depend a lot on your particular code — I wouldn't claim either is generally faster overall
07:24:54 <flergs> Twey: the use cases are file IO, network IO, and binary data processing like encodings
07:26:06 <funfunctor> how does for example, Endo work inside Data.Monad ? I understand the abstract idea but not the computational detail
07:27:04 <funfunctor> that is, I understand it forms a monoid of all the endomorphisms under functional composition
07:28:31 <c_wraith> ...  Data.Monad?  You mean Data.Monoid?
07:28:50 <funfunctor> woops, yes sorry typo c_wraith
07:29:17 <makalu> interesting, the Foreign.Concurrent finalizer is never called :(
07:29:17 <Hafydd> Control.List
07:29:20 <c_wraith> Ok.  Endo is relatively simple.  It's just a wrapper around functions with type a -> a
07:29:38 <c_wraith> newtype Endo a = Endo { appEndo :: a -> a }
07:29:47 <S11001001> funfunctor: http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Data-Monoid.html#Endo
07:30:02 <funfunctor> how does something like data Foo x = Yay (Endo x) | Boo String, work?
07:30:30 <c_wraith> funfunctor: It...  Just does.  What part are you uncertain about?
07:30:32 <funfunctor> S11001001: yes yes, I know all that. I mean how does it work in the computer
07:31:12 <funfunctor> I mean I can follow the idea of a function down into machine code just fine, I can't seem to follow this abstraction down like that..
07:31:16 <hnoob> ok I'm in xmonad and using xchat, can't close the "list of channels" window...
07:31:41 <S11001001> funfunctor: I'm not sure I see the value in doing that.
07:31:50 <hnoob> nvm will ask in #xmonad
07:32:18 <c_wraith> funfunctor: Are you familiar with how to represent algebraic data types at the machine level?
07:32:20 <Twey> makalu: Are you compiling with -threaded?
07:32:22 <makalu> oh, it says right in the documentation that there's no guarantee that the finalizer is run at all. I wonder what's the point of it then :P?
07:32:44 <funfunctor> hnoob: grep xK_c in your config perhaps, or grep kill
07:32:47 <makalu> "There is no guarantee of promptness, and in fact there is no guarantee that the finalizer will eventually run at all."
07:32:52 <geekosaur> hnoob: mod-shift-c
07:33:02 <geekosaur> (mod is by default alt)
07:33:14 <Twey> makalu: I think that might just be the usual caveat of garbage collection
07:33:44 <hnoob> ah, that did it.  thx geeksosaur
07:34:03 <funfunctor> c_wraith: yes for the most part, depends on the structure.. but its just fancy lines on a page that represent numbers. We can take some writing and define some AST for it given some contextual rules
07:34:16 <fizbin> I think there is a guarantee that it'll get run before that same memory is processed by the garbage collector and re-used.
07:34:24 <funfunctor> c_wraith: i've written compilers before
07:34:42 <makalu> Twey: the Foreign.ForeignPtr version of newForeignPtr says "There is no guarantee of promptness, however the finalizer will be executed before the program exits."
07:35:26 <c_wraith> funfunctor: yes, but that doesn't mean you've written a compiler anything like how GHC works. :)
07:36:02 <c_wraith> funfunctor: I think the most important detail is that GHC uses a uniform boxed representation for just about everything.
07:36:58 <funfunctor> c_wraith: yes GHC is extremely advanced hence my question ;)
07:37:00 <geekosaur> makalu: normal finalizers are about cleaning up memory, FFI finalizers do extra work in case the thing on the other side of the FFI *also* needs to run a finalizer.
07:37:06 <bennofs> Is there a better way to do vector a -> [a] for mutable vectors than: for [0..vectorSize-1] $ V.read vector
07:37:20 <geekosaur> what you don't have is OO finalizers --- because Haskell is not OO
07:37:47 <geekosaur> and generally if you're looking for those then you need to rethink your approach in a more functional manner
07:37:55 <c_wraith> funfunctor: even functions, when passed around as first-class values, share the boxed representation.
07:38:25 <makalu> geekosaur: I'm not trying to do any OO. I'm just trying to use a shitty C library (I have to use it).
07:38:36 <geekosaur> then you want the Foreign one
07:39:13 <c_wraith> funfunctor: and the important part of boxed representations is that they're all just pointers to some data.  How the data is used controls what is expected to be behind the pointer.
07:39:26 <Twey> bennofs: toList…?
07:39:38 <c_wraith> Twey: I don't think that actually exists for the mutable versions.
07:39:39 <bennofs> Twey: there doesn't seem to be a toList for Mutable Vectors, is there?
07:39:42 <funfunctor> c_wraith: well for a 'simple' monoid like Endo, could we try to break it down a bit for me?
07:39:43 <Twey> Oh, the mutable ones
07:39:45 <makalu> geekosaur: I think you might not have been here when I first asked my question. The problem is that the finalizer of one object can't run before the finalizer of another object.
07:40:05 <Twey> How odd
07:40:05 <c_wraith> funfunctor: the important point of Endo is that at runtime, it has the exact same representation as any other function
07:40:07 <funfunctor> c_wraith: lets pretend we are going to build a crappy compiler and pick a poor representation
07:40:31 <funfunctor> ah ok, so its 'some function' 'out there'..?
07:41:02 <c_wraith> funfunctor: well, haskell functions (unlike C functions) are actually a combination of function + environment
07:41:26 <c_wraith> funfunctor: err, code + environment.
07:42:03 <funfunctor> sure
07:42:53 <makalu> I'll have to think about this another day
07:43:26 <funfunctor> but I am just trying to gain some very naive view on the computational picture (it does not need to actually work in practice)
07:45:03 <funfunctor> how about map Endo [f, g, h], my current picture is these become a new function k = f . g . h
07:45:43 <c_wraith> funfunctor: only if you mconcat the list afterwards
07:45:58 <funfunctor> oh true
07:46:26 <funfunctor> hmm maybe I should think of some better simple examples of its use to gain a better picture
07:48:11 <c_wraith> funfunctor: You might find it helpful to remember that (.) is a function itself.  (f . g) is represented in memory as (something like) a pointer to the code for (.), and an environment containing pointers to f and g, whatever they might be.
07:48:45 <funfunctor> that is useful thanks
07:48:56 <funfunctor> slowly understanding it.. playing in ghci
07:49:07 <funfunctor> c_wraith: mconcat (map Endo [g, h, f]) `appEndo` 3
07:49:42 <funfunctor> with g = +5, h = +3, f = *4
07:49:51 <c_wraith> funfunctor: You could even trace that on paper, symbolically.
07:50:56 <funfunctor> c_wraith: yes that is what I am trying to understand out of the syntaxual sugar..
07:51:06 <c_wraith> funfunctor: mconcat [Endo g, Endo h, Endo f] `appEndo` 3 -----> Endo (g . h . f) `appEndo` 3 ------> (g . h . f) 3
07:51:09 <funfunctor> how is application happening here?
07:51:10 <funfunctor> ah
07:51:21 <c_wraith> I skipped a couple steps, of course
07:51:24 <funfunctor> ok I got it now
07:52:44 <funfunctor> so map Endo is so the functions are lifted into the Monoidal structure and then appEndo can be applied to compose them into a new function in the monoidal structure and then once again 3 is lifed in?
07:53:08 <c_wraith> funfunctor: actually, mconcat is what composes them, in that example
07:53:23 <c_wraith> funfunctor: appEndo just pulls the contents back out as a regular function
07:54:08 <funfunctor> so appEndo technically unwraps delifting things out the monoid back down a level of abstraction
07:54:43 <c_wraith> funfunctor: That's not standard terminology, but it's accurate. :)
07:55:12 <pjdelport> funfunctor: It's the same idea as:
07:55:12 <pjdelport> > getSum $ mconcat (map Sum [2, 3, 5])
07:55:14 <lambdabot>  10
07:55:19 <funfunctor> mconcat acts as the binary operation for the monoidal structure of the list where the list elements are also monoidal
07:55:40 <pjdelport> appEndo just the equivalent of getSum
07:55:47 <funfunctor> :t getSum
07:55:48 <lambdabot> Sum a -> a
07:56:00 <funfunctor> how do you say 'delift'?
07:56:47 <pjdelport> funfunctor: It's not even a special function; just a record label:
07:56:47 <pjdelport> newtype Sum a = Sum { getSum :: a }
07:56:47 <pjdelport> newtype Endo a = Endo { appEndo :: a -> a }
07:57:38 <pjdelport> You could equally just say: let Endo composed = mconcat (map Endo [g, h, f]) in composed 3
07:57:56 <funfunctor> I think this is a gap for me, because I /see/ appEndo :: a -> a  as a type-signature without a body
07:58:19 <pjdelport> funfunctor: Do you understand record syntax in general?
07:58:57 <funfunctor> not 100% no, although somehow i've managed to get away with using it so far enough to do complex things with it
07:59:21 <pjdelport> funfunctor: https://en.wikibooks.org/wiki/Haskell/More_on_datatypes#Named_Fields_.28Record_Syntax.29 might maybe quickly fill that gap
07:59:56 <funfunctor> I think the last time I read it I didn't get it so lets try again..
08:00:08 <hexagoxel> what is the easiest way to get a syntax tree of a literate haskell (.lhs) file?
08:00:35 <pjdelport> funfunctor: The basic idea is that the above syntax is equivalent to saying:
08:00:35 <pjdelport> newtype Endo a = Endo (a -> a)
08:00:35 <pjdelport> appEndo (Endo f) = f
08:00:47 <rribeiro> just a quick little question, what is cpp2hs? Where can I find a installation for it?
08:01:00 <pjdelport> funfunctor: In other words, each named field of the record becomes an implicit function that extracts that field.
08:01:21 <pjdelport> (And that can also be used in record patterns, etc., but that's not so relevant here)
08:01:22 <funfunctor> pjdelport: ah got it
08:01:54 <pjdelport> funfunctor: You'll often see newtypes defined that way, to get a "free" function to extract the value wrapped by the newtype.
08:01:57 <funfunctor> pjdelport: that syntax seems more magical then it actually is
08:02:05 <funfunctor> yes yes
08:02:44 <funfunctor> pjdelport: i've sometimes been mixing up writing helper functions then remembering you can do this, forgetting it and remembering it again
08:03:18 * funfunctor switches been C++/C/Haskell/Ada/ and a bunch of other things almost constantly
08:03:20 <pjdelport> funfunctor: Another example: newtype State s a = State { runState :: s -> (a, s) }
08:03:37 <flergs> Does haskell have a good method of serializing objects, so that I can work with binary formats without manually serializing fields for example?
08:04:01 <pjdelport> funfunctor: "runState :: State s a -> s -> (a, s)" might *seem* magical at first, but it's literally just an accessor :)
08:04:10 <bergmark_> flergs: check out the binary package
08:04:13 <flergs> ok
08:05:03 <funfunctor> pjdelport: yes its actually pretty nice as the data access semantics become well encapsulated without possible bitrot and things..
08:05:26 <funfunctor> thanks for explaining it
08:06:36 <funfunctor> I think I one day want to write a book "Haskell for the Dyslexic :: Type"
08:06:59 <OMN0M> Hi there, if anyone has a moment. I am on Ubuntu 14.04 and have cabal 1.16 and cabal-install v 1.16.02, I am trying to get cabal sandbox to work but I still can't. Any guidance?
08:08:03 <clrnd> OMN0M, any error message?
08:08:08 <mr-> OMN0M: I am not sure if 1.16 supports sandboxes. I'd advice you to do "cabal update" and "cabal install cabal-install" in any case
08:09:05 <clrnd> OMN0M, he is right, I actually installed cabal 1.20 because ubuntu 14 default one doesn't have sandboxes
08:09:07 <OMN0M> So i have done both of those
08:09:41 <mr-> OMN0M: and do you have ~/.cabal/bin in your path?
08:09:55 <OMN0M> cabal install cabal-install is going
08:10:05 <mr-> ah, great
08:10:22 <OMN0M> And no I do not have anything in ~/.cabal/bin
08:10:33 <mr-> cabal will install itself there
08:10:36 <OMN0M> I do have ~/.cabal with other stuff
08:11:16 <OMN0M> Actually
08:11:20 <OMN0M> I spoke too soon
08:11:26 <OMN0M> There is a cabal executable in bin
08:12:02 <mr-> .cabal/bin will (by default) have any executable that cabal installs
08:12:15 <OMN0M> How do I update it to a version with sandbox?
08:12:32 <mr-> For example happy, alex,...
08:12:49 <mr-> cabal install cabal-install should install the latest version of cabal in your .cabal/bin
08:13:03 <OMN0M> Okay it's still running
08:15:51 <OMN0M> That worked, I just had to copy cabal to /usr/bin
08:15:56 <OMN0M> Thank you so much
08:17:01 <mr-> the more sustainable solution is adding ~/.cabal/bin to your PATH :-)
08:17:20 <mr-> because then installing binaries with cabal "Just Works"
08:17:39 <prophile> the best solution is rm -rf /usr/bin; ln -s ~/.cabal/bin /usr/bin
08:18:23 <barrucadu> command not found: ls
08:18:26 <barrucadu> :p
08:18:34 <funfunctor> rm -rf /usr/bin O_o what !!!!
08:18:43 <prophile> barrucadu: ls is usually in /bin
08:18:45 <prophile> so you're fine!
08:20:09 <funfunctor> DO NOT run rm -rf /usr/bin
08:21:26 <bennofs> prophile: ArchLinux symlinks /usr/bin to /bin iirc
08:21:27 <nullremains> whoops
08:21:39 <barrucadu> bennofs: Yup
08:21:49 <barrucadu> They decided that the distinction was too arbitrary, and got rid of it
08:21:55 <prophile> does it indeed?
08:22:02 <prophile> excellent
08:22:27 <prophile> I remember hearing rumblings about Fedora doing that
08:22:45 <bennofs> But I think Arch users are used to fixing stuff from the initrd shell :)
08:24:34 * hackagebot semver 0.2.0 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.2.0 (BrendanHay)
08:26:22 <TallerGhostWalt_> getting an error message on Lens
08:26:25 <TallerGhostWalt_> unifyTypes: Bug: Unexpected empty list
08:26:39 <angerman> if I have a string like "foo bar foo line 123 bar foo baz qux", and want to replace "line [0-9]+" with <a href="#lineXXX">line XXX</a> how would I go about that?
08:27:52 <bennofs> angerman: use one of the regex libraries on hackage?
08:28:03 <bennofs> @hackage regex-tdfa
08:28:04 <lambdabot> http://hackage.haskell.org/package/regex-tdfa
08:28:45 <TallerGhostWalt_> not really sure what that means
08:28:50 <angerman> bennofs, ok, so regexp is not looked down upon? I always got that feeling that one should not use regexp, but go about parsing all the way.
08:29:35 * hackagebot graceful 0.1.1.4 - Library to write graceful shutdown / upgrade service.  http://hackage.haskell.org/package/graceful-0.1.1.4 (NoriyukiOhkawa)
08:30:41 <clrnd> I just implemented monadic parsers in python + pymonad, not that painfull at all (it's for a talk)
08:31:37 <bennofs> angerman: if foo bar foo baz qux don't have any strucure, I think using a parser will be quite expensive
08:32:14 <bennofs> I think I suggested the wrong package
08:32:25 <bennofs> @hackage regex-compat-tdfa -- this seems better
08:32:26 <lambdabot> http://hackage.haskell.org/package/regex-compat-tdfa -- this seems better
08:33:29 <MichaelBurge> I love how great QuickCheck is at shaking out bugs. It takes hardly any effort to set up generators for your types, and gives such great confidence
08:34:58 <eriksensei> Hi all, I'm running into a bit of a dilemma when modelling data that should eventually be saved to a db. An example would be a Person with a required foreign key to an Address. When saving, you need to provide a FK to an Address, whereas for in-memory manipulation, having the actual Address embedded in a Person seems more convenient to me. Would it make sense to parameterize Person in the types of its foreign keys so you could hav
08:35:22 <TallerGhostWalt_> lensField works differently in 4.4
08:35:24 <TallerGhostWalt_> I see now
08:37:01 <prophile> eriksensei: you've been bitten by the IRC line limit I think
08:37:12 <prophile> all after "foreign keys so"?
08:37:14 <angerman> bennofs, thanks.
08:37:35 <eriksensei> ...so you could have both? I'm wondering how people generally go about this in Haskell.
08:37:49 <eriksensei> prophile: thanks :) didn't know about that
08:39:20 <prophile> my relational algebra-fu may not be up to giving you a good answer I'm afraid
08:39:23 * prophile considers
08:47:47 <eriksensei> prophile: no worries, my hopes of getting suggestions are modest :)
08:48:35 <prophile> well, the problem isn't haskell-specific, it looks like a fairly common ORM problem
08:48:46 <prophile> so you might find something in how other ORM systems approach it
08:52:37 <bam365_> eriksensei: http://www.yesodweb.com/book/persistent, if you scroll down to the section "A Closer Look at Types", I think deals with something similar to what you suggest?
08:53:20 <bam365_> it's specific to persistent, but the thought process might be worthwhile anyway
08:54:35 <hexagoxel> hexagoxel: just run the source through ghc -E, and parse the resulting .hspp file with haskell-src-exts.
08:55:11 <hexagoxel> hexagoxel: thanks, that worked just fine, apart from some unboxed tuple stuff that is not important!
08:55:33 * hexagoxel has to answer his own questions
08:56:36 <eriksensei> prophile: that's true, but I generally haven't bothered in other languages because some of the possible solutions seemed too cumbersome to begin with
08:56:49 <eriksensei> bam365_: thanks, I'll have a look!
09:05:20 <eriksensei> bam365_: ah, I've actually read that before, but it deals with abstracting away from the type of the key (and the backend), instead of from the choice between having an actual record or having a foreign key to such a record. Some of the techniques may apply, though.
09:06:06 <bam365_> eriksensei: yeah, figured it was probably a long shot...I've been researching DB packages myself over the last few days
09:06:22 <eriksensei> bam365_: it never really ends, does it? :)
09:08:49 <bam365_> no :) I've been a little diappointed by Haskell's database offerings, with the possible exception of acid-state which is not an option for me
09:09:40 * hackagebot either 4.3.0.2 - An either monad transformer  http://hackage.haskell.org/package/either-4.3.0.2 (EdwardKmett)
09:10:16 <fizbin> Is there a {-# #-} directive I can add to a file to say "no, ghc, I know I'm compiling all my files with -Wall, but turn off these particular warnings in this file only"?
09:10:58 <clrnd> @hoogle (a -> Maybe b) -> [a] -> [b]
09:10:59 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
09:11:00 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:11:00 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
09:11:16 <bennofs> fizbin: {-# OPTIONS_GHC -Wno-<some warning name> #-~ß
09:11:32 <fizbin> ~ß ?
09:11:34 <ClaudiusMaximus> fizbin: http://www.haskell.org/ghc/docs/latest/html/users_guide/ch04s02.html#source-file-options
09:11:37 <bennofs> fizbin: to find out <some warning name>, I use ghci :set -Wno-<tab>
09:11:46 <bennofs> fizbin: typo, meant #-}
09:11:54 <eriksensei> bam365_: i've mostly played with persistent and esqueleto, and i'm using postgresql-persistent atm. i heard one of the snap contributors say he liked groundhog, the other day. opaleye looks quite interesting too.
09:13:40 <fizbin> bennofs: That tab technique doesn't seem to work in my ghci (7.6.3), but I can look at the docs to find them.
09:17:29 <bam365_> eriksensei: first I've heard of groundhog, just took a quick look, I'll definitely have to play around with it later
09:18:27 <fizbin> bennofs: The tab technique doesn't work because the flag is -fno-warn-<whatever>, not -Wno-
09:18:58 <bennofs> fizbin: oops right :/
09:27:02 <SwashBuckla> woo, I have finished the Functors, Applicative Functors and Monoids chapter of LYAH! http://learnyouahaskell.com/functors-applicative-functors-and-monoids
09:27:16 <SwashBuckla> onto A Fistful of Monads
09:28:05 <eriksensei> SwashBuckla: congratulations sir/ma'am!
09:28:11 <SwashBuckla> sir
09:28:21 <eriksensei> sir it is ;)
09:28:27 <SwashBuckla> I am making notes and little .hs files on the way
09:31:54 <obiwahn> i have tried a few times to come to terms with haskell
09:32:44 <obiwahn> this time i might manage -- i have asked the prof who introduced us first to haskell some time ago
09:32:52 <obiwahn> and he gave me this paper:
09:32:54 <obiwahn> http://research.microsoft.com/en-us/um/people/simonpj/papers/marktoberdorf/
09:32:59 <obiwahn> rally awesome
09:33:15 <obiwahn> really
09:33:51 <dfeuer_> HELLO nomeata.
09:34:11 <dfeuer_> It appears the time has come for me to try this scary ticky-ticky thing!
09:34:28 <dfeuer_> HELLO merijn.
09:34:35 * dfeuer_ is in a greety mood right now.
09:35:02 <nomeata> dfeuer_: hi. it’s not more scary than the other stuff you are doing
09:35:26 <nomeata> dfeuer_: also, I still have three unanwered mail from you in my inbox, I’ll get to them eventually (unless they are obsolete by now?)
09:35:28 <dfeuer_> nomeata, it's a lot *less* scary now that SPJ wrote some quick-start instructions for it.
09:35:30 <cschneid_> There was an fpcomplete (I think?) article on creating mealy and moore machines and how they do internal state. Does that sound familiar, and what was it called?
09:35:40 <dfeuer_> nomeata, I have no idea if they are or ain't.
09:36:24 <dfeuer_> The recent optimizer changes made fusible reverse *very bad* for n-body (1100% more allocation bad), so I have to go figure out what happened.
09:57:42 <eacameron> does haskell run singlethreaded unless you specify -N2+?
09:58:35 <jfischoff> yes
09:59:03 <jfischoff> and you have to explicitly compile with -threaded
09:59:42 <eacameron> I'm using -N2 and it is giving me an error that "Large values for -N is not enabled by default"...wha?
10:00:12 <monochrom> no, I see 4 threads by -threaded and no -N whatsoever
10:00:22 <monochrom> 4 OS threads, that is
10:00:54 <monochrom> do this simple test: 1. main = getLine
10:01:05 <monochrom> 2. ghc -O -threaded g.hs
10:01:10 <monochrom> 3. ./g
10:01:45 <monochrom> 4. in another terminal, find its pid, do an "ls -l /proc/the_pid/task". See 4 pids
10:01:50 <geekosaur> there are OS threads started by e.g. the I/O manager
10:01:54 <monochrom> this is on linux
10:02:20 <monochrom> test everything you say. everything.
10:02:42 <monochrom> do not trust your memory. mark memory as dirty. flush.
10:02:46 <geekosaur> getNumCapabilities >>= print         might be useful
10:02:59 <geekosaur> (import Control.Concurrent)
10:03:33 <monochrom> one of those threads is for the garbage collector
10:05:11 <monochrom> fun fact: suppose you hOpen and forget to hClose, and you compile with -threaded. then when your program is idle (e.g. waiting for getLine) for a few seconds, the GC will do hClose for you.
10:05:54 <jfischoff> monochrom: with getNumCapabilities >>= print I get ‘1’ with no rts options, and ‘8’ with -N
10:06:45 <monochrom> so?
10:07:30 <jfischoff> … I think we interpreted that question differently.
10:12:49 <vanila> Cale, are you aroundasd
10:12:50 <vanila> -asd
10:13:35 <schell> I’m trying to write a small AST for opengl uniform updates, but my wanted API doesn’t type check. Do you guys know of a way to essentially “store and hide” different types inside another type?
10:14:08 <schell> i’m also trying to avoid creating a type that is an enumeration of all possible uniform updates
10:15:17 <schell> at the core, my problem is that [(projection, matrix1), (modelview, matrix2)] doesn’t typecheck because projection and modelview are different types
10:15:43 <schell> but the functions that would use them down the line would use them in the same way
10:15:56 <schell> http://lpaste.net/110189
10:16:22 <schell> http://lpaste.net/110189#line46 is the error
10:16:47 <eriksensei> schell: have you looked at existential types?
10:16:51 <schell> i’m hoping there’s some kind of ghc-extension-fu that can accomplish this, but…
10:17:04 <schell> eriksensei: no, i will look that up
10:17:09 <schell> thanks :)
10:17:36 <eriksensei> schell: hope it helps :)
10:17:49 <schell> eriksensei: at this point any leads do!
10:18:07 <merijn> existential types almost NEVER make things better
10:18:39 <merijn> schell: Do projection and modelview support the same operation?
10:18:46 <schell> merijn: they do
10:19:10 <merijn> schell: WHy not replace them by a record that has those operations?
10:19:16 <schell> setUniforms shader (modelview =: matrixdata)
10:19:49 <hexagoxel> schell: phantom types
10:20:14 <hexagoxel> that way you can distinguish both matrix types if you want to, but you can also have operations that work on both
10:20:22 <merijn> @google scrap your typeclasses
10:20:24 <lambdabot> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
10:20:24 <lambdabot> Title: Haskell for all: Scrap your type classes
10:20:35 <merijn> schell: Maybe the blog post provides some inspiration
10:20:48 <schell> merijn: i’m not sure i follow, but what i’d like to do is support any two types that can be used with (=:)
10:20:54 <hexagoxel> i agree that existential types/typeclasses seems bad for this usecase
10:20:55 <schell> and use those in my AST
10:22:22 <eacameron> how can I write/modify MVar strictly?
10:22:57 <schell> merijn, hexagoxel: thanks for the leads :)
10:26:11 <glguy> eacameron:   putMVar myvar $! myval
10:26:45 <hexagoxel> whnf enough?
10:27:47 <eriksensei> merijn, hexagoxel, schell: i hereby retract my advice of looking into existential types :)
10:28:23 <schell> eriksensei, merijn, hexagoxel: thanks and just so you guys have some background here’s what I’m trying to accomplish http://lpaste.net/110194
10:28:52 <oisin761> Does cabal allow me to "tie in" an executable to run after or before cabal build / run? What should I be Googling for?
10:29:18 <dcoutts> oisin761: you can use the Setup.hs to add before/after hooks
10:29:38 <oisin761> dcoutts: Thanks!
10:32:39 <eacameron> glguy: thanks
10:33:49 <eacameron> I have a situation where adding -Nx makes the program slow down as x increases; is there a common mistake that I may have made that might have caused this? I'm not sure where to start looking
10:34:39 <eacameron> I suppose the first thing is to check for contention?
10:36:42 <jfischoff> eacameron: but would not have the same number of green threads regardless?
10:36:56 <pjdelport> eacameron: Too high granularity?
10:37:35 <eacameron> I don't quite understand either of your questions... ;) ?
10:39:50 <jfischoff> The number of threads trying to access shared state would cause contention, but I would assume that it would happen regardless of the capabilities (-N)
10:39:53 * hackagebot acme-stringly-typed 1.0.0.0 - Stringly Typed Programming  http://hackage.haskell.org/package/acme-stringly-typed-1.0.0.0 (SvenStruett)
10:40:07 <bennofs> eacameron: do you use forkIO (manual) to spawn your threads, or Control.Parallel style?
10:40:26 <eacameron> bennofs: I use async
10:41:10 <bennofs> jfischoff: if the threads all run on the same CPU, then the CPU cache works better (I'm not a perf guru so Idk exactly) I think
10:41:40 <eacameron> does -N2 use two CORES then?
10:42:07 <eacameron> i.e. is -N about cores or about OS threads?
10:42:29 <bennofs> eacameron: it will use 2 capabilities, which are roughly OS threads
10:42:44 <bennofs> eacameron: and if you have multiple OS threads, the OS might schedule them to multiple cores
10:42:48 <geekosaur> it's about threads. cores to threads is often not something that can be readily (or portably) controlled
10:43:03 <eacameron> geekosaur: bennofs: ok that's what I thought
10:43:29 <bennofs> eacameron: how big is your code? if it's ~100 lines or less, maybe you can share it (lpaste) so we can try?
10:43:45 <eacameron> bennofs: unfortunately it's proprietary... :(
10:43:50 <bennofs> :|
10:45:44 <Enigmagic> eacameron: often times the default GC settings cause harm with high values of -Nx
10:48:28 <eacameron> Enigmagic: hmmm, any idea what a better setting would be?
10:49:43 <bjoernlenz> \join #nixos
10:49:55 <bjoernlenz> sry
10:50:02 <sagittarian> is there a standard function that's the same as flip (.)?
10:50:14 <bennofs> Control.Arrow.(>>>)
10:50:33 <bennofs> :t (>>>) `asTypeOf` flip (.)
10:50:33 <sagittarian> ah good point
10:50:35 <lambdabot> (a -> b) -> (b -> c) -> a -> c
10:50:53 <Enigmagic> eacameron: easiest thing to try first is -gq1 (or is it -qg1?)
10:51:27 <Enigmagic> eacameron: that disables the parallel collector for gen0..
10:52:09 <eacameron> Enigmagic: is there no way for GHC to spawn n number of threads as they are needed?
10:52:51 <sagittarian> what is .:?
10:52:57 <sagittarian> i saw it in some code but it's not in prelude
10:53:04 <josephle> :t (.:)
10:53:06 <lambdabot>     Not in scope: ‘.:’
10:53:06 <lambdabot>     Perhaps you meant one of these:
10:53:06 <lambdabot>       ‘.’ (imported from Data.Function),
10:53:08 <eacameron> Enigmagic: or is that just forkOS
10:53:10 <josephle> :(
10:53:22 <sagittarian> already tried that josephle
10:53:29 <genisage> That's the double compose operator, right?
10:53:37 <Enigmagic> eacameron: GHC will spawn OS threads as needed, up to whatever you have -N set to
10:53:39 <sagittarian> where can i import it from?
10:53:47 <eacameron> Enigmagic: ahh
10:53:55 <merijn> sagittarian: Data.Functor.Compose, I think?
10:54:06 <merijn> oh wait
10:54:06 <fizbin> sagittarian: See http://hackage.haskell.org/package/composition-1.0.1.0/docs/Data-Composition.html
10:54:12 <sagittarian> nope
10:54:19 <genisage> (.:) :: (c -> d) -> (a -> b -> c) -> a -> b -> c
10:54:24 <genisage> I think
10:54:40 <glguy> josephle: Data.Aeson uses (.:) for  creating object parsers
10:54:44 <Enigmagic> eacameron: forkOS will create an OS thread that is bound to a single haskell thread. sometimes what you want, but not that often.
10:54:58 <Enigmagic> or rather a single haskell thread bound to a single OS thread.
10:54:59 <fizbin> genisage: Almost. result has type "d"
10:55:11 <glguy> josephle: Maybe this is what you saw? http://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson.html#v:.:
10:55:12 <fizbin> (.:) :: (c -> d) -> (a -> b -> c) -> a -> b -> d
10:55:20 <genisage> fizbin: oops, I knew that.
10:55:39 <glguy> The .: as a super-compose operator is best left to obfuscating code for IRC
10:55:42 <sagittarian> thanks fizbin
10:56:39 <fizbin> glguy: And really, the (->) monad and obscure monad operators are better at that (obfuscating code) in any case.
10:57:00 <glguy> fizbin: sure, there are lots of ways to destroy readability
10:57:24 <benzrf> glguy: i disagree
10:57:30 <benzrf> i find (.:) quite nice
10:57:46 <benzrf> it's certainly more readable than (foo .) . func, or whtever
10:57:59 <benzrf> 'oh this is regular compo but the 1st func has 2 args, easy'
10:58:00 <bennofs> fmap foo . func
10:58:12 <bennofs> is my favourite
10:58:17 <benzrf> gross
10:59:13 <bennofs> oh wait, that still needs some lens: func & mapped.mapeed %~ foo
10:59:48 <glguy> benzrf:  (foo .) . func  isn't any better
10:59:59 <benzrf> glguy: thats what i just said
11:00:06 <benzrf> oh u mean vs fmap
11:00:11 <glguy> so youd' just write:   foo (func x y)
11:01:00 <fizbin> :t fmap (fmap join) (flip fmap)
11:01:01 <lambdabot> (Functor f, Monad f) => f a1 -> (a1 -> f a) -> f a
11:01:15 <fizbin> :t (>>=)
11:01:16 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:10:47 <fizbin> I hope someday for a post-AMP lambdabot.
11:11:26 <oisin898> I'm not sure what I've done, but `cabal run` keeps throwing the error: You need to re-run the 'configure' command... The version of Cabal being used has changed, was 1.20.0.2, no 1.20.0.1. Additionally, the compiler is different, was 7.8 now 7.6. How do I resolve this and what caused it?
11:11:40 <oisin898> It happens after I run cabal configure, as well.
11:12:39 <dfeuer_> Why does GHC ship with Win32 graphics libraries, but not graphics libraries for anything else?
11:14:43 <shachaf> Graphics are not separate from other parts of the Windows API.
11:24:45 <infandum> Does anyone know if this scenario is possible? I have a program which uses unsafePerformIO in one location in the code (used a bunch of times due to a recursive call, but waitForProcess ensures that it is happening just once at a time) and on big data I get a segmentation fault, NON-DETERMINISTICALLY. However, it just started working perfectly--why!?!? Is it possible that ANOTHER program (a user running
11:24:46 <infandum> matlab code) could be accessing memory illegally, messing with the haskell program?
11:27:07 <dfeuer_> infandum, not in any modern operating system.
11:27:51 <supki> @quote unsafePerformIO.*is.not.a.bug
11:27:51 <lambdabot> Lemmih says: "I don't understand why my code acts weird when I use unsafePerformIO" is not a bug.
11:27:53 <infandum> dfeuer_: Weird--then why is it nondeterministic? I'm not using concurrency or threads or parallel anything...
11:27:55 <dfeuer_> infandum, The most basic guarantee modern general-purpose hardware and OSes give is that different processes will not access each other's memory.
11:27:57 <oisin898> Ah, I solved it with cabal install cabal cabal-install
11:28:55 <dfeuer_> infandum, you say it just started working perfectly. Did you upgrade GHC?
11:29:03 <infandum> dfeuer_: Hmm. I'm just trying to find out what's causing the segfault (and why it's fine now when I didn't touch the code).
11:29:08 <infandum> dfeuer_: Nope.
11:29:43 <dfeuer_> If you didn't touch the code or upgrade the compiler (or a package your code uses) then it's *not* fine now.
11:30:06 <eriksensei> is there a Haskell type that is inhabited only by undefined? i'm looking for something like Maybe's Nothing, but without the Just part
11:30:14 <`^_^> Void
11:30:21 <eriksensei> ah! thanks :)
11:30:24 <infandum> dfeuer_: All I know is that my coworker has been running a gigantic process and my code was segfaulting (it normally does not, I blame bigger data) but then when his code stopped my started working. It's paranoid, but it's a correlation
11:31:09 <infandum> dfeuer_: Yes, it's most likely not fine--but on smaller data it is. On bigger data it is nondeterministic with the SAME input (which should have the same output, even with my unsafe call)
11:31:18 <dfeuer_> infandum, that *strongly* suggests that your code has a race condition.
11:31:43 <dfeuer_> That is, whatever you're doing to try to manage what's going on between your threads is not robust.
11:31:49 <infandum> dfeuer_: Normally I would agree--but how? I have no parallelism in this program. I don't even know how to do it in haskell yet.
11:33:10 <infandum> dfeuer_: Unless some libraries I'm using use parallelism--but they don't advertise it
11:33:55 <infandum> dfeuer_: They are pretty common libraries though, and in the only unsafe part I have waitForProcess right after the unsafe process I call
11:33:56 <supki> eriksensei: the latter is called Proxy and is different from an uninhabited type
11:34:16 <pavonia> infandum: Could you paste the unsafe parts of your code? Maybe it's something "obvious"
11:34:59 * hackagebot persistent-template 2.0.0.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.0.2 (GregWeber)
11:35:33 <infandum> pavonia: Sure, hold on a sec. It's a call to svdlibc
11:35:35 <eriksensei> supki: what do you mean by 'the latter'?
11:35:55 <supki> Maybe-without-the-Just-part thing
11:36:15 <eriksensei> supki: this one? http://hackage.haskell.org/package/tagged-0.2.3.1/docs/Data-Proxy.html
11:36:29 <supki> yep
11:36:56 <dfeuer_> infandum, if you're dealing with waitForProcess, you're dealing with concurrency in some fashion.
11:37:00 <eriksensei> spuki, ok thanks, i'll read up on it!
11:37:21 <dfeuer_> infandum, one possibility is that waitForProcess isn't actually  running when you think it is.
11:37:42 <dfeuer_> Or there could be some laziness thing wonking around with it. Why are you using unsafePerformIO anyway?
11:37:51 <eriksensei> sorry, i meant supki
11:37:59 <josephle> eriksensei: of course, undefined is not the *only* inhabitant of Proxy
11:38:17 <josephle> so take that into account in the greater scope of your question
11:38:37 <infandum> dfeur, pavonia: Here is the code: http://pastebin.com/ANWjcpQh
11:39:04 <dfeuer_> erikd, if you want a type inhabited *only* by undefined, use Void, from Data.Void
11:39:08 <dfeuer_> sorry....
11:39:09 <infandum> I'm basically writing a sparse matrix to a file, running svdlibc on that file, and getting the result
11:39:11 <dfeuer_> I meant eriksensei.
11:39:28 <dfeuer_> conal the Mac person!
11:39:49 <eriksensei> josephle, dfeuer_: i see, thanks!
11:40:31 <dfeuer_> eriksensei, but yeah, it seems a lot of people say Proxy is more often what you want.
11:41:36 <eriksensei> dfeuer_: it's basically just for some experiments right now, but they both look useful
11:41:37 <josephle> I've used Void for theorem proving, but is there another application of Void?
11:41:38 <Peaker> http://www.well-typed.com/blog/97/ <-- almost what I was complaining about recently -- except disregards the main problem of cleanup being interruptible
11:42:33 <eriksensei> josephle: i'm using it to denote that there shouldn't really be anything there, and move along please
11:42:50 <Peaker> I think maybe what Haskell needs is "bracket", "catch", "handle", "finally", "onException", and others that use uninterruptibleMask for the cleanup, and interruptible mask for the before/action
11:43:55 <dfeuer_> Why is undefined==undefined  for Void?
11:44:14 * dfeuer_ looks up and sees that infandum tried to say his name but got it wrong.
11:45:15 <josephle> dfeuer_: that's interesting, I'd expect it to be "_ == _ = absurd"
11:45:40 <infandum> oops
11:45:46 <dfeuer_> josephle, so would I. But I don't understand the deep theory between waht this sort of thing is for.
11:45:59 <monochrom> Void is really a corner case where x==x can be argued to be True and can be argued to be False
11:46:17 <monochrom> or rather, x==y
11:46:30 <infandum> dfeuer_: Also, I think that it happens before the unsafe call sometimes as well.
11:46:36 <dfeuer_> infandum, I think I see the problem.
11:46:49 <monochrom> since you're talking about an empty domain, both "forall x,y. x==y" and "forall x,y. x/=y" are true
11:46:49 <infandum> dfeuer_: Really? This has been bugging me for ages!
11:47:40 <monochrom> at the end perhaps Void should be given no Eq instance at all
11:48:00 <glguy> monochrom: That'd be aggravating. imagine you had an : Either Void Int
11:48:02 <dfeuer_> infandum, I can't really be sure, of course. But tmixing unsafePerformIO with readFile looks completely insane.
11:48:04 <infandum> dfeuer_: It must be weird, because with smaller data it works
11:48:11 <glguy> monochrom: you could reasonably expect to compare for equality
11:48:13 <infandum> oh
11:48:36 <monochrom> ah, logic is so hard
11:48:53 <infandum> dfeuer_: But most of the time it crashes before svd outputs anything, so it must be before readFile most of the time as well
11:49:00 <vanila> instance Eq Void where
11:49:04 <vanila> that should be fine
11:49:08 <monochrom> heh
11:49:10 <vanila> now Right 3 == Right 3 works ok
11:49:31 <vanila> Left undefined == Left undefined will crash
11:49:58 <monochrom> this is the best form of my: don't answer to answer, just don't answer :)
11:50:01 * hackagebot friday 0.1.3 - A functionnal image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.1.3 (RaphaelJavaux)
11:50:21 <dfeuer_> infandum, the most obvious problem with that is that svdResult is the result of *lazily* reading the file. So if sparseWriteSVD is run again before that is complete, then it will presumably overwrite the file while you're still trying to read it.
11:50:37 <dfeuer_> I'm just guessing here.
11:50:42 <dfeuer_> But that looks VERY shady.
11:50:59 <infandum> dfeuer_: But that won't happen because of the waitForProcess, right?
11:51:09 <monochrom> on Windows, file locks also forbid you from writing
11:51:18 <josephle> "friday 0.1.3"...that's an inauspicious version number if I ever saw one
11:51:19 <dfeuer_> infandum, waitForProcess doesn't help you with that. I don't know about Windows.
11:51:35 <monochrom> (is it "forbid from" or "forbid to"?)
11:51:48 <infandum> dfeuer_: Oh, I mean that wouldn't help. But if the result of the readfile is used in order to determine the next unsafe call, then it should be ok, right?
11:51:59 <infandum> dfeuer_: Let me try to make it strict and see what happens
11:52:15 <infandum> dfeuer_: Even though I can't get the error again for some reason
11:52:31 <infandum> dfeuer_: Wait, it's not working again
11:52:32 <infandum> good
11:52:33 <dfeuer_> infandum, if the *entirely forced* result is used before then, you might be okay?
11:52:34 <infandum> ?
11:52:57 <infandum> dfeuer_: I'll test it being strict, this might take a few minutes due to file sizes
11:54:06 <dfeuer_> infandum, could you make svd take input from stdin and produce output on stdout? That might (maybe) be slightly saner (perhaps).
11:55:24 <infandum> dfeuer_: It looks like unsafePerformIO is lazy only, so I don't know what else to do there, but I can check the stdin and stdout
11:55:58 <dfeuer_> infandum, I don't think you understand what I was speculating.
11:56:49 <dfeuer_> I was suggesting maybe using  deepSeq svdResult (return svdResult)  might do something useful.
11:56:56 <infandum> dfeuer_: It looks like svd works on files only
11:57:52 <dfeuer_> infandum, you can use strict functions instead of readFile too. That might be better?
11:58:02 <dfeuer_> Oh wait.
11:58:04 <dfeuer_> Hahaha.
11:58:17 <dfeuer_> I think I see another obvious issue.
11:58:32 <dfeuer_> Give me a second...
11:58:32 <infandum> dfeuer_: Can I put bangpatterns on svdResult?
11:58:37 <dfeuer_> No.
11:58:46 <dfeuer_> I mean, maybe, but that won't fix it.
11:58:53 <dfeuer_> Because you need to force it all the way.
11:59:15 <infandum> dfeuer_: But it's a string, right? How is that not all the way?
11:59:43 <dfeuer_> A string is a list.
11:59:48 <infandum> oh
11:59:49 <infandum> duh
12:00:13 <dfeuer_> Hey, don't get me wrong here: I could be barking up the wrong trees....
12:00:28 <infandum> dfeuer_: Still worth a shot
12:00:30 <infandum> won't hurt
12:00:31 <dfeuer_> I just think what you're doing looks very shady, and these are some of the ways it looks shady.
12:00:56 <infandum> mhm
12:01:26 <infandum> But it's the best I can think of for doing a sparse svd in haskell
12:01:41 <infandum> (hmatrix has no sparse matrices or operations)
12:01:59 <dfeuer_> infandum, you should talk to carter.
12:02:08 <infandum> haha I think I have
12:02:15 <infandum> is he working on a new math library?
12:02:22 <dfeuer_> He's been doing a LOT of work on sparse matrices.
12:02:25 <dfeuer_> Yes.
12:02:33 <infandum> he said he would have a grand release over a year ago
12:02:38 <infandum> I was super excited
12:02:39 <infandum> but
12:02:41 <infandum> well
12:02:44 <infandum> yeah
12:03:48 <dolio> monochrom: It's definitely not "forbid you to writing" at least. :)
12:04:30 <monochrom> haha
12:04:36 <dfeuer_> dolio, what do you think about infandum's code? I've been giving ideas, but I'm a beginner myself!
12:04:50 <dfeuer_> Or monochrom...
12:05:09 <monochrom> now I have to find the code
12:05:31 <infandum> dfeuer_: I implemented deepseq to see how it goes
12:06:08 <dfeuer_> infandum, you don't need to implement it; you just need to use it.
12:06:13 <monochrom> unsafePerformIO?!
12:06:24 <infandum> dfeuer_: Haha well it's being used now
12:06:44 <c_wraith> evenMoreUnsafePerformST :: ST s a -> a
12:07:05 <dolio> I think it looks very suspicious.
12:07:44 <infandum> I mean, I tried to use the IO monad, but the call for this is so far down that the entire program would be in the IO monad, also the main function is a recursion to create a binary tree and going through that with IO was creating type errors which I did not know how to resolve
12:08:12 <monochrom> ok, you may assume that the following is one atomic transaction, i.e., all happen or none happens: write file and finish writing, then runcommand and it finishes, then open file for reading.
12:08:35 <dolio> Why is it marked inline?
12:08:50 <infandum> dolio: unsafePerformIO told me to do that in the docs
12:08:50 <monochrom> but you have only opened for reading. no real reading has begun. this is postponed until evaluation of the answer happens.
12:09:00 <dfeuer_> c_wraith, evenMoreUnsafePerfomST is the same as unsafePerformIO, right?
12:09:28 <monochrom> no, I thought it told you "NOINLINE"
12:09:36 <infandum> monochrom: It has to be read before the next iteration, so I'm not worried about that but I put it in deepseq just in case
12:09:50 <monochrom> and at any rate it tells you why and why not, and you still have to decide for yourself, not obey.
12:10:00 <c_wraith> dfeuer_: Yes, but it's worse in the same way unsafeInterleaveST is way worse than unsafeInterleaveIO
12:10:21 <dfeuer_> c_wraith, I don't actually know what makes that particularly evil either.
12:10:27 <infandum> monochrom: whoops, can't believe I missed that
12:10:44 <dolio> I don't think the inlining matters, because it's already a function.
12:10:53 <c_wraith> dfeuer_: http://lpaste.net/92226
12:10:58 <dolio> But it's still not something I'd recommend.
12:11:17 <infandum> dolio: So I should leave NOINLINE in there?
12:11:30 <monochrom> you should know why and why not
12:11:33 <dfeuer_> I don't think the inlining is the issue either. But I don't know enough about the machinery of readFile to know what evil will happen between it and unsafePerformIO.
12:11:39 <dolio> I don't really think you should do this in the first place. :)
12:12:10 <infandum> dolio: Until I can do sparse svd another way I need to do this :(
12:12:19 <monochrom> if you use unsafePerformIO, you have given up your license to do cargo cult. you must now know what is going on.
12:12:51 <dfeuer_> c_wraith, that code makes me dizzy.
12:13:36 <c_wraith> dfeuer_: It also violates referential transparency, thanks to unsafeInterleaveST
12:13:51 <infandum> monochrom: I just thought it was as simple as "you must guarantee that the function with the side effect always returns the same result with the same input", which SHOULD be true here I think
12:13:56 <monochrom> Oleg has a fun unsafeInterleaveST example too. same idea.
12:14:14 <c_wraith> I just realized I could modify that example to return two lists.  That'd be even better.
12:14:46 <monochrom> infandum, that is said for unsafePerformIO, but not for whether you INLINE or NOINLINE or neither.
12:15:15 <infandum> monochrom: Oh. Well for that I kinda read over it, kinda understood it, and blindly put it in
12:15:59 <infandum> monochrom: I mean, it shouldn't be performing more than once, so I didn't understand why that would happen
12:16:43 <c_wraith> dfeuer_: http://lpaste.net/110207 is even more fun!
12:16:50 <infandum> Okay, well maybe I should go back to everything in the IO monad
12:16:58 <infandum> but in that sense--how do I resolve this:
12:17:04 <monochrom> oh, it's normal to perform twice.
12:18:08 <dfeuer_> c_wraith, I can't even remember just what unsafeInterleaveST is supposed to do.
12:18:28 <dolio> It waits to do something until you demand the result.
12:18:46 <c_wraith> dfeuer_: exact same thing as unsafeInterleaveIO!
12:19:14 <monochrom> even in the simplest case, f 1 + f 1 may compute f 1 twice, even if f is pure function, so nevermind if f uses unsafePerformIO
12:19:23 <dfeuer_> Ah.
12:19:24 <phaazon> is there a way to pass options to haddock in a .cabal?
12:19:27 <infandum> monochrom: I have a tree, data Tree a = EmptyTree | Node a (Tree a) (Tree a). How can I create a binary tree with "createTree :: Stuff -> IO (Tree (IO Int))"
12:19:27 <phaazon> like the prune option
12:19:48 <monochrom> and if you INLINE f, that can only mean higher chance of computing f 1 twice, not lower
12:19:51 <dfeuer_> c_wraith, while I'm looking over there, what makes unsafeTToIO unsafe, exactly?
12:20:08 <dfeuer_> sorry, I meant unsafeSTToIO
12:20:26 <infandum> monochrom: As you can imagine, the IO would be in the computation of createTree, returning an IO Int for use in the tree.
12:20:27 <monochrom> I don't know what is Stuff
12:20:38 <c_wraith> dfeuer_: STRefs can escape
12:21:06 <Cale> dfeuer_: Are you talking about unsafeIOtoST?
12:21:15 <dfeuer_> No, Cale, that's obviously unsafe.
12:21:24 <monochrom> but "createTree _ = return (Node (return 10) EmptyTree EmptyTree" is an example
12:21:37 <c_wraith> dfeuer_: I guess that's not so bad, since the type system will force them to be STRef RealWorld, but it's still..  unpleasant.
12:21:56 <infandum> monochrom: Just unecessary things. Let's say Bool -> Int -> IO (Tree (IO Int)) and the integer gets +1 each iteration and when it's, say > 8 then the bool variable triggers and a leaf is made instead of a tree
12:22:01 <dolio> @type unsafeSTToIO (newSTRef 5)
12:22:02 <lambdabot> Not in scope: ‘unsafeSTToIO’
12:22:23 <Cale> Oh, I didn't even notice that existed in the new version
12:22:34 <dfeuer_> @type GHC.IO.unsafeSTToIO (newSTRef 5)
12:22:36 <lambdabot> Num a => IO (STRef s a)
12:22:53 <c_wraith> Oh, it doesn't force it to be STRef RealWorld.  Ok, then, that's *bad*
12:22:54 <Cale> I guess it's the fact that it's using unsafeCoerce?
12:22:57 <monochrom> each iteration of what?
12:23:01 <Cale> yeah
12:23:06 <infandum> monochrom: But what if instead of EmptyTree in your example, it was recursive, with a createTree in each left and right subtree
12:23:21 <Algebr> Why does runhaskell not play nice with sandboxes?
12:23:24 <infandum> monochrom: Only an EmptyTree if the bool triggers
12:23:37 <c_wraith> Algebr: sandboxes are managed by cabal.  runhaskell does not use cabal
12:24:11 <monochrom> ok, I don't understand why this involves IO.
12:24:15 <dfeuer_> c_wraith, I'm still not seeing the badness. You can't *do* anything with that STRef, can you? Unless you unsafeCoerce# it to an IORef or something?
12:24:49 <dolio> You can read it in another ST computation that you unsafeSTToIO.
12:24:50 <monochrom> I also don't understand how this depends on the Bool parameter
12:24:51 <dfeuer_> Er .... no, I'm wrong.
12:24:56 <infandum> monochrom: Because I need to clearly avoid unsafePerformIO, so I need to use actual IO
12:25:05 * hackagebot persistent-template 2.0.0.3 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-2.0.0.3 (GregWeber)
12:25:32 <dfeuer_> dolio, I think it's worse than I realized, because it (appears to be) polymorphic in s. So it will fit anywhere, I think.
12:25:44 <c_wraith> yeah, that type signature makes it polymorphic in s
12:26:04 <dolio> You can also construct an ST action that reads a ref, turns that action into an IO, and then run the ST action.
12:27:38 <dfeuer_> @type GHC.IO.unsafeSTToIO (newSTRef 5) >>= \ref -> runST readSTRef ref
12:27:39 <lambdabot>     Couldn't match expected type ‘ST s (STRef s0 a0 -> IO b)’
12:27:39 <lambdabot>                 with actual type ‘STRef s1 a1 -> ST s1 a1’
12:27:39 <lambdabot>     Relevant bindings include
12:27:41 <monochrom> http://lpaste.net/110210  createTree :: Int -> Tree Int, pure, what am I missing?
12:28:02 <dfeuer_> @type GHC.IO.unsafeSTToIO (newSTRef 5) >>= \ref -> runST (readSTRef ref >>= return)
12:28:04 <lambdabot>     Couldn't match type ‘s0’ with ‘s’
12:28:04 <lambdabot>       because type variable ‘s’ would escape its scope
12:28:04 <lambdabot>     This (rigid, skolem) type variable is bound by
12:28:14 <dolio> No, stop.
12:28:24 <dfeuer_> Sorry.
12:28:41 <joshc_> Algebr: you can use: cabal exec runhaskell foo.hs
12:28:47 <joshc_> from within the sandbox
12:29:02 <infandum> monochrom: Yes, except createTree returns IO (Tree (IO a))
12:29:35 <monochrom> I don't understand. my code typechecks. And it's Int -> Tree Int.
12:30:00 <sagittarian> :t id
12:30:01 <lambdabot> a -> a
12:30:06 * hackagebot monad-journal 0.2.3.1 - Pure logger typeclass and monad transformer  http://hackage.haskell.org/package/monad-journal-0.2.3.1 (DimitriSabadie)
12:30:07 <sagittarian> > id (2+) 5
12:30:08 <lambdabot>  7
12:30:19 <sagittarian> can someone explain to me what's going on there?
12:30:26 <vanila> id x = x
12:30:31 <vanila> so id (2+) 5 = (2+) 5
12:30:34 <monochrom> perhaps I don't understand your specification. (not implementation. specification.)
12:30:53 <sagittarian> but that's two arguments
12:31:03 <c_wraith> so/
12:31:08 <sagittarian> you can give id any number of arguments?
12:31:08 <infandum> monochrom, yes, but my (n > 8) function is actually (some n that is inside of the IO monad).
12:31:13 <vanila> id (2+) 5 parses as ((id (2+)) 5)
12:31:19 <vanila> so id is only getting one argument
12:31:21 <sagittarian> oh right
12:31:22 <sagittarian> thanks
12:31:27 <infandum> monochrom: And I can't compare it unless it's all in the IO monad
12:31:29 * sagittarian slaps his forehead
12:31:34 <infandum> monochrom: Which blows it all up
12:31:35 <c_wraith> sagittarian: remember, *all* functions take only one argument
12:31:39 <sagittarian> right
12:32:06 <c_wraith> sagittarian: so what's the concrete type of id in your example?
12:32:12 <monochrom> but your desired type is Bool -> Int -> ..., not Bool -> IO Int -> ...  You can an Int, where is the IO?
12:32:58 <Algebr> What does instance [incoherent] ... mean?
12:33:03 <monochrom> can you write down a complete formal specification?
12:33:05 <sagittarian> id :: Num a => (a -> a) -> a -> a if i understand correctly
12:33:40 <c_wraith> sagittarian: well.  That's a slightly-more-specialized polymorphic one.  With defaulting, it ends up being (Integer -> Integer) -> Integer -> Integer
12:33:48 <monochrom> "instance [incoherent]" means that the source code of that instance is compiled with IncoherentInstances enabled
12:33:57 <sagittarian> okay, same idea, thanks c_wraith
12:34:08 <c_wraith> sagittarian: but yeah, that's the basic idea.  Also, take a close look at the type of ($)
12:34:09 <infandum> monochrom: I'm confused. Let me state my issue. I have a matrix. I am making a tree that depends on that matrix. Each split in the binary tree depends on the result of a function on that matrix which uses IO. Therefore, Everything needs to be in IO, right?
12:34:21 <sagittarian> :t ($)
12:34:22 <lambdabot> (a -> b) -> a -> b
12:34:37 <Algebr> monochrom: okay, so what does that mean?
12:34:53 <monochrom> I don't have time to explain incoherent instances.
12:34:58 <c_wraith> sagittarian: Any idea why I suggested looking at that.
12:35:10 * shachaf wonders whether c_wraith would call e.g. (forall a. a -> a) -> Integer concrete.
12:35:17 <sagittarian> c_wraith, i'm thinking about it
12:35:49 <c_wraith> shachaf: Once you leave prenex types, I'm no longer sure what "concrete" means.
12:35:55 <infandum> monochrom: OK, I think I fixed it anyways. Thanks for tolerating me :)
12:36:05 <infandum> monochrom: EVERYTHING is in the IO monad now haha.
12:36:10 <monochrom> "everything" is very all-encompassing. be careful when you say "everything, absolutely everthing"
12:36:13 <shachaf> It's a stricter requirement on the caller than e.g. (Integer -> Integer) -> Integer
12:36:19 <sagittarian> ($) takes a function and an argument and applies the argument to the function, okay
12:36:32 <monochrom> you need at most IO Int -> IO (Tree Int)
12:36:32 <sagittarian> so, no, i don't know why you specifically suggested that, c_wraith
12:36:36 <shachaf> Anyway, fair enough.
12:36:38 <dolio> shachaf: Shh. That type doesn't exist. :)
12:37:17 <c_wraith> sagittarian: I can add some parens to that type without changing it..  ($) :: (a -> b) -> (a -> b)
12:37:25 <sagittarian> of course
12:37:26 <monochrom> I should stop talking to programmers. they can't write specifications. they can only write implementations.
12:37:26 <sagittarian> ah
12:37:41 <RyanGlScott> Is there a way to consolidate multiple cases in a case statement (similar to foo match { case Bar() | Baz() => "quux" } in Scala)?
12:37:50 <sagittarian> so ($) is id, with the constraint that it takes a function
12:37:52 <sagittarian> yes?
12:37:56 <shachaf> RyanGlScott: Not really.
12:38:02 <c_wraith> sagittarian: exactly
12:38:21 <sagittarian> cool, thanks a lot c_wraith
12:38:34 <c_wraith> sagittarian: and there's your new mental gymnastics trick for the day. :)
12:38:35 <monochrom> last time someone asked about a parsing problem, the grammar of which was in his head. I asked him to write down the grammar, which should only be 5 lines. he replied with "I have this so far" and 100 lines of parsec- or attoparsec-using code.
12:38:36 <infandum> monochrom: I'm not necessarily a programmer. I'm in biology, so it's even worse.
12:38:54 <sagittarian> so, assuming i'm careful about precedence, i could just write `id` instead of $
12:39:10 <Algebr> is <*> left associative?
12:39:18 <Tuplanolla> The more overlapping skill sets you ask for, the less people you will find, monochrom.
12:39:19 <sagittarian> :i <*>
12:39:25 <sagittarian> oh that doesn't work right
12:39:27 <c_wraith> sagittarian: you could.  It's a bit more typing, though.  still, sometimes you see things like (flip id) or (liftM2 id)
12:40:05 <Algebr> :t <*>
12:40:06 <lambdabot> parse error on input ‘<*>’
12:40:11 <merijn> monochrom: pffft, why would we ever learn people to spec out what they want? That's hard! Let's just hack something together :p
12:40:13 <josephle> :t (<*>)
12:40:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:40:31 <josephle> gotta have those operator "()"s
12:40:41 <sagittarian> huh, where is (<*>) located?
12:40:43 <monochrom> that is the divide between Intelligent Design and Evolution
12:40:50 <Tuplanolla> That's infixl 4, sagittarian.
12:40:53 <RyanGlScott> Is there a way to get Lambdabot to show information (like :i in GHCi)?
12:40:57 <pjdelport> @info (<*>)
12:40:57 <lambdabot> (<*>)
12:41:13 <Haskellfant> sagittarian: Control.Applicative
12:41:22 <sagittarian> thanks Haskellfant
12:41:23 <pjdelport> Eh, well:
12:41:23 <pjdelport> ghci> :i (<*>)
12:41:23 <pjdelport> infixl 4 <*>
12:41:23 <Haskellfant> will be in prelude with ghc 7.10 afaik
12:41:32 <pjdelport> Algebr: You can use that in ghci in general
12:41:56 <shachaf> RyanGlScott: There is no way.
12:41:57 <Algebr> pjdelport: sorry, just had an emacs bug.
12:42:04 <goglosh> "The type signature for 'function' lacks an accompanying binding
12:42:10 <goglosh> what does that mean?
12:42:27 <Tuplanolla> You have a type without a definition.
12:42:54 <goglosh> function :: [[a]] -> Int
12:43:00 <shachaf> goglosh: A "type signature" is a thing like this: "name :: ..."
12:43:13 <shachaf> A "binding" is a thing like this: "name = ...", or "name ... = ..."
12:43:19 <shachaf> You have the former without the latter.
12:43:24 <Tuplanolla> Add function = undefined after it and see.
12:43:36 <goglosh> oh it was a typo
12:43:39 <goglosh> :P silly me
12:43:58 <shachaf> goglosh: What you can learn from this is to show your code when you ask a question.
12:44:32 <goglosh> but now I know what a binding and a type signature is :P
12:45:19 <shachaf> Then maybe I made a mistake.
12:46:25 <monochrom> you should both show your code and ask what the terminology means
12:46:43 <monochrom> and we should answer all of them
12:47:15 <goglosh> awright
12:47:56 <infandum> quit
12:53:29 <kakos>  I keep seeing tutorials on how to do dependent types in Haskell that involves a hundred different extensions and involves some rather tortured syntax. Are there any plans to make a single unified extension for doing dependent types in haskell, hopefully with much cleaner syntax?
12:54:20 <shachaf> Haskell doesn't have dependent types.
12:54:46 <vanila> kakos, there's no way to do dependent types in haskell
12:54:57 <shachaf> There are no plans to add dependent types to GHC, either.
12:54:58 <Tuplanolla> Idris and Coq are better suited for that, kakos.
12:55:12 <vanila> none of these extensions reach that, they just let you do some more expressive type level stuff than usual
12:55:45 <monochrom> you can plan it yourself
12:55:53 <shachaf> There are various approximations for some things that you can do with dependent types.
12:56:29 <kakos> Ah, so it's not complete dependent types, just approaching dependent types.
12:56:42 <kakos> So, I guess the question is... why not add dependent types?
12:58:17 <Algebr> is ! syntax or an actual function?
12:58:25 <Algebr> or kind of like a pragma
12:59:27 <geekosaur> in what sense? there is an operator ! used for array indexing, which is a "normal" operator
12:59:27 <dolio> shachaf: There actually are plans to add them, I learned.
12:59:40 <dolio> But not plans that you should be expecting to occur any time soon.
12:59:46 <shachaf> dolio: Whose?
12:59:52 <dolio> Richard's.
12:59:52 <Algebr> geekosaur: talking about the one that says something should be strict
12:59:57 <geekosaur> there is also its use in `data` for strict fields, which is syntax. and an extension syntax BangPatters which enables that meaning in patters
13:00:18 <ReinH> So, I'm hitting a cabal-install bug and the proposed fix doesn't work for me. https://github.com/haskell/cabal/issues/1883
13:00:27 <ReinH> setting LANG as suggested has no effect. :/ any ideas?
13:00:39 <kakos> dolio: You have a link?
13:00:49 <dolio> I don't think there is a link.
13:01:04 <monochrom> dolio: which Richard?
13:01:31 <shachaf> monochrom: Is there more than one?
13:01:34 <dolio> Eisenberg.
13:01:49 <brisbin> ReinH: are you sure LANG is being set in the environment the code's seeing?
13:02:20 <ReinH> brisbin: it's in the env when I run cabal install, and I've also tried LANG=$CORRECT_THING cabal install directly
13:02:27 <ReinH> brisbin: beyond that I'm not sure how to determine it
13:02:43 <brisbin> if you're sure $CORRECT_THING is correct, then i'm out of ideas
13:02:52 <monochrom> I was hoping it was not Richard Bird
13:03:04 <ReinH> brisbin: It's the thing they suggested in the issue. Let me triple-check for typos.
13:03:10 <merijn> kakos: Because dependent types cost you type inference :)
13:03:23 <brisbin> ReinH: i have en_US.UTF-8 as my $LANG
13:03:28 <ReinH> I have en_US.UTF-8
13:03:29 <merijn> kakos: Haskell's type system (without extensions) is inferrable, dependent types in general, aren't
13:03:34 <brisbin> :shrug:
13:03:37 <ReinH> sad face
13:03:49 <brisbin> it's available in locale -a yeah?
13:04:02 <merijn> kakos: FYI, doing dependent types in an actual dependent language is much easier than faking it in haskell, if you're interested I would just try playing with those
13:04:16 <merijn> kakos: Idris is being specifically designed to be usable for haskell programmers
13:04:32 <brisbin> ReinH: i'm suspicious of your system in general, $LANG should just be set appropriately. linux, mac?
13:04:38 <vanila> kakos, because you need all functions to terminate for the logical interpretation of dependent types of be valid
13:05:12 <ReinH> linux, ubuntu 14.04
13:05:32 <brisbin> ReinH: and what does locale -a say?
13:05:33 <merijn> vanila: You can easily have non-total dependent types...
13:06:01 <vanila> merijn, you actually break the type safety entirely if you don't have strong normalization
13:06:24 <ReinH> brisbin: well, locale -a didn't list it so I've added it. Rather strange, that.
13:06:27 <ReinH> let's try again
13:06:29 <merijn> vanila: Define type safety
13:06:40 <monochrom> do you know you have to "export LANG" as well?
13:06:40 <vanila> @where TAPL
13:06:40 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
13:06:42 <{AS}> vanila: Yeah, they are not usable as proofs but they allow some features to be used. See Dependent ML
13:06:52 <merijn> vanila: I have read TaPL
13:07:02 <merijn> vanila: Type safety ONLY exists in relation with a model
13:07:14 <merijn> And a language is type safe IFF it doesn't violate the model
13:07:32 <merijn> C is type safe, given a sufficiently flexible model
13:07:40 <vanila> C is not type safe
13:07:41 <monochrom> OTOH, if you do nothing to LANG, the ubuntu default is already correct, i.e., some UTF-8 thing
13:07:47 <brisbin> ReinH: yup, get it to appear there (may require locale-gen logout/login), then i suspect it will work
13:07:48 <fizbin> I have some code that currently runs as a command-line program and I want to turn it into a simple REST service of the "post json, get response as json" type. Assume I've never used a haskell web framework. What haskell web framework should I go read up on?
13:07:55 <merijn> vanila: Your claim that "not being total gives up type safety" requires you to specify the model in which you are being type safe
13:07:55 <ReinH> brisbin: that was it, thanks. How strange that it wasn't already configured.
13:08:04 <brisbin> sigh-buntu
13:08:09 <ReinH> brisbin: heh
13:08:12 <merijn> vanila: C type safety, like other languages, depends on the model we're checking
13:08:18 <fizbin> Yesod seems to be the standard hotness currently.
13:08:26 <merijn> vanila: There are multiple models in which C is type safe
13:08:54 <merijn> vanila: Please refer to http://www.pl-enthusiast.net/2014/08/05/type-safety/
13:09:23 <merijn> vanila: Especially the comments
13:09:36 <merijn> vanila: The main blog post makes some erroneous assumptions (like you)
13:09:39 <vanila> merijn: I think you are confused. In C it's possible to e.g. coerce an object of one type into another causing a segfault
13:09:46 <kakos> merjin: Is interopability between Idris and Haskell easy?
13:10:03 <merijn> kakos: I believe it has a haskell FFI, not sure
13:10:06 <josephle> vanila: the argument that merijn is presenting is that you must first define "type safe" before you are allowed to make claims about type safety
13:10:09 <merijn> vanila: Please read Robert Harper's comment
13:10:19 <merijn> vanila: Else this discussion is pointless
13:10:29 <kakos> Ugh. Interoperability. But you got it. ;)
13:11:18 <merijn> kakos: Depending on your interests, there's a free book on using Coq to do formal proofs for software verification
13:11:48 <kakos> Actually, that does interest me quite a bit
13:11:52 <merijn> kakos: But that's less about dependently typed programming and more about proving, Idris is intended to be for actual programming
13:11:53 <vanila> The problem with non-terminating recursion and dependent types is that you can prove false things like Int = Bool and "unsafeCoerce" between them, this breaks type safety
13:11:55 <merijn> @where sf
13:11:55 <lambdabot> "Software Foundations" by Pierce,Casinghino,Greenberg,Sjöberg,Yorgey in 2011-06 at <http://www.cis.upenn.edu/~bcpierce/sf/> about "the mathematical theory of programming and programming languages", "It develops basic concepts of functional programming, logic, operational semantics, lambda-calculus, and static type systems, using the Coq proof
13:11:55 <lambdabot> assistant."
13:12:01 <brisbin> fizbin: yesod is a bit... featureful for what you're describe. i think snap is the standard smaller hotness, though you might be able to do what you want with just warp + aeson
13:12:10 <fizbin> Okay.
13:12:13 <merijn> kakos: See that link, it comes with tons of exercises in Coq too :)
13:12:18 <Algebr> ghci sometimes prints out something like: type foo Thing bar when I do :i on something. What's weird is that there is no RHS of that type. What does that mean?
13:12:21 <Tuplanolla> @where cpdt
13:12:21 <lambdabot> "Certified Programming with Dependent Types" by Adam Chlipala (aka Smerdyakov) (in progress) at <http://adam.chlipala.net/cpdt/>, "about practical engineering with the Coq proof assistant"
13:12:27 <kakos> merijn: Many thanks.
13:12:32 <Tuplanolla> That's another book of the same stuff.
13:12:50 <Tuplanolla> It's just a different approach.
13:13:11 <merijn> vanila: Last time, before I go do something productive, read the comments by Harper: There is no such thing as "type safety", type safety ONLY exists in correspondence to a model. You CANNOT make claims about type safety WITHOUT specifying a model first
13:13:18 <kakos> Thanks!
13:13:30 <merijn> vanila: You have refused to specify a model, therefore your claims about type safety are meaningless
13:13:33 <josephle> merijn: logic is hard :(
13:14:14 <vanila> sorry merijn I think all this stuff is covered in beginner textbooks like TAPL
13:14:32 <tippenein> so, I just cabal installed hakyll but when I try to ghc --make site.hs it can't find hakyll
13:14:40 <{AS}> merijn: Doesn't Bob Harper say that it is possible to make a type safe model for C, but the presented type system doesn't fulfil such model?
13:15:02 <monochrom> vanila: how do I prove Int=Bool by non-termination? but please don't use unsafeCoerce.
13:15:18 <jfischoff> tippenein: is ~/.cabal/bin on your PATH (or whereever cabal installs stuff to on your machine)
13:15:19 <vanila> monochrom, p : Int=Bool ; p = p
13:15:27 <oisin768> Is there a simple way to remove Haskell / Cabal / GHC off of OS X 10.9.2?
13:15:33 <merijn> {AS}: He's saying that the way people interpret C's types are generally inconsistent with the model they want to use for C
13:15:38 <monochrom> ok I see
13:15:39 <dolio> There's no problem with proving Int = Bool by non-termination; it just forces you to evaluate your proofs.
13:15:41 <Algebr> oisin768: how did you install it?
13:15:43 <prophile> oisin768: smash up your hard disk
13:15:48 <oisin768> Algebr: From source
13:15:50 <tippenein> jfischoff: yes
13:15:52 <oisin768> prophile: That's what it feels like
13:16:09 <oisin768> It's ghc 7.8.2 I think
13:16:11 <dolio> (I guess that is a problem, really, but....)
13:16:17 <jfischoff> tippenein: wait what exactly is the error?
13:16:22 <merijn> {AS}: So he's saying that people are mislead to believe C is type safe in a model for which it is not, even though there exist models in which it is
13:16:31 <{AS}> merijn: Ah, thanks
13:17:18 <tippenein> actually, ~/.cabal doesn't have a bin directory :(
13:17:31 <tippenein> so that's certainly it
13:18:51 <JordiGH> Last time I tested, ghc emitted object code without any CALL opcodes. Now, probably I'm saying something stupid, but I want to create a Haskell library to be called from C++, wouldn't this library need at least a few CALL and RET opcodes? I mean, it would need to export some symbols for functions, right?
13:18:52 <dolio> In fact, if 'p : Int=Bool; p = p' were a problem, it'd be a problem in GHC.
13:19:27 <dolio> Because you can write that.
13:19:28 <tippenein> jfischoff: just 'no module Hakyll found'
13:19:43 <jfischoff> oh that is a different problem
13:20:05 <jfischoff> I thought hakyll (lower case) was an executable
13:24:06 <merijn> JordiGH: Did you "foreign export" anything in that object code?
13:24:23 <merijn> JordiGH: foreign export will cause GHC to export symbols in the C calling convention of your system
13:24:27 <JordiGH> merijn: No. So is there some ghc option that emits those CALL and RET opcodes?
13:24:44 <merijn> JordiGH: You need to use the FFI (which foreign export is part of)
13:25:50 <JordiGH> Is this something that only C++ needs? If I want to use a Haskell library from another Haskell program, and I only have object code, how does that work?
13:27:47 <merijn> JordiGH: Native code languages all have their own calling conventions, each usually has a foreign function interface to translate from one to the other
13:28:02 <merijn> JordiGH: Usually all languages just only implement an FFI to C and use that to talk to others
13:28:07 <tippenein> How do I check where cabal is installing files to
13:28:11 <JordiGH> merijn: Uh-huh, does Haskell have a FFI with itself?
13:28:24 <merijn> JordiGH: It doesn't need to, haskell is not "foreign" :)
13:28:24 <JordiGH> How do you link to object code that was emitted by Haskell?
13:29:20 <merijn> JordiGH: You need to tell GHC to create code that C can understand (the same way you need to use "namespace "C"" to interoperate with C from C++), which is done via the foreign function interface
13:30:03 <sm> tippenein: you probably cabal install'ed hakyll into a sandbox, which ghc doesn't see by default
13:30:55 <tippenein> I actually didn't use a sandbox for that reason
13:30:55 <Fuuzetsu> is it accurate to say that [a] is the free monoid over ‘a’ with [] as id and (:) as (‌∙)?
13:30:57 <Peaker> merijn: extern "C", not namespace
13:31:30 <Peaker> Fuuzetsu: (:) doesn't work out, the types don't match. (++) does
13:31:42 <merijn> Peaker: Whatever, I don't do C++ that much :p
13:31:43 <Fuuzetsu> right
13:32:49 * Fuuzetsu will understand free-whatever in many more chapters of this book
13:32:52 <Fuuzetsu> free-monads here I come
13:32:53 <JordiGH> merijn: But symbols in shared libraries are not a peculiarity of C or Fortran or C++... By the time it's a library, it's just object code. How does ghc know how to link to a library emitted by ghc that doesn't have symbols?
13:33:16 <JordiGH> (I mean, C++ does name-mangling so you can see some C++ness in symbols, but that's besides the point)
13:33:16 <sm> tippenein: ok, does ghc-pkg list hakyll show an installed  and non-broken hakyll package ?
13:33:40 <Peaker> Fuuzetsu: I see "Free X" as a "recorder" of all the operations you do, that "forgets" all that it needs to make the laws work out
13:34:24 <merijn> JordiGH: It does have symbols
13:34:27 <JordiGH> (And I know ghc isn't a linker, but I presume ghc does drive ld?)
13:34:33 <merijn> JordiGH: Just not symbols C knows how to call
13:34:54 <JordiGH> Why do you insist talking about C? C is besides the point, isn't it?
13:35:08 <merijn> JordiGH: Well, yes and no
13:35:11 <Fuuzetsu> Peaker: right, that's more or less the idea I have now but I hope to get a more precise understanding
13:35:17 <JordiGH> It's not like the calling conventions are about C. It's just pure ASM by the time we talk about "calling conventions".
13:35:23 <merijn> JordiGH: Libraries just have symbols, but no information on how to call it
13:35:39 <merijn> JordiGH: So how do you expect non-haskell code to know how to call haskell symbols?
13:35:58 <merijn> JordiGH: You need to somehow "know"
13:36:07 <JordiGH> PUSH a few things on the stack and the CALL the function. I suppose the order in which you PUSH a few things is what we don't know about.
13:36:20 <tippenein> /usr/local/Cellar/ghc/7.6.3/lib/ghc-7.6.3/package.conf.d
13:36:21 <merijn> JordiGH: Except that haskell doesn't use CALL or RETURN
13:36:33 <merijn> JordiGH: Functions in haskell binary never return
13:36:45 <merijn> JordiGH: They're compiled CPS so they just use jump
13:37:01 <merijn> JordiGH: They don't use a stack either, at least not a function call stack like C
13:37:05 <JordiGH> Right, that's where my question started. Is that what that FFI function for ghc does, emit CALL and RET opcodes?
13:37:09 <tippenein> sm: there are two entries for ghc-pkg list hakyll, but they're conf.d files
13:37:34 <merijn> JordiGH: It creates symbols that behave according to the C calling convention, so any other languages can call them as if they were C functions
13:37:46 <JordiGH> But you can uh, "call" the function without CALL opcodes, and ghc knows how to link to such symbols?
13:38:12 <JordiGH> merijn: Do you know the details of creating symbols this way, or where I can read about it, and what ghc does differently?
13:40:20 <merijn> JordiGH: You can create arbitrary symbols, hell you can embed ascii or bmp or jpg into a binary as a symbol
13:40:33 <merijn> I dunno about any good texts on linking and code generation, though
13:40:52 <JordiGH> Okay, I'll search myself, thanks.
13:41:38 <JordiGH> You were helpful, can I give you a tiny bitcoin tip?
13:42:04 <levi> There's a book called "A Short History of Assemblers and Loaders" that might be relevant.
13:42:39 <prophile> where are my crackers
13:42:58 <levi> http://www.davidsalomon.name/assem.advertis/AssemAd.html
13:43:16 * merijn doesn't do bitcoins
13:43:40 <JordiGH> Oh well, thought I'd ask. I hope some day they become more widespread.
13:43:46 <JordiGH> Thanks, though.
13:43:48 <zomg> nobody ever offers to pay for something on irc
13:43:55 <zomg> you oughta take it, maybe it's a lucky sign
13:43:56 <zomg> :D
13:44:03 <Fuuzetsu> honeypot
13:44:13 <JordiGH> The only way I've acquired bitcoins is by getting paid on IRC.
13:44:26 <JordiGH> I've spent them on a bunch of useful things.
13:44:39 <levi> There's also this book "Linkers and Loaders": http://www.iecc.com/linker/
13:44:40 <zomg> I have 100k dogecoins. I have no idea what to do with them
13:44:59 <Fuuzetsu> free up your disk space by deleting your wallet, probably worth more than the coins
13:45:08 <zomg> lol, true
13:45:10 <JordiGH> lol
13:45:46 <Fuuzetsu> (I think that's like 10 euro worth nowadays)
13:46:03 <JordiGH> Yeah, about that much.
13:46:48 <levi> Linking/Loading is a bit of a black art in the world of software. Not many people write linkers.
13:47:07 <zomg> Yep, I mined them as they were fairly easy. Won't hurt to have 'em in case the unlikely price spike =)
13:47:17 <zomg> Didn't mine bitcoins and look what happened
13:48:32 <Fuuzetsu> Please don't reopen BitCoin scars
13:48:43 <merijn> I don't even know how I learned most of this stuff...
13:48:51 <Fuuzetsu> merijn: too much IRC
13:49:00 <merijn> Fuuzetsu: I think I learned a lot a uni
13:49:10 <Fuuzetsu> not enough IRC then
13:49:19 <merijn> Well, when I was like 16 I spend a bunch of time on these "hacking challenge" sites, I learned a ton there
13:49:43 <Fuuzetsu> are you a mastermind ‘hacker’ today?
13:49:47 <merijn> Like "here's a binary, reverse engineer the password verification system it uses and submit a valid password with the hash FOO"
13:50:00 <merijn> Fuuzetsu: No, back when those types of sites were still hardcore :)
13:50:11 <merijn> Learning to reverse engineer a binary is a valuable skill!
13:50:20 <merijn> More people should learn that stuff
13:50:29 <merijn> Do something funky, write self modifying assembler!
13:51:34 <merijn> Most of this stuff isn't as hard as it appears, it's just not very well documented in obvious places :)
13:51:34 <levi> Reading/writing linker scripts is an essential skill for embedded systems programming.
13:52:43 <Fuuzetsu> embedded systems programming is #2 on my list of things I hope I never have to actually do
13:52:45 <Fuuzetsu> #1 is web
13:53:04 <levi> Embedded systems is way less terrible than web.
13:53:04 <Clarice> lol
13:53:08 <Clarice> I agree with levi
13:53:11 <Clarice> assembly is fun!
13:53:21 <Clarice> Also, some of the wilder projects these days are using FPGA
13:53:34 <Clarice> if you get to use one of those you're having twice the fun
13:53:56 <Fuuzetsu> for ten times the money
13:54:01 <Clarice> :)
13:54:20 <levi> Plus you can use scopes and logic analyzers and stuff.
13:55:10 <Clarice> Anyway, if you exclude web-related programming (I include distributed computing in that field) and embedded programming, what exactly is left that's interesting? Enterprise applications? Databases? Payroll systems? Oooooh, what fun.
13:55:49 <levi> Games? Graphics apps?
13:55:49 <bvad> Clarice: "Enterprise applications" is a pretty broad theme :P
13:55:55 <systemfault> Any complex domain is fun (IMHO)
13:56:02 <Clarice> bvad: But they're all the same variety of garbage. :)
13:56:16 <bvad> Clarice: Isn't all software? ;)
13:56:25 <Clarice> True.
13:56:35 <merijn> Clarice: Why is distributed computing "web-related"?
13:57:08 <monochrom> Clarice, machine learning programming and genome crunching programming should be interesting
13:58:01 <monochrom> also cosmology simulations.
13:58:01 <Clarice> merijn: Usually I associate distributed computing with giant PaaS stuff
13:58:29 <levi> There are plenty of non-PaaS uses of distributed systems, though.
13:58:36 <merijn> Also HPC
13:58:40 <Clarice> Absolututely, so I was hasty
13:58:45 <levi> Sensor networks!
13:59:06 <Clarice> I should have been an optometrist, or a rock musician or something. I think I don't like computers.
13:59:08 <merijn> For me distributed computing also includes the "100 infiniband nodes with huge amounts of memory" stuff :p
13:59:25 <levi> HPC - home of today's Fortran programmers.
13:59:29 <bvad> Clarice: Not liking computers is what makes me want to fix them! :)
13:59:45 <monochrom> the most interesting computing happens in science that nobody knows because news reporters only report Wall Street happenings
13:59:49 <Clarice> bvad: But it's not like you dislike computers on a fundamental level
14:00:09 <bvad> Clarice: Well, no. It's more like I dislike how they're used
14:00:34 <Clarice> I'm a little bit of a luddite, too, actually.
14:00:37 <merijn> Clarice: The more I understand and like computers, the more miserable I become working with them :)
14:00:45 <Clarice> merijn: Where do you work?
14:00:46 <bvad> merijn: Don't we all!
14:00:57 <dolio> monochrom: What do you mean? The most interesting computing happens on Wall Street. That's why so many smart people work there. :)
14:01:02 <dolio> Also Twitter.
14:01:09 <merijn> Clarice: Normally as a phd at the University of Amsterdam, but currently at Oracle Labs
14:01:21 <Clarice> merijn: What do you work on at the latter?
14:01:25 <bvad> merijn: Oracle?! Oh my
14:01:28 <monochrom> you can follow Dijkstra's route. Write and prove-correct programs that you never even enter into computers. And don't check email. :)
14:01:34 <Fuuzetsu> hide your children
14:01:46 <merijn> Clarice: "graphs! big data! webscale!"
14:01:54 <merijn> But mostly graphs :)
14:02:05 <cite-reader> Graphs of big data *at* webscale! (Am I close?)
14:02:16 <bvad> cite-reader: in nodejs!
14:02:17 <merijn> As we've concluded, most customers who claim to have "big data" have "medium data", at best
14:02:26 <levi> What I like about embedded systems programming is that it's generally removed from the software fad chasing mindset, and the cost of hardware changes tends to keep feature scope a bit more static.
14:02:33 <Clarice> monochrom: I was reading Dijkstra's recommendation for an introductory computer science course and he insisted that students prove their programs correct before they use them, by hand, and never run them on a computer! Blasphemous.
14:02:51 <Clarice> merijn: Scaling's always an interesting problem, so that's very cool :)
14:02:55 <monochrom> I thought you liked his luddite way.
14:03:00 <eriksensei> merijn: what sort of things are you researching at the UvA?
14:03:27 <merijn> I think the biggest thing we have at the moment is a 300GB graph, which practically almost fits in memory of a single machine, so this distributed thing is silly :)
14:03:27 <monochrom> well, of course, he was not being luddite, he was being a learn-to-be-independent boot camp.
14:03:29 <dolio> Proving them correct on a computer would be better. But I guess they didn't really have that back then.
14:03:38 <merijn> eriksensei: Graphs, fine-grained parallelism and GPUs
14:04:12 <Fuuzetsu> is there something one can't lump under ‘graphs’?
14:04:23 <Clarice> monochrom: I have a philosophy related to computer science, but happen to shun a lot of technology, that's all.
14:04:44 <bvad> merijn: That sounds very interesting, have you published any papers?
14:04:50 <eriksensei> merijn: ah, cool, I know a guy who did GPU stuff there too
14:05:19 * hackagebot cabal-debian 4.17.3 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.17.3 (DavidFox)
14:05:51 <merijn> bvad: Yes, but not really on what I work on :p
14:06:01 <merijn> And I wouldn't recommend reading them :)
14:06:03 <bvad> Oh :)
14:06:38 <bvad> I'm starting my 2 year master's programme this monday, and I've already picked out courses in graphs and data science
14:06:48 <bvad> So I thought it would be interesting seeing what you were working on!
14:07:24 <merijn> data science is more "what can we do with graphs", I'm doing "how do we do that" :)
14:07:42 <seyvu> I'm getting a weird error from cabal. I have "base == 4.7.0.1" in my build-depends, and when I try to compile I get "rejecting base-4.6.0.1/installed-8aa... (conflict: todo => base == 4.7.0.1), rejecting: base-4.7.0.1, 4.7.0.0 etc etc... Now I understand the first part, but why is it rejecting 4.7.0.1., it's the exact version that I'm asking.
14:07:45 <monochrom> Fuuzetsu: a hash table isn't lumped under graphs. or rather, you could force it, and gain nothing.
14:07:52 <bvad> merijn: Well I'm not really sure what the courses consists of, so I wouldn't know! :)
14:08:07 <monochrom> a binary search tree can still be usefully lumped under graphs, unfortunately.
14:08:19 <monochrom> perhaps this is good cause to prefer hash tables :)
14:08:38 <merijn> seyvu: Which version of GHC do you have?
14:09:32 <merijn> seyvu: Base is tied into GHC and cannot be upgraded, if your GHC is too old you're out of luck and need to upgrade it
14:09:33 <seyvu> 7.6.3, one of the 7.8.x is installed (it's just not the default).
14:09:46 <seyvu> Ohh....
14:09:50 <merijn> seyvu: Right, 4.7 requires 7.8.x :)
14:09:54 <seyvu> I'll try with the newer ghc
14:11:44 <dfeuer_> GRRR $ GRRR
14:13:14 <Clint> slang or bang
14:13:19 <Clint> er
14:13:33 <benzrf> @let data Growl = GRRR Growl
14:13:35 <lambdabot>  Defined.
14:13:37 <benzrf> oh wait
14:13:42 <benzrf> @undef
14:13:42 <lambdabot> Undefined.
14:14:08 <benzrf> hmmmmm...
14:14:24 <benzrf> i am pretty sure that `GRRR $ GRRR' cannot be a well-typed expression in haskell
14:14:53 <benzrf> unles...
14:14:57 <vanila> data Growl = GRRR (Growl -> Growl)
14:15:03 <vanila> oops
14:15:04 <benzrf> vanila: doesnt work
14:15:10 <vanila> data Growl = GRRR ((Growl -> Growl) -> Growl) stil wrong..
14:15:14 <benzrf> @let data Growl = forall a. GRRR a
14:15:15 <lambdabot>  Defined.
14:15:20 <benzrf> :t GRRR $ GRRR
14:15:21 <lambdabot> Growl
14:15:25 <benzrf> still, that's not vanilla haskell
14:15:43 <benzrf> :t Just (Just)
14:15:44 <lambdabot> Maybe (a -> Maybe a)
14:15:56 <benzrf> OH OFC
14:15:57 <benzrf> @undef
14:15:57 <lambdabot> Undefined.
14:16:03 <benzrf> @let data Growl a = GRRR a
14:16:05 <lambdabot>  Defined.
14:16:07 <benzrf> :t GRRR $ GRRR
14:16:09 <lambdabot> Growl (a -> Growl a)
14:16:15 <benzrf> my mind was bein insufficiently polymorphic!
14:16:20 <benzrf> :t fix GRRR
14:16:21 <lambdabot>     Occurs check: cannot construct the infinite type: a ~ Growl a
14:16:21 <lambdabot>     Expected type: a -> a
14:16:21 <lambdabot>       Actual type: a -> Growl a
14:20:21 * hackagebot zeromq4-haskell 0.6.1 - Bindings to ZeroMQ 4.x  http://hackage.haskell.org/package/zeromq4-haskell-0.6.1 (ToralfWittner)
14:24:20 <seyvu> merijn: It works, thanks!
14:45:24 * hackagebot debian 3.83.4 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.83.4 (DavidFox)
14:59:05 <linman32> hello, i'm getting an error: "...parse error on input `<-'"
14:59:06 <linman32> http://lpaste.net/110216
14:59:11 <linman32> does anyone know what is wrong?
14:59:39 <Cale> linman32: Is there a 'do'?
15:00:06 <linman32> yes, towards the top in the source file
15:00:29 <Cale> linman32: Can you paste the entire source file?
15:00:55 <linman32> oh, wait a minute.. is this comment not allowed? ----****----
15:01:04 <Cale> That's not a comment
15:01:11 <linman32> ?
15:01:15 <Cale> It's an infix operator symbol
15:01:37 <linman32> but comments start with this -- right?
15:01:46 <Cale> Comments start with a number of hyphens greater or equal to 2, followed by a non-symbol character
15:01:56 <Cale> --> is a valid infix operator symbol
15:02:20 <linman32> oh, ok. got it.thanks
15:04:24 <k00mi> what irc libraries do people use? I've been using simpleirc, but had problems with disconnects and uncaught exceptions, which made me look at the code, which made me not want to use that anymore
15:05:42 <k00mi> the only other one I can find is ircbot, but I have to react to events other than messages from the server, which seems to be impossible with that library
15:05:54 <zomg> I rolled my own because I wanted to reinvent the wheel
15:06:00 <zomg> It's probably not very good tho
15:06:01 <zomg> :D
15:06:45 <k00mi> I could fix simpleirc, but that would probably require approximately as much effort as writing my own
15:08:25 <josephle> I wonder if you can get pieces from lambdabot?
15:09:58 <k00mi> hm, I really really don't want to roll my own
15:12:38 <haasn> I'm excited for http://hub.darcs.net/ertes/fastirc
15:12:43 <haasn> If that's the one I'm remembering correctly
15:14:58 <k00mi> last hackage release is from 2010
15:25:37 <roboguy_> lately I've been getting a lot of cabal errors about transformers that look like this "... (reinstall) changes: transformers-0.4.1.0 -> 0.3.0.0". Do any of you have an idea of what might be wrong?
15:27:23 <dcoutts_> roboguy_: in what sense is it an error?
15:28:03 <josephle> well, cabal does tell you reinstalls are scary. It might be taken as an error?
15:28:46 <roboguy_> dcoutts_: here's the full context of this one: http://lpaste.net/110218
15:28:58 <Peaker> how can I know if an operation isn't interruptible under mask?
15:29:02 <Peaker> e.g: atomicModifyIORef?
15:29:08 <roboguy_> josephle: yeah, it doesn't let me install without --force-reinstalls and I don't want to do that I think
15:29:19 <k00mi> haasn: I do like the idea of using FRP though
15:29:58 <dcoutts_> roboguy_: the solver is sort-of interactive, you can ask "would it work like this" and it'll either say "yes, here's the plan", or "no that doesn't work because..."
15:30:34 <dcoutts_> roboguy_: so in this case you want to ask, "would it work if we kept the installed instance of QuickCheck"
15:30:56 <dcoutts_> roboguy_: which you do by saying --constraint='QuickCheck installed'
15:31:10 <dcoutts_> roboguy_: oh, and --dry-run, you want to see what it would do of course
15:31:57 <roboguy_> dcoutts_: huh, I never knew that. Is there any documentation for those features?
15:32:01 <dcoutts_> --help
15:32:37 <roboguy_> --help covers that?
15:32:41 <dcoutts_> roboguy_: or alternatively you might try asking it to pick transformers-0.4.1.0, by saying --constraint="transformers == 0.4.1.0"
15:32:48 <roboguy_> oh, I see
15:32:54 <dcoutts_> roboguy_: well, it lists the --constraint and --preference flags
15:35:02 <roboguy_> dcoutts_: hmm, ok this is what it's giving now http://lpaste.net/110220
15:35:55 <roboguy_> looks like haskeline uses transformers 0.3.0.0
15:36:07 <dcoutts_> indeed
15:36:21 <Algebr> Was looking at vty and vty-ui, there is barely any C code in there. I thought that such libraries had to use C to touch such low level stuff, terminals and whatnot
15:36:31 <dcoutts_> roboguy_: what's unclear from that is why we cannot reinstall haskeline from source
15:36:56 <dcoutts_> roboguy_: but if you're interested, you can ask!  --constraint='haskeline source'
15:37:11 <geekosaur> Algebr: the parts that need to be in C are part of ghc already. the rest doesn't need to be in any particular language
15:37:56 <geekosaur> well, part of the "unix" package
15:38:34 <roboguy_> dcoutts_: it looks like it's more or less the same as the first error, but it also has the line "haskeline-0.7.1.3 (new version)"
15:38:57 <benzrf> :t (<*>).(<*>)
15:38:58 <lambdabot> (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
15:39:28 <benzrf> @let (.:) = (.) . (.)
15:39:30 <lambdabot>  Defined.
15:39:31 <benzrf> :t (<*>).:(<*>)
15:39:32 <lambdabot> Applicative f => f (a1 -> a -> b) -> f a1 -> f a -> f b
15:39:36 <benzrf> huh
15:39:52 <dcoutts_> roboguy_: you'd try the two together, haskeline source, and transformers >= 0.4
15:40:41 <dcoutts_> roboguy_: it's actually still unclear to me, since haskeline-0.7.1.3 will work with transformers-0.4.*, where as haskeline-0.7.1.2 needs transformers-0.3.*
15:40:43 <phaazon> dammit
15:40:44 <phaazon> Loading package photon-core-0.1.0.0 ... <command line>: can't load .so/.DLL for: /home/phaazon/dev/photon-opengl/.cabal-sandbox/lib/x86_64-linux-ghc-7.8.3/photon-core-0.1.0.0/libHSphoton-core-0.1.0.0-ghc7.8.3.so (/home/phaazon/dev/photon-opengl/.cabal-sandbox/lib/x86_64-linux-ghc-7.8.3/photon-core-0.1.0.0/libHSphoton-core-0.1.0.0-ghc7.8.3.so: undefined symbol: photonzmcorezm0zi1zi0zi0_PhotonziCoreziParsing_zdwunsignedParser_info)
15:41:13 <phaazon> I have that huge and nasty error when using TH and using as dependency a lib from me
15:41:16 <phaazon> any idea?
15:41:28 <dcoutts_> phaazon: most likely the .cabal file for photon-core does not list all of its modules
15:41:50 <roboguy_> dcoutts_: ok, I think it works if I also add "--allow-newer=transformers" to those other two arguments. Thanks!
15:41:53 <phaazon> ah
15:41:54 <phaazon> ok, thank you
15:41:56 <roboguy_> I never knew that about cabal
15:42:26 <dcoutts_> roboguy_: I don't see why it's necessary to use allow-newer here, haskeline doesn't have a restrictive upper bound on it
15:42:48 <dcoutts_> roboguy_: but yes, anyway, glad you've learned something
15:42:53 <Peaker> Is it safe to use "restore" from "mask" inside a forkIO'd thread that was created masked?
15:42:55 <roboguy_> dcoutts_: it didn't work because agda still needed transformers==0.3.0.0
15:43:03 <dcoutts_> roboguy_: ahh ok
15:43:04 <Peaker> or should one use forkIOUnmasked instead?
15:43:38 <dcoutts_> Peaker: good Q, do the docs say anything? I suspect it's dodgy. I'd use forkIOUnmasked
15:43:41 <trap_exit> anyone have a good example of using the list monad to solve SAT ?
15:43:51 <trap_exit> i.e. the list stores all partial assignments
15:43:51 <Peaker> dcoutts_: ok, thanks
15:44:01 <dcoutts_> Peaker: oh, wait I thought you mean cross-thread
15:44:09 <dcoutts_> but perhaps that's not what you meant
15:44:20 <Algebr> geekosaur: Why would ghc have C code to manipulate the terminal?
15:44:43 <geekosaur> Algebr, because the termios API is part of POSIX?
15:45:00 <geekosaur> and that's the only part that needs to be in C, really. the rest is not magic, it's just sending specific strings
15:45:11 <phaazon> dcoutts_: it was that, thank you :)
15:45:58 <Peaker> dcoutts_: I have something like:  mask $ \restore -> ... async $ restore $ ...        and I can replace it with:  mask $ \restore -> ... asyncWithUnmask $ \unmask -> unmask $ ...
15:46:33 <dcoutts_> Peaker: ok yeah, cross-thread. That does seem suspect. I'd use the dedicated create-with-mask functions
15:46:55 <Peaker> dcoutts_: it seems to work fine, but does seem sketchy, yeah
15:47:54 <geekosaur> and ever since ANSI X3.64, there has been no need for the complex terminal management provided by terminfo
15:50:47 <Algebr> geekosaur: 3.64, is that some kind of posix standard? what is terminfo, a sys call?
15:51:05 <Peaker> not having tryThrowTo or an async throwTo is a big problem, IMO :(
15:51:42 <Algebr> nvm, reading the wiki
15:51:47 <geekosaur> X3.64 is the ANSI standard for terminal escape/control sequences. terminfo is a terminal description database from back before there was a standard for terminals; it shipped with a database of several thousand different terminals
15:52:24 <Algebr> geekosaur: but now none of us "really" have terminals, right?
15:53:16 <geekosaur> terminal emulators still behave like terminals, using specific escape sequences to do things. it's just that there is now a standard that is widely used for those sequences
15:54:14 <geekosaur> some terminal emulators actually predate the ANSI standard, but the standard was based on the same physical terminal that xterm was based on (DEC VT100 with extensions)
15:55:11 <phaazon> ok, I have a Vector (a,b) and an index; I’d like to apply a function on a at a given index. Why is the following wrong?: ix myIndex . _1 %~ fOnA
15:55:14 <geekosaur> Windows has a terminal which requires C programming to control. POSIX terminals use escape sequences. there are arguments for and against both ways
15:59:06 <koala_man> you still need C programming for some things like disabling echo
16:00:01 <shachaf> phaazon: I don't know, you tell us.
16:00:31 <phaazon> shachaf: well
16:00:34 <phaazon> to me it’s correct
16:00:39 * hackagebot apiary 0.16.0 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.16.0 (HirotomoMoriwaki)
16:00:41 <shachaf> And to GHC?
16:00:42 * hackagebot apiary-logger 0.16.0 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-0.16.0 (HirotomoMoriwaki)
16:00:44 * hackagebot apiary-persistent 0.16.0 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.16.0 (HirotomoMoriwaki)
16:00:45 <phaazon> in a simple ghci session it’s correct
16:00:46 * hackagebot apiary-websockets 0.16.0 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.16.0 (HirotomoMoriwaki)
16:00:47 * hackagebot apiary-cookie 0.16.0 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.16.0 (HirotomoMoriwaki)
16:00:52 <phaazon> :t to
16:00:54 <lambdabot> (Contravariant f, Conjoined p, Functor f) => (s -> a) -> p a (f a) -> p s (f s)
16:00:57 <geekosaur> koala_man, that's sthe stuff in the POSIX bindings
16:01:05 <phaazon> > V.fromList [(4,"s"),(7,"lol")] & ix 0 . _1 %~ (*2)
16:01:06 <geekosaur> http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/unix-2.6.0.1/System-Posix-Terminal.html
16:01:07 <lambdabot>  Not in scope: ‘V.fromList’
16:01:08 <lambdabot>  Perhaps you meant one of these:
16:01:08 <lambdabot>    ‘M.fromList’ (imported from Data.Map),
16:01:08 <lambdabot>    ‘S.fromList’ (imported from Data.Set),
16:01:08 <lambdabot>    ‘IM.fromList’ (imported from Data.IntMap)
16:01:16 <phaazon> > [(4,"s"),(7,"lol")] & ix 0 . _1 %~ (*2)
16:01:19 <lambdabot>  [(8,"s"),(7,"lol")]
16:01:24 <phaazon> so yeah, it’s correct
16:01:32 <phaazon> but if I replace the Int by something else
16:01:34 <phaazon> I get a weird error
16:01:41 <phaazon>     No instance for (Field1
16:01:44 <shachaf> Which Int?
16:01:44 <phaazon> and so on
16:01:50 <phaazon> [(Int,String)]
16:01:53 <phaazon> that one
16:02:01 <shachaf> "and so on" isn't something GHC usually prints out.
16:02:07 <phaazon> shachaf: yeah
16:02:09 <phaazon> well:
16:02:16 <shachaf> I'd say that you should post your full code and full error message on hpaste.org.
16:02:18 <phaazon> http://lpaste.net/110224
16:03:09 <phaazon> oh wait
16:03:12 <phaazon> yeah
16:03:13 <phaazon> nvm
16:03:33 <shachaf> That doesn't have your full code, but it already has a big hint at what's wrong.
16:03:33 <phaazon> the issue was not related to that, it was the function passed which was of the wrong type
16:03:44 <shachaf> People here aren't mind readers. :-(
16:03:55 <phaazon> I found that hint pretty poor
16:04:36 <shachaf> OK. Well, you never posted actual code.
16:04:50 <phaazon> shachaf: I don’t blame anyone but me here
16:05:02 <phaazon> just, the error from lens are pretty cryptic to me
16:05:06 <phaazon> errors*
16:05:44 <shachaf> It is not a matter of blame but of learning to ask questions such that people can answer them.
16:05:50 * hackagebot context-stack 0.1.0.0 - An abstraction of a stack and stack-based monadic context.  http://hackage.haskell.org/package/context-stack-0.1.0.0 (thinkpad20)
16:05:52 * hackagebot apiary-clientsession 0.16.0 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.16.0 (HirotomoMoriwaki)
16:05:54 * hackagebot apiary-authenticate 0.16.0 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.16.0 (HirotomoMoriwaki)
16:05:56 * hackagebot apiary-eventsource 0.16.0 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-0.16.0 (HirotomoMoriwaki)
16:05:58 * hackagebot apiary-purescript 0.16.0 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-0.16.0 (HirotomoMoriwaki)
16:06:40 <phaazon> shachaf: you’re totally right, sorry for that
16:06:43 <phaazon> my code is just very dense
16:06:59 <phaazon> thank you anyway; sorry for bothering
16:20:15 <nateb> I read that ghc includes a full C parser, but it was a bit ambiguous what that meant.  Is that part of the compiler, or a library, or...?  I know that might not be a lot to go off of, but does anyone know?
16:20:28 <spopejoy> greetings. can't figure out read[s]Prec, want to simply implement a mnemonic for an enum, let's say data Foo = Alpha|Beta|Charlie and I want read "A" -> Alpha, "B" -> Beta, "C" -> Charlie
16:20:42 * hackagebot context-stack 0.1.0.1 - An abstraction of a stack and stack-based monadic context.  http://hackage.haskell.org/package/context-stack-0.1.0.1 (thinkpad20)
16:24:15 <merijn> nateb: Where did you read that?
16:24:32 <geekosaur> "ghc" doesn't include one, but there's at least one on hackage
16:24:44 <nateb> merijn: gimmie a second, I closed it...
16:27:36 <spopejoy> nm, Debug.Trace on my read instance reveals all
16:28:03 <infandum> Okay I'm back with questions about segfault. Is it possible to get segfaults in totally valid code due to issues with compilations or the binary? If, for instance, the compilation was bugged somehow, interrupted somehow, git branched somehow, anything like that which would result in a segfault during runtime of the binary?
16:29:52 <nateb> merijn: Yeah, so I couldn't find it :^(  I read it a few hours ago, and have since been repeatedly frustrated in my attempts to do something I thought was relatively simple, and recalling what I had read, decided to pop on this channel and ask.
16:30:10 <merijn> nateb: It sounds like an unlikely claim
16:30:28 <merijn> nateb: I wouldn't know where this C parser is hiding
16:32:06 <nateb> merijn: It seemed outrageous to me as well.  I wish I could find where I read it!  How embarassing.
16:36:02 <nateb> merijn: Aha!  I kept digging and found it: http://www.researchgate.net/post/Is_there_any_tool_parser_to_extract_information_from_C_code
16:36:34 <oisin716> My cabal project builds fine, but whenever I use `cabal run` it tells me to run `cabal configure` because my Cabal versions differ (20 v. 18). But `cabal configure` doesn't seem to do anything. I've tried reinstalling ghc and cabal to no avail. What's going wrong?
16:36:35 <nateb> My memory wasn't reliable about what was said, and it's sufficiently vague that it seems falsy, but that's what I'm here!
16:36:38 <merijn> nateb: I suspect that's referring to language-c
16:37:14 <oisin716> Nevermind, I'm an idiot.
16:37:53 <nateb> merijn: excellent!  That may be just what I was looking for.  I don't know why I couldn't find it otherwise.  Thanks!
16:41:28 <mvc`> hey, I've been trying to build copilot and am running into this cryptic error. Any ideas? http://pastebin.com/yC6zjJf1
16:45:51 <rodlogic> I am struggling with finally tagless encoding. Hoping someone could shed some light ... I want to have a pure class syntax and two intepretations: one pure and one in the IO monad. Is that possible?
16:46:48 <rodlogic> is unsafePerformIO the only option here?
16:47:28 <vanila> rodlogic, I imagine you can do it without, would have to look some code to help - using unsafePerformIO would be wrong for sure
16:47:30 <eriksensei1> I'm sketching out some ideas using type signatures f :: A -> B and so on, but is there a way to avoid having to write the accompanying binding as 'f = undefined' all the time?
16:47:48 <rodlogic> vanila: let me get some source up
16:48:05 <prophile> eriksensei1: http://www.haskell.org/haskellwiki/GHC/TypedHoles
16:53:02 * Peaker is now using uninterruptibleMask for all my cleanup handlers, let's see how that goes
16:53:03 <jchee_> is there a time library that supports div/mod over time so I could do something like: `fmap (\x -> div x 1 * month) getCurrentTime` and get `August 1 2014 00:00:00 ?
16:53:58 <eriksensei1> prophile: Thanks! I've been aware of TypedHoles, but now that you mention it, I suppose if I could get it to stop giving warnings, I'd be a happy camper.
16:57:49 <eriksensei1> prophile: ah, as it turns out, someone submitted a feature request to do just that, about a week ago. guess i'll have to be patient.:) https://ghc.haskell.org/trac/ghc/ticket/9497
16:58:55 <prophile> ah yes
17:05:14 <tlo> hi, this code works: http://lpaste.net/110227 but would an experienced haskeller write it like that? (does not feel "natural" to me, but maybe just because I'm, new with haskell)
17:08:43 <roboguy_> > let "string with\nnewlines\nand=key\nvalue=pairs" in map (fmap (drop 1) . break (== '=')) $ lines s
17:08:45 <lambdabot>  <hint>:1:51: parse error on input ‘in’
17:08:51 <roboguy_> > let s = "string with\nnewlines\nand=key\nvalue=pairs" in map (fmap (drop 1) . break (== '=')) $ lines s
17:08:53 <lambdabot>  [("string with",""),("newlines",""),("and","key"),("value","pairs")]
17:09:04 <kadoban> tlo: Not sure I can comment on the coding style all that much, but seems really fragile, depending on where you're getting your input from.
17:09:10 <roboguy_> > (it !! 2) !! 1
17:09:12 <lambdabot>  Not in scope: ‘it’
17:09:12 <lambdabot>  Perhaps you meant one of these:
17:09:12 <lambdabot>    ‘id’ (imported from Data.Function),
17:09:12 <lambdabot>    ‘C.id’ (imported from Control.Category),
17:09:12 <lambdabot>    ‘i’ (imported from Debug.SimpleReflect)
17:09:54 <roboguy_> > let { s = "string with\nnewlines\nand=key\nvalue=pairs"; a = map (fmap (drop 1) . break (== '=')) $ lines s } in snd (a !! 2)
17:09:55 <lambdabot>  "key"
17:11:03 <roboguy_> tlo: I think it would be better to use pairs like that. it's safer
17:11:55 <tlo> roboguy_: yes, that looks better. I'll try your example, thanks!
17:14:14 <mbj> can I ask attoparsec questions here?
17:14:29 <roboguy_> mbj: sure
17:21:56 <rodlogic> vanila: http://lpaste.net/110229
17:26:28 <vanila> rodlogic, I can't exactly understand what this is for
17:31:38 <vanila> rodlogic, could you explain the goal?
17:33:49 <rodlogic> vanila: there are two things at once here: I am create a DOM API using the finally tagless encoding (the Attribute class) and I am interpreting it in Haste using the ffi function to generate javascript and automatically pack/unpack args/return value.
17:35:13 <rodlogic> vanila: the Haste ffi function calls unpackify which is a method on an FFI class. However, there are only two implementations: for IO a and for a->b
17:35:44 <rodlogic> vanila: and the FFI class methods are not exported. So I am stuck with IO
17:36:20 <vanila> I see
17:36:47 <rodlogic> vanila: but I don't want to turn my nice syntax into an IO stack
17:37:32 <rodlogic> vanila: hence the 'pure' finally tagless encoding but an IO intepretation question
17:39:06 <vanila> I think that you can definitely do this withou the IO monda, rather than using any unsafe stuff
17:39:58 <vanila> there's an example of interpreting tagless syntax into IO here http://okmij.org/ftp/tagless-final/CB.hs
17:40:28 <vanila> I'm just having trouble grokking the BNF for your syntax and its interpretations and such so i cant help more without that
17:44:10 <rodlogic> vanila: I updated the link. It was missing the Element class.
17:45:15 <rodlogic> vanila: e.g element "div" [ attribute "id" "123" ] [ element "link" [ attribute "href" "http://...." ]
17:45:53 <vanila> oh i see
17:45:57 * hackagebot Win32-dhcp-server 0.2.1 - Win32 DHCP Server Management API  http://hackage.haskell.org/package/Win32-dhcp-server-0.2.1 (MichaelSteele)
17:47:23 <vanila> rodlogic, since I wasn't familiar with Haste I didn't quite understand instance Attribute AttrR
17:47:31 <rodlogic> vanila: now one representation is just Data.Tree. Another one is Haste, which requires IO.
17:47:45 <rodlogic> vanila: yes, this is my crap I am adding on top
17:48:02 <vanila> oh wait a sec
17:48:13 <vanila> this is your "ffi" function, or is it from haste?
17:48:22 <vanila> because i looked up haste and it also defines a function by that name
17:48:22 <rodlogic> vanila: from haste
17:48:25 <vanila> okay
17:48:54 <rodlogic> vanila: one tack is to contact valderman and discuss whether it makes sense to remove the IO context for some of these calls
17:49:10 <rodlogic> vanila: but the other question is still interesting
17:50:15 <lumo_e> sweet jesus
17:50:36 <lumo_e> someone please help me before I tear my eyes apart
17:50:38 <lumo_e> http://lpaste.net/112227323645788160
17:50:57 <lumo_e> Parse error in pattern: sieve'
17:51:06 <lumo_e> on the first line
17:51:17 <trap_exit> is it safe to say
17:51:27 <trap_exit> that data is better than functions
17:51:29 <trap_exit> because you can examine / manipulate data,
17:51:34 <trap_exit> whereas all you can do with functions is call them
17:52:03 <stalintrotsky> lumo, is there anything before that or is that the only thing in the file?
17:52:33 <lumo_e> there's something before but if I set sieve' blabla = [] the whole thing compiles
17:52:40 <lumo_e> so I guess the error is right there
17:52:48 <lumo_e> I'm pasting everything to be sure
17:52:59 <rodlogic> vanila: I see. The CB.hs link above give me a good direction. Thanks.
17:53:36 <lumo_e> stalintrotsky, http://lpaste.net/2475429075636715520
17:55:01 <vanila> rodlogic, yeah I' was still trying to get my head around this - feel free to have a go with the idea from that and ask more if you get stuck again
17:59:39 <stalintrotsky> I can't figure it out, and I have to go, sorry
17:59:44 <lumo_e> np
17:59:47 <lumo_e> thank you
17:59:55 <stalintrotsky> I'm not that great anyway, someone else will probably be better able to help
18:00:14 <stalintrotsky> hlint gives me an error on the otherwise line if that helps
18:00:35 <stalintrotsky> a parse error
18:01:51 <lumo_e> mmmh ok
18:09:23 <slack1256> I'm interested on yampa for gui programming. But I've read on the web that (A)FPR is better suited for games and engines than desktop applications.
18:09:37 <slack1256> Do somebody have the experience using it for desktop?
18:10:25 <roboguy_> hmm, anyone know why \ used to work as LocalLeader in vim (on OS X) but now it doesn't seem to do anything except ring the bell when I press it? I don't remember changing anything...
18:11:37 <ezrios1> roboguy_: #vim
18:11:45 <ezrios1> maybe remap your Leader key in ~/.vimrc as well
18:12:25 <ezrios1> hard to say why it started doing that all of a sudden though
18:13:03 <roboguy_> ezrios1: I'm not registered on freenode yet so I'm not sure if I can talk in that channel at the moment. my .vimrc doesn't seem to reassign any leader stuff
18:17:55 <slack1256> register in freenode, it takes like 3 min
18:18:03 <slack1256> or take it to #haskell-blah
18:19:49 <roboguy_> slack1256: alright, but I figured it wouldn't hurt too much here since there's not much going on right now and people talk about programming environments sometimes (and even totally unrelated CT stuff)
18:19:50 <yeboot> acpi
18:19:52 <yeboot> wrong window
18:22:48 <slack1256> roboguy_: even the CT stuff spoken usually has a application on term of a haskell library (think lens), but the need of a general channel for environment that is not directly related to haskell but with haskell people is what #haskell-blah is.
18:23:06 <roboguy_> slack1256: I don't see #haskell-blah actually
18:23:33 <slack1256> doing /join #haskell-blah doesn't work?
18:23:50 <roboguy_> oh, yeah. huh, it's not in my channel list
18:29:54 <zzo38> Is applicative LR parsing possible?
18:35:07 <zzo38> To do LR parsing it would seem to me that you would have to do something which is not a monad.
18:35:19 <zzo38> Is it correct?
18:39:39 <rodlogic> vanila: pheew ... "Could not deduce (m1 ~ IO) .. from the context (MonadIO m)"
18:52:27 <newbie228> hi all
18:53:18 <roboguy_> hi newbie228
18:53:46 <newbie228> sup with choo?
18:54:23 <slack1256> choo?
18:54:41 <newbie228> choo, its the formal version of 'you'
18:54:48 <MP2E_> pikachoo
18:54:54 <newbie228> are you not a native english speecher?
18:55:05 <slack1256> nope
18:55:10 <newbie228> Ah, me either
18:55:54 <slack1256> I am a native haskell speaker though
18:56:40 <newbie228> cool
18:56:50 <newbie228> i know 0 haskell
18:57:38 <zzo38> Then you must learn.
18:57:56 <vpm> newbie228: you may be interested by https://github.com/bitemyapp/learnhaskell then :-)
18:58:57 <newbie228> danka
18:59:38 <Axman6> choo is definitely not the formal version of you...
19:00:05 <slack1256> Are choo sure?
19:00:17 <MP2E_> haha
19:00:55 <Axman6> newbie228: do you have a question about Haskell?
19:01:52 <newbie228> well, more formal than y'all
19:02:10 <yeboot> > printStrLn "hello world"
19:02:11 <lambdabot>  Not in scope: ‘printStrLn’
19:02:12 <lambdabot>  Perhaps you meant one of these:
19:02:12 <lambdabot>    ‘putStrLn’ (imported from Prelude),
19:02:12 <lambdabot>    ‘BSC.putStrLn’ (imported from Data.ByteString.Char8),
19:02:12 <lambdabot>    ‘BSLC.putStrLn’ (imported from Data.ByteString.Lazy.Char8)
19:02:19 <slack1256> (it doesn't seem even english)
19:02:22 <yeboot> o putstrln is probably right
19:02:31 <slack1256> >putStrLn "hello"
19:02:37 <slack1256> > putStrLn "hello"
19:02:37 <yeboot> querying lambdabot works too, right
19:02:38 <lambdabot>  <IO ()>
19:02:40 <Axman6> :t putStrLn
19:02:41 <lambdabot> String -> IO ()
19:02:54 <marchelzo_> I am reading a tutorial and it says that Data.Map.lookup is defined to automatically work within any monad by simply calling the monad's fail function rather than returning a value in the Maybe monad. Is this true? It gives me a type error.
19:03:08 <shachaf> marchelzo_: It's not true.
19:03:28 <Axman6> where'd you read that?
19:03:31 <shachaf> It was true for a very old version of containers.
19:03:41 <marchelzo_> shachaf: It wouldn't even be possible to define it like that, would it?
19:03:42 <Axman6> ew
19:03:47 <shachaf> marchelzo_: It would.
19:03:48 <zzo38> Are you sure they are more formal than "y'all"? The singular form of "you" is "thou" and the plural form is "y'all".
19:03:52 <marchelzo_> I read it in this paper: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
19:04:07 <BMeph_> yeboot: Not only does it work, it is preferred. ;)
19:04:08 <Axman6> zzo38: or yous
19:04:08 <shachaf> It's not a particularly good generalization because fail isn't a particularly good function.
19:04:18 * Axman6 is Australian
19:04:47 <marchelzo_> What would the type signature of lookup be if it were defined like that
19:04:57 <c_wraith> :t M.lookup
19:04:58 <lambdabot> Ord k => k -> M.Map k a -> Maybe a
19:05:00 <zzo38> Axman6: OK, although I think "yous" is not a proper word (and maybe "y'all" is not a proper word either)
19:05:14 <Axman6> replacing Maybe with m
19:05:15 <c_wraith> marchelzo_: just like that, except m a in the return type
19:05:17 <shachaf> lookup :: (Monad m, Ord k) => k -> Map k a -> m a
19:05:25 <Axman6> zzo38: neither are :P
19:05:50 <c_wraith> marchelzo_: but it turned out to be a wrong choice, so it was undone.  Be *very* wary of any resource which claims it's good design.
19:06:19 <marchelzo_> c_wraith: thanks for the heads up.
19:07:09 <zzo38> You can also use the Alternative class, is another way to signal success/failure, in a applicative even if it is not a monad
19:07:53 <slack1256> with the AMP now that line will be blurrer
19:08:18 <shachaf> Not really. There are plenty of Applicative instances that aren't Monad instances.
19:08:25 * shachaf wishes that acronym would just go away.
19:08:44 <slack1256> I meant the other way around
19:08:45 <zzo38> I know there are a lot of applicative which are not a monad, such as a zip list
19:09:00 <slack1256> I interested if every MonadPlus will be an Alternative
19:09:08 <zzo38> slack1256: It ought to be.
19:09:11 <slack1256> specially since MonadPlus doesn't have a consensus on laws
19:09:50 <zzo38> slack1256: I consider the right zero law wrong, and the monoid law is the only proper law, same as Alternative. (The left zero law is implied by the monad laws.)
19:11:53 <Axman6> wooaahh, first Seblime Text 3 update since December!
19:15:47 <slack1256> any FPR implementation that works for desktop application?
19:15:53 <slack1256> ie not games?
19:16:29 <c_wraith> slack1256: reactive-banana has bindings to at least one windowing kit
19:17:09 <c_wraith> slack1256: ah, it has wxwindows bindings
19:19:15 <Algebr> any difference between directly running an exectuable in dist/ and doing cabal exec dist/..
19:19:17 <zzo38> Do you know answer of my question about the LR parsing?
19:19:51 <greymalkin> Algebr: sandbox?
19:19:58 <Algebr> yes, sandboxed
19:20:44 <slack1256> c_wraith: cool, it doesn't seem to be based on arrows which is different to the rest. Will give it a try!
19:20:59 <greymalkin> Then if it needs shared libraries (.so or .dll), it might be getting the wrong ones; otherwise, no, the executable should be the same to my knowledge.
19:21:32 <Guest40672> I have added a couple of extra commands to lambdabot for my own learning in Quotes.hs to get sayings from Heinlein and some others. How do I recomile and install over existing version to test it?
19:21:50 <shachaf> Messing with lambdabot is expert mode.
19:22:06 <Guest40672> I be apprentice, but wanting to learn
19:22:19 <roboguy_> zzo38: LR is context free right? I imagine it would have an Applicative instance but not Monad in that case
19:22:32 <zzo38> roboguy_: That is exactly my guess.
19:22:40 <zzo38> However, it didn't tell me how it is supposed to be done.
19:22:44 <shachaf> If you have an existing version, do whatever you did to get the existing version.
19:22:53 <roboguy_> if there was a Monad instance, you could make decisions based on context
19:23:24 <zzo38> Yes, I have said above, I think it has to be not a monad.
19:23:34 <c_wraith> LR parsers can only make handle a subset of context-free grammars, IIRC.  In that case, there might be issues making an Applicative instance that works fully correctly
19:23:35 <roboguy_> oh, you want to know how to implement the Applicative?
19:23:47 <zzo38> roboguy_: Yes.
19:24:17 <zzo38> c_wraith: I did think of that too, but it doesn't even necessarily have to be LR; it could be GLR or Earley or whatever, something related anyways
19:25:02 <c_wraith> zzo38: most of the existing parser combinator libs are based on LL(k) approaches
19:25:26 <zzo38> c_wraith: Yes, I know that! I have seen that
19:26:41 <roboguy_> zzo38: hmm what are you looking for?
19:27:01 <roboguy_> (what's the ultimate goal?)
19:27:25 <zzo38> For C programs, I have worked with Lemon which is a LALR(1) parser generator; unlike yacc, it is public domain and the tokenizer calls the parser instead of the other way around; I wanted to do something like that with Haskell too.
19:27:32 <zzo38> roboguy_: Mainly I am just curious
19:32:51 <slack1256> reactive-banana has the best logo I've seen
19:49:38 <Algebr_> pwd
19:49:38 <Algebr_> ls
19:49:48 <Algebr_> oops.
19:50:04 <marchelzo_> haha I do that all the time
19:50:22 <jollygood> hello. what date and time library should I use? I see there are at least two, if not more
19:50:24 <Algebr_> heh
19:50:33 <jollygood> I need to do some calculations involving dates
19:51:13 <zzo38> Do you need to calculate when is Easter?
19:51:45 <jollygood> no. I need to adjust timestamps in some log files (add/remove a couple of hours, and have the dates updated as well)
19:52:55 <jollygood> as well as sometimes change the date itself, month or day
19:53:24 <zzo38> Perhaps look at them and see what is most suitable for your work?
19:54:47 <jollygood> I would if I had the time.. I was hoping someone already did that for me :P
19:55:19 <zzo38> I haven't seen your project though.
19:56:20 <jollygood> is there not a preferable date library?  I see datetime, time, and few others on hackage
19:56:30 <sm> your options are time and thyme, and it sounds like the first is your best choice
19:56:48 <sm> there, boiled it down for you
19:57:35 <sm> expect a bit of a learning curve for the api
19:57:50 <jollygood> for a date api?
19:57:51 <zzo38> I would think what is preferable depends on your project, on your preference, on working with other libraries you may be using, etc
19:58:47 <zzo38> Is there any ephemeris library for Haskell? I know Swiss Ephemeris for C, but I don't know of any for Haskell.
19:58:57 <c_wraith> jollygood: yes, time's API actually makes sense, unlike every other time API.  So it requires some learning. :)
19:59:45 <c_wraith> jollygood: the single most important thing you can do when looking at the API for the time library is pay attention to instance lists.  They're where most of the relevant functions are hidden.
19:59:53 <jollygood> Thyme is a rewrite of the fine time library, with a particular focus on performance for applications that make heavy use of timestamps.
20:00:01 <jollygood> so I guess I should use that one?
20:00:13 <c_wraith> You could, but it's a little less friendly
20:00:26 <jollygood> 7YUAAKH2X: and datetime?
20:00:32 <jollygood> and datetime?
20:00:36 <c_wraith> And if you're not generating hundreds of timestamps per second, the speed increase isn't going to matter
20:00:51 <jollygood> yeah I am not
20:03:26 <sm> datetime is an easier facade for time, it might be a handy for you
20:04:05 <Axman6> it can take a while to figure out how everything fits together in the time API
20:04:08 <sm> if the license suits you
20:04:26 <jollygood> "easier facade for time"?
20:04:35 <jollygood> I don't care about the license, it is a personal project
20:05:30 <zzo38> Your things about date/time have reminded me that I was looking for Haskell ephemeris software.
20:06:53 <sm> the datetime package uses the time package, but aims to provide an easier & smaller API
20:07:48 <jollygood> okay
20:07:58 <sm> hasn't been updated in 3 years though. If it builds for you, go for it
20:08:19 <jollygood> I am not sure having so many choices is a good thing :)
20:08:53 <sm> just learn time then, you'll have to sooner or later
20:11:33 <jollygood> time is actually the only one that ships in haskell platform, and there's probably a reason for that. so yeah, time it is
20:13:50 <geekosaur> I think any reason there is somewhere between "nobody proposed it" and "hasn't been around long enough yet"
20:14:34 <jollygood> or "it is the most mature and stable package for this purpose"
20:15:31 <albeit> I'm trying to install GHC 7.8 on 64-bit Ubuntu. Downloaded the binary.. when I run "configure" I get this error: http://lpaste.net/107851
20:15:39 <albeit> Any idea on how to fix it?
20:15:41 <geekosaur> the platform strives more for "most useful". but they are not good at guessing that; they need to hear what is more useful
20:16:10 <geekosaur> (and as yet hackage still does not provide useful feedback of that variety)
20:16:29 <jollygood> do you disagree with the choice of time package or are you just talking in general?
20:16:38 <lpvb> My cabal broke on osx using version 1.18 included with the platform. The error is 'cabal: internal error when reading package index: could not read tar file' and reinstalling cabal or using a newer version doesnt work. Removing ~/.cabal doesn't work either. Using OSX. any ideas?
20:16:59 <geekosaur> in general. more specifically: time was pretty much all there was when the first platform came out, and nobody has proposed an alternative
20:17:14 <geekosaur> if you want something in the platform, you need to propose it
20:17:25 <geekosaur> libraries@haskell.org list
20:17:54 <lpvb> 'The package index or index cache is probably corrupt. Running cabal update might fix it.' cabal update doesnt work
20:18:56 <shelf> hello! I can't seem to get -threaded working in a cabal sandbox
20:19:00 <sm> lpvb: sounds unpleasant. Adding -v{,2,3} may tell you enough to unbreak it
20:19:12 <lpvb> I'll try
20:19:52 <geekosaur> albeit: either the named file that is supposed to be readable and/or executable isn't, or it's trying to use a binary loader that isn't.
20:19:58 <shelf> anyone know why something like "ghc-options: -threaded" wouldn't work in a cabal file?
20:20:06 <geekosaur> that's all I can tell you from the error message
20:20:33 <lpvb> sm: no hints to me http://lpaste.net/110234
20:20:44 <marchelzo_> Is the information in real world haskell still useful today, or is there a more modern book on writing practical haskell?
20:21:04 <geekosaur> it needs some tweaks but is by and large still useful
20:21:10 <albeit> geekosaur: Makes sense... I had to "chmod +x" the configure, which seemed odd. I feel like I'll have to that for all the executables.. but it doesnt seem right.
20:21:15 <geekosaur> I have no idea if dons ever plans to update it
20:21:41 <geekosaur> albeit: yes, it sounds like you somehow lost all the execute bits. I can't tell how/why.
20:22:01 <albeit> geekosaur: Ha yeah, just going to redownload and extract and see if that helps
20:22:02 <geekosaur> if you are working from a bindist, fixing those will be *painful*
20:22:17 <albeit> geekosaur: What is a bindist?
20:22:27 <albeit> Oh binary distribution
20:22:50 * hackagebot Win32-dhcp-server 0.2.1 - Win32 DHCP Server Management API  http://hackage.haskell.org/package/Win32-dhcp-server-0.2.1 (MichaelSteele)
20:22:50 * hackagebot blacktip 0.1.0.1 - Decentralized, k-ordered unique ID generator.  http://hackage.haskell.org/package/blacktip-0.1.0.1 (bitemyapp)
20:23:00 <geekosaur> albeit: what you downloaded, a binary distribution with configure/make install to relocate it appropriately for your system. as opposed to a source distribution you would have to compile
20:24:00 <sm> lpvb: bah.. strace cabal update then
20:24:32 <geekosaur> someone reported something like that cabal update issue on one of the lists recently, I think
20:24:39 <sm> strace cabal update 2>&1 | grep index, perhaps
20:25:05 <sm> and yes search the internets for that error message
20:26:12 <jollygood> not sure what is so weird about the api :). maybe I just didn't dig deep enough yet.. addUTCTime 3600 <$> getCurrentTime
20:26:57 <sm> that's the spirit, nothing weird here no sirree :)
20:27:08 <albeit> Is it possible to install GHC 7.8 from an Ubuntu repository?
20:27:22 <shachaf> albeit: I don't think so.
20:27:30 <geekosaur> you could search launchpad for a ppa
20:27:31 <lpvb> I already searched the internet I wouldnt ask here otherwise
20:27:33 <shachaf> albeit: But it's easy to download it and install it yourself.
20:27:46 <lpvb> sm: I don't have strace but I used dtruss and grepped for index
20:27:48 <lpvb> nothing
20:27:49 <shachaf> You can have multiple versions of GHC installed at the same time, no problem.
20:28:05 <albeit> shachaf: Heh, trying that now. Had to "chmod +x" the configure, and then ran into more issues
20:28:14 <shachaf> ?
20:28:16 <shachaf> What did you download?
20:28:19 <goglosh> uh guys, is there much difference between hughs and ghc?
20:28:29 <sm> lpvb: those hits at https://www.google.com/search?hl=en&q=%22cabal%3A%20internal%20error%20when%20reading%20package%20index%3A%20could%20not%20read%20tar%20file%22&gws_rd=ssl are no good ?
20:29:20 <albeit> shachaf: Downloaded the Linux x86_64 binary distribution made on Debian 7
20:29:39 <shachaf> albeit: "ghc-7.8.3-i386-unknown-linux-deb7.tar.xz"?
20:29:40 <lpvb> sm: the mailing list says to delete files in .cabal
20:29:51 <shachaf> I downloaded that a few days ago and installed GHC from it. I didn't need to chmod anything.
20:29:53 <lpvb> I deleted the whole thing because there was no packages dir in there
20:29:57 <shachaf> Er, not that.
20:30:08 <shachaf> I used "ghc-7.8.3-x86_64-unknown-linux-deb7.tar.xz"
20:30:10 <albeit> shachaf: ghc-7.8.2-x86_64-unknown-linux-deb7.tar.bz2
20:30:23 <shachaf> Close enough.
20:30:29 <sm> lpvb: ok.. and are you using a sandbox ?
20:30:49 <lpvb> I dont think so, how do I find that out?
20:31:04 <lpvb> I thought the sandbox resides in the project dir I used it from
20:31:26 <albeit> shachaf: And this is the error I'm getting after running configure http://lpaste.net/107851
20:31:27 <sm> no I guess you're not, that requires cabal 1.20+
20:31:57 <shachaf> albeit: Maybe you extracted in some strange way?
20:32:01 <sm> how about downloading a newer cabal binary from the cabal site ?
20:32:06 <shachaf> Maybe your filesystem is strange somehow?
20:32:34 <sm> I don't know if will help, but wouldn't hur
20:32:35 <sm> t
20:33:33 <lpvb> I tried that I will try again as welll as renaming the cabal bin
20:34:14 <albeit> shachaf: I hope not! Just using the "Extract here..." menu item. It does say "Could not create the hard link file ...haddock something"
20:34:26 <albeit> Does that sound important...?
20:34:31 <shachaf> albeit: OK. I don't know anything about menu items.
20:34:36 <shachaf> It sounds like it might be important.
20:34:49 <shachaf> Try using tar instead of menu items. That's what I used.
20:36:19 <albeit> shachaf: Ah beautiful! Worked great. Thanks!
20:44:27 <jollygood> looking at parseTime..I don't see a flag that will match month without zero padding. %m requires "03" but I have just "3"
20:44:31 <lpvb> sm: bah! It works now after using 1.20.2. I must be crazy. Thanks for your patience and time!
20:46:12 <lpvb> what's the recommended library for arrows?
20:46:29 <roboguy_> lpvb: for arrows?
20:46:34 <lpvb> base?
20:46:39 <roboguy_> yeah, arrows are builtin
20:46:48 <lpvb> oh ok
20:46:57 <roboguy_> as far as I know, that's the only option. there are packages that use arrows though
20:47:06 <lpvb> I was thiking arrow tranformer library
20:47:06 <jollygood> %-m did it
20:47:49 <roboguy_> lpvb: most of the arrow libraries I've seen are FRP related
20:47:57 <roboguy_> *arrow-based libraries
20:52:40 <roboguy_> lpvb: it looks like there is a sort of arrow transformer library https://hackage.haskell.org/package/arrows
20:52:48 * hackagebot persistent-mongoDB 2.0.0.2 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-2.0.0.2 (GregWeber)
20:52:50 <roboguy_> it doesn't look very maintained though
20:54:01 <jollygood> is there a regex ".*" (match all) equivalent for parseTime in time package?
20:55:43 <jollygood> timestamp is at the begining of a stream, and it would be convenient if I could use user-supplied strings (at runtime) to parse the dates, without having to do any manual parsing myself
20:55:52 <jollygood> at the beginning of a string, even
20:58:43 <NemesisD> got sort of a unixy question for my haskell library
21:00:27 <NemesisD> i'm using getProcessStatus from the unix package to check the exit status of child processes. so does a posix process actually retain the exit statuses of all exited children forever, if this call only returns something when the child process is done
21:01:51 <glguy> NemesisD: it remembers the process status until you wait for it
21:01:56 <glguy> and then it cleans up
21:02:13 <glguy> failure to wait for the processes you spawn leads to zombies
21:02:28 <NemesisD> wait for it to finish?
21:03:19 <sveit_> is there an example of an explicity written prism, or is it not like lens and it makes the most sense to write it using the 'prism' function from control.lens? also, suppose I use a Prism to set something that "fails" to be set -- is there a way to express "Nothing" for this result?
21:03:38 <glguy> sveit_: There's no benefit to writing them explicitly
21:03:46 <glguy> but if you want to do it just inline the definition of prism
21:03:50 <glguy> and then simplify around that
21:04:12 <sveit_> glguy, avoid lens library dependency :) but the definition of prism uses things like "dimap" which I cannot find the definition for
21:04:23 <glguy> It's in the profunctors package
21:05:41 <sveit_> glguy, just found it. any answer for the second question? it seems failed assignments fail "quietly"
21:05:55 <glguy> > map (failover _Right (+1)) [Left 2, Right 3] :: [Maybe (Either Int Int)]
21:05:56 <lambdabot>  [Nothing,Just (Right 4)]
21:10:28 <sveit_> glguy, is there a "set"? or do i have to write failover PRISM (const VALUE)?
21:10:44 <glguy> If you need failover you have to use const
21:14:00 <sveit_> glguy, my point is i could write "failset p = failover p . const", but does lens define something like that in it's 100's of combinators?
21:14:18 <glguy> I understood, no there isn't a failset
21:42:12 <OceanSpray> yo is there a way to hide stuff in modules
21:42:22 <OceanSpray> like, in the module itself rather than when it's imported
21:42:48 <OceanSpray> say I want to use some special constructors that enforce some sort of invariant and I don't want others to use the vanilla constructors of the type
21:46:49 <OceanSpray> I remember this channel being a lot more active back in the day
21:47:11 <shachaf> At 21:45 PT on Fri?
21:47:24 <Iceland_jack> Everyone knows Haskell at this point
21:47:34 <joelteon> What else would Haskell users be doing on Friday nights?
21:49:11 <OceanSpray> why, hang out on IRC, of course?
21:49:42 <OceanSpray> school's already in session, is it not?
21:49:52 <OceanSpray> since when do graduate students party
21:51:01 <c_wraith> OceanSpray: the difference is obvious then - the people in this channel have graduated.
21:51:50 * shachaf hasn't.
21:52:05 <platz> Was reading http://edmundkirwan.com/general/c-and-c.html , I wonder if there would be a way to get all the transitive dependencies of the "modules" of a program
21:52:15 <OceanSpray> I've visited this channel since circa 2008
21:52:45 <OceanSpray> I guess 6 years is enough for a phd
21:53:30 <sveit_> is there a lens-like (i was looking at prism but it doens't look like it fits) object where (1) the "getting" or "viewing" operation may or may not fail depending on "presence" of the object (2) i can still use the "setter" part of the "lens" even if the "getting" part fails. the reason I can't use prisms here is that if the prism fails, so does the setting operation, unabmiguously
21:54:17 <sveit_> i want the setting operation to be able to fail, but not always fail if the getting fails
21:54:21 <glguy> sveit_: No, that doesn't exist
21:55:26 <glguy> What are you trying to do, maybe there's another way to do it in lens
21:56:50 <sveit_> glguy, basically, i have some kind of multi-dimensional-array-type-thing. i could try to "get" something out of the bounds of the array, which should fail with Nothing, but if i set an element I want to quiety expand the size of the array and be able to get it later
21:57:20 <glguy> The closest thing is going to be something like "at"
21:57:34 <glguy> where you have :: Index -> Lens s (Maybe a)
22:01:30 <sveit_> glguy, thanks! what is the performance of prism like? it seems like it calls the "getting" function regardless of whether I am using just the "setting" component, or does laziness save me here?
22:06:27 <gennady> Hey guys I am trying to convert this http://pastebin.com/cDvFmML2 to haskell which this is what I come up with so far http://lpaste.net/8842970648918622208, but I keep getting a warning about show/print when I am not using it?
22:10:43 <kaol> gennady: ghci uses print implicitly.
22:11:13 <glguy> gennady: You've got a type that is going to be hard to satisfy
22:11:23 <glguy> Integral and Fractional and at odds
22:11:37 <glguy> You should replace your   /   with `div`
22:11:46 <sveit_> glguy, also, can i define a prism with a setter that just updates the original structure? i.e. the type signature of prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b, but i'd really like the first function to be (s -> b -> s) like in lens
22:12:25 <shachaf> A prism isn't a lens, though.
22:12:57 <shachaf> Maybe you're looking for a lens instead? :-)
22:13:02 <gennady> Ah! Hmm. Thanks I'll have to read up on the difference
22:13:18 <gennady> Sorry, still really new to this.
22:13:48 <sveit_> shachaf, nope, i need failure :)
22:14:11 <shachaf> Maybe you want a traversal?
22:14:12 <glguy> gennady: You're fine, that's a reasonable question to have
22:14:30 <sveit_> shachaf, it looks like it, but i'm only focusing on "one" part of the structure
22:14:35 <shachaf> It's worth spending a bit of time figuring out what the lens types mean rather than trying to pattern-match.
22:14:44 <shachaf> sveit_: A traversal focuses on zero or more parts of the structure.
22:15:04 <gennady> Thanks, appreciate the help.
22:15:05 <sveit_> shachaf, i'm aware, but that's too general for me is the point
22:15:13 <sveit_> if i have to resort to it that's fine
22:15:48 <MorpheusBeing> shachaf - thanks for assistance earlier, have now solved the problem and got my understanding of that section of Lambdabot developed
22:15:54 <shachaf> There's a notion of an AffineTraversal which focuses on zero or one parts of a structure.
22:16:20 <shachaf> But making a type that reflects it is tricky since we're trying to fit into Haskell's existing ecosystem of types (among other things).
22:16:21 <sveit_> shachaf, ok, but what does a Prism do that isn't focusing on zero or one parts of a structure?
22:16:27 <glguy> The TrivialTraversal focuses on zero parts of the structure
22:16:28 <shachaf> But a Prism is a much more specialized notion.
22:16:34 <shachaf> A prism lets you construct.
22:17:12 <shachaf> data T a b = T { foo :: b, bar :: b } -- here you have a lens for foo and a lens for bar
22:17:18 <shachaf> Er, foo :: a
22:17:36 <shachaf> data S a b = Foo a | Bar b -- here you have a prism for Foo and a prism for Bar
22:17:49 <sveit_> so is it "bad" to write a traversal that only focuses on at most one part?
22:17:57 <shachaf> A lens lets you do two things: "extract" a value from a bigger structure, and "modify" an existing structure with a new value
22:18:03 <glguy> sveit_: It isn't.
22:18:24 <shachaf> A prism lets you do two things: "match" a structure to see if it matches the prism, and "construct" and new value using the prism
22:18:35 <shachaf> No, it's fine.
22:18:58 <shachaf> Well, it's not great. It's sort of like a list with at most one element, instead of Maybe.
22:19:09 <benzrf> a lens is a firster-class accessor; a prism is a firster-class constructor
22:19:11 <shachaf> But in practice it works pretty well.
22:22:46 <Welkin> is there a way to specify that a function can accept one of two types of arguments?
22:24:11 <Welkin> without combining the two types into a larger adt
22:24:26 <sgronblo> define a typeclass?
22:24:39 <sveit_> shachaf, so how would I "fail" within the definition of a "Traversal"?
22:25:00 <shachaf> Do you know how to write traverse?
22:25:04 <shachaf> As in a Traversable instance.
22:25:19 <nshepperd> three options: 1. use Either/adt 2. use a typeclass 3. don't
22:26:39 <Welkin> I'll have to think about those
22:26:42 <Welkin> thank you
22:26:55 <sveit_> shachaf, i never had to before, so probably not
22:27:02 <sveit_> i've used "traverse" before though, so I know what it does
22:27:11 <Welkin> a typeclass may be overkill
22:27:12 <haasn> Try that, then
22:27:19 <Welkin> I'll try Either first
22:27:26 <haasn> Try writing traverse for Maybe and for []
22:28:39 <sveit_> haasn, ok, i think that was easy
22:28:48 <Blorgon> hallu. any1 knows about the haskell compiler and where can i read extensivly about it?
22:31:54 <sveit_> shachaf, ok, so i've written traversable instances for Maybe and [], but i'm still unsure how i would write a Traversal within Control.Lens that fails given a certain condition
22:32:03 <Welkin> can (>>=) be used inside of a do block?
22:32:09 <Welkin> it seems redundant
22:32:12 <shachaf> Failing just means not matching on anything.
22:32:19 <shachaf> I.e. not using the function at all.
22:32:39 <haasn> sveit_: Think of it like traverse f Nothing
22:32:50 <sveit_> ah so just "pure"
22:32:51 <sveit_> ?
22:32:56 <haasn> Exactly
22:33:51 <glguy> I have some examples of traversals: https://gist.github.com/glguy/74960a3f1531b64a201b
22:33:54 <sveit_> ok, but then it seems like magic that something like toListOf now "knows" it should be empty :)
22:34:07 <glguy> (Sure, there are lots of them)
22:34:40 <glguy> Welkin: Yes, it can be handy when you don't want to name something: do {x <- f =<< m; ....
22:34:47 <dfeuer_> Blorgon, extensive information about using the GHC compiler is at http://www.haskell.org/ghc while extensive information about how it works and how you can work on it is at https://ghc.haskell.org/trac/ghc
22:34:52 <sveit_> i guerss the "pure" version of some Applicative is probably "nothing" then...
22:41:49 <fsdfffff> ghc does not show function calls when I run a binary with +RTS.  The binary was compiled via ghc -O2 --make Main.hs -prof -auto-all -fforce-recomp -rtsopts
22:41:52 <fsdfffff> any ideas?
22:46:36 <eazar001> fsdfffff: try ` -fprof-auto` instead of `auto-all`??
22:46:47 <eazar001> also, usually you shouldn't compiled with -O2 when profiling
22:47:30 <eazar001> (unless you have your reasons)
22:48:06 <angerman> if I have a list like [(x,a),(x,b),(x,c),(y,d),(z,e),(z,f),(z,g),(x2,h),(x2,i)] how do I obtain a list [(x,a),(y,d),(z,e),(x2,h)]? A list that is reduced on the first element of the fst element?
22:48:11 <fsdfffff> eazar001: still nothing
22:48:42 <jle`> :t nubBy
22:48:43 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
22:48:49 <fsdfffff> eazar001: this time I compiled with ghc --make Main.hs -prof -fprof-auto -fforce-recomp -rtsopts
22:48:58 <jle`> :t on
22:48:58 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
22:49:14 <angerman> jle`: hmm let me check nubBy :D
22:49:30 <jle`> i'm not sure if it's the best solution but it's the first thing that came to mind :)
22:49:38 <jle`> :t nubBy (on (==) fst)
22:49:39 <lambdabot> Eq b => [(b, b1)] -> [(b, b1)]
22:49:44 <jle`> :t on (==) fst
22:49:45 <lambdabot> Eq b => (b, b1) -> (b, b1) -> Bool
22:50:18 <angerman> hmm. what does nub mean anyway?
22:50:28 <fsdfffff> essence
22:50:33 <Welkin> only uniques
22:50:36 <jle`> > nub [1,4,4,5,1]
22:50:36 <eazar001> angerman: nub means "the general essence of something"
22:50:38 <lambdabot>  [1,4,5]
22:50:48 <eazar001> fsdfffff: are you getting an actual profile report at all?
22:51:00 <angerman> jle`: my first trie went with Map.fromList and Map.toList... but I'm not sure that would gurarantee the order.
22:51:08 <angerman> eazar001, fsdfffff thanks!
22:51:42 <eazar001> angerman: yw, oddly enough, they actual define that in the docs (as if it were a dictionary too!!). weird huh?
22:51:44 <jle`> angerman: it can if you set it up right
22:52:21 <angerman> eazar001: I must have missed that then :(
22:52:36 <eazar001> haha, no biggie, i'll point you to the ref =]
22:52:54 <angerman> jle`: hmm...
22:53:08 <eazar001> http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-List.html
22:53:17 <fsdfffff> eazar001: i see this http://dpaste.com/0ZNN26C.txt
22:53:28 <jle`> angerman: actually wait, no
22:53:36 <jle`> it wouldn't keep the order at the end.  it would preserve what was first though
22:53:41 <eazar001> fsdfffff: shit
22:53:45 <jle`> it'd sort your fst's
22:54:08 <fsdfffff> eazar001: ???
22:54:23 <eazar001> fsdfffff: that's really unhelpful ... the profile report. i've never seen that before.
22:54:26 <angerman> jle`: I was assumung the list -> tree conversion to break the order. In a few tests (I assume I got lucky) it didn't though.
22:54:40 <jle`> > nubBy (on (==) fst) [(1, 'a'), (1, 'b'), (3, 'c'), (1, 'd')]
22:54:42 <lambdabot>  [(1,'a'),(3,'c')]
22:55:13 <eazar001> fsdfffff: just curious, what ghc version are you running?
22:55:19 <fsdfffff> eazar001: I'll try to add a cost center.
22:55:27 <fsdfffff> eazar001: 763, 782.
22:55:32 <eazar001> k k
22:56:32 <angerman> jle`: hmm, so it removes the last (1,'d') as well ...
22:56:56 <fsdfffff> eazar001: no difference
22:56:58 <angerman> and what would the toList fromList version do as well.  Ohh, that's not even waht i want :(
22:57:00 <jle`> yeah, isn't that what you wanted?
22:57:12 <eazar001> fsdfffff: you kind of have me stumped there
22:57:32 <jle`> the toList fromList (well, you'd need your own custom toList, using a fold) would do the same thing but reorder the keys in ascending order
22:57:46 <angerman> jle`: no, more like fist item, until change. So even if it changes back, I want to get that information as well.
22:58:02 <jle`> ah
22:58:27 <angerman> :t groupBy
22:58:28 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
22:58:39 <jle`> yup that's the one
22:58:52 <angerman> > groupBy (on (==) fst) [(1, 'a'), (1, 'b'), (3, 'c'), (1, 'd')]
22:58:54 <lambdabot>  [[(1,'a'),(1,'b')],[(3,'c')],[(1,'d')]]
22:59:02 <angerman> > map head . groupBy (on (==) fst) [(1, 'a'), (1, 'b'), (3, 'c'), (1, 'd')]
22:59:03 <lambdabot>  Couldn't match expected type ‘a -> [[b]]’
22:59:04 <lambdabot>              with actual type ‘[[(b0, GHC.Types.Char)]]’
22:59:13 <angerman> > map head $ groupBy (on (==) fst) [(1, 'a'), (1, 'b'), (3, 'c'), (1, 'd')]
22:59:15 <lambdabot>  [(1,'a'),(3,'c'),(1,'d')]
22:59:30 <jle`> this is one of the few situations where head makes sense, btw :)
22:59:51 <jle`> because you can statically prove you won't get an empty list
23:00:01 <jle`> @src groupBy
23:00:01 <lambdabot> groupBy _  []     =  []
23:00:01 <lambdabot> groupBy eq (x:xs) =  (x:ys) : groupBy eq zs
23:00:01 <lambdabot>     where (ys,zs) = span (eq x) xs
23:03:13 <gennady> So I dont think lyah is explaining this well, or I just suck at understanding this part. How would you read (Eq a) => a -> [a] -> Bool
23:03:29 <gennady> it takes an equality value of a, iterates a list and returns a book?
23:03:34 <gennady> bool*
23:03:52 <benzrf> :t span
23:03:52 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
23:03:57 <benzrf> :t break
23:03:57 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
23:04:00 <benzrf> ?
23:04:10 <eazar001> gennady: a is some variable under the typeclass Eq, that goes to a function that takes a list of some variable a, which returns a bool
23:04:23 <eazar001> or sorry grrr, mixed that up
23:04:34 <benzrf> oh
23:04:37 <benzrf> ic
23:04:54 <eazar001> a function that takes some variable `a` that returns a function that takes a list of some type `a`, which returns a Bool
23:05:06 <eazar001> given ... that the variable a is under the typeclass Eq
23:05:16 <gennady> So you have to explicity specify the type of the variable as it is changed/moves through your function?
23:05:18 <eazar001> (can be operated on by (==))
23:05:30 <eazar001> if you wish
23:05:35 <eazar001> not always no
23:05:50 <eazar001> in that example, they wanted a to be a type that can be operated by ==
23:05:56 <eazar001> but it depends on your usage
23:06:06 <jle`> Gracenotes_: it is like a -> [a] -> Bool.  You can think about it as a function that takes an a, and a list of a's, and returns a Bool
23:06:08 <gennady> Ah
23:06:12 <jle`> er, gennady
23:06:29 <jle`> the function could have been written as (a, [a]) -> Bool
23:06:31 <DanZimm> question: is there any better syntax to the same thing as this? (map $ replicate 4) [1]
23:06:38 <DanZimm> i.e. w/o parens
23:06:39 <jle`> "give me an `a` and a `[a]` and i'll give you a Bool"
23:06:57 <MP2E> "but only if 'a' is an instance of typeclass Eq"
23:07:06 <jle`> mhm
23:07:24 <gennady> Ah ok makes sense
23:07:27 <jle`> the Eq a => ... means that `a` is restricted to only mean instances of Eq.  or, types whre you have defined (==) and/or (/=)
23:07:36 <eazar001> map (replicate 4) [1]
23:07:42 <eazar001> DanZimm: map (replicate 4) [1]
23:07:48 <gennady> So you should have a really firm understanding of these types is what I'm getting?
23:08:01 <jle`> gennady: well, the types tell a strong story :)
23:08:02 <gennady> Because usually I just :t <myfunction> in ghci to find out its typeclass
23:08:37 <jle`> but remember that something like a -> b -> c could be interpreted/rewritten as (a, b) -> c
23:08:44 <jle`> but in the form a -> b -> c, it's a lot more flexible
23:08:51 <jle`> i think LYAH will explain soon enough why :)
23:09:22 <gennady> Ah ok, I'll keep reading. Thanks! :)
23:09:27 <Welkin> I'm having typeclass issues now...
23:10:02 <Welkin> I declared two instances of a typeclass for a function that either takes a #{type int} or a GLAttribute
23:10:23 <Welkin> yet ghc interprets my literal 3 as a GLAttribute
23:10:32 <Welkin> and complains that it is not an instance of Num
23:10:32 <mhr> I'm writing a machine learning program in Python, and there's a data collection step (trying to generate the different data required for my vectors) that's taking a long time, so I've decided perhaps I should rewrite it in Haskell to get a boost in speed. However, maybe it won't help, and I'd like some advice. My problem is not the program itself, the part
23:10:33 <mhr> that's in Python, but its dependencies. The program I'm using (calling it from within my program) to help generate data for my dependencies takes a lot of memory and time per row of data, and I have 2.5 million rows of data to get through, so I've been using the multiprocessing module in Python to call from the shell my dependency on a row 80 times in
23:10:33 <mhr> parallel (if I let it run like that, however, my computer eventually freezes, so my current solution is simply to crash my program every 50 rows of data or so and automate restart with a shell script). I desperately need to make my program faster by using parallelism with my dependency, but I'm afraid it'll just be the same in Haskell even with Haskell's
23:10:33 <mhr> parallelism abilities I've heard about. Can anyone comment on this? What wouldI haven't made anything big in Haskell yet, by the way, so it could be that rewriting the data collection part of my program in Haskell naively could result in a significant slow-down simply because of my lack of experience in writing performant Haskell.
23:10:51 <Welkin> thank you for flooding mhr
23:10:57 <mhr> Sorry
23:11:01 <jle`> well, he has a legitimate question it seems
23:11:35 <jle`> better to post it all at once than to spread it over thirty messages :)
23:11:42 <Welkin> what could the issue be with my typeclass?
23:14:24 <eazar001> nubBy [("x","a"),("x","b"),("x","c"),("y","d"),("z","e"),("z","f"),("z","g"),("x2","h"),("x2","i")
23:14:31 <eazar001> oops
23:14:56 <eazar001> nubBy (\x y -> fst x == fst y) [("x","a"),("x","b"),("x","c"),("y","d"),("z","e"),("z","f"),("z","g"),("x2","h"),("x2","i")]
23:14:59 <eazar001> shit
23:15:14 <eazar001> how do you execute lambdabot again?
23:15:22 <eazar001> >nubBy (\x y -> fst x == fst y) [("x","a"),("x","b"),("x","c"),("y","d"),("z","e"),("z","f"),("z","g"),("x2","h"),("x2","i")]
23:15:36 <Welkin> use "> "
23:15:41 <eazar001> thank you Welkin
23:15:46 <Welkin> do it in a private message though
23:15:51 <eazar001> > nubBy (\x y -> fst x == fst y) [("x","a"),("x","b"),("x","c"),("y","d"),("z","e"),("z","f"),("z","g"),("x2","h"),("x2","i")]
23:15:53 <lambdabot>  [("x","a"),("y","d"),("z","e"),("x2","h")]
23:15:58 <DanZimm> eazar001: there's still parens there though :/
23:16:06 <eazar001> that's for someone else Welkin
23:17:03 <eazar001> angerman: your function should be : nubBy (\x y -> fst x == fst y)
23:17:41 <eazar001> DanZimm: that looks about as good as it can get
23:17:57 <eazar001> DanZimm: plus i think parentheses wrapped around ($) applications are a bit redundant
23:18:03 <eazar001> but that's just me
23:19:05 <angerman> eazar001: i think I missed the fact in my sample that the "key" (fst) could repeat, but should in that case not be ignored.
23:19:14 <angerman> > nubBy (\x y -> fst x == fst y) [("x","a"),("x","b"),("x","c"),("y","d"),("z","e"),("z","f"),("z","g"),("x2","h"),("x2","i"),("x","j")]
23:19:15 <lambdabot>  [("x","a"),("y","d"),("z","e"),("x2","h")]
23:19:32 <angerman> > map head $ groupBy (\x y -> fst x == fst y) [("x","a"),("x","b"),("x","c"),("y","d"),("z","e"),("z","f"),("z","g"),("x2","h"),("x2","i"),("x","j")]
23:19:33 <lambdabot>  [("x","a"),("y","d"),("z","e"),("x2","h"),("x","j")]
23:20:07 <angerman> eazar001: It was a failure on my part to provide a comprehensive example :(
23:20:16 <eazar001> angerman: ahhhh, sorry about that
23:22:09 <sveit_> so if i write instance (C1 a) => C a where ..., does that mean i cannot write a non-overlapping instance for C anywhere else?
23:22:25 <c_wraith> sveit_: yes
23:23:04 <sveit_> c_wraith, is there any way around it? basically if (instance C1 a) then (instance C a) is trivial to write, so to avoid boilerplate i'd like to not do that
23:23:34 <sveit_> like is there a way to say "b is NOT instance C1" if there is no way to do that?
23:24:09 <jle`> DanZimm: what's wrong wit parentheses?
23:24:18 <jle`> do you want to remove spaces, too? :P
23:24:36 <c_wraith> sveit_: the only way to deal with that situation sanely is newtypes to indicate when a special case is available
23:24:53 <mhr> To add a bit to my question for advice above, for my problem of running multiple outside programs simultaneously as mentioned, what would be a way to do that in Haskell (I.e. does anyone have some recommendations for specific libraries)?
23:25:12 <sveit_> c_wraith, is there an example of this?
23:25:35 <c_wraith> sveit_: sort of like the Sum/Product newtypes in Data.Monoid, which provide wrappers for tupes that are instances of Num
23:25:42 <c_wraith> *types
23:27:41 <DanZimm> jle`: mostly curious
23:27:46 <DanZimm> eazar001: thanks!
23:27:59 * DanZimm is realtively new to haskell so just testing its limits
23:28:30 <jle`> sveit_: think ther'es a GHC extension that might allow you to mess around with something like that, but it's kind of still in general not too sane of a thing to do
23:28:32 <c_wraith> you can always fully remove parens from an expression by naming subexpressions.  It's..  Not really interesting to do so.
23:28:34 <jle`> *i think
23:28:58 <sveit_> c_wraith, so for wrapper class W, i would have instance (C1 a) => C (W a) where ..., right?
23:29:04 <c_wraith> jle`: you can mess with OverlappingInstances and IncoherentInstances, but then you might get eaten by demons
23:29:12 <jle`> yes, that's what i mean :)
23:29:15 <c_wraith> sveit_: correct
23:29:46 <sveit_> seems inelegant
23:30:04 <eazar001> DanZimm: np, didnt do much though =]
23:30:18 <jle`> > let r4 = replicate 4 in map r4 [1]
23:30:19 <lambdabot>  [[1,1,1,1]]
23:30:20 <c_wraith> sveit_: it's not the most elegant thing - but it keeps you sane.
23:30:30 <eazar001> hmmm
23:30:57 <jle`> > ($[1]) . ($replicate 4) $ map
23:30:59 <lambdabot>  [[1,1,1,1]]
23:31:08 <Welkin> what would you call #{type int}?
23:31:12 <Welkin> why is the hash there?
23:31:14 <jle`> hm
23:31:19 <Welkin> I know what it does, but what *is* it?
23:31:29 <sveit_> c_wraith, but now whenever i want to use that class in that context I either have to wrap it, or write a special unwrapped version of the instance, perhaps using the wrapped instance in my definition?
23:31:32 <c_wraith> Welkin: that looks like hsc2hs syntax
23:31:37 <Welkin> it is
23:31:40 <jle`> > flip id [1] . id replicate 4 $ map
23:31:41 <lambdabot>  mueval-core: L.hs: removeLink: does not exist (No such file or directory)
23:31:50 <jle`> > flip id [1] . flip id (id replicate 4) $ map
23:31:51 <lambdabot>  [[1,1,1,1]]
23:31:57 <jle`> almost there
23:32:02 <c_wraith> Welkin: oh, do you mean like "what's the name of the operation"?
23:32:04 <Welkin> is it possible to make it an instance of a typeclass?
23:32:18 <Welkin> or is it not a concrete type?
23:32:35 <Welkin> c_wraith: that too
23:33:14 <c_wraith> Welkin: It could be just about anything.  hsc2hs runs C macros inside #{}, looked up by mangling the name of the first token
23:33:53 <c_wraith> Welkin: well, CPP macros.  the way hsc2hs operates is instructive.  It converts your source into a C program that outputs a haskell file.
23:34:09 <c_wraith> Welkin: The macros operate in the context of that C file
23:34:20 <jle`> > flip id [1] . flip id `id` replicate 4 $ map
23:34:21 <lambdabot>  Precedence parsing error
23:34:21 <lambdabot>      cannot mix ‘GHC.Base..’ [infixr 9] and ‘GHC.Base.id’ [infixl 9] in the s...
23:34:24 <jle`> darn
23:35:10 <c_wraith> Welkin: I don't remember what the type macro does offhand
23:35:26 <Welkin> I seem to have trouble using a typeclass with it
23:35:32 <jle`> hm.
23:35:37 <jle`> > flip id [1] <<< flip id `id` replicate 4 $ map
23:35:37 <Welkin> it acts like I never wrte the instance
23:35:38 <lambdabot>  [[1,1,1,1]]
23:35:41 <jle`> yuss
23:35:50 <Welkin> and instead complains that it doesn't with with the other instance of the typeclass
23:35:53 <jle`> there you go DanZimm. don't do that in real code though
23:36:06 <eazar001> lol
23:36:20 <Welkin> work with*
23:36:43 <c_wraith> sveit_: there are some tricks, like using the newtype library, or the equivalent parts of the lens library.  They provide helper functions that let you wrap and unwrap neatly.
23:39:15 <c_wraith> Welkin: the quick summary is that hsc2hs macros work at a textual level, in your C compiler's environment.  They can produce any text they want - so long as the haskell file that results from the use of them is well-formed.
23:40:07 <c_wraith> Welkin: err, that's misleading.  They can generate C code to do all kinds of things.  producing text in the final haskell file is just the only useful thing they can do, but they aren't limited much in how they'll do so
23:40:40 <sveit_> c_wraith, just realized i could use undecidable instances to just simulate overlapping instances :)
23:40:53 <sveit_> and throw the typechecker for a loop
23:41:32 <gennady> Ah finally got it working!
23:41:39 <gennady> Felt I would share my enjoyment :P
23:41:42 <c_wraith> sveit_: then you'll need OverlappingInstances when you want to add another instance.  Soon you'll need IncoherentInstances.  After that, you go insane when adding a new instance breaks all your existing code
23:42:08 <c_wraith> sveit_: that's why my suggestion to use a newtype wrapper was based on sanity, not elegance
23:42:45 <sveit_> c_wraith, if only macros were as easy in haskell as they wre in lisp. always using the wrapped type is conceptually pretty ugly
23:44:05 <c_wraith> sveit_: honestly, the wrapper utilities in those libraries are so good, I consider them to be the only realistic solution
23:45:00 <sveit_> c_wraith, what part of the lens library emulates the newtype library?
23:45:43 <shachaf> The class Wrapped is like the class Newtype
23:46:22 <shachaf> And other parts are sprinkled throughout various modules wherever they make sense.
23:51:25 <sveit_> unrelated question, is there some combinator in the lens library to apply "over lens f a" for a list of lenses?
23:52:12 <sveit_> i.e. something like "\l -> over l f a <$> lenses"? i'm thinking of just folding over the list, but is there a more efficient way?
23:52:25 <shachaf> Not really.
23:52:35 <sveit_> of course my example with <$> doesn't work, btw
23:53:27 * hackagebot semver 0.2.1 - Representation, manipulation, and de/serialisation of Semantic Versions.  http://hackage.haskell.org/package/semver-0.2.1 (BrendanHay)
23:53:43 <sveit_> ok, and suppose i have a traversal that targets elements in a structure, say a list, and I pass several indices, some of them invalid. is proper behavior to just ignore the invalid inidices?
23:53:46 <shachaf> I guess you mean something like foldr (.) id . map (%~ f)
23:53:58 <shachaf> I don't understand.
23:54:30 <sveit_> something like ordinals from Data.Vector.Generic.Lens is a good example of what I'm asking about
23:54:52 <shachaf> Pass indices to what?
23:55:03 <shachaf> You mean you're writing a traversal?
23:55:05 <sveit_> shachaf, you pass indices to create the lens in the first place
23:55:15 <sveit_> sorry, the traversal
23:55:30 <shachaf> The behavior of ix is probably a reasonable one to follow.
23:56:41 <shachaf> I guess you mean something like [k] -> Traversal' (Map k v) v
23:59:03 <joelteon> Does anyone know whether optparse-applicative can generate an option parser that takes two arguments instead of one?
