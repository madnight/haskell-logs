00:07:34 <glguy> You probably need to add the surge constructor left of that mess of lift
00:08:18 <glguy> It would be better to name that lifting operation and write out its type than to inline it like that
00:08:35 <glguy> I can't try the change from my phone though
00:13:51 <Fuuzetsu> real programmer's have a Haskell dev environment on their phones!
00:13:54 <Fuuzetsu> programmers*
00:13:57 * Fuuzetsu shuts up
00:20:25 <Bazzie> do phones have vi?
00:20:49 <Fuuzetsu> I tried installing emacs on a friend's Android tablet but it segfaulted
00:20:52 <Fuuzetsu> I'm user you can find vi
00:20:53 <merijn> Is there a way to silence the warning from TypedHoles?
00:20:54 <Fuuzetsu> sure*
00:21:08 <Fuuzetsu> merijn: I think they put in a flag
00:21:15 <Fuuzetsu> at least I remember someone saying they shouldb
00:21:29 <Fuuzetsu> but I'm unsure whether that stayed with the removal of TypedHoles as extension
00:21:59 <merijn> Let's find out!
00:23:28 <merijn> oh
00:23:37 <merijn> That was not what I was hoping for >.<
00:23:54 <Fuuzetsu> is that a ‘no’ for the flag then?
00:23:56 <merijn> -fno-warn-typed-holes turns of the extension, but that didn't quite do what I wanted :p
00:24:19 <merijn> Because then the result is just a "Not in scope: x" >.<
00:24:55 <merijn> The problem I have is that typedholes are a warning, which is causing syntastic to complain whenever I use them
00:24:56 <Fuuzetsu> what's the actual thing you want to achieve?
00:25:09 <Fuuzetsu> sounds like you should configure syntastic to know better
00:25:14 <merijn> But the entire point of me adding a typed holes is to shut up syntastic and only see the warning when actually compiling
00:25:19 <merijn> Fuuzetsu: How? :p
00:25:24 <Fuuzetsu> no idea, never ever used it
00:25:35 <merijn> GHC reports a warning, syntastic just highlights it
00:29:12 <merijn> Fuuzetsu: I don't think there is a way to filter out a warning like this, unfortunately
00:30:03 <Fuuzetsu> merijn: it's free software, you could just hack it to ignore it
00:32:49 <merijn> Fuuzetsu: That leads to an infinite regression of yak shaving
00:33:07 <merijn> I'm trying to write new free software here, not fix 10,000 things I run into while doing so :p
00:33:57 <Fuuzetsu> I imagine that majority of software today was written while the author actually set out to write something else but had to shave some yaks along the way.
00:34:30 <merijn> Fuuzetsu: I'm already 3 yaks down that road!
00:34:42 <merijn> Fuuzetsu: I don't want even more distractions :(
00:35:37 <Fuuzetsu> I think half my recent repos are unexpected yaks ;(
00:37:41 <merijn> Fuuzetsu: I feel like I should finish at least *one* thing
00:38:29 <Fuuzetsu> I'm actually mid-meditation about the name for the next yak
00:38:55 <merijn> Fuuzetsu: Ooh, maybe we can help each other, I'm still torn between names for this yak :p
00:39:04 <Fuuzetsu> no thanks, one name is plenty
00:39:13 <Fuuzetsu> I'll call it ‘yak’.
00:39:15 <Fuuzetsu> yes, that will do
00:39:19 <Fuuzetsu> it's just an experiment anyway
00:39:32 <Fuuzetsu> not even taken
00:41:27 <merijn> See, the optimal name for my yaks is already taken (and not optimal anyway)
00:41:48 <Fuuzetsu> call it hs-optimalname
00:41:50 <Fuuzetsu> can't go wrong
00:42:32 * hackagebot type-natural 0.2.1.5 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.1.5 (HiromiIshii)
00:42:36 <merijn> Fuuzetsu: What if the optimal name was already "haskell-something"? :p
00:43:05 <Fuuzetsu> lambda-something
00:43:27 <Fuuzetsu> alright, it's that time again to pick an IO library, exciting
00:43:34 <Fuuzetsu> maybe conduit…
00:43:52 <Fuuzetsu> hm, never used itteratees, maybe that
00:44:01 <Fuuzetsu> iteratees*
00:44:01 <merijn> Fuuzetsu: I was torn between LambdaMQ and LambdaZero so far :)
00:44:11 <Fuuzetsu> ZeroMQ
00:44:23 <Fuuzetsu> \Zero -> Mq
00:44:25 <Fuuzetsu> MQ*
00:44:37 <merijn> Fuuzetsu: ZeroMQ is what I'm writing an implementation for >.>
00:44:49 <Fuuzetsu> oh hm, didn't know that was a thing already
00:45:11 <Fuuzetsu> SuccZeroMQ
00:45:14 <merijn> Fuuzetsu: haskell-zeromq is the library wrapping it, I'm writing a pure haskell reimplementation of the network protocol
00:45:36 <Fuuzetsu> pure-zeromq maybe?
00:45:39 <Fuuzetsu> descriptive
00:52:15 <lfairy> Fuuzetsu, merijn: onemq
00:52:24 <lfairy> it's only logical
00:52:53 <merijn> lfairy: :p
00:52:59 <Fuuzetsu> that was my thought before SuccZeroMQ but I decided it was too disjoint
00:53:00 <merijn> I kinda liked LambdaMQ, actually
00:57:35 * hackagebot data-fin 0.1.1.3 - Finite totally ordered sets  http://hackage.haskell.org/package/data-fin-0.1.1.3 (WrenThornton)
01:02:36 * hackagebot markov-chain 0.0.3.3 - Markov Chains for generating random sequences with a user definable behaviour.  http://hackage.haskell.org/package/markov-chain-0.0.3.3 (HenningThielemann)
01:03:08 <merijn> ugh
01:03:16 <merijn> and once again lack of recursive imports ruins my day
01:03:42 <Fuuzetsu> I had to write some boot files for Yi, it was terrible
01:03:47 <Fuuzetsu> less work than moving everything though
01:04:35 <merijn> Fuuzetsu: I can move things, but it ruins the nice "one module per concern" thing I have going
01:05:00 <merijn> Because it means I basically dump half of my datatype definitions in one file and then import that into all the modules that actually work with those datatypes
01:05:47 <Fuuzetsu> ah, the infamous .Types modules
01:06:07 <Fuuzetsu> I just start off projects with one of those to begin with
01:07:19 <Fuuzetsu> is there a cool new IO library on the market or should I just go with conduits?
01:07:36 * hackagebot haskore 0.2.0.4 - The Haskore Computer Music System  http://hackage.haskell.org/package/haskore-0.2.0.4 (HenningThielemann)
01:07:51 <merijn> Pipes :p
01:08:25 <Fuuzetsu> that pre-conduit era right
01:08:43 <Fuuzetsu> Henning Thielemann sure does a lot of work
01:09:00 <Fuuzetsu> when I asked about an issue tracker for haskore: No need for that since I solve problems immediately! :-)
01:09:01 <Fuuzetsu> must be nice
01:22:03 <stalintrotsky> what's the best way to define an Ord instance for an enumeration where the ordering is just an arbitrary one to make it look nice when displaying?
01:22:20 <stalintrotsky> There must be some better way than defining n ^ 2 pattern matches
01:22:57 <merijn> stalintrotsky: If you derive Ord it will follow the ordering of constructors in the definition
01:23:04 <stalintrotsky> Ok, thanks
01:23:22 <merijn> stalintrotsky: "data Foo = Foo | Bar | Baz deriving (Ord)" <- Foo < Bar and Bar < baz
01:30:44 <Fuuzetsu> merijn: pipes is harder to work with if you want resource usage you can fairly easily predict, right?
01:32:19 <merijn> In what way?
01:32:53 <merijn> The main difference, afaik, is the way they deal with leftovers
01:32:58 <Fuuzetsu> right
01:33:06 <Fuuzetsu> I'm reading http://www.yesodweb.com/blog/2013/10/core-flaw-pipes-conduit at the moment
01:34:04 <merijn> Incidentally, this whole "detect stream termination" thing is what pipes-parse is for nowadays
01:39:38 <Fuuzetsu> well, this is the kind of info I'm looking for
01:57:20 <solirc> bernalex: Just a heads up, there are still bungs with `cabal repl` on test-suites... https://github.com/haskell/cabal/issues/2032
02:05:45 <solirc> bennofs: FYI, just opened that issue https://github.com/sol/doctest/issues/89
02:13:35 <sylar> how to use Data.WAVE?
02:16:18 <sylar> what is the cabal install for it?
02:17:26 <pavonia> The package name seems to be WAVE, so it's "cabal install WAVE"
02:17:38 <sylar> ok
02:18:35 <friden> im having a problem compiling a file with bangpatterns enabled. this is my first time trying to compile a file with language extentions enabled: http://pastebin.com/SfTpCkSw
02:18:38 <friden> compiling with: ghc -o BangPatternTest BangPatternTest.hs
02:18:51 <friden> it gives me "Warning: output was redirected with -o, but no output will be generated"
02:18:54 <friden> because there is no Main module.
02:19:19 <friden> the quote was meant to cover both lines, sorry
02:19:56 <pavonia> The easiest is to rename the module to Main
02:20:13 <friden> oh
02:20:24 <friden> and if i dont want it named main? how do i do?
02:21:26 <pavonia> I think GHC has an option to state the main-function name, not sure if there's something similar for the module name
02:21:45 <friden> ok, maybe i should settle with main then
02:21:59 <friden> it worked compiling, thanks :D
02:22:25 <friden> thou i still dont grasp how to use force evaluation to speed things up -_-
02:22:42 <friden> that code got a stack overflow
02:22:52 <sylar> how to write a file path like "C:\dir\file"?
02:24:02 <pavonia> friden: Grep for "-main-is" in https://www.haskell.org/ghc/docs/7.0.4/html/users_guide/options-phases.html
02:24:37 <pavonia> sylar: What do you mean by write here?
02:25:20 <sylar> I try to getWAVEFile "C:\Users\bla"
02:25:26 <sylar> pavonia, ^
02:25:35 <sylar> and I get an error
02:25:46 <sylar> I am guessing that it doesn't like the "\"
02:26:27 <pavonia> Oh, you need to esacpe the backslash: "\\"
02:26:43 <friden> pavonia: oh, nice, thanks
02:27:37 <sylar> I changed it to / and it is now hanging
02:28:49 <sylar> now it work
02:29:04 <sylar> so.. anyway... how do I use that WAVE package?
02:29:19 <lfairy> sylar: try checking the documentation
02:29:21 <lfairy> @hackage WAVE
02:29:22 <lambdabot> http://hackage.haskell.org/package/WAVE
02:30:29 <lfairy> If you scroll down to "Modules", then click on "Data.WAVE", you can get a list of functions to use
02:31:33 <sylar> I see them, but I don't understand
02:33:27 <sylar> I think that what I want is to extract from the file the 'type WAVESamples = [[WAVESample]]"
02:33:38 <sylar> but I don't see what function do that
02:33:59 <sylar> getWAVEFile :: String -> IO WAVE
02:34:10 <sylar> so I can get IO WAVE
02:35:22 <sylar> WAVE have constructor with WAVESamples
02:35:47 <sylar> I am not sure what I can do with it
02:37:01 <pavonia> waveSamplesis a function of type WAVE -> WAVESamples
02:47:05 <sylar> pavonia, how do  you know?
02:47:34 <pavonia> This is how Haskell record fields work
02:47:41 <sylar> ah
02:48:02 <pavonia> Maybe you should start with a Haskell introduction first
02:48:08 <pavonia> @where lyah
02:48:09 <lambdabot> http://www.learnyouahaskell.com/
02:48:16 <sylar> oh, I read all of it
02:48:38 <oakwhiz> @where rwh
02:48:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:48:54 <pavonia> sylar: You have already read it?
02:48:54 <sylar> maybe except chapter 14
02:49:00 <sylar> yes
02:49:06 <sylar> I did
02:49:17 <sylar> I jsut
02:49:27 <sylar> I just never wrote anything
02:49:43 <Fuuzetsu> IO WAVE sounds like some new cool Google thing
02:49:48 <Fuuzetsu> ``cool''
02:49:56 <sylar> so I am a bit confused
02:50:11 <sylar> it is for reading .wav sound files
02:52:02 <sylar> what is wrong with "samples <- waveSamples waveIO" ?
02:52:24 <sylar> (where waveIO is of type IO WAVE)
02:52:43 <sylar> got - Couldn't match type `[[WAVESample]]' with `IO t0'
02:53:00 <oakwhiz> sylar: do you know about the IO monad?
02:53:03 <sylar> yes
02:53:17 <sylar> I need to extract the WAVE form the IO
02:53:20 <sylar> I forgot how
02:54:16 <sylar> waveIO >> samples <- waveSamples  ?
02:55:48 <pavonia> You can't apply waveSamples to an IO action directly, you need to use e.g. liftM
02:55:51 <pavonia> :t liftM
02:55:52 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
02:56:30 <sylar> what I wanted to do was to extract the samples
02:56:41 <sylar> and put it in a variables
02:56:46 <sylar> variable
02:56:54 <pavonia> yes
02:57:02 <sylar> I guess the term here is bound it to a name
02:57:21 <sylar> I have waveIO which is an IO WAVE
02:57:48 <sylar> I need to do something to operate over the WAVE
02:57:50 <latk> Is there some module to convert Int64 into Int ?
02:58:18 <sylar> is what I need: waveIO >>= function
02:58:26 <oakwhiz> latk: fromIntegral
02:58:35 <pavonia> sylar: You first need something to "lift" a function to work on an IO action
02:58:37 <latk> oakwhiz: Awesome, thanks.
02:59:50 <sylar> but the >>= extract the WAVE into the function no?
02:59:59 <sylar> it remove the monad, no?
03:00:21 <pavonia> No. Have a look at the types of liftM, waveSamples and waveIO. How could you combine them to get from IO WAVE to IO WAVESamples?
03:00:45 <oakwhiz> :t liftM
03:00:46 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
03:02:01 <sylar> :t waveSamples
03:02:02 <lambdabot> Not in scope: ‘waveSamples’
03:03:41 <oakwhiz> sylar: lambdabot doesn't import all modules on hackage
03:04:09 <pavonia> waveIO :: IO WAVE
03:04:11 <pavonia> waveSamples :: WAVE -> WAVESamples
03:04:12 <pavonia> liftM :: (a -> b) -> IO a -> IO b     (simplified)
03:04:57 <Jafet> We need a recycling centre for all the IOs that people want to throw away.
03:05:22 <oakwhiz> "IO isn't something you can just dump on a truck. IO is a series of tubes."
03:06:44 <sylar> liftM waveSamples waveIO ?
03:06:59 <sylar> I don't have liftM in my winghci
03:07:19 <pavonia> Yes, that's correct
03:07:30 <pavonia> liftM is in Control.Monad
03:08:25 <sylar> Couldn't match expected type `m0 WAVE' with actual type `WAVE'
03:09:03 <sylar> maybe it is the association defaults?
03:09:08 <sylar> how does it work
03:09:20 <pavonia> What have you tried?
03:09:46 <sylar> f g h x = (((f g) h) x) ?
03:09:57 <sylar> I tried liftM waveSamples waveIO
03:09:57 <oakwhiz> sylar: that's currying
03:10:39 <pavonia> sylar: Are you sure waveIO has type IO WAVE?
03:11:22 <sylar> :t waveIO
03:11:22 <sylar> waveIO :: WAVE
03:11:23 <lambdabot> Not in scope: ‘waveIO’
03:11:25 <sylar> oops
03:11:39 <pavonia> Oh well, it isn't :(
03:11:48 <sylar> oh, it is better, no?
03:12:09 <sylar> I did
03:12:15 <sylar> waveIO <- getWAVEFile "C:\file.wav"
03:12:47 <pavonia> So it isn't an IO action but the result value of one
03:13:10 <pavonia> which means you can't use liftM on it, but you can use waveSamples directly
03:13:19 <sylar> good :D
03:13:49 <sylar> I did, and got the screen filled with stuff looking like: [-2031616],[-2228224],[-1966080],
03:14:23 <pavonia> What is your aim, btw?
03:15:02 <sylar> I want to find the frequency of some waves in the file
03:15:27 <sylar> I am not sure what these values are
03:15:31 <sylar> the samples
03:15:53 <sylar> there should be time and value
03:16:01 <sylar> or maybe each is of the next sample
03:16:12 <sylar> and they are just the values
03:17:02 <oakwhiz> sylar: Typically that is done using Goertzel's algorithm, or a real-valued fast Fourier transform
03:17:27 <pavonia> Can't you calculate the time stamp from the position in the list and the meta data of the file?
03:18:52 <oakwhiz> sylar: pavonia is correct, you need to get the sample rate of your wave file in order to deduce time from sample index
03:19:01 <sylar> pavonia, I probably can
03:19:58 <sylar> I don't know the goertzel algorithm
03:21:01 <oakwhiz> Goertzel's algorithm is for efficiently finding the energy at specific frequencies, and the FFT is efficient at finding the energy at all frequencies
03:21:50 <oakwhiz> If you're just trying to find the strongest frequency or the lowest frequency, there are other ways of estimating that
03:23:05 <sylar> oakwhiz, energy?
03:25:10 <oakwhiz> sylar: the results of an FFT can be squared and added to obtain a power spectrum across different frequencies. I used the terms "power" and "energy" interchangeably when in fact they are different.
03:26:38 <sylar> ok
03:26:53 <sylar> I can try these algorithms and see what they give
03:27:36 <sylar> however from audacity, it doesn't look like fft will give me the correct value, because of noise
03:29:07 <oakwhiz> sylar: you can adjust the FFT windowing function and size to accomodate your needs
03:29:44 <oakwhiz> the most common windows seem to be the Hanning window and the root-raised cosine window
03:30:27 <oakwhiz> in addition, if your input data is time-variant, you might want a sliding window FFT instead
03:31:00 <oakwhiz> this gives you a 2D grid of results instead
03:31:15 <sylar> the noise have higher frequency then the signal
03:31:34 <sylar> so the size of the window won't eliminate the noise
03:31:40 <sylar> (I think)
03:32:02 <oakwhiz> sylar: you can bandlimit frequency estimation by ignoring bins above a certain index.
03:32:19 <sylar> ok, I will try
03:32:40 <sylar> haskell have FFT, I am guessing (?)
03:32:44 <oakwhiz> e.g. a 4096-point FFT of a 44.1kHz signal = about 10.7 Hz per bin
03:33:47 <oakwhiz> if you want to ignore all frequencies beyond 10 kHz then you limit your search to below the 934th bin
03:34:22 <oakwhiz> or is that the 467th bin... damn Nyquist limit
03:34:41 <oakwhiz> been a while since I've done digital signal processing
03:52:45 <sylar> oakwhiz, thanks.  I will try to use the fft library
03:54:12 <sylar> i found this : http://hackage.haskell.org/package/fft-0.1.7.2/docs/Math-FFT.html
04:00:06 <sagittarian> in a definition like data Maybe = Nothing | Just a, what is the proper term for Nothing and Just?
04:00:11 <jollygood> I have two threads printing to stdout without any synchronization. in ghci all the lines in the output are mixed together, but when I compile the program the output is fine. am I just getting lucky when compiling the program? how would one usually synchronize something like this? the order of printed lines is not important, I just dont want them mixed together
04:00:17 <Fuuzetsu> sagittarian: constructors?
04:00:29 <sagittarian> Fuuzetsu, thanks, that's what i was thinking but i wasn't sure
04:03:07 <Jafet> Use a mutex or Chan. It has nothing to do with compilation, probably ghci sets a different terminal mode.
04:04:40 <sylar> what to do with: <interactive>: out of memory
04:04:58 <Jafet> Buy more RAM!
04:05:19 <hexagoxel> use proper infinite band with your turing machine
04:05:45 <jollygood> mutex? that is what I would use in C
04:08:33 <hexagoxel> sylar: serious answer: either you really have a program that needs more memory than you got, or (more likely) you enter some kind of (buggy) loop that allocates more and more, until you run out
04:09:03 <Jafet> The rts is C, so why not
04:10:17 <sylar> hexagoxel, I just used getWAVEFile and then putWAVEFile
04:10:31 <sylar> in winGCHi
04:10:57 <jollygood> because I expected something better and less error prone than what I already had in C.. statical guarantee that I am not calling IO functions without synchronizing them properly, perhaps. am I dreaming?
04:11:12 <prophile> type WAVESamples = [[WAVESample]]
04:11:18 * prophile winces
04:11:47 <Jafet> Lazy programmer detected
04:11:47 <prophile> jollygood: there's STM
04:11:51 <prophile> depending on what you want to do
04:12:41 <Jafet> Also type WAVESample = Int32, a boxed type
04:13:02 <jollygood> prophillie I want to synchronize writes to stdout to avoid mangled output
04:13:04 <Jafet> jollygood: then use a Chan
04:13:52 <sylar> what?
04:19:06 <hexagoxel> jollygood: IO allows all IO stuff. you could write a monad SynchronizedSubsetOfIO or something, but it'd be hard to agree on what to exactly to allow in it, if you want it general-purpose.
04:32:27 <sven`> hi, how can I use lambdabot to convert a function into point-free style?
04:32:42 <Fuuzetsu> @pl f x y = f y x
04:32:42 <lambdabot> f = fix flip
04:33:01 <Fuuzetsu> huh
04:33:03 <Fuuzetsu> :t fix flip
04:33:04 <lambdabot> a -> a -> c
04:33:11 * hackagebot aws 0.10 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.10 (AristidBreitkreuz)
04:33:25 <sven`> @pl (+) (+1) (*)
04:33:25 <lambdabot> (1 +) + (*)
04:33:46 <Fuuzetsu> fix flip 3 (+ 4)
04:33:48 <prophile> Fuuzetsu: probably not the function you meant to put in
04:33:48 <Fuuzetsu> > fix flip 3 (+ 4)
04:33:50 <lambdabot>  No instance for (GHC.Num.Num (a0 -> a0))
04:33:50 <lambdabot>    arising from the literal ‘3’No instance for (GHC.Num.Num a0) arising from ...
04:33:50 <lambdabot>  The type variable ‘a0’ is ambiguous
04:33:50 <lambdabot>  Note: there are several potential instances:
04:33:50 <lambdabot>    instance GHC.Num.Num GHC.Types.Double
04:34:00 <Fuuzetsu> prophile: I just put in the first thing I could come up with
04:34:01 <prophile> @pl \f x y -> f y x
04:34:01 <lambdabot> flip
04:34:10 <Fuuzetsu> I wasn't aiming for flip ;)
04:34:14 <prophile> oic
04:34:31 <sven`> @pl \f fa fb a b -> f (fa a) (fb b)
04:34:32 <lambdabot> ((flip . ((.) .)) .) . (.)
04:34:37 <Fuuzetsu> > fix flip 3 4
04:34:42 <lambdabot>  mueval: ExitFailure 1
04:34:47 <sven`> holy crap
04:34:52 <Fuuzetsu> that's some amazing type though
04:35:08 <Fuuzetsu> > fix flip 'a' id
04:35:09 <lambdabot>  Couldn't match expected type ‘GHC.Types.Char’
04:35:09 <lambdabot>              with actual type ‘a0 -> a0’
04:35:17 <Fuuzetsu> whatever
04:35:21 <sven`> hmm
04:35:27 <prophile> Fuuzetsu: it kind of makes sense
04:35:47 <prophile> f x y just calls itself with the arguments backwards, so they both need to have the same type
04:35:49 <Fuuzetsu> yeah, I know, just trying to go past the kind of
04:36:03 <Fuuzetsu> right
04:36:12 <prophile> then infinite loops so can produce anything
04:36:17 <Fuuzetsu> :t (fix flip 7 5) :: String -- woo hoo
04:36:18 <lambdabot> String
04:36:24 <Fuuzetsu> non-termination sure is great
04:36:33 <prophile> I feel like I'm teaching my grandmother to suck eggs
04:36:35 <prophile> sorry about that
04:48:12 <dv-> suck eggs?
04:48:51 <trap_exit> Alex: Out of Context for $200 please.
04:51:56 * Fuuzetsu decided to not investigate
04:52:21 <Fuuzetsu> I'm guessing when you only want shells remaining without the insides
04:58:45 <bernalex> solirc: haven't run into it, but thanks for mentioning it.
05:22:57 <Luonnon> In a library, what's the easiest way to let a user set a concrete type for a generics which will be used in several functions?  For a proof of concept design, I'm using a typeclass, but that leads to the problem of orphan instances.
05:31:44 <Fuuzetsu> that's too vague to answer
05:39:40 <jml> how can I upgrade a dependency within a cabal sandbox?
05:47:07 <patriques> I get errors installing gtk: cairo-0.13.0.0 failed during the configure step
05:47:56 <k00mi> patriques: install gtk2hs-buildtools
05:47:57 <hamishmack> patriques: Did you install gtk2hs-buildtools first?
05:48:05 <hamishmack> snap
05:48:06 <patriques> Yes I did.
05:48:22 * hackagebot smallcaps 0.5.0.0 - Flatten camel case text in LaTeX files  http://hackage.haskell.org/package/smallcaps-0.5.0.0 (StefanBerthold)
05:48:52 <k00mi> then can you build cairo and show us the error?
05:48:57 <hamishmack> Did you add it to the path? Did you install the cairo dev package for your OS ?
05:49:07 <Fuuzetsu> someone must hate camel case
05:49:07 <patriques> Bascally followed http://www.haskell.org/haskellwiki/Gtk2Hs/Mac
05:50:07 <patriques> Failed to install glib-0.13.0.1
05:50:07 <patriques> cabal: Error: some packages failed to install:
05:50:07 <patriques> cairo-0.13.0.0 failed during the configure step. The exception was:
05:50:07 <patriques> ExitFailure 1
05:51:10 <hamishmack> Normally there will be another error before that one in the log somewhere
05:52:14 <patriques> hamishmack: Well in my case there wasn´t as far as I can see
05:55:14 <hamishmack> lpaste the log if you can (it might help to see what did work even if there is no other errror)
05:56:26 <patriques> hamishmack: Well I ran: cabal install --with-gcc=gcc-4.8 gtk
05:56:42 <patriques> And I got:
05:56:44 <patriques> Resolving dependencies...
05:56:44 <patriques> [1 of 2] Compiling SetupWrapper     ( /var/folders/lk/5y917sd55lx3hbp_5r5vmklc0000gn/T/cairo-0.13.0.0-892/cairo-0.13.0.0/SetupWrapper.hs, /var/folders/lk/5y917sd55lx3hbp_5r5vmklc0000gn/T/cairo-0.13.0.0-892/cairo-0.13.0.0/dist/setup/SetupWrapper.o )
05:56:44 <patriques>     Module
05:56:44 <patriques>     `Distribution.Simple.Configure'
05:56:44 <patriques>     does not export
05:56:44 <patriques>     `configCompilerEx'
05:56:45 <patriques> Failed to install cairo-0.13.0.0
05:56:45 <patriques> [1 of 2] Compiling SetupWrapper     ( /var/folders/lk/5y917sd55lx3hbp_5r5vmklc0000gn/T/glib-0.13.0.1-892/glib-0.13.0.1/SetupWrapper.hs, /var/folders/lk/5y917sd55lx3hbp_5r5vmklc0000gn/T/glib-0.13.0.1-892/glib-0.13.0.1/dist/setup/SetupWrapper.o )
05:56:46 <patriques>     Module
05:56:47 <patriques>     `Distribution.Simple.Configure'
05:56:47 <patriques>     does not export
05:56:48 <patriques>     `configCompilerEx'
05:56:48 <patriques> Failed to install glib-0.13.0.1
05:56:49 <patriques> cabal: Error: some packages failed to install:
05:58:04 <Fuuzetsu> wow there
05:58:05 <mcjohnalds> I'm getting a ton of linker errors like `undefined reference to wxMenuBar_SetLabelTop` when compiling a simple wx program with wx 3.0 in haskell, anyone know how to find out what's going on?
05:58:08 <Fuuzetsu> @where lpaste
05:58:08 <lambdabot> http://lpaste.net/new/haskell
05:58:23 * hackagebot atmos 0.2.0.0 - 1976 US Standard Atmosphere  http://hackage.haskell.org/package/atmos-0.2.0.0 (GregHorn)
05:58:25 * hackagebot atmos-dimensional 0.1.2 - dimensional wrapper on atmos package  http://hackage.haskell.org/package/atmos-dimensional-0.1.2 (GregHorn)
05:58:27 * hackagebot atmos-dimensional-tf 0.1.2 - dimensional-tf wrapper on atmos package  http://hackage.haskell.org/package/atmos-dimensional-tf-0.1.2 (GregHorn)
05:59:25 <hamishmack> patriques: Run “cabal install Cabal” then try again
06:00:43 <patriques> hamishmack: Ok, Ill try...
06:07:12 <patriques> hamishmack: still get the same error.. Im trying to install the cairo dev package with macports now. Do you think it might help?
06:07:40 <hamishmack> is it still complaining about configCompilerEx ?
06:08:17 <hamishmack> If so what version of Cabal do you see when you run ghc-pkg list
06:08:21 <patriques> Yes
06:08:55 <patriques> Cabal-1.20.0.1
06:08:55 <patriques>    Cabal-1.20.0.2
06:09:00 <sylar> what to do about the RAM consumption when I do putWAVEfile
06:09:02 <sylar> ?
06:11:17 <sylar> I have a big wave file, and the putWAVEfile use too much RAM
06:11:43 <sylar> several times more than the wav file size
06:11:52 <hamishmack> patriques: That error (about configCompilerEx) normally means it is building Setup.hs with an older version of Cabal
06:11:55 <sylar> and it reach the limit for my system
06:12:07 <hamishmack> Can you use lpaste.net to send the full log?
06:13:13 <patriques> http://lpaste.net/109476
06:13:20 <sylar> who?
06:15:53 <hamishmack> patriques: Is that in a sandbox?
06:16:10 <patriques> No, I don´t think so?
06:16:18 <hamishmack> cool
06:18:05 <hamishmack> patriques: Can you add -v and send the log again?
06:19:14 <patriques> hamishmack: Sure
06:19:34 <patriques> http://lpaste.net/109476
06:20:53 <hamishmack> hmmm cabal-install might need updating too
06:21:33 <hamishmack> That log shows it is still using the old Cabal to build Setup.hs
06:21:43 <patriques> hamishmack: Ok ill try that too. Thanks for helping me
06:21:50 <hamishmack> The bit where it passed “-package Cabal-1.16.0”
06:22:44 <patriques> Aha, so therefore you think it needs new version of cabal-install
06:22:46 <hamishmack> cabal install cabal-install and make sure the correct version of “cabal” is in your path.
06:22:55 <patriques> Yes
06:23:23 <hexagoxel> sylar: are you sure that it is putWaveFile that has high mem usage? also, it is important that you don't prevent garbage collection of the data if possible. can you show the code you use?
06:23:40 <hamishmack> There must be a reason it is not using Cabal-1.20 and that is the only thing I can think of
06:23:41 <Fuuzetsu> hamishmack: you're sending triples of INFORMATION SEPARATOR FOUR
06:24:21 <Exio4> what is the common approach when you have a "shared" datatype(s) over modules? just a new module that contains it/them?
06:24:34 <Fuuzetsu> Exio4: yes
06:24:44 <Fuuzetsu> whether we're happy with that or not
06:24:54 <patriques> hamishmack: BTW, In my .profile I have the path to the Library and so on, but how can I make sure the PATH points to the right Cabal?
06:25:48 <Exio4> kk, thanks
06:27:10 <hexagoxel> patriques: cabal --version
06:34:22 <patriques> hexagonel: you mean I should write like cabal --version and specify the version when I install. Currently I have cabal-install version 1.16.0.2
06:35:26 <patriques> hexagoxel: you mean I should write like cabal --version and specify the version when I install. Currently I have cabal-install version 1.16.0.2
06:35:35 <hexagoxel> no; you can query the version of the installed cabal with that command
06:36:12 <hexagoxel> if you have multiple versions installed, this can show you which gets called as well
06:36:59 <patriques> Oh, yeah I know. Well it is as hamishmack says the wrong version. But I dont know how to point it to the newer version.
06:37:33 <hexagoxel> are you sure that the correct one is the first in $PATH?
06:37:41 <hexagoxel> also, you mgiht wanna do "hash -r"
06:38:30 * hackagebot ehs 0.1.0.0 - embedded Haskell by using quasiquotes.  http://hackage.haskell.org/package/ehs-0.1.0.0 (minpou)
06:39:10 <patriques> I have only this in my .profile "export PATH=$HOME/Library/Haskell/bin:$PATH"
06:39:37 <patriques> related to haskell
06:39:41 <patriques> that is
06:40:37 <hexagoxel> and the "correct" cabal executable is in a different path?
06:42:17 <patriques> hexagoxel: no I dont have any PATH to the cabal executable.
06:43:55 <patriques> hexagoxel: but this might be done from the  ~/.cabal/config
06:44:52 <hexagoxel> patriques: ~/.cabal/bin/cabal --version
06:45:08 <hexagoxel> gives new version?
06:45:49 <patriques> gives: no such file or directory: /Users/patriknygren/.cabal/bin/cabal
06:46:15 <geekosaur> hexagoxel, it'd be ~/Library/Haskell/bin/cabal on OS X
06:46:21 <geekosaur> also patriques ^^
06:46:46 <patriques> geekosaur: Thanks!
06:46:47 <hexagoxel> oh, oops
06:46:58 <geekosaur> unless they still haven't fixed the problem with stuff not getting copied/linked/whatever into that directory from the package private bin...
06:47:02 <patriques> hexagoxel: Yes that gives the new version
06:47:31 <geekosaur> hash -r
06:48:24 <vektor_> What's the difference between "let A; B in C" and "let A in (let B in C)"?
06:48:40 <Fuuzetsu> one is ugly and one is not
06:48:44 <geekosaur> vektor_, the former can be a mutually recursive group
06:49:06 <geekosaur> (which in a lazy language can actually be useful if you do it right)
06:49:28 <hexagoxel> and use "echo $PATH" to make sure PATH is correct
06:49:37 <vektor_> Ahh, ok.
06:52:10 <patriques> Oh the PATH does not show up. Thats weird
06:55:21 <patriques> hexagoxel: But how can it not show up when it finds the cabal?
06:56:16 <vektor_> I'm working on a reduced subset of the haskell language (pretty straightforward stuff for the most part). I don't want to butcher the language, but I don't really think pattern-matching is too essential. Right? Whereas let..in.. is, even if I allow definition of an arbitrary number of functions, right?
06:56:51 <hexagoxel> patriques: .profile normally is processed only when you log in. did you change it during this session?
06:56:58 <vektor_> but in that case, I think I don't need let A;B in C, but let A in B will suffice... right?
06:57:24 <hexagoxel> (although i am not completly sure how osx handles this stuff)
06:57:53 <patriques> Well I have quitted on the my zshell every time I changed the PATH
06:58:09 <patriques> And restarted to get the effects
06:59:04 <btcNeverSleeps> I've got a working Haskell install on Debian Wheezy and now try to install a new Haskell development environment on a stock Debian Jessie and it's hell. I'm
06:59:14 <geekosaur> vektor_, if it's a lazy language, pattern matching is how you get strictness
06:59:30 <btcNeverSleeps> I'm trying to follow this: http://tim.dysinger.net/posts/2014-02-18-haskell-with-emacs.html   but it fails when I try to do "cabal install cabal-install"
07:00:05 <vektor_> strictness?
07:00:13 <btcNeverSleeps> what does "cabal update" do?  It apparently creates a ~/.cabal/ dir right!?  Can I safely delete that ~/.cabal/ dir and try again?
07:00:19 <silver> pattern matching is essential for me
07:00:20 <patriques> When I run ~/Library/Haskell/bin/cabal --version
07:00:20 <patriques> I get: cabal-install version 1.20.0.2
07:00:35 <btcNeverSleeps> patriques: OS X?  (Linux here)
07:00:42 <patriques> Yes
07:01:19 <patriques> But when I run "cabal --version" : cabal-install version 1.16.0.2
07:01:19 <patriques> using version 1.16.0 of the Cabal library
07:02:03 <btcNeverSleeps> "which cabal" gives me /usr/bin/cabal and "cabal-version" gives:   1.20.0.3  using version 1.20.0.2 of the Cabal library
07:02:09 <geekosaur> patriques: echo $PATH
07:02:29 <patriques> which cabal
07:02:49 <patriques> gives: /usr/bin/cabal
07:03:26 <btcNeverSleeps> am I correct in my understanding that "cabal update" goes to hackage to find the packages list?
07:03:38 <btcNeverSleeps> (and by doing so creates a ~/.cabal/ dir)
07:03:39 <patriques> geekosaur: echo $PATH does not show the expected $HOME/Library/Haskell/bin
07:04:48 <geekosaur> that's what I figured. youll need to figure out which of your dotfiles are setting $PATH and preferably get it down to one which does the right thing
07:04:55 <patriques> btcNeverSleeps
07:04:55 <patriques> btcNeverSleeps
07:04:55 <patriques> btcNeverSleeps: I think so
07:05:17 * geekosaur has to duck out for a bit...
07:05:51 <patriques> geekosaur: Allright. Ill figure it out somehow. Thanks for you help.
07:06:24 <btcNeverSleeps> "cabal install cabal-install" says: "There are files missing in the `parsec-3.1.5' package," but apparently Cabal is still building.   And "ghc-pkg check" reports issues with several packages.  I don't understand what is going on.
07:07:10 <btcNeverSleeps> should I try the latest "Haskell platform" instead?  Would that solve these "packages" issues?
07:08:23 <btcNeverSleeps> "ExitFailure 1    network-2.5.0.0 failed during the building phase"
07:08:41 <NikolajK> :t ( (\n->n+1)::(((->) Int) Int) )
07:08:42 <lambdabot> Int -> Int
07:08:54 <NikolajK> why does lambdabot reduce this and ghci doesn't
07:09:06 <NikolajK> it returns "( (\n->n+1)::(((->) Int) Int) ) :: (->) Int Int"
07:13:34 * hackagebot network-fancy 0.1.5.2 - Networking support with a cleaner API  http://hackage.haskell.org/package/network-fancy-0.1.5.2 (TaruKarttunen)
07:14:26 <taruti> please bug me if there are issues with the new version of network-fancy, just fixed it to get things compiling for new GHC.
07:25:53 <amf> how do i combine multiple already defined complex types under one type? so i can do the following
07:26:09 <amf> parseAllLogTypes :: Parser AllLogTypes
07:26:24 <amf> parseAllLogTypes = try parseThis <|> parseThat
07:27:56 <Fuuzetsu> amf: Left <$> (try parseThis) <|> Right <$> parseThat
07:28:10 <Fuuzetsu> well, guess those parens can be dropped
07:28:55 <amf> how would AllLogTypes be defined?
07:29:28 <Fuuzetsu> type AllLogTypes = Either ParseThisType ParseThatType
07:29:49 <sylar> hexagoxel, I just did:
07:29:54 <amf> and what about expanding it to more than 2?
07:29:57 <Fuuzetsu> (bar the Parser wrapper around inner typse)
07:30:06 <sylar> 1) wave <- getWAVEFile "filename.wav"
07:30:08 <sylar> and
07:30:27 <Fuuzetsu> amf: you'll need a type which handles more than just two
07:30:36 <sylar> 2) putWAVEFile "filename2.wav" wave
07:30:49 <sylar> where filename.wav is about 400MB
07:31:33 <Fuuzetsu> amf: if you're doing this then you either want a better-named type than Either/ThreeElems/FourElems &c OR your implementation needs rethinking
07:31:57 <amf> Fuuzetsu: thats the part im having trouble with. i have multiple parsers defined for very different log types, and want to put them all under one parser
07:32:26 <Fuuzetsu> amf: data LogType = …
07:32:39 <Fuuzetsu> then you end up with Parser LogType for that whole function
07:33:27 <sylar> hexagoxel, and the ram usage grew I think by 2GB
07:33:30 <Fuuzetsu> under LogType you just have constructors for each log you're might be parsing out
07:34:00 <Fuuzetsu> s/you're/you/
07:34:15 <amf> i have data LogType = SLT SomeLogType | OLT OtherType, but when i use LogType the compiler says its expecting SomeLogType and not LogType
07:35:07 <Fuuzetsu> at this stage you'll have to show me your code, I only have a rough guess of what the problem is
07:35:25 <amf> ok let me see if i can reduce it
07:36:32 * Fuuzetsu imagines you might figure it one while you try to reduce it
07:38:31 <jonathan1> Hi. I need a way to define functions at runtime, how would I do that? The XMonad window manager is an example that does pretty much what I need: it's config file is pure haskell code, that is parsed when the manager starts. Anyone have an idea?
07:38:44 <jonathan1> its*
07:39:02 <geekosaur> xmonad does not define functions at runtime. mod-q compiles a whole new program and exec()s it
07:39:05 <Minoru> jonathan1: it isn't parsed when the WM starts
07:39:30 <hpc> perhaps you can give us the specific issue you are trying to solve?
07:39:45 <jonathan1> really? then it does it really really fast :P
07:39:53 <geekosaur> usually it's fairly fast, yes
07:39:55 <hpc> almost always, code generation at runtime is complete overkill and you can get away with plain old higher order functions
07:40:13 <geekosaur> if you have my config and works in progress, it can take a while :)
07:40:35 <amf> Fuuzetsu: http://lpaste.net/3407863207128203264
07:40:45 <jonathan1> well, thank you for the help then
07:41:38 <Fuuzetsu> amf: add error message please
07:42:34 <Fuuzetsu> amf: you're omitting functions and types which actually matter ;P
07:43:12 <Fuuzetsu> amf: I'm guessing you should change parseLogTypes =  try parseThisLogRow <|> try parseThatLogRow <|> parseAnotherLogRow
07:43:46 <Fuuzetsu> to ‘parseLogTypes =  TLR <$> try parseThisLogRow <|> HLR <$> try parseThatLogRow <|> ALR <$> parseAnotherLogRow’
07:44:13 <amf> updated with errors at the end
07:44:30 <Fuuzetsu> yeah, that confirms what I just said
07:44:40 <amf> ok cool let me give it a whirl
07:45:26 <Fuuzetsu> your parsers are of types like ‘Parser ThatLongRow’ and ‘Parser ThisLongRow’ but you need ‘Parser LogTypes’, so you need to actually apply LogTypes constructor to make a LogType
07:45:56 <amf> shazam! that was it... thank you so much!
07:46:54 <Fuuzetsu> no problem; in the future try to include the types of functions in question, makes it much easier to help
07:47:41 <monochrom> you must always obey types
07:47:56 <Fuuzetsu> types are great
07:48:26 <Fuuzetsu> unless you stick undefined everywhere…
07:48:47 * Fuuzetsu compiled and tried to use a library with ~80 uses of undefined todaya
07:48:51 <Fuuzetsu> it did not work out well
07:49:09 <monochrom> that must be like 80 TODOs :)
07:49:18 <Fuuzetsu> yeah, that's pretty much eat
07:49:19 <Fuuzetsu> it*
07:49:25 <Fuuzetsu> sorry, looking at plate of food
07:50:02 <Fuuzetsu> to give it some credit though, it didn't just shut down and stop, it kept going
07:51:28 <Fuuzetsu> @src error
07:51:28 <lambdabot> error s = throw (ErrorCall s)
07:51:55 <Fuuzetsu> unchecked exceptions are the devil
07:58:42 <osfameron> so.  I'm doing a talk about zippers in Perl, and wanted to use a data structure of Donald Duck -> Scrooge (uncle relationship)
07:58:49 <osfameron> I've extended to:  Huey -> Donald -> Scrooge
07:59:02 <osfameron> and suddenly realised that my sample code:  $huey->zip  was more appropriate than expected
07:59:05 <osfameron> serendipity++
07:59:54 <hpc> Bareword "serendipity" not allowed
08:00:29 <osfameron> heh
08:03:35 <Fuuzetsu> osfameron: you mean zippers as in the data structure?
08:03:57 <Fuuzetsu> does that even lend itself well to languages with mutation?
08:05:08 <osfameron> Fuuzetsu: if you're doing immutable-style code, yes
08:05:41 <osfameron> obviously, there are fewer *guarantees* that someone isn't going to mess you up.  But there are pragmas and conventions you can use to minimize that
08:06:16 <osfameron> also, the zipper API is actually quite convenient, and can lead to quite nice looking code for manipulating a data structure (even if it turned out that the implementation was just doing mutation behind the scenes)
08:06:30 <osfameron> (though I'm specifically talking about an immutable zipper)
08:07:11 <hpc> if nothing else, an immutable zipper holding mutable elements is convenient
08:08:15 * hpc is a fan of closing over mutable variables
08:12:57 <EvanR__> hehe the redis documentation: "It is possible for an infinite number of clients to iterate the same collection at the same time"
08:13:11 <EvanR__> there is a lot of language like this, distracting
08:13:38 <hpc> if an infinite amount of monkeys write an infinite amount of documentation, can mongodb still be made webscale?
08:14:44 <SaBer> you could probably just make a seach and replace for infinite -> unlimited :)
08:14:53 <zomg> hpc: depends on if the monkeys are also highly trained and highly paid 10gen consultants
08:15:16 <EvanR__> this is the first case of infinite used like this, theres other non-precise epic-sounding jargon
08:15:35 <hpc> you just turn it on and it scales right up!
08:16:01 <hpc> it's amazing how much glitter people think they need to put on a distributed string store
08:16:27 <EvanR__> it makes me think that no matter how well designed i make a project, all i need is a markdown renderer with bootstrap styling to get accepted
08:16:47 <EvanR__> and a logo
08:22:29 <Philippa> EvanR__: I have to admit, I'm wary of anything like that using "infinite" in place of "unbounded"...
08:22:55 <NikolajK> If I define a class, like "class foobar where …" is that which follos after the were always just functions?
08:23:22 <EvanR__> im trying to figure out a good way to set up and query this problem, with a set of records (id, start, end), and a time x, what are all the ids where x is between start and end
08:23:32 <EvanR__> Philippa: right and it isnt even unbounded
08:23:37 <Philippa> NikolajK: it used to be, there are some GHC extensions that allow (IIRC) type families
08:23:57 <NikolajK> what are (IIRC) type families?
08:24:03 <Philippa> EvanR__: Real computers in not offering light-years of tape shocker!
08:24:15 <Philippa> NikolajK: sorry, the (IIRC) was "(If I Recall Correctly)"
08:24:32 <Philippa> my bad, can see how that's confusing!
08:24:51 <EvanR__> you cant even connect more than x thousand clients to a thing
08:25:38 <monochrom> laypeople have real troubles distinguishing the infinite from the unlimited
08:25:53 <Fuuzetsu> -XIIRCTypeFamilies
08:35:16 <NikolajK> :t ( (\_->1((->) Int) Char) )
08:35:18 <lambdabot> parse error on input ‘->’
08:35:26 <NikolajK> :t ( (\n->n+1((->) Char) Int) )
08:35:27 <lambdabot> parse error on input ‘->’
08:35:43 <NikolajK> :t ( (\_->1((->) Char) Int) )
08:35:45 <lambdabot> parse error on input ‘->’
08:35:52 <NikolajK> t ( (\_->1::((->) Int) Char) )
08:36:02 <NikolajK> sorry
08:37:55 <vanila> :k (->) Int Char
08:37:56 <lambdabot> *
08:46:55 <fread2282> agda does recursive search for instance arguments in HEAD :D
08:47:47 <vanila> what does that let you do?
08:48:46 <fread2282> haskell typeclasses as records + instance arguments (instance arguments are like implicit arguments but they also look for definitions of the needed type)
08:49:49 <vanila> cool!
08:50:11 <fread2282> actually looks like it's in 2.4.0.2
08:51:08 <fread2282> *2.4.2
08:51:58 <fread2282> (which isn't released yet. so HEAD)
09:29:28 <fizbin> @hoogle swap
09:29:30 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
09:29:30 <lambdabot> Control.Concurrent.MVar swapMVar :: MVar a -> a -> IO a
09:29:30 <lambdabot> Graphics.UI.GLUT.Window swapBuffers :: IO ()
09:36:20 <c_wraith> :t swap
09:36:21 <lambdabot> (a, b) -> (b, a)
09:36:38 <oliffia> is there a way to use a local cabal package as a dependency?
09:36:54 <oliffia> i want do develop a library alongside an application
09:37:01 <hpc> yes
09:37:23 <hpc> it should be add-source iirc
09:37:33 <hpc> oh, that's cabal-dev
09:37:39 <c_wraith> or a cabal sandbox
09:38:09 <hpc> gah, i keep forgetting i use an old cabal
09:40:26 <NikolajK> A priori, is I instantiate a member of Eq, the relation x == y     =  http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:not (x /= y)
09:40:26 <NikolajK>  doesn't have to be satisfied, right?
09:40:54 <NikolajK> I'm confused because the reference I look at writes it into the class definiton of Eq, while Functor only mentions the type of fmap
09:41:11 <NikolajK> as constraint
09:42:24 <c_wraith> NikolajK: I'm not sure what you're asking.  Are you talking about properties of implementations, or how type signatures are written?
09:42:46 <NikolajK> I constrast
09:42:46 <NikolajK> class http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq a  where
09:42:46 <NikolajK>    (==), (/=) :: a -> a -> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Bool
09:42:46 <NikolajK>    x /= y     =  http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:not (x == y)
09:42:46 <NikolajK>    x == y     =  http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:not (x /= y)
09:42:46 <NikolajK>  
09:42:46 <NikolajK> with
09:42:47 <NikolajK> class  http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Functor f  where
09:42:47 <NikolajK>     http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:fmap :: (a -> b) -> (f a -> f b)
09:42:56 <oliffia> so its not as simple as running cabal install on the library? my other project still cant find it
09:43:04 <NikolajK> in Functor, it only requires fmap has a certain type
09:43:19 <NikolajK> while in Eq there is more information - at least according to these examples on the wiki
09:43:31 <oliffia> oh i didnt have it set as a library in cabal
09:43:35 <c_wraith> NikolajK: there's a law for fmap, too.  fmap id is the same as id
09:43:36 <bennofs> NikolajK: that's not a requirement, it's providing default definitions
09:43:55 <bennofs> NikolajK: but instances should nevertheless satisfy the law if they provide a definition for both methods
09:44:03 <NikolajK> okay, so those default definiton could also be ignored
09:44:10 <NikolajK> or just overwritten?
09:44:11 <bennofs> NikolajK: (but that is not checked by the compiler)
09:44:22 <c_wraith> overwritten is more accurate
09:44:56 <NikolajK> so if I write an instance for Eq, and then use ==, it would just use the default because "why not"?
09:45:13 <c_wraith> depends on the instance you write.
09:45:21 <bennofs> NikolajK: if you don't supply a definition for (==) in your instance, then yes
09:45:33 <NikolajK> what would be an alternative definition?
09:45:43 <NikolajK> explicitly write it down for all terms?
09:45:59 <NikolajK> "myTerm1 == myTerm2 = False"
09:46:21 <eacameron> how would I go about writing a *lazy* version of sequence. `take 5 <$> sequence actions` runs ALL actions before returning the first 5. I want it to only run 5 actions.
09:46:40 <NikolajK> the default is just there so you must only write one of the two, right?
09:46:49 <copumpkin> eacameron: for a particular monad?
09:46:50 <bennofs> NikolajK: yes. If your type contains other types that have an eq instance, you can also use that instance in your definition. So for example, if you have data Foo = Foo Int Int, you could write instance Eq Foo where Foo a b == Foo c d = a == c && b == d
09:46:54 <c_wraith> eacameron: you can't really write a lazy version of sequence in general.
09:46:54 <bennofs> NikolajK: yes
09:46:55 <copumpkin> eacameron: not generally possible
09:47:00 <eacameron> copumpkin: IO monad
09:47:16 <copumpkin> you can write a lazy sequence for IO using unsafeInterleaveIO, but it sounds scary
09:47:26 <c_wraith> aaaaah.  you could write unsafeInterleavedSequence :: [IO a] -> IO [a]
09:48:07 <eacameron> c_wraith: my problem is not wroth an unsafeInterleaveIO, so I need to embed the "take 5" into some IO function...
09:48:30 <c_wraith> eacameron: then you're manually fusing sequence and take.  Unfortunate, but how things work.
09:48:44 <eacameron> although it sounds like something Conduit could do
09:48:56 * hackagebot network-uri 2.6.0.0 - URI manipulation  http://hackage.haskell.org/package/network-uri-2.6.0.0 (JohanTibell)
09:49:01 <eacameron> probably because of yield
09:49:12 <c_wraith> conduit can do it because it never uses anything like sequence
09:49:23 <eacameron> c_wraith: good point
09:50:08 <eacameron> c_wraith: so I guess that would be lazy IO, huh. Does readFile use unsafeInterleaveIO then?
09:50:23 <c_wraith> readFile does use unsafeInterleaveIO
09:50:30 <eacameron> c_wraith: OH
09:50:40 <eacameron> c_wraith: it's all coming together ;)
09:51:15 <c_wraith> eacameron: unsafeInterleaveIO is the basis for all "lazy IO"
09:51:28 <eacameron> now it's really all coming together
09:53:56 * hackagebot network 2.6.0.0 - Low-level networking interface  http://hackage.haskell.org/package/network-2.6.0.0 (JohanTibell)
10:01:55 <{AS}> Hi, is there a functor instance (Functor f, Functor g) => Functor (f (g a)) somewhere?
10:02:16 <glguy> Data.Functor.Compose
10:02:20 <{AS}> glguy: Thanks
10:02:21 <glguy> You'll need a newtype
10:02:43 <{AS}> glguy: why? just curious
10:03:11 <vanila> (f (g a)) has kind *
10:03:11 <glguy> Because "class Functor (f :: * -> *)"
10:03:23 <glguy> so you need to identify some "f" with that kind
10:03:35 <glguy> Compose f g :: * -> *, so that works
10:03:43 <{AS}> Ah, thanks
10:03:53 <glguy> newtype Compose f g a = Compose {getCompose :: f (g a)}
10:04:27 <glguy> without the newtype fmap on f (g a) would give you:     fmap :: (g a -> b) -> f (g a) -> f b
10:04:28 <frerich_> Is there some TH-based function which can generate catamorphisms for me, e.g. given ‘data X = A Int | B -> Bool’, I could run ‘makeCata [``X]’ and get ‘cataX :: (Int -> a) -> (Bool -> a) -> X -> a’ defined?
10:05:00 <glguy> You can do that with lens and the Plated class
10:05:09 <glguy> which generates for free using syb
10:06:35 <frerich_> (meant ‘data X = A Int | B Bool’ of course...)
10:06:59 <glguy> The plated solution is more for recursive cases
10:07:06 <glguy> now that I look at what you have
10:07:40 <glguy> frerich_: If you haven't done much TH, learning how to write that function in TH would be a fun exercise
10:07:50 <frerich_> Maybe it makes more sense for recursive cases anyway. It’s just that I recently learned about catamorphisms and noticed that they are quite useful, but to be fair they seemed to be *mostly* useful for recursive data structures.
10:08:28 <glguy> What I was getting to is that there is a function" para :: Plated a => (a -> [r] -> r) -> a -> r "
10:09:29 <{AS}> A catamorphism is like an elimination rule, right?
10:11:52 <frerich_> glguy: Given that I never actually did anything with TH, other than using it to generate code for me, I’ll indeed give it a shot myself :-)
10:19:01 * hackagebot cabal-bounds 0.8.4 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8.4 (DanielTrstenjak)
10:20:45 <oliffia> No instance for (Goal g0) arising from a use of `mkUpdater' <-- could this happen if there are no instances of `Goal' period?
10:24:19 <oliffia> looks like that was the cause indeed
10:30:13 <jml> is there something I can read about the motivation behind the switch from Control.Monad.Error to Control.Monad.Except?
10:32:18 <geekosaur> discussion on the libraries list, I think
10:34:29 <jml> geekosaur: thanks
10:46:38 <KorriX> Hello! Is there a feature that would allow to create polymorphic data constructor and pattern match on it?
10:47:25 <hpc> what type do you want it to have?
10:48:21 <{AS}> You could use Typeable
10:59:44 <KorriX> I'd like to have sth like this: http://lpaste.net/109489
11:00:14 <Ankhers> Which of these would be considered to be better / best practice? http://lpaste.net/109488
11:00:55 <KorriX> Ankhers: For me the third one. Is easiest to read
11:01:04 <ReinH> KorriX: 1 or 3
11:01:14 <ReinH> er Ankhers
11:01:44 <Ankhers> KorriX, ReinH: Thanks.
11:01:49 <Hafydd> 1, or:
11:01:49 <Hafydd> data Foo
11:01:50 <Hafydd>   = Bar
11:01:50 <Hafydd>   | Baz
11:01:50 <Hafydd>   | Quux
11:01:59 <mister_integer> Is it possible to compose multiple "instances" or layers of a single monad transformer?
11:02:03 <ReinH> 3 is fine
11:02:07 <Hafydd> But usually 1 when they are unary constructors.
11:02:31 <mister_integer> For example, if I wanted to log output to two different streams or lists of strings, using two copies of a WriterT
11:02:51 <mister_integer> Or read from two different environments with two ReaderT instances
11:03:58 <_d3f> I have a question concerning "longest common sequences" - My code hangs on some inputs, maybe anyone can look at it:http://sprunge.us/BAYE?haskell
11:04:08 * hackagebot happy-meta 0.2.0.7 - Quasi-quoter for Happy parsers  http://hackage.haskell.org/package/happy-meta-0.2.0.7 (JonasDuregard)
11:04:10 * hackagebot alex-meta 0.3.0.7 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.3.0.7 (JonasDuregard)
11:04:33 <_d3f> for example lcommonseq ["u3248973reftg9ewf","94tfg3jreu89iftg43re"]
11:04:55 <_d3f> takes _very long_ to calculater
11:05:32 <_d3f> (idk if it hangs in a loop) - haven't finished here yet
11:08:16 <ChristianS> _d3f: length is linear to the length of the list so it's not a good idea to call it repeatedly
11:09:07 <ChristianS> _d3f: you could calculate lenXs = length xs once and then just pass lenXs - 1 along if you strip the first element
11:09:44 <_d3f> I will try to do so, thx :)
11:13:12 <eitan_chatav> A friend just posted: "haskell is a little weird, it computes 10000 factorial instantly (product [1..10000]), but try to compute the length of [1..10000000000]? ...and gchi just consumed over 26 gb of memory (and didn't finish soon enough for me not to klll it so I could have all my ram back)"
11:13:41 <eitan_chatav> so...what is the best way to calculate this length efficiently?
11:13:50 <eitan_chatav> I tried using Array
11:14:19 <eitan_chatav> since Arrays define their bounds
11:14:25 <eitan_chatav> but it was still too slow
11:14:32 <Jafet> Tell your "friend" to compile the program with ghc.
11:14:40 <eitan_chatav> :-)
11:14:42 <hpc> > foldl' (*) 1 [1..10000000000]
11:14:46 <lambdabot>  mueval-core: Time limit exceeded
11:14:54 <Philippa> 10B element containers will run slowly on most systems, on account of not fitting in memory
11:15:17 <hpc> Philippa: the whole thing isn't in memory at once
11:15:17 <stew> eitan_chatav: the best way to calculate the length is 10000000000 - 1
11:15:30 <stew> oh that's probably off by one though
11:15:33 <Jafet> No, you should not use a way that gives the wrong answer
11:15:33 <drawesome> > product [1..100]
11:15:34 <eitan_chatav> off by 1
11:15:36 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
11:16:02 <Philippa> hpc: well no, I'd hope length [1..10000000000] actually ran moderately quickly on account of nothing else using the list, but hey
11:16:21 <hpc> doh, i misread that it was length, not product
11:16:24 <geekosaur> ghci is not optimized, it's creating and throwing stuff away pointlessly all over the place
11:16:28 <Philippa> (likewise, in basically constant space)
11:16:33 * hpc falls on sword
11:16:39 <drawesome> > [1..10]
11:16:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:16:50 <Philippa> (I mean sure, gen1 full of garbage...)
11:16:56 <eitan_chatav> so compiling will work better? i'll try and tell my "friend"...really...it was a friend ;-)
11:17:15 <Jafet> ghci should never use 26 GB of space for that, either, unless you assigned the list to a variable.
11:17:17 <geekosaur> usually it works better
11:17:28 <Jafet> Your friend, I mean, not you.
11:18:32 <geekosaur> hrm. just "length [1..10000000000]" at a ghci (7.6.3) prompt does misbehave a bit
11:18:38 <geekosaur> yug
11:18:42 <eitan_chatav> compiling still has it super slow
11:18:55 <Philippa> yeah, ghci's being pathologically slow on my laptop
11:19:03 <eitan_chatav> why doesn't this work?
11:19:08 <Philippa> it's enough elements I should notice the runtime, but it should've been done by now
11:19:27 <Exio4> you want a constant time length in a single linked list?
11:19:34 <Luonnon> Dumb HUnit question: When a test fails, cabal still reports the test suite as having "PASSED."  Is there any way to change this behavior, so I don't have to inspect the test log every time?
11:19:37 <eitan_chatav> uncurry (-) . bounds $ listArray (1,10000000000) [1..10000000000]
11:19:42 <Philippa> Exio4: I'm expecting a few tens of seconds
11:19:55 <Philippa> it shouldn't take /that/ long to traverse it
11:20:21 <Philippa> it's running in constant space on my laptop though
11:20:37 <drawesome> Does using :set prompt on ghci have any affect on the code being interpreted, or is it just cosmetic? I'm new to Haskell :p
11:20:54 <eitan_chatav> cosmetic
11:21:14 <Philippa> folks, I think we've got a genuinely pathological case here
11:21:17 <drawesome> Ok, thanks
11:21:31 <eitan_chatav> Philippa: how do you mean?
11:22:07 <Philippa> I mean a 1.9GHz Core i3 w/6GB of RAM and all the SSD swap it wants should've been able to /allocate/ and traverse the entire list sans GC if it really wanted to in rather less time than now
11:22:29 <eitan_chatav> ghci or ghc?
11:22:32 <Philippa> ghci
11:22:34 <Philippa> doesn't matter
11:22:48 <Philippa> it's been running several minutes: interpreter overhead ain't that high
11:23:01 <eitan_chatav> yeah, i was surprised too
11:23:34 <supki> Luonnon: you will need to inspect the results of the test run yourself and exit with non-zero exitcode manually in case of any errors
11:23:39 <Philippa> ... oh, right
11:23:51 * Philippa wonders which type it's using
11:23:52 <supki> Luonnon: ideally you just use something higher level like hspec, though
11:24:20 <Philippa> like, overflow on a 32-bit system might do bad things
11:24:44 <Philippa> counting the length of a 100M item list that way took longer than it "should" have too. gen 1 GC's supposed to be fast, dammit
11:25:01 <Exio4> Philippa, allocate a whole 10billion structure in ram?
11:25:11 <Luonnon> supki: Thanks for the heads up and suggestion.  Time to read up on hspec!
11:25:18 <Philippa> Exio4: welcome to lazy evaluation - length doesn't ever need the whole structure at once
11:25:28 <Philippa> (but also: with an SSD for swap, why not?)
11:25:48 <Philippa> 100M probably ought to go in less than a second
11:26:00 <Exio4> because ssd is still slow compared to ram, and i know, it doesn't need to do it :P
11:26:11 <Exio4> Philippa, real	3m32.996s
11:26:23 <Exio4> length of [1..10000000000]
11:26:39 <Philippa> *nod*. What kind of CPU? Ultrabook-grade Core chip here
11:26:56 <Philippa> (I killed mine after about 3 minutes)
11:26:57 <Exio4> FX 6100, good enough for multithreading, mid-to-low-end in singlethreading
11:28:20 <{AS}> Shouldn't deforestation make sure that nothing is allocated?
11:28:37 <Philippa> in ghci? No
11:28:46 <Philippa> you need GHC with optimisation on for that
11:28:50 <{AS}> Ah
11:29:01 <Philippa> but it shouldn't matter: 10B ain't that big a number if you're not fitting it all in RAM
11:29:20 <eitan_chatav> Philippa: how do you do that optimization?
11:30:25 <Philippa> eitan_chatav: deforestation? The basic idea is that when you've got one function that's the sole consumer of what another function produces, you can inline the producing function inside it and use simple transformations so that instead of building a data structure and doing case analysis, it jumps straight to what the consumer would do with it
11:31:03 <eitan_chatav> I just meant...o2 or what?
11:31:07 <Philippa> {AS}: the thing is, we shouldn't be seeing cons cells escaping the GC's first generation (because only length sees them) and gen1 GC should be fast
11:31:35 <Philippa> I honestly don't know, myself
11:31:41 <Philippa> I rarely need to care
11:32:58 <Philippa> {AS}: to put it another way, 10B shouldn't be that big a number when I have nearly 2B clock cycles/second :p
11:33:35 <{AS}> 10 billion in short count right?
11:33:52 <eitan_chatav> what about using arrays? how come it even bothers calculating elements of the array when it can just get its bounds?
11:34:12 <Philippa> because you don't /have/ an array until then, because that's how the primitives work
11:34:27 <kvelicka> foldl works through the list from the last element right?
11:34:29 <{AS}> I mean billion as 10^9  right?
11:34:43 <Philippa> {AS}: yeah, not that it's that big a difference
11:34:44 <{AS}> not the 10^12
11:34:47 <Philippa> oh, right
11:34:54 <Philippa> yeah, basically even most brits don't mean 10^12
11:35:04 <eitan_chatav> billiard?
11:40:13 <rhapsodhy> o/
11:42:16 <rhapsodhy> i'm trying to install yesod in a sandbox, and it fails, first with http://lpaste.net/109492 then after installing network-uri, with http://lpaste.net/109491
11:42:56 <rhapsodhy> can anyone give me some hints about this?
11:43:44 <eitan_chatav> have you tried adding `network-uri` to the cabal file?
11:43:54 <rhapsodhy> i don't have a cabal file at this point
11:44:08 <rhapsodhy> and i
11:44:14 * hackagebot hsexif 0.6.0.1 - EXIF handling library in pure Haskell  http://hackage.haskell.org/package/hsexif-0.6.0.1 (EmmanuelTouzery)
11:44:37 <rhapsodhy> eitan_chatav: and i'm not sure how to tamper into http-client's cabal file
11:45:03 <eitan_chatav> yeah...i've heard yesod is hard to build :-/
11:45:17 <eitan_chatav> trying in a sandbox now
11:46:23 <athan> I've only had it work in a sandbox, but `yesod devel` doesn't work very well, so I just stick to `./$SANDBOX_PATH/app Development`
11:52:57 <wojtekM_> Is an operator like flip ($) :: a -> (a -> b) -> b defined somewhere?
11:53:06 <athan> :t (&)
11:53:08 <lambdabot> a -> (a -> b) -> b
11:53:29 <athan> from Data.Lens I'm pretty sure, wojtekM_ :)
11:53:47 <edwardk> Control.Lens, but yes
11:54:03 <wojtekM_> OMG, Data.Lens
11:54:16 <wojtekM_> Thanks
11:54:47 <eitan_chatav> lol...depending on lens for (&)...^_^
11:55:05 <Cale> Frankly, I find (&) really questionable :P
11:55:19 <Jafet> You can simply copy the definition of & from the lens library.
11:55:26 <Jafet> I hear it's rather small.
11:55:44 <eitan_chatav> I find (>>=) questionable
11:55:44 <athan> (&) = flip ($)...?
11:55:45 <njcomsec> i heard the same thing about your dick
11:55:48 <edwardk> eitan_chatav: its in Data.Function in 7.10 or will be
11:55:49 <wojtekM_> I wanted to write code that reads from left to right:
11:55:56 <athan> eitan_chatav: lol
11:56:09 <wojtekM_> value & op1 >>> op2 >>> op3
11:56:47 <eitan_chatav> I'm a stricly right-to-left combinator kind of fellow
11:57:45 <athan> Anyone know of a good paper on data kinds?
12:00:21 <Jafet> njcomsec: it's just codata.
12:08:34 <jnoah> hey all, I'm starting to go through Real World Haskell ( http://book.realworldhaskell.org/read/ ) which discusses ghc 6.8.3. Is that still relevant, should I be aware of any modern differences?
12:09:06 <jnoah> I am running ghc 7.6.3
12:11:49 <stulli> jnoah: this SO question might be interesting to you: http://stackoverflow.com/questions/23727768/which-part-of-real-world-haskell-is-now-obsolete-or-considered-bad-practise
12:13:07 <merijn> jnoah: I would say that most of it is still relevant
12:13:44 <merijn> jnoah: Some of the examples broke due to changes and some APIs changed slightly, but I think that if you understand what the book says and then look at the current docs it should be pretty straightforward to understand things
12:14:25 <merijn> jnoah: i.e. the parsec chapter uses Parsec 2, rather than 3, 3 slightly changed the API so the examples don't run directly anymore, but the general concepts in Parsec didn't change so, if you just browse the API after the book it should make sense
12:14:26 <jnoah> stulli, merijn awesome, thank you!
12:15:03 <jnoah> I've gone through LYaH as well, so it sounds like it shouldn't be too difficult
12:15:40 <merijn> jnoah: I would take the code examples as that, examples of what real world code would look like and then just consult the API for current details
12:16:54 <Jafet> If you install ghc 6.8.3 and go to the local museum for a copy of parsec2, RWH is modern again and you can run all the examples.
12:25:46 <zugz> what's the generalisation of mapM to functors other than []?
12:26:24 <athan> zugz: I want to say <*>
12:26:26 <zugz> (and is there a way to get hoogle to answer questions like this)
12:26:37 <athan> :t mapM
12:26:38 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
12:26:46 <athan> :t (<*>)
12:26:47 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:26:51 <zugz> not quite
12:26:59 <athan> sequence, maybe?
12:27:02 <athan> :t sequence
12:27:03 <lambdabot> Monad m => [m a] -> m [a]
12:27:07 <eitan_chatav> :t traverse
12:27:07 <zugz> no, still lists
12:27:08 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
12:27:12 <zugz> that's the one!
12:27:14 <athan> There we go, haha
12:27:15 <zugz> eitan_chatav: thanks
12:27:21 <eitan_chatav> zugz: no prob ;-)
12:34:32 <merijn> zugz: There is no mapM for functors, you are probably wanting Foldable/Traversable?
12:35:13 <zugz> merijn: yes, traversable is what I wanted, thanks
12:38:09 <zennist> For pattern matching in haskell, is it possible to have an 'or' branch like in ocaml?
12:38:24 <monochrom> unfortunately no
12:38:31 <zennist> e.g., case ls of
12:38:31 <zennist>   h:t | [] -> ...
12:38:47 <heatsink> case ls of _ ->
12:38:56 <zennist> that's unfortunate.. I thought haskell should beat ocaml in every respect
12:39:00 <merijn> heatsink: That's not the same
12:39:04 <monochrom> although, the record syntax helps a bit
12:39:06 <zennist> heatsink: that was just a lame example...
12:39:09 <merijn> heatsink: That works in this trivial case, but not the others
12:39:26 <zennist> heatsink: there would be more useful scenarios for such features
12:39:36 <merijn> heatsink: In ocaml you can do case foo of 1 | 2 | 3 -> bar; 4 | 5 | 6 -> baz
12:39:37 <augur_> zennist: because your variables will usually differ in "or" cases, its probably best not to have them at all
12:39:52 <augur_> zennist: what you _can_ do is add guards
12:39:53 <merijn> augur_: They can be nice for some code
12:40:09 <heatsink> zennist: You can sort of do or-patterns with binding using view patterns
12:40:10 <augur_> merijn: yes, they can. probably view patterns can help with that
12:40:26 <monochrom> contrived example: "data M = C1 {mm::Int} | C2 {mm::Int, xx::Bool} | C3", "whee C3 = 0; whee m = mm m"
12:40:49 <zennist> augur_: consider the case where you are matching for 2 or more variables and you want to control the condition about both of their values - the 'or' feature would be pretty useful
12:40:56 <augur_> case xs of { ((`in` [1,2,3]) -> True) -> whatever ; ... }
12:41:07 <monochrom> this example mitigates the need for "whee C1 ... | C2 ... = ..."
12:41:10 <augur_> zennist: elaborate
12:41:22 <merijn> augur_: That example looks like it needs MultiWayIf :)
12:41:29 <heatsink> case ls of { Just (x, y) <- extractTwoElems ls -> ... }
12:41:36 <augur_> merijn: that too :)
12:41:47 <zennist> say you have a list and a counter, you want to give back the list if the counter reaches some value or the list is empty
12:41:50 <augur_> depends on what you're aiming for in the rest of the statement ofcourse
12:41:55 <heatsink> Eh, my syntax wasn't quite right
12:42:26 <augur_> zennist: and how would that look in ocaml
12:42:27 <darkman> did anybody do some stuff with WMFS?
12:42:31 <darkman> need help
12:42:50 <monochrom> ok, so once again people are more interested in arguing than solving.
12:43:04 <zennist> augur_: if there's 'or' then it would be simply: case ls, counter of [], _ | ls, 20 -> ls
12:43:15 <augur_> monochrom: i dont think there's any solving to be left to do, honestly
12:43:46 <augur_> zennist: thats... weird. so ls's is POSSIBLY shadowed depending on how the pattern-match goes?
12:43:58 <augur_> thats really bizarre
12:44:11 <zennist> case ls, counter of [], _ | _, 20 -> ls
12:44:13 <augur_> oh, wait, no i see what its going
12:44:17 <zennist> this is clearer then
12:44:59 <augur_> thats a weird thing to do i feel. why not just use an if statement?
12:45:19 <augur_> not that thats wrong, but it feels confusing and prone to bugs because of this weird disjunctive variable scope
12:45:29 <augur_> i guess you could make a nice explanation of how that should go tho
12:46:34 <augur_> lets see....    G !!- P pattern A    G !!- P' pattern A    ====>    G !!- P | P' pattern A
12:46:47 <monochrom> "The two sub-patterns pattern1 and pattern2 must bind exactly the same identifiers to values having the same types." from the OCaml manual
12:47:05 <augur_> where   G !!- P pattern A   is an affine proof that P is a pattern for type A in context G
12:47:36 <augur_> monochrom: yeah. i guess its not so bad
12:48:24 <monochrom> "[] | h::t" was not a legal example. however, it would be easy to correct. "[] | _::_" would be a legal example. "b as [] | _::b" would also be a legal example.
12:49:08 <monochrom> "[] | _::_" was not a pointful example. however, many data types with 3 or more branches would be pointful examples.
12:49:22 <monochrom> perhaps s/branches/variants/
12:49:32 <augur_> i guess in haskell you'd have to have a different notation since | is for guard
12:49:49 <augur_> also there arent multi-arg cases, just tuple cases, iinm
12:50:03 <zennist> monochrom: something learnt today. thank you
12:50:25 <augur_> so lets see.. maybe something like    case (ls,ctr) of  ([],_), (_,20) -> ls
12:50:25 <augur_> ?
12:51:19 <augur_> someone should add a feature request maybe!
12:51:30 <darkman> need help about WMFS2
12:58:40 <merijn> Is an insane idea to use TH to compile time check strings for restrictions before newtype wrapping?
12:59:23 * hackagebot http-client 0.3.7.1 - An HTTP client engine, intended as a base layer for more user-friendly packages.  http://hackage.haskell.org/package/http-client-0.3.7.1 (MichaelSnoyman)
12:59:52 <merijn> i.e. I have some restrictions on a string type (maximum length, allowable characters, etc.) I could define a smart constructor that returns "Maybe MyNewType", but handling the Maybe case for compile time values seems really tedious...
13:00:24 <monochrom> haha, interesting
13:01:00 <merijn> Too bad IsString isn't compile time :\
13:01:01 <monochrom> I would use quasi quotes. it's TH in theory, but much more lightweight in practice.
13:01:14 <merijn> monochrom: Sure, I was referring to quasi quotes
13:01:50 <monochrom> quasi quotes are much easier to use and reason about
13:02:11 <merijn> Do quasiquoters need to be explicitly imported? (I wanna check whether I should be careful not to collide with "common" quasiquoter names)
13:02:46 <monochrom> yes
13:03:02 <benmachine> they're values like any other
13:04:23 * hackagebot xss-sanitize 0.3.5.3 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.3.5.3 (MichaelSnoyman)
13:04:25 * hackagebot authenticate 1.3.2.10 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2.10 (MichaelSnoyman)
13:06:48 <merijn> ugh, why are Types.hs modules always such a mess? :(
13:09:24 * hackagebot yesod-form 1.3.15.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.3.15.1 (MichaelSnoyman)
13:09:26 * hackagebot yesod-auth 1.3.4.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.3.4.1 (MichaelSnoyman)
13:09:28 * hackagebot yesod-platform 1.2.13.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.13.1 (MichaelSnoyman)
13:15:12 <monochrom> the point of defining a whole bunch of types is that they represent very different things, even unrelated. putting unrelated things into the same module is bound to be incoherent.
13:16:38 <merijn> monochrom: Sure
13:16:57 <merijn> monochrom: But until GHC HQ fixes their compiler to follow the report and gives me recursive imports I have no choice
13:18:05 <monochrom> but you don't have to have a unique "types" module, do you?
13:18:37 <monochrom> you can use 5 "types" modules for 5 groups of types.
13:18:51 <merijn> There's too much overlap
13:21:42 <ayushmad> Hi I am a begineer to haskell. I was trying to solve the Project euler problem https://projecteuler.net/problem=65. My code was the following :-
13:21:45 <ayushmad> generateElement :: Int -> [a]
13:21:47 <bob`> join #cabal
13:21:47 <ayushmad> generateElement n =  solveContinuend (take n eContinuentChain)
13:21:50 <ayushmad>                        where solveContinuend = foldr1 (\acc x -> 1 % acc + x)
13:21:52 <ayushmad>                              eContinuentChain = 2:1:concat [[x, 1, 1] | x <- [2, 4..]]
13:22:43 <ayushmad> but i am getting this error:-    Occurs check: cannot construct the infinite type: a0 = Ratio a0
13:22:46 <ayushmad>     In the second argument of `(%)', namely `acc'
13:22:55 <ayushmad> please help ?
13:23:34 <heatsink> :type (%)
13:23:38 <heatsink> :t (%)
13:23:40 <lambdabot> Integral a => a -> a -> Ratio a
13:24:20 <heatsink> When you write 1 % acc , this takes 1 and acc (which are integral) and creates a ratio
13:24:43 <merijn> oh
13:24:46 <heatsink> The result is a ratio, and it's added to x to produce a ratio
13:24:54 <merijn> ayushmad: % is not actually modulo in haskell
13:24:58 <heatsink> So acc has to be an integral type, and a ratio of integral types.
13:25:00 <merijn> ayushmad: You'll want mod for that
13:25:09 <merijn> > 5 `mod` 2
13:25:11 <lambdabot>  1
13:25:32 <ayushmad> oh i wanted to use Ratio here .
13:26:08 <heatsink> What should 1 % acc do?
13:26:41 <merijn> ayushmad: Is it supposed to be (1 % acc) + x or 1 % (acc + x)?
13:26:49 <maxiepoo> so I take it you can't add things to stackage unless all of their dependencies are already there?
13:27:07 <ayushmad> merijn: I wanted to invert acc and add to x
13:27:19 <heatsink> Use / to divide
13:27:33 <ayushmad> merijn: I wanted ((1%acc) + x)
13:27:50 <heatsink> % is not a division operator.
13:28:16 <ayushmad> heatsink: But I want to solve it a float I basically want to invert the ratio
13:28:23 <heatsink> > let acc = 2 % 3 in 1 / acc + 1
13:28:25 <merijn> ayushmad: I don't know the error without the types of x and acc
13:28:25 <lambdabot>  5 % 2
13:28:55 <merijn> Is there a "case insensitive" equality/ord for ByteString?
13:29:10 <heatsink> ayushmad: I don't understand "I want to solve it a float"
13:30:32 <ayushmad> heatsink: sorry for the confusion. I want to take a float ratio in the accumulator and want to invert the ratio (basically 2%3 become 3%2) and then add it a integral number
13:32:46 <hexagoxel_> man, hlint has no feeling for symmetry
13:32:51 <heatsink> ayushmad: In a Ratio, the numerator and denominator have to be integral.  The numerator can't be 1.5 for example.
13:33:05 <ayushmad> merijn: I have dumped the program dand the error here :- http://dumptext.com/15eYWXaK
13:34:03 <heatsink> If you take a ratio of floats, then you can force the denominator to be 1 always, then you can discard the denominator, then you have a float.
13:34:34 <ayushmad> heatsink: oh ok. I don't want to make a float
13:35:15 <heatsink> 1 / x is the reciprocal of x.  It works for ratios also.
13:35:31 <ayushmad> heatsink: oh cool
13:37:07 <ayushmad> heatsink: When I change the program to a ratio I get following error :-
13:37:52 <ayushmad>     Could not deduce (a ~ Int)
13:37:52 <ayushmad>     from the context (Integral a)
13:37:52 <ayushmad>       bound by the type signature for
13:37:52 <ayushmad>                  generateElement :: Integral a => a -> Ratio a
13:37:52 <ayushmad>       at prob65.hs:10:20-45
13:37:55 <ayushmad>       `a' is a rigid type variable bound by
13:37:57 <ayushmad>           the type signature for
13:39:04 <ayushmad> heatsink: I have attached the dump here http://dumptext.com/tCfqHh9d
13:40:26 <heatsink> The error message says that you have declared the function to be polymorphic, where 'a' can stand for any integral type
13:40:42 <heatsink> you did that by writing it in the type signature for generateElement
13:40:58 <heatsink> it also says that the function will only work if a is type Int
13:41:19 <heatsink> That is a problem because a can be any type, and some types are not Int
13:41:34 <hpc> most types are not Int
13:42:19 <joelteon> almost every type isn't Int
13:42:25 <hpc> at least 90%
13:42:29 <hpc> maybe 95%
13:42:29 <heatsink> lol
13:42:36 <ayushmad> heatsink: oh ok, So if I change the type signature to generateElement :: Int a -> Ratio b
13:42:54 <merijn> <3 <3 <3 bos
13:42:58 <ion> Int does not take a type parameter.
13:42:59 <heatsink> That's not a valid type
13:43:15 <merijn> attoparsec already has case-insensitive matching for ByteString :D
13:43:16 <heatsink> The type signature also says why the current code requires a to be equal to Int
13:43:44 <heatsink> The code passes 'n' as an argument to to 'take'.  'take' requires an Int.  'n' has type 'a'.
13:43:44 <merijn> Now I just need an efficient case-insensitive map and I'm set :)
13:44:50 <merijn> Oh, wait, ByteString has no toUpper/toLower functions :\
13:45:03 <ion> merijn: In which encoding?
13:45:11 <merijn> ion: ASCII
13:45:11 <heatsink> You can fix the problem by changing the type signature, or you can fix the problem by casting from a to int.
13:45:18 <heatsink> Int.
13:45:22 <merijn> ion: Actually, probably more restricted than ASCII
13:45:43 <ion> How about if i pass it BS.pack [0xff]?
13:45:52 <merijn> ion: That's a parse error
13:46:04 <merijn> ion: The network protocol has fields define as alphanumeric ascii
13:46:14 <ion> The ByteString toUpper/toLower should return a parse error?
13:46:17 <merijn> If you pass in 0xff then parse fails and you disconnect
13:46:25 <merijn> ion: No, that value cannot get into the system
13:46:45 <merijn> ion: As I'm parsing fields that only allow a subset of ascii and I need to match those fields case insensitively
13:47:05 <merijn> So it is safe to assume 0xff can't happen by the time I lowercase
13:47:42 <ion> What i’m getting at is that toUpper/toLower in ByteString would need to make major assumptions about the contents of your byte arrays.
13:47:43 <merijn> ion: It's not like I can tell them to retroactively change the wire format to be case sensitive
13:47:50 <merijn> ion: Sure
13:47:52 <ayushmad> heatsink: I am still confused. It is possible because I have to study some more. Do you recommend any book which I should read to understand this better
13:48:04 <merijn> ion: But I can't be the first person to need to do this to a bytestring
13:48:21 <merijn> So I'm assuming SOMEONE already implemented it efficiently and I just don't know where
13:49:28 <heatsink> There are some books I can recommend for understanding Haskell or for understanding type theory.  To understand this specific problem, it would be more effective to discuss it.
13:49:58 <merijn> Well, there's the case-insensitive package, but that works by storing both the original and a case insensitive version which is rather costly in terms of space
13:50:35 <merijn> Besides I'd rather not parse and then transform, but instead just transform as I parse
13:51:04 <heatsink> ayushmad: Can you explain the following error?
13:51:18 <heatsink> > let n = 3 :: Ratio Int in take n "this"
13:51:20 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
13:51:20 <lambdabot>              with actual type ‘GHC.Real.Ratio GHC.Types.Int’
13:53:23 <merijn> oh, bollocks
13:53:31 <taruti> What is currently the preferred way of spawning a sub-process and getting the binary stdout? Is there really no ready function for this?
13:53:46 <merijn> Newer versions of attoparsec don't even have this function anymore :\
13:54:22 <athan> Hey guys, I'm trying to make a list of the factors of an integer via list comprehensions, but I'm caught in a loop. How could I rewrite this to make the comprehension... lazy...? factors n = [(n `div` d) | d <- [1..], (n `mod` d)==0]
13:54:42 <heatsink> taruti: You can use readProcess in System.Process
13:55:02 <taruti> heatsink: that fails with binary data.
13:55:08 <kqr> am I the only one who sees a weird lack of newlines in the examples here: http://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson.html
13:55:17 <heatsink> Hm
13:56:01 <taruti> "hGetContents: invalid argument (invalid byte sequence)" (handles, text mode etc)
13:56:03 <heatsink> Then I guess you would use createProcess and read from the handle
13:56:11 <heatsink> using some ByteString methods
13:57:12 <taruti> and probably forkIOs etc to handle buffering things and avoid deadlocks? ._.
13:57:30 <michaelt> athan: It keeps looking for more possible divisors; why not 'd <- [1..n]' or something
13:58:00 <heatsink> Will the subprocess wait for input?
13:58:28 <kqr> if I have a bytestring which contains a few iso-8859-1 (latin-1) characters, how can I convert it to utf-8? (which things such as aeson assume?)
13:58:47 <taruti> heatsink: thinking of whether it could write to stderr and that block if it is a pipe
13:58:56 <michaelt> > let factors n = [(n `div` d) | d <- [1..n], (n `mod` d)==0] in factors 20 -- athan
13:58:58 <lambdabot>  [20,10,5,4,2,1]
13:59:20 <ion> kqr: Data.Text.Encoding.encodeUtf8 . Data.Text.Encoding.decodeLatin1 for instance.
13:59:30 <ion> or iconv or something
13:59:30 * hackagebot aws 0.10.1 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.10.1 (AristidBreitkreuz)
13:59:40 <athan> michaelt: There you go! Sense to the rescue haha. Thanks :)
13:59:42 <taruti> oh, well readProcess just ignores stderr, I guess I can do the same.
13:59:44 <hpc> just about to say iconv
14:00:22 <hpc> ion: hotdamn that's a nice module
14:00:39 <NougatRillettes> Hi guys, I have some strange issue with binaries compiled by GHC
14:01:07 <NougatRillettes> I've written this littlep iece f code to count the numbers of words in a language modulo "is-anagram"
14:01:11 <kqr> ion, thanks
14:01:21 <NougatRillettes> and it segfaults on the 300k words input
14:01:26 <NougatRillettes> http://paste.awesom.eu/NougatRillettes/Xvuj&hl=haskell
14:02:20 <michaelt> kqr: It has an explicit character replacement scheme too, Data.Text.Encoding, though if its valid latin1 you wont need it
14:03:02 <NougatRillettes> to be precise it sometimes segfault on the input
14:04:30 * hackagebot aws 0.10.2 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.10.2 (AristidBreitkreuz)
14:08:04 <michaelt> NougatRillettes: maybe you should post the source? It could be any number of things, no?
14:08:19 <NougatRillettes> it's here : http://paste.awesom.eu/NougatRillettes/Xvuj&hl=haskell
14:09:04 <merijn> kqr: text-icu has a whole bunch of even obscurer encoding if Data.Text.Encoding isn't enough
14:11:16 <latk> Does anyone know if wreq does anything with the encoding of a page ?
14:11:29 <kqr> merijn, haha yeah, I saw that on the documentation for Data.Text.Encoding
14:11:40 <kqr> merijn, but for the time being I'm concerned with valid latin-1 to utf-8
14:11:58 <michaelt> NougatRillettes: hm, its tolerating /usr/share/dict/words fine let me try something bigger...
14:12:22 <latk> I have this situation: I have downloaded some pages using wreq. When I view them on the original server, they display correctly (using ISO-8859-1). When I view the downloaded pages in my browser with the same encoding, there are errors.
14:12:59 <NougatRillettes> michaelt: my source if you want : http://upload.kisai.info/liste.de.mots.francais.frgut.txt
14:13:04 <NougatRillettes> be careful the fiel is quite big
14:13:10 <merijn> latk: Is the the server sending the wrong mimetype?
14:13:34 <bennofs> I have a question about trifecta. In http://lpaste.net/109482, trifecta doesn't show "unexpected ..." like parsec does. Is there a way to get the parsec behaviour in trifecta? The trifecta error doesn't show at all why "else" is not a valid identifier, while the parsec error says that "else" is a reserved identifier (=> cannot be an identifier)
14:13:59 <edwardk> bennofs: put in a bug report, it is a reasonable request
14:14:11 <edwardk> github.com/ekmett/trifecta/issues
14:14:12 <michaelt> NougatRillettes: 304364 words... maybe there's some curious feature of you ghc install or something.
14:14:25 <latk> merijn: The Content-Type in the headers from chrome is ISO-8859-1 as well..
14:14:28 <bennofs> edwardk: thanks, will do. just noticed I alrady got your message. idk why lambdabot was so slow :)
14:15:09 <NougatRillettes> michaelt: does it work many time in a row ?
14:15:33 <NougatRillettes> (the bug is random on my computer, I'll try reinstalating ghc)
14:15:58 <latk> merijn: Also yeah, correct mimetype
14:15:59 <michaelt> NougatRillettes: yes, it seems fine.
14:16:10 <NougatRillettes> ok ok thx
14:18:04 <NougatRillettes> thx michaelt my ghc install was corrupt I guess becaue it's now working perfectly well
14:18:36 <michaelt> NougatRillettes: Wow, that was fast.
14:18:59 <JohnTalent> >:t <-
14:19:10 <JohnTalent> :t <-
14:19:11 <lambdabot> parse error on input ‘<-’
14:19:15 <JohnTalent> :t (<-)
14:19:17 <lambdabot> parse error on input ‘<-’
14:19:22 <NougatRillettes> yup I should have tried it first, sorry I bothered you :/
14:23:41 <mzero> JohnTalent: <- isn’t an operator, it is syntax
14:23:48 <JohnTalent> mzero: ok
14:24:29 <JohnTalent> :t d <- [1,2,3]
14:24:31 <lambdabot> <no location info>: not an expression: ‘d <- [1,2,3]’
14:25:17 <mzero> it is syntax that is part of either the list comprehension syntax, or the do syntax
14:25:18 <mzero> so
14:25:20 <JohnTalent> specifically for lisp comphrensions it seems.
14:25:46 <mzero> > [ show i ++ “ apples” | i <- [2,4..10] ]
14:25:47 <lambdabot>  <hint>:1:13: lexical error at character '\8220'
14:26:00 <mzero> > [ show i ++ “apples” | i <- [2,4..10] ]
14:26:02 <lambdabot>  <hint>:1:13: lexical error at character '\8220'
14:26:08 <mzero> bah smart quotes?!?!?!!
14:26:09 <joelteon> mzero, stop using curly quotes
14:26:28 <mzero> I just upgraded OS X and now I seem to have ‘em
14:26:47 <mzero> > [ show i ++ " apples" | i <- [2,4..10] ]
14:26:48 <JohnTalent> mzero: from linux? os x is a downgrade.
14:26:48 <mzero> there
14:26:49 <lambdabot>  ["2 apples","4 apples","6 apples","8 apples","10 apples"]
14:26:55 <mzero> or
14:28:27 <mzero> > do { putStrLn "Hello! What's your name?" ; name <- getLine ; putStrLn $ "Hello, " ++ name }
14:28:28 <lambdabot>  <IO ()>
14:28:35 <mzero> which of course, won't run in Lambda bot
14:28:45 <mzero> anyhow, JohnTalent, those are the uses of <-
14:30:08 <merijn> hmmm, binary doesn't have a way to see how many bytes a Get action consumed?
14:34:33 * hackagebot approximate-equality 1.1.0.1 - Newtype wrappers for approximate equality  http://hackage.haskell.org/package/approximate-equality-1.1.0.1 (GregoryCrosswhite)
14:36:14 <merijn> hmmm, I'm starting to understand why "be lenient what you accept" makes sense for network protocols...
14:36:29 <hpc> merijn: because NOBODY is strict in what they send
14:36:41 <frerich_> glguy: So, turns out that generating catamorphisms via TH is indeed a nice exercise. I already got it working for things like Bool, Maybe or Either :-)
14:36:41 <merijn> hpc: No
14:36:55 <merijn> hpc: Because verifying everything is horrifically slow
14:37:53 <merijn> hpc: Suppose I have an X length field which is defined to only be alphanumeric + any of "-_+." I need to scan the entire length and report and report an error
14:38:11 <hpc> that makes more sense
14:38:13 <merijn> hpc: If I just accept anything instead of just those things I can just bitblit the entire length
14:38:42 <hpc> i am more used to websites, tangled and incompetent
14:38:51 <hpc> and email, which is also brutally slow to verify but you need to do it anyway
14:39:02 <merijn> And in this case I guess the worst case is that I am accidentally compatible with people that don't follow the spec
14:39:12 <hpc> heh
14:39:22 <merijn> So I'm just gonna say "screw this" and not validate
14:39:34 * hackagebot approximate-equality 1.1.0.2 - Newtype wrappers for approximate equality  http://hackage.haskell.org/package/approximate-equality-1.1.0.2 (GregoryCrosswhite)
14:54:35 * hackagebot lojbanParser 0.1.9.2 - lojban parser  http://hackage.haskell.org/package/lojbanParser-0.1.9.2 (YoshikuniJujo)
14:56:56 <merijn> What's an efficient way of constructing a Map from a monadic action? I don't think first constructing a list and then inserting everything is gonna be very efficient, no?
14:58:46 <vanila> it may be better to just start with empty map and insert things one by one
15:04:05 <Cale> merijn: Well, there's fromList
15:04:40 <Cale> merijn: Oh, I think I see what you mean, you're worried about the space cost of the intermediate list?
15:05:03 <Cale> I suppose it could be an issue, yeah, you could just repeatedly insert.
15:06:38 <EvanR> im having a hard time determining when an intermediate lists even exists, because i heard sometimes it does not due to lazy evaluation
15:06:38 <augur> fromList just does a bunch of inserts anyway, right
15:07:34 <EvanR> fromList eventually drives the monad action lazily (unless its IO)
15:09:11 <augur> EvanR: also it might not due to fusion
15:09:17 <Cale> augur: yes
15:10:01 <EvanR> and then theres fusion, which is some other thing
15:10:01 <Cale> EvanR: Well, even if you can avoid having the entire list in memory because of lazy evaluation, there are still costs associated to allocating each cons cell.
15:10:11 <Cale> and fusion eliminates those costs
15:11:22 <Cale> Lazy evaluation reduces the total memory required over the course of the computation, but perhaps not the amount of allocation done. (Sometimes it can reduce the amount of allocation done as well, but that's when you don't need the entire structure.)
15:11:23 <EvanR> that makes sense, but this is a lot different from the equivalent concerns with intermediate lists in a regular programming language
15:11:41 <Cale> yes
15:11:53 <EvanR> where every list operation reallocates the entire list before continuing
15:12:15 <EvanR> so the difference is less total memory used at a given point in the process
15:16:21 <merijn> Cale: I'm not really happy with the code I have now either
15:17:47 <merijn> Essentially (I have this in more places) I want to build a list as I parse, but it's hard to do that efficiently in a tail recursive fashion
15:17:56 <merijn> (because of the monadic context)
15:18:49 <merijn> Right now I have something like this: http://lpaste.net/109504
15:19:14 <NougatRillettes> Does GADTs notation lower the performances of a type ? For exemple shaal I use data List a = Cons a (List a) | Nil rather than data List a where | Cons :: a -> List a -> List a | Nil :: List a ?
15:21:41 <benzrf> i think type checking is done at compile time
15:21:59 <benzrf> also i believe u dont want | there in your gadt
15:22:03 <ij> I would like to snoop on input/output of certain functions that I could lift in IO with relatively little effort/modifications to target functions or their calls. What would be a good way to do it?
15:22:25 <benzrf> ij: this is just for debugging purposes
15:22:28 <benzrf> ?
15:22:32 <benzrf> not for a real program
15:23:26 <ij> sort of
15:23:38 <benzrf> you could try debug.trace
15:23:42 <benzrf> if it doesnt offend your sensibilitie
15:23:44 <benzrf> s
15:24:16 <ij> That might do, I want to write some docs and compute out pretty pipelines of a lot of function calls.
15:24:30 <ij> data from f calls
15:25:50 <ij> Looks like trace might do the job, but is the reason for it not being production safe its slowness or something?
15:26:19 <ij> Or just bad design?
15:26:46 <merijn> ij: It abuses unsafePerformIO
15:27:14 <merijn> ij: All bets are off, it "safe enough" to use for debugging, but not designed or tested for anything else
15:27:32 <ij> Any predictions of what might go wrong?
15:28:35 <merijn> Things maybe printed multiple times, things might be printed only once even if run multiple times
15:31:46 <Exio4> isn't trace just unsafePerformIO + putStrLn + id?
15:31:50 <Exio4> @src trace
15:31:50 <lambdabot> trace string expr = unsafePerformIO $ do
15:31:51 <lambdabot>     hPutStrLn stderr string
15:31:51 <lambdabot>     return expr
15:32:06 <ij> Pretty much.
15:32:26 <hpc> :t unsafePerformIO + putStrLn + id
15:32:28 <lambdabot> Not in scope: ‘unsafePerformIO’
15:32:44 <hpc> aw, was hoping for some crazy Num instance action
15:34:36 <ij> No instance for (Show (IO a0 -> a0)) arising from a use of ‘print’
15:36:37 <vanila> I think it's more like
15:36:51 <vanila> oh nevermind
15:37:43 <Cale> merijn: Oh, also be careful because you're not evaluating m there
15:38:13 <Cale> merijn: So you'll build up an expression which looks like  insert k1 v1 (insert k2 v2 (...))
15:38:29 <Cale> which is exactly the same as just building a list
15:41:02 <trap_exit> if I were to shadow Prelude's + with "class MySum a b c | a b -> c where (+) :: a -> b -> c" ... what bad things should I expect to happen ?
15:41:49 <geekosaur> don't expect to add numbers unless you use Prelude.+ explicitly?
15:42:01 <mzero> very confusing error messages
15:42:23 <geekosaur> compiled code won't be affected, it's bound to the Prelude one
15:42:26 <merijn> Cale: I guess I can just import Data.Map.Strict, no?
15:45:27 <Cale> merijn: You don't really need to even do that, you just need a bang pattern on m
15:45:41 <Cale> merijn: Or seq m before recursing
15:46:42 <Cale> (changing to a stricter Map structure won't help if you never evaluate the expression which builds that structure in the first place)
15:47:32 <mzero> I want to be able to do historical API search....  like "when did Prelude stop exporting catch?"
15:48:08 <Cale> mzero: Yes, that would be awesome
15:48:54 * mzero goes to do binary search on Hackage...
15:50:01 <athan> Is there some sort of container that operates with keys behaving as values, and vice-versa? Something like a set of unordered 2-tuples, where lookups act on both sides of the tuple?
15:50:47 <mzero> athan - you want to be able to index the tuples by either of two keys?
15:51:13 <athan> mzero: Yep!
15:51:32 <mzero> well, if you think about it - there will have to be two trees, one per index
15:51:37 <mzero> and since the data itself will be shared
15:51:50 <mzero> just go ahead and create two maps, and add each item twice
15:51:57 <mzero> then use the right one to look up a value
15:52:09 <mzero> but - no - I don't that exists ready made in a lib.
15:52:44 <athan> hmm, alright. I might have to stitch something together then. It's for a factorization.... technique... lol
15:54:00 <koala_man> I have a minor function deep in a where clause that will return one of three values. is there a good way of doing that without declaring a top level data type?
15:55:26 <triliyn> You could return Maybe Bool, if you're not concerned about readability
15:55:49 <triliyn> But otherwise you probably just want a top-level data type
15:56:56 <koala_man> it's already returning Maybe Bool, and I guess Maybe (Maybe Bool) is a bit much
16:00:03 <mzero> here's another one I want: given my dependency bounds - tell me which lower bounds can be pulled forward, because other dependencies force them up anyway
16:00:39 <trap_exit> no, but "a b c | a b -> c"  is a superset of "a -> a -> a"
16:00:41 <trap_exit> thus, my + can call Prelude.+
16:00:59 <trap_exit> also, why is ++ bound to list.concat rather than mconcat ?
16:01:25 <trap_exit> is there a way to tell Haskell "don't implicitly include prelude" ?
16:02:00 <Iceland_jack> NoImplicitPrelude
16:02:43 <trap_exit> http://www.haskell.org/haskellwiki/No_import_of_Prelude
16:02:43 <trap_exit> cool
16:02:43 <trap_exit> thanks
16:02:53 <haasn> mzero: Sounds like tables
16:03:09 <mzero> ?
16:03:15 <haasn> https://github.com/ekmett/tables
16:03:33 <haasn> Indexing based on multiple keys/maps
16:03:46 <mzero> ah - I think athan wanted that
16:04:25 <athan> haasn: Thanks!
16:06:48 <k00mi> athan: what you want is called a bimap, I think an implementation is on hackage
16:07:08 <k00mi> tables would do but is way overkill
16:07:59 <athan> k00mi: Ahh perfect! Yeah this is exactly what I need. Thank you!!
16:08:56 <Marlene22>  Hi! I give you some videos. I hope you like! http://bit.ly/1mFMmyS
16:09:11 <trap_exit> !ops
16:09:29 <heatsink> @where ops
16:09:30 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:09:31 <trap_exit> @where ops
16:09:31 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
16:09:36 --- mode: ChanServ set +o copumpkin
16:09:38 --- mode: copumpkin set +b *!~Marlene21@95.141.28.117
16:09:38 --- kick: Marlene22 was kicked by copumpkin (No.)
16:09:40 --- mode: copumpkin set -o copumpkin
16:10:05 <trap_exit> I like how these spammers make their text so obvious
16:10:16 <trap_exit> if I were building such a spam bot, I'd use a markov chain or something, so it'd generate links like
16:10:32 <trap_exit> I get type error XYZ ... with the following code, please help debug http://bit.ly/...
16:10:50 <trap_exit> it should observe the channel, build a statistical model of sentence fragments taht include links, then use that
16:10:52 <copumpkin> don't give them ideas
16:10:54 <vanila> oh its hitting #gentoo too
16:11:04 <copumpkin> it hit #docker too
16:11:26 <Cale> It's been hitting all the top channels for the last several weeks
16:11:44 <Cale> Usually it gets banned by idoru
16:11:45 <heatsink> Is it advertising-related spam?
16:11:47 <copumpkin> I still think Haskell should be +s
16:11:52 <copumpkin> I had it that way for a while a few years ago
16:13:38 <geekosaur> trap_exit, there was a wave of spam like that at one point
16:14:01 <bennofs> Is there a parsing library (applictive or arrow style) that applies some static analysis to parsers? (other than uu-parsinglib). why aren
16:14:03 <geekosaur> it turned out to be readily identifiable because it was always rather ... antagonistically worded
16:14:08 <trap_exit> geekosaur: why did they stop? I bet click rates were higher
16:14:38 <trap_exit> hmm
16:14:46 <hpc> bennofs: ah, the age-old "enter instead of single quote" typo
16:14:57 <bennofs> hpc: :)
16:15:09 <trap_exit> I'd totally fall for things like: "check out this cool video of <famous haskell person> talkng about <interesting haskell concept> bit.ly / ... "
16:16:22 <geekosaur> trap_exit, yes, it workedd nicely at first. but it took about 3 uses before people started saying "don't click on that!" as soon as the spam appeared
16:16:43 <geekosaur> there are stunts that pretty much work only the first time they're used
16:18:08 <trap_exit> geekosaur: ahh, makse sense
16:19:50 <copumpkin> EvanR: rallymode
16:23:22 <trap_exit> i should create this new url shortenre service
16:23:32 <trap_exit> where first N people gets redirected to one site; remaining people gets redirected ot naother site
16:23:33 <trap_exit> teehee
17:32:33 <schell> how does infix precedence work again? the bigger the number, the higher the precedence?
17:36:01 <geekosaur> yes
17:37:26 <cwraith> the bigger the number, the stickier the operator.
17:45:50 <schell> geekosaur, cwraith: thanks :)
17:46:46 <Ankhers> If I create a recursive function, is it better to use an inner function?
17:47:20 <glguy> Ankhers: Do you have an example of what you mean?
17:47:35 <Ankhers> sure, let me write a quick paste.
17:48:42 <Ankhers> http://lpaste.net/109509
17:48:49 <Ankhers> Which is better for the compiler?
17:48:49 <pjdelport> schell: Mnemonic: higher number, higher precedence
17:49:36 <pjdelport> Ankhers: They might very well optimize to the same thing.
17:49:55 <pjdelport> Ankhers: Best to check the Core output, if it matters. There probably isn't a fully general rule about which is better.
17:50:17 <dolio> They don't.
17:52:06 <glguy> core for Ankhers 's code : http://lpaste.net/109509
17:52:49 <dolio> Sometimes stuff like bar is significantly better.
17:53:06 <dolio> Sometimes it's not.
17:53:35 <jcullen> Ankhers: One difference is that ghc won't inline recursive functions like foo, but it will inline a function written in the style of bar.  thats one way performance could differ somewhat
17:58:48 <schell> is there an Applicative version of sequence? [f a] -> f a?
17:59:24 <Ankhers> So aside from benchmarking, there is not way to tell if one version is better than the other?
17:59:56 * hackagebot edentv 4.9.1 - A Tool to Visualize Parallel Functional Program Executions  http://hackage.haskell.org/package/edentv-4.9.1 (horstmeyer)
18:00:07 <Ankhers> I guess what I am trying to say is that one is not inherently better than the other.
18:00:14 <hpc> @hoogle sequenceA
18:00:17 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
18:00:17 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
18:00:32 <hpc> schell: ^
18:00:39 <schell> ah! great!
18:00:56 <schell> i saw that one but the extra t context scared me
18:03:35 <dolio> Ankhers: There are ways to tell if it will likely have a big effect.
18:03:57 <pjdelport> schell: Traversable just generalizes list.
18:04:16 <dolio> Ankhers: For instance, foo has a function argument that is constant. If it inlines it can specialize to that function, and that can be a lot better than calling into an argument.
18:04:26 <pjdelport> :t sequenceA :: Applicative f => [f a] -> f [a]
18:04:28 <lambdabot>     Not in scope: ‘sequenceA’
18:04:28 <lambdabot>     Perhaps you meant one of these:
18:04:28 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
18:04:33 <pjdelport> :t T.sequenceA :: Applicative f => [f a] -> f [a]
18:04:34 <lambdabot> Applicative f => [f a] -> f [a]
18:04:44 <pjdelport> schell: No more scary :)
18:04:57 <glguy> > view each ("example","for","fosskers")
18:04:59 <lambdabot>  "exampleforfosskers"
18:05:14 <schell> pjdelport: thanks :) i had been using this foldl (liftA2 (++)) (pure []) . map (fmap (:[]))
18:05:32 <dolio> Ankhers: If it's just some data, it's less likely that it will matter.
18:05:57 <pjdelport> schell: Better version: sequenceA = foldr (liftA2 (:)) (pure [])
18:07:06 <Ankhers> dolio: I think I get it.
18:07:19 <Ankhers> dolio, glguy, jcullen, pjdelport: Thanks for the help.
18:07:31 <dolio> Ankhers: If you run with -fstatic-argument-transformation, GHC might turn foo into bar. But there's no -O level that will turn it on right now.
18:07:38 <dolio> Because it's not always worth doing.
18:08:21 <schell> pjdelport: thanks - it’l gonna take a sec for me to wrap my head around that
18:08:21 <dolio> Occasionally it's better to not do it, even.
18:08:26 <schell> i don’t use foldr much
18:08:39 <schell> ah, yes
18:09:06 <Ankhers> dolio: could you an example of when it would be better to not do it?
18:09:23 <dolio> Ankhers: No. :)
18:09:27 <dolio> I've only heard it second hand.
18:09:41 <pjdelport> schell: You know the identity foldr (:) [] ?
18:09:44 <schell> pjdelport: does that mean that we can say something general about that situation? like - if you need to map first and then foldl, maybe you should use a foldr?
18:09:52 <pjdelport> sequenceA is just that with the constructors lifted :)
18:09:55 <schell> pjdelport: yes, i see it now
18:10:07 <Ankhers> dolio: alright, thanks anyways :)
18:10:07 <redtricycle> How do I pretty print [Word8] into IO?  I'm in ghci playing with the pack and unpack commands (Data.ByteString)
18:10:11 <pjdelport> schell: Nah, i don't think the map affects it, really.
18:10:25 <dolio> Ankhers: I think it has to do with having a loop where the static stuff can be kept in registers, and so doing the static argument transform takes it out of registers and makes the code slower.
18:10:29 <pjdelport> schell: Anything you can express as a constructor transformation is a foldr, basically.
18:10:50 <redtricycle> pack [100] gets me "d"
18:11:10 <schell> that’s a new one for me - constructor transformation? something that updates a constructor?
18:11:14 <Ankhers> dolio: That makes sense.
18:11:33 <pjdelport> :t BS.putStrLn
18:11:35 <lambdabot> BSC.ByteString -> IO ()
18:11:44 <pjdelport> redtricycle: -^
18:11:57 <redtricycle> ah
18:12:39 <pjdelport> schell: I just mean in the sense that foldr implements a catamorphism: its arguments are basically replacements for the list's cons and nil constructors.
18:13:09 <pjdelport> schell: That's why foldr (:) [] is an identity function for lists: it just replaces the constructors with themselves.
18:14:12 <schell> that sounds very simple but i’m going to have to read up on it :)
18:15:34 <pjdelport> schell: Consider the list [1,2,3]. Written out, that is: (1 : (2 : (3 : [])))
18:15:34 <pjdelport> If you apply foldr f z to it, the result is: (1 `f` (2 `f` (3 `f` z)))
18:15:50 <pjdelport> Every (:) gets replaced with f, and every [] gets replaced with z.
18:17:35 <pjdelport> schell: Make sense? :)
18:18:04 <schell> yes - i’m just not familiar with the mathematical terms, though they’re very descriptive
18:18:16 <schell> i’m wikipedia’ing catamorphism right now
18:19:44 <pjdelport> schell: If you're more interested in the Haskell aspect of it, this is a classic paper on the subject: http://eprints.eemcs.utwente.nl/7281/01/db-utwente-40501F46.pdf
18:20:00 <pjdelport> Though it goes into some detail.
18:20:32 <pjdelport> schell: Consider the Either types' either function:
18:20:33 <pjdelport> :t either
18:20:34 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
18:20:39 <pjdelport> @src either
18:20:39 <lambdabot> either f _ (Left x)  = f x
18:20:39 <lambdabot> either _ g (Right y) = g y
18:21:20 <pjdelport> schell: Can you see how either f g actually just replaces Left with f, and Right with g?
18:21:48 <schell> yes, in the source it’s rather explicit
18:21:52 <pjdelport> That's a non-recursive example of the same idea as foldr.
18:22:13 <pjdelport> And like foldr (:) [] is an identity, so is either Left Right
18:22:42 <schell> ahh
18:22:51 <schell> that’s what an identity function is
18:22:51 <pjdelport> And, for example, maybe Nothing Just
18:23:00 <pjdelport> Same thing for Maybe
18:23:28 <pjdelport> Oh, sorry! My mistake; i should have explained that explicitly.
18:23:35 <schell> okay, it’s coming together
18:24:24 <pjdelport> But yeah, it's an identity in the sense that it returns exactly the same value (or structure), and can be optimized away without affecting anything. So foldr (:) []  == id
18:24:59 <pjdelport> But that identity is very useful as a starting point for defining foldr-based functions.
18:25:32 <schell> thanks - brb
18:25:47 <pjdelport> For example, the intuitive definition of map is that it takes [a,b,c,...] and "inserts" a function f in front of each value: [f a,f b,f c,...]
18:26:08 <pjdelport> With foldr, you can represent that idea explicitly: map f = foldr ((:) . f) []
18:27:04 <pjdelport> When you replace each (:) in the list with ((:) . f), you're literally inserting f between each (:) and its element value.
18:27:44 <schell> right
18:27:52 <schell> i hadn’t thought about map that way before
18:28:41 <pjdelport> (Sorry, i should say "one intuitive definition of map" not "the intuitive". :)
18:28:56 <schell> no worries - i read it as you meant
18:31:05 <pjdelport> foldr (liftA2 (:)) (pure []) is a similarly simple idea, once you grok it: you're lifting each individual constructor from "outside" the functor to inside it.
18:32:15 <schell> right, after the map example it’s much easier to see that
18:34:50 <pjdelport> The idea generalizes to any similar function:
18:34:50 <pjdelport> :t either (liftA Left) (liftA Right)
18:34:52 <lambdabot> Applicative f => Either (f a) (f b) -> f (Either a b)
18:35:03 <pjdelport> :t maybe (pure Nothing) (liftA Just)
18:35:04 <lambdabot> Applicative f => Maybe (f a) -> f (Maybe a)
18:37:01 <schell> well thanks for the lesson, that was a good tidbit of info :)
18:47:39 <benzrf> y use liftA when u got fmap
18:50:02 * hackagebot xml-pipe 0.0.0.8 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.8 (YoshikuniJujo)
18:58:16 <vanila> How do you write binary data to a file?
18:58:52 <vanila> Data.Binary?
19:01:07 <Clint> there are numerous ways
19:01:49 <vanila> how would I just store unsigned chars one by one?
19:01:56 <c_wraith> you mean bytes?
19:02:19 <vanila> im not sure
19:02:35 <vanila> oops
19:02:38 <vanila> I wrote unsigned when I meant signed
19:03:01 <vanila> I want to be able to write -128 up to 127 (whatever it is that fits in a byte)
19:05:33 <benzrf> @let a ><> b = a ++ " ><> " ++ b
19:05:35 <lambdabot>  Defined.
19:05:44 <benzrf> > "ocean" ><> "more ocean"
19:05:46 <lambdabot>  "ocean ><> more ocean"
19:06:17 <k00mi> vanila: pack the bytes into a ByteString, write ByteString to file
19:07:47 <vanila> thanks
19:07:49 <vanila> trying that :)
19:38:59 <Total_1mmersion> Is there a way to tell if two STRefs point to the same mutable value?
19:39:35 <Total_1mmersion> STRef is Eq, but runST $ do { i <- return 0; x <- newSTRef i; y <- newSTRef i; return (x == y) } is false
19:40:41 <augur> thats interesting
19:40:58 <augur> ooh, no, Total_1mmersion
19:41:07 <glguy_> The eq compares the references themselves not their contents
19:41:18 <Total_1mmersion> I know, that's what I want
19:41:25 <Total_1mmersion> Think of it like C pointers
19:41:28 <augur> Total_1mmersion: what you're doing is testing if the refs x and y are equal
19:41:29 <Total_1mmersion> I want to check if x == y
19:41:37 <glguy_> If you want to compare the values you need to read them out first
19:41:41 <augur> Total_1mmersion: which they're not -- they're different refs that happen to point to the same value
19:41:44 <Total_1mmersion> where *x is 1 and *y is the same value of 1
19:41:58 <dolio> x and y are two different mutable references.
19:41:59 <Total_1mmersion> I don't want to compare the values which the references point to
19:42:14 <augur> Total_1mmersion: why should that return True?
19:42:17 <Total_1mmersion> I want to know whether or not the references point to the same memory location
19:42:29 <augur> ahh no thats not what STRef does
19:42:42 <augur> STRef doesn't let you know anything about memory locations it points to
19:42:53 <Total_1mmersion> oh hmm
19:42:59 <augur> STRef is an opaque reference type
19:43:00 <Exio4> shouldn't you just use the same STRef?
19:43:17 <glguy_> You can't do that in Haskell, you can at best do some very unsafe things to approximate the answer
19:43:39 <Total_1mmersion> What I'm trying to do is implement a mutable graph which supports fmap
19:43:53 <Exio4> x <- newSTRef i; y <- x?
19:44:06 <Exio4> er, let y = x? :P
19:44:08 <Total_1mmersion> since modifySTRef only does a -> a, I would like to be able to do a -> b
19:44:18 <augur> Total_1mmersion: using genuine refs will be difficult/impossible
19:44:33 <Total_1mmersion> Exio4, yeah I think that would work
19:44:57 <augur> Total_1mmersion: you're better of implementing the graph as a lookup table
19:45:11 <augur> Total_1mmersion: ie Map Node [Edge]
19:45:40 <Total_1mmersion> If each node is given newSTRefs to each of its neighbors, it's impossible. But if the refs themselves are reused, I think it could work
19:45:53 <Total_1mmersion> augur, yeah that's the immutable alternative
19:46:16 <augur> its really hard to do this sort of stuff in haskell
19:46:36 <Total_1mmersion> I am just curious about how the use of a mutable graph would differ from immutable
19:46:40 <pjdelport> Total_1mmersion: You can use a mutable map
19:46:42 <fizbin> Hey, is there a standard place for silly little utility functions that you want to throw out there to see if other people find them useful?
19:47:07 <pjdelport> lpaste? :)
19:47:10 <Total_1mmersion> a fizbin sounds like a good place
19:47:12 <augur> Total_1mmersion: well, what do you want out of the mutability?
19:47:37 <Total_1mmersion> augur, really I just want a feeling for how it differs from the immutable map implementation
19:48:17 <fizbin> pjdelport: I was wondering if maybe there were a place where people might link to gists of little utility functions. lpaste seems too ephemeral.
19:48:32 <Total_1mmersion> rosettacode?
19:48:55 <pjdelport> fizbin: lpaste isn't all that ephemeral: if you fill in your author field, you can retrieve your pastes.
19:48:57 <augur> Total_1mmersion: well, but you cant get a feel without specifying what it does, see
19:49:14 <pjdelport> http://lpaste.net/browse?author=fizbin :)
19:49:20 <augur> Total_1mmersion: i mean, mutability implies you're changing things. so there has to be SOME kind of use difference
19:49:32 <augur> if there isnt, then there's just no real sense in which you have a mutable graph
19:49:45 <Total_1mmersion> augur, I would like to be able to for example label each node like so: a -> (Int, a)
19:50:03 <augur> Total_1mmersion: sure, but thats independent of mutability
19:50:31 <furrykef> Are there any downsides to using the 64-bit Haskell Platform on 64-bit Windows?
19:50:40 <furrykef> I know that with Python, for instance, it's typically better to use the 32-bit version
19:50:49 <furrykef> (for library compatibility)
19:51:31 <Total_1mmersion> augur, no, because each "a" could reference other "a"s
19:52:13 <pjdelport> Total_1mmersion: That doesn't require mutation.
19:52:48 <augur> Total_1mmersion: i dont know what you mean
19:52:55 <Total_1mmersion> pjdelport, right but an immutable implementation would just be simulating mutation
19:53:15 <pjdelport> Total_1mmersion: What do you mean?
19:53:15 <augur> Total_1mmersion: there is no mutation here at all
19:53:27 <augur> Total_1mmersion: not in the example you give of a labeled graph
19:53:47 <michaelt> furrykef: I think the haskell platform on windows comes bundled with a bunch of C libraries to keep that sort of trouble away; I'm not sure though.
19:54:25 <kristof> I can't think of a single person using Haskell on Windows.
19:54:55 <michaelt> russians do!
19:55:04 <kristof> Can Russians afford Windows?
19:55:15 <furrykef> well I'd happily be using Linux instead if only it wouldn't make it a big PITA to use my computer...
19:55:34 <Total_1mmersion> augur, um I'm pretty sure there is mutation going on. If I have a graph with nodes referencing each other and I want to modify all of the nodes by giving them each a label such that I can dereference the references from one node to the next and obtain the Int label, then isn't that mutation?
19:55:53 <michaelt> and Lennart Augustson at Standard Chartered is always complaining that this or that doesn't work on Windows.
19:55:58 <augur> Total_1mmersion: ahh, you want to ADD labels after the fact
19:56:03 <Total_1mmersion> STRef a -> STRef (Int, a)
19:56:20 <augur> Total_1mmersion: for that what i would do is something like
19:56:51 <augur> Map Node (STRef (Maybe Label), ...)
19:57:26 <augur> so that each node is mapped to a tuple containing a reference to a Maybe Label (ie a label or nothing) and to whatever other information
19:58:06 <Total_1mmersion> augur, as a first thought that seems like the only way to do it, but unfortunately you lose the type checkable guarantee that after adding labels, the labels are all there (i.e. not wrapped in Maybe).
19:58:37 <augur> Total_1mmersion: there can be no such guarantee in haskell
19:58:37 <Total_1mmersion> augur, that would totally work, but it would be nice to be able to do a -> b
19:59:12 <pjdelport> Total_1mmersion: What does "dereferencing" mean in this context, exactly? Following a path?
19:59:25 <augur> what you would need instead is a dependently typed language because you want to be able to specify that you're "adding all labels" not simply "adding one label"
19:59:35 <Total_1mmersion> pjdelport, yeah, so each node is an "a" which contains STRefs to other "a"s
20:00:03 <pjdelport> Total_1mmersion: Why STRefs instead of pure references?
20:00:11 <augur> Total_1mmersion: in a dependent language it would be possible to define a function    addAllLabels :: (TheNodes -> Label) -> Map Node (STRef (Maybe Label)) -> Map Node (STRef Label)
20:00:26 <pjdelport> Total_1mmersion: Values can circularly reference each other in a pure, immutable data structure.
20:00:30 <augur> Total_1mmersion: the key here being that TheNodes would be defined to be the type of all and only the labels in the graph in question
20:00:38 <augur> actually you couldnt define it quite like that but you get the point
20:00:49 <augur> the input function would then have to be total -- assigning every node a label
20:00:49 <Total_1mmersion> pjdelport, mutation. And I've already implmemented this using an immutable map - I'm just curious as to what it would be like using mutability in Haskell
20:01:09 <augur> but, Total_1mmersion, this actually has nothing to do with mutability
20:01:14 <pjdelport> Total_1mmersion: Can you paste it perhaps?
20:01:40 <Total_1mmersion> ehh not really, this is mostly in my head right now.
20:01:42 <augur> Total_1mmersion: even in an immutable graph, you cant guarantee that every node has a label if you use Maybe Label
20:02:02 <furrykef> looks like 64-bit GHC only produces 64-bit files, so I guess I'll get the 32-bit one
20:02:05 <pjdelport> Or rather, did your immutable version use circular "knot-tying", or did you rewrite the immutable map to simulate mutations?
20:02:20 <Total_1mmersion> I used an immutable map to simulate mutation
20:02:38 <pjdelport> Total_1mmersion: It's hard to give advice on how it might look like without seeing a more concrete example, though.
20:02:50 <Total_1mmersion> pjdelport, ok I'll write something up
20:05:30 <pjdelport> Total_1mmersion: Here's a trivial example of using and resolving circular references:
20:05:30 <pjdelport> > let (!) = (M.!);  g = M.fromList [('a', g ! 'c'), ('b', 2), ('c', g ! 'b'), ('d', 3)] in g
20:05:32 <lambdabot>  fromList [('a',2),('b',2),('c',2),('d',3)]
20:06:06 <pjdelport> Would that be applicable at all?
20:07:30 <pjdelport> In other words, each key's values can make arbitrary references to other keys' values, and Haskell will resolve whatever paths need resolving automatically.
20:08:36 <Total_1mmersion> Well the thing I'm looking to do then is change the value of a node and have that change be reflected in the references from other nodes to that node that got changed
20:09:53 <glguy_> There's no type safe way to change the type of a reference
20:11:49 <Total_1mmersion> glguy_, I'm not so sure, heh. I know that modifySTRef is (a -> a). If it was (a -> b) then of course it would be possible, but that would break the other references' types. I'm wondering if it's possible to traverse the graph by updating each node with (a -> b) and keep track of the references you've seen so far so that when you see an old reference, you just reuse it.
20:11:50 <pjdelport> Total_1mmersion: You could replace the Int value type in the above with STRef, then all the nodes that reference the same STRef will see updates to it whenever it changes.
20:12:08 <augur> :t modifySTRef
20:12:09 <lambdabot> STRef s a -> (a -> a) -> ST s ()
20:12:51 <pjdelport> Total_1mmersion: In that case, the graph structure is immutable, and resolved once; and then the actual STRefs are simply shared between all the nodes that reference them (regardless of whether the original reference was direct or indirect)
20:12:52 <augur> Total_1mmersion: i dont think there's a way without reifying the memory structure
20:13:11 <augur> Total_1mmersion: i was actually thinking about this a few weeks ago
20:13:12 <glguy_> Nope, the type is the way it is because that's the only type it can have
20:13:33 <augur> the problem is that its not just other refs that are the problem
20:13:40 <Total_1mmersion> pjdelport, replace the Ints with STRef of what?
20:13:41 <augur> Total_1mmersion: consider the possibility of having [STRef a]
20:13:52 <augur> Total_1mmersion: if you type-chang the head of the list, whats the type of the list?
20:14:04 <augur> Total_1mmersion: its not [STRef a] any more, nor is it [STRef b]
20:14:06 <pjdelport> Total_1mmersion: Whatever value you want them to reference. :)
20:14:20 <augur> its something like   [STRef a or STRef b]   but thats no go
20:14:23 <Total_1mmersion> augur, yes that's a problem and I realize that, but I'm wondering if it's possible to get around it by recreating the whole list
20:14:23 <augur> no good*
20:14:32 <augur> Total_1mmersion: recreating how tho
20:14:42 <Total_1mmersion> that's what I'm working on, heh
20:14:46 <augur> unless you apply a function to _everything_ in the list, there's nothing you can do
20:14:59 <augur> because lists in haskell must be homogeneous
20:15:01 <Total_1mmersion> right, you would have to apply the function to the whole list
20:15:38 <augur> the other problem of course, as you mention, is that the STRef might be used elsewhere and that would cause type errors too
20:15:44 <augur> the thing is, see, STRef is not a functor
20:16:03 <augur> and it cant be a functor
20:17:30 <trap_exit> alright alright, so I've learned: I don't want to ignore the entireity of prelude. There are some useful stuff there.
20:17:40 <trap_exit> Is there a wya to psay : import Prelude, except +-*/ ?
20:17:53 <trap_exit> because I want to redfine those myself, with some cases using Prelude.+ Prelude.-, etc ...
20:18:09 <triliyn> import Prelude hiding ((+), (-), (*), (/))
20:18:37 <trap_exit> triliyn: nice, thanks!
20:24:22 <trap_exit> err
20:24:24 <trap_exit> where is Int defined?
20:24:45 <pqmodn> in ghci you can type :i Int
20:25:09 <trap_exit> nice; thanks!
20:25:09 <pqmodn> data Int = GHC.Types.I# GHC.Prim.Int# -- Defined in ‘GHC.Types’
20:25:52 <trap_exit> you would not make a good car salesman: how much is this car for? well, you can get the accurate value online :-)
20:25:59 <pqmodn> heh
20:30:52 <trap_exit> waht should I expect to break if I define ++ to be mconcat ?
20:31:44 <joelteon> lots of type errors
20:31:51 <joelteon> mconcat is unary anyway
20:32:40 <trap_exit> sorry
20:32:42 <trap_exit> I'm a retard
20:32:44 <trap_exit> I mean ++ to be mappend
20:32:50 <bitemyapp> trap_exit: don't say that, no you're not.
20:33:10 <trap_exit> yaya, fishing for compliments success / I'm kidding
20:33:17 <trap_exit> but really, why is ++ not defined as mappend
20:33:26 <trap_exit> it seems stupid that I can ++ lists, but I can't ++ LazyTexts
20:33:38 <trap_exit> why do we have type classes, yet ++ only work on Lists, rather than be defined to be mappend
20:34:04 <pqmodn> may things in Prelude are not as general as they could be (specialized to [a] instead of Functor a, etc)
20:34:08 <MP2E> trap_exit: not sure why ++ is monomorphic, but there is '<>' from the semigroup typeclass, it is a synonym to mappend
20:34:15 <copumpkin> many things used to be more general than they are now
20:35:00 <pjdelport> Total_1mmersion: Here's a (somewhat tortured :) example:
20:35:00 <pjdelport> > let (!) = (M.!) in runST $ do { r <- newSTRef 1; let {g = M.fromList [('a', g ! 'c'), ('b', r), ('c', g ! 'b')]}; x <- readSTRef (g ! 'a'); modifySTRef (g ! 'b') negate; y <- readSTRef (g ! 'a'); return (x,y) }
20:35:02 <copumpkin> https://www.cs.auckland.ac.nz/references/haskell/haskell-report-1.4-html/standard-prelude.html
20:35:02 <lambdabot>  (1,-1)
20:35:07 <copumpkin> that's Haskell 1.4
20:35:11 <copumpkin> pre-98
20:35:28 <trap_exit> https://gist.github.com/anonymous/3722b4088cd138e1b016 <-- let's see what breaks :-)
20:36:01 <furrykef> <copumpkin> many things used to be more general than they are now
20:36:04 <furrykef> They got demoted to colonel?
20:36:09 <fizbin> :t let k f = either (k f) id . f in k
20:36:10 <lambdabot> (a -> Either a c) -> a -> c
20:36:14 <MP2E> colonel polymorphism
20:36:16 <pjdelport> Total_1mmersion: In other words, (g ! 'b') is modified, but the change is reflected in (g ! 'a'), which references the same underlying STRef (indirectly, via g ! 'c', which references g ! 'b')
20:36:36 <copumpkin> lol
20:36:36 <fizbin> @pl let k f = either (k f) id . f in k
20:36:36 <lambdabot> fix (join . ((.) .) . flip flip id . (either .))
20:37:13 <copumpkin> data Char = ... 'a' | 'b' ... -- 2^16 unicode values
20:37:15 <copumpkin> lol
20:37:24 <Total_1mmersion> pjdelport, right I see what's happening, but what I'm trying to do is not just negate which is (Int -> Int), but something like (Int -> String)
20:37:28 <fizbin> :t flip flip id
20:37:29 <lambdabot> (a -> (a1 -> a1) -> c) -> a -> c
20:37:57 <Total_1mmersion> pjdelport, I'm writing an example as well, I'll let you know when I'm done
20:38:56 <pjdelport> Total_1mmersion: You could do that with another indirection: have an STRef that contains an STRef.
20:39:12 <Total_1mmersion> pjdelport, I don't think so because modifySTRef is (a -> a)
20:39:16 <pqmodn> i didn't know Void used to be part of Prelude
20:39:42 <Total_1mmersion> pjdelport, STRef has a type parameter "a" which cannot change
20:39:44 <pjdelport> Total_1mmersion: D'oh, right. Hmm.
20:41:08 <pjdelport> Total_1mmersion: How polymorphic do you want to be?
20:41:14 <trap_exit> I'm redefineing Prelude.+ as follows: https://gist.github.com/anonymous/466e2cf9c9b044cc1d66 ... if it looks like I'm goign to be running into a brick wallk please inform me now :-)
20:41:25 <Total_1mmersion> pjdelport, as much as possible? heh
20:41:32 <MP2E> allthemorphic
20:41:33 <trap_exit> This generalization allows me to add Int -> Int -> Int, Double -> double -> Double, but then also do Vec2 -> BBox -> BBox
20:41:39 <Total_1mmersion> MP2E, lol yes
20:42:26 <pjdelport> Total_1mmersion: What i mean is, you have to separate the two levels of update somehow. If you want to be able to change the type of arbitrary keys in isolation, you'll have to make it a sum type.
20:43:02 <pjdelport> (And if you don't want to pre-declare your sum type, that sum type will have to be Data.Dynamic. :)
20:43:42 <rrradical> Is there a general strategy for diagnosing cabal dependency conflicts? I'm getting a bunch of "reinstalls" when I try to install Yi, but I'm not sure what the root cause of it is. The "reinstall" packages aren't even listed as dependencies.
20:43:45 <Total_1mmersion> pjdelport, yeah, essentially you need space to store information (like Maybes all over the place) that you will want eventually up front
20:49:41 <pjdelport> Total_1mmersion: Anyhow, does the above more or less demonstrate how the mutation is (or can be) orthogonal to the graph structure and referencing, at least?
20:50:04 <Total_1mmersion> pjdelport, what does orthogonal mean?
20:50:20 <pjdelport> Total_1mmersion: Independent of each other
20:50:46 <Total_1mmersion> pjdelport, yeah I see how it works
21:00:18 <fizbin> https://gist.github.com/fizbin/f6ee373e5c7b11e2b3a6
21:02:34 <Lambdanaut> Question. Are typeclasses roughly equivalent to categories? Answer like I'm 10 years old if possible.
21:02:46 <fizbin> No
21:03:08 <trap_exit> Do you like strawberry, chocolate, or vanilla ?
21:03:30 <Lambdanaut> Chocolate.
21:03:59 <Hafydd> Do you have kiwi?
21:04:05 <alpha123> Lambdanaut: You're 10? What are you doing on IRC? Are you lost? Where are your parents?
21:04:25 <pjdelport> Lambdanaut: "No" is probably a reasonable answer to that.
21:04:27 <pjdelport> :)
21:04:29 <fizbin> alpha123: Yes, yes, you read xkcd. Very nice.
21:04:45 <Lambdanaut> "No" is acceptable.
21:04:59 * alpha123 's secret plan to weed out the snarky xkcd readers in here is working well so far
21:05:16 <trap_exit> Are you an FBI or CIA agent impersonating as a 10 year old?
21:05:23 <pjdelport> Lambdanaut: I'm sure you can model type classes in various ways using categories, but that's about where the relation stops.
21:05:38 <pjdelport> (You can model *everything* in various ways using categories. :)
21:05:59 <Lambdanaut> cool
21:06:12 <trap_exit> I am in love
21:06:15 <trap_exit> with amazon fresh.
21:06:24 <trap_exit> It's amazing, order something, have it delivered in < 12 hours
21:06:37 <dolio> Can you order Haskell?
21:06:51 <trap_exit> No, for that I use cabal install
21:06:54 <trap_exit> which is faster.
21:07:13 <dolio> Then it's off topic.
21:07:14 <Lambdanaut> Much more expensive than the grocers? I'm considering going with it but I have a grocer 5 minute walk from the house
21:07:34 <trap_exit> dolio: point taken.
21:07:50 <Lambdanaut> awe
21:12:59 <trap_exit> is there a way to get lambdabot to msg me a list of ops, without the ops nicknames being displayed in channel and thus having their terminals beep ?
21:13:15 <alpha123> trap_exit: I guess you could /query lambdabot
21:13:28 <glguy> trap_exit: You can join #haskell-ops and see who is available
21:14:01 <trap_exit> alpha123 glguy: query worked :-)
21:16:21 <geekosaur> /msg lambdabot @command ...
21:18:34 <fizbin> @hoogle [Maybe a] -> [a]
21:18:36 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
21:18:37 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
21:18:37 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
21:26:41 <Total_1mmersion> pjdelport, I realize this is a lot of code, but hopefully it's straightforward. The part that I'm trying to figure out is the "undefined" http://lpaste.net/109515
21:31:26 <fizbin> :t (1,)
21:31:38 <lambdabot> Num t => t1 -> (t, t1)
21:51:49 <arbus> Has anyone ever encountered an issue where the you can run a query against a database just fine but running it through the runRaw function from HDBC always produces a syntax error from the database? Database in question is MySQL is that is relevant
21:57:06 <benzrf> why are you using mysql
22:03:34 <benzrf> you should be using yoursql
22:03:48 <spopejoy> When implementing Ord, I’m always writing compare a b = compare (f a) (f b). It’s easy to write a function (a -> a -> c) -> (b -> a) -> (b -> a) -> c to generalize this. Is there already a function like this in base?
22:04:43 <benzrf> :t on
22:04:44 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
22:05:15 <benzrf> > compare `on` snd $ (1, "foo") (3, "bar")
22:05:17 <lambdabot>  Precedence parsing error
22:05:17 <lambdabot>      cannot mix ‘Data.Function.on’ [infixl 0] and ‘GHC.Base.$’ [infixr 0] in ...
22:05:25 <benzrf> > (compare `on` snd) (1, "foo") (3, "bar")
22:05:30 <lambdabot>  GT
22:05:47 <Iceland_jack> > comparing snd (1, "foo") (3, "bar")
22:05:49 <lambdabot>  GT
22:06:02 <benzrf> @hoogle comparing
22:06:05 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
22:06:30 <spopejoy> thanks, i was hoogling the wrong type it seems
22:09:53 <benzrf> yez
22:10:05 <benzrf> your functoin takes no b's
22:10:09 <benzrf> it implicitly stores a b
22:10:18 <benzrf> storing b's is dangerous, u could get stung D:
22:20:07 <tel> Anyone have any familiarity with installing ghcjs? My ghcjs-boot is stalling around vector
22:25:20 * hackagebot mirror-tweet 0.1.0.0 - Tweet mirror  http://hackage.haskell.org/package/mirror-tweet-0.1.0.0 (minamiyama1994)
22:27:59 <ezapata> hey guys, I’ve got a couple of questions about typeclasses
22:28:40 <ezapata> I am trying to create a typeclass without any functions
22:28:54 <ezapata> which I believe should be okay
22:29:24 <ezapata> so something like class Foo a
22:29:37 <ezapata> but then what I want to do is something like
22:29:48 <ezapata> instance forall a . Foo (Maybe a)
22:29:49 <ezapata> ?
22:29:59 <ezapata> is it possible to do something like this?
22:31:04 <tel> ezapata most likely, yes, but you don't need the forall bit—that's automatic
22:31:24 <ezapata> tel: okay, but that appears not to work
22:32:34 <tel> ezapata class Foo a; instance Foo (Maybe a) compiles—where do you see it fail?
22:32:39 <ezapata> I am getting the error: “could not deduce a ~ Maybe [Char] from the context (Foo a)“
22:32:44 <ezapata> in my function definition
22:32:50 <ezapata> where I have
22:32:59 <ezapata> bar :: Foo a => Int -> a
22:33:37 <tel> Well, that's another problem—given that Foo has no methods you'll be hard pressed to create a type (forall a . Foo a => a)
22:34:00 <tel> (i.e. modulo bottom it is impossible)
22:34:03 <tel> what are you trying to achieve?
22:34:52 <ezapata> yeah I figured something like that would be the problem...
22:35:04 <ezapata> I guess I was trying to cheat Haskell
22:35:52 <tel> ezapata what were you trying to write?
22:35:55 <ezapata> what I am trying to achieve isn’t particularly important… I just thought a simple hack would work, and then realized it probably shouldn’t and wanted to know why
22:36:03 <ezapata> I definitely have work arounds
22:36:48 <tel> ezapata Gotcha
22:37:11 <ezapata> thanks for the help!
22:37:17 <tel> ezapata np!
22:47:38 <Fuuzetsu> I have a library here with tons of ‘undefined’ and I'd like to know which ones I'm hitting when it's running, is using ‘error "error from functionname"’ or is there something nicer I could do (bar fixing them all of course)
22:48:52 <glguy_> Google for Haskell debugging and take the first link to the Haskell wiki and section 1 talks about stack trace on exception
22:48:58 <glguy_> -xc stuff
22:49:25 <Fuuzetsu> not after that stuff, I just want something more informative than Prelude.undefined
22:49:36 <Fuuzetsu> I don't care much how it happened, just that it happened
22:49:48 <Fuuzetsu> say, maybe a line number would be nice on top or something
22:50:22 * hackagebot ghcjs-dom 0.1.0.0 - DOM library that supports both GHCJS and WebKitGTK  http://hackage.haskell.org/package/ghcjs-dom-0.1.0.0 (HamishMackenzie)
22:51:35 <tel> I'd love a ghcjs-dom that didn't bother installing webkitgtk and just nop'd dom code, just so I could typecheck it all in ghci
22:51:39 <merijn> Fuuzetsu: Replaced them with typed holes -fdefer-type-errors? :p
22:54:42 <GLaDER> I'm trying to split my program up into several files but I seem to be out of luck. Is it really harder than putting: module <Filename> where
22:54:45 <hamishmack> tel: Try cabal install -f-webkit ghcjs-dom
22:55:12 <tel> hamishmack oh nice
22:55:43 <merijn> GLaDER: What problems are you running into?
22:56:08 <hamishmack> tel: Not sure it might not work with ghc
22:56:21 <hamishmack> It should be easy to fix if it does not though
22:56:41 <tel> hamishmack I'll try it out as soon as my ghcjs is back
22:57:21 <Total_1mmersion> pjdelport, did you get a chance to look at http://lpaste.net/109515 ?
22:58:12 <GLaDER> merijn: Pretty much everything is reported as not in scope
22:59:48 <GLaDER> merijn: I have one file TestBot.hs and one file TestBotCommands.hs, in the same folder. I've written "module TestBot where" and imported everythin I need in the TestBot.hs-file and i've written "module TestBotCommands where" in the other file, and I've imported what I need.
23:00:17 <GLaDER> If I copy and paste everything (except the module part) from the Command-file to the TestBot.hs-file, it works smoth as silk.
23:01:26 <merijn> GLaDER: How are you compiling the code?
23:01:58 <GLaDER> runhaskell
23:02:23 <GLaDER> Aah, maybe that's the problem. I need to do a real compilation?
23:03:10 <pavonia> Do you run that from the directory where the files are?
23:03:19 <GLaDER> pavonia: I am idd!
23:03:25 <GLaDER> ls
23:03:53 <merijn> GLaDER: I have no clue about runhaskell, but I wouldn't trust it alot for doing the right thing
23:04:05 <GLaDER> merijn: Haha, what would you do?
23:04:27 <merijn> tbh, as soon as I have more than 1 file I start using cabal
23:04:36 <GLaDER> Never heard of, what is it?
23:05:14 <GLaDER> Cabal is a system for building and packaging Haskell libraries and programs.
23:05:51 <GLaDER> merijn: Well, thanks anyway, i'll dig into it a bit further!
23:06:09 <merijn> GLaDER: cabal is the dependency tracker/build tool for haskell
23:06:17 <pavonia> "ghc TestBot.hs" should work, though
23:06:27 <merijn> GLaDER: Does it work if you load it into ghc/compile with ghc
23:09:40 <Jafet> {-# LANGUAGE CPP #-} #define undefined (error (__FILE__ ++ ":" ++ show __LINE__ ++ ": undefined"))
23:09:49 <GLaDER> merijn, pavonia: Neither ghci nor ghc works.
23:10:12 <GLaDER> The issue seems to be that my class "Net" is not transfered properly between the files.
23:10:32 <pavonia> Could you paste the erre messages, please?
23:10:35 <pavonia> ,lpaste
23:10:41 <pavonia> @lpaste
23:10:41 <lambdabot> Haskell pastebin: http://lpaste.net/
23:10:46 <GLaDER> pavonia: http://i.imgur.com/QV1bEVN.png
23:11:27 <pavonia> And what do the headers of your .hs files look like?
23:12:43 <GLaDER> pavonia: I think we've encountered an issue. headers?
23:12:55 <pavonia> Oh wait, do you use functions/types from one file in the other *and* vice versa?
23:13:34 <GLaDER> pavonia: I think that might be the case, yes.
23:13:53 <pavonia> That's bad, you shouldn't have cyclical dependencies
23:13:56 <GLaDER> It's almost a year since I last programmed in Haskell so I'm not really up to speed when it comes to the terminology and syntax.
23:14:28 <pavonia> (By headers I just meant the module-line and the imports)
23:15:20 <GLaDER> pavonia: Help yourself :) http://pastebin.com/nL8xuqvS + http://pastebin.com/QkciD1TZ
23:16:53 <pavonia> Yeah, you would have to import TestBot from TestBotCommands. But I recommend restructuring your imports such that you import only in one direction
23:17:16 <merijn> They should just fix ghc to support cyclical dependencies
23:17:35 <merijn> I've been spending the past 4 hours restructuring modules and imports to work around that deficiency
23:17:51 <GLaDER> pavonia: Okay. How do I know what to put where?
23:19:07 <pavonia> Well, if you neet a function or type in file 1, it can go to file 1 or 2; if you need it in file 2 it can only get there. then you import 2 from 1
23:19:30 <pavonia> *go there
23:20:02 <MP2E> merijn: looks like people have been aware of this for a long time :( I wonder what's stopping it from being implemented
23:20:21 <GLaDER> Okay, and my current problem is that TestBotCommands.hs uses functions from TestBot.hs (?). I don't seem to recall that, or is it the "Net-type" that's messing everything up?
23:22:04 <pavonia> Yes, the Net type and all functions reported as not being in scope
23:22:28 <pavonia> Hhm, socket may be a library function
23:22:31 <GLaDER> pavonia: Okay. I'll simply go back to one file for now :D Thanks a lot for the help, and I'll check out Cabal as time goes on.
23:23:20 <pavonia> Okay. Note that cabal won't magically resolve this issue for you, AFAIK
23:23:37 <furrykef> pavonia -- fancy seeing you here
23:23:46 <merijn> argh
23:24:11 <merijn> I can't seem to unfuck this code to not bitch about cyclical imports
23:24:14 <pavonia> furrykef: O hai! :)
23:29:59 <merijn> )*)%&*()%&(#&
23:30:15 <merijn> Maybe I should just dump all my code in a single file...
23:30:38 <GLaDER> merijn: Sounds wise.
23:30:50 <GLaDER> readability < working code
23:38:48 <latk> Anyone know if there is a way with xml-conduit to select a node that is one of two element types ?
23:39:06 <latk> e.g. element "a" or element "p"
23:47:34 <Lambdanaut> what is the type signature of a function that takes a lens as input?
23:48:24 <glguy_> Use ALens as a function argument
23:48:48 <glguy_> And the you can use cloneLens on that
23:49:59 * merijn sighs
23:50:11 <merijn> And now binary doesn't have a strict bytestring encoder...
23:50:35 <Lambdanaut> glguy_: Yeah this looks right. Thanks
23:51:25 <glguy_> Just convert it to a strict bye string at the end
23:52:15 <merijn> glguy_: Can't
23:52:21 <merijn> Well, I can
23:52:26 <merijn> But it's really inefficient
23:52:50 <merijn> I'm encoding lots of a small bytestrings, converting all of them to strict bytestring can't be helpful for performance
23:54:08 <Cale> Use cereal?
23:54:42 <Fuuzetsu> mhm, I could totally use me some cereal right now
23:55:27 <glguy_> Cereal won't help
23:55:38 <merijn> Cale: I can't
23:55:43 <Cale> okay
23:55:47 <merijn> Cale: One of my dependencies uses binary
23:55:50 <Cale> I see
23:55:57 <Cale> Then yeah, just convert to strict at the end
23:56:02 <glguy_> It's just binary with a to strict at the end when you put with it
23:56:02 <merijn> Cale: Else I'm using binary for half my operations and cereal for the other
23:56:07 <Cale> Which basically amounts to concatenating chunks
23:56:47 <merijn> I don't really see why they don't add strict encoding to binary, they've already added strict parsing and then we could just deprecete cereal entirely
23:57:37 <glguy_> They haven't added it because it doesn't make sense to exist. The last version already works on large chunks
23:57:37 <merijn> Cale: Yeah, but toStrict is expensive according to the docs :\
23:57:47 <merijn> glguy_: Of course it makes sense to exist
23:57:54 <Cale> Well, of course it's expensive!
23:58:04 <glguy_> Binary doesn't make tiny chunks just because you wrote small things
23:58:08 <merijn> glguy_: If your entire application is expecting strict ByteString
23:58:11 <Cale> You're going to allocate a big hunk of memory and copy a bunch of chunks into it
23:58:35 <merijn> Cale: Right, hence why I want binary to have a way to just produce the strict BS immediately
23:59:01 <glguy_> Merijn , I think you might not understand how the Put monad works
23:59:03 <Cale> It would actually probably be worse, I bet
23:59:18 <Cale> Because you'd be repeatedly doing this throughout the Put action
23:59:40 <merijn> glguy_: Half our ecosystem uses strict ByteString, why the hell do we have a serialisation library that can only produce one of two bytestring types?!
23:59:51 <merijn> Instead of just doing both ByteString types
23:59:54 <Cale> merijn: because one of them is more appropriate than the other for this?
23:59:58 <Cale> and they're convertible
