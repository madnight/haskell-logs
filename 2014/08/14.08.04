00:00:10 <solatis> and do not use it as your primary data store, that's the bottom line i think
00:03:11 <vozz> I hear people mentioning that lazy IO can have weird behaviour that cause them problems... What kind of weird behaviour does it have, could someone explain, maybe with some examples?
00:04:04 <solidus-river> vozz: you open a filehandle, you dont evaluate its contents untill way later in the program
00:04:06 <solatis> vozz: http://www.haskell.org/haskellwiki/IO_inside#Welcome_to_the_RealWorld.2C_baby
00:04:11 <maybefbi> can yi show an overlay UI to show tips and select values from?
00:04:11 <solatis> that's a nice illustration
00:04:39 <solidus-river> vozz: or you open, load lazy io thats not evaluated, then close the fh before you look at it
00:05:07 <vozz> Ah.
00:05:10 <vozz> I see
00:05:22 <vozz> I'll have a look at that thing on the wiki
00:05:24 <vozz> thanks a lot!
02:12:21 <whyy> Introduced the awesomeness of Haskell in office
02:12:24 <whyy> Here are the slides
02:12:29 <whyy> http://slides.com/rajeevbharshetty/introduction-to-haskell#/
02:12:29 <whyy> :)
02:16:04 * Kinnison likes the macro images
02:18:30 <divyanshu> whyy : nice :)  I too gave a talk at office 3-4 months back.
02:19:18 <whyy> divyanshu: cool
02:33:37 <kvelicka> Hi. Is there a way to update an IORef in a do block that is for another monad (if that makes sense)
02:34:07 <augur> kvelicka: nope!
02:34:26 <augur> any computation which involves IO must be performed in the IO monad
02:34:36 <keko_> but do look into monad transformers
02:34:42 <augur> thats what the IO monad is! its the type of IO computations!
02:34:44 <keko_> those can probably do what you're thinking of
02:34:53 <ClaudiusMaximus> if the other monad supports MonadIO you can use liftIO, but that'll only be the case if you're using monad transformers
02:34:56 <augur> kennyp: sure but only by wrapping things in IO
02:35:05 <augur> er
02:35:07 <augur> keko_: ^
02:35:36 <kvelicka> the problem is that I'm parsing something and there's a certain "marker" that I need to keep a track of
02:35:41 <kvelicka> and I'm trying to find a way to do taht
02:35:58 <augur> kvelicka: example?
02:36:16 <augur> what kind of parser is it?
02:36:19 <arianvp_> @hoogle a -> IO b
02:36:22 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
02:36:22 <lambdabot> Control.Exception evaluate :: a -> IO a
02:36:22 <lambdabot> Control.OldException evaluate :: a -> IO a
02:36:46 <kvelicka> it parses eventlogs generated by the RTS, I'm extending the ghc-events library
02:36:49 <augur> kvelicka: "marker" suggests to me that you're doing some kind of chart-y parsing? maybe earley?
02:37:17 <augur> kvelicka: ok but i mean, what are these markers that you seem to want to be super-stateful about?
02:37:45 <kvelicka> the structure of the log is that there are certain "events" called EVENT_BLOCK_MARKER that contain the information on how many events it contains and which HEC they belong to
02:38:05 <kvelicka> and I want to annotate every event with its corresponding HEC
02:38:55 <augur> example of the sort of behavior you want?
02:38:59 <augur> input + output?
02:39:24 <ClaudiusMaximus> IO is overkill if you just need to keep track of some state, why not use State monad
02:39:50 <kvelicka> so my idea was to use a IORef that holds a (Maybe Int, Integer) which says which HEC the event belongs to (if any, some don't) and the Integer says where the block ends (in bytes)
02:39:59 <augur> as perverse as this sounds, i tend to thread state manually :x
02:40:29 <kvelicka> hmm, maybe, I'm not too knowledgeable on Haskell yet :)
02:41:27 <kvelicka> however, the context that I'm trying to work in is already in a transformer
02:41:47 <kvelicka> the type is GetEvents a = ReaderT EventParsers Get a
02:42:06 <kvelicka> is it a good idea (or even possible) to slap some State on this as well?
02:56:20 <adimit> kvelicka: a relatively common pattern is the RWS (Reader Writer State) Monad transformer. So, yes, it is possible to "slap some State" on tihs.
02:56:24 <adimit> You should look into StateT.
02:56:39 <adimit> i.e. State is also a monad transformer, and you can build your Monad stacks pretty high.
02:56:50 <adimit> whether that's a terribly good idea is another question.
02:57:19 <adimit> but it certainly can be done, and I don't think you'll have to worry much as long as you don't stack like 6 or 7 different Monads…
03:39:55 <kvelicka> adimit: thanks, I'll look into it
03:40:21 <kuribas> Are there any haskell-mode maintainers active?
03:40:38 <kuribas> (for emacs)
03:55:49 <Pythonfant> kuribas: you should probably ask in #haskell-emacs where chrisdone and others are hanging around
04:02:11 <kuribas> Pythonfant: ok, thanks!
04:08:19 <BoR0> @hoogle makePar
04:08:22 <lambdabot> No results found
04:08:59 <BoR0> @hoogle forkIO
04:09:00 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
04:09:00 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
04:09:00 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
04:20:23 <friden> im in search of a method that looks in a list for the item that is the most like the searched item, even if there isn't an exact match in the list, and returns it
04:20:41 <friden> its sufficient if it only works on lists of strings
04:21:00 <friden> but i can't find any, did i just miss it or do i have to make one myself?
04:22:06 <annelies> minimumBy (\a b -> levenshtein a s `compare` levenshtein b s)
04:22:56 <friden> annelies: nice, i can build on that^^
04:23:23 <annelies> Probably not efficient, but I think you need a different data structure if you want it to be more efficient.
04:23:32 <friden> yeah
04:25:30 <friden> so now i just have to find or create a function that returns the distance between two strings, not in length but in similarity
04:25:56 <kuribas> friden: In such cases a trie can be very useful.
04:26:00 <annelies> yeah, levenshtein distance does that
04:26:24 <kuribas> http://en.wikipedia.org/wiki/Trie
04:26:27 <friden> oh that was an actual function?
04:26:34 <ClaudiusMaximus> minimumBy (comparing (levenshtein s)) -- assuming it's symmetric
04:26:46 <friden> i just thought it was an example, but oh, now i understand, i will research that further
04:26:50 <annelies> oh cool didn't know about comparing
04:27:08 <friden> comparing seems cool
04:27:31 <kuribas> maybe this?  http://hackage.haskell.org/package/bytestring-trie-0.1.4/docs/Data-Trie.html
04:30:57 <friden> im not really sure how to use that to get what i need :/
04:31:56 <pjdelport> friden: You can also state the above by saying: minimumBy (comparing (`levenshtein` s))
04:32:29 <pjdelport> Oh, ClaudiusMaximus beat me to it. :)
04:33:46 <friden> yeah, that seems a bit easier, but it was a fun read kuribas^^
04:34:59 <adimit> friden: If you are going to use bytestring-trie be sure *not* to use bytestrings to store textual (String) data. In particular, as soon as you're importing Data.ByteString.Char8, you're on the wrong path.
04:35:17 <adimit> You *can* convert Text strings to ByteStrings, and then use that as keys.
04:35:46 <friden> adimit: i think ill go with levenshtein, but thanks
04:35:49 <pjdelport> friden: There's an overview here of a whole bunch of string distance algorithms: http://ntz-develop.blogspot.com/2011/03/fuzzy-string-search.html
04:37:03 <adimit> friden: levenshtein is a string comparison algorithm, but you need a storage data structure, too. I think you're best served with either a list [Text], or a HashSet Text, from unordered-containers. Be sure to use Data.Text for string values, not String.
04:37:14 <adimit> (if you want efficiency. If not. Well. String is OK :-)
04:37:46 <Iceland_jack> If you're converting Text to ByteString (encoding) you should specify the encoding and go through Data.Text.Encoding, but it makes more sense to work with characters than bytes here
04:38:32 <adimit> indeed it does :-)
04:38:42 <pjdelport> friden: http://hackage.haskell.org/package/edit-distance has some optimized implementations you can use.
04:38:46 <adimit> Here's a library that does string edit distance on String data types: http://hackage.haskell.org/package/edit-distance
04:38:57 <adimit> (dunno if, and how well it works.)
04:39:51 <Iceland_jack> It claims to be optimized, only works for String though
04:40:18 <adimit> yeah, well. :-P
04:40:37 <adimit> I wonder if one could access the array data structures underlying Data.Text (more or less) directly.
04:41:46 <adimit> It seems Data.Text.Internal does expose the Array. neat.
04:53:06 <interweb> Hi , I'm new to haskell but know a little of Python . Which book or site is the best for me to start with haskell?
04:53:25 <adimit> interweb: learn you a haskell for great good, and real world haskell. Google knows 'em.
04:53:50 <mmmm> @where LYAH
04:53:51 <lambdabot> http://www.learnyouahaskell.com/
04:54:06 <Iceland_jack> interweb: what mmmm said
04:54:51 <kuribas> adimit: I liked RWH (http://book.realworldhaskell.org/), even if it's a bit outdated.
04:56:10 <adimit> kuribas: well, I learned Haskell with "A gentle introduction to Haskell" (which was not gentle.) So i can't say how newb-friendly RWH is, but it seems LYAH is more of a total newb's book, and I've used RWH as a reference sometimes. But yes, it's becoming outdated, especially the later chapter.s
05:01:58 <arossouw> just wondering if i could use bytestring readFile with the parser code i wrote, http://lpaste.net/108739
05:04:49 <Diskord> hey. I have an issue
05:04:56 <Diskord> hey people - I have an issue. I am running arch linux, and attempting to install xmonad-darcs. Tehre's one major problem - it basically refuses to get darc's dependency of deepseq - it finds it, but it rejects it. manually instlalling these, i'm not sure helps. Once i got it to work last night... despite having a completely legitimate ~/.xmonad/xmonad.hs every time I tried to recompile, it produced an error - the most recent being 'Relative is not in scope' -
05:04:56 <Diskord>  relating to the UpdatePointer action.
05:05:18 <Diskord> i've put that message in both this and the xmonad irc.. because I am not sure which place is better for it
05:07:25 <orbifx> has anyone installed their packages for dynamic linking?
05:07:48 <orbifx> i am trying to do so for pandoc and hakyll but many packages fail
05:10:16 <dreams> is the right side on: rev (x:xs) = rev xs ++ [x] equivalent to (rev xs) ++ [x] or rev (xs ++ [x]) ?
05:11:04 <ClaudiusMaximus> the first - function application binds tighter than any operator
05:11:24 <adimit> > reverse [1..3] ++ [10]
05:11:27 <lambdabot>  [3,2,1,10]
05:11:44 <adimit> > reverse $ [1..3] ++ [10]
05:11:46 <lambdabot>  [10,3,2,1]
05:12:39 <dreams> ClaudiusMaximus, adimit thanks.
05:39:44 <kuribas> adimit: I actually also learned haskell with the "gentle introduction".  I already knew some ocaml, so it wasn't a big leap.  But the monad part was totally incomprehensible.
05:40:06 <kuribas> adimit: I understood monad by reading the papers by SPJ.
05:40:26 <kuribas> But RWH is a much better introduction.
05:41:02 <hc> I remember reading the gentle introduction
05:41:11 <hc> I was confused by the "very simple state monad" they presented
05:41:16 <kuribas> The gentle introduction explains monads by beginning with the monad laws.  That's good to scare anyone.
05:41:28 <kuribas> yeah
05:41:37 <hc> I was still confused after implementing it myself ;)
05:41:48 <hc> Then I bought real world haskell, which I loved
05:44:33 <kuribas> The papers by SPJ are actually very clear.  He first many examples, like list monad, state monad, etc... and then shows that they follow the same structure.
05:45:04 <kuribas> The same way RWH explains monads (by introducing them only after the examples).
05:46:26 <adimit> yeah, there's a trend in haskell didactics to go for a definition, implementation and laws, and then say: now you know all there is to know! Good luck.
05:46:42 <adimit> I had trouble wrapping my head around iteratees for the longest time this way.
05:47:20 <adimit> Whereas (for example) iteratees aren't that hard to get, or that hard to use, and you don't need to be able to implement one in order to use one. (I konw am able to do both, but it *was* a pain in the beginning.)
05:49:43 <adimit> s/konw/now/ — my fingers hate me.
05:50:09 <latk> I remeber seeing something about using repa (or possibly accelerate) to do real time video processing, but now can't find it. Could anyone point me to it?
05:50:11 <dreams> Is there a way to count the number of reduction steps of a program in GHC?
05:51:12 <darthdeus> is there something like https://github.com/rizo/awesome-ocaml but for haskell?
05:51:20 <mmmm> dreams: You can in hugs
05:54:15 <pjdelport> darthdeus: That's a good question.
05:54:29 <darthdeus> pjdelport: there definitely should be :P
05:54:30 <dreams> mmmm: thanks, seems to be down http://cvs.haskell.org/Hugs/pages/downloading.htm
05:54:41 <darthdeus> I only know about this https://github.com/grsmv/haskell-bookmarks
05:54:44 <darthdeus> and http://www.dohaskell.com/
05:56:21 <pjdelport> http://dev.stephendiehl.com/hask/ is probably relevant too
05:56:36 <kuribas> http://www.haskell.org/haskellwiki/Haskell
05:56:49 <bergmark> dreams: now where is it...
05:57:04 <bergmark> dreams: https://github.com/bitemyapp/learnhaskell
05:59:16 <arossouw> where can i learn more on let vs where, i'm not sure when let is better than where or vice versa
05:59:57 <dreams> bergmark: meh.
06:13:49 <pjdelport> arossouw: It's largely a question of style, though there are sometimes cases where one can be more or less efficient than the other, when they create bindings at different levels.
06:14:24 <pjdelport> arossouw: http://www.haskell.org/haskellwiki/Let_vs._Where
06:15:08 <arossouw> thank you
06:15:31 <arossouw> i'll have to experiment some more :-)
06:17:29 <magicman> ... are lens tutorials the new monad tutorials yet?
06:18:00 <arossouw> got this from stackoverflow, not sure how it works entirely, but its very fast http://lpaste.net/108740
06:18:41 <Peaker> pjdelport: I don't think where/let have perf. difference when both possible
06:19:07 <Peaker> arossouw: I prefer "where" everywhere except in "do" when I want access to bound names
06:19:41 <Peaker> "let" is syntactically heavier than "where", and "where" is applicable in more contexts (except lambda)
06:23:59 <arossouw> ok, noted
06:24:49 <a___> is anyone running ghci on openbsd 5.5/i386?  trying to work around dependency issues (integer-gmp, hs-vector-0.10.0.1p0)
06:28:49 <spin51> @putStr "hello"
06:28:50 <lambdabot> Unknown command, try @list
06:28:55 <spin51> @list
06:28:56 <lambdabot> What module?  Try @listmodules for some ideas.
06:29:36 <spin51> >putStr "hello"
06:31:36 <fizbin> Is there any consensus on which of the way too many things on http://www.haskell.org/haskellwiki/Command_line_option_parsers I should use?
06:32:10 <fizbin> I don't want to pick the wrong one and discover three months from now that "everybody knows" you should use library Foo, not library Bar.
06:32:22 <spin51> > "12" + "34"
06:32:24 <lambdabot>  No instance for (GHC.Num.Num [GHC.Types.Char])
06:32:24 <lambdabot>    arising from a use of ‘GHC.Num.+’
06:32:35 <fizbin> > "12" + +"34"
06:32:37 <lambdabot>  <hint>:1:8: parse error on input ‘+’
06:32:47 <fizbin> > "12" ++ "34"
06:32:49 <lambdabot>  "1234"
06:33:09 <spin51> > > ( \ a -> case a of minBound -> "0"; maxBound -> "x" ) False
06:33:11 <lambdabot>  <hint>:1:1: parse error on input ‘>’
06:33:17 <spin51> > ( \ a -> case a of minBound -> "0"; maxBound -> "x" ) False
06:33:19 <lambdabot>  "0"
06:34:02 <spin51> > let f a = case a of minBound -> "0"; maxBound -> "x"
06:34:04 <lambdabot>  not an expression: ‘let f a = case a of minBound -> "0"; maxBound -> "x"’
06:34:20 <spin51> > f a = case a of minBound -> "0"; maxBound -> "x"
06:34:21 <lambdabot>  <hint>:1:5: parse error on input ‘=’
06:34:26 <arossouw> wow, bytestrings seems fast
06:35:37 <mmachenry1> Does anyone know why I get type sound programs for parsing JSON from both lazy and strict byte strings but only lazy parse properly in my test cases? http://lpaste.net/108596
06:35:54 <spin51> > ( \ a -> case a of minBound -> "0"; maxBound -> "x" ) False
06:35:56 <lambdabot>  "0"
06:36:00 <spin51> > ( \ a -> case a of minBound -> "0"; maxBound -> "x" ) True
06:36:02 <lambdabot>  "0"
06:36:17 <spin51> why does it print "0" in both cases?
06:36:31 <hc> minBound always mathces; you need a guard
06:36:57 <hc> http://www.haskell.org/haskellwiki/Case section 2.2.1
06:37:17 <fizbin> spin51: "minBound" in the case statement is a pattern.
06:37:34 <fizbin> spin51: Not the value refering to the outside world that you want it to be.
06:38:18 <fizbin> If you try that in a ghci with the appropriate warning flags, you'll get a warning that you're shadowing minBound in your case statement.
06:38:48 <spin51> an, ok, still confusing
06:40:01 <fizbin> mmachenry1: What is the definition of decode' and decodeStrict ?
06:40:22 <fizbin> Oh, wait, those are from Aeson.
06:40:27 <mmachenry> fizbin: The are in Data.Aeson http://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson.html
06:40:29 <saep> > (\a -> case () of _ | minBound == a -> "0" ; _ -> "x") True
06:40:31 <lambdabot>  "x"
06:44:11 <paolobento> > y = y + 1
06:44:12 <lambdabot>  <hint>:1:3: parse error on input ‘=’
06:44:35 <paolobento> `=`
06:49:10 <fizbin> mmachenry: Man it takes a long time to rebuild my cabal sandbox with aeson...
06:49:49 <adimit> rebuilding takes time for pretty much all non-trivial packages.
06:50:19 <mmmm> too long
06:50:32 <orbifx> adimit: sucks
06:50:36 <ab9rf> the ultimate goal of any development environment is to maximize build time.
06:50:39 <mmachenry> fizbin: Well I certainly appreciate the effort.
06:50:51 <adimit> fizbin: you can try cabal install -j 4 or so (depending on your number of processors.)
06:51:23 <adimit> or just -j should suffice, it'll make as many jobs as you have cores. (requires a newish cabal, though.)
06:51:29 <mmachenry> fizbin: I'm pretty stumped. The fact that lazy works, strict doesn't, but that readIncoming :: "Strict ByteString" -> IncomingMessage works fine in my server. So weird.
06:52:13 <adimit> (and it won't speed up package-internal builds; it'll just parallel-build packages that don't depend upon each other.)
06:53:39 <fizbin> mmachenry: Did you leave out the "MsgGet" constructor accidentally?
06:54:02 <gogohome> i want learn haskell, i don’t know the way.
06:54:18 <adimit> @where LYAH
06:54:19 <lambdabot> http://www.learnyouahaskell.com/
06:54:31 <adimit> gogohome: have fun.
06:54:41 <gogohome> adimit: what mean?
06:54:59 <adimit> go to that web site, and get crackin ;-) Learning Haskell is much easier nowadays.
06:55:08 <fizbin> mmachenry:  Actually, even after adding in MsgGet, it won't compile: no instance for (FromJSON B.ByteString)
06:55:09 <gogohome> oh thanks
06:55:20 <mmachenry> fizbin: Possibly. Yes. It's just an emtpy one. I was trying to simplify the code.
06:55:33 <pjdelport> gogohome: Try https://en.wikibooks.org/wiki/Haskell too
06:55:33 <gogohome> adimit: how can i install haskell?
06:55:54 <mmachenry> You can actually just delete that line, Fizbin, I will update the code now
06:55:55 <gogohome> thanks pjdelport
06:56:06 <fizbin> Okay, MsgGet is easy enough to add, but what about (FromJSON B.ByteString) ?
06:56:17 <fizbin> gogohome: See http://www.haskell.org/platform/ for how to install
06:56:39 <adimit> gogohome: what fizbin said.
06:56:50 <mmachenry> fizbin: I removed the line and it compiles.
06:57:04 <gogohome> installing?
06:57:56 <mmachenry> fizbin: I think I must have some instance of (FromJSON B.ByteString) already imported since I was never told by the compiler that one was missing.
06:58:23 <mmachenry> fizbin: Really that ascribe on action could be any string type, Haskell just doesn't want it to be ambiguous.
06:58:55 <gogohome> brew install haskell-platform <——— i can install haskell like this?
06:59:34 <adimit> gogohome: if you're on a mac, probably.
06:59:34 <fizbin> mmachenry: Hrm. I changed it to (action :: String) and "tests" is now two Just objects.
06:59:41 <gogohome> yes
06:59:56 <gogohome> but i don’t know ghc and ghci
07:00:06 <Exio4> @pl f x y z = x+y+z
07:00:06 <lambdabot> f = ((+) .) . (+)
07:00:21 <adimit> those are the compiler and interpreter, respectively. brew install haskell-platform *should* install those for you.
07:00:23 <adimit> maybe.
07:00:53 <mmachenry> fizbin: Woa, really?
07:00:56 <mmachenry> One sec
07:01:03 <ab9rf> @pl f op x y z = x `op` y `op` z
07:01:03 <lambdabot> f = (.) =<< (.)
07:02:07 <fizbin> mmachenry: In any case, I think there might be something weird with your (FromJSON B.ByteString) instance. I suspect that's what's tripping you up.
07:02:13 <adimit> pl's ascii art is sometimes rather cute.
07:02:15 <mmachenry> fizbin: It's not for me! What the heck?
07:05:23 <mmachenry> fizbin: I updated. Is that what you have?
07:05:48 <mmachenry> fizbin: I get the same behavior with action::String. I, in fact, had that once upon a time in this program.
07:06:40 <fizbin> mmachenry:  http://lpaste.net/108744 is what I have.
07:07:46 <fizbin> Now we... I dunno. Check library versions?
07:08:04 <mmachenry> fizbin: I copied your code and I got [Just MsgPing,Nothing]. How is this possible?
07:08:21 <mmachenry> fizbin: What version of Data.Aeson are you using?
07:09:36 <fizbin> mmachenry: http://lpaste.net/108744 updated with library versions. aeson is 0.8.0.0
07:10:36 <mmachenry> fizbin: Oh damn. Loading package aeson-0.6.2.1 ... linking ... done.
07:10:38 <fizbin> Also, bytestring is 0.10.4.0
07:11:21 <mmachenry> fizbin: Perhaps my version of Aeson has a bug?
07:12:34 <fizbin> Maybe. If you have an old bytestring, you might try aeson 0.7.0.0
07:12:56 <gogohome> haskell
07:12:57 <gogohome> -bash: haskell: command not found
07:13:20 <gogohome> how can i do? i install haskell by ‘brew install haskell-platform’
07:13:29 <Clint> what are you trying to achieve
07:13:35 <fizbin> gogohome: Are you trying to run haskell without going and reading the LYAH site you were pointed at earlier?
07:14:07 <fizbin> Please. DO NOT attempt to learn haskell just by starting it and poking. Go read the "Learn You A Haskell" site.
07:14:34 <gogohome> ok fizbin
07:14:36 <mmachenry> fizbin: I should I manage all these updates to new libraries? I actually just did a cabal install of aeson. It got be what I guessed was probably the newest version.
07:14:37 <fizbin> The command you want is "ghci", but you'll likely find that frustrating at first.
07:14:46 <adimit> gogohome: here's a starter: http://learnyouahaskell.com/starting-out
07:14:51 <gogohome> ghci
07:14:53 <gogohome> thanks
07:14:55 <gogohome> ok
07:15:56 <gogohome> oh yes, but how can i exit from ‘Prelude'?
07:16:09 <jomg> gogohome: :q
07:16:12 <fizbin> gogohome: Ctrl-D or :q
07:16:18 <gogohome> thanks
07:16:44 <gogohome> i will use eclipse + haskell. is it good?
07:16:54 <fizbin> mmachenry: Also note that the changelog for aeson 0.7.0.0 mentions fixing bugs in "decodeStrictWith"
07:17:40 <mmachenry> fizbin: I will check that out now.
07:17:59 <fizbin> gogohome: It's tolerable, but for starting out I find that what you really want is a tutorial (like learnyouahaskell) and a simple editor. Heck, the default Mac OS text editor is good enough at first.
07:18:21 <adimit> gogohome: whatever you use will probably be fine, as long as it's not Word. You just need a plain text editor. TextMate, SublimeText, Whatever OS X uses as a plain text editor, they should all work.
07:18:36 <mmachenry> fizbin: Thanks so much for the help.
07:18:42 <gogohome> ok thaks fizbin and adimit
07:18:51 <mmachenry> fizbin: Glad it's a bug in Aeson and not "I'm crazy" :)
07:19:55 <fizbin> Well, you never know. It could always be both an Aeson bug and *also* that your computer is possessed of demons. Just because there is an aeson bug that might be the culprit, until you've upgraded you can't be sure.
07:22:01 <mmachenry> fizbin: You are a true Baysian.
07:22:34 <mmachenry> fizbin: Also now I will be looking over shoulder.
07:23:00 <ChanderG> Hello everyone. I have 2 folders src and tests. How do I import a module say Hello in src directory from a file in the tests directory?
07:23:31 <fizbin> ChanderG: Have you written a .cabal file yet?
07:23:47 <ChanderG> yes
07:24:45 <fizbin> ChanderG: Okay, then assuming that Hello is an "exported module" of your library, in your test code you can just "import Hello" to load it.
07:25:20 <ChanderG> How do you export a module?
07:25:28 <fizbin> That is, import it in test code just as in non-test code.
07:26:04 <fizbin> Sorry, an "exposed module". Can never remember cabal nomenclature.
07:26:22 <fizbin> Anyway, in your cabal file, you have the section "library" ?
07:26:48 <fizbin> In that "library" section, there should be a list setting called "exposed-modules:"
07:26:58 <fizbin> Just add Hello to that list.
07:27:08 <ChanderG> fizbin:  No. I only have an executable
07:27:32 <fizbin> Is this executable your test?
07:28:02 <ChanderG> fizbin: the executable is the code in the src, the one going to be tested
07:28:29 <moghedrin> Is there a convenient http library that will let me send http requests to a linux socket?
07:29:06 <Clint> you mean a unix domain socket?
07:29:06 <fizbin> Okay, so you have two choices: add a library and link the test up with that library, or in your Test-Suite section tell it to use source in both "src" and "tests"
07:29:18 <moghedrin> Clint: Aye.
07:29:46 <fizbin> ChanderG: At this point, I'd go with saying "hs-source-dirs: src, tests" in your Test-Suite section
07:31:11 <ChanderG> fizbin:  I tried the hs-source-dirs, but it is unable to find the module.
07:31:20 <Clint> moghedrin: i doubt it, but you could probably improve the proxy support in http-client
07:31:51 <ChanderG> fizbin: I havent written "exposed" anywhere though.
07:31:51 <fizbin> ChanderG: For example, see how lens.cabal in line 350 has the "properties" test-suite use multiple source dirs to access modules that aren't exposed: https://github.com/ekmett/lens/blob/master/lens.cabal
07:32:12 <fizbin> ChanderG: In your .hs source files, do you ever have a "module" line?
07:32:43 <mmachenry> fizbin: One more question. Do you have any idea why the readIncoming in by code would not be susceptible to the bug we were seeing? This actually works in my real server. But readIncoming doesn't pass any test cases.
07:32:44 <fizbin> Because if you never have a "module" line in your modules then, yeah, you can't import them.
07:33:16 <ChanderG> fizbin: Yes.  it starts with module <Name> where
07:33:28 <fizbin> mmachenry: No idea; that would require more knowledge of what the bug in readStrictWith that was fixed in aeson 0.7.0.0 is.
07:33:48 <mmachenry> fizbin: Fair enough. Again thanks for your time.
07:35:03 <fizbin> ChanderG: At this point then, I'd try putting your whole directory tree somewhere where people can look through it, on github or elsewhere. If it's proprietary code, try to make the smallest possible example showing it not working.
07:35:45 <fizbin> ChanderG: I know I've found that the process of removing all proprietary knowledge from the bit that isn't working to make an example I can share is often sufficient to solve my problem.
07:36:54 <ChanderG> fizbin: Actually I am just starting out. And it is on github : https://github.com/ChanderG/scheme-compiler
07:37:42 <ChanderG> fizbin: There are small changes, it is the last commited version
07:39:11 <fizbin> ChanderG: I see. And the change is then that in Core.hs you want to import something new?
07:39:37 <fizbin> I'll note that in your cabal file, line 72 is "hs-source-dirs:       tests, ."
07:39:53 <fizbin> Instead of what I would expect it to be: "hs-source-dirs:       tests, src"
07:40:16 <ChanderG> fizbin: No I tried  that too.
07:40:22 <moghedrin> Clint: Grah. Okay, thanks.
07:41:44 <abhi> hi haskellites
07:42:10 <fizbin> ChanderG: Ah. Tell me, when "Core.hs" does "import Main", do you expect to get the module that's in tests/testrunner.hs or the one that's in src/Main.hs ?
07:42:27 <fizbin> Because it isn't clear to me how ghc is supposed to know which one you want.
07:43:10 <ChanderG> fizbin: Ya, I want the one in src. I know main does not work. I tried renaming the module to Src.Main but even that does not work
07:45:01 <ChanderG> fizbin: I changed the module line of src/Main.hs to Src.Main and used the same in tests/Core.hs
07:46:23 <abhi> what r u talkign about... i thought its importance is quite self evident
07:48:01 <Exio4> @src intersperse
07:48:02 <lambdabot> intersperse _   []     = []
07:48:02 <lambdabot> intersperse _   [x]    = [x]
07:48:02 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
07:50:19 <fizbin> ChanderG: Looking at how to make it work...
07:50:42 <griotspeak> Hello
07:51:05 <griotspeak> I am having some trouble installing CCA (as a dependency of Euterpea)
07:51:21 <griotspeak> I am using GHC for Mac
07:52:00 <griotspeak> I keep geting ExitFailure 1
07:54:33 <ReinH> griotspeak: can you pastie the output please?
07:54:38 <griotspeak> ok
07:55:20 <griotspeak> http://lpaste.net/108747
07:57:05 <ChanderG> fizbin:  Thanks for looking into it. I have to go. I will be back in 20 min. If you find the answer or need to leave it would be great if you could message it here(if it is possible) or worst case open an issue on github(or something). Thanks a lot for your time.
07:58:16 <fizbin> ChanderG: I'll send you a github pull req. most likely
08:07:30 <maxiepoo> what's the cabal command to print all packages as a dot dependency tree?
08:08:44 <ReinH> griotspeak: it just looks like there's a bug in CCA (a type error) :(
08:08:52 <griotspeak> aw
08:08:59 <griotspeak> well at least it isn't me
08:09:31 <ReinH> maybe try an earlier version? I dunno. :/
08:09:37 <maxiepoo> or is it not built in to cabal?
08:09:52 <ReinH> maxiepoo: it might be in ghc-pkg?
08:10:12 <griotspeak> (I don't know things. I am currently learning haskell)
08:10:45 <maxiepoo> ah yes
08:10:49 <maxiepoo> it's ghc-pkg dot
08:10:58 <maxiepoo> thanks!
08:12:19 <ChanderG> fizbin: Are you there? I am back.
08:12:54 <fizbin> ChanderG: Writing the commit message now...
08:14:09 <ReinH> griotspeak: Ah. Hmm. I'm not seeing CCA as a dependency here https://github.com/Euterpea/Euterpea/blob/master/Euterpea.cabal
08:14:52 <griotspeak> odd. I cloned and then did cabal install
08:15:40 <ReinH> griotspeak: That is odd :(
08:15:58 <ReinH> griotspeak: I've never tried to install it before, but perhaps someone else might have an idea
08:17:30 <griotspeak> Here is the log from the first time that I tried to install http://lpaste.net/108748
08:17:51 <griotspeak> Looks like that might have been pulled in by an OpenGL related package?
08:22:14 <fizbin> ChanderG: sent pull req
08:22:58 <ChanderG> fizbin: Cool. I will check it now.
08:31:50 <griotspeak> Many thanks ReinH and maxiepoo
08:36:58 <monochrom> hahaha, accursed unutterable perform IO
08:38:26 <ChanderG> fizbin: Thank you. Working now. Thanks for helping out.
08:45:15 <stolaruk> I have a handful of IntMaps that I pass around in the State monad. Furthermore, each IntMap is inside its own TVar, as my program is concurrent and many threads need to access the tables. Here is my question (just want to make sure I understand STM correctly). If I simply need to lookup some values in a number of tables, then I can write a STM transaction that grabs the tables in the TVars, which then become available outside the STM monad
08:45:15 <stolaruk>  when I use "atomically"... right? Because the tables are immutable, I can operate on the tables outside the STM transacion?
08:46:13 <Cale> stolaruk: sure
08:46:25 <stolaruk> ok, right
08:47:24 <Cale> stolaruk: It's just that you might want to be careful if you need to make sure you have the latest version of the IntMap from the TVar
08:47:42 <Ankhers> Where could I find information on the progress of the next platform?
08:48:42 <stolaruk> Now, if I need to lookup a value in one of the IntMaps, do some operations, and update the IntMap, then the update needs to be inside the same transaction that the lookup is in, right? This is assuming that the update operation depends on nothing having changed in the IntMap from the point in time that the IntMap was read.
08:49:05 <Cale> Ankhers: http://www.haskell.org/pipermail/haskell/2014-July/024276.html
08:49:17 <Cale> stolaruk: right
08:49:18 <Ankhers> Cale: Thanks!
08:49:24 <prooftechnique> What text representation should I use? On the one hand, I'm constructing URLs to interact with JSON endpoints, which feels like Text (and Builders are nice), but parseUrl insists on String, so I can't decide if it's better to just work with Strings throughout. Or is there a good motivation for ByteStrings in this case?
08:49:26 <stolaruk> Cale: Ok, thanks
08:49:57 <stolaruk> rock on
08:50:42 <Cale> prooftechnique: For small things like URLs, I usually wouldn't expect the difference between Text and String to matter so much.
08:51:12 <monochrom> to a large extent, URL is bytes
08:51:28 <Cale> Yeah, that is a good point.
08:51:39 <stolaruk> ByteString is best for binary data, no?
08:52:00 <Cale> stolaruk: that's right
09:05:35 <adimit> Data.HashSet (unordered-containers) does not instantiate Functor or Traversable… Why not? Is it an oversight on tibbe's part (or just a case of not yet implemented) or is there some theoretical reason for it?
09:06:00 <adimit> Ah. Wait.
09:06:06 <adimit> of course. The Hashable and Eq constraints.
09:06:08 <opqdonut> admin: it's the Hashable a, Eq a constraint
09:06:09 <opqdonut> yep
09:06:22 <adimit> dumb question. Sure. duh.
09:07:23 <adimit> *sigh* that still leaves me with my HashSet (f a) that I'd like to turn into f (HashSet a)
09:08:41 <josephle> if only HashSet was traversable
09:09:15 <adimit> yeah, but it can't be, because of those bloody constraints (which it has to enforce, I see why.)
09:09:36 <josephle> that's a shame
09:10:26 <adimit> I mean, it should be almost trivial to re-implement something along the lines of traverse and sequenceA for HashSet.
09:10:56 <opqdonut> yeah, and the library could have those
09:11:18 <adimit> but without going into details, it would be ineficcient: fromList . sequenceA . toList.
09:11:30 <adimit> opqdonut: well, it does have its own map.
09:11:43 <Simec> Anyone here develop professionally on haskell ?   i need someone for fix me a software
09:12:06 <opqdonut> admin: you mean there's a more efficient implementation? fromList . sequenceA . toList sounds pretty nice if the lists fuse, and they should
09:12:22 <Lowl3v3l_> Simec, what do you mean by "fix"?
09:12:46 <Simec> correct something that is supposed to work in a way, but work in another
09:13:10 <Simec> if anyone develop professionally in haskell, pm me with the hourly rate wanted
09:13:16 <adimit> opqdonut: you're right; I should stop worrying and just benchmark if it becomes a problem.
09:13:57 <Lowl3v3l_> Simec, why dont you ask the developer ? o.O
09:14:10 <Simec> cause went "missing"
09:17:28 <BeardedCoder> ha
09:21:43 <Fuuzetsu> Simec: are you at liberty to say what software?
09:22:05 <Simec> sure, i am
09:22:16 <Simec> proxypool
09:26:51 <Fuuzetsu> doesn't seem like I can help with that but maybe you should open an issue describing a problem so any potential takers can read on it
09:28:41 <Simec> Fuuzetsu, my intention was to find someone able to professionally develop on haskell, talk to him in private, agree on the "payment", and then proceed with the patch
09:29:03 <Simec> with some kind of discretion
09:29:07 <pjdelport> :t S.foldr (liftA2 S.insert) (pure S.empty)
09:29:08 <lambdabot> (Applicative f, Ord a) => S.Set (f a) -> f (S.Set a)
09:29:34 <mmachenry> I think I might have tiptoed into "cabal hell" accidentally by doing a "cabal install" Aeson which upgraded my Aeson (and thus ByteString) but I might have not updated something else that requires ByteString
09:29:45 <mmachenry> I get GHCi runtime linker: fatal error: I found a duplicate definition for symbol
09:29:45 <mmachenry>    __hs_bytestring_int_dec
09:29:55 <adimit> pjdelport: interesting!
09:29:55 <mmachenry> What should I do?
09:29:58 <Fuuzetsu> well, that's up to you of course but it might be easier to find someone if you describe the problem and then put a bounty on it if you will, might be worth trying if you don't find someone to do it ‘in private’
09:30:09 <pjdelport> adimit: You can use the above as a poor man'- traverseSet / traverseHashSet
09:30:28 <pjdelport> s/'-/'s/
09:30:34 <adimit> pjdelport: any idea how it would stack up against fromList . traverse . toList ?
09:30:53 <Fuuzetsu> mmachenry: IIRC upgrading bytestring is always a no-no
09:31:00 <pjdelport> adimit: Should be the same, modulo avoiding the list roundtrip.
09:31:07 <mmachenry> Fuuzetsu: Really? Aeson did it for me :(
09:31:29 <pjdelport> adimit: sequence for lists is of course just foldr (liftA2 (:)) (pure []) :)
09:31:46 <adimit> pjdelport: yes, correct.
09:31:49 <Fuuzetsu> maybe I'm wrong
09:32:26 <mmachenry> I had Aeson 0.6 and it had a bug I ran into. I did cabal update, and installed aeson (which upgraded it since it was already installed)
09:32:37 <mmachenry> Now I have a duplicate byte string issue.
09:32:49 <adimit> pjdelport: now that I look at it. the list roundtrip shouldn't cost too much… Hm. I'll see which one fits better into my code. But that's a very interesting line, thanks for pointing it out :-)
09:33:15 <mmachenry> Perhaps I should reinstall everything with this command from stackoverflow?
09:33:16 <mmachenry> http://stackoverflow.com/questions/6905163/whats-the-best-workaround-for-not-having-cabal-upgrade
09:33:39 <nh2> hi, anybody volunteering to reproduce a small cabal bug for me with ghc 7.8?
09:34:20 <int-e> nh2: that's too vague, I think
09:45:26 <Fuuzetsu> just post your problem up nh2
09:46:08 <Fuuzetsu> mmachenry: could work I suppose
09:50:43 <dreams> when you pattern match a list with [], does that make it strict? i.e. the list is evaluated.
09:50:54 <monochrom> yes
09:51:00 <dreams> so f xs [] = xs.
09:51:14 <monochrom> read my http://www.vex.net/~trebla/haskell/lazy.xhtml
09:52:04 <HeladoDeBrownie> dreams, not the entire list though. You just need to evaluate it enough to know it is or is not [].
09:52:17 <dreams> say we have f [1,2,3,4] [x+y,4,etc]. Then the latter list is evaluated including the sub-expressions?
09:52:27 <HeladoDeBrownie> dreams, not *necessarily* the whole list, that is. The match could fail and only have evaluated the first cons cell
09:52:31 <monochrom> no
09:52:34 <monochrom> read my http://www.vex.net/~trebla/haskell/lazy.xhtml
09:53:23 <dreams> HeladoDeBrownie: I am profiling two functions, and when you pattern match against empty list, space is way more efficient.
09:53:37 <HeladoDeBrownie> dreams, what are the functions?
09:54:15 <dreams> HeladoDeBrownie: let me paste, can you recommend a paste site? some pastebins are not recommended but I can't remember which.
09:54:25 <prooftechnique> @paste
09:54:25 <lambdabot> Haskell pastebin: http://lpaste.net/
09:54:28 <HeladoDeBrownie> dreams, see the topic
09:54:31 <dreams> prooftechnique: thanks.
09:57:32 <dreams> HeladoDeBrownie: http://lpaste.net/108757
09:58:07 <dreams> HeladoDeBrownie: I don't get the idea of passing an empty list to shunt. does that make it strict or what's going on?
09:59:49 <HeladoDeBrownie> dreams, why do you guess that?
10:00:14 <monochrom> that is more about (...(x0 ++ x1) ++ x2) ++ ...) being inefficient
10:00:21 <prooftechnique> Have you compared with reverse (x:xs) = x : reverse xs?
10:00:41 <prooftechnique> I think this is just cons vs concatenation
10:00:51 <dreams> prooftechnique: no. but I have profiled both functions, and the space difference is huge, very huge.
10:01:14 <c_wraith> prooftechnique: that definition looks a lot like id
10:01:20 <HeladoDeBrownie> I think the first reverse is quadratic, no? Because it keeps having to traverse the entire list to replace its []
10:01:29 <dreams> HeladoDeBrownie: yes it is.
10:01:29 <monochrom> yes
10:01:33 <prooftechnique> c_wraith: Hahaha, yeah, you're right
10:01:40 <prooftechnique> Totally didn't think it through
10:01:54 <HeladoDeBrownie> dreams, try hand-evaluating fasterReverse to see what's going on. Do you know how to do that?
10:02:01 <pjdelport> dreams: The first version you have has to allocate a new copy of the list and walk the entire previous step's list for every single element.
10:02:11 <monochrom> it also uses more space because you can't get rid of the intermediate (...(x0 ++ x1) ++ x2) ++ ...) immediately as you convert it back to a good list
10:02:43 <dreams> HeladoDeBrownie: I get stuck on how much to evaluate with pattern matching.
10:03:04 <pjdelport> dreams: So it's O(N²), while the second version only walks the list (and allocates a new one) once, making it O(N).
10:03:28 <pjdelport> It has nothing to do with pattern matching, but with the algorithm.
10:03:51 <c_wraith> dreams: as for why shunt is passed an empty list - its first argument can be thought of as "the part of the list I've reversed so far", and the second argument as "the part of the list I haven't reversed yet"
10:04:01 <HeladoDeBrownie> dreams, well matching against [] is easy: You need only evaluate the outermost constructor to find out which it is. So if you have x:y:z, you only evaluate the first (:), not even x yet.
10:05:18 <HeladoDeBrownie> dreams, matching (x:xs) also only evaluates that far, but if the right-hand-side needs x or xs then those will be evaluated as needed.
10:05:44 <pointed_set> ... unless you matched ~(x : xs)
10:06:03 <dreams> HeladoDeBrownie: what does it mean to evaluate (:) ?
10:06:21 <HeladoDeBrownie> dreams, you *just* figure out what the actual constructor is, not what its arguments are.
10:06:37 <HeladoDeBrownie> A list's constructor is either [] or (:)
10:07:15 <pointed_set> dreams: The list has 2 possible states: a [] and a list (:) x xs. It "evals up to constructor".
10:07:28 <eacameron> I'm currently hacking and slashing and I really just need to force a file write fully complete before moving on with ByteString.Lazy.writeFile
10:07:31 <eacameron> how can I do that?
10:07:59 <c_wraith> eacameron: it...  should do that.
10:08:02 <maxiepoo> so, upper bounds
10:08:19 <HeladoDeBrownie> dreams, for that matter you never actually need to evaluate the elements themselves when reversing, just the list's structure, its (:)s and []
10:08:26 <c_wraith> eacameron: if it doesn't write completely, something is terribly broken.
10:08:27 <pointed_set> eacameron: I thought, all output operations (resulting with IO ()) are agressive.
10:08:35 <eacameron> c_wraith: I'm currently writing the file then immediately reading it, but it gives a file locked error
10:08:42 <maxiepoo> for a package that's most recent version is 1.3, should I make the upper bound <1.4 or <2 or does it depend on the package?
10:08:52 <dreams> HeladoDeBrownie: Ah, so if we ignore [] and (:) for a moment and treat them like: data List a = Cons a (List a) | Nil .. then (x:xs) will figure out that there exist a Cons there and not Nil?
10:08:58 <c_wraith> eacameron: file locked...  are you on windows?
10:09:02 <pointed_set> eacameron: you need to READ fully before
10:09:04 <eacameron> no linux
10:09:15 <Cale> dreams: Yes, that's right
10:09:17 <HeladoDeBrownie> dreams, correct, although it could be a Nil too in which case the pattern fails
10:09:20 <eacameron> pointed_set: what do you mean?
10:09:21 <c_wraith> eacameron: then...  writing to a file and locking it are totally unrelated
10:09:38 <c_wraith> eacameron: if you're getting errors that the file is locked, something else is going on.
10:09:47 <pointed_set> eacameron: do text <- readFile "x"; length text `seq` writeFile "x" text
10:10:24 <monochrom> eacameron: what are you using to write that you want to force? what is the actual code?
10:10:51 <eacameron> hmmm. could it be that there was an exception being thrown after reading the file?
10:11:05 <eacameron> then subsequent writes would fail?
10:11:06 <pjdelport> note that *readFile* is lazy
10:11:10 <dreams> HeladoDeBrownie: Ah ok. thanks.
10:11:25 <pjdelport> If you try to write back to the same file before forcing the entire read, strange things will probably happen.
10:11:25 <monochrom> it could be literally anything at this stage of no code.
10:11:29 <pointed_set> Your readFile is lazy and doesn't do anything when called - unless you force materialization. The easy way to materialize is to calc length (works for String, at least)
10:11:43 <c_wraith> pointed_set: that's irrelevant to the question as asked, though
10:11:46 <dreams> c_wraith: by the way, I keep reading about efficiency, and passing an empty list comes up a lot.
10:11:57 <monochrom> nothing is irrelevant at this stage of no code
10:12:17 <HeladoDeBrownie> dreams, (though of course if you match Nil and *then* Cons, by the time you match Cons you've already eliminated the possibility of Nil)
10:12:59 <c_wraith> dreams: in any case where that's happening, it's usually being used as an accumulator.
10:13:10 <eacameron> do {io $ store testData; io $ load testData; throwSomething}
10:13:31 <monochrom> where do io, store, and load come from?
10:13:37 <pointed_set> c_wraith: I got the error of his when I tried to write at the place read "before". The (length text `seq` writeFile ...) worked for me. Its the most popular error on writing a file after reading it.
10:13:42 <monochrom> what is throwSomething doing there?
10:14:09 <annelies> throwing something
10:14:17 <eacameron> monochrom: io is just liftIO, load and store are wrappers around ByteString.Lazy.readFile and writeFile
10:14:30 <eacameron> throwSomething is because my code to work through the data is throwing
10:14:37 <eacameron> something
10:14:59 <monochrom> then it is what pointed_set said about not reading the whole file. the file is still opened for reading
10:15:06 <pointed_set> eacameron: try make (length text `seq` ...)
10:15:19 <pointed_set> We file wont close unless read to end
10:15:22 <monochrom> no, wait, I misread
10:15:39 <eacameron> hmm, so the throw leaves the file unclosed
10:15:43 <eacameron> that makes sense
10:15:49 <eacameron> and subsequence operations fail
10:16:06 <eacameron> unclosed = open
10:19:09 <monochrom> I hate guessing.
10:23:31 <Fuuzetsu> are there any good guides on QuickCheck, specifically writing QuickCheck instances? It feels like I'm winging it way too much and I want to learn QC better
10:24:25 <imalsogreg> Fuuzetsu: I liked this: http://www.scs.stanford.edu/14sp-cs240h/slides/testing.html
10:32:55 <predator217> Fuuzetsu: depends on your taste but i found the quickcheck papers actually quite readable
10:33:23 <predator217> Fuuzetsu: or fpcomplete: https://www.fpcomplete.com/user/pbv/an-introduction-to-quickcheck-testing
10:34:26 <predator217> the fpcomplete article links the two QC papers at the bottom
10:42:50 <Fuuzetsu> predator217: ok, thanks; I read the first link, going to read fpcomplete stuff and maybe papers too
10:44:25 <limepod> can anyone recommend some excecises to get a better grasp of applicatives and monads?
10:44:29 <timmy_tofu> I had a development flag, as do many... how can I get ghc-mod to observe this flag? I'm getting errors about things not being in scope that are imported within an #ifdef CPP block
10:44:53 <pjdelport> limepod: Start with Functor, then look at Applicative, then Monad.
10:44:56 <timmy_tofu> Cabal builds fine, can't find the ghc-mod check option to pass this on
10:45:15 <limepod> I've got a decent grasp of functors
10:45:31 <limepod> and I can sort of use applicatives and monads
10:45:32 <Fuuzetsu> limepod: just write code
10:46:20 <pjdelport> limepod: Probably just play around with Applicative for a while: try to grok how it is just function application in general lifted to a functor.
10:46:21 <timmy_tofu> limepod: As you're looking at code - yours or otherwise - see how much of the explictly monadic stuff you can rewrite in applicative style
10:46:27 <pjdelport> :t ($)
10:46:28 <lambdabot> (a -> b) -> a -> b
10:46:32 <pjdelport> :t (<*>)
10:46:33 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
10:46:51 <pjdelport> > Just (+) <*> Just 2 <*> Just 3
10:46:53 <lambdabot>  Just 5
10:47:18 <pjdelport> > (++) <$> getLine <*> getLine
10:47:20 <lambdabot>  <IO [Char]>
10:47:25 <pjdelport> (try that in your ghci)
10:48:09 <Peaker> limepod: Applicatives let you combine "effects" and "results" of these effects simultaneously. Monads let you do the same, but also let choice of which effect to combine with which depend on previous results
10:48:17 <pjdelport> Note how that's just like (++) "foo" "bar", except for doing the function application with Applicative, and replacing the Strings with IO Strings (or any Applicative functor in general)
10:48:20 <monochrom> limepod: https://github.com/NICTA/course/ has sections on Applicative exercises and Monad exercises
10:48:58 <imalsogreg> limepod: Some nice exercises here too: https://www.fpcomplete.com/user/DanBurton/20-intermediate-exercises
10:49:22 <limepod> those links exactly what I was looking for, thanks!
10:49:24 <Peaker> limepod: i.e: Functor's fmap lets you apply a function on the "result" part without modifying the "effect".  Applicative then adds the ability to create empty-effects (pure :: a -> f a) and combine effects/results:  f (a -> b) -> f a -> f b    given fmap, this is also equivalent to:    f a -> f b -> f (a, b)
10:56:14 <mmachenry> Is there a safe and controlled way to update packages in cabal? I did a simple cabal update and then cabal install cabal-install (per the suggestion) then I did a cabal install aeson (which was already installed but a newer version was found so it installed it. This broke nearly all my ByteString dependent code.
10:56:47 <timmy_tofu> mmachenry: sandboxes
10:56:50 <mmachenry> I tried to reinstall all packages using a command I found but I have not had any luck.
10:57:22 <mmachenry> timmy_tofu: Is that really required? I thought that was only needed if I was doing some version specific stuff.
10:57:31 <c_wraith> mmachenry: the simplest is like rm -r ~/.ghc ; cabal update ; cabal install world
10:57:32 <mmachenry> I just want the latest that cabal recommends.
10:57:36 <timmy_tofu> What luck have you not had reinstalling? If you're really broken, I would try blowing away everything and reinstalling everything at once
10:57:57 <timmy_tofu> mmachenry: Not required insofar as people managed for years without it, but...
10:58:17 <mmachenry> What is cabal install world? Does that remember what I already had installed or does it install all packages?
10:58:54 <c_wraith> mmachenry: cat ~/.cabal/world
10:59:19 <c_wraith> mmachenry: it's a meta-package based on what you explicitly have installed on your system
10:59:27 <c_wraith> mmachenry: you can edit it however you like, if you want
10:59:30 <mmachenry> c_wraith: Ah! I see, your rm won't remove my cabal stuff, just my ghc stuff.
10:59:47 <mmachenry> What about ~/.cabal/bin Won't that be stale?
11:00:00 <mutable> mmachenry: I almost always use sandbox for all projects. I only install package to the ~/.cabal for the things that I need for my command line tools (such as cabal, hlint etc)
11:00:23 <mmachenry> Yeah I should probably learn about sandboxes I guess.
11:00:29 <c_wraith> mmachenry: Only if you have dynamic linking as the default.  Everything that's statically linked will be fine, and I think that's still everything by default
11:01:04 <timmy_tofu> mmachenry: They're super easy. cabal sandbox init is really all there is to it
11:01:18 <timmy_tofu> mmachenry: then cabal installs are put into the local environment
11:01:25 <mmachenry> timmy_tofu: Hm, alright, I'm sold. I do that in my project dir?
11:01:32 <timmy_tofu> mmachenry: so nothing conflicts with things eight directories away
11:01:42 <Tornado68> Someone know a good library for genetic and neural network programing?
11:02:03 <timmy_tofu> mmachenry: yep. cabal sandbox init, and then continue using cabal as normal. It'll "reinstall" everything you already have installed for the project you're in at that moment
11:02:05 <beaky> hello
11:02:18 <beaky> how do i test a haskell project
11:02:19 <mmachenry> If I want to start fresh and go the sandbox route, should I change my .cabal/world file before I rm -r .ghc and cabal install world?
11:02:25 <timmy_tofu> mmachenry: And if you every get in to a jam, you can just do cabal sandbox delete; cabal sandbox init; cabal install --dependencies-only and start fresh
11:02:37 <schell> beaky: there’s a couple different test suites you can use
11:02:41 <c_wraith> mmachenry: if you're going the sandbox route, what you have installed globally doesn't matter
11:02:47 <Lowl3v3l_> Tornado68, i dont, but i'd be interested too... but the question is : why do you need a "library" for that? for implementing neurons?
11:02:52 <schell> QuickCheck and DocTest are two really good ones
11:03:02 <pointed_set> mmachenry: sandbox ignores all global installs
11:03:11 <mmachenry> Ah okay.
11:03:31 <texasmynsted> anybody have opinion on this?  http://www.quora.com/Who-are-the-top-five-most-influential-and-successful-people-in-the-functional-programming-world-and-why
11:04:17 <Tornado68> Fuzzy investigation
11:05:03 <mutable> mmachenry: but considering you've already somehow mess about the global, resetting it would not be a bad idea, and then you can keep installing as few thing as possible there for the sake of tidiness.
11:05:43 <monochrom> mmachenry: read my http://www.vex.net/~trebla/haskell/sicp.xhtml for what is in ~/.ghc and what is in ~/.cabal
11:07:19 <DanielOertwig> I'm trying to cabal install hakyll / cabal-install / anything on a absolutely fresh (Arch) Linux (x86_64), but I keep getting very weird error messages. I think the root of all evil is "<no location info>: Warning: Couldn't figure out linker information! Make sure you're using GNU gcc, or clang".
11:08:26 <l0cust> DanielOertwig: how did you install ghc?
11:09:00 <l0cust> DanielOertwig: What is the GHC version? What is the cabal version? Also, lpaste the specific error messages
11:09:04 <DanielOertwig> pacman -S ghc ... and I think that might be real source ...
11:09:19 <l0cust> DanielOertwig: that's how I have it installed
11:09:41 <l0cust> DanielOertwig: Okay, try installing another package. Try "cabal install happy"
11:10:03 <l0cust> DanielOertwig: You need happy either way, so might as well install it
11:10:24 <lispy> texasmynsted: I would Reynolds to that list
11:10:41 <lispy> texasmynsted: add, even
11:11:06 <monochrom> I have an opinion on the number 5
11:11:34 <texasmynsted> Reynolds?
11:12:09 <DanielOertwig> http://lpaste.net/108761
11:12:13 <texasmynsted> I have an opinion on the number 6 because it fears 7
11:12:19 <lispy> texasmynsted: http://en.wikipedia.org/wiki/John_C._Reynolds
11:12:23 <DanielOertwig> THis is the result of running cabal install happy
11:12:56 * texasmynsted facepalm
11:13:00 <monochrom> there is a past exam question on data structures. it says: receive a natural number m at the beginning; henceforth, receive a sequence of numbers, interjected with occasional queries of "what are the m smallest numbers you have seen so far?"
11:13:02 <l0cust> DanielOertwig: oh, that's easy. Do you have the arch package group base-devel installed?
11:13:09 <texasmynsted> yes, thank you lispy
11:13:52 <monochrom> the revelation is that you must throw away most numbers
11:14:00 <DanielOertwig> l0cust: Yes. (I also have a working gcc / binutils / etc)
11:14:22 <lispy> texasmynsted: perhaps a better approach to resolving this is to look at this list: http://www.cis.upenn.edu/~bcpierce/courses/670Fall04/GreatWorksInPL.shtml
11:14:32 <texasmynsted> because, of course (7, 8, 9)
11:14:37 <monochrom> a question of the form "who are the 5 most important persons?", asked once in a while, requires you to throw away most important persons
11:14:55 <l0cust> DanielOertwig: What's the output of locale?
11:15:39 <texasmynsted> monochrom, that is a fair criticism.  Perhaps the question should not have a specific number
11:16:06 <DanielOertwig> Output of locale: http://lpaste.net/108762
11:16:22 <l0cust> DanielOertwig: oh, that's the problem
11:16:24 <texasmynsted> lispy, thank you for the link
11:16:35 <l0cust> DanielOertwig: GHC doesn't like non-MURICAns
11:17:11 <l0cust> DanielOertwig: try "LANG=en_US.UTF-8 ; cabal install happy"
11:17:31 <HeladoDeBrownie> l0cust, that doesn't sound quite right, I have a Spain Spanish locale and have found no problems
11:17:36 <monochrom> hrm, how does it affect finding the linker?
11:18:06 <monochrom> adding "-v3" may help
11:18:22 <monochrom> may help divulge more information
11:18:26 <l0cust> HeladoDeBrownie: This is actually bug #8825 of GHC https://ghc.haskell.org/trac/ghc/ticket/8825
11:18:40 <l0cust> The fix is to set your locale to en_US.UTF-8
11:18:52 <DanielOertwig> No, using english locale doesn't work either, the warning is gone, but it still complains about missing Control.Monad.Writer etc
11:18:55 <joelteon> does GHC accept en_GB.UTF-8?
11:19:05 <l0cust> DanielOertwig: try installing mtl
11:19:07 <monochrom> oh! that is how. "gcc версия 4.8.2"
11:19:24 <texasmynsted> In many ways the interesting part about the list is the "why" not the who.
11:20:09 <texasmynsted> Some people think in terms of academics, and others in terms of commercial success.
11:20:11 <texasmynsted> etc
11:20:20 <timmy_tofu> I'm getting ghc-mod errors about something not being in scope which is imported inside an #ifdef CPP block. How can I get ghc-mod to set and observe the flags I use in the #ifdef condition?
11:20:24 <texasmynsted> The list is subjective
11:20:39 <monochrom> oh heh, the spanish version "versión" is probably close enough to english
11:21:00 <lispy> texasmynsted: For me the criteria is version of "who came up with the ideas that become so pervasive that they're 'obvious'"
11:21:20 <l0cust> lispy: Darwin, Newton
11:21:27 <DanielOertwig> l0cust: mtl didn't solve it, but I guess something is wrong with ghc-pkg ... where is the user configuration stored, so I can reset it all?
11:21:32 <timmy_tofu> That is, the flag I pass to cabal config which sets a cpp-options flag in the cabal file
11:21:37 <lispy> l0cust: guttenberg
11:22:33 <l0cust> lispy: Faraday, Einstein, Archimedes
11:22:51 <fread2282> I got GHC to stack overflow in typechecking :o
11:22:55 <texasmynsted> lispy, yes but it is also interesting that sometimes the ideas are not immediately adopted or appreciated, and sometimes they are.  What makes that difference?
11:23:37 <l0cust> texasmynsted: My father is in that category. In his case, his work is politically controversial, so many people disregard it
11:23:56 <nh2> int-e, Fuuzetsu: had to take care of the Foosballtable. Here it comes: https://github.com/haskell/cabal/issues/2029
11:24:11 <l0cust> DanielOertwig: ~/.ghc/
11:24:19 <texasmynsted> l0cust, link?
11:24:32 <l0cust> texasmynsted: http://en.wikipedia.org/wiki/Henry_Harpending
11:24:36 <texasmynsted> ty
11:24:39 <lispy> texasmynsted: It seems like ideas have their time and that is a non-trivial effect. I think, relatedly, that network effects are very important.
11:24:56 <texasmynsted> I get "frustrated" with the politics in academics
11:25:30 <l0cust> texasmynsted: My dad tried to write a paper once about academic censorship. Unsurprisingly, his paper was censored.
11:25:52 <texasmynsted> :-(
11:26:52 <jophish_> fread2282, http://spacemanaki.com/blog/2014/08/04/Just-LOOK-at-the-humongous-type/
11:26:55 <texasmynsted> it seems at times as though there is an agenda, and if you do not align with it you are ignored or worse
11:27:29 <l0cust> texasmynsted: here's some of his more recent work http://westhunt.wordpress.com/author/harpend/
11:27:54 <fread2282> jophish_: yea, but I got it to overflow in normal code
11:29:02 <Fuuzetsu> nh2: I'll give it a go
11:29:34 <texasmynsted> I wonder if there is more censorship in anthropology than say physics
11:30:51 <l0cust> texasmynsted: definitely in the social sciences, as they are more immediately applicable to real life
11:30:58 <DanielOertwig> Removing both .ghc and .cabal made it possible to cabal install cabal-install ... so I try hakyll now ..
11:31:19 <l0cust> DanielOertwig: alright
11:32:03 <texasmynsted> that would make sens
11:32:05 <texasmynsted> e
11:32:36 <fread2282> tiny example that causes GHC to stackoverflow http://lpaste.net/8092524654104674304
11:35:32 <Fuuzetsu> nh2: uhm, you need Module1 in other-modules
11:35:37 <Fuuzetsu> this is the kind of error you get otherwise
11:39:05 <Fuuzetsu> comment on GitHub
11:41:18 <Defauk> Fuuzetsu why don't you build a navigation page on ur site
11:42:14 <rien> I'm looking for some sort of algebra to talk about JSON transformations (tree/array rewriting). I just need some conceptual help. I'm writing a JSON transformer library.
11:44:09 <sclv> rien: you can look up work on xml/tree diffs
11:44:30 <rien> for instance, I have trouble coming up with a way to say "grab all array->hash->"field_name"->array->hash->"sub_fields" and put them all in array->hash->"new_field_name"->array->"subfields"
11:46:10 <rien> sclv: I'm really looking for a high level way to describe these transformations, an unambiguous notation for saying which nodes to take from the input json and where to put them on the output json. I can code the solution if I have at least that, but I'm having trouble coming up with such algebra.
11:46:31 <HeladoDeBrownie> rien, sounds like something that exists in lens
11:46:53 <Fuuzetsu> Defauk: Why do I need one?
11:47:24 <HeladoDeBrownie> rien, I think the relevant term is "traversal" but I'm uncertain
11:47:46 <rien> HeladoDeBrownie: as I'm traversing I want to build a new JSON out of the input JSON
11:48:08 <nh2> Fuuzetsu: I noticed, but why does it go away if I delete the ANN pragma
11:48:48 <timmy_tofu> I'm getting ghc-mod errors about something not being in scope which is imported inside an #ifdef CPP block. The ifdef condition is a cpp-options flag specified in the cabal file set if a cabal flag is set (cabal configure -fdevelopment). How can I get ghc-mod to set and observe the flags I use in the #ifdef condition?
11:49:19 <sclv> rien: related -- http://www.cs.york.ac.uk/fp/HaXml/icfp99.html
11:49:37 <Fuuzetsu> nh2: It does not for me.
11:49:42 <nh2> Fuuzetsu: it does for me
11:49:48 <nh2> just tried it again and it works
11:50:02 <Fuuzetsu> try cleaning first
11:50:33 <nh2> Fuuzetsu: cleaned, same result
11:51:01 <nh2> (that's why I made the issue, otherwise it would just be #939)
11:51:20 <Fuuzetsu> then I don't know but I'm unsure if it is relevant to chase bugs on top of already known bugs
11:51:29 <Fuuzetsu> s/relevant/worthwhile/
11:51:51 <rien> sclv: thanks, that gives me some ideas.
11:51:52 <nh2> Fuuzetsu: if the ANN does *something*, that's clearly a problem
11:52:07 <nh2> it should have no effect
11:53:02 <Fuuzetsu> Why should it have no effect? It may be doing something that requires extra GHC work at which point the problem occurs
11:54:04 <Fuuzetsu> it is pointless to point out a bug based on top of another bug; it would be a problem if you were getting bad behaviour with all modules properly listed but that's not the case
11:54:19 <Fuuzetsu> it's kind of like pointing the finger at undefined behaviour and saying it's not the kind of undefined behaviour you wanted
11:56:48 <nh2> Fuuzetsu: I guess the real bug is the pragma doing something that it shouldn't, and the linker error is just the way I found it. Also according to #939, it's not a bug; #939 is marked as an enhancement for cabal to anticipate these linking problems
11:57:34 <Fuuzetsu> in my opinion it is mislabelled
11:58:30 <nh2> Fuuzetsu: I agree on that, but nevertheless I need to understand why annotating a function with a plain string can change *anything* in compilation behaviour
11:59:34 <Fuuzetsu> maybe modules need to be aware of all annotations at which point it tries to go to Module1 and has linking problems, is that unreasonable?
12:01:10 <Fuuzetsu> I just think that even if it is a ANN bug or whatever then you should be seeking it with all the modules listed: if it never occurs when all modules are listed then it's just not an issue
12:04:05 <nh2> Fuuzetsu: that doesn't help me much in understanding what happens here though; if you use ghc --make then the bug triggers in no case, and ANN is not something that cabal knows about, so it must be something subtle between ghc and cabal
12:06:28 <monochrom> hmm, what is ANN?
12:09:27 <mmachenry> If I want to remove as much as possible from my cabal world, and start using sandboxes for all of my projects, how can I safely clean up ~/.cabal/world and set it to only what's there by default when I install it?
12:09:49 <geekosaur> monochrom, http://www.haskell.org/ghc/docs/latest/html/users_guide/extending-ghc.html#annotation-pragmas
12:10:34 <monochrom> mmachenry: make it empty. that's the default.
12:10:47 <geekosaur> note that ~/.cabal isn't as significant as ~/.ghc
12:11:13 <mmachenry> monochrom: Wow, really? I've installed a lot. :)
12:12:05 <monochrom> I am always skeptic of it. it accumulates a lot of junk.
12:12:43 <monochrom> there is no way it knows which ones you use long-term and which ones you play for a bit and abandon
12:13:16 <monochrom> well, there is a way it knows. if you add --one-shot, then it knows you play for a bit and abandon. but have you even heard of it?
12:18:28 <dfeuer> Does Haskell have a non-short-circuiting version of or? Something like nsOr a b = isTrue# (orI# (dataToTag a) (dataToTag b))
12:18:53 <ReinH> dfeuer: min :)
12:19:00 <int-e> nh2: Note that the error pops up while compiling; the annotation causes ghc to load all packages specified on the command line, and that fails because the package is incomplete. I'm not sure why, I don't understand the annotation mechanism.
12:19:02 <ReinH> since the bools form a latice
12:19:26 <ReinH> woops I mean max
12:19:29 <ReinH> > max True False
12:19:31 <lambdabot>  True
12:19:36 <ReinH> > max True undefined
12:19:38 <lambdabot>  *Exception: Prelude.undefined
12:19:51 <int-e> nh2: without the annotation, it succeeds because nothing from 'mylib' library ends up being used; Module1 is just recompiled from scratch and linked to Main.
12:19:55 <ReinH> > True || undefined
12:19:57 <lambdabot>  True
12:20:01 <ReinH> dfeuer: or did you mean this or:
12:20:02 <ReinH> :t or
12:20:04 <lambdabot> [Bool] -> Bool
12:20:13 <dfeuer> I was about to say. Will max compile to good code for Bool?
12:20:32 <dfeuer> About to say about max/min. I'm not talking about the list thing.
12:20:33 <benzrf> dfeuer: there's or and and
12:20:43 <benzrf> oh
12:20:45 <benzrf> dur
12:20:51 <ReinH> dfeuer: define "good code" :p
12:20:55 <int-e> nh2: this is not your question, but personally I think that using the same source directory for the library and the main executable that's supposed to use it is a bad idea.
12:20:58 <benzrf> wait, won't max for bools just be (||)?
12:21:12 <dfeuer> No, benzrf. Read the question.
12:21:47 <ReinH> benzrf: they have different strictness
12:21:48 <int-e> nh2: actually, as to why ghc does it -- it has to run actual code, just like in the template haskell case. and whenever it runs code, it *will* load all packages specified on the command line.
12:22:03 <benzrf> ReinH: ah
12:22:33 <dfeuer> ReinH: I think good code in this context means max a b = isTrue# (orI# (dataToTag a) (dataToTag b)), or something equally cheap.
12:22:42 <ReinH> see also: http://stackoverflow.com/questions/23880626/understanding-haskells-bool-deriving-an-ord/23880921#23880921
12:23:18 <monochrom> > max True undefined
12:23:20 <lambdabot>  *Exception: Prelude.undefined
12:23:45 <int-e> bottom is greater than True, hah.
12:24:07 <monochrom> bottom is the greatest common denominator
12:25:11 <benzrf> :t isTrue#
12:25:12 <lambdabot> Not in scope: ‘isTrue#’
12:25:13 <benzrf> hmm
12:25:18 <benzrf> @src Bool
12:25:18 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:25:23 <benzrf> sounds fake to me
12:27:03 <dfeuer> benzrf, in GHC 7.8 and later, primops producing boolean results actually produce Int#. To pull a Bool out of that takes isTrue#.
12:28:31 <benzrf> huh
12:28:52 <mmachenry> "cabal sandbox init" is not a known command for cabal 1.16 which is the newest version I can install with "cabal install cabal-install
12:29:33 <ReinH> mmachenry: cabal update ?
12:30:00 <mmachenry> ReinH: Perhaps. I think it's a little confused. I did a delete and reinstall recently.
12:30:13 <Fuuzetsu> you need to cabal update after clearing .cabal
12:30:14 <monochrom> what ghc do you have?
12:31:26 <mmachenry> 7.6.3
12:31:52 <mmachenry> And when I install cabal I get "I just installed 1.20" and when I run —version I get 1.16
12:32:21 <HeladoDeBrownie> mmachenry, add $HOME/.cabal/bin to your $PATH
12:33:24 <dfeuer> mmachenry: that's likely a PATH issue.
12:33:26 <mmachenry> HeladoDeBrownie: Ah, that changed it.
12:33:39 <alorente> I'm having a problem where GHCi is complaining about overlapping instances, but it's pointing to the same line twice. https://paste.andrewlorente.com/oqehajokej.txt is it because I pulled in the module with :load maybe?
12:34:05 <monochrom> how many people noticed that, after "cabal install cabal-install" or "cabal install happy" or "cabal install hscolour" etc etc, it actually tells you about $HOME/.cabal/bin ?
12:34:35 <monochrom> it seems to me only 6 persons in the whole world ever saw that
12:35:37 <int-e> I've seen it.
12:38:25 <pjdelport> monochrom: I notice that, but then i also already have ~/.local/bin in my PATH.
12:39:31 <HeladoDeBrownie> pjdelport, what's there?
12:41:02 <mmachenry> Now I've deleted my .ghc, installed cabal again, fixed me path, and I, naturally, don't have packages. So I just tried to install datetime into the current sandbox. But it can't be found. http://lpaste.net/108763
12:41:10 <pjdelport> HeladoDeBrownie: Depends, but what's the canonical XDG place to install user-local executables into.
12:41:31 <HeladoDeBrownie> mmachenry, ghci doesn't automatically pick up on cabal sandboxes
12:41:33 <pjdelport> HeladoDeBrownie: So that's what for example pip (Python) uses.
12:41:40 <HeladoDeBrownie> mmachenry, try using the -package-db flag
12:41:45 <HeladoDeBrownie> pjdelport, ah, I see.
12:42:05 <HeladoDeBrownie> mmachenry, alternatively, put a package config in that directory and use `cabal repl`
12:43:05 <HeladoDeBrownie> pjdelport, out of curiosity, what actually uses ~/.local/bin? I've never seen anything offer that choice or care about it
12:43:29 <HeladoDeBrownie> Beyond being able to specify a configure prefix, which could be anywhere of course
12:43:29 <pjdelport> HeladoDeBrownie: pip, for example :)
12:43:33 <HeladoDeBrownie> Ah, right
12:43:46 <NikolajK> how do I call up djinn here?
12:43:51 <johnw> @djinn a -> a
12:43:52 <lambdabot> f a = a
12:44:32 <NikolajK> ah, I thought so, but it doesn't look like it's working in a private chat
12:44:39 <HeladoDeBrownie> It should
12:44:41 <monochrom> my ubuntu doesn't even have ~/.local/bin
12:45:02 <HeladoDeBrownie> NikolajK, works fine for me, you sure you're messaging lambdabot and not some poor other user? :)
12:45:07 <monochrom> /msg lambdabot @djinn a -> a
12:46:01 <NikolajK> ah, that's it
12:47:04 <shouya1> Hi folks, i got a (should be easy) question about using parsec. anyone can help?
12:47:17 <HeladoDeBrownie> shouya1, ask the question and whoever can answer it may
12:47:48 * nitrix squeezes lambdabot tightly~
12:47:49 <shouya1> i tried to connect the results of two consecutive parsing while i don't know what's the idiomatic way to do so.
12:48:01 <schell> how does ‘deriving (Functor)’ write the Functor instance for the data?
12:48:06 <shouya1> i tried using `mplus` but it doesn't really work.
12:48:29 <pavonia> shouya1: Connect in what way?
12:48:33 <HeladoDeBrownie> shouya1, how does it "not work"?
12:48:44 <HeladoDeBrownie> shouya1, show what you tried
12:48:55 <shouya1> for example, i have a parser: foo = do { char '1'; char '2' }
12:48:59 <schell> for instance, what would the Functor instance look like for this data? http://lpaste.net/108764
12:49:39 <shouya1> and now i want to collect the result in a whole from another parser: bar = foo   -- if parsed, bar should be `return "12"`
12:50:00 <HeladoDeBrownie> shouya1, bar = foo is saying that bar and foo are literally the same thing
12:50:15 <HeladoDeBrownie> shouya1, foo doesn't even result in "12", it results in '2'. If you want that, try, for example, string "12"
12:50:20 <HeladoDeBrownie> There are other ways but that's probably simplest
12:50:24 <HeladoDeBrownie> foo = string "12"
12:50:39 <shouya1> HeladoDeBrownie: yup i knew this function, but i just want to demo the simplest case.
12:50:39 <monochrom> bar = foo >> return "12"
12:50:56 <shouya1> actually i need to connect a parser with more complex cases.
12:51:03 <pqmodn_> or, you could try do { a <- char '1'; b <- char '2'; return [a, b]; }
12:51:27 <TheKing444> Anyone know the ircbot library very well?
12:51:28 <shouya1> pqmodn_: but is there any better way, i mean, more idiomatic way to do that?
12:51:35 <shachaf> sequence [char '1', char '2']
12:51:37 <monochrom> what is "more complex"? write a clear specification.
12:51:42 <shouya1> okay.
12:51:42 <HeladoDeBrownie> shouya1, well, there's sequence
12:51:50 <HeladoDeBrownie> Was beat to it
12:51:55 <pqmodn_> it depends on exactly what you want to do... is it really a list?
12:52:04 <mmachenry> What's the most idiomatic way to say "use this sandbox" for the one I made in my project's directory? Make a Setup.hs file?
12:52:16 <shouya1> foo = do { parser1; optional parser2; many parser3 }
12:52:22 <shouya1> something like that.
12:52:22 <monochrom> no, usually Setup.hs is already generated for you
12:52:27 <HeladoDeBrownie> mmachenry, `cabal repl` usually
12:52:27 <TheKing444> nvm
12:52:40 <HeladoDeBrownie> mmachenry, assuming you mean you want to run ghci or whatever
12:52:45 <shouya1> so i now tried to use MonadPlus.
12:53:03 <monochrom> I don't understand the purpose of parser1, paser2, parser3, and why do { parser1; optional parser2; many parser3 } is not already fulfilling your specification.
12:53:05 <HeladoDeBrownie> mmachenry, generally, cabal will be aware of the sandbox in the current directory so anything run through cabal should work as desired
12:53:17 <pqmodn_> if the second parser does not depend on the result of the first parser, you can use Applicative to combine the two results. for example, liftA2 (,) (p1) (p2) would be equivalent to do { a1 <- p1; a2 <- p2; return (a1, a2); }
12:53:19 <monochrom> you need to leave me no need to guess anything.
12:53:31 <shouya1> foo = do { (toString parser1) `mplus` (toString $ optional parser2) `mplus` (toString $ many parser3) } some like this.
12:53:32 <pavonia> schell: I think it would look like this: http://lpaste.net/108765
12:53:54 <HeladoDeBrownie> shouya1, ah, well the problem there is those parsers are of different types
12:54:15 <shouya1> monochrom: okay, i shall paste the code. wait a second :p
12:54:17 <monochrom> what the hell is toString?
12:54:25 <TheKing444> :t toString
12:54:27 <lambdabot>     Not in scope: ‘toString’
12:54:27 <lambdabot>     Perhaps you meant ‘BSLC.toStrict’ (imported from Data.ByteString.Lazy.Char8)
12:54:34 <TheKing444> :t BSLC.toString
12:54:36 <lambdabot>     Not in scope: ‘BSLC.toString’
12:54:36 <lambdabot>     Perhaps you meant one of these:
12:54:36 <lambdabot>       ‘BSLC.toStrict’ (imported from Data.ByteString.Lazy.Char8),
12:54:37 <HeladoDeBrownie> shouya1, it seems like you're sort of guessing that mplus is what you need, but I think it isn't
12:54:53 <schell> pavonia: ahh, so both records need Functor instances
12:54:54 <schell> okay
12:54:56 <tulcod> i'm writing template haskell, and depending on some data, want to either output an expression, or do nothing. is there a "nothing" expression in TH?
12:55:02 <schell> pavonia: thanks :)
12:55:03 <mmachenry> HeladoDeBrownie: What about if I want to run my program. `cabal repl` MyModule.hs doesn't work the way ghci MyModule.hs does
12:55:16 <shouya1> monochrom: ahh, i didn't just mean that. i just want to express that i need to convert each of the parsing result into string.
12:55:26 <HeladoDeBrownie> mmachenry, the backticks weren't meant to be literal, simply to separate the command from the rest of my message.
12:55:37 <shouya1> HeladoDeBrownie: no it isn't. it doesn't work as expect.
12:55:42 <pavonia> schell: Well, outVal is transformed directly
12:55:45 <sclv> tulcod: maybe an empty block of statements?
12:56:03 <tulcod> sclv: [e||] doesn't parse
12:56:12 <mmachenry> HeladoDeBrownie:  Yeah still, doesn't drop me into a repl with the argument loaded as a module
12:56:14 <schell> pavonia: right - but in general it just ‘maps’ over each record
12:56:16 <shouya1> http://lpaste.net/108767#line73
12:56:17 <shouya1> here.
12:57:03 <monochrom> what is Exercise 6?
12:57:05 <schell> pavonia: almost like fmap f = fromList . fmap f . toList
12:57:19 <monochrom> to be honest I still haven't received the specification
12:57:20 <schell> (conceptually)
12:57:31 <sclv> tulcod: you don't want an empty expression but an empty statement, no?
12:57:37 <shouya1> the exercises are from ths guide: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
12:57:45 <tulcod> sclv: well... i want to splice in nothing at all
12:58:00 <HeladoDeBrownie> mmachenry, you might want to read the documentation on cabal-install. I'll look for it, one moment
12:58:02 <vanila> shouya1, How did you discover that tutorial/decide to follow it?
12:58:02 <sclv> but you're normally splicing in a statement, right?
12:58:04 <shouya1> monochrom: exercise 6 is to implement the parser of float number.
12:58:07 <sclv> like a set of let decls or something?
12:58:09 <pavonia> schell: Yes, but only for the fields that make use of the type variable b
12:58:28 <schell> ah, right
12:58:39 <tulcod> sclv: like, using TH i'm defining a big function, and this function depends on some input data
12:58:40 <monochrom> ok, mplus is the wrong thing
12:58:58 <HeladoDeBrownie> mmachenry, hmm, well there's http://www.haskell.org/cabal/users-guide/ although that doesn't tell you specifically about `cabal repl` and such
12:59:00 <tulcod> sclv: so i'm writing a big do block, and depending on the input data (at compile time, that is), i either need to call a function in this do block, or not
12:59:08 <tulcod> call a function *at runtime
12:59:09 <shouya1> monochrom: hmm, seems i still have some misunderstood on it.
12:59:12 <HeladoDeBrownie> mmachenry, what, exactly, is it you want to do that that doesn't do?
12:59:19 <monochrom> mplus is the same as <|>
12:59:31 <shouya1> monochrom: well really?
12:59:38 <shouya1> monochrom: i don't get it.
12:59:50 <tulcod> sclv: so i have [d| blabla yadda = do $(case somevar of 1 -> [e|callSomeFunc|]; 2 -> DontDoAnything (tm)  )|]
12:59:51 <shouya1> monochrom: although seems it works in that way.
12:59:56 <monochrom> this is an axiom. there is only "accept" and "not accept"
13:00:05 <tulcod> sclv: question: what do i put at DontDoAnything (tm) ?
13:00:38 <sclv> probably put "return ()" ?
13:00:44 <sclv> in that case
13:00:48 <sclv> :-P
13:00:52 <tulcod> okay, sure
13:01:12 <shouya1> monochrom: yup, what i want is to passing connect all the accepted cases and if there is any unaccpeted case then the whole expression should be a not accepted case. (sorry for my twisted expression)
13:01:32 <monochrom> you need >>= , which is do-notation
13:01:32 <nitrix> I think I found an error in learn you a haskell
13:01:35 <sclv> if you had the do block itself in TH you could maybe do better
13:01:44 <sclv> by conditionally generating it
13:02:07 <sclv> nitrix: you may well have. what do you think you found?
13:02:10 <shouya1> monochrom: but that work the same as 'a <- expr' isn't it?
13:02:27 <tulcod> sclv: hm, yes, but that won't make it much prettier...
13:02:46 <nitrix> sclv: They say the type of the length function is `(Num b) => length :: [a] -> b`, but shouldn't it be `length :: (Num b) => [a] -> b` ?
13:03:05 <benzrf> nitrix: yep
13:03:07 <HeladoDeBrownie> nitrix, that does sound like a typo. Link?
13:03:07 <sclv> ?ty length
13:03:08 <lambdabot> [a] -> Int
13:03:12 <benzrf> congrats, now u can email the author
13:03:14 <sclv> oh that doesn't help :-)
13:03:17 <nitrix> >> http://learnyouahaskell.com/types-and-typeclasses
13:03:23 <monochrom> I'm going to just flatten it out and write: do { s0 <- parseNumStr; char '.'; s1 <- parseNumStr; optional (char 'F'); return (readFloat (s0 ++ "." ++ s1)) }
13:03:24 <benzrf> nitrix: actually thats the type of genericLength
13:03:33 <benzrf> :t length "foobar"
13:03:35 <lambdabot> Int
13:03:36 <nitrix> Bottom of the page, `having a more general type of`
13:03:38 <benzrf> :t genericLength "foobar"
13:03:40 <lambdabot> Num i => i
13:04:08 <shouya1> monochrom: i previously wrote it as that and it works.
13:04:09 <sclv> anyway yeah. the former isn't even valid syntax i think.
13:04:32 <HeladoDeBrownie> nitrix, yep, I can confirm that's an error
13:04:37 <nitrix> Can someone confirm? I'm not even 8hrs into Haskell, I wouldn't like to claim something I know nothing about.
13:04:39 <shouya1> monochrom: but i am thinking if there's any general operation i can take.
13:04:50 <nitrix> HeladoDeBrownie: Okay thanks. I'll email the author.
13:05:20 <monochrom> why?
13:06:04 <shouya1> monochrom: put this case aside. i want an function that can give out the total string eaten by a parser in a parsing process.
13:06:32 <shouya1> monochrom: the whole string eaten by a parser. no matter what it returns.
13:06:57 <joelteon> trifecta can do that
13:07:10 <pqmodn_> i'm not sure that exists in Parsec or Attoparsec. your parser would have to return it as part of the result, i believe
13:07:42 <monochrom> I have not seen one. it is also of little utility IMO. unless you are the kind of "use string for all data structures" programmers
13:07:54 <shouya1> pqmodn_: if i take a look inside the implemenation of Parsec states i think i could implement such function myself.
13:08:07 <monochrom> the last thing I want from a parser's answer is a string
13:08:29 <shouya1> monochrom: of course not :p
13:09:10 <monochrom> anyway, parsec doesn't provide it, and I'm uninterested in it
13:09:39 <shouya1> monochrom: I'm sorry for that :)
13:09:40 <pqmodn_> so you can't have it, shouya1, because monochrom is not interested! :)
13:09:59 <shouya1> pqmodn_: haha, it's fine :)
13:10:01 <monochrom> well, I'm sure you can code it up yourself and I can do nothing about it
13:10:23 <nitrix> HeladoDeBrownie: Sent. Appreciated.
13:10:38 <shouya1> monochrom: no, no, i don't mean that. i just want to say that from principle i knew there could exist such a function.
13:10:47 <HeladoDeBrownie> nitrix, good eye, you might have just helped some people be less confused in the future
13:11:00 <L8D> "/usr/local/Cellar/ghc/7.8.2_3: 6455 files, 807M, built in 130.7 minutes"
13:11:12 <L8D> I hope it was worth it
13:11:24 <gilligan_> Wanted to play with yesod but can't even get it installed in a fresh cabal sandbox : http://pastie.org/9445296  -- any suggestions how I can solve this ?
13:11:38 <pqmodn_> shouya1: one thing that makes it tricky is when input can be fed into the parser incrementally, you could parse it incrementally... unless you wanted that feature, in which case you'd have to buffer the input somehow
13:11:44 <nitrix> HeladoDeBrownie: It's just that before any demonstration, I try to figure it out myself before looking at it, to potentially catch me not understanding what I'm reading.
13:12:21 <nitrix> Everyone their method x]
13:12:37 <L8D> now I'm running cabal install cabal-install
13:12:42 <L8D> from 1.16 to 1.20
13:12:48 <L8D> gml
13:12:50 <shouya1> pqmodn_: hmm.. it matters.
13:13:58 <DanielOertwig> l0cust: It worked now, no idea why it didn't the first time, thanks for the help!
13:14:09 <shouya1> basically my idea is to intercept the state before and after the parsing process by the parser, and then look at the difference of these states to extract the parsed string.
13:14:10 <l0cust> DanielOertwig: no problem
13:14:36 * HeladoDeBrownie wonders if Parsec lets you push tokens back onto the stream
13:14:46 <monochrom> it does
13:14:59 <gilligan_> hrm, so I can install yesod-bin *or* yesod-platform but installing both won't work
13:15:01 <HeladoDeBrownie> In that case, shouya1, that sounds unfeasible
13:15:13 <monochrom> it even lets you replace the stream altogether
13:15:21 <HeladoDeBrownie> shouya1, also probably solving the wrong problem. Why do you want to do this?
13:15:56 <shouya1> HeladoDeBrownie: ha, actually i knew i can solve my case with a simpler method :p
13:16:14 <shouya1> I just thought too far...
13:16:57 <HeladoDeBrownie> shouya1, sometimes the simplest solution isn't the most obvious :)
13:17:07 <HeladoDeBrownie> s/sometimes/often/
13:17:13 <HeladoDeBrownie> s/often/usually/ ?
13:17:40 <shouya1> HeladoDeBrownie: ... yup surely.
13:17:42 <HeladoDeBrownie> I'm thinking of how it takes ages for mathematical systems to become beautiful from a rough initial idea
13:18:04 <HeladoDeBrownie> Like how infinitessimals came about in modern calculus
13:18:14 <shouya1> HeladoDeBrownie: can't agree more on that.
13:19:10 <shouya1> yet i was still astonished on how it's possible that `mplus` works the same way as `<|>`.
13:19:27 <monochrom> it is defined that way
13:19:30 <shouya1> gotcha!
13:19:41 <HeladoDeBrownie> They're from different typeclasses, but anything with an instance for both usually makes them identical
13:19:44 <shouya1> monochrom: it's awesome..
13:19:48 <HeladoDeBrownie> I think it *has* to to satisfy all relevant laws, doesn't it?
13:19:53 <monochrom> yes
13:20:11 <beaky> how do i master typeclasses
13:20:15 <beaky> as well as data
13:20:18 <simcity2000> beaky: master in what sense?
13:20:24 <monochrom> don't master.
13:20:24 <shouya1> i should try to think deeper...
13:20:38 <beaky> i want to know how to choose the best datastructure for any problem
13:20:46 <HeladoDeBrownie> beaky, practice
13:20:51 <simcity2000> beaky: try things and see where you're messing up
13:20:52 <pjdelport> shouya1: It's not that surprising when you realize that Applicative + Monoid → Alternative, and Monad + Monoid → MonadPlus
13:20:54 <monochrom> have a very smart brain, or hire one
13:20:57 <beaky> e.g. using trees to represent nested accounts
13:21:03 <prooftechnique> Or just insist that one datastructure is always best, and just use that one
13:21:05 <simcity2000> beaky: it's a simple answer, but it's the best one
13:21:14 <joelteon> use a finger tree for everything
13:21:16 <simcity2000> try things and if you have a feeling it could be done better, do it better
13:21:18 <HeladoDeBrownie> prooftechnique, cons cells 4eva
13:21:19 <beaky> whats a finger tree
13:21:22 <pjdelport> shouya1: So Alternative + Monad → MonadPlus
13:21:31 * beaky imagines a tree that looks like a hand or something
13:21:48 <benzrf> beaky: thats what it is
13:21:49 <shouya1> pjdelport: spectacular!
13:21:57 <monochrom> "choose the best datastructure for any problem" likely solves the halting problem
13:22:17 <HeladoDeBrownie> monochrom, well then, I suppose we'll have to use a Turing incomplete language to answer the question
13:22:33 <monochrom> you're better off asking the easier "choose the shortest program for any problem"
13:22:39 <Lowl3v3l_> :D
13:22:45 <Lowl3v3l_> well i got this one
13:22:47 <Lowl3v3l_> main = do
13:22:54 <Lowl3v3l_> print 42
13:23:04 <dfeuer> Beaky, a finger tree is a tree that fingers you while you're sleeping. Watch out for the finger forests.
13:23:14 <monochrom> that doesn't solve the problem "why is it not 43?"
13:23:27 <Lowl3v3l_> ofc it does.
13:23:32 <Lowl3v3l_> 42 is THE answer
13:23:36 <dottedmag> monochrom: It's not a problem.
13:23:49 <prooftechnique> Lowl3v3l_: Redundant do
13:23:53 <monochrom> I don't like 42. I like 43 more. it's a prime number.
13:24:01 <timmy_tofu> I'm getting ghc-mod errors about something not being in scope which is imported inside an #ifdef CPP block. The ifdef condition is a cpp-options flag specified in the cabal file set if a cabal flag is set (cabal configure -fdevelopment). How can I get ghc-mod to set and observe the flags I use in the #ifdef condition?
13:24:10 <dfeuer> I think you need dependent types to find out the question.
13:24:30 <shouya1> pjdelport: do you think it's a good idea to get started with category theory and then back to study haskell? or to learn haskell first and such category theory concepts would be clear for me?
13:25:05 <HeladoDeBrownie> shouya1, you don't need to know any CT, for that matter, to enjoy Haskell.
13:25:30 <prooftechnique> Though you might enjoy it, anyway
13:25:38 <HeladoDeBrownie> shouya1, the concepts, even Functors and Monads and the like, can be clear to you without even an iota of knowledge particular to CT.
13:25:55 <HeladoDeBrownie> But yes, I also agree with prooftechnique.
13:26:02 <shouya1> HeladoDeBrownie: i always feel that i knew too little on both haskell and CT..
13:26:47 <shouya1> HeladoDeBrownie: surely, i learned these evenn before i knew about the word 'category theory'..
13:27:13 <dfeuer> Some concepts get pretty hard to even try to understand, like most of Edward Kmett's libraries. And there can be complications when the documentation says wonky things like "blah blah must be a foomorphism/barfunctor".
13:27:15 <HeladoDeBrownie> shouya1, I think it's great that you're curious. Feel free to explore CT alongside your Haskell journey if you like. I'm just warning you now that it's not compulsory.
13:27:59 <edwardk> happy to take patches for better documentation or to help hash out what said better documentation should be with folks if they feel strongly
13:28:14 <HeladoDeBrownie> dfeuer, to be fair, even most of edwardk's documentation can be understood in terms of just Haskell by looking up the Haskell versions of the concepts referenced. :)
13:28:35 <shouya1> HeladoDeBrownie: btw, i bought a book named 'categories for the working mathematician' by saunders mac lane. do you know about this book?
13:28:46 <HeladoDeBrownie> shouya1, I know about it, but have never read it.
13:28:52 <Dodek> it's a great book for mathematicians
13:28:55 <HeladoDeBrownie> shouya1, you might be interested in ##categorytheory, by the way.
13:28:56 <shouya1> HeladoDeBrownie: i haven't started to read it yet :)
13:28:57 <simcity2000> is there any way to reduce the size of a GHC-compiled executable short of -dynamic or removing imports?
13:29:04 <Lowl3v3l_> i dont know it, but one of my profs said its good
13:29:11 <Dodek> not so much for haskell fans
13:29:33 <Cale> shouya1: It's a pretty famous book. I can't say that it's my favourite, but it's a classic and probably worth looking at for that reason alone.
13:29:33 <shouya1> Dodek: hmm.. so is there any suggestion?
13:29:39 <prooftechnique> simcity2000: Have you stripped the executable?
13:29:40 <Dodek> suggestion for what?
13:29:43 <dfeuer> edwardk: I am not the one to do that, because I don't understand it. You have a conceptual understanding of what the code *means* based on your understanding of category theory. I stare at the code and wonder "What is something like this for?"
13:29:44 <HeladoDeBrownie> shouya1, I've read parts of Awodey's Category Theory myself.
13:29:44 <beaky> how do i design good data structures
13:29:50 <simcity2000> prooftechnique: yes, and it's still huge. as in ~10MB
13:29:55 <beaky> e.g. representing financial acounts
13:29:57 <Cale> shouya1: I would highly recommend that book by Steve Awodey
13:30:08 <pjdelport> shouya1: I learn both Haskell and bits of category theory at the same time.
13:30:20 <simcity2000> beaky: that depends on what your use case is
13:30:27 <edwardk> dfeuer: then grab me, ask me, write up what you think i said, and show me, and i'll try to pick apart your words, we iterate a few times and then you toss it into a patch and we have docs
13:30:27 <pjdelport> shouya1: Don't focus too much on just category theory; learn type theory!
13:30:28 <shouya1> cool. i'm checking that book on amazon :)
13:30:29 <Philonous> It would be neat of cabal-install was available as a library.
13:30:29 <beaky> i want to compute balances
13:30:35 <dfeuer> beaky has no use case.
13:30:42 <shouya1> pjdelport: yup. i knew.
13:30:43 <edwardk> dfeuer: you don't have to understand it at the start of this process =)
13:30:45 <simcity2000> beaky: you're not going to find someone to do it for you
13:31:17 * dfeuer will be very happy to do that with edwardk, but won't be available for such intense work until much later today, or earlyish in two days.
13:31:31 <Philonous> is there a channel for cabal?
13:31:42 <Philonous> the cabal library, I mean
13:31:45 <dfeuer> Philonous: yes. It's #hell.
13:31:53 <Philonous> dfeuer, Not sure if joking
13:31:59 <edwardk> dfeuer: no rush. but when you feel the need feel free to reach out and i am more than happy to help teach how something works, _especially_ if the person is willing to help package that up in a form that can be used to teach others.
13:32:08 <dfeuer> I'm not sure either :-P
13:32:23 <dfeuer> I am very willing to try to do that, edwardk.
13:32:44 <edwardk> if we have that discussion on #haskell-lens, then others can pitch in as well
13:32:57 <dfeuer> *nod*
13:32:58 <edwardk> that reminds me i need to document the new contravariant applicative stuff
13:33:03 <MP2E> I'd like to help if i can, but what library would you be documenting dfeuer ?
13:33:04 <beaky> are lenses like pattern matching on records
13:33:08 <MP2E> It seems like lens is the new monad tutorial :P
13:33:10 * edwardk goes to scribble down laws
13:33:14 <edwardk> beaky: among other things
13:33:26 <edwardk> beaky: but that is a good first approximation of them
13:33:50 <dfeuer> Edwardk, beaky = let x = x in x
13:34:13 <dreams> how do you import a module in lambdabot?
13:34:14 <benzrf> beaky: lenses are like the accessors that haskell generates, except composable
13:34:14 <edwardk> dfeuer: i know =)
13:34:32 <benzrf> beaky: er, composable for the update operation
13:35:21 <benzrf> beaky: denotationally, a `Lens s t a b' is a `(s -> a, s -> b -> t)'
13:36:06 <Philonous> edwardk, As I understand it, a (Prism' a b) is isomorphic to (a -> b, b -> Maybe a). I'm looking for a Van-Laarhoven representation of (a -> b, b -> Either String a). Is such a thing possible?
13:36:07 <dfeuer> > fix id
13:36:11 <lambdabot>  mueval-core: Time limit exceeded
13:37:10 <benzrf> beaky: for example, if you have a `Lens (a, t) (b, t) a b', that's equivalent to a `((a, t) -> a, (a, t) -> b -> (b, t))'
13:38:12 <edwardk> clearly the best way to think of lenses is to construct the notion of a category equipped with lenses, which is to view the category as a category over an operad, the operad in question is the semilattice given by the terrifying UML diagram on the front page of lens. in that setting the composition of two arrows takes you to the least upper bound in the semilattice. With that you can view most lens combinators as functors that
13:38:12 <edwardk>  preserve the lattice structure, but may stretch and pull at it in various ways. You can view every category as equipped with optics in the sense that their normal arrows can be considered a lens style 'getter'.
13:39:01 <edwardk> sadly that is only a _bit_ trollish.
13:39:11 <benzrf> edwardk: :^)
13:39:21 <beaky> im confused :(
13:39:33 <edwardk> Philonous: the problem with the van laarhoven representation is that it is basically an accident that it works for lenses.
13:39:53 <benzrf> beaky: a `Lens s t a b' lets you do 2 things:
13:39:59 <benzrf> 1. get an a out of an s
13:40:09 <benzrf> 2. turn an s into a t by replacing an a with a b
13:40:11 <edwardk> Philonous: (a -> f b) -> s -> f t   -- can be reshuffled into profunctor terms by using strength, to get  forall p. Strong p => p a b -> p s t  -- now we can look around for other notions of strength
13:40:20 <beaky> aha
13:40:24 <benzrf> 04:33 < benzrf> beaky: denotationally, a `Lens s t a b' is a `(s -> a, s -> b -> t)'
13:40:27 <benzrf> 04:35 < benzrf> beaky: for example, if you have a `Lens (a, t) (b, t) a b', that's equivalent to a `((a, t) -> a, (a, t) -> b  -> (b, t))'
13:40:31 <beaky> so lens is just a type denoting a pair of getter and setter?
13:40:37 <beaky> but why pair getter and setter
13:40:38 <benzrf> beaky: denotationally yes
13:40:52 <benzrf> beaky: operationally, it varies on the lens library
13:41:07 <beaky> are they paired to be reversible or transitive or something
13:41:17 <benzrf> @where lens laws
13:41:17 <lambdabot> #haskell-lens | http://lens.github.io/ | https://github.com/ekmett/lens | http://www.youtube.com/watch?v=cefnmjtAolY&hd=1
13:41:20 <benzrf> @where lenslaws
13:41:20 <lambdabot> I know nothing about lenslaws.
13:41:22 <benzrf> meh
13:41:28 <MP2E> beaky: close, the getter and setter over the object forms an isopmorphism
13:41:35 <MP2E> isomorphism*
13:41:35 <beaky> whats an isomorphism
13:41:47 <benzrf> beaky: isomorphism is a 2-way mapping between things
13:41:59 <MP2E> If you have 2 objects, A and B, B is isomorphic to A if you can map between the two without losing any information
13:42:02 <edwardk> normal lens strength uses the monoidal structure on Hask given by the bifunctor (,) with unit (), that is ((a,b),c) <-> (a,(b,c)) and (a,()) <-> a <-> ((),a), in lens terms we want the profunctor to respect that monoidal structure, e.g. second' :: Strong p => p a b -> p (c, a) (c, b) --
13:42:03 <benzrf> which follows certain intuitive rules
13:42:23 <edwardk> for a prism we want to respect a different monoidal structure right' :: Choice p => p a b -> p (c, a) (c, b)
13:42:27 <edwardk> er
13:42:36 <edwardk> for a prism we want to respect a different monoidal structure right' :: Choice p => p a b -> p (Either c a) (Either c b)
13:42:43 <benzrf> beaky: for example, 1-element lists are isomorphic to Maybe, and the isomorphism is listToMaybe paired with maybeToList
13:43:02 <trap_exit> good morning haskell!
13:43:07 <benzrf> beaky: but the important thing is that the getter and setter ops for a lens should follow basic intuitive laws that say that they're accessing the same 'part'
13:43:53 <edwardk> so Choice and Strong are both 'strength' for different choices of monoidal structure. we can write a lens with type Lens s t a b = forall p. Strong p => p a b -> p s t -- while Prism uses 'strength for Either' aka Choice
13:44:16 <beaky> ah
13:44:23 <benzrf> https://www.fpcomplete.com/user/tel/lenses-from-scratch#laws <- beaky
13:44:33 <edwardk> but when you do that you get something that doesn't fit back into the van laarhoven form without modifying the (->)'s in (a -> f b) -> (s -> f t) -- this is why we pick p a (f b) -> p s (f t) in lens
13:44:53 <edwardk> Philonous: anyways that is why you can't have nice things
13:45:08 <edwardk> now, we can do more with strength, which leads to some new notions of lens
13:45:13 <benzrf> beaky: anyway, the fun part of lenses is that you can compose them
13:45:23 <beaky> how do i use lens in a project
13:45:39 <benzrf> beaky: that varies
13:45:50 <beaky> rather than records
13:46:01 <beaky> or are they not a replacement for records?
13:46:05 <MP2E> You still use records
13:46:10 <beaky> oh
13:46:11 <MP2E> lenses just let you zoom in on the part of the record you care about
13:46:20 <MP2E> and change it or do whatever from there
13:46:23 <benzrf> beaky: you probably dont want to pull in the whole lens lib just to replace records almost exactly
13:46:25 <beaky> so it makes nested records easier to use?
13:46:29 <benzrf> beaky: among other things
13:46:36 <Philonous> edwardk, Thanks for the explanation. I think I'll have to do some reading to get a better intuition for the involved concepts
13:46:40 <MP2E> beaky : that was one of the original uses, but lens has grown to be a lot more than that :)
13:46:47 <benzrf> beaky: the lens package is huge fyi
13:46:49 <edwardk> we can build lens-likes with respect to strength that respects other monoidal structures. e.g. if we pick to respect 'Compose'      composeStrength :: p f g -> p (Compose x (Compose f y)) (Compose x (Compose g y))  -- then you can have a lens that views out a 'segment of composed functors out of a bigger functor composition.
13:47:15 <edwardk> now ou can write something that views the reader structure out of state, or one that views the (,) e functor out of state
13:47:22 <benzrf> beaky: when i launch ghci, tab-completion has 470 suggestions. if i import Control.Lens, i now have 2074
13:47:40 <edwardk> sadly while this can pick out an applicative structure out of a tower of applicatives, it doesn't generalize to give a principled mmorph
13:47:41 <MP2E> heh o.O
13:48:20 <MP2E> edwardk : mmorph = monad morphism?
13:48:31 <MP2E> just a guess, haven't seen that word before
13:48:31 <MP2E> :V
13:48:44 <benzrf> beaky: if you use the pair-of-getter-and-setter representation of a lens, compo looks like:
13:48:45 <prooftechnique> @hackage mmorph
13:48:46 <lambdabot> http://hackage.haskell.org/package/mmorph
13:48:47 <edwardk> MP2E: http://www.haskellforall.com/2013/03/mmorph-100-monad-morphisms.html
13:48:58 <MP2E> Ah thanks :)
13:48:59 <edwardk> MP2E: meant the package
13:49:58 <edwardk> anyways, in a more general setting you can do more and get generalized traversals, generalized prisms, etc.
13:50:31 <benzrf> (get', set') . (get, set) = (get' . get, (\v d -> set (set' v (get d)) d))
13:50:33 <benzrf> iirc
13:55:01 <dfeuer> What's a prism?
13:55:21 <dfeuer> Eh, forget it. I should probably understand a lens properly first.
13:56:10 <monochrom> prism can be partial function IIRC
13:56:59 <benzrf> dfeuer: a lens gets and sets a section of a product type.
13:57:13 <benzrf> dfeuer: a prism maybe-gets and maybe-sets a section of a sum type
13:57:24 <benzrf> also you can invert prisms to rewrap values
13:57:34 <monochrom> nice
13:57:40 <MP2E> that's a wonderfully succinct description, thanks
13:59:38 <benzrf> it's basically just a copy of what the lens docs say :po
13:59:40 <MP2E> so basically Lenses can't fail and are the model of getting and settings things, traversals allow you to traverse through a product type and prisms allow you to use sum types(with the notion of failure)?
13:59:41 <benzrf> * :p
13:59:53 <benzrf> MP2E: well, it's not quite that clean-cut
14:00:13 <xcv_> hi
14:00:21 <prooftechnique> Hi
14:00:45 <beaky> lenses are awesome
14:00:45 <xcv_> I'd like to write an application that keeps state and refreshes it via network
14:00:58 <benzrf> lens has a whole system of various kinds of optics, each of which is really just a varyingly constrained version of `p a (f b) -> p s (f t)'
14:00:59 <beaky> like the purely functional version of accessors and mutators
14:01:01 <xcv_> and I'd like to know what's the best way to do the downloads
14:01:04 <L8D> Is there a library out there for 2D games?
14:01:12 <beaky> L8D: like rogulikes?
14:01:12 <HeladoDeBrownie> xcv_, over HTTP or what?
14:01:18 <L8D> A *good* game...
14:01:25 <xcv_> HeladoDeBrownie: yes, HTTP
14:01:27 <benzrf> for example, a "lens" is something where f must be a Functor and p is (->)
14:01:29 <L8D> DERP :s/game/library
14:01:33 <etandel> Ooooh, a Love2d-like lib for haskell would be awsome.
14:01:36 <L8D> beaky: Think, platformer
14:01:38 <xcv_> how can I implement a network worker that's constantly waiting for job to do?
14:01:38 <benzrf> a prism allows p to be any profunctor but restricts f to applicative
14:01:43 <HeladoDeBrownie> @hackage HTTP
14:01:44 <lambdabot> http://hackage.haskell.org/package/HTTP
14:01:56 <benzrf> something could satisfy both of those constraints, in which case it would be considered both a lens and a prism
14:02:02 <prooftechnique> @hackage pipes-http
14:02:02 <dfeuer> benzrf: , what is a profunctor?
14:02:02 <lambdabot> http://hackage.haskell.org/package/pipes-http
14:02:03 <benzrf> at least, according to the types
14:02:05 <xcv_> I'd prefer to avoid spawning threads and connections all over the place
14:02:11 <benzrf> dfeuer: don't worry about it x.x
14:02:13 <HeladoDeBrownie> xcv_, the first thing that occurs to me to do is to have a thread blocking on reading a queue of jobs
14:02:26 <prooftechnique> dfeuer: They're *really* good at fmapping
14:02:36 <benzrf> prooftechnique: ;)
14:02:37 <MP2E> dfeuer : a profunctor is a bifunctor that is contravariant in the first argument and covariant in the second.   https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors
14:02:37 <HeladoDeBrownie> xcv_, why avoid threads? Threads are great
14:02:40 <dfeuer> Har dee har.
14:02:54 <benzrf> dfeuer: that's actually a proper description :[
14:03:01 <MP2E> he's right :P
14:03:01 <benzrf> dfeuer: i learned profunctors from that link, though
14:03:04 <benzrf> it's pretty good
14:03:10 <xcv_> HeladoDeBrownie: I've been googling for a while and I've seen that threads are not the only problem. I'd prefer not to spam new connections
14:04:10 <hseg> RFC: I'm trying to equationally derive the definition of foldl in terms of foldr, and I'm somewhat stuck. Also, I'm not sure if I'm not overcomplicating stuff. http://lpaste.net/108776
14:04:14 <HeladoDeBrownie> xcv_, why might you need to spam connections?
14:04:27 <benzrf> @faq does this command still work
14:04:27 <siriusbtx> can you guys recommend some good readings on the theory behind haskell?
14:04:27 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:04:29 <benzrf> aw
14:04:42 <hseg> Any advice on how to move foreward is appreciated.
14:04:51 <benzrf> siriusbtx: this is extremely good for category theory http://wwwhome.ewi.utwente.nl/~fokkinga/mmf92b.pdf
14:05:06 <xcv_> HeladoDeBrownie: I've thought about having timers and user-triggered updates, I'd like to keep a maximum number of running downloads at the same time. Just to be sure
14:05:07 <benzrf> siriusbtx: assuming you know the basics of abstract algebra
14:05:31 <etandel> the problem with haskell definitions is that they have really complex descriptions, but often very simple concepts. like "a hylomorphism is the composition of an anamorphism and a catamorphism"
14:05:47 <siriusbtx> benzrf: thx
14:05:54 <etandel> When it's basically "folding an unfold"
14:05:56 <benzrf> siriusbtx: if you know what a monoid homomorphism is, you should be fine for that paper
14:06:11 <vanila> no one uses hylomorphism/anamorphism/catamorphim, this rubbish
14:06:12 <HeladoDeBrownie> xcv_, it sounds like there's some relevant detail of your problem that you haven't mentioned
14:06:15 <vanila> jst cal it a fold
14:06:26 <vanila> there's nothing to gain from obscure terminology
14:06:30 <benzrf> vanila: b-but muh formalism
14:06:33 <xcv_> prooftechnique: I've been thinking of learning pipes or conduit for a while, this may be a good reason to start. Which one would you recommend?
14:06:54 <xcv_> HeladoDeBrownie: Not really, perhaps I'm just overthinking a simple problem
14:06:55 <benzrf> xcv_: i dont know conduit but i can tell you that pipes is super simple
14:07:02 <benzrf> xcv_: you could probably learn both
14:07:15 <prooftechnique> I recommend pipes, but for your usecase it's up to taste. They both use http-client, now
14:07:27 <xcv_> benzrf: Well, I guess it's time to start then
14:07:45 <xcv_> prooftechnique: I heard that pipes is very nicely designed, I like that
14:07:56 <prooftechnique> :)
14:07:59 <benzrf> hey johnw want to get in on this argument-to-be
14:10:55 <benzrf> xcv_: pipes, at least, is really just a set of combinators over a monad transformer that models computations that may take input or send  output during processing
14:11:28 <Irene22>  You can find funny videos here. http://bit.ly/1o7dGrl
14:11:47 <monochrom> benzrf: I like his calculational way too. (I like calculational.) in particular the easy calculations that prove several definitions of adjunction equivalent.
14:11:58 <benzrf> i dont know anything bout adjuncts
14:12:18 <benzrf> but i like when alternate views of something are equivalent
14:14:36 <hseg> What do you call it when f.g.f = f and g.f.g = g, but f.g /= id and g.f /= id?
14:15:08 <merijn> hseg: automorphism
14:15:16 <benzrf> inner automorphism?
14:15:37 <benzrf> hold on
14:15:40 <benzrf> hseg: whats an example o-O
14:16:30 <benzrf> when will f . g = f if g /= id?
14:16:39 <nitrix> Oh mah. The quicksort in Haskell.
14:16:41 <monochrom> every Galois connection is an example. but a Galois connection also requires ∀x,y. f x ⊑ y iff x ⊑ g y
14:16:48 <nitrix> My mind is blown.
14:16:50 <benzrf> oh i guess if you have something like
14:16:52 <benzrf> g = reverse
14:16:55 <benzrf> f = something . sort
14:17:08 <vanila>  The quicksort in Haskell isn't quick
14:17:23 <vanila> just so you know, it's not the same algorithmic efficiency
14:17:45 <L8D> What's the command to ignore joins and leaves in IRC?
14:17:52 <L8D> IRC or Irssi
14:17:53 <benzrf> L8D: depends on your client
14:17:56 <L8D> irssi
14:18:02 <HeladoDeBrownie> L8D, depends on your client, there might not be one, it might be a script
14:18:06 <benzrf> @google irssi ignore leaves and joins
14:18:07 <benzrf> :p
14:18:08 <lambdabot> http://www.irssi.org/documentation/tips
14:18:08 <lambdabot> Title: Irssi - The client of the future
14:18:08 <etandel> L8D: /ignore JOINS #channel
14:18:13 <L8D> etandel: Thanks
14:18:19 <etandel> or rswap joins and channel
14:18:22 <monochrom> an example of Galois connection: f converts Real to Integer, g = floor. (or the other way round.)
14:18:36 <etandel> L8D: /help ignore should help. =)
14:18:50 <genisage> etandel: channel comes first
14:19:00 <etandel> genisage: thx
14:19:02 <merijn> vanila, nitrix: That's why I usually point people to mergesort instead, mergesort has an almost equally simple implementation, but much better complexity in a purely functional language :)
14:19:05 <hseg> The case where I found this is when converting from a cons list to an append list. Since there are several equivalent append lists for a cons list, then all you can say is that they form automorphisms, but they are not identities.
14:19:19 <vanila> I like insertion sort, everyone  knows its slow
14:19:44 <genisage> I like heapsort.
14:20:20 <benzrf> xcv_: if you're still there, there are 2 big differences i know of between pipes and conduit
14:20:22 <etandel> bogosort > all
14:20:27 <vanila> lol
14:20:41 <xcv_> benzrf: Yes, still there. I'm reading the Pipes tutorial right now
14:20:49 <xcv_> here*
14:20:49 <HeladoDeBrownie> The best sort, if implementable, would be quantum bogosort
14:21:06 <monochrom> another example of Galois connection: f :: Set People -> Set Book, f ps = (books read by everyone in ps); g :: Set Book -> Set People, g bs = (people who read every book in bs).
14:21:18 <vanila> quantum bogosort is destructive though so not in haskell :)
14:21:19 <benzrf> shit g2g
14:21:34 <jophish_> I think you'll find sleepsort to be the best sort.
14:21:42 <monochrom> then f = f.g.f means: the books I read = the books read by everyone who reads every book I read
14:21:59 <jophish_> http://e-arrows.sakura.ne.jp/images/Screen%20shot%202011-05-20%20at%2011.34.11.png
14:22:01 <hseg> Wait, I can't find a place where (inner) automorphisms in a way compatible with this case.
14:22:11 <monochrom> (or rather, f {me} = f.g.f {me})
14:22:22 <Fuuzetsu> jophish_: the text board that's from is now dead ;(
14:25:50 <arian__> can I pas -f flags to `cabal build` ??
14:26:01 <Fuuzetsu> you can to cabal configure
14:26:07 <hseg> I'm stuck with my derivation of foldl using foldr: http://lpaste.net/108776 Can someone give me a hint?
14:26:10 <Fuuzetsu> which is when it actually needs to know about them
14:26:24 <arian__> thanks
14:26:41 <dfeuer> vanila: insertion sort is not slow.
14:26:49 <vanila> O(n^2)
14:26:51 <etandel> jophish: lol. genious. reminded me of frogsort: http://www.smbc-comics.com/?id=2831
14:27:46 <Fuuzetsu> etandel: there is so much crap on that page that it took a while to load it all, now just waiting for actual content…
14:28:22 <Walther> etandel: for fun, look up bogobogosort
14:28:34 <dfeuer> Yes, vanila, it's slow when n is large. When n is small enough, it's actually very fast, which is why mergesort algorithms tend to switch to it one the pieces get small enough.
14:28:42 <vanila> ok, I agree
14:30:26 <Fuuzetsu> is there a way to stop GHC from complaining about ambiguous literals inside ANNs with OverloadedStrings? It seems that I can't even hack around with with :: String
14:30:55 <joelteon> the only way I know is :: String
14:30:58 <joelteon> what's it complaining about then
14:31:30 <tulcod> -- Dear future maintainer,
14:31:32 <tulcod> -- I'm sorry.
14:31:37 <monochrom> I once was a depraved computer scientist. I invented this gory sorting algorithm: cut fingers from people's hands, using finger lengths to stand for the numbers to be sorted. align the bundle of the fingers vertically on a table.
14:32:15 <Fuuzetsu> oh wait :: String worked, I just have multiple annotations and apparently can't read line numbers
14:32:45 <cmccann> numbers are very confusing. I ignore them whenever possible.
14:32:59 <monochrom> perhaps line fingers may help you :)
14:33:45 <hseg> monochrom: Something like a gorier version of https://en.wikipedia.org/wiki/Spaghetti_sort ?
14:33:55 <monochrom> yeah!
14:34:03 <etandel> Walther: lol. O(n!^n!)
14:35:24 <cmccann> sleepsort IS pretty cool though. it's O(1) with respect to the number of items being sorted! clearly very efficient.
14:35:30 <nitrix> Partial application <3
14:35:38 <nitrix> This Haskell man...
14:35:47 <monochrom> "designed not to succeed before the heat death of the universe on any sizable list" :)
14:36:01 <nitrix> Are you talking about bogobogosort?
14:36:04 <moghedrin> nitrix: Smexy stuff, aye?
14:36:45 <nitrix> So... just wondering, currying is a requirement for partial application, right?
14:36:53 <nitrix> If I understood everything correctly?
14:37:33 <nitrix> Or it least, it does make it easier to use.
14:37:36 <cmccann> nitrix: depends on which way you feel like quibbling over semantics
14:38:00 <nitrix> What does semantics say?
14:38:49 <tulcod> nitrix: it's sort of the same thing imo
14:38:57 <cmccann> currying makes partial application the default, but you can always jump through various hoops to do partial application without it
14:39:01 <monochrom> semantics says that every sentence is false because of anal pedantic technicalities
14:39:15 <cmccann> either building a lambda or using some sort of record holding the pre-applied arguments
14:39:27 <nitrix> cmccann: Thanks.
14:39:35 <cmccann> monochrom: including that sentence?
14:39:43 <monochrom> I think so
14:40:15 <tulcod> cmccann: the sentence is false, but not for anal pedantic technicality reasons
14:40:35 <cmccann> nitrix: e.g. imagine a struct in C holding a function pointer and a linked list of arguments, or something
14:40:44 <cmccann> it'd be horribly un-type-safe but that's beside the point
14:41:29 <cmccann> do some hand-waving and call it "abstraction" and you have something that looks just like partial application. when it works, at least.
14:41:43 <monochrom> I go a step further. I imagine a struct in C of variable size holding a function pointer and a variable-length array of arguments :)
14:42:17 <nitrix> cmccann: Right, which still doesn't give you currying unless all your functions take that single struct as an argument. If I'm following you.
14:42:20 <nitrix> cmccann: Got it.
14:42:22 <cmccann> monochrom: how about an array of pointers into unknown regions of memory holding data that claims to be arguments
14:42:39 <monochrom> yes!
14:42:52 <nitrix> UB never gets old.
14:43:38 <cmccann> nitrix: other way 'round, more like. currying would be if every function took one argument and returned either a result or a partial-application struct.
14:43:39 <nitrix> Well, I do feel a little bit overwhelmed by guards and pattern matching...
14:44:00 <etandel> wait, what's the difference between currying and partial application?
14:44:37 <nitrix> But I'm still making progress.
14:44:58 <hseg> etandel: currying means that a -> (b -> c) and (a, b) -> c are isomorphic. partial application means that f x makes sense even if f :: a -> b -> c
14:44:59 <cmccann> etandel: something involving pedantic technicalities and possibly monochrom cutting your fingers off. wait, no, that was something else.
14:45:52 <nitrix> Oh god.
14:45:55 <etandel> hseg: thx
14:46:00 <nitrix> (-4) is such a hack.
14:46:06 <dfeuer> Nitrix, it will not take long for you to understand pattern matching and standard Haskell guards. They are conceptually simple. What can be hard is reading them when they're very large.
14:46:22 <cmccann> nitrix: yes. that's one of the more annoying bits of haskell's syntax.
14:46:29 <Pythonfant> is it important that the main has type IO () or can it be any IO a (if so is the a just ignored?)
14:46:47 <monochrom> IO a, always ignored, except for a runghc bug
14:46:58 <Pythonfant> monochrom: thx
14:47:01 <ion> monochrom: What bug is that?
14:47:25 <monochrom> "main = return 42"  runghc prints 42
14:47:26 <pjdelport> runghc / runhaskell will actually print non-() result values on exit, if i recall
14:47:27 <dfeuer> Yes, nitrix, it is. (-4) should be (\x->x-4). But if you actually want what (-4) gets you in a less ugly way, you can write (negate 4).
14:47:39 <ion> monochrom: ah
14:47:42 <pjdelport> (Any particular reason it still does that?)
14:47:48 <dfeuer> Except that there's a GHC extension for negative literals, and I don't know how that relates.
14:48:22 <pjdelport> dfeuer: I think you mean (subtract 4) ?
14:48:29 <cmccann> dfeuer: I think that's just about desugaring literals and maybe rebindable syntax
14:48:32 <ion> > let (−) = (-); infixl 6 − in (−1) 2
14:48:34 <lambdabot>  1
14:48:44 <pjdelport> ion++
14:49:10 <nitrix> So (-4) will superseed the fact that - is a function?
14:49:20 <monochrom> yes
14:49:23 <dfeuer> No, pjdelport, I do not.
14:49:23 <tulcod> ion: that's evil. i like it.
14:49:46 <cmccann> nitrix: yes, the unary - is a syntactic kludge and is translated into the negate function.
14:49:59 <dfeuer> What I meant is that negate 4 gets you negative 4.
14:50:40 <dfeuer> ion: that's the opposite of evil.
14:50:53 <cmccann> dfeuer: live?
14:51:09 <dfeuer> subtract is a completely incomprehensible function.
14:51:19 <nitrix> I guess that was bound to happen if you have - a function and partial appplication. It's quite funny though.
14:51:24 <dfeuer> cmccann: yes, I will live.
14:51:26 <ion> ןᴉʌǝ
14:51:45 <monochrom> sometimes I use "evil" to mean the opposite of evil
14:51:56 <ion> coëvil
14:52:00 <monochrom> and "so bad" to mean the opposite of so bad
14:52:18 <monochrom> and "great" to mean the opposite of great
14:52:29 <merijn> nitrix: It's just unlucky, the alternative would have been to find a new operator for either subtraction or negation
14:52:45 <monochrom> anyway, SML makes you write ~4 for negative four.
14:52:56 <merijn> nitrix: So, instead people just added "subtract" as a function for right partial application of - and called it a day
14:53:00 <Zekka> merijn: Tempted to point out that Haskell already has notation for "apply an operation in prefix"
14:53:09 <dfeuer> I've read there's some sort of difference between (a+) or maybe (+a) and a simple translation to a more typical form. Is that an urban legend?
14:53:22 <Zekka> it's called "function application", and Haskell implements the non-specialcasey behavior as 'negate'
14:53:32 <etandel> lol @ "coevil"
14:53:56 <Zekka> dfeuer: If you're getting at something deeper, I don't knw it, but those are different entities
14:54:03 <Zekka> however, + is commutative so it doesn't matter
14:54:44 <dfeuer> Zekka: it was some alleged efficiency matter, I think.
14:54:45 <monochrom> no, you misremembered. there is some sort of difference between (\x -> 4 + x) and ((+) 4). the Haskell standard wants (4 +) to be (\x -> 4 + x). GHC did ((+) 4) for a long time. and I thought ((+) 4) for a long time, too.
14:54:50 <Zekka> dfeuer: If you want an example of a case where they behave differently as well, try (a++) and (++a)
14:55:05 <etandel> Well, if (*) is overloaded for, say, a matrix type, then (a*) will definitely be different than (*a).
14:55:20 <Zekka> AFAIK Haskell doesn't specialcase any translations like that based on the presumed associativity of operators though
14:55:28 <Zekka> although some rewriting rules for GHC might
14:55:30 <etandel> (at least that's what I'd expect)
14:55:34 <dfeuer> monochrom: presumably this had something to do with inlining?
14:55:43 <Zekka> er, associativity/commutativity/etc.
14:55:47 <monochrom> no
14:55:49 <dfeuer> Zekka: I am not talking about that.
14:55:55 <kazagistar> does Num have a commutativity law for (+)?
14:56:03 <Zekka> kazagistar: Not that I'm aware of, but let me check
14:56:17 <merijn> kazagistar: Num doesn't have any real laws,
14:56:30 <monochrom> ((+) 4) could be more undefined than (\x -> 4 + x)
14:56:37 <dfeuer> As far as I can tell, Num has no official laws, which is ridiculous.
14:57:01 <nitrix> What is an official law ._.
14:57:07 <Zekka> Yeah, when I google "num laws" I get other people's Ring, Group, etc. definitions
14:57:30 <Zekka> nitrix: Something that the author of a typeclass tells you instances of the typeclass should accomplish, but which can't be demosntrated in type alone
14:57:40 <nitrix> I see.
14:57:47 <Zekka> Usually they're phrased as identities like this one: fmap f . fmap g == fmap (f . g)
14:58:09 <kazagistar> nitrix: documented ones... see Functor laws for example https://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Functor.html
14:58:11 <Zekka> where == is not haskell == but 'results in the same for the same input'
14:58:30 <Zekka> So the one I just gave you is one of the Functor laws, for instance
14:58:38 <dfeuer> As far as I'm concerned, a proper Num instance forms a ring, at least.
14:59:09 <monochrom> Num is an area of conflict of many stakeholders
14:59:12 <L8D> What hackage can I use to build a 2D graphical platformer game?
14:59:27 <Zekka> L8D: I think there's a few game engines on hackage, let me check
14:59:28 <monochrom> an area of conflict is necessarily lawless
14:59:40 <Zekka> minding that I haven't used any
14:59:45 <Fuuzetsu> L8D: I've been using freegame but it has no sound support yet
14:59:53 <L8D> Hm...
14:59:58 <dfeuer> But not all real Num instances form rings. Floating point and natural numbers notably.
15:00:21 <Zekka> Personally I think Num is a usability/correctness tradeoff in favor of usability
15:00:29 <L8D> Whenever I build freegame or anything involving C compilation I get a bunch of erros :(
15:00:29 <Fuuzetsu> free-game*
15:00:48 <L8D> Wait no...It's only the "text" package which fails to build
15:00:55 <Zekka> there's a lot of things we use the Num-style noation for that aren't 'numeric' in the same way
15:01:16 <zwer> why? <monochrom> ((+) 4) could be more undefined than (\x -> 4 + x)
15:01:22 <monochrom> matrices. functions.
15:01:35 <kazagistar> dfeuer: what does a Num instance for nat do for negate and abs?
15:01:40 <Pythonfant> L8D: there is also helm http://helm-engine.org/ (haven't used it myself)
15:01:42 <dfeuer> (Rings with unity, I should say, where 1_R = fromIntegral 1)
15:01:44 <kazagistar> dfeuer: scratch that second one lol
15:01:59 <dfeuer> kazagistar: that's why tney're problematic.
15:02:15 <Zekka> Helm was the one I was looking for
15:02:21 <Zekka> ditto on not having used it though
15:02:29 <monochrom> I could code up: "(+) 4 = undefined". then ((+) 4) is undefined. but (\x -> 4 + x) is defined. as far as seq is concerned.
15:02:38 <kazagistar> dfeuer: I guess you could just have abs, negate, and signum be noops, and call it a day
15:02:48 <dfeuer> I think Nats form a ringoid.
15:03:01 <dfeuer> kazagistar: that would be an utterly terrible idea for negate.
15:03:31 <dfeuer> Some people use the word rig.
15:04:32 <L8D> I keep getting this whenever I try to install text: http://lpaste.net/108785
15:04:46 <hseg> dfeuer: Others would use the term semiring
15:04:54 <hseg> dfeuer: but rig is also nice.
15:05:51 <hseg> Can someone offer a hint on how to proceed here: http://lpaste.net/108776 ?
15:06:45 <cmccann> obviously negate on nats should give you the two's complement. that sounds sensible.
15:07:27 <sipa> two's complement with how many bits?
15:07:36 <amosr> L8D: that’s strange. it looks like I managed to install text-1.1.1.3 without problems.
15:07:54 <monochrom> negation is a nice complement to natural numbers :)
15:07:55 <dfeuer> cmccann: that is insane.
15:07:59 <cmccann> sipa: however many the instance feels like I guess
15:08:05 <amosr> L8D: you could try doing a “cabal unpack text-1.1.1.3” then modifying that line by hand
15:08:18 <sipa> cmccann: i was hoping you'd say "as many bits as the number has"
15:08:25 <cmccann> sipa: that works too
15:08:29 <L8D> amosr: What would I modify?
15:08:33 <sipa> cmccann: because then fix negate == const 0
15:08:49 <cmccann> sipa: oh, nice. that's delightfully awful.
15:08:55 <kazagistar> I mean, its clear that the numeric stack is a touch silly, but we tolarate it as a good enough comprimise, and try to not abuse it too much
15:09:16 <dfeuer> The Integer instance of Bits has twos complement out to infinity.
15:09:21 <amosr> L8D: I’d have a look at Data/Text/IO. hmm. what version of ghc are you using?
15:09:34 <L8D> 7.8.2
15:10:03 <kazagistar> dfeuer: there is a Bits instance for Integer? how hilarious
15:10:09 <L8D> http://hackage.haskell.org/package/text-0.7/docs/src/Data-Text-IO.html doesn't seem to have the same error
15:10:15 <dfeuer> kazagistar: its silliness leads to pain and suffering. If you do not believe this, read the source code for GHC.Enum.
15:10:30 <cmccann> the Enum instance for () is the best worst thing
15:10:38 <cmccann> > succ ()
15:10:39 <dfeuer> Yes, kazagistar, a fact I think is rather unfortunate.
15:10:40 <lambdabot>  *Exception: Prelude.Enum.().succ: bad argument
15:10:42 <cmccann> > pred ()
15:10:44 <lambdabot>  *Exception: Prelude.Enum.().pred: bad argument
15:10:55 <monochrom> > [() .. ]
15:10:57 <lambdabot>  [()]
15:11:07 <kazagistar> wat
15:11:15 <amosr> L8D: that’s funny. I did a cabal unpack and looked at that line. there’s actually a line break in there for me
15:11:34 <cmccann> monochrom: still better than floats I guess
15:11:39 <L8D> ooo! I should make a PR for this hidden newline
15:11:55 <cmccann> > [0, 0.6.. 1.0]
15:11:57 <lambdabot>  [0.0,0.6,1.2]
15:12:06 <cmccann> 1.2 is definitely part of the range I asked for, yes
15:12:06 <amalloy> that seems like a pretty reasonable Enum instance for (), right? the joke is that it seems useless but is really just fine?
15:12:18 <amosr> L8D: could it be something weird with unix / dos line endings? I’m not sure
15:12:33 <L8D> amosr: Wait...Where is the line break?
15:12:38 <dfeuer> cmccann: the problem with the Enum instance for () is that [(),()..] doesn't fuse, whereas repeat () does.
15:12:42 <amosr> L8D: but if you just cabal unpack, add that newline, then cabal install it the local one it should work
15:13:04 <Fuuzetsu> is there a good filesystem lib? I'm tired always parsing stuff by myself, say I just want to get all files with some extension in the directory
15:13:06 <amosr> L8D: after the ‘\r’ on line 236
15:13:06 <L8D> I just unpacked and went to line 218
15:13:22 <L8D> oh
15:13:53 <L8D> amosr: That looks normal to me
15:14:03 <dfeuer> Fuuzetsu: what is an "extension"? Yes, I know approximately what you mean, but that concept is more or less useful depending on the system involved.
15:14:07 <L8D> http://lpaste.net/108789
15:14:42 <amosr> L8D: wow, that’s weird. maybe it’s a tab/space issue? hm
15:15:07 <L8D> I'm guessing there is a \r instead of \n
15:15:15 <L8D> and ghc doesn't read \r properly
15:15:21 <Fuuzetsu> dfeuer: right, I'm aware but say I just want to find anything *.something for my something
15:15:40 <amosr> L8D: can you do a cabal build of the unpacked version?
15:15:57 <L8D> I'm running cabal install && cabal build
15:15:58 <L8D> right now
15:16:08 <Fuuzetsu> I just want an easy way to get similar results to ‘ls *.foo’ without having to get all files in the directory then creating filters by hand
15:16:10 <L8D> in the unpacked version
15:16:34 <amosr> cool. my unpacked version just managed to compile fine
15:16:49 <L8D> amosr: And you were able to compile fine?
15:16:58 <L8D> through cabal install text?
15:17:13 <L8D> :O I'm getting the same error when I build
15:17:14 <amosr> L8D: I think so, but that was a while ago
15:17:34 <amosr> well, at least it’s consistent :/
15:17:35 <monochrom> "cabal install && cabal build" is a very strange sequence. if you actually know what the two parts do
15:17:49 <L8D> What's the difference exactly?
15:17:52 <dhrosa> Fuuzetsu: what's wrong with getting a list of files via getDirectoryContents, and then filter (endswith ".foo")
15:18:07 <monochrom> the "cabal install" part already does "cabal build"
15:18:24 <Fuuzetsu> that's what I normally do but I've done it so many times you'd think there would be a package with these little utilities
15:18:29 <monochrom> read my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#install
15:18:32 <Fuuzetsu> (and that's in fact what I'm doing right now)
15:18:56 <dhrosa> Fuuzetsu: kind of like glob for python? (if you've ever used it)
15:19:21 <L8D> wtf...I changed the file and added a comment between the two lines and stuff but cabal keeps throwing the error as if it wasn't using that file
15:20:11 <etandel> Why not just `getGlob glob = filter (endswith glob)` ?
15:20:13 <Fuuzetsu> haven't used it but probably
15:20:21 <dhrosa> etandel: that's what he's doing it
15:20:28 <dhrosa> that's what he's doing*
15:21:14 <etandel> oh
15:21:20 <monochrom> Fuuzetsu: windows users need this utility greatly, but linux users don't. this may explain the demand-supply
15:21:46 <amosr> L8D: huh…
15:21:50 <L8D> weird
15:22:06 <Fuuzetsu> monochrom: How is it not useful to have such utilities on either system?
15:22:27 <Fuuzetsu> I'm talking about a library making it easier to work with files for the programmer
15:23:33 <L8D> amosr: I just put brackets and semicolons in and I guess it compiles now
15:23:55 <L8D> Maybe my editor tried to keep inserting more \rs instead of \n
15:24:25 <amosr> maybe. I don’t understand why it worked for me, and not for you
15:24:33 <L8D> oh greay
15:24:36 <L8D> another error
15:24:45 <L8D> Data/Text/Lazy/Builder/Int.hs:215:32: parse error on input ‘#)’
15:24:57 <amosr> I’m ghc 7.8.2, cabal 1.20.0.3, OSX
15:24:58 <dmwit> Fuuzetsu: It is less needed in Linux programs because globbing is done outside the program (by the shell).
15:25:12 <dmwit> Fuuzetsu: That's not to say it would never be useful. Just that it's less often useful.
15:25:13 <etandel> I can't remember who said "In haskell you don't have .dll hell, but you get cabal hell which may be worse."
15:25:21 <L8D> amosr: same but cabal 1.21
15:25:28 <L8D> I gtg but hanks
15:25:30 <L8D> thanks*
15:25:30 <amosr> L8D: that’s funny. as if magic hash or unboxed tuples aren’t enabled
15:26:06 <amosr> ok, talk later. hope it gets sorted
15:26:27 <Fuuzetsu> dmwit: except when we need the program to do some stuff instead of relying on the user to do that, which is always the case if your already using getDirectoryContents + filtering
15:26:39 <Fuuzetsu> the program doesn't stop and let the user input paths manually
15:27:14 * dmwit nods agreeably
15:27:24 <dmwit> Not "never useful", just "less often useful".
15:28:40 <Fuuzetsu> s/your/you're/
15:28:42 <Fuuzetsu> god damn it
15:29:18 <dmwit> Perhaps also relevant is that Windows has a much stronger tradition of GUIs/long-running interactive programs, whereas Linux has a much stronger tradition of one-shot program runs.
15:29:56 <dmwit> Hence your comment about "the program doesn't stop and let the user input paths manually". In Linux, that is in fact exactly what happens, mostly.
15:31:01 <Fuuzetsu> what's a good way to improve attorparsec error messages? <?> ?
15:31:22 <Fuuzetsu> deconstructing parsers in GHCi to find out what's breaking it all is tiresome
15:31:53 <dmwit> ooo, parsers with good error reporting
15:31:57 <dmwit> That's a tough problem. =P
15:32:11 <dmwit> I think the widely accepted answer is "write it manually instead of relying on a tool".
15:32:39 <Fuuzetsu> That's stupid.
15:32:55 <Fuuzetsu> that might as well say ‘ignore parsing libraries and reimplement them all badly yourself’
15:33:05 <dmwit> That is exactly what it says, yes.
15:33:10 <Fuuzetsu> <Fuuzetsu> That's stupid.
15:33:17 <dmwit> I never disagreed with you.
15:33:25 <mmmm> a <- getInput; traceShow a (return ())
15:33:26 <Fuuzetsu> Good
15:33:27 <dmwit> But I've also never seen a better idea.
15:33:33 <mmmm> no better way lol
15:33:50 <Fuuzetsu> mmmm: parseOnly (p *> takeText) is what I have been doing
15:33:56 <dmwit> The other choice is to give up on good errors. That's the choice GHC made.
15:34:00 <Fuuzetsu> and keep going adding parsers until I hit the problem
15:34:18 <Fuuzetsu> I'm sure I can do better than Left "Failed reading: takeWith" though
15:35:16 <dmwit> If your goal is merely mediocre error reporting, you can use <?> and sprinkle failure points (e.g. <|> fail "I tried such and such but it didn't work out") in a few places.
15:35:36 <mmmm> a liberal smattering of trace statements never did anyone any harm
15:35:37 <Fuuzetsu> yes, that's my goal, it's just to debug the parser
15:35:39 <sm> Fuuzetsu: I like this trace for parsec: https://github.com/simonmichael/hledger/blob/master/hledger-lib/Hledger/Utils.hs#L363
15:36:20 <Fuuzetsu> I'm using attoparsec, don't think that will work there, will it?
15:36:46 <sm> no, but in case it gives you ideas. Maybe you can do something similar with attoparsec
15:36:55 <Fuuzetsu> dmwit: I think I don't misunderstand what <?> is meant to be doing: parseOnly ("hello world" <?> "Hello world parser failed") "no world"
15:37:01 <Fuuzetsu> gives me Left "not enough input"
15:37:29 <Fuuzetsu> of course the <|> fail "foo" way works but I thought that'd be what <?> does
15:37:59 <Zekka> Fuuzetsu: <?> does something similar
15:38:12 <Zekka> its purpose is basically to label a parser for the default error generator
15:38:33 <Zekka> So, imagine parseWord is a parser of yours that parses a word character by character
15:38:40 <Zekka> But it's giving you an error "expected character"
15:38:45 <dmwit> Fuuzetsu: I think the problem is you're throwing away all the error information by using parseOnly.
15:38:53 <Zekka> You can wrap the body of parseWord in parens and then use <?> to label the whole parser body as 'word'
15:38:58 <Zekka> And then it will say "expected word" instead.
15:39:18 <Fuuzetsu> Zekka: can you tell me why it didn't work at parseOnly ("hello world" <?> "Hello world parser failed") "no world" ?
15:39:27 <Fuuzetsu> dmwit: what should I be using?
15:39:29 <Zekka> Fuuzetsu: What did it say instead?
15:39:37 <Fuuzetsu> <Fuuzetsu> gives me Left "not enough input"
15:39:42 <Zekka> Disclaimer, I've used parsec only and I think you mentioned you're using attoparsec
15:39:48 <Fuuzetsu> yes, attoparsec
15:39:51 <dmwit> Fuuzetsu: parse
15:40:04 <Zekka> also it was like six months ago I last used parsec
15:40:51 <hyPiRion> attoparsec discards the fancy parsec error messages I think, although I haven't used attoparsec at all
15:41:37 <dmwit> Fuuzetsu: When I use parse, I get a Partial f; and f "" gives me a failure that mentions the name I put in the <?> part.
15:41:57 <Fuuzetsu> dmwit: that gives me Partial as expected but I'm not seeing anything which lets me get more failure info from there
15:42:13 <Fuuzetsu> oh, h
15:42:14 <dmwit> Fuuzetsu: let Partial f = parse (...) "no world" in f ""
15:44:20 <Fuuzetsu> hm, any idea why one fails (with parser name, yay) but the other gives me back a partial: http://lpaste.net/108792
15:45:17 <dmwit> It is odd, I agree.
15:46:39 <Fuuzetsu> it does seem that parse gives me more useful output as opposed to parseOnly
15:46:43 <monochrom> perhaps because the input is shorter than expected
15:46:52 <Fuuzetsu> yes, that could be it
15:48:08 <seanparsons> If I have some methods that allow "MonadIO m" as their monadic type of choice, is there a way of using IO to go completely sequential or ParIO to implicitly allow parallelism?
15:48:29 <seanparsons> I'm staring at something written in the applicative style and it looks at first glance like it should parallelise, but I think my understanding of this in Haskell is poor.
15:49:39 <merijn> seanparsons: Why should applicative parallelise IO?
15:49:46 <merijn> seanparsons: That actually breaks the applicative laws
15:49:53 <pjdelport> seanparsons: It *could* parallelize for Applicatives in general, but in the case of IO, it's defined to sequence from left to right.
15:50:09 <HeladoDeBrownie> seanparsons, applicative style just makes it so that one computation can't depend on the result of the previous one, however IO has the capability in general and the ordering still does matter
15:50:29 <seanparsons> I'm thinking of the ParIO case, not the IO case.
15:51:57 <dmwit> Is the type "MonadIO m => m a" actually different in a meaningful way from "IO a"?
15:51:59 <arian__> Guys
15:52:11 <dmwit> liftIO/id seems to witness the isomorphism
15:52:40 <arian__> does anybody know whatś going on here? http://lpaste.net/108793
15:52:51 <arian__> if I don't run  'cabal configure' everything works just fine
15:53:00 <Zekka> dmwit: What do you mean "meaningful"? It'd different in that it can be MaybeT (IO a) and a variety of other things
15:53:03 <Zekka> It's*
15:54:02 <seanparsons> pjdelport: My thought is to write some code so that it can be run sequentially in IO or parallel in X, whatever it is that X may well be.
15:54:45 <HeladoDeBrownie> seanparsons, I don't understand what you mean by "in X" there, but this might be of interest? http://hackage.haskell.org/package/async-2.0.1.5/docs/Control-Concurrent-Async.html#t:Concurrently And that package in general
15:55:05 <HeladoDeBrownie> It's basically a thin wrapper over threads
15:55:12 <dmwit> Zekka: Can you come up with a value of type "MonadIO m => m a" (I'll even let you monomorph the "a" to whatever you like) for which liftIO . id is not id?
15:55:21 <Zekka> dmwit: Oh, I see what you  mean
15:55:38 <Zekka> You're talking about forall. MonadIO m => m a
15:55:39 <seanparsons> HeladoDeBrownie: I'm looking for a type that will satisfy the need or running applicatives in parallel, for which there is a MonadIO instance.
15:55:43 <Zekka> forall m*
15:55:45 <dmwit> I am, yes.
15:55:52 <arian__> guys. how do I make cabal take in consideration my local sources in my sandbox  (sandbox add-source x) when running `cabal configure` ?
15:55:53 <HeladoDeBrownie> dmwit, that's something I've sort of wondered, what we'd gain or lose if we just defined everything in terms of MonadIO instead of IO
15:56:12 <Zekka> not types like MonadIO m => Int -> [Char] -> m (Int, [Char])
15:56:17 <dmwit> HeladoDeBrownie: You would indeed lose things with more complicated types.
15:56:18 <HeladoDeBrownie> seanparsons, so, you also need it to have a Monad instance then
15:56:36 <dmwit> HeladoDeBrownie: e.g. forkIO can't really correctly be done in a way that's polymorphic over the monad.
15:56:47 <seanparsons> HeladoDeBrownie: That's a given if I'm asking for MonadIO.
15:56:59 <HeladoDeBrownie> seanparsons, right, I was just making it explicit just in case
15:58:43 <seanparsons> For context I've done something similar with Scalaz where I use their IO and the Scala Futures. The method itself is written in an applicative style and if the monad used is IO, we get sequential, with Future we get parallel.
15:58:55 <HeladoDeBrownie> seanparsons, perhaps you could define a type to do what you need and then define an interpreter for it in IO
15:59:21 <Zekka> seanparsons: I bet you could define a Future type that does what you want and could be translated to IO
16:00:35 <seanparsons> I was somewhat hoping someone would've already done it. :)
16:00:49 <Zekka> It's probabl around
16:00:56 <Zekka> (I don't know where it is offhand if it is)
16:01:20 <dmwit> arian__: I notice that you have one q in the dependency but two q's in the registered sandbox source package.
16:01:25 <dmwit> arian__: Perhaps that's related.
16:01:33 <arian__> dmwit: yep that was it :)
16:06:23 <merijn> seanparsons: I think parallel IO is essentially what you get with the Async monad from the async library
16:07:33 <seanparsons> merijn: That might just get me what I need, cheers!
16:07:50 <seanparsons> I can flip between Async or Identity as the types and it should "just work".
16:22:12 <L8D> amosr: You still there?
16:22:22 <amosr> L8D: hey, yup
16:22:35 <L8D> So I have cabal 1.21 installed
16:22:39 <L8D> And you have 1.20
16:23:06 <L8D> But I don't see why cabal would have anything to do with the compiler errors
16:23:23 <amosr> it does seem unlikely
16:23:40 <L8D> Then again, I don't know how I ended up with 1.21 instead of the stable release.
16:23:57 <L8D> I might have done cabal install cabal-install --devel
16:24:29 <L8D> or whatever the flag is for dev release
16:26:26 <amosr> do I dare install cabal 1.21 to test?
16:26:39 <L8D> It will take a while to compile...
16:26:47 <L8D> You shouldn't waste your time I guess
16:28:00 <L8D> Again...the error I get is:
16:28:01 <L8D> Data/Text/Lazy/Builder/Int.hs:215:32: parse error on input ‘#)’
16:28:26 <L8D> because of the PAIR macro
16:29:25 <hseg> I'm trying to prove that the diff list trick to optimize concatenations is correct. However, it seems I missed something when reasoning about recursive structures, as I don't know how to do induction on them. This gets me into trouble here: http://lpaste.net/108796 Can someone help, please?
16:29:40 <amosr> L8D: that’s really strange. it has UnboxedTuples enabled at the start of that file, right?
16:30:04 <zq> what's the (atto)parsec counterpart to finding all occurences of /a[^\n]b/?
16:30:05 <L8D> Yep. Line one has UnboxedTyples in it
16:31:25 <merijn> hseg: Are you trying to learn how to do proofs like this or do you just care about this particular proof?
16:31:29 <L8D> "{-# LANGUAGE BangPatterns, CPP, MagicHash, RankNTypes, UnboxedTuples #-}
16:31:59 <hseg> I'd like to learn how to do proofs like this. This is an example, which might be useful as an illustration.
16:32:01 <joelteon> zq: char 'a' >> notChar '\n' >> char 'b'
16:32:07 <hseg> And to show where I'm coming from.
16:32:07 <merijn> hseg: Ok, then I have a book for you :)
16:32:08 <amosr> L8D: does something like “ghc Data/Text/Lazy/Builder/Int.hs -DINTEGER_GMP” work?
16:32:14 <hseg> :)
16:32:31 <hseg> Another one for the ever-growing list.
16:32:40 <merijn> hseg: (Unless you're already familiar with Software Foundations, I saw some people working on that in here already)
16:32:59 <L8D> amosr: I get the same error with -DINTEGER_GMP.
16:33:06 <L8D> Perhaps it goes before the file path arg?
16:33:24 <hseg> What is/are Software Foundations? I might have heard of it informally.
16:33:34 <merijn> hseg: http://www.cis.upenn.edu/~bcpierce/sf/current/index.html
16:33:45 <amosr> L8D: what about with -XUnboxedTuples as well… ?
16:33:54 <merijn> hseg: It's the book I was talking about, it's about formal proofs using Coq
16:33:57 <trap_exit> wehat's a good tutorial in haskell for Expr -> String, where I want to minimize the use of ()'s (i.e. I want the function to take into account precedence operators to minimize need for ())
16:34:13 <L8D> amosr: same fucking problem. :(
16:34:25 <amosr> L8D: I’m totally confused
16:34:30 <L8D> I think my GHC forgot how to UnboxedTuples
16:34:42 <dmwit> trap_exit: I've got an SO answer about that, one moment.
16:34:45 <merijn> hseg: Trying to proof that two functions have identical behaviour is exactly the kind of stuff it covers :)
16:35:02 <hseg> Looks awesome. I'll have a look at it.
16:35:09 <dmwit> trap_exit: http://stackoverflow.com/a/20407740/791604
16:35:27 <trap_exit> dmwit; awesome, thanks!
16:35:33 <merijn> hseg: I highly recommend using either Proof General (if you use emacs) or Coquille (if using vim) when reading the book
16:35:38 <hseg> The list of authors is impressive on its own. Add to that the fact that the topic is highly interesting to me...
16:35:51 <zq> jolteon: that doesn't find all occurences, though
16:36:03 <merijn> hseg: As the book is a literate Coq file with proofs you can walkthrough and tons of exercises
16:36:12 <zq> joelteon: ^
16:36:21 <amosr> L8D: want to try a tiny module that requires unboxed tuples?
16:36:29 <joelteon> well yeah, attoparsec isn't a regular expression engine
16:36:31 <joelteon> it's a parser
16:36:36 <L8D> amosr: Um...sure?
16:36:42 <zq> so
16:36:44 <joelteon> if you want to match a[^\n]b in a body of text, use a regex library
16:36:46 <zq> back to res
16:36:50 <trap_exit> dmwit: so basically, you have a "precedence :: Expr -> Int", and the display function, takes an extra argument, which recods current precedence; then yuou choose whetehr to put in (), based on current + next precedence, right?
16:36:53 <trap_exit> dmwit: neat, I like this solution
16:36:59 <hseg> merijn: Nice. Would you mind helping me with this specific problem anyway?
16:36:59 <dmwit> trap_exit: right
16:37:02 <L8D> Why don't I just change the unboxed tuples to normal tuples and then build?
16:37:08 <hseg> merijn: And thanks.
16:37:58 <L8D> amosr: I see why I can't do that now...
16:37:59 <merijn> hseg: It seems like a fun proof to try, but I'm too swamped to actually attempt any kind of work more intellectually involved than procrastinating here :p
16:38:31 <hseg> :P
16:38:57 <hseg> This is my own procrastination, in fact.
16:39:03 <amosr> L8D: see if this compiles? http://lpaste.net/108798
16:39:13 <hseg> Slightly more productive than other methods, but still.
16:40:16 <L8D> amosr: http://lpaste.net/108799 :(
16:40:35 <hseg> merijn: It's possible that the fact that it is 2:30AM here caused me to forget that when you do structural induction, your inductive hypothesis is available regarding all substructures. Foolish me.
16:41:00 <amosr> L8D: bytecode compiler? what does that mean? are you cross-compiling or something?
16:41:16 <L8D> I was using runhaskell...derp
16:41:32 <hseg> merijn: So that means that in this case, I know that l,r are both ($[]) . runDiff . coerce and coerce.
16:41:42 <hseg> Now to find a way to use that fact...
16:41:48 <amosr> L8D: ah, ok, runhaskell doesn’t work for me either
16:42:04 <L8D> amosr: Compiled version works fine...WTF
16:43:05 <merijn> amosr: ghci and runhaskell by default compile to bytecode and interpret that
16:43:51 <amosr> merijn: ah, right
16:44:24 <merijn> unboxed tuples only make sense for performance reasons anyway, so if you're using unboxedtuples you don't wanna do that anyway :p
16:45:12 <L8D> amosr: I'm getting "Illegal literal in type (use DataKinds to enable): "Bool"" when I try to compile with a C macro
16:45:28 <amosr> merijn: ah, the problem is compiling text, ghc doesn’t seem to be enabling unboxed tuples properly
16:45:34 <L8D> That's not relevant to boxed tuples however
16:46:08 <L8D> This is what I'm trying to run: http://lpaste.net/108800
16:47:11 <amosr> L8D: hm, that compiles fine for me
16:47:48 <amosr> what C compiler are you using?
16:48:03 <L8D> gcc 4.2.1 :O
16:48:29 <amosr> if I do gcc —version, it gives me Apple LLVM version 5.0 (clang-500.2.79)
16:48:53 <L8D> --version not -version
16:49:21 <L8D> but if you installed through homebrew it should be 4.9.1
16:49:29 <L8D> or if you installed with --devel it should be 5.0
16:49:35 <MP2E> heh why does apple mangle the version numbers, LLVM 5.0 means nothing to me in regards to the upstream LLVM version
16:49:57 <L8D> I'm going to install gcc with homebrew now...
16:50:47 <amosr> L8D: ah, my irc client replaced dash dash with em dash
16:51:17 <L8D> oh
16:51:23 <amosr> L8D: I don’t remember, but I guess that could be it. if the C preprocessor is acting strangely
16:51:48 <L8D> Now I have the gcc-4.9 runtime
16:52:02 <stepkut> I feel like I am seeing a bug in GHC 7.8.3 where all the threads are just stopping :-/
16:52:05 <L8D> How do I tell GHC which runtime to use?
16:52:14 <stepkut> my app doesn't terminate -- but nothing happens either
16:52:57 <amosr> L8D: hmm, the easiest way is just to make sure gcc on the path is the one you want
16:53:16 <jfischoff> stepkut: try the -fno-omityields flag (I might have got the name wrong somewhat)
16:53:27 <amosr> L8D: there is a ghc config file that lets you choose which C compiler to use, but I don’t remember where it is
16:53:36 <jfischoff> I’ve seen a greating thread through off the scheduler
16:53:47 <jfischoff> greedy
16:54:15 <jfischoff> -fno-omit-yields
16:54:27 <L8D> But what is the flag?
16:55:28 <L8D> sigh this is tiring
16:55:33 <amosr> L8D: maybe -pgmc gcc-4.9 ?
16:56:10 <amosr> -pgmc cmd “use cmd as the C compiler"
16:56:15 <stepkut> jfischoff: an infinite, non-allocating loop would cause the scheduler to never run, but adding that would force in some yields?
16:56:28 <amosr> ah, no, -pgmP “use cmd as the C preprocessor"
16:56:48 <jfischoff> stepkut: that is my understanding
16:56:55 <stepkut> worth trying :)
16:57:06 <jfischoff> good luck!
16:57:08 <L8D> What happened to lambdabot reporting the lpastes?
16:57:11 <L8D> I miss that
16:57:11 <L8D> http://lpaste.net/108801
16:57:30 <amosr> L8D: yeah, you need the -DINTEGER_GMP I think
16:58:12 <L8D> With -DINTEGER_GMP I'm back to the "parse error on input #)" thing
16:58:18 <amosr> argh!
16:58:24 <amosr> oh, try -pgmP instead of -pgmc
16:58:29 <merijn> You can't use normal CPP
16:58:29 <L8D> -DINTEGER_GMP with the -pgmc /usr/local/bin/gcc-4.9
16:58:35 <merijn> GHC requires -traditional
16:58:52 <merijn> Because otherwise a lot of valid haskell syntax is a CPP error
16:59:17 <L8D> pgmP just made a bunch of errors about it thinking the haskell code was C code
16:59:50 <amosr> merijn: oh, so -optP -traditional ?
17:00:17 <merijn> amosr: There might be other things you need, but AT LEAST that
17:01:12 <L8D> http://lpaste.net/108802 :(
17:01:49 <L8D> with -pgmP it has a bunch of C errors
17:02:02 <L8D> :s/C errors/C syntax errors/g
17:04:20 <trap_exit> dmwit: ping
17:04:24 <dmwit> pong
17:04:32 <trap_exit> dmwit: I think I can take that example one step further
17:04:44 <dmwit> great!
17:04:52 <trap_exit> dmwit: I should use a state monad, and put it the last precedence in the state monad
17:05:05 <trap_exit> and have >>= take into account whether or not the last one is higher or lower precedence
17:05:25 <dfeuer> This is driving me nuts. Can anyone tell me where Bool is declared to be an instance of Ord?
17:05:43 <amosr> L8D: try ghc Unboxed.hs -v -pgmP "gcc-4.9 -E -undef -traditional -Wno-invalid-pp-token -optP -Wno-unicode -optP -Wno-trigraphs -optP -m64 -optP -fno-stack-protector -optP -DTABLES_NEXT_TO_CODE"
17:05:52 <shachaf> dfeuer: In GHC.Classes, according to ghci
17:06:23 <shachaf> @google "instance Ord Bool"
17:06:23 <lambdabot> https://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/src/GHC-Classes.html
17:06:26 <shachaf> Google agrees.
17:06:46 <amosr> L8D: ghc Unboxed.hs -v -pgmP "gcc-4.9 -E -undef -traditional -Wno-invalid-pp-token -Wno-unicode -Wno-trigraphs -m64 -fno-stack-protector -DTABLES_NEXT_TO_CODE"
17:07:00 <dfeuer> Thanks, shachaf.
17:07:05 <L8D> http://lpaste.net/108803
17:08:12 <dmwit> trap_exit: Beware the monad laws.
17:08:28 <dmwit> trap_exit: Binds that do interesting things often run afoul of them.
17:08:40 <trap_exit> dmwit: hmm, good point
17:08:43 <trap_exit> I need to reconsider
17:09:09 <dmwit> Of course there's nothing stopping you from defining *actions* that do something interesting.
17:09:20 <L8D> Why did lambdabot stop reporting lpaste posts?
17:09:39 <dmwit> I think it was stopped a while ago as a spam-prevention measure.
17:09:46 <L8D> :(
17:10:24 <amosr> L8D: I accidentally left the -optP inside the quotes
17:10:28 <amosr> L8D: try this one? ghc Unboxed.hs -v -pgmP "gcc-4.9 -E -undef -traditional -Wno-invalid-pp-token -Wno-unicode -Wno-trigraphs -m64 -fno-stack-protector -DTABLES_NEXT_TO_CODE"
17:11:40 <L8D> http://lpaste.net/108804
17:11:43 <L8D> It worked?
17:11:50 <L8D> yeah it worked
17:11:59 <amosr> L8D: yayy
17:12:14 <amosr> ok. so I think if you symlink gcc to gcc-4.9 you wouldn’t need that optP junk
17:12:43 <L8D> in that one you didn't use -optP
17:13:24 <amosr> L8D: oh whoops, I meant -pgmP
17:14:19 <L8D> how to I unlink things again?
17:14:26 <L8D> Just rm? Or will that delete the original?
17:14:41 <L8D> I forgot how OS X links things
17:15:44 <amosr> L8D: yeah, rm should be fine
17:15:50 <amosr> L8D: or you can edit this, it looks like /usr/local/lib/ghc-7.8.2/settings
17:16:58 <amosr> L8D: or maybe /usr/local/Cellar/ghc/7.8.2/lib/ghc-7.8.2/settings apparently
17:18:19 <jfischoff> stepkut: Did that have any effect?
17:19:22 <L8D> Well I linked gcc to gcc.49
17:19:27 <L8D> gcc-4.9*
17:19:34 <L8D> Guess what!
17:19:39 <stepkut> jfischoff: just starting the compilations now
17:19:47 <amosr> L8D: what?!
17:19:53 <jfischoff> curious
17:20:00 <L8D> amosr: I'm getting the SAME ERROR!
17:20:07 <amosr> arghhhh
17:20:09 <L8D> parse error on input '#)'
17:20:09 <stepkut> jfischoff: me too. It seems to fit the symptoms.
17:20:17 <amosr> L8D: even for Unboxed.hs?
17:20:22 * jfischoff nods
17:20:24 <stepkut> code tries to evaluate a lazy bytestring, and then suddenly, nothing happens
17:20:24 <L8D> that one compiles just fine
17:20:40 <amosr> huh
17:20:43 <stepkut> not just in that thread, but in all other threads too
17:21:27 <L8D> amosr: I was never getting the "parse error on input #)" when I compiled unboxed.hs
17:21:55 <amosr> L8D: mm. I figured they *must* have stemmed from the same problem though
17:22:45 <L8D> wait a second...
17:23:01 <L8D> go to line 215
17:23:07 <L8D> and tell that doesn't look right
17:23:29 <L8D> the syntax
17:24:15 <amosr> hmm. actually, that should be fine
17:24:28 <L8D> Are you sure? With the expression before the |
17:24:56 <amosr> “case x of (# a, b #) | b > 0 -> bah | otherwise -> blah” is actually valid
17:25:47 <L8D> touche
17:33:49 <L8D> yeah so I have no idea what is going on
17:34:02 <octopuscabbage> has anyone used f#? how does it compare to haskell. (i'm specifically refering to the .net implementation)
17:34:19 <L8D> octopuscabbage: Do you know a lot of C3?
17:34:22 <L8D> C#*
17:34:39 <octopuscabbage> i know a lot of java and the guy i work with knows some C#
17:34:58 <amosr> L8D: I have no idea either. it’s very strange
17:35:06 <amosr> I gotta go out. be back soon
17:35:10 <L8D> cya
17:35:15 <dmwit> F# is okay. Missing out on higher-kinded polymorphism sucks.
17:35:29 <octopuscabbage> what things is it missing?
17:35:30 <dmwit> I haven't actually used it. I'm just reporting what other people say when they discuss this question
17:35:30 <L8D> octopuscabbage: You'd have better luck using something like Scala then
17:35:36 <L8D> for Java.
17:35:48 <L8D> Then again, as far as .NET usage goes...
17:35:58 <L8D> F# is much better long term over C#
17:36:00 <dmwit> octopuscabbage: Functor, Applicative, Monad... but also like StateT and other transformers are also completely gone
17:36:11 <octopuscabbage> L8D well we work in a very small microsoft only company. he also has decent knowledge of .NET
17:36:21 <octopuscabbage> dmwit: F# doesn't have monads?
17:36:32 <ab9rf> the comments that i've read about F# are on the lines of "not a bad effort, but could be better"
17:36:53 <L8D> octopuscabbage: Check out this and see if you like it: http://learnxinyminutes.com/docs/fsharp/
17:36:55 <dmwit> octopuscabbage: It has them in the sense that it has types which would be monads, if the language could express that fact.
17:37:09 <dmwit> octopuscabbage: But there's no way to write code like in Haskell that abstracts over which monad it uses.
17:37:15 <ab9rf> nobody seems terribly excited about F# except for people who are reqired to use a .NET platform
17:37:17 <dmwit> octopuscabbage: Which means no code reuse between monads.
17:37:19 <dmwit> That's a big loss.
17:37:21 <ab9rf> which basically means microsoft employees
17:38:01 <octopuscabbage> L8D I used it a bit at work today for a small project, it was pretty cool.
17:38:16 <octopuscabbage> L8D, it had nice interop with C# which part of our project was already in
17:38:42 <dmwit> Also no chance of Foldable, Traversable, etc.
17:38:43 <octopuscabbage> ab9rf: i mean it doesn't really seem like something innovative which is why i don't think there are any hype people
17:39:09 <octopuscabbage> to me it seems like the language is basically to get functional programmers on .NET which i suppose is worth somethign
17:39:27 <ab9rf> octopuscabbage: i think it was an effort to come up with a "functional" languge for the .net platform, basically.
17:39:50 <octopuscabbage> ab9rf: yeah that's what it seems like. it kind of seems like a bastard child of haskell, scala, and common lisp
17:40:01 <ab9rf> octopuscabbage: MSFT didn't want not to have an entry in that space, and F# is what they threw together.  kinda ironic because MSFT was a big haskell player for years.
17:40:16 <octopuscabbage> ab9rf: MSFT?
17:40:27 <dmj`> F# is very similar to OCaml
17:40:51 <dsturnbull> i dunno about F#, but scala sucks big time. NPEs galore, inherited from crappy JVM libraries
17:40:56 <carter> @ask acfoltzer ping, lemme know whens a good time to chat please :)
17:40:57 <lambdabot> Consider it noted.
17:41:09 <octopuscabbage> F# does have one great thing going for it. the lambda identifier is literally "fun"
17:41:27 <dsturnbull> language-enforced fun? :)
17:41:37 <octopuscabbage> dsturnbull: thats' what turned me off as well. the jvm interop was not easy to use or clean
17:41:39 <eitan_chatav> there shouldn't be a lambda identifier at all...
17:41:48 <dsturnbull> eitan_chatav: like \ ?
17:41:50 <eitan_chatav> i just wanna write "x -> x^2"
17:42:14 <eitan_chatav> yeah, it's like if you had different notation for (,) at the type and value level
17:42:25 <eitan_chatav> it's cute to have the same notation
17:42:48 <octopuscabbage> well it's hard when -> is used for other things as well though
17:42:59 <eitan_chatav> yeah, cases
17:43:03 <eitan_chatav> good point
17:43:04 <dsturnbull> octopuscabbage: in my project we don't use much java interop on purpose.. the main thing we integrate against is actually in clojure (storm). but when i put a "if NPE tally reaches 10, we're switching to haskell" on the whiteboard, it only lasted 2 weeks
17:44:11 <eitan_chatav> actually, i'd like to have blank notation for lambda's...just write "_^2"
17:44:27 <octopuscabbage> eitan_chatav: IIRC scala has that
17:44:28 <eitan_chatav> or "_1 + _2"
17:44:52 <eitan_chatav> i think the new wolfram lang has something like it too
17:45:13 <octopuscabbage> it's hard on the parser to have it be wildcard and also an anonymous function
17:45:14 <timmy_tofu> I'm getting ghc-mod errors about something not being in scope which is imported inside an #ifdef CPP block. The ifdef condition is a cpp-options flag specified in the cabal file set if a cabal flag is set (cabal configure -fdevelopment). How can I get ghc-mod to set and observe the flags I use in the #ifdef condition?
17:45:49 <eitan_chatav> could be some other character...underscores are wildly overloaded
17:46:03 <merijn> timmy_tofu: Hard code that CPP option in ghc-mods command line options while checking
17:46:04 <Guest12169> Is there any use in being able to write (_ + 2) when you can write (+2)?
17:46:07 <dmj`> can anyone tell me off hand if this looks like a memory leak? It seems like memory usage keeps growing... I think the spike is when I strictly read a file into memory. https://dl.dropboxusercontent.com/u/10021156/profiling.png
17:46:17 <octopuscabbage> eitan_chatav: yeah but what else woudl you use
17:46:35 <eitan_chatav> Guest12169, the use is in having more variables and being able to put them out of order in a complicated expression
17:46:40 <octopuscabbage> Guest2169: well that's a simple example, anwhere you use a lambda could use that syntax
17:46:47 <dmj`> I have a long-running process that runs for 3 days then crashes on day 3.. Other than that it works great
17:47:00 <octopuscabbage> for example instead of filter /x->x%2==0 it would just be _%2==0
17:47:11 <octopuscabbage> err filter _%2==0
17:47:17 <oakwhiz> eitan_chatav: I really like the syntactic sugar in Scala, just from an aesthetic point of view
17:47:31 <timmy_tofu> merijn: I didn't see a CLI option for that, and if there's another way that'd be preferable, lest I end up having to change my ghc-mod command (in vim, eg) every time I add something
17:47:34 <eitan_chatav> guess I have to check out Scala :-)
17:47:36 <octopuscabbage> oakwhiz: it was good at that but it also added sooooooooo many symbols
17:48:10 <octopuscabbage> oakwhiz: all the syntactic sugar was cute except when you had to memorize it all
17:48:38 <octopuscabbage> https://stackoverflow.com/questions/7888944/scala-punctuation-aka-symbols-and-operators case and point
17:49:25 <oakwhiz> octopuscabbage: I stopped using Scala when I realized that I was just reinventing mutable versions of stuff that already exists in Haskell
17:49:26 <Guest12169> you could write (== 0) . (%2) could you not?
17:49:51 <ab9rf> octopuscabbage: MSFT == microsoft (it's their NASDAQ symbol)
17:49:57 <hiptobecubic> octopuscabbage, 'case in point'
17:50:49 <octopuscabbage> oakwhiz; well it tried to maintain mutable and immutable version of the same datastructure with different names
17:50:56 <octopuscabbage> ab9rf, ah i see
17:51:07 <octopuscabbage> hiptobecubic: couldn't remember which one is correct haha
17:51:17 <ab9rf> oakwhiz: i looked briefly at scala and didn't see what i was getting that i couldn't get from haskell other than java interop, which i wasn't that really excited about
17:51:36 <dibblego> ab9rf: you are missing nothing
17:51:56 <oakwhiz> IMO Scala is a good stepping stone from Java to Haskell. I wouldn't be playing around with Haskell if it weren't for Scala
17:52:16 <ab9rf> every so often i get mad at ghc's build environment but it's not like moving to scala would make that better
17:52:30 <octopuscabbage> oakwhiz: yeah it got me into haskell as well
17:53:12 <ab9rf> of course, now that minecraft forge has scala components, i imagine we'll be seeing more people learning scala badly :)
17:53:13 <oakwhiz> the only thing about Scala's SBT build environment that I liked was the fact that it cleaned up the mess that is Java's Maven, while retaining compatibility
17:53:26 <hiptobecubic> i don't think it's a good stepping stone, other than as illustration that Java is Doing It Wrong.
17:53:35 <octopuscabbage>  ab9r: nothing like bad functional programming
17:53:54 <octopuscabbage> oakwhiz: sbt was pretty neato, i found it pretty easy to use as well
17:54:03 <dibblego> "learning scala badly" has been happening for a very very very long time
17:54:32 <octopuscabbage> anyone wanna co author a book on haskell called "learning scala badly"
17:54:39 <hpc> god, minecraft forge is the last thing anyone should ever use to learn a language
17:54:40 <ab9rf> haha
17:54:50 <merijn> timmy_tofu: I meant changing your ghc-mod command in vim, yes
17:55:05 <hpc> between languages being not trivial things to learn well, minecraft forge being a complicated set of multiple frameworks over a huge obfuscated codebase
17:55:07 <merijn> timmy_tofu: It's unfortunate, but afaik neither ghc-mod nor hdevtools support querying cabal for flags
17:55:08 <ab9rf> hpc: indeed, but you know that a lot of people's first programming language is learned in the context of a scriptable or moddable game....
17:55:09 <octopuscabbage> hpc: meh i mean you gotta start somewhere
17:55:10 <hpc> that was itself not the best written thing
17:55:12 <eitan_chatav> I started with haskell and whenever i ask haskell folks if i should learn another lang i get negative responses :-)
17:55:14 <hpc> and the community is assholes
17:55:26 <hpc> it has literally nothing going for it
17:55:41 <octopuscabbage> eitan_chatav: learn C# or Java so you can have a job
17:55:54 <merijn> eitan_chatav: You *should* learn other languages, but you should learn haskell *too*
17:55:54 <hiptobecubic> not a job you *want* mind you
17:55:54 <octopuscabbage> eitan_chatav: or python or ruby if you want an easier web job
17:55:56 <eitan_chatav> octoputcabbage: i have a haskell job ;-)
17:56:02 <hiptobecubic> but that's not what jobs are about :)
17:56:23 <octopuscabbage> eitan_chatav: work two jobs then
17:56:33 <hiptobecubic> eitan_chatav, what do you at work?
17:56:41 <eitan_chatav> alephcloud
17:56:45 <octopuscabbage> hiptobecubic: i work in IT, a C# or Java would be cool netbeans for me
17:56:55 <ab9rf> hpc: which is why we're seeing so much stuff with "imbeddable lua" these days....
17:57:11 <hpc> lua's even worse
17:57:41 <eitan_chatav> hiptobecubic: oh, you asked what I do...some crypto...some other stuff
17:57:48 <timmy_tofu> merijn, I see, so I'll change it expand to ghc-mod -g -DDEVELOPMENT check... thanks
17:58:09 <octopuscabbage> eitan_chatav: how does one learn crypto and not learn another language? are you self taught?
17:58:24 <amosr> L8D: hey, any luck?
17:58:25 <eitan_chatav> octopuscabbage: yes, mostly self taught
17:58:40 <octopuscabbage> eitan_chatav: i'd imagine crypto jobs are fairly hard to get being self taught
17:58:41 <eitan_chatav> I'm a mathematician transitioning to be a programmer
17:58:51 <octopuscabbage> eitan_chatav: probably unless you're a mathematician
17:58:55 <hiptobecubic> :)
17:59:12 <octopuscabbage> eitan_chatav: that explains why you like haskell then. i'm coming from the other side kind of
17:59:30 <hiptobecubic> looks like a neat product actually
17:59:36 <eitan_chatav> yeah, most people are...it's interesting to see the other point of view because it's so different from mine
18:00:17 <octopuscabbage> eitan_chatav, 'what do you mean you don't know what a monad is? didn't you have to take category theory?"
18:00:32 <eitan_chatav> lol
18:00:56 <trap_exit> format "{}{}" (a, b)
18:00:57 <eitan_chatav> i knew what a monad was before I had any idea computer scientists knew about it...it's used for _completely_ different purposes in algebra
18:01:04 <trap_exit> how does format "{}" work?
18:01:15 <trap_exit> how do I create "a tuple of one element" to feed format ?
18:01:21 <hiptobecubic> eitan_chatav, would enjoy *that* talk if you have some free time someday
18:01:26 <ab9rf> trap_exit: there's no such thing as a "tuple of one element"
18:01:44 <dmwit> ?hackage OneTuple
18:01:45 <lambdabot> http://hackage.haskell.org/package/OneTuple
18:01:48 <thinkpad20> hey guys, does anyone know how to pass command-line arguments to `cabal test`? I want it to run my hspec with terminal colors but it's all in black & white T_T
18:01:51 <eitan_chatav> sure, some day i'll give a "what's next in category theory for haskellers" talk
18:01:53 <dibblego> ab9rf: yes there is
18:02:09 <octopuscabbage> eitan_chatav: don't riom the surprise i plan to take category theory some time in my uni life
18:02:14 <ab9rf> trap_exit: use the "Only" type in Data.Text.Format
18:02:20 <octopuscabbage> eitan_chatav: ohh i can't wait
18:02:29 <trap_exit> ab9rf: ah, nice, thanks!
18:02:34 <hiptobecubic> octopuscabbage, have you studied algebra before?
18:02:58 <octopuscabbage> hiptobecubic: not that kind of algebra, my highest math i've taken right now is discrete 2 and calc 2
18:03:12 <hiptobecubic> "discrete math" :D
18:03:18 <hiptobecubic> i always thought that was funny
18:03:23 <ab9rf> my undergrad CS curriculum had no discrete math requirement
18:03:33 <octopuscabbage> ab9rf: really? mine only had two semesters
18:03:35 <eitan_chatav> take a "modern algebra" course...it's worth it
18:03:51 <ab9rf> octopuscabbage: none at all, and it was a serious deficiency in the program imo
18:03:57 <octopuscabbage> ab9rf: i feel like some schools are more focused on the comp sci aspect and some schools are more focused on the software engineering side
18:04:05 <hiptobecubic> i self-studied the intro "sets and algebra" course from the VU in amsterdam. Definitely worth it.
18:04:06 <octopuscabbage> eitan_chatav: i plan to, i plan to get a minor in math
18:04:06 <ab9rf> octopuscabbage: of course, i was a CS major in the late 80s and didn't complete the program
18:04:23 <hiptobecubic> Linear algebra was so much easier to follow
18:04:30 <hiptobecubic> i don't know why it's not always done in that order
18:04:37 <ab9rf> octopuscabbage: far too many current programs are utter garbage, focusing entirely on teaching job skills instead of computer science.
18:04:55 <octopuscabbage> hiptobecubic: i plan to take linear next next semester
18:04:56 <kristof> How do I associate documentation with a function? I was thinking of just jury-rigging a solution by mapping functions strings in a documentation hash-table.
18:05:06 <ab9rf> octopuscabbage: i remember looking at a so-called "computer science" program that had junior level classes in "Cisco switching" and "Cisco routing"
18:05:17 <vanila> kristof, you can just put it in a comment
18:05:21 <octopuscabbage> ab9rf: i agree, i'm glad my uni (even though it's kind of a shit one) focuses more on comp sci
18:05:30 <kristof> vanila: No, that's not really the same thing.
18:05:35 <hiptobecubic> ab9rf, netherlands kind of had a different field altogether. There was a master in "Software Engineering" and university of amsterdam, which was pretty clearly not "computer sciencey" as i recall
18:05:45 <hiptobecubic> at* university of amsterdam
18:06:10 <octopuscabbage> hiptobecubic: which i think is interesting considering the cs minds that came out of the netherlands (like dijkstra obviously)
18:06:11 <ab9rf> hiptobecubic: software engineering is a real thing, but it's an engineering discipline and should be approached pedagologically as one.
18:06:21 <hiptobecubic> the systems and network engineering group and programming language theory people had all the comp sci fun
18:06:22 <kristof> vanila: A program is a living, breathing entity that you should be able to poke and prod.
18:06:28 <hiptobecubic> ab9rf, agreed
18:06:47 <octopuscabbage> ab9rf: yeah but the problem with teaching it soley as an engineering field is then you become tied to a technology
18:06:50 <ab9rf> hiptobecubic: my old undergrad institution was one of the first to do that (Purdue University, with Gene Spafford as the leader)
18:06:56 <oakwhiz> You don't want to know what they teach in "computer science" crash courses as part of IT programs.
18:06:58 <vanila> a lisp program is maybe.. a haskell program is a cold dead crystal
18:07:39 <octopuscabbage> vanila: not really, you have the same expressive power you have in lisp that you do in haskell, beside a tiny subset of macros
18:07:58 <machrider> i can partially apply a functor, but i can't assign it a new name... can anyone explain why? http://lpaste.net/108807
18:08:34 <Guest12169> without clicking the link im going to say monomorphism restriction
18:08:34 <kristof> vanila: I guess it wouldn't help if I said I'm a CL fan :P
18:08:37 <okuno54> vanila: fwiw, I find it easier to poke Haskell than Lisp, but it took me some time to get to that point; oh , and I started on Scheme
18:08:57 <okuno54> vanila: your milage may vary I guess...
18:08:58 <eitan_chatav> machrider: try putting its type sig in the let
18:09:05 <Guest12169> yep, monomorphism restriction
18:09:17 <eitan_chatav> yep
18:09:40 <Guest12169> why does that restriction exist in the first place
18:09:44 <machrider> eitan_chatav: i haven't been able to come up with the type signature, for some reason
18:09:53 <Trollinator> ab9rf: I like the way Edsger Dijkstra characterized software engineering: “how to program if you can't”
18:10:13 <eitan_chatav> machrider: ghc came up with it for you!
18:10:20 <eitan_chatav> just copy & paste
18:10:25 <okuno54> vanila: oh, and there's always Template Haskell, I almost forgot
18:10:26 <Guest12169> when you did :t
18:10:28 <machrider> eitan_chatav: LOL, i tried ;)
18:10:47 <octopuscabbage> Trollinator: there is a certain skillset required to design and maintain enterprise level software though. and i wouldn't say that really falls under computer science because that's more organizational and engineering skills
18:11:01 <okuno54> vanila: admittedly, Lisp macros are _so_ much easier than Haskell macros, for exactly the reasons a Lisper would expect
18:11:21 <machrider> eitan_chatav: edited the paste: http://lpaste.net/108807
18:11:36 <octopuscabbage> okuno54: but, IMO, the ease and usability of the macro system causes the rest of the language to be harder to write
18:11:58 <octopuscabbage> okuno54: lisp style expressions are great when you need a computer to write them, but a bit harder when a human has to
18:12:04 <Guest12169> you need parens
18:12:22 <octopuscabbage> okuno54: but like i said that's entirely my opinion, and i've never gone very far into lisps
18:12:30 <Guest12169> wait, nvm
18:12:30 <eitan_chatav> machrider: hmmm, that's strange, it worked for me
18:12:32 <okuno54> octopuscabbage: though, macros actually are "a computer writing code"
18:12:43 <Guest12169> me too
18:13:07 <eitan_chatav> actually, so did the inferred type sig code
18:13:09 <octopuscabbage> okuno54: yes i understand that, but in order for those macros to be effective to write the code they operate on has to be very easy for a computer to parse as well
18:13:18 <machrider> wtf
18:13:26 <eitan_chatav> which version of ghc are you on?
18:13:30 <machrider> 7.6.3
18:13:37 <machrider> (ubuntu)
18:13:50 <Trollinator> okuno54: why do you think it's easier to generate Haskell expressions? If you like, you can write 3 + 4 as ((+) 3 4) in Haskell, which is barely different from (+ 3 4)
18:14:04 <Trollinator> Err, I mean Lisp expressions.
18:14:06 <octopuscabbage> okuno54,: because you know for a fact every expression is going to come in the form of a list, while in haskell it comes as a function which is a bit harder to parse
18:14:29 <okuno54> Tollinator: huh?
18:14:45 <benzrf> okuno54: haskell expressions tend to just be function application
18:14:46 <Guest12169> Well, it works on 7.8.3
18:14:51 <Trollinator> okuno54: sorry, I meant octopuscabbage
18:14:51 <benzrf> which is b-trees
18:14:57 <benzrf> since all functions in haskell are unary
18:15:08 <Trollinator> two mistakes in one row :(
18:15:20 <okuno54> benzf: yeah, but the interesting part is generating types. generating exprs isn't needed (for the most part) since we're lazy
18:15:23 <benzrf> sadly, we also have things like case exprs
18:15:34 <benzrf> which are not so easy to represent simply
18:15:41 <Hodapp> benzrf: how does one determine exactly that all functions are unary?
18:16:24 <eitan_chatav> machrider: Try this? let p :: (Functor f, Num b) => f b -> f b; p = fmap (+1)
18:16:35 <octopuscabbage> Trollinator: because (+ 3 4) is a list of symbols and ((+) 3 4) is a function applied to two arguments
18:16:59 <Guest12169> I don't think that works
18:17:19 <machrider> eitan_chatav: that works.
18:17:33 <Guest12169> oh, I did something stupid
18:17:43 <eitan_chatav> machrider: good
18:17:54 <okuno54>  octopuscabbage: well, re-reading your stuff, I'm not exactly sure what you're getting at; however, it's safe to say that CL macros are a bit too deadly for my tastes anyway
18:18:23 <machrider> eitan_chatav: p (Just 4) ==> Just 5
18:18:25 <machrider> yay
18:18:32 <eitan_chatav> :-)
18:18:40 <octopuscabbage> okuno54: my main point is that macros are easy to write in lisp because the language is easier to write macros for, but as a result makes the language a bit harder to write programs in.
18:18:55 <Hodapp> anyone else? what makes Haskell functions fundamentally unary?
18:18:56 <octopuscabbage> okuno54: that's just my observation on the syntax style of the language
18:19:09 <octopuscabbage> Hodapp: i think he's talking about currying?
18:19:20 <vanila> Hodapp, well you can use tuples
18:19:27 <vanila> Hodapp, e.g.  f (x,y) = x + y
18:19:29 <kristof> octopuscabbage: I'm not sure why you think it would make the language harder to write programs in. The vast majority of haskell is prefix as well.
18:20:01 <Hodapp> or, I guess, what are the consequences of the functions being unary?
18:20:04 <eitan_chatav> Hodapp, a function in Haskell is unary because given f :: a -> b -> c, that's actually f :: a -> (b -> c)
18:20:06 <Trollinator> vanila: so what? it's still one argument, albeit of a tuple type.
18:20:19 <kristof> Hodapp: Automatic currying and point free notation.
18:20:25 <okuno54> octopuscabbage: ah, though meh. surface syntax isn't so material to me
18:20:26 <kristof> Er, point free style, I suppose it's called.
18:20:30 <octopuscabbage> kristof: i'm not really talking about the prefix notation, i'm more talking about the list style expressions
18:20:32 <Hodapp> pointless :P
18:20:34 * Hodapp ducks
18:20:35 <eitan_chatav> pointless style
18:20:43 <okuno54> octopuscabbage: throw some indendation-sensitivity in and it's way more readable
18:20:47 <kristof> You're lying to me, it's pointfree
18:20:57 <kristof> Oh, that was a joke
18:20:59 <kristof> :PPPPPPPPP
18:21:00 <machrider> lol
18:21:18 <octopuscabbage> okuno54: yeah i'm not trying to make a huge revelation, it's just what i feel like
18:21:24 <okuno54> octopuscabbage: for me, I just don't like writing anything longer than one or two thousand lines in Lisp, it's too hard to refactor
18:21:29 <kristof> Point free style is beautiful for simple function compositions that you want to compose and throw up to a higher order function.
18:21:43 <kristof> ...but that doesn't really mean anything in the context of large functions. Ok, I saved 4 seconds. yippee.
18:21:55 <trap_exit> damn it, for lazy text, is there no [LazyText] -> LazyText ? I'm looking at https://hackage.haskell.org/package/text-0.7.2.1/docs/Data-Text-Lazy.html .. there's append, which is LazyText -> lazyText -> LazyText, and there's fromChunks, which is [StrictText] -> LazyText ... but I wnat [LazyText] -> LazyText
18:22:22 <octopuscabbage> okuno54: i agree, and i think it's hard to pretty print compared to most other languages
18:22:27 <kristof> octopuscabbage: Well, I don't really understand what point you're making, then.
18:23:01 <okuno54> trap_exit: it's a monoit, so `mconcat` should do what you want
18:23:10 <okuno54> trap_exit: ahem, Monoid
18:23:10 <dfeuer> trap_exit: Did you look for things called concat?
18:23:11 <mwhit> there's also a concat builtin
18:23:23 <trap_exit> dfeuer: I did, is ther eone? I could not find it
18:23:28 <mwhit> @hoogle concat
18:23:29 <lambdabot> Prelude concat :: [[a]] -> [a]
18:23:29 <lambdabot> Data.List concat :: [[a]] -> [a]
18:23:29 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
18:23:35 <mwhit> oh i guess it doesn't have it
18:23:36 <Trollinator> sometimes I wonder if we would be better of if mathematicians had chosen a postfix syntax for function application, i. e. x sin instead of sin x
18:23:37 <mwhit> but it's there
18:23:50 <trap_exit> wait, so does [LazyText] -> LazyText have a concat?
18:23:50 <trap_exit> I'm confused
18:23:51 <trap_exit> enlighten me
18:23:55 <mwhit> yes
18:23:56 <kristof> Trollinator: ...why
18:24:00 <mwhit> Data.Text.Lazy.concat
18:24:01 <trap_exit> where is it?
18:24:01 <phaskell> No symbol 'it' found anywhere.
18:24:02 <kristof> or is your name a clue as to why you're saying that :P
18:24:23 <mwhit> or, just use mconcat
18:24:39 <trap_exit> mwhit: ah, it is there
18:24:40 <trap_exit> I'm retarded; ignore me
18:24:42 <okuno54> trap_exit: `mconcat` is a more general form of `concat`. It works on all kinds of types, including lazy `Text`
18:25:40 <Trollinator> kristof: because you essentially have to read an expression like f (g (h x)) from right to left, while normal text is read left-to-right.
18:26:23 <Trollinator> which is also why some people like to use g >>> f instead of f . g
18:26:37 <mwhit> x y f is much less readable than f x y though
18:26:51 <kristof> Trollinator: Conceputally that's better. When I think declaratively, I think "the ____ of the ____ of the ____ of the . . ."
18:27:15 <okuno54> Trollinator: it's a matter of convension, which is built from many people's personal taste
18:27:19 <eitan_chatav> right-to-left combinators = declarative; left-to-right combinators = imperative
18:27:27 <mwhit> i know in f# (flip .) is the idiomatic composition style
18:27:36 <okuno54> Trollinator: I tend to use f =<< x, for example, rather than x >>= x
18:27:38 <mwhit> or whatever it is
18:28:12 <mwhit> flip $ i guess, actually
18:28:16 <okuno54> Trollinator: I guess one will win eventually
18:29:49 <Trollinator> I don't understand the “declarative vs. imperative” argument.
18:29:56 <ab9rf> i usually get lost in long function compositions
18:30:08 <okuno54> anyway, bcak to what I was here for. Does anyone have experience with OpenGL and GLFW-b?
18:31:21 <okuno54> my image and ability to hit keys turns off every other event
18:34:23 <ab9rf> okuno54: i've tried several times to use the haskell OpenGL bindings, but i never get far with it.  things just never work out well.
18:35:31 <okuno54> ab9rf: as in there are bugs in the bindings?
18:35:54 <ab9rf> okuno54: i can't assert that because i don't understand them well enough to know if i'm using them correctly
18:36:21 <okuno54> ab9rf: ah, so we're in the same boat then T.T
18:40:22 <ab9rf> okuno54: however, it sounds to me like you might have a problem with double-buffering, or with returning to the main event loop after an event
18:41:28 <okuno54> ab9rf: that's GLUT stuff, though. GLFW always double-buffers, and has no "main event loop" unless you make it yourself
18:41:46 <timmy_tofu> merijn: do you happen to know how I can set that option with ghcmod-vim? I've tried adding it a few places in autoload/ghcmod.vim without luck
18:42:18 <okuno54> ab9rf: that's why I chose it, it looks so much more modern and safer. Ironically, only my GLUT example is working
18:43:27 <gentleben> is there any way to get hint to install on ghc 7.8?
18:46:59 <octopuscabbage> anyone want a pretty simple haskell project? (it's not very difficult and we can compare + it's open ended)
18:47:21 <L8D> octopuscabbage: okay? Are you talking about pair programming?
18:47:47 <octopuscabbage> L8D: nah it's just a project for a beginner haskeller sitting in channel looking for somethjing to do, or someone at home
18:47:56 <octopuscabbage> L8D, bored at home*
18:48:23 <octopuscabbage> L8D, not necessarily pair programming, just talking about it afterwards
18:48:26 <L8D> Are you the one wanting the project or do you have one to offer?
18:48:29 <vanila> what is it?
18:48:36 <octopuscabbage> L8D, both do it
18:48:50 <vanila> im interested
18:49:16 <L8D> ^ me too
18:49:19 <octopuscabbage> vanila: http://www.reddit.com/r/dailyprogrammer_ideas/comments/2cnabm/intermediate_tamagotchi_emulator/ (idk if this counts as self promotion i really don't mean it as such i just want to see it)
18:49:55 <vanila> that's a nice idea :)
18:50:06 <vanila> I wonder if natashenka has released enough stuff to do a real tama emu
18:50:14 <L8D> I'm gonna finish this job application and get on that...Sounds like fun :)
18:50:18 <octopuscabbage> vanila: i like it because it's a project you can make as difficult or as easy as you want.
18:50:29 <vanila> yeah, that's a good kind of project
18:50:46 <octopuscabbage> L8D, I'm thinking about doing it in F# because i want to use gtk# and learn a bit of F#
18:50:55 <trap_exit> this might sound wrong ... but suppose I have "data Foo = FInt Int | FString String ; \n new_foo :: Foo \n new_foo = 2" ... is there some haskell extension that will look this up and be like "new_foo has type Foo", Foo has a constructor Int -> Foo, thus I'll just automatically use FInt ?
18:51:16 <cestdiego> hey
18:51:26 <trap_exit> I want to setup a bunch of `promotions` where it's like "anytime you have type Foo, and you need type Bar, just use __magic_blah__ to do the conversion"
18:51:48 <mwhit> that would be simple enough with a typeclass
18:51:51 <mwhit> Fooable a
18:52:00 <octopuscabbage> trap_exit, are you talking about hungarian style notation?
18:52:07 <mwhit> but "magic" i don't think is doable, and even if it were it would be a bad idea
18:52:31 <trap_exit> i want to setup a bunch of a -> b 's where it's like here's a list of cuntikons
18:52:38 <trap_exit> and if you have an 'a' an dneed a 'b' just auto apply these behind my back
18:52:56 <octopuscabbage> do you mean like fromIntegral
18:52:59 <octopuscabbage> that kind of function?
18:53:04 <mwhit> yeah but he wants it to be applied magically
18:53:12 <mwhit> the avoiding of which is pretty much half the point of haskell
18:53:21 <benzrf> cuntikons?
18:53:31 <trap_exit> suppose I'm defining an expr language, I have things like "Expr = EVar String | EInt Int | EAdd Expr Expr"
18:53:32 <octopuscabbage> trap_exit: yeah the type system idea is kind of against htat
18:53:50 <octopuscabbage> trap_exit: do you mean to derive string and numeric
18:53:51 <trap_exit> instead of things like "EAdd (EVar "x") (EInt 2)" I'd prefer to do "EAdd "x" 2"
18:53:57 <trap_exit> and have the "x" -> EVar "x", and the 2 -> "EInt 2" automagically
18:54:04 <octopuscabbage> trap_exit: you could achieve the same effect deriving types
18:54:12 <okuno54> trap_exit: the best I can think of still requires a function call. alternately, hack the compiler
18:54:32 <trap_exit> so there's no way to write "EAdd "x" 2" instead of "EAdd (EVar "x") (Eint 2) " ?
18:54:35 <mwhit> oh yeah i guess you could do IsString and take advantage of string syntactic sugar
18:54:47 <vanila> trap_exit, you can bend haskell into doing that, but you dont benefit from it
18:55:35 <okuno54> trap_exit: in that particular case, you can use a smart constructor `eAdd a b = EAdd (Evar a) (Eint b)`
18:55:57 <trap_exit_> I just got disconnected, so I don't know if everyone heard of my brilliant idea of "class ToExpr a: where to_expr :: a -> Expr"
18:56:10 <trap_exit_> then doing "instance ToExpr String", "instance ToExpr Int"
18:56:11 <mwhit> that's the first thing i told you
18:56:27 <trap_exit_> mwhit: this idea is new to me
18:56:33 <trap_exit_> so when you said the words, which i'm sure were right, I did not get it
18:56:44 <trap_exit_> it's like saying "big mac" to someone who's never eaten a hamburger
18:56:47 <mwhit> fair
18:56:54 <trap_exit_> but after they eat a big mac, then "big mac" suddenly ameks sense :-)
18:56:54 <mwhit> didn't mean to be a dick
18:57:00 <okuno54> trap_exit_: (not sure this came through) in that particular case, you can use a smart constructor `eAdd a b = EAdd (Evar a) (Eint b)`
18:57:10 <mwhit> people aren't objecting to making construction more convenient
18:57:20 <vanila> mwhit, I am
18:57:36 <mwhit> it's the idea of "magically" applied functions that goes against the whole point of the type system
18:57:53 <vanila> trap_exit, you can bend haskell into doing that, but you dont benefit from it
18:58:52 <trap_exit_> ah, this is so cool :-)
18:59:13 <trap_exit_> so then I have to define eAdd a b :: a -> b -> Expr, eAdd a b = EAdd (toExpr a) (toExpr b)
18:59:13 <trap_exit_> coprrect ?
18:59:22 <trap_exit_> thus, the 'smart constructor' part of it
18:59:32 <okuno54> trap_exit_: exactly
18:59:43 <mwhit> welll
18:59:50 <mwhit> that particular example is not very safe
18:59:59 <okuno54> trap_exit_: strictly, though you'll need to include the class constrain in your type signature
19:00:03 <trap_exit_> eAdd a b :: (ToExpr a, ToExpr b) => ...
19:00:07 <mwhit> what if you call eAdd (a::Int) (b::String)?
19:00:22 <trap_exit_> okay okay, I need to call my lawyer and retract divorce filing with haskell; back in love again
19:00:32 <okuno54> trap_exit_: and the class isn't even necessary for the technique to be "smart"
19:00:37 <mwhit> ^^^
19:00:46 <trap_exit_> mwhit: why is that a problem?
19:00:56 <mwhit> well, what should that expression evaluate to?
19:01:00 <mwhit> it's not well-formed
19:01:11 <trap_exit_> eAdd (EInt a) (EVar b)
19:01:17 <trap_exit_> EAdd (EInt a) (EVar b)
19:01:25 <mwhit> the whole idea is to make malformed expressions impossible to create
19:02:06 <trap_exit_> yeah, that is fine
19:02:09 <trap_exit_> it's an EAdd Expr Expr
19:02:10 <trap_exit_> so it's well formed
19:02:39 <okuno54> mwhit: honestly, without his code, I'm not sure what's going on back there, no offense, trap_exit
19:02:39 <haasn> trap_exit_: in the case of Int and String you can actually just overload fromInteger and fromString; but that may not always be possible cleanly - it just works here because those can be polymorphic literals
19:03:08 <trap_exit_> okay, let met write up some code so this isn't a giant ball of consufion
19:03:24 <mwhit> trap_exit_: okay, but are you saying literally any representable value in this language can be added to any other representable value?
19:03:31 <mwhit> because that's what the existence of that constructor says
19:03:52 <Trollinator> I wonder if it's possible to write a Haskell datatype that represents Haskell programs and ensures that they're well-typed.
19:04:33 <okuno54> Trollinator: this is part of a bootstrapped Haskell compiler, such as GHC
19:04:42 <okuno54> Trollinator: gimme a sec, I may have an interesting link
19:04:50 <haasn> Trollinator: It's definitely possible with GADTs + TFs + UndecidableInstances
19:04:52 <trap_exit_> gentlemen, this is all I'm saying: https://gist.github.com/anonymous/ea68f93a658e14352476
19:05:00 <trap_exit_> haasn, okuno54, mwhit: ^^^^^
19:05:03 <trap_exit_> https://gist.github.com/anonymous/ea68f93a658e14352476
19:05:41 <okuno54> Trollinator: https://hackage.haskell.org/package/thih
19:05:59 * haasn .oO( instance Num Expr where (+) = EAdd; fromInteger = EInt . fromInteger )
19:06:37 <Trollinator> It is? that surprises me… because in order to typecheck a Haskell program, you need to take into account the datatypes defined therein. So I'm surprised it's supposed to be possible without full-blown dependent types.
19:06:50 <okuno54> trap_exit: looks reasonable, despite minor spelling errors
19:07:07 <mwhit> trap_exit_: all right, that's okay as is, because any representable value _is_ actually addable to any other value
19:07:11 <trap_exit_> mwhit: any objections? :-)
19:07:17 <haasn> Trollinator: To be fair, I'm not sure if it will be of any use without full-blown dependent types
19:07:25 <mwhit> but what happens if you want to then add booleans, or some other type to which addition does not apply?
19:07:25 <trap_exit_> mwhit: ah, you were thinking GADts + Ints + Vectors + Bool types of Expr ?
19:07:26 <haasn> But I'm sure it can be done. You could probably cook something up with singletons
19:07:38 <mwhit> yes, something like that
19:07:39 <trap_exit_> mwhit: I have not gone that far. What do you recommend?
19:07:42 <okuno54> Trollinator: thih only lets you feed in a Haskell program at runtime
19:07:47 <trap_exit_> mwhit: I was going to just throw exceptions all over the place, like "you dun goofed up"
19:07:53 <mwhit> yeah definitely don't do that
19:08:02 <mwhit> GADTs would be of interest
19:08:03 <mwhit> http://en.wikibooks.org/wiki/Haskell/GADT#Understanding_GADTs
19:08:16 <okuno54> Trollinator: dedpendent types would (depending on the flavor idk) let you type haskell input at compile time (if such input could be obtained)
19:08:29 <mwhit> the first section is talking about this exact application
19:08:33 <mwhit> almost verbatim
19:08:38 <haasn> Trollinator: data TypeSafeHaskellProgram where TSHP :: (TypeCorrect prog ~ True) => Sing (prog :: HaskellProgram) -> TypeSafeHaskellProgram
19:09:01 <haasn> That's the naive “proof” of it being possible
19:09:06 <haasn> In practice you'd have something more elaborate
19:09:22 <haasn> But with UndecidableInstances any function can be made into a condition on some constructor
19:09:30 <haasn> And with singletons you can construct and pass around such instances, in theory
19:10:24 <Trollinator> I see.
19:11:17 <okuno54> Trollinator: but, if you want dependent types, it's much easier to use Agda or Idris than Haskell (I expect, I haven't done that stuff)
19:12:03 <Trollinator> It was a purely academic question
19:12:04 <haasn> The thing about the GADT-form I gave is that in practice I know it works very well if you're including all of the data in your source code
19:12:15 <haasn> But I've never really played around with how well it works if you're reading data at *runtime*
19:12:20 <haasn> Precisely because type checking is so static
19:12:47 <haasn> You could probably cook something up. Hmm, I guess this is the part where I figure out how to implement a type checker and try it
19:13:06 * haasn reads up on hindley-milner
19:13:38 <Trollinator> Haskell is way beyond hindley-milner these days.
19:14:03 <haasn> Right, but if it can be done for hindley-milner it could most likely be expanded to system Fc_omega↑ or whatever
19:16:17 <Trollinator> well, getting that working for hindley-milner would already be a feat :-)
19:17:32 <intrados> What exactly does `cabal run Foo` do? I didn't expect it to take so much longer than `dist/build/Foo/Foo`
19:18:02 <okuno54> Trollinator: well, SPJ had a paper that made me understand how to write a type checker, lemme find it
19:18:33 <Trollinator> okuno54: it's not about writing a type checker.
19:18:46 <okuno54> Trollinator: heh, durp
19:19:06 <Trollinator> it's about writing a datatype declaration that ensures that only well-typed programs can be represented.
19:20:23 <Trollinator> I also don't know what “durp” means.
19:20:40 <okuno54> Trollinator: ah, now I see it. that actually sounds really useful
19:21:26 <okuno54> Trollinator: its onomotopoeia[sp?] for the speaker being dumb
19:21:46 <Trollinator> I see.
19:22:57 <Trollinator> Yes, it would be a terrific way to show off Haskell's type system's awesomeness. I doubt it's possible though.
19:23:05 <stupidpioneers> can i overload (+) to add tuples like (1,2) + (1,1)
19:23:19 <HeladoDeBrownie> stupidpioneers, yes.
19:23:28 <mwhit> @djinn (a -> (b,c)) -> [a] -> ([b],[c])
19:23:29 <lambdabot> Error: Undefined type []
19:23:41 <mwhit> drat
19:23:43 <HeladoDeBrownie> stupidpioneers, do you know what a typeclass is?
19:24:12 <okuno54> Trollinator: what I'm thinking is `evalIO :: YourDataType (YourIO YourUnit) -> IO ()`
19:24:30 <mietek> Is there a standard way to clamp a value to a range?
19:24:31 <okuno54> Trollinator: could be interesting for writing plugins or whatnot
19:24:44 <mietek> Something like Data.Ix inRange, but not returning Bool, but a clamped value
19:24:48 <stupidpioneers> HeladoDeBrownie: is that when you do newtype?
19:25:18 <HeladoDeBrownie> stupidpioneers, no, that has nothing to do with it. Try reading the chapter in Learn You A Haskell on typeclasses (and reading up to it couldn't hurt!)
19:25:36 <HeladoDeBrownie> @where lyah
19:25:36 <lambdabot> http://www.learnyouahaskell.com/
19:25:37 <stupidpioneers> ok
19:26:33 <kazagistar> mietek: you should be able to write one fairly easily
19:26:42 <HeladoDeBrownie> stupidpioneers, the short of it: (+) is part of the Num typeclass, which makes it overloadable by defining instances of that typeclass. Go ahead and read up and ask for any clarification you need.
19:26:55 <Trollinator> > :i Num
19:26:57 <lambdabot>  <hint>:1:1: parse error on input ‘:’
19:27:01 <Trollinator> :i Num
19:27:09 <Trollinator> lame :(
19:27:40 <bb010g> class Num a where
19:27:40 <bb010g>   (+) :: a -> a -> a
19:27:40 <bb010g>   (*) :: a -> a -> a
19:27:40 <bb010g>   (-) :: a -> a -> a
19:27:40 <bb010g>   negate :: a -> a
19:27:41 <bb010g>   abs :: a -> a
19:27:41 <bb010g>   signum :: a -> a
19:27:42 <bb010g>   fromInteger :: Integer -> a
19:27:42 <bb010g>   	-- Defined in ‘GHC.Num’
19:27:43 <bb010g> instance Num Integer -- Defined in ‘GHC.Num’
19:27:43 <bb010g> instance Num Int -- Defined in ‘GHC.Num’
19:27:44 <bb010g> instance Num Float -- Defined in ‘GHC.Float’
19:27:44 <bb010g> instance Num Double -- Defined in ‘GHC.Float’
19:28:00 <mwhit> @djinn (a -> b -> c) -> (a,a) -> (b,b) -> (c,c)
19:28:01 <lambdabot> f a (b, _) (c, _) = (a b c, a b c)
19:29:33 <MP2E> heh, silly djinn
19:29:50 <mwhit> it is technically correct
19:29:53 <mwhit> the very best kind of correct
19:29:54 <HeladoDeBrownie> MP2E, the Djinn did grant your wish ;)
19:30:02 <okuno54> yeah, that is not a comfortable function to read as-is
19:30:03 <MP2E> HeladoDeBrownie: mwhit's wish actually :P
19:30:08 <HeladoDeBrownie> Er, yes
19:31:52 <stupidpioneers> HeladoDeBrownie: so something :: a -> a is a typeclass
19:32:04 <mwhit> @pl f (a,b) (c,d) = (f a c, f b d)
19:32:05 <lambdabot> f = fix ((`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .)))
19:32:08 <mwhit> haha
19:32:09 <mwhit> pass
19:32:14 <HeladoDeBrownie> stupidpioneers, no, that's just a function
19:33:15 <HeladoDeBrownie> stupidpioneers, what led you to infer that that's a typeclass? Some part of LYAH's text?
19:33:41 <stupidpioneers> oh that's the type signature
19:33:45 <Trollinator> @djinn (a -> b) -> [a] -> [b]
19:33:46 <lambdabot> Error: Undefined type []
19:34:06 <Trollinator> err… what?
19:34:11 <stupidpioneers> Eq and Num and stuff are typeclasses
19:34:19 <HeladoDeBrownie> stupidpioneers, right, those are both typeclasses
19:34:20 <MP2E> Trollinator: [] is a recursive type
19:34:24 <MP2E> recursive types are not allowed in djinn
19:34:26 <kazagistar> Trollinator: djinn has a very limited vocabulary
19:34:39 <stupidpioneers> so the type i want to overload is (Num a, Num a)
19:34:42 <stupidpioneers> so the type i want to overload is (Num a, Num b)
19:35:27 <MP2E> @djinn (a -> b) -> Maybe a -> Maybe b
19:35:28 <lambdabot> f a b =
19:35:28 <lambdabot>     case b of
19:35:28 <lambdabot>     Nothing -> Nothing
19:35:28 <lambdabot>     Just c -> Just (a c)
19:35:30 <HeladoDeBrownie> stupidpioneers, that's not a type. What you want is to write an instance for Num on the type (a, b)
19:35:36 <MP2E> ^ that simulates a 0 or 1 element list
19:35:42 <kazagistar> stupidpioneers: that is not a type. do you mean (Num a, Num b) => (a, b) ?
19:35:42 <MP2E> I usually use maybe to simulate lists with djinn
19:35:42 <HeladoDeBrownie> stupidpioneers, however you'll want to be more specific than that, because there isn't really a natural instance given just that
19:36:11 <HeladoDeBrownie> stupidpioneers, what kazagistar just said is more likely what you'll write an instance for; given that we know there's an instance of Num for a and b, we can write one for their product as well.
19:36:26 <Trollinator> I don't get why it goes through the trouble to pattern matching. Why not just do f _ _ = Nothing?
19:37:21 <mwhit> ghci can't even check that ridiculous pointfree thing it just gave me
19:37:33 <MP2E> haha
19:37:57 <MP2E> yeah... that looks insane
19:38:09 <mwhit> it's the craziest one i've ever seen
19:38:12 <HeladoDeBrownie> stupidpioneers, so here, let's give this a try. Here's the documentation for Num: http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#t:Num
19:38:17 <Trollinator> @djinn Int -> Int -> Int
19:38:18 <lambdabot> Error: Undefined type Int
19:38:19 <mwhit> especially compared to the simplicity of the input
19:38:41 <HeladoDeBrownie> stupidpioneers, most typeclasses in base will give you a "minimal complete definition", which means the set of things you ought to define in your instance. The rest can be omitted if you like.
19:39:07 <HeladoDeBrownie> stupidpioneers, so, tell me what the head of our instance will look like. Feel free to ask for clarification if you're not sure.
19:39:16 <HeladoDeBrownie> stupidpioneers, in other words, the line that introduces the instance.
19:39:16 <kazagistar> mwhit: your original pointful version is broken, so it gave you a broken pointfree version
19:39:34 <mwhit> oh, so it was, haha
19:39:52 <mwhit> @pl f g (a,b) (c,d) = (g a c, g b d)
19:39:53 <lambdabot> f = (`ap` snd) . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .)) .) . (flip =<< (((.) . flip . (((.) . (,)) .)) .))
19:40:43 <mwhit> well, you tried, lambdabot
19:40:52 <MP2E> lmao
19:40:56 <MP2E> still undecypherable
19:41:07 <mwhit> it's just the same one minus the fix
19:41:18 <Trollinator> you've got to love the “flip flip fst” and “flip flip snd” things.
19:41:28 <TallerGhostWalt> what does @pl do?
19:41:37 <Trollinator> pointless programming
19:41:41 <Trollinator> @where pointfree
19:41:41 <lambdabot> http://haskell.org/haskellwiki/Haskell/Pointfree
19:41:52 <stupidpioneers> HeladoDeBrownie: sorry, i don't really understand, i'll have to read a bit more by myself
19:41:55 <stupidpioneers> thanks
19:42:07 <TallerGhostWalt> oh
19:42:20 <TallerGhostWalt> right... or I could have just looked at that output more closely
19:42:26 <TallerGhostWalt> but it was blinding, like the sun
19:42:41 <HeladoDeBrownie> stupidpioneers, sounds good. Not trying to push you, just sounded like you wanted to proceed. My mistake.
19:43:13 <stupidpioneers> also is there a way to delete a variable in ghci?
19:43:29 <julianb> stupidpioneers, override it
19:43:40 <stupidpioneers> ok
19:49:50 <haasn> First steps towards HM http://lpaste.net/108814
19:50:11 <vanila> haasn, where is unification?
19:50:11 <phaskell> No symbol 'unification' found anywhere.
19:50:38 <haasn> Nowhere right now
19:50:40 <vanila> so, you are cunningly reflecting haskells own unification into your DSL
19:50:55 <vanila> to get a type checking for your language with zero effort
19:51:24 <vanila>   App :: Lam env (a :→ b) -> Lam env a -> Lam env b
19:51:27 <vanila> you can just do
19:51:29 <vanila>   App :: Lam env (a -> b) -> Lam env a -> Lam env b
19:51:33 <vanila> without "datakinds"
19:51:55 <stupidpioneers> HeladoDeBrownie: is instance the same as instance of a class?
19:51:57 <vanila> and for (t ': env) it could be (t, env)
19:52:11 <stupidpioneers> or typeclass in this case
19:55:49 <HeladoDeBrownie> stupidpioneers, yes, in Haskell, "instance" is short for "type class instance".
19:56:19 <HeladoDeBrownie> stupidpioneers, likewise, "class" is short for "type class".
19:58:27 <SkippyDeluxe> Okay... who else here has seen this cabal problem:
19:58:46 <SkippyDeluxe> Can't install any packages. Everything fails with this msg:
19:58:49 <SkippyDeluxe> cabal: You need to re-run the 'configure' command. The version of Cabal being used has changed (was Cabal-1.18.1.3, now Cabal-1.20.0.1). Additionally the compiler is different (was ghc-7.8, now ghc-7.6) which is probably the cause
19:59:01 <HeladoDeBrownie> SkippyDeluxe, did you try running `cabal configure`?
19:59:10 <SkippyDeluxe> as far as I know 7.6 is nowhere on my machine
19:59:22 <SkippyDeluxe> Yeah, but I don't have a cabal file to run it on...?
19:59:27 <HeladoDeBrownie> Hmm, odd
19:59:28 <SkippyDeluxe> I'm installing from hackage
19:59:51 <SkippyDeluxe> Actually, correction: the one package that I can install is a new version of Cabal. But that doesn't help other packages
19:59:58 <tabemann> blah I need to get back to transforming my code for comparing recursive data structures into code for comparing recursive *Scheme* data structures
20:00:29 <SkippyDeluxe> I swear, 95% of my Haskell time is wrestling with build problems like this...
20:01:04 <tabemann> I really need to get back to work working in Haskell, actually
20:02:42 <HeladoDeBrownie> SkippyDeluxe, well, what does `ghc -V` say?
20:02:53 <SkippyDeluxe> 7.8.3
20:03:24 <HeladoDeBrownie> I don't know if this should matter, but are you installing it user-globally or in a sandbox or something else?
20:03:36 <SkippyDeluxe> global install, no sandbox
20:03:58 <HeladoDeBrownie> And there doesn't happen to be a cabal package file in the PWD?
20:04:09 <HeladoDeBrownie> I'm just guessing at this point, I've probably got almost no idea
20:04:19 <SkippyDeluxe> Nope.
20:04:30 <SkippyDeluxe> No problem, any ideas are welcome... I've been banging my head on this for days.
20:08:25 <SkippyDeluxe> I wish I could remember the sequence of events that lead to this... at one point I upgraded my "ghc.app" to 7.8.3, and then nothing seemed to work. But going back to the old version doesn't help either.
20:08:53 <dsturnbull> mdfind -name ghc ?
20:10:00 <codehero> okay. i'm stuck here
20:10:15 <codehero> how does this work?
20:10:18 <codehero> rightTriangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2]
20:10:48 <codehero> i'm reading learnyouahaskell and didn't have any problems until now
20:11:19 <SkippyDeluxe> dsturnbull, doesn't turn up any other ghcs
20:11:19 <dsturnbull> i think you can desugar that to three maps and a filter.. which if you try implementing the algorithm yourself you'll probably end up with'
20:11:44 <vanila> codehero, it tries c = 1, then 2 then 3 then 4.... and for each of those it tries b = 1,2,3, up to c, ... and it only gives results when a^2 + b^2 == c^2 is true
20:11:53 <dsturnbull> SkippyDeluxe: i have ~/Library/Haskell but also /Library/Frameworks/GHC.framework.. in my case they're the same version, but i thought you might not
20:11:56 <dsturnbull> both mine are 7.6.3
20:12:01 <vanila> codehero, here's a simpler example
20:12:05 <dsturnbull> anyway probably just nuke both
20:12:14 <vanila> > [ x | x <- [1..5], x^2 = 9 ]
20:12:15 <lambdabot>  <hint>:1:24: parse error on input ‘=’
20:12:18 <vanila> > [ x | x <- [1..5], x*x == 9 ]
20:12:20 <lambdabot>  [3]
20:12:39 <vanila> it tries x=1,2,3,4,5 and only gives a result when x*x == 9 is true
20:12:48 <codehero> yeah
20:13:14 <vanila> > [ (x,y) | x <- [1..5], y <- [1..5], x+y == 9 ]
20:13:16 <lambdabot>  [(4,5),(5,4)]
20:13:27 <dsturnbull> the magic about the comprehension solution is how b and c grow, but that's because i'm pretty sure we're wanting to look at this imperatively
20:13:31 <codehero> okay so b <- [1..c] takes each element from c if a^2+b^2=c^2 ?
20:13:48 <mwhit> no it picks an element in the range 1 to c
20:13:51 <vanila> b <- [1..c] just says try b=1, then b=2, then b=3, up  to b=c
20:14:10 <vanila> the a^2 + b^2 == c^2 bit is what stops it from returning any results unless that holds
20:14:18 <codehero> ah okay
20:14:30 <vanila> also another way to write this is like so
20:14:37 <dsturnbull> hang on, c is changing as well
20:14:41 <codehero> and c is just each element of that list?
20:14:42 <vanila> > do c <- [1..10], b <- [1..c], a <- [1..b], guard (a^2 + b^2 == c^2) ; return (a,b,c)
20:14:43 <lambdabot>  <hint>:1:16: parse error on input ‘,’
20:14:56 <codehero> sort of like a foreach loop looping through c?
20:15:00 <vanila> > do c <- [1..10] ; b <- [1..c] ; a <- [1..b] ; guard (a^2 + b^2 == c^2) ; return (a,b,c)
20:15:02 <lambdabot>  [(3,4,5),(6,8,10)]
20:16:58 <HeladoDeBrownie> codehero, you can imagine lists as an embodiment of iteration, in which case [1..c] would be an iteration from 1 to c
20:17:18 <codehero> okay
20:17:21 <codehero> that makes sense
20:17:22 <HeladoDeBrownie> codehero, so yeah, what you said is right in a metaphorical sense
20:18:32 <codehero> now that i think about it
20:18:42 <codehero> it's pretty much like the variable in a mathematical function
20:19:06 <SkippyDeluxe_> Ugh, crashed. Hopefully nobody had a brilliant insight while I was gone
20:19:07 <HeladoDeBrownie> codehero, sure, when you draw a graph you sample a function at various points, which is itself a sort of iteration
20:20:29 <HeladoDeBrownie> codehero, certain functions (but not all) can even be thought of as a list of pairs
20:20:47 <HeladoDeBrownie> E.g., the successor function on naturals looks something like: [(0, 1), (1, 2), (2, 3), …]
20:24:59 <oisin878> I'm having a bit of trouble creating a simple-ish UDP client and server in Haskell. I keep getting the error: user error (accept: can't perform accept on socket ((AF_INET,Datagram,0)) in status Bound)  This happens because of line 63 in my code: http://lpaste.net/108815 It appears that the server is unable to accept a joining client for whatever reason. Most of my example code comes from Real World Haskell, Chapter 27, so I don't rea
20:25:00 <oisin878> rong
20:25:24 <HeladoDeBrownie> oisin878, you cut off at "so I don't rea"
20:25:36 <oisin878> Ah, sorry. I don'
20:25:42 <oisin878> t really understand what's going wrong.
20:26:04 <vanila> oisin878, what port are you using?
20:26:15 <oisin878> vanila: Random ones, but anything between 10k - 15k
20:29:04 <haasn> vanila: Hmm, I guess once you try to implement any of the things that can't simply be cheated away it all devolves to “implement the type checking algorithm in the type system using a painstaking encoding of functions as TFs” either way
20:29:17 <haasn> Oh no
20:44:35 <sclv> oh give me a home
20:44:41 <sclv> ?where theBuffaloRoam
20:44:42 <lambdabot> And the skies are not cloudy all day.
21:02:53 <dmj`> > do do do do do do do 1
21:02:55 <lambdabot>  1
21:03:26 * gfixler is wondering if logic programming can make sense of that 7 buffalo sentence
21:04:04 <mwhit> 8 buffalo!
21:04:10 <dmj`> 9 buffalo!
21:04:21 <bb010g> @undo do do do do do do do do do 1
21:04:21 <lambdabot> 1
21:04:27 <dmj`> > forever $ print "buffalo"
21:04:29 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
21:04:29 <lambdabot>    arising from a use of ‘M51502076666671989378812.show_M51502076666671989378...
21:04:29 <lambdabot>  The type variable ‘b0’ is ambiguous
21:04:29 <lambdabot>  Note: there are several potential instances:
21:04:29 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
21:04:43 <bb010g> @do do do do do do do do do do "buffalo"
21:04:44 <lambdabot> do { do { do { do { do { do { do { do { do { "buffalo"}}}}}}}}}
21:05:21 <dmj`> > replicate 10 "buffalo"
21:05:22 <lambdabot>  ["buffalo","buffalo","buffalo","buffalo","buffalo","buffalo","buffalo","buff...
21:05:39 <dmj`> @do (@undo do do do 4)
21:05:39 <lambdabot> <unknown>.hs: 1: 2:Parse error: @
21:06:06 <haasn> @@ @do @undo do do do 4
21:06:06 <lambdabot>  4
21:06:16 <dmj`> haasn: nice!
21:07:15 * dmj` thinks haasn learned him a lambdabot
21:08:03 <toblerone> what does the @ symbol indicate?
21:08:32 <joelteon> @@ and @. are both command composition
21:08:32 <lambdabot> Plugin `compose' failed with: Unknown command: "are"
21:08:46 <haasn> lines starting with @ (along with ? and the two characters “> ”) are what lambdabot responds to
21:08:48 <dmj`> @unmtl StateT s IO a
21:08:49 <lambdabot> s -> IO (a, s)
21:08:49 <joelteon> @ is a cool name for the composition operator, but unfortunately it's taken already
21:09:02 <haasn> Oh, perhaps I misunderstood what toblerone was asking
21:09:05 <haasn> Your name is making me hungry
21:09:13 <joelteon> maybe i did
21:09:15 <TallerGhostWalt> lol
21:09:16 <joelteon> either way, we both answered
21:09:19 <bb010g> @pl \o h g i v e m a w r t b u f l -> b u f f a l o
21:09:20 <lambdabot> const . const . const . const . const . const . ((const . const . const) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . (flip .) . flip flip id . (ap .)))
21:09:36 <toblerone> haasn: no you understood my question
21:09:51 <bb010g> haasn: Don't forget :t
21:09:58 <haasn> Oh, yes, and :k
21:10:36 <dmj`> @typ \b u f a l o -> b $ u $ f $ f $ a $ l o
21:10:37 <lambdabot> (s -> t) -> (s1 -> s) -> (s1 -> s1) -> (s2 -> s1) -> (t1 -> s2) -> t1 -> t
21:11:34 <dmj`> @typ \b u f a l o -> map ($) [b,u,f,f,a,l,o]
21:11:36 <lambdabot> (a -> b) -> (a -> b) -> (a -> b) -> (a -> b) -> (a -> b) -> (a -> b) -> [a -> b]
21:16:59 <bb010g> :k Fix
21:17:00 <lambdabot> Not in scope: type constructor or class ‘Fix’
21:17:34 <bb010g> @let newtype Fix f = In { out :: f (Fix f) }
21:17:35 <lambdabot>  .L.hs:150:30:
21:17:36 <lambdabot>      Ambiguous occurrence ‘out’
21:17:36 <lambdabot>      It could refer to either ‘L.out’, defined at .L.hs:147:20
21:17:36 <lambdabot>                            or ‘Lambdabot.Plugin.Haskell.Eval.Trusted.out’,
21:17:36 <lambdabot>                               imported from ‘Lambdabot.Plugin.Haskell.Eval.Tr...
21:17:46 <bb010g> @let newtype Fix f = Fix { unfix :: f (Fix f) }
21:17:48 <lambdabot>  Defined.
21:19:39 <bb010g> @let data Buffalo' a b = Buffalo a a b | Plains a | Roam b | Home
21:19:41 <lambdabot>  Defined.
21:20:06 <bb010g> @let type Buffalo a = Fix (Buffalo' a)
21:20:07 <lambdabot>  Defined.
21:21:08 <mwhit> what are we building here
21:21:24 <bb010g> I don't quite know myself
21:21:32 <L8D> Is there a channel on Freenode for getting employed?
21:21:34 <L8D> lol
21:22:06 <tabemann> I'm not sure, but it's not here
21:22:38 <mwhit> :k Buffalo ()
21:22:39 <lambdabot> *
21:23:08 * tabemann just got a job, albeit not the Scala job that he was trying to get
21:23:11 <mwhit> :t Buffalo (Buffalo () () ())
21:23:12 <lambdabot> Buffalo' () () -> b -> Buffalo' (Buffalo' () ()) b
21:23:25 <tabemann> Scala isn't Haskell, but at least it's better than Java
21:23:30 <mwhit> :t Buffalo (Buffalo () () ()) () ()
21:23:31 <lambdabot>     Couldn't match expected type ‘Buffalo' () ()’ with actual type ‘()’
21:23:31 <lambdabot>     In the second argument of ‘Buffalo’, namely ‘()’
21:23:31 <lambdabot>     In the expression: Buffalo (Buffalo () () ()) () ()
21:23:43 <mwhit> :t Buffalo (Buffalo () () ()) (Buffalo () () ()) ()
21:23:44 <lambdabot> Buffalo' (Buffalo' () ()) ()
21:25:32 <bb010g> :t Buffalo "oh" "give" . Buffalo "me" "a" . Buffalo "home" "where" . Roam
21:25:34 <lambdabot> a -> Buffalo' [Char] (Buffalo' [Char] (Buffalo' [Char] (Buffalo' a1 a)))
21:26:01 <benzrf> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo
21:26:55 <danclien> tabemann: Using scalaz at least?
21:27:01 <bb010g> Do we have -XStandaloneDeriving for lambdabot?
21:27:19 <tabemann> danclien: well yes, these people were trying to actually use Scala as a functional language
21:28:47 <tabemann> instead I got a job programming in the stupid language known as Groovy
21:29:10 <danclien> tabemann: :( a.k.a. Java without types.
21:29:10 <tabemann> which is basically Java minus type-safety
21:29:49 <tabemann> even the guy who was hiring me was complaining about how his predecessor put in a bunch of code without types
21:30:48 <tabemann> at least the guy seemed personally interested in functional programming - he asked me at the final interview what a monad was
21:32:13 <tabemann> I don't think I gave a satisfactory answer, by my standards, but one that probably was okay for the sake of the average non-Haskeller
21:32:42 <tabemann> considering I got the job
21:32:59 <bb010g> tabemann: "A monad is just a monoid over the category of endofunctors."
21:33:04 <tabemann> hahahaha
21:33:13 <danclien> tabemann: Congrats on the job. Sorry it wasn't the one you were aiming for though.
21:33:40 <danclien> The nice thing about the JVM though is that it makes it easier to sneak in other JVM-languages.
21:33:48 <haasn> quote lax.functor
21:33:52 <haasn> @quote lax.functor
21:33:53 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
21:34:04 <tabemann> the job is actually more convenient for me, though, as the functional programming job was over in Madison, whereas this job is closer to home in West Bend (I'm in Wauwatosa, right outside of Milwaukee)
21:34:12 <bb010g> danclien: Clojure!
21:34:31 <danclien> bb010g: I would still pick Scala over Clojure, personally. :)
21:34:49 <tabemann> my hiring manager told me at the interview that he was told when he was brought on that he could program in any language he wanted as long as it was a JVM language
21:35:15 <tabemann> I asked him it *I* could program in any language *I* wanted as long as it was a JVM language, and he basically said yes, for new projects at least
21:35:23 <bb010g> If only there were a LLVM for JVM, then you could use Haskell
21:35:41 <danclien> tabemann: It's a step in the right direction at least.
21:35:51 <tabemann> *if
21:37:27 <tabemann> bb010g: I'm not sure if that'd count, as they basically said that whatever I worked in had to interoperate with other JVM code
21:38:05 <tabemann> whereas if there were LLVM for the JVM, that wouldn't allow the ability for Haskell to actually interoperate with Java code
21:41:41 <schell> does anyone here use yi as their goto haskell editor?
21:42:03 <benzrf> schell: goto considered hramful
21:42:12 <schell> benzrf: ;)
21:42:21 <Zekka> schell: I used it briefly but I stopped
21:43:05 <schell> are there any good walkthroughs or tutorials?
21:43:13 <Zekka> To do what?
21:43:31 <Zekka> Its hotkeys are probably pretty much the same as what you're used to in vim or emacs
21:43:31 <schell> i can’t seem to find anything on the editor in general besides the haskell wiki article
21:43:43 <Zekka> Yeah, it's not very popular at all
21:44:42 <Zekka> schell: You can install it with cabal install, from there it will ask you whether you like emacs or vi
21:45:06 <Zekka> AFAIK the scripting is not well-documented externally, but it's not too hard to learn to use
21:45:07 <bb010g> schell: I've been trying it recently.
21:45:23 <bb010g> Check out the configs in the GitHub repo.
21:45:42 <haasn> schell: I think Fuuzetsu does iirc
21:45:56 <Fuuzetsu> what's up
21:46:00 <haasn> yi's up
21:46:00 <schell> is it scriptable enough to allow for syntax highlighting, hlint, etc?
21:46:03 <bb010g> tabemann: One could probably develop a LLVM FFI with the JVM...
21:46:09 <Fuuzetsu> no, I don't use Yi as my editor at the moment
21:46:17 <Fuuzetsu> it has syntax highlighting
21:46:20 <Zekka> schell: Yeah, but plugins for those don't already exist
21:46:23 <Zekka> er, hlint that is
21:46:35 <ab9rf> bb010g: probablyu wouldn't be that hard.
21:46:50 <Fuuzetsu> schell: I would not recommend it as a more featured than emacs/vim/whateveryou'reusing just now
21:46:53 <Fuuzetsu> hopefully in the future
21:46:57 <tabemann> bb010g: tis true
21:47:18 <schell> Fuuzetsu: okay - is there a better resource for reading about it than the source?
21:47:19 <Fuuzetsu> we'd love some hands to hack on it though if you want to dive into it that way
21:47:30 <ab9rf> bb010g: from what i've seen the most complex part of the haskell FFI now has to do with the garbage collector, and on the JVM that's much simpler because the JVM is already providing one
21:47:36 <bb010g> I've found a JVM on LLVM, but not the inverse yet.
21:47:40 <Fuuzetsu> schell: there are a few links on the bottom of the README but otherwise there is not much
21:47:50 <Fuuzetsu> read source and ask questions
21:47:51 <schell> okay, i’ll start there
21:47:57 <ab9rf> bb010g: LLVM has code generators for the JVM, i'm fairly certain
21:48:00 <schell> Fuuzetsu: are you one of the contributors?
21:48:34 <Fuuzetsu> yes although I haven't touched it recently… well, that's untrue, I did dabble in it a little today; I think I'll have some time for it soon though
21:48:53 <Fuuzetsu> the issue tracker is quite up to date
21:49:07 <schell> cool, thanks
21:49:18 <Fuuzetsu> my GSOC proposal also lists tickets which have a fair timeline to them, i.e. not 2 year projects but non-trivial either
21:49:19 <Fuuzetsu> no problem
21:49:46 <Fuuzetsu> there's #yi by the way although not many of us there so it may take a while for people to reply
21:51:46 <schell> to be a part of GSOC you typically have to be a student, correct?
21:52:05 <Fuuzetsu> it is a requirement to be enrolled at certain date to be able to apply
21:52:51 <schell> ah, ok - i probably missed my chance by a half decade
21:52:56 <schell> or more
21:52:58 <schell> :)
21:53:13 <L8D> So do any of you have jobs in haskell?
21:53:33 <danclien> L8D: I'm slowly convincing my team to switch.
21:54:09 <Fuuzetsu> many people who could answer that ‘yes’ are not here ;)
21:54:26 <schell> danclien: what’s your strategy? what are you using now?
21:54:31 * tabemann is lucky to have found just a Java job... it seems much of the software development jobs here in Milwaukee are .NET jobs...
21:54:45 * Fuuzetsu is unemployed
21:54:45 <dibblego> L8D: I have not held a job where I do not enforce "right tool for the job" for over 10 years, so yes, lots of haskell
21:54:47 <Fuuzetsu> sucks
21:55:14 <danclien> schell: .NET > Scala+scalaz > Haskell. I'm the team lead though, and I'm lucky enough to have buy in from management to invest in better technology.
21:55:15 * tabemann is strictly speaking still unemployed, since he hasn't started work yet
21:55:47 <tac_> How much heap space does GHC allocate by default for a process?
21:55:48 <Fuuzetsu> well, 7am, gonna call it a night (day?), laters
21:56:00 <tabemann> g'night
21:56:13 <Fuuzetsu> tac_: it's in manual somewhere IIRC, RTS flags section I think
21:56:27 <schell> Fuuzetsu: night
22:09:26 <gfixler> L8D: I'd be curious who has the least-related-to-Haskell job.
22:09:48 <oisin625> Sorry, have to ask this one more time because I'm pretty stuck
22:09:51 <oisin625> I'm having a bit of trouble creating a simple-ish UDP client and server in Haskell. I keep getting the error: user error (accept: can't perform accept on socket ((AF_INET,Datagram,0)) in status Bound)  This happens because of line 63 in my code: http://lpaste.net/108815 It appears that the server is unable to accept a joining client for whatever reason.
22:10:58 <pfn> udp doesnt accept...
22:11:48 <oisin625> pfn: That's exactly what I want to know, then :D How do I create a socket from the client to the server if I can't accept?
22:12:35 <pfn> You just read the datagram when it arrives
22:12:38 <tabemann> well Datagram sockets don't accept
22:12:41 <tabemann> yeah
22:13:42 <bb010g> ab9rf: Asking on #llvm on irc.oftc.net, there is not currently a JVM backend for LLVM.
22:21:17 <bb010g> The guys there recommended building a IR interpreter in Java first. In any case, it wouldn't be too hard to make a working backend, but optimization would be difficult (as it always is).
22:21:21 <abrao95159> any compsci uni ppl here?
22:39:33 <schell> in general can you replace most cases of liftM, liftM2, liftM3, etc, with do notation?
22:39:44 <schell> (or all cases?)
22:39:57 <tac_> What is Control.Monad.Primitive for?
22:40:05 <tac_> schell: in all cases
22:40:16 <tac_> @src liftM
22:40:16 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
22:40:28 <schell> haha!
22:40:32 <schell> tac_: thanks
22:40:36 <tac_> see? The liftM's are just wrapping up do <-'s + return for you
22:40:39 <tac_> @src liftM2
22:40:39 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:40:39 <tac_> @src liftM3
22:40:40 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
22:40:51 <schell> yup
22:40:58 <tac_> In fact, what you really wish you could do is go the other way: go from do to liftMn
22:41:23 <schell> i guess it’s just a question of style as to which you use, correct?
22:41:32 <tac_> Yeah
22:42:18 <schell> thanks :)
22:42:52 <tac_> In fact, I think liftM is just another way to say fmap
22:43:00 <MP2E> it is
22:43:03 <tac_> yeah
22:43:07 <MP2E> and liftM2 is just another way of saying liftA2
22:43:18 <MP2E> well with the Applicative Monad proposal
22:43:30 <tac_> and liftM2 f x y and liftM3 f x y z are aliases for f <$> x <*> y <*> z, etc
22:54:02 <splintax> anyone know of any good examples of simple XML generation with HXT?
22:54:11 <splintax> all the tutorials seem to be about parsing it, which i don't need to do at all
22:57:50 <Enigmagic> splintax: have you looked at xml-conduit? http://hackage.haskell.org/package/xml-conduit-1.2.1/docs/Text-XML.html#g:7
22:59:23 <splintax> that's actually what i'm using right now and i'm beginning to wonder if it's the right tool for the job
22:59:35 <splintax> wait, hold on. i'm not using xml-conduit, i'm using xmlgen
22:59:52 <splintax> i've tried many different xml libraries and that was the first one i successfully got started with
23:00:21 <splintax> probably because it comes with a minimal example in the documentation :P
23:02:55 <splintax> ok i've just found the bit about xml-hamlet in the yesod book, that approach looks a lot nicer than what i have
23:13:49 <trap_exit> alright
23:13:52 <trap_exit> now that I get monads
23:13:54 <trap_exit> and monad transformers
23:13:56 <trap_exit> i need to learn arrows
23:14:12 <trap_exit> http://www.haskell.org/pipermail/haskell-cafe/2014-March/113253.html is the motivation
23:14:13 <trap_exit> i am trying ot read about haskell sql dsls
23:14:17 <trap_exit> and it's like BAM, arrows
23:14:20 <trap_exit> and I'm like wtf, I need to learn arrows
23:14:23 <trap_exit> jle`: where are you?
23:15:31 <trap_exit> anyone home?
23:17:55 <Enigmagic> it's late on a monday
23:18:51 <Enigmagic> few more hours and the euro contigent will hop on
23:19:11 <glguy> Arrows aren't buying you anything there, but it might be fun to look at them anyway
23:19:51 <trap_exit_> alright; I think freenode kicked me due to my sheer awesomeness overload
23:19:56 <zRecursive> :t (***)
23:19:57 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
23:19:57 <trap_exit_> I'm looking at http://www.haskell.org/arrows/ but it does not make much sense
23:20:26 <shachaf> There's a popular progression that goes "you must learn monads, then monad transformers, then arrows".
23:20:35 <shachaf> (Whatever "learn monads" means, I still haven't figured it out.)
23:20:42 <shachaf> It's pretty much nonsense.
23:21:02 <trap_exit_> shachaf: "learn monads" means (1) ignore all monad tutorials, (2) read the monad types, (3) enlightenment
23:21:33 <shachaf> You don't need to "learn arrows", and if you did it wouldn't be right after "learning monads" and probably wouldn't even depend on it.
23:21:56 <dibblego> shachaf: where have you seen this progression?
23:22:18 <trap_exit_> as in, you already know what tarrows are intuitively, you just need to put the types on them
23:22:25 <shachaf> Mostly in here, but who knows how it comes up.
23:22:35 <dibblego> sounds weird
23:22:36 <shachaf> For the most part Arrow just doesn't matter very much.
23:22:38 <haasn> Arrows: http://lpaste.net/94914
23:23:01 <haasn> This is still my favorite explanation of them
23:23:30 <haasn> For monads, LYAH's chapter worked for me so I see no reason to change that. YMMV. For monad transformers, I used the typeclassopedia
23:23:39 <haasn> Hope that provides pointers to.. whatever this is about, I don't actually know
23:26:41 <benzrf> l8r
23:26:56 <benzrf> bye
23:27:47 <trap_exit> haasn: that looks like an extremelely well written lpaste
23:27:48 <trap_exit> thanks!
23:31:02 <shachaf> I don't think I like several parts of LYAH very much. There's still room in the world for a good up-to-date Haskell introduction (and even more so for a freely-available one?).
23:32:40 <haasn> Looking at LYAH from my current perspective, I feel like it's spreading a lot of bad analogies and outdated information. Looking back at my experience going through it, though, I don't think I was hindered by wrong mental images or other bad impressions moving forwards. So I'm sort of divided between whether or not it's actually a bad resource (eg. for monads)
23:32:55 <haasn> Because it certainly seems to have helped
23:34:41 <drbean> The bad analogies and outdated information weren't hindering you with wrong mental images and other bad impressions?
23:34:57 <shachaf> A determined student can learn even with resources that aren't ideal.
23:35:56 <splintax> hmm, how do i deal with mixing and matching Data.Text and Data.Text.Lazy
23:36:36 <shachaf> You convert back and forth after getting a good understanding of the difference.
23:36:43 <haasn> splintax: Do you know about the “qualifying” keyword?
23:36:46 <haasn> qualified*
23:36:56 <shachaf> Oh, if you mean imports, yes, you qualify.
23:37:04 <jle`> trap_exit: on vacation, actually
23:37:13 <shachaf> (But you probably want to do that anyway, even if you only use one or the other.)
23:37:20 <trap_exit> jle`: alright, I'll bother you later :-)
23:37:26 <splintax> haasn: yep, but i'm confused as to whether i should be explicitly converting them, or making my functions polymorphic, or what
23:38:49 <haasn> Polymorphic functions are an answer to code repetition. If you find yourself reinventing the same functions twice, once for lazy and once for strict, that might be a good time to abstract
23:38:57 <haasn> (Or think about whether you really need one lazy and one strict version)
23:39:28 <trap_exit> what? how does this makes sense
23:39:33 <trap_exit> in a language which hides lazy/strict from yhou?
23:39:45 <haasn> The thing about Strict/Lazy Text is that conversion is “easy”​ because lazy Texts are just like lists of strict Texts.
23:40:20 <trap_exit> oh, ds that are explicity lazy / explicity strict
23:40:31 <trap_exit> I actually liie this distinction
23:40:37 <trap_exit> to be able to look at a type, and know whether it's strict / lazy
23:40:40 <trap_exit> instead of thinkinga bout wnhf
23:41:41 <haasn> trap_exit: It's not *just* a distinction between being strict and being lazy - both are strict to a degree; but “lazy” Text is divided up into a (lazy) list of (strict) chunks. It's good for streaming I/O for example, since you only need to keep one “chunk” at a time in memory
23:42:21 <trap_exit> hmm
23:42:23 <trap_exit> my understanding
23:42:34 <trap_exit> correct me if I'm wrong is that with LazyText, all ops are O(1) until you call toStrict
23:42:42 <trap_exit> then you pay the panlty once, dependent on the output string's length
23:43:05 <trap_exit> so I know for a fact that all computation is "delyaed' until I call toStrict
23:44:07 <haasn> There are other ways to force a lazy text then toStrict. For example I/O.
23:45:05 <shachaf> whoa, i forgot how much i love monoids for a little bit there
23:45:11 <splintax> yeah, it looks like for me polymorphism was not necessary, i just had to change some types in another file
23:45:44 <shachaf> You can make a traversal for lazy Text which reflects the list-of-lists structure in the monoid append tree.
23:46:00 <glguy> Sounds easy
23:46:13 <shachaf> Naturally.
23:46:26 <shachaf> Monoids are the easy version of categories.
23:46:31 <haasn> The best way to handle Lazy/Strict Text is to think in advance about which type you want where, rather than reacting to whatever other APIs expose - but if you find yourself reacting to other APIs a lot, maybe that's a sign that either your line of thinking or the library's line of thinking is flawed
23:47:38 <splintax> i'm still getting a bit confused by ghc errors; it seems like the error line number often points me inside a function that is correctly-typed, and it turns out the problem is that i forgot to change the type of something going into my function
23:47:59 <splintax> i guess there's no way for ghc to really know which type is right and which is wrong, just that they're inconsistent
23:48:06 <shachaf> Do you write type signatures for your functions?
23:48:07 <shachaf> It helps.
23:49:23 <latk> I'm a bit confused about manually writing aeson ToJSON / FromJSON instances. I have a record type that I would like to convert, and one of the fields is a newtype. Is there some way to remove the extra nesting of the sum type? e.g. { date : { date : 'thedate' } } would become { date : 'thedate' }
23:49:36 <latk> sum type = new type
23:50:52 <haasn> If it's a newtype of something that has a *JSON instance then maybe you can use GeneralizedNewtypeDeriving to copy over the “inner” behavior
23:51:37 <latk> haasn: I've not heard of that before - is it similar to derivegeneric?
23:52:39 <haasn> I don't think I'd call them similar. GeneralizedNewtypeDeriving allows you to “copy” instances of the underlying type when writing a newtype - like newtype Foo a = Foo { bar :: Bar a } deriving (Functor, Applicative, Monad)
23:53:04 <latk> Ah, okay.
23:53:11 <haasn> This will create an instance Monad Foo that works exactly like an existing instance Monad Bar except that all of the things of type “Foo a” are coerced to “Bar a”​ (and back) to make the types work
23:53:29 <latk> Okay, that sounds promising.
23:53:35 <haasn> I hope you're using GHC 7.8
23:53:58 <splintax> shachaf: yeah, i always write signatures. in fact, often my errors only pop up because there is an explicit type signature
23:54:27 <latk> haasn: Ah, I'm not ;s
23:54:35 <splintax> maybe i'm just relying too much on the type checker, and as i get more experience this will happen less :)
23:54:38 <latk> I tried to switch and it broke a load of stuff with snap.
23:54:45 <latk> This was quite a while ago, though.
23:55:15 <latk> haasn: Would it be possible to manually do something like this, though? It seems like it should be..
23:55:24 <haasn> That's not a big deal, but GHC 7.8 makes GeneralizedNewtypeDeriving “safe” - not that it makes a difference here
23:55:52 <haasn> (Unless you're using -XSafe, of course)
23:56:01 <haasn> latk: But for educational value; yes, you can do this yourself
23:56:08 <latk> I've not come across -XSafe
23:56:32 <haasn> instance ToJSON (Foo a) where toJSON (Foo a) = toJSON a
23:56:44 <shachaf> You can always do what GeneralizedNewtypeDeriving does manually, except in contrived cases when you can't (because it's evil).
23:57:05 <haasn> instance FromJSON (Foo a) where fromJSON v = fmap Foo (fromJSON v)
23:57:23 <glguy> And sometimes you can do it when GND can't
23:57:52 <glguy> When GND works overlaps some with when it's valid
23:57:56 <latk> haasn: Ok, cool.
23:58:35 <latk> Is there some overview of useful extensions, and what they do?
23:58:37 <shachaf> glguy: Yes, it's a superset of a subset.
23:58:43 <latk> I pretty much only understand overloadedstrings :p
23:58:50 <shachaf> But the fact that you can write code that GHC can't autogenerate isn't very interesting. :-)
23:59:39 <haasn> I think you can even look at GHC's auto-generated code. Not that it would probably be very interesting here
