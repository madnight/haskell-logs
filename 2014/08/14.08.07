00:03:56 * hackagebot attoparsec 0.12.1.1 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.12.1.1 (BryanOSullivan)
00:03:56 * hackagebot snaplet-haxl 0.0.0.2 - Snaplet for Facebook's Haxl  http://hackage.haskell.org/package/snaplet-haxl-0.0.0.2 (biscarch)
00:08:48 * hackagebot attoparsec 0.12.1.1 - Fast combinator parsing for bytestrings and text  http://hackage.haskell.org/package/attoparsec-0.12.1.1 (BryanOSullivan)
00:08:48 * hackagebot snaplet-haxl 0.0.0.2 - Snaplet for Facebook's Haxl  http://hackage.haskell.org/package/snaplet-haxl-0.0.0.2 (biscarch)
00:28:06 <orion> hm
00:28:24 <orion> I guess there's no good way to reject a TCP connection without accepting it first.
00:29:12 <orion> Seems to be a limitation of TCP itself, not haskell.
00:30:45 <dfeuer> orion, you can probably discard the connection request at some lower level in the stack, right?
00:31:07 <orion> dfeuer: You mean on a kernel level?
00:31:19 <dfeuer> I don't know what I mean!
00:31:22 <dfeuer> Could be.
00:32:52 <swgillespie> orion: what are you trying to do?
00:33:37 <orion> swgillespie: I was trying to reject incoming TCP connections before they're accepted (IP blocklist), but that's impossible.
00:33:55 <orion> Because the kernel's TCP stack negotiates the connection way before it ever gets to my application.
00:34:00 <swgillespie> yeah :/
00:35:16 <swgillespie> you could probably use iptables for that if you're on linux
00:56:51 <danilo2> hello! Is it possible to convert somehow (Proxy GHC.Generics.D1Maybe) into (Proxy Maybe)?
00:58:16 <c_wraith> danilo2: there's only one value of each of those types.  You don't even need to convert.
01:00:28 <danilo2_> c_wraith: I'm sorry - I've lost internet connection. Hmm, I;ve got some instances that mention (Proxy Maybe) - and I would like to keep it this way. Basically I want to have a function "extractBase" which will work like "extractBase (A 1 2 3) -> Proxy A", where A could be of any kind
01:01:24 <c_wraith> danilo2: if A is of any kind, such a function doesn't seem well-typed.
01:01:52 <danilo2_> c_wraith: hmm, why not? we can use (Proxy Maybe) and (Proxy Either). Proxy has kind of k -> *
01:02:33 <machrider> what's the (.|.) function called in english?
01:02:42 <c_wraith> machrider: bitwise or?
01:02:58 <c_wraith> danilo2_: crap, getting called away
01:03:18 <danilo2_> c_wraith: of course! Thank you! If I migh, I would ask you later about it :)
01:03:23 <danilo2_> c_wraith: thank you! :)
01:03:51 <machrider> c_wraith: thanks
01:04:45 <Iceland_jack> machrider: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Bits.html here is the documentation if you want
01:08:04 <machrider> Iceland_jack: thanks, found that after :) google is not so big on searching for random strings of punctuation (but hoogle found it; i just need to remember to use it in the future)
01:14:56 <danilo2> Hello! Could somebody tell me why (using GHC.Generics) if I check type of "from (Just True)" we get "Rep (Maybe Bool) x", a function "to" has signature of "to :: Rep a x -> a", but code "to $ from (Just True)" gives us ambiguity error?
01:15:19 <trap_exit> is it illegal in the US to have an aprtment complex that discriminates based on programming langauge?
01:15:30 <trap_exit> i.e. something like: you are only allowed to rent if you know one of clojure, haskell, or erlang
01:15:43 <tdammers> there's a simple solution
01:15:51 <trap_exit> in a post college world, it seems most neighborhoods are not as intellectual
01:15:53 <tdammers> just assess their skill somehow
01:16:03 <tdammers> but refuse them on fake reasons
01:16:20 <trap_exit> we can not rent to you
01:16:24 <trap_exit> because you look like a drug dealer
01:20:01 <danilo2> Hello! Is there a way in Haskell to extract the base type of a variable? I want just a function, which will work like this (extractBase (A 1 2 3)) -> (Proxy :: Proxy A), where A could have some type variables or not. for example - data A a = A a a a. I was trying to use generics but I failed so far :(
01:24:38 <opqdonut> danilo2: data Proxy (f :: * -> *) = Proxy; class Base f where base :: f a -> Proxy f; base _ = Proxy; instance Base []; instance Base Maybe;
01:24:55 <opqdonut> danilo2: needs -XKindSignatures
01:27:05 <danilo2> opqdonut: I do not want proxy to have elements of kind * -> * I want PolyKinds there
01:27:06 <opqdonut> danilo2: no wait, you don't even need the type class. data Proxy (f :: * -> *) = Proxy; base :: f a -> Proxy f; base _ = Proxy
01:27:19 <opqdonut> danilo2: hmm ok
01:28:00 <opqdonut> danilo2: yeah it works with PolyKinds too, just skip the kind signature for f
01:28:19 <opqdonut> hmm, no wait, it doesn't
01:28:29 <danilo2> opqdonut: :D
01:28:30 <opqdonut> you get e.g. base (Foo True ()) :: Proxy (* -> *) (Foo Bool)
01:28:45 <opqdonut> where data Foo a b = Foo a b
01:28:46 <danilo2> opqdonut: of course, but test it with Maybe
01:29:02 <danilo2> oh wait
01:29:20 <danilo2> opqdonut: your exampel is good - I want to get (Proxy Foo) not (Proxy (Foo Bool))
01:29:23 <opqdonut> it's kinda hard to tell when you've completelu "unapplied" a type
01:29:37 <danilo2> opqdonut: I want only the "first" one
01:29:54 <opqdonut> I don't think that's possible without some metaprogramming
01:30:40 <opqdonut> hmm, maybe with type families
01:31:09 <opqdonut> no, maybe not
01:31:43 <apricity> is haskell commonly used, or maybe i should say appropriate for security/crypto programming?
01:32:15 <tdammers> apricity: yes and no
01:32:38 <tdammers> apricity: purity and a strong type system make it a good choice, technically
01:32:46 <danilo2> opqdonut: It should be doable I think. If its not I think this is a medium priority bug in ghc
01:33:15 <tdammers> apricity: downside is that it's off-mainstream, so you'll have a hard time getting it scrutinized the way C or Python do
01:34:04 <tdammers> apricity: and then there's the timing thing - lazy evaluation and declarative programming make it relatively hard to reason about timing characteristics
01:34:24 <tdammers> apricity: so it's not trivial to harden Haskell code against timing side-channel attacks
01:34:57 <apricity> tdammers: ahh I'd heard about that elsewhere too
01:34:59 <tdammers> apricity: then again, formal proofs of correctness are easier to perform for Haskell than for a language that makes generous use of mutable state
01:35:16 <tdammers> apricity: probably the haskell-cafe mailing list, it's been discussed there recently
01:48:19 <danilo2> opqdonut: Oh, it was so simple! I've got it working :) http://lpaste.net/108981
01:53:56 * hackagebot cgrep 6.4.6 - Command line tool  http://hackage.haskell.org/package/cgrep-6.4.6 (NicolaBonelli)
01:55:07 <peti> Hi guys.
01:59:10 <peti> I have a question about type families. I defined a class with two assciated types, i.e. "class Collection c where { type Elem c :: *; type ElemList c :: * }". The default instance for ElemList c is [Elem c], obviously. Now, I'd like to specialize that instance so ElemList (a,b) becomes ([a],[b]) rather than [(a,b)], i.e. I'd like to "unzip" the tuple on the type level.
02:00:47 <danilo2> By the way - is there a way to write http://lpaste.net/108981 using type families somehow ?
02:00:51 <peti> I suppose I could just write out an instance that does this for the (a,b) case, but clearly there is an underlynig pattern that's more general than that, i.e. I wonder how I would generalize that thing to work with triples, quadruples, etc. without having to write an explicit instance every time.
02:02:38 <shachaf> Well, the type (a,b) doesn't really have anything in common with the type (a,b,c)
02:03:33 <tgeeky> peti: With lists, you know: the size of the list, and that every position of the list has the same type. With Tuples, you know the size also, but you do not know that every element has the same type: you just know that every position within every element must be the same type.
02:04:03 <shachaf> You could e.g. use HList-style tuples instead of regular Haskell tuples. Then it might be easier to express the problem.
02:04:36 <peti> shachaf: Right, I HList would do the trick, I suppose.
02:05:24 <shachaf> Well, probably not the original HList but a fancy GADT like data HList :: [*] -> * where { HNil :: HList '[]; HCons :: t -> HList ts -> HList (t ': ts) }
02:05:29 <tgeeky> but that doesn't do the trick, because that is only defined for Tuples.
02:06:09 <tgeeky> I thought you wanted n-tuples?
02:06:28 <c_wraith> danilo2: what the heck is your backwards context syntax?
02:06:44 <danilo2> peti: Maybe you should try to use type classes instead and use "nested tuples", like (a,(b,()))?
02:07:07 <danilo2> c_wraith: ah, sorry for that - it just like => but on the right side.
02:07:17 <danilo2> c_wraith: I'll fix it, brb
02:07:17 <c_wraith> danilo2: but... why?
02:07:48 <Twey> And how?
02:07:58 <peti> danilo2: I've been wondering the same thing. If I can cover the (a,b) case, then I get (a,(b,c)) for free. It's just that that nested tuples less aesthetically pleasing.
02:07:59 <danilo2> c_wraith: because If you got some pretty complex instances its just easier and more pretty to read the code if after "instance" you get all the most important informations and the context is written later
02:08:50 <danilo2> c_wraith: https://github.com/wdanilo/HaskellBooster#rightsidecontexts (but its up to you if you like it or no :) Its just easier for us to develop such instances)
02:08:55 <peti> I could probably define yet another type familiy that converts between (a,(b,c)) and (a,b,c). The instances for those could be auto-generated ...
02:09:01 <c_wraith> danilo2: But..  hiding the context with invalid code doesn't make anything easier.
02:09:26 <shachaf> peti: But that doesn't help you with (a,b,c,d)
02:09:47 <shachaf> HList is just "what if tuples were nested that way".
02:10:31 <danilo2> c_wraith: it is not hiding! Look - if you are reading instances the most important thing (at least for me) is the information what the instance is related to, like Instance SHOW - context is less improtant in the stage when you are looking at it to know what it does. If you get more instances I used to lay out everything nice, but some contexts were long (look at the example @ link above)
02:10:38 * peti tends to shy away from HList because the underlying machinery is so awfully complex.
02:10:54 <danilo2> peti: exactly. I'm, doing something like that and it works great
02:11:01 <Twey> peti: You can implement it in about five or six lines of modern Haskell.
02:11:21 <Twey> With DataKinds and type-level lists.
02:11:44 <peti> Twey: Type-level lists? Huh?
02:12:17 <c_wraith> danilo2: anyway, that seems to be something much easier to do with closed type families.
02:12:40 <Twey> peti: http://lpaste.net/108354
02:13:04 <Twey> s/modern Haskell/modern GHC Haskell/ I suppose ;)
02:13:40 <peti> Twey: Oh, very nice! Thanks for the example, that is quite helpful.
02:14:21 <danilo2> c_wraith: I was trying to, but it just does not work. The problem is with recursion call - the kinds does not match. Look at the definition of one of the instances: (BaseType (Proxy b) (Proxy x)), out~Proxy x => ... You should be able to write (BaseType (Proxy b) out), but you are not. You are always not able to omit the usage of (~) there. Does type families allow for such syntax? I've never seen anything simmilar there
02:18:01 <Twey> peti: Sorry, meant to link this: http://lpaste.net/108985
02:18:34 <shachaf> UnicodeSyntax is not a necessary extension for this type.
02:18:34 <Twey> That's a bit nicer & doesn't require so many extensions
02:19:06 <Twey> Yes, obviously.
02:19:22 <lfairy> I'm kind of annoyed that hscolour highlights "as" out of context
02:20:44 <trap_exit> I need help coming up with a good typeclass name. It has one function, of type :: obj1 -> obj1_delta -> obj2 -> obj2_delta
02:20:53 <peti> Twey: Great, thank you. I'll need a while to figure out how this works, I haven't really looked at the DataKinds extension yet. But I'm getting the impression that I should!
02:20:54 <trap_exit> the idea is that we have two objects, obj1, obj2
02:21:02 <trap_exit> and we have a diff on obj1
02:21:13 <shachaf> If you're doing this sort of thing then you should.
02:21:15 <trap_exit> then we can compute a corresponding diff for obj2
02:22:52 <annelies> You cannot compute a diff on two obj2s if you have only one obj2.
02:22:58 <c_wraith> danilo2: hmm.  Yes.  I seem to have run into a lack of polymorphic recursion in type families.
02:23:03 <annelies> And you cannot compute a diff of a single object, since that makes no sense.
02:23:22 <trap_exit> so there is a function
02:23:24 <annelies> It'd be the identity diff, which is empty.
02:23:27 <trap_exit> diff_apply :: obj1 -> obj1_delta -> obj1
02:23:35 <Twey> Is there an equivalent to the MonadReader class from mtl in transformers?
02:23:36 <trap_exit> diff_apply :: obj2 -> obj2_delta -> obj2
02:23:49 <trap_exit> so obj1 = an object, obj1 = a "delta' on obj1, say, a list of map entries to add/delete
02:23:58 <trap_exit> obj2 = another object, where f obj1 = obj2
02:24:11 <annelies> obj1 and obj2 are types right?
02:24:17 <trap_exit> and I want to compute an obj2_delta, s.t. f (diff_apply obj1 obj1_dekta) = diff)apply obj2 obj2_delta
02:24:19 <shachaf> No. That's why mtl exists.
02:24:26 <trap_exit> annelies: yes, they're types
02:24:30 <danilo2> c_wraith: hmm, I was a little ssuprosed. I was always thinking that type families got more love than fundeps :)
02:25:14 <annelies> There is no obj1 ~ obj2 constraint there so you cannot return values of obj2 if all you have is an obj1.
02:25:29 <trap_exit> there is some function f :: obj1 -> obj2
02:25:33 <annelies> ah I see :P
02:25:56 <annelies> I thought they were type variables since they're lowercase. Or is this all within the type class definition?
02:26:34 <mgore> I've got a question regarding ghc-7.8.3 on os x. does building split-objs work at all? when using this option, ghc always emits a 'warning: ignoring -fsplit-objs'. does someone know what's happening here?
02:26:42 <annelies> man this codebase is outright horrible why is there SQL in the HTML template
02:27:29 <trap_exit> https://gist.github.com/anonymous/24f235f84c8fcaed03b2 <-- please help me find a better name thatn XXXXXXXXXX since this codebase is not for running a porn site
02:28:17 <danilo2> c_wraith: oh no :( It does nto work when there are any polymorphic variables, like "baseType (Just return)" - Do you think, is there any way to accomplish it ?
02:28:30 <trap_exit> annelies: are you using PHP ?
02:28:31 <haasn> @@ trap_exit: @fresh
02:28:31 <lambdabot> Plugin `compose' failed with: Unknown command: "fresh"
02:28:40 <trap_exit> haasn : ?
02:28:48 <annelies> How can you ever use that ZZZZ function?
02:28:56 <annelies> trap_exit yes PHP :'(
02:29:16 <haasn> What happened to @fresh?
02:29:20 <haasn> Oh
02:29:21 <haasn> @freshname
02:29:21 <lambdabot> Hamx
02:29:36 <trap_exit> you given it o1 d1 o2, then it computes a d2 for you
02:29:46 <trap_exit> then using d2, you can get incremental IO ()
02:29:52 <annelies> How would you implement that in an instance?
02:30:07 <annelies> oooh w8 nevermind I understand
02:30:24 <trap_exit> annelies: have you had your morning coffee? :-) generally you're tearing my questions apart
02:30:45 <trap_exit> maybe my idea is vague / retarded, ... her's the general idea
02:30:50 <annelies> btw convention is camelcase not snakecase in Haskell
02:30:51 <trap_exit> object 1 = map of SVG elements
02:30:55 <trap_exit> object 2 = acutal DOM tree
02:31:15 <trap_exit> so when I change the SVG elemnts (say change a Circle's x / yh coordinate)
02:31:22 <trap_exit> then I want a "diff" on the DOM tree, which I then run in an IO () monad
02:31:28 <trap_exit> yeah, ... I'm from closure land
02:31:31 <trap_exit> clojure
02:31:34 <trap_exit> I can't read CameLCase
02:31:40 <trap_exit> snake_case is so muc heasier to read
02:31:51 <trap_exit> I do retraded thigns like mvar__new = newMVar in my code
02:32:06 <annelies> lol "heasier"
02:32:17 <annelies> so hard it became easy
02:32:17 <c_wraith> danilo2: It can't work in the presence of polymorphism.  What's the base type of the term "return True" ?
02:32:50 <danilo2> c_wraith: of course, with "return True" it does not, but with "Just return" it could
02:33:21 <c_wraith> danilo2: it could, in theory.  But the mechanisms for doing so wouldn't be well-founded in general.
02:33:58 <trap_exit> anneleis: https://gist.github.com/anonymous/c2b86c1858928a295c1b ... I'm calling it LocalDiffable
02:34:06 <trap_exit> since it's mapping a local chnange to another local change
02:34:15 <annelies> trap_exit how about SiphonDiff?
02:34:16 <c_wraith> danilo2: it's the difference between hacking in some special cases and finding a way to handle every case uniformly.
02:34:22 <trap_exit> however, I donm't like the order of the arguments; I have d1 -> o1 -> o1  .... vs d1 -> o1 -> o2 -> d2
02:34:35 <trap_exit> it should be more symemtric, maybe o1 -> d1 -> o1; o1 -> d1 -> o2 -> d2
02:34:56 <luite> trap_exit: don't worry, snake case still gets some love in the haskell world, GHC uses it for local names for example. then again, GHC also uses semicolon do notation....
02:35:30 <danilo2> c_wraith: I understand it. But in general case you can track if a variable was ever used and not thrown away and just say "ok, its ambigous, but we do niot care - user does nto use i anywhere"
02:37:08 <c_wraith> danilo2: that'd be the equivalent of some form of laziness in the type system.. which is a pretty substantial change.
02:37:11 <luite> trap_exit: also did you see ghcjs-vdom and how it avoids this problem by pervasive generic memoization?
02:37:31 <trap_exit> I understand what pervasive, memoization means in general
02:37:32 <trap_exit> but not in this context
02:37:39 <luite> :p
02:37:44 <luite> i just made that up
02:37:55 <trap_exit> https://github.com/ghcjs/ghcjs-vdom hmm
02:38:17 <trap_exit> but you still have to diff immutable DOM trees
02:38:23 <danilo2> c_wraith: I was thinking about just a compilation pass, but maybe (and probably) I'm not seeing the true problems behind this :)
02:38:32 <trap_exit> I want to avoid that, I want to map diffs to diffs
02:38:51 <luite> trap_exit: but it's easy to memoize a subtree, and if the underlying vdom library matchs a generated node against one generated from an earlier state, and that part hasn't changed, then it does not have to be rerendered
02:39:02 * hackagebot not-gloss 0.6.0.1 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.6.0.1 (GregHorn)
02:39:10 <trap_exit> right right, I agree on the avod re-rendering part
02:39:15 <trap_exit> the problem I'm trying to solve is "avoid doing a tree diff"
02:39:30 <trap_exit> since I write code that generates the SVG DOM elements / trees
02:39:41 <trap_exit> I have a higher level rep than just "here's two DOM trees, render one into the other"
02:41:07 <annelies> SVG in HTML is such an abomination. :'(
02:41:26 <luite> trap_exit: the vdom memoization is set up in such a way that it can avoid rerenders from an earlier lvel
02:41:27 <trap_exit> luite: correct me if i'm wrong. the vdom you have is as follows: dom_tree1 -> dom_tree2 -> a list of IO commands to change a rendering of dom_tree1 to dom_tree2 ... but to do this, you have to diff dom_tree1 and dom-tree2
02:42:51 <trap_exit> luite: https://gist.github.com/anonymous/2a279f954ead8c8e5f9e <-- this is what you currently have .. right?
02:44:32 <luite> trap_exit: yeah, eventually i'd like something that can avoid the diffing, by adjusting the underlying structure. if you structure your output as an associative operation and adaptively reassociate (like a splay tree) based on what parts of the data have changed, you can get incremental updates without diffing
02:46:13 <luite> trap_exit: that's the basics yes, but with a some lightweight memoization sprinkled in, most of the tree usually does not have to be rendered and compared at all
02:46:27 <trap_exit> luite: https://gist.github.com/anonymous/6e409d0a01785dcc9b86
02:46:34 <trap_exit> luite: that's what I'm trying to do
02:46:40 <trap_exit> I have a higher level rep, GuiTree -> DomTree
02:46:47 <trap_exit> keyboard / mouse events are mapped to "deltas" on the GuiTree
02:46:55 <trap_exit> I want to auto compute "deltas" on the DomTrees
02:47:04 <trap_exit> so taht the "deltas" on DomTrees -> IO events for updating the rendering
02:50:39 <luite> trap_exit: but the philosophy of frameworks like react is that you should save yourself all the work and complexity of computing updates/changes, instead focus on the simpler State -> Output
02:51:09 <trap_exit> yes, but there's only two levels of mapping going on
02:51:16 <trap_exit> level 1 = from DOM tree -> IO ... this is trivial
02:51:26 <trap_exit> and (2) from GUITree -> DomTree ... this is paid once _per gui widget_
02:53:55 <luite> trap_exit: i don't know how your widgets are structured, but if most of the GUITree -> DomTree mapping is in trms of some rendering functions, and you're somewhat careful updating your GUITree structure (i.e. not redrawing it from scratch but using as much sharing as possible) then that should avoid rerendering (and comparing) of most branches of the widgets
02:55:14 <trap_exit> luite: probably
02:55:32 <trap_exit> luite: I tried it once that way in clojure ... but given I'm using haskell, I feel confident enough, with the type checker's help, to get these diffs right
02:55:39 <luite> https://github.com/ghcjs/ghcjs-vdom/blob/master/example/Example.hs this for example has a grid of ~18000 div elements, but i only needs to compare under 200 every frame
03:00:09 <luite> trap_exit: i'm not sure if thinkign in changes is the easiest way to do things like this, efficiently calculating differences between data structure is is tricky
03:00:32 <trap_exit> not if the 'transform' function satisfies some basic axioms
03:01:02 <trap_exit> but it's okay
03:01:11 <trap_exit> this is why I do mini projects, and you do big projects like ghcjs :-)
03:01:25 <trap_exit> actually, there's probably other reasons for the above too
03:02:26 <luite> trap_exit: but if your result is built from, say, (a <> b <> c <> d <> e) and you find that the part that produced c has changed in your state, giving you a c', you can rerender as (a <> b <> c' <> d <> e). if you have an already computed result for ab = (a <> b) and de = (d <> e), then you can just apply <> only twice, and produce ab <> c' <> de
03:03:31 <trap_exit> sure
03:04:25 <trap_exit> luite: I have tremendous respect for you, but I respect haskell's mantra of "whatever it takes to avoid success" more, so I'm off computing diffs :-)
03:04:40 <trap_exit> I'm almost curious how hairy diffs can get
03:04:42 <luite> trap_exit: how much of those axioms or laws can you enforce in the type system?
03:04:52 <trap_exit> luite: in haskell? none of them
03:05:16 <trap_exit> well,a ctually, wait
03:05:17 <trap_exit> let me think this over
03:06:07 <trap_exit> it's basically shit like:  render :: Node -> [Node] -> OtherNode ; render parent childs = foo parent (map render childs)
03:06:12 <luite> trap_exit: bleh there goes another chance of someone doing the hard work of implementing my idea for me ;)
03:06:38 <trap_exit> the idea of "render of a child is independent of its siblings"
03:06:57 <trap_exit> and "render of a node invovles: (1) renfering child, largely indpendent of parent, and (2), parent just adjusts x/y coordinages, i.e. the <g> of the child"
03:07:31 <zebr> hi all. does anyone know if there's a name for coinductively-defined terms (e.g. codata terms)? like... coterms. does that sound reasonable?
03:07:35 <trap_exit> so I may be able to capture this in the type system, by defining render as
03:08:02 <trap_exit> by defining render as (node -> IO ()), (childs -> way of combing childs) ... or somethign like that, separating out the three parts of transforming a node of a tree
03:08:44 <luite> trap_exit: why have render in IO at all?
03:09:22 <trap_exit> luite: err, IO = typo, it's 3:00 am here :-()
03:10:03 <annelies> goto sleep; Oh wait, this is Haskell. No sleep for you!
03:10:47 <trap_exit> the first rule of haskell is: if your code does not compile; you do not sleep
03:10:50 <Twey> zebr: ‘Computations’?
03:11:04 <annelies> and the second rule of haskell is: your code does not compile
03:11:32 <tdammers> hmm, I thought the first rule of Haskell is "you don't talk about Haskell, you just hand out thunks"
03:11:34 <Twey> zebr: A term can represent a value or a computation.  Terms of inductive types represent values, and terms of coïnductive types represent computations
03:11:53 <annelies> you hand out thunks to other thunks
03:12:16 <annelies> then you solve the halting problem and you go to sleep anyway
03:12:45 <annelies> I bet you can solve the halting problem in Perl.
03:13:05 <luite> trap_exit: okay. anyway, ghcjs-vdom contains a few more tricks to get things fast, the VNode things map to opaque structures that are just the JS tree objects without additional overhead, and some stuff to get faster inline literals, even if your approach is different, some of that may still be useful
03:13:10 <trap_exit> annelies: if you can solve the halting problem in Perl, I'll solve it in 1 line of perl
03:14:32 <annelies> I'll just run $program =~ s/\r|\n//g; over my code and beat you to it.
03:15:33 <trap_exit> even better, since Coq has dependent types
03:15:52 <trap_exit> you can define a type in Coq, where if you can define a function of tha ttype, it'll solve the halting problem
03:15:53 <trap_exit> i.e. "if it compiles, it solves halting"
03:15:54 <annelies> =~ with s/// operator being impure bothers me.
03:17:03 <trap_exit> who's this arianvp guy
03:17:10 <trap_exit> (looking at ghcjs-vdom)
03:17:14 <annelies> he's a guy who's been with me in high school
03:17:43 <annelies> he's in Utrecht University now studying CS and maths IIRC
03:17:50 <zebr> Twey: i suppose that's true. i'm specifically working with coinductive proof terms, but 'proof computations' doesn't quite sound right to me. i could call them 'proves', to be like, the verb counterpart of the noun. very sly. :p
03:18:34 <annelies> oh only CS
03:18:34 <trap_exit> damn
03:18:42 <Twey> zebr: You could go for something like ‘negative term’
03:18:45 <trap_exit> aren't all three of you: annelies, luite, arianvp ... all in the netherlands?
03:18:54 <annelies> don't know about luite
03:18:57 <annelies> but arian and I am
03:18:57 <Twey> Versus ‘positive term’
03:19:13 <trap_exit> is linus trovalds also dutch?
03:19:19 <annelies> no, he is Finnish
03:19:20 <luite> no finnish
03:19:21 <trap_exit> so many smart people from that region
03:19:24 <trap_exit> oh
03:19:27 <Twey> Guido van Rossum is Dutch.
03:19:28 <luite> i'm dutch by the way yes
03:19:30 <annelies> if you ain't dutch you ain't much
03:19:45 <luite> and i live in the netherlands
03:19:54 <annelies> luitenant?
03:20:20 <b80905> Is there a function in Prelude that given an associative list [(key, val)] and a key returns the corresponding value?
03:20:37 <luite> b80905: lookup
03:21:02 <hexagoxel> :pl \g x -> ($x) <$> g
03:21:08 <hexagoxel> @pl \g x -> ($x) <$> g
03:21:08 <lambdabot> flip ((<$>) . flip id)
03:21:27 <annelies> lol flip id
03:21:43 <hexagoxel> hmm interesting, my local @pl must be outdated
03:22:00 <annelies> Does pl stand for Perl?
03:22:05 <annelies> Because that code sure looks like it.
03:23:30 <hexagoxel> @help pl
03:23:31 <lambdabot> pointless <expr>. Play with pointfree code.
03:26:32 <t7> anyone know of any AI planning stuff written in haskell?
03:27:15 <Lowl3v3l> t7, what do you mean by "AI planning"? Haskell is one of the most academic languages, there are tons of AI code in haskell afaik.
03:27:19 <trap_exit> you mean A* algorithm?
03:27:33 <t7> no like STRIPS and stuff
03:27:45 <t7> current state -> ? -> goal state
03:28:06 <t7> kinda like A* but not really
03:30:19 <annelies> I need that algorithm. I'd have it solve broke -> ? -> rich.
03:31:10 <trap_exit> there'a few solutiouns to that
03:31:15 <trap_exit> ? = marry rich
03:31:16 <Lowl3v3l> annelies, well i got a solution for that
03:31:18 <trap_exit> ? = stock options
03:31:27 <trap_exit> ? = inherit wealth
03:31:30 <trap_exit> I think that's about it
03:31:37 <Lowl3v3l> broke -> find idiot to sell things he doesnt need -> rich
03:32:56 <tdammers> annelies: it doesn't work that way
03:33:08 <tdammers> annelies: it's either rich -> richer
03:33:13 <trap_exit> in the US, there's one more solution
03:33:15 <trap_exit> broke -> sue -> rich
03:33:26 <tdammers> annelies: or broke -> sheer luck -> rich
03:33:40 <trap_exit> wait, I thikn that's broke -> sue -> (lawyer -> lawyer richer)
03:34:21 <annelies> I think logic programming can help me with my problem. :D
03:34:32 <Lowl3v3l> :D
03:34:48 <trap_exit> there's also broke -> break sha -> steal bitcoins -> rich
03:35:18 <tdammers> or broke -> rob bank -> slighy richer -> imprisoned
03:35:42 <trap_exit> if I treid it, it'd be broke -> try to rob bank -> get shot -> no more money problems
03:35:53 <annelies> tdammers will be fine; I'm in the Netherlands
03:35:57 <annelies> no prisons here
03:36:05 <tdammers> annelies: so am I
03:36:12 <tdammers> annelies: plenty of prisons
03:36:18 <annelies> empty prisons :v
03:36:28 <trap_exit> oh wait
03:36:40 <trap_exit> do you guys ahve the prisons that are "we want to rehabilate people" rather than "we want to punish people" ?
03:36:41 <annelies> more jailers than prisoners :v
03:36:52 <trap_exit> i bet your prisons have faster internet connection then I have
03:37:29 <annelies> If they punished people (which they probably do) then they wouldn't tell.
03:37:47 <annelies> as in punishment other than taking away freedom
03:37:47 <annelies> Because it's illegal to do so.
03:38:11 <annelies> e.g. can't hit people with bricks
03:38:47 <annelies> I want to go to jail once.
03:40:22 <orion> If you want to become rich, ensure that your country has an honest monetary system.
03:40:49 <orion> Otherwise politicians can steal the fruits of your labor through inflation.
03:40:50 * annelies leaves the netherlands
03:41:38 <annelies> soundness of laws should be proved mathematically
03:42:10 <zomg> I would like to see someone try that
03:42:27 <zomg> Although I probably wouldn't understand more than a quarter of the words used in such a proof
03:42:30 <zomg> =)
03:42:45 <annelies> wait for anneliesville :D
03:42:55 <trap_exit> I bet I would understand most of the words, I just wouldn't understand what the sentences meant.
03:43:02 <zomg> heh
03:43:15 <annelies> judges using Coq
03:43:41 <augur> is there a way to import something relative to the current directory?
03:43:43 <Maxdamantus> Don't need a judge.
03:43:53 <k00mi> augur: no
03:43:56 <trap_exit> Coq is for people who feel Haskell's type system is not expressive enough.
03:43:59 <augur> thats frustrating
03:44:02 <Maxdamantus> It's the prosecutors who write the proofs.
03:44:19 <augur> like, i cant have something in ./examples that imports something in ./src ?
03:44:25 <annelies> trap_exit make Haskell's type system impure and invoke Coq from it :D
03:45:00 <trap_exit> annelies: waht does it mean for a type system to be impure? I doin;'t think Coq even has IO :-)
03:45:11 <k00mi> augur: oh, I think you can do that, but I'm not sure how
03:45:21 <BoR0> in some systems, I've seen that mathematical induction is an axiom. but I've seen proofs of mathematical induction. does this mean that some axioms can be proven? or just that there are some systems that have mathematical induction as theorem?
03:45:44 <annelies> import System.Process (shell); f :: shell "coq coq.coq"
03:46:20 <BoR0> (probably a #math question but why not #haskell as well :)
03:48:22 <k00mi> augur: compile with -Lsrc and it works
03:48:58 <augur> im doing stuff in textmate, is there no way to just like... import ../src/Module
03:49:17 <k00mi> no
03:49:20 <annelies> nope
03:49:26 <augur> thats really irritating
03:49:40 <annelies> You can use C preprocessor and #include xD
03:49:42 <augur> that means you cant have an examples dir distinct from your src dir
03:49:56 <k00mi> sure you can
03:49:59 <annelies> you can, but you just have to pass extra flags to the compiler
03:50:04 <augur> yeah if i want to fuck around with cabal
03:50:06 <augur> i dont want to
03:50:10 <annelies> similar to -I in C and PYTHON_PATH in Python
03:50:11 <augur> i want to just load the example in ghci
03:50:24 <augur> without importing the parser
03:50:25 <augur> oh well
03:50:30 <annelies> c'est la vie
03:51:24 <k00mi> if you install the stuff in src/ you can just import it
03:56:00 <annelies> wait
03:56:20 <annelies> Can't you pass that flag with GHC_OPTS pragma?
03:56:37 <annelies> {-# GHC_OPTS -Lsrc #-}
03:56:41 <k00mi> yes, you can do that
03:57:28 <annelies> The current working directory of GHC doesn't change, right?
04:49:15 * hackagebot stringbuilder 0.5.0 - A writer monad for multi-line string literals  http://hackage.haskell.org/package/stringbuilder-0.5.0 (SimonHengel)
05:00:00 <trap_exit> so in the real world, there are daring things
05:00:17 <trap_exit> when people go base jumping, solo climbing, or other risky ventures
05:00:28 <trap_exit> in the haskell ... is there anything like badass / courageous code along that line ?
05:00:45 <Th30n> do everythin in unsafeIO
05:04:23 <pingu> trap_exit: writing something useful
05:04:24 <hexagoxel> type system is the main safety in haskell, so anything defying or ignoring it
05:04:41 <hexagoxel> like writing large amounts of code without any type signatures
05:04:50 <trap_exit> Th30n: I think unsafeIO is stupidity, not courage :-)
05:05:04 <Th30n> trap_exit: was thinking should i comment on that or not xD
05:05:59 <trap_exit> maybe the right querstion is: what is a piece of code, where when I start reading it, I'm like wtf wtf wtf ... then when I finish understanding it, I'm like "only a genius could have written this"
05:06:34 <hexagoxel> does not sound like base jumping or solo climbing to me
05:06:52 <trap_exit> yeah; good point
05:06:56 <trap_exit> bad analogy on my part
05:06:56 <Th30n> trap_exit: hmm, my only answer would be, forget everything about haskell and start learning it again. That's how I feel about every piece of someone's code XD
05:07:21 <pingu> trap_exit: I would go read the comonad reader blog
05:07:30 <pingu> if you want thinks that hurt your brain like that
05:07:47 <trap_exit> http://comonad.com/reader/ ?
05:08:35 <pingu> trap_exit: yes
05:09:23 <pingu> much of it is almost useful, too
05:10:10 <trap_exit> Or do you want to feel better about yourself, confirm that you are programming better, confirm that you are smarter and know more, reassure yourself that your adherence to a niche language is ok by striking out against the mainstream? -- ouch
05:11:11 <OldTimes> hello
05:12:09 <pingu> trap_exit: I wasn't actually a fan of that post. I think acknowledging that kind of person is, in a way, losing to them. The rest of the site is pretty technical.
05:25:26 <magicman> https://gist.github.com/tchakkazulu/5688866 <- a piece of code where when you start reading it, you'll be wtf wtf wtf. And when you finish understanding it, you'll *still* be like wtf wtf wtf.
05:25:43 <magicman> Closest I got <_<
05:33:21 <annelies> lol line 31 and 33
05:33:44 <annelies> My guess is that it prints the same thing five times.
05:34:22 <annelies> The code isn't that obscure.
05:34:30 <quchen_> Using IORefs is not a dead giveaway of anything.
05:34:46 <magicman> Aye! Also fun: replacing the 0 from the newIORef to something else.
05:35:31 <annelies> Is (&) = flip ($) often used outside of lenses?
05:35:58 <trap_exit> i want to see some pointfree obfuscation contest
05:36:05 <annelies> In many cases I like to read LTR instead RTL.
05:36:27 <tdammers> $ *is* LTR... depending on your frame of reference :P
05:36:46 <annelies> I mean as in data flow.
05:36:56 <quchen_> trap_exit: Most things are awful when written pointfree, that contest would not be very interesting.
05:37:03 <quchen_> ?pl \a b c -> [a,b,c]
05:37:04 <lambdabot> (. ((. return) . (:))) . (.) . (:)
05:37:08 <annelies> x & f & g means first f then g whereas f $ g $ x means first g then f
05:37:23 <tdammers> evaluation order, yes, sort of
05:37:25 <quchen_> The "better in pointfree" functions are a tiny subset.
05:37:41 <tdammers> but not really when you consider laziness
05:37:42 <annelies> well order of evaluation is irrelevant because it's pure
05:37:46 <annelies> and lazy
05:38:16 <annelies> but I mean g sees f'ed x
05:38:52 <tdammers> not if g ignores its input
05:39:08 <tdammers> then f isn't called *at all*
05:39:14 <annelies> what a surprise
05:39:22 <Twey> annelies: It's used in a bunch of things, like Diagrams and Threepenny.  It's nice to have around.
05:39:22 <annelies> YKWIM
05:39:27 <tibbe> edwardk: what do you think about adding Word to the Prelude?
05:39:43 <tdammers> yes, I do; still, data flow isn't as absolute a thing as it may seem
05:39:52 <tibbe> edwardk: it’s the odd one out and it’s such a core type. The closest thing we have to a natural number.
05:40:06 <tibbe> edwardk: right now users are a bit encouraged to use a signed type when they shouldn’t/
05:40:08 <tdammers> when you evaluate f $ g $ x lazily, evaluation of f starts before evaluation of g
05:40:24 <annelies> tibbe doesn't it do underflow?
05:40:48 <tibbe> annelies: it wraps mod 2^32/64 yes
05:40:49 <annelies> tdammers I don't care about order of evaluation
05:41:03 <tibbe> annelies: it’s just a fixed width unsigned int with modulo smenatics
05:41:16 <annelies> It's about the conceptual order you apply the operations to transform your data
05:41:34 <annelies> in which*
05:41:34 <tdammers> annelies: I know. I understand what you mean. And it's valid.
05:41:46 <tdammers> annelies: it's just less absolute than one might be tempted to think.
05:41:58 <annelies> Oh, okay. :P
05:42:04 <tdammers> annelies: it's a mental model that works, until you run into the case where it doesn't
05:42:19 <mhyperbolic> Is there a more "classic/cononical" Haskell solution to this problem? http://lpaste.net/108991
05:42:54 <tdammers> > let f = const 0 in f $ (+ 1) $ undefined
05:42:55 <lambdabot>  0
05:42:59 <annelies> well if (&) = flip ($) then the order of evaluation, if any, is obviously the same as with $
05:43:08 <tdammers> yes
05:43:29 <tdammers> but "LTR" doesn't completely cover what's really happening
05:44:00 <tdammers> > let f = const 0 in undefined & (+ 1) & f -- this would bottom out if it were truly LTR
05:44:02 <lambdabot>  0
05:44:07 <quchen_> safeInit [] = Nothing; safeInit x = Just (init x) -- A safe wrapper, mhyperbolic
05:44:10 <annelies> yes
05:45:11 <annelies> > let x & f = x `seq` (f x) in undefined & (+ 1) & const 0
05:45:12 <annelies> XD
05:45:13 <lambdabot>  *Exception: Prelude.undefined
05:45:43 <quchen_> ($) and (&) are not about order of evaluation, but about order of reading.
05:46:05 <mhyperbolic> quchen_, Ah yes. That is of course simpler. Thanks
05:54:25 * hackagebot auto-update 0.1.1.1 - Efficiently run periodic, on-demand actions  http://hackage.haskell.org/package/auto-update-0.1.1.1 (MichaelSnoyman)
06:09:27 * hackagebot Plot-ho-matic 0.4.0.3 - Real-time line plotter for protobuf-like data  http://hackage.haskell.org/package/Plot-ho-matic-0.4.0.3 (GregHorn)
06:17:30 <EnglishGent> Hi all -  not _strictly_ a Haskell question, but this is one of the few channels I think it appropriate for....
06:17:50 <EnglishGent> imagine I define a couple of simple DSLs as ADTS -- say integer arithemtic or boolean algebra
06:18:12 <EnglishGent> I can think of two functions that are applicable to both 'eval' & 'simplify'
06:18:25 <EnglishGent> eval reducing an expression with no variables to a value
06:18:43 <EnglishGent> and simplify possibly yielding a smaller, equivalent expression
06:18:50 <EnglishGent> would those functions be catamorphisms?
06:18:53 <EnglishGent> :)
06:19:06 * EnglishGent trying to understand the general idea :)
06:19:11 <OldTimes> I'm new at this, so...
06:19:16 <OldTimes> what are catamorphisms?
06:19:46 <EnglishGent> http://en.wikipedia.org/wiki/Catamorphism
06:19:49 <annelies> fancy word for fold with some deeper meaning
06:20:00 <EnglishGent> but I don't properly understand myself - that's what I'm trying to get
06:20:36 <EnglishGent> I thought it was more than just fold - that fold was *an* example of a catamorphism
06:20:59 <EnglishGent> but that catamorphisms themselves were a more general concept which could (somehow) be defined for many datatypes
06:24:30 * hackagebot alfred 0.2 - utility library for Alfred version 2  http://hackage.haskell.org/package/alfred-0.2 (PatrickBahr)
06:29:23 <danilo2_> Hello! I've got a data type "data V a = V a" I want to have a function which would return an identificator or anything unique for instances of each different datatype. I mean, I want something like "getPtr (V 1)" be the same as "getPtr (V 'a')" AND "getPtr (V (return 5))". The problem appears with polymorphic values, but is there any, even very hackish method to accomplish it?
06:32:29 <geekosaur> I think poymorphism still defeats it, but extract a TypeRep and then fst . splitTyConApp ?
06:38:59 <danilo2_> geekosaur: I cannot extract TypeRep with such value, can I ? :(
06:39:46 <geekosaur> well, a concrete value can't be polymorphic, so if you have an actual value and you derived Typeable for it then you can use typeOf
06:40:15 <geekosaur> wait, forall. not sure how that interacts currently
06:40:29 <jfeltz> is there a way to get all possible permutations of a package dependency tree for testing a hackage targeted cabal package? (assuming version bounds)?
06:40:40 <geekosaur> my understanding is the current Data.Typeable machinery is capable of handling that kind of polymorphism but nobody has written the code yet
06:40:49 <jfeltz> or combinations, rather
06:41:06 <danilo2_> geekosaur: following line fails to compile: "typeOf (V (return 5))"
06:41:52 <geekosaur> that means little to me since I have no idea what V is. is there enough information for ghc to know what it is at that point?
06:42:22 <danilo2_> geekosaur: yes! V iss just "data V a = V a deriving Typeable"
06:42:43 <danilo2_> geekosaur: I do not care about "a" - I want just to base on "V"
06:42:53 <geekosaur> then the correct answer to my question is "no" because you provided no information for the compiler to know `a` there.
06:43:03 <geekosaur> and you can't use defaulting there
06:43:15 <geekosaur> and if you believe this is a flaw in Typeable then you have not figured out ghc yet
06:43:38 <danilo2_> geekosaur: But I do not want it - look, I want to get THE SAME thing for (V 5), (V "a") and (V (return 5)). I just want and unique identifier for datatype "V".
06:43:47 <geekosaur> you want ghc to assign a type to an expression containing a type level undefined
06:43:57 <geekosaur> that does not matter
06:44:19 <geekosaur> ghc will not, with or without Typeable, compile an expression containing a type level undefined
06:44:36 <geekosaur> this is not a problem with Typeable or a problem you can work around with clever code
06:45:13 <geekosaur> if you have a concrete value, it must have a concrete type or ghc's type checker will not work with it
06:45:44 <danilo2_>  geekosaur: hmm, so is there any - just any way to do it? without typeable or anything? I Just want to be able to get a constant value for each instance of V another value for each istance of other datatype etc
06:45:59 <geekosaur> that type may have an embedded forall in it, but for `data V a = V a` ghc's type checker is going to insist that it know `a` before it even looks at your code
06:46:32 <geekosaur> you're still on the wrong level
06:46:49 <danilo2_> geekosaur: :(
06:47:30 <geekosaur> "no, you can't do it" solved. because I am apparently not getting across that the problem is at a different level than you are trying to hack it at
06:48:10 <geekosaur> put otherwise, there is a difference between `data V a = V a` and `data V a = V (forall a. a)` and the latter is what you're trying to do
06:48:25 <geekosaur> but adding that forall will cause you other problems that I'm pretty sure you've run into in the past
06:48:29 <danilo2_> geekosaur: I understand it is on other level. I was just hoping there is a way to do it because I still do not see exactly these levels. Thank you.
06:48:50 <danilo2_> geekosaur: exactly
06:49:05 <geekosaur> you want the `data V a = V a` and `data V a = V (forall a. a)` to be the same inside the typechecker so you can defer the `forall`-ness to runtime
06:49:45 <geekosaur> but no amount of runtime faffing about will solve the compile time problem of ghc wanting to assign a concrete type to a `V a`
06:50:27 <danilo2_> geekosaur: not exacly. I would love to use even (V get) - so m will have context of MonadState - - I know we can code it using forall, but still I would not to, because of other caveats and big problems with such solution
06:50:48 <geekosaur> (the notion of extracting just the constructor like that is runtime type representation; at compile time, `V` is incomplete and cannot be represented)
06:51:27 <danilo2_> geekosaur: Hmm I was not thinking about runtime. I was just thinking about GHC, which (during compile time) seeing function like (foo _ = 5) would give up resolving types of the argument because they are not bneeded here
06:51:53 <danilo2_> geekosaur: I was not talking about constructior, but about the type of V!
06:51:53 <geekosaur> no, it does resolve types there, it just uses defaulting
06:52:11 <geekosaur> V does not have a concrete type
06:52:15 <geekosaur> it has a non-* kind
06:53:10 <danilo2_> geekosaur: Oh, I completely do not understand it. Has not (V 5) the Type of V Int? and (V (return 5)) type of (V (m Bool)) ?
06:53:20 <geekosaur> and this is a perfect example of mixing levels. ghc cannot think like you do and muddle the concept of types so that a non-* kind like `V` has a meaningful type
06:53:44 <geekosaur> it can only assign a type to something of kind *
06:54:13 <danilo2_> I just wanted to write instance like: class Test a b | a -> b where test :: a -> b.  instance Test (V a) Int where test _ = 5; And GHC can, during compile time see, that the a is not needed. Or am I still confusing some "levels" ?
06:54:31 <danilo2_> geekosaur: oh
06:54:46 <danilo2_> geekosaur: I did not know about it
06:54:57 <geekosaur> there are times when it can be satisfied with saying "any type here". what it cannot do is jump from that to "*no* type here"
06:55:06 <danilo2_> geekosaur: hmm and what with (Proxy sthng) ? Proxy has always kind of *
06:55:10 <geekosaur> which is kinda what you're looking for
06:55:36 * geekosaur is getting bossed at, may have to vanish
06:56:01 <geekosaur> Proxy has a phantom type that has no value associated with it
06:56:44 <geekosaur> what you can't do is tell ghc that something like `data V a = V a` is secretly `data V a = V` which is the phantom type version
06:56:49 <danilo2_> geekosaur: hmm, I'm looking right now into it. Thank you, brb
06:56:50 <geekosaur> unless you actually write that `data`
06:57:42 <geekosaur> if you say `data V a = V a` then it has to have a concrete value, hence a concrete type, for `a` regardless of whether it's used --- because your `data` told it that it is mandatory
06:58:55 <vuiiiiiiiiiiiic> http://bet-tips.cogia.net/?ref=1810
07:00:14 <danilo2_> geekosaur: ok, I understand it. Im just thinking now how can I change the datatypes (they are generated) to be able to just do it. Do you see any other way of representing some datatypes (without IORefs etc) so we can do something like that?
07:00:48 <geekosaur> not offhand. we're getting into areas where my understanding is a bit weak, to be honest
07:01:56 <danilo2_> geekosaur: Oh ok. Could I as kyou one more question? - Do you know who can I ask about it ? This is a very hard but very, very important topic to me and I would just do anything to get the answert and do it someghow
07:02:51 <geekosaur> no, sorry. guess I'd ask later on when other people are around
07:03:04 <geekosaur> (it's somewhat odd that I'm the only active person in channel...)
07:03:11 <danilo2_> geekosaur: ok, thank you once again!
07:03:30 <danilo2_> geekosaur: for some time lately the amount of people here is very low
07:03:39 <danilo2_> "active people"
07:04:02 <edwardk> tibbe: the danger of word based lengths is inevitably users use them to compare after subtraction and get really bad errors, so any upgrade path that swaps Int for Word in length will be silently non-breaking. I'd be okay with its addition, but I'd probably fight tooth and nail against swapping things like length over to it
07:06:04 <tibbe> edwardk: I think length et al are way too late to change
07:06:11 <chrisdotcode> johnw_: hey, you around?
07:06:16 <tibbe> edwardk: we do have a concrete problem with array sizes though
07:06:33 <tibbe> edwardk: it would be nice to be able to allocate up to the memory size
07:07:08 <tibbe> edwardk: (what prompted this is that validate is now failing with a segfault in GHC because a test tries to allocate a 2^64 - 10 size array and a comparison on Int is overflowing)
07:07:24 <geekosaur> well, it is time of day dependent. for me it's 10:00am and I'm multitasking between here and work stuff. others in the Eastern Standard Tribe [ :) ] presumably are also involved in morning organization things
07:09:47 <edwardk> tibbe: yeah i recall hvr mentioning the problem
07:10:42 <edwardk> like i said, i'm more than okay with exporting Word from Prelude, we should go through libraries@ for it, but its a very common thing, i'd expect almost zero breakage other than some warnings from users who were (now-redundantly) importing Data.Word
07:19:49 <joe9> How do I convert from Int to NominalDiffTime (of System.Time.Clock)?
07:20:36 <joe9> I have a noOfDays :: Int = 4, I want to convert that to NominalDiffTime. I do (noOfDays * 86400) :: NominalDiffTime
07:20:53 <joe9> http://codepad.org/Jvvtgc6L I get this error.
07:21:10 <joe9> Any thoughts, please?
07:22:28 <joe9> got it , fromInteger
07:26:03 <Twey> How come http://hackage.haskell.org/package/distributed-process-0.5.0 hasn't been built yet?  It was uploaded in June
07:34:19 <ninedotnine> there are a number of times where i'd like to use data.text in place of string, but the libs i'm using (e.g. X11) only deal with string. does it do me any good to pack and then just unpack almost right after?
07:35:15 <johnw> it's pretty much what you have to do
07:35:25 <johnw> the other thing you could do is to create a little wrapper module for yourself
07:35:34 <johnw> so that all the packing and unpacking is confined to that module
07:35:44 <johnw> in effect making it appear as though the lib had a Data.Text interface
07:36:12 <ninedotnine> is that worthwhile? it seems like it would still have all the usual performance drawbacks of just using string in the first place
07:36:20 <Twey> ninedotnine: Well, you get the advantage that you can use Text elsewhere
07:36:24 <johnw> yeah, it depends
07:36:35 <johnw> if you use Text internally in your program more than you convert them, then yes
07:36:36 <Twey> And the String might in theory be deforested away
07:36:40 <johnw> if all you're doing is converting, then no
07:37:45 <ninedotnine> i might do at most one or two operations on the text, like appending some, but otherwise it would just be converting
07:38:17 <ninedotnine> Twey, i'm not familiar with "deforesting", could you explain or give me a link?
07:38:27 <johnw> also, if you use lots of other libraries that use Text, then you have to pick a lingua franca
07:38:50 <ninedotnine> it would be great if these libraries would use the IsString typeclass in the first place
07:38:53 <mwhit> you could just write your functions on IsString a
07:39:04 <ninedotnine> it's pretty frustrating that so much of the standard library uses String
07:39:27 <qnikst> Twey, in most cases it's only in theory :)
07:51:42 <Twey> qnikst: Indeed…
07:51:43 <mmachenry> Is there an existing program to count lines of code in a Haskell project that looks at the source code intelligently? I would like to get counts that eliminate empty lines (easy) comment lines (easy) and type declarations (less easy) and import lines (easy)
07:52:16 <mmachenry> But instead of writing my own it'd be nice if there were something that already gave me an idea of the complexity of my code vs. the amount of imports or comments.
07:52:46 <Twey> ninedotnine: When GHC sees a data structure being created and then consumed again, it tries to avoid creating it entirely.
07:52:58 <zomg> mmachenry: Don't know of a tool, but you could probably do that with a few regex replaces =)
07:53:07 <Twey> ninedotnine: But like qnikst says, I wouldn't count on it, especially between modules/packages.
07:53:25 <mmachenry> zomg: Yep, I'd rather not :)
07:53:29 <qnikst> ninedotnine: http://research.microsoft.com/en-us/um/people/simonpj/Papers/deforestation-short-cut.ps.Z <- classic paper
07:53:31 <ninedotnine> ah, mk thanks. in that case, there would be no point at all
07:54:00 <ninedotnine> ghc seems to have a lot of hypothetical optimizations that shouldn't be relied upon
07:54:07 <tb01110100> Why would a song be pink in ncmpcpp?...
07:54:31 <tb01110100> wrong channel
07:54:36 <Twey> ninedotnine: Well, deforestation is very useful, and key to much of GHC's performance.  But probably not in your case.
07:54:42 <qnikst> ninedotnine: I think you may rely on foldr/build much
07:54:57 <jedai> Twey: ninedotnine: GHC in itself doesn't do deforestation, RULEs try to do it and often succeed
07:55:06 <qnikst> just for strings it may even hard a performance (I'm not a real expert here)
07:55:24 <jedai> of course, afaik GHC is the only haskell compiler implementing RULEs so...
07:55:37 <qnikst> s/hard/harm/
07:56:22 <jedai> ninedotnine: GHC does a lot of optimization, it's just that sometimes we expect too much of it since it already does so much
07:57:00 <sclv> mmachenry: http://www.dwheeler.com/sloccount/
07:57:33 <sclv> its smart enough on the axes i want, and does things i didn't realize i wanted on other axes too
07:57:47 <mmachenry> sclv awesome
07:59:29 <negatratoron__> How do you pronounce the <|> operator?
07:59:43 <sclv> "or"
07:59:52 <etandel> negatratoron__: on parsec? 'or'.
08:00:10 <negatratoron__> I see it has type (Alternative f) => f a -> f a -> f a
08:00:19 <sclv> "or" works there too
08:00:20 <etandel> pattern1 <|> pattern2 => pattern1 or pattern2
08:00:35 <sclv> or "lift or" or the like if you need to distinguish from
08:00:37 <sclv> ?ty or
08:00:39 <lambdabot> [Bool] -> Bool
08:01:19 <supki> :t lift or
08:01:21 <lambdabot> MonadTrans t => t ((->) [Bool]) Bool
08:01:34 <etandel> alternatively, "match pattern2 if pattern1 doesn't match"
08:01:44 <sclv> perhaps "or else" :-)
08:02:06 <clrnd> :t (||)
08:02:08 <lambdabot> Bool -> Bool -> Bool
08:03:16 <negatratoron__> What would be the difference between using <|> and fmapping an 'or' function?
08:04:11 <negatratoron__> fmapping -> zipping
08:04:36 <negatratoron__> It looks like <|> just has access to the whole data structure, whereas zipping an "or" function you would have to go element by element.
08:05:32 <negatratoron__> Is there a place I can see the Alternative implementations for List and Maybe?
08:05:35 <negatratoron__> i think that would help
08:09:35 <jedai> negatratoron__: This is not at all the same thing
08:09:42 <jedai> :t liftA2 or
08:09:44 <lambdabot>     Couldn't match type ‘Bool’ with ‘b -> c’
08:09:44 <lambdabot>     Expected type: [Bool] -> b -> c
08:09:44 <lambdabot>       Actual type: [Bool] -> Bool
08:09:57 <jedai> :t liftA2 (||)
08:09:58 <lambdabot> Applicative f => f Bool -> f Bool -> f Bool
08:10:07 <jedai> :t (<|>)
08:10:08 <lambdabot> Alternative f => f a -> f a -> f a
08:10:29 <negatratoron__> alright
08:11:03 <negatratoron__> What does <|> do, that would justify calling it "or"?
08:11:15 <jedai> negatratoron__: Do you see the difference ? "liftA2 (||)" applies to the "content" of the applicative, whereas (<|>) is a fundamental operation whose implementation depends on the Applicative/Alternative instance
08:11:19 <negatratoron__> Yeah, I do
08:11:38 <adas> http://www.yesodweb.com/page/quickstart <- can that yesod guide be used. because I believe the guide was written for an earlier version?
08:11:52 <mwhit> etandel just answered it above. p1 <|> p2 means "try pattern 1, if it fails, try pattern 2"
08:11:57 <jedai> negatratoron__: Well for parsers it is a "try this, and if it fail try that instead"
08:12:12 <mwhit> liftA2 (||) is just "apply a logical or to the values in these functors
08:12:47 <clrnd> funny that (Just False) <|> (Just True) == Just False, it behaves like and, not or
08:12:55 <jedai> negatratoron__: for Maybe it is basically returns the first Just .. between the operands or Nothing if both operands are Nothing
08:12:57 <negatratoron__> That makes sense though
08:13:04 <negatratoron__> Just would be the 'success' case for Maybe
08:13:17 <jedai> clrnd: that's because (<|>) don't care at all about the content
08:13:18 <negatratoron__> but how does it behave for List?
08:13:30 <clrnd> yeah that was teh point :D
08:13:38 <jedai> > [1,2] <|> [3,4]
08:13:40 <lambdabot>  [1,2,3,4]
08:13:52 <negatratoron__> alright
08:14:13 <negatratoron__> I see these instances match the type signature, but I don't think I grasp the unifying concept
08:14:44 * hackagebot wai-extra 2.1.1.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-2.1.1.3 (GregWeber)
08:15:15 <negatratoron__> Why would [1,2] <|> [3,4] = [1,2] be wrong?
08:15:18 <jedai> negatratoron__: it's a monoid but limited on Applicative functors
08:16:54 <negatratoron__> I am guessing <|> has its own 'laws' that proper instances uphold
08:17:21 <mwhit> yes, it's a monoid over the functor
08:17:34 <mwhit> the applicative*
08:17:38 <jedai> negatratoron__: not really, it's a monoid so it must respect those laws and some and many have default definition you must emulate if you reimplement them but that's it
08:18:19 <jedai> negatratoron__: monoids law are the neutral element and the associativity of the operation, that's all
08:18:20 <mwhit> the name "Alternative" is pretty deceptive for the [] instance, admittedly
08:18:22 <negatratoron__> okay cool
08:19:03 <negatratoron__> would it be fair to say the Alternative type class is for declaring certain Applicatives form monoids under some <|> operation?
08:19:18 <mwhit> yes
08:19:20 <mwhit> and empty
08:19:48 <negatratoron__> that makes a lot of sense now
08:19:49 <jedai> mwhit: if you see List as a monad to apply to several values simultaneously, it makes sense, in "e <- xs <|> ys", e can come from xs _or_ ys
08:19:50 <negatratoron__> I think
08:20:04 <negatratoron__> an applicative really could form a monoid several different ways
08:20:19 <mwhit> in principle, sure
08:20:23 <mwhit> that's why we have list and ZipList
08:20:38 <negatratoron__> ahh yes
08:21:03 <jedai> mwhit: that's more of a "type constructor" can form an Applicative in several ways
08:21:08 <hiptobecubic> > let x = [1, 2, 3, 4]; y = [4,5,6] in do e <- x <|> y; return e
08:21:10 <lambdabot>  [1,2,3,4,4,5,6]
08:21:17 <hiptobecubic> Interesting.
08:21:28 <clrnd> nice one
08:21:48 <jedai> mwhit: I don't see any reason there could not be an Applicative that have several Alternative instance possible (though we have to chose one)
08:21:54 <hiptobecubic> List as an applicative hadn't really occured to me
08:22:02 <hiptobecubic> Although I don't see why to use it
08:22:27 <jedai> hiptobecubic: avoid liftM10 ?
08:22:38 <mwhit> [id, (+1), (*3)] <*> [1,2,3]
08:22:44 <mwhit> > [id, (+1), (*3)] <*> [1,2,3]
08:22:45 <lambdabot>  [1,2,3,2,3,4,3,6,9]
08:23:07 <hiptobecubic> > let x = [1,2,3]; in (,) <$> x <*> x
08:23:09 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
08:23:34 <hiptobecubic> > let x = [1,2,3]; in (,) <$> x <* x
08:23:36 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable b0)
08:23:36 <lambdabot>    arising from a use of ‘M779289659707256955226305.show_M7792896597072569552...
08:23:36 <lambdabot>  The type variable ‘b0’ is ambiguous
08:23:36 <lambdabot>  Note: there are several potential instances:
08:23:36 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
08:25:15 <clrnd> works with *>
08:25:27 <hiptobecubic> > let x = [1,2,3]; in (,) <$> x *. x
08:25:29 <lambdabot>  Not in scope: ‘*.’
08:25:29 <lambdabot>  Perhaps you meant one of these:
08:25:29 <lambdabot>    ‘*’ (imported from Prelude), ‘.’ (imported from Data.Function),
08:25:29 <lambdabot>    ‘C..’ (imported from Control.Category)
08:25:31 <hiptobecubic> > let x = [1,2,3]; in (,) <$> x *> x
08:25:33 <lambdabot>  [1,2,3,1,2,3,1,2,3]
08:25:35 <hiptobecubic> Why?
08:25:42 <hiptobecubic> oh right
08:26:03 <hiptobecubic> i was always confused by the precedence of <$>
08:29:14 --- mode: ChanServ set +o Saizan
08:32:37 <yitz> > [1,2,3] `mplus` [4,5,6]
08:32:39 <lambdabot>  [1,2,3,4,5,6]
08:33:33 <mwhit> > ZipList [1,2,3] <|> ZipList [4,5,6]
08:33:34 <lambdabot>  Could not deduce (Control.Applicative.Alternative
08:33:34 <lambdabot>                      Control.Applicative.ZipList)
08:33:35 <lambdabot>    arising from a use of ‘Control.Applicative.<|>’
08:33:35 <lambdabot>  from the context (GHC.Num.Num a)
08:33:35 <lambdabot>    bound by the inferred type of
08:33:39 <mwhit> hm
08:33:43 <mwhit> interesting
08:40:42 <kstt> Hi. Is there a librairie to format floating point numbers so that they display nicely. For example, I would like to truncate them to 2 significant digits.
08:41:30 <clrnd> kstt, Text.Printf
08:42:01 <kstt> oh no ... ;)
08:47:56 <kstt> thank you clrnd
08:48:01 <yitz> kstt: for that particular use case, the float-related functions in Numeric are useful.
08:48:24 <kstt> yitz: which package please ?
08:48:30 <kstt> or which module ?
08:48:30 <yitz> kstt: base
08:49:05 <kstt> ok, Numeric from base
08:50:24 <mmachenry> Doe anyone know what I did to kill my cabal haddock command? I did a "cabal clean" and "cabal install" still works but "cabal haddock" now tells me to "run the configure command" but I don't have a configure command
08:50:29 <mwhit> :t showFFloat
08:50:31 <lambdabot> RealFloat a => Maybe Int -> a -> ShowS
08:50:41 <geekosaur> it means `cabal configure`, I think
08:51:07 <mwhit> > showFFloat (Just 2) 1.234 ""
08:51:09 <lambdabot>  "1.23"
08:51:14 <mmachenry> Oh, thanks.
08:51:16 <mwhit> > showFFloat (Just 2) 1.234 "why is this here"
08:51:18 <lambdabot>  "1.23why is this here"
08:51:23 <geekosaur> although a bare `cabal install` without a package name should leave the configure information it wants around
08:51:38 <monochrom> "cabal install" already performs "cabal configure" so this is strange
08:52:07 <geekosaur> mwhit: take a look at ShowS
08:52:33 <monochrom> however, you should not be doing the sequence "cabal install; cabal haddock" in the first place. wrong concept.
08:52:36 <mwhit> yeah i know the type, i just don't know why it doesn't just return a string
08:52:41 <geekosaur> basically it's a form of functional concatenation, that shifts the cost of concatenation in ways that can be useful
08:52:53 <mwhit> gotcha
08:53:57 <geekosaur> if you do `a ++ b`, it has to scan all of a before it can do anything with b; if you build up a long chain this way, it scans `a` multiple times and it keeps getting longer and longer. if you use ShowS correctly, you can arrange for it to only be scanned once
08:54:13 <geekosaur> as part of outputting it
08:54:16 <geekosaur> (IIRC)
08:54:27 <geekosaur> it is a bit mind twisting if you're not used to it
08:54:32 <mwhit> so like a diff list but just for strings
08:54:36 <geekosaur> yes
08:55:25 <yitz> kstt: there is also a really fast double-to-text converter by bos, using a c++ library: double-conversion
08:56:24 <yitz> kstt: and a blaze-builder front-end for that: blaze-textual
08:56:26 <kstt> thank you yitz for this tip
08:56:46 <kstt> luckily, this time performance does not matter
08:56:59 <yitz> kstt: oh, i see that the (fairly) new native Builder in Data.Text.Lazy in the text package supports this kind of rendering too
08:57:40 <hiptobecubic> geekosaur, why not use (:) and then concat?
08:57:51 <hiptobecubic> instead of finagling around with ShowS
08:58:01 <hiptobecubic> which, frankly, is some kind of magic
08:58:02 <yitz> Data.Text.Lazy.Builder.RealFloat
08:59:06 <yitz> hiptobecubic: you can think of ShowS as a poor man's pretty printer. or as a precurser to the modern concept of a Builder.
08:59:48 * hackagebot csound-expression-dynamic 0.0.6 - dynamic core for csound-expression library  http://hackage.haskell.org/package/csound-expression-dynamic-0.0.6 (AntonKholomiov)
08:59:50 * hackagebot csound-expression-typed 0.0.5.3 - typed core for the library csound-expression  http://hackage.haskell.org/package/csound-expression-typed-0.0.5.3 (AntonKholomiov)
09:01:17 <monochrom> hiptobecubic: I have this data type "data R = Nil | Cons R Int". I want its Show instance to work like this: show (Cons (Cons (Cons Nil) 1) 2) = "1 2 ". how do you code it up with (:) and concat?
09:02:18 <Cale> monochrom: There's one too many Conses in your example there, I think
09:02:28 <Cale> Er...
09:02:33 <Cale> yeah
09:02:50 <Twey> (Cons (Cons Nil 1) 2)
09:04:49 * hackagebot csound-expression 4.0.0 - library to make electronic music  http://hackage.haskell.org/package/csound-expression-4.0.0 (AntonKholomiov)
09:04:51 * hackagebot csound-catalog 0.2.0 - a gallery of Csound instruments.  http://hackage.haskell.org/package/csound-catalog-0.2.0 (AntonKholomiov)
09:04:53 * hackagebot temporal-csound 0.4.0 - library to make electronic music, brings together temporal-music-notation and csound-expression packages  http://hackage.haskell.org/package/temporal-csound-0.4.0 (AntonKholomiov)
09:05:49 --- mode: Saizan set -b $a:beaky$#haskell-ops
09:06:33 --- mode: Saizan set -o Saizan
09:07:47 <fizbin> Anyone have much experience writing binary files in Haskell?
09:08:20 <fizbin> Say, files of the kind where the primary documentation is a load of C data structures?
09:09:10 <Saizan> not much, but some, i would probably use attoparsec for that now
09:09:14 <vlatkoB> For two simple identical functions, GHC can guess type if there is a function param, and not if there is none. Is this a bug?
09:09:16 <vlatkoB> http://lpaste.net/2411222827844763648
09:09:55 <monochrom> no, it is the monomorphism restriction specified in Haskell standard
09:10:18 <fizbin> What I've been doing with binary files is here, and I was hoping for feedback: http://lpaste.net/6964464176848699392
09:10:45 <fizbin> Fortunately, I only need to write them, not read them.
09:11:04 <vlatkoB> monochrom: I'll have to read about it again. Thanks for pointing it out.
09:11:57 <fizbin> Hrm. My new version of makeBlob isn't catching length mis-computation anymore...
09:12:22 <Saizan> vlatkoB: the idea is that people expect sharing from definitions with no function params, but implementations cannot provide it when there's a typeclass context, so the MR forces GHC to try to resolve the Monad m constraint away, which fails because m could be anything
09:12:27 <OldTimes> I'm reading learn you a haskell right now...
09:12:33 <OldTimes> lazy languages are awesome.
09:13:06 <Twey> => is a function arrow in disguise
09:13:34 <monochrom> I don't like that
09:14:20 <annelies> OldTimes so if I’d make a PHP clone that is lazy, it would be awesome?
09:14:21 <annelies> :P
09:15:03 <sleepynate> well, the syntax could get much worse, so probably :D
09:15:10 <monochrom> there is some contradiction is "PHP clone that is lazy"
09:15:26 <monochrom> unless you wing what "clone" means
09:16:12 <monochrom> but if you wing that, then everything qualifies as a "PHP clone", even assembly language does.
09:17:10 <vlatkoB> Saizan: I read about MR few days ago, but still can't recognize it when it bites.
09:18:43 <Saizan> vlatkoB: some just disable it :)
09:26:34 <yitz> fizbin: without going too deeply into your particular case, i have found that the binary or cereal package is great for that kind of thing.
09:27:31 <yitz> fizbin: you can usually write an expression in the Put monad that is pretty much a word for word translation of the C spec
09:28:20 <jfischoff> Is there a library that lets you get the pid (on linux) of the process that is executing?
09:29:05 <yitz> fizbin: the catch is that the Put monad is strict. so if you have a huge amount of data to render and want to do it lazily, some care is needed.
09:30:08 <mgsloan> jfischoff: is System.Posix.Process.getProcessID what you want?
09:30:12 <jfischoff> yes
09:30:20 <jfischoff> thank you!
09:30:29 <mgsloan> welcome!
09:32:51 <trap_exit> ping
09:46:08 <amf> im having trouble getting my parser to play nicely with bytestring and reading a file line by line http://lpaste.net/109000
09:46:20 <amf> code and error included in lpaste
09:47:13 <amf> i cant read the whole file into memory due their potential size
09:47:24 <josephle> I would like to thank whoever did ghcformacosx, you are a hero.
09:48:00 <fizbin> yitz: Looking at Data.Binary.Put, I see the issue that it doesn't seem to support a key point of my use case, that is, that the binary file contains forwards and backwards references to other things in the file, and so needs two passes: one to determine where everything is, and a second to then fill in references and actually make ByteStrings.
09:48:26 <ChristianS> amf: you're confusing lazy and strict bytestrings
09:48:58 <amf> ChristianS: i realize that, but i cant come up with the proper way to do it
09:50:53 <fizbin> amf: Try using (map (parseLine . BL.toStrict) (BL.Lines contents))
09:51:04 <fizbin> Where you have your map now.
09:51:51 <fizbin> Or apply BL.toStrict inside parseLine.
09:52:11 <fizbin> @type sum
09:52:12 <lambdabot> Num a => [a] -> a
09:52:28 <fizbin> Also, you have a second issue.
09:53:05 <fizbin> What do you intend this expression to give you? foldl' sum 0 (map parseLine (BL.lines contents))
09:53:39 <fizbin> Because parseLine outputs "Int", so (map parseLine (...)) output [Int]
09:54:27 <amf> id like to see a count of how many lines were parsed successfully
09:54:44 <amf> adding toStrict caused "cannot construct the infinite type"
09:54:59 <fizbin> But then you don't want to foldl' "sum" over that. You either want to use "(+)" or you want no foldl'
09:55:10 <fizbin> And then WTF are you doing taking "length" of that ?
09:55:21 <amf> that was a typo from a previous attempt
09:55:47 <fizbin>  print $ sum (map (parseLine . BL.toStrict) (BL.lines contents))
09:55:58 <fizbin> Just replace the line with that.
09:56:23 <orion> hm
09:56:42 <amf> ok thanks that worked. running now (how exciting!)
09:57:05 <fizbin> The "cannot construct the infinite type" was likely the compiler trying to make sense of your use of "sum" with "foldl'"
09:57:41 <yitz> fizbin: it might be a good idea to have an intermediate data type that represents all of the data that needs to be rendered, including the references. then binary can render it for you.
09:58:35 <orion> I am using io-streams to generate an InputStream and OutputStream on a socket. I am able to read from the InputStream, but I find myself unable to specify exactly how many bytes to read. Does anyone know how to do this?
09:58:59 <fizbin> You either wanted just "sum" (as I showed) or equivalently " foldl' (+) 0 ".  Using "foldl' sum 0" is going to cause the compiler to torture itself.
10:00:10 <yitz> fizbin: fortunately for the compiler, it has the type checker to shield it from such torture.
10:00:31 <fizbin> yitz: Then I essentially get back what I have now. I suppose instead of "ByteString", I could have my "make the binary" function return a Put, but I'm not really clear on what that'd get me.
10:01:58 <yitz> fizbin: the Put monad is great for specifying bit layouts cleanly, according to spec. and it has convenient functions for rendering binary floats and integers with whatever endieness you need.
10:03:08 <fizbin> True, I did like that it already had those. In my current project, I only ever need 16-bit little endian quantities, but I can see how that would be useful.
10:03:19 <amf> fizbin: thanks again! got my program working as expected
10:06:03 <fizbin> yitz: Huh. It might be nice to be able to lazily walk a list of [BinaryPiece] and, when I encounter a reference that isn't resolved yet, walk ahead only as far as needed, working out length along the way. I'm not sure how to do that lazily; my current solution needs to walk all the way through once to grab all the references and then generate stuff on a second pass.
10:07:59 <yitz> fizbin: if it's not predictable, then it will be tricky. and even then, unless you have limits about how far you'll need to look ahead, you may not get any guarantee that it will be faster than the simple way of two traversals.
10:08:59 <Shamar> anyone using SFML here?
10:09:09 <fizbin> Well, it essentially will be two traversals, but I guess what I'm noticing is that I don't need to finish one of the traversals before starting the second.
10:14:13 <Shamar> what does it means when ghc complains about a missing symbol whose name starts with __imp__
10:14:15 <Shamar> ?
10:19:23 <NemesisD> is this something I can do without lots of boilerplate? there's a type Parser i a, Parser i is an instance of Monad, i want to add a phantom type a-la newtype Parser e i a = Parser i a, but i want all of its instances for free
10:19:50 <NemesisD> but it complains about not being able to deriving instances even with "cunning" newtype deriving
10:23:17 <kini> should I expect `cabal install -j` to ever fail where just `cabal install` would have succeeded?
10:23:51 <NemesisD> oh nm i actually could do what i was doing
10:24:23 <carter> kini: package level parallel or ghc level parallel?
10:25:05 <kini> I don't know, whatever "-j" does (I thought it was package level parallel)
10:25:49 <stolaruk> What happens under the hood when I have an IntMap in a TVar and I read the TVar? Do I get a complete copy of the original IntMap?
10:26:01 <ChristianS> kini: why do you use if it you don't know that it does?
10:26:32 <kini> ChristianS: who said I'm using it? :)
10:28:10 <kini> in any case, sometimes I have occasion to try to hack on code that other people have written, in which case I am sometimes forced to be "using" something which I don't understand
10:28:10 <kini> and that's often exactly when I need to find out more about said thing. Isn't that reasonable?
10:29:36 <jfischoff> stolaruk: what do you mean by original IntMap?
10:29:52 <stolaruk> jfischoff: I mean the IntMap that is inside the TVar
10:30:48 <carter> kini: -J will always work on a clean build
10:30:55 <jfischoff> jfischoff: reading doesn’t cause a copy operation to occur if that is what you are wondering
10:31:19 <ChristianS> kini: well if you don't use -j i needed worry about if failing ;) besides, i don't use it either and so i know just as little about it as you.
10:31:31 <carter> if you have a build failure because of missing dyn_o or whatever, do cabal clean ; cabal build
10:31:33 <carter> then things will work
10:31:44 <carter> -j will always work correctly for cabal install foo
10:32:05 <carter> its when you're actively editing rebuildsing and occasionally killing bulids, you'll have funny things hapeppn
10:32:44 <kini> I see, thanks...
10:33:03 <kini> but now that I look more closely this cannot be related to -j since -j is not even used in this portion of the build process, it looks like
10:33:47 <kini> afaik this should be running completely from scratch every time. Strange
10:34:42 <merijn> stolaruk: "a complete copy" <- you mean a reference?
10:34:54 <merijn> stolaruk: IntMaps inside TVars are still immutable...
10:34:58 * hackagebot apiary 0.15.0 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.15.0 (HirotomoMoriwaki)
10:35:00 * hackagebot apiary-logger 0.11.3.2 - fast-logger support for apiary web framework.  http://hackage.haskell.org/package/apiary-logger-0.11.3.2 (HirotomoMoriwaki)
10:35:02 * hackagebot apiary-persistent 0.13.1.1 - persistent support for apiary web framework.  http://hackage.haskell.org/package/apiary-persistent-0.13.1.1 (HirotomoMoriwaki)
10:35:29 <stolaruk> jfischoff: That's good, but I'm curious how that can be the case. If I read the TVar and get the IntMap inside of it, then I have an immutable IntMap. Another thread might then update the IntMap inside the same TVar. But the IntMap I got from my read operation won't be changed, I think. Since such a thing can happen, how can it be that the read operation didn't give me a copy of the IntMap in the TVar?
10:36:19 <fryguybob> stolaruk: Only the reference to the IntMap (the TVar) is mutated.
10:36:24 <merijn> stolaruk: No, another thread might never update the IntMap inside the TVar
10:36:48 <merijn> stolaruk: Another thread may put a new IntMap inside the TVar, but the old one can never change
10:37:09 <levi> Updating an IntMap means making a new IntMap with some shared references with the original one.
10:37:15 <merijn> TVars/MVar/etc don't change the rules of haskell, all values are still immutable
10:37:42 <stolaruk> Hmm ok.
10:37:44 <levi> So if another thread writes a new IntMap to the TVar before you get a chance to, your transaction will have to re-run.
10:37:48 * jfischoff waves at fryguybob
10:38:14 <fryguybob> jfischoff: Hi.  Hope all is well with you!
10:38:30 <jfischoff> likewise are you still working on htm stuff?
10:38:59 <fryguybob> jfischoff: Yeah, have a plan for my thesis work to keep working on it.
10:39:03 <stolaruk> Are operations that write to the TVar "expensive"?
10:39:11 <jfischoff> that’s awesome
10:39:23 <fryguybob> stolaruk: In some respects yes.
10:39:59 * hackagebot apiary-websockets 0.11.5 - websockets support for apiary web framework.  http://hackage.haskell.org/package/apiary-websockets-0.11.5 (HirotomoMoriwaki)
10:40:01 * hackagebot apiary-cookie 0.13.1.1 - Cookie support for apiary web framework.  http://hackage.haskell.org/package/apiary-cookie-0.13.1.1 (HirotomoMoriwaki)
10:40:03 * hackagebot apiary-clientsession 0.13.2.1 - clientsession support for apiary web framework.  http://hackage.haskell.org/package/apiary-clientsession-0.13.2.1 (HirotomoMoriwaki)
10:40:03 <fryguybob> stolaruk: But if there is not much contention it can be much cheaper then taking a lock and writing to an IORef.
10:40:05 * hackagebot apiary-authenticate 0.14.1 - authenticate support for apiary web framework.  http://hackage.haskell.org/package/apiary-authenticate-0.14.1 (HirotomoMoriwaki)
10:40:07 * hackagebot apiary-eventsource 0.11.6.1 - eventsource support for apiary web framework.  http://hackage.haskell.org/package/apiary-eventsource-0.11.6.1 (HirotomoMoriwaki)
10:40:30 <orion> Anyone know how to read a specific number of bytes from an io-stream InputStream?
10:41:41 <orion> Oh, bah! https://hackage.haskell.org/package/io-streams-1.1.4.6/docs/System-IO-Streams-ByteString.html -- readExactly
10:41:47 <stolaruk> Let's say I have a record data type that contains 5 different IntMaps. I wrap the data type in a TVar. Now I want to update a single record in just one of the IntMaps. So I read the TVar, update my record, and write the TVar. Does this incur much overhead due to memory management?
10:41:58 <orion> http://www.haskell.org/hoogle/?hoogle=readExactly -- No results found. Hoogle lies!
10:42:40 <fryguybob> stolaruk: It is very difficult to reason about the performance costs of concurrent programming by looking at parts in isolation.
10:43:24 <stolaruk> fryguybob: Yeah this is my first time writing a concurrent server and I'm having a very hard time figuring out how to best approach it
10:43:56 <timmy_tofu> Does anyone know how and where to add a ghc-mod GHC flag to set a CPP flag in ghc-mod-vim? That is, I want the command executed to be ghc-mod -g -DDEVELOPMENT blah blah blah when ghc mod is run.
10:43:58 <fryguybob> stolaruk: I would approach it by making it correct first, then benchmarking and finding bottlenecks.
10:44:11 <jfischoff> stolaruk: I find IO dwarfs the STM stuff for servers so I would just write it
10:44:16 <timmy_tofu> I've tried adding it to l:opts in autoload/ghcmod.vim various ways, but to no avail
10:44:42 <timmy_tofu> There's a b:ghc_mod_options variable as well, but I don't want to do this on a buffer-by-buffer basis, and I haven't tried to see if that even works anyways
10:44:43 <fryguybob> stolaruk: What jfischoff said :D
10:45:09 * hackagebot apiary-purescript 0.14.0.1 - purescript compiler for apiary web framework.  http://hackage.haskell.org/package/apiary-purescript-0.14.0.1 (HirotomoMoriwaki)
10:45:36 <stolaruk> fryguybob: Presently I have the situation described above, with a record type and a bunch of IntMaps as the records; I am finding it would be much easier to write my code where I have the entire record data type inside a TVar as opposed to each individual IntMap in it's own TVar (in which case the record data type has records of IntMaps inside TVars).
10:46:06 <stolaruk> But I don't know if that would be a bad idea from the standpoint of concurrency
10:46:17 <fryguybob> stolaruk: That sounds great.  Do what is easy and correct.
10:46:36 <stolaruk> fryguybob: Yeah ok. I can see how IO bottlenecks would darf STM bottlenecks
10:46:47 <stolaruk> that makes sense
10:47:20 <spopejoy> \msg lambdabot
10:47:31 <fryguybob> stolaruk: If you do find it to be a bottleneck and it makes sense to make it more fine-grained, having the code already there will make it easier to see how much of a change that is.
10:47:59 <stolaruk> fryguybob: Yeah, ok. I do feel like I am getting overly involved in optimising my code prematurely
10:48:06 <stolaruk> I have that sense
10:48:11 <stolaruk> I tend to do that :)
10:48:15 <fryguybob> :D
10:49:23 <stolaruk> Awesome, thanks for the help fryguybob, merijn, jfischoff
10:49:36 <fryguybob> stolaruk: No problem.
10:57:38 <Shamar> what's the current best practice for safe resource management? ResourceT? bracket?
10:59:09 <stolaruk> Shamar: The bracket family of functions is nice. Exception handling can be complicated
10:59:17 <stolaruk> especially when working with multiple threads
10:59:48 <Shamar> I've seen also a pipe package
11:00:31 <Shamar> but, currently I feel pipes' combinators ackwards
11:00:33 <stolaruk> pipes and conduit are popular
11:01:01 <ReinH> Conduit focuses more on resource management than pipes
11:02:15 <Shamar> I have a set of FFI bindings that requires explicit calls to destroy/free
11:02:41 <merijn> Shamar: Look at pipes-safe for things that need exception safe resource allocation/freeing
11:02:43 <Shamar> (FFI bindings to C bindings to a C++ library)
11:03:20 <solidus-river> collections of wires are messin with me pretty hard
11:03:39 <solidus-river> everyway i look at it the arrow abstraction of the wires gets very very messy once you start dealing with collections of wires
11:04:15 <solidus-river> Shamar: look up marshaling and Store
11:04:35 <darthdeus> how can I do like a conditional in parsec? for example     do { res <- parser1;  if res then return res else parser2 }
11:04:41 <Shamar> merijn, pipe-safe are ok, but in general I can't feel pipes' program readable... maybe I just need to study and use them more...
11:04:43 <darthdeus> and i dont want <|>
11:04:48 <darthdeus> i want to do some conversion to the result beforei  return it
11:05:08 <OldTimes> I need help
11:05:10 <Shamar> but that IO in each type looks... strange
11:05:22 <OldTimes> I'm reading "learn you a haskell right now"
11:05:32 <solidus-river> OldTimes: thats a good one
11:06:02 <OldTimes> the problem is that type declarations such as "addThree :: Int -> Int -> Int -> Int" don't work
11:06:15 <OldTimes> I'm guessing they need a word behind them, just like assignments need "let"
11:06:21 <OldTimes> but what is it
11:07:01 <solidus-river> oldtimes, i'm confused, could you make a paste of what they dont work for?
11:07:19 <Trollinator> > addThree :: Int -> Int -> Int -> Int
11:07:20 <lambdabot>  Not in scope: ‘addThree’
11:07:29 <Shamar> solidus-river, googling for "haskell marshalling" don't lead me to what I need
11:07:34 <merijn> OldTimes: Are you writing in ghci?
11:07:40 <OldTimes> yes
11:07:46 <merijn> OldTimes: ghci won't let you write types on a separate line
11:07:48 <Trollinator> let { addThree :: Int -> Int -> Int -> Int; addThree a b c = a + b + c }
11:07:50 <Trollinator> > let { addThree :: Int -> Int -> Int -> Int; addThree a b c = a + b + c }
11:07:52 <lambdabot>  not an expression: ‘let { addThree :: Int -> Int -> Int -> Int; addThree a b...
11:07:55 <Shamar> may be I'm searching the wrong  things
11:08:06 <Trollinator> oops
11:08:21 <OldTimes> oh
11:08:26 <merijn> OldTimes: I always prefer editing in a text editor and loading the file into ghci. You can use ":l files.hs" to load an entire file into ghci and ":r" to reload it with new changes
11:08:29 <Trollinator> that works in GHCi though.
11:08:33 <OldTimes> thank you, merijn
11:08:37 <solidus-river> OldTimes: http://lpaste.net/109006
11:08:39 <OldTimes> and trollinator, too
11:08:48 <Trollinator> you're welcome
11:09:17 <Trollinator> OldTimes: are you aware of the relationship between braces and indentation?
11:09:20 <solidus-river> oh, merijn answer is more right
11:09:28 <merijn> OldTimes: ghci isn't quite the same as writing haskell in files yet, especially for things like multiline function definitions
11:10:00 <Trollinator> yes… you need to use braces for that.
11:10:26 <Trollinator> of course that becomes ugly very quickly.
11:13:21 <solidus-river> Trollinator: you mean it becomes lisp?
11:13:36 <Trollinator> no.
11:13:47 <solidus-river> :P
11:20:50 <d-snp> hi :)
11:22:08 <d-snp> I'm designing a game engine, and it's got a central state object, that has entities, components and systems, the entities are basically integers, the components are records, and the systems are functions that get called by each other
11:22:45 <d-snp> a system will be able to access the entities and components, and add new ones as well as trigger systems and adding systems
11:23:02 <d-snp> would these systems run in a monad?
11:23:08 <d-snp> like a monadtransformer kind of thing?
11:23:39 <Fuuzetsu> It could.
11:24:13 <stolaruk> d-snp: If you end up using the State monad and IO (which you might), then probably
11:24:14 <d-snp> I've done something like this before in another pure functional programming language, and in that one every system would make changes to a system record, and return that record at the end for the next system call to use
11:24:29 <d-snp> it had no monads
11:24:38 <stolaruk> d-snp: What language?
11:25:01 <d-snp> a miranda clone
11:25:18 <d-snp> I guess haskell is a miranda clone too P
11:25:19 <d-snp> :P
11:25:22 <danilo2> Hello! Is there any flag in GHC to silent warnings about No explicit implementation for
11:25:25 <danilo2> ?
11:26:16 <mwhit> -fno-warn-missing-methods
11:26:27 <mwhit> that tends to be a pretty important warning though
11:27:03 <dfeuer> Always warn for missing methods and incomplete patterns.
11:27:17 <dfeuer> I don't know why the incomplete pattern warning isn't the default.
11:27:28 <mwhit> yeah it's probably the single most useful one
11:29:24 <d-snp> anyone can recommand a tutorial about monad transformers?
11:30:06 <dfeuer> d-snp, maybe I could if I understood monad transformers. They're wonky.
11:30:07 <merijn> d-snp: I think the best way to approach it is just implement one yourself :)
11:30:24 <Th30n> d-snp: AllAboutMonads maybe, on wiki.haskell ?
11:30:27 <merijn> d-snp: Did you ever implement State as homework/exercise? :)
11:30:58 <Trollinator> http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
11:30:59 <merijn> If not, start with that, then generalise to StateT, it's an enlightening exercise :)
11:31:17 <d-snp> no, we had absolutely no monadic stuff in the univ course
11:31:29 <enthropy> danilo2: -fno-warn-missing-methods ? ghci can tab complete those thing
11:31:42 <merijn> d-snp: ok, let me write down some types for you
11:31:44 <enthropy> as in you type :set -fno-warn-<tab>, and there's a big list
11:31:46 <danilo2> enthropy: ahh ok, thank you! :)
11:31:49 <d-snp> cool thanks merijn :)
11:33:48 <merijn> d-snp: hmm, I need to run for lunch, I'll send you a lambdabot message when I get back'
11:34:17 <d-snp> merijn: no problem, I'll read some theory in the meanwhile
11:34:47 <dfeuer> d-snp, all I know about monad transformers is that you're not supposed to use the ListT from the monad transformer library. There are at least two alternatives that are considered better.
11:35:43 <c_wraith> Huh.  The docs for optionMaybe in http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Combinator.html are kind of misleading: "optionMaybe p tries to apply parser p. If p fails without consuming input, it return Nothing, otherwise it returns Just the value returned by p."
11:35:53 <c_wraith> What if p fails after consuming input?
11:36:06 <d-snp> a friend lent me his Haskell & Yesod book, and it tries to explain a monad transformer, but it got real complicated real fast :P
11:36:08 <c_wraith> Does optionMaybe fail in that case? or does it still return Nothing?
11:36:36 <mwhit> *using* transformers is a good bit easier than *implementing* transformers or understanding how they work under the hood
11:36:39 <mwhit> most of the time
11:37:00 <c_wraith> Heck.  *using* transformers is easier than understanding monads themselves.
11:37:25 <d-snp> mwhit: yeah, I think the effect is basically that you get handy functions that work on a state
11:37:28 <mmachenry> Does anyone know how to force cabal to understand where postgres 0.9 is on my system and not look for postgres 0.8? I am getting unknown symbol errors. I set my path to have 0.9's pg_config favored but that doesn't work
11:37:34 <c_wraith> Because just using them doesn't require grasping the higher-kinded type stuff going on.  Not really, anyway.
11:38:11 <josephle> the "just use it" philosophy is a good one :)
11:38:23 <d-snp> haha yeah, but I think I have to design one :P
11:38:56 <d-snp> to make this thing nice and abstract anyway..
11:39:20 <dfeuer> That's an odd footnote:  "Sections ?? and ?? are added by Wei Hu, Feb 2008. Unfortunately the bib file is missing, so are the references."
11:39:23 <kvelicka> Hi. Say I have data Dat = One | Two. Is it possible to pattern match on Maybe Dat in a way where I check for all three options (Just One, Just Two and Nothing). Or do I have to have nested `case x of` statements?
11:39:45 <dfeuer> kvelicka, yes, you can nest the matching.
11:40:30 <dfeuer> foo (Just One) = whatever; foo (Just Two) = whoever; foo Nothing = however
11:41:35 <kvelicka> dfeuer: what if Dat was a recrod?
11:41:48 <josephle> d-snp: it depends, maybe what you want can be done by combining transformers
11:41:57 <dfeuer> kvelicka, it makes no difference.
11:42:14 <dfeuer> You can nest patterns as deeply as you like.
11:43:40 <kvelicka> thank you
11:43:45 <dfeuer> f [a,b,Just (Left (c, Node d _ _))]=(a,b,c+d) if you like.
11:47:37 <c_wraith> So.  It seems optionMaybe actually fails if its argument consumes input.  It'd be nice if that was documented.
11:47:48 <c_wraith> Freaking magical behavior.  I really don't like parsec.
11:48:32 <josephle> is there anyone you can contact to get the documentation updated?
11:48:41 <c_wraith> I'm sure there is.
11:48:47 <c_wraith> But I'd rather tell people not to use parsec.
11:49:31 <c_wraith> Use a parser combinator lib that actually understands composability instead.
11:51:12 <josephle> fair enough
11:51:26 <mmmm_> c_wraith: That is documented..
11:52:23 <c_wraith> mmmm_: it's documented in optional, but not in optionMaybe or option
11:53:00 <mmmm_> "optionMaybe p tries to apply parser p. If p fails without consuming input, it return Nothing, otherwise it returns Just the value returned by p."
11:53:20 <c_wraith> mmmm_: totally missing from that description is what happens if p fails after consuming input
11:53:31 <c_wraith> mmmm_: there are three cases, the documentation discusses 2 of them
11:53:49 <sm> disaster! throw out that library at once
11:54:13 <mmmm_> The value returned by p is fail no?
11:54:33 <c_wraith> mmmm_: no. failure is not a value returned, in the monadic sense.
11:55:15 <RyanGlScott> Are there any fixed-precision Integral types that use more than 8 bytes of space?
11:55:42 <c_wraith> I don't think so.
11:55:53 <RyanGlScott> Good to know.
11:56:04 <c_wraith> Maybe somewhere obscure on hackage
11:56:10 <mmmm_> so which library do you suggest to people?
11:56:38 <n-dolio> I'm pretty sure there's some crypto-related package that has Word256 and stuff.
11:57:09 <vanila> http://www.pl-enthusiast.net/2014/08/05/type-safety/ fantastic post by Bob Harper there
11:57:20 <latk> I've got two executables, a server, and something that periodically generates the data for the server to use. How would people recommend I run the executable? Call it from the server, cron or something?
11:57:21 <vanila> He's always right on the mark :)
11:57:33 <qnikst> RyanGlScott: will Data.Fixed from base match your needs?
11:57:46 <latk> Also, they need to share some info (e.g. database path) - what is the best way to share this info ?
11:58:25 <qnikst> ops it's for real
11:58:48 <c_wraith> mmmm_: uu-parsinglib actually provides composability, so if people want elegance, I tell them to use it. If they want efficiency and suffering, I tell them to use attoparsec. At least with attoparsec, you know what you're getting into up front.
11:59:07 <daneeklu>  does using TH, for instance "makeLenses", dictate the order in which functions/types must be defined in a file?
11:59:17 <mwhit> yes
11:59:20 <c_wraith> daneeklu: to some extent, yes
11:59:23 <RyanGlScott> qnikst: I don't need them, I just need to know what the largest possible size someone could (realistically) throw at me.
11:59:45 <mmmm_> c_wraith: Have you read the uu-parsinglib documentation..?
11:59:49 <c_wraith> mmmm_: yes
11:59:53 <sm> latk: if you want to be fancy/integrated, maybe http://www.yesodweb.com/blog/2014/08/announcing-auto-update
11:59:56 <daneeklu> what is the reason for this? linear walking of TH down the file?
12:00:24 <latk> sm: Hah, cool. That might work..
12:00:34 <mmmm_> c_wraith: I might be more for it if the documentation was there
12:00:35 <latk> sm: Do you know of any disadvantage to doing itthis way?
12:00:51 <sm> it's brand new, otherwise no
12:01:24 <enthropy> daneeklu: I think you can mostly pretend that everything above makeLenses is a module imported into stuff below it
12:01:32 <edwardk> daneeklu: ghc basically divides the file into 'what happened above the splice and what happened below the splice, and each of those bands has to typecheck in isolation
12:01:57 <latk> Cool, I'll have a look. Thanks!
12:02:00 <daneeklu> got it, thanks for the answers!
12:02:08 <c_wraith> mmmm_: Other than approximately one issue with eof, the library is so simple that there just isn't that much to document.
12:02:43 <sm> np
12:04:26 <darthdeus> any tips for diagnosing a linker error? it only appears when i do  "cabal repl hspec", though if i do "ghci -package hspec" and load my test files and run them, i dont get any errors
12:04:48 <c_wraith> mmmm_: but I also read the paper, which might be why I think it's simple.  The paper is a full tutorial.
12:05:33 <darthdeus> also tried a clean build but didn't help
12:05:48 <sm> darthdeus: got all your files listed in the cabal file ?
12:06:56 <c_wraith> edwardk: what does trifecta do with failing parsers that have consumed some input?
12:07:11 <mmmm_> Same as parsec c_wraith
12:07:14 <mmmm_> as far as I know
12:07:19 <edwardk> they fail all the way out. if you don't want that, use try
12:07:27 <darthdeus> SmileyKeith: lol no, you're right that fixes it :) i was missing a module in there
12:07:38 <sm> np
12:07:45 <merijn> d-snp: Here: http://lpaste.net/109008
12:08:14 <merijn> d-snp: Try implementing those functions and the Monad instance, once you've implemented MyState, try figuring out how to do it with MyStateT
12:08:36 <merijn> d-snp: You can also implement Functor/Applicative instances if you feel like the extra challenge :)
12:09:57 <c_wraith> edwardk: as in, <|> and mplus don't even catch that situation?  I think that's actually an improvement over parsec
12:10:15 <mmmm_> c_wraith: You actually think the uu-parsinglib documentation is good? Barely any functions are given descriptions and the only other documention is the paper
12:10:20 <edwardk> <|> catches only the 'unconsumed case' just like in parsec
12:11:36 <c_wraith> mmmm_: it's as good as it needs to be.
12:12:53 <mmmm_> c_wraith: ... I have nothing more to say, there clearly isn't enough documentation
12:13:34 <c_wraith> mmmm_: I can use the documentation to write a working parser.  How much more does there need to be?
12:15:12 * hackagebot tidal 0.4.10 - Pattern language for improvised music  http://hackage.haskell.org/package/tidal-0.4.10 (AlexMcLean)
12:15:39 <c_wraith> darn, tidal isn't using changelogs.
12:17:39 <guesting> I am trying to use Parsec with Data.Text--it seems to take IN text ok, but it won't return text! As in, manyTill anyChar eol returns a string, not a Text! Is there a way to have it return text?
12:18:16 <Cale> guesting: You could pack the resulting String
12:18:32 <guesting> Cale: Yes, but I want to avoid that--it's usually pretty slow
12:18:50 <merijn> guesting: Parsec doesn't let you parse Text that way, no. It's a bit sad
12:18:58 <merijn> guesting: The good news is that attoparsec does allow that
12:19:15 <guesting> hmph
12:19:25 <guesting> alright, well as long as I wasn't missing something
12:19:30 <guesting> thanks guys!
12:19:55 <Cale> guesting: My guess as to why it does that is that it still has to look at each character, so it's natural to end up with a String that gets built up recursively.
12:20:06 <merijn> guesting: Might wanna check out attoparsec, it is nearly identical to parsec (well, it has slightly less builtin special combinators, but the high level is the same)
12:20:33 <merijn> guesting: It has things like "takeWhile :: (Char -> Bool) -> Parser Text" in Data.Attoparsec.Text
12:21:12 <merijn> Cale: Sure, but attoparsec, for example, inspects each character and when it finds the end cuts of the entire chunk of Text in one go, which avoids the intermediate list allocation and Text building
12:21:23 <guesting> That's pretty cool, but I'm pretty new to parsing with parsec so I'll stick with it for a while until I feel comfortable enough to optimize it
12:22:02 <merijn> guesting: I still recommend taking a look at the API for attoparsec for like 30s, I think the types are actually simpler than parsec in many cases :)
12:22:27 <guesting> merijn: I'll check it out, thanks
12:23:14 <c_wraith> guesting: yeah, I was just saying that I'd recommend attoparsec over parsec for unrelated reasons. :)
12:23:15 <etrepum> I find that attoparsec has more of the combinators I want to use already there, and I like not having to use 'try' all over the place
12:24:09 <eacameron> noob question: a >>= f will work with f having one argument, how can I do (action1, action2) >>= f2 where f takes 2 arguments?
12:25:06 <Bor0> it's still one argument, (action1, action2) is a pair
12:25:25 <mwhit> i'm guessing he meant the actual 2-argument case, not a literal tuple
12:25:36 <Cale> eacameron: action1 >>= \x -> action2 >>= \y -> f2 x y
12:25:49 <Cale> eacameron: Or liftM2 f2 action1 action2
12:26:06 <Cale> eacameron: Or just use do-notation:  do x <- action1; y <- action2; f2 x y
12:26:12 <geekosaur> was gonna say, that's liftM2 / applicatives
12:26:22 <Cale> er, sorry, liftM2 isn't really the same
12:26:28 <Cale> You'd need to join
12:26:54 <Cale> (because the result of executing the liftM2 will be an action then, and you'll want to run that as well)
12:27:55 <eacameron> Cale: that's what I was finding. liftM2 lifts too much
12:28:16 <eacameron> it feels like a job for applicative but I'm not sure how to do it
12:28:22 <Cale> eacameron: But just use do-notation
12:28:55 <Trollinator> How do I get GHCi to display type names without the full package prefix?
12:29:05 <Cale> eacameron: v <- x inside of a do-block means "execute the action x and call its result v", so if x :: M t, then v :: t
12:29:18 <Trollinator> i. e. Parser Text () instead of attoparsec-0.12.1.1:Data.Attoparsec.Internal.Types.Parser Data.Text.Internal.Text ()
12:30:09 <c_wraith> Trollinator: make sure you've imported something that exports the Parser type in your current ghci session
12:30:28 <monochrom> if you get the "attoparsec-0.12.1.1" part, that means you possess multiple versions of attoparsec. it is the only reason why ghc has to show it for disambiguation.
12:31:26 <eacameron> Cale: thanks, I'll stick with plain old do notation.
12:32:32 <merijn> Or just "f2 <$> action1 <*> action2"
12:32:37 <merijn> oh, no
12:32:41 <merijn> Same problem as liftM2
12:32:45 <Cale> right
12:32:50 <c_wraith> because that's the same as liftM2
12:32:50 <Cale> It can be nice to have some concise thing using fancier combinators sometimes, but if you're confused about how to do that, chances are pretty good that it won't be clearer :)
12:33:25 <eacameron> Cale: brevity over clarity...always. ;)
12:33:43 <c_wraith> eacameron: in that case, I recommend looking into the j language. :P
12:33:49 <monochrom> what is clarity? is there an objective definition?
12:34:13 <Trollinator> no.
12:34:21 <eacameron> it's that thing that people use to make themselves think their code is good
12:34:22 <aarvar> java is clarity
12:34:26 <Cale> Well, and clearer or not, if you expect to have to change the code, do-notation tends to be a little more flexible
12:35:18 <mmachenry> Does anyone know how to get code coverage data easily with an HSpec test suite? I have a cabal file and tried adding -fphc to the ghc flags in the test-suite but that does not create a tix file that I can find.
12:35:25 <DanielDiaz> is Data.List.splitAt O(n)?
12:36:20 <Cale> Of course, clarity is relative to the observer :)
12:36:44 <DanielDiaz> I guess so... what I am actually wondering is if the list is half-traversed twice
12:36:59 <Cale> DanielDiaz: It's traversed once
12:37:19 <DanielDiaz> Cale: nice, thank you.
12:37:21 <RyanGlScott> I'm having trouble disambiguating a multi-parameter typeclass: http://lpaste.net/109010
12:37:43 <Cale> RyanGlScott: You could add a functional dependency
12:37:53 <c_wraith> RyanGlScott: that class cannot work
12:37:57 <Cale> RyanGlScott: class Wat a b | a -> b, b -> a where ...
12:37:59 <RyanGlScott> Cale: Ooh, I hadn't thought of that. Let me try that out.
12:38:20 <Cale> You'll need dependencies in both directions
12:38:31 <Cale> or else one of those two methods will always be ambiguous
12:38:34 <merijn> This doesn't seem like a very useful class, though
12:39:25 <RyanGlScott> Cale: That did the trick. Thanks!
12:41:40 <c_wraith> RyanGlScott: what do you get out of that class that you wouldn't get out of 2 classes instead, though?  Did you elide some other definition that used both type variables?
12:42:56 <RyanGlScott> c_wraith: That was a dumbed down version of the code I was actually using. It now looks something like:
12:43:23 <RyanGlScott> class HasPort a port | a -> port where getPort :: a -> port
12:43:36 <RyanGlScott> I then have instances with different port types (Word8, Word16, etc.)
12:43:37 <c_wraith> RyanGlScott: well, it clearly was cut down.  I was just hoping that the part you cut out was a reason for actually using an MPTC
12:43:49 <RyanGlScott> I hope so :)
12:43:58 <RyanGlScott> I can't think of a better way of expressing it
12:45:44 <Cale> RyanGlScott: You could also use an associated type for that
12:45:59 <Cale> class HasPort a where type Port a; getPort :: a -> Port a
12:46:39 <RyanGlScott> Cale: What's the advantage of using that over parametric polymorphism?
12:46:59 <c_wraith> It's not parametric polymorphism in a class
12:46:59 <Cale> You mean over multiparameter type classes and functional dependencies?
12:47:10 <RyanGlScott> Cale: Yes.
12:47:19 <c_wraith> If it only works for types explicitly defined in an instance, it's not parametric. :P
12:47:24 <Cale> None really, it's just another notation for the same in this case
12:47:44 <Cale> It gives you a name for the mapping between types and their port types.
12:47:56 <Cale> Which can make reading some types a little easier
12:48:24 <Cale> But sometimes it can result in things being a little less concise as well, if you have many occurrences of the same "Port a" occurring in a type
12:48:58 <RyanGlScott> I was wondering if there was anything you could do with associated types that you couldn't do with the previous approach, like this Scala example http://stackoverflow.com/a/20071543
12:49:18 <RyanGlScott> But that may only apply to object-oriented languages.
12:49:20 <c_wraith> RyanGlScott: there actually *is* something you can do with associated types that you can't otherwise.
12:49:40 <c_wraith> RyanGlScott: and that's using the type family explicitly
12:49:54 <Cale> I think they interact with GADTs better, if I recall correctly.
12:49:55 <saml> how can I display fraction to 2 decimal points?  1.90523423 => 1.91
12:50:22 <saml> it is better to get Double truncated to the closet 2 decimal points
12:50:23 <Cale> They're slightly less general than functional dependencies in some ways (though I've only ever seen contrived examples of that)
12:50:30 <c_wraith> > printf "%2d" 1.90532423 :: String
12:50:33 <lambdabot>  "*Exception: printf: bad formatting char 'd'
12:50:38 <Cale> But their interaction with other extensions is easier to work out for that reason
12:50:43 <c_wraith> > printf "%2f" 1.90532423 :: String
12:50:46 <lambdabot>  "1.90532423"
12:50:46 <merijn> Cale: Well, the associated type is less brittle than MPTC
12:50:55 <saml> > printf "%.2f" 1.905232424 :: String
12:50:57 <lambdabot>  "1.91"
12:51:02 <c_wraith> I'm bad at print
12:51:02 <c_wraith> f
12:51:10 <saml> then how do I convert string to Double?
12:51:15 <saml> oh read
12:51:25 <merijn> Cale: Also, I would argue it's semantically more correct
12:51:44 <RyanGlScott> merijn: In what sense?
12:52:33 <saml> > let deci :: Int -> Double -> Double; deci n f = read $ printf "%.2f" f in deci 2 1.90534324
12:52:36 <lambdabot>  1.91
12:52:37 <merijn> RyanGlScott: With "Port HasPort a port | a -> port where getPort :: a -> port" the instance selection (i.e. which instance GHC picks) depends on the type of the port
12:53:07 <merijn> RyanGlScott: Whereas semantically the instane only depends on the 'a', which should uniquely determine the port type
12:53:12 <av> Hi everyone, I'm trying to make a cabal package for a FFI bindings that use a library shipped with the cabal package -- is that possible?  I'm at the point where I have to specify where the shared object is that I'm using through FFI (in normal ghc parameters, this would be "-Lsomething") and don't know what to do. Any ideas?
12:53:34 <merijn> RyanGlScott: The fundep enforces that property, but when I see a two parameter typeclass constraint I don't magically know such a fundep exists
12:53:39 <c_wraith> a functional dependency implicitly introduces something like a type family.  class Foo a b | a -> b means that instances create implicit functions from type a to type b.  But you can't use that function in your own type signatures - at least not easily.  With an associated type, you get explicit access to that type function.
12:54:15 <merijn> RyanGlScott: Whereas with "instance HasPort a where type Port a :: *; getPort :: a -> Port a" the constraint only has one type, so it's immediately clear the instance only depends on 'a'
12:54:22 <av> basically, is there a way of telling cabal to build including some .a or .o files in addition to the c-sources entry?
12:54:44 <RyanGlScott> Hm, I didn't realize that functional dependencies were so controversial.
12:55:06 <benzrf> fun deps!
12:55:07 <merijn> RyanGlScott: They are not controversial, I think. I just think TypeFamilies are much nicer and explicit
12:55:12 <benzrf> fun deps are fun
12:55:40 <RyanGlScott> av: I've done something like this before, but how easy it is depends on your OS and what shared objects you're using.
12:56:07 <RyanGlScott> av: Are you using your own custom shared objects?
12:56:43 <av> RyanGlScott: good to know -- I'm trying not to use a shared object if possible but would like to have it all static
12:57:20 <RyanGlScott> av: I agree. The only time I've ever had to explicitly link against a .dll involved using Visual C code.
12:57:28 <RyanGlScott> av: It's generally not enjoyable.
12:58:36 <RyanGlScott> av: (But that assumes you're using Windows)
13:00:40 <av> RyanGlScott: can you point me to an example?
13:01:12 <RyanGlScott> av: First of all, what are you using the FFI for? Your own C code? A C library?
13:02:32 <av> RyanGlScott: someone else's fortran77 code (well...) with a minimal C wrapper of my own.  I was thinking of compiling the f77 code into a .a archive and specifying the C wrapper as the c-source in cabal.
13:03:21 <Cale> merijn: Well, I suppose locally when you're reading the code, you don't know the fundep exists, but in order to be able to understand the code, you'll need to learn its definition anyway, at which point you'll become aware of the functional dependency
13:03:23 <av> RyanGlScott: it all works without cabal, but I have to specify the .a explicitly when building Haskell programs that use the library
13:04:35 <Ankhers> Is TVar the suggested way to share data between threads?
13:04:42 <merijn> Ankhers: "it depends"
13:05:00 <merijn> Ankhers: What sort of data, what sort of threads, what do you plan to do with it?
13:05:03 <benzrf> ∀∀.∀
13:05:25 <RyanGlScott> av: This sounds like something you'd need to do with a custom Cabal setup.
13:05:57 <Ankhers> merijn: I want to use a hashtable to create a whitelist to check if a URL is in said whitelist.
13:06:12 <av> RyanGlScott: no surprise there... any pointers? :)
13:06:36 <RyanGlScott> av: Here's the unfortunate part: current, cabal has an extra-lib-dirs field which allows you to specify library directories
13:06:44 <josephle> Ankhers: are you sharing the hashtable or URLs?
13:06:46 <RyanGlScott> av: But it only takes absolute directories.
13:06:47 <Ankhers> merijn: I can't use a Channel because I need it to be read from multiple times.
13:07:12 <RyanGlScott> av: This works okay with globally installed things (e.g., /usr/lib), but it's a PITA to use with custom libraries.
13:07:18 <Ankhers> josephle: the hashtable. I get a single URL in the request, and if it is in the whitelist, I need to act on it.
13:07:38 <danilo2> Hello! can we somehow in Haskell provide a type to a function which does not met the requirements in the function context, but tell the type system just to compile further? I know this sounds really wrong :)
13:07:45 <RyanGlScott> av: (There's supposed to be a ${pkgroot} variable that you can use to get around this, but it doesn't work https://github.com/haskell/cabal/issues/1317)
13:08:03 <benzrf> how is Docile.dsl_eval any different from instance_eal
13:08:04 <benzrf> *eval
13:08:14 <RyanGlScott> av: So you basically have to do it with Cabal's Setup.hs file.
13:08:16 <benzrf> oops wrong chan
13:08:49 <RyanGlScott> av: Here's the very quick-and-dirty solution I came up with: https://github.com/RyanGlScott/hermit-bluetooth/blob/master/Setup.hs
13:09:15 <mwhit> danilo2: you can use undefined
13:09:36 <merijn> Ankhers: Then (assuming you want to update the TVar from all threads concurrently) the TVar is probably a good solution yes. But it depends on how frequently the whitelist has to be updated
13:09:45 <danilo2> mwhit: no, undefined is just bottom type. I'm aksing If I can use a concrete type which just does not match to the context
13:10:02 <mwhit> what would be the difference from using undefined? it's not like it could do anythign with the concrete type anyway
13:10:07 <RyanGlScott> av: This isn't an ideal situation since it requires copying a DLL to the .cabal/bin folder. I'm not sure if that would be necessary in your case, though.
13:10:21 <Ankhers> merijn: not that often, ~10-15 minutes probably.
13:10:38 <danilo2> mwhit: like, if we get function foo :: Monad m => m a
13:10:40 <av> RyanGlScott: thanks a lot, I'll check out your code tomorrow
13:10:55 <merijn> Ankhers: Right, that should be no issue
13:10:59 <danilo2> mwhit: sorry I pressed enter by accident
13:11:15 <RyanGlScott> The sad thing is that if ${pkgroot} worked correctly, this would be 100x simpler.
13:11:37 <merijn> Ankhers: The problem with TVar's is that if you write to them any transaction reading them will fail and have to start over. But if you only update once every 10 minutes that's basically never
13:11:48 <danilo2> mwhit: like we've got function foo :: Monad m => m a -> Int . I Just want to call it like "foo Dummy" even if Dummy is not an instance of Monad - and tell GHC to be silent and does not complain there
13:12:04 <merijn> Ankhers: If you were planning to update every tenth of a second you might get performance issues due to needing to constantly restart
13:12:10 <mwhit> danilo2: right, but let's say you pass it that value... what would happen when the function is evaluated? The only thing it can do is error out. which is exactly the same as if you'd used undefined
13:12:20 <mwhit> there's no difference between what you're describing and just saying "foo undefined"
13:12:39 <danilo2> mwhit: no, imagine function like foo :: m a -> Int; foo _ = 5
13:12:55 <danilo2> mwhit: there is - because foo undefined is ambigous
13:12:55 <mwhit> well, then foo is :: a -> Int
13:13:16 <mwhit> how so?
13:13:28 <danilo2> no, try it!
13:13:47 <mwhit> try what?
13:13:48 <merijn> mwhit: It is with his type signature
13:13:56 <merijn> mwhit: GHC can't infer which monad instance
13:14:01 <mwhit> oh, that
13:14:49 <dutchie> danilo2: could you not do instance Monad Dummy where return _ = undefined etc
13:15:03 <merijn> danilo2: So change the type of foo?
13:15:48 <mwhit> so foo (undefined :: Identity ())
13:15:51 <merijn> dutchie: ಠ_ಠ ಠ_ಠ ಠ_ಠ ಠ_ಠ
13:16:25 <dutchie> merijn: it's possible I am talking utter gibberish as I'm pretty tired
13:16:42 <dutchie> but humour me and point out why that's a silly idea
13:16:56 <mwhit> doesn't solve the problem, for one
13:17:16 <danilo2> merijn, dutchie I would love to, but I cannot. This is just simplified use case. In reality I've got a datatype parametrized by polymorphic variable and I want to use it as argument to some type class function, which is illegal from the same reason. But I've got a working solution here - I'm just looking for something pretter: http://lpaste.net/109001
13:17:32 <merijn> dutchie: Because that instance would never follow the monad laws
13:17:35 <danilo2> dutchie: I can, I was just looking for something a little more general
13:17:50 <RyanGlScott> Okay, TypeFamilies question. Suppose I have class HasPort a where type Port a; getPort :: a -> Port a
13:18:01 <RyanGlScott> How do I constrain Port a to be Integral?
13:18:23 <merijn> RyanGlScott: You want the port to be polymorphic?
13:18:23 <Cale> class (Integral (Port a)) => HasPort a where ...
13:18:25 <dutchie> hmm fair enough
13:18:36 <Ankhers> merijn: Awesome. Thanks.
13:18:40 <merijn> oh, nice, Cale :)
13:18:58 <merijn> Didn't think of that :)
13:19:12 <RyanGlScott> Does that require FlexibleContexts?
13:19:40 <RyanGlScott> Hm, it does. What does that extension do?
13:20:06 <mwhit> danilo2: okay, context is good, but now i'm not really sure what you're trying to accomplish. I see the Test instance that has what you're talking about, but it's never used.
13:21:00 <Cale> RyanGlScott: It lets you have contexts that constrain things which aren't simply type variables
13:21:01 <RyanGlScott> Does it exist to allow instance syntax not permitted by Haskell 98?
13:21:14 <merijn> RyanGlScott: FlexibleContexts is because the report is overly conservative in what is allowed in constraints
13:21:24 <Cale> and yeah, it's not Haskell 98, but then, neither are type families :P
13:21:38 <merijn> Also, we're on Haskell2010 nowdays :p
13:21:39 <RyanGlScott> Is there a reason the syntax wasn't loosened in Haskell 2010?
13:21:52 <Cale> Haskell 2010 is essentially Haskell 98
13:21:56 <merijn> RyanGlScott: The committee is silli-ly conservative
13:22:21 <Cale> It made sense to be conservative with features surrounding type classes in H98
13:22:26 <RyanGlScott> merijn: I can understand that, I suppose. What does it take for an extension to become a part of the language?
13:22:33 <Cale> and it makes a certain amount of sense to keep things separated into extensions
13:22:37 <danilo2> mwhit: Ok, look here: http://lpaste.net/109011 :)
13:22:49 <Cale> H2010 standardised the {-# LANGUAGE ... #-} pragma
13:22:54 <benmachine> extensions are sufficiently convenient that no-one's really stressing about getting them standardised
13:23:01 <monochrom> I don't think the committee was silly. I think it was just in a rush.
13:23:28 <RyanGlScott> Yeah, I suppose extension standardization would only become an issue if non-GHC Haskells ever truly take off.
13:24:02 <Cale> Well, the extensions themselves can be standardised *as extensions*
13:24:26 <Cale> which lets the non-GHC implementations implement them separately as they have resources to do so
13:25:12 <RyanGlScott> So there's a list of extensions that Haskells should implement?
13:25:18 * hackagebot fastbayes 0.1.0.0 - Bayesian modeling algorithms accelerated for particular model structures  http://hackage.haskell.org/package/fastbayes-0.1.0.0 (ChadScherrer)
13:25:25 <Cale> But in any case, it'd also be silly to write a Haskell Report which describes zero of the implementations
13:25:33 <RyanGlScott> i.e., non-experimental ones?
13:25:42 <Cale> So, if we're going to change this, GHC should change first.
13:26:23 <Cale> H2010 specifies a list of extensions which must be supported iirc.
13:26:54 <Shamar> I have a linking problem with ghc: how can I debug it
13:27:00 <Cale> oh, sorry, it simply encourages support for a particular list
13:27:30 <RyanGlScott> Cale: Where is this list, for curiosity's sake?
13:27:35 <ChristianS> Cale: some former extensions are simply standard as per haskell 2010
13:27:38 <Cale> PatternGuards, NoNPlusKPatterns, RelaxedPolyRec, EmptyDataDecls, ForeignFunctionInterface
13:27:45 <Cale> ChristianS: That's also true
13:27:58 <Cale> RyanGlScott: Section 12.3
13:28:34 <RyanGlScott> Cale: Awesome, thanks.
13:28:59 <Shamar> while building a package B that depends on a package A that uses FFI, it complains about a missing symbol (actually a function) that starts with __imp__
13:29:24 <frerich> Shamar: Is that on Windows by any chance?
13:29:48 <Shamar> frerich, yes it's on windows
13:29:57 <Shamar> :-(
13:30:19 <frerich> Shamar: That sounds like a mixup between __declspec(dllexport) and __declspec(dllimport), i.e. the code you compile tries to import a symbol but the library didn’t export it.
13:30:39 <MagnusVortex> Reading that as "Final Fantasy One" yields a slightly different interperetation.
13:31:12 <RyanGlScott> MagnusVortex: I know, I hate when Garland screws up my linker.
13:31:59 <Shamar> probably, but how can I find the broken line
13:32:15 <RyanGlScott> Shamar: What is the function after the __imp__? That should give you a clue.
13:34:11 <Shamar> sfListener_setPosition (here the bug report: https://github.com/SFML-haskell/SFML-control/issues/7)
13:34:20 <frerich> Shamar: You could check the symbols exported by the DLL you try to interface with (e.g. with ‘dumpbin /exports’ ) and see whether it exports anything at all. If a lot of stuff seems to be missing, chances are that the library was built incorrectly - i.e. it lacks __declspec(dllexport); this is often added by a macro (something like ‘EXPORT’) which is #define’d to be __declspec(dllexport) or __declspec(dllimport) depending on whether a DLL is built or
13:34:57 <frerich> HSSFML-0.2.0.0.o? That sounds like MinGW :-/
13:35:19 <Shamar> it is
13:35:38 <Shamar> it is SFML build with mingw
13:36:24 <Shamar> I mean it is Haskel's SFML here https://github.com/SFML-haskell/SFML
13:36:59 <kini> networking question - I have a library whose API allows me to start a server given five port numbers on which to serve
13:36:59 <kini> is there some way to find five arbitrary free ports, which I can then pass to this API?
13:37:07 <benzrf> kini: bind to port 0
13:37:14 <benzrf> it will give you a fake port
13:37:22 <benzrf> or something
13:37:33 <kini> Hmm, I see, thanks
13:38:05 <RyanGlScott> Shamar: Unfortunately, it looks like the author uses Visual Studio to compile the SMFL C-bits. https://github.com/SFML-haskell/SFML/wiki/Installation-on-Windows
13:41:30 <Shamar> RyanGlScott, I read it (I actually use VS at work) but I can't install it at home
13:41:55 <Shamar> I supposed that with mingw I could build it nevertheless
13:42:21 <RyanGlScott> Shamar: I think it's kind of lame that the author wouldn't use MinGW (since that's what Haskell on Windows is build with), but that's just me.
13:42:41 <RyanGlScott> (Unless there's a darn good reason to use Visual Studio)
13:53:55 <ezrios> are there any good resources for learning reactive-banana?
13:56:21 <Fuuzetsu> are there ane good resources on setting up benchmarking for a program? Mainly interested in memory allocation
13:56:31 <Fuuzetsu> any*
13:59:31 <athan> Fuuzetsu: I think there's a switch that gives really basic information that you can use on calls to a function in ghci, one sec
14:01:42 <athan> Fuuzetsu: I know there's a lot more out there, but here's something I was speaking of: http://www.haskell.org/haskellwiki/Performance/GHC#Measuring_performance
14:01:43 <mwhit> set +s
14:01:44 <athan> also, threadscope
14:01:46 <mwhit> in ghci
14:01:53 <athan> derp, there you go ^
14:02:20 <mwhit> but that's just going to be a ballpark estimate probably
14:02:21 <Fuuzetsu> while that's useful, I'm looking for something a bit more automated
14:02:25 <Fuuzetsu> maybe ran as part of test-suite
14:02:39 <athan> threadscope might be a good tool for you then
14:08:32 <SrPx> Just wondering, is there a name for `foo = foldr1 (.)` ?
14:09:14 <SrPx> or `foo = foldl' (.) id`
14:10:13 <napping> I don't think there's any standard function like thta
14:10:17 <Zekka> SrPx: I don't know if there's a name but there's a Monoid instance for it
14:10:21 <athan> SrPx: I was just thinking about this with applicatives....
14:10:28 <napping> In words I'd just call it function composition
14:10:37 <Zekka> @hoogle Endo
14:10:38 <lambdabot> Data.Monoid Endo :: (a -> a) -> Endo a
14:10:38 <lambdabot> Data.Monoid newtype Endo a
14:10:38 <lambdabot> System.Posix.Terminal.ByteString EndOfFile :: ControlCharacter
14:10:39 <napping> or something like "the composition of this list of functions"
14:10:44 <SrPx> okay thanks
14:10:48 <Zekka> For Endo it's mconcat
14:11:09 <napping> foldr id (.) is probably better
14:11:09 <athan> Ahh, nice
14:11:20 <Zekka> Minding that it's a right fold, not a left fold like in your second example
14:11:33 <Zekka> it basically expands to foldr id (.)
14:11:45 <athan> ...CoEndo? :P
14:11:50 <danilo2> Hello! Is it possible to use "-fno-warn-missing-methods " as a pragma in file? I was looking into documentation right now but I havent found any related option yet.
14:11:51 <shachaf> > ala Endo foldMap [(+1),(*2)] 5
14:11:53 <lambdabot>  11
14:12:10 <SrPx> hmm
14:12:20 <napping> danilo2: I think there's a pragma for that, but it's probably recommended to put in in build settings
14:12:28 <benzrf> :t ala
14:12:29 <Zekka> shachaf: Thanks for the example.
14:12:30 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
14:12:31 <benzrf> mfw
14:12:41 <benzrf> :k Unwrapped
14:12:43 <lambdabot> * -> *
14:12:46 <danilo2> napping: why? I want it to be enabled for just one file
14:12:49 <napping> let's see, UserGuide -> 7.20 Pragmas -> 7.20.2 OPTIONS_GHC -- that's the one
14:12:58 <napping> Sure, if that's what you want
14:13:32 <__sebastian__> does something like this exists? Control.Monad.Catch.MonadThrow m => Maybe a -> m a
14:13:53 <danilo2> napping: I'm either tired or blind. Thanks!
14:14:02 <Zekka> __sebastian__: It's possible I'm misunderstanding the type but I don't see how that could be defined
14:14:35 <napping> If you only want one file either putting it a pragma or just on the command line is as well as I see to do it
14:14:48 <Zekka> __sebastian__: What would the exception be?
14:14:49 <napping> It's easier to stick in in a .cabal file or something if you wanted it for all files
14:15:08 <__sebastian__> Zekka: no idea, maybe I misunderstood my problem
14:15:18 <__sebastian__> Zekka: this funciton already exists: id
14:15:58 <Zekka> Wouldn't that be Maybe a -> Maybe a? It's not polymorphic over the type of the m.
14:16:37 <__sebastian__> Maybe is already an instance of MonadThrow
14:16:41 * benzrf e%amines MonadThrow
14:16:49 <benzrf> class Monad m => Control.Monad.Catch.MonadThrow (m :: * -> *) where Control.Monad.Catch.throwM :: GHC.Exception.Exception e => e -> m a
14:16:59 <benzrf> how about:
14:16:59 <Zekka> __sebastian__: Yes, but what I'm saying is that the type you gave is of a function that can turn a Maybe a into *any* MonadThrow
14:17:34 <Zekka> id only allows you to turn a Maybe a into a Maybe a -- while Maybe is a MonadThrow, it's not *any* MonadThrow
14:17:43 <benzrf> Zekka: wait
14:17:54 <Zekka> benzrf: What am I missing?
14:17:59 <__sebastian__> Zekka: I was looking for a save version of fromJust
14:18:11 <benzrf> yourFunc Nothing = throwM [make exception regarding emptiness here]
14:18:17 <benzrf> yourFunc (Just v) = return v
14:18:27 <Zekka> benzrf: Yes, that's correct, but I don't know where the exception comes from
14:18:30 <benzrf> Zekka: ah
14:18:33 <benzrf> cant you make one from a string
14:18:42 <Zekka> If there's a sufficiently generic exception to handle all cases that are like this, then sure
14:18:50 <benzrf> @hoogle Exception
14:18:50 <lambdabot> Control.Exception module Control.Exception
14:18:51 <lambdabot> Control.Exception.Base class (Typeable e, Show e) => Exception e
14:18:51 <lambdabot> Control.Exception class (Typeable e, Show e) => Exception e
14:19:03 <monochrom> @quote monochrom safeFromJust
14:19:03 <lambdabot> monochrom says: I use safeFromJust :: Maybe a -> Maybe a
14:19:05 <Zekka> (It's different from i.e. MonadError where the exception must be of a specific type dpending on the type of the monad, right?)
14:19:25 <trap_exit> what is a good way in haskell to do 'signal based' programming? imagine I have an electrical network with nodes ... as I modify one node, it sends a signal to another node ... . Now, I'm not writing a circut simulator -- but I have a a verity of 'nodes' in my program, and as I update one value, it propoagates changes to other nodes. Currently, I'm thinking of modeling each node as a mvar and setting up watchers. However, I suspect
14:19:33 <trap_exit> and I would prefer to just steal their solution
14:19:40 <benzrf> trap_exit: sounds EXACTLY like FRP/DCTP
14:19:47 <benzrf> trap_exit: also you got cut off at `suspectr'
14:19:49 <benzrf> trap_exit: also you got cut off at `suspect'
14:19:58 <Zekka> trap_exit: Have you considered modeling signals as Applicatives/Arrows and then just doing conventional FRP?
14:20:10 <trap_exit> "However, I suspect someone already solved this problem, and I would prefer to just steal their solution."
14:20:10 <__sebastian__> Zekka, benzrf thanks for the input
14:20:12 <trap_exit> benzrf: thanks, thanks
14:20:42 <trap_exit> DCTP = "denotative continuous time progrmaming" ?
14:20:46 <benzrf> yep
14:20:54 <benzrf> conal's gnu/linux to frp's linux
14:20:55 <benzrf> ;y
14:20:58 <Zekka> I don't know much about DCTP but I'm guessing it's probably fairly similar to my solution
14:21:03 <Zekka> yeah, that's about what I thought
14:21:11 <trap_exit> "conal's gnu/l;inux to frp's linux" <-- what does this mean ?
14:21:19 <trap_exit> also, my events are _discrete_, and I thought frp was all about continuous time
14:21:25 <benzrf> conal suggests DCTP because people keep calling things FRP that arent what he originally meant when he invented denotational continuous time programming
14:21:34 <trap_exit> ah
14:21:47 <benzrf> similar to how rms suggests gnu/linux because people keep calling things linux that arent what he thinks linux means
14:22:04 <benzrf> trap_exit: reactive-banana, at least, distinguishes events and behaviors
14:22:11 <vanila> linux is a kernel
14:22:14 <benzrf> but are you sure you're making a discrete thing?
14:22:23 <vanila> the majority of a linux distro is GNU software (which he mostly created)
14:23:06 <RyanGlScott> Okay, I'm stuck with TypeFamilies again. Suppose instead of an associated type, I have an associated data: class HasPort a where data Port a
14:23:13 <trap_exit> benzrf: the fake testimonials have convinced me to give it a shot
14:23:17 <benzrf> trap_exit: hehehe
14:23:20 <RyanGlScott> I need Port a's type to be Integral
14:23:20 <benzrf> trap_exit: basic overview is
14:23:28 <benzrf> trap_exit: you define some Events and Behaviors in the Moment monad
14:23:35 <RyanGlScott> class (Integral (Port a)) => HasPort a doesn't work this time
14:23:53 <benzrf> then you use `reactimate' on an Event (IO a) to run the actions the event signals
14:23:54 <RyanGlScott> Can you do something with DataKinds to get data Port a :: Integral?
14:24:10 <benzrf> the result of the Moment block can be compiled into an EventNetwork, which you use `actuate' to run
14:25:12 <benzrf> you send events into the network by using `newAddHandler' to get a token and an IO action that you run to fire the event, and `fromAddHandler' to get an Event from the token
14:25:20 <k00mi> RyanGlScott: you declared 'Port a' as a data family, not a type family. Are you sure that's what you want?
14:25:24 * hackagebot twitter-conduit 0.0.5.3 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.3 (TakahiroHimura)
14:25:34 <benzrf> within the network, you can use fmap on Events and Behaviors, and (<*>)/pure on Behaviors
14:25:34 <RyanGlScott> k00mi: Yes, that's intentional.
14:25:35 <trap_exit> benzrf: is Haskell School of Expression a good explaination of frp ?
14:25:40 <benzrf> possibly, i havent seen it
14:26:01 <benzrf> trap_exit: an `Event t a' in reactive-banana is a stream of discrete values of a at points in time
14:26:18 <RyanGlScott> I can set it to be data Port a :: *, but I can't constrain it further for some reason
14:26:20 <benzrf> trap_exit: a `Behavior t a' is a potentially-changing `a'
14:26:33 <trap_exit> benzrf: I appreciate your attempts to help, but I think at th emoment, I need a rigorous treatment to make sure I get the theory right, ... and after that, all will make sense
14:26:35 <benzrf> trap_exit: `Behavior t' is an Applicative, but `Event t' is not
14:26:40 <benzrf> trap_exit: fair enough :p
14:26:54 <benzrf> i guess im kinda being a firehose of info right now
14:26:57 <benzrf> mb
14:26:58 <benzrf> g2g
14:29:26 <bb010g> Any ideas on how to golf this further (Prelude only)? ``mapM_(putStrLn.return).show.sum.map((\x->if|x>57->x|True->48-x).fromEnum)``
14:29:42 <k00mi> RyanGlScott: what's the error when you have the Integral constraint?
14:31:24 <vanila> > show.sum.map((\x->if|x>57->x|True->48-x).fromEnum)
14:31:26 <lambdabot>  <hint>:1:19: Multi-way if-expressions need MultiWayIf turned on
14:32:10 <RyanGlScott> k00mi: 'Integral' of kind '* -> Constraint' is not promotable In the kind 'Integral'
14:32:45 <bb010g> mapM_(putStrLn.return).show.sum.map((\x->if x>57 then x else 48-x).fromEnum)
14:32:47 <bb010g> > mapM_(putStrLn.return).show.sum.map((\x->if x>57 then x else 48-x).fromEnum)
14:32:49 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a0)
14:32:49 <lambdabot>    arising from a use of ‘M553775405886553936631128.show_M5537754058865539366...
14:32:49 <lambdabot>  The type variable ‘a0’ is ambiguous
14:32:49 <lambdabot>  Note: there are several potential instances:
14:32:49 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
14:32:58 <bb010g> ?
14:33:05 <k00mi> RyanGlScott: I meant with the (Integral (Port a)) constraint
14:33:25 <k00mi> RyanGlScott: Port a :: Integral can't work because Integral is not a kind
14:34:12 <bb010g> > mapM_(putStrLn.return).show.sum.map((\x->if x>57 then x else 48-x).fromEnum)$"99A874512995"
14:34:14 <lambdabot>  <IO ()>
14:34:27 <vanila> > show.sum.map((\x->if x>57 then x else 48-x).fromEnum)$"99A874512995"
14:34:29 <lambdabot>  "-3"
14:34:33 <RyanGlScott> k00mi: Here's the full code: http://lpaste.net/109015
14:34:51 <RyanGlScott> k00mi: It complains that Port Int and Port Double aren't instances of Integral, unsurprisingly
14:35:07 <vanila> what's it suppose d to do
14:35:45 <k00mi> RyanGlScott: well, where's the problem then? Isn't that exactly the behavior you want?
14:36:05 <bb010g> vanila: Print (one character per line) the sum of the ASCII values of uppercase chars and negated actual number values.
14:36:46 <RyanGlScott> k00mi: I want to be able to have (Integral a) => Port a, but doing that requires a in HasPort a to be Integral as well.
14:37:05 <mwhit> RyanGlScott: so write an Integral instance
14:37:13 <Fuuzetsu> <command line>: combination not supported: Profiling/RTS Event Logging – well that sucks
14:37:23 <josephle> :t  mapM_(putStrLn).show.sum.map((\x->if x>57 then x else 48-x).fromEnum)
14:37:24 <lambdabot>     Couldn't match type ‘Char’ with ‘[Char]’
14:37:25 <lambdabot>     Expected type: Int -> [String]
14:37:25 <lambdabot>       Actual type: Int -> String
14:37:26 <RyanGlScott> mwhit: How? I can't figure out how to do that with TypeFamily syntax.
14:37:33 <metzger> hi
14:37:39 <DanielDiaz> is there any function to know if the system is 32 or 64-bits? (returning these values if possible) looking at (maxBound :: Int) and guessing it doesn't satisfy me : (
14:38:33 <monochrom> I think there is
14:38:36 <RyanGlScott> DanielDiaz: arch from System.Info: http://hackage.haskell.org/package/base-4.7.0.1/docs/System-Info.html#v:arch
14:39:04 <bb010g> josephle: The .return after putStrLn is so there's only one char per line, else I would use print instead of the mapM_
14:39:18 <DanielDiaz> RyanGlScott: I know from System.Info, but that still requires parsing a String? What outputs are possible?
14:39:31 <josephle> bb010g: ok
14:39:38 <mwhit> RyanGlScott: it seems like you want a type family, not a data family
14:39:40 <bb010g> josephle: And (putStrLn.return) is the same number of characters as (\x->putStrLn[x])
14:39:51 <silasm> > logBase 2 . fromIntegral $ (maxBound :: Int)
14:39:53 <lambdabot>  63.0
14:40:05 <mwhit> write data IntPort separately, with an Integral instance, then `type Port Int = IntPort'
14:40:21 <RyanGlScott> mwhit: No, I need a data type. The problem is that I'm trying to write a function like f :: Bool -> Port a, but this won't work.
14:40:34 <RyanGlScott> mwhit: I'd need a sum type to accomplish that.
14:40:48 <monochrom> DanielDiaz: my arch is "x86_64". IIRC 32-bit x86 is "x86". but I don't know what happens to ARM etc
14:40:56 <k00mi> RyanGlScott: I'm still not sure what you're trying to do. Do you want to every 'a' in 'HasPort a' to be Integral, or every 'Port a' for any 'a'?
14:41:09 <mwhit> RyanGlScott: I don't follow. what does that have to do with data families?
14:41:12 <monochrom> > System.Info.arch
14:41:14 <lambdabot>  Not in scope: ‘System.Info.arch’
14:41:16 <mwhit> IntPort can still be a sum type
14:41:20 <RyanGlScott> k00mi: Every Port a should be wrapped around an Integral type.
14:41:20 <mwhit> if you want
14:41:22 <josephle> bb010g: mapM_(putStrLn.(:[])).show.sum.map((\x->if x>57 then x else 48-x).fromEnum)
14:41:36 <RyanGlScott> mwhit: Data families are needed to have Port be associated with HasPort.
14:41:39 <josephle> bb010g: does that work?
14:41:42 <DanielDiaz> monochrom: yeah, that's my concern. I don't know every possible output of that. : (
14:41:42 <mwhit> no, type families also work
14:42:15 <k00mi> RyanGlScott: so what about: (Integral a) => HasPort a
14:42:40 <bb010g> josephle: Yes! Thanks.
14:43:00 <monochrom> how about we just assume that (isSuffixOf "64" arch) will just work :)
14:43:51 <RyanGlScott> mwhit: Type families are insufficient for this: http://lpaste.net/109016
14:44:01 <DanielDiaz> monochrom: I am too careful to accept that haha
14:44:15 <RyanGlScott> mwhit: I need to be able to have one of several results of a type function as an output
14:44:27 <RyanGlScott> mwhit: I can only see this happening with an algebraic sum type
14:45:01 <silasm> DanielDiaz: does the actual system architecture matter anyways (as opposed to the ghc installation?)
14:45:07 <monochrom> perhaps it is worthwhile to ask on the glasgow-haskell-users mailing list.
14:45:11 <RyanGlScott> k00mi: (Integral a) => HasPort a constrains the HasPort as well. I only want to constrain the Port.
14:45:46 <DanielDiaz> silasm: no, only the bit size.
14:45:48 <k00mi> RyanGlScott: but Port is part of HasPort
14:45:59 <mwhit> RyanGlScott: the syntax is wrong on that lpaste, of course it doesn't work
14:46:12 <RyanGlScott> k00mi: Right. HasPort is some unconstrained type with an associated data type that wraps something that is an Integral instance.
14:46:12 <silasm> DanielDiaz: I mean if you have a 32-bit ghc on a 64-bit system, which one matters to you?
14:46:29 <Delirious> Hello ?
14:46:30 <DanielDiaz> silasm: the GHC one
14:46:56 <napping> Hello !
14:47:00 <Guest44596> Hey
14:47:01 <silasm> >fromEnum . (+1) . logBase 2 . fromIntegral $ (maxBound :: Int) -- why not this then?
14:47:14 <DanielDiaz> silasm: from what you are pointing out, "arch" can even give me a wrong answer
14:47:28 <RyanGlScott> mwhit: Sorry, updated. http://lpaste.net/109016
14:47:39 <Guest44596> Anyone good with editing emulators ?
14:47:57 <k00mi> oh
14:48:16 <k00mi> RyanGlScott: you want the return type to depend on the value of the argument to f?
14:48:24 <RyanGlScott> k00mi: Yes.
14:48:32 <DanielDiaz> silasm: if you look at my question, I was saying that I don't like that solution. I was just asking if there were a direct function. But yeah, it seems I have to do it that way after all.
14:48:32 <k00mi> that's not possible in haskell
14:48:44 <croyd> DanielDiaz: how about taking the size of a pointer type? http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-Storable.html
14:48:46 <k00mi> you need full dependent types for that
14:48:59 <silasm> DanielDiaz: I'm not 100% sure that'll always get you what you want to be honest, but I think it will.
14:49:10 <DanielDiaz> croyd: now you are inspiring me!
14:49:12 <silasm> If there isn't a standard function for it, there should be.
14:49:13 <k00mi> RyanGlScott: you can get a close approximation with singletons
14:49:14 <monochrom> DanielDiaz, silasm: 32-bit GHC on 64-bit windows still says arch = "i386". it reflects what GHC is built for.
14:49:35 <DanielDiaz> monochrom: good to know, thank you.
14:50:03 <monochrom> however, at this point, if you use GHC, then maxBound::Int/Word seems to be the simplest and most reliable
14:50:08 <k00mi> RyanGlScott: http://hackage.haskell.org/package/singletons
14:50:22 <RyanGlScott> k00mi: I can always create a data type Port = IntPort Int | WordPort Word, but the plumbing is kind of awful.
14:50:29 <mwhit> RyanGlScott: even if you could get that to compile, how would you do anything with the results of f, having no idea what it returns?
14:50:31 <monochrom> if you will use other compilers, then of course it tells you nothing
14:51:10 <k00mi> RyanGlScott: the problem is that a polymorphic return type means the caller can decide what it returns
14:51:45 <croyd> DanielDiaz: > sizeOf (undefined :: Ptr a)
14:51:51 <croyd> DanielDiaz: 8
14:51:56 <k00mi> RyanGlScott: e.g. 'read :: Read a => String -> a' means I, the caller, can decide if that a is Int or whatever
14:52:05 <k00mi> RyanGlScott: read can't just give me an Int
14:52:20 <DanielDiaz> croyd: just typed: sizeOf (undefined :: Word) :)
14:52:35 <DanielDiaz> the size of an undefined word :)
14:53:04 <k00mi> RyanGlScott: but you're trying to give the caller a 'Port Int' or 'Port Double' when, according to the type, he can request any HasPort
14:53:06 <DanielDiaz> I think this is my favorite solution
14:53:17 <DanielDiaz> so far
14:53:18 <monochrom> \∩/
14:53:24 <danilo2> Hello! Is it possible somehow in haskell to enable IncoherentIntances only for a single instance not whole file ?
14:53:52 <mwhit> i don't think so
14:54:01 <monochrom> danilo2: a new extension in proposal will do that. it probably will appear in GHC 7.10
14:54:02 <DanielDiaz> danilo2: no, unless your whole file consists in only one instance.
14:54:03 <RyanGlScott> k00mi: Hm. I'll have to think about this some more tomorrow.
14:54:03 <mwhit> but you can probably trust yourself not to write any more incoherent instances in that file, no?
14:54:11 <k00mi> RyanGlScott: btw. there is no Integral instance for Double
14:54:11 <croyd> DanielDiaz: cheers
14:54:14 <k00mi> meh
14:54:43 <danilo2> monochrom:: Oh great! Is it already implemented (in the HEAD or somewhere) ?
14:54:44 <monochrom> in fact, it has already been implemented. only problem is now people want to have a say on how to name the keywords etc!
14:54:49 <dsturnbull> k00mi: wouldnt Double be a Fractional?
14:55:07 <dsturnbull> er Rational
14:55:16 <danilo2> monochrom: heh :) Ok so If its implemented- could I use it now ? (even if the naming will change later)
14:55:31 <k00mi> dsturnbull: yes, among others
14:55:40 <napping> danilo2: I think the important thing is what flags are enabled where the instance is defined
14:55:57 <monochrom> I don't know. but go to glasgow-haskell-users mailing list and find the thread "Overlapping and incoherent instances"
14:57:14 <k00mi> dsturnbull: you can see what instances a type has with ':i Type' in GHCi ;)
14:57:28 <monochrom> :i stands for :info
14:57:39 <danilo2> monochrom: great! thank you very much!
14:57:57 <danilo2> napping: I was talking aobut enbabling such flag locally :)
14:59:08 <napping> danilo2: I think the best you can do is enable it for one file that defines the option you want
14:59:15 <latk> I'm trying to install lens, but get some error about could not deduce traversable. Has anyone had this problem?
14:59:16 <napping> that defines the instance rather
14:59:42 <triliyn> dsturnbull, k00mi: Rational is a type, not a class
14:59:47 <triliyn> > 1.5 :: Rational
14:59:47 <danilo2> napping: for now yes, but as monochrom mentioned - it would soon be allowed to define them locally \o/
14:59:48 <lambdabot>  3 % 2
15:00:05 <k00mi> triliyn: yes, but Fractional isn't
15:00:06 <timmy_tofu> Does anyone know how and where to add a ghc-mod GHC flag to set a CPP flag in ghc-mod-vim? That is, I want the command executed to be ghc-mod -g -DDEVELOPMENT blah blah blah when ghc mod is run.
15:00:11 <timmy_tofu> I've tried adding it to l:opts in autoload/ghcmod.vim various ways, but to no avail
15:00:19 <timmy_tofu> There's a b:ghc_mod_options variable as well, but I don't want to do this on a buffer-by-buffer basis, and I haven't tried to see if that even works anyways
15:00:28 * hackagebot b-tree 0.1.0.0 - Immutable disk-based B* trees  http://hackage.haskell.org/package/b-tree-0.1.0.0 (BenGamari)
15:01:13 <monochrom> in fact my understand of what SPJ says is that GHC has long been marking instances individually internally. it's just a matter of making up a syntax for you.
15:02:54 <mmmm_> latk: Are you installing in a sandbox?
15:03:01 <monochrom> it's worse. internally, every instance is marked with 2 bits "can other instances overlap me?" and "can I overlap other instances?". and this has never been exposed to you. externally you have to turn on both or turn off both, but internally they can be independent and there is no harm.
15:06:26 <latk> mmmm_: yes - does that change things ?
15:06:58 <edwardk> latk: what version of lens?
15:07:10 <edwardk> latk: and what version of semigroupoids?
15:07:42 <latk> edwardk: lens-4.3.3, I don't know about semigroupoids - how do I find this out ?
15:08:00 <edwardk> if its with 4.3.3 then it should be current semigroupoids
15:08:08 <edwardk> afk a bit
15:08:44 <latk> This is the error: http://lpaste.net/109018
15:08:46 <kmicinski> Hey all, I’m trying to install conduit and am getting the following error (http://pastebin.com/Z1YGPF2R).  I’m on OSX and am at 1.20 for cabal and 7.6.3 for ghc
15:09:34 <kmicinski> I got the same error trying to install conduit 1.1.7 and 1.1.6, it seems strange that it’s related to preprocessing so I’m hoping this is a small error in my configuration relating to OSX
15:09:48 <bergey> latk: I've been seeing this with current lens, semigroupoids and GHC-7.6.3.  It works fine with GHC-7.8.3.
15:10:12 <metzger> can someone explain existential types to me please?
15:10:13 <bergey> https://travis-ci.org/diagrams/diagrams-lib/jobs/31930230 has a full build log.
15:10:26 <latk> bergey: Huh, okay. I guess I could try upgrading ghc
15:11:17 <monochrom> existential type means throwing away type information irrecoverably
15:11:36 <metzger> i don't know what that means and what its effect is
15:12:20 <napping> A type like exists a . [a] would be a list where you don't know what the exact member type a is
15:12:26 <monochrom> its effect is that if I create a value of an existential type and pass that value to you, you have very limited ways of using it
15:12:43 <napping> The type "a" named by exists isn't stored in the value or anything
15:12:52 <napping> so basically all you can do is look at the shape of the list itself
15:12:54 <metzger> the only bit i somehow understood was when someone said that an existential type is of the form { foo :: a; bar :: a -> b } and you don't get told what a is but know that there's some type and you can take the foo and put it into bar and you'll get b, which you might know
15:13:30 <metzger> so the existential says that the type of foo and the type of the first parameter of bar are the same
15:13:33 <josephle> metzger: that is how you can practically use existential types
15:13:35 <monochrom> yes, all you can do is write "bar foo" and marvel at the blinking lights
15:13:43 <metzger> but what use does this have?
15:13:46 <napping> If I give you something and tell you it's a list, but maybe [Int] or maybe [Char] or maybe [IO ()], you can't do anything (well-typed) to the elements
15:13:51 <monochrom> no use.
15:14:03 <aranea> Hi. I just discovered QuickCheck's quickCheckAll (which tests all properties defined in the current module) is implemented by getting the path of the source file from the compiler, and then opening and manually parsing it. Isn
15:14:03 <bb010g> Is there a way to get GHCi to not show the result of it, and only show the evaluation of its IO?
15:14:18 <metzger> i cannot believe that this has no use to speak of
15:14:24 <aranea> 't there any better way to do that? (Notebook keyboards are awful)
15:14:47 <napping> metzger: I agree only that that example doesn't have much use
15:14:57 <napping> one thing you can do is include other information that tells you something about the type
15:15:01 <metzger> wouldn't it make e.g. type inference easier? i know it's simpler to prove theorems if you don't have to construct every step along the way, but can e.g. use AC at some point.
15:15:02 <monochrom> the exact example you wrote has no use. some other very elaborate example has some use, but still very limited
15:15:35 <metzger> oh. i was asking about what use existential types have in general.
15:15:52 <napping> In general you can only use the things involving the existential variable if the values packages some functions in terms of types you do know
15:16:07 <napping> and them most of the time you can just "pre-apply" them, and give somebody a simple value in a type they know
15:16:15 <metzger> basically, when people say "existential type" they mean there are several types bound by mentioning the same type in their body, right?
15:16:38 <napping> exists a . ([a],a -> Int) is no more useful than [Int]
15:16:49 <metzger> yeah
15:17:15 <napping> It's not so much about mentioning the same type
15:17:28 <metzger> but if you now have exists a . ([a], a -> Foo, a -> Bar) then it becomes useful, right?
15:17:50 <Guest16933> why not just [(Foo, Bar)] then
15:17:51 <napping> but that you have some type variable, like that "a" in lists, that's somehow hidden so when you get the value you don't know what it is
15:18:00 <napping> yeah, that's the general idea
15:18:01 <monochrom> is it useful to you?
15:18:55 <monochrom> it looks to me exists a . ([a], a -> Foo, a -> Bar) is of the same calibre as exists a . ([a],a -> Int)
15:19:08 <metzger> perhaps
15:19:19 <napping> and building/cacheing a tuple of results vs. being able to call functions is basically the difference
15:19:25 <metzger> haskell doesn't have the "exists" operator, right?
15:19:38 <napping> Nope, it's kind of built in to data type definitions
15:19:56 <metzger> how does one write monochrom's useful example in haskell?
15:20:11 <monochrom> I don't have a useful example
15:20:21 <Sonarpulse> does anybody have something like find -exec in laying around in haskell ?
15:20:23 <josephle> existentials are rarely seen at the source level of a programming language
15:20:34 <Sonarpulse> +1 if paralell
15:20:42 <tac-tics> josephle: probably because Haskell has no syntax support for them
15:20:43 <benzrf> Sonarpulse: johnw is make a parallel find lib
15:20:55 <Sonarpulse> kewl
15:20:56 <benzrf> @google john wiegley conduits find
15:20:57 <lambdabot> http://www.newartisans.com/
15:20:57 <lambdabot> Title: index
15:20:59 <josephle> tac-tics: I mean, most languages don't have syntax support for them :)
15:20:59 <benzrf> 1 sec
15:21:20 <tac-tics> josephle: well yeah :P
15:21:36 <benzrf> https://github.com/jwiegley/find-conduit Sonarpulse
15:21:39 <Sonarpulse> tac-tics rust is an exception
15:21:41 <monochrom> perhaps the package "machine" has a useful example
15:21:48 <tac-tics> Sonarpulse: oh really?
15:21:52 <josephle> Sonarpulse: really?
15:21:57 <monochrom> err, "machines"
15:22:09 <johnw> benzrf: not just is making, has made.  I just haven't implemented all the GNU find-like combinators :)
15:22:10 <napping> metzger: I don't know that monochrom gave a particular example, but you can turn on ExistentialQuantification and write data Stream a = forall a . Stream state (state -> Maybe (a,state))
15:22:15 <benzrf> ah
15:22:22 <metzger> napping: ([a], a -> Int)
15:22:22 <Sonarpulse> yes
15:22:30 <Sonarpulse> limited usage
15:22:33 <monochrom> its type "Step" has an existential
15:22:39 <frerich> Sonarpulse: You can use https://hackage.haskell.org/package/filemanip for that
15:22:41 <benzrf> i was thinking earlier of writing some kind of lib for generic grid-based automata
15:22:47 <metzger> napping: i don't know what "Stream" would look like with "exists".
15:22:49 <napping> which is useful more because the replacement is [a] which would have to be defined recursively, which GHC doesn't optimize as well
15:22:51 <benzrf> not necessarily just cell-has-state-updated-by-neighbor tho
15:22:54 <Sonarpulse> but basically using a trait (aka type classe) as a type name
15:23:06 <napping> The forall before the constructor name is how you write "exists" in Haskell
15:23:06 <benzrf> and i got to thinking about how to write tick functions for entities in the grid
15:23:23 <Sonarpulse> is exists T (TypeClass T)
15:23:33 <Sonarpulse> there are other restrictions
15:23:35 <metzger> napping: so this would then be "data Stream a = exists a . Stream state (state -> Maybe (a, state))"?
15:23:45 <Sonarpulse> it is basically there for people comming from C++ that expect dynamic dispatch
15:23:51 <Sonarpulse> thanks frerich
15:23:54 <frerich> Sonarpulse: “find -exec” would probably be something like ‘find always (anyPerms 555) “/some/dir”’’
15:23:57 <benzrf> and im not sure how to phrase what i was thinking about
15:23:58 <benzrf> -.-
15:24:03 <jophish_> Is there a #Haskell-social channel?
15:24:06 <frerich> Sonarpulse: …to find all files beneath /some/dir which have some executable bit set.
15:24:12 <josephle> jophish_: #haskell-blah
15:24:40 <monochrom> metzger: no, exists a. (state, state -> Maybe (a, state))
15:24:43 <Sonarpulse> great
15:24:47 <monochrom> err
15:24:51 <Sonarpulse> tac-tic http://smallcultfollowing.com/babysteps/blog/2014/01/05/dst-take-5/
15:24:52 <monochrom> exists state. (state, state -> Maybe (a, state))
15:25:07 <Sonarpulse> *tac-tics
15:25:14 <frerich> Sonarpulse: (I think it should be “anyPerms 111” actually, not sure)
15:25:30 * hackagebot texmath 0.7.0.1 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.7.0.1 (JohnMacFarlane)
15:25:32 <metzger> monochrom: why would you have an existential type only on the right side of the pair?
15:25:35 <benzrf> jophish_: #haskell-blah
15:25:45 <jophish_> Thansk josephle, benzrf
15:25:54 <josephle> Sonarpulse: isn't that still a layer indirection from actual existentials?
15:25:54 <monochrom> I don't understand the question
15:26:02 <josephle> *layer of indirection
15:26:14 <monochrom> I am just faithfully translating haskell to your notation
15:26:14 <metzger> what does it give me that there's some a on the output of a function?
15:26:40 <frerich> Sonarpulse: Ah sorry I only now realize that I had a brainfault - “find -exec” executes a cmmand for all files, it doesn’t find executable files. Still, the ‘filemaip’ package is still a good library for doing what ‘find’ on the commandline does :)
15:26:45 <monochrom> it is a stream of a's
15:26:47 <Sonarpulse> josephle yeah you can't write any existential
15:26:57 <Sonarpulse> that would break the monomorphization guarantees
15:27:01 <metzger> given that this a is not further quantified there doesn't seem to be any way to use that a
15:27:03 <benzrf> i wonder
15:27:14 <benzrf> ok
15:27:23 <benzrf> is there a wrapper in the std libs like this
15:27:24 <monochrom> you have heard of "data [a] = [] | a:[a]", no?
15:27:29 <Sonarpulse> frerich yeah that is difinitely what I want
15:27:38 <Sonarpulse> thanks so much
15:27:39 <benzrf> nvm
15:27:40 <metzger> monochrom: yes
15:27:50 <benzrf> is there a pointwise monoid instance for functions
15:27:59 <monochrom> ok, so Stream is "data Stream a = ..."
15:28:00 <benzrf> i mean is there a wrapper that allows that
15:28:20 <monochrom> and then it does an exists on "state". not "a".
15:28:28 <metzger> monochrom: oh, i just noticed you corrected "exists a".
15:28:38 <metzger> that explains everything.
15:28:47 <benzrf> @let newtype Pointwise a b = Pointwise (unPointwise :: a -> b}
15:28:48 <lambdabot>  Parse failed: PolyKinds is not enabled
15:28:54 <benzrf> @let newtype Pointwise a b = Pointwise {unPointwise :: a -> b}
15:28:57 <lambdabot>  Defined.
15:29:33 <metzger> so if i'm doing existential quantification, the "exists" type is the one not mentioned in the "forall"?
15:29:40 <monochrom> yes
15:29:42 <benzrf> oh wait
15:29:49 <benzrf> i guess that could be an applicative monoid in general couldntit
15:29:57 <monochrom> err, probably not. I don't understand the question.
15:30:16 <napping> metzger: another use might be passing a random number generator/seed as exists a . (a, a -> [Int]), so you could let the stream be garbage collected if you temporarily don't need it. Again fairly operational
15:30:31 * hackagebot easyjson 0.1.0.0 - Haskell JSON library with an emphasis on simplicity, minimal dependencies, and ease of use.  http://hackage.haskell.org/package/easyjson-0.1.0.0 (thinkpad20)
15:30:43 <monochrom> "data XXX a = forall b. Ctor ... a ... b ..." the exists is on b.
15:31:09 <metzger> but when you translated the Stream example you put the exists on the thing that wasn't in the forall.
15:31:29 <tac-tics> Is there an easy way to get the TimeZone given a city name or geo coordinates?
15:31:30 <monochrom> you wrote it wrong in the beginning
15:31:34 <metzger> oh
15:31:52 <metzger> did napping write it correctly?
15:31:57 <monochrom> the correct code is: data Stream a = forall state. Stream state (state -> Maybe (a, state))
15:32:04 <metzger> "data Stream a = forall a . Stream state (state -> Maybe (a,state))"
15:32:11 <metzger> ok.
15:32:31 <metzger> yes, that makes sense.
15:35:46 <benzrf> forall a.?
15:35:49 <benzrf> wut?
15:35:59 <benzrf> shouldnt that be forall state.
15:36:40 <tac-tics> yeah. Otherwise state is unbounded.
15:36:45 <monochrom> yes
15:36:56 <monochrom> welcome to the party
15:36:58 <danilo2> Hello! I've got 2 simple codes here. I thought they should work the same way (one is refactoristaion of the other one). But the first compiles while the second complains about overlapping instances. Would somebody be so nice and give me hint why the first one works and the annotation does not? http://lpaste.net/109019
15:37:32 <metzger> when looking at a type, how do i figure out which of the arrows are natural transformations?
15:37:54 <mwhit> danilo2: GHC can't use constraints on an instance declaration when figuring out what instance to use
15:38:23 <mwhit> danilo2: so in the second module, instance out~b => BaseType b out where will overlap with any other instance
15:38:23 <danilo2> mwhit: I know - look , the first code compiles and works ...
15:38:45 <danilo2> mwhit: hmm, in the first code we've got the same situation - am I wrong ?
15:38:59 <mwhit> no, in the first code you have BaseType (Proxy b) outj
15:39:04 <benmachine> are there any non-LANGUAGE pragmas in GHC which affect whether or not a module successfully compiles, rather than just how it is optimised?
15:39:26 <danilo2> mwhit: which overlaps with the second instance the same way, right ?
15:39:46 <mwhit> oh
15:39:47 <mwhit> hm
15:39:51 <mwhit> you're right
15:39:56 <mwhit> oh
15:39:56 <mwhit> duh
15:40:02 <mwhit> you have overlapping instances enabled in the first one
15:40:15 <mwhit> and in the second, so what's the errorr?
15:40:39 <danilo2> mwhit: oh, I did nto pasted the error -.- brb
15:41:21 <danilo2> mwhit: error in annotation : http://lpaste.net/109019
15:42:40 <mwhit> so it doesn't surprise me that the second one doesn't compile, it suprises me that the first one does
15:42:58 <mwhit> the first 2 statements in main should have the same complaint there as far as i can tell
15:43:42 <danilo2> mwhit: exactly - that did suprise me in the beginning
15:45:04 <danilo2> mwhit: whats interesting - the first code works good
15:46:03 <mwhit> :t toProxy
15:46:04 <lambdabot> Not in scope: ‘toProxy’
15:46:59 <danilo2> mwhit: hmm, oh
15:47:13 <danilo2> mwhit: toProxy :: a -> Proxy a; toProxy = Proxy
15:47:31 <codygman> I'm looking for and trying to make a "containsOneOf" function. I guess just elem, but for Text that is Text -> [Text] -> Bool. Also I initially just tried map T.isInfixOf which resulted in a type of [T.Text] -> [T.Text -> Bool]. So it returns a list of functions that take Text as an argument and return a bool? How would I use map T.isInfixOf?
15:48:14 <danilo2> mwhit: I've fixed it in the example: http://lpaste.net/109020
15:49:03 <mwhit> yeah, i'm at a loss actually
15:49:05 <mwhit> that's super interesting
15:49:09 <mwhit> but unfortunately i gotta go
15:49:10 <pavonia> codygman: isInfixOf takes two arguments
15:49:24 <danilo2> mwhit: Oh, ok. Thank you
15:50:00 <pavonia> codygman: Try "map (theWordToSearchFor `isInfixOf`)"
15:50:08 <danilo2> Anyway - if anybody could explain to me why the first code compiles and the second one does not I owuld be very thankful: http://lpaste.net/109019  (where toProxy :: a -> Proxy a; toProxy = Proxy)
15:52:26 <codygman> pavonia: Thanks
15:52:48 <benzrf> are there any reasonable uses of ala other than foldMap
15:56:58 <benzrf> i guess there's
15:57:00 <benzrf> > ala Any (const (const mempty)) "foo"
15:57:02 <lambdabot>  False
15:57:07 <benzrf> if you want that for some nutty reason
15:57:21 <benzrf> or something along those lines
15:57:46 <hiptobecubic_> :t ala
15:57:48 <lambdabot> (Rewrapped t s, Rewrapped s t) => (Unwrapped s -> s) -> ((Unwrapped t -> t) -> e -> s) -> e -> Unwrapped s
15:58:18 <hiptobecubic_> what?
16:01:30 <benzrf> hiptobecubic_: it takes a newtype wrapping constructor and a function that takes a wrapper, an e, and returns a wrapped value, then takes an e and returns an unwrapped value
16:01:41 <benzrf> hiptobecubic_: basically it's something like
16:02:04 <benzrf> ala wrap f a = unwrapFor wrap $ f wrap a
16:02:05 <benzrf> or something
16:02:14 <benzrf> it's handy for foldMap:
16:02:22 <benzrf> > ala Any foldMap [True, False, False]
16:02:24 <lambdabot>  True
16:04:15 <platz> emacs users, are y'all using com-int mode for the repl, or the other "interactive" mode?
16:04:57 <glguy_> benzrf: (au (iso runWriterT WriterT) traverse) :: (Applicative f, Monoid w) => [f (a,w)] -> f ([a], w)
16:04:58 <glguy_>   :: (Monoid w, Applicative f) => [f (a, w)] -> f ([a], w)
16:05:22 <benzrf> whaaaaa
16:05:24 <glguy_> you can use it to build up different "sequenceA" operations just like you can build up different fold operations
16:05:31 <benzrf> :t au
16:05:32 <lambdabot> AnIso s t a b -> ((s -> a) -> e -> b) -> e -> t
16:05:34 * hackagebot picosat 0.1.1 - Bindings to the PicoSAT solver  http://hackage.haskell.org/package/picosat-0.1.1 (sdiehl)
16:05:40 <glguy_> au is the manual version of ala
16:05:45 <benzrf> o
16:06:35 <bergey> platz: I'm pretty happy with the newer interactive-mode; I think the other is also popular.
16:06:38 <glguy_> Actually, this works: (ala WriterT traverse) :: (Applicative f, Monoid w) => [f (a,w)] -> f ([a], w)
16:06:39 <glguy_>   :: (Monoid w, Applicative f) => [f (a, w)] -> f ([a], w)
16:06:52 <codygman> pavonia: Actually that was the opposite of what I needed, lol.
16:07:35 <pavonia> Oh
16:08:05 <codygman> I have a list of [Text] and want to filter them by a list of [Text]
16:08:25 <platz> bergey: thanks - my previous setup stopped working after an upgrade and I noticed this new mode - it appears comint is depricated - kinda confusing because a lot of the emacs setup tutorials are out of date now.  but I think I'll switch things over now!
16:08:26 <codygman> err
16:09:00 <codygman> pavonia: I have a Text and want to filter out the ones who don't satisfy certain predicates
16:11:43 <pavonia> I'm not sure I understand
16:12:50 <pavonia> > filter (`isInfixOf`"foobar") ["foo", "bar", "foobar"]
16:12:52 <lambdabot>  ["foo","bar","foobar"]
16:13:01 <pavonia> > filter (`isInfixOf`"foobar") ["foo", "bar", "foobaz"]
16:13:02 <lambdabot>  ["foo","bar"]
16:13:07 <pavonia> Like that?
16:13:48 <codygman> pavonia: checking now
16:13:48 <Fuuzetsu> just now I discovered a module called Data.Attoparsec.Internal.Fhthagn
16:13:56 <Fuuzetsu> I think the nasty name is to stop people from using what's inside
16:14:13 <oakwhiz> http://hackage.haskell.org/package/attoparsec-0.12.1.0/docs/src/Data-Attoparsec-Internal-Fhthagn.html
16:14:18 <benzrf> :t foldMap
16:14:19 <benzrf> :t traverse
16:14:19 <lambdabot> (Monoid m, Foldable t) => (a -> m) -> t a -> m
16:14:21 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:14:25 <benzrf> mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm i see
16:14:25 <Fuuzetsu> yup
16:14:36 <oakwhiz> unsafeperformio, but on steroids
16:14:53 <benzrf> lmao
16:15:27 <ezrios> :t mapM
16:15:29 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
16:15:33 <ezrios> :t (>>=)
16:15:35 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:15:49 <ezrios> hm
16:15:56 <ezrios> I need to watch that lenses talk again
16:16:50 <benzrf> :t iso runWriterT WriterT
16:16:51 <systemfault> What is the lenses talk?
16:16:52 <lambdabot> (Profunctor p, Functor f) => p (m (a, w)) (f (m1 (a1, w1))) -> p (WriterT w m a) (f (WriterT w1 m1 a1))
16:16:53 * tabemann_ needs to learn more about lenses himself
16:16:56 <benzrf> bwah
16:17:04 <ezrios> https://www.youtube.com/watch?v=cefnmjtAolY
16:17:06 <ezrios> from the man himself
16:17:07 <benzrf> EDWARDK WHAT HAVE U WROUGHT IN YOUR HUBRIS
16:17:12 <ezrios> great talk
16:17:15 <ezrios> very dense
16:17:18 <systemfault> Thank you
16:17:26 <ezrios> slides are googleable
16:17:30 <ezrios> and very helpful
16:17:56 <ezrios> benzrf: what the hell
16:17:58 <ezrios> is that
16:18:01 * tabemann_ was starting to learn about lenses, but then he dropped out of Haskell development for a while and forgot everything
16:18:13 <ezrios> tabemann_: that's how I'm learning Haskell
16:18:25 <ezrios> I do it in sprints, and every time I gradually learn more than I forget
16:19:15 <ezrios> I want to learn category theory
16:19:30 <benzrf> ezrios: whats stpoping you
16:19:39 <ezrios> my feeble mind cannot comprehend the maths
16:19:49 <benzrf> bullshit
16:20:00 <benzrf> if u can grok monads u can grok CT
16:20:09 <ezrios> you know a good book?
16:20:21 <platz> ezrios: I've watched it twice and get lost pretty quickly.. maybe trying at 1am doesn't help either
16:20:40 <glguy_> It's less scary (but maybe still scary) when written as:    iso runWriterT WriterT :: Iso (WriterT w m a) (WriterT v n b) (m (a,w)) (n (b,v))
16:20:45 <ezrios> platz: a lot of the prior shit is just derivation
16:21:12 <platz> yeah it's more about implementation rather than usage
16:21:28 <ezrios> he does some good examples in ghci
16:21:32 <ezrios> but yah very math heavy
16:21:37 <ezrios> I got lost after like an hour
16:21:42 <ezrios> well maybe not math per se
16:21:53 <benzrf> :t ala WriterT traverse
16:21:54 <lambdabot> (Monoid w', Traversable t, Applicative m') => t (m' (a', w')) -> Unwrapped (WriterT w' m' (t a'))
16:22:16 <benzrf> i see
16:22:17 <ezrios> maybe I will just troll ncatlab
16:22:41 <mwhit> i think fluency in math *as a language* is a totally separate skill from understanding of any particular branch of math
16:22:49 <mwhit> and those who are fluent forget what it's like not to be
16:22:59 <benzrf> I:
16:23:02 <ezrios> mwhit: my friend had a similar idea
16:23:06 <josephle> I know some argue CT is basically a language
16:23:11 <ezrios> "I just realized, I don't remember what it was like not to understand code"
16:23:19 <benzrf> ezrios: same
16:23:22 <ezrios> "and I have no idea what other people think when they see code"
16:23:53 <mwhit> i switched from physical sciences into data science like, barely a year ago
16:24:01 <mwhit> i still very much remember what it was like not to know how to code
16:24:06 <mwhit> but math is another story
16:24:19 <ezrios> well it probably changes the way you look at everything
16:25:07 <tabemann_> I for one don't have much of a math background at an abstract level, while yeah I can't remember not understanding code
16:25:44 <tabemann_> I think about things in terms of code rather than in terms of math
16:25:52 <mwhit> it definitely made me think i'd have had a much easier time with some parts of math learning (especially early on) if i'd had programming skills at the same time
16:26:04 <ezrios> I try to think about math the same way I think about code
16:26:05 <ezrios> doesn't work
16:26:10 <ezrios> I'm just lost
16:26:13 <platz> for me the frustration is with the implied context one must have when studying equations.  you're supposed to know what a gamma is and it's not defined for you.  gamma will mean something else in a different context.
16:26:42 <platz> when you get several of these variables in an equation it's maddening
16:27:37 <ezrios> a lot of the time I am astounded at how some people derive mathematical results
16:27:46 <tac-tics> platz: Yeah. That was and is still my number one frustration when learning new science material, still today
16:27:47 <SrPx> Could someone please explain how this is translated to lambda calculus / system f / core / whatever? `let { x = 1 : x } in x`. I ask this because I don't recognise that to be expressible in lambda calculus (without y combinator or whatnot)
16:27:48 <ezrios> they just pull genius out of their ass
16:27:52 <tac-tics> That and not knowing what "type" objects are supposed to be
16:28:05 <benzrf> platz: in CT theres a common asshole trick of using a natural transformation as though it were a morphism
16:28:13 <tac-tics> ezrios: It's just like anything else. They learn it in a community. And that community then does a shit job of documenting itself.
16:28:20 <benzrf> i finally figured out that you just need to tackle it as though it were a polymorphic function in haskell
16:28:28 <ezrios> tac-tics: textbooks are documentation
16:28:48 <benzrf> SrPx: use the y combinator, then
16:28:50 <Saizan> SrPx: you do need the y combinator or some other way to do (co)recursion for that
16:28:51 <benzrf> thats how it works
16:28:59 <tac-tics> benzrf: Natural transformations are the morphisms of Cat. And the analogy between NT and polymorphism is a kind of weak one.
16:29:14 <mwhit> tac-tics: ehhh... a lot of it is, like I said, math *as a language* rather than something to be documented
16:29:16 <SrPx> I mean, how *haskell* does it? Does it actually create a Y combinator and figure out how to express it in LC?
16:29:35 <SrPx> I mean, how *haskell* does it? Does it actually create a Y combinator and figure out how to express it in LC?
16:29:39 <SrPx> woops, sorry
16:29:43 <mwhit> in the example of "knowin what a gamma is", a lot of times the equation including that gamma is implicitly defining it in whatever equation
16:29:44 <platz> related: which variables are free, which are not free..  which are ranging
16:29:53 <platz> sometimes this is described well, but sometimes it's not
16:30:09 <benzrf> tac-tics: i mean when they elide the object that the transformation is applied to
16:30:11 <Saizan> SrPx: oh, haskell just has let, even GHC core does
16:30:22 <benzrf> and just use the transformation in place of the morphism that it would give when applied to the elided object
16:30:37 <tac-tics> benzrf: I guess I haven't seen that very often
16:30:48 <ezrios> possible to learn category theory off ncatlab?
16:31:07 <SrPx> Saizan: ah so it has a recursive let primitive, ok. Do top-level functions get translated to "lets" in core or is there yet another primitive for name bindings?
16:31:14 <tac-tics> I have seen, however, functors used as maps Obj C -> Obj D *and* as the fmap we know: Hom(A,B) -> Hom(FA, FB)
16:31:21 <dfeuer> ezrios: that would be difficult.
16:31:32 <tac-tics> ezrios: don't bother :X
16:31:50 <Saizan> SrPx: i think core still has top-level functions
16:31:51 <Clint> edwardk: why no MonadMask instance for EitherT?
16:31:54 <tabemann_> what good sources are there for category theory for people who don't know a whole lot of math?
16:32:12 <ezrios> hm
16:32:20 <platz> I'm going to give awodey's videos another shot . if I ever get to adjunction's and actually understanding yoneda i'll be happy
16:32:23 <tac-tics> tabemann_: ##categorytheory, Pierce's book for computer scientists, Awodey, and the "baby book" by Lawvere.
16:32:33 <ezrios> Pierce's book really
16:32:36 <ezrios> I keep hearing about this
16:32:37 <benzrf> http://wwwhome.ewi.utwente.nl/~fokkinga/mmf92b.pdf http://wwwhome.ewi.utwente.nl/~fokkinga/mmf92b.pdf http://wwwhome.ewi.utwente.nl/~fokkinga/mmf92b.pdf  http://wwwhome.ewi.utwente.nl/~fokkinga/mmf92b.pdfhttp://wwwhome.ewi.utwente.nl/~fokkinga/mmf92b.pdf
16:32:45 <ezrios> wat
16:32:55 <edwardk> Clint: the goal with MonadMask is you should actually _know_ the real events are being masked. the idea is that if you really want to build a test suite that mocked with Either, you could postulate it locally in the quickcheck application or whatever, but that it isn't sound to postulate in general
16:33:05 <edwardk> otherwise it'd just be in the MonadCatch class
16:33:22 <edwardk> with Either you could believe you had async safety when you were doing nothing of the sort
16:33:44 <tac-tics> platz: adjunctions are weird. But the yoneda embedding is basically "fleshing out" (or "completing") a category to make it nicer. It adds all finite limits, colimits, makes it a CCC, and also a topos.
16:33:55 <tabemann_> thanks
16:33:57 <dfeuer> SrPx: Core still has top-level functions, but mutually recursive ones are tied together with a special form I don't remember the name of.
16:34:03 <edwardk> it was the compromise i reached with snoyman whereby i could continue to mock, but he could continue to understand his code was really being masked when requested
16:34:23 <platz> tac-tics: yeah it does sound pretty neat
16:34:41 <tac-tics> platz: as an analogy, the yoneda embedding is a lot like the problem of "I want all my nontrivial polynomials to have solutions"... and so you "complete" the reals to get complex number.
16:34:50 <dfeuer> Something like Recursive {f ... = ... g ...; g ... = ... f ...}
16:34:57 <tac-tics> Or similarly, you want least upper bounds, so you "complete" the rationals to get the reals
16:34:57 <benzrf> tac-tics: example of something i saw using that notation recently: check the formulas on page 7 of http://dmwit.com/papers/201009SL_full.pdf
16:36:05 <edwardk> tac-tics: basically as it takes you to a presheaf on set you can borrow the nice things about set.
16:36:09 <platz> bartosz had some good posts on it i'll have to re-visit
16:36:19 <edwardk> C^J gets most of the nice structure of C for free
16:36:20 <SrPx> dfeuer: Saizan I see, thanks
16:36:30 <edwardk> so Set^(C^op) also gets most of the nice structure of Set
16:36:43 <benzrf> tac-tics: i.e.
16:36:48 <tac-tics> edwardk: yeah. It also justifies why category theorists are obsessed with categories of functors
16:36:49 <benzrf> diag;(f⊗f) =f;diag
16:36:55 <edwardk> yep
16:37:08 <edwardk> hask is basically 'lets do everything where yoneda behaves nicely and nothing else'
16:37:09 <edwardk> =)
16:37:30 <tac-tics> edwardk: when you ignore _|_ and seq, right? :P
16:37:30 <edwardk> https://github.com/ekmett/hask/blob/master/src/Hask/Category.hs#L48
16:37:55 <edwardk> you can reason about code as if they don't exist and if code terminates in both universes it gets the same answer =P
16:38:11 <dfeuer> What is this Yoneda lemma I've heard of? Is that the funky thing where you somehow manufacture Monads from Functors and Functors from anything you like?
16:38:37 <benzrf> dfeuer: coyoneda is a free functor
16:38:43 <benzrf> i think yoneda is as well? maybe?
16:38:45 <Clint> edwardk: so if i want to use finally and bracketOnError with EitherT, what should I be doing?
16:38:45 <benzrf> no
16:38:51 <benzrf> i dont know
16:38:57 <platz> dfeuer: yoneda defies explanation.  one must contemplate yoneda in various ways
16:39:05 <benzrf> coyoneda seems more intuitive to me
16:39:11 <benzrf> dfeuer: free monads are fairly simple
16:39:14 <benzrf> @undef
16:39:15 <lambdabot> Undefined.
16:39:34 <benzrf> @let define FreeMonad f a = Return a | Join (f (FreeMonad f a))
16:39:34 <lambdabot>  Parse failed: Parse error: |
16:39:39 <benzrf> @let data FreeMonad f a = Return a | Join (f (FreeMonad f a))
16:39:41 <lambdabot>  Defined.
16:40:21 <edwardk> Clint: you can give up and make an orphan instance of MonadMask for EitherT, or you can make your own EitherT. finally carries the connotation that it does the right thing for async exceptions as well
16:40:25 <platz> https://www.fpcomplete.com/user/bartosz/understanding-yoneda
16:40:38 <edwardk> and i can't do that in general
16:40:41 <benzrf> :t Join
16:40:42 <lambdabot> f (FreeMonad f a) -> FreeMonad f a
16:40:47 <benzrf> bleh...
16:41:00 <benzrf> i've suffered amnesia and forgotten how this works
16:41:17 <dfeuer> OK, I'm clearly mixing up different things I don't understand.
16:41:21 <dfeuer> Forget that for now.
16:41:37 <benzrf> o wait yes?
16:42:32 <benzrf> dfeuer: the point is that instead of defining a real Return and Join, you define constructors that take the appropriate types and artificially assert that they're returning or joining
16:42:36 <benzrf> when all they
16:42:42 <benzrf> 're really doing is papering it over
16:42:53 <benzrf> then later you can decide to come in and do something with the paper'd over structure
16:43:54 <benzrf> @let instance Functor f => Monad (FreeMonad f) where return = Return; join (Return a) = Join a; join j = Join j
16:43:55 <lambdabot>  .L.hs:152:9: ‘join’ is not a (visible) method of class ‘Monad’
16:43:59 <benzrf> wait, that seems wrong
16:44:10 <benzrf> crap i forgot that join isnt the real method
16:44:43 <benzrf> wasnt there a proposal to make (>>=) and join like (==) and (!=)
16:44:50 <trap_exit> I'm looking at my haskell code base; and pretty much all my *.hs files are < 100 files. Am I creating too many modules, or does this sound about right?
16:45:06 <Clint> edwardk: hmm, thanks
16:45:07 <benzrf> trap_exit: sounds cool.
16:45:10 <benzrf> i dunno
16:45:14 <benzrf> its all up to you eh
16:45:22 <trap_exit> I'm trying to get a gist of good practice
16:45:27 <MP2E> benzrf : like (==) and (!=)? Oh you mean implemented in terms of each other
16:45:30 <MP2E> benzrf: that sounds like a great idea
16:45:37 * hackagebot texmath 0.7.0.2 - Conversion between formats used to represent mathematics.  http://hackage.haskell.org/package/texmath-0.7.0.2 (JohnMacFarlane)
16:45:52 <benzrf> wait i mean (/=)
16:45:55 <benzrf> derrr
16:45:56 <MP2E> right
16:45:58 <MP2E> :P
16:46:39 <MP2E> Heh when i see (!=) it's still tricky sometimes to avoid thinking 'not equal'
16:46:46 <MP2E> them imperative languages
16:46:59 <tabemann_> I still read it as "not equal"
16:49:22 <tabemann_> is there any reason that it's (/=) and not (!=) - I know ! has special meanings elsewhere - or is that just arbitrary
16:50:39 <platz>  /= probably looks closer to the mathematical notation of 'not equals'
16:51:09 <tabemann_> that's what I was thinking
16:51:21 <trap_exit> eh
16:51:26 <trap_exit> != looks closer than /= imo
16:51:33 <hpc> @let (!=) = "you can use ! in operators just fine" in (!=)
16:51:34 <lambdabot>  Parse failed: Parse error: in
16:51:43 <trap_exit> ha
16:51:45 <hpc> er
16:51:56 <hpc> > let (!=) = "i suck at lambdabot" in (!=)
16:51:57 <lambdabot>  "i suck at lambdabot"
16:52:00 <platz> != does kind of look like the (not) predicate
16:52:17 <hpc> you mean ¬?
16:52:21 <platz> err, yeah
16:52:48 <platz> maybe it doesn't, oh well
16:52:59 <tabemann_> okay I need to get going now, so I've now got a number of things to read
16:53:56 <ij> I can't figure out how to write something of the type: end :: Point                                                                                                    │|                          |                              │    link/ether 00:a1:b0:00:16:d0 brd ff:ff:ff:ff:ff:ff
16:54:05 <ij> Sorry, clipboard messed up.
16:54:21 <ij> '[[a]] -> [[b]] -> [[(a,b)]]'
16:54:58 <benzrf> :t zipWith zip
16:54:59 <lambdabot> [[a]] -> [[b]] -> [[(a, b)]]
16:55:38 <ij> Thanks!
16:56:21 <benzrf> ya
17:00:44 * hackagebot dns 1.4.2 - DNS library in Haskell  http://hackage.haskell.org/package/dns-1.4.2 (KazuYamamoto)
17:04:12 <Fuuzetsu> ij: I'm hacking your MAC address right now
17:05:50 <benzrf> Fuuzetsu: ( ͡° ͜ʖ ͡°)
17:06:04 <timmy_tofu> Does anyone know how and where to add a ghc-mod GHC flag to set a CPP flag in ghc-mod-vim? That is, I want the command executed to be ghc-mod -g -DDEVELOPMENT blah blah blah when ghc mod is run.
17:06:08 <timmy_tofu> I've tried adding it to l:opts in autoload/ghcmod.vim various ways, but to no avail
17:06:11 <timmy_tofu> There's a b:ghc_mod_options variable as well, but I don't want to do this on a buffer-by-buffer basis, and I haven't tried to see if that even works anyways
17:06:37 <ij> Fuuzetsu, waat
17:13:49 <Arahael_> How do I obtain the current memory usage by my haskell script?
17:14:45 <Arahael_> I want to be able to write (in ghci), 'currentMemory', and have it report on the current memory statistics haskell has for that script in that point of time.
17:14:51 <Fuuzetsu> Arahael_: you ask your system for it, what else
17:14:54 <Fuuzetsu> ah
17:15:01 <Fuuzetsu> hm, I think GHC API exposes something
17:16:09 <Arahael_> Most of the documentation keeps directing me to profiling, but that's not what I want at the moment. Right now I'm using 'top' (with a fairly fast refresh rate), but I'd prefer to have a few points in the script instead.
17:16:33 <Fuuzetsu> http://hackage.haskell.org/package/base-4.7.0.1/docs/GHC-Stats.html perhaps you're after bytesAllocated from that module
17:17:14 <Fuuzetsu> but if you're doing this to see the memory usage then you should be using heap profiling rather than that
17:21:37 <Arahael_> Fuuzetsu: I probably should, but I don't know enough about how to do that within IHaskell Notebook.
17:22:28 <Fuuzetsu> I don't know what IHaskell Notebook is but the general idea is that you compile with -prof and -rtsopts and then add RTS flags to your program to make it spit out some data
17:22:54 <Arahael_> Fuuzetsu: It seems to be a custom ghci-like environment.
17:23:07 <Arahael_> Fuuzetsu: There is no compilation step.
17:24:13 <Fuuzetsu> you don't profile in GHCi either way
17:24:35 <aspidites> i hate to sound so vain but is there a prettier alternative to "foo\ \bar" for multiline strings that isn't as heavy weight as unwords? In particular, I'm using blaze-html and long strings are forcing me to use "p $ H.toHtml $ T.unwords [..]"
17:25:03 <hpc> not really
17:25:16 <Fuuzetsu> I usually end up with concat/unwords then semi-hope GHC gets rid of that
17:25:20 <Fuuzetsu> but I don't think it actually does
17:25:25 <aspidites> darn
17:25:30 <Arahael_> Fuuzetsu: I'm not after profiling.  I am after: "How much memory is used at this point? And how much at this point?", and that's it.
17:25:37 <hpc> template haskell might work
17:25:45 <hpc> but that's not exactly pretty
17:25:59 <aspidites> and seems excessive for the simple case of not forcing a line over 80 chars :P
17:26:17 <aspidites> unless you're talking to Fuuzetsu about something completely different. In which case, whoops
17:27:09 <Fuuzetsu> Arahael_: sounds like profiling to me
17:27:58 <Fuuzetsu> aspidites: I hand formatted some 1000 lines of sample test the other day to not go over 80 …
17:28:05 <Fuuzetsu> then of course I had to change it later
17:28:19 <aspidites> lol. That's what I call dedication
17:28:20 <merijn> aspidites: quasiquoting/TH?
17:28:32 <SrPx> I've installed accelerate by cloning the repo, initialising a sandbox and doing "cabal install". What do I have to do now so GHC recognises the lib (so I can import it with `import Data.Array.Accelerate`)?
17:29:08 <aspidites> ah, quasiquoters may be kind of pretty. I think i even remember seeing a package that did what i want
17:29:18 <aspidites> that's what i get for shrugging TH off so quickly
17:29:21 <Arahael_> Fuuzetsu: Why does that matter?
17:30:13 <aspidites> http://www.haskell.org/haskellwiki/Poor_man%27s_here_document
17:30:40 <Arahael_> Fuuzetsu: I want several things: 1) Peak allocated MB's. (GHC.Stats.peakMegabytesAllocated seems exactly what I want), 2) Some measure of how much RAM I need for this script to provide to the VM (top is fine, I guess). 3) Som measure of how much memory is leaked every time I execute the statement.
17:31:10 <Arahael_> Fuuzetsu: I have _zero_ interest in optimising this code beyond that.
17:31:17 <Fuuzetsu> it matters because you're asking about things profiling tells you but at the same time refuse to use profiling tools
17:31:25 <Fuuzetsu> now now, I never said optimising
17:31:27 <Normangorman> just a quick question: if i run; condition1 && condition2, and condition 1 turns out to be False - will condition2 even be checked?
17:31:37 <Arahael_> Fuuzetsu: Ok, how do I use profiling tools, without compilation?
17:31:39 <Fuuzetsu> no, && short-circuits
17:31:55 <Normangorman> ok, thanks :)!
17:32:15 <Fuuzetsu> Arahael_: you don't; rather, even GHCi and your IHaskell compile anyway, just to really innefficient bytecode
17:32:33 <Fuuzetsu> in fact your memory usage will probably be vastly different unless you actually go and compile
17:32:38 <Arahael_> Fuuzetsu: The script gets sent via ZeroMQ to a haskell "kernel", which then parses and executes the code.
17:32:39 <aspidites> only catch to the quasiquoter is line breaks, but i think with html that wouldn't matter as it'd just get wrapped unless i used an explicit <p>, <br>, or <div>
17:32:43 <aspidites> thanks guys/gals
17:33:02 <SrPx> err anyone? I guess I just have to somehow point GHC to my accelerate directory but I'm not sure how
17:33:19 <Arahael_> Fuuzetsu: I want to have some idea of memory usage within that context.
17:36:47 <Fuuzetsu> SrPx: --add-source ?
17:36:54 <Fuuzetsu> or whatever the command was
17:37:12 <Fuuzetsu> Arahael_: In that case I don't know, I never had such a setup.
17:37:49 <Arahael_> Fuuzetsu: So could we please stop arguing about the 'best' way to 'profile' this?
17:38:03 <SrPx> Fuuzetsu: hm?
17:38:50 <Fuuzetsu> Arahael_: I'm not arguing, I'm just stating what you're asking for while refusing the tools that let you do that. If you have reasons why you can't use those than say earlier.
17:39:38 <Fuuzetsu> SrPx: in your project add-source the accelerate sandbox
17:39:57 <SrPx> hmm okay, but can't I tell GHC to use it for any project?
17:40:04 <SrPx> my project isn't using cabal
17:40:14 <SrPx> it is just a single .hs file, actually I'm just trying to test accelerate
17:40:34 <Fuuzetsu> …it's in a sandbox, what would be the point if it leaked out to all projects?
17:40:50 <Arahael_> Fuuzetsu: Now, that's a fair point.  It is frustrating asking for something, and having people refuse to give an answer because there's a "better" way of doing it though.  As it turns out, GCStats is not available in my environment, so I think I'll restrict myself to some sort of generic  memory monitoring setup.
17:41:13 <SrPx> Fuuzetsu: hm if you say so
17:41:49 <Fuuzetsu> SrPx: you could probably manually pass in -package-db to the path in your accelerate sandbox to GHC
17:43:20 <SrPx> I just don't get it, so anytime I install a library with a sandbox I have to do "cabal init", "cabal sandbox", "cabal add-source path" to use that lib in a hs file? what if I am on GHCI?
17:44:27 <Fuuzetsu> all cabal sandbox does is create a new package database in local directory which the cabal commands will then use
17:44:48 <Fuuzetsu> but GHC doesn't know about sandboxes so you'll have to either cabalise your project or manually tell it where to find this new database
17:45:18 <SrPx> I see... :(
17:45:33 <Fuuzetsu> …or if you're using nix simply drop into a shell with accelerate available ;)
17:45:49 <SrPx> so installing a library from hackage in general is still a really complicated process
17:45:59 <SrPx> Fuuzetsu: I wish I was :(
17:46:22 <SrPx> Fuuzetsu: does it take long to migrate from OSX?
17:46:31 <Fuuzetsu> you can install nix on OSX
17:46:44 <Fuuzetsu> there are a few quirks but there are a lot of people in #nixos which use it
17:46:49 <Fuuzetsu> a lot of OSX people*
17:46:49 <SrPx> ah I was talking about nixos
17:46:58 <Fuuzetsu> well, I do recommend NixOS of course
17:47:25 <SrPx> in nixos installing a lib is simple and unproblematic ? always ?
17:47:46 <Fuuzetsu> well, if I wanted to play with accelerate now I would just do nix-shell -p haskellPackages_ghc783.accelerate
17:47:55 <Fuuzetsu> then ghci would see accelerate
17:48:16 <Fuuzetsu> well, if it built on 7.8.3 that is but I can just change ghc783 to ghc763 or whatever it builds on
17:48:34 <Fuuzetsu> (if it was built already by the build bot it just fetches a binary)
17:50:04 <Fuuzetsu> I can't say it's ‘always’ unproblematic because a single issue makes that a lie but I haven't had any real problems yet and I certainly had much less trouble than with cabal
17:50:54 <trap_exit> are there any particular cpu / memory setup that is good for ghc compilation? most of my 'waiting' time is spent waiting for ghc to compi;e and am now willing to invest in a decent (say $2000 workstation)
17:51:00 <khumba> Question for you all: I want to maintain an environment with a minimum supported version of dependencies for my package (it's HP-2012.4 essentially, for now at least).  I'm considering a Gentoo chroot w/a custom overlay (my system is Gentoo); a Nix installation; or just having a separate Fedora 20 install (since it has 2012.4).  What would you recommend?
17:51:22 <Fuuzetsu> trap_exit: 64-bit Linux is the golden platform but that's all I can say
17:51:37 <trap_exit> I think 64-bit linux is software
17:51:38 <hpc> if the bottleneck is linking, you can try gold
17:51:39 <trap_exit> not hardware :-)
17:51:55 <Fuuzetsu> trap_exit: don't want to cripple the hardware with bad software
17:52:03 <trap_exit> hmm
17:52:11 <ezrios> khumba: Gentoo
17:52:12 <trap_exit> I guess part of the problem is taht I am running ghc inside of a virtualbox ubuntu
17:52:20 <ezrios> you can get pretty minimal with Gentoo
17:52:26 <hpc> it's usually not a hardware issue; for perspective, i can build ghc on a machine with one gig of ram
17:52:31 <ezrios> and tweak things just the way you like
17:52:44 <trap_exit> i think by the time i'm done tweaking gentoo
17:52:44 <ezrios> downsides: upgrading, and configuration is time consuming
17:52:47 <trap_exit> the hardware will be outdated
17:52:51 <dfeuer> trap_exit, compilation tends to care more about CPU  and memory speed than many things. If you can, get fast CPUs, fast RAM, and enough RAM.
17:53:01 <Fuuzetsu> khumba: Setting up a Nix profile with just those dependencies would not be much work but you'd have to spend few minutes getting the exact versions you need onto your system; the upside is that you can use any package versions you want for all other projects
17:53:22 <trap_exit> Fuuzetsu: I'm starting to be convinced that NixOs = the future
17:53:36 <Fuuzetsu> trap_exit: I wish I was paid to do this.
17:54:01 <Fuuzetsu> I guess more people to package and work on stuff is kind of a payment…
17:54:49 <koala_man> if you derive Ord, will the elements of a type always be ordered left to right?
17:54:55 <Fuuzetsu> yes
17:56:02 <dfeuer> And if you derive Enum, they will always be numbered 0 to whatever from left to right.
17:57:48 <koala_man> great, thanks!
17:59:52 <khumba> ezrios, Fuuzetsu: I'm a long-time Gentoo user so that was my first inclination, I actually wrote a script to set up a chroot, but I don't want the haskell overlay removing old packages under me...  I imagine that once I get either of Gentoo/Nix set up, maintaining an overlay vs. a Nix expression would be about the same effort (though Nix may automate Cabal packages more easily than hackport).
18:00:42 <khumba> Thanks :).  Plus Nix can do multiple configurations at once...  Might go with that for a change.
18:01:06 <Fuuzetsu> I can tell you that maintaining a Nix expression would be easier. I ran Gentoo before NixOS and it was not sane especially because I wanted more than one GHC version at once
18:02:14 <Fuuzetsu> (in fact it would take 2 line change for version and sha256 update to bump a dependency)
18:02:25 <khumba> Ah, ha.  Yeah, you'd definitely need a separate chroot for each configuration, since none of the Haskell stuff is slotted.
18:02:50 <khumba> That's really cool.  Just curious, are you using NixOS as well then, or Nix within something else?
18:03:30 <Fuuzetsu> khumba: Correct. And I didn't just need 1 or 2. In the end I purged everything to do with Haskell from portage and installed GHCs to my ~, changing the symlink to them when I needed. I also spent days of my life waiting for same sandboxed packages to recompile because I was changing versions frequently
18:03:35 <Fuuzetsu> it was just not sane
18:07:04 <Rainb> what does "Int -> Maybe a" does?
18:07:52 <Cale> Rainb: That is a type of functions which take a value of type Int, and for any type a, produce a value of type Maybe a
18:08:27 <Fuuzetsu> @djinn Int -> Maybe a
18:08:27 <lambdabot> Error: Undefined type Int
18:08:29 <georgeleege> Hey guys, I just started learning haskell today and I'm going through "Learn you a haskell" right now. ghci keeps throwing parsing errors when I try to bind more than 1 thing using "where"
18:08:32 <Rainb> Oh wow, thanks.
18:08:37 <khumba> Fuuzetsu, okay, that's great to hear, thanks a lot.  Might just end up doing the same.  Heh, it's the haskell overlay that provides nix even.
18:09:15 <Cale> There aren't many functions of this type which produce fully defined results: they pretty much have to result in Nothing for any input, because the implementation doesn't know what type 'a' is, and doesn't have any values of that type to work with.
18:09:15 <Fuuzetsu> I know nothing of installing just nix on Gentoo so I can't help there, I just went straight for NixOS, it's pretty comfy
18:09:24 <godel> georgeleege: post a paste please
18:09:28 <shachaf> georgeleege: What are you writing?
18:09:59 <Fuuzetsu> I'm putting my bet down on hard tabs
18:10:14 <shachaf> georgeleege: (It's hard to guess what invalid syntax you might be using from that description. :-) )
18:10:25 <merijn> georgeleege: Probably you're just running into the fact that ghci has a weird way of parsing multiline declarations
18:10:34 <Cale> georgeleege: Yeah, check that your text editor is configured to convert tabs to spaces
18:10:57 <Fuuzetsu> actually he's using GHCi so that might not be the problem but we won't know until he pastes
18:11:03 <merijn> georgeleege: I usually recommend writing code in a file with your editor and using ":l files.hs" to load into ghci and ":r" to reload changes
18:11:03 <Cale> ah
18:11:06 <Cale> yeah
18:11:13 <georgeleege> by paste do you mean a direct copy and paste?
18:11:17 <georgeleege> sorry first time here
18:11:20 <Fuuzetsu> @lpaste
18:11:20 <lambdabot> Haskell pastebin: http://lpaste.net/
18:11:36 <Fuuzetsu> if it's not long (<=3 lines) you can just paste it into here I suppose
18:11:50 <godel> ^
18:12:27 <shachaf> If it's input to ghci, it's probably one line.
18:12:45 <shachaf> I don't recommend multiline inputs to ghci (though it is possible).
18:12:56 <athan> Who knows of a good way to see if you'll get sued for taking code from an open source project to another with a more liberal license? (Or a better place to ask? Sorry guys :S)
18:12:57 <georgeleege> hmm on my editor the columns are lined up, but on lpaste it's not
18:13:08 <athan> (You're just in general the most knowledgable people I know)
18:13:18 <shachaf> Are you using tabs?
18:13:21 <athan> (insert subtle complement here)
18:13:42 <merijn> athan: You mean, for example, taking GPL code to a BSD project?
18:13:45 <shachaf> GHC treats tabs as 8 spaces (or, actually, as lining up to the next column which is a multiple of 8 characters; but close enough).
18:13:59 <athan> merijn: Exactly, but actually to MIT
18:14:02 <shachaf> The simplest solution is to use spaces instead of tabs for indentation.
18:14:13 <merijn> athan: Right, you can't do that (well, for some value of can't)
18:14:18 <Fuuzetsu> athan: you'll have to conform to their license; if it imposes things you can't satisfy then you can't use it
18:14:21 <athan> merijn: The code is fairly well known, and should be simple to reproduce using the library
18:14:32 <georgeleege> i have tried to use both spaces and tabs, with tabs i need a few spaces as well
18:14:36 <guesting> In parsec, is there a "sepByTill"? Like, separate by ">" untill ">>", so it stops when it sees ">>"?
18:14:43 <merijn> athan: Let's take this to #-blah
18:14:46 <athan> Is there an easy way to break up a repo into multiple licenses?
18:14:57 <athan> merijn: Thank you :)
18:15:08 <solidus-river> is the maintainer of hasklig around?
18:15:27 <georgeleege> http://lpaste.net/109031
18:16:13 <godel> georgeleege: align it with the first declaration
18:16:31 <Fuuzetsu> georgeleege: you have a hard tab in front of ‘where’ as apparent by how it looks like in the paste; set up your ieditor to only use spaces
18:16:41 <Fuuzetsu> s/ieditor/editor/
18:16:44 <georgeleege> godel: in my editor it is. I am going to align in lpaste and then try pasting into my editor
18:17:02 <georgeleege> Fuuzetsu: ok i will see how to do that
18:18:06 <godel> georgeleege: use spaces, not tabs
18:18:18 <godel> everytime you use tabs a kitten dies
18:18:30 <georgeleege> When i lined it up on lpaste and then copied that into my editor it worked. I will see how to make it line correctly in my editor.
18:19:31 <georgeleege> Fuuzetsu: ahh i see i see. my where has a tab whereas everything else was spaced
18:19:54 <Fuuzetsu> yup
18:20:06 <georgeleege> thank you everyone. i will now only use spaces
18:28:11 <timmy_tofu> Anyone know why a snap application would stop responding to ctrl+c? I just get a `user interrupt` message but it doesn't shut down anymore
18:28:40 <timmy_tofu> I end up having to kill it
18:29:14 <benzrf> timmy_tofu: ^C IS killing it
18:29:18 <benzrf> for a given definition of kill
18:29:56 <timmy_tofu> It's not killing it, that's the problem
18:30:19 <timmy_tofu> Not by _my_ definition of kill, anyways
18:30:35 <Fuuzetsu> kill -9 ;^)
18:30:43 <Fuuzetsu> then cry if it's stuck waiting on IO
18:31:22 <hpc> -9 goes through IO i thought
18:31:38 <Fuuzetsu> nope
18:31:43 <Fuuzetsu> at least not in my experience
18:32:00 <hpc> weird
18:32:08 <Fuuzetsu> I got stuck with hung terminals doing ls or whatever to a broken network share far too many times
18:32:55 <hpc> maybe it's a system call thing then?
18:33:15 <hpc> ls is known to have an issue showing huge numbers of files because of parameters to a syscall iirc
18:33:31 <timmy_tofu> I should mention I'm running it via cabal run, though I don't think that should matter (it never has before... ultimately cabal run is just calling the executable in dist anyways)
18:34:16 <Fuuzetsu> apparently you can change the way you mount NFS shares and then the processes will eventually die
18:34:23 <Fuuzetsu> http://lkml.iu.edu/hypermail/linux/kernel/0106.1/0380.html
18:34:31 <Fuuzetsu> but yeah, kill -9 didn't work on this stuf
18:34:46 <fizbin> I seem to keep hitting this pattern: is there a standard idiom for "apply this function until it doesn't change the result"? Or better yet "apply this (a -> Maybe a) until it returns Nothing, and give me the last Just value it returned"?
18:35:05 <Fuuzetsu> hpc: it wasn't just with ls, also if I try to unmount and one time it even stopped df -h from terminating
18:35:20 <Fuuzetsu> at this point I did the sanest thing I could think of and rebooted
18:35:21 <fizbin> I keep hitting this pattern in writing stuff that tries optimizations that might work, but might fail to find anything to make better.
18:35:23 <splintax> fizbin: iterate + takeWhile?
18:35:49 <hpc> weird
18:35:54 <hpc> also i am misremembering the ls bug
18:35:59 <fizbin> splintax: It isn't clear to me how one would use that.
18:36:07 <splintax> trying to write an example now
18:36:23 <Fuuzetsu> :t iterate
18:36:25 <lambdabot> (a -> a) -> a -> [a]
18:36:26 <Fuuzetsu> :t takeWhile
18:36:27 <lambdabot> (a -> Bool) -> [a] -> [a]
18:36:32 <hpc> it reads from getdents in 32k chunks so it has to make thousands of syscalls on a directory with millions of files
18:36:46 <Fuuzetsu> takeWhile isJust $ iterate myFunc
18:36:53 <Fuuzetsu> for some myFunc and isJust
18:37:07 <Fuuzetsu> then take last
18:37:20 <fizbin> Fuuzetsu: iterate isn't going to like that type.
18:37:34 <Fuuzetsu> oh
18:37:42 <Fuuzetsu> :t iterateM
18:37:43 <lambdabot>     Not in scope: ‘iterateM’
18:37:43 <lambdabot>     Perhaps you meant one of these:
18:37:44 <lambdabot>       ‘iterate’ (imported from Data.List),
18:37:48 <Fuuzetsu> I thought there was one
18:38:07 <splintax> takeWhile isJust $ iterate myFunc "seed value"
18:38:21 <Fuuzetsu> http://stackoverflow.com/questions/10801036/iterate-forever-iteratem-repeating-an-action-with-feedback
18:39:01 <Fuuzetsu> it seems you'll have to write one
18:39:52 <Arahael_> Is it possible to programmatically indicate a maximum memory usage for the current script?
18:41:15 <fizbin> Hrm. I could take the last of: takeWhile isJust $ iterate ((=<<) myFunc) (Just seedValue)
18:41:25 <Arahael_> Fuuzetsu: Ideally, the parent process should monitor and limit memory usage, but struggling with the design I'm stuck with.
18:41:36 <fizbin> But that seems worse than just writing my own loop.
18:43:50 <fizbin> ISTR that someone on this channel recently was asking about/dealing with something similar with the signature (a -> Either b a) -> a -> b or something like that that repeatedly applied the function so long as Right was obtained and then returned the innards of the Left that was obtained.
18:44:53 <Arahael_> Nevermind, I've just realised that I might be able to use cgroups for this.
18:45:12 <fizbin> And that's not quite what I want, though I suppose it's trivial to translate that function into what I want, so I guess "repeat until Left" is really just a generalization of what I want.
18:49:39 <splintax> what do you mean by "writing your own loop"?
18:50:41 <fizbin> Huh. I guess I could also maybe use whileJust_ with the State monad.
18:51:16 <merijn> fizbin: Have you looked at monad-loops yet?
18:51:42 <fizbin> merijn: monad-loops is where I got whileJust_ from
18:51:46 <mwhit> @let f = undefined :: a -> Either b a)
18:51:46 <lambdabot>  Parse failed: Parse error: )
18:51:53 <mwhit> @let f = undefined :: a -> Either b a
18:51:56 <lambdabot>  Defined.
18:52:15 <mwhit> :t dropWhile isRight . iterate (f =<<) . return
18:52:16 <lambdabot>     Ambiguous occurrence ‘f’
18:52:17 <lambdabot>     It could refer to either ‘L.f’,
18:52:17 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:149:1
18:52:22 <mwhit> :t dropWhile isRight . iterate (L.f =<<) . return
18:52:24 <lambdabot> b -> [Either a b]
18:52:35 <mwhit> fizbin ^^
18:52:38 <fizbin> Again though, I'm not interested in repeating this computation inside a monad really.
18:53:08 <fizbin> mwhit: Interesting.
18:53:41 <fizbin> :t \f -> head . dropWhile isRight . iterate (f =<<) . return
18:53:42 <lambdabot> (b -> Either a b) -> b -> Either a b
18:54:01 <fizbin> :t lefts
18:54:03 <lambdabot> [Either a b] -> [a]
18:54:08 <benzrf> @djinn (b -> Either a b) -> b -> Either a b
18:54:09 <lambdabot> f a = a
18:54:13 <benzrf> ftfy
18:54:29 <fizbin> :t \f -> head . lefts . iterate (f =<<) . return
18:54:30 <lambdabot> (b -> Either c b) -> b -> c
18:54:45 <mwhit> perfect
18:54:59 <benzrf> looks like unfold
18:55:20 <benzrf> wait
18:55:22 <benzrf> :t iterate
18:55:23 <lambdabot> (a -> a) -> a -> [a]
18:55:31 <benzrf> oh
18:55:53 <benzrf> interesting.
18:56:07 <benzrf> :t (>>=) `asAppliedTo' Right "foo"
18:56:08 <lambdabot> parse error on input ‘Right’
18:56:13 <benzrf> :t (>>=) `asAppliedTo` Right "foo"
18:56:14 <lambdabot> Either a [Char] -> ([Char] -> Either a b) -> Either a b
18:56:25 <mwhit> :t asAppliedTo
18:56:26 <lambdabot> (a -> b) -> a -> a -> b
18:56:53 <mwhit> buh?
18:57:03 <mwhit> > asAppliedTo (: []) 1 2
18:57:05 <lambdabot>  [2]
18:57:09 <mwhit> ohhh
18:57:12 <mwhit> i remember this
18:57:25 <mwhit> it's just for resolving types, right?
18:57:28 <benzrf> ye
18:57:54 <benzrf> > let f (n, v) | n < 10 = Right (n + 1, v ++ "fu") | otherwise = Left "heck no"
18:57:55 <lambdabot>  not an expression: ‘let f (n, v) | n < 10 = Right (n + 1, v ++ "fu") | other...
18:57:56 <benzrf> wait
18:58:15 <benzrf> > let f (n, v) | n < 10 = Right (n + 1, v ++ "fu") | otherwise = Left "heck no" in iterate f (0, "fu")
18:58:17 <lambdabot>  Couldn't match type ‘Data.Either.Either
18:58:17 <lambdabot>                         [GHC.Types.Char] (t, [GHC.Types.Char])’
18:58:17 <lambdabot>                with ‘(t, [GHC.Types.Char])’
18:58:17 <lambdabot>  Expected type: (t, [GHC.Types.Char]) -> (t, [GHC.Types.Char])
18:58:17 <lambdabot>    Actual type: (t, [GHC.Types.Char])
18:58:25 <benzrf> > let f (n, v) | n < 10 = Right (n + 1, v ++ "fu") | otherwise = Left "heck no" in iterate (f =<<) (0, "fu")
18:58:27 <lambdabot>  Couldn't match type ‘(,) t0’
18:58:27 <lambdabot>                with ‘Data.Either.Either [GHC.Types.Char]’
18:58:27 <lambdabot>  Expected type: Data.Either.Either
18:58:27 <lambdabot>                   [GHC.Types.Char] (t, [GHC.Types.Char])
18:58:27 <lambdabot>    Actual type: (t0, (t, [GHC.Types.Char]))Couldn't match expected type ‘(t, ...
18:58:32 <benzrf> ?!
18:58:32 <lambdabot> Maybe you meant: v @ ? .
18:58:42 <benzrf> oh
18:58:48 <benzrf> > let f (n, v) | n < 10 = Right (n + 1, v ++ "fu") | otherwise = Left "heck no" in iterate (f =<<) (Right (0, "fu"))
18:58:50 <lambdabot>  [Right (0,"fu"),Right (1,"fufu"),Right (2,"fufufu"),Right (3,"fufufufu"),Rig...
18:59:22 <fizbin> > let f (n, v) | n < 10 = Right (n + 1, v ++ "fu") | otherwise = Left "heck no" in lefts $ iterate (f =<<) (Right (0, "fu"))
18:59:24 <lambdabot>  ["heck no","heck no","heck no","heck no","heck no","heck no","heck no","heck...
18:59:50 <benzrf> so
18:59:59 <fizbin> > let f (n, v) | n < 10 = Right (n + 1, v ++ "fu") | otherwise = Left "heck no" in head $ lefts $ iterate (f =<<) (Right (0, "fu"))
19:00:00 <lambdabot>  "heck no"
19:00:06 <benzrf> neat
19:00:34 <benzrf> not necessarily total, though
19:01:26 <mwhit> well, neither is unfoldr
19:01:37 <fizbin> benzrf: Depends on how you define "total".
19:02:01 <benzrf> fizbin: not having bottoms
19:02:01 <fizbin> It's more total than functions that don't cover all possible patterns.
19:02:12 <pyon> > cycle []
19:02:14 <lambdabot>  *Exception: Prelude.cycle: empty list
19:02:19 <pyon> Aw. :-(
19:02:35 <mwhit> were you hoping for an extra-empty list
19:02:41 <mwhit> more nothing in it
19:02:49 <pyon> mwhit: I was hoping for a timeout.
19:03:13 <fizbin> > head $ lefts $ iterate (Right =<<) (Right (0, "fu"))
19:03:17 <lambdabot>  mueval-core: Time limit exceeded
19:03:25 <fizbin> Indeed.
19:04:11 <pyon> > fix ([] ++)
19:04:16 <lambdabot>  mueval-core: Time limit exceeded
19:04:35 <fizbin> Though I think I'll write (>>= f) instead of (f =<<) just for readability.
19:04:44 <godel> > head [1,2]
19:04:46 <lambdabot>  1
19:05:03 <HeladoDeBrownie> fizbin, why do you consider (>>= f) to be the more readable of the two?
19:05:11 <godel> > (id . id . id . id . id . id) 5
19:05:13 <lambdabot>  5
19:05:18 <Fuuzetsu> I also tend to go with >>= even if =<< goes in the right direction…
19:05:22 <mwhit> i usually find myself using =<<
19:05:36 <Fuuzetsu> maybe if =<< was in scope by default
19:05:41 <mwhit> it is
19:05:43 <HeladoDeBrownie> Isn't it?
19:05:49 <fizbin> HeladoDeBrownie: Just because >>= is so much more well-known. (since it's in every Monad tutorial out there)
19:05:49 <Fuuzetsu> you have to import it
19:05:54 <mwhit> no you don't
19:06:08 <Fuuzetsu> hm apparently you don't
19:06:12 <pyon> @type (Prelude.=<<)
19:06:13 <lambdabot> Monad m => (a -> m b) -> m a -> m b
19:06:20 <Fuuzetsu> is that a new addition?
19:06:26 <pyon> No idea.
19:06:55 <fizbin> HeladoDeBrownie: Actually, I also will sometimes import (>>>) to use that as though it were (flip (.)), because I find reading long operations left to right easier.
19:06:58 <pyon> I like (=<<) better than (>>=). It is more consistent with the syntax for function application and composition.
19:07:15 <mwhit> i always type it wrong though
19:07:19 <solatis> it reads from right-to-left rather than left-to-right
19:07:28 <mwhit> i keep doing ==< or <<= for some reason
19:07:38 <HeladoDeBrownie> fizbin, makes sense. I try to make everything flow in the same direction if possible, which is why I also end up using (=<<) a bunch
19:07:49 <fizbin> pyon: Right, it is, but I find that the order of function application and composition is occasionally inconvenient.
19:07:52 <mwhit> solatis: no more than function application does
19:08:12 <fizbin> Especially when my function names are English words which I'm reading left-to-right.
19:08:12 <solatis> in one of our Dutch television channels, they periodically give an overview of the upcoming 3 programs
19:08:16 <solatis> they present it like this:
19:08:28 <solatis> Foo >>= Bar >>= Wombat
19:08:43 <fizbin> Too many of those, and I end up importing >>> to use to chain functions.
19:08:50 <chat> hello
19:08:57 <solatis> i always feel there must be a haskeller working in that television studio :)
19:09:15 <chat> I was wondering if anyone could help me out with something
19:09:26 <Fuuzetsu> chat: ask away
19:09:29 <mwhit> chat: just ask, don't ask to ask :)
19:09:30 <solirc> darthdeus: I think `cabal repl` still has it's issues..
19:09:36 <fizbin> solatis: Or maybe the direction of influence was the other way around? Any idea how long they've been doing that?
19:09:56 <chat> do you know about metasploit via downloading and installing by terminal?
19:09:59 <solirc> darthdeus: https://github.com/haskell/cabal/issues/2032
19:10:54 <solatis> fizbin: aha, so the people working at the station have influenced haskell development... that makes so little sense it is funny :)
19:11:30 <Fuuzetsu> Dutch TV confirmed for origin of >>= operator
19:11:42 <fizbin> solatis: There have been stranger cases of something obscure influencing something significantly less obscure.
19:11:51 <chat> fuuzetsu, do you know about metasploit?
19:11:59 <solirc> darthdeus: I use `ghci -isrc -itest -package-db .cabal-sandbox/x86_64-linux-ghc-7.8.3-packages.conf.d test/Spec.hs`
19:12:01 <Fuuzetsu> chat: No.
19:12:18 <Fuuzetsu> I'm not sure if it's even a Haskell thing.
19:12:43 <fizbin> chat: I don't know that #haskell is the right channel to discuss issues installing metasploit, and I'm not sure what would be.
19:13:00 <chat> oh ok, well thanks anyways :)
19:13:26 <julianb> fizbin, #metasploit , maybe?
19:14:35 <fizbin> Maybe. Thing is, I'd be... wary of following advice obtained in channels of metasploit enthusiasts that I couldn't carefully verify before using it.
19:15:41 <fizbin> I mean, I'm sure that *most* metasploit users are perfectly ethical and trustworthy. But there are unethical people out there, and it doesn't seem unreasonable that they'd be drawn to the metasploit community.
19:15:59 <shachaf> At any rate #haskell is not the right place for it.
19:16:51 <solatis> you can always join #nothaskell
19:17:22 <shachaf> That is also almost certainly not the right place for it.
19:21:04 * hackagebot husk-scheme 3.18 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.18 (JustinEthier)
19:21:44 <Fuuzetsu> didn't know R7RS was a thing
19:21:54 <vanila> it's the worst thing that happened to scheme
19:22:02 <johnw> I thought R6 was pretty bad
19:22:03 <vanila> (imo)
19:22:16 <vanila> R5RS is so close to perfect
19:22:27 <vanila> all they needed to do was replace cwcc with shift/reset and add a proper module system
19:22:47 <vanila> but instead they made some horrible long complicated mess
19:25:03 <Fuuzetsu> it's ok, nothing of value was lost
19:29:44 <alpha123> Yeah, with R6 it stopped being so pretty and minimalist. IIRC with R7 they're splitting it into two languages. :/
19:30:34 <vanila> makes no sense, the vote for it only pased by like 51% too
19:32:37 <alpha123> I'm rather torn on if I actually like Lisps or not anyway, and this isn't really helping their case :P
19:34:00 <vanila> lisp is good
19:34:30 <alpha123> I like the idea, I just haven't found a Lisp that I like. I've written quite a bit of stuff in Common Lisp, but it's an ugly language. :/
19:34:43 <vanila> no need to actually program with it, just the history an ideas are important
19:34:57 <alpha123> Haskell seems beautiful, both syntactically and conceptually, but I unfortunately don't understand it well enough to actually do anything :(
19:35:11 <vanila> you''l be doing useful things in haskell in no time
19:35:18 <vanila> this language takes a bit to get startd but its' very powerful
19:36:05 * hackagebot persistent-template 1.3.2.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-1.3.2.2 (GregWeber)
19:37:49 <alpha123> I think I 'invented' monads in JavaScript, but for some reason I can't grok them in Haskell. I'm a web designer/developer and I work pretty much exclusively with JavaScript and Ruby.
19:38:24 <alpha123> Dabbled in Lua and Common Lisp. So yeah, I don't generally like type systems. :P
19:38:57 <splintax> tried Go?
19:39:03 <vanila> yes go sucks
19:39:12 <shachaf> vanila: No language bashing here, please.
19:39:39 <alpha123> Go seems like simple rehashing of old ideas, IMO. It's kind of exactly what we don't need.
19:39:44 <splintax> i started with web dev and used to be a big fan of python but a lot of that community seem to be getting introduced to static typing via go
19:39:52 <vanila> yes
19:39:53 <shachaf> alpha123: Monads don't really make a lot of sense without a type system or at least something equivalent in your head.
19:39:57 <mwhit> the key to understanding monads is to stop reading monad tutorials and just try to write code without them
19:40:04 <mwhit> the use of them will become obvious
19:40:30 <vanila> but go can't do things like [a]
19:40:38 <vanila> you can do [forall a. a], and cast them back to whatever
19:40:49 <vanila> it's really lame
19:40:49 <dolio> The secret is to read N monad tutorials, where when you read the Nth one, you've finally thought about them enough to understand them.
19:40:52 <alpha123> shachaf: Is that necessarily true? e.g. jQuery's arguably a momad, isn't it?
19:41:14 <oakwhiz> mwhit: definitely this
19:41:15 <dolio> Then you go around telling people to read just that last tutorial. But it won't work.
19:41:24 <merijn> The key to understanding monads is: 1) understanding types, 2) understanding typeclasses, 3) learn what the monad instance does for specific types like Maybe, Either, lists and Stte
19:42:15 <splintax> alpha123: i agree with shachaf. jquery can be seen as a monad but that doesn't really help you understand why monads are useful or why they're used in haskell
19:42:47 <shachaf> But there are a lot of things that people call monads in other languages because it's a popular thing to do these days.
19:42:57 <shachaf> Hmm, I was disconnected for about a minute there.
19:43:04 <alpha123> splintax: It helped me figure out that they wrap something
19:43:10 <shachaf> alpha123: No, "jQuery is a monad" is not even a thing that makes sense to say.
19:43:15 <dolio> JQuery does all kind of weird situation-dependent things that make it not a monad.
19:43:26 <shachaf> People like saying it but it's nonsense.
19:43:37 <oakwhiz> can you prove that JQuery follows the monad laws?
19:43:47 <alpha123> I don't believe it does, no. It just gets kinda close.
19:44:17 <glguy> alpha123: Where does it fall short?
19:44:28 <alpha123> I have no idea.
19:44:45 <mwhit> is talking about monads a popular thing now? i've noticed people talking about the idea but they don't like actully using the word from what i've seen
19:44:48 <mwhit> like this: gramming | F# for fun and profit
19:44:49 <dolio> glguy: When you 'map' with jquery, sometimes it flattens and sometimes it doesn't.
19:44:49 <mwhit> fsharpforfunandprofit.com/post
19:44:53 <mwhit> hm
19:44:54 <shachaf> Also, monads aren't such a big deal in Haskell. "Monad" is an abstraction that almost arises naturally with various language features Haskell has, and those features are worth learning. But don't focus on monads.
19:44:56 <mwhit> http://fsharpforfunandprofit.com/posts/recipe-part2/
19:45:07 <mwhit> it's a monad tutorial that never actually uses the word 'monad'
19:45:25 <splintax> i don't think that >>= really exists in jquery
19:45:55 <k00mi> what's the point of calling jQuery a monad? I don't think it helps you write things with jQuery or understand the Monad typeclass
19:46:39 <splintax> agreed. although explaining why it isn't a monad probably helps with the latter
19:46:40 <dolio> Usually the point is to try and help people understand monads.
19:46:42 <Fuuzetsu> does it replace it with ‘burrito’
19:46:54 <shachaf> Fuuzetsu: You are not helping.
19:46:56 <oakwhiz> jQuery is closer to a burrito than a monad
19:47:05 * Fuuzetsu has genuine fear that he'll go to a burrito place and ask for a monad
19:47:08 <mwhit> k00mi: it lets HN hipsters pretend Javascript is cutting-edge
19:47:11 <shachaf> No one who said the word "burrito" in here has ever helped except for byorgey.
19:47:21 <Fuuzetsu> ;_;
19:47:45 <julianb> how is jQuery a monad?
19:47:49 <Fuuzetsu> it isn't
19:47:59 <solatis> mwhit: have you looked into LiveScript? it's pretty awesome
19:48:14 <solatis> it even comes with its own prelude
19:48:20 <shachaf> mwhit: "monad tutorial" is probably only relevant when you're talking about the abstraction "monad", not an individual thing which happens to be a monad.
19:48:37 <merijn> shachaf: I always contend that a burrito is more like a comonad...it's hard to keep things inside
19:48:50 * shachaf sighs.
19:48:59 * merijn is sorry
19:49:02 <Fuuzetsu> shachaf must be so tired of that
19:49:15 <oakwhiz> what we need are more comonad analogies
19:49:21 <shachaf> Anyway, #haskell has this conversation every week and it's never good.
19:49:36 <solatis> oakwhiz: taco's?
19:49:37 <joelteon> what we need are fewer analogies
19:49:45 <Fuuzetsu> and fewer CT puns
19:49:52 <Fuuzetsu> just no fun allowed in general
19:50:05 <mwhit> actually i think the problem has shifted from "too many monad tutorials" to "too much talking about how there are too many monad tutorials"
19:50:07 <joelteon> I've been here long enough to know that fun is irritating
19:50:07 <dolio> Fun is allowed.
19:50:08 <mwhit> so meta
19:50:09 <HeladoDeBrownie> Fuuzetsu, fewer CT puns? I dunno, I could use more fiber in my diet
19:50:12 <dolio> That's why puns aren't.
19:50:18 <shachaf> Is saying the same joke for the 200th time really fun?
19:50:19 <merijn> dolio: :(
19:50:26 <alpha123> I don't think I have the gonads for monads. :(
19:50:32 <mwhit> ^^^
19:50:32 <shachaf> The only joke is that it's a reference to something that people tend to say in here.
19:50:33 * alpha123 ducks
19:50:39 <joelteon> Yes. The 201st is the problem.
19:50:44 <mwhit> @quote
19:50:45 <lambdabot> DanPascu says: For God's sake, have mercy on us. I'm no mathematician, yet I find 'patch commutation' to sound reliable and trustworthy. 'Patch Flipping' sounds like a drunken monkey doing rollovers
19:51:05 <mwhit> @remember alpha123 I don't think I have the gonads for monads. :(
19:51:06 <lambdabot> I will never forget.
19:51:19 <shachaf> Really?
19:51:21 * shachaf sighs.
19:51:22 <mwhit> i like it
19:51:26 <HeladoDeBrownie> That doesn't bother me so much for the rhyme as for the sexist connotations
19:51:32 <joelteon> We disappointend shachaf again.
19:51:39 <joelteon> Come on, #haskell.
19:51:49 <joelteon> also, s/end/ed/
19:51:50 <mwhit> HeladoDeBrownie: both sexes have gonads?
19:51:51 <alpha123> HeladoDeBrownie: Women have gonads too :P
19:51:54 <k00mi> well, not everyone has heard the same joke for the 200th time
19:51:59 <HeladoDeBrownie> I know
19:52:11 <alpha123> though I suppose it's implied to be referring to male gonads
19:52:13 <HeladoDeBrownie> but it… seems like a replacement for "balls"
19:52:16 <HeladoDeBrownie> Yes
19:52:32 <mwhit> it's literally the non-sexist version of that though
19:52:35 <joelteon> Having this discussion is really scraping the bottom of the sexism in computing barrel.
19:52:44 <joelteon> It might even be below the bottom of the barrel.
19:52:57 <fizbin> I've only ever seen "gonads" used as a replacement for "balls" meaning grit when people were trying to make the sentence non-gender-specific.
19:53:15 <HeladoDeBrownie> The fact is it's irrelevant to the subject matter
19:53:34 <HeladoDeBrownie> And I'll finish at that as joelteon seems to think it's not worth discussing
19:53:40 <joelteon> Thanks.
19:54:00 <joelteon> Besides, nobody ever uses @quote. It'll be a non-issue in half an hour.
19:54:01 <fizbin> I know! What do people think about indentation?
19:54:16 <fizbin> Because that flame war is always fun.
19:54:24 <nobody`> @quote
19:54:25 <lambdabot> ex0r says: if map was a woman she could probably handle infinite arguments
19:54:42 <joelteon> No, we want to get off sexism.
19:54:52 <mwhit> haha what are the odds
19:54:54 <HeladoDeBrownie> The sad thing is that was a random quote
19:54:55 <alpha123> Bad choice, lambdabot >_<
19:55:03 <fizbin> Speaking of sexist connotations...
19:55:11 <HeladoDeBrownie> Could we get *that* quote removed at least?
19:55:23 <dolio> @forget ex0r if map was a woman she could probably handle infinite arguments
19:55:24 <lambdabot> Done.
19:55:26 <HeladoDeBrownie> Thanks.
19:55:37 <fizbin> Sexist, and they forgot to use the subjunctive.
19:55:59 <alpha123> Nobody uses the subjunctive except in legal documents anyway
19:56:17 <joelteon> If someone were to use the subjunctive in conversation, I'd slap them.
19:56:20 <fizbin> No, I use it all the time.
19:56:23 <HeladoDeBrownie> joelteon, :P
19:56:40 <HeladoDeBrownie> Apparently joelteon makes a habit of slapping themself
19:56:41 <mwhit> what even is the english subjunctive, i only know it in french
19:56:44 <mwhit> if map *were*?
19:56:51 <HeladoDeBrownie> mwhit, right
19:56:57 <mwhit> gotcha
19:57:03 <alpha123> fizbin: I suggest you not use it, lest you confuse people.
19:57:35 <HeladoDeBrownie> If the subjunctive confused people, I'd have a lot of confused people on my hands.
19:57:40 <fizbin> "was" used as subjunctive grates on my ears. I'd cringe when the chorus came on of that song from... two decades or so ago ... that had line "damn! Wish I was your lover"
19:58:05 <fizbin> It's not confusing, it just doesn't sound right.
19:58:26 <alpha123> mwhit: I'm a native English speaker and frankly I barely recognize it in English. We don't really use it.
19:58:47 <mwhit> i am too, that's why it's silly i only know the french
19:58:53 <alpha123> fizbin: It was a bad joke. =P
19:58:55 <alpha123> mwhit: oh, lol
19:59:27 <HeladoDeBrownie> It's certainly degraded in use, but it still shows up. It's a lot more obvious in Spanish, in my opinion, since it conjugates differently.
19:59:43 <johnw> this may be getting too off-topic...
19:59:47 <mwhit> we should just go the chinese route, no conjugations ever
19:59:48 <mwhit> true
19:59:48 <alpha123> It's very subtle in English, so it probably does show up more than I give it credit for.
19:59:51 <mwhit> i think we've hit the time limit
19:59:51 <joelteon> #haskell-blah
20:00:01 <alpha123> johnw: You're just looking at this conversation through the wrong... lense.
20:00:04 <alpha123> *lens
20:00:14 <fizbin> @quote
20:00:15 <lambdabot> AlanPerlis says: It is easier to write an incorrect program than understand a correct one.
20:00:33 <fizbin> (Since that worked to change the topic last time)
20:00:42 <mwhit> that's a silly one
20:00:53 <mwhit> it's easier to write an incorrect program than...most anything
20:00:54 <alpha123> There should be a 'to understand' there
20:01:02 <mwhit> qpwoeijfqpo <- incorrect program
20:01:08 <alpha123> Though I guess that's barely changing the topic from grammar
20:01:30 <HeladoDeBrownie> mwhit, isn't there a difference between incorrect and ill-formed?
20:02:00 <mwhit> ok, main = return ()
20:02:25 <HeladoDeBrownie> That's a perfectly correct program, if you wanted it to do nothing of consequence. :) A program's correctness is relative to a specification.
20:03:23 <HeladoDeBrownie> That's part of why it's apparently impossible to ensure there are no bugs - The spec could be "bugged" too, albeit maybe in a different sense.
20:04:05 <fizbin> I contend that the statement is ignoring that the space of incorrect programs is much, much larger than the space of correct programs. There certainly exist incorrect programs which are more difficult to write than some correct programs are to understand.
20:04:10 <oakwhiz> HeladoDeBrownie: Try telling that to your boss :-)
20:04:31 <HeladoDeBrownie> oakwhiz, what would my hypothetical boss think of that statement, hypothetically?
20:04:52 <HeladoDeBrownie> fizbin, sure, but picking one out of that space? Easy, no?
20:05:32 <fizbin> However, it may well be that (minimum $ map writingDifficulty $ filter incorrect $ programs) < (minimum $ map readingDifficulty $ filter correct $ programs)
20:05:45 * hodapp thwaps fizbin.
20:06:39 <HeladoDeBrownie> I would easily believe that, with not much additional weight of evidence.
20:07:34 <HeladoDeBrownie> Although I think your program is incorrect :)
20:08:01 <HeladoDeBrownie> Orrr I misread it, never mind :P
20:20:27 <koala_man> if I'm in ErrorT SomeThing IO () and I have a IO () I watch to `catch` and throwError Something for, how would I do it? There doesn't appear to be a liftCatch for ErrorT
20:23:20 <fizbin> @type groupWith
20:23:22 <lambdabot> Not in scope: ‘groupWith’
20:26:44 <lispy> :t groupBy
20:26:46 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
20:29:18 <glguy> :t \m f -> either throwError return =<< lift (catch (runErrorT m) (\e -> runErrorT  (f e)))
20:29:19 <lambdabot> (MonadError a (t IO), MonadTrans t, Exception e) => ErrorT a IO b -> (e -> ErrorT a IO b) -> t IO b
20:30:01 <benzrf> @let (.:) = (.) . (.)
20:30:03 <lambdabot>  Defined.
20:30:46 <benzrf> @let jump v x y = abs (x - y) > v
20:30:48 <lambdabot>  Defined.
20:31:02 <benzrf> > groupBy (jump 3) [1, 2, 5, 2, 8, 9, 10, 40, 39]
20:31:04 <lambdabot>  [[1],[2],[5],[2,8,9,10,40,39]]
20:31:08 <benzrf> o.o
20:32:30 <glguy`> Group by expects an equivalence
20:34:04 <glguy`> And each member of the group is tested against the first member of the group, not its neighbor
20:34:53 <shlevy> Am I right in thinking that ghc could theoretically automatically parallelize evaluation of strict arguments to a function? Does it?
20:35:25 <benzrf> oh i see
20:35:34 <johnw> shlevy: no automatic parallelization ever happens
20:35:37 <benzrf> > groupBy (not . jump 3) [1, 2, 5, 2, 8, 9, 10, 40, 39]
20:35:39 <lambdabot>  Couldn't match type ‘GHC.Types.Bool’ with ‘a -> GHC.Types.Bool’
20:35:39 <lambdabot>  Expected type: GHC.Types.Bool -> a -> GHC.Types.Bool
20:35:40 <lambdabot>    Actual type: GHC.Types.Bool -> GHC.Types.BoolCouldn't match type ‘a -> GHC...
20:35:40 <lambdabot>  Expected type: a -> GHC.Types.Bool
20:35:40 <lambdabot>    Actual type: a -> a -> GHC.Types.Bool
20:35:43 <benzrf> > groupBy (not .: jump 3) [1, 2, 5, 2, 8, 9, 10, 40, 39]
20:35:45 <lambdabot>  [[1,2],[5,2,8],[9,10],[40,39]]
20:35:47 <shlevy> johnw: Would it be semantically sound?
20:35:50 <benzrf> hella
20:35:55 <alpha123> johnw: He did say "theoretically"
20:36:08 <shlevy> alpha123: I also asked if it actually happened :)
20:36:16 <johnw> he ended the question with "Does it?"
20:38:58 <shlevy> johnw: Do you know why nothing automatic ever happens?
20:39:10 <johnw> granurality
20:39:13 <johnw> granularity
20:39:20 <shlevy> Hm?
20:39:23 <johnw> it can cost more to setup parallelization than it does to do the work serially
20:39:27 <shlevy> Sure
20:39:33 <johnw> only a human knows when and where to apply it effectively
20:39:35 <shlevy> But can't the compiler take that into account in deciding?
20:39:36 <shlevy> Ah OK
20:39:38 <johnw> (or at least, so it goes today)
20:39:54 <johnw> if you imagine a JIT-like system which is constantly profiling and sampling, it could know more
20:40:17 <johnw> and there have been speculative parallelization efforts that have shown promise
20:40:37 <lispy> Just-In-Time-Parallelization!
20:41:23 <Boney> johnw, shlevy: Automatic parallelisation is possible.  It's possible for the machine to know _better_ than the human the effects of granuality,
20:41:38 <Boney> and even dependance and determine when parallelisation is worth while.
20:42:00 <Boney> http://www.mercurylang.org/documentation/papers.html#pbone_phd_thesis
20:44:19 <lispy> shlevy: I think it's semantically equivalent in the absence of bottom
20:44:54 <shlevy> lispy: If the arguments are strict, bottom still catches you no?
20:45:08 <lispy> not all bottoms are the same operationaly
20:45:27 <shlevy> Ah fair enough
20:45:33 <shlevy> infinite loop vs throwing an error you mean?
20:45:38 <lispy> yeah
20:46:42 <shlevy> Curious if that's required in the spec
20:46:51 <shlevy> Well
20:46:58 <shlevy> Is any argument evaluation order required?
20:47:45 <shlevy> Hmm when you pattern match does it force arguments from left to right or in any order?
20:48:46 <shlevy> Ah never mind
20:48:50 <shlevy> There are no multi-argument functions
20:48:56 <shlevy> So it's gotta be left to right
20:49:43 * shlevy should stop using #haskell as his rubber duck, sorry
20:50:02 <Boney> What if you match a data term or tuple, after evaluating it to WHNF what order do you evaluate it's arguments in?
20:50:16 <Boney> eg in:
20:50:23 <Boney> foo (1, 2) = ...
20:50:34 <Iceland_jack> shlevy: It depends on which arguments you match on
20:50:58 <Iceland_jack>     foo _ [] = []
20:50:58 <Iceland_jack>     foo [] _ = []
20:50:58 <Iceland_jack> inspects the second argument first
20:50:58 <shlevy> Boney: I'd assume tuple is equivalent to data Pair a b = Pair a b
20:50:59 <fizbin> shlevy: I find lambdabot in a /msg conversation makes for an excellent rubber duck sometimes.
20:51:10 <cmccann> GHCi claims that the element type parameter to StorableArray has role "phantom". that sounds slightly fishy.
20:51:16 <shlevy> Iceland_jack: No it doesn't, it just doesn't need to evaluate its first param at all
20:51:20 <shlevy> Oh
20:51:22 <shlevy> never mind
20:51:24 <shlevy> ignore my nonsense
20:51:27 <Iceland_jack> shlevy: What do you mean?
20:51:37 <Boney> shlevy: Yep, so which of the arguments to Pair do you evaluate first?
20:51:39 <shlevy> I forgot you could pattern match like that
20:52:07 <Boney> Np.
20:52:17 <shlevy> Boney: I'd guess the first one. Since Pair is a function which returns a function from b to Pair
20:53:04 <Boney> shlevy: I'm not sure it's modeled like that operationally.
20:53:25 <shlevy> Yeah me neither
20:53:25 <enthropy> cmccann: seems ok so long as sizeOf for both types is the same
20:53:51 <enthropy> and maybe alignment too
20:53:54 <shlevy> Semantically it seems like how it has to work, but the existence of pattern matches like Iceland_jack's means that the conceptual desugaring of case statements gets complex then
20:55:01 <cmccann> enthropy: that's not terribly reassuring
20:55:37 <cmccann> I mean it's basically a pointer to a chunk of memory intended mostly for C interop so I guess it doesn't matter that much but still
20:56:40 <enthropy> cmccann: any idea why ghci doesn't always print the role?
20:57:00 <cmccann> no idea
20:57:06 <cmccann> I've been out of the loop for a while anyway
20:57:10 <enthropy> :info Ptr StorableArray -- only prints the role for Ptr
20:57:14 <enthropy> err, for StorableArray
20:57:46 <enthropy> but I can still    coerce (p :: Ptr Int) :: Ptr (Sum Int)
20:59:04 <lispy> shlevy: Checkout the report. It's pretty readable.
20:59:21 <lispy> shlevy: IIRC, the report doesn't define evaluation order.
21:00:05 <lispy> https://www.haskell.org/onlinereport/haskell2010/
21:00:18 <shachaf> I wish there was a one-page version of the Report.
21:00:56 <enthropy> http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-600003.17.2
21:00:58 <glguy> shachaf: Like this? http://www.haskell.org/definition/haskell2010.pdf or like a single printed page?
21:01:20 <shachaf> I mean a single HTML page, though the PDF is something.
21:01:43 <shachaf> I want to be able to search easily and link to sections easily and so on.
21:02:00 <haasn> shachaf: I would be in favor of that as well
21:02:22 <lispy> where does the source of the report live?
21:02:31 <haasn> shachaf: Have you suggested something like this to the GHC team or on the tracker? I wonder how hard it would be to modify GHC's documentation system to produce a single-page summary
21:02:32 <glguy> Yes, *someone* should do that
21:02:53 <enthropy> finding that x8-600003.17.2 should have been easier
21:02:57 <shachaf> haasn: I'm not sure the Report has anything to do with GHC.
21:03:13 <haasn> Oh, wait; I was thinking of the GHC user's manual
21:03:18 <haasn> Not the online report
21:03:20 <haasn> My bad
21:03:27 <shachaf> Both would be fine to have one-page versions for.
21:03:28 <cmccann> Haskell, GHC, what's the difference, right
21:03:35 <shachaf> Everything ought to have a one-page version.
21:04:15 <cmccann> <shachaf> I want a one-page version of Wikipedia. The whole thing.
21:04:50 <lispy> http://darcs.haskell.org/haskell2010-report/
21:04:51 <shachaf> <cmccann> I love monoids. They are so easy.
21:04:58 <lispy> that appears to be the source of the report
21:05:37 <cmccann> well, monoids ARE so easy. what's not to like, really?
21:06:09 <tabemann> hmph - from reading deeper into A Gentle Introduction to Category Theory, it seems like they like jumping over steps, assigning things to the reader, and assuming the reader understands the notation
21:07:13 <ceramic-houses> wikipedia is anti capitalist and unreliable
21:07:32 <glguy> It's all lower-case there, eh?
21:07:59 <lispy> glguy: Yes, except it's unreliably that way :(
21:08:13 <haasn> cmccann: Doable! Download a nightly backup and merge it into a single document
21:09:05 <glguy> Do they still make those available?
21:09:11 <glguy> I thought they stopped years ago
21:09:30 <cmccann> I hope they do. otherwise how will shachaf get his one-page version?
21:09:56 <benzrf> cmccann: lol;'
21:10:05 <benzrf> * ceramic-houses
21:10:11 <shachaf> cmccann: I believe I once downloaded an XML file containing all of Wikipedia.
21:10:12 <glguy> with the wiki monoid, you can append pages and then there's the empty page
21:10:29 <benzrf> ah but
21:10:34 <benzrf> appendingin the empty page is
21:10:37 <benzrf> not iden
21:10:50 <glguy> It is in the single page view
21:10:54 <glguy> We had a full dump of wikipedia a few years back
21:11:08 <glguy> for a wiki oriented project at work
21:11:14 <cmccann> shachaf: of course you did. I'd expect no less.
21:11:31 <shachaf> i,i "of course you did. I'd expect no more."
21:11:47 <glguy> shachaf: Don't worry, *I* expect no less
21:12:12 <shachaf> cmccann expects the lub
21:12:54 <cmccann> I'm not sure my expectations have a well-defined ordering, to be honest.
21:13:14 <shachaf> all expectations can be well-ordered
21:17:43 <haasn> glguy: http://dumps.wikimedia.org/enwiki/
21:18:41 <glguy> awesome
21:18:50 <haasn> See also https://meta.wikimedia.org/wiki/Data_dump_torrents
21:18:59 <tac_> ooooh
21:19:38 <Total_1mmersion> Is Set a monad?
21:19:46 <haasn> Total_1mmersion: No
21:20:00 <tac_> @kind Set
21:20:01 <haasn> It's not even a Functor
21:20:01 <lambdabot>     Not in scope: type constructor or class ‘Set’
21:20:01 <lambdabot>     Perhaps you meant one of these:
21:20:02 <lambdabot>       ‘S.Set’ (imported from Data.Set),
21:20:05 <Total_1mmersion> But it could be, right?
21:20:09 <tac_> @type Set
21:20:11 <lambdabot> Not in scope: data constructor ‘Set’
21:20:14 <tac_> :(
21:20:17 <Axman6> no with Haskell's current definition of Monad
21:20:18 <haasn> Total_1mmersion: Depends on what you mean by “could”
21:20:21 <lispy> Total_1mmersion: the only thing holding it back is the Ord constraint
21:20:26 <haasn> Total_1mmersion: you can't really write an instance for it
21:20:30 <tac_> The problem is State has a typeclass constraint on it
21:20:37 <tac_> err Set*
21:21:09 <Axman6> (>>=) would need type (Ord b) => Set a -> (a -> Set b) -> Set b
21:21:17 <haasn> Axman6: Alternatively: Not with Data.Set's current definition of Set
21:21:27 <shachaf> Codensity to the rescue!
21:21:35 <haasn> It is possible to make a Set-like type which works like Set in specific cases and like [] in others
21:22:41 <haasn> Axman6: Do you know if there is a definition of Monad that permits Set?
21:22:56 <haasn> A *sane* definition of Monad
21:22:57 <Total_1mmersion> oh I see, Monad doesn't constrain the type parameters
21:23:18 <Axman6> I've felt that many type classes should include a Constraint kinded type family for things like that
21:23:26 <danclien> Has anyone used persistent with PostgreSQL's enumerated types?
21:24:40 <Axman6> class Monad m where data MonadConstr m a b :: Constraint; (>>=) :: MonadConstr m a b => m a -> (a -> m b) -> mb
21:24:52 <Axman6> but I'm sure there's issues I haven't thought about
21:25:00 <Axman6> because I haven't thought about it deeply
21:25:03 <haasn> How much of a hassle would having to pass around this constraint in generalized Monad code be?
21:25:15 <joelteon> how do you quantify hassle
21:25:23 <haasn> sequence :: (Monad m, ???) => [m a] -> m [a]
21:25:33 <haasn> @src sequence
21:25:33 <lambdabot> sequence []     = return []
21:25:34 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:25:34 <lambdabot> --OR
21:25:34 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:25:55 <haasn> Would return :: MonadConstr m a a => a -> m a -- ?
21:26:17 * hackagebot hspec 1.11.1 - A Testing Framework for Haskell  http://hackage.haskell.org/package/hspec-1.11.1 (SimonHengel)
21:26:19 * hackagebot hspec-meta 1.11.1 - A version of Hspec which is used to test Hspec itself  http://hackage.haskell.org/package/hspec-meta-1.11.1 (SimonHengel)
21:26:23 <spopejoy> arrgh. in an IO ‘do’ block, how might i do something like c <- mconcat (map getDirectoryContents [“/foo/bar”,”/baz”])
21:26:54 <Axman6> mapM?
21:27:01 <merijn> spopejoy: You are probably looking for mapM
21:27:03 <merijn> and/or sequence
21:27:07 <merijn> :t sequence
21:27:09 <lambdabot> Monad m => [m a] -> m [a]
21:27:09 <merijn> :t mapM
21:27:10 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
21:27:28 <spopejoy> thanks, my hoogling wasn't cutting it
21:27:29 <Axman6> :t mapM getDirectoryContents
21:27:30 <lambdabot> Not in scope: ‘getDirectoryContents’
21:27:42 <merijn> :t \f -> sequence . map f
21:27:43 <lambdabot> Monad m => (a1 -> m a) -> [a1] -> m [a]
21:28:21 <Axman6> :t mapM (undefined :: FilePath -> IO [FilePath]) -- is that the right type?
21:28:22 <lambdabot> [FilePath] -> IO [[FilePath]]
21:28:47 <haasn> I asked GHC, and it said that sequence :: (Monad m, MonadConstr m [a] [a], MonadConstr m a [a]) => [m a] -> m [a]
21:28:54 <ceramic-houses> does haskell work fine on freebsd?
21:29:07 <Axman6> ceramic-houses: sure
21:29:24 <haasn> ceramic-houses: GHC supports it as a tier-1 platform, next to Mac OS X, Linux x86 and Windows
21:29:27 <haasn> https://ghc.haskell.org/trac/ghc/wiki/Platforms
21:29:38 <haasn> Which is pretty much the best support you could ask for
21:29:41 <spopejoy> yep that's it: c <- mapM getDirectoryContents ["a","b"]
21:29:47 <lispy> ceramic-houses: Sometimes template haskell and ghci don't work on the some platforms. Not sure if freebsd is in that category.
21:30:22 <merijn> ghci and TH work just fine on freebsd
21:30:27 <merijn> At least, they did years ago
21:30:29 <Axman6> :t traverse (undefined :: FilePath -> IO [FilePath]) (undefined :: [FilePath])
21:30:30 <lambdabot> IO [[FilePath]]
21:30:38 <haasn> There is a summary on the wiki page I mentioned
21:31:18 * hackagebot haskell-brainfuck 0.1.0.0 - BrainFuck interpreter  http://hackage.haskell.org/package/haskell-brainfuck-0.1.0.0 (paraseba)
21:32:21 <tabemann> of all things you use Haskell for, you use it to write a BrainFuck interpreter
21:32:29 <benzrf> i did that
21:32:33 <mwhit> write a Haskell compiler for Brainfuck and i'll be impressed
21:32:40 <mwhit> *in branfuck
21:32:48 <haasn> http://www.haskell.org/definition/ whoa, this page seems quite desynchronized with the rest of haskell.org
21:32:53 <haasn> missing images, broken links
21:34:04 <tabemann> I've always toyed with the idea of writing a compiler for some language that *targets* brainfuck
21:34:04 <Total_1mmersion> mwhit, it would probably be easier to write a Haskell -> BF compiler in Haskell, write a Haskell compiler in Haskell, then compile it to BF.
21:34:57 <tabemann> it'd probably be easiest to have the Haskell compiler be in Haskell, and write an LLVM > BF layer
21:36:17 <tabemann> I'm not sure how efficient the code output by an LLVM to BF translator wouldbe though, but then BF isn't a very efficient language for handling general cases
21:37:28 <dfeuer> When people on StackOverflow ask how to obfuscate code, I tend to recommend things like writing their program as interpreted BF in INTERCAL.
21:39:52 <haasn> shachaf: It seems like the online report is generated from TeX source using tex4ht to produce a HTML file. From tex4ht's documentation, it seems like the feature to split up sections into separate pages is optional. I haven't looked at it more closely but if you really want it it would probably be rather simple to modify the tex4ht invocation to produce a single-page version for yourself
21:40:28 <shachaf> haasn: Well, I'd like it to be officially available too.
21:40:55 <benzrf> :t lens
21:40:56 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
21:41:56 <haasn> shachaf: “If you render the report in a new way that others may wish to use, please let us know and we'll add it to this web page.” Heh
21:42:17 <shachaf> haasn: Oh.
21:42:21 <shachaf> Perhaps I'll do that.
21:42:34 <haasn> That's from the “outdated” page (concerning the Haskell 98 report) I posted earlier
21:42:44 <haasn> But I can't imagine the stance on Haskell 2010 being any different
21:43:00 <haasn> Bugs and suggestions are meant to be sent to the haskell-prime mailing list, so maybe that's a good place to discuss this
21:43:46 <shachaf> You should do it! You're almost there already.
21:44:15 <tabemann> is the haskell-prime mailing list still active, considering that Haskell 2010 has been out for a while now?
21:44:27 <benzrf> hmmm
21:44:36 <benzrf> does Control.Lens have something for list zippers
21:44:40 <shachaf> haskell-prime is the process to update Haskell.
21:45:07 <tabemann> oh okay so it's still active, for whatever will follow Haskell 2010
21:45:54 <lispy> tabemann: correct
21:46:31 <edwardk> benzrf: we have a zippers package that can do a bunch of stuff with zipping into arbitrary containers
21:46:51 <SrPx> How can I expect Accelerate to perform as opposed to coding CUDA/OpenCL directly? Is it the same perf or much slower? I guess it would be much slower, or else why someone would use CUDA/OpenCL.
21:46:52 <haasn> shachaf: Yikes; building the Haskell2010 report requires using tools clearly written for some really old version of GHC
21:47:00 <haasn> It still has the -fglasgow-exts and haskell98-style modules
21:47:14 <haasn> Maybe I should update it to modern GHC.
21:47:36 <benzrf> edwardk: just an offhand question more than anything
21:47:49 <benzrf> im minorly refactoring my little brainfuck interp
21:48:04 <edwardk> benzrf: did you see the old brainfuck interpreters distributed with lens?
21:48:23 <haasn> zippers is awesome
21:48:29 <haasn> especially for interpreting brainfuck
21:48:31 <tabemann> what I'd be interested in seeing in a brainfuck interpreter is one that optimizes out a lot of the loops and converts them into non-looping code
21:48:35 <edwardk> haasn: got bored and wrote a bunch
21:48:42 <edwardk> er haasn got bored and wrote a bunch
21:48:55 <tabemann> I used to use a brainfuck interpreter written in Python that did that
21:49:09 <edwardk> the code they need has since been moved out to the zippers package, not  sure if they moved with it
21:49:24 <lispy> tabemann: I think the one I wrote for lambdabot used to do that (depending on what you have in mind)
21:49:26 <benzrf> edwardk: bleh
21:49:48 <lispy> I think it was eventually removed from lambdabot
21:50:11 <shachaf> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
21:50:12 <lambdabot>   <
21:50:15 <platz> I'm guessing, the lens-based zippers are superior to the classic zipper in every way
21:50:17 <shachaf> Nope.
21:50:27 <edwardk> platz: of course =)
21:50:32 <shachaf> (But please send further queries in /msg unless they're relevant to the channel.)
21:50:34 <sclv> maybe
21:50:49 <platz> :)
21:51:01 <shachaf> lens-based zippers are pretty different from the usual notion of a zipper.
21:51:05 <shachaf> Well, moderately different.
21:51:11 <edwardk> platz: except maybe that whole pesky 'ease of use' thing
21:51:22 <shachaf> They don't let you do the same things, either.
21:51:27 <haasn> How  Top :>> [a] :>> a  actually compare to Zipper a
21:51:30 <haasn> How does*
21:51:38 <shachaf> A superset of a subset of the same things.
21:51:44 <lispy> tabemann: see the optimize function: https://hackage.haskell.org/package/brainfuck-0.1/src/Language/Brainfuck.hs
21:52:03 <haasn> edwardk: they did
21:52:45 <haasn> SrPx: I can't answer your first question but I can answer your second: Because Accelerate only has backends that support Nvidia right now
21:53:04 <edwardk> haasn: the main thing is that the path you took down at least in terms of intermediate types shows up in your zipper type in lens
21:53:08 <edwardk> this has the benefit you can change types
21:53:15 <edwardk> this has the cost that it shows up
21:53:23 <haasn> Does somebody know how to port haskell98's Prelude.catch to Control.Exception.catch? Is just using IOException instead of IOError enough? All it does is call “show”
21:53:29 <haasn> And output that to stdout
21:53:32 <benzrf> this is my brain fuck
21:53:33 <benzrf>  http://lpaste.net/109039
21:53:42 <SrPx> haasn: hmm I see, that makes me even more interested on the answer
21:53:44 <haasn> (Control.Exception.Lens is not an option)
21:53:57 <c_wraith> haasn: catch a SomeException and show it
21:54:03 <SrPx> wish someone did a few benchmarks, accerelate/haskell seems orders of magnitudes easier to deal with
21:54:10 <haasn> c_wraith: Does the old catch really behave like SomeException?
21:54:27 <lispy> SrPx: Have you checked the accelerate publications?
21:54:28 <tabemann> benzrf: okay, so yours isn't an optimizing brainfuck
21:54:33 <haasn> It had IOError instead of Exception e => e
21:54:47 <c_wraith> haasn: well...  Sort of. It only worked for a single exception type, because there only was a single exception type
21:54:47 <SrPx> lispy: not yet, I'm midway reading a book on OpenCL right now ):
21:54:50 <platz> shachaf: hrmm, I think there were a few different versions of the "classic" zipper.  the one on hackage I think is different from Gerard Huet's paper
21:55:01 <benzrf> tabemann: pfft
21:55:02 <benzrf> who has time for that
21:55:08 <haasn> c_wraith: Makes sense
21:55:16 <tabemann> I don't think I've ever written an optimizing brainfuck either
21:55:28 <platz> if there's anything different it might be with the "context" part
21:55:29 <benzrf> the only 'clever bit' in mine is offloading paren-balancing to parsec
21:55:58 <hae> You know what's interesting? Binary lambda calculus.
21:56:05 <hae> Do we have an interpreter for that?
21:56:35 <benzrf> i just found a downside to Nix
21:56:43 <benzrf> no man pages :'(
21:57:06 <haasn> hae: Is this related to Iota/Jot?
21:58:09 <tabemann> what's the language that's like unlambda but instead is pure? is that Iota?
21:58:15 <haasn> tabemann: Lazy K
21:58:37 <haasn> Iota is like SKI but based on only one combinator, I
21:58:53 <haasn> with I x = ``xSK
21:59:20 <tabemann> is that actually turning-complete?
21:59:30 <Axman6> yes
21:59:32 <benzrf> haasn: type of I?
21:59:42 <benzrf> i cant read your nonsense unlambda
21:59:55 <haasn> Oh, unfortunate naming, I here is not to be confused with I x = x from SKI
22:00:28 <haasn> But with this I you can define K = I(I(II)) and S = I(I(I(II)))
22:00:36 <aji> did i hear SKI calculus?
22:00:38 <aji> and iota? :D
22:00:39 <benzrf> explain
22:00:49 <benzrf> haasn: write I in haskell pls
22:00:52 <hae> Uh I don't know. https://en.wikipedia.org/wiki/Binary_lambda_calculus
22:01:21 <Axman6> :t ap `asAppliedTo` id
22:01:23 <lambdabot> ((a -> b) -> a -> b) -> ((a -> b) -> a) -> (a -> b) -> b
22:01:40 <Axman6> is that S/K? (I can never remember which)
22:02:01 <Axman6> @djinn ((a -> b) -> a -> b) -> ((a -> b) -> a) -> (a -> b) -> b
22:02:02 <lambdabot> f a b c = c (b (\ d -> a (a (\ _ -> c d)) d))
22:02:47 <haasn> Setting m -> (a -> b) to ‘id’ makes the type unnecessarily complex
22:03:08 <haasn> But it's S, in essence
22:03:16 <Axman6> right
22:03:20 <Axman6> and K is const
22:03:28 <Axman6> (and I id obviously)
22:03:36 <dibblego> s = \f g x -> f x (g x)
22:03:46 <haasn> :t ap `asTypeOf` \f g x -> f x (g x)
22:03:47 <lambdabot> (t -> a -> b) -> (t -> a) -> t -> b
22:03:51 <Axman6> :t let iota x = x ap const in iota
22:03:52 <lambdabot> Monad m => ((m (a -> b) -> m a -> m b) -> (a1 -> b1 -> a1) -> t) -> t
22:04:13 <dolio> I would guess iota doesn't have types.
22:04:29 <haasn> :t let iota x = x (\f g x -> f x (g x)) const in iota
22:04:31 <lambdabot> (((t3 -> t2 -> t1) -> (t3 -> t2) -> t3 -> t1) -> (a -> b -> a) -> t) -> t
22:04:57 <haasn> :t let iota x = x (\f g x -> f x (g x)) const in iota iota
22:04:59 <lambdabot>     Occurs check: cannot construct the infinite type: b0 ~ a -> b0 -> a
22:04:59 <lambdabot>     Expected type: (((a -> b0 -> a) -> (a -> b0) -> a -> a)
22:04:59 <lambdabot>                     -> ((a -> b0 -> a) -> a -> b0) -> (a -> b0 -> a) -> a -> a)
22:05:05 <haasn> Okay, so we can't type this in Haskell that well
22:05:07 <lispy> we have identity and const functors in haskell, do we have an S functor?
22:05:11 <haasn> (This should be identity)
22:05:23 <kristof> What would an S functor be? You mean the S combinator?
22:05:42 <dolio> newtype S f g x = S (f x (g x))
22:05:57 <lispy> Sorry, I meant as an already defined thing.
22:06:04 <lispy> Does it have another name already?
22:06:08 <dolio> Not that I know of.
22:06:19 <Iceland_jack> GHC complains when I ask it to derive it as a Functor
22:06:21 <haasn> (Bifunctor f, Functor g) => Functor S -- ?
22:06:34 <haasn> (Bifunctor f, Functor g) => Functor (S f g) I mean
22:07:00 <haasn> fmap f = bimap f (fmap f) -- This trivially passes fmap id = id
22:07:09 <haasn> Which is sufficient, right?
22:07:22 <lispy> Lens already uses Const and Identity to compose effects. So I was thinking, what if it also used S? Would that mean you can build SKI on lens? :)
22:07:52 <haasn> lispy: More importantly, could you build ‘over’ using only Const and S?
22:08:13 <haasn> Since s+k clearly implies i
22:08:32 <dolio> You could. But you wouldn't want to.
22:08:34 <haasn> Can we make an S applicative?
22:09:22 <haasn> What would that require for f? Something like Category?
22:11:55 <dolio> Not category.
22:12:30 <dolio> You want f to be some kind of biapplicative.
22:15:02 <haasn> hae: I looked it up, seems like the BLC is similar to Jot in spirit - but Jot is bijective to the set of all binary strings, which the notion of BLC presented on that page doesn't seem to be
22:15:48 <dolio> Very important that every possible string you can write is a valid program.
22:16:24 <spopejoy> any pointers on regexs? I can't seem to get backslashes to work.
22:17:23 <spopejoy> ie, ("food123" =~ "\\d" :: String) returns "d" instead of "1"
22:18:35 <lispy> > "\\d"
22:18:36 <lambdabot>  "\\d"
22:18:43 <sclv> is Exp maybe a better notion than S?
22:19:04 <dolio> Do the docs say \d is digit?
22:19:14 <spopejoy> "docs". that's a good one.
22:19:15 <lispy> spopejoy: are you sure the underlying regex library knows \d?
22:19:31 <sclv> data Exp f g a = Exp (forall b. (a -> f b) -> g b)
22:20:28 <dolio> That isn't S.
22:20:38 <dolio> That's a Kan extension.
22:20:57 <sclv> your S is the obvious one
22:21:01 <sclv> but it doesn't feel useful :-)
22:21:29 <benzrf> dolio: so Kant was wrong after all?
22:21:32 <benzrf> @rimshot
22:21:33 <lambdabot> Unknown command, try @list
22:21:35 <dolio> Mine's the one that's S. :)
22:21:37 <benzrf> :[
22:22:47 * sclv totally forgot that Exp is the same as Ran.
22:22:56 <sclv> in fact is there another Exp that's slightly different?
22:22:59 <sclv> and i wrote the wrong one
22:23:07 <spopejoy> it could be that TDFA etc don't support character classes. if so that's too bad
22:23:21 <dolio> Does it have [::digit::] or whatever?
22:23:23 <mcbears> has anyone used codeeval before? do we know if they use any extended libraries, or just ghc with base?
22:24:15 <dfeuer> Has anyone written a BF interpreter in BF? And has anyone written a BF-to-INTERCAL compiler in either BF or INTERCAL?
22:24:50 <spopejoy> ok it looks like TDFA doesn't support backslash, but [:digit:]
22:24:54 <spopejoy> etc
22:25:13 <dolio> Much better than [0-9].
22:25:21 <lispy> welcome to the world of incompatible regex syntaxes
22:25:37 <mcbears> dfeuer: found one https://github.com/canoon/bfbf/blob/master/bf.bf
22:26:02 <mcbears> bf.bf is a filename that skews magical
22:27:15 <lispy> My favorite line in that file is the first one: #!/usr/bin/bf
22:27:26 <lispy> as if everyone has bf installed in /usr/bin :)
22:27:27 <dfeuer> mcbears, that's disgusting.
22:27:50 <mcbears> be careful what you wish for...
22:28:51 <spopejoy> I take it back. ARRGH. TDFA only supports classes for ascii
22:28:56 <tabemann> back
22:29:22 <spopejoy> OK time for PCRE. I was hoping for "native + fast" and also reasonably modern.
22:29:39 <spopejoy> can't have all three.
22:30:15 <spopejoy> lispy: my favorite weird regex syntax is emacs'
22:30:29 <spopejoy> although i suspect it's close to sed
22:31:00 <spopejoy> there we go. PCRE supports "\\d"
22:31:16 <spopejoy> Welcome to 1992.
22:31:56 <MP2E> 1992? damnit.. one year ahead and you might have been able to play Doom at least :P
22:32:08 <mwhit> i mostly just write out character classes. saving 3 characters isn't worth having to remember what works where, what needs escaping where, etc etc
22:32:10 <haasn> shachaf: I've managed to produce a single HTML file
22:32:23 <haasn> But I have no idea how much is wrong
22:32:45 <haasn> Apparently it's as simple as changing a ‘3’ in the invocation (Makefile) to ‘0’, indicating the sub-depth up to which to produce separate documents
22:32:54 <haasn> (0 obviously meaning single file)
22:33:24 <spopejoy> Doom … or Marathon
22:33:49 <haasn> But my build environment is probably very different from the official one. I get a ton of LaTeX errors, and in my infinite wisdom, just spamming ^D seems to be enough to make the script happy
22:33:55 <tabemann> I remember Marathon
22:34:30 <haasn> I also get a “haskell.bbl: no such file” error, but copying haskell.bib to haskell.bbl seems to have made the script continue.
22:35:09 <spopejoy> "frog blast the vent core"
22:35:35 <Axman6> spopejoy: what do you need regexes for anyway? the usual Haskell solution to regexes is to use a proper parser because as easy as you think it's going to be, it's always going to be easier to change (and read!) the parser later
22:36:29 <spopejoy> cuz i've decided to do all my command-line utils in haskell. for instance, parsing the output of ghc-pkg.
22:36:44 <Axman6> ah, fair enough
22:37:04 <pyon> Does any of the main parser combinator libraries allow for backtracking *tokens* rather than characters?
22:37:27 <Axman6> you can always tokenise first and then use parsec if you want
22:37:31 <solatis> is there anyone able to hold my hand while i try to comprehend what i'm doing wrong?
22:37:50 <solatis> i'm trying to get some code out of a 'do' block and put it in another separate function
22:37:51 <Axman6> solatis: only if you tell us what's happening! =)
22:37:54 <mcbears> we're here for you
22:38:00 <solatis> except, i have no idea what the f..k i'm doing
22:38:03 <solatis> https://gist.github.com/solatis/22942319dbfae491e80e
22:38:09 <solatis> Version1 compiles perfectly
22:38:16 <solatis> Version2 generates the error you see below
22:38:16 * Axman6 initiates DRS ABCD
22:38:59 <solatis> Axman6: see the gist i asted -- or is lpaste preferred?
22:39:10 <solatis> *pasted
22:39:25 <Axman6> gist is fine, but I'm currently eating and will be with you soon =)
22:39:43 <solatis> ok
22:41:00 <mwhit> solatis: run takes a Socket z t, but openSender returns a ZMQ z ()
22:41:07 <mwhit> plus you aren't even fully applying openSender
22:41:16 <solatis> i think the problem is that the code i'm trying to 'get out' of the do block is inside a monad and performs monad transformations -- the problem is, i have no idea what the function signature should be of the "refactored" function should look like
22:41:43 <mcbears> It looks like you're going to end up using "run" inside of your openSender definition
22:42:07 <mwhit> :t System.ZMQ4.Monadic.bind
22:42:08 <lambdabot> Not in scope: ‘System.ZMQ4.Monadic.bind’
22:42:32 <benzrf> see you
22:42:33 <benzrf> bye
22:42:37 <solatis> mcbears: but that's exactly the thing i want to decouple -- opening the socket from performing actions on the socket
22:42:43 <Javran> how can I use glade with gtk2hs? the demo found in gtk2hs source can't even compile. it complains "No instance for (gtk-0.12.5.7:Graphics.UI.Gtk.Types.WidgetClass Window)" but WidgetClass is actually defined in "Graphics.UI.Gtk.Abstract.Widget"
22:43:01 <haasn> shachaf: Anyway, my output is at http://www.nand.wakku.to/haskell2010/
22:43:06 <haasn> I hope this is helpful
22:43:31 <mwhit> solatis: what is the type of "bind publisher \"tcp://*:10150\""?
22:43:58 <mwhit> wait scratch that
22:44:06 <mwhit> it's ZMQ z () right?
22:44:26 <mwhit> and publisher is a Socket z t?
22:44:47 <haasn> shachaf: It seems to be formatted slightly differently, but I have no idea if the content differs
22:44:49 <solatis> http://hackage.haskell.org/package/zeromq4-haskell-0.6/docs/System-ZMQ4-Monadic.html
22:45:00 <mwhit> then openSender should be Int -> ZMQ z (Socket z t)
22:45:05 <solatis> that's the relevant documetantation
22:45:09 <solatis> mwhit: aha! yes!
22:45:19 <solatis> mwhit: so the socket lives within the ZMQ monad
22:45:24 <mwhit> correct
22:45:29 <mwhit> that is the type of 'publisher'
22:45:33 <solatis> let me try
22:45:39 <haasn> shachaf: Actually, let me take that back. I was zoomed in to 110% size on haskell.org for some reason
22:47:24 <haasn> The only major deviation I can see is that the table of contents seems to be missing entries for the contents, preface and bibliography. Probably this is related to some of the errors I got.
22:48:38 <solatis> ffs i hate it that i have no idea what i'm doing
22:48:39 <haasn> Oh, the bibliography is also not rendered at all. That is probably related to the “fix” I applied to the missing haskell.bbl file.
23:05:43 <gamegoblin> > print “good evening, all”
23:05:45 <lambdabot>  can't find file: L.hs
23:06:11 <gamegoblin> > print ?good evening, all?
23:06:12 <lambdabot>  <hint>:1:20: parse error on input ‘,’
23:06:22 <gamegoblin> Ugh stupid mac stupid irc client stupid non ascii quotes
23:10:44 <geekosaur> gamegoblin, System Preferences > Language & Text > Text > Smart Quotes (on right)
23:11:55 <geekosaur> the un-smart quote options are the last one in each dropdown
23:12:01 <gamegoblin> print "test"
23:12:03 <gamegoblin> > print "test"
23:12:05 <lambdabot>  <IO ()>
23:12:36 <gamegoblin> print "another test"
23:12:40 <gamegoblin> > print "another test"
23:12:42 <lambdabot>  <IO ()>
23:12:45 <gamegoblin> wat
23:13:13 <geekosaur> > 't'
23:13:14 <lambdabot>  't'
23:13:22 <geekosaur> > text "foo"
23:13:23 <lambdabot>  foo
23:13:27 <gamegoblin> > "lol"
23:13:28 <lambdabot>  "lol"
23:13:49 <sclv> Play with the bot in privmsg
23:13:51 <gamegoblin> > "lol" <> " wat is dis"
23:13:53 <lambdabot>  "lol wat is dis"
23:13:59 <gamegoblin> sclv: all done
23:19:34 <shachaf> haasn: Looks good overall.
23:19:45 <shachaf> haasn: I think the bibliography didn't work out, at least.
23:20:00 <shachaf> But now that you have it working you should propose it as an official thing!
23:24:42 <haasn> shachaf: When I wake up I will try to replicate a more proper build environment inside a VM using older versions of stuff
23:25:01 <haasn> I will write an email, too
23:25:54 <solatis> i think i am about to hit my head against a wall
23:26:05 <shachaf> Hooray.
23:26:07 <shachaf> haasn++
23:26:22 <solatis> all these monad compiler problems remind me of decyphering template metaprogramming errors in c++
23:26:48 <solatis> you really need a lot of experience to have enough a mental model of what's going on to interpret the errors correctly
23:29:13 <jfeltz> is there a reference to hoogle's flags? anywhere? and no, haskellwiki doesn't count
23:30:30 <adas> mornig
23:32:03 <solatis> ok
23:32:14 <solatis> i need someone holding my hand again
23:32:16 <solatis> https://gist.github.com/solatis/22942319dbfae491e80e#file-version3
23:33:21 <adas> solatis: you need to add a type signature
23:33:30 <solatis> is it likely that this error is caused because i left openSender undefined, and thus it is unable to derive the type of Sender, or do I need to make a more 'firm' declaration of the run function that already puts more constraints on the Sender?
23:33:50 <solatis> adas: so the latter
23:33:50 <adas> solatis: the later
23:33:56 <solatis> ok
23:33:57 <adas> *latter : )
23:34:02 <solatis> then i will focus on that
23:39:44 <adas> solatis: more specifically, it can make out which instance of the sender typeclass to use..which is obvious from the error message.
23:40:53 <solatis> yes i undrestand that
23:41:06 <solatis> it cannot derive the type, so my type signature needs to be more strict
23:46:22 <jfeltz> shouldn't this work? hoogle --d=~/.hoogle/haddock.hoo Flag_IgnoreAllExports
23:46:33 <jfeltz> flag_ignoreallexports is a symbol in the dump of haddock.hoo
23:48:25 <trap_exit> has anyone here made even $100 off of amazon fire store?
23:49:19 <Axman6> using Haskell?
23:51:24 <trap_exit> hmm
23:51:25 <trap_exit> wrong channel
23:51:43 <trap_exit> has anyone made $100 off _any_ app store using haskell? :-D
23:51:45 <trap_exit> probably not
23:51:51 <MP2E> heh :<
23:55:17 <dv-> there's a haskell game on steam
23:55:28 <dv-> i would imagine it's made more than $100
