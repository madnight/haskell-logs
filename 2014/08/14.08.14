00:00:06 <solatis> so all i need to do is to tell forM_ that i return nothing
00:00:38 <frerich> solatis: Ghc doesn't make the 'logical conclusion to return the bool'. If you desgar your 'do' block, it's the same as "unpack  receive receiver >>= validator", but "validator" does not return a monadic value. So there's a type error. No matter whether you use forM or forM_.
00:00:55 <solatis> i understand
00:01:21 <solatis> but how do I make the code return a monadic value?
00:01:26 <corgifex> no
00:01:33 <corgifex> first you need to explain what this code is supposed to do
00:01:39 <solatis> yeah, true, hold on
00:01:44 <solatis> i'm improving the paste
00:02:01 <frerich> solatis: You would need a function of type 'a -> m a'. ;-)
00:02:14 <Welkin> just throw in a return?
00:02:39 * frerich thinks it's not necessary to explain what the code is supposed to do, the types already tell the whole story -- the code is obviously reduced ad absurdum.
00:02:42 <corgifex> if you just throw in a return, you can simplify the whole thing to 'forM_ [1 .. urlAmount] $ \_ -> do receive receiver'
00:03:28 <frerich> corgifex: Well that won't help much I fear, since the *real* code actually does more in the action passed to forM_. Note that this code won't even compile as it is, there's a lot of stuff missing.
00:04:02 <solatis> http://lpaste.net/109354
00:04:25 <solatis> now with comments
00:04:56 <frerich> solatis: there's a function called "when" which you might find useful.
00:05:03 <Cale> solatis: What's the type of validator?
00:05:09 <corgifex> does ZMQ do anything special with exceptions? or are you supposed to use liftIO . throwIO or something?
00:05:15 <corgifex> Cale: it's a parameter
00:05:24 <Cale> oh
00:05:31 <solatis> Cale: it's a (String -> Bool) function
00:05:32 <Cale> So String -> Bool, in which case
00:05:48 <Cale> you can just write  if validator message then ... else ...
00:06:01 <Cale> and in each branch, put whatever action you'd like
00:06:16 <solatis> but that should be a monadic action
00:06:20 <corgifex> one of the branches is a no-op, hence the 'when' suggestion
00:06:27 <Cale> Yeah, it needs to be a ZMQ z action
00:06:35 <solatis> I understand.
00:06:44 <Cale> well, yeah, 'when' will also work
00:06:50 <solatis> And what does a no-op ZMQ z action look like? just return() ?
00:06:56 <Cale> yep
00:07:02 <solatis> (sorry for my stupid questions)
00:07:09 <Cale> when is actually defined like that
00:07:25 <Cale> @src when
00:07:25 <lambdabot> when p s = if p then s else return ()
00:07:51 <Cale> I don't know if the ZMQ monad has exceptions
00:08:06 <solatis> i will look it up, I think they kept it pretty simple
00:08:23 <solatis> http://hackage.haskell.org/package/zeromq4-haskell-0.6/docs/System-ZMQ4-Monadic.html
00:08:26 <solatis> fyi
00:08:28 <corgifex> ZMQError is an instance of Exception and that seems to be it
00:08:33 <corgifex> liftIO is available
00:08:48 <Cale> Ah, it's an instance of MonadThrow
00:09:08 <corgifex> ooh, MonadThrow
00:09:15 <solatis> corgifex: that seems more like the exceptions the ZMQ monad is supposed to throw at me, instead of me throwing it at the ZMQ monad?
00:09:35 <corgifex> yes, ZMQError is unrelated
00:09:42 <solatis> right
00:09:46 <Cale> So yeah, you can throwM any sort of exception type that you'd like
00:09:59 <solatis> http://hackage.haskell.org/package/exceptions-0.6.1/docs/Control-Monad-Catch.html#t:MonadThrow
00:10:05 <solatis> that's what I need to look at I think?
00:10:07 <Cale> If you want to invent a new exception type, you can do that too, it's pretty easy
00:10:14 <Cale> yep
00:10:31 <corgifex> throwM "o noes"
00:10:34 <solatis> ok, I do not want to invent a new exception type
00:10:48 <solatis> I just want the process to crash, actually
00:11:00 <solatis> but that's a side-effect of not handling the exception
00:11:30 <solatis> (i actually don't like exceptions myself, what would you guys do in this case?)
00:11:33 <Cale> Well, you could also just use  error "Oops!"
00:12:14 <corgifex> @src error
00:12:15 <lambdabot> error s = throw (ErrorCall s)
00:12:26 <corgifex> it's exceptions all the way down
00:12:41 <solatis> it seems more elegant tho
00:12:56 <solatis> as in, exceptions as an implementation detail
00:13:02 <Cale> But inventing a new exception type and throwing that is really easy.   data ValidatorFailed = ValidatorFailed String deriving (Show, Typeable); instance Exception ValidatorFailed where {}
00:13:21 <Cale> and then you can  throwM (ValidatorFailed message)
00:13:29 <solatis> Cale: ok, for the sake of excercise I will try that :)
00:13:40 <corgifex> 'where {}' is redundant
00:14:00 <Cale> You're probably right
00:14:09 <solatis> thanks for the help everyone
00:14:18 <Cale> I'm trying to think if leaving that 'where' out is new or not
00:14:27 <corgifex> xmonad has been using it for ages
00:14:37 <Cale> okay, cool :)
00:14:39 <corgifex> IIRC
00:15:41 <Cale> Yeah, the where is definitely optional in H2010 at least
00:16:05 <Cale> and in H98 too
00:16:10 <Cale> So nothing to worry about :)
00:17:45 <Welkin> optional in what context?
00:18:05 <Cale> Welkin: In the context that you don't want to put any declarations inside it
00:18:13 <Cale> (in an instance declaration)
00:18:36 <Welkin> example?
00:18:44 <corgifex> instance Exception ValidatorFailed
00:18:46 <Cale> instance Exception MyType
00:19:14 <Welkin> rather than:
00:19:24 <Welkin> instance Exception MyType where
00:20:01 <Cale> It's quite common for instances of Exception to be perfectly fine without overriding the default implementation of toException and fromException
00:20:14 <Cale> You can do some really cool things by writing your own though
00:20:22 <Welkin> oh, I see
00:20:32 <Welkin> it is optional if the where is empty
00:20:39 <Cale> yeah
00:32:13 <makalu> is there a way to detect overflow when converting from Double to Float (I've been using GHC.Float.double2Float)? I could use minBound, maxBound with integral types but not with floats.
00:34:58 <dfeuer> makalu, what do you mean by "overflow"?
00:35:04 <pyrtsa> makalu: Could http://hackage.haskell.org/package/base-4.7.0.1/docs/Prelude.html#v:floatRange help?
00:35:06 <mkrtem> makalu: yeah, what dfeuer said
00:35:46 <Welkin> 64-bit overflow
00:35:53 <Welkin> or 32-bit
00:35:56 <makalu> I wish "double2Float (exp 100)" would throw an exception, or return Nothing instead of infinity
00:36:13 <dfeuer> makalu, why?
00:36:16 <mkrtem> So you could just check to see if it returned infinity
00:36:16 <Welkin> what is the precision of Float?
00:36:54 <Welkin> :t maxBound
00:36:55 <lambdabot> Bounded a => a
00:37:07 <Welkin> maxBound Float
00:37:08 <adas> > maxBound :: Float
00:37:09 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Types.Float)
00:37:10 <lambdabot>    arising from a use of ‚ÄòGHC.Enum.maxBound‚Äô
00:37:22 <adas> > maxBound :: Int
00:37:23 <lambdabot>  9223372036854775807
00:37:30 <adas> > maxBound :: Integer
00:37:31 <lambdabot>  No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
00:37:31 <lambdabot>    arising from a use of ‚ÄòGHC.Enum.maxBound‚Äô
00:37:41 <dfeuer> > maxBound :: (Int,Int)
00:37:42 <lambdabot>  (9223372036854775807,9223372036854775807)
00:37:50 <makalu> dfeuer: I'm parsing a text file and the user will specify the type of number literals and I want to warn if he has a number that doesn't fit into the type he specifies
00:38:23 <makalu> actually it's a bit more complicated than that unfortunately, but still
00:38:45 <dfeuer> makalu, it still sounds like the way to accomplish that it to just check for infinity, no?
00:38:50 <lfairy> you can create a wrapper type that has that behavior
00:39:25 <makalu> ok
00:41:30 <lfairy> thought I'm not sure myself what wouldn't be covered by simply adding a check for infinity
00:41:35 <dottedmag> makalu: why reading Float through an intermediary Double?
00:41:51 <lfairy> *though
00:42:07 <makalu> yeah I'm not sure either
00:42:34 * hackagebot bff-mono 0.2.3 - "Bidirectionalization for Free" for Monomorphic Transformations  http://hackage.haskell.org/package/bff-mono-0.2.3 (kztk)
00:42:34 <Cale> You pretty much never want Float
00:43:09 <makalu> it doesn't matter what I want. I have requirements that don't depend on me.
00:43:22 <Cale> Well, okay :)
00:44:12 <Cale> So, there's decodeFloat which might be useful
00:44:15 <makalu> I think the whole task I was given is not well thought out
00:44:55 <dottedmag> Sure it is the first time it happened in the history in computing ;)
00:46:10 <makalu> I need to warn when parsing text to a numeric type and I also need to warn when converting from one type to another. In C++ I can use boost's lexical_cast and numeric_cast which throw appropriate exceptions.
00:46:55 <Cale> Well, of course you can just realToFrac and use isInfinite
00:47:30 <Cale> > realToFrac (2^127) :: Float
00:47:31 <lambdabot>  1.7014118e38
00:47:34 * hackagebot Strafunski-StrategyLib 5.0.0.4 - Library for strategic programming  http://hackage.haskell.org/package/Strafunski-StrategyLib-5.0.0.4 (JamesKoppel)
00:47:35 <Cale> > realToFrac (2^128) :: Float
00:47:36 <lambdabot>  Infinity
00:47:43 <Cale> > isInfinite (realToFrac (2^128) :: Float)
00:47:44 <lambdabot>  True
00:47:49 <Cale> > isInfinite (realToFrac (2^127) :: Float)
00:47:50 <lambdabot>  False
00:48:29 <makalu> thanks for helping. I'll think of some stupid solution.
00:49:59 <hal9> haskell sucks
00:50:10 <frerich> If I have a Vector Int at hand (I need O(1) indexing) and commonly need to perform things like 'find the next zero starting from a given position', is there a good trick to make all such operations also work in reverse? I.e. so that I can use the same code for finding the next zero to search for the previous zero? I think this requires abstracting traversal of the vector, but unfortunately all the existing API
00:50:11 <frerich>  seems to have it built-in (e.g. Vector.find always searches forward).
00:50:32 <Cale> hal9: Sure in some ways, but do you have any particular point to make, or are you just being negative?
00:50:45 <hal9> its all about Go
00:50:47 <hal9> I write everything in Go
00:51:33 <makalu> :)
00:51:57 <Cale> frerich: This reminds me of something that Edward Kmett was talking about...
00:52:26 <hal9> what
00:52:38 <hal9> 'have you guys thought about switch to Go
00:52:40 <hal9> there is still time
00:52:45 <hal9> for you to be saved
00:52:54 --- mode: ChanServ set +o johnw
00:52:55 --- kick: hal9 was kicked by johnw (Kicked)
00:52:55 --- mode: johnw set -o johnw
00:52:55 <Hafydd> When is the deadline?
00:53:01 <Cale> Aww, you kicked him
00:53:12 <hal9> soz
00:53:13 <johnw> you wanted entertainment?
00:53:13 <hal9> i was just
00:53:15 <hal9> joking
00:54:13 <shachaf> Whether you're joking or not isn't really relevant, just whether you're making the channel unpleasant.
00:54:26 <KorriX> Hello! Is there any way of deriving instances for classes that have associated types?
00:54:32 <Cale> hal9: I was going to say, personally I don't find Go (the programming language) all that interesting. The ideas in it are all pretty old, and it doesn't do a really good job of allowing one to write code that is reusable. Its type system is pretty deficient when it comes to polymorphism.
00:54:51 <shachaf> If you're going to joke, learn to joke better. But that behavior isn't acceptable.
00:54:58 <hal9> soz
00:55:15 <hal9> the two aren't really comparable
00:55:34 <hal9> that was the point*
00:55:49 <hal9> nvm
00:56:10 <lfairy> KorriX: what version of GHC are you using?
00:56:19 <Cale> hal9: The first thing that I did with Go is to try to write an ordinary polymorphic 'map' function, and when I figured out that it couldn't be done, I was pretty much done with it.
00:57:13 <hal9> sorry not a mathematician
00:57:16 <KorriX> lfairy: The 7.8.3 one
00:57:57 <Cale> hal9: I mean the sort of function which takes a function and a list, and applies the function to all the elements of the list, obtaining a new list of the results.
00:58:04 <Cale> In Haskell, it's called map
00:58:05 <Cale> :t map
00:58:07 <lambdabot> (a -> b) -> [a] -> [b]
00:58:17 <hyPiRion> Cale: "But you have for loops" ‚Äì Go authors
00:58:34 <hal9> yea i actually dont know how to write in Go
00:58:48 <hal9> soz
00:58:51 <Cale> It takes a function of type a -> b (i.e. this function argument takes something of type a, and produces something of type b), and a list of values of type a, and produces a list of values of type b
00:59:02 <hal9> oh
00:59:36 <Cale> Go (along with a lot of older languages) is bad at expressing this kind of relationship between types.
00:59:48 <hal9> but what if the functions domain isnt finite
00:59:52 <corgifex> map f [x1, x2, x3, ...] = [f(x1), f(x2), f(x3), ...]
00:59:55 <corgifex> map in a nutshell
00:59:59 <Cale> hal9: That's perfectly okay
01:00:22 <hal9> how would you map f(x)=x^2
01:00:31 <Cale> > map (\x -> x^2) [1,2,3,4,5]
01:00:32 <lambdabot>  [1,4,9,16,25]
01:00:34 <Iceland_jack> > map (^2) [1..5]
01:00:35 <lambdabot>  [1,4,9,16,25]
01:00:47 <hal9> yeah but its domain isnt (1,2,3,4,5)
01:00:48 <hal9> its N
01:00:51 <hal9> my bad
01:00:52 <Cale> Sure
01:00:54 <corgifex> so what?
01:00:55 <hal9> its whatever
01:00:59 <Cale> > map (\x -> x^2) [0..]
01:01:01 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,4...
01:01:18 <hal9> what if I made its domain the real numbers
01:01:24 <frerich> Wasn't Go specifically designed to be a "nice" imperative language? If so, evaluating it by how well it works for a functional style isn't really fair, I'd think.
01:01:29 <corgifex> why are you talking about domains?
01:01:35 <hal9> i dont know
01:01:39 <Cale> hal9: It doesn't matter how large the domain of the function is, so long as that domain contains all the elements of the list
01:01:55 <hal9> why is this useful
01:02:00 <corgifex> frerich: all nice imperative languages I know have map
01:02:15 <Cale> Because applying a function to all the elements of a list is frequently a useful thing to do.
01:02:20 <Cale> :)
01:02:23 <hal9> oh yeah
01:02:25 <Iceland_jack> hal9: You might be interested in checking out Learn You a Haskell
01:02:25 <Iceland_jack> @where lyah
01:02:25 <lambdabot> http://www.learnyouahaskell.com/
01:02:25 <hal9> that makes sense
01:02:30 <hal9> nvm
01:02:34 <hal9> i dnt thinki
01:02:36 <hal9> i understood
01:02:38 <Iceland_jack> It's available to read online for free and it will answer this question (and more)
01:02:39 <hal9> what you were saying
01:03:02 <lfairy> KorriX: I found this bug report https://ghc.haskell.org/trac/ghc/ticket/8165
01:03:08 <lfairy> so it looks like we can't
01:03:18 <Cale> > map reverse ["here", "are", "some", "words", "to", "reverse"]
01:03:19 <lambdabot>  ["ereh","era","emos","sdrow","ot","esrever"]
01:03:20 <hal9> like if i wanted to calculate how much each person would pay for somthing, and i had a certain function that evaluated each person
01:03:27 <Cale> yes
01:03:40 <corgifex> > map length ["here", "are", "some", "words", "to", "reverse"]
01:03:40 <Iceland_jack> > map length ["here", "are", "some", "words", "to", "reverse"]
01:03:41 <lambdabot>  [4,3,4,5,2,7]
01:03:41 <lambdabot>  can't find file: L.hs
01:03:43 <Iceland_jack> heh
01:03:47 <Cale> You could map the function over the list, and get a list of the results
01:04:01 <Cale> and know how much the payments would be
01:04:37 <Cale> Someday we should really look at what causes that race condition in lambdabot :P
01:12:29 <frerich> For what it's worth, http://blog.burntsushi.net/type-parametric-functions-golang discusses various ways to implement 'map' in Go. So even though defining such functions in Go doesn't look very nice (much like in e.g. C++, ahem...), it seems possible
01:13:25 <KorriX> lfairy: I need to have structure for representing points in different coordinate systems (Cartesian.Point, Polar.Point, etc..). Basically all of them could be a newtype wrapper for Linear.V2, but I don't know how to force newtype to inherit all the instances from the type that it wraps
01:14:56 <KorriX> lfairy: It's necesarry for me to have instances from linear-accelerate package for my points (It's quite a lot of boilerplate to write them by hand for ~10 kinds of points
01:17:05 <Cale> frerich: lol, runtime type checks
01:17:24 <Cale> frerich: I guess it's something though
01:21:49 <frerich> Cale: Right - I don't have much experience with 'Go' beyond a few tutorials, but I do appreciate that it allows to escape the OO paradigm (unlike e.g Java, where you don't even have free functions, let along being able to pass them around -- unless you resort to using Reflection at which point you basically give up any type checking).
01:22:57 <corgifex> many languages from the 60s and 70s allow you to escape the OO paradigm
01:23:34 <KorriX> My second question is about protocol-buffers package. Is it maintained at all? (It does not compile on 7.8.3 because of typeable update - I have a fix for that, but the author is not responding on emails)
01:24:32 <KorriX> You can look at https://github.com/korrix/protocol-buffers/commit/03b1ef52494d2a1dfe7ddb6fb3170fd2bfbfa789
01:31:18 <trap_exit> sup
01:52:37 <frerich> I hope there will be an "executive summary" of the Good, Bad, GUI thread at some point because I long lost track of what it's about :-}
02:02:56 <haasn> C# allows you to ‚Äúescape‚Äù the OO paradigm
02:17:51 <ddrone> Hi everyone. I am trying to find a way to get a difference between two UTCTimes in seconds. I've found a way to subtract two UTCTimes, getting DiffTime, but don't see a way to convert it to some numerical type
02:18:22 <Kinnison> DiffTime is Num
02:18:31 <bennofs> :t fromIntegral
02:18:32 <lambdabot> (Num b, Integral a) => a -> b
02:18:45 <Kinnison> DiffTime doesn't appear to be Integral
02:19:18 <bennofs> @let import Data.Time.Clock
02:19:19 <lambdabot>  .L.hs:105:1:
02:19:20 <lambdabot>      Data.Time.Clock: Can't be safely imported!
02:19:20 <lambdabot>      The package (time-1.4.2) the module resides in isn't trusted.
02:19:25 <bennofs> :t realToFrac
02:19:26 <lambdabot> (Real a, Fractional b) => a -> b
02:19:33 <bennofs> Kinnison: DiffTime is Real
02:19:52 <Kinnison> And Fractional
02:21:26 <ddrone> So what, if DiffTime is Num, I can convert Integer to DiffTime, but I want get an Integer out of DiffTime
02:21:38 <corgifex> which Integer?
02:21:46 <Kinnison> (fromIntegral . floor) (100 :: DiffTime)
02:21:54 <Kinnison> seems to give you seconds
02:22:03 <corgifex> why fromIntegral?
02:22:34 <Kinnison> I was just playing
02:22:39 <Kinnison> and I'm precaffeination so far :-)
02:22:45 <ddrone> corgifex: I'd prefer amount of seconds
02:22:54 <corgifex> ok, then floor should work
02:23:01 <corgifex> "This is a length of time, as measured by a clock. Conversion functions will treat it as seconds."
02:24:10 <ddrone> Oh, I missed that, thanks
02:32:52 * hackagebot type-natural 0.2.1.2 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.1.2 (HiromiIshii)
02:49:09 <NikolajK> In the source for types in the Prelude, I read things like "data {-# CTYPE "HsChar" #-} Char = C# Char#". Google suggests CTYPE has to do with the C programming language. What is going on here?
02:59:20 <int-e> NikolajK: hmm, the documentation of that pragma is not particularly helpful: https://www.haskell.org/ghc/docs/latest/html/users_guide/ffi.html#ffi-capi
03:01:58 <splintax> NikolajK: what's the source you're referring to?
03:02:22 <NikolajK> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.1.0/src/GHC-Types.html#Bool
03:02:30 <NikolajK> I have to go to lunch now, though
03:03:26 <splintax> if i understand correctly, that is not part of the prelude as such. that's ghc's implementation of the type Char
03:03:42 <splintax> which is just part of the haskell spec and can be implemented however the compiler/interpreter wants
03:26:21 <Darwin226> Hey guys. I'm trying out vim2hs but I get these errors when I open a haskell file: http://lpaste.net/109357
03:26:26 <Darwin226> Would anyone know anything about those?
03:35:29 <pavonia> Darwin226: What do the corresponding source code lines look like?
03:36:29 <Darwin226> pavonia: The thing is, I don't know where they are. Vundle is supposed to install into $HOME/vimfiles/bundle but there's nothing but vundle in there
03:36:39 <Darwin226> pavonia: Where do I look for them?
03:36:53 <pavonia> I mean of the Haskell file you opened
03:37:30 <Darwin226> pavonia: Oh. Hold on
03:39:07 <Darwin226> pavonia: Well, it always says line 12 so I don't think it's talking about my haskell file. Here's the line in the one I have currently open: makePoolAcc n (rnd, list) = makePoolAcc (n - 1) (nextRnd, genome : list)
03:39:31 <pavonia> Hhm
03:40:01 <corgifex> Darwin226: does it really say √¢‚Ç¨¬¶ in the error message?
03:40:17 <Darwin226> corgifex: it does
03:40:27 <corgifex> my money is on encoding problems
03:40:33 <corgifex> what does :set enc? say?
03:40:53 <pavonia> That seems to be a '‚Ä¶' in UTF-8
03:41:15 <Darwin226> corgifex: cp1250
03:41:22 <corgifex> you seem to be on windows
03:41:29 <Darwin226> corgifex: I am
03:41:44 <corgifex> do you have a _vimrc?
03:42:00 <Darwin226> corgifex: I do, not much in it though
03:42:20 <corgifex> add 'set enc=utf-8'
03:42:40 <corgifex> then quit vim and retry. it might not fix it, but you definitely want encoding=utf-8
03:43:15 <Darwin226> corgifex: Bingo!
03:43:24 <Darwin226> corgifex: it worked
03:43:33 <corgifex> I suspect it was fencs, which is set from enc
03:43:38 <corgifex> but yay
03:44:04 <Darwin226> thanks
03:44:42 <corgifex> explanation: vim was reading the script source (which is in UTF-8) as an 8-bit encoding (CP-1250)
03:45:04 <corgifex> that made it look like it was trying to set cchar to 3 characters, but only one character is valid
03:45:32 <corgifex> changing enc triggers a different fencs, which is the list of file encodings vim tries when opening a file
03:45:58 <corgifex> in particular, it added utf-8 near the top of the list
03:47:17 <Darwin226> corgifex: It had an annoying sideffect though. I've previously binded ƒá and ≈æ keys on my keyboard to some actions since I was reasonably sure those weren't taken. They don't work anymore now.
03:48:11 <Darwin226> corgifex: What keys do people usually use for custom mappings?
03:49:58 <quchen> I'm having trouble finding the semantics of where clauses in the Report. Is the brief mentioning of it in the "case expressions" section everything there is?
03:51:20 <dbushenko> hi all!
03:51:34 <dbushenko> which is more usable: fay or haste?
03:53:03 * hackagebot type-natural 0.2.1.3 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.1.3 (HiromiIshii)
03:53:05 * hackagebot plailude 0.2.2 - plaimi's prelude  http://hackage.haskell.org/package/plailude-0.2.2 (alexander)
03:55:03 <corgifex> Darwin226: I don't use mappings much but see :h leader (and maybe :h map-multi)
03:55:41 <Darwin226> corgifex: Does that mean that you typeout stuff like GhcModType every time you want to use it?
04:03:04 * hackagebot blaze-bootstrap 0.1.0.0 - Blaze helper functions for bootstrap pages  http://hackage.haskell.org/package/blaze-bootstrap-0.1.0.0 (AlexanderThiemann)
04:03:06 * hackagebot digestive-bootstrap 0.1.0.0 - Speed up form designing using digestive functors and bootstrap  http://hackage.haskell.org/package/digestive-bootstrap-0.1.0.0 (AlexanderThiemann)
04:16:05 <adas> please correct me if im wrong.. but is the state monad a kind of continuation?
04:16:25 <adas> or am i totally wrong?
04:17:23 <funrep> is there a defecto http library?
04:17:33 <funrep> ups wrong channel
04:20:10 <thermidore> hi everyone!
04:21:16 <thermidore> I have a silly question for you guys, is there a way to impose correct implementation of monadic laws in haskell on instances of Monad typeclass?
04:21:56 <quchen> thermidore: No.
04:22:39 <quchen> Every appropriate constructor can be made a Monad using return = (>>=) = undefined, and you cannot check whether something is undefined or something meaningful.
04:23:27 <quchen> Idris goes a bit further here and allows proofs in that spirit, but Haskell doesn't have that capability.
04:24:27 <quchen> Also note that many common Monads do not obey the Monad laws in the presence of undefined values (e.g. Reader).
04:26:17 <thermidore> So, basically, if we remove undefined (and to my knowledge make the language total) we can impose the laws needed?
04:26:50 <makalu> if I want to use Read but I'm working with Text, what should I do? Convert Text to String? That defeats the purpose of Text.
04:27:08 <quchen> makalu: Why do you want to use Read?
04:27:32 <funrep> write your own parser?
04:28:17 <quchen> thermidore: I'm not sure about that. Proofs in Haskell are often done in comments in the source (e.g. DList, Pipes), so they're very informal.
04:28:21 <makalu> I want to parse numbers
04:28:23 <bernalex> how do I use ghci in a sandbox?
04:28:29 <quchen> bernalex: cabal repl
04:28:31 <makalu> maybe I should use scientific instead
04:28:51 <quchen> bernalex: "cabal exec ghci" might work as well, but "cabal repl" is the dedicated command
04:28:54 <bernalex> quchen: thanks
04:29:31 <quchen> makalu: If you want to parse numbers, why not use a parsing library?
04:29:38 <bernalex> quchen: does this autoload something? I tried :t-ing something, but it's not loaded
04:29:53 <bernalex> ah OK I needed to :l it. never mind. :-]
04:30:10 <quchen> I think it autoloads *something*, but I don't know what.
04:30:23 <bernalex> quchen: is it possible to autoload all modules?
04:30:49 <quchen> You mean all modules you're exposing? I don't think so. Imagine two submodules have clashing names.
04:31:37 <quchen> Hm, actually it loaded everything for me now.
04:41:05 <makalu> quchen: which parsing library provides parsing of numeric literals from Text? I would not like to write my own broken parser.
04:41:32 <adas> makalu: attoparsec
04:41:39 <quchen> makalu: Parsec, Attoparsec.
04:41:42 <adas> i think parsec too
04:41:52 <quchen> The former has better error reporting, Attoparsec is more performant.
04:42:48 <makalu> damn. I already looked at attoparsec's documentation but I looked at the wrong module >:(
04:42:54 <makalu> thanks
04:42:55 <quchen> makalu: Check the Token submodule of Parsec, it includes a small example at the bottom.
04:42:56 <quchen> http://hackage.haskell.org/package/parsec-3.1.5/docs/Text-Parsec-Token.html
04:43:08 * hackagebot equational-reasoning 0.2.0.4 - Proof assistant for Haskell using DataKinds & PolyKinds  http://hackage.haskell.org/package/equational-reasoning-0.2.0.4 (HiromiIshii)
04:43:28 <quchen> You basically import a grammar, then make a lexer using that, and then you get all the nice parsers for free.
04:43:45 <makalu> I've used Token with String multiple times. It didn't seem to work with Text.
04:44:22 <quchen> float :: ParsecT s u m Double -- That's polymorphic in s, the input stream.
04:44:29 <makalu> I probably just didn't spend sufficient effort.
04:52:48 <makalu> quchen: http://lpaste.net/109358 any idea why I get no instance error? There's Monad m => Stream Text m Char in Text.Parsec.Prim
04:53:52 <mietek> transformers-0.4.1.0 failed during the configure step. The exception was:
04:53:52 <mietek> user error (The package 'transformers' requires Cabal library version >=1.19.2
04:53:53 <mietek> && >=1.6 but no suitable version is installed.)
04:54:07 <mietek> How did this happen?
04:54:24 <mietek> I don't see the Cabal library listed in build-depends for transformers-0.4.1.0
04:54:56 <mietek> Oh, I see
04:55:10 <mietek> cabal install --allow-newer=unix transformers-0.4.1.0
04:56:23 <quchen> makalu: What type does GHC infer for the lexer?
04:56:32 <quchen> Maybe your type sig is incorrect
04:56:52 <makalu> "No instance for (Stream s0 m0 Char)" if I remove the signature :)
04:57:40 <makalu> obviously
04:57:47 <quchen> That's odd, there is an instance for that in the docs: Monad m => Stream Text m Char
04:58:40 <makalu> http://lpaste.net/109359
05:00:04 <quchen> Instead of making a "Parser" type yourself, import Text.Parsec.Text(.Lazy)
05:00:15 <quchen> Seems unrelated, but try it anyway
05:00:36 <supki> the instance is in Text.Parsec.Text
05:01:11 <quchen> Good catch!
05:03:27 <makalu> thanks
05:04:28 <makalu> but what's up with attoparsec? I import Data.Attoparsec.Text and "parse double $ T.pack "1.0"" gives me "Partial _"
05:06:36 <makalu> oh nevermind, it's incremental :)
05:06:51 <makalu> (I've only used parsec)
05:07:05 <kstt> hi. It seems that starting a haskell executable on windows will display the windows command window. How can I avoid that please ?
05:08:57 <Phillemann> makalu: Ah, so there might be more digits...
05:09:03 <Phillemann> I didn't see it at first, too.
05:12:07 <kstt> ok, it should be GHC option  -optl-mwindows
05:12:35 <makalu> oh parseOnly is useful in this case
05:13:31 <Phillemann> makalu: Apart from that, I think you can always give the Partial callback the empty string.
05:31:23 <jcullen> hey all.. trying to upgrade to the new haskell platform on linux.. and running into some cabal dependency issues, think anyone could help me out?
05:31:41 <jcullen> not sure what the error message I'm gettin g means exactly
05:32:02 <doismellburning> jcullen: until you pastebin it, I doubt anyone will be able to help with much
05:32:15 <jcullen> working on it haha
05:33:15 * hackagebot references 0.2.0.0 - Generalization of lenses, folds and traversals to handle monads and addition.  http://hackage.haskell.org/package/references-0.2.0.0 (lazac)
05:36:16 <doismellburning> win 55
05:36:18 <doismellburning> er sorry
05:36:34 <jcullen> http://pastebin.com/aHEtCe6y
05:36:46 <jcullen> that is the paste of the cabal install command I'm trying to run and the error
05:37:24 <jcullen> http://pastebin.com/dWYtAiZ0
05:37:28 <jcullen> and here is the output of ghc-pkg list
05:38:06 <jcullen> the only thing I've done is install the new haskell platform, upgrade cabal-install, cabal update, and enable profiling in my .cabal/config
05:38:40 <jcullen> thought I was on the right track to avoiding dependency issues by installing everything at once but I guess not
05:40:40 <adas> jcullen: you should try sandboxes
05:44:15 <nooodl> hey, i realized something neat!
05:44:22 <jcullen> adas: not sure exactly how to go about that.  I understand sandboxing for development, but i'm not exactly sure how to go about installing libraries in a sandbox
05:45:04 <adas> jcullen: what OS are you using?
05:45:15 <adas> nooodl: share the (wealth :: Knowledge)
05:46:08 <nooodl> if you write the obvious "pick :: MonadRandom m => [a] -> m (Maybe (a, [a]))" with e.g. pick [1..5] yielding something like "Just (2,[1,3,4,5])"
05:46:16 <nooodl> and pick [] yielding "Nothing"
05:46:35 <nooodl> then shuffling a list is just "unfoldrM pick"!
05:47:17 <jcullen> adas: ubuntu 14.04
05:48:34 <nooodl> MonadRandom is really cool. it seems like a potentially interesting introduction to the concept of monads?!
05:48:48 <jcullen> :i MonadRandom
05:48:57 <jcullen> aww, thought that would work
05:48:58 <jcullen> haha
05:48:59 <adas> jcullen: https://github.com/bitemyapp/learnhaskell
05:49:12 <adas> jcullen: there are instruction for 12.04 and above
05:49:38 <adas> i think its > :i MonadRandom
05:50:55 <jcullen> > :i MonadRandom
05:50:56 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
05:51:06 <jcullen> >:i MonadRandom
05:51:08 <nooodl> @info MonadRandom
05:51:08 <lambdabot> MonadRandom
05:51:16 <pjdelport> nooodl: Neat. :)
05:51:29 <pjdelport> MonadRandom is a great example of a monad, yeah.
05:57:48 <SwashBuckla> yay haskell!
05:58:46 <jcullen> adas: someone on reddit recommended using allow-newer flag with cabal-install.  with that flag cabal can resolve the dependencies.. I'm gonna give that a shot and see if everything works out before going for sandboxes
06:08:20 * hackagebot OpenCLWrappers 0.1.0.3 - The OpenCL Standard for heterogenous data-parallel computing  http://hackage.haskell.org/package/OpenCLWrappers-0.1.0.3 (EmilKarlson)
06:08:22 * hackagebot rtld 0.0.2 - dynamic linker tools for Haskell  http://hackage.haskell.org/package/rtld-0.0.2 (KrzysztofKardzis)
06:10:38 <pejo> I've set LANG and LC_ALL to C. I still get error messages like " Not in scope: type constructor or class ‚" from ghci. What environment variable should I set?
06:18:22 * hackagebot curlhs 0.1.1 - bindings to libcurl, the multiprotocol file transfer library  http://hackage.haskell.org/package/curlhs-0.1.1 (KrzysztofKardzis)
06:21:58 <jle`> anyone want to talk about deep stuff
06:22:16 <nooodl> deep?
06:22:47 <jle`> spopejoy: nope! :D
06:22:56 <jle`> ((->) a) b
06:22:59 <jle`> works
06:23:48 <jle`> oh wow i was back seven hours in the logs
06:23:51 <jle`> sorry spopejoy
06:24:09 <spopejoy> :)
06:24:28 <adas> jle`: whats ((->) a) b
06:24:34 <adas> function type?
06:24:50 <jle`> it's (->) a b, according to precedence rules
06:24:59 <jle`> which is a -> b, because (->) can be used as an infix operator
06:25:17 <jle`> it's cute like that
06:26:08 <Iceland_jack> @kind forall a b. a -> b
06:26:08 <lambdabot> *
06:26:15 <Iceland_jack> @kind forall a b. ((->) a) b
06:26:16 <lambdabot> *
06:31:28 <spopejoy> interesting that ((->) a) by itself is illegal, though
06:31:49 <spopejoy> @define f :: ((->) a) b; f = undefined
06:31:50 <lambdabot>  .L.hs:153:1:
06:31:50 <lambdabot>      Duplicate type signatures for ‚Äòf‚Äô
06:31:50 <lambdabot>      at .L.hs:150:1
06:31:50 <lambdabot>         .L.hs:153:1
06:31:50 <lambdabot>  
06:31:55 <spopejoy> @undef f
06:31:55 <lambdabot> There's currently no way to undefine just one thing.  Say @undefine (with no extra words) to undefine everything.
06:32:02 <spopejoy> @undef
06:32:02 <lambdabot> Undefined.
06:32:12 <spopejoy> @define f :: ((->) a) b; f = undefined
06:32:13 <lambdabot>  Defined.
06:32:33 <nooodl> :t f
06:32:33 <lambdabot>     Ambiguous occurrence ‚Äòf‚Äô
06:32:34 <lambdabot>     It could refer to either ‚ÄòL.f‚Äô,
06:32:34 <lambdabot>                              defined at /home/lambda/.lambdabot/State/L.hs:148:1
06:32:44 <nooodl> :t L.f
06:32:45 <spopejoy> @define g :: ((->) a) : g = undefined
06:32:45 <lambdabot> a -> b
06:32:45 <lambdabot>  .L.hs:149:15: parse error on input ‚Äò:‚Äô
06:33:08 <spopejoy> @define g :: ((->) a) ; g = undefined
06:33:09 <lambdabot>  .L.hs:150:7:
06:33:09 <lambdabot>      Expecting one more argument to ‚Äò(->) a‚Äô
06:33:09 <lambdabot>      Expected a type, but ‚Äò(->) a‚Äô has kind ‚Äò* -> *‚Äô
06:33:09 <lambdabot>      In the type signature for ‚ÄòL.g‚Äô: L.g :: (->) a
06:33:20 <BoR0> :k (-> a) b
06:33:21 <lambdabot> parse error on input ‚Äòa‚Äô
06:33:28 <orion> :k [String]
06:33:29 <lambdabot> *
06:33:41 <orion> :k [[a]]
06:33:42 <lambdabot> Not in scope: type variable ‚Äòa‚Äô
06:33:54 <orion> :k [[Char]]
06:33:55 <lambdabot> *
06:34:01 <Iceland_jack> :k forall a. [[a]]
06:34:02 <lambdabot> *
06:34:13 <spopejoy> ((->) a) b is valid, just ((->) a) is not
06:34:18 <BoR0> shouldn't :k a -> b return * -> *? or am I missing the point of kind
06:34:35 <Iceland_jack> It shouldn't return * -> *
06:34:46 <Iceland_jack> ((->) a) should
06:34:55 <Iceland_jack> :k forall a. ((->) a)
06:34:55 <lambdabot> * -> *
06:35:28 <orion> :k []
06:35:29 <lambdabot> * -> *
06:35:32 <orion> :k [[]]
06:35:33 <lambdabot>     Expecting one more argument to ‚Äò[]‚Äô
06:35:33 <lambdabot>     Expected kind ‚Äò*‚Äô, but ‚Äò[]‚Äô has kind ‚Äò* -> *‚Äô
06:35:33 <lambdabot>     In a type in a GHCi command: [[]]
06:35:41 <orion> hmm
06:35:50 <jcullen> BoR0: It doesn't have kind * -> * because the a and b are implicity universally quantified
06:36:07 <BoR0> I see
06:36:09 <BoR0> :k Maybe
06:36:10 <lambdabot> * -> *
06:36:12 <BoR0> :k Maybe Int
06:36:13 <lambdabot> *
06:36:24 <BoR0> :k (->) ((->) a b)
06:36:25 <lambdabot> Not in scope: type variable ‚Äòa‚Äô
06:36:25 <lambdabot> Not in scope: type variable ‚Äòb‚Äô
06:36:38 <orion> It's a shame I can't manipulate ByteStrings in the [] Monad the way I can with Strings.
06:36:39 <BoR0> :k (->) ((->) Int Int)
06:36:40 <lambdabot> * -> *
06:36:53 <BoR0> jcullen, so it basically shows you the "holes" ?
06:38:05 <jcullen> BoR0: basically, you just have to remember that in a -> b, a and b aren't "holes"
06:38:15 <jcullen> BoR0: because its short for forall a b. a -> b
06:38:21 <BoR0> but (->) a has one hole, right?
06:38:27 <jcullen> yes
06:38:51 <BoR0> :k (->) a -- is there a way to write this same using infix? e.g. (a ->) but this doesn't work
06:38:52 <lambdabot> Not in scope: type variable ‚Äòa‚Äô
06:40:36 <jcullen> BoR0: you could use a newtype or a type alias
06:40:56 <jcullen> type Whatever a b = a -> b
06:41:00 <jcullen> should work
06:41:03 <jcullen> or rather
06:41:08 <jcullen> type Whatever a b = b -> A
06:41:11 <jcullen> type Whatever a b = b -> a
06:41:19 <jcullen> and then you can partially apply Whatever a
06:41:38 <BoR0> I see, kinda like Maybe
06:42:25 <jcullen> that should work I think anyways, I dont have ghci access right now, reinstall ghc :P
06:42:31 <jcullen> reinstalling*
06:43:25 * hackagebot json-assertions 1.0.4 - Test that your (Aeson) JSON encoding matches your expectations  http://hackage.haskell.org/package/json-assertions-1.0.4 (OliverCharles)
06:44:36 <jcullen> does hackagebot trigger whenever someone uploads something new to hackage?
06:51:43 <bennofs> jcullen: it has some delay (~5 mins IME) but yes
06:58:53 <jcullen> cool
07:31:13 <RyanGlScott> Quick survey: what GHC flags do you always use to check for good coding style (e.g., -Wall)?
07:31:29 <orion> hmm
07:32:16 <orion> Are there some algorithms which simply can't be evaluated in constant space, regardless of whether you evaluate it in a strict or lazy manner?
07:33:35 <bennofs> RyanGlScott: I use -Wall only. I also run hlint on my code
07:49:19 <MagneticDuck1> orion: my connection blipped, were you answered?
07:49:32 <orion> MagneticDuck1: nope
07:49:32 <MagneticDuck1> anyway, you're talking about something related to the halting theorem
07:49:36 <MagneticDuck1> and yes, there are
07:50:56 <MagneticDuck1> in short, checking whether a program written in a turing-complete language is an algorithm that may require infinite space
07:51:26 <orion> MagneticDuck1: I am trying to make all permutations of a password.
07:51:33 <MagneticDuck1> okay
07:51:44 <MagneticDuck1> what's your password space
07:51:44 <orion> I've tried deepseq, and it seems that I just can't get it to use constant space.
07:51:48 <orion> 2^26
07:52:07 <MagneticDuck1> what's the bottleneck in the system
07:52:12 <MagneticDuck1> where are you checking the password?
07:52:17 <MagneticDuck1> are you reversing a hash?
07:53:03 <int-e> > map generalCategory "√•√§√∂"
07:53:04 <lambdabot>  [LowercaseLetter,LowercaseLetter,LowercaseLetter]
07:53:33 <hiptobecubic> :t generalCategory
07:53:34 <lambdabot> Char -> GeneralCategory
07:53:40 <hiptobecubic> ... sigh
07:54:04 <MagneticDuck1> ?
07:54:09 <hasf> > foldl (+) 0 [1,2,3,4,5]
07:54:11 <lambdabot>  15
07:54:18 <orion> MagneticDuck1: http://ideone.com/y4fJp9
07:55:40 <orion> MagneticDuck1: downstream I am running each password through PBKDF2, but I'm *not* doing that until I can get this particular section of code working in constant space.
07:56:03 <MagneticDuck1> ...
07:56:16 <MagneticDuck1> it's working in constant space
07:56:22 <MagneticDuck1> infinity /= a big number
07:56:27 <orion> Ok, well I'm misinformed then.
07:56:57 <monochrom> infinity is *the* big number :)
07:58:15 <centrinia> Infinity encompasses all big numbers.
08:00:04 <orion> MagneticDuck1: http://i.imgur.com/yo97jhu.png <-- is that what constant space looks like?
08:00:05 <MagneticDuck1> infinity is not a number.. usually, kinda, depends who you ask
08:00:23 <hiptobecubic> monochrom, what about the other infinites?
08:00:30 <MagneticDuck1> orion: that's what big space looks like xD
08:00:34 <hiptobecubic> infinities* rather
08:00:38 <MagneticDuck1> dude, permute terminates for smaller inputs, right?
08:00:46 <bennofs> orion: I get               21 MB total memory in use (0 MB lost due to fragmentation)
08:00:48 <MagneticDuck1> you should be able to prove that it will terminate for all inputs
08:01:04 <MagneticDuck1> -> constant space
08:01:05 <bennofs> orion: using ghc -O2  version 7.8.3
08:01:08 <orion> MagneticDuck1: It does terminate for smaller inputs. It terminated for my graph.
08:01:18 <MagneticDuck1> yes
08:01:46 <barrucadu> MagneticDuck1: How does termination imply constant space?
08:01:46 * MagneticDuck1 is not sure what he's arguing
08:02:03 <orion> bennofs: Try the string "laeioslaeioslaeioslaeiosla"
08:02:09 <orion> You'll run out of memory.
08:02:23 <MagneticDuck1> well that's not hard to predict :D
08:02:37 <MagneticDuck1> barrucadu: go away, math guy :D
08:02:45 <MagneticDuck1> we're talking about computations that can actually be computed on computers
08:02:52 <barrucadu> I know
08:02:53 <orion> MagneticDuck1: Basically, I want to modify this code to run on my computer.
08:02:57 <MagneticDuck1> <3
08:03:00 <barrucadu> I just don't see how constant space comes in here
08:03:05 <MagneticDuck1> yeah I don't know either
08:03:16 <MagneticDuck1> orion was talking about how his algorithm is using infinite space or something
08:03:21 <MagneticDuck1> orion: well.
08:03:25 <orion> I clearly don't know what constant space means.
08:03:34 <orion> To me, I think it means when your heap profile graph is flat./
08:03:42 <MagneticDuck1> you could let your program have more memory
08:03:42 <barrucadu> Constant space means that the space usage of the algorithm is independent of the size of the input.
08:03:49 <MagneticDuck1> oh
08:03:52 * MagneticDuck1 messed up
08:03:54 <MagneticDuck1> never mind <3
08:03:58 <MagneticDuck1> was thinking about something else
08:04:17 <orion> Alright.
08:04:31 <MagneticDuck1> I know what you want then
08:04:35 <MagneticDuck1> recursion is not the answer
08:04:41 <MagneticDuck1> the answer is modulo!
08:04:42 <pjdelport> barrucadu: "Constant space" also implies "bounded by a constant", to be precise.
08:04:59 <MagneticDuck1> use a counter as the program state, and just increment the counter until you get to 2^16
08:05:08 <MagneticDuck1> at every step, find the corresponding string for your counter
08:05:13 <pjdelport> An algorithm can be independent of the size of the input by always consuming unbounded resources. :)
08:05:28 <orion> wait a minute
08:05:58 <MagneticDuck1> pjdelport: well, that's only if you accept infinity as an actual, comparable value in your set of numbers
08:06:16 <orion> If the space used by your algorithm is dependent on the size of your input, wouldn't that imply that your algorithm runs in linear space, not constant space?
08:06:34 <pjdelport> orion: N^2 also depends on N
08:06:59 <orion> pjdelport: Could you rephrase that?
08:07:34 <barrucadu> orion: Your algotihm could take n^2 space for an input of size n - which isn't linear space
08:07:35 <pjdelport> orion: I mean that depending on the size of the doesn't imply it's linear: it can be quadratic, or logarithmic, or anything else, too.
08:08:14 <pjdelport> So "depends on N" can mean any non-constant function of N (where N is the size of the input)
08:10:50 <orion> pjdelport: In my case, would you agree that the permute function runs in n^2 space?
08:11:56 <pjdelport> orion: If you're storing all the permutations, it would be O(N!) space, surely?
08:12:22 <pjdelport> (Or O(n * n!) i guess)
08:13:00 <orion> Right
08:13:12 <orion> Is there a way to reduce that? :)
08:14:18 <kvelicka> Hi guys. When making non-backward compatible changes to a library, is there a standard process of deprecating the old stuff?
08:14:52 <bennofs> orion: i don't know why this is the case yet, but this version of permute doesn't have the memory leak:
08:14:55 <bennofs> permute :: String -> [String]
08:14:57 <bennofs> permute [] = [[]]
08:14:59 <bennofs> permute (c:cs) = [ c':cs' | cs' <- permute cs, c' <- leet c ]
08:15:23 <taruti> Who is responsible for hackage accounts?
08:15:59 <bennofs> orion: note that if you swap cs' <- permute cs and c' <- leet c, the problem appears again
08:16:36 <bennofs> orion: your version is equavilent to the swapped one
08:16:59 <pjdelport> orion: The first thing you'll probably want to do is use a Vector or Array instead of a list.
08:17:01 <orion> bennofs: Wow, that's a lot simpler.
08:17:34 <bennofs> pjdelport: why use vector or array for this?
08:18:04 <pjdelport> orion: You can then do the permutation in-place using factoradics and Lehmer coding.
08:18:37 <pjdelport> That gives you a nice way to distribute the work, too.
08:18:39 <naudiz> I'm currently playing around with Yesod and it's the first time I'm using the cabal-sandbox... now I need some Libraries that are not included with Yesod, how can I add them to the sandbox?
08:18:57 <pjdelport> (and keep track of what ranges of permutations have been checked and what not)
08:19:23 <saep> kvelicka: It depends on you versioning scheme. If you use semantic versioning, you would increase the the major version.
08:19:28 <sgronblo> liftM is equivalent to fmap?
08:19:50 <geekosaur> sgronblo, it's kind of a historical artifact
08:19:57 <bennofs> sgronblo: yes, the only difference is that liftM has a Monad and not a Functor constraint
08:19:58 <sgronblo> which one_
08:20:08 <naudiz> Yesod tells me for Syste.Filepath: "Perhaps you need to add ‚Äòfilepath‚Äô to the build-depends in your .cabal file." ‚Äì but there is no .cabal in the working directory
08:20:12 <monochrom> MagneticDuck1: in one context (projective real line), there needs only one infinity :)
08:20:26 <naudiz> s/Syste.Filepath/System.Filepath
08:20:34 <sgronblo> http://hackage.haskell.org/package/base-4.7.0.1/docs/src/Control-Monad.html#liftM Is there a reason to not just write liftM = fmap ?
08:20:36 <geekosaur> a Monad is known to always be a Functor, but this is not reflected in the Haskell definition, so liftM is a purely Monad implementation of fmap
08:20:53 <orion> bennofs: Are you sure?: http://ideone.com/y4fJp9
08:20:54 <geekosaur> modern code typically uses fmap directly since you should not have a Monad that is not a Functor
08:20:55 <bennofs> orion: there is an even simpler version, which has the space leak: permute = mapM leet
08:21:19 <pjdelport> sgronblo: You'll want to read http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal :)
08:21:32 <bennofs> orion: note I replaced permute [] = [] by permute [] = [[]]
08:21:39 <bryan__> Hello.  How to do a list of IO (Either a b) actions, but stop on the first one that returns Left?   [IO (Either a b)] -> IO (Either a [b])
08:21:54 <sgronblo> wait... Monad is separate from Functor too?
08:22:02 <geekosaur> currently
08:22:02 <bryan__> Is there a standard function for that?
08:22:06 <nooodl> i get annoyed by having to type my function (Functor m, Monad m) => ... just because i use fmap :(
08:22:06 <pjdelport> sgronblo: Yes, for hysterical raisins.
08:22:08 <kvelicka> saep: I meant in a sense that I'm making some changes that appear to make backwards compatibility pretty much impossible. What should I do in that case? Don't suppose it's a good idea to just drop support like that
08:22:09 <sgronblo> I thought it was just that Applicative was missing from the middle of the hierarchy
08:22:11 <nooodl> similarly for (<$>)
08:22:14 <geekosaur> see the page pjdelport pointed you to
08:22:26 <pjdelport> sgronblo: But that is fixed / will be fixed soon.
08:22:31 <sgronblo> There should be only one way to do it
08:22:34 <nooodl> bryan__: sequence i think
08:22:38 <naudiz> isn't there someone in here who has experience with the cabal sandbox?
08:22:38 <MagneticDuck1> orion: http://ix.io/dTz
08:22:40 <MagneticDuck1> that may be of use
08:22:44 <sgronblo> When will that hierarchy be changed?
08:22:51 <nooodl> or hm
08:22:58 <geekosaur> Applicative is a sort of missing link between them, but even before we had Applicative it was known that all Monad-s were Functor-s
08:23:16 <bryan__> nooodl: sequence will evaluate all of the IO actions in the list I think
08:23:18 <geekosaur> (but not always reflected in the definitions)
08:23:20 <bennofs> MagneticDuck1: the 'permute' name of orion's function is misleading. All that the function is doing is mapM leet
08:23:32 <MagneticDuck1> yeah
08:23:42 <orion> bennofs: Ah, but memory still blows up
08:23:48 <orion> With the list comprehension version.
08:23:53 <MagneticDuck1> orion: ... which is where my idea comes in
08:24:01 <MagneticDuck1> no need for lots of memory or recursion
08:24:05 <nooodl> sequence gets you "IO [Either a b]" and then (fmap sequence) gets you "IO (Either a [b])"
08:24:07 <MagneticDuck1> my solution is actually constant space
08:24:17 <MagneticDuck1> (excluding the growing stdout buffer =P)
08:24:31 <bennofs> MagneticDuck1: permute (c:cs) = [ c':cs' | cs' <- permute cs, c' <- leet c ] was constant space on my computer with GHC 7.8.3 -O2 too
08:24:39 <hexagoxel> sgronblo: ghc 7.10
08:24:41 <nooodl> :t fmap sequence . sequence
08:24:42 <lambdabot> (Functor f, Monad m, Monad f) => [f (m a)] -> f (m [a])
08:24:43 <eacameron> I hear Spolsky's "Law of Leaky Abstractions" thrown around from time to time and it garners suspicion toward abstraction in general; but as a Haskeller, I feel that abstraction can and should be highly trusted so I'm inclined to say that Spolsky's "law" is at best misleading and at worst just wrong. Thoughts?
08:25:04 <geekosaur> re the IO Either thing, I was wondering about MonadPlus
08:25:21 <pjdelport> bryan__: You can do it in two traversals with: fmap sequenceA . sequenceA
08:25:26 <geekosaur> eacameron, I think some languages make "leaky" abstraction easier
08:25:30 <saep> kvelicka: What is your definition of support? Increasing the version number does not mean that you do not support the older version anymore.
08:25:39 <geekosaur> Haskell tends to encourage sensible abstraction
08:25:41 <pjdelport> bryan__: Or in one with sequenceA2 = foldr (liftA2 (liftA2 (:))) (pure (pure []))
08:25:47 <hiptobecubic> eacameron, there are very few languages that give you any control over anything whatsoever. In the context of those languages, abstractions are hard to properly create.
08:25:55 <pjdelport> Where sequenceA2 is like sequenceA, except two levels deep.
08:25:57 <eacameron> geekosaur: true; my impression is that abstraction is all about making guarantees and keeping them; haskell abstractions are very good at that
08:26:12 <carter> a leaky abstraction is worse than no abstraction
08:26:17 <bryan__> pjdelport: thanks, I'll give that a try
08:26:22 <carter> a real abstraction is better than either
08:26:23 <carter> :)
08:26:45 <pjdelport> bryan__: The definition of sequenceA2 mirrors sequenceA = foldr (liftA2 (:)) (pure [])
08:26:59 <bennofs> bryan__: do you want to execute all IO actions and then only retain the values until the first Left, or do you also only want to execute the IO actions until the first one returns Left?
08:27:27 <eacameron> it's interesting to note that ALL (I'm pretty sure) leaks that Spolsky mentions are performance related; but NONE of the abstractions that he mentions actually make any performance GUARANTEES
08:28:18 <bryan__> pjdelport: I only want to execute IO actions until first Left so I can report an error on the first problem found
08:28:27 <carter> eacameron: interestingly enough, its possible to build some really nice high level abrractions that have nice perf guarnatees
08:28:42 <eacameron> I guess having controlled effects is very important for making true guarantees
08:28:46 <carter> eh
08:28:49 <carter> depends :)
08:28:56 <MagneticDuck1> orion: http://ix.io/dTB
08:28:59 <carter> whats the examples he cites/
08:29:10 <MagneticDuck1> bennofs: oh x|
08:29:29 <eacameron> TCP, SQL, looking up the rest...
08:29:45 <eacameron> NTFS mount
08:29:46 <pjdelport> bryan__: Ah, in that case you'll need something more specialized.
08:30:02 <eacameron> (or any network based mounting)
08:30:16 <eacameron> his complaint: they might end up being really slow
08:30:21 <eacameron> when you thought they would be fast
08:30:31 <bryan__> I just wrote seqEithers :: [IO (Either e b)] -> IO (Maybe e)     seems to fit the bill, returns Nothing if all goes well, or the first Left result
08:31:00 <vanila> seq might be confusing
08:31:03 <carter> eacameron: hrmm
08:31:04 <carter> well
08:31:06 <vanila> sequenceEithers would be clearer
08:31:09 <orion> MagneticDuck1: Could you explain how your code works?
08:31:16 <bryan__> pjdelport: In this case I don't need the Right results, so writing seqEithers :: [IO (Either e b)] -> IO (Maybe e)    will do, thanks for the help
08:31:24 <carter> the problme there is you can gget good throughput, but not good latency right?
08:31:27 <MagneticDuck1> it works by the magic of modulo!
08:31:30 <eacameron> carter: driving fast in the rain with windshield wipers.....
08:31:34 <vanila> :t listToMaybe
08:31:35 <lambdabot> [a] -> Maybe a
08:31:43 <carter> eacameron:?
08:31:48 <vanila> listToMaybeIO might be more compatable with normal naming
08:31:54 <eacameron> carter: that's a leaky abstraction apparently
08:31:55 <carter> i have trouble mixing metaphors with engineering
08:32:01 <MagneticDuck1> orion: your example is a restrained case of my little algorithm
08:32:05 <orion> bennofs: How many characters was your input?
08:32:19 <MagneticDuck1> essentially, you're just counting to 2^18 in base 2 and then mapping some sort of function onto each of the digits
08:32:20 <osfameron> I don't the leaky abstractions thing is *against* making abstractions.  it's mostly just a rueful rant about stuff being hard, I think
08:32:42 <MagneticDuck1> my program does the same type of math, but works in strange "bases" where different digits have different exponents
08:33:08 <eacameron> carter: I think his point about TCP being a leaking abstraction is off since TCP does not and cannot make performance guarantees; those are simply not part of the abstraction
08:33:28 <eacameron> TCP abstracts across data transfer, not the time axis
08:33:30 <carter> yeah
08:33:53 <carter> its strong ordering guarntees PROMISE that perf will be iffy
08:34:04 <eacameron> exactly
08:35:01 <eacameron> I'm thinking about writing a blog to mildly challenge his law, not because I think he's dumb (he's not!) but because I think too many people use it to write off abstractions as unreliable
08:35:45 <bennofs> MagneticDuck1: anyway, in this program, the bottleneck is the IO, not the permuting
08:35:47 <eacameron> if they had a more mathematical understanding of abstraction, I doubt there would be as much suspicion
08:36:35 <geekosaur> I feel like I've read a Spolsky follow-on that made some points about that
08:36:52 <eacameron> geekosaur: by Spolsky himself?
08:36:57 <geekosaur> yes
08:37:04 <eacameron> whoa! I'd love to find that
08:37:05 <geekosaur> ...I think
08:37:24 <geekosaur> I know I have read various responses to it in multiple places that made those points, and I *think* one was by Spolsky himself
08:37:59 <carter> i kinda regard abstractions as parametric in the things they don't specify :)
08:38:03 <eacameron> geekosaur: oh good, then I don't need to do it again. :) I just need to find those articles so I can give them to people when they cite his law ;)
08:38:19 <eacameron> carter: haha...I think that's the point!
08:38:24 <geekosaur> might have been tied into "big head/little head" (referring to an Israeli idiom about, loosely, people who understand vs. people who blindly copy)
08:39:13 <eacameron> geekosaur: yeah, that's the main issue. I dislike it when people on the internet are wrong.... ;)
08:39:35 <eacameron> but when big names like Spolsky go touting around "Laws" that they make up...it's much harder
08:39:57 <orion> bennofs: I ran your code with -O2 on 7.8.3: http://i.imgur.com/ZESaahW.png
08:40:04 <orion> Is that what you expect?
08:40:36 <eacameron> Colleage: You *dare* to doubt the LAW of leaky abstractions???!
08:40:55 <eacameron> *colleague
08:40:56 <carter> eacameron: so by treating abstractions as parametric in what they dont specify, i have an adversarial view of how things behave
08:40:59 <carter> but not a lying view
08:41:07 <carter> code doesn't leak, it trols!
08:41:09 <carter> *trolls
08:42:18 <eacameron> carter: hahaha; adversarial?
08:42:44 <geekosaur> in any case the whole /rosh katan/ rant was about people who treat things like that as immutable Laws instead of as considerations to keep in mind during design
08:43:08 <geekosaur> so Spolsky is entirely aware of the fact that people misconstrue his posts that way
08:43:34 <bennofs> orion: hmm, no
08:43:41 <eacameron> geekosaur: well said; he's still one of my favorites; always so insighful
08:43:44 <eacameron> but not infallible
08:44:18 <bennofs> orion: I get: http://i.imgur.com/R9c9sIK.png
08:44:36 <carter> eacameron: geekosaur  i've met him IRL, very nice quiet guy
08:44:47 <orion> bennofs: Wow, that's weird.
08:45:15 <bennofs> orion: the code: https://gist.github.com/bennofs/d77a2e96bd1a4ee66bdb
08:46:21 <eacameron> carter: very cool
08:48:39 <orion> bennofs: Ahh, I found a discrepancy in my code. I am now able to reproduce your results.
08:48:44 <orion> Quite interesting!
08:48:54 <orion> MagneticDuck: Your code is interesting too.
08:49:49 <cow_2001> offtopic: this is pretty cool https://github.com/Russell91/pythonpy
08:50:19 <orion> bennofs: I find it quite interesting that replacing your code with mapM changes the memory complexity.
08:50:57 <bennofs> orion: yeah, an also swapping the assignments in the list comp change memory complexity
08:51:25 <orion> Is that expected?
08:51:35 <orion> Could it be a bug perhaps?
09:00:31 <geekosaur> orion: I think it's not unexpected, and difficult to fix? it sounds like some known issues
09:01:52 <geekosaur> some optimizations are specified as RULEs, and those may not fire if the pattern isn't recognizeable or if it could cover cases where the optimization turns out to be a major pessimization
09:02:09 <geekosaur> ..or, occasionally, do fire in cases where it creates a pessimization
09:02:09 <orion> geekosaur: Where can I read more about this?
09:02:33 <geekosaur> the ghc trac/wiki might be the best place. Also maybe pop into #ghc and ask
09:02:49 <orion> geekosaur: ok, thank you
09:05:04 <eacameron> I'm doing `atomically $ replicateM 100 $ readTMQueue queue` to get a batch of Maybe a items from the queue. But at the end of the pipeline, that batch might be mostly Nothings. Is there an easy way to "sequeunce" the calls to readTMQueue so that it immediately stops reading on the first sight of Nothing?
09:07:40 <carter> eacameron: mapM then filter
09:07:41 <carter> ?
09:07:45 <carter> ohhh
09:07:48 <carter> hrmm
09:08:05 <eacameron> carter: that's basically what I'm doing
09:08:20 <carter> you could write mapMaybeBail
09:08:32 <carter> or use something like ExceptT ?
09:18:37 <Ankhers> What is it called if I define a function like  `foo = map toLower ` instead of `foo x = map toLower x`?
09:18:53 <ion> eta-reduction
09:18:54 <Iceland_jack> eta reduction
09:19:26 <Ankhers> ion, Iceland_jack: Thank you!
09:20:22 <keko_> or point-free
09:20:39 <orion> Currying?
09:20:48 <theli0nheart> I'm playing around with Aeson and am trying to figure out how one might parse a JSON payload without knowing its format beforehand. Is that even possible with Haskell?
09:21:13 <SwashBuckla> how do you do something when a lookup returns Nothing?
09:21:15 <SwashBuckla> (command:args) <- getArgs; let action = lookup command dispatch;
09:21:37 <SwashBuckla> (Data.List.lookup)
09:21:50 <barrucadu> orion: Currying is when you turn a function of type (a, b) -> c to a -> b -> c
09:22:25 <barrucadu> Or, more generally, a function from a n-tuple to a series of one-argument functions returning other functions
09:22:36 <orion> barrucadu: ah
09:23:14 <supki> theli0nheart: sure, you parse it to a generic representation e.g. aeson Value and work with that
09:23:15 <Iceland_jack> @ty curry
09:23:15 <lambdabot> ((a, b) -> c) -> a -> b -> c
09:23:28 <flojistik> a shame that uncurrying is not called "Haskelling"
09:24:30 <SwashBuckla> Iceland_jack helped me
09:24:33 <SwashBuckla> ;)
09:24:46 <SwashBuckla> case lookup command dispatch of...
09:24:46 <Iceland_jack> haha
09:25:00 <keko_> theli0nheart: see under "Working with the AST" https://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson.html
09:26:01 <theli0nheart> keko_: woot, that did it. thanks!
09:26:24 <Ankhers> Is it generally a good practice to write your functions in point-free if possible?
09:26:35 <Iceland_jack> Ankhers: It really depends
09:27:28 <doismellburning> Ankhers: I would suggest writing your functions as clearly as possible until other factors become necessary
09:27:36 <Iceland_jack> if you have something basic like
09:27:36 <Iceland_jack>     foo xs = f (g (h (j xs)))
09:27:36 <Iceland_jack> something like
09:27:36 <Iceland_jack>     foo = f . g . h . j
09:27:39 <Iceland_jack> exposes the structure better
09:29:26 <Iceland_jack> but don't go out of your way to define something pointfree, keep in mind that it can be a lot harder to read code than it is to write it: my rule of thumb is to be smart in my own code and stupid in public code
09:30:38 <Ankhers> foo xs = f (not . g) (map j xs) as foo = f (not . g) . map j
09:30:58 <Ankhers> I'm sorry, that is hard to read on one line...
09:32:02 <Ankhers> Iceland_jack: That makes sense. Thanks.
09:32:54 <Iceland_jack> for example
09:32:54 <Iceland_jack>     foo xs = f xs == xs
09:32:54 <Iceland_jack> could be rewritten pointfree as
09:32:54 <Iceland_jack>     foo = f >>= (==)
09:33:48 <Ankhers> I don't think I would have thought of that.
09:34:14 <Iceland_jack> And you probably wouldn't like to meet that in your codebase
09:34:29 <Iceland_jack> while 'f xs == xs' is perfectly clear
09:34:56 <Ankhers> Fair enough.
09:35:15 <Iceland_jack> But you can't say in general, people have their preferences and it depends who your audience is
09:35:21 <bernalex> Defined in ‚Äòinteger-gmp:GHC.Integer.Type‚Äô -- where is that? what file?
09:35:21 <phaskell> No symbol 'that' found anywhere.
09:36:25 <keko_> where is GHC.Integer.Type?
09:36:26 <phaskell> No symbol 'GHC.Integer.Type' found anywhere.
09:36:29 <bernalex> phaskell: lolwat
09:36:41 <bernalex> it responds to "where is"?
09:36:42 <josephle> what does phaskell bot do?
09:36:42 <keko_> where is map?
09:36:43 <phaskell> No symbol 'map' found anywhere.
09:36:53 <Iceland_jack> where is Waldo?
09:36:54 <phaskell> No symbol 'Waldo' found anywhere.
09:37:04 <josephle> time to find out -- where is phaskell?
09:37:04 <phaskell> No symbol 'phaskell' found anywhere.
09:37:07 <bernalex> josephle: phabricator stuff
09:37:14 <bernalex> where is D134?
09:37:15 <phaskell> D134: fix T4981-V3 and T9208 tests for no newline at end of file warning - https://phabricator.haskell.org/D134
09:37:15 <phaskell> No symbol 'D134' found anywhere.
09:37:22 <bernalex> heh
09:37:24 <funfunctor1> Hi
09:37:40 <bernalex> but anyway, anyone know where Integer is defined in GHC?
09:37:53 <funfunctor1> Has anyone worked a lot with Happy to write production rules (sic BNF)?
09:38:11 <keko_> here? http://www.haskell.org/ghc/docs/7.4.1/html/libraries/integer-gmp-0.4.0.0/GHC-Integer-GMP-Internals.html
09:38:23 <bernalex> keko_: thanks
09:38:37 <keko_> (I just googled integer-gmp :)
09:40:05 <asante> hi, I'm trying to write a type class for containers for general Items a (which should be able to test for equality) but failing with getting the type class right. a piece of example code is here: http://lpaste.net/3797145586705104896 can someone hint me to a possible solution?
09:44:38 <enthropy> asante: class MyContainer a b
09:45:02 <smitzer> What GUI toolkit do you recommend for Haskell programs on Ubuntu?
09:45:13 <enthropy> also I suggest renaming the instance to   instance Eq b => MyContainer List b, since that's less confusing
09:46:08 <enthropy> well actually, class Eq b => MyContainer a b -- is better
09:46:28 <cschneid> Is there a big list of papers I should read out there? I vaguely remember seeing that, but I don't remember if it was haskell specific
09:47:58 <josephle> for what reason would you want to read a big list of papers?
09:49:34 <cschneid> josephle: well, half of it is that I don't know where to go looking.  There're sorta spread all over.  Mildly organized "here's some cool tree structures", "here's a clever way to do lists", etc.
09:49:52 <asante> enthropy: for that I need -XMultiParamTypeClasses and -XFlexibleInstances don't I? but that still gives me an error when introducing another instance of MyContainer
09:50:06 <cschneid> I've gotten to the point of haskell knowledge where I can do pragmatic programming, but I'd like to get further into the thinking & design of deeper uses.
09:50:26 <josephle> cschneid: have you read the typeclassopedia?
09:50:52 <cschneid> yeah, need to reread it at some point, but I grok everything except arrows I think (and I just haven't poked into it deep enough)
09:51:01 <bernalex> is there a polymorphic length somewhere?
09:51:16 <cschneid> well, or comonad. :)
09:52:26 <josephle> cschneid: any experience in type theory?
09:53:08 <cschneid> josephle: only what I've picked up from reading haskelly things.  So I have a loose handle on "category" and "monoid" and "semigroup". I can't say I could describe what the cattheory def of functor means, but I get the haskell's "functor" type.
09:53:33 <bergmark> bernalex: Data.List.genericLength
09:53:34 <supki> :t lengthOf folded
09:53:35 <lambdabot> Foldable f => f a -> Int
09:53:47 <cschneid> I'd like to focus on programming though, rather than diving into pure-math.  I don't mind math as the backup and proof, but would like to see stuff that took a problem, and manipulated and came up with a clever solution.
09:53:49 <enthropy> asante: yes. There are other cases where you might need to do something like http://www.haskell.org/ghc/docs/7.8.1-rc1/html/libraries/base-4.7.0.0/GHC-Exts.html#t:IsList
09:54:01 <cschneid> I do need to go through functional pearls I suppose - anything else like that?
09:54:21 <josephle> functional pearls is a good place to start
09:54:41 <bernalex> bergmark: I knew there was one in Data.List. couldn't remember the name though.
09:54:51 <bernalex> bergmark: (that was my way of saying thank you)
09:55:43 <josephle> :t lengthOf
09:55:44 <lambdabot> Getting (Endo (Endo Int)) s a -> s -> Int
09:55:55 <josephle> :t folded
09:55:56 <lambdabot> (Contravariant f1, Indexable Int p, Foldable f, Applicative f1) => p a (f1 a) -> f a -> f1 (f a)
09:57:01 <merijn> cschneid: What sort of papers are you looking for? Type theory, theory in general, haskell specific, etc.?
09:57:26 <cschneid> haskell specific I think.  Along the lines of that paper that derives monad transformers.
09:57:38 <merijn> cschneid: TypeFamilies?
09:57:51 <merijn> The paper is called "Fun with Type Functions", I think
09:58:05 <merijn> Also, the STG paper
09:59:08 <cschneid> cool
09:59:27 <merijn> cschneid: https://research.microsoft.com/apps/pubs/default.aspx?id=67083
09:59:47 <cschneid> yeah. `stg paper` was enough for google.
09:59:52 <cschneid> how'd people do without google....
10:00:38 <Pythonfant> why is functor in data and applicative functor in control?
10:01:18 <avallark> hello all :)
10:01:47 <dfeuer> Pythonfant, I think it's because someone got confused and though there was a difference between data and control.
10:02:04 <dfeuer> *thought
10:02:08 <Pythonfant> dfeuer: and now I am confused :) ok, thx
10:02:12 <merijn> Pythonfant: Stupid hysterical raisins
10:02:29 <bernalex> dfeuer: yeah it's a bit odd
10:02:40 <merijn> Pythonfant: Basically, I think that if the module system was redesigned today there would be no Control/Data prefixes
10:02:43 <bernalex> a lot is of course available in both, like <$>
10:03:09 <bjorkintosh> have you guys seen this yet? http://keera.co.uk/blog/2014/08/13/most-inspiring-green-screen-you-will-ever-see/
10:03:30 <bjorkintosh> i'm sure you have. it's haskell, afterall.
10:03:47 <Pythonfant> merijn: ok thx
10:04:01 <eacameron> how can I write a function that takes a list of functions like [(Queue q1, Queue q2) => q1 a -> q2 a -> IO ()] where q1 and q2 can be be rebound for each item in the list??
10:04:42 <dfeuer> eacameron, your question is not a question. What are you trying to do?
10:05:19 <bernalex> merijn: I have a Control/Data separation in my prelude-library. I kind of regret it.
10:05:58 <solidus-river> jle`: noooo! i came into work today to a frozen tmux with my name highlighted in #haskell like i was mentioned, if you got back to me my work computer flubbed it and i missed it :(
10:07:05 <eacameron> dfeuer: say I have Queue q => [q a]; that binds q to once instance immediately such that all the items in the list must have the same instance, but how can I make it so that all items can use different instances?
10:07:35 <merijn> eacameron: You can't have heterogeneous lists (well, you can but they most likely won't let you do what you want)
10:07:53 <merijn> eacameron: See existential-antipattern and Tekmo's "Scrap Your Typeclasses"
10:08:05 <dfeuer> Who is "Tekmo"?
10:08:14 <eacameron> merijn: I thought that would still be homogenious since it's still all one typeclass
10:08:23 <merijn> eacameron: The correct solution to your question is probably: Delete your queue typeclass and make it a datatype
10:08:37 <shachaf> But don't see too much of the latter. It doesn't really answer the relevant questions.
10:08:56 <eacameron> merijn: ahh, hmm; now that you mention it, that would work
10:08:58 <merijn> dfeuer: Gabriel Gonzalez, he wrote pipes, etc.
10:09:22 <shachaf> I think "delete your type class" is a little extreme. Type classes can have a lot of motivation to exist other than this one case.
10:09:37 <dfeuer> eacameron, it's *possible* to do it; it's just not that *useful*. Once you have that list, you can't do anything to go outside the Queue abstraction.
10:09:54 <shachaf> But of course if it's a superfluous type class then deleting it is a good idea.
10:09:56 <Iceland_jack> You can strike a nice balance between type classes and values by using edwardk's reflection library
10:10:02 <merijn> Sure, maybe there's other reasons for it, but in general a queue sounds suspiciously like it should be a datatype
10:10:35 <eacameron> dfeuer: right, but if all I ever do is use Queue's method's I don't see how it's a problem; much like OO polymorphic lists
10:10:41 <merijn> eacameron: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html <- this explains how you can replace a typeclass by a datatype, how relevant that is for your Queue depends on the rest of your code
10:11:09 <eacameron> so instead of having typeclass methods, I would just write a function to handle my Queue data type
10:11:33 <eacameron> so "downgrade" my methods to a set of plain functions...yeah that would work
10:11:56 <merijn> eacameron: Usually you'd write something like "data Queue a = Queue { qEmpty :: IO Bool; qPush :: a -> IO (); qPop :: IO (Maybe a) }" or some polymorphic type like that
10:12:07 <merijn> (Doesn't have to use IO, for example_
10:12:39 <merijn> And then "push :: Queue a -> a -> IO (); push queue x = qPush queue x", etc.
10:12:46 <solidus-river> is the history of this irc channel kept anywhere?
10:12:58 <merijn> solidus-river: ircbrowse.net
10:12:58 <eacameron> merijn: yeah, that's much simpler
10:13:46 <shachaf> solidus-river: Plain readable logs are in the topic.
10:16:42 <solidus-river> shachaf: thanks :)
10:17:03 <solidus-river> jle`: by the power of logs i have read your mesage, thanks, i'll take a look at them and start idling in haskell-game
10:17:06 <dfeuer> eacameron, I think the  real point is not "you should never do that" so much as "when you're tempted to do that, it's usually a sign you should rethink your approach".
10:17:44 <eacameron> dfeuer: good point. I'm guessing doing that (without data type) would use existential types?
10:17:54 <eacameron> I'd rather avoid those if I can
10:17:57 <eacameron> seems really heavy duty
10:18:05 <dfeuer> eacameron, *why* do you want a bunch of functions in a list, each of which maps some sort of queue to some other sort of queue?
10:18:46 <eacameron> dfeuer: chaining a bunch of async threads together with queues for passing data through
10:19:41 <eacameron> dfeuer: bascially like bash piping
10:19:55 <eacameron> dfeuer: but I need the ends to be null queues
10:20:20 <dfeuer> eacameron, if you want "basically like bash piping, but with the ends being null queues", you might want to loop at pipe or conduit.
10:20:33 <dfeuer> I can't claim to understand either of them,
10:20:43 <dfeuer> but they seem likely to be what you want.
10:21:21 <dfeuer> *look at
10:21:36 <eacameron> dfeuer: Yeah, we may "upgrade" to using real libraries...
10:21:39 * dfeuer is missing way more typos today than usual.
10:22:53 <dfeuer> eacameron, it can't hurt to try to roll your own for educational purposes, but it turns out that this stuff is kind of hard to get right, and even the grand masters can't seem to agree on just the right way to do it.
10:23:54 <eacameron> dfeuer: we did try conduit at first, but our source end of the pipe cannot be a conduit, and the stm-conduits package is missing just a few functions that would de precisely what we want...so not sure yet if we want to dive in
10:23:56 <Heffalump> is there a standard/most commonly used type class for overloading "catch"?
10:24:09 <dfeuer> Ah.
10:24:12 <jle`> solidus-river: :)
10:24:40 <jle`> solidus-river: it is worth nothing that the author and maintainer of netwire is pretty active on #haskell-game
10:26:09 <bjorkintosh> huh.
10:33:47 <solidus-river> jle`: huh, probably good to hang out there then :) Its kinda wierd how hard it is to get a wire that inhibits based on an event. I need to fire an event when something happensthen immidiately inhibit and delay for a couple seconds and listen for that event and produce a value
10:34:33 <solidus-river> oh, actually i can probably get it done with biased wire combinators
10:34:50 <jophish> Yo yo yo
10:37:21 <jle`> solidus-river: fire an event when something happens; how do you mean?
10:37:28 <jle`> fire an event when another event happens?
10:38:05 <jle`> you can just use teh Functor instance of Event for that, to transform an event stream
10:38:06 <solidus-river> jle`: this is for shooting a gun
10:38:23 <solidus-river> jle`: so you fire a shot when a key is pressed then inhibit and a wire runs that does nothing for the reload time and then waits for the event again
10:38:38 <solidus-river> but you cant form the shot from teh wire that emits a fire event because its based on who fired
10:38:44 <solidus-river> so the person who got the fire event has to emit the bullit
10:38:46 <solidus-river> *bullet
10:38:54 <solidus-river> and the wire itself doesnt have enough information to form a bullet
10:42:31 <jle`> solidus-river: the keypress goes to the wire of the player, which emits among other things an event stream of new bullets?
10:42:32 <jle`> does that work?
10:44:24 <solidus-river> jle`: i'm not clear how to turn that event stream of new bullets from an event stream into a bullet
10:44:33 <solidus-river> jle`: it looks like the only way to do that is asSoonAs
10:44:42 <solidus-river> but! if you use asSoonAs theres no way to inhibit for the reload period
10:45:04 <solidus-river> my first attempt was
10:45:30 <solidus-river> once . asSoonAs . became (key evaluator) --> after 0.5 recurse
10:45:40 <solidus-river> and then in the other wire do
10:46:07 <solidus-river> that should only emit the event once then inhibit the rest of the time and you can do
10:46:23 <solidus-river> thatWire <|> [] -- ^ no bullets fired is an empty list
10:46:32 <solidus-river> but even then it was unclear how to turn that event into a bullet once it got emitted
10:46:39 <solidus-river> and once actually never inhibits
10:46:53 <solidus-river> so that attempt resulted in always firing
10:47:33 <solidus-river> i should have pushed my code related to this to git
10:49:28 <jle`> why isn't your wire receiving Event KeyPress
10:49:36 <jle`> filterE on the ones that would fire a bullet
10:50:03 <jle`> and using...until?
10:50:07 <jle`> hm. when?
10:59:00 * hackagebot cabal-bounds 0.8.1 - A command line program for managing the bounds/versions of the dependencies in a cabal file.  http://hackage.haskell.org/package/cabal-bounds-0.8.1 (DanielTrstenjak)
11:05:15 <thinkpad20> Hey guys I was wondering, why is it that newtypes can only have one field? I get that they should only have one constructor, but why the other limitation? After all a `newtype T1 = T1 Int Int` should have the same machine representation as `newtype T2 = T2 (Int, Int)`, no?
11:05:16 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
11:05:16 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
11:06:32 <vanila> thinkpad20, I think the idea is that newtype X = X c can be implemented as a 'c'
11:07:43 <thinkpad20> yeah, but there's no reason that they couldn't do that trick with more than one object alongside each other
11:08:44 <vanila> it would break the property I said though
11:08:49 <thinkpad20> it's like in C, a `struct {int i}` is the same machine representation as `int i`, and `struct {int i; int j}` is the same as a 2-array of ints
11:09:02 <thinkpad20> how would that break that property?
11:09:31 <c_wraith> haskell data types actually contain self-descriptive information, unlike C data types
11:09:41 <thinkpad20> but newtypes don't
11:09:46 <thinkpad20> which is their whole point, no?
11:09:49 <c_wraith> the underlying type *does*
11:09:58 <c_wraith> You can't just mash two of them next to each other
11:10:04 <c_wraith> It would break the in-memory representation
11:10:13 <thinkpad20> how come?
11:10:58 <thinkpad20> just put two or more pointers next to each other in memory, and bob's your uncle
11:11:05 <c_wraith> Hmm.  Maybe if you pretended everything was a word+pointer struct, it wouldn't be.
11:11:18 <c_wraith> But it would sure complicate semantics
11:12:20 <thinkpad20> well the in-memory representation of `newtype T = T Int` is just `Int`, right? So take whatever it takes to represent an `Int` in memory, and put two of them next to each other, and you've got a `newtype T2 = T2 Int Int`
11:12:38 <thinkpad20> I'm not sure where the increased complexity would come from
11:13:28 <thinkpad20> I mean sure it would require a little work at the compiler level, but it's just calculating an offset to access the nth element of the newtype (and the offset would be trivially calculable from the type definition)
11:13:46 <c_wraith> Its interactions with laziness would be really annoying.
11:13:53 <c_wraith> I mean, you could implement something easily
11:14:04 <c_wraith> But how would you prove it was *right*?
11:14:06 <thinkpad20> But I thought that was the whole point of a newtype, that you don't get that laziness guarantee
11:14:19 <c_wraith> newtypes have very specific laziness guarantees
11:14:40 <vanila> the purpose of newtype is to let you distinguish things, so that the typechecker keeps them apart
11:15:22 <c_wraith> Ah, I see the problem.  The GC interaction.
11:16:06 <c_wraith> The garbage collector doesn't have any typing information
11:16:14 <stalintrotsky> what happens if I read a file lazily with readFile and then attempt write operations while I haven't finished using the string from readFile?
11:16:19 <c_wraith> All it has is the runtime representation.
11:16:27 <c_wraith> stalintrotsky: terrible things.
11:16:36 <stalintrotsky> Will the runtime kill my parents
11:16:52 <c_wraith> stalintrotsky: quite possibly.
11:17:10 <geekosaur> don't you get an exception because the file is "locked"?
11:17:13 <c_wraith> thinkpad20: The garbage collector has no type information. It works entirely with the runtime representations.
11:17:24 <c_wraith> geekosaur: not on linux, not using readFile
11:17:25 <stalintrotsky> would it be slow to cache the entire file as a string and just route all write operations to that string?
11:17:25 <thinkpad20> c_wraith: what problem does that cause?
11:17:37 <stalintrotsky> append operations would be slow I guess, because of ++
11:17:38 <c_wraith> geekosaur: if you used hGetContents, then yes
11:17:43 <timmy_tofu> I'm making a script for my team to create a skeleton of a snap service and install and configure everything so that they can just run this script, cd into the right directory, and `cabal run`, `cabal test`, etc.
11:17:48 <timmy_tofu> Off to the races, all setup done.
11:17:53 <timmy_tofu> I can't figure out a command or two to install all dependencies for all blocks (executable, test, etc) in the cabal file at once.
11:17:58 <timmy_tofu> cabal install --enable-tests --dependencies-only # installs depedencies and enables tests for them. Doesn't install test packages required by the new project itself, unless those happen to be the same as ones requested by the dependencies tests
11:18:12 <timmy_tofu> No real need to enable tests for the dependencies
11:18:17 <thinkpad20> c_wraith: I'm just struggling to see any issues with more than one object laid out sequentially in memory, that disappear when the amount of objects is restricted to one
11:18:19 <c_wraith> thinkpad20: the runtime representation of a newtype with multiple fields would have to include how many fields it has.  That would add runtime overhead, and the whole point of newtypes is zero runtime overhead
11:18:48 <timmy_tofu> cabal configure --enable-tests && cabal install # installs the new project, which isn't needed, and doesn't work because cabal configure exits with code 1 for all the stuff that's missing
11:18:49 <c_wraith> thinkpad20: if you have to include runtime overhead, you're in exactly the same situation as data anyway
11:19:32 <thinkpad20> hmmm I see
11:19:37 <thinkpad20> I hadn't thought of that
11:20:14 <thinkpad20> It just seems like a waste to have to do `data` when there's only one constructor
11:20:29 <thinkpad20> I guess that's just what you get
11:20:58 <thinkpad20> maybe it would be better if there were a real record system in haskell
11:21:00 <timmy_tofu> Any way to wrap this up into something that will install everything needed for the current project, nothing else, and not have a non-zero exit code along the way?
11:23:37 <timmy_tofu> Another, perhaps easier question: doctest is saying it cant find my Paths_ module, which is imported in one of my src files and is included as an other-modules item for in the doctest block and in the executable block - what am I missing?
11:27:25 <timmy_tofu> It imports without issue in the src file of the executable, I should mention
11:28:29 <Gaelan> @pl hammingDistance x y = length (zipWith (==) x y)
11:28:29 <lambdabot> hammingDistance = (length .) . zipWith (==)
11:28:52 <vanila> I don't think that's correct?
11:29:08 <vanila> no its right, sorry - I was thinking of a different metric
11:32:52 <hiptobecubic> length?
11:33:10 <hiptobecubic> is there supposed to be a filter in there, perhaps?
11:33:35 <vanila> hiptobecubic++
11:34:21 <hiptobecubic> Gaelan, ^
11:34:37 <ReinH> Gaelan: don't you need: length . filter id . zipWith (==) ?
11:34:54 <solidus-river> jle`: that takes care of emitting a bullet but not blocking another bullet from beign fired untill the reload is complete
11:35:05 <Gaelan> ReinH: Thanks!
11:35:07 <ReinH> otherwise you just have a rube goldberg `length' function ;)
11:35:22 <ReinH> Gaelan: not that literally, because it won't type check with two arguments, but you know what I mean
11:35:30 <Gaelan> ReinH++
11:35:32 <solidus-river> i've left the keys currently pressed as a set of pressed keys so i don't ahve to keep track of press and unpressed events
11:35:36 <Gaelan> hiptobecubic++
11:36:03 <jle`> solidus-river: hm.  your backend doesn't offer an unpress event?
11:36:14 <jle`> solidus-river: for bloking you could do a switch loop
11:36:31 <ReinH> :t \x y -> length . filter id $ zipWith (==) x y
11:36:32 <lambdabot> Eq b => [b] -> [b] -> Int
11:36:37 <ReinH> This is one of the few places I like using ($)
11:37:07 <ReinH> to separate "reasoning about composition" from "reasoning about application"
11:39:22 <solidus-river> switch only blocks on an inhibition of a wire though, right?
11:39:52 <solidus-river> so if i use when it will only have 1 time where it could recieve a key press inbetween the reload waits
11:47:06 <jle`> it's not quite about blocking
11:47:23 <enthropy> Couldn't match type ‚ÄòUnMaybe (Maybe (BoolN "y"))‚Äô with ‚ÄòBoolN "y"‚Äô -- how is this possible?
11:47:34 <jle`> it's about a wire who reacts differently to an event stream based on what state it is in
11:47:38 <enthropy> I have type family UnMaybe (x :: *) :: *; type instance UnMaybe (Maybe a) = a
11:48:02 <jle`> it can either be a "don't let any events go through" state/behavior, or a "make a bullet for each event" state/behavior
11:48:48 <vanila> enthropy, you can't  have strings in the type system
11:49:02 <vanila> (I think... you never know what extensions add)
11:49:06 * hackagebot rainbow 0.16.2.0 - Print text to terminal with colors and effects  http://hackage.haskell.org/package/rainbow-0.16.2.0 (OmariNorman)
11:49:07 <enthropy> -XDataKinds
11:51:11 <enthropy> and also I have   newtype BoolN (tag :: Symbol) = BoolN Bool
11:54:06 * hackagebot text-icu-translit 0.1.0.7 - ICU transliteration  http://hackage.haskell.org/package/text-icu-translit-0.1.0.7 (AntonNikishaev)
11:54:29 * shapr hops cheerfully
11:54:32 <shapr> yay haskell!
11:54:35 <johnw> hey shapr!!
11:54:41 <shapr> howdy johnw, how's code?
11:54:58 <shapr> I'm benefiting from the excellent eshell library in emacs.
11:55:34 <johnw> oh nice!
11:56:02 <shapr> johnw: I'm especially fond of eshell-toggle-cd, it almost gets rid of the need for projectile in emacs
11:57:06 <enthropy> oops nevermind UnMaybe had a different definition
11:58:40 <shapr> Fun Haskell blog post I just read: http://www.yesodweb.com/blog/2014/07/reading-files-proc-filesystem
11:59:07 * hackagebot hierarchical-clustering 0.4.4 - Fast algorithms for single, average/UPGMA and complete linkage clustering.  http://hackage.haskell.org/package/hierarchical-clustering-0.4.4 (FelipeLessa)
12:00:01 <Cale> shapr: That is interesting
12:05:04 <Cale> shapr: Clearly, file sizes ought to be Maybe values.
12:06:47 <Cale> I wonder if perhaps that optimisation shouldn't be applied in the case that the reported file size is 0.
12:08:15 <Cale> edwardk: What do you think? Perhaps strict bytestring's readFile should go via lazy bytestring's when the reported file size is 0?
12:08:30 <solidus-river> jle`: ah, that makes sense but how do you tell it to inhibit (switch) every time it makes a bullet
12:08:44 <shapr> The real problem is that /proc files aren't real files
12:09:08 * hackagebot dynamic-cabal 0.3.2 - dynamic-cabal  http://hackage.haskell.org/package/dynamic-cabal-0.3.2 (BennoFuenfstueck)
12:09:17 <Cale> Yeah, there's no filesize that could be reported by the kernel which would be meaningful
12:09:36 <Cale> because by the time you read it, the contents might be of a different length
12:10:11 <Cale> (but I think reporting 0 for that is disingenuous, it's not 0-length, it's an undetermined length)
12:10:41 <shapr> so the real fix would be an indeterminate length value?
12:10:51 <Cale> Yeah
12:11:24 <edwardk> Cale: how would that differ?
12:11:28 * edwardk tunes in
12:11:41 <Cale> edwardk: Reading files under /proc fails because they report 0 length
12:12:26 <Cale> (you get an empty strict ByteString)
12:12:31 <edwardk> ugh
12:12:38 <edwardk> i'd file a bug report about it at least
12:13:23 <Cale> Which trac do I post to?
12:14:58 <Cale> I suppose GHC's
12:17:28 <lelf> Cale: https://github.com/haskell/bytestring/issues/10
12:17:45 <Cale> ah, cool
12:19:10 * hackagebot rainbow-tests 0.16.2.0 - Tests and QuickCheck generators to accompany rainbow.  http://hackage.haskell.org/package/rainbow-tests-0.16.2.0 (OmariNorman)
12:25:10 <ian_mi> It would be nice if there were a kind of weak newtype, which shares all instances with its underlying type and disallows new instances.
12:27:08 <ian_mi> So that one could have the benefit of a newtype while still being able to use the Constraints on the underlying type
12:27:34 <enthropy> if you defined the underlying type as data X = A | B | C, you can kind of get that effect with data X' t = A | B | C
12:27:36 <timmy_tofu> cabal install --enable-tests --dependencies-only # installs depedencies and enables tests for them. Doesn't install test packages required by the new project itself, unless those happen to be the same as ones requested by the dependencies tests
12:27:40 <timmy_tofu> No real need to enable tests for the dependencies
12:27:47 <timmy_tofu> Off to the races, all setup done.
12:27:57 <timmy_tofu> I can't figure out a command or two to install all dependencies for all blocks (executable, test, etc) in the cabal file at once.
12:28:26 <enthropy> at least if you make sure the only instances defined look like   instance Num (X' t)
12:28:31 <timmy_tofu> cabal install --enable-tests --dependencies-only # installs depedencies and enables tests for them. Doesn't install test packages required by the new project itself, unless those happen to be the same as ones requested by the dependencies tests
12:31:36 <ian_mi> Not sure I understand. In my case I've defined newtype (:.:) f g a = f (g a) for the composition of functors. I need the newtype because I want to be able to work with the functor f :.: g which is partially applied
12:32:14 <ian_mi> but I need to have that C (f (g a)) :- C ((f :.: g) a) for any constraint family C
12:32:29 <ian_mi> the only way currently is to unsafeCoerce
12:34:44 <ian_mi> actually, what I really want to be able to do is to safely coerce even when used as a nominal variable
12:35:02 <ian_mi> which I think those restrictions would allow
12:35:08 <RyanGlScott> I'm having a bizarre problem with an FFI blocking call. It gets interrupted with eINTR when compiled, but works correctly on GHCi.
12:35:26 <mmachenry> How do people recommend writing SQL statements in Haskell code?
12:35:41 <timmy_tofu> Another, perhaps easier question: doctest is saying it cant find my Paths_ module, which is imported in one of my src files and is included as an other-modules item for in the doctest block and in the executable block - what am I missing?
12:36:43 <enthropy> ian_mi: you do know -XGeneralizedNewtypeDeriving?
12:36:59 <burp> mmachenry: with esqueleto package, if you use persistent
12:37:51 <enthropy> but it's inadequate here because you have to list out all the classes explicitly
12:38:32 <ian_mi> enthropy: I'm looking at the newtype wrapper proposal. Perhaps this is what I want.
12:38:50 <enthropy> deriving instance C1 (f (g a)) => C1 ((f :.: g) a) -- and repeat for C2, C3 etc. that you care about
12:39:54 <enthropy> I don't think it'll work well for C1 ~ Functor though
12:40:04 <mmachenry> burp: I don't, I use postgresql-simple
12:40:29 <enthropy> (as in I think you still need to use unsafeCoerce yourself)
12:41:23 <ian_mi> enthropy: will this work for an associated data family? I want generalize C c (f (g a)) for any instance c of some class
12:41:31 <ian_mi> sorry associated type family
12:42:20 <ian_mi> specifically, my Category c class defines a constraint family Object c :: k -> Constraint
12:43:03 <ian_mi> every functor has that Object c1 a :- Object c2 (f a)
12:43:28 <ian_mi> now for two functors I need that Object c1 a :- Object c3 ((f :.: g) a)
12:44:14 <burp> mmachenry: ok, I'm not aware of any SQL EDSL for that
12:44:40 <mmachenry> That's too bad. Hm‚Ä¶
12:47:16 <timmy_tofu> mmachenry: What don't you like about postgresql-simple?
12:48:12 <bergmark> mmachenry: tomejaguar_away is working on a cool sql edsl
12:49:19 <bergmark> there's also groundhog which is similar to persistent. I haven't looked into much because it doesn't support joins
12:50:59 <timmy_tofu> Also Opaleye is coming https://gist.github.com/begriffs/3b35c7b646a94695929d
12:51:19 <timmy_tofu> The next Haskell meetup in NYC will have a talk on Opaleye which I'm looking forward to
12:51:59 <Clint> timmy_tofu: when's that?
12:52:19 <Clint> ah
12:52:27 <timmy_tofu> http://www.meetup.com/NY-Haskell/ 27th
12:52:34 <Clint> i'll be out of town
12:54:46 <timmy_tofu> doctest is saying it cant find my Paths_ module, which is imported in one of my src files and is included as an other-modules item in the executable block, and I added it to the doctest block now just in case but no help - what am I missing?
12:55:26 <smitzer> How big is the haskell runtime? it must be loaded into RAM right?
12:55:34 <smitzer> http://keera.co.uk/blog/2014/08/13/most-inspiring-green-screen-you-will-ever-see/
12:55:48 <mmachenry> timmy_tofu: postgresql-simple was the first thing I tried and it worked just fine
12:55:50 <bennofs> timmy_tofu: try adding -idist/autogen to the doctest cmdline flags
12:56:24 <smitzer> ^^I don't get if it can be done on any phone or if you need ghc on the actual phone...do you need to root the phone? then it is not interestin for me yet.
12:57:50 <timmy_tofu> bennofs: How can I do that when running through cabal? cabal test -- -idist/autogen tries to pass it to build
12:58:13 <bennofs> timmy_tofu: how does your source code that runs the doctest look?
13:00:49 <vanila> > [0.0 .. 10.0]
13:00:51 <lambdabot>  [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
13:01:22 <enthropy> bennofs, timmy_tofu it should be -idist/build/autogen
13:02:52 <timmy_tofu> bennofs: I think you might have found the forest that I overlooked for the trees... trying to arrange things now
13:02:54 <enthropy> if you have   main = doctest ["Module1.hs"], just change it to  main = doctest ["-idist/build/autogen","Module1.hs"]
13:04:16 * hackagebot between 0.9.0.0 - Function combinator "between" and derived combinators  http://hackage.haskell.org/package/between-0.9.0.0 (PeterTrsko)
13:05:13 <timmy_tofu> bennofs: enthropy: Yes, thank you both, I had forgotten to include that in the doctest launcher... oy
13:10:10 <trap_exit> is there a good tutorial on "write yourself a simply typed imperative language" in haskell ?
13:10:41 <trap_exit> so I'd like to implement something like, say ML in haskell; the type system needs not be as complicated as Haskell's
13:11:23 <vanila> trap_exit, it doesn't exist yet but I was thinking of writing this
13:11:36 <n-dolio> Is ML's system simpler than Haskell's?
13:11:38 <trap_exit> vanila: I would really like reading it
13:11:39 <vanila> i started some work on it
13:11:55 <vanila> ok that's nice to know, ill work more on it :)
13:12:04 <trap_exit> vanila: I've read a bit about simply typed lambda calculus, I've read jonathan tang's write yourself a scheme in 48 hours
13:12:17 <trap_exit> vanila: and I was studying parsing imperative langauges in parsec yesterday
13:12:26 <vanila> great :)
13:12:38 <trap_exit> vanila: but I fell like it'd be really cool to parse in parsec (or attoparsec), reason about types (fa you familiar with the W algorithm)? and interpret it
13:12:59 <vanila> yeah that would be!
13:13:08 <trap_exit> vanila: so 'executing a single step' is just a state monad right?
13:13:13 <trap_exit> where the state = the heap + stack frames of the imperaive language
13:13:57 <vanila> there's another way to evaluate it using higher order functions
13:14:11 <vanila> that lets you avoid state, but certainly what you said would work too
13:14:39 <trap_exit> vanila: what type inference algorithm would you use / are you using?
13:15:21 <vanila> the simplest thing after type checking fully annotated terms would be running unification over a syntax tree
13:15:59 <trap_exit> vanila: please do this, you'd become my next-favorite persin in #haskell, behind luite, jle`, Cale, annelies, and a few others
13:16:23 <vanila> ok once I have a draft can I ask you to skim it a bit then? :)
13:17:58 <trap_exit> vanila: yes, wonderful!
13:26:32 <eacameron> is it possible to get the name of the current function for printing it in a logging system?
13:27:43 <athan> > show (+)
13:27:45 <lambdabot>  "<Integer -> Integer -> Integer>"
13:27:54 <timmy_tofu> Is there a way to install --dependencies-only and include dependencies of the tests just for the project I'm in, rather than having cabal install --enable-tests --dependencies-only enable tests on the dependencies themselves?
13:29:15 <athan> > show $ (+) :: Float -> Float -> Float
13:29:16 <lambdabot>  Couldn't match type ‚Äò[GHC.Types.Char]‚Äô
13:29:16 <lambdabot>                with ‚ÄòGHC.Types.Float -> GHC.Types.Float -> GHC.Types.Float‚Äô
13:29:16 <lambdabot>  Expected type: GHC.Types.Float
13:29:16 <lambdabot>                 -> GHC.Types.Float -> GHC.Types.Float
13:29:16 <lambdabot>    Actual type: GHC.Base.String
13:29:27 <geekosaur> eacameron, I don't think it's reliably available without using ghc-as-a-library during the compile (which may mean TH, or something even more involved)
13:29:28 <corgifex> :: isn't an operator
13:29:37 <smitzer> http://keera.co.uk/blog/2014/08/13/most-inspiring-green-screen-you-will-ever-see/
13:29:40 <smitzer> ^^I don't get if it can be done on any phone or if you need ghc on the actual phone...do you need to root the phone? then it is not interestin for me yet.
13:29:40 <athan> > show $ (+) :: Num a => a -> a -> a
13:29:41 <lambdabot>  Couldn't match type ‚Äò[GHC.Types.Char]‚Äô with ‚Äòa1 -> a1 -> a1‚Äô
13:29:41 <lambdabot>  Expected type: a1 -> a1 -> a1
13:29:41 <lambdabot>    Actual type: GHC.Base.String
13:30:31 <c_wraith> athan: :: isn't an operator.  $ doesn't have lower priority than it
13:30:43 <athan> Oh! sorry
13:31:02 <eacameron> geekosaur: ok...not sure its worth it.. ;)
13:34:05 <bernalex> why is chunksOf not in base?
13:34:07 <bernalex> edwardk: ?
13:35:37 <spott> anyone have any experience with stackage?
13:35:58 <geekosaur> I think there was a vague idea of figuring out which functions from Data.List.Split were most useful and moving them to Data.List, but the execution fell apart somewhere?
13:36:02 <wcaleb> newbie question: i'm working on a codebase that has a function that takes a (String -> String) function as one of its parameters
13:36:19 <bernalex> geekosaur: unless edwardk or someone chimes in I think I wanna propose to add it. it's very useful.
13:36:39 <geekosaur> go for it, imo
13:36:42 <edwardk> its in the platform, its messy, not quite fundamental, etc.
13:36:43 <wcaleb> i want the function to accept either a (String -> String) OR a (String -> String -> String) function; is that possible?
13:37:01 <edwardk> pick and choose from that list
13:37:05 <bernalex> edwardk: I think it's great to have a polymorphic chunksOf TBH
13:37:08 <spott> wcaleb: not that I'm aware of
13:37:14 <geekosaur> wcaleb, while I think it's possible, it's not easy and it's rather restrictive
13:37:16 <edwardk> polymorphic how?
13:37:29 <bernalex> edwardk: Int -> [a] -> [[a]] is quite polymorphic
13:37:31 <spott> how do you plan on writiing the function so that you can USE both functions?
13:37:38 <geekosaur> (like, as soon as you want to partially apply a String -> String -> String using that interface, you have a Problem)
13:37:44 <edwardk> was worried you wanted it to vary based on the choice of functor =P
13:37:54 <bernalex> edwardk: ohhhhhh
13:38:00 <bernalex> edwardk: you should never have said anything ;-)
13:38:11 <geekosaur> spott: you might look at how Text.Printf works
13:38:37 <geekosaur> it *can* be done. it's pretty ugly, and as I said it's kinda restrictive compared to what you can normally do in Haskell.
13:38:39 <SirLalala> Hi guys I'm using the sdl2 bindings and I'm not sure how can I create a Ptr Rect as expected by the method renderCopy (https://hackage.haskell.org/package/sdl2-1.1.0/docs/Graphics-UI-SDL-Video.html)
13:38:51 <edwardk> bernalex: meh, ultimately the problem is it is messy and already in split, which is in the platform
13:39:07 <edwardk> so the main thing you get is another name taken by base, and switch-over pain for marginal gain
13:39:09 <wcaleb> spott: hmmm, good point ‚Ä¶ i'm still stuck in pythonic thinking where some arguments optional, i guess
13:39:14 <bernalex> I've never used the platform heh
13:39:19 <Iceland_jack> wcaleb: You probably don't want that tbh
13:39:24 <edwardk> bernalex: that may explain why you want everything in base =P
13:39:50 <bernalex> edwardk: :-P I'm fine with having it in the split combinators library I guess
13:40:41 <spott> geekosaur: how does that work?
13:40:52 <geekosaur> tricky use of typeclasses
13:41:20 <c_wraith> It also has a lot of runtime crashes, rather than compile-time errors
13:41:25 <geekosaur> you'd have to alter it a bit for this particular usage, but there's no conceptual reason you couldn't do it. you just have to watch out for the possibilities you lose by doing it
13:41:28 <SirLalala> as far as I can understand I need exactly the opposite of a "Storable"
13:41:34 <geekosaur> which is why we, in general, don't do things that way
13:41:54 <c_wraith> SirLalala: Storable provides both Haskell -> C and C -> Haskell..  What else do you need?
13:41:55 <Iceland_jack> Coming from python, if you wanted to get the maximum from n numbers you'd want a Haskell function like Int -> Int, Int -> Int -> Int, Int -> Int -> Int -> Int... then you realize you just want a list of numbers
13:41:56 <Iceland_jack> @ty maximum
13:41:57 <lambdabot> Ord a => [a] -> a
13:42:34 <geekosaur> SirLalala, actually I think that is a Storable. also, looking at the SDL interface, it may be a bad (== too "raw") reflection of the C API
13:42:36 <c_wraith> SirLalala: oh, I see.  Look at functions like alloca and malloc
13:42:53 <geekosaur> but yes, alloca is probably what you want here
13:43:05 <spott> does anyone know if it is possible to use stackage for global/user package installs, and hackage (or stackage "inclusive") for sandboxed installs?
13:43:07 <SirLalala> geekosaur: yeah it's 1-1 match to the c api
13:43:16 <joe9> need some help, please? I am trying to write a program to decipher the "caught" column output of "ps", as described at: http://jonebird.com/2010/02/09/deciphering-caught-signals/ . The attached python program there does not work with the latest python. I am trying to do this in haskell. I figure I can do this with System.Posix.Signals and using Data.Bits.testBit to figure out which signal bit is set. Instead of having to manually list
13:43:17 <joe9> each signal, is there an enum of all signals?
13:43:21 <c_wraith> SirLalala: http://hackage.haskell.org/package/base-4.7.0.1/docs/Foreign-Marshal-Alloc.html
13:43:43 <SirLalala> c_wraith: thanks a lot!
13:43:47 <geekosaur> yeh, there should really be a wrapper. I am pretty sure, looking at the SDL2 API, that the pointer-ness is an artifact of working in C and we should not be reflecting it in the Haskell API
13:44:09 <geekosaur> but maybe the Haskell SDL2 bindings maintainer has plans to implement a higher level interface at some point
13:44:27 <SirLalala> c_wraith: malloc should do the trick
13:44:28 <geekosaur> in general, exposing a Ptr like that is a bit of a code smell
13:44:55 <c_wraith> SirLalala: alloca also does the trick, and handles freeing it for you.  ie, beware of leaking memory with malloc. :)
13:45:11 <geekosaur> right, that's why I suggested alloca earlier
13:45:45 <geekosaur> (note that alloca does not have the same issues in Haskell that it does in C)
13:46:21 <SirLalala> geekosaur: sorry thanks as well! Probably missed it while looking the marshal.alloc docs :(
13:47:58 <geekosaur> joe9: there's no portable way to get such a list, sadly
13:49:56 <geekosaur> you can try to trawl the system include files (beware of #include!) or see if there's something like sys_siglist available and FFI bind to it
13:51:07 <CaptainK> anybody using AcidState?
13:52:51 <Clint> i sometimes use acid-state
13:55:39 <clrnd> I sometimes do acid
13:56:28 <orion> I designed a large C++ application while on acid.
13:56:49 <joe9> geekosaur: ok, thanks.
13:59:09 <mmachenry> I have written lots of code and I have costumed many things with a ph lower than 7.
13:59:24 <mmachenry> *consumed
14:00:16 <athan> It's like brain octane-booster
14:01:02 <CaptainK> lol, ok so Clint uses it, the rest are on acid :P
14:03:42 <CaptainK> want to know if I can bypass the HDBC layer
14:04:01 <CaptainK> moving now to a real world application for haskell
14:04:40 <CaptainK> maybe acid might enlighten further
14:04:59 <Cale> CaptainK: I don't think acid-state requires hdbc
14:05:59 <athan> CaptainK comes back with his own type system and SAT solver
14:06:33 <Cale> It just serialises things using SafeCopy, which in turn uses the binary Get and Put from cereal
14:09:06 <CaptainK> don't want to have to use HDBC
14:09:59 <Cale> CaptainK: I think acid-state is pretty close to how you'd ideally like to do things, but it might be regarded as a little bit experimental still, if you're writing something really critical.
14:10:12 <Cale> You just use Haskell data as your database, pretty much
14:11:18 <Cale> The other main downside to it vs. a more traditional database is that you'll need enough memory to keep your entire DB in memory
14:11:19 <c_wraith> acid-state has issues under heavy concurrent load that make its performance break down badly.  I wouldn't recommend it for anything you expect to ever get heavy use.
14:11:49 <dmj> I use acid-state heavily and it works fine for me
14:12:03 <c_wraith> dmj: on the other hand, it didn't work for hackage 2 at all
14:12:37 <dmj> hackage1/2 didn't use the remote module, it embeds the process inside the website I believe
14:12:51 <dmj> the lesser known acid-state remote is great
14:13:34 <wcaleb> i've been hacking on Gitit, the Pandoc wiki, and am stuck here: https://github.com/wcaleb/gitit/commit/4cee2e4bc5c2a657801c374dd72f77507866d872
14:13:36 <dmj> the remote module gives you your own process to broadcast a state from
14:13:37 <napping> CaptainK: You just want to avoid HDBC? Have you looked at things like persistent or postgresql-simple?
14:13:49 <athan> Yesod's persistent is a pretty sweet activerecord lookalike
14:14:15 <wcaleb> as you can see, i've modified a function that returned Bool so that it now returns a GititServerPart (gitit specific constructor) Bool
14:14:17 <dmj> c_wraith: I can store 400k records in an IntMap no problem
14:14:28 * hackagebot cassandra-cql 0.4.0.1 - Haskell client for Cassandra's CQL protocol  http://hackage.haskell.org/package/cassandra-cql-0.4.0.1 (StephenBlackheath)
14:14:34 <napping> Are you trying to avoid things implemented over HDBC, or using the HDBC interface directly? There are some of each
14:14:35 <wcaleb> this causes problems elsewhere in the program because calls to that function needed Bool
14:15:00 <CaptainK> trying to avoid HDBC all together
14:15:07 <wcaleb> i get the feeling that there's some easy fix to this that I'm not seeing as a newbie---a way to "unwrap" that Bool?
14:15:09 <c_wraith> dmj: what's the update rate, and how much concurrently?  That's far more important than the size of the structure.
14:15:42 <ndrr> Hello - trivial question, but does anyone know why types are declared with a double colon (::) rather than a single colon (:)?
14:15:42 <napping> CaptainK: I haven't used any database interface for serious work, but postgresql-simple seems pretty nice, and I think it just goes through a libpq binding
14:15:46 <dmj> c_wraith: right now I have about 20 threads in a pool that poll a remote state every 5 seconds
14:15:56 <dmj> c_wraith: queries are non-blocking
14:16:07 <timmy_tofu> When I do cabal configure -whatever in a sandbox, where are those configurations put? cabal.sandbox.config doesn't have options like ~/.cabal/config does, and every time I run cabal test I get "Re-configuring with test suites enabled"
14:16:09 <Cale> wcaleb: You'd need to run the GititServerPart action
14:16:18 <CaptainK> dmj: thats like what I have to do
14:16:22 <c_wraith> dmj: and...  how many updates per second?  That's the statistic that makes acid-state fail
14:16:40 <wcaleb> Cale: can you explain what you mean? i'm pretty green ...
14:17:20 <Cale> wcaleb: Which you can only do from another GititServerPart action, or apparently by using runServerPartT and runReaderT...
14:17:33 <koala_man> ndrr: so is "Nothing : []" a list or a type declaration?
14:17:45 <Cale> wcaleb: If the other places where the Bool is needed are in GititServerPart actions, it's easy
14:17:48 <mmachenry> If I want to run ghci from within the current sandbox but import a module that's just not in my normal code branch
14:17:56 <mmachenry> cabal repl imports all of my code.
14:18:04 <mmachenry> But not my new Test.hs module
14:18:21 <Cale> You just write something like   do b <- isPageFile fp; {- ... use b :: Bool here ... -}
14:18:39 <mmachenry> I want to have the same behavior as "ghci Test.hs" but have access to the installed modules from this .cabal-sand-box that I'm in
14:19:04 <Cale> wcaleb: But if they're not in such actions, it's a bit more complicated, because you need a bunch of additional data to be able to execute a GititServerPart action.
14:19:06 <dmj> c_wraith: with the remote module all querys / updates are RPC calls so the values get serialized and put into a TQueue and are sent over tcp in order
14:19:09 <wcaleb> Cale: most of them are in functions of type Handler, which is of type GititServerPart Response
14:19:34 <Cale> wcaleb: cool, then in those cases, it's easy, you can just do what I suggested there
14:19:51 <dmj> c_wraith: what are your latency requirements?
14:19:54 <wcaleb> Cale: interesting. thanks for the tip
14:20:03 <ndrr> that sprang to mind koala_man, was just wondering if it was a case that list concat was decided before type declarations or if there was another justification
14:20:11 <dmj> CaptainK: then give Data.Acid.Remote a try
14:20:34 <c_wraith> dmj: It's not about latency.  It's about acid-state's storage format becoming less and less efficient as you have more and more update history.
14:21:04 <Cale> wcaleb: In general, if you're writing an action of type M t, where M is some monad, and you're using do-notation, then v <- x inside the do-block means "execute the M-action x, and call its result v", so if x :: M a, then v :: a
14:21:38 <Cale> wcaleb: The do-block as a whole will itself be an M-action -- do notation serves to glue actions of some monad together into more complicated ones
14:21:57 <dmj> c_wraith: maybe if you haven't created a checkpoint in a long time, starting up might be slow since you'd have to read the logs, but note that query's don't write to the log
14:22:19 <c_wraith> dmj: that's why I keep saying "update" and "write"
14:22:34 <btcNeverSleeps> when I fmap s
14:22:36 <btcNeverSleeps> oops
14:22:46 <wcaleb> Cale: thanks, i'm still wrapping my head around monads ...
14:23:16 <btcNeverSleeps> when I fmap a function which returns a Maybe, I end up with something like: Just (Just ...)
14:24:17 <btcNeverSleeps> what if I want "Just ..." instead of "Just (Just ...)"  (if my question makes any sense)
14:24:18 <Cale> btcNeverSleeps: Yeah, if bar :: a -> Maybe b, then  fmap bar :: (Functor f) => f a -> f (Maybe b)
14:24:26 <ParahSailin> :t join
14:24:26 <lambdabot> Monad m => m (m a) -> m a
14:24:27 <Cale> btcNeverSleeps: You're probably looking for >>=
14:24:29 * hackagebot text-icu 0.7.0.0 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.7.0.0 (BryanOSullivan)
14:24:32 <ajcoppa> :t (>>=)
14:24:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
14:24:45 <Cale> x >>= f = join (fmap f x)
14:24:53 <ajcoppa> note that bar :: a -> Maybe b fits neatly as the second argument to >>=
14:25:06 <ajcoppa> and will give you back a Maybe b as the overall result
14:25:35 <btcNeverSleeps> is this something common to do in Haskell?
14:25:42 <Cale> btcNeverSleeps: Using Maybe as a monad?
14:25:46 <CaptainK> dmj: thx, trying to install remote now
14:25:46 <Cale> It's not too uncommon
14:26:12 <Cale> btcNeverSleeps: You can also use do-notation
14:26:43 <Cale> If you write a do-block that has v <- x where x :: Maybe a, then v :: a, and the do-block as a whole will have type Maybe t for some t
14:27:19 <Cale> (if any of the Maybes is Nothing, then the whole do-block is Nothing)
14:27:37 <Cale> For example...
14:27:37 <btcNeverSleeps> yup, that is precisely what I want (or at least what I'm trying to do)
14:28:01 <Cale> @let dict = [(0,1),(1,3),(2,4),(3,5)]
14:28:03 <lambdabot>  Defined.
14:28:18 <joe9> http://codepad.org/bszVnafe any comments on this code, please?
14:28:19 <Cale> :t lookup
14:28:20 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
14:28:39 <Cale> > do x <- lookup 0 dict; y <- lookup x dict; return (x,y)
14:28:40 <lambdabot>  Just (1,3)
14:28:49 <Cale> > do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; return (x,y,z)
14:28:50 <lambdabot>  Just (1,3,5)
14:29:00 <Cale> > do x <- lookup 0 dict; y <- lookup x dict; z <- lookup y dict; w <- lookup z dict; return (x,y,z,w)
14:29:01 <lambdabot>  Nothing
14:29:13 <btcNeverSleeps> oh that is a sweet and short example!
14:29:46 <btcNeverSleeps> so in such a case is the do-notation preferred?
14:29:52 <Cale> It's not bad
14:29:58 <Cale> There are a lot of options
14:30:15 <Cale> But yeah, for this specific example, it's hard to do a whole lot better
14:30:31 <Iceland_jack>     [ (x, y, z, w) | x <- lookup 0 dict,
14:30:31 <Iceland_jack>                      y <- lookup x dict,
14:30:31 <Iceland_jack>                      z <- lookup y dict,
14:30:31 <Iceland_jack>                      w <- lookup z dict ]
14:30:33 <mmachenry> I am having a problem with lazy byte strings, lazy evaluation, and sending partial messages to a client over TCP. http://lpaste.net/109384
14:30:44 <Iceland_jack> omitting the return
14:30:46 <Cale> Yeah, you could use a monad comprehension
14:31:01 <Cale> but that'll require turning on the extension for that
14:31:01 <mmachenry> I am not sure why given that I'm encoding my messages with that function, that occasionally my server will send half the message and then the second half later.
14:31:17 <mmachenry> Do I need to use a $! for toStrict
14:31:18 <mmachenry> ?
14:31:35 <bb010g> >(,) <$> lookup x <*> lookup y $ dict
14:31:49 <Cale> mmachenry: When your server sends things has nothing at all to do with evaluation
14:32:00 <bb010g> > (,) <$> lookup x <*> lookup y $ dict
14:32:02 <lambdabot>  (Nothing,Nothing)
14:32:08 <athan> After reading Scrap More Boilerplate, they keep mentioning "sums-of-products"... anyone know what this means, here?
14:32:10 <Cale> mmachenry: All that evaluation does is to reduce expressions in memory to values so that pattern matching can occur
14:32:12 <haasn> bb010g: ‚Äòx‚Äô and ‚Äòy‚Äô are not in scope yet
14:32:45 <Cale> mmachenry: If your server is sending or not sending something in a timely fashion, that's a matter of execution (of IO actions)
14:32:49 <dmj> c_wraith: there's only one logging thread that waits on new entries to arrive, writes them to disk first, then executes the action against the state. So under very heavy load the serialization / persistence of rapid events could be a bottleneck for the fileWriter.
14:32:53 <bb010g> Oh, derp. Chained lookup
14:32:59 <bb010g> > (,) <$> lookup 0 <*> lookup 1 $ dict
14:33:00 <lambdabot>  (Just 1,Just 3)
14:33:02 <Iceland_jack> athan: Sums of products is the form of algebraic data types
14:33:10 <bb010g> > fold $ (,) <$> lookup 0 <*> lookup 1 $ dict
14:33:12 <lambdabot>  No instance for (GHC.Show.Show t10)
14:33:12 <lambdabot>    arising from a use of ‚ÄòM573607108118821779321453.show_M5736071081188217793...
14:33:12 <lambdabot>  The type variable ‚Äòt10‚Äô is ambiguous
14:33:12 <lambdabot>  Note: there are several potential instances:
14:33:12 <lambdabot>    instance [safe] GHC.Show.Show
14:33:19 <Cale> mmachenry: So, nothing about the code you gave can be part of the issue
14:33:23 <athan> Iceland_jack: Oh, okay. Thanks!
14:33:27 <bb010g> :t fold
14:33:28 <lambdabot> (Monoid m, Foldable t) => t m -> m
14:33:49 <mmachenry> Cale, not sure what you mean, but's one call to sendMany but it's getting send in two segments.
14:33:50 <bb010g> :t traverse
14:33:51 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:33:52 <Cale> mmachenry: If I had to guess, it probably has something to do with the buffering mode on the Handle to the socket
14:34:02 <Iceland_jack> athan: something like
14:34:02 <Iceland_jack>     data Bool = True | False
14:34:02 <Iceland_jack> is really
14:34:02 <Iceland_jack>     Bool = True + False
14:34:05 <Iceland_jack> so a sum of two things
14:34:14 <Cale> mmachenry: (but I can't see the rest of your code)
14:34:48 <mmachenry> Cale, there's actually no buffering mode since I'm using Network.Socket.ByteString
14:35:04 <athan> Iceland_jack: I remember now :) It's still just a bit strange for me to take on that perspective in my reasoning
14:35:11 <dmj> c_wraith: but its still faster than an RDBMS
14:35:29 <bb010g> > traverse (flip lookup dict) $ [0,1]
14:35:30 <mmachenry> Cale I can paste that module.
14:35:30 <lambdabot>  Just [1,3]
14:35:55 <bb010g> \o/ I finally came up with a use for traverse! :)
14:36:30 <nitrix> Hi, I have trouble using https://john-millikin.com/software/haskell-ncurses/reference/haskell-ncurses/latest/UI.NCurses/ given a resize event, it seems like its not triggering anything in my program... this is the function in question http://whiteboard.debian.net/db45d0.wb any idea?
14:36:53 <mmachenry> Cale,this is the module I use to send the bytestrings I get from that f function
14:36:54 <mmachenry> http://lpaste.net/109385
14:36:58 <nitrix> renderStage doesnt get called, as far as I'm able to tell.
14:37:05 <athan> bb010g: !?!??!
14:37:18 <bb010g> athan: ??!??
14:37:24 <Cale> mmachenry: Well, one thing you should try is just to print the string and make sure it is what you expect it to do
14:37:25 <wcaleb> Cale: sorry to bother again, but how would the method you recommended work with something like this: https://github.com/jgm/gitit/blob/master/Network/Gitit/Handlers.hs#L117
14:37:26 <Cale> be*
14:37:49 <wcaleb> Cale: where the isPageFile function is inside a function fed to filter?
14:38:03 <mmachenry> Cale, I did that. It looks normal.
14:38:10 <Cale> wcaleb: Just before the line with the 'let' on it, put  isPF <- isPageFile f, and then replace the call to isPageFile with isPF
14:38:38 <bb010g> athan: Could you be a tinge more verbose in your exclamatory question?
14:38:51 <wcaleb> Cale: f isn't in scope yet, though, because it's used to filter files
14:38:51 <Cale> mmachenry: Okay, I'll have a look
14:39:24 <nezt> Hi haskellers
14:39:30 <bb010g> Hi
14:39:32 <mmachenry> Hi nezt
14:39:33 <frerich_> Does anybody have some suggestions on how to make the ‚ÄòfindMatchingBracket‚Äô function in http://lpaste.net/109386 less convoluted? It serves as a common helper for two other functions which, given a Vector and some position in the vector, try to find a matching closing/opening brace while considering that braces can be nested.
14:40:03 <athan> bb010g: I'm just joking haha. Aren't traversables something like a fold that retains structure... or something?
14:40:15 <bb010g> :t traverse
14:40:15 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:40:22 <bb010g> Say you have a dict:
14:40:25 <bb010g> > dict
14:40:26 <lambdabot>  [(0,1),(1,3),(2,4),(3,5)]
14:40:26 <bb010g> :t dict
14:40:27 <lambdabot> (Num t1, Num t) => [(t, t1)]
14:40:40 <bb010g> And you want to lookup something:
14:40:42 <bb010g> :t lookup
14:40:43 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
14:40:57 <athan> bb010g: ahhhh, okay. So it's like a map/sequence?
14:40:58 <bb010g> lookup 0 dict
14:41:02 <bb010g> > lookup 0 dict
14:41:04 <lambdabot>  Just 1
14:41:15 <bb010g> But when you fmap to lookup a lot of stuff:
14:41:34 <bb010g> > fmap (flip lookup dict) [0,1,3]
14:41:35 <lambdabot>  [Just 1,Just 3,Just 5]
14:41:43 <athan> ahhhhh
14:42:01 <bb010g> It's a list of Justs. That's nice if you want isolated failure:
14:42:04 <bb010g> > fmap (flip lookup dict) [0,1,3,42]
14:42:06 <lambdabot>  [Just 1,Just 3,Just 5,Nothing]
14:42:12 <bb010g> But what if you don't?
14:42:16 <Cale> mmachenry: Okay, that's weird
14:42:17 <bb010g> :t traverse
14:42:18 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:42:23 <athan> that's supreme
14:42:32 <Cale> mmachenry: How are you checking that the entire string has been sent? Maybe it's a client side issue?
14:42:45 <athan> thanks bb010g :)
14:43:01 <bb010g> Traverse kinda flips & sequences the functor throughout the Traversable, keeping the answers where they were.
14:43:07 <bb010g> > traverse (flip lookup dict) [0,1,3]
14:43:09 <lambdabot>  Just [1,3,5]
14:43:10 <bb010g> > traverse (flip lookup dict) [0,1,42]
14:43:11 <lambdabot>  Nothing
14:43:18 <athan> ahhh nice
14:43:19 <athan> hmm
14:43:22 <mmachenry> Cale maybe it is a client-side issue.
14:43:35 <Pythonfant> is there a name for applicative functors without the pure function? are those semiapplicative functors?
14:43:40 <bb010g> It's like a fold that keeps structure.
14:43:49 <bb010g> Pythonfant: Apply
14:43:57 <Pythonfant> bb010g: k
14:43:57 <bb010g> @hackage semigroupoids
14:43:58 <lambdabot> http://hackage.haskell.org/package/semigroupoids
14:44:03 <bb010g> Pythonfant: ^
14:44:14 <timmy_tofu> When I do cabal configure -whatever in a sandbox, where are those configurations put? cabal.sandbox.config doesn't have options like ~/.cabal/config does, and every time I run cabal test I get "Re-configuring with test suites enabled"
14:44:15 <Pythonfant> ah I knew I saw those somewhere, thx
14:44:35 <bb010g> Pythonfant: And if you want to play around with them, I'm working on a Prelude with them. https://github.com/bb010g/yapp
14:44:45 <athan> I thought semigroupoids were like categories + inversion...?
14:44:56 <athan> meh
14:45:03 <Pythonfant> bb010g: great I'll take a look
14:45:08 <prophile> athan: groupoids are categories + inversion
14:45:12 <bb010g> athan: Semigroupoids are categories sans id (like how semigroups are monoids sans mempty).
14:45:13 <prophile> semigroupoids are categories - identity
14:45:21 <athan> ahh okay
14:45:31 <athan> awesome, thanks :)
14:46:07 <bb010g> Pythonfant: Warning, YAPP's still _very_ rough, so don't depend too much on it for now. I'm going to be taking stuff in and out actively.
14:46:14 <prophile> (,) is a semigroupoid interestingly enough
14:46:23 <Pythonfant> bb010g: ok thx for the warning
14:47:59 <mausch> hi, does anyone know what's the rationale behind deriving Ord in this sort of sum types? data AType = A | B deriving (Eq, Ord);main = print $ A < B
14:48:12 <mausch> seems awfully arbitrary to me...
14:48:24 <glguy> It allows you to do things like filter for duplicates efficiently
14:48:28 <glguy> or use as a Map key
14:48:51 <geekosaur> or Enum?
14:48:52 <bb010g> mausch: Comparison depends on figuring out the ordering of something.
14:49:05 <geekosaur> well, except that wasn't derived
14:49:17 <mausch> thanks but what does A < B really *mean*?
14:49:29 <glguy> Ord just specifies an arbitrary total order on the elements
14:49:34 <glguy> that's all Ord means
14:49:35 <bb010g> :t (<)
14:49:35 <lambdabot> Ord a => a -> a -> Bool
14:49:49 <athan> in this instance, that A was written before B in the data declaration :p
14:50:19 <mausch> exactly, implementing Ord depending on the order of the declaration just doesn't make any sense to me
14:50:42 <athan> mausch: It can be helpful and convenient
14:50:47 <bb010g> mausch: How would you do it?
14:50:54 <athan> syntactic sugar in this case
14:50:59 <athan> (to me at least)
14:50:59 <glguy> You'd prefer it was lexicographically ordered by constructor name?
14:51:07 <Bor0> within category theory (according to wikipedia), why is associativity defined as if f :: a->b, g :: b->c, h :: c->d then ..., but ordinary associativity states "for all"?
14:51:14 <mausch> changing the definition from A | B to B | A should be a safe operation but it's not
14:51:42 <geekosaur> mausch, define safe
14:51:43 <mausch> I wouldn't allow deriving Ord
14:51:44 <glguy> You'd still get a total order out of Ord
14:51:47 <athan> Bor0: Category theory isn't founded on set theory
14:51:51 <cmccann> mausch: if there's no semantically meaningful ordering then you shouldn't have code that relies on the choice of ordering
14:51:57 <glguy> so as long as you didn't assume more about Ord than that nothing would break
14:52:13 <cmccann> if there is a semantically meaningful ordering you should be using that, even if means writing an instance manually
14:52:31 <mausch> glguy: doesn't that go against type safety?
14:52:47 <glguy> No, type safety is different
14:52:49 <spion> so whats the difference between a monoid and a category?
14:52:50 <mausch> absolutely, I'd write it manually where it makes sense
14:52:56 <cmccann> anyway, at least it's not outright broken like the Ord instance for floats.
14:52:57 <cmccann> sigh.
14:53:34 <glguy> "Well-typed programs don't go wrong", it has to do with type-preservation and progress
14:53:37 <Guest41527> Not really a question, but why typeclass is needed in general? If we already have a taxonomy using Type, then why need another taxanomy over taxanomy. Does it mean the initial typing is inefficient?
14:55:18 <timmy_tofu> When I do cabal configure -whatever in a sandbox, where are those configurations put? cabal.sandbox.config doesn't have options like ~/.cabal/config does, and every time I run cabal test I get "Re-configuring with test suites enabled"
14:55:23 <Bor0> athan, can it be said that function composition (.) in general makes a category? if we consider the objects to be all possible functions
14:55:26 <mausch> sorry, yes, it's not about type safety
14:55:53 <mausch> it's just that since there are many possible implementations, I don't see why the compiler chooses one arbitrarily
14:55:54 <athan> Guest41527: It's not quite a taxonomy over taxonomy, it's a general, common interface to particular and specific structures
14:56:22 <glguy> mausch: Because you wrote "deriving Ord" and said "I don't care, just make a total order please, I can't be bothered to specify one because it doesn't matter"
14:56:24 <Gaelan> @pl hammingDistance a b = length ( filter id ( zipWith (==) a b) )
14:56:25 <lambdabot> hammingDistance = ((length . filter id) .) . zipWith (==)
14:56:32 <glguy> and when it doesn't matter that's just what you need
14:56:38 <MagneticDuck> today I will learn about lenses!
14:57:19 <mausch> I'd still rather have the compiler error out and tell me: "I'm not guessing this for you, tell me exactly what you want"
14:57:20 <bb010g> mausch: http://www.haskell.org/onlinereport/derived.html#derived-appendix
14:57:23 <athan> Bor0: :) I think you're right, with `id` being the identity to the objects
14:57:36 <MagneticDuck> it seems that lenses are really pretty much absolutely necessary if I don't want to be writing huge freaking amounts of boilerplate everywhere I want to make large datatypes and work with them
14:57:37 <athan> MagneticDuck: Today I will actually try to use them!
14:57:59 <MagneticDuck> but tell me -- how many more absolutely necessary things will I have to learn until I can start doing absolutely necessary work?
14:58:04 <MagneticDuck> :(
14:58:14 <edwardk> MagneticDuck: it never stops, but you'll find that that is okay
14:58:20 <athan> MagneticDuck: I had to read Scrap Your Boilerplate, which is educational on it's own
14:58:27 <athan> hahaha
14:58:49 <mausch> The spec doesn't really say *why* this is so, it only describes how it is.
14:58:52 <bb010g> mausch: It's not guessing; the behaviour is defined in the Haskell 98 Report. If you want something different, you can define that yourself in a normal instance declaration.
14:59:10 <MagneticDuck> oh, syb
14:59:17 <MagneticDuck> haven't heard of that
14:59:30 <MagneticDuck> tell me -- is it less work to learn than the lens libraries?
14:59:31 <geekosaur> there's lots of generics libraries; lenses are just one approach
14:59:40 <athan> Yes
14:59:46 <athan> ...kinda
14:59:48 <MagneticDuck> is it a viable alternative?
14:59:58 <athan> no
14:59:58 <edwardk> MagneticDuck: the nice thing is basically everything is less work than learning lens. so you've got that going for you now. ;)
15:00:15 <MagneticDuck> ugh
15:00:30 <MagneticDuck> athan: but if I use syb.. I won't have boiletplate
15:00:32 <vanila> really curious about this lens stuff
15:00:34 <MagneticDuck> so I guess that's okay
15:00:41 <MagneticDuck> vanila: IT"S ABSOLUTELY NECESSARY
15:00:42 <athan> Be the lens, MagneticDuck
15:00:48 <vanila> lol
15:00:49 <MagneticDuck> okaay .__.
15:01:03 <bb010g> mausch: It's an easy way to get orderings quickly. I'd much rather follow an arbitrary ordering for my declaration than write them out each time. data Size = Small | Medium | Large deriving (Eq, Ord) is really nice. Also, it works well with things like Data.Set where Ord is needed, even if you don't really sort your type (e.g. in a parse representation).
15:01:07 <vanila> I get how they compose, and are used to project out fields, or modify fields
15:01:11 <vanila> but what comes next?
15:01:13 <cmccann> mausch: the "deriving" list is you telling it you want it to guess though
15:01:17 <MagneticDuck> EVERYTHING
15:01:57 <bb010g> MagneticDuck: #haskell-lens and https://youtu.be/cefnmjtAolY
15:02:06 <athan> vanila: Haskell DSL in Haskell
15:02:18 <bb010g> And vanilla
15:02:58 <MagneticDuck> https://twitter.com/PLT_Borat/ <- the funny quotes FP language
15:03:40 <mausch> cmccann: bb010g: ok, thanks
15:04:31 <cmccann> mausch: if you don't derive Ord you'll get the error you want if and when you try to use something that needs an Ord instance for that type
15:04:42 <athan> I still don't have any idea what the yoneda lemma implies and does
15:05:14 <bb010g> :t S.map
15:05:15 <lambdabot> Ord b => (a -> b) -> S.Set a -> S.Set b
15:05:33 <mausch> cmccann: I know, I was only wondering about the arbitrary Ord derivation
15:05:47 <Bor0> athan, I have a bit misunderstanding for associativity. say, I consider a monoid M with operation (.) function composition, and the set of all functions. does this form a monoid? it sure forms a category, right?
15:06:49 <Bor0> athan, for monoid, associativity says "for all", but for category it says "if...then...". this is the part that confuses me
15:07:01 <glguy> Bor0: your intuition is good, check out the Endo type: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html#t:Endo
15:07:25 <bb010g> Bor0: It forms a monoid if you compose functions of the same type, e.g. instance Monoid (forall a. (->) a a) where {mempty = id; mconcat = (.)}
15:07:51 <Bor0> only and only for a -> a, correct?
15:07:54 <bb010g> Bor0: And that can be extended to (forall c a. Category c => c a a)
15:09:26 <bb010g> glguy: Is there an instance for category monoids like that?
15:10:13 <glguy> bb010g: Not that I know of in "base"
15:11:30 <Bor0> bb010g, which law does not hold for monoids if I consider functions a -> b? it's associativity, right?
15:11:43 <bb010g> :t mconcat
15:11:44 <lambdabot> Monoid a => [a] -> a
15:11:53 <bb010g> :t mappend
15:11:53 <lambdabot> Monoid a => a -> a -> a
15:12:01 <timmy_tofu> Is there a reasonable way to run cabal repl and import something from the global repo. Just so that if I'm fooling around in the repo and want to use something that I don't have in my local and might not really need it long-term but just want to use some utility while repling?
15:12:05 <corgifex> Bor0: what would be your mappend?
15:12:22 <bb010g> (b -> c) !~ (a -> b)
15:12:30 <Fuuzetsu> for something as easy as Nats, we sure have a poor support for it‚Ä¶
15:12:35 <btcNeverSleeps> if I want to install the Haskell platform 2014.2.0.0 on a Debian 7 system, do I need compile from sources or should the "generic linux binaries" work?
15:12:38 <Bor0> what is this notation !~
15:13:04 <bb010g> Bor0: Psuedo-notation for non equality of types. (a ~ b is type equality between a & b)
15:13:13 <Bor0> oh, I see
15:13:26 <btcNeverSleeps> I'm asking because it says "Success reported with: Mint 17, Ubuntu 12, Ubunutu 14" for the generic linux binaries, but doesn't mention Debian 7 itself.
15:13:32 <Bor0> so the types don't line up, there is no flow, thus it does not make a monoid. however, it makes a category, right?
15:13:46 <bb010g> Bor0: Yes.
15:13:53 <bb010g> :t (C..)
15:13:53 <lambdabot> Category cat => cat b c -> cat a b -> cat a c
15:13:57 <bb010g> :t (C.id)
15:13:57 <lambdabot> Category cat => cat a a
15:14:01 <Fuuzetsu> btcNeverSleeps: Try-and-see, chances are no one tried with Debian 7.
15:14:07 <bb010g> :t (C.>>>)
15:14:08 <lambdabot> Category cat => cat a b -> cat b c -> cat a c
15:14:10 <Fuuzetsu> Well, no-one that has access to that page
15:14:18 <btcNeverSleeps> Fuuzetsu: oh gotcha
15:14:32 <Bor0> thanks for the information bb010g and all. I think I got it this time :)
15:17:49 <CaptainK> what is the size of the entire hackage database?
15:19:09 <merijn> CaptainK: BLind stab in the dark guess: Couple of GB?
15:19:13 <merijn> Max
15:19:20 <napping> CaptainK: 7.2M for 00-index.tar.gz
15:19:38 <merijn> That's just the index, no, not the actual sources
15:19:48 <CaptainK> was going to say
15:20:05 <napping> depends what you mean by "entire hackage database"
15:20:21 <napping> I doubt sources are in any database, most of the interesting stuff is in the cabal files I think
15:20:39 <napping> maybe a few more fields for pointers to generated documentation and stuff
15:22:41 -zbt4880(~tc@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -gew5407(~ri@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -ugn8961(~fw@ool-4a58dcab.dyn.optonline.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -ysj4041(~uz@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -frm3126(~nr@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -kty3719(~iv@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -fsq5434(~gi@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -oij8197(~ll@ool-4a58dcab.dyn.optonline.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -glw4283(~tz@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -njt4543(~ff@ool-4a58dcab.dyn.optonline.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -bie1369(~xt@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -obz1683(~uj@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -npq4093(~vs@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -pek5005(~pb@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -zsy5928(~xr@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -hib9694(~wx@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -wnp5155(~ym@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -tcj6099(~nb@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -mrl7359(~ha@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -kpk7868(~wj@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -svz2345(~nj@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -ols2859(~qa@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -pke7535(~jp@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -psh7557(~rr@24.90.159.176)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -ahl8457(~oi@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -sai3944(~co@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -lfm1848(~gx@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -jfh8072(~fv@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -bpi7496(~qc@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -dbj6028(~wg@173.202.203.128)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -hei7094(~md@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -hxc6247(~jt@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -xfn8905(~bz@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -mix2011(~js@69.117.216.63)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -svl5609(~od@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -mtb3017(~zv@ool-4a58dcab.dyn.optonline.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:41 -hyf1025(~de@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:42 -box7697(~dn@c-76-120-222-230.hsd1.va.comcast.net)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:42 -qqm8913(~iq@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:42 -xwb4703(~rh@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:42 -vce6586(~ut@cpe-24-90-159-176.nyc.res.rr.com)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:22:43 -mix2011(~js@69.117.216.63)- HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free? HEY F A G G O T S do your mothers suck C O C K For free?
15:23:23 <merijn> @where ops
15:23:23 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
15:23:38 <sveit_> in the typeclass i am making it makes sense to have a generic initializer for members of the class, but in order to do this i have to provide different informatoin depending on the instance. so for example "class C a where initializeFromB :: a -> B -> a". do people export a "mostly empty" version of a for this? my problem is i can't fill the fields with "undefined" since it is strict in some of its fields.
15:23:46 --- mode: ChanServ set +o edwardk
15:23:53 --- mode: edwardk set +b mix2011!*@*
15:24:08 <geekosaur> sadly not helpful, they broadcast to channel
15:24:10 <geekosaur> from outside
15:24:17 <merijn> ah
15:24:28 <edwardk> well, he was in the channel while broadcasting earlier
15:24:29 <merijn> Is there no way to block notices to a channel?
15:24:54 <edwardk> and yes you can block notices to channel
15:25:27 <athan> I almost feel bad for him
15:25:29 <OooL> You fucking faggot idoru I'll be around, take care
15:25:34 --- mode: ChanServ set +o geekosaur
15:25:38 --- mode: edwardk set +b *!~net@79.98.158.170
15:25:38 --- mode: geekosaur set +b *!*net@79.98.158.*
15:25:39 --- kick: OooL was kicked by geekosaur (OooL)
15:25:50 <Cale> lol
15:26:02 <yukko> do you think he wrote his IRC spammer in haskell
15:26:03 <geekosaur> also too dumb to know idoru is a bot, apparently
15:26:09 <Cale> yeah
15:26:13 <athan> hahahaha!
15:26:14 <Cale> that's what I was laughing about
15:26:21 <geekosaur> threats are about as helpful as they'd be against a brick wall
15:26:59 --- mode: geekosaur set -o geekosaur
15:27:00 --- mode: edwardk set +b *!*@cpe-24-90-159-176.nyc.res.rr.com
15:27:07 --- mode: edwardk set -o edwardk
15:27:17 <Fuuzetsu> @pl f <$> (g <$> h <*> i)
15:27:17 <lambdabot> f <$> (g <$> h <*> i)
15:27:20 <Fuuzetsu> zz
15:27:23 <sbrg> isn't there a mode for no outside notice etc?
15:27:25 <Fuuzetsu> any nicer way to drop the parens?
15:27:47 <Cale> sveit_: How are you using the class? Maybe some more information would be useful... it sounds like something that you might not even want a type class for.
15:28:15 <vanila> f <$> $ g <$> h <*> i
15:28:23 <vanila> not sure if the precidence is right though
15:28:25 * frerich_ is satisfied that his Brainf*ck interpreter can run a nested BF interpreter written in BF itself ‚Äî but then realizes that a BF interpreter written in BF is a lot shorter than the Haskell version :-{
15:28:35 <vanila> probably not
15:28:49 <vanila> friden, can I see the BF interp in BF?
15:28:56 <vanila> frerich_*
15:29:01 <Fuuzetsu> vanila: that's even worse ;P
15:29:16 <Fuuzetsu> pretty sure you can't even do that
15:29:18 <corgifex> sbrg: that should be covered by channel mode +n
15:29:26 <Fuuzetsu> yep, parse error
15:29:34 <frerich_> vanila: http://lpaste.net/109392
15:30:10 <bb010g> frerich_: BF is like a DSL for BFy things
15:30:11 <vanila> How does that work?
15:31:04 <vanila> do you have a properly indented version?
15:31:40 <frerich_> vanila: Alas, no - I found this on the Internet.
15:31:59 <frerich_> There are a couple other BF interpreters in BF, but they are a lot longer.
15:32:02 <sveit_> in the typeclass i am making it makes sense to have a generic initializer for members of the class, but in order to do this i have to provide different informatoin depending on the instance. so for example "class C a where initializeFromB :: a -> B -> a". do people export a "mostly empty" version of a for this? my problem is i can't fill the fields with "undefined" since it is strict in some of its fields.
15:32:06 <vanila> yeah this is so much shorter than I expecte
15:32:07 <vanila> d
15:32:15 <vanila> I can't be bothered RE"ing it but I want to know how it works..
15:35:00 <sx_> hi, has anyone tried http://hackage.haskell.org/package/curl-1.3.8 ? i'm searching something which is able to download files (support HTTP and FTP). It seems to me that there is no possiblity for a pull based approach, or I'm just too stupid to find it. But then I see no point for the chunk (ByteString) based functions.
15:39:20 <Scorchin> Hi. This is probably a silly question, but are there any good examples of how to get a "proper" haskell project started? Things like the recommended package manager, testing tool, structure, etc.
15:39:40 <Scorchin> Worth saying that I'm still learning Haskell but find it easier to learn by writing unit tests for functions I'm making
15:39:58 <Scorchin> or just tests in general, forget the unit bit of it
15:41:31 <timmy_tofu> Scorchin: hi is a utility to make project scaffolds from git repos
15:41:39 <Cale> Scorchin: For testing, look into QuickCheck. Unit tests are a degenerate case of QuickCheck tests (ones which have no arguments)
15:41:57 <timmy_tofu> Scorchin: I've never actually used hi myself, but a template like https://github.com/fujimura/hi-hspec might suit you
15:42:20 <Scorchin> Excellent. I'll look into all of those.
15:42:36 <Cale> cabal init is a lightweight way to get a .cabal file started
15:42:51 <merijn> sveit_: Sounds like what you want is not very well suited to typeclasses?
15:43:01 <bb010g> Also, you can look at some projects in Hackage or GitHub
15:43:06 <Scorchin> Cale: I've heard of QuickCheck and test.check (Clojure equivalent) but didn't want to start off with that. It's more learning by making my assumptions really clear and then seeing if they stick in terms of how the implementation works, etc.
15:43:25 <Scorchin> ^ that's the kind of testing I mean
15:43:31 <Fuuzetsu> > maxBound (undefined :: Char)
15:43:32 <lambdabot>  can't find file: L.hs
15:43:33 <Fuuzetsu> > maxBound (undefined :: Char)
15:43:35 <lambdabot>  No instance for (GHC.Show.Show a0)
15:43:35 <lambdabot>    arising from a use of ‚ÄòM820526395599970669722501.show_M8205263955999706697...
15:43:35 <lambdabot>  The type variable ‚Äòa0‚Äô is ambiguous
15:43:35 <lambdabot>  Note: there are several potential instances:
15:43:35 <lambdabot>    instance [safe] GHC.Show.Show
15:43:46 <Fuuzetsu> :t maxBound
15:43:47 <lambdabot> Bounded a => a
15:43:47 <Cale> Scorchin: I recommend keeping two windows open while you write code: one for your text editor of choice, and one for ghci
15:43:58 <Fuuzetsu> :t maxBound :: Char
15:43:59 <lambdabot> Char
15:44:03 <Fuuzetsu> maxBound :: Char
15:44:07 <bergmark> Scorchin: tasty + hunit
15:44:09 <Fuuzetsu> > maxBound :: Char
15:44:10 <lambdabot>  '\1114111'
15:44:15 <Cale> Scorchin: You can tap :r in ghci whenever you save your file, and it'll reload so that you can try things and make sure they work as you expect
15:44:34 <Scorchin> is there an Emacs slime binding to hook a ghci session into a buffer?
15:44:43 * Scorchin looks into a flymake mode for Haskell
15:44:50 <bb010g> Scorchin: IIRC, yes
15:44:55 <Fuuzetsu> > ord (maxBound :: Char)
15:44:56 <lambdabot>  1114111
15:45:07 <Fuuzetsu> > chr 1114111
15:45:07 <Cale> There's stuff for Emacs, yeah. I forget what it all is, because I'm a bit of a text editor luddite :)
15:45:08 <lambdabot>  '\1114111'
15:45:26 <Fuuzetsu> OK, that's a lot more than 65535 I was going with in my QC instance‚Ä¶
15:45:28 <CaptainK> Here is the kindof idea I had? http://stackoverflow.com/questions/14758423/how-can-one-make-a-private-copy-of-hackage
15:45:38 <Scorchin> Cale: all good, I know my text editor's ecosystem quite well. I'll work it out :-)
15:46:45 <bb010g> Anyone here use Sublime Text? How's it compare to Emacs/Vim?
15:47:24 <CaptainK> Sublime is kick ass
15:48:25 <CaptainK> but vim rules at the CLI
15:48:53 <bb010g> I'm excited for what #neovim is doing.
15:51:20 <spott> bb010g: me too
15:51:24 <athan> CaptainK: I keep seeing people do really cool things with vim, but I just don't know where to learn :/
15:51:35 <spott> athan: start using it...
15:52:08 <spott> vimtutor on the command line will help
15:52:30 <jophish> bb010g, anything about nvim in particular?
15:52:32 <athan> spott: there we go, thanks. The commands just don't feel intuitive yet
15:52:33 <sbrg> vim rotated 180 degrees is "win"
15:52:49 <jophish> ?
15:52:50 <spott> athan: yea, it will take a long time...
15:52:52 <athan> hahaha
15:53:03 <sbrg> athan: they will. and eventually, they are the only thing that will feel natural and you will feel handicapped whenever you have to use a non-modal editor.
15:53:12 <jophish> athan, Play a bit of nethack, you'll have the navigation keys in no time
15:53:13 <athan> sbrg: My favorite is "wow dood"
15:53:40 <spott> athan: this helps http://vimcasts.org/blog/2013/02/habit-breaking-habit-making/
15:53:44 <athan> jophish: Is that the vim web game?? I got past level 1 :)
15:54:00 <jophish> athan, I don't think so. Nethack is a text based roguelike
15:54:05 <athan> spott: Thanks man :)
15:54:09 <jophish> have you got a link to the game?
15:54:18 <athan> jophish: Oh! Perfect! Yeah one sec
15:54:37 <athan> jophish: http://vim-adventures.com/
15:54:42 <jophish> thanks
15:54:44 <athan> my computer was bugging out though
15:54:50 <athan> :)
15:54:50 <bb010g> jophish: Plugins are being completely redone to be less suckish and not require recompilation for each language.
15:55:02 <bb010g> jophish: It's a message passing API.
15:55:08 <spott> jophish: neovim is rewriting vim so it has a pluggable gui, and is rewriting the plugin system so that it sucks less (and also runs on a different thread)
15:55:15 <athan> ooop, crap. I think it's killing my browser now
15:55:20 <bb010g> jophish: Also, similar abstraction for the GUI: it's not built in.
15:56:24 <jophish> they're translating viml to lua too, right>
15:56:29 <spott> jophish: yea
15:56:58 <sbrg> spott: also different language etc
15:57:01 <sbrg> no more vimscript
15:57:09 <sbrg> jophish: yeah, something like that yeah
15:57:17 <dolio> Perhaps there is a more appropriate forum for discussion about neovim.
15:57:19 <bb010g> sbrg: Vimscript is still there, but it's just another language.
15:57:34 <spott> sbrg: yea, luajit instead.  viml will be transcompiled
15:57:54 <bb010g> And as dolio said, #haskell-blah or #neovim
15:57:58 <desophos> haha this game is neat athan
15:58:25 <spott> well, more towards haskell: anyone use yi?
15:58:43 <shachaf> No.
15:58:53 <athan> desophos: :D
15:59:04 <athan> spott: lambency!
15:59:07 <bb010g> spott: I've been trying it out lately. It's alright, even without config. Fuuzetsu knows a lot more about it than me. #yi
15:59:09 <shachaf> This forum is appropriate for discussion of unboxed sum types. Is there any good discussion to be had?
15:59:20 <shachaf> What would it take to implement unboxed sums in GHC? Would it be worth it?
15:59:31 <bb010g> shachaf: I thought unboxed was more #ghc. ;D
15:59:54 <shelf> old versions of documentation on hackage get much better search rankings than the newer versions
16:00:01 <shachaf> OK, what would it take to implement unboxed sums in a Haskell compiler similar to GHC?
16:00:11 <shelf> does this bug anyone else
16:00:22 <shachaf> Right now, if you have e.g. f :: ... -> Maybe Int, and f isn't inlined, then it has to allocate a Maybe.
16:00:34 <shachaf> Even if that Maybe gets pattern-matched on right away.
16:00:47 <spott> shachaf: I think unboxed sum types are probably damn near impossible...
16:00:56 <shachaf> This seems kind of wasteful.
16:00:58 <shachaf> Why?
16:01:14 <shachaf> We have CPR.
16:01:19 <spott> CPR?
16:01:20 <dolio> Does it need to get inlined, or just spec-constred?
16:01:47 <spott> cause an unboxed value is a pointer to the value:  but a sum type doesn't have a single value type.
16:02:55 <dolio> I guess that question is also whether spec-constr is the equivalent of CPR you're looking for.
16:02:56 <shachaf> dolio: What do you mean?
16:03:11 <shachaf> Ah. I guess I'd better read about spec-constr, then.
16:03:20 <spott> what is CPR?
16:03:23 <shachaf> @where cpr
16:03:23 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/Papers/cpr/index.htm
16:03:31 <dolio> CPR is constructed product return.
16:03:39 <Fuuzetsu> > let g = enumFromTo minBound maxBound :: [Char] in all $ zipWith (==) g g
16:03:40 <lambdabot>  Couldn't match expected type ‚Äòa -> GHC.Types.Bool‚Äô
16:03:41 <lambdabot>              with actual type ‚Äò[GHC.Types.Bool]‚Äô
16:03:42 <dolio> Or something like that.
16:03:48 <shachaf> Result, I think.
16:03:50 <shachaf> What is SpecConstr?
16:04:12 <dolio> I believe it's supposed to specialize functions on sum types to specific construtors of the sum.
16:04:21 <dolio> And it was very important for stream fusion.
16:04:57 <dolio> But I don't know many details.
16:05:12 <shachaf> I can believe that this is relevant for stream fusion, but I don't think GHC does the sort of thing I'm talking about.
16:05:32 <shachaf> Is there a paper to read or something, or do I just look at SpecConstr.lhs?
16:05:41 <dolio> Dunno.
16:06:29 <shachaf> I'm thinking of something along the lines of a worker-wrapper transformation for a function that returns e.g. a Maybe.
16:07:02 <dolio> I'm not sure what it is you want, though. If it's for calls like 'f (Just x)' to instead call 'f_Just x', then I think that's spec-constr.
16:07:54 <dolio> Oh, returns a maybe.
16:08:10 <dolio> I thought you meant calling with sums.
16:08:13 <shachaf> Oh.
16:08:27 <shachaf> No, CPR wouldn't be relevant in that case either (I think).
16:08:36 <Lara22>  Hi! I give you some videos. I hope you like! http://bit.ly/1mFMmyS
16:08:41 <shachaf> I mean e.g. foo :: Int -> Maybe Int; foo 0 = Nothing; foo x = Just (x + 1)
16:08:45 <dolio> Well, in that case, I'm not sure what you think is happening actually happens, either.
16:08:46 --- mode: ChanServ set +o glguy
16:08:54 --- mode: glguy set +b *!*@37.221.169.147
16:09:00 --- kick: Lara22 was kicked by glguy (spam is offtopic)
16:09:20 <shachaf> Into maybe something like foo_worker :: Int -> (# Int#, Int #); foo_worker 0 = (# 0#, undefined #); foo_worker x = (# 1#, x + 1 #)
16:09:54 <athan> Would it be too much to force people register with nickserv?
16:10:02 <dolio> Like, the STG model is for 'returning a constructor' to push some things on a stack and call a function with the tag.
16:10:05 <merijn> shachaf: Where the first Int# is supposed to encode the constructor?
16:10:06 <shachaf> foo_wrapper :: Int -> Maybe Int; foo_wrapper x = case foo_worker of (# 0#, _ #) -> Nothing; (# 1#, x #) -> Just x
16:10:09 <bb010g> athan: We used to. Do we not now?
16:10:09 <shachaf> Something like that.
16:10:22 <athan> bb010g: I never have to
16:10:28 <merijn> athan: It's a high barrier to entry for noobs using webclients
16:10:31 <dolio> And you only build something like 'Just x' if you have to write back to an update closure.
16:10:36 <athan> true...
16:10:43 <athan> they should learn, though!!
16:10:43 <merijn> And #haskell is supposed to have a low entry barrier
16:10:50 <athan> :S
16:11:04 <Cale> shachaf: http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/index.htm
16:11:06 <bb010g> merijn: https://kiwiirc.com/ supports NickServ auth on entry for a network
16:11:22 <merijn> bb010g: That means you have to actually register a nick in the first place, though
16:11:33 <merijn> bb010g: And need to know that there is such a thing as registering
16:11:40 <merijn> And such a thing as nickserv, etc.
16:11:46 <shachaf> Cale: Thanks. I ought to have looked for that myself, but I didn't expect it to have that name for some reason.
16:12:20 <bb010g> merijn: I think we just put something in the topic along the lines of "Register with NickServ first: /msg NickServ help"
16:12:36 <shachaf> dolio: You'd only be able to do this transformation in some cases, of course, just like with CPR.
16:12:37 <merijn> bb010g: How would they see that topic?
16:12:53 <shachaf> That's why it's constructed-product-result, not just any-ol'-product-result.
16:12:55 <bb010g> merijn: I think they could enter, but not post
16:15:49 <shachaf> Cale: (Are you saying this is relevant to my question or just that there's a paper?)
16:15:54 <dolio> shachaf: Doesn't CPR avoid a branch basically, though?
16:16:00 <dolio> You can't avoid a branch with a sum type.
16:16:06 <Cale> shachaf: Just that there's a paper about SpecConstr
16:16:29 <shachaf> dolio: CPR avoids allocating a product in the first place.
16:16:40 <Cale> shachaf: I've been a bit distracted and noticed you asked whether there's a paper about SpecConstr, so I linked it, but I missed your actual question
16:17:27 <shachaf> dolio: Or maybe I don't understand your question?
16:17:30 <dolio> shachaf: I'm not sure that's accurate with respect to STG semantics.
16:17:42 <dolio> Maybe GHC is different now.
16:18:05 <shachaf> Different from 1992?
16:18:17 <dolio> Well, I know it's different.
16:18:33 <dolio> Just not whether it's different in ways that are relevant.
16:18:34 <shachaf> What situation do you have in mind in particular?
16:19:43 * hackagebot xml-to-json 1.0.0 - Library and command line tool for converting XML files to json  http://hackage.haskell.org/package/xml-to-json-1.0.0 (NoamLewis)
16:20:27 <shachaf> dolio: Are you talking about "vectored returns"?
16:20:31 <dolio> According to the STG evaluation model, something like 'let f x = (x, x) in case f 5 of (x, y) -> ...' doesn't "allocate a product" I think exactly.
16:20:33 <zwer> wcaleb
16:21:41 <dolio> You push a case frame, push 5, enter f, which pushes 5 twice, then enters (,) which calls return-to-case with 1, maybe after some additional pushes.
16:22:00 <dolio> Unless I'm confused.
16:22:21 <dolio> There's no 'let p = (x, x)' in there that would "build a product".
16:24:35 <enthropy> is there some way to defer selecting an instance based on a kind variable?
16:24:40 <dolio> But there's still a branch in return-to-case which tests the constructor tag 1 and figures out which branch of the case to take.
16:25:10 <dolio> So CPR eliminates that by rewriting the code to use unboxed tuples.
16:25:48 <enthropy> class C (x :: k) (y :: *);  instance (k ~ (*), t ~ ()) => C (t :: k) () -- roughly the syntax I think should work
16:27:05 <enthropy> well maybe "defer" isn't the right word. I mean that the instance should be selected before deciding that the kind variable is *
16:28:07 <mcbears> am I right in saying that types of kinds other than * (or #) are uninhabited (even by bottom)?
16:28:19 <Cale> enthropy: So you just want it to overlap with everything?
16:28:26 <Cale> enthropy: What's the point of the type class then?
16:28:58 <dolio> mcbears: That might not be the best way to put it.
16:29:17 <shachaf> ski calls them "uninhabitable"
16:29:19 <Cale> mcbears: The thing to the right of :: needs to be something of kind * (or some unboxed kind)
16:29:20 <enthropy> in http://code.haskell.org/~aavogt/HList/doc/Data-HList-Labelable.html
16:30:05 <Cale> Even calling things of other kinds "types" is slightly awkward.
16:30:15 <enthropy>  mkTIC1 True & hLens' Label %~ not -- should have the instance for TIC selected
16:30:22 <mcbears> I guess I mean "type-level things"
16:30:27 <mcbears> but thanks :)
16:30:34 <enthropy> oops that page hasn't been updated
16:30:35 <Cale> mcbears: Yeah, I know what you mean
16:30:58 <Cale> mcbears: I think everyone kind of faces the same dilemma about what word to use for those
16:31:10 <shachaf> dolio: I don't think my mental model matches yours here.
16:31:29 <enthropy> anyways, (Label `asTypeOf` (Label :: Label (t :: *))) makes the code work properly
16:31:59 <enthropy> but if you know the collection is a TIC, the type inside the Label has to have kind *
16:32:19 <shachaf> The CPR paper suggests that the allocation is still important?
16:32:50 <Gaelan> @pl foo x = func x && otherfunc x
16:32:50 <lambdabot> foo = liftM2 (&&) func otherfunc
16:33:08 <Gaelan> @pl foo x = thirdFunc || func x && otherfunc x
16:33:08 <lambdabot> foo = (thirdFunc ||) . liftM2 (&&) func otherfunc
16:33:15 <dolio> mcbears: It's kind of like the difference between saying "'5 is an element of 2' is false" and "'5 is an element of 2' is not a well formed proposition".
16:33:37 <Gaelan> @pl foo x = thirdFunc x && func x || otherfunc x
16:33:37 <lambdabot> foo = ap ((||) . liftM2 (&&) thirdFunc func) otherfunc
16:33:41 <mcbears> that makes sense
16:33:59 <dolio> shachaf: Okay. Then my mental model doesn't match how GHC operates.
16:34:20 <dolio> Or I'm missing that STG's invariants require there to be an allocation.
16:34:29 <dolio> Both of which are possible.
16:34:41 <shachaf> dolio: Or mine doesn't. It's been a while since I thought about any of this.
16:34:59 <shachaf> But the CPR paper does talk about saving an allocation as one of the benefits.
16:35:21 <shachaf> E.g. for Int vs. Int#
16:35:26 <athan> Anyone know a good introduction to dependent type theory? (possibly with GADTs & rank-2 polymorphism?)
16:36:55 <mcbears> athan: the first chapter of homotopy type theory worked okay for me, it was easier than it seemed
16:37:04 <mcbears> though I don't think there were GADTs per se
16:37:25 <athan> hmm, alright! Thanks, mcbears
16:37:50 <mcbears> for something more programming-ish, one of the Idris tutorial papers could work
16:38:03 <athan> I'm reading "a pattern for almost compositional functions" by Bringert & Ranta, and they mention 'general tree types', I hope I don't get lost from it
16:38:14 <athan> thanks :)
16:38:42 <alorente> I'm deleting a big whack of functionality from this application. Is there a tool for finding modules that're no longer imported?
16:38:52 <dolio> shachaf: Oh, one possibility is that my case statement was bogus.
16:39:01 <dolio> I can't remember if you can write 'case f 5 of ...'
16:39:06 <cwraith> alorente: ghc -Wall
16:39:16 <dolio> Or if you need to write: 'let p = f 5 in case p of ...'
16:39:16 <cwraith> alorente: oh, you meant in the other direction.
16:39:30 <dolio> If it's the latter, that's an allocation.
16:39:42 <shachaf> I know SPJ talked about related issues once. If only he still frequented #ghc.
16:40:01 <alorente> maybe I can do something with find and grep
16:40:25 <shachaf> On the other hand if he did we probably wouldn't have a compiler.
16:40:42 <dolio> shachaf: -ddump-stg has 'case f 5 of ...' though.
16:41:13 <shachaf> dolio: What's the code you're compiling? I'll look at the output.
16:41:14 <c_wraith> dolio: inlining?
16:41:48 <dolio> shachaf: f x = (x,x) ; {-# noinline f #-} ; main = case f 5 of (x, y) -> print x
16:42:03 <shachaf> whoa, lowercase pragmas
16:42:42 <shachaf> i have no one to blame but myself
16:43:19 <merijn> alorente: Delete everything but your main module from your cabal file, readd until cabal stops complaining about missing modules? :>
16:45:13 <shachaf> dolio: Looking at the Cmm, f is certainly doing a heap allocation.
16:45:40 <shachaf> Which is what I'd expect. You wouldn't?
16:45:58 <dolio> Dunno.
16:46:32 <dolio> We would do a heap allocation in ermine, but that's because we're extremely dumb about the default case.
16:47:02 <dolio> Or, not default, but the 'x' in 'case e of x { ... }'
16:47:24 <dolio> We turn that into 'let x = ... in case e of { ... }'
16:47:41 <dolio> Er, sorry. 'let x = e in case x of { ... }'
16:47:50 <dolio> Which is obviously a heap allocation.
16:47:52 <alorente> merijn: I'm not suer what "readd" means
16:48:10 <danilo2> Hello! Is it possible to use GHC Api and build something like TemplateHaskell structures and then compile them in GHC?
16:48:14 <dolio> But, GHC has STG with the 'whole' argument to case, and I don't know how that works.
16:48:18 <dolio> Maybe it's a heap allocaiton.
16:49:02 <dolio> case on unboxed tuples has the same form, but maybe it's not a heap allocation.
16:49:45 <dolio> Well, obviously it isn't.
16:50:36 <dolio> Now I'm looking at: f 0 x = (x, x) ; f n x = f (n-1) x ; main = case f 1000 5 of ...
16:50:52 <dolio> You can see CPR in that.
16:50:58 <merijn> alorente: re-add
16:51:18 <alorente> oh!
16:51:22 <merijn> alorente: If cabal complains "can't find module X", add X to the exposed module list
16:51:50 <alorente> unfortunately I don't have an exposed-modules list to work with, just a hs-source-dirs and a main-is
16:52:10 <merijn> oh, you just have an executable?
16:52:14 <alorente> yeah
16:52:16 <merijn> Then I don't know
16:52:34 <merijn> alorente: "mv Foo.hs Foo.bak" move back until it compiles again >.>
16:52:48 <shachaf> dolio: Sure, you'd see CPR in all of these, with noinline.
16:52:56 <alorente> that...might work actually
16:53:05 <alorente> since I'm removing more than I'm keeping...
16:53:17 <dolio> shachaf: I didn't see CPR on my first example at -O2.
16:53:25 <dolio> I think the noinline blocks it.
16:53:25 <alorente> or even just rm -rf src and then git checkout to get it back
16:53:44 <shachaf> dolio: You had noinline.
16:53:53 <shachaf> Er, sorry, I meant *without* noinline.
16:53:56 <dolio> Oh.
16:53:58 <shachaf> CPR + noinline doesn't make sense.
16:54:07 <dolio> But if you don't have noinline it will just inline all of f.
16:54:19 <shachaf> Yes.
16:54:24 <dolio> And it should spec case probably.
16:54:45 <shachaf> I'm not sure if there's a way to have it CPR and inline just the wrapper.
16:55:20 <dolio> Well, making it recursive works.
16:55:26 <dolio> Easier than making a really big function.
16:57:22 <geekosaur> danilo2, perhaps give an example of what you're looking for. As asked, the answer could be yes or no or zeroth
16:58:42 <dolio> shachaf: I guess the 'case e of x { ... }' must always do heap allocation of the result of e as x.
16:58:48 <dolio> Even if x is unused.
16:58:56 <spopejoy> hi. I feel like I worked way too hard on this, a function [a]->[[a]] that generates ‚Äúall possible sublist sums‚Äù. comments? http://lpaste.net/edit/4808349401225363456
16:59:01 <dolio> That's the allocation it avoids.
16:59:02 <shachaf> dolio: ?
16:59:16 <danilo2> geekosaur: Oh, sorry then. I was sure the question is clear (but probably only for me :) ) So I want to generate a new program in Haskell. A completely new program - each function, datatype, everything. But I do not want to generate text. I want to generate some typed data structure (like the template haskell one) and build the file out of it. Then I want to compile it
16:59:30 <dolio> shachaf: Core and STG case have the form: case e of x { <cases }
16:59:45 <dolio> Where x is an alias to the evaluated form of e.
16:59:58 <geekosaur> hm. pretty sure TH is not sufficiently complete for that; ghc api should be, but may not be sufficiently documented
16:59:59 <shachaf> Yes, I know.
17:00:06 <shachaf> Why does the case itself ever do an allocation?
17:00:17 <geekosaur> this may be a #ghc question as opposed to a #haskell one
17:00:24 <spopejoy> sorry, http://lpaste.net/4808349401225363456
17:00:51 <dolio> shachaf: Because you have to write back to the closure x.
17:01:07 <dolio> Heap allocate x and write to it after evaluating.
17:01:23 <dolio> Instead of just jumping to the correct branch with things on the stack.
17:02:49 <danilo2> geekosaur: Ok, I asked in on #GHC. I'm just wondering why TH would not be sufficient here. I think it is very powerfull. But I would be happy with GHC Api also
17:03:03 <dolio> shachaf: http://lpaste.net/109393
17:03:44 <geekosaur> it is powerful, but it can't represent an *entire* module in its AST, much less multiple modules
17:03:46 <dolio> shachaf: If you look at the STG of that, GHC will do CPR on f, and then do a let inside main to call 'g'.
17:04:11 <dolio> shachaf: But if you noinline f, it obviously just uses the 'whole' variable in the case.
17:04:19 <geekosaur> some key things needed for that were just added in HEAD, IIRC, but I would be surprised if that made it complete
17:04:43 <dolio> So it must be equivalent. And I'd guess GHC always does the allocation this way, even if the whole part is not used.
17:04:46 <geekosaur> (also TH really wants to edit the current AST, not build a new one)
17:05:10 <danilo2> geekosaur: you are right. TH cannot add for example pragmas
17:06:50 <geekosaur> that would be my second point. in ghc api, you set flags in your ghc context to enable/disable pragmas, iirc
17:07:42 <shachaf> dolio: Are you saying that g would be doing an allocation here?
17:08:04 <dolio> No.
17:08:39 <geekosaur> ...also many pragmas are source level transformations, so you would not use them at all in this case, your AST would already reflect them
17:08:50 * shachaf looks at the STG of that.
17:08:54 <dolio> Well, maybe it would, but I'm not sure which part you're talking about.
17:09:06 <geekosaur> (consider CPP, or MonadComprehensions)
17:10:05 <spopejoy> *sniff* nobody wants to bikeshed my little function. http://lpaste.net/4808349401225363456
17:11:37 <Cale> oops!
17:11:55 <Cale> meant to annotate and ended up editing
17:12:16 * Watcher7 hugs spopejoy :(
17:12:18 <Cale> spopejoy: you might want to repost :)
17:12:24 <spopejoy> ok
17:12:35 <shachaf> Or just "annotate" Cale's post.
17:12:47 <Cale> spopejoy: but that function that I posted should be relevant
17:12:50 <spopejoy> http://lpaste.net/4808349401225363456
17:13:15 <danilo2> geekosaur: Of course. Such pragmas would be considered in the AST :) Anyway , thank you for pointing some direction :)
17:13:31 <Cale> spopejoy: There, added it as an annotation properly this time :)
17:14:16 <slack1256> Hey that game looks cool, I even have a dancepad
17:14:31 <dolio> shachaf: Anyhow, your unboxed sums would be things working the way I thought they worked.
17:14:50 <Cale> ghci> map (map sum) . partitions $ [2,1,2]
17:14:51 <Cale> [[2,1,2],[2,3],[3,2],[5]]
17:15:07 <shachaf> dolio: OK, I'll take that as a positive thing.
17:15:39 <dolio> I think it's also the way the STG paper says they work.
17:15:53 <tulcod> danilo2: i basically did exactly that for the wayland bindings i wrote recently
17:16:04 <shachaf> dolio: Are you thinking of "vectored returns"?
17:16:04 <tulcod> danilo2: a part of the code is completely TH-generated
17:16:05 <danilo2> tulcod: Oh great!
17:16:11 <spopejoy> Cale: nice
17:16:18 <danilo2> tulcod: Where can I see it ?
17:16:20 <shachaf> The thing where you push a "continuation" for each constructor, and the function you called jumps to the right one?
17:16:23 <tulcod> honestly, at the moment it's a mess, but what you said gave me some ideas
17:16:26 <glguy> spopejoy: how about this? http://lpaste.net/4808349401225363456
17:16:29 <danilo2> tulcod: TH or GHC-API generated?
17:16:38 <tulcod> danilo2: TH
17:16:51 <tulcod> danilo2: this is the core code https://github.com/tulcod/haskell-wayland/blob/master/Graphics/Wayland/Scanner.chs
17:16:58 <danilo2> tulcod: why did you choose TH over GHC API ?
17:17:04 <dolio> shachaf: Yes, basically.
17:17:04 <tulcod> dunno
17:17:21 <shachaf> @where ptr-tag talks about why they stopped doing that, I think.
17:17:21 <lambdabot> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
17:17:23 <tulcod> danilo2: i guess i don't really know about the GHC api?
17:17:30 <vanila> cabal install -p is breaking because I don't have profiliing libs, how do I get them?
17:17:34 <Cale> spopejoy: My partitions function is based on the fact that in every partition of (x:xs), you'll either have x in its own part, followed by a partition of xs, or x will be part of the first part, and after deleting it from that first part, we obtain a partition of xs
17:18:10 <tulcod> danilo2: anyway, most of my code works great. the main issue is that i don't even know what modules i'm exposing at compile time
17:18:10 <spopejoy> glguy: also nice
17:18:38 <spopejoy> but my solution chews up so much more CPU. good for budget planning.
17:19:02 <danilo2> tulcod: Ok, but you are writing just TH functions. And the nyou are using them in other hs files, right?
17:19:08 <tulcod> danilo2: and what you said made me think of the following... TH includes a pretty printer (which i think enables the -ddump-splices). maybe what you can do is generate text for language features TH doesn't support, e.g. "module" syntax, and pretty print the rest
17:19:30 <Cale> Note that while you could share the computation of partitions xs, you likely don't want to, because it will consume a lot of memory, and its elements are relatively cheap to recompute.
17:19:30 <danilo2> tulcod: If yes, then it is not what I want
17:19:38 <dolio> shachaf: That's kind of orthogonal, though.
17:19:40 <tulcod> danilo2: functions, datatypes, foreign imports. and splicing them in a couple of files to expose pretty much directly to the user.
17:19:53 <danilo2> tulcod: no, pretty printer for TH is broken for many years. It just does not always produce right code
17:20:07 <tulcod> danilo2: okay, thx for the notice :)
17:20:17 <dolio> shachaf: GHC could do vectored returns, but then the first thing in each continuation could be to build a closure for the whole evaluated result.
17:20:24 <tulcod> danilo2: anyway, in which sense is it not what you're looking for?
17:20:35 <spopejoy> what‚Äôs amazing to me is you guys did this in minutes while I futzed for hours. I need a way to approach combinatorial problems, or I‚Äôll never get that entry-level Google job :)
17:20:36 <dolio> Or that could be built before jumping.
17:20:45 <danilo2> tulcod: anyway - pretty printing something like that would make no sense-  you have to parse it again. I want to base on GHC Api or anything which woudl allow me to operate on internal structures
17:21:37 <dolio> shachaf: So the important part would be not building the whole thing. Which I don't think the STG paper even allows you to refer to the whole result in its cases except for in default branches.
17:21:37 <shachaf> dolio: Right, I guess this is just an optimization that doesn't change whether the allocation happens.
17:22:35 <tulcod> danilo2: well that doesn't mean you can't pretty print - it's just some intermediary stage to get access to more language aspects
17:22:35 <spopejoy> the mind blowing things for me here are Cale: recursive list generation. glguy: foldr gen [[]]?? foldr on an empty list???
17:22:37 <shachaf> Anyway, I'd like to see how much of a difference unboxed sums would make.
17:22:47 <tulcod> danilo2: anyway, what *are* you looking for, if not what i'm doing?
17:22:58 <shachaf> In any real programs. I guess I could worker-wrapper them by hand.
17:23:31 <tulcod> danilo2: i mean.. apart from defining "main", i'm doing as much as i can in terms of generating an entire program/library
17:23:31 <shachaf> It's a bit annoying that you can get CPR for a Stream type but not for [], "just" because you have an extra constructor.
17:23:36 <Cale> spopejoy: Remember that foldr f z xs replaces each (:) in xs with f, and the [] at the end (if any) with z
17:23:43 <glguy> spopejoy, it's not folding the [[]], that's what it's replacing [] with, it's "folding" the [Int] input
17:23:45 <Cale> spopejoy: So, the [[]] is the "replacement for []"
17:24:02 <spopejoy> arrgh, pointfree fail
17:24:35 <shachaf> dolio: I also wonder whether GHC could/should have a "native" concept of unboxed sums, like it has for unboxed tuples.
17:24:58 <shachaf> Where it handles the tag etc. by itself.
17:25:19 <dolio> I don't know enough about how it works nowadays.
17:25:20 <danilo2> tulcod: I've got program A. The program runs and creates something (using TH or GHC API). And it creates program B from scratch. But I just do not want to generate any text :)
17:25:26 <shachaf> And of course how unboxed sums should be represented in memory.
17:25:40 <tulcod> danilo2: right. so how is that not what i'm doing?
17:26:10 <dolio> As far as STG goes, unboxed tuples and unboxed sums would be more or less a "don't do that allocation of the whole result" signal.
17:26:30 <dolio> Which makes sense to be built-in.
17:26:53 <tulcod> danilo2: does your program A require user interaction? ie, do you want something like "eval" - runtime haskell compilation?
17:26:59 <danilo2> tulcod: hmm, you are using these splices by hand in other files if I'm right. So you have to manually create file and put there splices. I want to omit this step and create it also using API
17:27:23 <tulcod> danilo2: if i could do that, i would
17:27:35 <tulcod> danilo2: if you figure out any reasonable way to do that, *please* let me know
17:28:51 <Cale> spopejoy: You can also transform my partitions solution directly into a genNAds function and avoid the intermediate lists: http://lpaste.net/109396
17:29:00 <merijn> What does CPR stand for?
17:29:08 <tulcod> danilo2: there's a problem with figuring out build order if you can dynamically generate modules. so that's why GHC doesn't support a lot in that direction
17:29:11 <dolio> Constructed product result.
17:29:13 <tulcod> danilo2: let alone TH
17:29:16 <danilo2> tulcod: and this is what I meant when I was talking that I want something differnet
17:29:17 <Cale> Cardiopulmonary resuscitation ;)
17:29:48 <danilo2> tulcod: I think we need ghc api here :) I will be working on it in near future :)
17:30:13 <tulcod> danilo2: i would be surprised if GHC would support anything like that
17:30:24 <tulcod> but if you think it does, awesome
17:30:30 <vanila> isnt cabal supposed to install stuff if i dont have it?
17:31:16 <dolio> What kind of stuff?
17:31:28 <Cale> spopejoy: I find that harder to think about for some reason though
17:31:28 <tulcod> vanila: it doesn't supprot build dependencies, so you may be missing those
17:31:34 <Cale> (just a bit)
17:31:43 <vanila> well i want to debug a large program
17:31:57 <vanila> it's sandboxed
17:32:03 <spopejoy> yes but it wins the terseness award for today
17:32:04 <vanila> so I thought I could use cabal install -p to get all the profiling libs
17:37:57 <dolio> vanila: Did you have stuff installed previously without -p?
17:38:11 <dolio> I don't think cabal rebuids in that situation.
17:38:33 <vanila> yes I do
17:39:04 <spopejoy> glguy: not familiar with do syntax on a list. it appears to apply concat, but why
17:40:11 <vanila> cabal clean doesn't seem help though
17:40:28 <bergmark> spopejoy: try making your own list type with a monad instance
17:41:12 <dolio> I don't think cabal clean clears out the libraries you've installed into the sandbox.
17:41:31 <trap_exit> yo ... where can I learn how to write a pattern matching type system in haskell?
17:41:34 <trap_exit> well, I want to parse one
17:41:50 <trap_exit> I want to be able to parse a simply typed lambda calculus
17:42:38 <Iceland_jack> Check out Types and Programming Languages
17:43:27 <vanila> trap_exit, here's a quick parser for lambda, vars, applications - no case/patterns though
17:43:38 <trap_exit> vanila: yes!
17:43:40 <trap_exit> vanila: GIVE ME THE CODE
17:43:43 <trap_exit> :-)
17:43:47 <vanila> ahhh the paste site is frozen
17:43:48 <vanila> lol
17:43:53 <vanila> im going as fast as I can
17:43:59 <trap_exit> the universe is afraid of us
17:44:03 <trap_exit> it's afriad of the code we shall write
17:44:08 <vanila> http://bpaste.net/show/V85H5c42wk3438yZycJa/
17:44:31 <trap_exit> bpaste is down for me
17:44:32 <trap_exit> can you gist it on github?
17:44:38 <trap_exit> https://gist.github.com/
17:44:57 * hackagebot simple-pipe 0.0.0.9 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.9 (YoshikuniJujo)
17:44:59 <vanila> http://lpaste.net/109400
17:45:21 <trap_exit> that's it?
17:45:21 <trap_exit> 23 lines?
17:45:21 <trap_exit> :-)
17:53:05 <danilo2> edwardk: Hi! I've got a question regarding trifecta. Can we get parsing error as a structure? Something like (Unexpected "eof")? I want to use such structure to provide further information - like in GHC. If you write wroing method name, I want to provide simmilar ones.
18:07:12 <edwardk> danilo2: i'm actually refactoring the error message machinery in my working copy, it changes somewhat closer to that but not all the way. i have some old work i may be able to adapt that would let you locally supply completion/suggestion handlers that may get you what you want, if not exactly what you asked for. if time permits i can see if i can work them in
18:09:03 <danilo2> edwardk: Nice to hear that :) I do not need it right now, but I would love to built it inside of our compiler in few weeks from now. I just wanted to ask if is / would it be possible. So I understand that in new version the error machinery would base on some kind of AST which I can process / extend etc?
18:13:54 <bb010g> What else could you do with a data Listish t a = Nil | Cons a t besides make type List a = (Fix Listish) a? I feel like there's more, but I don't know how to operate on a pointlessly
18:14:34 <joelteon> isn't that just Maybe (a,b)?
18:15:04 * hackagebot scotty-binding-play 1.1 - The Play Framework style data binding in Scotty.  http://hackage.haskell.org/package/scotty-binding-play-1.1 (YusukeNomura)
18:15:27 <benzrf> bb010g: you could make an alternating list
18:15:34 <joelteon> you can do anything with (a,b)
18:16:19 <benzrf> newtype Alternating a b = Alt (Listish (Alternating b a) a)
18:16:22 <benzrf> or somethin
18:16:28 <benzrf> rewrite w/ fix if u lik
18:16:29 <benzrf> e
18:35:49 <fumieval> hi, is it possible to put C++ sources into a cabal package?
18:36:20 <fumieval> I don't need to use FFI to these sources directly
18:37:10 <geekosaur> extra-source-files?
18:42:15 <trap_exit> vanila:
18:42:17 <trap_exit> vanila: ping :-)
18:42:55 <vanila> hi
18:43:01 <vanila> hows it going
18:43:17 <trap_exit> vanila: great, I've decided to start with writing parse trees
18:43:18 <trap_exit> rather than deal with a parser
18:43:25 <vanila> that's a good idea too
18:43:28 <trap_exit> i..e the input = haskell structures taht represent the ast tree
18:43:33 <trap_exit> then deal with parsing later
18:51:08 <balakalaka> yo whats the best way to read a massive file (1TB) and parse it line by line?
18:51:53 <balakalaka> would lines + readFile do that efficiently?
18:51:54 <carter> balakalaka: incrementally
18:52:04 <carter> you dont wanna load it all at once
18:52:09 <koala_man> across machines or what?
18:52:09 <balakalaka> yeah i know
18:52:20 <carter> getLine
18:52:26 <carter> or
18:52:27 <balakalaka> but im asking what haskell apis will do that fast
18:52:29 <carter> well
18:52:34 <carter> depends
18:52:35 <MP2E> attoparsec maybe?
18:52:40 <carter> what file format
18:52:40 <MP2E> it does depend though
18:52:45 <balakalaka> the parsing itself is very simple
18:52:46 <balakalaka> csv
18:53:13 <balakalaka> i just need to figure out the actual reading
18:53:28 <koala_man> can you process it faster than the storage can provide it?
18:53:42 <carter> MP2E: i'd problyhttps://hackage.haskell.org/package/cassava-0.4.1.0/docs/Data-Csv-Incremental.html ?
18:53:44 <carter> https://hackage.haskell.org/package/cassava-0.4.1.0/docs/Data-Csv-Incremental.html
18:54:04 <carter> and load it in chunks as a binary file
18:54:06 <MP2E> "This module allows for incremental decoding of CSV data. This is useful if you e.g. want to interleave I/O with parsing or if you want finer grained control over how you deal with type conversion errors." I like the sound of this a lot
18:54:07 <carter> pick some chunk size
18:54:30 <carter> eg, load something like a 10mb window at a time
18:54:31 <carter> feed it in
18:54:32 <carter> do something
18:54:46 <balakalaka> why?
18:55:03 <carter> why what
18:55:32 <balakalaka> why load it 10mb at a time?
18:55:40 <carter> i made up that chunking size
18:55:44 <carter> point is, incrementally
18:55:49 <carter> how much ram does the machine have?
18:55:51 <enthropy> balakalaka: lines + readFile can work
18:55:52 <carter> or more than one machine
18:56:01 <balakalaka> is there an api that will do this for me?
18:56:04 <carter> do what
18:56:04 <balakalaka> like a lazy io?
18:56:11 <carter> try what enthropy  said
18:56:17 <balakalaka> ok
18:58:22 <balakalaka> I tried this with nodejs btw, and it was amazingly slow
18:58:31 <balakalaka> 10 times slower than c
18:58:47 <balakalaka> even though nodejs supposedly uses c for the file io anyway
18:59:05 <michaelt> balakalaka: what are you going to do with the data once you parse it from each line?
18:59:17 <balakalaka> michaelt: store it in a database
18:59:31 <enthropy> conduit might also be worth looking at if it's not so convenient to deal with https://hackage.haskell.org/package/cassava-0.4.1.0/docs/Data-Csv-Incremental.html#t:Parser directly
19:00:06 <carter> balakalaka: are you doing adtech data analysis?
19:00:20 <balakalaka> no, financial data
19:00:25 <carter> ok
19:00:30 <michaelt> all the non-lazy-io frameworks have some cassava tie-in it seems
19:00:32 <carter> how big a box do you have to runnt he computation?
19:00:37 <carter> michaelt: ++
19:00:43 <carter> pipes/conduits/etc
19:00:53 <carter> enumerator/iteratee?
19:01:19 <balakalaka> carter: the computations are all on small subsets of the data right now
19:01:28 <carter> no
19:01:31 <carter> how much ram
19:01:34 <carter> and how fast is disk io
19:02:10 <carter> because that lets us estimate how fast it should be under ideal circumstances
19:02:11 <balakalaka> uh idk, i think about 10GB ram tops
19:02:17 <carter> ok
19:02:20 <balakalaka> with a distributed map-reduce at first
19:02:22 <carter> and disk io throughput?
19:02:54 <balakalaka> carter: are you talking about the csv parsing?
19:03:00 <carter> sure
19:03:10 <balakalaka> what im doing right now is loading csv -> mongodb
19:03:10 <carter> the only part you specified :)
19:03:17 <carter> why?
19:03:24 <balakalaka> then i used mongodb + c++ for the rest
19:03:39 <balakalaka> because its more useful for me that way
19:05:24 <balakalaka> carter: my server nodes cant store all the data on a single machine
19:05:30 <carter> ah
19:05:30 <balakalaka> i used like 20 nodes right now
19:05:35 <carter> hrm
19:05:36 <balakalaka> and mongodb makes it all a lot easier
19:06:36 <carter> fair nuff
19:06:44 <carter> time series data?
19:06:49 <balakalaka> yeah
19:07:11 <balakalaka> i had a nodejs app for loading all the data and it took like 1 week before
19:07:25 <carter> balakalaka: you might wanna explore using H D F 5 http://www.hdfgroup.org/HDF5/
19:08:07 <carter> nodejs isn't designed for that workload!
19:08:09 <balakalaka> ah, ill check it out
19:08:28 <balakalaka> well the bottleneck was surprisingly the data loading
19:08:29 <carter> HDF5 is used for high energy physics time series data
19:08:51 <balakalaka> im not sure if its the way it reads the data from file, or the way it parses it, but its damn slow
19:08:54 <carter> ok
19:08:56 <carter> well
19:09:01 <carter> pipes or conduit might be good fro you
19:09:08 <carter> they give way of composing streaming computations
19:09:12 <merijn> o.O
19:09:14 <balakalaka> ah ok
19:09:20 <merijn> You tried that in node.js? :>
19:09:26 <balakalaka> yeah lol
19:09:29 <carter> https://hackage.haskell.org/packages/#cat:Pipes
19:09:41 <carter> conduit has stuf too
19:09:43 <carter> or enumerator
19:09:47 <balakalaka> it was the simplest at the time cause i work with nodejs a lot
19:09:57 <carter> you wanna use an API that forces you to write streaming code
19:10:15 * hackagebot simple-pipe 0.0.0.10 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.10 (YoshikuniJujo)
19:10:34 <balakalaka> ok ill try it thanks!
19:10:44 <merijn> simple-pipe sounds like a potentially confusing name >.>
19:10:57 <carter> merijn: yeah
19:10:58 <MP2E> yeah...
19:11:35 <carter> also its below PVP min :)
19:19:26 <trap_exit> Erlang has atoms. Clojure has keywords. Haskell has ENUMs, but then I have to do something like GlobalEnums.hs ... and include it in all files, and any time I change GlobalEnums.hs, everything has to recompile -- does Haskell ahve anything like atoms or keywords?
19:27:48 <merijn> Quick poll: Would lens being a dependency stop anyone from using a fairly low level library?
19:28:09 <dolio> Probably.
19:28:26 <MP2E> not me, personally
19:28:33 <glguy> You can provide lenses and traversals for the users of your library without depending on it fwiw
19:28:55 <dolio> Yeah, not me personally either, but there exist such people.
19:28:59 <carter> merijn: depends
19:29:02 <carter> how low level
19:29:17 <merijn> glguy: That doesn't help me if I use lens functions
19:29:22 <merijn> carter: Networking
19:29:49 <merijn> More specifically, I've restarted development on my haskell ZeroMQ library
19:29:57 <edwardk> merijn: 'anyone'? yes. enough people to not be worth doing anyways? not sure
19:30:05 <yyttr3> hello.
19:30:09 <edwardk> merijn: i tend to just lensify stuff because i like the effect on the API.
19:30:49 <edwardk> and it has infected enough of the haskell ecosystem that its less of a burden than it used to be. e.g. if you use a web programming framework you probably got hit with a lens dep already, etc.
19:30:50 <carter> yeah, if it makes the engineering that much easier internally and for the api, do it
19:30:55 <merijn> edwardk: Well, the alternative would be lens-family-core, which would be sufficient API wise, but I feel that depending on lens-family-core would annoy people that wanna use lens
19:31:06 <carter> why would it annoy them?
19:31:25 <jmcarthur> yet another dependency!
19:31:45 <yyttr3> Does anyone know how I would define a type constructor that took objects of kind *->* ? (I'm new) I need a data Dist a b = Dist a b where :k a = *->*
19:31:53 <edwardk> lens-family-core just makes me sad, because parts of lens were generalized to make it possible so that it could work across, but they never accepted some of the olive branches into l-f-c. =/ prisms/isos, etc, remain unimplemented there.
19:32:22 <jmcarthur> yukko: if the kind of a is * -> * then it can't be a field of the data constructor, because it's not a type
19:32:28 <edwardk> yyttr3: you mean data Dist a b = Dist (a b) ?
19:32:38 <jmcarthur> yukko: or do you mean   data Dist a b = Dist (a b)   ?
19:32:48 <jmcarthur> ugh sorry, wrong nick
19:32:53 <merijn> edwardk: Sure, but the upside is that it only depends on transformers and containers, both of which I already depend on anyway
19:33:13 <yyttr3> I'm trying to figure out the difference jmcarthur.
19:33:14 <edwardk> merijn: do what you feel you must =P
19:33:19 * edwardk shrugs.
19:33:23 <vanila> silly question but what kind of applications might one use lens for?
19:33:34 <merijn> "all"
19:33:39 <MP2E> lens is applicable everywhere, really
19:33:53 <glguy> merijn: I'd be more likely to avoid a library that made me install an extra lens library than one that used the one I already have :)
19:33:54 <vanila> i am trying to think of a project i can use it on, to learn it
19:34:02 <edwardk> vanila: whenever you need to get things out of things, or look at one case among several. not too broad a mandate i guess =)
19:34:08 <merijn> edwardk: I'm don't have any strong opinions, hence why I was polling for opinions :p
19:34:11 <edwardk> glguy++ =)
19:34:18 <MP2E> glguy++ as well :P
19:34:28 <edwardk> i confess that my experience mimic's glguys there.
19:34:53 <merijn> glguy: I could even make it depend on either using awful CPP hacks to detect which is used, but that's not much nicer >.>
19:35:12 <edwardk> vanila: folks who have to dig around in json, xml, nested records, syntax trees, compilers, etc. tend to find a lot of use for it.
19:35:13 <glguy> merijn: You should do whatever makes developing the library fun for you
19:35:17 <merijn> Plus I don't know whether cabal wouldn't do the "wrong thing" there either
19:35:19 <glguy> merijn: and worry about mass adoption later
19:35:35 <jfischoff> is there a `withForeignPtr :: ByteString -> (Ptr Word8 -> Int -> IO a) -> IO a` function in ByteString?
19:35:38 <merijn> >.>
19:35:46 <yyttr3> Ok, is it possible then to create a "type constructor" that takes objects of kind *->*?
19:35:51 <edwardk> merijn: build the best library for the domain and then users will come, make the library nice and easy to use, make it solve the fundamental problem, and wham. users.
19:35:59 <merijn> Well, maybe I'll just not use lens simply because it's complaining I need to do reinstalls >.<
19:36:04 <vanila> i cant think how i would use it on syntax trees, normally just a fold does everything i want
19:36:07 <enthropy> you can't really specify "merijn-library -fwith_lens" as a dependency, so having a flag (and CPP) to decide which dependency to pick probably won't really help people
19:36:18 <pjdelport> @kind Functor
19:36:19 <lambdabot> (* -> *) -> Constraint
19:36:22 <pjdelport> yyttr3: -^ ?
19:36:29 <nitrix> Hi guys, I need help debugging a NCurses application. It's only 33 lines, I really doubt it's a problem with the library so could someone explain me what I'm doing wrong? Supposedly, with Haskell, if it compiles, chances are it works. I already have a problem at my 1st attempt...........
19:36:34 <nitrix> http://ideone.com/02hzax
19:36:40 <platz> vanila: http://www.infoq.com/presentations/haskell-newsroom-nyt -> skip to 24:30
19:36:49 <yyttr3> Kind funtor? I'll google it? and _^ on hoogle?
19:36:56 <michaelt> yyttr3: all kinds of things do that. StateT s m a takes a * -> * thing as the second argument, of course
19:36:57 <edwardk> vanila: rewrite $ \case Neg (Lit a) -> Just $ Lit (-a); _ -> Nothing -- will recursively rebuild a syntax tree with negated literals in it into one where the value has moved into the literal for instance.
19:37:05 <pjdelport> yyttr3: Sorry, "-^" was just an ASCII up arrow :)
19:37:13 <pjdelport> yyttr3: I meant to ask if that is what you meant.
19:37:18 <edwardk> vanila: that is done using the 'Plated' generic programming machinery in lens which lets you have a traversal to immediate sub-children in a syntax tree of the same type.
19:37:18 <nitrix> When resizing the terminal, the window doesn't redraw. I even have an increment number and apparently it is incremented.
19:37:22 <jmcarthur> yyttr3: data Foo a b = Foo Int String a b    has four fields. a and b have kind *.
19:37:27 <nitrix> So what am I doing wrong with the rendering?
19:37:28 <geekosaur> nitrix, sadly, while that is often (not always!) true of pure Haskell, you've dragged in curses --- which is notoriously bizarre and often broken
19:37:49 <yyttr3> pjdelport : I don't know anything about haskell xD so I don't know what that is yet.
19:37:50 <edwardk> vanila: you can also use traverse to walk down to all the variables for instance, which is a traversal, so if you want a set of free variables you can literally use setOf traverse ...
19:37:56 <jmcarthur> yyttr3: data Foo a b = Foo Int String (a b)   has three fields. a has kind * -> * and b has kind *. (a b) has kind *.
19:37:58 <geekosaur> and if you are not getting a resize event, it is likely the ncurses library that is messing up its SIGWINCH handling *yet again*
19:38:07 <yyttr3> I'll google kind functors.
19:38:15 <nitrix> geekosaur: While I agree, this case should be fairly simple and would greatly help me going / motivates me to learn Haskell.
19:38:21 <edwardk> vanila: folds are great when you want to consider every case. but when you then extend the tree? now you have to edit every 'case' statement.
19:38:21 <pjdelport> yyttr3: Oh... that's kind of an oddly detailed and specific question if you don't know anything about Haskell. :) What's the context?
19:38:22 <nitrix> geekosaur: If you wouldn't mind having a look..
19:38:31 <michaelt> merijn can't you just define your lenses with the usual polymorphic type signature, or do you want something more.
19:38:37 <edwardk> vanila: a little bit of generic programming goes a long way
19:38:38 <pjdelport> yyttr3: You probably want a different answer than the above, i'm guessing.
19:38:52 <edwardk> vanila: prisms let you talk about constructors, we use them in the unifier for ermine for instance.
19:39:08 <yyttr3> I was making a tic tac toe program after reading learn you a haskell and I was trying to create a probability distribution Functor.
19:39:10 <yyttr3> and
19:39:20 <vanila> interesting!
19:39:26 <vanila> this is a lot different from the way I think about things
19:39:29 <merijn> michaelt: I just said I need to use lens functions, not expose lenses
19:39:33 <yyttr3> I came across needing it, or at least wanting to try it.
19:39:34 <vanila> it sounds like a really good approach though
19:40:09 <vanila> nitrix, I was going to look at it but I got cabal install problems
19:40:15 <pjdelport> yyttr3: In Haskell terms, Functor is a type class that takes a type of kind (* -> *) as parameter. (That's just its signature at the type level: the details of Functor itself aren't really important if you're only interested in that.)
19:40:15 <vanila>  #include <ncursesw/ncurses.h>
19:40:24 <nitrix> vanila: Are you on archlinux?
19:40:26 <vanila> yes
19:40:41 <vanila> i guess you could tell frmo the fact nothing works? :p
19:40:45 <merijn> oi!
19:40:46 <nitrix> Yeah it's a bug of Arch actually. I contacted the maintainer. The fix is very simple.
19:40:56 <merijn> Sense when is cabal automatically doing reinstalls without --force?
19:40:59 <merijn> *Since
19:41:10 <merijn> "Warning: Note that reinstalls are always dangerous. Continuing anyway..."
19:41:15 <nitrix> You want ln -s /usr/include/ncurses/ncurses.h /usr/include/ncursesw/ncurses.h
19:41:16 <geekosaur> I still claim not an Arch bug since ncursesw was deprecated years ago
19:41:39 <vanila> if it requires a fix it's a bug
19:41:40 <geekosaur> do we still need to retain compatibility with the 1990s?
19:41:56 <nitrix> Why does UI.NCurses needs ncursesw is a good question.
19:42:00 <geekosaur> well, the fix should not be Arch's. it's the Haskell binding that is a decade in the past
19:42:08 <vanila> well to be honset using ncurses is the REAL problem here
19:42:10 <nitrix> I though that was the newer ncurses API, the "modern" one ?
19:42:10 <merijn> Why did the cabal defaults change to "avoid-reinstalls: False"?
19:42:11 <kristof> vanila: That is libel :P
19:42:16 <geekosaur> I already said *that* part :)
19:42:17 <merijn> nitrix: Why not use vty instead?
19:42:21 <geekosaur> well, implied it
19:42:26 <nitrix> merijn: is vty better?
19:42:34 <vanila> ln: failed to create symbolic link '/usr/include/ncursesw/ncurses.h': No such file or directory
19:42:46 <merijn> nitrix: Pure haskell, so avoids annoying bindings and vty-ui is a widget library for writing applications with it
19:42:47 <geekosaur> vty has some shortcomings, but curses is just broken and weird
19:43:01 <geekosaur> vanila:you need to create the /usr/include/ncursesw directory first
19:43:10 <geekosaur> ln won't do it for you
19:43:10 <nitrix> ^ this
19:43:24 <nitrix> And you also have to do panel.h after.
19:43:29 <vanila> thanks guys :)
19:43:31 <nitrix> Then it worked for me.
19:43:44 <nitrix> But yeah, maybe vty is a better solution?
19:43:49 <vanila> this did not fix the problem
19:44:20 <vanila> I guess I need the library too
19:44:30 <nitrix> Well yeah.
19:44:48 <nitrix> That's just a symlink.
19:44:49 <vanila> I have ncurses though
19:44:55 <nitrix> Oh that's strange.
19:45:13 <vanila> ncurses /usr/include/ncurses.h
19:45:21 <nitrix> vanila: I'm sorry then. Thank you for trying to help :/
19:45:42 <yyttr3> I want to compose two type classes, a custom made on Dist and [], maybe that is a better way to explain it.
19:45:43 <nitrix> Honestly, I might just go with geekosaur's suggestion and try vty.
19:46:07 <nitrix> geekosaur: Any shortcomings you could list on top of your head to be aware of?
19:46:09 <geekosaur> in case my comment earlier was not clear, the window size change stuff is often broken in ncurses
19:46:24 <vanila> oh your symblink command was not pointinng to anything
19:46:25 <vanila> ln -s /usr/include/panel.h /usr/include/ncursesw/panel.h
19:46:26 <vanila> works
19:46:30 <geekosaur> in the C lib, that is; the Haskell bindingh can't help with broken C code
19:46:48 <merijn> I don't really like how IO heavy the vty API is, but it worked pretty okay for the obvious things I tried
19:46:52 <vanila> ok I built your app now :)
19:46:57 <nitrix> vanila: <3
19:46:59 <geekosaur> vty doesn't have the screen optimization stuff that ncurses does. This may not be a problem, if you write your code intelligently
19:47:00 <vanila> it works
19:47:01 <vanila> !
19:47:08 <vanila> but resize isn't being called?
19:47:10 <merijn> geekosaur: vty-ui has some optimisations
19:47:21 <geekosaur> (also ncurses' screen optimization has its own bugs)
19:47:29 <merijn> geekosaur: And you want to use vty-ui over vty directly anyway
19:47:34 <nitrix> vanila: It is being called, see there's a counter at the top left corner that increases every event you send (mouse click, resize, key input)
19:48:05 <nitrix> vanila: And when I resize the window, it does get incremented, I can tell, because when I send another event, it has increased by 2. But the moment you resize, the terminal goes blank.
19:48:15 <nitrix> vanila: It's not re-rendering and it puzzle me.
19:48:20 <vanila> hmm
19:48:36 <vanila> lets see what the docs say
19:48:42 <geekosaur> actually if you can see the number increasing then it *is* rerendering to some extent
19:48:59 <geekosaur> what it may not be doing is ... right
19:49:03 <nitrix> vanila: https://john-millikin.com/software/haskell-ncurses/reference/haskell-ncurses/latest/UI.NCurses/
19:49:08 <geekosaur> you need an erase call in there somewhere
19:49:22 <geekosaur> otherwise it's not removing the old contents before drawing the new
19:49:29 <nitrix> Oh, really?
19:49:41 <geekosaur> yes. (again, standard curses behavior)
19:50:16 <geekosaur> you might see if you can get your hands on some documentation on how to use curses (the C library) properly
19:50:29 <nitrix> I did before and clear wasn't necessary.
19:50:31 <vanila> curses is really horrible though
19:50:31 <geekosaur> it is idiosyncratic and can be quite strange
19:50:44 <geekosaur> clear and erase are different things in curses, btw
19:50:47 <nitrix> Lazy drawing is idiomatic for the ncurses C version to avoid redrawing the entire screen.
19:50:48 <vanila> is there a nice hakell native lib hat lets you do stuff like this?
19:50:55 <nitrix> I see.
19:51:01 <MP2E> vty
19:51:12 <nitrix> vanila: vty, but geekosaur said it had shortcommings D:
19:51:39 <geekosaur> specifically clear sets the "clear the whole screen" flag, erase just tells it to forget what was there and it'll clean things up without a forced clear-screen. for resizes you probably want the clear, but for normal updates this will cause lots of blinking
19:51:41 <merijn> nitrix: I haven't run into them and it's far easier and better to use than ncurses
19:51:46 <vanila> I've been experimenting with using xcb from haskell
19:51:47 <nitrix> Omg.
19:51:51 <vanila> but I can't figure out how to resizing
19:51:55 <nitrix> I think I want `setTouched True`
19:52:08 <vanila> nitrix, I tried that but it's Update so it gave a type error
19:52:13 <geekosaur> I would suggest here the correct thing to do is to set the clear flag on stdscr when you see the resize event, but that's one of the places where curses just gets bizarre
19:52:17 <merijn> nitrix: I would just check out the vty-ui demo's and see how well those work for you
19:52:17 <nitrix> The render only renders what changed, and since nothing technically changes, the render pass does nothing, it's drawing blank.
19:52:28 <geekosaur> wclrscr(stdscr, TRUE) in C
19:52:31 <nitrix> But if I do setTouched True, it would redraw the full window, according to the docs.
19:52:40 <geekosaur> yes, on a resize event you want that
19:52:45 <geekosaur> not on normal redraws
19:52:59 <yyttr3> Functor composition is what I think it would be called, if anyone knows any good resources?
19:53:15 <geekosaur> so you erase as part of the redraw (this is a non-clearscreen erase), but set the clear-screen flag on a resize event
19:53:27 <geekosaur> just one of those bizarre curses quirks
19:53:34 <geekosaur> and why you should poke at vty-ui instead
19:53:59 <geekosaur> you have to do a lot of weird stuff like that to get curses to behave like you would expect
19:55:22 <geekosaur> (werlcome to curses. antipsychotic not included...)
19:58:17 <yyttr3> How do I make an instance of functor for a [] wrapped in another type such a Maybe?
19:59:06 <geekosaur> another fun thing about curses is that multiple windows don't behave like you would sanely expect them to. *that* functionality was eventually added, as the panel library.
20:00:11 <nitrix> I'm surpised that even setTouched True doesn't fix my problem.
20:00:19 <nitrix> But oh well.
20:00:48 <geekosaur> all that does is modify the screen optimization stuff to be more thorough
20:00:58 <geekosaur> it won't do anything useful in this case
20:01:21 <enthropy> yyttr3: with a newtype (solution here: http://hackage.haskell.org/package/applicative-extras-0.1.8/docs/Control-Applicative-Compose.html)
20:01:30 <geekosaur> because curses' internals still do not know that anything has actually changed; it does not do anything with the resize event itself, you have to do it all
20:02:37 <yyttr3> Thank you! I was reading Control.Functor.Composition, but this looks even better!
20:03:03 <geekosaur> (part of the reason for this is that what happened to what was already on screen is undefined; some terminal emulators will redraw truncating, some will redraw wrapped, a few will just leave garbage)
20:03:35 <geekosaur> (curses has *no* way to find out which of these happened)
20:04:15 <nitrix> geekosaur: Tell me vty makes this easier?
20:04:30 <geekosaur> that would be why people have been telling you to use vty instead, yes :)
20:04:32 <nitrix> I don't remember having that much problems with ncurses in C.
20:04:38 <nitrix> Interesting.
20:04:51 <nitrix> Let me try vty then, brb :)
20:05:02 <merijn> nitrix: Go straight for vty-ui
20:05:08 <geekosaur> ncurses in C is even more frustrasting because often what happens is "correct" right up until it goes bizarre
20:05:11 <merijn> nitrix: It wraps vty with convenient editing/etc widgets
20:05:51 <nitrix> That sounds very useful.
20:05:55 <geekosaur> and then you tear your hair out before discovering that you had to do a bunch of other stuff to get *reliable* behavior instead of "usually works well enough if you don't sneeze at the wrong time"
20:06:36 <nitrix> Right.
20:06:45 <yyttr3> enthropy: Don't suppose there is a way to see Control.Applicative's source code?
20:07:01 <nitrix> Well, I suspect the vty-ui (if it is what I think it is) to leverage Haskell to its full potential.
20:07:08 <nitrix> It must be quite a nice library c:
20:07:33 <enthropy> yyttr3: from that page you can follow some links and end up at http://hackage.haskell.org/package/base-4.4.1.0/docs/src/Control-Applicative.html#Applicative
20:07:40 <geekosaur> and putting Haskell's laziness on top of ncurses is just begging to hit all the idiosyncratic behavior buried in it
20:08:19 <yyttr3> enthropy: Sorry! I didn't see the link. Thank you so much.
20:08:28 <geekosaur> (yes, even IO is lazy; it's just lazy in different ways, and interfacing curses' event loop with ghc's event loop introduces still more weirdness)
20:09:22 <nitrix> geekosaur: I think I'm convinced ;)
20:10:21 * hackagebot simple-pipe 0.0.0.11 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.11 (YoshikuniJujo)
20:14:44 <jle`> that green screen article was inspiring
20:14:55 <jle`> i'm going to make an android game now
20:15:21 <Fuuzetsu> ew
20:16:17 <lpvb> jle`: with haskell?
20:16:25 <jle`> lpvb: yes
20:16:30 <lpvb> does it work well
20:16:37 <lpvb> ghc?
20:16:40 <jle`> apparently so, according to that green screen article
20:17:24 <lpvb> this one?
20:17:25 <lpvb> http://keera.co.uk/blog/2014/08/13/most-inspiring-green-screen-you-will-ever-see/
20:17:27 <jle`> yea
20:17:28 <merijn> It works, I wouldn't say "well" yet :p
20:17:40 <merijn> Android support is still rudimentary/experimental/etc
20:17:48 <merijn> <3 TypedHoles
20:17:57 <lpvb> it's been that way for 4 years though :(
20:18:40 <jle`> why is that sad face
20:18:49 <jle`> oh, in reference to merijn
20:19:09 <jle`> i don't like when blog posts don't put in dates :|
20:19:22 <Fuuzetsu> that's cool, I might compile my game to it when I finish it in the next decade
20:21:46 <merijn> lpvb: Yes, because there's only like a handful of people working on android support, none of the paid for it
20:23:00 <merijn> edwardk: zoom only works if StateT is the outer transformer in the monad stack?
20:23:22 <edwardk> no
20:23:25 <johnw> byorgey: nice going with "labelled"; I always agonize over that decision
20:23:33 <edwardk> zoom in lens-family-core does
20:23:38 <edwardk> in lens it works anywhere
20:24:12 <merijn> edwardk: I was using lens, but now that I changed it to try again after your "no" it works, so clearly I messed something else up...
20:24:56 <edwardk> merijn: it doesn't work in an 'abstract' monad transformer stack, because it can't, but it works for pretty much any concrete choice of stack you pick
20:25:15 <edwardk> and it can work if you are 'concrete up to the type where you change out the index'
20:25:43 <merijn> Now I need to abduct Tekmo to tell me how I can compose a pipe on the bottom of a monad stack without running the entire thing...
20:27:54 <johnw> merijn: pipes aren't MFunctor's?
20:28:43 <merijn> johnw: They are, but the pipe is at the bottom so that doesn't matter now. I guess I can hoist a partially applied >->?
20:28:56 <johnw> that's what I'd try
20:30:34 <merijn> ooh, that works
20:30:51 <merijn> I wonder how terrible the performance of all my hoisting and monad stacking is gonna be...
20:31:46 <pjdelport> ~ hoist, hoist, hoist your pipe, gently up the stack... ~
20:32:05 <merijn> I'm secretly hoping that the sheer power of edwardk's and Tekmo's voodoo will result in GHC melting 90% of this code away into no-ops and it'll be blazingly fast, but I'm afraid it won't be :p
20:33:11 <Welkin> don't be afraid!
20:33:14 <Welkin> take this!
20:33:14 <Welkin> https://www.youtube.com/watch?v=wvUQcnfwUUM
20:35:24 * hackagebot infer-upstream 0.1.1.0 - Find the repository from where a given repo was forked  http://hackage.haskell.org/package/infer-upstream-0.1.1.0 (NoonSilk)
20:35:26 * hackagebot gsl-random 0.5.0 - Bindings the the GSL random number generation facilities.  http://hackage.haskell.org/package/gsl-random-0.5.0 (PatrickPerry)
20:35:41 <ij> Are there any cases where data doesn't come after functions in high-order functions?
20:35:58 <Welkin> what do you mean?
20:35:58 <ij> or maybe I can hoogle that
20:36:06 <Welkin> function application?
20:36:13 <ij> :t concatMap
20:36:14 <lambdabot> (a -> [b]) -> [a] -> [b]
20:36:20 <ij> function -> data -> data
20:36:23 <pjdelport> :t forM
20:36:23 <zwer> :t forM
20:36:24 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
20:36:24 <lambdabot> Monad m => [a] -> (a -> m b) -> m [b]
20:36:25 <Welkin> oh
20:36:29 <pjdelport> zwer: heh
20:36:32 <Welkin> :t (>>=)
20:36:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
20:36:34 <zwer> :)
20:36:47 <Welkin> it is arbitrary...
20:36:52 <pjdelport> ij: Lots, in other words.
20:36:54 <Welkin> it really doesn't matter
20:38:02 <ij> I guess it doesn't, considering flip exists.
20:38:08 * Welkin gives lambdabot a guitar
20:38:11 <Welkin> sing it with me!
20:40:24 * hackagebot peyotls 0.1.3.0 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.3.0 (YoshikuniJujo)
21:03:54 <augur_> @faq can haskell prove the continuum hypothesis?
21:03:55 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:03:58 <augur_> ugh
21:06:14 <Fuuzetsu> sadly that great feature was removed in favour of something boring ;(
21:10:28 * hackagebot PTQ 0.0.6 - An implementation of Montague's PTQ.  http://hackage.haskell.org/package/PTQ-0.0.6 (MasahiroSakai)
21:12:58 <ij> I hadn't thought of curry $ x . y to deliver 2 args to y and then one to x.
21:14:48 <vanila> :t \x y -> curry $ x . y
21:14:56 <lambdabot> (b1 -> c) -> ((a, b) -> b1) -> a -> b -> c
21:17:27 <ij> and y might be found with uncurrying a function, so perhaps curry $ x . flip y
21:20:00 <trap_exit> i wonder if the nick ijk is taken
21:20:31 <trap_exit> ij: you should make your alt ijk instead of ij_
21:25:49 <dibblego> what have I done in my source file such that I cannot refer to functions defined afterward?
21:25:54 <glguy> TH
21:25:58 <dibblego> I thought so
21:26:13 <ij> ij, Alt? Hmm, interesting idea.
21:40:14 <oisin876> Should I use Foreign.ForeignPtr instead of Foreign.Marshal.Alloc for allocating memory for OpenGLRaw?
21:43:18 <johnw> depends
21:43:25 <johnw> will OpenGL "own" the memory block and free it, or should you?
21:44:03 <oisin876> johnw: I will have to free it at some point - probably right before the end of the program
21:44:16 <oisin876> but I don't quite understand "own"?
21:44:36 <johnw> so, a ForeignPtr will free the memory block when it is garbage collected
21:44:46 <johnw> so if it's your responsibility to manage the block, you should use that
21:44:53 <johnw> own = the one who has to free it
21:45:56 <oisin876> Oh ok - and there's no concerns about when ForeignPtr frees it? Only if I'm super memory blocked should I use Foreign.Marshal?
21:47:05 <johnw> if you need deterministic freeing, you can always call finalizeForeignPtr
21:47:29 <oisin876> Awesome, that's very helpful. Thanks!
21:50:33 * hackagebot monte-carlo 0.6 - A monad and transformer for Monte Carlo calculations.  http://hackage.haskell.org/package/monte-carlo-0.6 (PatrickPerry)
22:04:41 <ij> I think I've lost a lot of time just wondering where were the parens put in case of ./>>= composition. Is there a way of finding out directly from ghc?
22:05:41 <platz> > :i (.)
22:05:43 <lambdabot>  <hint>:1:1: parse error on input ‚Äò:‚Äô
22:05:49 <platz> :i (.)
22:06:31 <Cale> (.) is infixr 9 which means it binds more tightly than any other operator
22:07:01 <Cale> (>>=) is infixl 1
22:07:08 <ij> Bigger numbers pull stronger. Got that will keep in mind, thanks.
22:07:13 <ij> Cool.
22:08:11 <dibblego> also remember that space (function application) binds even tighter, so (f x . g) binds as ((f x) . g)
22:09:13 <ij> :i ($)
22:09:53 <spopejoy> glguy: i rewrote your version of my function to understand the way [] bind employs foldr. http://lpaste.net/109415 . What is the motivation in general for using do on a list?
22:10:58 <merijn> ij: lambdabot doesn't support :i
22:11:31 <merijn> ij: Note that function application has fixity 10 (i.e. higher than any operator) and record updates have fixity 11 (higher than function application)
22:11:34 <glguy> You use it when you want nice syntax for concatMap
22:11:58 <glguy> List works like a backtracking/multiple outcome computation
22:12:17 <lfairy> oh yes, the fixity of record updates is surprising, but quite nice sometimes
22:12:17 <spopejoy> interesting
22:12:32 <lfairy> especially for passing options
22:13:02 <lfairy> e.g. httpRequest defaultRequest { url = ... }
22:13:41 <spopejoy> i miss ‚Äòwhere‚Äô in do LHSs though
22:13:51 <ij> I am having such a hard time imagining types of so many things.
22:14:08 <spopejoy> sorry RHSs
22:14:19 <lfairy> ij: what do you mean?
22:16:18 <ij> lfairy, I'm trying to write a sudoku solver and I'm trying to find all the deterministic choices before backtracking. And it involves functions that operate on something like Board (Pos, Line Int) -> something else.
22:16:31 <ij> It's hard for me to penetrate type errors when dealing with such functions.
22:16:54 <lfairy> ij: oh, ok
22:17:23 <lfairy> what I tend to do is split the problem into really small pieces
22:17:31 <lfairy> then put explicit type signatures on every piece
22:18:23 <lfairy> ij: is there a particular type error you're having trouble with?
22:20:02 <ReinH> ij: have you seen Richard Bird's sudoku solver? It's awesome.
22:20:08 <ij> Not anymore, just slowly decrypting piece by piece. I'm just very slow.
22:20:55 <ij> ReinH, Nope, what is awesome about it?
22:23:48 <merijn> Man, I don't know who was responsible for implementing a hdevtools patch that makes it support cabal files, but I <3 this person
22:31:09 <c_wraith> ij: Bird's sudoku solver isn't just an implementation - it's a series of implementations, each one a minor refinement over the previous, with a good explanation of what's going on.  And the final state is quite fast.
22:32:57 <ij> Is it silly that I'm hiding it from myself so that I would finish and write mine?
22:33:03 <ij> finish writing*
22:33:07 <c_wraith> not really. :)
22:36:09 <megajosh2> I've  been trying to figure out since yesterday why hGetContents blocks on line 29 until the handle closes https://gist.github.com/joshtwo/f14b78e2560dc1d295fd
22:36:24 <megajosh2> I've tried a lot of different things to try and get around the blocking but nothing works
22:37:02 <megajosh2> I have the output of the program there showing what the separate threads are doing; does anybody know what I can do to fix this
22:37:06 <megajosh2> ?
22:37:23 <c_wraith> megajosh2: hGetContents returns the *whole* contents.  If that's not what you want, don't use hGetContents
22:39:07 <megajosh2> ... oh, I see what you mean
22:39:23 <megajosh2> It's been so long since I've written any Haskell and I'm forgetting how I usually did this
22:39:51 <c_wraith> megajosh2: The quick'n'dirty fix would be switching to lazy bytestrings.
22:40:03 <megajosh2> I was using lazy bytestrings
22:40:06 <megajosh2> It still blocked
22:40:22 <megajosh2> It's just that it returned part of the packet it ultimately spits out once the handle closes
22:40:32 <megajosh2> Still waited for the rest, though
22:42:09 <megajosh2> Alright, I got it, thanks
