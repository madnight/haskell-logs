00:02:00 <lfairy> zRecursive: I think your tarballs got corrupted
00:02:20 <zRecursive> i see, but why ?
00:02:40 <zRecursive> i just run `cabal install cabal-install`
00:03:01 <lfairy> probably some bits got flipped on the wire
00:03:18 <zRecursive> weird problem
00:03:20 <lfairy> nuke ~/.cabal and start over, no biggie
00:03:59 <zRecursive> i have repeated several times
00:04:29 <c_wraith> In that case, I'd be suspicious of your networking hardware.  Some of it repeatedly corrupts specific patterns.
00:08:10 <zRecursive> `cabal update` => Config file path source is default config file. Config file ~/.cabal/config not found. \nWriting default configuration to ~/.cabal/config  \nDownloading the latest package list from hackage.haskell.org   \ncabal-install: openTCPConnection: host lookup failure for "hackage.haskell.org"
00:08:54 * hackagebot PartialTypeSignatures 0.1.0.1 - emulate partial type signatures with template haskell  http://hackage.haskell.org/package/PartialTypeSignatures-0.1.0.1 (AdamVogt)
00:08:54 * hackagebot criterion 1.0.0.2 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-1.0.0.2 (BryanOSullivan)
00:20:11 <adas> is it okay to do "cabal install yesod-bin yesod-platform ghc-mod". what happens if there is a common dependency between all of them and different versions of the common dependency are needed?
00:20:22 <trap_exit> http://web.archive.org/web/20100703060856/http://www.haskell.org/bz/thdoc.htm is so brilliant
00:20:22 <trap_exit> espeically the ast two examples
00:20:31 <trap_exit> I can feel my power level increasing
00:20:44 <joelteon> adas: cabal's solver will make sure it doesn't happen
00:20:57 <trap_exit> adas: that is a good question; I have often wondere about it; if you resolve it, please ping me so I can know the answer too :-)
00:21:13 <trap_exit> joelteon: oh, so is cabal is like foo wants cat 2.0, bar wants cat 3.0, unable to install ?
00:21:17 <joelteon> yeah
00:21:28 <c_wraith> when you specify multiple things to cabal at once, it solves all of their dependencies together
00:21:44 <c_wraith> Or fails to.
00:22:18 <c_wraith> It won't do anything unless it can solve them all together.  I find that to be a really helpful tool for investigating what makes things break.
00:23:07 <trap_exit> damn it, does cabal get anything wrong?
00:23:16 <joelteon> it gets plenty wrong
00:24:12 <trap_exit> heresy!
00:24:13 <trap_exit> @where ops
00:24:14 <lambdabot> arjanb bos byorgey Cale conal copumpkin dcoutts dibblego dmhouse dolio dons edwardk elliott geekosaur glguy Heffalump Igloo jmcarthur johnw kosmikus Lemmih monochrom nyc Philippa Pseudonym quicksilver roconnor Saizan shachaf shapr sjanssen ski sorear SyntaxPolice xerox
00:24:32 <johnw> do you need an op?
00:24:40 <shachaf> Huh?
00:24:42 <trap_exit> no sorry, was meant as a joke
00:24:44 <trap_exit> probably a bad joke
00:24:49 <merijn> Pretty rude joke...
00:24:49 * trap_exit hides from crying wolf
00:24:57 <johnw> yes, please do not do that :)
00:24:59 <shachaf> trap_exit: Please do not cry wolf.
00:25:03 <tabemann> http://lpaste.net/109111
00:25:13 <shachaf> Using @where ops alerts a lot of people.
00:25:14 <trap_exit> in retrospect, yes, I apologize
00:25:24 <pavonia> @where wolf
00:25:25 <lambdabot> AROOOOOO!
00:25:31 <trap_exit> it will not happen again
00:25:35 <johnw> thank you
00:25:53 <Iceland_jack> Isn't that the headless body of Agnew?
00:26:06 <Iceland_jack> No, I'm thinking of Nixon!
00:26:17 <tabemann> does anyone know why configCompilerEx isn't available?
00:26:40 <tabemann> is it something about my system having GHC 7.6.3 and the packages being written for GHC 7.8.3?
00:26:43 <johnw> I'm guessing you changed the version of Cabal you're linking with
00:28:05 <tabemann> weird
00:28:18 <tabemann> root@kryogenik:/home/tabemann# cabal --version
00:28:18 <tabemann> cabal-install version 1.20.0.2
00:28:18 <tabemann> using version 1.20.0.1 of the Cabal library
00:29:31 <johnw> that's the version of Cabal being used by your cabal-install
00:29:37 <johnw> not by the Setup.hs in glib
00:29:44 <johnw> or SetupWrapper.hs, apparently
00:30:06 <tabemann> I just did a full uninstall of GHC and everything followed by a full reinstall, just to make sure I was using a consistent set of packages
00:30:32 <johnw> I'd say glib needs to be updated
00:30:41 <johnw> they are relying on a Cabal feature which has disappeared
00:31:59 <tabemann> I'm not even using a particularly up-to-date GHC
00:37:14 <tabemann> I figured it out
00:37:38 <tabemann> it's not that gtk is too old, but that my cabal, the cabal installed with Debian, is not new enough
00:38:17 <tabemann> wait, maybe not
00:41:21 <adas> im trying to install yesod. got an error saying could not find "zlib.h". search ubuntu package repo for the package to install to get that library. i get multiple candidates. which zlib package should I install?
00:42:26 <adas> there libcrypto++-dev libtagcoll2-dev thunderbird-dev  zlib1g-dev
00:42:36 <adas> all of them provide "zlib.h"
00:42:44 <johnw> zlib1g
00:43:13 <adas> johnw: thakns.
00:43:17 <Iceland_jack> You'll want zlib1g-dev I think
00:43:43 <Iceland_jack> first result is in Japanese
00:43:43 <Iceland_jack> @google "zlib.h" Yesod
00:43:45 <lambdabot> http://d.hatena.ne.jp/yoya/20120429/yesod
00:43:45 <lambdabot> Title: Debian6 �� yesod �򥤥󥹥ȡ��� - yoya�Υ��
00:45:38 <adas> japanese folks love haskell
00:45:55 <adas> i mean japanese programmers
00:46:11 <Iceland_jack> It would be a bit weird if non-programmers loved it
00:47:25 <adas> won't be weird..but there will be a lot of competition for the few haskell jobs available
01:07:02 <solatis> does anyone here actually use literate haskell?
01:07:56 <solatis> i'm a bit in doubt whether to use it or not
01:12:42 <dfeuer> solarus, it seems not to be so popular these days.
01:13:49 <tabemann> ever since it was taken over my oracle
01:24:34 <chrisdone> Twey: http://www.reddit.com/r/haskell/comments/2d1dpg/%CE%BB_lessons_pattern_matching_firstclass_functions/
01:40:39 <tabemann> okay, that's not right
01:42:23 <tabemann> how do you build the haskell platform with GHC 7.8.3?
01:44:19 <tabemann> okay, cabal comes with GHC and not the haskell platform, so I guess I don't need the haskell platform
01:48:58 * hackagebot glib 0.13.0.1 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.13.0.1 (HamishMackenzie)
01:49:45 <solatis> is it correct that building your application for profiling using cabal currently is a PITA?
01:49:58 <solatis> i keep getting errors that my dependencies aren't built for profiling
01:50:42 <solatis> these kind of errors:
01:51:12 <solatis> Perhaps you haven't installed the profiling libraries for package `xyz`
01:51:23 <pavonia> Yeah, all packages have to be built for profiling
01:51:30 <solatis> how do i do that?
01:53:23 <solatis> cabal install --reinstall doesn't seem to rebuild my deps
01:53:53 <joelteon> remove all your packages and start again
01:54:02 <solatis> k
01:54:27 <pavonia> But make sure to enable profiling in your .cabal file before doing that
01:54:47 <solatis> yeah i've enabled them in ~/.cabal/config also
01:55:33 <pavonia> Err yes, that's what I meant
01:55:46 <d-snp> hey merijn, I'm about half way there, am I on a good path? http://lpaste.net/109090
01:56:06 <pavonia> Someone linked an article about that recently but I can't find it right now
01:56:19 <solatis> hmmm... 'remove all your packages'  == rm -rf ~/.cabal/packages/ ?
01:56:30 <solatis> or is there some more official way?
01:57:35 <tabemann> I'd say more like rm -rf ~/.cabal
01:57:38 <solatis> :)
01:57:45 <solatis> not via ghc-pkg ?
01:58:18 <tabemann> but make sure you save your ~/.cabal/config first
01:58:36 <solatis> ya
01:58:39 <solatis> ok
01:58:41 <solatis> will do that
01:59:30 <tabemann> afterwards, create a directory named ~/.cabal and put your modified ~/.cabal/config, with profiling enabled
01:59:33 <tabemann> *in it
01:59:43 <adas> i did a yesod dry run install and i got the message that "wai-logger-2.2.1" will likely break if i continue with the installation. what options do i have?
01:59:59 <solatis> tabemann: i was ahead of you, already did that
02:00:38 <annelies> good morning :3
02:01:04 * tabemann wishes the haskell platform would compile with GHC 7.8.3, so he would not have to reconstruct what goes into the haskell platform piecemeal via cabal dependencies
02:01:35 <adas> anyone?
02:01:41 <adas> hints
02:02:23 <d-snp> adas: I'd continue and see what happens
02:03:47 <adas> yup. thats one option.
02:06:21 <pavonia> Where do you find cabal's "world file"?
02:06:28 <solatis> ok rm -rf ~/.ghc was also required
02:10:17 <annelies> Are bounded chans commonly used for communicating between threads? I liked this approach in Go but maybe MVar or IORef are more idiomatic in Haskell?
02:10:53 <annelies> I think they have different use cases though.
02:11:10 <annelies> Unless you can register a callback on an MVar/IORef mutation
02:12:06 <lfairy> annelies: MVar is a bounded channel of length 1
02:12:19 <lfairy> IORef is just a mutable variable. No concurrency.
02:13:09 <annelies> Oh, I see.
02:13:30 <trap_exit> annelies !
02:13:36 <annelies> Why is Chan from base unbounded?
02:13:43 <annelies> Unbounded channels don’t seem very useful.
02:13:46 <lfairy> beats me :\
02:13:58 <trap_exit> they're difficult to read about
02:14:15 <trap_exit> hmm
02:14:24 <trap_exit> I be tunbounded chan makes performance independent of scheduling
02:14:29 <slack1256> I see lazy bytestrings subdumed by streaming frameworks (as pipes).
02:14:34 <pharaun> unbound channels is good for protypes where i don't worry about the length
02:14:39 <pharaun> and just dump things to a queue to be chewed on
02:14:46 <slack1256> Any idea of a problem that needs of lazy bytestrings instead of a streaming framework?
02:14:50 <pharaun> i usually eventually qualify and put a reasonable bound on them
02:15:23 <slack1256> annelies: see pipes-concurrency for bounded channels
02:15:35 <annelies> Oh, I just installed BoundedChannel
02:15:42 <annelies> BoundedChan*
02:16:27 <luite> chrisdone: lambda lessons looks quite cool, but unfortunately without sharing it doesn't show you how haskell works
02:17:18 <annelies> which reminds me
02:17:24 <annelies> I should read the CSP paper again.
02:17:41 <trap_exit> https://gist.github.com/anonymous/c7d51a25c8eea6896b60
02:17:45 <trap_exit> wtf does parse do?
02:17:49 <d-snp> annelies: what is idiomatic haskell for concurrency actually changes a lot, especially in recent years
02:17:56 <d-snp> also depending on who you ask :P
02:18:19 <raichoo> annelies: What paper do you mean?
02:18:29 <annelies> _Communicating Sequential Processes_
02:18:42 <raichoo> Ah thanks :)
02:20:31 <annelies> I wonder whether there’s a Promise-based channel library for Node.js. JS is the only language in which I ever get stuff done. XD
02:22:18 <gauthier> solving a small puzzle, looking for feedback on the form and maybe search algorithm itself: https://bitbucket.org/gauthier/haskell-playground/src/5884d57aa9c86af25e344c887a71c33102016c78/Playground/Puzzles/ShiftedSortedArraySearch.hs need to find index where the sorted array has been shifted
02:22:37 <chrisdone> luite: where in the haskell report is sharing specified?
02:24:40 <trap_exit> damn this code is awesome
02:27:19 <Darwin226> Hey guys. I've got a question about dealing with random generatort
02:27:44 <slack1256> ask :-)
02:27:51 <chrisdone> darwin226: and you're not afraid to use it!
02:28:57 <Darwin226> Having all my functions take a random generator is a slight pain but not really an issue, but having them all return a new generator as a pair with their usual result is a slightly bigger issue. Now, I've noticed that System.Random has split. My question is, would it be ok if those function just didn't return a new generator and
02:29:04 <trap_exit> StateT monad
02:29:28 <Darwin226> that the called is expected to split their generator and give the function a generator they can just throw away after they're done?
02:29:31 <slack1256> Couldn't the lazy bytestring used on the Gzip package be replaced by a pipe consumer?
02:29:32 <trap_exit> also, your question got chopped off at "return a new generator and <chopped off>"
02:29:53 <Darwin226> trap_exit: I chopped it off myself :D
02:30:03 <trap_exit> glguy_ : so I'm a retard and lost that gist post you sent me
02:30:13 <trap_exit> glguy_ : would you by any chance have that 70+ lines of template haskell magic ?
02:31:12 <chrisdone> trap_exit: http://ircbrowse.net/day/haskell/today?id=18778131&timestamp=1407564262#t1407564262
02:31:14 <slack1256> Darwin226: You are supposed to thread the returned generator and use it the next random function.
02:31:23 <trap_exit> chrisdone: ah, nice, thanks!
02:31:29 <chrisdone> =)
02:31:40 <trap_exit> I'm retarded for forgeting that #haskell is logged :-)
02:31:49 <trap_exit> and good job realizing that by 'gist' I meant lpaste
02:31:51 <slack1256> basically it boils down to use the State monad to do the threading
02:32:16 <Darwin226> slack1256: Well, if I split it before passing it to the function then I can just use the first one for this function and the second one for the rest
02:32:32 <trap_exit> Darwin226: see http://book.realworldhaskell.org/read/monads.html .. search for "random"
02:33:43 <slack1256> Yes you can do that. But do you really gain anything like that? seems more annoyance just for the pleasure of it
02:34:27 <Darwin226> slack1256: Yeah, now that I think about it, this would just mean I have to use an extra line of code before a function call just to get a new generator...
02:34:51 <Darwin226> I'll read the RWH link
02:34:53 <Darwin226> Thanks guys
02:35:14 <slack1256> Not only that, you have to manually handle different generators and know who is who (because they have the same type).
02:37:02 <Darwin226> How long do you have to use Haskell, on average, before your mindset changes from "Oh god, I have to use monads" to "Oh good, there's a monad for that"?
02:38:05 <slack1256> Depends, I usually find the easiest way to make that change is obligate to somebody to threading manually (Maybe a) between 8 function application
02:38:20 <slack1256> by the time they hit the 6 they will be begging for using a monad
02:38:32 <trap_exit> hmm, about 2 weeks
02:38:51 <trap_exit> actually, about the time I stopped reading dumbass monad tutorials, started reading just the monad types
02:39:23 <slack1256> Darwin226: But hey, #haskell is your friend, if you need help just come by and we will play with lambdabot
02:40:30 <trap_exit> I found the best way to learn monads as was as folows:
02:40:31 <trap_exit> 1) ignore monads
02:40:43 <trap_exit> 2) write code with crap tons os repetition / arguments being passed all over he place / complicated logic
02:40:51 <trap_exit> 3) realize ... damn, I bet there's a way to use >>= to combine steps
02:40:57 <trap_exit> 4) a-ha! I like monads
02:41:07 <slack1256> 2 - 3 is crucial
02:41:17 <lfairy> that sounds right
02:41:29 <lfairy> abstraction usually makes no sense until you need it
02:41:31 <chrisdone> Darwin226: i recommend ignoring everyone's advice and learning how you like to learn
02:42:18 <slack1256> sure, why teach when you can drown yourself on monads tutorials
02:42:43 <chrisdone> slack1256: that would be taking advice ;)
02:43:25 <slack1256> Well, if somebody got the time to write those "monads are burritos" somebody need to read them too!
02:43:46 <trap_exit> monadtransformer are like russian dolls
02:43:50 <trap_exit> you can wrap one within the other
02:44:29 <trap_exit> ### can someone pls help me get https://gist.github.com/anonymous/0f1af1074e1d6fc65830 from http://web.archive.org/web/20100703060856/http://www.haskell.org/bz/thdoc.htm to actually compile ????
02:44:58 <luite> chrisdone: i'm not sure it's relevant that the report allows reduction strategies that do not share if you want to teach people to reason about performance in actual running code. for other properties, like termination, it might be ok, but it'd be akin to using unary representation and peano arithmetic for teaching about performance in numerical code
02:46:33 <slack1256> has there ever been a haskell compiler with call by name?
02:51:41 <erikd> slack1256: you mean strict evaluation rather than lazy evaluation?
02:52:02 <slack1256> I thought call by name was lazy evaluation without sharing
02:54:14 <luite> oh looks like chrisdone left while i was typing that :(
02:54:41 <erikd> slack1256: you're right. no idea then.
02:55:36 <trap_exit> i have a serious question
02:55:46 <trap_exit> why do we need ghc.generics if we already have things like template haskell
02:58:16 <slack1256> trap_exit: I could explain what is cool about them but I wouldn't be able to do it better than Stephen http://dev.stephendiehl.com/hask/#generics
02:58:53 <slack1256> summary: you can use it do decompose a data type in a sum of products and recursion and build automatically instances for types.
02:59:41 <trap_exit> slackl256: who is this stephendiel guy
02:59:43 <trap_exit> does he hang out here?
03:02:19 <slack1256> IDK maybe
03:10:46 <luite> slack1256: you can do that in TH too though (perhaps not everything, i haven't tried) by reifying the type and getting the datacons from the declaration.
03:37:50 <pyed> noob question:  I got a function ( f :: Int -> Int) I want to make infinite list of calling f on it's result
03:38:03 <shachaf> :t iterate
03:38:04 <lambdabot> (a -> a) -> a -> [a]
03:38:56 <pyed> hallelujah, thanks shachaf
03:39:44 <corgifex> :t iterate <*> fix
03:39:45 <lambdabot> (a -> a) -> [a]
03:39:48 <trap_exit> damn it ... in http://lpaste.net/109107 ... how do I call makeUpdaters
03:40:10 <shachaf> :t repeat . fix
03:40:11 <lambdabot> (b -> b) -> [b]
03:40:38 <corgifex> that's for b -> b but my function has type a -> a
03:41:23 <annelies> Who thought it was a good idea to put full paths to dylibs in executables.
03:44:08 * hackagebot compdata 0.8.1.3 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.8.1.3 (PatrickBahr)
03:45:24 <p0a> http://www.haskell.org/haskellwiki/Learning_Haskell#Textbooks third link is wrong...
03:45:40 <p0a> Points to a book not relevant to haskell
03:47:06 <corgifex> what do you have against Aqueous Environmental Geochemistry
03:47:18 <p0a> lol
03:47:29 <p0a> what do you have for it? :P
03:47:52 <trap_exit> glguy: your code now works for me, thanks!
03:50:14 <p0a> my uni library has no books on haskell :S
03:52:23 <MagneticDuck> how many does it have on Java
03:53:04 <p0a> 174 records. not all relevant of course
03:55:54 <lwm> hey, anyone worked through 'write yourself a scheme' ?
03:56:03 <lwm> I am trying to clear up the following line in my head
03:56:09 <lwm> tail <- char '.' >> spaces >> parseExpr
03:56:26 <trap_exit_> luite: (I got disconnected): ghcjs you pay once per module" <-- is this in existing ghcjs, or what you're currently working on?
03:56:35 <trap_exit_> luite: oops, wrong channel, repasting in ghcjs
03:57:14 <trap_exit_> lwm: is this by Jonathan Tang ?
03:57:51 <lwm> trap_exit_: yeah, that's the one
03:58:37 <lwm> I just need an intuition on what the '>>' is doing here ... to me it looks like composition
03:59:09 * hackagebot parallel-tasks 4.0.1.0 -   http://hackage.haskell.org/package/parallel-tasks-4.0.1.0 (NeilBrown)
03:59:45 <aarvar> :t (>>)
03:59:46 <lambdabot> Monad m => m a -> m b -> m b
03:59:54 <shachaf> a >> b means "a then b"
04:00:04 <shachaf> It's the same as do { a; b }, if you've seen that.
04:00:40 <lwm> ah, sequencing, right
04:01:26 <freeman42> could someone explain this please? https://twitter.com/dibblego/status/497987983086088193 ,  http://i.imgur.com/WfyF1sq.png
04:04:10 * hackagebot alloy 1.2.1 - Generic programming library  http://hackage.haskell.org/package/alloy-1.2.1 (NeilBrown)
04:05:35 <xpika> does purescript have anything to do with http://en.wikipedia.org/wiki/Pure_%28programming_language%29
04:05:38 <xpika> ?
04:06:18 <p0a> freeman42, sure
04:06:56 <p0a> freeman42, when you think of composition in haskell, the very first type in the type signature is the domain and the rest is the codomain (of the function to be composed). So let's look at :t foldl
04:07:00 <p0a> :t foldl
04:07:01 <lambdabot> (b -> a -> b) -> b -> [a] -> b
04:07:35 <freeman42> thank you, all ears(eyes)
04:08:15 <p0a> Okay so when composed to itself, this is what happens: First, it takes an argument of type (b -> a -> b) and returns b -> [a] -> b. Now, name a' = [a]. Then the second foldl takes an argument of type (b -> a' -> b) as returned by the first foldl, and returns an argument of type b->[a']->b
04:08:17 <d-snp> xpika: there's no side effects anywhere in the documentation :|
04:08:30 <p0a> If you replace a' with [a], you'll see the resulting type signature is (b->a->b)->b->[[a]]->b
04:09:57 <p0a> freeman42, usually, in reading types, we think of all the types as argumetns and the type after the last arrow -> as the return value type
04:10:15 <p0a> freeman42, and in most programming languages, that's how composition works. I.e. in C, you'd have g(f(x,y))
04:10:46 <ion> > ((foldr . flip) . (foldr . flip) . flip) (:) [] ["hello", " ", "world"]
04:10:49 <lambdabot>  "hello world"
04:10:56 <p0a> But in Haskell, composition works in another way: You always compose functions of one argument. It's the codomain that is important
04:11:08 <p0a> that of course happens because of currying
04:11:37 <p0a> I hope I made some sense
04:11:59 <freeman42> p0a, interesting :) now I understood why all the []
04:12:15 <p0a> > ((foldr . flip) . (foldr . flip) . flip) (:) ["_"] ["hello", " ", "world"]
04:12:17 <lambdabot>  Couldn't match type ‘GHC.Types.Char’ with ‘[GHC.Types.Char]’
04:12:17 <lambdabot>  Expected type: [[GHC.Types.Char]]
04:12:17 <lambdabot>    Actual type: [GHC.Types.Char]Couldn't match type ‘GHC.Types.Char’ with ‘[G...
04:12:17 <lambdabot>  Expected type: [[GHC.Types.Char]]
04:12:17 <lambdabot>    Actual type: [GHC.Types.Char]Couldn't match type ‘GHC.Types.Char’ with ‘[G...
04:12:22 <p0a> oops... sorry
04:12:56 <freeman42> but what meaning would it have? composing 2 foldl ? I did not get the transducer part
04:14:33 <p0a> Try it out. As for what a transducer is, I've no idea
04:14:54 <aarvar> apparently transducer is a word that rich hickey just made up
04:15:49 <d-snp> transducers are a feature that got added to clojure last week
04:16:03 <d-snp> iirc it was a higher level fold or something
04:16:21 <d-snp> http://blog.cognitect.com/blog/2014/8/6/transducers-are-coming
04:16:26 <aarvar> looked it up and it appears to be a function of the form a -> b -> a
04:16:29 <freeman42> so, it could fold a 2D list? like... sum all the elements in the 2D list?
04:16:45 <aarvar> in other words, a fold
04:16:49 <d-snp> I eh.. don't think so
04:17:07 <d-snp> folding a 2d list is just 2 folds in a row
04:17:08 <aarvar> oh wait nevermind
04:17:16 <aarvar> he calls that a reducing function
04:17:37 <aarvar> a transudcer is a function from a reducing function to a reducing function
04:17:58 <aarvar> this sounds like a lot of made up semtantics to make something seem novel
04:18:10 <d-snp> yes, the idea is you can compose your reductors
04:19:04 <d-snp> I think..
04:19:22 <c3l> Why does http://hackage.haskell.org/package/base-4.7.0.1/docs/src/GHC-Base.html#foldr define the function 'go' rather than the code in the two comment lines directly after the type declaration of foldr?
04:20:09 <aarvar> isn't x -> a -> x equivalent to [a]?
04:21:19 <shachaf> c3l: For better inlining behavior.
04:22:35 <benjumanji> aarvar: not quite. The church encoding of a list is more like forall x. (a -> x -> x) -> x -> x
04:22:41 <benjumanji> as in you need something for nil
04:22:44 <benjumanji> not just cons
04:23:12 <shachaf> (forall x. (a -> x -> x) -> x) is also a very different thing from (x -> a -> x)
04:23:17 <p0a> aarvar, maybe I'm not understanding the context of your question, but how could that be possible?
04:23:27 <benjumanji> true that.
04:23:37 <aarvar> er, x -> a -> x as in foldr I guess
04:24:33 <benmachine> aarvar: in what sense equivalent? what do you translate [] into?
04:24:36 <d-snp> man I'm having real difficulty making MyStateT a monad instance..
04:24:47 <shachaf> For that matter, what is x?
04:24:56 <benmachine> d-snp: can you do the non-transformer version?
04:25:09 <d-snp> benmachine: yes, though it was real ugly
04:25:11 <shachaf> benmachine: I finally figured out that benjumanji wasn't you and now you show up.
04:25:12 <aarvar> [] would be a function, nil x a = x
04:25:27 <benmachine> shachaf: :P sorry I'm late?
04:25:34 <benjumanji> too many bens.
04:25:53 <benmachine> oh man, that reminds me, I need to tell my employer my name is not benjamin
04:25:55 <d-snp> benmachine: http://lpaste.net/109117 this is where I'm at
04:25:56 <benmachine> people assume things :(
04:26:58 <benmachine> d-snp: your life will possibly get easier if you write runState :: State s a -> s -> (a,s)
04:27:08 <shachaf> It's Benmachine, right?
04:27:14 <cin> also shachaf Ben-kiki =p
04:27:29 <aarvar> I was just looking at this https://twitter.com/richhickey/status/497098126709506049
04:27:33 <benmachine> shachaf: right
04:27:35 <corgifex> bensonmum
04:27:41 <d-snp> benmachine: thanks, I'll try that
04:27:41 <mmmm> Is there a function like fmap for Fix (f a -> g a) -> Fix f -> Fix g ?
04:27:49 <mmmm> probably not the right types
04:28:18 <benmachine> aarvar: oh, that's weird
04:28:44 <shachaf> You mean something like foo :: (Functor f, Functor g) => (forall a. f a -> g a) -> Fix f -> Fix g?
04:29:02 <mmmm> ye
04:29:31 <benmachine> d-snp: also, I seriously suspect your monad for State is wrong, have you tested it?
04:29:37 <aarvar> I think these "transducers" are just foldr closures?
04:29:57 <c3l> shachaf, oh - I had not encountered this concept before, some googling explained it. thanks
04:30:56 <benjumanji> arvar: http://conscientiousprogrammer.com/blog/2014/08/07/understanding-cloure-transducers-through-types/
04:31:01 <benjumanji> did you see this via reddit?
04:31:12 <benjumanji> it is the best discussion on transducers I have seen so far
04:31:17 <shachaf> mmmm: You can write it easily enough, with a Functor constraint on either f or g.
04:31:19 <benjumanji> plus osme commentary by mr hickey at the bottom
04:31:34 <benjumanji> some*
04:32:02 <shachaf> mmmm: Fix is a functor from the category of Hask endofunctors to Hask.
04:32:19 <shachaf> I don't know if it's in any standard library, if that's what you mean. Maybe it's in whatever library you're getting Fix from.
04:32:27 <nickolay> hi! can someone tell me why is there no tuple comprehensions in haskell?
04:32:36 <shachaf> What would they do?
04:32:54 <mmmm> shachaf: Yes I didn't want to reinvent the wheel but I haven't been able to find it in fixplate or recursion-schemes
04:34:41 <benjumanji> hmap lives in unification-fd
04:34:50 <benjumanji> hmap :: (Functor f, Functor g) => (forall a. f a -> g a) -> Fix f -> Fix g
04:40:40 <mmmm> perfect thanks benjumanji
04:45:28 <d-snp> benmachine: I haven't tested it, I'm not even sure what it's supposed to do, just satisfying the typesystem :D
04:45:46 <benmachine> d-snp: ah, that doesn't work
04:45:55 <benmachine> there is more than one implementation of bind
04:46:01 <benmachine> that is type-correct
04:46:15 <benmachine> at least three that I'm aware of
04:51:03 <d-snp> benmachine: tbh I'm still unclear about why State wraps a function, is the idea like the I/O monad so that the functions nest and you get a nice sequencing?
04:52:19 <benmachine> d-snp: it's much simpler than that
04:54:02 <benmachine> d-snp: State s a is basically "something that produces an a dependent on some state s, which it might also return an updated value of"
04:54:25 <benmachine> *something that produces a value of type a, dependent on some state of type s
04:54:50 <benmachine> one common example is parsing things, where your state is your unconsumed input
04:55:09 <benmachine> you want to read the unconsumed input, produce an output, but also consume some of the input
04:55:21 <benmachine> you do that by also returning the remaining unconsumed input
04:55:36 <benmachine> so that other parsing functions can use it
04:56:47 <d-snp> ah
04:57:28 <zwer> another example is a random function. you could return a random value while updating the current RandomGen instead of passing the gen around explicitly like System.Random does
04:57:54 <benmachine> right, yeah, functions like "random" are exactly of this shape
04:57:55 <benmachine> :t random
04:57:56 <lambdabot> (Random a, RandomGen g) => g -> (a, g)
04:58:08 <benmachine> take a seed, return a value and the new seed
05:00:38 <trap_exit> luite: is what off by a factor of 10 ?
05:04:20 <ion> 420
05:15:08 <thrakcattack> @source print
05:15:08 <lambdabot> Unknown command, try @list
05:15:11 <thrakcattack> @list
05:15:12 <lambdabot> What module?  Try @listmodules for some ideas.
05:15:27 <thrakcattack> @listmodules
05:15:27 <lambdabot> activity base bf check compose dice dict djinn dummy elite eval filter free fresh haddock help hoogle instances irc karma localtime more oeis offlineRC pl pointful poll pretty quote search slap source spell system tell ticker todo topic type undo unlambda unmtl version where
05:17:36 <dario> hey guys
05:18:13 <dario> there's hs-nacl, salt (both thoughtpolice's github) and saltine.. which one to use?
05:29:20 * hackagebot twitter-conduit 0.0.5.5 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.5 (TakahiroHimura)
05:31:02 <xpika> how do you pronounce (<*>) ?
05:31:56 <pyon> xpika: ap
05:32:33 <xpika> pyon: ok
05:33:03 <friden> some one knows a nice way to get [(1,4),(1,5),(1,6),(2,4),(2.5),(2.6)] from [1,2] and [4,5,6]?
05:33:22 <xpika> ap is sort of like zipwith
05:34:08 <d-snp> friden: it's called a carthesian product
05:34:09 <pyon> > zip [1,2] [4,5,6]
05:34:11 <lambdabot>  [(1,4),(2,5)]
05:34:18 <pyon> errr
05:34:35 <pyon> > (,) <$> [1,2] <*> [4,5,6]
05:34:37 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6)]
05:34:38 <friden> d-snp: yeah, but is there a nice function for that?^
05:34:55 <friden> pyon: whoa
05:35:00 <d-snp> for some weird coincidence it's exactly the function xpika just asked about..
05:35:33 <friden> im quite new to haskell, that is quite magic for me pyon xd
05:35:48 <d-snp> :t <*>
05:35:50 <lambdabot> parse error on input ‘<*>’
05:35:54 <d-snp> :t (<*>)
05:35:55 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:36:04 <friden> i see that it gives the right result, but is there another way that is easier to understand by someone new?^^
05:36:08 <pyon> > [(x,y) | x <- [1,2] , y <- [4,5,6]]
05:36:10 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6)]
05:36:16 <friden> oh, i should have thought of that
05:36:21 <friden> list comprehensions
05:36:24 <dario> :t (<*>)
05:36:25 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
05:36:58 <friden> and is there a way with higher order functions?^^
05:37:15 <friden> or standard functions, or what the name is
05:37:21 <pyon> friden: <$> and <*> are higher-order functions
05:37:25 <pertl> I am using the haskell platform on os x. is there an easy way to access the sources of the library functions for learning?
05:37:28 <pyon> :t (<$>)
05:37:29 <lambdabot> Functor f => (a -> b) -> f a -> f b
05:37:50 <pyon> friden: <$> is just fmap :-)
05:37:51 <friden> ok, i will study those a bit further, havnt been using them as much
05:38:22 <friden> thanks :D
05:38:24 <pyon> friden: Functors and applicatives are very nice, you should definitely have a look at them. :-)
05:39:21 * hackagebot immortal 0.1 - Spawn threads that never die (unless told to do so)  http://hackage.haskell.org/package/immortal-0.1 (RomanCheplyaka)
05:39:48 <MagneticDuck> uhm... I'm not sure if I understand how haskell deals with pipes and such; is it safe to have a call to "getStrLn" as part of a program loop that runs at 60 fps?
05:40:45 <pyon> MagneticDuck: Wouldn't getStrLn block until there is input? :-O
05:40:54 <MagneticDuck> that's my first thought
05:40:57 <MagneticDuck> that's why I'm asking
05:41:11 <oakwhiz> MagneticDuck: sounds like you need a concurrency primitive
05:41:48 <MagneticDuck> I mean, isn't it a fairly simple and well-worn problem of having a program loop that needs to respond to activity on a stream of some sort?
05:41:50 <pertl> I am still learning, but how about "lines $ getContents" ?
05:41:52 <MagneticDuck> what's the simplest way to do this
05:42:19 <MagneticDuck> yeah I'm not sure
05:42:29 <MagneticDuck> I never was good at dealing with pipes and laziness simultaneously
05:42:50 <MagneticDuck> getContents is still magic to me because I never really learned about how haskell works
05:43:11 <pertl> afaik it's lazily reading from stdin
05:43:22 <MagneticDuck> yeah
05:43:25 <MagneticDuck> I get that >_>
05:43:42 <MagneticDuck> but I'm not sure exactly how its inner workings tick
05:44:12 <pertl> I still have to fully digest the chapter on monads :-)
05:44:21 <MagneticDuck> oh.
05:44:26 <MagneticDuck> lols
05:44:33 <benmachine> no getContents is actually magic
05:44:33 <MagneticDuck> then we're talking about completely different things
05:44:39 <pertl> ok
05:44:40 <benmachine> bona-fide magic
05:44:41 <pertl> :-)
05:44:43 <MagneticDuck> as much as core is magic I guess
05:44:57 <MagneticDuck> I DON"T UNDERSTAND CORE ZSOMZEBODY HELP MEEEE
05:45:47 <MagneticDuck> as in, I understand lambda calculi but I don't understand the strange land between lambda calculi and IO
05:45:55 <benmachine> if you want to interleave reading from some stream with something else, use forkIO
05:48:13 <MagneticDuck> yes
05:48:15 <MagneticDuck> the forkIO
05:48:38 <MagneticDuck> I will finally have to deal with it
05:50:01 <vlatkoB> In base 4.7, >>= for list is defined as "foldr ((++) . (\ _ -> k)) [] m".
05:50:02 <vlatkoB> Why not (const k) instead of lambda? Performance?
05:50:43 <MagneticDuck> style
05:51:09 <MagneticDuck> I mean, if "const k" is always slower than lambda, ghc would have done something about it by now, right?!
05:53:39 <vlatkoB> I suppose. Maybe ghc can optimize lambda "better"
05:54:44 <MagneticDuck> not sure how that would work
05:55:03 <MagneticDuck> but as I said earlier, I know very little about how ghc actually works
05:55:05 <MagneticDuck> =P
06:03:57 <mietek> https://vimeo.com/83779832
06:04:01 <mietek> Oops, wrong window.
06:10:11 <Darwin226> Say I'm making a game in haskell. Is there a way to load assets without using the IO monad? The way I see it, static assets are as constant as the executable so being unable to load them is as unpredictable as the executable getting corrupted or something.
06:11:11 <Darwin226> Or maybe a way to package everything in a single bundle so there's no IO
06:11:22 <MagneticDuck> you can use unsafePerformIO
06:11:29 <MagneticDuck> or you could package it into the executible
06:12:07 <MagneticDuck> out of curiosity, what are you using for graphics?
06:12:10 <MagneticDuck> I'm also trying to make a game
06:12:25 <MagneticDuck> I have problems with everything I do graphics-related >_>
06:13:32 <Darwin226> Juicy pixels or something? I don't have the code with me atm
06:13:46 <Darwin226> https://hackage.haskell.org/package/JuicyPixels
06:14:11 <Darwin226> Or do you mean rendering?
06:14:22 <Darwin226> For my purposes the gloss library was enough
06:15:16 <MagneticDuck> oh.
06:15:20 <MagneticDuck> gloss then
06:15:23 <MagneticDuck> k
06:25:01 <zwer> Darwin226 why do you need to load them outside of IO?
06:25:39 <Darwin226> Because it's easier and cleaner not dealing with an unescapable monad
06:26:06 <Darwin226> Would you say that that would be a valid use of unsafePerformIO?
06:27:03 <benmachine> I don't think it would be so painful to load them in IO
06:27:10 <benmachine> lots of other stuff is going to be happening in IO, after all
06:27:18 <benmachine> however, it seems reasonable that you would have them as pure values
06:27:45 <benmachine> I vaguely recall that there's a Template Haskell thing that allows you to load such things at compile time
06:33:06 <benmachine> Darwin226: http://hackage.haskell.org/package/file-embed
06:33:32 <Darwin226> benmachine: Useful. Thanks
06:41:13 <Philonous> It's a bit sad that most libraries that ship th functionality package it up in a way that's not composable
06:42:54 <Philonous> I wonder whether that's responsible for th's bad reputation.
06:48:24 <tulcod> Philonous: what do you mean?
06:48:47 <tulcod> Philonous: what do you think most people do, and what would be better?
06:50:07 <Philonous> tulcod, Well, most TH I see has some variation on (Name -> Q [Dec]), maybe with some configuration type as a parameter (so it supports a million special cases).
06:50:15 <tulcod> right
06:50:40 <Philonous> But that becomes useless when I can't give it a name to be reified.
06:50:50 <Philonous> So I have to re-implement it.
06:51:00 <tulcod> so what would be a better type signature?
06:52:18 <Philonous> tulcod, Well, depends on the situation of course, but let's say it creates accessors lenses for a data type, (Dec -> Q [Dec]) would be an improvement
06:53:01 <tulcod> Philonous: but if it creates them for a data type, the input Dec must be a DataD
06:53:17 <Philonous> DataD is a constructor, not a type, though
06:53:23 <tulcod> exactly
06:53:44 <Philonous> It could error out when it doesn't get a DataD
06:53:59 <Philonous> Just as it errors out when I don't give it a the name of a data declaration
06:54:02 <tulcod> that sort of throws the idea of types out the window
06:54:20 <Philonous> It's a compile time error.
06:54:36 <tulcod> but you can't validate that you got a DataD compile-time
06:54:46 <tulcod> not without a big GADT type mess
06:55:29 <Philonous> Huh? Of course it can. The TH code runs during compile time. Any exceptions will translateted into compile errors
06:55:58 <tulcod> Philonous: ah. alright
06:56:08 <Philonous> Note that it's not safe to begin with. There's no guarantee that the Name you give it will be that of a data type. So it will error anyway
06:56:17 <tulcod> still. is that how you want to solve this?
06:56:57 <tulcod> Philonous: well you could used typed TH
06:57:20 <Philonous> It's only one step into the right direction. Let the user reify the name if he needs to (or write a convenience function), but allow the function to be called with an actual declaration
06:58:02 <Philonous> Or take the needed data directly (In this case, presumably the name of the fields and accessor functions)
07:03:50 <nitrix> Hi, does haskell require a garbage collector?
07:04:19 <tulcod> nitrix: what do you mean by "require"?
07:04:20 <nitrix> I was very enthusiast about the language until this came up.
07:04:30 <zomg> I think all languages with automatic memory management have some form of garbage collection
07:04:42 <nitrix> It seems like the lazy evaluation mixed with other properties of the language makes escape analysis pretty complicated.
07:04:55 <tulcod> nitrix: fwiw, the garbage collector you get from GHC (the "default" compiler) is *very* small
07:05:17 <tulcod> nitrix: and the beauty of haskell is that you don't need to think about laziness (usually)
07:05:27 <nitrix> I wouldn't call it small if it's stopping the world....
07:05:57 <tulcod> nitrix: ok if you're just here to call haskell shit because it has a garbage collector, we can't help you
07:05:58 <k00mi> tulcod: unless you care about performance
07:06:05 <nitrix> I expected something elegant, aka RAII or something.
07:06:21 <nitrix> tulcod: Do not confuse language semantics with implementations.
07:06:21 <tulcod> haskell doesn't have RAII because it doesn't use the concept of resources
07:06:36 <benmachine> that's a bizarre comment
07:06:40 <benmachine> resources are a very general concept
07:06:53 <tulcod> not in the classical programming language sense *
07:06:58 <benmachine> oh fair enough
07:06:59 * benmachine shrug
07:07:19 * osfameron has never understood RAII
07:07:23 <benmachine> anyway, no Haskell compiler that I know of has ever had a story for deallocation that wasn't garbage collection
07:07:26 <nitrix> Why doesn't GHC use reference counting or any other strategy?
07:07:45 <nitrix> A garbage collector (stop the world) seems way overkill.
07:07:47 <tulcod> nitrix: because that's not how you should think of variables in haskell
07:07:49 <Iceland_jack> nitrix: What do you know about Haskell exactly?
07:08:10 <k00mi> nitrix: cyclic dependencies are very common
07:08:27 <tulcod> nitrix: because haskell is functional, you can throw away data whenever you like, and recompute it later. or you can keep it around if you think you'll need the same value twice.
07:08:31 <int-e> nitrix: because a) there are cyclic data structures b) reference counting is quite expensive c) allocation would become more expensive than in a copying GC (which is what ghc uses for the first generation at least)
07:09:31 <zomg> nitrix: if you're considering using haskell for a project, it would probably be better to ask about your actual concern (eg. performance for doing X) rather than picking on what you think is a problem (which it might not be)
07:11:06 <benmachine> I think it's fair to say that Haskell is unsuitable for applications with hard real-time constraints, because of its tendency to garbage collect at inopportune moments
07:11:13 <int-e> nitrix: Honestly I would only worry about the garbage collector when faced with real time requirements.
07:11:16 <nitrix> I just don't understand why you'd want a language to generate garbage at all. Even if it comes to an extra cost, it's amortized.
07:11:41 <Iceland_jack> Haskell in it's curent form couldn't really exist without a GC
07:11:49 <zomg> lol, now it does start sounding like a troll
07:11:58 <benmachine> no it doesn't
07:12:11 <zomg> maybe it's just me =)
07:12:20 <zomg> I'm on channels where it's a problem all the time...
07:12:30 <dottedmag> nitrix: You might want to refer to books or articles on Haskell (or lazy fp languages in general) compilation.
07:12:46 <tulcod> is there a specific way to write haskell code that allows you not to require a single resource? ideas of linear logic come to mind
07:12:52 <tulcod> eh acquire*
07:13:01 <nitrix> zomg: Maybe you just like calling people trolls, but to me, Haskell seems like an interesting language. They got almost every elements right in the design, but I wonder if the implementations aren't running late behind.
07:13:16 <benmachine> zomg: IMO naming people as trolls is at least as much a source of hostility as trolls themselves
07:13:25 <benmachine> and it's rarely productive anyway
07:13:26 <tulcod> nitrix: behind? name a single recently developed language without a gc
07:13:41 <benmachine> Apple's new thing does refcounting
07:13:44 <nitrix> Rust ?
07:13:48 <hexagoxel_> you are not the only one, zomg
07:13:52 <zomg> benmachine: yeah I suppose, but when they immediately respond in kind, it's hard to ignore the possibility :P
07:13:53 <benmachine> you have to explicitly mark cycles as such, it's pretty awkward
07:13:55 <d-snp> rust has a gc
07:14:01 <k00mi> an optional one
07:14:09 <int-e> nitrix: it's a trade-off, obviously. the pro GC argument is that copying garbage collection takes time proportional to the working set size, and allocation is incredibly cheap (advance a pointer, compare to the upper bound of the heap); if GC cost is too high, you can reduce GC frequency by allowing the program to use more memory.
07:14:45 <d-snp> can't you turn the gc off in haskell?
07:15:16 <k00mi> if you have enough memory ;-)
07:15:27 <d-snp> well yeah, it's 2014, ofcourse I do ;)
07:15:27 <tulcod> can't you write haskell in such a way that you don't need to acquire memory halfway through a specific computation?
07:15:27 <cin> http://en.wikipedia.org/wiki/Poe's_law
07:15:33 <Darwin226> Is there no way to write a custom Show instance for a type synonym?
07:15:41 <cin> Darwin226, no
07:15:58 <tulcod> Darwin226: type synonyms are just that: synonyms
07:15:59 <Iceland_jack> This is relevant: http://stackoverflow.com/questions/9952602/does-haskell-require-a-garbage-collector
07:16:00 <benmachine> Darwin226: type synonyms can't have different instances from their underlying types
07:16:00 <int-e> Note that all this is tied to particular implementations. jhc does some region inference, I believe (but will still have a garbage collector for data for which region analysis fails)
07:16:04 <nitrix> int-e: It's stop-the-world that bothers me, because at that point it becomes guess work of when's the optimal time and ideal frequency of doing it. Which is supposedly "amortized", but think a video game or flight controller, it makes no sense to have your software pause.
07:16:15 <jmcarthur> nitrix: reference counting is actually slower than mark and sweep most of the time
07:16:26 <nitrix> jmcarthur: But it's constant :/
07:16:28 <dottedmag> nitrix: You might want to refer to new developments in GC.
07:16:37 <benmachine> nitrix: I wouldn't write flight controllers in Haskell, but video games are a thing
07:16:40 <jmcarthur> nitrix: it is not constant when you dereference a large data structure
07:16:59 <dottedmag> nitrix: No, it isn't. Imagine last pointer to a huge data region removed.
07:17:01 <jmcarthur> nitrix: sorry, when you *no longer* reference it
07:17:35 <Maior> benmachine: one day I'll get Frag to build...
07:17:45 <benmachine> Maior: likewise :P
07:18:45 <benmachine> but frag isn't the only one
07:19:16 <benmachine> somewhat less ambitious: http://bysusanlin.com/raincat/
07:19:30 * hackagebot apiary 0.15.1 - Simple and type safe web framework that can be automatically generate API documentation.  http://hackage.haskell.org/package/apiary-0.15.1 (HirotomoMoriwaki)
07:20:13 <joffee> "<tulcod> nitrix: behind? name a single recently developed language without a gc"   swift
07:20:14 <jmcarthur> nitrix: for video games, it's not too hard to write haskell that has small enough gc pauses that it doesn't impact the frame rate at all. for actual hard real time systems, there's always DSLs like atom/copilot.
07:20:28 <benmachine> there was a commercial game "nikki and the robots", although I don't know what happened to it, it may not have survived
07:20:31 <jmcarthur> nitrix: basically using a haskell library to ultimately generate C
07:20:52 <jmcarthur> benmachine: it was "successful" in the sense that they released a commercial product
07:20:59 <jmcarthur> not sure if it was a good game or not
07:21:02 <benmachine> heh
07:21:16 <dottedmag> joffee: By introducing unowned and weak references, so basically shifting memory management back to programmer.
07:21:19 <tulcod> joffee: ok i guess my bluff was called :)
07:21:54 <jmcarthur> i think rust's answer to no gc is quite coherent
07:21:56 <dottedmag> tulcod: "A single recently developed language with automatic memory management and without a gc" would be accurate.
07:22:07 <tulcod> dottedmag: okay
07:22:08 <jmcarthur> and btw, rust doesn't actually have a gc now. it's just a library.
07:22:20 <jmcarthur> dottedmag: rust
07:22:31 <dottedmag> jmcarthur: < dottedmag> joffee: By introducing unowned and weak references, so basically shifting memory management back to programmer.
07:22:35 <dottedmag> jmcarthur: No cookie.
07:22:35 <jmcarthur> dottedmag: no
07:22:46 <jmcarthur> dottedmag: there is no free operation for rust references
07:22:48 <cin> so much straw grasping in here
07:22:54 <dottedmag> jmcarthur: Yes. You get memory leaks if you don't mark your loops.
07:23:25 <jmcarthur> ?
07:24:37 <dottedmag> jmcarthur: class A { var b: B? }; class B { var a: A? }; while true { var a = A(); var b = B(); a.b = b; b.a = a; } will cause ENOMEM.
07:25:39 <tulcod> okay, so next question: how can you make a language with automatic memory management, but without a periodic (or timed however) garbage collector?
07:26:04 <int-e> tulcod: prevent loops by making all data strict and immutable
07:26:08 <nitrix> What happens if you generate garbage quicker than the GC collects? You spend more time in the generations?
07:26:20 <arrdem> nitrix: typically
07:26:33 <Iceland_jack> Most garbage dies very young in Haskell
07:26:41 <joffee> arent there garbage collectors for java specifically made for hard real-time?
07:27:05 <tulcod> nitrix: i would totally call an implementation of that after whatever company i dislike at that time
07:27:20 <tulcod> e.g. Acne.Microsoft
07:28:31 <dottedmag> tulcod: There are incremental garbage collectors, which work a little every time allocation is requested.
07:28:48 <int-e> nitrix: here's a classic paper on real-time GC, http://www.pipeline.com/~hbaker1/NoMotionGC.html
07:29:04 <dottedmag> tulcod: Please refer to a plethora of GC research papers describing huge variety of collection schemes.
07:29:09 <tulcod> dottedmag: :)
07:29:27 <nitrix> int-e: Thank you for not using PDF.
07:29:31 <tulcod> in (roughly?) which cases does ghc optimize away new variable creations? like, when does computing a value never require more memory?
07:30:25 <jmcarthur> dottedmag: i'm trying to recall/find what the ? means in your code
07:30:51 <k00mi> dottedmag: is your example earlier supposed to be rust?
07:30:51 <dottedmag> jmcarthur: it's Maybe
07:30:57 <dottedmag> k00mi: swift
07:31:04 <k00mi> dottedmag: jmcarthur was talking about rust
07:31:21 <dottedmag> jmcarthur: Oh, sorry then.
07:31:26 <jmcarthur> lol
07:32:05 <dottedmag> jmcarthur: how does it deal with reference loops then?
07:32:27 <int-e> tulcod: as long as ghc manages to keep values unboxed. there's no hard rule, but with some experience, you can read this off GHC's core intermediate language (broadly, every application of a constructor and every partial application that remains after optmization  will cause some allocation on the heap)
07:32:33 <jmcarthur> dottedmag: you are not allowed by the compiler, in general.
07:32:49 <joffee> Real-time Java, Part 4: Real-time garbage collection - http://www.ibm.com/developerworks/library/j-rtj4/
07:33:05 <jmcarthur> dottedmag: i think there are some cases where it allows you to do it, or you can fall back to the gc or weak pointer tricks, but it's all statically checked for sanity.
07:33:13 <tulcod> int-e: ah, i guess i should look at the intermediate language more often then :)
07:33:18 <k00mi> dottedmag: rust has manual memory management with lifetime inference
07:33:29 <k00mi> dottedmag: things go out of scope, they are deallocated
07:33:51 <jmcarthur> it's really only manual in the sense that the cost model is really simple and the compiler will occasionally require hints
07:36:20 <dottedmag> jmcarthur: So, only DAG for references?
07:36:56 <int-e> nitrix: btw, Erlang is a functional language that has been designed with real-time constraints in mind. Apparently people are writing game servers with it; not sure about clients: http://www.slideshare.net/eonblast/an-erlang-game-stack
07:37:09 <jmcarthur> dottedmag: in fact, it's even more constrained for the most general case. you usually will only use trees, in rust, or at least that is easiest to do.
07:37:45 <nitrix> erlang actually seems very insteresting.
07:37:54 <dottedmag> Sounds pretty restrictive, but I hadn't tried to write anything in such an environment.
07:38:35 <jmcarthur> dottedmag: it's really not. i quite enjoyed the little bit of rust i have written, actually
07:39:29 <jmcarthur> dottedmag: and as i said, when you really need it, you can go all the way to manual memory management (really only needed when interfacing with C) or GC (which is a library now, because so few people needed it when it was a language feature)
07:43:42 <jmcarthur> dottedmag: i haven't watched all of this, but i've seen part of it and it seems to be going in the right direction to explain some of rust's tricks https://air.mozilla.org/guaranteeing-memory-safety-in-rust/
07:45:04 <bjz> jmcarthur: yeah, that is basically from the horse's mouth - niko is one of the main implementors of rust's borrow checker
07:45:14 <jmcarthur> yup
07:45:44 <pertl> if monads were defined "class (Applicative a) => Monad a where ... " would the "return" function just disappear in favor of "pure" ?
07:46:24 <k00mi> pertl: ideally yes
07:46:29 <bjz> jmcarthur: the GC still needs a ton of work put into it, but there are more pressing things for 1.0
07:46:37 <pertl> k00mi:  ok thanks :-)
07:47:21 <joffee> why was return called return? similarity with imperative return doesnt help, it causes confusion
07:47:29 <k00mi> pertl: ghc 7.10 will actually have Applicative => Monad, but Monad will keep return for backwards compatibility
07:47:37 <benmachine> pertl: I think on balance it's unlikely, since return is so widely used
07:47:55 <pertl> makes a lot of sense ... thanks benmachine
07:49:14 <bjz> jmcarthur: manual memory managment is required for actually implementing the smart pointers, RC, GC, allocators, etc. but it is easier to check this stuff when it is packaged up in a library, behind a safe, statically checked interface
07:50:56 <jmcarthur> yeah, sure
07:51:20 <jmcarthur> just like you need real mutation to implement ST even though ST itself is safe
07:52:45 <luite> you even need real mutation to implement thunks :)
07:53:03 <int-e> > fix (1:) -- real mutation in action
07:53:04 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
07:53:06 <jmcarthur> :)
07:54:06 <augur> luite: no, you need real mutation to implement thunks *efficiently*
07:54:18 <augur> you can thunk all you like without being efficient tho!
07:54:22 <int-e> (the same goes for ST)
07:54:23 <l0cust> Okay, now it's two times in the past week that relaxing max-backjumps has worked. What sort of sorcery is happening?
07:54:41 <augur> luite: but, thats at an implementation level, so who cares
07:54:54 <augur> all computers use mutation at the bottom
07:55:17 <l0cust> augur: not necessarily. The computer could grow more ram
07:55:27 <augur> l0cust: yes, but
07:55:34 <augur> l0cust: setting ram, setting registers, etc. is all mutation
07:56:17 <augur> l0cust: even pure evaluation entails normalizing a term, which means creating some new representation in memory
07:56:35 <l0cust> augur: I was kidding :)
07:56:50 <int-e> l0cust: well, limiting the number of backjumps makes DPLL SAT-solvers (where the terminology comes from) incomplete...
07:57:09 <augur> l0cust: :P
07:57:22 <luite> http://hdiff.luite.com/tmp/threads.jsexe/ <- each table cell updated by its own thread, 10000 of 'em!
07:59:38 <Pythonfant> luite: are those webworker threads or do you just simulate multiple threads?
08:00:14 <luite> Pythonfant: forkIO threads
08:00:34 <Pythonfant> but you need to translate them to something javascripty, right?
08:01:40 <luite> yeah, green threads here, running in the gui thread
08:01:55 <luite> Pythonfant: the code https://github.com/ghcjs/ghcjs-examples/blob/master/threads/threads.hs
08:02:01 <Pythonfant> thx
08:04:21 <luite> Pythonfant: the rts runs these with h$mainLoop, which keeps running code as long as there's some haskell thread to run, but occasionally yields to let the browser process events
08:05:29 <luite> Pythonfant: all delayed threads are on a min-heap, if h$mainLoop has no more work it reschedules itself when the earliest of those has to wake up
08:05:48 <Pythonfant> cool
08:07:31 <luite> it might be called earlier if some event handler calls back into haskell for example, then the timeout is canceled. a new timeout is set when there is no more haskell work
08:09:09 <luite> Pythonfant: a thread example i did last week, http://hdiff.luite.com/tmp/try-purescript.jsexe/
08:09:24 <torpor> hi folks
08:09:33 <torpor> what can i do about this in the latest cabal update: Module
08:09:33 <torpor>     `Distribution.Simple.Configure'
08:09:34 <torpor>     does not export
08:09:34 <torpor>     `configCompilerEx'
08:09:50 <luite> Pythonfant: it runs the purescript compiler in a thread, but since the main loop breaks up the work, the gui stays responsive, even if the compile takes multiple seconds
08:10:13 <Pythonfant> that's nice
08:10:21 <Pythonfant> I really need to look into ghcjs
08:10:29 <luite> Pythonfant: and the compile can be restarted if the user has typed during that time, by sending an exception to the thread and putting the new source in the MVar
08:10:34 <nooodl> hi! is there a name for "foldr (.) id"?
08:11:21 <Cale> nooodl: No, but if there were, it would be called compose
08:11:29 <luite> Pythonfant: i liked that the source for that thing is very short: https://github.com/ghcjs/ghcjs-examples/blob/master/try-purescript/Main.hs
08:12:17 <mizu_no_oto> How efficient is Integer, particularly with respect to GHC and Data.Bits?  I'm writing a bitboard for Go.  Am I likely to notice a difference between a data constructor with the exact number of unboxed ints I need vs just using an Integer?
08:12:17 <nooodl> i guess it is also mconcat for the Endo monoid
08:13:08 <nooodl> is there something like Endo but with (<=<) and return instead of (.) and id?
08:13:28 <Cale> mizu_no_oto: You might want to consider using a UArray of Bool values, which is automatically packed into bits
08:13:42 <Cale> mizu_no_oto: You can even index it with pairs
08:14:32 <mizu_no_oto> Cale:  I don't care about the indexing, so much; most of my operations are easily done via bit-shifting and bitwise operations
08:14:34 * hackagebot Spock 0.6.2.2 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.2.2 (AlexanderThiemann)
08:14:36 * hackagebot graph-core 0.2.0.1 - Fast, memory efficient and persistent graph implementation  http://hackage.haskell.org/package/graph-core-0.2.0.1 (AlexanderThiemann)
08:15:58 <torpor> can someone help me out with some cabal package hell .. for some reason glib and cairo don't want to install .. i'm using the 'latest cabal update' fwiw ..
08:16:19 <bergmark> torpor: maybe you are missing some external library?
08:16:30 <torpor> i'm trying to use cabal to install helm
08:17:01 <torpor> http://pastebin.com/raw.php?i=6vksD3sA
08:17:24 <torpor> Module
08:17:24 <torpor>     `Distribution.Simple.Configure'
08:17:24 <torpor>     does not export
08:17:24 <torpor>     `configCompilerEx'
08:17:31 <bergmark> torpor: what does cabal --version say?
08:17:41 <torpor> using version 1.16.0 of the Cabal library
08:17:44 <mizu_no_oto> Cale: UArray of Bool doesn't offer a Data.Bits-like api, correct?
08:17:45 <luite> that is not the relevant version
08:18:08 <torpor> how do i fix this - go back to a different version of cabal?
08:19:12 <bergmark> torpor: here you can see that it exists in the latest version of Cabal http://hackage.haskell.org/package/Cabal-1.20.0.2/docs/Distribution-Simple-Configure.html#v:configCompilerEx
08:19:14 <luite> torpor: it's linking against the Cabal library of your GHC, check that first
08:19:47 <torpor> so i should try to update to 1.20?
08:20:26 <luite> torpor: are you running GHC 7.4 by the way?
08:20:38 <torpor> nope
08:20:40 <torpor> $ ghc --version
08:20:40 <torpor> The Glorious Glasgow Haskell Compilation System, version 7.6.3
08:20:48 <luite> oh ok
08:20:52 <bergmark> as luite said, it might be picking the Cabal version ghc uses. I think it only does that if you install something that depends on both Cabal and ghc?
08:20:55 <torpor> so is it that my cabal is outdated?
08:21:22 <luite> bergmark: nah it always uss the Cabal lib when it has to build a Setup executable
08:21:41 <bergmark> ah ok
08:21:58 <torpor> i'm confused about what i should do
08:22:12 <torpor> i'm trying to learn haskell and see some examples (helm) of what it can do
08:22:28 <bergmark> torpor: you need to either patch glib or upgrade your ghc
08:22:39 <torpor> ghc 7.6.3 is too old?
08:22:42 <luite> which always for build-type: Custom, and for other build-types it depends on whether the internal setup can be used (i think it-s disabled for -jN) and whether an executable has already been cached
08:23:04 <luite> torpor: a new haskell platform with 7.8.3 is going to be released later today, that might help
08:23:07 <bergmark> torpor: you may be able to install an older version of glib too
08:23:18 <bergmark> that's the easiest solution if it works
08:24:12 <bergmark> but either way it'd be nice if you filed a bug report to glib
08:24:25 <torpor> i don't know how to describe it properly - is this a bug in glib?
08:25:24 <bergmark> torpor: maybe not a bug per se, but you can title it "Doesn't build with cabal-1.16 (ghc-7.6)"
08:41:31 <torpor> welp
08:41:33 <torpor> i give up
08:41:42 <torpor> that's enough not-learning-haskell for today
08:42:49 <orbifx> lol
08:49:12 <benzrf> torpor: hehehe
08:49:44 <mwhit> was there a reason 'cabal install cabal-install' wasn't good enough?
08:54:22 <dmj`> does newtype unbox values at runtime?
08:54:58 <Hafydd> dmj`: I'm not sure what you mean. newtype is never associated with a box, as far as I know.
08:55:52 <Hafydd> The point is that it's a type-level annotation without any runtime overhead.
08:56:51 <asmyers> mwhit: What do you mean by "wasn't good enough"?
08:57:18 <modeller> Why "(+) 1 2 + " is allowed, but "(+) (+) 1 2" is not allowed?
08:57:27 <modeller> Appreciate any advice
08:57:37 <dmj`> Hafydd: are values defined with newtype allocated on the heap or stack
08:58:08 <tromp__> because of associativity, modeller
08:58:13 <Hafydd> dmj`: IDK. Probably both, depending on the context.
08:58:26 <pyon> modeller: Perhaps you meant "(+) ((+) 1 2)" ?
08:58:29 <Hafydd> A list probably can't be allocated on the stack, for example, but an newtype Int can.
08:58:46 <modeller> let me try out
08:58:57 <tromp__> :t (+) 1 2 +
08:58:59 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
08:59:03 <tromp__> :t ((+) 1 2 + )
08:59:04 <lambdabot> Num a => a -> a
08:59:37 <modeller> yeah it works. thx
09:00:15 <dmj`> Hafydd: data A = A Int deriving Show; main = print $ A 4. When the rts begins evaluating does it allocate A on the heap, then dereference it to get 4, or at compile time is (A 4) is removed and it just prints the value when evaluated, or is something different going on
09:04:52 <Hafydd> dmj`: it works exactly the same as however print $ (4 :: Int) does, AFAIK.
09:05:22 <modeller> Why does ((+) 1 2 + (+) 3 4) work, but ((+) (+) 1 2 (+) 3 4) not? A bit trial question, I am trying to understand the basic rules.
09:05:22 <Hafydd> dmj`: if you're talking about GHC, I don't know if it's accuate to say that the RTS is "evaluating".
09:05:55 <{AS}> modeller: you are applying (+) with (+) as first argument, which isn't an Int
09:06:23 <{AS}> ((+) ((+) 1 2) ((+) 3 4)) is equivalent to the first
09:07:03 <dmj`> Hafydd: what would be more accurate?
09:07:14 <{AS}> since it has to apply (+) as a function to the inner arguments, producing an Int, and then it can use it as argument for the outer (+)
09:07:20 <modeller> :t (+) (+)
09:07:21 <lambdabot> (Num (a -> a -> a), Num a) => (a -> a -> a) -> a -> a -> a
09:07:35 <modeller> :t (+) (+) 1 2
09:07:36 <lambdabot> (Num (a -> a -> a), Num a) => a -> a
09:07:57 <modeller> :t (+) ((+) 1 2)
09:07:58 <lambdabot> Num a => a -> a
09:08:07 <Hafydd> dmj`: that the program itself is evaluating it.
09:11:41 <{AS}> :t (+) (+) (1 :: Int) 2
09:11:43 <lambdabot>     Couldn't match expected type ‘a -> a -> a’ with actual type ‘Int’
09:11:43 <lambdabot>     In the second argument of ‘(+)’, namely ‘(1 :: Int)’
09:11:43 <lambdabot>     In the expression: (+) (+) (1 :: Int) 2
09:11:51 <{AS}> modeller: ^ gives you a better error
09:14:33 <eacameron> how can I see the inferred type for a function in a "where" clause?
09:15:27 <dmj`> eacameron: move it out of the where and put it on the top level
09:15:50 <dmj`> eacameron: or maybe using type holes
09:16:18 <eacameron> dmj`: doesn't that effect the inferred type since it might reference identifiers within the enclosing context?
09:16:23 <eacameron> *affect
09:17:10 <eacameron> type holes?
09:18:43 <dmj`> eacameron: http://www.haskell.org/haskellwiki/GHC/TypedHoles
09:19:18 <enthropy> giving it a wrong type signature is probably still easier
09:19:46 <modeller> {_AS}: I understand it now. I went back to do some reading about currying.
09:20:22 <modeller> thanks for the tips
09:20:23 <enthropy> f x = something `const` (_a_hole_with_the_type_of_g `asTypeOf` g) where g = ...
09:24:42 <dagle> Can you turn off things like history, tabbing etc in ghci?
09:25:21 <Cale> dagle: Why do you ask?
09:25:56 <dagle> Cale: It conflicts other stuff I run.
09:26:08 <modeller> {AS}: In your previous example, why the 2nd inner parenthesis (the ones surrounding (+) 3 4) necessary? (+) ((+) 1 2) ((+) 3 4)
09:26:14 <Cale> hm, I don't think there's an option to turn them off
09:26:33 <modeller> My concern is that if to use + as infix, it is not needed
09:27:31 <Cale> modeller: The parens surrounding ((+) 3 4) are needed because otherwise that (+) would be an argument to the first (+), which would be a type error
09:27:37 <modeller> ((+) 1 2) + (+) 3 4
09:27:37 <Cale> (probably)
09:27:50 <Cale> Oh, you can do that
09:27:59 <Cale> > (+) 1 2 + (+) 3 4
09:28:00 <lambdabot>  10
09:28:14 <Cale> But if you want to prefix the outermost (+) as well...
09:28:25 <Cale> > (+) ((+) 1 2) ((+) 3 4)
09:28:27 <lambdabot>  10
09:28:37 <modeller> Cale: If that is the case, then shouldn't ((+) 1 2) + (+) 3 4 also fail?
09:28:38 <Cale> then the arguments have to be parenthesised
09:28:50 <Cale> > ((+) 1 2) + (+) 3 4
09:28:52 <lambdabot>  10
09:28:55 <Cale> No, that doesn't fail
09:29:26 <triliyn> modeller: prefix function applications have higher precedence than any infix operator
09:29:36 <Cale> Yes
09:29:57 <Cale> If you write f x y + g z w, then this will always mean (f x y) + (g z w)
09:30:04 <modeller> So, does it mean that below two expression is NOT equivalent: (+) ((+) 1 2) ; ((+) 1 2) +
09:30:07 <triliyn> Even if f and g are (+)
09:30:22 <Cale> modeller: The latter is syntactically incorrect
09:30:44 <Cale> > ((+) 1 2) +
09:30:45 <lambdabot>  <hint>:1:12:
09:30:46 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
09:30:57 <Cale> > (+) ((+) 1 2)
09:30:59 <lambdabot>  <Integer -> Integer>
09:31:21 <modeller> :info +
09:31:35 <triliyn> If you want to partially apply an infix operator, you need to use section syntax
09:31:38 <modeller> :info (+)
09:31:45 <triliyn> > (((+) 1 2) +)
09:31:47 <lambdabot>  <Integer -> Integer>
09:31:51 <Cale> Lambdabot doesn't have :info
09:32:12 <Cale> (+) is infixl 6
09:32:18 <modeller> Ok i see
09:32:29 <modeller> and + ?
09:32:36 <Cale> Hm?
09:32:55 <modeller> Is there a way to check precedence of infix operator +
09:33:09 <Cale> It's infixl 6, that's what I just said
09:33:13 <Cale> ghci> :info (+)
09:33:13 <Cale> class Num a where
09:33:13 <Cale>   (+) :: a -> a -> a
09:33:13 <Cale>   ...
09:33:13 <Cale>   	-- Defined in ‘GHC.Num’
09:33:14 <Cale> infixl 6 +
09:34:04 <Cale> Putting any infix operator in parens makes it prefix
09:34:06 <modeller> so the displayed precedence is same for infix and prefix
09:34:10 <Cale> (i.e. like an ordinary function)
09:34:22 <Cale> The precedence doesn't matter at that point
09:34:47 <Cale> Precedence only matters for infix applications
09:35:13 <{AS}> function application always has higher precedence than infix operators
09:35:20 <modeller> o i c
09:35:57 <{AS}> I am unsure if prefix operators can have higher precedence than function application though
09:36:19 <Cale> There's only one prefix operator, unary negation, and it doesn't.
09:36:30 <modeller> I thought operator is just an function
09:37:50 * cabal_stuck :: [Stuck]
09:38:31 <triliyn> Operators are syntactically different from functions, but not semantically
09:38:32 <cabal_stuck> I've tried rm -rf .cabal; cabal update; cabal install cabal-install, but am having all kinds of problems getting basic packages installed
09:39:06 <cabal_stuck> am I missing some important step?  building on ghc 7.6.3 on openbsd 5.5 amd64
09:39:52 <cabal_stuck> ghc-pkg check returns dozens of pages of 'files missing'...
09:40:31 <hexagoxel> cabal_stuck: for a full reset, i think you also need to rm -rf .ghc
09:40:34 <modeller> ok got it
09:41:41 <cabal_stuck> hexagoxel: ok... tryinig that now :)
09:42:27 <cabal_stuck> hexagoxel: do you recommend using cabal-dev instead of the vanilla cabal?  i'v read that on a blog somewhere but never seen it mentioned elsewhere
09:42:36 --- mode: ChanServ set +o copumpkin
09:42:50 --- mode: copumpkin set +b stuntaneous*!*@*$##fix_your_connection
09:43:01 <hexagoxel> cabal_stuck: cabal sandbox is replacement for cabal-dev, afaik
09:43:04 --- mode: copumpkin set -o copumpkin
09:43:12 <glguy_> cabal-dev is deprecated now and unmaintained
09:43:25 <copumpkin> and nix is a replacement for both :P
09:45:35 --- mode: ChanServ set +o glguy_
09:45:52 --- mode: glguy_ set -b boemekeld!*@*$##fix_your_connection
09:45:56 --- mode: glguy_ set -o glguy
09:46:58 <bergmark> i'm still using cabal-dev
09:48:54 <cabal_stuck> conceptually it's hard to understand why upgrading from version 4.1 to 4.2 of a certain package could break so many other packages...
09:49:35 <chrisdone> bergmark: i'm writing some fay :3
09:49:42 <bergmark> chrisdone: :-O :3
09:50:01 <bergmark> i'm writing some type families
09:50:02 <glguy_> cabal_stuck: 4.1 to 4.2 is a major version number change, so everything could have changed
09:50:18 <heatsink> It's a minor version number change
09:50:19 <chrisdone> bergmark: beer o'clock here. la chouffe ^_^
09:50:24 <heatsink> 4.1 to 5.0 is a major version number change
09:50:43 <glguy_> heatsink: No, the pvp doesn't distinguish between the first two digits
09:51:17 <bergmark> chrisdone: good idea! i have some weird ones in the fridge
09:51:22 --- mode: glguy_ set -o glguy
09:51:32 <chrisdone> bergmark: i sent you a modern mix of a 90s track on tweetinger =p
09:51:50 <bergmark> i like the only comment
09:52:06 <chrisdone> lol
09:52:29 <chrisdone> i'm using x.y.z for my versions these days… i found i never ever updated the x in x.y.z
09:54:24 <heatsink> Hmm.  What was undesirable about major.minor.bugfix format?
09:55:36 <chrisdone> heatsink: i don't subscribe to that characterization of the components. the only things that matter to me are breaking-change.non-breaking-change
09:56:40 <bergmark> it's major.major.minor.bugfix... so basically the same thing, not sure if semver was established at that time?
09:56:44 <chrisdone> i.e. to depend on the package you should reliably be able to depend on breaking-change.*
09:57:24 <heatsink> chrisdone: "major" is supposed to be a compatibility-breaking change, "minor" a backward-compatible change, "bugfix" a change that doesn't affect the interface
09:59:05 <chrisdone> heatsink: the latter two aren't distinct to me and overlap
09:59:06 <heatsink> So having two major versions means you need to depend on x.y.*
10:00:24 <chrisdone> bugfixes can change interfaces, minor changes can not affect interfaces (like improving performance), etc. it's all just "does this preserve what people were using when they chose the breaking-change.* version?" if yes, just bump non-breaking-change. if not, bump breaking-change
10:00:40 <heatsink> That's reasonable
10:01:10 <bergmark> you are always free to bump a higher component if you want so it works out pretty well i think
10:01:30 <bergmark> http://fvisser.nl/post/2013/may/28/towards-a-better-haskell-package.html
10:01:40 <chrisdone> yeah, people can still use my versions like "5.2" as if it were 5.2.0
10:03:58 <bergmark> it's pretty tricky for fay for instance, since you may need to take the api, command line args, maybe even generated code into account
10:04:21 <chrisdone> yeah, all of it
10:05:06 <cabal_stuck> if you are alreday on version 5.2 of a program, that means you've gone through at least 52 versions.  If two versions after 50 you're having to break the dependency tree, version 5.0 was probably premature
10:05:41 <chrisdone> cabal_stuck: hmm, 52 versions isn't a correct assumption
10:05:46 <chrisdone> 5.124 could be a valid version
10:05:52 <chrisdone> if i did 124 non-breaking changes
10:06:23 <chrisdone> 5 means i made 5 breaking changes
10:06:37 <chrisdone> actually -- i made 5 *releases of breaking changes*
10:06:54 <chrisdone> i probably made more than one breaking change within each release
10:07:17 <bergmark> i haven't decided if i like bundling breaking changes up or not
10:07:55 <heatsink> Bundling them together means clients revise their code less often
10:07:59 <bergmark> much easier to upgrade one breaking thing at a time
10:08:09 <chrisdone> sebastian's guide is good, i like that one
10:08:26 <cabal_stuck> chrisdone: going to a new major version number doesn't NECESSARILY mean you've introduced breaking changes.  maybe you just introduced a GUI, for example
10:08:42 <Philonous> I'd much fix my code once because fo a breaking API than once every week, even when the one change is bigger.
10:08:50 <cabal_stuck> CABAL NEEDS A GUI, that will solve everythin
10:09:07 <Philonous> much rather*
10:09:27 <chrisdone> bergmark: it's a trade-off for sure
10:09:39 <chrisdone> i get nervous about upgrading fay when there're a bunch of changes upstream
10:09:51 <bergmark> Philonous: yeah i'm leaning towards that too. and most of the time breaking changes don't actually break that many users
10:09:52 <chrisdone> but i don't have time to always be pulling and reviewing
10:12:24 <Th30n> What's the preferred way to deal with C functions returning an error code when wrapping them? Should I throw an exception (since it is in IO) or return IO (Either ErrorMsg CorrectResult) ?
10:13:50 <chrisdone> th30n: as you prefer!
10:14:10 <Th30n> But take into consideration I might release the code on hackage if no such library exists by the time I'm done
10:14:14 <chrisdone> if it's expected to return an error often, return Either
10:14:23 <chrisdone> if it's exceptional that it fails, throw an exception
10:14:26 <chrisdone> that's the rule i go by
10:15:52 <heatsink> How do you document upstream bugs that are exposed through your library?
10:16:11 <mwhit> is there a good reason for ever throwing an exception? I always go for Either, even in IO
10:16:14 <mwhit> am i missing something
10:16:45 <Th30n> mwhit: Well I'm asking since I'm still new to Haskell. And am wondering what's the general usage pattern.
10:16:56 <mwhit> oh, i'm asking too
10:17:40 <Cale> I suppose it depends on whether you'd usually want to handle the exception immediately or let it propagate upward
10:17:46 <chrisdone> mwhit: if it's exceptional behaviour, like running out of memory. that's a good example for an exception. indeed, the line blurs when you get to things like "if the file doesn't exist, readFile throws an exception". but i lean torwards "if it's rare that this happens, throw exception"
10:18:15 <merijn> Actually, my personal opinion is this: Library APIs shouldn't throw exceptions
10:18:29 <merijn> Or at least non-throwing should be default
10:18:35 <hodapp> use exceptions for slightly non-standard flow control!
10:18:46 <benmachine> psht
10:19:00 <benmachine> use exceptions for standard flow control, if statements are needless luxury
10:19:01 <mwhit> chrisdone: I understand that's the perspective for some, but *why*? Why should throwing an exception be preferred there rather over a non-lying type signature?
10:19:05 <ezrios> Data.List.head
10:19:11 <merijn> Exceptions can be useful within an application, i.e. terminating processing of a connection in a server to return to the main loop, but other than that...
10:19:22 <chrisdone> mwhit: because that's the point of exceptions? they're exceptional?
10:19:34 <mwhit> that seems like... not a good reason
10:19:37 <chrisdone> the whole innovation was that "instead of always returning error codes we're going to invent exceptions"
10:19:42 <merijn> mwhit: If you don't plan to handle the error and want to escape from deeply nested code (i.e. server thread handling a client terminating the entire connection"
10:19:44 <hpc> i agree that running out of memory should be an exception
10:19:48 <hpc> but a file not found should not be
10:20:05 <chrisdone> so maybe your question may be better phrased like "why are exceptions better than return values"?
10:20:13 <heatsink> mwhit: One useful case is when exceptions are not generated by the code, but come from outside, like in the out-of-memory example.
10:20:18 <chrisdone> er, sorry
10:20:23 <mwhit> heatsink: that's fair
10:20:24 <heatsink> "outside" here is the runtime system
10:20:34 <bergmark> that they're exceptional is a good motivation imo, it's annoying to have to handle these cases all the time, and conversely it'd be annoying to accidentally forget to handle some common error
10:20:36 <chrisdone> nod
10:20:54 <benmachine> you kind of definitely need exceptions for async exceptions
10:21:10 <benmachine> or at least, I can't see any other way of doing them
10:21:10 <hodapp> kind of definitely?
10:21:10 <chrisdone> there's the thing where you're using a library (like IO) where basically ALL the actions can throw an exception
10:21:22 <heatsink> hodapp: Sounds like modal logic
10:21:43 <chrisdone> so you can either make every single function return a status value, or just say "The IO type can throw these values"
10:22:30 <heatsink> chrisdone: But that can also be handled by putting everything into LibraryM and providing runLibrary :: LibraryM a -> IO a
10:22:51 <chrisdone> heatsink: what would the use be?
10:23:19 <heatsink> chrisdone: Require users to explicitly catch or explicitly ignore errors
10:23:52 <chrisdone> heatsink: perhaps runLibrary :: LibraryM a -> IO (Either Error a) would be explicit
10:24:00 <heatsink> yeah
10:24:01 <chrisdone> your type signature seems just as implicit and icky as normal IO
10:24:28 <chrisdone> i guess STM is an example of that
10:24:45 <chrisdone> catch (atomically …) (\(e :: STMException) -> …)
10:24:50 <chrisdone> (or whatever the type of STM exceptions is)
10:25:43 <chrisdone> mwhit: what do you think about checked exceptions java?
10:27:11 <mwhit> i see your analogy, but I think Haskell users have a greater expectation of safety, and i think that's a good thing
10:27:31 <mwhit> and java lacks many of haskell's safe error-handling features
10:27:51 <chrisdone> i wasn't making a point, was just curious what you thought of it
10:28:13 <mwhit> oh, well, yes, they're irritating to handle
10:28:18 <mwhit> which i assumed is where you were going with that
10:28:18 <chrisdone> ah, i didn't really mind it the few times i programmed in java
10:28:22 <chrisdone> interesting
10:28:45 <mwhit> i'm for them, really
10:28:51 <mwhit> but i'm against fighting the entire java culture over them
10:29:11 <HeladoDeBrownie> mwhit, what do they have to say about them?
10:29:20 <mwhit> generally frowned on, from my understanding
10:29:37 <mwhit> maybe i just have a warped perception though
10:29:39 <chrisdone> i think Expert Programmers like them, but popular opinion says they're bad because error handling is a chore
10:30:09 * HeladoDeBrownie wonders if inference of thrown exceptions could ever be a thing :P
10:30:29 <heatsink> "Expert Programmers"?
10:30:37 <mwhit> Real Programmers (tm)
10:30:43 <heatsink> i c
10:31:06 <chrisdone> heatsink: an ironic way of referring to the shirt and tie Enterprise™ java programmer
10:31:22 <heatsink> ok
10:31:37 <chrisdone> people who read books like "Patterns and Things You Should Take as Gospel"
10:31:52 <Th30n> I think I'll go with IO (Either Error a). Because I would definitely want to check every error and the possibility of an error is right there in type signature.
10:32:30 <benzrf> Th30n: y not EitherT Error IO a
10:32:44 <Th30n> benzrf: to have less dependencies
10:32:53 <chrisdone> benzrf: is there a difference?
10:33:01 <benzrf> chrisdone: automatic handling by bind?
10:33:04 <HeladoDeBrownie> Ease of composability, mostly
10:33:08 <Th30n> As I said, i'm thinking about putting it on hackage
10:33:20 <benzrf> Th30n: everybody already has transformers anyway
10:33:28 <benzrf> dont be afraid!
10:33:37 <Th30n> ok, it certainly makes writing the code easier
10:33:40 <chrisdone> benzrf: but presumbaly there's an m (Either e a) -> ErrorT e m a
10:33:48 <benzrf> chrisdone: hmm?
10:33:56 <benzrf> what, is ErrorT in baes?
10:33:58 <benzrf> *base
10:34:02 <mwhit> EitherT isn't in transformers, actually, but that shouldn't stop you
10:34:06 <chrisdone> benzrf: what do you do with ErrorT when you're using an IO function that returns an Either?
10:34:09 <benzrf> mwhit: oh
10:34:11 <benzrf> it used to be
10:34:22 <benzrf> chrisdone: i dont know what this is mean
10:34:25 <mwhit> it's in either now afaik
10:34:29 <benzrf> mwhit: ah
10:34:44 <chrisdone> benzrf: foo :: IO (Either Error String) -- now you want to use foo inside EitherT. what do you do?
10:35:08 <Th30n> runEitherT foo
10:35:28 <HeladoDeBrownie> I think that's the opposite of what you want
10:35:32 <chrisdone> Th30n: (°¬°)
10:35:55 <benzrf> chrisdone: EitherT foo
10:35:56 <benzrf> ;-)
10:36:09 <Th30n> ups, right :)
10:36:20 <chrisdone> benzrf: okay, so that's handy and easy
10:36:47 <Hafydd> Maybe `either left return foo' if you don't want to use the constructor.
10:36:58 <Hafydd> Er... with some lifting.
10:37:05 <chrisdone> heh, maybe with fmap  or something
10:38:14 <Hafydd> liftIO foo >>= either left return
10:40:55 <chrisdone> hafydd: i award one internet point to you
10:41:07 <Th30n> Thanks for discussion, off I go.
10:43:25 <Hafydd> Is there a bureau de change for all the different currencies of internet points, somewhere?
10:44:44 <mwhit> if i switch on library-profiling by default in cabal, is there any way to tell cabal to go back and reinstall dependencies with profiling when necessary?
10:45:09 <mwhit> as it is it fails if something depends on a library already installed without profiling
10:46:55 <merijn> mwhit: Unfortunately not and it really sucks that profiling is not the default :\
10:47:23 <benmachine> the cost of profiling is a bit steep
10:47:27 <td123> are there any articles explaining why haskell uses exceptions in some places and sum type errors in others? why not just go for all sum types?
10:47:33 <benmachine> doubling compile/install times is a bit sad
10:49:00 <mwhit> td123: you shuld have been here like, 30 minutes ago
10:49:11 <mwhit> we literally just finished that conversation
10:49:53 <td123> mwhit: I know I shouldn't have been working 30 minutes ago!
10:50:02 <heatsink> heh
10:50:06 <td123> no worries, I will just check my irc history
10:50:31 <_ikke_> Am I correct that the latest haskell-platform isn't suitable for ghc 7.8.3? I get all kinds of errors about OpenGL
10:51:03 <mwhit> not sure, but the new one is supposedly releasing today
10:51:08 <mwhit> so you might want to wait a few hours
10:51:21 <merijn> _ikke_: Latest platform will be released today or tomorrow
10:51:34 <merijn> Last email I saw was them figuring out the right space on the new servers
10:52:55 <_ikke_> ok
10:53:51 <mwhit> guess i'll just --disable-library-profiling for non-sandbox stuff
10:57:21 <dfeuer_> @hi
10:57:21 <lambdabot> hitchcock ... Hitchcock's Bible Names Dictionary (late 1800's)
10:57:41 <mwhit> interesting interpretation
10:58:39 <Hafydd> What?
11:01:19 <chrisdone> @@ pl id show
11:01:20 <lambdabot>  pl id show
11:01:23 <chrisdone> lol wut
11:01:31 <chrisdone> @. x
11:01:31 <lambdabot> Not enough arguments to @.
11:01:42 <chrisdone> @. vixen id
11:01:43 <lambdabot> Plugin `compose' failed with: Unknown command: "vixen"
11:01:50 <chrisdone> @. faq id
11:01:50 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
11:01:55 <chrisdone> @. faq cycle
11:01:56 <lambdabot> Plugin `compose' failed with: Unknown command: "cycle"
11:01:59 <chrisdone> oic
11:02:08 <hiptobecubic> :)
11:02:16 <hiptobecubic> @. id id
11:02:22 <chrisdone> hiptobecubic: it's hip to be square, their undisputed masterpiece!
11:03:47 <hiptobecubic> so it is!
11:04:53 * hackagebot api-builder 0.1.1.0 - Library for easily building REST API wrappers in Haskell  http://hackage.haskell.org/package/api-builder-0.1.1.0 (Intolerable)
11:10:09 <chrisdone> i think this will be a cool idea
11:10:25 <chrisdone> in a web page, to show "fmap (+1)" where (+1) is an editable expression
11:10:51 <chrisdone> and then you have [a], Maybe a, Tree a, Vector a, Const a, (-> r) a, etc. results below that update in real time
11:11:02 <chrisdone> to give newbies intuition about how fmap works
11:15:50 <_ikke_> ghc seems to be able to find the Data.Text module, but ghci and runhaskell can't
11:18:50 <_ikke_> ghc-pkg returns the text packge
11:18:52 <_ikke_> package
11:22:27 <dfeuer_> What is generic Haskell?
11:23:18 <bergmark> dfeuer_: you basically work with the structure of types, rather than specific types
11:23:26 <dfeuer_> Huh.
11:24:39 <bergmark> dfeuer_: say you want to serialize something to json, you can write a serializer that's specific to your type, or you can write a generic serializer that can serialize any type
11:26:13 <bergmark> it's like reflection in java, but good :-)
11:26:29 <dfeuer_> Hmmm.
11:44:40 <dfeuer_>  When I do foldr f [x], and f takes the head of its second argument, I get Core that checks for empty every time. Any ideas for avoiding this? Is there a "reallyUnsafeHead" function out there somewhere?
11:46:10 <simcity2000> dfeuer_: don't you need the initial for the fold anyway?
11:47:06 <dfeuer_> simcity2000, sorry, I didn't give enough information. The fold sticks in enough conses to make things work.
11:47:25 <simcity2000> dfeuer_: hmm
11:47:43 <dfeuer_> simcity2000, specifically, I'm writing a new version of scanr.
11:47:51 <simcity2000> dfeuer_: I'm not sure I understand the full scope still, but if you're looking for a really unsafe head function that doesn't check for empty you could just make one yourself in one line
11:47:52 <dfeuer_> As an explicit foldr.
11:47:57 <simcity2000> dfeuer_: gotcha
11:49:02 <simcity2000> @let unsafeHead (x:xs) = x
11:49:03 <lambdabot>  .L.hs:156:1: Warning:
11:49:04 <lambdabot>      Pattern match(es) are overlapped
11:49:04 <lambdabot>      In an equation for ‘unsafeHead’: unsafeHead (x : xs) = ...
11:49:04 <lambdabot>  
11:49:04 <lambdabot>  <no location info>:
11:49:14 <simcity2000> oh, I had already defined that in a query
11:49:45 <dfeuer_> simcity2000, that just turns the head error check to a pattern error check.
11:49:48 <dfeuer_> No improvement.
11:50:43 <enthropy>  unsafeHead (~ (x:xs) ) = x -- stab in the dark
11:51:13 <simcity2000> dfeuer_: right, I'm just sort of throwing something out there, but I'm also curious about what it is the unsafeness would help with
11:53:43 <olivia1> how do i convince haskell that these two type variables actually have to be the same? http://pastebin.com/VCFq55CN
11:53:50 <dfeuer_> simcity2000, I just don't see the need to have it test for something that can't happen.
11:57:51 <dfeuer_> simcity2000, I'm not sure, but I fear the check may also affect stack allocation.
11:57:55 <mwhit> olivial: what is the type of free?
11:58:10 <olivia1> class World a b where free :: a -> b -> Bool
11:58:46 <olivia1> sorry, class (Coordinate b) => World a b where free :: a -> b -> Bool
11:58:58 <simcity2000> dfeuer_: that's fair...mulling over this I'm not really sure any of the head functions fail to check if a list head exists
11:59:01 <carter> dfeuer_: you want a sized fold/scan
11:59:05 <enthropy> olivia1: can you always calculate 'c' from 't'?
11:59:13 <carter> dfeuer_: try writing the stuff with a static sized list
11:59:14 <simcity2000> dfeuer_: maybe something like xs !! 0?
11:59:23 <olivia1> enthropy: probably, yeah
11:59:25 <dfeuer_> carter, what do you mean by that?
11:59:33 <carter> List (n::Nat) a
11:59:35 <carter> not List a
11:59:40 <mwhit> olivial: Oh, well allowed has (World w (Thing a)) here and you need (World w a)
11:59:54 <mwhit> they aren't the same
11:59:56 <carter> dfeuer_: i've a pretty worked out sized list impl
12:00:03 <carter> https://github.com/wellposed/numerical/blob/master/src/Numerical/Array/Shape.hs
12:00:11 <dfeuer_> carter, how does adding numbers help? Some type trickery?
12:00:20 <carter> dfeuer_: i know how big it  its
12:00:22 <enthropy> olivia1: then I'd add to the class  "type GetC t", and then allowed :: (c ~ GetC t, World w c) => ...
12:00:23 <carter> *is
12:00:38 <enthropy> type GetC (Thing a) = a
12:00:43 <dfeuer_> But I don't know how big it is. I only know it's not empty.
12:00:46 <carter> yes
12:00:47 <carter> so you cant
12:01:15 <carter> i'm contending that the information you want is tantamount to knowing something about size
12:01:45 <dfeuer_> Sort of. It's about knowing the relationship between the size coming in and the size going out.
12:01:52 <dfeuer_> Which is about size, I suppose.
12:01:55 <carter> yup
12:02:13 <carter> write down the information / hyptheses you need for the operation to be safe
12:02:20 <carter> then figure out how to deduce that info
12:02:56 <olivia1> enthropy: never used type families before, im getting "  Type indexes must match class instance head, Found `Thing a' but expected `t'" now http://pastebin.com/UBR4eAJ9
12:04:05 <enthropy> olivia1: "type GetC (Thing a) = a" goes with the instance
12:05:10 <olivia1> enthropy: it works now! thanks so much
12:06:09 <olivia1> this will be interesting to port later haha
12:10:01 * hackagebot xlsx 0.1.0.2 - Simple and incomplete Excel file parser/writer  http://hackage.haskell.org/package/xlsx-0.1.0.2 (KirillZaborsky)
12:15:02 * hackagebot shadower 0.1.0.5 - An automated way to run doctests in files that are changing  http://hackage.haskell.org/package/shadower-0.1.0.5 (karun012)
12:18:06 <dfeuer> carter: I can get rid of that test by making a NonEmpty instead and then converting that to a list, but I'm not sure if GHC will be smart enough to make the code I want, and I can't test it for another nine plus hours :/
12:18:23 <carter> dfeuer: have you tried using benchmarking yet?
12:18:39 <carter> ie "is the code you want it ot generate as fast as you think"
12:18:43 <carter> or "is the speed the same"
12:18:46 <dfeuer> I think I can, anyway.
12:19:03 <carter> can you benchmark ideas before trying to make them happen?
12:19:04 <carter> like
12:19:24 <Total_1mmersion> Why is an irrefutable pattern necessary here? fix $ \(~(a,b)) -> let {a' = 0:a; b' = 1:b} in (a', b')
12:19:45 <Total_1mmersion> This hangs: fix $ \(a,b) -> let {a' = 0:a; b' = 1:b} in (a', b')
12:20:31 <dfeuer> Total_1mmersion: let.
12:20:47 <Total_1mmersion> Could you explain?
12:20:54 <carter> "can i make up a sythentic small demo that shows a measurable difference in the code?"
12:20:57 <carter> like
12:21:00 <carter> ignore fusion for a bit
12:21:08 <carter> and write the targe fuxed thing by hand
12:21:39 <dfeuer> Targe fuxed?
12:23:16 <carter> fused thingy
12:23:20 <carter> you know what i'm tlaking about
12:23:29 <dfeuer> OK.
12:23:43 <carter> if the resulting fused code if written by hand doesn't have a measurable perf difference, does it matter if it happens?
12:23:48 <carter> so if you have a design idea
12:23:53 <carter> measure the hand fused codes
12:23:58 <carter> vs the naive one you want people to be able to write
12:25:03 * hackagebot shadower 0.1.0.6 - An automated way to run doctests in files that are changing  http://hackage.haskell.org/package/shadower-0.1.0.6 (karun012)
12:28:16 <jughead> is there a book to start learning functional programming coming from an oop world
12:29:08 <hpc> probably LYAH
12:29:31 <hpc> functional programming is sufficiently different that there's very little you can compare between haskell and something like java
12:29:32 <lispy> jughead_: Have you tried real-world haskell?
12:29:57 <jughead_> i haven't . I used sml in a course years ago
12:30:17 <c_wraith> hpc: weird. I found functional programming to be no real change.  On the other hand, laziness and higher-kinded type classes really took me a while to come to grips with.
12:30:52 <jughead_> oay.. i guess LYAH and real world haskell are places to start ?
12:31:19 <hpc> c_wraith: it depends on what kind of OOP you come from; java's polymorphism is categorically backwards from haskell and you don't have things like first-class functions
12:31:29 <hpc> but something like javascript's prototype OO will be much more natural
12:31:38 <c_wraith> hpc: I came from mostly java.  The thing is I never really thought in java.
12:32:09 <c_wraith> hpc: I already thought of things in terms of stronger types and recursion, in general.
12:32:09 <hpc> c_wraith: you're lucky then
12:32:35 <hpc> it's painful to watch someone who thinks in java, because they have so much trouble learning new things
12:33:12 <platz> jughead: this course is starting up again soon, it goes FP basics and how it differs from OOP https://www.coursera.org/course/proglang
12:33:12 <c_wraith> I guess even at the start of my university days, I didn't see a real difference between loops and recursion. They were obviously the same thing.
12:33:28 <lispy> jughead: most importantly, try something. Write some code. Ask lots of questions.
12:33:29 <jughead> pltz: checking it out
12:33:35 <platz> jughead: and since you did some sml before should have some review for your
12:33:37 <platz> you
12:34:00 <jughead> thsi course looks awesome
12:34:10 <platz> the teacher is really good
12:34:49 <platz> it won't make you an FP expert, but it connects some of the dots between FP and OO
12:35:54 <platz> (non pure FP, that is)  if you want to learn haskell, a lot of people do start with LYAH
12:36:06 <hpc> the teacher did a presentation on STM to jane street
12:36:13 <hpc> in 2008
12:36:49 <jughead> does LYAH automatically mean that it would introduce me to FP concepts
12:37:21 <hpc> it's meant for people who have some programming experience, but not functional experience
12:37:30 <hpc> but it also works for people who have no experience at all
12:37:52 <jughead> cool!
12:39:43 <avallark> hello all :)
12:41:54 <dfeuer> carter: I'm looking at your Shape thing. What does a ! in a type signature mean?
12:42:01 <carter> bang patterns
12:42:08 <carter> that module is just just just for array indexing
12:42:12 <carter> but thats still a sized list
12:42:12 <fsp> Hi. Does anyone know how to accomplish this?: http://lpaste.net/83519586145665024
12:43:04 <olivia1> fsp do you already have the map from characters to lists of possible replacement characters?
12:43:08 <fsp> olivia1: yes
12:43:21 <fsp> I wrote a function called "leet" which pattern marches on Char.
12:43:33 <fsp> leet :: Char -> Char
12:43:48 <dfeuer> carter: ah, I see. Because that's not a normal type signature, but one in a GADT declaration.
12:43:59 <carter> gadt
12:44:00 <carter> yes
12:44:02 <daneeklu> fsp: shouldn't that be Char -> Maybe Char? In case some chars have no replacement
12:44:13 <olivia1> so you can get [[Char]] from the original string
12:44:22 <enthropy> @leet AAAAA
12:44:22 <lambdabot> Aa44a
12:44:22 <fsp> daneeklu: no, the last pattern I matched was leet x = x
12:44:30 <daneeklu> (it might not be necessary, but might simplify the rest)
12:45:03 <fsp> daneeklu: If they have no replacement I just leave them as is.
12:45:34 <enthropy> sometimes one character might expand to /\/\uLtip13 characters
12:45:46 <fsp> enthropy: I know ahead of time that this is not the case.
12:45:50 <daneeklu> what I mean is, it might be easier when creating the list containing all the variations
12:46:14 <fsp> enthropy: A girl in my life lost her bitcoin wallet password and wants me to help recover it.
12:46:36 <fsp> She knows all the words, just not the order/leet permutations.
12:47:04 <daneeklu> fsp: have you tried list comprehensions / the list monad?
12:47:14 <fsp> daneeklu: I looked in to it.
12:47:38 <fsp> I am having trouble figuring out how to leverage the list Monad properly.
12:48:08 <fsp> I think I have preconceived notions about how to approach the problem that doesn't mesh with how the list Monad operates.
12:48:27 <fsp> As a result, I am kind of spinning my mental wheels here.
12:49:16 <hpc> fsp: you know what map over a list does?
12:49:22 <hpc> > map (+ 5) [1..5]
12:49:24 <lambdabot>  [6,7,8,9,10]
12:49:31 <hpc> fsp: and what join does
12:49:35 <fsp> :t map
12:49:36 <lambdabot> (a -> b) -> [a] -> [b]
12:49:41 <hpc> > join [[1,2,3],[4,5,6],[7,8,9]]
12:49:42 <fsp> Yes.
12:49:43 <lambdabot>  [1,2,3,4,5,6,7,8,9]
12:49:47 <fsp> join = concat
12:49:51 <hpc> yeah
12:49:56 <fsp> And the list Monad defines bind as concatMap
12:50:21 <fsp> I am having trouble figuring out how to leverage that power in this problem.
12:50:29 <hpc> what's the problem?
12:50:36 <fsp> hpc: http://lpaste.net/83519586145665024
12:50:46 <enthropy> > permutations [1 .. 3]
12:50:47 <lambdabot>  [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
12:50:52 <hpc> oh, cool
12:51:14 <enthropy> maybe there's a select :: [a] -> [(a,[a])] somewhere now
12:51:20 <hpc> :t concatMap
12:51:21 <lambdabot> (a -> [b]) -> [a] -> [b]
12:51:40 <hpc> so, concatMap takes a function that returns multiple possibilities
12:51:49 <hpc> and a list of multiple possibilities
12:52:01 <hiptobecubic> wouldn't each letter be a list of length 2
12:52:04 <hpc> and produces a "cross product", sort of
12:52:38 <hpc> > do {x <- [1..5]; y <- [(+), (-)]; return (y x 1)}
12:52:40 <lambdabot>  [2,0,3,1,4,2,5,3,6,4]
12:52:43 <Total_1mmersion> What do you call each of these: Maybe, Maybe a, Maybe Int?
12:53:08 <hpc> fsp: so for each character position, have a list of possibilities for that position
12:53:32 <dfeuer> carter: could you write shapeToList=unsafeCoerce#?
12:53:36 <carter> no
12:53:45 <carter> dfeuer: why would i wanna do that?
12:53:50 <benzrf> @let x = 3
12:53:51 <benzrf> > x
12:53:52 <lambdabot>  Defined.
12:53:53 <lambdabot>  Ambiguous occurrence ‘x’
12:53:53 <lambdabot>  It could refer to either ‘L.x’, defined at L.hs:149:1
12:53:53 <lambdabot>                        or ‘Debug.SimpleReflect.Vars.x’,
12:53:53 <lambdabot>                           imported from ‘Debug.SimpleReflect’ at L.hs:112:1-26
12:53:54 <lambdabot>                           (and originally defined in ‘simple-reflect-0.3.2:De...
12:53:54 <benzrf> dang
12:53:56 <hpc> > do {let a1 = 'h'; a2 <- "3e"; a3 <- "1l"; a4 <- "1l"; return (a1:a2:a3:a4:[])}
12:53:58 <lambdabot>  <hint>:1:22: parse error on input ‘<-’
12:54:00 <carter> dfeuer: that depends on the exact RTS representation
12:54:07 <carter> dfeuer: try it and let me know if it works
12:54:07 <benzrf> @undef
12:54:08 <lambdabot> Undefined.
12:54:12 <benzrf> @let data Cheat = X
12:54:14 <lambdabot>  Defined.
12:54:30 <carter> but honestly the cost of converting betweeen the two is soooo low  compared with other things
12:54:41 <hpc> fsp: er, sec
12:54:53 <benzrf> @let instance Num (Cheat -> Int) where fromInteger v X y = v * y
12:54:54 <lambdabot>  .L.hs:150:9:
12:54:55 <lambdabot>      Couldn't match expected type ‘Integer -> Integer’
12:54:55 <lambdabot>                  with actual type ‘Int’
12:54:55 <lambdabot>      The equation(s) for ‘fromInteger’ have three arguments,
12:54:55 <lambdabot>      but its type ‘Integer -> Cheat -> Int’ has only two
12:55:10 <benzrf> @let instance Num (Cheat -> Integer) where fromInteger v = \X y -> v * y
12:55:12 <lambdabot>  .L.hs:150:25:
12:55:12 <lambdabot>      Couldn't match expected type ‘Integer -> Integer’
12:55:12 <lambdabot>                  with actual type ‘Integer’
12:55:12 <lambdabot>      The lambda expression ‘\ X y -> v * y’ has two arguments,
12:55:12 <lambdabot>      but its type ‘Cheat -> Integer’ has only one
12:55:15 <benzrf> :\
12:55:22 <hpc> > do {a1 <- "h"; a2 <- "3e"; a3 <- "1l"; a4 <- "1l"; a5 <- "o0"; return (a1:a2:a3:a4:[])} -- fsp, so like this
12:55:22 <carter> dfeuer: for any realistic sized input i'll ever deal with using this code, converting from shape to list will take less than 50 nanoseconds
12:55:23 <lambdabot>  ["h311","h311","h31l","h31l","h3l1","h3l1","h3ll","h3ll","he11","he11","he1l...
12:55:26 <benzrf> @let instance Num (Cheat -> Integer -> Integer) where fromInteger v = \X y -> v * y
12:55:27 <lambdabot>  .L.hs:149:10: Warning:
12:55:27 <lambdabot>      No explicit implementation for
12:55:27 <lambdabot>        ‘+’, ‘*’, ‘abs’, ‘signum’, and (either ‘negate’ or ‘-’)
12:55:27 <lambdabot>      In the instance declaration for ‘Num (Cheat -> Integer -> Integer)’
12:55:27 <lambdabot>  
12:55:30 <benzrf> sweet
12:55:33 <benzrf> > 3 X 4
12:55:35 <lambdabot>  Could not deduce (GHC.Num.Num (L.Cheat -> a0 -> t))
12:55:35 <lambdabot>    arising from the ambiguity check for ‘e_134’
12:55:35 <lambdabot>  from the context (GHC.Num.Num (L.Cheat -> a -> t), GHC.Num.Num a)
12:55:35 <lambdabot>    bound by the inferred type for ‘e_134’:
12:55:36 <hpc> > do {a1 <- "h"; a2 <- "3e"; a3 <- "1l"; a4 <- "1l"; a5 <- "o0"; return (a1:a2:a3:a4:a5:[])} -- fsp, er
12:55:37 <benzrf> aw
12:55:37 <lambdabot>               (GHC.Num.Num (L.Cheat -> a -> t), GHC.Num.Num a) => t
12:55:39 <lambdabot>  ["h311o","h3110","h31lo","h31l0","h3l1o","h3l10","h3llo","h3ll0","he11o","he...
12:55:48 <benzrf> hpc: lel
12:56:13 <RyanGlScott> Is it considered good practice to always use lazy pattern matches on data types with one constructor?
12:56:18 <hpc> fsp: basically, each (>>=) instance means "try all possibilities"
12:56:34 <monochrom> no
12:57:16 <benzrf> hmm
12:58:13 <fsp> hmm
12:58:34 <RyanGlScott> Now that you mention, here is an example of differing usages of lazy pattern matches: http://hackage.haskell.org/package/bifunctors-4.1.1.1/docs/src/Data-Bifunctor.html
12:58:49 <RyanGlScott> (,) is lazily pattern matched, but Const isn't. Why is that?
12:59:07 <hpc> @src Const
12:59:08 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:59:20 <hpc> Const is a newtype
12:59:34 <c_wraith> pattern matches on newtypes are basically lazy anyway.
13:00:02 <c_wraith> Since they don't actually do anything.
13:00:18 <RyanGlScott> So back to my original question: is there a scenario where lazily pattern matching on a data type with only one constructor could be harmful?
13:00:42 <c_wraith> depends on your definition of "harmful"
13:00:54 <vanila> It can make a crash occur later on
13:01:01 <monochrom> I think you're look for a non-existent rule of thumb. use lazy when you need lazy. use non-lazy when you need non-lazy.
13:01:02 <hpc> if you do it repeatedly, you can end up making enormous thunks
13:01:08 <c_wraith> It can just plain have wrong semantics.
13:01:21 <ifesdjeen> Hi everyone, could you give a hint about a good way to simplify expression like: a <$> b <$> c
13:01:22 <hpc> heh, that too
13:01:29 <RyanGlScott> monochrom: My problem is that I don't know exactly when I need lazy vs. non-lazy. I see it used often enough that I'm curious now.
13:01:34 <hpc> :t \a b c -> a <$> b <$> c
13:01:35 <lambdabot> Functor f => (a1 -> b) -> (a -> a1) -> f a -> f b
13:01:48 <fsp> hpc: How can I generalize that code so that it works on any words?
13:01:54 <monochrom> then learn laziness for real. read my http://www.vex.net/~trebla/haskell/lazy.xhtml
13:02:06 <fsp> hpc: I want to write a function with type String -> [String]
13:02:41 <t7> gloss is cool
13:02:50 <monochrom> I need only one rule of thumb: write down your program specification, implement it correctly.
13:02:58 <hpc> fsp: you'll need something that associates a character with possible obfuscations
13:03:36 <daneeklu> fsp: http://lpaste.net/109129
13:03:38 <daneeklu> something like this?
13:03:41 <hpc> fsp: and then you'd loop over the input string to try every alternative character
13:04:03 <daneeklu> (not a haskell expert, just tried to generalize the code I saw in chat)
13:04:41 <hpc> daneeklu: that'll work
13:05:14 <hpc> i would write it with forM or one of the other built-in combinators
13:05:49 <daneeklu> yeah, it is obviously pretty hastily made, and not great code
13:06:12 <daneeklu> fsp: I do hope it makes it quite simple to see how the list monad works in that case though
13:06:28 <AncientPC> Is there something like ccache for Haskell to speed up recompiling?
13:07:01 <t7> @hoogle b -> Map a b -> [a]
13:07:04 <lambdabot> Data.Map.Lazy showTreeWith :: (k -> a -> String) -> Bool -> Bool -> Map k a -> String
13:07:05 <lambdabot> Data.Map.Strict showTreeWith :: (k -> a -> String) -> Bool -> Bool -> Map k a -> String
13:07:05 <lambdabot> Data.Graph.Inductive.Query.BFS bfs :: Graph gr => Node -> gr a b -> [Node]
13:08:25 <fsp> daneeklu: I think that does what I want. I am mentally digesting your code now.
13:09:34 <daneeklu> fsp: just remember that every bind, is basically "do the below code for every element in the list"
13:10:08 <AncientPC> I have lambdabot combiled and running in a Docker, how do I get it to connect to an IRC server?
13:10:35 <fsp> daneeklu: yes!
13:14:40 <daneeklu> fsp: as someone mentioned, using forM is much more straightforward
13:15:09 <daneeklu> leetWord s = forM s leetS
13:15:41 <daneeklu> (where leetS is the list of variations for each character, as before)
13:15:51 <jughead> a quick question: where do ppl use haskell in the industry ?
13:17:41 <johnw> jughead: anywhere you'd use other languages
13:18:01 <jughead> @johnw what about missing libraries.
13:18:01 <lambdabot> Not enough privileges
13:18:16 <johnw> what about them?
13:18:35 <NemesisD> isn't there an extension that will let me match against an in-scope value? i.e. foo = 42; case x of; Just (==foo) sort of thing
13:19:03 <bergmark> NemesisD: ViewPatterns
13:19:14 <ReinH> NemesisD: No. Closest you'd get might be view patterns.
13:19:38 <jughead> scientific computing. rest services.
13:19:56 <jughead> does haskell have libraries for them? Wouldnt that limit the industry
13:19:59 <jmcarthur> jughead: probably the most well-known examples of companies using haskell are galois (high assurance software) and standard chartered (finance). those are probably the most popularly thought of industries for functional programming. however, haskell is totally general purpose and can be used for just about anything.
13:20:26 <jmcarthur> s/those/those (high assurance software and finance)/
13:20:37 <mwhit> the short answer is that industry use is limited but finally starting to see real growth, for basically the reason of limited library ecosystem
13:20:49 <bergmark> jughead: rest: http://engineering.silk.co/post/90354057868/announcing-rest-a-haskell-rest-framework
13:20:49 <jmcarthur> jughead: and not only "can be used for" but "is very nice for"
13:22:00 <jughead> in terms of speed?
13:22:18 <dmj`> jughead: haskell is used a lot for web development
13:22:18 <jmcarthur> jughead: i work for a company that doesn't use haskell, but does use a pretty unusual language (even less popular than haskell, as far as i know) with limited library support, and we get by pretty well. it's not crazy to roll your own when you think it's worth it for the benefits of the language.
13:22:30 <fsp> daneeklu: Indeed. So, in the list Monad every operation operates on the result of the previous operation, right?
13:22:36 <t7> is there a defacto dijkstra implementation on hackage?
13:22:51 <kristof> jmcarthur: what language, and what reasons?
13:23:08 <jmcarthur> jughead: ghc can produce pretty fast executables (with caveats for beginners since the cost model is unusual and the compiler optimizations are not exactly easy to get used to)
13:23:27 <jmcarthur> jughead: ocaml, and for most of the reasons one might choose haskell, too.
13:23:56 <daneeklu> fsp: yes, something like that. There might be tutorials that explain it better than me though
13:24:04 <jmcarthur> jughead: one thing ocaml has over haskell i guess is that its cost model is much simpler by default (but then again, the compiler is a lot less sophisticated, so you end up working at a lower level of abstraction most of the time)
13:24:11 <fsp> daneeklu: Ok, I appreciate your help!
13:24:30 <jughead> jmcarthur is there a reason why these languages pop up more in finance
13:24:35 <Philonous> jmcarthur, Do you happen to work at jane street?
13:25:10 <jmcarthur> jughead: the finance industry is generally more happy to try out newer technologies, i think. also, there is some element of "high assurance" involved, too.
13:25:12 <jmcarthur> Philonous: yes
13:26:12 <Philonous> jmcarthur, Ah, I was wondering whether another company was using ocaml. But so far it always turned out to be jane street.
13:26:33 <jmcarthur> Philonous: yeah. they pop up sometimes, but jane street is likely to remain the most high profile for a while yet
13:27:43 <luite> they keep a high profile at icfp :)
13:27:56 <AncientPC> Esper is another Bay Area startup that's using OCaml: http://esper.com/jobs.html
13:28:02 <jmcarthur> i've always thought games might be a nice area for ocaml, with its simple cost model and incremental gc for low latency, but now that rust is further along i think it might claim the spot i was imagining ocaml taking.
13:28:05 <AncientPC> IMVU also migrated from PHP -> Haskell: http://engineering.imvu.com/2014/03/24/what-its-like-to-use-haskell/
13:28:49 <jmcarthur> of course rust isn't exactly making big headway into that area either, but it's my hope that it will at least replace a lot of C++ code
13:29:24 <AncientPC> jmcarthur: Bay Area Rust group has hosted quite a few game-related talks, people seem pretty interested in using Rust for game dev.
13:29:39 <jmcarthur> AncientPC: yeah. i think it's a good fit (in my head, at least)
13:29:50 <Lowl3v3l> well my hope that c++ will be at his place died years ago... they were so much nice languages that could have replaced cpp by now.
13:29:51 <luite> AncientPC: anything bigger than hobby/indie yet?
13:30:24 <jmcarthur> Lowl3v3l: i actually don't think there have been many languages that would be reasonable candidates to replace C++, taking into account the criteria most C++ programmers would require
13:30:31 <AncientPC> luite: No, not until after Rust hits 1.0. Even then most AAA titles use game engines built on top of C++.
13:30:51 <jmcarthur> Lowl3v3l: namely, zero-cost abstractions, completely transparent cost model
13:30:57 <bjz> jmcarthur: a number of game companies are quietly interested (one has even given a presentation to the Rust team), and there's lots of hobbiest projects atm
13:31:29 <jmcarthur> bjz: i bet
13:31:33 <Lowl3v3l> jmcarthur, well my biggest hope was D^^
13:31:45 <bjz> AncientPC: not bigger than hobbiest - no sane game company would commit just yet
13:32:06 <jmcarthur> D is nicer than C++, but I don't think brings enough to the table to make a dent.
13:32:19 <ezyang_> Anyone have experience writing omnibus typeclasses like StringLike and can comment if they're a good/bad idea?
13:33:22 <{AS}> Hi, this might come off as a bit odd question. Is it possible to derive monad?
13:33:36 <hpc> it's not
13:33:54 <bergmark> {AS}: you can do it for newtypes
13:34:05 <ezyang_> {AS}: In theory, it should be possible in many cases
13:34:07 <hpc> or it hasn't been done, not sure about theoretically possible
13:34:13 <ezyang_> c.f. djinn
13:34:16 <jmcarthur> ezyang_: No experience writing them, some experience using them. I think they are a bad idea. They are just misusing type classes as module systems. I am dissuaded from using such type classes for polymorphism since there is little/no prescribed behavior for them.
13:34:18 <hpc> you can derive Functor iirc
13:34:20 <hiptobecubic> "completely transparent cost model"
13:34:29 <jmcarthur> hiptobecubic: okay that's a stretch
13:34:31 <hiptobecubic> assuming you can understand what the hell is going on
13:34:43 <jmcarthur> hiptobecubic: C is not a good cost model for modern machines anyway.
13:34:46 <ezyang_> jmcarthur: Right, a common conceptual complaint is that there are no "laws" for these typeclasses to obey
13:35:01 <ezyang_> jmcarthur: Did you notice any usability problems as well?
13:35:10 <AncientPC> Is there a well documented open source Haskell project that's easy to contribute?
13:35:34 <{AS}> Thanks guys :). I did know about GND but was wondering if it was possible to do generically for datatypes
13:35:35 <jmcarthur> ezyang_: I guess the only real usability issue was that it made type inference harder.
13:35:55 <{AS}> I have a bit of ad hoc algorithm in my head, but I believe it is not as simple as DeriveFunctor :)
13:36:04 <jmcarthur> ezyang_: a minor point for somebody who always writes type signatures anyway :)
13:36:25 <Lowl3v3l> AncientPC, ghc?^^
13:36:40 <ezyang_> jmcarthur: I dunno, I could easily imagine non top-level code becoming ambiguous
13:36:53 <AncientPC> Lowl3v3l: lol the compiler? ok... I'll give it a shot.
13:37:07 <jmcarthur> ezyang_: well, i guess there's also the fact that when there's some type that could be an instance of the type class but isn't, i have to revert to qualified names anyway, completely losing the point of the overloading in the first place
13:37:26 <jmcarthur> ezyang_: at least if i need to use both in the same module
13:37:27 <Lowl3v3l> AncientPC, was the first project that came to my mind^^
13:38:08 <ezyang_> jmcarthur: I'm not sure what you mean. What's an example with something like StringLike?
13:39:06 <jmcarthur> ezyang_: well imagine that String and ByteString are instances but Text isn't, and I need to use both ByteString and Text in the same module. now i have to qualify the names that would collide (some from StringLike and some from Text) anyway.
13:39:46 <ezyang_> hmm, ok
13:40:10 <jmcarthur> ezyang_: basically i'm just saying that the type class only provides benefit for instances that are already available. i'm not inclined to write out a (long) instance for every type that fits the pattern.
13:40:27 <ezyang_> ok, that makes it clearer :)
13:41:13 <jmcarthur> ezyang_: constrast with ML style modules, where i can just declare the signature of the module i want to use without necessarily having to write out boilerplatey instances for each module i want to be compatible with it.
13:41:26 <ezyang_> jmcarthur: Yes, I am well aware :)
13:41:38 <jmcarthur> ezyang_: so long as the modules i want to use with it fit the signature in the first place, of course
13:47:46 <jmcarthur> {AS}: i think deriving Monad should be pretty easy for some subset of ideal monads, although it might be ambiguous which monad to choose when more than one is possible. i suppose this is the same situation as with something like Ord, though.
13:48:53 <hpc> jmcarthur: it's a bit less straightforward how to disambiguate than Ord, though :P
13:49:32 <c_wraith> err.  Ord's disambiguation rules are very straightforward.  Did you mean *than* Ord?
13:50:07 <jmcarthur> c_wraith: they are driven by the order of constructors though. i was thinking maybe a similar (kind of weird, to me) disambiguation tactic would have to be used for monad
13:50:55 <c_wraith> I'm totally unsure how you'd write up such a tactic.  I would be interested in seeing the result, though.
13:51:20 <cogrendel> a bit of ad hoc algorithm in my head, but I believe it is not as simple as DeriveFunctor :)
13:51:23 <cogrendel> [16:34] <   jmcarthur>| ezyang_: a minor point for somebody who always writes type signatures anyway :)
13:51:24 <jmcarthur> it's about deciding how return should work.
13:52:03 <jmcarthur> agreed. whatever it is is going to less useful and harder to understand and more limited than DeriveFunctor
13:52:38 <hpc> and not even saving on "overhead" given that usually when something is a Monad you will be using that as the main interface
13:53:56 <c_wraith> DeriveFunctor has the advantage that there aren't choices to make.
13:55:24 * {AS} wonders if DeriveBindable is easier
13:55:47 <{AS}> since no constructor choice is needed for return
13:56:08 <jughead> my aim of learning haskell is that i can go back and apply some useful fp into my python programming. Thats possible ?
13:56:29 <kristof> Sure is, but!
13:56:39 <shachaf> c_wraith: Sure there are. But DeriveFunctor's choices are straightforward.
13:56:41 <kristof> jughead: python doesn't tail call optimize
13:56:48 <c_wraith> jughead: yes.  Though most of what you pick up will be philosophies, rather than actual coding style
13:56:51 <shachaf> (What's the instance for Compose f g?)
13:56:54 <mwhit> jughead: yeah, but i think you'll find it hard to go back
13:56:58 <hpc> jughead: it's entirely possible that learning haskell will render python intolerable :P
13:57:04 <sipa> i hardly use haskell anymore, but i'm it helped me be a better programmer in other languagrs too
13:57:08 <jughead> hpc: :)
13:57:19 <hpc> it'll make perl a fun language though!
13:57:22 <mwhit> jughead: I keep saying "Just gonna get this pet project to a usable state and then go back to my actul work"
13:57:27 <mwhit> still waiting on that
13:57:31 <mwhit> it's just so much more enjoyable
13:57:53 <hpc> (in roughly the same way that getting good at counter strike will make tf2 more fun)
13:58:01 <sipa> hpc: a fun(ctional) language?
13:58:20 <c_wraith> jughead: most of what easily translates back to python is the advantages of immutable dumb data, and writing functions to transform that data.
13:58:30 <mwhit> are you trying to imply that counterstrike is more fun than tf2
13:58:38 <hpc> mwhit: just more demanding
13:58:40 <mwhit> oh
13:58:41 <mwhit> sure
13:58:56 <shachaf> Wait, maybe DeriveFunctor doesn't support Compose f g anyway.
13:59:05 <hpc> you can do most of what haskell does in perl because the syntax is so wonky and flexible
13:59:16 <hpc> but there's way fewer checks and you can do some terrible terrible things
13:59:27 * BMeph would prefer DeriveJoin
13:59:39 <shachaf> Oh, it does, but not when you have PolyKinds on. Of course.
14:01:21 <dfeuer> carter: it seems to point to a general concept of adding phantom type variables to an existing type, making the result Coercible with the original.
14:05:14 * hackagebot spreadsheet 0.1.3.3 - Read and write spreadsheets from and to CSV files in a lazy way  http://hackage.haskell.org/package/spreadsheet-0.1.3.3 (HenningThielemann)
14:10:15 * hackagebot json-rpc 0.1.0.3 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.1.0.3 (XenoGenesis)
14:10:17 * hackagebot json-rpc 0.1.0.4 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.1.0.4 (XenoGenesis)
14:13:37 <Pythonfant> Why is sum and product implemented lazy in ghc? In which case does lazyness work to your advantage here?
14:14:36 <benzrf> Pythonfant:
14:14:40 <benzrf> > 10 < sum [1..]
14:14:45 <lambdabot>  mueval-core: Time limit exceeded
14:14:45 <lambdabot>  mueval: ExitFailure 1
14:14:50 <benzrf> o wait
14:14:53 <Iceland_jack> ...
14:15:02 <benzrf> that only works with nats p:
14:15:34 <benzrf> > 10 < (sum [1..] :: Natural)
14:15:38 <lambdabot>  mueval-core: Time limit exceeded
14:15:43 <benzrf> w/e
14:15:58 <benzrf> was supposed to be a joke, but i guess that doesnt even work
14:16:25 <enthropy> @src sum
14:16:25 <lambdabot> sum = foldl (+) 0
14:16:46 <enthropy> > 10 < foldr (+) 0 [1 :: Natural ..  ]
14:16:48 <lambdabot>  True
14:17:30 <enthropy> Pythonfant: if you have optimizations on, I think you will get the same behavior as if there was   sum = foldl' (+) 0
14:17:44 <int-e> > 10 < sum [undefined, 5 :: Natural, 4, 3, 2, 1]
14:17:46 <lambdabot>  *Exception: Prelude.undefined
14:17:57 <int-e> oh.
14:18:01 <simcity2000> Pythonfant: if nothing else, arithmetic being lazy is at least consistent with haskell being non-strict
14:18:05 <int-e> right, that won't work either.
14:18:31 <shachaf> Pythonfant: sum is foldl rather than foldl' because foldl' isn't in Haskell 98, I think.
14:18:34 <jako_> (Not exactly haskell code) - Given the mconcat function of the Monoid typeclass - Would the following signature be acceptable?: mconcat : R<A, B>[] -> R<A[], B>      - The reason for asking, is that I'm aware of that the function must return the same type - but does this mean the exact same type (same generics too?)
14:18:44 <int-e> > 10 < foldl (flip (+)) 0 [undefined, 5 :: Natural, 4, 3, 2, 1]
14:18:45 <lambdabot>  True
14:18:49 <shachaf> But GHC's strictness analysis will do the thing enthropy said, at least in some cases.
14:19:23 <Pythonfant> ah ok
14:19:40 <Pythonfant> shachaf: which optimization level is actually needed for strictness analysis to kick in?
14:19:54 <shachaf> Probably -O2?
14:20:10 <shachaf> It might be something other than strictness analysis, actually, like a SPECIALIZE. I'm not sure.
14:20:47 <hpc> probably SPECIALIZE, because it can't make that optimization for types like Nat
14:21:25 <shachaf> Well, SPECIALIZE on its own isn't enough, of course.
14:21:53 <pjdelport> jako_: What kind of type signature is that exactly?
14:22:30 <jako_> pjdelport: Mostly F#. - Was more to illustrate the idea, as I dont really have enough experience with haskell to could write it.
14:23:17 <pjdelport> jako_: Does R<A, B>[] in that syntax mean a list of R<A, B> ?
14:23:33 <jako_> pjdelport: Yes.
14:23:35 <Pythonfant> ok, thx for your help
14:23:44 <joshhartigan> (noob) wouldn’t you have to use the cons colon?
14:23:48 <pjdelport> jako_: If so, the result type should probably be R<A, B>
14:23:57 <pjdelport> jako_: Assuming R<A, B> is the thing that's monoidal.
14:25:13 <jako_> pjdelport: It is. You answered my question :-) - Was just glosing over whether R<A, B> and R<A[], B> both could be seen as "m". - But clearly they are two different types as their generics are different.
14:25:16 * hackagebot json-rpc 0.1.0.5 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.1.0.5 (XenoGenesis)
14:25:32 <sbidin> I'm having trouble using the 'connection' package to establish a secure connection, even though I basically copied code that seemed to work. What am I doing wrong? Here's the code, with comments:
14:25:48 <sbidin> http://lpaste.net/109133
14:26:43 <pjdelport> jako_: Note that mconcat is only in the Monoid type class as an optional point of optimization: the fundamental Monoid operations are only mempty and mappend.
14:27:09 <nicoo> pjdelport: Doesn't mconcat have a default implementation ?
14:27:23 <johnw> it should just be foldr (<>) mempty
14:27:54 <johnw> or foldMap id
14:28:23 <benmachine> pjdelport: fun fact: it is also possible to define mempty and mappend using only mconcat
14:28:36 <benmachine> i.e. mconcat is more fundamental than you think
14:28:36 <shachaf> benmachine: Now that we have MINIMAL, it should be done!
14:28:46 <jako_> pjdelport: Yea, just digging into this monad/monoid stuff - so it's bit of a mouthful. I was actually just trying to figure out what to name a function with the type signature: "R<A, B>[] -> R<A[], B>" - and it (almost) looked like mconcat for me :)
14:28:56 <joelteon> well yeah it'd be mconcat [] and mconcat [a,b]
14:28:57 <pjdelport> nicoo: Yep. By the above, i meant that mconcat is only included in the type class so that specific types have the option of overriding the default implementation in case they have a better, type-specific way of doing it.
14:28:59 <shachaf> benmachine: Well, there's the obvious mconcat [], mconcat [a,b], but mconcat is even more "fundamental" than that.
14:29:29 <benmachine> shachaf: blah blah monad algebra blah blah free monoid
14:30:10 <benmachine> sorry, my burrito just finished cooking, all other things became less important
14:30:16 <johnw> you just cooked a monad?
14:30:17 <shachaf> blah blah blah swordfish blah blah blah spoons blah blah blah
14:30:43 <pjdelport> The burrito monad forces strict evaluation.
14:31:01 <johnw> you can put something in the burrito, but it never comes back out
14:31:08 <shachaf> I am so tired of the burrito-monad thing.
14:31:16 <johnw> knew that was coming :)
14:31:32 * benmachine cuddles shachaf
14:31:36 <shachaf> "i knew you wouldn't like it but i said it anyway"
14:31:41 <johnw> because I'm not tired of it
14:31:42 <simcity2000> burritos are messy and generally badly made
14:32:06 <joelteon> hmm...is the main objective of #haskell now not to annoy shachaf?
14:32:13 <johnw> I got tired of "I love monoids, they're easy" but that didn't stop you for months
14:32:31 <stevejb> Hello, I have a simple question. I haven't used Haskell for a while and I am getting myself confused on some simple IO stuff. Code here: http://ix.io/dP4
14:32:56 <benmachine> stevejb: what's the problem?
14:33:19 <stevejb> benmachine:     Expected type: Person -> IO Char
14:33:19 <stevejb>       Actual type: Person -> String
14:33:20 <stevejb>     In the first argument of ‘mapM_’, namely ‘printPerson’
14:33:20 <stevejb>     In the expression: mapM_ printPerson persons
14:33:22 <stevejb>  
14:33:47 <jako_> pjdelport: Thanks for your help :-) - Back to the drawing table, and come up with a kick-ass name for that lazy function.
14:33:54 <benmachine> stevejb: sounds about right. printPerson just makes a string, doesn't say what to do with it
14:33:56 <Cale> stevejb: Oh, perhaps you want mapM_ (putStrLn . printPerson)
14:34:02 <pjdelport> jako_: What does it do?
14:34:35 <stevejb> Cale: that was it
14:34:52 <stevejb> benmachine: :) thanks!
14:35:08 * pharaun . o O (thinks it would be easier and clearer to rename printPerson -> showPerson or derieve a show instance for Person)
14:35:22 <pjdelport> jako_: From the type, it looks like it *might* be some variant of sequence, depending on what the things represent?
14:35:23 <jako_> pjdelport: Well.. it takes a list of R<A, B> and transforms it into a R<A[], B> (where A is now replaced with a List of A). - short: It reduces the List of R<A, B> into R<List of A, B>.
14:35:26 <pjdelport> :t sequence
14:35:27 <lambdabot> Monad m => [m a] -> m [a]
14:35:28 <pjdelport> :t sequenceA
14:35:29 <benmachine> stevejb: for the record I was planning to be more helpful, but Cale beat me to it :P
14:35:29 <lambdabot>     Not in scope: ‘sequenceA’
14:35:29 <lambdabot>     Perhaps you meant one of these:
14:35:29 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
14:35:34 <pjdelport> :t T.sequenceA
14:35:35 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
14:35:57 <Cale> hehe
14:35:58 <pharaun> I should stop using the list maps/sequence/etc and start using the Traversable instances
14:35:59 <pjdelport> jako_: Do R, A and B imply any things in particular?
14:37:44 <jako_> pjdelport: Thought I could explain it better with shorter signatures.. I was wrong - Anyway, the real signature is:      List of Result<Success, Failure> -> Result<List of Success, Failure>         - So what the function does is taking the success values and merge them into a single Result. - darn it's hard to explain when being such a newb to this.
14:38:49 <pjdelport> jako_: Ah, is Result a choice between Success and Failure?
14:39:10 <jako_> pjdelport: That's right.
14:39:49 <benmachine> jako_: if there are multiple failures, do you just get the first one, or what?
14:40:00 <jako_> benmachine: yup.
14:40:05 <pjdelport> jako_: Ah, that's equivalent to sequencing the Either functor in Haskell, then.
14:40:09 <benmachine> yep
14:40:22 <pjdelport> :t sequenceA :: [Either e a] -> Either e [a]
14:40:23 <lambdabot>     Not in scope: ‘sequenceA’
14:40:24 <lambdabot>     Perhaps you meant one of these:
14:40:24 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
14:40:28 <pjdelport> xP
14:40:28 <benmachine> > sequence [Right 1, Right 2, Right 3]
14:40:30 <lambdabot>  Right [1,2,3]
14:40:38 <benmachine> > sequence [Right 1, Right 2, Left "oh no", Right 3]
14:40:40 <lambdabot>  Left "oh no"
14:40:55 <jako_> Exactly!
14:40:56 <pjdelport> But yeah, sequence / sequenceA specialized to type [Either e a] -> Either e [a]
14:41:08 <sbidin> For anyone scouring these logs and perhaps wondering about the solution to my connection problem: the issue was using network's PortNum to wrap the port number. Somehow that messes things up. Instead, simply give the port directly as a literal.
14:41:31 <benmachine> sbidin: oh man, that keeps biting people
14:41:34 <pjdelport> jako_: In Haskell convention, Either's Left is often interpreted as an error value, and Right as a successful value (i.e., it's "right")
14:42:17 <johnw> shachaf: sorry, that was peevish of me, I apologize for being annoying
14:42:23 <jako_> pjdelport: Ah I see. - Well sequence it shall be named!
14:43:01 <pjdelport> jako_: And in terms of the generic type for sequenceA, list or [] is the Traversable in this case, and (Either e) is the Applicative functor instance.
14:44:15 <jako_> pjdelport: That just answered my question about why the sequenceA would work on a list... - which is of course because it's a monad.
14:44:30 <pjdelport> jako_: Nah, it has nothing to do with monads in this case.
14:45:31 <pjdelport> jako_: http://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Traversable.html#t:Traversable
14:45:34 <jako_> pjdelport: Wrong function.. looked at "sequence" which seems to be monad specific (or not really.. to me it just seems to be a synonym for sequenceA).
14:45:44 <simcity2000> sbidin: interesting, I had tried fiddling with it to no avail
14:46:07 <pjdelport> jako_: Right, but in the above, (Either e) is actually the functor/monad, not list.
14:46:53 <pjdelport> jako_: And sequence (without the A suffix) is a bit over-specialized, for historical reasons: although it says Monad, it only actually uses the monad as an Applicative functor (which is more generic).
14:47:26 <pjdelport> So sequenceA is the more "correct" or general type signature for what the older sequence function does.
14:48:12 <t7> @hoogle a -> (a -> b) -> [(a, b)]
14:48:14 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
14:48:14 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
14:48:14 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
14:48:28 <t7> @hoogle (a -> b) -> [a] -> [(a, b)]
14:48:29 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
14:48:29 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
14:48:29 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
14:48:39 <pjdelport> In other words, sequenceA will work for *any* Traversable data structure as the container, not just lists, and will work with any Applicative functor as the contents, not just Monad.
14:50:50 <pjdelport> jako_: If you're new to Haskell, the Functor/Applicative versus Monad split can be a bit confusing, unfortunately... like i mentioned, it's mainly there for historical reasons (the addition of Monad predates the addition of Applicative). But it's in the process of being resolved: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
14:51:10 <BMeph> :t ap zip . map
14:51:15 <lambdabot> (a -> b) -> [a] -> [(a, b)]
14:51:25 <BMeph> t7: ^ ?
14:54:25 <trap_exit> glguy`: hey, just wanted to say thanks for the TH example from yesterday
14:54:57 <trap_exit> without using template haskell, is it possible to autmoatically generate function foo https://gist.github.com/anonymous/792486e9a58ad34bf3f3 ... basically, it returns True if "it uses the same constructor" (even if passed different values), and False otherwise
14:55:16 <trap_exit> I just want to test if two objects used the same constructor
14:55:57 <glguy_> You're welcome
14:56:21 --- mode: glguy_ set -o glguy_
14:57:24 <jako_> pjdelport: I see. - It's kinda the same with fmap and liftM.
14:57:36 <trap_exit> so basically, [| |] / $ in TH, is like `( ... ), and "," (or ~ in clojure) in lisp macros
14:57:36 <pjdelport> jako_: Exactly, yes.
14:58:01 <enthropy> @type (==) `on` toConstr
14:58:01 <lambdabot> Data a => a -> a -> Bool
14:58:03 <trap_exit> [| ... |] opens up a new quasiquotation, and $ allows execution of something inside of it
14:58:16 <trap_exit> @src toConstr
14:58:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:58:48 <enthropy> @let sameConstr x = (==) `on` toConstr x
14:58:49 <lambdabot>  .L.hs:149:26:
14:58:49 <lambdabot>      Couldn't match expected type ‘a -> b0’ with actual type ‘Constr’
14:58:49 <lambdabot>      Relevant bindings include
14:58:49 <lambdabot>        sameConstr :: a1 -> a -> a -> Bool (bound at .L.hs:149:1)
14:58:49 <lambdabot>      Possible cause: ‘toConstr’ is applied to too many arguments
14:59:00 <enthropy> @let sameConstr x = (==) `on` toConstr $ x
14:59:01 <lambdabot>  .L.hs:149:16:
14:59:01 <lambdabot>      Precedence parsing error
14:59:01 <lambdabot>          cannot mix ‘on’ [infixl 0] and ‘$’ [infixr 0] in the same infix expr...
14:59:11 <jako_> pjdelport: "Right, but in the above, (Either e) is actually the functor/monad, not list." - I'm not sure I understand. - How is that?
15:00:49 <Cale> jako_: In which code?
15:01:29 <pjdelport> jako_: (Either e) is what actually provides the functorial/monadic behavior of collecting all Right values, or "erroring out" for any Left value.
15:02:03 <pjdelport> In other words, [] is only being used as a data structure being traversed. ([] has its own behavior as a functor/monad, but it's unrelated to this case.)
15:02:30 <pjdelport> > Right negate <*> Right 5
15:02:31 <jako_> pjdelport: Ah - like fmap, bind etc. that's defined for it (and most likely used to construct the sequence function) ?
15:02:32 <lambdabot>  Right (-5)
15:02:39 <pjdelport> > Right negate <*> Left "boom!"
15:02:41 <lambdabot>  Left "boom!"
15:02:51 <jako_> pjdelport: I see.
15:02:59 <pjdelport> That's another example of (Either e) in action. :)
15:03:32 <hpc> extra credit: pure = Right, and one of the Applicative laws is that f <$> x = pure f <*> x
15:03:36 <hpc> > negate <$> Right 5
15:03:38 <lambdabot>  Right (-5)
15:03:41 <pjdelport> jako_: Right. If you look at the type of sequenceA again:
15:03:41 <pjdelport> :t sequenceA
15:03:42 <lambdabot>     Not in scope: ‘sequenceA’
15:03:42 <lambdabot>     Perhaps you meant one of these:
15:03:42 <lambdabot>       ‘T.sequenceA’ (imported from Data.Traversable),
15:03:44 <mjrosenb> I forget, is there a project that is a successor to grapefruit?
15:03:48 <pjdelport> :t T.sequenceA
15:03:49 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
15:03:53 <pjdelport> (damnit, i keep forgetting :)
15:04:01 <jako_> Hehe :)
15:04:50 <pjdelport> jako_: In Haskell the two type classes are effectively parameters to sequence: the eventual type (either from type inference or an explicit signature) determines which instances of Traversable and Applicative get used.
15:05:19 <pjdelport> > T.sequenceA [Just 2, Just 3, Just 4]
15:05:20 <lambdabot>  Just [2,3,4]
15:05:23 <pjdelport> > T.sequenceA [Just 2, Just 3, Just 4, Nothing]
15:05:24 <lambdabot>  Nothing
15:06:11 <jako_> pjdelport: I see - so the "actual" signature is: Traversable (Applicative a) -> Applicative (Traversable  a)
15:06:21 <AncientPC> How come `cabal update && cabal install lambdabot` installs an old version (4.2.2) instead of the most recent version in Hackage? (4.3.0.1)
15:07:02 <hpc> AncientPC: another package constraint preventing you from installing the latest?
15:07:17 <jako_> pjdelport: And this "sequence" function then knows how to do it's job, by using functions from the Traversable and Applicative used.
15:07:31 <AncientPC> hpc: Is there an easy way to see which constraint caused that?
15:07:40 <pjdelport> jako_: Yep, where those are the actual instances, of course. :) That's why i spoke of sequenceA's type being specialized to [Either e a] -> Either e [a]
15:08:24 <jako_> pjdelport: Makes a lot more sense now :)
15:08:58 <pjdelport> jako_: The specialization is easier to see if you reorganize it slightly: [] ((Either e) a) -> (Either e) ([] a)
15:08:59 <jako_> pjdelport: Not sure my statmenet about how the "sequence" function is composed is right though.
15:09:32 <pjdelport> Or substituting "List" for "[]": List ((Either e) a) -> (Either e) (List a)
15:10:31 <pjdelport> So in the context of the original signature, the Traversable t type parameter is specialized to [], and the Applicative f type parameter is specialized to (Either e).
15:10:38 <jako_> pjdelport: Yea, that makes it easier to see what's going on.
15:11:30 <pjdelport> It's perhaps even clearer if you use e.g. Maybe instead of Either a: List (Maybe a) -> Maybe (List a)
15:11:53 <jako_> pjdelport: Yup. - And the reason for only Traversable and Applicative types can be used, is that the sequence function uses the functions from those two to do the work? - Or is that wrong to assume?
15:12:05 <pjdelport> You can think of Maybe as being the same as Either, except that the Left / Nothing / error value does not have any additional parameter associated with it.
15:12:59 <pjdelport> jako_: Right, that's how sequenceA is defined. It's actually a method of the Traversable type class.
15:13:55 <pjdelport> In fact, the minimal definition of any Traversable instance is either traverse or sequenceA (each can be defined in terms of the other).
15:15:47 <jako_> pjdelport: Ah :)
15:27:05 <jako_> pjdelport: Thanks for your time and help - I appreciate it.
15:29:07 <mjrosenb> I cannot seem to build grapfruit-frp via cabal :-(
15:31:12 <pavonia> mjrosenb: What errors do you get?
15:32:32 <mzero> woot! Haskell Platform 2014.2.0.0 is released!
15:33:12 <johnw> yay!
15:33:30 <johnw> I'm more excited about that spreading 7.8.3 around more
15:34:12 <mzero> me too!
15:34:22 <mzero> also - excited that we can now track GHC much more closely
15:34:58 <merijn> I'm excited that I can reinstall haskell easily after breaking everything with my upgrade to Mavericks this week :p
15:35:46 <mzero> yes - the new platform handles Mavericks (and clang) right out of the installer
15:35:52 <mzero> and doesn't need the wrapper script anymore!
15:38:17 <Rufflewind_> So, it seems haddock needs the symbol to be present in scope in order to link to it, but if I add it to scope then GHC will complain that the symbol is unused (-Wall) ... can't make everyone happy :(
15:38:56 <merijn> Rufflewind_: Huh, do you have a minimal example you can lpaste?
15:39:10 <ezyang> Rufflewind_: You should report that as a bug
15:39:30 <johnw> hmm.. donwload link for Mac is broken though
15:40:11 <Rufflewind> i'm not entirely sure if it's a bug ... GHC isn't supposed to care about what haddock does ("separation of concerns")
15:43:10 <Rufflewind> merijn: http://lpaste.net/109138
15:45:37 <merijn> I guess I don't really see why you would refer to Ratio if it's literally never used in the source?
15:47:22 <Rufflewind> merijn: Well I doesn't have to, I'm just explaining something in the documentation and mentioning Ratio in passing.  But I do indeed use Ratio in the actual code, I just don't have it anywhere in the type signatures.
15:47:46 <shachaf> Rufflewind: You can use a qualified name, as in 'Data.Ratio.Ratio'
15:48:38 <Rufflewind> shachaf: Oh, that works wonderfully, thanks!
16:10:27 <daganu> Hello, I've been googling for a Vim/Haskell setup, but I'm afraid what I found is old or incomplete
16:10:57 <hpc> i am probably in the minority here but i use vanilla vim
16:11:44 <daganu> Yes, at this time (learning Haskell) me too, but I'm a heavy Vim user and miss some integration
16:11:46 <hodapp> I'm on Emacs...
16:12:20 <daganu> Too old to change my editor hodapp ;)
16:12:57 <hodapp> When did you change your language to Haskell? :P
16:13:02 <hpc> heh
16:13:20 <hpc> unfortunately i don't know much about setting up the vim plugin for haskell
16:14:05 <strg> daganu: this seems to be pretty new: https://github.com/lukerandall/haskellmode-vim
16:14:48 <raichoo> daganu: I wrote some scripts to improve highlighting and indentation. It was for my personal use only but people seem to like it: https://github.com/raichoo/haskell-vim
16:14:53 <daganu> hodapp: no changing, just wanted to learn another one but I see where your are trying to drive me....
16:15:38 <hodapp> daganu: I don't care if you use vim
16:17:06 <daganu> raichoo: Checked, thanks
16:17:24 <daganu> I'm gonna try with http://vimawesome.com/plugin/neco-ghc for completion
16:17:24 <raichoo> daganu: Patches welcome :)
16:18:43 <mjrosenb> http://bpaste.net/show/584984/ -- any ideas how to fix this?
16:35:46 <systemfault> Woohoo, 7.8.3 :)
16:41:54 <bb010g> Shouldn't http://www.haskell.org/haskellwiki/Haskell be updated with the news of the latest HP?
16:43:26 <pjdelport> "This page was last modified on 9 September 2013" :)
16:44:01 <oisin721> I'm trying to install cabal from source on OS X 10.9 - but I can't find the executables. It seems to install with no problems, however, there is no ~/.cabal folder created. Is there somewhere else I should be looking?
16:44:16 <joelteon> ~/.cabal/bin
16:44:48 <oisin721> joelteon: That's not created, unfortunately...
16:45:06 <int-e> oisin721: so you used Setup.lhs directly?
16:45:11 <joelteon> oh sorry, the last half of your line was hidden behind a window
16:45:14 <joelteon> my mistake
16:45:24 <joelteon> what about /usr/local/bin
16:45:30 <oisin721> int-e: No - I run the four (?) commands located in the README.
16:45:39 <joelteon> there's a bootstrap.sh
16:45:39 <oisin721> int-e: Maybe from source isn't the correct phrase
16:45:57 <benzrf> hmmm
16:46:06 <oisin721> joelteon: Nothing in there either - how do I use the bootstrap?
16:46:15 <benzrf> :t traverse
16:46:15 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
16:46:22 <benzrf> no waigt
16:46:25 <benzrf> :t T.sequenceA
16:46:25 <lambdabot> (Traversable t, Applicative f) => t (f a) -> f (t a)
16:47:33 <oisin721> Sorry, my mistake, I've missed running runghc...
16:49:16 <int-e> oisin721: ok, I'm confused. Looking at the readme of cabal-install, there's only one command to be run, ./bootstrap.sh
16:49:42 <oisin721> int-e: Sorry, not cabal-install, just cabal? If that makes sense?
16:49:47 <oisin721> https://github.com/haskell/cabal/blob/master/Cabal/README.md
16:49:59 <int-e> oisin721: if you're looking at Cabal (capital C), that's a library, there won't be any executables.
16:50:26 <oisin721> int-e: Oh, I was under the impression that that library granted me the ability to cabal ____ package
16:50:36 <int-e> (To make the confusion complete, the library is used by cabal-install.)
16:50:37 <oisin721> with ____ being install, unregister, etc
16:50:41 <int-e> oisin721: you need cabal-install
16:50:55 <oisin721> int-e: Ok, thanks! :D
16:53:17 <oisin721> int-e: Much easier! Thanks, it works now.
17:00:28 * hackagebot json-rpc 0.2.0.0 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.2.0.0 (XenoGenesis)
17:01:16 <dreams> What techniques do you guys use to debug Haskell?
17:02:00 <schell> i guess it depends on what kind of debugging
17:02:09 <ezrios> the facedesk technique
17:02:13 <dreams> schell: say a logical bug in a large program
17:02:26 <Axman6> depends on the problem, but Debug.Trace.trace is often a good way to start if you code compiles but produces incorrect results
17:02:28 <schell> you’ve got Debug.Trace, which just unsafe traces strings
17:02:50 <schell> you can use GHCI to inspect your functions
17:02:51 <benzrf> :t typeOf
17:02:52 <lambdabot> Typeable a => a -> TypeRep
17:02:54 <benzrf> hmm
17:03:15 <dreams> Axman6: schell, that requires a lot of annotation and causes non-termination + interleaving output.
17:03:16 <schell> you can also use GHCI to set break points and such, but I’ve never needed to do that
17:03:46 <dreams> schell: GHCI shows you lazy evaluation which is confusing, there is no direct relation between invocations.
17:04:28 <schell> i know there’s a way to ctrl-c and print a stack trace in ghci if you suspect your function isn’t terminating terminate
17:04:38 <schell> s/terminate//
17:05:30 <dreams> schell: well the stack trace is also lazy.
17:06:05 <schell> if it’s a logical bug you can open that module in ghci and hand feed the functions you think are at fault
17:06:46 <dreams> schell: well that's the thing, the module is large, and I can't tell which function has the bug.
17:07:15 <dreams> schell: what I am basically saying is that there is no decent debugger for Haskell, when you compare it to gdb.
17:07:54 <schell> mmm, that’s true in a sense, but i think it’s most haskeller’s opinion that a debugger similar to gdb isn’t needed
17:08:07 <dreams> schell: why?
17:08:21 <corgifex> because we have it (ghci) and no one likes it
17:08:39 <schell> you can usually pull apart your functions and test them one by one (to reason about them)
17:09:17 <RyanGlScott> Haskell Platform question: is there a way to check what version of MinGW is shipped with the Windows 2014.2.0.0 bundle?
17:09:34 <dreams> corgifex: the ghci solution is just there because its better than nothing. And you think it sucks because its not declarative.
17:09:46 <corgifex> do I?
17:09:50 <schell> dreams: is your module doing much IO?
17:10:13 <dfeuer> I'm reading the 2014 Coercions technical report, and something's not matching up. Is Figure 2 missing one set of newtype instances, for things that look like newtype X = MkX Y ? They seem to discuss such in the text around it, but I don't see the rules.
17:10:24 <dreams> corgifex: try Hat for a small program and you'll see what I mean. But again, Hat doesn't support full Haskell & libraries.
17:10:46 <dreams> schell: there is no program.
17:11:00 <dfeuer> That is, "Safe, Zero-cost Coercions for Haskell (extended version)"
17:11:07 <schell> the module though, does it do a lot of IO?
17:12:58 <schell> well, i guess it doesn’t matter much - you can use Debug.Trace to trace out parts of that module until you zero in on the culprit and then use ghci from there on to figure out what’s going on
17:13:17 <schell> or you could learn how to use ghci to step through
17:13:47 <schell> dreams: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
17:14:18 <dreams> schell: a tip
17:14:28 <dreams> Don't use trace
17:14:33 <dreams> use Debug.Trace.Hood
17:14:47 <dreams> its way better, it doesn't have the nasty things with trace.
17:15:18 <dreams> schell: even with infinite lists ..etc. It preserve laziness.
17:16:34 <schell> i haven’t run into the nastiness of trace yet
17:16:49 <trap_exit> Someone should build an odesk/elance for haskell. You specify the Type of the function. Then, you can automatically test if the submitted code compiles.
17:17:02 <schell> but thanks, are you talking about http://hackage.haskell.org/package/hood?
17:17:10 <dreams> schell: yes.
17:34:15 <Mathnerd314> is there a function that's similar to Map a b -> Map b c -> Map a c ?
17:37:55 <copumpkin> nowhere that I know of, but there could be!
17:38:18 <Cale> You can do it with mapMaybe
17:38:27 <copumpkin> yeah
17:38:36 <copumpkin> mapMaybe (lookup other)
17:38:43 <Cale> :t \m1 m2 -> M.mapMaybe (flip M.lookup m2) m1
17:38:44 <lambdabot> Ord a => M.Map k a -> M.Map a b -> M.Map k b
17:41:53 <pjdelport> :t flip $ M.mapMaybe . flip M.lookup
17:41:54 <lambdabot> Ord a => M.Map k a -> M.Map a b -> M.Map k b
17:42:02 <pjdelport> (obligatory unreadable version)
17:45:32 <Clint> hmm, is that more efficient than doing a M.lookup >>= M.lookup
17:46:47 <Cale> Clint: it is if you need to do many such lookups
17:47:56 <Clint> good to know
17:51:34 <Cale> Clint: In fact, in the case where you look up a single key twice, it should already be better
17:51:41 <Cale> (I think)
18:03:19 <Clint> Cale: i'll change my code
18:05:34 * hackagebot active 0.1.0.16 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.16 (BrentYorgey)
18:23:07 <eazar001> @hoogle uncurry
18:23:09 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
18:23:09 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
18:41:20 <Rufflewind> is it possible to write a rewrite rule that matches a return type?  e.g. for a polymorphic function fromFoo :: Num a => Foo -> a, I want to write a rule like this: fromFoo x = id x :: Foo
18:44:42 <Mathnerd314> Cale: ok. although what I really have is a Set Name, a function Name -> String, and a Map String X. I want a Maybe (Map Name X) (Nothing in the case that a Name's string is missing from the map)
18:48:04 <Mathnerd314> Cale: so is there a function similar to mapMaybe for Sets?
18:48:53 <qrada__> ok i think i've pulled out all of my hair.. if someone could take a quick look at this code, it'd be greatly appreciated.. http://hastebin.com/putozetipo.coffee .. basically, i'm not sure if i'm approaching this in a sane way.. even so, i'm unable to call 'new', it gives me the following error: add a type signature etc
18:49:02 <qrada__> k <- new (0 :: Int)
18:49:40 <qrada__> however, i'm able to do things like this: inc $ CntI { _nI = 0 }
18:49:50 <qrada__> that works.. the instances work when i pass it the CntI record
18:50:17 <qrada__> is 'new' impossible? should i have a 'mkNew' living outside of that counter class?
18:52:22 <Mathnerd314> qrada__: I think you can write data Counter t = Cnt { _n :: t }, in which case you can avoid the class and GHC will infer the types properly
18:54:02 <Mathnerd314> qrada__: the multiparameter type class, that is. You can still have class Cnt t where new :: t; inc :: t -> t
18:54:40 <qrada__> thanks Mathnerd314, sounds alot simpler.. i guess the reason why im using classes/instances is because my 'CntX' record could be different.. i want ghc to pick the right inc/new/etc based on the c m t param types
18:54:48 <merijn> qrada__: Maybe try something simpler like this
18:54:52 <Cale> I'm not entirely sure why you're using IO at all. Nothing you're doing has any effects.
18:54:56 <Cale> Not even mutation.
18:55:08 <qrada__> Cale: right, it's test code for something else, which uses effects/io
18:56:42 <lfairy> qrada__: right now you only have c -> t, which means "the type c fully determines the type t"
18:57:04 <lfairy> but you don't state the other direction, t -> c
18:57:22 <peterjoel> Hi, can anyone help me with complex powers? ie:  (2 :+ 3) ^ 2
18:57:24 <lfairy> so when you only give t, as in new (0 :: Int), the compiler can't derive c from it
18:57:27 <peterjoel> How would I do that?
18:57:31 <vanila> peterjoel, ** should work
18:57:36 <qrada__> lfairy: you have to be kidding me..
18:57:38 <qrada__> lfairy: you have to be kidding me..
18:57:41 <vanila> > (2 :+ 3) ** 2
18:57:41 <qrada__> :D
18:57:42 <lambdabot>  (-5.0) :+ 12.0
18:58:16 <peterjoel> oh. I thought I tried that!
18:58:19 <merijn> qrada__: Here: http://lpaste.net/109144
18:58:22 <peterjoel> thanks ;)
18:58:23 <qrada__> lfairy: that fixed it.. basically i had no idea about functional dependencies and this journey of errors lead me to that extension.. whcih i figured would fix it.. but man o man i never thought of that
18:58:27 <qrada__> awesome
18:58:29 <Cale> > (2 :+ 3)^2
18:58:30 <lambdabot>  (-5.0) :+ 12.0
18:58:33 <Cale> ^^ also works
18:58:38 <merijn> qrada__: The original seems like gratuitous typeclass abuse to me
18:58:39 <qrada__> marijn, cool thanks lemme check
18:58:59 <peterjoel> yes, I think I have another problem that is confusing things
18:59:04 <peterjoel> thanks anyway
18:59:39 <Cale> qrada__: If you're ever having trouble with typeclasses and fundeps and stuff, always consider just making a record datatype with fields for the methods of your typeclass.
19:00:04 <Cale> qrada__: Then you can supply values of that type explicitly and not have to worry about ambiguities of instance selection.
19:00:08 <merijn> Yeah, the existential-antipattern applies, even in the absense of existentials :)
19:00:15 <merijn> @where existential-antipattern
19:00:15 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
19:00:22 <qrada__> i read that the other day
19:00:42 <merijn> See also: http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
19:01:00 <qrada__> ya i'm trying to figure out how i want to design this abstraction library that's in my head
19:01:08 <merijn> qrada__: basically, anything typeclasses can do, records can do and in a lot of cases like this it's much easier to have a polymorphic record like I suggested :)
19:01:14 <qrada__> i've gone through a ton of experimental iterations..
19:01:21 <qrada__> ya..
19:01:45 <griotspeak> Hello
19:01:46 <qrada__> that code is definitely alot simpler
19:01:50 <qrada__> cleaner
19:02:15 <vanila> hi
19:02:30 <merijn> qrada__: Allowing monadic updates like you had is pretty simple too
19:03:43 <merijn> qrada__: See my annotation: http://lpaste.net/109144
19:04:04 <merijn> Actually, that needs a Monad constraint on inc, because of the do notation, but you get the idea
19:04:28 <qrada__> ya.. thanks alot checking
19:05:09 <merijn> It could probably be written a bit cleaner, but I was lazy
19:05:40 * hackagebot diagrams-cairo 1.2 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2 (BrentYorgey)
19:05:44 <qrada__> merijn: so can i run this small concept by you.. ok so, i want a 'Counter' type (record or class etc).. I'm creating a general interface for counters: new, incr, decr, incrBy, decrBy, reset.... so, my backend implementations of counter for example, will be: mvar, redis, mysql, stm, etc...
19:06:42 <qrada__> with that info, (if you can derive anything from it), do you think the 'data record' approach is still better than type classes? im going to read your 'scrap your typeclasses' article you posted.. already read the existential one which saved my life because i was actually using existentials at one point as part of my experimentation
19:07:49 <lfairy> qrada__: that still seems like something best done using a record
19:08:17 <merijn> qrada__: Yeah, I don't really think typeclasses gain you much here. They only thing that you'd really gain is a "new" operation that creates a simple counter. But you can easily just export a bunch of "new" operations instead
19:08:29 <lfairy> data Counter m a = Counter { increment :: m (), getValue :: m a, ... }
19:08:48 <lfairy> then define newMVarCounter, newSTMCounter... as necessary
19:09:03 <merijn> Exactly
19:09:04 <qrada__> ya
19:09:10 <qrada__> ok thanks so much folks
19:10:04 <merijn> qrada__: The "scrap your typeclasses" thing is (as is noted in the edit) perhaps a bit overzealous in preaching against typeclasses, but it's a good illustration of how everything implemented by typeclasses can be implemented by records
19:10:40 <merijn> qrada__: Developing a "feel" for when typeclasses make sense is a matter of practice and experience :)
19:11:25 <qrada__> ya.. i've got caught up in trying to learn all of these 'advanced haskell things'
19:11:58 <qrada__> need to make sure i don't overcomplicate things
19:12:14 <shachaf> Surprise, you can compile Haskell to Haskell-without-type-classes. And you can even do it by hand!
19:13:40 <Fuuzetsu> hand compilers are the best
19:13:47 <Fuuzetsu> back in my day…
19:15:01 <qrada__> my strategy is to pull my hair out for 3 days and if i still havn't figured it out.. ask in #haskell and get schooled in < 1 minute
19:15:17 <benzrf> qrada__: he he he
19:15:34 <Fuuzetsu> I just ask
19:21:19 <merijn> qrada__: A lot of tricks/techniques of thinking functional are really obvious once you see them, but before then...
19:21:38 <merijn> qrada__: Also, the struggle makes you realise why the tricks are a good idea ;)
19:22:28 <merijn> qrada__: We could start telling newbies "you don't wanna use typeclasses for everything!" (actually, I think most people do...), but then they go "pah! What do you know, typeclasses are awesome, I'll use them *everywhere*" :)
19:23:11 <shachaf> Sure, people often err on the side of using type classes too much.
19:23:13 <merijn> Admittedly, typeclasses are awesome, it just turns out you don't need a whole lot of different ones
19:23:35 <shachaf> But the answer isn't "here's how you can do the exact same thing except by hand so you write -> instead of =>", it's to write the program differently.
19:24:03 <mzero> also, laziness often obviates the need for typeclasses
19:24:12 <Ankhers> Has anyone upgraded to the latest platform and tested threading?
19:24:49 <mzero> on which platform?
19:24:52 <mzero> er, os
19:25:00 <Ankhers> OS X Mavericks
19:25:35 <merijn> Ankhers: I was about to, so :)
19:25:58 <Ankhers> I will actually try this on a windows machine to see if I am getting the same issue.
19:26:07 <merijn> Which issue are you getting?
19:26:54 <Ankhers> merijn: I am building a warp application and I am getting the same requests per second whether I use 1-3 cores. Previously I was getting vastly different numbers.
19:27:15 <merijn> Ankhers: Are you building with the threaded runtime system?
19:27:20 <mzero> Ankhers: I've run the nofib benchmarks with threading... all worked as expected (and I ran it on 10.9, 10.8, 10.7 and 10.6!!!)
19:27:47 <Ankhers> my cabal file has "ghc-options: -O2 -threaded"
19:27:56 <merijn> hmmm
19:30:30 <gamegoblin> Hmmm I think the answer is no, but is there a way to get a list of all of the constructors of a datatype (without hard coding them all)
19:31:04 <vanila> gamegoblin, the problem is you can't actually make such a list - the constructosrs can have different tyes
19:31:06 <vanila> e.g.
19:31:10 <vanila> :t [Nothing, Just]
19:31:11 <lambdabot>     Couldn't match expected type ‘Maybe a’
19:31:11 <lambdabot>                 with actual type ‘a0 -> Maybe a0’
19:31:11 <lambdabot>     Probable cause: ‘Just’ is applied to too few arguments
19:31:29 <mzero> gamegoblin: is it a simple "enum-like" data type?
19:31:41 <gamegoblin> vanila: good point. In my case they are all of the same type so I didn’t even think about that
19:31:43 <gamegoblin> mzero: yes
19:32:18 <mzero> oh, then just derive (Enum, Bounded, Eq, Ordered)    and you can use [minBound..maxBound]
19:32:28 <gamegoblin> mzero: oooo that’s clever. Gotcha.
19:32:32 <benzrf> it's Ord isnt it
19:32:35 <mzero> yes,
19:32:43 <mzero> fingers typing ahead of brain
19:32:51 <gamegoblin> very very clever
19:32:56 <vanila> nice one
19:33:06 <mzero> actually... it's exactly what Bounded is there for!
19:33:07 <merijn> gamegoblin: It depends on what you want it for?
19:34:24 <mzero> >[minBound..maxBound] :: [Ordering]
19:34:33 <tsani> Can't you do something with Typable and Data ?
19:34:51 <tsani> (I don't really know how they work, but they seem a propos.)
19:34:52 <mzero> > [minBound..maxBound] :: [Ordering]
19:34:53 <lambdabot>  [LT,EQ,GT]
19:35:14 <merijn> tsani: Typeable doesn't help, probably. But data and/or generics might, depending on what you want to do with them
19:35:16 <gamegoblin> mzero: perfectly what I need
19:35:19 <merijn> Hell, TH might help
19:36:31 <gamegoblin> Can you use TH to get the current line number? I have some logging functions which do some unsafePerformIO and I’d like them to be able to note their line number
19:36:34 <enthropy> > dataTypeOf (Just '3')
19:36:36 <lambdabot>  DataType {tycon = "Prelude.Maybe", datarep = AlgRep [Nothing,Just]}
19:37:04 * mzero shudders at unsafePerformIO for logging....
19:37:12 <gamegoblin> mzero: Any better suggestions?
19:37:13 * tsani gasps.
19:37:46 <mzero> not without knowing the scenario... but really, that way lies madness... because you'll discover it is never called when you expect it!
19:38:01 <tsani> I've used Debug.Trace for some print-style debugging.
19:38:08 <tsani> Maybe you could use Writer ?
19:38:10 <mzero> (mind you, eventually, you'll come to expect it... once you internalize the evaluation order in Haskell...)
19:38:18 <gamegoblin> tsani: Exactly, it’s just like a souped of version of Debug.Trace
19:38:23 <gamegoblin> souped up*
19:38:35 <mzero> To be honest, I've just weaned myself off logging as a mechanism
19:38:47 <gamegoblin> mzero: It’s a web server, so logs are fairly important
19:39:01 <mzero> well... that is a different kind of logging
19:39:04 <Maior> oh
19:39:28 <mzero> if you're doing unsafePerformIO... you're in pure code... and so I'm guessing you're logging as you're not sure if your code is doing the right thing
19:40:27 <gamegoblin> mzero:  not necessarily, but sometimes it’s convenient to have some intermediate results which never leave the pure code in the logs
19:41:00 <mzero> If you really really want to accumulate information about a compuation, as a sort of "side log of how and why this value was computed"...  then use Writer as tsani suggested
19:41:32 <Mathnerd314> is there a WriterT' w m a = (w, m a)? for comparison, WriterT is m (w,a)
19:41:52 <johnw> which register allocator does -O2 use?
19:43:54 <merijn> Mathnerd314: That doesn't seem very useful...your effects couldn't log anything then
19:43:56 <mzero> Mathnerd314: hmmm... I'd have to deep think on that... but I'm not sure that could even make sense
19:44:22 <mzero> because you can't get the w's out of the stacked computation on m a without running it
19:44:45 * mzero and merijn think alike
19:45:33 <benzrf> :t sequence `asAppliedTo` (undefined :: (w, m a))
19:45:34 <lambdabot>     Couldn't match expected type ‘[m a]’ with actual type ‘(w0, m0 a0)’
19:45:34 <lambdabot>     In the second argument of ‘asAppliedTo’, namely
19:45:34 <lambdabot>       ‘(undefined :: (w, m a))’
19:45:39 <benzrf> :t T.sequenceA `asAppliedTo` (undefined :: (w, m a))
19:45:40 <lambdabot> Applicative f => (w, f a) -> f (w, a)
19:45:45 <benzrf> ;)
19:46:14 <benzrf> it's homomorphic!!!!
19:47:47 <Mathnerd314> hmm, maybe I want a Comonad
19:48:17 <Mathnerd314> https://hackage.haskell.org/package/comonad-4.2.2/docs/Control-Comonad-Env.html
19:48:26 <Mathnerd314> that looks right
19:48:41 <benzrf> Mathnerd314: the implementation of your WriterT' is trivial
19:49:26 <benzrf> oh wait no im an idiot
19:49:29 <benzrf> NEVER MIND
19:49:30 <benzrf> =
19:49:30 <benzrf> D
19:49:51 <Mathnerd314> and every Comonad is a monad transformer: http://comonad.com/reader/2011/monad-transformers-from-comonads/
19:50:19 <shachaf> No, you can make a monad transformer out of every Comonad.
19:50:25 <benzrf> when i first saw Cokleisli i thought it was some new Cok leis li, not Co Kleisli
19:51:00 <shachaf> Oh, that's not even the article I was thinking of. Either way.
19:52:38 <benzrf> instance Monad (Either way)
19:53:30 <benzrf> ok i think i understand the env comonad
19:54:14 <Mathnerd314> shachaf: right, comonads are not directly monads
19:54:49 <Mathnerd314> I just realized that after reading the post :p
19:55:11 <benzrf> Mathnerd314: Env looks like it's Coreader or something
19:55:14 <benzrf> er
19:55:38 <benzrf> it looks like it's similar to Reader, except that the mobits become the arrows
19:55:45 <benzrf> or like, something, man
19:56:40 <benzrf> no wait
19:57:20 <Mathnerd314> env is coreader, that's in the documentation
19:57:24 <benzrf> oh
19:57:33 <Mathnerd314> "The Env comonad (aka the Coreader, Environment, or Product comonad) "
19:58:18 <benzrf> a `Kleisli (Reader e) a b' is `e -> a -> b'; a `Cokleisli (Env e) a b' is `(e, a) -> b'
19:58:21 <shachaf> "coreader" is a somewhat dubious name for it.
19:58:33 <benzrf> they're isomorphic
20:01:55 <NemesisD> hey guys. i think i may be at the brim of cabal hell. nuked my sandbox, initialized it, installed and it complains that reinstalls would break criterion
20:02:10 <NemesisD> i have a fresh sandbox, why is anything even being reinstalled
20:02:46 <NemesisD> should i do --avoid-reinstalls?
20:03:24 <lfairy> NemesisD that sounds suspicious
20:03:37 <lfairy> where is criterion installed?
20:03:41 <NemesisD> things are humming along with --avoid-reinstalls
20:03:52 <NemesisD> i went to my home directory and did cabal list --installed and see no criterion
20:08:58 <Elora22>  Hi! I give you some videos. I hope you like! http://bit.ly/1lLuZsn
20:09:50 <Fuuzetsu> yep, it's porn, NSFW and all that
20:09:55 <jughead> hahaha
20:10:06 <Fuuzetsu> some op get ‘Elora’ over there off
20:15:27 <Mathnerd314> hmm, so my real type is (Set a, Map a b -> m c). It's not a Comonad since you can't extract the m c, and it's not a Monad since you can't do join. It is a functor though
20:16:32 * Mathnerd314 checks the Typeclassopedia
20:16:45 <aaronlevin> anyone know if there is a way to make working with Free Monads of Coproducts easier w.r.t. to writing interpreters on the free monad?
20:17:07 <Fuuzetsu> write a DSL for working with DSLs
20:18:12 <aaronlevin> I am finding it really cumbersome to destruct the nested Eithers, grabbing instructions, etc. just curious if this code has already been written. i can't find anything in `free` or `comonad`
20:18:30 <dfeuer> It feels like there should be a way to explicitly create a new datatype U based on an existing one T, formed by adding one or more phantom type variables (and maybe representational ones?), renaming the data constructors, and get a Coercible instance.
20:19:38 <Fuuzetsu> can't you do this in TH
20:25:20 <dfeuer> Fuuzetsu: I don't know, but I doubt it. Coercible is magic, like Typable—you can't declare instances.
20:25:39 <Fuuzetsu> oh
20:31:59 <gsingh93> I want to print out the values of some computations to the user. these computations are happening inside functions that currently don't return IO actions. what should I do? make all these functions return IO actions along with their regular return values?
20:33:25 <mzero> You mean you want both the computations, and some additional data with the compuatation (like a log, say)
20:33:29 <aaronlevin> gsingh93: write a wrapper function that takes those functions and creates an io action that uses them and prints a message to your users.
20:33:32 <mzero> and you will eventually want to print out that log data?
20:34:17 <gsingh93> mzero: yea, pretty much. the computations return stuff, but I want to print out some intermediate values going on inside the functions
20:34:17 <aaronlevin> gsing93: something like: wrap :: (a -> b) -> a -> String -> IO b
20:34:21 <gsingh93> and not just for debugging
20:34:58 <mzero> if you turn all your functions into IO actions so that you can log from within them
20:35:02 <mzero> you loose a lot
20:35:10 <aaronlevin> gsingh93: wrap f a msg = do putStrLn msg; return f a
20:35:11 <mzero> for one, they become harder to compose
20:35:58 <mzero> for another, you've not lost the power of purity - you can never ever mix these compuations without logging ... and you'll never know *what* they actually do... they are in IO, they could launch missles!
20:36:22 <mzero> so perhaps a better idea is to have them reutrn ([String], a)
20:36:32 <mzero> or even just be in a Writer monad
20:37:01 <mzero> then you can much more easily compose them, control them, and let other code, elsewhere decide what to do with the log output
20:37:57 <gsingh93> thanks, i'll look into the Writer monad
20:39:24 <aaronlevin> gsing93: whatever method you chose, keep your original functions pure and add effects by wrapping them or injecting them into a monad.
20:39:48 * dfeuer looses the hounds upon mzero. One must not confuse the verbs "lose" and "loose".
20:42:09 <drbean> http://haskell.org/hoogle is easy to remember. What is a good way to remember http://hayoo.fh-wedel.de/
20:42:27 <drbean> What does fh-wedel mean?
20:44:12 <HeladoDeBrownie> johnw, I've run into a baffling interaction between Feedly and your blog, and I can't tell who's at fault. Unless you provide the direct RSS feed URL to Feedly, it misses the post you made in June. This problem seems to affect maybe tens of people. I checked and as far as I can tell your site does things legit.
20:44:36 <johnw> hmm
20:44:36 <HeladoDeBrownie> Just thought you might want to know, or have some idea.
20:44:45 <johnw> I have no idea, but I'm glad to know, thank you
20:44:53 <johnw> I recently switched to Hakyll, so it should be a trivial fix
20:46:08 <drbean> Apparently, Die Fachhochschule Wedel
20:46:51 <lfairy> drbean: I just use DuckDuckGo
20:47:03 <lfairy> they let you search hayoo using the !hayoo command
20:47:11 <benzrf> who uses hayoo
20:53:09 <ruukasu> implying benzrf
20:55:53 <drbean> https://duckduckgo.com/lite/?q=wedel
21:00:39 <ruukasu> https://s3.amazonaws.com/lyah/setnotation.png
21:00:59 <ruukasu> what do the things that look like euro and namecoin symbols mean?
21:01:55 <daneeklu> "element of set", and "natural numbers" I believe
21:03:26 <Cale> yes
21:03:56 <Cale> This is the set of values 2 * x, for x in the set of natural numbers, and x less than or equal to 10.
21:03:57 <ruukasu> daneeklu, Cale: so that image would be [2, 4..20]?
21:04:03 <Cale> yeah
21:04:40 <Cale> Or [0,2..20], depending
21:05:08 <ruukasu> natural numbers [1..], right?
21:05:10 <daneeklu> http://en.wikipedia.org/wiki/Natural_number
21:05:19 <Cale> Most authors these days like to include 0 among the natural numbers
21:05:26 <daneeklu> as noted here, sometimes the set includes 0, and sometimes not, so either of those yes
21:05:44 <Cale> (especially computer scientists and logicians!)
21:05:47 <shachaf> In just about any context relevant to #haskell, 0 is a natural number.
21:05:56 <Mathnerd314> is there a way to use fixities to get a <$> b <*> c <$> d to parse as a <$> b <*> (c <$> d) ?
21:05:58 <dfeuer> It's nice to make the natural numbers look like the first infinite ordinal.
21:06:23 <ruukasu> I thought the only difference between natural and whole numbers was 0 and not 0?
21:06:29 <Cale> Also it's nice for the natural numbers to correspond to the sizes of finite sets
21:06:45 <ruukasu> if there's already a term for natural w/ 0, why screw with the definition of natural?
21:06:50 <Cale> ruukasu: Nobody in mathematics ever talks about "the whole numbers"
21:06:55 <daneeklu> ruukasu: Z is the set of integers (drawn in the same style as N), might be good to remember
21:07:05 <Cale> That's as far as I can tell, something invented by highschools
21:07:34 <Cale> ruukasu: If you want to be precise, you can say "the positive integers" or "the nonnegative integers"
21:08:08 <shachaf> I have a book that uses "positive" to mean ≥0 and "strictly positive" to mean >0
21:08:14 <Cale> heh
21:08:19 <ruukasu> positive ints being [1..] and nonnegative ints being [0..]?
21:08:20 <dfeuer> Of course then you get weirdos calling 0 positive.
21:08:33 <dfeuer> Yes, what shachaf said.
21:08:35 <Cale> ruukasu: yes
21:08:44 <dfeuer> Mathematicians are an inconsistent lot.
21:08:51 <shachaf> The word "positive" is a bit unfortunate, but that's the right spirit for the kind of words we should be using.
21:08:57 <shachaf> i,i strictly nonnegative
21:08:59 <Cale> It's important to keep in mind that mathematics is all arbitrary definitions anyway
21:09:24 <dfeuer> No, mathematics is a *game*.
21:09:33 <Cale> The main reason to standardise anything is just to be able to communicate better
21:10:01 <Cale> and work together on the same puzzles
21:10:08 <dfeuer> Massively multiplayer and intercontinental, and it's been running for millenia, with all sorts of variants.
21:10:13 <Cale> yeah
21:11:05 <caseof> Can I install the new haskell platform on OSX without messing up the previously installed one (which was installed with brew)?
21:11:18 <dfeuer> The silly definitional stuff is unfortunate, but it can't be fixed, so ... deal.
21:12:13 <Cale> The thing is, it'll tend to be obvious what is meant, and usually if the difference matters at all, whoever is writing will point it out.
21:12:33 <shachaf> caseof: You can install multiple versions of GHC at the same time with no problem.
21:12:51 <shachaf> I don't know about the Haskell Platform or about brew.
21:13:46 <dfeuer> There are times when people go too far from the norm an make themselves truly hard to understand (try reading the stuff about orders in Kelley's General Topology).
21:14:15 <caseof> shachaf: Ok, thanks. Anyone with experience with haskell platform on OSX?
21:17:45 <dfeuer> (In particular, Kelley notes correctly that some define orders to be reflexive and antisymmetric, and others define them to be irreflexive and asymmetric, so he splits the baby by declaring an order to be a transitive relation. Then he defines a linear order based on this in a way that makes those utterly weird too.)
21:17:59 <nk887> Can anybody recommend a rigorous introductory functional programming book (focusing on theory)?
21:18:41 <merijn> nk887: Types and Programming Languages?
21:18:44 <merijn> @where tapl
21:18:44 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
21:19:08 <dfeuer> That's not exactly an intro to functional programming, is it?
21:19:28 <johnw> it does pretty much fit his request though
21:19:44 <Fuuzetsu> it really doesn't
21:19:48 * Fuuzetsu was just reading TAPL today
21:20:08 <merijn> It depends on what type of theory
21:20:10 <Fuuzetsu> he should still read it of course
21:20:14 <johnw> well, TAPL is what taught me about lambda calculus, which made me realize how it underlies functional programming
21:21:01 <merijn> Plus type theory and how to implement type inference
21:21:05 <johnw> yeah
21:21:12 <johnw> and the "rigorous" part
21:21:15 <johnw> TAPL is no joke about that
21:22:00 <johnw> in fact, I'd say skip the first 3 chapters the first time, and then read them on the second reading
21:22:03 <platz> nk887: unfortunately my experience is that "functional programming" is actually several different camps that opererate under a similar umbrella - which can feel a bit like driving through various mountain passes only to discover there is no 'true' peak
21:22:41 <platz> only more and more passes
21:22:52 <platz> but that's the beauty
21:23:32 <EvanR__> its like having burritos, enchilladas, and chimichangas available
21:23:38 <EvanR__> all on the menu at once
21:23:43 <johnw> :)
21:23:44 <platz> ^^
21:25:36 <ruukasu> [ x | x <- [10..20], x /= 13, x /= 15, x /= 19]
21:25:50 <ruukasu> what are the parts of the comprehension that aren't predicates called?
21:26:00 <ruukasu> the x and the x <- [10..20]
21:26:02 <freeman42> beginner here :) how could I build and install in a sandbox? hdevtools seems to be broken for the latest ghc
21:26:21 <johnw> but what does hdevtools have to do with building and installing in a sandbox?
21:26:26 <nk887> Hehe, good to know. Any specific titles that are a good introduction (with exposure to haskell) that focus on more than simply the language?
21:26:54 <nk887> I've been working through The Haskell Road to Logic, Math, and Programming
21:27:05 <merijn> nk887: Well, like I said, it kinda depends on what you're looking for
21:27:29 <merijn> nk887: Are you looking to dive more into type theory, advanced functional programming or implementing your own language(s)?
21:27:41 <freeman42> johnw, I need to manually build hdevtools for EclipseFP https://github.com/bitc/hdevtools/pull/33
21:28:12 <nk887> I'm mostly interested in learning to think better and become a better progammer in general
21:28:27 <johnw> nk887: have you seen http://www.cis.upenn.edu/~bcpierce/sf/current/index.html?
21:28:33 <johnw> i can't recommend that enough, if that is your goal
21:29:16 <merijn> nk887: I can think of a few things, they mostly don't use haskell (but it should still be very good to read)
21:29:48 <merijn> nk887: So TaPL is one (it uses ocaml), Software Foundations (which johnw just linked) is very good, which uses Coq (which can extract to both ocaml and haskell, so)
21:29:59 <merijn> nk887: Okasaki's book/thesis on purely functional data structures
21:30:46 <nk887> Cool, I'll check them out; thanks
21:31:10 <nk887> I've been look at a ton of books, haven't found the next one I'm going to tackle yet though
21:31:25 <johnw> what I like about SF is the interactivity
21:31:33 <johnw> it's both a book, a game, a puzzle and a learning tool
21:31:52 <merijn> Videogame programming \o/
21:31:53 <joelteon> it's both those four things
21:31:57 <merijn> johnw: That you continue after OPLSS?
21:32:07 <merijn> -That+Did
21:32:08 <johnw> plus you'll get a feel for dependent types, and how some of those ideas are making their way into Haskell
21:32:15 <johnw> merijn: oh yes, I've been using it a lot actually
21:32:21 <johnw> OPLSS really got me started
21:32:34 <merijn> I didn't have time yet, which makes me sad
21:32:36 <EvanR__> its half book, half game, half puzzle, and half learning tool
21:32:49 <nk887> sounds good, I'll look into it
21:32:50 <johnw> lol
21:35:52 * hackagebot easyjson 0.1.0.1 - Haskell JSON library with an emphasis on simplicity, minimal dependencies, and ease of use.  http://hackage.haskell.org/package/easyjson-0.1.0.1 (thinkpad20)
21:38:17 <trap_exit> we need a haskell platform party
21:39:12 <EvanR__> the haskell platform is too damn high
21:39:16 <nk887> I'm definitely going to have to put Purely Functional Data Structures on my to-read list, not sure if it will be my next book though
21:40:12 <nk887> Software Foundations looks really interesting
21:40:42 <platz> nk887: I might suggest Pearls of Functional Algorithm Design by Richard Bird before Purely Functional Data  Structures
21:41:17 <mwhit> PFDS seems more like a reference than something to read through in its entirety, from what i've seen of it
21:41:37 <platz> hrmm, that may be true
21:44:39 <merijn> johnw: btw, are you running mavericks? How did you install Coq? MacPorts install I used before seems to have broken...
21:44:51 <johnw> "nix-env -i coq" :)
21:44:56 <johnw> and yes, I'm on Mavericks
21:44:56 <trap_exit> Coq?
21:44:57 <trap_exit> who's using Coq
21:45:01 <johnw> I use Coq
21:45:05 <trap_exit> johnw: what are you using Coq for ?
21:45:15 <johnw> I'm formalizing edwardk's hask library, to prove his ideas
21:45:26 <johnw> github.com/jwiegley/category-theory
21:45:34 <trap_exit> do you feel Haskell's type system almost useless after using Coq?
21:45:48 <johnw> actually, Haskell is very good at some things
21:46:17 <trap_exit> i think theonly thing that haskell beats Coq at ... is ... writing real programs
21:46:18 <platz> I've heard coq is sensitive to refactoring/changes
21:46:20 <johnw> sometimes I use a Haskell scratch pad to help me play with types more fluidly
21:46:23 <trap_exit> everything else, I'd have to give Coq the advantage
21:46:49 <trap_exit> platz: with Coq, the problem with refactoring is not just changing your code ---- it's changing your proofs :-)
21:46:59 <johnw> platz: if you adopt a proof-scripting style like Chlipala does in his book on Certified Programming and Dependent Typese, you can insulate yourself a lot more from refactoring
21:47:19 <platz> trap_exit: yes, gotta provide that evidence now
21:47:20 <johnw> I have whole files where there is not one line of proof
21:47:35 <johnw> all 11 obligations are discharged by a single proof script
21:47:59 <trap_exit> johnw: sure ... but they you have the curse of exponential search / ltac
21:48:09 <johnw> you have to know what you're doing, sure
21:48:15 <platz> johnw: that is interesting. I suppose we can develop ways around the obvious blunders one first runs into
21:48:16 <johnw> there are ways to make your proof scripts much faster
21:48:19 <johnw> that's covered in CPDT too
21:48:42 <trap_exit> I found the entireity of CPDT / ltac impractical
21:48:44 <platz> much like folks that encounter haskell complain about things coming from imperative languages
21:48:56 <johnw> really?  I'm finding it quite effective
21:48:56 <trap_exit> what I want ... is somethign like Haskell ... which outputs a proof .... which Coq verifies
21:49:04 <trap_exit> rather than doing proofs in LTAC
21:49:12 <trap_exit> johnw: what's the most complicated thing you've proved in ltac ?
21:49:26 <johnw> trap_exit: i'm just starting with ltac, so nothing really complex yet
21:49:44 <trap_exit> johnw: are you doing this with proof general?
21:49:50 <johnw> yes
21:50:34 <Fuuzetsu> does anyone have a dark theme for Hackage/Haddock?
21:50:39 <Fuuzetsu> dark CSS theme that is
21:51:11 <trap_exit> johnw: since you're amazing at haskell
21:51:13 <trap_exit> johnw: and interested in Coq
21:51:29 <trap_exit> johnw: can you please write a Coq verifier in Haskell? none of the LTAC / syntax stuff
21:51:39 <trap_exit> johnw: just a verifier which verfiesi whether a proof is correct :-)
21:51:50 <trap_exit> I feel like someone should do this, then people can write LTAC scripts in Haskell instead of LTAC
21:51:50 <johnw> not sure I really understand what you mean
21:52:00 <johnw> a proof is correct if I'm able to construct its proof term
21:52:21 <johnw> you know, you *can* write Coq proof Agda-style; I just don't think of that as fun
21:52:37 <Fuuzetsu> sounds like someone just wants to use Agda
21:52:58 <trap_exit> hm, I've never used Agda
21:53:03 <johnw> also, when you say "the most complicated thing I've proved in ltac", do you just mean proved in general, or proved using automated proof scripting?
21:53:10 <platz> I thought using idris to verify a protocol was pretty neat http://i.imgur.com/t49jAo3.png
21:53:23 <johnw> yeah, Idris shows great promise
21:53:55 <johnw> I trust Coq's meta-theory a bit more at the present time :)
21:54:11 <trap_exit> johnw: I dunno about you, but rarely can I write a single ltac scripts that just solves it
21:54:15 <Fuuzetsu> ah, I just realised that with 7.8.3 being out, I can freely use holes while not using GHC HEAD but a latest release instead
21:54:17 <trap_exit> johnw: it's generally things like ltac ; ... | .... | ... |
21:54:24 <trap_exit> where for diferent cases, I then I have to do different things
21:54:33 <johnw> trap_exit: do you mean Ltac scripts, or just proofs?
21:54:37 <trap_exit> it could just be that I'm bad at ltac
21:54:40 <johnw> I don't quite follow
21:55:04 <Fuuzetsu> platz: is the full talk available?
21:55:38 <trap_exit> johnw: I haven't used ltac in a few months, I may be out of date
21:55:39 <Fuuzetsu> if only Idris didn't consider Unicode as the enemy…
21:56:08 <platz> Fuuzetsu: the video is a bit old since Idris has changed since February, but here https://www.youtube.com/watch?v=vkIlW797JN8
21:56:38 <johnw> trap_exit: this proof took me a rather insane amount of time to figure out: https://github.com/jwiegley/category-theory/blob/master/Endo/ACompose.v#L34
21:56:44 <johnw> but part of it is that I was just too new to Coq at the time
21:56:55 <Cale> Fuuzetsu: Actually the excessive unicode is mostly what prevents me from using Agda more than Coq. It becomes really hard on my hands in short order typing \ over and over.
21:57:13 <johnw> Cale: what OS do you use?
21:57:17 <Cale> Linux
21:57:22 <johnw> and Emacs?
21:57:25 <Fuuzetsu> Remap \, problem solved
21:57:33 <Cale> Is there any other choice for Agda?
21:57:41 <trap_exit> johnw: that proof looks very ltac-acable .. . since you aren't "picking terms to apply hypothesis/lema to"
21:57:44 <johnw> I do stuff like this: https://gist.github.com/3b0f7ea15c336d59b7ec
21:57:49 <johnw> for the really common unicode that I type
21:58:02 <johnw> just take one of your unused modifier keys and xmodmap it to the Alt keyspace in Emacs
21:58:14 <ion> L for gamma? :-P
21:58:23 <johnw> oops
21:58:31 <johnw> dunno why I thought that was Lambda
21:58:32 <Fuuzetsu> you mean upside down Γ right
21:58:42 * johnw sheepishly fixes
21:59:04 <Fuuzetsu> (and reflected)
21:59:16 <johnw> trap_exit: yeah, nearly every proof in that directory is mechanical
21:59:50 <johnw> trap_exit: the problem is that I think the search trees would get really large, because at every point there's a lot of choices that lead down deep blind alleys
22:00:09 <johnw> Adam said to me that if ltac script would start looking like the inverse of my proof, don't bother automating
22:00:20 <trap_exit> johnw: yeah, that's the thing I hate about ltac, it's like "non-deterministic patern matching"
22:00:33 <johnw> on the other hand, when it works it's magical
22:00:36 <johnw> I use "crush" a lot now
22:00:55 <johnw> it's like waving your hand at the rest of the obligation and saying, "rest is left as an exercise for crush"
22:01:39 <johnw> sometimes I feel Haskell lets me get away with too much now
22:01:39 <trap_exit> the problem I have with crush is: when it fails, it's not clear why it fails
22:01:45 <trap_exit> and even worse, when it works but is slow
22:01:48 <trap_exit> I have no idea why it's slow
22:02:04 <johnw> there are debugging tools to figure out why it's slow
22:02:06 <johnw> also in CPDT :)
22:02:14 <johnw> they can show you the search tree
22:02:17 <trap_exit> you mean tracing with proof general ?
22:02:23 <johnw> no, using Coq commands
22:02:27 <johnw> maybe we should take this to #coq actually
22:02:36 <trap_exit> sounds good
22:04:26 <johnw> merijn: coming to ICFP?
22:07:39 <merijn> johnw: No, I'm in the US atm :)
22:07:45 <johnw> oh?  where?
22:07:49 <merijn> Bay area
22:07:53 <johnw> welcome back
22:08:00 <merijn> Will be until the end of the year :)
22:08:38 <ReinH> merijn: SF or?
22:08:57 <merijn> ReinH: Belmont
22:09:41 <ReinH> Ah. I'll be in Sunnyvale on Monday.
22:10:46 <merijn> ReinH: For how long?
22:11:07 <ReinH> Just a couple days
22:12:17 <merijn> Impromptu haskell hackathon :p
22:12:47 <ReinH> Haha maybe dinner?
22:14:13 <Fuuzetsu> sounds like a setup for a date
22:14:28 <merijn> Lambda's, romance, it's all the same ;)
22:15:04 <ReinH> Well I'm already planning on dinner with jonsterling on Monday.
22:15:08 <Fuuzetsu> well, that solves the UnicodeSyntax problem for lambda, just use the heart unicode symbol
22:15:11 <ReinH> I don't think it's a date...
22:15:30 <Fuuzetsu> tsk tsk tsk, two-timing…
22:15:34 <jonsterling> heh
22:15:46 <ReinH> My wife probably wouldn't approve.
22:15:58 <Fuuzetsu> Does she know Haskell?
22:16:07 <ReinH> not yet
22:16:34 <merijn> I need to set up a system for meeting up with haskell people here :p It's a shame BayHac was early in the year :\
22:17:05 <ReinH> jonsterling: so dinner with Jeff and merijn on Monday? :D
22:17:48 <jonsterling> Heh, that'd be great!
22:18:02 <SrPx> Is there any library that allows getting webcam data on haskell on osx?
22:18:34 <merijn> I don't have any plans for monday yet, so just lemme know via lambdabot what time/place
22:18:42 <Maior> SrPx: checked out hsimage?
22:18:52 <SrPx> Yes, said it is only for linux
22:18:56 <ReinH> merijn: ok!
22:19:09 <ReinH> jonsterling: ok you should pick a place :D
22:19:45 <jonsterling> ReinH: Indeed! Though I forget, what city are we doing this in?
22:20:06 <ReinH> I don't know. Centroid is probably somewhere in SF
22:20:16 <jonsterling> I think Jeff is in LA though... Unless he's told you otherwise?
22:20:26 <ReinH> he is? huh
22:20:32 * gfixler wants to go, but has work, and is in LA
22:20:34 <ReinH> he said he'd be interested in dinner
22:20:40 <jonsterling> I mean, that's where he lives but perhaps he has come up to see you!
22:20:47 <ReinH> ah maybe
22:20:49 <jonsterling> Anyway, I'm fine wherever so long as it's not in LA :)
22:20:53 <jonsterling> Never LA
22:20:55 <ReinH> haha agree
22:20:57 <gfixler> :(
22:21:08 <ReinH> I can make it into SF
22:21:19 <jonsterling> So augur is going to be so mad at me, but I have just come up with a much more elegant formulation of the thing we spent all day making
22:21:26 <ReinH> but I'll be staying closer to Sunnyvale
22:21:34 <ReinH> haha
22:22:05 <jonsterling> Well, now that things have settled down for me, I can probably make it to Sunnyvale if that's easiest for everyone; but I don't know about food in the area.
22:22:35 <ReinH> me neither
22:22:40 <ReinH> let's talk about it tomorrow.
22:22:44 <jonsterling> Sounds good!
22:22:52 <merijn> Sunnyvale is easy enough, I think it's only like 20mins driving for me
22:22:59 <ReinH> yay settled down.
22:22:59 <joelteon> is something happening in Sunnyvale?
22:23:01 <joelteon> I'm already here
22:23:20 <ReinH> joelteon: I am happening. I guess. I'll be in town.
22:23:29 <ReinH> I am now a happening.
22:23:32 <joelteon> Are you hip?
22:23:39 <ReinH> so hip
22:24:12 <ReinH> Haskell dinner is happening I guess.
22:34:45 <solatis> does the concept of 'a blocking operation' exist in haskell?
22:35:18 <solatis> i'm currently in fight with a library that claims to 'block while waiting on input', but generating 100% cpu in the meantime
22:35:38 <shachaf> Using 100% CPU to do nothing isn't a good sign.
22:35:44 <solatis> exactly
22:36:14 <solatis> i'm a c++ developer by nature, so my next logical step would be to use gdb to find out what is happening
22:36:27 <shachaf> But that question doesn't really give enough information to figure out what's going on.
22:36:41 <lfairy> showing us the code tends to help
22:36:52 <shachaf> gdb is still usable for GHC-compiled programs sometimes but you have to know what's going on.
22:36:52 <solatis> https://stackoverflow.com/questions/25225122/100-cpu-usage-with-zeromq-push-socket-with-0-listeners
22:36:52 <johnw> a gdb backtrace can sometimes still give a clue
22:37:20 <shachaf> You could also try strace or something to see what it's doing.
22:37:24 <solatis> yeah
22:37:42 <solatis> but when using +RTS -pa doesnt really give a lot of information
22:37:48 <dfeuer> solatis: at a guess, you might start grepping for lock-free primitives—someone might not know how to use them, or might be using them by mistake.
22:38:22 <solatis> dfeuer: i believe the haskell library of zmq is a wrapper around the C calls, and they all claim to be lock-free indeed
22:38:43 <solatis> but at the same time, they claim certain functions can be blocking
22:38:54 <solatis> wait, let me dig into the offending code
22:39:58 <solatis> https://github.com/twittner/zeromq-haskell/blob/master/src/System/ZMQ4.hs#L794
22:40:06 <solatis> that's the function that's generating the 100% cpu
22:40:20 <dfeuer> It is advantageous to use lock-free primitives to implement blocking in special cases, but much care is requited to avoid unbounded busy-wait.
22:40:47 <dfeuer> Best to leave that to concurrency library implementors.
22:40:51 <solatis> from the comments: "Still 'send' is blocking the thread as long as the message can not be queued on the socket using GHC's 'threadWaitWrite'."
22:42:03 <solatis> but as you can see, it's just a wrapper around the C call zmq_sendmsg
22:43:03 <solatis> ok, look at the comments of this function, they seem to be contradicting itself:
22:43:09 <solatis> https://github.com/twittner/zeromq-haskell/blob/master/src/System/ZMQ4.hs#L790
22:43:21 <solatis> first it says "this function is non-blocking"
22:43:36 <solatis> then it says "but it can still block using waitWrite"
22:43:54 <solatis> what would you guys make of it?
22:44:34 <tgeeky> solatis: it means that it's non-blocking by default, but it can explicitly block using waitWrite
22:44:51 <tgeeky> (now i look at the code)
22:45:13 <solatis> no it calls waitWrite itself
22:46:10 <dfeuer> I'm no expert, but it sounds like the library writer isn't/wasn't one either.
22:46:32 <solatis> haha
22:46:36 <solatis> good
22:46:51 <solatis> i hate opening trouble tickets etc, but you guys agree with me that this smells fishy?
22:47:13 <dfeuer> I haven't read the source yet.
22:47:26 <tgeeky> no I don't agree; but I have to read more.
22:47:36 <solatis> ok
22:47:43 <tgeeky> you can't assume that the presence of the name of a function means the function will be called in haskell
22:47:57 <solatis> these zeromq guys generally know what they are doing
22:48:08 <solatis> and the library seems like a semi-thin wrapper around the C calls
22:48:38 <tgeeky> and anyway, this function claims to guarantee what it does as a *caller* of zmq_sendmsg; but this does not necessary extend to this function (send)
22:49:12 <solatis> now you say it like that, you are right
22:50:34 <benzrf> ømq is sweet
22:50:47 <solatis> yeah it is, and the guys behind it seem to know what they are doing
22:50:51 <solatis> and i do not know what i am doing
22:50:58 <solatis> so i give them the advantage
22:51:12 <dfeuer> Sounds fair.
22:52:19 <solatis> however, i do think i am going to contact the library author directly about this issue -- the test case i have is sufficiently small and isolated, and it does rais some concerns
22:56:25 <solatis> ah
22:56:37 <solatis> strace gives a lot of sensible details
23:01:03 * hackagebot jose 0.2.31.0 - Javascript Object Signing and Encryption and JSON Web Token library  http://hackage.haskell.org/package/jose-0.2.31.0 (frasertweedale)
23:09:10 <dfeuer_> carter, I have an answer for you. unsafeCoerce from a Shape to a list seems to work perfectly in compiled code, but not in bytecode in ghci.
23:09:40 <carter> dfeuer_: :)
23:09:46 <dfeuer_> Running ghci with -fobject-code makes it work.
23:09:52 <carter> dfeuer: :)
23:09:55 <dfeuer_> ?
23:09:58 <glguy_> :)
23:10:24 <dfeuer_> I'm not sure what these smiles mean today.
23:11:07 <shachaf> There are lots of reasons things might not be unsafeCoerce-compatible in slightly different environments.
23:11:47 <dfeuer_> I would very much like for GHC to be able to make those sorts of things Coercible.
23:12:32 <carter> dfeuer: why
23:12:37 <shachaf> Do you have a situation where it matters?
23:12:45 <carter> what shachaf  said
23:12:53 <carter> it is coooool / neat that its possible
23:12:57 <dfeuer_> Unclear.
23:12:57 <carter> but when is it a good idea :)
23:13:11 <carter> dfeuer: did you know you can unsafeCoerce anything to a heap address?
23:13:34 <dfeuer_> You can unsafeCoerce anything to anything else. You can make horrible crashes.
23:14:05 <dfeuer_> Coercible seems to handle map-like things very well.
23:14:19 <dfeuer_> What we're looking at is a more fold-like thing.
23:14:24 <carter> which one?
23:14:36 <dfeuer_> From this sort of list to that sort of list.
23:14:51 <dfeuer_> From sized list to unsized list.
23:14:54 <carter> why
23:15:02 <carter> dfeuer: you can use a newtype! :)
23:15:14 <tabemann> Coercible is actually a thing?
23:15:17 <carter> yes
23:15:17 <carter> it is
23:15:25 <tabemann> I thought Coercible is something we thought up in IRC
23:15:29 <dfeuer_> I don't think that gives GHC the sort of proof it needs, does it?
23:15:43 <carter> dfeuer: you could do newtype SizedList (n::Nat) a =  SList [a]
23:15:46 <dfeuer_> No, Coercible is a real thing.
23:15:47 <carter> proof of what
23:16:17 <dfeuer_> What is an SList?
23:16:43 <dfeuer_> carter, forget I said that. Continue with your explanation?
23:16:45 <tabemann> okay, Coercible has been a thing since 4.7.0.0
23:16:52 <carter> dfeuer: i just made it up
23:17:00 <carter> dfeuer: go play with it
23:17:17 <carter> you can define a sized cons and stuff with it
23:17:18 <carter> and sized head
23:17:21 <carter> and sized tail
23:17:33 <carter> and  its trivially coercible to a list
23:17:35 * dfeuer_ is still puzzling over that type.
23:18:26 <tabemann> the thing is, Coercible is exactly what I remember us thinking it should be, without knowledge of there being an actual Coercible type class in the works
23:18:33 * dfeuer_ goes away to try to figure that out.
23:21:20 <dfeuer_> carter, the proof I'm referring to, of course, is that the list isn't empty when I try to take its head.
23:21:31 <carter> do able with this
23:22:58 <lfairy> tabemann: what do you mean?
23:23:12 <dfeuer_> ???  How do I convince GHC that when I give it SList foo;:SizedList (S x) T  that foo will actually not be empty?
23:23:53 <dfeuer_> With the approach you use in Shape, that seems to follow directly from the types.
23:24:45 <dfeuer_> Do you see what I'm getting at with the fold vs. map coercion, or am I talking nonsense?
23:25:11 <carter> dfeuer: so ... you want ghc to be able to think more
23:25:18 <carter> i don't know if its that smart yet
23:25:22 <carter> but that'd be a cool project
23:25:34 <dfeuer_> Unless there's a feature/technique for doing it now that I don't know about!
23:25:59 <dfeuer_> Unfortunately, even what it does now is beyond more than my shallow understanding.
23:26:01 <carter> dfeuer: have you considered writing cmm code to prototype trustMeItsSafeHead
23:26:04 <carter> :)
23:26:34 <dfeuer_> carter, I'm going to try the unsafeCoerce approach :-P
23:26:52 <carter> dfeuer: Q: does ghc generate teh code you want for my shape type?
23:27:12 <dfeuer_> carter, that's what I'm about to find out, in a couple minutes.
23:27:42 <tabemann> back
23:28:19 <tabemann> lfairy: I remember a discussion in here a while ago where we proposed a type class Coercible, with a function coerce :: Coercible a b => a -> b, with automatic generation of type class instances
23:28:38 <dfeuer_> tabemann, that is real.
23:28:44 <tabemann> as I just found out
23:29:12 <dfeuer_> But the details are complicated, and the implementation much more so.
23:29:55 <dfeuer_> And yet it's simpler than a previous, apparently more powerful, proposal that apparently no one could figure out how to implement.
23:35:51 <carter> who said its complicated?
23:36:07 <carter> dfeuer_: did you check the core? :)
23:36:30 <dfeuer_> carter, still working on making it compile.
23:36:34 <carter> :P
23:36:35 <dfeuer_> I did, carter.
23:36:39 <carter> and?
23:36:40 <dfeuer_> Said it's complicated.
23:36:47 <carter> :)
23:36:55 <carter> which?
23:36:59 <carter> coercible aint complicated
23:37:00 <carter> :)
23:37:02 <carter> well
23:37:06 <carter> not reallly
23:37:16 <carter> i'm crashin
23:37:17 <carter> gnight
23:37:50 <tabemann> g'night
23:38:07 <dfeuer_> Nooooo.
23:38:15 <dfeuer_> carter must not go to sleep yet!
23:56:10 * hackagebot sci-ratio 0.2.0.0 - Rational numbers in scientific notation.  http://hackage.haskell.org/package/sci-ratio-0.2.0.0 (Rufflewind)
