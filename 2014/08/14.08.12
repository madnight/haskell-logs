00:00:57 <d3m1g0d-> >:t (+) <$> (*2) <*> (+3) $ 5
00:01:14 <nicoo> t (+) <$> (*2) <*> (+3) $ 5
00:01:16 <nicoo> :t (+) <$> (*2) <*> (+3) $ 5
00:01:17 <lambdabot> Num b => b
00:01:25 <funfunctor> CmdrMoozy: every GUI toolkit I have ever seen sucks big time! However, I would recommend you do your GUI in Gtk or Qt with preference to Gtk due to my personal hate for C++. Then wrap your handlers and do all your logic in Haskell. i.e. MVC design pattern
00:02:04 <CmdrMoozy> funfunctor, linman32 was asking, however I agree in principal
00:02:14 <d3m1g0d-> what happens in this example ? the (*2) <*> (+3) part is evaluated as "\x -> (*2) x (+3 x)" ?
00:02:33 <kadoban> I wonder if you can do GUI in python or something nice and high level easily
00:02:38 <funfunctor> CmdrMoozy: ok, I just walked in here ;) irssi has been crashing a lot lately
00:02:44 <CmdrMoozy> no worries :)
00:02:50 <funfunctor> someone needs to rewrite irssi in haskell :D
00:02:57 <hamid> funfunctor, +1
00:02:59 <Iceland_jack> d3m1g0d-: Yes
00:03:08 <CmdrMoozy> my understanding is that it's very easy to call haskell functions from C, and I know for a fact that it's very easy to call C code from python
00:03:13 <CmdrMoozy> so it should be very possible
00:03:18 <Iceland_jack> @ty (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b)
00:03:19 <lambdabot> (r -> a -> b) -> (r -> a) -> r -> b
00:03:37 <hamid> Iceland_jack, what does @ty do?
00:03:45 <Iceland_jack> hamid: gets the type of an expression
00:03:49 <kadoban> Yeah, same understanding. I'll have to give that a try next time I need a GUI, see if it's tedious in practice or actually works.
00:03:54 <hamid> right
00:04:27 <d3m1g0d-> > fmap (+) (\x -> (*2) x (+3 x))
00:04:28 <lambdabot>  No instance for (Data.Typeable.Internal.Typeable a1)
00:04:28 <lambdabot>    arising from a use of ‘M914653736290773231430466.show_M9146537362907732314...
00:04:28 <lambdabot>  The type variable ‘a1’ is ambiguous
00:04:28 <lambdabot>  Note: there are several potential instances:
00:04:28 <lambdabot>    instance Data.Typeable.Internal.Typeable Data.Dynamic.Dynamic
00:04:36 <linman32> yall are saying code gui in c via gtk. then wrap haskell around it
00:04:43 <linman32> and python gui might be easier
00:04:59 <dfeuer_> @tell edwardk My hand-simplification of (reverse . unfold) was verified by GHC. It's lovely.
00:04:59 <lambdabot> Consider it noted.
00:05:03 <d3m1g0d-> Iceland_jack:  then shouldn't that work ?
00:05:10 <d3m1g0d-> ..> fmap (+) (\x -> (*2) x (+3 x))
00:05:16 <d3m1g0d-> the exact equivalent of
00:05:18 <Iceland_jack> d3m1g0d-: the thing is that (*2) x ((+3)x) doesn't work
00:05:24 <Iceland_jack> but it expands to that
00:05:35 <Iceland_jack> (+3 x) is wrong as well
00:05:58 <Iceland_jack> as you can tell from
00:05:58 <Iceland_jack> @ty (<*>) :: (r -> a -> b) -> (r -> a) -> (r -> b)
00:05:58 <Iceland_jack> its first argument needs to be (at least) a binary function
00:05:59 <lambdabot> (r -> a -> b) -> (r -> a) -> r -> b
00:06:32 <Iceland_jack> So something like this works:
00:06:33 <Iceland_jack> :t (+) <*> (* 2)
00:06:33 <Iceland_jack>  
00:06:33 <lambdabot> Num a => a -> a
00:06:44 <Iceland_jack> and that's the same as
00:06:44 <Iceland_jack>     x + x * 2
00:07:03 <Iceland_jack> > ((+) <*> (* 2)) 4
00:07:04 <lambdabot>  12
00:07:07 <Iceland_jack> > 4 + 4 * 2
00:07:08 <lambdabot>  12
00:07:54 <d3m1g0d-> > fmap (+) (\x -> (*2) x (((+3) x)) $ 5
00:07:56 <lambdabot>  <hint>:1:38:
00:07:56 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
00:08:01 <d3m1g0d-> can you explain again why that doesnt work ?
00:08:09 <Iceland_jack> d3m1g0d-: (*2) is a unary function
00:08:22 <Iceland_jack> and you're passing it two arguments (and the parentheses are also mismatched)
00:08:30 <Iceland_jack> > (*2) 5 10
00:08:31 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> t))
00:08:31 <lambdabot>    arising from the ambiguity check for ‘e_12510’
00:08:31 <lambdabot>  from the context (GHC.Num.Num (a -> t), GHC.Num.Num a)
00:08:31 <lambdabot>    bound by the inferred type for ‘e_12510’:
00:08:31 <lambdabot>               (GHC.Num.Num (a -> t), GHC.Num.Num a) => t
00:12:07 <d3m1g0d-> Iceland_jack:  ok sir, but why does that work then ?
00:12:08 <d3m1g0d-> :t (+) <$> (*2) <*> (+3) $ 5
00:12:08 <lambdabot> Num b => b
00:12:19 <d3m1g0d-> whats the precendence of the operations here ?
00:12:32 <ezrios> :info (<$>)
00:12:35 <Iceland_jack> It works like this
00:12:35 <Iceland_jack> :t (((+) <$> (*2)) <*> (+3)) 5
00:12:36 <lambdabot> Num b => b
00:12:44 <Iceland_jack> so *first* you compose (+) and (*")
00:12:48 <Iceland_jack> and (*2)
00:12:50 <d3m1g0d-> ohohohoho , ok .... thanks sir .. got it
00:12:51 <d3m1g0d-> <3
00:12:54 <Iceland_jack> No problem :)
00:15:09 <d3m1g0d-> to avoid future silliness, how can i check the precedence of operators and their associativity ( left or right ) ?
00:15:18 <Iceland_jack> You can use ':info' in GHCi
00:15:31 <shachaf> :i in ghci
00:15:42 <Iceland_jack> I wrote a patch for GHCi that displayed the grouping of parentheses
00:16:07 <Iceland_jack> but it never got anywhere
00:16:35 <solidus-river> is there a good way to clamp an integral in netwire?
00:16:38 <solidus-river> er, netwire 5
00:17:44 <prinsen> Im experiencing some memory leaks in a program with forever running pipes. Is there any pitfalls? I have profiling generated if anyone wants to check
00:18:09 <Iceland_jack> d3m1g0d-: I can show you how it's evaluated if you're interested
00:18:38 <Iceland_jack> a bit too long to paste into the channel
00:18:52 <Iceland_jack> d3m1g0d-: http://lpaste.net/109226
00:19:18 <Iceland_jack> Hope that helps
00:21:27 <prinsen> Any general tips on avoiding space leaks?
00:21:30 <Iceland_jack> so
00:21:30 <Iceland_jack>     (***) <$> foo <*> bar
00:21:30 <Iceland_jack>     ==
00:21:30 <Iceland_jack>     \r -> foo r *** bar r
00:21:55 * hackagebot h-booru 0.2.0.0 - Haskell library for retrieving data from various booru image sites  http://hackage.haskell.org/package/h-booru-0.2.0.0 (MateuszKowalczyk)
00:21:57 * hackagebot pandoc-citeproc 0.4 - Supports using pandoc with citeproc  http://hackage.haskell.org/package/pandoc-citeproc-0.4 (JohnMacFarlane)
00:23:02 <Iceland_jack> prinsen: Strictness is a big one
00:23:30 <Iceland_jack> If you have a variable that you're incrementing by one, be careful not to create a thunk of
00:23:30 <Iceland_jack>     0 + 1 + 1 + 1 + 1 + 1 + ...
00:24:26 <Iceland_jack> So use versions of data structures that are strict and use ($!)
00:25:16 <Iceland_jack> Be careful not to help on to a reference for too long
00:25:23 <brbblnch> Hi. I'm trying to read a file with aeson, but I have an error that I can't find the cause. Here is a code example giving me the error : http://lpaste.net/4537127774170644480 . And ghci says "No instance for (FromJSON Rec) arising from a use of ‘decode’". I don't know what I'm doing wrong. Any hint?
00:25:50 <prinsen> Iceland_jack: Looking at my graphs, the biggest thief is ARR_WORDS which i guess is ByteString
00:25:54 <Iceland_jack> brbblnch: You need to make a FromJSON instance
00:26:04 <prinsen> Iceland_jack: But everything seems to be increasing
00:26:17 <Iceland_jack> brbblnch: https://hackage.haskell.org/package/aeson-0.8.0.0/docs/Data-Aeson.html
00:26:35 <Iceland_jack> Adding a 'instance FromJSON Rec' should do it
00:26:35 <prinsen> Iceland_jack: can I send you a profiling somehow?
00:27:03 <Iceland_jack> I'm not a profiling expert so I'm not sure if I can help with that much
00:28:46 <makalu> I would like to run action (m a) such that if it throws an exception, Nothing is returned, otherwise Just a. How can I do that? I tried (Just <$> action) `catch` (const $ return Nothing) but then the exception type is ambiguous and I don't know how to restrict it to IO exceptions
00:29:28 <makalu> actually, let's make it simpler: I need System.Environment.lookupEnv in base <7
00:29:32 <Iceland_jack> makalu: You're going to have to specify the exception in 'const $ return Nothing'
00:29:51 <Iceland_jack> something like
00:29:51 <Iceland_jack>     (\(_ :: IOException) -> return Nothing)
00:29:53 <brbblnch> Iceland_jack, Wow, thanks. I thought that adding Generics would automagically do it for me. Simply writing "instance FromJSON Rec" seemed to do the trick
00:30:28 <Iceland_jack> brbblnch: Generics is what makes it possible to automagically derive the FromJSON instance :)
00:31:13 <makalu> Iceland_jack: I tried that and it didn't work. But I should have listened to GHC's suggestion (use ScopedTypeVariables) :). Thanks.
00:31:16 <Iceland_jack> makalu:
00:31:16 <Iceland_jack> @ty catch (Just <$> undefined) (\(_ :: IOException) -> return Nothing)
00:31:17 <lambdabot> IO (Maybe a)
00:31:23 <Iceland_jack> yes, you need ScopedTypeVariables
00:31:55 <Axman6> I'd use SomeException instead of IOException if you want to catch any esception
00:31:57 <Iceland_jack> You can also define a local function
00:31:57 <Iceland_jack>     retNothing :: IOException -> IO (Maybe a)
00:31:57 <Iceland_jack>     retNothing _ = return Nothing
00:31:57 <Iceland_jack> if you really want to avoid that
00:32:03 <Axman6> exception*
00:32:24 <Iceland_jack> SomeException catches everything, even Ctrl-C interrupts
00:33:39 <adas> glguy: kindof figured it out. but thats a very convoluted way of writing sum
00:34:34 <makalu> I hope getEnv only throws does not exist exceptions so I hope IOException is sufficient
00:35:07 <Iceland_jack> makalu: is that 'getEnv' from System.Environment?
00:35:19 <makalu> yes
00:35:25 <Iceland_jack> Maybe you want 'lookupEnv'
00:35:33 <Iceland_jack> @hoogle lookupEnv
00:35:35 <lambdabot> No results found
00:35:37 <makalu> that's what I said :). I want lookupEnv in base <7
00:35:44 <Iceland_jack> aah, no problem
00:35:55 <makalu> sorry, base 4 something
00:35:56 <Iceland_jack> I missed that
00:36:19 <makalu> I have GHC 7.4.2 from the binary on the website, it has 4.5.1.0
00:36:40 <trap_exit> why are you not running 7.8.3
00:36:42 <Iceland_jack> there is also a 'try' function btw
00:36:46 <Iceland_jack> @ty try
00:36:47 <lambdabot> Exception e => IO a -> IO (Either e a)
00:37:19 <makalu> I want my program to work on Debian Wheezy with apt's version of GHC
00:37:26 <makalu> to compile I mean
00:37:40 <Iceland_jack> @ty try (?getEnv "") :: IO (Either IOException String)
00:37:40 <lambdabot> (?getEnv::[Char] -> IO String) => IO (Either IOException String)
00:40:46 <makalu> I think I'll use try then. Thank you.
00:43:24 <makalu> nice my program compiles. Making it work with 7.4 wasn't as horrible as I thought.
00:43:43 <Iceland_jack> It's nice to see you care about older versions
00:48:39 <makalu> now cabal can't resolve dependencies with 7.6 :)
00:51:54 <makalu> because I had to put version bounds on some dependencies
00:55:23 <makalu> the unix package that comes with 7.6 is too fresh for haskeline 0.6.*
00:56:59 * hackagebot jpeg 0.0.1.1 - A library for decoding JPEG files written in pure Haskell  http://hackage.haskell.org/package/jpeg-0.0.1.1 (AtzeDijkstra)
01:04:31 <trap_exit> greatness
01:12:00 * hackagebot clash-ghc 0.3.3 - CAES Language for Synchronous Hardware  http://hackage.haskell.org/package/clash-ghc-0.3.3 (ChristiaanBaaij)
01:22:05 <latk> Is it possible to get documentation / hayoo offline?
01:22:59 <splintax> cabal install foo --enable-documentation should give you a local copy of the docs for foo
01:23:14 <blakehaswell> Is there a nicer way to write: Leaf <$> read <$> ((++) <$> integer <*> fraction)
01:23:58 <latk> splintax: Is there some nice way to get access to them ?
01:26:16 <splintax> latk: not sure tbh. i just open .cabal-sandbox/share/doc/<arch>/<pkg>/index.html and browse from there
01:26:19 <splintax> but it's not that convenient
01:26:56 <splintax> in fact, it's so inconvenient that i often end up just finding the docs on google (and running into problems with them being inaccurate), so let me know if you find a better way
01:27:29 <latk> splintax: That is exactly what I do at the moment :p
01:28:28 <splintax> someone's probably hacked up a shell script to do it
01:28:39 <frerich> It probably says a lot about the state of searching your computer for documents if you find that asking Google to searchi through billions of documents to find some Haskell API reference is faster and more convenient than opening the HTML file on your local system.
01:33:28 <trap_exit> frerich: ouch
01:33:30 <trap_exit> but yeah, I agree
01:33:43 <trap_exit> the problem is
01:33:47 <trap_exit> there is no money to be made in improving desktop search
01:33:52 <splintax> there's a lot more money, computing power and engineering talent thrown at the (more important) problem of searching the internet
01:35:06 <trap_exit> I want to watch ninja warrior finals
01:36:54 <blakehaswell> Hmm, I have this: fmap (Leaf . read) $ (++) <$> integer <*> fraction
01:37:19 <blakehaswell> Which is kind of nicer…
01:47:05 * hackagebot leveldb-haskell-fork 0.3.2 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-fork-0.3.2 (ifesdjeen)
01:47:36 <trap_exit> ooooh
01:47:36 <trap_exit> leveldb
01:49:24 <funfunctor> has anyone worked with both Alex and Flex for generating Lexers?
01:57:57 <Maior> doing some debugging in ghci - if I "import Main" I don't get the non-main symbols in there; is there a good/convenient way to, well, get them?
01:58:31 <corgifex> what does that mean?
01:59:47 <Maior> corgifex: I have `Main.hs`, it has `main` and `foo`; `import Main` does not let me use `foo`
02:00:41 <corgifex> rm Main.o
02:02:38 <Maior> corgifex: doesn't exist
02:02:53 <shachaf> Put "module Main where" at the top of the file.
02:02:57 <shachaf> Otherwise only "main" is exported.
02:03:08 <shachaf> Alternatively, use "ghci Main.hs" instead of "import Main"
02:03:22 <corgifex> weird
02:03:25 <corgifex> does import *Main work?
02:04:52 <Maior> shachaf: ...that'd do it thanks
02:04:57 <Maior> corgifex: it also does indeed, cheers
02:05:29 <corgifex> so if there is no compiled object code, wtf is ghci loading by default?
02:05:55 <zereraz> hello, what is wrong with this line f n arr =  mapM_ (\x->replicate n x) arr   . its supposed to print each element of array n times
02:06:27 <zereraz> why do I get so many [(),()...]
02:06:49 <corgifex> there's no print
02:07:07 * hackagebot alex-meta 0.3.0.6 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.3.0.6 (JonasDuregard)
02:07:09 * hackagebot happy-meta 0.2.0.6 - Quasi-quoter for Happy parsers  http://hackage.haskell.org/package/happy-meta-0.2.0.6 (JonasDuregard)
02:07:12 <Iceland_jack>  @ty mapM_ (print . replicate 5)
02:07:28 <Iceland_jack> that should be
02:07:28 <Iceland_jack>     replicateM 5 . print
02:07:50 <zereraz> it works
02:07:51 <Iceland_jack> so
02:07:52 <Iceland_jack> @ty mapM_ (replicateM 5 . print)
02:07:52 <lambdabot> Show a => [a] -> IO ()
02:07:55 <zereraz> thanks
02:07:59 <Iceland_jack> No prob
02:08:52 <zereraz> Iceland_jack: why does it not work here http://lpaste.net/109230
02:09:59 <Iceland_jack> zereraz: You haven't update 'f' have you?
02:10:13 <Iceland_jack> Does it work for
02:10:13 <Iceland_jack>     f n = mapM_ (replicateM n . print)
02:10:54 <zereraz> Iceland_jack: its giving error on type
02:11:05 <zereraz> expected [a0]
02:11:06 <Iceland_jack> Compiles for me
02:11:08 <zereraz> actual IO
02:11:11 <Iceland_jack> yes, omit the 'arr'
02:11:15 <zereraz> I did
02:11:23 <Iceland_jack> Is it exactly like this?
02:11:23 <Iceland_jack>     f n = mapM_ (replicateM n . print)
02:11:23 <zereraz> they don't want print statement I think
02:11:39 <zereraz> yeah
02:11:48 <Iceland_jack> hm no wait
02:12:04 <zereraz> Iceland_jack: they normally print on their own
02:12:08 * hackagebot BNFC-meta 0.4.0.2 - Deriving Parsers and Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.4.0.2 (JonasDuregard)
02:12:15 <zereraz> Iceland_jack: I just solve question and printing is prewritten
02:12:56 <Iceland_jack> ah okay, sorry I messed up
02:13:05 <Iceland_jack> printing is taken care of already
02:13:12 <zereraz> Iceland_jack: no problem
02:13:38 <zereraz> Iceland_jack: they are printing lots of (),()
02:13:48 <Iceland_jack> so I'm guessing you want
02:13:48 <Iceland_jack>     f 2 [1,2,3,4]
02:13:48 <Iceland_jack> to turn into
02:13:48 <Iceland_jack>     [1,1,2,2,3,3,4,4]?
02:14:01 <zereraz> yeah
02:14:17 <blakehaswell> Hi all
02:14:19 <corgifex> then stop using mapM_ and friends
02:14:21 <Iceland_jack> okay then you want
02:14:21 <Iceland_jack> > concatMap (replicate 2) [1,2,3,4]
02:14:22 <lambdabot>  [1,1,2,2,3,3,4,4]
02:14:35 <Iceland_jack> so
02:14:35 <Iceland_jack>     f n = concatMap (replicate n)
02:14:58 <blakehaswell> Anyone know their way around parsec?
02:15:05 <Iceland_jack> then f has type
02:15:05 <Iceland_jack>     f :: Int -> [a] -> [a]
02:15:05 <Iceland_jack>     f n = concatMap (replicate n)
02:15:22 <zereraz> I'll need to learn concatMap
02:15:30 <Iceland_jack> @src concatMap
02:15:31 <lambdabot> concatMap f = foldr ((++) . f) []
02:15:41 <Iceland_jack> it's basically map followed by concat
02:15:51 <zereraz> ok got it
02:15:59 <Iceland_jack> > map (replicate 2) [1,2,3,4]
02:16:00 <lambdabot>  [[1,1],[2,2],[3,3],[4,4]]
02:16:04 <Iceland_jack> > concat (map (replicate 2) [1,2,3,4])
02:16:05 <lambdabot>  [1,1,2,2,3,3,4,4]
02:16:11 <zereraz> ah nice
02:16:16 <zereraz> thanks allot
02:16:27 <Iceland_jack> No problem
02:16:43 <Iceland_jack> A shorted definition would be to eta-reduce 'simply
02:16:43 <Iceland_jack>     
02:16:52 <Iceland_jack> A shorted definition would be to eta-reduce 'f' into
02:16:52 <Iceland_jack>     f = concatMap . replicate
02:16:57 <zereraz> what does eta mean
02:16:59 <Iceland_jack> depends if that's clearer to you or not
02:17:18 <zereraz> I saw it in lpaste too
02:17:18 <blakehaswell> I’m toying with a small equation parser, and the following code compiles but when I try to run it it hangs forever
02:17:20 <blakehaswell> http://lpaste.net/109231
02:17:24 <corgifex> zereraz: eliminating function parameters from both sides
02:17:44 <corgifex> the basic version is to write 'f = g' instead of 'f x = g x'
02:17:44 <Iceland_jack> zereraz: So you can turn
02:17:45 <Iceland_jack>     f x = foo x
02:17:45 <Iceland_jack> into
02:17:48 <Iceland_jack>     f = foo
02:17:52 <zereraz> corgifex: ok so we can only remove where its obvious
02:18:16 <zereraz> to make it simple
02:18:18 <corgifex> zereraz: well, turns out we can always remove explicit parameters unless you pattern match on them :-)
02:18:19 <Iceland_jack> zereraz: It's fine as long as 'x' does not appear in the function 'foo'
02:18:41 <corgifex> but that tends to require some awkward rewriting
02:18:53 <zereraz> I did not understand both the statements
02:19:08 <Iceland_jack> All these are equivalent
02:19:09 <Iceland_jack>     f n arr = concatMap (replicate n) arr
02:19:09 <Iceland_jack>     f n     = concatMap (replicate n)
02:19:09 <Iceland_jack>     f n     = (concatMap . replicate) n
02:19:12 <Iceland_jack>     f       = concatMap . replciate
02:19:15 <zereraz> corgifex: unless we pattern match or if we pattern match
02:19:18 <Iceland_jack> so it just depends on what you prefer
02:19:33 <zereraz> oh
02:19:35 <Iceland_jack> *s/replciate/replicate/
02:19:36 <zereraz> that is so new
02:19:57 <Iceland_jack> The second and fourth of those are due to eta-reduction
02:20:04 <Iceland_jack> The third line is due to the definition of (.)
02:20:17 <zereraz> wow
02:20:37 <zereraz> so cool, I saw a question in which I had no parameters
02:20:37 <Iceland_jack> zereraz: we can even ask lambdabot
02:20:41 <zereraz> now I can solve it too!
02:20:44 <Iceland_jack> @pl \n arr -> concatMap (replicate n) arr
02:20:45 <lambdabot> (=<<) . replicate
02:20:50 <zereraz> how to ask lambdabot
02:20:52 <Iceland_jack> well, that's too much :)
02:20:56 <Iceland_jack> @pl \n arr -> concatMap' (replicate n) arr
02:20:56 <lambdabot> concatMap' . replicate
02:21:01 <corgifex> lambdabot thinks (=<<) looks cooler than concatMap
02:21:11 <Iceland_jack> @pl \n arr -> f (g n) arr
02:21:11 <lambdabot> f . g
02:21:36 <Iceland_jack> So lambdabot tells you that for any function
02:21:36 <Iceland_jack>     foo n arr = f (g n) arr
02:21:36 <Iceland_jack> you can rewrite it as
02:21:36 <Iceland_jack>     foo = f . g
02:21:40 <zereraz> @pl \n arr -> concatMap(replicate n) arr
02:21:41 <lambdabot> (=<<) . replicate
02:21:48 <Iceland_jack> @pl foo n arr = f (g n) arr
02:21:48 <lambdabot> foo = f . g
02:21:49 <zereraz> =<< ?
02:21:56 <Iceland_jack> zereraz: You can ignore (=<<) for now
02:22:01 <zereraz> ok
02:22:05 <Iceland_jack> but (=<<) = flip concatMap
02:22:14 <Iceland_jack> no, concatMap sorry
02:22:23 <zereraz> ok
02:22:36 <Iceland_jack> @src [] (>>=)
02:22:36 <lambdabot> xs >>= f = concatMap f xs
02:22:47 <Iceland_jack> zereraz: Can you eta-reduce the definition of (>>=)? :)
02:23:26 <zereraz> Iceland_jack: what does >>= mean
02:23:33 <zereraz> oh
02:23:35 <Iceland_jack> it's just a definition
02:23:53 <Iceland_jack> We can call it 'bind' instead
02:24:00 <Iceland_jack>     bind xs f = concatMap f xs
02:24:15 <zereraz> we can remove both arguments
02:24:22 <zereraz> >>= = concatMap
02:24:37 <Iceland_jack> almost, we first need to flip concatMap
02:24:43 <Iceland_jack> since the arguments are in the wrong order
02:24:51 <zereraz> yes
02:25:00 <Iceland_jack>     bind xs f = (flip concatMap) xs f
02:25:02 <zereraz> so it assumes arguments in the order they are passed
02:25:14 <Iceland_jack> now you can eta-reduce twice
02:25:48 <Iceland_jack> zereraz: Maybe this is helpful: http://stackoverflow.com/questions/5793843/what-does-eta-reduce-mean-in-the-context-of-hlint
02:25:57 <zereraz> Iceland_jack: ok thanks
02:26:01 <zereraz> corgifex: thanks
02:26:49 <Iceland_jack> I hope I didn't write too much and added to the confusion
02:32:27 <zereraz> Iceland_jack: no, I always get more excited to learn more when I know so many awesome things are there to learn in haskell
02:32:44 <Iceland_jack> Great!
02:33:11 <zereraz> I found LYAH in my college library, was so happy!
02:43:13 <jle`> zereraz: what a find :)
02:43:18 <jle`> what college do you go to
02:46:34 <zereraz> jle`: manipal institute of technology
02:46:45 <zereraz> jle`: had 2 copies, made my friend take the other
02:48:22 <Iceland_jack> zereraz: Form study groups, spread the knowledge! :)
02:49:46 <zereraz> Iceland_jack: I teach little bit haskell (the little bit I know). I am spreading word about it as I enjoy haskell! But I have no idea how to form study groups here.
02:51:19 <zereraz> most of the people in my class don't know about functional programming
02:51:26 <zereraz> all they know is c++,c,java
02:58:31 <jle`> zereraz: encourage them to ask questions to eachother, and work on projects together :)
02:59:48 <zereraz> jle`: I try, I am doing a project in c++, making a web server, is it possible to do in haskell?
03:00:25 <adas> > let mysum xs = foldr (\val acc initialval -> acc $ initialval+val) id xs 0 in mysum [1..5]
03:00:26 <lambdabot>  15
03:01:16 <adas> (\val acc initialval -> ...) make more sense than (\x rec acc -> ...)
03:04:42 <frerich> zereraz: One approach to teasing people into looking at functional programming techniques (not necessarily in Haskell, but that often comes naturally) is to show how it can be helpful in languages they know. Say, JavaScript.
03:04:42 <frerich> zereraz: I recently talked to a colleague who wrote a 'String createFolder(String baseFolder, String name);' function to create a new folder within a given folder and then implemented a 'createFoldersRecursively(String baseFolder, Array names);' function in order to create a whole bunch of folders.
03:05:13 <frerich> zereraz: I.e. the latter function could be called like "createFoldersRecursively("/", "tmp", "foo", "bar", "yoyo");' to create "/tmp/foo/bar/yoyo".
03:05:51 <frerich> zereraz: I think it made "click" in his mind when I mentioned that his 'createFoldersRecursively' is just ["tmp", "foo", "bar", "yoyo"].reduce(createFolder, "/");
03:06:01 <frerich> I.e. that creating a directory recursively can be considered a 'fold'.
03:06:12 <zereraz> frerich: few know javascript :( , I tell them about function passing functions as parameters and such things.
03:06:35 <zereraz> frerich: nice
03:07:22 <zereraz> many consider java their favourite language
03:08:28 <barrucadu> Any of them use Java 8? That has some functional stuff
03:09:07 <zereraz> barrucadu: I know only 1 guy who got excited about java 8 and he didn't know any functional stuff to be excited about that part.
03:12:27 <zereraz> also is it necessary or important to have functional understanding?
03:16:21 <zereraz> I have one problem, the 2nd parameter does not seem to pass http://lpaste.net/109232
03:16:48 <zereraz> that is totally wrong logic though
03:17:05 <Iceland_jack> zereraz: you're treating the 'm' as a function
03:17:27 <zereraz> Iceland_jack: am I using the guards wrong
03:17:28 <Iceland_jack> you need
03:17:28 <Iceland_jack>     | n <= 100 = n : myFibo m (n+m)
03:17:28 <Iceland_jack> if you want to 'm' and 'n + m' to myFibo
03:17:33 <Iceland_jack> no the guards are fine
03:18:34 <Iceland_jack> Trying it with 'myFibo 1 1' seems to work fine given the change above
03:18:51 <zereraz> it worked thanks
03:19:13 <corgifex> x (y z) applies the function x to the result of the function y applied to z
03:19:20 <zereraz> is this a slow implementation of fibo?
03:19:50 <zereraz> corgifex: yeah I always forget
03:21:10 <corgifex> x y z means (x y) z and applies the function x to y, and then the result (which must be another function) to z
03:21:59 <zereraz> why x to y,why not y to x
03:22:23 <zereraz> x is to left
03:22:33 <zereraz> so y would be applied to x
03:22:36 <tulcod> zereraz: it applies the value y to the function x
03:22:41 <tulcod> or vice versa
03:22:44 <tulcod> but taht's terminology
03:22:53 <tulcod> the point is that x is the function which takes the value y
03:22:53 <zereraz> yeah
03:22:59 <zereraz> got it
03:23:03 <zereraz> thanks
03:24:24 <corgifex> functions are applied to arguments
03:31:27 <zereraz> corgifex: I thought it was otherwise, thanks
03:32:02 <trap_exit> what's a good linear algebra library for haskell ?
03:34:32 <lfairy> @hackage linear
03:34:32 <lambdabot> http://hackage.haskell.org/package/linear
03:52:21 * hackagebot list-t 0.2.1 - ListT done right  http://hackage.haskell.org/package/list-t-0.2.1 (NikitaVolkov)
03:54:23 <vanila> What was wrong with previous listt?
03:54:35 <vanila> no reference provided anywhere
03:57:25 <prophile> vanila: it was bork
03:57:42 <prophile> vanila: in a whole bunch of cases it didn't actually preserve the monad laws
03:57:53 <prophile> (off-hand I think it was if you use it with any monad that isn't commutative)
03:58:19 <supki> what was wrong with the previous ListT done right?
03:58:37 <vanila> ah thanks, but no proofs in this code either!
03:59:45 <quchen> vanila: I think it misbehaved for infinite lists, or required executing more actions of the base monad than necessary
04:01:13 <quchen> Also check out the Pipes.Tutorial module, which mentions ListT a couple of times. http://hackage.haskell.org/package/pipes-4.1.2/docs/Pipes-Tutorial.html
04:01:25 <quchen> In particular, "If you sacrifice Streaming you get mapM, forM and "ListT done wrong", which are composable and effectful, but do not return a single result until the whole list has first been processed and loaded into memory."
04:03:15 <vanila> hm
04:03:28 <vanila> any idea how i'd bring this ListT data type into a proof assistant like Coq?
04:03:49 <vanila> the 'm' parameter can potentially break strict positivity
04:03:57 <prophile> Require Import ListT.
04:04:04 <prophile> :)
04:04:17 <vanila> where do i get that library?
04:12:15 <latk> Anyone know of any good tutorials for fay ?
04:19:28 <joneshf-laptop> I've got some design questions
04:19:50 <joneshf-laptop> i'm writing a program that can be used in different contexts, like If I want a curses frontend for it, or if I want a browser frontend for it, or a gui frontend.
04:20:09 <joneshf-laptop> I'd like to expose an api for the events it needs (reading from a db, communicating with a server, etc) and each of the frontends can do this in their own way.
04:20:43 <joneshf-laptop> the browser might use ajax for communicating, whereas the curses might just use shell commands or somthing
04:20:59 <joneshf-laptop> i started out trying to use ContT
04:22:01 <joneshf-laptop> but i'm not sure if this is the correct path. Should this be done this way? or is there some other way that is more robust?
04:25:34 <joneshf-laptop> in particular, i want to be able to pass the program the data it needs to operate on from each frontend or when things change and whatnot
04:27:50 <joneshf-laptop> so it'd besomething like `foo :: InputData -> ContT () IO Event`
04:27:56 <joneshf-laptop> or am i just way off here?
04:29:53 <skuggi> is there a way to write a function with the following type for conduits: Conduit a m b -> Conduit (Maybe a) m (Maybe b) ?
05:07:33 * hackagebot streaming-commons 0.1.4.2 - Common lower-level functions needed by various streaming data libraries  http://hackage.haskell.org/package/streaming-commons-0.1.4.2 (MichaelSnoyman)
05:07:35 * hackagebot wai-extra 3.0.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.2 (MichaelSnoyman)
05:08:05 <vanila> is Nikita Volkov here?
05:08:21 <vanila> curious about this cool monad transformer lib
05:27:35 * hackagebot warp 3.0.0.8 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-3.0.0.8 (MichaelSnoyman)
05:27:37 * hackagebot bitarray 0.0.1.1 - Mutable and immutable bit arrays  http://hackage.haskell.org/package/bitarray-0.0.1.1 (BalazsKomuves)
05:45:13 <tomqq> Hey all, was wondering what a good IDE for haskell is ? Esp. for OS X
05:45:13 <h4tter> @pl (\x -> f (g f x) x)
05:45:13 <lambdabot> f =<< g f
05:46:24 <rudi_s> tomqq: $EDITOR (as in emacs or vim ;-))
05:46:50 <tomqq> tool support?
05:46:55 <splintax> tomqq: i prefer vim myself, but i'm considering trying to switch to emacs because haskell-mode seems really cool
05:47:03 <splintax> what do you mean by tool support?
05:47:22 <tomqq> telling me where my types are going to break the compiler
05:47:29 <moriarty> he means support for being a tool
05:47:32 <tomqq> ^
05:49:21 <opqdonut> tomqq: the way you find out your types are wrong is by using the compiler
05:49:37 <opqdonut> tomqq: I just write code in an editor and have a ghci open for reloading the file
05:49:52 <opqdonut> (sometimes using haskell-mode's ghci integration, sometimes not)
05:49:59 <tomqq> at the moment i have the noobish approach of typing ghc -- make foo and reading errors :<
05:50:16 <opqdonut> tomqq: that's how you do it
05:50:43 <tomqq> and people writing big haskell apps in the real world are doing..?
05:53:22 <Maior> tomqq: I know what you mean - I'm looking for nice in-editor "you're doing it wrong" UI, but am yet to find anything
05:54:06 <tomqq> :'(
05:54:10 <saep> syntastic does that (or flycheck-mode in eamcs)
05:54:11 <opqdonut> tomqq: I meant, that's how I think everybody does it
05:54:38 <tomqq> ok thanks all
05:54:43 <opqdonut> tomqq: there are some IDEs, I think, or at least there used to be
05:54:46 <tomqq> i'll keep on plugging away
05:54:47 <opqdonut> tomqq: leksah for instance
05:54:57 <opqdonut> http://leksah.org/
05:55:02 <tomqq> ooo thx
05:55:09 <opqdonut> I don't know how good it's nowadays, but it used to be pretty useless :)
05:55:19 <opqdonut> then there's lots of stuff for emacs, as mentioned by saep
05:55:32 <bjobjo> in terms of type checking and linting, I've had some success with Sublime and Atom, but your mileage may vary
05:55:42 <bjobjo> Atom had a ton of other problems in my opinion
05:55:58 <bjobjo> and from what I could gather, it seems that vim / emacs is rather popular for haskell stuff
05:56:47 <Jaxan> do people use this FP haskell center thingy?
05:57:04 <bjobjo> I've been meaning to try it out - it looks good
05:58:39 <kgadek> hi. anybody succeeded in building hprotoc on GHC 7.8.x?
05:58:40 <Maior> IDEA's Haskell integration isn't that good alas
05:59:41 <kgadek> …or actually haskell-src-exts ?
05:59:52 <saep> I could probably blog about my vim setup. I've got ctags autogenerated on commits, linters are working, a funny tagbar and slime.
06:00:51 <Maior> saep: which is nice, but I think a lot of people really want the "hints as you type" sort of stuff ("that line you just typed...nope")
06:00:51 <Walther> having slime in your editor sounds unhealthy, or unsanitary
06:07:40 * hackagebot strive 0.6.1 - A Haskell client for the Strava V3 API.  http://hackage.haskell.org/package/strive-0.6.1 (fozworth)
06:09:18 <ezyang> Straw poll: who uses stackage?
06:36:18 <kstt> ezyang: "not me, but I'm not opposed to the concept"
06:36:45 <kstt> what about you ?
06:36:54 <apricity> what is the difference between + and (+) or what's it called when you put parens around the operator so I can google it
06:37:43 * hackagebot prednote 0.26.0.0 -   http://hackage.haskell.org/package/prednote-0.26.0.0 (OmariNorman)
06:38:07 <Ankhers> > (+) 2 3
06:38:08 <lambdabot>  5
06:38:13 <Ankhers> > + 2 3
06:38:14 <lambdabot>  <hint>:1:1: parse error on input ‘+’
06:38:32 <kstt> apricity: infix operators can't be partially applied without parens
06:38:50 <kstt> apricity: usual prefix functions can
06:39:11 <kstt> > let f = (+) in let g = f 1 in g 10
06:39:12 <lambdabot>  11
06:39:26 <kstt> > let f = + in let g = f 1 in g 10
06:39:27 <apricity> without the parens is + a function? like :t + gives me an error
06:39:28 <lambdabot>  <hint>:1:9: parse error on input ‘+’
06:39:44 <Ankhers> :t (+)
06:39:45 <lambdabot> Num a => a -> a -> a
06:40:10 <kstt> :t (+1)
06:40:11 <lambdabot> Num a => a -> a
06:40:15 <kstt> :t +1
06:40:16 <lambdabot> parse error on input ‘+’
06:40:20 <kstt> :t 1+1
06:40:21 <lambdabot> Num a => a
06:40:35 <Ankhers> :t ((+) 1)
06:40:35 <lambdabot> Num a => a -> a
06:43:52 <Ankhers> @src (+)
06:43:52 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
06:45:40 <ChristianS> polite as always
06:45:46 <Ankhers> fact.
06:46:11 <makalu> broccoli brain?
06:46:33 <ChristianS> Ankhers: (+) is hardwired for standard numerical types, i'd suspect
06:46:41 <Ankhers> I think it is trying to say that I eat too much broccoli.
06:46:46 <Philonous> ChristianS, No, there are primitive versions
06:47:31 <Ankhers> I was just hoping to have it show how infix operators are defined.
06:48:08 <Philonous> Ankhers, If you want to mention an infix function in a non-infix context you have to add parens
06:48:12 <Philonous> @type (+)
06:48:13 <lambdabot> Num a => a -> a -> a
06:48:24 <Philonous> > (+) 3 5
06:48:25 <lambdabot>  8
06:48:45 <Ankhers> I know. I was trying to do it for the benefit of someone else that was asking about (+) and +
06:48:59 <apricity> thanks Ankhers, I think I understand
06:49:02 <Philonous> Ankhers, Oh, maybe I should first read what was said before :>
06:49:08 <corgifex> (+) isn't a freestanding function
06:49:10 <theli0nheart> Hi all. I'm learning about liftM2 right now, and for the life of me I'm stumped with how to use it inside of GHCi. "let add = liftM2 (+)" tells me to add a type signature to fix these variables but I'm not sure how to do that...
06:49:13 <corgifex> it doesn't have a single definition
06:49:17 <Ankhers> Philonous: lol, all good. I'm still a newb myself.
06:49:41 <corgifex> theli0nheart: what's the error message?
06:50:00 <adas> is there a way to do "cabal repl" but with OverloadedStrings?
06:50:04 <geekosaur> theli0nheart, monomorphism restriction. also, `let add :: {put your type here}; add = liftM2 (+)
06:50:10 <theli0nheart> corgifex: http://lpaste.net/109245
06:50:13 <Ankhers> :set -XOverloadedStrings
06:50:15 <mmmm> Does BS.readFile prepend a "." to the path?
06:50:17 <Ankhers> once inside the repl
06:50:26 <Philonous> adas, You can :set -XOverloadedStrings inside ghci
06:50:30 <Ankhers> Thats what I do anyways.
06:50:32 <corgifex> theli0nheart: :set -XNoMonomorphismRestriction
06:50:45 <adas> Ankhers: Philonous thanks much. will try that
06:50:58 <geekosaur> mmmm: I do not understand the question
06:51:05 <theli0nheart> geekosaur: woot, that helped, thanks! let add :: Maybe Int -> Maybe Int -> Maybe Int; add = liftM2 (+)
06:51:14 <theli0nheart> corgifex: cool, I'll try that too--what does that do?
06:51:17 <Philonous> adas, Or rather, you probably you want :seti
06:51:21 <geekosaur> @where dmr
06:51:22 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:51:37 <Philonous> adas, If you get bored of typing it every time you can add it to ~/.ghci
06:51:41 <corgifex> theli0nheart: disables the monomorphism restriction
06:51:45 <barrucadu> Does ghci 7.8.3 disable the monomorphism restriction by default?
06:52:02 <adas> Philonous: seti is cool. but i think ill do the .ghci option. thanks
06:52:17 <theli0nheart> corgifex: very cool, thank you!
06:52:27 <mmmm> one sec I will show you the problem
06:52:40 <barrucadu> Ah, yes, a change as of 7.8.1
06:52:59 <angerman> Does anyone know of a deflate lib, that does not require the zlib header and adler32 checksum tail?
06:53:01 <Philonous> adas, (Just to be precise, you want to add ":seti -XOverloadedStrings" to your .ghci, if that wasn't clear)
06:53:20 <theli0nheart> Philonous: thanks for the ghci tip :)
06:53:52 <adas> oh.. i was using :set
06:54:03 <angerman> If the regular zlib deflated data looks like [2 byte header][deflated block stream][4 byte adler32 checksum], I only have the [deflated block stream].
06:54:27 <Philonous> adas, THat works, too, but it also sets it for loaded files, which can be confusing because compiling them might give you errors that loading them in ghci won't
06:55:43 <mellon85> I was trying some stuff with MTL.. but is it possible to catch an (IO) exception and get the StateT when the exception has been raised?
06:56:07 <ezyang> mellon85: Nope
06:56:17 <mmmm> geekosaur: http://lpaste.net/109246
06:57:06 <mellon85> ewell so it will be some Either stuff to do it :)
06:57:40 <geekosaur> why does that error message start with "pandoc: "? are you using the BS module prefix for an internal Pandoc library module instead of a ByteString module?
06:58:05 <geekosaur> (put otherwise: you might verify that it is that readFile that is failing, and not something later on)
06:59:53 <mmmm> geekosaur: import qualified Data.ByteString as BS
07:00:11 <mmmm> Is at the top of the file - I have a trace statement after the readFile as well which never fires
07:01:20 <geekosaur> so, do you know where the "pandoc:" prefix comes from there? did you for some reason name your program "pandoc"? (not that exceptions retrieve the program name, last I checked)
07:01:42 <geekosaur> and no, BS.readFile does not alter the pathname passed to it
07:02:14 <mmmm> yes, it's because I'm working on pandoc
07:03:01 <RyanGlScott> In this source (http://hackage.haskell.org/package/list-t-0.2.1/docs/src/ListT.html), ListT is a newtype. Yet in the docs (http://hackage.haskell.org/package/list-t-0.2.1/docs/ListT.html), ListT is data. What gives?
07:03:10 <RyanGlScott> Is this a Haddock quirk?
07:03:13 <mmmm> the easiest way to test was to build the executable which is where the prefix comes from
07:04:32 <supki> RyanGlScott: when the constructor isn't exported haddock renders newtypes as data
07:05:14 <RyanGlScott> supki: Interesting. I guess if you don't export the constructors, there's no way to distinguish newtypes from data anyways?
07:05:40 <RyanGlScott> Or could you somehow use reflection to figure it out?
07:06:45 <Philonous> RyanGlScott, Why would you want to? Without access to the constructor the distinction between netype and data becomes immaterial.
07:07:02 <RyanGlScott> Philonous: Just for curiosity's sake.
07:12:49 * hackagebot cabal2nix 1.68 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.68 (PeterSimons)
07:22:32 <corbindavenport> hi yall
07:22:33 <corbindavenport> hi yall
07:22:36 <corbindavenport> hi yall
07:22:43 <cow_2001> hey gurl
07:22:51 <corbindavenport> :-)
07:22:52 <corbindavenport> :-)
07:22:52 <corbindavenport> :-)
07:22:53 <corbindavenport> :-)
07:22:53 <corbindavenport> :-)
07:22:55 <cow_2001> O_o
07:23:01 <corbindavenport> O.O
07:23:02 <corbindavenport> O.O
07:23:02 <corbindavenport> O.O
07:23:35 * cow_2001 regrets to have woken the Furies
07:23:42 <cow_2001> awaken
07:27:50 * hackagebot mangopay 1.9 - Bindings to the MangoPay API  http://hackage.haskell.org/package/mangopay-1.9 (FelipeLessa)
07:27:52 * hackagebot yesod-mangopay 1.9 - Yesod library for MangoPay API access  http://hackage.haskell.org/package/yesod-mangopay-1.9 (FelipeLessa)
07:31:59 <pxqr> is it possible to reify Body of a top-level function?
07:34:00 <pxqr> http://hackage.haskell.org/package/template-haskell-2.8.0.0/docs/Language-Haskell-TH.html#t:Info says "The Maybe Dec field contains Just the declaration which defined the variable -- including the RHS of the declaration -- or else Nothing, in the case where the RHS is unavailable to the compiler. At present, this value is _always_ Nothing: returning the RHS has not yet been implemented because of lack of interest.". Is there another way
07:34:00 <pxqr> to do that?
07:43:37 <glaebhoerl> what's the proper term for the quasi-subtyping-like thing Haskell has going on with polymorphic types and substitution/unification (used to good effect in e.g. lens)?
07:44:02 <napping> instantiation?
07:44:19 <glaebhoerl> iirc it's not actually called subtyping, but it's basically impossible to google for (searching for things like "haskell polymorphism subtyping" just gives results about actual subtyping and comparisons with java)
07:44:25 <napping> I think there was some more specific term for one type being an instance of another
07:44:55 <napping> If you're asking specifically about getting a subtyping sort of behaviour out of polymorphism like lens does, I doubt there's a standard term
07:45:10 <frerich> I thought that in the context of Haskell, types can only be instances of classes, not of other types.
07:45:39 <glaebhoerl> frerich: depends on what you mean by "instance of". there's a relationship between `forall a. a` and `Int`. what's it called? :)
07:46:13 <frerich> glaebhoerl: The 'morphism', i.e. polymorph vs. monomorph?
07:46:49 <glaebhoerl> napping: I'm pretty sure someone had an actual term for it at some point (probably here on IRC)... but it was long ago and I can't remember. maybe I just dreamed it, but I don't think so.
07:46:51 <pqmodn_> it's called an instance, though that word is used in other contexts so it's hard to google. search for it in the context of ML type inference, where (forall a. a) is called a "type scheme"
07:46:52 <napping> frerich: "instantiation" is a standard term for filling in the polymorphic type variables, at least
07:47:06 <Philonous> Well, ((Show a, Read a) => a) is in a sense a subtype of (Show a => a) and both are polymorphh
07:48:06 <napping> I don't have my copy of TAPL handy, I'm pretty sure there was a term and it was written with a squared-off subset-eq symbol
07:48:49 <pqmodn_> the type judgement is often called T-GEN (to add forall quantifiers around free type variables) and T-INST (to eliminate forall quantifiers by instantiating bound type variables)
07:49:05 <napping> frerich: I think "instance" of a polymorphic type is most common if you are just writing about type systems, but you're right it might be better avoided
07:49:24 <napping> if there's confusion in Haskell - or just say "instance of the type"
07:50:05 <pqmodn_> or, instance of a polymorphic type to be more explicit
07:50:42 * geekosaur might use "instantiation" to avoid collision with other uses of "instance"
07:54:55 <pqmodn_> the phrase "generic instance" is used too, see Damas & Milner http://prooftoys.org/ian-grant/hm/milner-damas.pdf
07:57:24 <pqmodn_> i guess the distinction as they put it is "instantiation acts on free variables, while generic instantiation acts on bound variables".
08:02:55 * hackagebot cabal-debian 4.15.2 - Create a debianization for a cabal package  http://hackage.haskell.org/package/cabal-debian-4.15.2 (DavidFox)
08:03:00 <eacameron> how can the function to `fix` take a reference to itself as a first argument? fix takes an (a -> a), which does not take a function as its first arg..?
08:03:36 <vanila> eacameron, fix works on data too - for functions it'd be   ((e -> e) -> (e -> e)) -> (e -> e)
08:03:50 <vanila> but you can also use fix : (String -> String) -> String, for example
08:03:55 <vanila> > fix ("foo" ++)
08:03:56 <lambdabot>  "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoo...
08:04:24 <vanila> > fix (\f e -> if e == 0 then 1 else e * f (e - 1)) 3
08:04:26 <lambdabot>  6
08:04:32 <eacameron> vanila: That might be the key to the lightbulb in my brain
08:04:48 <vanila> in the second example im passing in a function of type (e -> e) -> e -> e into fix
08:04:52 <hiptobecubic> > fix ("hue" ++)
08:04:54 <lambdabot>  "huehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehuehue...
08:05:30 <glaebhoerl> relevant: https://github.com/isomorphism/subtypes/blob/master/Acme/Subtype.hs
08:06:41 <kstt> has anyone ever packaged an Haskell / Gtk3 application for windows ? I'm lost here. I don't know how to proceed.
08:07:11 <kstt> I successfully built the application, now I'm looking for a simple way to distribute it.
08:07:31 <jle`> :t \f e -> if e == 0 then 1 else e * f (e - 1)
08:07:32 <lambdabot> (Num a, Eq a) => (a -> a) -> a -> a
08:07:54 <jle`> :t fix
08:07:55 <lambdabot> (a -> a) -> a
08:08:18 <vanila> jle`, I think this is kind of confusing because it uses 'a' for two different things
08:08:30 <jle`> oh i was mostly exploring it for myself
08:08:37 <jle`> it is quite confusing, isn't it
08:08:56 <jle`> :t fix `asAppliedTo` (\f e -> if e == 0 then 1 else e * f (e - 1))
08:08:57 <lambdabot> (Num a, Eq a) => ((a -> a) -> a -> a) -> a -> a
08:10:02 <eacameron> vanila: the way I understand precedence, that expression for fix (...) 3 should give two arguments to fix; why does that work?
08:10:19 <shiona> kstt: is there more to it than statically linking everything?
08:10:28 <vanila> a b c  parses as  (a b) c
08:10:34 <vanila> so youre right
08:10:43 <kstt> shiona: is that technically possible ?
08:10:58 <ReinH> :t fix `asAppliedTo` (id :: (a -> a) -> a -> a)
08:10:58 <lambdabot> ((a -> a) -> a -> a) -> a -> a
08:11:00 <vanila> but fix creates a function in this case - so then i'm just passing a value to it
08:11:17 <shiona> kstt: I think it should be, but I have absolutely no experience in doing so
08:11:30 <kstt> shiona: I doubt we can. Even then, there are runtime files required (config schema, font config etc.).
08:12:29 <shiona> kstt: hmm, true. Hope someone who actually knows his (or her) stuff will take this from here
08:12:34 <jle`> eacameron: he's really doing (fix f) 3, but because of how precedence works in haskell, the parentheses are not required
08:13:01 <shiona> I actually just answered due to interest in knowing what was the problem, I really don't know how to help anyone
08:13:07 <vanila> > let factorial = fix (\f e -> if e == 0 then 1 else e * f (e - 1)) in factorial 5
08:13:08 <lambdabot>  120
08:13:18 <pqmodn_> glaebhoerl: beware, Acme is the humor namespace -- it's where the joke packages live :)
08:13:30 <jle`> :t fix $ \f e -> if e == 0 then 1 else e * f (e - 1)
08:13:31 <lambdabot> (Num a, Eq a) => a -> a
08:13:58 <vanila> > let fac = (\f e -> if e == 0 then 1 else e * f (e - 1)) in fac . fac . fac . fac . undefined $ 3
08:13:59 <lambdabot>  <Integer -> Integer>
08:14:03 <vanila> oops
08:14:07 <flebron> Y'know, I never really appreciated that property access and function application are syntactically identical, until I had to refactor some stuff and make a member just a computable function, and all my code still works.
08:14:09 <eacameron> jle`: huh. I guess I misunderstood precenence to always mean ALL args are applied at highest precedence. But it means only the first one, because of currynig
08:14:12 <jle`> this trick is also pretty useful for those record syntax abuses
08:14:13 <glaebhoerl> pgokeeffe: I know!
08:14:15 <vanila> > let fac = (\f e -> if e == 0 then 1 else e * f (e - 1)) in (fac . fac . fac . fac . undefined) undefined 3
08:14:16 <lambdabot>  6
08:14:19 <glaebhoerl> er
08:14:19 <vanila> this may or may not help :)
08:14:25 <glaebhoerl> pqmodn_, sorry
08:14:26 <jle`> eacameron: not necessarily because of currying :)
08:14:49 <eacameron> jle`: I meant, because we want to support currying
08:14:58 <corgifex> :t \f e -> if e == (0 :: Integer) then 1 else e * f (e - 1)
08:14:59 <lambdabot> (Integer -> Integer) -> Integer -> Integer
08:15:02 <corgifex> :t fix
08:15:03 <lambdabot> (a -> a) -> a
08:15:10 <corgifex> :t fix (\f e -> if e == (0 :: Integer) then 1 else e * f (e - 1))
08:15:11 <lambdabot> Integer -> Integer
08:15:15 <jle`> yeah, because we want to make currying look nice with our language syntax :)
08:15:49 <jle`> this trick is also used in record syntax abuses, if you are familiar with them
08:15:51 <mietek> http://input.fontbureau.com -- this is pretty cool.
08:16:34 <jle`> if have something like newtype Endo a = Endo (a -> a), then to "apply" the function i would have to do something like let Endo f = myEndo in f 4
08:16:40 <adas> is there a way to print the binary representation of a number?
08:16:45 <adas> or is there a function for that?
08:17:14 <jle`> but with record syntax, you can do newtype Endo a = Endo { appEndo :: a -> a }, then you can just do appEndo myEndo 4
08:17:15 <corgifex> :t showIntAtBase
08:17:16 <lambdabot> (Show a, Integral a) => a -> (Int -> Char) -> a -> ShowS
08:17:28 <corgifex> :t intToDigit
08:17:29 <lambdabot> Int -> Char
08:17:40 <corgifex> > showIntAtBase 2 intToDigit 100 ""
08:17:44 <lambdabot>  "1100100"
08:18:17 <corgifex> and I think printf-mauke supports printf "%b" 100
08:18:20 <jle`> > binary # 100
08:18:21 <lambdabot>  "1100100"
08:18:36 <Ankhers> :t binary
08:18:37 <lambdabot> (Choice p, Applicative f, Integral a) => p a (f a) -> p String (f String)
08:18:44 <adas> corgifex: where can i find all these functions?
08:18:47 <Ankhers> :t (#)
08:18:47 <lambdabot> parse error on input ‘)’
08:18:50 <adas> hoogle doesn't give anything
08:18:55 <corgifex> @hoogle showIntAtBase
08:18:57 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
08:19:02 <corgifex> @hoogle intToDigit
08:19:02 <lambdabot> Data.Char intToDigit :: Int -> Char
08:19:14 <jle`> import Numeric
08:19:18 <jle`> Numeric is in base
08:19:35 <corgifex> :t ( # )
08:19:36 <lambdabot> AReview s t a b -> b -> t
08:19:38 <Ankhers> :t #
08:19:39 <lambdabot> <no location info>: not an expression: ‘#’
08:19:39 <adas> thanks much
08:19:54 <Ankhers> corgifex: Thanks. Why does it require the spaces?
08:20:10 <corgifex> :t (# #)
08:20:11 <lambdabot> (# #)
08:20:17 <corgifex> shenanigans
08:20:19 <jle`> magic hash extension, i believe
08:20:40 <jle`> which gives the hash symbol some special syntax powers
08:20:50 <corgifex> :t I#
08:20:51 <lambdabot>     Not in scope: data constructor ‘I#’
08:20:51 <lambdabot>     Perhaps you meant ‘In’ (imported from Lambdabot.Plugin.Haskell.Eval.Trusted)
08:21:19 <jle`> but it's magic, as the name implies ^_^
08:21:32 <Ankhers> Indeed. What does it do exactly?
08:21:44 <corgifex> pretend to be a letter, among other things
08:22:43 <Ankhers> > binary "100"
08:22:44 <lambdabot>  Couldn't match type ‘p a0’ with ‘[]’
08:22:45 <lambdabot>  Expected type: p a0 (f a0)
08:22:45 <lambdabot>    Actual type: [GHC.Types.Char]
08:22:50 <Ankhers> :t binary
08:22:51 <lambdabot> (Choice p, Applicative f, Integral a) => p a (f a) -> p String (f String)
08:23:33 <Ankhers> I'm sure I will understand one day...
08:23:35 <supki> > "100" ^? binary
08:23:37 <lambdabot>  Just 4
08:23:57 <Ankhers> :t (^?)
08:23:58 <lambdabot> s -> Getting (First a) s a -> Maybe a
08:24:14 <corgifex> first you need to Get s t a b b e d
08:32:36 <clrnd> :t ಠ_ಠ
08:32:37 <lambdabot> Not in scope: ‘ಠ_ಠ’
08:33:12 <modeller> A (language lawyer) question about the haskell report, 2.3 comments: why "|--" does not start a line comment?
08:34:02 <modeller> I can understand the example "-->" does not start a comment because "->" is an operator. But what about "|--"
08:34:19 <geekosaur> because then you cannot ever use -- in the middle of a user defined operator
08:34:32 <corgifex> :t (|--)
08:34:33 <lambdabot> parse error on input ‘|’
08:35:02 <modeller> oh, does |-- defines an user operator?  I havent read about the user defined op
08:36:11 <geekosaur> lambdabot's (mueval's?) parser is overly strict there; ghc just accepted a definition of (|--) for me
08:37:06 <corgifex> > (|--)
08:37:07 <lambdabot>  Not in scope: ‘|--’
08:37:12 <corgifex> ah, better
08:40:18 <quchen> The Report says that a "varsym" is a (symbol (as in Unicode) that's not ":") followed by more symbols, and the entire thing together cannot be a reserved operator.
08:40:23 <quchen> So |-- should be fine.
08:43:00 * hackagebot s3-signer 0.2.0.0 - Pre-signed Amazon S3 URLs  http://hackage.haskell.org/package/s3-signer-0.2.0.0 (DavidJohnson)
08:43:02 * hackagebot haste-perch 0.1.0.2 - Create dynamic HTML in the browser using declarative notation  http://hackage.haskell.org/package/haste-perch-0.1.0.2 (AlbertoCorona)
08:43:32 <jle`> > let x |-- f = f x in 5 |-- show
08:43:33 <lambdabot>  "5"
08:43:59 <corgifex> > "nice" ---
08:44:00 <lambdabot>  "nice"
08:48:01 * hackagebot hoobuddy 0.1.0.0 - Simple tool for fetching and merging hoogle data  http://hackage.haskell.org/package/hoobuddy-0.1.0.0 (gilligan)
08:54:09 <adas> im using attoparsec and for some reason i get "Partial _" results even though all the input is consumed.
08:54:45 <adas> "parseOnly" works fine. "parseTest" and "parse" give me only "Partial _" even though all input is consumed
08:55:55 <modeller> Some part of the report is hard to understand, like this:
08:55:56 <modeller> Instead, the first unmatched occurrence of the string “-}”
08:55:56 <modeller> terminates the nested comment.
08:56:40 <c_wraith> adas: returning Partial means that it needs *more* input to terminate.  Of course it has consumed all input if it does that.
08:57:38 <napping> adas: "Partial" means it thinks it might be able to accept more input
08:58:06 <mmmm> adas: https://hackage.haskell.org/package/attoparsec-0.12.1.1/docs/Data-Attoparsec-ByteString.html#v:parseOnly
08:58:23 <adas> c_wraith: but there is no more input? I know i can pass an empty string or text to terminate but why isn't it terminating in the first place when there is no more characters in the input string?
08:58:43 <c_wraith> adas: because that's the whole point of a streaming parser?
08:59:46 <c_wraith> adas: attoparsec is designed to work with streaming data. If you don't want to supply it with streaming data, use parseOnly
09:00:14 <adas> c_wraith: oh .. so 'parse' and 'parseTest' are working as the should?
09:00:18 <eacameron> so I'm trying to rewrite some mysql-simple functions to use conduit....but the author wisely does not expose the constructor for his Query type, which means I can't easily access his underlying mechanism...is there hope?
09:00:22 <c_wraith> adas: yes
09:00:36 <napping> adas: "parse" says "here's the first chunk of input, there might be more on the way"
09:01:03 <adas> c_wraith: oh thanks. I thought there was something wrong with the parsers I was passing to "parse" and "parseTest"
09:01:40 <c_wraith> adas: well, it'll only return Partial if the parser has matched the entire input and could still accept more.
09:01:48 <glguy> eacameron: Easiest way to do what?
09:01:54 <c_wraith> adas: but if you're parsing a list of records, that's a common situation.
09:02:01 <glguy> eacameron: or rather hope for doing what
09:03:03 * hackagebot hplayground 0.1.0.1 - a client-side haskell framework that compiles to javascript with the haste compiler  http://hackage.haskell.org/package/hplayground-0.1.0.1 (AlbertoCorona)
09:03:57 <adas> c_wraith: Yup. partial simply means that input encountered so far is successfully passed
09:04:12 <eacameron> glguy: hope of subverting his protection of that type somehow and deconstruct it in my code
09:04:28 <BeardedCoder> eacameron: You trying to stream rows instead of fetching entire result set?
09:04:47 <eacameron> BeardedCoder: yes
09:05:30 <c_wraith> adas: and as you've noticed, passing an empty string to feed/the returned function is a signal for end of input.
09:06:48 <BeardedCoder> eacameron: I need that as well. I don't have the convo handy but I believe last time I asked, Bos said he didn't have support for that because of the issues Mysql has with that type of query. ie. some sort of lock on the table until the last row is read. But, I could use this as well for a constant space streaming thing I'm doing. Probably needs to be added to the mysql package and then mysql-simple.
09:07:22 <adas> c_wraith: thanks for the clarificaion. didn't know that parse and parseTest always return only Partial
09:07:48 <eacameron> BeardedCoder: Yeah, I'm aware of the mysql lock problem. he mentions that in the docs. But that just means be careful. ;)
09:08:04 * hackagebot hplayground 0.1.0.2 - a client-side haskell framework that compiles to javascript with the haste compiler  http://hackage.haskell.org/package/hplayground-0.1.0.2 (AlbertoCorona)
09:08:05 <BeardedCoder> eacameron: does the mysql package support it already?
09:08:32 <eacameron> BeardedCoder: it doesn't care either way. super thin wrapper around C calls
09:08:47 <c_wraith> adas: well, they can return Done if the parser can't accept more input, but that requires a parser that can recognize that its input stream is done without checking for end of input
09:09:20 <eacameron> BeardedCoder: I think it just involves wrapping the fetchRow with yield
09:09:31 <BeardedCoder> eacameron: I see
09:09:43 <adas> c_wraith: when you say "without checking for input" do you mean not using "endOfInput :: Parser t ()"?
09:10:37 <c_wraith> adas: no, I also mean things like not using many* or sep* parsers.
09:11:23 <c_wraith> adas: at least in the final position.  Something where the input stream has an obvious end.  For example, parsing JSON has an obvious end, when you reach the final closing }
09:11:43 <adas> c_wraith: ah okay.. got it. in some of my parsers i did use "many*" and "sep*".
09:13:04 * hackagebot haste-perch 0.1.0.3 - Create, navigate and modify the DOM tree with composable syntax, with the haste compiler  http://hackage.haskell.org/package/haste-perch-0.1.0.3 (AlbertoCorona)
09:18:46 <abc56889> Is there a way to lift m (Maybe a) into MaybeT m a? So I can use Maybe returning functions in a MaybeT? ie runMaybeT (lift myMaybeFunction)
09:19:35 <glguy> hoistMaybe = MaybeT . return :: Monad m => Maybe a -> MaybeT m a
09:19:53 <jle`> i wonder if mmorphs has the hoist already written
09:20:14 <adas> c_wraith: thanks for the clarification. I think i understood it. : )
09:21:17 <glguy> jle`: It doesn't. You'd need    type Maybe = MaybeT Identity
09:21:36 <adas> its funny how no where in the documentation for "Data.Attoparsec.Text" do I see the word "streaming".
09:21:55 <jle`> glguy: oh yeah
09:22:49 <abc56889> glguy: replacing `lift` with `MaybeT` did the trick. No idea how
09:23:02 <glguy> adas: Read the top of this page, it talks a lot about being incremental: http://hackage.haskell.org/package/attoparsec-0.12.1.1/docs/Data-Attoparsec-ByteString.html
09:23:05 * hackagebot wx 0.91.0.0 - wxHaskell  http://hackage.haskell.org/package/wx-0.91.0.0 (HenkJanVanTuyl)
09:23:07 * hackagebot wxdirect 0.91.0.0 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.91.0.0 (HenkJanVanTuyl)
09:23:09 * hackagebot wxc 0.91.0.0 - wxHaskell C++ wrapper  http://hackage.haskell.org/package/wxc-0.91.0.0 (HenkJanVanTuyl)
09:23:11 * hackagebot wxcore 0.91.0.0 - wxHaskell core  http://hackage.haskell.org/package/wxcore-0.91.0.0 (HenkJanVanTuyl)
09:23:27 <adas> glguy: i was just going thru that exact same page
09:23:44 <glguy> abc56889: You should take a moment to understand the difference in using "lift" and "MaybeT" in this context
09:24:08 <glguy> abc56889: and you can ask questions here if you get stuck, but it'll be a valuable exercise to understand the difference
09:26:13 <merijn> :t MaybeT
09:26:14 <lambdabot> Not in scope: data constructor ‘MaybeT’
09:26:19 <merijn> hmmm
09:26:22 <glguy> MaybeT :: m (Maybe a) -> MaybeT m a
09:26:47 <eacameron> is IO not an instance of MonadResource?
09:29:06 <abc56889> glguy: I think I got it, was just surprised I no longer needed lift. but it makes sense now
09:29:11 <abc56889> MaybeT :: m (Maybe a) -> MaybeT m a
09:31:45 <Twey> Cale: Do you know if I'm using ‘execute’ wrong here?  http://lpaste.net/5885517651349864448  It seems to perform some kind of unexpected caching, but the docs don't mention it.  I can rewrite ‘apply’ using ‘snapshot’ and then it works as expected.
09:32:20 <Twey> (or other people; just asked Cale because he recommended me Sodium a while back ☺)
09:45:06 <benzrf> i use reactive banana because potassium is more reactive than sodium
09:45:09 <benzrf> ^FACST
09:45:11 <johnw> eacameron: if it were, it could only free the resources at process exit, which defeats the purpose of ResourceT
09:45:23 <johnw> benzrf: cute
09:45:26 <benzrf> although i think ive been told that sodium is better. i dont know
09:45:32 <benzrf> johnw: sadly i didnt come up with that :_(
09:49:11 <jle`> that is one long teardrop
09:52:26 <adas> is there a way to represent bytes? not bytestrings?
09:52:37 <adas> i was thinking we might have a Data.Bytes
09:52:40 <adas> nothing like that
09:52:46 <jfischoff> what’s the difference?
09:53:10 <johnw> a Word8 is a single 8-bit byte, and ByteStrings are an array of those effectively
09:54:17 <jfischoff> adas: What would Data.Bytes do differently?
09:54:44 <adas> jfischoff: functions for working with individual bytes i suppose
09:54:54 <adas> or functions for working with word8's?
09:54:58 <joelteon> like bytestring?
09:55:05 <joelteon> are you talking about Bits?
09:55:08 <joelteon> still not sure what the question is
09:55:09 <jfischoff> adas: you mean like the Bits
09:55:13 <jle`> individual bytes, like bitwise operations probably
09:55:19 <jfischoff> @hoogle Bits
09:55:20 <jle`> Word8 -> Word8 functions
09:55:20 <lambdabot> Data.Bits class Num a => Bits a
09:55:20 <lambdabot> Data.Bits module Data.Bits
09:55:20 <lambdabot> Graphics.UI.GLUT.GameMode type BitsPerPlane = Int
09:55:28 <joelteon> :t (.&.)
09:55:29 <lambdabot>     Ambiguous occurrence ‘.&.’
09:55:29 <lambdabot>     It could refer to either ‘Data.Bits..&.’,
09:55:29 <lambdabot>                              imported from ‘Data.Bits’ at /home/lambda/.lambdabot/State/L.hs:57:1-16
09:55:33 <joelteon> oh c'mon
09:55:43 <jfischoff> ha
09:55:56 <adas> i think i was looking for Data.Word : )
09:55:59 <jle`> > 3 .&. 7
09:56:00 <lambdabot>  Ambiguous occurrence ‘.&.’
09:56:01 <lambdabot>  It could refer to either ‘Data.Bits..&.’,
09:56:01 <lambdabot>                           imported from ‘Data.Bits’ at L.hs:57:1-16
09:56:01 <lambdabot>                        or ‘Test.QuickCheck.Property..&.’,
09:56:01 <lambdabot>                           imported from ‘Lambdabot.Plugin.Haskell.Eval.Truste...
09:56:13 <jle`> > 3 Data.Bits..&. 7
09:56:14 <lambdabot>  3
09:56:16 <jfischoff> adas: ah
09:56:30 <joelteon> > 5 `shiftL` 3
09:56:32 <lambdabot>  40
09:56:43 <jle`> > 3 Data.Bits..|. 10
09:56:45 <lambdabot>  11
09:56:47 <adas> johnw: thanks for the hint
09:59:17 <merijn> adas: The String part of ByteString is a bit of a misnomer and the only reason it isn't changed is backward compatibility
09:59:37 <merijn> :t Data.ByteString.map
09:59:38 <lambdabot> (Word8 -> Word8) -> BSC.ByteString -> BSC.ByteString
09:59:42 <johnw> yeah, it really should be called Bytes
09:59:49 <adas> merijn: would it be changed in a future release or are there no plans for that?
09:59:51 <joelteon> well, it is a string of bytes after all
09:59:57 <johnw> it's probably the most often corrected misnomer in this channel
10:00:01 <adas> perhaps ByteArray. i think we already have that
10:00:03 <johnw> shachaf probably has a macro for saying it by now
10:00:07 <merijn> adas: Not going to happen, it would break a million things for no good reason
10:00:23 <merijn> adas: Like 98% of all libraries would have to be patched
10:00:31 <johnw> adas: did you know your name means lentil in Persian? :)
10:00:38 <joelteon> not if bos does 'type ByteString = Bytes'
10:00:40 <joelteon> easy
10:01:24 <adas> johnw: hmm.. interesting. I didn't know that. Are you persian?
10:01:35 <johnw> my wife is
10:01:36 <merijn> joelteon: Anyone having instances of ByteString would need to turn on FlexibleInstances
10:01:41 <johnw> she makes me "adas soup" often
10:01:49 <joelteon> oh right. that too
10:02:03 <zmbmartin> Anyone that can help with this error. Playing with mongodb and json -> https://gist.github.com/codedmart/e5721ae1b54649d21aa0
10:02:04 <adas> haha..
10:02:27 <johnw> zmbmartin: you didn't paste the error
10:02:35 <jfischoff> its at the top
10:02:39 <jfischoff> missing instance
10:02:48 <geekosaur> at the top, all on one line
10:03:03 <joelteon> the way vim likes it
10:03:19 <joelteon> zmbmartin, it's exactly as the compiler says
10:03:24 <joelteon> you need FromJSON for ObjectId, there is none
10:03:39 <joelteon> i'm not familiar with mongo, what is an ObjectId?
10:03:56 <zmbmartin> joelteon: Still a little new to haskell not sure how that should look.
10:04:28 <joelteon> zmbmartin: you're trying to parse an Object into a User. that means you need to parse part of the Object into a mongo ObjectId. there's no instance that tells the compiler how to do that.
10:04:37 <joelteon> how do you construct an ObjectId normally?
10:05:03 <jfischoff> constructing it in place might be better then making an orphan
10:05:12 <joelteon> right, that's where i'm trying to get to
10:05:23 * jfischoff nods
10:06:04 <zmbmartin> joelteon: Well to create one I can just do id <- genObjectId
10:06:25 <pqmodn_> oh noes
10:06:37 <adas> johnw: عدس . Thats me in persian - )
10:06:43 <Raydiation> is a functor just a typeclass that requires fmap to be implemented?
10:06:51 <adas> hope you have a unicode terminal
10:06:54 <joelteon> zmbmartin, are there functions that can convert one to Text and back?
10:07:07 <johnw> exactly!
10:07:28 <johnw> و همیشه ميخرم اسمت برای شام :)
10:07:42 <johnw> and I often eat your namesake for dinner
10:08:14 <johnw> Raydiation: and you need to know that it obeys the two functor laws
10:08:28 <johnw> Raydiation: it's quite possible to make a Functor instance that typechecks but is wrong
10:08:37 <johnw> example: instance Functor [] where fmap _ _ = []
10:08:48 <johnw> that fails the second functor law, although it passes the first
10:08:52 <johnw> sorry, other way around
10:09:10 <johnw> fails the first, passes the second.  Since the second is a free theorem, it's impossible to fail it if your definition type checks
10:09:18 <adas> "And always buy for your name" -> thats google mangling persian to english translation
10:09:20 <Raydiation> ah i see :)
10:09:32 <zmbmartin> joel I use show id to convert to string
10:09:40 <johnw> adas: oh, it's right, I mispelled a word
10:09:45 <adas> attoparsec to parse persian.. that be cool.. i think its possible
10:09:46 <Raydiation> im often wondering why the names are so complicated for these things
10:09:47 <johnw> i did say buy instead of eat
10:10:02 <adas> attoparsec.Text support unicode
10:10:02 <johnw> Raydiation: a Functor is a fundamental concept in category theory
10:11:47 <zmbmartin> joelteon: I can do this to convert back to ObjectId. let oid = ObjId $ read stringId
10:12:06 <zmbmartin> I am just not sure where to put that in the FromJSON
10:13:37 <zmbmartin> Nevermind that turns it into a Value not an ObjectId
10:19:17 <dzhus> How do I force hackage to build docs for my package?
10:20:12 <c_wraith> You can't.  It'll either build docs, or not, as it feels like, when it feels like it.
10:20:21 <dzhus> ;_;
10:20:29 <c_wraith> ...  Ok, there's some actual logic to the situation, but you might as well think of it that way
10:20:29 <wz1000>  Hi! I am trying to set up kdm with xmonad. However, whenever I log in using xmonad as my session, kdm doesn't do anything(the kdm cursor and wallpaper in still there). Plasma works fine, and xmonad runs perfectly when I run it in my kde session
10:20:35 <merijn> dzhus: If hackage isn't building your docs, it means the build of your package is broken on the hackage machine (you can checkthe build reports)
10:20:44 <c_wraith> Note that you can build docs locally and upload them to hackage, now
10:20:45 <merijn> dzhus: The good news is, you can now upload locally build docs!
10:20:54 <Raydiation> johnw: would you recommend learning category theory to understand haskell?
10:21:32 <merijn> dzhus: See http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html for relevant links
10:21:37 <merijn> Raydiation: Nope
10:21:44 <c_wraith> wz1000: this may not be the best place to get xmonad help.  There are some people here who use it, but this channel isn't dedicated to it.
10:21:52 <johnw> Raydiation: no, category theory is much more general than the subset of it we see in Haskell
10:22:03 <merijn> Raydiation: I consider myself a reasonably expert haskell programmer and I know barely any CT
10:22:08 <johnw> Raydiation: I would recommend learning category theory for its own sake, and then enjoying its connections to Haskell
10:22:14 <c_wraith> wz1000: the #xmonad channel is probably a better place to ask.
10:22:24 <merijn> (note: I'm not saying "don't learn CT", just that it's completely superfluous to learning haskell)
10:22:48 <johnw> both SPJ and Marlow hardly know any CT, if that gives you an indication of how little you need to know about it to succeed at Haskell
10:23:15 <Raydiation> i see thanks :)
10:23:18 <johnw> I asked SPJ if he was into CT and the maths side of Haskell, and he said "not at all, I let other people have fun with that"
10:24:00 <josephle> can the same be said about type theory? There seems to be some beginners who want to pursue that route.
10:24:17 <merijn> josephle: I think basic type theory is much more directly valuable to haskell
10:24:44 <johnw> yeah, knowing basic TT and how the simply typed lambda calculus works will go a long way
10:24:44 <c_wraith> No, you really do need to understand basic type theory to make sense of haskell.  ("monad" isn't a complicated topic.  higher-kinded type classes, on the other hand...)
10:24:44 <merijn> But even the advanced stuff there is overkill, although still far more practically appliable than CT
10:25:08 <josephle> do you mean up to simply typed lambda calculus with some extensions? (iso-rec types, etc)
10:25:17 <yac> how can I view installed packages with versions in cabal?
10:25:19 <glguy> You don't need to understand higher-kinded type classes to be a good haskell programmer, either :-p
10:25:32 <johnw> yac: ghc-pkg list?
10:25:33 <merijn> josephle: Haskell is loosely based on System F_omega with some extensions, I think
10:25:43 <yac> yes, thanks
10:25:45 <c_wraith> glguy: you don't need to, but it *really* helps. :)
10:25:59 <josephle> and some simplifications, if I remember the System FC spec correctly
10:26:05 <joelteon> zmbmartin: you shouldn't be using read
10:26:06 <glguy> It'll be fun but it probably won't help write clean code
10:26:06 <dzhus> merijn: c_wraith thanks for tips
10:26:28 <dzhus> build reports list is empty for my package, so probably it hasn't attempted a build yet
10:26:33 <merijn> Although I don't think *knowing* basic type theory is required for haskell, I learned basic type theory from haskell, for example
10:26:34 <int-e> yac: if you are in a sandbox, cabal sandbox hc-pkg list
10:26:44 <Philonous> glguy, Wait, you'r saying you don't need to understand Functor, Monad etc. to be good at haskell? How's that supposed to work?
10:26:53 <merijn> dzhus: Hackage batches builds, so it can take up to a day or so before it even tries
10:26:57 <zmbmartin> joelteon: OK what should I be using?
10:27:11 <merijn> Philonous: I don't think understanding those requires understanding type theory
10:27:13 <yac> How come this blows in runtime instead of compile time? git-yrp: GitYrp.hs:(127,14)-(136,9): Missing field in record construction System.Process.Internals.delegate_ctlc
10:27:25 <silver_> Philonous, you'll understand those from practical point of view
10:27:27 <int-e> yac: and with recent cabal-install versions, cabal exec ghc-pkg list  will do the right thing inside and outside of sandboxes.
10:27:27 <merijn> yac: Do you have -Wall enabled?
10:27:43 <yac> https://github.com/yaccz/git-yrp/blob/master/GitYrp.hs this is the source and it happens with process-1.2 which added a field
10:28:06 <josephle> Philonous: but you don't need to know that Functors and Monads are built on Higher-Kinded Types in order to use them
10:28:06 <bergmark> yac: if the field is strict it will fail to compile, otherwise it'll give a warning with -Wall
10:28:35 <yac> nope, don't think I have -Wall
10:28:53 <yac> but how come it's only a warning if it will will blow out in runtime anyway?
10:29:08 <joelteon> zmbmartin, what does the json look like?
10:29:17 <bergmark> yac: i agree that it's a bad thing, not sure why it was done this way
10:29:19 <merijn> yac: Same silly reason incomplete pattern matches are only a warning
10:29:55 <merijn> yac: I'm a firm believer that you should always just use -Wall and selectively disable a small number of warnings
10:30:20 <bergmark> we are actually using a record field initialized to error in one place and populating it later :-(
10:30:22 <yac> merijn: true but welp I didn't do it here yet and now this error happens
10:31:38 <yac> but with -Wall I get often warnings about shadowed variables in where clauses
10:31:56 <bergmark> yac: -fno-warn-name-shadowing if you don't like that
10:33:19 <zmbmartin> joelteon: if I print a user in ghci I get this -> User {_id = 53ea4f2f66a161a6e2000000, firstName = "Bill", lastName = "Braskey", email = "bill@email.com"}
10:33:32 <joelteon> what does the json look like, though
10:33:34 <joelteon> that's not json
10:34:05 <merijn> yac: Right, like bergmark suggests I would turn on -Wall and for every warning either 1) fix it or 2) look up the corresponding flag in the GHC manual and disable it
10:34:08 <zmbmartin> joelteon: OK, not sure then. I have some more learning and reading to do.
10:34:24 <dzhus> which GHC version does Hackage run?
10:34:40 <yac> https://gist.github.com/yaccz/396bc2ca3feea41ab312 still, no warnings
10:34:48 <bergmark> i really wish warnings could be disabled with more granularity
10:34:55 <merijn> bergmark: Word.
10:34:59 <yac> merijn: right, thanks
10:35:18 <yac> bergmark: like a preprocessor directive?
10:36:31 <bergmark> i was thinking just a pragma, `x = x where {-# SHADOW #-} x = 1' or something
10:38:00 <bergmark> i don't shadow variables, but if i could document it like that and have it checked I might
10:39:47 <yac> hrm, I have to clean the dist/ otherwise the new cabal options doensn't take effect
10:39:57 <joelteon> yeah, that'll happen
10:40:21 <merijn> yac: Oh, yeah, cabal only recompiles if source file have changed
10:41:59 <yac> hrm, process-1.1 doesn't work with ghc-7.8.3 ?
10:42:51 <bergmark> yac: nope
10:42:57 <glguy> process is one of the packages that comes with GHC
10:43:05 <glguy> so you get to use 1.2.0.0 with 7.8.3
10:43:11 <yac> hrm
10:44:15 <yac> I have a problem now that I need to support ghc-7.8 as well as 7.6
10:44:17 <yac> what do I do?
10:44:49 <yac> add some CPP magic to know which version I'm building against?
10:44:53 <glguy> Write code that works against both versions of process
10:44:57 <glguy> and CPP where that's not possible
10:45:14 <yac> glguy: well I have the problem that CreateProcess has new field in process-1.2
10:46:44 <merijn> yac: Right, you'll have to CPP around that, I fear
10:47:12 <yac> so how do I get the define?
10:47:16 <geekosaur> #if MIN_VERSION_process(1, 2) ... #else ... #endif
10:47:27 <geekosaur> tell cabal that you're using the CPP extension
10:47:34 <geekosaur> cabal will arrange for it to work
10:47:45 <yac> so I just enable CPP and MIN_VERSION... will appear automatically?
10:47:46 <glguy> yac: Instead of using the CreateProcess constructor, you can figure out if one of the smart constructors does what you want (shell, proc, etc.)
10:47:55 <glguy> yac: and then use record update syntax for the changes you need
10:47:57 <yac> glguy: I couldn't find one
10:48:17 <glguy> yac: find the *closest* one and then use record update syntax to fix the differences
10:48:25 <geekosaur> yac: if cabal knows that you are using CPP, yes, it will provide those for all declared package dependencies
10:48:44 <yac> geekosaur: cool
10:49:35 <enthropy> yac: look in dist/build/autogen for where those macros are defined
10:49:36 <glguy> yac: there's one smart constructor for each case of CmdSpec (two in total)
10:49:45 <glguy> so there's no need to introduce CPP
10:50:09 <enthropy> yes avoid it if you can
10:50:27 <zmbmartin> joelteon: I updated the gist to add what the json looks like -> https://gist.github.com/codedmart/e5721ae1b54649d21aa0
10:50:37 <yac> glguy: thanks, I'm just googling for how to use the update synta
10:50:49 <joelteon> huh.
10:50:59 <joelteon> zmbmartin, you can use reads or readMay instead of read
10:51:01 <joelteon> because they're not partial
10:51:19 <glguy> proc "myproc" { cwd = Just something }
10:54:10 <zmbmartin> joelteon: OK I am just not sure how/where to add that to the FromJSON stuff.
10:54:37 <joelteon> zmbmartin: you can either put it in your FromJSON of User, or you can define a new FromJSON instance for ObjectId
10:54:42 <joelteon> the latter will be an orphan, so I'd choose the former
10:55:17 <zmbmartin> joelteon: OK I will look at that, Thanks for your help!
10:58:02 <eacameron> can I use Reader for connection pooling, for example? The pool will have to update itself on request, but the monad code doesn't ever "write"
11:00:38 <merijn> eacameron: You could have a connection pool in an MVar and pass that using reader, for example, yes
11:00:51 <eacameron> merijn: excellent
11:02:00 <yac> glguy: thanks, it's working
11:03:06 <merijn> eacameron: Hell, you could have an "IO Connection" action that takes a connection from a pool/allocates a new one and pass that using reader
11:03:12 <merijn> eacameron: First class IO \o/
11:06:01 <koral> when using Text.Parsec.Text to parse from a Text rather than a String, is it possible to use the definitions from Text.Parsec.Char ? GHC complains about a mismatch between Char and Word32, not sure if this is a problem in my code or if it is simply not possible to mix both modules...
11:06:55 <joelteon> if you're trying to match a character, you could do char (fromIntegral $ ord 'c')
11:06:58 <joelteon> or whatever character you're matching
11:07:10 <koral> I'm actually using noneOf "<>"
11:07:19 <joelteon> noneOf $ map (fromIntegral . ord) "<>"
11:07:40 <joelteon> or of course you could just figure out ord < and > and add them as constants and put in a comment about what characters those are
11:08:21 <koral> looks pretty heavy for such a simple parser, why isn't that snippet part of the library already ?
11:08:53 <joelteon> dunno
11:10:09 <koral> hmmmm GHC still complains about the same thing
11:10:43 <glguy> koral: You can use noneOf with Text directly
11:10:48 <glguy> you're doing something else weird
11:11:40 <koral> I have OverloadedStrings enabled, wouldn't GHC have already tried with Text if it were possible ? Let me test it manually
11:11:47 <glguy> Text.Parsec.Char.noneOf "<>" :: Text.Parsec.Text.Parser Char
11:12:15 <glguy> The problem is probably that you're trying to use the result as a Word32
11:12:38 <koral> Couldn't match expected type ‘[Char]’ with actual type ‘Text’
11:12:49 <glguy> You need to give noneOf a String
11:13:05 <glguy> Text.Parsec.Char.noneOf  :: Stream s m Char => [Char] -> ParsecT s u m Char
11:13:20 * hackagebot fastbayes 0.2.0.0 - Bayesian modeling algorithms accelerated for particular model structures  http://hackage.haskell.org/package/fastbayes-0.2.0.0 (ChadScherrer)
11:13:30 <koral> got it, I was indeed expecting a Word32 in the end
11:14:43 <koral> what I want is probably fromIntegral . ord <$> noneOf "<>"
11:16:00 <koral> I'm not sure to understand why this works though
11:16:56 <glguy> class Monad m => Stream s m t | s -> t;   instance Monad m => Stream Text m Char
11:18:57 <josephle> :t ord
11:18:57 <lambdabot> Char -> Int
11:20:43 <koral> it looks like I'm parsing a String and converting it to Text afterwards
11:21:08 <koral> (fromIntegral . ord) is Char -> Word32
11:21:10 <glguy> The way parsec parses Text is to unpack one Char from the Text at a time
11:21:33 <glguy> \xs -> anyToken >>= \x -> if x`elem`xs then parserZero else return x
11:21:33 <glguy>   :: (Stream s m b, Show b, Eq b) => [b] -> ParsecT s u m b
11:21:50 <glguy> noneOf isn't using the String for its String properties, but for it's list of tokens
11:22:19 <glguy> pops a Char off the Text, looks at the list of prohibited tokens
11:23:21 <koral> ok I get it : Text becomes a stream of Char, which go through parsers
11:23:44 <koral> at first sight, I thought it was defeating the purpose of using Text
11:27:48 <yac> how can I debug an exception in ghci?
11:28:08 <yac> when I don't know where it is thrown from
11:31:10 <scooty-puff> is there an algorithm to, given all the type instances, derive the most restrictive functional depenencies on a type class?
11:31:25 <spopejoy> hi y’all. any ideas wtf is up with my ghci?? I’m getting “Could not deduce (transformers-0.3.0.0:Control.Monad.IO.Class.MonadIO”
11:31:37 <spopejoy> from a simple import Control.Monad.IO.Class (liftIO, MonadIO)
11:31:53 <spopejoy> it’s saying “Possible fix:
11:31:54 <spopejoy>       add (transformers-0.3.0.0:Control.Monad.IO.Class.MonadIO
11:31:54 <spopejoy>              m) to the context of"
11:32:03 <Ankhers> spopejoy: Do you have multiple versions of the tansformers package installed?
11:32:06 <scooty-puff> e.e. class Plus a b c where (+) :: a -> b -> c, instance Plus Int Int Int, instance Plus Char Int Int, instance Plus Int Char Int, instance Plus Char Char Char, would derive a b -> c
11:32:10 <scooty-puff> *e.g.
11:32:12 <spopejoy> lemme check
11:32:17 <geekosaur> spopejoy, usually when ghc includes a package name, it's got multiple versions of the pacge in scope
11:32:19 <merijn> spopejoy: version number package names generally imply you're trying to use multiple different versions of a package
11:33:33 <etandel> you know you are doing too much haskell when someone talks about the Transformers movie and you think about monads.
11:33:40 <spopejoy> is ‘ghc-pkg hide’ the way to resolve?
11:34:12 <spopejoy> i do have two transformers, 0.3.0.0, 0.4.1.0
11:35:31 <oisin876> I'm writing a Haskell function that has a type signature like: a -> b -> c -> (m, n, o, p). Unfortunately, I have other functions that take (m, n, o, p) as input and return some other egregious tuple combination. They all deal with some permutation of m, n, o, and p, though. Is there a way to simplify my types using a monad? I'm thinking something like State for multiple values?
11:35:49 <glguy> The way I handle that particular problem is to have "constraint: transformers installed" in my ~/.cabal/config (along with all the other GHC provided packages)
11:35:59 <glguy> to avoid accidentally installing extra versions of those packages
11:36:06 <geekosaur> often when you're using an n-tuple with n > 2, you're better off with an ADT
11:36:23 <spopejoy> actually larger question
11:36:32 <spopejoy> i installed haskell w/ haskell platform
11:36:41 <geekosaur> the exceptions are usually one-offs where the tuple just collects disparate values (see for example createProcess)
11:36:50 <geekosaur> and you never use them as a group after getting them
11:37:24 <yac> so I got a trace with :set -fbreak-on-exception and then :history but the trace doesn't make any sense
11:37:38 <spopejoy> haskell platform installs into /usr/bin, etc. But then I use cabal as my user, which installs into ~/Library/… (OSX). Is there a way to setup haskell platform without installing into root /Library, /usr/bin, etc?
11:37:58 <oisin876> geekosaur: Thanks, I think that I will use an ADT - I'm unsure how the types are related, but they must be since I pass them around a bit. Thanks!
11:38:08 <geekosaur> spopejoy, wait for the new platform to get into macports/homebrew/etc.? otherwise I think you need to build from source
11:38:28 <geekosaur> and since it's framework-based, it will give you trouble unless it's in a well defined framework location
11:38:53 <spopejoy> should i be running cabal install as root then?
11:39:07 <spopejoy> methinks I want to stick with haskell platform.
11:39:08 <geekosaur> um. almost never
11:39:24 <spopejoy> sure, so how do i avoid the two-headed cabal monster?
11:39:30 <geekosaur> you really, really want to let ghc and platform stuff be separate from your local packages
11:39:51 <geekosaur> you WILL get into massive messes requiring a full platform wipe and reinstall otherwise
11:40:00 <glguy> you edit your .cabal/config and add constraints for the HP packages so that you don't get duplicates
11:40:17 <spopejoy> ok
11:40:36 <geekosaur> note that you can still get duplicates if you force everything into the same package database. and it's much harder ot recover in that case
11:40:52 <spopejoy> how do i get out of the current mess, ghc-pkg hide? ghc-pkg unregister?
11:41:05 <geekosaur> ghc-pkg unregister, typically
11:41:39 <Ankhers> cabal sandboxes are pretty good.
11:41:45 <glguy> I have a script I use for recursive unregister and for detecting multiple installed versions of packages: https://github.com/glguy/GhcPkgUtils
11:41:51 <dmj`> das sandbox es gut
11:42:01 <Ankhers> (at preventing this from happening)
11:42:18 <glguy> supporting "GhcPkgUtils outdated" "GhcPkgUtils multiversion" "GhcPkgUtils unregister <thepackage>"
11:42:25 <spopejoy> arg. that’s what i get for trying out optparse-applicative :)
11:43:10 <spopejoy> ghc-pkg is saying unregister transformers-0.4.1.0 would break optparse-applicative. Do I just —force and cross my fingers with optparse?
11:43:31 <glguy> No, you unregister optparse
11:43:37 <glguy> and then come back to transformers
11:43:54 <spopejoy> edit cabal/config and reinstall optparse after?
11:44:16 <glguy> That'd work
11:44:45 <Fermata> w/ 25
11:45:05 <spopejoy> any other HP packages I should constrain in cabal/config?
11:54:25 <spopejoy> found a nice list on teh interweb http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
11:56:49 <spopejoy> HP should really come with that list pre-configured somehow. This is a noob nightmare otherwise
11:57:12 <spopejoy> Spoken as a noob, but I happened to deep-dive ghc-pkg just the other day, so I had some idea what to do
11:57:54 <dfeuer_> If Control.Monad.Trans.List is considered "done wrong", why isn't it deprecated?
11:58:40 <spopejoy> problem fixed, back to trying to get enumerators to work reading a terminal process output. am i crazy? should I be using pipes or conduit?
11:59:37 <orion> My application is experencing a memory leak. I profiled it and got this result: http://i.imgur.com/9vCsdZF.png does anyone know what could be going on? (http://ideone.com/BEbeSi)
12:00:04 <enthropy> dfeuer_: the maintainer of transformers probably doesn't share that opinion?
12:00:46 <orion> In particular, what is "ghc-prim:GHC.Types." ?
12:00:58 <dmj`> orion: you are strictly reading wallet.dat into memory
12:01:50 <codile> orion: how did you produce that graph?
12:02:09 <orion> codile: ./antigone +RTS -h
12:02:22 <codile> thank you :)
12:02:52 <orion> dmj`: The reason I do that is because I only want to read from disk once.
12:03:07 <orion> And I only want to base64 decode it once.
12:05:26 <dfeuer_> enthropy, ah, it appears the maintainer sees it as useful in some circumstances and much easier to understand: http://www.haskell.org/pipermail/libraries/2013-July/020381.html
12:07:39 <orion> dmj`: Is my logic wrong there?
12:08:26 * hackagebot constraints 0.4 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.4 (EdwardKmett)
12:09:41 <dmj`> orion: case cs of [] -> return [c'] will never be called, I think you can just do permute = concatMap leet, which means you have nested calls to concatMap, which might cause a lot of heap allocation
12:09:59 <dmj`> orion: oh wait, nvm, it will
12:10:12 <dmj`> orion: but you still have nested concatMap calls
12:10:13 <n-dolio> edwardk isn't the maintainer of transformers.
12:10:39 <n-dolio> Ross Patterson is.
12:10:54 <n-dolio> And he says in that thread that there are 140 packages using ListT, which is why it isn't gone.
12:11:20 <eacameron> how do you *make* a NominalDiffTime
12:11:23 <edwardk> dfeuer_: i just maintain the mtl, which wraps transformers with useful instances
12:13:26 * hackagebot binary-list 0.1.0.2 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.1.0.2 (DanielDiaz)
12:13:53 <dmj`> orion: no, you don't, I'm wrong :)
12:14:07 <eacameron> :t NominalDiffTime
12:14:08 <lambdabot> Not in scope: data constructor ‘NominalDiffTime’
12:14:46 <burrito`> Is unbalance brace allowed since the report says: Instead, the first unmatched occurrence of the string “-}” terminates the nested comment.
12:15:23 <burrito`> 2.3
12:16:32 <eacameron> oh. the answer is likely (fromRational x :: NominalDiffTime)
12:23:23 <flebron> Hi. If I have a type with some members ({ foo :: bar, baz :: quux }), can I have a function f, that sometimes (depending on some stuff) changes the "foo" field, sometimes the "baz" field?
12:23:28 * hackagebot props 0.1.2 - Reusable quickcheck properties  http://hackage.haskell.org/package/props-0.1.2 (AlecHeller)
12:23:48 <Cale> flebron: yes
12:23:48 <flebron> I can't just use record notation like obj { f = 1 }, can I?
12:23:54 <Cale> Right, no
12:24:03 <Cale> You'll need a conditional of some sort
12:24:21 <Cale> You could use if/then/else or case, or top level pattern matching
12:24:59 <Cale> But in each branch of the conditional, you can use that syntax
12:27:02 <flebron> Hrm, OK, somewhat unwieldly :p
12:27:23 <flebron> Seems like a reasonable use for lenses, no?
12:28:07 <edwardk> flebron: certain very restricted forms of the problem may be suited to lens, yes
12:28:28 * hackagebot DBus 0.5.1 - D-Bus bindings  http://hackage.haskell.org/package/DBus-0.5.1 (AlexanderKojevnikov)
12:31:03 <flebron> I'm benchmarking some code, and I wanted my program to receive parameters like ./foo --property whatever --from 10 --to 100 --step 10, and run a bunch of timings on instaces where the "whatever" property of my object is 10, 20, ..., 100. I was thinking of using a conditional with HFlags on flag_property, and what that returns is a lens (or something) that I can use to say "changeTo i", for i = 10, 20, ..
12:31:05 <flebron> 100, where changeTo returns a default instance, with the property being changed each time.
12:32:01 <edwardk> flebron: my experience is usually that you want the lens itself to be dumb, and that you want to build all your business logic outside of them. they just define how to get in and get at a thing, all the intelligence about how to wield the tool comes from outside
12:34:51 <JohnTalent> when one contructs his/her types , one fully thinks of the extents of his/her program before hand.
12:38:32 <edwardk> JohnTalent: i'd argue almost the opposite. i sit down bang out some data type, then try to figure out what things it is an instance of
12:38:48 <edwardk> JohnTalent: by the time i'm done with that supply of questions i better understand the weird thing i wrote
12:39:29 <edwardk> and if i can then identify it in category theory as well as some weird haskell data type, then it probably is fundamental, if not then i repeat the experiment with another type ;)
12:40:24 <flebron> And thus Hackage is born :p
12:42:42 <timmy_tofu> I'm getting Ambiguous module errors when running doctest (but not for my project overall) - is there a better way of solving this than package-qualified imports? The correct package is specified in my cabal file, the  other one is unmentioned directly. I've tried adding the proper package to the doctest block in the cabal file as well; no change
12:42:47 <timmy_tofu> (xpost from #hspec)
12:47:38 <Mathnerd314> is there an equivalent of MonadTrans for Applicative?
12:48:07 <pjdelport> Mathnerd314: Applicative pretty much composes just with type composition.
12:48:13 <merijn> Mathnerd314: Don't need one, two nested Applicatives are already compose
12:48:19 <merijn> Mathnerd314: See Data.Functor.Compose
12:49:11 <Mathnerd314> but I want the lift function, in this case (Applicative f) => f a -> ReaderT r f a
12:49:59 <Mathnerd314> I can see it defined here: http://hackage.haskell.org/package/transformers-0.4.1.0/docs/src/Control-Monad-Trans-Reader.html#liftReaderT
12:50:27 <Mathnerd314> but it's only exported through MonadTrans
12:52:33 <zmbmartin> joelteon: So I can't figure this part out. If I pass (Object v) to parseJSON as parseJSON (Object v) = …..
12:53:01 <zmbmartin> I have a where id = ObjId $ reads <- what do I do here?
12:53:16 <zmbmartin> If I want to reads the "_id" from v?
12:57:52 <mjrosenb> can lambdabot be privmsg'd for @pl, and others?
12:58:12 <mjrosenb> woah, I was /way/ behind on scrollback.
13:00:41 <Mathnerd314> aha, that's it. I just need Alternative.
13:01:51 <pjdelport> mjrosenb: Yes.
13:02:14 <pjdelport> lambdabot can be your ghci away from home. :)
13:03:32 * hackagebot bytes 0.14.1 - Sharing code for serialization between binary and cereal  http://hackage.haskell.org/package/bytes-0.14.1 (EdwardKmett)
13:18:07 <eacameron> is there a lifted form of atomically?
13:20:41 <merijn> eacameron: What do you mean by that?
13:21:02 <eacameron> atomically :: MonadIO m => STM a -> m a
13:21:17 <corgifex> :t liftIO . atomically
13:21:18 <lambdabot> Not in scope: ‘atomically’
13:22:17 <eacameron> corgifex: yeah....I guess I expected that to be built in. I'm surprised how often things are not polymorphic? what's the reason? i.e. async vs lifted-async. Why doesn't async just use polymorphism?
13:22:35 <corgifex> dunno, I've never seen lifted-async
13:23:12 <lispy> People typically use IO non-polymorphically.
13:23:30 <lispy> I can't really think of any good reasons for that (or against it)
13:23:40 <eacameron> lispy: but don't people also tend to use their own monad transformer stacks?
13:23:56 <eacameron> so now you have to liftIO everywhere because the lib author's didn't bother to lift
13:24:43 <Cale> eacameron: I avoid any use of monad transformers where people would be able to tell I was using monad transformers from outside the module.
13:25:27 <eacameron> but libs are meant to be small pieces of reusable stuff oftentimes, right?
13:25:35 <Cale> (well, sometimes exposing a MonadIO instance can be justified, but you should generally newtype and try to provide enough stuff so that people won't need to liftIO, and certainly enough so they don't have to lift)
13:26:52 <eacameron> so async is an example of that; you have to lift a lot
13:27:04 <eacameron> and whats more, once you've lifted, you can't use your monad anymore :(
13:27:16 <ion> Is there a type like this in some popular library? Probably not, it’s a bit weird. data ListAnd final a = End final | Cons a (ListAnd final a)
13:27:18 <eacameron> so you can't propagate your monad into the maps, folds, etc
13:27:26 <Cale> Async isn't even a monad
13:27:32 <Cale> let alone a transformer
13:27:39 <eacameron> I know, but it's a library that doesn't lift
13:27:44 <ion> do you even lift?
13:27:50 <eacameron> no
13:28:02 <eacameron> I'm too busy complaining about libs to lift
13:28:30 <Cale> I think Async is well-designed, myself.
13:28:40 <eacameron> so someone had to make lifted-async so that I can mapConcurrently (MYMONADFUNC) [data]
13:28:50 <Cale> It provides the operations that you need, and doesn't try to force a Monad instance.
13:29:17 <supki> ion: Free (a,) b ?
13:29:23 <corgifex> ion: (final, [a])?
13:29:28 <eacameron> Cale: doesn't it force IO?
13:29:30 <Cale> I'm not sure what you mean there
13:29:33 <flebron> What could be the cause for "Could not find module `HFlags'", and "All the requested packages are already installed: hflags-0.4"?
13:29:40 <eacameron> :t mapConcurrently
13:29:41 <lambdabot> Not in scope: ‘mapConcurrently’
13:29:48 <Cale> Of course it requires IO in places.
13:29:54 <Cale> Because creating threads does.
13:30:08 <Cale> It is specifically for managing asynchronous IO
13:30:19 <Cale> So, it would make a whole lot of sense to involve it :P
13:30:27 <eacameron> Cale: perhaps I misunderstand how things work...so this is good for me to hash out
13:30:39 <eacameron> Cale: of course, but sometimes I write transformers on top of IO
13:30:39 <lispy> Cale: I think the question was, why not MonadIO?
13:31:06 <ddrone> Hi everyone. I am looking for examples of using extensible-effects, maybe someone could point me to it?
13:31:13 <Cale> lispy: Because MonadIO only provides a way to turn IO actions into actions of a more structured type, which isn't enough.
13:31:46 <ion> corgifex: That lets me evaluate final before evaluating the [a] fully.
13:32:10 <Cale> lispy: In order to forkIO something, you need to have an IO action in hand. Async does a bit of stuff to the action before forkIO, but that's pretty much what it's doing.
13:32:15 <corgifex> ion: bonus!
13:32:16 <eacameron> this has bit me twice, for example: I have a ReaderT thingy with my state that I need to use. Then I want to mapConcurrently (myFunc :: MyMonad Int) [data]
13:32:30 <ion> corgifex: malus :-P
13:32:31 <Cale> The solution to that is stop using ReaderT over IO
13:32:32 <lispy> Cale: yeah, that makes sense.
13:32:39 <corgifex> bad apple
13:32:53 <eacameron> Cale: How? By not using ReaderT?
13:32:53 <Cale> ReaderT and StateT are totally overused
13:32:56 <Cale> yes
13:33:02 <eacameron> what instead?
13:33:10 <corgifex> function parameters :-)
13:33:12 <Cale> ReaderT is an awkward notation for function parameters
13:33:33 <luite> use implicit parameters instead ;)
13:33:34 <corgifex> @unmtl ReaderT r IO a
13:33:34 <lambdabot> r -> IO a
13:33:36 * hackagebot free-functors 0.6.3.2 - Provides free functors that are adjoint to functors that forget class constraints.  http://hackage.haskell.org/package/free-functors-0.6.3.2 (SjoerdVisscher)
13:33:39 <Cale> luite: lol
13:33:44 <eacameron> Cale: agreed
13:33:47 <Cale> Just use dang function parameters!
13:34:02 <ion> supki: Thanks, but i think i’ll just use my type.
13:34:08 <corgifex> and then eliminate them again!
13:34:37 <joneshf-laptop> i'm looking to have a program running that uses some data from the outside world. I'd like the data to be modifiable at runtime, but only from the top level, (not from any of the other functions used during the program). However, I'd like for each function to be able to notify the top level when it wants to change something, or get something new, or whatever.
13:34:39 <Cale> Yeah, sure, *if* you write your program using function parameters, and then you see a way that you could wrap everything up more cleanly, then great
13:34:48 <luite> i thought no one used those, until i updated the gloss backend for ghcjs last weekend, gloss uses them, first time i've seen them in ages
13:34:52 <Cale> But don't start out with a ReaderT before you know it's going to work out perfectly.
13:34:53 <joneshf-laptop> ive tried using ContT but didn't get as far as id have hoped
13:35:05 <joneshf-laptop> any suggestions on what to look at?
13:35:38 <eacameron> Cale: that's what I did, both times ;)
13:35:39 <Cale> The extra lifts you need to write are syntactic overhead which usually costs at least as much as the parameter passing would have
13:36:15 <desophos> anyone know of any machine learning or AI-related channels? i'd like to have people to talk to about up-to-date resources. #machinelearning doesn't seem to be active
13:36:22 <corgifex> I eliminate my parameters with @pl
13:36:26 <desophos> uhhh i don't know if this is the best place to ask, sorry
13:36:39 <Cale> So unless you can package things up in some way that avoids explicit lifting, then it's better just to pass the parameters
13:37:31 <Cale> desophos: It's an okay place to ask. I don't know how many people around here are involved with it, but I think mauke is kinda involved in that kind of thing (more on the applied computational linguistics side of things)
13:37:38 <corgifex> http://hackage.haskell.org/package/reflection teehee
13:38:12 <corgifex> Cale: that would surprise me
13:38:34 <corgifex> linguistics is linked to augur, though
13:39:09 <Cale> joneshf-laptop: I'm not sure I totally understand your question, but breaking up an IORef by partially applying readIORef and writeIORef and then passing the results around tends to work well
13:39:34 <Cale> joneshf-laptop: and you can elaborate those actions to, say, do logging, before passing them along to the rest of your program
13:39:49 <stalintrotsky> can I use liftM to lift catch into a StateT s IO monad?
13:40:09 <corgifex> no
13:40:13 <Cale> stalintrotsky: uh, no
13:40:43 <Cale> The type of liftM would specialise like:  liftM :: (a -> b) -> StateT s IO a -> StateT s IO b
13:40:55 <Cale> :t Control.Exception.catch
13:40:56 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
13:41:00 <joneshf-laptop> Cale, yeah, i think i explained that poorly.
13:41:01 <stalintrotsky> so it would just operate on the inner inner value?
13:41:03 <desophos> thanks Cale, where do you think would be a better place to ask? google just turned up #machinelearning
13:41:56 <Cale> desophos: I'm never quite sure how best to discover IRC channels. I just use my IRC client's search and see what I get, or get told about them from other people.
13:42:13 <desophos> haha yeah, that seems to be it
13:42:26 <desophos> i also end up on subreddit channels
13:43:00 <Cale> There's this #ml-class channel
13:43:28 <desophos> yeah, that seems to be for a specific coursera class that is over
13:43:36 * hackagebot prednote-test 0.26.0.0 - Tests and QuickCheck generators to accompany prednote.  http://hackage.haskell.org/package/prednote-test-0.26.0.0 (OmariNorman)
13:43:38 * hackagebot groundhog 0.6.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-0.6.0 (BorisLykah)
13:43:40 * hackagebot groundhog-th 0.6.0 - Type-safe datatype-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.6.0 (BorisLykah)
13:43:42 * hackagebot groundhog-sqlite 0.6.0 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.6.0 (BorisLykah)
13:43:44 * hackagebot groundhog-postgresql 0.6.0 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.6.0 (BorisLykah)
13:43:47 <Trollinator> given some record x, I can do stuff like x { foo = bar }. Is there a more convenient way to write something like \x -> x { foo = bar }?
13:44:20 <Cale> Trollinator: Not exactly. At a point, that's kind of what lenses are about.
13:44:29 <corgifex> yes, an imperative language
13:44:41 <Cale> ?
13:44:42 <corgifex> have you tried perl?
13:44:52 <stalintrotsky> is there a way to transform values that operate on monadic values of m a to operate on transformed monadic values where the inner monad is m?
13:44:55 <Trollinator> corgifex, wtf are you talking about?
13:45:06 <stalintrotsky> transform functions*
13:45:10 <Cale> corgifex: That operation tends to be even more complicated in an imperative language, since you have to clone explicitly.
13:45:25 <Cale> (and do deep copying and stuff)
13:45:37 <corgifex> Cale: ah, but in an imperative language you can do REAL updates!
13:45:43 <josephle> :t liftM
13:45:44 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
13:45:52 <Cale> corgifex: But that's not what Trollinator is asking about
13:45:58 <corgifex> stalintrotsky: example?
13:46:01 <Cale> You can do real updated in Haskell too
13:46:04 <Cale> updates*
13:46:08 <Trollinator> I don't *want* destructive updates.
13:46:12 <Cale> But the types would be different :P
13:46:14 <desophos> oh, #ml-class does still have some users
13:46:15 <stalintrotsky> I have a bot that runs in StateT Bot IO
13:46:25 <Trollinator> and I have no idea what made you think I did.
13:46:26 <stalintrotsky> There are parts that are only IO that I could put catch around
13:46:29 <hiptobecubic> corgifex, you mean you *must* do "real" updates and if you don't want that, too bad
13:46:33 <stalintrotsky> but sometimes the exception comes later due to lazy reading
13:46:37 <Cale> stalintrotsky: Not in general
13:46:49 <stalintrotsky> so I want to be able to keep it in the state monad and keep the state when I do backup plans
13:46:50 <Cale> stalintrotsky: lift only gives you one direction
13:46:52 <stalintrotsky> ok
13:47:07 <stalintrotsky> I don't think it would be too hard to write a custom catch function would it?
13:47:12 <joneshf-laptop> Cale, So, I need to do a few different things, e.g. read a db somewhere or send http requests. I'd prefer if these werent randomly strewn throughout the codebase, and would rather they we only at the top level. so i'd like to have my functions that need to do something liek that "request" (for lack of better word) for new data or "request" that something be sent to a db.
13:47:13 <Cale> stalintrotsky: the other direction ("running") tends to require case-specific information
13:47:28 <Trollinator> it seems weird that getter functions are automatically generated when defining a record but no setters.
13:47:30 <Trollinator> oh well.
13:47:43 <corgifex> yeah, see lens
13:47:56 <Cale> Trollinator: Yeah, lens provides this kind of thing
13:48:16 <Cale> Trollinator: and it would be kind of cool if the field names were lenses instead of getters
13:48:30 <Cale> (but that's a major breaking change to the language at this point)
13:48:37 * hackagebot groundhog-mysql 0.6.0 - MySQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-mysql-0.6.0 (BorisLykah)
13:48:58 <joneshf-laptop> Cale, i was trying with `ContT` because i thought I could just wrap up the different "request"'s in a data type and let the top level deal with it.
13:49:14 <joneshf-laptop> Cale, this works, but i can't seem to figure out how to make it loop with the new data
13:49:20 <eacameron> Cale: so I see there's also lifted-base.....
13:49:28 <joneshf-laptop> Cale, sorry, kind of all over the place with this question
13:49:29 <Cale> joneshf-laptop: Right, so you need a representation for those requests. You could choose to make a data type for representing all the possible requests, or if you're lazy, you can just use IO actions to represent them
13:49:46 <Cale> hmm
13:50:05 <Trollinator> lens seems scary to me.
13:50:15 <joneshf-laptop> Trollinator, it's very unscary
13:50:17 <edwardk> don't worry, its scary to me too
13:50:26 <Cale> It is scary, what are you talking about :D
13:50:31 <k00mi> OverloadedRecordFields will introduce some support for lenses
13:50:44 <Cale> But there's a simple idea in there
13:50:50 <Cale> which is not so scary
13:50:55 <Trollinator> edwardk: you're not helping :D
13:51:04 <joneshf-laptop> that's what i'm talking about, the actual idea
13:51:13 <joneshf-laptop> not the library
13:51:14 <Cale> (the library as a whole though...)
13:51:24 <joneshf-laptop> blows my mind
13:51:26 <corgifex> s t a b b y
13:51:31 <eacameron> where can I get some polarized-lens?
13:51:46 <corgifex> sorry, I only have prisms
13:51:51 <Trollinator> cause everything I've heard from edwardk so far makes me think he has a head the size of Beijing
13:52:06 <Cale> cabal install diffraction-gratings
13:52:11 <josephle> eacameron: I personally like those shift-tilt-lens :)
13:52:18 <hyPiRion> oh, while we're at lenses: Is there any example on how you define a lens without makeLens? I've been unable to find any.
13:52:40 <hyPiRion> Perhaps I should read how _1 and friend is implemented
13:52:46 <stalintrotsky> could you define it in terms of other lenses? I've never used lens
13:53:16 <orion> My application is experencing a memory leak. I profiled it and got this result: http://i.imgur.com/9vCsdZF.png does anyone know what could be going on? (http://ideone.com/BEbeSi)
13:53:19 <joneshf-laptop> hyPiRion, you can use `lens`
13:53:21 <joneshf-laptop> :t lens
13:53:22 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
13:53:30 <shachaf> But you shouldn't if you can help it.
13:53:31 <joneshf-laptop> give it a getter and a setter and you get back a lens
13:53:37 * hackagebot hactor 1.0.0.0 - Lightweight Erlang-style actors for Haskell.  http://hackage.haskell.org/package/hactor-1.0.0.0 (Forkk)
13:53:47 <hyPiRion> joneshf-laptop: alright, thanks
13:53:48 <shachaf> lens is less efficient and more complicated than just writing out the lens directly.
13:53:52 <spopejoy> is TH the ‘recommended’ way to use lens?
13:54:33 <shachaf> TH works fine for some ("structural") lenses.
13:54:33 <hyPiRion> schell: what do you mean by "writing out the lens directly"?
13:54:45 <hyPiRion> whoops, shachaf I meant.
13:54:57 <shachaf> _2 f (x,y) = (,) x <$> f y
13:55:03 <spopejoy> i’d like to avoid using TH, wondering the easy way to lens-ify a record
13:55:09 <glguy> hyPiRion: https://gist.github.com/glguy/74960a3f1531b64a201b
13:55:16 <schell> hyPiRion: no worries - happens about once every two months or so ;)
13:55:37 <shachaf> Without TH you would write the lenses by hand.
13:55:54 <Cale> spopejoy: I'd tend to use TH, because writing lenses by hand is boring
13:56:19 <schell> Cale, shachaf: what would be nice is if your editor could write the lenses for you
13:56:38 <Trollinator> how is that better than TH?
13:56:39 <Cale> Er, that's the worst of both worlds?
13:56:42 <glguy> Why bake boilerplate into your source file?
13:56:43 <shachaf> You probably don't pay them enough to do that.
13:56:56 <k00mi> why should writing code be the job of the editor?
13:56:58 <spopejoy> ok, data Foo = Foo { bar :: String, baz :: Int }. How do you lens it?
13:57:12 <glguy> spopejoy: https://gist.github.com/glguy/74960a3f1531b64a201b
13:57:28 <schell> i’d like that better - i’d rather have a snippet do the work of writing the lens and also not have to make TH a dependecy of my project
13:57:31 <Cale> It's automated, so you don't control what you end up with, but it's baked into the source so that changes to the type might break the code...
13:57:57 <spopejoy> schell: agree. I have an aversion to TH for some reason
13:57:58 <schell> it’s the best of both worlds from my perspective
13:58:09 <Cale> I tend to hate editor features which involve generating code and writing it into the source file
13:58:11 <Trollinator> so depending on an editor feature is OK, but depending on a feature of the compiler that you're probably going to use anyway is not?
13:58:30 <schell> Cale: i’m guessing you don’t use snippets much?
13:58:33 <Cale> Those kinds of features only exist to make up for bad language or library design.
13:58:40 <corgifex> I just have my editor generate object code
13:58:49 <corgifex> so my packages don't have to depend on a compiler
13:58:49 <glguy> Ooh, and the editor could compile code for me so I don't need an actual compiler !
13:58:57 <schell> Trollinator: i think the problem is that with TH it’s not always portable
13:59:13 <glguy> just inline asm files
13:59:16 <schell> at least with the editor solution you can compile it on…iOS, Android, etc
13:59:47 <spopejoy> there’s something wrong with TH that I can’t put my finger on. Meanwhile that lens code is kind of horrid
13:59:49 <Cale> glguy: pff, I just use a hex editor with macros that expand out the machine code in place. You don't even need an assembler anymore!
13:59:53 <schell> though i think in the newest GHC TH is supported for ARM
14:00:19 <hyPiRion> glguy: thanks btw
14:00:26 <Cale> schell: Yeah, the right solution in the long run is just to get TH support working on those platforms.
14:00:30 <glguy> hyPiRion: quite welcome!
14:00:31 <spopejoy> although i’m surprised, is ‘lens’ really a pattern? don’t see the word “lens” anywhere in glguy’s code
14:00:36 <schell> one way or another they’re just preferences and to each their own
14:00:51 <spopejoy> ie setter functors?
14:01:05 <glguy> spopejoy: There is some bolded text "Lens" in there
14:01:51 <schell> oh, my other gripe with lens+TH - my records are required to have “_” prefixes
14:02:02 <glguy> schell: That's configurable, the _ is the default
14:02:05 <Cale> schell: Not *required*, you can give a different mapping
14:02:07 <Trollinator> it's *not* just a preference. TH provides clear advantages such as not having generated boilerplate clutter your code, and you don't have to run your editor “snippet“ again when the record changes.
14:02:17 <schell> i was hoping you guys would tell me that!
14:02:36 <schell> Trollinator: that’s a good point
14:03:04 <JohnTalent> edwardk: are you making a program or not?
14:03:05 <spopejoy> yes that’s great. I hate “_” pfxs <shudder>C++ nightmares</shudder>
14:03:15 <Peaker> TH needs to be done via a build step that generates cached files that need not be recompiled if the inputs to the TH process did not change
14:03:21 <Peaker> TH build times are atrocious :(
14:03:26 <schell> one more - in order to use lens+TH you have to depend on the entire lens library - what if all i want are getters and setters?
14:03:28 <edwardk> JohnTalent: ? i write lots of programs. which one in particular are you referring to?
14:03:38 <spopejoy> TH reminds me of templates, in the “big build” area
14:03:38 * hackagebot hactor 1.0.0.1 - Lightweight Erlang-style actors for Haskell.  http://hackage.haskell.org/package/hactor-1.0.0.1 (Forkk)
14:03:40 <Peaker> I've reverted to writing all my lenses/prisms by hand to avoid the TH build times
14:04:08 <edwardk> Peaker: fair. The TH startup/build time makes me sad.
14:05:02 <Cale> Yeah, it *would* be nice for various reasons to have an easier time extracting the unfolded TH code as an intermediate file
14:05:34 <Cale> For one, while debugging TH code.
14:05:45 <edwardk> schell: lenses and traversals can be written with just Prelue. getters + folds can be written with just a dependency on 'contravariant'. to get prisms and isos you need 'profunctors'. but you can bring in lens if you want a whole suite of combinators for working with them
14:05:48 <glguy> I'm imaging you already know about -ddump-splices, Cale
14:05:49 <edwardk> er Prelude
14:05:50 <spopejoy> Wouldn’t there be some way to autogenerate lenses using Typeable or something? At least some boilerplate “lens1”,”lens2” for 1 arg, two arg etc that somehow use Typeable or Dynamic to spit out the impl.
14:06:02 <Cale> glguy: yeah
14:06:23 <edwardk> spopejoy: we have a traversal that is generated by Typeable in lens
14:06:33 <edwardk> :t Data.Data.Lens.biplate
14:06:34 <lambdabot> (Applicative f, Typeable a, Data s) => (a -> f a) -> s -> f s
14:06:36 <Cale> With just Typeable?
14:06:40 <glguy> If your goal is to use GHC.Generics, you can make lenses like this: http://lpaste.net/107186
14:06:40 <Cale> I would expect Data, yeah
14:06:48 <Cale> and seemingly you do require it :)
14:07:01 <edwardk> i meant Typeable off the target
14:07:02 <edwardk> but yeah
14:07:14 <edwardk> and i was using the words he asked with =)
14:07:23 <spopejoy> glguy: that seems nicer. drawbacks?
14:07:42 <edwardk> spopejoy: they are much slower
14:07:45 <glguy> spopejoy: resulting code is worse, the TH code is exaactly the code you want, it can't do type changing
14:07:51 <spopejoy> oof
14:07:53 <schell> edwardk: ah thanks - i’ll have to write some by hand soon to understand
14:07:55 <bts-> Any emacs users know why I might get "cabal: Cannot find the program 'ghc' at 'ghci-ng' or on the path" when using haskell-process-type 'cabal-repl instead of 'ghci? 'ghci doesn't load cabal deps for me, so I am trying to switch to 'cabal-repl
14:07:59 <glguy> spopejoy: I did it to prove that you can , not to use it
14:08:08 <spopejoy> glguy: :)
14:08:10 <napping> schell: for fields you could use field update too
14:08:43 <schell> napping: is field update just thing{ thingsField = newValue} ?
14:08:51 <merijn> schell: Yup
14:08:57 <spopejoy> codegen’s starting to look pretty good. i resisted it in java for decades, but my life improved once I drank the koolaid
14:09:07 <Sonarpulse> I've been trying to rewrite/continue https://hackage.haskell.org/package/disassembler at https://github.com/cnc-patch/disass/tree/master
14:09:12 <merijn> schell: That'll return a copy of "thing" with the thingsField replaced
14:09:18 <schell> yar, thank you
14:09:24 <spopejoy> any good tools for haskell codegen?
14:10:06 <Sonarpulse> I want to rewrite make a "conservative" dissasembler that only disassembers from addresses given to it by user, or discovered from jumps
14:10:39 <vanila> Sonarpulse, neat idea :)
14:10:43 <Sonarpulse> I'd like to make it on some abstract interface that allows reading and seeking. Anybody have a typeclass to recoomend?
14:10:46 <Sonarpulse> thanks vanila
14:11:11 <vanila> you could maybe use a zipper
14:11:34 <vanila> it's basically just a list with a hole in the middle, that would let you replace pieces of raw binary into opcodes
14:12:13 <Sonarpulse> well i mean typeclass, that just has read and seek, so I can give it a big array, a file, or a zipper
14:14:34 <merijn> Sonarpulse: I don't think such a typeclass makes a lot of sense?
14:15:51 <teakay> hey guys. I have a persistent/esqueleto related question
14:16:37 <Sonarpulse> I supposed i could use one of the many stream frameworks
14:16:48 <Sonarpulse> and seek would essentially be "get new stream"
14:18:51 <eacameron> I want to use a function that uses MonadBaseControl IO m but my monad is not an instance and I really don't feel like figuring out how to make it one...any workarounds?
14:19:03 <tunnels> I'm new to haskell, and I'm trying to resolve cabal dependencies
14:19:03 <eacameron> I'm pretty new to hs and I'm getting sucked into the depths too fast!
14:19:15 <tunnels> lpaste.net/109259
14:19:40 <tunnels> anyone able to point me in the right direction to get past these rejections ^^
14:19:58 <johnw> eacameron: I copy&paste those
14:20:03 <johnw> eacameron: want a template to use?
14:20:31 <eacameron> johnw: sure; except that apparently StM requires * kind and I'm using * -> *...
14:20:40 <eacameron> ugg
14:20:49 <JohnTalent> edwardk: when I ask you if your writing a program I mean is there a thought of a program or are you just programming for the sake of space?
14:21:14 <teakay> I have a view (V), and since persistent has no notion of views I have defined it as a regular table, in persistent. So now the primary key's type is of that table, though the view has a 0:1 relation with another table (T). and id like to join the view onto a table (T2)  which has a reference to T's primary key
14:21:15 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
14:21:59 <teakay> so the types dont work out. anyone know if theres any way to do it?  I know i can use rawSQL, but can't for another reason
14:22:02 <johnw> eacameron: https://gist.github.com/3bfaaf569b9f59d83ce1
14:22:36 <johnw> so the point of MonadBaseControl is to (1) encapsulate the state of a monad into a variable; and (2) take such a variable and restore it as the state of another action in that monad
14:22:43 <edwardk> JohnTalent: my approach to programming is that i'm always nominally working towards some goal. and along the way i find a bunch of sub problems, and those have sub problems. eventually i find a yak somewhere in tibet that i'm uniquely suited to shave, and i go to town, and set up that yak with laser hair removal to the point where it never needs be shaved again, and then i pop the stack. some times i get back to my original
14:22:44 <edwardk>  problem, but next time i'm working on a problem, and i need a shaved yak? I've got that part down.
14:22:51 <eacameron> johnw: thanks!
14:23:00 <johnw> eacameron: here's some docs I wrote that you might find useful: https://gist.github.com/f3d2e88be013689b5d6a
14:23:14 <eacameron> johnw: and it blows my mind that I just realized who you are. I'm just now starting to use ledger, but very new ;)
14:23:27 <johnw> great!
14:23:41 <edwardk> JohnTalent: so when i try to solve something i have an abstract need, but then try to solve the sub problem at most vaguely motivated by my initial need, and just try to let the solution i write be the best solution to the class of problems it is in
14:23:54 <JohnTalent> edwardk: interesting. i have a different approach, end user need. otherwise I just dick around with language facets not previously known.
14:24:14 <johnw> oh, appears I put that up as a blog article: http://www.newartisans.com/2013/09/using-monad-control-with-monad-transformers/
14:24:14 <Trollinator> perhaps you should try breadth-first search.
14:24:20 <timmy_tofu> tunnels: The dependency bounds in your output are alarmingly narrow. Are you using cabal sandboxes?
14:24:52 <edwardk> Trollinator: breadth first is inefficient. i use iterative deepening depth first search really.
14:25:06 <JohnTalent> edwardk: your way is probably better
14:25:18 <edwardk> which given a wide enough fan out converges to the same asymptotics, but requires me to remember fewer things as i go
14:25:47 <JohnTalent> edwardk: what happens when your boss asks you to write a program?
14:25:55 <edwardk> JohnTalent: end users always have needs. ;) i get a fair chunk of that having written the library and picked up users.
14:26:39 <tunnels> timmy_tofu: I don't know.
14:26:41 <tunnels> I didn't write the code, I just did an 'apt-get install cabal-install', then I'm trying to follow the installation instructions
14:27:03 <edwardk> JohnTalent: then i do what i have to do. but i try very hard to avoid getting stuck in a situation where i must solve exactly this one problem or use exactly this one solution. Do you know who Feynman was?
14:27:15 <Trollinator> edwardk: http://xkcd.com/761/
14:27:31 <JohnTalent> edwardk: a physicist iirc.
14:28:09 <haasn> the physicist
14:28:17 <Trollinator> so I still think breadth-first search has its advantages.
14:28:17 <glguy> Trollinator: that's where iterative deepening comes in!
14:28:41 <Trollinator> take it with a grain of salt.
14:28:54 <edwardk> JohnTalent: anyways, he had a schpiel he used to give about how to be a genius. he said 'hold a dozen problems in your head, and when someone shows you a new trick, tip or solution, go home and try it out against all of your problems' if it hits, when you come in in the morning and explain it? they'll go how did he make that connection!? he must be a genius!
14:29:00 <johnw> Trollinator: awesome
14:29:37 <edwardk> JohnTalent: now, as a good little category theorist i like to look at the world through the eyes of duality. given any statement i should be able to turn it around and talk about the opposite approach. here, instead of holding a dozen problems, what if you hold a dozen solutions?
14:30:01 <edwardk> JohnTalent: well, if you do, and someone shows you a new problem, and you find a hit among your solutions, then you are.. well, more or less a consultant.
14:30:19 <corgifex> what if I hold a dozen hammers
14:30:34 <glguy> You'd get stronger
14:30:35 <haasn> Does duality give you a dozen nails?
14:30:38 <corgifex> and any problem looks like a thumb
14:30:39 <haasn> This category thing really seems useful
14:30:47 <stalintrotsky> I tried making a catch for StateT s IO, and it compiles, will this work? http://pastebin.com/88JwdcT8
14:30:54 <stalintrotsky> and could it be more idiomatic
14:30:55 <Trollinator> it still looks like abstract nonsense to me.
14:30:57 <edwardk> JohnTalent: but as someone who likes AI, the next observation is you shouldn't ever search from one end of a problem space or the other, but instead try to meet in the middle. so if you instead of holding a dozen problems or dozen solutions hold a half dozen of each you can optimize for throughput
14:31:01 <JohnTalent> edwardk: okay so your a bottom up guy.
14:31:09 <edwardk> not exactly
14:31:19 <edwardk> i don't believe in either top down entirely or bottom up entirely
14:31:35 <edwardk> i believe in searching motivated by a problem through my stack of solutions, and searching motivated by a solution through a stack of problems
14:31:42 <corgifex> stalintrotsky: yes, if you're fine with exceptions losing your current state
14:31:43 <edwardk> and trying to meet in the middle
14:31:43 <tunnels> timmy_tofu: so I should look into how to modify the dependency bounds?
14:31:48 <corgifex> stalintrotsky: and it doesn't look thread safe
14:31:58 <edwardk> because if you are stuck working on one problem you've nailed down one end of the search space
14:31:59 <johnw> an exceptino could happen after the call to catch
14:32:12 <stalintrotsky> wouldn't I keep the state since I'm binding the new state from the ones in catch to s?
14:32:16 <edwardk> if you are stuck that you must find uses for a given solution you've nailed down the other
14:32:17 <haasn> fixating yourself on bottom up or top down seems like fixating yourself on one language or another
14:32:22 <haasn> No reason we can't use the right tool for the situation
14:32:25 <edwardk> and both of these states are inefficient search modes
14:32:37 <johnw> stalintrotsky: think about async exceptions after liftIO $ catch has been executed
14:32:49 <corgifex> no, don't think about async exceptions yet
14:32:52 <johnw> you could put, but then another exception would just throw away the effect of the put
14:32:58 <edwardk> so i try to optimize for the total amount of problems i solve and try to find places that value that I can do this
14:33:02 <JohnTalent> Thats the thing with AI. If you approach it from the middle you see what a detraction to society it is. if you're a programmer , you're out of a job and the internet becomes a ai generated crapfest.
14:33:02 <johnw> always think about async exceptions
14:33:34 <benmachine> JohnTalent: well, perhaps we're due a change in what kind of crapfest it is
14:33:36 <corgifex> stalintrotsky: consider do { put 42; throw "whatever" }
14:33:39 <edwardk> As a friend of mine likes to say that the moment we know how to do a thing we cease to call it AI and give it another name. ;)
14:33:42 <corgifex> stalintrotsky: that put 42 will be lost
14:34:00 <JohnTalent> edwardk: i like your style btw.
14:34:07 <edwardk> its machine learning, data science, data mining, cognitive science, computational linguistics...
14:35:51 <Lambdanaut> I/d say that all computational processes exhibit aspects of intelligence, and that once we understand a certain process, we can then give it further labels to give us more understanding of the category it belongs in.
14:35:58 <Lambdanaut> But it's still AI, regardless.
14:36:55 <Lambdanaut> I think it's more useful to put it all in the same basket and say that a computer executing "1+1" is AI, but just a simple form, and it's also in the "automated arithmetic" category.
14:37:05 <edwardk> JohnTalent: anyways, that sort of motivates why i work the way i do and it happens to work out really really well in haskell. parametricity collapses the search space just enough that the general solution is usually the only solution, typeclasses make it easy to refactor the design over and over and keep it working so you can get out of local ruts where you are often stuck with the first design you picked in other languages, i
14:37:06 <edwardk>  find that parametricity gives me a path to code reuse that doesn't just entail 'flogging the developer because they failed to perfectly guess the right level of generality' and passing out doggie treats when they get it right.
14:37:31 <johnw> wait, how did i miss out on the doggie treats?
14:37:44 <edwardk> johnw: sorry. stole them when you weren't looking
14:37:58 <johnw> you only have cats anyway, so I'm suspicious
14:38:03 <Lambdanaut> edwardk: What do you mean by "parametricity"?
14:38:14 <JohnTalent> benmachine: all ai generation is crapfest. i hold no adherence towards heuristics regurgitating language. AI will always be 'Ruthless' as quoted by 13th Chess Champion. Garry Kasparov. With 1 bit change Star Wars is a snuff film about a golden robot on a human death rampage.
14:38:27 <edwardk> Lambdanaut: http://en.wikipedia.org/wiki/Parametric_polymorphism
14:40:01 <Lambdanaut> oh haha. So that's what that thing I always do is called
14:40:50 <edwardk> JohnTalent: frankly i'm more afraid of the fear mongers than the AI. =P
14:41:25 <edwardk> but this drifts seriously into #haskell-blah territory
14:41:51 <JohnTalent> edwardk: Takes imagination to see where your karma goes , what is does, and what it comes back with.
14:42:33 <ion> I’m using both unsafePerformIO and unsafeInterleaveIO for the first time. I’m scared.
14:42:35 <JohnTalent> Personality can only be programming but falsely because the cold iron is ruthless. given current technology.
14:42:55 <JohnTalent> xor or not xor that is the question.
14:43:00 <spopejoy> re lens, am I correct to say the core of field optics is gaining the ability to fmap on fields?
14:43:03 <napping> schlumpi: if you're wanting to write a lens for a field yourself, you can use record update to make it smaller.
14:43:12 <JohnTalent> edwardk: right.
14:43:16 <JohnTalent> sorry guys.
14:43:18 <napping> schell, rather
14:43:54 <schell> napping: smaller?
14:44:32 <schell> i’m familiar with records, and pretty familiar with using lenses, i just haven’t written a lens by hand
14:44:58 <schell> but what do you mean by making it smaller?
14:45:13 <edwardk> spopejoy: frankly fmap is kind of a boring application of the lens machinery. the optic stuff is about being able to get in and manipulate formally some part or case of a whole.
14:45:43 <edwardk> spopejoy: with suitable generalizations of the concept you can do a lot with the ideas behind lenses, e.g. we have code in hask for playing with lenses into arbitrary monad transformer stacks that can reshuffle the stack
14:46:19 <spopejoy> edwardk: my question/assertion was more what is the underlying mechanism that makes all this possible
14:46:40 <spopejoy> ie, is independent fmap on fields the underlying requirement for lens magic
14:47:09 <flebron> Hey, what was that way to ensure no cabal conflicts? I tried removing .ghc and .cabal and I still get "forced reinstalls" when installing Criterion.
14:47:11 <edwardk> spopejoy: lens uses a weird encoding of a simple shape and a couple laws to enable users to reason about them
14:47:19 <edwardk> spopejoy: thats it. no magic
14:47:48 <vanila> what is this shape?
14:47:53 <edwardk> _2 f (a,b) = (,) a <$> f b --- is a lens into the second half of a tuple that is capable of type changing assignment, viewing it, etc.
14:48:04 <spopejoy> by “magic” i meant “neato functionality in a concise package”
14:48:23 <spopejoy> “sufficiently advanced technology is indistinguishable from magic”
14:48:26 <napping> schell: like myLens f rec = (\field -> rec {field = field}) <$> f (field rec) or so
14:48:47 <edwardk> vanila: type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t   is a weird way to encode (s -> a, s -> b -> t) -- which is the paired getter/setter in such a way that if you squint at it you realize it can be composed with (.)
14:49:22 <edwardk> but it gets the benefit that s -> (a, b -> t) does, which is you can 'share the work' of pattern matching on s across the getter and setter when you want to work under it
14:50:04 <edwardk> when you pick the choice of Functor f you are choosing what you want to do. for Identity you are updating, for Const you are reading, for Store you are recovering the more direct getter/setter pair, etc.
14:50:21 <edwardk> the key about the lens encoding is that it composes with things that aren't lenses just as well
14:50:28 <vanila> wow, that is really elegant!
14:50:28 <edwardk> and there are generalizations of this shape
14:50:30 <edwardk> :t traverse
14:50:31 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
14:50:38 <edwardk> that also looks the same
14:50:42 <edwardk> :t traverse.traverse
14:50:43 <lambdabot> (Traversable t1, Traversable t, Applicative f) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
14:50:47 <edwardk> as does that
14:50:54 <edwardk> :t both.traverse.traverse.both
14:50:55 <lambdabot> (Data.Bitraversable.Bitraversable r1, Data.Bitraversable.Bitraversable r, Traversable t1, Traversable t, Applicative f) => (a -> f b) -> r (t (t1 (r1 a a))) (t (t1 (r1 a a))) -> f (r (t (t1 (r1 b b))) (t (t1 (r1 b b))))
14:51:03 <glguy> and... shark jumped
14:51:08 <edwardk> hahha
14:51:23 <vanila> that's awesome I'm going to play around with this a bit
14:51:26 <edwardk> the point was more that you can compose simple pieces and get non-trivial results
14:52:01 <edwardk> vanila: that coq treatment of category theory we've been talking about will let us borrow some of this vocabulary eventually there
14:52:08 <edwardk> @hackage lens
14:52:09 <lambdabot> http://hackage.haskell.org/package/lens
14:52:24 <napping> schell: using NamedFieldPuns you could even write
14:52:33 <napping> let myLens f r@Foo{field} = (\field -> r{field}) <$> f field
14:52:35 <edwardk> ^- there is the library in question, its a bit large, if you get lost don't hesitate to ask here or for more in depth off topicy stuff #haskell-lens is a good resource
14:52:51 <edwardk> napping: yeah but then -Wall goes ballistic ;)
14:53:18 <napping> that's unforunate
14:53:37 <napping> you'd think NamedFieldPuns would tell the compiler to expect field names to be shadowed here and there ;)
14:53:42 * hackagebot Spock 0.6.2.3 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.2.3 (AlexanderThiemann)
14:53:56 <codile> this looks cool http://danielvelkov.blogspot.de/2014/08/easy-haskell-profiling.html
14:55:34 <spopejoy> what do you lose/gain by just using lens-family-core?
14:56:08 <edwardk> spopejoy: indexed lenses, prisms, isos, most of the combinators, support for a ton of libraries out of the box, sanity
14:57:27 <Peaker> oh how I love sequenceAOf :-)
14:57:33 <flebron> How do I unregister all packages with ghc-pjg?
14:57:34 <flebron> *pkg
14:57:49 <edwardk> spopejoy: i wrote lens as a reaction to lens-family / lens-family-core. your mileage may vary
14:58:02 <luite> flebron: you could just remove the database in ~/.ghc, which is what i usually do
14:58:04 <Peaker> Many lens functions save boilerplate,  sequenceAOf saves me from thinking quite a bit :-)
14:58:10 <edwardk> hah
14:58:22 <Peaker> I can transform the type without even understanding what I'm doing! :-)
14:58:24 <flebron> luite: I do that, and then update, and then cabal install criterion, and it tells me a bunch of conflicts happen :s
14:59:20 <edwardk> for why Peaker is poking fun: sequenceAOf l = l id
14:59:30 <edwardk> :t both id
14:59:31 <lambdabot> (Data.Bitraversable.Bitraversable r, Applicative f) => r (f b) (f b) -> f (r b b)
14:59:36 <edwardk> oh we generalized both
14:59:41 <corgifex> haha
14:59:43 <edwardk> what is a good traversal to demonstrate on now? =)
14:59:57 <edwardk> @let both' f (a,b) = (,) <$> f a <*> f b
14:59:59 <lambdabot>  Defined.
15:00:09 <edwardk> :t sequenceAOf both'
15:00:10 <lambdabot> Applicative f => (f b, f b) -> f (b, b)
15:00:17 <edwardk> :t both' id
15:00:18 <lambdabot> Applicative f => (f a, f a) -> f (a, a)
15:00:43 <luite> flebron: hmm, that might happen, run ghc-pkg check first to see if everything is ok. you could try installing in a sandbox, but that should not be different from installing just after clearing the user db
15:01:57 <corgifex> http://www.youtube.com/watch?v=gz9P43sIJaI
15:05:48 <luite> is there a good way to help cabal-install a bit when something only installs with --max-backjumps=-1 --reorder-goals and takes a very long time finding an install plan even with that?
15:06:08 <luite> by adjusting the cabal file of the problematic package
15:14:02 <augur> corgifex: whoa hello whats up
15:14:13 <prophile> so monadacme is just the identity monad
15:14:16 <prophile> with one exception
15:14:32 <prophile> fail = return . unsafeCoerce
15:14:39 <prophile> I think I have a new favourite definition for fail
15:14:41 <augur> corgifex: i dont do applied comp ling :x
15:14:59 <corgifex> I don't do any kind of linguistics!
15:15:22 <hpc> prophile: wow, that breaks the crap out of do-notation
15:15:46 <prophile> unless you happen to be dealing with strings
15:15:47 <hpc> suddenly, do {Just x <- return Nothing; return x}
15:15:52 <napping> luite: I imagine giving exact versions of various things would help
15:16:06 <napping> That's probably a bit more aggressive than you really want
15:16:09 <ij> Should I care about what Applicative actually is or just how it works to do things for me?
15:16:20 <johnw> ij: the latter should be fine
15:16:26 <trap_exit> what's the state of GPGPU on haskell ?
15:16:34 <napping> I'm not sure how much of a "what Applicative actually is" there actually is
15:16:45 <hpc> napping: exactly as much as for Monad
15:16:46 <hpc> (none)
15:16:48 <johnw> napping: don't say that in front of edwardk
15:16:51 <prophile> it's a generalisation of the SKI combinator calculus obviously
15:17:08 <napping> oh, that is nice
15:17:22 <hpc> typed SKI, really
15:17:25 <hpc> or something
15:17:26 <luite> napping: might break more installed packages too, so then it might prevent it from finding an acceptable plan (without --force-reinstalls)
15:17:39 <hpc> you can't go writing fix with just Applicative afaik
15:17:43 <napping> I finally understood how to use some funny propositional logic axiom systems when I realized they were basically S/K/I
15:18:02 <napping> luite: I mean if you end up with some working plan, you could hardcode some of the working versions it found
15:18:11 <napping> You probably want some other things?
15:18:22 <napping> But freezing versions makes sense if you just want a binary or something
15:18:30 <napping> perhaps it's time for cabal to look into a proper SAT solver?
15:19:05 <napping> maybe it already is, if the option name mentions "backjumps"
15:19:14 <edwardk> An applicative is just a monoid of Day convolution. done. easy peasy. now we know what it is we can all use it right?
15:19:17 <luite> napping: but that might break on other systems if that requires reinstalls
15:20:31 <napping> luite: well, yes. I only know to suggest that you give things tighter constraints, so there's less search space for the solver to rule out
15:20:41 <hodapp> hmmm, could you maybe explain Applicative with a burrito analogy?
15:22:07 <haasn> I wonder if shachaf loves applicative
15:22:36 <shachaf> haasn: Constantly.
15:22:42 <edwardk> hodapp: its a line of burritos but once you start eating it you can't moderate your behavior based on what you saw inside the last burrito. it's burritos from the time yous tart til the time you end.
15:23:05 <napping> luite: what package is it?
15:23:18 <napping> do you know if there's any way to get Cabal to dump the constraints it's trying to solve?
15:24:06 <sm> -v3
15:24:21 <edwardk> napping: get it to dump core and wade through the wreckage? ;)
15:24:55 <napping> Preferrably something that would let me try a standard SAT solver with minimal effort :)
15:24:59 <luite> napping: ghcjs
15:26:13 <luite> napping: it has quite a few eps, and transformers seems to be causing some problems in particular, since ghc ships with (and depends on) 0.3.0.0, but often people have things with a newer transformers installed already
15:26:53 <napping> luite: huh, with the current ghcjs.cabal from https://raw.githubusercontent.com/ghcjs/ghcjs/master/ghcjs.cabal it just plain fails
15:27:13 <luite> napping: what does it say?
15:27:18 <mmmm> I've got into the habit of using <=< and =<< rather than >=> and >>= is this idiotmatic?
15:27:24 <luite> napping: max-backjumps=-1 ?
15:27:28 <napping> oh, it doesn't know about haddock-internal, I guess that's not on Hackage either
15:27:51 <luite> napping: oh ghc-prim and haddock-internal are on github, same organization
15:27:56 <luite> i mean ghcjs-prim, sorry
15:28:16 <merijn> mmmm: I use whichever looks best in the surrounding code
15:28:34 <codile> Haskell, you got to be kidding me...
15:29:07 <codile> lol. meoblast001?
15:29:22 <meoblast001> what about me?
15:29:27 <napping> huh, it found a solution in a clean sandbox just about instantly as far as I can tell
15:29:30 <codile> you code haskell?
15:29:34 <meoblast001> i'm learning
15:29:39 <codile> ah, cool ^^
15:29:47 <meoblast001> wait. where do i know you?
15:29:55 <codile> #theradiocc
15:29:57 <codile> duh
15:30:01 <meoblast001> ooooh!
15:30:10 <meoblast001> codehero
15:30:16 <codile> yupp
15:30:17 <meoblast001> now it all makes sense
15:30:18 <codile> dat me
15:30:26 <meoblast001> das du
15:30:41 <napping> luite: what are you doing differently?
15:30:52 <napping> even -v3 isn't printing the full constraint problem
15:32:30 <mmmm> merijn: My reasoning is that f . g is the same order as f <=< g
15:32:43 <vanila> col, I tried out that lens thing and it works - really neat
15:32:47 <luite> napping: it still fails even if you include those packages?
15:33:28 <napping> luite: Oh, you're trying to build ghcjs
15:33:37 <vanila> http://lpaste.net/109264 what comes after this?
15:33:41 <napping> I thought you meant you were actually trying to build ghcjs-prim
15:33:50 <napping> that's what built fine for me, at least in a fresh sandbox
15:34:00 <orion> Anyone ever do anything with Haskell on AWS?
15:34:08 <luite> napping: oh, yeah ghcjs fails, haddock-internal and ghcjs-prim are usually ok
15:34:27 <hpc> @quote cost.me
15:34:27 <lambdabot> SimonMarlow says: This is the largest program (in terms of memory requirements) I've ever seen anyone run using GHC.  In fact there was no machine in our building capable of running it, I had to fire up the largest Amazon EC2 instance available (68GB) to debug it - this bug cost me $26.
15:34:51 <hpc> orion: ^^
15:34:56 <luite> hehe
15:34:57 <orion> hah
15:35:00 <napping> luite: well, I have to go for a bit. This is all in a fresh sandbox?
15:35:49 <luite> napping: i think sandboxes are less problematic in most cases
15:35:53 <napping> If so, I can try on my own later
15:36:16 <napping> I mean, is it just those three .cabal files plus hackage, or is it slow give some other installed stuff?
15:36:34 <hpc> orion: looking for specific help or just precedent?
15:36:50 <luite> napping: yeah installed stuff seems to be problematic, and i don't want to force users to use a sandbox
15:36:58 <danilo2> Hello! Does anybody know if is it possible to disable colered output in trifecta? I want disable it basing on some env conditions
15:37:20 <napping> I guess I'll just see if I can reproduce it in a sandbox then
15:38:03 <hpc> danilo2: if there's not one built in, you can adapt this: http://www.commandlinefu.com/commands/view/3584/remove-color-codes-special-characters-with-sed
15:38:53 <danilo2> hpc: ugh that is ugly and works only on Unix
15:40:51 <hpc> danilo2: well, adapt it into a string manipulation
15:41:04 <hpc> color codes are just magic characters in the text
15:41:38 <orion> hpc: Specific help.
15:42:25 <hpc> orion: first you must make the ritual IRC sacrifice by asking if you can ask a question, then waiting for us to tease you a bit
15:42:33 <hpc> then you ask your question and wait for someone to answer ;)
15:42:46 <orion> hpc: I am distracted.
15:42:51 <orion> That's why I haven't asked the question yet.
15:42:54 <hpc> ah, np
15:42:58 <orion> I like to formulate godo questions. :)
15:43:25 <danilo2> hpc: hmm, on unix yes, the colors are just special characters, but on windows they are windows api calls
15:43:50 <edwardk> danilo2: put in a request through github.com/ekmett/trifecta/issues i'm open to it, and am actively working on trifecta right now
15:44:51 <orion> hpc: http://ideone.com/J9JYQN -- I want to execute this program ~30 times concurrently on a c3.8xlarge EC2 instance.
15:45:05 <orion> But I don't want to waste time/money uploading and compiling the application.
15:45:31 <orion> I want to make my own AMI with Haskell Platform, and my program compiled and ready to go.
15:46:17 <merijn> orion: You wouldn't even need the platform for that, no?
15:46:25 <merijn> Just compile your binary and put it in the AMI?
15:46:30 <danilo2> edwardk: Ok :) Btw - are there any "traps" in current trifecta implementation? I've got a pretty big parser in parsec and I want to convert it to trifecta - Should I be aware of something, or should I be albe to just convert it without bigger problems?
15:46:38 <orion> merijn: Oh yes! Good point.
15:46:44 <hpc> oh, you asked the permute question the other day
15:46:59 <orion> hpc: Yeah, I had problems with memory usage.
15:47:02 <merijn> orion: GHC links anything except the C libraries statically anyway, so just make sure you've got the right C libraries installed
15:48:28 <orion> I profiled my heap and found the culprit to be "ghc-prim:GHC.Types."
15:48:30 <danilo2> edwardk: https://github.com/ekmett/trifecta/issues/36 :)
15:48:42 <orion> Of course, I have no idea what that is.
15:49:08 <edwardk> danilo2: my usual recommendation is to port the parser to 'parsers', then you can keep using it with trifecta and/or with parsec or with attoparsec or ReadP or...
15:49:36 <edwardk> danilo2: parsers provides the parser combinators in a parser library neutral fashion
15:49:46 <edwardk> danilo2: trifecta just supplies an instance
15:50:28 <danilo2> edwardk: hmm, that could be a great idea. I understand that "parsers" has not any performance overhead ? And I understand also (out of curious) it is incompatible with uu-parsinglib?
15:51:06 <edwardk> someone is welcome to try to write a uu-parsinglib backend for parsers, but i hesitate to include it in the main lib. its really oriented around 'try'-oriented parsers
15:51:39 <edwardk> so there may be some infelicities when used with parsers that always backtrack, but then really only do so only some times, like uu-parsinglib
15:51:48 <edwardk> so i have no idea if the semantics line up enough to be useful there
15:52:14 <edwardk> as for performance overhead? relative to parsec it should be negligible. for attoparsec it can be somewhat high
15:52:25 <danilo2> edwardk: I was asking exactly about it. I do not think it would be a good idea though. uu-parsinglib is completely different story than try based parser combinators. Anyway thank you for the help - I'm trying now with parsers :)
15:54:54 <danilo2> edwardk: Hmm I was asking about performance overhead between using "parsers" with trifecta or parsec vs trifecta/parsec directly. I was sure the answer would be that there is no overhead, but you've told there is not negligible one with attoparsec - would you be so nice and tell few words why?
15:55:26 <edwardk> trifecta doesn't have a 'directly'. all the combinators are supplied through parsers
15:56:15 <edwardk> attoparsec implements a lot of its own stuff using every dirty trick that bos can muster, parsers basically builds most of its stuff over a fairly simple core of combinators but it can't use that suite of tricks that depend on the guts of his implementation
15:56:47 <edwardk> so going through the parsers version of some combinators may have a proportionally high overhead for attoparsec, because his base primitives are _so_ optimized.
15:57:17 <edwardk> for parsec the impedence mismatch is less, the combinators exported by parsers do mostly what the ones in parsec do directly
15:58:58 <danilo2> edwardk: ok, thank you, it makes sense with attoparsec. But why there is **any** overhead with parsec? When I was looking at it implementation and its combinators, they were defined like the ones in parsers library. Where such slowdown could came from ?
16:00:06 <edwardk> there are a few places where the parsers ones try to go through the Applicative combinators rather than the Monad combinators, this can lead to a few percent variance here and there trading generality for a bit of speed and vice versa
16:00:22 <edwardk> but also there is a class now that you're hoping GHC sees fit to inline appropriately
16:00:31 <edwardk> so it can lose a little bit there
16:00:55 <edwardk> i don't tend to quibble over 20% here and there for increased flexibility.
16:01:51 <edwardk> also parsec pays a lot for its general token machinery, which can make it harder for the compiler to see to inline some stuff
16:02:13 <edwardk> i figure text parsing isn't my bottleneck
16:02:29 <danilo2> edwardk: Ok, its clear now :) Thank you very much for the help! :)
16:02:34 <edwardk> its getting the parser right, its understanding the errors i get out of it, etc.
16:03:10 <danilo2> edwardk: You are completely right. Nice highlighting and error messages are very important and text parsing speed should not be bottleneck unless you use uu-parsinglib with some complex rules :)
16:07:19 <mornfall> danilo2: that entirely depends on what is the role of parsing in your use case ... if you are slicing through hundreds of megabytes of text, speed can matter a lot :)
16:07:49 <mornfall> (and so it happens in those cases it's usually not a human at the other end, so nice error messages may not be the highest priority)
16:08:02 <danilo2> mornfall: of course. I'm talking about a text language parser :) Something like haskell parser
16:08:42 <vanila> cabal: Error: some packages failed to install:
16:08:42 <vanila> QuickCheck-2.7.6 depends on tf-random-0.5 which failed to install.
16:08:43 <vanila> :((((
16:08:43 <mornfall> I think in that case you should be pondering LL vs LR.
16:08:44 <vanila> why
16:09:37 <vanila> does anyone know the fix for this cabal issue?
16:10:05 <mornfall> danilo2: (combinator/recursive descent parsing is basically LL)
16:10:06 <hpc> vanila: if you scroll up there should be a reason tf-random couldn't install
16:10:20 <vanila> hpc, it's because the .cabal file has unicode in it
16:10:26 <hpc> ew
16:10:28 <vanila> i fixed this before by manually editing it out
16:10:37 <vanila> but now im installing a new thing and i think it uses sandboxes, so its redoing this..
16:11:48 <onat> Would it be terrible to program a router in haskell?
16:12:16 <Sonarpulse> onat there is very good software defined network work in Haskell
16:12:17 <hpc> it might
16:12:17 <mornfall> onat: probably depends on what hardware you want to run it
16:12:27 <onat> im thinking embedded system => little memory  available and predictable speed is of the essence
16:12:32 <vanila>     In the use of `bitSize' (imported from Data.Bits):
16:12:32 <vanila>     Deprecated: "Use 'bitSizeMaybe' or 'finiteBitSize' instead"
16:12:39 <vanila> it gives this error, but i dont think this is exactly the problem
16:12:47 <hpc> home routers are seriously skimpy on specs and you can easily write code that doesn't have nice GC properties
16:13:22 <mornfall> onat: if you want something that resembles realtime, you may want to generate code in Haskell but not run the Haskell runtime at routing time
16:13:47 <hpc> for making one of those tens of thousands of dollars routers, you probably have more time to get the code right, and the benefit of being able to write more maintainable code might show up more
16:14:10 <hpc> maybe
16:14:21 <Sonarpulse> Rust would be a good fit for router itself
16:14:44 <hpc> there's some good small frameworks in haskell that you can use for web configuration
16:15:03 <mornfall> Sonarpulse: so would be LLVM if the code was generated :-)
16:15:29 <mornfall> I think it really all depends on a more precise specification of the problem.
16:16:16 <vanila> can anyone help me get cabal to work please?
16:16:20 <hodapp> edwardk: ummm... soooo... Applicative is Chipotle, basically?
16:16:45 <Sonarpulse> mornfall: hmm?
16:16:49 <hpc> also, when haskell itself isn't the right choice you can usually write a DSL using haskell and write your program in that
16:18:17 <mornfall> Sonarpulse: he could write a router compiler, if the routing tables are static, or even do the high-level work in a BGP-like scenario in haskell but compile or JIT the code that decides about packets...
16:18:46 <mornfall> since “router” could be so many things...
16:18:51 <Sonarpulse> ah ok.
16:19:17 <vanila> http://lpaste.net/109266 this is the error
16:19:24 <zmbmartin> Anyone that can help me with this FromJSON instance. https://gist.github.com/codedmart/e5721ae1b54649d21aa0
16:19:43 <mornfall> (I think hpc had something similar in mind)
16:19:56 <zmbmartin> I want to access _id from Object v so I can cast it to what I need. Not sure how to get _id from v.
16:21:24 <mornfall> zmbmartin: where does cast' come from?
16:21:49 <mornfall> zmbmartin: (a more complete snippet might be useful)
16:21:55 <zmbmartin> mornfall: From Database.MongoDB
16:22:02 <zmbmartin> I have everything else working fine
16:22:24 <mornfall> zmbmartin: well, that cast' is pretty central :-)
16:22:28 <zmbmartin> I am just not sure how to get _id from v so I can work with it.
16:22:30 <onat> but code generation takes a lot of knowledge, not feasible for non-genuses
16:22:40 <mornfall> zmbmartin: the same you get all the other fields?
16:23:06 <mornfall> zmbmartin: id <- v .: "id"
16:23:14 <mornfall> zmbmartin: return $ User (tweak id) ...
16:23:26 <mornfall> not sure what the question is I guess
16:24:29 <josephle> onat: an alternative is to adopt OpenFlow and do your routing using haskell :)
16:24:55 <mornfall> onat: code generation is actually very simple
16:25:02 <mornfall> onat: at least nowadays :-)
16:25:11 <zmbmartin> mornfall: OK Thanks!
16:28:45 <edwardk> mornfall: trifecta is rather deliberately designed for text produced by humans intended to be consumed by humans. i leave the boring protocol stuff to others ;)
16:29:29 <corgifex> edwardk: http://hackage.haskell.org/package/constraints-0.4/docs/Data-Constraint.html#v:bottom "This demonstrates the law of classical logical"
16:29:35 <corgifex> logical -> logic?
16:29:51 <edwardk> corgifex: yeah looks like a typo
16:31:17 <mornfall> edwardk: did you win an award with “fixiting”? ;-)
16:31:42 <edwardk> did i say that somewhere? =)
16:32:08 <mornfall> edwardk: I'm looking at trifecta combinators
16:32:45 <edwardk> ah
16:32:48 <edwardk> i did use that somewhere
16:33:53 <kristof> like Yaml
16:34:26 <mornfall> edwardk: do you have a tutorial?
16:34:36 <xieyuheng> hi, friends. why I can not register a new Lambda The Ultimate account ? always "pending approval" !!
16:35:02 <vanila> xieyuheng, it's been broken for a long time
16:35:33 <kristof> mornfall: There's an example file in the source tree on Github
16:36:04 <zmbmartin> mornfall: Here is the whole file with the original error -> https://gist.github.com/codedmart/e5721ae1b54649d21aa0
16:36:08 <xieyuheng> vanila: new accounts can not be registered anymore ?
16:36:20 <zmbmartin> Not sure how to add a instance FromJSON ObjectID where … ?
16:36:32 <vanila> xieyuheng, yeah - I havne't been able to. I think it's a bug
16:37:12 <Luke> Am I missing something or is there not a way to pack a literal number into a ByteString?
16:37:15 <mornfall> zmbmartin: yes, you need to either write a FromJSON instance for ObjectId or convert it explicitly when passing to User's ctor
16:37:20 <edwardk> mornfall: we've been kinda light on tutorial material for trifecta mainly because i've been threatening to do pretty much a complete rewrite for a couple of years now
16:38:30 <mornfall> edwardk: do you have some sample diagnostics handy? I'm looking for inspiration :)
16:38:34 <orion> hpc: I might not need to create a separate AMI. I think I can simply lauch a micro instance, put all my Haskell stuff on there, stop the instance, detach the EBS volume, and reattch it on the large instance.
16:38:43 <spott> edwardk: what do you want to change?
16:39:34 <mornfall> edwardk: I have a recursive descent parser in C++ and right now I dump a bunch of alternative parses as a diagnostic, but it doesn't make me all that happy
16:39:45 <edwardk> spott: e.g. i'm currently going through and ripping out the rope machinery because nobody but me ever used it and i'm not even using it any more, cleaning up the renderings for diagnostics so they are a serializable AST rather than something that has functions dangling in it
16:39:50 <mornfall> edwardk: also, do you do some sort of error recovery?
16:40:14 <Luke> oh i found it in builder
16:40:38 <edwardk> mornfall: what i do is what parsec does slightly modified to track the current set of alternatives for the current location. so for non-backtracking failures you'll get a set of expected tokens that get fed into the final error message for the current location
16:41:02 <edwardk> when you give an error you can 'draw' on it with fixits, spans and carets to indicate more about the error and how to recover
16:41:30 <edwardk> but trifecta doesn't directly provide error recovery machinery, LL grammars kinda suck at recovery. LR has error productions and can 'hit their stride again' after an error
16:41:53 <mornfall> edwardk: well, why do you think I ask ;-)
16:42:00 <zmbmartin> mornfall: How would I write a FromJSON properly. Or should I just convert explicity?
16:42:16 <edwardk> i did some work on burke-fisher error repair, which can be done in an LL setting. it wasn't bad but it wasn't clear how to wire it up with full generality
16:42:20 <mornfall> zmbmartin: well, you already wrote one for User, it's teh same deal
16:42:53 <jfeltz> in pipes, is a Producer with a base monad guaranteed to not lazily thunk a result following a 'yield'? even if the type yielded has a member with a value that is not evaluated, but record assigned?
16:43:01 <edwardk> i also built a version of CPP that could be put 'atop' a parser in a previous version of my parsing combinator stack, i want to get that out there in mainstream trifecta some time soon. i also want to go back and fix up trifecta so i can turn back on the layout parser
16:43:31 <edwardk> these are all (except for the CPP thing) stuff I need right now for work as well, so I have an incentive to get them right
16:45:00 <zmbmartin> mornfall: I guess I don't understand. I figured out how to explicitly convert it, but I am not sure how to incorporate that into my code properly. Not fully grasping haskell yet.
16:45:39 <mornfall> zmbmartin: well, if you have a function "tweak" that goes String -> ObjectId, then just User (tweak id) ...
16:48:41 <mornfall> zmbmartin: with the same tweak function, you could write instance FromJSON ObjectId where parseJSON = withText "ObjectId" $ tweak
16:48:46 <mornfall> zmbmartin: or something like that, anyway :-)
16:49:26 <mornfall> zmbmartin: (for that you want tweak to be :: Text -> ObjectId, it won't work with String directly)
16:49:55 <mornfall> zmbmartin: (you probably want it to work on Text in both cases, anyway, String is slow and doesn't add any value here)
16:51:05 <mornfall> (that $ is also redundant)
16:51:24 <kristof> I can't remember, why is it that strings are linked lists in haskell?
16:51:34 <mornfall> kristof: historical reasons :-)
16:51:40 <mornfall> kristof: also, it's convenient
16:51:50 <merijn> kristof: Because it makes writing simple string functions easy
16:51:51 <mornfall> unless you want to do anything serious with them, that is
16:52:37 <merijn> kristof: I've done ocaml (where strings aren't linked lists) and while that performs better a lot of easy things become annoyingly hard that way
16:52:38 <mornfall> and I think there was a desire to avoid ListLike stuff
16:53:30 <mornfall> (and overloading pattern matching may not even be a viable option)
16:55:27 <orion> I am using map in this fashion: map B.pack (permute baseWord) -- the array produced by (permute baseWord) is *huge* and it's causing the heap to grow large. Is there a version of map which is strict? Would that even help my problem?
16:55:37 <ij> How was Lens' ^. chosen? .~ reminds me of OOP object call list/chain.
16:55:50 <kristof> merijn: I was just about to say that strings in Ocaml are byte arrays, so it's confusing to me that "historically" the Haskell committee made such a decision.
16:56:33 <spott> does anyone have any recomendations for figuring out a good performance model for haskell?
16:56:56 <merijn> spott: The STG paper?
16:57:04 <spott> STG?
16:57:08 <mornfall> :-)
16:57:10 <spott> I don't know that paper
16:57:17 <mornfall> spott: spineless tagless G-machine
16:57:22 <mornfall> spott: google will bring it up
16:57:49 <spott> found it
16:57:57 <georgeleege> I'm pretty new to haskell and was wondering what the current state of the community/development is. What direction is the langauge moving in? What are some current issues?
16:58:05 <merijn> spott: https://research.microsoft.com/apps/pubs/default.aspx?id=67083
16:58:20 <mornfall> georgeleege: web services! :-)
16:58:34 <merijn> spott: It discusses an intermediate language for haskell and how that can be compiled to C and/or ASM
16:58:55 <merijn> spott: GHC has changed since then, but it's a good starting intuition
16:59:03 <spott> thanks
16:59:51 <shachaf> The STG paper is good for getting a general idea of things but a lot of the specifics are different.
17:00:24 <shachaf> You can get a lot of the details from various more recent papers.
17:00:31 <georgeleege> mornfall: what's the best way that I can keep up with the community?
17:00:55 <merijn> spott: Not to mention that part of what makes performance modelling tricky is the amount of trickery GHC pulls to optimise things
17:01:11 <spott> merijn: yea, I got that...
17:01:13 <mornfall> shachaf: well, I think most of the trouble is in the haskell -> core translation anyway, if you are trying to map haskell-level code to its performance characteristics
17:01:23 <merijn> spott: Generally when trying to performance tune haskell you'd profile to see where it is slow and then inspect the generated Core to figure out why
17:01:46 <merijn> Although even Core can be optimised a lot, see Intel's Core compiler
17:01:57 <zmbmartin> mornfall: Thanks!
17:02:05 <spott> merijn: that isn't open source though, is it?
17:02:12 <shachaf> mornfall: That's fair, but getting a mental model for how Core behaves is important.
17:02:30 <merijn> spott: Probably not
17:02:32 <Luke> is there an easy way to coerce an Int64 lower bits to a Word16
17:02:40 <shachaf> Usually the one people start off with is pretty inaccurate.
17:02:58 <merijn> Luke: Data.Bits to mask everything but lowest 16 bits, then fromIntegral?
17:03:02 <mornfall> merijn: intel's core compiler must be the most ungoogleable thing ever
17:03:03 <Luke> thanks
17:03:04 <Luke> eaxctly
17:03:08 <hpc> > fromInteger (123456789012345678901234567890 :: Int64) :: Word16
17:03:09 <lambdabot>  Couldn't match expected type ‘GHC.Integer.Type.Integer’
17:03:09 <lambdabot>              with actual type ‘GHC.Int.Int64’
17:03:16 <hpc> > fromIntegral (123456789012345678901234567890 :: Int64) :: Word16 -- derp
17:03:16 <nisstyre> mornfall: intel icc
17:03:17 <merijn> Luke: Watch out for negatives, etc. though
17:03:17 <lambdabot>  2770
17:03:31 <Luke> merijn: this is a very special case - not random numbers
17:03:35 <hpc> fromIntegral will already do the truncation
17:03:41 <merijn> hpc: oh, yeah, duh
17:03:41 <mornfall> nisstyre: I don't think icc can compile core?
17:03:46 <spott> mornfall: tell me about it... I tried a while ago
17:04:03 <spott> nisstyre: icc is intel C compiler...
17:04:04 <nisstyre> mornfall: oh sorry, I thought you were talking about icc
17:04:04 <mornfall> nisstyre: that's a C++ compiler
17:04:15 <merijn> mornfall: Intel wrote a "Haskell" compiler that took GHC core, optimised it and then produced some intermediate IR that got compiled by icc
17:04:25 <merijn> mornfall: They had some ridiculous speedups compared to GHC
17:04:28 <nisstyre> you mean the haskell intermediate language I guess?
17:04:33 <mornfall> nisstyre: yes
17:04:42 <mornfall> merijn: I figured that much, yea
17:04:43 <nisstyre> yeah, I remember reading about that now
17:04:43 <spott> http://www.leafpetersen.com/leaf/publications/hs2013/hrc-paper.pdf
17:04:58 <mornfall> merijn: although it makes you wonder where did the speedup come from, really
17:05:10 <edwardk> ij: ^. was chosen to 'get out of the way' and start an oop style field accessor chain. .~  and .= were chosen to be syntactically as close to := as i could get, and it was the quietest' notation available to me.
17:05:11 <merijn> mornfall: Low level numerical optimisation for their own chips
17:05:23 <spott> that is the intel labs haskell research compiler
17:05:27 <mornfall> merijn: that'd only work with some pretty special cases of haskell, though?
17:05:29 <merijn> mornfall: Vector/SIMD instructions, etc.
17:05:32 <onat> mornfall: is it easy to do code geenration? generating what kind of code? are there good libraries?
17:05:47 <merijn> mornfall: Sure, it wasn't "massive speedup for generic desktop app", no
17:05:51 <mornfall> onat: LLVM would be a good start, I think :-)
17:06:16 <mornfall> onat: it has a fairly nifty haskell library too
17:06:22 <dsturnbull> merijn/kristof: i think the idea behind linked lists is that they're essentially O(0) because of laziness, and then when you evaluate that thunk it's going to be the same order of complexity as traditional array manip
17:06:46 <nisstyre> you could also learn how to convert to SS or CPS yourself, and do register allocation, define a calling convention, etc...
17:06:54 <nisstyre> of course it would inevitably suck compared to LLVM
17:06:58 <nisstyre> *SSA
17:07:06 <mornfall> nisstyre: the point was to not learn that stuff :-)
17:07:37 <mornfall> nisstyre: generating code in SSA as such is trivial, getting it out is the problem
17:07:52 <merijn> nisstyre: Depends on your language
17:08:11 <merijn> nisstyre: LLVM still isn't great for, for example GHC's calling convention, afaik
17:08:13 <nisstyre> merijn: I know, which is why I hesitate to say just use LLVM
17:08:27 <kristof> Why isn't it?
17:08:40 <mornfall> merijn: the use case here was packet routing
17:08:45 <joelteon> also, llvm rewrites some string literals :)
17:09:10 <merijn> kristof: Because it was mostly designed with different languages styles in mind so no one thought to optimise for the way lazy languages like to call things?
17:09:28 <mornfall> kristof: because it is special-cased and probably not all transformations are well tuned for it
17:09:35 <merijn> kristof: haskell function calls don't have stack frames, for example
17:09:44 <kristof> merijn: Lazy languages are secretly strict languages deep down. :P
17:11:15 <kristof> I guess I just don't know how one would even optimize a lazy calling convention.
17:11:19 <merijn> kristof: So any "call" construct that assumes you want to push a stack frame is going to be a bit sucky for that
17:11:30 <merijn> kristof: Well, read the STG paper we just linked :)
17:11:34 <kristof> Will do!
17:11:50 <kristof> Before I do: is the "spineless" thing a joke or is that really a part of the design that has a technical meaning?
17:11:56 <merijn> It explains exactly how you can compile a simple, lazy language to asm
17:12:01 <mornfall> kristof: it has technical meaning
17:12:09 <merijn> kristof: Spineless is a technical name
17:12:15 <kristof> got it
17:12:34 <merijn> kristof: In a linked list you would call the cons constructors the "spine"
17:13:11 <merijn> kristof: For container-like data structures in general the spine is "everything that is not contents", i.e. the thing that gives it a "shape"
17:13:34 <kristof> So all the cons boxes, basically.
17:13:38 <spott> Here is another paper on the haskell research compiler: http://www.cs.ru.nl/P.Achten/IFL2013/symposium_proceedings_IFL2013/ifl2013_submission_20.pdf
17:13:41 <merijn> kristof: Although many functional people don't shun puns either :p
17:13:53 <spott> it actually shows some really nice comparisons
17:13:59 <mornfall> kristof: if you are a lisper, then it's just cons boxes yes :-)
17:14:03 <kristof> merijn: What does that look like for a vector?
17:14:23 <kristof> mornfall: Hey hey hey! Keep the slander to yourself, I use arrays and structs in common lisp every day.
17:14:26 <mornfall> kristof: vector doesn't really have any structure
17:14:34 <kristof> mornfall: Gotcha.
17:14:53 <mornfall> kristof: you only get structure from pointers
17:14:54 <kristof> mornfall: Oh, nor does it need it. If this is for optimization, then I assume the spine is relevant because of all the dereferencing of pointers, right?
17:15:05 <mornfall> kristof: so unless your structs have pointers in them, they are flat just like vectors
17:15:22 <merijn> kristof: Vectors don't really have a spine as they have  no linked parts
17:15:51 <kristof> merijn: Gotcha. See, I was thinking at first that the part of a vector which keeps track of its length would be part of the "spine" but I understand what you mean, now
17:16:48 <mornfall> kristof: well, yes, if you have vector as an ADT with length and a pointer to an array, then it has a very simple “spine” (but you wouldn't think of it as a spine if it's constant-sized for all instances)
17:17:14 <carter> @ask davean  is there ANY good priority queue implementation on hackage that has an active dev?
17:17:14 <lambdabot> Consider it noted.
17:17:41 <carter> (the pqueue one looks good, but its not got a repo living anywhere)
17:18:18 <ij> Say I wrote the function that mapped from [[a]] to [[a]], so that f might equal Data.List.transpose. Can I now set heoutpu 7
17:18:52 <ij> Can I set the output from it and undo the mapping without applying transpose again directly?
17:20:33 <mornfall> ij: can you elaborate?
17:22:56 <ij> I'm writing a sudoku solver. I've written a mapper from a sudoku board [[Int]] to list of squares [[Int]]. (I hope I get the words right: )
17:23:06 <ij> The mapping is bijective, but you have to apply it twice more to get with what you came up with. So squars.squares.squares = id :: [[Int]] -> [[Int]]
17:23:33 <ij> Which is ugly and I was wondering whether one can do it in a nicer fashion.
17:24:20 <orion> How should I interpret the productivity percentage reported by +RTS -sstderr? Is it a misleading number, or is a number like 20% absolutely horrible?
17:25:25 <mornfall> ij: well, if you are asking for an inverse of square, it's entirely up to you how you write it :-)
17:25:38 <mornfall> ij: unsquare = square . square is probably quite reasonable
17:26:00 <mornfall> ij: (presumably you aren't in it for top performance, or you wouldn't be using lists this way)
17:27:58 <trap_exit> how can I learn how to use the lift* functions? I'm writing moands alot
17:28:02 <ij> I was thinking about that, but I thought that maybe because I showed map to one way it can figure out the inverse itself.
17:28:05 <trap_exit> and I feel like I'm repeating junk that lift was built to solve
17:28:29 <mornfall> ij: no, not really :-)
17:29:04 <mornfall> ij: it doesn't even know it's a bijection and that's already undecidable
17:30:04 <ij> A bummer, thanks.
17:33:06 <trap_exit> can these two lines (inside of a MOnad) be simplified to one line?
17:33:06 <trap_exit> https://gist.github.com/anonymous/8a3da21cd6fe727a801b
17:33:08 <mornfall> ij: you can prove that for yourself, I guess?
17:33:38 <josephle> trap_exit: strict_state_get >>= (_cmap__cnt . _gs__gui)
17:33:47 <ij> mornfall, No, I think not.
17:33:55 <trap_exit> I was hoping something based on liftM
17:33:58 <trap_exit> something like cnt <- liftM ...
17:34:14 <mornfall> josephle: actually, cnt <- _cmap__cnt . _gs__gui <$> strict_state_get
17:34:27 <josephle> oh yeah, that works even better
17:34:30 <mornfall> (I always forget if . or <$> takes precedence)
17:34:44 <mornfall> josephle: well, you have a type error in there :)
17:34:55 <trap_exit>   cnt <- Control.Monad.liftM (_cmap__cnt . _gs__gui) strict_state__get
17:34:56 <trap_exit> I am awesome
17:35:02 <trap_exit> mornfall : ah, did not see your example
17:35:05 <mornfall> trap_exit: yes, but fmap is better :-)
17:35:07 <trap_exit> is <$> == liftM ?
17:35:10 <mornfall> (fmap is <$>)
17:35:18 <mornfall> trap_exit: liftM is fmap for monads yes
17:35:21 <mornfall> forget about it :-)
17:35:23 <trap_exit> mornfall I do like yours more
17:35:34 <josephle> mornfall: ah, it's hard to program without knowing the types :(
17:35:39 <trap_exit> no no, using <$> makes me feel like a superman
17:35:58 <mornfall> trap_exit: I mean forget about liftM, it's only good if you are lazy typing Functor constraints
17:36:10 <trap_exit> ah, forget about liftM, use <$>
17:36:10 <trap_exit> I agree
17:36:16 <Luke> merijn: cant see how to downcast with Data.Bit
17:36:22 <mornfall> (or fmap, sometimes that's more readable)
17:36:59 <merijn> Luke: I said use fromIntegral after truncating, but hpc pointed out that fromIntegral already truncates
17:37:13 <josephle> idiomatic haskell style guide: "whatever reads the best"
17:37:18 <merijn> > fromIntegral (5679796279676780790752 :: Int64) :: Word16
17:37:20 <lambdabot>  50144
17:37:29 <Luke> oh gotcha - thanks
17:37:45 <JohnTalent> http://pastie.org/9468548
17:38:11 <Luke> great thanks so much - I didn't realize fromIntegral truncated
17:38:22 <mornfall> josephle: obviously
17:40:44 <Cale> JohnTalent: Well, let's deal with the first problem, cabal install happy, and make sure that ~/.cabal/bin/ is in your PATH
17:41:13 <Cale> Oh, I guess that's not even the first problem
17:41:22 <Cale> There's a lot of weird stuff going on there
17:43:58 * hackagebot matrix 0.3.4.0 - A native implementation of matrix operations.  http://hackage.haskell.org/package/matrix-0.3.4.0 (DanielDiaz)
17:44:00 * hackagebot lojbanParser 0.1.9.1 - lojban parser  http://hackage.haskell.org/package/lojbanParser-0.1.9.1 (YoshikuniJujo)
17:48:00 <JohnTalent> Cale: ok done. cabal install --help doesn't show ghcjs
17:48:17 <Cale> JohnTalent: Yeah, I really don't know anything about ghcjs
17:48:39 <Cale> I assume a lot of the linking issues you're having have something to do with that
17:49:07 <merijn> There was some discussion earlier about cabal not really finding a good install for ghcjs
17:49:23 <merijn> JohnTalent: luite works on ghcjs and is in here a lot, I recommend asking him if he's around
17:49:53 <JohnTalent> luite: hi
17:52:48 <JohnTalent> noticing 100% cpu usage on ghc with like 85% idle on a 4 core.
17:53:15 <codile> ghc really uses a lot of resources
17:53:35 <JohnTalent> thats not the point, it isn't using the 7 other core threads.
17:53:41 <codile> oh
17:53:45 <codile> hmm
17:54:22 <kristof> computing liebensraum
17:54:28 <luite> JohnTalent: hi
17:54:38 <JohnTalent> luite: hi how are you?
17:55:53 <luite> JohnTalent: see the readme, you need the ghcjs branch from the forked cabal repository at https://github.com/ghcjs/cabal
17:56:49 <luite> JohnTalent: those missing libraries mean that oyu probably installed some stuff with a very old cabal-install
17:57:32 <codile> applicative functors are just screwing with my mind..
17:57:34 <JohnTalent> aye, thats the one i'm using
17:57:48 <luite> JohnTalent: so when you have a working recent (1.18+) cabal-install, you'll probably want to gt rid of your ghc package db
17:58:32 <luite> JohnTalent: you don't need --enable-shared anymore for ghcjs (template haskell is handled differently now), and it's better to not install as root
17:59:52 <JohnTalent> luite: ok
18:00:51 <luite> JohnTalent: do you know where you found the --enable-shared thing? perhaps i forgot to update some documentation
18:01:00 <JohnTalent> haskell(+ [Act: 3,4,5,6,7,8,9,10,11,13]
18:01:01 <JohnTalent> [#haskell]
18:01:34 <JohnTalent> installed cabal 1.21.0.0
18:01:36 <JohnTalent> is that ok
18:01:44 <JohnTalent> luite: the github page for ghcjs
18:02:24 <luite> JohnTalent: yeah that's the correct version, it should mention --ghcjs as an option for cabal install --help (otherwise you picked the wrong branch)
18:02:53 <JohnTalent> have to apt-get uninstall
18:03:43 <luite> JohnTalent: what do you need to uninstall?
18:07:04 <luite> JohnTalent: are you sure you got that --enable-shared from https://github.com/ghcjs/ghcjs and not an old fork of that repo? i can't find it there
18:08:14 <JohnTalent> interesting
18:08:19 <JohnTalent> sudo cabal cannot be found
18:08:26 <JohnTalent> but cabal works
18:09:14 <JohnTalent> luite: it was probably from my terminal while I was in this compile-soup
18:09:55 <luite> JohnTalent: don't use sudo from now on when installing haskell things with cabal :)  the executable is probably installed in ~/.cabal/bin if you installed cabal-install as a normal user
18:10:12 <JohnTalent> yes i have to use sudo or I get perm errors
18:10:21 <luite> then probably something else is wrong
18:10:48 <luite> default cabal config should install into ~/.cabal, better fix the actual problem
18:11:26 <JohnTalent> luite: http://pastie.org/9468588
18:12:28 <luite> JohnTalent: you probably ran cabal with sudo in the same tree, so your dist subdir is owned by root. remove dist, or sudo chown -R everything
18:13:13 <JohnTalent> remove what dist
18:13:14 <JohnTalent> ?
18:13:36 <luite> JohnTalent: ./Cabal/dist and ./cabal-install/dist
18:16:02 <ij> Why can't I define this function with that error message? http://sprunge.us/FAcf
18:16:04 <JohnTalent> luite: ok, recompilig
18:16:10 <JohnTalent> recompiling
18:17:00 <JohnTalent> nope
18:17:08 <JohnTalent> deleting the dist dirs didn't do it.
18:17:18 <JohnTalent> wow, d in command. :)
18:17:43 <JohnTalent> http://pastie.org/9468596
18:18:27 <luite> JohnTalent: ack you also need to chown everything in ~/.cabal
18:19:47 <solidus-river> where does layman put overlays?
18:19:58 <JohnTalent> chown -R *
18:20:03 <JohnTalent> recompiling
18:20:19 <trap_exit> does haskell have an ordered set? I want O(log n) time removal, but also for the set to have an 'order'
18:20:50 <JohnTalent> luite: why doesn't ghc use all my idle cores?
18:21:13 <codile> ij: a needs to be the same for all the parameters and the return
18:21:38 <codile> when you put a Board in there you can't return an error
18:21:39 <JohnTalent> luite: same exact error
18:21:49 <codile> at least that's what i think
18:21:50 <trap_exit> JohnTalen: ghc or ghcjs ?
18:21:55 <luite> JohnTalent: it only compiles one file at a time
18:21:56 <JohnTalent> luite:
18:22:04 <JohnTalent> trap_exit: ghc
18:22:23 <merijn> trap_exit: Haskell sets are ordered by default
18:22:29 <JohnTalent> luite: cabal-install-1.21.0.0 depends on Cabal-1.21.0.0 which failed to install
18:22:34 <merijn> trap_exit: Oh wait, did you mean insertion order?
18:22:35 <luite> JohnTalent: what did you run to change the ownership of the files under ~/.cabal ?
18:22:37 <trap_exit> merijn: well, I mean "the original order I specify"
18:22:46 <trap_exit> merijn: yes, basically I want a list with O(log n) time removal
18:22:50 <JohnTalent> luite: cd ~/.cabal; chown -R *
18:22:56 <merijn> trap_exit: Then I don't know
18:23:46 <JohnTalent> okay, it didn't get bin
18:23:48 <JohnTalent> retrying
18:24:30 <luite> JohnTalent: yeah you need to add the user:group to change ownership to, and probably run it as root
18:25:18 <JohnTalent> recompling ghcjs is there now
18:25:31 <JohnTalent> i changed it to john/john
18:26:11 <codile> does anyone know a useful application of applicative functors?
18:27:17 <JohnTalent> luite: http://stackoverflow.com/questions/23927744/where-is-libhsprimitive-0-5-3-0-so
18:27:26 <JohnTalent> that is where i got it
18:27:55 <JohnTalent> luite: works
18:28:13 <ij> codile, But error is String -> a, so it matches, doesn't it?
18:29:31 <luite> trap_exit: Data.Sequence has that
18:30:11 <pavonia> codile: Parser combinators
18:30:57 <athan> codile: I like to think of it as contextual application
18:32:17 <athan> codile: The only thing that applicatives don't have that monads do is `join`; merging two wrapped contexts into one (except I'm kinda wrong, there's a lot of detail in this kind of stuff)
18:34:14 <glguy> Codile: http://hackage.haskell.org/package/async
18:34:20 <orion> heh
18:34:31 <glguy> Here's an interesting application of them
18:34:55 <orion> Does this heap profile look funny to anyone?: http://i.imgur.com/agdx4hG.png
18:35:05 <JohnTalent> http://pastebin.com/v84BZ6fD
18:36:36 <luite> JohnTalent: run ghc-pkg check and remove all the packages with missing libraries
18:38:17 <JohnTalent> luite: i run gh-pkg check and there are plenty of 'doesn't exist or isn't a directory' under /home/john/.cabal/share/*
18:38:26 <JohnTalent> ghc-pkg check
18:39:21 <luite> JohnTalent: ignore the warnings, unregister the packages that have errors
18:39:26 <JohnTalent> how?
18:39:29 <JohnTalent> i'm a newb.
18:39:53 <luite> JohnTalent: can you paste the output of ghc-pkg list ?
18:40:46 <JohnTalent> yes, and ghc-pkg doesn't allow piping to a file
18:41:26 <luite> it's printing things to stderr, use 2>somefile to redirect that stream
18:41:51 <JohnTalent> luite: http://pastebin.com/ui9X8Ss3
18:41:55 <dmj`> ghc-pkg list > file.txt
18:42:01 <JohnTalent> ok
18:44:11 <Fuuzetsu> luite: speak to Simon yet?
18:44:31 <luite> Fuuzetsu: sorry forgot to finish the mail
18:45:05 <TheMoonMaster> Can I use getLine and `where` together to read a number from input?
18:45:15 <Fuuzetsu> well, while I'm not in particular rush I'd rather know sooner than later because I want to do the thing I spoke about on GHC devs which will probably result in a release
18:46:06 <JohnTalent> luite: did u get the paste?
18:46:32 <Fuuzetsu> TheMoonMaster: maybe, depends on what your code looks like. In the end getLine will have to be in IO block to run
18:46:34 <luite> Fuuzetsu: yeah i see, i'll send it soon :)
18:46:57 <TheMoonMaster> Fuuzetsu: I'm terrible at Haskell, basically a function that compares a passed in number to input
18:47:17 <TheMoonMaster> So I'm trying to do something similar to `  where guess = read getLine`
18:47:28 <luite> JohnTalent: yeah but you need to paste the ghc-pkg list output
18:47:40 <JohnTalent> luite:
18:47:41 <JohnTalent> ok
18:47:46 <Fuuzetsu> what's wrong with ‘compare x = do { y <- read <$> getLine; {- do whatever here -} }’
18:47:57 <TheMoonMaster> I have no idea what the hell half of that does.
18:48:01 <TheMoonMaster> That's what's wrong with it
18:48:16 <dmj`> getNum <$> getLine where getNum :: String -> IO (Maybe Int); getNum = return . readMaybe
18:48:24 <Fuuzetsu> did you trying reading something like Learn You a Haskell?
18:48:27 <TheMoonMaster> I'm trying to use guards with the function as well, hence the `where`
18:48:32 <TheMoonMaster> I'm in the middle of that, yeah.
18:48:39 <JohnTalent> http://pastebin.com/jMqXxH9z
18:48:40 <TheMoonMaster> But Haskell isn't exactly the friendliest language to learn.
18:49:12 <Fuuzetsu> it's a pretty friendly language to learn, don't have to worry about any nasty stuff happening behind your back, or nulls or any other dumb stuff usually present ;)
18:49:20 <JohnTalent> TheMoonMaster: https://www.fpcomplete.com/school/starting-with-haskell/introduction-to-haskell
18:49:26 <TheMoonMaster> No offense, but that's total bs.
18:49:28 <Fuuzetsu> anyway if you can put up what you have on lpaste.net then it might be easier for us to help
18:49:33 <TheMoonMaster> It's definitely not friendly to learn.
18:49:48 <TheMoonMaster> JohnTalent: Thanks dude, I'll check that out.
18:50:10 <Fuuzetsu> TheMoonMaster: Why not?
18:50:15 <TheMoonMaster> Fuuzetsu: It's easy once you get it I'm sure, but getting there is the problem.
18:50:24 <TheMoonMaster> Because of the way it handles state mostly.
18:50:31 <TheMoonMaster> At least that's my impression at this point.
18:50:33 <Cale> I don't think it's any harder than whatever your first language was
18:50:49 <Fuuzetsu> Oh, so what you actually meant to say is “It doesn't do what I have come to expect from other languages”.
18:51:09 <TheMoonMaster> No, what I meant to say is that it's harder to learn than other languages.
18:51:25 <TheMoonMaster> Which is an opinion.
18:51:44 <dmj`> TheMoonMaster: print =<< (readMaybe :: String -> Maybe Int) <$> getLine
18:51:54 <Fuuzetsu> Why? It has fewer constructs than most languages and much fewer gotchas.
18:52:11 <Cale> In absolute terms, Haskell isn't really any more complicated than the average language. Maybe once you throw in all the various extensions, it starts to push things a little, but for instance, the Haskell Report and the GHC User Guide (which describes all the extensions along with a lot of other stuff) still comes to around 1/5 the size of the C++ spec.
18:52:28 <JohnTalent> I think it's the documenation. Most Haskell stuff is poor on examples and high on dissertation.
18:52:36 <Fuuzetsu> Cale: 1/5th of the C++ spec is still a lot ;P
18:52:40 <TheMoonMaster> I'll agree with JohnTalent on that one
18:52:51 <dmj`> JohnTalent: the types are pretty descriptive, but yea, there's a lot of reading source
18:52:52 <TheMoonMaster> And yeah, C++ is a clusterfuck but I'd definitely say it's easier to begin with
18:53:01 <TheMoonMaster> Just because I can easily hack my way to get something to work.
18:53:13 <Cale> TheMoonMaster: I'd totally disagree, and I *did* learn C++ before Haskell
18:53:14 <JohnTalent> luite: thanks btw.
18:53:15 <TheMoonMaster> Not saying that I WANT to hack things to work, but you can.
18:53:20 <Fuuzetsu> I also disagree.
18:53:40 <TheMoonMaster> That's fair, different people, different experiences.
18:53:42 <Cale> C++ was way harder and took me longer to learn than Haskell.
18:54:27 <codile> Cale: really?
18:54:55 <Cale> Yes, though I was younger and less experienced at the time I was learning C++
18:55:15 <codile> hmm
18:55:21 <TheMoonMaster> I was too. :P
18:55:25 <Cale> Don't get me wrong, it took me a couple months before I felt like I could do useful things with Haskell, and a year to be comfortable.
18:55:29 <codile> well, i was learning C++ after C and I was like 14
18:55:32 <orion> dmj`: Hey.
18:55:33 <codile> it wasn't that hard
18:55:44 <Cale> But it took longer than that to get to doing similar useful things with C++
18:55:49 <codile> but haskell is just blowing my mind right now
18:55:57 <TheMoonMaster> If it means anything, I feel pretty comfortable with Elixir/Erlang
18:56:07 <JohnTalent> luite: Are you still there?
18:56:20 <TheMoonMaster> So it's definitely not the whole functional paradigm thing tripping me up for the most part.
18:56:26 <codile> i'm just wondering if i need to fully understand everything in haskell to o what i can do with C/C++
18:56:30 <solatis> ok, I want to create some high-level integration tests for my application (specifically, fire up a server, launch some requests, and validate the responses), is there any framework I should use, or is my intuition to just use exitcode-stdio without any framework correct?
18:56:46 <orion> dmj`: So, it appears that there isn't a space leak after all.
18:57:22 <flebron> Say I rm -rf ~/.ghc ~/.cabal, and I still have cabal issues. Wat do?
18:57:54 <solatis> flebron: uninstall cabal completely and reinstall perhaps?
18:57:57 <ParahSailin> has anyone ever looked at implementing uwsgi protocol
18:58:02 <Cale> The main thing which throws more experienced programmers (myself included) is that they usually expect to be able to pick up yet another language really easily, having put in a long time learning their first few, and then other similar languages start getting easy (like, you can pick them up in a week and do useful things)
18:58:16 <Cale> But Haskell isn't necessarily similar to a language you already know
18:58:22 <Cale> even if it's not really any more complicated
18:58:33 <orion> hm
18:58:50 <JohnTalent> haskell docs needs less talk and more combinations of trivial examples, preferable related.
18:58:54 <Fuuzetsu> codile: In contrary, because it's very hard to break something you didn't write in Haskell, it's rather easy to get going. In C++ you need to think about when stuff gets freed, allocated, does that function free memory? Does that one? Oh but what if I need to set some variable… Oh, I could use a generic function here, brb 20 mins, templates. Oh damn, segfault… I don't understand how this is any better than going ‘oh, that has that type,
18:58:54 <Fuuzetsu> OK, I now know everything I need to know to use the function.’.
18:59:34 <Cale> JohnTalent: Yeah, that probably would help beginners a bunch. The experienced Haskell programmers tend to get by really well just looking at the types of things and fitting pieces together on that basis.
18:59:50 <codile> Fuuzetsu: well, that's true but you don't really need pointers that often
18:59:57 <codile> especially not in C++
19:00:21 <codile> there are certain problems that i can solve way easier with haskell than with C++
19:00:31 <Cale> But having examples is also just useful to get you pointed in the right direction. Sometimes the types don't make it totally obvious what's going on from the outset.
19:00:34 <codile> but there are some concepts in haskell that i can't quite understand
19:00:47 <Cale> codile: Anything in particular?
19:00:58 <codile> applicative functors for example
19:01:10 <JohnTalent> Cale: I for example can't get past monads in any documentation. i'm just giving haskell my 4th go after many years.
19:01:11 <Fuuzetsu> codile: I hear this often and yet the few C++ programs I run still segfault every few commits, why is this? Everyone I speak to blames bad programmers but then I struggle to see any good programmers. My point is simply that in Haskell you don't have to worry about any of that stuff while in C++ you do as even if you don't use it your library might. It should be clear in which situation it's easier to get going.
19:01:13 <codile> and i know that even worse stuff is to come
19:01:23 <Fuuzetsu> Not to even mention cryptic C++ error messages half the time.
19:01:26 <flebron> Heh. "cabal install hflags". Try to compile my .hs, missing Criterion. "cabal install criterion". Try to compile, now missing HFlags.
19:01:40 <flebron> Without a doubt, cabal's the worst part of Haskell :p
19:01:53 <Cale> The best thing to do about monads and applicative functors is to mostly ignore the problem of understanding what they mean. You learn what those things are by using examples of them.
19:01:54 <Fuuzetsu> Easily fixed with nix
19:02:12 <flebron> I can deal with C++ error messages. I can't deal with Cabal :p
19:02:17 <codile> Cale: okay. i hope that works :D
19:02:19 <Cale> Really, Monad and Applicative are just particular shapes that show up a lot in library APIs
19:02:30 <JohnTalent> Fuuzetsu: direct access to memory is c++'s strength and weakness.
19:02:34 <codile> Fuuzetsu: well, that's true. haskell may be easier to use but C++ is easier to learn
19:02:37 <codile> it's like php
19:02:45 <codile> you can learn it very easy
19:02:59 <codile> but it isn't necessarily a good language
19:03:15 <codile> but you can hack stuff together pretty easily
19:03:28 <codile> which is what a beginner will try to do
19:03:33 <JohnTalent> Cale: ok
19:03:57 <Fuuzetsu> codile: I don't understand how having to learn 20 different things and pick from 10 different historical printing functions to make sure your simple program is correct is easier. What exactly is hard about Haskell that makes it hard when learning?
19:04:19 <Cale> In functional programming, we often don't like to write fragile solutions to problems directly. We're much happier to write embedded domain-specific languages in which the solution to our problem is easy to express.
19:04:31 <Cale> When you do this, certain patterns start showing up
19:04:56 <codile> Fuuzetsu: all that weird stuff
19:05:01 <Cale> Monad and Applicative are just names for some of the patterns which show up often enough that we've abstracted them out in order to not write the same code over and over
19:05:25 <desophos> i think haskell the language definitely isn't the hard part about learning haskell; it's functional design and philosophy
19:05:30 <codile> maybe i'm just reading the wrong book but c++ was easier to learn
19:05:46 <desophos> designing haskell programs is way harder than designing C++ programs
19:05:54 <Cale> codile: Which book?
19:05:57 <Fuuzetsu> codile: What weird stuff? There is no weird stuff unless you come with a preconceived idea of what's normal and what's weird which just refers back to “I expect it to work like what I already know about but it doesn't so it must mean Haskell is hard” which is inaccurate to say the least.
19:05:58 <codile> LYAH
19:06:40 <Cale> I don't know how LYAH is for the later bits. At some point I really ought to read it through. (It showed up after I learned Haskell)
19:06:44 <desophos> haskell just forces you to know what you're doing during the entire coding process
19:06:56 <codile> Fuuzetsu: no, i don't expect it to work in any way. it's just like maths or physics. you learn some weird new thing and don't have any idea what to do with it
19:07:02 <Fuuzetsu> I also think we have different idea of what it means to ‘learn’ the language. I'm talking about a level where you can use it where the program behaves more or less like you expect it to. I'm sceptic that's your definition considering you called PHP easy to learn. It's very easy to write a broken program that seems to do what you want it to do on some inputs but it's no doubt broken.
19:07:51 <Cale> codile, JohnTalent: A really good example to look at to get a sense for the point of Monad as an abstraction is 'sequence'
19:08:15 <codile> sequence?
19:08:33 <cdk> codile: Haskell is not difficult to learn, it is your previous languages that are difficult to unlearn :)
19:08:39 <Cale> sequence is a function which takes a list of actions (in some monad), and combines them together into a single action which computes a list of results by running each of the actions in the list it was given
19:08:47 <Cale> Its type is
19:08:47 <codile> cdk: that might also be it :D
19:08:49 <Cale> :t sequence
19:08:50 <lambdabot> Monad m => [m a] -> m [a]
19:08:57 <desophos> cdk: that's pretty accurate :p
19:08:58 <Cale> Let's write it :)
19:09:02 <Fuuzetsu> desophos: Does it? I write down the type I'd like the thing to have in the end and then hack away bit by bit until GHC is pleased. It's super easy to write something without having a general idea of the end result.
19:09:08 <codile> i don't even know what a monad is :/
19:09:22 <Cale> ah, okay
19:09:32 <Cale> codile: Then you shouldn't be worried about applicative functors!
19:09:42 <codile> oh, okay :P
19:09:54 <JohnTalent> Cale: listening! :)
19:09:57 <Cale> okay
19:10:27 <Cale> sequence [] = return [] -- when the list of actions is empty, sequence will give us an action which does nothing except to produce an empty list as its result
19:10:44 <Cale> (return v is always the action which does nothing except to, well, return v)
19:10:56 <Cale> sequence (x:xs) = ...
19:11:03 <desophos> Fuuzetsu: haskell (i.e. FP) seems to me to encourage a top-down design where you have to figure out how everything fits together before writing the pieces, i.e. design before implementation
19:11:12 <Cale> now, if we have a nonempty list of actions, we want to run each of them in turn, collecting up a list of the results
19:11:14 <desophos> i mean, you can write things as needed
19:11:19 <Cale> sequence (x:xs) = do v <- x; ...
19:11:21 <benzrf> desophos: dont be absurd
19:11:24 <benzrf> the whole point is bottom up!!!
19:11:25 <Cale> so we run the first one, getting some result v
19:11:33 <benzrf> desophos: invent a data type, then implement useful-seeming operations on it
19:11:37 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; ...
19:11:51 <Cale> and then we (recursively) run the rest of them, getting a list of results vs
19:11:59 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:12:12 <Cale> finally, we return a collected list of all the results
19:12:40 <benzrf> the rest is easy
19:12:40 <benzrf> [this is a lie]
19:12:43 <JohnTalent> Cale: makes sense!
19:12:44 <Cale> So, this sequence thing is a bit like a primordial loop
19:13:00 <Cale> If we can decide ahead of time what's to happen on each iteration, and form a list of actions
19:13:08 <Cale> then sequence will stitch them together
19:13:22 <desophos> benzrf: i assume your definition of "data type" is very liberal
19:14:15 <Fuuzetsu> data MyResult = …
19:14:43 <Cale> In the list monad, "running" a list means picking an element from it, and this is done in all possible ways
19:14:47 <benzrf> something suitably genreic
19:14:48 <nickPapanastasio> Hey guys, so I'm having a hell of a time installing the platform version 7.8.3. I followed the instructions found here: https://www.haskell.org/platform/linux.html#binary, to recieve a message that activeate-hs didn't exist. I then cd'd into it's directory to execute it there, to recieve "couldn't deduce location of ghc root." Any insights?
19:15:01 <benzrf> desophos: why, what have u designed that turned out top down
19:15:03 <desophos> i suppose ADTs can be far more complex than i've experienced
19:15:15 <Cale> So, with that monad instance, sequence will take a list of lists, and pick one element from each, in all possible ways, collecting up lists of the choices:
19:15:20 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
19:15:22 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
19:15:45 <Fuuzetsu> desophos: they can also be very simple; anyway, you can use this approach at any point in the program, write down the type of the thing you want to achieve next and start hacking away in sequence
19:15:47 <desophos> benzrf: i haven't designed anything bigger than a couple functions yet :p
19:16:05 <Cale> In the IO monad, sequence does the more mundane thing of just making an IO action that when executed will execute each of the actions in turn
19:16:17 <Fuuzetsu> often I'll just stick a few functions I want to eventually have and their types and define them as undefined then hack in order
19:16:31 <Cale> In a parsing monad, sequence will concatenate a list of parsers, collecting a list of the parsed results
19:16:41 <Cale> (or rather, making a parser which does)
19:16:49 <benzrf> Fuuzetsu: yea i think everyone does tha
19:16:51 <benzrf> t
19:17:06 <desophos> hmm, but doesn't coming up with the type signatures mean figuring out where something fits?
19:17:56 <Cale> JohnTalent: So, because this thing is already in the Control.Monad library, we don't have to write any of these specific instances of it, if we realise that our new library happens to support operations corresponding to return and (>>=)
19:18:17 <Cale> sequence will typically do something useful in any setting where there's a sensible definition for those two things
19:18:52 <Cale> Similarly, there are a bunch of other control-structure-like devices in Control.Monad which will work with anything that happens to be a monad
19:19:14 <Fuuzetsu> desophos: not really, why would it? You set yourself a goal of what next you'd like to achieve, put down a reasonable type and then work towards that. If you change your mind later then change your type and fix up the errors. You can do this as far ahead in the program as you'd like or not far at all. You can keep doing this until you arrive at goal small enough that you can hack.
19:19:29 <desophos> hm, i see
19:19:30 <Cale> e.g. forM, which takes a list to iterate over, and a function from elements of that list to actions to be performed (a loop body), and acts as a for-each loop
19:19:40 <Cale> and also collects up the results of each iteration
19:19:50 <Cale> forM is actually easy to write in terms of sequence:
19:19:55 <JohnTalent> Cale: is that list monad lazy by default?
19:20:02 <Cale> forM xs f = sequence (map f xs)
19:20:16 <desophos> then i think the hard part is unlearning imperative style :)
19:20:26 <Cale> JohnTalent: Yeah, well, evaluation is lazy in Haskell by default, and the list monad does nothing to make it any stricter than it needs to be
19:20:53 <Cale> JohnTalent: So, running things in the list monad will effectively be like doing a depth-first search
19:20:55 <Fuuzetsu> desophos: for example, say you're interfacing with some server and want to pull down some data. End goal is some type which represents the parsed data. You can put this down if you like. Hm, OK, what now, that seems like that's a fairly hefty stretch, let's set a closer goal. Let's make a type which represents a request to the server. If that's still too much you can have types which then compose into the request and so on and so on.
19:21:09 <Cale> You'll be able to take the head of the list, and it'll just compute the first solution it finds
19:21:12 <nickPapanastasio> :Cale Doesn't (>>=) cause a strict evaluation?
19:21:33 <Cale> Only insofar as >>= pattern matches on the list to its left
19:21:34 <Fuuzetsu> And the great thing about this is that if you feel like working on say, data parsing, you can stop everything else at any time and simply assume everything before has been done already. The types let you do that.
19:21:55 <Cale> For the list monad,  xs >>= f = concat (map f xs)
19:22:35 <Cale> and both concat and map need to pattern match a bit on the lists involved in order to compute part of their result
19:22:48 <Cale> But in order to compute the first element of the list, you don't have to compute everything all the way
19:22:53 <trap_exit> anyone feel like they're doing error driven development?
19:22:56 <Cale> (at least, not in general)
19:23:02 <desophos> trap_exit: always
19:23:05 * trap_exit shuts up
19:23:09 <trap_exit> Cale: go ahead
19:23:09 <Fuuzetsu> trap_exit: errors are great
19:23:14 <nickPapanastasio> So would an infinite list as the lhs of >>= cause an issue?
19:23:20 <Cale> nope!
19:23:28 <Cale> > [1..] >>= (\x -> [x, 10*x])
19:23:29 <lambdabot>  [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100,11,110,12,120,13,130,14...
19:24:16 <trap_exit> I've noted, in my haskll development: when I get type errors -- I know what to do. When I get exceptions, I know what line of code to look at. The only time when I'm stuck is when (1) the code compiles, (2) runs without exception, and now I'm like "wtf, what is the next step I need to do." tag: desophos, Fuzzetsu
19:24:40 <trap_exit> so it seems like if I can write code in a way where .. when I start, I throw an exception ... then as I write code, it continues to throw exceptions / have type errors until I finish, ... I'd be maximally productive
19:24:48 <Fuuzetsu> trap_exit: you're either done or you need to stick more types in
19:24:49 <benzrf> trap_exit: well it's nice because then you can always debug functions in a vacuum :-)
19:25:08 <Cale> nickPapanastasio: If you want to pick elements from more than one infinite list at a time though, the order in which the list monad does its search will foil you a bit, because you'll never get past the first element of the first infinite list once you start searching through the second (it behaves like nested loops)
19:25:10 <Fuuzetsu> also if my code throws a runtime exception I consider this a failure and throw my hands up in the air cursing unchecked exceptions
19:25:12 <trap_exit> benzrf: debug functions in a vacuum ?
19:25:19 <benzrf> trap_exit: basically what youre saying is that you have an easier time fixing errors than debugging
19:25:25 <benzrf> which has always been true for everyone :p
19:25:38 <benzrf> haskell just moves a lot more things into the realm of errors
19:25:38 <trap_exit> no no, I have an easier time fixing errors ... than making design decisions of what to write next
19:25:52 <Cale> > do x <- [1..]; y <- [1..]; return (x,y)
19:25:54 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12),...
19:25:55 <JohnTalent> Cale: can you describe xs >>= f = concat (map f xs) ?
19:25:58 <trap_exit> so I write code "bottm up" rather than "top down"
19:25:59 <Fuuzetsu> More types. Answer is *always* more types.
19:26:02 <benzrf> trap_exit: in languages like ruby or java, you have impure functions and methods that depend on program state
19:26:03 <luite> trap_exit: you're looking for Data.Sequence
19:26:14 <Cale> JohnTalent: Sure, well, let's start with the types
19:26:14 <benzrf> so you cant rly debug without a powerful debugger or print tracing
19:26:19 <JohnTalent> oh nevermind
19:26:26 <benzrf> in haskell you can always test a function outside of any stateful context
19:26:34 <benzrf> because everything it needs to know about is in the arguments
19:26:35 <Cale> JohnTalent: In general, we need to have (>>=) :: M a -> (a -> M b) -> M b, where M is our monad
19:26:42 <Fuuzetsu> this is probably why Haskell debugging tools are rather poor, not much debugging
19:26:47 <benzrf> which means you dont need a full running instance to debug (well, not ALWAYS)
19:26:48 <JohnTalent> that example is a list monad, correct Cale ?
19:26:53 <Fuuzetsu> and we have stuff like QC to check things up on the fly as we develop
19:27:06 <benzrf> i still wish buddha hadnt stopped bein a thing
19:27:08 <benzrf> it looked sweet
19:27:13 <trap_exit> luite: damn , you're right, that is what I want
19:27:18 <Cale> yeah, we're looking at the list monad
19:27:33 <Cale> JohnTalent: So, in the case of the list monad, this means we have (>>=) :: [a] -> (a -> [b]) -> [b]
19:28:00 <Cale> So, it's taking a list of apples, and a function which converts an apple into a list of blueberries, and it's producing a list of blueberries
19:28:07 <trap_exit> luite: no, that's not what I want ... I want a list with O(log n) remove
19:28:12 <trap_exit> luite: but I don't know where the item is located
19:28:14 <benzrf> man, types of fruit
19:28:20 <Fuuzetsu> benzrf: looks nice, what happened to it
19:28:26 <benzrf> Fuuzetsu: time
19:28:36 <johnw> O(leg k) measures complexity of type hacking
19:28:36 <benzrf> do we really want our apples and blueberries as different types
19:28:36 <benzrf> now we cant speak abstractly about fruit :'(
19:28:42 <benzrf> johnw: kek
19:28:53 <luite> trap_exit: oh!
19:29:06 * hodapp looks at johnw
19:29:09 <trap_exit> luite: yeah, so I wnat a "set" but with the set in order
19:29:14 <hodapp> not sure if punning...
19:29:20 <Cale> There's a unique most natural thing that such a function could be doing, once you eliminate all the stupid solutions
19:29:25 <johnw> reference to Oleg Kiselyov
19:29:25 <spott> anyone know why vector won't build its documentation? even when I use --enable-documentation or --haddock-all in my `cabal install vector` instruction?
19:29:34 <hodapp> johnw: *slow clap*
19:29:42 <Cale> and that thing happens to be just right to define a monad :)
19:30:16 <luite> trap_exit: where do you add new things to the set?
19:30:18 <shachaf> johnw: You are +o
19:30:18 <Cale> JohnTalent: Make sense?
19:30:23 --- mode: johnw set -o johnw
19:30:43 <Fuuzetsu> johnw: nice, gotta remember that one
19:30:55 <JohnTalent> Cale: great. i am totally with you now.
19:31:05 <Cale> JohnTalent: We apply the given function to all the elements of the list, and then concatenate the results together
19:31:08 <Fuuzetsu> is being +o discouraged?
19:31:21 <hodapp> Fuuzetsu: on Freenode, yes, idle +o'ness is generally discouraged
19:31:21 <Cale> JohnTalent: and then for return, in general,  return :: a -> M a
19:31:34 <Cale> JohnTalent: and in this specific case, that means  return :: a -> [a]
19:31:35 <Fuuzetsu> oh, OK, by network rules yeah
19:31:47 <hodapp> one does not simply carry a ban-hammer openly
19:31:56 <JohnTalent> Cale: yes , thank you very much.
19:32:03 <Cale> JohnTalent: So, there might be a few things you could think of for such a function to do, but the simplest one is probably  return v = [v]
19:32:04 <trap_exit> luite: the obj has the following ops: add to front, add to end, remove elem; get list
19:32:08 <Cale> and that turns out to be the right one
19:33:15 <Cale> JohnTalent: Another example of a monad is the function monad, where we choose some type e, and let  M a = e -> a
19:33:18 <nickPapanastasio> So, does anyone here have experience with Happstack? I'm thinking about using it for my present project.
19:33:41 <stepkut> nickPapanastasio: I've got tons...
19:33:45 <Cale> JohnTalent: So then,  return :: a -> (e -> a),  and  (>>=) :: (e -> a) -> (a -> (e -> b)) -> (e -> b)
19:33:48 <luite> trap_exit: priority search queue and keep a min/max if they're not efficiently available from the implementation
19:34:10 <nickPapanastasio> :stepkut Wow, this is convenient.
19:34:14 <Cale> JohnTalent: While the type of bind there might be a bit of a mouthful at first, there's really only one sensible definition
19:34:43 <Cale> JohnTalent: The effect of this monad is that "running" a function means applying it to the value of type e to which the entire computation has been applied:
19:34:58 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
19:34:59 <lambdabot>  ("hello","olleh","HELLO")
19:35:06 <nickPapanastasio> :stepkut You're on of the guys on clckwrks, right?
19:35:17 <stepkut> nickPapanastasio: yes -- and happstack
19:35:38 <Cale> So "running" reverse means applying reverse to "hello" here, and y gets bound to "olleh", yeah?
19:35:59 <JohnTalent> Cale: id is verbatim i gather.
19:36:09 <Cale> id is the identity function:  id x = x
19:36:13 <JohnTalent> ah ok
19:36:36 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
19:36:37 <lambdabot>  [5,7,10,25,32]
19:36:56 <Cale> In this monad, sequence takes a list of functions, and combines them into a function which computes a list of the results
19:37:30 <stepkut> nickPapanastasio: I even gave a workshop on Happstack at ICFP one year (techincally, CUFP)
19:37:34 <Cale> Looking at the types, remember that we had
19:37:42 <Cale> sequence :: (Monad m) => [m a] -> m [a]
19:37:52 <Cale> So if  m t = e -> t
19:37:57 <nickPapanastasio> :stepkut Ooh, cool. Does there happen to be footage?
19:38:05 <Cale> We have  sequence :: [e -> a] -> e -> [a]
19:38:08 <JohnTalent> Cale: beautiful code!
19:38:08 <johnw> stepkut: when the next Chicago hackathon?
19:41:33 <Cale> JohnTalent: So, yeah, the real point is just to save code -- a lot of explanations of monads in other languages miss this point entirely. You really need to be able to write code like sequence and mapM/forM and filterM and so on which will work with any monad, before it's really worth talking about monads.
19:42:45 <Cale> I wrote a bit more about it here: http://www.haskell.org/haskellwiki/Monads_as_computation
19:42:48 <nickPapanastasio> :Cale But weren't monads introduced to handle IO purely?
19:42:54 <Cale> Not really
19:42:57 <ij> i would've thought (+1) == (+2) is computabl
19:42:59 <ij> e
19:43:05 <Cale> The IO type constructor *happens to be* a monad
19:43:25 <Cale> But the real innovation of Haskell's IO system is making IO actions values at all.
19:43:45 <Cale> We could have failed to realise that it's an example of a monad entirely
19:43:53 <Makoryu> nickPapanastasio: The IO type was introduced to handle IO. Monads were an additional discovery on top of it that made it easier to write nicer code
19:44:19 <Cale> Yeah, so we can take a bunch of code for control structures that build IO actions, and generalise them to work with libraries for other sorts of actions.
19:44:22 <Cale> Like parsers
19:44:23 <Makoryu> Even if we didn't have monads, the IO type would still work the way it does now
19:44:23 <Cale> or lists
19:45:34 <Cale> We'd probably even have some equivalent to return and (>>=) in the IO library, even if we didn't know about monads at all
19:46:11 <Cale> But even that's not *completely* necessary. There are other styles of fitting IO actions together
19:46:12 <johnw> like the way that C++ people rediscovered monadic structure in their threading proposal
19:46:13 <nickPapanastasio> The devs simply recognized the pattern then?
19:46:19 <Cale> nickPapanastasio: Yeah
19:46:41 <nickPapanastasio> :Cale That's awfully cool.
19:47:01 <JohnTalent> Cale: the purpose of monad is what?
19:47:03 <johnw> one example where Monads become important is when you're writing a library and you don't want to fix people on IO, but just "whatever side-effect capable scenario they want to execute my functions in".  In that case, coding over Monad m is just what you want to say, as it's the most general expression of the idea
19:47:57 <Cale> JohnTalent: To abstract out this pattern of some type constructor M, together with things of shape  a -> M a  and  M a -> (a -> M b) -> M b  (which actually have to satisfy some conditions I haven't mentioned)
19:48:11 <Cale> JohnTalent: and be able to write code that'll work with anything of that shape
19:48:19 <Cale> Like this sequence function
19:49:00 <Cale> The notion that we have some "type of computations with result of type t", that is, M t
19:49:20 <Cale> together with a way to get a computation which "does nothing" except to produce a given result   return :: a -> M a
19:50:01 <Cale> and a way to take a computation with a result of type a, and a function from possible results of that function, to computations for what to do next, and glue those together in the obvious way
19:50:15 <Cale> i.e. (>>=) :: M a -> (a -> M b) -> M b
19:50:21 <Cale> this pattern shows up a lot
19:50:30 <Cale> once you start programming in a functional way
19:50:50 <Cale> It even shows up in SICP, which is a course from the 70's where the implementation language is scheme
19:51:03 <Cale> They didn't notice the monad pattern
19:51:09 <Cale> But it was there in their code
19:51:31 <Cale> They didn't abstract over it, so they didn't get to take advantage of things like sequence and liftM2 and whatnot
19:51:49 <Cale> But in Haskell, that's what we tend to do when we notice this pattern
19:52:12 <Cale> So we don't have to write the same sequence function in every such library
19:52:20 <Cale> We just have one in Control.Monad
19:52:51 <original_brogram> Now, it's my understanding that all monads are by definition also functors. Why is this  not reflected in their implementation in Haskell?
19:53:03 <original_brogram> seemingly not*
19:53:05 <johnw> Conal Elliott's recent presentation on Denotational Design gives an example of evolving a functional interafce, and then abstracting over things like Applicative and Monad, and how much of the standard library you get to take advantage of for freeing by doing so
19:53:10 <Cale> original_brogram: Historical reasons, not really any good reason.
19:53:14 <johnw> original_brogram: it will be in GHC 7.30
19:53:16 <johnw> 7.10
19:53:16 <kazagistar> ij: equality of arbitrary expressions is not computable... it might be doable at compile time, but (==) demands that equality be well defined at runtime for any instance of the typeclass parameter "a"
19:53:20 <Cale> original_brogram: Also, yeah, it's changing :)
19:53:24 <Cale> FINALLY
19:53:43 <Cale> AFTER LIKE 12 YEARS OF EVERYONE AGREEING THAT IT SHOULD CHANGE
19:53:52 <original_brogram> I FEEL SO SMART RIGHT NOW
19:53:56 <johnw> hahaha
19:55:23 <original_brogram> So now it will be something like class (Functor m) => Monad m where ... ?
19:55:37 <shergill> why does asking ghci the type of 'id id id id id id ... id' return almost instantaneously, but evaluating 'let foo = <same expr>' takes much longer?
19:55:46 <nolan_d> If I have some questions and want to paste code, but the code requires various packages to compile, what's the best way to do that so the example is runnable?
19:55:49 <shergill> s/takes/take/
19:55:52 <kazagistar> do you actually have to write instances for Functor if I have one for Monad?
19:56:11 <johnw> kazagistar: you almost never have to write instances for Functor, if you use the DeriveFunctor extension
19:56:20 <johnw> but no, writing one for Monad does not give you Functor for free
19:56:25 <Cale> original_brogram: Yeah, actually I believe they'll be adding Applicative in between
19:56:35 <Cale> You can always just write:
19:56:37 <johnw> even though it gives you nough to be able to implement fmap in terms of >>= and return
19:56:43 <original_brogram> Ah, that makes more sense.
19:56:44 <Cale> instance Functor MyMonad where fmap = liftM
19:56:54 <johnw> or liftM....
19:56:56 <johnw> :)
19:57:01 <kazagistar> johnw: applicative then...
19:57:01 <nolan_d> I'm trying hard to learn and like Haskell, only I'm banging my head on some problems that require a .hs file + dependencies, and it'd be great if I could send a fully compilable example of one file + dependencies and have help debugging it. :)
19:57:09 <johnw> applicative can't be auto-generated
19:57:14 <johnw> but you can say pure = return; (<*>) = ap
19:57:15 <johnw> i do that a lot
19:57:22 <benzrf> yeah that's because (>>=) *IS* fmap (followed by join)
19:57:33 <Fuuzetsu> nolan_d: just put up a repository somewhere with a cabal file
19:57:38 <benzrf> you can implement Functor from Monad because Functor has been artificially stitched onto Monad
19:57:39 <aarvar> It would be nice if there was a mechanism for having default super instances
19:57:55 <slack1256> nolan_d: try fpcomplete web IDE It will tell you errors while you are making it. Plus the dependencies will be a solved problem.
19:58:01 <Cale> nolan_d: If you do something like make a github repo, or even just paste all the files on lpaste.net, I'm sure we can have a look
19:58:12 <nolan_d> Ah, guess so. Thanks.
19:58:40 <Cale> aarvar: Yeah, there have been a lot of such proposals throughout the years
19:58:47 <kazagistar> original_brogram: they are also adding Applicative m => MonadPlus m, if I am not mistaken
19:58:58 <slack1256> I remember there was a problem on implementing backpack and typeclasses, anybody remembers a blogpost about it?
19:59:04 <Cale> kazagistar: Uh, that won't be required
19:59:20 <Cale> kazagistar: There's already a Monad m constraint on MonadPlus m
19:59:27 <slack1256> Aplicative m => Monad M => MonadPlus m
19:59:28 <original_brogram> :Cale Since Monad m => MonadPlus m ?
19:59:37 <kazagistar> Cale: shit, I meant Alternative, sorry :P
19:59:43 <Cale> Oh, interesting
19:59:52 <shergill> can ghci compilation be profiled?
20:00:02 <Cale> Not even sure I agree with that one, but I guess it makes some sense
20:00:28 <shergill> i'm trying to figure out why asking ghci the type of 'id id id id id id ... id' returns almost instantaneously, but evaluating 'let foo = <same expr>' takes quite a while
20:00:35 <slack1256> shergill: check out in ghci :? . also notice the set +s.
20:00:45 <Cale> shergill: hmm, well, it is a GHC-compiled program, so it should be possible
20:00:51 <Cale> I have no experience doing that
20:00:53 <slack1256> it not full blown profiling as -prof -auto-all but it's something.
20:01:05 <Cale> slack1256: I think he wants to profile the operation of ghci itself?
20:01:19 <slack1256> Oohh
20:01:27 <johnw> slack1256: nowadays I think -prof -fprof-auto is preferred
20:01:32 <Cale> shergill asked a question just before about why ghci was taking a long time on a certain expression
20:01:40 <JohnTalent> Cale: in sequence [id,(+2), (*2), (^2), (2^)] 5   is [] the m in [m a] -> m [a] ?
20:01:41 <luite> Cale: hmm, i'm not sure, template haskell is disabled when ghc has been compiled with profiling, that uses more or less the same machinery
20:01:45 <shergill> Cale: hmm k
20:02:06 <slack1256> johnw: I am getting rusty :-)
20:02:10 <orzo> i've written a wrapper on Data.IntMap that enables the use of arbitrary key types k that satisfy Coercible k Int.  Only, i'm not quite finished and I'm not sure I want to finish if nobody else wants that.  Does anybody want an IntMap that doesn't use Int as key?
20:03:01 <slack1256> orzo: Could you tell us about what led to develop such wrapper? Maybe that can show its usefulness
20:03:26 <orion> Is there a function available which will wait on a ThreadId to die?
20:03:34 <slack1256> I remember there was a problem on implementing backpack and typeclasses, anybody remembers a blogpost about it?
20:03:39 <slack1256> orion: check the async package
20:03:41 <Cale> JohnTalent: nope
20:03:42 <aarvar> :t [id,(+2), (*2), (^2), (2^)]
20:03:43 <lambdabot> Integral a => [a -> a]
20:03:53 <Cale> JohnTalent: There, we have m t = e -> t
20:04:10 <Cale> JohnTalent: Or, written in curried form, m = (->) e
20:05:27 <orzo> slack1256: well, i'm intending to use multiple IntMaps in my application, some of which are so closely related in form and function that it would be easy to get them mixed up.  I figured with the wrapper, i'd have some assurance i don't feed keys to the wrong maps.
20:06:12 <Cale> (So, when you write this instance of Monad, you write   instance Monad ((->) e) where return v x = v; (f >>= g) x = g (f x) x
20:06:15 <Cale> )
20:06:50 <orzo> i'm trying to implement an algorithm called SybilLimit, there's a paper out there if you google
20:06:53 <dmj`> orion: forkFinally will run a function after a thread dies
20:06:59 <dmj`> orion: or returns
20:07:13 <Cale> JohnTalent: If that seems a little strange, well, it's a bit of a strange instance of Monad, people don't really use it so much, but I like it for IRC discussions because it's one of the examples which doesn't take so much space to write down.
20:07:42 <orion> dmj`: good point
20:08:10 <Cale> JohnTalent: So, in general, sequence :: (Monad m) => [m a] -> m [a]
20:08:26 <Cale> JohnTalent: and if m a = e -> a, then the type becomes  [e -> a] -> e -> [a]
20:08:32 <orzo> wouldn't IntMap have allowed different key types originally if the Coercible infrastructure existed?
20:09:25 <Cale> JohnTalent: So it's taking a list of functions of type e -> a, as well as an argument of type e, and it's producing a list of results of type a
20:09:39 <Cale> JohnTalent: and there's only one really sensible thing that such a function could be doing
20:09:44 <slack1256> Well if you wanted to use different keys you could use directly Maps
20:10:01 <orzo> slack1256: well, my keys are all newtypes of Int
20:10:16 <JohnTalent> Cale: why isn't that reflected in the first type with (Monad m).. you mentioned?
20:10:27 <slack1256> AFAIK IntMap only exists because there are some bitwise trickery avaible for Int and the balancing of the tree.
20:10:28 <orzo> slack1256: wouldn't i incur a penalty switching to Map ?
20:10:43 <Cale> JohnTalent: Well, the m in the first type is a type variable which you can plug any monad in for
20:10:52 <slack1256> depend if you can afford it to the problem.
20:10:59 <Cale> JohnTalent: So, the type of sequence also specialises to  [IO a] -> IO [a]
20:11:09 <Cale> JohnTalent: and [[a]] -> [[a]] (the list monad case)
20:11:16 <Cale> JohnTalent: and [Maybe a] -> Maybe [a]
20:11:26 <Cale> > sequence [Just 1, Just 2, Just 3]
20:11:27 <lambdabot>  Just [1,2,3]
20:11:34 <Cale> > sequence [Just 1, Just 2, Nothing]
20:11:35 <lambdabot>  Nothing
20:11:53 <orzo> it'd be nice if haskell could use IntMap trickery seemless without us having to be aware whenever the compiler determines the key is really an Int
20:11:55 <Cale> > sequence [[1,2],[3],[4,5,6]]
20:11:57 <lambdabot>  can't find file: L.hs
20:11:58 <JohnTalent> ok , so i need to cd Monad. :)
20:11:59 <Cale> ...
20:12:00 <Cale> > sequence [[1,2],[3],[4,5,6]]
20:12:02 <lambdabot>  [[1,3,4],[1,3,5],[1,3,6],[2,3,4],[2,3,5],[2,3,6]]
20:12:29 <solatis> ok, i'm getting more and more demotivated... i'm doing haskell fulltime for about 2 weeks now, and i still have no idea wtf i'm doing
20:12:42 <solatis> it seems i'm just on infinite trial-and-error mode
20:12:48 <AshyIsMe> is the haddock markup described here incorrect?  http://www.haskell.org/haddock/doc/html/ch03s08.html
20:12:50 <Cale> solatis: It took me about 2 months before I felt like I could do useful things
20:12:51 <solatis> without understanding what i'm doing
20:12:55 <AshyIsMe> i can't get the headings or bold to work
20:13:05 <solatis> Cale: yeah i'm used to picking up languages easily
20:13:09 <Cale> solatis: and about a year to really be comfortable
20:13:10 <AshyIsMe> in a module level comment
20:13:20 <Cale> solatis: I was the same, at the time I started learning Haskell.
20:13:35 <Cale> solatis: It's probably quite different from most of the languages you're likely to know
20:13:46 <Cale> solatis: So you have to treat it a bit more like it's your first programming language
20:13:49 <kazagistar> solatis: have you tried using a book like LYAH? Haskell requires slightly different thinking, so it took me longer then usual to pick up.
20:14:12 <solatis> kazagistar: yeah
20:14:16 <AshyIsMe> solatis: i think the trick is to just write simple little projects without worrying about doing things the right way
20:14:20 <AshyIsMe> im still at that level too
20:14:21 <orzo> slack1256: so can i take your opinion as a vote for the wrapper being useless?
20:14:23 <merijn> solatis: To add to Cale's remarks, I didn't "get" haskell until my 3rd or 4th attempt at learning it and it probably took at least 6 months after that before I really started to become comfortable writing code
20:14:34 <solatis> k
20:14:39 <solatis> i have a sabbatical year this year
20:14:39 <AshyIsMe> despite being a fulltime developer for nearly a decade haskell still does my head in a bit
20:14:52 <solatis> i decided to learn haskell this year
20:14:59 <orzo> why
20:15:03 <Cale> After about 12 years or so, Haskell is finally starting to get a little boring for me
20:15:05 <orzo> is haskell booming?
20:15:08 <merijn> orzo: Why not? :p
20:15:10 <stepkut> johnw: sometime after burning man
20:15:17 <slack1256> orzo: I wouldn't say that, it just need a better use case.
20:15:26 <splintax> orzo: isn't this the biggest language channel on freenode? :)
20:15:26 <merijn> orzo: Has been for the past few years
20:15:56 <solatis> i have the feeling that learning haskell, because it is so completely different, will change the way i approach programming problems in other languages too
20:16:18 <kazagistar> solatis: its a challenge to learn, but it gave me a lot more then learning just another OOP/imperative language. Feel free to ask any questions here, and we will try to help
20:16:36 <solatis> yeah i know, this #haskell community is really great
20:16:48 <solatis> i'm so glad people actually help other people here, for a change :)
20:17:54 <orzo> the ops remind us to be non-evil whenever we stray
20:18:03 <slack1256> yep
20:18:12 <solatis> yeah, but that can be interpreted in many ways
20:18:17 <Cale> solatis: Yeah, eventually it will make most other languages intolerable because you'll see how horribly unsafe and at the same time verbose everything else tends to be by comparison.
20:18:34 <flebron> I removed ~/.ghc and ~/.cabal. I don't care, I want everything gone and to start afresh, this is a clusterfuck (as Cabal always ends up.) Yet cabal still complains about some reinstalls and breaking things. Is there some other place packages could be hiding?
20:18:48 <flebron> I really, really just want to kill everything and start over. I have work to do and this is not letting me do it.
20:19:18 <orzo> do you use debian by any chance, flebron?
20:19:19 <Cale> solatis: That's a slightly overstated boast, but it's kind of true as well.
20:19:22 <flebron> Gentoo.
20:19:29 <splintax> flebron: sandboxes? ./.cabal-sandbox
20:19:33 <flebron> Already asked in #gentoo-haskell, nobody answered.
20:19:36 <kazagistar> flebron: I think there are system level places to store that information as well?
20:19:49 <aarvar> while you're killing everything, why not nix your os for nixos
20:19:59 <flebron> Any idea where they could be? I'm about to strace cabal to see what it's reading.
20:20:03 <solatis> ah, linux distribution religion
20:20:09 <flebron> aarvar: I meant everything related to Cabal.
20:20:10 <estulticia> linux sucks
20:20:18 <kazagistar> programming is terrible
20:20:21 <kazagistar> computers are terrible
20:20:29 <flebron> splintax: There doesn't seem to be any -sandbox, no.
20:20:37 <Cale> estulticia: It's just that everything else sucks too :(
20:20:47 <orzo> i've got a system worked out for myself where all my haskell packages are known to the os package manager, debian testing/sid has an excelent tool for debianizing any cabal package
20:21:07 <merijn> solatis: I actually think one of the biggest problems many new haskellers run into when trying to write "real world" code is that there's a lot more code reuse in haskell than most other languages I've programmed in. The result is that understanding said "real world" code not only requires you to know haskell, but also know the most common libraries (like transformers, Control.Applicative, mtl and a bunch more) and recent additi
20:21:34 <slack1256> merijn: Isn't that true for any language?
20:21:42 <flebron> If anyone has any ideas, I'm all ears. If it comes to that, yes, I'm hosing the entire goddamned OS, but I would have to back a lot of things up, since it's my work machine.
20:21:45 <estulticia> Cale: some more, some less
20:21:58 <Cale> merijn: In case you wrote much more, your line got cut off at "recent addit"
20:22:06 <flebron> It really should not be the case that I need to remove my operating system to fix Cabal.
20:22:21 <solatis> merijn: i'm a fairly experienced c++ programmer. i can confirm that problem is there with c++ too, maybe even more so
20:22:29 <splintax> flebron: have you uninstalled all haskell-related packages from your package manager?
20:22:37 <solatis> it's just that haskell and c++ (and others) are very "expert-friendly" languages
20:22:43 <flebron> I don't think so, no. Some things are only in cabal.
20:22:43 <gp5st1> is there a way to have a type say "floating pt between 4.0 and 6.0" and then ensure that a conditional or pattern matching statement(s) would handle all values in that range? does that make any sense?
20:22:49 <kazagistar> flebron: " If you install a package globally, the local packages are ignored. " <- could this be the problem?
20:22:50 <splintax> flebron: not that you should have to do that, rm -rf ~/.ghc ~/.cabal has always worked for me
20:22:55 <merijn> continued: recent additions to the landscape like lens, pipes and conduit are also attracting a lot of attention
20:23:05 <flebron> kazagistar: What does "globally" mean? Is there something other than ~/.ghc?
20:23:16 <merijn> slack1256: Do you know any libraries that are as universally useful as, say, lens in python, javascript, ruby, etc.?
20:23:18 <Cale> estulticia: I suppose it's mostly that many of the things which suck about Windows and MacOS X are things which I have no control over at all, and at least in Linux, when something bothers me *enough*, then I have some recourse.
20:23:22 <solatis> merijn: yeah. last week (my second week of haskell) i decided to dive intro cloud haskell. boy that was a mistake. :)
20:23:34 <slack1256> merijn: I only know haskell as a language, so I couldn't tell.
20:23:37 <orzo> flebron: iduno about gentoo, but debian has packages not installed in ~
20:23:39 <kazagistar> flebron: yes, I don't remember where, but I ran into it once
20:23:46 <slack1256> Well I know some of college level C but that is.
20:24:11 <orzo> /usr/lib/haskell-packages/ghc/lib
20:24:21 <slack1256> gp5st1: That is called reifiying a type, that can be done with Liquid haskell
20:24:30 <merijn> solatis: There's two schools of thought about haskell learning: 1) stick with toys to get comfortable with various abstractions and slowly expand your toolbox until you feel ready to tackle "real world" code (noting that this can take months)
20:24:51 <merijn> solatis: 2) dive into real world code as fast as possible
20:24:59 <solatis> merijn: i am definitely #2
20:25:00 <aarvar> Er, don't those schools of thought exist for everything?
20:25:08 <orzo> what's "real world" code
20:25:12 <orzo> heh
20:25:12 <merijn> solatis: I personally am in favour of the first 1, but they have their own trade-offs
20:25:16 <Cale> #1 is pretty much what I did, but the idea of "real world" Haskell code was a joke at that time
20:25:18 <solatis> the way i'm currently learning is, funny enough, searching github
20:25:31 <Cale> (I learned Haskell back around 2001-2002 or so)
20:25:34 <orzo> hackage/cabal should have a flag Toy/RealWorld so we know.
20:25:35 <solatis> just search for code that uses constructs i have problems with
20:25:38 <solatis> and try to understand that code
20:25:38 <merijn> orzo: Robust code that needs to interface with the network, filesystem, etc. and not crash
20:25:56 <merijn> solatis: The problem with the former is that you feel useless, not being able to write real programs in haskell
20:25:57 <Cale> solatis: That's an interesting approach
20:26:04 <gp5st1> slack1256: thanks:)
20:26:07 <orzo> merijn: and that wont be radically and incompatibly changed in the next release?
20:26:08 <Cale> solatis: Also, don't be afraid to ask lots of questions here
20:26:15 <aarvar> cabal should let you add avoidSuccess = true
20:26:20 <merijn> solatis: The problem with the second is that you can get so lost in "incidental" complexity of real world code that you give up
20:26:30 <slack1256> gp5st1: You're welcome.
20:26:34 <solatis> merijn: that's why i'm demotivated right now.
20:26:39 <merijn> orzo: If you have "releases" you're already real world code
20:26:41 <solatis> merijn: but it's just temporarily. :)
20:26:47 <kazagistar> flebron: look for where gentoo installs packages from cabal, that is probably the global package store
20:26:56 <solidus-river> i have an arrow question
20:27:00 <orzo> merijn: so everything on hackage?
20:27:02 <merijn> solatis: For "practical" haskell, have you looked at Write Yourself a Scheme in 48 Hours?
20:27:17 <merijn> orzo: It's not a binary property, more a fuzzy gradient :)
20:27:27 <flebron> I'm not seeing a place, but I'll keep looking, kazagistar.
20:27:31 <Cale> solatis: If there's any sort of construction you'd like to understand better, I'd be happy to try to explain :)
20:27:36 <solidus-river> i have an arrow that takes (a, b)
20:27:41 <merijn> orzo: Clearly there's a difference between fbonacci one-liners and working curl implementation, for example
20:27:42 <solidus-river> and an arrow that produces a
20:27:42 <flebron> (I've been blocked fighting with Cabal for hours. Next time, I'm using Python. :|)
20:27:45 <solidus-river> and a static b
20:28:00 <merijn> flebron: Block in what way?
20:28:05 <solidus-river> how do i add the b into the.. blah, i'll just use arrow notation
20:28:19 <Cale> solidus-river: f >>> arr (\a -> (a,b)) >>> g
20:28:25 <flebron> Tried to use criterion. cabal-installed criterion. HFlags is now gone. I needed hflags. I can't seem to get it back.
20:28:26 <solatis> Cale: i know, but the problem is often that you do not know what you're looking for / how to formulate the question
20:28:42 <merijn> flebron: Define "gone"
20:28:46 <flebron> This beautiful error message. http://pastebin.com/4DaBQx7N
20:28:47 <Cale> solatis: Yeah, that's a tricky place to be in :)
20:29:17 <Cale> flebron: uh oh
20:29:32 <solidus-river> Cale: thanks :)
20:29:37 <orzo> heh, nice lambda bash prompt
20:29:37 <solatis> Cale: but it will be alright. i am arrogant enough to consider myself good enough a coder to be able to master the concepts. i think what i'm running into right now is my lack of math knowledge
20:29:50 <Cale> solatis: *Maybe* :)
20:29:56 <flebron> By the time I got to "bf61a4658ec6a658842180669370b43a", I also thought "uh oh."
20:29:59 <merijn> flebron: Did you --force-reinstall anything?
20:29:59 <naudiz> hey, I'd like to deal with a number in a context for calculating with units (Mass, Velocity, Distance, etc.), so I tried `newtype Mass = Mass Double` but I ended up redefining all the operations that were already defined on Double... is there a way to just use all the implementations of Double in a context of a Unit without redefining all those operations?
20:30:23 <flebron> merijn: Perhaps? I had some issues a while back and followed some advice on #gentoo-haskell which may have involved both that and haskell-updater.
20:30:24 <solidus-river> Cale: is writing it that way any better than writing it via arrow notation from a performance standpoint, they should boil down to the same description of coding
20:30:51 <Cale> solidus-river: They should be about the same, the 'arr' is going to mess things up regardless.
20:30:52 <solidus-river> solatis: what part are you looking to get a grasp on?
20:30:55 <flebron> merijn: If I did, is there any way to nuke everything Cabal-related from orbit and just start again? I don't mind. Really. I don't really like any of the packages in Hackage, even my own. They can all go away.
20:30:57 <merijn> flebron: Oh, gentoo/linux package managers have a history of manually editing cabal meta-data files and hosing things
20:30:59 <tesetacc> solatis: it's more-so about your ability to read and understand type-signatures, how comfortable are you with type classes?
20:31:09 <flebron> Oh goodie.
20:31:24 <merijn> flebron: The golden rule is generally to never use linux package managers for installing libraries
20:31:29 <merijn> @where sicp
20:31:29 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml -- "Storage and Identification of Cabalized Packages"
20:31:29 <solatis> tesetacc: i believe they're the same as c++ concepts, right?
20:31:42 <Cale> solidus-river: This is one of those uses of 'arr' which gets in the way of doing fancy things when running your arrow, because by that point you don't know that the function is so trivial, it's a black box
20:31:45 <merijn> flebron: See that last vex.net link for an explanation of the problem and how it can be avoided
20:31:50 <aarvar> nixos nixos nixos
20:32:00 <orzo> merijn: you have to if you want to write an app that you intend to package for your os
20:32:05 <merijn> flebron: And in general --force-reinstall is very likely to break lots of things
20:32:27 <Cale> flebron: rm -r ~/.ghc
20:32:28 <merijn> orzo: Then follow the instructions at the end of that vex.net link
20:32:30 <solatis> tesetacc: i have a LOT of experience with c++ meta-programming, and 'concepts' are a feature that i think are exactly the same as haskell type classes
20:32:32 <flebron> Good to know :p As a last measure, I'm asking Portage (the Gentoo package manager) to reinstall the packages.
20:32:41 <flebron> Cale: That's done, as well as .cabal, there still are packages it seems.
20:32:57 <Cale> flebron: ~/.cabal/config you sometimes might want to keep
20:33:13 <Cale> also ~/.cabal/bin where cabal-install is usually
20:33:16 <tesetacc> solatis: conceptually they are similar to interfaces yea, how comfortable are you with kinds?
20:33:18 <flebron> Cale: I reeeeeeeeeeeally don't care. Anything with a prefix of [cC]abal can just die in a fire, as far as I'm concerned.
20:33:31 <merijn> flebron: Basically, read the unsafeInterleaveInstall section in that link
20:33:32 <Cale> flebron: It's never really necessary to blow away anything under ~/.cabal
20:33:39 <Cale> flebron: ~/.ghc will be enough
20:33:44 <merijn> flebron: Although the rest is pretty good to know to avoid future disasters
20:34:00 <Cale> flebron: the stuff under ~/.cabal you might want to tidy up just to save space, but it won't hurt anything sitting there
20:34:02 <Fuuzetsu> flebron: I just replaced the my remaining Gentoo box with NixOS, *hint* *hint*
20:34:35 <solatis> tesetacc: i do not know what you mean with interfaces. c++ concepts define compile-time meta-constructs for things like, something is 'Iterable', or 'ForwardIterable', etc
20:34:37 <Luke> what's the suggested way to read 2 bytes from Attoparsec ByteString into a Word16?
20:34:43 <Cale> solatis: Yeah, concepts were directly inspired by type classes
20:34:50 <solatis> exactly
20:34:53 <Luke> googling only seems to turn up Char8 String -> Word16
20:34:57 <Luke> using read
20:35:01 <merijn> flebron: tbh, people give cabal a bad rep, but most of the times I hear about cabal issues there's one of three things going on: 1) linux distro botched the database or 2) people tried --force-reinstalls or 3) people are trying to install the bleeding edge even though the stuff they want to use doesn't support it yet
20:35:09 <johnw> Luke: I think you need to peel off two Word8s and shift one up
20:35:13 <merijn> johnw: No
20:35:21 <JohnTalent> Cale: for sequence::(Monad m) = [m a] -> m [a]. Can I type :t [m a] and it will should e->a?
20:35:29 <merijn> johnw: attoparsec has support for words, afaik
20:35:32 <flebron> merijn: Even so, cabal shouldn't leave me in a state of "Yep, nothing works. Not even your old code."
20:35:43 <johnw> oh?  ah, I missed the Attoparsec part
20:35:43 <Luke> merijn: i wasn't able to find it
20:35:45 <flebron> It's incredibly frustrating to even start to fix.
20:35:48 <tesetacc> solatis: I wasn't referring to C++, but to the concept of an interface, found in langauges like java
20:35:54 <solatis> ah yes
20:36:02 <Cale> JohnTalent: uh, you can't... when I said that m a = e -> a, I was giving an example of how we might plug in a specific m
20:36:14 <kazagistar> flebron: delete ~/.cabal, then ask for the packages, then search for them? might be worth a try
20:36:17 <solatis> i think typeclasses are a bit different than interfaces tho
20:36:20 <benzrf> sequenceA > sequence
20:36:24 <solatis> typeclasses are more 'free-form'
20:36:28 <solatis> interfaces are more OOP
20:36:31 <merijn> flebron: Well, the first one cabal can't warn about, because it's linux package managers editing metadata without consulting cabal, the 2nd cabal warns about with "this will break shit"
20:36:46 <flebron> kazagistar: I delete both .cabal and .ghc, and cabal still says there's conflicts when saying cabal install criterion.
20:36:46 <JohnTalent> Cale: isn't that misrepresention then?
20:36:51 <Cale> JohnTalent: What you *can* do is make the substitution yourself and see that the typechecker accepts it:
20:36:55 <Cale> :t sequence
20:36:56 <lambdabot> Monad m => [m a] -> m [a]
20:36:58 <orzo> flebron: didn't you say you deleted .cabal and .ghc already?  And it's saying hflags is already installed?  That seems fishy to me
20:37:02 <Cale> :t sequence :: [e -> a] -> e -> [a]
20:37:03 <lambdabot> [e -> a] -> e -> [a]
20:37:06 <Luke> merijn: would you midn pointing me at the word16 parsing you're referencing?
20:37:07 <flebron> orzo: Indeed :(
20:37:16 <merijn> Luke: Oh, you'll want attoparsec-binary
20:37:16 <Cale> :t sequence :: [IO a] -> IO [a]
20:37:17 <lambdabot> [IO a] -> IO [a]
20:37:23 <Luke> merijn: aaah ok thanks
20:37:26 <merijn> Luke: It's a library that has the functions I'm thinking off
20:37:28 <orzo> flebron: check for goofy environment variables, grep them for CABAL, heh
20:37:32 <kazagistar> flebron: right, because a global package is conflicting, so the goal is to find where that global package is by searching under /usr/share/ or something
20:37:32 <Cale> JohnTalent: It's polymorphic, its type specialises to all these things
20:37:35 <glguy_> Paste the output of "ghc-pkg list"
20:37:38 <merijn> Luke: "anyWord16le :: Parser Word16", etc.
20:37:41 <Luke> merijn: I didn't think to look outside the library
20:37:43 <Luke> perfect!
20:37:45 <Luke> thank you
20:37:47 <glguy_> You probably installed something globally
20:37:52 <Cale> JohnTalent: just like the type of length, which is [a] -> Int will specialise to [Int] -> Int and [Char] -> Int
20:38:01 <flebron> glguy_: Aha! There's a /usr/lib64/ghc-7.6.3/package.conf.d
20:38:14 <JohnTalent> so you have go guess to check?
20:38:14 <flebron> That entire directory is getting the good ol' rm -rf treatment.
20:38:19 <glguy_> Don't go that
20:38:21 <glguy_> No no
20:38:23 <glguy_> Bad
20:38:29 <Cale> JohnTalent: Well, you can look at what instances of Monad are around
20:38:32 <flebron> I want it do die. Painfully, if I can.
20:38:34 <orzo> flebron: doesnt gentoo let you remove that in some better way than rm -rf ?
20:38:35 <kazagistar> solatis: typeclasses let you specify all three separately... abstraction in one file, datatype in another, and the implementation in a third, compiled separately
20:38:40 <glguy_> You'll have to start over reinstalling ghc
20:38:42 <solatis> *anyway*. just to make it clear: the helpfulness of the #haskell channel is a serious motivation to keep going. it gives me a feeling i'm not 'alone in the dark' when learning haskell. so just a big thank you all :)
20:39:01 <orzo> flebron: portage remove or something?
20:39:04 <Cale> JohnTalent: If you type  :info Monad  in ghci, you should see a bunch of lines like:
20:39:07 <solatis> and now i'm back to actual coding again
20:39:09 <flebron> glguy_: Is there a better way? My error message seems to say "Everything everywhere is hosed." http://pastebin.com/4DaBQx7N
20:39:11 <Cale> instance Monad IO -- Defined in ‘GHC.Base’
20:39:15 <Luke> merijn: looks like it does what johnw was suggesting. just peels off the word8s and shifts
20:39:16 <nisstyre> solatis: it took me 4-5 months to start understanding Haskell
20:39:17 <flebron> orzo: I don't even know what I'd need to remove!
20:39:33 <nisstyre> solatis: that isn't meant to demotivate you but to show that everyone has trouble with new things
20:39:36 <Cale> JohnTalent: This means that IO is a valid substitute for 'm' whenever you have to satisfy a (Monad m) constraint
20:39:58 <orzo> flebron: debian puts "ghc" or "haskell" in every single haskell package name.  If portage will list installed packages, just grep for those, they maybe probably follow the same convention
20:40:08 <glguy_> Wow, I see that you've been busy:)
20:40:12 <Cale> JohnTalent: Depending on which modules you have imported, that list might be longer or shorter
20:40:21 <solatis> nisstyre: yeah, and everyone is different. i'm the type of person who learns by example. other people like to read a lot up front and slowly extend their knowledge.
20:40:26 <solatis> whatever floats you boat, i would say
20:40:36 <orzo> flebron: debian also has dpkg -S to identify what package owns a file, gentoo might have an equivelent to that
20:40:38 <Cale> (well, not usually shorter than what you get when you just started ghci)
20:40:39 <nisstyre> solatis: it might've also been that I started with Real World Haskell
20:40:44 <nisstyre> and nothing else pretty much
20:41:04 <nisstyre> and had no real experience with functional programming or types in general
20:41:08 <solidus-river> Cale: aye, my road down arrow lane has been interesting, i'm kinda curoiuse what quick check is going to look like for arrows
20:42:15 <kazagistar> flebron: you really need to just find the global install directory, probably somewhere under /usr/local
20:42:28 <Cale> solidus-river: Arrow is a little bit of a broken abstraction. It's very close to being something quite useful and important, but it's not quite there as it stands. At some point, I should get together with Ryan Trinkle and a few other people and make a grand proposal to fix it.
20:42:30 <flebron> kazagistar: It seems I already did, /usr/lib64/ghc-7.6.3/package.conf.d.
20:42:38 <flebron> But glguy_ says I shouldn't just rm -rf it.
20:42:52 <JohnTalent> Cale: ok thank you.
20:42:57 <glguy_> You can delete it if you're ready to reinstall everything
20:43:05 <glguy_> It won't break your computer
20:43:12 <flebron> I see no other option, given that the error messages are totally inscrutable.
20:43:39 <orzo> flebron: equery belongs /usr/lib64/ghc-7.6.3/package.conf.d
20:43:45 <kazagistar> flebron: this is a OSX specific thread, but it might help http://stackoverflow.com/a/7543342/2895784
20:44:11 <Cale> solidus-river: Well, there are instances of Arrow which work well enough as it stands, but the design of the library prevents it from being useful for a lot of the niche of libraries which would prefer something like that to the whole Functor/Applicative/Monad sort of design.
20:44:24 <dolio> cabal doesn't global install to /usr/lib64 unless you set it up to do that.
20:44:52 <flebron> For example, the -v says package Agda is broken because of recursive or missing packages, and gives a list of packages. I try to install every single one, and cabal says they're already installed.
20:45:00 <orzo> portage did it, he just has to remove the right package name, and he should be able to find that with equery belongs based on my google
20:45:02 <original_brogram> Cale: What's so broken about Arrow?
20:45:02 <flebron> So this gives me no info on either what the problem is, or how to solve it.
20:45:25 <glguy_> package text-1.1.1.3-bf61a4658ec6a658842180669370b43a is shadowed by package text-1.1.1.3-d5b44bf17f6c5ecc7287fc7abc49734f
20:45:39 <flebron> How does the same package have different signatures...
20:45:48 <nitrix> Hey guys. I'm making lot of progress with Haskell. I understand more and more advanced concepts, but while I'm able to connect the dots and understand what I'm learning, I'm very bad with names. I'd like to know if Haskell had a specification document that is concise enough to present the different elements of the language and consistently name them the same thing so that I know how to refer to them?
20:45:50 <glguy_> It tells you exactly why each package's broken
20:46:04 <nitrix> E.g. type constructors, etc.
20:46:05 <glguy_> You can unregister all the broken packages
20:46:14 <Cale> original_brogram: It relies too heavily on arr to provide basic operations for, e.g. re-associating and swapping tuples, which tend to come up when wiring together arrow computations (and definitely show up in between every pair of lines when you use arrow notation)
20:46:15 <merijn> original_brogram: The requirement that any function can be converted to an arrow
20:46:28 <flebron> glguy_: Do I have to do that manually? There's dozens of them!
20:46:28 <original_brogram> nitrix: You're looking for the Haskell Report!
20:46:42 <Cale> arr itself isn't such a big deal (though it definitely should be in its own type class)
20:46:46 <glguy_> And it's broken because you or you via you package manager ripped then away
20:46:52 <merijn> nitrix: Google "Haskell 2010 Report"
20:46:53 <nitrix> original_brogram: Report made it sound like a long article rather than a formal document. Link?
20:47:07 <nitrix> merijn: Alright, will do. Appreciated!
20:47:10 <merijn> nitrix: I found the report very readable, for a language standard
20:47:13 <flebron> glguy_: So the solution is? Unregistering which packages? I don't think I should unregister text, should I?
20:47:26 <glguy_> Text s fine to unregister
20:47:29 <original_brogram> http://www.haskell.org/definition/haskell2010.pdf In all its glory
20:47:31 <merijn> nitrix: 100 times more readable than, say, the C standard :)
20:47:41 <nitrix> merijn: I quote you literally anything from the C standard.
20:47:44 <flebron> OK, I'll start unregistering everything there...
20:47:46 <glguy_> You can reinstall text later
20:47:48 <orzo> i havent read the report since the 98 edition
20:47:53 <merijn> nitrix: Also
20:47:56 <merijn> @where cheatsheet
20:47:56 <lambdabot> http://blog.codeslower.com/static/CheatSheet.pdf
20:48:03 <Cale> original_brogram: One of the main things which makes Arrow attractive as an abstraction is that whereas with Monad, every time that x >>= f shows up, the 'f' is a black box which you can't inspect ahead of time in any way but to apply it...
20:48:18 <nitrix> Erf, no HTML version?
20:48:26 <nitrix> What's up with PDFs... really...
20:48:33 <original_brogram> :Cale whereas with Arrow F is more transparent?
20:48:35 <merijn> nitrix: No, but it is a very comprehensive cheatsheet, so still worthwhile
20:48:37 <Cale> original_brogram: In Arrow, all the combining operations take arguments of a type that you control, in particular (>>>)
20:49:02 <Cale> original_brogram: So, you might hope to be able to analyse your computations a bit better before running them
20:49:09 <flebron> glguy_: ghc-pkg unregister text tells me this would break a lot of things, and that I need to --force. Should I?
20:49:13 <Cale> But every occurrence of 'arr' is a black box again
20:49:17 * hackagebot simple-pipe 0.0.0.8 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.8 (YoshikuniJujo)
20:49:47 <merijn> Cale: I saw an interesting hack to disable "arr" at the NL-FP day :)
20:49:58 <glguy_> Force yes and keep going until ghc-pkg check stops complaining
20:50:00 <original_brogram> So `arr` is the issue in that it re-introduces the problem which >>> aims to solve?
20:50:08 <nisstyre> nitrix: the Haskell Report is awesome
20:50:17 <nitrix> original_brogram: merijn: These seem to be exactly what I want. I guess I'm a really pedantic person.
20:50:17 <Cale> and because Arrow lacks operations like  assocR :: ((u,v),w) ~> (u,(v,w)) and  swap :: (u,v) ~> (v,u), and such
20:50:26 <nitrix> nisstyre: Well, you know me, don't you :) ?
20:50:32 <nisstyre> that and the RnRS standards are the benchmark for language specs imo
20:50:38 <merijn> Cale: The guy had an arrow instance and then wrote all his combinators to be of type "F (Foo a) (Foo b)", where Foo where newtypes without exported constructors
20:50:39 <nisstyre> nitrix: yes :p
20:51:03 <merijn> Cale: So the only way to use arr was with a "Foo a -> Foo b" function, which you couldn't create due to the Foo newtype
20:51:13 <merijn> Cale: And then he just left arr unimplemented
20:51:32 <Cale> merijn: Well, that prevents the problem somewhat, but it doesn't really fundamentally solve the issue that operations you probably need are then missing :P
20:51:49 <merijn> Cale: Sure, that's why I called it "an interesting hack" :)
20:51:51 <nisstyre> nitrix: whenever you see something like {-# LANGUAGE blah #-} in code it means it's using something non-standard fyi
20:51:53 <Cale> (of course, they can be provided separately too)
20:52:28 <original_brogram> Speaking of LANGUAGE pragmas, why isn't OverloadedString a default?
20:52:31 <Cale> merijn: At iPwn, we had our own Arrow type class that had those operations, along with a source preprocessor which unfolded proc/do notation in terms of the new operations
20:52:46 <Cale> merijn: and that adjustment made our game run a few times faster
20:52:49 <nitrix> nisstyre: So, it's not normative, but they are introducing it anyway?
20:52:54 <nisstyre> original_brogram: because it's non-standard, put it in your .ghci file
20:53:18 <nisstyre> nitrix: yes, it means it's essentially for that compiler/whatever only
20:53:27 <nisstyre> it can modify anything about the language basically
20:53:32 <nitrix> Fine by me.
20:53:47 <original_brogram> nitrix: You'd do well to dig into the extensions. Many are just fantastic.
20:53:58 <Cale> Well, {-# LANGUAGE ... #-} pragmas are themselves standardised, and the standard encourages support for particular ones
20:54:00 <nisstyre> yeah, OverloadedStrings is very useful
20:54:21 <Cale> It's just a way to make the language specification a bit more modular
20:54:24 <merijn> nitrix: Where, for example, gcc takes the choice to not by standards compatible unless asked. GHC makes the choice to conform to the report by default unless extensions are explicitly enabled
20:54:32 <Cale> The Haskell report isn't normative
20:54:37 <merijn> Well, GHC makes the choice to *mostly* conform to the report :p
20:54:41 <Cale> It's just a description of current practice
20:54:52 <Cale> (or at least, an attempt at one)
20:55:04 <nitrix> Since it hasn't been standardised?
20:55:32 <nitrix> ^ That's a terrible sentence there
20:55:47 <nisstyre> well there's no standard created by anyone like ISO or anything as far as I know
20:55:48 <Cale> Well, what is the purpose of a standard? It's to help multiple implementations be compatible with one another, and generally to inform people about what to expect.
20:56:09 <nitrix> Sure. But the report isn't doing that?
20:56:19 <merijn> I think it's silly that the module to filename mapping isn't standardised yet
20:56:21 <Cale> It would be a bit foolhardy to put things into the Report which weren't already implemented
20:56:24 <merijn> Actually
20:56:26 <merijn> That reminds me!
20:56:27 <original_brogram> The only non-conformance in GHC I know of is the whitespace rules.
20:56:36 <Cale> and so things always show up in implementations first
20:56:46 <merijn> time to go annoy people about my proposal from ages ago again!
20:56:48 <nitrix> Interesting. C does the opposite.
20:57:12 <merijn> original_brogram: Num does not have Show and Eq as superclasses and GHC doesn't support recursive imports
20:57:27 <Cale> original_brogram: GHC treats Unicode "other" letters as if they are lower case, which the Report doesn't technically allow
20:57:33 <merijn> Oh, and that
20:57:40 <merijn> Because Cale reads reddit too, apparently ;)
20:57:44 <original_brogram> merijn: Oh yes. The latter has caused me much pain...
20:57:46 <Cale> (and the mailing list)
20:58:02 <enthropy> https://www.haskell.org/ghc/docs/latest/html/users_guide/bugs-and-infelicities.html
20:58:11 <Cale> For some reason that mailing list post landed in my inbox instead of being auto-archived
20:58:21 <Cale> There are various other issues, yeah
20:58:29 <original_brogram> merijn: I thought we all assumed everyone here is on reddit as well?
20:58:34 <Cale> One of which is recursive module imports
20:58:46 <Cale> GHC requires you to write hs-boot files
20:59:00 <Cale> While the standard implies that you should just be able to recursively import things
20:59:14 <merijn> Man
20:59:27 <merijn> I need to set reminders that I actually close the discussion on my proposals on the mailing list
20:59:53 <merijn> I proposed a discussion with 4 weeks time in march and didn't remember until just now
21:00:01 <original_brogram> So many things are failing to install and it's making me sad. The guys at work will never listen to me about Haskell...
21:00:57 <drbean> How would I extract the bi-grams in a string of words, s in a haskelly way?map (\n -> (unwords [(( words s) !! n ), ((words s) !! (n+1))] )) [0 .. ((length $ words s) -2)]
21:01:19 <nisstyre> drbean: how do you define a bi-gram?
21:01:23 <nisstyre> two words in a row?
21:01:27 <Kludgy> Hi all. I'm having an interesting problem with HXT unpickling wherein if I have two XML files GOOD.xml and BAD.xml, and msum runX over [GOOD,BAD] yields no 'fatal error report' and processing silently halts, but msum runX [BAD,GOOD] outputs the expected fatal error. (full example at fpcomplete here: https://www.fpcomplete.com/user/Kludgy/silenthxt) .. anyone have any clues as to how to track
21:01:27 <Kludgy> down this unexpected behaviour?
21:02:27 <begriffs> I have a convenience module that defines instances of FromJSON and ToJSON of HDBC SqlValues. It leads to a warning about orphan instances, and I'm wondering how to heed the warning and fix my code. Any ideas?
21:03:25 <Cale> drbean: zip xs (tail xs)
21:03:30 <drbean> Perhaps I can make 2 lists, one of which is the same as the other, except for a prepended word, and then zip the words.
21:04:19 <Cale> > let bigrams s = zip xs (tail xs) where xs = words s in bigrams "here is a bunch of words"
21:04:20 <lambdabot>  [("here","is"),("is","a"),("a","bunch"),("bunch","of"),("of","words")]
21:04:24 * hackagebot conduit-extra 1.1.3.1 - Batteries included conduit: adapters for common libraries.  http://hackage.haskell.org/package/conduit-extra-1.1.3.1 (MichaelSnoyman)
21:05:12 <Cale> drbean: Note that in general, any time you're using !! or length, it's a good sign that either lists are the wrong datastructure, or there's some better way to do what you're doing
21:05:21 <merijn> begriffs: An instance is an orphan if it's NOT declared in either 1) the module defining the class or 2) the module defining the datatype
21:05:49 <merijn> begriffs: Orphans are, in itself, not dangerous, but avoiding orphans makes it easy to avoid accidentally declaring two different instances for a type
21:06:15 <merijn> begriffs: (double instances ARE a problem)
21:06:42 <begriffs> My orphans live in a homemade module called "Types" which isn't really meant for public consumption. It's included in a few of my other modules that need to work with sql and with json.
21:07:15 <benzrf> begriffs: i should hope orphans arent for public consumption!
21:07:28 <begriffs> :)
21:08:23 <kvanb> poor orphans
21:09:32 -boccato(~boccato@200.162.246.160.static-user.ajato.com.br)- I have this line of code: let mime = defaultMimeLookup (takeFileName path)
21:09:49 <boccato> And GHC is complaining that: Couldn't match type ‘[Char]’ with ‘Text’
21:10:00 <benzrf> boccato: using notice to get attention are we
21:10:43 <boccato> Shouldn't it work with OverloadedStrings?
21:11:09 <boccato> benzrf: Sorry, I didn't understand your comment.
21:11:35 <benzrf> boccato: you used notice instead of privmsg just there
21:11:49 <dolio> OverloadedStrings makes string literals overloaded.
21:12:09 <dolio> There don't appear to be any string literals in that line of code.
21:12:10 <boccato> benzrf: sorry, new irc client...
21:12:33 <boccato> Hmm.. didnt't realized it worked only on literals!
21:13:01 <splintax> that's annoyed me in the past too, although i assume there are valid reasons for not also coercing Strings to Text
21:13:19 <boccato> Though the name "Overloaded string literals" is pretty straight forward, now that you said it...
21:13:26 <dolio> Yes. Things are never coerced at all.
21:16:20 <pavonia> splintax: How would you decide when to convert a String to Text and when not?
21:18:45 <original_brogram> pavonia: Text is more efficient.
21:19:21 <pavonia> So?
21:19:40 <dolio> So you don't want to be randomly converting back and forth between it and String all the time.
21:19:50 <original_brogram> Just a data point to considere.
21:19:51 <dolio> Which is why you don't have the compiler auto-coerce things for you.
21:19:52 <boccato> I thought the String type would be converted to a IsString type.
21:20:12 <napping> that's only with string literals
21:20:17 <ReinH> IsString is not a type.
21:20:18 <boccato> But now I see IsString actually uses String, so it doesn't make sense.
21:20:46 <Makoryu> class Coerce a b where coerce :: a -> b -- Now just put "coerce" in front of literally everything
21:21:15 <Makoryu> coerce (coerce 2 + coerce 2)
21:21:15 <benzrf> instance Coerce a b where coerce = unsafeCoerce# -- now its useful
21:21:53 <napping> boccato: it's like how Num a has fromInteger :: Integer -> a, and a literal like 12 means (fromInteger (12 :: Integer))
21:22:06 <napping> luite: are you still around?
21:23:08 <stew> i'm trying to get ghc-mod working in emacs, when I turn on ghc-debug and watch the debug buffer, i see a constant stream of "NG ghc: readProcess: runInteractiveProcess: exec: does not exist (No such file or directory)"
21:23:18 <stew> when I run ghc-debug, all the versions seem to match up
21:23:27 <stew> does this seem familiar to anyone?
21:23:42 <Fuuzetsu> does lpaste have search functionality, looking for a paste I made few days ago
21:24:08 <boccato> napping: So it is like (functionThatTakesText (fromString ("bla" :: String)))
21:24:27 <napping> yes, if you have the overloaded string extension turned on
21:24:59 <boccato> And now my eyes are opened! :)
21:25:00 <napping> and I think there are some RULES pragmas or something so it doesn't actually convert through a String at runtime
21:25:28 <napping> not sure how the unicode handling goes with that
21:25:42 <pjdelport> Fuuzetsu: If you filled in the author field, you can say http://lpaste.net/browse?author=foo
21:25:42 <shachaf> It'll be encoded as a UTF-8 C String with \0 represented with an overlong code unit.
21:25:50 <shachaf> Unless it's of length <2
21:25:59 <Fuuzetsu> I didn't ;;
21:26:22 <shachaf> It'll still have to be decoded to UTF-16.
21:26:24 <glguy> Fuuzetsu: Just search on google with "site:lpaste.net"
21:26:43 <merijn> napping: Yeah, text abuses some GHC stuff to convert encode a blob in GHC's encoding into UTF-16
21:27:12 <nolan_d> Can someone please explain this Happstack type to me? home :: RouteT Sitemap (ServerPartT IO) Response
21:27:21 <shachaf> Notably it'll generate awful code for "" :: Text or "A" :: Text
21:27:33 <nolan_d> I don't see any ->s, =>s, ","s or any other symbols.
21:28:01 <original_brogram> That's because it's a single parameterized type
21:28:03 <stepkut> nolan_d: RouteT is a simple monad transfer (basically ReaderT) which contains a function that generates a url from values of Sitemap
21:28:11 <Kludgy> Wait.. why does anything of the form 'msum (xs :: [IO ()])' even typecheck?
21:28:18 <Fuuzetsu> glguy: got it
21:28:18 <Kludgy> (because it is for me)
21:28:18 <merijn> :t msum
21:28:19 <lambdabot> MonadPlus m => [m a] -> m a
21:28:50 <Kludgy> :info IO
21:28:52 <Kludgy> ?
21:29:05 <original_brogram> stepkut: So, Happstack 7.3.1 is failing on build for me. Any insight?
21:29:10 <napping> Kludgy: ick, I guess you got a MonadPlus IO from somewhere
21:29:24 <dolio> Control.Monad.Error.
21:29:37 <stepkut> original_brogram: which error and which version of ghc?
21:29:39 <Kludgy> dolio: O-ho.. looking this up
21:29:43 <nolan_d> Ah, OK, so I should read up on readers then.
21:30:29 <original_brogram> stepkut: All I'm getting is Exit Status 1 on GHC 7.8.3, on Ubuntu 14, cabal 1.18.
21:30:59 <stepkut> original_brogram: mysterious!
21:31:15 <stew> hrm, when I run the ghc-modi commands by hand they work
21:31:43 <stepkut> original_brogram: does adding -v provide any additional useful information?
21:31:51 <original_brogram> stepkut: I've there was also something about HSX somewhere. Let me see ig I can dig that up as well.
21:32:44 <nolan_d> So why are some parts of that definition parenthesized?
21:33:32 <luite> napping: yes
21:33:49 <merijn> nolan_d: Same reason tsome parts of the type "(a -> b) -> [a] -> [b]" are parenthesised, if they weren't the type would mean something else
21:34:04 <original_brogram> stepkut: Hmm. I tried again, but 7.0.1 was installed.
21:34:28 <merijn> nolan_d: It's saying the RouteT type takes 3 arguments: 1) "Sitemap" 2) "ServerPartT IO" 3) "Response"
21:34:33 <numberten> is there a way to wrap a library in another library?
21:34:44 <numberten> without importing it and including renamed functions?
21:34:44 <merijn> numberten: That depends on what you mean by that?
21:35:02 <Kludgy> dolio: So I'm not calling mtl's Control.Monad.Error.runErrorT anywhere, but perhaps HXT is internally. Can the MonadPlus leak out through my upper level type signature without being specified somehow?
21:35:07 <merijn> numberten: You mean you want to directly export the stuff provided by another library?
21:35:18 <numberten> merijn: so if I wanted to include Data.Hex in my Foo module
21:35:25 <dolio> Kludgy: Yes. All class instances are automatically re-exported.
21:35:32 <merijn> numberten: You can re-export entire modules at once
21:35:46 <nolan_d> merijn: Ah, thanks, I think I get it. I'm used to seeing ->s between arguments, but that indicates function while nothing indicates parameterized type?
21:35:50 <numberten> is there special syntax for that? i've been tinkering with it and been unable to get it to work
21:35:55 <merijn> numberten: "module Foo (myFunc, module Data.Hex) where import Data.Hex {- more code here -}"
21:35:57 <napping> luite: I put comments on the issue. I didn't reproduce your problem, building everything at once worked just fine
21:36:12 <Kludgy> dolio: right. thinking about this carefully.. I may have to extract my fpcomplete project to explore it in more detail.
21:36:18 <numberten> merijn: thanks :)
21:36:24 <merijn> nolan_d: Right :)
21:36:42 <merijn> nolan_d: Take "Maybe Int", that's also parameterised, except by only 1 type
21:36:42 <nolan_d> Ah, lightbulb moment. :) Thanks.
21:36:52 <merijn> nolan_d: "RouteT" is simply parameterised by 3 types :)
21:37:05 <stepkut> original_brogram: 7.3.1 builds fine with 7.8.3 for me -- seems like something is a bit odd on your system. Especially with the mysterious Exit 1 error from ghc.
21:37:23 <merijn> nolan_d: If you want to think of type constructors as "type-level functions", you'd be more correct than you'd initially expect ;)
21:37:51 <nolan_d> marienz: Right, which is what confused me. I expected arrows.
21:37:54 <original_brogram> stepkut: Okay, the failing package is happstack-hsp-7.3.1, exiting with status 1, and just before ghc reports "cannot execute hsx2hs"
21:38:00 <napping> luite: unless the custom/newer cabal is somehow relevant to building ghcjs itself? I didn't try that
21:38:05 <stepkut> original_brogram: ah
21:38:09 <nolan_d> Er, sorry, tab complete goof.
21:38:24 <stepkut> original_brogram: you probably don't have ~/.cabal/bin in your $PATH
21:39:55 <original_brogram> stepkut: That was true. Trying again!
21:39:57 <nolan_d> stepkut: Ran into that one too, I was installing in a sandbox and the sandbox directory wasn't on my path.
21:40:15 <stepkut> ah
21:40:34 <prinsen> I have a space leak in a program using pipes. I have condensed it to the following example: http://lpaste.net/109279
21:40:35 <stepkut> I should probably upgrade that code to use the [hsx| |] QuasiQuoter to avoid this issue entirely
21:40:41 <nolan_d> A second cabal install --dependencies fixed it for me, not sure if there's a cleaner workaround.
21:40:56 <numberten> merijn: do you know if there's a way to do the module exporting but without the original namespace?
21:41:14 <merijn> numberten: What do you mean "without the original namespace"?
21:41:17 <prinsen> When I run this with profiling I get a forever increasing memory usage
21:41:23 <luite> napping: i suspect that it might install some deps that make it hard for cabal to resolve this later.. (could also be a bug in cabal head)
21:41:53 <luite> napping: but thanks to someone else who reported a similar problem here, i probably have a workaround now
21:41:57 <napping> luite: I wouldn't be surprised if installing things in two steps picks versions in the first step that make it hard or impossible to finish
21:41:57 <merijn> numberten: If Data.Hex has a function "showHex" then "Foo.showHex" would be valid after someone imports "Foo" in my example
21:42:24 <napping> luite: just doing the cabal install ghcjs-prim haddock-internal ghcjs worked nicely
21:42:27 <luite> napping: Cabal 1.21 is not a package dependency of ghcjs, so that shouldn't be it
21:42:35 <numberten> merijn: i'm not seeing that :(
21:43:01 <luite> napping: and it also fails to find a plan when doing all those packages at the sam time, like you did
21:43:02 <numberten> merijn: I'm only getting showHex with a Data.Hex.showHex
21:43:03 <original_brogram> stepkut: Hmm. Fixed my $PATH, but still failing. I'll dig around a bit and see what else I've probably muffed.
21:43:20 <stepkut> original_brogram: same error ?
21:43:33 <merijn> numberten: Can you paste a minimal example?
21:43:48 <napping> luite: huh, must be the new cabal then, just usig the cabal I have it seems to do fine installing in two steps as well
21:43:54 <original_brogram> stepkut:  Identical
21:44:04 <stepkut> original_brogram: one moment
21:44:07 <luite> napping: but i think that depending on transformers-compat==0.3.3.3 will probably solve things
21:44:59 <luite> napping: there was some weirdness in flag handling in that package, that exact version forces transformers 0.3 to be used
21:45:12 <numberten> merijn: the same code is working as you said it would as a simple file in ghci
21:45:39 <napping> huh, guess I'll have to try the cabal too
21:45:42 <luite> napping: and i'll probably look into the transformers-compat flag handling stuff later, might be a bug in cabal, but i'm not sure
21:45:51 <numberten> merijn: I think maybe there's something else happening with my first text, gonna look into it and I'll tell you if I figure it out
21:45:56 <numberten> s/text/test
21:47:10 <numberten> merijn: when I load my file via 'cabal repl' I don't get the Data.Hex functions in the current namespace
21:47:20 <numberten> but when I use 'ghci' and manually load the file, I do
21:47:56 <numberten> even though cabal repl is automatically loading the file that is otherwise being manually loaded in ghci
21:48:08 <merijn> Odd
21:48:10 <numberten> yeah
21:48:28 <enthropy> does cabal repl actually take you into the same module as you were loading manually?
21:49:13 <numberten> good question, I'm new to the feature, so maybe not
21:49:23 <enthropy> there's also confusion that can be caused by loading compiled code (which has less things in scope), but I don't think cabal repl will do that
21:53:01 <stepkut> original_brogram: do a cabal update and try again
21:53:15 <stepkut> original_brogram: I uploaded a version of happstack-hsp that does not use hsx2hs
21:53:38 <original_brogram> stepkut: You are the coolest dev ever.
21:53:47 <stepkut> \o/
21:54:30 * hackagebot happstack-hsp 7.3.2 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.3.2 (JeremyShaw)
21:54:32 * hackagebot happstack-server-tls 7.1.2.1 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.1.2.1 (JeremyShaw)
21:54:50 <original_brogram> stepkut: Success!
21:55:07 <Kludgy> dolio: Thanks for the clue. :)  "instance MonadPlus IO
21:55:07 <Kludgy>   -- Defined in ‘transformers-0.4.1.0:Control.Monad.Trans.Error’
21:55:07 <Kludgy> "
21:55:30 <original_brogram> stepkut: Thank you so much!
21:55:39 <stepkut> thanks for reporting the error!
21:55:51 <stepkut> I can't fix things unless I know they are broken :)
21:55:58 <dolio> Kludgy: No problem. It's a tricky one.
21:56:18 <dolio> Been around for a long time, but hard to find in the docs, if possible at all.
21:56:18 <orion> hmm
21:56:37 <orion> So, I am running my haskell application on a huge AWS instance now, and the load is 0.5
21:56:47 <orion> And there are 32 cores.
21:56:59 <orion> Seems a little... low.
21:56:59 <original_brogram> stepkut: I'm trying to hint to the guys at work about Happstack, so you'll probably be hearing a lot from me in here!
21:57:08 <Kludgy> dolio: It was an unblocker for me.. step towards trying to figure out why the MonadPlus IO instance prevents HXT error outputs from showing up.
21:57:47 <napping> luite: working in sandboxes, I haven't gotten problems with the newer cabal either
21:57:50 <Boney> .win 3
21:57:52 <Boney> err.
21:58:52 <luite> napping: k tnx for testing so far, must be some existing dep making it hard to solve. i need some sleep now though
21:59:25 <numberten> enthropy: it appears that cabal repl only gives the first 'exposed-module' in the current namespace
22:00:14 <Kludgy> dolio: Oh nuts.. probably a clue.. 'Deprecated: Use Control.Monad.Trans.Except instead' (in hackage.haskell.org/package/transformers-0.4.1.0/docs/Control-Monad-Trans-Error.html)
22:02:08 <orion> a ha!
22:02:30 <orion> If I add +RTS -N32 to the arguments for my application, the CPU utilization goes to >2000% :D
22:05:30 <Kludgy> Can anyone suggest an alternative to HXT for unpickling XML? :)  It can be more lax in the ordering and optional bits.
22:06:03 <carter> orion: its actually hard work to keep even  ~ 15 cores busy
22:06:32 <original_brogram> stepkut: After 3 hours of waiting for builds, furious googling, and reporting the error here, I finally got the clckwrks demo to run. Just want to say: totally worth it.
22:06:37 <merijn> carter: Depends on what you're doing ;)
22:06:57 <carter> merijn: well, if you're not triggering GC that often is pretty easy
22:07:08 <carter> GC creates a lot of contention when allocating a lot on all the thread
22:07:35 <merijn> carter: Yeah, it would be really nice if there was a way to have per-capability GC, like erlang
22:07:42 <orion> carter: The load average is ~15
22:07:45 <orion> Which makes me sad.
22:07:53 <carter> orion: you need more threads
22:08:05 <orion> -N64 then?
22:08:06 <carter> orion: how're you scheduling the work
22:08:07 <carter> no
22:08:16 <carter> thats just number of capabilities
22:08:19 <carter> not the nubmer of threads
22:08:44 <carter> forkOn :: Int -> IO () -> IO ThreadId
22:08:46 <orion> carter: http://ideone.com/QhOR8c
22:09:40 <carter> orion: have you tried using the async lib?
22:09:46 <carter> it has a nice mapAsynchronously function
22:10:06 <carter> orion: it could be you're doing something network/io bound
22:10:41 <orion> carter: I don't do networking or disk IO.
22:10:54 <orion> It's SHA1 and AES256
22:11:27 <carter> orion: try mapAsynchronousl
22:11:28 <carter> y
22:12:00 <carter> orion: OR use forkOne
22:12:08 <carter> *forkOn and have a worker thread per core
22:12:53 <orion> carter: I will check it out. Are context switches killing me do you think?
22:13:07 <carter> umm, you should also play with RTS flags
22:13:14 <carter> theres a bit of art to tuning in the mega core case
22:13:34 <carter> orion: i've found +RTS -N -qa -RTS is a good srating point
22:13:39 <bitemyapp> :: Maybe a -> (a -> b) -> c -> Either c b
22:13:44 <bitemyapp> is that just not a thing? What am I missing?
22:14:15 <bitemyapp> I know (maybe :: b -> (a -> b) -> Maybe a -> b)
22:14:40 <carter> :t maybe
22:14:41 <lambdabot> b -> (a -> b) -> Maybe a -> b
22:14:47 <carter> it looks like a funny version o maybe
22:14:48 <bitemyapp> carter: I just pasted that function.
22:14:52 <carter> i know
22:14:54 <carter> i'm using :T :)
22:15:00 <bitemyapp> so
22:15:32 <numberten> enthropy: fixed it
22:15:34 <bitemyapp> carter: yeah I think this is a specialized of maybe
22:15:34 <carter> maybe (Left c) (Right . f)
22:15:39 <bitemyapp> right, yes.
22:15:47 <bitemyapp> specialization*
22:15:51 <carter> yup
22:15:51 <carter> tis
22:15:55 <bitemyapp> carter: that's probably what I wanted. Thanks.
22:16:02 <carter> de nada
22:16:09 <numberten> enthropy: made a low level file that exports all the other modules, as seen in bitemyapp's bloodhound
22:16:10 <bitemyapp> sanity checks r gud. :)
22:16:21 <bitemyapp> numberten: way to name-drop.
22:16:37 <bitemyapp> I get a lot of mileage out of, "just look at this line number in Bloodhound"
22:16:46 <bitemyapp> enthropy: https://github.com/bitemyapp/bloodhound/blob/master/Database/Bloodhound.hs
22:16:49 <bitemyapp> speaking of ^^
22:16:53 <bitemyapp> there's a re-export.
22:16:55 <bitemyapp> if that's what you wanted.
22:17:00 <numberten> enthropy: https://github.com/bitemyapp/bloodhound/blob/master/Database/Bloodhound.hs#L1
22:17:11 <numberten> bitemyapp: lol ty
22:17:17 <numberten> ugh
22:17:20 <numberten> you took my link
22:17:21 <bitemyapp> numberten: ?
22:17:28 <numberten> :(
22:17:36 <bitemyapp> numberten: I'm in a good mood and I'm on dual-monitor xmonad so I'm fast right now :P
22:18:01 <bitemyapp> numberten: accept my apology with a serving of: http://www.youtube.com/watch?v=A4VsdfdZfyc
22:18:34 <bitemyapp> numberten: and: http://i.imgur.com/KW83Nne.jpg
22:18:44 <bitemyapp> http://knowyourmeme.com/memes/gotta-go-fast
22:20:37 <numberten> i'm sleep deprived and seriously lacking in sonic music
22:21:05 <bitemyapp> numberten: make coffee and jam out t saturday morning cartoon theme songs.
22:21:07 <numberten> now i'm thoroughly confused, but thank you haha
22:21:08 <bitemyapp> to*
22:21:10 <numberten> oh good
22:21:24 <ajyasgar> rollin' around at the speed of sound~
22:22:34 <swgillespie> i had never heard of xmonad until you just mentioned it bitemyapp
22:22:39 <swgillespie> i'm going to install that right now
22:22:47 <bitemyapp> swgillespie: welp.
22:22:51 <numberten> oh man
22:22:53 <bitemyapp> swgillespie: good luck!
22:22:54 <swgillespie> i'm pretty new to haskell
22:23:02 <swgillespie> bitemyapp: will i need it?
22:23:07 <bitemyapp> don't get me wrong, xmonad is fantastic, but if you've never used a tiling window manager before
22:23:10 <bitemyapp> you are going to be BEWILDERED
22:23:19 <numberten> it's a dangerous thing to go without
22:23:21 <numberten> after getting used to
22:23:21 <bitemyapp> it's a bit like Emacs or vim. It's an investment.
22:23:24 <swgillespie> oh no, I've used a tiling manager before
22:23:34 <bitemyapp> swgillespie: oh you should be cool then.
22:23:34 <swgillespie> I used awesome before
22:23:44 <orion> carter: Can mapConcurrently be a direct replacement for forM_?
22:23:51 <numberten> is osxmonad any good?
22:23:53 <ajyasgar> xmonad is pretty great even without modifications
22:23:54 <carter> orion: TRY AND FIND OUT
22:23:57 <bitemyapp> numberten: abandonware.
22:24:03 <numberten> i keep getting recommended slate for my work computer
22:24:03 <ezrios> :t mapConcurrently
22:24:04 <lambdabot> Not in scope: ‘mapConcurrently’
22:24:11 <numberten> so far I've somehow just put up with not having a tiling window manager
22:24:12 <bitemyapp> numberten: this is partly why I just said fuck it and installed Linux. That and everything else about Linux.
22:24:17 <swgillespie> i'm afraid of messing with my os x window manager
22:24:26 <bitemyapp> swgillespie: err, you're on OS X?
22:24:33 <swgillespie> bitemyapp: linux vm for any real work
22:24:39 <numberten> bitemyapp: don't think devops supports linux on a mbp :(
22:24:50 <numberten> though I have ubuntu on my play mbp and love it
22:24:51 <swgillespie> bitemyapp: don't worry i'm installing on a linux vm :P
22:25:11 <bitemyapp> numberten: nuts.
22:25:33 <bitemyapp> numberten: that's what I've been wondering, if I can/should replicate my Linux setup on my work MBP. My personal machine is MBP with Linux.
22:25:39 <swgillespie> numberten: do you have one of the new macbook pros?
22:25:45 <bitemyapp> numberten: I like this xmonad setup a lot and would like to be able to use it for work.
22:25:50 <bitemyapp> so productive *_*
22:25:51 <numberten> swgillespie: late 2013
22:25:58 <swgillespie> oh, okay
22:26:20 <numberten> yeah it's amazing what a good xmonad setup can do to your computer experience..
22:26:24 <swgillespie> I have a retina MBP and my linux installation totally failed since there isn't a linux driver for the broadcom chip in the new MBPs
22:26:28 <numberten> i've never used xmonad /w dual screens though
22:26:29 <swgillespie> or at least there wasn't when I tried it
22:26:53 <numberten> swgillespie: :/
22:26:59 <swgillespie> yeah :/
22:27:13 <bitemyapp> numberten: multi-monitor is half of why I love xmonad.
22:27:20 <bitemyapp> numberten: it handles multi-monitor properly out of the box. It's great.
22:27:21 <merijn> swgillespie: Just run your terminal full screen with tmux inside for nearly the same experience ;)
22:27:24 <numberten> one day...
22:27:27 <bitemyapp> merijn: not even close.
22:27:35 <merijn> But I suggest the window manager discussion continues in -blah:)
22:27:41 <bitemyapp> oh sorry.
22:27:45 <bitemyapp> merijn: thanks for the reminder.
22:35:12 <kvanb> is this some kind of extension
22:35:20 <kvanb> I see a module with a record called WindowHint
22:35:26 <kvanb> and it has constructors
22:35:27 <kvanb> WindowHint'Resizable
22:35:30 <solidus-river> hmm, i'm trying to reform charlse isShooting wire from his asteroids game in a clearer way and am really unclear what i'm flubbing up
22:35:30 <kvanb> WindowHint'Visible
22:35:31 <kvanb> etc
22:35:41 <kvanb> do I really have to write out the full long name including the '
22:36:58 <ajyasgar> "That apostrophe doesn't have any special meaning in Haskell's syntax. It's a valid character to use in a function name. We usually use ' to either denote a strict version of a function (one that isn't lazy) or a slightly modified version of a function or a variable. "
22:37:12 <ajyasgar> from http://learnyouahaskell.com/starting-out#ready-set-go
22:37:43 <ajyasgar> sort of annoying, apostrophe is so easy to miss if you're quickly scanning text
22:38:35 <carter> map'ceptWhenIDontWanna
22:41:19 <solidus-river> http://lpaste.net/109281
22:41:53 <solidus-river> what am i doing wrong here, netwire is fine with the isShooting wire but hates the type of my braveDefenderIsShooting, i'm trying to express the action of a shot in a cleaner way
22:43:41 <merijn> carter: I was happy with my grammatically correct "can'tHappen" variable :p
22:45:45 <greymalkin> I'm trying to break my teeth on a "simple" program -- takes input piecemeal, puts it into a 'data' type, and creates a 'form' from that.
22:45:49 <sveit_> just checking, suppose an indexed traversal accesses multiple values, it isn't possible to set all those values to different things?
22:46:02 <greymalkin> The 'taking input piecemeal' -- does that really need lenses?
22:46:29 <carter> nothign needs lenses
22:46:49 <carter> its just eventually you hit a wall of "yah know, life will be better if i rub lense on everything"
22:46:53 <carter> like toothpaste
22:47:51 <dmj`> greymalkin: why do you mean by "form" ?
22:47:54 <dmj`> what*
22:48:10 <sveit_> greymalkin, sorry, bad timing with my question, which is unrelated :)
22:48:26 <sveit_> i'm still wondering. i just hope i'm not missing something.
22:48:31 <greymalkin> Ideally, it'll make a PDF -- but for now I'll settle for formatted text.
22:49:07 <dmj`> greymalkin: cool, do you have code for it?
22:49:47 <greymalkin> dmj`: Right now I've just defined a number of the data types, and a 'output' which looks a bit like a property list... nothing to look at.
22:50:34 <carter> greymalkin: pandoc!
22:50:34 <greymalkin> But searching for 'haskell data set field' got me pointed at lenses; which seems ... complicated
22:50:46 <carter> greymalkin: just do something dumb using pandoc as a backend
22:50:49 <carter> :)
22:51:27 <greymalkin> carter: Nice.
22:51:47 <carter> 'cause pandoc is both a library and a great cli too
22:51:51 <carter> tool
22:52:27 <dmj`> greymalkin: I'd use bytestring I/O for reading command line input, then attoparsec to put it into a data type, then write an eval function that renders the datatype to a pdf w/ pandoc
22:54:09 <benzrf> sleeping
22:54:18 <greymalkin> so, lenses, then.
22:54:23 <benzrf> bye
22:55:03 <corgifex> why lenses?
22:55:25 <dmj`> greymalkin: no lenses needed, you can set values w/o them...let newRec = record { field = value }
22:55:47 <sveit_> is there an equivalent of "over" but with the function being monadic?
22:56:07 <pavonia> :t over
22:56:07 <lambdabot> Profunctor p => Setting p s t a b -> p a b -> s -> t
22:56:13 <glguy> sveit_: Just apply your function to your lens
22:56:41 <glguy> :t _Right print
22:56:42 <lambdabot> Show a => Either c a -> IO (Either c ())
22:56:49 <greymalkin> dmj`: When I try that in GHCI, it's getting 'stuck'
22:57:30 <sveit_> glguy, why does that work?
22:57:37 <dmj`> greymalkin: the threads blocks until you hit enter
22:57:50 <glguy> sveit_: same reason you can do:
22:57:52 <glguy> ?type traverse print
22:57:53 <lambdabot> (Traversable t, Show a) => t a -> IO (t ())
22:57:57 <glguy> It's just a function
22:57:57 <dmj`> greymalkin: oh wait, are you talking about setting record values?
22:58:16 <greymalkin> Requires a ^C to get back to input
22:59:04 <sveit_> glguy, so presumably this means i can't take a traversable to multiple values and set them to different things?
22:59:05 <dmj`> greymalkin: are you using readLine?
22:59:10 <dmj`> *getLine
22:59:14 <greymalkin> dmj`: Yeah, I'd like to have a 'data' that describes the completed input; rather than try to track all the little bits of information along the way (especially painful if it ever becomes a web app)
23:00:14 <corgifex> greymalkin: you're all over the place. show your code
23:00:30 <glguy> sveit_: You can set them to different things based on what their previous value was or based on the index or using side effects (say in IO) to track where you are
23:00:32 <dmj`> greymalkin: you can use a StateT DataType IO () to accumulate results
23:01:20 <greymalkin> nm
23:01:30 <sveit_> glguy, could you point me to a resource that does something like this? i'm not sure i have a comprehensive understanding of traversals in lens
23:02:48 <glguy> sveit_: What are you trying to do. Maybe we can start there? I Don't know what best to show you
23:03:43 <sveit_> glguy, i think i understand the basic lens type and its applications/derivation (even read up on the yoneda lemma relationship), but i have no intuition for how to work with traversals
23:04:24 <glguy> Have you used mapM yet?
23:04:55 <sveit_> as in in code? sure
23:05:08 <glguy> OK, that works on []
23:05:14 <glguy> same idea
23:05:17 <glguy> :t mapM
23:05:18 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
23:05:21 <glguy> :t traverse
23:05:22 <lambdabot> (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
23:05:26 <glguy> but generalized beyond lists
23:05:51 <sveit_> glguy, and indexed traversals?
23:06:12 <dmj`> greymalkin: flip execStateT [] $ forever $ liftIO getLine >>= \case { "add" -> modify (++"thing") >> get >>= \t -> liftIO (print t); _ -> liftIO $ putStrLn "nothing here..." }
23:06:22 <glguy> They're traversals that know where their current "index" along the way
23:06:26 <dmj`> greymalkin: you should show us your code
23:08:07 <glguy> ?type itraverse (\i x -> putStrLn ("Visiting index " ++ show i) >> return (x+1::Int)) [10..20]
23:08:08 <lambdabot> IO [Int]
23:09:30 <sveit_> glguy, i see. i'll ask a more specific "burning question", suppose i have a list of values that i would like to stick in the traversable, is there some monad to do that?
23:10:23 <pingu> sveit_: what do you mean by "stick a list of values into a traversal"?
23:10:26 <sveit_> so suppose that i want to set the middle two elements of the list (not actually abusing the list this way) [1,2,3,4] -> [1,45,34,10]
23:10:43 <sveit_> sorry, i meant [1,2,3,4] -> [1,45,34,4]
23:10:45 <sveit_> for example
23:11:12 <corgifex> :t itraverse (\i x -> return ([1,45,34,4] !! i)) [1,2,3,4]
23:11:13 <lambdabot> (Applicative f, Num b, Monad f) => f [b]
23:11:22 <pingu> sveit_: so you want to operate on [2,3] all at once, or modify each element at a time?
23:11:50 <sveit_> pingu, whichever's faster? :) side-effects don't matter in my case
23:12:10 <sveit_> my point is suppose i have a list of n elements, and i have a traversal that i know will focus on n things, how do i replace those n things
23:12:13 <sveit_> with my thigns :)
23:12:16 <glguy> > set (partsOf (taking 2 (dropping 1 traverse))) [45,34] [1..4]
23:12:18 <lambdabot>  [1,45,34,4]
23:12:21 <glguy> You can do that. I don't know that it's a good idea
23:12:33 <corgifex> "focus" how?
23:13:15 <glguy> > set (partsOf both) [10,20] (0,0)
23:13:16 <lambdabot>  (10,20)
23:13:42 <pingu> so that's how I'd do it (with partsOf), but as for restricting, I'd use either filtered or indices
23:14:04 <sveit_> corgifex, suppose i use the traversable (elements (<10)). This will always focus on the first 10 elements of an indexed traversable.
23:15:19 <shachaf> "focus" means "traverse" when talking about a traversal, presumably.
23:15:46 <shachaf> By analogy with lenses.
23:15:50 <pingu> sveit_: if you have this traversal that works on a subset, you just "use" it. you pass it a function to do the modification and the structure it traverses over.
23:16:15 <sveit_> incidentally this is the kind of thing i would like some more information about. every lens resource online seems to focus on lenses/prisms/getters/setters which i think i have a pretty firm grasp on, but traversals i'm still not getting i think
23:16:16 <pingu> if you want to do all of the elements at once, you can use partsOf to turn the traversal into a function that works on a list that is the subset
23:16:18 <adas> is there a standard library for writing TCP or UDP servers? warp and the snap server seem to be primarily for http servers.
23:16:34 <pingu> if you don't want side effects, you want to use "over" or %~
23:16:40 <merijn> adas: What sort of standard library do you expect?
23:17:14 <merijn> adas: You presumably want the network library for access to sockets and something like pipes or conduit to do streaming IO (if you need that)
23:17:22 <kvanb_> adas: pipes, bytestring and such tend to work well for those things
23:17:34 <kvanb_> servers are more of a streaming beast
23:18:50 <kvanb_> I actually started putting together a library to rule all pipes server abstractions, but gradually it backburnered while my time disappeared ( https://github.com/kvanberendonck/surge )
23:19:19 <adas> thanks .. ill look into network library. i want to write a server that can contact a predefined url every few minutes. thats why i asked
23:19:42 <adas> predfined address/url
23:22:16 <sveit_> ok so one more example might help me. Control.Lens defines the indexed traversal Data.Vector.Generic.Lens.ordinals. Suppose i have a v1 = fromList [1,2,3,4] and v2 = fromList [7,8]. is there a way to use ordinals, which takes a list of indices, to set the middle two elements of v1 to the elements of v2? i.e. (ordinals [1,2]) is the traversal i would be using
23:22:36 <Fuuzetsu> is http://packdeps.haskellers.com/reverse no longer maintained?
23:22:50 <Fuuzetsu> oh, wait, last updated today
23:23:06 <Fuuzetsu> is there a reason why some packages don't show up?
23:28:59 <supki> Fuuzetsu: they probably do not have revdeps
23:29:39 <Fuuzetsu> hm, I see 1200 downloads on haddock-library within last month, I doubt it'd go up that high without revdeps
23:30:41 <slomo> why is there no MaybeT in mtl? should i use the one from transformers instead, or the maybet package?
23:30:55 <Fuuzetsu> the only thing I can think of is buildbots fetching it for yet-unreleased packages using it
23:31:43 <supki> I'd guess things that depend on haddock-library haven't been pushed to hackage yet
23:31:54 <carter> Fuuzetsu: probably ghcjs :)
23:32:05 <carter> Fuuzetsu: 'cause ghcjs packages don't live on hackage yet
23:32:07 <Fuuzetsu> another example is yi-contrib, I know that ‘yi’ depends on it and it has for a long time, yet yi-contrib doesn't show up
23:32:28 <Fuuzetsu> wait, yi-contrib depends on yi should I say
23:32:38 <glguy> Slomo might as well use the one in transformers since you have that package already
23:32:38 <Fuuzetsu> hm, OK, that shouldn't show up
23:33:01 <Fuuzetsu> carter: that sounds like a lot of users
23:33:11 <carter> or a LOT of builds
23:33:37 <adas> is "yi" useable?
23:34:25 <Fuuzetsu> adas: Yes, but not to the point where it's comfortable or advantegous to do so.
23:34:38 <Fuuzetsu> it is not ready for serious switch yet
23:35:06 <supki> slomo: mtl re-exports transformers types and adds a bunch of MonadX classes. There's no point in MonadMaybe, so it does not re-export it
23:35:36 <slomo> supki: ok, that makes sense :) thanks
23:36:18 <shachaf> supki: Isn't there?
23:36:45 <Fuuzetsu> carter: does GHCJS even have a buildbot? Can't find any mention
23:37:01 <carter> i think the build bot is luite :)
23:37:10 <dbs1> Anybody know what would cause a program to freeze during a funciton call? As in, it prints stuff out before the function is called but not at the start of the function.
23:37:19 <adas> Fuuzetsu: just saw its hackage page. seems like development is still going on. somehow i thought it stopped
23:38:10 <Fuuzetsu> adas: there aren't many of use and we're mostly busy with stuff so it's going slow but it has not been abandoned
23:38:17 <Fuuzetsu> I think I'll have some time next week to hack on it
23:38:24 <Fuuzetsu> many of us*
23:38:43 <Fuuzetsu> we'd love some more hackers if you're interested
23:38:47 <adas> Fuuzetsu: if im interested in it, i know i should perhaps participate in development but i don't think im competent yet
23:39:19 <adas> Fuuzetsu: though i love the idea of using haskell to customize it the way i want ala emacs
23:39:24 <Fuuzetsu> I don't know of a better way to become competent than hacking on actual projects ;P
23:39:31 <Fuuzetsu> although the way Yi is set up might be a bit hard to deal with
23:40:06 <Fuuzetsu> adas: Right, as do I, I basically want something like emacs but using Haskell and being able to easily use any Haskell libs
23:41:57 <Fuuzetsu> my machine is building lens 4 times at once (two versions x 2 archs), it was nice knowing it ;(
23:45:36 <Fuuzetsu> carter: I doubt luite made dependency downloads 1000+ times himself
23:46:00 <merijn> Fuuzetsu: Plenty of people are trying ghcjs out
23:46:29 <Fuuzetsu> perhaps, the ammount just suprises me considering it's not on Hackage
23:46:53 <Fuuzetsu> I know pandoc is a revdep now but that version is also not on Hackage yet
23:48:23 <merijn> Fuuzetsu: Don't underestimate the number of people tracking pandoc master on github (I used to, for example)
23:49:09 <Fuuzetsu> I guess; the downside of haddock-library existing is that now we can't use bleeding edge GHC HEAD features in it
23:49:21 <Fuuzetsu> jgm patched out LambdaCase to have 7.4.2 support…
23:49:23 <Fuuzetsu> ;_;
23:50:09 <Fuuzetsu> I don't think I ever even used pandoc. Maybe once.
23:51:35 <merijn> I've used a bunch of times and when I was working on my hakyll site (which like most projects ended on indefinite hold when I got distracted :p)
23:59:16 <sgronblo> Why do I have to add +aeson to a query on Hoogle to find .= ?
23:59:23 <sgronblo> Seems to defeat the purpose
23:59:48 <Fuuzetsu> because Hoogle by default only looks in a bunch of packages
