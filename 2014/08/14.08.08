00:02:48 <trap_exit> I am tempted to write a monad tutorial now
00:02:57 <trap_exit> I feel like I have some special insight no existing monad tutorial I've read captures
00:02:57 <MP2E> oh god
00:03:14 <trap_exit> the idea is -- ignore analogies, ignore IO, ignore State, ignore Maybe
00:03:14 <MP2E> there are so many monad tutorials :V
00:03:23 <trap_exit> just think of two functions, f , g, and f >>= g
00:03:52 <MP2E> http://dev.stephendiehl.com/hask/#monads
00:04:03 <trap_exit> I should put up a kick starter
00:04:03 <trap_exit> if I get $50k, I won't write it
00:04:09 <MP2E> heh
00:16:37 * hackagebot haskell-brainfuck 0.1.0.1 - BrainFuck interpreter  http://hackage.haskell.org/package/haskell-brainfuck-0.1.0.1 (paraseba)
00:44:37 <solatis> ok, i'm still battling with type signatures and ambiguity and all that stuff... i understand what the problem is, and what i have to do, but do not know which syntax to use
00:44:45 <solatis> what is recommended reading material?
00:45:13 <shachaf> Reading material on what?
00:45:37 <solatis> on type signatures and type casting
00:45:48 <solatis> all the material i found on google is trivial
00:46:00 <solatis> and doesn't really explain complex situations
00:46:15 <shachaf> There's no such thing as type casting.
00:46:25 <solatis> hmz
00:46:35 <solatis> ok let me rephrase
00:46:42 <shachaf> I don't know what material on type signatures would say.
00:46:45 <solatis> I have a type Sender, which can be one of several instances
00:46:53 <solatis> the compiler is unable to derive which instance I use
00:47:12 <solatis> and I have no idea what to google for, what the syntax is, or whatever
00:47:21 <solatis> i understand the error message perfectly well :)
00:47:44 <Pythonfant> in some cases you need to provide explicit type signatures
00:49:07 <solatis> well, look at this compiler error:
00:49:09 <solatis> https://gist.github.com/solatis/22942319dbfae491e80e#file-version3
00:49:25 <solatis> how am I supposed to tell the compiler it's an instance of Sender Push
00:50:54 <Pythonfant> run =<< ((openSender 10150) :: Sender Dealer) would be my first guess
00:51:24 <annelies> I’d put it in a function with an explicit signature
00:51:32 <annelies> type signature in expressions are ugly
00:52:06 <Pythonfant> yeah probably a better solution
00:52:25 <solatis> well Pythonfant's suggestion generates 4 pages of error messages
00:52:53 <latk> How should I be specifying package versions in my .cabal files? Until now, I've just been adding them.. but cabal install has been running for 40 minutes now, with no result :p
00:52:53 <Pythonfant> solatis: ah ofc
00:53:06 <latk> adding them = just adding the package-name
00:53:35 <Pythonfant> solatis: that's because you get ZMQ z (Socket z t) out of opensender
00:53:41 <solatis> yes
00:53:44 <Pythonfant> so you need to force the type to something like this
00:53:47 <annelies> (run :: Socket z Dealer -> ZMQ z ()) =<< openSender 10150
00:53:49 <annelies> with whatever z
00:53:55 <annelies> I don’t know which one it is
00:55:42 <annelies> openSender :: Int -> ZMQ z (Socket z t)
00:55:51 <annelies> Compiler has to know what t and z are more specifically
00:55:59 <annelies> So you have to tell it if it cannot infer it.
00:56:02 <solatis> so i need to define the function
00:56:57 <annelies> what is z?
00:57:20 <solatis> it's the ZMQ monad
00:57:34 <annelies> no, that’s ZMQ z
00:58:10 <solatis> hmz
00:58:27 <solatis> you're taking about the declaration of `run` ?
00:58:43 <annelies> yes, or openSender
00:59:05 <solatis> but z is already defined there as ZMQ z ?
00:59:12 <solatis> so z is ZMQ?
00:59:29 <solatis> what am I missing?
00:59:46 <annelies> what is “z” in “openSender :: Int -> ZMQ z (Socket z t)”
00:59:47 <annelies> what does it mean
01:00:37 <annelies> what would you call it if you had to give it a name longer than a single character?
01:01:06 <Axman6> zed
01:01:14 <Axman6> >_>
01:01:43 <annelies> > It uses the uninstantiated type variable z to distinguish different invoctions of runZMQ and to prevent unintented use of Sockets outside their scope.
01:01:44 <annelies> ah, I see.
01:01:45 <lambdabot>  <hint>:1:28: parse error on input ‘type’
01:02:10 <Axman6> like the s in ST s a
01:02:29 <solatis> annelies: i would probably call it z0 and z1 ?
01:02:32 <Iceland_jack> You can call it a thread if you want to
01:02:43 <solatis> to denote the transformation of the monad?
01:03:43 <solatis> annelies: you're talking way beyond my level of understanding at the moment, but as far as I understand it they provide the ZMQ monad to prevent leaks of sockets etc
01:03:57 <annelies> solatis: you can do this then:
01:03:58 <annelies> https://gist.github.com/rightfold/68621f19d359eda79149
01:04:16 <annelies> you need to enable language extension for the forall, but I don’t know what it’s called
01:04:20 <annelies> ExistentialQuantification IIRC
01:04:24 <Iceland_jack> RankNTypes
01:04:47 <Iceland_jack> I would guess if it's similar to ST, I haven't read the complete backlog
01:05:11 <annelies> also why does haskell use “forall” instead of “exist” for this ;_;
01:05:32 <solatis> annelies: is this really an appropriate solution?
01:05:39 <solatis> it feels.. complex
01:05:49 <annelies> I don’t see how else you’d do it.
01:05:54 <solatis> what does 'forall z. ZMQ z (Socket z Dealer)' do ?
01:05:55 <lieven_> that's one I never understood either. it's called *existential* quantification and the keyword is forall.
01:06:01 <annelies> maybe you don’t need “forall z.” though
01:06:16 <annelies> {-# LANGUAGE CPP #-}
01:06:17 <annelies> #define exist forall
01:06:18 <annelies> fixed :D
01:06:26 <solatis> annelies: https://gist.githubusercontent.com/solatis/22942319dbfae491e80e/raw/5de4619d0903b603d7df9351415e67b1360b8157/Version1
01:06:31 <solatis> that is the code that 'is working'
01:06:41 <solatis> i'm trying to get the logic of opening the socket out of it
01:06:44 <Iceland_jack> I need to run so I can't really explain but you will definitely find something if you search for "forall haskell exists"
01:06:54 <solatis> to *simplify* and decouple the code
01:07:04 <solatis> but it only seems to grow more and more complex
01:07:42 <lieven_> I remember my first attempts to separate out some stuff that used pipes and persist. cutting monadic code in pieces is hard sometimes.
01:08:03 <solatis> well it just seems to cause a lot of code bloat
01:08:09 <solatis> and makes things more complex
01:08:19 <solatis> which is the opposite of my goal
01:09:04 <solatis> you see my version1? it's neat and clean
01:09:10 <solatis> but its tightly integrated
01:09:30 <solatis> the more i get toward decoupling the opening of the socket from operating on the socket, the more complex the code seems to become
01:09:59 <solatis> is this a common pattern in haskell, or am i doing something wrong?
01:12:27 <frerich> Thanks to Google+ I just learned that you can have list comprehensions without any generators, e.g. you can do 'foo ++ [ "yes" | odd 3 ]' which is probably quite neat when you want to show a message but only include some things in certain conditions.
01:13:42 <frerich> Maybe something like '"Byte" ++ ['s' | n /= 1]' :-)
01:13:51 <Iceland_jack> cute :)
01:14:08 <Iceland_jack> you may want to create a formatter for that like FORMAT in Common Lisp
01:14:45 <annelies> cryptographers also like such code
01:15:00 <Iceland_jack> something like 'format ("Byte" % plural) n'
01:15:08 <lieven_> should be interesting. FORMAT is just not quite Turing complete.
01:15:32 <lieven_> if you don't cheat by using its 'call an arbitrary function' feature
01:15:37 <Iceland_jack> It isn't? You can..
01:15:41 <Iceland_jack> oh was just about to mention that
01:15:54 <Iceland_jack> but I'm very sure it is Turing complete regardless
01:16:21 <lieven_> it has come up in cll and consensus seemed to be not quite
01:16:30 <Iceland_jack> FORMAT is horrible though
01:16:41 <Iceland_jack> @hackage formatting
01:16:42 <lambdabot> http://hackage.haskell.org/package/formatting
01:16:47 <Iceland_jack> is a nicer approach
01:17:04 <annelies> > let orEmpty cond x = if cond then x else mempty in (orEmpty (odd 3) "yes", orEmpty (odd 2) "yes")
01:17:06 <lambdabot>  ("yes","")
01:17:14 <lieven_> it looks like line noise but it has it's moments. and having 2 systems of roman numerals is fun
01:17:58 <solatis> ok that's it, i'm going for a monolithic function instead of breaking it up in separate functions
01:18:00 * frerich .o0( ["severe " | severity err > 50] ++ "error detected" )
01:18:08 <solatis> it just seems more trouble than its worth
01:18:15 * solatis disappointed :(
01:20:13 <lieven_> I'll stop being off topic (sorry guys) but this is the reference I was thinking about. https://groups.google.com/forum/#!original/comp.lang.lisp/w5ZrkgewWnQ/RWrMyTueRP4J
01:21:38 <shachaf> "forall" is used for existential quantification because of where it is.
01:22:04 <shachaf> data T = T (forall a. a) -- would be universal
01:22:14 <shachaf> data T = forall a. T a -- would be existential
01:22:49 <shachaf> This means that for any type A, (T (x :: A)) has type T
01:22:55 <shachaf> (For any x of type A.)
01:23:10 <shachaf> Just like data T = T Int means that T (5 :: Int) has type T
01:23:29 <lieven_> you're talking about the first or the second one?
01:23:36 <shachaf> And data T a = T a means that T (x :: A) has type T A
01:23:44 <shachaf> I'm talking about the second one.
01:24:21 <lieven_> so data T a = T a with explicit quantifiers would be forall a. data T a = T a
01:24:38 <shachaf> No, there's no forall.
01:24:44 <shachaf> T (x :: Int) :: T Int
01:24:48 <shachaf> T (x :: Bool) :: T Bool
01:24:56 <Pythonfant> shachaf: the first one could only contain bottom?
01:25:07 <shachaf> Pythonfant: In this case, yes.
01:27:55 <lieven_> and for the second one, about the only functions you could write with an argument of type T would be `id` or repackaging in a similar general container
01:29:11 <shachaf> Well, that T is isomorphic to ()
01:29:14 <shachaf> No useful information in it.
01:29:21 <shachaf> In retrospect I shouldn't've called them all T.
01:53:50 <jkarni> shachaf: How exactly does one map Haskell's types to, say first-order logic? I'd like to read the data declaration data T a = T a as something like (Va)Ta => T'a (T is the constructor, T' the datatype) but that seems to fail miserably when you try putting Haskell quantifiers in
01:55:03 <shachaf> Haskell quantifiers behave the same way as the usual logic quantifiers.
01:55:12 <shachaf> I'm not sure I understand your notation.
02:01:40 <jkarni> shachaf: give me a second to formulate the question better
02:01:46 <latk> How does one install a new version of Cabal? I currently have Cabal-1.18.1.3.
02:02:08 <adas> latk: cabal install cabal-install?
02:02:17 <adas> or is it cabal install cabal
02:02:39 <latk> adas: I'll try both :)
02:03:13 <jkarni> shachaf: take something like data T a = T a
02:03:39 <jkarni> shachaf: So I see the constructor as a function, and the datatype as a predicate
02:04:09 <shachaf> Maybe better to give them two different names to clarify. data T a = MkT a
02:04:17 <jkarni> shachaf: yeah
02:04:43 <shachaf> The type T is like a predicate, sure.
02:04:58 <jkarni> shachaf: so I see the entire line as saying something like, "forall. a, if you apply MkT to a, T (MkT a) holds"
02:05:07 <adas> isn't the type T a kind (* -> *) or am I way off context/
02:05:09 <adas> ?
02:05:21 <shachaf> "T (MkT a)" looks like an error of some sort.
02:05:35 <shachaf> MkT is on the value level, T is on the type level.
02:06:00 <jkarni> shachaf: yeah, I know it's not valid haskell
02:06:02 <shachaf> You can think of the type like a predicate T(x)=x, maybe.
02:07:21 <jkarni> shachaf: well, I guess it should really be a relation
02:07:36 <shachaf> There's a forall involved in that "MkT :: forall a. a -> T a" -- I guess that's what you mean here?
02:08:14 <jkarni> shachaf: that's the forall I mean
02:08:19 <shachaf> adas: It isn't a kind, but it has that kind.
02:08:53 <shachaf> jkarni: OK. With GADT syntax, the following three are different types:
02:08:59 <shachaf> data T a where { MkT :: forall a. a -> T a }
02:09:07 <shachaf> data T where { MkT :: forall a. a -> T }
02:09:10 <shachaf> data T where { MkT :: (forall a. a) -> T }
02:09:43 <jkarni> shachaf: wait, the second and third are different?
02:10:03 <shachaf> Yes.
02:10:14 <shachaf> "forall a. a -> T" means "forall a. (a -> T)"
02:10:43 <jkarni> shachaf: ah, yeah
02:10:51 <shachaf> That second one happens to be the same as "data T where { MkT :: (exists a. a) -> T }", except you can't say that in Haskell.
02:11:23 <jkarni> shachaf: aha, now I see
02:11:29 <pavonia> Is there a difference between "data T a where { MkT :: forall a. a -> T a }" and "data T a where { MkT :: a -> T a }"?
02:11:34 <xtreak> hi I am a haskell newbiw here.. I was told that haskell doesn't have states and everything is a constant.. But ghci lets me define let x = 5 and again let x = 6.. How?
02:11:50 <shachaf> pavonia: No, the forall is implied, just like with other Haskell types.
02:11:55 <shachaf> I was being explicit for clarity.
02:12:07 <pavonia> Okay
02:12:09 <shachaf> xtreak: Those are two different variables that happen to have the same name.
02:12:34 <pavonia> xtreak: The second x shadows the first one
02:12:47 <xtreak> So you mean to say two x exists?
02:13:06 <shachaf> After you define the second x, the first one doesn't exist anymore.
02:13:48 <jkarni> shachaf: thanks - even before I made my question really clear, you answered it!
02:14:07 <shachaf> jkarni: Hmm, I'm not sure what your question was, but I'm glad that helped.
02:15:18 <xtreak> shachaf : Thanks. So how is it different from other languages that let me do the same? What exactly is meant by state in this context?
02:16:15 <shachaf> xtreak: Well, you can't say something like "let x = 5; if (blah) { let x = 6 }"
02:16:33 <shachaf> Because that would only create a new x inside the scope of the if.
02:16:46 <xtreak> pavonia Thanks.
02:16:57 <shachaf> In fact there isn't even a notion of statements built into the language (other than in ghci, sort of).
02:17:01 <tac_> xtreak: Variables names are like people names. Sometimes you end up with two Johns in the same room.
02:17:09 <tac_> that doesn't make them the same person :)
02:17:30 <shachaf> jkarni: As always I recommend thinking of forall as a function and of exists as a tuple.
02:18:40 <tac_> (Also note that Haskell has no true notion of "exists" in the language. You always 'encode' exists using forall and a logical trick)
02:19:04 <xtreak> shachaf So every variable can have only one value at a time?
02:19:19 <shachaf> Haskell has a notion of existential types, just not the keyword "exists".
02:19:27 <shachaf> xtreak: Yes.
02:19:33 <jkarni> shachaf: can you say more?
02:19:59 <pavonia> xtreak: Isn't that true in all languages?
02:20:14 <xtreak> shachaf : Could you share any links that explain it a bit more?
02:20:31 <haasn> pavonia: What about nondeterministic languages?
02:20:37 <shachaf> xtreak: I don't know any but probably any introduction to Haskell has something about it.
02:20:48 <shachaf> A variable is a shorthand for a value.
02:20:59 <bahamas> pavonia: he means that in some languages you can use the same name for different values, but you were probably pedantic
02:21:03 <shachaf> When you say "let x = 5 in ...x...x...", you could just say "...5...5..." instead.
02:21:13 <xtreak> shachaf : Thanks
02:21:15 <pavonia> haasn: I've never heard of these
02:21:35 <shachaf> I,I do { x <- [1..5]; ... } -- what is the value of x?
02:22:04 <Maior> [1..5], no?
02:22:52 <xtreak> pavonia : Thanks. I was little confused by the notion everything is a constant in haskell.
02:23:24 <tac_> xtreak: it throws everyone for a curveball
02:23:29 <shachaf> jkarni: Do you know any dependently typed languages, or maybe System F, or similar?
02:23:36 <haasn> Data is immutable in all languages; but other languages tend to have references whose meanings can change over the course of evaluation. Haskell does not
02:23:44 <haasn> If you reference an immutable value, you will always reference the exact same immutable value
02:23:55 <shachaf> jkarni: Or e.g. https://en.wikipedia.org/wiki/Brouwer-Heyting-Kolmogorov_interpretation ?
02:26:02 <jkarni> shachaf: yes, BHK! but only briefly, and in quite a different context
02:26:52 <shachaf> jkarni: It's the same sort of idea: forall is a function, exists is a tuple.
02:27:25 <jkarni> shachaf: nice, that helps
02:28:49 <shachaf> jkarni: In a language like Agda, say, you don't have polymorphism in the Haskell sense, exactly. You can write idInt :: Int -> Int; idInt x = x and idBool :: Bool -> Bool; idBool x = x
02:29:35 <shachaf> Clearly those functions have a lot in common -- in fact, the only thing different about them is the type. So when we have things that are very similar where only the type is different, we use a function to generalize.
02:29:39 <haasn> I remember liking http://stackoverflow.com/questions/10753073/whats-the-theoretical-basis-for-existential-types
02:29:47 <haasn> If that helps anybody
02:30:08 <shachaf> So you can write something like id :: (A :: *) -> A -> A; id T x = x
02:30:32 <shachaf> So id Bool = idBool, i.e. (\(x::Bool) -> x), and similarly for id Int and id Char.
02:31:29 <jkarni> shachaf: thus making more concrete the forall-as-function idea
02:31:51 <shachaf> Right. You have a family of id functions, parameterized on a type.
02:32:01 <shachaf> Except you need a fancy type system to be able to write the type of a function like that.
02:32:09 <tac_> jkarni: typeclasss work the same sort of way. Eq a => ... is just an "implicit" parameter of type Eq a
02:32:20 <shachaf> (Because the type of (id T) depends on T.)
02:32:28 <tac_> just as forall a. ... is an implicit parameter of kind *
02:32:43 <shachaf> Why bring type classes into it? Type classes are complicated. :-(
02:33:22 <tac_> shachaf: Because they aren't complicated if you think of them as implicit parameters that the compiler works out for you
02:33:43 <tac_> I found that fact rather unifying when I first saw agda
02:33:49 <shachaf> They're much more complicated than the absence of type classes.
02:33:53 <shachaf> Anyway.
02:34:35 <tac_> Parameters are parameters.
02:34:46 <shachaf> jkarni: So for existential types you can think of a tuple. (exists a. Foo a) "really means" ((A :: *), Foo A)
02:35:01 <haasn> Ooh, I forgot that the stackoverflow answer also includes “proofs” for why forall a. X -> T a is the same as X -> forall a. T a
02:35:24 <haasn> And why forall a. T a -> X is the same as (exists a. T a) -> X
02:35:44 <tac_> haasn: isn't that only when a is not free in X?
02:35:44 <shachaf> "flip" and "curry/uncurry"
02:35:48 <haasn> tac_: Right
02:35:51 <tac_> yeah
02:36:17 <haasn> tac_: X and T can be read as actual types here, not just metavariables
02:36:39 <haasn> Since you can transform any other type fitting those shape into precisely that by giving definitions for X and T
02:36:39 <shachaf> That's the way you encode existential types in Haskell: To encode (exists a. Foo a), you first convert it to (forall r. ((exists a. Foo a) -> r) -> r), and then you curry that to get (forall r. (forall a. Foo a -> r) -> r).
02:36:48 <shachaf> But this is spoilers.
02:36:57 * hackagebot SpacePrivateers 0.1.0.0 - Simple space pirate roguelike  http://hackage.haskell.org/package/SpacePrivateers-0.1.0.0 (tuturto)
02:37:34 <jkarni> shachaf: aha
02:37:41 <haasn> I think the stackoverflow answer explains this mechanism quite nicsely
02:38:05 <jkarni> shachaf: that's incredibly enlightening
02:38:19 <haasn> Converting (exists a. T a) -> ... to forall a. T a -> ...; which explains why we don't use the “exists” keyword for Haskell datatypes, instead using forall with the variables moved to the outside of the constructor
02:38:41 <shachaf> It does. Sort of.
02:39:07 <shachaf> It explains why we can get away with not having "exists".
02:39:10 <haasn> It does sort of provide the logical underpinnings of the equivalence
02:40:42 <shachaf> jkarni: Now you can understand everything having to do with RankNTypes and ExistentialTypes!
02:41:12 <tac_> It would still be nice to have exists
02:41:17 <tac_> someday....
02:41:53 <shachaf> I think the original complaint here was that you write "data T = forall a. MkT a" instead of writing "exists"
02:41:57 <haasn> Preferably on the same day we get impredicative polymorphism?
02:42:16 <shachaf> But no one complains about the "=>" in "data T = forall a. Show a => MkT a"
02:43:08 * haasn .oO( data T = MkT (exists a. Show a *> a) )
02:43:31 * haasn .oO( data T = MkT (exists a. (a -> String, a)) )
02:43:35 <shachaf> Yes. Preach the *>
02:43:36 * haasn .oO( data T = MkT String )
02:43:57 <shachaf> haasn: That doesn't give me showsPrec at all!
02:44:13 <shachaf> Anyway, yes, I know that's not a useful type.
02:44:44 <haasn> I was just thinking about how to demonstrate that *> works like tuples, if => works like functions
02:45:06 <haasn> Analogous to how exists works like tuples, if forall works like functions
02:45:44 <shachaf> That's pretty straightforward if you accept the dictionary interpretation of type classes.
02:45:50 <haasn> And simultaneously demonstrating the often non-usefulness of existential types
02:46:05 <shachaf> "data T = MkT (exists a. (ShowDict a, a))" -- there you go
02:46:58 <shachaf> I think people overcorrect for existentials.
02:46:59 * hackagebot not-gloss 0.6.1.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.6.1.0 (GregHorn)
02:47:35 <haasn> That's something I actually wonder about. Does the “dictionary interpretation” break down? Obviously type class resolution is automatic while dictionary passing is explicit, but what features of type classes are hard or impossible to capture with this type of explanation?
02:47:42 <shachaf> You learn about existentials, and you think "hey, that's great!". And then you learn about how you could use String instead of (exists a. Show a *> a) and you think "hey, existentials are useless!"
02:47:48 <haasn> Do MPTCs+FunDeps count, since they affect type checking?
02:48:18 <shachaf> But they're still useful.
02:48:32 <shachaf> Even (especially?) existentials without type classes are useful.
02:48:40 <shachaf> (OK, maybe "especially" is going a bit far.)
02:49:09 <shachaf> haasn: Well, in what context? In plain Haskell2010 without RankNTypes dictionaries don't work very well because of methods with a forall in their type. Say return.
02:49:33 <shachaf> You can't write data Monad m = Monad { return :: forall a. a -> m a; ... } without Rank2Types (or something close).
02:49:40 <haasn> I know of one situation in which they're different from the “declassed” version in nontrivial ways; namely when “declassing” would be a performance loss
02:49:44 <haasn> I don't know of any others
02:50:05 <shachaf> When what's different?
02:50:06 <haasn> shachaf: In the context of GHC + Everything under the sun
02:51:04 <haasn> When an existential with a type class constraint is different from its equivalent version stored as a collection of all methods
02:51:43 <shachaf> Oh. Sure.
02:51:57 <shachaf> More memory usage, slower, etc.
02:52:13 <shachaf> (In certain cases.)
02:52:22 <haasn> You also lose some generality that is only possible with existentials
02:52:27 <fl> hi guys! Does anyone knows if there is a way to switch current viewing workspace in xmonad with the terminal (from a python script)?
02:52:36 <haasn> Sure, you can always transform a *specific* type to a dictionary, but you can't do that if you're abstracting over the type class involved
02:52:38 <haasn> eg. http://hackage.haskell.org/package/constraints
02:53:11 <shachaf> fl: This channel is for Haskell. Maybe ask in #xmonad.
02:54:55 <haasn> That package actually captures the idea of => working like functions, too. In a way.
02:55:07 <haasn> It represents a :- b, which is sort of like a function between constraints, as a => Dict b
03:02:01 * hackagebot data-filepath 1.0.0.0 - A type safe file path data structure  http://hackage.haskell.org/package/data-filepath-1.0.0.0 (MaxwellSwadling)
03:07:01 * hackagebot criterion 1.0.0.0 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-1.0.0.0 (BryanOSullivan)
03:09:59 <shachaf> jkarni: By the way, GHC's intermediate representation (called Core) does represent foralls explicitly as functions.
03:11:04 <shachaf> So id is compiled into a function with two "arguments".
03:12:02 * hackagebot simplessh 0.2.0.5 - Simple wrapper around libssh2  http://hackage.haskell.org/package/simplessh-0.2.0.5 (thoferon)
03:12:04 * hackagebot tagsoup 0.13.2 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.13.2 (NeilMitchell)
03:18:59 <hc> Hi, suppose I have data Foo = Foo String and I only wish to export the type constructor but not the data constructor, (how) is this possible?
03:19:18 <shachaf> module MyModule(Foo) where ...
03:19:37 <hc> But since the data constructor is also called Foo...
03:20:49 <shachaf> If you wanted to export both you would write module MyModule(Foo(Foo)) where ...
03:20:55 <shachaf> Or Foo(..)
03:20:56 <hc> Oh, I see
03:20:59 <hc> thank you!
03:21:00 <Pythonfant> afaik Foo exports just the type, so it should do what you want. If you need constructors … ^ yeah that
03:23:20 <iasoon> I am seeking to implement an algorithm that requires me to mark nodes as 'visited'. Any idea how I could achieve this marking in a functional context?
03:23:53 <iasoon> I have thought of using a list of 'unvisited' nodes, but this would make checking whether a node has been visited quite inefficient.
03:24:16 <tac_> iasoon: You can use a mutable Data.Vector in the ST monad
03:24:35 <tac_> It's O(1) access and write, I believe, but also pure
03:25:04 <haasn> HashSet provides “nearly” (large base) constant time lookups too
03:25:12 <haasn> or HashMap, whatever
03:25:28 <haasn> But ST might be a good way
03:25:51 <iasoon> If I use a Vector, would I need to keep every point's index in its data in order to update it?
03:26:01 <iasoon> Like a pointer, I mean.
03:28:03 <Maior> @hoogle (a -> Bool) -> [a] -> [a]
03:28:06 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:28:06 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
03:28:06 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
03:30:33 <tac_> ugg. I'm getting an error message "empty"
03:30:43 <tac_> and nothing else... after a large refactoring job
03:31:01 <tac_> any ideas how to diagnose this or find a line number?
03:31:49 <shachaf> ?
03:32:31 <shachaf> $ ghc file.hs
03:32:36 <shachaf> empty
03:32:45 <shachaf> Or what's happening?
03:33:06 <tac_> ./executable
03:33:10 <tac_> executable: empty
03:33:42 <tac_> At the start, it parses a config file, but parsing it in cabal repl doesn't throw an exception
03:33:52 <tac_> maybe there's undefined data underneath a binder though
03:34:27 <shachaf> @where rts-xc , perhaps
03:34:27 <lambdabot> ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc # print stack traces on unhandled exceptions
03:34:41 <shachaf> Or look for whatever is throwing that error.
03:37:37 <tac_> Do you typically install GHC with profiling packages separately?
03:38:20 <Maior> after quite a while I still don't fully appreciate the difference between a URI and a URL; if I want to manipulate HTTP UR-things, e.g. adding/removing querystring parameters, can anyone recommend me a library please?
03:38:53 <tac_> (what _is_ the difference?)
03:39:12 <Maior> currently using Network.URI, but that lacks nice things for manipulating query strings
03:39:36 <Maior> tac_: I read http://stackoverflow.com/q/176264/928098 - I'm not sure I'm much the wiser
03:39:48 <Maior> actually
03:39:50 <tac_> oh hmm
03:40:01 <tac_> I wonder if since I switched to cabal... do I even use this binary any more?
03:40:06 <Maior> I think I am - I think it's a difference you can't determine from the string alone
03:40:11 <tac_> perhaps it should be burned in a fire....
03:47:08 * hackagebot hsyslog 2.0 - FFI interface to syslog(3) from POSIX.1-2001  http://hackage.haskell.org/package/hsyslog-2.0 (PeterSimons)
04:04:56 <izo_hr> anyone here ?
04:06:25 <shachaf> There is only silence and some second-hand clothes.
04:06:34 <shachaf> And ~1300 people.
04:06:53 <Kinnison> sssh, don't ruin it
04:07:19 <izo_hr> :)
04:07:25 <izo_hr> can I ask something abot haskell here...
04:07:37 <njcomsec> no
04:07:39 <izo_hr> or you guys prefer silence ?
04:07:42 <Pythonfant> that's what this channel is for
04:07:47 <njcomsec> haskell is off topic in the haskell room
04:07:54 <izo_hr> :D
04:08:05 <Kinnison> izo_hr: It's best if you just ask
04:08:09 <izo_hr> OK... so straight to do point
04:08:13 <izo_hr> OK... so straight to the point
04:08:14 <Kinnison> izo_hr: and then if someone can answer, and feels like doing so, they will
04:08:21 <izo_hr> data Row a = CreateRow {getRowData :: [a] } deriving (Show)
04:08:44 <izo_hr> works good, I can show it
04:09:00 <izo_hr> now, remove  "deriving (Show)"
04:09:13 <izo_hr> how can I define my own "show" instance ?
04:09:36 <shachaf> instance Show a => Show (Row a) where show = ...
04:09:37 <Cale> instance (Show a) => Show (Row a) where show (CreateRow xs) = ...
04:11:13 <izo_hr> that was blazing fast...
04:11:30 <izo_hr> now, what if I want different "show" in case "a" is Char and Int ?
04:12:27 <shachaf> I'm not quite sure what you're asking but the answer is probably that you can't do it.
04:12:50 <Maior> izo_hr: higher level, what are you trying to do/
04:12:52 <izo_hr> Row Int to be showed "1,2,3,4", but Row Char as "abcd"
04:12:55 <Cale> You could turn on FlexibleInstances and write specific instances for each, but those would overlap with the general instance, so you'd probably have to give that one up
04:13:45 <izo_hr> aaaa... I have to choose one of them...
04:13:56 <izo_hr> and use "show" on "per element" base...
04:14:01 <izo_hr> I guess... moment
04:15:13 <Maior> hm, how does [a] do that then?
04:15:15 <Maior> (magic?)
04:15:24 <Cale> :t showList
04:15:26 <lambdabot> Show a => [a] -> ShowS
04:15:33 <izo_hr> it works... ok great...
04:16:01 <Cale> Maior: Hackery. The Show class includes a method showList which the list instance of Show uses.
04:16:09 <Maior> Cale: ah cheers
04:17:04 <izo_hr> showList seems to accept on param ([a])
04:17:13 <izo_hr> but
04:17:14 <izo_hr> showList [1,2,3,5]
04:17:16 <izo_hr> gives
04:17:39 <izo_hr> <interactive>:280:1:     No instance for (Show ShowS) arising from a use of `print'     Possible fix: add an instance declaration for (Show ShowS)     In a stmt of an interactive GHCi command: print it
04:18:08 <Maior> hm, Network.URL - does that have a way of handling relative URLs perchance? it looks tantalisingly close to (given PathRelative) but I see no code for actually doing it
04:18:09 <izo_hr> why do I have to do: showList [1,2,3,4,5] ""
04:18:25 <izo_hr> cannot recognize this additional param, from :t showList ?
04:18:32 <Maior> (I have an insufficiently-restful API where I want to store a base url and append paths to it)
04:18:33 <Cale> type ShowS = String -> String
04:18:50 <izo_hr> aha
04:18:53 <Maior> :t showList
04:18:54 <lambdabot> Show a => [a] -> ShowS
04:18:59 <izo_hr> :t ShowS says "not in scope" ?
04:19:00 <lambdabot>     parse error (possibly incorrect indentation or mismatched brackets)
04:19:05 <Cale> :info ShowS
04:19:11 <Cale> It's a type synonym
04:19:17 <izo_hr> great
04:19:21 <izo_hr> ok clear now
04:19:24 <Cale> I suppose you could also do :k ShowS
04:19:30 <Cale> :k ShowS
04:19:31 <lambdabot> *
04:20:55 <Cale> (which just tells you that it has kind *, meaning that it's an ordinary type which can have values)
04:20:59 <Cale> :k Maybe
04:21:00 <lambdabot> * -> *
04:21:02 <Cale> :k Maybe Integer
04:21:04 <lambdabot> *
04:21:07 <Cale> :k Either
04:21:08 <lambdabot> * -> * -> *
04:21:14 <Cale> :k Either Integer
04:21:15 <lambdabot> * -> *
04:21:16 <Cale> :k Either Integer String
04:21:17 <lambdabot> *
04:37:18 * hackagebot json-rpc 0.1.0.0 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.1.0.0 (XenoGenesis)
04:43:23 <Javran> @hoogle UTCTime -> CalendarTime
04:43:25 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
04:43:25 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
04:43:25 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
04:44:21 <hyPiRion> Well, that's obviously the sanest thing to do. Just unsafeCoerce it.
04:45:25 <Cale> Javran: Where is CalendarTime defined?
04:47:01 <Javran> Cale: it's in old-time package
04:47:41 <Javran> Cale: I think I've found a solution, just move to time package.
04:48:27 <Cale> yeah, that's probably sensible
04:50:50 <pertl> I am trying to get a graps of Applicative. I understand that <*> sort of applies a "boxed" function to a boxed value. So why does this work?     Just 3 <*> Just 5    (since it's a boxed value - not a function - applied on a boxed value, right?)
04:51:14 <pertl> :t Just 3 <*> Just 5
04:51:15 <lambdabot> (Num (a -> b), Num a) => Maybe b
04:51:21 <pertl> Just 3 <*> Just 5 :: (Num (a -> b), Num a) => Maybe b
04:52:30 <shachaf> pertl: "box" will probably lead to bad intuition.
04:52:57 <k00mi> pertl: it doesn't work
04:52:59 <pertl> I could also call it "context"
04:53:16 <k00mi> pertl: there is no instance for Num (a -> b)
04:53:20 <shachaf> There isn't "a value" in the first place, really.
04:53:46 <pertl> hmm, maybe I got something wrong
04:53:47 <shachaf> But that "works" because 3 is a polymorphic value. It won't actually type-check in GHC with the standard Num instances.
04:54:20 <shachaf> Try using Chars or Bools or Strings instead of numbers to get more straightforward errors.
04:54:53 <pertl> funny, I can type ":t" and the type but assigning the expression via "let foo = " will render an error as you said
04:54:55 <Maior> argparser, optparse-applicative, or $other?
04:55:16 <Maior> (noting that at some point, I will be looking to create CLI options from other internal datatypes)
04:55:29 <shachaf> pertl: Yes, but look at the type.
04:55:35 <Maior> (because I'll be loading a config file, and wanting to generate CLI args from config options...)
04:55:55 <shachaf> (Num (a -> b), Num a) => isn't a constraint you're going to satisfy with anything.
04:56:09 <pertl> shachaf: make a whole lot of sense :-)
04:56:42 <pertl> geez, I constructed a black hole, next thing I will do is divide by zero *g*
04:57:12 <shachaf> Anyway, remember that there are a lot of Applicative instances. Is [Int] a "box that contains an Int"? How about (Blah -> Int)?
04:57:22 * hackagebot Spock 0.6.2.0 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.2.0 (AlexanderThiemann)
04:57:23 <shachaf> ((Int -> Bool) -> Bool)?
04:57:58 <pertl> haskell can really blow you mind
04:58:01 <pertl> your
05:03:00 <danilo2_> Hello! Would somebody be so nice and explain to me why the first code compiles while the second does not? It is just the same, after refactorization. Error provided as annotation: http://lpaste.net/109019
05:23:17 <yac> what's the deal with base package? I'm trying cabal install base-4.7.0.1 but it rejects it for some reason
05:23:58 <yac> rejecting: base-4.7.0.1 (only already installed instances can be used)
05:24:03 <supki_> the only way to upgrade base is to upgrade ghc itself
05:24:33 <yac> oh, right
05:27:25 * hackagebot fsnotify 0.1.0.3 - Cross platform library for file change notification.  http://hackage.haskell.org/package/fsnotify-0.1.0.3 (RomanCheplyaka)
06:13:51 <tulcod> oh shit. it's building. it compiles. it compiles... it compiles, it compiles, it compiles, IT COMPILES!
06:14:02 <Maior> :)
06:14:16 <tulcod> what a monstrosity it is that i'm building....
06:15:13 <tulcod> oh man, if this actually does what i want it to do....
06:35:13 <vanila> good morning #haskell
06:35:59 <lgt> morning
06:36:07 <vanila> :)
06:36:21 <chrisdone> join this meeting in 4 hours to talk about haskell and emacs, gonna try out the idea: https://plus.google.com/events/cbnd1ontjkt1b7caic3lshov3q8t
06:37:05 <vanila> ah you wrote that structural haskell mode
06:37:19 <luite> event could not be found?
06:37:24 <Pythonfant> chrisdone: will this be recorded? I'm away later but I'm interested so I'd like to be able to watch it.
06:37:32 <vanila> this URL doesn't seem to be correct? or maybe it will start working later on?
06:38:00 <Pythonfant> the correct url is https://plus.google.com/events/cbnd1ontjkt1b7caic3lshov3q8
06:38:32 <chrisdone> oh, woops, thanks Pythonfant
06:38:50 <chrisdone> pythonfant: maybe i can record it, if anyone turns up =)
06:38:58 <Pythonfant> :)
06:39:53 <luite> chrisdone: btw do you know a way to debug hanging regexp in emacs? i get some hangs in something like re2_match_internal (forgot the actual name, gdb points to this when attaching to the hanging emacs process) in haskell-mode sometimes
06:41:54 <vanila> what's the smart way to get involved with fp work if you don't have social contacts/
06:42:35 <chrisdone> luite: the whole UI locks up?
06:42:49 <luite> chrisdone: yeah the whole process, C-g doesn't work
06:43:01 <chrisdone> luite: is that coming from -indentation or -indent?
06:43:35 <chrisdone> i've never experienced a regex freeze, but i don't use either of those modes, so curious if it's from that
06:44:13 <luite> chrisdone: indentation possibly, but i don't know the regex that's making it freeze
06:44:44 <carboniferous> join #math
06:44:47 <kstt> hey
06:44:50 <vanila> hi
06:46:01 <chrisdone> luite: yeah, tricky to say which function that is. if it's e.g. re-search-forward you could run M-x debug-on-entry RET re-search-forward RET
06:46:04 <kstt> while we are at it, I have a project that generates hundred warnings under -Wall. I'd like to fix them all, is there something is emacs haskell-mode to help me ? I'm compiling with cabal sandboxed.
06:46:21 <chrisdone> luite: so it'll enter the debugger with a backtrace whenever that function is called
06:46:38 <kstt> even something basic like "jump to warning site" would be cool
06:47:02 <chrisdone> luite: if it's re_match_internal it or its parent caller is probably similarly named in elisp
06:51:24 <luite> chrisdone: ah i'll try that some time then. and is there a way to have it just log the calls with arguments to some buffer/file? since it happens after a while, and obviously just the last one fails
06:52:34 * hackagebot twitter-conduit 0.0.5.4 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.4 (TakahiroHimura)
06:53:40 <vanila> :/
06:53:59 <tgkokk> kstt: Check out flycheck and flycheck-haskell
06:54:42 <Maior> anyone got good examples for using optparse-applicative please?
06:55:57 <bergey`> kstt: haskell-process-cabal-build, part of interactive-haskell-mode, builds the package. Move point over an error and hit return to go to the error.
06:56:14 <bergey`> (flycheck is also great, but IIRC, not as good at picking up sandboxes.)
06:56:49 <chrisdone> luite: hm, don't know. maybe with tracing mode in edebug?
06:56:57 <Ankhers> could anyone give me an example of when unsafePerformIO is actually safe?
06:58:39 <justinleitgeb> Ankhers: the example I've seen most often is when you have a foreign function call that you know doesn't have side effects, eg. a pure computation done in C.
06:59:36 <luite> chrisdone: ah thanks, that looks useful
06:59:44 <kstt> thank you bergey !
07:00:04 <chrisdone> justinleitgeb: you don't need unsafePerformIO for that, the ffi gives you that out of the box
07:00:32 <kstt> Oh, my haskell mode is old. Must update it sometime.
07:00:38 <chrisdone> e.g. foreign import ccall "sin" c_sin :: CDouble -> CDouble
07:00:45 <justinleitgeb> chrisdone: ah, didn't know that, thanks!
07:00:45 <Ankhers> Would it be 'safe' to use it when using Data.HashTable.IO.lookup?
07:01:01 <kstt> no
07:01:09 <vanila> Ankhers, I think some people were optimizing functions by using hashtables with unsafePerformIO
07:01:19 <luite> justinleitgeb: not allowed in safe haskell though
07:01:29 <chrisdone> it's like that old obnoxious saying by car salesmen: if you have to ask how dangerous unsafePerformIO is, you can't afford to use it
07:01:30 <vanila> just caching the result values of functions, not change to what the program computes
07:01:36 <tulcod> chrisdone: though to be fair, in that sense the FFI also gives you an implementation of unsafePerformIO
07:01:42 <justinleitgeb> chrisdone: lol
07:01:56 <vanila> this optimization is a safe use of the function, but I question it's value
07:02:06 <chrisdone> tulcod: yup, roughly
07:02:13 <hodapp> chrisdone: what other kind of saying do car salesmen have?
07:02:31 <chrisdone> hodapp: "this is a great runner"
07:02:34 <chrisdone> (a lie)
07:02:44 <tulcod> "only used on sundays"?
07:02:51 <tulcod> "used to be owned by an old lady"
07:03:40 <kstt> tulcod: ahah, my car saleman told me exactly that, used on sunday by on old lady
07:03:47 <chrisdone> lol
07:04:53 <hodapp> "She just drove it to and from the grocery store!"
07:05:18 <tulcod> what about "i'd buy it myself"?
07:05:36 <tulcod> (and then "<insert lame excuse>")
07:05:42 <justinleitgeb> "this is the right type of car for you" (some car salesmen unfortunately run buggy unification algorithms)
07:05:47 <chrisdone> "i'm hurting myself to give this to you so cheap"
07:05:54 <tulcod> haha definitely
07:06:38 <hodapp> Or, in my dad's case, "Fuck this job, I am never selling cars again."
07:06:59 <chrisdone> ankhers: it depends on the exact use. i once showed simon peyton jones, in person, some code i was having trouble with and he walked away laughing
07:07:01 <tulcod> wait, this works? http://www.yesodweb.com/blog/2010/09/yo-dawg-template-haskell
07:07:03 <Maior> has anyone done anything around shipping binary Haskell packages perchance?
07:07:15 <chrisdone> ankhers: because it contained unsafePerformIO
07:07:36 * hackagebot gitson 0.3.0 - A document store library for Git + JSON.  http://hackage.haskell.org/package/gitson-0.3.0 (myfreeweb)
07:07:48 <chrisdone> hodapp: did he ever get you a crappy car for christmas and sell you on it?
07:08:11 <Ankhers> I have a HashTable filled with domains, acting as a white list. I am wanting to create a member function to find out if a key is in the HashTable. I currently have two versions of the member function. One that returns a Bool (using unsafePerformIO) and the other returning an IO Bool. In this case, would it be safe, or is there a better option available?
07:08:18 <tulcod> Maior: if you can't find someone here, try ask distro package maintainers (e.g. archlinux's, or the gentoo guys)
07:08:50 <Maior> tulcod: ah, I didn't mean distro packages, sorry, I meant hackage
07:08:59 <tulcod> chrisdone: is he in this channel sometimes?
07:09:12 <tulcod> Maior: wait. you can do that? :o
07:09:21 <Maior> tulcod: I have no idea, hence the question
07:09:24 <tulcod> haha
07:09:32 <Maior> tulcod: specifically I'm looking to minimise things like "just clone this repo, run cabal install, go get lunch"
07:09:37 <chrisdone> tulcod: i've never seen him, i don't think he's been. this was at a hackathon
07:10:01 <chrisdone> ankhers: that sounds reasonably safe
07:10:17 <tulcod> Maior: uh, isn't that the point of hackage? you don't need to explicitly clone anything - you can just run cabal install <package>
07:10:43 <tulcod> Maior: or are you trying to reduce compilation time?
07:10:45 <Ankhers> chrisdone: Can you explain 'reasonably'?
07:10:46 <Maior> tulcod: internal project; fetching/installing dependencies
07:11:05 <tulcod> Maior: you can setup your own local hackage server and have everyone install from there
07:11:17 <vanila> Ankhers, why is it in IO?
07:11:25 <tulcod> Maior: (just trying to think of sane solutions here, feel free to disregard me :) )
07:11:30 <Maior> tulcod: this seems pointless if they're developing said internal project
07:11:39 <Maior> tulcod: and orthogonal to my real question, unless I've misunderstood
07:11:52 <tulcod> Maior: but if they're developing, why would you want to ship anything in binary?
07:11:54 <Ankhers> vanila: because http://hackage.haskell.org/package/hashtables-1.0.0.0/docs/Data-HashTable-IO.html seems to be the only way to have O(1) lookup.
07:11:58 <tulcod> ship internally, that is
07:12:06 <Maior> tulcod: I don't
07:12:18 <tulcod> then you've lost me
07:12:21 <Maior> tulcod: I want them to not have to sit there as all the dependencies compile
07:12:24 <vanila> Ankhers, it says it's a wrapper around http://hackage.haskell.org/package/hashtables-1.0.0.0/docs/Data-HashTable-Class.html which is in ST rather than IO
07:12:44 <tulcod> Maior: ah, you want to distribute the *dependencies* in binary
07:12:50 <vanila> maybe you'd be better using that instead of dangerous stuff that might crash if not used right
07:13:10 <tulcod> Maior: well one thing you could do is fill a cabal sandbox with all the dependencies, and have users copy that
07:13:14 <Maior> tulcod: apologies for the lack of clarity - yess
07:13:17 <Maior> ss? s
07:13:33 <tulcod> Maior: but that'll probably require installing in the same dir
07:14:02 <tulcod> (and make sure they all run the same haskell version etc)
07:14:02 <Maior> hm, interesting, thanks
07:14:05 <Ankhers> vanila: You are probably right. I will try and rewrite this quickly.
07:14:27 <tulcod> Maior: and then there are some distros (e.g. arch) which offer a bunch of packages binary
07:14:42 <tulcod> Maior: you could check out how they work, and setup a local package repository for whatever distro you're using
07:15:07 <Maior> tulcod: I've briefly looked at that, it doesn't seem to play nicely with sandboxen
07:15:27 <chrisdone> ankhers: what was the reason you needed it to be pure?
07:16:21 <tulcod> Maior: i wouldn't know how you can use the hackage ecosystem to distribute compiled packages. i don't think you can, considering the target directory needs to be known at compile time - and if you know that, you might as well copy sandbox dirs
07:16:21 <Maior> tulcod: anyway cheers for the ideas!
07:16:29 <Maior> tulcod: oh it does? woe
07:16:46 <tulcod> Maior: hmm, i'm actually not sure. but i wouldn't be surprised in the least
07:17:20 <chrisdone> you won't be able to use the ST hashtables in the way you want (without unsafePerformIO) either
07:17:46 <chrisdone> unless you put all your code inside ST
07:17:57 <vanila> what about stToIO?
07:18:21 <tulcod> vanila: is that safe?
07:18:49 <Maior> (aside: examples of optparse-applicative usage would be massively appreciated please)
07:20:00 <chrisdone> vanila: an IO action just means you now need unsafePerformIO to use it purely, back to square one
07:20:21 <supki_> Maior: https://github.com/pcapriotti/optparse-applicative/blob/master/README.md ?
07:20:59 <Ankhers> chrisdone: Ultimately, I need a ByteString. I suppose if I had an IO ByteString, I could use >>= to do my other operations. I would just need to make my functions all return IO a. Which doesn't feel right to me.
07:21:08 <chrisdone> ST refs can't escape their thread of execution, it's not like you can have runST (do stuff with myVar) and then runST (do stuff with myVar) and have that state shared across pure invocations
07:21:22 <Maior> supki_: ...thank you, I naïvely saw that it started the same as https://hackage.haskell.org/package/optparse-applicative-0.9.1.1 and didn't see the rest
07:22:39 * hackagebot HFuse 0.2.4.3 - HFuse is a binding for the Linux FUSE library.  http://hackage.haskell.org/package/HFuse-0.2.4.3 (M15K)
07:22:49 <chrisdone> ankhers: can you paste some code? your details are very cryptic, it's hard to determine what your real problem is
07:23:02 <Ankhers> chrisdone: Sure. One sec.
07:30:35 <Ankhers> chrisdone: http://lpaste.net/109054
07:31:02 <Twey> vanila: stToIO is runST…
07:31:57 <Ankhers> any criticisms on how to make any part of this better would be appreciated.
07:32:40 * hackagebot binary-list 0.1.0.0 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.1.0.0 (DanielDiaz)
07:32:50 <tulcod> Ankhers: your member call is in a do statement. you can use the IO version.
07:33:09 <Guest59943> Is it possible to send GET request to udp in haskell?
07:34:33 <tulcod> Guest59943: what does HTTP have to do with UDP?
07:34:33 <Ankhers> tulcod: Should I be able to do a straight swap of functions? When I try to use the IO version, I get "Couldn't match expected type `Bool' with actual type `IO Bool'"
07:35:15 <tulcod> Ankhers: that's because you have to lift the entire statement, which you can do e.g. by assigning the value of your member call to a variable with <-
07:35:41 <tulcod> Ankhers: anyway, this is nothing you should need unsafePerformIO for. you just need to fiddle around with monads a little bit :)
07:35:55 <RyanGlScott> Is there a typeclass for nonnegative Integral types (e.g., Word)?
07:36:00 <tulcod> Ankhers: (of course you're most welcome to ask for help on that, but that'd be another question)
07:36:41 <Ankhers> Heh, that I would need help with. I'm still terrible with Monads.
07:37:05 <chrisdone> yeah, looking at the code, i'd just move the lookup up a bit before the let response'
07:37:40 * hackagebot binary-list 0.1.0.1 - Lists of size length a power of two.  http://hackage.haskell.org/package/binary-list-0.1.0.1 (DanielDiaz)
07:38:14 <tulcod> Ankhers: so the first thing to realize is that response' should be a "<-" assignment, not a "let", since its value depends on that of teh member call, which is in the IO monad
07:39:21 <chrisdone> ankhers: you can do it in pieces
07:39:44 <Guest59943> tulcod: I'm trying to learn haskell by following a guide on how to a bittorent client. This guide said that the tracker responded to a GET (in HTTP(S)) request. Since my torrent file gave me a udp address I assumed it was possible to send get request to udp as well.
07:39:48 <chrisdone> response' <- undefined  *compile* => ok
07:39:48 <chrisdone> response' <- case br of _ -> undefined *compile* => ok
07:39:55 <chrisdone> etc until you have the full statement
07:40:17 <Twey> Guest59943: HTTP requires TCP
07:40:49 <Twey> It's not valid to drop a packet of an HTTP request or response
07:40:58 <tulcod> Guest59943: from wikipedia: "The UDP tracker protocol is a high-performance low-overhead BitTorrent tracker protocol. It uses the stateless User Datagram Protocol (UDP) for data transmission instead of the HTTP protocol (over TCP) regular trackers use."
07:42:02 <tulcod> Ankhers: (PS: this may seem like magic to you know - it did to me when i first started programming with the IO monad - but it gets much much better once you get the hang of it, which you will)
07:42:06 <tulcod> to you now*
07:42:38 <Ankhers> chrisdone, tulcod: This means that my functions like response and encodedNoBid now need to return IO ByteString instead of ByteString, right?
07:43:05 <chrisdone> ankhers: no, those are fine. it means your response' statement needs to have a call to return, involving them
07:43:25 <tulcod> Ankhers: uh, i'm not seeing those functions
07:43:34 <Ankhers> Yeah, I thought of that after I asked.
07:43:55 <Ankhers> tulcod: I didn't paste the source because I didn't think they were important. They are in the case statement though.
07:44:12 <chrisdone> monochrom's law: people never paste the whole story
07:45:05 <tulcod> Ankhers: ah of course. yeah, no, what chrisdone said :)
07:45:06 <chrisdone> "hello, this is 911. what's your emergency?" "dead!" "who is dead?" "someone!" "what's their name?" "joey" "when did it happen?" "recently!"
07:45:31 <tulcod> Ankhers: the fact that you're doing computations inside the IO monad doesn't mean you can't also use pure computations
07:46:59 <chrisdone> ankhers: if it would help your understanding rather than stunt it i can show you the code for that statement rewritten
07:47:40 <Ankhers> chrisdone: I would very much appreciate it. I think I almost have a version of it. Though, I for some reason doubt it is good.
07:47:55 <chrisdone> response' <- case br of
07:47:55 <chrisdone>                Just a -> do isMember <- member (url a) wl'
07:47:55 <chrisdone>                             return (if isMember then response br else encodedNoBid)
07:47:55 <chrisdone>                Nothing -> return encodedNoBid
07:48:03 <chrisdone> ankhers: is this what you were writing?
07:48:17 <nick_named> Does anyone know what "In"/"Out" constructors are?
07:48:20 <tulcod> Ankhers: the first couple of times you stunt it, you will probably come up with some horribly complicated way of writing what is actually essentialy not too complicated :)
07:48:31 <Ankhers> I'm surprised it was very close to that actually.
07:48:33 <tulcod> Ankhers: that's what happened to me, anyway
07:48:56 <chrisdone> ankhers: that's good then. nothing clever in the solution
07:49:11 <chrisdone> just simple re-arranging
07:49:13 <Iceland_jack> nick_named: They can refer to many things, sometimes fixed point data types or duals for session types
07:49:13 <tulcod> chrisdone: the fact that you have to go deeper and deeper in indentation sometimes saddens me. what's the general counter-strategy to that?
07:49:28 <chrisdone> tulcod: i would put it in another function
07:49:29 <Iceland_jack> So more context is needed
07:49:35 <tulcod> chrisdone: save for putting it in another function ;P
07:49:49 <tulcod> and save for using liftM all over the place
07:49:49 <Ankhers> Everything compiles. Does that mean the rest just works the same way?
07:49:51 <chrisdone> i'd perhaps move the `do` under the Just
07:49:53 <nick_named> Iceland_jack: Specifically in the context of GHC pattern matching.
07:50:08 <chrisdone> and also move the case under the <-, if i really didn't want to move it into a function
07:50:17 <tulcod> Ankhers: if it compiles, then the types match up. so it probably does what you want.
07:50:38 <Iceland_jack> nick_named: Is this something specific to GHC? If so I'm not familiar with it, even more context would help
07:50:48 <chrisdone> ankhers: right, the rest of the code will be fine. this was just a local change
07:51:38 <Ankhers> chrisdone, tulcod: That was actually pretty painless. Thank you both so much!
07:51:53 <chrisdone> ankhers: welcome!
07:52:44 * hackagebot data-r-tree 0.0.5.0 - R-Tree is a spatial data structure similar to Quadtrees or B-Trees.  http://hackage.haskell.org/package/data-r-tree-0.0.5.0 (SebastianPhilipp)
07:53:37 <deni> what wiki software would you recommenbd? would you recommend gitit? i've only used dokuwiki so far and i wan't to move away from it
07:54:35 <nick_named> Iceland_jack: I think it was just referring to certain constructors in a data type that can or cannot be in in a wrapper type.  https://github.com/ghc/ghc/blob/master/compiler/hsSyn/HsPat.lhs#l52-53
07:55:37 <Iceland_jack> nick_named: That's quite different from what you asked originally :)
07:56:00 <Iceland_jack> Those aren't "In"/"Out" constructors, they're InPat and OutPat type synonyms
07:56:23 <nick_named> Iceland_jack: Yes it is, I thought it was some common terminoligy that I didn't know.  Then I realized it wasn't.
07:56:47 <Iceland_jack> nick_named: I'm guessing that LPat doesn't had a special pattern to distinguish between those different kind of patterns
07:56:53 <Iceland_jack> so they made simple synonyms, that would be my guess
07:57:22 <nick_named> That would make sense.  Thanks.
07:59:16 <tulcod> okay, so using TH i am generating a bunch of functions. they use some TH-generated internal functions, which I don't want to expose to the server. Unfortunately, this pattern continues another two "layers". what is the most sane way to expose exactly the right functions to the library user?
07:59:41 <tulcod> s/server/user/
08:00:28 <tulcod> what i have so far is four separate haskell files, all splicing in some functions, and then there's a fifth central file which re-exposes only the right modules
08:10:44 <tulcod> can i use TH's pretty printer to generate a module whose exposed symbols I can decide dynamically?
08:11:53 <chrisdone> i don't think TH can generate modules
08:11:58 <chrisdone> only Decls and below
08:12:39 <bergmark> there was some talk about allowing TH to generate exports
08:12:49 <Maior> @hoogle a -> [a->a] -> a
08:12:52 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
08:12:52 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
08:12:52 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:13:04 <eacameron> Does Control.Concurrent.STM.TMQueue still exist?
08:13:05 <int-e> @type foldr id
08:13:06 <lambdabot> b -> [b -> b] -> b
08:13:11 <Maior> int-e: ...thanjs
08:13:13 <Maior> *thanks!
08:13:14 <tulcod> bergmark: this? https://ghc.haskell.org/trac/ghc/ticket/1475
08:13:51 <bergmark> tulcod: yeah
08:14:20 <tulcod> bergmark: thanks. i guess i should finish my project and show how it would greatly simplify some things
08:14:43 <tulcod> but looks like it's not gonna happen any time soon
08:14:58 <fryguybob> eacameron: Thre is one in the stm-chans package
08:15:14 <tulcod> what is the most sane way to generate haddock documentation (dynamically, ie like TH)?
08:15:15 <int-e> > (foldr id a [f,g], foldl (flip id) a [f,g])
08:15:17 <lambdabot>  (f (g a),g (f a))
08:15:30 <int-e> Maior: not sure which of these you need
08:15:52 <Maior> int-e: will have a play, thanks!
08:15:52 <eacameron> fryguybob: oh, interesting, why are there two packages for these basic types (TChan and TMChan, for example)?
08:16:02 <modeller> Is there a trivial way to pattern match a literal between two lists? i.e. please correct (xs1: 42 : xs2)
08:16:55 <Twey> modeller: No, there isn't
08:17:20 <modeller> i see.
08:17:21 <Twey> modeller: That'd be an O(n) operation, and has multiple possible results: pattern-matching is generally constant-time and deterministic
08:17:38 <Twey> I.E. just deconstructing constructors
08:17:48 <Twey> There's no ‘between two lists’ constructor for lists
08:18:00 <eacameron> modeller: that's basically "find"
08:18:02 <Twey> But you can use a pattern guard and a function, maybe from Data.List.Split
08:18:04 <modeller> what about a literal behind a list, i.e. sth like (xs : x) but correctly done
08:18:08 <AleksejsM> Hi, maybe someone could explain me one example of composition?
08:18:21 <modeller> correction, (xs : 42)
08:18:34 <fryguybob> eacameron: They were developed by different people?
08:18:41 <Twey> modeller: Nope, there's no ‘on the end of the list’ constructor either.  Pattern-matching is just for constructors (unless you use ViewPatterns).
08:18:58 <modeller> Ok. Just to get a feel about it. Thanks for tips
08:19:11 <Twey> modeller: A list is a very simple data structure with two constructors: [] (empty list) and (:) (element prepended to list)
08:19:24 <Twey> modeller: So that's all you can match on (though you can nest them, obviously)
08:19:32 <tulcod> does anyone have an example Setup.hs of interfacing with haddock at build time?
08:19:41 <ClaudiusMaximus> > break (== 'X') "helloXworld" -- modeller, something like this might work (pattern match on the results), but what Twey says
08:19:43 <lambdabot>  ("hello","Xworld")
08:19:47 <Twey> modeller: If you want to do more complex things, you can use guards (not pattern guards, sorry — that's not what you want)
08:20:06 <eacameron> AleksejsM: head . head $ [[1]]
08:20:08 <Twey> Oh, actually, a pattern guard might be nice in combination with that, yeah
08:20:09 <modeller> I see.
08:20:09 <eacameron> > head . head $ [[1]]
08:20:11 <lambdabot>  1
08:20:47 <AleksejsM> For example, pl version of \xs -> map f xs is just map f. If we modify it \x xs -> map (f x) xs, we get map . f. Both examples are pretty easy
08:21:03 <AleksejsM> But
08:21:17 <jcullen> hey does anyone know if there is a way I can modify ghcis default behavior when printing out an object?
08:21:25 <Twey> > let f l | (x, 42 : xs) <- break (== 42) l = (x, xs) in f [1, 2, 3, 42, 5, 6, 42, 7]
08:21:27 <lambdabot>  ([1,2,3],[5,6,42,7])
08:21:28 <eacameron> jcullen: yes
08:21:32 <jcullen> I want it to use a pretty printing library instead of just "print", when displaying objects
08:21:42 <AleksejsM> @pl \x xs -> bar $ map (f x) xs
08:21:43 <lambdabot> (bar .) . map . f
08:21:48 <Twey> Oh, they're gone.
08:21:59 <chrisdone> Twey: They're gone, child. They're all gone.
08:22:06 * Twey looks downcast
08:22:07 <AleksejsM> This just looks like magic for me
08:23:01 <chrisdone> Twey: https://www.youtube.com/watch?v=yRujuE-GIY4&t=0m52s
08:24:00 <eacameron> jcullen: see this page: https://www.haskell.org/ghc/docs/7.6.2/html/users_guide/interactive-evaluation.html
08:24:09 <eacameron> jcullen: section 2.4.8
08:24:32 <eacameron> or this link for the latest GHC: https://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html
08:25:16 <eacameron> (but it's 2.4.9 on that page...)
08:27:12 <Total_1mmersion> Why does Applicative define pure and not Functor?
08:27:18 <Twey> AleksejsM: http://lpaste.net/416807454882398208
08:27:34 <annelies> because there may be functors for which pure doesn’t make sense
08:27:53 <Twey> Total_1mmersion: Because that's the definition of a functor — you can't always create a functor from a pure value
08:28:06 <Twey> Or, er, apply a functor to a pure value, or something
08:28:07 <annelies> http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad
08:29:25 <chrisdone> Const is the only functor-but-not-applicative i can think of
08:29:56 <Twey> chrisdone: Hahah.
08:30:07 <mwhit> more importantly than that, pure is defined in terms of <*> anyway
08:30:12 <Twey> chrisdone: There are a bunch of them in FRP
08:30:13 <mwhit> without <*> pure is just some arbitrary value
08:30:37 <Twey> chrisdone: Event, for example, is Functor but not Applicative
08:32:25 <chrisdone> mwhit: how do you define pure in terms of <*>?
08:32:41 <mwhit> the applicative laws
08:32:58 <mwhit> i guess "defined in terms of" is not the correct expression
08:33:04 <mwhit> "only has meaning with respect to"?
08:33:18 <chrisdone> oh, sure
08:34:51 <k00mi> chrisdone: Async is only Functor
08:35:37 <Exio4> > pure (+3) <*> pure 3
08:35:38 <lambdabot>  No instance for (GHC.Show.Show (f0 b0))
08:35:38 <lambdabot>    arising from a use of ‘M112997102767321512919852.show_M1129971027673215129...
08:35:39 <lambdabot>  The type variables ‘f0’, ‘b0’ are ambiguous
08:35:39 <lambdabot>  Note: there are several potential instances:
08:35:39 <lambdabot>    instance [safe] GHC.Show.Show a =>
08:35:49 <Exio4> :(
08:36:30 <k00mi> Exio4: it doesn't know which Applicative instance to choose
08:36:38 <k00mi> > pure (+3) <*> Just 3
08:36:41 <lambdabot>  Just 6
08:36:52 <xenog> > :t show
08:36:54 <lambdabot>  <hint>:1:1: parse error on input ‘:’
08:37:01 <chrisdone> k00mi: neat
08:38:33 <pjdelport> I learned from edwardk that things like maps are applicative functors without pure, but not Applicative *with* pure: http://hackage.haskell.org/package/semigroupoids-4.2/docs/Data-Functor-Apply.html#t:Apply
08:38:50 <enthropy> is there a pointful way to achieve something like http://stackoverflow.com/questions/11844523/ ? My understanding is that you can sometimes make an Arrow out of Applicative (which ZipSink is)?
08:39:46 <sm> chrisdone: is ircbrowse (the IRC client) hulk ?
08:39:59 <edwardk> i should rename that to Semiapplicative some time
08:41:18 <sm> ooh, you patched rss2irc
08:42:19 <Maior> @hoogle (a -> b) -> [a] -> [b]
08:42:20 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
08:42:20 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
08:42:20 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
08:42:23 <Maior> er
08:42:33 <Maior> @hoogle [a -> b] -> a -> [b]
08:42:34 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
08:42:34 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
08:42:35 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
08:42:50 * hackagebot snaplet-persistent 0.3 - persistent snaplet for the Snap Framework  http://hackage.haskell.org/package/snaplet-persistent-0.3 (DougBeardsley)
08:42:52 * hackagebot DAV 1.0 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-1.0 (ClintAdams)
08:52:06 <pjdelport> edwardk: Morally speaking (and ignoring practicality), wouldn't it be better for Apply / Semiapplicative to just be "Applicative", and the current Applicative then something like PointedApplicative, and CoApplicative (with extract) something like CopointedApplicative?
08:52:52 * hackagebot functor-infix 0.0.1 - Compositions of functors.  http://hackage.haskell.org/package/functor-infix-0.0.1 (vi)
08:53:04 <johnw> in CT "Applicative" maps monoidal structure between categories, so it needs to talk about what mapping the neutral element means
08:53:42 <johnw> a "Semiapplicative" would map semimonoidal structure, is where I think he's going
08:55:27 <haskoiner> > Nothing
08:55:28 <lambdabot>  Nothing
08:56:00 <haskoiner> > Just True
08:56:01 <lambdabot>  Just True
09:05:38 <haskoiner> > [(x,y,z) | x <- [1..100], y <- [1..100], z <- [1..100], x^3 + y^3 == z^3]
09:05:42 <lambdabot>  mueval-core: Time limit exceeded
09:05:45 <mwhit_> haha
09:05:59 <vanila> you aint gonna find any cubes as sum of two cubes ask Euler why :)
09:06:17 <haskoiner> i know :) im trolling the bot
09:06:27 <vanila> hehe
09:07:31 <mwhit_> isn't that fermat, not euler
09:07:47 <mwhit_> oh
09:07:49 <tulcod> mwhit_: was just looking that up
09:07:50 <mwhit_> that's just the general case
09:07:52 <haskoiner> maybe euler proved the case for 3
09:07:57 <vanila> fermat did x^4+y^4=z^4
09:07:57 <mwhit_> yeah 3 and 4
09:08:16 <vanila> using pythagorean triples, 3 is harder - Euler used sqrt(-3)
09:30:05 <anon_555> hi i am writing the function to return last element
09:30:21 <anon_555> lastElement xs:x = x
09:30:26 <vanila> that's not valid
09:30:27 <anon_555> what's wrong in it
09:30:30 <vanila> you have to write patterns like this
09:30:32 <vanila> lastElement (xs:x)
09:30:35 <vanila> but even that won't work
09:30:44 <napping> unfortuantely (:) only matches at the front
09:30:44 <vanila>  a list is built up the other way around
09:30:51 <vanila> so you'll need to use recursion to go right to the end of the list
09:31:07 <vanila> so
09:31:12 <vanila> lastElement (x:xs) = lastElement xs
09:31:18 <vanila> will do for the recursive case
09:31:25 <vanila> it says that lastElement [1,2,3] is the same as lastElement [2,3]
09:31:38 <vanila> so then you need a base case: lastElement [x] = x
09:31:39 <anon_555> ok thank you vanila
09:31:43 <anon_555> vanila thankyou
09:32:54 <Tinned_Tuna1> heya, I'm working on a small problem (as in, homework type, the problem is language independant), and for part of it, I need to be able to convert Strings (ex. "3afb5cdef126") to [Word8], and vice-versa. Is there a built in fn to do this quickly/easily?
09:33:35 <vanila> :t readIntAtBase
09:33:37 <lambdabot> Not in scope: ‘readIntAtBase’
09:33:38 <vanila> hm
09:33:40 <vanila> there's a way..
09:33:48 <luite> yes, readHex too
09:33:59 <vanila> :t readInt
09:34:00 <lambdabot> Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
09:34:06 <Tinned_Tuna1> :t readHEx
09:34:08 <lambdabot>     Not in scope: ‘readHEx’
09:34:08 <lambdabot>     Perhaps you meant ‘readHex’ (imported from Numeric)
09:34:09 <Tinned_Tuna1> :t readHex
09:34:10 <lambdabot> (Num a, Eq a) => ReadS a
09:34:11 <vanila> you can use this to convert from hex to Word8, and recursion on chunks of two
09:34:51 <luite> Tinned_Tuna1: if you need it for non-homework type problems, look at base16-bytestring
09:34:58 <Twey> :t chunks
09:34:59 <slack1256> Is this commentary on arrows correct?
09:34:59 <lambdabot>     Not in scope: ‘chunks’
09:34:59 <lambdabot>     Perhaps you meant one of these:
09:35:00 <lambdabot>       ‘chunk’ (imported from Data.List.Split),
09:35:05 <Twey> :t chunk
09:35:06 <slack1256> "Likewise the thing that you get from A b c is an inability to construct a new b-consuming c-producing "function". The arrow is protecting you from consuming the b and creating a c except by participating in the various arrow combinators or by using the primitive operations of the particular arrow instance."
09:35:06 <lambdabot> Int -> [e] -> [[e]]
09:35:23 <Twey> > map readHex $ chunk 2 "3afb5cdef126"
09:35:25 <lambdabot>  [[(58,"")],[(251,"")],[(92,"")],[(222,"")],[(241,"")],[(38,"")]]
09:35:33 <anon_555> http://lpaste.net/109055
09:35:38 <anon_555> what is wrong in this
09:35:46 <Tinned_Tuna1> luite: yea, I looked at that, but I'm not sure it's what I want
09:36:00 <slack1256> So if I am to every write a new arrow, basically I am limited to composition of operation that respect the context of the arrow?
09:36:14 <zalatovo> anon_555: That's the same as: lastElement all = tail all
09:36:30 <clrnd> anon_555, lastElement [1,2,3] would be = tail [1,2,3] = [2,3]
09:36:37 <joshkirklin> anyone around with some experience in netwire?
09:36:47 <clrnd> anon_555, you need the recursive step
09:36:50 <anon_555> but don't work
09:37:09 <vanila> anon_555, do it the way I said just a moment ago :)
09:37:10 <Tinned_Tuna1> Twey: that looks promising!
09:37:29 <Tinned_Tuna1> > fst . readHex $ chunk 2 "3afb"
09:37:31 <lambdabot>  Couldn't match type ‘[(a0, GHC.Base.String)]’ with ‘(c, b0)’
09:37:31 <lambdabot>  Expected type: GHC.Base.String -> (c, b0)
09:37:31 <lambdabot>    Actual type: Text.ParserCombinators.ReadP.ReadS a0Couldn't match type ‘[GH...
09:37:31 <lambdabot>  Expected type: GHC.Base.String
09:37:31 <lambdabot>    Actual type: [[GHC.Types.Char]]
09:37:43 <Tinned_Tuna1> > map fst . readHex $ chunk 2 "3afb"
09:37:45 <lambdabot>  Couldn't match type ‘[GHC.Types.Char]’ with ‘GHC.Types.Char’
09:37:45 <lambdabot>  Expected type: GHC.Base.String
09:37:45 <lambdabot>    Actual type: [[GHC.Types.Char]]
09:37:52 <Tinned_Tuna1> map (fst . readHex) $ chunk 2 "3afb"
09:38:20 <Tinned_Tuna1> > map (fst . readHex) $ chunk 2 "3afb"
09:38:22 <lambdabot>  Couldn't match type ‘[(a0, GHC.Base.String)]’ with ‘(b, b0)’
09:38:22 <lambdabot>  Expected type: GHC.Base.String -> (b, b0)
09:38:22 <lambdabot>    Actual type: Text.ParserCombinators.ReadP.ReadS a0
09:38:40 <Tinned_Tuna1> well, I'll make a note, gotta grab some tea , thanks :-)
09:38:47 <luite> Tinned_Tuna1: you can easily get a function of the type String -> [Word8] with that: B.unpack . fst . B16.decode . C8.pack
09:38:47 <phaskell> B16: Diff 143 - https://phabricator.haskell.org/B16
09:39:37 <fsp> Hi. Someone asked me to help them decrypt a file. The person told me all the words in the password, but she forgot which order the words were in, and which words had letters changed to their corresponding numbers (e.g. a -> 4, l -> 1, e -> 3, etc). What haskell functions/packages should I look atto generate a list of all possible permutations?
09:39:38 <luite> Tinned_Tuna1: where the last one is from the somewhat evil ByteString.Char8 module, only use that if you're sure your string contains only hex data (or at least ascii)
09:40:39 <luite> fsp: Data.List has permutations
09:41:41 <Fuuzetsu> I'm experiencing a really weird issue right now where if I load source of my module into GHCi, it will *only* make the exports available rather than everything including imports…
09:41:42 <luite> fsp: combine that with the list monad to try the changed/unchanged variations and you should be able to get there
09:41:52 <Twey> > map (fst . head . readHex) $ chunk 2 "3afb5cdef126"
09:41:54 <lambdabot>  [58,251,92,222,241,38]
09:42:04 <anon_555> How can i print the list in haskell when i am running in script file
09:42:15 <Fuuzetsu> anon_555: print yourlist
09:42:16 <Fuuzetsu> ???
09:42:48 <fsp> luite: ok, thank you!
09:42:49 <napping> Fuuzetsu: sounds like it's finding a compiled version
09:43:39 <Fuuzetsu> napping: no such thing in ghc-pkg and I remove all .hi and .o files…
09:43:50 <Fuuzetsu> maybe it's looking into dist/, let me check
09:44:05 <anon_555> http://lpaste.net/109055
09:44:10 <anon_555> what is wrong in this?
09:44:57 <HeladoDeBrownie> anon_555, lastElement lacks a base case
09:45:06 <johnw> it will recurse until it fails to pattern match
09:45:35 <HeladoDeBrownie> anon_555, style-wise, the "do" is redundant, as are the parens around the list.
09:45:37 <luite> fsp: for example:
09:45:39 <luite> > ["abc","123"] >>= \xs -> ["def","456"] >>= \ys -> return (xs++ys)  -- also (++) <$> ["abc","123"] <*> ["def","456"]
09:45:41 <lambdabot>  ["abcdef","abc456","123def","123456"]
09:45:44 <Fuuzetsu> napping: well, no, even if I remove dist/ and get [2 of 2] Compiling Documentation.Haddock.Doc ( src/Documentation/Haddock/Doc.hs, interpreted ) in GHCi, it only shows me the single function I have exported there
09:46:21 <napping> Weird, I've never seen that
09:47:23 <fsp> luite: In the list Monad, bind is zip, right?
09:47:27 <Fuuzetsu> ok there's something super sketchy going on, it must have a compiled version stashed somewhere because reming dist and everying .o and .hi doesn't make it cry and recompile the whole thing
09:47:30 <luite> fsp: concatMap
09:47:34 <fsp> ah
09:47:37 <luite> flipped
09:48:33 <chrisdone> Fuuzetsu: are you using -fbyte-code?
09:48:46 <fsp> > (++) <$> ["abc","123"] <*> ["def","456"]
09:48:48 <lambdabot>  ["abcdef","abc456","123def","123456"]
09:49:41 <Fuuzetsu> chrisdone: I was using -fobject-code and that's what I suspect because I added it yesterday and it worked fine until then but removing it doesn't fix the problem, do you know what to do?
09:50:12 <cschneid> Tinned_Tuna1: here's a snippet I've used when playing with a few encryption problems. It's basically the same solution as the (fst . head . readHex) answer from above. https://gist.github.com/a0eebe4eb6e842899937
09:51:20 <chrisdone> fuuzetsu: yeah, -fobject-code will make ghci not see things inside the module or things imported by it. -fbyte-code works properly. if you have automation you can compile with -fobject-code and then enable -fbyte-code and reload. go figure
09:51:35 <luite> fsp: yeah i added the former since you'll probably want something like that (or foldM) if you have a list of parts as input, applicative notation is useful for a fixed number (and if things are actually just Applicative but not Monad obviously)
09:52:25 <Fuuzetsu> chrisdone: I don't think I need -fobject-code anymore as I removed the code that was causing GHCi trouble, I just can't figure out how to get it to load my modules properly again
09:52:36 <fsp> luite: Indeed. As far as mutating the password with leet speak, what functions do you recommend?
09:52:45 <Fuuzetsu> does it stash files into /tmp and read from there or something, I see nothing in my project that it could have produced and still be loading
09:53:12 <chrisdone> Fuuzetsu: i normally just rm all the *.o and *.hi files and restart with -fbyte-code
09:53:27 <Fuuzetsu> oh, is -fbyte-code ‘do it the normal way’?
09:53:31 <chrisdone> yeah
09:53:33 <monochrom> -fbyte-code is already the default
09:53:34 <chrisdone> -fbyte-code's the default
09:53:57 <luite> fsp: that's just substitution, 'e' -> '3' etc, right? so I'd just use map over the string and pattern match those Chars, return original when not matched
09:53:58 <monochrom> but don't forget there is always :load *MyFile.hs
09:54:10 <Fuuzetsu> I'm going to remove .hi and .o from .gitignore, I must be missing some files
09:54:16 <vanila> glguy_, hi?
09:54:25 <glguy_> Hi
09:54:26 <fsp> luite: Oh, cool. I didn't know you can actually pattern match on a character.
09:54:35 <vanila> How do I 'solve' a problem on that rosalind site?
09:54:39 <chrisdone> normally just find src -name '*.o' | xargs rm
09:54:39 <Fuuzetsu> hm, they are not in .gitignore
09:54:52 <vanila> sorry I just figured it out now
09:54:58 <chrisdone> (unless you're one of those guys that puts haskell modules in the top-level)
09:55:07 <glguy_> vanila: You click "download data set" and run your program on that data set and then you either paste your output into the provided text box, or you upload your output to the  file upload button below it
09:55:10 <vanila> I had to download it
09:55:13 <vanila> I didn't see that, thank you :)
09:55:23 <glguy_> No problem, best luck with your solutions :)
09:55:50 <vanila> oh god its timing e
09:55:51 <vanila> me*
09:56:19 * monochrom is one of those guys who put haskell modules in the top level. they're just for an executable. not a lib.
09:56:20 <Fuuzetsu> chrisdone: I am confident I have no .hi and .o left over and it STILL doesn't reload properly, I have no idea what the hell it's doing
09:56:21 <glguy_> You get 5 minutes, no rush :)
09:57:20 <luite> fsp: if you have 'advanced' l33t substitutions like 'M' -> "|\/|" then it's obviously not Char -> Char anymore, so you'd need to go back to concatMap instead
09:57:28 <Fuuzetsu> can I ask GHCi where it's loading stuff from?
09:57:45 <fsp> luite: I see.
09:57:55 <luite> Fuuzetsu: does -v show it?
09:57:59 * hackagebot Spock 0.6.2.1 - Another Haskell web framework for rapid development  http://hackage.haskell.org/package/Spock-0.6.2.1 (AlexanderThiemann)
09:58:48 <chrisdone> Fuuzetsu: oh, another idea
09:59:05 <chrisdone> Fuuzetsu: are you working on a library that you've installed?
09:59:30 <chrisdone> sometimes i end up loading the library version of the project i'm trying to work on
09:59:51 <napping> They said they checked ghc-pkg, but that is plausible
10:00:23 <Fuuzetsu> http://lpaste.net/109060 here is my -v, ghc-pkg list, showing I have no .o and .hi…
10:02:17 <chrisdone> hmm
10:02:29 <Fuuzetsu> not sure about this line: *** Checking old interface for main:Documentation.Haddock.Types:
10:03:14 <cschneid> hmm, hadn't heard about Spock... anybody use it - what kind of tradeoff w/ scotty?
10:03:15 <cschneid> seems similar
10:03:20 <chrisdone> Fuuzetsu: are you sure :browse normally shows things not exported?
10:03:37 <chrisdone> Fuuzetsu: locally with:
10:03:40 <chrisdone> module X (y) where
10:03:41 <chrisdone> x = 123
10:03:41 <chrisdone> y = 123
10:03:46 <chrisdone> :t x works, but :browse doesn't list y
10:03:47 <lambdabot> parse error on input ‘,’
10:03:48 <chrisdone> which makes sense to me
10:03:51 <Fuuzetsu> No, but I can't use any modules I imported in that module, no instances, nothing
10:03:54 <chrisdone> lambdabot: shut up beavis
10:04:09 <Fuuzetsu> chrisdone: right, but I can't use anything out of that module except that single function
10:04:28 <Ankhers> Would anyone be able to explain the log_file_size in System.Log.FastLogger.File.FileLogSpec?
10:04:39 <chrisdone> Fuuzetsu: hm, that is weird. looks like it's being loaded right
10:04:40 <Fuuzetsu> wait fuck, I think it fixed itself
10:04:59 <napping> "*Documentation.Haddock.Doc" looks like ghci a least thinks it's giving you access to everything
10:04:59 <luite> Fuuzetsu: btw i should still mail Simon about the Haddock executable issue in the package, right?
10:05:06 <Fuuzetsu> haha it fucking works again!
10:05:13 <napping> Fuuzetsu: that's always the worst :( Hope it doesn't spring up again
10:05:24 <Fuuzetsu> luite: Yes, I spoke to him yesterday and he's waiting to hear from you
10:05:36 <napping> As far as I know, only seeing exported stuff can only be caused by loding in a object-compiled versions
10:05:43 <Fuuzetsu> napping: I'm not adding -fobject-code again ever
10:05:51 <luite> Fuuzetsu: cool, i'll send it tonight
10:06:13 <napping> I've never tried that, what would it do?
10:06:39 <Fuuzetsu> break everything apparently ;^)
10:06:50 <fsp> luite: In the list Monad, does the map step look like this?: map (\x -> ["123", "456"]) ["abc", "def"]
10:06:51 <napping> what did you hope it would do?
10:06:52 <Fuuzetsu> dunno, I added it after I was trying to load something in with unboxed tuples
10:07:10 <Fuuzetsu> (that's what it told me to do)
10:07:46 <Tinned_Tuna1> Twey, cschneid: Hm, what ver. of GHC would I need for that? I don't seem to have readHex in my prelude, nor do I have Data.Hex. My GHCi prints ver. 7.4.2.
10:07:51 <napping> huh, I can't believe I never tried to load a file with unboxed tuples into GHCi
10:08:01 * hackagebot json-rpc 0.1.0.1 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.1.0.1 (XenoGenesis)
10:08:06 <cschneid> Tinned_Tuna1: it's Data.Hex, which is a package you'll need to install
10:08:14 <cschneid> it's not built-in to the core of the language
10:08:21 <cschneid> Tinned_Tuna1: `cabal install hex` I think.
10:08:27 <Tinned_Tuna1> cschneid: cool, thanks :-)
10:08:48 <monochrom> that's the problem with obeying your computer
10:08:49 <cschneid> Tinned_Tuna1: you'll also need the `split` library for the Data.List.Split module
10:08:59 <luite> fsp: you still want to have map f :: String -> String, where f :: Char -> Char
10:09:13 <napping> Tinned_Tuna1: I see a readHex in "Numeric", if you don't need the dependency
10:10:36 <Fuuzetsu> napping: well, if you yourself don't use it then you never will; my use-case was trying to load in attoparsec which used it
10:11:25 <Tinned_Tuna1> cschneid, napping: Thanks, I think I have a workable solution :-)
10:11:28 <napping> Fuuzetsu: I'm sure I've played at least a little with unboxed tuples, I guess I mangaged to never try them in the interpreter?
10:11:32 <cschneid> Tinned_Tuna1: yay! :)
10:11:44 <Fuuzetsu> who knows, maybe those were special unboxed tuples ;^)
10:11:48 <merijn> Unboxed tuples don't even make sense in interpreted haskell
10:12:01 <luite> fsp: assuming you're doign this as an exercise, String being [Char] could be a tad confusing if you're also working with the list monad, you can use Text instead, and l33t t = T.map l33tChar t (assuming you imported qualified Data.Text as T)
10:12:01 <napping> why not?
10:12:31 <napping> merijn: I'd think whether the code is interpreted or compiled should be mostly orthogonal to what data representations it works with
10:12:36 <merijn> napping: Unboxed tuples are for returning parameters in CPU registers
10:12:44 <fsp> luite: My girlfriend legitimitely lost the password to her bitcoin wallet. :)
10:12:48 <luite> fsp: and appending two Text is then (t <> u) (Data.Monoid)
10:12:51 <luite> fsp: hah
10:13:01 * hackagebot criterion 1.0.0.1 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-1.0.0.1 (BryanOSullivan)
10:13:10 <zalatovo> fsp: did she have a lot of bitcoins in it?
10:13:24 <napping> or a bitcoin in it?
10:13:25 <merijn> napping: The notion of registers for return values in interpreted mode doesn't make a lot of sense
10:13:38 <fsp> ZioCrocifisso: Doesn't matter. The woman gets what the woman wants.
10:13:40 * Fuuzetsu spent a night and a half recovering his forgotten GPG password
10:13:43 <Fuuzetsu> losing passwords suck
10:13:52 <monochrom> if module XXX uses unboxed tuples, it's safer to just go to a command line and do "ghc -c XXX" before working in default ghci, rather than giving -fobject-code to ghci (which affects everything, not just XXX)
10:13:53 * lpsmith is wondering if we really need something like threadWaitReadWithMVar :: MVar Fd -> IO ()
10:14:10 <luite> fsp: admittedly i had the same thing a few months ago when i lost the password to an encrypted backup archive but remembered enough of the password to have a haskell program try the remaining permutations :)
10:14:26 <lpsmith> Namely,  something that would start waiting on the Fd in the MVar and *then* put the Fd back.
10:14:35 <anon_555> myButLast = last . init
10:14:37 <napping> merijn: not implementing them by registers in the bytecode interpreter makes sense, but translating them across the interface between compiled an interpreted code does
10:14:42 <fsp> luite: So you did the *exact* same thing I'm doing!
10:14:45 <napping> and there are some semantic implications about strictness anyway
10:14:47 <lpsmith> instead of read the mvar,  put the fd back,  and then start waiting on the Fd.
10:14:53 <anon_555> how is this working without any parameter myButLast = last . init
10:15:08 <Fuuzetsu> luite: did you program call out to the shell or did you just use it to generate wordlists?
10:15:21 <napping> anon_555: the right hand is making a function, and you name it myButLast
10:15:42 <luite> Fuuzetsu: piped the word list to another program that tried each one
10:15:47 <fsp> Gotta go, thanks luite!
10:15:53 <Fuuzetsu> right, I did that
10:15:54 <merijn> napping: THe thing is, unboxed tuples aren't *real* things
10:15:55 <napping> compare myNum = 12 / myLast = last / myNum2 = 12 + 4 / myButLast = init . last
10:16:00 <merijn> napping: They don't have a representation
10:16:00 <Fuuzetsu> seemed hacky but it worked out
10:16:33 <anon_555> napping: thanks buddy you're the man
10:17:09 <lpsmith> well, actually,  to start waiting on the Fd and then putting the MVar back is probably impossible,  but what seems necessary is for that process to be atomic
10:17:31 <hamid> :t (->)
10:17:32 <lambdabot> parse error on input ‘->’
10:17:45 <carter> lpsmith: was nice meeting you! i was a bit overloaded that weekend so i wasn't as social as i'd have liked
10:17:54 <lpsmith> carter, it's all good :)
10:17:58 <hamid> :/
10:18:00 <Aesop> Hello, I want to use a Map with the type Day as keys, internally they are just integers, I guess. That would make using IntMap attractive but that's not possible given the type. Any ideas how I could keep the type safety from Day and use the efficient IntMap?
10:18:02 <luite> Fuuzetsu: i need to find some better password management method some time, preferably with some hardware token :)
10:18:35 <merijn> Aesop: Use a newtype around IntMap and export custom insert/lookup functions to convert to/from Day?
10:18:36 <Fuuzetsu> problem with hardware tokens is that if you lose it, that's it
10:18:37 <lpsmith> carter, it was nice meeting you too.
10:18:46 <anon_555> napping hi
10:18:48 <Fuuzetsu> if you forget a password you can try to recover it from memory
10:18:48 <napping> anon_555: you're welcome. I certainly ask my own share of questions, I try to help where I can.
10:19:29 <napping> Fuuzetsu: I suppose you could have some less convenient backups of what you expect the hardware to protect - secret sharing between printouts in multiple places or something
10:19:41 <luite> Fuuzetsu: yeah they may break too, so there should be some fallback still, but that may be inconvenient (like typing a 256bit key)
10:20:15 <Aesop> merijn: sounds reasonable but I would have to reimplement every function, which I want to use, from the lib api, right?
10:20:35 <Fuuzetsu> breaking is actually why I'm most afraid to make one, I don't want a shitty memory stick failing, locking me out of stuff
10:20:44 <Fuuzetsu> I suppose a printout is a good idea if I owned a printer
10:20:53 <solidus-river> i think i found the mother type of all wire collections
10:21:08 <solidus-river> lists of wires you want to be able to grow / shrink
10:21:11 <merijn> Aesop: Most of them, yes :\ Maybe there's some TH hackery that can help, but I'm not sure
10:21:21 <solidus-river> http://lpaste.net/109062
10:21:51 <infandum> Can someone help me with parsing something? The code is at http://pastebin.com/0VqMwyVD, when trying to parse ">>1\n2\n>3\n4\n" to ((0, Struct { structX = 1, structY = 2 }), [Struct { structX = 3, structY = 4 }]), I get the error "unexpected 3, expecting ">>".
10:21:55 <Fuuzetsu> wireCollections :: Magic!
10:22:11 <solidus-river> haha
10:22:14 <solidus-river> no! seriously though
10:22:22 <solidus-river> i think this will handle every case where someone wants to manage a list of wires
10:22:27 <solidus-river> and use that list as part of a wire
10:22:35 <Aesop> merijn: Thanks then
10:22:36 <Fuuzetsu> infandum: pretty sure parsec has EOL parser for you
10:22:39 <solidus-river> with maybe a multicast variant where the wires all get the same input
10:22:49 <luite> Fuuzetsu: yeah it shouldn't be a plain memory stick at least, to prevent brute force or sniffing decrypted data in memory, something with a proper crypto cpu and some protected storage
10:22:54 <infandum> Fuuzetsu: Yes, but not for double lines
10:23:06 <Fuuzetsu> infandum: double lines?
10:23:08 <infandum> Fuuzetsu: Wait hold on let me check, it's one line
10:23:26 <Fuuzetsu> also removeWhitespace = skipSpace in attoparsec, I imagine the same in Parsec
10:23:28 <merijn> Aesop: Well, it depends actually, do you plan to expose the Map in the API?
10:23:34 <vamega> Hi. I'm trying to expand a list of tuples of form (a,[b]) to one of form (a,b) where a's are duplicated for each b it is associated with
10:23:52 <infandum> Fuuzetsu, oh, it's in Extra, that's why I didn't see it
10:23:59 <napping> how about a list comprehension?
10:24:12 <merijn> vamega: Is this homework by any chance? This is the 3rd time I've seen this question since yesterday :>
10:24:18 <vamega> So for example: (1,[2,3,4]) would map to (1,2) (1,3) (1,4) (1,5)
10:24:25 <vamega> Merijin: Nope
10:24:27 <vamega> Not in school.
10:24:34 <vamega> I'm just trying to make a file copy utility
10:24:37 <solidus-river> vamega: unfold?
10:24:41 <solidus-river> vamega: zip with
10:24:42 <infandum> Fuuzetsu, ok, Extra is an extra library I would have to download
10:24:51 <hamid> what's this ((->) r) ?
10:24:56 <hamid> a lambda thing?!
10:25:12 <Fuuzetsu> it's just (r ->)
10:25:21 <Aesop> merijn, I'm not sure yet, how does it depend?
10:25:21 <Cale> hamid: It's the type constructor for function types, partially applied
10:25:32 <solidus-river> humppa: (r -> b) == ((->) r b)
10:25:34 <Cale> (->) r s means the same thing as r -> s
10:25:47 <solidus-river> humppa: same way a + b == (+) a b
10:26:01 <infandum> Fuuzetsu: But I doubt that would solve the error
10:26:02 <vamega> solidus-river
10:26:06 <hamid> got it.
10:26:10 <solidus-river> vamega!
10:26:14 <Cale> hamid: I'm guessing you're looking at its Functor or Monad instance?
10:26:16 <vamega> Not sure I understand how zipwith would work.
10:26:16 <merijn> Aesop: Well, if you only have 5 functions in your API that work on the map, you could just keep using IntMap and convert Day to Int within your code
10:26:23 <hamid> Cale, yeah instance Functor ((->) r) where
10:26:28 <vamega> Since zipwith expects two lists.
10:26:41 <vamega> But I only have one that I with to stretch.
10:26:42 <hamid> Cale, actually trying to understand this https://ocharles.org.uk/blog/guest-posts/2013-12-21-24-days-of-hackage-contravariant.html
10:26:51 <solidus-river> vamega: oh actually it might be a fold
10:26:56 <Fuuzetsu> infandum: right OK; can you just tell me if ‘spaces’ needs to take 1 or more spaces or is it fine with 0?
10:27:14 <infandum> Fuuzetsu: It's 0 or more
10:27:42 <Cale> hamid: So in general, fmap :: (Functor f) => (a -> b) -> f a -> f b, so if f = (->) r, then this becomes  (a -> b) -> (r -> a) -> (r -> b)
10:27:48 <vamega> solidus-river: Usually I find folds reduce things to a single value, rather than expand a list.
10:28:01 <Aesop> merijn, ah I see what you mean, it's not done yet but is assume I will use the map interface quite extensive.
10:28:04 <solidus-river> well you could form it either way
10:28:12 <solidus-river> for the zip youd replicate the first element of hte tuple ina  list
10:28:17 <solidus-river> and zip that with the 2nd element of the tuple
10:28:19 <solidus-river> and form a tuple out of each
10:28:22 <vamega> I'd use map, but the semantics of imply that the domain and range of the function have the same lenght.
10:28:37 <Cale> hamid: and given functions of types a -> b and r -> a, if we want to get a function r -> b, there is just one obvious way to do that.
10:28:47 <Cale> hamid: which is to compose them
10:28:54 <solidus-river> > cycle [first (1, [2,3,4])]
10:28:56 <lambdabot>  Could not deduce (Control.Arrow.Arrow (,))
10:28:56 <lambdabot>    arising from a use of ‘Control.Arrow.first’
10:28:56 <lambdabot>  from the context (GHC.Num.Num t, GHC.Num.Num b)
10:28:56 <lambdabot>    bound by the inferred type of
10:28:56 <lambdabot>             it :: (GHC.Num.Num t, GHC.Num.Num b) => [((b, d), ([t], d))]
10:29:00 <Fuuzetsu> infandum: not sure what actual problem is without running it myself but the way I'd program that would be something like: ">>" *> takeTill isEndOfLine `sepBy` endOfLine
10:29:00 <Aesop> merijn, the map basically represents a timeline and I want to do some statistical analysis on it.
10:29:04 <solidus-river> > repeat [first (1, [2,3,4])]
10:29:06 <lambdabot>  Could not deduce (Control.Arrow.Arrow (,))
10:29:06 <lambdabot>    arising from a use of ‘Control.Arrow.first’
10:29:06 <lambdabot>  from the context (GHC.Num.Num t, GHC.Num.Num b)
10:29:06 <lambdabot>    bound by the inferred type of
10:29:06 <lambdabot>             it :: (GHC.Num.Num t, GHC.Num.Num b) => [[((b, d), ([t], d))]]
10:29:29 <solidus-river> > cycle . first (1, [2,3,4])
10:29:31 <lambdabot>  Couldn't match expected type ‘a -> [a1]’
10:29:31 <lambdabot>              with actual type ‘((b0, d0), ([t0], d0))’
10:29:33 <hamid> Cale, wow! nice :|
10:29:35 <solidus-river> damn, something like that
10:29:49 <mcbears> you could just ham-fist it
10:29:50 <solidus-river> i don't have ghci around and don't want to keep flooding guesses in here
10:29:53 <mcbears> case (1, [2,3,4]) of (a, b) -> zip (repeat a) b
10:29:57 <mcbears> I don't know if there's a fancier way
10:30:00 <hamid> Cale, Thank you. you were a great help :)
10:30:04 <Cale> hamid: This satisfies the functor laws: fmap (f . g) x = (f . g) . x = f . (g . x) = fmap f (fmap g x), using the fact that composition is associative, and the definition that fmap = (.)
10:30:07 <merijn> :t strength
10:30:08 <lambdabot> Not in scope: ‘strength’
10:30:10 <merijn> hmm
10:30:11 <vamega> I was trying to use something like map (\(a, b) -> map (\x -> (a, x)) b)
10:30:28 <Cale> and  fmap id x = id . x = x  using the fact that id is the identity for composition
10:30:32 <solidus-river> mcbears: is great
10:30:42 <merijn> :t join . map (\(a, b) -> (a,) <$> b)
10:30:43 <lambdabot> [(t, [a])] -> [(t, a)]
10:31:36 <hamid> Cale, going to reread everything you just said again :D
10:31:42 <infandum> Fuuzetsu: Is that using attoparsec?
10:31:49 <vanila> glguy_, wow this is so much harder than I thought!
10:32:10 <Fuuzetsu> infandum: yes but all those things should either be in Parsec or are easily implemented
10:32:51 <Fuuzetsu> you could also just take the rest of the content after ‘>>’ and apply ‘lines’ or something
10:33:00 <Fuuzetsu> it depends what your usecase is and how much granularity you want
10:33:07 <infandum> Fuuzetsu: Hmm, but I don't want to split it by line (except for the structX part), I want to split by ">>" at the higher level and ">" at the sublevel
10:33:22 <infandum> Fuuzetsu: Like a csv kindof
10:33:48 <Fuuzetsu> oh, I didn't see the > before the 3
10:33:57 <zalatovo> What does lambdabot do with infinite lists?
10:34:08 <Fuuzetsu> zalatovo: try and see
10:34:40 <merijn> > [1..]
10:34:42 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
10:34:54 <zalatovo> Huh, that's not so bad
10:35:06 <merijn> zalatovo: Lambdabot is pretty battle-tested by years of people trying to break her :p
10:35:44 <Iceland_jack> > repeat 'a'
10:35:46 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
10:35:47 <Iceland_jack> > text (repeat 'a')
10:35:47 <merijn> zalatovo: Input just gets truncated after X characters
10:35:52 <lambdabot>  mueval: ExitFailure 1
10:35:59 <vamega> merjin: Thank you. That works great. I'm guessing this works by using some property of the Monad instance for lists.
10:36:03 <vamega> I'll go figure that out.
10:36:30 <vamega> That requires an extension call TupleSections.
10:36:40 <vamega> Is the only alternative to that to use a Lambda?
10:36:54 <merijn> vamega: Oh, you can do it without tuplesections by writing ((,) a) instead of (a,)
10:37:13 <merijn> Although TupleSections is a pretty damn awesome extension :)
10:37:21 <vamega> Yeah, I just enabled it for my file.
10:37:31 <merijn> > (,1,,2,,4) 'c' True Nothing
10:37:32 <lambdabot>  ('c',1,True,2,Nothing,4)
10:37:47 <vamega> Cool
10:37:49 <clrnd> oh wow, nice
10:37:49 <Fuuzetsu> infandum: you could define a par parser that's just ‘(,) <$> (char '>' *> decimal <* endOfLine) <*> (decimal <* endOfLine)
10:38:11 <vamega> Yeah, I just discovered ScopedTypeVariables, and that's helped me keep track of types at crucial points.
10:38:25 <Fuuzetsu> then your main parser would be Struct <$> (char '>' *> pair) <*> many pair
10:38:28 <Fuuzetsu> something like that
10:39:09 <Fuuzetsu> vamega: it's pretty great if you combine it with holes
10:39:29 <Fuuzetsu> vamega: https://www.youtube.com/watch?v=52VsgyexS8Q
10:39:30 <infandum> Fuuzetsu: I should've mentioned that where I put "\n" in that string I meant it could be an arbitrary amount of newlines, and those numbers should be anyChar
10:39:45 <infandum> Fuuzetsu (excluding ">" and ">>" of course)
10:39:54 <merijn> vamega: The only property it uses of the list monad is join
10:39:58 <Fuuzetsu> infandum: sure, just replace endOfLine with many1 endOfLine and decimal with anyChar
10:40:04 <merijn> Actually, I guess this is even neater
10:40:10 <infandum> hm
10:40:22 <merijn> :t concatMap (\(a, b) -> (a,) <$> b)
10:40:23 <lambdabot> [(t, [a])] -> [(t, a)]
10:40:45 <merijn> Which is the same as
10:40:53 <merijn> :t concatMap (\(a, b) -> map (a,) b)
10:40:54 <lambdabot> [(t, [a])] -> [(t, a)]
10:41:08 <vamega> merijn: I don't think I'm fully grokked the Monad instance for lists.
10:41:24 <merijn> vamega: Simple:
10:41:31 <merijn> :t (>>=)
10:41:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
10:41:37 <merijn> :t flip concatMap
10:41:38 <lambdabot> [a] -> (a -> [b]) -> [b]
10:41:50 <infandum> Fuuzetsu: But how does that make a list in the second index of the tuple?
10:41:58 <vamega> Ohh, flip concatMap makes a lot of sense...
10:42:05 <merijn> vamega: :)
10:42:07 <Fuuzetsu> because many :: Parser a -> Parser [a]
10:42:15 <merijn> vamega: And return is of course just "return x = [x]"
10:42:22 <vamega> And while I've read the implementation (>>=) for lists in LYAH.
10:42:34 <vamega> I don't think I've come to reach for it when thinking of a problem
10:42:37 <enthropy> are there "partial type signatures" implemented with TH somewhere?
10:42:52 <vamega> Which is why I'm trying to write more Haskell.
10:42:57 <merijn> vamega: The nice things of my original version was that if you replace map with fmap it works for any monad :)
10:43:10 <enthropy> I am considering ones that just express "f can be specialized to T"
10:43:14 <Cale> vamega: Have you ever used list comprehensions?
10:43:15 <Fuuzetsu> infandum: or I might have just read the result type wrong, I should probably load this up into GHC…
10:43:20 <vamega> Even though what I'm currently implementing would have been far for me to to implement in bash.
10:43:24 <Fuuzetsu> infandum: can you post definition of Struct?
10:43:24 <vamega> Cale: yes.
10:43:25 <merijn> :t join . fmap (\(a,b) -> fmap (a,) b)
10:43:26 <lambdabot> (Functor m, Monad m) => m (t, m a) -> m (t, a)
10:43:32 <infandum> Fuuzetsu: Although I feel like my method SHOULD work...
10:43:37 <Cale> vamega: They're effectively built up from uses of (>>=) for the list monad
10:43:45 <vamega> I understand that those can be reduced/desugerd to the List monad.
10:43:59 <Fuuzetsu> infandum: well, if you want to know why your method doesn't work then we can work on that I suppose
10:44:00 <merijn> Note: They *can* be, but in reality aren't in GHC
10:44:11 <vamega> And then there is the MonadComprehensions.
10:44:23 <Fuuzetsu> but you'll have to post the full source for me
10:44:27 <Cale> > [x + y | x <- [1,2,3], y <- [10,20,30]]
10:44:29 <lambdabot>  [11,21,31,12,22,32,13,23,33]
10:44:30 <infandum> Fuuzetsu: data Struct = Struct { structX :: String, structY :: String }
10:44:41 <Cale> > do x <- [1,2,3]; y <- [10,20,30]; return (x+y)
10:44:43 <lambdabot>  [11,21,31,12,22,32,13,23,33]
10:44:46 <merijn> vamega: Right, MonadComprehensions are just "list comprehensions can be implemented using just >>=, so why don't we make them work for *any* monad"
10:44:57 <infandum> Fuuzetsu: Although the names here are placeholders, so I don't know if it will still give the same error (but it should)
10:44:58 <vamega> I've read a fair bit, but I'm now trying to actually use it, and it turns out I'm not proficient in this just yet.
10:45:08 <enthropy> @type guard
10:45:09 <lambdabot> MonadPlus m => Bool -> m ()
10:45:33 <Cale> The advantage of having an instance of Monad is that then you get to use stuff that'll work with any monad:
10:45:37 <vamega> My main method currently looks extremely imperative.
10:45:41 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
10:45:43 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
10:45:51 <vamega> It's just a series of lets one after the other.
10:45:56 <Cale> > replicateM 5 [0,1]
10:45:58 <lambdabot>  [[0,0,0,0,0],[0,0,0,0,1],[0,0,0,1,0],[0,0,0,1,1],[0,0,1,0,0],[0,0,1,0,1],[0,...
10:46:17 <vamega> Each one operating on the output of the previous one.
10:46:22 <vamega> Almost like I'm writing Python.,
10:46:32 <merijn> vamega: lpaste it and we can give feedback on how to approach things?
10:46:59 <vamega> Yeah, will do as soon as I finish it.
10:47:06 <Fuuzetsu> infandum: where is ‘fseq’ from?
10:47:07 <merijn> vamega: Also, some problems are just very IO-y/imperative-y, and that's ok. I prefer IO heavy haskell to writing python nowadays :)
10:48:01 <infandum> Fuuzetsu: Oops, that should be "y"
10:48:15 <infandum> Fuuzetsu: info should be "x"
10:48:34 <Fuuzetsu> ok
10:48:42 * enthropy wonders why "_ x = f x" shouldn't be a shortcut for "_ = \x -> f x" + -XNoMonomorphismRestriction for that binding
10:48:48 <infandum> Fuuzetsu: That's what I mean by replacing names haha
10:49:40 <Fuuzetsu> infandum: you said the struct has String but your desired result was amongs others Struct { structX = 1, structY = 2 }, should that have been "1" and "2"?
10:50:10 <infandum> Fuuzetsu: Yes, sorry. Those numbers where just indices for me to check where the code was failing
10:51:20 <Fuuzetsu> ok, I can replicate the error
10:51:34 <infandum> Fuuzetsu: Yay! Uh...I guess
10:52:25 <Fuuzetsu> it would really help if you put types on your parsers but whatever
10:53:00 <infandum> Fuuzetsu: I was following tutorials which all say to just ignore them, which is probably bad practice
10:53:27 <merijn> infandum: Yeah, common practice is to have type signature for all top-level declarations
10:53:38 <infandum> merijn: Even for parsec?
10:53:42 <Fuuzetsu> pfft, you should totally put down the types first or things get insane
10:53:55 <infandum> I always do, just not for parsec
10:54:16 <Fuuzetsu> my attoparsec usage goes write down type, then myparser = undefined, reload into GHCi ;)
10:54:21 <Fuuzetsu> no point writing the wrong parser
10:54:29 <infandum> mhm
10:54:32 <infandum> ill put them in
10:57:11 <RyanGlScott> For some reason, I'm having trouble using phantom types with type synonyms.
10:57:20 <RyanGlScott> For example, type PhantomInt a = Int
10:57:38 <RyanGlScott> safePlus :: PhantomInt a -> PhantomInt a -> PhantomInt a
10:57:53 <n-dolio> PhantomInt a just computes to Int.
10:58:00 <n-dolio> That won't enforce anything about a.
10:58:11 <RyanGlScott> Is there no way to enforce it other than using data/newtype?
10:58:50 <zalatovo> RyanGlScott: http://www.haskell.org/haskellwiki/Phantom_type#Why_not_type_synonyms
10:58:54 <n-dolio> Correct.
10:58:56 <Cale> RyanGlScott: You can imagine that type synonyms are all unfolded by a preprocessor
10:59:10 <n-dolio> Hugs had an abstract type alias extension.
10:59:21 <n-dolio> But presumably you're not using Hugs.
10:59:29 <Fuuzetsu> infandum: how is this for a result: *Main> parseFile input ==> [((0,Struct {structX = "1", structY = "2"}),[Struct {structX = "3", structY = "4"}])]
10:59:30 <RyanGlScott> No, I'm not. Well, darn.
10:59:41 <Cale> RyanGlScott: Why not newtype?
11:00:05 <RyanGlScott> Cale: I was hoping to keep "backwards compatibility" with some already existing functions that expect a certain type.
11:00:21 <infandum> Fuuzetsu: Yes! Then if another "\n>5\n6\n" is added, it would be added to that list in the tuple!
11:00:23 <enthropy> @hackage newtype
11:00:23 <lambdabot> http://hackage.haskell.org/package/newtype
11:00:24 <RyanGlScott> I guess it wouldn't be too unreasonable to pattern match against a newtype if that situation arises, though.
11:00:49 <Fuuzetsu> infandum: I imagine you want to extend it to more >>'s however
11:00:50 <infandum> and if you copy the string and append that copy to itself, it should be another insert at the top level list
11:00:55 <Fuuzetsu> right
11:00:56 <infandum> Fuuzetsu: Yes
11:00:59 <Fuuzetsu> let me try that
11:01:09 <Cale> RyanGlScott: Yeah, the trouble is, if it's really backwards compatible, you should be able to treat an Int as a PhantomInt a of some sort, but for which types a?
11:01:13 <infandum> Fuuzetsu (with a 1 in the next tuple)
11:01:34 <infandum> I'm still confused as to what is going wrong with my own code though :(
11:01:40 <infandum> I feel so helpless
11:02:17 <Fuuzetsu> infandum: it's no doubt that questionably use of manyTill subcell eoc
11:02:32 <Fuuzetsu> ‘many subcell’ is a saner option, now to just extend that to >>
11:02:35 <bb010g> enthropy: What's the point of that package? Can't you just make your newtype a Functor and fmap into it?
11:02:37 <infandum> Fuuzetsu: Yeah, it seems to FAIL subcell parsing
11:02:59 <infandum> Fuuzetsu: But why is it wrong? How could it not parse a very obvious subcell?
11:03:42 <enthropy> bb010g: newtype N = N Int gives "cleaner" type signatures
11:04:05 <infandum> Fuuzetsu: It should've parsed up to ">3\n4" and then try to parse subcell on it, it CLEARY would succeed on that!
11:04:13 <enthropy> also I think you can use it to take   f :: N -> N  to f :: Int -> Int
11:04:17 <RyanGlScott> enthropy: The newtype package does look interesting, thanks. I might use this to make wrappers around the existing functions.
11:04:25 <infandum> but instead it ate up the ">" for some weird reason
11:04:27 <Fuuzetsu> infandum: I would say that if you're using lookAhead frequently or for more than one character, you're doing something wrong
11:04:53 <infandum> Fuuzetsu: lookAhead doesn't work for strings?
11:04:58 <Fuuzetsu> infandum: well, parsec doesn't backtrack by default so that's probably why it eats things up
11:05:08 <Fuuzetsu> infandum: no no, it does work, it's just very often not what you want to use
11:05:49 <infandum> Fuuzetsu: Why not? If you want to parse a cell up to the next one which is defined by a string, it seems to be perfect
11:06:39 <Fuuzetsu> what I would do is simply try to parse a cell and if that fails then try to parse a subcell
11:07:28 <infandum> Fuuzetsu but I don't think that will be nestable
11:07:47 <Fuuzetsu> let me try to implement this thing then we can chat
11:07:52 <infandum> ok
11:07:53 <Fuuzetsu> for reference you can look at Haddock's parser
11:08:05 <Fuuzetsu> we use attoparsec and we do plenty of nesting in the list parsing
11:08:10 <Fuuzetsu> no lookaheads
11:08:15 <Fuuzetsu> (well, no more than 1 char)
11:14:05 <Fuuzetsu> infandum: how is this for results http://lpaste.net/109067 ?
11:14:08 <Fuuzetsu> is this what you want?
11:14:33 <infandum> Fuuzetsu: Let me test
11:15:10 <RyanGlScott> This is a long-shot, but if you have an ADT without record syntax, is it possible to use NamedFieldPuns with it?
11:15:50 <enthropy> RyanGlScott: what names would it bind things to?
11:16:21 <RyanGlScott> enthropy: That's a good question. :P Is there a way to create custom bindings in lieu of record fuctions?
11:16:47 <RyanGlScott> (This is intended for an API with an ADT without record syntax.)
11:17:59 <infandum> Fuuzetsu: Yes! Except the last test would be to have another ">" entry at the end and see if it adds it to the list in the second tuple, also can handle arbitrary newlines
11:18:32 <Fuuzetsu> infandum: http://lpaste.net/109070 I tried to not change how the code was too much
11:19:09 <Fuuzetsu> there are definitely improvements to be done though…
11:19:31 <Fuuzetsu> oops, like removing that unuse where p = … ;)
11:19:34 <infandum> Fuuzetsu: Oh my, it seems much more complex
11:19:34 <Fuuzetsu> unused*
11:19:40 <bergmark> RyanGlScott: maybe you want https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms
11:19:42 <Fuuzetsu> it isn't, I barely changed anything
11:21:31 <infandum> Fuuzetsu: YAY! It's perfect!
11:21:52 <infandum> Fuuzetsu: How do you know exactly what's wrong and can fix it so quickly!?
11:22:16 <Fuuzetsu> let's just say I spent for too many hours on the Haddock parser…
11:22:32 <Fuuzetsu> although this is my first time using Parsec
11:23:23 <Fuuzetsu> basically your problem in subcell was that it swallowed up too much, if it saw something like >>1 then x would parse to >1
11:23:31 <infandum> Fuuzetsu: Like, you know exactly how to use "*>" and whatnot
11:23:35 <Fuuzetsu> rather than failing because it's not a subcell
11:23:36 <infandum> I'm not even that far
11:23:48 <Fuuzetsu> infandum: that's just applicative, not a Parsec thing
11:24:03 <infandum> Yeah, but it doesn't occur to me to use it IN parsec
11:24:05 <Fuuzetsu> you can substitute *> with >>
11:24:34 <monochrom> @type (*>)
11:24:35 <lambdabot> Applicative f => f a -> f b -> f b
11:24:38 <infandum> Fuuzetsu: OOOhhh. You're used to applicatives, while >> is for monads, right?
11:24:41 <monochrom> ah, yeah
11:24:43 <infandum> ah, yes
11:24:56 <infandum> ok, I don't feel as bad now haha
11:24:58 <infandum> still
11:25:00 <Fuuzetsu> infandum: right, but if you're a Monad then you're also (usually and soon guaranteed) an Applicative
11:25:05 <infandum> mhm
11:25:18 <monochrom> Parsec is both Monad and Applicative (and Functor)
11:25:28 <Fuuzetsu> and probably more names!
11:25:29 <infandum> Fuuzetsu: Oh, I see what you did I think
11:25:51 <infandum> Fuuzetsu: You are parsing subcells until you can't (because it's a cell), right?
11:26:02 <Fuuzetsu> yes
11:26:13 <infandum> That's a way to bypass using lookahead with ">>"
11:26:15 <Fuuzetsu> at that point it goes ‘oops, I shouldn't be here’, goes back up and parses as a cell
11:26:17 <infandum> hm
11:26:38 <infandum> yeah, it's not swallowed because of "try"
11:26:40 <infandum> great
11:26:51 <infandum> Fuuzetsu: THANK YOUUUU!
11:27:09 <infandum> Fuuzetsu: So you recommend to not use lookAhead so much, and especially not with strings?
11:29:47 <Fuuzetsu> more or less
11:29:54 <infandum> got it!
11:29:55 <Fuuzetsu> there are just better ways often
11:30:01 <Fuuzetsu> I'm actualal removing your lookaheads right now
11:30:06 <Fuuzetsu> actually*
11:30:09 <infandum> Thank you! I need to depart though
11:30:09 <Fuuzetsu> if anything, lookahead is ugly
11:30:55 <Fuuzetsu> ah, alright, http://lpaste.net/109071 that's what I have at the moment, nothing much
11:31:00 <Fuuzetsu> see you around infandum
11:31:14 <josephle> ah, the joys of recursive descent parsing. I learned to hate lookahead the hard way :(
11:31:16 <infandum> Fuuzetsu: Thank you again!
11:32:09 <Fuuzetsu> PS: testing your subparsers is a great way to find bugs and help you code the rest of them
11:32:35 <Fuuzetsu> josephle: I use attoparsec which doesn't even have lookAhead for more than one character so I don't have that problem I guess
11:33:33 <josephle> attoparsec is definitely a nicer experience
11:38:09 * hackagebot json-rpc 0.1.0.2 - Fully-featured JSON-RPC 2.0 library  http://hackage.haskell.org/package/json-rpc-0.1.0.2 (XenoGenesis)
11:40:05 <Fermata> I'm picking up Haskell again, using _Programming in Haskell_. All is going well, until curried functions appear.
11:40:11 <Fermata> I can't get my head around why the example mult :: Int -> (Int -> (Int -> Int))   mult x y z = x * y * z works.
11:40:32 <Fermata> I can acknowledge the fact that it works and am able to apply/edit the syntax.
11:40:49 <Fermata> But not *why*.  Can someone fill me in?
11:41:17 <Kirth> hur
11:41:59 <Cale> Fermata: f x y z means ((f x) y) z
11:42:24 <Cale> Fermata: Does that help? :)
11:42:48 <Fermata> Ah...
11:42:55 <Cale> Fermata: So, mult x :: Int -> (Int -> Int), and then  mult x y :: Int -> Int, and finally mult x y z :: Int
11:43:13 <Fermata> Which "turns" x into a valid function.
11:43:14 <Fermata> And so on.
11:43:24 <Cale> x isn't a function
11:43:28 <Cale> x :: Int  here
11:43:55 <Cale> (similarly y and z are Ints)
11:44:28 <Fermata> Well, it helps...but it doesn't clear it up entirely.
11:45:08 <Cale> > let mult x y z = x * y * z in mult 2 3 5
11:45:10 <lambdabot>  30
11:45:14 <c_wraith> Fermata: think function application as removing the top-level arrow from the type signature
11:45:43 <Cale> > let mult x y z = x * y * z in map (mult 2 3) [1,2,3,4,5]
11:45:45 <lambdabot>  [6,12,18,24,30]
11:45:49 <{AS}> Fermata: Imagine currying as a way to partially assign values to arguments, e.g. mult 2 is equivalent to 2 * y * z, mult 2 3 is equivalent to 2 * 3 * z and mult 2 3 5 is equivalent to 2 * 3 * 5
11:46:11 <xintron> I'm playing around with scotty (wai) and I wonder how I can extract the clients IP address from the request. I get the SockAddr but have no clue how to extract the address (without source port)
11:46:19 <Cale> {AS}: Or maybe we should put in the lambdas
11:46:23 <Cale> mult 2 is equivalent to (\y z -> 2 * y * z)
11:46:32 <Cale> mult 2 3 is equivalent to (\z -> 2 * 3 * z)
11:46:33 <xintron> doing: request >>= show . remoteHost
11:46:46 <Fermata> Ah...thanks to the three of you.
11:46:52 <Fermata> That helped.
11:47:26 <dfeuer> \x y z -> expr is (pretty much) the same as \x->\y->\z->expr
11:48:35 <Guest35864> import Data.Int
11:48:35 <Guest35864>     selfpow :: (Integral a) => a -> a
11:48:35 <Guest35864> selfpow x = foldl (*) 1 (take  (fromIntegral x) (repeat x))
11:48:37 <Guest35864> result :: (Integral a) => [a]	-> a
11:48:39 <Guest35864> result xs = sum [selfpow x | x <- xs]
11:48:41 <Guest35864> digits :: (Integral a) => a -> [a]
11:48:43 <Guest35864> digits 0 = []
11:48:45 <Guest35864> digits x = last : digits result
11:48:47 <Guest35864>     where last = x `mod` 10
11:48:49 <Guest35864>           result = x `div` 10
11:49:06 <Cale> Guest35864: lpaste.net
11:49:07 <Guest35864> hey guys could you please give feedback on this'?
11:49:15 <Guest35864> okay
11:49:51 <Fermata> Time to tinker with this.  Thanks again.
11:49:51 <Cale> btw, you can write  (result, last) = divMod x 10  which is slightly more efficient
11:49:58 <rebasar> Hi everyone, I have created a simple implementation of Look and Say numbers of John Conway (https://www.youtube.com/watch?v=ea7lJkEhytA) with my rusty Haskell knowledge but I think looks rather dreadful and wastes a lot of computation. Care to take a look and suggest anything? https://gist.github.com/rebasar/af9cd24620b97d1cb224
11:51:31 <Guest35864> Cale: okay, can selfpow be improved too?
11:52:35 <Cale> Guest35864: yes
11:52:54 <Cale> Guest35864: You might want to have a look at how (^) is implemented in the Prelude
11:52:57 <Cale> @src (^)
11:52:58 <lambdabot> x ^ 0            =  1
11:52:58 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
11:52:58 <lambdabot>   where f _ 0 y = y
11:52:58 <lambdabot>         f x n y = g x n
11:52:58 <lambdabot>           where g x n | even n    = g (x*x) (n `quot` 2)
11:53:00 <lambdabot>                       | otherwise = f x (n-1) (x*y)
11:53:02 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
11:53:21 <Cale> This does fewer multiplications
11:53:47 <Guest35864> cool, thanks
11:53:51 <Guest35864> will have a look at it
11:55:37 <cschneid> can I have `cabal test` run my test suite as interpreted haskell (ie like `runhaskell` would), rather than doing the full compile first?
11:57:00 <c_wraith> rebasar: Your implementation looks pretty good, in terms of efficiency.
11:57:17 <c_wraith> rebasar: I'm sure it can be improved, but it's not doing anything obviously wrong.  It's what my first pass would be.
11:57:43 <c_wraith> rebasar: Stylistically, though, I would change lasIter to use guards instead of a case on ==
11:58:32 <paraseba> is there some trick to get hackage to generate and link the documentation?
11:58:56 <rebasar> c_wraith: Thanks, I thought about using guards but as I said, rusty knowledge
11:58:57 <c_wraith> paraseba: waiting impatiently.  The more impatient you are, the faster it gets around to it. :)
11:59:04 <paraseba> or some log of why it fails... cabal haddock works locally
11:59:18 <t7> @hoogle (a -> Maybe b) -> [a] -> [b]
11:59:21 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
11:59:21 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:59:21 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
11:59:24 <c_wraith> paraseba: oh, if it failed, that's another story.  There should be a log, though?
11:59:27 <mmachenry> I need some advice debugging a pretty obscure issue. I am reading from a socket using Data.ByteString.hGetLine and getting failures parsing my strings into JSON. Parsing those same strings in my test cases work. Is this is possibly a strictness issue?
11:59:36 <eacameron1> Its seems that GHC is not constraining my data based on my type signatures the way I would expect. I would expect something like myMap = [(Key, ByteString -> Query)] to constrain my lambdas to be ByteString -> Query but it appears it's inferring a much higher type for the functions on the right side of the map. any thoughts?
11:59:47 <paraseba> c_wraith: i've been waiting for almost 20 hs, does it usually take that long? cabal haddock works locally
12:00:02 <c_wraith> paraseba: if it hasn't posted a failure log, it's still pending.
12:00:52 <paraseba> c_wraith: oh, there should be a log link in the maintainance page if it failed? That's good to know, this is the first time I submit a package
12:00:58 <eacameron1> *= should be :: above
12:01:42 <aranea> Phew. My ghc just spent 3 minutes of cpu time, used up 2GB ram and wrote 40MB output files. Guess what I did - I fed it with a source file containing a single [Int] literal with 100.000 elements.
12:01:56 <aranea> I'm really surprised how long it took.
12:01:57 <c_wraith> paraseba: well, the failure log would be on the download page.
12:03:22 <paraseba> c_wraith: hum, do you mean here https://hackage.haskell.org/package/haskell-brainfuck ?
12:04:14 <paraseba> maybe it's confused by the fact that the package is both a library and an executable?
12:04:26 <tulcod> are there constructors for a Float? i have the exact IEEE754 representation of a float I want to use
12:04:52 <luite> aranea: desugaring an let floating probably made it create ~200k toplevel names for that
12:05:26 <c_wraith> tulcod: there are constructors, but they wouldn't help you with that.  You actually want a direct conversion function.  Those also exist, but I don't recall where.
12:06:35 <t7> @hoogle Int -> a -> [a]
12:06:37 <lambdabot> Prelude replicate :: Int -> a -> [a]
12:06:37 <lambdabot> Data.List replicate :: Int -> a -> [a]
12:06:37 <lambdabot> Prelude drop :: Int -> [a] -> [a]
12:06:48 <chirpsalot> tulcod: sounds scary. You're not trying to write fast inverse square root, are you? :(
12:07:03 <tulcod> chirpsalot: i'm binding to a C library which uses the wrong type to represent stuff
12:07:17 <chirpsalot> tulcod: oh god, my condolences.
12:07:29 <tulcod> chirpsalot: appreciated
12:08:11 * hackagebot SpacePrivateers 0.1.0.0 - Simple space pirate roguelike  http://hackage.haskell.org/package/SpacePrivateers-0.1.0.0 (tuturto)
12:09:08 <stolaruk> What is the convention for indenting a line following a line that starts with "in"? I normally indent 4 spaces on a new line following a "do"... so if I have "in do", would I indent the following line 4 spaces in from the "in", or 7 spaces from the "in"?
12:09:57 <aranea> tulcod: So, you've got something like a C float/double?
12:09:59 <tulcod> stolaruk: i think in general 2 spaces are convention
12:10:30 <tulcod> aranea: i'm trying to find out exactly what it is. technically it's just a C int, but i think it should just be a "float" (in the C sense). either way, i'd like to construct the float explicitly
12:10:37 <c_wraith> paraseba: huh.  It looks like that page isn't where the failure log shows up anymore.  apparently my hackage knowledge is out of date. I have no clue where it would show up.
12:11:24 <aranea> tulcod: Well, there's encodeFloat :: RealFloat a => Integer -> Int -> a
12:11:29 <paraseba> c_wraith: thanks anyway
12:11:37 <c_wraith> tulcod: http://hackage.haskell.org/package/ghc-prim-0.3.1.0/docs/GHC-Prim.html
12:12:02 <paraseba> c_wraith: i'm suspecting the problem could be related to this https://github.com/haskell/cabal/issues/1085
12:12:05 <c_wraith> tulcod: that's where I'd be looking.  I'm not sure if it's actually god what you need.
12:13:06 <tulcod> aranea: i think that's exactly what i need
12:13:09 <tulcod> thanks
12:14:00 <aranea> You're welcome.
12:17:00 <n-dolio> If you have the exact IEEE bit pattern as a machine integer, encodeFloat is probably not what you want.
12:19:18 <aranea> n-dolio, tulcod: Sure, you've got to extract the bits first to use that.
12:19:55 <timmy_tofu> Does anybody have a better flow than I for dealing with a multi-sandbox/multi-sandbox tree in vim?
12:20:00 <timmy_tofu> That is, I open vim from baseDir/ and then navigate around in it, where there is baseDir/project0, baseDir/project1, where each project has it's own sandbox.
12:20:05 <timmy_tofu> But because the pwd is baseDir, I get syntastic errors about packages not being found until I :cd currentProject
12:20:11 <timmy_tofu> This has been bugging me for a while. I could solve it with a shared sandbox, I think, if the projects didn't have conflicting dependencies, but does anyone have their vim setup to somehow automatically cd to the base directory of a project when you open it?
12:20:12 <t7> is it monadplus that can return the first Just ?
12:20:16 <t7> in a sequence
12:20:31 <timmy_tofu> *multi-project
12:20:51 <t7> > mplus (Just 1) (Just 2)
12:20:53 <lambdabot>  Just 1
12:23:02 <t7> does monad plus have a guard?
12:23:07 <t7> like short circuit ?
12:23:25 <bergmark> @type guard
12:23:27 <lambdabot> MonadPlus m => Bool -> m ()
12:23:54 <t7> hmmm
12:24:23 <t7> oh im an idiot never mind
12:25:43 <oisin999> Should I lean towards using [(x, y)] or Data.Map?
12:26:21 <t7> if x /= another x then use map
12:26:42 <oisin999> t7: Thanks! :)
12:26:48 <Cale> oisin999: Generally Data.Map, if you're going to be looking up associations at all
12:27:04 <Cale> oisin999: If you're going to iterate through the entries in order, then the list is fine
12:28:02 <oisin999> Cale: Thanks, I will be so I'll definitely use Data.Map then
12:28:06 <dfeuer> Is the (safe) coerce function as powerful as it looks for improving the efficiency of data structures with fancy types?
12:30:46 <maybefbi> i cannot install hoogle on windows because this error "hsc2hs.exe: dist\build\System\Win32File_hsc_make.exe: runProcess: does not exist
12:30:46 <maybefbi>  (No such file or directory)" happened when installing streaming-commons.
12:31:59 <maybefbi> someday haskellers will care about windows.
12:32:17 <chrisdone> maybefbi: i think that's probably not true =/
12:32:29 <maybefbi> :)
12:32:37 <{AS}> Any news on the HP 2014.2.0.0?
12:32:41 <chrisdone> if i was to draw a graph of microsoft-windows-mattering, it would be like
12:33:11 <chrisdone> ___
12:33:12 <chrisdone>    `-.__
12:33:12 <chrisdone>         \____ ← now
12:33:28 <Cale> ahahaha
12:34:24 <mcbears> {AS}: last I saw, it was going to be ready for release by the end of the week? last week? I think?
12:34:43 <mcbears> so I wouldn't be surprised if it popped up any minute now, but I also wouldn't be surprised if it took a bit longer
12:34:51 <maybefbi> i would be
12:34:56 <monochrom> it's in RC3
12:35:35 <chrisdone> @botsnack
12:35:36 <lambdabot> :)
12:36:00 <{AS}> mcbears: Ah thanks :). I knew it was around the corner (was just wondering :))
12:39:21 <maybefbi> "Windows and OS X users: There are no RC3 versions - as the RC2 versions seem to be holding up fine!" <-- never heard so much bullshit
12:39:53 <maybefbi> hsc2hs cannot handle windows paths just like in the old days before 2 years ago.
12:40:08 <maybefbi> i reopened the ticket but nobody seems to care
12:40:45 <chrisdone> yeah, haskell's tooling is purely a community effort
12:40:56 <chrisdone> if there was a lot of windows users its tooling would be better
12:41:05 <monochrom> is that part of GHC, or is that something the haskell platform people can do anything about at all?
12:41:30 <tulcod> aaaah, i'm a bit of an idiot. the C number i'm working with is not a float[ing point], but a fixed-point type. what is the most fitting haskell datatype for that?
12:41:36 <monochrom> no, chrisdone, you need a lot of windows contributors, not windows users per se.
12:42:19 <chrisdone> monochrom: sure. i expect there's some correlation, though
12:43:13 <chrisdone> more people using a thing i expect to correlate with more contributors for that thing
12:43:32 <chrisdone> but perhaps not
12:43:42 <monochrom> economically, you need a reward system for that correlation to happen
12:43:51 <chrisdone> there is that
12:44:03 <chrisdone> there's also the kind of person who uses windows
12:44:45 <chrisdone> i think people willfully using windows are more used to software just working and not having to contribute to it to get it to work
12:44:59 <monochrom> perhaps among linux users, the reward system is bragging rights and reputation
12:45:39 <chrisdone> well, it depends whether the motivation is this-solves-my-problem or this-makes-me-feel-good
12:45:41 <monochrom> but I'm feelling that among windows users, the reward system is money. and no money has been paid yet for improving GHC on windows
12:45:57 <chrisdone> for the former, you don't care about impressing people, you just want this thing to work so you fix it
12:46:12 <chrisdone> for the latter, yeah, reputation and "rewards" are a thing
12:47:22 <chrisdone> monochrom: i recognise two kinds of people for emacs users
12:47:29 <chrisdone> those two write elisp, and those who don't =p
12:47:30 <aranea> chrisdone: Remember using windows and willfully using windows is not quite the same.
12:47:33 <sm> it seems like some insightful windows person could hack the marketing & incentives to increase windows contributions
12:47:54 <chrisdone> aranea: sure, that's why i specifically said willfully. some people are forced to use it and don't like it
12:48:08 <Aesop> I was under the impression ghc works reasonable well on windows these days
12:48:18 <monochrom> I don't write elisp. however, proportionately, I don't make demands either.
12:48:20 <Aesop> at least for me that's the case
12:48:36 <cschneid> I'm using UTCTime for the first time, and it's wanting to use old-locale library, is that actually still recommended? Is there a better way to take a UTCTime and spin it out with a certain format?
12:48:37 <maybefbi> Aesop, bet you are not on haskell 2014.2
12:48:43 <Aesop> nope :D
12:48:56 <Aesop> ghc 7.8
12:49:15 <maybefbi> Aesop, you didn't install the platform?
12:49:18 <sm> cschneid: yes that lib is still current despite the name
12:49:20 <Aesop> took me some time to find out haskell platform is not what you want
12:49:30 <cschneid> sm: thanks - misleading name :)
12:49:31 <Aesop> or rather I want
12:49:33 <chrisdone> monochrom: sure. by analogy i think people who choose linux, for example, are more in the former camp. they're okay with cranking open source and sending patches. the latter camp, i think applies more to windows users. they're mostly users, and rarely developers (of their tooling/desktop)
12:49:52 <dfeuer> aranea: from way back, try -fsimple-list-literals
12:49:56 <maybefbi> Aesop, hmm looks like haskell platform is not what i want either. how did you compile hsc2hs in windows?
12:50:25 <Aesop> maybefbi, I don't know specifically about that lib but I could try
12:50:32 <monochrom> hsc2hc comes with GHC
12:50:52 <chrisdone> monochrom: so yeah, maybe rewards and incentives are the only way to get the windows devs to do something, because there are few of them and they don't share the same issues as the users
12:50:53 <aranea> tulcod: There's Data.Fixed
12:51:09 <maybefbi> monochrom,  haskell platform x64 2014.2 hsc2hs cannot handle paths properly
12:51:24 <monochrom> and GHC hsc2hs can?
12:51:36 <maybefbi> monochrom, havent tried
12:51:57 <monochrom> then your complaint is misplaced
12:52:04 <aranea> dfeuer: Grepping the ghc man page for that doesn't yield anything.
12:52:23 <adimit> What do people use these days to typeset Haskell code in LaTeX? I'm not super-content with lhs2tex, since it doesn't handle newer GHC extensions like DataKinds properly, and I'm looking for an alternative…
12:53:03 <monochrom> when part of GHC has a problem, the haskell platform people can do very little about it. they don't know GHC internals. they only know installation and packaging.
12:53:22 <monochrom> "RC2 holds up on windows" means the install script holds up.
12:53:49 <monochrom> if GHC 7.8.3 panics, it is not contradictory to "RC2 holds on on windows".
12:54:22 <tulcod> aranea: hmm, it's in base. it would be awesome if i can bend that to my will, thanks.
12:54:28 <monochrom> RC3 seems to be testing linux install and build scripts
12:54:45 <platz> there are a few packages that don't compile well windows, but I think that is mostly those assuming a posix environment - not everything is written cross-platform, but that is only an issue about libraries, not base
12:54:52 <maybefbi> monochrom, im going to try the 32 bit haskell platform
12:55:15 <maybefbi> monochrom, perhaps it is the preprocessor #includes not working correctly
12:55:37 <dfeuer> aranea: See http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.8.3/src/DsExpr.html
12:56:10 <maybefbi> monochrom, hsc2hs Main.hs line 225 says: #if defined(mingw32_HOST_OS)
12:56:23 <maybefbi> monochrom, not sure if that will work on x64
12:56:26 <chrisdone> sm: what was that channel to add to ircbrowse? i've restarted my client since
12:56:35 <monochrom> this is evolving into the like of telling a traveling agency that the airplane engine is not working
12:56:47 <sm> chrisdone: #hledger
12:56:55 <chrisdone> sm: k
12:57:16 <sm> I was wondering what you use to capture the logs. hulk, hog, or.. ?
12:57:27 <chrisdone> znc
12:57:48 <sm> interesting
12:58:06 <chrisdone> makes it a bit easier to manage "live"
12:58:26 <RyanGlScott> maybefbi: defined(mingw32_HOST_OS) will be true regardless of which Windows architecture you're using. That's just checking if MinGW is present (which it is).
12:58:45 <sm> nod
12:58:48 <maybefbi> RyanGlScott, ok
12:59:09 <tippenein> Control.Distributed.Process.Node doesn't seem to import. http://lpaste.net/109073
12:59:09 <RyanGlScott> maybefbi: I should know since I'm using Windows GHC x86_64 (not the Haskell Platform, though).
12:59:18 <dfeuer> aranea: basically, there's a weird hack in GHC's handling of list literals, and that flag turns it off.
12:59:44 <maybefbi> RyanGlScott, how did you compile hsc2hs ? did you use mingw or cygwin?
12:59:59 <OldTimes> hello
13:00:47 * dfeuer needs to talk to some folks... I have an account on a machine still running GHC 6.something.
13:00:47 <RyanGlScott> maybefbi: I never compiled it. It came bundled with this GHC binary package: http://www.haskell.org/ghc/dist/7.8.3/ghc-7.8.3-x86_64-unknown-mingw32.tar.xz
13:01:00 <maybefbi> RyanGlScott, ok thanks
13:01:32 <RyanGlScott> maybefbi: However, if you install from binary, you will need MSYS at some point to get some package (e.g., network) installed correctly.
13:01:49 <maybefbi> RyanGlScott, yeah
13:01:53 <maybefbi> or cygwin
13:02:12 <RyanGlScott> maybefbi: No, not Cygwin. network explicitly needs the MinGW libraries to build correctly on Windows.
13:02:23 <maybefbi> RyanGlScott, copy that
13:05:01 <fractalsea> Hi, does anyone know what might be causing this error on Win 7 + Cygwin when I run cabal install cabal-install? http://lpaste.net/109074
13:05:40 <RyanGlScott> fractalsea: You have to compile network with MSYS or MSYS2.
13:05:54 <fractalsea> ahh, OK
13:05:58 <fractalsea> Thanks
13:07:00 <Aesop> anyone familiar with acid-state? Is there a performance advantage when defining fine grained acid queries instead of querying the whole db and refining the query from there?
13:08:10 <OldTimes> how do I check how standard data is defined?
13:08:29 <nisstyre> OldTimes: you mean Prelude types?
13:08:41 <fractalsea> That's odd that it doesn't work on Cygwin. I was always under the impression that MSYS was a subset of the tools provided by Cygwin if anything
13:09:01 <nisstyre> :info Char
13:09:08 <nisstyre> hmm, that used to work
13:10:11 <bmuk> I know this isn't strictly about haskell, but when working through a theoretical book, do you all always actually *do* the example problems or just skim/skip them if you already understand the topic?
13:10:16 <OldTimes> ok, thanks
13:10:44 <bmuk> For instance, RWH, Learn You a Haskell, or in my case SICP
13:11:28 <mcbears> bmuk: it might be a bad habit but I usually tend to skim the whole work and then read through it again with a fine-toothed comb
13:11:47 <vanila> bmuk, I only solve problems I can't immediately solve in my head
13:11:51 <vanila> this goes for math too
13:12:05 <nk887> @bmuk You can't beat practical, hands-on experience IMO. At the very least, it helps with committing it to memory and becoming more intimately familiar with the concepts (rather than just familiar with them at a surface level)
13:12:05 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
13:13:27 <bmuk> nk887: I get this for something like RWH, where the goal is learning haskell itself, but the SICP problems are stuff like implement this recursive algorithm in an interative way
13:14:30 <RyanGlScott> fractalsea: They're different projects altogether. http://stackoverflow.com/questions/771756/what-is-the-difference-between-cygwin-and-mingw
13:14:41 <nk887> To me, implementing ideas on my own is immensely beneficial in improving understanding. That's just me though.
13:14:51 <bmuk> I guess though that you develop skill with implementing algorithms this way
13:14:54 <lispy> nk887: Nah, I think that's everyone
13:15:30 <sellout> Is there a general recursion scheme like Functor f => (f a -> f a -> a) -> Fix f -> Fix f -> a – a mergemorphism, perhaps?
13:16:04 <RyanGlScott> (You used to be able to compile MinGW programs with Cygwin using the -mno-cygwin flag, but that has been removed.)
13:17:41 <benzrf> woah woat
13:20:15 <enthropy> hello I'm confused about why an IORef I'm using with template-haskell is misbehaving
13:20:19 <enthropy> https://gist.github.com/aavogt/6e714161d5e523f143f4
13:20:30 <rrmckinley> is there something in Haskell like Either or Except or Maybe that is more for warnings? Like, the computation was successful, but it was less than ideal. I want to warn the user, but in context. The data structure closely matches the UI. So, would I just use (T, Maybe String)? I show the T and maybe I show a warning message?
13:20:48 <enthropy> rrmckinley: Writer
13:21:18 <rrmckinley> enthropy: thanks, googling...
13:22:05 <enthropy> I'm suggesting http://hackage.haskell.org/package/mtl-2.0.1.0/docs/Control-Monad-Writer-Lazy.html
13:22:53 <enthropy> but supposing you have something like "data UI = Beside UI UI | Widget"
13:23:23 <pjdelport> rebasar: I added a comment with another take on that look-and-say implementation: https://gist.github.com/rebasar/af9cd24620b97d1cb224#comment-1278434
13:23:39 <enthropy> you probably want something a bit more than    beside = liftM2 Beside :: Writer [String] UI -> Writer [String] UI -> Writer [String] UI
13:24:10 <enthropy> as in, that would be the type, but maybe the implementation is supposed to have some breadcrumbs
13:25:25 <enthropy> anyways, Writer (Maybe String) has the same implementation as you were proposing
13:28:30 <aranea> dfeuer: Thanks!
13:30:07 <rrmckinley> enthropy: To be specific this UI goes to json first so the json would be something like {value:1, warning:null} or {value:2, warning:'you probably don't want 2'}. breadcrumbs aren't really necessary I guess because I am returning a nested structure with the values and warning in context. breadcrumbs would just be a flatmap I guess.
13:31:49 <enthropy> you could add another parameter to your data like this 'l' here: http://hackage.haskell.org/package/haskell-src-exts-1.15.0.1/docs/Language-Haskell-Exts-Annotated-Syntax.html#t:Exp
13:32:17 <enthropy> there's it's used for locations, but the same thing will work for warnings
13:32:46 <chrisdone> sm: ok, #hledger is setup on ircbrowse now
13:32:53 <chrisdone> happy browsing!
13:36:20 <enthropy> nevermind my paste above, the IORef behaved properly, but I was reading from the wrong Map
13:38:07 <tac_> Does anyone know if there is a Vim plugin for Haskell core syntax highlighting?
13:38:50 <sm> chrisdone: thank you very much!
13:38:56 <chrisdone> welcome!
13:39:01 <fractalsea> I've installed MinGW and MSYS base, but how do I actually run cabal install "in" mingw. I'm only used to Cygwin...
13:39:44 <sm> all welcome to drop by #hledger, a new channel specifically for the haskell rewrite of Ledger CLI
13:40:15 <phaazon> I just thought about something; edwardk, I read the LICENSE file of your lens package; it sounds a bit weird to me
13:40:29 <edwardk> phaazon: let me go look
13:40:37 <phaazon> is it a BSD3 license or some kind of derived license?
13:40:48 <edwardk> its standard BSD3
13:41:03 <phaazon> do I have to put your name on my rendering engine then?
13:41:08 <edwardk> no
13:41:22 <phaazon> I don’t get it then
13:41:38 <rrmckinley> BSD3 plated
13:41:43 <phaazon> 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
13:41:54 <edwardk> http://opensource.org/licenses/BSD-3-Clause
13:42:26 <edwardk> should read line for line identical with a possible pronoun change
13:43:23 <phaazon> why not using GPLv3?
13:43:25 <glguy_> You just have to put the license terms somewhere if you distribute it. For example in Apple's web browser Safari there is a Help>Acknowledgements menu item
13:43:41 <glguy_> and it lists all the licenses of the software that it uses which are BSD3, GPL, etc
13:43:44 <edwardk> Using GPLv3 encumbers users more than BSD3
13:43:55 <phaazon> why edwardk
13:43:58 <phaazon> ?
13:44:05 <phaazon> because it’s heavy?
13:44:11 <monochrom> edwardk, I think it's "redistributions in binary form must reproduce the above copyright notice", and the copyright notice usually has your name.
13:44:11 <edwardk> I write under BSD3 because it makes more users able to use my code.
13:44:16 <phaazon> maybe I’ll release my engine in BSD3 then
13:44:39 <phaazon> my packages on hackage are PublicDomain I guess
13:45:08 <phaazon> https://hackage.haskell.org/package/monad-journal-0.2.2.0 yep, PublicDomain
13:45:16 <edwardk> I don't particularly care if folks take my code in house and make changes to it, this that and the other thing. In general they can't keep up with drinking from the fire hose, so eventually they either stop and commit back what they were trying to maintain in the fork, or they bring me in as a consultant to work on the in house version of things.
13:45:35 <monochrom> on the other hand, your name must not be used to endorse or promote derived products :)
13:45:46 <edwardk> i don't license things under the public domain because there are many legal settings where the "public domain" doesn't exist. Which makes it actually less well defined for many lawyers and legal departments than BSD3
13:46:04 <monochrom> example: "use my program! it's powered by edwardk's lens!" is forbidden :)
13:46:04 <edwardk> monochrom: i usually use BSD2, since that clause is redundant, it doesn't follow even in its absence
13:46:17 <phaazon> monochrom: I se
13:46:19 <phaazon> see*
13:46:45 <phaazon> ok, and then, why is GPLv3 a pain in the a**?
13:47:03 <lpvb> edwardk: I thought unlicense and CC0 try to give as many rights as possible even without full public domain
13:47:41 <vanila> GPLv3 is no problem at all, just distribute modifications under GPL3 too
13:47:42 <monochrom> GPLv3 says, under many circumstances, you must open-source your stuff too
13:48:03 <edwardk> Finally there are some second order consequences to GPL licensing that keeps me preferring BSD licensing, which is that GPL licensing doesn't affect organizations that are large enough to afford to buy anyone they'd otherwise partner with, so GPL only encumbers mid-scale companies and serves to favor the creation of larger companies with higher Coase ceilings from an economics perspective. I understand the moral ground it stakes
13:48:05 <edwardk>  out but from a POSIWID perspective, this development means that it favors the creation of entities that _can't_ bring me on in a partner capacity, merely as a subcontractor to work on my own code.
13:48:06 <vanila> it is designed to protect software freedom
13:48:30 <edwardk> lpvb: those are an option as well but they are less well understood by corporate legal departments than BSD
13:48:43 <lpvb> understandable
13:48:53 <edwardk> odds are every corporate legal department on the planet has had to deal with something where they brought in BSD licensed code into the organization already
13:49:20 <RyanGlScott> fractalsea: You'd still run "cabal install cabal-install". The only difference is that with MSYS, you're in the presence of different headers/libraries.
13:49:57 <fractalsea> RyanGlScott: So they should automatically get picked up from within PowerShell?
13:50:07 <edwardk> So in that sense, the fact that I stumbled upon the Haskell community right around the time I decided I was going to stop using GPL for everything, and found that everyone here tends to license things under BSD was very serendipitous.
13:50:41 <glguy_> You have to be careful, though, there are a few GPL landmines hiding out on hackage
13:50:44 <RyanGlScott> fractalsea: No, you'd have to run it from the MSYS shell itself, since it does some work behind the scenes to get the PATH configured correctly.
13:50:48 <rebasar> pjdelport: wow! Looks much clearer. Thanks
13:50:57 <edwardk> there are, and i very carefully avoid working on or with any of them
13:51:10 <chrisdone> BSD/MIT makes it easy for us at fpcomplete to work =)
13:51:24 <koala_man> edwardk: are you saying that a large company would just buy the rights to a GPL product if they wanted to use it?
13:51:47 <chrisdone> we look at hackage with a lens (hur) that filters out *GPL licensed packages
13:51:49 <koala_man> if they wanted to use it in a non-GPL product that is
13:52:19 <fractalsea> RyanGlScott: Ah, I think I understand. I couldn't find the command to start the shell, but I think I found it now.
13:52:27 <edwardk> koala_man: no, i'm saying, look at say Google. Google has its own proproprietary set of changes to the linux kernel that are behind closed doors. They are big enough to afford to buy any other company that a more reasonable scaled company would partner with if they need to deal with joint distribution of that code to a 'partner' without leaking it out via the GPL.
13:55:41 <Clint> koala_man: it doesn't occur to most people that they can buy alternate licenses
13:56:56 <chrisdone> clint: yeah, i think people see licenses as the B-all end-all when you can just approach the copyright holder as a human being and get an alternate license, free license or contract
13:58:04 <chrisdone> this stacked graph algo is cool http://www.leebyron.com/else/streamgraph/
13:58:20 <fractalsea> RyanGlScott: I just ran cabal install cabal-install and I'm getting the same error as I previously posted. Do any ideas of what to try next?
13:59:18 <RyanGlScott> fractalsea: Now that I think about it, you should probably reinstall all of network. I'm guessing that cabal is only trying to install cabal-install.
14:00:01 <fractalsea> RyanGlScott: OK. Is there a command I can use to reinstall, or should I just uninstall and re-install?
14:00:03 <koala_man> I still love how trolltech, after being badgered for ages to open source Qt, licensed it under full on GPL. It really shut up all the people who just didn't want to buy a license for their proprietary product
14:00:44 <monochrom> hehe
14:01:07 <RyanGlScott> fractalsea: You can use "ghc-pkg unregister network" if you'd wish. Fully uninstalling a package would require an external tool (such as cab http://hackage.haskell.org/package/cab)
14:01:08 <chrisdone> koala_man =)
14:01:33 <fractalsea> RyanGlScott: OK, thanks. I'll give that first one a go
14:03:29 <chrisdone> koala_man: yeah, that really underscores the difference between Free Software (as by RMS and FSF) and Open Source (as by OSI and disparaged by RMS). "Open Source" makes people focus price and access, and ignore freedom
14:10:27 <fractalsea> RyanGlScott: Yes! That worked. Managed to update cabal-install. Thanks a lot, that woul have taken me ages.
14:12:27 <solidus-river> so, i'm realizing more and more as i spend more itme coding places...
14:12:59 <solidus-river> what makes good code isn't being smart about telling a computer what to do but mostly being smart about descibing what your telling hte computer to do to whoever is going to look at it next
14:13:03 <solidus-river> or try to use it
14:13:31 <gfixler> solidus-river: that's one pillar of maintainable code
14:13:41 <solidus-river> like its very rare in work i get into a situation where performance matters much
14:13:59 <gfixler> epic one-liners demonstrate smartness about telling a computer what to do
14:14:07 <solidus-river> and even when it does it doesnt matter so much that you have to sacrafice readability, and when it does happen, the solution is usually to make 2/3rds of that function a comment
14:14:08 <gfixler> but they'll get you strangled by the dev who finds it later
14:14:37 <gfixler> solidus-river: looked at all into literate programming?
14:14:39 <josephle> or your code reviewer if you have code reviews in your process
14:15:12 <josephle> code reviews are a great first line of strangling
14:15:12 <solidus-river> gfixler: i did but i think LaTeX is hard to read while coding, and i dont like having to abreviate linex of code with >
14:15:26 <gfixler> I personally don't like comments
14:15:37 <gfixler> it doesn't mean I don't use them, but I try to make things really stupidly obvious
14:16:07 <solidus-river> i'm growing ot hate one letter variables
14:16:11 <solidus-river> but that seems to be the style in haskell
14:16:15 <solidus-river> my variable names are always long
14:16:21 <solidus-river> because someones going to have to find out what o means later
14:16:22 <gfixler> foo = foo + bar # adds bar to foo <-- bad comment
14:16:26 <solidus-river> and they dont want to find out it means "object"
14:16:41 <gfixler> Bob Martin in his book "Clean Code" calls that "mental mapping"
14:16:50 <pjdelport> Obligatory: "Programs must be written for people to read, and only incidentally for machines to execute." (SICP)
14:16:54 <gfixler> where you put the onus on the reader to map bad names to what they mean
14:17:26 <gfixler> I've gotten past several-day mental blocks by fixing a name
14:17:34 <gfixler> because a name tells you what a thing is, and what it can do
14:17:50 <gfixler> I changed a name from actor to puppet once, and suddenly found I could write the rest of the code
14:18:08 <gfixler> because the passiveness of a puppet helped me realize a bunch of things about it
14:18:20 <dottedmag> inactor? :)
14:18:20 <gfixler> actors moves themselves, puppets are moved by others
14:18:29 <gfixler> :)
14:18:34 <gfixler> slugabed
14:19:06 <solidus-river> lol
14:19:43 <solidus-river> i guess my problem is.. why is this something i had to learn by hard knocks, this should be part of a degree for a computerey person like grammer is part of a degree for a writer
14:20:02 <gfixler> solidus-river for president
14:20:09 <clrnd> +1
14:20:09 <solidus-river> really the only guidance we got on documentation / design in school was that a function probably shouldn't be more than 40 lines and a module more than 180 when starting out in C++
14:20:36 <clrnd> also verb/adjetive and OOP shenanigans
14:20:43 <gfixler> I would add several things to curriculum - clean code, FP, granular versioning
14:20:59 <alorente> my CS program mentioned readability/maintainability, but we never did any long-run projects where you get to see the point
14:21:02 <dottedmag> solidus-river: Is there a degree for a writer?
14:21:05 <gfixler> I'd even add psychological things, like ways of dealing with the imposter syndrome, which runs rampant in our industry
14:21:11 <Cale> solidus-river: Names should grow with their scope and shrink with their frequency of use
14:21:11 <dottedmag> solidus-river: Anyway, it just means CS degrees suck.
14:21:46 <Cale> solidus-river: The reason there are a lot of one-letter variables in Haskell is that there tend to be a lot of definitions which are one-line-long
14:21:48 <gfixler> I didn't go the CS route - do they do code reviews in CS classes?
14:22:00 <Guest28816> Hi, so I am in a level of cabal hell I have yet to experience.  "cabal --v" returns cabal 1.16. "which cabal" returns "/usr/local/bin/cabal". "/usr/local/bin/cabal --v" returns cabal 1.20. And lastly "/home/$USERNAME/.cabal/bin/cabal --v" returns cabal 1.20. Where the hell is cabal 1.16 installed??
14:22:01 <josephle> my school enforced clean code, but it was baptism by 20% of your grade
14:22:08 <dottedmag> gfixler: Sometimes language-wide (i, j) or even project-wide shortcuts are warranted, but those are exceptions, yes.
14:22:09 <gfixler> Cale: also maths - math people use 1-letter variables for all kinds of things
14:22:13 <Cale> So you can see the binder at the same time as you're looking at any of the occurrences
14:22:25 <gfixler> dottedmag: I name things as long as their distance/scope
14:22:30 <Cale> In mathematics the reason is a little different
14:22:49 <gfixler> i is find for a loop through some numbers
14:22:51 <gfixler> or n
14:22:55 <gfixler> fine*
14:23:01 <Cale> Another reason in Haskell is polymorphism means that you couldn't give more meaningful variables to things if you wanted to
14:23:13 <solidus-river> yeah, maths is hard to translate into a readable program
14:23:30 <solidus-river> this is the best i could do https://github.com/fuag15/functioninvaders/blob/master/src/NFInvaders/Util/Geometry.hs
14:23:38 <gfixler> Maybe a stands in for Maybe Int, Maybe String, Maybe [[Char]], Maybe Maybe Int, etc
14:23:47 <Cale> map theFunction (firstElement:restOfList) = theFunction firstElement : map theFunction restOfList  is really not clearer than  map f (x:xs) = f x : map f xs
14:24:27 <monochrom> when I was undergrad, we had a "software engineering" course. we learned some principles such as (de)coupling, cohesion. decoupling means two procedures/modules should try not to assume too much about each other, at least don't assume implementation details. cohesion means...
14:24:27 <solidus-river> and the only thing that saves that code from ewing unreadable is the like 2/3rds of it that have nothing to do with telling a computer what to do
14:24:38 <solidus-river> *being
14:24:52 <dottedmag> Cale: function accepting f g h and combining them somehow might be clearer if intention would be encoded in names.
14:25:00 <gfixler> solidus-river: this is heading well towards LP
14:25:18 <sm> crazypyro: oh that sounds like a very mild upper level of cabal hell
14:25:22 <monochrom> cohesion means, for example, if you code up function foo such that "foo True g" computes the minimum spanning tree of g, and "foo False g" computes the shortest paths of g, then you're doing it wrong.
14:26:03 <crazypyro> sm: very minor level, last time I was in cabal hell, i literally just wiped the machine and restarted with a fresh ubuntu
14:26:03 <monochrom> we only talked about those things in the course. we needed not code up anything. but it seems like today you don't even talk about them.
14:26:08 <gfixler> I like f g h if we're making something that talks generically about functions
14:26:15 <solidus-river> gfixler: do you need any extra tools in yoru chain for ghc to compile .lhs files or will it pick up the .lhs and translate
14:26:16 <gfixler> but I'd rather have names if it's something more concrete
14:26:20 <solidus-river> *your
14:26:24 <sm> crazypyro: here, type -a cabal  finds the one I'm running
14:26:35 <sm> and lists any others
14:27:02 <gfixler> solidus-river: not sure; I haven't actually done LP myself
14:27:17 <crazypyro> sm: oh great, thanks, found it, it was in /usr/bin/cabal and 1.20 got installed to /usr/bin/local/cabal
14:28:34 <barrucadu> solidus-river: GHC just works with .lhs files
14:28:49 <enthropy> gfixler: L in LP is logic or linear?
14:28:55 <monochrom> still, I would not write LaTeX in the comments in lhs
14:28:58 <enthropy> or something else
14:29:04 <monochrom> LaTeX is a write-only language
14:29:15 <monochrom> alongside with Perl
14:29:18 <josephle> enthropy: in this context, literate
14:29:19 <lpvb> if any of you are using xmonad + multiple ircs, tell me how you open so many different chats? One new process for each window?
14:31:31 <gfixler> enthropy: literate
14:32:35 <gfixler> lpvb: not using a tiling wm (yet), but I use irssi in the terminal
14:32:45 <enthropy> thanks
14:32:47 <gfixler> and just C-n and C-p through each channel
14:33:15 <monochrom> my http://www.vex.net/~trebla/haskell/IO.xhtml#organization is a trivial example of decoupling, cohesion, etc. I didn't need to be taught this when I was a haskell beginner. it made decoupling sense, haskell or not. you want each component of your program to worry about just one thing. basic trivial SE principle.
14:33:25 <solidus-river> lpvb: i use tmux and irssi and then i modified someones blogged post to make the roomList appear in a seperate pane for screen to work in tmux
14:34:04 <monochrom> yet many other haskell beginners, after learning IO, jump to the wrong conclusion "so every function in my program must do IO?"
14:34:23 <gfixler> monochrom: I think as few as possible should
14:34:37 <solidus-river> lpvb: then i use window-switcher for faster switchin around
14:35:11 <gfixler> solidus-river: faster than <prefix>n and <prefix>p ?
14:35:47 <monochrom> I think we're looking at how today's education teaches OOP wrong. teachers today use OOP to keep talking how you must generalize to no end.
14:37:10 <monochrom> the students get the mistaken message that you must generalize in all crazy directions. each class/object must be the umbella of everything under the sun. well that's going to hurt decoupling and cohesion etc
14:37:18 <solidus-river> gfixler: i do "/ws filter_by_name <Enter>"
14:37:24 <chrisdone> s/teaches OOP wrong/teaches wrong/
14:37:27 <solidus-river> so most of the time to get back here its
14:37:35 <solidus-river> "/ws hask <Enter>"
14:38:24 * hackagebot leveldb-haskell-fork 0.3.1 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-fork-0.3.1 (ifesdjeen)
14:39:05 <solidus-river> then theres another plugin that will send up a console beep when your name is mentioned and that notifies me in tmux's window list, between this, xmonad, vim and vimium for chrome i've pretty much ditched my mouse
14:39:19 <monochrom> well, I'm pretty sure the wrong teaching has much to do with trying to teach OOP. because no one made us generalize that much when there was no OOP when I was a student.
14:40:23 <benzrf> monochrom: class GenericSuperclass {} // generic superclass for all subclasses
14:40:38 <chrisdone> i was taught by people who today i wouldn't hire for a trivial task
14:40:46 <monochrom> suppose here is a homework/exam question: code up something to hold a student name and his/her course grade.
14:41:10 <chrisdone> (pretty much sums up my education)
14:41:12 <monochrom> pre-OOP model answer: a record that has those two fields
14:42:13 <monochrom> post-OOP model answer: it has to be a highly abstract class/object, because "there are a ton of things you may to add in the future!"
14:42:48 <hpc> interface IAbstractStudentManagerFactory<? super Student>
14:42:49 <chrisdone> siege warfare
14:42:56 <monochrom> decoupling and cohesion actually say the opposite: there are a ton of things you will never add, even in the future.
14:42:59 * sm hastily invokes http://c2.com/cgi/wiki?DoTheSimplestThingThatCouldPossiblyWork 
14:43:06 <chrisdone> better design your architecture right first time, who knows what will come later to attack you!
14:43:19 <benzrf> chrisdone: ive fallen prey to that ;-;
14:43:19 <chrisdone> … yet everyone knows the key to military success is mobility
14:43:33 <bergmark> chrisdone: how was emacs+haskell? i got stuck in query arrows so didn't make it :-(
14:44:08 <chrisdone> bergmark: not bad, we chatted about some things, troubleshooted some things here and there. in a couple weeks when me or alanz has something to demonstrate we'll do another, with more notice ahead of time =)
14:44:10 <benzrf> sm: it says:
14:44:11 <benzrf> > Resist being so greedy when seeking the 'simplest' thing today that the 'simplest thing' tomorrow becomes AddingEpicycles.
14:44:12 <lambdabot>  <hint>:1:123:
14:44:12 <lambdabot>      parse error (possibly incorrect indentation or mismatched brackets)
14:44:14 <benzrf> i like
14:44:20 <monochrom> now, I don't actually know what OOP per se advocates. I am just saying how teachers interpret and teach it.
14:44:22 <bergmark> chrisdone: cool :-)
14:45:06 <chrisdone> monochrom: it's like how teachers will teach you to model with entity relationship diagrams with non-trivial visual grammar or UML
14:45:15 <hpc> monochrom: good OOP would be "make a type with two fields and a small set of methods that will be your student api"
14:45:32 <chrisdone> when in reality people sketch something on paper which suffices for 90% of the time
14:46:58 <chrisdone> we even did http://en.wikipedia.org/wiki/Nassi%E2%80%93Shneiderman_diagram at my uni
14:47:10 <chrisdone> 70's hogwash
14:47:23 <chrisdone> computing education in the uk is godawful
14:48:00 <hpc> i don't think that's a regional thing
14:48:06 <Twey> chrisdone: We're trying to fix it
14:48:11 <chrisdone> probably not, but i can only speak from experience ;)
14:48:33 <chrisdone> twey: spj and his posse are doing a good job
14:48:48 <gfixler> I don't know if I'm right yet, but I've begun to feel that OO is highly unnecessary
14:49:07 <gfixler> and that it deserves no more favor than a for loop or a map; i.e. it's just another tool that can be handy
14:49:13 <benzrf> gfixler: no shit
14:49:18 <benzrf> gfixler: paradigms are paradigms
14:49:29 <jophish> preaching to the choir in this channel
14:49:32 <Twey> chrisdone: The goverment is into teaching programming from a young age at the moment.  So everyone who knows what's what has pounced and now we're all fighting to get *our* kind of programming taught from a young age ;)
14:49:37 <benzrf> they're frames of mind for approaching a problem
14:49:38 <gfixler> and that Java is crazy, because it forces all things to be OO
14:49:40 <benzrf> they're just tools
14:49:45 <tulcod> the haskell FFI is complaining about unacceptable argument types in foreign declarations. which types are deemed acceptable?
14:49:47 <chrisdone> twey: naturally ;)
14:49:52 <gfixler> which is as crazy as saying "All your code must be nested for loops"
14:49:53 <benzrf> gfixler: no, java's crazy because it forces things to be SHITTY OO
14:50:00 <levi> I would suggest that OO is a particular arrangement of more fundamental structures; that arrangement is subsumed by languages that provide the same building blocks in a more flexible manner.
14:50:01 <enthropy> tulcod: stuff like Double, CInt
14:50:09 <benzrf> gfixler: haskell forces everything to be functional, in a sense
14:50:10 <hpc> gfixler: i suggest you write some javascript and play around with control flow and data structures in that
14:50:10 <enthropy> Ptr Foo
14:50:10 <tulcod> enthropy: can you be more precise?
14:50:14 <aarvar> Is it neccesary to get a CS degree? I'm still in high school and I feel like I'll just "learn" a bunch of OO nonsense
14:50:15 <chrisdone> twey: of course,  they'll ruin it and make some people hate computing forever
14:50:18 <benzrf> gfixler: it's just not shitty fp
14:50:18 <benzrf> :-)
14:50:23 <hpc> gfixler: you'll find yourself writing a lot of functional code and OO code mixed together, and it's quite nice
14:50:25 <chrisdone> twey: but at least there'll be a higher level of literacy
14:50:31 <vanila> Haskell makes it easy to use a variety of programming paradigms via monads
14:50:33 <gfixler> hpc: I've written 10s of thousands of lines of JS
14:50:40 <Twey> chrisdone: Yup
14:50:40 <gfixler> and Flash AS
14:50:42 <zomg> aarvar: if you wanna write code, no. If you wanna learn CS, yes
14:50:43 <benzrf> ruby > js
14:50:44 <tulcod> aarvar: yes, you will not be happy until you get your CS degree
14:50:52 <benzrf> ruby can do most stuff js can do, and more pleasantly
14:51:01 <monochrom> tulcod: Haskell 2010 chapter 8 has the exact criterion
14:51:03 <hpc> ruby has completely guzzled the OOP kool-aid
14:51:06 <tulcod> monochrom: thanks
14:51:08 <josephle> aarvar: CS /= OOP if taught correctly
14:51:13 <Twey> gfixler: http://blog.higher-order.com/blog/2008/12/04/no-such-thing/
14:51:22 <hpc> trying to read the official tutorial was like going through a manifesto
14:51:25 <benzrf> hpc: at least it supports HOFs
14:51:33 <chrisdone> OOP used to make sense to me as a useful thing
14:51:38 <hpc> and js doesn't?
14:51:48 <benzrf> hpc: js does, but the syntax blows
14:51:49 <aarvar> Let's say I was capable of learning everything on my own. How useful is the degree
14:51:55 <hpc> that's true
14:51:56 <bb010g> josephle: ORLY? According to the College Board, Computer Science is all Java...
14:52:00 <benzrf> hpc: my point is that ruby is nicer
14:52:01 <josephle> http://www.cs.cmu.edu/~aldrich/papers/objects-essay.pdf -- a defense of OOP from a former research advisor of mine
14:52:03 <gfixler> hpc: I actually quite loved ECMA-262
14:52:09 <gfixler> later I found out that tons of people hate it
14:52:10 <benzrf> hpc: not that it's ideologically superior or something
14:52:18 <napping> aarvar: there's a lot from the "science" part that harder to get on your own
14:52:22 <josephle> bb010g: if College Board is your measuring stick for education, we have other problems at hand...
14:52:44 <tulcod> monochrom: exactly the information i was looking for, greatly appreciated.
14:52:51 <aarvar> Well let's say im an exceptional learner for argument's sake
14:52:53 <benzrf> hpc: i tend to prefer [1, 2, 3, 4].map {|n| n + 1} to [1, 2, 3, 4].map(function(n){return n + 1;})
14:52:54 <monochrom> you're welcome
14:52:56 <gfixler> bb010g: according to the jobs available right now, CS actually is all Java
14:53:02 <bb010g> josephle: It isn't. I wish it was actual Comp Sci. The thing is, newer people may use them.
14:53:08 <gfixler> it's like 60% or more of the market
14:53:29 <hpc> when CS education isn't java, it's C
14:53:45 <chrisdone> twey: you're gonna work on my awesome teaching tool one day
14:53:45 <hpc> where you learn valuable skills like ignoring a buffer overflow bug in order to make a deadline
14:53:52 <enthropy> tulcod: Somewhere there's a list of which haskell types correspond to particular C types (maybe in Foreign.C?)
14:54:01 <chrisdone> twey: it'll be so awesome that you'll not not be able to resist =p
14:54:05 <tulcod> enthropy: yes, i know, but i'm using some opaque pointer types
14:54:10 <Twey> chrisdone: \o/
14:54:15 <Twey> chrisdone: How will it be awesome?
14:54:22 <tulcod> enthropy: and usually it works, but in this specific case it doesn't compile and i need to know why
14:54:50 <benzrf> hpc: also, ruby actually understands the idea that expressions are nicer than functions
14:54:53 <bb010g> chrisdone: I want to see this tool
14:54:56 <benzrf> er
14:55:00 <benzrf> nicer than statements >->'
14:55:25 <hpc> javascript doesn't really have anything against expressions imo
14:55:30 <hpc> that's more python's thing
14:55:33 <aarvar> I took a java course at community college and the teacher had no idea what he was talking about. It's made me question the value of college
14:55:41 <enthropy> tulcod: "Ptr X" for any X should be valid
14:56:02 <enthropy> you're not trying something like   foreign import ccall "foo" foo :: ForeignPtr () -> IO ()?
14:56:04 <tulcod> enthropy: i don't want to expose the fact that it is a pointer, so i must use newtype
14:56:15 <mgaare> aarvar: doing a degree confers professional benefits, contacts and connections, the ability to do higher degrees, and people to talk to about things
14:56:17 <levi> aarvar: Time spent at a university will give you a couple of things that self-study won't: It'll expose you to things you wouldn't have chosen to study on your own, and it will expose you to people you wouldn't have otherwise met.
14:56:27 <benzrf> hpc: then why do i have to write return
14:56:30 <bb010g> It seems that any course that teaches Java could gain somewhat by teaching C# instead.
14:56:44 <enthropy> tulcod: oh then just make sure the newtype constructor is in-scope where you have the foreign import
14:56:47 <benzrf> hpc: why do i have to say `var x; if (foo) {x = 3} else {x = 4}'
14:56:59 <monochrom> tulcod: the rule about newtypes in Chapter 8 is kind of new, not there before Haskell 2010.
14:57:01 <tulcod> enthropy: yes, i figured as much from the haskell docs
14:57:04 <aarvar> levi: what are some things that I wouldn't otherwise study
14:57:05 <bb010g> benzrf: CoffeeScript!
14:57:05 <benzrf> hpc: why cant i say `if foo; 3; else; 4;'
14:57:10 <benzrf> bb010g: indeed
14:57:30 <enthropy> the error message is pretty unhelpful, I'm pretty sure there's a ghc bug on it
14:57:42 <tulcod> which is why i wanted to know the exact criterion :)
14:57:44 <levi> aarvar: I don't know; I'm not sure what things you're inclined to study on your own or what path you might choose through the university curriculum.
14:58:13 <chrisdone> twey: my plan is to store facts and rules about a topic in a datalog database, and then generate descriptions of that topic and exercises, randomly seeded. you'll not see the same exercise often. sort of like how quickcheck generates structurally valid values from a type spec
14:58:13 <chrisdone> twey: and when you answer, or if you give up, the system can either show you the derivation of the question (from facts and rules), or downgrade the question into its constituent parts to ask more fundamental questions
14:58:21 <aarvar> Let me rephrase that. What things might I miss out on learning that would be valuable?
14:58:22 <chrisdone> twey: so rather than a book containing pros and exercises, it's a graph of nodes sorted by most direct and indirect (weighted, i guess) edges, and you pick and choose the topic to learn. and the "book" knows what you've learned by a basic Leitner system or similar
14:58:31 <enthropy> tulcod: https://ghc.haskell.org/trac/ghc/ticket/5610 seems to be fixed for the next ghc release
14:58:47 <aarvar> That's still rather vague though I guess
14:58:52 <levi> aarvar: If they could be enumerated that easily, then there really wouldn't be much value to going there. :)
14:59:06 <tulcod> enthropy: that's good to hear
14:59:35 <chrisdone> twey: really, it's for myself. whenever i approach a new topic, i wish i had an interactive version of wikipedia, basically. i don't learn from being lectured to, i learn from interaction
14:59:36 <bb010g> chrisdone: I want to use that. :D
14:59:39 <mgaare> aarvar: most of MIT's curriculum (among others) is online, so I don't think that's a big disadvantage of self study anymore
14:59:54 <Twey> chrisdone: Oh!  I did something like this for my A-level coursework
14:59:57 <chrisdone> bb010g: hurrah, my first user =) i'm still working on the datalog engine
15:00:02 <chrisdone> twey: yeah?
15:00:29 <aarvar> So then the main disadvantage is not having the actual degree
15:01:02 <tulcod> aarvar: these days you don't really need a paper to get into science jobs. however, it's easy to underestimate what you learn from such a degree.
15:01:18 <levi> aarvar: But if you go, you will most likely end up taking some sort of class that you wouldn't have imagined needing to learn otherwise. Maybe it'll end up being a literature class or history or language.
15:01:19 <josephle> chrisdone: is this like Knuth's flowchart on how to read TAoCP?
15:01:20 <Twey> chrisdone: Just the exercise generation part.  Rather than specifying actual exercises, educators specified exercise *templates*, i.e. functions that took a random input of some specified type and used it to generate an exercise and answer
15:01:26 <tulcod> aarvar: although admittedly you can skip the first year, say
15:01:49 <napping> aarvar: going at it from the other side, if you're decent at programming the coding coursework probably won't take much time from learning stuff
15:01:56 <mgaare> aarvar: that, and the loss of connections and interactions, I would say are hte main disadvantages
15:02:02 <levi> aarvar: Maybe some aspect of CS that you hadn't thought of before.  Maybe the subject won't matter, but the people involved will; a classmate or professor.
15:02:06 <aarvar> other than programming in java frustrates me
15:02:08 <chrisdone> twey: right, that's indeed similar. example of a type?
15:02:16 <Twey> chrisdone: It was all in Python and Lua and TeX though :þ
15:02:22 <chrisdone> josephle: hmm, link?
15:02:38 <mgaare> aarvar: how much java have you done
15:02:42 <napping> aarvar: if you were planning to systematically work through some curriculum anyway, might as well go?
15:02:54 <bb010g> Twey: So pretty much QuickCheck with you doing the tests?
15:03:00 <Twey> chrisdone: The focus was on GCSE maths, so the only supported types were reals and nats.  But you could in theory extend it.
15:03:10 <aarvar> I learned java as my first language about two years ago. and then scala a year ago, and now its on to haskell
15:03:11 <Twey> bb010g: Yeah, pretty much
15:03:18 <levi> If you're inclined to just treat a university as a fancy trade school, you may be better off not spending the money on it.
15:03:23 <josephle> chrisdone: Knuth did this somewhat tongue in cheek http://stackoverflow.com/questions/4951411/which-volume-of-taocp-should-i-start-with
15:03:57 <Twey> If you're inclined to treat university as a trade school, everyone else would also be better off if you didn't spend the money on it.
15:04:06 <tulcod> aarvar: if you go to do a degree, you'll definitely be ahead of some people. but that doesn't mean it's a waste of time - you just won't need to spend time on some preliminaries
15:04:19 <tulcod> aarvar: now, whether it's a waste of money, we can't decide for you
15:04:29 <chrisdone> twey: hehe. the obvious example is, if you have a rule like: The representative of a state lives in the capital of that state. The capital of the US is Washington D.C. The representative of the US is Barack Obama. now the system can generate "Where does Barack Obama live?" because it knows that you've learned the previous two facts in the past, it can expect you to be able to put two-and-two together. if you can't, it can explain the
15:04:29 <chrisdone> derivation
15:04:41 <aarvar> The other thing is I tend to get bad grades and have no money
15:05:04 <Twey> chrisdone: I think someone made a similar bot for Lojban once
15:05:17 <Twey> I don't remember what it was called
15:05:27 <chrisdone> twey: Eimi, i think. it would generate ontologically accurate facts from a database
15:05:37 <chrisdone> er, not facts. claims
15:05:44 <levi> Having to work hard to pay for tuition can be surprisingly effective at increasing grades for some people.
15:05:58 <bb010g> chrisdone: I wonder if that could be hooked up to W|A at some point.
15:06:09 <bb010g> Lots of facts there
15:06:12 <Twey> chrisdone: Ah, could be
15:06:22 <Twey> bb010g: But not in any useful format.
15:06:31 <aarvar> I just feel like I might be wasting my time since math and programming come easily to me. I tend to learn more quickly than a class can probably teach when im interested in the subject
15:06:34 <chrisdone> bb010g: if it would export in something like FoL, perhaps
15:06:43 <Twey> chrisdone: Also of interest might be http://web.engr.oregonstate.edu/~erwig/XOP/
15:06:54 <napping> aarvar: having a degree tends to help getting money
15:07:14 <napping> aarvar: I feel the same, but I still learned a bunch of stuff I wouldn't have picked up on my own
15:07:22 <chrisdone> twey: neat links, thanks
15:07:52 <napping> I suppose you might see if you can secure a decently paying programming job right off the bat
15:07:57 <chrisdone> twey: (this is why i started on my attempto controlled english parser. lojban gave me a taste for the things that can be done)
15:08:04 <Twey> aarvar: Being at university means being surrounded by smart people, some of whom are probably interested in the same stuff as you, and being constantly motivated to learn new things.  The lectures are incidental and IME more of a hindrance to learning than a help.
15:08:07 <aarvar> napping: Could you give me an example of something you learned that you probably wouldn't have otherwise which you think is valuable
15:08:07 <levi> aarvar: If you take that as an excuse to slack, then it probably will be a waste of money. But if you instead take it as an opportunity to engage with professors to get more challenging things and learn related topics, you can forge important relationships and learn faster than you would on your own.
15:08:15 <vanila> "Being at university means being surrounded by smart people" - This is not true
15:08:22 <napping> I doubt I could have taught me abstract algebra
15:08:39 <vanila> It's possible that formal education will just be really harmful to you
15:08:40 <josephle> now, if you can collect some restraining orders from various tech companies due to your exploits...
15:08:41 <napping> It was surprisingly hard to even find a decent definition of big-O complexity online
15:08:45 <napping> all kinds of computability stuff
15:09:04 <napping> algorithms
15:09:51 <napping> like, interestingly efficient algorithms
15:10:03 <aarvar> Well, I'm good at math, with the right online resources I could cover all that stuff probably
15:10:12 <moghedrin> aarvar: It sounds like you've already decided.
15:10:13 <d_k> napping: “it was” how many years ago?
15:10:14 <fractalsea> For me the best thing about uni was just motivating me to get a heck of a lot done, and the people I met.
15:10:15 <napping> Nah, these are stuff that didn't have good online resources
15:10:19 <levi> aarvar: It's not always a matter of not being able to learn something on your own. Being able to converse at will and in person with people who are experts can be a great *accelerator* of learning.
15:10:22 <napping> 15 or so?
15:10:26 <fractalsea> Looking back I learned way more online than I ever did in lectures.
15:10:41 <aarvar> moghedrin: not at all
15:10:42 <napping> If you're thinking of buying a big stack of good textbooks you could probably cover a lot
15:10:46 <gfixler> levi: absolutely - the #1 thing for me about college was the people
15:10:50 <gfixler> several of them got me jobs later
15:10:54 <tulcod> aarvar: look, if you don't feel you are missing anything, don't go do a degree right now. go work, and perhaps save up, reconsider it later
15:11:00 <d_k> napping: heh, then I’m surprised you were able to find anything about big O :)
15:11:00 <napping> yeah, don't pick a bad school
15:11:07 <gfixler> people I'd all but forgotten about new I had skills in areas and contacted me out of the blue
15:11:08 <desophos> imo, the best reason to go to college/university is having access to professors as resources
15:11:20 <napping> and I was even reading some papers online and stuff before that
15:11:30 <Twey> It's all about the people and the atmosphere.
15:11:48 <vanila> that's right: formal education isnt' about learning stuff - it's about being a social climber and exploiting the situation for your own gain
15:11:52 <Twey> vanila: Okay, you still have to seek them out.  But they're there.
15:11:53 <napping> So just casually being really curious about stuff an decently smart didn't get me anything resembling a comprehensive background
15:11:55 <desophos> other students rarely help with your actual education
15:12:03 <gfixler> I'm 15 years out of school now, and it's been far harder to find anyone to talk to about anything
15:12:06 <fractalsea> Personally, I found conversation with clever classmates more helpful when I didn't get something than professors.
15:12:07 <gfixler> I have to use the internet
15:12:19 <mgaare> aarvar: if you do decide to go it alone, I'd suggest looking at this: http://web.mit.edu/catalog/degre.engin.ch6.html and actually going through all the courses (lectures and a lot of materials are available) here: http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/
15:12:20 <gfixler> everyone I knew spread around the world, familied-up, and stopped talking about all of this stuff
15:12:27 <tulcod> gfixler: i'm still in higher education, and hearing that makes me sad
15:12:35 <gfixler> tulcod: it is sad :(
15:12:53 <gfixler> and it happened fast
15:12:57 <gfixler> 15 years isn't *that* long
15:13:00 <tulcod> gfixler: i'm afraid that me wanting to stay in academia is sorta driven by that
15:13:02 <fractalsea> gfixler: I don't know where you live, but if you are near any user groups, that's a great way of meeting like minded, technical, people
15:13:05 <gfixler> I wanted a good 50 years of going at this stuff
15:13:11 <gfixler> and 15 years in, it's evaporated
15:13:19 <desophos> talking and studying personally with professors was definitely the best education i got out of college
15:13:20 <tulcod> fractalsea: meeting up with people is different. uni is every day.
15:13:27 * hackagebot twitter-types 0.4.20140809 - Twitter JSON parser and types  http://hackage.haskell.org/package/twitter-types-0.4.20140809 (TakahiroHimura)
15:13:34 <gfixler> tulcod: everyone tells me I should get back into academia, because I can't find anyone on the outside who's interested
15:13:56 <desophos> i guess it depends on what you're interested in
15:14:01 <d_k> gfixler: who’s intereseted in what?
15:14:09 <fractalsea> tulcod: True. I guess finding a good work environment is very important.
15:14:12 <gfixler> d_k: the kinds of things we chat about in here
15:14:13 <desophos> and what resources your college/uni has
15:14:19 <aarvar> I suppose the other question is: Would it be difficult to get a programming job while going to college?
15:14:33 <desophos> e.g. my college had very few professors who were interested in what i was interested in
15:14:36 <tulcod> aarvar: no.
15:14:52 <trap_exit> has anyone here done female voice synthesis in haskell? I am building an app, and I need an attractive female voice to say thigns like "twenty three plus four is twenty seven"
15:14:56 <desophos> aarvar: depends how your college handles programming
15:14:56 <mgaare> aarvar: depends on location. I know in Atlanta there are tons of opportunities for paid programming internships and such if you know what you're doing
15:14:58 <gfixler> desophos: I never really had a relationship with a teacher (we didn't have professors)
15:14:58 <monochrom> yes. both of them want your full 24-hour day.
15:15:00 <tulcod> aarvar: will you get a good pay for it? much better than teaching, but still hardly enough to make a living
15:15:01 <trap_exit> but it can't be pre-recorded, since I need to generate lots of wav files
15:15:11 <gfixler> desophos: it was all with other students
15:15:19 <desophos> gfixler: interesting, i envy you then haha
15:15:33 <gfixler> desophos: full-disclosure: I went to art school
15:15:38 <gfixler> for computer animation
15:15:39 <desophos> if you were around students who could actually help you
15:15:42 <vanila> How does one get a programming job? Especially if they have only been in academia before?
15:15:44 <gfixler> but got into the technical side of it pretty quickly
15:15:44 <aarvar> I'm in washington state if that's relevant
15:15:49 <monochrom> if you can clone yourself then you can go to programming job and school simultaneously.
15:15:51 <gfixler> tools, pipelines, etc
15:15:54 <fractalsea> Looking back I do agree what is being said here. I enjoyed where I used to work, but I could never chat about category theory like I did at uni
15:16:11 <gfixler> desophos: the students were amazing in all different ways
15:16:13 <d_k> gfixler: the best way to build solid social connections is to do things together. It has always been easy for me to find people interested in programming, they were just working with me. Fidning people interested in other things was a real problem
15:16:13 <desophos> fractalsea: isn't that what IRC is for? ;)
15:16:20 <tulcod> gfixler: yes, CS/math departments tend to be different
15:16:22 <gfixler> amazing painters, animators, photoshop users, technical types, riggers
15:16:35 <tulcod> gfixler: you can definitely go out and look for contact with higher-ups, anyway
15:16:41 <desophos> my college didn't have much of a CS department
15:16:45 <gfixler> tulcod: true, I need to be more proactive
15:16:58 <desophos> so i had very few people interested in what i wanted to do
15:16:59 <mgaare> In most CS programs, there is actually an astounding lack of sincere interest in realy doing it among the students. At my last job, we were looking for interns, and it was almost impossible to find anyone who had done any side projects or shown any interest in applying what they were doing or expanding their horizons at all
15:16:59 <fractalsea> desophos: Yes true, but I prefer real life convos if I can. Particuarly if I'm finding it hard to put difficult something into words
15:17:10 <vanila> anyone? :(
15:17:16 <gfixler> d_k: I work with many devs, but they never want to talk about this stuff with me, unfortunately
15:17:20 <desophos> vanila: that's a pretty difficult question
15:17:27 <gfixler> they actually get annoyed when I try
15:17:37 <fractalsea> desophos: The umming, arring, and frantic gesturing often gets the point accross
15:17:38 <gfixler> and trying too often has made them all avoid me now
15:17:40 <mgaare> it got to the point where if a CS student came up to me and just had a github profile, they'd practically get hired on the spot :D
15:17:58 <vanila> well if anyone would like to help me i would appreciate it massively
15:18:02 <desophos> fractalsea: well ideally we'd all work with people with whom we could talk about these sorts of things
15:18:12 <tulcod> vanila: send an email to *any* company.
15:18:14 <gfixler> vanila: start small
15:18:17 <mgaare> vanila: what kind of academic work or research have you done?
15:18:20 <aarvar> So I should go code some project to show off then?
15:18:21 <acowley> vanila: There's no easy answer. You submit applications and keep your eyes and ears open for every opportunity!
15:18:24 <gfixler> if you have no experience, you get a job that needs no experience
15:18:29 <gfixler> low-level, entry position
15:18:30 <tulcod> vanila: really, everyone is looking for programmers. now, an *interesting* programming job, that's the real challenge
15:18:38 <d_k> gfixler: if people are interested in what they are doing they’ll definitely talk about that. So may be you’ve been working with people who weren’t interested in their profession. I barely can find other arguments
15:18:41 <gfixler> then you push like hell there and play the political games and climb the ladder
15:18:47 <mgaare> aarvar: yes, absolutely. That is just about the most important thing that you can do, in my opinion.
15:18:58 <fractalsea> mgaare: It would be nice if unis encouraged open source involvement more. Sometimes it is hard to know where to start as a student and it can be quite daunting
15:19:01 <gfixler> d_k: I think they're interested in their profession
15:19:03 <aarvar> Now I just need to think of what to program then
15:19:08 <gfixler> but they're on a much more practical side of it
15:19:11 <gfixler> the 'get things done' side
15:19:17 <gfixler> I'm more on the invest-in-the-future side of it
15:19:33 <mgaare> aarvar: It's also really, really great to contribute to other open-source projects, especially those used in areas you're interested in
15:19:39 <desophos> i like the idea of working in academia (in accord with my interests) but realistically i'm not gonna get there
15:19:42 <tulcod> aarvar: scratch an itch
15:19:45 <gfixler> this industry tends to create a lot of things in short order, then throw them all away and start over on the next project
15:19:52 <gfixler> I've done that 5x longer than many of them
15:19:53 <tulcod> aarvar: that's pretty easy with haskell
15:19:54 <gfixler> and I'm tired of it
15:19:59 <mgaare> companies that use open-source stuff are usually HUGELY enthusiastic about hiring people who contribute to the things they use
15:20:06 <gfixler> so I want to invest and create robust things that solve the higher-order patterns
15:20:10 <acowley> Why does GHC think it's cool to tell me "Context reduction stack overflow"?
15:20:11 <gfixler> and that frustrates them
15:20:22 <frsilent> I went to school & got a CS degree; interviewed with a bunch of really tough companies, some of which that weren't interested in me if I couldn't do a bunch of algos/DSes on the spot
15:20:51 <frsilent> ended up getting a job my former boss recommended me for (doing django for a small company) starting at 30k/yr more than most the places I'd been interviewing at
15:20:55 <monochrom> acowley: do you happen to use UndecidableInstances? it is one cause.
15:21:04 <acowley> frsilent: What's a DS?
15:21:09 <frsilent> data structure
15:21:10 <acowley> monochrom: I almost certainly do
15:21:42 <monochrom> then you likely have an infinite recursion in your instance relations
15:21:43 <desophos> it seems like the programming job market varies hugely depending on where you live
15:21:53 <desophos> i keep seeing people talk about how easy it is to get a job
15:22:00 <frsilent> desophos: true but *a lot* of companies are much more open now to remote employment
15:22:06 <mgaare> fractalcat: yes, it definitely would be. Unis seem to do a lot of disservice to students
15:22:07 <desophos> frsilent: not in my experience
15:22:13 <frsilent> like the market's change drastically in the last 2-3 years I've seen
15:22:17 <chrisdone> gfixler: http://sifter.org/~simon/journal/20121123.h.html
15:22:21 <monochrom> by which I mean, for a trivial example, "instance Show a => Show a"
15:22:25 <frsilent> start applying to jobs in the valley maybe
15:22:46 <tulcod> frsilent: does "the valley" mean "silicon valley"?
15:22:47 <frsilent> I know of at least 5 very well-known companies that do remote employment
15:22:50 <frsilent> yeah
15:22:53 <Exio4> if i need any kind of "programming" job around my city, it is either Java or Java
15:23:03 <tulcod> Exio4: does that include scala?
15:23:13 <desophos> i was looking for a job for months (since around November of last year) and ended up in this job where i'm hardly doing any programming and being paid very little
15:23:19 <acowley> monochrom: Hm, yeah. It's not that simple. This is some driver code that takes a higher rank argument, and I've added another pass to how that argument is used. The original code works, and the extra pass works by itself. Together they blow up.
15:23:19 <monochrom> "either Java or Java" is a fun way to put it :)
15:23:28 <Exio4> tulcod, not really :(
15:23:39 <chrisdone> gfixler: ^ article pretty much sums up your attitude
15:23:46 <monochrom> then likely some subtle mutual recursion
15:23:53 <desophos> i have a github profile, i've done personal projects, all anyone wanted was industry experience
15:23:56 <acowley> monochrom: Yeah, I think that's it
15:24:15 <desophos> so i'm skeptical of people saying that it's easy to get a programming job.
15:24:20 <Exio4> monochrom, Maybe Java!
15:24:21 <chrisdone> The bottom line is: there is no escaping the need to make best effort to understand the whys and wherefores. To skip this and go straight for the fix is not humbly admitting the system is too complex to understand, it is arrogantly assuming we understand it well enough to fix it without breaking it. The humble thing to do is less, not more--to respect the difficulty in keeping any complex system stable, and the degree to which doing so
15:24:21 <chrisdone> relies upon a best effort by, and freedom of, each component to self-regulate.
15:24:22 <josephle> desophos: the larger companies don't require industry experience..
15:24:25 <frsilent> desophos: it may just take time but a tiny bit of experience goes a very long way
15:24:53 <Mathnerd314> I forget, does GHC do rebindable lists yet? (e.g. [1,2,3] :: Vector Int)
15:25:11 <uberwach> tfw never applied to a large company
15:25:13 <tulcod> desophos: i guess it is area dependent then. here in northwestern europe, you get a programming job for free with your lunch
15:25:20 <chrisdone> Mathnerd314: overloadedlists?
15:25:25 <desophos> i'm in LA btw
15:25:29 <frsilent> desophos: do you have meetups in your city? every single one I go to there's a part that's like "Who's hiring?" & 95% of hands go up
15:25:37 <Mathnerd314> chrisdone: thanks :-)
15:25:55 <frsilent> particularly on the web end; js meetups & such
15:26:01 <chrisdone> frsilent: start-ups, presumably
15:26:07 <uberwach> in Berlin meetups are the way to go, but startups always try to lowball... and not by undercutting market rate by 20% but rather 50%
15:26:15 <tulcod> start-ups, web dev, tons of job offers on that
15:26:18 <acowley> chrisdone: How did the hangout earlier today go?
15:26:26 <tulcod> start-up web dev, those are the worst
15:26:30 <uberwach> s/always/most often/
15:26:34 <desophos> there appear to be plenty of jobs, just none that would accept me, so maybe it's fine for someone with more experience
15:26:49 <vanila> desophos, yeah, it seems that way to me too
15:26:50 <frsilent> shit a failed startup is still experience & hopefully a decent paycheck
15:26:51 <gfixler> chrisdone: yes, this seems to the basics of it
15:27:01 <gfixler> it's Jersey Style vs. MIT Style
15:27:14 <chrisdone> acowley: yeah it was not bad. a few people talking, more listening in. we chatted about a few things. i think we'll have another in a few weeks after i or alan zimmerman has something to demonstrate, then we can do a demo and chat about it
15:27:28 <bergmark> i'm doing startup web dev, it's the best :-)
15:27:43 <uberwach> bergmark: which tech stack?
15:27:53 <chrisdone> uberwach: the best
15:27:53 <acowley> chrisdone: I really like the idea of there being a vibrant intersection between Haskell and emacs
15:27:58 <frsilent> I do the same, primarily django/jquery
15:28:05 <gfixler> frsilent: haven't found much in the way of meetups in LA
15:28:07 <gfixler> it's a weird place
15:28:14 <gfixler> AT&T coverage is also really bad here, which makes no sense
15:28:28 <Exio4> here if you want a job "easy and fast", you code Java (or if webdev, PHP+HTML+JS)
15:28:46 <uberwach> Exio4: Java w/ Spring ;)
15:28:50 <chrisdone> acowley: yeah, me too =)
15:28:57 <bergmark> uberwach: haskell and typescript
15:28:59 <tommd> What about "interesting" and "meaningful"?
15:29:10 <tulcod> ugh. why are most programming jobs 15 years behind on actual developments...
15:29:11 <uberwach> bergmark: where? :O
15:29:18 <josephle> tommd: you can fix that with enough Camus and Sarte. :P
15:29:26 <bergmark> uberwach: www.silk.co http://jobs.silk.co/
15:29:30 <acowley> chrisdone: Do you know if anyone out there is working on better org babel support?
15:29:36 <chrisdone> tulcod: takes 15 years to make a successful company? =p
15:29:51 <vanila> I would do anything, java, even .ASP I just don't want to lose my house :(
15:29:51 <chrisdone> acowley: that area is unfamiliar to me
15:30:11 <tulcod> chrisdone: well if a successful company means being alive for a couple of years, then presumably yes
15:30:19 <acowley> tulcod: And after you're successful, people move in who are unwilling to fix what isn't 100% broken
15:30:21 <uberwach> money = appreciation for me, would kill for a humble dev team...
15:30:31 <tulcod> acowley: ugh. the sad state of the world.
15:30:40 <uberwach> quit my current job, because of communication issues and outsourced programmers... :/
15:31:01 <chrisdone> acowley: i set 'em up, you knocked 'em down =)
15:31:03 <acowley> chrisdone: I have rather a lot of code that generates pretty pictures and movies and such and would quite like a way to scriptify the whole thing.
15:31:05 * chrisdone high fives
15:31:14 <acowley> o/
15:31:21 <chrisdone> in haskell?
15:32:09 <acowley> chrisdone: I can probably do what I want with pandoc, tbh. I just really don't want to reinvent anything.
15:32:11 <chrisdone> tulcod: i worked at such a company. they were using ASP classic. php was modern to them
15:32:12 <tulcod> bergmark: wait, is this the website that is basically a fancy graph plotter?
15:32:30 <Mathnerd314> chrisdone: do you know of any instances of IsList?
15:32:37 <tulcod> chrisdone: the only thing i can think about is thedailywtf.com
15:32:48 <tulcod> chrisdone: ASP? major red flag
15:33:21 <chrisdone> Mathnerd314: [a]? =)
15:33:32 <chrisdone> tulcod: ya think?
15:33:58 <Mathnerd314> chrisdone: I was looking for Vector :: Nat -> *; I found sized-vectors but it doesn't seem to implement IsList...
15:34:10 <acowley> While I like to sneer at how slow companies move, I'm trying to come to terms with how much effort Facebook pours into PHP
15:34:11 <chrisdone> Prelude> :set -XOverloadedLists
15:34:12 <chrisdone> Prelude> :t []
15:34:12 <chrisdone> [] :: GHC.Exts.IsList l => l
15:34:13 <chrisdone> Prelude GHC.Exts> :i IsList
15:34:14 <chrisdone> class IsList l where …
15:34:17 <chrisdone> instance IsList [a] -- Defined in ‘GHC.Exts’
15:34:28 <acowley> I don't really understand why they do it
15:35:07 <Trollinator> acowley: what is there to understand? they have millions of lines of code they want to run faster.
15:35:10 <chrisdone> acowley: i guess because humans are bad at long term things
15:35:42 <vanila> is there anything significantly better than PHP?
15:35:56 <tulcod> haha
15:35:58 <chrisdone> is there anything *not* significantly better than PHP?
15:35:58 <josephle> vanila: facebook would like you to think Hack is :)
15:36:00 <Trollinator> vanila: lung cancer.
15:36:14 <tulcod> Trollinator: nice
15:37:05 <vanila> so what should I use instead of PHP?
15:37:09 <chrisdone> acowley: also, perhaps zuckerberg still has influence
15:37:19 <acowley> chrisdone: But they have so many talented employees
15:37:34 <Trollinator> vanila: given the channel you're in, what do you expect people to say?
15:37:36 <chrisdone> yup, most of who probably recognize that php is a turd
15:37:51 <tulcod> vanila: use C++ if you have no other choice
15:37:58 <tulcod> anything but PHP
15:38:07 <tulcod> man, if you use visual basic i'm fine with that
15:38:08 <acowley> So maybe one day, in the cafeteria, they could just be like, "Hey, show of hands, who wants to keep using PHP?"
15:38:17 <Trollinator> hey, it's better than sh
15:38:35 <chrisdone> but zuckerberg was just some mediocre programmer who wrote yet another profile site at the right time, clearly he lacks any programming language judgement. but he certainly has clout
15:38:36 <mgaare> when facebook started, it was pretty much either that or perl
15:38:39 <vanila> C++ will work worse than PHP because over stack overflows etc.
15:38:59 <tulcod> vanila: ah of course, because PHP doesn't have a stack. oh wait.
15:39:10 <chrisdone> mgaare: you make it sound like it was the 90s
15:39:15 <vanila> tulcod: are you sure you don't know what I'm talking about?
15:39:25 <Trollinator> there was a time when the PHP interpreter crashed when you overflowed the stack. I don't know if that's still true...
15:39:44 <tulcod> vanila: well i don't know what you're trying to say by referring to stack overflows, because php can have those as good as any language with a stack
15:39:51 <chrisdone> mgaare: meanwhile reddit writes their system in lisp
15:39:51 <mgaare> chrisdone: it was 2003, 2004. What other reasonable choice was there at the time?
15:39:56 <chrisdone> mgaare: and then rewrites it in python
15:39:57 <desophos> chrisdone: really?
15:40:05 <chrisdone> zuckerberg sticks with php
15:40:10 <tulcod> chrisdone: nice
15:40:10 <vanila> tulcod, There is a common class of security vulnerabilities in C and C++ programs here you take control of the program and execute arbitrary code by smashing the stack
15:40:22 <vanila> tulcod, PHP protects against this, so C++ is a worse choice than PHP for writing a site
15:40:29 <tulcod> vanila: that's called a buffer overflow, and explicitly a problem of C rather than C++
15:40:42 <tulcod> because you don't use char* but the String class
15:40:42 <Trollinator> well, Perl would have been a better choice… better as in Matrix 2 being better than Matrix 3.
15:40:44 <acowley> Yeah, the way FB started with PHP makes plenty of sense
15:40:48 <tulcod> or std::string, w/e
15:41:13 <bb010g> chrisdone: It's in Python now.
15:41:23 <chrisdone> bb010g: read the whole log
15:41:25 <Trollinator> nonsense… an iterator has *exactly* the same problems as a pointer.
15:41:28 <tippenein> PHP is great if you spend all your time writing libraries around it in haskell and ocaml to analyze it and recompile it to something that doesn't suck
15:41:29 <Trollinator> in C++, that is.
15:41:30 * chrisdone beats bb010g with a large trout
15:41:32 <tulcod> vanila: and whatever security you think PHP has over another language it easily makes up for by any of the other "design choices" they made
15:41:56 <bb010g> chrisdone: *derp*
15:41:59 <tulcod> tippenein: that sounds like a fight with the devil. have you been there?
15:42:14 <mgaare> vanila: bear in mind that the php interpreter is written in C, so...
15:42:29 <tippenein> I've seen their opensource libraries
15:42:30 <chrisdone> acowley: although, i think dynamic languages encourage their continued use like that
15:42:33 <Mathnerd314> I wonder if kind inference could be combined with name resolution, so constraints were in a different namespace from other types (like the current type/value split)
15:43:18 <chrisdone> acowley: it's really frightening to have a system that you care about written in something like php, javascript or python. you know you can't refactor it. especially when it starts to get hairy, and involve things like handling money. I Ain't Touching That
15:43:45 <chrisdone> or lisp
15:43:54 <hodapp> I thought even Facebook went with a variant of PHP, Hack?
15:43:58 <Trollinator> I once applied for a python job. I recently considered writing them a thank you email for not taking me.
15:43:58 <abc56889> How do I match a data constructor without capturing it's arguments, instead capturing the whole boxed object?
15:44:23 <tippenein> https://github.com/facebook/pfff for example is the sound you make when you realize they're still holding onto php
15:44:26 <chrisdone> acowley: number of times i've seen codebases that even their own authors are afraid to change, because "it works so leave it"
15:44:28 <Trollinator> though thinking about it it seemed a bit dickish.
15:44:28 <uberwach> Trollinator: in de?
15:44:31 <acowley> chrisdone: Yeah, I can understand that, and I'm sure I underestimate the size of their code base.
15:44:32 <ClaudiusMaximus> abc56889: foo@(Constr{})
15:44:37 <Trollinator> uberwach: ja.
15:44:38 <sm> chrisdone: yes it is. The nice tools help a bit
15:44:49 <uberwach> Trollinator: you shouldn't. people talk with each other ;)
15:44:53 <abc56889> ClaudiusMaximus: thanks
15:44:54 <sm> PHPStorm is helping here
15:44:59 <acowley> chrisdone: But with FB they have so much money and so much programmer-power, I just find it really surprising that they're really so paralyzed
15:45:38 <josephle> doesn't FB have haskell in their codebase?
15:45:46 <josephle> it's not a lot of haskell, granted, but it's still there
15:46:03 <tulcod> tippenein: taht's a huge project. just saying.
15:46:07 <Trollinator> acowley: what would you do in their place, having millions of LOC in PHP?
15:46:09 <chrisdone> acowley: right, that's why i alternatively pondered maybe it's not technical but some managerial ('cause-zuckerberg-said-so) or social thing. although we're speculating, i guess. we know they're now writing new systems in other languages
15:46:14 <abc56889> ~.
15:46:34 <mgaare> FB has a huge amount of working code that cost them untold millions of dollars to produce, not to mention the ecosystem of apps and integrations... just rewriting it for the hell of it isn't an option ;)
15:46:40 <tippenein> https://github.com/facebook/Haxl
15:47:07 <RchrdB> josephle, IIRC they were talking about a really powerful Haskell library for making pipelined queries to large numbers of different backend servers.
15:47:09 <Trollinator> http://www.zdnet.com/blog/facebook/why-facebook-hasnt-ditched-php/9536
15:47:15 <RchrdB> possibly open-sourcing it?
15:47:16 <dsturnbull> FB's code is worth billions, even if it is written in a poor language. that's the context.
15:47:17 <chrisdone> mgaare: true. the power of If It Ain't Broke is overwhelming when new feature requests are piling in from sales
15:47:18 <hodapp> but as far as I remember, it was pretty early that Facebook stopped using standard PHP and was having to use some modified forms of it.
15:47:30 <tippenein> RchrdB: it's haxl probably
15:47:38 <RchrdB> ah thank you tippenein, that is it
15:47:41 <acowley> Trollinator: Slowly migrate to something sane? Like I said, I don't know how their situation compares to other companies, but I can't think of a big company with a worse technology decision at their core.
15:47:46 <tippenein> it is already OSS
15:48:13 <acowley> chrisdone: My guess is managerial influence, too
15:48:30 <pjdelport> acowley: The trouble probably isn't migrating the source code, it's migrating the legions of programmers :)
15:48:35 <Augmental_> acowley:  As in Zuckerberg wrote v1 in PHP
15:48:45 <dsturnbull> acowley: FB's technology is what they've written, not PHP itself
15:48:46 <Augmental_> :-)
15:48:53 <josephle> hodapp: I too thought they were pushing towards companywide adoption of Hack
15:49:04 <vanila> if PHP is so bad how are they doing so well with it? I recognie it's problems but can you honestly recommend someething that is practical to use today that is better?
15:49:09 <mgaare> It sounds like they are migrating
15:49:18 <chrisdone> vanila: that kind of reasoning is what managers believe
15:49:22 <dsturnbull> vanila: there is nothing objectively better, no
15:49:24 <chrisdone> and what many programmers believe
15:49:29 <Trollinator> acowley: sure. But they have *mountains* of code. It will take *years* before such a change pays off.
15:49:29 <acowley> pjdelport: For a small company, I buy that reasoning. For FB? They drop billions on acquisitions.
15:49:29 <tippenein> they just wrote their own thing which makes sense if you have too much money
15:50:00 <chrisdone> companies made millions writing complex systems in handwritten assembly
15:50:01 <codile> http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/
15:50:09 <chrisdone> just because you can doesn't mean you should
15:50:13 <dsturnbull> FB is the unparalleled leader in their field, and they use PHP.. pretty good validation, no? perhaps they succeeded despite the language (likely), but you can't argue with results.
15:50:19 <mgaare> vanila: ruby, python, java, scala, anything in the modern .NET stack, clojure
15:50:24 <chrisdone> dsturnbull: no.
15:50:31 <Trollinator> I mean most banks are still running millions of lines of COBOL
15:50:31 <chrisdone> you can argue with results
15:50:40 <Exio4> new https://www.coursera.org/course/proglang session if anyone wants to take it
15:50:41 <codile> Trollinator: really?
15:50:42 <acowley> dsturnbull: Of course you can argue with results!
15:50:44 <dsturnbull> chrisdone: who else beats FB?
15:50:48 <josephle> dsturnbull: but even FB argues with their own results. Otherwise they wouldn't make Hack
15:50:52 <chrisdone> dsturnbull: at what? popularity?
15:50:58 <mgaare> Diskord: which field do you mean?
15:50:59 <dsturnbull> no, in profit, duh
15:51:07 <tulcod> google beats facebook in profit
15:51:11 <acowley> dsturnbull: Why do I have to take market cap as a direct measure of PL wisdom?
15:51:18 <tulcod> sure, different market, but they do beat facebook
15:51:21 <dsturnbull> you're stretching to think i said that
15:51:29 <codile> doesn't google use lots of php?
15:51:30 <Trollinator> codile: well, I don't know if it's most banks or just many banks,
15:51:35 <mgaare> Diskord: sorry, wrong highlight
15:51:35 <codile> s/php/python
15:51:36 <tulcod> but doesn't every company have its own market?
15:51:39 <codile> i meant python
15:51:41 <codile> duh
15:51:41 <tnks> did someone take the time to go to #haskell and defend PHP?  I just started looking at this buffer, and got confused.
15:51:48 <dsturnbull> acowley: i think you're seeing the programming language in isolation
15:51:55 <Trollinator> but there's still a lot of COBOL around.
15:51:56 <tulcod> tnks: haha yes
15:51:57 <josephle> codile: they use a lot of languages
15:52:00 <codile> hmm
15:52:07 <vanila> tnks, There are also people attacking PHP and saying that you shouldn't use it
15:52:09 <Trollinator> and COBOL developers are paid well.
15:52:09 <codile> well, afaik most of youtube runs on python
15:52:16 <codile> not sure what they use for google though
15:52:18 <chrisdone> look at it this way
15:52:25 <acowley> dsturnbull: I'm trying to look at the language in isolation. I'm not willing to bundle up all the decisions they've ever made with one measure (e.g. profit).
15:52:28 <dsturnbull> you sohuld definitely not use php, unless you're already making billions of dollars in profit :)
15:52:30 <d-snp> facebook is the company that uses a lot of php
15:52:34 <d-snp> and also some haskell :P
15:52:40 <vanila> tnks, I don't think anyone specifically joined to defend PHP. And people started talking bad about it first
15:52:41 <RchrdB> Trollinator, there's an argument that companies like Amazon and Facebook implement many things on a SOA basis precisely so that they can implement new functionality more or less however they please, without necessarily being bound to use the same virtual machine that whatever their last system was implemented in. :)
15:52:51 <tippenein> facebook does the same thing as google, but facebook open sources more
15:53:20 <tnks> I just don't use PHP because I like to reason about my code.
15:53:26 <josephle> codile: C++ used far more than python
15:53:29 <acowley> I think it's good to try to appreciate why apparently bad technical decisions have merit in case there's a reason beyond, "The boss made us do it"
15:53:32 <tippenein> tnks gets it
15:53:33 <dsturnbull> acowley: unless you're talking about asthetics or in an academic sense, what other measure can the success of code be made by?
15:53:35 <codile> josephle: oh, okay
15:53:38 <tnks> people should talk less about PHP, and more about the value of reaonsing.
15:53:49 <chrisdone> every stupid feature of PHP that trips people up, that programmers have to spend time memorizing, that causes bugs that have to be found by some tester, tracked by some guy typing up an issue in an issue tracker, and solved and committed by the author, or another sorry programmer who has to follow the mess, every piece of bad code that can't be refactored reasonably and that nobody will touch, every person you have to employ to make
15:53:49 <chrisdone> static analysis tools for php
15:54:02 <chrisdone> add the sum total of all those things
15:54:02 <josephle> codile: python doesn't have what it takes to serve billions of queries every day
15:54:11 <mgaare> if someone was starting a new project today, PHP would not be a good choice
15:54:19 <codile> that's probably true, yeah
15:54:37 <RchrdB> Trollinator, (that's not necessarily a correct argument. I don't know how much SOA facebook do or why. Amazon are famous for doing as much as possible on a SOA basis but I think that that has more to do with managing how they integrate systems and meet SLAs than anything else?)
15:54:55 <josephle> speaking of which, I know Facebook is having a large D push as well
15:55:39 * EvaLoTion  Trading 600 LTC .. SERIOUS DEALER MSG ME ..!!
15:55:41 <Trollinator> RchrdB: *shrug* I guess you're right about SOA and stuff
15:56:01 <d-snp> merijn gave me this type definition for a state: data MyState s a = MyState (s -> (a, s))
15:56:11 <d-snp> I'm a bit confused by it
15:56:16 <RchrdB> Trollinator, I'm really only guessing! :)
15:56:22 <l0cust> Oh wow. for the first time in like, ever, using --max-backjumps=-1 actually resolved dependency issues
15:56:27 <chrisdone> d-snp: what bit confuses you?
15:56:46 <Trollinator> This is one reason why PHP is still so popular: http://www.haskellforall.com/2014/04/worst-practices-are-viral-for-wrong.html
15:56:48 <chrisdone> l0cust: no way. i thought that was just a no-op meant to give false hope
15:56:56 <l0cust> chrisdone: that's what I thought
15:57:34 <d-snp> the constructor I'm having trouble putting it in words, a MyState is something that takes an s, and returns a tuple of (a,s) ?
15:57:36 <orzo> i generally use f for Functor instance and m for Monad instance, I think it's typical to use f also for Applicative instances, but I'm not sure I like that.  What variable name do you typically reach for to represent an arbitrary Applicative?
15:58:34 <josephle> it seems Control.Applicative uses f
15:59:14 <RchrdB> orzo, 'f', because it's short for "applicative Functor"
15:59:38 <RchrdB> orzo, I've seen some people even suggest switching from using the term "monad" to "monadic Functor" ;)
15:59:58 <d-snp> just call everything f and be done with it? :P
16:00:02 <chrisdone> d-snp: sounds correct to me
16:00:13 <Trollinator> why not just call it a monoid in the category of endofunctors.
16:00:25 <tulcod> Trollinator: you have to specify the category
16:00:30 <orzo> Trollinator: and use 'm' ?
16:00:36 <tulcod>  /which/ category of endofunctors?
16:00:57 <dsturnbull> the second one, third from the right
16:01:01 <vanila> Trollinator, because that's wrong
16:01:05 <shachaf> In particular, which monoidal category of endofunctors?
16:01:08 <chrisdone> d-snp: what is f :: s -> (a,s)?
16:01:28 <Trollinator> I see I shouldn't have tried to be funny.
16:01:48 <tulcod> Trollinator: you shall not make jokes about category theory for it is serious business!
16:02:03 <orzo> i am sympathetic to using 'm' since i feel like it's more an almost-monad and is closer to the monad niche than functor niche tool-wise
16:02:15 <shachaf> You can make jokes about it, but that one is a very tired joke.
16:02:18 <d-snp> a function that takes an s and returns a tuple of (a,s)? :P
16:02:40 <vanila> People have said it so often it kinda lost the humor value
16:03:28 <chrisdone> d-snp: ok. what's the type of MyState?
16:04:05 <dfeuer> The category of endofunctors.... that's ... not something I understand. I guess that means making a category of the functors from some category to itself, coming with some sort of morphism from functor to functor?
16:04:20 <tulcod> dfeuer: right
16:04:24 <d-snp> MyState is a function that takes an s and returns (a,s) then?
16:04:40 <dfeuer> I have only a vague notion of functors.
16:04:40 <vanila> dfeuer, the morphism being natural transforms
16:04:42 <chrisdone> d-snp: nope
16:05:14 <chrisdone> d-snp: MyState takes an (s -> (a,s)). so what would its type be?
16:05:28 <tulcod> dfeuer: a category has 0-cells, the objects, and 1-cells, the morphisms, which are cells between 0-cells. a functor maps 0-cells to 0-cells and 1-cells to 1-cells in such a way that everything commutes like you'd want it to
16:06:09 <d-snp> a function that takes a function that takes an s and returns (a,s)?
16:06:31 <chrisdone> d-snp: right. and what does it return?
16:06:40 <d-snp> yes, that's what I'm asking myself now too :D
16:06:58 <dfeuer> tulcod: you just flew waaaay over my head. I'm waiting for Lawvere and whoever to arrive, so I guess I'll find out then.
16:07:04 <chrisdone> d-snp: let's simplify it. data Simple a = Simple a. what is the type of the constructor Simple?
16:07:28 <d-snp> just right? Simple a
16:07:41 <d-snp> .. just 'Simple a' right?
16:07:43 <Trollinator> no.
16:07:45 <d-snp> oh
16:07:47 <Trollinator> a -> Simple a
16:07:48 <tulcod> dfeuer: the idea of talking about cells makes more sense if you view a category as a graph: just some interconnected dots
16:07:51 <d-snp> oh wait
16:07:54 <d-snp> yes
16:07:58 <d-snp> sorry.. it's the constructor
16:08:07 <chrisdone> d-snp: yeah, the constructor. does that much make sense?
16:08:26 <oisin818> I'm currently running ghc-7.6.3 but I also have ghc-7.8.2 installed. When running cabal install glfw-b I run into some problem that I believe is caused by 7.6.3. The ghc command seems to be "aliased" to 7.6.3. How do I... migrate my project to 7.8.2 without breaking everything?
16:08:27 <d-snp> yes, so it returns a MyState s a
16:08:49 <chrisdone> that's right =)
16:09:12 <chrisdone> d-snp: so can you write the notation for the full type of the MyState constructor? =)
16:10:25 <d-snp> MyState :: (s -> (a, s)) -> MyState s a
16:10:27 <d-snp> like that?
16:10:40 <chrisdone> perfect =)
16:11:05 <chrisdone> so now we have a bit more common language for what's going on in MyState
16:11:08 <chrisdone> what about it confuses you?
16:11:26 <Twey> If I have a library section and an executable section in a .cabal file, why is it that the environment entered by ‘cabal repl’ only contains the dependencies for the library and not the executable?
16:11:42 <chrisdone> twey: can't you choose the target?
16:11:48 <chrisdone> via some --target or whatever
16:12:17 <chrisdone> (i don't use this feature)
16:12:18 <ion> Incidentally, with GADTs this works: data MyState s a where { MyState :: (s -> (a, s)) -> MyState s a }
16:12:29 <tulcod> Twey: are you getting an internal compiler error?
16:13:10 <Twey> chrisdone: I don't see such a flag…
16:13:11 <tulcod> Twey: also, not sure i understand you correctly. how can the executable be linked into the ghci environment?
16:13:14 <tulcod> it's an executable
16:13:17 <Twey> tulcod: No
16:13:40 <dfeuer> tulcod: is a functor inherently either covariant or contravariant, or are there other options? I know I saw in the lovely little blog post riffing on "I love profunctors. They're so easy" that the notion must be somewhat more general, but just what does it mean?
16:13:44 <tkon> Is there a way to cabal build into a sandbox that is not in the project directory
16:14:04 <pyon> dfeuer: A profunctor is contravariant in its first argument, covariant in the second one.
16:14:08 <shachaf> Are you talking about categories or Haskell?
16:14:09 <tulcod> dfeuer: every functor is by definition covariant. a contravariant functor is not a functor (or not between the same categories, anyway)
16:14:34 <bb010g> tulcod: Haskell Functor or mathematical functor?
16:14:39 <tulcod> uh. mathematical functor
16:14:49 <tulcod> i guess the haskell one has some laws which you can satisfy either way
16:15:11 <Twey> tulcod: It's an executable with build dependencies.  I'd like to load the Main module into my REPL (:l path/to/Main.hs).  But I can't, because the environment entered by ‘cabal repl’ only contains the dependencies for the library, not for the executable.
16:15:36 <tulcod> Twey: well cabal repl allows you to see what a user of your package would see
16:15:42 <tulcod> (i think)
16:15:56 <acowley> monochrom: My context reduction stack overflow turns out to have been just in reporting the error, and bumping it by 1 made it give me a useful error message!
16:15:57 <Twey> tkon: cabal --sandbox-config-file /path/to/cabal.sandbox.config
16:15:58 * chrisdone doesn't like the answering to people with just "no" that happens in here
16:16:06 <d-snp> chrisdone: so I have to implement the put function, which takes an s, and should make a MyState s (), but my compiler seems to be ok with this implementation: put _ = MyState (\ v -> ( ()  , v ))
16:16:24 <Saizan> dfeuer, tulcod: actually, you can say "contravariant functor from C to D" to mean a functor "C^op -> D"
16:16:29 <Twey> chrisdone: The ‘no’ was to ‘are you getting an internal compiler error?’
16:16:40 <tulcod> Saizan: that's what i was referring to. or alternatively, C->D^op
16:16:54 <tulcod> referring / suggesting
16:17:19 <tkon> twey: much tanks
16:17:19 <tulcod> chrisdone, Twey: yeah no offense taken, i got the information i wanted
16:17:31 <tkon> Twey: or thanks (whichever you prefer)
16:17:46 <Twey> tkon: I wouldn't say no to a few tanks.  ;)
16:18:08 <acowley> Nobody told me there'd be tanks
16:18:12 <chrisdone> twey =)
16:18:18 <d-snp> I can't actually think of any other implementation for put.. because I have to either ignore the parameter of the lambda, or the parameter of the function..
16:18:20 <johnw> launch ze tanks
16:18:20 <chrisdone> d-snp: okay, that's a type checking solution, sure
16:18:25 <johnw> heya chrisdone!
16:18:33 <chrisdone> hey johnw =)
16:18:45 <Twey> acowley: Clearly you're just not helpful enough, you with your producing of actual useful software and all.
16:19:06 <carter> johnw: whats a safe way to try out nix on my mac?
16:19:15 <johnw> it's inherently safe already
16:19:16 <johnw> what do you mean?
16:19:19 <acowley> haha
16:19:31 <chrisdone> d-snp: put itself is supposed to forget the old state and use the new provided state. does that help your choice?
16:19:41 <acowley> That interaction should probably be on the nix homepage
16:20:32 <Twey> Heh
16:21:07 <SenorSenpai> hello everyone, I have a basic question to ask. I have a variable named "fresh" which is a boolean, how do I set this to "false"? thank you very much to anyone who can assist me :)
16:21:13 <d-snp> chrisdone: ah okey, that makes sense, then I'd return a function that returns (a,s) no matter what right? so: put s = MyState (\ _ -> ( ()  , s ))
16:21:52 <enthropy> @let fresh = "false"
16:21:53 <lambdabot>  Defined.
16:21:55 <enthropy> > fresh
16:21:57 <lambdabot>  "false"
16:22:20 <chrisdone> acowley: link'd =) http://ircbrowse.net/selection/haskell?title=Conversation&events=18776219,18776220,18776221,18776222
16:22:31 <SenorSenpai> false as in not true as aposed to true or the string "false", is that understandable?
16:22:35 <chrisdone> d-snp: looks good to me!
16:22:48 <tkon> SenorSenpai: like `let fresh = False`
16:23:04 <SenorSenpai> thanks tkon, gonna try it
16:23:12 <acowley> oh wow, I didn't know IRCBrowse was so fancy
16:23:15 <d-snp> chrisdone: ok, I'll continue on.. thanks for helping me so far :D
16:23:44 <chrisdone> d-snp: welcome =)
16:24:00 <Twey> Ah, Nix saves the day: just stuck the extra build dependencies in my nix-shell environment :þ
16:24:27 <chrisdone> acowley: http://www.reactionface.info/sites/default/files/imagecache/Node_Page/images/1310408064982.jpg
16:25:13 <acowley> How does nix-shell play with cabal repl and haskell mode and ghc-mod and such things?
16:25:56 <acowley> chrisdone: :D
16:26:53 <orzo> hm, i notice the integer-gmp package has an integerLog2# function.  I want need that, but it seems wrong to assume gmp and to use GHC.* directly if there is an alternative.  Where's the go-to for a log2 of a bignum integer?
16:27:05 <Twey> acowley: Hackishly, it seems.  But it's not bad.
16:28:06 <orzo> also, is integer-gmp included in base?
16:28:17 <orzo> i guess not
16:28:37 <linman32> hello. i'm trying to install darcs. it is failing to install, though
16:28:37 <linman32> http://pastebin.com/aD7Q5hvH
16:28:46 <acowley> Twey: cabal repl, ghc-mod, and emacs are probably my top priorities
16:28:55 <d-snp> I feel like a wizard.. I'm still very hazy on what I'm actually going to achieve :D
16:29:10 <Twey> acowley: It's pretty convenient, though you have to do some unpleasant things to get it that way (I have a per-project haskell-program-name and a pseudo-package in my project root…)
16:29:11 <acowley> I can get a snack while rebuilding sandboxes, but I want my emacs face-time to be valuable for both of us
16:29:28 <tulcod> linman32: did you install iconv?
16:29:36 <tulcod> linman32: the C library, not the haskell package
16:29:37 <acowley> (I like to think emacs enjoys being part of productive coding sessions)
16:30:01 <linman32> not sure.. let me see
16:31:07 <carter> johnw: i mean safe from yaks and snipes
16:31:11 <acowley> Twey: That doesn't sound magical
16:31:25 <alpha123> acowley: That sounds good, but what do you plan to use for a text editor?
16:31:50 <acowley> alpha123: Hold on, let me see what emacs suggests
16:31:54 <Twey> acowley: No.  But I do get package sharing out of it.
16:32:16 <acowley> Twey: And I am very jealous :/
16:32:47 <Twey> Not sure about ghc-mod, since I don't use it at the moment, but I imagine you'd just have to tweak the ghc-mod command to enter the shell — something like nix-shell --pure "ghc-mod"
16:32:55 <linman32> tulcod: do you know name of package iconv on ubuntu?
16:32:55 <Twey> Er, nix-shell --pure --command "ghc-mod"
16:33:13 <tulcod> linman32: no. but i guess it'd be "libiconv" or "iconv"
16:34:19 <Twey> acowley: The use of nix-shell to provide a project-specific environment is a huge hack to start with.  It's meant to be used for testing package build environments — hence the pseudo-package
16:35:04 <acowley> btw, johnw, I'm sorry I missed BosHac after all. We started making travel arrangements too late (my fault) and it was coming out really pricey.
16:35:07 <chrisdone> acowley: emacs is like a husky dog. it works hard and thinks you're awesome and loves you being around, but there's also an ancient quality in its appearance and eyes that spans back through hundreds of thousands of years to the grey wolf's ancestors. mysterious and old
16:35:34 <Fuuzetsu> *tips fedora*
16:35:38 <acowley> chrisdone: Can I get that as a poster?
16:35:45 <chrisdone> acowley: haha
16:35:52 <acowley> What should the background image be, though?
16:35:57 <alpha123> chrisdone: I think that applies equally well to vim, if not better :P
16:36:02 <vanila> less 4chan crap?
16:36:14 <alpha123> acowley: Emacs drawing a wolf, I guess
16:36:24 <acowley> vim is only mysterious in so far as exiting the program. emacs's mystery runs deep.
16:36:35 <chrisdone> RMS getting after getting out of bed?
16:36:47 <chrisdone> acowley++
16:36:48 <tulcod> vim is more like a mountain troll
16:37:05 <tulcod> you keep screaming but it doesn't go away
16:37:05 <acowley> Twey: Yeah, it seems that way
16:37:23 <tulcod> it's part of the mountain. never been anywhere else
16:37:29 <acowley> Twey: in some ways I'm fine with that as long as emacs knows how to navigate things
16:38:10 <acowley> One annoying limitation I've hit of late is ghc-mod's lack of SLIMEness. I like to tramp into a vagrant VM for some dev, but I cheat and run ghc-mod locally on the same code base.
16:38:35 <chrisdone> acowley: that's partially what ghc-server is motivated for. that kind of use-case
16:38:56 <acowley> chrisdone: Yeah, I know, I'm eager to see how it develops!
16:40:48 <chrisdone> “Any sufficiently complicated C or Fortran program contains an ad hoc, informally-specified, bug-ridden, slow implementation of half of Common Lisp.” — Greenspun's tenth rule
16:41:01 <chrisdone> “…including Common Lisp.” — Morris's corollary
16:41:10 <alpha123> ^ Important disclaimer :P
16:41:16 <chrisdone> ghc-server is my ad hoc, informally-specified, bug-ridden, slow implementation of half of SLIME
16:41:17 <SenorSenpai> tkon: getting error parse error on input "let", ive pasted a block of code here to see where I messed up http://pastebin.com/1SRXgbuC thanks in advance
16:41:43 <alpha123> Can confirm often accidentally reimplementing parts of CL. It's huge and ugly, you tend to miss things.
16:41:45 <acowley> chrisdone: Another issue is memory use
16:42:08 <acowley> chrisdone: With cabal repl or ghc-mod or whatever, it ties up a ton of memory for me
16:42:24 <acowley> I don't know what can be done about that, but it's a limiting factor given I do all my work on old laptops
16:43:54 <chrisdone> acowley: do you use -fbyte-code when you load into the repl?
16:44:25 <acowley> chrisdone: I don't do whatever the default behavior is
16:44:27 <chrisdone> in the past i found -fobject-code performs better, and -fbyte-code (the default) gobbles memory
16:44:28 <acowley> err
16:44:32 <acowley> I do whatever the default is
16:44:40 <chrisdone> right, so -fbyte-code
16:44:48 <acowley> There seem to be issues with cabal repl not using object code
16:45:01 <acowley> I thought it used to, but now it always (?) uses interpreted mode
16:45:11 <chrisdone> you can :set -fobject-code
16:46:09 <d-snp> can youeee
16:47:25 <chrisdone> d-snp: yes you caneee
16:49:55 <d-snp> my wifi for some reason is super dodgy :D
16:49:58 <d-snp> haha
16:51:15 <hpc> d-snp: if i learned anything from photoshop, it's that you can fix that with the burn tool
16:51:37 <d-snp> lol
16:51:44 <tkon> SenorSenpai: where is fresh defined?
16:52:49 <d-snp> the bind function of the MyState monad is going to be tricky I feel
16:54:21 <d-snp> I need to get the a out of the MyState.. and feed that into the next one.. hmm
16:56:27 <Cale> SenorSenpai: Yeah, I think whoever gave you that answer was expecting that you were typing commands into ghci
16:59:41 <Cale> SenorSenpai: If the 'let' were to align with the 'if', then the declaration would almost work, except that the do-block ends there, so you'd need more statements (you're not allowed to end a do-block with a 'let' since none of the declarations made in it could possibly matter, and the desugaring wouldn't work.
16:59:44 <Cale> )
17:00:31 <SenorSenpai> Cale: i see, what about on the last line, can there be multiple lines after the | otherwise -> line?
17:00:36 <Cale> SenorSenpai: If that 'let fresh = False' was somehow intended to be part of the else branch of the if expression, then there are a couple problems
17:01:00 <Cale> One being that fresh is never used from that point on, and secondly, you already know that fresh is False there.
17:01:15 <Cale> (so why shadow it with a new variable binding?)
17:01:42 <Cale> I'm not sure what you mean by multiple lines... you can split any Haskell expression across multiple lines.
17:02:26 <Cale> Whoever wrote this code really loves $ a whole lot
17:02:28 <Cale> :)
17:02:32 <Simec> lol
17:02:46 <Cale> Personally, I'd be tempted to replace most of these with .'s
17:02:59 <Cale> But that's beside the point
17:03:17 <Cale> Can I see more of the code and perhaps you could tell me what you're trying to do with it?
17:03:28 <Cale> lpaste.net is a better pastebin, btw.
17:03:36 <SenorSenpai> cale can I pm you with more details?
17:03:58 <Cale> sure, or just paste the thing on lpaste.net and link here
17:04:54 <SenorSenpai> ok, heres the paste with more code http://lpaste.net/6571179458982576128
17:05:13 <Cale> uh, could I get at least a complete declaration?
17:05:27 <SenorSenpai> well, there is no declaration of fresh
17:05:32 <Cale> I mean...
17:05:40 <Cale> This isn't a complete top-level declaration eve
17:05:41 <Cale> n
17:06:06 <SenorSenpai> ah so you need more code?
17:06:30 <Cale> I want to understand where 'fresh' gets bound
17:06:50 <Cale> oh, or wait a minute
17:07:00 <Cale> The indentation got screwed up
17:07:16 <Cale> So fresh was bound by the previous line
17:07:44 <SenorSenpai> the line before (submitDiff, fresh) <- ?
17:07:47 <Cale> yes
17:07:53 <SenorSenpai> duplicate <- withMVar (g_used global) $ return . S.member rawShare
17:07:55 <SenorSenpai> is that line
17:08:14 <Cale> (submitDiff, fresh) <- ...
17:08:37 <Cale> I mean, this binds 'fresh' to the second component of the pair which is the result of executing the action to the right of the <-
17:09:12 <Cale> It's important to understand that 'fresh' is not the name of a location of a boolean value, it is a name for a boolean value.
17:09:17 <SenorSenpai> I see, I can see it on line 6, return (0, False)
17:10:32 <SenorSenpai> the probklem I have is that, once line 22 executes, I need fresh to be false when its used at the end of line 25
17:11:01 <Simec> you mean IF line 22 executes :)
17:11:40 <SenorSenpai> yes, if the code of otherwise -> is triggered
17:11:58 <Cale> Okay, so you'll want to produce some value from the action which begins on line 9
17:12:05 <Cale> which you'll use in place of fresh there
17:12:37 <Cale> This code is kinda awful
17:13:51 <SenorSenpai> hehe i guess it is
17:14:10 <codile> hmm
17:14:22 <codile> in this example here http://learnyouahaskell.com/input-and-output main is called recursively
17:14:27 <Cale> wait
17:14:27 <codile> how does this work?
17:14:40 <codile> doesn't it use some kind of stack?
17:14:50 <Cale> Oh, right, line 22
17:14:51 <linman32> tulcod: i'm still getting the same error after iconv install. i installed iconv by using make in a tmp folder.
17:15:27 <SenorSenpai> Cale: I see that fresh is defined by the lines 2-6, so how can fresh be changed after this?
17:15:36 <Cale> codile: There's no call stack. There is a stack used during evaluation for pattern matches who are waiting for their scrutinee to be evaluated enough to match
17:15:43 <d-snp> I thought I was being smart, but I get a really weird error, what's wrong with this?
17:15:50 <Fuuzetsu> SenorSenpai: the library that code is from is up public on GitHub, it'd be easier to link to there than link (perhaps incomplete) snippets
17:15:51 <codile> Cale: oh, okay
17:15:54 <d-snp> (>>=) (MyState f) fmb = MyState (\ s -> ( (fmb $ fst $ f s) , s ) )
17:16:05 <Cale> SenorSenpai: fresh is not the name of a memory location where a boolean value is stored
17:16:07 <codile> i'm also wondering then. how does recursion work in general?
17:16:10 <Cale> SenorSenpai: it's the name of a boolean value
17:16:25 <codile> is there only a stack for the lazy evaluations?
17:16:31 <Cale> SenorSenpai: So setting fresh to be False makes the same amount of sense as setting True to be False
17:17:08 <SenorSenpai> cale: if I understand that, it means fresh can never be anything but a representation of false?
17:17:10 <Cale> codile: Lazy evaluation is outermost first... well, let me give SenorSenpai some hints with his code and then I'll explain how things go :)
17:17:17 <codile> okay :)
17:18:02 <Cale> SenorSenpai: It's a name for some Boolean value, which is either True or False, but whichever one it is, you can't change that fact.
17:18:07 <SenorSenpai> for the record, here's the full source https://github.com/dogestreet/proxypool/blob/master/ProxyPool/Handlers.hs line 515 is where my paste begins
17:18:14 <orzo> look what i just made, http://jerkface.net/~joe/Stochastic.html
17:19:44 <SenorSenpai> cale, I see, so I think I get what you mean about having it be another value to use in place of fresh, like fresh2 = fresh or fresh2 = false, something like that, then passing fresh2 on line 25?
17:19:45 <Simec> cale, are you sayng  basically that the variable cannot be changed?  if yes, why ?
17:19:57 <Cale> SenorSenpai: you could do this: http://lpaste.net/6571179458982576128
17:20:20 <Cale> Simec: Because variables refer to the same thing over their entire scope
17:21:44 <Cale> codile: Okay, so evaluation...
17:21:50 <d-snp> nvm what I said made no sense
17:22:21 <SenorSenpai> cale: any chance you can explain what you changed in that snippet? I see fresh' instead of fresh, plus some extra return values
17:22:22 <codile> okay
17:23:00 <Cale> SenorSenpai: Yeah, I have the action which is this whole fancy multi-way-if-expression returning a value now, which is fresh'
17:23:10 <SenorSenpai> ah
17:23:36 <Cale> SenorSenpai: so most of the time, I have it return fresh
17:23:48 <Cale> SenorSenpai: and then in the otherwise case, I have it unconditionally return False
17:23:57 <SenorSenpai> I see, I understnd this
17:24:26 <Simec> cale, i can confirm that at least your snippet compiled correctly ;)
17:24:41 <SenorSenpai> thats pretty neat way of handling things
17:25:01 <Cale> codile: Let's use the function  double x = x + x, and evaluate  double (double 5)  under a few different evaluation strategies
17:25:19 <codile> okay. i'm listening
17:25:22 <codile> *reading
17:25:22 <Cale> codile: Under strict evaluation (which is another name for innermost-first evaluation), we'd have something like:
17:25:27 <Cale> double (double 5)
17:25:31 <trap_exit> why is lens so complicated?
17:25:34 <Cale> -> double (5 + 5)
17:25:37 <Cale> -> double 10
17:25:38 <trap_exit> why can't it just be like 100 lines of template haskell
17:25:41 <trap_exit> for passing around getters and setters
17:25:45 <Cale> -> 10 + 10
17:25:46 <Cale> -> 20
17:26:10 <trap_exit> what? isn't double (5 + 5)
17:26:13 <trap_exit> -> (5 + 5) + (5 + 5)
17:26:27 <Cale> trap_exit: I'm using innermost-first evaluation here
17:26:35 <Cale> and the innermost reducible expression is 5 + 5
17:26:44 <trap_exit> ah
17:27:51 <lfairy> trap_exit: it is quite simple. most of the complexity is in optimizations and miscellaneous utility functions
17:28:01 <trap_exit> ah
17:28:36 <Cale> codile: So, we could also evaluate this expression in many other orders. In particular, we could use outermost-first evaluation:
17:28:39 <Cale> double (double 5)
17:28:46 <Cale> -> (double 5) + (double 5)
17:28:51 <Cale> -> (5 + 5) + (double 5)
17:28:55 <Cale> -> 10 + (double 5)
17:28:59 <Cale> -> 10 + (5 + 5)
17:29:02 <Cale> -> 10 + 10
17:29:03 <Cale> -> 20
17:30:02 <codile> okay
17:30:04 <Cale> You'll note that we duplicated the work of evaluating double 5, because the parameter x in the definition double x = x + x occurs more than once in the body of the definition
17:30:31 <codile> yeah
17:30:34 <Cale> Lazy evaluation evaluates outermost-first like this, but avoids this duplication
17:30:59 <dfeuer> trap_exit: speaking as someone who doesn't understand lens stuff, I think the problem is probably not that they're *complicated*, per se, but rather that it's difficult to conceptualize what they "really mean".
17:31:11 <Cale> Any work done to evaluate the expression a bound variable is bound to will be shared between the occurrences
17:31:29 <trap_exit> dfeuer: I was referingg to why it requires so many dependence sto build
17:31:33 <Cale> We can represent this sharing using a let expression, so under lazy evaluation, it would look like:
17:31:35 <dfeuer> Ah.
17:31:37 <Cale> double (double 5)
17:31:54 <Cale> -> let x = double 5 in x + x -- note that we're still expanding the outermost double first
17:32:03 <Cale> -> let x = 5 + 5 in x + x
17:32:07 <Cale> -> let x = 10 in x + x
17:32:10 <Cale> -> 10 + 10
17:32:11 <Cale> -> 20
17:32:16 <codile> oooh
17:32:18 <codile> that's cool
17:32:39 <dfeuer> trap_exit: I'm not sure, but I think part of *that* might be that it needs to bring in lots of types in order to provide lens instances relating to them.
17:33:14 <Cale> Now, this explanation has hidden somewhat the reason that certain expressions weren't reducible
17:33:46 <Cale> e.g. when we had  10 + double 5  in the plain outermost-first example, why couldn't we reduce the (+)?
17:34:02 <linman32> hi, a package is not installing. is there a way to log in more detail during install?
17:34:09 <Cale> Well, we actually probably could, but we wouldn't get very far
17:34:20 <codile> because double 5 has to be evaluated first?
17:34:36 <Cale> because x + y is likely to expand to a case expression which pattern matches on both x and y
17:34:59 <Cale> (internally)
17:35:13 <d-snp> chrisdone: http://lpaste.net/109090 I made something very ugly
17:35:24 <d-snp> was there something smart I should've done to make it pretty?
17:35:43 <Cale> and because it matches on both, it will need to evaluate them to determine which constructor matches (what the constructors are will depend on how integers are implemented)
17:35:56 <d-snp> ( takling about the bind implementation )
17:36:31 <Cale> So, this is where this choice of example has the downside that we usually don't think about the internal implementation of (+), which is likely to include some primitive stuff anyhow.
17:38:12 <codile> okay.
17:38:16 <Cale> But anyway, the place where a stack comes in is that when a case expression (or any pattern match, they eventually all get compiled to case expressions) matches on something, that case expression goes on the stack, and the expression gets evaluated
17:38:35 <Cale> Let's look at an example where there can be a problem
17:38:38 <Cale> @src foldl
17:38:38 <lambdabot> foldl f z []     = z
17:38:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:38:47 <Cale> Have you seen foldl before?
17:38:51 <codile> yes i have
17:38:55 <Cale> Okay
17:39:03 <Cale> So, let's look at  foldl (+) 0 [1,2,3]
17:39:41 <Cale> foldl pattern matches on the list argument, but in this case, we're going to assume that our list argument is fully evaluated already, so pretty much the stack goes unused for this part
17:39:48 <Cale> it reduces to:
17:39:57 <Cale> foldl (+) (0 + 1) [2,3]
17:40:03 <Cale> and then
17:40:08 <genisage> d-snp: if you give the function inside of the state a name (e.g. newType myState s a = MyState { runMyState :: (s -> (s,a)) } it makes it a bit easier to write a pretty version
17:40:10 <Cale> foldl (+) ((0 + 1) + 2) [3]
17:40:10 <dfeuer> I think I've finally begun to understand the implementation of foldl in terms of foldr, but I have not begun to understand how Joachim Breitner's call arity work makes it efficient, makes it fuse properly, etc.
17:40:23 <Cale> foldl (+) (((0 + 1) + 2) + 3) []
17:40:28 <Cale> ((0 + 1) + 2) + 3
17:40:43 <Cale> Up to this point, the stack has gone practically unused
17:41:13 <Simec> cale
17:41:22 <Simec> can i offer you a bear or something ?
17:41:23 <Cale> But now the outermost function is (+), and it's going to match on ((0 + 1) + 2) (which isn't evaluated yet) and 3 (which we'll assume is)
17:41:25 <Simec> *beer
17:41:41 <Cale> Simec: I don't drink alcohol, but that's cool :)
17:41:45 * d-snp arrests Simec for trade in protected species
17:41:57 <Simec> no, really, i mean
17:42:02 <d-snp> perhaps you can offer him some Cale juice ;)
17:42:08 <Simec> you helped us with a fix, do you have a bitcoin address ?
17:42:18 <Cale> no, it's fine
17:42:23 <Simec> you sure ?
17:42:30 <Simec> well, thanks a lot :)
17:42:47 <Cale> codile: So, this pattern match will wait on the stack while ((0 + 1) + 2) is evaluated, and then the same thing will happen with the outermost (+) here
17:43:19 <codile> makes sense
17:43:35 <Cale> codile: and you get the idea, we're building up stack entries while we wait for evaluation to happen. If the list had been millions of elements long, we might get a stack overflow here
17:44:13 <codile> yeah. and i guess that's were strict comes in?
17:44:17 <Cale> But the foldl itself didn't need the stack all that much, it's this expression that it built and the matching inside of (+) which caused the problem.
17:44:49 <Cale> Yeah, so, there's a variant of foldl called foldl' which forces the evaluation of the accumulating parameter before recursing
17:44:54 <Cale> @src foldl'
17:44:54 <lambdabot> foldl' f a []     = a
17:44:55 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:46:01 <Cale> (or really, it forces the evaluation of a' to occur before the result of the foldl' f a' xs can be matched on, but that's a subtle detail)
17:46:10 <dfeuer> And all of this explains why foldl' (in Data.List) scanl' (not yet in the list library), and iterate' (ditto) are more likely to be what you want than foldl, scanl, or iterate.
17:46:30 <Cale> scanl actually you probably want not to be strict
17:46:31 <SenorSenpai> cale: thanks so much, the changes you made allowed for a successful compilation, and the logic in place is now perfect. thanks a bunch
17:46:40 <Cale> often enough, anyway
17:46:55 <codile> so when you're not building expressions in a recursive function it doesn't matter how often it calls itself?
17:47:00 <Cale> Well, I suppose it depends on the manner in which you're making it stricter
17:47:14 <Cale> codile: Right, because the stack isn't a call stack
17:47:21 <dfeuer> Cale: it may depend on the application, I suppose. But if the function you give it is strict, you probably want to accumulate strictly as well.
17:47:34 <codile> that's pretty cool
17:47:55 <d-snp> genisage: thanks, so this is how it's supposed to be done?
17:48:12 <Cale> dfeuer: I suppose you could be a little stricter and force the evaluation of the elements as you walk the list
17:48:37 <Cale> dfeuer: But often you won't want to make the whole list result strict
17:49:19 <dfeuer> Cale, someone came up with a function in 2012 that can strictify scanl and iterate into scanl' and iterate', but it never seemed to go anywhere, possibly because the name was not so great.
17:49:41 <Cale> dfeuer: e.g. strictList [] = []; strictList (x:xs) = x `seq` (x : strictList xs), and then  scanl' f z xs = strictList (scanl f z xs)
17:50:18 <Cale> Or perhaps strictList (x:xs) = x : (x `seq` strictList xs)
17:50:21 <dfeuer> Yes, Cale, that's the idea, but write it with build and foldr.
17:50:39 <Cale> Well, sure, this is a foldr
17:50:48 <dfeuer> I think the first way works out a bit better.
17:50:58 <Cale> They're just slightly different
17:51:11 <Cale> The second way is a touch lazier, which could be good
17:51:24 <Cale> (still strict enough to prevent large expressions)
17:52:23 <dfeuer> Cale: I could very well be wrong, but I think the foldr/build fusion may work out more cleanly the first way.
17:52:38 <Cale> maaaaybe
17:52:47 <Cale> They're both foldrs though
17:53:30 <Cale> foldr (\x xs -> x `seq` x : xs) [] vs. foldr (\x xs -> x : (x `seq` xs)) []
17:53:45 <frerich> Cale: Seeing that the expression generated by ‘foldl (+) 0 [1,2,3]’ needs stack space, does the same issue exist with ‘foldr (+) 0 [1,2,3]’ which expands to ‘1 + (2 + (3 + 0))’ if I did the manual reduction correctly? I suppose in the case of (+) it is, right - but a function which doesn’t need its second argument in all cases could ‘abort’ the folding early?
17:53:59 <Cale> right
17:54:22 <dfeuer> Cale: I'll have to ponder that a bit more. You may be right.
17:54:47 <Cale> frerich: (+) needs to match on both its arguments, so you'll still get stack usage here, but yes, foldr has that advantage
17:55:02 <dfeuer> In which case I guess you'd want both. But what do you name them?
17:55:09 <Cale> > foldr (\x y -> if x > 100 then x else y) 0 [1..]
17:55:10 <ij> If I learn lens I'll be able to update data without pain?
17:55:11 <lambdabot>  101
17:55:41 <Cale> dfeuer: eh, the difference is *so* subtle that having both is sort of ridiculous
17:56:05 <Cale> dfeuer: I expect that almost any application which could use one wouldn't be too harmed by using the other instead
17:56:10 <dfeuer> Point.
17:56:48 <tertl3> hi what does "/"" mean?
17:56:59 <Cale> tertl3: you mean "\""?
17:57:08 <tertl3> yes
17:57:10 <tertl3> x <- many (noneOf "\"")
17:57:12 <dfeuer> (But I don't know anything about the strictness analyzer, so I don't know if the lazier one could ever get in the way of glorious unboxing.)
17:57:13 <Cale> It's the string whose only character is a doublequote
17:57:24 <Cale> > length "\""
17:57:26 <lambdabot>  1
17:57:31 <Cale> > head "\""
17:57:33 <lambdabot>  '"'
17:57:45 <ij> > '"' : []
17:57:47 <lambdabot>  "\""
17:57:56 <tertl3> > tail "\""
17:57:58 <lambdabot>  ""
17:58:08 <tertl3> i dont get it
17:58:14 <ij> > head "\""
17:58:16 <lambdabot>  '"'
17:58:16 <tertl3> i understand how it works
17:58:19 <ij> And now?
17:58:33 <Cale> tertl3: The \ is an escape so that the quotation mark is treated as a character of the string, and not the end of the string
17:59:05 <frerich> Cale: I see. So I suppose a foldr’ wouldn’t make any sense since it would trigger evaluating the entire list (which may not be such a good idea for infinite lists) but on the other hand a non-strict left-fold isn’t very useful either. Or maybe there are cases where you *do* want to have a non-strict accumulator? Let me think about that....
17:59:09 <Cale> > ['"']
17:59:10 <lambdabot>  "\""
17:59:26 <Cale> frerich: reverse
17:59:56 <Cale> frerich: But the reason that foldl was in the Prelude and foldl' wasn't is basically optimism
18:00:05 <tertl3> so its a single quote Cale?
18:00:20 <Cale> tertl3: A single double-quote
18:00:25 <Cale> "
18:00:27 <tertl3> gotcha
18:00:37 <frerich> Cale: With ‘reverse’ you mean - ‘reverse’ is a function which you’d ather want to define with foldl than foldl’?
18:00:41 <Cale> yes
18:00:43 <tertl3> thats just the only way to express it
18:00:48 <frerich> Cale: Hm let me try that.
18:01:05 <Cale> frerich: It doesn't really make that much of a difference
18:01:13 <tertl3> seems like '"' would be better?
18:01:18 <Cale> frerich: but it saves you perhaps a little bit of evaluation
18:01:23 <tertl3> noneOf '"'
18:01:35 <Cale> :t '"'
18:01:36 <lambdabot> Char
18:01:39 <frerich> Cale: I wonder whether there’s something involving ‘undefined’ or ‘error’ or so which makes foldl’ abort but foldl won't.
18:01:40 <Cale> :t "\""
18:01:42 <lambdabot> [Char]
18:01:53 <Cale> tertl3: noneOf wants a list of characters
18:01:53 <tertl3> could I do noneOf ['"']?
18:01:55 <Cale> yes
18:02:00 <Cale> that's the same thing as well
18:02:04 <tertl3> ok I like that better
18:02:29 <monochrom> '"' is not String
18:02:59 <dfeuer> I do too, tertl3. It expresses the correct concept.
18:03:48 <tertl3> should I edit the wikibook?
18:04:00 <monochrom> @let monoop _ True = True; monoop x _ = x
18:04:02 <lambdabot>  Defined.
18:04:24 <tertl3> how about this one guys noneOf "\"\\"
18:04:33 <monochrom> > foldl monoop True [True, undefined]
18:04:36 <lambdabot>  *Exception: Prelude.undefined
18:04:39 <Cale> tertl3: that's ['"','\']
18:04:53 <ij> How did people deal with nested data structures before lens?
18:04:57 <tertl3> >ok , ty thats where my parser is at atm
18:04:59 <monochrom> > foldl monoop True [undefined, True]
18:05:01 <lambdabot>  True
18:05:05 <monochrom> > foldl' monoop True [undefined, True]
18:05:06 <lambdabot>  *Exception: Prelude.undefined
18:05:19 <monochrom> that is an example
18:05:41 <monochrom> but it's contrived. you don't see a similar thing in practice.
18:05:43 <Cale> ij: Usually by avoiding them somehow
18:06:00 <hae> ij, record syntax sometimes.
18:06:07 <ij> It was just terrible?
18:06:10 <Cale> ij: Or defining operations which acted on them specifically
18:06:39 <ij> I see.
18:07:02 <Cale> e.g. writing higher order functions that apply a function to each of the fields
18:07:31 <tertl3> Cale i get an error with  x <- many $ escapedChars <|> noneOf "['"','\']"
18:07:33 <Cale> Which is kind of like pre-baked 'over'
18:08:05 <Cale> tertl3: that's going to be a parse error
18:08:19 <Cale> "['" <-- your string ends here
18:08:32 <Cale> but why are you quoting that thing?
18:08:44 <tertl3> i just tried it o see idf it would fix it
18:08:48 <Cale> didn't you want ['"','\'] ?
18:08:53 <tertl3> yes sry
18:09:01 <monochrom> I fear that you need to escape \ too
18:09:07 <Cale> oh, right
18:09:09 <Cale> '\\'
18:09:13 <Cale> > '\'
18:09:14 <lambdabot>  <hint>:1:4:
18:09:15 <lambdabot>      unexpected end-of-file in string/character literal at end of input
18:09:15 <Cale> ^^ error
18:09:17 <Cale> > '\\'
18:09:19 <lambdabot>  '\\'
18:09:20 <Simec> thanks again for everything cale, take care ;)
18:09:25 <Cale> Simec: no problem :)
18:10:05 <monochrom> quite frankly by this point you're better off using numbers. ['\34', '\92']
18:10:36 <Cale> monochrom: I'm not sure it's quite come to that :)
18:12:42 <tertl3> are those numbers right?
18:13:04 <monochrom> wouldn't you love to write string/char literals in source code without needing escapes
18:13:18 <monochrom> wouldn't you love you use any character you like in identifiers
18:13:53 <monochrom> but you must liberate source code from plain text files for them
18:14:11 <monochrom> as long as you still believe in the religion of "source code is plain text file", you can't.
18:15:01 <tertl3> ok ty Cale and Co.
18:15:08 <tertl3> its working
18:15:34 <tertl3> but the double escape isn't as pretty as I hoped
18:15:57 <k00mi> not using the same character for begin and end of string/char would be a great start
18:16:08 <monochrom> the problem with escape codes is that you always need one more level of meta-escaping than you think
18:16:32 <tertl3> i agree Im gonna go with the numbers version
18:16:46 <tertl3> at least there should be a quick reference for that
18:17:24 <tertl3> i will file a complaint to Mr. Marlow
18:17:31 <monochrom> you can add a comment. ['\34', '\92']  -- double-quote, backslash
18:17:44 <ion> Mrlow
18:18:20 <tertl3> good idea monochrom
18:18:41 <tertl3> ok back to work
18:18:45 <ion> -- left square bracket, apostrophe, backslash, three, four, …
18:19:22 <tertl3> ion pls
18:19:33 <tertl3> im already confused enough
18:19:37 <tertl3> :)
18:19:58 <tertl3> one last q
18:20:20 <ion> Must the response be a?
18:20:20 <tertl3> why would you choose to use parsec non combinators?
18:21:08 <Cale> what?
18:21:09 <tertl3> i noticed the sources only calls import Text.ParserCombinators.Parsec
18:21:19 <Cale> Oh, that's the old location for it
18:21:58 <Cale> The "ParserCombinators" got annoying to type, so everything got moved to Text.Parsec
18:21:58 <tertl3> but on hackage there is Text.ParserCombinators.Parsec and Text.Parsec
18:22:25 <Cale> Yeah, that's for backward compatibility with things that still import them
18:22:31 <tertl3> ah ok
18:22:41 <tertl3> im with ya
18:23:31 <tertl3> im thinking about making a screencast of the lisp parser
18:23:41 <tertl3> for newbs like me
18:24:30 <monochrom> Text.Parsec is still full of combinators. don't read too deeply into module names.
18:24:30 <tertl3> or maybe fp complete
18:25:13 <tertl3> ok, Im just coming back to this after some time away so I need to learn all the new stuff
18:25:32 <monochrom> identifiers are not literature. identifiers do not contain deep allegory or philosophy.
18:25:45 <tertl3> so maybe i can share my learnings and updates to keep it current
18:27:41 <monochrom> the only human nature you can read out of identifiers is that people disagree on the meanings of words
18:28:14 <shachaf> Hm, https://stevekrouse.github.io/hs.js/
18:29:05 <monochrom> very neato
18:29:25 <ion> nice
18:30:12 <monochrom> wait, [1 2 3 4 5] is not legal
18:30:37 <shachaf> Yes, it's not quite true to Haskell in several ways.
18:31:03 <monochrom> and I noticed that because I fooled around with the "Function Editor" part. I modified "map" to: map f (x:xs) = f x : xs
18:31:41 <shachaf> For some reason (1 : []) "reduces" to [1].
18:31:53 <lfairy> monochrom: with a bit of overloading, it's possible to overload numeric literals to behave as functions
18:32:07 <lfairy> So (1 2 3 4 5) creates a list
18:32:12 <monochrom> so I got (map addOne [1 2 3 4 5]) to expand to addOne 1 : [2 3 4 5], and then to [(addOne 1) 2 3 4 5]. then I noticed it looked like function application
18:32:26 <shachaf> lfairy: Overloading of number literals is rather beside the point.
18:33:05 <monochrom> I don't understand why some people work so hard to get the syntax "1 2 3 4 5" to work
18:33:16 <shachaf> It doesn't really look like it has a type checker as such. Like @pl.
18:33:27 <lfairy> shachaf: ah, that's what I get for taking things out of context :\
18:35:43 <shachaf> It looks like it just ignores the types.
18:36:39 <mwhit> jjjlllli
18:36:41 <mwhit> err
18:36:47 <mwhit> it seems vim does not have focus
18:36:48 <dolio> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
18:36:48 <lambdabot> ap (. join id) (. join id)
18:37:00 <shachaf> @pl (\x -> x x) (\x -> x x)
18:37:03 <lambdabot> ap id id (ap id id)
18:37:03 <lambdabot> optimization suspended, use @pl-resume to continue.
18:37:13 <ion> mwhit: f or W or something would have been more convenient than llll
18:37:34 <dolio> Suspended? That's all there is.
18:37:58 <shachaf> Are you sure? It can be reduced to ap id id (ap id id)
18:38:04 <shachaf> Or even further to ap id id (ap id id)
18:38:14 <dolio> It doesn't normalize. It just converts to combinators.
18:38:37 <dolio> Or does it?
18:38:44 <shachaf> It has a whole bunch of optimizations beyond getting rid of lambdas.
18:38:49 <dolio> Ah.
18:38:50 <shachaf> Otherwise you'd have really horrible expressions.
18:39:02 <dolio> You mean, even more horrible?
18:40:20 <shachaf> Yes.
18:40:30 <shachaf> The rules are at https://github.com/bmillwood/pointfree/blob/master/Plugin/Pl/Rules.hs
18:40:45 <shachaf> You can cabal install pointfree and use pointfree -v to see the sort of thing it comes up with.
18:49:07 <mmachenry1> Is there a library to ensure that proper reading from Network.Socket.ByteString? I want to get one line of data at a time but all I can do is tell it a number of bytes.
18:51:00 <Abathurr> really quick question
18:51:06 <Abathurr> is there a one-to-one relationshi in a binary treE?
18:51:08 <Abathurr> I don't think so
18:51:39 <cschneid> Can somebody help me figure out cabal: how do I not repeat myself in both my library AND my test deps?  https://gist.github.com/9aefe0c7c24adf5cde4b
18:52:19 <glguy> mmachenry1: One solution is to use socketToHandle :: Socket -> IOMode -> IO Handle, and then use normal Handle operations on it
18:53:16 <glguy> cschneid: Your test source dir and library source dirs should be different
18:53:28 <glguy> cschneid: and then you can list the library as a dependency of the test harness
18:53:31 <cschneid> glguy: I just realized that my test target was building src/* too - yeah
18:53:45 <mwhit> glguy: oh, duh
18:53:49 <mwhit> i've been doing that wrong forever
18:54:14 <cschneid> glguy: no idea why I find answers right after giving up and asking for help :)
18:54:25 <mwhit> funny, that
18:56:14 <enthropy> > 1 :: Int :: Int
18:56:16 <lambdabot>  <hint>:1:10: parse error on input ‘::’
18:56:27 <enthropy> any reason that one shouldn't parse as (1 :: Int) :: Int?
18:56:38 <shachaf> :t \x -> x :: Int :: Int -> Int
18:56:39 <lambdabot> Int -> Int
18:56:42 <monochrom> > (1 :: Int) :: Int
18:56:43 <lambdabot>  1
18:56:57 <codile> lazy io. how awesome is that
18:56:59 <glguy> :t if True then 1 else 1 :: Int :: Int
18:57:01 <lambdabot> Int
18:57:02 <monochrom> well, too bad, but there are virtually no use case anyway
18:57:30 <enthropy> my use case is for specifying partial type signatures
18:57:33 <codile> you don't even need to deal with reading stuff into a multitude of variables or rereading into the same one over and over
18:57:35 <monochrom> lazy I/O is awesomely difficult to use correctly. if that is your sense of awesome.
18:57:48 <codile> it's difficult to use?
18:57:56 <monochrom> yes
18:57:56 <codile> how so?
18:57:57 <enthropy>  y `asTypeOf` (undefined :: (a, T) :: (T, b))
18:58:13 <monochrom> you need to know lazy evaluation inside out to use lazy I/O correctly.
18:58:22 <codile> oh
18:58:24 <codile> hmm
18:59:26 <kristof> lazy I/O, how terrifying
18:59:33 <kristof> that must be a performance nightmare
18:59:58 <colluphid> what is the argc equivalent in haskell?
19:00:58 <glguy> You can look at the output of System.Environment.getArgs
19:01:09 <codile> is it still that bad for simple stuff?
19:01:24 <monochrom> if you don't know why doing the following a million times in a process uses up all your quota for file handles/descriptors and the OS aborts your process, you are not ready for lazy I/O: do { s <- readFile "xxx"; print (take 5 s) }
19:01:55 <monochrom> that depends on what is "simple". is my example "simple"?
19:02:09 <codile> seems simple
19:02:20 <codile> i'm not sure what readFile "xxx" does though
19:02:22 <monochrom> then it is bad. because it is an example of bad.
19:02:26 <kristof> codile: It, you know, reads a file.
19:02:31 <monochrom> it does lazy I/O. that's what it does.
19:02:40 <codile> hmm
19:02:48 <codile> so it's the same as getContents?
19:02:50 <cschneid> if I have a showable thing, is there a Text function to go directly to it, rather than doing `pack . show $ thing`?
19:02:51 <monochrom> yes
19:08:17 <monochrom> lazy I/O is in a dilemmatic position. if you are not advanced, you run into problems you don't understand. if you are advanced, you are ready for better methods such as pipes and conduits. either way, lazy I/O does not help you write correct programs.
19:08:43 <codile> hmmm. okay
19:08:57 <monochrom> it is, of course, adequate for toy programs. but how many toy programs do you care about?
19:09:08 <codile> i just thought it was a cool thing as you could always just read from that one name
19:09:15 <ceramic-houses> i want money making programs
19:10:40 <kristof> Is that because you aren't making money by building ceramic houses?
19:11:39 <kristof> codile: You can read from "one name" in C, too. The difference is that you can reliably free up the resource at a deterministic point in time with C. In Haskell, it gets garbage collected. THAT'S the problem.
19:11:59 <monochrom> it is hard to sell ceramic houses. people expect houses to be not delicate.
19:12:08 <codile> oh
19:12:26 <codile> hmm. so is there an alternative?
19:12:29 <monochrom> it is much easier to sell cermaic software. people expect software to be delicate, and still willing to pay much.
19:12:50 <kristof> That one made me chuckle pretty good.
19:13:04 <codile> it's true actually... :/
19:13:07 <aarvar> ceramics-oriented programming
19:13:08 <Fuuzetsu> the alternative is brick and mortar houses
19:13:12 <ceramic-houses> imagine plastic houses
19:13:13 <ceramic-houses> far apart
19:13:15 <kristof> aarvar: Trademarked by Oracle
19:13:20 <ceramic-houses> 10,000$ and 10,000 sq feet
19:13:28 <ceramic-houses> platic jacuzi n showers inclded and plastic pool
19:13:35 <codile> what about glass houses?
19:13:35 <ceramic-houses> concrete stele colms for supprt
19:13:43 <codile> *cough* windows *cough*
19:13:44 <ceramic-houses> hardened silison could work
19:13:44 <Fuuzetsu> codile: that's been done, right
19:13:47 <aarvar> so what material does haskell use then
19:13:54 <ryantm> http://www.reddit.com/r/haskell/comments/2cv6l4/clojures_transducers_are_perverse_lenses/cjjyay7 I don't understand the definition of mapping. How does it match four different arguments?
19:13:59 <kristof> aarvar: Combinators.
19:14:08 <Fuuzetsu> aarvar: homeless until you force it
19:14:12 <kristof> But watch out! Underneath are the turtles.
19:14:14 <aarvar> lol
19:14:18 <codile> Fuuzetsu: XD
19:14:26 <ceramic-houses> reddit is such a republican attack site
19:14:28 <mwhit> aarvar: Strategic pruning of trees so the house slowly grows around you
19:14:34 <ceramic-houses> 100% of articels attack republicans
19:14:35 <ceramic-houses> lol
19:14:38 <ceramic-houses> total commy site
19:14:46 <ceramic-houses> I prefer drudge report
19:14:47 <ceramic-houses> :)
19:14:48 <glguy> ryantm: "mapping :: (b -> a) -> (r -> a -> r) -> (r -> b -> r)" is the same as "mapping :: (b -> a) -> (r -> a -> r) -> r -> b -> r"
19:14:52 <aarvar> no, that's pruning-oriented programming
19:14:54 <ceramic-houses> and unregulated capitalism
19:14:55 <ceramic-houses> :)
19:15:07 <glguy> sounds off-topic
19:15:13 <ryantm> glguy, Thanks!
19:15:14 <Fabiano> guys, where you use haskell?
19:15:22 <mwhit> what i don't understand about transducers is why they're a big deal
19:15:27 <mwhit> other than because rich hickey says so
19:15:37 <Fabiano> which applications?
19:15:38 <mwhit> mapping f g c = g c . f
19:15:40 <mwhit> whoop dee do
19:15:47 <tabemann_> any application
19:15:51 <monochrom> people think that things mentioned by opinion leaders are big deals
19:15:52 <Fuuzetsu> is transducer some fancy name for a combinator or a new gender to identify with?
19:15:59 <monochrom> it's almost an axiom.
19:16:00 <Fabiano> but, why haskell?
19:16:44 <cschneid> looking for the right word: my type has a monoid instance, I want to write my hspec like "mytype implements monoid" or "mytype has a monoid instance" or "mytype is a monoid" - is there a good way (best way?) to say that?
19:16:46 <mmachenry1> Fabiano: I'm currently writing a concurrent phone dialing system.
19:16:48 <mwhit> rich hickey has this incredible ability where I can listen to him talk, and he sounds like he knows exactly what he's talking about, but I come away not able to name a single conclusion from what he said
19:17:00 <codile> mwhit: wouldn't that be: mapping f g c = g (c f) ?
19:17:24 <kristof> mwhit: That's a little bit disingenuous. He's an intelligent person.
19:17:30 <mwhit> i believe it
19:17:37 <mwhit> i'm not saying he doesn't know what he's talking about
19:17:56 <mwhit> i just somehow never feel like i learned anything when i hear him talk
19:17:58 <mwhit> it's probably on me
19:18:00 <aarvar> what the heck is a transducer
19:18:14 <kristof> I've watched the development of clojure and much of it seems very ad-hoc. "This is the solution to most programs! Oh, we've got this problem now, so... new library! Oh, new problem. So new library!" Ad infinitum.
19:18:32 <ryantm> mwhit One reason to care is if you want to understand how Clojure works
19:18:33 <Fuuzetsu> cschneid: ‘mytype obeys monoid laws’? ‘monoid instance of mytype obeys monoid laws’?
19:18:42 <Fuuzetsu> whatever works as long as it's clear
19:18:42 <monochrom> cschneid: perhaps somehow specify associativity and "x <> empty = x, empty <> x = x"
19:18:53 <cschneid> Fuuzetsu: well, it's actually an implementation of IsString I'm testing
19:19:03 <cschneid> so there aren't "laws" since it really is just a syntax helper
19:19:21 <kristof> mwhit: Some value of "learned anything". If you come from Java, you learn something from his talks about functional programming. If you come from a functional language without macros, you learn about the power of metaprogramming.
19:19:30 <Fabiano> mmachenry, i think haskell somewhat complicated
19:19:49 <Fabiano> mmachenry, is it normal for those who came from languages ​​such as C??
19:20:18 <mmachenry> Fabiano: It has a bit steeper learning curve but people are often needlessly scared away but the big words and don't realize it's easier than they think.
19:20:35 <monochrom> from the C perspective, Haskell can look complicated, yes. from the Haskell perspective, C can look complicated, too.
19:20:37 <aarvar> someone should really create a haskell clone with nicer names for things
19:20:41 <Fuuzetsu> except the times when it's harder than they think ;(
19:20:49 <mmachenry> Fabiano: I think using words like monad, functor, and monoid were potentially marketing failure for Haskell :)
19:20:55 <kristof> aarvar: newtype all the things, then
19:21:25 <kristof> They're the most specific words for the things they represent.
19:21:25 <aarvar> then they look at the source..
19:21:32 <sm> mmachenry: only in the short term, they'll become familiar
19:21:37 <monochrom> my trick is I created a virtual machine in my mind to learn each
19:21:56 <mwhit> oh, is that all
19:22:11 <mwhit> :)
19:22:20 <kristof> If you never used the word "monoid", no one would ever see the relationship between the things that fall under that abstraction.
19:22:24 <tabemann_> Haskell is only conplicated if you try to shove impure ways of doing things into it, rather than learning how to do things purely
19:23:13 <ryantm> It's complicated. Everything is complicated.
19:23:14 <aarvar> actually if you just made everything return IO it wouldn't really be complicated
19:23:26 <Fabiano> mmachenry, recommends some material for those who already know the basics of Haskell and has experience in structured languages​​?
19:23:43 <tabemann_> so of course it is going to seem complicated if you try to program C in it
19:24:00 <Fuuzetsu> well, there's that one C DSL package…
19:24:14 <tabemann_> @where lyah
19:24:15 <lambdabot> http://www.learnyouahaskell.com/
19:24:37 <aarvar> I really didn't like that book
19:25:21 <tabemann_> there's rwh, but I wouldn't recommend that to Fabiano's level of beginner
19:25:50 <tabemann_> and agith is not gentle
19:25:56 <mwhit> there's
19:25:57 <mwhit> @where yorgey
19:25:58 <lambdabot> http://www.seas.upenn.edu/~cis194/lectures.html
19:26:27 <monochrom> I don't think you can reuse much knowledge from your knowledge of imperative languages
19:26:49 <monochrom> you can reuse the idea, the meta idea, that programs should be nicely structured.
19:27:02 <tabemann_> agreed
19:27:06 <kristof> I didn't have much of a problem.
19:27:08 <mwhit> i always tell people with zero exposure that it's closer to learning how to program over from scratch, than it is to learning the average new language
19:27:15 <monochrom> and data should be nicely structured, too.
19:27:34 <kristof> The hardest part for me was understanding enumerated types and algebraic data types.
19:27:49 <kristof> C's union keyword is, uh, different from a sum type, substantially.
19:27:50 <monochrom> but you will not reuse some specific structures, and you will have to use some new structures
19:27:50 <aarvar> If you're coming from OOP it might be worse than starting from scratch
19:28:19 <kristof> aarvar: Not if you've also used C.
19:28:49 <tabemann_> the hardest part for me with Haskell was learning the implications of laziness... but this was coming after years of working with OCaml
19:29:13 <tabemann_> which is functional but impure and strict
19:29:14 <kristof> aarvar: Then it becomes readily apparent to astute users why obj.method() has the syntax that it does; the object is actually a struct with a function pointer named method! And so method invocation is merely pointer chasing and function invocation.
19:29:21 <mmachenry> tabemann: Same with me. I still find that challenging.
19:30:17 <tabemann_> I have to resist the urge to tail recurse in Haskell
19:30:24 <kristof> Uh. Why?
19:30:48 <mwhit> kristof: think foldl
19:31:12 <tabemann_> because in a large set of use cases tail recursion is obviated by laziness
19:31:14 <kristof> Tail call optimization is neat-o. Stack frame re-use and all that. Though if you're going for space optimization you shouldn't be thinking about using Haskell an-y-way.
19:31:20 <monochrom> some tail recursions are still good in Haskell
19:31:29 <kristof> mwhit: That's not tail recursion, that's just... recursion
19:31:36 <mwhit> @src foldl
19:31:36 <lambdabot> foldl f z []     = z
19:31:36 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:31:55 <mwhit> the tail recursive call is why foldl builds up thunks
19:31:58 <mwhit> and why it's discouraged
19:32:04 <mwhit> compared to
19:32:05 <mwhit> @src foldr
19:32:06 <lambdabot> foldr f z []     = z
19:32:06 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:32:19 <Fuuzetsu> didn't we just have this argument about tail-recursion like a week ago…
19:32:21 <monochrom> but foldr builts up thunks, too
19:33:03 <monochrom> read my http://www.vex.net/~trebla/haskell/lazy.xhtml . I have both examples, and both use the same amount of space asymptotically
19:33:16 <monochrom> I should just say: both use linear space
19:33:38 <Fuuzetsu> is that the long article
19:33:43 <monochrom> yes
19:33:57 <kristof> Curse you, thunks.
19:34:06 <Fuuzetsu> I should probably go through it slowly
19:34:12 <Cale> Lazy evaluators don't tend to have a call stack as such
19:34:12 <monochrom> and yet, what Toiken says: still not long enough :)
19:34:22 <Fuuzetsu> it'd be cool if it had irrefutable patterns or something
19:34:45 <Fuuzetsu> ah, Cale comes in with the usual ‘no call stack!’
19:34:47 <tabemann_> I'd say the thing that truly makes Haskell hard is memory management, not all the other stufd
19:34:49 <Cale> yes
19:34:59 <tabemann_> stuff*
19:34:59 <Fuuzetsu> you must highlight the word ‘stack’
19:35:01 <Fuuzetsu> that must be it
19:35:11 <Cale> Well, "TCO" is hard to make sense of if there's no call stack
19:35:24 <mwhit> i'm glad Cale came in
19:35:26 <kristof> I thought that GHC would do some small stack optimizing
19:35:32 <mwhit> because i was about to say all this stuff, but probably say it wrong
19:35:33 <kristof> In the same way that small tuples are unpacked into registers
19:36:06 <monochrom> the reason I don't want you to talk about tail recursion is that it gives you 0 bits of information. absolute 0. you still don't know how much space it uses.
19:36:37 <monochrom> the reason is emphatically not that it must use linear space. the reason is emphatically that you still can't draw any conclusion.
19:36:59 <monochrom> you're really better off talking about the colours your editor uses
19:37:05 <kristof> Which is why I made the small addendum that in haskell, the prevalence of thunks make for very unpredictable space complexity.
19:37:12 <tabemann_> whereas if you are coming from, say, OCaml your immediate instinct is to tail recurse whenever possible
19:37:40 <kristof> Common Lisp and Scheme here, but yes, I do tail recurse whenever possible.
19:38:17 <kristof> Oh, question for those in the no: what exactly do people use as the most modern incarnation of ML: is it SML, or OCaml?
19:38:40 <kristof> *in the know. And by modern, I think I mean "the thing that can most accurately call itself ML or at least preserves the spirit of ML"
19:38:49 <monochrom> I think some of them may answer "F#" :)
19:39:13 <Cale> I wouldn't say it's unpredictable
19:39:20 <monochrom> and I think the rest simply divide half-half between SML and OCaml
19:39:28 <tabemann_> I think SML is more pure (different sense) than OCaml while OCaml has more userbase than SML
19:39:38 <kristof> Weird and weird.
19:40:01 <dreams> is main a redex?
19:40:13 <Cale> You can put an upper bound on the space complexity by considering how much space would be used under lazy evaluation.
19:40:24 <Cale> dreams: Typically?
19:40:28 <tabemann_> and then F# has its fans, but is derided for sacrificing key ML functionality at the altar of .NET
19:40:29 <dreams> Cale: formally.
19:40:31 <monochrom> I used to use old ML, in a sense, because I used to use the theorem prover HOL88, the origin of ML.
19:40:49 <monochrom> it was so old, it required Allegro Common Lisp!
19:41:05 <kristof> Franz is still kickin'. :P
19:41:13 <dreams> Cale: according to redex definition in wiki, main is a redex.
19:41:14 <monochrom> (i.e., use Allegro CL to build ML. then use ML to build HOL88)
19:41:20 <Cale> dreams: Well, 'main' will typically be defined to be some expression that can be reduced, and on its own, it's not a constructor, so you can look up its definition in the environment to reduce it
19:42:48 <dreams> Cale: fair enough.
19:42:52 <monochrom> I think in Haskell implementations or operational semantics, CAF is more important than redex
19:43:25 <dreams> monochrom: I though caf is a redex.
19:45:01 <tabemann_> about foldr, doesn't its space usage vary on whether f is lazy on its second argument? i.e. if it is strict on its second argument its memory usage explodes but if it is lazy on its second argument it does not?
19:45:53 <tabemann_> hence why you don't use foldr if you can help it in strict languages but it is fine in many use cases in Haskell
19:46:01 <monochrom> yes, it varies with laziness
19:46:24 <monochrom> I wouldn't call it fine in lazy languages.
19:46:43 <Cale> Those aren't the words I would use, but it has the right overall impression
19:46:55 <Cale> @src foldr
19:46:56 <lambdabot> foldr f z []     = z
19:46:56 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:47:35 <monochrom> every time there is an easy way to solve a problem in O(1) space and O(n) time, if you use Θ(n) space and same time, it is not fine.
19:47:40 <Cale> Thinking operationally, in the recursive case, foldr immediately gives control to f.
19:47:59 <Cale> So there's a very real sense in which it's O(1) everything.
19:48:34 <Cale> It's just when f matches on its second argument that the recursive application of foldr will be evaluated
19:49:03 <Cale> f might do this conditionally, or all the time, or none of the time
19:49:08 <monochrom> oh, "many use cases", yes
19:49:26 <Cale> It's the pattern matching that requires a stack entry
19:49:43 <trap_exit> you know what lens reminds me of? c++ stl compile times ... why is it so &*)(*& slow ?
19:50:05 <tabemann_> this is what I thought about foldr
19:50:55 <monochrom> I was just having in mind foldr (+) vs foldl (+). neither is fine.
19:51:04 <Cale> yeah
19:51:07 <tabemann_> yes
19:51:34 <monochrom> but foldr (\x y -> f x : y), that's an example of fine in haskell, not fine in SML, yes
19:51:40 <Cale> But it's the pattern matching inside of (+) which eventually causes the stack overflow
19:52:18 <tabemann_> monochrom: that was the case I was thinking of
19:53:23 <Cale> trap_exit: What are you compiling?
19:53:41 <trap_exit> 20 line lens prog
19:54:06 <monochrom> type inference is exponential time or worse, do you know that? :)
19:54:21 <Cale> But probably all the time is being spent by the linker?
19:54:35 <monochrom> oh, that too. that takes quadratic space or something :)
19:54:52 <colluphid> if i have a list ["a", "b", "c"] how could i change it to be a list of Chars instead of Strings
19:55:11 <Cale> colluphid: concat?
19:55:27 <Cale> > concat ["a","b","c"]
19:55:29 <lambdabot>  "abc"
19:55:38 <Cale> :t concat ["a","b","c"]
19:55:39 <lambdabot> [Char]
19:55:40 <monochrom> and "abc" is ['a', 'b', 'c']
19:55:43 <trap_exit> Cale: yea, the linker is spending all the time
19:55:45 <trap_exit> Cale: is there a way to reduce linking time?
19:55:55 <trap_exit> what sucks is that certain errors only pop up during linking
19:55:59 <Cale> trap_exit: No, that's just a pain
19:56:20 <colluphid> Cale: coo thx
19:56:33 <monochrom> you could use the gold linker. but you would then need to tell GHC that you're using the gold linker so that a certain flag is not passed
19:57:06 <tabemann_> okay, I need to get going, will be back later
19:58:10 <monochrom> actually, if you are just building an executable, you need not worry about that. if you're build a lib, then you need to worry.
19:58:15 <Cale> trap_exit: It's just that lens has a lot of dependencies I guess
19:58:33 <Cale> trap_exit: I don't think it's any slower than linking anything else with that many deps.
19:58:48 <trap_exit> argh
19:58:51 <Cale> Is it really that slow?
19:58:58 <trap_exit> this breaks my "wrie a few lines of code" "hit C-0 to compile" cycle
19:59:00 <trap_exit> the wait is annoying
19:59:14 <trap_exit> before Lens, I'm having < 3-4 sec compile cycles
19:59:28 <Cale> Can you lpaste the code?
19:59:34 <kristof> Doesn't Lens do a lot of template expansion?
19:59:39 <Cale> I'll let you know how long it takes on my machine
19:59:52 <Exio4> if you have two "benchmark" codes, same here
20:00:00 <Exio4> i want to know if it is really _that_ expensive
20:00:08 <trap_exit> alright, let me throw something together
20:02:40 <trap_exit> https://gist.github.com/anonymous/c5779253a9c1e834fe2b causes https://gist.github.com/anonymous/9ed112bf25185382b350 ... which now takes > 5 seconds
20:02:50 <trap_exit> oh, I'm using ghcjs inside of virtualbox, I should proabbly mention that
20:03:50 <Cale> That takes 0.4s to build for me
20:03:54 * hackagebot PartialTypeSignatures 0.1.0.0 - emulate partial type signatures with template haskell  http://hackage.haskell.org/package/PartialTypeSignatures-0.1.0.0 (AdamVogt)
20:04:24 <trap_exit> I'd be happy with 0.4s
20:04:34 <Cale> 0.5s if I turn on -O2
20:04:50 <Cale> I'm just using plain GHC though
20:04:56 <trap_exit> hmm
20:04:57 <Cale> ghcjs might be slow?
20:05:02 <trap_exit> yeah, it's very fast for me with ghc too
20:05:27 <Cale> It wouldn't surprise me if ghcjs weren't heavily optimised
20:05:41 <Cale> I mean, it's basically still experimental
20:06:00 <monochrom> also mind how much RAM you give to the virtualbox. the gnu linker uses a lot of memory. it may thrash. it may push you into swap space.
20:06:13 <Cale> Oh, that's a good point
20:06:26 <trap_exit> oh the virtualbox has 12 GB of RAM
20:06:27 <trap_exit> machine has 16GB of RAM
20:06:41 <monochrom> then that is a lot of RAM, even for gnu linker :)
20:06:56 <Cale> Also, I'm not sure what linking means exactly when you're compiling to javascript
20:07:03 <trap_exit> time ghc Test.hs = 1.188 s ; time ghcjs Test.hs = 0.2898s
20:07:12 <trap_exit> err, 2.898
20:07:40 <trap_exit> I think it's the linking it with other modules that depends on it part that's killing me or something
20:08:06 <trap_exit> Linking template haskell (Algo.InsertionSort,Algo.Prog,Core.Data,Core.FFI,Core.JSEvent,Core.TextBlock,Core.Util,ThRunner1) <-- I bet this line is inking more than just Test
20:08:09 <trap_exit> it's linking everything that uses template haskell
20:08:48 <enthropy> maybe there is a ghcijs, that can just be fed a :reload
20:14:49 <hamishmack> trap_exit: luite changed ghcjs so it now uses nodejs to run template haskell, this saves it from having to compile to native code as well as JS
20:15:09 <hamishmack> a big when when you do not need template haskell
20:15:21 <trap_exit> hamishmack: what does this mean? when did this happen?
20:15:23 <hamishmack> a big win when…
20:15:52 <hamishmack> a few weeks ago I think
20:16:56 <trap_exit> hmm
20:16:57 <trap_exit> I recompiled ghcjs yesterday
20:17:40 <hamishmack> and was is that when it got slow?
20:18:29 <trap_exit> I dunno
20:18:36 <trap_exit> I learned about lens today :-)
20:18:47 <trap_exit> I'm a newb
20:19:28 <ajyasgar> i don't really understand the motivation for it, or really what it even does
20:19:56 <hamishmack> I suspect it will be possible to improve the performance of TH in ghcjs
20:20:22 <zRecursive> cabal-install: Codec.Compression.Zlib: premature end of compressed stream
20:23:55 * hackagebot PartialTypeSignatures 0.1.0.1 - emulate partial type signatures with template haskell  http://hackage.haskell.org/package/PartialTypeSignatures-0.1.0.1 (AdamVogt)
20:24:47 <mmachenry> If I have a cabal-managed project, and I am editing a lot of files and I know many won't compile, but I want to load up one in the repl, how can I do that? If I do ghci <file> then the dependencies from Hackage are not present. cabal repl wants to read my whole project in.
20:26:09 <mmachenry> I would think that would be "cabal repl Foo" like in the —help but it doesn't seem to work, it loads everything.
20:32:58 <enthropy> mmachenry: do you use -fdefer-type-errors?
20:33:31 <mmachenry> enthropy: No I don't. I don't know what it is. Why do you ask?
20:34:02 <enthropy> well it can let ghci load up files that don't typecheck
20:34:23 <mmachenry> Oh. Well I want them to be typechecked.
20:34:43 <mmachenry> I want to edit the interface of a module, for example, that all other modules use.
20:35:29 <mmachenry> I will change the code, and then want to repeatedly ghci/edit that module until it's right. I know the rest won't compile since it is wrong or perhaps I've made other changes, to those files.
20:35:47 <mmachenry> But I don't want to be bothered until the first modules is right.
20:36:20 <enthropy> I think if you cabal repl before you break the package, you can keep :reload / :load'ing
21:10:33 <tertl3-laptop> hello jakell
21:12:26 <Fuuzetsu> working outside of cabal repl with just GHCi which doesn't import those modules would also work but probably not what you're after
21:12:36 <Fuuzetsu> if you were using nix on another hand…
21:16:48 <tertl3-laptop> github for windows is finally workable
21:41:08 <platz_> tertl3-laptop: does it show branches in a sane way a-la-gitk ?
21:41:35 <platz_> I thought it presented a simplified view when it first came out
21:46:10 <HauntJemimah> woah
21:46:16 <HauntJemimah> people still use haskell?
21:47:51 <Fuuzetsu> nope, we're only here to tell anyone asking this that there are in fact 0 Haskell users remaining
21:49:07 <joelteon> it's a 1330-man job
21:50:51 <ian_mi> When I load the code http://lpaste.net/109102 with GHC 7.8.3 I get the error Couldn't match type ‘Cat1 P.Maybe’ with ‘(->)’
21:51:17 <ian_mi> haven't I declared Cat1 P.Maybe to be (->) ?
21:51:35 <ian_mi> the error occurs on line 20
21:53:04 <shachaf> You declared it to be (→)
21:53:41 <shachaf> Who knows what that is. You don't have UnicodeSyntax turned on.
21:53:54 <ian_mi> it's just vim conceal
21:54:08 <ian_mi> I can post the raw version
21:54:11 <joelteon> how did you manage to get vim conceal into lpaste?
21:54:21 <ian_mi> highlight + paste
21:54:25 <joelteon> ...ok
21:55:08 <ian_mi> I didn't see an option to upload a file
21:55:44 <ian_mi> anyways, here is the actual code http://lpaste.net/109104
21:58:14 <shachaf> OK.
21:58:23 <shachaf> The issue is your kind annotation, I think.
21:58:34 <dfeuer> Well that was interesting. I was apparently talking to myself.
21:58:55 <shachaf> What do you expect "Cat1 f (a :: k1) (b :: k2)" to do?
22:00:13 <dfeuer> I seem to remember reading a paper about using phantom types to enforce invariants in some data structure, in an attempt to be faster than the nested type representation of that structure. It mostly worked out, except it was possible to break the amortized bounds rather badly if you wanted to.
22:00:30 <dfeuer> Now I can't remember either the data structure, the name of the paper, or the author.
22:00:33 <dfeuer> Any guesses?
22:01:34 <ian_mi> shachaf: well, nothing much, but removing those two particular annotations does not change the problem
22:02:06 <Guest82220> >
22:02:40 <ian_mi> shachaf: if I get rid of all the annotations the problem is fixed
22:03:20 <ian_mi> but I want to keep the kind polymorphism to allow different categories
22:04:05 <tertl3> im excited for the new release
22:04:11 <tertl3> when will it happen?
22:04:46 <ian_mi> still, it is wierd to me that that fixes it because none of the explicit type variables have annotations
22:05:02 <dfeuer> tertl3: do you mean the Haskell Platform/
22:05:07 <dfeuer> ?
22:05:08 <ian_mi> so it seems like the type synonym should still be used
22:05:19 <tertl3> yes dfeuer
22:05:34 <dfeuer> Tertl, there's an RC2.
22:06:12 <dfeuer> So Real Soon Now.
22:08:49 <dfeuer> Tertl, it may even be reasonably usable now, especially if you're not on Windows.
22:11:28 <ian_mi> I guess it might be better to use functional dependencies
22:11:53 <haasn> Note: Kind polymorphism does not require any annotations
22:12:01 <haasn> enabling PolyKinds will infer the most general possible kind
22:12:26 <haasn> At least, for data types. I'm not actually sure if that's true for type families as well.
22:12:57 <haasn> Okay, it's not true for type families
22:13:15 <enthropy> haasn: how so?
22:13:16 <haasn> But it's true for classes and types
22:13:25 <haasn> enthropy: “type family Foo a b c” infers Foo :: * -> * -> * -> *
22:13:26 <enthropy> you get * if there are no annotations at all?
22:13:33 <haasn> Rather than the most general Foo :: k1 -> k2 -> k3 -> k4
22:13:51 <haasn> Which makes sense.
22:13:55 <shachaf> "type family Foo a :: * -> *" is quite different from "type family Foo a b :: *", anyway.
22:14:02 <colluphid> is there a way to limit a function to only accept a list of 3 elements without writing out 4 definitions
22:14:14 <colluphid> func :: String -> Bool
22:14:24 <colluphid> func [a, b, c, _] = False
22:14:38 <colluphid> func [a, b] = False
22:14:40 <colluphid> etc.
22:14:42 <johnw> that doesn't stop people from calling it with more than 4 arguments, btw
22:14:47 <haasn> Oh, yes; that too. Type families are weird
22:14:49 <johnw> you'll get a pattern match error in that case
22:14:56 <enthropy> haasn: seems like that should be changed
22:15:21 <haasn> enthropy: I'm not sure if I'd want that
22:15:33 <Total_1mmersion> Is there anything obviously wrong with my use of mfix here? The annotation is where I replaced dummy references with mfix. http://lpaste.net/109105 I'm getting *** Exception: <<loop>>
22:15:39 <enthropy> well you don't have to enable PolyKinds most of the time
22:15:54 <haasn> colluphid: If you want to accept a list of exactly 3 elements, can you instead just accept exactly 3 elements?
22:16:24 <glguy> Total_1mmersion: You might need a lazy pattern match on your lambda
22:16:55 <Total_1mmersion> glguy, it's not lazy? How do I make it lazy? Remove the pattern matching?
22:17:40 <glguy> > (\ ~(_,_) -> True) undefined
22:17:42 <lambdabot>  True
22:18:52 <glguy> Total_1mmersion: If you want to search for more information the term is "irrefutable patterns"
22:19:51 <Total_1mmersion> Hmm I've seen this before. I'm trying it now
22:20:14 <Total_1mmersion> Wow it worked. I'll read up on those.
22:21:53 <glguy> > let [x,y] = [1,2] in (x::Double,y::Int)
22:21:55 <lambdabot>  (1.0,2)
22:26:20 <Fuuzetsu> real programmers default to Word8
22:26:45 <mwhit> real programmers write Core
22:27:03 <Fuuzetsu> just write C--
22:27:36 <Total_1mmersion> You're allowed to use an as-pattern on a constant?
22:27:42 <Total_1mmersion> > let fib@(1:tfib)    = 1 : 1 : [ a+b | (a,b) <- zip fib tfib ] in take 10 fib
22:27:44 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
22:28:01 <Fuuzetsu> why not?
22:28:12 <Fuuzetsu> >let x@1 = 1 in x
22:28:17 <Fuuzetsu> > let x@1 = 1 in x
22:28:19 <lambdabot>  1
22:28:23 <Total_1mmersion> I always thought as-patterns were only for arguments
22:28:45 <Fuuzetsu> you can put them anywhere that you can put patterns
22:29:05 <glguy> > let x@(~ 10) = 20 in x
22:29:07 <Total_1mmersion> But you can't put a pattern there without the as part, right?
22:29:07 <lambdabot>  20
22:29:25 <Fuuzetsu> I don't understand the question
22:29:40 <Total_1mmersion> You can't drop the "fib@" from what I wrote above
22:29:57 <Fuuzetsu> well, you're using it so no
22:30:26 <Total_1mmersion> Even if I didn't use it
22:30:30 <mwhit> let (1:tfib) = 1 : 1 : [a+b | (a,b) <- zip (1:fib) tfib ] in take 10 (1:tfib)
22:30:34 <mwhit> > let (1:tfib) = 1 : 1 : [a+b | (a,b) <- zip (1:fib) tfib ] in take 10 (1:tfib)
22:30:36 <lambdabot>  Not in scope: ‘fib’
22:30:36 <lambdabot>  Perhaps you meant one of these:
22:30:37 <lambdabot>    ‘tfib’ (line 1), ‘fix’ (imported from Data.Function)
22:30:47 <mwhit> > let (1:tfib) = 1 : 1 : [a+b | (a,b) <- zip (1:tfib) tfib ] in take 10 (1:tfib)
22:30:49 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
22:30:54 <mwhit> works fine
22:30:59 <Fuuzetsu> there is no reason you shouldn't be able to do this
22:31:22 <Fuuzetsu> (1:tfib) is a pattern itself
22:31:35 <Fuuzetsu> name@ is used to name patterns
22:31:37 <Fuuzetsu> hm
22:31:41 <Total_1mmersion> Oh you're right, tihs works fine in let/where/case. I was thinking as a top-level constant this wouldn't work.
22:31:57 <Fuuzetsu> > let out@(in@1) 1 in out
22:31:59 <lambdabot>  <hint>:1:10: parse error on input ‘in’
22:32:04 <Fuuzetsu> > let out@(inner@1) 1 in out
22:32:06 <lambdabot>  <hint>:1:21: parse error on input ‘in’
22:32:13 <Fuuzetsu> > let out@(aner@1) 1 in out
22:32:15 <lambdabot>  <hint>:1:20: parse error on input ‘in’
22:32:15 <mwhit> no you can do it at top-level too
22:32:31 <Fuuzetsu> fuck it's talking about other in
22:32:35 <Fuuzetsu> > let out@(aner@1) = 1 in out
22:32:36 <lambdabot>  1
22:32:40 <Fuuzetsu> cool
22:33:45 <Total_1mmersion> wow mwhit you're right about that too, haha thanks for correcting me
22:37:09 <trap_exit> https://gist.github.com/anonymous/88540def2706884d95db <-- can someone teach me how to write this in Template Haskell ?
22:39:52 <Fuuzetsu> you mean how to generate the red blue green name functions?
22:40:08 <trap_exit> yes
22:40:09 <trap_exit> exactly!
22:40:12 <trap_exit> please help! :-)
22:40:27 <Fuuzetsu> OK, first thing you do is {-# LANGUAGE TemplateHaskell #-}, you with me so far?
22:41:15 <Fuuzetsu> now import Control.Lens and put ‘makeLenses ''Color’ on the bottom, thanking edwardk for all the ungreatful work he had to do and forget that TemplateHaskell exists
22:41:16 <Fuuzetsu> done!
22:41:19 <trap_exit> yes
22:41:26 <trap_exit> no no nono no
22:41:27 <trap_exit> I can't use Control.Lens
22:41:30 <trap_exit> as it's too slow in ghcjs
22:41:39 <trap_exit> so I need to learn how to do this myself in Template Haskell
22:42:07 <Fuuzetsu> you could peak at how makeLenses is implemented and strip it doewn
22:42:08 <Fuuzetsu> down*
22:42:18 <Fuuzetsu> IIRC Haskell wiki has some examples you can adapt
22:42:26 <Fuuzetsu> I think I had some code lying around too…
22:42:59 <trap_exit> yeah, I don't get http://www.haskell.org/haskellwiki/Template_Haskell yet
22:43:07 <trap_exit> I understand clojure amcros
22:43:13 <dfeuer> trap_exit: if Control.Lens is too slow, can you fix it so it's not?
22:43:14 <trap_exit> yet I don't undersand how template haskell is so complicated
22:43:31 <trap_exit> dfeuer: I'd like to create a Lens-Lite
22:43:32 <Axman6> Haskell is a more complicated language
22:43:41 <Axman6> this is why people like homoiconic languages
22:43:46 <trap_exit> where basically it has makeLenses ... and I don't need anything else
22:44:28 <Fuuzetsu> ah, the code I had was making new record type with some field rather than top-level stuff
22:46:05 <dfeuer> trap_exit: so there are features of the types that support functions you don't use, making the types heavier?
22:46:25 <trap_exit> dfeuer: I have no idea what your question asks
22:46:30 <Fuuzetsu> I think you should look at the TH types and try to figure out what they translate to in Haskell syntax then try to translate back
22:47:14 <enthropy> the haddocks for template-haskell show the translation
22:47:55 <enthropy> ex. http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:Dec
22:48:20 <Fuuzetsu> I like the fact that the lens TH module used to make lenses uses lenses
22:49:16 * hackagebot criterion 1.0.0.2 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-1.0.0.2 (BryanOSullivan)
22:49:25 <Fuuzetsu> ooh interesting
22:49:57 <glguy> I've done a bunch of work in that C.L.TH module. It's a lot to take in
22:50:54 <Fuuzetsu> damn, I think I'll hook up criterion to some projects
22:50:58 <Fuuzetsu> the graphs sure are pretty
22:51:39 <enthropy> trap_exit: you can load that Test.hs in ghci, then :set -XTemplateHaskell, then $(reify ''Color >>= stringE . show)
22:51:48 <trap_exit> okay
22:51:50 <enthropy> and you'll see stuff that you can use to define those functions
22:52:00 <Axman6> those docs are really good. could be a little clearer in specifying which parts of say DataD map to which elements of the declartion though
22:52:15 <trap_exit> I think I'm starging to understand template haskell
22:52:15 <trap_exit> so just to check -- all of template haskell is executed at _cmpile_ time right?
22:52:21 <Fuuzetsu> yes
22:52:29 <Fuuzetsu> arbitrary IO execution and all
22:52:30 <Axman6> (it wasn't obvious to me that [Name] referred to the deriving clause)
22:53:25 <enthropy> Fuuzetsu: well I don't think they're going to add named fields to that data Dec, so you can't attach docs to those particular things
22:53:52 <Fuuzetsu> wrong highlight?
22:54:10 <enthropy> sorry, Axman6
22:58:11 <Axman6> enthropy: sure, though it'd be nice to have each section showing up in italics: DataD Cxt Name [TyVarBndr] [Con] [Name]   { data /Cxt x/ => /T/ /x/ = /A x | B (T x)/ deriving /(Z,W)/} but that's probably not possible with haddock
22:59:53 <Fuuzetsu> what's not possible
23:00:08 <Axman6> no didn't think so, but it would be nice nonetheless
23:00:19 <Fuuzetsu> m8 don't give me that, damn right it's possible
23:00:24 <Fuuzetsu> swear to god
23:00:40 <Axman6> u wot m8?
23:01:42 <Axman6> also there's a type in Type's docs:
23:01:42 <Axman6> ForallT [TyVarBndr] Cxt Type	
23:01:44 <Axman6> forall <vars>. <ctxt> -> <type>
23:01:47 <Axman6>  should be
23:01:50 <Axman6> forall <vars>. <ctxt> => <type>
23:01:55 <Fuuzetsu> DocParagraph (DocAppend (DocString "{ data ") (DocAppend (DocEmphasis (DocString "Cxt x")) (DocAppend (DocString " => ") (DocAppend (DocEmphasis (DocString "T")) (DocAppend (DocString " ") (DocAppend (DocEmphasis (DocString "x")) (DocAppend (DocString " = ") (DocAppend (DocEmphasis (DocString "A x | B (T x)")) (DocAppend (DocString " deriving ") (DocAppend (DocEmphasis (DocString "(Z,W)")) (DocString "}")))))))))))
23:02:07 <Fuuzetsu> looks like what you want to me
23:02:15 <Axman6> looks good to me too =_
23:02:18 <Axman6> =)*
23:02:25 <Axman6> anyway, time to head off!
23:05:47 <glguy> trap_exit: Still doing template haskell?
23:05:56 <trap_exit> glguy: yeah
23:06:01 <glguy> http://lpaste.net/109107
23:06:05 <glguy> You can peek at that if you get stuck
23:06:13 <glguy> One thing it doesn't do is generate type signatures yet
23:06:31 <trap_exit> glguy: damn, I'm no where near that
23:06:41 <trap_exit> still getting up to date on basics of template haskell
23:06:59 <glguy> It's worth learning, but there are tricky bits
23:07:18 <trap_exit> yeah; apaprently I can't define macros + use them in the same file
23:09:23 <trap_exit> Quasiquoters must obey the same stage restrictions as Template Haskell, e.g., in the example, expr cannot be defined in Main.hs where it is used, but must be imported.
23:13:26 <trap_exit> in the context of Tempalte Haskell, what does Q / Exp mean? "Q Exp" show up all over the place
23:13:52 <glguy> Q is the monad that you do template haskell stuff in. It can generate new names and other fun TH things
23:13:55 <glguy> Exp is an expression
23:14:03 <glguy> or at least the syntax for one
23:14:20 <glguy> a Q Exp is a template haskell "program" for generating expression syntax
23:17:01 <trap_exit> whoa
23:17:02 <trap_exit> cool
23:17:08 <trap_exit> I would have never guessed that Q was a monad by looking at code
23:17:18 <trap_exit> but shoudl I have guessed -- how else would Haskell do macros, if not with monads :-)
23:18:39 <c_wraith> trap_exit: it has runIO..  That should have been enough for you to guess. :P
23:18:52 <glguy> Updated for generating type signatures :)
23:19:14 <trap_exit> c_wraith: ah, I'm reading tutorials, not the actual docs :-)
23:21:07 <trap_exit> glguy: noted, thanks!
23:24:35 <glguy> trap_exit: Have you read about "splices" yet?
23:25:09 <glguy> and expression quotations?
23:25:43 <enthropy> there should be a tutorial that motivates those
23:25:56 <enthropy> possibly some of the papers count for that
23:26:06 <glguy> I annotated the paste to show using them or not using them
23:26:30 <glguy> They let you switch between TH Syntax -> actual expressions    and back from actual expressions to TH Syntax
23:26:49 <trap_exit> glguy: splices as in (+2) and (2+) i.e. binary op + one arg
23:27:00 <trap_exit> glguy: oh, those are "slices", not "splices"
23:27:07 <glguy> right :)
23:27:20 <glguy> More like this: [| $fExp ($fieldExp $xExp) |] or [t| $innerUpdType -> $outerUdpType |]
23:27:31 <glguy> The '$' splices and the [| |] quotes
23:28:31 <trap_exit> glguy: http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html mentioned it
23:28:34 <trap_exit> but it's not complete
23:28:37 <enthropy> (+2) is a "section"
23:31:04 <mwhit> okay, another stab at understanding more advanced lensing. I have a Traversal a a b b, and a function (b -> c -> m c) that I want to fold over a. howww... do i do that in terms of the traversal?
23:31:14 <mwhit> i feel like there's some operator i'm missing or something
23:31:18 <mwhit> seems like that should be very simple
23:31:24 <trap_exit> ah, the Q Monad is the "quotation Monad"
23:32:26 <shachaf> It'll probably help to use the standard lens variable names. Traversal s s a a, where s is the "structure" and a is the thing inside.
23:32:35 <shachaf> Where does c come from?
23:33:22 <mwhit> right, sorry
23:33:55 <mwhit> c is just a type used in the fold function
23:34:09 <shachaf> It'll also help if you use concrete-looking variable names for things that are concrete types.
23:34:51 <shachaf> So maybe you want something like fold[lr]MOf?
23:35:22 <trap_exit> https://gist.github.com/anonymous/e00373ec24718c65d001 <-- how do I fix this template haskell code? (reading a tutorial)
23:36:00 <mwhit> ah
23:36:18 <mwhit> i thought I had to work with MonadicFold somehow
23:36:23 <mwhit> was all mixed up
23:36:28 <mwhit> foldrMOf is it
23:37:08 <trap_exit> ah; got it to compile :-)
23:37:11 <trap_exit> I am greatness.
23:40:31 <trap_exit> glguy: A splice is written $x, where x is an identifier, or $(...), where the "..." is an arbitrary expression. There must be no space between the "$" and the identifier or parenthesis. This use of "$" overrides its meaning as an infix operator, just as "M.x" overrides the meaning of "." as an infix operator. If you want the infix operator, put spaces around it.
23:40:36 <trap_exit> glguy: yeah, I get splice now :-)
23:42:35 <trap_exit> splices can be Q Exp, for exp, Q Type, for type, or Q [Decl] for a list of top level declarations
23:42:36 <trap_exit> awesome
23:44:00 <tac-tics> trap_exit: what tutorial are you going through?
23:44:13 * tac-tics needs to sit down and suffer through learning template haskell 
23:44:14 <trap_exit> tac-tics: you want to learn too? :-)
23:44:17 <tac-tics> yes
23:44:30 <trap_exit> tac-tics: http://web.archive.org/web/20100703060856/http://www.haskell.org/bz/thdoc.htm I'm only 5% through it; join me
23:47:17 <tac-tics> trap_exit: are you sure this is a reliable tutorial?
23:47:20 <tac-tics> If it's this old....
23:47:39 <trap_exit> tac-tics: it's amazing
23:48:46 <tac-tics> I am not convinced.
23:49:22 <enthropy> tac-tics: TH has not changed much recently
23:49:31 <enthropy> that tutorial is probably missing quasiquoters
23:49:31 * trap_exit refunds tac-tics his $.
23:50:07 <tac-tics> {-# OPTIONS_GHC -fth #-}
23:50:07 <tac-tics>  <-- this is older, isn't it?
23:50:29 <enthropy> yes and ghc will tell you "please use -XTemplateHaskell"
23:51:37 <tac-tics> Well
23:51:52 <tac-tics> trap_exit: You get a head start, and I'll try it out tomorrow
23:52:08 <enthropy> there are some other subtleties that have changed (say what's in scope for reify), but I think those are things you can ignore most of the time
23:52:12 <tac-tics> It's probably better I get some sleep, rather than learn something new at 2am
23:54:14 <glguy> Typed quotes and splices are new
23:59:02 <zRecursive> Cabal-1.20.0.2 failed while unpacking the package. The exception was:
23:59:03 <zRecursive> user error (data is not in tar format) \ncabal-install-1.20.0.3 depends on stm-2.4.3 which failed to install. \nstm-2.4.3 failed while unpacking the package. The exception was: \nuser error (data is not in tar format)
23:59:38 <nk87> Has anybody here read Thompson's "Haskell - The Craft of Functional Programming," and would you recommend it for a newcomer?
