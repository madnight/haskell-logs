00:00:22 <mjrosenb> lwin 27
00:05:12 <michaelt> mjrosenb: here's an attempt to skip to the newline http://lpaste.net/8491278226843238400 I don't have input so I may be hallucinating.
00:06:11 <mjrosenb> michaelt: I can give you the full input if you want :-p
00:07:54 * hackagebot hspec-laws 0.0.0 - Document and test laws for standard type classes  http://hackage.haskell.org/package/hspec-laws-0.0.0 (SimonHengel)
00:07:54 * hackagebot yesod-platform 1.2.13.2 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.2.13.2 (MichaelSnoyman)
00:10:51 <michaelt> mjrosenb: oh another dumb mistake, I dropped a char in the bad material, rather than dropping the newline after it http://lpaste.net/2436154537472425984
00:13:03 <mjrosenb> michaelt: almost able te test it!
00:14:12 <michaelt> you need a lens library, I used lens-family just because its easier to install, but if you have `lens` and Control.Lens, use `view` from it.
00:14:36 <mjrosenb> /jesus/ pipes-group pulls in a lot of stuff.
00:15:16 <michaelt> oh damn, yeah, you enter edward k land for Free and so on...
00:15:50 <mjrosenb> I feel like bytestring /really/ shouldn't require that much more than the standard one.
00:15:53 <merijn> mjrosenb: Really? it doesn't have so many dependencies...
00:16:10 <michaelt> mostly they are very compact packages
00:16:21 <merijn> mjrosenb: profunctors, semigroupoids, etc. are really tiny packages
00:16:22 <mjrosenb> merijn: https://gist.github.com/480b12f42e9f055892d4
00:16:36 <mjrosenb> I realize they're small
00:16:40 <mjrosenb> just there are a lot of them.
00:16:54 <merijn> mjrosenb: Try installing pandoc, or something
00:17:14 <merijn> mjrosenb: Haskell is just more amenable to small reusable code than many other languages, imo
00:17:20 <michaelt> ... sorry about that, I always have them installed anyway...
00:17:31 <mjrosenb> merijn: I was comparing pipes-bytestring with pipes-attoparsec
00:17:40 <mjrosenb> which had 2 things I didn't already have.
00:18:05 <michaelt> now for pandoc you need lua bindings, I think an http server or something ...
00:18:05 <mjrosenb> well, 1 if you don't count pipes-attoparsec
00:18:40 <mjrosenb> michaelt: your implementation is getting 50 mb/sec.
00:19:02 <michaelt> how terrible is that? worse than String?
00:19:23 <michaelt> the pipes-attoparsec is a bit slow, it does fancy stuff we're not using, like tracking position
00:19:35 <mjrosenb> michaelt: better than string, worse than my original ByteString /after/ lines
00:19:45 <mjrosenb> *nod*
00:19:59 <michaelt> hm, and you're compiling with -O2 or whatever
00:20:05 <mjrosenb> yup. -O2
00:20:12 <mjrosenb> ghc --make -O2 dd2
00:20:20 <mjrosenb> same I used for mine.
00:20:27 <michaelt> yeah
00:20:42 <michaelt> well, I'm not sure how to improve it without getting ugly. ....
00:21:12 <mjrosenb> I guess I could drop attoparsec, and do it myself.
00:21:36 <michaelt> it isn't surprising that a pure bytestring + attoparsec-bytestring thing would be faster.  Since this is straightforwardly sequential, ByteString.lines will probably not be too bad.
00:22:09 <mjrosenb> michaelt: this was a lazy bytestring
00:22:19 <mjrosenb> but yeah.
00:22:48 <michaelt> yes you would need that for input, though it is less desirable for parsing.
00:22:50 <mjrosenb> so with ByteString.lines was 70 mb/s, when I let attoparsec handle newlines, it bumped to 80mb/s
00:23:43 <michaelt> the Pipes.ByteString.stdin gets rid of the need for lazy input, but does stick you with all attoparsec thinking.
00:26:27 <lpvb> so what happened to the pipes vs conduits debate from a year ago? did ekmett's machines take off?
00:27:13 <tranma> lpvb: https://twitter.com/GabrielG439/status/501900054928441344
00:27:34 <mjrosenb> what is O(n\c)? (the ByteString docs for ByteString.drop say it has that running time.
00:29:01 <splintax> link? the docs i'm looking at say it's O(1)
00:29:12 <mjrosenb> http://hackage.haskell.org/package/bytestring-0.10.4.0/docs/Data-ByteString-Lazy-Char8.html
00:30:33 <splintax> i'm guessing from the comments on fromChunks and toChunks that c means "the number of chunks"?
00:30:35 <michaelt> lpvb: it's still the same, I'd think.  conduit is much more widely used, and has way more associated libraries. machines is distinctly esoteric still, I'd think.  I like io-streams by the way
00:31:08 <johnw> michaelt: and there is simple-conduit too
00:31:21 <michaelt> oh right...
00:31:36 <lfairy> io-streams is a great one to start with
00:31:52 <mjrosenb> as long as it is amortized constant when n << chunksize, I'm fine.
00:32:03 <michaelt> maybe an io-streams would make this fast. In fact since lazy io is suitable to the task it may not be worth the trouble.
00:32:26 <tranma> hm, how do I use pipes with scotty to stream out json? I'm looking at scotty's `stream` which takes a WAI `streamingbody`, which relies on blaze-builder….
00:32:31 <tranma> I have a producer of bytestrings
00:34:22 <michaelt> yipe blaze-builder... I'm not sure tranma. the bytestring producer is producing the json, so that part is over?
00:35:16 <tranma> yeah, I can produce the json, now I just need to stream it (not via websockets)
00:36:20 <michaelt> there aren't any builder much less blaze builder libraries for pipe as far as I know. Let me see what the types are like though...
00:37:27 <tranma> type StreamingBody = (Builder -> IO ()) -> IO () -> IO () that's quite an unfriendly type!
00:38:25 <johnw> it's just a specialized foldM
00:39:21 <michaelt> ha, I was going to report back in horror type StreamingBody = (Builder -> IO ()) -> IO () -> IO ()
00:40:20 <michaelt> wait how is that FoldM? It's 3 in the morning here ...
00:40:31 <michaelt> oh I see
00:40:38 <johnw> it just ignores the accumulator since it's ()
00:40:43 <michaelt> yes
00:41:54 <lfairy> johnw: it's not semantically a foldM though, since the second argument means "flush" not "base case"
00:42:04 <johnw> fair
00:42:06 <michaelt> oh
00:42:26 <johnw> i'd say closer to a LogicT, except it's not quite that either
00:42:32 <lfairy> michaelt: so you write a function \ write flush -> do ...
00:42:42 <lfairy> and in that function you call write and flush
00:42:51 <lfairy> with your data
00:43:00 <lfairy> that's what I got from reading the docs, anyway
00:43:03 <mjrosenb> @hoogle (.|.)
00:43:05 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
00:43:43 <mjrosenb> oh derp
00:43:47 <mjrosenb> :b /= :browse
00:44:08 <Iceland_jack> :bro == :browse
00:44:14 <michaelt> so tranma will be looking at a type x :: StreamingBody -> ScottyAppThing, and so will write x $ \write flush ...
00:47:23 <tranma> yeah, I'm trying to reconcile that with the fact that I want a Producer ByteString m -> Scotty.ActionM ()
00:55:02 <michaelt> tranma: okay, I see, the way that makes no sensible use of builders would just be \write flush -> for myjsonproducer (\bs -> lift (write (tobuilderfunction) >> flush))
00:55:30 <michaelt> thus flushing after converting each bytestring chunk into a builder...
00:55:47 <michaelt> oh, i need runEffect in there to make the whole thing IO ()
00:58:11 <michaelt> \write flush -> runEffect $ for myjsonproducer (\bs -> lift (write (tobuilderfunction) >> flush))  or \write flush -> runEffect $ myjsonproducer >-> mapM (\bs -> lift (write (tobuilderfunction) >> flush)) or the like
00:58:43 <michaelt> \write flush -> runEffect $ for myjsonproducer (\bs -> lift (write (tobuilderfunction bs) >> flush))  rather, I forgot to use the bytestring
00:59:17 <Markz> pick number 2 m'lord
01:03:16 <solatis> the "pattern matches are overlapped" warning for _ seems to me as if it could be safely ignored, as long as i am aware of the order in which the patterns are matched. is this correct?
01:04:23 <mjrosenb> solatis: my guess would be that you're never going to get to that case?
01:04:44 <solatis> mjrosenb: hmm
01:05:03 <solatis> why would you assume that?
01:05:33 <solatis> https://github.com/pcapriotti/optparse-applicative/blob/master/tests/Examples/Hello.hs#L29
01:05:38 <solatis> that code generates that warning
01:06:19 <lfairy> solatis: that looks like a bug in GHC
01:06:27 <solatis> no
01:06:30 <lfairy> it's possible to reach that if the second field is True
01:06:31 <solatis> it is a bug in my head
01:06:38 <solatis> pebcak
01:06:39 <solatis> sorry
01:07:01 * lfairy shrugs
01:07:21 <mjrosenb> solatis: what was the issue?
01:07:55 <solatis> that i'm a half-assed monkey that only rarely has a clue what he is doing
01:11:30 <johnw> solatis has awakened to the human condition I see
01:11:45 <johnw> welcome to the club :)
01:11:55 <mjrosenb> rolling my own hex parser seems to have the same speed as attoparsec :-(
01:12:03 <johnw> mjrosenb: I've been there
01:18:12 <mjrosenb> oh great, and that made it slower :-(
01:18:50 <solatis> mjrosenb: remembers me of my C time... "surely i can write a faster scanner/parser than flex/bison!"
01:18:52 <solatis> boy was i wrong
01:19:53 <mjrosenb> solatis: so, I'm competing against a parser that I wrote by hand in like 40 minutes, in C.
01:20:40 <solatis> mjrosenb: and now you're trying to make an attoparsec parser in haskell and let it be faster?
01:20:56 <mjrosenb> solatis: I'm trying to get within a factor of 5.
01:21:02 <solatis> mjrosenb: that's easy
01:21:10 <solatis> just add a 'sleep(1)' statement in the C parser
01:21:22 <solatis> (sorry couldn't resist)
01:21:37 <mjrosenb> solatis: well, if I put that as the first line of main, the C one will still be faster
01:21:42 <solatis> haha
01:21:44 <solatis> ouch
01:21:55 <thebnq> add it in the loop (:
01:22:15 <solatis> but yeah i haven't seen anyone beat C parser generators yet
01:22:27 <solatis> they usually have crazy fast state machines and lookup tables
01:22:45 <solatis> even C++'s Qi/Spirit doesn't even come close
01:22:52 <mjrosenb> solatis: I was considering a look up table.
01:23:04 <mjrosenb> I ended up just using the branches of a switch statement.
01:24:01 <solatis> yeah but the scanner generators will just make a 256 byte lookup table, make it incredibly unsafe, and you have O(1) all over the place
01:24:16 <mjrosenb> solatis: a switch is O(1)
01:24:18 <mjrosenb> probably.
01:24:25 <solatis> i know, but it's not as fast as a lookup table
01:24:50 <mjrosenb> anyhow, I am not looking to increase the speed of my C program
01:25:00 <mjrosenb> I'm looking to increas the speed of my haskell program.
01:25:30 <nol> ow don't we all
01:25:44 <solatis> i know, i'm just merely saying that, after about 40 years of C, with incredibly optimized parser generator libraries, it's never going to be close
01:26:03 <zereraz> :t "a"
01:26:05 <lambdabot> [Char]
01:26:37 <levi> solatis: switch statements often are compiled to lookup tables.
01:27:01 <solatis> levi: if they are large enough to justiy the memory requirements, yes
01:28:09 <solatis> ok, this was the first hit i found
01:28:10 <solatis> https://github.com/lokeshw24/rsync_parser/blob/master/lex.yy.c
01:28:12 <solatis> just look at that code
01:30:29 <levi> Are you compiling your Haskell code with optimizations on, too?
01:31:31 <mjrosenb> levi: yup.
01:31:33 <mjrosenb> levi: -O2
01:31:42 <mjrosenb> does anything higher do anything?
01:31:49 <mjrosenb> also, wow. gj, gcc
01:31:56 <mjrosenb> my C function is 91 lines long
01:32:04 <mjrosenb> and it compiles to 141 instructions.
01:34:37 <levi> mjrosenb: The question is, what's the main source of inefficiency in your Haskell code? Have you tried profiling?
01:36:17 <mjrosenb> l	nope, and I don't really know how to,.
01:36:42 <NickHu> Hi, I'm trying to install ghc-mod but cabal wants to reinstall a bunch of packages and I can't find why: http://lpaste.net/109742
01:37:24 <lfairy> mjrosenb: have you tried alex?
01:37:37 <lfairy> I haven't used it myself, but I heard it's good
01:37:44 <mjrosenb> lfairy: good as in fast?
01:38:14 <johnw> mjrosenb: why not just use FFI to call your C version?
01:38:54 <mjrosenb> johnw: because the C version isn't that extensible.
01:39:18 <levi> mjrosenb: http://book.realworldhaskell.org/read/profiling-and-optimization.html
01:39:33 <lfairy> mjrosenb: I think it uses lookup tables, so yes
01:45:45 <mjrosenb> wow, adding -sstderr slowed it down by an order of magnitude.
01:47:41 <levi> Sorry I can't help any more, gotta sleep.
01:47:47 <levi> Good luck!
01:47:59 <mjrosenb> https://gist.github.com/e1c02eb6f5a39f21373f -- well, at least gc isn't destroying me.
01:53:59 <stalintrotsky> In something like f :: (Num a) => a -> Type; f 3 = something, how does a Num instance get pattern matched against the 3?
01:54:51 <kvanb> I think its GHC magic that literals are instances of Num
01:54:59 <Iceland_jack> stalintrotsky: Well that type is wrong
01:55:08 <kvanb> (or IsString)
01:55:30 <Iceland_jack> If you try it GHC should complain about a missing 'Eq' constraint
01:55:58 <kvanb> clever
01:55:58 <Iceland_jack> Case in point:
01:55:59 <Iceland_jack> @ty \3 -> False
01:56:00 <lambdabot> (Num a, Eq a) => a -> Bool
01:56:02 <stalintrotsky> does it use the Eq instance to pattern match?
01:56:05 <Iceland_jack> Yes
01:56:14 <stalintrotsky> oh, I see
01:56:20 <stalintrotsky> thanks
01:56:34 <Iceland_jack> You're welcome
01:57:27 <lfairy> mjrosenb: what does -sstderr do?
01:57:42 <mjrosenb> lfairy: no clue.
01:57:53 <mjrosenb> lfairy: well, it prints out the thing I pasted before.
01:58:39 * mjrosenb now tries with actual profiling.
01:59:00 <mjrosenb> ooh, and the speed gets halved again!
02:03:21 <mjrosenb> c.c half of the time, and half of the allocations are parsing hex numbers.
02:08:20 * hackagebot shuffle 0.1.2.0 - Shuffle tool for UHC  http://hackage.haskell.org/package/shuffle-0.1.2.0 (JeroenBransen)
02:09:00 <mjrosenb> https://gist.github.com/856597631fdb4ea52818 -- not horribly informative
02:09:27 <mjrosenb> although, I guess that is showing that ByteStream.Lazy isn't hurting per se?
02:13:21 * hackagebot statvfs 0.2 - Get unix filesystem statistics with statfs, statvfs  http://hackage.haskell.org/package/statvfs-0.2 (GergelyRisko)
02:14:19 <arianvp> soo. I was checking this comonadic version of Life. but I don't see the gain
02:14:34 <arianvp> it's like 100 LoC and I can write a much more concise version without Comonads
02:15:13 <lfairy> mjrosenb: can you put your code on lpaste? maybe #haskell can look at it
02:16:42 <mjrosenb> lfairy: suuuure :-p
02:17:11 <mjrosenb> https://gist.github.com/026f381c79d428b0e0e0 -- that is the fastest version I've gotten so far.
02:18:54 <mjrosenb> err, no, it isn't.
02:19:03 <mjrosenb> blast, I destroyed the fast one.
02:23:24 <abc56889> anyone know of a template haskell function which grabs information about enclosing scope to help debugging when things go wrong?
02:25:20 <mjrosenb> lfairy: https://gist.github.com/f5bcdf4ec5f8eb0a0dbf -- ok, that version is 10 MB/s faster than the first one.
02:29:26 <lfairy> mjrosenb: have you tried simply scanning for 'x', rather than matching a whole string?
02:29:37 <pavonia> abc56889: The Debug.Trace module might have something for you
02:29:54 <lfairy> that seems intuitively faster, but I without profiling I'm not sure
02:33:23 * hackagebot type-natural 0.2.2.0 - Type-level natural and proofs of their properties.  http://hackage.haskell.org/package/type-natural-0.2.2.0 (HiromiIshii)
02:33:53 <mjrosenb> lfairy: 78 -> 81
02:34:17 <mjrosenb> of course, I'm not 'scanning', but jumping a fixed N bytes ahead.
02:35:20 <lfairy> mjrosenb: are those numbers in seconds, or seconds^-1 ?
02:35:43 <mjrosenb> seconds^-1
02:35:59 <jkarni> why does GHC think the version in comments here is ambiguous?
02:36:01 <jkarni> http://lpaste.net/109745
02:36:50 <jkarni> Can't it transfer the fundep in (ShowPred a flag) to PrintHelper?
02:37:38 <jkarni> oops, nevermind
02:37:44 <jkarni> no it couldn't
02:38:24 * hackagebot reserve 0.0.0 - Reserve reloads web applications  http://hackage.haskell.org/package/reserve-0.0.0 (SimonHengel)
02:38:40 <lfairy> jkarni: I think you need forall flag. in the instance head, so ScopedTypeVariables kicks in
02:39:32 <jkarni> lfairy: the pasted code compiles fine - it's just the changes mentioned in the comments that make it break
02:40:54 <lfairy> oh whoops never mind
02:42:27 <jkarni> lfairy: also a little of pasting woes
02:43:30 <jkarni> lfairy: I believe ScopedTypeVariables automatically scope over methods in class/instance decs
02:43:39 <lfairy> jkarni: yeah, til
02:48:20 <adas> is it okay to say that types like Int, Integer, Bool and other user defined types .. are atomic types in type theory?
02:48:26 * hackagebot casadi-bindings-internal 0.1.1 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-internal-0.1.1 (GregHorn)
02:48:27 * hackagebot casadi-bindings-core 2.0.0.1 - low level bindings to casadi-core  http://hackage.haskell.org/package/casadi-bindings-core-2.0.0.1 (GregHorn)
02:48:29 * hackagebot casadi-bindings-control 2.0.0.1 - low level bindings to casadi-control  http://hackage.haskell.org/package/casadi-bindings-control-2.0.0.1 (GregHorn)
02:48:32 * hackagebot casadi-bindings 2.0.0.1 - low level bindings to CasADi  http://hackage.haskell.org/package/casadi-bindings-2.0.0.1 (GregHorn)
02:49:58 <mjrosenb> adas: what do you mean by 'atomic'?
02:52:04 <adas> mjrosenb: atomic types are types that belong to collections which form level-1 types. in this case I think level-1 types would typeclasses which can have instances of atomic types
02:52:36 <adas> mjrosenb: like i said, im just trying to understand if im right. Am not saying that I'm right : )
02:53:10 <adas> mjrosenb: i read about this at goodmath.org. was wondering if my anolgies were correct
02:54:01 <adas> or rather if it was the right way to look at it
02:55:19 <Kinnison> ls
02:55:22 <Kinnison> oops
03:01:03 <Twey> adas: Not… necessarily
03:01:34 <Twey> adas: TT's ‘atomic types’ are basically ‘some other types not defined here’
03:02:05 <adas> Twey: could you elaborate?
03:02:05 <Twey> adas: If you're not interested in e.g. user type definitions then certainly you can just call all user-defined types ‘atomic’ and be done with it
03:02:27 <Twey> Hm
03:02:44 <Twey> Although Haskell also lets you define type *functions*, like Maybe, which are not usually considered atomic types
03:03:27 * hackagebot fullstop 0.1.4 - Simple sentence segmenter  http://hackage.haskell.org/package/fullstop-0.1.4 (EricKow)
03:06:35 <adas> Twey: Maybe might not be an atomic type because "Maybe a" could be a level-1 type in the context of "Maybe Int, Maybe Bool, Maybe UserDefinedType" and so on..
03:07:37 <adas> Twey: so you're saying whats on that article is not even remotely applicable to haskell?
03:08:43 <Twey> adas: I don't know what article you're referring to, but I imagine you'd find that it's very applicable to Haskell, but doesn't consider user-defined types and so on (because they're not relevant to what it's talking about).
03:09:03 <johnw> I love it when a program that takes 10G of heap is fixed by a one-line to take no more than 5MB throughout its entire run
03:09:09 <johnw> one-line change*
03:09:14 <doismellburning> johnw: so satisfying!
03:09:29 <johnw> it really is, and moreso that it didn't take that long to find!
03:10:06 <johnw> I saw a block of code and thought "sharing is holding every list element on the heap"...
03:11:13 * Kinnison wishes he was at that point.  I mostly look at code and if I understand what it's doing at all I'm happy :-)
03:11:20 <johnw> does anyone know why this code would be taking 50% of my program's not insignificant runtime: https://gist.github.com/ae2d2cc364f7dbed4d23
03:11:43 <johnw> (using Attoparsec)
03:12:28 <johnw> ah, skipWhitespace should be using skip, not satisfy
03:12:32 <johnw> that's one
03:13:34 <mjrosenb> johnw: I'd imagine the chain of short-circuiting is doing fun things to your cpu's branch predictor.
03:14:51 <mjrosenb> ooh, and then stopChar piles a bunch more on.
03:15:45 * mjrosenb wonders if a static lookup-table would be apropriate here.
03:15:56 <johnw> i wondered that too
03:16:24 <johnw> a 256-element vector
03:16:28 <johnw> that's what I'd do in C
03:16:52 <hexagoxel> 118 seems enough :D
03:17:16 <mjrosenb> hexagoxel: yeah, but then you'd need extra math / bounds checks.
03:17:27 <mjrosenb> hexagoxel: and the goal is most likely to decrease branches.
03:17:31 <hexagoxel> hmm true
03:18:09 <mjrosenb> I actually had a /really/ cute idea for this recently.
03:19:42 <adas> Twey: this is what i was referring to http://www.goodmath.org/blog/2014/08/15/the-basics-of-st-type-theory-plus-administrivia/
03:19:44 <johnw> actually, I can simulate a table lookup
03:19:51 <johnw> with a function that matches on its argument
03:19:52 <adas> should have used a url shortner
03:19:57 <johnw> for Ints, will that be smart?
03:20:05 <johnw> or will it be identical to the if?
03:20:05 <alpounet> johnw: i've done both and it tends to perform decently
03:20:54 <alpounet> (table lookup and testing the argument's value with guards)
03:22:20 <alpounet> it may be a bit more efficient than the =='s OR'd together
03:23:18 <hexagoxel> the other question is of course "do you need to call parseWord that often?"
03:23:40 <johnw> yeah
03:23:44 <johnw> it's the whole point acutally
03:24:02 <arianvp> why can you write the definition of list as  L(a) = 1 / (1 - a)
03:24:37 <bennofs> johnw: be warned though that having big case expressions causes GHC to take really long to compile :/
03:24:42 <arianvp> I'm reading about zippers and they argue zippers are just derivatives of the data structure
03:24:59 <arianvp> so they say "you can write the definition of list as   L(a) = 1/(1-a)"
03:25:04 <shachaf> I think GHC will generate better code for data T = T0 | T1 | T2 | ... | T255; f :: T -> ...; f T0 = ...; f T1 = ...; ... than for f :: Word8 -> ...; f 0 = ...; f 1 = ...; ...
03:25:04 <phaskell> T1: SSL for monitor.haskell.org/nagios - https://phabricator.haskell.org/T1
03:25:04 <phaskell> T2: Move wiki to rackspace vm - https://phabricator.haskell.org/T2
03:25:18 * shachaf looks to see if that's actually what's being talked about.
03:25:27 <arianvp> and the deriviative of that is  a / (1 - a)^2
03:25:43 <arianvp> hence list zippers are  L(a) * a * L(a) =    data ZIpper a = Z [a] a [a]
03:25:55 <bennofs> schell: oh, why is that ?
03:26:08 <bennofs> schell: sorry, meant shachaf
03:27:05 <shachaf> Because it'll generate bad code for the latter, maybe.
03:27:10 <shachaf> I might well be wrong, you should try it. :-)
03:28:25 <Twey> arianvp: Where are you reading this?
03:29:16 <ewd> join deutsch
03:30:21 <thebnq> with ghci i could load a file and play with functions that aren't exported, is there a way to do that with cabal repl?
03:30:52 <thebnq> (without adding to the .cabal or exporting everything)
03:31:20 <arianvp> Twey: http://chris-taylor.github.io/blog/2013/02/13/the-algebra-of-algebraic-data-types-part-iii/
03:31:27 <arianvp> Twey: and http://en.wikibooks.org/wiki/Haskell/Zippers
03:31:34 <dcoutts_> thebnq: yes, you can use :module or :load after starting cabal repl
03:31:45 <arianvp> " Remembering that lists are L(a) = 1 / (1 - a)"
03:32:14 <thebnq> dcoutts_: oh i see thanks!
03:32:15 <dcoutts_> thebnq: and you may need to cabal clean -s  first, to remove .o files, so you get interpreted mode
03:32:45 <dcoutts_> thebnq: you'll be able to tell, because ghci says when it loads each module if it's interpreted or from a .o file
03:32:46 <BoR0> how come you are able to write L(a) = 1/(1 - a) as lists? this doesn't make much sense to me
03:33:43 <quchen> BoR0: You know how lists are "[a] = 1 + a*[a]"?
03:33:47 <thebnq> hm i didn't clean but its interpreting fine :)
03:33:53 <bennofs> dcoutts_: btw, why does cabal repl build the project before loading the repl? the repl still needs to load all the modules in interpreted mode anyway
03:34:01 <BoR0> quchen, oh, is this type theory notation?
03:34:11 <bennofs> dcoutts_: or is it just to perform preprocessing & compilation of c files?
03:34:49 <dcoutts_> bennofs: as far as I know it does not compile all the modules to .o files, just .c files and pre-processing
03:34:49 <quchen> BoR0: Not really, it's just different notation. In Haskell, you would write "data [a] = Nil | Cons a [a]". Here, | behaves like a +, and Cons like a tuple, which is like *.
03:35:08 <bennofs> dcoutts_: it compiles everything for me :/
03:35:18 <quchen> BoR0: If you've never heard of any of this, this blog post might be helpful. http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/
03:35:30 <BoR0> quchen, I am aware with the haskell syntax. but why is exactly 1 = Nil ?
03:35:41 <hpc> BoR0: there's only one value it can take
03:35:44 <hpc> specifically Nil
03:36:16 <frerich> Speaking of optimization, could anybody help me making sense of a ".prof" file I generated? The source code and the profiling report I got for some representative input is at http://lpaste.net/109748 -- I gathered that 'exec' is really where the time is spent, which makes sense. However, I'm not sure how much I can trust the report since 'handle' calls itself recursively, I suppose that has some odd effect on the profiling report.
03:36:19 <BoR0> I see. so a * b * c would equal to a (b c) using that syntax?
03:36:30 <quchen> No, that would be (a,b,c).
03:36:46 <BoR0> but then, lists are not Nil | (a, [a])?
03:36:55 <frerich> What's also clear is that it would help if 'getCell' and 'setCell' would be faster, but it's not clear to me how I could improve their speed, I'm using a mutable vector already -- and a vector of unboxed things didn't seem to help. :-/
03:37:08 <quchen> BoR0: Now you're mixing two notations. I really recommend the post I just linked.
03:37:20 <BoR0> quchen, right. I'll read that one, thanks
03:37:22 <quchen> It's not complicated, and explained very well there.
03:37:26 <Twey> arianvp: The answer is here, under ‘Lists’: http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/
03:37:31 <hpc> BoR0: the way data definition syntax works, (Cons a [a]) is what you are thinking of
03:37:43 <BoR0> yes
03:37:47 <quchen> BoR0: Part 2 of the post talks about how to get to 1/(1-a) specifically.
03:37:51 <arianvp> ah there was a part 2
03:37:58 * arianvp walks away in shame
03:38:02 <bennofs> dcoutts_: oh, I just tried it and it seems you're correct. thanks :=)
03:38:03 <arianvp> :) thanks anyway haha
03:38:06 <Twey> arianvp: There's a Part I too ;)
03:38:10 <arianvp> hehehe
03:38:30 <arianvp> I think it's really magical that I can just take the derivative of a functor and get a zipper back
03:38:38 <arianvp> this stuff really makes me fill up with joy :P
03:38:51 <tulcod> frerich: this is unrelated, but why did you need to switch arguments? your exec.handle is just "flip exec"
03:39:06 <dcoutts_> bennofs: that's odd, because the code fairly clearly does not
03:39:20 <frerich> tulcod: Yeah, that's an artefact of earlier refactorings rendering the 'handle' function obsolete.
03:39:24 <dcoutts_> bennofs: you're not seeing another dependent component being built are you?
03:39:27 <bennofs> dcoutts_: well, as I said, it seems to work now. don't know if that is something that was fixed
03:39:35 <Twey> arianvp: FYI I think you can actually implement - and / on types in a HoTT setting
03:39:45 <dcoutts_> bennofs: e.g. your exe depending on a lib, and the lib being built?
03:39:51 <bennofs> dcoutts_: ah wait, that might be
03:39:51 <dcoutts_> within the same package I mean
03:40:06 <Twey> Hm, maybe not -, or only with some circumlocutions
03:40:19 <arianvp> Twey: though I have totally no intuitions how that'd look hehe
03:40:33 <dcoutts_> bennofs: so for the exe, the lib has to be compiled. You can cabal repl the lib of course.
03:40:36 <Twey> But I think it's (at least potentially) justified in some sense
03:41:08 <tulcod> frerich: the 50% time is spent in your last "handle" clause  (l@(Loop p))  -  you don't see this in the statistics because you don't have an SCC here
03:41:41 <frerich> tulcod: Ah okay, For what it's worth, that "run" function is just "foldM exec", i.e. it recurses
03:42:13 <frerich> tulcod : So I suppose if I could make the other branches in 'handle' cheaper, which seem to be dominated by the costs of 'setCell' and 'getCell', then that recursion would be cheaper as well.
03:43:43 <tulcod> frerich: fwiw it looks like the setCell is much more costly than getCell
03:44:04 <bennofs> dcoutts_: it seems that it always builds the lib, even if i do cabal repl lib:hnix
03:44:06 <tulcod> frerich: but either way this is not the bulk of the work
03:44:39 <dcoutts_> bennofs: what cabal version, can I see a log?
03:44:52 <bennofs> cabal-install version 1.20.0.3
03:44:55 <bennofs> using version 1.20.0.2 of the Cabal library
03:45:44 <tulcod> frerich: say, where did the "m" argument in "handle l" on line 31 go?
03:46:37 <Twey> arianvp: a / b can be defined by a quotient type, i.e. a type with a new equivalence relation b
03:46:37 <frerich> tulcod: It is 'eta reduced', i.e. the code could also be "run m p >>= \m' -> handle l m'"
03:47:26 <tulcod> frerich: ah :)
03:47:27 <BoR0> quchen, I just saw why L(a) = 1/(1 - a). but, using this algebra, are we free to do stuff that we are using ordinary algebra? e.g. move a*L(a) on the left side and then divide by (1-a)
03:47:49 <frerich> tulcod: FWIW, in case I missed some pieces in my paste - the full (though little...) source code is at https://github.com/frerich/brainfuck/blob/compilation/src/Main.hs
03:48:01 <bennofs> dcoutts_: https://gist.github.com/bennofs/bd4af56ef1d272a8362e
03:48:09 <tulcod> frerich: is there any reason why you are using IO-mutable memory to implement this? can't you use e.g. lenses? i think you can do this in pure haskell, perhaps more efficiently
03:48:24 <tulcod> frerich: (not that I know a lot about lenses)
03:48:31 <tulcod> or e.g. the State / ST monad
03:48:43 <frerich> tulcod: I used a zipper on lists before, but they seemed to be very inefficient when it comes to seeking left/right more than one step at a time.
03:48:46 <Twey> BoR0: When you talk about ‘moving x to the left and changing the sign’, what you actually mean is ‘adding x to [or subtracting x from] both sides’.  So so long as addition (or subtraction) is valid, so is the operation.
03:48:51 <quchen> BoR0: I guess, yeah. But I don't have any deeper knowledge about these things.
03:48:56 <frerich> tulcod: I suppose the ST monad would work just as well
03:49:00 <Twey> BoR0: Addition is always valid, but subtraction is only valid in some special circumstances, it seems.
03:49:34 <frerich> tulcod: It's just that I never did anything with that monad yet (always only read about it) so I kind of tip-toed around it ;->
03:49:51 <tulcod> frerich: well ST is probably going to give something equivalent to this
03:50:02 <Twey> BoR0: Similarly with multiplication/division: multiplication is always valid (it's just a pair, and you can construct a pair of any types), and I *think* division is too, but I might be wrong there.
03:50:02 <tulcod> but i'm just thinking, can't you do this efficiently in pure haskell?
03:50:21 <tulcod> frerich: anyway, the fact that you spend most of your time processing Loops is not surprising, obviously
03:50:34 <tulcod> that's why algorithm complexity is so important
03:50:55 <frerich> tulcod: I suppose if setCell is really as expensive as the profiling report makes it look, then that's either caused by the lenses generated by 'mkLabels' incurs some significant, or Data.Vector.Mutable.Write is where the time is spent
03:51:03 <BoR0> Twey, ok, I understand
03:52:01 <Twey> BoR0: Er, ‘is valid and preserves the equality you care about’.
03:54:48 <BoR0> haha, at part 2 "Although we abused the algebra horribly, by performing operations that are completely unjustified on types, we still ended up with a sensible answer." :D
03:55:17 <BoR0> I am not sure if any of this makes sense to me right now
03:55:46 <moop> how easy is it to make a haskell app for android?
03:57:24 <bennofs> dcoutts_: https://gist.github.com/bennofs/2311a8dc7e728919c10a is a simple self-contained example
03:58:16 <dcoutts_> bennofs: cheers, just installing the same version of cabal...
04:04:53 <dcoutts_> bennofs: weird, works for me
04:05:00 <dcoutts_> as in, it does not build, only repl
04:05:14 <dcoutts_> using same version of cabal-install as you
04:05:28 <dcoutts_> of course, I don't think it's that weird, because it is what the code says it does
04:05:30 <pyr> hi haskellers!
04:06:03 <dcoutts_> hi pyr! :-)
04:06:15 <pyr> I am working on a new "FileStore" and wanted to use it in gitit
04:06:27 <pyr> looking at http://hackage.haskell.org/package/gitit-0.7.3.4/docs/Network-Gitit.html I'm a bit at loss as how do to that
04:06:48 <Twey> Is there a function in ‘time’ for converting to diffs from the UNIX epoch?
04:07:02 <pyr> gitit has a FileStoreType non-extensible type and I can't make out how to use the WikiState type which does what I want
04:07:20 <pyr> would anyone have jumped through these specific hoops before ?
04:07:24 <dcoutts_> Twey: you could convert to UTCTime, and then take a diff with the unix epoch
04:08:05 <Twey> dcoutts_: Aye, I was just wondering whether there was a function to do it before I went about defining my own epoch
04:09:15 <dcoutts_> Twey: but that's easy: posixSecondsToUTCTime 0
04:09:22 <dcoutts_> Twey: but actually, it's even easier...
04:09:44 <dcoutts_> Twey: POSIXTime is actually a NominalDiffTime from the UNIX epoch!
04:09:47 <Twey> Ah!  I missed the whole POSIX module
04:09:53 <Twey> Brilliant, thanks!
04:10:22 <dcoutts_> so the function I was imagining writing would actually be id
04:10:47 <Twey> And there's a utcTimeToPOSIXSeconds too
04:11:02 <Twey> So there is such a function!
04:11:44 <dcoutts_> oh, I misunderstood the direction you wanted to convert :-)
04:19:59 <Trollinator> The more I learn about Haskell, the less I feel like I've understood anything at all.
04:23:14 <Twey> Trollinator: Don't worry — it may be a journey into the unknown, but it's a fun journey and you're in good company :þ
04:23:37 * hackagebot reserve 0.1.0 - Reserve reloads web applications  http://hackage.haskell.org/package/reserve-0.1.0 (SimonHengel)
04:38:22 <bennofs> dcoutts_: Maybe https://github.com/haskell/cabal/blob/6cc46998f0778c04b535c805416604995fe153b5/Cabal/Distribution/Simple/GHC.hs#L795 is the reason for the behaviour I'm seeing?
04:44:16 <dcoutts_> bennofs: that just runs ghci if we're in repl mode (assuming there are any modules in the library)
04:44:52 <dcoutts_> bennofs: the comment it talking about a dependency problem with ffi
04:56:05 <foobar_> hola! how can I compile a regex pattern with regex-tdfa package
04:57:22 <foobar_> there is this regex pattern which I use multiple times. Having a compiled regex would help I guess
04:58:07 <Axman6> this doesn't dirctly answer your question, but do you actually need a regex? would a proper parser be clearer and easier to maintain?
04:58:44 <Axman6> (Only asking because we often get users of other languages where regexes are widely used and have never heard of parser combinators, and are usually very happy when they do find out about them)
04:58:52 <Axman6> @hackage regex-tdfa
04:58:52 <lambdabot> http://hackage.haskell.org/package/regex-tdfa
04:58:59 <Axman6> @botsnack
04:58:59 <lambdabot> :)
04:59:30 <foobar_> I think thats my case too :). Pretty new to this
04:59:36 <Twey> What's the nicest tool for hunting down space leaks around these days?
05:00:03 <Axman6> foobar_: what're you trying to match?
05:00:24 <foobar_> Axman6, a filename
05:01:05 <foobar_> Axman6, can you give some pointers where I can read about parser combinators. Would be helpful :)
05:01:08 <Axman6> foobar_: for reference, there seems to be "compile" functions in each of the various Text.Regex.TDFA.foo modules: http://hackage.haskell.org/package/regex-tdfa-1.2.0/docs/Text-Regex-TDFA-String.html#v:compile
05:01:24 <Axman6> foobar_: sure thing. I'll have to remember how I learned about them!
05:01:51 <Axman6> http://www.haskell.org/haskellwiki/Parsec is probably a great place to start
05:02:25 <foobar_> Axman6, thanks man. 'would read that
05:02:27 <Axman6> http://book.realworldhaskell.org/read/using-parsec.html from memory is good
05:02:45 <Axman6> (as is most of the rest of that book, though a few bits are outdated)
05:03:07 <dcoutts_> foobar_: you may also find you can do it using just the System.FilePath module (depending on what you want to do exactly)
05:03:25 <Axman6> also a good suggestion
05:04:29 <Axman6> but learn parsec anyway, it's a fantastic tool. Soon, wall your problems will look like they can be solved with a decent parser :P
05:07:59 <blakehaswell> Agreed, I’ve only used parsec for some small stuff, but it's extremely powerful and intuitive once you learn it
05:08:26 <Axman6> and usually so much more clear when you come back to it months later!
05:08:27 <blakehaswell> But I did struggle with the documentation for a while
05:08:42 * hackagebot kure 2.16.4 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.16.4 (NeilSculthorpe)
05:08:54 <blakehaswell> Yeah, parsec > regex for maintainability any day of the week
05:10:39 <Axman6> and being able to parse context sensitive stuff is often very useful: len <- word64; bs <- getByteString len; bytesTerminator; return bs (more a attoparsec/binary kind of example, but equally useful for text)
05:17:29 <Twey> (word64 >>= getByteString) <* bytesTerminator ?
05:35:12 <mjrosenb> Axman6: how does parsec's speed compare with attoparsec?
05:37:36 <bennofs> mjrosenb: parsec is much slower than attoparsec
05:37:55 <Twey> That being largely the point of Attoparsec
05:37:59 <mjrosenb> blast :-(
05:38:46 * hackagebot friday 0.1 - A functionnal image processing library for Haskell.  http://hackage.haskell.org/package/friday-0.1 (RaphaelJavaux)
05:38:59 <mjrosenb> I spent the last ~7 hours trying to get attoparsec to be within 5x of C for a very simple problem.
05:38:59 <kvelicka> is there a way to see which functions are uncovered in haddock? it keeps telling me that I have 15/16 but I can't see which one am I missing
05:39:23 <mjrosenb> I suspect the limiting factor is actually parsing the hex numbers.
05:43:47 * hackagebot aws-ec2 0.2 - AWS EC2/VPC, ELB and CloudWatch client library for Haskell  http://hackage.haskell.org/package/aws-ec2-0.2 (VladimirKirillov)
05:53:04 <remdezx> Hello! Does anybody know ho can I make library available to use inside ghc monad? I'm using "hint" library and on runtime and I keep getting error "user error (WontCompile: Could not find module ‘Data.Hash’ Use -v to see a list of the files searched for.)". I added data-hash to build dependencies of my project
05:54:45 <jkarni> remdezx: are you using a sandbox?
05:55:56 <remdezx> jkarni: yes
05:58:19 <jkarni> remdezx: yeah, I believe hint runs outside of the sandbox, so it won't notice the package
05:59:12 <remdezx> oh ;/ . ghc as a library would notice it?
05:59:55 <jkarni> no - that's what "cabal repl" is for
06:00:04 <mjrosenb> > elemIndicies '"' (fix show)
06:00:06 <lambdabot>  Not in scope: ‘elemIndicies’
06:00:06 <lambdabot>  Perhaps you meant one of these:
06:00:06 <lambdabot>    ‘BS.elemIndices’ (imported from Data.ByteString),
06:00:06 <lambdabot>    ‘BSL.elemIndices’ (imported from Data.ByteString.Lazy),
06:00:06 <lambdabot>    ‘elemIndices’ (imported from Data.List)
06:00:14 <mjrosenb> > elemIndices '"' (fix show)
06:00:19 <lambdabot>  mueval-core: Time limit exceeded
06:00:26 <mjrosenb> did I really copy the mis-typed line?
06:00:28 <mjrosenb> gah.
06:00:39 <mjrosenb> anyhow, why does lambdabot not produce a partial result there?
06:01:21 <vanila> > elemIndices 'x' "aabaxaxxaxaxxbabx"
06:01:22 <lambdabot>  [4,6,7,9,11,12,16]
06:01:42 <vanila> I guess it holds the result in an accumulator or is strict or something
06:01:52 <vanila> @hoogle elemIndices
06:01:55 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
06:01:55 <lambdabot> Data.ByteString.Lazy.Char8 elemIndices :: Char -> ByteString -> [Int64]
06:01:55 <lambdabot> Data.ByteString.Char8 elemIndices :: Char -> ByteString -> [Int]
06:02:01 <jkarni> remdezx: https://github.com/gelisam/hawk/blob/d3d6734d3402668d42cc390b0573acea43ecdaa1/src/System/Console/Hawk/Sandbox.hs
06:02:03 <remdezx> jkarni: is there any other way to make hint see sandboxed packages? Maybe some flags needs to be set or something? We could also mix calls to ghc and hint
06:02:05 <Twey> WFM.  Maybe it just times out?
06:02:08 <mjrosenb> > elemIndices 'x' "aabaxaxxaxaxxbabx" ++ repeat 'y'
06:02:09 <lambdabot>  Couldn't match expected type ‘GHC.Types.Int’
06:02:10 <lambdabot>              with actual type ‘GHC.Types.Char’
06:02:14 <Twey> > elemIndices '"' $ fix show
06:02:19 <lambdabot>  mueval-core: Time limit exceeded
06:02:23 <jkarni> remdezx: Hawk runs into that issue - that file should show how it solves it
06:02:26 <Twey> > take 2 . elemIndices '"' $ fix show
06:02:28 <lambdabot>  [0,2]
06:02:34 <mjrosenb> > elemIndices 'x' ("aabaxaxxaxaxxbabx" ++ repeat 'y')
06:02:39 <lambdabot>  mueval: ExitFailure 1
06:03:01 <Twey> mjrosenb: I think λb tries to get a complete ‘line’ (truncated) of input before outputting it, and the later elements are increasingly slow to generate
06:03:14 <mjrosenb> exitfailure 1 ?
06:03:22 <remdezx> jkarni: thanks a lot, I will take a look at this :)
06:03:43 <Twey> ¯\o/¯
06:04:00 <jkarni> remdezx: np
06:13:12 <mjrosenb> :t splitEvery
06:13:14 <lambdabot> Int -> [e] -> [[e]]
06:14:56 <ex> why is my function "bitStream" eating my ram, but "bitStreamWorking" actually returning its output? i thought the code would do the same thing http://lpaste.net/6673386568092221440
06:19:20 <mjrosenb> @src foldr
06:19:20 <lambdabot> foldr f z []     = z
06:19:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
06:20:53 <ex> but shouldn't BSL.foldr .. do "the same thing" as foldr ... (BSL.unpack ...)?
06:21:16 <ex> (i'm not talking about the implementation but the actual results)
06:21:27 <mjrosenb> ex: if BSL.foldr attempts to be strict, then you'll build up a giant call stack
06:21:59 <mjrosenb> while Data.List.foldr will be able to give you partial results immediately for processing
06:22:19 <ex> i thought it'd not be strict enough as it is in Data.ByteString.Lazy
06:23:01 <mjrosenb> @src BSL.foldr
06:23:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:23:14 <mjrosenb> @src Data.ByteString.Lazy.foldr
06:23:14 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:24:36 <ex> http://www.haskell.org/ghc/docs/7.6.3/html/libraries/bytestring-0.10.0.2/src/Data-ByteString-Lazy.html
06:24:48 <mmachenry> Should I use Data.BTree.HashTable.STM or 		https://hackage.haskell.org/package/stm-containers-0.1.3/docs/STMContainers-Map.html for a hash table in STM that I will want to have many concurrent threads updating individual pieces of?
06:25:26 <mmachenry> Sorry, bad paste job. STMContainers.Map vs Data.BTree.HashTable.STM
06:29:53 <mjrosenb> ex: how much memory is it eating?
06:31:53 <ex> i don't know the max memory usage, but after requesting 5 chars from /dev/urandom ate 80MB and keep increasing, i'd say it is a _little_ strict :P
06:37:20 <ex> after a few minutes it ate 200~mb compared to the <2mb of the list version
06:37:54 <ex> i just wanted to avoid the intermediate list, but i think i'll keep it like that
06:38:51 <mjrosenb> list-fusion should make the intermediate list go away
06:39:00 <mjrosenb> then again BSL.unpack seems to be kind of crazy.
06:39:08 <mjrosenb> so it probably won't get fused.
06:40:18 <mjrosenb> ex: if you generate a sample 'random' file with dd, and run both versions, do they produce the same result?
06:43:11 <ex> mjrosenb: i copied ~8mb of random data from /dev/urandom to a file, the BSL.unpack version returns in <100ms, the other returns "out of memory (requested 2097152 bytes)"
06:44:46 <Raghs> cabal install cabal-install is giving me error /usr/bin/ld: cannot find -lz on Ubunutu 14.04. what is z? how do i get it?
06:45:44 <ex> (with a "little enough" input, they do the same thing)
06:46:01 <dcoutts_> Raghs: zlib, you need the zlib system package (dev version). It's odd for it to fail that way though, it should fail during configure of the Haskell zlib wrapper package
06:46:22 <dcoutts_> Raghs: can you show us the log of the command and the failure (e.g. hpaste)
06:47:56 <Raghs> dcoutts_ : Here's the hpaste
06:47:58 <Raghs> http://lpaste.net/6347187761920868352
06:49:13 <dcoutts_> Raghs: do you know if you installed the Haskell zlib wrapper package earlier via cabal, or via your system package manager? If you don't know, using ghc-pkg list should give us a hint, if it's in the global section then you'll probably have installed it via the system package manager.
06:49:58 <dcoutts_> Raghs: or did you recently upgrade your system packages? It's possible you may have installed the zlib wrapper previously, and now the system C zlib package is no longer installed for some reason.
06:50:37 <Raghs> dcoutts_ : I installed haskell platform 2014 this morning and did cabal-install
06:51:01 <dcoutts_> Raghs: what OS?
06:51:03 <Raghs> i installed zlib and was able to get the cabal-install run
06:51:08 <Raghs> ubuntu 14.04
06:51:27 <dcoutts_> oh, ubuntu you said, ok, did you install the haskell platform via the system package manager?
06:53:06 <dcoutts_> Raghs: ?
06:54:06 <mads-> dcoutts_: just a quick question regarding the current subject. Which one would you recommend? Using the package manager of your system or cabal?
06:54:07 <dcoutts_> if so then something is broken with the system package, since the libghc6-zlib-dev should depend on zlib1g-dev
06:54:23 <Raghs> no. i downloaded and installed it from http://www.haskell.org/platform/linux.html Haskell Platform 2014.2.0.0 for Linux, 64bit
06:54:30 <dcoutts_> mads-: depends on the circumstance and user
06:55:32 <dcoutts_> Raghs: ahh ok, so a binary of the whole platform. Ok, then I guess we should really file a ticket with the platform installer, since it should check that the necessary C libs are already installed.
06:57:43 <Raghs> dcoutts_ : thanks.
07:22:31 <mjrosenb> ex: so, I just tried it, giving it a 200 mb file.  both versions ran basically instantly.
07:22:44 <mjrosenb> ex: and used basically no memory.
07:37:09 <Algebr`> Having strange issue where cabal doesn't install the head of a package, instead fetching some really old version.
07:37:36 <Algebr`> I was under the impression that cabal install <package> would always get the HEAD of that package?
07:37:53 <bennofs> Algebr`: try --constraint "<package> == <head version of package>"
07:37:59 <Algebr`> (package in question is http, keep getting version 40000.0.7)
07:38:15 <bennofs> Algebr`: then cabal will give an error message telling you why it can't choose <head version of package>
07:39:06 <ex> mjrosenb: Glasgow Haskell Compiler, Version 7.6.3, stage 2 booted by GHC version 7.6.3 (debian's version) what is yours?
07:40:13 <mjrosenb> 7.8.3
07:41:26 <Algebr`> bennofs: I did cabal install http --constraint "http == 4000.2.17" and that still tried installing 4000.0.7
07:41:48 <bergmark> Algebr`: that's odd...
07:42:17 <bergmark> Algebr`: oh, constraints are case sensitive
07:42:20 <bergmark> the package is called HTTP
07:42:27 * dcoutts_ was about to say the same thing
07:43:11 <Algebr`> its literally parsing a haskell string for the constraint?
07:43:38 <bergmark> Algebr`: not sure what you mean
07:44:09 <Algebr`> I mean what ever comes after --constraint, it just evals that haskell string?
07:44:19 <bergmark> no
07:44:27 <Algebr`> not like other command line options like --with-gcc=gcc-4.9
07:45:25 <Algebr`> Okay, so it worked. Why doesn't cabal always go for head? Something in .cabal/config can be changed?
07:45:49 <dcoutts_> Algebr`: it tries to minimise the number of installs
07:45:49 <bergmark> Algebr`: it probably preferred an older version to not break already installed packages
07:46:01 <bergmark> and/or that
07:46:09 <mjrosenb> `/win 4
07:46:12 <dcoutts_> Algebr`: so it tries to use existing versions of things you've got installed already
07:46:14 * mjrosenb is good today
07:46:21 <dcoutts_> rather than agressively upgrading everything
07:46:47 <Algebr`> okay, well I learned something new today. thanks.
07:47:33 <dcoutts_> Algebr`: re your parsing Q, no, it's not just accepting any string as a constraint. But "http == 4000.2.17" is a valid constraint for a package called "http", it's just that the one you wanted is called "HTTP"
07:48:41 <dcoutts_> package names are case sensitive, but the cabal-install command like UI mostly lets you use them insensitively when it's not ambiguous, but it doesn't support that disambiguation for constraints
07:49:01 <clrnd> ja I had the exactly same problem yesterday, so I installed the latest version of HTTP manually
07:50:01 <Algebr`> general question, safe to say cabal is like a supped up make?
07:51:36 <dcoutts_> Algebr`: sort of, it's a build system that knows all about Haskell and Haskell compilers, but in many ways the build system is not as good as make. It's not easily customisable, and it's not fully dependency based.
07:53:23 <AshyIsMe> it's more like node's npm
07:53:28 <int-e> Algebr`: not really; cabal is less about how to build a package itself (make is very good for describing a result that is produced in several steps with many intermediate results; Cabal will often break down there, requiring custom hooks) and more about describing dependencies on other packages (which 'make' really isn't designed to handle at all).
07:53:35 <AshyIsMe> if you know node that is...
07:53:49 <mjrosenb> it replaces a fractal-like subset of the standard C ecosystem
07:54:37 <int-e> Algebr`: so it's a bit of a build system and a bit of a package manager, limiting itself to common uses for the first part.
07:57:16 <mjrosenb> also, if you could argue that cabal is /far/ less powerful than make :-p
07:57:53 <dcoutts_> mjrosenb: as a build system, yes
07:58:13 <dcoutts_> it's a long standing issue that Cabal's internal build system infrastructure is basically crap
07:58:46 <dcoutts_> (but doing it properly is hard, we've tried)
07:59:30 <mjrosenb> dcoutts_: well, if you're talking about cabal, it is a library that can't do /anything/ on its own, and needs to be linked into Setup.hs.
08:19:56 <hask54> Is it common for Haskell programmers to actually create their own functors?
08:20:17 <hask54> And monoids and monads.
08:20:18 <trap_exit> do programs which allow scripting within Haskell basically have to have a GHC embedded in them?
08:20:27 <trap_exit> if not, how do they load dynamic haskell code and execute it?
08:20:42 <trap_exit> hmm, speaking of which ... how does xmonad do it -- how dow xmonad relaod its config files?
08:21:06 <Ralith> hask54: yes.
08:21:20 <Ralith> trap_exit: it recompiles itself and restarts
08:21:44 <trap_exit> Ralith: hmm, so it's like copy ~/.xmonad.hs into source tree; recompile, restart
08:21:49 <trap_exit> whoa
08:21:49 <trap_exit> clever
08:21:56 <jayunit100> anyone curating a fully featured haskell vagrant box ?
08:21:57 <mjrosenb> hask54: I've found that my larger projects tend to, but my smaller projects don't.
08:22:03 <trap_exit> somethign something paper about trusting trust
08:22:09 <thebnq> trap_exit: there are other means to do this though, like using ghc as a library
08:22:22 <trap_exit> how about the yi editor
08:22:23 <hask54> mjrosenb: ok, coz it seems like all the functors,monoids,monads are already ready-made for me from the libraries and frameworks
08:22:25 <trap_exit> it supports loading dynamic modules right?
08:22:27 <trap_exit> how do they do it?
08:23:00 <mjrosenb> hask54: many, many of them are, but when you start implementing your own types, this will no longer be the case.
08:23:10 <hask54> ok, thanks
08:23:11 <hask54> good to know
08:23:26 <mjrosenb> trap_exit: we were talking about this before; there is a pretty old package called plugins.
08:23:26 <thebnq> hm theres a library
08:23:39 <mjrosenb> and there are others.
08:23:47 <geekosaur> xmonad doesn't copy xmonad.hs anywhere. xmonad is a library; ~/.xmonad/xmonad.hs is a main program, which calls into the library with a config record telling it how to behave. that config record can reference definitions in xmonad.hs
08:24:31 <trap_exit> geekosaur, so xmonad.hs is like Main.hs which goes "import xmonad" man
08:24:32 <trap_exit> that is smart
08:24:49 <geekosaur> import XMonad; main = xmonad defaultConfig
08:25:05 <trap_exit> man
08:25:08 <trap_exit> I use xmonad all these years
08:25:10 <trap_exit> this finally makes sense
08:25:13 <trap_exit> geekosaur ++
08:31:30 <S11001001> @ty coerce
08:31:32 <lambdabot> (Contravariant f, Functor f) => f a -> f b
08:32:31 <c_wraith> that looks lensy, rather than the new built-in coerce
08:32:56 <c_wraith> Also, it *is* true that with those constraints, that operation is always safe!
08:33:45 <S11001001> mmhmm :)
08:35:00 <c_wraith> ...  Assuming lawful implementations of both constraints, I guess.
08:35:41 <c_wraith> Err, maybe it doesn't even require that.  I can't find a way to use GADTs with bad instances to mess it up
08:43:32 <amf> in postgresql-simple, my query is returning IO [my-data-type], and i want to loop over that with forM_, how do i get the data out of IO?
08:46:09 <BeardedCoder> amf: I don't think forM_ is what you want. If the type you just mentioned is accurate you can bind the list then use list functions on it.
08:47:29 <amf> BeardedCoder: what do you mean bind?
08:47:50 <BeardedCoder> :t (>>=)
08:47:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
08:49:55 <amf> oh right, ok let me fiddle around with this a little more
08:49:56 <Xeironis> In a ghci session, if I have -Wall enabled, how can I unset it?
08:50:09 <frerich> One pattern which I noticed in my code is 'a >>= \x -> case x of ...'. Is there a way to shorten this somehow such that I don't need to come up with a name like 'x'? In actual code, it's more like "do { args <- getArgs; case args of ..}" and I always wonder if there isn't a function to wrap 'case' which I could fmap onto a monadic value like 'getArgs'.
08:50:54 <BeardedCoder> amf: IMO, you should start with do sugar to understand this.
08:51:50 <frerich> Oh, duh, it only now occurs to me that I could have a separate function which pattern-matches on its arguments instead of a case, and then fmap that...
08:52:34 <Twey> frerich: There's the LambdaCase extension: a >>= \case Foo -> …
08:52:46 <frerich> Twey: Ah! That looks good!
08:53:07 <Twey> frerich: But yes, quite often you end up matching on Maybe or Bool or something, and so long as your branches are short, the appropriate eliminator function is generally nicer
08:53:32 <Twey> That said, I like LambdaCase a lot.  ☺
08:53:50 <frerich> Yeah, It looks pretty! I'll start using that I think :-)
08:53:57 <frerich> Twey: Thanks for pointing that out! :-)
08:55:15 <Twey> frerich: If you're using lens (or don't mind writing a utility combinator) you can also write stuff like  foo <&> \case -> …  for Functors
08:55:34 <Twey> (where (<&>) = flip (<$>))
08:56:00 <joshc> for simple tools, if I'm just ensuring the correct number of arguments I'll just use a pattern match on the left hand side of '<-' (knowing this involves 'fail' which is taboo in some circles): do { (x:y:[]) <- getArgs; do_something x y }
08:56:10 <yesthisisuser> amf: I am not sure if mapM_ is not more convenient: query_ conn "select id, name from employee" >>= mapM_ (\row -> print (row :: (Int, Text)))
08:56:45 <yesthisisuser> or I guess in that case "fold" is a better option
08:57:12 <Twey> joshc: For small things that take arguments, I often end up with: main = getArgs >>= run; run [x, y] = doSomething x y; run _ = error "Wrong arguments"
08:57:16 <yesthisisuser> i.e., the fold defined by postgresql-simple
08:57:58 <Twey> joshc: Especially nice when combined with ViewPatterns
08:59:37 <joshc> Twey: yep, only slightly more verbose, but at least provides a decipherable error!
09:03:25 <Xeironis> Ah, it appears that the flag -w does what I wanted
09:06:26 <amf> i still dont understand it :( http://lpaste.net/5786777727604359168
09:09:19 <frerich> amf: The second error means that the "query_" function expects a "Connection" value as its first argment, but "connect getConn" returns an "IO Connection", i.e. an action which when executed yields a "Connection" value. To fix this, try writing 'conn <- connect getConn' and then 'query_ conn ...'
09:09:31 <Twey> Debugging space leaks makes me sad.  ☹
09:11:19 <Twey> amf: query_ (connect getConn) "SELECT id, comment, author FROM logs ORDER BY updated LIMIT 10"  has type  IO a  for some a, mapM_ (\row -> toitem (row :: (Int, T.Text, T.Text)))  has type  MarkupM b  for some b
09:12:03 <Twey> amf: You probably want to lift it into the IO monad somehow, depending on what a ServerPart is
09:12:38 <Twey> amf: Oh, and the other error is saying that  connect getConn  is an IO value, so you need to do something like: connect getConn >>= flip query_ "SELECT id, comment, author FROM logs ORDER BY updated LIMIT 10" >>= …
09:13:10 <Twey> amf: Where's ‘template’ from?
09:14:06 <amf> Twey: template is my custom happstack function with does all the html construction
09:14:25 <amf> i got it working outside of happstack and blaze, so i know it can auth and get data
09:15:42 <yesthisisuser> start from something simple in the IO monad, and build from there
09:15:43 <yesthisisuser> http://lpaste.net/109754
09:16:13 <Twey> amf: What's its type?
09:16:55 <amf> Twey: template :: T.Text -> Html -> Response
09:18:33 <amf> yesthisisuser: i was able to get an example like that working outside of the web framework (happstack)
09:19:35 <Twey> amf: http://lpaste.net/5786777727604359168
09:19:40 <Twey> Probably something like this
09:20:36 <Twey> amf: Uh, you might need  liftIO . flip query_ …
09:21:35 <slack1256> Is my idea of archlinux package for haskell are built without profiling?
09:21:42 <slack1256> *or
09:22:57 <amf> Twey: yep that was it, thank you! that example should help me actually understand whats happening now!
09:23:59 <Twey> amf: No problem
09:30:19 <nitrix> Twey: You're a haskeller?
09:30:51 <nitrix> Heh, small world.
09:41:10 <NikolajK> >map not []
09:41:49 <NikolajK> why would that be [] - is that hardcoded or derived?
09:42:09 <ReinH> @src map
09:42:09 <lambdabot> map _ []     = []
09:42:09 <lambdabot> map f (x:xs) = f x : map f xs
09:42:22 <ReinH> Yes, it's hard coded in the definition of map.
09:42:36 <{AS}> @src fmap
09:42:36 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:42:54 <NikolajK> ah, I was concentrating on "not".
09:43:14 <NikolajK> got the question form a SE question asking about why and [] isn't the same as or [].
09:43:54 <ReinH> Because `and' and `or' are monoids, and they have different identity elements
09:44:09 <ReinH> er, are monoidal folds
09:44:10 <NikolajK> I mean I read that thread, thx ;)
09:44:14 <ReinH> :)
09:44:25 <NikolajK> can't resist, hu
09:44:35 <ReinH> it's an interesting question
09:44:40 <NikolajK> it is
09:45:14 <ReinH> like "why is Bool an instance of Ord?"
09:45:23 <NikolajK> why
09:45:33 <merijn> "Because it's convenient and we could" :p
09:46:04 <NikolajK> because Zorns lemma :P
09:46:16 <merijn> Although, arguably also because Bool is a degenerate case of Heyting algebras, implying a partial order on them in which False is less than True
09:46:24 <ReinH> because {True,False} is a boolean algebra, which means it's a complemented distributive lattice, which means it has an ordering
09:46:39 <ReinH> (ignoring bottom, per usual)
09:46:40 * merijn said something smart \o/
09:46:45 <ReinH> merijn: heh :)
09:47:07 <NikolajK> that's actually a good reason
09:47:09 <ReinH> We usually take False to be bottom and True to be top
09:47:24 <ReinH> NikolajK: indeed :)
09:48:20 <NikolajK> (I should have said "because of the well-ordiering theorem", that would have been less obscure)
09:48:44 <NikolajK> do you guys know Paul Taylor?
09:48:44 <ReinH> NikolajK: I thought of the question because it nicely shows that `and' and `or' are dual :)
09:49:27 <NikolajK> or let me get at it differently - how many people use "Set a" in their code?
09:49:47 <ReinH> NikolajK: I'm sure people use it for efficient member checks
09:49:57 <NikolajK> okay
09:50:02 <NikolajK> is that the best implementation?
09:50:22 <ReinH> of efficient member checks?
09:50:27 <ReinH> it depends on what you mean by "best", I suppose
09:52:12 <NikolajK> my reasoning is this: if people use it, it's either because they don't want to code it themselves or because their know the implementation is better than what they'd do
09:52:36 <ReinH> it's a pretty efficient implementation, as is Data.Map
09:53:08 <NikolajK> has anybody looked at what the whole of Set a correpsonds to, in terms of set theories?
09:53:10 <ReinH> almost certainly more efficient than what you'd write yourself
09:53:27 <NikolajK> it's all constructive right, so Kripke something
09:53:36 <c_wraith> though unordered-containers variants are more efficient on many workloads.
09:53:42 <ReinH> I'm not sure, but probably not very much given the Ord constraint
09:54:13 <NikolajK> what is the problem with Ord?
09:54:31 <ReinH> Well, it restricts you to totally ordered sets
09:55:27 <NikolajK> yeah, so well-ordering again.
09:55:48 <NikolajK> I don't see that as a restriction per se
09:55:54 <NikolajK> http://en.wikipedia.org/wiki/Well-ordering_theorem
09:55:59 <c_wraith> fortunately, computers have a tendency to require you to work with countable sets
09:56:20 <c_wraith> And being countable implies a well-ordering
09:56:43 <c_wraith> without having to assert it as an axiom!
09:56:52 <NikolajK> yeah, so since there is no uncountable set, nobody would resonably reject choice and hence you have well ordering / Ord
09:57:13 <ReinH> I'm just suggesting that it restricts you to a particularly boring part of set theory ;)
09:58:23 <NikolajK> (tbh I don't consider R to be a good set)
09:58:56 <NikolajK> Set doesn't see doubled instances, does it?
09:59:22 <ReinH> Although total orders are related to simplex categories, which are important
09:59:24 <dolio> Ord doesn't just require an ordering.
09:59:25 <nitrix> How would be the easiest way to have a Data.Text that is N amount of '*' ?
09:59:32 <dolio> It requires a decidable ordering.
09:59:36 <ReinH> dolio: good point
09:59:44 <quchen> nitrix: Text.replicate?
09:59:49 <merijn> NikolajK: The Set implementation is as efficient as you can be while still purely functional
09:59:58 <nitrix> quchen: thanks
10:00:21 <merijn> NikolajK: i.e. log n queries/inserts, etc.
10:00:24 <NikolajK> Set (Int->Int) takes \n->(n+1)^2 and \n->n^2+2n+1 to be different, right?
10:00:25 <ReinH> (You can tell because it's a log away in big O temms)
10:00:52 <merijn> NikolajK: There is no Ord instance for "Int -> Int", so you can't insert that into a Set
10:01:34 <dolio> And it's really even more restrictive than that.
10:01:38 <NikolajK> ah, I see. Can't you not just make a pseudo Int->Int, which is an Ord instance?
10:02:13 <dolio> There's no Ord for Complex, for instance, because imposing an arbitrary ordering isn't nice enough for Ord.
10:02:27 <ReinH> You can wrap it in a newtype, but you can't write a reasonable Ord instance
10:02:52 <ReinH> other than compare _ _ = EQ, which is useless
10:03:06 <NikolajK> what is nice enough? enumerate the haskell language and evaluate the function codes :)
10:03:11 <dolio> You could write one for Int -> Int, but you wouldn't want to use it.
10:03:17 <merijn> :)
10:03:34 <ReinH> oh yeah you could just write it for Int -> Int
10:03:50 <dolio> It's better that it doesn't exist, really.
10:03:50 <ReinH> there's obv no conflicting instance
10:04:31 <ReinH> well yes
10:04:32 <monochrom> I don't understand what would "instance Ord (Int -> Int)" do, specifically.
10:04:39 <ReinH> merijn: be stupid
10:04:46 <ReinH> er monochrom ^
10:04:47 <quchen> monochrom: This! http://lpaste.net/109757
10:04:53 <dolio> monochrom: Start testing point-wise at minBound.
10:04:58 <NikolajK> here's my semicanonical suggestion: order by value at 0, if equal consider the value at 1, then -1, then 2, etc. :)
10:05:08 <ReinH> quchen: stahp :p
10:05:37 <monochrom> ok I see. it will be slow, but it will be well-defined.
10:05:42 <ReinH> ugh
10:05:46 <ReinH> yep
10:05:49 <merijn> monochrom: Presumably it would do what my earlier instance of "instance (Bounded a, Ord b) => Ord (a -> b)" did :D
10:05:53 <NikolajK> monochrom: we could take it as a Set
10:05:56 <ReinH> Please feel free to not do this
10:06:07 <merijn> Well
10:06:10 <quchen> merijn: Needs Enum too, no?
10:06:19 <merijn> quchen: I guess, yeah
10:06:46 <quchen> Anyway, there are some types that should not be Ord but it's useful anyway. For example, having a Set of Complex might be useful.
10:06:48 <NikolajK> > 17:03:51 UTC wat
10:06:50 <lambdabot>  Not in scope: data constructor ‘UTC’Not in scope: ‘wat’
10:06:50 <lambdabot>  Perhaps you meant one of these:
10:06:50 <lambdabot>    ‘cat’ (imported from Text.PrettyPrint.HughesPJ),
10:06:50 <lambdabot>    ‘at’ (imported from Control.Lens)
10:07:07 <alket> Hi , im new to haskell and I use kubuntu , what IDE do you suggest ?
10:07:14 <monochrom> yeah Complex is pretty easy
10:07:36 <quchen> Right, Ord Complex violates taste in the worst case.
10:07:56 <quchen> Int -> Int on the other hand is pretty hard to justify :-)
10:08:13 <dolio> Sometimes it's unfortunate that there's only one Ord.
10:08:40 <dolio> Like, Ord with a numeric type is expected to be the 'usual' ordering on things like real numbers.
10:08:58 <dolio> So it doesn't make sense for Complex, which isn't totally ordered in the usual way.
10:09:10 <dolio> But it'd still be handy to put them in a map or set.
10:09:30 <dolio> I guess Hashable is usable for that.
10:09:38 <NikolajK> what is Map again?
10:09:43 <NikolajK> Data.Map
10:09:51 <quchen> Map () is Set
10:09:59 <merijn> alket: I'd suggest whichever editor you're already familiar with
10:10:01 <monochrom> at this point, I suggest using a greater evil to solve a smaller evil. there is an unsafeCoerce trick to help you specify dictionaries, that is, different dictionaries at a different places :)
10:10:04 <merijn> quchen: No it's not
10:10:05 <quchen> "Map k a" associates keys with type k to values with type a
10:10:07 <zereraz> hello, what is the meaning of m0 in error "Couldn't match expected type `Int' with actual type `m0 Int'"
10:10:13 <merijn> quchen: "Map () a" is Maybe
10:10:21 <merijn> zereraz: A type variable
10:10:23 <quchen> merijn: Oh, flipped, woops
10:10:34 <zereraz> merijn: what does that mean
10:10:35 <quchen> Map a () is Set a
10:10:39 <dolio> monochrom: That sounds great if you want your maps and sets to not work. :)
10:10:56 <zereraz> merijn: any variable of type Int?
10:11:10 <merijn> zereraz: It means there is an "Int" somewhere, where type inference suggests it should be "Maybe Int", "[Int]", etc.
10:11:16 <dolio> Also it requires you to program everything in some nested scope, which Haskell is not good at.
10:11:19 <merijn> zereraz: Put youre code + error on lpaste?
10:11:48 <zereraz> merijn: I am still debugging if I am not able to solve it then I will ask here
10:11:53 <merijn> alket: Most people here use vim/emacs, then there's some people using Sublime, EclipseFP and a variety of other editors
10:11:56 <zereraz> merijn: I was just curious as to what it means
10:12:15 <alket> merijn: oh it has Eclipse , thanks
10:12:31 <merijn> :t let f :: a -> m a; f x = x in f
10:12:31 <NikolajK> so for member queries you'd want to use Set. e.g. for graph programs?
10:12:33 <lambdabot>     Couldn't match expected type ‘m1 a1’ with actual type ‘a1’
10:12:33 <lambdabot>       ‘a1’ is a rigid type variable bound by
10:12:33 <lambdabot>            the type signature for f :: a1 -> m1 a1 at <interactive>:1:10
10:13:45 <merijn> zereraz: See, my function type claims to return an "m a" (for some value of m), but I'm accidentally returning an 'a', so it's complaining it can't match 'm1 a1' with 'a1' (the numbers are due to type inference introducing extra type variables during checking, causing some to be renamed)
10:14:08 <NikolajK> what made you guys go for Haskell in the first place?
10:14:19 <merijn> :t let f :: Monad m => a -> m a; f x = return x in f -- And this fixes it
10:14:21 <lambdabot> Monad m => a -> m a
10:14:42 <zereraz> merijn: how does it know what type my function returns
10:14:57 <zereraz> merijn: I have specified that it should return an Int
10:15:18 <merijn> zereraz: Right, so it's saying that whatever you wrote doesn't match the type you wrote :)
10:15:45 <merijn> zereraz: "You claimed this would return Int, but after type checking your code I found it returns "m0 Int"
10:16:23 <merijn> zereraz: The "error translation" is: "Couldn't match expected type `Int'" -> "You told me this would be Int"
10:16:24 <zereraz> merijn: so it ran my code while interpreting it
10:16:44 <merijn> zereraz: "with actual type `m0 Int'"" -> "but according to me it's m0 Int"
10:16:52 <merijn> zereraz: No
10:16:56 <NikolajK> ReinH: I've just been told to watch a video on the youtube channel "closer to the truth". Another evidence that Bool is an Ord
10:17:07 <enthropy> is there a way to make HPC not care about "Proxy" and "otherwise"?
10:17:09 <ReinH> o_O
10:17:09 <merijn> zereraz: Type checking is a compile time thing, it happens without ever running the code
10:17:35 <zereraz> merijn: so it puts int in my function and tries to see the output?
10:17:43 <merijn> zereraz: No
10:17:46 <zereraz> merijn: as my function accepts ints
10:17:53 <zereraz> merijn:  http://lpaste.net/109759
10:18:15 <quchen> Types are similar to physical units, they tell you what things describe. Your type error is similar to writing  "10 m/s * 5 s = ? s". You don't need to calculate anything to see this equation is false. In other words, typechecking does not require your program to be run.
10:18:20 <merijn> zereraz: Type checking never requires anything to be run, it's just a game of "fill the holes using the type checking algorithm"
10:18:21 <ReinH> :t return
10:18:23 <lambdabot> Monad m => a -> m a
10:18:29 <ReinH> zereraz: return n can't ever be an Int
10:18:35 <zereraz> merijn: oh its an algorithm
10:18:39 <ReinH> zereraz: you don't need to use return like you sometimes do in imperative langauges
10:18:51 <zereraz> ReinH: damn, I forgot
10:18:52 <merijn> zereraz: For example, if you have a function "f :: Int -> Int" and "x :: Int", then the type checker knows that "f x :: Int"
10:18:56 <ReinH> it doesn't mean "return this value from the function"
10:19:03 <zereraz> ReinH: got it
10:19:14 <zereraz> merijn: ok understood
10:19:17 <zereraz> thanks
10:19:26 <ReinH> zereraz: common mistake made possible by calling it "return", not really your fault ;)
10:20:10 <zereraz> ReinH: I haven't written in like a week, and was doing c++ so I forgot.
10:20:13 <josephle> I hear the rust compiler shames you for using return, if negative reinforcement is more your thing :P
10:20:21 <zereraz> ReinH: thanks
10:20:28 <zereraz> merijn: thanks
10:21:01 <zereraz> there seems to be error here aswell else gcd' $ (m`mod`n) n
10:21:17 <zereraz> will m`mod`n give int
10:21:22 <ReinH> :t mod
10:21:24 <lambdabot> Integral a => a -> a -> a
10:21:35 <ReinH> :t mod `asAppliedTo` (1 :: Int)
10:21:36 <lambdabot> Int -> Int -> Int
10:21:39 <ReinH> Yes.
10:21:51 <zereraz> so that line is correct?
10:21:56 <quchen> gcd' $ (m`mod`n) n  ===   gcd' (m`mod`n) n  ===   (gcd' (m`mod`n)) n
10:21:59 <ReinH> What does the compiler say?
10:22:15 <quchen> Wait.
10:22:16 <quchen> No.
10:22:19 <merijn> Why would it be an error?
10:22:22 <quchen> Ignore that. Bad quchen.
10:22:31 <zereraz> Couldn't match expected type `Int' with actual type `Int -> Int'
10:22:36 <josephle> gcd' $ (m`mod`n) n == gcd` ((m`mod`n) n)
10:22:37 <quchen> gcd' $ (m`mod`n) n  ===   gcd' ((m`mod`n) n)   -- This way, zereraz
10:22:38 <josephle> which is a type error
10:22:51 <zrho> You apply (m `mod` n) to n.
10:22:52 <merijn> oh, duh
10:22:56 <zereraz> quchen: ok
10:23:04 <zereraz> oh
10:23:11 <zereraz> got it!
10:23:28 <zereraz> how do I prevent that
10:23:30 <merijn> zereraz: Another way to write it (whoo! guards!): http://lpaste.net/109759
10:23:35 <zrho> without the $
10:23:46 <zereraz> zrho: so $ was the problem
10:24:03 <zereraz> oh it worked
10:24:06 <zereraz> thanks everyone
10:24:21 <ReinH> merijn: another way: just pattern match on 0
10:24:53 <merijn> Oh, true
10:24:54 <zereraz> ReinH: yeah I could do that too
10:25:15 <ReinH> gcd 0 n = n; gcd m n = gcn (mod m n) n
10:25:19 <zrho> the $ essentially starts a new "application list"; (m ´mod` n) becomes the head of it then. without it, gcd' becomes the head, and both expressions are arguments then.
10:25:21 <zereraz> yeah
10:25:32 <zereraz> and is this the way we find gcd right?
10:27:16 <zrho> yes, I think so. try it on small examples for extra confidence in it
10:27:33 <zrho> Hm... conduit uses a Pipe type internally, and newtype wraps it as ConduitM. Why?
10:28:05 <Fuuzetsu> luite: are you going to do the 2.15 bump in your patches or what is happening there?
10:28:57 <ReinH> Euclid's algorithm is:
10:29:02 <ReinH> a > b implies: gcd(a, b) = gcd(b, a mod b); gcd(a, 0) = a
10:30:07 <dolio> I feel like that code is off.
10:30:09 <Fuuzetsu> oh hm, got confused for a minute and thought ‘what the hell is ReinH doing in this channel’
10:30:16 <ReinH> Fuuzetsu: :p
10:30:32 <ReinH> dolio: mine?
10:30:39 <dolio> Yeah.
10:30:43 <quchen> ?src gcd
10:30:43 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
10:30:44 <lambdabot> gcd x y = gcd' (abs x) (abs y)
10:30:44 <lambdabot>    where gcd' a 0 = a
10:30:44 <lambdabot>          gcd' a b = gcd' b (a `rem` b)
10:30:49 <dolio> Well, certainly gcn is undefined.
10:31:06 <ReinH> dolio: http://en.wikipedia.org/wiki/Euclidean_algorithm
10:31:12 <dolio> I think the recursive arguments are supposed to be shuffled around, too, though.
10:31:26 <dolio> I meant the line before that.
10:31:36 <ReinH> oh yeah, that one's wrong
10:31:41 <dolio> Ok(f <$> a) ((\f b c -> f b c) <$> b <*> c).
10:31:44 <ReinH> which is why I gave the actual algorithm
10:31:45 <dolio> Whoops.
10:32:36 <quchen> ReinH: Your algorithm doesn't terminate because you didn't flip the args
10:32:43 <ReinH> quchen: yep
10:32:57 <quchen> Argh I see you already noticed.
10:33:01 <ReinH> There's a mod version and a rem version (and the rem version can be replaced by a subtract version) http://en.wikipedia.org/wiki/Euclidean_algorithm
10:33:03 <quchen> My selective reading is strong today.
10:33:36 <ReinH> quchen: np
10:34:13 <luite> Fuuzetsu: oh i didn't know if more changes from my end were needed
10:34:37 <ReinH> Fuuzetsu: heh which channel did you think you were in?
10:38:53 <Fuuzetsu> ReinH: not this one ;)
10:38:57 <ReinH> heh
10:39:13 <Fuuzetsu> luite: well, you're the one lobbying for not breaking the API in minor version
10:41:00 <luite> Fuuzetsu: whether to bump is mostly a matter of preference, i don't have a strong preference for either way, but i think that if released as 2.14.4 it should include the library. you're the maintainers so you can make the choice, but if you need another opinion to get out of an impasse i can give one :)
10:42:40 <kuribas> When I try to compiler ghcjs, I get the error: setup-Cabal-1.18.1.3-x86_64-linux-ghc-7.8.3: Error: Could not find module: Data.Aeson with any suffix: ["dyn_hi"] in the search path: ["dist/build"]
10:43:06 <Fuuzetsu> I'm just lazy ;(
10:43:37 <tm512> how big is a normal install of GHC?
10:43:52 <tm512> Arch Linux's package for it is almost 800MB
10:43:55 <luite> kuribas: you probably have some broken packages where the dynamic library is missing
10:44:03 <tm512> and I think that's pretty crazy
10:44:03 <Fuuzetsu> tm512: then about that big for you
10:44:23 <luite> kuribas: did you install some things with a very old cabal?
10:44:32 <merijn> tm512: Is that platform or GHC?
10:44:38 <tm512> I don't know
10:44:41 <kuribas> luite: I reinstalled the whole package list.
10:44:43 <Fuuzetsu> tm512: the binary release of GHC is ~120MB tops
10:44:53 <kuyatzu> tm512: look at the Provides list
10:44:59 <Fuuzetsu> apparently 200MB on Windows
10:45:05 <kuyatzu> tm512: pacman -Qi ghc
10:45:05 <merijn> tm512: https://stackoverflow.com/questions/4858585/why-is-ghc-so-large-big
10:45:17 <glguy> The binary release expands to around 800MB
10:45:19 <luite> kuribas: this is when compiling ghcjs itself, right, not when running ghcjs-boot or compiling things with ghcjs?
10:45:33 <kuribas> luite: no, when I compile ghcjs
10:45:34 <glguy> 729M on OS X
10:45:51 <kuribas> luite: cabal install ./ghcjs
10:45:56 <luite> kuribas: did you reset your user package db?
10:46:17 <kuribas> luite: hm... maybe not
10:46:29 <kuribas> luite: I just deleted the .ghc directory
10:47:00 <tm512> merijn: ah, alright
10:47:02 <NikolajK> @djinn: Ord a => a -> Bool
10:47:03 <lambdabot> Error: Class not found: Ord
10:47:14 <luite> kuribas: that should be enough. you didn't supply any specific --enable-executable-dynamic or similar things whn building ghcjs?
10:47:54 <kuribas> luite: I have share=True in .cabal/setup
10:48:06 <kuribas> .cabal/config
10:48:20 <tm512> what binary is cabal? It says it provides it
10:49:07 <merijn> tm512: Can you clarify what "it" refers too? :)
10:49:20 <tm512> it being the ghc package here
10:49:29 <tm512> provides "haskell-cabal=1.18.1.3"
10:49:34 <merijn> tm512: cabal is haskell's dependency tracking/build tool
10:49:36 <ReinH> NikolajK: anyway it would probably just have provided const True or something ;)
10:49:41 <ReinH> @djinn a -> Bool
10:49:41 <lambdabot> f _ = False
10:49:49 <ReinH> ok, const False
10:50:03 <merijn> tm512: It tracks installed libraries and builds/fetches required dependencies from hackage
10:50:06 <tm512> merijn: i'm aware. I dunno what binary it installed it to
10:50:10 <luite> Fuuzetsu: if you want an opinion, i'd probably say bump to 2.15 now, keep the directory layout the same for now, with, and move the lib to haddock-api when fixing things for the ghc 7.10 release
10:50:18 <merijn> tm512: Oh, just "cabal" :)
10:50:29 <NikolajK> @djinn why -> Bool
10:50:30 <lambdabot> f _ = False
10:50:53 <NikolajK> @djinn freeWill -> Bool
10:50:54 <lambdabot> f _ = False
10:51:44 <NikolajK> would be interesting to know why he chooses False before True.
10:51:48 <tm512> there's to cabal binary in here...
10:51:52 <dolio> No, the cabal binary is not owned by the haskell-cabal package.
10:52:03 <dolio> haskell-cabal is the cabal libraries.
10:52:07 <haasn> @djinn FreeWill
10:52:08 <lambdabot> f = None
10:52:12 <dolio> The cabal binary is cabal-install.
10:52:30 <haasn> NikolajK: data Bool = False | True
10:52:32 <tm512> ah
10:52:34 <haasn> False is the ‘first’ constructor
10:52:58 <merijn> oh, that's silly
10:53:08 <NikolajK> fundamental questions, and the answer is determined by what some old dude felt should come first like 20 years ago
10:53:09 <merijn> Why would they not install cabal-install with ghc?
10:53:19 <haasn> Not everybody wants cabal-install
10:53:28 <dolio> cabal-install upgrades more frequently than ghc.
10:53:49 <merijn> dolio: Doesn't mean their package thingy can't keep switching to newer cabal-install's
10:53:51 <haasn> NikolajK: There's a non-trivial reason it's defined this order
10:54:00 <luite> kuribas: dynamically linked programs should work though, i wonder if this is a cabal bug
10:54:10 <kuribas> luite: I also have profiling: True
10:54:12 <haasn> NikolajK: Constructor order affects the behavior of auto-derived instances such as Ord and Enum
10:54:19 <merijn> haasn: We already covered boolean and heyting algebra's earlier while discussing why "False < True"
10:54:26 <haasn> > (fromEnum False, False < True, [False..])
10:54:28 <lambdabot>  <hint>:1:40: parse error on input ‘]’
10:54:34 <haasn> > (fromEnum False, False < True, [False ..])
10:54:36 <lambdabot>  (0,True,[False,True])
10:55:00 <haasn> merijn: Right; that's going one step further and answering the question of why we want False < True, though
10:55:07 <luite> kuribas: that will not work, ghcjs cannot boot when the excutable is built with profiling. library profiling is ok (that just installs an extra version of the lib, there is still a non-profiled one)
10:55:15 <haasn> I was not even going that far
10:55:24 <ReinH> haasn: that doesn't answer the question, it just changes the question to "Why is False the first constructor?" :p
10:55:40 <luite> kuribas: you can still build ghcjs with profiling, but template haskell won't work due to a limitation in the ghc api
10:56:15 <kuribas> luite: ok, so I turn off profiling just to build ghcjs?
10:56:42 <tm512> if I had to compile some haskell code in a space-constrained environment, could I build a stripped down GHC easily?
10:56:44 <luite> kuribas: so first install a non-profiled ghcjs, then run ghcjs-boot, then reinstall the same vrsion with profiling enabled for investigating ghcjs performance problems
10:57:04 <kuribas> luite: ok, I'll try that
10:57:11 <luite> kuribas: yah you probably want a non-profiled executabl for normal use anyway since a profiled one is many times slower
10:57:28 <tm512> i.e. only static libs
10:57:35 <dmwit> tm512: space-constrained = disk space or RAM?
10:57:43 <dmwit> For RAM, I've heard switching to gold can help.
10:57:49 <luite> kuribas: you can install with --disable-executable-profiling
10:57:49 <dmwit> For disk, I haven't heard of any efforts.
10:57:56 <dolio> If your environment is so space constrained that it can't afford 800MB, is it capable of compiling Haskell code in a reasonable amount of time?
10:57:58 <luite> kuribas: to just disable for this install
10:58:10 <monochrom> for disk, use a smaller haskell compiler such as jhc :)
10:58:20 <kuribas> luite: I have executable-profiling commented out in .config, but library-profiling on
10:58:42 <luite> kuribas: oh ok, then it's ok, you should be fine then
10:59:56 <tm512> dmwit: probably. also just in general having to install 800mb of bloat on anything I want to compile on is a bit bothersome to me
11:00:05 <tm512> and it is bloat
11:00:07 <kuribas> luite: hm, maybe I see the problem, I am using /usr/local/bin/cabal, not ~/.cabal/bin/cabal
11:00:49 <NikolajK> is there a  way to classify all possible monads for a given Algebraic data type. List, say
11:00:49 <tm512> I guess it includes several builds of the same compiler, and same libraries, in various linking/profiling configurations
11:01:00 <NikolajK> there are two for []. Why not more
11:01:15 <dmwit> tm512: If "probably" is intended to answer my question, I don't understand your answer.
11:01:31 <monochrom> you may be able to build GHC yourself and disable profiling. that saves a lot of disk space.
11:01:50 <dolio> Some distributions separate profiling stuff, I think.
11:02:03 <dmwit> NikolajK: There are two monads on []?
11:02:04 <tm512> dmwit: probably, as in it will probably be capable of compiling stuff in time
11:02:05 <luite> kuribas: yeah you were using 1.18, which won't work for ghcjs-boot, but it should still be possible to install ghcjs with it. the updated 1.21 branch is only needed for building with ghcjs
11:02:24 <dmwit> tm512: I never mentioned time.
11:02:36 <monochrom> but you should also consider jhc and ajhc. and even hugs.
11:02:48 <dmwit> tm512: Neither did anybody else, that I saw.
11:03:01 <dolio> I brought it up.
11:03:12 <dolio> I wouldn't compile Haskell code on a phone, probably.
11:03:24 <dmwit> ah, maybe just a misnick, then
11:03:36 <dmwit> I see you did mention time now. My eye skipped it... twice. Dunno why.
11:03:56 <monochrom> this is why you need to read everything 3 times :)
11:04:06 <tm512> yea, and I just saw a starting d and the same nick length, lol
11:04:15 <NikolajK> dmwit: or Applicative
11:04:29 <NikolajK> "The list type constructor [] can actually be made an instance of Applicative in two ways; essentially, it comes down to whether we want to think of lists as ordered collections of elements, or as contexts representing multiple results of a nondeterministic computation"
11:04:36 <monochrom> I use proportional font. dolio and dmwit have different lengths :)
11:05:21 <monochrom> since you don't paste or read multi-line aligned code in IRC, there is no point using fixed-width fonts.
11:05:30 <dmwit> NikolajK: I can't think of anything off the top of my head about enumerating algebraic structures on particular types.
11:05:41 <dmwit> or counting or anything like that
11:05:44 <monochrom> and ASCII art is pretty much a lost art, too
11:05:49 <dfeuer_> @src take
11:05:50 <lambdabot> take n _      | n <= 0 = []
11:05:50 <lambdabot> take _ []              = []
11:05:50 <lambdabot> take n (x:xs)          = x : take (n-1) xs
11:05:54 <josephle> you can also use a colored nick script, and hope you get lucky with the color distribution
11:05:55 <dolio> There's one point, at least.
11:06:05 <nateb> Hi.  I saw in cabal's "developing packages" doc that you can access the version field using the Paths_pkgname module.  Is there a way to access the cabal "synopsis" or "author" fields in my application?
11:06:44 <tm512> is jhc capable of using libraries installed with cabal?
11:07:02 <dmwit> I would be shocked if it wasn't.
11:07:15 <dolio> I think cabal supports jhc.
11:07:23 <dmwit> Perhaps you are asking whether jhc is capable of using libraries built with ghc...?
11:07:29 <dmwit> If that's the question, then probably no.
11:07:36 <dolio> The harder question is whether the libraries you want to use are able to be used on jhc.
11:09:39 <luite> kuribas: i'm going to do some work, if you get stuck later on you can ask in #ghcjs, usually there are some people there, and i usually read the scrollback to answer questions later
11:10:08 <kuribas> luite: ok, thanks.  I hope it works now that I replaced the cabal binary.
11:10:41 <NikolajK> why is there a foldr1, which is just foldr with one unnecessary setting of b to a?
11:11:01 <Xeironis> :t foldr
11:11:03 <lambdabot> (a -> b -> b) -> b -> [a] -> b
11:11:06 <Xeironis> :t foldr1
11:11:07 <lambdabot> (a -> a -> a) -> [a] -> a
11:11:20 <Xeironis> You don't have to give it an initial value
11:11:25 <Xeironis> it has on argument less
11:11:46 <NikolajK> k I guess that's plugging in the monoid unit, right
11:11:53 <merijn> tm512: THe usual workflow is to just build stuff on a single build machine and the distribute binaries to the non-beefy machines you wanna run on
11:11:54 <Xeironis> s/one argument less/one argument fewer/
11:11:56 <dolio> What monoid?
11:12:07 <NikolajK> fold    :: Monoid m => t m -> m
11:12:16 <Xeironis> No
11:12:26 <Xeironis> It's using the first element of the list
11:12:27 <merijn> NikolajK: No, it uses the first values of the list and crashes if it's empty
11:12:38 <merijn> > foldr1 (&&) []
11:12:39 <lambdabot>  *Exception: Prelude.foldr1: empty list
11:13:04 <dolio> It doesn't use the first element, I think.
11:13:13 <merijn> dolio: Well, foldr uses the last, sure
11:13:13 <tm512> how about cross-compiling?
11:13:20 <NikolajK> shouldn't it use all?
11:13:29 <solidus-river> > last [1,2,3,4]
11:13:30 <NikolajK> > foldr1 (&&) [True,False]
11:13:31 <lambdabot>  4
11:13:32 <lambdabot>  False
11:13:35 <Xeironis> NikolajK: The *initial value* is the first (last) element
11:13:37 <merijn> tm512: It's being worked on, there's some rudimentary support, but it's getting better
11:13:50 <merijn> tm512: THere's lots of work to cross-compile for ARM to run on android/iOS
11:13:57 <Xeironis> NikolajK: After that, it uses the function to combine it with all the other elements one after the other
11:14:29 <merijn> tm512: It works (http://keera.co.uk/blog/2014/08/13/most-inspiring-green-screen-you-will-ever-see/), but it's not very polished yet
11:14:36 <dolio> You basically have to build a separate GHC for cross compiling right now.
11:14:56 <Xeironis> So   foldr 4 (+) [1,2,3] == foldr1 (+) [1,2,3,4], I think
11:15:15 <NikolajK> should I think of type classes as putting Venn diagrams into Obj_{Hask}?
11:15:20 <merijn> Although, to be fair, cross-compiling with gcc doesn't feel very polished yet either :)
11:15:40 <solidus-river> > last [1..]
11:15:44 <lambdabot>  mueval-core: Time limit exceeded
11:15:44 * solidus-river teeheehee
11:16:50 <NikolajK> >P==NP
11:16:58 <dmwit> NikolajK: Venn diagrams...?
11:17:02 <TheKing44> how does one get haskell platform 2014 on Linux?
11:17:10 <TheKing44> such as Ubuntu?
11:17:23 <NikolajK> specifying subsets - which might overlap
11:17:52 <dmwit> NikolajK: Better to think of it a class. That's why it's called that.
11:18:03 <dmwit> Sets are scary.
11:18:25 <oleo> lol
11:18:29 <NikolajK> how is it more a class than a set
11:18:36 <Xeironis> TheKing44: I think you should be able to run sudo apt-get install haskell-platform
11:18:37 <NikolajK> or the other way around
11:18:40 <haasn> but is it a proper class?
11:18:41 <NikolajK> it's very small in any case
11:18:51 <Xeironis> TheKing44: Or is that an older version?
11:18:55 <dmwit> Not at all.
11:19:03 <dmwit> instance Foo a does not declare a small set.
11:19:08 <TheKing44> yep
11:19:16 <dfeuer_> TheKing44, you install it. You probably have to download it from the Haskell Platform website.
11:19:26 <dmwit> err
11:19:34 <TheKing44> dfeuer_ its old
11:19:36 <dmwit> I should be a bit careful, since "small" is actually a technical term.
11:19:38 <dfeuer_> Unfortunately, it will be a while before most of the distros get it.
11:19:39 <NikolajK> over which logic? irl the language you use is countable
11:19:43 <Xeironis> TheKing44: There are generic linux libraries on http://www.haskell.org/platform/linux.html
11:19:57 <Xeironis> TheKing44: They are up to date, IIRc
11:20:22 <dmwit> What is this IRL nonsense.
11:20:27 <dmwit> Let's have none of that.
11:20:29 <dmwit> ;-)
11:20:35 <NikolajK> sure, in princple the set of subsets of Int isn't, but in Haskell you can't reason about the non-definable sets, can you?
11:20:43 <dfeuer_> Unfortunately, the binaries seem to be only for Debian-style systems.
11:20:44 <TheKing44> http://packages.ubuntu.com/trusty/haskell-platform is old
11:21:04 <Xeironis> TheKing44: Yes, but look at the download under "generic linux libraries" on http://www.haskell.org/platform/linux.html
11:21:20 <Xeironis> sorry, binaries
11:21:21 <dmwit> I don't understand that question. "set of subsets of Int"? what does "reason" mean in this context? "non-definable"?
11:21:32 <dolio> All the sets in set theory are countable, obviously.
11:21:38 <dolio> But they don't look that way from the inside.
11:22:02 <dfeuer_> Xeironis, I looked there. Success reported with Mint, Ubuntu, and more Ubuntu. Failure reported with Fedora. Fedora's official repository will be stuck in long-time-ago-land till next year or something.
11:22:07 <NikolajK> you say Haskell classes aren't small. elaborate
11:22:35 <Xeironis> dfeuer_: Yeah, I guess the only option there is to compile it from source
11:23:05 <NikolajK> if you consider [Int], then its terms are not enumarable - so uncountable in principle. But in Haskell you can't talk about the complement of [Int] w.r.t to the enumerable ones - I assume
11:23:14 <NikolajK> so in effect, the class is small
11:23:28 <monochrom> wait, do you want set or do you want list? [Int] is not a set type.
11:23:32 <dfeuer_> NikolajK, when you dig into set theory, it turns out that seemingly simple concepts like "countable" are not so simple aftr all.
11:23:53 <NikolajK> dmwit: "non-definable": http://en.wikipedia.org/wiki/Definable_real_number
11:24:03 <TheKing44> dfeuer_ oh, they did in from the mobile version of the site
11:24:13 <TheKing44> that is odd
11:24:17 <dfeuer_> TheKing44, they did what?
11:25:00 <hseg> Lambdabot claims that a >>= \ x -> b >>= \ y -> return (f x y) is equivalent to a >>= (<$> b) . f, but I can't see the equivalence.
11:25:07 <dmwit> Do you believe there is a set containing all Haskell types?
11:25:44 <dfeuer_> I believe there is a ZF set containing all Haskell types.
11:26:11 <merijn> hseg: Well, since you give b as argument >>= it must be in the right monad, right?
11:26:15 <NikolajK> dmwit: depends on what you mean. "irl Haskell types" is anything you could code, and that's enumerable, even
11:26:27 <Xeironis> @src fmap
11:26:28 <lambdabot> Source not found. :(
11:26:44 <merijn> hseg: "a >>= (<$> b) . f" -> "a >>= \x -> f x <$> b"
11:27:38 <dmwit> Oops!
11:27:49 <dmwit> I don't actually understand why a typeclass is called a class and not a set.
11:27:51 <dfeuer_> dmwit, the Haskell types for which a signature can be given certainly form a set in ZF. However, it seems very likely that they don't form any sort of "set" in Haskell, because it seems unlikely that a computer can prove that every inhabited type actually is inhabited.
11:28:05 <dfeuer_> Well, I guess
11:28:08 <dfeuer_> that's invalid.
11:28:09 <dfeuer_> Forget that.
11:28:13 <dfeuer_> HRMMMM
11:28:45 <NikolajK> dmwit: I doubt the name is motivated by math
11:28:48 <dmwit> The usual place where type theory isn't enough is when it comes to polymorphism.
11:28:51 <dmwit> But typeclasses don't do that.
11:28:56 <dmwit> sorry
11:29:04 <dmwit> The usual place where *set* theory isn't enough.
11:29:23 <hseg> merijn: I'm an idiot. Just realized all I need to do is look at the definition of <$> in terms of >>= and return.
11:29:43 <dfeuer_> dmwit, I wouldn't think set theory would have issues unless maybe you were dealing with infinite types.
11:29:51 <NikolajK> If you read "A History of Haskell: Being Lazy With Class" by the founders, they don't seem to be particularly mathy people, in the "but ZFC…" sense.
11:30:13 <NikolajK> rather "hey, lazy types are cool, becuase.., we could use.. to…"
11:30:20 <dmwit> dfeuer_: You'd be wrong. =)
11:30:23 <NikolajK> lazy languages with strong typing*
11:30:32 <dmwit> NikolajK: If I were you, I wouldn't underestimate the mathiness of the Haskell founders.
11:30:53 <dmwit> dfeuer_: (But you'd be in very good company!)
11:31:19 <dfeuer_> dmwit, are you saying there's a proper class of types for which no signature can be given?
11:31:24 <NikolajK> they just always say category is "abstroose" and shit like that, it's offensive
11:31:27 <dmwit> dfeuer_: http://stackoverflow.com/q/10453558/791604
11:31:44 <NikolajK> in talks too
11:32:16 <monochrom> NikolajK, what is your agenda?
11:32:55 <NikolajK> agenda?
11:32:59 <dfeuer_> dmwit, that's an off-hand remark that doesn't say anything.
11:33:01 <monochrom> yes, agenda.
11:33:30 <dmwit> dfeuer_: I agree it is not a proof.
11:33:37 <dmwit> dfeuer_: It is a pointer to where things get hairy only.
11:34:26 <dfeuer_> dmwit, that something needs categorical concepts does not imply that set theory is formally insufficient.
11:34:31 * hseg just realized: The Church isomorphism (forall r . (a -> r) -> r) ~ a is just a statement of the Yoneda lemma
11:34:33 <NikolajK> monchrom: don't know what you mean
11:34:48 <dmwit> dfeuer_: Erm, it's not?
11:34:52 * hackagebot hplayground 0.1.0.3 - a client-side haskell framework that compiles to javascript with the haste compiler  http://hackage.haskell.org/package/hplayground-0.1.0.3 (AlbertoCorona)
11:35:02 <dfeuer_> dmwit, what's not what?
11:35:24 <NikolajK> dmwit: regarding polymorphism: http://i.imgur.com/vAmXL1F.png
11:35:24 <dmwit> dfeuer_: "X needs category theory to be properly described" does not imply "set theory is insufficient"?
11:36:10 <dfeuer_> dmwit, you can fit a lot of category theory inside of set theory. Not all of it, certainly, but a lot. That doesn't mean the set theory will make for a good explanation.
11:36:39 <hseg> dmwit: No. a needs b means that anything less than b won't suffice. However, c can be equivalent or supply more than b.
11:37:26 <dfeuer_> @tell carter criterion-0.8.1.0 depends on statistics-0.13.2.1 which failed to install.
11:37:26 <dfeuer_> statistics-0.13.2.1 failed during the building phase. The exception was:
11:37:26 <lambdabot> Consider it noted.
11:38:26 <dfeuer_> carter keep yelling at me to benchmark things, but that's hard to do when Criterion won't compile.
11:38:38 <NikolajK> monochrom: ?
11:39:06 <carter> dfeuer_: why aren't you installing crterion 1.0
11:39:06 <NikolajK> I looked up "agenda" and it translates to intention or purpose
11:39:30 <carter> dfeuer_: if you can't build it, debug it and file a bug report
11:39:40 <dmwit> NikolajK: This presupposes \union_{x \in A} F(x) is a sensible thing. I presuppose no such thing.
11:39:49 <athan> dfeuer_: Be addicted to it worse than CRACK
11:39:50 <carter> @tell dfeuer_  you don't need to @tell me because ZNC gives me all the messages
11:39:50 <lambdabot> Consider it noted.
11:39:52 * hackagebot linux-evdev 0.3 - Bindings to Linux evdev input device interface.  http://hackage.haskell.org/package/linux-evdev-0.3 (BenGamari)
11:40:11 <monochrom> 1. A set suffices for the collection of types in the Haskell programming language. (In fact, A set suffices for the collection of programs in the Haskell programming language.)
11:40:11 <carter> athan: addicted to what?
11:40:22 <athan> carter: Criterion lol
11:40:31 <solidus-river> is tuple not a valid word?
11:40:37 <athan> slash benchmarking
11:40:41 <carter> :)
11:40:43 <solidus-river> i just realized everywhere i use it text editors tell me to sodd off and use real language
11:40:45 <monochrom> 2. You don't always use the smallest necessary collection. You always use the most convenient collection, which can be quite larger and contains junk.
11:41:00 <NikolajK> dmwit: so you want to deal with object that aren't sets? proper functor categories in haskell or what :P
11:41:22 <athan> solidus-river: Do they reject monad too?
11:41:51 <monochrom> For example, Dana Scott's greatest invention was "let's look at the collection of all continuous functions, not just the collection of all computable functions". his choice turned out to be way more convenient, though way more junky.
11:41:55 <solidus-river> athan: yes, but i'm less suprised by that
11:41:57 <josephle> athan: interestingly, monad does have a non-category theory usage, so it might be in the english lexicon
11:42:12 <solidus-river> athan: i'd expect tuple to be common enough to be in dictionaries for spellcheckers
11:42:14 <triliyn> solidus-river: I think in vernacular english it needs to have a numeric prefix to be a word, maybe?
11:42:21 <geekosaur> I wouldn't, particularly
11:42:35 <dfeuer_> carter, how do I nuke the broken installation attempt? It was installed for a certain compiler build.
11:42:44 <carter> dfeuer_: rm ~/.ghc
11:42:46 <carter> bam
11:42:52 <carter> then ghc-pkg recache
11:42:59 <geekosaur> common English has pairs, triples, etc.; it takes a mathy type to generalize to "tuple" instead of "group"/"collection"
11:43:01 <carter> then cabal update ; cabal install criterion
11:43:12 <carter> i need to update my criterion benchmark template to criterion 1.0
11:43:41 <dfeuer_> carter, I may have lost by failing to do that update... When did 1.0 come out?
11:44:03 <dmwit> dfeuer_, hseg: I am having trouble putting my finger on what bothers me about your rejoinders.
11:44:29 <dfeuer_> carter, when I do that and specify criterion-1.0, it fails.
11:44:35 <NikolajK> monochrom: my agenda is understanding computation
11:44:39 <dfeuer_> (global constraint requires ==1.0)
11:44:50 <dfeuer_> Could not resolve dependencies.
11:45:17 <carter> dfeuer_: .... what cabal version
11:45:18 <carter> what ghc version
11:45:20 <carter> and did you do exactly what i typed
11:45:21 <carter> or not
11:45:40 <dfeuer_> 1.20.0.1
11:45:55 <dfeuer_> I did everything except I specified criterion-1.0 instead of just criterion.
11:45:58 <dfeuer_> And
11:46:06 <dfeuer_> I used a -w, bucause I need that.
11:46:18 <carter> whats -w?
11:46:37 <dfeuer_> carter, install for a specific GHC.
11:46:44 <carter> 1.20.0.3 is the newest cabal install
11:46:46 <carter> what ghc version
11:46:56 <dfeuer_> Which happens to be sitting in ~/GHC/stock/bin/ghc
11:47:05 <carter> theres weres some nasty bugs in earlier 1.20.X
11:47:07 <dfeuer_> carter, close to current head.
11:47:14 <dfeuer_> Ah.
11:47:16 <carter> dfeuer_: ... you're not using 7.8 release?
11:47:21 <dfeuer_> So I may not have needed to nuke everything...
11:47:34 <carter> dfeuer_: not all the libs are supported in HEAD before release
11:47:45 <carter> are you just using a patched 7.8.3 OR actually head
11:47:48 <dfeuer_> carter, I'm hacking on the list libraries. I can't do what I need without Call Arity.
11:47:57 <carter> dfeuer_: ok, you'll have to patch shit
11:48:02 <carter> god speed :)
11:48:05 <dfeuer_> Well, it's probably a week behind HEAD or something.
11:48:10 <carter> thats head
11:48:13 <dfeuer_> Later, y'all.
11:48:20 <carter> dfeuer_: you also neeeeed to update your cabal-install
11:48:23 <carter> possibly to head
11:48:27 <carter> like
11:48:30 <carter> actually
11:48:32 <carter> probably
11:48:38 <dfeuer_> hrmm
11:48:50 <dfeuer_> bye
11:48:52 <carter> k
11:53:44 <NikolajK> can I write a Foldable instance for every algebraic datastructure which is based on only one monoid?
11:54:11 <NikolajK> I could have said "on a single monoid"
11:54:32 <NikolajK> i.e. if the mappend operation makes sense, can I always fold any tree in a good way
11:54:54 * hackagebot xilinx-lava 5.0.1.9 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.1.9 (SatnamSingh)
11:55:10 <quchen> What do you mean with "based on only one monoid"?
11:55:17 <dmwit> data FoldThis a = FoldThis (a -> Int) -- ?
11:55:43 <dmwit> Perhaps you do not consider this to be algebraic.
11:56:22 <monochrom> what is the definition of "an algebraic data structured based on a single monoid"?
11:56:51 <monochrom> is it decidable?
11:57:09 <dmwit> Maybe also what is the definition of "can I write a Foldable instance"?
11:57:25 <dmwit> foldMap _ _ = mempty -- yes
11:57:55 <monochrom> let's ask the easier question first :)
11:58:36 <NikolajK> what I mean is to choose a monoid and define a data type only with products and sums.
11:59:13 <NikolajK> if for this data type, there can always be written a foldable instance. I imagine these data types as trees and would assume the answer is yes
12:00:14 <NikolajK> the fold would scan through the tree in a way which treats different terms differently
12:00:32 <dmwit> Yes, you can fold sums and products in a sensible way.
12:00:44 <elaforge> has anyone used the new 'deriving Generic'?
12:00:46 <zereraz> hello, if I declare an integer t with a value can I do something like this t = t-1?
12:01:03 <dmwit> zereraz: nope!
12:01:06 <elaforge> no matter what I do I get Expected kind ‘(* -> *) -> Constraint’, but ‘Generics.Generic’ has kind ‘(* -> *) -> *’
12:01:07 <NikolajK> haha
12:01:23 <zereraz> dmwit: ok so what is the workaround
12:01:34 <quchen> elaforge: Paste your code?
12:01:43 <dmwit> zereraz: Rethink your plan. =)
12:02:06 <elaforge> {-# LANGUAGE DeriveGeneric #-}
12:02:06 <elaforge> import Data.Generics
12:02:07 <elaforge> data Empty deriving Generic
12:02:08 <zereraz> I was trying to implement this algo http://wiki.answers.com/Q/What_is_the_Consecutive_Integer_Checking_algorithm_to_find_the_GCD_of_two_numbers_with_an_eg
12:02:20 <dmwit> > gcd 32 64
12:02:22 <lambdabot>  32
12:02:24 <elaforge> directly out of the ghc doc, 7.8.3
12:02:24 <dmwit> ?src gcd
12:02:25 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
12:02:25 <lambdabot> gcd x y = gcd' (abs x) (abs y)
12:02:25 <lambdabot>    where gcd' a 0 = a
12:02:25 <lambdabot>          gcd' a b = gcd' b (a `rem` b)
12:03:03 <zereraz> dmwit: I did that one, that is euler algo
12:03:11 <dmwit> yep, reading now
12:03:22 <monochrom> consecutive integer checking algorithm?! that sounds really slow!
12:03:25 <dmwit> connection may drop out temporarily, relocating
12:03:43 <dmwit> but just a hint before I go: you might like lists as a reification of loops
12:04:04 <c_wraith> elaforge: wait, where is Data.Generics defined?  don't you want to be importing GHC.Generic?
12:04:06 <zereraz> dmwit: hmm
12:04:18 <zereraz> monochrom: yeah
12:04:29 <elaforge> c_wraith: aha!
12:04:33 <c_wraith> elaforge: err.  GHC.Generics
12:04:39 <elaforge> that was it, thanks so much :)
12:04:50 <zereraz> monochrom: using it to see how slow it is
12:04:51 <c_wraith> elaforge: you're welcome
12:04:54 <elaforge> too many generics libraries around
12:06:11 <elaforge> c_wraith: looks like Data.Generics is SYB
12:06:25 <c_wraith> elaforge: huh.  I thought SYB was Data.Data and Data.Typeable
12:06:47 <c_wraith> elaforge: all of which just proves your larger point - too many generics libraries. :)
12:07:22 <elaforge> c_wraith: someone should come up with a way to reify multiple generics libraries into a single datatype
12:08:43 <{AS}> as long as the generics libraries are optimised for the particular datatypes, me thinks that having multiple libraries is an advantage
12:10:22 <dmwit> zereraz: Did you get your answer yet?
12:10:50 <zereraz> dmwit: I am going to use recursion
12:11:04 <zereraz> dmwit: right now trying in c++, then will retry with haskell
12:11:35 <dmwit> > let gcd' m n = head . filter (\t -> m `rem` t == 0 && n `rem` t == 0) $ [min m n, min m n - 1..] in gcd' 35 40
12:11:37 <lambdabot>  5
12:12:02 <dmwit> zereraz: It's generally considered good form to avoid recursion where possible (by shifting that responsibility off onto library functions).
12:12:32 <zereraz> dmwit: oh I thought recursion is the right way to go, is it because of memory?
12:12:37 <vanila> recursion is fine
12:12:50 <NikolajK> what's to know about Edward Kmett. I stumbled upon him a couple of times now
12:12:58 <dmwit> zereraz: No, readability, maintainability, and code-writing speed.
12:13:13 <zereraz> dmwit: ok thanks
12:13:22 <Tuplanolla> He writes lots of things, NikolajK.
12:13:32 <dmwit> zereraz: As in the answer I wrote above that implements the algorithm you linked to. =)
12:13:57 <zereraz> dmwit: yeah, still trying to understand what you did
12:14:03 <quchen> NikolajK: He's the maintainer of those. http://hackage.haskell.org/user/EdwardKmett
12:14:19 <dmwit> > [35, 34..]
12:14:21 <lambdabot>  [35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,...
12:14:21 <monochrom> zereraz: [x .. y] and filter contain their own recursions
12:14:26 <quchen> EdwardK : Haskell = Euler : Mathematics ;-)
12:14:36 <zereraz> monochrom: huh
12:14:46 <dmwit> zereraz: This is the "decrease the value of t by 1 and repeat" part.
12:14:56 <zereraz> yeah
12:14:59 <zereraz> ok
12:15:26 <dmwit> > let m = 35; n = 40 in filter (\t -> m `mod` t == 0 && n `mod` t == 0) [35, 34, 30, 25, 5]
12:15:27 <zereraz> need to think functionally
12:15:28 <lambdabot>  [5]
12:15:40 <dmwit> zereraz: This is the "divide and check if the remainder is 0" part.
12:15:46 <dmwit> > head [5]
12:15:48 <lambdabot>  5
12:15:55 <zereraz> understood, thanks!
12:15:58 <dmwit> zereraz: This is the "if both divisions are zero, return the answer and stop" part.
12:16:32 <monochrom> zereraz: [x..y] is defined recursively. filter is defined recursively.
12:16:52 <zereraz> monochrom: oh, didn't know that, that makes sense though
12:17:01 <monochrom> it is alright to write your own recursion or use someone else's recursion
12:18:11 <zereraz> ok
12:21:46 <monochrom> ooohhh, a typo in the haskell platform source tarball README :)
12:21:50 <Artemis_> Hi, I'm trying to set default options for cabals use of happy inside a cabal.config file but when running cabal configure or cabal build it always throws an error: http://lpaste.net/109766
12:22:06 <monochrom> "If defaults to /usr/local/haskell" s/If/It/ :)
12:22:36 <zereraz> any improvements http://lpaste.net/109767 ?
12:23:32 <elaforge>  /window level -JOINS -PARTS -QUITS
12:24:24 <dcoutts_> Artemis_: 1. check you're using a version of cabal that knows about this section, but 2. it's possible it's supported in the global ~/.cabal/config but not the local one, would have to check
12:24:25 <clrnd> je
12:25:19 <Fuuzetsu> is there an environment variable which lets me pass flags to GHC? Notably looking for -v
12:26:14 <monochrom> ooohhh, the typo was worse. it was "If defaults to /usr/loca/haskell". s/If/It/ and s/loca/local/ !
12:27:24 <dmwit> zereraz: The annotations on readLn are probably not necessary.
12:27:47 <zereraz> dmwit: annotations? the :: IO Int?
12:28:02 <dmwit> yes
12:28:27 <monochrom> yeah, using n, m on gcd' which narrows the types is enough to narrow the types
12:29:05 <zereraz> ok
12:29:07 <zereraz> thanks
12:29:13 <monochrom> then again, if you generalize the type of gcd' one day, then you will need to annotate n, m again
12:29:38 <Ankhers> zereraz: Maybe create an inline recursive function in gcd' since the n and m are constant?
12:29:56 <monochrom> however, when that happens, I prefer to turn on an extension that allows me to write "n :: Int <- readLn" instead
12:30:22 <monochrom> inline? inner?
12:30:32 <zereraz> Ankhers: I do not know how to do that
12:30:44 <Ankhers> monochrom: Whatever it would be called to create a function with where.
12:30:49 <Ankhers> I thought that was called inline.
12:30:53 <monochrom> that's inner
12:30:58 <Ankhers> My mistake.
12:31:06 <zereraz> can you give example
12:31:31 <Ankhers> Sure. I will annotate your paste. Just give me a sec.
12:33:47 <zereraz> ok
12:34:02 <Ankhers> zereraz: something like http://lpaste.net/109767
12:34:36 <Ankhers> I don't know how good a name `go` is. But I see that used fairly often for inner functions.
12:34:42 <zereraz> what is go x?
12:34:52 <NikolajK> quchen: he's dead :/
12:34:56 <Ankhers> that is the inline function.
12:34:56 <merijn> zereraz: A function declaration :)
12:35:03 <Ankhers> inner
12:35:06 <Ankhers> inner function
12:35:07 <merijn> zereraz: "where" introduces a local scope
12:35:12 <monochrom> it's a helper function
12:35:19 <zereraz> oh
12:35:31 <merijn> Ankhers: Although the helper function seems redundant here?
12:35:37 <zereraz> does this take less memory than mine?
12:35:46 <monochrom> the bland name "go" is chosen to mean "this is my loop". or something. don't worry about the name.
12:35:47 <quchen> NikolajK: Wat
12:35:49 <merijn> Ankhers: Just put the guards directly in gcd, I'd say?
12:35:57 <NikolajK> >Euler
12:36:24 <Ankhers> merijn: I thought since n and m don't change, it would take less space to have an inner definition?
12:36:27 <Artemis_> dcoutts_ I'm running 1.18.05 (just updated) and this option is (even though commented out) in my ~/.cabal/config file
12:36:32 <Ankhers> I'm still new to Haskell so I could be wrong.
12:36:42 <zereraz> Ankhers: makes sense
12:36:51 <Artemis_> dcoutts_ but changing it there also does not seem to change anything…
12:36:57 <zereraz> Ankhers: how long have you been learning?
12:37:23 <merijn> Ankhers: oh, right, but then it's not really computing gcd anymore, is it?
12:37:26 <zereraz> monochrom: it does look like loop
12:37:30 <merijn> oh
12:37:38 <merijn> I guess it is, just the "dumb" way :)
12:38:07 <Ankhers> zereraz: about three or four months seriously. Looking at it about a year or so.
12:38:20 <zereraz> merijn: this is like checking everything, not the euler method
12:38:22 <Ankhers> merijn: Yes. It was the "dumb" way before the change too though.
12:38:23 <marchelzo_> yeah that is a really naive defn of gcd
12:38:29 <dcoutts_> Artemis_: you mean setting it (and uncommenting obviously) in the ~/.cabal/config doesn't work?
12:38:44 <merijn> Ankhers: Before I went to lunch zereraz was implementing Euclid's algorithm :)
12:39:02 <shapr> @quote shapl
12:39:03 <lambdabot> Cale says: shapr, shapl, shapl'
12:39:17 <merijn> Also, I think Project Euler isn't very good for practicing haskell
12:39:19 <zereraz> I have an assignment we were supposed to do these in c++, I did in both c++ and haskell
12:39:27 <Ankhers> I suppose that would make my change look terrible.
12:39:28 <zereraz> 3 types of gcd algos
12:39:32 <shapr> zereraz: nifty!
12:39:34 <merijn> ah :)
12:40:17 <merijn> The nicer way to do it would be to ditch the extra argument in gcd
12:40:26 <zereraz> now the next one called middle school procedure I think
12:40:36 <shapr> zereraz: One of my instructors asked for a one-page-max proposal for a word count program, so I did in lhs2TeX, where the presentation was executable, and ran on itself :-) http://www.scannedinavian.com/~shae/WordCount.pdf
12:40:38 <zereraz> merijn: you mean t?
12:41:16 <merijn> zereraz: http://lpaste.net/109767
12:41:37 <Ankhers> That would make more sense.
12:41:39 <zereraz> shapr: that is interesting, I am going to read it soon
12:42:00 <merijn> zereraz: Yeah, because normally someone doing "gcd x y" doesn't want to have to provide a start value
12:42:11 <merijn> actually
12:42:12 <Artemis_> dcoutts_: yes, setting it e.g. to "  happy-options: --glr" does not change the haskell file built by cabal
12:42:18 <dcoutts_> Artemis_: hmm, no doesn't work for me here either, setting it in the ~/.cabal/config
12:42:20 <merijn> I guess you want "min x y" as argument to go :)
12:42:21 <zereraz> merijn: its supposed to be min
12:42:30 <zereraz> merijn: yeah :)
12:42:32 <dcoutts_> Artemis_: (I'm using a later version)
12:42:43 <zereraz> merijn:  this is called some reduction right
12:43:05 <zereraz> merijn: this is different I gues
12:43:05 <dcoutts_> Artemis_: it's easy to see by looking at the output of cabal haddock -v, compare e.g. with cabal haddock --haddock-options=--foobar
12:43:05 <merijn> zereraz: Anyway, this is a very common pattern, define a function as a call to a helper that assume some start values
12:43:07 <Getterac7> I'm writing a C application and currently use embedded Python interpreter for scripting, but would like to replace that with an embedded Haskell interpreter.  I'd need to be able to make calls from C to arbitrary Haskell functions, and vice versa.  Is this possible? If not, would it be possible if I define headers/interfaces for Haskell functions?
12:43:11 <Artemis_> dcoutts_ my problem is that the default options for happy are not safe and I want cabal to not use those extra unsafe feautres :-|
12:43:22 <dcoutts_> Artemis_: how so?
12:43:34 <zereraz> thanks everyone
12:43:40 <merijn> Getterac7: It's not only possible, it's fairly easy (if you don't use structs, if you do it's slightly more annoying)
12:44:05 <merijn> Getterac7: I wrote a minimal example on lpaste not so long ago, lemme check if I can find it
12:44:09 <Artemis_> dcoutts_ looks like cabal calls happy with the following options: --ghc --coerce --array
12:44:15 <Getterac7> merijn: awesome, thank you :)
12:44:23 <dcoutts_> Artemis_: yes, what's wrong with that?
12:45:01 * hackagebot spice 0.3.2.0 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.3.2.0 (Crockeo)
12:45:03 * hackagebot spice 0.3.2.1 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.3.2.1 (Crockeo)
12:45:05 <yrlnry> I'm trying to implement "cat" in Haskell.  I don't understand how to handle the EOF condition.  Hackage says "[hGetLine] may fail with isEOFError...".  How do I handle that failure?
12:45:40 <Artemis_> dcoutts_ It's bothering me a little bit that GHC.Exts (included by --coerce) is not a safe package
12:45:59 <merijn> yrlnry: See the functions in Control.Exception
12:46:02 <yrlnry> is there a function somewhere that says "take an IO a and call function f if it yields an error, and function y:: a -> b  if it succeeds?
12:46:07 <yrlnry> Thanks, will dpo.
12:46:09 <yrlnry> do.
12:46:22 <merijn> Getterac7: Ah, I can't find it anymore, but if you google haskell FFI you should find a lot of examples
12:46:29 <merijn> :t Control.Exception.catch
12:46:31 <lambdabot> Exception e => IO a -> (e -> IO a) -> IO a
12:46:36 <Guest73363> meta-1
12:46:43 <Getterac7> merijn: will-do. thank you again!
12:46:45 <shachaf> yrlnry: You can catch after fmapping.
12:46:47 <johnnyrichard> sdf
12:47:00 <shachaf> yrlnry: I.e. just make an IO b in the first place.
12:47:14 <milieu> I don't get how the Haskell wiki page isn't regularly curated. I have a friend who keeps dissing haskell because it's "last stable release was four years ago" when it's July 9th.
12:47:19 <milieu> updating it.
12:47:28 <milieu> but I'm not wrong, right?
12:47:47 <milieu> According to http://www.haskell.org/ghc/docs/latest/html/users_guide/version-numbering.html and http://git.haskell.org/ghc.git/tags
12:47:50 <merijn> milieu: There's no real group in charge of managing the wiki
12:47:59 <merijn> milieu: 7.8 was released this summer, yeah
12:48:09 <merijn> And platform just like 1 or 2 weeks ago
12:48:14 <gcganley> i think its 7.8.3 right now
12:48:29 <gcganley> at least thats the repo on arch linux pacman
12:48:41 <btubbs> yrlnry: not related to exceptions, but more to the 'cat' example.  Have you seen 'interact'? http://www.haskell.org/haskellwiki/Tutorials/Programming_Haskell/String_IO#IO
12:49:14 <milieu> merijn: thanks for confirming, and yeah it's 7.8.3
12:49:31 <dcoutts_> Artemis_: ahh I see
12:49:32 <yrlnry> btubbs: I did,  but I wanted to write my own cat instead of using interact.  But thanks.,
12:50:05 <dcoutts_> Artemis_: mm, interesting. Yes, those options are not supposed to be controversial, so we don't provide any way to control them (as a package author).
12:50:13 <merijn> Actually, this is probably nicer
12:50:19 <dcoutts_> Artemis_: you're welcome to file a Cabal ticket about this issue
12:50:24 <merijn> :t try hGetLine
12:50:26 <lambdabot>     Not in scope: ‘hGetLine’
12:50:26 <lambdabot>     Perhaps you meant one of these:
12:50:26 <lambdabot>       ‘BSC.hGetLine’ (imported from Data.ByteString.Char8),
12:50:40 <merijn> :t Control.Except.try Data.ByteString.hGetLine
12:50:43 <lambdabot>     Not in scope: ‘Control.Except.try’
12:50:43 <lambdabot>     Perhaps you meant ‘Control.Exception.try’ (imported from Control.Exception)
12:50:53 <gcganley> :t (<$)
12:50:55 <lambdabot> Functor f => a -> f b -> f a
12:50:56 <merijn> :t Control.Exception.try Data.ByteString.hGetLine --third time's the charm!
12:50:57 <lambdabot>     Couldn't match expected type ‘IO a’
12:50:57 <lambdabot>                 with actual type ‘GHC.IO.Handle.Types.Handle -> IO BSC.ByteString’
12:50:57 <lambdabot>     Probable cause: ‘BSC.hGetLine’ is applied to too few arguments
12:51:03 <monochrom> yrlnry: see my http://www.vex.net/~trebla/haskell/exception-tutorial.xhtml
12:51:10 <merijn> ugh, I give up
12:51:37 <shachaf> :t try getLine -- hth
12:51:39 <lambdabot> Exception e => IO (Either e String)
12:53:04 <elaforge> yrlnry: I think the ghc io library expects you to call isEOF all the time
12:53:12 <Artemis_> dcoutts_ you just opened a ticket… ?! so nothing left to do on my part except following this issue on github?
12:53:39 <shachaf> whoa, it's elaforge
12:53:53 <dcoutts_> Artemis_: oh, you might want to mention the issue that it's not recognised in the local config file
12:53:57 <shachaf> elaforge: Isn't the point of the exception that you don't have to use isEOF in advance?
12:54:14 <elaforge> well yeah, but then you have to catch exceptions
12:54:21 <elaforge> pick your poison I guess :)
12:54:33 <Artemis_> dcoutts_ yeah you're right even though you mentioned it in you comment -- but I'll add some information to the issue
12:54:57 <monochrom> hGetLine is susceptible to DoS attacks
12:55:07 <shachaf> In this case maybe you get to pick your poison, but in many similar cases there are race conditions and what not such that checking in advance isn't really an option.
12:55:14 <dcoutts_> Artemis_: but it's different, the warning was about not recognising the section at all
12:55:37 <elaforge> true, maybe in general catching is better
12:55:38 <Artemis_> dcoutts_ oh yeah you're right
12:55:50 <monochrom> as well as benign "I forgot to put a newline in the middle"
12:55:53 <shachaf> Either catching the exception or an hGetLine with a better type.
12:56:17 <shachaf> I,I Either catching the exception or Either-catching the exception.
12:56:23 <monochrom> hahahaha
12:56:24 <yrlnry> Thanks, my cat program works now.
12:56:48 <monochrom> @remember shachaf I,I Either catching the exception or Either-catching the exception.
12:56:49 <lambdabot> Okay.
12:56:50 <yrlnry> I defined:   overAndOver act = act >> (overAndOver act)    but I expect that overAndOver is a standard function somewhere.  What is it called?
12:56:52 <merijn> monochrom: I don't think hGetLine DoS attacks are a big worry for toy cat implementations :)
12:57:08 <merijn> yrlnry: You probably want Control.Monad.forever ?
12:57:21 <merijn> :t forever
12:57:22 <lambdabot> Monad m => m a -> m b
12:57:28 <yrlnry> That's it, thanks.
12:57:38 <frerich_> Hm, I just decided to give the latest and greatest Haskell Platform a try on OS X. One of the first things I’d like to install is Criterion, but trying it gives me http://lpaste.net/109771 — how does one deal with this? Try building Criterion in a sandbox and somehow copy the library out of the sandbox? Risk installing with —force-reinstalls and cross fingers? Install an older version of Criterion?
12:57:40 <monochrom> well, I would agree if you changed it to "toy inputs"
12:58:06 <merijn> yrlnry: If you catch the exception outside forever you have an easy way to exit the loop :)
12:58:25 <yrlnry> Yes, I couldn't get it to work any other way.
12:59:25 <kuribas> frerich_: I never had problems with reinstalls
12:59:53 <milieu> there needs to be a haskell bot for updating that wiki page.
13:00:24 <yrlnry> My program is still working, with overAndOver replaced by forever.  But if I leave in the line overAndOver = forever, I get a type failure:
13:00:27 <yrlnry>     No instance for (Monad m0) arising from a use of `forever'
13:00:27 <yrlnry>     The type variable `m0' is ambiguous
13:00:48 <yrlnry> What does that mean?  How can  "overAndOver = forever" cause a type failure?
13:00:48 <shachaf> yrlnry: This is the monomorphism restriction, probably. Add a type for overAndOver.
13:01:00 <shachaf> Or add a parameter, as in overAndOver x = forever x
13:01:01 <shachaf> @where dmr
13:01:02 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:01:42 <yrlnry> Oh, its DMR.
13:01:43 <yrlnry> Thanks.
13:06:37 <bergey> frerich_: You can rebuild the named packages with the new version of attoparsec that you're installing.  That's reasonable if you're mostly using the Platform as a convenient way to install zlip, OpenGL and whatever else is annoying to install on not-Linux.
13:06:55 <monochrom> problems caused by reinstalls are latent dormant problems. they don't show up immediately. none of them does.
13:07:29 <merijn> yrlnry: It seems kinda redundant to define "overAndOver = forever" instead of just using forever, though :)
13:07:53 <MitchellSalad> overAndOver isn't a great name, either. I'd change it to overAndOverAndOver
13:08:00 <MitchellSalad> slightly more accurate
13:08:11 <monochrom> they will show up at a later time when you will use some other packages you deem unrelated (but related without your knowing, of course). you may not even recognize that they are caused by your reinstalls six months earler.
13:08:51 <monochrom> therefore, take "I have never had problems with reinstalls" with a grain of salt. you don't know whether the speaker really knows.
13:09:12 <merijn> monochrom: Well, when I reinstall something what I actually mean is "repeatedly ghc-pkg unregister, followed by clean installs" :)
13:09:20 <yrlnry> merijn: I left it in by mistake.
13:09:31 <glguy> When I reinstall something I use a script to repeatedly unregister ^_^
13:10:28 <merijn> monochrom: Which I'm pretty sure makes it impossible to break something in subtle ways, no?
13:10:39 <monochrom> yes, but suppose the context is "I am on OS X and I simply installed the haskell platform installer". do you now accept giving up part of it?
13:10:53 <glguy> Oh, definitely give up the HP :)
13:11:27 <monochrom> it is clear for you. it is not clear for other people.
13:11:42 <DanielDiaz> if "ghc --version" returns "The Glorious Glasgow Haskell Compilation System, version 7.8.3" but "cabal haddock" says "The GHC version is 7.6.3 but haddock is using GHC version 7.8.3"... what am I doing wrong?
13:11:59 <merijn> DanielDiaz: haddock links against GHC the library
13:12:19 <merijn> I suspect that's the issue?
13:12:34 <monochrom> I would think that a person choosing the haskell platform is also choosing a certain tradeoff point of not wanting to babysit individual libs
13:12:34 <DanielDiaz> merijn: I don't know. So what do I do next?
13:13:23 <monochrom> also, he/she may not know which parts are safe to give up. (some parts are unsafe to give up.)
13:13:37 <dcoutts_> DanielDiaz: looks like you're really using ghc-7.6.3, and the new haddock
13:13:55 <dcoutts_> DanielDiaz: see cabal configure -v to see which ghc cabal is picking up
13:16:53 <DanielDiaz> dcoutts_: cabal configure returns "Using compiler: ghc-7.8.3"
13:17:47 <dcoutts_> DanielDiaz: and then cabal haddock still reports the same thing?
13:17:53 <dcoutts_> for the same package?
13:17:56 <DanielDiaz> dcoutts_: ok. now it works...
13:18:00 <dcoutts_> after having configured
13:18:20 <Markz> http://lpaste.net/6659500191499943936
13:18:25 <DanielDiaz> dcoutts_: yes, reconfiguring worked. I guess it was still using and old configuration with the old GHC.
13:18:26 <Markz> where does st come from
13:18:26 <dcoutts_> DanielDiaz: presumably you installed 7.8.3 but did not reconfigure before building/haddocking
13:19:08 <DanielDiaz> dcoutts_: it was a silly problem then :( thank you anyway. I just found the message confusing.
13:19:17 <dcoutts_> Markz: you might want to ask a more specific question
13:19:25 <yrlnry> Does lambdabot still have a command for converting a function definition to point-free form?
13:19:42 <geekosaur> @help pl
13:19:42 <lambdabot> pointless <expr>. Play with pointfree code.
13:19:49 <yrlnry> Thanks.
13:20:12 <dcoutts_> Markz: or you'll get answers like "line 5, definition of loop", which is not perhaps what you mean.
13:20:47 <Markz> well at some point, a value is going be applied which is referred to as st right?
13:21:06 <Markz> probably from main
13:21:29 <Markz> is main IO -> IO ?
13:21:40 <dcoutts_> Markz: that'll come from connect, via bracket
13:21:51 <vanila> main :: IO ()
13:22:19 <dcoutts_> Markz: see the definition or documentation of bracket and it'll all become clear
13:22:27 <dcoutts_> or just the type of bracket
13:25:49 <Markz> mybad
13:28:06 <merijn> vanila: To be completely accurate, "main :: IO a"
13:28:23 <merijn> vanila: The report says you can use any 'a' as result for main
13:30:22 <josephle> does "main :: IO Int" set the program exit status to whatever is returned?
13:30:38 <quchen> No, main is implicitly voided.
13:31:49 <quchen> "The value of the program is the value of the identifier main in module Main, which must be a computation of type IO τ for some type τ. When the program is executed, the computation main is performed, and its result (of type τ) is discarded."
13:32:20 <josephle> oh, okay
13:33:04 <schell> is there a ghc option to not show “Defaulting the following constraint…” warnings?
13:33:52 <carter> schell: look in the manual
13:34:00 <carter> probably something like -fno-somethingsometing
13:34:58 <monochrom> -fno-warn-somethingsomething
13:35:23 <shachaf> If I don't have ScopedTypeVariables, how bad would it be to write f :: ...b...; f = ... where g :: ...b...; g = ..., when g is only used with its b equal to f's b?
13:35:52 <shachaf> I.e. if I made b scoped it would continue to type-check.
13:36:00 <shachaf> It's a bit like shadowing, though.
13:36:15 <shachaf> Since the two 'b's are different, and g also happens to be polymorphic.
13:36:58 <carter> monochrom: :P
13:37:17 <carter> schell: i usually open a new terminal tab, type ghc --show-options
13:37:21 <yrlnry> My cat program now works when it is invoked with command-line arguments, but my implementation seems kind of yucky.  I would be grateful if someone would look at http://lpaste.net/109773 and tell me if there is a cleaner way to do it.
13:37:26 <carter> then search for the right word
13:37:39 <schell> carter: ah! thanks, that’s a nice trick
13:38:06 <shachaf> yrlnry: mapM_ would be better than mapM
13:38:12 <shachaf> (And it returns IO ().)
13:38:12 <carter> schell: thees a LOT of options that aren't "supported" per se :)
13:38:15 <yrlnry> Ooh, the lpaste itself suggests mapM_!
13:38:20 <yrlnry> Thanks!
13:38:21 <schell> my other solution was going to be a monomorphic function instead of the polymorphic function
13:39:33 <monochrom> shachaf: I am paranoid about misleading readers using the same name for two different things. so it's bad.
13:39:59 <shachaf> monochrom: So am I.
13:40:19 <shachaf> OK, I'll use a different name, since it's polymorphic anyway.
13:41:57 <bernalex> monochrom: sucks to be in a lang where type & data constructors don't share a namespace amirite
13:42:07 <monochrom> there was once a long time, when I saw "f :: ... b ...; f = ... where g :: ... b ...", I assumed that the two b's were in sync.
13:42:41 <bernalex> Ball ball = new Ball(); /* :-] */
13:43:20 <monochrom> now, if you accept that I'm pretty smart and well-versed in haskell, then you get to conclude: if even monochrom makes that mistake, this issue must be really subtle and easy to miss.
13:43:49 <shachaf> The question is whether the fact that it would type-check if they were in sync makes it better or worse.
13:44:19 <bernalex> what's a nicer way to do map (\(x,y,z) -> z)? my brain is tired today
13:44:20 <shachaf> But I'll just use another letter. Free variables don't cost me anything.
13:44:22 <monochrom> "Ball ball = new Ball()" is more a demonstration of the calamity of lacking type inference :)
13:44:46 <bernalex> monochrom: not only
13:45:05 <dolio> Java is more fun than that.
13:45:09 <monochrom> right, but that's the first thing I notice
13:45:17 <dolio> Variables and methods don't share a namespace.
13:45:23 <bernalex> monochrom: I would like it more if at least it had MkBall :-]
13:45:27 <ReinH> bernalex: view _3 if you've got lens lying around
13:45:30 <dolio> As I recall.
13:45:32 <bernalex> ReinH: yeah I don't
13:45:36 <dolio> You can have lots of fun with that.
13:45:40 <ReinH> b-but...
13:45:48 <josephle> bernalex: then you're probably stuck with that lambda
13:46:04 <bernalex> josephle: that was my guess
13:46:09 <monochrom> then again, "ball :: Ball; ball = Ball" is legal Haskell too, given the necessary declarations for Ball.
13:46:36 <monochrom> in fact it's the #0 misunderstanding among beginners
13:46:37 <ReinH> monochrom: how many people are confused by [] at the type and value levels? ;)
13:46:46 <bernalex> monochrom: I'd consider "b :: Ball; b = MkBall" a lot nicer
13:46:49 <ReinH> (lots and lots)
13:46:57 <bernalex> ReinH: oh yes
13:47:04 <monochrom> yes, I always wrote "data Ball = Ctor1 | Ctor2 Int" for beginners
13:47:10 <bernalex> ReinH: I even got confused by it a week ago or so when I was sleepy
13:47:10 <monochrom> s/wrote/write/
13:47:14 <ReinH> haha
13:47:18 <josephle> unless someone made a "thd" function in Data.Tuple while I wasn't looking
13:47:19 <dolio> Many. And the number will only grow.
13:47:39 <bernalex> josephle: thd fth... now what? ;-)
13:47:44 <monochrom> "data Ball = Ball Int" is simply inviting beginners to imagine "can I also do data X = Int | Bool"
13:47:52 <quchen> monochrom: You should also try "data Maybe a = Nothing | Maybe a" to have something to compare your data to.
13:47:55 <pantsman_> https://www.youtube.com/watch?v=45NOP1OA-EQ
13:48:05 <dolio> monochrom: You can do that.
13:48:07 <bernalex> monochrom: super simple things like imports become a hassle for newbs
13:48:23 <bernalex> monochrom: "it says to import the data constructor for Ball, but I already have import Ball (Ball)!"
13:48:37 <monochrom> hahaha
13:48:50 <bernalex> "oh no you want import Ball (Ball (Ball)) duhh"
13:48:57 <monochrom> "import Ball(Ball(Ball))" would be a bit too extreme, wouldn't it? :)
13:49:29 <bernalex> and since f (g x) = f . x you should be able to do import (Ball . Ball . Ball)
13:49:46 <bernalex> and since a & f = f a, you should be able to do import & Ball . Ball . Ball
13:49:56 <bernalex> or actually
13:49:59 <bernalex> and since a & f = f a, you should be able to do import & Ball . Ball $ Ball
13:50:08 <josephle> that's more like it
13:50:28 <bernalex> is it sad that I would actually like that?
13:50:36 <monochrom> this is a good time to cue: http://article.gmane.org/gmane.comp.lang.haskell.cafe/83292/
13:50:50 <bernalex> though these days I have adopted a super verbose import system for easy merging
13:52:03 <monochrom> super verbose. does it look like "import System.IO(hGetLine) \n import System.IO(stderr) \n import System.IO(hClose) \n ..."?
13:52:31 <bernalex> https://github.com/plaimi/tempuhs-server/blob/master/src/Tempuhs/Server/POST.hs
13:52:48 <bernalex> :-]
13:53:07 <monochrom> aren't you thankful that spurrious commas are accepted :)
13:53:16 <bernalex> YES
13:53:24 <monochrom> \∩/
13:53:24 <bernalex> #1 feature request for record syntax
13:53:39 <monochrom> yeah, we need that to complete the cycle
13:53:57 <monochrom> no wait, also need it for list comprehension!
13:53:59 <bernalex> maybe I should open a bug for haskell'
13:54:17 <bernalex> "Consistent trailing commas"
13:55:07 <bernalex> of course the true Glaswegian way is to write {-# LANGUAGE ConsistentTrailingCommas #-}
13:56:41 <prophile> that could be confusing with tuple sections
13:56:49 <bernalex> haha
13:59:03 <Haskellfant> I just stumbled upon http://lampwww.epfl.ch/~emir/bqbase/2005/01/20/monad.html which explains monads in scala. However here unit has type a -> M b. Is this just an error or is there a mathematical reason to use this generalized version instead of the one haskell uses for return
13:59:21 <merijn> Haskellfant: Perhaps subtyping?
13:59:51 <Haskellfant> merijn: I can't quite follow you there
14:00:29 <Natch> does anyone know how I can force a dependency to run autoreconf before compiling if I'm installing something in a cabal sandbox?
14:00:59 <Cale_> Haskellfant: I can't imagine that being anything other than an error
14:01:04 <ReinH> Haskellfant: that doesn't seem like a reasonable type for unit
14:01:06 <josephle> Haskellfant: "The functor T lifts any function f:a-<b to a function Tf:T[A] -> T[B]"
14:01:12 <josephle> from the article you linked
14:01:17 <bernalex> Haskellfant: well, the way I would the law for left unit is unit a * \b. n = n[a/b]
14:01:27 <josephle> oh wait
14:01:30 <josephle> nevermind
14:01:34 <josephle> dang typos
14:02:04 <Haskellfant> Ok thx to everybody. I thought there might be some deeper point I'm missing here.
14:02:22 <bernalex> which reads as compute a and bind b to the result. compute n. with the result being equal to n with the value a substituted for the variable b.
14:03:03 <Haskellfant> bernalex: I wasn't talking about the unit law but about the the type of the unit function (so return in haskell)
14:03:57 <bernalex> Haskellfant: are you sure that's what they're talking about? because to explain monads really simply I'd say it's having an arrow a -> M b (I did not read the link)
14:04:23 <bernalex> if it's really just "return", I find it hard to believe it's not just a -> M a
14:04:36 <josephle> bernalex: the link explicitly says "unit: A -> M[B]". I'm inclined to think it's a typo though
14:04:44 <monochrom> I don't think "a -> M b" for unit makes sense.
14:04:48 <bernalex> josephle: yeah unit should be a -> M b
14:04:53 <bernalex> god damnit
14:04:56 <bernalex> I just made the typo
14:04:59 <bernalex> so yeha... probably a typo.
14:05:00 <josephle> hehe
14:05:03 <Haskellfant> :)
14:05:10 <Haskellfant> bernalex: yes I am pretty sure
14:05:19 <bernalex> I'm not convinced a -> M b can make sense
14:05:31 <prophile> bernalex: depends on M
14:05:37 <josephle> well, if a <: b, this can work out
14:05:47 <josephle> but such constraints in scala are made at the trait level
14:05:52 <josephle> and this would make bind nonsensical
14:05:53 <prophile> data Unit a = Unit
14:06:00 <prophile> has a completely valid monad instance
14:06:10 <prophile> and also supports an operation a -> Unit b for all a, b
14:06:27 <monochrom> prophile: did you know: Moggi added an extra requirement in his paper to outlaw that :)
14:06:46 <prophile> I did not know that
14:07:05 <prophile> is that even a thing?
14:07:09 <monochrom> the extra requirement has one implication "unit has to be injective" :)
14:07:16 <prophile> our rights to trivial instances must be protected by some amendment or other
14:07:35 <bernalex> I don't recall anything allowing that in pwadler's papers but IDR off the top of my head
14:08:00 <monochrom> yes, I think he clearly worded it as his personal extra requirement rather than a monad requirement
14:08:26 <bernalex> heh
14:08:31 <bernalex> I still think it's a typo :-]
14:09:01 <monochrom> either b is explicitly a subtype of a, or cannot be b.
14:10:12 * hackagebot nonfree 0.1.0.0 - Free structures sans laws  http://hackage.haskell.org/package/nonfree-0.1.0.0 (ShachafBenKiki)
14:10:24 <shachaf> hi hackagebot
14:10:33 <monochrom> this is the problem with learning from people who aren't aware of the issues
14:11:36 <josephle> you're right, it should be b <: a
14:11:37 <prophile> shachaf: shoulda called it "proprietary" :)
14:11:48 <shachaf> I was deliberating between "nonfree" and "cheap".
14:12:40 <monochrom> oh, it's a shachaf's package!
14:12:55 <monochrom> why is a collection of free structures called nonfree?
14:13:45 <Twey> I have a big chunk of memory in my heap profile that's just marked PINNED.  How can I track it down?
14:13:47 <shachaf> They're not free.
14:13:53 <shachaf> They're not even structures.
14:14:06 <shachaf> Well. The nonfree monoid is not a monoid.
14:14:28 <monochrom> Twey: bytestring uses pinned memory. perhaps text does, too.
14:14:59 <shachaf> text uses ByteArray#
14:15:13 <bernalex> shachaf | They're not free.
14:15:15 <bernalex> :-(
14:15:24 <prophile> http://hackage.haskell.org/package/nonfree-0.1.0.0/src/Data/Monoid/Nonfree.hs
14:15:33 <bernalex> maybe you should have called your package "enslaved" or "imprisoned"
14:15:34 <prophile> is this an encoding issue
14:15:45 <prophile> or have you actually just bested kmett for the most unwieldy operators :D
14:16:07 <shachaf> The Unicode names are ◇ and ε.
14:16:15 <prophile> ah
14:16:21 <prophile> how disappointing
14:16:32 <prophile> â—‡ sounds like an intriguing operator
14:16:53 <shachaf> Fix your browser to default to UTF-8.
14:17:02 <Twey> monochrom: Right, I know that… but how can I figure out where they're being allocated?
14:17:03 <bernalex> shachaf: does that actually work?
14:17:12 <johnw> bernalex: it does actually
14:17:13 <bernalex> shachaf: last I checked all browsers would then fail to detect western encoding properly
14:17:35 <monochrom> then I don't know, Twey
14:17:37 <bernalex> though IDK how you even view that file in a browser, because it's not served as plaintext (I had to download it)
14:17:42 <shachaf> To justify that package name I should probably add more than just monoids.
14:17:53 <prophile> shachaf: that would be breaking the browser
14:17:55 <Twey> monochrom: Aw.  Okay, thanks ☹
14:18:16 <prophile> the HTTP default charset is ISO-8859-1
14:18:25 <monochrom> really?!
14:18:29 <bernalex> yep
14:18:43 <monochrom> it is actually written clearly in the RFC?
14:18:45 <prophile> the problem is that hackage.haskell.org isn't sending the encoding as part of the MIME type
14:19:10 <shachaf> monochrom: Ugh, it is. :-(
14:19:13 <bernalex> but for those of us who sometimes need to do webdev kind of stuff, it's really annoying because JSON etc is most certainly UTF-8 if it's served by us at least
14:19:17 <monochrom> it is preferrable for websites to send out explicit correct MIME types, of course
14:19:30 <shachaf> http://tools.ietf.org/html/rfc2616#section-3.7.1
14:19:43 <prophile> shachaf beat me to it
14:19:53 <bernalex> monochrom: have you not yet learned that when something sounds too stupid to be true, it's usually true?
14:19:56 <fodase> hello
14:20:11 <johnnyrichard> fodase: e ai man
14:20:26 <monochrom> I keep forgetting that, bernalex :)
14:20:29 <fodase> asd
14:20:39 <fodase> johnnyrichard: mama eu
14:20:46 <monochrom> I live among such smart people, for example all of you :)
14:21:01 <johnnyrichard> monochrom: ops
14:21:51 <fodase> suckle me
14:21:59 <fodase> johnnyrichard: sukle me
14:22:04 <bernalex> @lyah
14:22:05 <lambdabot> Unknown command, try @list
14:22:08 <bernalex> @where lyah
14:22:08 <lambdabot> http://www.learnyouahaskell.com/
14:22:11 <bernalex> fodase: ^ there you go
14:22:25 --- mode: ChanServ set +o Heffalump
14:23:11 <fodase> i want everyone sukle my balls
14:23:13 --- mode: ChanServ set +o johnw
14:23:15 --- mode: johnw set -o johnw
14:23:20 --- mode: ChanServ set +o johnw
14:23:23 --- mode: ChanServ set +o johnw
14:23:26 --- mode: johnw set +b *!bb268478@gateway/web/freenode/ip.187.38.132.120
14:23:29 --- kick: fodase was kicked by johnw (Kicked)
14:23:32 --- mode: johnw set -o johnw
14:23:39 --- mode: Heffalump set -o Heffalump
14:23:45 <bernalex> LYAH counts as suckling, I assume?
14:23:57 <bernalex> i.e. in the transitive form of the verb
14:23:58 <MP2E> hahha
14:25:02 <shachaf> Heffalump++
14:26:45 * bernalex >>= sleep
14:27:15 <HeladoDeBrownie> bernalex :: IO Int -- ?
14:27:43 <hpc> hopefully reality is 64-bit
14:27:55 <hpc> or you'd only ever be able to sleep for about 2 hours
14:28:32 <HeladoDeBrownie> Never mind sleep duration, how about the duration of the universe?
14:28:38 <fread2282> hopefully time is an Integer
14:31:27 <shachaf> foldMapDefault is occasionally a better Foldable instance than foldMap
14:31:51 <shachaf> People like to define foldr instead of foldMap. But they don't have that luxury with traverse.
14:32:59 <meretrix> My application performs many end of day tasks at 5PM.  How would you suggest testing something like this without changing the system's clock?
14:33:37 <monochrom> change the system's clock. of a virtual machine.
14:33:39 <prophile> meretrix: run it in docker and change the system clock in the container
14:34:07 <happy4crazy> Can someone explain when I would want to use Attoparsec vs. Data.Binary for parsing a binary network protocol?
14:34:29 <happy4crazy> I've written little parsers with both, and it's not clear to me when I would chose one over the other.
14:34:32 <merijn> happy4crazy: Binary is good for fixed/known length fields, attoparsec is nicer for variable length
14:34:42 <meretrix> Ok thanks.  I figured that wouldn't be a generally accepted approach to testing.
14:34:55 <shachaf> If only Milan was on IRC. :-(
14:35:19 <merijn> happy4crazy: attoparsec has things like takeTill, takeWhile, etc. binary does not
14:35:25 <happy4crazy> merijn: I see.
14:35:41 <fread2282> happy4crazy: Data.Bnary is good if both ends are haskell and your code
14:35:52 <happy4crazy> fread2282: Ah, interesting.
14:36:26 <happy4crazy> Ok, silly question: how would you write e.g. word16be in Attoparsec? Use anyWord8 twice and combine the results?
14:37:29 <happy4crazy> I'm slightly surprised that's not a built-in parser.
14:39:34 <SrPx> Hello, I have 2 "Maybe Int", a and b. What is the shortest way to do this? {case a of {Just x) → x; Nothing → case b of (Just x) → x; Nothing → 0}
14:39:50 <stalintrotsky> use the monoid instance
14:39:54 <stalintrotsky> a <> b
14:40:00 <stalintrotsky> I think that's in Data.Monoid?
14:40:22 <SrPx> Ah, that gets the one that is not "nothing"? I expected it to be Nothing if any of them is Nothing. hmm
14:40:28 <SrPx> > Nothing <> (Just 1)
14:40:30 <lambdabot>  No instance for (GHC.Show.Show a0)
14:40:30 <lambdabot>    arising from a use of ‘M208675882571539751623001.show_M2086758825715397516...
14:40:30 <lambdabot>  The type variable ‘a0’ is ambiguous
14:40:30 <lambdabot>  Note: there are several potential instances:
14:40:30 <lambdabot>    instance [safe] GHC.Show.Show
14:40:40 <SrPx> hm woops. well I will test here, htanks!
14:40:41 <spaceloop> or use Alternative, from Control.Applicative: a <|> b
14:40:50 <HeladoDeBrownie> No, you don't want the Monoid instance of Maybe, you want First
14:40:52 <Twey> What does the dot-backslash mean in GHC's profiling output?  I see a lot of things marked foo.\ or foo.\/bar
14:41:08 <HeladoDeBrownie> The Monoid instance of First, that is
14:41:45 <HeladoDeBrownie> getFirst (First a <> First b) -- or the like
14:41:49 <quchen> :t \a b -> fromMaybe 0 (a <|> b)
14:41:50 <lambdabot> Num a => Maybe a -> Maybe a -> a
14:42:05 <fread2282> > Nothing <> Just Bool
14:42:07 <lambdabot>  Not in scope: data constructor ‘Bool’
14:42:09 <fread2282> > Nothing <> Just True
14:42:10 <HeladoDeBrownie> The Maybe Monoid would use the Int Monoid instance and end up adding them if both were a Just
14:42:11 <lambdabot>  No instance for (Data.Monoid.Monoid GHC.Types.Bool)
14:42:11 <lambdabot>    arising from a use of ‘Data.Monoid.<>’
14:42:23 <HeladoDeBrownie> iirc
14:42:23 <quchen> Int doesn't have a monoid instance
14:42:34 <HeladoDeBrownie> Ah, in that case you couldn't use it
14:42:41 <fread2282> > Nothing <|> Just True
14:42:43 <lambdabot>  Just True
14:42:43 <quchen> You have to explicitly wrap it in Sum or Product to choose which of the possible ones you want
14:42:47 <merijn> happy4crazy: There is like an attoparsec-binary library that has parsers like that
14:42:54 <HeladoDeBrownie> > Just 10 <> Just 20
14:42:56 <lambdabot>  No instance for (GHC.Show.Show a0)
14:42:56 <lambdabot>    arising from a use of ‘M689622848481894199723108.show_M6896228484818941997...
14:42:56 <lambdabot>  The type variable ‘a0’ is ambiguous
14:42:56 <lambdabot>  Note: there are several potential instances:
14:42:56 <lambdabot>    instance [safe] GHC.Show.Show
14:43:01 <SrPx> hmmm
14:43:03 <fread2282> SrPx: use <|>
14:43:09 <HeladoDeBrownie> > First (Just 10) <> First (Just 20)
14:43:11 <lambdabot>  First {getFirst = Just 10}
14:43:19 <merijn> HeladoDeBrownie: There is no Int monoid :)
14:43:29 <HeladoDeBrownie> merijn, I got that already
14:43:31 <quchen> merijn: There is no Int Monoid. :-þ
14:43:32 <HeladoDeBrownie> I was merely demonstrating
14:43:36 <merijn> HeladoDeBrownie: There's a Sum and Product newtype with a monoid, though
14:43:44 <HeladoDeBrownie> This information was stated mere seconds ago :P
14:44:06 <fread2282> oh nvm
14:44:20 <fread2282> > Nothing <|> Just 1 <|> Just 0
14:44:22 <SrPx> Yea <o> works nicely indeed.
14:44:22 <lambdabot>  Just 1
14:44:25 <SrPx> <|>
14:44:25 <fread2282> that
14:44:31 <fread2282> > Nothing <|> Nothing <|> Just 0
14:44:33 <lambdabot>  Just 0
14:44:46 <HeladoDeBrownie> Yeah, that does essentially the same as the First stuff I mentioned
14:45:11 <fread2282> wait, fromMaybe is probably better
14:45:15 <HeladoDeBrownie> I'd agree (<|>) is probably prettier here
14:45:19 * hackagebot spice 0.3.2.2 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.3.2.2 (Crockeo)
14:45:26 <fread2282> > fromMaybe 0 (Nothing <|> Just 1)
14:45:28 <lambdabot>  1
14:45:34 <fread2282> > fromMaybe 0 (Nothing <|> Nothing)
14:45:36 <lambdabot>  0
14:46:02 <spaceloop> you can often read <|> as "or", which I think is the most intuitive solution in this case, I tend to read <> often as "combine", but use whatever you like
14:46:25 <fread2282> I read <> as "op" :)
14:46:43 <SrPx> I don't get the actual meaning of <|> though. Is there an "and" similar to it?
14:47:01 <TheKing44> :t foldr (<|>)
14:47:02 <lambdabot> Alternative f => f a -> [f a] -> f a
14:47:03 <Peaker> SrPx: I think <*> is the "and"
14:47:05 <spaceloop> I think that <*> comes the closest to and
14:47:10 <quchen> Peaker: Was about to suggest that too
14:47:12 <spaceloop> :t (<*>)
14:47:13 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
14:47:25 <spaceloop> but it has to combine in a different way
14:47:34 <Peaker> * is product, | is sum, so it makes sense by the names too :)
14:47:57 <hpc> it's true
14:48:04 <spaceloop> a different "and" might have been
14:48:06 <spaceloop> <*> :: Applicative f => f a -> f b -> f (a,b)
14:48:10 <spaceloop> but that doesn't compose very nicely
14:48:14 <hpc> like the arithmetic operations you learn in school, *, ;, |, &
14:49:12 <quchen> spaceloop: That alternative formulation exists, but is mostly used for educational purposes.
14:49:36 <quchen> It's usually called (**).
14:49:38 <fread2282> > :t (,b) <*> a
14:49:40 <lambdabot>  <hint>:1:1: parse error on input ‘:’
14:49:47 <fread2282> :t (,b) <*> a
14:49:48 <lambdabot>     Couldn't match type ‘(t, Expr)’ with ‘a0 -> b’
14:49:49 <lambdabot>     Expected type: t -> a0 -> b
14:49:49 <lambdabot>       Actual type: t -> (t, Expr)
14:49:57 <fread2282> :(
14:50:00 <spaceloop> :t (,b) <$> a
14:50:01 <lambdabot>     Couldn't match expected type ‘f a’ with actual type ‘Expr’
14:50:02 <lambdabot>     In the second argument of ‘(<$>)’, namely ‘a’
14:50:02 <lambdabot>     In the expression: (, b) <$> a
14:50:33 <quchen> :t \a b -> (,b) <$> a -- you need to define your variables.
14:50:35 <lambdabot> Functor f => f a -> t -> f (a, t)
14:50:50 <fread2282> :t a
14:50:51 <lambdabot> Expr
14:50:59 <fread2282> :t b
14:51:00 <lambdabot> Expr
14:51:23 <bvad> ~.
14:51:26 <bvad> ~>
14:56:28 <fread2282> > Og \a b -> (\c -> (,)  <$> a <*> c) <$> b
14:56:29 <lambdabot>  <hint>:1:4: parse error on input ‘\’
14:56:39 <fread2282> :t \a b -> (\c -> (,)  <$> a <*> c) <$> b
14:56:40 <lambdabot> (Applicative f1, Functor f) => f1 a1 -> f (f1 a) -> f (f1 (a1, a))
14:57:23 <fread2282> :t \a b -> (\c -> (,) <$> a <*> b)
14:57:25 <lambdabot> Applicative f => f a1 -> f a -> t -> f (a1, a)
14:57:30 <fread2282> :t \a b -> (,) <$> a <*> b
14:57:31 <lambdabot> Applicative f => f a1 -> f a -> f (a1, a)
14:57:38 <fread2282> that's better
14:58:36 <Iceland_jack> :t liftA2 (,)
14:58:38 <lambdabot> Applicative f => f a -> f b -> f (a, b)
15:01:10 <johnw> fread2282: you may want to /query lambdabot and talk to him directly
15:07:27 <dolio> You do not want to keep doing it here. :)
15:36:29 <benzrf> :t Og
15:36:31 <lambdabot> Not in scope: data constructor ‘Og’
15:36:32 <benzrf> ??
15:36:47 <int-e> what did you expect?
15:37:19 <int-e> @hoogle Og
15:37:22 <lambdabot> package OGL
15:37:22 <lambdabot> Prelude log :: Floating a => a -> a
15:37:22 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
15:38:42 <benzrf> 05:55 < fread2282> > Og \a b -> (\c -> (,)  <$> a <*> c) <$> b
15:38:52 <fread2282> rofl
15:39:01 <fread2282> it was a typo of :t
15:39:04 <benzrf> oh lmao
15:46:19 <pyon> @hoogle (a,b) -> (b,a)
15:46:23 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
15:46:23 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
15:46:23 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
15:58:19 <stalintrotsky> @pf f x = g . f x
15:58:19 <lambdabot> Maybe you meant: pl bf
15:58:30 <stalintrotsky> @pl f x = g . f x
15:58:30 <lambdabot> f = fix ((g .) .)
15:59:05 <exio4> @pl f x y = y x x
15:59:06 <lambdabot> f = flip =<< flip id
15:59:18 <exio4> neat
16:00:48 <Jesin> @unpl flip id >>= flip
16:00:49 <lambdabot> (\ h -> (\ e f g -> e g f) (\ c -> c h) h)
16:00:58 <Jesin> @unpl f = flip id >>= flip
16:00:58 <lambdabot> f h = (\ e f g -> e g f) (\ c -> c h) h;
16:01:26 <Jesin> @unpl f = flip =<< flip id
16:01:26 <lambdabot> f g c = (\ e f -> f e) g c g;
16:01:46 <stalintrotsky> @pl f g x y z a = f x y . g z a $ x
16:01:47 <lambdabot> f = fix (flip flip id . (liftM2 (flip . ((flip . (flip .)) .)) .) . flip . ((flip . (((.) . (.) . (.)) .)) .))
16:02:09 <Jesin> https://en.wikipedia.org/wiki/Categorical_quantum_mechanics
16:05:06 <BMeph> @pl h f g x y z a = f x y . g z a $ x
16:05:06 <lambdabot> h = flip flip id . (liftM2 (flip . ((flip . (flip .)) .)) .) . flip . ((flip . (((.) . (.) . (.)) .)) .)
16:06:51 <lowfyr> Hello everyone
16:07:13 <vanila> hi
16:07:49 <shiona> hello
16:08:30 <vanila> my constraint solving is not working :(
16:09:44 <merijn> hmmm
16:09:49 <colordrops> NSFW
16:10:22 <merijn> If I try to build with cabal using "-dynamic-too" I get an error with integer-gmp
16:10:45 <merijn> "Failed to load interface for ‘GHC.Integer.Type’ Perhaps you haven't installed the "p_dyn" libraries for package ‘integer-gmp’?"
16:13:20 <quchen> "build cabal"?
16:13:31 <quchen> Via bootstrapping or using Cabal?
16:13:52 <quchen> Oh, *with* cabal.
16:14:00 <merijn> Actually
16:14:08 <augur> sow hats the best way to do low-level audio programming in haskell? something that will give me access to the waveform data, and maybe to spectrographic data?
16:14:11 <merijn> Every single library seems to fail with missing p_dyn
16:14:22 <quchen> Seems like you didn't build with dynamic+profiling then
16:14:38 <merijn> quchen: How do I do that?
16:15:12 <merijn> I have both "shared: True" and "library-profiling: True" in .cabal/config
16:15:23 <merijn> I'm not sure what else I would be supposed to do?
16:16:01 <quchen> Hmm yeah I don't see a setting as well. Maybe your GHC wasn't built with dynamic libs enabled?
16:16:18 <quchen> The standard build includes only default and profiling, if I recall correctly
16:16:35 <merijn> quchen: I just have the 7.8.3 from haskell platform
16:16:58 <merijn> That's annoying, it means that I have to do complicated stuff to get ghci too work :\
16:17:25 <enthropy> do we sort of have type inference for RankN types?
16:17:26 <quchen> I don't know what the Platform includes :-(
16:17:29 <merijn> ghci was ignoring my .o files since it wants dynamic files, but if I specify "-dynamic-too" in my cabal file it fails because it can't build profiled+dynamic
16:17:39 <quchen> enthropy: "sort of". In general it's undecidable.
16:17:41 <enthropy> something like https://gist.github.com/aavogt/823f60e9d474ab788b30 could be better integrated with the language, right?
16:21:07 <quchen> merijn: Are there any p_dyn files in your GHC directory?
16:21:41 <quchen> Should be in ghc-$version/lib/
16:21:58 <merijn> quchen: no
16:22:14 <merijn> Frankly I don't care about "profiling + dynamic"
16:22:25 <merijn> I just want cabal repl to load the files build by cabal build
16:23:35 <elaforge> merijn: I don't know if this applies to you, but there's a ghc bug where it doesn't load the o_dyn if you use -dynamic-too
16:24:03 <elaforge> you have to use just -dynamic
16:24:33 <merijn> elaforge: If I use -dynamic cabal crashes on the fact that I don't have any "dynamic + profiling" libraries
16:24:54 <elaforge> yeah, I don't pass -dynamic for profiling
16:25:03 <elaforge> but I don't use cabal, so if it's a cabal problem I don't know
16:25:28 <merijn> I don't pass -dynamic for profiling either, but somehow it still complains
16:25:58 <Rufflewind> does anyone know of a lightweight library that supports HTTPS?
16:26:02 <merijn> ok, ":set -fobject-code" in .ghci seems to work
16:26:04 <elaforge> what if you compile by hand?
16:26:20 <elaforge> yeah, that makes it compile each time before loading
16:26:30 <elaforge> works, but slow
16:28:07 <quchen> Rufflewind: wreq supports TLS
16:28:09 <dfeuer> Is GHCi supposed to be able to run optimized code with -fobject-code? Or just compile code unoptimized or load unoptimized code?
16:28:46 <elaforge> it should compile and run optimized, if you pass -O[12]
16:28:52 <merijn> elaforge: Right now it's *already* compiling each time before loading
16:28:53 <dfeuer> Hrmmm
16:29:12 <merijn> I just want it to fucking load the object files I already have >.<
16:29:47 <merijn> This shouldn't be so stupidly complicated to get working
16:29:50 <elaforge> yeah, I spent some time getting that to work
16:29:56 <elaforge> but it was due to the -dynamic-too ghc bug
16:30:19 <elaforge> ghc -c -dynamic T.hs, then ghci :l T
16:30:26 <merijn> Well, -dynamic-too isn't working, -dynamic also isn't working
16:30:32 <elaforge> should load without the "compiling bytecode" thing
16:30:46 <merijn> elaforge: I have a 13 files (and growing) cabal project, I'm not going to compile everything by hand
16:30:56 <int-e> merijn: https://ghc.haskell.org/trac/ghc/ticket/8736 ... -dynamic *should* be working, but how do you get cabal to not use -dynamic-too?
16:30:58 <merijn> Especially since I keep running "cabal build" to check for type errors
16:31:17 <merijn> int-e: I have no clue what I'm doing, I just run "cabal build"
16:31:38 <int-e> merijn: then what did you mean by "-dynamic also isn't working"?
16:31:55 <Rufflewind> quchen: thanks!
16:32:08 <merijn> int-e: If I add "-dynamic" to my ghc-options in my cabal file the compile gives up on missing "p_dyn" files
16:32:27 <merijn> Could not find module ‘Control.Lens’ Perhaps you haven't installed the "p_dyn" libraries for package ‘lens-4.1.2.1’?
16:33:03 <merijn> I have "shared: True" and "library-profiling: True" in my .cabal/config, I have no clue why this nonsense doesn't work
16:36:04 <int-e> merijn: oh, here's something that seems to work: add a cabal.config file containgin library-vanilla: False and shared: True; then cabal build; cabal repl --ghc-options='-osuf dyn_o -hisuf dyn_hi'
16:37:01 <int-e> merijn: the library-vanilla: False makes cabal-install use '-dynamic' rather than '-dynamic-too' when compiling. but 'cabal repl' still wouldn't find the object files by itself.
16:37:51 <merijn> int-e: But then it doesn't build static libraries, no?
16:37:56 <int-e> merijn: right
16:38:03 <merijn> But I *want* static libraries
16:38:23 <merijn> I just also want to not wait like 2 mins while ghci compiles stuff that I have *already* compiled
16:39:52 <int-e> merijn: yeah, but it seems that right now that isn't possible, because there's no way to get ghci to accept object files compiled with -dynamic-too, nor to get cabal-install not use -dynamic-too when both shared and vanilla objects are requested. (I may be wrong about the latter)
16:39:59 <elaforge> I just switched to all-dynamic, links a lot faster too
16:40:35 <merijn> >.<
16:41:14 <merijn> Who the hell thought it was a good idea to break ghci's ability to load object files and then not fix it before release...
16:41:38 <shachaf> What happened to my documentation in http://hackage.haskell.org/package/nonfree-0.1.0.0/docs/Data-Monoid-Nonfree.html ?
16:41:49 <shachaf> When I ran cabal haddock it generated it properly.
16:41:58 <int-e> merijn: of course you could also build a non-dynamic ghc (seting DYNAMIC_GHC_PROGRAMS to NO in build.mk).
16:42:28 <int-e> merijn: I don't know whether thay will run into problems with cabal-install later (in connection with Template Haskell, perhaps)
16:42:46 <merijn> shachaf: Hackage generates documentation as batch job
16:42:56 <shachaf> merijn: Yes, but it generated the documentation.
16:43:05 <merijn> shachaf: Also, it only generates docs if your package compiles on the hackage machine
16:43:06 <shachaf> It just doesn't have the paragraph in it.
16:43:13 <shachaf> It generated a documentation file. I linked to it.
16:43:20 <shachaf> But it's missing the bulk of my documentation.
16:43:20 <kristof> I've got a serious question about the implementation of lazy sequences. If I take 5 from mapping over some list, do I force 5 thunks, or am I just iterating five times without any thunk creation?
16:43:34 <merijn> shachaf: heh, odd
16:43:47 <merijn> shachaf: You can manually overwrite it, though
16:43:58 <merijn> shachaf: Have you checked the build log?
16:43:58 <shachaf> Yes, but I want it to be generated correctly.
16:44:19 <shachaf> No. Where is the build log?
16:44:28 <int-e> kristof: normally you'll be forcing 5 thunks. when the code is compiled, fusion may kick in and eliminate the thunks.
16:44:55 <merijn> shachaf: Hidden far away, see here: http://fuuzetsu.co.uk/blog/posts/2014-01-06-Fix-your-Hackage-documentation.html
16:45:04 <kristof> int-e: how likely is that if the map only appears once?
16:45:14 <hpc> kristof: in ghci you can use :sprint <var> to see how evaluated something is
16:45:23 <hpc> thunks will be _
16:45:25 <elaforge> shachaf: is it the os x thing?
16:45:38 * hackagebot cookbook 3.0.0.1 - Tiered general-purpose libraries with domain-specific applications.  http://hackage.haskell.org/package/cookbook-3.0.0.1 (NatePisarski)
16:45:40 <elaforge> the latest versions of Cabal have a fix
16:45:42 <shachaf> elaforge: I don't know. I don't use OS X, if that's what you mean.
16:45:48 <elaforge> oh, ok, something different then
16:45:54 <hpc> it's a bit weird for lists but if you take 5 from a list
16:45:55 <shachaf> "cabal haddock" on my machine works fine.
16:46:02 <shachaf> By which I mean it generates the documentation I expect.
16:46:09 <hpc> you should end up with _ at first
16:46:20 <hpc> you can evaluate the spine of the list (for instance, with length)
16:46:30 <hpc> and then get [_,_,_,_,_]
16:46:32 <kristof> Right.
16:46:37 <glguy> shachaf: http://hackage.haskell.org/package/nonfree-0.1.0.0/reports/1/log
16:46:46 <glguy> haddock module header parse failed: Cannot parse header documentation paragraphs
16:46:55 <kristof> hpc: but there's no way to skip the boxing?
16:47:02 <shachaf> glguy: Aha. Thanks.
16:47:08 <int-e> kristof: it depends on the list. take 5 (map f xs)  will fuse (there will be no intermediate list between the 'take' and the 'map'), but beyond that it depends on what xs looks like.
16:47:30 <glguy> shachaf: also, http://hackage.haskell.org/package/nonfree-0.1.0.0/reports/1 for version info
16:47:50 <kristof> int-e: that's what I'm looking for, thank you. Are there any papers on this stream fusion stuff in general?
16:48:09 <kristof> int-e: Especially something that might apply to an eager language.
16:48:22 <shachaf> Do I need the "-- Module: ...\n-- Author: ...\n..." business at the beginning of my documentation?
16:48:51 <hpc> shachaf: that info should be in the cabal file already
16:48:58 <hpc> i would only put stuff that you actually need
16:48:59 <thenewguy> hello
16:49:11 <shachaf> I don't need anything.
16:49:13 <sh1ken> hi
16:49:14 <hpc> -- | module descriptions
16:49:18 <hpc> or a license text
16:49:37 <shachaf> How would you improve http://hackage.haskell.org/package/nonfree-0.1.0.0/docs/src/Data-Monoid-Nonfree.html ?
16:49:58 <thenewguy> um. first time on irc
16:50:04 * thenewguy this is a thing right?
16:50:24 <thenewguy> um.... looking over a book about haskell.... and I"ve been a dev for a while
16:50:38 <thenewguy> wtf....... is [1,2,3] > [1,10,100]
16:50:45 <thenewguy> and why is it true?
16:50:49 <hpc> shachaf: looks good; the only nit i can pick is that the httpd needs to serve the file as utf-8
16:51:00 <Iceland_jack> thenewguy: it isn't
16:51:02 <hpc> > [1,2,3] > [1,10,100]
16:51:03 <Iceland_jack> > [1,2,3] > [1,10,100]
16:51:04 <lambdabot>  False
16:51:05 <lambdabot>  False
16:51:08 <glguy> shachaf: I'd start by getting the lines under 80 characters
16:51:13 <shachaf> hpc: Here is the documentation Hackage generates: http://hackage.haskell.org/package/nonfree-0.1.0.0/docs/Data-Monoid-Nonfree.html
16:51:18 <glguy> is that what you were asking about?
16:51:19 <hpc> > (show [1,2,3]) > (show [1,10,100])
16:51:22 <lambdabot>  True
16:51:30 <thenewguy> excuse me the example was [3,2,1] > [2,10,100]
16:51:42 <Iceland_jack> thenewguy: Yes that's true
16:51:45 <hpc> shachaf: doh, i see
16:51:46 <Iceland_jack> It's element-wise
16:51:59 <shachaf> glguy: Whoops. I guess I'll fix that, maybe.
16:52:03 <hpc> shachaf: you might need to have that pipe on every line of the top description
16:52:30 <Iceland_jack> thenewguy: The definition is here https://hackage.haskell.org/package/base-4.3.1.0/docs/src/GHC-Classes.html if you search for "instance (Ord a) => Ord [a] where"
16:52:36 <thenewguy> so element wise its comparing using >
16:52:45 <hpc> thenewguy: yes
16:52:46 <thenewguy> so 2 > 1 true
16:52:47 <shachaf> glguy: I'm asking about none of that text showing up at all.
16:52:52 <Iceland_jack> yes basically (using ‘compare’ strictly speaking)
16:52:56 <Iceland_jack> > compare 2 1
16:52:57 <thenewguy> hmmmmmm
16:52:58 <lambdabot>  GT
16:52:59 <Iceland_jack> > 2 > 1
16:53:00 <thenewguy> but
16:53:01 <lambdabot>  True
16:53:02 <hpc> thenewguy: basically, it's what makes [Char] do dictionary ordering
16:53:07 <thenewguy> 2 > 10?
16:53:09 <glguy> I,I just wanted to participate like everyone else
16:53:28 <hpc> thenewguy: it isn't unless you were doing something different than what you asked
16:53:29 <Iceland_jack> thenewguy: '2 > 10' is False, this is just the ordering you'd expect
16:53:56 <thenewguy> so, piece by piece what is > doing on those lists?
16:54:03 <thenewguy> is it only comparing head?
16:54:20 <Iceland_jack> thenewguy: Only if both lists have a head
16:54:26 <hpc> @src [] (>)
16:54:26 <lambdabot> Source not found. You untyped fool!
16:54:29 <hpc> :(
16:54:46 <glguy> shachaf: Might poke around in haddocks' ./src/Haddock/Interface/ParseModuleHeader.hs
16:54:53 <glguy> shachaf: where the parsing actually happens
16:55:03 <thenewguy> so.... thats all it cares about. so confusing
16:55:11 <thenewguy> < vs <=?
16:55:15 <Iceland_jack>     compare []     []     = EQ
16:55:15 <Iceland_jack>     compare []     (_:_)  = LT
16:55:15 <Iceland_jack>     compare (_:_)  []     = GT
16:55:15 <Iceland_jack>     compare (x:xs) (y:ys) = case compare x y of
16:55:16 <shachaf> glguy: It works when I cabal haddock.
16:55:18 <Iceland_jack>       EQ    -> compare xs ys
16:55:22 <Iceland_jack>       other -> other
16:55:23 <glguy> shachaf: which version of haddock?
16:55:25 <Iceland_jack> thenewguy: How is that confusing?
16:55:32 <thenewguy> i guess its not
16:55:35 <glguy> shachaf: the build system is using ghc 7.6.3 and presumably that version's haddock
16:55:37 <shachaf> haddock --version says 2.14.2
16:55:39 <thenewguy> the fact it only compares head actually
16:55:42 <shachaf> Hmm, I'll try 7.6
16:55:51 <Iceland_jack> thenewguy: It doesn't only compare the head
16:56:04 <Iceland_jack> If the head of both lists are equal, then it compares the rest
16:56:13 <Iceland_jack> <Iceland_jack>     compare (x:xs) (y:ys) = case compare x y of
16:56:13 <Iceland_jack> <Iceland_jack>       EQ    -> compare xs ys
16:56:13 <Iceland_jack>  
16:56:51 <thenewguy> <Iceland_jack> but...... hold on let me look at this thing again
16:56:59 <Iceland_jack> Sure
16:57:25 <int-e> merijn: ok, here's another workaround: in your foo.cabal file, add  ghc-shared-options:  -v1  ... that way the shared objects will be compiled separately. Then use cabal repl --ghc-options '-osuf dyn_o -hisuf dyn_hi'
16:57:27 <shachaf> I don't have haddock for 7.6.3. Sigh.
16:58:02 <int-e> merijn: (the Cabal code checks whether ghc-shared-options is empty before using -dynamic-too)
16:59:14 <int-e> merijn: but that way, a full 'cabal build' will be slower, of course. it should not affect the time required for finding the first compilation error.
16:59:22 <thenewguy> <Iceland_jack> so it does, 1) head comparison. if equal, continue until first non equal type
16:59:30 <thenewguy> type is such a terrible choice of word
16:59:32 <thenewguy> comparison
16:59:43 <Iceland_jack> thenewguy: Yes, that's the right idea
16:59:52 <thenewguy> so.... then when they are not equal for the first time, it fires off the operator you've specified
17:00:04 <thenewguy> and returns the value of that evaluation
17:00:22 <thenewguy> that is something I've never seen in a language before
17:00:28 <thenewguy> but now it makes sense. thank you so much
17:00:50 <Iceland_jack> And if two lists are equal up to a point, but one of them is shorter then that list will be 'less'
17:01:02 <thenewguy> perfect
17:01:02 <Iceland_jack> > compare "ab" "abc"
17:01:04 <lambdabot>  LT
17:01:14 <kristof> In other words, comparing lists is useless.
17:01:22 <int-e> kristof: huh?
17:01:48 <thenewguy> <Iceland_jack> is that kind of operator specific to haskell or functional programming? I've just never seen an operator like that before
17:02:00 <thenewguy> <kristof> lol
17:02:02 <kristof> int-e: the instance definition is arbitrary and there's no good reason to compare lists that way :P
17:02:03 <Iceland_jack> thenewguy: What operator are you referring to?
17:02:04 <silver_> > sort ["zxe","bad","axc"]
17:02:05 <int-e> kristof: it's a total order if the order on elements is; furthermore, this lexicographic order is fairly standard.
17:02:06 <lambdabot>  ["axc","bad","zxe"]
17:02:12 <thenewguy> > in reference to lists
17:02:14 <lambdabot>  <hint>:1:1: parse error on input ‘in’
17:02:37 <thenewguy> the whole gamut of comparison operators i suppose.
17:02:58 <thenewguy> like if i hit up lisp, does it also perform that comparison in kind, or is it a haskell thing?
17:03:30 <int-e> python does it that way, too.
17:03:52 <merijn> int-e: I'll try that
17:03:53 <kristof> thenewguy: operator overloading is not present in lisp
17:04:38 <Iceland_jack> In [1]: cmp([1,2], [1,2,3])
17:04:38 <Iceland_jack> Out[1]: -1
17:04:50 <Iceland_jack> In [2]: [1,2] < [1,2,3]
17:04:50 <Iceland_jack> Out[2]: True
17:04:54 <Iceland_jack> this should be that surprising
17:05:32 <thenewguy> this place is as awesome as people said it would be
17:05:34 <Iceland_jack> http://www.tutorialspoint.com/python/list_cmp.htm this describes how the Python one works, it's more involved than the Haskell version for obvious reasons
17:05:35 <thenewguy> very helpful stuff
17:06:05 <silver_> I think even strcmp works the same way
17:06:20 <silver_> in C
17:06:20 <merijn> Of course
17:06:28 <merijn> It's the only sensible way to compare strings
17:06:37 <merijn> What else would you compare?
17:07:12 <int-e> merijn: sometimes it's nice to compare the length first, then the elements (lexicographically)
17:07:53 <drdo> int-e: For example?
17:08:28 <Iceland_jack> thenewguy: This can be useful if you want to compare many things, you can do something like
17:08:28 <Iceland_jack>     [a1, b1, c1] < [a2, b2, c2]
17:08:32 <int-e> (actually the motivation is a bit theoretical: the nice thing about comparing the length first is that it gives a well-founded order if the order on elements is well-founded)
17:08:54 <Rufflewind> it's a lexicographical ordering (see Wikipedia); pretty much any sane language does the same thing
17:09:14 <thenewguy> very cool
17:09:17 <thenewguy> thank you guys so much
17:09:23 <Iceland_jack> thenewguy: You're very welcome
17:09:25 <merijn> More importantly, if you want to sort a list of strings you generally want lexicographical ordering
17:09:48 <int-e> this has a practical consequence, too: one can enumerate strings over a finite alphabet that way: enumerate those of length 0, then of length 1, then of length 2, etc.
17:10:39 <int-e> that said I wouldn't make it the default way of comparing lists in any language; the lexicographic order is much more common.
17:10:57 <drdo> We're talking about list orders right? (just clarifying since people keep saying strings and lists)
17:11:12 <thenewguy> string is a list though right?
17:11:14 <merijn> drdo: Well, haskell strings are just lists of Char :)
17:11:15 <int-e> drdo: yes.
17:11:19 <Iceland_jack> int-e: also in Haskell getting the length of a [] list is expensive
17:11:20 <drdo> That's precisely my point
17:11:23 <thenewguy> boom. i knew a thing
17:11:28 <Iceland_jack> > ['a', 'b', 'c'] == "abc"
17:11:30 <lambdabot>  True
17:11:46 <drdo> Iceland_jack: What do you mean?
17:11:49 <int-e> drdo: once you know how to compare strings, there's really only one way to generalise it to lists over ordered types that are not characters.
17:12:15 <merijn> drdo: Getting the length of a list is O(n)
17:12:21 <Rufflewind> a List in Haskell does not keep track of its length, so inquiring its length requires traversing the whole list every time
17:12:22 <thenewguy> this has all been super helpful. downloaded an irc client just for this room
17:12:31 <thenewguy> you shall all be pestered again
17:12:38 <Iceland_jack> Bring it on thenewguy
17:12:43 <thenewguy> gonna get back to my tutorial for the moment
17:12:52 <drdo> merijn: Indeed, but why is that relevant to the question
17:12:52 <thenewguy> Iceland_jack it shall be brought
17:13:37 <merijn> drdo: It means that comparing two long lists that differ in their first argument is really cheap with lexicographical order and comparing length first is really expensive
17:13:40 <drdo> I'm assuming Iceland_jack meant the empty list when he wrote "[] list"
17:14:10 <Iceland_jack> drdo: I actually meant the Haskell's linked list, [] is the type constructor
17:14:17 <drdo> I see
17:14:29 <Iceland_jack> Since there are links where the length is O(1), bad way of disambiguating
17:18:53 <Rufflewind> has there been any recent efforts to allow Cabal to have multiple packages with the same name and versions?
17:19:21 <drdo> Isn't that already working? I have multiple versions of the same package installed right now
17:19:39 <drdo> At least i think i do (ghc-pkg list reports them)
17:19:47 <merijn> Rufflewind: Yes
17:20:01 <merijn> Rufflewind: ezyang's backpack stuff
17:20:46 <Rufflewind> merijn: Backpack was what prompted me to ask in the first place hehe
17:21:06 <Rufflewind> drdo: I meant *same* versions
17:21:18 <Rufflewind> to avoid the dread diamond hell
17:23:08 <merijn> Rufflewind: Right, well it's part of the backpack work :)
17:23:26 <slack1256> Last time I heard backpack had yet to develop theory to deal with typeclasses
17:23:37 <slack1256> What was decided back then?
17:24:04 * slack1256 really wants backpack
17:50:32 <stalintrotsky> How is fix usually used?
17:51:34 <Iceland_jack> 'fix' is more of a theoretical curiosity than anything, but it can be useful for defining evaluators for languages with fixed points and such
17:51:38 <hpc> it's usually not used because there's more applicable abstractions, so it's hard to say
17:52:12 <Iceland_jack> but since Haskell has recursion you can write
17:52:13 <Iceland_jack>     foo 1 = 1
17:52:13 <Iceland_jack>     foo n = n * foo (n-1)
17:52:13 <Iceland_jack> rather than
17:52:16 <Iceland_jack>     foo = fix (\f n -> if n == 1 then 1 else n * f (n-1))
17:52:54 <Algebr> did State monad change from 7.6 to 7.8? I thought :i State would give back a newtype but it gives a type State s
17:52:59 <hpc> fix is sometimes used to make infinite structures without giving them a name, but usually in those cases it's more clear to just name it
17:53:09 <Iceland_jack> You would prefer
17:53:09 <Iceland_jack>     repeat 1
17:53:09 <Iceland_jack> to
17:53:12 <Iceland_jack>     fix (1:)
17:53:27 <hpc> Algebr: it hasn't been a newtype for a long time
17:53:42 <hpc> been reading RWH?
17:53:53 <Algebr> and some tutorials on state
17:54:15 <Iceland_jack> Algebr: Some tutorials simplify the situation to make it easier to understand
17:55:01 <Algebr> Just high level understanding then, the State Monad is able to do what it does because of how it curries
17:55:47 * hackagebot backtracking-exceptions 0.1.0.0 - A monad transformer for backtracking exceptions  http://hackage.haskell.org/package/backtracking-exceptions-0.1.0.0 (tapuu)
17:56:12 <hpc> Algebr: for practical purposes, wherever in what you are reading you see the data constructor State, you can replace it with state
17:56:15 <hpc> :t state
17:56:16 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
17:56:37 <hpc> which is the same thing but with some jiggery-pokery to make it behave with the different type definition
17:56:50 <Iceland_jack> > runState (state (5,)) 20
17:56:52 <lambdabot>  (5,20)
17:58:54 <David> Is there a quick and easy way to remove and deregister all cabal-installed packages on a system?
17:59:19 <hpc> David: for a user or everyone?
17:59:25 <David> for everyone
17:59:34 <David> it doesn't really matter - I'm on a single user machine
17:59:44 <Algebr> rm -rf ~/.cabal ~/.ghc, would that work?
17:59:51 <David> I think so
17:59:57 <David> but there are some other things I think
17:59:57 <hpc> if you're using --global when you install packages then there's some concerns
18:00:05 <hpc> but if not Algebr is right
18:00:14 <David> /var/lib/ghc/package.conf.d
18:00:17 <David> apparently has something
18:00:23 <David> when I do ghc-pkg list
18:00:39 <David> is that just stuff in haskell-platform or do I have to watch out for that?
18:00:43 * hpc usually just installs a new ghc when faced with this problem, what better time to upgrade?
18:01:42 <David> thanks guys
18:03:28 <Algebr> having trouble with pandoc and slidy, getting errors when trying to give cmd action of slidy-url=./path/to/slidy/directory
18:05:19 <David> hmm... has anyone seen this error in lambdabot?
18:05:20 <David> lambdabot> > 2 + 3
18:05:20 <David>   mueval-core: GhcException "cannot satisfy -package lambdabot\n    (use -v for more information)"
18:08:52 <TheKing44> > 2 + 3
18:08:54 <lambdabot>  5
18:09:03 <David> naw, I mean on a local lambdabot install
18:09:10 <TheKing44> oh
18:09:29 <TheKing44> nope
18:09:47 <TheKing44> how did you install it?
18:10:28 <David> TheKing44: I just used apt
18:10:39 <David> I don't have enough memory and swap to compile deps for lambdabot on my vps
18:10:48 <TheKing44> try cabal
18:10:52 <David> and I don't want to deal with cross compiling
18:11:06 <David> not an option
18:11:07 <TheKing44> hmm
18:11:22 <TheKing44> try nix maybe
18:11:44 <bergmark> David: built in a sandbox?
18:11:56 <David> bergmark: I did not build it
18:12:01 <TheKing44> the didn't use cabal
18:12:01 <David> I used APT to install it
18:12:11 <David> my VPS has 512 mb ram and maybe 1gb of swap
18:12:34 <TheKing44> that aint enough?
18:12:48 <David> attempting to use cabal install lambdabot fails when it consumes all the memomry during compilation of ghc-src-exts
18:12:54 <TheKing44> what OS you doing
18:13:05 <David> latest ubuntu lts
18:13:06 <David> 14.04
18:13:27 <int-e> David: do you mean haskell-src-exts?
18:13:32 <David> yes
18:13:34 <David> right
18:13:58 <TheKing44> i think you could compile in on a Ubuntu box then and in would work on your vm fine
18:13:59 <dolio> I don't know why, but that package takes a lot of resources to compile.
18:14:10 <David> TheKing44: would be nice if I had a spare ubuntu box handy
18:14:29 <TheKing44> dual boot?
18:14:30 <David> unfortunately, I don't.
18:14:57 <David> and I don't have the time (or disk space) to download and install ubuntu
18:15:11 <TheKing44> nix package matador in probably more up to date that apt
18:15:14 <int-e> David: anyway, yes, I keep running into this as well. I usually end up unpacking it, and running 'cabal build' several times. Sometimes I had to disable -O for compiling the two modules that define the syntax datatypes.
18:15:37 <TheKing44> he doesn't use cabal
18:15:45 <mgsloan> It's the pesky deriving instances.  If you remove them it takes 3s instead of 40s to compile that module
18:16:09 <mgsloan> (not that that matters, something's up, there, probably related to huge case statements)
18:16:24 <int-e> TheKing44: unlikely, since the failing command was "cabal install lambdabot"
18:16:42 <TheKing44> he used apt
18:17:02 <David> I tried both
18:18:06 <int-e> David: (The VM that runs lambdabot has 512MB RAM and 512MB swap; this is quite enough for normal operation but tight for installation.)
18:18:13 <TheKing44> what if you write an irc that pms lambda bot for you
18:18:28 <David> int-e: hmm, I'm on a VM with the same RAM and a little more swap
18:18:40 <David> but it's also running quassel
18:18:46 <David> which sucks up a bit of memory
18:19:03 <David> but have you seen this error?
18:19:07 <David>   mueval-core: GhcException "cannot satisfy -package lambdabot\n    (use -v for more information)"
18:19:16 <David> when I run mueval normally it works
18:19:21 <TheKing44> did you use -v?
18:19:40 <Jesin> Is there anything I can put in my cabal.config to cause packages to be built with the LLVM backend by default?
18:19:41 <David> -v is apparently not an option for mueval
18:20:08 <TheKing44> then why was it suggested, that's odd
18:20:25 <dolio> Because it's just dumping errors from something else.
18:20:31 <TheKing44> oh
18:21:52 <TheKing44> So it has come to this.
18:21:53 <platz> has anyone done diehl's llvm compiler tutorial?  Thinking about doing it
18:22:11 <int-e> David: Sort of. There's two modules from the lambdabot package that it wants to use during evaluation. In the git repo, they are now in a separate package, lambdabot-trusted. This change has not made its way to hackage yet...
18:22:44 <int-e> David: in particular, this module: http://hackage.haskell.org/package/lambdabot-4.3.0.1/docs/Lambdabot-Plugin-Eval-Trusted.html
18:23:13 <David> hmm. I read in an article that you need to set trusted
18:23:18 <David> but this appears to be something else
18:23:29 <David> http://www.theunixman.com/posts/2014-06-25-lambdabot.html
18:23:35 <int-e> David: does ghci -package lambdabot  work?
18:23:51 <David> nope
18:23:52 <David> GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
18:23:52 <David> <command line>: cannot satisfy -package lambdabot
18:23:52 <David>     (use -v for more information)
18:24:09 <David> when I do it with -v
18:24:11 <int-e> David: oh are you running in a sandbox?
18:24:11 <David> I get target `lambdabot' is not a module name or a source file
18:24:25 <David> int-e: maybe? No clue... it's the default ubuntu install
18:24:49 <int-e> David: did you run any 'cabal sandbox' commands like on that page?
18:24:58 <David> no
18:25:01 <David> just lambdabot
18:25:14 <David> http://packages.ubuntu.com/trusty/amd64/lambdabot/filelist
18:25:27 <David> everything is in /usr/share/lambdabot or /usr/lib/haskell-packages
18:29:54 <David> so the question is
18:30:04 <David> how do I make it so that ghc -package lambdabot runs?
18:30:09 <David> here is the full error log
18:30:10 <int-e> David: hmm. that looks incomplete, there should be a file in  /var/lib/ghc/package.conf.d/  describing the package as well. Oh and then it would have to install all the dependencies.
18:30:52 * hackagebot haskell-neo4j-client 0.1.5.0 - A Haskell neo4j client  http://hackage.haskell.org/package/haskell-neo4j-client-0.1.5.0 (asilvestre)
18:30:59 <David> GHCi, version 7.6.3: http://www.haskell.org/ghc/  :? for help
18:30:59 <David> Glasgow Haskell Compiler, Version 7.6.3, stage 2 booted by GHC version 7.6.3
18:30:59 <David> Using binary package database: /usr/lib/ghc/package.conf.d/package.cache
18:30:59 <David> *** Deleting temp files:
18:30:59 <David> Deleting:
18:31:01 <David> *** Deleting temp dirs:
18:31:03 <David> Deleting:
18:31:05 <David> <command line>: cannot satisfy -package lambdabot
18:31:07 <David>     (use -v for more information)
18:31:47 <int-e> David: please use lpaste.net  for text longer than a line or two.
18:32:02 <David> whoops, sorry
18:34:19 <David> (btw, what should passwd.rc look like for lambdabot?)
18:34:44 <David> do I just put the nickserv password there or do I have to prefix it with something?
18:41:22 <int-e> David: But anyway, as I said, I'm afraid the package is incomplete. I'm not sure wether the list of trusted packages can be overridden with --trusted.
18:42:06 <int-e> David: as for passwd.rc, it contains a line "msg freenode:nickserv identify somepasswordorother" here. (that's not the actual password)
18:42:15 <David> ok, thanks
18:42:30 <David> (I'm trying to run lambdabot on another irc server, but nicksrev mostly works the same way there)
18:48:55 <David> hmm... odd. Lambdabot connects fine to freenode but doesn't like the other server... I need to introduce a delay
18:52:22 <int-e> David: ok, I gave it a try. If one runs  lambdabot --trust base  and starts with an empty  L.hs  file in lambdabot's state directory (~/.lambdabot/State) then at least basic @run (or >) commands work. So that overrides the builtin list of packages (at least for me). You can add more --trust packages, and hopefully make more of L.hs' contents work. It's not completely satisfying.
18:52:56 <co-dh> Hello, how do I know which directorys ghc (ld) search for libraries? I know you can pass -L to ghc, but I would like to make a link from where ghc search to my lib.
18:53:12 <David> Mainly all I want is >, so that works for me
18:53:14 <David> let me try it
18:53:24 <David> btw, is there a command that I can put in online.rc to make lambdabot wait?
18:53:31 <int-e> David: (ah, if you do that, don't forget to update Pristine.hs as well, since @undef  copies Pristine.hs to L.hs)
18:53:57 <David> the other irc server that I want to run it on needs a delay between connecting and sending messages (this happened with my homegrown irc bot too)
18:54:15 <David> I need to put a 500ms delay between initial connect and sending messages to connect properly
18:54:56 <splintax> co-dh: i don't know the answer to your question off the top of my head, but are you using cabal? it should make your build process simpler
18:56:01 <co-dh> splintax: yes, I"m using cabal. but I have a lib that is not at standard place ( I'm using nix), even cabal cannot find it. It's a C lib ( libncursesw)
18:56:09 <int-e> David: sorry, no. one recommendation I've gotten is to use an IRC bouncer like znc, which may help in this situation.
18:56:20 <splintax> co-dh: the answer to the question you asked seems to be "ghc --print-libdir" :-)
18:56:43 <splintax> actually wait maybe that's not for third-party libraries...
18:56:50 <David> aach
18:57:00 <David> Here's what I get wih lambdabot --trust base with empty L and Pristine
18:57:06 <David>   Could not find module `Test.IOSpec'
18:57:06 <David>  Use -v to see a list of the files searched for.
18:57:08 <hseg> I'm reading the Backpack paper. So far, there are two design decisions I don't understand. First, why is the module order made significant? Second, why aren't more general implementations accepted to fill holes?
18:57:21 <David> and then when I put in --trust Test.IOSpec, I get mueval-core: GhcException "cannot satisfy -package Test.IOSpec\n
18:57:51 <David> I'm gonna give building lambdabot another try tonight
18:58:28 <David> you said you could get haskell-src-exts to build by unpacking it and runnig cabal build a few times, right?
18:58:59 <int-e> David: yes.
18:59:08 <David> all right, thans
18:59:12 <David> I'll try it
18:59:15 <David> thanks for all the help int-e
19:02:31 <Dashkal> I've run into a chicken and egg situation installing the haskell platform on Centos 7.  How do I get my hands on cabal?  I've got as far as building and installing ghc (installed package version, used it to build ghc 7.8.3, installed in /usr/local, removed package version.
19:02:40 <co-dh> splintax: ghc --print-libdir is more for Haskell lib. for system lib like libncursesw, where ghc is searching?
19:04:22 <int-e> Dashkal: download the cabal-install sources, they come with a 'bootstrap.sh' script that should get you a running 'cabal' executable
19:04:34 <Dashkal> danke
19:05:20 <Dashkal> Erm, how would I determine my current version of base (to ensure I get the right cabal) without cabal?
19:05:32 <int-e> Dashkal: ghc-pkg list base
19:06:29 <int-e> Dashkal: since its tied to the compiler it will be 4.7.0.1.
19:06:50 <Dashkal> Danke
19:06:56 <Dashkal> Looks like latest should be fine then
19:08:36 <Sizur> @djinn (a -> b) -> a -> (b,a)
19:08:36 <lambdabot> f a b = (a b, b)
19:09:03 <Sizur> @pl f a b = (a b, b)
19:09:03 <lambdabot> f = ((,) =<<)
19:09:36 <Sizur> ahh, good old lambdabot ftw
19:10:47 <co-dh> I figure it out by use ldd.
19:10:48 <Sizur> ? (=<<)
19:11:06 <hseg> Sizur: (=<<) = flip (>>=)
19:11:34 <Sizur> and (>>=) = flip (=<<) -- i dont remember what either is
19:12:09 <hseg> Sizur: f =<< x = join (f <$> x)
19:12:14 <hseg> @ty (>>=)
19:12:15 <lambdabot> Monad m => m a -> (a -> m b) -> m b
19:12:26 <Sizur> ah it was @ty, thanks
19:12:28 <int-e> Monadic bind. @pl likes to use the (->) r monad, where a >>= b = \x -> b (a x) x
19:12:29 <Iceland_jack> Sizur: It's (flipped) bind, you don't need to know more than it's
19:12:29 <Iceland_jack>     (f =<< x) r = f r (r x)
19:12:46 <splintax> co-dh: nice one. so what's the directory? :P
19:13:13 <int-e> Iceland_jack: I think you messed that up.
19:13:32 <Sizur> ah right! (>>=) is bind! heh, i forgot...  that's what i get for not coding haskell for 3 years
19:13:46 <int-e> (f =<< x) r = f (x r) r
19:13:55 <Iceland_jack> yes you're right
19:14:18 <co-dh> I'm using nix, so it's something like libc.so.6 => /nix/store/94n64qy99ja0vgbkf675nyk39g9b978n-glibc-2.19/lib/libc.so.6,  somehow nix forget to add libncursesw, so I just link all libncursesw files to the glibc-2.19/lib folder .
19:14:42 <co-dh> not a perfect solution, but works for me.
19:14:51 <Sizur> thanks guys! this channel has always been as still is the best
19:15:25 <enthropy> co-dh: https://github.com/NixOS/nixpkgs/issues/3682
19:16:11 <Sizur> although, I thought @pl f a b = (a b, b) woudl have produced an arrow based solution instead of monadic.
19:16:27 <Iceland_jack> You can also give an arrow solution
19:17:03 <enthropy> that postInstall doesn't really work (I think it works if you add -L${ncurses}/lib to the ld-options instead)
19:17:17 <Iceland_jack> :t \a -> ((a $) &&& id)
19:17:18 <lambdabot> (c' -> c) -> c' -> (c, c')
19:17:41 <Iceland_jack> :t \a b -> (a b, b)
19:17:42 <lambdabot> (t1 -> t) -> t1 -> (t, t1)
19:18:18 <joelteon> Has anyone had a chance to try friday yet?
19:18:43 <int-e> @type ap (flip (,))
19:18:45 <lambdabot> (b -> a) -> b -> (a, b)
19:19:24 <Sizur> Iceland_jack: ah yeah, fanout. I called that double a b = a b b and did double (,) in Elm
19:19:30 <Sizur> i should rename that to fanout
19:19:42 <co-dh> enthropy: thanks
19:19:49 <shachaf> @pl double a b = a b b
19:19:49 <lambdabot> double = join
19:20:06 <Sizur> why's that called a join?
19:20:20 <Iceland_jack> Sizur: it's the monadic join for the ((->) r) instance
19:20:23 <nitrix> Guys, GUYS.
19:20:27 <nitrix> I'm understanding monads ;-;
19:20:35 <Iceland_jack> > map (join replicate) [1,2,3]
19:20:36 <lambdabot>  [[1],[2,2],[3,3,3]]
19:20:49 <int-e> because it joins a stack of two applications of a monadic functor into a single application of said functor.
19:21:05 <int-e> @type join
19:21:06 <lambdabot> Monad m => m (m a) -> m a
19:21:26 <Iceland_jack> @type join :: (r -> r -> a) -> (r -> a)
19:21:27 <lambdabot> (r -> r -> a) -> r -> a
19:21:43 <Sizur> int-e: ah, thanks! that makes sense
19:21:54 <Sizur> join of two applications
19:22:09 <Iceland_jack> Sizur: Note how telling its ((->) r) specialized type is
19:22:25 <Iceland_jack> Turn
19:22:25 <Iceland_jack>     r -> r -> a
19:22:25 <Iceland_jack> into
19:22:25 <Iceland_jack>          r -> a
19:22:58 <int-e> Sizur: also think of the tree monad (a tree with leafs as trees can be turned into a tree by turning the leaf trees into subtrees)
19:23:35 <Sizur> int-e: awesome
19:23:38 <hseg> Is there a way to tell lambdabot: Give me the type of f, using this instance of a class?
19:23:39 <Sizur> Iceland_jack: thanks
19:23:52 <hseg> e.g. join @ ((->) r)
19:24:23 <hseg> Come think of it, isn't such a feature supposed to land in GHC 7.8/10?
19:24:36 <Iceland_jack> @ty join `asTypeOf` (\f x -> f x x)
19:24:37 <lambdabot> (t -> t -> a) -> t -> a
19:24:48 <shachaf> hseg: No, but there's asAppliedTo.
19:24:50 <platz> i thought it was neat friday exposes a Delayed representation.  But i'm not familiar enough with graphics libs to know if this is a common representation even in imperative libs
19:25:06 <shachaf> :t id `asAppliedTo` "abc"
19:25:07 <lambdabot> [Char] -> [Char]
19:25:10 <int-e> @type let r :: (r -> a) -> (r -> a); r = id in r . join -- not really
19:25:11 <Iceland_jack> Good news is that it's not that hard!
19:25:11 <platz> seems kind of like a Builder
19:25:11 <lambdabot> (r -> r -> a) -> r -> a
19:25:28 <Iceland_jack>     join :: Monad m => m (m a) -> m a
19:25:28 <Iceland_jack>  
19:25:34 <Sizur> is there any effort going on to bring OCaml's modules into haskell?  Is that even feasible?
19:25:38 <Iceland_jack> you replace each 'm' with ((->) r)
19:26:40 <Sizur> i guess the whole standard library would then need reimplementation using modules
19:26:46 <hseg> Sizur: I'm reading about such an effort now. It's called the Backpack project.
19:26:59 <Iceland_jack>       join :: Monad m => m (m a) -> m a
19:26:59 <Iceland_jack>     = join :: ((->) r) (((->) r) a) -> ((->) r) a
19:26:59 <Iceland_jack>     = join :: ((->) r) (r -> a) -> (r -> a)
19:26:59 <Iceland_jack>     = join :: (r -> (r -> a)) -> (r -> a)
19:27:01 <dolio> Backpack is not really the same thing.
19:27:16 <hseg> dolio: Isn't it similar?
19:27:19 <platz> Sizur: http://blog.ezyang.com/2014/08/whats-a-module-system-good-for-anyway/
19:27:20 <dolio> Yes.
19:27:31 <hseg> What are the differences?
19:28:00 <dolio> It's more integrated into the language in OCaml.
19:28:16 <dolio> Instead of being something at the package layer.
19:28:34 <Sizur> Microsoft's dedication to Haskell research is the single thing that has brought my opinion of MS from gutter to green pastures.
19:28:47 <hseg> OK, sure. Is this an important difference?
19:29:00 <dolio> Yes.
19:29:15 <nitrix> Sizur: The Microsoft research team is actually very _VERY_ brilliant. I think the problems are at a higher level.
19:29:26 <tabemann> Microsoft's dedication to Haskell research seems so un-Microsoft-ish
19:29:40 <hseg> Sizur: I'm a bit conflicted on the matter. MS research is awesome. MS products... less so.
19:29:51 <hseg> dolio: Example?
19:30:07 <Ralith> hseg: why do you have to be conflicted?
19:30:08 <dolio> OCaml modules are first class, and they used that to implement GADTs recently, I believe.
19:30:09 <nitrix> Sizur: http://research.microsoft.com/en-us/um/redmond/projects/hyperlapse/
19:30:13 <Ralith> MS research and MS business are basically independent.
19:30:27 <nitrix> Sizur: You might like this if you havent seen it.
19:30:31 <Dashkal> int-e: Thanks again.  One platform installed
19:30:34 <Dashkal> Now to face down X...
19:31:21 <tabemann> OCaml and SML modules are "better" than Haskell modules for sure... but parameterized modules aren't as effectively useful in practice as type classes
19:31:38 <tabemann> even if they are better
19:32:14 <Sizur> nitrix: that's cool.  is this used by google glass already?  because i had my videos nicely and automatically stabilized.
19:32:31 <hseg> Ralith: I guess I could make that distinction and "imagine Microsoft complexly", as John Green would say.
19:32:48 <hseg> dolio: I still fail to understand the distinction
19:32:52 <nitrix> Sizur: No idea, I don't have mine yet.
19:32:53 <solatis> hi everyone, i'm having trouble with decoupling a callback-ish function from a function definition... getting compiler errors that it cannot deduce the type, etc, and i think i'm running into syntactic errors
19:32:59 <solatis> can anyone take a look? -> http://lpaste.net/109794
19:33:02 <dolio> hseg: OCaml can have types that contain modules.
19:33:09 <dolio> As values.
19:33:22 <Sizur> nitrix: the speed was not increased, but otherwise i think they are using this algo
19:33:23 <dolio> You match on a type and get a module.
19:33:24 <hseg> dolio: OK. *Now* we're talking.
19:33:28 <dolio> I believe.
19:33:48 <dolio> That's not typical ML stuff. It's pretty new.
19:33:52 <hseg> dolio: As in, I can pass around entire sets of  bindings as values?
19:34:33 <dolio> Also, in ML, you can use modules as units of abstraction within your programs.
19:34:40 <dolio> Even in the same file, if you want.
19:34:49 <hseg> tabemann: Have a look at http://blog.ezyang.com/2014/08/whats-a-module-system-good-for-anyway/ and at the reddit discussion he links to there.
19:35:02 <dolio> That's not going to be convenient if you have to divide things into separate packages to get the equivalent of ML modules.
19:35:37 <Sizur> tabemann: why do you say ML's modules are not as useful as typeclasses?  is that opinion based on m a being a subset of a?
19:36:18 <hseg> dolio: That sounds nice. But from what I've seen from Backpack, it's syntax-agnostic enough to be able to define source code files as being their own packages.
19:36:24 <nitrix> Just making sure that my reading let me in the good redirection. Are monads, like IO, actually a function that takes an extra argument, just to justify that it may return different values on subsequent calls?
19:36:35 <nitrix> s/redirection/direction/
19:37:05 <int-e> Sizur: ocaml doesn't provide the overloading part of typeclasses.
19:37:23 <platz> nitrix: 'extra argument'?
19:37:39 <platz> what are you reading?
19:37:41 <solatis> ah, i think i might understand my problem... i have two different z and z1 monad contexts?
19:37:57 <hseg> nitrix: No. Monads are type constructors m :: * -> * for which there exist functions return :: a -> m a and join :: m (m a) -> m a
19:38:14 <int-e> (the overloading may seem unimportant, and it often is, until you want to write code that works in 3 monads ... and every 'bind' needs its own name)
19:38:15 <Sizur> you can implement it in a bunch of modules though. the only difference being that you'd have to manually spec module sig to module imp.
19:38:31 <hseg> nitrix: There are equivalent formulations in terms of return and (>>=)
19:38:36 <solatis> maybe i need to lift the monad?
19:38:48 <dolio> Neither ML modules nor type classes completely overlap one another well. There are things that one is good for that the other is not.
19:39:09 <dolio> The question is which non-overlappping stuff do you like better.
19:39:41 <hseg> nitrix: However, many monads are state transformers, which may explain how you got to this idea.
19:39:52 <nitrix> hseg: Meaning it's not clear enough then. How would you explain them? I don't understand how they manage to do their magic without breaking any rules
19:40:18 <nitrix> hseg: If I can only understand IO, it'll be a good begining I think.
19:40:29 <hseg> nitrix: Do you mean how getStr returns different values on each invocation?
19:40:40 <nitrix> hseg: I can use it fine, but I'm interested by the theory.
19:40:48 <nitrix> hseg: Sure, getStr for example.
19:41:26 <hseg> nitrix: Have you seen the State monad yet?
19:41:56 <nitrix> I understand its purpose and I used it because the library I'm using is using it.
19:42:10 <nitrix> I'm still fairly knew and trying to stitch the different concepts together.
19:42:11 <Sizur> it might be List or Maybe monads are easier to start from
19:42:50 <hseg> Sizur: sure, but State shows how you can have aparrently referentially opaque values
19:42:55 <tabemann> back
19:43:01 <hseg> nitrix: Do you understand how State works?
19:43:35 <tabemann> Sizur: ML parameterized modules are too heavy-weight and can't be type-inferred
19:43:37 <nitrix> hseg: I'm afraid that's my question. or refIO, or the random function or anything similar for that matter.
19:43:57 <co-dh> does anybody know how to fix sublime text 2's syntax color bug for haskell? I got a lot of pink ( red) for correct haskell file.
19:44:01 <Welkin> !seen solidus_river
19:44:10 <Welkin> @seen
19:44:10 <lambdabot> Say again?
19:44:15 <Welkin> @seen solidus_river
19:44:16 <lambdabot> z0|IdU$_riVeR
19:44:17 <hseg> nitrix: OK, I'm just trying to get a grasp of where you're standing to explain better.
19:44:20 <Welkin> ...what
19:44:21 <nitrix> hseg: I'll just absorb whatever you say, whether or not it happens to answer my question :)
19:44:25 <tabemann> for every parameterized module one wants to instantiate, one has to explicitly apply one module to a (ML term) functor to get a new module
19:44:26 <hseg> nitrix: :)
19:44:43 * solatis hits head against wall
19:44:46 <int-e> Welkin: oh no, that has editing distance 2 from 'leet'.
19:44:55 <hseg> nitrix: For the sake of the argument, let type State s a = s -> (s, a)
19:45:01 <Sizur> tabemann: is that true?  why does SML impl module compiles without sigs?
19:45:37 <tabemann> I mean syntactically
19:45:40 <hseg> nitrix: So values of type State s a are functions that take an old state to a new state and to a state-dependent value.
19:45:54 <hseg> nitrix: With me so far?
19:46:12 <tabemann> you have to (not real ML syntax) module Baz = Foo(Bar) and then explicitly use Baz
19:46:20 <nitrix> hseg: Yes.
19:46:21 <int-e> Welkin: @seen has been disabled for ages, I forgot why. It leaked memory, I suppose.
19:47:01 <tabemann> so people in real ML code don't use modules nearly as widely as it could be used
19:47:04 <hseg> nitrix: OK. So now can you see that for all s, State s is a Functor?
19:47:08 <Sizur> tabemann: right, that's the strength of modules though, right? many-to-many impl-to-sig relations
19:47:52 <nitrix> hseg: Yeah sure.
19:47:56 <int-e> dolio: It's weird, I miss Haskell's file system mapped hierarchical modules in ocaml.
19:48:14 <nitrix> hseg: Although, does the fact its a functor really play an important role?
19:48:20 <dolio> int-e: I think that's understandable.
19:48:27 <solatis> ok, i really need someone to point me in the right direction here: http://lpaste.net/109794
19:48:35 <solatis> i suspect it's due to me using monads incorrectly
19:48:39 <tabemann> the problem is that the syntax for actually taking advantage of the possibilities of parameterized modules is clumsy, and not type-inferrable
19:48:59 <hseg> nitrix: A) As a warm-up B) all monads are functors, so we need to discharge this proof obligation first.
19:49:08 <Sizur> tabemann: i understand what you mean with no inference. but module/no_inverence is a positive value.  so i'm excited to have both with Backpack :)
19:49:34 <dolio> int-e: It's probably nice to have both.
19:49:35 <Sizur> i mean above 1 value :/
19:50:23 * nitrix googles discharging method of discrete mathematics.... mkay, if you can avoid the notation, I can actually grasp a couple of things in layman.
19:50:28 <nitrix> hseg: ^
19:50:30 * tabemann though doesn't see how parameterized modules taking modules for strings would be any different from using type classes for strings
19:51:04 <tabemann> one would still have to choose which functions to put in your module signature just as you would have to choose which functions to put in your type class
19:51:38 <dolio> Overloading all your string operations can lead you to ambiguous situations.
19:52:02 <dolio> And you probably don't need the overloading. Just a global choice.
19:52:10 <solatis> waaaait a minute... should my callback definition perhaps be ZMQ z (Sender t) instead of Sender t -> ZMQ z () ?
19:52:20 <tabemann> the problem's libraries that take strings
19:52:21 <hseg> nitrix: No, all I meant is that since all monads are functors, we should first show State s is a functor.
19:52:27 <hseg> nitrix: Sorry for the confusion.
19:52:55 <tabemann> either they have to duplicate themselves for each string type they take, or they have to overload with type classes, or they just have to force the user to convert strings to the right type in every case
19:53:34 <dolio> Like if you overload and do stuff like: do s <- getLine ; let s' = ... s ... ; putStrLn s'
19:53:47 <dolio> Then the choice of string is ambiguous if it's all overloaded.
19:53:54 <hseg> nitrix: Anyway, can you see how to implement return and join for State?
19:54:34 <Sizur> dolio: there are cases in Haskell when you have to specify type manually too, and plenty
19:55:10 <dolio> Yes, and it's bad when that happens.
19:55:29 <tabemann> the only advantage I see for parameterized modules here over type classes is that one doesn't have to hand-specify the ambiguous cases
19:55:40 <nitrix> hseg: Not really no. Like I said, while I understand most of the typing system, and realising that monadic code I used were actually syntaxic sugar, I looked up the operators and then I got lost.
19:56:00 <hseg> nitrix: It's OK.
19:56:29 <dolio> tabemann: It's also very annoying to defer the choice to someone else in these cases.
19:56:43 <dolio> If you should wish to do so.
19:56:58 <hseg> nitrix: Consider return first. It has type a -> State s a, which reduces to a -> s -> (s,a). What could it possibly do?
19:57:13 <nitrix> hseg: I learned merely just IO so far, and it was very easy because I worked with them as boxed types, well actions, that had to be executed which can only happen in a monadic context, IO specifically in my case, which is introduced by `do`.
19:57:37 <vanila> do action1 ; action2 ; action3  is just  action1 >> action2 >> action3
19:58:03 <vanila> do x <- action1 ; action2 x ; action3 x  is  action1 >>= \x -> action2 x >> action3 x
19:58:14 <hseg> nitrix: Well, I'm here to tell you that Monad is just a typeclass that's so useful Haskell invented some syntactic sugar for it.
19:58:16 <nitrix> hseg: So that was very simple, but I still have no clue of what I'm doing, how it's even possible. I thought the theory would make it easier to grasp but I think with haskell I might want to go the other way around. Layman first, then I'll curiously adopt the theory :S
19:59:44 <dolio> tabemann: Basically, I think there are some cases where you have a potentially large API you want to abstract over, but only need to use one copy of that API at any time.
19:59:56 <dolio> ML modules are the right thing for that, and type classes are not.
20:00:40 <hseg> nitrix: It's OK, we've all been at that stage. I'd suggest you approach Monad just like any other typeclass, and forget about the syntactic sugar. Then, once you feel you understand Monad, look at the desugaring of do-notation and map your knowledge to it.
20:01:17 <tabemann> http://lpaste.net/109797 < anyone have any idea what's going on here?
20:01:20 <nitrix> hseg: I know it's too early, but it feels so weird to just magically accept that it works.
20:01:47 <dolio> You can use type classes for it to some degree, but it has deficiencies, and you're not playing to the strengths of classes.
20:01:54 <tabemann> dolio: ML modules are the ideal thing for that, while type classes work in some cases
20:02:43 <dolio> If I have to choose between the two, I still pick classes, though.
20:02:47 <nitrix> hseg: I'm stuff my brain of a couple of videos instead of reading, that might just be the blocking.
20:03:01 <vanila> @nitrix
20:03:01 <lambdabot> Unknown command, try @list
20:03:10 <hseg> nitrix: I'm not saying you should magically accept it works. You don't need to know how list comprehensions work to understand how lists work. First understand lists, then look at how list comprehensions become normal list manipulation functions. Same applies here.
20:03:32 <nitrix> But I understand list comprehensions :D
20:03:34 <enthropy> tabemann: are you using a ghc that was out when that plugins release was made?
20:03:39 <hseg> nitrix: :).
20:03:49 <tabemann> enthropy: I'm using GHC 7.8.3
20:03:50 <nitrix> I read on it on wikipedia, it was simple enough and the syntax in haskell was very similar so I picked it up easily :)
20:04:39 <hseg> nitrix: The syntax is easy to pick up, I agree. But do you know what GHC translates it to?
20:04:39 <nitrix> Well, I must admit that, the most confusing thing is the type system.
20:04:57 <nitrix> The fact types have constructors and types are constructed of other types or something.
20:05:14 <hseg> nitrix: Let's back up to that first, shall we?
20:05:24 <enthropy> tabemann: well I'd try with 7.6 and/or pester stepcut (who seems to be the maintainer) about this problem
20:05:25 <nitrix> Would be very nice.
20:05:25 <tabemann> plugins was last updated on Thu Oct 3 18:41:13 UTC 2013, so I presume that was GHC 7.6.3
20:06:08 <tabemann> I'll email Jeremy Shaw about it
20:06:27 <hseg> nitrix: (simplified, Haskell98 only) You have types. Types classify values. So, for example True is a value of type Bool.
20:07:12 <nitrix> hseg: Note that I'm very pedantic too, don't be easy with the terms.
20:07:16 <enthropy> no commits http://hub.darcs.net/stepcut/plugins/changes since that release
20:07:16 <mjrosenb> tabemann: ping?
20:07:23 <athan> hey guys, what is a "nominal datatype" exactly? Just an ADT? A GADT?
20:07:32 <nitrix> hseg: So Bool is a type. Not a type class, it's merely a type?
20:07:38 <hseg> nitrix: Yep
20:07:44 <nitrix> Fine by me.
20:07:49 <dfeuer> athan: are you looking at type roles?
20:08:00 <nitrix> hseg: So what would True be, a type constructor?
20:08:05 <nitrix> hseg: Or a type value?
20:08:10 <enthropy> data constructor
20:08:17 <hseg> nitrix: the simplified only referred to the fact that I'm not dealing with all sorts of new stuff like GADTs, kinds, type families etc
20:08:27 <athan> dfeuer: yoko, but I could use the knowledge in that context, too :)
20:08:35 <dfeuer> Bool is a type constructor.
20:08:47 <dfeuer> Yoko = ... you only kill once?
20:08:49 <tabemann> mjrosenb: pong
20:09:03 <nitrix> dfeuer: Bool is a type constructor? Of?
20:09:10 <mjrosenb> tabemann: so, I figured out how to use plugins.
20:09:14 <athan> dfeuer: lol... i think it means "child" in japanese - for "a pattern of almost homomorphic functions"
20:09:16 <tabemann> how?
20:09:34 <dfeuer> nitrix: let's go off channel.
20:09:38 <athan> I think it's a generic programming technique for establishing homomorphisms, but I still haven't gotten though it
20:09:41 <mjrosenb> tabemann: ghc ./eval.hs  -optl=-Wl,--export-dynamic
20:09:50 <nitrix> dfeuer: hseg #nitrix
20:11:53 <tabemann> mjrosenb: that results in:
20:11:55 <tabemann> EvalTest: /tmp/MXXXXX14566.o: unknown symbol `base_DataziTypeableziInternal_zdfTypeableInt_closure'
20:11:56 <tabemann> EvalTest: user error (resolvedObjs failed.)
20:12:16 <NougatRillettes> On which forum(s) may I find a good Haskell comunity ?
20:12:38 <tabemann> for a good Haskell community you're already here
20:12:44 <mjrosenb> tabemann: did you clean out the old executable first? otherwise ghc won't do anything.
20:12:48 <dmj`> NougatRillettes: does your city have meetups?
20:12:53 <mjrosenb> also, --make may be necessary.
20:13:06 <NougatRillettes> yes but I'd like something more permanent tabemann
20:13:12 <NougatRillettes> hm no dmj`
20:13:29 <tabemann> mjrosenb: I deleted it and it didn't make a difference
20:13:37 <NougatRillettes> And it's just to have some advice on code
20:13:37 <hseg> NougatRillettes: The mailing lists are nice
20:13:42 <enthropy> --make is on by default for something like ghc > 6.12
20:14:30 <tabemann> okay I deleted EvalTest.o now, and it now does:
20:14:42 <NougatRillettes> ok I'll try them hseg thx
20:14:43 <tabemann> EvalTest: /tmp/MXXXXX14713.o: unknown symbol `base_DataziDynamic_toDyn_closure'
20:14:44 <tabemann> EvalTest: user error (resolvedObjs failed.)
20:20:08 <tabemann> the options can't be the issue, because I've seen other people mentioning online that System.Eval.Haskell or System.Plugins work without any mention of special compilation options
20:22:20 <tabemann> hah got it to work
20:23:24 <tabemann> but it seems brittle because it only works with ghc -O2
20:24:49 <tabemann> it still feels like I shouldn't have to do all this to get it to work, since no one else mentions it
20:46:20 <mjrosenb> tabemann: dunno, dcoutts said he reported this issue about a decade ago :-p
20:49:24 <tabemann> wonderful
20:49:29 <tabemann> does anyone use plugins then?
20:52:26 <carter> hey all
20:52:35 <carter> am i right in thinking that
20:52:36 <carter> newtype IntFun a = Ifun  (forall m. (PrimMonad m)=>  Int -> m a )
20:52:41 <carter> should have a legal functor instnace
20:52:51 <carter> doesn't seem definable though
20:54:51 <carter> woot
20:54:53 <carter> got it
20:55:21 <tabemann> know what
20:55:47 <tabemann> I'm just going to use System.Plugins.Make and System.Plugins.Load and not bother with System.Eval.Haskell
20:55:53 <carter> cooll
20:56:07 <tabemann> since I don't have to bother with special compiler options with S.P.M and S.P.L
20:56:57 <tabemann> and when the user enters code at an in-program REPL I'm literally going to write it out to file, build it to *.o and *.hi, and then load it as a plugin
20:57:31 <bluebelle> Anyone knows if parsec has an instant LanguageDef st -> String -> [Token] ??
20:57:43 <tabemann> especially since most scripts I see the user entering will already be as files anyways
21:00:20 <tabemann> wait, no, I do need special options for my load-only code
21:01:30 <bluebelle> nvm looks like it's not that simple
21:02:54 <southp0105> Hi. I installed GHC 7.6.3 on my MBA through homebrew. I would like to compile a simple hello world program into C code. However, ghc -C hello-world.hs gave me the warning: "Compiler not unregisterised, so ignoring -C". What was that?
21:03:08 <carter> southp0105: i recommend not using homebrew
21:03:16 <carter> also -C doesn't do what you think it does
21:03:48 <carter> southp0105: if you want a very simple GHC install on mac, the ghc app bundle is what i'd recommend
21:03:53 <carter> @google ghc app
21:03:54 <lambdabot> https://www1.ghc.org/html/public/mobile/
21:03:56 <carter> @google ghc app os x
21:03:57 <lambdabot> http://ghcformacosx.github.io/
21:03:58 <lambdabot> Title: Haskell for Mac OS X, self-contained relocatable GHC builds
21:04:03 <southp0105> carter: Out of curiosity, is there anything wrong with the homebew version?
21:04:23 <carter>  southp0105  simply put, no one who actually is very familiar with haskell actively maintains it
21:05:14 <southp0105> @carter: Understood.
21:05:14 <lambdabot> Unknown command, try @list
21:05:23 <tabemann> know what - I'm actually going to use system.Eval.Haskell anyways because I can actually force it to typecheck against what is in a source file, whereas with System.Plugins.Load if the type doesn't match it just outputs garbage
21:05:46 <carter> southp0105: and the brew dev flow means that it needs active baby sitting
21:06:09 <tabemann> even though using System.Eval.Haskell would be less efficient because I'd be compiling *twice* rather than once
21:06:11 <southp0105> carter: Understood. btw, what did you mean by "-C doesn't do what you think" ?
21:06:12 <carter> southp0105: for friends who are getting started, https://github.com/bitemyapp/learnhaskell is an actively updated curated learning resource list
21:06:26 <carter> southp0105: well, what did you think it does?
21:06:37 <carter> southp0105: ghc --help will list the basic flags :)
21:07:01 <southp0105> carter: I thought it would generated a C version program that does exactly the same thing.
21:07:04 <carter> :)
21:07:23 <carter> southp0105: a) thats only supported for platforms which dont have native code gen or llvm support
21:07:32 <carter> and b) the generated code aint human redable
21:07:38 <tabemann> I assure you that any C generated by GHC is going to be completely non-understandable by humans
21:07:53 <carter> southp0105: you could do one fo the following flags
21:08:01 <carter> southp0105: have you heard of C minus minux?
21:08:04 <carter> CMM
21:08:09 <carter> *minus minus
21:08:42 <carter> if Normal Ramsey had been better at marketing it and pushing for adoption in multiple communities, would have been LLVM  before llvm
21:08:50 <carter> ghc's last IR rep is CMM
21:09:10 <carter> southp0105: so -ddump-cmm will dumpt that
21:09:18 <southp0105> I once read about it on the chapter about ghc in the book "the architecture of open source software"
21:09:34 <carter> anyways, i don't reocmmend using brew for haskell
21:10:27 <carter> use either the ghc for OS X or the newest haskell platform release
21:11:31 <southp0105> carter: Thanks. I'll first install the bundle you recommended and have a try of -ddump-cmm : )
21:11:45 <carter> southp0105: also
21:11:52 <carter> a) add ~/.cabal/bin to you rpath
21:12:11 <carter> and *your path
21:12:37 <carter> and dl the latest cabal-install binary  from http://www.haskell.org/cabal/download.html and put it in your /usr/local/bin or ~/.cabal/bin
21:13:48 <southp0105> carter: OK. I'll do it.
21:13:59 <carter> put it into ~/.cabal/bin
21:14:10 <carter> then do cabal update ; cabal install cabal-install
21:14:24 <carter> so you'll at the end have a self hosed cabal binary :)
21:14:33 <carter> AFTER you setup the osx app
21:26:44 <flebron> Is there a "pretty" way to generate the list of all lists of positive Ints?
21:27:22 <flebron> (Such that for any list of positive numbers xs, if ys is the list that I generated, xs `elem` ys)
21:27:29 <Iceland_jack> > inits (iterate succ 0)
21:27:29 <Iceland_jack> ?
21:27:31 <lambdabot>  [[],[0],[0,1],[0,1,2],[0,1,2,3],[0,1,2,3,4],[0,1,2,3,4,5],[0,1,2,3,4,5,6],[0...
21:27:32 <flebron> (Any finite* list xs)
21:27:39 <flebron> Iceland_jack: Those are all sorted.
21:27:49 <Iceland_jack> right, then you can use 'concatMap permutations'
21:27:52 <flebron> [1, 1] isn't there, for example, and neither is [2, 1].
21:27:53 <Iceland_jack> but it won't be efficient
21:28:00 <flebron> Oh, and also, I'd like there to not be repeats :)
21:28:24 * Iceland_jack wonders what you need this for
21:28:34 <flebron> No particular reason.
21:28:42 <carter> he's going golfing and is seaking a volunteer caddy :)
21:29:03 <Iceland_jack> heh the answer you'll get depends a lot on what your requirements are
21:29:53 <flebron> No repeats, and xs `elem` ys must be true (in finite time :p) for all lists of positive ints xs.
21:30:02 <flebron> *finite lists xs, I keep missing that.
21:30:05 <carter> Iceland_jack: i demand your spleen
21:30:59 <carter> Iceland_jack: why aren't you on my channel  no mor :'(
21:32:00 <carter> spleen was a requirement for some codes
21:33:46 <Iceland_jack>     /join #numerical-haskell
21:33:48 <Iceland_jack> carter: You were saying? :)
21:34:01 <carter> Iceland_jack: i'm done with the tricky things
21:34:02 <carter> now for math
21:34:52 <Iceland_jack> carter: I made some patches for GHC half a year ago and they only got attention now
21:35:08 <carter> Iceland_jack: well, the phab stuff maks that happen faaster now
21:35:19 <Iceland_jack> and I'm fixing them a bit now which is time consuming on my weak computer
21:35:37 <Iceland_jack> carter: I haven't used the phab thing, you'll need to tell me how that works
21:35:47 <carter> Iceland_jack: its really easy
21:35:54 <carter> i literally followed the directions and it worked
21:36:21 <carter> nb, its a good idea to make a duplicate branch of your branch before running the arc / phab cli  tool on it
21:36:26 <Iceland_jack> (compiling ghc is causnig my computer to grind to a halt if I don't respond)
21:36:26 <carter> just because git is confusing
21:36:29 <carter> haha
21:36:38 <carter> Iceland_jack: try tellingit to use only 1 cpus
21:37:11 <Iceland_jack> Will do
21:37:35 <Iceland_jack> I'll check out the phab tutorial on the ghc trac
21:42:26 <int-e> > []:fix(([1]:).(>>= \(x:xs)->[1:x:xs,1+x:xs]))
21:42:28 <lambdabot>  [[],[1],[1,1],[2],[1,1,1],[2,1],[1,2],[3],[1,1,1,1],[2,1,1],[1,2,1],[3,1],[1...
21:44:12 <Iceland_jack> btw carter, is there a reason why the :kind command doesn't implicitly quantify type variables?
21:44:12 <Iceland_jack>  
21:44:17 <dfeuer> Is Professor dcoutts here?
21:44:29 <Iceland_jack> So you can write
21:44:29 <Iceland_jack>     @kind Either a b
21:44:29 <Iceland_jack> instead of
21:44:29 <Iceland_jack> @kind forall a b. Either a b
21:44:30 <lambdabot> *
21:44:56 <carter> Iceland_jack: but if you just made a typo it'd be confusing
21:45:07 <carter> and theres a difference between mono / poly types
21:45:14 <carter> honestly no clue
21:45:15 <carter>  :)
21:45:18 <Iceland_jack> hehe
21:46:00 <Iceland_jack> when I'm playing around with type families especially
21:46:00 <Iceland_jack>     ghci> :kind! forall a b c d. Rev (a -> b -> c -> d)
21:46:00 <Iceland_jack> adding the 'forall' gets annying
21:47:17 <carter> think about when you accidently mistype a var
21:48:07 <Iceland_jack> Sure but these are just a single line, can you don't need to specify them explicitely in type signatures and that has never been an issue
21:48:20 <carter> idk
21:48:29 <carter> maybe its just no one bothered?
21:48:37 <carter> maybe its waiting for Iceland_jack  to save the day?
21:48:40 <Iceland_jack> haha
21:49:05 <Iceland_jack> Well people have sure been quiet about those expectations
21:49:40 <carter> its all self motivation
21:50:18 <Iceland_jack> I'm wondering since I'm modifying code in that area if I should just casually add the feature (or 'bug' depending on your views)
21:50:41 <Sgeo> Why does conduit have $= and =$ and =$= instead of one operator?
21:51:34 <carter> Iceland_jack: dont sneak it in
21:51:41 <Iceland_jack> No no, I'm kidding :)
21:51:41 <carter> have an explicit conversation
21:51:43 <carter> ok
21:54:05 <Iceland_jack> Has it been discussed that all the methods in Integral could be implemented for Float and Double?
21:55:28 <carter> Iceland_jack: what do they mean on Nan
21:55:35 <carter> or ±Infty?
21:55:41 <carter> or -0 ?
21:55:57 <Iceland_jack> Well those two are always annoying when defining on IEEE 754
21:56:07 <Iceland_jack> but div/mod is well defined on the reals
21:56:32 <carter> Iceland_jack: but since when are Float/Double == the realse?
21:56:52 <Iceland_jack> carter: Granted :) but we define Eq for Float/Double
21:56:55 <carter> @tell johnw lets sync up about me taking over numbers mebe
21:56:55 <lambdabot> Consider it noted.
21:57:05 <carter> Iceland_jack: yes
21:57:07 <Iceland_jack> and Ord, even though it's not quite what you'd expect
21:57:14 <carter> i kNOW
21:57:15 <Iceland_jack> Trichotomy is no more
21:57:17 <carter> you don't need to remind me
21:57:20 <Iceland_jack> haha
21:57:27 <carter> otoh, Nan is like a reified exception
21:57:31 <Iceland_jack> Yes
21:57:50 <Iceland_jack> Using something like Idris one would define a NaN-free Float/Double I suppose
21:57:52 <lfairy> I know Rust separates lawful and unlawful Ord
21:57:58 <Iceland_jack> the {auto : ...} feature
21:58:04 <carter> lfairy: i know, i helped them evade some gotchas
21:58:12 <carter> Iceland_jack: problem is, EVERY type has undefined
21:58:24 <carter> so Nans are just inspectable Undefineds restricted to floats
21:58:33 <Iceland_jack> Yes
21:58:49 <Iceland_jack> And it's the only bottom you'll find in Float# :)
21:59:02 <carter> hah
21:59:03 <carter> well
21:59:04 <carter> anyways
21:59:07 <carter> i'm slowly mulling how to do it
21:59:09 <carter> BUT
21:59:11 <carter> floats aint Reals
21:59:11 <Iceland_jack> Okay
21:59:26 <carter> and any changes need to be slow boil
22:00:11 <Iceland_jack> No disagreements there, but currently we have truncated division (quot/rem) and floored division (div/mod) and I'd like to at least add Euclidian division
22:00:23 <Iceland_jack> any idea where I could propose this?
22:00:33 <carter> hrmm
22:00:40 <carter> Iceland_jack: lets chat about it more first
22:00:42 <Iceland_jack> sure
22:01:39 <Iceland_jack> I doubt Integral will actually change but it's a bit of a misnomer since if you implement RealFrac you should be able to implement a generalized rem/mod
22:02:42 <Iceland_jack> ...still compiling
22:05:36 <carter> Iceland_jack: slow boil
22:05:56 <Iceland_jack> Yes :) I've just signed in to Phabricator
22:09:20 <michaelt> What is the incantation for the cabal config that would say 'don't install a new transformers'? I cant remember...
22:09:54 <dmj`> michaelt: put an upper bound on the version?
22:10:43 <lfairy> michaelt: "transformers installed" ?
22:10:43 <michaelt> hm, there used to be something you said, 'use installed transformers' or something, in the .cabal/config file; maybe it's ancient history
22:11:00 <lfairy> "constraints: transformers installed" I mean
22:11:16 <michaelt> ah, that sound right, thanks lfairy
22:11:22 <lfairy> \o/
22:11:29 <dfeuer> @tell dcoutts Will you be available Friday night?
22:11:30 <lambdabot> Consider it noted.
22:12:15 <merijn> michaelt: it's constraint (no s), but yes, that's the one
22:12:50 <michaelt> right, I see it commented in the config file
22:12:55 <michaelt> with no 's'
22:14:20 <michaelt> Ah, yes, this is looking better, thanks lfairy merijn etc
22:15:58 <lfairy> merijn: silly of me to get that wrong, when I've been hacking on Cabal myself :P
22:22:33 <JohnTalent> what is the usual libs needed to make a haskell mvc web server?
22:23:09 <merijn> Depends on which web framework you wanna use
22:23:27 <merijn> Like every language, we have approximately umpteen billion different ones
22:23:43 <joelteon> fortunately you can lazily evaluate them
22:24:11 <dmj`> JohnTalent: here's one example: https://github.com/scotty-web/scotty-starter
22:24:42 <dmj`> as merijn said there are a ton of libs on different ways to do things
22:27:15 <Javran> How to ignore "Use String" from hlint if I'm defining a type synonym like: `type Foo = [Char]`?
22:28:39 <carter> Javran: Newtype
22:31:24 * hackagebot peyotls 0.1.4.0 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.4.0 (YoshikuniJujo)
22:33:27 <Javran> carter: but I have to deal with wraping if I use newtype.
22:33:46 <carter> Javran: do you wanna mix up normal strings and this or not?
22:33:51 <carter> you *could* use overloaded strings :)
22:35:24 <Javran> carter: nope, I want to say it's just a list of Chars, have nothing to do with String
22:35:42 <carter> nope "don't let normal strings happen here"
22:35:51 <carter> or "no, i'm ok mixing em up"
22:36:07 <Javran> the former one
22:36:18 <carter> you want newtype
22:36:25 <carter> type is just a alias
22:36:42 <carter> that lets you refere to large types via a short hand
22:37:15 <Iceland_jack> Yes, there is no difference between Foo and String and [Char] given
22:37:16 <Iceland_jack>     type Foo = [Char]
22:37:36 <Javran> carter: thanks, just realized there's a better solution
22:38:11 <Javran> I can have `type Foo a = [a]`
22:38:57 <merijn> Javran: Sure
22:39:10 <carter> well
22:39:11 <merijn> Javran: But that means that "Foo a" and "[a]" are identical
22:40:05 <Iceland_jack> @let type Foo a = [a]
22:40:09 <lambdabot>  Defined.
22:40:12 <Iceland_jack> @ty L.Refl :: (Is (Foo a) [a])
22:40:14 <lambdabot> Is (Foo a) [a]
22:40:53 <merijn> > let f :: Foo a -> a; f (x:xs) = x in f ([1,2,3] :: [Int])
22:40:53 <Javran> hmmm... looks like there's a prolog-like system in type level?
22:40:55 <lambdabot>  1
22:41:30 <merijn> Javran: Pretty much
22:43:04 <Javran> merijn: wow that's impressive
22:44:22 <merijn> @quote edwardk prolog
22:44:22 <lambdabot> edwardk says: oleg doesn't write haskell. he writes prolog. he just happens to write it at the haskell type level.
22:46:10 <merijn> With type families it actually becomes even more expressive, I think
22:53:27 <vojta> Hi guys, I have a newbie question…
22:53:30 <vojta> Both String and Int are instances of type class of Eq, but I can not do `"foo" == 123`
22:53:41 <doismellburning> :t (==)
22:53:42 <lambdabot> Eq a => a -> a -> Bool
22:53:55 <Iceland_jack> vojta: You can only compare two things of the same type, as the type of (==) shows
22:54:16 <vojta> Well, I could define == for String -> Int -> Bool, right?
22:54:19 <doismellburning> vojta: read that as "for some type a that is an instance of Eq"
22:54:30 <Iceland_jack> vojta: no
22:54:30 <doismellburning> vojta: not "an Eq to an Eq to a Bool"
22:54:53 <doismellburning> vojta: note that typeclasses aren't like java interfaces
22:55:38 <doismellburning> (but even if they were, you'd see a definition of == a bit more like `Eq a, Eq b => a -> b -> Bool`)
22:55:43 <doismellburning> definition? signature
22:56:23 <doismellburning> ...that wasn't a hugely cogent few sentences there, but hopefully gives you some sort of indication?
22:56:27 * hackagebot lens-aeson 1 - Law-abiding lenses for aeson  http://hackage.haskell.org/package/lens-aeson-1 (EricMertens)
22:56:29 * hackagebot lens 4.4 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.4 (EricMertens)
22:56:41 <edwardk> glguy++
22:57:14 <pyon> doismellburning: The type of (==) is "Eq a => a -> a -> Bool", so, when you define an Eq instance for any type Foo, then (==) really has to have type "Foo -> Foo -> Bool".
22:57:16 <Iceland_jack> You could define a (multi-parameter) type class for comparing across types (heterogeneous equality), and the type of equality would be something like
22:57:16 <Iceland_jack>     equal :: Equal a b => a -> b -> Bool
22:57:16 <vojta> thanks
22:57:19 <joelteon> glguy, what does incrementing feel like
22:57:44 <doismellburning> pyon: I never claimed otherwise
22:57:46 <glguy> I feel like I'm about to overflow ;-)
22:57:57 <pyon> Oh.
22:58:17 <doismellburning> (though that does feel clearer than what I was trying to say, thanks)
22:59:19 <merijn> "(==) :: (Typeable a, Typeable b, Eq a, Eq b) => a -> b -> Bool" :D
22:59:25 <Iceland_jack> yuck!
22:59:26 <Iceland_jack> :)
22:59:52 <merijn> :t let eq x y = Just x == cast y in eq
22:59:53 <lambdabot> (Typeable a1, Typeable a, Eq a) => a -> a1 -> Bool
22:59:58 <merijn> oh, duh
23:00:14 <doismellburning> ew
23:00:15 <merijn> > let eq x y = Just x == cast y in eq 1 "whoo!"
23:00:17 <lambdabot>  False
23:00:40 <merijn> > let eq x y = Just x == cast y in eq 1 1
23:00:43 <lambdabot>  True
23:01:04 <merijn> Who needs dynamically typed languages? :D
23:01:22 <doismellburning> @src cast
23:01:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
23:01:25 <doismellburning> :t cast
23:01:26 <lambdabot> (Typeable b, Typeable a) => a -> Maybe b
23:01:37 <merijn> > cast 1 :: Maybe Char
23:01:39 <lambdabot>  Nothing
23:01:41 <merijn> > cast 1 :: Maybe Int
23:01:44 <lambdabot>  Nothing
23:01:47 <merijn> oh, hah
23:01:50 <merijn> > cast 1 :: Maybe Integer
23:01:52 <lambdabot>  Just 1
23:02:16 <doismellburning> lol
23:02:34 <pyon> Is there any example of "cast (x :: a) = Just (y :: b)" where "a" and "b" are different?
23:02:37 <merijn> doismellburning: cast (ab)uses typeclasses and basically always returns "Nothing" unless 'a' and 'b' are already the same type :)
23:02:55 <merijn> pyon: No, unless there's a bug somewhere :p
23:03:28 <pyon> merijn: So I guess this is only useful with higher-rank types?
23:04:07 <merijn> pyon: It's (occasionally) useful with ExistentialQuantification
23:04:15 <pyon> Ah! Existential quantification, that was it.
23:04:44 <pyon> Still, it looks kinda ugly.
23:05:32 <merijn> It is, it's effectively dynamic typing :p
23:05:34 <pyon> The kind * is not supposed to be an inductive or coinductive sort, so you should not be "pattern-matching" on it.
23:05:55 <merijn> pyon: It only works on monomorphic types of kind * anyway
23:06:12 <pyon> Ah!
23:06:42 <pyon> merijn: I guess the existence of this cast function means that type information is not really erased during the compilation process, right?
23:06:54 <merijn> pyon: "It depends"
23:07:07 <pyon> On what? Compiler flags?
23:07:22 <merijn> pyon: Typeable has a "type representation" which is comparable and if the type representation is equal than the types must be equal
23:07:32 <merijn> Since it's now impossible to handwrite Typeable implementations
23:07:42 <pyon> Ah!
23:07:49 <merijn> pyon: So, there is no type information, you're just using typeclasses to fake it at runtime
23:08:23 <pyon> But now that means Typeable is not an ordinary type class, but rather it gets special treatment by the compiler, right?
23:08:28 <merijn> No
23:08:32 <merijn> It's an ordinary typeclass
23:08:47 <merijn> The only unordinary thing is that you can't handwrite instances
23:08:48 <pyon> Then how would it be impossible to hand-write Typeable instances?
23:08:53 <merijn> Not too long ago you could
23:08:57 <pyon> Ah.
23:09:06 <merijn> But a mistake in the typeable instance is horrifically dangerous :)
23:09:20 <merijn> That's why you can only derive it now, which eliminates the possibility of mistakes
23:09:21 <pyon> merijn: Yes, it renders the whole thing unsound.
23:09:27 <pyon> Ah!
23:09:48 <merijn> pyon: But there's nothing fundamentally special that makes it impossible to implement it yourself
23:10:14 <merijn> pyon: "cast" just compares type represenations and uses "unsafeCoerce" if they're identical :)
23:10:33 <merijn> Which is safe, assuming your Typeable instance is correct :)
23:11:34 <pyon> merijn: Ah!
23:16:24 <Sizur> @pl f a = b . map (c a)
23:16:24 <lambdabot> f = (b .) . map . c
23:16:46 <Sizur> . . .. (..)...
23:20:20 <merijn> Sizur: It's called pointless, because most of it's suggestions are! ;)
23:20:30 <Sizur> heh
23:21:34 * hackagebot order-statistics 0.1.1 - L-Estimators for robust statistics  http://hackage.haskell.org/package/order-statistics-0.1.1 (EdwardKmett)
23:22:01 <Sizur> @pl f a b = c (map (d a) b)
23:22:02 <lambdabot> f = (c .) . map . d
23:22:29 <Sizur> meh. Elm is not letting me do (a .)
23:22:56 <Iceland_jack> Does Elm support operator sections?
23:23:00 <bernalex> Sizur: writing code in haskell & trying to translate it to elm is a nice way to get very disappointed by elm.
23:23:38 <Sizur> Iceland_jack: no operator sections.
23:23:53 <bernalex> Iceland_jack: my guess is this is one of the things that community considers "pedantic" and "bad pedagogy", which is what they say about most of the things that make sense in haskell.
23:24:45 <Iceland_jack> For every feature in Haskell you could ask why that feature isn't in Elm, I would mention type classes before sugar like sections
23:24:59 <Iceland_jack> But Elm is holding its own
23:25:04 <Sizur> yeah, i miss type classes
23:25:33 <Sizur> i implemented non-parametric tyep classes in perl
23:26:01 <bernalex> Iceland_jack: the attitude that syntax (sugar) doesn't matter at all is one I will never understand. the first thing you see in a language is syntax. sure it matters. equational reasoning makes code *a lot* easier to read to me than foo x y z = case (x, y, z) of ...
23:26:04 <Sizur> maybe they should be called contract classes
23:26:18 <Iceland_jack> bernalex: That was absolutely not what I was saying
23:26:28 <Iceland_jack> I'll be the first to quote Whitehead on the importance of syntax
23:26:29 <bernalex> Iceland_jack: yeah I didn't mean to direct it at you either, sorry
23:26:44 <bernalex> it was more related to what you said than directed at you
23:31:42 <augur> so are there any good audio packages for haskell?
23:32:55 <merijn> augur: What kind of audio packages?
23:33:05 <merijn> There's some live coding things
23:33:19 <augur> i just need to process audio data
23:33:40 <augur> ideally i just want something to input an audio file and give me some representation of the samples
23:33:40 <kvda> merijn, like?
23:33:52 <taktoa> euterpea?
23:34:08 <taktoa> www.cs.yale.edu/homes/hudak/Papers/HSoM.pdf
23:34:41 <kvda> there's Tida
23:34:48 <kvda> *Tidal
23:35:38 <Sizur> well, atleast it's easy to overcome lack of operator crossections by introducing another function.
23:35:40 <merijn> kvda: I forgot, I saw like 3 packages fly by on twitter at some point
23:36:06 <kvda> ah ok, I know of Tidal, but was wondering if there were any other good ones
23:36:15 <kvda> Tidal was meant to be fairly difficult to set up
23:36:22 <kvda> might try it now
23:37:30 <augur> also, is there a good online (3d?) graphing tool that allows scripting?
23:38:01 <augur> or at least allows definitions
23:38:04 <merijn> augur: Are there any good graphing tools, period? :p
23:38:14 <augur> probably mathematica
23:38:29 <merijn> Mathematica is actually pretty ok, yeah
23:39:17 <augur> i want to poke around with some wave stuff to see how to use binaural audio input to localize sound sources in space
23:39:46 <Sizur> merijn: METAPOST! :)
23:40:09 <Sizur> + graphviz
23:40:27 <augur> noo wrong graphing
23:41:27 <augur> i guess what i'd really like to do is just write a program that displays an image so i can define the thing computationally
23:41:48 <Sizur> augur: have you looked at metapost?
23:41:59 <augur> no what is metapost
23:45:12 <levi> augur: I have some coworkers that do a lot of audio beamforming stuff. It's pretty cool.
23:45:53 <augur> levi: oh?
23:45:59 <augur> tell me more
23:46:37 * hackagebot peyotls 0.1.4.1 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.4.1 (YoshikuniJujo)
23:47:31 <levi> Oh, stuff for using microphone arrays to isolate sounds from specific locations.
23:49:01 <levi> Half of my group are networking/EE, the other half are DSP engineers.
23:50:16 <sgronblo> forgot there was another meanin gfor DSP as well
23:50:42 <levi> One guy spent several years doing DSP engineering for a hearing aid company, so he's pretty good with audio and human audio perception.
23:50:52 <levi> sgronblo: What other DSP are you thinking of?
23:54:13 <nshepperd> when I was 14 I independently invented audio beamforming. I didn't know there was a name for it already
23:54:57 <nshepperd> none of my childhood inventions turned out to be new
23:55:42 <augur> nshepperd: whats audio beam forming?
23:56:41 <augur> levi: yeah, i figure it would be useful for speech recognition because you could eliminate a lot of ambient noise
23:57:24 <augur> if you could localize a sound source in space, you can filter by sound source, or atleast by position in space, and look for "speech-like patterns" at each point in space
23:57:39 <nshepperd> combine a bunch of signals from a bunch of microphones, so that the signal from the target location interferes constructively, while the "noise" from elsewhere interferes (semi-)destructively, resulting in effective amplification of signal
23:58:05 <augur> yeah thats what im poking around with right now :)
