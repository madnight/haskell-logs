00:00:31 <nshepperd> the most simple method would be to delay each source so as to exactly counter the propagation delay from the target to the microphone due to the speed of sound, then add up the signals
00:02:24 <nshepperd> of course you can also do this in reverse with multiple speakers to try and localize sound _output_
00:03:59 <augur> nshepperd: yeah, the problem im foreseeing tho is that there will be cyclic hotspots in space
00:08:41 <levi> Yeah, beam-forming works better with larger arrays.
00:09:50 <augur> what is beamforming D:
00:10:32 <levi> I read a research paper from a team that developed a WiFi device localization device by creating access points with large antenna arrays using some SDR hardware. They achieved cm-level accuracy in locating handheld devices.
00:11:15 <augur> levi: wow thats pretty accurate
00:12:14 <doismellburning> levi: got a link perchance please? that sounds relevant to my interests
00:12:40 <levi> https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final51.pdf
00:13:04 <doismellburning> levi: thanks
00:14:12 <johnw> doismellburning: http://media.catmoji.com/post/r9s/this-is-relevant-to-my-interests-uu.jpg
00:15:27 <Fuuzetsu> to OSX users, is GTK3 easier to get get going that GTK(2) on OSX?
00:15:31 <Fuuzetsu> than*
00:16:33 <Sizur> @pl f a = b (c (d a) . e) g
00:16:33 <lambdabot> f = flip b g . (. e) . c . d
00:16:44 <levi> Also fun: https://www.usenix.org/system/files/conference/nsdi14/nsdi14-paper-adib.pdf
00:17:15 <levi> That one describes Kinect-like human imaging via radio signals that works through walls.
00:17:38 <Fuuzetsu> how long have MVars been around? I see some code here that uses IORefs and I don't know whether that's by design or just because it's so old
00:20:06 <levi> This 1996 paper describing Concurrent Haskell is probably around when they were introduced: http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz
00:23:42 <levi> Looks like multiple threads and channels predated MVars: http://web.cecs.pdx.edu/~mpj/pubs/par.html
00:29:31 <Sizur> @pl f a = b (c (d a) . e . h) g
00:29:32 <lambdabot> f = flip b g . (. (e . h)) . c . d
00:29:55 <levi> This one from '95 (the par paper was from '93) develops the par idea a bit more: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.29.4173
00:31:06 <levi> So the introduction of MVars probably came to Haskell via GHC in the '95/'96 time frame.
00:31:29 <levi> And now I am off to sleep.
00:51:48 * hackagebot peyotls 0.1.4.2 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.4.2 (YoshikuniJujo)
00:55:55 <Sizur> Has anybody tried Haste here?
00:56:48 * hackagebot peyotls 0.1.4.3 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.4.3 (YoshikuniJujo)
00:56:56 <tranma> it's pretty good
00:57:06 <tranma> compiled a small program with pipes fine
01:00:46 <Sizur> that's pretty cool.  it seems it would be possible to for Coq to produce a client-server app then
01:00:57 <Sizur> that's theoretically proven to be correct
01:01:49 * hackagebot peyotls 0.1.4.4 - Pretty Easy YOshikuni-made TLS library  http://hackage.haskell.org/package/peyotls-0.1.4.4 (YoshikuniJujo)
01:05:30 <haasn> Is it just theoretically proven to be correct or also practically proven to be correct?
01:10:51 <quchen> There are many layers to "theoretically proven correct" anyways.
01:11:07 <quchen> The compiler verifying your proof has to be correct. Your hardware has to be.
01:13:46 <sgronblo> levi: Demand Side Platform (very vague term)
01:14:10 <no-doz> :t hGetContents
01:14:11 <lambdabot>     Not in scope: ‘hGetContents’
01:14:12 <lambdabot>     Perhaps you meant one of these:
01:14:12 <lambdabot>       ‘BSC.hGetContents’ (imported from Data.ByteString.Char8),
01:16:03 <dfeuer> quchen, as long as the relays don't stick and the fuses don't blow, the hardware should be good.
01:16:38 <dfeuer> Of course if you're using one of those newfangled "electronic" computers made with vacuum tubes, all bets are off.
01:17:20 <quchen> I'm running my proofs on my self-built Minecraft computer so I'm fine
01:31:11 <Sizur> @pl f a b = c ( d (e ["", b]) ) a
01:31:12 <lambdabot> f = flip (c . d . e . ([] :) . return)
01:34:32 <solatis> what is a good library for a REALLY simple http server (for automated testing purposes) ?
01:34:59 <solatis> just happstack-server? seems a bit like overkill
01:37:53 <jkarni> solatis: scotty?
01:38:04 <solatis> let me google that
01:39:50 <solatis> scotty looks sweet!
01:43:07 <jkarni> solatis: I'm partial to happstack, but if you want simple, scotty is probably best
01:44:53 <solatis> jkarni: yeah, i want really really simple -- anything that even involves routing is overkill :)
01:45:10 <solatis> just to test a http client
01:46:54 * hackagebot statistics-linreg 0.3 - Linear regression between two samples, based on the 'statistics' package.  http://hackage.haskell.org/package/statistics-linreg-0.3 (AlpMestanogullari)
01:51:55 * hackagebot projection 0.1 - Projection function for arbitrarily nested binary product types.  http://hackage.haskell.org/package/projection-0.1 (PatrickBahr)
01:56:56 * hackagebot compdata 0.9 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.9 (PatrickBahr)
02:01:57 * hackagebot compdata-automata 0.9 - Tree automata on Compositional Data Types  http://hackage.haskell.org/package/compdata-automata-0.9 (PatrickBahr)
02:04:55 <mmmm> What does it mean to say that a Pattern `P` provides constraints `CP`
02:06:03 <johnw> mmmm: where are you reading that?
02:06:14 <mmmm> https://ghc.haskell.org/trac/ghc/ticket/8581#comment:10
02:06:43 <johnw> ah, pattern synonyms
02:06:57 * hackagebot compdata-dags 0.1 - Compositional Data Types on DAGs  http://hackage.haskell.org/package/compdata-dags-0.1 (PatrickBahr)
02:08:48 <bennofs> reload
02:09:07 * doismellburning shoots outside of the screen
02:14:56 <Gaelan> @pl locateCharacter character = fst . head . filter \ (_, char) -> char == character
02:14:57 <lambdabot> (line 1, column 49):
02:14:57 <lambdabot> unexpected '\\'
02:14:57 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
02:15:13 <Gaelan> @pl locateCharacter character = fst . head . filter (\ (_, char) -> char == character)
02:15:14 <lambdabot> locateCharacter = ((fst . head) .) . filter . (. snd) . (==)
02:17:44 <SwashBuckla> what might the 'f' in `fmap` stand for?
02:17:49 <quchen> Functor
02:17:58 <SwashBuckla> mm
02:18:07 <SwashBuckla> I think so too
02:18:51 <quchen> "map" is taken for list mapping, so it was called fmap
02:19:15 <bernalex> SwashBuckla: hi Simon
02:19:18 <SwashBuckla> List is an instance of Functor, right?
02:19:21 <SwashBuckla> hi bernalex !
02:19:24 <Haskellfant> SwashBuckla: yes
02:19:36 <bernalex> SwashBuckla: yes it is. map is a mistake, and a case of haskell being list-supremacist. ;-)
02:19:46 <SwashBuckla> haha
02:19:55 <Gaelan> I'd think that there wouldn't be any back-compat issues with making map take a Functor.
02:20:18 <Gaelan> Other than maybe people relying on it to type-infer their function to take a list
02:20:25 <SwashBuckla> > fmap (+1) [1..5]
02:20:27 <lambdabot>  [2,3,4,5,6]
02:20:41 <bernalex> Gaelan: I think I agree.
02:20:47 <bernalex> SwashBuckla: we tend to write fmap <$> because we're ricers
02:20:47 <jkarni> bernalex: but then error messages involving map would mention "Functor", which is pretty scary if you're just starting out
02:20:48 <Gaelan> > map (+1) [1..5]
02:20:50 <lambdabot>  [2,3,4,5,6]
02:20:53 <bernalex> > (+1) <$> [1..5]
02:20:55 <lambdabot>  [2,3,4,5,6]
02:21:07 <bernalex> jkarni: yes that's the reason map is broken
02:21:17 <doismellburning> eh?
02:21:17 <Hafydd> What if someone wrote an alternative fmap instance for [], and then used it alongside map?
02:21:22 <Hafydd> That sounds like it might get broken.
02:21:33 <hyPiRion> jkarni: Maybe we should just rename Functor to List so that people won't get scared away. That should totally fix things
02:21:36 <doismellburning> Hafydd: alternative fmap instance? like what?
02:21:49 <SwashBuckla> hyPiRion: I agree!
02:21:51 <Hafydd> doismellburning: like fmap _ = error "wololo!"
02:21:56 <SwashBuckla> >_>
02:22:01 <hyPiRion> Hafydd: they'd have to use newtype for that, wouldn't they? As List is a functor already
02:22:08 <Haskellfant> hyPiRion: and monad to burrito?
02:22:10 <MP2E> Hafydd: doesn't obey the Functor laws
02:22:13 <doismellburning> Hafydd: that would violate functor laws
02:22:17 <quchen> newtype WololoList a = WololoList [a]
02:22:19 <Hafydd> That's beside the point.
02:22:20 <bernalex> Hafydd: well... if we changed it, it would be in haskell', so it would be a long way away, and you don't *need* to use the new language. I don't think it's a big enough problem.
02:22:22 <hyPiRion> Haskellfant: No, to Context
02:22:26 <MP2E> actually because of the Functor laws, there can be at most one valid implementation of Functor in Haskell
02:22:28 <doismellburning> anyway y'all have fun
02:22:33 <wz1000> When solving for a binary tree on http://chris-taylor.github.io/blog/2013/02/11/the-algebra-of-algebraic-data-types-part-ii/ , won't there be two roots? Why is one ignored?
02:22:39 <hyPiRion> Haskellfant: Although burrito is a close second
02:22:44 <Gaelan> instance List Maybe where… ;)
02:22:54 <MP2E> per type*
02:23:13 <Hafydd> Isn't there some extension that allows you to override existing instances?
02:23:20 <Hafydd> The point is that it would change the behaviour of a program.
02:23:21 <Haskellfant> MP2E: do proofs exist for thiss
02:23:27 <MP2E> yes
02:23:29 <MP2E> let me grab it
02:24:04 <MP2E> http://article.gmane.org/gmane.comp.lang.haskell.libraries/15384
02:24:12 <Haskellfant> thx
02:24:54 <Cale> wz1000: There's only one which is a power series in a
02:25:01 <Hafydd> Of course, I probably still would support changing fmap to map, on principle.
02:26:03 <quchen> That would be quite a painful change to save one character.
02:26:09 <bernalex> I would just like to have <$> in prelude
02:26:09 <prophile> MP2E: hm
02:26:22 <prophile> does that still hold true with GADTs and whatnot?
02:26:31 <Cale> wz1000: In order for that expression for T(a) to make sense, we're relying on the fact that 1 - sqrt(1 - 4a) is actually divisible by a
02:26:53 <wz1000> Cale: Ah.
02:26:59 * hackagebot language-lua 0.4.4 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.4.4 (OmerAgacan)
02:27:02 <bernalex> quchen: it's not about saving chars (we already have <$> for that), but doing the Right Thing
02:27:23 <wz1000> What does divisibility mean in the context of types?
02:27:33 <bernalex> quchen: haskell has a long history of doing the Right Thing and then being forced to deal with the problems this causes. that's where most of our innovation comes from. :-P
02:28:20 <Cale> wz1000: Well, 1 - sqrt(1 - 4a) is a series which looks like 2 a + 2 a^2 + 4 a^3 + 10 a^4 + 28 a^5 + 84 a^6 + 264 a^7 + 858 a^8 + ...
02:28:43 <wz1000> OK, I get it
02:28:45 <Cale> and you can see that 2a is a factor of every term
02:28:54 <MP2E> prophile: Yep! The proof is given to us by the free theorems of Functor, so if it's a valid functor, there can only be one instance. I believe GHC exploits this to allow Functor to be derived
02:29:24 <MP2E> i should look at the source for that, that sounds interesting
02:29:39 <prophile> from what I understand from the free theorem doesn't that just allow us to derive one law from the other?
02:29:40 <Cale> It's not entirely obvious which series actually have square roots, but 1 - 4a just happens to have one
02:29:51 <prophile> if fmap id = id then fmap (a . b) = fmap a . fmap b
02:30:23 <quchen> bernalex: Doing the right thing is something like importing Foldable/Traversable by default. Stripping an "f" is a non-issue.
02:30:38 <quchen> prophile: Up to strictness that works, yes. https://github.com/quchen/articles/blob/master/second_functor_law.md
02:31:13 <wz1000> Also, why is (a,[a],[a]) more widely used than  ([a],[a]) as a list zipper? Is it inherently better?
02:31:21 <Saizan> prophile: that's one consequence, but the theorem is more general
02:31:55 <prophile> wz1000: the latter doesn't necessarily have a "current element"
02:32:24 <prophile> so it's not a comonad and other such observations
02:32:32 <prophile> Saizan: k
02:33:04 <MP2E> i recommend reading the proof I posted about fmap and playing around with it on a piece of paper
02:33:08 <MP2E> that helped me gain some intuition for it
02:33:38 <prophile> MP2E: I've looked at it before, it's quite pretty—I just thought of existential types and wondered if that changed it at all
02:33:49 <MP2E> ah
02:35:41 <prophile> http://lpaste.net/109799 for instance
02:36:02 <prophile> I'm not sure (1) whether those are valid and (2) whether they are actually distinct in any meaningful way
02:36:12 <prophile> well, whether the second one is valid anyway
02:36:36 <wz1000> Is there any name for values that fix the result of a function, essentialy turning it into a const? Eg:- (*0), (Nothing >>=), ([] >>=), (^0) etc.
02:37:15 <prophile> wz1000: annihilative perhaps, I think that's the term used for the 0*x = x*0 = 0 law for semirings
02:40:58 <nizbel> hi, is learnyourhaskell a good place to start out learning? any other recommendations?
02:41:25 <NougatRillettes> I found it was quite good
02:41:35 <kuyatzu> nizbel: it is, and real world haskell
02:41:37 <hyPiRion> nizbel: I started out with it, and found it nice
02:41:42 <quchen> nizbel: There's also "Programming in Haskell" by Hutton. Either are a good choice.
02:41:45 <hyPiRion> nizbel: and continued with real world haskell
02:41:46 <NougatRillettes> but the tone maybe somewhat a little too loose
02:42:00 <bennofs> nizbel: I found it pretty good. for more advanced libraries I found some chapters of Real World Haskell useful
02:42:05 <bennofs> @where rwh
02:42:05 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
02:42:19 <nizbel> alright, thanks everyone!
02:42:39 <NougatRillettes> I'm facing performances isuues with this code : http://lpaste.net/109800
02:43:00 <kuyatzu> nizbel: https://github.com/NICTA/course/
02:43:13 <NougatRillettes> It's a brainfuck interpreter, and on some input runs wayyy slower than other implementations
02:43:25 <Haskellfant> Is there some simple explanation of why I can replace the foo g with fmap g in the proof of functor instances or do I need to start reading up on free theorems?
02:43:58 <kuyatzu> nizbel: that’s a nice course but a bit hard to understand as a newbie
02:44:37 <NougatRillettes> I know I'm not making any BF code optimization right know (like +++++ becomes Add 5) but my guess is that it should do better even without it
02:44:37 <nizbel> kuyatzu: thanks, i'll check that out too.
02:45:13 <prophile> NougatRillettes: under what cases are there performance problems
02:45:27 <MP2E> prophile: I feel like the second instance of Functor is wrong but I can't seem to prove it, this is a very interesting counterexample :P
02:45:44 * MP2E thinks more
02:45:55 <prophile> MP2E: my guess is that it's correct but that the two aren't distinct in any meaningful way
02:46:34 <NougatRillettes> prophile: hm;;; what do you mean by cases ?
02:46:46 <prophile> well, is it "generally slow" or does it behave badly on a few specific inputs?
02:46:52 <prophile> (also try switching to the strict state monad)
02:46:56 <NougatRillettes> it's generally slow
02:47:03 <prophile> k
02:47:33 <NougatRillettes> hehe, I'm kinda lost with lazyness/strictness
02:47:36 <Saizan> prophile, MP2E: it depends on when you want to consider elements of Bees equal
02:47:58 <prophile> I'd go for "is it possible to distinguish between them"
02:48:07 <prophile> if so, they're unequal
02:48:45 <NougatRillettes> right now (with the Lazy one) operation like (l, x:xs) -> (l, (x+1) : xs) are stored as thunks ?
02:49:07 <Saizan> right, in haskell you can consider them as parametric colimits so you can use bisimulation for equality
02:49:39 <prophile> that sounds very mathematical so probably yes
02:50:22 <prophile> NougatRillettes: you can end up with a long chain of thunks for your state with the lazy state monad
02:50:24 <Saizan> yeah, i'm writing the terms so people can look them up if interested, too lazy to spell them out atm :P
02:50:26 <prophile> which just grows and eats memory
02:51:13 <Saizan> anyhow if you think of existentials as crippled dependent pairs then you get MP2E's answer instead, i'd think
02:51:26 <NougatRillettes> hm, could you explain "In this version, sequencing of computations is strict (but computations are not strict in the state unless you force it with seq or the like)." to me ?
02:51:40 <NougatRillettes> (it's from the State.Lazy description)
02:52:06 <NougatRillettes> I don't understand what is being called strictly and what is not
02:52:35 <johnw> basically, put and modify do not force the value put into the state
02:52:56 <johnw> use put $! x
02:52:59 <Saizan> (State.Strict, you mean?)
02:53:01 <johnw> right
02:54:00 <NougatRillettes> (yes State.Strict, sry)
02:54:22 <NougatRillettes> hm, but what is costly to stock are all the operation on the list zipper in my case isn't it ?
02:56:18 <wz1000> Is laziness more 'correct' than strictness? With laziness, you would be able to access the 5th element of a list where the 4th element is the result of a non terminating computation. Or compare numbers to infinity. Are there any cases where strictness is more 'correct' than laziness?
02:56:58 <NougatRillettes> On a fold
02:57:13 <NougatRillettes> like fold (+) [1.. 10000]
02:57:41 <prophile> I wouldn't say it's more correct in that case
02:57:48 <prophile> just quite a bit faster to evaluate
02:58:35 <NougatRillettes> And maily more memory efficient
02:59:07 <hyPiRion> wz1000: not more correct, but easier to reason about time complexities I'd say.
02:59:31 <hyPiRion> both strict and lazy programs can be non-terminating
03:00:48 <wz1000> hyPiRion: Yes, but is there any program that is terminating in strict semantics, but not in lazy semantics
03:02:04 * hackagebot compdata-param 0.8.0.2 - Parametric Compositional Data Types  http://hackage.haskell.org/package/compdata-param-0.8.0.2 (PatrickBahr)
03:02:43 <prophile> "newtype Hyper b c = H (Hyper c b -> c)"
03:02:51 <prophile> this is an arrow
03:02:52 <prophile> wat
03:03:50 <bezirg> question: in haskell is there any other difference between data constructors and functions than that data constrs can be used in pattern matching?
03:04:37 <bernalex> quchen: again, it's not about stripping the 'f'. it's about getting rid of map entirely. at which point fmap might as well be called map.
03:04:52 <prophile> bernalex: Idris did that
03:05:47 <wz1000> bezirg: They are quite similar in many respects, but a data contructor gives a final value, wheareas a function gives you a thunk with the promise of a value.
03:06:53 <quchen> bernalex: I see. I guess it's a matter of taste whether you want to use monomorphic functions sometimes. I wouldn't support removing concatMap in favour of =<< for example.
03:06:54 <hyPiRion> wz1000: I won't believe so, although a lazy program may terminate in cases where a strict program may not.
03:07:31 <hyPiRion> s/won't/don't/
03:08:01 <quchen> wz1000: A (data) constructor gives you a thunk as well, it doesn't do any computation.
03:08:39 <bernalex> quchen: I sure would be in favour of doing just that :-]
03:08:53 <prophile> a fully applied data constructor will never give you _|_, a fully applied function still might
03:08:56 <bernalex> I want as few primitives as possible
03:09:10 <prophile> neither =<< nor concatMap are primitives
03:09:40 <bernalex> prophile: that's kind of handwavy. call them what you'd like. I mean language definition functions.
03:09:48 <bezirg> I agree with the _|_
03:10:02 <bezirg> what about recursion?
03:10:10 <quchen> Minimal API is not really something you should aim for. Usable is good, minimal may be a consequence of that.
03:10:56 <quchen> I'm sure there are many things you could make shorter using Category/Arrow, but that would not be beneficial.
03:11:35 <bernalex> quchen: sometimes it would, sometimes it would not. :-]
03:13:57 <bezirg> I mean using data constructors, somebody would expect only primitive recursion?
03:14:08 <bezirg> maybe I am wrong onthis
03:22:07 * hackagebot digestive-functors-aeson 1.1.11 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.1.11 (OliverCharles)
03:34:09 <NougatRillettes> How come the commented versions are way faster than the one not commented ?
03:34:20 <NougatRillettes> I thought that forcing evaluation of f x would help
03:36:15 <NougatRillettes> http://lpaste.net/109801
03:42:17 <k00mi> you can use modiy' if you want to be strict in the new state
03:42:42 <ClaudiusMaximus> NougatRillettes: your decr with (1 -) does the wrong thing
03:42:57 <ClaudiusMaximus> NougatRillettes: probably you want (subtract 1)
03:43:13 <bennofs> ClaudiusMaximus: (1 -) works fine iirc. (- 1) is a problem
03:43:18 <bennofs> > (1 -) $ 3
03:43:20 <lambdabot>  -2
03:43:33 <bennofs> ah, right. Forgot to think
03:43:34 <ClaudiusMaximus> bennofs: sure, but it doesn't decrement :)
03:43:40 <NougatRillettes> damm, I'm so dumb
03:43:52 <NougatRillettes> :d
03:44:03 <NougatRillettes> thx
03:45:14 <pavonia> > pred 3
03:45:16 <lambdabot>  2
03:46:23 <ClaudiusMaximus> NougatRillettes: how are you measuring timings?  the commented version might be quicker if it just builds up a thunk that never gets evaluated
03:46:34 <bernalex> pred is nonsafe btw
03:46:51 <pavonia> bernalex: In what way?
03:46:52 <quchen> Depends on the type of its argument.
03:46:55 <bernalex> > pred LT
03:46:56 <lambdabot>  *Exception: Prelude.Enum.Ordering.pred: bad argument
03:47:02 <ClaudiusMaximus> > pred (minBound :: Int)
03:47:02 <NougatRillettes> ClaudiusMaximus: the +RTS -s option, but I think all thunk are eventually evaluated
03:47:03 <lambdabot>  *Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
03:47:07 <prophile> > succ GT
03:47:08 <lambdabot>  *Exception: Prelude.Enum.Ordering.succ: bad argument
03:47:20 <pavonia> >  (minBound :: Int) - 1
03:47:21 <prophile> Enum is unsafe
03:47:22 <lambdabot>  9223372036854775807
03:47:40 <pavonia> Is this considered safe?
03:47:46 <bernalex> pavonia: yes
03:47:51 <quchen> Enum+Bounded is unsafe.
03:47:53 <bernalex> pavonia: but it's probably not what you want either
03:48:17 <bernalex> might want a predMaybe. IDK. :-]
03:48:23 <pavonia> I wouldn't call that safe, it's just a different version of usafe to me
03:48:33 <bernalex> pavonia: it's safe in that it doesn't cause a runtime crash.
03:49:18 <NougatRillettes> and thx for modify' k00mi :)
03:49:33 <ClaudiusMaximus> you could argue that crashing is safer than doing the wrong thing on overflow
03:50:08 <bernalex> ClaudiusMaximus: with a different definition of safe than I am using maybe :-]
03:50:44 <bernalex> formally, a haskell program can't crash.
03:50:54 <bernalex> if a program typechecks, it is guaranteed to not crash. :-]
03:50:56 <ClaudiusMaximus> yep.  not sure if haskell implementations are allowed to throw exceptions on Int overflow
03:51:08 <bernalex> s/haskell/GHC/ BTW, I sometimes forget that not everyone equate them ;-)
03:51:53 <barrucadu> bernalex: That breaks down in the presence of unsafe functions though, surely
03:51:56 <NougatRillettes> hm bernalex how do you call main = (hd []) `seq` (return ()) then ?
03:51:58 <felixsch> how do I check which base version is currently installed on my system?
03:52:11 <barrucadu> So as long as there are functions like unsafeCoerce, that guarantee can't be made
03:52:30 <pavonia> felixsch: ghc-pkg list base
03:52:36 <zwer> > fromIntegral (minBound :: Int) - 1 :: Integer
03:52:37 <bernalex> barrucadu: ah, yes the definition assumes not using FFI etc. :-]
03:52:38 <lambdabot>  -9223372036854775809
03:52:47 <felixsch> pavonia: ah nice thanks :)
03:52:57 <bernalex> NougatRillettes: I don't understand what hd is
03:53:04 <bennofs> bernalex: head
03:53:12 <bernalex> then that is not a crash.
03:53:31 <bernalex> the formal definition of a crash does not include things like pattern matching failures etc. these are sometimes known as "soft crashes".
03:53:43 <quchen> Crash has a formal definition?
03:54:11 <bernalex> quchen: yes, it is formalised by the progress and type preservation theorems that prevent execution from getting stuck.
03:54:17 <NougatRillettes> bernalex: because they would be spot by ghc -Wall ?
03:55:09 <bernalex> NougatRillettes: I don't think that plays into it.
03:55:29 <bernalex> SPJ once told me to search for "progress and preservation" to learn more, but I never found the time. guess I should. :-]
03:55:36 <quchen> bernalex: So you'd call a "statically visible failure" a "soft crash", while a real exception, such as calling `error`, a "hard crash"?
03:55:42 <bernalex> GHC's proofs are available in http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/ :-]
03:56:13 <bernalex> quchen: I'm not sure if calling error is a hard crash, actually. a hard crash would be segfaults.
03:56:54 <bernalex> you should ask simonm & maybe especially SPJ about it. the latter wrote the theorems for GHC's intermediate lang. :-]
03:57:46 <quchen> bernalex: Which paper is it? "Equality proof and deferred type errors"?
03:58:04 <bernalex> quchen: all of them touch into them somehow
03:58:19 <quchen> Uh okay
03:58:30 <bernalex> quchen: I don't think one of them has a "list of theorems"
04:00:32 <bernalex> quchen: I just sent an email to ghc-devs asking SPJ or someone to make a wiki article. :-]
04:01:38 <quchen> Neat.
04:01:48 <quchen> bernalex: What intermediate language are the proofs talking about anyway?
04:03:08 <bernalex> quchen: I would assume it's in the simplification of core -- so desugared & simplified core. but it might be STG -- I honestly do not know.
04:03:36 <quchen> Hm okay, thanks anyway.
04:03:51 <bernalex> quchen: I'll let you know if SPJ or someone replies.
04:03:59 <bernalex> quchen: unless you follow ghc-devs yourself :-]
04:04:10 <quchen> I am
04:20:45 <Fuuzetsu> is there a definition for [minBound .. maxBound] already?
04:21:03 <Twey> Fuuzetsu: https://hackage.haskell.org/package/universe
04:21:51 <Fuuzetsu> too lazy to integrate another package into my XMonad ;^)
04:22:27 <quchen> Fuuzetsu: "import somePackage; … = everything" is already longer than what you wrote.
04:22:39 <quchen> And you don't need to specify maxBound there anyway.
04:22:39 <Fuuzetsu> quchen: maybe it's in Prelude!
04:22:44 <Fuuzetsu> ah, right
04:23:04 <quchen> "enumFrom minBound" is so short I doubt it's worth having a lib for it.
04:23:15 <Fuuzetsu> [minBound ..] is shorter
04:23:25 <quchen> But in Prelude you can never know. Maybe there's a monomorphic version for Int in it ;-)
04:29:45 <Twey> … I'm trying to do heap profiling.  I've been using the -hy and -hr options, and found a leak with them.  Now I'm trying to profile a different part of my program, which is in a separate package, so I recompiled my library and executable (cabal install --enable-library-profiling --enable-executable-profiling --ghc-option=-fprof-auto --ghc-option=-rtsopts) and now ./my-program +RTS -hr tells me: invalid
04:29:47 <Twey> heap profile option: -hr
04:31:23 <Fuuzetsu> Twey: http://heap.ezyang.com/ in case you didn't know about this
04:32:02 <Twey> Fuuzetsu: It's NDA'd for now, so I don't think I can share it :-\
04:32:06 <Fuuzetsu> Twey: you're missing --ghc-option=-prof I think
04:32:15 * hackagebot rados-haskell 3.1.0 - librados haskell bindings  http://hackage.haskell.org/package/rados-haskell-3.1.0 (ChristianMarie)
04:32:16 <Fuuzetsu> also nix can do all that crap for you
04:32:36 <Twey> Oh, I assumed that was what --enable-library-profiling did
04:33:01 <Fuuzetsu> I wasted some time chasing similar problem recently and I think that's what it ended up being
04:34:04 <dcoutts_> Twey: yes, odd, --enable-library-profiling will use -prof for the lib, and --enable-executable-profiling will use it for the exes
04:34:32 <dcoutts_> Twey, Fuuzetsu: if you work it out and think it's a cabal or ghc bug, let us know, we can file a ticket
04:34:52 <Fuuzetsu> dcoutts_: unrelated: do you have any ETA on that CBOR stuff?
04:35:24 <dcoutts_> Fuuzetsu: not at the moment, working on another project currently (removing the ghc library's dep on the Cabal lib)
04:36:35 <hvr> dcoutts_: speaking of which... I can't wait to see your changes show up in Phab :-)
04:36:46 <hvr> any rought ETA/
04:36:48 <hvr> ?
04:36:51 <dcoutts_> Fuuzetsu: but I did overcome a sticking point on the types with the help of kosmikus
04:37:06 <Twey> Fuuzetsu: ‘Nix can do that for you’ — I'd assume so, but I don't know how to pass everything I want
04:37:40 <dcoutts_> hvr: maybe today, maybe tomorrow
04:38:08 <Fuuzetsu> Twey: simply use profiled version of GHC; for your own project either use nix-build or pass all the flags in directly in the nix expression
04:38:28 <Fuuzetsu> actually I think you can keep default.nix as-is and then in shell.nix simply pick the profiled version and it will Just Work™
04:38:44 <Fuuzetsu> gonna try that
04:39:27 <hvr> dcoutts_: wow... that's earlier than I expected :)
04:40:35 <Twey> Fuuzetsu: There's no option to cabal.mkDerivation for arbitrary --ghc-option flags, as far as I can see
04:41:03 <Fuuzetsu> configureFlags = [ … ] IIRC
04:41:11 <Fuuzetsu> (for cabal flags which take GHC flags)
04:41:12 <Fuuzetsu> I forgot
04:41:31 <Fuuzetsu> oh there we go
04:41:32 <Fuuzetsu>   # extraConfigureFlags = [ "--ghc-option=-fprof-auto"
04:41:32 <Fuuzetsu>   #                         "--ghc-option=-rtsopts"
04:41:33 <Fuuzetsu>   #                         "--enable-executable-profiling"
04:41:35 <Fuuzetsu>   #                       ];
04:42:16 * hackagebot helm 0.6.1 - A functionally reactive game engine.  http://hackage.haskell.org/package/helm-0.6.1 (ZackCorr)
04:53:29 <frerich> harri: An improved patch (in fact, a patch set) is now at http://osaka-express/~frerich/coveragescanner-no-abort-on-error-patches.zip -- it improves on the previous diff in that it's actual commits (i.e. with commit messages) you can apply with 'git am'. The new patch will also print more error output, making it explicit that the invocation will be forwarded to the native compiler. I also added some documentation
04:53:29 <frerich>  to mention the switch in release notes and coveragescanner synopsis.
04:53:44 <frerich> ergs, wrong channel, sorry.
04:54:41 <frerich> In fact, I didn't mean to write this in *any* channel. It's unfortunate how command terminals and IRC clients both react to 'Arrow-up, Return'. So when you Alt+Tab, Arrow-up, Return very quickly- you better know where 'Alt-Tab' puts the focus, ahem...
04:57:59 <nilg> can I use a conditional (if-then-else) inside a do?
04:58:12 <thebnq> sure
04:58:31 <barrucadu> nilg: do-notation just desugars to regular Haskell
04:58:48 <zomg> frerich: once upon a time I wrote a program switcher which used arrow keys, so you always knew which window you would get :)
05:01:17 <Fuuzetsu> frerich: stealing patches **right now**
05:01:37 <dottedmag> frerich: Ctrl-[fbnp] instead of arrows?
05:01:39 <Fuuzetsu> although that seems like an internal domain
05:03:00 <barrucadu> Fuuzetsu: It's ok, just brute-force your way into all networks
05:03:42 <Fuuzetsu> @hoogle [Network] -> Patchset
05:03:45 <lambdabot> Warning: Unknown type Patchset
05:03:46 <lambdabot> No results found
05:04:05 <Fuuzetsu> should be in base by 7.10
05:17:20 * hackagebot xcb-types 0.7.0 - Parses XML files used by the XCB project  http://hackage.haskell.org/package/xcb-types-0.7.0 (AntoineLatter)
05:30:02 <Twey> Gah, now the runtime isn't even producing a .hp file…
05:31:58 * Twey has no idea how to go about trying to debug this
05:35:21 <zmbmartin> Is there a cleaner way to do this with applicative functors or something -> https://gist.github.com/codedmart/5270ab526b2df39eeff6
05:41:02 <Twey> zmbmartin: It would be cleaner to just work on Text and not do the round-trip from String and back…
05:41:29 <zmbmartin> Twey: Yeah I am trying that out as well.
05:41:30 <Twey> Then bodyToParams = map ((head &&& last) . T.split (== '=')) . T.split (== '&')
05:42:09 <Twey> Though I think you should really add some error-checking to that ‘head’
05:43:10 <zmbmartin> Twey: yeah I know I need to add some error checking. Just trying to get things working. Still trying to grasp haskell more and more :)
05:43:42 <Twey> zmbmartin: You'd probably have more luck with (Atto)Parsec
05:44:46 <k_bx> Silly lens question: what is a shorthand of doing `. to (fmap foo)` for a maybe-value?
05:45:31 <Twey> k_bx: That doesn't look like valid syntax…
05:45:49 <jle`> perhaps he means (. to (fmap foo))
05:45:51 <Twey> :t let to = undefined; foo = undefined; . to (fmap foo)
05:45:52 <lambdabot> parse error on input ‘.’
05:45:54 <Twey> Oh
05:45:54 <zmbmartin> Twey: OK thanks I will look into that.
05:46:01 <k_bx> Twey: full piece of code is something like `foo ^. bar . to (fmap baz)`
05:46:02 <jle`> just a guess
05:46:08 <Twey> Ah, with Lens
05:46:10 <k_bx> where bar returns Maybe-value
05:46:39 <Twey> There's <&>
05:46:45 <Twey> foo ^. bar <&> baz
05:46:51 <Twey> (if the precedence is right)
05:46:57 <k_bx> Oh, that's interesting, thanks
05:47:23 <k_bx> Seems to work! Thanks again.
05:47:25 * hackagebot irc-ctcp 0.1.0.0 - A CTCP encoding and decoding library for IRC clients.  http://hackage.haskell.org/package/irc-ctcp-0.1.0.0 (barrucadu)
05:50:39 <supki> :t \l f -> views l (fmap f)
05:50:40 <lambdabot> (MonadReader s m, Functor f) => Optical (->) (->) (Const (f b)) s s (f a) (f a) -> (a -> b) -> m (f b)
05:51:24 <jle`> sometimes i wouldn't mind a flip fmap
05:51:44 <jle`> especially for forM-like idioms
05:51:51 <jle`> but sometimes i would
05:51:56 <jle`> this is the nature of life
05:52:54 <Krakarn> since <**> is flip <*>, wouldn't <$$> be flip <$>?
05:53:50 <jle`> flip fmap is often used as <&>, in analogy to <$>
05:54:07 <jle`> s/used/defined
05:55:05 <jle`> idk thouuugh
05:55:50 <blakehaswell> How can I inline this?
05:55:52 <blakehaswell> main = do
05:55:52 <blakehaswell>     s <- getContents
05:55:53 <blakehaswell>     print $ fromJust (solve <$> parse s)
05:56:11 <pjdelport> Krakarn: <**> not quite flip <*>; it's liftA2 (flip ($))
05:56:32 <pjdelport> (where <*> is liftA2 ($) for comparison)
05:56:44 <jle`> blakehaswell: do you mean not using do ntotation?
05:56:53 <Twey> blakehaswell: main = getContents >>= print . fromJust . fmap solve . parse -- did you mean one-line it?
05:57:31 <Twey> jle`: I like (<&>) from lens
05:57:33 <jle`> print . fromJust . fmap solve . parse =<< getContents
05:57:37 <jle`> but
05:57:41 <jle`> fromJust . fmap solve = solve . fromJust
05:57:53 <Twey> Ah, indeed
05:57:58 <jle`> in real life hopefully you aren' actually using fromJust here
05:58:25 <blakehaswell> Plan to add error handling
05:58:30 <jle`> mhm, assumed so :)
05:58:41 <Twey> print . solve . fromJust . parse =<< getContents -- though I still wish we had a flip (.) instead
05:58:52 <jle`> nah, i like this way better :/
05:58:54 <jle`> it makes more sense
05:59:08 <jle`> it feels more natural in he context of normal function application/composition
05:59:22 <jle`> if we assumed that everything was wrapped in identity, it would be just
05:59:22 <Twey> I'd flip function application, too, though ;þ
05:59:30 <jle`> heh
05:59:37 <jle`> i am in the opposite camp :)
06:00:03 <jle`> because it looks kind of like print . solve . fromJust . parse $ getContents
06:00:10 <jle`> except you use (=<<) instead of ($)
06:00:17 <jle`> it fits in with haskell land more, i think
06:00:35 <Twey> Actually, interesting difference, I find that it varies depending on when I'm in ‘programming mode’ (I have a value and I want to transform it into a different value) and ‘theorem-proving mode’ (I want a value that goes in this hole, but I don't know what it is)
06:01:01 <jle`> i don't think i ever use (>>=)
06:01:07 <Krakarn> :t (<*>)
06:01:08 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
06:01:13 <jle`> except to draw the haskell logo
06:01:14 <frerich> blakehaswell: You might also find 'interact' useful, i.e. "interact (fromJust . (fmap solve) . parse)"
06:01:19 <Krakarn> :t flip (<*>)
06:01:20 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
06:01:24 <Twey> I generally use >>= and write and read it left-to-right as a pipeline
06:01:26 <Krakarn> :t (<**>)
06:01:27 <lambdabot> Applicative f => f a -> f (a -> b) -> f b
06:01:33 <doismellburning> :t interact
06:01:34 <Twey> I.E. in the order that it's executed
06:01:34 <lambdabot> (String -> String) -> IO ()
06:01:35 <frerich> blakehaswell: I think I forgot a 'show' at the front
06:02:06 <blakehaswell> Thanks guys. That's useful. A week or so without writing anything and I can’t see how the types flow… ugh
06:02:14 <Twey> main = interact $ show . solve . fromJust . parse
06:02:29 <co-dh> greeting, I'm using sublime haskell, and have following error, ModuleInspector returns error: Parse failed at SrcLoc , any help?
06:02:37 <jle`> i like to think that (=<<) and (.) and friends reflect the order of the driving of evaluation
06:02:47 <jle`> when you take into account lazy IO and stuff like that
06:02:49 <jle`> but
06:02:58 <jle`> this makes more sense in (.) only...
06:03:12 <frerich> Twey: I think he rather wants 'main = interact $ show . fromJust . (fmap solve) . parse'
06:03:13 <jle`> i guess when you use IO, you are more concerned about the order of effects
06:03:20 <blakehaswell> Oh I forgot about interact, nice one frerich
06:03:29 <jle`> fromJust . fmap solve == solve . fromJust
06:03:40 <co-dh> it's using haskell-src-exts-1.0.1, parseFileContents, but I believe it should use parseFileContentsWithMode. just don't know how to fix it.
06:04:07 <frerich> jle`: Ah oops, of course.
06:04:38 <Twey> jle`: I prefer to take lazy IO into as little account as possible :þ
06:04:47 <jle`> maybe i will start using (>>=) for noncommutative monads
06:04:57 <jle`> but that's kind of weird to draw that line
06:05:01 <ttjake> @hoogle Read a => String -> Maybe a
06:05:04 <lambdabot> Network.CGI.Protocol maybeRead :: Read a => String -> Maybe a
06:05:04 <lambdabot> Network.CGI readCookie :: (Read a, MonadCGI m) => String -> m (Maybe a)
06:05:04 <lambdabot> Network.CGI readInput :: (Read a, MonadCGI m) => String -> m (Maybe a)
06:05:21 <ttjake> wasn't there such a function in Prelude?
06:05:30 <Twey> Nope
06:05:36 <Twey> :t reads
06:05:38 <lambdabot> Read a => ReadS a
06:05:39 <ttjake> added recently
06:05:44 <jle`> there's one in base i believe
06:05:50 <jle`> hm.
06:05:52 <jle`> mayb enot
06:05:53 <Twey> Oh, it's in Text, isn't it?
06:06:17 <ttjake> i believe it was string. added one or two ghc versions ago
06:06:49 <Twey> ttjake: Text.Read.readMaybe
06:07:19 <ttjake> yes that is the one. thanks
06:07:55 <jle`> i need to start importing that
06:08:04 <ttjake> hoogle can't find it by the way. http://www.haskell.org/hoogle/?hoogle=readMaybe
06:22:20 <Twey> In distributed-process, what's the appropriate way to terminate a local node so it doesn't leak memory? (dcoutts_?)  There's a closeLocalNode, but it doesn't actually free the node
06:23:05 <Twey> But that's marked as ‘force-close’, so is there some way to *gracefully* kill a node?
06:25:47 <dcoutts_> Twey: I think closeLocalNode should be the right answer, but it looks like it doesn't quite close everything
06:26:00 <dcoutts_> Twey: you'd also have to stop the processes running on the node
06:26:14 <dcoutts_> btw, but it's not clear that closeLocalNode should do that
06:27:31 <dcoutts_> Twey: it will stop all incoming and outgoing messages (it shuts down the network connection for the new)
06:27:38 <dcoutts_> new/node
06:28:27 <dcoutts_> Twey: I don't have a very good answer, we'd need to audit the node resources to make sure we can shut it down cleanly
06:29:46 <Twey> Right, I've got a program that's spawning and closing a bunch of nodes (simulating a network), but due to the node processes still running it looks like it's leaking memory
06:30:04 <Twey> Hm, alright.  Thanks
06:43:40 <timd> If I have a pair of lenses to access 2 different fields of the same structure, how do I construct a traversal over both of them (assuming the fields have the same type)?
06:44:04 <edwardk> timd: the problem here is that you can't know just from the types you've given that they don't overlap
06:44:22 <edwardk> timd: consider _1 and _1 now you have two updates for one location
06:44:31 <edwardk> this is the sort of thing that faces such an implementation
06:44:39 <timd> Oh. I see.
06:44:58 <edwardk> we have tricks available to you, you can do folds very easily
06:45:11 <edwardk> > (1,2,3)^..(_1 <> _3)
06:45:13 <lambdabot>  [1,3]
06:45:18 <timd> That seems to preclude a general combinator. But is there something that works if I know there is no overlap?
06:46:07 <timd> I'm trying to do something that seems simple really. I have a data structure will a bunch of fields of the same type, and I'm looking for a shorthand to update them all.
06:46:08 <edwardk> timd: we don't currently have one. the other thing it precludes is having a combinator that works across multiple lens-types, so writing it at all is a bit of a frustrating exercise in dealing with the vagaries of the particular corner of the lens hierarchy you want to support
06:46:24 <edwardk> timd: there is a way to do that with makeLensesFor IIRC
06:46:58 <edwardk> you can tell it to map several fields to the same traversal there
06:47:34 * hackagebot STL 0.2.0.1 - STL 3D geometry format parsing and pretty-printing  http://hackage.haskell.org/package/STL-0.2.0.1 (bergey)
06:47:36 * hackagebot aws-ec2 0.2.1 - AWS EC2/VPC, ELB and CloudWatch client library for Haskell  http://hackage.haskell.org/package/aws-ec2-0.2.1 (VladimirKirillov)
06:47:47 <edwardk> timd: it is a common enough request though, perhaps you should throw an issue on github.com/ekmett/lens/issues
06:50:19 <timd> Thanks - just looking at makeLensesFor now. I don't think it solves my problem. In actual fact the fields that I want to provide parallel updates for are in "child" structures, not the base one.
06:51:10 <co-dh> what is the (..) means in import of a Data?
06:52:18 <timd> edwardk: Anyway, thanks for letting me know that its not just me failing to read the doco...
06:52:22 <pjdelport> co-dh: What's the full line? It usually means importing all the constructors of a data type.
06:52:46 <co-dh> module Language.Haskell.Exts.ParseMonad(         -- * Parsing         P, ParseResult(..), atSrcLoc, LexContext(..),         ParseMode(..),
06:53:10 <jle`> co-dh: compare Maybe(Just, Nothing)
06:53:13 <jle`> to Maybe(..)
06:53:42 <co-dh> thanks! it's just hard to google and find it.
06:54:14 <jle`> heh, admittedly :)
06:54:39 <jle`> i think the Haskell report is a good reference for syntaxy things like this
06:59:26 <k_bx> One more simple lens questions I can't figure out for some time now. How would you filter a hashmap by some keys? Like to filter H.fromList [("foo", "bar"), ("baz", "qux")] by (== "baz") ? Thanks.
07:00:22 <k_bx> Big picture is that I'm trying to filter a list of json objects by their keys (while keeping it as json), that's why non-lens is too verbose to just use.
07:02:39 <frerich> k_bx: A HashMap can contain an entry with a given key just once, no? E.g. 'H.size (H.fromList [("foo", "bar"), ("baz", "qux"), ("baz", "yoyodyne")])' would be '2'.
07:03:04 <k_bx> frerich: the task is to remove couple keys from hashmap (well, json structure originally)
07:04:23 <frerich> k_box: You could use 'difference' for that
07:05:59 <frerich> k_box: I think "H.difference (H.fromList [("a",1),("b",1),("c",1)]) (H.fromList [("a",1),("c",1)])" will result in a hashmap with just ("b", 1) in it
07:08:44 <pjdelport> k_bx: filterWithKey :: Ord k => (k -> a -> Bool) -> HashMap k a -> HashMap k a ?
07:10:52 <frerich> Oh yeah that looks nicer.
07:14:18 <k_bx> frerich: pjdelport: so, the real task is to filter (J.toJSON (V.fromList [J.object [("foo", J.String("bar"))], J.object [("baz", J.String("qux"))]...). To put it more simple, you have a parsed json from [{"foo": "bar"}, {"baz": "qux"}], and you need to go through each object and remove key "baz". Result would be [{"foo": "bar"},{}] in this case.
07:14:31 <k_bx> pjdelport: ^ (don't know if you were notified)
07:17:35 <k_bx> Actually, probably I know where my mistake was :/ instead of trying to traverse/filter I could just do `over` and use this filterWithKey thing
07:19:07 <supki> k_bx: json & _Array.traverse._Object.at "baz" .~ Nothing
07:20:01 <k_bx> supki: awesome, thanks!
07:20:01 <supki> could be simplified to  json & values._Object.at "baz" .~ Nothing
07:20:13 <supki> "simplified"
07:20:34 <k_bx> Can it work for multiple keys? Because probably that's why I didn't think if this solution.
07:20:42 <k_bx> s/if/of/
07:22:24 <supki> well, it's not exceptionally pretty but  values._Object %~ (set (at "baz") Nothing . set (at "qux") Nothing)  will work
07:22:38 * hackagebot rest-core 0.32 - Rest API library.  http://hackage.haskell.org/package/rest-core-0.32 (ErikHesselink)
07:22:40 * hackagebot rest-example 0.1.0.1 - Example project for rest  http://hackage.haskell.org/package/rest-example-0.1.0.1 (ErikHesselink)
07:22:42 * hackagebot rest-gen 0.14.2.1 - Documentation and client generation from rest definition.  http://hackage.haskell.org/package/rest-gen-0.14.2.1 (ErikHesselink)
07:22:44 * hackagebot rest-happstack 0.2.10.1 - Rest driver for Happstack.  http://hackage.haskell.org/package/rest-happstack-0.2.10.1 (ErikHesselink)
07:22:46 * hackagebot rest-snap 0.1.17.13 - Rest driver for Snap.  http://hackage.haskell.org/package/rest-snap-0.1.17.13 (ErikHesselink)
07:22:48 <k_bx> Ah, I see how to combine them now. Thanks again!
07:24:32 <Fuuzetsu> @pl bindWs k f = zip (zip (repeat k) workspaceKeys) (map (withNthWorkspace f) [0..])
07:24:32 <lambdabot> bindWs = (. flip (map . withNthWorkspace) [0..]) . zip . flip zip workspaceKeys . repeat
07:25:26 <pjdelport> k_bx: You could say: map (delete "foo")
07:26:34 <pjdelport> k_bx: Or for multiple keys, perhaps: map (filter (`elem` ["foo","baz"]))
07:27:25 <pjdelport> Or rather map (filter (not . (`elem` ["foo","baz"])))
07:27:49 * hackagebot rest-types 1.10.2 - Silk Rest Framework Types  http://hackage.haskell.org/package/rest-types-1.10.2 (ErikHesselink)
07:27:50 * hackagebot rest-wai 0.1.0.3 - Rest driver for WAI applications.  http://hackage.haskell.org/package/rest-wai-0.1.0.3 (ErikHesselink)
07:31:15 <cow_2001> what's the etymology of the name of the function 'fold'?
07:35:18 <Fuuzetsu> it's Data.Map.keys and Data.Map.…? I'm after values
07:35:28 <Fuuzetsu> I always, always think key-value but it's not value ;(
07:35:43 <Fuuzetsu> @hoogle M.Map a b -> [b]
07:35:46 <lambdabot> Parse error:
07:35:46 <lambdabot>   M.Map a b -> [b]
07:35:46 <lambdabot>     ^
07:35:50 <Fuuzetsu> @hoogle Map a b -> [b]
07:35:52 <lambdabot> Data.Map.Lazy elems :: Map k a -> [a]
07:35:52 <lambdabot> Data.Map.Strict elems :: Map k a -> [a]
07:35:52 <lambdabot> Data.Map.Lazy keys :: Map k a -> [k]
07:35:56 <Fuuzetsu> elems…
07:42:47 <forgottenone> hi i am trying to learn haskell, when i try to write a factorial function in ghci (let fac 0 = 1 let fac x = x* fac (x - 1)) i get an stack overflow. what is the reason of that
07:45:00 <Goplat> If you use two different lets, the later one replaces the earlier
07:45:10 <Goplat> you want "let fac 0 = 1; fac x = ..."
07:45:49 <athan> forgottenone: You could also use an if statement or case branch
07:47:02 <forgottenone> Goplat: i see, thank you. athan: you right but i wanted especially use pattern matching to get the idea
07:47:09 <pyrtsa> Instead of ";" it's also possible to enter longer definition in GHCi by starting with ":{" on the first line and ":}" on the last one.
07:48:24 <athan> forgottenone: That's good! You might find better success writing your own files and compiling them, making `fac` a top-level function without having to use `let`
07:48:39 <pyrtsa> forgottenone: So either do what Goplat did (that's pattern matching already!) or write ":{\nlet fac 0 = 1\n    fac n = ...\n:}" (omitting the quotes and replacing \n with newlines of course).
07:52:25 <forgottenone> athan i use python mainly so using interactive shell during the learning process more comfortable for me
07:52:31 <forgottenone> pyrtsa thank you
07:54:41 <pyrtsa> forgottenone: The workflow where you create a Foo.hs file, then run `ghci Foo.hs` and then just `:reload` it, is pretty convenient for learning as well.
07:55:52 <zmbmartin> Does anyone use scotty? I am trying to parse the body and add those to params. Is that possible?
07:56:14 <forgottenone> pyrtsa, you are right but somehow repl is more familiar for me at first, of course after i figure out something i will change it
07:56:59 <pyrtsa> forgottenone: Yeah, I started the same way too, and often still just play with ghci when I get new ideas. ;)
08:17:22 <kstt> hello
08:17:39 <kstt> my first lens question : how to factor out a lens http://lpaste.net/109809
08:23:43 <c_wraith> kstt: I'm pretty sure you could use over or %~ for that
08:26:07 <cloudhead_> is `head $ Map.toList m` efficient for large maps?
08:26:15 <c_wraith> cloudhead_: yes
08:26:22 <cloudhead_> c_wraith: cheers
08:27:08 <c_wraith> cloudhead_: though findMin might be preferable
08:27:15 <c_wraith> cloudhead_: from a clarity POV
08:27:43 <cloudhead_> oh didn't think that's what it was for
08:27:44 <cloudhead_> cool
08:27:56 <cloudhead_> I thought it related to values, not keys
08:28:12 <c_wraith> It gives you both back, but yeah, it's the minimum key
08:28:19 <cloudhead_> nice, yea
08:31:15 <Algebr> Trying to get a Map where keys are random items, link tries to capture general idea, http://lpaste.net/109810
08:33:55 <c_wraith> Algebr: it is probably easier to seperate generating random keys from building the map.
08:34:27 <Algebr> That's what I was thinking, but then how can I get the foldr to run the action?
08:34:45 <c_wraith> why use foldr?  you could use fromList instead
08:34:58 <Algebr> yea, I know I could, was just trying this angle.
08:35:40 <glguy> You can write something like this http://lpaste.net/109810
08:36:38 <glguy> If your heart is set on a fold, check out
08:36:39 <glguy> :t foldM
08:36:41 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
08:37:35 <gallais> So I'm trying to use prelude-extras to implement Show for my complicated datatype. But it hangs. Any clue? http://lpaste.net/109811
08:37:37 <Algebr> so basically in any situation, the entire map itself will be tagged by IO
08:38:18 <glguy> Algebr: Yes, if you use IO to pick the values of the map, that will be reflected in the type
08:38:26 <c_wraith> :t \xs -> fmap (M.fromList . flip zip xs . randoms) newStdGen -- Algebr
08:38:27 <lambdabot> (Random k, Ord k) => [a] -> IO (M.Map k a)
08:39:48 <glguy> gallais: Normally you use the default implementation of Show1. Here's an example deriving Show for a type using the Bound library
08:39:48 <glguy> http://lpaste.net/109425
08:40:39 <glguy> gallais: But if you're trying to do something more clever intentionally we can try and work that out
08:41:00 <ericjones> How does cabal know not to rebuild a file when things are not changed. It is simply a matter of a check-sum or more. I am trying to get a CI service not to rebuild things it doesn't have to on subsequent builds by caching the appropriate directory. I am caching /dist right now but I think there is something I am missing since restoring the cached dist still results in a clean build.
08:41:26 <c_wraith> ericjones: as far as I know, it leaves that determination to the compiler, and GHC just checks timestamps
08:42:25 <gallais> glguy: in your example, it's simpler: none of the parameters of the datatype are higher order
08:43:30 <gallais> in my case, I have:  Ty (f :: * -> *) (a :: *) and trying to rely on the default implementations generates errors
08:43:38 <c_wraith> :t \seed xs -> M.fromList . flip zip xs . randoms . mkStdGen $ seed -- Algebr, alternatively, you can purify the function, moving the responsibility for generating a good seed to the caller.
08:43:39 <lambdabot> (Random k, Ord k) => Int -> [a] -> M.Map k a
08:45:08 <DenSchub> meta-j-de
08:48:47 <glguy> gallais: I don't think you can use Lift1 here and will have to write out the three cases of instance Show1 f => Show1 (Ty f) where
08:49:05 <glguy> instance Show1 f => Show1 (Lift1 f) where showsPrec1 d (Lift1 a) = showsPrec1 d a
08:49:18 <glguy> You're calling Lift1's show1 which calls yours back
08:50:48 <glguy> instance (Show1 f, Show a) => Show (Lift1 f a) where showsPrec d (Lift1 a) = showsPrec1 d a
08:50:59 <Algebr> So in main, whenever it gets a return (), that immediately ends the program?
08:51:05 <glguy> no
08:51:13 <glguy> return () is a no op
08:51:48 <barrucadu> Algebr: "return" in Haskell is a bit of a misnomer
08:51:49 <Algebr> but it satisifies the type signature of main, so why doesn't that mean the end of program exec?
08:52:16 <Algebr> yea, I realize that return () means "inject" () into the Monad
08:52:22 <gallais> Argh. I was really hoping to avoid writing these (and the Eq1 instances) by hand: my real Ty has 9 constructors & I have two other datatypes defined in the same fashion.
08:52:59 <ChristianS> Algebr: return has nothing to do with the return statement in imperative languages
08:53:20 <geekosaur> not "whenever it gets a return ()" so much as "whenever that is the last action it can perform"
08:53:36 <geekosaur> main = return () >> putStrLn "hi"
08:53:59 <geekosaur> the return does not end the program because it has a following action via (>>)
08:55:45 <jle`> in the context of the IO instance of Monad, return () is the no-op IO action
08:55:59 <jle`> it can be sequenced like any other IO action
08:57:05 <Algebr> geekosaur: Does the last thing always have to be an action?
08:57:06 <jle`> main doesn't "go through every action", per se
08:57:10 <monochrom> an action that quits would have type a -> IO b, not a -> IO a.
08:57:14 <jle`> main is a single IO ()
08:57:29 <geekosaur> Algebr, anything else would be a type error
08:57:30 <jle`> and you create that IO () by merging and combining other IO a's
08:57:46 <ericjones> Is there are reason why GHC checks timestamps when determining what needs to be rebuilt rather than md5sums or something equivalent? Simply copying the dist folder is enough to make GHC think it needs to do a clean build?
08:57:55 <monochrom> perhaps read my http://www.vex.net/~trebla/IO.xhtml
08:57:56 <jle`> Algebr: perhaps instead of thinking about "first or last action"s, you can think of main as literally one IO () action
08:58:07 <Algebr> geekosaur: but clearly not just any action, right? certainly not getLine?
08:58:25 <levi> There's no reason to use 'return ()' at all unless the action "so far" is not of the type 'Monad m => m ()', e.g. 'IO ()' for main, and something else is expecting that type signature. For example, if the last action in main is of type 'IO Int', you would bind '\_ -> return ()' to it to make the type 'IO ()' as expected.
08:58:32 <geekosaur> Algebr, actually that's entirely valid since main :: IO a, not main :: IO ()
08:58:39 <geekosaur> it's not useful, but it's legal
08:58:52 <Algebr> geekosaur: what? Then why is main always written as main :: IO ()?
08:59:10 <monochrom> that is a personal choice
08:59:18 <monochrom> you need to read my http://www.vex.net/~trebla/IO.xhtml
08:59:19 <geekosaur> because there's rarely any point in it being anything else given that the a is always thrown away
08:59:26 <jle`> well, often times, main actually is IO ().
08:59:31 <Algebr> monochrom: link didn't work
08:59:39 <dottedmag> monochrom: 404
08:59:45 <monochrom> I see, sorry, you should have said it earlier.
08:59:49 <monochrom> you need to read my http://www.vex.net/~trebla/haskell/IO.xhtml
09:00:00 <levi> Well, if you explicitly declare main to be 'IO ()', then you must ensure that the value you give to main respects that signature.
09:00:04 <geekosaur> so 99% of the time it will be IO (), but there are obscure cases where it's useful
09:00:17 <Algebr> What about giving a return code to the OS?
09:00:28 <jle`> return code isn't a part of the language
09:00:28 <monochrom> that is done by System.Exit
09:00:33 <geekosaur> and, if you want to make sure you're not doing pointless stuff, you probably want to be explicit about IO ()
09:00:37 <jle`> it's a part of the implementation
09:00:39 <c_wraith> not every OS on which haskell might run is defined to have exit codes
09:01:43 <dottedmag> ExitCode being ExitSuccess | ExitFailure Int is not suitable for Plan 9, btw ;)
09:02:42 <geekosaur> technically it's not suitable for Unix either; there's a bit of a bobble about `ExitFailure 0` which IIRC is mentioned in the haddock
09:03:15 <monochrom> if only we had predicate subtypes
09:07:12 <carter> whats brandons handle on irc? i've never been able to figure it out
09:07:17 <dottedmag> geekosaur: At least Unix has got integer return codes, not string ones.
09:08:19 <c_wraith> I want typed return codes.  Wait, windows has that now with powershell, doesn't it?
09:08:47 <monochrom> they call it objects, not types.
09:09:03 <barrucadu> Objectified return codes
09:09:20 <monochrom> it may be a Liskov-substitutability type system
09:11:16 <geekosaur> carter: which brandon? :p
09:11:24 <carter> albernany?
09:11:26 <carter> i can't spell
09:11:32 <carter> the one who's on cafe a lot
09:11:41 <geekosaur> there's several of us in the haskell community...
09:11:59 <geekosaur> <--- allbery.b at gmail aka Brandon Allbery
09:12:05 <carter> geekosaur: oh its you!
09:12:06 <carter> :)
09:12:15 <carter> i'm bad at handle name mappings
09:13:19 <geekosaur> (and the reason I use a nonobvious mapping is there's another Allbery active in the kerberos and (until recently) openafs communities and it just caused massive confusion)
09:13:50 <carter> i get annoyed when thers annother carter ever
09:14:05 <carter> like the thead about fixing num prelude
09:14:13 <c_wraith> isn't there another active carter in haskell stuff?
09:14:18 <carter> yes
09:14:20 <carter> exactly
09:14:23 <monochrom> you have no idea how many Albert Lai's are in computer science, even formal methods :)
09:14:27 <carter> i was pissed
09:15:11 <c_wraith> monochrom: did you pick "Albert", or is it actually your given name?
09:15:48 <monochrom> it is in fact given. my elder relatives picked when I was born.
09:16:12 <Algebr> So something like Foo -> IO Bar -> String, that's a nonsensical signature, right?
09:16:26 <c_wraith> monochrom: ah.  It's not exactly common.  I will admit to being surprised that there are multiple Albert Lais in formal methods. :)
09:16:32 <geekosaur> it's not complete nonsense, but it's only likely to be useful in obscure cases
09:16:34 <monochrom> it is a sensical signature for a function that ignores the second parameter
09:51:41 <jfischoff> Is there anyway to make modifyIORef’ faster?
09:52:42 <jfischoff> I am surprised that in a second I was only able to update this ref 100 million times: timeout 1000000 $ forever $ modifyIORef' x (1+)
09:53:28 <jfischoff> where as c++ was able to do the same in 4 milliseconds
09:55:39 <glguy> c++ was able to do 1 update every 0.04 nanoseconds?
09:55:46 <glguy> an update rate of 25 gigahertz?
09:56:27 <dv-> gcc probably just replaced it with a constant
09:56:41 <jfischoff> dv-: perhaps
09:56:47 <glguy> That or C++ unlocks the fast mode of an Intel processor
09:57:02 <dv-> use -g -Wa,-adhls to see the assembler side-by-side
09:57:06 <jfischoff> or the accurancy of time isn’t that great
09:57:10 <Sculptor_> -drophammer
09:58:02 * hackagebot NTRU 1.0.0.0 - NTRU Cryptography  http://hackage.haskell.org/package/NTRU-1.0.0.0 (mikewest)
09:58:22 <jfischoff> heh, my index defaulted to Integer. Get 200 million in ghc with Int
09:58:31 <jfischoff> going to check the c++ assembly
10:01:32 <merijn> jfischoff: The accuracy of time is terrible
10:01:39 * jfischoff nods
10:02:56 <jfischoff> dv-, glguy: dv- the compiler did completely unfold the loop
10:03:02 * hackagebot diagrams-core 1.2.0.2 - Core libraries for diagrams EDSL  http://hackage.haskell.org/package/diagrams-core-1.2.0.2 (bergey)
10:06:19 <dv-> yeah it's clever like that
10:08:03 * hackagebot diagrams-lib 1.2.0.2 - Embedded domain-specific language for declarative graphics  http://hackage.haskell.org/package/diagrams-lib-1.2.0.2 (bergey)
10:08:05 * hackagebot force-layout 0.3.0.7 - Simple force-directed layout  http://hackage.haskell.org/package/force-layout-0.3.0.7 (bergey)
10:08:07 * hackagebot propellor 0.8.3 - property-based host configuration management in haskell  http://hackage.haskell.org/package/propellor-0.8.3 (JoeyHess)
10:09:36 <jfischoff> dv-: crap passing in an arg didn’t confuse the optimizer
10:10:02 <merijn> jfischoff: Good luck, benchmarking C is ridiculously hard :)
10:10:54 * jfischoff wonders clang can optimize hand written assembly
10:11:12 <allyraza> hello everybody
10:13:04 * hackagebot diagrams-contrib 1.1.2.1 - Collection of user contributions to diagrams EDSL  http://hackage.haskell.org/package/diagrams-contrib-1.1.2.1 (bergey)
10:13:40 <c_wraith> It took me 3 reads to realize bergey isn't byorgey
10:14:13 <c_wraith> Cognitive priming! "diagrams" is in the package name!
10:15:02 <jfischoff> Is there any way to get ghc to unbox the value in IORef?
10:15:29 <c_wraith> No
10:15:34 <jfischoff> I’m looking at the core for an IORef Int and it matches on I# during modification
10:15:42 <c_wraith> It's aactually really important that it's boxed
10:15:42 <jfischoff> crap
10:15:59 <jfischoff> is there anyway to get an unboxed reference?
10:16:14 <jfischoff> the equivalent of c int*?
10:16:16 <c_wraith> That's how it can use an atomic compare and exchange implementation
10:18:27 <jfischoff> I supposed I could use a Ptr but when I tested that earlier it was slower.
10:18:56 <c_wraith> using a Ptr involves more indirections, yes.  It's designed for marshaling, not direct access
10:19:50 <jfischoff> c_wraith: right, but I feel like this is common case, what have other done for unboxed mutable values?
10:20:30 <c_wraith> jfischoff: if you don't need atomicModifyIORef, there's always unboxed vectors.
10:21:05 <jfischoff> right MutableByteBuffer
10:21:07 <c_wraith> jfischoff: also, if you're just looking for a counter, there are some packages with efficient concurrent counters
10:21:20 <c_wraith> jfischoff: use case matters
10:21:29 <jfischoff> I don’t need a concurrent counter
10:21:32 <trink> best soccer tips http://tinyurl.com/p5bpscx
10:21:43 <jfischoff> I want to be able to read a double quickly
10:22:36 <jfischoff> s/MutableByteBuffer/MutableByteArray
10:23:05 * hackagebot diagrams-svg 1.1.0.1 - SVG backend for diagrams drawing EDSL.  http://hackage.haskell.org/package/diagrams-svg-1.1.0.1 (bergey)
10:23:07 * hackagebot diagrams-cairo 1.2.0.1 - Cairo backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-cairo-1.2.0.1 (bergey)
10:23:09 * hackagebot diagrams-postscript 1.1.0.1 - Postscript backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-postscript-1.1.0.1 (bergey)
10:23:11 * hackagebot diagrams-rasterific 0.1.0.1 - Rasterific backend for diagrams.  http://hackage.haskell.org/package/diagrams-rasterific-0.1.0.1 (bergey)
10:23:59 <carter> jfischoff: look at atomic-primops and also what johan does in ekg
10:24:14 <carter> theres some subtleties
10:25:01 <carter> hrmm
10:25:15 <carter> c_wraith: took me months to stop confusing them on irc
10:28:06 * hackagebot diagrams-canvas 0.2.0.1 - HTML5 canvas backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-canvas-0.2.0.1 (bergey)
10:28:08 * hackagebot diagrams-builder 0.6.0.1 - hint-based build service for the diagrams graphics EDSL.  http://hackage.haskell.org/package/diagrams-builder-0.6.0.1 (bergey)
10:28:10 * hackagebot diagrams-haddock 0.2.2.11 - Preprocessor for embedding diagrams in Haddock documentation  http://hackage.haskell.org/package/diagrams-haddock-0.2.2.11 (bergey)
10:29:19 <jfischoff> c_wraith: MutableByteArray is a promising route. I’ll profile later tonight
10:30:02 <c_wraith> jfischoff: I strongly recommend looking at atomic-primops. If it can be made to do what you want, it's probably a better choice. (I couldn't remember the name of the package)
10:30:17 <carter> and look at what EKG does
10:30:23 <carter> johan spent A LOT of time tuning it
10:30:34 <jfischoff> c_wraith: I’m familar with the package
10:30:47 <jfischoff> carter: what part of EKG are you referring to?
10:31:09 <carter> probably https://hackage.haskell.org/package/ekg-core
10:31:26 <carter> look at the internals on githbu
10:31:46 <jfischoff> carter: what line?
10:31:58 <carter> no clue
10:32:23 <carter> probably something related to the INternal module of https://hackage.haskell.org/package/ekg-core-0.1.0.1/docs/System-Metrics-Distribution.html
10:32:32 <carter> since you care about double/float
10:32:56 <jfischoff> he is just using storable AFAICT
10:33:04 <carter> not so
10:33:05 <carter> well
10:33:09 <carter> theres a bit more going on
10:33:16 <carter> but look at how he does it
10:33:22 <jfischoff> does what?
10:33:31 <carter> the reading /writing to memory
10:33:35 <carter> for making it fast
10:33:37 <jfischoff> withForeignPtr
10:34:00 <jfischoff> I don’t see what you are referring to, why don’t you point to it
10:34:01 <carter> Cbits
10:34:30 <carter> https://github.com/tibbe/ekg-core/tree/master/cbits and  https://github.com/tibbe/ekg-core/blob/master/System/Metrics/Distribution.hsc probably
10:34:33 <carter> if you want floats
10:34:43 <carter> his stuff is also atomic
10:34:47 <carter> so thread safe
10:35:11 <jfischoff> I don’t see how this codes relates to my question
10:36:19 <athan> How difficult are linking errors to resolve? I've got a few "undefined references". Maybe delete the sandbox and try again?
10:36:48 <bernalex> athan: that's what I did the only time it happened to me
10:37:46 <zmbmartin> Is there anyone here that uses scotty and can help me. I am not understanding jsonData
10:37:48 <athan> bernalex: *prays to the lambda gods*
10:38:02 <bernalex> athan: the Church of Lambda :-]
10:38:29 <bernalex> zmbmartin: I use scotty but not jsonData =/
10:39:11 <bergmark> zmbmartin: what don't you understand about it?
10:40:18 <zmbmartin> bernalex: I can't figure it out period. I just keep getting a 500 no parse error.
10:40:29 <athan> lol
10:40:29 <athan> dmj` could get into this, I think
10:40:40 <bergmark> zmbmartin: are you sure you are passing valid json to it?
10:40:55 <bernalex> yeah try testing it in GHCI
10:41:01 <bernalex> ToJSON is yr friend
10:41:02 <bergmark> aeson only allows arrays and objects on the top level by default, for instance
10:42:09 <c_wraith> bergmark: that is correct behavior.  Technically, that's all the JSON format allows at the top level.  But it sometimes surprising, yeah.
10:42:11 <zmbmartin> bergmark: I thought so but I guess it is off.
10:42:26 <bergmark> c_wraith: there are different standards afaik
10:42:53 <bergmark> c_wraith: https://github.com/bos/aeson/issues/194#issuecomment-44139706
10:43:18 <Guest79274> I am very curious about Haskell, may I know for what it is used ? (in general)
10:43:42 <c_wraith> Guest79274: writing software
10:44:05 <c_wraith> Guest79274: well, and research into compilers. :)
10:44:20 <bernalex> and writing programming languages
10:45:01 <jfischoff> Guest79274: I write web services with Haskell
10:45:02 <bernalex> sometimes we just look at it and feel tears stream down our faces, only to meet their redeemer and be wiped away; and there is joy.
10:45:29 <zmbmartin> bergmark: Could you provide me with a simple example based on jsonData?
10:47:13 <Guest79274> ok thanks guys. How would you compare Haskell to other language ? For example, may I know other similar languages ?
10:47:40 <bergmark> zmbmartin: no, i have never used scotty. but jsonData juts calls aeson's decode so my guess would be that the FromJSON instance doesn't match the json you are passing to it, or that the json is invalid
10:47:42 <c_wraith> I'm not sure there's anything that's really similar to haskell.  The feature set is kind of unique.
10:48:02 <c_wraith> There are other languages with immutable-by-default data, but that lack purity.
10:48:17 <merijn> @quote Jafet research.language
10:48:17 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatics, phone apps, and web services.
10:48:36 <athan> crud, still getting an "undefined reference" error at the linking stage. Any ideas for diagnosis?
10:48:46 <carter> athan: you forgot to list a module in your cabal file
10:48:48 <c_wraith> I mean the ML family is similar in the type system, but lacks purity
10:48:59 <athan> carter: ! Thank you!!!
10:49:13 <carter> athan: found the missing modules?
10:49:35 <carter> athan: its tricky to give good error reports for linker things
10:49:38 <athan> carter: Yeah I know exactly which one :) Do I just expose it?
10:49:47 <c_wraith> athan: or include it in other-modules.  either way
10:49:49 <Guest79274> ok thx for the info
10:49:51 <carter> it could be in your other-modules: stanza
10:49:59 <c_wraith> athan: depending on whether you need to import it
10:50:02 <athan> carter: I could only imagine. c_wraith: Awesome!!!
10:50:10 <athan> yeah I just need to import it
10:50:33 <c_wraith> If it needs to be imported in client code, then it needs to be exposed.
10:51:08 <athan> erm, sorry. I only need to utilize it in the package that's throwing the error
10:51:16 <carter> other-modulees
10:51:17 <athan> so other-modules seems to be the best fit
10:51:21 <athan> yep
10:51:25 <athan> sorry! Thank you!!!
10:51:36 <bernalex> Guest79274: most similar languages might be clean, miranda, hope, iswim & in some respects ML. but it's hard to compare them too much to haskell.
10:51:41 * dottedmag wonders if there a ready-made parser for Bind 9 zone files (searching for 'bind' or 'named' in Hackage is hopeless)
10:51:53 <zmbmartin> bergmark: ok thanks!
10:51:55 <carter> dottedmag: you want DNS stuff
10:51:58 <carter> @hackag dns
10:51:58 <lambdabot> http://hackage.haskell.org/package/dns
10:52:16 <bernalex> Guest79274: you'll recognise quite a few features from other languages. c#, python & scala are just a few languages that have many things that are inspired by haskell.
10:52:22 <dottedmag> carter: Nope, I want a parser for bind zone file, to update it.
10:52:23 <carter> dottedmag: idk if DNS is the right package
10:52:28 <dottedmag> carter: Thanks anyway
10:53:14 <carter> dottedmag: probably easy to write a parser combinator parser
10:53:31 <carter> idk
10:53:32 <carter> gluck
10:53:33 <c_wraith> athan: you would run into a similar issue if you uploaded the package to hackage. cabal sdist requires that every module used be in either exposed-modules or other-modules.  The thing is, you don't exactly need to keep those sections up-to-date in local development, so it's easy to forget about them.  Sandboxes kind of improve things there.
10:53:35 <dottedmag> carter: Right, at least for subset I care about.
10:55:13 <alorente> When GHC raises an import error, it says "Use -v to see a list of the files searched for." How do I tell cabal to pass -v to GHC?
10:56:14 <merijn> alorente: GHC-options
10:56:59 <alorente> merijn: Can you elaborate
10:57:35 <athan> c_wraith: Very good to know, thanks for the tip!
10:58:18 <monochrom> I don't think that will tell you anything you don't already know. if you're using cabal, your *.cabal file already has complete control over the files searched for, via dependencies and src-dir
10:59:35 <alorente> monochrom: that is condescending and unhelpful
10:59:56 <joelteon> no it isn't
11:00:15 <joelteon> alorente: ghc-options: -v
11:00:35 <alorente> joelteon: where do I put that?
11:00:43 <joelteon> in your cabal file
11:00:48 <alorente> oh!
11:01:07 <k00mi> --ghc-options=-v also works
11:02:44 <alorente> oh look at that, it told me what I was trying to find out, almost as if I was asking that question because it was what I wanted to know, and didn't need someone who didn't know what problem I had to talk down to me
11:04:15 <joelteon> but only almost :)
11:04:59 <joelteon> alorente, it will probably be helpful to change your mentality if you plan to stay here and continue getting help
11:05:40 <k00mi> alorente: monochrom wasn't talking down to you, he was just saying that in his experience, -v will not help you solve your problem
11:05:44 <meiji11> if ghc is unable to load a package, is there some deeper description of what the problem is, stored somewhere?
11:05:53 <joelteon> define unable to load
11:05:54 <k00mi> unhelpful, in this case yes, condescending, no
11:07:08 <meiji11> joeltoen: I try to define a value in ghci after successfully compiling my program, it says "Loading package unix-time-0.3.3.... linking... ghc.exe: unable to load package `unix-time-0.3.3'"
11:08:46 <Guest39013> I have a "data Direction = N | E | S | W deriving (Enum, Bounded)" I want make it circular, does it make sense to create a class Circulable?
11:08:51 <joelteon> oh, this is a windows problem...I cannot help
11:09:39 <c_wraith> Guest39013: probably not.
11:10:26 <bergmark> Guest39013: a function should suffice
11:11:10 <c_wraith> Data.List.cycle might suffice
11:11:52 <Guest39013> great, will have a look at it
11:12:17 <meiji11> it appears to be a windows problem, yes, but I've otherwise compiled / configured it with cygwin
11:12:26 <meiji11> which I would hope isolates it from windows problems. probably not though.
11:12:35 <Guest39013> wondering that when will I encounter that magic moment when I need to create a class in Haskell :)
11:13:57 <k00mi> in about two years of haskell development, I never had the need to create a new class
11:14:21 <k00mi> oh, I do use classy lenses, if that counts
11:14:23 <bergmark> i avoid it as much as possible, but when you have recursive types involved you pretty much have to
11:15:11 <athan> Is there a way to delete the package database, just so I can use sandboxes only?
11:15:51 <c_wraith> athan: I guess you chould chmod 444 .ghc
11:16:23 <monochrom> all sandbox solutions already ignore the --user database altogether
11:17:26 <c_wraith> monochrom: cabal sandbox only does if there's a cabal file present. Otherwise, it goes into a weir hybrid mode
11:17:34 <c_wraith> *weird
11:17:41 <meiji11> more generally, though, if ghc is "unable to load" a package in the above sense, is there some way to get at the deeper cause of the problem?
11:18:38 <athan> Ahh, i figured it out. I accidentally copied the sandbox file from another machine
11:18:41 <monochrom> the --user database is somewhere under ~/.ghc on linux. use ls to find out what's there, you'll see.
11:19:30 <athan> hmm, alright, I'll have to dissect a bit for good measure. Thanks monochrom, meiji11, c_wraith
11:20:18 <Natch> does anyone know how I can force a dependency to run autoreconf before compiling if I'm installing something in a cabal sandbox?
11:26:22 <Algebr> I think I just understood how haskell handles state just a bit better, its so clever, its not really state, just something else that we can act like is state.
11:29:03 <zebr> hi all. i was wondering if anyone could help me fix a compilation error. i have a MultiParamTypeClasses and ScopedTypeVariables on, and i have the code "machine4 :: forall a b c. Fabric a b c => Config a b c -> Maybe (Config a b c); machine4 = ... (body :: a -> a) ..." but the compiler doesn't understand that 'body' is meant to be the instance for Fabric a b c - it says Fabric a b4 c3 where b4 and c3 are ambiguous.
11:29:15 <zebr> error message - http://sprunge.us/UhLM
11:29:35 <zebr> i just don't know what i could do to tell the compiler what instance 'body' is meant to belong to
11:30:49 <monochrom> Algebr: I don't think that's right. If you're referring to IO, then there is really state. If you're referring to StateT, then it is not so much Haskell as a user-defined type, which is also writable in other languages.
11:31:01 <RyanGlScott> zebr: the body function only resolves the type of a in Fabric a b c. Hence, b and c are ambiguous.
11:31:26 <zebr> RyanGlScott: yeah - i don't know how i can force their resolution. is there a way?
11:31:37 <bernalex> monochrom: semantics semantics semantics but I'd say that haskell has state, logically. it just doesn't achieve it the same way computationally like C++ does with assignment & side-effects. :-]
11:31:51 <zebr> i tried e.g. body :: Fabric a b c => a -> a, but ofc that doesn't work
11:32:02 <monochrom> I agree
11:32:21 <RyanGlScott> zebr: One way to get around this is using functional dependencies, e.g., class Fabric a b c | a -> b c
11:32:43 <RyanGlScott> zebr: That means that the "a" in a Fabric uniquely determines the b and c
11:32:50 <bernalex> monochrom: which means I'll try to avoid saying "state" when talking to anyone coming from the C++-world, because it just confuses them. :-]
11:32:52 <Algebr> monochrom: I was refering to like passing around a Map in a recursive loop, just always with an updated Map.
11:34:36 <RyanGlScott> How would one convert a Windows-style path to a POSIX-style one? e.g., "C:\\Users\\mingw" to "C/Users/mingw"
11:36:42 <monochrom> that is not specific to Haskell. I do it all the time in other languages too.
11:37:35 <bernalex> yeah that's just FP really
11:37:53 <bernalex> but, sure, you can look at it like state
11:38:22 <monochrom> a statement of the form "the way Haskell handles ___" had better be highly specific to Haskell, preferrably defined by the language standard. as opposed to a programmer's choice
11:38:55 <zebr> RyanGlScott: it seems to compile if i use functional dependencies to make all the type variables dependent on each other. which is weird, but there we are. thanks. :)
11:38:57 <bernalex> relax, they might not be experienced programmers at all :-]
11:39:16 <RyanGlScott> zebr: Right, that's the whole point of functional dependencies.
11:39:23 <bartavelle> is it possible to do a heap dump and see what's in the heap ? I have a memory leak issue that is driving me crazy, profiling says it's from ":", but I don't see any large list in my code
11:40:59 <sruz25> Looking for a structure that could concatenate in O(1), but couldn't find anything better than sequence. Any idea if there's something better? btw I want it for a queue in which I do either "current element to 'done' part of queue, rest to todo" or "current element to 'done' part, rest stays the same"
11:41:54 <bartavelle> sruz25, there are difference lists
11:42:11 <sruz25> will look into it, thanks
11:42:45 <bartavelle> not sure if it'll fit your use case better than sequence however
11:52:35 <RyanGlScott> > encodeString posix . decodeString windows $ "C:\\Users\mingw"
11:52:37 <lambdabot>  <hint>:1:56:
11:52:37 <lambdabot>      lexical error in string/character literal at character 'm'
11:52:43 <RyanGlScott> > encodeString posix . decodeString windows $ "C:\\Users\\mingw"
11:52:45 <lambdabot>  Not in scope: ‘encodeString’Not in scope: ‘posix’Not in scope: ‘decodeString...
11:53:33 <RyanGlScott> > import Filesystem.Path.Rules
11:53:35 <lambdabot>  <hint>:1:1: parse error on input ‘import’
12:07:26 <dreams> Any hpc users here?
12:11:59 <jfischoff> c_wraith: MutableByteArray is about 2.5 times faster then IORef in my little test
12:12:12 <jfischoff> c_wraith: thanks
12:12:19 <tekul> dreams: I use it with cabal... what's up?
12:12:23 <c_wraith> jfischoff: is it correct in the face of concurrent updates?
12:12:44 <jfischoff> c_wraith: not important for my purposes
12:12:49 <jfischoff> no idea
12:13:12 <c_wraith> jfischoff: well, it's sort of important.  You probably don't want two half-writes.
12:13:40 <jfischoff> c_wraith: I only have one thread writing to it
12:13:57 <dreams> tekul: I find it a bit weird. So what are you using it for? to find which expressions were used in the program?
12:14:14 <c_wraith> jfischoff: Well, ok, reading a partially-written value is still potentially problematic.
12:14:14 <tekul> dreams: I just use it when testing
12:14:26 <tekul> So for test coverage
12:14:53 <dreams> tekul: so to test which parts were used in your program?
12:15:07 <dreams> I know its called coverage but the idea is not landing.
12:15:12 <jfischoff> c_wraith: true. If it is do a word size mov I should be okay. I’ll need dig deeper to see
12:15:25 <tekul> To check what parts were covered by my test suite, but effectvely yes I guess
12:15:54 <c_wraith> jfischoff: anyway, if you never see a partially-written value, you should be good.
12:16:08 <dreams> tekul: so in other words, which expressions were tested after testing your program?
12:16:54 <tekul> dreams: 'cabal test' outputs a coverage report if you have configured it with --enable-library-coverage
12:17:46 <Peaker> it's funny how Maybe/Either lend themselves to puns.  There's Just-vs-Unjust (for good/bad results). The Maybe Monad is determined, it will stop at Nothing.   Either you're Right, or you're wrong (good/bad results).   Left used when you want to have left the computation in a monad
12:17:49 <dreams> tekul: ok, I keep repeating a question and you keep talking about something different. Nevermind, thanks.
12:17:56 <jgt> how can I filter a string with two conditions?
12:18:13 <jgt> I have "$2,345,678.99"
12:18:26 <Peaker> jgt: filter (\str -> cond1 str && cond2 str)      OR:    filter cond1 . filter cond2
12:18:27 <jgt> which I’d like to have as 2345678.99
12:18:38 <dreams> The GHCi debugger uses hbc the concept, so I wanted to know how it works.
12:18:54 <dreams> s/hbc/hpc/
12:19:12 <tekul> Dunno about that, sorry.
12:19:21 <dreams> tekul: no worries mate.
12:19:30 <tekul> But the report does show which expressions have been evaluated.
12:20:55 <glassresistor> im so close to not having to use if in this bash command but i don't think i can
12:21:26 <dreams> tekul: yup.
12:21:38 <glassresistor> gnome-terminal -e 'screen -D -R -S chat bash -c "irssi"'
12:23:46 <jgt> filter (\str -> Data.Char.isNumber str || =='.' str)
12:23:52 <jgt> this isn’t working
12:24:51 <zwer> :t isNumber
12:24:52 <Iceland_jack> jgt: You probably want to fix "=='.'"
12:24:52 <lambdabot> Char -> Bool
12:25:08 <zwer> you seem to be passing it a string
12:25:38 <Iceland_jack> zwer: that's not the issue
12:25:39 <jgt> hmm
12:25:45 <jgt> I’ll try to explain more clearly
12:25:49 <Iceland_jack> but 'str' is a misnomer :)
12:25:56 <jgt> I have a string like "$1,234.99"
12:26:12 <jgt> I can do filter (=='.') "$1,234.99"
12:26:18 <jgt> and I get the dot
12:26:19 <merijn> The problem is that "=='.'" makes no sense
12:26:27 <Iceland_jack> jgt: Yes, you can't write (== '.') without the parentheses
12:26:42 <jgt> or I can do filter Data.Char.isNumber "$1,234.99"
12:26:47 <jgt> and I get 123499
12:26:50 <Iceland_jack> In this case you don't want an operator section (== '.') at all
12:26:52 <merijn> :t (=='.')
12:26:53 <jgt> I’d like to combine the two
12:26:53 <lambdabot> Char -> Bool
12:27:06 <merijn> :t \str -> =='.' str
12:27:07 <lambdabot> parse error on input ‘==’
12:27:14 <merijn> :t \str -> (=='.') str
12:27:15 <lambdabot> Char -> Bool
12:27:18 <Iceland_jack> jgt: Read up :)
12:27:20 <merijn> :t \str -> '.' == str
12:27:22 <lambdabot> Char -> Bool
12:27:39 <jgt> Iceland_jack: on what, exactly?
12:27:48 <merijn> jgt: The past 10 lines of IRC
12:28:01 <Iceland_jack> > 'a' == '.'
12:28:03 <lambdabot>  False
12:28:07 <Iceland_jack> That works
12:28:26 * hackagebot hsimport 0.5.1 - A command line program for extending the import list of a Haskell source file.  http://hackage.haskell.org/package/hsimport-0.5.1 (DanielTrstenjak)
12:28:39 <jgt> filter (\str -> Data.Char.isNumber str || (=='.') str)
12:28:53 <jgt> doesn’t work in ghci
12:29:00 <Iceland_jack> jgt: You don't want to use an operator section, (== '.') is an operator section
12:29:15 <Iceland_jack> You want to use "'.' == str" instead
12:29:27 <Iceland_jack> and maybe change 'str' to 'char' while you're at it :)
12:30:19 <jgt> ouldn't match expected type `Bool' with actual type `[Char]'
12:30:33 <jgt> s/ouldn’t/couldn’t/
12:30:47 <jgt> filter (\str -> Data.Char.isNumber str || "'.' == str")
12:30:52 <merijn> > filter (\c -> Data.Char.isNumber c || '.' == c) "$1,234.99"
12:30:54 <lambdabot>  "1234.99"
12:31:22 <Iceland_jack> jgt: I should have made it clear the " was not a part of the code
12:31:29 <jgt> ah
12:31:38 <Iceland_jack> It's hard to mix natural language and code, I was quoting the code
12:31:57 <jgt> Iceland_jack: I thought it was convention to use `backticks` to denote code
12:32:05 <jgt> merijn: Thanks for that
12:32:16 <Iceland_jack> jgt: I usually use ‘this’ but some people complain about unicode
12:32:37 <Iceland_jack> also `backticks` is also valid Haskell for infix names :)
12:32:41 <monochrom> I use " to quote code most of the time. then there are 0.5% of the time I use (), and 0.5% of the time I use «»
12:32:43 <Iceland_jack> > 3 `take` "hello"
12:32:45 <lambdabot>  "hel"
12:33:25 <Iceland_jack> I should just start using “”, ‘’ or ()
12:33:26 * hackagebot yaml-light-lens 0.3.1.3 - Lens interface to yaml-light.  http://hackage.haskell.org/package/yaml-light-lens-0.3.1.3 (AnthonyCowley)
12:33:40 <monochrom> actually do you like «» more or do you like “” more? :)
12:34:22 <monochrom> if only we accepted HTML in IRC. <code>f x = x ++ "hello"</code>
12:34:46 <Iceland_jack> I prefer “” but my best preference is indentation
12:34:46 <Iceland_jack>     '.' == char
12:35:03 <monochrom> I want to avoid using multiple lines
12:35:52 <Iceland_jack> I try to keep the number of lines to a minimum, but when showing reduction steps it's invaluable
12:36:31 <monochrom> if only we accepted HTML in IRC. <pre>... :)
12:37:09 <jgt> read (filter (\c -> Data.Char.isNumber c || '.' == c) "$1,234.99") :: Float
12:37:14 <jgt> hooray it works
12:37:22 <Iceland_jack> And then if people could use webbrowsers as a client, wait...
12:37:43 <Iceland_jack> jgt: Now can you think of cases where it fails?
12:38:08 <jgt> Iceland_jack: some countries use a different currency format
12:38:20 <jgt> i.e., they switch commas and dots
12:38:22 <ion> Using Float for currency is a bad idea.
12:38:41 <hiptobecubic> Iceland_jack, a lof of them actually. Most of europe i think
12:38:49 <Iceland_jack> ion is right but I have a feeling this is for practice
12:38:49 <Iceland_jack>  
12:38:56 <jgt> this is indeed for practice
12:39:04 <jgt> I’m completely new to Haskell
12:39:12 <Iceland_jack> Welcome
12:39:15 <jgt> grazie
12:39:36 <hiptobecubic> jgt, there is also #haskell-beginners
12:39:37 <Iceland_jack> jgt: What if the input isn't valid currency? What if it is the empty string? What if it consists only of periods? ...
12:39:55 <Iceland_jack> And other annoying questions
12:40:08 <monochrom> use readMaybe in Text.Read :)
12:40:22 <jgt> I use some pattern match to tell the user to stop trying to break my naïve function
12:40:37 <Iceland_jack> Blaming the user, I like it
12:40:41 <jgt> and then push to production
12:40:49 <hiptobecubic> jgt, on a friday afternoon
12:40:55 <hiptobecubic> Then off to the bar!
12:40:55 <jgt> #yolo
12:40:57 <hiptobecubic> :D
12:41:25 <Iceland_jack>     “All my balances say 'Error: #yolo'”
12:42:10 <monochrom> at least it's consistent with spreadsheets filling your cells with "Error: #N/A"
12:42:19 <hiptobecubic> Iceland_jack, a recent app i worked on just redirected people to https://www.youtube.com/watch?v=ygr5AHufBN4 on errors
12:43:00 <Iceland_jack> haha
12:50:36 <bartavelle> can the profiler be completely wrong when it assigns memory allocation to a function ?
12:50:52 <Fuuzetsu> seems unlikely
12:51:03 <bartavelle> this is crazy then
12:51:22 <Fuuzetsu> you'll probably have to read the Core
12:51:55 <bartavelle> I never was good at this, but the function seems to not allocation _anything_
12:52:01 <bartavelle> allocate
12:52:24 <Fuuzetsu> you should be jumping up and down at how great GHC is ;P
12:52:35 <bartavelle> haha
12:53:16 <Fuuzetsu> reminds me of a Tweet from a Japanese user. To paraphrase: GHC 7.6 - 1.2 sec, GHC 7.8 - 0.8 sec, GHC 7.20 - 0 sec
12:53:29 * hackagebot cabal-uninstall 0.1.6 - Uninstall cabal packages  http://hackage.haskell.org/package/cabal-uninstall-0.1.6 (JanChristiansen)
12:54:12 <bartavelle> in the meantime, if somebody has a clue, the function is crazy simple http://lpaste.net/109821
12:54:21 <bartavelle> this is an attoparsec parser
12:54:41 <bartavelle> it claims it allocates 40% of the memory, the whole parser parses some sort of "find -ls" output
12:55:03 <bartavelle> I would expect it to allocate a constant amount of memory as it only returns constructors without parameters
12:55:05 <monochrom> perhaps it uses O(1) memory
12:55:37 <bartavelle> monochrom, well, it seems linear with the number of lines parsed
12:55:38 <Fuuzetsu> I can't say why but I can say that's not how I'd define that
12:55:43 <monochrom> I see
12:55:54 <dolio> That doesn't seem surprising.
12:55:57 <bartavelle> monochrom, didn't really verify it though
12:56:11 <Fuuzetsu> I'd just do char '-' *> pure TFile <|> char 'f' *> pure TFile …
12:56:16 <bartavelle> I would be happy to not be surprised
12:56:28 <bartavelle> humm
12:56:33 <dolio> If it's doing allocation, the amount of allocation it does is linear in how much you call it.
12:56:41 <dolio> At least.
12:56:55 <dreams> Is there a ghc-dev channel?
12:57:03 <Iceland_jack> there's #ghc
12:57:08 <bartavelle> well, yes, I just don't realize why it's allocating at all
12:57:12 <bartavelle> Fuuzetsu, will try your version
12:57:37 <dreams> Iceland_jack: thanks.
12:58:02 <dolio> Almost everything in a Haskell program is going to allocate memory.
12:58:10 <Fuuzetsu> Almost?
12:58:15 <dolio> Yes, almost.
12:58:29 * hackagebot random 1.0.1.3 - random number library  http://hackage.haskell.org/package/random-1.0.1.3 (RyanNewton)
12:58:31 * hackagebot GLUtil 0.8.1 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.8.1 (AnthonyCowley)
12:58:37 <Fuuzetsu> What are the things that won't allocate memory, bar for the staff spirited away at compile time
12:58:43 <Fuuzetsu> stuff*
12:58:45 <bartavelle> dolio, in this case, all the constructors are shared AFAIK
12:58:59 <dolio> Stuff that works with unboxed values.
12:59:07 <dolio> bartavelle: That's reading a character.
12:59:07 <bartavelle> constructors with no arguments should allocate O(1) memory
12:59:15 <bartavelle> yeah
12:59:49 <bartavelle> but why is *this* taking 40% of allocation, whereas a "takeWhile (...)" that parses the user name, and another that parses the group name, take 6% ?
13:00:00 <bartavelle> they are reading way more characters
13:00:30 <dolio> Also, are you using optimizations when running profiling?
13:00:36 <dolio> Because that can make weird things happen.
13:01:00 <bartavelle> yes I am
13:01:15 <bartavelle> I suppose that the line is misleading
13:01:32 <dolio> Like, perhaps anyChar is getting inlined, so allocation it does is getting attributed to your function there.
13:01:36 <bartavelle> will drop optimizations, great idea
13:01:47 <dolio> Where as some other thing you're doing doesn't make that happen.
13:03:01 <dolio> Or it might be even weirder than that.
13:03:16 <dolio> What parser are you using, by the way?
13:03:30 <dolio> Another funny thing that can happen is with continuation passing.
13:03:38 <monochrom> attoparsec
13:04:16 <dolio> When you use continuations, the cost of any one thing is the cost of its entire continuation.
13:04:33 <Fuuzetsu> any time I look at fast code, there's inlining and unboxing everywhere
13:04:36 <dolio> So if this thing goes first, it will be assigned the cost of the entire parsing operation.
13:04:39 <Fuuzetsu> --inline-everything when?
13:04:48 <bartavelle> ah well, without optimizations, this gets interesting
13:05:17 <bartavelle> this is the unix user parsing that uses all the space now, which seems to be logical
13:05:36 <bartavelle> thanks for the great hint !
13:05:51 <dolio> Yeah. You basically can't trust anything you see when doing profiling with optimizations, I think.
13:06:12 <k00mi> dolio: so there is no reliable way to profile with optimizations?
13:06:38 <dolio> Maybe it'll get better in 7.10.
13:07:09 <dolio> They're adding DWARF stuff which should be able to do sample based profiling on optimized code, I guess.
13:08:04 <eacameron> how do I install a lib with profiling?
13:08:04 <dolio> Maybe there's a way to do it now that I don't know about.
13:08:18 <joshc> bartavelle: if you're worried about speed, if possible you could side-step parsing altogether by using the 'directory' library
13:08:19 <k00mi> ok
13:08:20 <eacameron> I tried --enable-library-profiling  but it says the lib is already installed
13:08:56 <dolio> eacameron: You probably have to reinstall.
13:09:05 <dolio> cabal won't reinstall by default.
13:09:12 <dolio> I think.
13:09:24 <bartavelle> joshc, I run post-analyzis on collectd "find -ls" output
13:09:40 <bartavelle> not on the system the program is running on
13:09:44 <joshc> ah, so perhaps that not an option for you :).  figured it was worth a suggestion
13:09:51 <bartavelle> it was
13:10:39 <monochrom> eacameron: you have to reinstall or unregister-then-install. see my http://www.vex.net/~trebla/haskell/cabal-cabal.xhtml#config
13:13:42 <eacameron> monochrom: thank you! I'll change those defaults
13:20:04 <NinjaBanjo> hello #haskell.
13:20:14 <dmj`> yo
13:23:33 * hackagebot orchestrate 0.2.0.0 - An API client for http://orchestrate.io/.  http://hackage.haskell.org/package/orchestrate-0.2.0.0 (EricRochester)
13:28:49 <eacameron> monochrom: I'm hoping that linking without -prof removes ALL profiling cruft from my binaries?
13:29:29 <eacameron> monochrom: *perhaps "building without -prof" would be a better way to say it
13:29:51 <monochrom> yes. does not even use the library files containing profiling
13:30:35 <monochrom> each library is built 3 times. with nothing; with profiling; with dynamic linking.
13:30:35 <mroman> Is there some high-level network transport library?
13:31:04 <mroman> i.e. message passing style
13:31:46 <monochrom> so you have 3 library files per library. if you build an executable and ask for no profiling, the 1st library file is used, it has nothing.
13:33:34 * hackagebot wai-extra 3.0.2.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-3.0.2.1 (GregWeber)
13:35:03 <llefri> Hi. I am new at haskell... I was doing the manual "Learn you a haskell", and I created two files... one that sums an "x" number and another that calculates the square of 3 numbers. Now I want to use those two functions in the same console, but it throws me an error. can somebody help me, please? Thank you.
13:35:39 <dsffff> is it possible to derive an instance for GADT?
13:35:46 <glguy> llefri: Paste your errors to lpaste.net
13:35:53 <dsffff> or should I use standalone deriving?
13:35:59 <c_wraith> dsffff: depends on the class
13:36:03 <dsffff> Show
13:36:10 <c_wraith> dsffff: should work
13:36:30 <mroman> hm. I could use happstack + acid-state I guess
13:36:52 <dsffff> c_wraith: I'm getting Constructor [...] must have a Haskell-98 type.  Possible fix: use a standalone deriving declaration instead.
13:37:05 <c_wraith> dsffff: oh.  Ick.  Yeah, use standalone deriving then.
13:37:15 <dsffff> okay, thank you anyway.
13:37:44 <c_wraith> drat.  I'm not sure he knew that's an extension, and was going to make sure, then he left. :(
13:38:00 <k00mi> mroman: there is cloud haskell (distributed-process on hackage), but it's still rather experimental
13:38:08 <llefri> there it is:  http://lpaste.net/109823
13:38:43 <mroman> is it overkill to use happstack for RESTful stuff :D?
13:38:45 <glguy> llefri: doubleMe doesn't take 2 arguments
13:38:50 <monochrom> "doubleMe 3 4" has too many parameters.
13:39:00 <felixn> https://gist.github.com/munro/16faff2cedef2fa4ac37 <-- fun expirement ... integer addition without built in functions
13:39:22 <llefri> oh...
13:39:57 <llefri> what a fool... sorry, I'm new at this :/ thank you guys!
13:40:20 <monochrom> felixn: multiplication is even more fun, and division the holy grail
13:41:17 <llefri> and other thing... If I want to use those two functions, they have to be written in the same file? Can't they be in two separate files (i.e. squareus.hs and doubleme.hs) and use both of them?
13:41:58 <monochrom> they have be in two files. then you have you load both.
13:42:11 <monochrom> s/have be/can be/
13:42:26 <k00mi> felixn: you can have another constructor Twice for better performance
13:42:48 <llefri> let me try...
13:43:06 <felixn> k00mi: how do you mean?
13:44:50 <llefri> look at what happens: http://lpaste.net/109823
13:44:54 <felixn> lol I like the idea of everything being bootstrapped in haskell
13:45:04 <monochrom> it is most convenient to stick to single file for now. loading two files into ghci requires advanced knowledge of both haskell and ghci.
13:45:42 <monochrom> exactly. the :load command forgets previous loadings, by definition
13:45:53 <glguy> You can do:   :load doubleme.hs squareme.hs
13:46:17 <glguy> on a single line. afterward you will have to bring the second module into scope:   import SquareMe
13:46:18 <glguy> for example
13:46:44 <llefri> let's try...
13:48:12 <llefri> look... http://lpaste.net/109823
13:54:00 <c_wraith> llefri: All haskell files are modules. If you don't specify a module name, the name is assumed to be Main
13:54:42 <c_wraith> llefri: Since neither file contains a module name, *both* are assumed to be named Main, and you have a namespace collision.
13:58:18 <athan> Anyone up for a "wtf is going on?" challenge?
13:58:52 <eacameron> monochrom: perfect
13:59:50 <jfischoff> athan: I can look at it for a few minutes
14:01:53 <athan> jfischoff: I'm getting inconsistent results when using a sandboxed module that's been added with `cabal sandbox add-source`, compared to one that's just included as a file. It's Yesod... so it's got some hairy code, but it's still really weird. Here's my SO question: http://stackoverflow.com/questions/25431114/yesod-sanitizing-quotation-marks-in-javascript-julius?noredirect=1#comment39691388_25431114
14:13:39 * hackagebot spice 0.3.2.4 - An FRP-based game engine written in Haskell.  http://hackage.haskell.org/package/spice-0.3.2.4 (Crockeo)
14:14:11 <jgt> more practice…
14:14:22 <jgt> I wrote some ugly nested thing
14:14:37 <jgt> and I’m not sure how to simplify it with function composition
14:14:42 <jgt> keep getting type errors
14:14:46 <jgt> here’s what I have
14:14:48 <jgt>   everyEighth z = z:(everyEighth (last (take 2 (everyThird (last (take 2 (everyFifth z)))))))
14:15:31 <jgt> the two functions referenced look like   everyThird x = x:(everyThird (x + 3))
14:15:40 <vanila> everyEighth z = z:(everyEighth . last . take 2 . everyThird . last . take 2 . everyFifth $ z)
14:15:44 <jgt> everyFifth is essentially the same
14:15:50 <Fuuzetsu> @pl everyEighth z = z:(everyEighth (last (take 2 (everyThird (last (take 2
14:15:50 <Fuuzetsu>       (everyFifth z)))))))
14:15:50 <lambdabot> (line 1, column 16):
14:15:51 <lambdabot> unexpected " "
14:15:51 <lambdabot> expecting operator
14:15:53 <Fuuzetsu> @pl everyEighth z = z:(everyEighth (last (take 2 (everyThird (last (take 2 (everyFifth z)))))))
14:15:54 <lambdabot> everyEighth = fix (ap (:) . (. (last . take 2 . everyThird . last . take 2 . everyFifth)))
14:15:57 <glguy> last (take 2 xs)    is    xs!!2
14:16:31 <Fuuzetsu> I'd probably just write that as two clauses and drop
14:16:43 <athan> jfischoff: No luck, huh :(
14:17:11 <jgt> Fuuzetsu: I’d write it as everyEighth z = z:(everyEighth (z + 8))
14:17:21 <jgt> but, you know, exercises in books and stuff
14:17:22 <jfischoff> athan: I would need your setup, and I know nothing about the libraries (except of Yesod)
14:17:50 <athan> I think Yesod apps are so difficult to debug because there isn't (at least to my knowledge) a dummy server for manual requests -> responses
14:18:36 <glguy> > let everyEighth = map head . takeWhile (not . null) . iterate (drop 8) in everyEighth [2..]
14:18:38 <lambdabot>  [2,10,18,26,34,42,50,58,66,74,82,90,98,106,114,122,130,138,146,154,162,170,1...
14:18:50 <athan> jfischoff: Oh! On the last comment, I included a couple github repos - the GSAP one is just the javascript I'm trying to include, nothing more than a QQ wrapper around the JS. The other is just a slightly edited vanilla yesod init
14:19:04 <Fuuzetsu> oh, apparently I misunderstood what everyEigth was meant to be doing
14:19:17 <Fuuzetsu> > [2, 10 .. ]
14:19:19 <lambdabot>  [2,10,18,26,34,42,50,58,66,74,82,90,98,106,114,122,130,138,146,154,162,170,1...
14:19:32 <athan> jfischoff: There's no need to really know anything about the JavaScript, though
14:20:21 <vyorkin> quit
14:20:56 <vanila> https://www.janestreet.com/puzzles/current-puzzle/
14:21:01 <vanila> does anyone know how to solve this?
14:21:34 <Fuuzetsu> sounds like something Prolog would be good at
14:21:51 <Fuuzetsu> if you have a few days to run it that is
14:22:12 <vanila> yeah, I had a go in prolog with clpfd constraint solver but when I add a lot of rules it goes too slowly
14:22:31 <vanila> I wish I knew what i need to learn to solve this
14:22:39 <levi> Yeah, looks like a job for constraint logic programming.
14:22:52 <jgt> glguy: Couldn’t quite work out the !!2 thing
14:22:58 <jgt>   everyEighth z = z:(everyEighth . everyThird!!2 . everyFifth!!2 $ z)
14:23:17 <Fuuzetsu> (!!) is just a list index
14:23:17 <glguy> You'd have to write   f . (!!2) . g
14:23:24 <glguy> to use it in a function composition sequence
14:23:31 <glguy> :t (!!)
14:23:32 <lambdabot> [a] -> Int -> a
14:24:36 <levi> Wouldn't last . take 2 = (!! 1) due to 0-based indexing?
14:24:55 <Fuuzetsu> yes
14:24:55 <rrradical> is there a way to see which dependency is responsible for cabal trying to downgrade packages?
14:25:44 <vanila> any ideas where i could ask for tips on this?
14:26:52 <Fuuzetsu> vanila: ##prolog ?
14:27:05 <monochrom> perhaps some people are discussing that puzzle on reddit or stackoverflow
14:27:05 <Fuuzetsu> pretty sure they can point you to some materials
14:27:17 <merijn> rrradical: -v and friends?
14:27:39 <vanila> il google for it
14:27:39 <Fuuzetsu> I don't consider -v my friend, if I have to run it then I already am on unfriendly terms with the program ;P
14:28:53 <rrradical> merijn: oh, --verbose=3 gives me a bit more. thanks
14:35:08 <jfischoff> rradical: when there is a conflict it will mention where the contraints are coming from. You could tell it to use a newer version and then see the error message.
14:44:14 <zmbmartin> Does anyone use mongodb. I am trying to do a FromJSON for ObjectId but am not sure what I am doing.
14:48:24 <athan> Is there a syntax highlighting extension for ghci?
14:51:36 <bernalex> ghci-in-a-new-dress
14:51:39 <bernalex> used to have it
14:51:46 <bernalex> but maybe that project died? =/
14:55:10 <athan> bernalex: D:
14:55:29 <athan> Wait! I remember hearing about some iHaskell business...
14:56:34 <enthropy> ihaskell does syntax highlighting
14:57:00 <bernalex> ah yeah forgot about that. it's a haskell backend for ipython.
14:57:16 <enthropy> probably you don't write large enough expressions in ghci for syntax highlighting to matter
14:57:23 * enthropy is just making excuses for the lack of it
14:57:31 <athan> :P
14:57:33 <bernalex> it's largely true tho
14:57:37 <athan> I'm working with Yesod!
14:57:46 <bernalex> ouch
14:57:52 <athan> yeah my fingers hurt
14:57:55 <bernalex> can you do cabal repl using ipython tho?
14:58:02 <athan> that's my question, too
14:58:09 <bernalex> hope you're using dvorak at least ;-)
14:58:36 <athan> Nope, unicode! (i wish)
14:59:07 <bernalex> athan: https://github.com/gibiansky/IHaskell seems you can use it with cabal repl
14:59:09 <TallerGhostWalt> is there a way to do auto-paren-wrap with structured-haskell-mode?
14:59:14 <TallerGhostWalt> the way you can in sublime?
14:59:22 <athan> woo! Already installing :)
15:00:30 <levi> TallerGhostWalt: Select what you want to wrap, then open-paren.  Or you can open-paren then 'slurp' stuff in via alt-rightarrow or something like that, I think.
15:00:50 <levi> I never really got comfortable with structured-haskell-mode, though.
15:00:54 <athan> I doubt I'll use notebook, though, firefox crashes on me all the time :/
15:03:25 <athan> I fear I'm going to have to make a new WAI backend for this... ><
15:03:33 <athan> like a debug server
15:05:11 <TallerGhostWalt> levi: thanks
15:05:31 <dutchie> hi all, i'm having some trouble with attoparsec
15:05:33 <dutchie> see paste:
15:06:12 <dutchie> http://lpaste.net/109832
15:06:49 <dutchie> i expect that to give me ["foo", "bar" ,"baz"] but it just locks up my cpu and eats all my memory
15:07:58 <dutchie> if i use `many1 (char ' ')` it works fine, but i want to deal with tabs also
15:09:40 <burp> maybe then something like choice [char ' ', char '\t']
15:10:02 <zmbmartin> So in ghci I can do this to get an ObjectId from a string -> read id or if it is Text I can do -> read $ T.unpack in
15:10:11 <burp> I have problems building that example with latest attoparsec/ghc
15:10:13 <zmbmartin> How do I translate that into a FromJSON
15:10:36 <monochrom> I don't understand the type of takeWhile isHorizontalSpace
15:10:40 <zmbmartin> One try has been -> parseJSON = T.unpack . read :: ObjectId
15:10:45 <dutchie> i may have messed it up in transferring it to lpaste
15:10:59 <dutchie> monochrom: it's takeWhile from attoparsec, not Prelude
15:11:10 <zmbmartin> But I get could not match expected type 'ObjectId' with 'String -> String'
15:11:44 <dutchie> http://hackage.haskell.org/package/attoparsec-0.12.1.1/docs/Data-Attoparsec-Text.html#v:takeWhile
15:12:22 <dutchie> burp: sure i could do that
15:12:33 <dutchie> but i want to understand why my example does'nt work
15:12:43 <dmj`> does Aeson have an eitherDecode for strict bytestrings?
15:13:00 <dmj`> I see decodeStrict, returns a Maybe though
15:13:25 <burp> zmbmartin: Data.Bson.ObjectId?
15:13:50 <zmbmartin> burp: I am not sure what you mean?
15:13:58 <monochrom> "Because this parser does not fail, do not use it with combinators such as many, because such parsers loop until a failure occurs."
15:14:00 <burp> zmbmartin: what is that ObjectId you refer to
15:14:14 <zmbmartin> Yes from Database.Mongodb
15:14:29 <zmbmartin> That might be using Data.Bson.ObjectId
15:14:31 <monochrom> I think it is true of sepBy1 as well. sepBy1 relies on mplus which wants to see failure
15:14:47 <zmbmartin> burp: I am trying to write a FromJSON for it.
15:15:12 <dutchie> monochrom: oh right
15:15:24 <dutchie> of course
15:15:57 <dutchie> i should use takeWhile1 instead then
15:16:20 <TheKing444> You guys see any parse errors in this?
15:16:21 <TheKing444> First  -> (Right $ Game (fcs''++[fi, si, fd, sd, fw, sw]) scs'', First )
15:16:33 <burp> zmbmartin: should work with the read instance provided by it
15:16:37 <TheKing444> As part of a case expression.
15:16:42 <dutchie> monochrom: thank you for reading the docs for me
15:16:45 <dutchie> i feel suitably stupid
15:16:50 <burp> zmbmartin: ah I didn't read your error, moment
15:17:01 <TheKing444> wait, nvm
15:17:04 <TheKing444> previous line error
15:17:38 <zmbmartin> burp: I can do read on a string or read $ T.unpack on Text in ghci
15:17:59 <dfdsfs> Is there a way around this? http://dpaste.com/1ZVKNK3.txt It fails to typecheck.
15:19:23 <monochrom> I only know how to explain the type error. I do not know what constitutes a way around.
15:19:59 <geekosaur> likewise
15:20:28 <geekosaur> you are trying to do something that is not going to work. I do not know why you are trying to do it, so I have no suggestions as to how to do it correctly
15:20:47 <monochrom> the type "Foo a => a -> Int" means that the user (not you, the writer) chooses which type for "a". moreoever, parametricity implies that the person who cannot choose (that's you) cannot ask either. that is right, you cannot even ask "is X chosen? is Y chosen?"
15:20:48 <geekosaur> but it does not work and is not intended to work the way you are trying to do it
15:22:43 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/112535 recent related post by me
15:23:41 <monochrom> as the writer, you are only entitled to call methods of Foo. since there are no methods of Foo, you can do nothing.
15:24:06 <burp> zmbmartin: I think you have to use `json`, give me a minute
15:25:15 <zmbmartin> burp: OK thanks!
15:25:22 <enthropy> bernalex: that documentation is for "cabal repl" to load the ihaskell code itself
15:25:36 <bernalex> enthropy: derp
15:25:46 <athan> my laptop keeps overheating :(
15:26:06 <bernalex> athan: put yr cpu-freq governor to userspace and set it to a lower setting
15:26:39 <athan> bernalex: I have a feeling I would just break my system doing that :/
15:26:39 <monochrom> programming is a dialectic class struggle between the giver and the receiver
15:26:41 <enthropy> it's pretty straightforward to grab all the ghc flags that "cabal repl" makes
15:26:47 <s34n> I tried to cabal install gitit and get pages of messages about base-x.y.z was excluded because ... for many versions of base
15:26:49 <bernalex> athan: why on earth would you do that
15:26:58 <athan> lol
15:27:15 <s34n> does that mean I have a too old version of haskell?
15:28:00 <enthropy> s34n: probably it means you need a newer ghc (or maybe an older one)
15:28:54 <monochrom> I wouldn't conclude that without first reading the complete output, and possibly more.
15:31:17 <burp> zmbmartin: http://lpaste.net/8801796386589769728 this compiles
15:31:36 <burp> zmbmartin: not saying it's safe because of read throwing exceptions or such :D
15:32:23 <burp> zmbmartin: you could also use Data.Aeson.json yourself to get a Aeson Value and convert that to your ObjectId
15:32:42 <burp> but withText seems a convenient wrapper
15:32:44 <Algebr> do actions in a do block always go off? like say your entire main is foo <- getLine then print "hi", no point to run getLine?
15:32:54 <zmbmartin> burp: man I was kinda close.
15:33:07 <zmbmartin> burp: Thanks! still trying to grok haskell
15:33:20 <zmbmartin> I feel like I am starting programming all over again.
15:33:42 <burp> read is kinda bad, maybe you should implement the conversion from Text to ObjectId yourself
15:34:12 <s34n> enthropy: I have the latest from the centos repo
15:34:16 <zmbmartin> burp: how would I do that?
15:34:58 <augur> is there a good way to enforce well-typedness across the FFI?
15:36:12 <enthropy> use a preprocessor. c2hs checks that the .h file matches the types you use in .chs file
15:36:24 <merijn> augur: Nope
15:36:41 <augur> merijn: :(
15:36:50 <merijn> augur: Well, if you include the header file with your import, GHC will check whether your types match
15:36:55 <athan> is there any way to delete individual packages from a sandbox?
15:36:59 <merijn> But that's only a very naive check
15:37:01 <augur> merijn: i think ive read that there are ways to define custom types and the C-side will be able to use the types
15:37:01 <enthropy> merijn: it does? oO?
15:37:17 <augur> merijn: something like.. instead of returning, say, Ptr () you return Ptr MyType
15:37:20 <dmj`> Algebr: yes, getLine is a blocking function
15:37:25 <augur> merijn: and on the C-side it goes from being void* to MyType*
15:37:32 <merijn> augur: Right, but then C just sees pointers :)
15:37:39 <merijn> augur: There is no difference to C
15:37:58 <augur> merijn: thats fine as long as the type name is correct, no? i mean, you need explicit casts to change it
15:38:03 <monochrom> treat FFI as I/O
15:38:04 <burp> zmbmartin: use attoparsec to write a parser for such an ObjectId given as Text
15:38:09 <dmj`> Algebr: you can use the "when" and "unless" functions to make monadic actions conditional
15:38:14 <merijn> augur: No, you don't need explicit casts to change the type of void*
15:38:34 <augur> merijn: you dont need to do soething like..   (MyType*)theVoidPointer  ?
15:38:48 <merijn> augur: No, that's C++ nonsense
15:38:52 <augur> merijn: oh ok
15:39:38 <merijn> augur: Also, MyType doesn't magically have more structure, the type argument to Ptr is just a phantom type for safety on the haskell side
15:39:42 <s34n> I have ghc 7.04. I'm trying to cabal install gitit
15:39:51 <monochrom> treat FFI as I/O. when you read from I/O, you get arbitrary data, so you validate and parse to good types; same for data from FFI. when you write to I/O, you unparse good types to arbitrary data; same for data to FFI.
15:39:53 <merijn> augur: The C side doesn't distinguish the pointers
15:39:59 <augur> merijn: no i know. i just would like to be able to state the conventions in the types
15:40:10 <merijn> s34n: 7.04 is pretty ancient
15:40:11 <burp> zmbmartin: ah, or you can use reads
15:40:58 <zmbmartin> burp: reads throws an error for me.
15:41:03 <s34n> merijn: so I gather. but that is what centos supplies
15:41:07 <zmbmartin> I tried that unless I am doing it wrong.
15:41:20 <s34n> so I guess I can go off repo to update... :-(
15:41:27 <burp> zmbmartin: it's not just replacing read by reads though ;)
15:41:37 <monochrom> zmbmartin: my http://www.vex.net/~trebla/haskell/reads.xhtml is a tutorial of reads
15:41:53 <burp> > reads "1.3" :: [(Double,String)]
15:41:54 <lambdabot>  [(1.3,"")]
15:42:20 <burp> then I guess for your ObjectId you would check if there is only one element, and if the `snd` of the tuple is ""
15:42:34 <burp> if that is the case, then return the ObjectId, else mzero
15:42:36 <monochrom> there is also readMaybe in Text.Read
15:42:43 <zmbmartin> burp: OK let me try that.
15:42:59 <enthropy> merijn: how do you get ghc to check foreign import types: https://gist.github.com/aavogt/70f55aa85287f0046f3b ?
15:43:14 <burp> zmbmartin: oh yes readMabye is even better
15:43:23 <burp> I'd use that
15:44:20 <timmy_tofu> Aeson has a function fromJSON :: (FromJSON a) => Value -> Result a , but the only things that operate on Results are in .Internal. Is the best way of converting between a Value and a reified piece of data to encode the Value and then decode with the specified type?
15:44:43 <s34n> google tells me that upgrading 7.0 to 7.8 involves compiling 7.6 then using that to compile 7.8.
15:44:59 <s34n> multiple hour+ compiles
15:45:09 <merijn> enthropy: 1 sec, my machine is having a slowness aneurysm
15:45:21 <merijn> s34n: Or you just donwnload the prebuilt binaries?
15:45:23 <monochrom> the GHC website has pre-compiled binary tarballs. you never need to compile.
15:45:51 <monochrom> start at http://www.haskell.org/ghc/
15:46:09 <s34n> merijn: where?
15:46:17 <s34n> thx
15:47:16 <zmbmartin> burp: I see how to use readMaybe from ghci but how would I do that with the FromJSON
15:47:30 <zmbmartin> Do I need to do a case readMaybe of
15:47:37 <monochrom> yes
15:48:52 <zmbmartin> monochrom: What that yes for me?
15:50:39 <burp> yea it was
15:50:50 <NougatRillettes> Hey guys, do you have ideas on how to improve general performances of this code : http://lpaste.net/109835
15:51:03 <merijn> enthropy: Hmm, my code was using the CApiFFI, so maybe that's the difference
15:51:07 <NougatRillettes> (same as ~10h ago)
15:51:15 <NougatRillettes> (with improvements)
15:51:29 <merijn> enthropy: You should check out the CApiFFI anyway, since it lets you foreign import CPP macro :)
15:51:50 <enthropy> merijn: odd, `foreign import capi "a.h f" f :: Int -> Int' gives the right numerical answer
15:52:17 <moop> ok, crazy idea here
15:52:18 <enthropy> so I guess you get a more sane cast thrown in
15:52:29 <dfdsfs> what does kind [*] mean for HList?
15:52:43 <merijn> dfdsfs: A type level list of types
15:52:55 <dfdsfs> please elaborate
15:53:05 <dfdsfs> what's a type level list?
15:53:11 <merijn> dfdsfs: You may wanna google for an introduction to DataKinds :)
15:53:28 <enthropy> > Proxy :: Proxy ([Int, Double, Char] :: [*])
15:53:29 <merijn> I don't know of one off-hand, other than the GHC manual, which may be a bit short
15:53:29 <lambdabot>  Illegal type: ‘'[Int, Double, Char]’
15:53:29 <lambdabot>    Perhaps you intended to use DataKindsIllegal kind: ‘[*]’ Perhaps you inten...
15:54:01 <zmbmartin> burp: OK here is what I am trying -> https://gist.github.com/codedmart/c0be2b768813e96b0837
15:54:22 <zmbmartin> Types are killing me and I am lost when this stuff happens.
15:54:26 <burp> zmbmartin: do you have an ObjectId that "read"s?
15:55:07 <burp> zmbmartin: uh yea, that is not very sensible :D
15:55:44 <zmbmartin> burp: when we did read it worked fine other then a parse error when it was a bad ObjectId. So I like readMaybe idea better.
15:56:14 <zmbmartin> I just keep getting a little lost so far.
15:56:30 <zmbmartin> I am determined to get haskell but it is kicking my butt so far.
15:56:48 <burp> you should always write type signatures
15:57:03 <burp> before you write the code
15:57:12 <burp> so it's clear to you what you want to have
15:57:36 <burp> otherwise it'll be like trial and error like now ;)
15:58:02 <burp> you should begin with parseJSON
15:58:26 <burp> you want parseJSON :: Value -> Parser ObjectId
15:58:59 <s34n> merijn, monochrom: the downloads point me to my distro's upstream. I'm already using my distro's package.
15:59:43 <s34n> and the "generic" binary tarball looks like it's not generic, but built for debian
16:00:45 <s34n> I really wasn't in for this kind of fight. I just wanted to checkout gitit. ;-(
16:04:49 <zmbmartin> burp: I am not sure I following. Are you telling me to write a Parser?
16:05:14 <burp> you have two functions in your paste above, parseJSON and readMaybeObjectId
16:05:26 <burp> you should write type annotations, that tell you the type of the functions
16:06:01 <burp> like of the readon function
16:06:02 <burp> :t read
16:06:03 <lambdabot> Read a => String -> a
16:06:06 <enthropy> merijn: seems that capi does some checking, but it does more casts so I guess I'm sticking with c2hs for now
16:07:29 <zmbmartin> burp: Ok sorry, so add parseJSON :: Value -> Parser ObjectId to my code.
16:07:34 <zmbmartin> For the parseJSON
16:07:54 <burp> yes, you should do that for all haskell functions you want to write
16:08:22 <burp> then you pick the functions you want to use, and see that type signatures match in compositions :D
16:08:30 <zmbmartin> burb: OK adding that gives me another error now
16:08:47 <burp> yea, your readMaybeObjectId doesn't make sense ;)
16:09:02 <zmbmartin> burp: Pattern bindings (except simple variables) not allowed in instance declarations parseJSON :: Value -> Parser ObjectId parseJSON = withText "_id" $ return . read . T.unpack
16:09:47 <burp> is that in one line?
16:10:00 <zmbmartin> burp: Taking readMaybeObjectId out and using read still gives me the same error.
16:11:49 <zmbmartin> burp: Here is an update of what I have -> https://gist.github.com/codedmart/c0be2b768813e96b0837
16:11:58 <zmbmartin> I really appreciate your help :)
16:12:14 <zmbmartin> updated now.
16:13:08 <zmbmartin> The parseJSON in this case works if I take out the type signature but I get read parse errors if the ObjectId is invalid so I would like to use readMaybe like you mentioned. Which works well in ghci.
16:14:41 <burp> what sample do you run it against?
16:14:46 <burp> the test parsing
16:15:12 <dfdsfs> merijn, monochrom: following up on my HList question, how can I have an HList of both Xs and Ys where data X = X, data Y = Y.  or is it the same situation as my original question?
16:15:18 <burp> decode "…… what"?
16:16:25 <kludgy> Hi all. So I'm using pipes-attoparsec to serialize a binary stream, and I was wondering (of any experts out there), how close is this combination to being bidirectional, ie. using the same definition to spit out the bytes from the parsed data again? Are there any recommendations for bridging the gap? (I guess I'm seeking an isomorphism for the serialization types.)
16:16:42 <dfdsfs> if I say foo :: Foo a => Int -> HList '[a], ghc is unable to deduce it.
16:17:04 <burp> zmbmartin: how do you test that it works with read?
16:18:17 <zmbmartin> burp: I am using scotty right now so I posting data.
16:19:49 <burp> zmbmartin: http://lpaste.net/5587444507235844096 I imagine something like that
16:23:24 <zmbmartin> burp: Thank you very much!
16:23:56 <burp> it works?
16:24:36 <zmbmartin> Yeah if it is a invalid id my bad request fires not rather then a parse read error :)
16:24:53 <zmbmartin> burp: Thanks again! I need to get this stuff down.
16:24:54 <burp> you can also use fail "error message" instead of mzero
16:25:15 <zmbmartin> I keep over confusing myself.
16:25:17 <burp> I was going crazy here for not getting it to work with a sample
16:25:31 <burp> print (A.decode "\"507c7f79bcf86cd7994f6c0e\"" :: Maybe ObjectId)
16:25:38 <burp> in principle something like that should work…
16:26:04 <burp> I have no idea why not, but it seems to work in your setup
16:26:31 <TheKing444> I got an error called "pad3: <<loop>>".
16:26:35 <TheKing444> What does that mean?
16:26:49 <Algebr> is it the case that you can't do pattern matching guards?   | e == (ErrorMisc s) = "Something else? " ++ s , where e came from the function error_handling e
16:27:30 <zmbmartin> burp: This works for me in ghci -> print (decode $ BS.pack "\"507c7f79bcf86cd7994f6c0e\"" :: Maybe ObjectId)
16:27:35 <zmbmartin> sort of I get Nothing
16:27:48 <burp> yea Nothing, I expect you to get 507c7f79bcf86cd7994f6c0e as ObjectId
16:31:03 <zmbmartin> Weird
16:31:15 <dfdsfs> how are types that don't have an 'a' in the type declaration called?  Monomorphic?
16:31:57 <sbrg> dfdsfs: what do you mean?
16:32:09 <heatsink> Types that aren't polymorphic are monomorphic
16:32:21 <sbrg> aah.
16:32:30 <heatsink> For global variables, if they don't have type variables, they're monomorphic
16:32:35 <dfdsfs> Maybe a is polymorphic because a can be anything.  data Foo = X | Y is monomorphic, right?
16:32:44 <heatsink> yes
16:32:47 <dfdsfs> okay
16:32:52 <kludgy> dfdsfs: I think you just mean concrete (or fully specified) types
16:32:54 <dreams> Does GHC use optimistic evaluation at any point?
16:33:09 <TheKing444> what does a "pad3: <<loop>>" error mean?
16:33:38 <dfdsfs> kludgy: Thanks, I'll go with Concrete!
16:33:40 <Algebr> For stuff like Network.Socket and whatnot, presumably those all work via FFI calls to C?
16:33:44 <heatsink> TheKing444: You have a value that depends on itself
16:33:54 <heatsink> > let x = x + 1 - 1 in x
16:33:58 <lambdabot>  mueval-core: Time limit exceeded
16:34:02 <TheKing444> hmm
16:35:20 <heatsink> It's an infinite loop.  In some cases the compiler detects it and replaces it with a <<loop>> error.
16:35:21 <kludgy> dfdsfs: Or 'fully constructed type'... or 'singly kinded' I think.. consider: 'Maybe :: * -> *' but 'Maybe Int :: *'
16:35:25 <eacameron1> can anyone pinpoint a space-leak in this little thing? I am very bad at finding this stuff and so far I have turned up nothing. https://gist.github.com/3noch/aaa2ddf8fae874aac91c
16:35:39 <nitrix> Hi, I have a slightly unusual question but I'm sure it can be solved quickly.
16:35:39 <RumHam> hey all, does anyone know if there's an up to date PDF version of "Learn you a Haskell"? The one on their website stops about halfway through
16:35:40 <dolio> It's actually the runtime system that detects loops.
16:36:11 <nitrix> How would one determine wheter A or B is most successful, if A has 50% success rate but 1 sample, and B has 45% success rate but 20 samples?
16:36:38 <nitrix> I feel like the sample determines the accuracy of that success rate. Is there a formula for this?
16:36:44 <heatsink> With 1 sample, wouldn't the only possibilites be 100% or 0%?
16:37:07 <vanila> A is better
16:37:08 <RumHam> nitrix: what do you mean "successful"? the expected values of success are technically .5 and .45 but the second has more confidence
16:38:03 <nitrix> Well, I'd like to evaluate success, but in terms of confidence.
16:38:17 <vanila> I don't think there's a way
16:38:54 <nitrix> B is slightly less successful by 5%, but you can be a lot more confident about it than A, which only has 1 sample.
16:38:56 * hackagebot simple-pipe 0.0.0.19 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.19 (YoshikuniJujo)
16:38:59 <RumHam> there may be a statistical method to combine the two but you'd need domain knowledge I think
16:39:13 <RumHam> like...you need to define what is success
16:39:30 <RumHam> or rather which is more important, confidence or success
16:39:55 <heatsink> nitrix, you could approach it by modeling the acutal success probability as an exact function of some unknown variables
16:40:44 <heatsink> nitrix, then you have a set of possible probability distributions, and you can ask how likely it is that each of them produced the results that you observed
16:41:30 <nitrix> RumHam: confidence would be more important, but I feel like that relation would have a treshold value?
16:42:07 <heatsink> From that, you could compute the likelihood that the real success rate is within a particular interval, given your observations.
16:42:23 <merijn> TheKing444: It's impossible to detect all infinite loops (halting problem, etc.), but when the compiler detects a "pure" (i.e. no side-effects) infinite loop it will throw an exception, since that can never produce anything useful (other than CPU heat ;))
16:42:26 <nitrix> heatsink: Right, let me digest what you said.
16:43:13 <TheKing444> Well, it breaks my work flow. I use GHC infinite loops to activate my Control Key.
16:43:30 <TheKing444> Also, the children in Russia need it to keep warm.
16:43:51 <zmbmartin> burp: would it be possible to return Nothing rather then use mzero>
16:43:52 <zmbmartin> ?
16:44:17 <burp> no, your result needs to be "Parser ObjectId"
16:44:37 <zmbmartin> burp: ok thanks again!
16:44:39 <burp> otherwise it would be something like Parser (Maybe ObjectId)
16:46:03 <zmbmartin> OK
16:46:31 <zmbmartin> I guess it makes sense that if someone gives an invalid objectid I error out.
16:46:53 <burp> you should not do that in the fromJSON instance
16:47:21 <burp> there only a syntactically correct ObjectId matters
16:47:42 <burp> I assume that you want to check it against your database
16:48:02 <zmbmartin> Yeah I will be.
16:52:03 <zmbmartin> burp: Well I am off. Thanks again so much. I am still going to keep with it.
16:52:27 <burp> yea, its not an easy thing to start with
16:52:55 <zmbmartin> I really appreciate it. It helps me to see code that works to analyze it.
17:01:43 <Algebr> How can you tell if you're encountering the monomorphism probem? Is it when you get ambigiuity in types errors?
17:02:15 <vanila> the fix is to put {-# LANGUAGE NoMonorphismRestriction #-} at the top of your  file
17:02:32 <vanila> it just infers types wrongly when you don't ave it
17:03:00 <merijn> vanila: This is not true
17:03:04 <Algebr> Is that a fix? to disable a part of the language?
17:03:09 <vanila> yes
17:03:15 <merijn> vanila: And blindly disabling monomorphism is not the right approach
17:03:41 <vanila> merijn, I disagree, disabling it fixes the problem completely
17:04:06 <merijn> vanila: At the cost of introducing a silent hard to detect performance issue in some cases
17:04:07 <vanila> ghc goes back to inferring the most general type, as everyone expects
17:04:13 <heatsink> Algebr: I generally add type signatures if I have a type error.  If the problem is fixed by adding a type signature, then it was probably caused by the monomorphism restriction.
17:04:30 <merijn> Algebr: Anything with an explicit type signature will never run into monomorphism
17:04:31 <vanila> if you need monomorphic types for performance reasons just put annotations
17:04:56 <merijn> vanila: The thing is that when MMR is enabled you explicitly get an error in that situation
17:05:08 <merijn> vanila: Without MMR you need to debug what the hell is going on
17:05:24 <merijn> So it is easier to selectively add type signatures when you run into MMR than the other way around
17:05:59 <exio4> i normally never got "eaten" by the monomorphism restriction, but i like to keep the types of top-level functions explicit
17:06:06 <vanila> merijn, which situation exactly?
17:07:31 <exio4> is it that hard to write type notations of functions? they are good for documentation!
17:08:09 <hpc> exio4: the tricky part is that it can bite you on nested definitions
17:08:18 <hpc> where a type signature might be impossible to write without extensions
17:08:24 <hpc> (namely, explicit forall)
17:08:43 <hpc> it's pretty rare for that to happen, but it definitely has
17:08:57 <merijn> vanila: Polymorphic lists get reevaluated, if you have a typeclass polymorphic list generated by an expensive computation and thought it would get memoised it will instead silently recompute every time you use the list
17:09:06 <merijn> Or really any polymorphic datatype
17:09:34 <RyanGlScott> Is there a way to get e-mail notifications about updates to GHC Trac tickets (without leaving a comment)?
17:09:54 <vanila> I am not convinced that this monomorphism thing is good, just put a type annotation when you do lazy memoization
17:09:56 <merijn> RyanGlScott: I think you can add yourself to the CC list?
17:10:06 <vanila> it causes much more confusion to beginners from the non-uniform behavior than its worth
17:10:07 <merijn> vanila: Ah, but now you need to remember when to do that
17:10:19 <merijn> vanila: Whereas the opposite case the compiler tells you what to fix
17:10:25 <RyanGlScott> merijn: Oh yeah, I can. Thanks!
17:11:51 <tabemann> beginners should just be advised to always have type signatures for top-level name bindings
17:13:08 <tabemann> (people coming from ML might not be used to it, since their type signatures are typically in interface files where they are only for names being exported)
17:14:32 <athan> tabemann: It's really contradictory to me, too, seeing as how HM type systems can be completely inferred
17:14:42 <hpc> ... i forgot you can split type signatures from definitions in haskell
17:14:46 <hpc> i must make acme-c now
17:14:55 <hpc> use CPP to separate every type signature into a .h file
17:15:49 <hpc> it would be the perfect acme-php companion
17:16:47 <tabemann> athan: it's still good practice to have type signatures just for documentation purposes, and to make sure that type errors are relatively contained
17:16:54 <RyanGlScott> Besides Haskell and Scala, what other languages support higher-kinded types?
17:17:01 <hpc> java
17:17:26 <RyanGlScott> Er, wait. Maybe I didn't phrase that question correctly.
17:17:26 <hpc> (via generics, but it's kind of tricky)
17:17:27 <tabemann> C#
17:17:48 <athan> tabemann: Isn't it demanded by the monomorphism restriction, though?
17:17:57 <RyanGlScott> I was thinking along the lines of, what languages have the machinery to support Haskell-style Functors?
17:18:01 <heatsink> But C# is implemented on top of .NET, and .NET doesn't support higher kinds
17:18:49 <athan> RyanGLScott: Clean, Gofer, ML, OCaml, Idris, Adga to name a few
17:19:02 <RyanGlScott> athan: That's a fantastic list, thanks.
17:19:07 <athan> :)
17:19:15 <tabemann> athan: it's made necessary in many cases because of the monomorphism restriction, but you should do it even you turn it off
17:19:38 <athan> tabemann: I agree... sorta :P. Sometimes I shoot myself in the foot
17:20:04 <josephle> athan: SML and OCaml don't _really_ have higher-kinded types
17:20:28 <athan> josephle: :x
17:20:30 <josephle> just because the module system can be translated to F-omega, doesn't mean programmers can use that fact :P
17:20:45 <tabemann> even if it's off, the problem is that type errors can escape from definitions and affect the types of other definitions, making them much harder to debug
17:20:57 <RyanGlScott> I'm surprised that newer languages (e.g., Rust, Swift) aren't on that list.
17:21:11 <platz> Rust is slated to add higher kinds after 1.0
17:21:15 <athan> tabemann: That's really good to know, actually. I could see that being a pain
17:21:16 <RyanGlScott> Sweet.
17:21:17 <josephle> Rust made a conscious decision to not have first-class support for higher kinds before 1.0
17:21:24 <vanila> new languages often don't learn the lessons of the past
17:21:31 <athan> Racket?
17:22:01 <tabemann> Racket is dynamically typed, but I onno about Typed Racket
17:22:09 <platz> Rust is all *about* the lessons of the past, that is why it's called Rust!
17:22:48 <josephle> the lesson they took away is that HKTs intimidate beginners :/
17:23:03 <athan> Omega! >:D
17:23:05 <josephle> hence why no HKTs for now
17:23:17 <RyanGlScott> It looks like Typed Racket doesn't support it either: https://groups.google.com/d/msg/plt-scheme/TzNdyLX4MyM/cL5vcbWFJOoJ
17:23:47 <vanila> that seems weird, why can't beginners just not use higher kinded types?
17:24:11 <athan> Why can't they use them?!
17:24:17 <platz> higher kinds seem very similar to generic classes in C#
17:24:28 <platz> class BaseNodeGeneric<T>
17:24:31 <vanila> aren't they just things like  newtype Compose f g x = Compose (f (g x))
17:24:36 <vanila> it isn't really hard
17:24:50 <athan> Higher kinded types just "sounds" bad. It's honestly really intuitive, imo
17:24:57 <athan> as a beginner, even
17:24:57 <vanila> I agree athan
17:25:07 <josephle> vanila, athan: in paraphrase -- leads to scary things like MONADS
17:25:18 <athan> D:
17:25:19 <tabemann> why is it that language designers have this idea that it's better to cater to ignorant newbies rather than providing features that people who've actually learned said language should be able to use, with useful effect
17:25:30 <tabemann> even Haskell
17:25:37 <vanila> tabemann, yeah this trend seems harmfull
17:25:50 <tabemann> they split fmap from map, for instance
17:26:02 <tabemann> when map should be fmap
17:26:04 <athan> I totally agree
17:26:07 <athan> or the AMP
17:26:29 <athan> or the semigroups/monoid... idea
17:27:52 <RyanGlScott> athan: Has there been any traction to make Semigroup a superclass of Monoid?
17:28:01 <athan> I don't think so :/
17:28:05 <athan> it's more of principal
17:28:18 <athan> and also from the fact that the type system isn't perfectly ubiquitous
17:28:27 <newbie227> whats up
17:28:36 <athan> check out ed kmetts categories, for example
17:28:52 <athan> newbie227: Ayoooo
17:29:18 <newbie227> athan: urp.
17:29:30 <athan> newbie227: Bless you
17:29:37 <newbie227> athan: welks
17:29:51 <josephle> tabemann: from rust's perspective, they want to get people to convert from C/C++
17:30:18 <josephle> these people will probably not be that receptive of monads and functors :/
17:30:22 <newbie227> josephle: why?
17:30:36 <vanila> if rust isn't pure functional then there will be no need to use monads
17:31:21 <josephle> vanila: you say that, but I sometimes miss the Maybe monad when programming rust
17:31:22 <athan> I wonder if we could make PureScript self-hosted...
17:31:48 <tabemann> the thing is that even an imperative language could do well with sum and product types
17:31:50 <vanila> hmm
17:32:05 <tabemann> and with higher-kinded types
17:32:12 <athan> I wish application, composition, and forward-application (binding) were ubiquitous across the typeclasses :/
17:32:15 <vanila> josephle, usually this is obviated by having a way of throwing and catching exceptions
17:32:33 <c_wraith> josephle: I could swear rust has a Maybe monad.  What it lacks is a monad *abstraction*
17:32:33 <athan> I agree, tabemann
17:32:38 <tabemann> but you don't want to always have to catch exceptions
17:32:44 <josephle> that is true, but rust doesn't have exceptions
17:32:46 <newbie227> what kind of programming do you guys usually do?
17:32:53 <vanila> so this sounds like a problem
17:32:56 <tabemann> exceptions have a way of not getting caught, and cascading down
17:33:02 <c_wraith> josephle: Though I think it's Option instead of Maybe
17:33:04 <vanila> in go you have to do error checking in an absolutely hilariously stupid way
17:33:05 <tabemann> whereas you often just want to represent something or not something
17:33:18 <vanila> it's  result, err := call_procedure(...)
17:33:24 <tabemann> without any exception handling
17:33:27 <vanila> and you can just write result := call_procedure(...) and the compiler accepts it
17:33:36 <athan> newbie227: fancy stuff
17:33:40 <vanila> which is what you do when you "know that an error will not occur"
17:33:46 <josephle> c_wraith: I always wondered why haskell chose Maybe over Option
17:33:46 <newbie227> athan: with frills!?
17:33:58 <tabemann> I wondered about that too
17:34:08 <tabemann> Option just seems to be a better name than Maybe
17:34:17 <vanila> go is a huge step back in language design progress
17:34:31 <athan> newbie227: I wish D:
17:34:43 <tabemann> these people are just recreating traditional imperative languages without knowing anything better
17:35:06 <athan> vanila: Really? I just spoke with a fan of it saying how concurrent it was
17:35:19 <vanila> the concurrency stuff is great
17:35:38 <athan> vanila: It had a Ruby-esque to it, though :/
17:35:42 <athan> I don't much like ruby
17:35:57 <tabemann> the thing is if these people knew better they'd be borrowing from ML for their imperative languages
17:36:12 <josephle> tabemann: which is exactly what Rust is doing
17:36:22 <josephle> and Swift for that matter
17:36:32 <josephle> people *have* gotten wiser
17:37:31 <tabemann> I'd say that the MLs would make perfectly good imperative languages unto themselves, except they have poor concurrency and parallelism support
17:38:08 <dolio> What about Alice?
17:38:21 <tabemann> haven't looked at Alice
17:38:36 <nicoo> tabemann: Not true. OCaml has very good libs for concurrency (and // runtime is coming :D)
17:38:59 <tabemann> nicoo: doesn't OCaml have a single-threaded runtime?
17:39:07 <tabemann> single core I mean
17:40:25 <hiptobecubic> I though ocaml couldn't multithread, only multiprocess?
17:40:30 <hiptobecubic> I could be wrong, i really have no idea
17:40:59 <tabemann> presently to do multicore in OCaml you have to break your program up into multiple processes and do messaging between them
17:41:13 <hiptobecubic> right
17:41:52 <tabemann> and OCaml doesn't have STM or actors last time I checked
17:43:34 <nicoo> tabemann: Hence why I said concurrency, not //ism. And there are libs implementing STM
17:44:20 <tabemann> other thing - OCaml doesn't do N:N multithreading
17:44:57 <tabemann> which can allow extremely lightweight threads
17:46:35 <newbie227> anyone here do any game programming?
17:47:16 <hpc> newbie227: some do
17:47:25 <hpc> got a specific issue?
17:47:56 <newbie227> not really, just starting with pygame
17:48:20 <Algebr> isn't pygame a python thing?
17:48:35 <newbie227> usually... why?
17:48:51 <hpc> Algebr: it's actually rho for ruby :P
17:52:34 <RyanGlScott> I'm having some problems with Haskell build-tools at the moment. I'm trying to use c2hs to make a sum type from C enums: http://lpaste.net/109841
17:52:53 <RyanGlScott> The problem is that some definitions are only available in certain versions of the C library I'm using
17:53:19 <RyanGlScott> I want to use #ifdef's to section them off (e.g., #if defined(ENUM_THING) ... #endif)
17:53:40 <RyanGlScott> But c2hs runs before the C preprocessor does, and it interprets #if/#endif as a syntax error
17:54:05 <RyanGlScott> Is there a way to force the C preprocessor to run before c2hs?
17:54:26 <enthropy> you could call it yourself
17:54:43 <RyanGlScott> enthropy: I could, but it would be nice to have cabal do it.
17:55:12 <enthropy> probably you have to change the #include to something that turns into #include after the cpp is done with it
17:55:40 <RyanGlScott> enthropy: I'm not sure I follow.
17:58:12 <enthropy> RyanGlScott: I mean if you had a Makefile, there'd be a rule with a body like   cpp < uuid.chs.in > uuid.chs
17:58:44 <enthropy> and probably c2hs wants to see "#include <bluetooth/sdp.h>" instead of the contents of that file
17:58:57 <RyanGlScott> enthropy: Ah, I see what you mean. I suppose I could call make from Setup.hs.
18:09:41 <protein-jesus> I need to generate numbers from 30 to 180
18:09:44 <protein-jesus> what do I do?
18:09:58 <hpc> > [30 .. 180]
18:10:00 <lambdabot>  [30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,...
18:10:01 <tabemann> [30..180]
18:10:11 <protein-jesus> I don't see :: Generator -> (Int, Int) -> Int in System.Random
18:10:36 <protein-jesus> oh sorry, random numbers :)
18:10:43 <dolio> @type randomR
18:10:45 <lambdabot> (Random a, RandomGen g) => (a, a) -> g -> (a, g)
18:11:08 <protein-jesus> oh
18:11:20 <protein-jesus> it appears I'm just stupid
18:11:22 <shachaf> dolio: Oh, Bazaar is another pseudo-example of this thing I was talking about.
18:11:39 <shachaf> With Mu/Nu and Yoneda/Coyoneda and Codensity/Density and so on.
18:11:52 <shachaf> But your arguments that it wasn't that much of a thing were somewhat convincing.
18:15:17 <dolio> I think it's limits and colimits.
18:15:43 <tabemann> is it reasonable practice to create a function wrapping liftIO . atomically just because I'll be using that a lot?
18:16:11 <dmj`> When designing an API for a haskell library, if two modules define two data types that both reference each other, a circular module import scenario is created, is a good solution to create an external Types folder and house the types in there to get around this? Or is there a better way?
18:16:26 <tabemann> that's what I'd do
18:16:28 <johnw> me too
18:16:33 <johnw> I almost always have a "Types" file
18:16:47 <dmj`> yay! ok good :)
18:16:54 <dmj`> thanks johnw, tabemann
18:17:06 <tabemann> I feel conflicted about doing this, though, because I don't *really* want to expose my scripts to the internals of all my types
18:17:37 <dolio> (Co)limits are defined by correspondence to natural transformations, and there are lots of natural transformations where you can slop things to one side or the other to get one.
18:17:47 <tabemann> (in my IRC client, that is)
18:17:56 <dmj`> my other concern was, "how will this affect the haddocks?", since obviously I don't want to expose the types folder directly, but via the higher level module
18:18:14 <dolio> And when things are internalized to the degree they are in Haskell, that's shuffling around quantifiers and such.
18:18:22 <dolio> Or, in GHC.
18:18:45 <tabemann> dmj`: I've seen Haddocks for packages organized this way before
18:19:17 <protein-jesus> dolio: thanks. That seems to be working for me
18:19:28 <dolio> protein-jesus: No problem.
18:20:13 <tabemann> dmj`: maybe one could export the types from other modules, and then exclude your types module from the Haddock
18:20:19 <Markz> is there a work around for to ignore *** Exception: <stdout>: hPutChar: invalid argument (invalid character)
18:20:22 <dolio> shachaf: What's the other side of bazaar?
18:20:26 <dmj`> Yea, I think I have too, I just want to be sure that the types defined in the types folder are documented in the higher level module, so clicking Web.Lib.A shows documentation for types in Web.Lib.Types.A as long as Web.Lib.A imports Web.Lib.Types.A
18:20:33 <shachaf> dolio: I don't know if there is one.
18:20:35 <hpc> Markz: what character is it?
18:20:39 <dolio> Oh.
18:20:46 <Markz> no idea
18:21:05 <dolio> shachaf: I'm sure you can get one by rearranging quantifiers.
18:21:08 <Markz> I don't generate the text
18:21:20 <hpc> do you know the encoding of the text?
18:21:27 <shachaf> dolio: The quantification in Bazaar is a bit strange, though.
18:21:27 <Markz> it can be anything
18:21:38 <shachaf> Bazaar a b t = forall f. Applicative f => (a -> f b) -> f t
18:21:51 <shachaf> Rather than something like forall t.
18:21:55 <dolio> Oh, it's f.
18:22:17 <dolio> Maybe not, then.
18:22:19 <tabemann> dmj`: btw, reexporting a type is just a matter of importing it and then exporting it in your module statement, right?
18:25:03 <dmj`> tabemann: that's my understanding yea
18:25:45 <kvanb> tabemann: if it's a newtype, you may need to remember to put (..) at the end
18:25:51 <shachaf> dolio: It still seems to fit the same pattern, though.
18:25:51 <kvanb> or the constructors won't be exported
18:26:56 <tabemann> yeah
18:27:01 <shachaf> dolio: If you make a Bazaar equivalent for Traversable, I guess it would look like Bazaar t a = forall f b. Applicative f => (a -> f b) -> f (t b)
18:27:08 <shachaf> Or something like that.
18:27:19 <dolio> Yeah.
18:27:42 <dolio> Or pull out the b if you want.
18:28:20 <shachaf> It looks more like Yoneda when it's polymorphic in the b. :-)
18:28:59 <shachaf> I mean, you probably want the most polymorphism possible. You apply it to something :: t a, so you have to fix t and a, but nothing else.
18:30:08 <dolio> Yeah.
18:34:46 <tabemann> I wonder if I'm making the users of my program do too much by forcing them to use STM to do basically anything with their scripts
18:35:29 <tabemann> I'm creating accessor functions to hide away much of the STM machinery so the users don't have to evaluate readTVar and writeTVar repeatedly
18:37:40 <samba1> how can I import the Object data constructor from Aeson explicitly? if i import Data.Aeson, i can write parseJSON (Object o), but i don't know how to import Data.Aeson (Object(..),(.:)) to limit it. there is no Object data constructor
18:38:37 <dmj`> samba1: Data.Aeson (Value (..))
18:38:50 <dmj`> it's part of Value I believe
18:39:04 <dmj`> http://hackage.haskell.org/package/aeson-0.6.1.0/docs/Data-Aeson.html#t:Value
18:39:06 <samba1> dmj`: you are right, i think
18:39:21 <samba1> dmj`: so it's different from the type Object
18:40:32 <samba1> confusing, thank you
18:40:33 <dmj`> samba1: yea, I guess you can have types and data constructors with the same name
18:40:43 <dmj`> type A = Int; data B = A is valid
18:41:17 <dmj`> that is strange, calling :i on A shows both the type alias and the data constructor
18:41:51 <dmj`> Oh of course, one's a type, one's a value
18:41:56 <dmj`> duuuhhhhh
18:42:05 <timmy_tofu> dmj`: showing both makes sense to me, but :i Object only shows one
18:42:11 <dmj`> they exist in two seperate realms of the universe
18:42:14 <timmy_tofu> dmj`: the alias
18:42:30 <dmj`> timmy_tofu: he might not be exposing it
18:42:50 <dmj`> let's fact check that
18:42:53 <timmy_tofu> It's exported
18:43:03 <samba1> Object is out in Data.Aeson
18:43:16 <timmy_tofu> The Object vs. Object thing caught me, too
18:43:26 <timmy_tofu> I get it, but that :i doesn't show it always confused me
18:43:43 <samba1> yes, confusing
18:43:54 <dmj`> timmy_tofu: it's exported from Internal, not from Data.Aeson I'm guessing
18:44:12 * hackagebot passwords 0.1.0.4 - Password generation/validation library  http://hackage.haskell.org/package/passwords-0.1.0.4 (mkulkin)
18:45:37 <timmy_tofu> http://hackage.haskell.org/package/aeson-0.8.0.0/docs/src/Data-Aeson.html
18:45:52 <timmy_tofu> Aeson, top level, re-exports both Object and Value(..)
18:46:30 <samba1> Wait, now it does show both
18:47:37 <tabemann> http://www.haskell.org/haskellwiki/Physical_equality < whoever wrote this *wants* physical quality tests that aren't in IO?
18:48:18 <tabemann> so they're willing to give up referential transparency just to be able to do physical comparisons of values?
18:50:24 <dmj`> timmy_tofu: yea shows both for me too
19:04:31 <nitrix> What happens if I load a program in ghci, then only reload a module? Do the State monads preserve their states?
19:04:42 <vanila> no
19:05:56 <nitrix> So there's no form of easy hot patching to make the iteration/dev cycle faster?
19:06:19 <nitrix> I figured since it was modular, maybe GHCi would allow it.
19:07:34 <dmj`> nitrix: you can just define the states you want to work with in the file, then when you send it to ghci it will be defined
19:09:23 <dfeuer> Ping dcoutts dcoutts_
19:17:55 <naudiz> Is there a way to import a module from a file's parent directory?
19:19:00 <merijn> naudiz: Only if the importing module is lower in the hierarchy
19:19:59 <merijn> naudiz: i.e. if I have ~/Foo/Bar/Quux.hs, ~/Foo/Xyzzy.hs then Quux.hs can just "import Xyzzy" IF Quux.hs contains the module "Bar.Quux"
19:20:19 <Laquendi> nitrix: http://hackage.haskell.org/package/foreign-store but it's super hackish, i think yesod guys also had some (potentially) better solution
19:20:32 <naudiz> merijn: thanks, there was actually no problem at all, ghcmod just didn't know what to do with the import :)
19:23:37 <merijn> hmmm
19:24:28 <merijn> I have an Executable depending on a library defined in the same cabal, my executable only imports modules from my library (well, that and base/bytestring), but when I try to build it, it complains about all sorts of invisible packages (all of them are dependencies of my library which builds just fine)
19:24:46 <merijn> I don't need to list the transitive dependencies for executables, do I?
19:27:04 <benzrf> i want monadic parser combinators that dnt sck in more languages
19:27:40 <dmj`> benzrf: just use haskell, problem solved :)
19:28:12 <RyanGlScott> merijn: I wouldn't think so. What packages does cabal think are invisible?
19:28:49 <benzrf> dmj`: i would
19:28:55 <benzrf> actully i do
19:29:53 <merijn> RyanGlScott: Everything, basically
19:30:09 <merijn> RyanGlScott: stm, binary, pipes, all the dependencies of my own library, basically
19:31:01 <Laquendi> merijn: do you have correct exposed-modules && other-modules sections
19:31:14 <merijn> Laquendi: Yeah
19:31:55 <merijn> Laquendi: Like I said, my own library builds just fine and the 4 or so modules I import in the executable are exposed
19:35:17 <RyanGlScott> merijn: The only thing I could possibly think of is some weird behavior related to package versioning, but I couldn't tell without seeing the .cabal file.
19:36:01 <merijn> RyanGlScott: My executable has literally 3 dependencies, so that seems odd
19:36:14 <merijn> RyanGlScott: base, bytestring (identical version as my own library) and my library
19:43:10 <timmy_tofu> merijn: What's on the line numbers ghc complains about members of invisible packages?
19:44:16 <merijn> timmy_tofu: Well, it's complaining about line numbers in my libraries modules, even though that's already been compiled succesfully?
19:45:52 <NemesisD> hey folks. i'm trying out the new company-ghc package in emacs. it mentions troubleshooting problems with ghc-mod and it says "try again with setting ghc-debug to t and see if there is any error in *GHC Debug* buffer"
19:46:02 <NemesisD> anyone know what he means by setting ghc-debug to t. how would i do that?
19:47:47 <geekosaur> M-: setq ghc-debug t         or possibly     M-x set-variable ghc-debug t
19:48:07 <timmy_tofu> merijn: You're compiling both with cabal build, right? And they're in the same package? That is, an executable referencing it's own library
19:48:07 <geekosaur> (the "variables" for the latter need to be declared in a particular way to work)
19:48:13 <geekosaur> er
19:48:21 <geekosaur> M-: (setq ghc-debug t)
19:48:29 <merijn> timmy_tofu: Yes
19:48:30 <geekosaur> it needs a lisp expression
19:50:52 <RyanGlScott> merijn: You aren't listing the library's exposed-modules in the executable's other-modules, are you?
19:51:22 <merijn> RyanGlScott: I'm not listing any modules in the executable, other than "Mains-is: Main.hs"
19:51:30 <RyanGlScott> Hm.
19:51:30 <merijn> s/Mains/Main
19:52:18 <NemesisD> hmm ok, did that, unfortunately everything looks good in the ghc debug buffer
19:56:40 <NemesisD> geekosaur: you wouldn't happen to know anything about company-mode or ghc-mod in emacs would you?
19:56:54 <geekosaur> no, sorry
19:57:48 <geekosaur> until very recently my emacs+haskell usage has been under RHEL6 and therefore about a decade out of date...
19:58:03 <NemesisD> woah
19:58:24 <naudiz> let's say I have a function Foo :: IO (Int) ... how do I run putStrLn :: Text -> IO() there?
19:58:43 <funnybutton> How do I learn Haskell as my first programming language?
19:58:49 <funnybutton> I wanna have major fun
19:58:56 <naudiz> or... how do I convert IO () to IO (Int)?
19:59:14 <funnybutton> naudiz: simple, write a function
19:59:33 <funnybutton> wait...no clue
19:59:45 <naudiz> funnybutton: I suppose there already is a function
19:59:52 <bmuk> funnybutton: learn you a haskell is a great book for beginners and it's available online
19:59:55 <merijn> naudiz: Well, how do you magically expect "putStrLn" to return an Int?
20:00:12 <glguy__> naudiz: What are you trying to do more specifically?
20:00:13 <merijn> naudiz: Do you already have an Int you want to return?
20:00:21 <bmuk> merijn: couldn't you just putStrLn $ show int
20:00:22 <bmuk> ?
20:00:35 <naudiz> merijn glguy__ nevermind, there was a missing `do` :D sorry
20:00:36 <merijn> bmuk: How does that return an Int?
20:00:41 <naudiz> but thank you anyway
20:00:45 <merijn> bmuk: putStrLn just prints a line
20:00:57 <geekosaur> are we sure we don't want (putStrLn ... >> Foo) ?
20:00:58 <bmuk> sorry I thought you just wanted to print an int
20:01:55 <merijn> No further suggestions about why cabal is flipping out?
20:02:02 <naudiz> geekosaur: I forgot `do` after my case condition
20:02:20 <funnybutton> bmuk: I will write an object oriented Haskell with immutable objects such that every time you modify an object you get a new one
20:02:37 <funnybutton> bmuk: and pure functional
20:03:01 <funnybutton> bmuk: if only you could cause I'm too young
20:04:08 <bmuk> funnybutton: no such thing as too young! Look at this if you're interested in languages - https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours. I'd go through LYH first but you don't necessarily have to
20:04:52 * dfeuer wonders if funnybutton is beaky in disguise.
20:05:00 <dfeuer> Probably not.
20:08:10 <funnybutton> dfeuer: no I'm not beaky
20:10:34 <krishnan_p> I am learning to use the pipes library for a small network download manager I'm writing. I wanted to know if it's correct to make a producer out of a lazy ByteString and form the 'pipeline'?
20:14:09 <johnw> krishnan_p: sure, the lazy ByteString can yield strict chunks as elements easily
20:14:32 <johnw> in fact, there should be a combinator for that I'm pretty sure
20:18:18 <krishnan_p> johnw, I don't know how to reason space complexity of the lazily evaluated parts of haskell. So, I was wondering if having lazy ByteString at the start of a pipes pipeline would be missing the point of this library completely.
20:18:41 <johnw> for a pure pipeline, that would be right
20:18:48 <johnw> the question is where that lazy bytestring is coming from, and how
20:19:22 <merijn> krishnan_p: If you already have a lazy ByteString, use that, if you're reading from a socket, you probably want something like
20:19:53 <merijn> http://lpaste.net/109845
20:20:59 <krishnan_p> I want to write an application that downloads content from a URI and save it on to a file on the disk
20:21:33 <krishnan_p> I have been hearing about pipes a lot and wanted to use it to make my app to be deterministic in its space complexity
20:22:12 <krishnan_p> I am using download-curl library to fetch the content given a URI. There are two variants of ByteString the library provides, 1) strict and 2) lazy
20:22:45 <krishnan_p> merijn, johnw, does that give you an idea as to what I am trying?
20:23:32 <merijn> I'm guessing download-curl's strict interface just loads the entire file into memory, so you probably want the lazy interface from download-curl and stream that to disk
20:26:46 <krishnan_p> hmm. I'd like to understand how pipes library ensures that the size of chunks 'pulled' from the upstream lazy ByteString is bounded. I guess that is going to take some time.
20:31:09 <NemesisD> oh god damnit does ghc-mod not understand cabal sandboxes
20:31:27 <merijn> krishnan_p: Lazy bytestring is essentially a lazy list of fixed size bytestring chunks
20:31:38 <merijn> krishnan_p: So it can just pop off one chunk at a time
20:32:30 <merijn> krishnan_p: And the default chunk sizes has a 32kb max, so it will never pop off more than 32kb at a time.
20:33:14 <krishnan_p> merijn, OK. Thanks for the explanation.
20:33:20 <merijn> NemesisD: I have an unofficial fork of hdevtools on my github with some community patches that has rudimentary sandbox support
20:40:17 <merijn> There's no real way to determine whether something uses a (potentially) blocking operation, internally, right?
20:42:10 <monochrom> there is no practical way. there is a theoretic way, but impractical.
20:42:22 <merijn> I was afraid of that
20:43:01 <merijn> Doesn't that make bracket nearly impossible to use safely in the presence of async exceptions?
20:43:18 <naudiz> how do I force a IO flush?
20:43:33 <merijn> naudiz: Of a specifice Handle?
20:43:50 <monochrom> System.IO has hFlush, naudiz.
20:44:07 <monochrom> along with hSetBuffering if that is even better
20:44:19 <naudiz> without a specific handle, standard IO
20:44:36 <monochrom> then the handles are stdin, stdout, and stderr
20:44:44 <naudiz> thanks
20:45:49 <merijn> Do other users of async exceptions just rely on luck for their correctness, or something? >.<
20:46:05 <johnw> merijn: why do you ask that?
20:46:28 <monochrom> I rely on hClose being not-blocking-enough
20:46:39 <merijn> monochrom: The problem isn't releasing, that's safe
20:46:52 <merijn> The problem is that how the hell can I be sure my resource allocation is non-blocking?
20:47:22 <merijn> If I have compound allocations then I can't rely on bracket, as bracket uses mask, not uninterruptibleMask
20:47:37 <merijn> If any part happens to be blocking you can still leak resources
20:47:49 <merijn> And there's no real way to check
20:48:29 <merijn> Other than auditting my dependencies and hoping they don't silently change some implementation to something that can block
20:48:40 <johnw> merijn: you could also look at ResourceT, if bracket is troublesome
20:48:48 <johnw> or whatever the pipes equivalent is called
20:48:51 <monochrom> I think, so far, I haven't had compound allocations. if I have two openFile's, I use two corresponding brackets. hell, I use two withFile's.
20:51:08 <merijn> johnw: pipes uses edwardk's exceptions, which provides a transformer friendly bracket, but that doesn't eliminate the mask issue
20:52:18 <merijn> monochrom: Well, I'm establishing a network connection, which means first "connect" and the use "socketToHandle", but the latter uses modifyMVar, I just saw
20:52:26 <merijn> So there you go, already not an atomic allocation
20:52:47 <merijn> If you get an unlucky async exception during the modifyMVar you leak the socket
20:53:27 <johnw> modifyMVar doesn't mask async exceptions?
20:53:39 <llefri> Hi... I've got a question, if I have a list of numbers, is it possible to multiply each of the numbers inside it?... for example, numbers = [1..10] and then mutiply all of them by 2?
20:53:47 <merijn> johnw: Not uninterrupbleMask
20:53:53 <Makoryu> > map 2 [1 .. 10]
20:53:55 <lambdabot>  Could not deduce (GHC.Num.Num (a0 -> b))
20:53:55 <lambdabot>    arising from the ambiguity check for ‘e_12110’
20:53:56 <lambdabot>  from the context (GHC.Num.Num (a -> b),
20:53:56 <lambdabot>                    GHC.Num.Num a,
20:53:56 <lambdabot>                    GHC.Enum.Enum a)
20:53:58 <Makoryu> OH NO
20:54:08 <johnw> map (+2)
20:54:09 <Tiktalik> MAKORYU
20:54:14 <Makoryu> > map (*2) [1 .. 10]
20:54:15 <merijn> johnw: So you need to be really unlucky (modify when the content is taken, so modify blocks and can get async'ed)
20:54:16 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
20:54:33 <johnw> merijn: hmm
20:54:36 <llefri> mmm...
20:54:52 <merijn> johnw: In this case I think I'm fine, since I'm the only thread with access to the socket, so I can guarantee the MVar is not empty, but still
20:55:02 <merijn> johnw: This is not the case in general
20:55:06 <Tiktalik> Makoryu: Hi. I think I loosely know you from another channel.
20:55:19 <Makoryu> Tiktalik: Nah, don't think so
20:55:24 <Makoryu> You're imagining things dude
20:55:27 <pjdelport> :t map
20:55:27 <merijn> johnw: So I was just wondering whether 1) everyone was just not paranoid enough 2) relied on luck not to get bugs or 3) just uninterruptibleMask's everything
20:55:28 <llefri> Thank you guys!
20:55:28 <lambdabot> (a -> b) -> [a] -> [b]
20:55:29 <Tiktalik> Makoryu: You made weird faces.
20:55:38 <johnw> merijn: I think 1 and 2
20:55:45 <Tiktalik> Distinctive ones.
20:55:47 <Makoryu> Tiktalik: No way, my faces are 100% normal
20:55:49 <johnw> merijn: you've read Marlow's book yet?
20:55:50 <merijn> johnw: I'm afraid so too :)
20:55:53 <merijn> johnw: Yes
20:55:54 <Tiktalik> Makoryu: Nice to see you again.
20:56:10 <johnw> getting async exceptions right is a black art
20:56:13 <Makoryu> Tiktalik: In fact I am totally boring and ordinary and there's no reason to take note of me
20:56:14 <Makoryu> Also sup
20:56:19 <Tiktalik> Not much.
20:56:33 <Tiktalik> Makoryu: I've learned jack shit about programming, and got an electric bass guitar.
20:56:37 <merijn> johnw: Although I didn't learn much news, as I read it after I managed to get my "bidirectional blocking communication in a single thread by abusing async exceptions and uninterruptibleMask" working before then :)
20:56:41 <johnw> snoyberg is really good with async exception handling, he and I used to discuss them in depth whenever we'd review code
20:57:01 <johnw> merijn: is your code public?  I'd love to read it over
20:57:12 <merijn> johnw: Not yet
20:57:47 <merijn> johnw: I wanna get it at least to "pre-pre-pre-pre alpha stage" before then, also the bidirectional communication bit I nuked, because I no longer need it :)
20:57:48 <johnw> I'd enjoy more experience at reviewing code for proper async exc. handling, so just ping me when it's available
20:59:41 <merijn> johnw: Right now I'm doing an intermediate cleanup pass before adding some more actual features, so I get to do fun things like bikeshed how to linewrap type signatures :p
20:59:54 <johnw> ooh, always fun
21:00:22 <monochrom> use fewer spaces to avoid linewrapping
21:01:58 <merijn> monochrom: Not gonna work :)
21:02:11 <merijn> monochrom: Even without space it probably filles like 2 lines :)
21:03:24 <monochrom> replacing -> by → may also help :)
21:04:31 * hackagebot lens 4.4.0.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-4.4.0.1 (EricMertens)
21:04:54 <merijn> monochrom: After eliminating all superfluous spaces I come out at 138 characters :p
21:05:47 <monochrom> once upon a time, there was such a thing as 132-column screens and printers.
21:06:05 <glguy__> simpler times
21:06:37 <merijn> Feel free to bikeshed the linewrapping of this beauty: http://lpaste.net/109846
21:07:13 <johnw> merijn: https://gist.github.com/eca1439d2881aafa0412
21:07:23 <johnw> that's what my automatic "fill type-signature" function does
21:08:10 <monochrom> "fill" is as in emacs's "fill paragraph" which means adding line breaks?
21:08:16 <johnw> yes
21:08:25 <johnw> i have it bound to C-c M-q
21:08:45 <monochrom> nice emacs fu
21:09:15 <merijn> That's what I had manually wrapped (aside from the second argument)
21:09:21 <merijn> I was debating the proper style for that
21:11:28 <zq> oh hey johnw
21:11:45 <zq> i ported your catmaybes proof to agda :>
21:11:46 <merijn> Right, time to "unsuck" the next file :)
21:11:59 <johnw> zq: nice!  can I see it?
21:12:02 <zq> on a separate note: when to use Reader versus param passing?
21:12:21 <johnw> I like using Reader when there are lots of intermediate functions that have no need of the parameter
21:12:28 <johnw> the functional version of "dependency injection"
21:13:10 <zq> johnw: here it is: https://gist.github.com/bryant/3f52772383ca1862e8d1
21:13:43 <zq> everything below line 29 are the byproducts of groping around on how to use propositional unification
21:14:27 <johnw> nice
21:14:40 <merijn> johnw: I thought ContT was the functional version of dependency injection? :p
21:14:51 <benzrf> for some value of dependency injection
21:15:12 <copumpkin> I thought functions were the functional version of dependency injection
21:15:15 <zq> what if i have a complicated Reader env variable?
21:15:25 <zq> uh, a complicated param datastruct*
21:15:29 <johnw> well, I'm thinking of dependency injection as "providing values to deep leaves of a function graph without cluttering intermediate levels"
21:15:38 <johnw> but it's not a precise term
21:15:40 <benzrf> reader, then
21:15:52 <copumpkin> :)
21:15:56 * copumpkin will bbl
21:16:00 <johnw> zq: the lens library can make it easier to access
21:16:07 <johnw> haha
21:16:31 * benzrf just realized he still has no idea what a codensity is
21:16:45 <benzrf> its been 3 weeks and i never looked it up myself
21:16:54 <johnw> benzrf: it's the right kan extension of a functor along the identity, what's the problem?
21:17:07 <johnw> no, along itself
21:17:12 <johnw> along the identity is yoneda
21:17:26 <johnw> forall r. (a -> m r) -> m r
21:17:29 <johnw> that's codensity
21:17:37 <johnw> it's a monad even if 'm' is not
21:17:43 <zq> "...'i know, i'll use lenses.' now they have two problems."
21:18:03 <benzrf> @let twoProblemsJoke _ = "WHO FUCKING CARES"
21:18:06 <lambdabot>  Defined.
21:18:16 <benzrf> > twoProblemsJoke "lens"
21:18:18 <lambdabot>  "WHO FUCKING CARES"
21:18:37 <zq> what's the optimal path to learning lenses?
21:18:55 <Ralith> using them as much as possible
21:18:55 <benzrf> zq: what do u want to know about them
21:19:02 <benzrf> how much do u want to understand
21:19:18 <benzrf> are u willing to be reborn as ur true self in the order of Profunctors
21:19:47 <zq> enough to use them and have a rough idea of their mechanism? i know there's a ton of category theory behind
21:19:51 <benzrf> do u swear to diligently pursue the ancient secrets of tensorial strength
21:19:53 <benzrf> :p
21:19:59 <benzrf> zq: plain lenses are not too Hardolaf
21:20:00 <benzrf> *hard
21:20:22 <benzrf> zq: what do u already know about lenses
21:20:40 <johnw> benzrf: you is only two more letters than u
21:20:55 <zq> element access is called "projection." lots of strange infixrs/ls
21:21:12 <zq> lots of template haskell to generate the getters and setters
21:21:39 <zq> whatever, i'll just learn it
21:21:49 <benzrf> johnw: i said 'u' 6 times
21:21:51 <glguy> Don't worry, you don't have to learn any operators to use lens, the template haskell is optional
21:21:54 <benzrf> that's a savings of 12 letters!
21:22:07 <johnw> a savings for you, a loss to my hope for humanity
21:22:21 <benzrf> johnw: if ur hope 4 humanity relies on people not abbreviating
21:22:23 * edwardk hands benrzf a prozac
21:22:26 <benzrf> then u have rather poor values
21:22:37 <Ralith> man, a whole 12 letters saved and all it cost you was people's respect
21:22:43 <benzrf> respect is overrated
21:22:47 * benzrf cries a little
21:23:11 <Hardolaf> benzrf: no you were right, I don't use plain lenses...
21:23:46 <Hardolaf> oh wait programming, nevermind :D
21:24:20 <merijn> benzrf: What if I already like profunctors but still don't like lens? :<
21:24:30 <benzrf> that is your choice and i respect that
21:25:27 <edwardk> what if i wrote it, but am still not sure i like lens? =)
21:25:51 <johnw> you don't get an opinion anymore edwardk
21:25:56 <edwardk> oh okay.
21:26:09 * edwardk puts away his attempt at pulling an Erik Meijer.
21:26:40 <johnw> cognitive dissonance ensures that everyone who puts in the effort to learn how lens works, must use and like lens
21:27:16 <benzrf> i put in a bunch of effort a while back
21:27:20 <benzrf> i dont think i like it very much
21:27:26 <benzrf> it's ok
21:27:30 <johnw> SHHH
21:27:39 * johnw hands benzrf another prozac
21:28:12 <edwardk> lens still strikes me as the best balance for a tool for the existing haskell ecosystem. if i was starting in new language from scratch? i'd probably do quite a bit differently, but the benefits of folks being able to write them without depending on the library are huge for adoption.
21:28:15 * benzrf vibrates ab it
21:28:34 <benzrf> edwardk: couldnt you do the same thing with just a profunctor package ,though
21:28:39 <benzrf> if you were doing profunctor lenses, i mean
21:28:40 <merijn> edwardk: Also, I <3 the shedding of aeson :)
21:28:49 <johnw> yeah, thanks for that
21:28:54 <edwardk> benzrf: profunctor lenses don't have a good adoption story.
21:28:57 <merijn> edwardk: That cuts the biggest lens dependencies that I wasn't already using :)
21:28:58 <benzrf> oh yeah?
21:29:42 <edwardk> benzrf: we don't have a story for indexed traversals/lenses for them, they are harder to write for the common lens/traversal case, they require more than the Prelude to build/use, etc.
21:29:53 <edwardk> the benefits start arising once you go all the way out to something like Hask.
21:30:38 <edwardk> then we can talk about the generalized notions of strength, prisms as lenses for another monoidal tensor, lenses into monad transformer stacks, lenses for day convolution into applicative stacks, lenses into stacks of functors, etc.
21:30:55 <edwardk> but you give up a lot to get there
21:31:06 <edwardk> and i don't have a story whereby you get to have both sets of benefits right now
21:31:16 <edwardk> and the existing toolbox is better for most users
21:31:39 <edwardk> merijn: that was pretty much entirely why we did it
21:32:08 <edwardk> merijn: not you in particular, but it was the most common complaint across all our users, that aeson had almost disjoint dependencies from the rest of the lib
21:32:22 <johnw> lens makes certain expressions *much* easier to write, for example, manipulating subsets of structure data within a Map kept in State
21:33:00 <johnw> and Prism manipulations are just magical, avoid tortuous "if" guarding and case analysis that would normally be needed
21:33:31 <benzrf> edwardk: i opened up the Hask code again... why are both Category and Category'' a thing?
21:33:55 <edwardk> benzrf: they exist because until 7.10 i can't have cycles that involve polymorphic recursion on kinds between class definitions. see ghc bug #9200.
21:34:19 <benzrf> cycle
21:34:20 <benzrf> s
21:34:30 <edwardk> benzrf: so i instead define functor and class separately, then bootstrap one off the other and move out through the silly ' business
21:34:51 <benzrf> oh i see
21:34:53 <edwardk> Functor referencing Category and Category referencing Functor (for its Hom)
21:35:01 <edwardk> but at different kinds throughout
21:35:05 <benzrf> greeaaat... which one's code should i read first then
21:35:14 <edwardk> start with the top of the file =P
21:35:19 <benzrf> Category.hs
21:35:34 <edwardk> and just accept that Category' or whatever will add in more stuff we want by the time it gets to a 'real' category
21:36:01 <edwardk> benzrf: afk a bit
21:39:33 <merijn> hmm
21:39:45 <merijn> If I want a where close over multiple patterns, am I just boned?
21:39:59 <benzrf> merijn: multiple patterns meanin?
21:40:14 <shachaf> merijn: You can use case.
21:40:21 <benzrf> merijn: do you mean like
21:40:28 <benzrf> func (Foo n) = v
21:40:32 <benzrf> func (Bar n) = v
21:40:32 <nomeata> merijn: yes, you are. but note that a where clause can cover multiple pattern guards (if they belong to one pattern)
21:40:35 <benzrf>   where v = n + 1
21:40:42 <benzrf> nomeata: dang it u beat me to say that
21:40:47 <nomeata> merijn: so that is often a good workaround
21:42:19 <merijn> oh, duh
21:42:43 <merijn> case/of works just as well, in this case, I think
21:52:50 <zereraz> I found a good link for beginners http://shuklan.com/haskell/
21:53:57 <mer7233> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTIN
21:53:57 <hkd2736> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTIN
21:53:57 <ShushMeeta> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WAS
21:53:57 <irg2749> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTIN
21:53:57 <hrb7440> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTIN
21:53:57 <ShahreBabu> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WAS
21:53:57 <tov9971> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTIN
21:53:57 <Blugh> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING 
21:53:57 <BingoBob> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTI
21:53:57 <mmz9853> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING 
21:53:57 <vzt4436> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTIN
21:53:57 <TunnGainda> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WAS
21:53:57 <Cage> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING H
21:53:57 <WaKoFB> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING
21:53:57 <uiw3286> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING 
21:53:57 <PhuRkiPeNa> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTI
21:53:57 <Guest78343> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTI
21:53:57 <TimBuck2> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING
21:53:57 <zdm5371> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING 
21:53:57 <MailME> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING H
21:53:57 <aub5888> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING 
21:53:59 <MunnayMian> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WAS
21:53:59 <MunnayMian> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WAS
21:54:01 <Fredster> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING
21:54:01 <Fredster> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING
21:54:01 <Fredster> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING
21:54:02 <WashBeson> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTIN
21:54:02 <WashBeson> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTIN
21:54:02 <WashBeson> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTIN
21:54:02 <eoo7271> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING 
21:54:02 --- mode: ChanServ set +o johnw
21:54:02 <eoo7271> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING 
21:54:02 <eoo7271> HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING HUMAN RESOURCES AND DIE YOU SNEAKY SUBHUMAN TURDS HEY FUCKING DIABETIC JUNKIES YOU RAN OUT OF INSULIN? YOU'D BETTER STOP WASTING 
21:54:06 --- mode: ChanServ set +o johnw
21:54:13 --- mode: ChanServ set +o johnw
21:54:36 --- mode: johnw set -o johnw
21:55:01 --- mode: ChanServ set +o glguy
21:55:09 --- mode: glguy set +b *!*@183.136.152.66
21:55:09 <merijn> Any cabal experts around that can help me figure out why the hell cabal refuses to build my executable?
21:55:13 <merijn> glguy: Too slow :p
21:55:23 <johnw> merijn: show me error text
21:55:42 <merijn> johnw: complains about hidden packages it shouldn't be looking for
21:55:47 <johnw> show me show me show me
21:56:03 <johnw> my cabal zen requires blankly staring at the text messages and then having a moment of enlightment
21:56:29 <ReinH> johnw: o/
21:56:34 <johnw> ReinH: o/!
21:57:23 <merijn> johnw: Oh, damn, I just broke my code while I was waiting for it to be later on the night, give me 1 sec to fix it :p
22:01:45 <jnoah> hey all. I'm playing around with aeson at the moment and have a question about parsing JSON. http://dpaste.com/26SAM8K is how I think it should be parsed. http://multiplayerrobot.com/About/Api#get-games-and-players is what I am parsing. However, decode keeps resulting in Nothing.
22:01:55 <jnoah> any help would be greatly appreciated
22:02:00 <merijn> johnw: http://lpaste.net/2094531610387939328
22:02:13 <johnw> jnoah: are there any optional fields?
22:02:17 <merijn> johnw: Keep in mind: None of those hs files are part of my executable and cabal shouldn't even be touching them
22:02:33 <jnoah> johnw: i don't know
22:02:34 <johnw> weird, it's like there is no build-depends setup
22:02:35 <merijn> johnw: The files mentioned are all part of the library in my cabal file upon which my executable depends
22:02:39 <jnoah> the api is horridly documented
22:02:45 <johnw> jnoah: the way you've written it, every field must be present for the record to parse
22:03:00 <jnoah> is it legal to make all optional?
22:03:04 <johnw> sure
22:03:08 <merijn> johnw: My executable only imports base, bytestring and modules from my library (my library builds just fine)
22:03:09 <jnoah> ok, i'll try that. thanks
22:03:18 <johnw> you can either use Maybe fields, or provide default values
22:03:25 <merijn> johnw: The imported modules are correctly listed in exposed-modules for my library
22:03:30 <jnoah> johnw: .:? ?
22:03:34 <johnw> yeah, I think that's it
22:03:45 <johnw> merijn: can I see your .cabal file?
22:04:19 <merijn> johnw: See the annotation: http://lpaste.net/2094531610387939328
22:05:09 <johnw> copy all your build-depends into the executable's build depends
22:05:10 <johnw> that will fix it
22:05:39 <merijn> johnw: But I don't want that, that means I have to do twice the changes all the time and I'm changing stuff alot still
22:05:43 <johnw> yep
22:05:48 <johnw> but that's life
22:06:01 <johnw> there's a way around it, but I can never remember what it is
22:06:09 <carter> merijn: either help dcoutts_ patch cabal to have namable stanzas
22:06:20 <carter> and use head once it gets merged in
22:06:24 <carter> or copy it in the mean time
22:06:26 <carter> OR BOTH
22:06:30 <merijn> johnw, carter: But my Main.hs doesn't depend on any of those libraries
22:06:41 <merijn> I only ever import modules from lambdamq
22:06:41 <glguy> jnoah: You don't want to recursively call "parseJSON"
22:07:01 <merijn> AFAIK executables don't have to list the transitive closure of their dependencies?!
22:07:08 <johnw> merijn: but it does if it's importing those modules
22:07:09 <monochrom> I don't understand. Parsing.hs is not listed under any other-modules or exposed-modules. that can't be right.
22:07:12 <johnw> merijn: don't ask me why
22:07:15 <merijn> johnw: It isn't
22:07:24 <johnw> really?  huh
22:07:25 <merijn> monochrom: Oh, you're right, that isn't right!
22:07:27 <jnoah> glguy: I was going off of http://the-singleton.com/2012/02/parsing-nested-json-in-haskell-with-aeson/
22:07:29 <monochrom> well ok, it can be right until you "cabal sdist"
22:07:32 <jnoah> glguy: what do you suggest instead?
22:07:36 <merijn> johnw: None of the mentioned hs files are imported by Main.hs
22:07:42 <glguy> jnoah: That isn't nested JSON, it's just normal old JSON
22:07:49 <johnw> something is trying to pull them in
22:08:25 <monochrom> but if Main.hs imports Parsing.hs imports Control.Monad.State.Strict, then you are explicitly depending on mtl.
22:08:30 <merijn> johnw: Those modules are all part of the library and I'm only import the four Exposed-Modules
22:08:41 <johnw> transitivity maybe?
22:08:44 <merijn> monochrom: Yeah, I added Parsing.hs to Other-Modules
22:08:59 <johnw> anyway, duplicating the depednencies will work
22:09:40 <merijn> johnw: That only works because cabal is doing something evvery wrong
22:09:54 <merijn> johnw: i.e. not linking against my built library
22:09:55 <johnw> granted
22:10:10 <merijn> I find that very worrisome
22:10:15 <glguy> jnoah: This is how that sample data is parsed by Aeson http://lpaste.net/109849
22:10:22 <merijn> I hope monochrom's sharp eye fixed it
22:10:26 --- mode: glguy set -o glguy
22:10:34 <merijn> hmm, nope
22:11:55 <jnoah> glguy: how did you get that?
22:12:19 <johnw> I bet he just parsed it untyped
22:12:28 <glguy> jnoah:   fmap decodeString (Data.ByteString.readFile "sample.json") :: IO (Maybe Value)
22:12:38 <johnw> which if you only need to snarf out a little bit of data, is much easier to work with if you use lens-aeson
22:12:38 <glguy> decodeStrict*
22:12:44 <jnoah> glguy: awesome, thanks. I'll use that from now on
22:13:13 <glguy> jnoah: I think your code is close to correct, but you just need to remove the calls to parseJSON
22:13:35 <glguy> jnoah: The indented syntax is c/o
22:13:37 <glguy> ?hackage pretty-show
22:13:38 <lambdabot> http://hackage.haskell.org/package/pretty-show
22:15:02 <merijn> ...
22:15:11 <merijn> Ok, so cabal/ghc is just braindead
22:15:37 <merijn> If the executable source is in the source tree it will just try and pull files in directly, rather than linking against the library
22:16:00 <glguy> yeah, you aren't supposed to put the executable and library in the same source directory
22:16:02 <jnoah> glguy: http://dpaste.com/119QXJ9 still Nothing
22:16:03 <merijn> I moved Main.hs and now it compiles
22:16:07 <jnoah> glguy: c/o+
22:16:12 <jnoah> c/o? *
22:19:03 <glguy> jnoah: care of, and don't parse the response as a "GamesAndPlayers" type, it's a "UserData"
22:19:18 <glguy> Notice how the same output doesn't contain the string GamesAndPlayers
22:19:38 <glguy> That's just the name of the object it returns
22:19:39 * hackagebot simple-pipe 0.0.0.20 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.20 (YoshikuniJujo)
22:20:16 * monochrom misreads pretty-show as pretty-slow and thinks: why would anyone call his/her package pretty slow? :)
22:20:52 <jnoah> glguy: key order doesn't matter, correct?
22:20:59 <glguy> jnoah: Correct
22:21:05 <monochrom> perhaps I should implement ackermann's function can put it in acme-pretty-slow :)
22:21:25 <johnw> monochrom: it was an improvement over ugly-slow
22:22:02 <monochrom> along with bogosort and unary arithmetic fibonacci
22:23:20 <glguy> jnoah: http://lpaste.net/109850
22:23:57 <carter> hah
22:24:19 <carter> monochrom: its even slow when you compute it through type class induction!
22:24:21 <carter> *slower
22:24:24 <merijn> monochrom: How about bitflip sort?
22:24:53 <merijn> Actually
22:25:06 <merijn> That'd have to be in IO in haskell
22:25:54 <merijn> monochrom: http://www.siafoo.net/algorithm/9
22:25:58 <jnoah> glguy: ooo, thanks
22:33:12 <Vulpyne> Hello. I'm having an issue getting the EitherT monad transform from the ContStuff (transformers CPS style) package to work. Here is a paste: http://lpaste.net/8588571433804759040
22:33:49 <carter> i gues friday night #haskell is more lively than thursdaynight
22:33:54 <Vulpyne> The issue is that it embeds the types for a successful return or an exception in two separate continuations, which means calling another function in the same monad stack fails if the return type is different.
22:34:11 <Vulpyne> I'm not smart enough to figure out if there's a way around that problem.
22:34:47 <merijn> carter: Hacking haskell is my idea of a party ;)
22:35:31 <Vulpyne> Well, I could always liftIO and run other function in a whole separate stack and then convert the result. But I really don't want to do that.
22:36:06 <jollygood> hello. why is this program using 1.6 GB of ram before crashing due to lack of memory? I am parsing a 10 GB log file, but I expected laziness to do its thing there. why isn't it, and how can I make it work? http://lpaste.net/109851
22:37:10 <Vulpyne> jollygood: Might want to use Text.Lazy (assuming you meant Data.Text)
22:37:23 <merijn> oh
22:37:30 <jollygood> it takes two minutes to reach that point btw
22:37:34 <merijn> If that's using String, you probably shouldn't, yeah
22:37:57 <Vulpyne> Oh, yeah. It's not even using Text, it just imports it for some reason.
22:38:22 <jollygood> I am importing Text.Read for readMaybe
22:38:24 <solatis> shouldn't you be using some lazy bytestream?
22:39:16 <jollygood> I am processing the file one character at a time so wouldn't string be appropriate here?
22:40:06 <jollygood> and why am I getting such a high memory usage when IO is lazy?
22:40:10 <merijn> solatis: Not really for text processing
22:40:29 <pjdelport> jollygood: How are you compiling? -O2?
22:41:29 <Vulpyne> I'd use foldl' (+) 0 instead of sum. You can also use mapMaybe f instead of catMaybes . map f
22:41:35 <jollygood> recompiling with -O2, it is possible I didn't use it
22:42:13 <hamid> :t (+++)
22:42:15 <lambdabot> ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
22:42:15 <jollygood> getting 2 MB memory usage now :)
22:42:27 <Vulpyne> Anyone have any ideas regarding my question?
22:42:33 <jollygood> is it because sum is usin foldl instead of foldl'? so we need -O2
22:42:53 <Vulpyne> jollygood: I doubt -O2 will help you there, but you can try my sum suggestion. It's a drop in replacement.
22:43:10 <Vulpyne> You'll need to import Data.List
22:43:21 <pjdelport> jollygood: By default, sum uses foldl yes, but there are rewrite rules to rewrite it to foldl' for types that are known strict (like Int, in this case).
22:43:44 <pjdelport> jollygood: Assuming -O2 fixed it, the cause was probably that optimization not being applied, yes.
22:43:51 <jollygood> Vulpyne program has been running for about a minute now, still using only 2MB of memory
22:44:17 <jollygood> it would have used at least half a GB at this point without -O2
22:44:27 <Vulpyne> jollygood: Yay. Using foldl' (+) 0 instead of sum probably would have done the same thing, although without optimization your programs will run rather slow.
22:44:39 <Vulpyne> I'd rather be explicit than trust the compiler to rewrite my stuff.
22:46:04 <Vulpyne> Anyone have any idea regarding my problem? Paste showing the issue: http://lpaste.net/8588571433804759040
22:46:17 <jollygood> as far as I know we always want to use foldl', so why did they add foldl' instead of rewriting foldl?
22:46:35 <jnoah> glguy: so a field may either be a Null or String, how can I handle that?
22:46:46 <glguy> Use a "Maybe String"
22:47:23 <merijn> Vulpyne: Why do you have an Either within the EitherT?
22:47:53 <Vulpyne> merijn: The type for the transformer is EitherT r e m a = EitherT { getEitherT :: (a -> m r) -> (e -> m r) -> m r }
22:48:29 <Vulpyne> merijn: I'm using evalEitherT from here: https://hackage.haskell.org/package/contstuff-1.2.6/docs/Control-ContStuff-Trans.html#g:5
22:48:48 <jnoah> glguy: sweet! that did it. Turns out there was an optional field missing and that Null/String field. Thanks for the help.
22:49:01 <glguy> You're welcome ^_^
22:49:02 <merijn> Vulpyne: Well, the problem is your TestT type
22:49:12 <merijn> Vulpyne: It forces the exception and result to always be the same
22:49:57 <merijn> Vulpyne: "type TestT m a = EitherT (Either String a) String m a"
22:50:08 <Vulpyne> merijn: Yeah, I'm just not sure how to work around it so that it acts like the EitherT transformer from a more normal monad transformer package.
22:50:08 <merijn> Vulpyne: But the transformer will only let the last 'a' change values
22:50:26 <merijn> Vulpyne: Well, why is TestT specifying the error and return to be the same type?
22:51:04 <merijn> Vulpyne: Why not "type TestT m a = EitherT (Either String MyError) String m a"?
22:51:06 <merijn> Or whatever
22:51:16 <Vulpyne> merijn: The String type is the error type.
22:51:45 <Vulpyne> merijn: The internal type of the transformer is (a -> m r) -> (e -> m r) -> m r
22:52:10 <merijn> Vulpyne: I can see that
22:52:12 <Vulpyne> merijn: It has a continuation for each case - error or normal return.
22:52:23 <merijn> Vulpyne: But for some reason you're picking "e" to be "Either String a"
22:52:28 <merijn> And I don't see why you would do that
22:53:34 <merijn> Vulpyne: Your current TestT type says that the error is *always* "Either String a", where 'a' is the return type of a single computation
22:53:37 <merijn> That makes no sense to me
22:53:56 <merijn> oh, wait
22:54:02 <merijn> hmm, I flipped two variables
22:54:21 <Vulpyne> Yeah. :(
22:54:46 <Vulpyne> "r" needs to be something that can handle either the error or the normal return.
22:55:05 <merijn> Vulpyne: Right, but why bother setting 'r' to Either?
22:55:14 <merijn> That kinda defeats the purpose of this transformer?
22:56:02 <Vulpyne> So TestT IO () = (() -> m (Right ())) -> (String -> m (Left String)) -> m ()
22:56:16 <Vulpyne> Er...
22:56:25 <Vulpyne> So TestT IO () = (() -> m (Right ())) -> (String -> m (Left String)) -> m (Either String ())
22:57:05 <Vulpyne> Both continuations and the final result are "m r"
22:57:13 <merijn> Vulpyne: What's wrong with "type TestT m a = EitherT MyResult String m a"?
22:57:38 <merijn> Where MyResult is whatever you want
22:57:40 <Vulpyne> Well, different functions are going to return different things.
22:58:10 <Vulpyne> An average either/exception transformer looks like: newtype EitherT e m a = EitherT { runEitherT :: m (Either e a) }
22:58:13 <merijn> tbh, I think this definition of EitherT is rather silly anyway
22:58:29 <merijn> It requires you to fix the result value in advance
22:58:36 <Vulpyne> Yeah, that is the issue.
22:58:47 <merijn> Vulpyne: So why use it?
22:58:50 <Vulpyne> ContStuff uses the continuation monad to create transformerns.
22:59:04 <Vulpyne> merijn: Because it's a lot faster than the normal style of transformers.
22:59:32 <Vulpyne> merijn: https://www.haskell.org/haskellwiki/Performance/Monads
22:59:43 <merijn> Vulpyne: And you've profiled your code and determined this speed difference matters?
22:59:44 * hackagebot simple-pipe 0.0.0.21 - simple pipeline library like conduit  http://hackage.haskell.org/package/simple-pipe-0.0.0.21 (YoshikuniJujo)
23:00:09 <Vulpyne> merijn: Nope! But it is a very performance critical application (which doesn't exist yet...)
23:00:39 <merijn> Vulpyne: There's a ton of high-speed libraries that seem to run just fine using traditional transformers
23:00:40 <Vulpyne> merijn: Also, I didn't realize that I would run into issues like this trying to use it instead of transformers or mtl.
23:01:36 <merijn> Vulpyne: What does performance critical mean?
23:01:43 <merijn> Vulpyne: How fast does it have to be?
23:01:48 <merijn> And doing what
23:02:43 <Vulpyne> merijn: Means it needs to be fast. Really, the faster the better usually. It's going to be handling the logic for SIP call handling.
23:03:24 <merijn> Vulpyne: Nanoseconds, microseconds, tens of microseconds, 100s of microseconds?
23:03:33 <merijn> milliseconds?
23:03:42 <Vulpyne> People say that premature optimization is the root of all evil, but I try to think about efficiency from the start. If I have a choice of using one library that is faster than another and can be used in some sort of reasonable way, I'd generally take that route.
23:04:34 <Vulpyne> merijn: It's hard to answer that question without context. For example, the less resources it uses the more resources are available for other things, can use less expensive hardware, etc.
23:05:03 <Vulpyne> It's also going to be heavily concurrent, so thinking about how long a single request takes isn't necessarily useful.
23:05:13 <Vulpyne> If it's adequate, I mean.
23:05:25 <merijn> Vulpyne: Just today I read a post about applying this trick to some streaming libraries, but that was to optimise an inner loop from 15ms to 4ms
23:05:26 <Vulpyne> SIP is phone calls, so the less latency there, the better.
23:06:00 <Vulpyne> merijn: This ContStuff package seemed to essentially be a drop in replacement for the transformers package.
23:06:24 <merijn> Vulpyne: I think you're prematurely optimising in a way that's making your life really hard from the start :)
23:06:30 <Vulpyne> If I just can't make it work in a reasonable way, I can either bite the bullet and use transformers or dispense with monad transformers entirely and pass around my state manually.
23:07:04 <Vulpyne> merijn: That's often the case... However, this time I think it wasn't entirely my fault.
23:07:27 <Vulpyne> There's nothing in the documentation about requiring special consideration with their EitherT transformer.
23:08:13 <Vulpyne> And the results of evalEitherT emulate the result from transformers.
23:08:42 <Vulpyne> Oh well.
23:09:06 <Vulpyne> You're the only person that replied, so I appreciate that!
23:09:45 * hackagebot twitter-conduit 0.0.5.6 - Twitter API package with conduit interface and Streaming API support.  http://hackage.haskell.org/package/twitter-conduit-0.0.5.6 (TakahiroHimura)
23:14:46 * hackagebot xml-pipe 0.0.0.10 - XML parser which uses simple-pipe  http://hackage.haskell.org/package/xml-pipe-0.0.0.10 (YoshikuniJujo)
23:27:58 <Laquendi> Vulpyne: i don't think there is anything wrong with using performant libraries
23:28:59 <merijn> Laquendi: No one said that, but using one that is more complex to use than the main library used by everyone (transformers) is not a very productive start
23:29:00 <Laquendi> but you might want to build intuition for Cont with simpler stuff
23:29:33 <merijn> Why not just implement everything with transformers first and then if it works but is too slow you can always move to the Cont based stuff
23:29:55 <Vulpyne> That would imply it's possible to move to the Cont based stuff. :)
23:30:04 <Laquendi> why learn haskell when you can use python
23:30:17 <Laquendi> everyone uses python
23:30:57 <merijn> Vulpyne: Why not? It may require a bunch of rewriting, but large scale refactorings like that are usually rather easy in haskell
23:31:15 <merijn> Vulpyne: Just change the type, fix compile errors until the compiler is happy and then you know you've covered all cases
23:31:38 <Vulpyne> merijn: Because of the issue where any functions running in the monad must have the same type as a return value.
23:31:46 <Vulpyne> That would seem to limit its usefulness considerably.
23:32:05 <Vulpyne> And I suspect that actually unwrapping the whole thing would pretty much negative any performance advantage.
23:32:15 <merijn> Vulpyne: That's not a requirement of the monad, that's one of your type alias
23:32:43 <Vulpyne> merijn: The type of the monad was (a -> m r) -> (a - > m r) -> m r
23:32:45 <merijn> Vulpyne: The cont transformer merely requires you to pick the result type in advance
23:32:48 <merijn> Right
23:32:57 <merijn> no
23:33:06 <merijn> Vulpyne: the second 'a' is an 'e'
23:33:14 <Vulpyne> Yeah, my mistake.
23:33:25 <Laquendi> Vulpyne: just leave r as type parameter until you know what it is
23:33:48 <Vulpyne> I know what it is: it's the final result of the computation.
23:34:18 <Laquendi> but test2 doesn't depend on the final result of the computation
23:34:33 <shachaf> @quote shachaf is.monad
23:34:33 <lambdabot> shachaf says: Hmm, so is monad a useful function?
23:34:45 <Vulpyne> The r pretty much has to imply the type variable a, unless you don't care about results at all.
23:34:58 <merijn> Vulpyne: Huh? No, why?
23:35:16 <Vulpyne> After your computation finishes, you get an "r".
23:35:30 <shachaf> Vulpyne: At the very end your r might be a, if you use runCont with id. Maybe that's what you mean here.
23:35:36 <Vulpyne> From that, you need to be able to extract an error result or a successful result where the latter can be a different type in each case.
23:35:50 <merijn> Vulpyne: You may want to read up on CPS first
23:35:52 <Vulpyne> shachaf: Then how would you determine if there was an exception?
23:35:53 <shachaf> But you'll have a lot of intermediate smaller (Cont r a) actions with r different from a.
23:36:15 <shachaf> I haven't read the previous discussion so maybe I'm not answering whatever you're asking.
23:36:35 <Vulpyne> shachaf: Did you look at my hpaste link?
23:37:05 <shachaf> No.
23:37:16 <Vulpyne> shachaf: http://lpaste.net/8588571433804759040
23:37:16 <shachaf> Oh, there's no Cont there in the first place.
23:37:28 <shachaf> Oh, you're using a CPSy EitherT.
23:37:29 <Vulpyne> It uses the ContStuff package, which is monad transformers implemented with Cont.
23:37:32 <Vulpyne> Yeah.
23:37:48 <Vulpyne> The problem is that internally, the transformer has one continuation for success and another for exception.
23:38:04 <shachaf> I don't see a package with that name.
23:38:06 <Vulpyne> Which must both return the same type, since the computation has to result in a type.
23:38:11 <Vulpyne> contstuff
23:38:14 <merijn> Vulpyne: The problem is that you're fixing 'r' even though there's no reason too fix 'r' in advance
23:38:16 <shachaf> Oh, lowercase.
23:38:41 <Vulpyne> shachaf: https://hackage.haskell.org/package/contstuff-1.2.6/docs/Control-ContStuff-Trans.html#g:5
23:38:46 <Vulpyne> That's the relevant section of the docs.
23:39:02 <shachaf> Yep.
23:39:05 <Vulpyne> The problem is because the result type is encoded in the continuation, calling other functions in the same monad cause a type conflict.
23:39:09 <shachaf> I would start with the regular EitherT instead of this one.
23:39:21 <Vulpyne> shachaf: The advantage is this one is faster!
23:39:31 <Vulpyne> Certainly making the normal EitherT work is no challenge. :)
23:39:41 <shachaf> Maybe it is.
23:39:52 <shachaf> But it's also "the same", so whatever isn't working here shouldn't be working there either.
23:39:54 <Vulpyne> Why would it be?
23:40:09 <Vulpyne> It's actually not the same.
23:40:28 <Vulpyne> (a -> m r) -> (e -> m r) -> m r vs m (Either e a)
23:40:34 <shachaf> I mean isomorphic.
23:40:45 <shachaf> But, hmm, the m is on the inside here?
23:40:47 <merijn> Vulpyne: The result type is only encoded because your type alias enforces that
23:41:15 <Vulpyne> merijn: Yes, but there has to be *some* sort of result type that can distinguish between a successful completion and an exception.
23:41:33 <Vulpyne> merijn: Either is the natural type to use here, but if you have an idea for something that would work I'm all ears.
23:41:38 <merijn> shachaf: Wouldn't it make more sense that it's running the functions using >>= on the existing "m e" or "m a"? then it wouldn't be on the outside
23:41:56 <merijn> Vulpyne: My point is, you don't need to decide on that type until you actually run it
23:42:05 <shachaf> Vulpyne: EitherT takes three arguments and you're giving it four?
23:42:09 <merijn> Vulpyne: Your premature commitment is what's screwing you over
23:42:18 <shachaf> Wait, there's an r.
23:42:30 <Vulpyne> With m (Either e a), each function in the monad transformer can return a different successful result without an issue.
23:42:32 <shachaf> OK, I see.
23:42:41 <shachaf> Why is that r not foralled?
23:43:13 <merijn> Completely unrelated: Is there a pragma for displaying warnings?
23:43:18 <hamid> Is there an specific usage for function "const" like "seq"?
23:43:23 <Vulpyne> evalEitherT :: Applicative m => EitherT (Either e a) e m a -> m (Either e a)
23:43:25 <merijn> Sorta like CPP's "#warn" ?
23:43:33 <Vulpyne> evalEitherT (EitherT c) = c (pure . Right) (pure . Left)
23:43:47 <glguy> Merijn: if it makes you feel better, I'll mention you've been saying that for a while and you're right
23:44:05 <merijn> glguy: I know, but thanks anyway :)
23:44:13 <glguy> About the type
23:44:34 <merijn> Oh, I guess I could just enable -XCPP and use actual #warn?
23:44:37 <Vulpyne> merijn: Well, it wouldn't be the first time my premature commitment screwed me over, but I think I'd learn something that would be useful in other situations if it turned out there was a solution.
23:44:40 <merijn> Althought that's a bit ghetto
23:44:44 <Vulpyne> But it's looking like there isn't one.
23:45:11 <shachaf> Vulpyne: I find this type moderately suspicious now.
23:45:14 <shachaf> Are you sure it's the right one?
23:45:19 <merijn> Vulpyne: The point I'm making is, while for the FINAL type 'r' and 'a' need to be correlated, you're fixing 'r' for all INTERMEDIATE steps too
23:45:33 <Vulpyne> shachaf: Which one? evalEitherT or the actual transformer?
23:45:42 <merijn> Vulpyne: Which means you require 'r' and 'a' to be correlated for EVERY step, rather than just the last
23:45:43 <shachaf> The transformer.
23:46:18 <Vulpyne> shachaf: You can read the full source: https://hackage.haskell.org/package/contstuff-1.2.6/docs/src/Control-ContStuff-Trans.html#EitherT
23:46:30 <shachaf> Yes, I saw it.
23:47:15 <Vulpyne> shachaf: It's the real type.
23:47:33 <glguy> Vulpyne , you understand that the issue is your type synonym and not that you are using the CP's stuff , right?
23:47:34 <Vulpyne> merijn: What would you do differently?
23:47:43 <Vulpyne> glguy: Not yet!
23:48:17 <glguy> OK, then listen to merijn for a bit because this is hell to type out
23:48:39 <shachaf> Yes, what merijn is saying sounds right.
23:48:43 <merijn> Vulpyne: This whole thing can be done more nicely with RankNTypes, but I'll skip over that bit for simplicity, I'd write "type TestT r m a = EitherT r String m a"
23:49:02 <shachaf> On the type -- I understand that it's in a module on Hackage. I'm not sure it does what you want.
23:49:50 <merijn> Vulpyne: This means your intermediate a's may not be related to 'r', but you don't care. Then before you run, you fix "Either String Foo" where Foo is the actual result you want
23:50:40 <shachaf> Ignoring the "r" issue, this EitherT is behaving like data EitherT e m a = LeftT (m a) | RightT (m a)
23:51:00 <shachaf> Er, data EitherT e m a = LeftT (m e) | RightT (m a)
23:51:03 <shachaf> Which is quite different from m (Either e a)
23:51:52 <merijn> Vulpyne: See annotation: http://lpaste.net/8588571433804759040
23:52:41 <merijn> Vulpyne: Now when test1 uses test2, test2 has type "EitherT (Either String ()) String IO Int"
23:53:12 <merijn> Vulpyne: Notice that you're initial TestT synynom made test2 "EitherT (Either String Int) String IO Int", because you fixed 'r' and 'a' to always be related
23:53:34 <merijn> Which is why you couldn't use it within test1, which had a different result type
23:53:56 <Vulpyne> merijn: I think I understand. Thank you for taking the time to explain!
23:54:41 <shachaf> I would now advise figuring out whether this EitherT is really the type that you want, and why it makes things "faster", if it does.
23:55:29 <Vulpyne> Well, pretty much everything I have read about transformers says that doing it in the CPS way is substantially faster.
23:57:34 <shachaf> It does a specific thing which is worth understanding. It's faster in some contexts.
23:58:19 <shachaf> Can you find a way to measure it in this case? :-)
23:58:52 <merijn> shachaf: No, because he's prematurely optimising like I warned him a while back :)
23:58:57 <Vulpyne> shachaf: I'm prematurely optimizing.
23:59:00 <Vulpyne> Yes, what he said.
23:59:21 <shachaf> OK. Then please make sure what you're doing is actually an optimization.
23:59:30 <shachaf> The main property of an optimization is that it preserves correctness. :-)
